uint64_t _FSTBuilderBfsContext_DiscoverState(uint64_t a1, _DWORD *a2)
{
  unsigned int v4;
  unsigned int *v5;
  _DWORD *v6;
  unint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  _DWORD *v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t result;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  unint64_t v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;

  v33 = 0;
  v4 = a2[6];
  v5 = *(unsigned int **)(a1 + 40);
  v6 = (_DWORD *)*((void *)v5 + 1);
  v7 = *((void *)v5 + 2) - (void)v6;
  v8 = v4 % (v7 >> 2);
  v9 = &v6[v8];
  while (1)
  {
    v10 = *v9;
    if ((v10 & 0x80000000) != 0) {
      break;
    }
    v9 = (unsigned int *)(*((void *)v5 + 4) + 8 * v10);
    if (v4 == v9[1]) {
      goto LABEL_34;
    }
  }
  LODWORD(v10) = v5[12];
  if (v10 != -1)
  {
    v11 = (int)v10;
    v12 = *((void *)v5 + 4);
    v13 = (_DWORD *)(v12 + 8 * (int)v10);
    v5[12] = (*v13 & 0xBFFFFFFF) - 1;
    *v13 = 0;
    v13[1] = v4;
LABEL_33:
    *(_DWORD *)(v12 + 8 * v11) = v6[v8];
    v6[v8] = v10;
LABEL_34:
    v30 = a2[2];
    if (v30 < 0) {
      v31 = a2[7];
    }
    else {
      v31 = 0;
    }
    if (*(_DWORD *)(a1 + 48)) {
      v32 = v10;
    }
    else {
      v32 = v4;
    }
    return (***(uint64_t (****)(void, uint64_t, void, uint64_t, BOOL))(a1 + 24))(*(void *)(a1 + 24) - *(void *)(**(void **)(a1 + 24) + 24), v32, v30 & 0xF0000000, v31, v4 == *(_DWORD *)(a1 + 32));
  }
  v12 = *((void *)v5 + 4);
  v14 = (_DWORD *)*((void *)v5 + 5);
  v10 = ((unint64_t)v14 - v12) >> 3;
  v15 = 2 * (v7 >> 2);
  if (v15 >= v10)
  {
    v20 = ((unint64_t)v14 - v12) >> 3;
  }
  else
  {
    v16 = v15 | 1;
    v17 = *v5;
    if (v16 <= v17)
    {
      v10 = 4 * v17;
    }
    else
    {
      if (v16 <= 8) {
        v18 = 8;
      }
      else {
        v18 = v16;
      }
      v10 = 4 * v18;
      v6 = (_DWORD *)OOCAllocator_Realloc(*(void *)(a1 + 8), (uint64_t)v6, v10, &v33);
      v5 = *(unsigned int **)(a1 + 40);
      *((void *)v5 + 1) = v6;
      result = v33;
      if (v33) {
        return result;
      }
      *v5 = v18;
      v7 &= 0x3FFFFFFFCuLL;
      *((void *)v5 + 2) = (char *)v6 + v7;
    }
    v21 = (v7 >> 1) & 0xFFFFFFFE | 1;
    *((void *)v5 + 2) = &v6[v21];
    cstdlib_memset(v6, 255, v10);
    v5 = *(unsigned int **)(a1 + 40);
    v12 = *((void *)v5 + 4);
    v14 = (_DWORD *)*((void *)v5 + 5);
    v20 = ((unint64_t)v14 - v12) >> 3;
    LODWORD(v10) = v20;
    if (v20)
    {
      v22 = 0;
      v23 = (_DWORD *)*((void *)v5 + 4);
      do
      {
        if (((*v23 + 1) & 0x40000000) == 0)
        {
          result = v33;
          if (v33) {
            return result;
          }
          v24 = v23[1] - (v23[1] / v21) * (unint64_t)v21;
          v25 = *((void *)v5 + 1);
          *v23 = *(_DWORD *)(v25 + 4 * v24);
          *(_DWORD *)(v25 + 4 * v24) = v22;
        }
        ++v22;
        v23 += 2;
      }
      while ((((unint64_t)v14 - v12) >> 3) != v22);
    }
  }
  v26 = v10 + 1;
  v27 = v5[6];
  if ((int)v10 + 1 <= v27)
  {
LABEL_32:
    *((void *)v5 + 5) = v14 + 2;
    *v14 = 0;
    v14[1] = v4;
    v6 = (_DWORD *)*((void *)v5 + 1);
    v8 = v4 % ((*((void *)v5 + 2) - (void)v6) >> 2);
    v11 = (int)v10;
    goto LABEL_33;
  }
  v28 = 2 * v27;
  if (2 * v27 >= v27 + 1000000) {
    v28 = v27 + 1000000;
  }
  if (v28 > v26) {
    v26 = v28;
  }
  if (v26 <= 8) {
    v29 = 8;
  }
  else {
    v29 = v26;
  }
  v12 = OOCAllocator_Realloc(*(void *)(a1 + 8), v12, 8 * v29, &v33);
  v5 = *(unsigned int **)(a1 + 40);
  *((void *)v5 + 4) = v12;
  result = v33;
  if (!v33)
  {
    v5[6] = v29;
    v14 = (_DWORD *)(v12 + 8 * v20);
    *((void *)v5 + 5) = v14;
    goto LABEL_32;
  }
  return result;
}

uint64_t _FSTBuilderBfsContext_ExploreArc(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  LODWORD(v4) = a2;
  unsigned int v58 = 0;
  v6 = *(unsigned int **)(a1 + 40);
  v7 = (_DWORD *)*((void *)v6 + 1);
  uint64_t v8 = *((void *)v6 + 2);
  unint64_t v9 = v8 - (void)v7;
  unint64_t v10 = (unint64_t)(v8 - (void)v7) >> 2;
  uint64_t v11 = a2 % v10;
  v12 = &v7[v11];
  while (1)
  {
    uint64_t v13 = *v12;
    if ((v13 & 0x80000000) != 0) {
      break;
    }
    uint64_t v14 = *((void *)v6 + 4);
    v12 = (unsigned int *)(v14 + 8 * v13);
    if (v12[1] == v4)
    {
      v16 = (int *)(a1 + 48);
      int v15 = *(_DWORD *)(a1 + 48);
      if (v15) {
        uint64_t v4 = v13;
      }
      else {
        uint64_t v4 = v4;
      }
LABEL_39:
      unsigned int v35 = *a3;
      unint64_t v36 = v8 - (void)v7;
      unint64_t v37 = (unint64_t)(v8 - (void)v7) >> 2;
      uint64_t v38 = *a3 % v37;
      v39 = &v7[v38];
      while (1)
      {
        uint64_t v40 = *v39;
        if ((v40 & 0x80000000) != 0) {
          break;
        }
        v39 = (unsigned int *)(v14 + 8 * v40);
        if (v35 == v39[1]) {
          goto LABEL_72;
        }
      }
      LODWORD(v40) = v6[12];
      if (v40 != -1)
      {
        uint64_t v41 = (int)v40;
        v42 = (_DWORD *)(v14 + 8 * (int)v40);
        v6[12] = (*v42 & 0xBFFFFFFF) - 1;
        _DWORD *v42 = 0;
        v42[1] = v35;
LABEL_71:
        *(_DWORD *)(v14 + 8 * v41) = v7[v38];
        v7[v38] = v40;
        unsigned int v35 = *a3;
        int v15 = *v16;
LABEL_72:
        if (v15) {
          uint64_t v57 = v40;
        }
        else {
          uint64_t v57 = v35;
        }
        return (*(uint64_t (**)(void, uint64_t, void, void, void, uint64_t))(**(void **)(a1 + 24) + 8))(*(void *)(a1 + 24) - *(void *)(**(void **)(a1 + 24) + 24), v4, a3[1], a3[2], a3[3], v57);
      }
      v43 = (_DWORD *)*((void *)v6 + 5);
      uint64_t v40 = ((unint64_t)v43 - v14) >> 3;
      if (2 * (int)v37 >= v40)
      {
        unint64_t v47 = ((unint64_t)v43 - v14) >> 3;
        goto LABEL_60;
      }
      unsigned int v44 = (2 * v37) | 1;
      uint64_t v45 = *v6;
      if (v44 <= v45)
      {
        uint64_t v40 = 4 * v45;
        goto LABEL_54;
      }
      if (v44 <= 8) {
        unsigned int v46 = 8;
      }
      else {
        unsigned int v46 = (2 * v37) | 1;
      }
      uint64_t v40 = 4 * v46;
      v7 = (_DWORD *)OOCAllocator_Realloc(*(void *)(a1 + 8), (uint64_t)v7, v40, &v58);
      v6 = *(unsigned int **)(a1 + 40);
      *((void *)v6 + 1) = v7;
      uint64_t result = v58;
      if (!v58)
      {
        unsigned int *v6 = v46;
        v36 &= 0x3FFFFFFFCuLL;
        *((void *)v6 + 2) = (char *)v7 + v36;
LABEL_54:
        unint64_t v48 = (v36 >> 1) & 0xFFFFFFFE | 1;
        *((void *)v6 + 2) = &v7[v48];
        cstdlib_memset(v7, 255, v40);
        v6 = *(unsigned int **)(a1 + 40);
        uint64_t v14 = *((void *)v6 + 4);
        v43 = (_DWORD *)*((void *)v6 + 5);
        unint64_t v47 = ((unint64_t)v43 - v14) >> 3;
        LODWORD(v40) = v47;
        if (v47)
        {
          uint64_t v49 = 0;
          v50 = (_DWORD *)*((void *)v6 + 4);
          do
          {
            if (((*v50 + 1) & 0x40000000) == 0)
            {
              uint64_t result = v58;
              if (v58) {
                return result;
              }
              unint64_t v51 = v50[1]
                  - (v50[1] / v48) * (unint64_t)v48;
              uint64_t v52 = *((void *)v6 + 1);
              _DWORD *v50 = *(_DWORD *)(v52 + 4 * v51);
              *(_DWORD *)(v52 + 4 * v51) = v49;
            }
            ++v49;
            v50 += 2;
          }
          while ((((unint64_t)v43 - v14) >> 3) != v49);
        }
LABEL_60:
        unsigned int v53 = v40 + 1;
        unsigned int v54 = v6[6];
        if ((int)v40 + 1 <= v54)
        {
LABEL_70:
          *((void *)v6 + 5) = v43 + 2;
          _DWORD *v43 = 0;
          v43[1] = v35;
          v7 = (_DWORD *)*((void *)v6 + 1);
          uint64_t v38 = v35 % ((*((void *)v6 + 2) - (void)v7) >> 2);
          uint64_t v41 = (int)v40;
          goto LABEL_71;
        }
        unsigned int v55 = 2 * v54;
        if (2 * v54 >= v54 + 1000000) {
          unsigned int v55 = v54 + 1000000;
        }
        if (v55 > v53) {
          unsigned int v53 = v55;
        }
        if (v53 <= 8) {
          unsigned int v56 = 8;
        }
        else {
          unsigned int v56 = v53;
        }
        uint64_t v14 = OOCAllocator_Realloc(*(void *)(a1 + 8), v14, 8 * v56, &v58);
        v6 = *(unsigned int **)(a1 + 40);
        *((void *)v6 + 4) = v14;
        uint64_t result = v58;
        if (!v58)
        {
          v6[6] = v56;
          v43 = (_DWORD *)(v14 + 8 * v47);
          *((void *)v6 + 5) = v43;
          goto LABEL_70;
        }
      }
      return result;
    }
  }
  LODWORD(v17) = v6[12];
  if (v17 == -1)
  {
    uint64_t v14 = *((void *)v6 + 4);
    v20 = (_DWORD *)*((void *)v6 + 5);
    uint64_t v17 = ((unint64_t)v20 - v14) >> 3;
    if (2 * (int)v10 >= v17)
    {
      unint64_t v25 = ((unint64_t)v20 - v14) >> 3;
    }
    else
    {
      unsigned int v21 = (2 * v10) | 1;
      uint64_t v22 = *v6;
      if (v21 <= v22)
      {
        uint64_t v17 = 4 * v22;
      }
      else
      {
        if (v21 <= 8) {
          unsigned int v23 = 8;
        }
        else {
          unsigned int v23 = (2 * v10) | 1;
        }
        uint64_t v17 = 4 * v23;
        v7 = (_DWORD *)OOCAllocator_Realloc(*(void *)(a1 + 8), (uint64_t)v7, v17, &v58);
        v6 = *(unsigned int **)(a1 + 40);
        *((void *)v6 + 1) = v7;
        uint64_t result = v58;
        if (v58) {
          return result;
        }
        unsigned int *v6 = v23;
        v9 &= 0x3FFFFFFFCuLL;
        *((void *)v6 + 2) = (char *)v7 + v9;
      }
      unint64_t v26 = (v9 >> 1) & 0xFFFFFFFE | 1;
      *((void *)v6 + 2) = &v7[v26];
      cstdlib_memset(v7, 255, v17);
      v6 = *(unsigned int **)(a1 + 40);
      uint64_t v14 = *((void *)v6 + 4);
      v20 = (_DWORD *)*((void *)v6 + 5);
      unint64_t v25 = ((unint64_t)v20 - v14) >> 3;
      LODWORD(v17) = v25;
      if (v25)
      {
        uint64_t v27 = 0;
        v28 = (_DWORD *)*((void *)v6 + 4);
        do
        {
          if (((*v28 + 1) & 0x40000000) == 0)
          {
            uint64_t result = v58;
            if (v58) {
              return result;
            }
            unint64_t v29 = v28[1]
                - (v28[1] / v26) * (unint64_t)v26;
            uint64_t v30 = *((void *)v6 + 1);
            _DWORD *v28 = *(_DWORD *)(v30 + 4 * v29);
            *(_DWORD *)(v30 + 4 * v29) = v27;
          }
          ++v27;
          v28 += 2;
        }
        while ((((unint64_t)v20 - v14) >> 3) != v27);
      }
    }
    unsigned int v31 = v17 + 1;
    unsigned int v32 = v6[6];
    if ((int)v17 + 1 > v32)
    {
      unsigned int v33 = 2 * v32;
      if (2 * v32 >= v32 + 1000000) {
        unsigned int v33 = v32 + 1000000;
      }
      if (v33 > v31) {
        unsigned int v31 = v33;
      }
      if (v31 <= 8) {
        unsigned int v34 = 8;
      }
      else {
        unsigned int v34 = v31;
      }
      uint64_t v14 = OOCAllocator_Realloc(*(void *)(a1 + 8), v14, 8 * v34, &v58);
      v6 = *(unsigned int **)(a1 + 40);
      *((void *)v6 + 4) = v14;
      uint64_t result = v58;
      if (v58) {
        return result;
      }
      v6[6] = v34;
      v20 = (_DWORD *)(v14 + 8 * v25);
      *((void *)v6 + 5) = v20;
    }
    *((void *)v6 + 5) = v20 + 2;
    _DWORD *v20 = 0;
    v20[1] = v4;
    v7 = (_DWORD *)*((void *)v6 + 1);
    uint64_t v8 = *((void *)v6 + 2);
    uint64_t v11 = v4 % ((unint64_t)(v8 - (void)v7) >> 2);
    uint64_t v18 = (int)v17;
  }
  else
  {
    uint64_t v18 = (int)v17;
    uint64_t v14 = *((void *)v6 + 4);
    v19 = (_DWORD *)(v14 + 8 * (int)v17);
    v6[12] = (*v19 & 0xBFFFFFFF) - 1;
    _DWORD *v19 = 0;
    v19[1] = v4;
  }
  *(_DWORD *)(v14 + 8 * v18) = v7[v11];
  v7[v11] = v17;
  uint64_t result = v58;
  v16 = (int *)(a1 + 48);
  int v15 = *(_DWORD *)(a1 + 48);
  if (v15) {
    uint64_t v4 = v17;
  }
  else {
    uint64_t v4 = v4;
  }
  if (!v58) {
    goto LABEL_39;
  }
  return result;
}

uint64_t FSTBuilderBfsContext_ReleaseStateMap(uint64_t a1, void *a2, void *a3)
{
  *a2 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  *a3 = *(void *)(a1 + 8);
  return 0;
}

uint64_t PNEW_FSTBuilderBfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 56, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = FSTBuilderBfsContext_Con(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *a6 = v12;
    }
  }
  return result;
}

void *GetFSTBuilderBfsContextClass()
{
  return &__FSTBuilderBfsContext;
}

uint64_t IFSTStateQueue_Create(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v8 = *(_DWORD *)(a3 + 44) & 0x200;
  if ((v8 & *(_DWORD *)(a3 + 40)) == 0 && v8 != 0)
  {
    *(void *)&v19[0] = 0;
    uint64_t result = PNEW_FSTStateQueueTopoSort_Con(a1, a2, a3, (uint64_t *)v19);
    if (!result) {
      *a4 = *(void *)&v19[0] + 8;
    }
    return result;
  }
  long long v20 = 0u;
  memset(v19, 0, sizeof(v19));
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t result = FSTSCCDfsContext_Con((uint64_t)v19, a2, a3);
  if (!result)
  {
    uint64_t result = FSTDfs2Context_Dfs((uint64_t)v19);
    unsigned int v21 = result;
    if (!result)
    {
      FSTSCCDfsContext_ReleaseScc((uint64_t)v19, &v18, &v17);
      if (!DWORD2(v20))
      {
        uint64_t v16 = 0;
        LODWORD(v15) = *(void *)(a3 + 40) & 0xFFFFFDFF;
        HIDWORD(v15) = (*(void *)(a3 + 40) | 0x20000000200uLL) >> 32;
        *(void *)(a3 + 40) = v15;
        uint64_t result = PNEW_FSTStateQueueTopoSort_ConFromOrder(a1, a2, v18, v17, a2, &v16);
        unsigned int v21 = result;
        if (result) {
          return result;
        }
LABEL_21:
        *a4 = v16 + 8;
        return (*(uint64_t (**)(_OWORD *))(*(void *)&v19[0] + 16))(v19);
      }
      uint64_t v16 = 0;
      uint64_t v10 = v20;
      *(void *)(a3 + 40) |= 0x20000000200uLL;
      uint64_t v11 = 4 * v10;
      uint64_t v12 = OOCAllocator_Malloc(a2, 4 * v10, &v21);
      uint64_t result = v21;
      if (!v21)
      {
        if (v10)
        {
          uint64_t v13 = v11 + v12;
          if (v11 + v12 <= (unint64_t)(v12 + 4)) {
            uint64_t v13 = v12 + 4;
          }
          memset_pattern16((void *)v12, &unk_2206E3270, ((v13 + ~v12) & 0xFFFFFFFFFFFFFFFCLL) + 4);
        }
        uint64_t result = PNEW_FSTStateQueueSCC_Con(a1, a2, v10, v12, v18, v17, a2, &v16);
        unsigned int v21 = result;
        if (!result)
        {
          if (v12) {
            OOCAllocator_Free(a2, v12);
          }
          goto LABEL_21;
        }
      }
    }
  }
  return result;
}

void FSTCompact2BfsBuilder_Con(void *a1, uint64_t a2)
{
  FSTCompact2Builder_Con(a1, a2);
  if (!v3) {
    *a1 = &__FSTCompact2BfsBuilder;
  }
}

void FSTCompact2BfsBuilder_ConToStream(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  FSTCompact2Builder_ConToStream(a1, a2, a3, a4, a5);
  if (!v6) {
    *a1 = &__FSTCompact2BfsBuilder;
  }
}

uint64_t FSTCompact2BfsBuilder_ConvertFST(int8x8_t *a1, uint64_t a2)
{
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  uint64_t v3 = (uint64_t)a1[1];
  v4.i32[0] = *(_DWORD *)(a2 + 44) & 0x3FFFF & *(_DWORD *)(a2 + 40);
  v4.i32[1] = *(_DWORD *)(a2 + 44) & 0x3FFFF;
  a1[8] = (int8x8_t)(*(void *)&vorr_s8(vand_s8(a1[8], (int8x8_t)0x300000003), v4) | 0x10000000100);
  v5 = a1 + 9;
  uint64_t result = FSTBuilderBfsContext_Con((uint64_t)v7, v3, a2, (uint64_t)&a1[9], 1);
  if (!result)
  {
    uint64_t result = FSTBuilderBfsContext_Bfs((uint64_t)v7);
    if (!result)
    {
      uint64_t result = (*(uint64_t (**)(_OWORD *))(*(void *)&v7[0] + 16))(v7);
      if (!result) {
        return (*(uint64_t (**)(char *))(*(void *)v5 + 16))((char *)v5 - *(void *)(*(void *)v5 + 24));
      }
    }
  }
  return result;
}

void PNEW_FSTCompact2BfsBuilder_Con(uint64_t a1, uint64_t a2, void *a3)
{
  int v8 = 0;
  int v6 = (void *)OOCAllocator_Malloc(a1, 112, &v8);
  if (!v8)
  {
    FSTCompact2Builder_Con(v6, a2);
    if (v7)
    {
      int v8 = v7;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
    }
    else
    {
      void *v6 = &__FSTCompact2BfsBuilder;
      *a3 = v6;
    }
  }
}

void PNEW_FSTCompact2BfsBuilder_ConToStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  int v14 = 0;
  uint64_t v12 = (void *)OOCAllocator_Malloc(a1, 112, &v14);
  if (!v14)
  {
    FSTCompact2Builder_ConToStream(v12, a2, a3, a4, a5);
    if (v13)
    {
      int v14 = v13;
      OOCAllocator_Free(a1, (uint64_t)v12);
      *a6 = 0;
    }
    else
    {
      void *v12 = &__FSTCompact2BfsBuilder;
      *a6 = v12;
    }
  }
}

void *GetFSTCompact2BfsBuilderClass()
{
  return &__FSTCompact2BfsBuilder;
}

uint64_t fstcache(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, __int32 a5, uint64_t *a6)
{
  if (*(_DWORD *)(a3 + 32) == 13)
  {
    *a6 = a3;
    if (*(_DWORD *)(a3 + 128) >= a4 || (*(_DWORD *)(a3 + 168) = a5, uint64_t result = FSTCache_Resize(a3, a4), !result))
    {
      if (*(_DWORD *)(a3 + 168) == a5)
      {
        return 0;
      }
      else
      {
        *(_DWORD *)(a3 + 168) = a5;
        if (a5 == 1)
        {
          return __FSTCache_BuildBFSPrefill(a3);
        }
        else
        {
          return __FSTCache_DeletePrefill((void *)a3);
        }
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t result = PNEW_FSTCache_Con(a1, a2, a3, a4, a5, &v10);
    if (!result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 32))(a3);
      if (!result) {
        *a6 = (uint64_t)v10;
      }
    }
  }
  return result;
}

uint64_t FSTCache_Resize(uint64_t a1, unsigned int a2)
{
  unsigned int v24 = 0;
  if (*(_DWORD *)(a1 + 128) == a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 112))(a1);
  }
  uint64_t v5 = *(void *)(a1 + 24);
  int v6 = (uint64_t *)(a1 + 104);
  int v7 = *(uint64_t **)(a1 + 104);
  *(_DWORD *)(*(void *)(a1 + 48) + 40) = a2 + 10;
  unint64_t v8 = *(void *)(a1 + 112);
  while ((unint64_t)v7 < v8)
  {
    uint64_t v9 = *v7;
    int v10 = *(_DWORD *)(*v7 + 8);
    if ((v10 & 0x3FFFFFF) == 1)
    {
      if ((v10 & 0x8000000) != 0) {
        uint64_t v11 = *(void *)(v9 + 16);
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t result = FSTStatePool_PushFSTState(v11, v9);
      if (result) {
        return result;
      }
      unint64_t v8 = *(void *)(a1 + 112);
    }
    else
    {
      *(_DWORD *)(v9 + 8) = v10 - 1;
      if ((v10 & 0x3FFFFFF) == 0) {
        return 9;
      }
    }
    v7 += 4;
  }
  unsigned int v24 = 0;
  uint64_t v12 = *(void *)(a1 + 80);
  if (v12) {
    OOCAllocator_Free(v5, v12);
  }
  if (*v6) {
    OOCAllocator_Free(v5, *v6);
  }
  if (!a2)
  {
    *(_DWORD *)(a1 + 72) = 1;
    uint64_t v15 = OOCAllocator_Malloc(v5, 4, &v24);
    *(void *)(a1 + 80) = v15;
    uint64_t result = v24;
    if (v24) {
      return result;
    }
    uint64_t v16 = *(unsigned int *)(a1 + 72);
    unint64_t v17 = v15 + 4 * v16;
    *(void *)(a1 + 88) = v17;
    if (v16)
    {
      if (v17 <= v15 + 4) {
        unint64_t v17 = v15 + 4;
      }
      memset((void *)v15, 255, ((v17 + ~v15) & 0xFFFFFFFFFFFFFFFCLL) + 4);
    }
    *(_DWORD *)(a1 + 96) = 0;
    uint64_t *v6 = 0;
    *(void *)(a1 + 112) = 0;
    goto LABEL_28;
  }
  *(_DWORD *)(a1 + 72) = a2;
  uint64_t v13 = OOCAllocator_Malloc(v5, 4 * a2, &v24);
  *(void *)(a1 + 80) = v13;
  uint64_t result = v24;
  if (!v24)
  {
    *(void *)(a1 + 88) = v13 + 4 * *(unsigned int *)(a1 + 72);
    *(_DWORD *)(a1 + 96) = a2;
    uint64_t v14 = OOCAllocator_Malloc(v5, 32 * a2, &v24);
    *(void *)(a1 + 104) = v14;
    uint64_t result = v24;
    if (!v24)
    {
      *(void *)(a1 + 112) = v14 + 32 * *(unsigned int *)(a1 + 96);
      *(_DWORD *)(a1 + 120) = -1;
      cstdlib_memset(*(void **)(a1 + 80), 255, 4 * *(unsigned int *)(a1 + 72));
      *(void *)(a1 + 112) = *(void *)(a1 + 104);
LABEL_28:
      *(_DWORD *)(a1 + 120) = -1;
      uint64_t v18 = *(void *)(a1 + 160);
      if (v18)
      {
        uint64_t v19 = *(void *)(a1 + 152);
        if (v19 > (unint64_t)a2)
        {
          if (v19 > a2)
          {
            for (i = (uint64_t *)(v18 + 8 * a2); (unint64_t)i < v18 + 8 * v19; ++i)
            {
              uint64_t v21 = *i;
              int v22 = *(_DWORD *)(*i + 8);
              if ((v22 & 0x3FFFFFF) == 1)
              {
                if ((v22 & 0x8000000) != 0) {
                  uint64_t v23 = *(void *)(v21 + 16);
                }
                else {
                  uint64_t v23 = 0;
                }
                uint64_t result = FSTStatePool_PushFSTState(v23, *i);
                unsigned int v24 = result;
                if (result) {
                  return result;
                }
                uint64_t v19 = *(void *)(a1 + 152);
                uint64_t v18 = *(void *)(a1 + 160);
              }
              else
              {
                *(_DWORD *)(v21 + 8) = v22 - 1;
                if ((v22 & 0x3FFFFFF) == 0) {
                  return 9;
                }
                unsigned int v24 = 0;
              }
            }
          }
          if (a2)
          {
            *(void *)(a1 + 160) = OOCAllocator_Realloc(v5, v18, 8 * a2, &v24);
            uint64_t result = v24;
            if (v24) {
              return result;
            }
          }
          else
          {
            OOCAllocator_Free(v5, v18);
            *(void *)(a1 + 160) = 0;
          }
          *(void *)(a1 + 152) = a2;
        }
      }
      *(_DWORD *)(a1 + 128) = a2;
      return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 112))(a1);
    }
  }
  return result;
}

uint64_t __FSTCache_BuildBFSPrefill(uint64_t a1)
{
  unsigned int v12 = 0;
  uint64_t v11 = 0;
  long long v10 = 0u;
  memset(v9, 0, sizeof(v9));
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t v3 = (unsigned int *)OOCAllocator_Malloc(v2, 4 * *(unsigned int *)(a1 + 128), &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = FSTCountBfsContext_Con(v9, v2, *(void *)(a1 + 64));
    unsigned int v12 = result;
    if (!result)
    {
      uint64_t result = FSTBfsContext_BfsPartial((uint64_t)v9, v3, *(unsigned int *)(a1 + 128));
      unsigned int v12 = result;
      if (!result)
      {
        *(void *)(a1 + 152) = DWORD1(v10);
        uint64_t result = (*(uint64_t (**)(_OWORD *))(*(void *)&v9[0] + 16))(v9);
        unsigned int v12 = result;
        if (!result)
        {
          uint64_t v5 = *(void *)(a1 + 152);
          uint64_t v6 = OOCAllocator_Malloc(v2, 8 * v5, &v12);
          *(void *)(a1 + 160) = v6;
          uint64_t result = v12;
          if (!v12)
          {
            if (v5 < 1)
            {
LABEL_10:
              OOCAllocator_Free(v2, (uint64_t)v3);
              return v12;
            }
            else
            {
              int v7 = &v3[v5];
              unint64_t v8 = v3;
              while (1)
              {
                uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), *v8, 8, v6);
                unsigned int v12 = result;
                if (result) {
                  break;
                }
                ++v8;
                v6 += 8;
                if (v8 >= v7) {
                  goto LABEL_10;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t __FSTCache_DeletePrefill(void *a1)
{
  uint64_t v1 = a1[20];
  if (!v1) {
    return 0;
  }
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[19];
  if (v4 >= 1)
  {
    for (i = (uint64_t *)a1[20]; (unint64_t)i < v1 + 8 * v4; ++i)
    {
      uint64_t v6 = *i;
      int v7 = *(_DWORD *)(*i + 8);
      if ((v7 & 0x3FFFFFF) == 1)
      {
        if ((v7 & 0x8000000) != 0) {
          uint64_t v8 = *(void *)(v6 + 16);
        }
        else {
          uint64_t v8 = 0;
        }
        uint64_t result = FSTStatePool_PushFSTState(v8, *i);
        if (result) {
          return result;
        }
        uint64_t v4 = a1[19];
        uint64_t v1 = a1[20];
      }
      else
      {
        *(_DWORD *)(v6 + 8) = v7 - 1;
        if ((v7 & 0x3FFFFFF) == 0) {
          return 9;
        }
      }
    }
  }
  OOCAllocator_Free(v3, v1);
  uint64_t result = 0;
  a1[20] = 0;
  return result;
}

uint64_t PNEW_FSTCache_Con(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int32 a4, __int32 a5, int8x8_t **a6)
{
  unsigned int v14 = 0;
  unsigned int v12 = (int8x8_t *)OOCAllocator_Malloc(a1, 184, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = FSTCache_Con(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      v12[2] = (int8x8_t)a1;
      *a6 = v12;
    }
  }
  return result;
}

uint64_t FSTCache_Con(int8x8_t *a1, uint64_t a2, uint64_t a3, unsigned __int32 a4, __int32 a5)
{
  uint64_t result = _FSTUnaryOperator_Con((uint64_t)a1, a2, a3);
  unsigned int v14 = result;
  if (!result)
  {
    *a1 = (int8x8_t)&__FSTCache;
    a1[16].i32[0] = a4;
    a1[21].i32[0] = a5;
    a1[19] = 0;
    a1[20] = 0;
    a1[4].i32[0] = 13;
    a1[9].i32[0] = a4;
    uint64_t v11 = OOCAllocator_Malloc(a2, 4 * a4, &v14);
    a1[10] = (int8x8_t)v11;
    uint64_t result = v14;
    if (!v14)
    {
      a1[11] = (int8x8_t)(v11 + 4 * a1[9].u32[0]);
      uint64_t v12 = a1[16].u32[0];
      a1[12].i32[0] = v12;
      uint64_t v13 = OOCAllocator_Malloc(a2, 32 * v12, &v14);
      a1[13] = (int8x8_t)v13;
      uint64_t result = v14;
      if (!v14)
      {
        a1[14] = (int8x8_t)(v13 + 32 * a1[12].u32[0]);
        a1[15].i32[0] = -1;
        cstdlib_memset(*(void **)&a1[10], 255, 4 * a1[9].u32[0]);
        a1[14] = a1[13];
        a1[15].i32[0] = -1;
        if (!a1[21].i32[0] || (result = __FSTCache_BuildBFSPrefill((uint64_t)a1), (unsigned int v14 = result) == 0))
        {
          *(_DWORD *)(*(void *)(a3 + 48) + 40) = a4 + 10;
          uint64_t result = (*(uint64_t (**)(int8x8_t *))(*(void *)a1 + 112))(a1);
          unsigned int v14 = result;
          if (!result)
          {
            a1[21].i32[1] = 0;
            a1[22].i32[0] = 0;
            _FSTUnaryOperator_InheritProperties(a1, a3, 0, 256, 0, 261887);
            return v14;
          }
        }
      }
    }
  }
  return result;
}

uint64_t FSTCache_Des(void *a1)
{
  uint64_t v2 = a1[3];
  *(_DWORD *)(*(void *)(a1[8] + 48) + 40) = 10;
  uint64_t v4 = (uint64_t *)a1[13];
  unint64_t v3 = a1[14];
  while ((unint64_t)v4 < v3)
  {
    uint64_t v5 = *v4;
    int v6 = *(_DWORD *)(*v4 + 8);
    if ((v6 & 0x3FFFFFF) == 1)
    {
      if ((v6 & 0x8000000) != 0) {
        uint64_t v7 = *(void *)(v5 + 16);
      }
      else {
        uint64_t v7 = 0;
      }
      uint64_t result = FSTStatePool_PushFSTState(v7, v5);
      if (result) {
        return result;
      }
      unint64_t v3 = a1[14];
    }
    else
    {
      *(_DWORD *)(v5 + 8) = v6 - 1;
      if ((v6 & 0x3FFFFFF) == 0) {
        return 9;
      }
    }
    v4 += 4;
  }
  uint64_t v8 = a1[10];
  if (v8) {
    OOCAllocator_Free(v2, v8);
  }
  uint64_t v9 = a1[13];
  if (v9) {
    OOCAllocator_Free(v2, v9);
  }
  uint64_t result = __FSTCache_DeletePrefill(a1);
  if (!result)
  {
    return FSTUnaryOperator_Des((uint64_t)a1);
  }
  return result;
}

uint64_t FSTCache_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v11 = 0;
  *a4 = 0;
  if (!__FSTCache_HasState(a1, a2, &v11))
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, a3, a4);
    if (result) {
      return result;
    }
    if (!*a4) {
      return 0;
    }
    uint64_t result = __FSTCache_InsertState(a1, *a4);
    if (result) {
      return result;
    }
LABEL_8:
    uint64_t v9 = *a4;
    if (!*a4) {
      return 0;
    }
    goto LABEL_9;
  }
  uint64_t v8 = v11;
  if (!FST_CheckQuery(*(_DWORD *)(*v11 + 8) & 0xF0000000, a3)) {
    goto LABEL_8;
  }
  uint64_t v9 = *v8;
  *a4 = *v8;
  if (!v9) {
    return 0;
  }
LABEL_9:
  if (*(_DWORD *)(a1 + 128))
  {
    uint64_t result = 0;
    ++*(_DWORD *)(v9 + 8);
    return result;
  }
  return 0;
}

uint64_t __FSTCache_HasState(uint64_t a1, unsigned int a2, void *a3)
{
  if (!*(_DWORD *)(a1 + 128)) {
    return 0;
  }
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 80)
                       + 4 * (a2 % ((*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2)));
  if ((v3 & 0x80000000) != 0)
  {
LABEL_6:
    uint64_t result = 0;
    *a3 = 0;
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 104);
    while (*(_DWORD *)(*(void *)(v4 + 32 * v3) + 24) != a2)
    {
      uint64_t v3 = *(unsigned int *)(v4 + 32 * v3 + 24);
      if ((v3 & 0x80000000) != 0) {
        goto LABEL_6;
      }
    }
    uint64_t v6 = v4 + 32 * v3;
    *a3 = v6;
    uint64_t v7 = *(void *)(a1 + 136);
    if (v6 != v7)
    {
      if (*(void *)(a1 + 144) == v6)
      {
        uint64_t v10 = *(void *)(v4 + 32 * v3 + 16);
        *(void *)(a1 + 144) = v10;
        *(void *)(v10 + 8) = 0;
      }
      else
      {
        uint64_t v8 = v4 + 32 * v3;
        uint64_t v9 = *(void *)(v8 + 16);
        *(void *)(v9 + 8) = *(void *)(v8 + 8);
        *(void *)(*(void *)(v8 + 8) + 16) = v9;
      }
      *(void *)(v7 + 16) = v6;
      uint64_t v11 = v4 + 32 * v3;
      *(void *)(v11 + 8) = v7;
      *(void *)(v11 + 16) = 0;
      *(void *)(a1 + 136) = v6;
    }
    return 1;
  }
  return result;
}

uint64_t __FSTCache_InsertState(uint64_t a1, uint64_t a2)
{
  unsigned int v55 = 0;
  int v2 = *(_DWORD *)(a1 + 128);
  if (!v2) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v6 = *(void *)(a1 + 112);
  uint64_t v7 = (unint64_t)(v6 - v5) >> 5;
  if (v2 == v7)
  {
    uint64_t v8 = *(uint64_t **)(a1 + 144);
    unint64_t v9 = ((unint64_t)v8 - v5) >> 5;
    uint64_t v10 = (int)(((uint64_t)v8 - v5) >> 5);
    uint64_t v11 = (int *)(v5 + 32 * v10);
    uint64_t v12 = *(void *)(a1 + 80);
    unint64_t v13 = (unint64_t)(*(void *)(a1 + 88) - v12) >> 2;
    uint64_t v14 = *(_DWORD *)(*(void *)v11 + 24) % v13;
    int v17 = v11[6];
    uint64_t v16 = v11 + 6;
    int v15 = v17;
    unsigned int v18 = *(_DWORD *)(v12 + 4 * v14);
    for (i = -1; (v18 & 0x80000000) == 0; unsigned int v18 = *(_DWORD *)(v5 + 32 * v18 + 24))
    {
      if (v18 == v9) {
        break;
      }
      unsigned int i = v18;
    }
    int v20 = *(_DWORD *)(a1 + 120);
    *(_DWORD *)(a1 + 120) = v9;
    int *v16 = (v20 + 1) | 0x40000000;
    if ((i & 0x80000000) != 0 && v15 < 0)
    {
      int v15 = -1;
    }
    else if ((i & 0x80000000) == 0)
    {
      *(_DWORD *)(v5 + 32 * i + 24) = v15;
LABEL_18:
      uint64_t v27 = *v8;
      int v28 = *(_DWORD *)(*v8 + 8);
      if ((v28 & 0x3FFFFFF) == 1)
      {
        if ((v28 & 0x8000000) != 0) {
          uint64_t v29 = *(void *)(v27 + 16);
        }
        else {
          uint64_t v29 = 0;
        }
        uint64_t result = FSTStatePool_PushFSTState(v29, *v8);
        unsigned int v55 = result;
        if (result) {
          return result;
        }
        uint64_t v5 = *(void *)(a1 + 104);
        uint64_t v12 = *(void *)(a1 + 80);
        uint64_t v8 = *(uint64_t **)(a1 + 144);
        unint64_t v13 = (unint64_t)(*(void *)(a1 + 88) - v12) >> 2;
      }
      else
      {
        *(_DWORD *)(v27 + 8) = v28 - 1;
        if ((v28 & 0x3FFFFFF) == 0) {
          return 9;
        }
        unsigned int v55 = 0;
      }
      uint64_t v34 = v5 + 32 * v10;
      *(void *)uint64_t v34 = a2;
      unsigned int v35 = *(_DWORD *)(a2 + 24) % v13;
      *(_DWORD *)(v34 + 24) = *(_DWORD *)(v12 + 4 * v35);
      *(_DWORD *)(v12 + 4 * v35) = v9;
      uint64_t v36 = v8[2];
      *(void *)(a1 + 144) = v36;
      *(void *)(v36 + 8) = 0;
      goto LABEL_55;
    }
    *(_DWORD *)(v12 + 4 * v14) = v15;
    goto LABEL_18;
  }
  unsigned int v22 = *(_DWORD *)(a2 + 24);
  uint64_t v23 = *(_DWORD **)(a1 + 80);
  unint64_t v24 = *(void *)(a1 + 88) - (void)v23;
  LODWORD(v9) = v23[v22 % (v24 >> 2)];
  if ((v9 & 0x80000000) == 0)
  {
    while (v22 != *(_DWORD *)(*(void *)(v5 + 32 * v9) + 24))
    {
      LODWORD(v9) = *(_DWORD *)(v5 + 32 * v9 + 24);
      if ((v9 & 0x80000000) != 0) {
        goto LABEL_13;
      }
    }
    goto LABEL_55;
  }
LABEL_13:
  int v25 = *(_DWORD *)(a1 + 120);
  if (v25 != -1)
  {
    uint64_t v26 = v25;
    uint64_t v6 = v5 + 32 * v25;
    *(_DWORD *)(a1 + 120) = (*(_DWORD *)(v6 + 24) & 0xBFFFFFFF) - 1;
    *(void *)uint64_t v6 = a2;
    LODWORD(v7) = v25;
LABEL_54:
    *(void *)(v6 + 8) = 0;
    *(void *)(v6 + 16) = 0;
    *(void *)(v6 + 24) = 0;
    uint64_t v50 = *(void *)(a1 + 80);
    unsigned int v51 = v22 % ((unint64_t)(*(void *)(a1 + 88) - v50) >> 2);
    uint64_t v5 = *(void *)(a1 + 104);
    *(_DWORD *)(v5 + 32 * v26 + 24) = *(_DWORD *)(v50 + 4 * v51);
    *(_DWORD *)(v50 + 4 * v51) = v7;
    LODWORD(v9) = v7;
LABEL_55:
    uint64_t v52 = v5 + 32 * (int)v9;
    if (!*(void *)(a1 + 144)) {
      *(void *)(a1 + 144) = v52;
    }
    uint64_t v53 = *(void *)(a1 + 136);
    if (v53) {
      *(void *)(v53 + 16) = v52;
    }
    uint64_t v54 = v5 + 32 * (int)v9;
    *(void *)(v54 + 8) = v53;
    *(void *)(v54 + 16) = 0;
    *(void *)(a1 + 136) = v52;
    return v55;
  }
  unsigned int v30 = 2 * (v24 >> 2);
  if (v30 >= v7)
  {
    unint64_t v37 = (unint64_t)(v6 - v5) >> 5;
  }
  else
  {
    unsigned int v31 = v30 | 1;
    uint64_t v32 = *(unsigned int *)(a1 + 72);
    if (v31 <= v32)
    {
      uint64_t v7 = 4 * v32;
    }
    else
    {
      if (v31 <= 8) {
        unsigned int v33 = 8;
      }
      else {
        unsigned int v33 = v31;
      }
      uint64_t v7 = 4 * v33;
      uint64_t v23 = (_DWORD *)OOCAllocator_Realloc(*(void *)(a1 + 24), *(void *)(a1 + 80), v7, &v55);
      *(void *)(a1 + 80) = v23;
      uint64_t result = v55;
      if (v55) {
        return result;
      }
      *(_DWORD *)(a1 + 72) = v33;
      v24 &= 0x3FFFFFFFCuLL;
    }
    unint64_t v38 = (v24 >> 1) & 0xFFFFFFFE | 1;
    *(void *)(a1 + 88) = &v23[v38];
    cstdlib_memset(v23, 255, v7);
    uint64_t v5 = *(void *)(a1 + 104);
    uint64_t v6 = *(void *)(a1 + 112);
    unint64_t v37 = (unint64_t)(v6 - v5) >> 5;
    LODWORD(v7) = v37;
    if (v37)
    {
      uint64_t v39 = 0;
      uint64_t v40 = (_DWORD *)(v5 + 24);
      do
      {
        if (((*v40 + 1) & 0x40000000) == 0)
        {
          uint64_t result = v55;
          if (v55) {
            return result;
          }
          unint64_t v41 = *(unsigned int *)(*((void *)v40 - 3) + 24);
          uint64_t v42 = v41 - (v41 / v38) * (unint64_t)v38;
          uint64_t v43 = *(void *)(a1 + 80);
          *uint64_t v40 = *(_DWORD *)(v43 + 4 * v42);
          *(_DWORD *)(v43 + 4 * v42) = v39;
        }
        ++v39;
        v40 += 8;
      }
      while (((unint64_t)(v6 - v5) >> 5) != v39);
    }
  }
  unsigned int v44 = v7 + 1;
  unsigned int v45 = *(_DWORD *)(a1 + 96);
  if ((int)v7 + 1 <= v45)
  {
LABEL_53:
    *(void *)(a1 + 112) = v6 + 32;
    *(void *)uint64_t v6 = a2;
    uint64_t v26 = (int)v7;
    goto LABEL_54;
  }
  unsigned int v46 = 2 * v45;
  unsigned int v47 = v45 + 1000000;
  if (v46 >= v47) {
    unsigned int v46 = v47;
  }
  if (v46 > v44) {
    unsigned int v44 = v46;
  }
  if (v44 <= 8) {
    unsigned int v48 = 8;
  }
  else {
    unsigned int v48 = v44;
  }
  uint64_t v49 = OOCAllocator_Realloc(*(void *)(a1 + 24), v5, 32 * v48, &v55);
  *(void *)(a1 + 104) = v49;
  uint64_t result = v55;
  if (!v55)
  {
    *(_DWORD *)(a1 + 96) = v48;
    uint64_t v6 = v49 + 32 * v37;
    goto LABEL_53;
  }
  return result;
}

uint64_t FSTCache_GetFinalStateWeight(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v8 = 0;
  unint64_t v9 = 0;
  if (__FSTCache_HasState(a1, a2, &v9))
  {
    uint64_t v6 = v9;
LABEL_3:
    uint64_t result = 0;
    *a3 = *(_DWORD *)(*v6 + 28);
    return result;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, 8, &v8);
  if (!result)
  {
    uint64_t result = __FSTCache_InsertState(a1, v8);
    if (!result)
    {
      uint64_t v6 = &v8;
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t FSTCache_GetMaxBranchFactor(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 136))(*(void *)(a1 + 64));
}

uint64_t FSTCache_GetMemoryInfo(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 64) + 96))(*(void *)(a1 + 64));
  uint64_t v2 = *(void *)(a1 + 160);
  if (v2 && (uint64_t v3 = *(void *)(a1 + 152), v3 >= 1))
  {
    int v4 = 0;
    unint64_t v5 = v2 + 8 * v3;
    unint64_t v6 = *(void *)(a1 + 160);
    do
    {
      uint64_t v7 = *(void *)(*(void *)v6 + 56);
      if (v7 || (uint64_t v7 = *(void *)(*(void *)v6 + 40)) != 0) {
        LODWORD(v7) = *(_DWORD *)(v7 - 4);
      }
      v4 += 16 * v7 + 64;
      v6 += 8;
    }
    while (v6 < v5);
  }
  else
  {
    int v4 = 0;
  }
  for (unint64_t i = *(void *)(a1 + 104); i < *(void *)(a1 + 112); i += 32)
  {
    uint64_t v9 = *(void *)(*(void *)i + 56);
    if (v9 || (uint64_t v9 = *(void *)(*(void *)i + 40)) != 0) {
      LODWORD(v9) = *(_DWORD *)(v9 - 4);
    }
    v4 += 16 * v9 + 64;
  }
  uint64_t v10 = 32 * *(unsigned int *)(a1 + 96) + 4 * *(unsigned int *)(a1 + 72) + 184;
  if (v2) {
    v10 += 8 * *(void *)(a1 + 152);
  }
  return v10;
}

uint64_t FSTCache_GetStateFlags(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  if (__FSTCache_HasState(a1, a2, &v9))
  {
    unint64_t v6 = v9;
LABEL_3:
    uint64_t result = 0;
    *a3 = *(_DWORD *)(*v6 + 8) & 0xF0000000;
    return result;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, 8, &v8);
  if (!result)
  {
    uint64_t result = __FSTCache_InsertState(a1, v8);
    if (!result)
    {
      unint64_t v6 = &v8;
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t FSTCache_Reset(uint64_t a1)
{
  uint64_t v3 = *(uint64_t **)(a1 + 104);
  unint64_t v2 = *(void *)(a1 + 112);
  while ((unint64_t)v3 < v2)
  {
    uint64_t v4 = *v3;
    int v5 = *(_DWORD *)(*v3 + 8);
    if ((v5 & 0x3FFFFFF) == 1)
    {
      if ((v5 & 0x8000000) != 0) {
        uint64_t v6 = *(void *)(v4 + 16);
      }
      else {
        uint64_t v6 = 0;
      }
      uint64_t result = FSTStatePool_PushFSTState(v6, v4);
      if (result) {
        return result;
      }
      unint64_t v2 = *(void *)(a1 + 112);
    }
    else
    {
      *(_DWORD *)(v4 + 8) = v5 - 1;
      if ((v5 & 0x3FFFFFF) == 0) {
        return 9;
      }
    }
    v3 += 4;
  }
  cstdlib_memset(*(void **)(a1 + 80), 255, 4 * *(unsigned int *)(a1 + 72));
  *(void *)(a1 + 136) = 0;
  uint64_t v7 = (uint64_t *)(a1 + 136);
  uint64_t v8 = *(void *)(a1 + 104);
  *(void *)(a1 + 112) = v8;
  *(_DWORD *)(a1 + 120) = -1;
  *(void *)(a1 + 144) = 0;
  if (!*(_DWORD *)(a1 + 168)) {
    return FSTUnaryOperator_Reset(a1);
  }
  unsigned int v45 = 0;
  uint64_t v9 = *(void *)(a1 + 152);
  if (v9 <= 0) {
    return FSTUnaryOperator_Reset(a1);
  }
  uint64_t v10 = 0;
  uint64_t v11 = *(uint64_t **)(a1 + 160);
  unint64_t v12 = (unint64_t)&v11[v9];
  while (1)
  {
    uint64_t result = v45;
    if (v45) {
      return result;
    }
    uint64_t v13 = *v11;
    unsigned int v14 = *(_DWORD *)(*v11 + 24);
    int v15 = *(unsigned int **)(a1 + 80);
    unint64_t v16 = *(void *)(a1 + 88) - (void)v15;
    unint64_t v17 = v16 >> 2;
    uint64_t v18 = v15[v14 % (v16 >> 2)];
    if ((v18 & 0x80000000) != 0)
    {
LABEL_19:
      LODWORD(v19) = *(_DWORD *)(a1 + 120);
      if (v19 == -1)
      {
        uint64_t v21 = *(void *)(a1 + 112);
        uint64_t v19 = (unint64_t)(v21 - v8) >> 5;
        if (2 * (int)v17 >= v19)
        {
          unint64_t v25 = (unint64_t)(v21 - v8) >> 5;
        }
        else
        {
          unsigned int v22 = (2 * v17) | 1;
          uint64_t v23 = *(unsigned int *)(a1 + 72);
          if (v22 <= v23)
          {
            uint64_t v19 = 4 * v23;
          }
          else
          {
            if (v22 <= 8) {
              unsigned int v24 = 8;
            }
            else {
              unsigned int v24 = (2 * v17) | 1;
            }
            uint64_t v19 = 4 * v24;
            int v15 = (unsigned int *)OOCAllocator_Realloc(*(void *)(a1 + 24), *(void *)(a1 + 80), v19, &v45);
            *(void *)(a1 + 80) = v15;
            uint64_t result = v45;
            if (v45) {
              return result;
            }
            *(_DWORD *)(a1 + 72) = v24;
            v16 &= 0x3FFFFFFFCuLL;
          }
          unint64_t v26 = (v16 >> 1) & 0xFFFFFFFE | 1;
          *(void *)(a1 + 88) = &v15[v26];
          cstdlib_memset(v15, 255, v19);
          uint64_t v8 = *(void *)(a1 + 104);
          uint64_t v21 = *(void *)(a1 + 112);
          unint64_t v25 = (unint64_t)(v21 - v8) >> 5;
          LODWORD(v19) = v25;
          if (v25)
          {
            uint64_t v27 = 0;
            int v28 = (_DWORD *)(v8 + 24);
            do
            {
              if (((*v28 + 1) & 0x40000000) == 0)
              {
                uint64_t result = v45;
                if (v45) {
                  return result;
                }
                unint64_t v29 = *(unsigned int *)(*((void *)v28 - 3) + 24);
                uint64_t v30 = v29 - (v29 / v26) * (unint64_t)v26;
                uint64_t v31 = *(void *)(a1 + 80);
                _DWORD *v28 = *(_DWORD *)(v31 + 4 * v30);
                *(_DWORD *)(v31 + 4 * v30) = v27;
              }
              ++v27;
              v28 += 8;
            }
            while (((unint64_t)(v21 - v8) >> 5) != v27);
          }
        }
        unsigned int v32 = v19 + 1;
        unsigned int v33 = *(_DWORD *)(a1 + 96);
        if ((int)v19 + 1 > v33)
        {
          unsigned int v34 = 2 * v33;
          unsigned int v35 = v33 + 1000000;
          if (v34 >= v35) {
            unsigned int v34 = v35;
          }
          if (v34 > v32) {
            unsigned int v32 = v34;
          }
          if (v32 <= 8) {
            unsigned int v36 = 8;
          }
          else {
            unsigned int v36 = v32;
          }
          uint64_t v37 = OOCAllocator_Realloc(*(void *)(a1 + 24), v8, 32 * v36, &v45);
          *(void *)(a1 + 104) = v37;
          uint64_t result = v45;
          if (v45) {
            return result;
          }
          *(_DWORD *)(a1 + 96) = v36;
          uint64_t v21 = v37 + 32 * v25;
        }
        *(void *)(a1 + 112) = v21 + 32;
        *(void *)uint64_t v21 = v13;
        *(void *)(v21 + 24) = 0;
        *(_OWORD *)(v21 + 8) = 0uLL;
        uint64_t v18 = (int)v19;
      }
      else
      {
        uint64_t v18 = (int)v19;
        uint64_t v20 = v8 + 32 * (int)v19;
        *(_DWORD *)(a1 + 120) = (*(_DWORD *)(v20 + 24) & 0xBFFFFFFF) - 1;
        *(void *)uint64_t v20 = v13;
        *(void *)(v20 + 8) = 0;
        *(void *)(v20 + 16) = 0;
        *(void *)(v20 + 24) = 0;
      }
      uint64_t v38 = *(void *)(a1 + 80);
      unsigned int v39 = v14 % ((unint64_t)(*(void *)(a1 + 88) - v38) >> 2);
      uint64_t v8 = *(void *)(a1 + 104);
      *(_DWORD *)(v8 + 32 * v18 + 24) = *(_DWORD *)(v38 + 4 * v39);
      *(_DWORD *)(v38 + 4 * v39) = v19;
      uint64_t v10 = *(void *)(a1 + 144);
    }
    else
    {
      while (v14 != *(_DWORD *)(*(void *)(v8 + 32 * v18) + 24))
      {
        uint64_t v18 = *(unsigned int *)(v8 + 32 * v18 + 24);
        if ((v18 & 0x80000000) != 0) {
          goto LABEL_19;
        }
      }
    }
    uint64_t v40 = v8 + 32 * v18;
    if (!v10)
    {
      *(void *)(a1 + 144) = v40;
      uint64_t v10 = v8 + 32 * v18;
    }
    uint64_t v41 = *v7;
    if (*v7) {
      *(void *)(v41 + 16) = v40;
    }
    uint64_t v42 = v8 + 32 * v18;
    *(void *)(v42 + 8) = v41;
    *(void *)(v42 + 16) = 0;
    uint64_t *v7 = v40;
    uint64_t v43 = *v11++;
    ++*(_DWORD *)(v43 + 8);
    if ((unint64_t)v11 >= v12)
    {
      uint64_t result = v45;
      if (v45) {
        return result;
      }
      return FSTUnaryOperator_Reset(a1);
    }
  }
}

void *GetFSTCacheClass()
{
  return &__FSTCache;
}

uint64_t fstrmepsilonlocal(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7 = 0;
  uint64_t result = PNEW_FSTRmEpsilonLocal_Con(a1, a2, a3, &v7);
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 32))(a3);
    if (!result) {
      *a4 = v7;
    }
  }
  return result;
}

uint64_t PNEW_FSTRmEpsilonLocal_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 88, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = FSTRmEpsilonLocal_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *(void *)(v8 + 16) = a1;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t FSTRmEpsilonLocal_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = _FSTUnaryOperator_Con(a1, a2, a3);
  if (!result)
  {
    *(void *)a1 = &__FSTRmEpsilonLocal;
    *(_DWORD *)(a1 + 32) = 46;
    _FSTUnaryOperator_InheritProperties((int8x8_t *)a1, a3, 0x2000u, 0, 237055, 16896);
    uint64_t result = PNEW_FSTRmEpsilonLocalDfsContext_Con(a2, a2, a3, (uint64_t *)(a1 + 72));
    if (!result)
    {
      uint64_t result = FSTDfsContext_Dfs(*(void *)(a1 + 72));
      if (!result)
      {
        return PNEW_FSTSimpleCache_Con(a2, a3, (uint64_t *)(a1 + 80));
      }
    }
  }
  return result;
}

uint64_t FSTRmEpsilonLocal_Des(uint64_t a1)
{
  uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 24), *(void *)(a1 + 72));
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 32))(*(void *)(a1 + 80));
    if (!result)
    {
      return FSTUnaryOperator_Des(a1);
    }
  }
  return result;
}

uint64_t FSTRmEpsilonLocal_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unsigned int v4 = a2;
  uint64_t v120 = 0;
  uint64_t v119 = *(void *)(a1 + 24);
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 80) + 120))(*(void *)(a1 + 80), a2, a3, &v120);
  unsigned int v121 = result;
  if (result) {
    return result;
  }
  if (!v120)
  {
    uint64_t v19 = 0;
    goto LABEL_205;
  }
  uint64_t v7 = *(void *)(v120 + 40);
  uint64_t v8 = *(void *)(v120 + 56) + 16 * *(unsigned int *)(v120 + 48);
  if (v7 != v8)
  {
    unsigned int v117 = v4;
    int v9 = 0;
    unsigned int v10 = 0;
    uint64_t v11 = 0;
    unsigned int v12 = 0;
    uint64_t v13 = v7 + 16 * *(unsigned int *)(v120 + 32);
    int v14 = 2;
    while (v7 != v13)
    {
LABEL_8:
      unint64_t v15 = (unint64_t)v10 - v11;
      unsigned int v16 = (((unint64_t)v10 - v11) >> 3) + 1;
      if (v16 > v12)
      {
        unsigned int v17 = 2 * v12;
        if (2 * v12 >= v12 + 1000000) {
          unsigned int v17 = v12 + 1000000;
        }
        if (v17 <= v16) {
          unsigned int v17 = v16;
        }
        if (v17 <= 8) {
          unsigned int v12 = 8;
        }
        else {
          unsigned int v12 = v17;
        }
        uint64_t v11 = OOCAllocator_Realloc(v119, v11, 8 * v12, &v121);
        uint64_t result = v121;
        if (v121) {
          return result;
        }
        unsigned int v10 = (_DWORD *)(v11 + (v15 & 0x7FFFFFFF8));
      }
      uint64_t v18 = v10 + 2;
      *unsigned int v10 = v9;
      v10[1] = v14;
      ++v9;
      v7 += 16;
      v10 += 2;
      if (v7 == v8) {
        goto LABEL_22;
      }
    }
    if (*(_DWORD *)(v120 + 48))
    {
      int v9 = 0;
      uint64_t v7 = *(void *)(v120 + 56);
      int v14 = 4;
      goto LABEL_8;
    }
    uint64_t v18 = v10;
LABEL_22:
    if ((_DWORD *)v11 != v18)
    {
      unsigned int v110 = v12;
      unsigned int v20 = v117;
      uint64_t v21 = v117;
      do
      {
        unint64_t v22 = *((void *)v18 - 1);
        v18 -= 2;
        unint64_t v23 = HIDWORD(v22);
        unsigned int v24 = (_DWORD *)v120;
        uint64_t v25 = v22;
        if (HIDWORD(v22) == 2)
        {
          unint64_t v26 = (unsigned int *)(*(void *)(v120 + 40) + 16 * v25);
          unsigned int v27 = *v26;
          if (*v26 == v20)
          {
            uint64_t v28 = *(void *)(a1 + 72);
            --*(_DWORD *)(*(void *)(v28 + 96) + 4 * v21);
            --*(_DWORD *)(*(void *)(v28 + 72) + 4 * v21);
            *unint64_t v26 = -1;
            continue;
          }
        }
        else
        {
          unsigned int v27 = *(_DWORD *)(*(void *)(v120 + 56) + 16 * v25);
          if (v27 == v20) {
            continue;
          }
        }
        if (v27 != -1)
        {
          uint64_t v29 = *(void *)(a1 + 72);
          uint64_t v30 = *(void *)(v29 + 72);
          int v31 = *(_DWORD *)(v30 + 4 * v27);
          unsigned int v32 = *(_DWORD *)(*(void *)(v29 + 96) + 4 * v27);
          if (v31 == 1 && v32 >= 2)
          {
            uint64_t v125 = 0;
            uint64_t v41 = 56;
            if (v23 == 2) {
              uint64_t v41 = 40;
            }
            uint64_t v111 = v41;
            uint64_t v112 = *(void *)(a1 + 24);
            long long v124 = *(_OWORD *)(*(void *)(v120 + v41) + 16 * v25);
            uint64_t v42 = v124;
            uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t *))(**(void **)(a1 + 80) + 120))(*(void *)(a1 + 80), v124, 8, &v125);
            v126[0] = result;
            if (result) {
              return result;
            }
            uint64_t v38 = v125;
            if (!v125) {
              goto LABEL_138;
            }
            int v40 = *(_DWORD *)(v125 + 8);
            if (((v40 ^ v24[2]) & 0x50000000) != 0) {
              goto LABEL_134;
            }
            uint64_t v43 = *(unsigned int *)(v125 + 32);
            if (v23 == 4 && !v43) {
              goto LABEL_134;
            }
            unsigned int v44 = *(_DWORD **)(v125 + 40);
            uint64_t v116 = *(void *)(v125 + 56) + 16 * *(unsigned int *)(v125 + 48);
            if (v44 == (_DWORD *)v116)
            {
              int v54 = 0;
              int v53 = 0;
            }
            else
            {
              uint64_t v109 = 0;
              v114 = &v44[4 * v43];
              do
              {
                uint64_t v122 = 0;
                uint64_t v123 = 0;
                if (v44 == v114)
                {
                  uint64_t v38 = v125;
                  if (!*(_DWORD *)(v125 + 48)) {
                    goto LABEL_72;
                  }
                  unsigned int v44 = *(_DWORD **)(v125 + 56);
                }
                if (*v44 != -1)
                {
                  if (__FSTRmEpsilonLocal_CanCombineArcs(&v124, v44, &v122))
                  {
                    uint64_t v45 = *(void *)(*(void *)(a1 + 72) + 96);
                    --*(_DWORD *)(v45 + 4 * v42);
                    ++*(_DWORD *)(v45 + 4 * v24[6]);
                    *unsigned int v44 = -1;
                    if (HIDWORD(v122) == -2)
                    {
                      int v46 = 2;
                      uint64_t result = FSTState_AddArcs((uint64_t)v24, 2, (uint64_t)&v122, 1u);
                      v126[0] = result;
                      unsigned int v47 = v24 + 8;
                      if (result) {
                        return result;
                      }
                    }
                    else
                    {
                      int v46 = 4;
                      uint64_t result = FSTState_AddArcs((uint64_t)v24, 4, (uint64_t)&v122, 1u);
                      v126[0] = result;
                      unsigned int v47 = v24 + 12;
                      if (result) {
                        return result;
                      }
                    }
                    int v48 = *v47;
                    unint64_t v49 = (unint64_t)v18 - v11;
                    unsigned int v50 = (((unint64_t)v18 - v11) >> 3) + 1;
                    if (v50 > v110)
                    {
                      unsigned int v51 = 2 * v110;
                      if (2 * v110 >= v110 + 1000000) {
                        unsigned int v51 = v110 + 1000000;
                      }
                      if (v51 > v50) {
                        unsigned int v50 = v51;
                      }
                      if (v50 <= 8) {
                        unsigned int v52 = 8;
                      }
                      else {
                        unsigned int v52 = v50;
                      }
                      uint64_t v11 = OOCAllocator_Realloc(v112, v11, 8 * v52, v126);
                      uint64_t result = v126[0];
                      if (v126[0]) {
                        return result;
                      }
                      unsigned int v110 = v52;
                      uint64_t v18 = (_DWORD *)(v11 + (v49 & 0x7FFFFFFF8));
                    }
                    *uint64_t v18 = v48 - 1;
                    v18[1] = v46;
                    v18 += 2;
                    HIDWORD(v109) = 1;
                    unsigned int v20 = v117;
                    uint64_t v21 = v117;
                  }
                  else
                  {
                    LODWORD(v109) = 1;
                  }
                }
                v44 += 4;
              }
              while (v44 != (_DWORD *)v116);
              uint64_t v38 = v125;
LABEL_72:
              int v53 = v109;
              int v54 = HIDWORD(v109);
            }
            int v40 = *(_DWORD *)(v38 + 8);
            if (v40 < 0)
            {
              if (*(void *)((char *)&v124 + 4) == 0xFFFFFFFEFFFFFFFELL)
              {
                int v61 = *(_DWORD *)(v38 + 28);
                int v62 = HIDWORD(v124);
                int v63 = v24[2];
                if (v63 < 0)
                {
                  int v65 = v24[7];
                  uint64_t v64 = *(void *)(*(void *)(a1 + 72) + 96);
                }
                else
                {
                  uint64_t v64 = *(void *)(*(void *)(a1 + 72) + 96);
                  ++*(_DWORD *)(v64 + 4 * v24[6]);
                  int v63 = v24[2];
                  int v65 = 0x7FFFFFFF;
                }
                int v82 = v62 + v61;
                v24[2] = v63 | 0x80000000;
                if (v65 < v82) {
                  int v82 = v65;
                }
                v24[7] = v82;
                --*(_DWORD *)(v64 + 4 * v42);
                int v40 = *(_DWORD *)(v38 + 8) & 0x7FFFFFFF;
                *(_DWORD *)(v38 + 8) = v40;
                int v54 = 1;
                goto LABEL_120;
              }
LABEL_134:
              if ((v40 & 0x3FFFFFF) == 1)
              {
                if ((v40 & 0x8000000) != 0) {
                  uint64_t v88 = *(void *)(v38 + 16);
                }
                else {
                  uint64_t v88 = 0;
                }
                uint64_t result = FSTStatePool_PushFSTState(v88, v38);
LABEL_141:
                unsigned int v121 = result;
                if (result) {
                  return result;
                }
                continue;
              }
              *(_DWORD *)(v38 + 8) = v40 - 1;
              if ((v40 & 0x3FFFFFF) == 0) {
                return 9;
              }
LABEL_138:
              unsigned int v121 = 0;
              continue;
            }
LABEL_120:
            if (!v54 || v53) {
              goto LABEL_134;
            }
            uint64_t v83 = *(void *)((char *)v24 + v111);
            uint64_t v84 = *(void *)(a1 + 72);
            --*(_DWORD *)(*(void *)(v84 + 96) + 4 * v24[6]);
            --*(_DWORD *)(*(void *)(v84 + 72) + 4 * v42);
            *(_DWORD *)(v83 + 16 * v25) = -1;
LABEL_133:
            int v40 = *(_DWORD *)(v38 + 8);
            goto LABEL_134;
          }
          if (v32 == 1)
          {
            uint64_t v34 = *(void *)(a1 + 24);
            uint64_t v125 = 0;
            uint64_t v35 = 56;
            if (v23 == 2) {
              uint64_t v35 = 40;
            }
            uint64_t v113 = v34;
            uint64_t v115 = v35;
            long long v124 = *(_OWORD *)(*(void *)(v120 + v35) + 16 * v25);
            uint64_t v36 = v124;
            int v37 = *(_DWORD *)(v30 + 4 * v124);
            uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t *))(**(void **)(a1 + 80) + 120))(*(void *)(a1 + 80), v124, 8, &v125);
            v126[0] = result;
            if (result) {
              return result;
            }
            uint64_t v38 = v125;
            if (!v125)
            {
              uint64_t v21 = v117;
              goto LABEL_138;
            }
            int v39 = v24[2];
            int v40 = *(_DWORD *)(v125 + 8);
            if (((v40 ^ v39) & 0x50000000) == 0 && (v23 != 4 || *(_DWORD *)(v125 + 32)))
            {
              if ((v40 & 0x80000000) == 0)
              {
                uint64_t v122 = 0;
                uint64_t v123 = 0;
                unsigned int v55 = *(unsigned int **)(v125 + 40);
                uint64_t v56 = *(void *)(v125 + 56);
                uint64_t v57 = *(unsigned int *)(v125 + 48);
                unsigned int v58 = (unsigned int *)(v56 + 16 * v57);
                if (v55 != v58)
                {
                  v59 = &v55[4 * *(unsigned int *)(v125 + 32)];
                  while (1)
                  {
                    BOOL v60 = v55 == v59;
                    if (v55 == v59) {
                      unsigned int v55 = *(unsigned int **)(v125 + 56);
                    }
                    if (!v57 && v60) {
                      break;
                    }
                    if (*v55 != -1) {
                      goto LABEL_95;
                    }
                    v55 += 4;
                    if (v55 == v58)
                    {
                      unsigned int v55 = (unsigned int *)(v56 + 16 * v57);
                      goto LABEL_95;
                    }
                  }
                  unsigned int v55 = v59;
                }
LABEL_95:
                uint64_t v70 = v125;
                if (__FSTRmEpsilonLocal_CanCombineArcs(&v124, v55, &v122))
                {
                  uint64_t v71 = *(void *)(a1 + 72);
                  uint64_t v72 = *(void *)(v71 + 96);
                  if (v37 == 1)
                  {
                    --*(_DWORD *)(v72 + 4 * v36);
                    uint64_t v73 = *(void *)(v71 + 72);
                    --*(_DWORD *)(v73 + 4 * *v55);
                    *unsigned int v55 = -1;
                  }
                  else
                  {
                    uint64_t v73 = *(void *)(v71 + 72);
                  }
                  ++*(_DWORD *)(v72 + 4 * v24[6]);
                  ++*(_DWORD *)(v73 + 4 * v122);
                  if (HIDWORD(v122) == -2)
                  {
                    uint64_t result = FSTState_AddArcs((uint64_t)v24, 2, (uint64_t)&v122, 1u);
                    v126[0] = result;
                    if (result) {
                      return result;
                    }
                    v74 = v24 + 8;
                    int v75 = 2;
                  }
                  else
                  {
                    uint64_t result = FSTState_AddArcs((uint64_t)v24, 4, (uint64_t)&v122, 1u);
                    v126[0] = result;
                    if (result) {
                      return result;
                    }
                    v74 = v24 + 12;
                    int v75 = 4;
                  }
                  int v76 = *v74;
                  unint64_t v77 = (unint64_t)v18 - v11;
                  unsigned int v78 = (((unint64_t)v18 - v11) >> 3) + 1;
                  if (v78 > v110)
                  {
                    unsigned int v79 = 2 * v110;
                    if (2 * v110 >= v110 + 1000000) {
                      unsigned int v79 = v110 + 1000000;
                    }
                    if (v79 > v78) {
                      unsigned int v78 = v79;
                    }
                    if (v78 <= 8) {
                      unsigned int v80 = 8;
                    }
                    else {
                      unsigned int v80 = v78;
                    }
                    uint64_t v11 = OOCAllocator_Realloc(v113, v11, 8 * v80, v126);
                    uint64_t result = v126[0];
                    if (v126[0]) {
                      return result;
                    }
                    uint64_t v18 = (_DWORD *)(v11 + (v77 & 0x7FFFFFFF8));
                    unsigned int v110 = v80;
                  }
                  uint64_t v81 = v115;
                  *uint64_t v18 = v76 - 1;
                  v18[1] = v75;
                  v18 += 2;
                  uint64_t v68 = *(void *)(a1 + 72);
                  uint64_t v38 = v125;
                  unsigned int v20 = v117;
                  uint64_t v21 = v117;
LABEL_131:
                  uint64_t v87 = *(void *)((char *)v24 + v81);
                  --*(_DWORD *)(*(void *)(v68 + 96) + 4 * v24[6]);
                  --*(_DWORD *)(*(void *)(v68 + 72) + 4 * v36);
                  *(_DWORD *)(v87 + 16 * v25) = -1;
                }
                else
                {
                  uint64_t v21 = v117;
                  uint64_t v38 = v70;
                }
                if (!v38)
                {
                  uint64_t result = v126[0];
                  goto LABEL_141;
                }
                goto LABEL_133;
              }
              if (*(void *)((char *)&v124 + 4) == 0xFFFFFFFEFFFFFFFELL)
              {
                int v66 = *(_DWORD *)(v125 + 28);
                int v67 = HIDWORD(v124);
                if (v39 < 0)
                {
                  int v69 = v24[7];
                  uint64_t v68 = *(void *)(a1 + 72);
                }
                else
                {
                  uint64_t v68 = *(void *)(a1 + 72);
                  ++*(_DWORD *)(*(void *)(v68 + 96) + 4 * v24[6]);
                  int v39 = v24[2];
                  int v69 = 0x7FFFFFFF;
                }
                int v85 = v67 + v66;
                v24[2] = v39 | 0x80000000;
                if (v69 >= v85) {
                  int v86 = v85;
                }
                else {
                  int v86 = v69;
                }
                v24[7] = v86;
                if (v37 == 1)
                {
                  --*(_DWORD *)(*(void *)(v68 + 96) + 4 * v36);
                  *(_DWORD *)(v38 + 8) &= ~0x80000000;
                }
                uint64_t v21 = v117;
                uint64_t v81 = v115;
                goto LABEL_131;
              }
            }
            uint64_t v21 = v117;
            goto LABEL_134;
          }
        }
      }
      while ((_DWORD *)v11 != v18);
    }
    if (v11) {
      OOCAllocator_Free(v119, v11);
    }
  }
  uint64_t v89 = v120;
  *(_DWORD *)(v120 + 8) &= ~0x20000000u;
  lhstdlib_udqsort(*(void *)(v89 + 40), *(_DWORD *)(v89 + 32), 0x10u, a1, (uint64_t (*)(char *, char *, uint64_t))__FSTRmEpsilonLocal_Compare);
  lhstdlib_udqsort(*(void *)(v120 + 56), *(_DWORD *)(v120 + 48), 0x10u, a1, (uint64_t (*)(char *, char *, uint64_t))__FSTRmEpsilonLocal_Compare);
  uint64_t v19 = (_DWORD *)v120;
  v90 = *(char **)(v120 + 40);
  uint64_t v91 = *(void *)(v120 + 56);
  v92 = (_OWORD *)(v91 + 16 * *(unsigned int *)(v120 + 48));
  if (v90 == (char *)v92)
  {
    *(_DWORD *)(v120 + 32) = 0;
    _OWORD v19[12] = (unint64_t)&v90[-v91] >> 4;
    goto LABEL_205;
  }
  v93 = 0;
  LODWORD(v94) = 0;
  v95 = (unsigned int *)&v90[16 * *(unsigned int *)(v120 + 32)];
  v96 = *(unsigned int **)(v120 + 40);
  while (v96 != v95)
  {
    uint64_t v97 = *v96;
    if (v97 == -1) {
      goto LABEL_171;
    }
    if (!v93) {
      goto LABEL_169;
    }
    *(void *)&long long v124 = 0;
    uint64_t v122 = 0;
    if (*((_DWORD *)v93 + 1) != v96[1]) {
      goto LABEL_166;
    }
    if (*((_DWORD *)v93 + 2) != v96[2]) {
      goto LABEL_166;
    }
    if (*((_DWORD *)v93 + 3) != v96[3]) {
      goto LABEL_166;
    }
    uint64_t v98 = *(void *)(*(void *)(a1 + 72) + 72);
    if (*(_DWORD *)(v98 + 4 * *(unsigned int *)v93) != 1 || *(_DWORD *)(v98 + 4 * v97) != 1) {
      goto LABEL_166;
    }
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 120))(*(void *)(a1 + 80));
    if (result) {
      return result;
    }
    if (!(void)v124)
    {
LABEL_166:
      int v102 = 0;
LABEL_167:
      unsigned int v121 = 0;
      goto LABEL_168;
    }
    uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t *))(**(void **)(a1 + 80) + 120))(*(void *)(a1 + 80), *v96, 8, &v122);
    if (result) {
      return result;
    }
    uint64_t v99 = v122;
    uint64_t v100 = v124;
    if (v122)
    {
      int v101 = *(_DWORD *)(v122 + 8);
      if (((v101 ^ *(_DWORD *)(v124 + 8)) & 0x50000000) != 0)
      {
        int v102 = 0;
      }
      else
      {
        unsigned int v103 = *(_DWORD *)(v122 + 32);
        if (v103)
        {
          uint64_t result = FSTState_AddArcs(v124, 2, *(void *)(v122 + 40), v103);
          if (result) {
            return result;
          }
          uint64_t v99 = v122;
          uint64_t v100 = v124;
        }
        unsigned int v104 = *(_DWORD *)(v99 + 48);
        if (v104)
        {
          uint64_t result = FSTState_AddArcs(v100, 4, *(void *)(v99 + 56), v104);
          if (result) {
            return result;
          }
          uint64_t v99 = v122;
          uint64_t v100 = v124;
        }
        uint64_t v105 = *(void *)(*(void *)(a1 + 72) + 72);
        *(_DWORD *)(v105 + 4 * *v96) -= *(_DWORD *)(v99 + 32);
        *(_DWORD *)(v105 + 4 * *v96) -= *(_DWORD *)(v99 + 48);
        *(_DWORD *)(v99 + 32) = 0;
        *(_DWORD *)(v99 + 48) = 0;
        *(_DWORD *)(v100 + 8) |= *(_DWORD *)(v99 + 8) & 0x80000000;
        int v101 = *(_DWORD *)(v99 + 8);
        int v102 = 1;
      }
      if ((v101 & 0x3FFFFFF) == 1)
      {
        if ((v101 & 0x8000000) != 0) {
          uint64_t v106 = *(void *)(v99 + 16);
        }
        else {
          uint64_t v106 = 0;
        }
        uint64_t result = FSTStatePool_PushFSTState(v106, v99);
      }
      else
      {
        *(_DWORD *)(v99 + 8) = v101 - 1;
        if ((v101 & 0x3FFFFFF) != 0) {
          uint64_t result = 0;
        }
        else {
          uint64_t result = 9;
        }
      }
      if (result) {
        goto LABEL_199;
      }
      uint64_t v100 = v124;
      if (!(void)v124) {
        goto LABEL_199;
      }
    }
    else
    {
      int v102 = 0;
      if (!(void)v124) {
        goto LABEL_167;
      }
    }
    int v107 = *(_DWORD *)(v100 + 8);
    if ((v107 & 0x3FFFFFF) != 1)
    {
      *(_DWORD *)(v100 + 8) = v107 - 1;
      if ((v107 & 0x3FFFFFF) == 0) {
        return 9;
      }
      goto LABEL_167;
    }
    if ((v107 & 0x8000000) != 0) {
      uint64_t v108 = *(void *)(v100 + 16);
    }
    else {
      uint64_t v108 = 0;
    }
    uint64_t result = FSTStatePool_PushFSTState(v108, v100);
LABEL_199:
    unsigned int v121 = result;
    if (result) {
      return result;
    }
LABEL_168:
    if (!v102) {
      goto LABEL_169;
    }
LABEL_171:
    v96 += 4;
    if (v96 == (unsigned int *)v92)
    {
      uint64_t v19 = (_DWORD *)v120;
      v96 = *(unsigned int **)(v120 + 56);
      goto LABEL_203;
    }
  }
  uint64_t v19 = (_DWORD *)v120;
  unint64_t v94 = (unint64_t)&v90[-*(void *)(v120 + 40)] >> 4;
  v96 = *(unsigned int **)(v120 + 56);
  if (*(_DWORD *)(v120 + 48))
  {
    if (*v96 == -1)
    {
      v93 = 0;
      v90 = *(char **)(v120 + 56);
      goto LABEL_171;
    }
    v90 = *(char **)(v120 + 56);
LABEL_169:
    v93 = v90;
    *(_OWORD *)v90 = *(_OWORD *)v96;
    v90 += 16;
    goto LABEL_171;
  }
  v90 = *(char **)(v120 + 56);
LABEL_203:
  v19[8] = v94;
  _OWORD v19[12] = (unint64_t)(v90 - (char *)v96) >> 4;
  if (v94) {
    v19[2] |= 0x20000000u;
  }
LABEL_205:
  *a4 = v19;
  return v121;
}

uint64_t __FSTRmEpsilonLocal_Compare(unsigned int *a1, unsigned int *a2, uint64_t a3)
{
  signed int v3 = a1[1];
  signed int v4 = a2[1];
  if (v3 < v4) {
    return 0xFFFFFFFFLL;
  }
  if (v3 > v4) {
    return 1;
  }
  signed int v6 = a1[2];
  signed int v7 = a2[2];
  if (v6 < v7) {
    return 0xFFFFFFFFLL;
  }
  if (v6 > v7) {
    return 1;
  }
  signed int v8 = a1[3];
  signed int v9 = a2[3];
  if (v8 < v9) {
    return 0xFFFFFFFFLL;
  }
  if (v8 > v9) {
    return 1;
  }
  uint64_t v10 = *a1;
  if (v10 == -1) {
    int v11 = 0;
  }
  else {
    int v11 = *(_DWORD *)(*(void *)(*(void *)(a3 + 72) + 72) + 4 * v10);
  }
  uint64_t v12 = *a2;
  if (v12 == -1) {
    int v13 = 0;
  }
  else {
    int v13 = *(_DWORD *)(*(void *)(*(void *)(a3 + 72) + 72) + 4 * v12);
  }
  uint64_t result = (v11 - v13);
  if (v11 == v13)
  {
    if (v10 >= v12) {
      return v10 > v12;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

unint64_t FSTRmEpsilonLocal_GetMemoryInfo(uint64_t a1)
{
  return FSTUnaryOperator_GetMemoryInfo(a1)
       + 4
       * (*(unsigned int *)(*(void *)(a1 + 72) + 88)
        + (unint64_t)*(unsigned int *)(*(void *)(a1 + 72) + 64)
        + *(unsigned int *)(*(void *)(a1 + 72) + 16))
       + 136;
}

uint64_t FSTRmEpsilonLocal_Reset(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t result = FSTUnaryOperator_Reset(a1);
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 112))(*(void *)(a1 + 80));
    if (!result)
    {
      uint64_t result = OOC_PlacementDeleteObject(v2, *(void *)(a1 + 72));
      if (!result)
      {
        uint64_t result = PNEW_FSTRmEpsilonLocalDfsContext_Con(v2, v2, *(void *)(a1 + 64), (uint64_t *)(a1 + 72));
        if (!result)
        {
          uint64_t v4 = *(void *)(a1 + 72);
          return FSTDfsContext_Dfs(v4);
        }
      }
    }
  }
  return result;
}

void *GetFSTRmEpsilonLocalClass()
{
  return &__FSTRmEpsilonLocal;
}

uint64_t __FSTRmEpsilonLocal_CanCombineArcs(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  int v3 = a1[1];
  if (v3 == -2 && a1[2] == -2 && !a1[3])
  {
    a3[3] = a2[3];
    int v3 = a2[1];
  }
  else
  {
    if (a2[1] != -2 || a2[2] != -2 || a2[3]) {
      return 0;
    }
    a3[3] = a1[3];
  }
  a3[1] = v3;
  int v5 = a1[2];
  if (v5 == -2) {
    int v5 = a2[2];
  }
  a3[2] = v5;
  *a3 = *a2;
  return 1;
}

uint64_t FSTNumArcLimiter_Con(int8x8_t *a1, uint64_t a2, uint64_t a3, __int32 a4)
{
  uint64_t result = _FSTUnaryOperator_Con((uint64_t)a1, a2, a3);
  unsigned int v15 = result;
  if (!result)
  {
    int v14 = 0;
    *a1 = (int8x8_t)&__FSTNumArcLimiter;
    a1[4].i32[0] = 35;
    a1[9].i32[0] = a4;
    a1[10].i32[0] = 5;
    uint64_t v9 = OOCAllocator_Malloc(a2, 20, &v15);
    a1[11] = (int8x8_t)v9;
    uint64_t result = v15;
    if (!v15)
    {
      uint64_t v10 = a1[10].u32[0];
      unint64_t v11 = v9 + 4 * v10;
      a1[12] = (int8x8_t)v11;
      if (v10)
      {
        if (v11 <= v9 + 4) {
          unint64_t v11 = v9 + 4;
        }
        memset((void *)v9, 255, ((v11 + ~v9) & 0xFFFFFFFFFFFFFFFCLL) + 4);
      }
      a1[13].i32[0] = 0;
      a1[14] = 0;
      a1[15] = 0;
      a1[16].i32[0] = -1;
      uint64_t result = (*(uint64_t (**)(uint64_t, int *))(*(void *)a3 + 72))(a3, &v14);
      unsigned int v15 = result;
      if (!result)
      {
        int v12 = v14;
        if (v14 != -1)
        {
LABEL_9:
          a1[9].i32[1] = v12 + 1;
          _FSTUnaryOperator_InheritProperties(a1, a3, 0, 256, 259327, 2560);
          return v15;
        }
        memset(v13, 0, sizeof(v13));
        uint64_t result = FSTCount(a2, a3, (uint64_t)v13);
        unsigned int v15 = result;
        if (!result)
        {
          int v12 = v13[0];
          int v14 = v13[0];
          goto LABEL_9;
        }
      }
    }
  }
  return result;
}

uint64_t FSTNumArcLimiter_Des(uint64_t *a1)
{
  uint64_t v2 = a1[11];
  if (v2) {
    OOCAllocator_Free(a1[3], v2);
  }
  uint64_t v3 = a1[14];
  if (v3) {
    OOCAllocator_Free(a1[3], v3);
  }

  return FSTUnaryOperator_Des((uint64_t)a1);
}

uint64_t FSTNumArcLimiter_FetchState(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4)
{
  int v6 = a2;
  unsigned int v102 = 0;
  uint64_t v100 = 0;
  uint64_t v101 = 0;
  *a4 = 0;
  unsigned int v8 = *(_DWORD *)(a1 + 76);
  BOOL v9 = a2 >= v8;
  unsigned int v10 = a2 - v8;
  if (v9)
  {
    uint64_t v28 = *(void *)(a1 + 112) + 12 * v10;
    uint64_t v29 = *(unsigned int *)(v28 + 4);
    uint64_t v30 = *(unsigned int *)(v28 + 8);
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), v29, 8, &v101);
    unsigned int v102 = result;
    if (result) {
      return result;
    }
    unsigned int v31 = *(_DWORD *)(v101 + 32);
    if (v31 <= v30)
    {
      int v34 = 0;
      unsigned int v33 = 0;
      unsigned int v32 = *(_DWORD *)(a1 + 72);
    }
    else
    {
      unsigned int v32 = *(_DWORD *)(a1 + 72);
      if (v31 - v30 >= v32) {
        unsigned int v33 = *(_DWORD *)(a1 + 72);
      }
      else {
        unsigned int v33 = v31 - v30;
      }
      int v34 = 0x20000000;
    }
    unsigned int v35 = v31 + *(_DWORD *)(v101 + 48) - v33 - v30;
    unsigned int v36 = v32 - v33;
    if (v35 >= v36) {
      uint64_t v37 = v36;
    }
    else {
      uint64_t v37 = v35;
    }
    BOOL v9 = v30 >= v31;
    unsigned int v38 = v30 - v31;
    if (v9) {
      unsigned int v39 = v38;
    }
    else {
      unsigned int v39 = 0;
    }
    if (FST_CheckQuery(v34, a3))
    {
      uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v100);
      unsigned int v102 = result;
      if (result) {
        return result;
      }
      uint64_t v40 = v100;
      *(_DWORD *)(v100 + 8) |= v34;
      *(_DWORD *)(v40 + 28) = 0;
      *(_DWORD *)(v40 + 32) = 0;
      *(_DWORD *)(v40 + 24) = v6;
      *(_DWORD *)(v40 + 48) = 0;
      if (v33)
      {
        uint64_t v41 = *(void *)(v40 + 40);
        if (!v41 || *(_DWORD *)(v41 - 4) <= v33)
        {
          uint64_t v41 = _FSTState_ReserveEpsilonArcsInternal(v40, v33, &v102);
          uint64_t result = v102;
          if (v102) {
            return result;
          }
        }
        unsigned int v42 = 0;
        uint64_t v43 = (_OWORD *)(*(void *)(v101 + 40) + 16 * v30);
        uint64_t v44 = v33;
        do
        {
          if (*(_DWORD *)v43 != v29) {
            *(_OWORD *)(v41 + 16 * v42++) = *v43;
          }
          ++v43;
          --v44;
        }
        while (v44);
        uint64_t v40 = v100;
        *(_DWORD *)(v100 + 32) = v42;
      }
      if (v37)
      {
        uint64_t v45 = *(void *)(v40 + 56);
        if (!v45 || *(_DWORD *)(v45 - 4) <= v37)
        {
          uint64_t v45 = _FSTState_ReserveArcsInternal(v40, v37, &v102);
          uint64_t result = v102;
          if (v102) {
            return result;
          }
        }
        unsigned int v46 = 0;
        unsigned int v47 = (_OWORD *)(*(void *)(v101 + 56) + 16 * v39);
        do
        {
          if (*(_DWORD *)v47 != v29) {
            *(_OWORD *)(v45 + 16 * v46++) = *v47;
          }
          ++v47;
          --v37;
        }
        while (v37);
        uint64_t v40 = v100;
        *(_DWORD *)(v100 + 48) = v46;
      }
      *a4 = v40;
    }
    int v48 = *(_DWORD *)(v101 + 8);
    if ((v48 & 0x3FFFFFF) == 1)
    {
      if ((v48 & 0x8000000) != 0) {
        uint64_t v49 = *(void *)(v101 + 16);
      }
      else {
        uint64_t v49 = 0;
      }
      return FSTStatePool_PushFSTState(v49, v101);
    }
    else
    {
      *(_DWORD *)(v101 + 8) = v48 - 1;
      if ((v48 & 0x3FFFFFF) != 0) {
        return 0;
      }
      else {
        return 9;
      }
    }
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, 8, &v101);
  unsigned int v102 = result;
  uint64_t v12 = v101;
  if (result) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = v101 == 0;
  }
  if (!v13)
  {
    unsigned int v14 = *(_DWORD *)(v101 + 48) + *(_DWORD *)(v101 + 32);
    if (v14 <= *(_DWORD *)(a1 + 72))
    {
      uint64_t result = 0;
LABEL_28:
      *a4 = v12;
      return result;
    }
    unsigned int v15 = *(_DWORD *)(v101 + 8) & 0xD0000000 | 0x20000000;
    if (!FST_CheckQuery(v15, a3)) {
      return v102;
    }
    unsigned int v16 = *(_DWORD *)(a1 + 72);
    unsigned int v17 = v14 / v16;
    uint64_t v18 = *(_DWORD **)(v101 + 40);
    uint64_t v19 = *(_DWORD **)(v101 + 56);
    uint64_t v20 = *(unsigned int *)(v101 + 48);
    uint64_t v21 = &v19[4 * v20];
    if (v18 != v21)
    {
      int v22 = 0;
      unsigned int v23 = 0;
      unsigned int v24 = 0;
      int v25 = *(_DWORD *)(v101 + 24);
      unint64_t v26 = &v18[4 * *(unsigned int *)(v101 + 32)];
      int v27 = 1;
      while (v18 != v26)
      {
        if (*v18 == v25)
        {
          ++v24;
          if (!v27) {
            goto LABEL_17;
          }
          ++v22;
        }
LABEL_19:
        v18 += 4;
        if (v18 == v21) {
          goto LABEL_65;
        }
      }
      if (!v20) {
        goto LABEL_65;
      }
      if (*v19 != v25)
      {
        int v27 = 0;
        uint64_t v18 = *(_DWORD **)(v101 + 56);
        goto LABEL_19;
      }
      ++v24;
      uint64_t v18 = *(_DWORD **)(v101 + 56);
LABEL_17:
      int v27 = 0;
      ++v23;
      goto LABEL_19;
    }
    unsigned int v24 = 0;
    unsigned int v23 = 0;
    int v22 = 0;
LABEL_65:
    if (v14 == v17 * v16) {
      uint64_t v50 = v17;
    }
    else {
      uint64_t v50 = v17 + 1;
    }
    if (v50 > v16 || v24 > v16 || v14 != v24 && v24 >= v16) {
      return err_GenerateErrorInternal();
    }
    uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v100);
    unsigned int v102 = result;
    if (!result)
    {
      uint64_t v51 = v100;
      *(_DWORD *)(v100 + 24) = v6;
      *(_DWORD *)(v51 + 8) |= v15;
      int v52 = *(_DWORD *)(v101 + 28);
      *(_DWORD *)(v51 + 48) = 0;
      *(_DWORD *)(v51 + 28) = v52;
      *(_DWORD *)(v51 + 32) = v50;
      uint64_t v53 = *(void *)(v51 + 40);
      if (v53)
      {
        unsigned int v54 = v50 + v22;
        if (*(_DWORD *)(v53 - 4) > (v50 + v22))
        {
LABEL_83:
          if (v22)
          {
            uint64_t v55 = *(unsigned int *)(v101 + 32);
            if (v55)
            {
              unsigned int v56 = 0;
              uint64_t v57 = *(_OWORD **)(v101 + 40);
              unsigned int v58 = &v57[v55];
              do
              {
                if (*(_DWORD *)v57 == v6) {
                  *(_OWORD *)(v53 + 16 * v56++) = *v57;
                }
                ++v57;
              }
              while (v57 < v58);
            }
            else
            {
              unsigned int v56 = 0;
            }
            *(_DWORD *)(v100 + 32) = v56 + v50;
            v53 += 16 * v56;
          }
          if (v50)
          {
            uint64_t v59 = 0;
            int v99 = 2309 * v6;
            uint64_t v98 = v53;
            do
            {
              int v60 = *(_DWORD *)(a1 + 72) * v59;
              unsigned int v61 = v60 + v99;
              int v62 = *(_DWORD **)(a1 + 88);
              unint64_t v63 = *(void *)(a1 + 96) - (void)v62;
              uint64_t v64 = (v60 + v99) % (v63 >> 2);
              unsigned int v65 = v62[v64];
              if ((v65 & 0x80000000) != 0)
              {
LABEL_99:
                unsigned int v65 = *(_DWORD *)(a1 + 128);
                if (v65 == -1)
                {
                  uint64_t v68 = *(void *)(a1 + 112);
                  uint64_t v70 = *(_DWORD **)(a1 + 120);
                  uint64_t v71 = ((uint64_t)v70 - v68) >> 2;
                  unsigned int v65 = -1431655765 * v71;
                  unsigned int v72 = 2 * (v63 >> 2);
                  if (v72 >= -1431655765 * (int)v71)
                  {
                    unsigned int v77 = -1431655765 * v71;
                  }
                  else
                  {
                    unsigned int v73 = v72 | 1;
                    uint64_t v74 = *(unsigned int *)(a1 + 80);
                    if (v73 <= v74)
                    {
                      size_t v76 = 4 * v74;
                    }
                    else
                    {
                      if (v73 <= 8) {
                        unsigned int v75 = 8;
                      }
                      else {
                        unsigned int v75 = v73;
                      }
                      int v62 = (_DWORD *)OOCAllocator_Realloc(*(void *)(a1 + 24), (uint64_t)v62, 4 * v75, &v102);
                      *(void *)(a1 + 88) = v62;
                      uint64_t result = v102;
                      if (v102) {
                        return result;
                      }
                      *(_DWORD *)(a1 + 80) = v75;
                      v63 &= 0x3FFFFFFFCuLL;
                      size_t v76 = 4 * v75;
                    }
                    unint64_t v78 = (v63 >> 1) & 0xFFFFFFFE | 1;
                    *(void *)(a1 + 96) = &v62[v78];
                    cstdlib_memset(v62, 255, v76);
                    uint64_t v68 = *(void *)(a1 + 112);
                    uint64_t v70 = *(_DWORD **)(a1 + 120);
                    unsigned int v77 = -1431655765 * (((uint64_t)v70 - v68) >> 2);
                    if (v77)
                    {
                      uint64_t v79 = 0;
                      unsigned int v80 = *(_DWORD **)(a1 + 112);
                      do
                      {
                        if (((*v80 + 1) & 0x40000000) == 0)
                        {
                          uint64_t result = v102;
                          if (v102) {
                            return result;
                          }
                          unint64_t v81 = (v80[2] + 2309 * v80[1]);
                          uint64_t v82 = v81 - (v81 / v78) * (unint64_t)v78;
                          uint64_t v83 = *(void *)(a1 + 88);
                          *unsigned int v80 = *(_DWORD *)(v83 + 4 * v82);
                          *(_DWORD *)(v83 + 4 * v82) = v79;
                        }
                        ++v79;
                        v80 += 3;
                      }
                      while (-1431655765 * (((uint64_t)v70 - v68) >> 2) != v79);
                      unsigned int v65 = -1431655765 * (((uint64_t)v70 - v68) >> 2);
                    }
                    else
                    {
                      unsigned int v65 = 0;
                    }
                    unsigned int v61 = v60 + v99;
                  }
                  unsigned int v84 = v65 + 1;
                  unsigned int v85 = *(_DWORD *)(a1 + 104);
                  if (v65 + 1 > v85)
                  {
                    unsigned int v97 = v77;
                    unsigned int v86 = 2 * v85;
                    unsigned int v87 = v85 + 1000000;
                    if (v86 >= v87) {
                      unsigned int v86 = v87;
                    }
                    if (v86 > v84) {
                      unsigned int v84 = v86;
                    }
                    if (v84 <= 8) {
                      unsigned int v88 = 8;
                    }
                    else {
                      unsigned int v88 = v84;
                    }
                    uint64_t v68 = OOCAllocator_Realloc(*(void *)(a1 + 24), v68, 12 * v88, &v102);
                    *(void *)(a1 + 112) = v68;
                    uint64_t result = v102;
                    if (v102) {
                      return result;
                    }
                    *(_DWORD *)(a1 + 104) = v88;
                    uint64_t v70 = (_DWORD *)(v68 + 12 * v97);
                    unsigned int v61 = v60 + v99;
                  }
                  *(void *)(a1 + 120) = v70 + 3;
                  *uint64_t v70 = 0;
                  v70[1] = v6;
                  v70[2] = v60;
                  int v62 = *(_DWORD **)(a1 + 88);
                  uint64_t v64 = v61 % ((*(void *)(a1 + 96) - (void)v62) >> 2);
                  unsigned int v67 = v65;
                }
                else
                {
                  unsigned int v67 = *(_DWORD *)(a1 + 128);
                  uint64_t v68 = *(void *)(a1 + 112);
                  int v69 = (_DWORD *)(v68 + 12 * (int)v65);
                  *(_DWORD *)(a1 + 128) = (*v69 & 0xBFFFFFFF) - 1;
                  *int v69 = 0;
                  v69[1] = v6;
                  v69[2] = v60;
                }
                *(_DWORD *)(v68 + 12 * (int)v67) = v62[v64];
                v62[v64] = v65;
              }
              else
              {
                uint64_t v66 = *(void *)(a1 + 112);
                while (*(_DWORD *)(v66 + 12 * v65 + 4) != v6 || v60 != *(_DWORD *)(v66 + 12 * v65 + 8))
                {
                  unsigned int v65 = *(_DWORD *)(v66 + 12 * v65);
                  if ((v65 & 0x80000000) != 0) {
                    goto LABEL_99;
                  }
                }
              }
              uint64_t result = FSTArc_Con((_DWORD *)(v98 + 16 * v59), *(_DWORD *)(a1 + 76) + v65, -2, -2, 0);
              unsigned int v102 = result;
              if (result) {
                return result;
              }
              ++v59;
            }
            while (v59 != v50);
          }
          if (v23)
          {
            uint64_t v89 = *(void *)(v100 + 56);
            if (!v89 || *(_DWORD *)(v89 - 4) <= v23)
            {
              uint64_t v89 = _FSTState_ReserveArcsInternal(v100, v23, &v102);
              uint64_t result = v102;
              if (v102) {
                return result;
              }
            }
            uint64_t v90 = v101;
            uint64_t v91 = *(unsigned int *)(v101 + 48);
            if (v91)
            {
              unsigned int v92 = 0;
              v93 = *(_OWORD **)(v101 + 56);
              unint64_t v94 = &v93[v91];
              do
              {
                if (*(_DWORD *)v93 == v6) {
                  *(_OWORD *)(v89 + 16 * v92++) = *v93;
                }
                ++v93;
              }
              while (v93 < v94);
            }
            else
            {
              unsigned int v92 = 0;
            }
            *(_DWORD *)(v100 + 48) = v92;
          }
          else
          {
            uint64_t v90 = v101;
          }
          int v95 = *(_DWORD *)(v90 + 8);
          if ((v95 & 0x3FFFFFF) != 1)
          {
            *(_DWORD *)(v90 + 8) = v95 - 1;
            if ((v95 & 0x3FFFFFF) == 0) {
              return 9;
            }
            goto LABEL_153;
          }
          if ((v95 & 0x8000000) != 0) {
            uint64_t v96 = *(void *)(v90 + 16);
          }
          else {
            uint64_t v96 = 0;
          }
          uint64_t result = FSTStatePool_PushFSTState(v96, v90);
          if (!result)
          {
LABEL_153:
            uint64_t result = 0;
            uint64_t v12 = v100;
            goto LABEL_28;
          }
          return result;
        }
      }
      else
      {
        unsigned int v54 = v50 + v22;
      }
      uint64_t v53 = _FSTState_ReserveEpsilonArcsInternal(v51, v54, &v102);
      uint64_t result = v102;
      if (v102) {
        return result;
      }
      goto LABEL_83;
    }
  }
  return result;
}

uint64_t FSTNumArcLimiter_GetFinalStateWeight(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  if (*(_DWORD *)(a1 + 76) > a2) {
    return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 64))(*(void *)(a1 + 64));
  }
  *a3 = 0;
  return 0;
}

uint64_t FSTNumArcLimiter_GetMaxStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = -1;
  return 0;
}

uint64_t FSTNumArcLimiter_GetMemoryInfo(uint64_t a1)
{
  return FSTUnaryOperator_GetMemoryInfo(a1) + 4 * *(unsigned int *)(a1 + 80) + 12 * *(unsigned int *)(a1 + 104) + 64;
}

uint64_t FSTNumArcLimiter_GetStateFlags(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unsigned int v16 = 0;
  unsigned int v5 = *(_DWORD *)(a1 + 76);
  unsigned int v6 = a2 - v5;
  if (a2 >= v5)
  {
    uint64_t v13 = *(void *)(a1 + 112);
    uint64_t result = (*(uint64_t (**)(void, void, uint64_t, _DWORD **))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), *(unsigned int *)(v13 + 12 * v6 + 4), 8, &v16);
    if (result) {
      return result;
    }
    uint64_t v8 = (uint64_t)v16;
    int v12 = (*(_DWORD *)(v13 + 12 * v6 + 8) < v16[8]) << 29;
    goto LABEL_10;
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64));
  uint64_t v8 = (uint64_t)v16;
  if (result) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = v16 == 0;
  }
  if (!v9)
  {
    unsigned int v10 = v16[12] + v16[8];
    unsigned int v11 = v16[2] & 0xF0000000;
    *a3 = v11;
    if (v10 <= *(_DWORD *)(a1 + 72)) {
      goto LABEL_11;
    }
    int v12 = v11 | 0x20000000;
LABEL_10:
    *a3 = v12;
LABEL_11:
    int v14 = *(_DWORD *)(v8 + 8);
    if ((v14 & 0x3FFFFFF) == 1)
    {
      if ((v14 & 0x8000000) != 0) {
        uint64_t v15 = *(void *)(v8 + 16);
      }
      else {
        uint64_t v15 = 0;
      }
      return FSTStatePool_PushFSTState(v15, v8);
    }
    else
    {
      *(_DWORD *)(v8 + 8) = v14 - 1;
      if ((v14 & 0x3FFFFFF) != 0) {
        return 0;
      }
      else {
        return 9;
      }
    }
  }
  return result;
}

uint64_t PNEW_FSTNumArcLimiter_Con(uint64_t a1, uint64_t a2, uint64_t a3, __int32 a4, int8x8_t **a5)
{
  unsigned int v12 = 0;
  unsigned int v10 = (int8x8_t *)OOCAllocator_Malloc(a1, 136, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = FSTNumArcLimiter_Con(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      v10[2] = (int8x8_t)a1;
      *a5 = v10;
    }
  }
  return result;
}

void *GetFSTNumArcLimiterClass()
{
  return &__FSTNumArcLimiter;
}

uint64_t FSTArc_Con(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  a1[3] = a5;
  return 0;
}

uint64_t PNEW_FSTArc_Con(uint64_t a1, int a2, int a3, int a4, int a5, void *a6)
{
  unsigned int v13 = 0;
  unsigned int v11 = (_DWORD *)OOCAllocator_Malloc(a1, 16, &v13);
  uint64_t result = v13;
  if (!v13)
  {
    *unsigned int v11 = a2;
    v11[1] = a3;
    v11[2] = a4;
    v11[3] = a5;
    *a6 = v11;
  }
  return result;
}

uint64_t PDELETE_FSTArc(uint64_t a1, uint64_t a2)
{
  return 0;
}

void FSTCompactRnd_Con(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  *(void *)(a1 + 168) = a5;
  FSTCompactRnd_ConFromBuffers(a1, a2, a3, a4, a4, (const void **)(a1 + 168), a6);
  if (!v7) {
    *(void *)a1 = &__FSTCompactRnd;
  }
}

double FSTCompactRnd_ConFromBuffers(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, const void **a6, uint64_t a7)
{
  int v14 = (char *)*a6;
  int v20 = 0;
  unint64_t v19 = 0;
  if (!FST_GetHeaderSizeInInputBuffer(v14, (uint64_t *)&v19))
  {
    if (a5 >= a4) {
      a5 = a4;
    }
    if (a5 < v19 + 24) {
      goto LABEL_5;
    }
    double result = _FSTBaseFlat_Con((void *)a1, a2, a3, a5, v14, a7, 1u);
    if (!v16)
    {
      *(void *)a1 = &__FSTCompactRnd;
      *(void *)(a1 + 136) = 0;
      *(void *)(a1 + 144) = 0;
      *(void *)(a1 + 112) = a5;
      *(void *)(a1 + 120) = a6;
      *(void *)(a1 + 128) = (a4 + a5 - 1) / a5;
      if (!FST_ReadHeader((_DWORD *)a1, v14, &v20, &v19))
      {
        if (*(_DWORD *)(a1 + 32) != 43 || *(_DWORD *)(a1 + 104) != 1)
        {
LABEL_5:
          err_GenerateErrorData();
          return result;
        }
        uint64_t v17 = *(void *)&v14[v19 + 16];
        *(void *)&long long v18 = v17;
        *((void *)&v18 + 1) = HIDWORD(v17);
        *(_OWORD *)(a1 + 152) = v18;
        *(void *)&double result = *(void *)(a1 + 40) | 0x10000000100;
        *(double *)(a1 + 40) = result;
      }
    }
  }
  return result;
}

int8x8_t FSTCompactRnd_ConFromFST(int8x8_t *a1, uint64_t a2, uint64_t a3)
{
  memset(v19, 0, sizeof(v19));
  unint64_t v17 = 0;
  int8x8_t v18 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  memset(v14, 0, sizeof(v14));
  *a1 = (int8x8_t)&__FSTCompactRnd;
  FSTCompactRndBuilder_Con(v19, a2);
  if (!v7)
  {
    v8.i32[0] = *(_DWORD *)(a3 + 44) & 0x3FFFF & *(_DWORD *)(a3 + 40);
    v8.i32[1] = *(_DWORD *)(a3 + 44) & 0x3FFFF;
    *(void *)&v19[4] = *(void *)&vorr_s8(vand_s8(*(int8x8_t *)&v19[4], (int8x8_t)0x300000003), v8) | 0x10000000100;
    if (!FSTBuilderBfsContext_Con((uint64_t)v14, a2, a3, (uint64_t)&v19[4] + 8, 0)
      && !FSTBuilderBfsContext_Bfs((uint64_t)v14)
      && !(*(unsigned int (**)(_OWORD *))(*(void *)&v14[0] + 16))(v14)
      && !(*(unsigned int (**)(char *))(*((void *)&v19[4] + 1) + 16))((char *)&v19[4]
                                                                                   - *(void *)(*((void *)&v19[4] + 1)
                                                                                               + 24) + 8)
      && !FSTBufferBuilder_ReleaseBuffer((uint64_t)v19, (uint64_t *)&v18, &v17, &v16)
      && !FSTCompactRndBuilder_Des((uint64_t)v19))
    {
      uint64_t v9 = *(void *)(a3 + 48);
      unint64_t v10 = v17;
      uint64_t v11 = v16;
      a1[21] = v18;
      *(double *)&int8x8_t result = FSTCompactRnd_ConFromBuffers((uint64_t)a1, a2, v9, v10, v10, (const void **)&a1[21], v11);
      if (!v12)
      {
        *a1 = (int8x8_t)&__FSTCompactRnd;
        v13.i32[0] = *(_DWORD *)(a3 + 44) & 0x3FFFF & *(_DWORD *)(a3 + 40);
        v13.i32[1] = *(_DWORD *)(a3 + 44) & 0x3FFFF;
        int8x8_t result = vorr_s8(vand_s8(a1[5], (int8x8_t)0x300000003), v13);
        a1[5] = result;
      }
    }
  }
  return result;
}

uint64_t FSTCompactRnd_Des(uint64_t *a1)
{
  if (a1[12])
  {
    if ((unint64_t)a1[16] >= 2)
    {
      unint64_t v2 = 1;
      do
        OOCAllocator_Free(a1[12], *(void *)(a1[15] + 8 * v2++));
      while (v2 < a1[16]);
    }
    uint64_t v3 = a1[15];
    if ((uint64_t *)v3 != a1 + 21) {
      OOCAllocator_Free(a1[12], v3);
    }
  }
  OOCAllocator_Free(a1[3], a1[17]);

  return FSTBaseFlat_Des((uint64_t)a1);
}

uint64_t FSTCompactRnd_FetchState(uint64_t *a1, int a2, unsigned int a3, uint64_t *a4)
{
  int v33 = 0;
  unint64_t v31 = 0;
  uint64_t v32 = 0;
  __FSTCompactRnd_GetFlagsOffsetSize(a1, a2, (unsigned int *)&v33, &v32, &v31);
  int v8 = v33;
  int v9 = FST_CheckQuery(v33, a3);
  if (v32 == 0xFFFFFFFFLL || v9 == 0)
  {
    uint64_t v11 = 0;
    *a4 = 0;
  }
  else
  {
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    unint64_t v12 = v31;
    uint64_t StateInfo = __FSTCompactRnd_GetStateInfo(a1, v32, v31, (const void **)&v30);
    uint64_t v11 = StateInfo;
    if (!StateInfo)
    {
      int v14 = v30;
      uint64_t v15 = (unsigned int *)((char *)v30 + v12);
      if (v8 < 0)
      {
        int v14 = v30 + 1;
        unsigned int v16 = bswap32(*v30++);
      }
      else
      {
        unsigned int v16 = 0x7FFFFFFF;
      }
      *(void *)&long long v28 = v14;
      if (v14 == v15)
      {
        unsigned int v17 = 0;
        unsigned int v18 = 0;
      }
      else
      {
        unsigned int v17 = 0;
        unsigned int v18 = 0;
        do
        {
          int v19 = FSTCompactCodec_ScanEncodedArc((uint64_t *)&v28);
          if (v19) {
            unsigned int v20 = v17;
          }
          else {
            unsigned int v20 = v18;
          }
          if (v19) {
            unsigned int v17 = v20 + 1;
          }
          else {
            unsigned int v18 = v20 + 1;
          }
        }
        while ((unsigned int *)v28 != v15);
      }
      uint64_t v11 = FSTStatePool_PopFSTState(a1[6], &v29);
      unsigned int v34 = v11;
      if (!v11)
      {
        uint64_t v21 = v29;
        *(_DWORD *)(v29 + 8) |= v8;
        *(_DWORD *)(v21 + 24) = a2;
        *(_DWORD *)(v21 + 28) = v16;
        if (v17)
        {
          int v22 = *(_OWORD **)(v21 + 40);
          if (!v22 || *((_DWORD *)v22 - 1) <= v17)
          {
            uint64_t v23 = _FSTState_ReserveEpsilonArcsInternal(v21, v17, &v34);
            uint64_t v11 = v34;
            if (v34) {
              return v11;
            }
            int v22 = (_OWORD *)v23;
          }
          uint64_t v21 = v29;
        }
        else
        {
          int v22 = 0;
        }
        if (v18)
        {
          unsigned int v24 = *(_OWORD **)(v21 + 56);
          if (!v24 || *((_DWORD *)v24 - 1) <= v18)
          {
            uint64_t v25 = _FSTState_ReserveArcsInternal(v21, v18, &v34);
            uint64_t v11 = v34;
            if (v34) {
              return v11;
            }
            unsigned int v24 = (_OWORD *)v25;
          }
          uint64_t v21 = v29;
        }
        else
        {
          unsigned int v24 = 0;
        }
        *(_DWORD *)(v21 + 32) = v17;
        *(_DWORD *)(v21 + 48) = v18;
        if (v14 != v15)
        {
          while (1)
          {
            long long v28 = 0uLL;
            FSTCompactCodec_DecodeArcInc((int *)&v28, &v30);
            if (v22)
            {
              if (DWORD1(v28) == -2) {
                break;
              }
            }
            if (v24)
            {
              unint64_t v26 = v24++;
              goto LABEL_43;
            }
LABEL_44:
            if (v30 == v15)
            {
              uint64_t v21 = v29;
              uint64_t v11 = v34;
              goto LABEL_47;
            }
          }
          unint64_t v26 = v22++;
LABEL_43:
          *unint64_t v26 = v28;
          goto LABEL_44;
        }
        uint64_t v11 = 0;
LABEL_47:
        *a4 = v21;
      }
    }
  }
  return v11;
}

void *__FSTCompactRnd_GetFlagsOffsetSize(void *result, int a2, unsigned int *a3, void *a4, void *a5)
{
  int v8 = result;
  uint64_t v21 = *MEMORY[0x263EF8340];
  unint64_t v9 = result[19] + (8 * a2);
  unint64_t v10 = result[14];
  unint64_t v11 = v9 / v10;
  unint64_t v12 = v9 % v10;
  if (v12 + 8 <= v10)
  {
    unsigned int v17 = (unsigned __int8 *)(*(void *)(result[15] + 8 * v11) + v12);
    int v14 = *v17 << 24;
    unsigned int v15 = v14 & 0xF000000 | (v17[1] << 16) | (bswap32(*((unsigned __int16 *)v17 + 1)) >> 16);
    unsigned int v16 = *((_DWORD *)v17 + 1);
  }
  else
  {
    unint64_t v13 = v10 - v12;
    cstdlib_memcpy(v18, (const void *)(*(void *)(result[15] + 8 * v11) + v12), v10 - v12);
    int8x8_t result = cstdlib_memcpy(&v18[v13], *(const void **)(v8[15] + 8 * v11 + 8), 8 - v13);
    int v14 = v18[0] << 24;
    unsigned int v15 = v14 & 0xF000000 | (v18[1] << 16) | (bswap32(v19) >> 16);
    unsigned int v16 = v20;
  }
  *a4 = (int)bswap32(v16);
  *a3 = v14 & 0xF0000000;
  *a5 = v15;
  return result;
}

uint64_t __FSTCompactRnd_GetStateInfo(uint64_t *a1, uint64_t a2, unint64_t a3, const void **a4)
{
  uint64_t result = 0;
  unsigned int v15 = 0;
  unint64_t v6 = a1[20] + a2;
  unint64_t v7 = a1[14];
  unint64_t v8 = v6 / v7;
  unint64_t v9 = (const void *)(*(void *)(a1[15] + 8 * (v6 / v7)) + v6 % v7);
  unint64_t v10 = (v6 + a3) / v7;
  *a4 = v9;
  if (v6 / v7 != v10)
  {
    if (a1[18] >= a3)
    {
      unint64_t v13 = (void *)a1[17];
    }
    else
    {
      a1[18] = a3;
      OOCAllocator_Free(a1[3], a1[17]);
      unint64_t v13 = (void *)OOCAllocator_Malloc(a1[3], a3, &v15);
      a1[17] = (uint64_t)v13;
      uint64_t result = v15;
      if (v15) {
        return result;
      }
      unint64_t v7 = a1[14];
      unint64_t v9 = *a4;
    }
    size_t v14 = v7 + v7 * v8 - v6;
    cstdlib_memcpy(v13, v9, v14);
    if (a3 - v14 <= a1[14])
    {
      cstdlib_memcpy((void *)(a1[17] + v14), *(const void **)(a1[15] + 8 * v10), a3 - v14);
      *a4 = (const void *)a1[17];
      return v15;
    }
    else
    {
      return err_GenerateErrorInternal();
    }
  }
  return result;
}

uint64_t FSTCompactRnd_FillBuffer(uint64_t a1, char *a2, unint64_t *a3)
{
  uint64_t v6 = *(void *)(a1 + 80) - 16;
  uint64_t v16 = 0;
  uint64_t v17 = v6;
  uint64_t result = (uint64_t)FST_GetHeaderSizeInInputBuffer(**(const void ***)(a1 + 120), &v17);
  if (!result)
  {
    uint64_t result = FST_GetHeaderSizeInOutputBuffer(&v16);
    if (!result)
    {
      unint64_t v8 = *(void *)(a1 + 72) - v17 + v16;
      if (a2 && *a3 >= v8)
      {
        uint64_t result = FST_FillHeader((_DWORD *)a1, a2, *(_DWORD *)(a1 + 104), &v16);
        if (result) {
          return result;
        }
        unint64_t v9 = &a2[v16];
        unint64_t v10 = (const void *)(**(void **)(a1 + 120) + v17);
        if (*(void *)(a1 + 128) == 1)
        {
          size_t v11 = *(void *)(a1 + 72) - v17;
        }
        else
        {
          cstdlib_memcpy(v9, v10, *(void *)(a1 + 112) - v17);
          size_t v12 = *(void *)(a1 + 112);
          unint64_t v13 = &a2[v12 + v16 - v17];
          unint64_t v14 = *(void *)(a1 + 128) - 1;
          unint64_t v15 = 1;
          if (v14 >= 2)
          {
            do
            {
              cstdlib_memcpy(v13, *(const void **)(*(void *)(a1 + 120) + 8 * v15), v12);
              size_t v12 = *(void *)(a1 + 112);
              v13 += v12;
              ++v15;
              unint64_t v14 = *(void *)(a1 + 128) - 1;
            }
            while (v15 < v14);
          }
          unint64_t v10 = *(const void **)(*(void *)(a1 + 120) + 8 * v15);
          size_t v11 = *(void *)(a1 + 72) - v12 * v14;
          unint64_t v9 = v13;
        }
        cstdlib_memcpy(v9, v10, v11);
      }
      uint64_t result = 0;
      *a3 = v8;
    }
  }
  return result;
}

uint64_t FSTCompactRnd_GetFinalStateWeight(uint64_t *a1, int a2, unsigned int *a3)
{
  unsigned int v10 = 0;
  unint64_t v8 = 0;
  uint64_t v9 = 0;
  __FSTCompactRnd_GetFlagsOffsetSize(a1, a2, &v10, &v9, &v8);
  if (v9 == 0xFFFFFFFFLL || (v10 & 0x80000000) == 0)
  {
    uint64_t result = 0;
    unsigned int v6 = 0x7FFFFFFF;
  }
  else
  {
    unint64_t v7 = 0;
    uint64_t result = __FSTCompactRnd_GetStateInfo(a1, v9, v8, (const void **)&v7);
    if (result) {
      return result;
    }
    unsigned int v6 = bswap32(*v7);
  }
  *a3 = v6;
  return result;
}

uint64_t FSTCompactRnd_GetStateFlags(void *a1, int a2, unsigned int *a3)
{
  __FSTCompactRnd_GetFlagsOffsetSize(a1, a2, a3, &v5, &v4);
  return 0;
}

void PNEW_FSTCompactRnd_Con(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  int v16 = 0;
  uint64_t v14 = OOCAllocator_Malloc(a1, 176, &v16);
  if (!v16)
  {
    *(void *)(v14 + 168) = a5;
    FSTCompactRnd_ConFromBuffers(v14, a2, a3, a4, a4, (const void **)(v14 + 168), a6);
    if (v15)
    {
      int v16 = v15;
      OOCAllocator_Free(a1, v14);
      *a7 = 0;
    }
    else
    {
      *(void *)uint64_t v14 = &__FSTCompactRnd;
      *(void *)(v14 + 16) = a1;
      *a7 = v14;
    }
  }
}

void PNEW_FSTCompactRnd_ConFromBuffers(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, const void **a6, uint64_t a7, uint64_t *a8)
{
  int v18 = 0;
  uint64_t v16 = OOCAllocator_Malloc(a1, 176, &v18);
  if (!v18)
  {
    FSTCompactRnd_ConFromBuffers(v16, a2, a3, a4, a5, a6, a7);
    int v18 = v17;
    if (v17)
    {
      OOCAllocator_Free(a1, v16);
      *a8 = 0;
    }
    else
    {
      *(void *)(v16 + 16) = a1;
      *a8 = v16;
    }
  }
}

void PNEW_FSTCompactRnd_ConFromFST(uint64_t a1, uint64_t a2, uint64_t a3, int8x8_t **a4)
{
  int v10 = 0;
  unint64_t v8 = (int8x8_t *)OOCAllocator_Malloc(a1, 176, &v10);
  if (!v10)
  {
    FSTCompactRnd_ConFromFST(v8, a2, a3);
    int v10 = v9;
    if (v9)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
    }
    else
    {
      v8[2] = (int8x8_t)a1;
      *a4 = v8;
    }
  }
}

void *GetFSTCompactRndClass()
{
  return &__FSTCompactRnd;
}

void FSTFlatBuilder_Con(void *a1, uint64_t a2)
{
  if (!FSTBufferBuilder_Con(a1, a2))
  {
    *a1 = &__FSTFlatBuilder;
    a1[9] = &unk_26D215D00;
    __FSTFlatBuilder_Init((uint64_t)a1);
  }
}

void __FSTFlatBuilder_Init(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v7 = 0;
  long long v5 = 0u;
  long long v6 = 0u;
  memset(v4, 0, sizeof(v4));
  FST_Con(v4, *(void *)(a1 + 8), 0);
  if (!v2)
  {
    *(void *)(a1 + 80) = 0xFFFFFFFF00000001;
    *(_DWORD *)(a1 + 104) = -1;
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 64) = *(void *)&vand_s8(*(int8x8_t *)(a1 + 64), (int8x8_t)0x300000003) | 0x10000000100;
    *(void *)&long long v5 = 0x200000002;
    *((void *)&v5 + 1) |= 0x10000000100uLL;
    if (!__FSTFlatBuilder_WriteFstBaseHeader((uint64_t *)a1, v4, &v7))
    {
      int v8 = -1;
      uint64_t v10 = 0;
      uint64_t v9 = 0;
      int v11 = v7 + 24;
      if (*(uint64_t *)(a1 + 48) >= 0x7FFFFFFFFFFFFFE8)
      {
        if (err_GenerateErrorCallback()) {
          return;
        }
        goto LABEL_10;
      }
      if ((**(uint64_t (***)(int *, uint64_t, uint64_t, void))(a1 + 16))(&v8, 24, 1, *(void *)(a1 + 24)) == 1)int ErrorCallback = 0; {
      else
      }
        int ErrorCallback = err_GenerateErrorCallback();
      *(void *)(a1 + 48) += 24;
      if (!ErrorCallback) {
LABEL_10:
      }
        FST_Des((uint64_t)v4);
    }
  }
}

void FSTFlatBuilder_ConToStream(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!FSTBufferBuilder_ConToStream(a1, a2, a3, a4, a5))
  {
    *a1 = &__FSTFlatBuilder;
    a1[9] = &unk_26D215D00;
    __FSTFlatBuilder_Init((uint64_t)a1);
  }
}

uint64_t FSTFlatBuilder_Des(uint64_t *a1)
{
  uint64_t v2 = a1[11];
  if (v2) {
    OOCAllocator_Free(a1[1], v2);
  }

  return FSTBufferBuilder_Des(a1);
}

uint64_t FSTFlatBuilder_AddArc(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  v8[0] = a6;
  v8[1] = a3;
  v8[2] = a4;
  v8[3] = a5;
  if (*(uint64_t *)(a1 + 48) < 0x7FFFFFFFFFFFFFF0)
  {
    if ((**(uint64_t (***)(_DWORD *, uint64_t, uint64_t, void))(a1 + 16))(v8, 4, 4, *(void *)(a1 + 24)) == 4) {
      uint64_t result = 0;
    }
    else {
      uint64_t result = err_GenerateErrorCallback();
    }
    *(void *)(a1 + 48) += 16;
  }
  else
  {
    return err_GenerateErrorCallback();
  }
  return result;
}

uint64_t FSTFlatBuilder_ConvertFST(uint64_t a1, _DWORD *a2)
{
  memset(v22, 0, sizeof(v22));
  uint64_t result = FSTCount(*(void *)(a1 + 8), (uint64_t)a2, (uint64_t)v22);
  unsigned int v23 = result;
  if (!result)
  {
    int v5 = v22[0];
    unsigned int v6 = *(_DWORD *)(a1 + 100);
    if (LODWORD(v22[0]) + 2 <= v6
      || ((v7 = v6 + (v6 >> 1), LODWORD(v22[0]) + 2 <= v7) ? (unsigned int v8 = v7) : (unsigned int v8 = LODWORD(v22[0]) + 2),
          *(void *)(a1 + 88) = OOCAllocator_Realloc(*(void *)(a1 + 8), *(void *)(a1 + 88), 4 * v8, &v23),
          *(_DWORD *)(a1 + 100) = v8,
          (uint64_t result = v23) == 0))
    {
      uint64_t result = (*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)a2 + 48))(a2, a1 + 104);
      unsigned int v23 = result;
      if (!result)
      {
        v9.i32[0] = a2[11] & 0x3FFFF & a2[10];
        v9.i32[1] = a2[11] & 0x3FFFF;
        *(void *)(a1 + 64) = *(void *)&vorr_s8(vand_s8(*(int8x8_t *)(a1 + 64), (int8x8_t)0x300000003), v9) | 0x10000000100;
        if (v5 != -1)
        {
          uint64_t v10 = 0;
          uint64_t v11 = a1 + 72;
          while (1)
          {
            uint64_t v21 = 0;
            uint64_t result = (*(uint64_t (**)(_DWORD *, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 120))(a2, v10, 8, &v21);
            unsigned int v23 = result;
            if (result) {
              return result;
            }
            if (!v21) {
              break;
            }
            int v12 = *(_DWORD *)(v21 + 8);
            if (v12 < 0) {
              uint64_t v13 = *(unsigned int *)(v21 + 28);
            }
            else {
              uint64_t v13 = 0;
            }
            uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t, void))v11)(v11 - *(void *)(*(void *)v11 + 24), v10, v12 & 0xF0000000, v13, 0);
            unsigned int v23 = result;
            if (result) {
              return result;
            }
            uint64_t v14 = v21;
            int v15 = *(unsigned int **)(v21 + 40);
            uint64_t v16 = *(void *)(v21 + 56) + 16 * *(unsigned int *)(v21 + 48);
            if (v15 != (unsigned int *)v16)
            {
              int v17 = &v15[4 * *(unsigned int *)(v21 + 32)];
              while (1)
              {
                if (v15 == v17)
                {
                  uint64_t v14 = v21;
                  if (!*(_DWORD *)(v21 + 48)) {
                    break;
                  }
                  int v15 = *(unsigned int **)(v21 + 56);
                }
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, void))(*(void *)v11 + 8))(v11 - *(void *)(*(void *)v11 + 24), v10, v15[1], v15[2], v15[3], *v15);
                unsigned int v23 = result;
                if (result) {
                  return result;
                }
                v15 += 4;
                if (v15 == (unsigned int *)v16)
                {
                  uint64_t v14 = v21;
                  break;
                }
              }
            }
            int v18 = *(_DWORD *)(v14 + 8);
            if ((v18 & 0x3FFFFFF) == 1)
            {
              if ((v18 & 0x8000000) != 0) {
                uint64_t v19 = *(void *)(v14 + 16);
              }
              else {
                uint64_t v19 = 0;
              }
              uint64_t result = FSTStatePool_PushFSTState(v19, v14);
LABEL_32:
              unsigned int v23 = result;
              if (result) {
                return result;
              }
              goto LABEL_33;
            }
            *(_DWORD *)(v14 + 8) = v18 - 1;
            if ((v18 & 0x3FFFFFF) == 0) {
              return 9;
            }
            unsigned int v23 = 0;
LABEL_33:
            BOOL v20 = v10 == v5;
            uint64_t v10 = (v10 + 1);
            if (v20) {
              return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 16))(a1 + 72 - *(void *)(*(void *)(a1 + 72) + 24));
            }
          }
          uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, void, void))v11)(v11 - *(void *)(*(void *)v11 + 24), v10, 0, 0, 0);
          goto LABEL_32;
        }
        return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 16))(a1 + 72 - *(void *)(*(void *)(a1 + 72) + 24));
      }
    }
  }
  return result;
}

void FSTFlatBuilder_Finalize(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v24 = v2;
  uint64_t v25 = 0;
  unsigned int v23 = 0;
  uint64_t v22 = 0;
  long long v20 = 0u;
  long long v21 = 0u;
  memset(v19, 0, sizeof(v19));
  FST_Con(v19, *(void *)(a1 + 8), 0);
  if (v3 || FST_GetHeaderSizeInOutputBuffer(&v22)) {
    return;
  }
  if (!*(_DWORD *)(a1 + 80))
  {
LABEL_61:
    *(_DWORD *)(a1 + 80) = 0;
    FST_Des((uint64_t)v19);
    return;
  }
  if (*(_DWORD *)(a1 + 96))
  {
    uint64_t v4 = 0;
    do
    {
      unsigned int v23 = *(_DWORD *)(*(void *)(a1 + 88) + 4 * v4);
      if (*(uint64_t *)(a1 + 48) <= 0x7FFFFFFFFFFFFFFBLL)
      {
        int ErrorCallback = (**(uint64_t (***)(unsigned int *, uint64_t, uint64_t, void))(a1 + 16))(&v23, 4, 1, *(void *)(a1 + 24)) == 1? 0: err_GenerateErrorCallback();
        *(void *)(a1 + 48) += 4;
      }
      else
      {
        int ErrorCallback = err_GenerateErrorCallback();
      }
      if (ErrorCallback) {
        return;
      }
    }
    while (++v4 < (unint64_t)*(unsigned int *)(a1 + 96));
  }
  OOCAllocator_Free(*(void *)(a1 + 8), *(void *)(a1 + 88));
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 100) = 0;
  unsigned int v23 = (v2 - v22 - 24) >> 4;
  if (*(uint64_t *)(a1 + 48) <= 0x7FFFFFFFFFFFFFFBLL)
  {
    if ((**(uint64_t (***)(unsigned int *, uint64_t, uint64_t, void))(a1 + 16))(&v23, 4, 1, *(void *)(a1 + 24)) == 1)int v6 = 0; {
    else
    }
      int v6 = err_GenerateErrorCallback();
    *(void *)(a1 + 48) += 4;
  }
  else
  {
    int v6 = err_GenerateErrorCallback();
  }
  if (!v6)
  {
    uint64_t v7 = *(void *)(a1 + 48);
    v8.i32[0] = *(_DWORD *)(a1 + 68) & 0x3FFFF & *(_DWORD *)(a1 + 64);
    v8.i32[1] = *(_DWORD *)(a1 + 68) & 0x3FFFF;
    *(void *)&long long v20 = 0x200000002;
    *((int8x8_t *)&v20 + 1) = vorr_s8(v8, vand_s8(*(int8x8_t *)((char *)&v20 + 8), (int8x8_t)0x300000003));
    if (!__FSTFlatBuilder_WriteFstBaseHeader((uint64_t *)a1, v19, &v22))
    {
      HIDWORD(v25) = *(_DWORD *)(a1 + 104);
      if ((*(unsigned int (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v22, 0))
      {
        int v9 = err_GenerateErrorCallback();
        uint64_t v10 = v22;
        *(void *)(a1 + 48) = v22;
        if (v9) {
          return;
        }
      }
      else
      {
        uint64_t v10 = v22;
        *(void *)(a1 + 48) = v22;
      }
      if (v10 <= 0x7FFFFFFFFFFFFFFBLL)
      {
        int v11 = (**(uint64_t (***)(char *, uint64_t, uint64_t, void))(a1 + 16))((char *)&v25 + 4, 4, 1, *(void *)(a1 + 24)) == 1? 0: err_GenerateErrorCallback();
        *(void *)(a1 + 48) += 4;
      }
      else
      {
        int v11 = err_GenerateErrorCallback();
      }
      if (!v11)
      {
        LODWORD(v25) = *(_DWORD *)(a1 + 96);
        if ((*(unsigned int (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v22 + 12, 0))
        {
          int v12 = err_GenerateErrorCallback();
          uint64_t v13 = v22 + 12;
          *(void *)(a1 + 48) = v22 + 12;
          if (v12) {
            return;
          }
        }
        else
        {
          uint64_t v13 = v22 + 12;
          *(void *)(a1 + 48) = v22 + 12;
        }
        if (v13 <= 0x7FFFFFFFFFFFFFFBLL)
        {
          int v14 = (**(uint64_t (***)(uint64_t *, uint64_t, uint64_t, void))(a1 + 16))(&v25, 4, 1, *(void *)(a1 + 24)) == 1? 0: err_GenerateErrorCallback();
          *(void *)(a1 + 48) += 4;
        }
        else
        {
          int v14 = err_GenerateErrorCallback();
        }
        if (!v14)
        {
          if ((*(unsigned int (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v22 + 16, 0))
          {
            int v15 = err_GenerateErrorCallback();
            uint64_t v16 = v22 + 16;
            *(void *)(a1 + 48) = v22 + 16;
            if (v15) {
              return;
            }
          }
          else
          {
            uint64_t v16 = v22 + 16;
            *(void *)(a1 + 48) = v22 + 16;
          }
          if (v16 <= 0x7FFFFFFFFFFFFFFBLL)
          {
            int v17 = (**(uint64_t (***)(uint64_t *, uint64_t, uint64_t, void))(a1 + 16))(&v24, 4, 1, *(void *)(a1 + 24)) == 1? 0: err_GenerateErrorCallback();
            *(void *)(a1 + 48) += 4;
          }
          else
          {
            int v17 = err_GenerateErrorCallback();
          }
          if (!v17)
          {
            if ((*(unsigned int (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v7, 0))
            {
              int v18 = err_GenerateErrorCallback();
              *(void *)(a1 + 48) = v7;
              if (v18) {
                return;
              }
            }
            else
            {
              *(void *)(a1 + 48) = v7;
            }
            *(void *)(a1 + 56) = v7;
            goto LABEL_61;
          }
        }
      }
    }
  }
}

uint64_t __FSTFlatBuilder_WriteFstBaseHeader(uint64_t *a1, _DWORD *a2, uint64_t *a3)
{
  uint64_t result = FST_GetHeaderSizeInOutputBuffer(a3);
  unsigned int v8 = result;
  if (!result)
  {
    uint64_t v7 = (void *)OOCAllocator_Malloc(a1[1], *a3, &v8);
    uint64_t result = v8;
    if (!v8)
    {
      uint64_t result = FST_FillHeader(a2, v7, 3, a3);
      unsigned int v8 = result;
      if (!result)
      {
        if ((*(unsigned int (**)(uint64_t, void, void))(a1[2] + 8))(a1[3], 0, 0))
        {
          uint64_t result = err_GenerateErrorCallback();
          unsigned int v8 = result;
        }
        else
        {
          uint64_t result = v8;
        }
        a1[6] = 0;
        if (!result)
        {
          if ((*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))a1[2])(v7, *a3, 1, a1[3]) == 1)
          {
            uint64_t result = v8;
          }
          else
          {
            uint64_t result = err_GenerateErrorCallback();
            unsigned int v8 = result;
          }
          a1[6] += *a3;
          if (!result)
          {
            OOCAllocator_Free(a1[1], (uint64_t)v7);
            return v8;
          }
        }
      }
    }
  }
  return result;
}

uint64_t FSTFlatBuilder_InitializeState(uint64_t a1, unsigned int a2, int a3, int a4, int a5)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  unsigned int HeaderSizeInOutputBuffer = 0;
  uint64_t v10 = *(void *)(a1 + 48);
  uint64_t v15 = 0;
  unsigned int v11 = *(_DWORD *)(a1 + 100);
  if (a2 + 1 <= v11
    || ((v12 = v11 + (v11 >> 1), a2 + 1 <= v12) ? (unsigned int v13 = v12) : (unsigned int v13 = a2 + 1),
        *(void *)(a1 + 88) = OOCAllocator_Realloc(*(void *)(a1 + 8), *(void *)(a1 + 88), 4 * v13, &HeaderSizeInOutputBuffer), *(_DWORD *)(a1 + 100) = v13, !HeaderSizeInOutputBuffer))
  {
    ++*(_DWORD *)(a1 + 96);
    *(_DWORD *)(a1 + 84) = a2;
    unsigned int HeaderSizeInOutputBuffer = FST_GetHeaderSizeInOutputBuffer(&v15);
    if (!HeaderSizeInOutputBuffer)
    {
      *(_DWORD *)(*(void *)(a1 + 88) + 4 * a2) = a3 | ((v10 - v15 - 24) >> 4);
      if (a5) {
        *(_DWORD *)(a1 + 104) = a2;
      }
      if (a3 < 0)
      {
        v17[0] = a4;
        v17[1] = 0;
        uint64_t v18 = 0;
        if (*(uint64_t *)(a1 + 48) < 0x7FFFFFFFFFFFFFF0)
        {
          if ((**(uint64_t (***)(_DWORD *, uint64_t, uint64_t, void))(a1 + 16))(v17, 4, 4, *(void *)(a1 + 24)) != 4)unsigned int HeaderSizeInOutputBuffer = err_GenerateErrorCallback(); {
          *(void *)(a1 + 48) += 16;
          }
        }
        else
        {
          return err_GenerateErrorCallback();
        }
      }
    }
  }
  return HeaderSizeInOutputBuffer;
}

void PNEW_FSTFlatBuilder_Con(uint64_t a1, uint64_t a2, void *a3)
{
  int v8 = 0;
  int v6 = (void *)OOCAllocator_Malloc(a1, 112, &v8);
  if (!v8)
  {
    FSTFlatBuilder_Con(v6, a2);
    int v8 = v7;
    if (v7)
    {
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
    }
    else
    {
      *a3 = v6;
    }
  }
}

void PNEW_FSTFlatBuilder_ConToStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  int v14 = 0;
  unsigned int v12 = (void *)OOCAllocator_Malloc(a1, 112, &v14);
  if (!v14)
  {
    FSTFlatBuilder_ConToStream(v12, a2, a3, a4, a5);
    int v14 = v13;
    if (v13)
    {
      OOCAllocator_Free(a1, (uint64_t)v12);
      *a6 = 0;
    }
    else
    {
      *a6 = v12;
    }
  }
}

void *GetFSTFlatBuilderClass()
{
  return &__FSTFlatBuilder;
}

void FSTCompactBuilder_Con(void *a1, uint64_t a2)
{
  if (!FSTBufferBuilder_Con(a1, a2))
  {
    *a1 = &__FSTCompactBuilder;
    a1[9] = &unk_26D215D40;
    __FSTCompactBuilder_Init((uint64_t)a1);
  }
}

void __FSTCompactBuilder_Init(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  long long v4 = 0u;
  long long v5 = 0u;
  memset(v3, 0, sizeof(v3));
  FST_Con(v3, *(void *)(a1 + 8), 0);
  if (!v2)
  {
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 80) = 0xFFFFFFFF00000001;
    *(void *)(a1 + 96) = 0xFFFFFFFF00000000;
    *(void *)(a1 + 64) = *(void *)&vand_s8(*(int8x8_t *)(a1 + 64), (int8x8_t)0x300000003) | 0x10000000100;
    if (!dpmemblock_Create(*(void *)(a1 + 8), 4, 0x400u, (uint64_t *)(a1 + 88)))
    {
      *(void *)&long long v4 = 0x200000015;
      *((void *)&v4 + 1) |= 0x10000000100uLL;
      if (!__FSTFlatBuilder_WriteFstBaseHeader((uint64_t *)a1, v3, &v6))
      {
        int v7 = -1;
        uint64_t v9 = 0;
        uint64_t v8 = 0;
        int v10 = v6 + 24;
        if (*(uint64_t *)(a1 + 48) < 0x7FFFFFFFFFFFFFE8)
        {
          if ((**(uint64_t (***)(int *, uint64_t, uint64_t, void))(a1 + 16))(&v7, 24, 1, *(void *)(a1 + 24)) != 1)err_GenerateErrorCallback(); {
          *(void *)(a1 + 48) += 24;
          }
        }
        else
        {
          err_GenerateErrorCallback();
        }
        FST_Des((uint64_t)v3);
      }
    }
  }
}

void FSTCompactBuilder_ConToStream(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!FSTBufferBuilder_ConToStream(a1, a2, a3, a4, a5))
  {
    *a1 = &__FSTCompactBuilder;
    a1[9] = &unk_26D215D40;
    __FSTCompactBuilder_Init((uint64_t)a1);
  }
}

uint64_t FSTCompactBuilder_Des(uint64_t a1)
{
  dpmemblock_Free(*(uint64_t **)(a1 + 88));

  return FSTBufferBuilder_Des((uint64_t *)a1);
}

uint64_t FSTCompactBuilder_AddArc(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v9[0] = 0;
  v9[1] = 0;
  uint64_t v8 = 17;
  uint64_t result = FSTArc_Con(v9, a6, a3, a4, a5);
  if (!result)
  {
    FSTCompactCodec_EncodeArc((unsigned int *)v9, (uint64_t)v10, &v8);
    if (*(void *)(a1 + 48) <= (v8 ^ 0x7FFFFFFFFFFFFFFFLL))
    {
      if ((**(uint64_t (***)(unsigned char *))(a1 + 16))(v10) == 1) {
        uint64_t result = 0;
      }
      else {
        uint64_t result = err_GenerateErrorCallback();
      }
      *(void *)(a1 + 48) += v8;
    }
    else
    {
      return err_GenerateErrorCallback();
    }
  }
  return result;
}

uint64_t FSTCompactBuilder_ConvertFST(uint64_t a1, _DWORD *a2)
{
  v25[3] = *MEMORY[0x263EF8340];
  memset(v24, 0, sizeof(v24));
  uint64_t result = FSTCount(*(void *)(a1 + 8), (uint64_t)a2, (uint64_t)v24);
  if (result) {
    return result;
  }
  int v5 = v24[0];
  v25[0] = 0;
  unsigned int v6 = LODWORD(v24[0]) + 2;
  uint64_t v7 = *(void *)(a1 + 88);
  unsigned int v8 = *(_DWORD *)(v7 + 32);
  if (LODWORD(v24[0]) + 2 <= v8)
  {
    *(_DWORD *)(v7 + 32) = v6;
  }
  else
  {
    unsigned int v9 = v8 + 1;
    do
    {
      uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 88), v25, 0);
      if (v9 >= v6) {
        break;
      }
      ++v9;
    }
    while (!result);
    if (result) {
      return result;
    }
  }
  uint64_t result = (*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)a2 + 48))(a2, a1 + 100);
  if (!result)
  {
    v10.i32[0] = a2[11] & 0x3FFFF & a2[10];
    v10.i32[1] = a2[11] & 0x3FFFF;
    *(void *)(a1 + 64) = *(void *)&vorr_s8(vand_s8(*(int8x8_t *)(a1 + 64), (int8x8_t)0x300000003), v10) | 0x10000000100;
    if (v5 == -1)
    {
      return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 16))(a1 + 72 - *(void *)(*(void *)(a1 + 72) + 24));
    }
    else
    {
      uint64_t v11 = 0;
      uint64_t v12 = a1 + 72;
      while (1)
      {
        uint64_t v23 = 0;
        uint64_t result = (*(uint64_t (**)(_DWORD *, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 120))(a2, v11, 8, &v23);
        if (result) {
          break;
        }
        if (v23)
        {
          int v13 = *(_DWORD *)(v23 + 8);
          if (v13 < 0) {
            uint64_t v14 = *(unsigned int *)(v23 + 28);
          }
          else {
            uint64_t v14 = 0;
          }
          uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t, void))v12)(v12 - *(void *)(*(void *)v12 + 24), v11, v13 & 0xF0000000, v14, 0);
          if (result) {
            return result;
          }
          uint64_t v15 = v23;
          uint64_t v16 = *(unsigned int **)(v23 + 40);
          uint64_t v17 = *(void *)(v23 + 56) + 16 * *(unsigned int *)(v23 + 48);
          if (v16 != (unsigned int *)v17)
          {
            uint64_t v18 = &v16[4 * *(unsigned int *)(v23 + 32)];
            while (1)
            {
              uint64_t v22 = 17;
              if (v16 == v18)
              {
                uint64_t v15 = v23;
                if (!*(_DWORD *)(v23 + 48)) {
                  break;
                }
                uint64_t v16 = *(unsigned int **)(v23 + 56);
              }
              FSTCompactCodec_EncodeArc(v16, (uint64_t)v25, &v22);
              if (*(void *)(a1 + 48) <= (v22 ^ 0x7FFFFFFFFFFFFFFFLL))
              {
                uint64_t result = (**(uint64_t (***)(void *))(a1 + 16))(v25) == 1 ? 0 : err_GenerateErrorCallback();
                *(void *)(a1 + 48) += v22;
              }
              else
              {
                uint64_t result = err_GenerateErrorCallback();
              }
              if (result) {
                return result;
              }
              v16 += 4;
              if (v16 == (unsigned int *)v17)
              {
                uint64_t v15 = v23;
                break;
              }
            }
          }
          int v19 = *(_DWORD *)(v15 + 8);
          if ((v19 & 0x3FFFFFF) == 1)
          {
            if ((v19 & 0x8000000) != 0) {
              uint64_t v20 = *(void *)(v15 + 16);
            }
            else {
              uint64_t v20 = 0;
            }
            uint64_t result = FSTStatePool_PushFSTState(v20, v15);
            if (result) {
              return result;
            }
          }
          else
          {
            *(_DWORD *)(v15 + 8) = v19 - 1;
            if ((v19 & 0x3FFFFFF) == 0) {
              return 9;
            }
          }
        }
        else
        {
          uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, void, void))v12)(v12 - *(void *)(*(void *)v12 + 24), v11, 0, 0, 0);
          if (result) {
            return result;
          }
        }
        BOOL v21 = v11 == v5;
        uint64_t v11 = (v11 + 1);
        if (v21) {
          return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 16))(a1 + 72 - *(void *)(*(void *)(a1 + 72) + 24));
        }
      }
    }
  }
  return result;
}

uint64_t FSTCompactBuilder_Finalize(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v23 = v2;
  uint64_t v24 = 0;
  unsigned int v22 = 0;
  uint64_t v21 = 0;
  long long v19 = 0u;
  long long v20 = 0u;
  memset(v18, 0, sizeof(v18));
  FST_Con(v18, *(void *)(a1 + 8), 0);
  uint64_t HeaderSizeInOutputBuffer = v3;
  if (v3) {
    return HeaderSizeInOutputBuffer;
  }
  uint64_t HeaderSizeInOutputBuffer = FST_GetHeaderSizeInOutputBuffer(&v21);
  if (HeaderSizeInOutputBuffer) {
    return HeaderSizeInOutputBuffer;
  }
  unsigned int v22 = v2 - v21 - 24;
  if (!*(_DWORD *)(a1 + 80)) {
    return FST_Des((uint64_t)v18);
  }
  unsigned int v6 = ((int)v2 - (int)v21 - 24) % 7u;
  unsigned int v7 = v6 ^ 7;
  if (v6) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8)
  {
    int v17 = -1;
    if (v7 < 5)
    {
      uint64_t HeaderSizeInOutputBuffer = 0;
      unsigned int v9 = v6 ^ 7;
    }
    else
    {
      uint64_t HeaderSizeInOutputBuffer = 0;
      unsigned int v9 = v6 ^ 7;
      do
      {
        if (*(uint64_t *)(a1 + 48) <= 0x7FFFFFFFFFFFFFFBLL)
        {
          if ((**(uint64_t (***)(int *, uint64_t, uint64_t, void))(a1 + 16))(&v17, 4, 1, *(void *)(a1 + 24)) != 1)uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback(); {
          *(void *)(a1 + 48) += 4;
          }
        }
        else
        {
          uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
        }
        v9 -= 4;
      }
      while (v9 > 4);
    }
    if (*(void *)(a1 + 48) <= (v9 ^ 0x7FFFFFFFFFFFFFFFLL))
    {
      if ((**(uint64_t (***)(int *, void, uint64_t, void))(a1 + 16))(&v17, v9, 1, *(void *)(a1 + 24)) != 1) {
        uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
      }
      *(void *)(a1 + 48) += v9;
    }
    else
    {
      uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
    }
    if (HeaderSizeInOutputBuffer) {
      return HeaderSizeInOutputBuffer;
    }
    v22 += v7;
    v2 += v7;
    uint64_t v23 = v2;
  }
  if ((v2 & 3) != 0)
  {
    uint64_t v10 = 4 - (v2 & 3);
    int v17 = -1;
    if (*(void *)(a1 + 48) <= (v10 ^ 0x7FFFFFFFFFFFFFFFLL))
    {
      if ((**(uint64_t (***)(int *, uint64_t, uint64_t, void))(a1 + 16))(&v17, v10, 1, *(void *)(a1 + 24)) == 1)uint64_t HeaderSizeInOutputBuffer = 0; {
      else
      }
        uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
      *(void *)(a1 + 48) += v10;
    }
    else
    {
      uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
    }
    if (HeaderSizeInOutputBuffer) {
      return HeaderSizeInOutputBuffer;
    }
    uint64_t v23 = v2 + v10;
  }
  if (*(_DWORD *)(a1 + 96))
  {
    unsigned int v11 = 0;
    do
    {
      int v17 = 0;
      int v17 = *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 88) + 8)
                                  + 8 * (v11 >> *(_WORD *)(*(void *)(a1 + 88) + 44)))
                      + 4 * (v11 & ~(-1 << *(_WORD *)(*(void *)(a1 + 88) + 44))));
      if (*(uint64_t *)(a1 + 48) <= 0x7FFFFFFFFFFFFFFBLL)
      {
        uint64_t HeaderSizeInOutputBuffer = (**(uint64_t (***)(int *, uint64_t, uint64_t, void))(a1 + 16))(&v17, 4, 1, *(void *)(a1 + 24)) == 1? 0: err_GenerateErrorCallback();
        *(void *)(a1 + 48) += 4;
      }
      else
      {
        uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
      }
      if (HeaderSizeInOutputBuffer) {
        return HeaderSizeInOutputBuffer;
      }
    }
    while (++v11 < *(_DWORD *)(a1 + 96));
  }
  dpmemblock_Reset(*(void *)(a1 + 88));
  v22 /= 7u;
  if (*(uint64_t *)(a1 + 48) <= 0x7FFFFFFFFFFFFFFBLL)
  {
    if ((**(uint64_t (***)(unsigned int *, uint64_t, uint64_t, void))(a1 + 16))(&v22, 4, 1, *(void *)(a1 + 24)) == 1)uint64_t HeaderSizeInOutputBuffer = 0; {
    else
    }
      uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
    *(void *)(a1 + 48) += 4;
  }
  else
  {
    uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
  }
  if (!HeaderSizeInOutputBuffer)
  {
    uint64_t v12 = *(void *)(a1 + 48);
    v13.i32[0] = *(_DWORD *)(a1 + 68) & 0x3FFFF & *(_DWORD *)(a1 + 64);
    v13.i32[1] = *(_DWORD *)(a1 + 68) & 0x3FFFF;
    *(void *)&long long v19 = 0x200000015;
    *((int8x8_t *)&v19 + 1) = vorr_s8(v13, vand_s8(*(int8x8_t *)((char *)&v19 + 8), (int8x8_t)0x300000003));
    uint64_t HeaderSizeInOutputBuffer = __FSTFlatBuilder_WriteFstBaseHeader((uint64_t *)a1, v18, &v21);
    if (!HeaderSizeInOutputBuffer)
    {
      HIDWORD(v24) = *(_DWORD *)(a1 + 100);
      if ((*(unsigned int (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v21, 0))
      {
        uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
        uint64_t v14 = v21;
        *(void *)(a1 + 48) = v21;
        if (HeaderSizeInOutputBuffer) {
          return HeaderSizeInOutputBuffer;
        }
      }
      else
      {
        uint64_t v14 = v21;
        *(void *)(a1 + 48) = v21;
      }
      if (v14 <= 0x7FFFFFFFFFFFFFFBLL)
      {
        uint64_t HeaderSizeInOutputBuffer = (**(uint64_t (***)(char *, uint64_t, uint64_t, void))(a1 + 16))((char *)&v24 + 4, 4, 1, *(void *)(a1 + 24)) == 1? 0: err_GenerateErrorCallback();
        *(void *)(a1 + 48) += 4;
      }
      else
      {
        uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
      }
      if (!HeaderSizeInOutputBuffer)
      {
        LODWORD(v24) = *(_DWORD *)(a1 + 96);
        if ((*(unsigned int (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v21 + 12, 0))
        {
          uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
          uint64_t v15 = v21 + 12;
          *(void *)(a1 + 48) = v21 + 12;
          if (HeaderSizeInOutputBuffer) {
            return HeaderSizeInOutputBuffer;
          }
        }
        else
        {
          uint64_t v15 = v21 + 12;
          *(void *)(a1 + 48) = v21 + 12;
        }
        if (v15 <= 0x7FFFFFFFFFFFFFFBLL)
        {
          uint64_t HeaderSizeInOutputBuffer = (**(uint64_t (***)(uint64_t *, uint64_t, uint64_t, void))(a1 + 16))(&v24, 4, 1, *(void *)(a1 + 24)) == 1? 0: err_GenerateErrorCallback();
          *(void *)(a1 + 48) += 4;
        }
        else
        {
          uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
        }
        if (!HeaderSizeInOutputBuffer)
        {
          if ((*(unsigned int (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v21 + 16, 0))
          {
            uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
            uint64_t v16 = v21 + 16;
            *(void *)(a1 + 48) = v21 + 16;
            if (HeaderSizeInOutputBuffer) {
              return HeaderSizeInOutputBuffer;
            }
          }
          else
          {
            uint64_t v16 = v21 + 16;
            *(void *)(a1 + 48) = v21 + 16;
          }
          if (v16 <= 0x7FFFFFFFFFFFFFFBLL)
          {
            uint64_t HeaderSizeInOutputBuffer = (**(uint64_t (***)(uint64_t *, uint64_t, uint64_t, void))(a1 + 16))(&v23, 4, 1, *(void *)(a1 + 24)) == 1? 0: err_GenerateErrorCallback();
            *(void *)(a1 + 48) += 4;
          }
          else
          {
            uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
          }
          if (!HeaderSizeInOutputBuffer)
          {
            if ((*(unsigned int (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v12, 0))
            {
              uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
              *(void *)(a1 + 48) = v12;
              if (HeaderSizeInOutputBuffer) {
                return HeaderSizeInOutputBuffer;
              }
            }
            else
            {
              *(void *)(a1 + 48) = v12;
            }
            *(void *)(a1 + 56) = v12;
            *(_DWORD *)(a1 + 80) = 0;
            return FST_Des((uint64_t)v18);
          }
        }
      }
    }
  }
  return HeaderSizeInOutputBuffer;
}

uint64_t FSTCompactBuilder_InitializeState(uint64_t a1, unsigned int a2, int a3, unsigned int a4, int a5)
{
  uint64_t v10 = *(void *)(a1 + 48);
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  unsigned int v11 = a2 + 1;
  uint64_t v12 = *(void *)(a1 + 88);
  unsigned int v13 = *(_DWORD *)(v12 + 32);
  if (a2 + 1 <= v13)
  {
    *(_DWORD *)(v12 + 32) = v11;
  }
  else
  {
    unsigned int v14 = v13 + 1;
    do
    {
      uint64_t NewElement = dpmemblock_GetNewElement(*(void *)(a1 + 88), &v26, 0);
      uint64_t HeaderSizeInOutputBuffer = NewElement;
      if (v14 >= v11) {
        break;
      }
      ++v14;
    }
    while (!NewElement);
    if (NewElement) {
      return HeaderSizeInOutputBuffer;
    }
  }
  ++*(_DWORD *)(a1 + 96);
  *(_DWORD *)(a1 + 84) = a2;
  uint64_t HeaderSizeInOutputBuffer = FST_GetHeaderSizeInOutputBuffer(&v27);
  if (HeaderSizeInOutputBuffer) {
    return HeaderSizeInOutputBuffer;
  }
  unsigned int v18 = v10 - v27 - 24;
  unsigned int v19 = (v18 % 7) ^ 7;
  if (v18 % 7) {
    BOOL v20 = v19 == 0;
  }
  else {
    BOOL v20 = 1;
  }
  if (!v20)
  {
    unsigned int v25 = a4;
    LODWORD(v26) = -1;
    if (v19 < 5)
    {
      uint64_t HeaderSizeInOutputBuffer = 0;
      unsigned int v21 = (v18 % 7) ^ 7;
    }
    else
    {
      uint64_t HeaderSizeInOutputBuffer = 0;
      unsigned int v21 = (v18 % 7) ^ 7;
      do
      {
        if (*(uint64_t *)(a1 + 48) <= 0x7FFFFFFFFFFFFFFBLL)
        {
          if ((**(uint64_t (***)(uint64_t *, uint64_t, uint64_t, void))(a1 + 16))(&v26, 4, 1, *(void *)(a1 + 24)) != 1)uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback(); {
          *(void *)(a1 + 48) += 4;
          }
        }
        else
        {
          uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
        }
        v21 -= 4;
      }
      while (v21 > 4);
    }
    uint64_t v22 = v21;
    if (*(void *)(a1 + 48) <= (v21 ^ 0x7FFFFFFFFFFFFFFFLL))
    {
      uint64_t v23 = (**(uint64_t (***)(uint64_t *, void, uint64_t, void))(a1 + 16))(&v26, v21, 1, *(void *)(a1 + 24));
      a4 = v25;
      if (v23 != 1) {
        uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
      }
      *(void *)(a1 + 48) += v22;
      if (HeaderSizeInOutputBuffer) {
        return HeaderSizeInOutputBuffer;
      }
    }
    else
    {
      uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
      a4 = v25;
      if (HeaderSizeInOutputBuffer) {
        return HeaderSizeInOutputBuffer;
      }
    }
    v18 += v19;
  }
  if (v18 >> 28 >= 7) {
    return err_GenerateErrorLimit();
  }
  *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 8
                                                                  * (a2 >> *(_WORD *)(*(void *)(a1 + 88) + 44)))
            + 4 * (a2 & ~(-1 << *(_WORD *)(*(void *)(a1 + 88) + 44)))) = a3 | (v18 / 7);
  if (a5) {
    *(_DWORD *)(a1 + 100) = a2;
  }
  if ((a3 & 0x80000000) == 0) {
    return 0;
  }
  LODWORD(v26) = bswap32(a4);
  if (*(uint64_t *)(a1 + 48) > 0x7FFFFFFFFFFFFFFBLL) {
    return err_GenerateErrorCallback();
  }
  if ((**(uint64_t (***)(uint64_t *, uint64_t, uint64_t, void))(a1 + 16))(&v26, 4, 1, *(void *)(a1 + 24)) == 1)uint64_t HeaderSizeInOutputBuffer = 0; {
  else
  }
    uint64_t HeaderSizeInOutputBuffer = err_GenerateErrorCallback();
  *(void *)(a1 + 48) += 4;
  return HeaderSizeInOutputBuffer;
}

void PNEW_FSTCompactBuilder_Con(uint64_t a1, uint64_t a2, void *a3)
{
  int v8 = 0;
  unsigned int v6 = (void *)OOCAllocator_Malloc(a1, 104, &v8);
  if (!v8)
  {
    FSTCompactBuilder_Con(v6, a2);
    int v8 = v7;
    if (v7)
    {
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
    }
    else
    {
      *a3 = v6;
    }
  }
}

void PNEW_FSTCompactBuilder_ConToStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  int v14 = 0;
  uint64_t v12 = (void *)OOCAllocator_Malloc(a1, 104, &v14);
  if (!v14)
  {
    FSTCompactBuilder_ConToStream(v12, a2, a3, a4, a5);
    int v14 = v13;
    if (v13)
    {
      OOCAllocator_Free(a1, (uint64_t)v12);
      *a6 = 0;
    }
    else
    {
      *a6 = v12;
    }
  }
}

void *GetFSTCompactBuilderClass()
{
  return &__FSTCompactBuilder;
}

double FSTMapLabels2_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7, int a8, int a9)
{
  if (!_FSTUnaryOperator_Con(a1, a2, a3))
  {
    *(void *)a1 = &__FSTMapLabels2;
    *(_DWORD *)(a1 + 32) = 268435461;
    *(void *)(a1 + 72) = a4;
    *(_DWORD *)(a1 + 80) = a5;
    *(_DWORD *)(a1 + 84) = a6;
    *(void *)(a1 + 88) = a7;
    *(_DWORD *)(a1 + 96) = a8;
    *(_DWORD *)(a1 + 100) = a9;
    double result = NAN;
    *(void *)(a1 + 104) = 0x7FFFFFFF80000000;
  }
  return result;
}

uint64_t FSTMapLabels2_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v26 = 0;
  *a4 = 0;
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, a3, &v26);
  uint64_t v7 = v26;
  if (result) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = v26 == 0;
  }
  if (!v8)
  {
    if ((*(_DWORD *)(v26 + 8) & 0x3FFFFFE) != 0)
    {
      uint64_t v25 = 0;
      uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v25);
      if (result) {
        return result;
      }
      uint64_t result = FSTState_Copy(v25, v26);
      if (result) {
        return result;
      }
      int v9 = *(_DWORD *)(v26 + 8);
      *(_DWORD *)(v26 + 8) = v9 - 1;
      if ((v9 & 0x3FFFFFF) == 0) {
        return 9;
      }
      uint64_t v7 = v25;
    }
    int v11 = *(_DWORD *)(a1 + 96);
    int v10 = *(_DWORD *)(a1 + 100);
    uint64_t v12 = *(unsigned int *)(v7 + 48);
    if (v12)
    {
      int v14 = *(_DWORD *)(a1 + 80);
      int v13 = *(_DWORD *)(a1 + 84);
      unint64_t v15 = *(void *)(v7 + 56);
      unint64_t v16 = v15 + 16 * v12;
      int v17 = *(_DWORD *)(a1 + 104);
      do
      {
        int v18 = *(_DWORD *)(v15 + 4);
        unsigned int v19 = v18 - v13;
        if (v18 - v13 >= 0 && (int)v19 < v14) {
          *(_DWORD *)(v15 + 4) = *(_DWORD *)(*(void *)(a1 + 72) + 4 * v19);
        }
        if (v18 >= v17 && v18 <= *(_DWORD *)(a1 + 108))
        {
          int v20 = *(_DWORD *)(v15 + 8) - v10;
          if (v20 >= 0 && v20 < v11) {
            *(_DWORD *)(v15 + 8) = *(_DWORD *)(*(void *)(a1 + 88) + 4 * v20);
          }
        }
        v15 += 16;
      }
      while (v15 < v16);
    }
    else
    {
      int v17 = *(_DWORD *)(a1 + 104);
    }
    if (v17 <= -2 && *(int *)(a1 + 108) >= -2)
    {
      uint64_t v21 = *(unsigned int *)(v7 + 32);
      if (v21)
      {
        unint64_t v22 = *(void *)(v7 + 40);
        unint64_t v23 = v22 + 16 * v21;
        do
        {
          int v24 = *(_DWORD *)(v22 + 8) - v10;
          if (v24 >= 0 && v24 < v11) {
            *(_DWORD *)(v22 + 8) = *(_DWORD *)(*(void *)(a1 + 88) + 4 * v24);
          }
          v22 += 16;
        }
        while (v22 < v23);
      }
    }
    uint64_t result = 0;
    *a4 = v7;
  }
  return result;
}

uint64_t FSTMapLabels2_GetMemoryInfo(uint64_t a1)
{
  return FSTUnaryOperator_GetMemoryInfo(a1) + 4 * (*(_DWORD *)(a1 + 96) + *(_DWORD *)(a1 + 80)) + 40;
}

uint64_t FSTMapLabels2_GetStateFlags(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  return FST_GetStateFlags(*(void *)(a1 + 64), a2, a3);
}

uint64_t FSTMapLabels2_SetInputLabelRangeForOutputMapping(uint64_t result, int a2, int a3)
{
  *(_DWORD *)(result + 104) = a2;
  *(_DWORD *)(result + 108) = a3;
  return result;
}

double PNEW_FSTMapLabels2_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7, int a8, int a9, uint64_t *a10)
{
  int v21 = 0;
  uint64_t v18 = OOCAllocator_Malloc(a1, 112, &v21);
  if (!v21)
  {
    int v20 = _FSTUnaryOperator_Con(v18, a2, a3);
    if (v20)
    {
      int v21 = v20;
      OOCAllocator_Free(a1, v18);
      *a10 = 0;
    }
    else
    {
      *(void *)uint64_t v18 = &__FSTMapLabels2;
      *(_DWORD *)(v18 + 32) = 268435461;
      *(void *)(v18 + 72) = a4;
      *(_DWORD *)(v18 + 80) = a5;
      *(_DWORD *)(v18 + 84) = a6;
      *(void *)(v18 + 88) = a7;
      *(_DWORD *)(v18 + 96) = a8;
      *(_DWORD *)(v18 + 100) = a9;
      double result = NAN;
      *(void *)(v18 + 104) = 0x7FFFFFFF80000000;
      *(void *)(v18 + 16) = a1;
      *a10 = v18;
    }
  }
  return result;
}

void *GetFSTMapLabels2Class()
{
  return &__FSTMapLabels2;
}

uint64_t FSTDfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = Object_Con((void *)a1);
  if (!v6)
  {
    *(_DWORD *)(a1 + 16) = 0;
    *(void *)(a1 + 40) = a3;
    *(void *)(a1 + 48) = 0;
    *(_DWORD *)(a1 + 56) = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)a1 = &__FSTDfsContext;
    *(void *)(a1 + 8) = a2;
    (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
  }
  return v6;
}

uint64_t FSTDfsContext_Des(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 32))(*(void *)(a1 + 40));
  if (!result)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3) {
      OOCAllocator_Free(*(void *)(a1 + 8), v3);
    }
    return Object_Des();
  }
  return result;
}

uint64_t FSTDfsContext_AbortDFS()
{
  return 0;
}

uint64_t FSTDfsContext_Dfs(uint64_t a1)
{
  int v47 = 0;
  int v48 = 0;
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 8);
  unsigned int v49 = (*(uint64_t (**)(uint64_t, int *))(*(void *)v2 + 48))(v2, &v48);
  if (v49) {
    return v49;
  }
  unsigned int v49 = (*(uint64_t (**)(uint64_t, int *))(*(void *)v2 + 72))(v2, &v47);
  if (v49) {
    return v49;
  }
  if (v48 == -1)
  {
    unsigned int v44 = 0;
    uint64_t v7 = 0;
    BOOL v8 = 0;
  }
  else
  {
    int v5 = (_DWORD *)OOCAllocator_Realloc(v3, 0, 32, &v49);
    BOOL v6 = v49 == 0;
    if (v49) {
      return v49;
    }
    uint64_t v7 = (uint64_t)v5;
    _DWORD *v5 = v48;
    BOOL v8 = v5 + 1;
    uint64_t v9 = (v48 + 1);
    uint64_t v10 = *(void *)(a1 + 24);
    int v11 = *(unsigned char **)(a1 + 32);
    unsigned int v12 = v11 - v10;
    if (v9 < (int)v11 - (int)v10) {
      goto LABEL_22;
    }
    unsigned int v13 = *(_DWORD *)(a1 + 16);
    if (v9 > v13)
    {
      unsigned int v14 = 2 * v13;
      unsigned int v15 = v13 + 1000000;
      if (v14 >= v15) {
        unsigned int v14 = v15;
      }
      if (v14 <= v9) {
        unsigned int v14 = v48 + 1;
      }
      if (v14 <= 8) {
        uint64_t v16 = 8;
      }
      else {
        uint64_t v16 = v14;
      }
      uint64_t v17 = OOCAllocator_Realloc(v3, v10, v16, &v49);
      *(void *)(a1 + 24) = v17;
      if (v49) {
        return v49;
      }
      uint64_t v10 = v17;
      *(_DWORD *)(a1 + 16) = v16;
      int v11 = (unsigned char *)(v17 + v12);
      *(void *)(a1 + 32) = v11;
    }
    if ((unint64_t)v11 >= v10 + v9)
    {
LABEL_22:
      unsigned int v44 = 8;
    }
    else
    {
      unsigned int v44 = 8 * v6;
      do
      {
        *int v11 = 0;
        int v11 = (unsigned char *)(*(void *)(a1 + 32) + 1);
        *(void *)(a1 + 32) = v11;
      }
      while ((unint64_t)v11 < v10 + v9);
    }
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 24))(a1)) {
    BOOL v18 = 1;
  }
  else {
    BOOL v18 = v7 == (void)v8;
  }
  if (!v18)
  {
    unsigned int v19 = v8;
    uint64_t v43 = v3;
    do
    {
      unsigned int v21 = *--v19;
      uint64_t v20 = v21;
      uint64_t v22 = *(void *)(a1 + 24);
      int v23 = *(unsigned __int8 *)(v22 + v21);
      if (v23 == 1)
      {
        *(unsigned char *)(v22 + v20) = 2;
        if (*(_DWORD *)(a1 + 56))
        {
          unsigned int v49 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 56))(a1, v20);
          if (v49) {
            return v49;
          }
        }
      }
      else if (!v23)
      {
        uint64_t v45 = v7;
        uint64_t v46 = 0;
        unsigned int v49 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)v2 + 120))(v2, v20, 8, &v46);
        if (v49) {
          return v49;
        }
        *(unsigned char *)(*(void *)(a1 + 24) + v20) = 1;
        unsigned int v49 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 32))(a1, v46);
        if (v49) {
          return v49;
        }
        uint64_t v24 = v46;
        uint64_t v25 = *(_DWORD **)(v46 + 40);
        uint64_t v26 = *(void *)(v46 + 56) + 16 * *(unsigned int *)(v46 + 48);
        if (v25 != (_DWORD *)v26)
        {
          uint64_t v27 = &v25[4 * *(unsigned int *)(v46 + 32)];
          do
          {
            if (v25 == v27)
            {
              uint64_t v24 = v46;
              if (!*(_DWORD *)(v46 + 48)) {
                goto LABEL_70;
              }
              uint64_t v25 = *(_DWORD **)(v46 + 56);
            }
            uint64_t v28 = (*v25 + 1);
            uint64_t v29 = *(void *)(a1 + 24);
            uint64_t v30 = *(unsigned char **)(a1 + 32);
            unsigned int v31 = v30 - v29;
            if (v28 >= (int)v30 - (int)v29)
            {
              if (v28 >= *(_DWORD *)(a1 + 16))
              {
                unsigned int v32 = 120 * v31 / 0x64;
                if (v32 <= v28) {
                  unsigned int v32 = *v25 + 1;
                }
                if (v32 <= 8) {
                  uint64_t v33 = 8;
                }
                else {
                  uint64_t v33 = v32;
                }
                uint64_t v34 = OOCAllocator_Realloc(v43, v29, v33, &v49);
                *(void *)(a1 + 24) = v34;
                if (v49) {
                  return v49;
                }
                uint64_t v29 = v34;
                *(_DWORD *)(a1 + 16) = v33;
                uint64_t v30 = (unsigned char *)(v34 + v31);
                *(void *)(a1 + 32) = v30;
              }
              if ((unint64_t)v30 < v29 + v28)
              {
                do
                {
                  *uint64_t v30 = 0;
                  uint64_t v30 = (unsigned char *)(*(void *)(a1 + 32) + 1);
                  *(void *)(a1 + 32) = v30;
                }
                while ((unint64_t)v30 < v29 + v28);
                uint64_t v29 = *(void *)(a1 + 24);
              }
            }
            if (*(unsigned char *)(v29 + *v25))
            {
              if (*(_DWORD *)(a1 + 48))
              {
                unsigned int v49 = (*(uint64_t (**)(uint64_t, uint64_t, _DWORD *))(*(void *)a1 + 48))(a1, v20, v25);
                if (v49) {
                  return v49;
                }
              }
            }
            else
            {
              if (*(_DWORD *)(a1 + 52))
              {
                unsigned int v49 = (*(uint64_t (**)(uint64_t, uint64_t, _DWORD *))(*(void *)a1 + 40))(a1, v20, v25);
                if (v49) {
                  return v49;
                }
              }
              unint64_t v35 = (unint64_t)v8 - v45;
              unsigned int v36 = (((unint64_t)v8 - v45) >> 2) + 1;
              if (v36 > v44)
              {
                unsigned int v37 = 2 * v44;
                if (2 * v44 >= v44 + 1000000) {
                  unsigned int v37 = v44 + 1000000;
                }
                if (v37 > v36) {
                  unsigned int v36 = v37;
                }
                if (v36 <= 8) {
                  unsigned int v38 = 8;
                }
                else {
                  unsigned int v38 = v36;
                }
                uint64_t v39 = OOCAllocator_Realloc(v43, v45, 4 * v38, &v49);
                if (v49) {
                  return v49;
                }
                unsigned int v44 = v38;
                uint64_t v45 = v39;
                BOOL v8 = (_DWORD *)(v39 + (v35 & 0x3FFFFFFFCLL));
              }
              *v8++ = *v25;
            }
            v25 += 4;
          }
          while (v25 != (_DWORD *)v26);
          uint64_t v24 = v46;
        }
LABEL_70:
        unsigned int v19 = v8;
        int v40 = *(_DWORD *)(v24 + 8);
        if ((v40 & 0x3FFFFFF) == 1)
        {
          if ((v40 & 0x8000000) != 0) {
            uint64_t v41 = *(void *)(v24 + 16);
          }
          else {
            uint64_t v41 = 0;
          }
          unsigned int v49 = FSTStatePool_PushFSTState(v41, v24);
          if (v49) {
            return v49;
          }
        }
        else
        {
          *(_DWORD *)(v24 + 8) = v40 - 1;
          if ((v40 & 0x3FFFFFF) == 0) {
            return 9;
          }
          unsigned int v49 = 0;
        }
        uint64_t v3 = v43;
        uint64_t v7 = v45;
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 24))(a1)) {
        BOOL v42 = 1;
      }
      else {
        BOOL v42 = v7 == (void)v19;
      }
      BOOL v8 = v19;
    }
    while (!v42);
  }
  if (v7) {
    OOCAllocator_Free(v3, v7);
  }
  return v49;
}

uint64_t FSTDfsContext_ExploreNonTreeArc()
{
  return err_GenerateErrorNotSupported();
}

uint64_t FSTDfsContext_ExploreTreeArc()
{
  return err_GenerateErrorNotSupported();
}

uint64_t FSTDfsContext_FinishState()
{
  return 0;
}

_DWORD *FSTDfsContext_SetDfsOptions(_DWORD *result, int a2, int a3, int a4)
{
  result[12] = a4;
  result[13] = a3;
  result[14] = a2;
  return result;
}

void *GetFSTDfsContextClass()
{
  return &__FSTDfsContext;
}

double FST_Con(void *a1, uint64_t a2, uint64_t a3)
{
  if (!RefCounted_Con((uint64_t)a1, 1))
  {
    *a1 = &__FST;
    a1[3] = a2;
    *(void *)((char *)a1 + 36) = 0;
    *(void *)((char *)a1 + 52) = 0;
    *(void *)((char *)a1 + 44) = 0;
    return FST_SetStatePool((uint64_t)a1, a3);
  }
  return result;
}

uint64_t FST_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (!v2 || (uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 32))(v2), !result))
  {
    return RefCounted_Des(a1);
  }
  return result;
}

void FST_AllocateExtendedHeaderFromRandomReader(uint64_t a1, uint64_t a2, uint64_t a3, const void **a4, void *a5, _DWORD *a6, _DWORD *a7)
{
  long long v17 = 0u;
  long long v18 = 0u;
  memset(v16, 0, sizeof(v16));
  FST_Con(v16, a1, 0);
  if (!v14)
  {
    unint64_t v19 = 0;
    unsigned int HeaderSizeInRandomReader = FST_GetHeaderSizeInRandomReader(a2, (uint64_t *)&v19);
    if (!HeaderSizeInRandomReader)
    {
      uint64_t v15 = v19 + a3;
      *a5 = v19 + a3;
      *a4 = (const void *)OOCAllocator_Malloc(a1, v15, &HeaderSizeInRandomReader);
      if (!HeaderSizeInRandomReader)
      {
        unsigned int HeaderSizeInRandomReader = (**(uint64_t (***)(uint64_t, void))a2)(a2 - *(void *)(*(void *)a2 + 56), 0);
        if (!HeaderSizeInRandomReader)
        {
          unsigned int HeaderSizeInRandomReader = (*(uint64_t (**)(uint64_t, const void *, void))(*(void *)a2 + 8))(a2 - *(void *)(*(void *)a2 + 56), *a4, *a5);
          if (!HeaderSizeInRandomReader)
          {
            unsigned int HeaderSizeInRandomReader = FST_ReadHeader(v16, *a4, a6, &v19);
            if (!HeaderSizeInRandomReader)
            {
              *a7 = v17;
              FST_Des((uint64_t)v16);
            }
          }
        }
      }
    }
  }
}

const void *FST_GetHeaderSizeInRandomReader(uint64_t a1, uint64_t *a2)
{
  v5[1] = *MEMORY[0x263EF8340];
  uint64_t result = (const void *)(*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 8))(a1 - *(void *)(*(void *)a1 + 56), v5, 8);
  if (!result)
  {
    uint64_t result = (const void *)(**(uint64_t (***)(uint64_t, void))a1)(a1 - *(void *)(*(void *)a1 + 56), 0);
    if (!result) {
      return FST_GetHeaderSizeInInputBuffer(v5, a2);
    }
  }
  return result;
}

uint64_t FST_ReadHeader(_DWORD *a1, const void *a2, _DWORD *a3, unint64_t *a4)
{
  unint64_t v15 = 0;
  uint64_t result = (uint64_t)FST_GetHeaderSizeInInputBuffer(a2, (uint64_t *)&v15);
  if (!result)
  {
    unint64_t v9 = v15;
    if (*a4 >= v15)
    {
      unsigned int v13 = a2;
      uint64_t v14 = 0;
      uint64_t result = __FST_ReadHeaderIdAndVersions((const void **)&v13, (_DWORD *)&v14 + 1, &v14);
      if (!result)
      {
        *a3 = v14;
        if (HIDWORD(v14) == 1)
        {
          unsigned int v12 = v13;
          a1[8] = *v13;
          a1[9] = v12[1];
          a1[10] = v12[2];
          a1[11] = v12[3];
        }
        else
        {
          if (HIDWORD(v14)) {
            return err_GenerateErrorData();
          }
          a1[11] = 0;
          uint64_t v10 = v13;
          a1[8] = *v13;
          a1[9] = v10[1];
          int v11 = (2 * v10[2]) & 4 | ((v10[2] & 1) << 8) & 0xFDFF | (v10[2] >> 2) & 3 | (((v10[2] >> 4) & 1) << 9);
          a1[10] = v11 | a1[10] & 0xFFFFFCF8;
          a1[11] = v11;
        }
        uint64_t result = 0;
        *a4 = v9;
      }
    }
    else
    {
      return err_GenerateErrorData();
    }
  }
  return result;
}

uint64_t FST_BorrowComponentFst()
{
  return 0;
}

uint64_t FST_CheckQuery(int a1, unsigned int a2)
{
  unsigned int v2 = (a2 >> 3) & 1;
  if ((a2 & 1) != 0 && (a1 & 0x20000000) != 0) {
    unsigned int v2 = 1;
  }
  if ((((a1 & 0x20000000) == 0) & ((a2 & 2) >> 1)) != 0) {
    unsigned int v2 = 1;
  }
  if ((a2 & 4) != 0 && a1 <= -1) {
    return 1;
  }
  else {
    return v2;
  }
}

uint64_t FST_FetchStateLabel(uint64_t a1, uint64_t a2, void *a3)
{
  *a3 = 0;
  return 0;
}

uint64_t FST_FillBuffer()
{
  return err_GenerateErrorNotSupported();
}

uint64_t FST_FillHeader(_DWORD *a1, void *__dst, int a3, void *a4)
{
  if (*a4 >= 0x14uLL)
  {
    cstdlib_memcpy(__dst, "NFST", 4uLL);
    *((_DWORD *)__dst + 1) = a3;
    *((_DWORD *)__dst + 2) = a1[8];
    *((_DWORD *)__dst + 3) = a1[9];
    int v9 = a1[11];
    if ((v9 & 0x200) != 0)
    {
      int v10 = (a1[10] >> 5) & 0x10;
      if ((v9 & 0x100) == 0) {
        goto LABEL_10;
      }
    }
    else
    {
      int v10 = 0;
      if ((v9 & 0x100) == 0)
      {
LABEL_10:
        if ((v9 & 4) != 0)
        {
          v10 |= (a1[10] >> 1) & 2;
          if ((v9 & 1) == 0)
          {
LABEL_12:
            if ((v9 & 2) == 0)
            {
LABEL_14:
              *((_DWORD *)__dst + 4) = v10;
              *a4 = 20;
              return 0;
            }
LABEL_13:
            v10 |= (4 * a1[10]) & 8;
            goto LABEL_14;
          }
        }
        else if ((v9 & 1) == 0)
        {
          goto LABEL_12;
        }
        v10 |= 4 * (a1[10] & 1);
        if ((v9 & 2) == 0) {
          goto LABEL_14;
        }
        goto LABEL_13;
      }
    }
    v10 |= (a1[10] >> 8) & 1;
    goto LABEL_10;
  }

  return err_GenerateErrorData();
}

uint64_t FST_GetHeaderSizeInOutputBuffer(void *a1)
{
  *a1 = 20;
  return 0;
}

uint64_t FST_GetFinalStateWeight(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v8 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a1 + 120))(a1, a2, 8, &v8);
  if (!result)
  {
    uint64_t v5 = v8;
    *a3 = *(_DWORD *)(v8 + 28);
    int v6 = *(_DWORD *)(v5 + 8);
    if ((v6 & 0x3FFFFFF) == 1)
    {
      if ((v6 & 0x8000000) != 0) {
        uint64_t v7 = *(void *)(v5 + 16);
      }
      else {
        uint64_t v7 = 0;
      }
      return FSTStatePool_PushFSTState(v7, v5);
    }
    else
    {
      *(_DWORD *)(v5 + 8) = v6 - 1;
      if ((v6 & 0x3FFFFFF) != 0) {
        return 0;
      }
      else {
        return 9;
      }
    }
  }
  return result;
}

const void *FST_GetHeaderSizeInInputBuffer(const void *result, uint64_t *a2)
{
  if (result)
  {
    int v6 = 0;
    long long v4 = result;
    uint64_t result = (const void *)__FST_ReadHeaderIdAndVersions(&v4, &v6, &v5);
    if (result) {
      return result;
    }
    if (v6)
    {
      if (v6 != 1) {
        return (const void *)err_GenerateErrorData();
      }
      uint64_t v3 = 24;
    }
    else
    {
      uint64_t v3 = 20;
    }
    uint64_t result = 0;
  }
  else
  {
    uint64_t v3 = 20;
  }
  *a2 = v3;
  return result;
}

uint64_t __FST_ReadHeaderIdAndVersions(const void **a1, _DWORD *a2, _DWORD *a3)
{
  int v6 = (unsigned __int16 *)*a1;
  uint64_t result = cstdlib_memcmp(*a1, "NFST", 4uLL);
  if (result)
  {
    return err_GenerateErrorData();
  }
  else
  {
    *a3 = v6[2];
    *a2 = v6[3];
    *a1 = v6 + 4;
  }
  return result;
}

uint64_t FST_GetMappedStateId()
{
  return 0xFFFFFFFFLL;
}

uint64_t FST_GetMaxBranchFactor(uint64_t a1, _DWORD *a2)
{
  uint64_t v5 = 0;
  memset(v4, 0, sizeof(v4));
  uint64_t result = FSTMaxBranchDfsContext_Con((uint64_t)v4, *(void *)(a1 + 24), a1);
  if (!result)
  {
    uint64_t result = FSTDfsContext_Dfs((uint64_t)v4);
    if (!result)
    {
      *a2 = v5;
      return (*(uint64_t (**)(_OWORD *))(*(void *)&v4[0] + 16))(v4);
    }
  }
  return result;
}

uint64_t FST_GetMaxNbrComponentFsts()
{
  return 0;
}

uint64_t FST_GetStateFlags(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v8 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a1 + 120))(a1, a2, 8, &v8);
  if (!result)
  {
    uint64_t v5 = v8;
    *a3 = *(_DWORD *)(v8 + 8) & 0xF0000000;
    int v6 = *(_DWORD *)(v5 + 8);
    if ((v6 & 0x3FFFFFF) == 1)
    {
      if ((v6 & 0x8000000) != 0) {
        uint64_t v7 = *(void *)(v5 + 16);
      }
      else {
        uint64_t v7 = 0;
      }
      return FSTStatePool_PushFSTState(v7, v5);
    }
    else
    {
      *(_DWORD *)(v5 + 8) = v6 - 1;
      if ((v6 & 0x3FFFFFF) != 0) {
        return 0;
      }
      else {
        return 9;
      }
    }
  }
  return result;
}

uint64_t FST_GetStatus(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t FST_QueryProperties(uint64_t a1, int a2, int *a3)
{
  int v6 = *(_DWORD *)(a1 + 40);
  int v5 = *(_DWORD *)(a1 + 44);
  int v7 = v6 & a2 & v5;
  int v8 = a2 & ~v5;
  if (!v8)
  {
LABEL_10:
    uint64_t result = 0;
    *(_DWORD *)(a1 + 40) = v6 & ~v8 | v7 & v8;
    *(_DWORD *)(a1 + 44) = v5 | v8;
    *a3 = v7;
    return result;
  }
  int DecidableProperties = FSTPropertiesDfsContext_GetDecidableProperties();
  int v10 = DecidableProperties & v8;
  if ((DecidableProperties & v8) == 0)
  {
LABEL_7:
    if ((v8 & ~DecidableProperties & 0xFFFFEEFF) != 0) {
      return err_GenerateErrorNotSupported();
    }
    int v6 = *(_DWORD *)(a1 + 40);
    int v5 = *(_DWORD *)(a1 + 44);
    goto LABEL_10;
  }
  int v14 = 0;
  memset(v13, 0, sizeof(v13));
  uint64_t result = FSTPropertiesDfsContext_Con((uint64_t)v13, *(void *)(a1 + 24), a1);
  if (!result)
  {
    uint64_t result = FSTPropertiesDfsContext_QueryProperties((uint64_t)v13, v10, &v14);
    if (!result)
    {
      int v12 = v14;
      uint64_t result = FSTPropertiesDfsContext_Des(v13);
      if (!result)
      {
        v7 |= v12 & v10;
        goto LABEL_7;
      }
    }
  }
  return result;
}

uint64_t FST_Reset()
{
  return 0;
}

uint64_t FST_ReturnStateFn(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 8);
  if ((v2 & 0x3FFFFFF) == 1)
  {
    if ((v2 & 0x8000000) != 0) {
      uint64_t v3 = *(void *)(a2 + 16);
    }
    else {
      uint64_t v3 = 0;
    }
    return FSTStatePool_PushFSTState(v3, a2);
  }
  else
  {
    *(_DWORD *)(a2 + 8) = v2 - 1;
    if ((v2 & 0x3FFFFFF) != 0) {
      return 0;
    }
    else {
      return 9;
    }
  }
}

double FST_SetStatePool(uint64_t a1, uint64_t a2)
{
  int v5 = (uint64_t *)(a1 + 48);
  uint64_t v4 = *(void *)(a1 + 48);
  if (!v4 || !(*(unsigned int (**)(uint64_t))(*(void *)v4 + 32))(v4))
  {
    if (a2)
    {
      uint64_t *v5 = a2;
      (*(void (**)(uint64_t))(*(void *)a2 + 24))(a2);
    }
    else
    {
      uint64_t v7 = *(void *)(a1 + 24);
      return PNEW_FSTStatePool_Con(v7, v7, 10, v5);
    }
  }
  return result;
}

uint64_t FST_WriteBuffer(uint64_t *a1, uint64_t a2)
{
  uint64_t v6 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t *, void, uint64_t *))(*a1 + 80))(a1, 0, &v6);
  unsigned int v7 = result;
  if (!result)
  {
    uint64_t v5 = OOCAllocator_Malloc(a1[3], v6, &v7);
    uint64_t result = v7;
    if (!v7)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t *))(*a1 + 80))(a1, v5, &v6);
      unsigned int v7 = result;
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 8))(a2 - *(void *)(*(void *)a2 + 56), v5, v6);
        unsigned int v7 = result;
        if (!result)
        {
          OOCAllocator_Free(a1[3], v5);
          return v7;
        }
      }
    }
  }
  return result;
}

uint64_t _FST_SetStatus(uint64_t result, int a2)
{
  *(_DWORD *)(result + 56) = a2;
  return result;
}

void *GetFSTClass()
{
  return &__FST;
}

const char *FST_GetClassFromString(const char *__s1)
{
  if (__s1)
  {
    uint64_t v1 = __s1;
    uint64_t v2 = 0;
    while (cstdlib_strcmp(v1, *(const char **)&classes[v2 + 2]))
    {
      v2 += 4;
      if (v2 == 216) {
        return 0;
      }
    }
    return (const char *)classes[v2];
  }
  return __s1;
}

const char *FST_GetStringFromClass(int a1)
{
  uint64_t v2 = 0;
  uint64_t result = "unknown";
  while (classes[v2] != a1)
  {
    v2 += 4;
    if (v2 == 216) {
      return result;
    }
  }
  return *(const char **)&classes[v2 + 2];
}

const char *FST_GetTypeFromString(const char *__s1)
{
  if (__s1)
  {
    uint64_t v1 = __s1;
    uint64_t v2 = 0;
    while (cstdlib_strcmp(v1, *(const char **)&types[v2 + 2]))
    {
      v2 += 4;
      if (v2 == 12) {
        return 0;
      }
    }
    return (const char *)types[v2];
  }
  return __s1;
}

const char *FST_GetStringFromType(int a1)
{
  uint64_t v2 = 0;
  uint64_t result = "unknown";
  while (types[v2] != a1)
  {
    v2 += 4;
    if (v2 == 12) {
      return result;
    }
  }
  return *(const char **)&types[v2 + 2];
}

uint64_t FSTBufferBuilder_Con(void *a1, uint64_t a2)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__FSTBufferBuilder;
    a1[1] = a2;
    uint64_t result = PNEW_MemOutStream_Con(a2, a2, a1 + 5);
    if (!result)
    {
      uint64_t v5 = (*(uint64_t (**)(void))(*(void *)a1[5] + 24))(a1[5]);
      uint64_t result = 0;
      uint64_t v6 = a1[5];
      a1[2] = v5;
      a1[3] = v6;
      a1[4] = 0;
      a1[6] = 0;
      a1[7] = 0;
    }
  }
  return result;
}

uint64_t FSTBufferBuilder_ConToStream(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__FSTBufferBuilder;
    a1[1] = a2;
    a1[2] = a3;
    a1[3] = a4;
    a1[4] = a5;
    a1[5] = 0;
    a1[6] = 0;
    a1[7] = 0;
  }
  return result;
}

uint64_t FSTBufferBuilder_Des(uint64_t *a1)
{
  if ((*(unsigned int (**)(uint64_t, void))(a1[2] + 24))(a1[3], 0))
  {
    return err_GenerateErrorCallback();
  }
  else
  {
    uint64_t v3 = a1[5];
    if (!v3 || (uint64_t result = OOC_PlacementDeleteObject(a1[1], v3), !result))
    {
      return Object_Des();
    }
  }
  return result;
}

uint64_t FSTBufferBuilder_BorrowBuffer(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 40);
  if (result) {
    return MemOutStream_BorrowBuffer(result);
  }
  return result;
}

uint64_t FSTBufferBuilder_GetSize(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2) {
    return MemOutStream_GetSize(v2);
  }
  else {
    return *(void *)(a1 + 56);
  }
}

void *FSTBufferBuilder_ReleaseBuffer(uint64_t a1, uint64_t *a2, void *a3, void *a4)
{
  uint64_t result = *(void **)(a1 + 40);
  if (result) {
    return (void *)MemOutStream_ReleaseBuffer(result, a2, a3, a4);
  }
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  return result;
}

void *GetFSTBufferBuilderClass()
{
  return &__FSTBufferBuilder;
}

int8x8_t FSTIncrementalMinimization_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(double *)&int8x8_t result = FST_Con((void *)a1, a2, a3);
  if (!v6)
  {
    *(void *)a1 = &__FSTIncrementalMinimization;
    *(void *)(a1 + 32) = 0x200000021;
    uint64_t v32 = 0;
    *(void *)(a1 + 64) = 0;
    if (!dpmemblock_Create(a2, 20, 0x400u, (uint64_t *)(a1 + 64))
      && !dpmemblock_GetNewElement(*(void *)(a1 + 64), &v32, 0))
    {
      uint64_t v7 = *(void *)(a1 + 64);
      uint64_t v8 = *(void *)(*(void *)(v7 + 8) + 8 * ((*(_DWORD *)(v7 + 32) - 1) >> *(_WORD *)(v7 + 44)))
         + 20 * ((*(_DWORD *)(v7 + 32) - 1) & ~(-1 << *(_WORD *)(v7 + 44)));
      *(void *)uint64_t v8 = 0;
      *(void *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 16) = 0;
      uint64_t v32 = 0;
      *(void *)(a1 + 72) = 0;
      if (!dpmemblock_Create(a2, 8, 0x400u, (uint64_t *)(a1 + 72)))
      {
        int v9 = -1;
        do
        {
          int NewElement = dpmemblock_GetNewElement(*(void *)(a1 + 72), &v32, 0);
          if (!v9) {
            break;
          }
          ++v9;
        }
        while (!NewElement);
        if (!NewElement)
        {
          uint64_t v11 = *(void *)(a1 + 72);
          int v12 = *(void ***)(v11 + 8);
          *_DWORD *v12 = 0xFFFFFFFFLL;
          v12[1uLL >> *(_WORD *)(v11 + 44)][((0xFFFFFFFFLL << *(_WORD *)(v11 + 44)) & 1) == 0] = 0x80000000FFFFFFFFLL;
          uint64_t v32 = 0;
          *(void *)(a1 + 80) = 0;
          unsigned int v13 = (uint64_t *)(a1 + 80);
          if (!dpmemblock_Create(a2, 4, 0x400u, (uint64_t *)(a1 + 80)))
          {
            int v14 = -12;
            do
            {
              int v15 = dpmemblock_GetNewElement(*v13, &v32, 0);
              if (!v14) {
                break;
              }
              ++v14;
            }
            while (!v15);
            if (!v15)
            {
              uint64_t v16 = *v13;
              if (*(_DWORD *)(*v13 + 32))
              {
                unsigned int v17 = 0;
                uint64_t v18 = *(void *)(v16 + 8);
                __int16 v19 = *(_WORD *)(v16 + 44);
                do
                {
                  uint64_t v20 = *(void *)(v18 + 8 * (v17 >> v19));
                  if (!v20) {
                    break;
                  }
                  *(_DWORD *)(v20 + 4 * (v17++ & ~(-1 << v19))) = -1;
                }
                while (v17 < *(_DWORD *)(v16 + 32));
              }
              *(void *)(a1 + 88) = 0;
              if (!dpmemblock_Create(a2, 16, 0x400u, (uint64_t *)(a1 + 88)))
              {
                *(_DWORD *)(a1 + 96) = -1;
                uint64_t v32 = 0;
                *(void *)(a1 + 104) = 0;
                unsigned int v21 = (uint64_t *)(a1 + 104);
                if (!dpmemblock_Create(a2, 4, 0x400u, (uint64_t *)(a1 + 104)))
                {
                  int v22 = -12;
                  do
                  {
                    int v23 = dpmemblock_GetNewElement(*v21, &v32, 0);
                    if (!v22) {
                      break;
                    }
                    ++v22;
                  }
                  while (!v23);
                  if (!v23)
                  {
                    uint64_t v24 = *v21;
                    if (*(_DWORD *)(*v21 + 32))
                    {
                      unsigned int v25 = 0;
                      uint64_t v26 = *(void *)(v24 + 8);
                      __int16 v27 = *(_WORD *)(v24 + 44);
                      do
                      {
                        uint64_t v28 = *(void *)(v26 + 8 * (v25 >> v27));
                        if (!v28) {
                          break;
                        }
                        *(_DWORD *)(v28 + 4 * (v25++ & ~(-1 << v27))) = -1;
                      }
                      while (v25 < *(_DWORD *)(v24 + 32));
                    }
                    *(void *)(a1 + 112) = 0;
                    if (!dpmemblock_Create(a2, 8, 0x400u, (uint64_t *)(a1 + 112)))
                    {
                      *(_DWORD *)(a1 + 120) = -1;
                      v29.i32[0] = -66305;
                      *(void *)(a1 + 128) = 1;
                      *(_DWORD *)(a1 + 136) = 0;
                      int8x8_t v30 = *(int8x8_t *)(a1 + 40);
                      LODWORD(v31) = vand_s8(v30, v29).u32[0];
                      int8x8_t result = vorr_s8(v30, (int8x8_t)vdup_n_s32(0x10300u));
                      HIDWORD(v31) = result.i32[1];
                      *(void *)(a1 + 40) = v31;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void FSTIncrementalMinimization_ConFromBuffer(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, unint64_t a5)
{
  int v97 = 1;
  FST_Con((void *)a1, a2, a3);
  if (!v9)
  {
    unint64_t v98 = 0;
    *(void *)a1 = &__FSTIncrementalMinimization;
    if (!FST_GetHeaderSizeInInputBuffer(a4, (uint64_t *)&v98))
    {
      if (v98 > a5)
      {
LABEL_4:
        err_GenerateErrorData();
        return;
      }
      if (!FST_ReadHeader((_DWORD *)a1, a4, &v97, &v98))
      {
        if (*(_DWORD *)(a1 + 36) != 2) {
          goto LABEL_4;
        }
        int v10 = *(_DWORD *)(a1 + 32);
        if (v10 != 10 && v10 != 33) {
          goto LABEL_4;
        }
        unint64_t v11 = v98;
        int v12 = &a4[v98];
        if (v10 == 10)
        {
          if (__FSTIncrementalMinimization_InitFromLegacySyntaxBuffer(a1, (uint64_t)&a4[v98])) {
            return;
          }
        }
        else
        {
          uint64_t v16 = (const float *)&a4[v98];
          int8x8_t v17 = (int8x8_t)vld1_dup_f32(v16++);
          *(int8x8_t *)(a1 + 132) = vand_s8(v17, (int8x8_t)0x200000001);
          float v18 = *v16;
          uint64_t v96 = 0;
          *(void *)(a1 + 64) = 0;
          __int16 v19 = (uint64_t *)(a1 + 64);
          if (dpmemblock_Create(a2, 20, 0x400u, (uint64_t *)(a1 + 64))) {
            return;
          }
          if (v18 != 0.0)
          {
            int v20 = LODWORD(v18) - 1;
            do
            {
              int NewElement = dpmemblock_GetNewElement(*v19, &v96, 0);
              BOOL v22 = v20-- != 0;
            }
            while (v22 && !NewElement);
            if (NewElement) {
              return;
            }
          }
          uint64_t v23 = *v19;
          int v24 = *(_DWORD *)(*v19 + 32);
          if (v24)
          {
            unsigned int v25 = 0;
            uint64_t v26 = *(void *)(v23 + 8);
            __int16 v27 = *(_WORD *)(v23 + 44);
            uint64_t v28 = &a4[v11 + 24];
            do
            {
              uint64_t v29 = *(void *)(v26 + 8 * (v25 >> v27));
              if (!v29) {
                break;
              }
              int8x8_t v30 = (_DWORD *)(v29 + 20 * (v25 & ~(-1 << v27)));
              *int8x8_t v30 = *((_DWORD *)v28 - 4);
              v30[1] = *((_DWORD *)v28 - 3);
              v30[2] = *((_DWORD *)v28 - 2);
              v30[3] = *((_DWORD *)v28 - 1);
              int v31 = *(_DWORD *)v28;
              v28 += 20;
              v30[4] = v31;
              ++v25;
            }
            while (v24 != v25);
            uint64_t v32 = v28 - 16;
          }
          else
          {
            uint64_t v32 = v12 + 8;
          }
          int v35 = *(_DWORD *)v32;
          uint64_t v33 = v32 + 4;
          int v34 = v35;
          uint64_t v96 = 0;
          *(void *)(a1 + 72) = 0;
          unsigned int v36 = (uint64_t *)(a1 + 72);
          if (dpmemblock_Create(a2, 8, 0x400u, (uint64_t *)(a1 + 72))) {
            return;
          }
          if (v34)
          {
            int v37 = v34 - 1;
            do
            {
              int v38 = dpmemblock_GetNewElement(*v36, &v96, 0);
              BOOL v22 = v37-- != 0;
            }
            while (v22 && !v38);
            if (v38) {
              return;
            }
          }
          uint64_t v39 = *v36;
          int v40 = *(_DWORD *)(*v36 + 32);
          if (v40)
          {
            unsigned int v41 = 0;
            uint64_t v42 = *(void *)(v39 + 8);
            __int16 v43 = *(_WORD *)(v39 + 44);
            do
            {
              uint64_t v44 = *(void *)(v42 + 8 * (v41 >> v43));
              if (!v44) {
                break;
              }
              uint64_t v45 = (_DWORD *)(v44 + 8 * (v41 & ~(-1 << v43)));
              *uint64_t v45 = *v33;
              v45[1] = v33[1];
              v33 += 2;
              ++v41;
            }
            while (v40 != v41);
          }
          int v47 = *v33;
          unsigned int v46 = v33[1];
          uint64_t v96 = 0;
          *(void *)(a1 + 80) = 0;
          int v48 = (uint64_t *)(a1 + 80);
          if (dpmemblock_Create(a2, 4, 0x400u, (uint64_t *)(a1 + 80))) {
            return;
          }
          if (v46)
          {
            unsigned int v49 = v46 - 1;
            do
            {
              int v50 = dpmemblock_GetNewElement(*v48, &v96, 0);
              BOOL v22 = v49-- != 0;
            }
            while (v22 && !v50);
            if (v50) {
              return;
            }
          }
          uint64_t v51 = v33 + 2;
          uint64_t v52 = *v48;
          if (*(_DWORD *)(*v48 + 32))
          {
            unsigned int v53 = 0;
            uint64_t v54 = *(void *)(v52 + 8);
            __int16 v55 = *(_WORD *)(v52 + 44);
            do
            {
              uint64_t v56 = *(void *)(v54 + 8 * (v53 >> v55));
              if (!v56) {
                break;
              }
              *(_DWORD *)(v56 + 4 * (v53++ & ~(-1 << v55))) = -1;
            }
            while (v53 < *(_DWORD *)(v52 + 32));
          }
          if (v47)
          {
            uint64_t v96 = 0;
            *(void *)(a1 + 88) = 0;
            uint64_t v57 = (uint64_t *)(a1 + 88);
            if (dpmemblock_Create(a2, 16, 0x400u, (uint64_t *)(a1 + 88))) {
              return;
            }
            int v58 = v47 - 1;
            do
            {
              int v59 = dpmemblock_GetNewElement(*v57, &v96, 0);
              BOOL v22 = v58-- != 0;
            }
            while (v22 && !v59);
            if (v59) {
              return;
            }
            uint64_t v60 = *v57;
            if (*(_DWORD *)(*v57 + 32))
            {
              unsigned int v61 = 0;
              uint64_t v62 = *(void *)(v60 + 8);
              __int16 v63 = *(_WORD *)(v60 + 44);
              do
              {
                uint64_t v64 = *(void *)(v62 + 8 * (v61 >> v63));
                if (!v64) {
                  break;
                }
                unsigned int v65 = (_DWORD *)(v64 + 16 * (v61 & ~(-1 << v63)));
                v65[1] = *v51;
                v65[2] = v51[1];
                v65[3] = v51[2];
                v51 += 3;
                unsigned int v66 = _FSTIncrementalMinimizationPrefixHash(a1, (uint64_t)v65);
                uint64_t v67 = *(void *)(a1 + 80);
                uint64_t v68 = *(void *)(v67 + 8);
                LOBYTE(v67) = *(_WORD *)(v67 + 44);
                uint64_t v69 = *(void *)(v68 + 8 * ((v66 % v46) >> v67));
                unsigned int v70 = (v66 % v46) & ~(-1 << v67);
                *unsigned int v65 = *(_DWORD *)(v69 + 4 * v70);
                *(_DWORD *)(v69 + 4 * v70) = v61++;
              }
              while (v61 < *(_DWORD *)(v60 + 32));
            }
          }
          else
          {
            *(void *)(a1 + 88) = 0;
            if (dpmemblock_Create(a2, 16, 0x400u, (uint64_t *)(a1 + 88))) {
              return;
            }
          }
          *(_DWORD *)(a1 + 96) = -1;
          int v72 = *v51;
          unsigned int v71 = v51[1];
          uint64_t v96 = 0;
          *(void *)(a1 + 104) = 0;
          unsigned int v73 = (uint64_t *)(a1 + 104);
          if (dpmemblock_Create(a2, 4, 0x400u, (uint64_t *)(a1 + 104))) {
            return;
          }
          if (v71)
          {
            unsigned int v74 = v71 - 1;
            do
            {
              int v75 = dpmemblock_GetNewElement(*v73, &v96, 0);
              BOOL v22 = v74-- != 0;
            }
            while (v22 && !v75);
            if (v75) {
              return;
            }
          }
          uint64_t v76 = *v73;
          if (*(_DWORD *)(*v73 + 32))
          {
            unsigned int v77 = 0;
            uint64_t v78 = *(void *)(v76 + 8);
            __int16 v79 = *(_WORD *)(v76 + 44);
            do
            {
              uint64_t v80 = *(void *)(v78 + 8 * (v77 >> v79));
              if (!v80) {
                break;
              }
              *(_DWORD *)(v80 + 4 * (v77++ & ~(-1 << v79))) = -1;
            }
            while (v77 < *(_DWORD *)(v76 + 32));
          }
          if (v72)
          {
            uint64_t v96 = 0;
            *(void *)(a1 + 112) = 0;
            unint64_t v81 = (uint64_t *)(a1 + 112);
            if (dpmemblock_Create(a2, 8, 0x400u, (uint64_t *)(a1 + 112))) {
              return;
            }
            uint64_t v82 = v51 + 2;
            int v83 = v72 - 1;
            do
            {
              int v84 = dpmemblock_GetNewElement(*v81, &v96, 0);
              BOOL v22 = v83-- != 0;
            }
            while (v22 && !v84);
            if (v84) {
              return;
            }
            uint64_t v85 = *v81;
            if (*(_DWORD *)(v85 + 32))
            {
              uint64_t v86 = 0;
              uint64_t v87 = *(void *)(v85 + 8);
              __int16 v88 = *(_WORD *)(v85 + 44);
              do
              {
                uint64_t v89 = *(void *)(v87 + 8 * (v86 >> v88));
                if (!v89) {
                  break;
                }
                uint64_t v90 = (_DWORD *)(v89 + 8 * (v86 & ~(-1 << v88)));
                v90[1] = v82[v86];
                unsigned int v91 = _FSTIncrementalMinimizationSuffixHash(a1, (uint64_t)v90);
                uint64_t v92 = *(void *)(a1 + 104);
                uint64_t v93 = *(void *)(v92 + 8);
                LOBYTE(v92) = *(_WORD *)(v92 + 44);
                uint64_t v94 = *(void *)(v93 + 8 * ((v91 % v71) >> v92));
                unsigned int v95 = (v91 % v71) & ~(-1 << v92);
                _DWORD *v90 = *(_DWORD *)(v94 + 4 * v95);
                *(_DWORD *)(v94 + 4 * v95) = v86++;
              }
              while (v86 < *(_DWORD *)(v85 + 32));
            }
          }
          else
          {
            *(void *)(a1 + 112) = 0;
            if (dpmemblock_Create(a2, 8, 0x400u, (uint64_t *)(a1 + 112))) {
              return;
            }
          }
          *(_DWORD *)(a1 + 120) = -1;
        }
        *(_DWORD *)(a1 + 128) = 1;
        int8x8_t v14 = *(int8x8_t *)(a1 + 40);
        v13.i32[0] = -66305;
        LODWORD(v15) = vand_s8(v14, v13).u32[0];
        HIDWORD(v15) = vorr_s8(v14, (int8x8_t)vdup_n_s32(0x10300u)).i32[1];
        *(void *)(a1 + 40) = v15;
      }
    }
  }
}

uint64_t __FSTIncrementalMinimization_InitFromLegacySyntaxBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  int v5 = *(_DWORD *)(a2 + 12);
  *(void *)(a1 + 64) = 0;
  int v6 = (uint64_t *)(a1 + 64);
  uint64_t result = dpmemblock_Create(v4, 20, 0x400u, (uint64_t *)(a1 + 64));
  if (!result)
  {
    uint64_t v83 = 0;
    if (!v5) {
      goto LABEL_9;
    }
    int v8 = v5 - 1;
    do
    {
      uint64_t result = dpmemblock_GetNewElement(*v6, &v83, 0);
      BOOL v9 = v8-- != 0;
    }
    while (v9 && !result);
    if (!result)
    {
LABEL_9:
      int v10 = (_DWORD *)(a2 + 16);
      uint64_t v11 = *v6;
      int v12 = *(_DWORD *)(*v6 + 32);
      if (v12)
      {
        unsigned int v13 = 0;
        uint64_t v14 = *(void *)(v11 + 8);
        __int16 v15 = *(_WORD *)(v11 + 44);
        int v16 = ~(-1 << v15);
        do
        {
          uint64_t v17 = *(void *)(v14 + 8 * (v13 >> v15));
          if (!v17) {
            break;
          }
          *(_DWORD *)(v17 + 20 * (v13 & v16)) = *v10;
          int v18 = v10[1];
          int v19 = v18 ? v18 + 1 : 0;
          int v20 = v18 == -1 ? 1 : v19;
          unsigned int v21 = (_DWORD *)(v17 + 20 * (v13 & v16));
          v21[1] = v20;
          v21[2] = v10[2];
          v21[3] = v10[3];
          v21[4] = v10[4];
          v10 += 5;
          ++v13;
        }
        while (v12 != v13);
      }
      int v22 = *v10;
      uint64_t v83 = 0;
      *(void *)(a1 + 72) = 0;
      uint64_t v23 = (uint64_t *)(a1 + 72);
      uint64_t result = dpmemblock_Create(v4, 8, 0x400u, (uint64_t *)(a1 + 72));
      if (!result)
      {
        if (v22 == -1) {
          goto LABEL_35;
        }
        int v24 = v22;
        do
        {
          uint64_t result = dpmemblock_GetNewElement(*v23, &v83, 0);
          BOOL v9 = v24-- != 0;
        }
        while (v9 && !result);
        if (!result)
        {
LABEL_35:
          uint64_t v25 = *v23;
          uint64_t v26 = *(_DWORD ***)(*v23 + 8);
          __int16 v27 = *v26;
          *__int16 v27 = v10[1];
          v27[1] = v10[2];
          uint64_t v28 = v10 + 3;
          __int16 v29 = *(_WORD *)(v25 + 44);
          *(void *)&v26[1uLL >> v29][2 * (((-1 << v29) & 1) == 0)] = 0x80000000FFFFFFFFLL;
          if ((v22 + 1) >= 3)
          {
            unsigned int v30 = 1;
            do
            {
              ++v30;
              int v31 = &v26[v30 >> v29][2 * (v30 & ~(-1 << v29))];
              *int v31 = *v28;
              v31[1] = v28[1];
              v28 += 2;
            }
            while (v22 != v30);
          }
          int v33 = *v28;
          unsigned int v32 = v28[1];
          uint64_t v83 = 0;
          *(void *)(a1 + 80) = 0;
          int v34 = (uint64_t *)(a1 + 80);
          uint64_t result = dpmemblock_Create(v4, 4, 0x400u, (uint64_t *)(a1 + 80));
          if (!result)
          {
            if (!v32) {
              goto LABEL_36;
            }
            unsigned int v35 = v32 - 1;
            do
            {
              uint64_t result = dpmemblock_GetNewElement(*v34, &v83, 0);
              BOOL v9 = v35-- != 0;
            }
            while (v9 && !result);
            if (!result)
            {
LABEL_36:
              unsigned int v36 = v28 + 2;
              uint64_t v37 = *v34;
              if (*(_DWORD *)(*v34 + 32))
              {
                unsigned int v38 = 0;
                uint64_t v39 = *(void *)(v37 + 8);
                __int16 v40 = *(_WORD *)(v37 + 44);
                do
                {
                  uint64_t v41 = *(void *)(v39 + 8 * (v38 >> v40));
                  if (!v41) {
                    break;
                  }
                  *(_DWORD *)(v41 + 4 * (v38++ & ~(-1 << v40))) = -1;
                }
                while (v38 < *(_DWORD *)(v37 + 32));
              }
              if (v33)
              {
                uint64_t v83 = 0;
                *(void *)(a1 + 88) = 0;
                uint64_t v42 = (uint64_t *)(a1 + 88);
                uint64_t result = dpmemblock_Create(v4, 16, 0x400u, (uint64_t *)(a1 + 88));
                if (result) {
                  return result;
                }
                int v43 = v33 - 1;
                do
                {
                  uint64_t result = dpmemblock_GetNewElement(*v42, &v83, 0);
                  BOOL v9 = v43-- != 0;
                }
                while (v9 && !result);
                if (result) {
                  return result;
                }
                uint64_t v44 = *v42;
                if (*(_DWORD *)(*v42 + 32))
                {
                  unsigned int v45 = 0;
                  uint64_t v46 = *(void *)(v44 + 8);
                  __int16 v47 = *(_WORD *)(v44 + 44);
                  do
                  {
                    uint64_t v48 = *(void *)(v46 + 8 * (v45 >> v47));
                    if (!v48) {
                      break;
                    }
                    uint64_t v49 = v45 & ~(-1 << v47);
                    int v50 = *v36;
                    uint64_t v51 = v48 + 16 * v49;
                    *(_DWORD *)(v51 + 4) = *v36;
                    uint64_t v52 = (_DWORD *)(v51 + 4);
                    unsigned int v53 = v36[1];
                    v52[1] = v53;
                    v52[2] = v36[2];
                    if (v50) {
                      *uint64_t v52 = ++v50;
                    }
                    uint64_t v54 = (_DWORD *)(v48 + 16 * v49);
                    v36 += 3;
                    uint64_t v55 = *(void *)(*(void *)(*v6 + 8) + 8 * (v53 >> *(_WORD *)(*v6 + 44)))
                        + 20 * (v53 & ~(-1 << *(_WORD *)(*v6 + 44)));
                    LODWORD(v55) = (*(_DWORD *)(v55 + 16)
                                  + 2239 * (*(_DWORD *)(v55 + 12) + 2239 * (*(_DWORD *)(v55 + 8) + 2239 * v50)))
                                 % v32;
                    char v56 = *(_WORD *)(*v34 + 44);
                    uint64_t v57 = *(void *)(*(void *)(*v34 + 8) + 8 * (v55 >> v56));
                    LODWORD(v55) = v55 & ~(-1 << v56);
                    *uint64_t v54 = *(_DWORD *)(v57 + 4 * v55);
                    *(_DWORD *)(v57 + 4 * v55) = v45++;
                  }
                  while (v45 < *(_DWORD *)(v44 + 32));
                }
              }
              else
              {
                *(void *)(a1 + 88) = 0;
                uint64_t result = dpmemblock_Create(v4, 16, 0x400u, (uint64_t *)(a1 + 88));
                if (result) {
                  return result;
                }
              }
              *(_DWORD *)(a1 + 96) = -1;
              int v59 = *v36;
              unsigned int v58 = v36[1];
              uint64_t v83 = 0;
              *(void *)(a1 + 104) = 0;
              uint64_t v60 = (uint64_t *)(a1 + 104);
              uint64_t result = dpmemblock_Create(v4, 4, 0x400u, (uint64_t *)(a1 + 104));
              if (!result)
              {
                if (!v58) {
                  goto LABEL_62;
                }
                unsigned int v61 = v58 - 1;
                do
                {
                  uint64_t result = dpmemblock_GetNewElement(*v60, &v83, 0);
                  BOOL v9 = v61-- != 0;
                }
                while (v9 && !result);
                if (!result)
                {
LABEL_62:
                  uint64_t v62 = *v60;
                  if (*(_DWORD *)(*v60 + 32))
                  {
                    unsigned int v63 = 0;
                    uint64_t v64 = *(void *)(v62 + 8);
                    __int16 v65 = *(_WORD *)(v62 + 44);
                    do
                    {
                      uint64_t v66 = *(void *)(v64 + 8 * (v63 >> v65));
                      if (!v66) {
                        break;
                      }
                      *(_DWORD *)(v66 + 4 * (v63++ & ~(-1 << v65))) = -1;
                    }
                    while (v63 < *(_DWORD *)(v62 + 32));
                  }
                  if (v59)
                  {
                    uint64_t v83 = 0;
                    *(void *)(a1 + 112) = 0;
                    uint64_t v67 = (uint64_t *)(a1 + 112);
                    uint64_t result = dpmemblock_Create(v4, 8, 0x400u, (uint64_t *)(a1 + 112));
                    if (!result)
                    {
                      uint64_t v68 = v36 + 2;
                      int v69 = v59 - 1;
                      do
                      {
                        uint64_t result = dpmemblock_GetNewElement(*v67, &v83, 0);
                        BOOL v9 = v69-- != 0;
                      }
                      while (v9 && !result);
                      if (!result)
                      {
                        uint64_t v70 = *v67;
                        if (*(_DWORD *)(v70 + 32))
                        {
                          uint64_t v71 = 0;
                          uint64_t v72 = *(void *)(v70 + 8);
                          __int16 v73 = *(_WORD *)(v70 + 44);
                          do
                          {
                            uint64_t v74 = *(void *)(v72 + 8 * (v71 >> v73));
                            if (!v74) {
                              break;
                            }
                            int v75 = (_DWORD *)(v74 + 8 * (v71 & ~(-1 << v73)));
                            int v76 = v68[v71];
                            int v77 = v76 ? v76 + 1 : 0;
                            v75[1] = v77;
                            unsigned int v78 = _FSTIncrementalMinimizationSuffixHash(a1, (uint64_t)v75);
                            uint64_t v79 = *(void *)(a1 + 104);
                            uint64_t v80 = *(void *)(v79 + 8);
                            LOBYTE(v79) = *(_WORD *)(v79 + 44);
                            uint64_t v81 = *(void *)(v80 + 8 * ((v78 % v58) >> v79));
                            unsigned int v82 = (v78 % v58) & ~(-1 << v79);
                            *int v75 = *(_DWORD *)(v81 + 4 * v82);
                            *(_DWORD *)(v81 + 4 * v82) = v71++;
                          }
                          while (v71 < *(_DWORD *)(v70 + 32));
                        }
                        goto LABEL_82;
                      }
                    }
                  }
                  else
                  {
                    *(void *)(a1 + 112) = 0;
                    uint64_t result = dpmemblock_Create(v4, 8, 0x400u, (uint64_t *)(a1 + 112));
                    if (!result)
                    {
LABEL_82:
                      uint64_t result = 0;
                      *(_DWORD *)(a1 + 120) = -1;
                      *(_DWORD *)(a1 + 32) = 33;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t _FSTIncrementalMinimizationPrefixHash(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 64) + 8)
                            + 8 * (*(_DWORD *)(a2 + 8) >> *(_WORD *)(*(void *)(a1 + 64) + 44)))
                + 20 * (*(_DWORD *)(a2 + 8) & ~(-1 << *(_WORD *)(*(void *)(a1 + 64) + 44))));
  return (v2[4] + 2239 * (v2[3] + 2239 * (v2[2] + 2239 * *(_DWORD *)(a2 + 4))));
}

uint64_t _FSTIncrementalMinimizationSuffixHash(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  unsigned int v4 = *(_DWORD *)(a2 + 4);
  uint64_t v5 = *(void *)(a1 + 72);
  uint64_t v6 = *(void *)(v5 + 8);
  __int16 v7 = *(_WORD *)(v5 + 44);
  do
  {
    unsigned int v8 = *(_DWORD *)(*(void *)(v6 + 8 * (v4 >> v7)) + 8 * (v4 & ~(-1 << v7)));
    if (v8 == -1) {
      break;
    }
    BOOL v9 = (_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 64) + 8)
                              + 8 * (v8 >> *(_WORD *)(*(void *)(a1 + 64) + 44)))
                  + 20 * (v8 & ~(-1 << *(_WORD *)(*(void *)(a1 + 64) + 44))));
    unsigned int v4 = v9[1];
    uint64_t result = (v9[4] + 2239 * (v9[3] + 2239 * (v9[2] + 2239 * result)));
  }
  while (v4 != 1);
  return result;
}

uint64_t FSTIncrementalMinimization_Des(uint64_t a1)
{
  dpmemblock_Free(*(uint64_t **)(a1 + 64));
  dpmemblock_Free(*(uint64_t **)(a1 + 72));
  dpmemblock_Free(*(uint64_t **)(a1 + 80));
  dpmemblock_Free(*(uint64_t **)(a1 + 88));
  *(_DWORD *)(a1 + 96) = -1;
  dpmemblock_Free(*(uint64_t **)(a1 + 104));
  dpmemblock_Free(*(uint64_t **)(a1 + 112));
  *(_DWORD *)(a1 + 120) = -1;

  return FST_Des(a1);
}

uint64_t FSTIncrementalMinimization_AddSequence(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6 = *(void *)(a1 + 24);
  HIDWORD(v236) = 0;
  LODWORD(v236) = 0;
  __FSTIncrementalMinimization_SetExactMatchMode(a1, 1);
  v237[0] = 0;
  uint64_t v7 = OOCAllocator_Calloc(v6, a3, 4, v237);
  uint64_t result = v237[0];
  if (v237[0]) {
    return result;
  }
  uint64_t v207 = v6;
  *(void *)((char *)&v236 + 4) = 0;
  uint64_t v212 = a2;
  uint64_t v213 = v7;
  if (!a3)
  {
    unsigned int v94 = 0;
    unsigned int v95 = 0;
    goto LABEL_79;
  }
  unint64_t v9 = 0;
  unsigned int v10 = 0;
  v228 = (_DWORD *)(a2 + 20);
  uint64_t v226 = 1;
  unsigned int v210 = a3;
  uint64_t v214 = a3;
  unint64_t v220 = a3 - 1;
  while (1)
  {
    uint64_t v11 = **(void **)(*(void *)(a1 + 64) + 8);
    int v12 = (uint64_t *)(a2 + 12 * v9);
    uint64_t v13 = *v12;
    *(_DWORD *)(v11 + 16) = *((_DWORD *)v12 + 2);
    *(void *)(v11 + 8) = v13;
    uint64_t result = v237[0];
    if (v237[0]) {
      return result;
    }
    unint64_t v14 = v9;
    uint64_t v15 = *(void *)(a1 + 64);
    uint64_t v16 = *(void *)(v15 + 8);
    __int16 v17 = *(_WORD *)(v15 + 44);
    int v230 = ~(-1 << v17);
    unsigned int v216 = v10;
    unsigned int v18 = *(_DWORD *)(*(void *)v16 + 16)
        + 2239 * (*(_DWORD *)(*(void *)v16 + 12) + 2239 * (*(_DWORD *)(*(void *)v16 + 8) + 2239 * v10));
    uint64_t v19 = *(void *)(a1 + 80);
    int v20 = (unsigned int *)(*(void *)(*(void *)(v19 + 8)
                                     + 8 * ((v18 % *(_DWORD *)(v19 + 32)) >> *(_WORD *)(v19 + 44)))
                         + 4 * ((v18 % *(_DWORD *)(v19 + 32)) & ~(-1 << *(_WORD *)(v19 + 44))));
    while (1)
    {
      unsigned int v21 = *v20;
      if ((*v20 & 0x80000000) != 0) {
        break;
      }
      uint64_t v22 = *(void *)(a1 + 88);
      uint64_t v23 = *(void *)(v22 + 8);
      LOBYTE(v22) = *(_WORD *)(v22 + 44);
      uint64_t v24 = v21 >> v22;
      uint64_t v25 = v21 & ~(-1 << v22);
      int v20 = (unsigned int *)(*(void *)(v23 + 8 * v24) + 16 * v25);
      if (_FSTIncrementalMinimizationPrefixEqual(a1, (uint64_t)&v236, (uint64_t)v20)) {
        goto LABEL_12;
      }
    }
    if (v21 == -1)
    {
      unsigned int v94 = v216;
      if (v216)
      {
        unsigned int v156 = *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 72) + 8)
                                     + 8 * (v216 >> *(_WORD *)(*(void *)(a1 + 72) + 44)))
                         + 8 * (v216 & ~(-1 << *(_WORD *)(*(void *)(a1 + 72) + 44))));
        uint64_t v7 = v213;
        a3 = v210;
        unsigned int v95 = v14;
        if (v156 != -1 && *(_DWORD *)(*(void *)(v16 + 8 * (v156 >> v17)) + 20 * (v156 & v230)) == -1)
        {
          __FSTIncrementalMinimization_ClearSuffixes(a1, v14, v213);
          unsigned int v94 = v216;
          v237[0] = 0;
        }
      }
      else
      {
        uint64_t v7 = v213;
        a3 = v210;
        unsigned int v95 = v14;
      }
      a2 = v212;
      goto LABEL_79;
    }
    uint64_t v26 = *(void *)(a1 + 88);
    uint64_t v23 = *(void *)(v26 + 8);
    LOBYTE(v26) = *(_WORD *)(v26 + 44);
    uint64_t v24 = v21 >> v26;
    uint64_t v25 = v21 & ~(-1 << v26);
LABEL_12:
    uint64_t v27 = *(void *)(v23 + 8 * v24);
    uint64_t v223 = v27 + 16 * v25;
    unsigned int v218 = *(_DWORD *)(v223 + 8);
    unsigned int v10 = *(_DWORD *)(*(void *)(v16 + 8 * (v218 >> v17)) + 20 * (v218 & v230) + 4);
    uint64_t v28 = *(void *)(a1 + 72);
    uint64_t v29 = *(void *)(v28 + 8);
    __int16 v30 = *(_WORD *)(v28 + 44);
    uint64_t v31 = *(void *)(v29 + 8 * (v10 >> v30));
    uint64_t v32 = v10 & ~(-1 << v30);
    unint64_t v33 = v220;
    if ((*(_DWORD *)(v31 + 8 * v32 + 4) & 0x7FFFFFFE) == 0)
    {
      unint64_t v35 = v14;
      uint64_t v36 = v214;
      goto LABEL_68;
    }
    uint64_t v208 = v27;
    unsigned int v34 = *(_DWORD *)(v31 + 8 * v32);
    unint64_t v35 = v14;
    uint64_t v36 = v214;
    if (v34 == -1)
    {
LABEL_33:
      *(void *)&long long v235 = 0;
      uint64_t result = dpmemblock_GetNewElement(v28, &v235, 0);
      if (result) {
        return result;
      }
      *(void *)long long v235 = 0x1FFFFFFFFLL;
      uint64_t v49 = *(void *)(a1 + 72);
      uint64_t v50 = *(void *)(v49 + 8);
      __int16 v51 = *(_WORD *)(v49 + 44);
      uint64_t v55 = (void *)(v50 + 8 * (v10 >> v51));
      int v56 = -1;
      int v52 = ~(-1 << v51);
      unsigned int v57 = v10 & v52;
    }
    else
    {
      uint64_t v37 = *(void *)(v16 + 8 * (v34 >> v17));
      unsigned int v38 = v34 & v230;
      if (v35 < v220)
      {
        unint64_t v40 = v226;
        uint64_t v39 = v228;
        uint64_t v41 = (_DWORD *)(v37 + 20 * v38);
        do
        {
          if (v40 < v220 && v41[1] == 1
            || v220 == v40 && v41[1] != 1
            || v41[2] != *(v39 - 2)
            || v41[3] != *(v39 - 1)
            || v41[4] != *v39)
          {
            goto LABEL_29;
          }
          if (v40 < v220)
          {
            unsigned int v42 = *(_DWORD *)(*(void *)(v29 + 8 * (v41[1] >> v30))
                            + 8 * (v41[1] & ~(-1 << v30)));
            if (v42 == -1) {
              goto LABEL_33;
            }
            uint64_t v41 = (_DWORD *)(*(void *)(v16 + 8 * (v42 >> v17)) + 20 * (v42 & v230));
          }
          ++v40;
          v39 += 3;
        }
        while (v214 != v40);
        v237[0] = 0;
        uint64_t v7 = v213;
        goto LABEL_183;
      }
LABEL_29:
      uint64_t v43 = v37 + 20 * v38;
      uint64_t v44 = v37;
      int v45 = *(_DWORD *)(v15 + 32);
      *(void *)&long long v235 = 0;
      uint64_t result = dpmemblock_GetNewElement(v28, &v235, 0);
      if (result) {
        return result;
      }
      uint64_t v46 = v235;
      *(_DWORD *)long long v235 = v45;
      *(_DWORD *)(v46 + 4) = 1;
      *(void *)&long long v235 = 0;
      uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 64), &v235, 0);
      if (result) {
        return result;
      }
      uint64_t v47 = v235;
      int v48 = *(_DWORD *)(v43 + 16);
      *(_OWORD *)long long v235 = *(_OWORD *)v43;
      *(_DWORD *)(v47 + 16) = v48;
      uint64_t v49 = *(void *)(a1 + 72);
      uint64_t v50 = *(void *)(v49 + 8);
      __int16 v51 = *(_WORD *)(v49 + 44);
      int v52 = ~(-1 << v51);
      uint64_t v53 = *(void *)(v50 + 8 * (v10 >> v51)) + 8 * (v10 & v52);
      *(_DWORD *)(v53 + 4) = ((*(_DWORD *)(v53 + 4) & 0x7FFFFFFF) - 1) | *(_DWORD *)(v53 + 4) & 0x80000000;
      unsigned int v54 = *(_DWORD *)(v44 + 20 * v38 + 4);
      if (v54 == 1)
      {
        uint64_t v36 = v214;
        goto LABEL_37;
      }
      uint64_t v55 = (void *)(v50 + 8 * (v54 >> v51));
      unsigned int v57 = v54 & v52;
      int v56 = 1;
      uint64_t v36 = v214;
    }
    *(_DWORD *)(*v55 + 8 * v57 + 4) = ((*(_DWORD *)(*v55 + 8 * v57 + 4) & 0x7FFFFFFF) + v56) | *(_DWORD *)(*v55 + 8 * v57 + 4) & 0x80000000;
LABEL_37:
    unsigned int v10 = *(_DWORD *)(v49 + 32) - 1;
    uint64_t v58 = *(void *)(a1 + 64);
    uint64_t v59 = *(void *)(v58 + 8);
    __int16 v60 = *(_WORD *)(v58 + 44);
    *(_DWORD *)(*(void *)(v59 + 8 * (v218 >> v60)) + 20 * (v218 & ~(-1 << v60)) + 4) = v10;
    uint64_t v61 = *(void *)(v50 + 8 * (v10 >> v51));
    v237[0] = 0;
    unsigned int v62 = *(_DWORD *)(v61 + 8 * (v10 & v52));
    if (v62 != -1)
    {
      *(void *)((char *)&v235 + 4) = __PAIR64__(v62, v10);
      LODWORD(v235) = 0;
      HIDWORD(v235) = *(_DWORD *)(v208 + 16 * v25 + 12);
      unsigned int v63 = (_DWORD *)(*(void *)(v59 + 8 * (v62 >> v60)) + 20 * (v62 & ~(-1 << v60)));
      unsigned int v64 = v63[4] + 2239 * (v63[3] + 2239 * (v63[2] + 2239 * v10));
      uint64_t v65 = *(void *)(a1 + 80);
      unsigned int v66 = *(_DWORD *)(v65 + 32);
      uint64_t v67 = (_DWORD *)(*(void *)(*(void *)(v65 + 8) + 8 * ((v64 % v66) >> *(_WORD *)(v65 + 44)))
                     + 4 * ((v64 % v66) & ~(-1 << *(_WORD *)(v65 + 44))));
      while ((*v67 & 0x80000000) == 0)
      {
        uint64_t v67 = (_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 88) + 8)
                                   + 8 * (*v67 >> *(_WORD *)(*(void *)(a1 + 88) + 44)))
                       + 16 * (*v67 & ~(-1 << *(_WORD *)(*(void *)(a1 + 88) + 44))));
        if (_FSTIncrementalMinimizationPrefixEqual(a1, (uint64_t)&v235, (uint64_t)v67)) {
          goto LABEL_67;
        }
      }
      unsigned int v231 = v64;
      unsigned int v68 = *(_DWORD *)(a1 + 96);
      uint64_t v69 = *(void *)(a1 + 88);
      if (v68 != -1)
      {
        char v70 = *(_WORD *)(v69 + 44);
        uint64_t v71 = *(void *)(*(void *)(v69 + 8) + 8 * (v68 >> v70));
        unsigned int v72 = v68 & ~(-1 << v70);
        *(_DWORD *)(a1 + 96) = (*(_DWORD *)(v71 + 16 * v72) & 0xBFFFFFFF) - 1;
        *(_OWORD *)(v71 + 16 * v72) = v235;
LABEL_66:
        uint64_t v89 = *(void *)(a1 + 80);
        unsigned int v90 = v231 % *(_DWORD *)(v89 + 32);
        uint64_t v91 = *(void *)(v89 + 8);
        LOBYTE(v89) = *(_WORD *)(v89 + 44);
        uint64_t v92 = *(void *)(v91 + 8 * (v90 >> v89));
        LODWORD(v89) = v90 & ~(-1 << v89);
        *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 88) + 8)
                              + 8 * (v68 >> *(_WORD *)(*(void *)(a1 + 88) + 44)))
                  + 16 * (v68 & ~(-1 << *(_WORD *)(*(void *)(a1 + 88) + 44)))) = *(_DWORD *)(v92
                                                                                                 + 4
                                                                                                 * v89);
        *(_DWORD *)(v92 + 4 * v89) = v68;
        goto LABEL_67;
      }
      unsigned int v68 = *(_DWORD *)(v69 + 32);
      if (v68 <= 2 * v66)
      {
LABEL_64:
        v234 = 0;
        uint64_t result = dpmemblock_GetNewElement(v69, &v234, 0);
        v237[0] = result;
        if (result) {
          return result;
        }
        _OWORD *v234 = v235;
        goto LABEL_66;
      }
      v234 = 0;
      unsigned int v73 = (2 * v66) | 1;
      if (v73 <= v66)
      {
        *(_DWORD *)(v65 + 32) = v73;
      }
      else
      {
        unsigned int v74 = v66 + 1;
        do
        {
          uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 80), &v234, 0);
          v237[0] = result;
          if (v74 >= v73) {
            break;
          }
          ++v74;
        }
        while (!result);
        if (result) {
          return result;
        }
        uint64_t v65 = *(void *)(a1 + 80);
        unsigned int v73 = *(_DWORD *)(v65 + 32);
        if (!v73)
        {
          unsigned int v209 = 0;
LABEL_56:
          uint64_t v69 = *(void *)(a1 + 88);
          unsigned int v68 = *(_DWORD *)(v69 + 32);
          if (v68)
          {
            unsigned int v79 = 0;
            uint64_t v80 = *(void *)(v69 + 8);
            __int16 v81 = *(_WORD *)(v69 + 44);
            uint64_t v206 = v80;
            do
            {
              uint64_t v82 = *(void *)(v80 + 8 * (v79 >> v81));
              if (!v82) {
                break;
              }
              uint64_t v83 = (_DWORD *)(v82 + 16 * (v79 & ~(-1 << v81)));
              if (((*v83 + 1) & 0x40000000) == 0)
              {
                uint64_t result = v237[0];
                if (v237[0]) {
                  return result;
                }
                uint64_t v84 = v69;
                unsigned int v85 = _FSTIncrementalMinimizationPrefixHash(a1, (uint64_t)v83);
                uint64_t v69 = v84;
                char v86 = *(_WORD *)(v65 + 44);
                uint64_t v87 = *(void *)(*(void *)(v65 + 8) + 8 * ((v85 % v209) >> v86));
                unsigned int v88 = (v85 % v209) & ~(-1 << v86);
                *uint64_t v83 = *(_DWORD *)(v87 + 4 * v88);
                uint64_t v80 = v206;
                *(_DWORD *)(v87 + 4 * v88) = v79;
                unsigned int v68 = *(_DWORD *)(v84 + 32);
              }
              ++v79;
            }
            while (v79 < v68);
          }
          uint64_t v36 = v214;
          goto LABEL_64;
        }
      }
      unsigned int v75 = 0;
      uint64_t v76 = *(void *)(v65 + 8);
      __int16 v77 = *(_WORD *)(v65 + 44);
      unsigned int v209 = v73;
      do
      {
        uint64_t v78 = *(void *)(v76 + 8 * (v75 >> v77));
        if (!v78) {
          break;
        }
        *(_DWORD *)(v78 + 4 * (v75++ & ~(-1 << v77))) = -1;
      }
      while (v75 < *(_DWORD *)(v65 + 32));
      goto LABEL_56;
    }
LABEL_67:
    unint64_t v33 = v220;
LABEL_68:
    a2 = v212;
    uint64_t v7 = v213;
    *(_DWORD *)(v213 + 4 * v35) = v10;
    a3 = v210;
    if (v210 - v35 > *(_DWORD *)(v223 + 12)) {
      *(_DWORD *)(v223 + 12) = v210 - v35;
    }
    if (v35 == v33)
    {
      if (v10 != 1)
      {
        uint64_t v93 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8)
                        + 8 * (v10 >> *(_WORD *)(*(void *)(a1 + 72) + 44)))
            + 8 * (v10 & ~(-1 << *(_WORD *)(*(void *)(a1 + 72) + 44)));
        *(_DWORD *)(v93 + 4) |= 0x80000000;
        __FSTIncrementalMinimization_ClearSuffixes(a1, v210, v213);
        v237[0] = 0;
      }
      unsigned int v10 = v216;
      goto LABEL_76;
    }
    if (v10 == 1) {
      break;
    }
    DWORD1(v236) = v10;
LABEL_76:
    unint64_t v9 = v35 + 1;
    ++v226;
    v228 += 3;
    if (v9 == v36) {
      goto LABEL_183;
    }
  }
  uint64_t v157 = *(void *)(a1 + 72);
  unsigned int v158 = *(_DWORD *)(v157 + 32);
  if (v35)
  {
    __FSTIncrementalMinimization_ClearSuffixes(a1, v35, v213);
    v237[0] = 0;
    uint64_t v157 = *(void *)(a1 + 72);
  }
  *(void *)&long long v235 = 0;
  uint64_t result = dpmemblock_GetNewElement(v157, &v235, 0);
  v237[0] = result;
  if (result) {
    return result;
  }
  *(void *)long long v235 = 0x1FFFFFFFFLL;
  unsigned int v94 = v158;
  uint64_t v159 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 8 * (v158 >> *(_WORD *)(*(void *)(a1 + 72) + 44)))
       + 8 * (v158 & ~(-1 << *(_WORD *)(*(void *)(a1 + 72) + 44)));
  *(_DWORD *)(v159 + 4) |= 0x80000000;
  *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 64) + 8)
                        + 8 * (v218 >> *(_WORD *)(*(void *)(a1 + 64) + 44)))
            + 20 * (v218 & ~(-1 << *(_WORD *)(*(void *)(a1 + 64) + 44)))
            + 4) = v158;
  unsigned int v95 = v35 + 1;
  DWORD1(v236) = v158;
LABEL_79:
  if (a3 <= v95)
  {
LABEL_183:
    OOCAllocator_Free(v207, v7);
    return v237[0];
  }
  unsigned int v227 = a3 - v95;
  uint64_t v96 = *(void *)(a1 + 64);
  uint64_t v97 = *(void *)(a1 + 72);
  unsigned int v98 = *(_DWORD *)(v96 + 32);
  int v229 = *(_DWORD *)(v97 + 32);
  uint64_t v99 = *(void *)(v97 + 8);
  LOBYTE(v97) = *(_WORD *)(v97 + 44);
  uint64_t v100 = *(void *)(v99 + 8 * (v94 >> v97));
  unsigned int v217 = v94;
  uint64_t v101 = 8 * (v94 & ~(-1 << v97));
  int v102 = *(_DWORD *)(v100 + v101);
  v234 = 0;
  unsigned int v232 = v98;
  *(_DWORD *)(v100 + v101) = v98;
  unsigned int v103 = v95;
  if (v95 < a3 - 1)
  {
    uint64_t v104 = a2 + 12 * v95;
    unsigned int v105 = v95;
    unsigned int v106 = ~v95 + a3;
    do
    {
      uint64_t v107 = *(void *)(a1 + 64);
      int v108 = *(_DWORD *)(*(void *)(a1 + 72) + 32);
      *(void *)&long long v235 = *(void *)v104;
      DWORD2(v235) = *(_DWORD *)(v104 + 8);
      v233 = 0;
      uint64_t result = dpmemblock_GetNewElement(v107, &v233, 0);
      v237[0] = result;
      if (result) {
        return result;
      }
      uint64_t v109 = v233;
      _DWORD *v233 = -1;
      v109[1] = v108;
      *((void *)v109 + 1) = v235;
      v109[4] = DWORD2(v235);
      uint64_t v110 = *(void *)(a1 + 72);
      int v111 = *(_DWORD *)(*(void *)(a1 + 64) + 32);
      v233 = 0;
      uint64_t result = dpmemblock_GetNewElement(v110, &v233, 0);
      v237[0] = result;
      if (result) {
        return result;
      }
      uint64_t v112 = v233;
      _DWORD *v233 = v111;
      v112[1] = 1;
      v104 += 12;
      --v106;
    }
    while (v106);
    uint64_t v96 = *(void *)(a1 + 64);
    unsigned int v103 = a3 - 1;
    a2 = v212;
    uint64_t v7 = v213;
    unsigned int v95 = v105;
  }
  uint64_t v113 = a2 + 12 * v103;
  *(void *)&long long v235 = *(void *)v113;
  DWORD2(v235) = *(_DWORD *)(v113 + 8);
  v233 = 0;
  uint64_t result = dpmemblock_GetNewElement(v96, &v233, 0);
  v237[0] = result;
  if (result) {
    return result;
  }
  v114 = v233;
  *(void *)v233 = 0x1FFFFFFFFLL;
  *((void *)v114 + 1) = v235;
  v114[4] = DWORD2(v235);
  *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 64) + 8)
                        + 8 * (v232 >> *(_WORD *)(*(void *)(a1 + 64) + 44)))
            + 20 * (v232 & ~(-1 << *(_WORD *)(*(void *)(a1 + 64) + 44)))) = v102;
  unsigned int v115 = v227;
  if (v227 < 2)
  {
LABEL_119:
    BOOL v153 = a3 == v95;
    unsigned int v154 = v115;
    unsigned int v155 = v217;
    if (v153) {
      goto LABEL_183;
    }
LABEL_150:
    int v172 = 0;
    unsigned int v225 = v154;
    while (2)
    {
      DWORD2(v236) = v172 + v232;
      HIDWORD(v236) = v115 - v172;
      LODWORD(v236) = 0;
      uint64_t result = v237[0];
      if (v237[0]) {
        return result;
      }
      v173 = (_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 64) + 8)
                                  + 8 * ((v172 + v232) >> *(_WORD *)(*(void *)(a1 + 64) + 44)))
                      + 20 * ((v172 + v232) & ~(-1 << *(_WORD *)(*(void *)(a1 + 64) + 44))));
      uint64_t v174 = v173[4] + 2239 * (v173[3] + 2239 * (v173[2] + 2239 * v155));
      uint64_t v175 = *(void *)(a1 + 80);
      unsigned int v176 = *(_DWORD *)(v175 + 32);
      v177 = (_DWORD *)(*(void *)(*(void *)(v175 + 8) + 8 * ((v174 % v176) >> *(_WORD *)(v175 + 44)))
                      + 4 * ((v174 % v176) & ~(-1 << *(_WORD *)(v175 + 44))));
      while ((*v177 & 0x80000000) == 0)
      {
        v177 = (_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 88) + 8)
                                    + 8 * (*v177 >> *(_WORD *)(*(void *)(a1 + 88) + 44)))
                        + 16 * (*v177 & ~(-1 << *(_WORD *)(*(void *)(a1 + 88) + 44))));
        if (_FSTIncrementalMinimizationPrefixEqual(a1, (uint64_t)&v236, (uint64_t)v177)) {
          goto LABEL_182;
        }
      }
      unsigned int v178 = *(_DWORD *)(a1 + 96);
      uint64_t v179 = *(void *)(a1 + 88);
      if (v178 != -1)
      {
        char v180 = *(_WORD *)(v179 + 44);
        uint64_t v181 = *(void *)(*(void *)(v179 + 8) + 8 * (v178 >> v180));
        unsigned int v182 = v178 & ~(-1 << v180);
        *(_DWORD *)(a1 + 96) = (*(_DWORD *)(v181 + 16 * v182) & 0xBFFFFFFF) - 1;
        *(_OWORD *)(v181 + 16 * v182) = v236;
        goto LABEL_181;
      }
      unsigned int v178 = *(_DWORD *)(v179 + 32);
      if (v178 <= 2 * v176)
      {
LABEL_179:
        v233 = 0;
        uint64_t result = dpmemblock_GetNewElement(v179, &v233, 0);
        v237[0] = result;
        if (result) {
          return result;
        }
        *(_OWORD *)v233 = v236;
LABEL_181:
        uint64_t v202 = *(void *)(a1 + 80);
        unsigned int v203 = v174 % *(_DWORD *)(v202 + 32);
        uint64_t v204 = *(void *)(v202 + 8);
        LOBYTE(v202) = *(_WORD *)(v202 + 44);
        uint64_t v205 = *(void *)(v204 + 8 * (v203 >> v202));
        LODWORD(v202) = v203 & ~(-1 << v202);
        *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 88) + 8)
                              + 8 * (v178 >> *(_WORD *)(*(void *)(a1 + 88) + 44)))
                  + 16 * (v178 & ~(-1 << *(_WORD *)(*(void *)(a1 + 88) + 44)))) = *(_DWORD *)(v205
                                                                                                  + 4 * v202);
        *(_DWORD *)(v205 + 4 * v202) = v178;
        unsigned int v154 = v225;
LABEL_182:
        unsigned int v155 = v172 + v229;
        DWORD1(v236) = v172 + v229;
        if (++v172 != v154) {
          continue;
        }
        goto LABEL_183;
      }
      break;
    }
    v233 = 0;
    unsigned int v183 = (2 * v176) | 1;
    if (v183 <= v176)
    {
      *(_DWORD *)(v175 + 32) = v183;
    }
    else
    {
      unsigned int v184 = v176 + 1;
      do
      {
        uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 80), &v233, 0);
        v237[0] = result;
        if (v184 >= v183) {
          break;
        }
        ++v184;
      }
      while (!result);
      if (result) {
        return result;
      }
      uint64_t v175 = *(void *)(a1 + 80);
      unsigned int v183 = *(_DWORD *)(v175 + 32);
      if (!v183)
      {
        unsigned int v222 = 0;
LABEL_170:
        uint64_t v179 = *(void *)(a1 + 88);
        unsigned int v178 = *(_DWORD *)(v179 + 32);
        if (v178)
        {
          unsigned int v189 = 0;
          uint64_t v190 = *(void *)(v179 + 8);
          uint64_t v191 = *(unsigned __int16 *)(v179 + 44);
          int v192 = ~(-1 << v191);
          uint64_t v219 = v190;
          do
          {
            uint64_t v193 = *(void *)(v190 + 8 * (v189 >> v191));
            if (!v193) {
              break;
            }
            v194 = (_DWORD *)(v193 + 16 * (v189 & v192));
            if (((*v194 + 1) & 0x40000000) == 0)
            {
              uint64_t result = v237[0];
              if (v237[0]) {
                return result;
              }
              uint64_t v195 = v174;
              uint64_t v196 = v191;
              uint64_t v197 = v179;
              unsigned int v198 = _FSTIncrementalMinimizationPrefixHash(a1, (uint64_t)v194);
              uint64_t v179 = v197;
              char v199 = *(_WORD *)(v175 + 44);
              uint64_t v200 = *(void *)(*(void *)(v175 + 8) + 8 * ((v198 % v222) >> v199));
              uint64_t v191 = v196;
              uint64_t v174 = v195;
              unsigned int v201 = (v198 % v222) & ~(-1 << v199);
              _DWORD *v194 = *(_DWORD *)(v200 + 4 * v201);
              uint64_t v190 = v219;
              *(_DWORD *)(v200 + 4 * v201) = v189;
              unsigned int v178 = *(_DWORD *)(v197 + 32);
            }
            ++v189;
          }
          while (v189 < v178);
          uint64_t v7 = v213;
        }
        unsigned int v115 = v227;
        goto LABEL_179;
      }
    }
    unsigned int v185 = 0;
    uint64_t v186 = *(void *)(v175 + 8);
    __int16 v187 = *(_WORD *)(v175 + 44);
    unsigned int v222 = v183;
    do
    {
      uint64_t v188 = *(void *)(v186 + 8 * (v185 >> v187));
      if (!v188) {
        break;
      }
      *(_DWORD *)(v188 + 4 * (v185++ & ~(-1 << v187))) = -1;
    }
    while (v185 < *(_DWORD *)(v175 + 32));
    goto LABEL_170;
  }
  int v116 = v229 - 1;
  int v117 = 1;
  unsigned int v221 = v95;
  while (2)
  {
    int v224 = v117;
    HIDWORD(v234) = v116 + v117;
    unsigned int v118 = _FSTIncrementalMinimizationSuffixHash(a1, (uint64_t)&v234);
    uint64_t result = v237[0];
    if (v237[0]) {
      return result;
    }
    uint64_t v119 = *(void *)(a1 + 104);
    unsigned int v120 = *(_DWORD *)(v119 + 32);
    unsigned int v121 = (unsigned int *)(*(void *)(*(void *)(v119 + 8) + 8 * ((v118 % v120) >> *(_WORD *)(v119 + 44)))
                          + 4 * ((v118 % v120) & ~(-1 << *(_WORD *)(v119 + 44))));
LABEL_91:
    unsigned int v122 = *v121;
    if ((*v121 & 0x80000000) != 0)
    {
      unsigned int v127 = *(_DWORD *)(a1 + 120);
      uint64_t v128 = *(void *)(a1 + 112);
      if (v127 != -1)
      {
        char v129 = *(_WORD *)(v128 + 44);
        uint64_t v130 = *(void *)(*(void *)(v128 + 8) + 8 * (v127 >> v129));
        unsigned int v131 = v127 & ~(-1 << v129);
        *(_DWORD *)(a1 + 120) = (*(_DWORD *)(v130 + 8 * v131) & 0xBFFFFFFF) - 1;
        *(void *)(v130 + 8 * v131) = v234;
        uint64_t v7 = v213;
        unsigned int v95 = v221;
        goto LABEL_118;
      }
      unsigned int v127 = *(_DWORD *)(v128 + 32);
      unsigned int v95 = v221;
      if (v127 <= 2 * v120)
      {
LABEL_116:
        v233 = 0;
        uint64_t result = dpmemblock_GetNewElement(v128, &v233, 0);
        v237[0] = result;
        uint64_t v7 = v213;
        if (result) {
          return result;
        }
        *(void *)v233 = v234;
LABEL_118:
        int v116 = v229 - 1;
        uint64_t v149 = *(void *)(a1 + 104);
        unsigned int v150 = v118 % *(_DWORD *)(v149 + 32);
        uint64_t v151 = *(void *)(v149 + 8);
        LOBYTE(v149) = *(_WORD *)(v149 + 44);
        uint64_t v152 = *(void *)(v151 + 8 * (v150 >> v149));
        LODWORD(v149) = v150 & ~(-1 << v149);
        *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 112) + 8)
                              + 8 * (v127 >> *(_WORD *)(*(void *)(a1 + 112) + 44)))
                  + 8 * (v127 & ~(-1 << *(_WORD *)(*(void *)(a1 + 112) + 44)))) = *(_DWORD *)(v152
                                                                                                  + 4 * v149);
        *(_DWORD *)(v152 + 4 * v149) = v127;
        int v117 = v224 + 1;
        unsigned int v115 = v227;
        if (v224 + 1 != v227) {
          continue;
        }
        goto LABEL_119;
      }
      v233 = 0;
      unsigned int v132 = (2 * v120) | 1;
      if (v132 <= v120)
      {
        *(_DWORD *)(v119 + 32) = v132;
      }
      else
      {
        unsigned int v133 = v120 + 1;
        do
        {
          uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 104), &v233, 0);
          v237[0] = result;
          if (v133 >= v132) {
            break;
          }
          ++v133;
        }
        while (!result);
        if (result) {
          return result;
        }
        uint64_t v119 = *(void *)(a1 + 104);
        unsigned int v132 = *(_DWORD *)(v119 + 32);
        if (!v132)
        {
          unsigned int v215 = 0;
          goto LABEL_108;
        }
      }
      unsigned int v134 = 0;
      uint64_t v135 = *(void *)(v119 + 8);
      __int16 v136 = *(_WORD *)(v119 + 44);
      unsigned int v215 = v132;
      do
      {
        uint64_t v137 = *(void *)(v135 + 8 * (v134 >> v136));
        if (!v137) {
          break;
        }
        *(_DWORD *)(v137 + 4 * (v134++ & ~(-1 << v136))) = -1;
      }
      while (v134 < *(_DWORD *)(v119 + 32));
LABEL_108:
      uint64_t v128 = *(void *)(a1 + 112);
      unsigned int v127 = *(_DWORD *)(v128 + 32);
      if (v127)
      {
        unsigned int v211 = a3;
        unsigned int v138 = 0;
        uint64_t v139 = *(void *)(v128 + 8);
        __int16 v140 = *(_WORD *)(v128 + 44);
        do
        {
          uint64_t v141 = *(void *)(v139 + 8 * (v138 >> v140));
          if (!v141) {
            break;
          }
          v142 = (_DWORD *)(v141 + 8 * (v138 & ~(-1 << v140)));
          if (((*v142 + 1) & 0x40000000) == 0)
          {
            uint64_t v143 = v128;
            unsigned int v144 = _FSTIncrementalMinimizationSuffixHash(a1, (uint64_t)v142);
            uint64_t result = v237[0];
            if (v237[0]) {
              return result;
            }
            unsigned int v145 = v144 % v215;
            char v146 = *(_WORD *)(v119 + 44);
            uint64_t v147 = *(void *)(*(void *)(v119 + 8) + 8 * (v145 >> v146));
            unsigned int v148 = v145 & ~(-1 << v146);
            _DWORD *v142 = *(_DWORD *)(v147 + 4 * v148);
            *(_DWORD *)(v147 + 4 * v148) = v138;
            uint64_t v128 = v143;
            unsigned int v127 = *(_DWORD *)(v143 + 32);
          }
          ++v138;
        }
        while (v138 < v127);
        a3 = v211;
        unsigned int v95 = v221;
      }
      goto LABEL_116;
    }
    break;
  }
  uint64_t v123 = *(void *)(a1 + 112);
  uint64_t v124 = *(void *)(v123 + 8);
  LOBYTE(v123) = *(_WORD *)(v123 + 44);
  uint64_t v125 = *(void *)(v124 + 8 * (v122 >> v123));
  uint64_t v126 = v122 & ~(-1 << v123);
  unsigned int v121 = (unsigned int *)(v125 + 8 * v126);
  if (!_FSTIncrementalMinimizationSuffixEqual(a1, (uint64_t)&v234, (uint64_t)v121)) {
    goto LABEL_91;
  }
  unsigned int v160 = a3 - (v224 + v221);
  if (a3 <= v224 + v221)
  {
    uint64_t v7 = v213;
    unsigned int v155 = v217;
    unsigned int v115 = v227;
    unsigned int v154 = v224;
    goto LABEL_150;
  }
  unsigned int v161 = *(_DWORD *)(v125 + 8 * v126 + 4);
  v233 = 0;
  uint64_t v162 = *(void *)(a1 + 64);
  unsigned int v163 = *(_DWORD *)(v162 + 32);
  unsigned int v164 = v163 - v160;
  uint64_t v7 = v213;
  if (v163 >= v160)
  {
    *(_DWORD *)(v162 + 32) = v164;
    unsigned int v154 = v224;
LABEL_141:
    *(_DWORD *)(*(void *)(*(void *)(v162 + 8) + 8 * ((v164 - 1) >> *(_WORD *)(v162 + 44)))
              + 20 * ((v164 - 1) & ~(-1 << *(_WORD *)(v162 + 44)))
              + 4) = v161;
    uint64_t v166 = *(void *)(a1 + 72);
    uint64_t v167 = *(void *)(*(void *)(v166 + 8) + 8 * (v161 >> *(_WORD *)(v166 + 44)))
         + 8 * (v161 & ~(-1 << *(_WORD *)(v166 + 44)));
    *(_DWORD *)(v167 + 4) = ((*(_DWORD *)(v167 + 4) & 0x7FFFFFFF) + 1) | *(_DWORD *)(v167 + 4) & 0x80000000;
    v233 = 0;
    unsigned int v168 = *(_DWORD *)(v166 + 32);
    BOOL v169 = v168 >= v160;
    unsigned int v170 = v168 - v160;
    if (v169)
    {
      *(_DWORD *)(v166 + 32) = v170;
      unsigned int v155 = v217;
    }
    else
    {
      uint64_t result = v237[0];
      if (v237[0]) {
        return result;
      }
      unsigned int v171 = v168 + 1;
      do
      {
        uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 72), &v233, 0);
        v237[0] = result;
        if (v171 >= v170) {
          break;
        }
        ++v171;
      }
      while (!result);
      unsigned int v155 = v217;
      if (result) {
        return result;
      }
    }
    unsigned int v115 = v227;
    goto LABEL_150;
  }
  unsigned int v165 = v163 + 1;
  do
  {
    uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 64), &v233, 0);
    v237[0] = result;
    if (v165 >= v164) {
      break;
    }
    ++v165;
  }
  while (!result);
  unsigned int v154 = v224;
  if (!result)
  {
    uint64_t v162 = *(void *)(a1 + 64);
    unsigned int v164 = *(_DWORD *)(v162 + 32);
    goto LABEL_141;
  }
  return result;
}

uint64_t __FSTIncrementalMinimization_SetExactMatchMode(uint64_t result, int a2)
{
  if (*(_DWORD *)(result + 128) != a2)
  {
    *(_DWORD *)(result + 128) = a2;
    uint64_t v2 = *(void *)(result + 80);
    unsigned int v3 = *(_DWORD *)(v2 + 32);
    if (a2)
    {
      if (v3)
      {
        unsigned int v4 = 0;
        uint64_t v5 = *(void *)(v2 + 8);
        __int16 v6 = *(_WORD *)(v2 + 44);
        do
        {
          uint64_t v7 = *(void *)(v5 + 8 * (v4 >> v6));
          if (!v7) {
            break;
          }
          *(_DWORD *)(v7 + 4 * (v4++ & ~(-1 << v6))) = -1;
        }
        while (v4 < *(_DWORD *)(v2 + 32));
      }
      uint64_t v8 = *(void *)(result + 88);
      unsigned int v9 = *(_DWORD *)(v8 + 32);
      if (v9)
      {
        unsigned int v10 = 0;
        uint64_t v11 = *(void *)(v8 + 8);
        __int16 v12 = *(_WORD *)(v8 + 44);
        do
        {
          uint64_t v13 = *(void *)(v11 + 8 * (v10 >> v12));
          if (!v13) {
            break;
          }
          uint64_t v14 = v10 & ~(-1 << v12);
          uint64_t v15 = (_DWORD *)(v13 + 16 * v14);
          if (((*v15 + 1) & 0x40000000) == 0)
          {
            uint64_t v16 = *(void *)(*(void *)(*(void *)(result + 64) + 8)
                            + 8
                            * (*(_DWORD *)(v13 + 16 * v14 + 8) >> *(_WORD *)(*(void *)(result + 64)
                                                                                         + 44)))
                + 20
                * (*(_DWORD *)(v13 + 16 * v14 + 8) & ~(-1 << *(_WORD *)(*(void *)(result + 64) + 44)));
            LODWORD(v16) = (*(_DWORD *)(v16 + 16)
                          + 2239
                          * (*(_DWORD *)(v16 + 12)
                           + 2239 * (*(_DWORD *)(v16 + 8) + 2239 * *(_DWORD *)(v13 + 16 * v14 + 4))))
                         % v3;
            char v17 = *(_WORD *)(v2 + 44);
            uint64_t v18 = *(void *)(*(void *)(v2 + 8) + 8 * (v16 >> v17));
            LODWORD(v16) = v16 & ~(-1 << v17);
            *uint64_t v15 = *(_DWORD *)(v18 + 4 * v16);
            *(_DWORD *)(v18 + 4 * v16) = v10;
            unsigned int v9 = *(_DWORD *)(v8 + 32);
          }
          ++v10;
        }
        while (v10 < v9);
      }
    }
    else
    {
      if (v3)
      {
        unsigned int v19 = 0;
        uint64_t v20 = *(void *)(v2 + 8);
        __int16 v21 = *(_WORD *)(v2 + 44);
        do
        {
          uint64_t v22 = *(void *)(v20 + 8 * (v19 >> v21));
          if (!v22) {
            break;
          }
          *(_DWORD *)(v22 + 4 * (v19++ & ~(-1 << v21))) = -1;
        }
        while (v19 < *(_DWORD *)(v2 + 32));
      }
      uint64_t v23 = *(void *)(result + 88);
      unsigned int v24 = *(_DWORD *)(v23 + 32);
      if (v24)
      {
        unsigned int v25 = 0;
        uint64_t v26 = *(void *)(v23 + 8);
        __int16 v27 = *(_WORD *)(v23 + 44);
        do
        {
          uint64_t v28 = *(void *)(v26 + 8 * (v25 >> v27));
          if (!v28) {
            break;
          }
          uint64_t v29 = v25 & ~(-1 << v27);
          __int16 v30 = (_DWORD *)(v28 + 16 * v29);
          if (((*v30 + 1) & 0x40000000) == 0)
          {
            uint64_t v31 = *(void *)(*(void *)(*(void *)(result + 64) + 8)
                            + 8
                            * (*(_DWORD *)(v28 + 16 * v29 + 8) >> *(_WORD *)(*(void *)(result + 64)
                                                                                         + 44)))
                + 20
                * (*(_DWORD *)(v28 + 16 * v29 + 8) & ~(-1 << *(_WORD *)(*(void *)(result + 64) + 44)));
            LODWORD(v31) = (*(_DWORD *)(v31 + 16) + 2239 * (*(_DWORD *)(v31 + 12) + 2239 * *(_DWORD *)(v31 + 8))) % v3;
            char v32 = *(_WORD *)(v2 + 44);
            uint64_t v33 = *(void *)(*(void *)(v2 + 8) + 8 * (v31 >> v32));
            LODWORD(v31) = v31 & ~(-1 << v32);
            *__int16 v30 = *(_DWORD *)(v33 + 4 * v31);
            *(_DWORD *)(v33 + 4 * v31) = v25;
            unsigned int v24 = *(_DWORD *)(v23 + 32);
          }
          ++v25;
        }
        while (v25 < v24);
      }
    }
  }
  return result;
}

BOOL _FSTIncrementalMinimizationPrefixEqual(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a2 + 4) != *(_DWORD *)(a3 + 4)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 64);
  uint64_t v4 = *(void *)(v3 + 8);
  unsigned int v5 = *(_DWORD *)(a2 + 8);
  char v6 = *(_WORD *)(v3 + 44);
  uint64_t v7 = *(void *)(v4 + 8 * (v5 >> v6));
  unsigned int v8 = v5 & ~(-1 << v6);
  unsigned int v9 = *(_DWORD *)(a3 + 8);
  uint64_t v10 = *(void *)(v4 + 8 * (v9 >> v6));
  unsigned int v11 = v9 & ~(-1 << v6);
  if (*(_DWORD *)(v7 + 20 * v8 + 8) != *(_DWORD *)(v10 + 20 * v11 + 8)) {
    return 0;
  }
  return *(_DWORD *)(v7 + 20 * v8 + 12) == *(_DWORD *)(v10 + 20 * v11 + 12)
      && *(_DWORD *)(v7 + 20 * v8 + 16) == *(_DWORD *)(v10 + 20 * v11 + 16);
}

uint64_t __FSTIncrementalMinimization_ClearSuffixes(uint64_t result, unsigned int a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v3 = result;
    uint64_t v34 = 0;
    uint64_t v4 = *(void *)(result + 72);
    __int16 v30 = *(_WORD *)(v4 + 44);
    uint64_t v31 = *(void *)(v4 + 8);
    uint64_t v5 = a2;
    do
    {
      unsigned int v6 = *(_DWORD *)(a3 + 4 * --v5);
      uint64_t v7 = *(void *)(v31 + 8 * (v6 >> v30));
      HIDWORD(v34) = v6;
      unsigned int v8 = *(_DWORD *)(v7 + 8 * (v6 & ~(-1 << v30)));
      if (v8 != -1)
      {
        if (*(_DWORD *)(*(void *)(*(void *)(*(void *)(v3 + 64) + 8)
                                   + 8 * (v8 >> *(_WORD *)(*(void *)(v3 + 64) + 44)))
                       + 20 * (v8 & ~(-1 << *(_WORD *)(*(void *)(v3 + 64) + 44)))) != -1)
          return result;
        uint64_t v33 = v5;
        uint64_t result = _FSTIncrementalMinimizationSuffixHash(v3, (uint64_t)&v34);
        uint64_t v9 = *(void *)(v3 + 104);
        unsigned int v28 = *(_DWORD *)(v9 + 32);
        uint64_t v29 = *(void *)(v9 + 8);
        __int16 v27 = *(_WORD *)(v9 + 44);
        int v26 = ~(-1 << v27);
        uint64_t v10 = (unsigned int *)(*(void *)(v29 + 8 * ((result % v28) >> v27))
                             + 4 * ((result % v28) & v26));
        while (1)
        {
          unsigned int v11 = *v10;
          if ((*v10 & 0x80000000) != 0) {
            break;
          }
          uint64_t v12 = *(void *)(v3 + 112);
          uint64_t v13 = *(void *)(v12 + 8);
          __int16 v14 = *(_WORD *)(v12 + 44);
          uint64_t v15 = v11 >> v14;
          uint64_t v16 = v11 & ~(-1 << v14);
          uint64_t v10 = (unsigned int *)(*(void *)(v13 + 8 * v15) + 8 * v16);
          uint64_t result = _FSTIncrementalMinimizationSuffixEqual(v3, (uint64_t)&v34, (uint64_t)v10);
          if (result)
          {
            int v17 = ~(-1 << v14);
            goto LABEL_11;
          }
        }
        uint64_t v5 = v33;
        if (v11 == -1) {
          continue;
        }
        uint64_t v18 = *(void *)(v3 + 112);
        uint64_t v13 = *(void *)(v18 + 8);
        __int16 v14 = *(_WORD *)(v18 + 44);
        uint64_t v15 = v11 >> v14;
        int v17 = ~(-1 << v14);
        uint64_t v16 = v11 & v17;
LABEL_11:
        unsigned int v19 = (int *)(*(void *)(v13 + 8 * v15) + 8 * v16);
        uint64_t v5 = v33;
        if (v6 == v19[1])
        {
          uint64_t result = _FSTIncrementalMinimizationSuffixHash(v3, (uint64_t)v19);
          uint64_t v20 = *(void *)(v29 + 8 * ((result % v28) >> v27));
          uint64_t v21 = (result % v28) & v26;
          unsigned int v22 = *(_DWORD *)(v20 + 4 * v21);
          for (unsigned int i = -1;
                (v22 & 0x80000000) == 0;
                unsigned int v22 = *(_DWORD *)(*(void *)(v13 + 8 * (v22 >> v14)) + 8 * (v22 & v17)))
          {
            if (v22 == v11) {
              break;
            }
            unsigned int i = v22;
          }
          int v24 = *v19;
          int v25 = *(_DWORD *)(v3 + 120);
          *(_DWORD *)(v3 + 120) = v11;
          int *v19 = (v25 + 1) | 0x40000000;
          if ((i & 0x80000000) != 0 && v24 < 0)
          {
            *(_DWORD *)(v20 + 4 * v21) = -1;
          }
          else if ((i & 0x80000000) != 0)
          {
            *(_DWORD *)(v20 + 4 * v21) = v24;
          }
          else
          {
            *(_DWORD *)(*(void *)(v13 + 8 * (i >> v14)) + 8 * (i & v17)) = v24;
          }
        }
      }
    }
    while (v5);
  }
  return result;
}

BOOL _FSTIncrementalMinimizationSuffixEqual(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(a2 + 4);
  unsigned int v4 = *(_DWORD *)(a3 + 4);
  uint64_t v5 = *(void *)(a1 + 72);
  uint64_t v6 = *(void *)(v5 + 8);
  __int16 v7 = *(_WORD *)(v5 + 44);
  int v8 = ~(-1 << v7);
  while (1)
  {
    unsigned int v9 = *(_DWORD *)(*(void *)(v6 + 8 * (v3 >> v7)) + 8 * (v3 & v8));
    unsigned int v10 = *(_DWORD *)(*(void *)(v6 + 8 * (v4 >> v7)) + 8 * (v4 & v8));
    if (v9 == -1 || v10 == -1) {
      break;
    }
    uint64_t v12 = *(void *)(a1 + 64);
    uint64_t v13 = *(void *)(v12 + 8);
    __int16 v14 = *(_WORD *)(v12 + 44);
    uint64_t v15 = *(void *)(v13 + 8 * (v9 >> v14));
    unsigned int v16 = v9 & ~(-1 << v14);
    uint64_t v17 = *(void *)(v13 + 8 * (v10 >> v14));
    unsigned int v18 = v10 & ~(-1 << v14);
    if (*(_DWORD *)(v15 + 20 * v16 + 8) != *(_DWORD *)(v17 + 20 * v18 + 8)
      || *(_DWORD *)(v15 + 20 * v16 + 12) != *(_DWORD *)(v17 + 20 * v18 + 12)
      || *(_DWORD *)(v15 + 20 * v16 + 16) != *(_DWORD *)(v17 + 20 * v18 + 16))
    {
      break;
    }
    unsigned int v3 = *(_DWORD *)(v15 + 20 * v16 + 4);
    unsigned int v4 = *(_DWORD *)(v17 + 20 * v18 + 4);
    if (v3 == 1 || v4 == 1) {
      return v3 == v4;
    }
  }
  return 0;
}

uint64_t FSTIncrementalMinimization_FetchState(uint64_t *a1, unsigned int a2, uint64_t a3, void *a4)
{
  uint64_t v36 = 0;
  uint64_t v7 = FSTStatePool_PopFSTState(a1[6], &v36);
  unsigned int v37 = v7;
  if (!v7)
  {
    uint64_t v8 = v36;
    unsigned int v9 = (unsigned int *)(*(void *)(*(void *)(a1[9] + 8) + 8 * (a2 >> *(_WORD *)(a1[9] + 44)))
                        + 8 * (a2 & ~(-1 << *(_WORD *)(a1[9] + 44))));
    int v10 = v9[1];
    unsigned int v11 = v10 & 0x80000000 | *(_DWORD *)(v36 + 8);
    *(_DWORD *)(v36 + 8) = v11 | 0x40000000;
    if (v10 >= 0) {
      int v12 = 0x7FFFFFFF;
    }
    else {
      int v12 = 0;
    }
    *(_DWORD *)(v8 + 24) = a2;
    *(_DWORD *)(v8 + 28) = v12;
    unsigned int v13 = *v9;
    if ((*v9 & 0x80000000) != 0)
    {
      unsigned int v14 = 0;
      unsigned int v15 = 0;
    }
    else
    {
      unsigned int v14 = 0;
      unsigned int v15 = 0;
      uint64_t v16 = a1[8];
      uint64_t v17 = *(void *)(v16 + 8);
      __int16 v18 = *(_WORD *)(v16 + 44);
      do
      {
        unsigned int v19 = (unsigned int *)(*(void *)(v17 + 8 * (v13 >> v18)) + 20 * (v13 & ~(-1 << v18)));
        if (v19[2] == -2) {
          ++v14;
        }
        else {
          ++v15;
        }
        unsigned int v13 = *v19;
      }
      while ((v13 & 0x80000000) == 0);
      if (v14) {
        *(_DWORD *)(v8 + 8) = v11 | 0x60000000;
      }
    }
    *(_DWORD *)(v8 + 32) = v14;
    *(_DWORD *)(v8 + 48) = v15;
    uint64_t v20 = *(void *)(v8 + 40);
    if (!v20 || *(_DWORD *)(v20 - 4) <= v14)
    {
      uint64_t v21 = _FSTState_ReserveEpsilonArcsInternal(v8, v14, &v37);
      uint64_t v7 = v37;
      if (v37) {
        goto LABEL_31;
      }
      uint64_t v20 = v21;
    }
    uint64_t v22 = *(void *)(v36 + 56);
    if (v22 && *(_DWORD *)(v22 - 4) > v15 || (uint64_t v22 = _FSTState_ReserveArcsInternal(v36, v15, &v37), (v7 = v37) == 0))
    {
      int v23 = *(_DWORD *)(*(void *)(*(void *)(a1[9] + 8) + 8 * (a2 >> *(_WORD *)(a1[9] + 44)))
                      + 8 * (a2 & ~(-1 << *(_WORD *)(a1[9] + 44))));
      if (v23 < 1)
      {
        uint64_t v7 = 0;
      }
      else
      {
        uint64_t v24 = a1[8];
        uint64_t v25 = *(void *)(v24 + 8);
        __int16 v26 = *(_WORD *)(v24 + 44);
        uint64_t v27 = v36;
        do
        {
          uint64_t v28 = *(void *)(v25 + 8 * (v23 >> v26));
          unsigned int v29 = v23 & ~(-1 << v26);
          uint64_t v30 = v28 + 20 * v29;
          int v31 = *(_DWORD *)(v30 + 4);
          int v32 = *(_DWORD *)(v30 + 8);
          uint64_t v33 = (uint64_t *)(v30 + 12);
          if (v32 == -2)
          {
            *(_DWORD *)uint64_t v20 = v31;
            *(_DWORD *)(v20 + 4) = -2;
            uint64_t v34 = *v33;
            *(void *)(v20 + 8) = *v33;
            if ((v34 & 0x40000000) != 0) {
              *(_DWORD *)(v27 + 8) |= 0x10000000u;
            }
            v20 += 16;
          }
          else
          {
            *(_DWORD *)uint64_t v22 = v31;
            *(_DWORD *)(v22 + 4) = v32;
            *(void *)(v22 + 8) = *v33;
            v22 += 16;
          }
          int v23 = *(_DWORD *)(v28 + 20 * v29);
        }
        while (v23 > 0);
        uint64_t v7 = v37;
      }
    }
  }
LABEL_31:
  *a4 = v36;
  return v7;
}

uint64_t FSTIncrementalMinimization_FillBuffer(uint64_t a1, char *a2, uint64_t *a3)
{
  uint64_t v41 = 0;
  if (a2)
  {
    uint64_t v41 = *a3;
    uint64_t result = FST_FillHeader((_DWORD *)a1, a2, 1, &v41);
    if (result) {
      return result;
    }
    uint64_t v7 = v41;
    uint64_t v8 = (int *)&a2[v41];
    int v9 = *(_DWORD *)(a1 + 132);
    if (v9)
    {
      if (*(_DWORD *)(a1 + 136)) {
        int v9 = 3;
      }
      else {
        int v9 = 1;
      }
    }
    *uint64_t v8 = v9;
    uint64_t v10 = *(void *)(a1 + 64);
    v8[1] = *(_DWORD *)(v10 + 32);
    if (*(_DWORD *)(v10 + 32))
    {
      unsigned int v11 = 0;
      uint64_t v12 = *(void *)(v10 + 8);
      __int16 v13 = *(_WORD *)(v10 + 44);
      unsigned int v14 = &a2[v7 + 24];
      do
      {
        uint64_t v15 = *(void *)(v12 + 8 * (v11 >> v13));
        if (!v15) {
          break;
        }
        uint64_t v16 = (_DWORD *)(v15 + 20 * (v11 & ~(-1 << v13)));
        *((_DWORD *)v14 - 4) = *v16;
        *((_DWORD *)v14 - 3) = v16[1];
        *((_DWORD *)v14 - 2) = v16[2];
        *((_DWORD *)v14 - 1) = v16[3];
        *(_DWORD *)unsigned int v14 = v16[4];
        v14 += 20;
        ++v11;
      }
      while (v11 < *(_DWORD *)(v10 + 32));
      uint64_t v17 = v14 - 16;
    }
    else
    {
      uint64_t v17 = (char *)(v8 + 2);
    }
    uint64_t v19 = *(void *)(a1 + 72);
    *(_DWORD *)uint64_t v17 = *(_DWORD *)(v19 + 32);
    uint64_t v20 = v17 + 4;
    if (*(_DWORD *)(v19 + 32))
    {
      unsigned int v21 = 0;
      uint64_t v22 = *(void *)(v19 + 8);
      __int16 v23 = *(_WORD *)(v19 + 44);
      do
      {
        uint64_t v24 = *(void *)(v22 + 8 * (v21 >> v23));
        if (!v24) {
          break;
        }
        uint64_t v25 = (_DWORD *)(v24 + 8 * (v21 & ~(-1 << v23)));
        _DWORD *v20 = *v25;
        v20[1] = v25[1];
        v20 += 2;
        ++v21;
      }
      while (v21 < *(_DWORD *)(v19 + 32));
    }
    uint64_t v27 = *(void *)(a1 + 80);
    uint64_t v26 = *(void *)(a1 + 88);
    _DWORD *v20 = *(_DWORD *)(v26 + 32);
    v20[1] = *(_DWORD *)(v27 + 32);
    uint64_t v28 = v20 + 2;
    if (*(_DWORD *)(v26 + 32))
    {
      unsigned int v29 = 0;
      uint64_t v30 = *(void *)(v26 + 8);
      __int16 v31 = *(_WORD *)(v26 + 44);
      do
      {
        uint64_t v32 = *(void *)(v30 + 8 * (v29 >> v31));
        if (!v32) {
          break;
        }
        uint64_t v33 = (_DWORD *)(v32 + 16 * (v29 & ~(-1 << v31)));
        _DWORD *v28 = v33[1];
        v28[1] = v33[2];
        v28[2] = v33[3];
        v28 += 3;
        ++v29;
      }
      while (v29 < *(_DWORD *)(v26 + 32));
    }
    uint64_t v35 = *(void *)(a1 + 104);
    uint64_t v34 = *(void *)(a1 + 112);
    _DWORD *v28 = *(_DWORD *)(v34 + 32);
    v28[1] = *(_DWORD *)(v35 + 32);
    uint64_t v36 = (char *)(v28 + 2);
    if (*(_DWORD *)(v34 + 32))
    {
      unsigned int v37 = 0;
      uint64_t v38 = *(void *)(v34 + 8);
      __int16 v39 = *(_WORD *)(v34 + 44);
      do
      {
        uint64_t v40 = *(void *)(v38 + 8 * (v37 >> v39));
        if (!v40) {
          break;
        }
        *(_DWORD *)uint64_t v36 = *(_DWORD *)(v40 + 8 * (v37 & ~(-1 << v39)) + 4);
        v36 += 4;
        ++v37;
      }
      while (v37 < *(_DWORD *)(v34 + 32));
    }
    uint64_t v18 = v36 - a2;
  }
  else
  {
    uint64_t result = FST_GetHeaderSizeInOutputBuffer(&v41);
    if (result) {
      return result;
    }
    uint64_t v18 = v41
        + 20 * *(unsigned int *)(*(void *)(a1 + 64) + 32)
        + 8 * *(unsigned int *)(*(void *)(a1 + 72) + 32)
        + 12 * *(unsigned int *)(*(void *)(a1 + 88) + 32)
        + 4 * *(unsigned int *)(*(void *)(a1 + 112) + 32)
        + 28;
  }
  uint64_t result = 0;
  *a3 = v18;
  return result;
}

uint64_t FSTIncrementalMinimization_FillOutStateSequence(void *a1, uint64_t a2, int a3, uint64_t a4, _DWORD *a5)
{
  unsigned int v46 = 0;
  uint64_t v35 = a1[3];
  *a5 = 0;
  uint64_t v7 = (void *)OOCAllocator_Realloc(v35, 0, 64, &v46);
  if (!v46)
  {
    uint64_t v9 = (uint64_t)v7;
    uint64_t v43 = 0;
    int v45 = 0;
    void *v7 = 0;
    __FSTIncrementalMinimization_SetExactMatchMode((uint64_t)a1, 1);
    unsigned int v46 = 0;
    uint64_t v10 = (unsigned int *)(v9 + 8);
    int v37 = a3 - 1;
    unsigned int v44 = 0;
    uint64_t v11 = 8;
    while (2)
    {
      int v12 = *(v10 - 2);
      uint64_t v13 = *(v10 - 1);
      v10 -= 2;
      HIDWORD(v43) = v12;
      uint64_t v14 = **(void **)(a1[8] + 8);
      uint64_t v15 = a2 + 12 * v13;
      int v16 = *(_DWORD *)(v15 + 8);
      *(void *)(v14 + 8) = *(void *)v15;
      *(_DWORD *)(v14 + 16) = v16;
      if (!v46)
      {
        uint64_t v41 = v11;
        uint64_t v42 = v9;
        uint64_t v17 = a1[8];
        __int16 v18 = *(_WORD *)(v17 + 44);
        int v19 = ~(-1 << v18);
        uint64_t v40 = *(void *)(v17 + 8);
        uint64_t v20 = (_DWORD *)(*(void *)(v40 + 8 * (v44 >> v18)) + 20 * (v44 & v19));
        unsigned int v21 = v20[4] + 2239 * (v20[3] + 2239 * (v20[2] + 2239 * v12));
        uint64_t v22 = a1[10];
        __int16 v23 = (unsigned int *)(*(void *)(*(void *)(v22 + 8)
                                         + 8 * ((v21 % *(_DWORD *)(v22 + 32)) >> *(_WORD *)(v22 + 44)))
                             + 4 * ((v21 % *(_DWORD *)(v22 + 32)) & ~(-1 << *(_WORD *)(v22 + 44))));
        while (1)
        {
          unsigned int v24 = *v23;
          if ((*v23 & 0x80000000) != 0) {
            break;
          }
          uint64_t v25 = a1[11];
          uint64_t v26 = *(void *)(v25 + 8);
          LOBYTE(v25) = *(_WORD *)(v25 + 44);
          uint64_t v27 = v24 >> v25;
          uint64_t v28 = v24 & ~(-1 << v25);
          __int16 v23 = (unsigned int *)(*(void *)(v26 + 8 * v27) + 16 * v28);
          if (_FSTIncrementalMinimizationPrefixEqual((uint64_t)a1, (uint64_t)&v43, (uint64_t)v23)) {
            goto LABEL_11;
          }
        }
        if (v24 == -1)
        {
          uint64_t v11 = v41;
          uint64_t v9 = v42;
          goto LABEL_28;
        }
        uint64_t v29 = a1[11];
        uint64_t v26 = *(void *)(v29 + 8);
        LOBYTE(v29) = *(_WORD *)(v29 + 44);
        uint64_t v27 = v24 >> v29;
        uint64_t v28 = v24 & ~(-1 << v29);
LABEL_11:
        unsigned int v30 = *(_DWORD *)(*(void *)(v26 + 8 * v27) + 16 * v28 + 8);
        unsigned int v31 = *(_DWORD *)(*(void *)(v40 + 8 * (v30 >> v18)) + 20 * (v30 & v19) + 4);
        *(_DWORD *)(a4 + 4 * v13) = v31;
        if (v13 == v37)
        {
          uint64_t v11 = v41;
          uint64_t v9 = v42;
          if (v31 == 1
            || (*(_DWORD *)(*(void *)(*(void *)(a1[9] + 8) + 8 * (v31 >> *(_WORD *)(a1[9] + 44)))
                          + 8 * (v31 & ~(-1 << *(_WORD *)(a1[9] + 44)))
                          + 4) & 0x80000000) != 0)
          {
            *a5 = 1;
          }
        }
        else
        {
          uint64_t v11 = v41;
          uint64_t v9 = v42;
          if (v31 != 1)
          {
            unsigned int v32 = (((unint64_t)v10 - v42) >> 3) + 1;
            if (v32 > v41)
            {
              unsigned int v33 = 2 * v41;
              if (2 * (int)v41 >= (v41 + 100)) {
                unsigned int v33 = v41 + 100;
              }
              if (v33 > v32) {
                unsigned int v32 = v33;
              }
              if (v32 <= 8) {
                uint64_t v11 = 8;
              }
              else {
                uint64_t v11 = v32;
              }
              uint64_t v34 = OOCAllocator_Realloc(v35, v42, 8 * v11, &v46);
              if (v46) {
                return v46;
              }
              uint64_t v9 = v34;
              uint64_t v10 = (unsigned int *)(v34 + (((unint64_t)v10 - v42) & 0x7FFFFFFF8));
            }
            *uint64_t v10 = v31;
            v10[1] = v13 + 1;
            v10 += 2;
          }
        }
LABEL_28:
        if ((unsigned int *)v9 != v10) {
          continue;
        }
        if (v9) {
          OOCAllocator_Free(v35, v9);
        }
      }
      break;
    }
  }
  return v46;
}

uint64_t FSTIncrementalMinimization_GarbageCollection(uint64_t *a1, char **a2)
{
  unsigned int v227 = 0;
  uint64_t v2 = a1[3];
  uint64_t v223 = a1;
  if (*((_DWORD *)a1 + 34))
  {
    uint64_t v222 = a1[3];
    unsigned int v3 = (char *)OOCAllocator_Malloc(v2, 4, &v227);
    if (v227) {
      return v227;
    }
    unsigned int v4 = v3;
    *(_DWORD *)unsigned int v3 = 0;
    uint64_t v5 = v3 + 4;
    a1 = v223;
    int v6 = ***(_DWORD ***)(v223[9] + 8);
    if (v6 == -1)
    {
      uint64_t v11 = 0;
      uint64_t v10 = 0;
      uint64_t v12 = 0;
    }
    else
    {
      uint64_t v7 = v5;
      uint64_t v8 = v4;
      uint64_t v9 = OOCAllocator_Realloc(v222, 0, 96, &v227);
      if (v227) {
        return v227;
      }
      unsigned int v4 = v8;
      uint64_t v10 = v9;
      uint64_t v11 = (unsigned int *)(v9 + 12);
      *(void *)uint64_t v9 = 0xFFFFFFFF00000000;
      *(_DWORD *)(v9 + 8) = v6;
      uint64_t v12 = 8;
      a1 = v223;
      uint64_t v5 = v7;
    }
    if ((unsigned int *)v10 != v11)
    {
      int v13 = 0;
      int v14 = 0;
      uint64_t v15 = 1;
      int v16 = v11;
      while (1)
      {
        unsigned int v18 = *(v16 - 3);
        v16 -= 3;
        unsigned int v17 = v18;
        unsigned int v19 = v16[2];
        uint64_t v20 = a1[8];
        uint64_t v21 = *(void *)(v20 + 8);
        LOBYTE(v20) = *(_WORD *)(v20 + 44);
        uint64_t v22 = *(void *)(v21 + 8 * (v19 >> v20));
        unsigned int v23 = v19 & ~(-1 << v20);
        if (v14)
        {
          unsigned int v24 = (unsigned int *)(v22 + 20 * v23);
          if (v13)
          {
            unsigned int v25 = v16[1];
            int64_t v26 = v5 - v4;
            LODWORD(v27) = ((unint64_t)(v5 - v4) >> 2) + 1;
            if (v27 > v15)
            {
              unsigned int v220 = v16[1];
              uint64_t v28 = v12;
              unsigned int v29 = 2 * v15;
              if (2 * (int)v15 >= (v15 + 100)) {
                unsigned int v29 = v15 + 100;
              }
              if (v29 > v27) {
                LODWORD(v27) = v29;
              }
              if (v27 <= 8) {
                uint64_t v27 = 8;
              }
              else {
                uint64_t v27 = v27;
              }
              uint64_t v30 = v27;
              unsigned int v31 = v17;
              uint64_t v32 = v10;
              uint64_t v33 = OOCAllocator_Realloc(v222, (uint64_t)v4, 4 * v27, &v227);
              if (v227) {
                return v227;
              }
              uint64_t v10 = v32;
              unsigned int v17 = v31;
              unsigned int v4 = (char *)v33;
              uint64_t v5 = (char *)(v33 + (v26 & 0x3FFFFFFFCLL));
              a1 = v223;
              uint64_t v15 = v30;
              uint64_t v12 = v28;
              unsigned int v24 = (unsigned int *)(v22 + 20 * v23);
              unsigned int v25 = v220;
            }
            uint64_t v34 = v22 + 20 * v23;
            int v36 = *(_DWORD *)(v34 + 8);
            uint64_t v35 = v34 + 8;
            *(_DWORD *)uint64_t v5 = v36;
            v5 += 4;
            ++*(_DWORD *)v4;
            uint64_t v37 = a1[9];
            uint64_t v38 = *(void *)(v37 + 8);
            __int16 v39 = *(_WORD *)(v37 + 44);
            uint64_t v40 = (unsigned int *)(*(void *)(v38 + 8 * (v17 >> v39)) + 8 * (v17 & ~(-1 << v39)));
            if (v19 == *v40)
            {
              *uint64_t v40 = *v24;
            }
            else if (v25 != -1)
            {
              *(_DWORD *)(*(void *)(*(void *)(a1[8] + 8) + 8 * (v25 >> *(_WORD *)(a1[8] + 44)))
                        + 20 * (v25 & ~(-1 << *(_WORD *)(a1[8] + 44)))) = *v24;
            }
            unsigned int v53 = *(_DWORD *)(v22 + 20 * v23 + 4);
            if (v53 != 1)
            {
              uint64_t v54 = *(void *)(v38 + 8 * (v53 >> v39)) + 8 * (v53 & ~(-1 << v39));
              *(_DWORD *)(v54 + 4) = ((*(_DWORD *)(v54 + 4) & 0x7FFFFFFF) - 1) | *(_DWORD *)(v54 + 4) & 0x80000000;
            }
            *(void *)uint64_t v35 = -1;
            *(_DWORD *)(v35 + 8) = -1;
          }
          unsigned int v55 = *v24;
          if (*v24 == -1)
          {
            int v14 = 1;
          }
          else
          {
            unint64_t v56 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v16 - v10) >> 2);
            LODWORD(v57) = v56 + 1;
            if ((int)v56 + 1 > v12)
            {
              uint64_t v58 = v15;
              uint64_t v59 = v5;
              unsigned int v60 = 2 * v12;
              if (2 * (int)v12 >= (v12 + 100)) {
                unsigned int v60 = v12 + 100;
              }
              if (v60 > v57) {
                LODWORD(v57) = v60;
              }
              if (v57 <= 8) {
                uint64_t v57 = 8;
              }
              else {
                uint64_t v57 = v57;
              }
              uint64_t v61 = v57;
              unsigned int v62 = v4;
              uint64_t v63 = OOCAllocator_Realloc(v222, v10, 12 * v57, &v227);
              if (v227) {
                return v227;
              }
              unsigned int v4 = v62;
              uint64_t v10 = v63;
              int v16 = (unsigned int *)(v63 + 12 * v56);
              a1 = v223;
              uint64_t v5 = v59;
              uint64_t v15 = v58;
              uint64_t v12 = v61;
            }
            int v14 = 0;
            int v13 = 0;
            unsigned int *v16 = v17;
            v16[1] = v19;
            _OWORD v16[2] = v55;
            v16 += 3;
          }
        }
        else
        {
          uint64_t v41 = a1[9];
          unsigned int v42 = *(_DWORD *)(v22 + 20 * v23 + 4);
          char v43 = *(_WORD *)(v41 + 44);
          uint64_t v44 = *(void *)(*(void *)(v41 + 8) + 8 * (v42 >> v43));
          unsigned int v45 = *(_DWORD *)(v44 + 8 * (v42 & ~(-1 << v43)));
          if (v45 == -1)
          {
            if (v42 != 1 && *(int *)(v44 + 8 * (v42 & ~(-1 << v43)) + 4) >= 0) {
              int v13 = 1;
            }
            int v14 = 1;
            int v16 = v11;
          }
          else
          {
            unint64_t v46 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v11 - v10) >> 2);
            if ((int)v46 + 1 > v12)
            {
              uint64_t v47 = v15;
              int v48 = v5;
              LODWORD(v49) = 2 * v12;
              if (2 * (int)v12 >= (v12 + 100)) {
                LODWORD(v49) = v12 + 100;
              }
              if (v49 <= (int)v46 + 1) {
                LODWORD(v49) = v46 + 1;
              }
              if (v49 <= 8) {
                uint64_t v49 = 8;
              }
              else {
                uint64_t v49 = v49;
              }
              uint64_t v50 = v49;
              __int16 v51 = v4;
              uint64_t v52 = OOCAllocator_Realloc(v222, v10, 12 * v49, &v227);
              if (v227) {
                return v227;
              }
              unsigned int v4 = v51;
              uint64_t v10 = v52;
              uint64_t v11 = (unsigned int *)(v52 + 12 * v46);
              a1 = v223;
              uint64_t v5 = v48;
              uint64_t v15 = v47;
              uint64_t v12 = v50;
            }
            int v14 = 0;
            int v16 = v11 + 3;
            *uint64_t v11 = v42;
            v11[1] = -1;
            v11[2] = v45;
          }
        }
        uint64_t v11 = v16;
        if ((unsigned int *)v10 == v16) {
          goto LABEL_60;
        }
      }
    }
    int v16 = v11;
LABEL_60:
    uint64_t v2 = v222;
    if (v16)
    {
      unsigned int v64 = v4;
      OOCAllocator_Free(v222, (uint64_t)v16);
      unsigned int v4 = v64;
      a1 = v223;
    }
    *((_DWORD *)a1 + 34) = 0;
    if (*(int *)v4 <= 0)
    {
      OOCAllocator_Free(v222, (uint64_t)v4);
      a1 = v223;
      unsigned int v4 = 0;
    }
    *a2 = v4;
  }
  if (*((_DWORD *)a1 + 33))
  {
    uint64_t v224 = 0;
    unsigned int v225 = 0;
    uint64_t v226 = 0;
    uint64_t v65 = v2;
    unsigned int v227 = dpmemblock_Create(v2, 4, 0x400u, (uint64_t *)&v226);
    if (!v227)
    {
      int v67 = *(_DWORD *)(v223[9] + 32);
      if (!v67) {
        goto LABEL_74;
      }
      int v68 = v67 - 1;
      do
      {
        unsigned int NewElement = dpmemblock_GetNewElement((uint64_t)v226, &v224, 0);
        unsigned int v227 = NewElement;
        BOOL v70 = v68-- != 0;
      }
      while (v70 && !NewElement);
      if (!NewElement)
      {
LABEL_74:
        uint64_t v71 = v226;
        if (*((_DWORD *)v226 + 8))
        {
          unsigned int v72 = 0;
          uint64_t v73 = v226[1];
          __int16 v74 = *((_WORD *)v226 + 22);
          do
          {
            uint64_t v75 = *(void *)(v73 + 8 * (v72 >> v74));
            if (!v75) {
              break;
            }
            *(_DWORD *)(v75 + 4 * (v72++ & ~(-1 << v74))) = 0;
          }
          while (v72 < *((_DWORD *)v71 + 8));
        }
        uint64_t v224 = 0;
        unsigned int v225 = 0;
        unsigned int v227 = dpmemblock_Create(v65, 4, 0x400u, (uint64_t *)&v225);
        if (!v227)
        {
          int v76 = *(_DWORD *)(v223[8] + 32);
          if (!v76) {
            goto LABEL_85;
          }
          int v77 = v76 - 1;
          do
          {
            unsigned int v78 = dpmemblock_GetNewElement((uint64_t)v225, &v224, 0);
            unsigned int v227 = v78;
            BOOL v70 = v77-- != 0;
          }
          while (v70 && !v78);
          if (!v78)
          {
LABEL_85:
            unsigned int v79 = v225;
            if (*((_DWORD *)v225 + 8))
            {
              unsigned int v80 = 0;
              uint64_t v81 = v225[1];
              __int16 v82 = *((_WORD *)v225 + 22);
              do
              {
                uint64_t v83 = *(void *)(v81 + 8 * (v80 >> v82));
                if (!v83) {
                  break;
                }
                *(_DWORD *)(v83 + 4 * (v80++ & ~(-1 << v82))) = -1;
              }
              while (v80 < *((_DWORD *)v79 + 8));
            }
            uint64_t v84 = v223;
            uint64_t v85 = v223[8];
            unsigned int v86 = *(_DWORD *)(v85 + 32);
            if (v86 >= 2)
            {
              int v87 = 0;
              uint64_t v88 = *(void *)(v85 + 8);
              __int16 v89 = *(_WORD *)(v85 + 44);
              int v90 = ~(-1 << v89);
              for (unsigned int i = 1; i < v86; ++i)
              {
                uint64_t v92 = *(void *)(v88 + 8 * (i >> v89));
                unsigned int v93 = i & v90;
                if (*(_DWORD *)(v92 + 20 * (i & v90) + 8) == -1
                  && *(_DWORD *)(v92 + 20 * v93 + 12) == -1
                  && *(_DWORD *)(v92 + 20 * v93 + 16) == -1)
                {
                  ++v87;
                }
                else
                {
                  *(_DWORD *)(*(void *)(v79[1] + 8 * (i >> *((_WORD *)v79 + 22)))
                            + 4 * (i & ~(-1 << *((_WORD *)v79 + 22)))) = i - v87;
                  unsigned int v86 = *(_DWORD *)(v85 + 32);
                }
              }
            }
            unsigned int v94 = v226;
            unsigned int v95 = (_DWORD **)v226[1];
            *unsigned int *v95 = 0;
            __int16 v96 = *((_WORD *)v94 + 22);
            v95[1uLL >> v96][((-1 << v96) & 1) == 0] = 1;
            uint64_t v97 = v223[9];
            unsigned int v98 = *(_DWORD *)(v97 + 32);
            if (v98 >= 3)
            {
              int v99 = 0;
              uint64_t v100 = *(void *)(v97 + 8);
              __int16 v101 = *(_WORD *)(v97 + 44);
              for (unsigned int j = 2; j < v98; ++j)
              {
                if (*(_DWORD *)(*(void *)(v100 + 8 * (j >> v101)) + 8 * (j & ~(-1 << v101))) == -1)
                {
                  ++v99;
                }
                else
                {
                  v95[j >> v96][j & ~(-1 << v96)] = j - v99;
                  unsigned int v98 = *(_DWORD *)(v97 + 32);
                }
              }
            }
            unsigned int v103 = *(_DWORD *)(v85 + 32);
            unsigned int v104 = 1;
            if (v103 >= 2)
            {
              for (unsigned int k = 1; k < v103; ++k)
              {
                uint64_t v106 = v79[1];
                __int16 v107 = *((_WORD *)v79 + 22);
                unsigned int v108 = *(_DWORD *)(*(void *)(v106 + 8 * (k >> v107)) + 4 * (k & ~(-1 << v107)));
                if (v108 != -1)
                {
                  uint64_t v109 = *(void *)(v85 + 8);
                  __int16 v110 = *(_WORD *)(v85 + 44);
                  uint64_t v111 = *(void *)(v109 + 8 * (k >> v110));
                  int v112 = -1;
                  unsigned int v113 = k & ~(-1 << v110);
                  unsigned int v114 = *(_DWORD *)(v111 + 20 * v113);
                  if (v114 != -1) {
                    int v112 = *(_DWORD *)(*(void *)(v106 + 8 * (v114 >> v107)) + 4 * (v114 & ~(-1 << v107)));
                  }
                  uint64_t v115 = *(void *)(v109 + 8 * (v108 >> v110));
                  unsigned int v116 = v108 & ~(-1 << v110);
                  *(_DWORD *)(v115 + 20 * v116) = v112;
                  uint64_t v117 = v111 + 20 * v113;
                  unsigned int v118 = *(_DWORD *)(*(void *)(v94[1]
                                               + 8 * (*(_DWORD *)(v117 + 4) >> *((_WORD *)v94 + 22)))
                                   + 4 * (*(_DWORD *)(v117 + 4) & ~(-1 << *((_WORD *)v94 + 22))));
                  if (v118 <= 1) {
                    unsigned int v118 = 1;
                  }
                  uint64_t v119 = v115 + 20 * v116;
                  *(_DWORD *)(v119 + 4) = v118;
                  uint64_t v120 = *(void *)(v117 + 8);
                  *(_DWORD *)(v119 + 16) = *(_DWORD *)(v117 + 16);
                  *(void *)(v119 + 8) = v120;
                  ++v104;
                  uint64_t v85 = v223[8];
                }
                unsigned int v103 = *(_DWORD *)(v85 + 32);
              }
            }
            uint64_t v224 = 0;
            if (v104 <= v103)
            {
              *(_DWORD *)(v85 + 32) = v104;
            }
            else
            {
              if (v227) {
                return v227;
              }
              unsigned int v121 = v103 + 1;
              do
              {
                unsigned int v122 = dpmemblock_GetNewElement(v84[8], &v224, 0);
                uint64_t v84 = v223;
                unsigned int v227 = v122;
                if (v121 >= v104) {
                  break;
                }
                ++v121;
              }
              while (!v122);
              if (v122) {
                return v227;
              }
            }
            uint64_t v123 = v84[9];
            uint64_t v124 = *(unsigned int ***)(v123 + 8);
            unsigned int v125 = **v124;
            if (v125 != -1) {
              **uint64_t v124 = *(_DWORD *)(*(void *)(v225[1] + 8 * (v125 >> *((_WORD *)v225 + 22)))
            }
                                 + 4 * (v125 & ~(-1 << *((_WORD *)v225 + 22))));
            unsigned int v126 = *(_DWORD *)(v123 + 32);
            if (v126 < 3)
            {
              unsigned int v130 = 2;
            }
            else
            {
              unsigned int v127 = v225;
              uint64_t v128 = v226[1];
              __int16 v129 = *((_WORD *)v226 + 22);
              unsigned int v130 = 2;
              for (unsigned int m = 2; m != v126; ++m)
              {
                unsigned int v132 = *(_DWORD *)(*(void *)(v128 + 8 * (m >> v129)) + 4 * (m & ~(-1 << v129)));
                if (v132)
                {
                  __int16 v133 = *(_WORD *)(v123 + 44);
                  unsigned int v134 = v124[m >> v133];
                  int v135 = -1;
                  int v136 = -1 << v133;
                  uint64_t v137 = m & ~(-1 << v133);
                  unsigned int v138 = v134[2 * v137];
                  if (v138 != -1) {
                    int v135 = *(_DWORD *)(*(void *)(v127[1] + 8 * (v138 >> *((_WORD *)v127 + 22)))
                  }
                                     + 4 * (v138 & ~(-1 << *((_WORD *)v127 + 22))));
                  uint64_t v139 = v124[v132 >> v133];
                  uint64_t v140 = v132 & ~v136;
                  v139[2 * v140] = v135;
                  v139[2 * v140 + 1] = v134[2 * v137 + 1];
                  ++v130;
                }
              }
            }
            uint64_t v224 = 0;
            if (v130 <= v126)
            {
              *(_DWORD *)(v123 + 32) = v130;
            }
            else
            {
              if (v227) {
                return v227;
              }
              unsigned int v141 = v126 + 1;
              do
              {
                unsigned int v142 = dpmemblock_GetNewElement(v84[9], &v224, 0);
                uint64_t v84 = v223;
                unsigned int v227 = v142;
                if (v141 >= v130) {
                  break;
                }
                ++v141;
              }
              while (!v142);
              if (v142) {
                return v227;
              }
            }
            uint64_t v143 = v84[11];
            unsigned int v144 = *(_DWORD *)(v143 + 32);
            if (v144)
            {
              unsigned int v145 = 0;
              unsigned int v146 = 0;
              uint64_t v147 = *(void *)(v143 + 8);
              __int16 v148 = *(_WORD *)(v143 + 44);
              int v149 = ~(-1 << v148);
              unsigned int v150 = v225;
              uint64_t v151 = v226[1];
              __int16 v152 = *((_WORD *)v226 + 22);
              do
              {
                uint64_t v153 = *(void *)(v147 + 8 * (v146 >> v148));
                uint64_t v154 = v146 & v149;
                unsigned int v155 = *(_DWORD *)(v153 + 16 * v154 + 4);
                int v156 = *(_DWORD *)(*(void *)(v151 + 8 * (v155 >> v152)) + 4 * (v155 & ~(-1 << v152)));
                if (v156)
                {
                  unsigned int v157 = *(_DWORD *)(v153 + 16 * v154 + 8);
                  __int16 v158 = *((_WORD *)v150 + 22);
                  uint64_t v159 = *(void *)(v150[1] + 8 * (v157 >> v158));
                  uint64_t v160 = v157 & ~(-1 << v158);
                  if (*(_DWORD *)(v159 + 4 * v160) != -1)
                  {
                    uint64_t v161 = *(void *)(v147 + 8 * (v145 >> v148));
                    uint64_t v162 = v145 & v149;
                    uint64_t v163 = v161 + 16 * v162;
                    *(_DWORD *)(v163 + 4) = v156;
                    unsigned int v164 = (_DWORD *)(v163 + 4);
                    if (v157 == -1) {
                      int v165 = -1;
                    }
                    else {
                      int v165 = *(_DWORD *)(v159 + 4 * v160);
                    }
                    *(_DWORD *)(v161 + 16 * v162 + 8) = v165;
                    *unsigned int v164 = *(_DWORD *)(v153 + 16 * v154 + 12);
                    ++v145;
                  }
                }
                ++v146;
              }
              while (v144 != v146);
              uint64_t v224 = 0;
              if (v145 > v144)
              {
                if (v227) {
                  return v227;
                }
                unsigned int v166 = v144 + 1;
                do
                {
                  unsigned int v167 = dpmemblock_GetNewElement(v84[11], &v224, 0);
                  uint64_t v84 = v223;
                  unsigned int v227 = v167;
                  if (v166 >= v145) {
                    break;
                  }
                  ++v166;
                }
                while (!v167);
                if (v167) {
                  return v227;
                }
LABEL_158:
                __FSTIncrementalMinimization_SetExactMatchMode((uint64_t)v84, 1);
                uint64_t v168 = (uint64_t)v223;
                unsigned int v227 = 0;
                uint64_t v169 = v223[10];
                unsigned int v170 = *(_DWORD *)(v169 + 32);
                if (v170)
                {
                  unsigned int v171 = 0;
                  uint64_t v172 = *(void *)(v169 + 8);
                  __int16 v173 = *(_WORD *)(v169 + 44);
                  do
                  {
                    uint64_t v174 = *(void *)(v172 + 8 * (v171 >> v173));
                    if (!v174) {
                      break;
                    }
                    *(_DWORD *)(v174 + 4 * (v171++ & ~(-1 << v173))) = -1;
                  }
                  while (v171 < *(_DWORD *)(v169 + 32));
                }
                uint64_t v175 = v223[11];
                unsigned int v176 = *(_DWORD *)(v175 + 32);
                if (v176)
                {
                  unsigned int v177 = 0;
                  uint64_t v178 = *(void *)(v175 + 8);
                  __int16 v179 = *(_WORD *)(v175 + 44);
                  do
                  {
                    uint64_t v180 = *(void *)(v178 + 8 * (v177 >> v179));
                    if (!v180) {
                      break;
                    }
                    uint64_t v181 = v177 & ~(-1 << v179);
                    unsigned int v182 = (_DWORD *)(v180 + 16 * v181);
                    if (((*v182 + 1) & 0x40000000) == 0)
                    {
                      if (v227) {
                        return v227;
                      }
                      uint64_t v183 = v180 + 16 * v181;
                      int v184 = *(_DWORD *)(v183 + 4);
                      uint64_t v185 = *(void *)(*(void *)(v223[8] + 8)
                                       + 8 * (*(_DWORD *)(v183 + 8) >> *(_WORD *)(v223[8] + 44)))
                           + 20 * (*(_DWORD *)(v183 + 8) & ~(-1 << *(_WORD *)(v223[8] + 44)));
                      LODWORD(v185) = (*(_DWORD *)(v185 + 16)
                                     + 2239 * (*(_DWORD *)(v185 + 12) + 2239 * (*(_DWORD *)(v185 + 8) + 2239 * v184)))
                                    % v170;
                      char v186 = *(_WORD *)(v169 + 44);
                      uint64_t v187 = *(void *)(*(void *)(v169 + 8) + 8 * (v185 >> v186));
                      LODWORD(v185) = v185 & ~(-1 << v186);
                      *unsigned int v182 = *(_DWORD *)(v187 + 4 * v185);
                      *(_DWORD *)(v187 + 4 * v185) = v177;
                      unsigned int v176 = *(_DWORD *)(v175 + 32);
                    }
                    ++v177;
                  }
                  while (v177 < v176);
                }
                uint64_t v188 = v223[14];
                unsigned int v189 = *(_DWORD *)(v188 + 32);
                if (v189)
                {
                  unsigned int v190 = 0;
                  unsigned int v191 = 0;
                  uint64_t v192 = *(void *)(v188 + 8);
                  __int16 v193 = *(_WORD *)(v188 + 44);
                  int v194 = ~(-1 << v193);
                  uint64_t v195 = v226[1];
                  __int16 v196 = *((_WORD *)v226 + 22);
                  do
                  {
                    unsigned int v197 = *(_DWORD *)(*(void *)(v192 + 8 * (v191 >> v193)) + 8 * (v191 & v194) + 4);
                    int v198 = *(_DWORD *)(*(void *)(v195 + 8 * (v197 >> v196)) + 4 * (v197 & ~(-1 << v196)));
                    if (v198)
                    {
                      *(_DWORD *)(*(void *)(v192 + 8 * (v190 >> v193)) + 8 * (v190 & v194) + 4) = v198;
                      ++v190;
                    }
                    ++v191;
                  }
                  while (v189 != v191);
                  char v199 = v223 + 13;
                  uint64_t v224 = 0;
                  if (v190 > v189)
                  {
                    if (v227) {
                      return v227;
                    }
                    unsigned int v200 = v189 + 1;
                    do
                    {
                      unsigned int v201 = dpmemblock_GetNewElement(*(void *)(v168 + 112), &v224, 0);
                      uint64_t v168 = (uint64_t)v223;
                      unsigned int v227 = v201;
                      if (v200 >= v190) {
                        break;
                      }
                      ++v200;
                    }
                    while (!v201);
                    if (v201) {
                      return v227;
                    }
                    goto LABEL_183;
                  }
                }
                else
                {
                  unsigned int v190 = 0;
                  char v199 = v223 + 13;
                }
                *(_DWORD *)(v188 + 32) = v190;
LABEL_183:
                uint64_t v202 = *v199;
                unsigned int v203 = *(_DWORD *)(*v199 + 32);
                if (v203)
                {
                  unsigned int v204 = 0;
                  uint64_t v205 = *(void *)(v202 + 8);
                  __int16 v206 = *(_WORD *)(v202 + 44);
                  do
                  {
                    uint64_t v207 = *(void *)(v205 + 8 * (v204 >> v206));
                    if (!v207) {
                      break;
                    }
                    *(_DWORD *)(v207 + 4 * (v204++ & ~(-1 << v206))) = -1;
                  }
                  while (v204 < *(_DWORD *)(v202 + 32));
                }
                uint64_t v208 = *(void *)(v168 + 112);
                unsigned int v209 = *(_DWORD *)(v208 + 32);
                if (v209)
                {
                  unsigned int v210 = 0;
                  uint64_t v211 = *(void *)(v208 + 8);
                  __int16 v212 = *(_WORD *)(v208 + 44);
                  do
                  {
                    uint64_t v213 = *(void *)(v211 + 8 * (v210 >> v212));
                    if (!v213) {
                      break;
                    }
                    uint64_t v214 = (_DWORD *)(v213 + 8 * (v210 & ~(-1 << v212)));
                    if (((*v214 + 1) & 0x40000000) == 0)
                    {
                      unsigned int v215 = _FSTIncrementalMinimizationSuffixHash(v168, (uint64_t)v214);
                      uint64_t v168 = (uint64_t)v223;
                      if (v227) {
                        return v227;
                      }
                      char v216 = *(_WORD *)(v202 + 44);
                      uint64_t v217 = *(void *)(*(void *)(v202 + 8) + 8 * ((v215 % v203) >> v216));
                      unsigned int v218 = (v215 % v203) & ~(-1 << v216);
                      *uint64_t v214 = *(_DWORD *)(v217 + 4 * v218);
                      *(_DWORD *)(v217 + 4 * v218) = v210;
                      unsigned int v209 = *(_DWORD *)(v208 + 32);
                    }
                    ++v210;
                  }
                  while (v210 < v209);
                }
                uint64_t v219 = v168;
                dpmemblock_Free(v226);
                dpmemblock_Free(v225);
                *(_DWORD *)(v219 + 132) = 0;
                return v227;
              }
            }
            else
            {
              unsigned int v145 = 0;
            }
            *(_DWORD *)(v143 + 32) = v145;
            goto LABEL_158;
          }
        }
      }
    }
  }
  return v227;
}

uint64_t FSTIncrementalMinimization_GetFinalStateWeight(uint64_t a1, unsigned int a2, int *a3)
{
  if (*(int *)(*(void *)(*(void *)(*(void *)(a1 + 72) + 8)
                          + 8 * (a2 >> *(_WORD *)(*(void *)(a1 + 72) + 44)))
              + 8 * (a2 & ~(-1 << *(_WORD *)(*(void *)(a1 + 72) + 44)))
              + 4) >= 0)
    int v3 = 0x7FFFFFFF;
  else {
    int v3 = 0;
  }
  *a3 = v3;
  return 0;
}

uint64_t FSTIncrementalMinimization_GetInitialStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = 0;
  return 0;
}

uint64_t FSTIncrementalMinimization_GetMaxStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(*(void *)(a1 + 72) + 32) - 1;
  return 0;
}

uint64_t FSTIncrementalMinimization_GetMemoryInfo(uint64_t *a1)
{
  v17[0] = 0;
  v17[1] = 0;
  cstdlib_memset(v17, 0, 0x10uLL);
  int UnitSize = dpmemblock_GetUnitSize(a1[8]);
  uint64_t v3 = a1[9];
  v17[0] += (*(_DWORD *)(a1[8] + 36) * UnitSize) + 8 * *(unsigned int *)(a1[8] + 28) + 48;
  int v4 = dpmemblock_GetUnitSize(v3);
  uint64_t v5 = a1[10];
  v17[0] += (*(_DWORD *)(a1[9] + 36) * v4) + 8 * *(unsigned int *)(a1[9] + 28) + 48;
  int v6 = dpmemblock_GetUnitSize(v5);
  uint64_t v7 = a1[10];
  uint64_t v8 = (*(_DWORD *)(v7 + 36) * v6);
  uint64_t v9 = *(unsigned int *)(v7 + 28);
  int v10 = dpmemblock_GetUnitSize(a1[11]);
  v17[0] += v8 + (*(_DWORD *)(a1[11] + 36) * v10) + 8 * (*(unsigned int *)(a1[11] + 28) + v9) + 96;
  int v11 = dpmemblock_GetUnitSize(a1[13]);
  uint64_t v12 = a1[13];
  uint64_t v13 = (*(_DWORD *)(v12 + 36) * v11);
  uint64_t v14 = *(unsigned int *)(v12 + 28);
  int v15 = dpmemblock_GetUnitSize(a1[14]);
  return v13 + (*(_DWORD *)(a1[14] + 36) * v15) + v17[0] + 8 * (*(unsigned int *)(a1[14] + 28) + v14) + 96;
}

uint64_t FSTIncrementalMinimization_GetStateFlags(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  *a3 = *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 72) + 8)
                              + 8 * (a2 >> *(_WORD *)(*(void *)(a1 + 72) + 44)))
                  + 8 * (a2 & ~(-1 << *(_WORD *)(*(void *)(a1 + 72) + 44)))
                  + 4) & 0x80000000 | 0x40000000;
  return 0;
}

uint64_t FSTIncrementalMinimization_RemoveSequences(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int a4, int a5, int *a6, void *a7)
{
  uint64_t v11 = a1;
  __FSTIncrementalMinimization_SetExactMatchMode(a1, a5);
  unsigned int v166 = a3;
  if (!*a3) {
    return 0;
  }
  uint64_t v12 = 0;
  uint64_t v183 = a4;
  uint64_t v170 = 12 * a4;
  unsigned int v172 = a4 - 1;
  uint64_t v162 = a2 + 8;
  int v173 = a4;
  uint64_t v189 = v11;
  __int16 v158 = a7;
  uint64_t v160 = a2;
LABEL_3:
  v190[0] = 0;
  v190[1] = 0;
  uint64_t v13 = **(void **)(*(void *)(v11 + 64) + 8);
  uint64_t v163 = v12;
  uint64_t v14 = a2 + 12 * v12;
  int v15 = *(_DWORD *)(v14 + 8);
  *(void *)(v13 + 8) = *(void *)v14;
  *(_DWORD *)(v13 + 16) = v15;
  int v16 = **(_DWORD ***)(*(void *)(v11 + 64) + 8);
  uint64_t v17 = *(void *)(v11 + 80);
  unsigned int v161 = (v16[4] + 2239 * (v16[3] + 2239 * v16[2])) % *(_DWORD *)(v17 + 32);
  unsigned int v18 = *(_DWORD *)(*(void *)(*(void *)(v17 + 8) + 8 * (v161 >> *(_WORD *)(v17 + 44)))
                  + 4 * (v161 & ~(-1 << *(_WORD *)(v17 + 44))));
  if ((v18 & 0x80000000) != 0) {
    goto LABEL_146;
  }
LABEL_4:
  uint64_t v19 = *(void *)(v11 + 88);
  uint64_t v20 = *(void *)(v19 + 8);
  LOBYTE(v19) = *(_WORD *)(v19 + 44);
  uint64_t v21 = *(void *)(v20 + 8 * (v18 >> v19));
  uint64_t v22 = v18 & ~(-1 << v19);
  unsigned int v23 = (unsigned int *)(v21 + 16 * v22);
  unsigned int v18 = *v23;
  if (v23[3] < a4) {
    goto LABEL_138;
  }
  unsigned int v164 = *v23;
  if (a5)
  {
    if (!_FSTIncrementalMinimizationPrefixEqual(v11, (uint64_t)v190, (uint64_t)v23)) {
      goto LABEL_137;
    }
  }
  else if (!_FSTIncrementalMinimizationPrefixFuzzyEqual(v11, (uint64_t)v190, (uint64_t)v23))
  {
LABEL_137:
    unsigned int v18 = v164;
    goto LABEL_138;
  }
  int v159 = *a6;
  unsigned int v191 = 0;
  unsigned int v24 = (_DWORD *)*a7;
  uint64_t v25 = v21 + 16 * v22;
  uint64_t v26 = *(unsigned int *)(v25 + 4);
  uint64_t v176 = *(void *)(v11 + 24);
  uint64_t v27 = (_DWORD *)OOCAllocator_Malloc(v176, v170, &v191);
  uint64_t result = v191;
  if (!v191)
  {
    int v29 = *(_DWORD *)(v25 + 8);
    uint64_t v30 = *(void *)(v11 + 72);
    char v31 = *(_WORD *)(v30 + 44);
    uint64_t v32 = *(void *)(*(void *)(v30 + 8) + 8 * (v26 >> v31));
    int v33 = -1;
    for (unsigned int i = *(_DWORD *)(v32 + 8 * (v26 & ~(-1 << v31)));
          i != v29;
          unsigned int i = *(_DWORD *)(*(void *)(*(void *)(*(void *)(v11 + 64) + 8)
                                    + 8 * (i >> *(_WORD *)(*(void *)(v11 + 64) + 44)))
                        + 20 * (i & ~(-1 << *(_WORD *)(*(void *)(v11 + 64) + 44)))))
    {
      int v33 = i;
      if (i == -1) {
        break;
      }
    }
    *uint64_t v27 = v26;
    v27[1] = v33;
    v27[2] = v29;
    uint64_t v35 = OOCAllocator_Realloc(v176, 0, 256, &v191);
    uint64_t result = v191;
    if (!v191)
    {
      uint64_t v168 = v24;
      *(_DWORD *)uint64_t v35 = v173;
      *(_DWORD *)(v35 + 4) = 0;
      *(void *)(v35 + 8) = v27;
      *(void *)(v35 + 16) = &v27[3 * v183];
      *(void *)(v35 + 24) = 0;
      uint64_t v174 = v35;
      uint64_t v36 = v35 + 32;
      unsigned int v171 = 8;
      uint64_t v37 = v26;
      while (1)
      {
        uint64_t v38 = *(unsigned int *)(v36 - 8);
        uint64_t v188 = *(void *)(v36 - 24);
        unsigned int v39 = *(_DWORD *)(v188 + 12 * v38 + 8);
        uint64_t v40 = *(void *)(v11 + 64);
        uint64_t v41 = *(void *)(v40 + 8);
        __int16 v42 = *(_WORD *)(v40 + 44);
        uint64_t v177 = v36 - 32;
        uint64_t v43 = *(unsigned int *)(*(void *)(v41 + 8 * (v39 >> v42)) + 20 * (v39 & ~(-1 << v42)) + 4);
        if (v38 != v172)
        {
          if (v43 == 1) {
            goto LABEL_127;
          }
          unsigned int v70 = *(_DWORD *)(*(void *)(*(void *)(*(void *)(v11 + 72) + 8)
                                      + 8 * (v43 >> *(_WORD *)(*(void *)(v11 + 72) + 44)))
                          + 8 * (v43 & ~(-1 << *(_WORD *)(*(void *)(v11 + 72) + 44))));
          if (v70 == -1)
          {
            uint64_t v37 = v43;
            goto LABEL_127;
          }
          uint64_t v71 = (v38 + 1);
          unsigned int v72 = -1;
          LOBYTE(v73) = *(_WORD *)(v40 + 44);
          do
          {
            unsigned int v74 = v72;
            unsigned int v72 = v70;
            unsigned int v75 = v166[v38];
            unsigned int v76 = v166[v71];
            if (v76 > v75)
            {
              uint64_t v77 = *(void *)(v41 + 8 * (v70 >> v73)) + 20 * (v70 & ~(-1 << v73));
              int v78 = *(_DWORD *)(v77 + 8);
              unsigned int v79 = (_DWORD *)(v77 + 12);
              unsigned int v80 = (_DWORD *)(v77 + 16);
              uint64_t v81 = (_DWORD *)(v162 + 12 * v75);
              unsigned int v82 = v76 - v75;
              while (v78 != *(v81 - 2) || *v79 != *(v81 - 1) || *v80 != *v81)
              {
                v81 += 3;
                if (!--v82) {
                  goto LABEL_52;
                }
              }
              uint64_t v83 = v43;
              uint64_t v84 = OOCAllocator_Malloc(v176, v170, &v191);
              uint64_t result = v191;
              if (v191) {
                return result;
              }
              if (v38 != -1)
              {
                uint64_t v85 = v84;
                uint64_t v86 = v188;
                uint64_t v87 = (v38 + 1);
                do
                {
                  uint64_t v88 = *(void *)v86;
                  *(_DWORD *)(v85 + 8) = *(_DWORD *)(v86 + 8);
                  *(void *)uint64_t v85 = v88;
                  v85 += 12;
                  v86 += 12;
                  --v87;
                }
                while (v87);
              }
              __int16 v89 = (_DWORD *)(v84 + 12 * v71);
              *__int16 v89 = v83;
              v89[1] = v74;
              v89[2] = v72;
              uint64_t v90 = v177 - v174;
              unsigned int v91 = ((unint64_t)(v177 - v174) >> 5) + 1;
              if (v91 <= v171)
              {
                uint64_t v94 = v177;
              }
              else
              {
                unsigned int v92 = 2 * v171;
                if (2 * v171 >= v171 + 100) {
                  unsigned int v92 = v171 + 100;
                }
                if (v92 > v91) {
                  unsigned int v91 = v92;
                }
                if (v91 <= 8) {
                  unsigned int v91 = 8;
                }
                unsigned int v171 = v91;
                uint64_t v93 = OOCAllocator_Realloc(v176, v174, 32 * v91, &v191);
                uint64_t result = v191;
                if (v191) {
                  return result;
                }
                uint64_t v174 = v93;
                uint64_t v94 = v93 + (v90 & 0x1FFFFFFFE0);
              }
              *(_DWORD *)uint64_t v94 = v173;
              *(_DWORD *)(v94 + 4) = 0;
              *(void *)(v94 + 8) = v84;
              *(void *)(v94 + 16) = v84 + 12 * v183;
              *(void *)(v94 + 24) = v71;
              uint64_t v40 = *(void *)(v189 + 64);
              uint64_t v177 = v94 + 32;
              uint64_t v43 = v83;
            }
LABEL_52:
            uint64_t v41 = *(void *)(v40 + 8);
            __int16 v73 = *(_WORD *)(v40 + 44);
            unsigned int v70 = *(_DWORD *)(*(void *)(v41 + 8 * (v72 >> v73)) + 20 * (v72 & ~(-1 << v73)));
          }
          while (v70 != -1);
          uint64_t v37 = v43;
          uint64_t v11 = v189;
LABEL_126:
          if (v188) {
            goto LABEL_127;
          }
          goto LABEL_128;
        }
        if (*(_DWORD *)(v11 + 128)
          && v43 != 1
          && (*(_DWORD *)(*(void *)(*(void *)(*(void *)(v11 + 72) + 8)
                                    + 8 * (v43 >> *(_WORD *)(*(void *)(v11 + 72) + 44)))
                        + 8 * (v43 & ~(-1 << *(_WORD *)(*(void *)(v11 + 72) + 44)))
                        + 4) & 0x80000000) == 0)
        {
          goto LABEL_127;
        }
        int v165 = *(_DWORD *)(*(void *)(v41 + 8 * (v39 >> v42)) + 20 * (v39 & ~(-1 << v42)) + 4);
        int v44 = v173;
        if (v173)
        {
          uint64_t v45 = 0;
          uint64_t v175 = *(void *)(v40 + 8);
          while (1)
          {
            uint64_t v192 = 0;
            unint64_t v46 = (unsigned int *)(v188 + 12 * v45);
            uint64_t v37 = *v46;
            unsigned int v47 = v46[2];
            if (v37)
            {
              unsigned int v186 = *v46;
              HIDWORD(v192) = *v46;
              unsigned int v48 = _FSTIncrementalMinimizationSuffixHash(v189, (uint64_t)&v192);
              uint64_t result = v191;
              if (v191) {
                return result;
              }
              unsigned int v184 = v47;
              uint64_t v49 = *(void *)(v189 + 104);
              unsigned int v180 = *(_DWORD *)(v49 + 32);
              uint64_t v181 = *(void *)(v49 + 8);
              __int16 v179 = *(_WORD *)(v49 + 44);
              int v178 = ~(-1 << v179);
              uint64_t v50 = (unsigned int *)(*(void *)(v181 + 8 * ((v48 % v180) >> v179)) + 4 * ((v48 % v180) & v178));
              while (1)
              {
                unsigned int v51 = *v50;
                if ((*v50 & 0x80000000) != 0) {
                  break;
                }
                uint64_t v52 = *(void *)(v189 + 112);
                uint64_t v53 = *(void *)(v52 + 8);
                __int16 v54 = *(_WORD *)(v52 + 44);
                uint64_t v55 = *(void *)(v53 + 8 * (v51 >> v54));
                uint64_t v56 = v51 & ~(-1 << v54);
                uint64_t v50 = (unsigned int *)(v55 + 8 * v56);
                if (_FSTIncrementalMinimizationSuffixEqual(v189, (uint64_t)&v192, (uint64_t)v50))
                {
                  int v57 = ~(-1 << v54);
                  uint64_t v58 = v189;
                  uint64_t v41 = v175;
                  goto LABEL_27;
                }
              }
              uint64_t v37 = v186;
              uint64_t v41 = v175;
              unsigned int v47 = v184;
              if (v51 == -1) {
                goto LABEL_40;
              }
              uint64_t v58 = v189;
              uint64_t v59 = *(void *)(v189 + 112);
              uint64_t v53 = *(void *)(v59 + 8);
              __int16 v54 = *(_WORD *)(v59 + 44);
              int v57 = ~(-1 << v54);
              uint64_t v56 = v51 & v57;
              uint64_t v55 = *(void *)(v53 + 8 * (v51 >> v54));
LABEL_27:
              unsigned int v60 = (int *)(v55 + 8 * v56);
              unsigned int v61 = _FSTIncrementalMinimizationSuffixHash(v58, (uint64_t)v60);
              uint64_t v62 = *(void *)(v181 + 8 * ((v61 % v180) >> v179));
              uint64_t v63 = (v61 % v180) & v178;
              unsigned int v64 = *(_DWORD *)(v62 + 4 * v63);
              unsigned int v65 = -1;
              if ((v64 & 0x80000000) != 0)
              {
                uint64_t v37 = v186;
              }
              else
              {
                uint64_t v37 = v186;
                if (v64 != v51)
                {
                  do
                  {
                    unsigned int v65 = v64;
                    unsigned int v64 = *(_DWORD *)(*(void *)(v53 + 8 * (v64 >> v54)) + 8 * (v64 & v57));
                  }
                  while ((v64 & 0x80000000) == 0 && v64 != v51);
                }
              }
              int v66 = *v60;
              int v67 = *(_DWORD *)(v189 + 120);
              *(_DWORD *)(v189 + 120) = v51;
              *unsigned int v60 = (v67 + 1) | 0x40000000;
              if ((v65 & 0x80000000) != 0 && v66 < 0)
              {
                *(_DWORD *)(v62 + 4 * v63) = -1;
              }
              else if ((v65 & 0x80000000) != 0)
              {
                *(_DWORD *)(v62 + 4 * v63) = v66;
              }
              else
              {
                *(_DWORD *)(*(void *)(v53 + 8 * (v65 >> v54)) + 8 * (v65 & v57)) = v66;
              }
              unsigned int v47 = v184;
            }
LABEL_40:
            uint64_t v11 = v189;
            unsigned int v68 = *(_DWORD *)(*(void *)(v41 + 8 * (v47 >> v42)) + 20 * (v47 & ~(-1 << v42)) + 4);
            if ((*(_DWORD *)(*(void *)(*(void *)(*(void *)(v11 + 72) + 8)
                                        + 8 * (v68 >> *(_WORD *)(*(void *)(v11 + 72) + 44)))
                            + 8 * (v68 & ~(-1 << *(_WORD *)(*(void *)(v11 + 72) + 44)))
                            + 4) & 0x7FFFFFFE) != 0)
              break;
            if (++v45 == v183)
            {
              int v44 = v173;
              unsigned int v69 = v173;
              goto LABEL_72;
            }
          }
          unsigned int v69 = v45 + 1;
          int v44 = v173;
        }
        else
        {
          unsigned int v69 = 0;
        }
LABEL_72:
        unsigned int v95 = v168;
        if (*(_DWORD *)(v11 + 128))
        {
          int v96 = 1;
          goto LABEL_74;
        }
        unsigned int v187 = v37;
        unsigned int v99 = *(_DWORD *)(*(void *)(*(void *)(*(void *)(v11 + 72) + 8)
                                    + 8 * (v37 >> *(_WORD *)(*(void *)(v11 + 72) + 44)))
                        + 8 * (v37 & ~(-1 << *(_WORD *)(*(void *)(v11 + 72) + 44)))
                        + 4) & 0x7FFFFFFF;
        if (v99 >= 2) {
          *a6 = v99 + *a6 - 1;
        }
        v194[0] = 0;
        uint64_t v100 = *(void *)(v11 + 24);
        __int16 v101 = (char *)OOCAllocator_Realloc(v100, 0, 32, v194);
        uint64_t result = v194[0];
        if (v194[0]) {
          return result;
        }
        *(_DWORD *)__int16 v101 = v165;
        int v102 = v101 + 4;
        unsigned int v103 = 8;
        int v96 = 1;
        while (1)
        {
          uint64_t v192 = 0;
          uint64_t v193 = 0;
          unsigned int v105 = *((_DWORD *)v102 - 1);
          v102 -= 4;
          unsigned int v104 = v105;
          if (v105 >= 2)
          {
            uint64_t v106 = (unsigned int *)(*(void *)(*(void *)(*(void *)(v11 + 72) + 8)
                                              + 8 * (v104 >> *(_WORD *)(*(void *)(v11 + 72) + 44)))
                                  + 8 * (v104 & ~(-1 << *(_WORD *)(*(void *)(v11 + 72) + 44))));
            int v107 = v106[1];
            if ((v107 & 0x7FFFFFFE) == 0) {
              break;
            }
          }
LABEL_99:
          if (v101 == v102)
          {
            BOOL v120 = 0;
            goto LABEL_101;
          }
        }
        unsigned int v108 = *v106;
        if (*v106 != -1) {
          break;
        }
        BOOL v120 = v107 >= 0;
        if (v107 >= 0) {
          int v96 = 0;
        }
        uint64_t v11 = v189;
LABEL_101:
        unsigned int v95 = v168;
        if (v101) {
          OOCAllocator_Free(v100, (uint64_t)v101);
        }
        uint64_t result = v194[0];
        unsigned int v191 = v194[0];
        if (v194[0]) {
          return result;
        }
        *(_DWORD *)(v11 + 136) = 1;
        uint64_t v37 = v187;
        int v44 = v173;
        if (v120) {
          goto LABEL_126;
        }
LABEL_74:
        *a6 += v96;
        uint64_t v97 = v37;
        int v98 = v95 ? *v95 : 0;
        unsigned int v121 = (_DWORD *)OOCAllocator_Realloc(v176, (uint64_t)v95, 4 * (v98 + v44 + 1), &v191);
        uint64_t result = v191;
        if (v191) {
          return result;
        }
        *unsigned int v121 = v98 + v44;
        int v122 = v44;
        unsigned int v123 = -1;
        uint64_t v37 = v97;
        if (v122)
        {
          uint64_t v124 = *(void *)(v11 + 64);
          __int16 v125 = *(_WORD *)(v124 + 44);
          uint64_t v126 = *(void *)(v124 + 8);
          int v127 = v98 + 1;
          uint64_t v128 = (unsigned int *)(v188 + 8);
          uint64_t v129 = v183;
          int v130 = -1;
          do
          {
            unsigned int v131 = *v128;
            v128 += 3;
            unsigned int v123 = v130;
            v121[v127++] = *(_DWORD *)(*(void *)(v126 + 8 * (v131 >> v125)) + 20 * (v131 & ~(-1 << v125)) + 8);
            int v130 = v131;
            --v129;
          }
          while (v129);
        }
        uint64_t v168 = v121;
        if (!v69) {
          goto LABEL_126;
        }
        uint64_t v132 = 12 * v69;
        while (1)
        {
          uint64_t v192 = 0;
          uint64_t v193 = 0;
          uint64_t v37 = *(unsigned int *)(v188 + v132 - 12);
          unsigned int v133 = *(_DWORD *)(v188 + v132 - 8);
          unsigned int v134 = *(_DWORD *)(v188 + v132 - 4);
          uint64_t v135 = *(void *)(v11 + 64);
          uint64_t v136 = *(void *)(v135 + 8);
          LOBYTE(v135) = *(_WORD *)(v135 + 44);
          uint64_t v137 = *(void *)(v136 + 8 * (v134 >> v135));
          unsigned int v138 = v134 & ~(-1 << v135);
          if (*(_DWORD *)(v11 + 128))
          {
            unsigned int v139 = *(_DWORD *)(v137 + 20 * v138 + 4);
            if (v139 != 1)
            {
              uint64_t v140 = *(void *)(*(void *)(*(void *)(v11 + 72) + 8)
                               + 8 * (v139 >> *(_WORD *)(*(void *)(v11 + 72) + 44)))
                   + 8 * (v139 & ~(-1 << *(_WORD *)(*(void *)(v11 + 72) + 44)));
              int v143 = *(_DWORD *)(v140 + 4);
              unsigned int v141 = (int *)(v140 + 4);
              int v142 = v143;
              if (v143 < 0)
              {
                *unsigned int v141 = v142 & 0x7FFFFFFF;
                goto LABEL_127;
              }
            }
          }
          unsigned int v144 = (_DWORD *)(v137 + 20 * v138);
          HIDWORD(v192) = *(_DWORD *)(v188 + v132 - 12);
          LODWORD(v193) = v134;
          uint64_t v145 = v37;
          __FSTIncrementalMinimization_UnhashPrefix(v11, (uint64_t)&v192);
          uint64_t v37 = v145;
          uint64_t v146 = *(void *)(v11 + 72);
          uint64_t v147 = *(void *)(v146 + 8);
          __int16 v148 = *(_WORD *)(v146 + 44);
          uint64_t v149 = *(void *)(v147 + 8 * (v145 >> v148));
          unsigned int v191 = 0;
          unsigned int v150 = (_DWORD *)(v149 + 8 * (v145 & ~(-1 << v148)));
          if (v134 == *v150)
          {
            *unsigned int v150 = *v144;
          }
          else if (v133 != -1)
          {
            *(_DWORD *)(*(void *)(*(void *)(*(void *)(v11 + 64) + 8)
                                  + 8 * (v133 >> *(_WORD *)(*(void *)(v11 + 64) + 44)))
                      + 20 * (v133 & ~(-1 << *(_WORD *)(*(void *)(v11 + 64) + 44)))) = *v144;
          }
          unsigned int v151 = *(_DWORD *)(v137 + 20 * v138 + 4);
          if (v151 != 1)
          {
            uint64_t v152 = *(void *)(v147 + 8 * (v151 >> v148)) + 8 * (v151 & ~(-1 << v148));
            *(_DWORD *)(v152 + 4) = ((*(_DWORD *)(v152 + 4) & 0x7FFFFFFF) - 1) | *(_DWORD *)(v152 + 4) & 0x80000000;
          }
          uint64_t v153 = v137 + 20 * v138;
          *(_DWORD *)(v153 + 16) = -1;
          *(void *)(v153 + 8) = -1;
          *(_DWORD *)(v11 + 132) = 1;
          uint64_t v154 = *(void *)(v11 + 72);
          char v155 = *(_WORD *)(v154 + 44);
          uint64_t v156 = *(void *)(*(void *)(v154 + 8) + 8 * (v145 >> v155));
          if (*(_DWORD *)(v156 + 8 * (v145 & ~(-1 << v155))) != -1) {
            goto LABEL_127;
          }
          if ((*(_DWORD *)(v156 + 8 * (v145 & ~(-1 << v155)) + 4) & 0x80000000) != 0) {
            break;
          }
          v132 -= 12;
          if (!v132) {
            goto LABEL_127;
          }
        }
        if (v123 != -1) {
          *(_DWORD *)(*(void *)(*(void *)(*(void *)(v11 + 64) + 8)
        }
                                + 8 * (v123 >> *(_WORD *)(*(void *)(v11 + 64) + 44)))
                    + 20 * (v123 & ~(-1 << *(_WORD *)(*(void *)(v11 + 64) + 44)))
                    + 4) = 1;
LABEL_127:
        uint64_t v157 = v37;
        OOCAllocator_Free(v176, v188);
        uint64_t v37 = v157;
LABEL_128:
        uint64_t v36 = v177;
        if (v174 == v177)
        {
          if (v174) {
            OOCAllocator_Free(v176, v174);
          }
          a7 = v158;
          *__int16 v158 = v168;
          uint64_t result = v191;
          a4 = v173;
          if (v191) {
            return result;
          }
          unsigned int v18 = v164;
          if ((v164 & 0x80000000) != 0) {
            goto LABEL_146;
          }
          if (*a6 != v159) {
            unsigned int v18 = *(_DWORD *)(*(void *)(*(void *)(*(void *)(v11 + 80) + 8)
          }
                                        + 8 * (v161 >> *(_WORD *)(*(void *)(v11 + 80) + 44)))
                            + 4 * (v161 & ~(-1 << *(_WORD *)(*(void *)(v11 + 80) + 44))));
LABEL_138:
          if ((v18 & 0x80000000) != 0)
          {
LABEL_146:
            uint64_t v12 = v163 + 1;
            a2 = v160;
            if (v163 + 1 >= (unint64_t)*v166) {
              return 0;
            }
            goto LABEL_3;
          }
          goto LABEL_4;
        }
      }
      uint64_t v185 = v106;
      unsigned int v182 = v96 + (v107 >> 31);
      HIDWORD(v192) = v104;
      uint64_t v109 = *(void *)(v189 + 64);
      uint64_t v110 = *(void *)(v109 + 8);
      __int16 v111 = *(_WORD *)(v109 + 44);
      int v112 = -1;
      do
      {
        int v113 = *(_DWORD *)(*(void *)(v110 + 8 * (v108 >> v111)) + 20 * (v108 & ~(-1 << v111)) + 4);
        int64_t v114 = v102 - v101;
        unsigned int v115 = ((unint64_t)(v102 - v101) >> 2) + 1;
        if (v115 > v103)
        {
          unsigned int v116 = 2 * v103;
          if (2 * v103 >= v103 + 100) {
            unsigned int v116 = v103 + 100;
          }
          if (v116 > v115) {
            unsigned int v115 = v116;
          }
          if (v115 <= 8) {
            unsigned int v103 = 8;
          }
          else {
            unsigned int v103 = v115;
          }
          __int16 v101 = (char *)OOCAllocator_Realloc(v100, (uint64_t)v101, 4 * v103, v194);
          uint64_t result = v194[0];
          if (v194[0]) {
            return result;
          }
          int v102 = &v101[v114 & 0x3FFFFFFFCLL];
        }
        *(_DWORD *)int v102 = v113;
        v102 += 4;
        LODWORD(v193) = v108;
        __FSTIncrementalMinimization_UnhashPrefix(v189, (uint64_t)&v192);
        v194[0] = 0;
        uint64_t v117 = *(void *)(*(void *)(*(void *)(v189 + 64) + 8)
                         + 8 * (v108 >> *(_WORD *)(*(void *)(v189 + 64) + 44)))
             + 20 * (v108 & ~(-1 << *(_WORD *)(*(void *)(v189 + 64) + 44)));
        *(_DWORD *)(v117 + 16) = -1;
        *(void *)(v117 + 8) = -1;
        uint64_t v118 = *(void *)(v189 + 64);
        uint64_t v110 = *(void *)(v118 + 8);
        __int16 v111 = *(_WORD *)(v118 + 44);
        unsigned int v108 = *(_DWORD *)(*(void *)(v110 + 8 * (v108 >> v111)) + 20 * (v108 & ~(-1 << v111)));
        ++v112;
      }
      while (v108 != -1);
      *uint64_t v185 = -1;
      if ((v112 + 1) <= 1) {
        int v119 = 0;
      }
      else {
        int v119 = v112;
      }
      int v96 = v182 + v119;
      uint64_t v11 = v189;
      goto LABEL_99;
    }
  }
  return result;
}

BOOL _FSTIncrementalMinimizationPrefixFuzzyEqual(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 64);
  uint64_t v4 = *(void *)(v3 + 8);
  unsigned int v5 = *(_DWORD *)(a2 + 8);
  char v6 = *(_WORD *)(v3 + 44);
  uint64_t v7 = *(void *)(v4 + 8 * (v5 >> v6));
  unsigned int v8 = v5 & ~(-1 << v6);
  unsigned int v9 = *(_DWORD *)(a3 + 8);
  uint64_t v10 = *(void *)(v4 + 8 * (v9 >> v6));
  unsigned int v11 = v9 & ~(-1 << v6);
  return *(_DWORD *)(v7 + 20 * v8 + 8) == *(_DWORD *)(v10 + 20 * v11 + 8)
      && *(_DWORD *)(v7 + 20 * v8 + 12) == *(_DWORD *)(v10 + 20 * v11 + 12)
      && *(_DWORD *)(v7 + 20 * v8 + 16) == *(_DWORD *)(v10 + 20 * v11 + 16);
}

uint64_t FSTIncrementalMinimization_SetInitialStateFlags(uint64_t a1, int a2)
{
  if (a2 < 0)
  {
    uint64_t v2 = **(void **)(*(void *)(a1 + 72) + 8);
    *(_DWORD *)(v2 + 4) |= 0x80000000;
  }
  return 0;
}

void PNEW_FSTIncrementalMinimization_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 144, &v10);
  if (!v10)
  {
    FSTIncrementalMinimization_Con(v8, a2, a3);
    int v10 = v9;
    if (v9)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
    }
    else
    {
      *(void *)(v8 + 16) = a1;
      *a4 = v8;
    }
  }
}

void PNEW_FSTIncrementalMinimization_ConFromBuffer(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, unint64_t a5, uint64_t *a6)
{
  int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 144, &v14);
  if (!v14)
  {
    FSTIncrementalMinimization_ConFromBuffer(v12, a2, a3, a4, a5);
    int v14 = v13;
    if (v13)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
    }
    else
    {
      *(void *)(v12 + 16) = a1;
      *a6 = v12;
    }
  }
}

void *GetFSTIncrementalMinimizationClass()
{
  return &__FSTIncrementalMinimization;
}

uint64_t __FSTIncrementalMinimization_UnhashPrefix(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 64);
  uint64_t v5 = *(void *)(v4 + 8);
  unsigned int v6 = *(_DWORD *)(a2 + 8);
  __int16 v7 = *(_WORD *)(v4 + 44);
  uint64_t v8 = *(void *)(v5 + 8 * (v6 >> v7));
  unsigned int v9 = v6 & ~(-1 << v7);
  int v10 = (_DWORD *)(v8 + 20 * v9 + 8);
  char v60 = v7;
  int v59 = ~(-1 << v7);
  if (*(_DWORD *)(result + 128))
  {
    unsigned int v11 = *(_DWORD *)(v8 + 20 * v9 + 16)
        + 2239 * (*(_DWORD *)(v8 + 20 * v9 + 12) + 2239 * (*v10 + 2239 * *(_DWORD *)(a2 + 4)));
    uint64_t v12 = *(void *)(result + 80);
    unsigned int v56 = *(_DWORD *)(v12 + 32);
    uint64_t v57 = *(void *)(v12 + 8);
    uint64_t v58 = v5;
    __int16 v55 = *(_WORD *)(v12 + 44);
    int v54 = ~(-1 << v55);
    int v13 = (unsigned int *)(*(void *)(v57 + 8 * ((v11 % v56) >> v55)) + 4 * ((v11 % v56) & v54));
    while (1)
    {
      unsigned int v14 = *v13;
      if ((*v13 & 0x80000000) != 0) {
        break;
      }
      uint64_t v15 = *(void *)(v3 + 88);
      uint64_t v16 = *(void *)(v15 + 8);
      __int16 v17 = *(_WORD *)(v15 + 44);
      uint64_t v18 = v14 >> v17;
      uint64_t v19 = v14 & ~(-1 << v17);
      int v13 = (unsigned int *)(*(void *)(v16 + 8 * v18) + 16 * v19);
      uint64_t result = _FSTIncrementalMinimizationPrefixEqual(v3, a2, (uint64_t)v13);
      if (result)
      {
        int v20 = ~(-1 << v17);
        goto LABEL_12;
      }
    }
    if (v14 == -1) {
      return result;
    }
    uint64_t v29 = *(void *)(v3 + 88);
    uint64_t v16 = *(void *)(v29 + 8);
    __int16 v17 = *(_WORD *)(v29 + 44);
    uint64_t v18 = v14 >> v17;
    int v20 = ~(-1 << v17);
    uint64_t v19 = v14 & v20;
LABEL_12:
    uint64_t v30 = (int *)(*(void *)(v16 + 8 * v18) + 16 * v19);
    char v31 = (_DWORD *)(*(void *)(v58 + 8 * (v30[2] >> v60)) + 20 * (v30[2] & v59));
    unsigned int v32 = (v31[4] + 2239 * (v31[3] + 2239 * (v31[2] + 2239 * v30[1]))) % v56;
    uint64_t v33 = *(void *)(v57 + 8 * (v32 >> v55));
    uint64_t v34 = v32 & v54;
    unsigned int v35 = *(_DWORD *)(v33 + 4 * v34);
    for (i = -1; (v35 & 0x80000000) == 0; unsigned int v35 = *(_DWORD *)(*(void *)(v16 + 8 * (v35 >> v17)) + 16 * (v35 & v20)))
    {
      if (v35 == v14) {
        break;
      }
      unsigned int i = v35;
    }
    int v37 = *v30;
    int v38 = *(_DWORD *)(v3 + 96);
    *(_DWORD *)(v3 + 96) = v14;
    *uint64_t v30 = (v38 + 1) | 0x40000000;
    if ((i & 0x80000000) != 0 && v37 < 0)
    {
      *(_DWORD *)(v33 + 4 * v34) = -1;
    }
    else if ((i & 0x80000000) != 0)
    {
      *(_DWORD *)(v33 + 4 * v34) = v37;
    }
    else
    {
      *(_DWORD *)(*(void *)(v16 + 8 * (i >> v17)) + 16 * (i & v20)) = v37;
    }
  }
  else
  {
    unsigned int v21 = *(_DWORD *)(v8 + 20 * v9 + 16) + 2239 * (*(_DWORD *)(v8 + 20 * v9 + 12) + 2239 * *v10);
    uint64_t v22 = *(void *)(result + 80);
    uint64_t v23 = *(void *)(v22 + 8);
    unsigned int v24 = *(_DWORD *)(v22 + 32);
    __int16 v25 = *(_WORD *)(v22 + 44);
    int v26 = ~(-1 << v25);
    uint64_t v27 = (unsigned int *)(*(void *)(v23 + 8 * ((v21 % v24) >> v25)) + 4 * ((v21 % v24) & v26));
    while (1)
    {
      unsigned int v28 = *v27;
      if ((*v27 & 0x80000000) != 0) {
        break;
      }
      uint64_t v27 = (unsigned int *)(*(void *)(*(void *)(*(void *)(v3 + 88) + 8)
                                       + 8 * (v28 >> *(_WORD *)(*(void *)(v3 + 88) + 44)))
                           + 16 * (v28 & ~(-1 << *(_WORD *)(*(void *)(v3 + 88) + 44))));
      uint64_t result = _FSTIncrementalMinimizationPrefixFuzzyEqual(v3, a2, (uint64_t)v27);
      if (result) {
        goto LABEL_21;
      }
    }
    if (v28 == -1) {
      return result;
    }
LABEL_21:
    uint64_t v39 = *(void *)(v3 + 88);
    uint64_t v40 = *(void *)(v39 + 8);
    __int16 v41 = *(_WORD *)(v39 + 44);
    int v42 = ~(-1 << v41);
    while (1)
    {
      uint64_t v43 = *(void *)(v40 + 8 * (v28 >> v41));
      uint64_t v44 = v28 & v42;
      uint64_t v45 = (int *)(v43 + 16 * v44);
      if (v45[1] == *(_DWORD *)(a2 + 4)) {
        break;
      }
      unsigned int v28 = *v45;
      if (*v45 == -1) {
        return result;
      }
    }
    unint64_t v46 = (_DWORD *)(*(void *)(v5 + 8 * (*(_DWORD *)(v43 + 16 * v44 + 8) >> v60))
                   + 20 * (*(_DWORD *)(v43 + 16 * v44 + 8) & v59));
    unsigned int v47 = (v46[4] + 2239 * (v46[3] + 2239 * v46[2])) % v24;
    uint64_t v48 = *(void *)(v23 + 8 * (v47 >> v25));
    uint64_t v49 = v47 & v26;
    unsigned int v50 = *(_DWORD *)(v48 + 4 * v49);
    for (j = -1; (v50 & 0x80000000) == 0; unsigned int v50 = *(_DWORD *)(*(void *)(v40 + 8 * (v50 >> v41)) + 16 * (v50 & v42)))
    {
      if (v50 == v28) {
        break;
      }
      unsigned int j = v50;
    }
    int v52 = *v45;
    int v53 = *(_DWORD *)(v3 + 96);
    *(_DWORD *)(v3 + 96) = v28;
    *uint64_t v45 = (v53 + 1) | 0x40000000;
    if ((j & 0x80000000) != 0 && v52 < 0)
    {
      *(_DWORD *)(v48 + 4 * v49) = -1;
    }
    else if ((j & 0x80000000) != 0)
    {
      *(_DWORD *)(v48 + 4 * v49) = v52;
    }
    else
    {
      *(_DWORD *)(*(void *)(v40 + 8 * (j >> v41)) + 16 * (j & v42)) = v52;
    }
  }
  return result;
}

uint64_t _FSTUnaryOperator_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v5 = FST_Con((void *)a1, a2, *(void *)(a3 + 48));
  uint64_t v7 = v6;
  if (!v6)
  {
    *(void *)a1 = &__FSTUnaryOperator;
    *(void *)(a1 + 64) = a3;
    (*(void (**)(uint64_t, double))(*(void *)a3 + 24))(a3, v5);
    int v8 = *(_DWORD *)(a3 + 36);
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 36) = v8;
  }
  return v7;
}

uint64_t FSTUnaryOperator_Des(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 32))(*(void *)(a1 + 64));
  if (!result)
  {
    return FST_Des(a1);
  }
  return result;
}

uint64_t FSTUnaryOperator_BorrowComponentFst(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t FSTUnaryOperator_GetFinalStateWeight(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 64))(*(void *)(a1 + 64));
}

uint64_t FSTUnaryOperator_GetInitialStateId(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 48))(*(void *)(a1 + 64));
}

uint64_t FSTUnaryOperator_GetMaxBranchFactor(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 136))(*(void *)(a1 + 64));
}

uint64_t FSTUnaryOperator_GetMaxNbrComponentFsts()
{
  return 1;
}

uint64_t FSTUnaryOperator_GetMaxStateId(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 72))(*(void *)(a1 + 64));
}

uint64_t FSTUnaryOperator_GetMemoryInfo(uint64_t a1)
{
  return 72;
}

uint64_t FSTUnaryOperator_GetStatus(uint64_t a1)
{
  int v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 168))(*(void *)(a1 + 64));
  return FST_GetStatus(a1) | v2;
}

uint64_t FSTUnaryOperator_Reset(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 112))(*(void *)(a1 + 64));
  if (!result)
  {
    return FST_Reset();
  }
  return result;
}

double FSTUnaryOperator_SetStatePool(uint64_t a1, uint64_t a2)
{
  if (!(*(unsigned int (**)(void))(**(void **)(a1 + 64) + 128))(*(void *)(a1 + 64)))
  {
    return FST_SetStatePool(a1, a2);
  }
  return result;
}

int8x8_t *_FSTUnaryOperator_InheritProperties(int8x8_t *result, uint64_t a2, unsigned int a3, int a4, int a5, int a6)
{
  if (a3) {
    result[5] = vorr_s8(result[5], (int8x8_t)vdup_n_s32(a3));
  }
  if (a4)
  {
    int v6 = result[5].i32[1] | a4;
    result[5].i32[0] &= ~a4;
    result[5].i32[1] = v6;
  }
  if (a5) {
    result[5] = vand_s8(result[5], (int8x8_t)vdup_n_s32(~a5));
  }
  if (a2)
  {
    if (a6)
    {
      int v7 = *(_DWORD *)(a2 + 44);
      int v8 = result[5].i32[1] & ~a6 | v7 & a6;
      result[5].i32[0] = *(_DWORD *)(a2 + 40) & a6 & v7 | result[5].i32[0] & ~a6;
      result[5].i32[1] = v8;
    }
  }
  return result;
}

uint64_t _FSTUnaryOperator_SetFst(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = a2;
  (*(void (**)(uint64_t))(*(void *)a2 + 24))(a2);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 32);

  return v3(v2);
}

void *GetFSTUnaryOperatorClass()
{
  return &__FSTUnaryOperator;
}

double FSTPacked_Con(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, char *a5, uint64_t a6)
{
  double result = _FSTBaseFlat_Con((void *)a1, a2, a3, a4, a5, a6, 1u);
  if (!v9)
  {
    *(void *)a1 = &__FSTPacked;
    *(_DWORD *)(a1 + 112) = bswap32(*(_DWORD *)&a5[*(void *)(a1 + 80)]);
    *(_DWORD *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = 0;
    *(void *)&double result = *(void *)(a1 + 40) | 0x10000000100;
    *(double *)(a1 + 40) = result;
  }
  return result;
}

void FSTPacked_ConFromFST(int8x8_t *a1, uint64_t a2, uint64_t a3)
{
  v125[4] = *MEMORY[0x263EF8340];
  uint64_t v123 = 0;
  memset(v122, 0, sizeof(v122));
  uint64_t v119 = 0;
  uint64_t v120 = 0;
  uint64_t v121 = 0;
  unsigned int v118 = 0;
  int HeaderSizeInOutputBuffer = FSTCount(a2, a3, (uint64_t)v122);
  if (!HeaderSizeInOutputBuffer)
  {
    int HeaderSizeInOutputBuffer = FST_GetHeaderSizeInOutputBuffer(&v123);
    if (!HeaderSizeInOutputBuffer)
    {
      uint64_t v6 = v123;
      int v7 = (char *)OOCAllocator_Malloc(a2, v123 + 20, &HeaderSizeInOutputBuffer);
      if (!HeaderSizeInOutputBuffer)
      {
        int v8 = *(_DWORD *)(a3 + 32);
        *(_DWORD *)(a3 + 32) = 3;
        int HeaderSizeInOutputBuffer = FST_FillHeader((_DWORD *)a3, v7, 1, &v123);
        if (!HeaderSizeInOutputBuffer)
        {
          uint64_t v112 = v6 + 20;
          int v113 = a1;
          unsigned int v9 = 0;
          uint64_t v10 = 0;
          unint64_t v11 = 0;
          uint64_t v12 = 0;
          uint64_t v114 = v6 + 16;
          uint64_t v115 = (uint64_t)v7;
          *(_DWORD *)(a3 + 32) = v8;
          int v13 = &v7[v123];
          *((void *)v13 + 1) = 0;
          *((_DWORD *)v13 + 1) = 0;
          while (2)
          {
            int v14 = 0;
            v125[0] = 0;
            uint64_t v15 = v12;
            while (1)
            {
              uint64_t v16 = (v15 + 1);
              unint64_t v17 = v11 - v10;
              if (v16 >= ((v11 - v10) >> 2))
              {
                if (v16 > v9)
                {
                  unsigned int v18 = 2 * v9;
                  if (2 * v9 >= v9 + 1000000) {
                    unsigned int v18 = v9 + 1000000;
                  }
                  if (v18 <= v16) {
                    unsigned int v18 = v15 + 1;
                  }
                  if (v18 <= 8) {
                    unsigned int v9 = 8;
                  }
                  else {
                    unsigned int v9 = v18;
                  }
                  uint64_t v10 = OOCAllocator_Realloc(a2, v10, 4 * v9, &HeaderSizeInOutputBuffer);
                  if (HeaderSizeInOutputBuffer) {
                    return;
                  }
                  unint64_t v11 = v10 + (v17 & 0x3FFFFFFFCLL);
                }
                if (v11 < v10 + 4 * v16)
                {
                  unint64_t v19 = v10 + 4 * v16;
                  if (v19 <= v11 + 4) {
                    unint64_t v19 = v11 + 4;
                  }
                  size_t v20 = ((v19 + ~v11) & 0xFFFFFFFFFFFFFFFCLL) + 4;
                  bzero((void *)v11, v20);
                  v11 += v20;
                }
              }
              int HeaderSizeInOutputBuffer = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a3 + 120))(a3, v15, 2, v125);
              if (HeaderSizeInOutputBuffer) {
                return;
              }
              if (!v125[0]) {
                goto LABEL_57;
              }
              unsigned int v21 = *(_DWORD *)(v125[0] + 8);
              if (v21 >> 28 || *(_DWORD *)(v125[0] + 48) != 1)
              {
                int v27 = v21 & 0x3FFFFFF;
                int v28 = -v14;
                goto LABEL_47;
              }
              int v22 = *(_DWORD *)(v10 + 4 * v15);
              if (v22) {
                break;
              }
              uint64_t v23 = *(unsigned int **)(v125[0] + 56);
              if (!v23 || (uint64_t v24 = *v23, v24 == v15) || v23[2] != -2)
              {
                if ((v21 & 0x3FFFFFF) == 1)
                {
                  if ((v21 & 0x8000000) != 0) {
                    uint64_t v26 = *(void *)(v125[0] + 16);
                  }
                  else {
                    uint64_t v26 = 0;
                  }
                  int HeaderSizeInOutputBuffer = FSTStatePool_PushFSTState(v26, v125[0]);
                  if (HeaderSizeInOutputBuffer) {
                    return;
                  }
                }
                else
                {
                  *(_DWORD *)(v125[0] + 8) = v21 - 1;
                  if ((v21 & 0x3FFFFFF) == 0) {
                    return;
                  }
                  int HeaderSizeInOutputBuffer = 0;
                }
LABEL_57:
                int v28 = -v14;
                goto LABEL_58;
              }
              if ((v21 & 0x3FFFFFF) == 1)
              {
                if ((v21 & 0x8000000) != 0) {
                  uint64_t v25 = *(void *)(v125[0] + 16);
                }
                else {
                  uint64_t v25 = 0;
                }
                int HeaderSizeInOutputBuffer = FSTStatePool_PushFSTState(v25, v125[0]);
                if (HeaderSizeInOutputBuffer) {
                  return;
                }
              }
              else
              {
                *(_DWORD *)(v125[0] + 8) = v21 - 1;
                if ((v21 & 0x3FFFFFF) == 0) {
                  return;
                }
                int HeaderSizeInOutputBuffer = 0;
              }
              v125[0] = 0;
              --v14;
              uint64_t v15 = v24;
              if (v14 == -100)
              {
LABEL_228:
                err_GenerateErrorLimit();
                return;
              }
            }
            int v28 = v22 - v14;
            int v27 = v21 & 0x3FFFFFF;
LABEL_47:
            if (v27 == 1)
            {
              if ((v21 & 0x8000000) != 0) {
                uint64_t v29 = *(void *)(v125[0] + 16);
              }
              else {
                uint64_t v29 = 0;
              }
              int HeaderSizeInOutputBuffer = FSTStatePool_PushFSTState(v29, v125[0]);
              if (HeaderSizeInOutputBuffer) {
                return;
              }
            }
            else
            {
              *(_DWORD *)(v125[0] + 8) = v21 - 1;
              if (!v27) {
                return;
              }
              int HeaderSizeInOutputBuffer = 0;
            }
LABEL_58:
            *(_DWORD *)(v10 + 4 * v12) = v28;
            uint64_t v12 = (v12 + 1);
            if (v12 <= LODWORD(v122[0])) {
              continue;
            }
            break;
          }
          uint64_t v30 = 4 * LODWORD(v122[0]) + 4;
          uint64_t v31 = OOCAllocator_Malloc(a2, v30, &HeaderSizeInOutputBuffer);
          if (!HeaderSizeInOutputBuffer)
          {
            uint64_t v32 = v30 + v31;
            if (v30 + v31 <= (unint64_t)(v31 + 4)) {
              uint64_t v32 = v31 + 4;
            }
            memset((void *)v31, 255, ((v32 + ~v31) & 0xFFFFFFFFFFFFFFFCLL) + 4);
            uint64_t v33 = 0;
            do
            {
              if (*(_DWORD *)(v10 + 4 * v33))
              {
                int v34 = 0;
                uint64_t v35 = v33;
                do
                {
                  v125[0] = 0;
                  int HeaderSizeInOutputBuffer = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a3 + 120))(a3, v35, 8, v125);
                  if (HeaderSizeInOutputBuffer) {
                    return;
                  }
                  if (v125[0])
                  {
                    uint64_t v36 = **(unsigned int **)(v125[0] + 56);
                    int v37 = *(_DWORD *)(v125[0] + 8);
                    if ((v37 & 0x3FFFFFF) == 1)
                    {
                      if ((v37 & 0x8000000) != 0) {
                        uint64_t v38 = *(void *)(v125[0] + 16);
                      }
                      else {
                        uint64_t v38 = 0;
                      }
                      int HeaderSizeInOutputBuffer = FSTStatePool_PushFSTState(v38, v125[0]);
                      if (HeaderSizeInOutputBuffer) {
                        return;
                      }
                    }
                    else
                    {
                      *(_DWORD *)(v125[0] + 8) = v37 - 1;
                      if ((v37 & 0x3FFFFFF) == 0) {
                        return;
                      }
                      int HeaderSizeInOutputBuffer = 0;
                    }
                    uint64_t v39 = *(unsigned int *)(v31 + 4 * v35);
                    if (v39 != -1 && *(_DWORD *)(v10 + 4 * v39) >= *(_DWORD *)(v10 + 4 * v33)) {
                      break;
                    }
                    *(_DWORD *)(v31 + 4 * v35) = v33;
                    uint64_t v35 = v36;
                  }
                }
                while (++v34 < *(_DWORD *)(v10 + 4 * v33));
              }
              uint64_t v33 = (v33 + 1);
            }
            while (v33 <= LODWORD(v122[0]));
            OOCAllocator_Free(a2, v10);
            int v40 = LODWORD(v122[0]) + 1;
            uint64_t v41 = 4 * (LODWORD(v122[0]) + 1);
            uint64_t v108 = OOCAllocator_Malloc(a2, v41, &HeaderSizeInOutputBuffer);
            if (!HeaderSizeInOutputBuffer)
            {
              if (v40)
              {
                uint64_t v42 = v41 + v108;
                if (v41 + v108 <= (unint64_t)(v108 + 4)) {
                  uint64_t v42 = v108 + 4;
                }
                bzero((void *)v108, ((v42 + ~v108) & 0xFFFFFFFFFFFFFFFCLL) + 4);
              }
              unsigned int v43 = 0;
              do
              {
                uint64_t v44 = *(unsigned int *)(v31 + 4 * v43);
                if (v44 != -1) {
                  ++*(_DWORD *)(v108 + 4 * v44);
                }
                ++v43;
              }
              while (v43 <= LODWORD(v122[0]));
              uint64_t v45 = LODWORD(v122[0]) + 1;
              LODWORD(v119) = LODWORD(v122[0]) + 1;
              uint64_t v46 = 4 * v45;
              uint64_t v47 = OOCAllocator_Malloc(a2, 4 * v45, &HeaderSizeInOutputBuffer);
              uint64_t v120 = v47;
              if (!HeaderSizeInOutputBuffer)
              {
                uint64_t v121 = v47 + 4 * v45;
                uint64_t v48 = v46 + v47;
                if (v46 + v47 <= (unint64_t)(v47 + 4)) {
                  uint64_t v48 = v47 + 4;
                }
                memset((void *)v47, 255, ((v48 + ~v47) & 0xFFFFFFFFFFFFFFFCLL) + 4);
                LODWORD(v49) = 0;
                __int16 v111 = 0;
                __dst = 0;
                uint64_t v50 = 0;
                int v109 = 0;
                int v104 = 0;
                do
                {
LABEL_92:
                  uint64_t v51 = *(unsigned int *)(v108 + 4 * v50);
                  if (v51)
                  {
                    __src = (char *)OOCAllocator_Malloc(a2, 2 * v51 + 4, &HeaderSizeInOutputBuffer);
                    if (HeaderSizeInOutputBuffer) {
                      return;
                    }
                    int v52 = __src;
                    uint64_t v53 = v50;
                    int v54 = 4 * v109 + 2 * v104;
                    do
                    {
                      v125[0] = 0;
                      int HeaderSizeInOutputBuffer = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a3 + 120))(a3, v53, 8, v125);
                      if (HeaderSizeInOutputBuffer) {
                        return;
                      }
                      if (v125[0])
                      {
                        __int16 v55 = *(unsigned int **)(v125[0] + 56);
                        *(_WORD *)int v52 = bswap32(*((unsigned __int16 *)v55 + 2)) >> 16;
                        v52 += 2;
                        *(_DWORD *)(v120 + 4 * v53) = v54;
                        uint64_t v53 = *v55;
                        int v56 = *(_DWORD *)(v125[0] + 8);
                        if ((v56 & 0x3FFFFFF) == 1)
                        {
                          if ((v56 & 0x8000000) != 0) {
                            uint64_t v57 = *(void *)(v125[0] + 16);
                          }
                          else {
                            uint64_t v57 = 0;
                          }
                          int HeaderSizeInOutputBuffer = FSTStatePool_PushFSTState(v57, v125[0]);
                          if (HeaderSizeInOutputBuffer) {
                            return;
                          }
                        }
                        else
                        {
                          *(_DWORD *)(v125[0] + 8) = v56 - 1;
                          if ((v56 & 0x3FFFFFF) == 0) {
                            return;
                          }
                          int HeaderSizeInOutputBuffer = 0;
                        }
                      }
                      v54 += 2;
                      LODWORD(v51) = v51 - 1;
                    }
                    while (v51);
                    int v58 = *(_DWORD *)(v120 + 4 * v53);
                    if (v58 < 0) {
                      goto LABEL_228;
                    }
                    *int v52 = HIBYTE(v58) | 0x80;
                    v52[1] = BYTE2(v58);
                    v52[2] = BYTE1(v58);
                    v52[3] = v58;
                    uint64_t v59 = *(unsigned int *)(v108 + 4 * v50);
                    unsigned int v60 = __dst - v111;
                    uint64_t v61 = 2 * v59;
                    unsigned int v62 = __dst - v111 + 2 * v59 + 4;
                    if (v49 < v62)
                    {
                      unsigned int v63 = 2 * v49;
                      if (2 * (int)v49 >= (v49 + 1000000)) {
                        unsigned int v63 = v49 + 1000000;
                      }
                      if (v63 <= v62) {
                        unsigned int v63 = __dst - v111 + 2 * v59 + 4;
                      }
                      if (v63 <= 8) {
                        uint64_t v49 = 8;
                      }
                      else {
                        uint64_t v49 = v63;
                      }
                      __int16 v111 = (char *)OOCAllocator_Realloc(a2, (uint64_t)v111, v49, &HeaderSizeInOutputBuffer);
                      if (HeaderSizeInOutputBuffer) {
                        return;
                      }
                      __dst = &v111[v60];
                      uint64_t v61 = 2 * *(unsigned int *)(v108 + 4 * v50);
                    }
                    ++v109;
                    v104 += v59;
                    cstdlib_memcpy(__dst, __src, v61 + 4);
                    __dst += 2 * *(unsigned int *)(v108 + 4 * v50) + 4;
                    OOCAllocator_Free(a2, (uint64_t)__src);
                  }
                  uint64_t v50 = (v50 + 1);
                }
                while (v50 <= LODWORD(v122[0]));
                unsigned int v110 = 0;
                int __srca = 0;
                unsigned int v64 = __dst;
                *(_DWORD *)(v115 + v114) = bswap32(__dst - v111);
                while (2)
                {
                  uint64_t v117 = 0;
                  int HeaderSizeInOutputBuffer = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t *))(*(void *)a3 + 120))(a3, v110, 8, &v117);
                  if (HeaderSizeInOutputBuffer) {
                    return;
                  }
                  int v65 = *(_DWORD *)(v117 + 8);
                  char v66 = HIBYTE(v65) & 0xF0;
                  uint64_t v67 = *(unsigned int *)(v117 + 48);
                  uint64_t v68 = *(unsigned int *)(v117 + 32);
                  if (!(v67 | v68))
                  {
                    unsigned int v69 = v64 - v111;
                    if (*(_DWORD *)(v120 + 4 * v110) != v64 - v111)
                    {
                      ++__srca;
                      *(_DWORD *)(v120 + 4 * v110) = v69;
                    }
                    unsigned int v70 = v69 + 1;
                    if (v69 + 1 > v49)
                    {
                      unsigned int v71 = 2 * v49;
                      if (2 * (int)v49 >= (v49 + 1000000)) {
                        unsigned int v71 = v49 + 1000000;
                      }
                      if (v71 > v70) {
                        unsigned int v70 = v71;
                      }
                      if (v70 <= 8) {
                        uint64_t v49 = 8;
                      }
                      else {
                        uint64_t v49 = v70;
                      }
                      __int16 v111 = (char *)OOCAllocator_Realloc(a2, (uint64_t)v111, v49, &HeaderSizeInOutputBuffer);
                      if (HeaderSizeInOutputBuffer) {
                        return;
                      }
                      unsigned int v64 = &v111[v69];
                    }
                    *unsigned int v64 = v66;
                    unsigned int v72 = v64 + 1;
                    if (v65 < 0)
                    {
                      LODWORD(v125[0]) = bswap32(*(_DWORD *)(v117 + 28));
                      unsigned int v73 = v72 - v111;
                      unsigned int v74 = v72 - v111 + 4;
                      if (v74 > v49)
                      {
                        unsigned int v75 = 2 * v49;
                        if (2 * (int)v49 >= (v49 + 1000000)) {
                          unsigned int v75 = v49 + 1000000;
                        }
                        if (v75 > v74) {
                          unsigned int v74 = v75;
                        }
                        if (v74 <= 8) {
                          uint64_t v49 = 8;
                        }
                        else {
                          uint64_t v49 = v74;
                        }
                        __int16 v111 = (char *)OOCAllocator_Realloc(a2, (uint64_t)v111, v49, &HeaderSizeInOutputBuffer);
                        if (HeaderSizeInOutputBuffer) {
                          return;
                        }
                        unsigned int v72 = &v111[v73];
                      }
                      cstdlib_memcpy(v72, v125, 4uLL);
                      v72 += 4;
                    }
                    goto LABEL_145;
                  }
                  if (!*(_DWORD *)(v108 + 4 * v110) && *(_DWORD *)(v31 + 4 * v110) == -1)
                  {
                    uint64_t v81 = *(unsigned int **)(v117 + 40);
                    uint64_t v105 = *(void *)(v117 + 56);
                    unsigned int __dsta = v64 - v111;
                    if (*(_DWORD *)(v120 + 4 * v110) != v64 - v111)
                    {
                      ++__srca;
                      *(_DWORD *)(v120 + 4 * v110) = __dsta;
                    }
                    unsigned int v82 = __dsta + 1;
                    if (__dsta + 1 > v49)
                    {
                      unsigned int v83 = 2 * v49;
                      if (2 * (int)v49 >= (v49 + 1000000)) {
                        unsigned int v83 = v49 + 1000000;
                      }
                      if (v83 > v82) {
                        unsigned int v82 = v83;
                      }
                      if (v82 <= 8) {
                        uint64_t v49 = 8;
                      }
                      else {
                        uint64_t v49 = v82;
                      }
                      __int16 v111 = (char *)OOCAllocator_Realloc(a2, (uint64_t)v111, v49, &HeaderSizeInOutputBuffer);
                      if (HeaderSizeInOutputBuffer) {
                        return;
                      }
                      unsigned int v64 = &v111[__dsta];
                    }
                    *unsigned int v64 = v66;
                    unsigned int v72 = v64 + 1;
                    if (v65 < 0)
                    {
                      LODWORD(v125[0]) = bswap32(*(_DWORD *)(v117 + 28));
                      unsigned int v84 = v72 - v111;
                      unsigned int v85 = v72 - v111 + 4;
                      if (v85 > v49)
                      {
                        unsigned int v86 = 2 * v49;
                        if (2 * (int)v49 >= (v49 + 1000000)) {
                          unsigned int v86 = v49 + 1000000;
                        }
                        if (v86 > v85) {
                          unsigned int v85 = v86;
                        }
                        if (v85 <= 8) {
                          uint64_t v49 = 8;
                        }
                        else {
                          uint64_t v49 = v85;
                        }
                        __int16 v111 = (char *)OOCAllocator_Realloc(a2, (uint64_t)v111, v49, &HeaderSizeInOutputBuffer);
                        if (HeaderSizeInOutputBuffer) {
                          return;
                        }
                        unsigned int v72 = &v111[v84];
                      }
                      cstdlib_memcpy(v72, v125, 4uLL);
                      v72 += 4;
                    }
                    uint64_t v87 = (unsigned int *)(v105 + 16 * v67);
                    if (v81 != v87)
                    {
                      uint64_t v88 = &v81[4 * v68];
                      do
                      {
                        long long v116 = 0uLL;
                        if (v81 == v88)
                        {
                          if (!*(_DWORD *)(v117 + 48)) {
                            break;
                          }
                          uint64_t v81 = *(unsigned int **)(v117 + 56);
                        }
                        long long v116 = *(_OWORD *)v81;
                        LODWORD(v116) = *(_DWORD *)(v120 + 4 * *v81);
                        uint64_t Type = FSTPackedArcGetType((unsigned int *)&v116);
                        unsigned int v90 = v72 - v111;
                        unsigned int v91 = v72 - v111 + 1;
                        if (v91 > v49)
                        {
                          unsigned int v92 = 2 * v49;
                          if (2 * (int)v49 >= (v49 + 1000000)) {
                            unsigned int v92 = v49 + 1000000;
                          }
                          if (v92 > v91) {
                            unsigned int v91 = v92;
                          }
                          if (v91 <= 8) {
                            uint64_t v49 = 8;
                          }
                          else {
                            uint64_t v49 = v91;
                          }
                          __int16 v111 = (char *)OOCAllocator_Realloc(a2, (uint64_t)v111, v49, &HeaderSizeInOutputBuffer);
                          if (HeaderSizeInOutputBuffer) {
                            return;
                          }
                          unsigned int v72 = &v111[v90];
                        }
                        *unsigned int v72 = Type;
                        uint64_t v93 = v72 + 1;
                        FSTPackedArcPackArc(Type, (int *)&v116, v125);
                        unsigned int ArcSize = FSTPacked_GetArcSize(Type);
                        unsigned int v95 = v93 - v111;
                        unsigned int v96 = ArcSize + v93 - v111;
                        if (v96 > v49)
                        {
                          unsigned int v97 = 2 * v49;
                          if (2 * (int)v49 >= (v49 + 1000000)) {
                            unsigned int v97 = v49 + 1000000;
                          }
                          if (v97 > v96) {
                            unsigned int v96 = v97;
                          }
                          if (v96 <= 8) {
                            uint64_t v49 = 8;
                          }
                          else {
                            uint64_t v49 = v96;
                          }
                          __int16 v111 = (char *)OOCAllocator_Realloc(a2, (uint64_t)v111, v49, &HeaderSizeInOutputBuffer);
                          if (HeaderSizeInOutputBuffer) {
                            return;
                          }
                          uint64_t v93 = &v111[v95];
                        }
                        cstdlib_memcpy(v93, v125, ArcSize);
                        unsigned int v72 = &v93[ArcSize];
                        v81 += 4;
                      }
                      while (v81 != v87);
                    }
LABEL_145:
                    unsigned int v76 = v72 - v111;
                    unsigned int v77 = v72 - v111 + 1;
                    if (v77 > v49)
                    {
                      unsigned int v78 = 2 * v49;
                      if (2 * (int)v49 >= (v49 + 1000000)) {
                        unsigned int v78 = v49 + 1000000;
                      }
                      if (v78 > v77) {
                        unsigned int v77 = v78;
                      }
                      if (v77 <= 8) {
                        uint64_t v49 = 8;
                      }
                      else {
                        uint64_t v49 = v77;
                      }
                      __int16 v111 = (char *)OOCAllocator_Realloc(a2, (uint64_t)v111, v49, &HeaderSizeInOutputBuffer);
                      if (HeaderSizeInOutputBuffer) {
                        return;
                      }
                      unsigned int v72 = &v111[v76];
                    }
                    *unsigned int v72 = 0;
                    unsigned int v64 = v72 + 1;
                  }
                  int v79 = *(_DWORD *)(v117 + 8);
                  if ((v79 & 0x3FFFFFF) == 1)
                  {
                    if ((v79 & 0x8000000) != 0) {
                      uint64_t v80 = *(void *)(v117 + 16);
                    }
                    else {
                      uint64_t v80 = 0;
                    }
                    int HeaderSizeInOutputBuffer = FSTStatePool_PushFSTState(v80, v117);
                    if (HeaderSizeInOutputBuffer) {
                      return;
                    }
                  }
                  else
                  {
                    *(_DWORD *)(v117 + 8) = v79 - 1;
                    if ((v79 & 0x3FFFFFF) == 0) {
                      return;
                    }
                    int HeaderSizeInOutputBuffer = 0;
                  }
                  if (++v110 > LODWORD(v122[0]))
                  {
                    uint64_t v50 = 0;
                    int v109 = 0;
                    int v104 = 0;
                    __dst = v111;
                    if (__srca) {
                      goto LABEL_92;
                    }
                    int HeaderSizeInOutputBuffer = (*(uint64_t (**)(uint64_t, unsigned int *))(*(void *)a3 + 48))(a3, &v118);
                    if (!HeaderSizeInOutputBuffer)
                    {
                      *(_DWORD *)(v115 + v123) = *(_DWORD *)(v120 + 4 * v118);
                      if (v31) {
                        OOCAllocator_Free(a2, v31);
                      }
                      if (v108) {
                        OOCAllocator_Free(a2, v108);
                      }
                      size_t v98 = (v64 - v111);
                      unsigned int v99 = (char *)OOCAllocator_Realloc(a2, v115, v98 + v112, &HeaderSizeInOutputBuffer);
                      cstdlib_memcpy(&v99[v114 + 4], v111, v98);
                      if (v111) {
                        OOCAllocator_Free(a2, (uint64_t)v111);
                      }
                      FSTPacked_Con((uint64_t)v113, a2, *(void *)(a3 + 48), v98 + v112, v99, a2);
                      int HeaderSizeInOutputBuffer = v100;
                      if (!v100)
                      {
                        cstdlib_memcpy(&v113[15], &v119, 0x18uLL);
                        v101.i32[0] = *(_DWORD *)(a3 + 44) & 0x3FFFF & *(_DWORD *)(a3 + 40);
                        v101.i32[1] = *(_DWORD *)(a3 + 44) & 0x3FFFF;
                        v113[5] = (int8x8_t)(*(void *)&vorr_s8(vand_s8(v113[5], (int8x8_t)0x300000003), v101) | 0x10000000100);
                      }
                    }
                    return;
                  }
                  continue;
                }
              }
            }
          }
        }
      }
    }
  }
}

uint64_t FSTPackedArcGetType(unsigned int *a1)
{
  unsigned int v1 = *a1;
  int v2 = a1[1];
  if (HIBYTE(*a1)) {
    char v3 = 3;
  }
  else {
    char v3 = 2;
  }
  if (v1 >= 0x10000) {
    unsigned __int8 v4 = v3;
  }
  else {
    unsigned __int8 v4 = 1;
  }
  if (v1 < 0x100) {
    unsigned __int8 v4 = 0;
  }
  if (HIWORD(v2)) {
    unsigned __int8 v5 = v4 | 0xC;
  }
  else {
    unsigned __int8 v5 = v4 | 8;
  }
  if (v2 <= 255) {
    unsigned __int8 v5 = v4 | 4;
  }
  if (v2 == -1) {
    unsigned __int8 v5 = v4 | 0xC;
  }
  if (v2 != -2) {
    unsigned __int8 v4 = v5;
  }
  int v6 = a1[2];
  int v7 = a1[3];
  if (HIWORD(v6)) {
    unsigned __int8 v8 = v4 | 0x30;
  }
  else {
    unsigned __int8 v8 = v4 | 0x20;
  }
  if (v6 <= 255) {
    unsigned __int8 v8 = v4 | 0x10;
  }
  if (v6 == -1) {
    unsigned __int8 v8 = v4 | 0x30;
  }
  if (v6 != -2) {
    unsigned __int8 v4 = v8;
  }
  if (HIWORD(v7)) {
    unsigned __int8 v9 = v4 | 0xC0;
  }
  else {
    unsigned __int8 v9 = v4 | 0x80;
  }
  if (v7 <= 255) {
    unsigned __int8 v9 = v4 | 0x40;
  }
  if (v7) {
    unsigned __int8 v4 = v9;
  }
  if (!v4) {
    return 4;
  }
  return v4;
}

uint64_t FSTPackedArcPackArc(uint64_t result, int *a2, unsigned char *a3)
{
  switch(result & 3)
  {
    case 1:
      int v3 = *a2;
      *a3 = BYTE1(*a2);
      unsigned __int8 v5 = a3 + 1;
      uint64_t v4 = 2;
      break;
    case 2:
      int v3 = *a2;
      *a3 = BYTE2(*a2);
      unsigned __int8 v5 = a3 + 2;
      a3[1] = BYTE1(v3);
      uint64_t v4 = 3;
      break;
    case 3:
      int v3 = *a2;
      *a3 = HIBYTE(*a2);
      a3[1] = BYTE2(v3);
      unsigned __int8 v5 = a3 + 3;
      a3[2] = BYTE1(v3);
      uint64_t v4 = 4;
      break;
    default:
      int v3 = *a2;
      uint64_t v4 = 1;
      unsigned __int8 v5 = a3;
      break;
  }
  int v6 = &a3[v4];
  unsigned char *v5 = v3;
  int v7 = result & 0xC;
  switch(v7)
  {
    case 12:
      int v8 = a2[1];
      unsigned char *v6 = HIBYTE(v8);
      v6[1] = BYTE2(v8);
      uint64_t v10 = v6 + 3;
      v6[2] = BYTE1(v8);
      uint64_t v9 = 4;
      break;
    case 8:
      int v8 = a2[1];
      unsigned char *v6 = BYTE1(v8);
      uint64_t v10 = v6 + 1;
      uint64_t v9 = 2;
      break;
    case 4:
      int v8 = a2[1];
      uint64_t v9 = 1;
      uint64_t v10 = v6;
      break;
    default:
      goto LABEL_13;
  }
  v6 += v9;
  *uint64_t v10 = v8;
LABEL_13:
  int v11 = result & 0x30;
  switch(v11)
  {
    case 48:
      int v12 = a2[2];
      unsigned char *v6 = HIBYTE(v12);
      v6[1] = BYTE2(v12);
      int v14 = v6 + 3;
      v6[2] = BYTE1(v12);
      uint64_t v13 = 4;
      break;
    case 32:
      int v12 = a2[2];
      unsigned char *v6 = BYTE1(v12);
      int v14 = v6 + 1;
      uint64_t v13 = 2;
      break;
    case 16:
      int v12 = a2[2];
      uint64_t v13 = 1;
      int v14 = v6;
      break;
    default:
      goto LABEL_20;
  }
  v6 += v13;
  *int v14 = v12;
LABEL_20:
  int v15 = result & 0xC0;
  switch(v15)
  {
    case 192:
      int v16 = a2[3];
      unsigned char *v6 = HIBYTE(v16);
      v6[1] = BYTE2(v16);
      v6[2] = BYTE1(v16);
      v6 += 3;
      break;
    case 128:
      int v16 = a2[3];
      *v6++ = BYTE1(v16);
      break;
    case 64:
      int v16 = a2[3];
      break;
    default:
      return result;
  }
  unsigned char *v6 = v16;
  return result;
}

uint64_t FSTPacked_GetArcSize(char a1)
{
  int v1 = a1 & 3;
  int v2 = v1 == 0;
  if (v1 == 1) {
    int v2 = 2;
  }
  if (v1 == 2) {
    v2 += 3;
  }
  if (v1 == 3) {
    unsigned int v3 = v2 + 4;
  }
  else {
    unsigned int v3 = v2;
  }
  int v4 = a1 & 0xC;
  if (v4 == 4) {
    ++v3;
  }
  if (v4 == 8) {
    v3 += 2;
  }
  if (v4 == 12) {
    v3 += 4;
  }
  int v5 = a1 & 0x30;
  if (v5 == 16) {
    ++v3;
  }
  if (v5 == 32) {
    v3 += 2;
  }
  if (v5 == 48) {
    v3 += 4;
  }
  int v6 = a1 & 0xC0;
  if (v6 == 64) {
    ++v3;
  }
  if (v6 == 128) {
    v3 += 2;
  }
  if (v6 == 192) {
    return v3 + 4;
  }
  else {
    return v3;
  }
}

uint64_t FSTPacked_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 128);
  if (v2) {
    OOCAllocator_Free(*(void *)(a1 + 24), v2);
  }

  return FSTBaseFlat_Des(a1);
}

uint64_t FSTPacked_FetchState(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t *a4)
{
  if (*(_DWORD *)(a1 + 112) <= a2) {
    signed int v7 = (*(unsigned __int8 *)(*(void *)(a1 + 88) + *(void *)(a1 + 80) + a2 + 4) << 24) & 0xF0000000;
  }
  else {
    signed int v7 = 0;
  }
  uint64_t result = FST_CheckQuery(v7, a3);
  if (result)
  {
    uint64_t v10 = *(void *)(a1 + 80);
    uint64_t v9 = *(void *)(a1 + 88);
    uint64_t v42 = 0;
    unsigned int v43 = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v42);
    if (v43) {
      return v43;
    }
    int v11 = (unsigned __int16 *)(v9 + v10 + a2 + 4);
    uint64_t v12 = v42;
    *(_DWORD *)(v42 + 8) |= v7;
    *(_DWORD *)(v12 + 24) = a2;
    *(_DWORD *)(v12 + 28) = ~(v7 >> 31) & 0x7FFFFFFF;
    *a4 = v12;
    if (*(_DWORD *)(a1 + 112) > a2)
    {
      uint64_t v13 = *(void *)(v12 + 56);
      if (!v13 || *(_DWORD *)(v13 - 4) <= 1u)
      {
        uint64_t v14 = _FSTState_ReserveArcsInternal(v12, 1u, &v43);
        if (v43) {
          return v43;
        }
        uint64_t v13 = v14;
      }
      *(_DWORD *)(v42 + 48) = 1;
      *(_DWORD *)(v13 + 4) = __rev16(*v11);
      int v15 = *((char *)v11 + 2);
      if (v15 < 0) {
        int v16 = ((v15 & 0x7F) << 24) | (*((unsigned __int8 *)v11 + 3) << 16) | (*((unsigned __int8 *)v11 + 4) << 8) | *((unsigned __int8 *)v11 + 5);
      }
      else {
        int v16 = a2 + 2;
      }
      *(_DWORD *)uint64_t v13 = v16;
      *(void *)(v13 + 8) = 4294967294;
      return v43;
    }
    if (v7 >= 0) {
      unint64_t v17 = (unsigned __int8 *)v11 + 1;
    }
    else {
      unint64_t v17 = (unsigned __int8 *)v11 + 5;
    }
    char v18 = *v17;
    if (!*v17) {
      return v43;
    }
    unsigned int v19 = 0;
    unsigned int v20 = 0;
    while (1)
    {
      if ((v18 & 3) == 2)
      {
        int v21 = (v17[1] << 16) | (v17[2] << 8) | v17[3];
        v17 += 4;
      }
      else if ((v18 & 3) == 1)
      {
        int v21 = __rev16(*(unsigned __int16 *)(v17 + 1));
        v17 += 3;
      }
      else if ((v18 & 3) != 0)
      {
        int v21 = bswap32(*(_DWORD *)(v17 + 1));
        v17 += 5;
      }
      else
      {
        int v21 = v17[1];
        v17 += 2;
      }
      int v22 = v18 & 0xC;
      switch(v22)
      {
        case 4:
          unsigned int v25 = *v17++;
          unsigned int v24 = v25;
          break;
        case 12:
          unsigned int v26 = *(_DWORD *)v17;
          v17 += 4;
          unsigned int v24 = bswap32(v26);
          break;
        case 8:
          unsigned int v23 = *(unsigned __int16 *)v17;
          v17 += 2;
          unsigned int v24 = __rev16(v23);
          break;
        default:
          unsigned int v24 = -2;
          break;
      }
      int v27 = v18 & 0x30;
      if ((v18 & 0x30) != 0)
      {
        if (v27 == 32)
        {
          unsigned int v30 = *(unsigned __int16 *)v17;
          v17 += 2;
          unsigned int v29 = __rev16(v30);
        }
        else if (v27 == 48)
        {
          unsigned int v28 = *(_DWORD *)v17;
          v17 += 4;
          unsigned int v29 = bswap32(v28);
        }
        else
        {
          unsigned int v31 = *v17++;
          unsigned int v29 = v31;
        }
      }
      else
      {
        unsigned int v29 = -2;
      }
      int v32 = v18 & 0xC0;
      if ((v18 & 0xC0) != 0)
      {
        if (v32 == 128)
        {
          unsigned int v34 = *(unsigned __int16 *)v17;
          v17 += 2;
          int v32 = __rev16(v34);
        }
        else if (v32 == 64)
        {
          int v33 = *v17++;
          int v32 = v33;
        }
        else
        {
          unsigned int v35 = *(_DWORD *)v17;
          v17 += 4;
          int v32 = bswap32(v35);
        }
      }
      if (v24 != -2)
      {
        uint64_t v38 = *(void *)(v12 + 56);
        if (v38)
        {
          unsigned int v39 = v19 + 1;
          if (*(_DWORD *)(v38 - 4) > v19 + 1) {
            goto LABEL_60;
          }
        }
        else
        {
          unsigned int v39 = v19 + 1;
        }
        _FSTState_ReserveArcsInternal(v12, v39, &v43);
LABEL_60:
        if (v43) {
          return v43;
        }
        uint64_t v12 = v42;
        uint64_t v41 = (int *)(*(void *)(v42 + 56) + 16 * v19);
        *uint64_t v41 = v21;
        v41[1] = v24;
        v41[2] = v29;
        v41[3] = v32;
        *(_DWORD *)(v12 + 48) = ++v19;
        goto LABEL_62;
      }
      uint64_t v36 = *(void *)(v12 + 40);
      if (v36)
      {
        unsigned int v37 = v20 + 1;
        if (*(_DWORD *)(v36 - 4) > v20 + 1) {
          goto LABEL_56;
        }
      }
      else
      {
        unsigned int v37 = v20 + 1;
      }
      uint64_t v36 = _FSTState_ReserveEpsilonArcsInternal(v12, v37, &v43);
LABEL_56:
      if (v43) {
        return v43;
      }
      int v40 = (int *)(v36 + 16 * v20);
      *int v40 = v21;
      v40[1] = -2;
      v40[2] = v29;
      v40[3] = v32;
      ++v20;
      uint64_t v12 = v42;
      *(_DWORD *)(v42 + 32) = v20;
LABEL_62:
      char v18 = *v17;
      if (!*v17) {
        return v43;
      }
    }
  }
  *a4 = 0;
  return result;
}

uint64_t FSTPacked_FillBuffer(uint64_t a1, char *a2, unint64_t *a3)
{
  uint64_t v10 = 0;
  uint64_t v6 = *(void *)(a1 + 80);
  uint64_t result = FST_GetHeaderSizeInOutputBuffer(&v10);
  if (!result)
  {
    uint64_t v8 = v6 - 16;
    unint64_t v9 = *(void *)(a1 + 72) - (v6 - 16) + v10;
    if (!a2)
    {
LABEL_7:
      uint64_t result = 0;
      *a3 = v9;
      return result;
    }
    if (*a3 < v9) {
      return err_GenerateErrorData();
    }
    uint64_t result = FST_FillHeader((_DWORD *)a1, a2, *(_DWORD *)(a1 + 104), &v10);
    if (!result)
    {
      cstdlib_memcpy(&a2[v10], (const void *)(*(void *)(a1 + 88) + v8), v9 - v10);
      goto LABEL_7;
    }
  }
  return result;
}

uint64_t FSTPacked_GetFinalStateWeight(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  *a3 = 0x7FFFFFFF;
  if (*(_DWORD *)(a1 + 112) <= a2 && *(char *)(*(void *)(a1 + 88) + *(void *)(a1 + 80) + a2 + 4) < 0) {
    *a3 = 0;
  }
  return 0;
}

uint64_t FSTPacked_GetMappedStateId(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 128);
  if (((unint64_t)(*(void *)(a1 + 136) - v2) >> 2) <= a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *(unsigned int *)(v2 + 4 * a2);
  }
}

uint64_t FSTPacked_GetMaxStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = -1;
  return 0;
}

uint64_t FSTPacked_GetStateFlags(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  if (*(_DWORD *)(a1 + 112) <= a2) {
    unsigned int v3 = (*(unsigned __int8 *)(*(void *)(a1 + 88) + *(void *)(a1 + 80) + a2 + 4) << 24) & 0xF0000000;
  }
  else {
    unsigned int v3 = 0;
  }
  *a3 = v3;
  return 0;
}

uint64_t FSTPacked_Reset(uint64_t a1)
{
  unsigned int v3 = (void *)(a1 + 128);
  uint64_t v2 = *(void *)(a1 + 128);
  if (v2) {
    OOCAllocator_Free(*(void *)(a1 + 24), v2);
  }
  *(_DWORD *)(a1 + 120) = 0;
  *unsigned int v3 = 0;
  v3[1] = 0;
  return 0;
}

void PNEW_FSTPacked_Con(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, char *a5, uint64_t a6, uint64_t *a7)
{
  int v16 = 0;
  uint64_t v14 = OOCAllocator_Malloc(a1, 144, &v16);
  if (!v16)
  {
    FSTPacked_Con(v14, a2, a3, a4, a5, a6);
    int v16 = v15;
    if (v15)
    {
      OOCAllocator_Free(a1, v14);
      *a7 = 0;
    }
    else
    {
      *(void *)(v14 + 16) = a1;
      *a7 = v14;
    }
  }
}

void PNEW_FSTPacked_ConFromFST(uint64_t a1, uint64_t a2, uint64_t a3, int8x8_t **a4)
{
  int v10 = 0;
  uint64_t v8 = (int8x8_t *)OOCAllocator_Malloc(a1, 144, &v10);
  if (!v10)
  {
    FSTPacked_ConFromFST(v8, a2, a3);
    int v10 = v9;
    if (v9)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
    }
    else
    {
      v8[2] = (int8x8_t)a1;
      *a4 = v8;
    }
  }
}

void *GetFSTPackedClass()
{
  return &__FSTPacked;
}

void FSTInject_Con(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  FST_Con((void *)a1, a2, *(void *)(a3 + 48));
  if (!v10)
  {
    *(void *)a1 = &__FSTInject;
    *(_DWORD *)(a1 + 220) = 0;
    __FSTInject_InternalConstructor(a1, a2, (_DWORD *)a3, a4, a5);
  }
}

uint64_t __FSTInject_InternalConstructor(uint64_t a1, uint64_t a2, _DWORD *a3, unsigned int a4, int a5)
{
  uint64_t v20 = 0;
  *(_DWORD *)(a1 + 32) = 14;
  *(_DWORD *)(a1 + 36) = a3[9];
  (*(void (**)(_DWORD *))(*(void *)a3 + 24))(a3);
  *(void *)(a1 + 64) = a3;
  *(_DWORD *)(a1 + 72) = a4;
  int v10 = (void *)OOCAllocator_Malloc(a2, 56 * a4, (_DWORD *)&v20 + 1);
  *(void *)(a1 + 80) = v10;
  uint64_t result = HIDWORD(v20);
  if (!HIDWORD(v20))
  {
    cstdlib_memset(v10, 0, 56 * *(unsigned int *)(a1 + 72));
    *(_DWORD *)(a1 + 160) = 5;
    uint64_t v12 = OOCAllocator_Malloc(a2, 20, (_DWORD *)&v20 + 1);
    *(void *)(a1 + 168) = v12;
    uint64_t result = HIDWORD(v20);
    if (!HIDWORD(v20))
    {
      uint64_t v13 = *(unsigned int *)(a1 + 160);
      unint64_t v14 = v12 + 4 * v13;
      *(void *)(a1 + 176) = v14;
      if (v13)
      {
        if (v14 <= v12 + 4) {
          unint64_t v14 = v12 + 4;
        }
        memset((void *)v12, 255, ((v14 + ~v12) & 0xFFFFFFFFFFFFFFFCLL) + 4);
      }
      *(_DWORD *)(a1 + 184) = 0;
      *(void *)(a1 + 192) = 0;
      *(void *)(a1 + 200) = 0;
      *(_DWORD *)(a1 + 208) = -1;
      uint64_t result = dpmemblock_Create(a2, 12, 0xAu, (uint64_t *)(a1 + 88));
      HIDWORD(v20) = result;
      if (!result)
      {
        *(_DWORD *)(a1 + 96) = 5;
        uint64_t v15 = OOCAllocator_Malloc(a2, 20, (_DWORD *)&v20 + 1);
        *(void *)(a1 + 104) = v15;
        uint64_t result = HIDWORD(v20);
        if (!HIDWORD(v20))
        {
          uint64_t v16 = *(unsigned int *)(a1 + 96);
          unint64_t v17 = v15 + 4 * v16;
          *(void *)(a1 + 112) = v17;
          if (v16)
          {
            if (v17 <= v15 + 4) {
              unint64_t v17 = v15 + 4;
            }
            memset((void *)v15, 255, ((v17 + ~v15) & 0xFFFFFFFFFFFFFFFCLL) + 4);
          }
          *(_DWORD *)(a1 + 120) = 0;
          *(void *)(a1 + 128) = 0;
          *(void *)(a1 + 136) = 0;
          *(_DWORD *)(a1 + 144) = -1;
          uint64_t result = (*(uint64_t (**)(void, uint64_t *))(**(void **)(a1 + 64) + 72))(*(void *)(a1 + 64), &v20);
          HIDWORD(v20) = result;
          if (!result)
          {
            int v18 = v20;
            if (v20 != -1)
            {
LABEL_15:
              *(_DWORD *)(a1 + 152) = v18;
              *(_DWORD *)(a1 + 228) = a5;
              return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 112))(a1);
            }
            memset(v19, 0, sizeof(v19));
            uint64_t result = FSTCount(a2, *(void *)(a1 + 64), (uint64_t)v19);
            HIDWORD(v20) = result;
            if (!result)
            {
              int v18 = v19[0];
              LODWORD(v20) = v19[0];
              goto LABEL_15;
            }
          }
        }
      }
    }
  }
  return result;
}

void FSTInject_ConAllInstancesActive(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  FST_Con((void *)a1, a2, *(void *)(a3 + 48));
  if (!v10)
  {
    *(void *)a1 = &__FSTInject;
    *(_DWORD *)(a1 + 220) = 1;
    __FSTInject_InternalConstructor(a1, a2, (_DWORD *)a3, a4, a5);
  }
}

uint64_t FSTInject_Des(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 32))(*(void *)(a1 + 64));
  if (!result)
  {
    uint64_t v3 = *(void *)(a1 + 80);
    if (v3)
    {
      if (*(_DWORD *)(a1 + 72))
      {
        uint64_t v4 = 0;
        unint64_t v5 = 0;
        do
        {
          uint64_t v6 = *(void *)(a1 + 80);
          uint64_t v7 = *(void *)(v6 + v4);
          if (v7)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 32))(v7);
            if (result) {
              return result;
            }
            uint64_t v6 = *(void *)(a1 + 80);
          }
          uint64_t v8 = *(void *)(v6 + v4 + 48);
          if (v8) {
            OOCAllocator_Free(*(void *)(a1 + 24), v8);
          }
          ++v5;
          v4 += 56;
        }
        while (v5 < *(unsigned int *)(a1 + 72));
        uint64_t v3 = *(void *)(a1 + 80);
      }
      OOCAllocator_Free(*(void *)(a1 + 24), v3);
    }
    dpmemblock_Free(*(uint64_t **)(a1 + 88));
    uint64_t v9 = *(void *)(a1 + 104);
    if (v9) {
      OOCAllocator_Free(*(void *)(a1 + 24), v9);
    }
    uint64_t v10 = *(void *)(a1 + 128);
    if (v10) {
      OOCAllocator_Free(*(void *)(a1 + 24), v10);
    }
    uint64_t v11 = *(void *)(a1 + 168);
    if (v11) {
      OOCAllocator_Free(*(void *)(a1 + 24), v11);
    }
    uint64_t v12 = *(void *)(a1 + 192);
    if (v12) {
      OOCAllocator_Free(*(void *)(a1 + 24), v12);
    }
    return FST_Des(a1);
  }
  return result;
}

uint64_t FSTInject_BorrowComponentFst(uint64_t a1, int a2)
{
  if (!a2)
  {
    uint64_t v2 = a1 + 64;
    return *(void *)v2;
  }
  if ((a2 - 1) < *(_DWORD *)(a1 + 72))
  {
    uint64_t v2 = *(void *)(a1 + 80) + 56 * (a2 - 1);
    return *(void *)v2;
  }
  return 0;
}

double FSTInject_ClearGroupFst(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 80) + 56 * a2);
  if (v3)
  {
    if (!(*(unsigned int (**)(uint64_t))(*(void *)v3 + 32))(v3))
    {
      uint64_t v6 = (void *)(*(void *)(a1 + 80) + 56 * a2);
      void *v6 = 0;
      v6[3] = 0;
      v6[4] = 0;
      double result = NAN;
      v6[1] = -1;
    }
  }
  return result;
}

uint64_t FSTInject_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  long long v36 = 0uLL;
  uint64_t v35 = 0;
  if (*(_DWORD *)(a1 + 152) >= a2)
  {
    unint64_t v17 = (unsigned int *)(*(void *)(a1 + 168)
                         + 4
                         * (a2 % ((*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 2)));
    while (1)
    {
      unsigned int v18 = *v17;
      if ((*v17 & 0x80000000) != 0) {
        break;
      }
      unint64_t v17 = (unsigned int *)(*(void *)(a1 + 192) + 12 * v18);
      if (v17[1] == a2) {
        goto LABEL_23;
      }
    }
    if (v18 == -1)
    {
      uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, a3, &v35);
      if (result) {
        return result;
      }
      goto LABEL_43;
    }
LABEL_23:
    if (a3) {
      a3 = 8;
    }
    else {
      a3 = a3;
    }
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, a3, &v35);
    if (!result)
    {
      uint64_t v19 = v35;
      if (!v35) {
        goto LABEL_43;
      }
      unsigned int v20 = *(_DWORD *)(*(void *)(a1 + 192) + 12 * (int)v18 + 8);
      int v21 = *(_DWORD *)(v35 + 8);
      if ((v21 & 0x3FFFFFE) != 0)
      {
        uint64_t v34 = 0;
        uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v34);
        if (result) {
          return result;
        }
        uint64_t result = FSTState_Copy(v34, v35);
        if (result) {
          return result;
        }
        int v22 = *(_DWORD *)(v35 + 8);
        *(_DWORD *)(v35 + 8) = v22 - 1;
        if ((v22 & 0x3FFFFFF) == 0) {
          return 9;
        }
        uint64_t v19 = v34;
        uint64_t v35 = v34;
        int v21 = *(_DWORD *)(v34 + 8);
      }
      *(_DWORD *)(v19 + 8) = v21 | 0x50000000;
      if (v20 == -1) {
        goto LABEL_43;
      }
      while (1)
      {
        uint64_t v24 = *(void *)(a1 + 80);
        uint64_t v23 = *(void *)(a1 + 88);
        unsigned int v25 = (unsigned int *)(*(void *)(*(void *)(v23 + 8) + 8 * (v20 >> *(_WORD *)(v23 + 44)))
                             + (v20 - (v20 >> *(_WORD *)(v23 + 44) << *(_WORD *)(v23 + 44))) * *(_DWORD *)(v23 + 16));
        unsigned int v26 = *v25;
        if (*(void *)(v24 + 56 * *v25))
        {
          uint64_t v27 = v24 + 56 * v26;
          int v30 = *(_DWORD *)(v27 + 16);
          unsigned int v29 = (void *)(v27 + 16);
          int v28 = v30;
          uint64_t v31 = v29[4];
          uint64_t v32 = v25[1];
          LODWORD(v34) = 0;
          uint64_t result = __FSTInject_ActivateGroupInstance(a1, v26, v32, &v34);
          if (result) {
            break;
          }
          int v33 = v28 == -2 ? 2 : 4;
          *(void *)((char *)&v36 + 4) = *v29;
          HIDWORD(v36) = *(_DWORD *)(v31 + 8 * v32 + 4);
          LODWORD(v36) = v34 + *(_DWORD *)(v24 + 56 * v26 + 8);
          uint64_t result = FSTState_AddArcs(v35, v33, (uint64_t)&v36, 1u);
          if (result) {
            break;
          }
        }
        unsigned int v20 = v25[2];
        if (v20 == -1) {
          goto LABEL_43;
        }
      }
    }
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 128);
    uint64_t v7 = *(void *)(a1 + 136);
    unint64_t v8 = v7 - v6;
    if (v7 - v6 >= 21)
    {
      do
      {
        uint64_t v9 = v6 + 20 * (v8 / 0x28);
        if (*(_DWORD *)(v9 + 16) > a2) {
          uint64_t v7 = v9;
        }
        else {
          uint64_t v6 = v9;
        }
        unint64_t v8 = v7 - v6;
      }
      while (v7 - v6 > 20);
    }
    uint64_t v10 = *(void *)(a1 + 80);
    unsigned int v11 = *(_DWORD *)(v6 + 4);
    uint64_t v12 = v10 + 56 * v11;
    uint64_t v13 = (_DWORD *)(*(void *)(v12 + 48) + 8 * *(unsigned int *)(v6 + 12));
    if (*v13 != -1 && a3 == 1) {
      LODWORD(a3) = 5;
    }
    BOOL v15 = *v13 != -1 && a3 == 4;
    if (v15
      || (uint64_t result = (*(uint64_t (**)(void))(**(void **)(v10 + 56 * v11) + 120))(*(void *)(v10 + 56 * v11)),
          !result))
    {
LABEL_43:
      uint64_t result = 0;
      *a4 = v35;
    }
  }
  return result;
}

uint64_t __FSTInject_ActivateGroupInstance(uint64_t a1, unsigned int a2, unsigned int a3, _DWORD *a4)
{
  unsigned int v54 = 0;
  uint64_t v8 = *(void *)(a1 + 80);
  uint64_t v9 = (uint64_t *)(v8 + 56 * a2);
  int v10 = *(_DWORD *)(v9[6] + 8 * a3);
  unsigned int v11 = v10 + 2309 * a2;
  uint64_t v12 = *(unsigned int **)(a1 + 104);
  unint64_t v13 = *(void *)(a1 + 112) - (void)v12;
  uint64_t v14 = v11 % (v13 >> 2);
  uint64_t v15 = v12[v14];
  if ((v15 & 0x80000000) != 0)
  {
LABEL_6:
    signed int v17 = *(_DWORD *)(a1 + 144);
    if (v17 == -1)
    {
      uint64_t v19 = *(void *)(a1 + 128);
      int v21 = *(_DWORD **)(a1 + 136);
      uint64_t v22 = ((uint64_t)v21 - v19) >> 2;
      signed int v17 = -858993459 * v22;
      unsigned int v23 = 2 * (v13 >> 2);
      if (v23 >= -858993459 * (int)v22)
      {
        unsigned int v29 = -858993459 * v22;
      }
      else
      {
        unsigned int v24 = v23 | 1;
        uint64_t v25 = *(unsigned int *)(a1 + 96);
        if (v24 <= v25)
        {
          uint64_t v26 = 4 * v25;
        }
        else
        {
          if (v24 <= 8) {
            unsigned int v24 = 8;
          }
          unsigned int v51 = v24;
          uint64_t v26 = 4 * v24;
          uint64_t v27 = OOCAllocator_Realloc(*(void *)(a1 + 24), (uint64_t)v12, v26, &v54);
          *(void *)(a1 + 104) = v27;
          if (v54) {
            return v54;
          }
          uint64_t v12 = (unsigned int *)v27;
          *(_DWORD *)(a1 + 96) = v51;
          v13 &= 0x3FFFFFFFCuLL;
        }
        unint64_t v30 = (v13 >> 1) & 0xFFFFFFFE | 1;
        *(void *)(a1 + 112) = &v12[v30];
        cstdlib_memset(v12, 255, v26);
        uint64_t v19 = *(void *)(a1 + 128);
        int v21 = *(_DWORD **)(a1 + 136);
        unsigned int v29 = -858993459 * (((uint64_t)v21 - v19) >> 2);
        if (v29)
        {
          uint64_t v31 = 0;
          uint64_t v32 = *(_DWORD **)(a1 + 128);
          do
          {
            if (((*v32 + 1) & 0x40000000) == 0)
            {
              if (v54) {
                return v54;
              }
              unint64_t v33 = (v32[2] + 2309 * v32[1]);
              uint64_t v34 = v33 - (v33 / v30) * (unint64_t)v30;
              uint64_t v35 = *(void *)(a1 + 104);
              *uint64_t v32 = *(_DWORD *)(v35 + 4 * v34);
              *(_DWORD *)(v35 + 4 * v34) = v31;
            }
            ++v31;
            v32 += 5;
          }
          while (-858993459 * (((uint64_t)v21 - v19) >> 2) != v31);
          signed int v17 = -858993459 * (((uint64_t)v21 - v19) >> 2);
        }
        else
        {
          signed int v17 = 0;
        }
      }
      unsigned int v36 = v17 + 1;
      unsigned int v37 = *(_DWORD *)(a1 + 120);
      if (v17 + 1 > v37)
      {
        unsigned int v38 = 2 * v37;
        unsigned int v39 = v37 + 1000000;
        if (v38 >= v39) {
          unsigned int v38 = v39;
        }
        if (v38 > v36) {
          unsigned int v36 = v38;
        }
        if (v36 <= 8) {
          unsigned int v40 = 8;
        }
        else {
          unsigned int v40 = v36;
        }
        unsigned int v52 = v40;
        unsigned int v41 = v29;
        uint64_t v42 = OOCAllocator_Realloc(*(void *)(a1 + 24), v19, 20 * v40, &v54);
        *(void *)(a1 + 128) = v42;
        if (v54) {
          return v54;
        }
        uint64_t v19 = v42;
        *(_DWORD *)(a1 + 120) = v52;
        int v21 = (_DWORD *)(v42 + 20 * v41);
      }
      *(void *)(a1 + 136) = v21 + 5;
      *int v21 = 0;
      v21[1] = a2;
      v21[2] = v10;
      v21[3] = a3;
      v21[4] = 0;
      uint64_t v12 = *(unsigned int **)(a1 + 104);
      signed int v18 = v17;
      uint64_t v14 = v11 % ((*(void *)(a1 + 112) - (void)v12) >> 2);
    }
    else
    {
      signed int v18 = *(_DWORD *)(a1 + 144);
      uint64_t v19 = *(void *)(a1 + 128);
      uint64_t v20 = v19 + 20 * v17;
      *(_DWORD *)(a1 + 144) = (*(_DWORD *)v20 & 0xBFFFFFFF) - 1;
      *(_DWORD *)uint64_t v20 = 0;
      *(_DWORD *)(v20 + 4) = a2;
      *(_DWORD *)(v20 + 8) = v10;
      *(void *)(v20 + 12) = a3;
    }
    unsigned int v43 = (_DWORD *)(v19 + 20 * v18);
    _DWORD *v43 = v12[v14];
    v12[v14] = v17;
    int v45 = v43[4];
    uint64_t v44 = v43 + 4;
    *a4 = v45;
    *a4 = *(_DWORD *)(a1 + 216);
    *uint64_t v44 = *(_DWORD *)(a1 + 216);
    if (!*v9) {
      return v54;
    }
    uint64_t v46 = v8 + 56 * a2;
    int v49 = *(_DWORD *)(v46 + 12);
    uint64_t v48 = (int *)(v46 + 12);
    int v47 = v49;
    if (v49 == -1)
    {
      unsigned int v54 = (*(uint64_t (**)(uint64_t, int *))(*(void *)*v9 + 72))(*v9, v48);
      if (v54 || ((*(uint64_t (**)(uint64_t))(*(void *)*v9 + 168))(*v9) & 1) != 0) {
        return v54;
      }
      int v47 = *v48;
      if (*v48 == -1)
      {
        memset(v53, 0, sizeof(v53));
        unsigned int v54 = FSTCount(*(void *)(a1 + 24), *v9, (uint64_t)v53);
        if (v54) {
          return v54;
        }
        int v47 = v53[0];
        *uint64_t v48 = v53[0];
      }
    }
    if (__CFADD__(*v44, v47))
    {
      _FST_SetStatus(a1, 1);
    }
    else
    {
      *(_DWORD *)(a1 + 224) = v47 + *v44;
      *(_DWORD *)(a1 + 216) += v47 + 1;
    }
    return v54;
  }
  uint64_t v16 = *(void *)(a1 + 128);
  while (*(_DWORD *)(v16 + 20 * v15 + 4) != a2 || v10 != *(_DWORD *)(v16 + 20 * v15 + 8))
  {
    uint64_t v15 = *(unsigned int *)(v16 + 20 * v15);
    if ((v15 & 0x80000000) != 0) {
      goto LABEL_6;
    }
  }
  uint64_t v28 = v16 + 20 * v15;
  *a4 = *(_DWORD *)(v28 + 16);
  *a4 = *(_DWORD *)(v28 + 16);
  return v54;
}

uint64_t FSTInject_FillBuffer()
{
  return err_GenerateErrorNotSupported();
}

uint64_t FSTInject_GetFinalStateWeight(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *a3 = 0x7FFFFFFF;
  if (*(_DWORD *)(a1 + 152) >= a2)
  {
    uint64_t v10 = *(void *)(a1 + 64);
  }
  else
  {
    uint64_t v3 = *(char **)(a1 + 128);
    uint64_t v4 = *(char **)(a1 + 136);
    unint64_t v5 = v4 - v3;
    if (v4 - v3 >= 21)
    {
      do
      {
        uint64_t v6 = &v3[20 * (v5 / 0x28)];
        if (*((_DWORD *)v6 + 4) > a2) {
          uint64_t v4 = v6;
        }
        else {
          uint64_t v3 = v6;
        }
        unint64_t v5 = v4 - v3;
      }
      while (v4 - v3 > 20);
    }
    uint64_t v7 = *(void *)(a1 + 80);
    unsigned int v8 = *((_DWORD *)v3 + 1);
    if (*(_DWORD *)(*(void *)(v7 + 56 * v8 + 48) + 8 * *((unsigned int *)v3 + 3)) != -1) {
      return 0;
    }
    uint64_t v10 = *(void *)(v7 + 56 * v8);
    a2 = (a2 - *((_DWORD *)v3 + 4));
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 64))(v10, a2);
}

uint64_t FSTInject_GetInitialStateId(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 48))(*(void *)(a1 + 64));
}

uint64_t FSTInject_GetMaxBranchFactor(uint64_t a1, unsigned int *a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 136))(*(void *)(a1 + 64));
  if (!result)
  {
    unint64_t v5 = *(unsigned int *)(a1 + 72);
    if (v5)
    {
      uint64_t v6 = 0;
      for (unint64_t i = 0; i < v5; ++i)
      {
        uint64_t v8 = *(void *)(*(void *)(a1 + 80) + v6);
        if (v8)
        {
          unsigned int v9 = 0;
          uint64_t result = (*(uint64_t (**)(uint64_t, unsigned int *))(*(void *)v8 + 136))(v8, &v9);
          if (result) {
            return result;
          }
          if (v9 > *a2) {
            *a2 = v9;
          }
          unint64_t v5 = *(unsigned int *)(a1 + 72);
        }
        v6 += 56;
      }
    }
    return 0;
  }
  return result;
}

uint64_t FSTInject_GetMaxNbrComponentFsts(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 72) + 1);
}

uint64_t FSTInject_GetMaxStateId(_DWORD *a1, int *a2)
{
  if (a1[55] || (uint64_t result = __FSTInject_ActivateAllGroupInstances((uint64_t)a1), !result))
  {
    if ((*(uint64_t (**)(_DWORD *))(*(void *)a1 + 168))(a1)) {
      int v5 = -1;
    }
    else {
      int v5 = a1[56];
    }
    uint64_t result = 0;
    *a2 = v5;
  }
  return result;
}

uint64_t __FSTInject_ActivateAllGroupInstances(uint64_t a1)
{
  unint64_t v1 = *(unsigned int *)(a1 + 72);
  if (!v1) {
    return 0;
  }
  uint64_t v3 = 0;
  uint64_t v4 = *(void *)(a1 + 80);
  while (!*(_DWORD *)(v4 + 56 * v3 + 40))
  {
LABEL_9:
    if (++v3 >= v1) {
      return 0;
    }
  }
  unsigned int v5 = 0;
  while (1)
  {
    uint64_t result = __FSTInject_ActivateGroupInstance(a1, v3, v5, &v7);
    if (result) {
      return result;
    }
    if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 168))(a1)) {
      return 0;
    }
    ++v5;
    uint64_t v4 = *(void *)(a1 + 80);
    if (v5 >= *(_DWORD *)(v4 + 56 * v3 + 40))
    {
      unint64_t v1 = *(unsigned int *)(a1 + 72);
      goto LABEL_9;
    }
  }
}

unint64_t FSTInject_GetMemoryInfo(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 72);
  unint64_t v3 = 12 * *(unsigned int *)(a1 + 184)
     + 56 * v2
     + 20 * *(unsigned int *)(a1 + 120)
     + 4 * (*(unsigned int *)(a1 + 96) + (unint64_t)*(unsigned int *)(a1 + 160))
     + (*(_DWORD *)(*(void *)(a1 + 88) + 20)
                    * *(_DWORD *)(*(void *)(a1 + 88) + 24)
                    * *(_DWORD *)(*(void *)(a1 + 88) + 16))
     + 48;
  if (v2)
  {
    uint64_t v4 = (unsigned int *)(*(void *)(a1 + 80) + 40);
    do
    {
      unsigned int v5 = *v4;
      v4 += 14;
      v3 += 8 * v5;
      --v2;
    }
    while (v2);
  }
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 96))(*(void *)(a1 + 64));
  uint64_t v8 = v6 + v7;
  unint64_t v9 = *(unsigned int *)(a1 + 72);
  if (v9)
  {
    uint64_t v10 = 0;
    for (unint64_t i = 0; i < v9; ++i)
    {
      uint64_t v12 = *(void *)(*(void *)(a1 + 80) + v10);
      if (v12)
      {
        uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 96))(v12);
        v8 += v14 + v13;
        unint64_t v9 = *(unsigned int *)(a1 + 72);
      }
      v10 += 56;
    }
  }
  return v3;
}

uint64_t FSTInject_GetStateFlags(uint64_t a1, uint64_t a2, int *a3)
{
  unsigned int v4 = a2;
  *a3 = 0;
  if (*(_DWORD *)(a1 + 152) >= a2)
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t, int *))(**(void **)(a1 + 64) + 56))(*(void *)(a1 + 64), a2, a3);
    if (result) {
      return result;
    }
    signed int v17 = (unsigned int *)(*(void *)(a1 + 168)
                         + 4 * (v4 % ((*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 2)));
    while (1)
    {
      unsigned int v18 = *v17;
      if ((*v17 & 0x80000000) != 0) {
        return 0;
      }
      uint64_t v19 = *(void *)(a1 + 192);
      signed int v17 = (unsigned int *)(v19 + 12 * v18);
      if (v17[1] == v4)
      {
        unsigned int v20 = *(_DWORD *)(v19 + 12 * v18 + 8);
        int v16 = *a3;
        *a3 |= 0x50000000u;
        if (v20 == -1) {
          return 0;
        }
        uint64_t v21 = *(void *)(a1 + 80);
        uint64_t v22 = *(void *)(a1 + 88);
        uint64_t v23 = *(void *)(v22 + 8);
        __int16 v24 = *(_WORD *)(v22 + 44);
        int v25 = *(_DWORD *)(v22 + 16);
        while (1)
        {
          uint64_t v26 = (unsigned int *)(*(void *)(v23 + 8 * (v20 >> v24)) + (v20 - (v20 >> v24 << v24)) * v25);
          if (*(void *)(v21 + 56 * *v26))
          {
            if (*(_DWORD *)(v21 + 56 * *v26 + 16) == -2) {
              break;
            }
          }
          unsigned int v20 = v26[2];
          if (v20 == -1) {
            return 0;
          }
        }
        goto LABEL_11;
      }
    }
  }
  uint64_t v6 = *(char **)(a1 + 128);
  uint64_t v7 = *(char **)(a1 + 136);
  unint64_t v8 = v7 - v6;
  if (v7 - v6 >= 21)
  {
    do
    {
      unint64_t v9 = &v6[20 * (v8 / 0x28)];
      if (*((_DWORD *)v9 + 4) > a2) {
        uint64_t v7 = v9;
      }
      else {
        uint64_t v6 = v9;
      }
      unint64_t v8 = v7 - v6;
    }
    while (v7 - v6 > 20);
  }
  uint64_t v10 = *(void *)(a1 + 80);
  unsigned int v11 = *((_DWORD *)v6 + 1);
  uint64_t v12 = (void *)(v10 + 56 * v11);
  uint64_t v13 = v12[6];
  uint64_t v14 = *((unsigned int *)v6 + 3);
  uint64_t result = (*(uint64_t (**)(void, void, int *))(*(void *)*v12 + 56))(*v12, (a2 - *((_DWORD *)v6 + 4)), a3);
  if (!result)
  {
    if (*a3 < 0 && *(_DWORD *)(v13 + 8 * v14) != -1)
    {
      int v16 = *a3 & 0x2FFFFFFF;
      *a3 = v16 | 0x50000000;
      if (*(_DWORD *)(v10 + 56 * v11 + 16) == -2)
      {
LABEL_11:
        uint64_t result = 0;
        *a3 = v16 | 0x70000000;
        return result;
      }
    }
    return 0;
  }
  return result;
}

uint64_t FSTInject_GetStatus(uint64_t a1)
{
  unint64_t v2 = *(unsigned int *)(a1 + 72);
  if (v2)
  {
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    int v5 = 0;
    do
    {
      uint64_t v6 = *(void *)(*(void *)(a1 + 80) + v3);
      if (v6)
      {
        v5 |= (*(uint64_t (**)(uint64_t))(*(void *)v6 + 168))(v6);
        unint64_t v2 = *(unsigned int *)(a1 + 72);
      }
      ++v4;
      v3 += 56;
    }
    while (v4 < v2);
  }
  else
  {
    int v5 = 0;
  }
  return FST_GetStatus(a1) | v5;
}

uint64_t FSTInject_InitializeGroup(uint64_t a1, unsigned int a2, int a3, int a4, unsigned int a5)
{
  unsigned int v11 = 0;
  uint64_t v7 = (_DWORD *)(*(void *)(a1 + 80) + 56 * a2);
  v7[4] = a3;
  v7[5] = a4;
  v7[10] = a5;
  uint64_t v8 = OOCAllocator_Malloc(*(void *)(a1 + 24), 8 * a5, &v11);
  uint64_t v9 = *(void *)(a1 + 80) + 56 * a2;
  *(void *)(v9 + 48) = v8;
  *(_DWORD *)(v9 + 12) = -1;
  return v11;
}

uint64_t FSTInject_InitializeGroupInstance(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5, int a6)
{
  unsigned int v41 = 0;
  unsigned int v40 = 0;
  unsigned int v39 = 0;
  uint64_t v10 = (_DWORD *)(*(void *)(*(void *)(a1 + 80) + 56 * a2 + 48) + 8 * a3);
  *uint64_t v10 = a5;
  v10[1] = a6;
  unsigned int v11 = *(_DWORD **)(a1 + 168);
  unint64_t v12 = *(void *)(a1 + 176) - (void)v11;
  uint64_t v13 = a4 % (v12 >> 2);
  uint64_t v14 = &v11[v13];
  while (1)
  {
    unsigned int v15 = *v14;
    if ((*v14 & 0x80000000) != 0) {
      break;
    }
    uint64_t v16 = *(void *)(a1 + 192);
    uint64_t v14 = (unsigned int *)(v16 + 12 * v15);
    if (v14[1] == a4) {
      goto LABEL_36;
    }
  }
  unsigned int v15 = *(_DWORD *)(a1 + 208);
  if (v15 != -1)
  {
    unsigned int v17 = *(_DWORD *)(a1 + 208);
    uint64_t v16 = *(void *)(a1 + 192);
    unsigned int v18 = (_DWORD *)(v16 + 12 * (int)v15);
    *(_DWORD *)(a1 + 208) = (*v18 & 0xBFFFFFFF) - 1;
    *unsigned int v18 = 0;
    v18[1] = a4;
    _OWORD v18[2] = -1;
LABEL_35:
    *(_DWORD *)(v16 + 12 * (int)v17) = v11[v13];
    v11[v13] = v15;
LABEL_36:
    uint64_t result = dpmemblock_GetNewElementWithReUse(*(void *)(a1 + 88), &v40, &v39);
    unsigned int v41 = result;
    if (!result)
    {
      unsigned int v37 = v40;
      *unsigned int v40 = a2;
      v37[1] = a3;
      uint64_t v38 = v16 + 12 * (int)v15;
      v37[2] = *(_DWORD *)(v38 + 8);
      *(_DWORD *)(v38 + 8) = v39;
      return v41;
    }
    return result;
  }
  uint64_t v16 = *(void *)(a1 + 192);
  uint64_t v19 = *(_DWORD **)(a1 + 200);
  uint64_t v20 = ((uint64_t)v19 - v16) >> 2;
  unsigned int v15 = -1431655765 * v20;
  unsigned int v21 = 2 * (v12 >> 2);
  if (v21 >= -1431655765 * (int)v20)
  {
    unsigned int v27 = -1431655765 * v20;
  }
  else
  {
    unsigned int v22 = v21 | 1;
    uint64_t v23 = *(unsigned int *)(a1 + 160);
    if (v22 <= v23)
    {
      uint64_t v25 = 4 * v23;
    }
    else
    {
      if (v22 <= 8) {
        unsigned int v24 = 8;
      }
      else {
        unsigned int v24 = v22;
      }
      uint64_t v25 = 4 * v24;
      unsigned int v11 = (_DWORD *)OOCAllocator_Realloc(*(void *)(a1 + 24), (uint64_t)v11, v25, &v41);
      *(void *)(a1 + 168) = v11;
      uint64_t result = v41;
      if (v41) {
        return result;
      }
      *(_DWORD *)(a1 + 160) = v24;
      v12 &= 0x3FFFFFFFCuLL;
    }
    unint64_t v28 = (v12 >> 1) & 0xFFFFFFFE | 1;
    *(void *)(a1 + 176) = &v11[v28];
    cstdlib_memset(v11, 255, v25);
    uint64_t v16 = *(void *)(a1 + 192);
    uint64_t v19 = *(_DWORD **)(a1 + 200);
    unsigned int v27 = -1431655765 * (((uint64_t)v19 - v16) >> 2);
    if (v27)
    {
      uint64_t v29 = 0;
      unint64_t v30 = *(_DWORD **)(a1 + 192);
      do
      {
        if (((*v30 + 1) & 0x40000000) == 0)
        {
          uint64_t result = v41;
          if (v41) {
            return result;
          }
          unint64_t v31 = v30[1] - (v30[1] / v28) * (unint64_t)v28;
          uint64_t v32 = *(void *)(a1 + 168);
          *unint64_t v30 = *(_DWORD *)(v32 + 4 * v31);
          *(_DWORD *)(v32 + 4 * v31) = v29;
        }
        ++v29;
        v30 += 3;
      }
      while (-1431655765 * (((uint64_t)v19 - v16) >> 2) != v29);
      unsigned int v15 = -1431655765 * (((uint64_t)v19 - v16) >> 2);
    }
    else
    {
      unsigned int v15 = 0;
    }
  }
  unsigned int v33 = *(_DWORD *)(a1 + 184);
  if (v15 + 1 <= v33)
  {
LABEL_34:
    *(void *)(a1 + 200) = v19 + 3;
    _DWORD *v19 = 0;
    v19[1] = a4;
    _OWORD v19[2] = -1;
    unsigned int v11 = *(_DWORD **)(a1 + 168);
    uint64_t v13 = a4 % ((*(void *)(a1 + 176) - (void)v11) >> 2);
    unsigned int v17 = v15;
    goto LABEL_35;
  }
  unsigned int v34 = 2 * v33;
  unsigned int v35 = v33 + 1000000;
  if (v34 >= v35) {
    unsigned int v34 = v35;
  }
  if (v34 <= v15 + 1) {
    unsigned int v34 = v15 + 1;
  }
  if (v34 <= 8) {
    unsigned int v36 = 8;
  }
  else {
    unsigned int v36 = v34;
  }
  uint64_t v16 = OOCAllocator_Realloc(*(void *)(a1 + 24), v16, 12 * v36, &v41);
  *(void *)(a1 + 192) = v16;
  uint64_t result = v41;
  if (!v41)
  {
    *(_DWORD *)(a1 + 184) = v36;
    uint64_t v19 = (_DWORD *)(v16 + 12 * v27);
    goto LABEL_34;
  }
  return result;
}

uint64_t FSTInject_Reset(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 112))(*(void *)(a1 + 64));
  if (!result)
  {
    unint64_t v3 = *(unsigned int *)(a1 + 72);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = *(void *)(*(void *)(a1 + 80) + v4);
        if (v6)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 112))(v6);
          if (result) {
            return result;
          }
          unint64_t v3 = *(unsigned int *)(a1 + 72);
        }
        v4 += 56;
      }
    }
    int v7 = *(_DWORD *)(a1 + 152);
    *(_DWORD *)(a1 + 216) = v7 + 1;
    *(_DWORD *)(a1 + 224) = v7;
    cstdlib_memset(*(void **)(a1 + 104), 255, 4 * *(unsigned int *)(a1 + 96));
    *(void *)(a1 + 136) = *(void *)(a1 + 128);
    *(_DWORD *)(a1 + 144) = -1;
    if (*(_DWORD *)(a1 + 220))
    {
      return __FSTInject_ActivateAllGroupInstances(a1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t FSTInject_SetGroupFst(uint64_t a1, unsigned int a2, uint64_t a3, int a4, uint64_t a5, int a6, int a7)
{
  int v19 = 0;
  uint64_t v14 = (*(uint64_t (**)(uint64_t, int *))(*(void *)a3 + 48))(a3, &v19);
  if (v14) {
    BOOL v15 = 1;
  }
  else {
    BOOL v15 = v19 == -1;
  }
  if (!v15)
  {
    (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
    uint64_t v16 = *(void *)(a1 + 80) + 56 * a2;
    *(void *)uint64_t v16 = a3;
    int v17 = v19;
    if (a4 != -1) {
      int v17 = a4;
    }
    *(void *)(v16 + 24) = a5;
    *(_DWORD *)(v16 + 32) = a6;
    *(_DWORD *)(v16 + 36) = a7;
    *(_DWORD *)(v16 + 8) = v17;
    *(_DWORD *)(v16 + 12) = -1;
  }
  return v14;
}

double FSTInject_SetStatePool(uint64_t a1, uint64_t a2)
{
  if (!(*(unsigned int (**)(void))(**(void **)(a1 + 64) + 128))(*(void *)(a1 + 64)))
  {
    unint64_t v5 = *(unsigned int *)(a1 + 72);
    if (v5)
    {
      uint64_t v6 = 0;
      for (unint64_t i = 0; i < v5; ++i)
      {
        uint64_t v8 = *(void *)(*(void *)(a1 + 80) + v6);
        if (v8)
        {
          if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v8 + 128))(v8, a2)) {
            return result;
          }
          unint64_t v5 = *(unsigned int *)(a1 + 72);
        }
        v6 += 56;
      }
    }
    return FST_SetStatePool(a1, a2);
  }
  return result;
}

uint64_t FSTInject_UpdateGroupInstanceWeight(uint64_t result, unsigned int a2, unsigned int a3, int a4)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 80) + 56 * a2 + 48) + 8 * a3 + 4) = a4;
  return result;
}

void PNEW_FSTInject_Con(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t *a6)
{
  int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 232, &v14);
  if (!v14)
  {
    FSTInject_Con(v12, a2, a3, a4, a5);
    int v14 = v13;
    if (v13)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
    }
    else
    {
      *(void *)(v12 + 16) = a1;
      *a6 = v12;
    }
  }
}

void PNEW_FSTInject_ConAllInstancesActive(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t *a6)
{
  int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 232, &v14);
  if (!v14)
  {
    FSTInject_ConAllInstancesActive(v12, a2, a3, a4, a5);
    int v14 = v13;
    if (v13)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
    }
    else
    {
      *(void *)(v12 + 16) = a1;
      *a6 = v12;
    }
  }
}

void *GetFSTInjectClass()
{
  return &__FSTInject;
}

void fstmerge(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v9 = a4;
  if (a3 < 2)
  {
    *a8 = *a4;
  }
  else
  {
    int v13 = 0;
    PNEW_FSTMerge_Con(a1, a2, a3, a4, a5, a6, a7, &v13);
    if (!v11)
    {
      *a8 = v13;
      uint64_t v12 = a3;
      do
      {
        if ((*(unsigned int (**)(void))(*(void *)*v9 + 32))(*v9)) {
          break;
        }
        ++v9;
        --v12;
      }
      while (v12);
    }
  }
}

void PNEW_FSTMerge_Con(uint64_t a1, uint64_t a2, unsigned int a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, int8x8_t **a8)
{
  int v18 = 0;
  uint64_t v16 = (int8x8_t *)OOCAllocator_Malloc(a1, 160, &v18);
  if (!v18)
  {
    FSTMerge_Con(v16, a2, a3, a4, a5, a6, a7);
    int v18 = v17;
    if (v17)
    {
      OOCAllocator_Free(a1, (uint64_t)v16);
      *a8 = 0;
    }
    else
    {
      _OWORD v16[2] = (int8x8_t)a1;
      *a8 = v16;
    }
  }
}

void FSTMerge_Con(int8x8_t *a1, uint64_t a2, unsigned int a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  FST_Con(a1, a2, *(void *)(*(void *)a4 + 48));
  int v27 = v14;
  if (!v14)
  {
    *a1 = (int8x8_t)&__FSTMerge;
    if (a3 >= 0x10000)
    {
      err_GenerateErrorLimit();
    }
    else
    {
      a1[8].i16[0] = a3;
      BOOL v15 = (void *)OOCAllocator_Malloc(a2, 8 * a3, &v27);
      a1[9] = (int8x8_t)v15;
      if (!v27)
      {
        cstdlib_memcpy(v15, a4, 8 * a3);
        a1[5] = vorr_s8(vand_s8(a1[5], (int8x8_t)0x300000003), (int8x8_t)0x1430000004000);
        if (a3)
        {
          unint64_t v16 = 0;
          unint64_t v17 = (unsigned __int16)a3;
          int8x8_t v18 = a1[9];
          int v19 = 1;
          do
          {
            (*(void (**)(void))(**(void **)(*(void *)&v18 + 8 * v16) + 24))(*(void *)(*(void *)&v18 + 8 * v16));
            int8x8_t v18 = a1[9];
            uint64_t v20 = *(_DWORD **)(*(void *)&v18 + 8 * v16);
            int v21 = v20[10];
            if (v20[9] == 2) {
              int v19 = 2;
            }
            int v22 = v20[11];
            if ((v21 & v22 & 0x200) != 0)
            {
              *(void *)&a1[5] |= 0x20000000200uLL;
              int v21 = v20[10];
              int v22 = v20[11];
            }
            if ((v22 & v21 & 0x10000) != 0)
            {
              *(void *)&a1[5] |= 0x1000000010000uLL;
              int v22 = v20[11];
            }
            if ((v22 & 0x4000) != 0)
            {
              v23.i32[0] = *(void *)&a1[5] & 0xFFFFBFFF;
              v23.i32[1] = (*(void *)&a1[5] | 0x400000004000uLL) >> 32;
              a1[5] = v23;
            }
            ++v16;
          }
          while (v16 < v17);
        }
        else
        {
          int v19 = 1;
        }
        a1[10] = (int8x8_t)a5;
        a1[11] = (int8x8_t)a6;
        a1[12] = (int8x8_t)a7;
        a1[4].i32[0] = 8;
        a1[4].i32[1] = v19;
        a1[13].i32[0] = 16;
        uint64_t v24 = OOCAllocator_Malloc(a2, 64, &v27);
        a1[14] = (int8x8_t)v24;
        if (!v27)
        {
          uint64_t v25 = a1[13].u32[0];
          unint64_t v26 = v24 + 4 * v25;
          a1[15] = (int8x8_t)v26;
          if (v25)
          {
            if (v26 <= v24 + 4) {
              unint64_t v26 = v24 + 4;
            }
            memset((void *)v24, 255, ((v26 + ~v24) & 0xFFFFFFFFFFFFFFFCLL) + 4);
          }
          a1[16].i32[0] = 0;
          a1[17] = 0;
          a1[18] = 0;
          a1[19].i32[0] = -1;
        }
      }
    }
  }
}

uint64_t FSTMerge_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (*(_WORD *)(a1 + 64))
  {
    uint64_t v3 = 0;
    while (1)
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 72) + 8 * v3);
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 32))(v4);
      if (result) {
        break;
      }
      if (++v3 >= (unint64_t)*(unsigned __int16 *)(a1 + 64)) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    OOCAllocator_Free(v2, *(void *)(a1 + 72));
    uint64_t v6 = *(void *)(a1 + 112);
    if (v6) {
      OOCAllocator_Free(v2, v6);
    }
    uint64_t v7 = *(void *)(a1 + 136);
    if (v7) {
      OOCAllocator_Free(v2, v7);
    }
    return FST_Des(a1);
  }
  return result;
}

uint64_t FSTMerge_BorrowComponentFst(uint64_t a1, unsigned int a2)
{
  if (*(unsigned __int16 *)(a1 + 64) <= a2) {
    return 0;
  }
  else {
    return *(void *)(*(void *)(a1 + 72) + 8 * a2);
  }
}

uint64_t FSTMerge_FetchState(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v5 = a3;
  v185[0] = 0;
  uint64_t v7 = *(void *)(a1 + 24);
  *a4 = 0;
  if (a2)
  {
    uint64_t v9 = v7;
    uint64_t v180 = 0;
    uint64_t v10 = *(void *)(a1 + 136) + 10 * (a2 - 1);
    uint64_t v11 = *(unsigned __int16 *)(v10 + 4);
    uint64_t v12 = *(void *)(*(void *)(a1 + 72) + 8 * v11);
    v185[0] = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t *))(*(void *)v12 + 120))(v12, *(unsigned int *)(v10 + 6), a3, &v180);
    if (v185[0]) {
      return v185[0];
    }
    uint64_t v13 = v180;
    if (!v180) {
      return v185[0];
    }
    if ((*(_DWORD *)(v180 + 8) & 0x3FFFFFE) != 0)
    {
      *(void *)&long long v176 = 0;
      v185[0] = FSTStatePool_PopFSTState(*(void *)(a1 + 48), (uint64_t *)&v176);
      if (v185[0]) {
        return v185[0];
      }
      v185[0] = FSTState_Copy(v176, v180);
      if (v185[0]) {
        return v185[0];
      }
      int v14 = *(_DWORD *)(v180 + 8);
      *(_DWORD *)(v180 + 8) = v14 - 1;
      int v15 = v14 & 0x3FFFFFF;
      int v16 = (v14 & 0x3FFFFFF) != 0 ? 0 : 9;
      v185[0] = v16;
      if (!v15) {
        return v185[0];
      }
      uint64_t v13 = v176;
      uint64_t v180 = v176;
    }
    *(_DWORD *)(v13 + 24) = a2;
    unint64_t v17 = *(int **)(v13 + 40);
    uint64_t v18 = *(void *)(v13 + 56) + 16 * *(unsigned int *)(v13 + 48);
    if (v17 == (int *)v18)
    {
LABEL_211:
      *a4 = v13;
      return v185[0];
    }
    int v19 = &v17[4 * *(unsigned int *)(v13 + 32)];
    unsigned int v167 = v19;
    uint64_t v170 = *(void *)(v13 + 56) + 16 * *(unsigned int *)(v13 + 48);
    while (1)
    {
      if (v17 == v19)
      {
        uint64_t v13 = v180;
        if (!*(_DWORD *)(v180 + 48)) {
          goto LABEL_211;
        }
        unint64_t v17 = *(int **)(v180 + 56);
      }
      if (v185[0]) {
        return v185[0];
      }
      int v20 = *v17;
      unsigned int v21 = v11 + 2309 * *v17;
      int v22 = *(_DWORD **)(a1 + 112);
      unint64_t v23 = *(void *)(a1 + 120) - (void)v22;
      unsigned int v24 = v22[v21 % (v23 >> 2)];
      if ((v24 & 0x80000000) != 0)
      {
LABEL_23:
        unsigned int v24 = *(_DWORD *)(a1 + 152);
        if (v24 == -1)
        {
          uint64_t v28 = *(void *)(a1 + 136);
          uint64_t v29 = *(void *)(a1 + 144);
          uint64_t v30 = (v29 - v28) >> 1;
          unsigned int v24 = -858993459 * v30;
          unsigned int v31 = 2 * (v23 >> 2);
          if (v31 >= -858993459 * (int)v30)
          {
            unsigned int v37 = -858993459 * v30;
          }
          else
          {
            unsigned int v32 = v31 | 1;
            uint64_t v33 = *(unsigned int *)(a1 + 104);
            if (v32 <= v33)
            {
              uint64_t v35 = 4 * v33;
            }
            else
            {
              if (v32 <= 8) {
                unsigned int v34 = 8;
              }
              else {
                unsigned int v34 = v32;
              }
              uint64_t v35 = 4 * v34;
              uint64_t v36 = OOCAllocator_Realloc(v9, *(void *)(a1 + 112), v35, v185);
              *(void *)(a1 + 112) = v36;
              if (v185[0]) {
                return v185[0];
              }
              int v22 = (_DWORD *)v36;
              *(_DWORD *)(a1 + 104) = v34;
              v23 &= 0x3FFFFFFFCuLL;
            }
            unint64_t v38 = (v23 >> 1) & 0xFFFFFFFE | 1;
            *(void *)(a1 + 120) = &v22[v38];
            cstdlib_memset(v22, 255, v35);
            uint64_t v28 = *(void *)(a1 + 136);
            uint64_t v29 = *(void *)(a1 + 144);
            unsigned int v37 = -858993459 * ((v29 - v28) >> 1);
            if (v37)
            {
              uint64_t v39 = 0;
              unsigned int v40 = (unsigned __int16 *)(v28 + 4);
              int v19 = v167;
              uint64_t v18 = v170;
              do
              {
                if (((*((_DWORD *)v40 - 1) + 1) & 0x40000000) == 0)
                {
                  if (v185[0]) {
                    return v185[0];
                  }
                  unint64_t v41 = *v40 + 2309 * *(_DWORD *)(v40 + 1);
                  uint64_t v42 = v41 - (v41 / v38) * (unint64_t)v38;
                  uint64_t v43 = *(void *)(a1 + 112);
                  *((_DWORD *)v40 - 1) = *(_DWORD *)(v43 + 4 * v42);
                  *(_DWORD *)(v43 + 4 * v42) = v39;
                }
                ++v39;
                v40 += 5;
              }
              while (-858993459 * ((v29 - v28) >> 1) != v39);
              unsigned int v24 = -858993459 * ((v29 - v28) >> 1);
            }
            else
            {
              unsigned int v24 = 0;
              int v19 = v167;
              uint64_t v18 = v170;
            }
          }
          unsigned int v44 = v24 + 1;
          unsigned int v45 = *(_DWORD *)(a1 + 128);
          if (v24 + 1 > v45)
          {
            unsigned int v46 = 2 * v45;
            unsigned int v47 = v45 + 1000000;
            if (v46 >= v47) {
              unsigned int v46 = v47;
            }
            if (v46 > v44) {
              unsigned int v44 = v46;
            }
            if (v44 <= 8) {
              unsigned int v48 = 8;
            }
            else {
              unsigned int v48 = v44;
            }
            uint64_t v49 = OOCAllocator_Realloc(v9, v28, 10 * v48, v185);
            int v19 = v167;
            uint64_t v18 = v170;
            *(void *)(a1 + 136) = v49;
            if (v185[0]) {
              return v185[0];
            }
            *(_DWORD *)(a1 + 128) = v48;
            uint64_t v29 = v49 + 10 * v37;
          }
          *(void *)(a1 + 144) = v29 + 10;
          *(_DWORD *)uint64_t v29 = 0;
          *(_WORD *)(v29 + 4) = v11;
          *(_DWORD *)(v29 + 6) = v20;
          unsigned int v26 = v24;
        }
        else
        {
          unsigned int v26 = *(_DWORD *)(a1 + 152);
          int v27 = (unsigned __int16 *)(*(void *)(a1 + 136) + 10 * (int)v24);
          *(_DWORD *)(a1 + 152) = (*v27 | (v27[1] << 16) & 0xBFFF0000) - 1;
          *(_DWORD *)int v27 = 0;
          v27[2] = v11;
          *(_DWORD *)(v27 + 3) = v20;
        }
        uint64_t v50 = *(void *)(a1 + 112);
        unsigned int v51 = v21 % ((unint64_t)(*(void *)(a1 + 120) - v50) >> 2);
        *(_DWORD *)(*(void *)(a1 + 136) + 10 * (int)v26) = *(_DWORD *)(v50 + 4 * v51);
        *(_DWORD *)(v50 + 4 * v51) = v24;
      }
      else
      {
        uint64_t v25 = *(void *)(a1 + 136);
        while (v20 != *(_DWORD *)(v25 + 10 * v24 + 6) || v11 != *(unsigned __int16 *)(v25 + 10 * v24 + 4))
        {
          unsigned int v24 = *(_DWORD *)(v25 + 10 * v24);
          if ((v24 & 0x80000000) != 0) {
            goto LABEL_23;
          }
        }
      }
      *unint64_t v17 = v24 + 1;
      uint64_t v52 = *(void *)(a1 + 80);
      if (v52)
      {
        uint64_t v53 = *(void *)(v52 + 8 * v11);
        if (v53)
        {
          uint64_t v54 = v17[1];
          if ((v54 & 0x80000000) == 0) {
            v17[1] = *(_DWORD *)(v53 + 4 * v54);
          }
        }
      }
      int v55 = v17[2];
      if (v55 >= 1)
      {
        if ((v55 & 0x40000000) == 0 || v17[1] < 0xFFFFFFFE)
        {
          uint64_t v56 = *(void *)(a1 + 88);
          if (!v56) {
            goto LABEL_63;
          }
LABEL_62:
          void v17[2] = *(_DWORD *)(v56 + 4 * v11) + v55;
          goto LABEL_63;
        }
        uint64_t v56 = *(void *)(a1 + 96);
        if (v56) {
          goto LABEL_62;
        }
      }
LABEL_63:
      v17 += 4;
      if (v17 == (int *)v18)
      {
        uint64_t v13 = v180;
        goto LABEL_211;
      }
    }
  }
  uint64_t v184 = 0;
  long long v182 = 0u;
  long long v183 = 0u;
  uint64_t v180 = 10;
  uint64_t v179 = 0;
  long long v177 = 0u;
  long long v178 = 0u;
  long long v176 = 0u;
  uint64_t v175 = 0;
  uint64_t v57 = OOCAllocator_Malloc(v7, 40, v185);
  uint64_t v181 = v57;
  if (v185[0]) {
    return v185[0];
  }
  *(void *)&long long v182 = v57 + 40;
  *(void *)&long long v58 = -1;
  *((void *)&v58 + 1) = -1;
  *(_OWORD *)uint64_t v57 = v58;
  *(_OWORD *)(v57 + 16) = v58;
  *(void *)(v57 + 32) = -1;
  DWORD2(v182) = 0;
  long long v183 = 0uLL;
  LODWORD(v184) = -1;
  LODWORD(v176) = 10;
  uint64_t v59 = OOCAllocator_Malloc(v7, 40, v185);
  *((void *)&v176 + 1) = v59;
  if (v185[0]) {
    return v185[0];
  }
  int v173 = a4;
  uint64_t v166 = v7;
  *(void *)&long long v177 = v59 + 40;
  *(void *)&long long v60 = -1;
  *((void *)&v60 + 1) = -1;
  *(_OWORD *)uint64_t v59 = v60;
  *(_OWORD *)(v59 + 16) = v60;
  *(void *)(v59 + 32) = -1;
  DWORD2(v177) = 0;
  long long v178 = 0uLL;
  LODWORD(v179) = -1;
  if (!*(_WORD *)(a1 + 64))
  {
    int v161 = 0x7FFFFFFF;
    unsigned int v162 = 0;
    goto LABEL_188;
  }
  unsigned int v162 = 0;
  unsigned int v163 = v5;
  unint64_t v61 = 0;
  int v161 = 0x7FFFFFFF;
  do
  {
    unint64_t v171 = v61;
    unsigned int v174 = 0;
    uint64_t v62 = *(void *)(*(void *)(a1 + 72) + 8 * v61);
    v185[0] = (*(uint64_t (**)(uint64_t, unsigned int *))(*(void *)v62 + 48))(v62, &v174);
    if (v185[0]) {
      return v185[0];
    }
    uint64_t v63 = *(void *)(*(void *)(a1 + 72) + 8 * v171);
    int v64 = (*(uint64_t (**)(uint64_t, void, void, uint64_t *))(*(void *)v63 + 120))(v63, v174, v163, &v175);
    unint64_t v65 = v171;
    v185[0] = v64;
    if (v64) {
      return v185[0];
    }
    uint64_t v66 = v175;
    if (!v175) {
      goto LABEL_185;
    }
    int v67 = *(_DWORD *)(v175 + 8);
    if (v67 < 0)
    {
      int v68 = v161;
      if (v161 >= *(_DWORD *)(v175 + 28)) {
        int v68 = *(_DWORD *)(v175 + 28);
      }
      int v161 = v68;
    }
    unsigned int v69 = *(int **)(v175 + 40);
    uint64_t v70 = *(void *)(v175 + 56) + 16 * *(unsigned int *)(v175 + 48);
    if (v69 == (int *)v70)
    {
      int v144 = *(_DWORD *)(v175 + 8);
      unsigned int v145 = v162;
      goto LABEL_178;
    }
    int v158 = *(_DWORD *)(v175 + 8);
    unsigned int v71 = &v69[4 * *(unsigned int *)(v175 + 32)];
    unsigned int v72 = (uint64_t *)&v176;
    unsigned int v164 = v71;
    uint64_t v165 = *(void *)(v175 + 56) + 16 * *(unsigned int *)(v175 + 48);
    do
    {
      if (v69 == v71)
      {
        uint64_t v66 = v175;
        if (!*(_DWORD *)(v175 + 48)) {
          goto LABEL_176;
        }
        unsigned int v69 = *(int **)(v175 + 56);
        unsigned int v72 = &v180;
      }
      int v74 = *v69;
      uint64_t v73 = v69[1];
      int v76 = v69[2];
      int v75 = v69[3];
      if (*v69 == v174)
      {
        unsigned int v77 = 0;
      }
      else
      {
        if (v185[0]) {
          return v185[0];
        }
        unsigned int v78 = v65 + 2309 * v74;
        int v79 = *(_DWORD **)(a1 + 112);
        unint64_t v80 = *(void *)(a1 + 120) - (void)v79;
        unsigned int v81 = v79[v78 % (v80 >> 2)];
        if ((v81 & 0x80000000) != 0)
        {
LABEL_91:
          unsigned int v81 = *(_DWORD *)(a1 + 152);
          if (v81 == -1)
          {
            uint64_t v85 = *(void *)(a1 + 136);
            uint64_t v86 = *(void *)(a1 + 144);
            uint64_t v87 = (v86 - v85) >> 1;
            unsigned int v81 = -858993459 * v87;
            unsigned int v88 = 2 * (v80 >> 2);
            int v168 = v69[3];
            unsigned int v159 = v65 + 2309 * v74;
            if (v88 >= -858993459 * (int)v87)
            {
              unsigned int v94 = -858993459 * v87;
            }
            else
            {
              unsigned int v89 = v88 | 1;
              uint64_t v90 = *(unsigned int *)(a1 + 104);
              if (v89 <= v90)
              {
                uint64_t v92 = 4 * v90;
              }
              else
              {
                if (v89 <= 8) {
                  unsigned int v91 = 8;
                }
                else {
                  unsigned int v91 = v89;
                }
                uint64_t v92 = 4 * v91;
                uint64_t v93 = OOCAllocator_Realloc(v166, (uint64_t)v79, v92, v185);
                *(void *)(a1 + 112) = v93;
                if (v185[0]) {
                  return v185[0];
                }
                int v79 = (_DWORD *)v93;
                *(_DWORD *)(a1 + 104) = v91;
                v80 &= 0x3FFFFFFFCuLL;
              }
              unint64_t v95 = (v80 >> 1) & 0xFFFFFFFE | 1;
              *(void *)(a1 + 120) = &v79[v95];
              cstdlib_memset(v79, 255, v92);
              uint64_t v85 = *(void *)(a1 + 136);
              uint64_t v86 = *(void *)(a1 + 144);
              unsigned int v94 = -858993459 * ((v86 - v85) >> 1);
              if (v94)
              {
                uint64_t v96 = 0;
                unsigned int v97 = (unsigned __int16 *)(v85 + 4);
                unint64_t v65 = v171;
                unsigned int v71 = v164;
                uint64_t v70 = v165;
                int v75 = v168;
                do
                {
                  if (((*((_DWORD *)v97 - 1) + 1) & 0x40000000) == 0)
                  {
                    if (v185[0]) {
                      return v185[0];
                    }
                    unint64_t v98 = *v97 + 2309 * *(_DWORD *)(v97 + 1);
                    uint64_t v99 = v98 - (v98 / v95) * (unint64_t)v95;
                    uint64_t v100 = *(void *)(a1 + 112);
                    *((_DWORD *)v97 - 1) = *(_DWORD *)(v100 + 4 * v99);
                    *(_DWORD *)(v100 + 4 * v99) = v96;
                  }
                  ++v96;
                  v97 += 5;
                }
                while (-858993459 * ((v86 - v85) >> 1) != v96);
                unsigned int v81 = -858993459 * ((v86 - v85) >> 1);
              }
              else
              {
                unsigned int v81 = 0;
                unint64_t v65 = v171;
                unsigned int v71 = v164;
                uint64_t v70 = v165;
                int v75 = v168;
              }
              unsigned int v78 = v159;
            }
            unsigned int v101 = v81 + 1;
            unsigned int v102 = *(_DWORD *)(a1 + 128);
            if (v81 + 1 > v102)
            {
              unsigned int v103 = 2 * v102;
              unsigned int v104 = v102 + 1000000;
              if (v103 >= v104) {
                unsigned int v103 = v104;
              }
              if (v103 > v101) {
                unsigned int v101 = v103;
              }
              if (v101 <= 8) {
                unsigned int v105 = 8;
              }
              else {
                unsigned int v105 = v101;
              }
              uint64_t v106 = OOCAllocator_Realloc(v166, v85, 10 * v105, v185);
              int v75 = v168;
              unsigned int v71 = v164;
              uint64_t v70 = v165;
              unint64_t v65 = v171;
              *(void *)(a1 + 136) = v106;
              if (v185[0]) {
                return v185[0];
              }
              *(_DWORD *)(a1 + 128) = v105;
              uint64_t v86 = v106 + 10 * v94;
              unsigned int v78 = v159;
            }
            *(void *)(a1 + 144) = v86 + 10;
            *(_DWORD *)uint64_t v86 = 0;
            *(_WORD *)(v86 + 4) = v65;
            *(_DWORD *)(v86 + 6) = v74;
            unsigned int v83 = v81;
          }
          else
          {
            unsigned int v83 = *(_DWORD *)(a1 + 152);
            unsigned int v84 = (unsigned __int16 *)(*(void *)(a1 + 136) + 10 * (int)v81);
            *(_DWORD *)(a1 + 152) = (*v84 | (v84[1] << 16) & 0xBFFF0000) - 1;
            *(_DWORD *)unsigned int v84 = 0;
            v84[2] = v65;
            *(_DWORD *)(v84 + 3) = v74;
          }
          uint64_t v107 = *(void *)(a1 + 112);
          unsigned int v108 = v78 % ((unint64_t)(*(void *)(a1 + 120) - v107) >> 2);
          *(_DWORD *)(*(void *)(a1 + 136) + 10 * (int)v83) = *(_DWORD *)(v107 + 4 * v108);
          *(_DWORD *)(v107 + 4 * v108) = v81;
        }
        else
        {
          uint64_t v82 = *(void *)(a1 + 136);
          while (v74 != *(_DWORD *)(v82 + 10 * v81 + 6) || v65 != *(unsigned __int16 *)(v82 + 10 * v81 + 4))
          {
            unsigned int v81 = *(_DWORD *)(v82 + 10 * v81);
            if ((v81 & 0x80000000) != 0) {
              goto LABEL_91;
            }
          }
        }
        unsigned int v77 = v81 + 1;
      }
      uint64_t v109 = *(void *)(a1 + 80);
      if (v109)
      {
        uint64_t v110 = *(void *)(v109 + 8 * v65);
        if (v110)
        {
          if ((v73 & 0x80000000) == 0) {
            LODWORD(v73) = *(_DWORD *)(v110 + 4 * v73);
          }
        }
      }
      if (v76 >= 1)
      {
        if (v73 >= 0xFFFFFFFE && (v76 & 0x40000000) != 0)
        {
          uint64_t v111 = *(void *)(a1 + 96);
          if (!v111) {
            goto LABEL_133;
          }
LABEL_132:
          v76 += *(_DWORD *)(v111 + 4 * v65);
          goto LABEL_133;
        }
        uint64_t v111 = *(void *)(a1 + 88);
        if (v111) {
          goto LABEL_132;
        }
      }
LABEL_133:
      if (v185[0]) {
        return v185[0];
      }
      unsigned int v112 = v77 + 2239 * (v75 + 2239 * (v76 + 2239 * v73));
      int v113 = (unsigned int *)v72[1];
      unint64_t v114 = v72[2] - (void)v113;
      uint64_t v115 = v112 % (v114 >> 2);
      uint64_t v116 = v113[v115];
      if ((v116 & 0x80000000) != 0)
      {
LABEL_141:
        signed int v119 = *((_DWORD *)v72 + 12);
        if (v119 == -1)
        {
          uint64_t v121 = v72[4];
          uint64_t v123 = (_DWORD *)v72[5];
          uint64_t v124 = ((uint64_t)v123 - v121) >> 2;
          signed int v119 = -858993459 * v124;
          unsigned int v125 = 2 * (v114 >> 2);
          int v169 = v75;
          if (v125 >= -858993459 * (int)v124)
          {
            unsigned int v131 = -858993459 * v124;
          }
          else
          {
            unsigned int v126 = v125 | 1;
            uint64_t v127 = *(unsigned int *)v72;
            if (v126 <= v127)
            {
              size_t v130 = 4 * v127;
            }
            else
            {
              if (v126 <= 8) {
                unsigned int v128 = 8;
              }
              else {
                unsigned int v128 = v126;
              }
              uint64_t v129 = OOCAllocator_Realloc(v166, (uint64_t)v113, 4 * v128, v185);
              v72[1] = v129;
              if (v185[0]) {
                return v185[0];
              }
              int v113 = (unsigned int *)v129;
              *(_DWORD *)unsigned int v72 = v128;
              v114 &= 0x3FFFFFFFCuLL;
              size_t v130 = 4 * v128;
            }
            unint64_t v132 = (v114 >> 1) & 0xFFFFFFFE | 1;
            v72[2] = (uint64_t)&v113[v132];
            cstdlib_memset(v113, 255, v130);
            uint64_t v121 = v72[4];
            uint64_t v123 = (_DWORD *)v72[5];
            unsigned int v131 = -858993459 * (((uint64_t)v123 - v121) >> 2);
            if (v131)
            {
              uint64_t v133 = 0;
              unsigned int v134 = (_DWORD *)v72[4];
              unint64_t v65 = v171;
              unsigned int v71 = v164;
              uint64_t v70 = v165;
              int v75 = v169;
              do
              {
                if (((*v134 + 1) & 0x40000000) == 0)
                {
                  if (v185[0]) {
                    return v185[0];
                  }
                  unint64_t v135 = (v134[1] + 2239 * (v134[4] + 2239 * (v134[3] + 2239 * v134[2])));
                  uint64_t v136 = v135 - (v135 / v132) * (unint64_t)v132;
                  uint64_t v137 = v72[1];
                  *unsigned int v134 = *(_DWORD *)(v137 + 4 * v136);
                  *(_DWORD *)(v137 + 4 * v136) = v133;
                }
                ++v133;
                v134 += 5;
              }
              while (-858993459 * (((uint64_t)v123 - v121) >> 2) != v133);
              signed int v119 = -858993459 * (((uint64_t)v123 - v121) >> 2);
            }
            else
            {
              signed int v119 = 0;
              unint64_t v65 = v171;
              unsigned int v71 = v164;
              uint64_t v70 = v165;
              int v75 = v169;
            }
          }
          unsigned int v138 = v119 + 1;
          unsigned int v139 = *((_DWORD *)v72 + 6);
          if (v119 + 1 > v139)
          {
            unsigned int v140 = 2 * v139;
            unsigned int v141 = v139 + 1000000;
            if (v140 >= v141) {
              unsigned int v140 = v141;
            }
            if (v140 > v138) {
              unsigned int v138 = v140;
            }
            if (v138 <= 8) {
              unsigned int v142 = 8;
            }
            else {
              unsigned int v142 = v138;
            }
            unsigned int v160 = v131;
            uint64_t v143 = OOCAllocator_Realloc(v166, v121, 20 * v142, v185);
            int v75 = v169;
            unsigned int v71 = v164;
            uint64_t v70 = v165;
            unint64_t v65 = v171;
            v72[4] = v143;
            if (v185[0]) {
              return v185[0];
            }
            uint64_t v121 = v143;
            *((_DWORD *)v72 + 6) = v142;
            uint64_t v123 = (_DWORD *)(v143 + 20 * v160);
          }
          v72[5] = (uint64_t)(v123 + 5);
          *uint64_t v123 = 0;
          v123[1] = v77;
          v123[2] = v73;
          v123[3] = v76;
          v123[4] = v75;
          int v113 = (unsigned int *)v72[1];
          uint64_t v115 = v112 % ((unint64_t)(v72[2] - (void)v113) >> 2);
          signed int v120 = v119;
        }
        else
        {
          signed int v120 = *((_DWORD *)v72 + 12);
          uint64_t v121 = v72[4];
          int v122 = (_DWORD *)(v121 + 20 * v119);
          *((_DWORD *)v72 + 12) = (*v122 & 0xBFFFFFFF) - 1;
          *int v122 = 0;
          v122[1] = v77;
          v122[2] = v73;
          void v122[3] = v76;
          v122[4] = v75;
        }
        *(_DWORD *)(v121 + 20 * v120) = v113[v115];
        v113[v115] = v119;
      }
      else
      {
        uint64_t v117 = v72[4];
        while (1)
        {
          uint64_t v118 = v117 + 20 * v116;
          if (v73 == *(_DWORD *)(v118 + 8)
            && v76 == *(_DWORD *)(v117 + 20 * v116 + 12)
            && v75 == *(_DWORD *)(v117 + 20 * v116 + 16)
            && v77 == *(_DWORD *)(v118 + 4))
          {
            break;
          }
          uint64_t v116 = *(unsigned int *)(v117 + 20 * v116);
          if ((v116 & 0x80000000) != 0) {
            goto LABEL_141;
          }
        }
      }
      v69 += 4;
    }
    while (v69 != (int *)v70);
    uint64_t v66 = v175;
LABEL_176:
    int v144 = *(_DWORD *)(v66 + 8);
    unsigned int v145 = v162;
    int v67 = v158;
LABEL_178:
    unsigned int v162 = v67 & 0xF0000000 | v145;
    if ((v144 & 0x3FFFFFF) != 1)
    {
      *(_DWORD *)(v66 + 8) = v144 - 1;
      if ((v144 & 0x3FFFFFF) != 0)
      {
        v185[0] = 0;
        goto LABEL_185;
      }
      v185[0] = 9;
      return v185[0];
    }
    if ((v144 & 0x8000000) != 0) {
      uint64_t v146 = *(void *)(v66 + 16);
    }
    else {
      uint64_t v146 = 0;
    }
    v185[0] = FSTStatePool_PushFSTState(v146, v66);
    unint64_t v65 = v171;
    if (v185[0]) {
      return v185[0];
    }
LABEL_185:
    unint64_t v61 = v65 + 1;
  }
  while (v61 < *(unsigned __int16 *)(a1 + 64));
LABEL_188:
  v185[0] = FSTStatePool_PopFSTState(*(void *)(a1 + 48), v173);
  if (!v185[0])
  {
    uint64_t v147 = *v173;
    *(_DWORD *)(v147 + 8) = *(_DWORD *)(*v173 + 8) | v162;
    *(_DWORD *)(v147 + 24) = 0;
    *(_DWORD *)(v147 + 28) = v161;
    long long v148 = v178;
    unsigned int v149 = -858993459 * ((*((void *)&v178 + 1) - (void)v178) >> 2);
    if (!v149) {
      goto LABEL_196;
    }
    if ((unsigned int v150 = *(_OWORD **)(v147 + 40)) != 0 && *((_DWORD *)v150 - 1) > v149
      || (unsigned int v150 = (_OWORD *)_FSTState_ReserveEpsilonArcsInternal(v147, v149, v185), !v185[0]))
    {
      if ((unint64_t)v148 < *((void *)&v148 + 1))
      {
        unint64_t v151 = v148;
        do
        {
          *v150++ = *(_OWORD *)(v151 + 4);
          v151 += 20;
        }
        while (v151 < *((void *)&v148 + 1));
      }
LABEL_196:
      uint64_t v152 = *v173;
      *(_DWORD *)(*v173 + 32) = v149;
      long long v153 = v183;
      unsigned int v154 = -858993459 * ((*((void *)&v183 + 1) - (void)v183) >> 2);
      if (v154)
      {
        char v155 = *(_OWORD **)(v152 + 56);
        if (v155 && *((_DWORD *)v155 - 1) > v154
          || (char v155 = (_OWORD *)_FSTState_ReserveArcsInternal(v152, v154, v185), !v185[0]))
        {
          if ((unint64_t)v153 < *((void *)&v153 + 1))
          {
            unint64_t v156 = v153;
            do
            {
              *v155++ = *(_OWORD *)(v156 + 4);
              v156 += 20;
            }
            while (v156 < *((void *)&v153 + 1));
          }
          goto LABEL_203;
        }
      }
      else
      {
LABEL_203:
        *(_DWORD *)(*v173 + 48) = v154;
        if (v181) {
          OOCAllocator_Free(v166, v181);
        }
        if ((void)v153) {
          OOCAllocator_Free(v166, v153);
        }
        if (*((void *)&v176 + 1)) {
          OOCAllocator_Free(v166, *((uint64_t *)&v176 + 1));
        }
        if ((void)v148) {
          OOCAllocator_Free(v166, v148);
        }
      }
    }
  }
  return v185[0];
}

uint64_t FSTMerge_GetFinalStateWeight(uint64_t a1, int a2, int *a3)
{
  *a3 = 0x7FFFFFFF;
  if (a2)
  {
    unsigned int v5 = *(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 72)
                                           + 8
                                           * *(unsigned __int16 *)(*(void *)(a1 + 136)
                                                                 + 10 * (a2 - 1)
                                                                 + 4))
                             + 64);
    return v5();
  }
  else if (*(_WORD *)(a1 + 64))
  {
    uint64_t v7 = 0;
    while (1)
    {
      uint64_t v11 = 0;
      uint64_t v8 = *(void *)(*(void *)(a1 + 72) + 8 * v7);
      uint64_t result = (*(uint64_t (**)(uint64_t, char *))(*(void *)v8 + 48))(v8, (char *)&v11 + 4);
      if (result) {
        break;
      }
      uint64_t v9 = *(void *)(*(void *)(a1 + 72) + 8 * v7);
      uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t *))(*(void *)v9 + 64))(v9, HIDWORD(v11), &v11);
      if (result) {
        break;
      }
      int v10 = *a3;
      if (*a3 >= (int)v11) {
        int v10 = v11;
      }
      *a3 = v10;
      if (++v7 >= (unint64_t)*(unsigned __int16 *)(a1 + 64)) {
        return 0;
      }
    }
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t FSTMerge_GetInitialStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = 0;
  return 0;
}

uint64_t FSTMerge_GetMaxNbrComponentFsts(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 64);
}

uint64_t FSTMerge_GetMaxStateId(uint64_t a1, int *a2)
{
  *a2 = 0;
  if (!*(_WORD *)(a1 + 64)) {
    return 0;
  }
  uint64_t v4 = 0;
  while (1)
  {
    int v10 = -1;
    uint64_t v5 = *(void *)(*(void *)(a1 + 72) + 8 * v4);
    uint64_t v6 = (*(uint64_t (**)(uint64_t, int *))(*(void *)v5 + 72))(v5, &v10);
    if (v6) {
      return v6;
    }
    uint64_t v7 = *(void *)(*(void *)(a1 + 72) + 8 * v4);
    if ((*(uint64_t (**)(uint64_t))(*(void *)v7 + 168))(v7))
    {
      int v8 = -1;
LABEL_10:
      *a2 = v8;
      return v6;
    }
    int v8 = v10;
    if (v10 == -1) {
      goto LABEL_10;
    }
    if (__CFADD__(v10, *a2))
    {
      _FST_SetStatus(a1, 1);
      return v6;
    }
    *a2 += v10;
    if (++v4 >= (unint64_t)*(unsigned __int16 *)(a1 + 64)) {
      return 0;
    }
  }
}

uint64_t FSTMerge_GetMemoryInfo(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int16 *)(a1 + 64);
  uint64_t v2 = *(unsigned int *)(a1 + 104);
  unsigned int v3 = *(_DWORD *)(a1 + 128);
  if (*(_WORD *)(a1 + 64))
  {
    unint64_t v5 = 0;
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = *(void *)(*(void *)(a1 + 72) + 8 * v5);
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 96))(v7);
      v6 += v9 + v8;
      ++v5;
    }
    while (v5 < *(unsigned __int16 *)(a1 + 64));
  }
  return 8 * v1 + 4 * v2 + 10 * v3 + 160;
}

uint64_t FSTMerge_GetStatus(uint64_t a1)
{
  uint64_t Status = FST_GetStatus(a1);
  if (*(_WORD *)(a1 + 64))
  {
    unint64_t v3 = 0;
    do
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 72) + 8 * v3);
      uint64_t Status = (*(unsigned int (**)(uint64_t))(*(void *)v4 + 168))(v4) | Status;
      ++v3;
    }
    while (v3 < *(unsigned __int16 *)(a1 + 64));
  }
  return Status;
}

uint64_t FSTMerge_Reset(uint64_t a1)
{
  if (*(_WORD *)(a1 + 64))
  {
    uint64_t v2 = 0;
    while (1)
    {
      uint64_t v3 = *(void *)(*(void *)(a1 + 72) + 8 * v2);
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 112))(v3);
      if (result) {
        break;
      }
      if (++v2 >= (unint64_t)*(unsigned __int16 *)(a1 + 64)) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    unint64_t v5 = *(void *)(a1 + 112);
    unint64_t v6 = *(void *)(a1 + 120);
    if (v5 < v6)
    {
      if (v6 <= v5 + 4) {
        unint64_t v6 = v5 + 4;
      }
      memset((void *)v5, 255, ((v6 + ~v5) & 0xFFFFFFFFFFFFFFFCLL) + 4);
    }
    *(_DWORD *)(a1 + 128) = 0;
    uint64_t v7 = *(void *)(a1 + 136);
    if (v7)
    {
      OOCAllocator_Free(*(void *)(a1 + 24), v7);
      *(void *)(a1 + 136) = 0;
    }
    uint64_t result = 0;
    *(void *)(a1 + 144) = 0;
    *(_DWORD *)(a1 + 152) = -1;
  }
  return result;
}

void FSTMerge_SetStatePool(uint64_t a1, uint64_t a2)
{
  v4.n128_f64[0] = FST_SetStatePool(a1, a2);
  if (!v5 && *(_WORD *)(a1 + 64))
  {
    unint64_t v6 = 0;
    do
    {
      uint64_t v7 = *(void *)(*(void *)(a1 + 72) + 8 * v6);
      if ((*(unsigned int (**)(uint64_t, uint64_t, __n128))(*(void *)v7 + 128))(v7, a2, v4)) {
        break;
      }
      ++v6;
    }
    while (v6 < *(unsigned __int16 *)(a1 + 64));
  }
}

void *GetFSTMergeClass()
{
  return &__FSTMerge;
}

uint64_t FSTDfsContextMapper_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t result = FSTDfsContext_Con(a1, a2, a3);
  unsigned int v16 = result;
  if (result) {
    return result;
  }
  *(void *)a1 = &__FSTDfsContextMapper;
  *(_DWORD *)(a1 + 64) = a4;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  if (!a5 || (BOOL v10 = __CFADD__(a5, 1), v11 = (a5 + 1), v10))
  {
    uint64_t result = 0;
LABEL_6:
    *(void *)(a1 + 48) = 0x100000001;
    return result;
  }
  if (v11 >= 9) {
    unsigned int v12 = v11;
  }
  else {
    unsigned int v12 = 8;
  }
  uint64_t v13 = OOCAllocator_Realloc(a2, 0, 4 * v12, &v16);
  *(void *)(a1 + 80) = v13;
  uint64_t result = v16;
  if (!v16)
  {
    *(_DWORD *)(a1 + 72) = v12;
    unint64_t v14 = v13 + 4 * v11;
    if (v14 <= v13 + 4) {
      unint64_t v14 = v13 + 4;
    }
    size_t v15 = ((v14 + ~v13) & 0xFFFFFFFFFFFFFFFCLL) + 4;
    bzero((void *)v13, v15);
    *(void *)(a1 + 88) = v13 + v15;
    uint64_t result = v16;
    goto LABEL_6;
  }
  return result;
}

uint64_t FSTDfsContextMapper_Des(uint64_t *a1)
{
  uint64_t v2 = a1[10];
  if (v2) {
    OOCAllocator_Free(a1[1], v2);
  }
  uint64_t v3 = a1[13];
  if (v3) {
    OOCAllocator_Free(a1[1], v3);
  }

  return FSTDfsContext_Des((uint64_t)a1);
}

uint64_t FSTDfsContextMapper_BorrowMap(uint64_t a1)
{
  return a1 + 96;
}

uint64_t FSTDfsContextMapper_DiscoverState()
{
  return 0;
}

uint64_t FSTDfsContextMapper_ExploreNonTreeArc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v16 = 0;
  uint64_t v3 = *(int *)(a3 + 4);
  uint64_t v4 = (v3 + 1);
  uint64_t v5 = *(void *)(a1 + 80);
  unint64_t v6 = *(void *)(a1 + 88);
  unint64_t v7 = v6 - v5;
  if (v4 < ((v6 - v5) >> 2))
  {
LABEL_16:
    ++*(_DWORD *)(v5 + 4 * v3);
    return v16;
  }
  unsigned int v9 = *(_DWORD *)(a1 + 72);
  if (v4 <= v9)
  {
LABEL_12:
    if (v6 < v5 + 4 * (unint64_t)v4)
    {
      unint64_t v14 = v5 + 4 * v4;
      if (v14 <= v6 + 4) {
        unint64_t v14 = v6 + 4;
      }
      size_t v15 = ((v14 + ~v6) & 0xFFFFFFFFFFFFFFFCLL) + 4;
      bzero((void *)v6, v15);
      *(void *)(a1 + 88) = v6 + v15;
    }
    goto LABEL_16;
  }
  unsigned int v10 = 2 * v9;
  unsigned int v11 = v9 + 1000000;
  if (v10 < v11) {
    unsigned int v11 = v10;
  }
  if (v11 <= v4) {
    unsigned int v11 = v3 + 1;
  }
  if (v11 <= 8) {
    unsigned int v12 = 8;
  }
  else {
    unsigned int v12 = v11;
  }
  uint64_t v5 = OOCAllocator_Realloc(*(void *)(a1 + 8), v5, 4 * v12, &v16);
  *(void *)(a1 + 80) = v5;
  uint64_t result = v16;
  if (!v16)
  {
    *(_DWORD *)(a1 + 72) = v12;
    unint64_t v6 = v5 + (v7 & 0x3FFFFFFFCLL);
    *(void *)(a1 + 88) = v6;
    goto LABEL_12;
  }
  return result;
}

uint64_t FSTDfsContextMapper_SortByCount(uint64_t a1)
{
  unsigned int v8 = 0;
  uint64_t v2 = (*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2;
  uint64_t v3 = *(void *)(a1 + 104);
  if (*(_DWORD *)(a1 + 96) < v2)
  {
    if (v2 <= 8) {
      unsigned int v4 = 8;
    }
    else {
      unsigned int v4 = (*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2;
    }
    uint64_t v3 = OOCAllocator_Realloc(*(void *)(a1 + 8), v3, 4 * v4, &v8);
    *(void *)(a1 + 104) = v3;
    uint64_t result = v8;
    if (v8) {
      return result;
    }
    *(_DWORD *)(a1 + 96) = v4;
    uint64_t v2 = (*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2;
  }
  *(void *)(a1 + 112) = v3 + 4 * v2;
  if (v2)
  {
    uint64_t v6 = 0;
    do
    {
      *(_DWORD *)(v3 + 4 * v6) = v6;
      ++v6;
    }
    while (v2 != v6);
  }
  lhstdlib_pqsort(v3, v2, 4uLL, (uint64_t (*)(void))FSTDfsContextMapperCompare, a1);
  *(_DWORD *)(a1 + 72) = 0;
  uint64_t v7 = *(void *)(a1 + 80);
  if (v7)
  {
    OOCAllocator_Free(*(void *)(a1 + 8), v7);
    *(void *)(a1 + 80) = 0;
  }
  *(void *)(a1 + 88) = 0;
  return v8;
}

uint64_t FSTDfsContextMapperCompare(unsigned int *a1, unsigned int *a2, uint64_t a3)
{
  return (*(_DWORD *)(*(void *)(a3 + 80) + 4 * *a1) - *(_DWORD *)(*(void *)(a3 + 80) + 4 * *a2));
}

uint64_t PNEW_FSTDfsContextMapper_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 120, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = FSTDfsContextMapper_Con(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *a6 = v12;
    }
  }
  return result;
}

void *GetFSTDfsContextMapperClass()
{
  return &__FSTDfsContextMapper;
}

double FSTStatePool_Con(uint64_t a1, uint64_t a2, int a3)
{
  if (!RefCounted_Con(a1, 1))
  {
    *(void *)a1 = &__FSTStatePool;
    *(_DWORD *)(a1 + 40) = a3;
    *(void *)&double result = 0x3200000000;
    *(void *)(a1 + 44) = 0x3200000000;
    *(void *)(a1 + 24) = a2;
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

uint64_t FSTStatePool_Des(uint64_t *a1)
{
  while (1)
  {
    uint64_t v2 = a1[4];
    if (!v2) {
      break;
    }
    a1[4] = *(unsigned int *)(v2 + 28) | ((unint64_t)*(unsigned int *)(v2 + 24) << 32);
    (*(void (**)(uint64_t *))(*a1 + 24))(a1);
    uint64_t result = OOC_PlacementDeleteObject(a1[3], v2);
    if (result) {
      return result;
    }
  }

  return RefCounted_Des(a1);
}

uint64_t FSTStatePool_PopFSTState(uint64_t a1, uint64_t *a2)
{
  int v4 = *(_DWORD *)(a1 + 44);
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    *a2 = v5;
    unint64_t v6 = *(unsigned int *)(v5 + 28) | ((unint64_t)*(unsigned int *)(v5 + 24) << 32);
    *(_DWORD *)(a1 + 44) = v4 - 1;
    *(void *)(a1 + 32) = v6;
    FSTState_Clean(*a2);
    (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
    return 0;
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 24);
    uint64_t v9 = *(void *)(a1 + 24);
    return PNEW_FSTState_Con(v8, v9, a1, a2);
  }
}

uint64_t FSTStatePool_PushFSTState(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 44);
  if (v2 >= *(_DWORD *)(a1 + 40)) {
    return OOC_PlacementDeleteObject(*(void *)(a1 + 24), a2);
  }
  uint64_t v3 = *(void *)(a2 + 56);
  if (v3) {
    LODWORD(v3) = *(_DWORD *)(v3 - 4);
  }
  uint64_t v4 = *(void *)(a2 + 40);
  if (v4) {
    LODWORD(v4) = *(_DWORD *)(v4 - 4);
  }
  unsigned int v5 = *(_DWORD *)(a1 + 48);
  if (v3 <= v5)
  {
    BOOL v6 = v4 >= v5;
    BOOL v7 = v4 == v5;
  }
  else
  {
    BOOL v6 = 1;
    BOOL v7 = 0;
  }
  if (!v7 && v6) {
    return OOC_PlacementDeleteObject(*(void *)(a1 + 24), a2);
  }
  uint64_t v8 = *(void *)(a1 + 32);
  *(_DWORD *)(a1 + 44) = v2 + 1;
  *(_DWORD *)(a2 + 24) = HIDWORD(v8);
  *(_DWORD *)(a2 + 28) = v8;
  *(void *)(a1 + 32) = a2;
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
}

double PNEW_FSTStatePool_Con(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  int v11 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 56, &v11);
  if (!v11)
  {
    int v10 = RefCounted_Con(v8, 1);
    if (v10)
    {
      int v11 = v10;
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
    }
    else
    {
      *(void *)uint64_t v8 = &__FSTStatePool;
      *(_DWORD *)(v8 + 40) = a3;
      *(void *)&double result = 0x3200000000;
      *(void *)(v8 + 44) = 0x3200000000;
      *(void *)(v8 + 24) = a2;
      *(void *)(v8 + 32) = 0;
      *(void *)(v8 + 16) = a1;
      *a4 = v8;
    }
  }
  return result;
}

void *GetFSTStatePoolClass()
{
  return &__FSTStatePool;
}

void FSTCreateFromBuffer(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4, uint64_t a5, void *a6)
{
  long long v18 = 0u;
  long long v19 = 0u;
  memset(v17, 0, sizeof(v17));
  unint64_t v16 = a3;
  int v15 = 0;
  FST_Con(v17, a1, 0);
  if (!v12 && !FST_ReadHeader(v17, a4, &v15, &v16))
  {
    uint64_t v14 = 0;
    if (!__Get_FSTStorageFormat(v18, &v14))
    {
      uint64_t v13 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, unint64_t, const void *, uint64_t, void *))(v14 + 8);
      if (v13)
      {
        if (v13(a1, a1, a2, a3, a4, a5, a6)) {
          *a6 = 0;
        }
        else {
          FST_Des((uint64_t)v17);
        }
      }
      else
      {
        err_GenerateErrorNotSupported();
      }
    }
  }
}

uint64_t __Get_FSTStorageFormat(int a1, void *a2)
{
  uint64_t v6 = 0;
  uint64_t result = FSTFormatRegistry_GetInstance(0, 0, &v6);
  if (!result)
  {
    Format = FSTFormatRegistry_GetFormat(v6, a1);
    *a2 = Format;
    if (Format) {
      return 0;
    }
    else {
      return err_GenerateErrorNotSupported();
    }
  }
  return result;
}

void FSTCreateFromRandomReader(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  long long v15 = 0u;
  long long v16 = 0u;
  memset(v14, 0, sizeof(v14));
  uint64_t v13 = 0;
  int v12 = 0;
  unsigned int HeaderSizeInRandomReader = FST_GetHeaderSizeInRandomReader(a3, &v13);
  if (!HeaderSizeInRandomReader)
  {
    uint64_t v8 = (const void *)OOCAllocator_Malloc(a1, v13, &HeaderSizeInRandomReader);
    if (!HeaderSizeInRandomReader)
    {
      unsigned int HeaderSizeInRandomReader = (*(uint64_t (**)(uint64_t, const void *, uint64_t))(*(void *)a3 + 8))(a3 - *(void *)(*(void *)a3 + 56), v8, v13);
      if (!HeaderSizeInRandomReader)
      {
        FST_Con(v14, a1, 0);
        unsigned int HeaderSizeInRandomReader = v9;
        if (!v9)
        {
          unsigned int HeaderSizeInRandomReader = FST_ReadHeader(v14, v8, &v12, (unint64_t *)&v13);
          if (!HeaderSizeInRandomReader)
          {
            unsigned int HeaderSizeInRandomReader = (**(uint64_t (***)(uint64_t, void))a3)(a3 - *(void *)(*(void *)a3 + 56), 0);
            if (!HeaderSizeInRandomReader)
            {
              uint64_t v11 = 0;
              unsigned int HeaderSizeInRandomReader = __Get_FSTStorageFormat(v15, &v11);
              if (!HeaderSizeInRandomReader)
              {
                int v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(v11 + 16);
                if (v10)
                {
                  unsigned int HeaderSizeInRandomReader = v10(a1, a1, a2, a3, a4);
                  if (HeaderSizeInRandomReader)
                  {
                    *a4 = 0;
                  }
                  else
                  {
                    OOCAllocator_Free(a1, (uint64_t)v8);
                    FST_Des((uint64_t)v14);
                  }
                }
                else
                {
                  err_GenerateErrorNotSupported();
                }
              }
            }
          }
        }
      }
    }
  }
}

void FSTCreateFromIStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t v10 = 0;
  if (!PNEW_DataSectionRandomReader_Con(a1, a1, a3, a4, 0, 0, 0xFFFFFFFF, 0, &v10))
  {
    FSTCreateFromRandomReader(a1, a2, v10 + 24, a6);
    if (!v9) {
      (*(void (**)(uint64_t))(*(void *)v10 + 32))(v10);
    }
  }
}

uint64_t fstnormalize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  int v10 = 0;
  uint64_t result = FST_QueryProperties(a3, 1024, &v10);
  if (!result)
  {
    if (v10)
    {
      uint64_t result = 0;
      *a4 = a3;
    }
    else
    {
      uint64_t v9 = 0;
      uint64_t result = PNEW_FSTNormalize_Con(a1, a2, a3, &v9);
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 32))(a3);
        if (!result) {
          *a4 = v9;
        }
      }
    }
  }
  return result;
}

uint64_t PNEW_FSTNormalize_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 96, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = FSTNormalize_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *(void *)(v8 + 16) = a1;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t FSTNormalize_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = _FSTUnaryOperator_Con(a1, a2, a3);
  if (!result)
  {
    *(void *)a1 = &__FSTNormalize;
    uint64_t v14 = 0;
    *(void *)(a1 + 72) = 0;
    BOOL v7 = (uint64_t *)(a1 + 72);
    uint64_t result = dpmemblock_Create(a2, 4, 0x400u, (uint64_t *)(a1 + 72));
    if (!result)
    {
      int v8 = -12;
      do
      {
        uint64_t result = dpmemblock_GetNewElement(*v7, &v14, 0);
        if (!v8) {
          break;
        }
        ++v8;
      }
      while (!result);
      if (!result)
      {
        uint64_t v9 = *v7;
        if (*(_DWORD *)(*v7 + 32))
        {
          unsigned int v10 = 0;
          uint64_t v11 = *(void *)(v9 + 8);
          __int16 v12 = *(_WORD *)(v9 + 44);
          do
          {
            uint64_t v13 = *(void *)(v11 + 8 * (v10 >> v12));
            if (!v13) {
              break;
            }
            *(_DWORD *)(v13 + 4 * (v10++ & ~(-1 << v12))) = -1;
          }
          while (v10 < *(_DWORD *)(v9 + 32));
        }
        *(void *)(a1 + 80) = 0;
        uint64_t result = dpmemblock_Create(a2, 8, 0x400u, (uint64_t *)(a1 + 80));
        if (!result)
        {
          *(_DWORD *)(a1 + 88) = -1;
          *(_DWORD *)(a1 + 32) = 6;
          _FSTUnaryOperator_InheritProperties((int8x8_t *)a1, a3, 0x400u, 256, 0, 260863);
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t FSTNormalize_Des(uint64_t a1)
{
  dpmemblock_Free(*(uint64_t **)(a1 + 72));
  dpmemblock_Free(*(uint64_t **)(a1 + 80));
  *(_DWORD *)(a1 + 88) = -1;

  return FSTUnaryOperator_Des(a1);
}

uint64_t FSTNormalize_FetchState(uint64_t a1, unsigned int a2, uint64_t a3, void *a4)
{
  uint64_t v50 = 0;
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, _DWORD **))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), *(unsigned int *)(*(void *)(*(void *)(*(void *)(a1 + 80) + 8)+ 8 * (a2 >> *(_WORD *)(*(void *)(a1 + 80) + 44)))+ 8 * (a2 & ~(-1 << *(_WORD *)(*(void *)(a1 + 80) + 44)))+ 4), a3, &v50);
  if (!result)
  {
    int v8 = v50;
    if (!v50) {
      goto LABEL_42;
    }
    if ((v50[2] & 0x3FFFFFE) == 0)
    {
LABEL_8:
      v8[6] = a2;
      unsigned int v10 = (unsigned int *)*((void *)v8 + 5);
      uint64_t v11 = *((void *)v8 + 7) + 16 * v8[12];
      if (v10 != (unsigned int *)v11)
      {
        __int16 v12 = &v10[4 * v8[8]];
        while (2)
        {
          if (v10 != v12) {
            goto LABEL_13;
          }
          int v8 = v50;
          if (v50[12])
          {
            unsigned int v10 = (unsigned int *)*((void *)v50 + 7);
LABEL_13:
            unsigned int v13 = *v10;
            uint64_t v14 = *(void *)(a1 + 72);
            uint64_t v15 = *(void *)(v14 + 8);
            unsigned int v16 = *(_DWORD *)(v14 + 32);
            __int16 v17 = *(_WORD *)(v14 + 44);
            int v18 = ~(-1 << v17);
            long long v19 = (unsigned int *)(*(void *)(v15 + 8 * ((v13 % v16) >> v17)) + 4 * ((v13 % v16) & v18));
            while (1)
            {
              unsigned int v20 = *v19;
              if ((*v19 & 0x80000000) != 0) {
                break;
              }
              long long v19 = (unsigned int *)(*(void *)(*(void *)(*(void *)(a1 + 80) + 8)
                                               + 8 * (v20 >> *(_WORD *)(*(void *)(a1 + 80) + 44)))
                                   + 8 * (v20 & ~(-1 << *(_WORD *)(*(void *)(a1 + 80) + 44))));
              if (v13 == v19[1]) {
                goto LABEL_40;
              }
            }
            unsigned int v20 = *(_DWORD *)(a1 + 88);
            uint64_t v21 = *(void *)(a1 + 80);
            if (v20 != -1)
            {
              uint64_t v22 = *(void *)(v21 + 8);
              char v23 = *(_WORD *)(v21 + 44);
              uint64_t v24 = v20 >> v23;
              uint64_t v25 = v20 & ~(-1 << v23);
              unsigned int v26 = (_DWORD *)(*(void *)(v22 + 8 * v24) + 8 * v25);
              *(_DWORD *)(a1 + 88) = (*v26 & 0xBFFFFFFF) - 1;
              *unsigned int v26 = 0;
              v26[1] = v13;
              goto LABEL_39;
            }
            unsigned int v20 = *(_DWORD *)(v21 + 32);
            if (v20 <= 2 * v16)
            {
LABEL_37:
              uint64_t v49 = 0;
              uint64_t result = dpmemblock_GetNewElement(v21, &v49, 0);
              if (result) {
                return result;
              }
              uint64_t v43 = v49;
              *uint64_t v49 = 0;
              v43[1] = v13;
              uint64_t v14 = *(void *)(a1 + 72);
              uint64_t v44 = *(void *)(a1 + 80);
              uint64_t v15 = *(void *)(v14 + 8);
              __int16 v17 = *(_WORD *)(v14 + 44);
              uint64_t v22 = *(void *)(v44 + 8);
              char v45 = *(_WORD *)(v44 + 44);
              int v18 = ~(-1 << v17);
              uint64_t v24 = v20 >> v45;
              uint64_t v25 = v20 & ~(-1 << v45);
LABEL_39:
              unsigned int v46 = v13 % *(_DWORD *)(v14 + 32);
              uint64_t v47 = *(void *)(v15 + 8 * (v46 >> v17));
              unsigned int v48 = v46 & v18;
              *(_DWORD *)(*(void *)(v22 + 8 * v24) + 8 * v25) = *(_DWORD *)(v47 + 4 * v48);
              *(_DWORD *)(v47 + 4 * v48) = v20;
LABEL_40:
              *unsigned int v10 = v20;
              v10 += 4;
              if (v10 != (unsigned int *)v11) {
                continue;
              }
              int v8 = v50;
              break;
            }
            uint64_t v49 = 0;
            unsigned int v27 = (2 * v16) | 1;
            if (v27 <= v16)
            {
              *(_DWORD *)(v14 + 32) = v27;
            }
            else
            {
              unsigned int v28 = v16 + 1;
              do
              {
                uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 72), &v49, 0);
                if (v28 >= v27) {
                  break;
                }
                ++v28;
              }
              while (!result);
              if (result) {
                return result;
              }
              uint64_t v14 = *(void *)(a1 + 72);
              unsigned int v27 = *(_DWORD *)(v14 + 32);
              if (!v27) {
                goto LABEL_31;
              }
            }
            unsigned int v29 = 0;
            uint64_t v30 = *(void *)(v14 + 8);
            __int16 v31 = *(_WORD *)(v14 + 44);
            do
            {
              uint64_t v32 = *(void *)(v30 + 8 * (v29 >> v31));
              if (!v32) {
                break;
              }
              *(_DWORD *)(v32 + 4 * (v29++ & ~(-1 << v31))) = -1;
            }
            while (v29 < *(_DWORD *)(v14 + 32));
LABEL_31:
            uint64_t v21 = *(void *)(a1 + 80);
            unsigned int v20 = *(_DWORD *)(v21 + 32);
            if (v20)
            {
              unsigned int v33 = 0;
              uint64_t v34 = *(void *)(v21 + 8);
              __int16 v35 = *(_WORD *)(v21 + 44);
              do
              {
                uint64_t v36 = *(void *)(v34 + 8 * (v33 >> v35));
                if (!v36) {
                  break;
                }
                uint64_t v37 = v33 & ~(-1 << v35);
                unint64_t v38 = (_DWORD *)(v36 + 8 * v37);
                if (((*v38 + 1) & 0x40000000) == 0)
                {
                  unsigned int v39 = *(_DWORD *)(v36 + 8 * v37 + 4) % v27;
                  char v40 = *(_WORD *)(v14 + 44);
                  uint64_t v41 = *(void *)(*(void *)(v14 + 8) + 8 * (v39 >> v40));
                  unsigned int v42 = v39 & ~(-1 << v40);
                  *unint64_t v38 = *(_DWORD *)(v41 + 4 * v42);
                  *(_DWORD *)(v41 + 4 * v42) = v33;
                  unsigned int v20 = *(_DWORD *)(v21 + 32);
                }
                ++v33;
              }
              while (v33 < v20);
            }
            goto LABEL_37;
          }
          break;
        }
      }
LABEL_42:
      uint64_t result = 0;
      *a4 = v8;
      return result;
    }
    uint64_t v49 = 0;
    uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), (uint64_t *)&v49);
    if (!result)
    {
      uint64_t result = FSTState_Copy((uint64_t)v49, (uint64_t)v50);
      if (!result)
      {
        int v9 = v50[2];
        v50[2] = v9 - 1;
        if ((v9 & 0x3FFFFFF) == 0) {
          return 9;
        }
        int v8 = v49;
        uint64_t v50 = v49;
        goto LABEL_8;
      }
    }
  }
  return result;
}

uint64_t FSTNormalize_FillBuffer(uint64_t a1, char *__dst, uint64_t *a3)
{
  if (__dst)
  {
    uint64_t v6 = *a3;
  }
  else
  {
    uint64_t v6 = 0;
    *a3 = 0;
  }
  uint64_t v11 = v6;
  uint64_t result = FST_FillHeader((_DWORD *)a1, __dst, 1, &v11);
  if (!result)
  {
    uint64_t v8 = v11;
    if (__dst) {
      int v9 = &__dst[v11];
    }
    else {
      int v9 = 0;
    }
    if (*a3) {
      uint64_t v10 = *a3 - v11;
    }
    else {
      uint64_t v10 = 0;
    }
    uint64_t v11 = v10;
    uint64_t result = (*(uint64_t (**)(void, char *, uint64_t *))(**(void **)(a1 + 64) + 80))(*(void *)(a1 + 64), v9, &v11);
    if (!result) {
      *a3 = v11 + v8;
    }
  }
  return result;
}

uint64_t FSTNormalize_GetFinalStateWeight(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 64) + 64))(*(void *)(a1 + 64), *(unsigned int *)(*(void *)(*(void *)(*(void *)(a1 + 80) + 8)+ 8 * (a2 >> *(_WORD *)(*(void *)(a1 + 80) + 44)))+ 8 * (a2 & ~(-1 << *(_WORD *)(*(void *)(a1 + 80) + 44)))+ 4));
}

uint64_t FSTNormalize_GetInitialStateId(uint64_t a1, unsigned int *a2)
{
  uint64_t v36 = 0;
  uint64_t result = (*(uint64_t (**)(void, char *))(**(void **)(a1 + 64) + 48))(*(void *)(a1 + 64), (char *)&v36 + 4);
  if (result) {
    return result;
  }
  unsigned int v5 = HIDWORD(v36);
  unsigned int v6 = -1;
  if (HIDWORD(v36) == -1)
  {
LABEL_10:
    uint64_t result = 0;
    *a2 = v6;
    return result;
  }
  uint64_t v7 = *(void *)(a1 + 72);
  unsigned int v8 = *(_DWORD *)(v7 + 32);
  int v9 = (unsigned int *)(*(void *)(*(void *)(v7 + 8) + 8 * ((HIDWORD(v36) % v8) >> *(_WORD *)(v7 + 44)))
                      + 4 * ((HIDWORD(v36) % v8) & ~(-1 << *(_WORD *)(v7 + 44))));
  while (1)
  {
    unsigned int v10 = *v9;
    if ((*v9 & 0x80000000) != 0) {
      break;
    }
    int v9 = (unsigned int *)(*(void *)(*(void *)(*(void *)(a1 + 80) + 8)
                                    + 8 * (v10 >> *(_WORD *)(*(void *)(a1 + 80) + 44)))
                        + 8 * (v10 & ~(-1 << *(_WORD *)(*(void *)(a1 + 80) + 44))));
    if (HIDWORD(v36) == v9[1])
    {
      unsigned int v6 = v10;
      goto LABEL_10;
    }
  }
  unsigned int v6 = *(_DWORD *)(a1 + 88);
  uint64_t v11 = *(void *)(a1 + 80);
  if (v6 != -1)
  {
    char v12 = *(_WORD *)(v11 + 44);
    uint64_t v13 = *(void *)(*(void *)(v11 + 8) + 8 * (v6 >> v12));
    unsigned int v14 = v6 & ~(-1 << v12);
    *(_DWORD *)(a1 + 88) = (*(_DWORD *)(v13 + 8 * v14) & 0xBFFFFFFF) - 1;
    *(void *)(v13 + 8 * v14) = v36;
LABEL_9:
    uint64_t v15 = *(void *)(a1 + 72);
    unsigned int v16 = v5 % *(_DWORD *)(v15 + 32);
    uint64_t v17 = *(void *)(v15 + 8);
    LOBYTE(v15) = *(_WORD *)(v15 + 44);
    uint64_t v18 = *(void *)(v17 + 8 * (v16 >> v15));
    LODWORD(v15) = v16 & ~(-1 << v15);
    *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 80) + 8)
                          + 8 * (v6 >> *(_WORD *)(*(void *)(a1 + 80) + 44)))
              + 8 * (v6 & ~(-1 << *(_WORD *)(*(void *)(a1 + 80) + 44)))) = *(_DWORD *)(v18
                                                                                           + 4 * v15);
    *(_DWORD *)(v18 + 4 * v15) = v6;
    goto LABEL_10;
  }
  unsigned int v6 = *(_DWORD *)(v11 + 32);
  if (v6 <= 2 * v8) {
    goto LABEL_30;
  }
  __int16 v35 = 0;
  unsigned int v19 = (2 * v8) | 1;
  if (v19 <= v8)
  {
    *(_DWORD *)(v7 + 32) = v19;
  }
  else
  {
    unsigned int v20 = v8 + 1;
    do
    {
      uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 72), &v35, 0);
      if (v20 >= v19) {
        break;
      }
      ++v20;
    }
    while (!result);
    if (result) {
      return result;
    }
    uint64_t v7 = *(void *)(a1 + 72);
    unsigned int v19 = *(_DWORD *)(v7 + 32);
    if (!v19) {
      goto LABEL_24;
    }
  }
  unsigned int v21 = 0;
  uint64_t v22 = *(void *)(v7 + 8);
  __int16 v23 = *(_WORD *)(v7 + 44);
  do
  {
    uint64_t v24 = *(void *)(v22 + 8 * (v21 >> v23));
    if (!v24) {
      break;
    }
    *(_DWORD *)(v24 + 4 * (v21++ & ~(-1 << v23))) = -1;
  }
  while (v21 < *(_DWORD *)(v7 + 32));
LABEL_24:
  uint64_t v11 = *(void *)(a1 + 80);
  unsigned int v6 = *(_DWORD *)(v11 + 32);
  if (v6)
  {
    unsigned int v25 = 0;
    uint64_t v26 = *(void *)(v11 + 8);
    __int16 v27 = *(_WORD *)(v11 + 44);
    do
    {
      uint64_t v28 = *(void *)(v26 + 8 * (v25 >> v27));
      if (!v28) {
        break;
      }
      uint64_t v29 = v25 & ~(-1 << v27);
      uint64_t v30 = (_DWORD *)(v28 + 8 * v29);
      if (((*v30 + 1) & 0x40000000) == 0)
      {
        unsigned int v31 = *(_DWORD *)(v28 + 8 * v29 + 4) % v19;
        char v32 = *(_WORD *)(v7 + 44);
        uint64_t v33 = *(void *)(*(void *)(v7 + 8) + 8 * (v31 >> v32));
        unsigned int v34 = v31 & ~(-1 << v32);
        *uint64_t v30 = *(_DWORD *)(v33 + 4 * v34);
        *(_DWORD *)(v33 + 4 * v34) = v25;
        unsigned int v6 = *(_DWORD *)(v11 + 32);
      }
      ++v25;
    }
    while (v25 < v6);
  }
LABEL_30:
  __int16 v35 = 0;
  uint64_t result = dpmemblock_GetNewElement(v11, &v35, 0);
  if (!result)
  {
    *__int16 v35 = v36;
    goto LABEL_9;
  }
  return result;
}

uint64_t FSTNormalize_GetMappedStateId(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 72);
  uint64_t v3 = (int *)(*(void *)(*(void *)(v2 + 8) + 8 * ((a2 % *(_DWORD *)(v2 + 32)) >> *(_WORD *)(v2 + 44)))
             + 4 * ((a2 % *(_DWORD *)(v2 + 32)) & ~(-1 << *(_WORD *)(v2 + 44))));
  do
  {
    int v4 = *v3;
    if (*v3 < 0) {
      break;
    }
    uint64_t v3 = (int *)(*(void *)(*(void *)(*(void *)(a1 + 80) + 8)
                           + 8 * (v4 >> *(_WORD *)(*(void *)(a1 + 80) + 44)))
               + 8 * (v4 & ~(-1 << *(_WORD *)(*(void *)(a1 + 80) + 44))));
  }
  while (v3[1] != a2);
  if (v4 < 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v4;
  }
}

uint64_t FSTNormalize_GetMemoryInfo(uint64_t a1)
{
  uint64_t MemoryInfo = FSTUnaryOperator_GetMemoryInfo(a1);
  int UnitSize = dpmemblock_GetUnitSize(*(void *)(a1 + 72));
  uint64_t v4 = *(void *)(a1 + 72);
  uint64_t v5 = (*(_DWORD *)(v4 + 36) * UnitSize);
  uint64_t v6 = *(unsigned int *)(v4 + 28);
  return MemoryInfo
       + v5
       + *(_DWORD *)(*(void *)(a1 + 80) + 36) * dpmemblock_GetUnitSize(*(void *)(a1 + 80))
       + 8 * (*(unsigned int *)(*(void *)(a1 + 80) + 28) + v6)
       + 120;
}

uint64_t FSTNormalize_GetStateFlags(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 64) + 56))(*(void *)(a1 + 64), *(unsigned int *)(*(void *)(*(void *)(*(void *)(a1 + 80) + 8)+ 8 * (a2 >> *(_WORD *)(*(void *)(a1 + 80) + 44)))+ 8 * (a2 & ~(-1 << *(_WORD *)(*(void *)(a1 + 80) + 44)))+ 4));
}

void *GetFSTNormalizeClass()
{
  return &__FSTNormalize;
}

void FSTStreamedCompact_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v22 = 0;
  unint64_t v20 = 0;
  unsigned int v21 = 0;
  int v19 = 0;
  FST_AllocateExtendedHeaderFromRandomReader(a2, a4, 24, (const void **)&v21, &v20, &v22, &v19);
  if (!v8)
  {
    if (v19 != 21) {
      goto LABEL_13;
    }
    unint64_t v10 = v20;
    int v9 = v21;
    v21[2] = 22;
    double v11 = _FSTBaseFlat_Con((void *)a1, a2, a3, v10, v9, a2, 3u);
    if (v12) {
      return;
    }
    *(void *)a1 = &__FSTStreamedCompact;
    *(void *)(a1 + 112) = a4;
    *(void *)(a1 + 144) = 0;
    *(void *)(a1 + 152) = 0;
    (*(void (**)(uint64_t, double))(*(void *)a4 + 48))(a4 - *(void *)(*(void *)a4 + 56), v11);
    if (v22 == 3)
    {
      uint64_t v13 = (char *)v21 + v10;
      uint64_t v15 = *(unsigned int *)((char *)v21 + v10 - 8);
      int v14 = *((_DWORD *)v13 - 1);
      *(void *)(a1 + 128) = 0;
      *(_DWORD *)(a1 + 136) = v14;
      *(_DWORD *)(a1 + 120) = *((_DWORD *)v13 - 3);
      if (!dpmemblock_Create(a2, 4, 0x400u, (uint64_t *)(a1 + 128))
        && !(**(unsigned int (***)(uint64_t, uint64_t))a4)(a4 - *(void *)(*(void *)a4 + 56), v15)
        && *(_DWORD *)(a1 + 120) != -1)
      {
        unsigned int v16 = 0;
        do
        {
          int v18 = 0;
          if ((*(unsigned int (**)(uint64_t, int *, uint64_t))(*(void *)a4 + 8))(a4 - *(void *)(*(void *)a4 + 56), &v18, 4))
          {
            break;
          }
          uint64_t v17 = 0;
          if (dpmemblock_GetNewElement(*(void *)(a1 + 128), &v17, 0)) {
            break;
          }
          *uint64_t v17 = v18;
          ++v16;
        }
        while (v16 < *(_DWORD *)(a1 + 120) + 1);
      }
    }
    else
    {
LABEL_13:
      err_GenerateErrorData();
    }
  }
}

void FSTStreamedCompact_ConFromIStream(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *a1 = &__FSTStreamedCompact;
  uint64_t v9 = 0;
  if (!PNEW_DataSectionRandomReader_Con(a2, a2, a4, a5, 0, 0, 0xFFFFFFFF, 0, &v9))
  {
    FSTStreamedCompact_Con((uint64_t)a1, a2, a3, v9 + 24);
    if (!v8) {
      (*(void (**)(uint64_t))(*(void *)v9 + 32))(v9);
    }
  }
}

uint64_t FSTStreamedCompact_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  dpmemblock_Free(*(uint64_t **)(a1 + 128));
  OOCAllocator_Free(v2, *(void *)(a1 + 144));
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 40))(*(void *)(a1 + 112) - *(void *)(**(void **)(a1 + 112) + 56));
  if (!result)
  {
    return FSTBaseFlat_Des(a1);
  }
  return result;
}

uint64_t FSTStreamedCompact_FetchState(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t *a4)
{
  unsigned int v32 = 0;
  int v7 = *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 128) + 8)
                             + 8 * (a2 >> *(_WORD *)(*(void *)(a1 + 128) + 44)))
                 + 4 * (a2 & ~(-1 << *(_WORD *)(*(void *)(a1 + 128) + 44))));
  unsigned int v8 = v7 & 0xF0000000;
  if (!FST_CheckQuery(v7 & 0xF0000000, a3))
  {
    uint64_t v17 = 0;
    *a4 = 0;
    return v17;
  }
  uint64_t v9 = *(void *)(a1 + 128);
  uint64_t v10 = *(void *)(v9 + 8);
  LOBYTE(v9) = *(_WORD *)(v9 + 44);
  int v11 = *(_DWORD *)(*(void *)(v10 + 8 * (a2 >> v9)) + 4 * (a2 & ~(-1 << v9))) & 0xFFFFFFF;
  int v12 = *(_DWORD *)(*(void *)(v10 + 8 * ((a2 + 1) >> v9)) + 4 * ((a2 + 1) & ~(-1 << v9))) & 0xFFFFFFF;
  unint64_t v13 = (7 * (v12 - v11));
  uint64_t v31 = 0;
  if (v12 == v11) {
    goto LABEL_58;
  }
  if (*(void *)(a1 + 152) < v13)
  {
    *(void *)(a1 + 144) = OOCAllocator_Realloc(*(void *)(a1 + 24), *(void *)(a1 + 144), (7 * (v12 - v11)), &v32);
    uint64_t v17 = v32;
    if (v32) {
      return v17;
    }
    *(void *)(a1 + 152) = v13;
  }
  uint64_t v17 = (***(uint64_t (****)(void, void))(a1 + 112))(*(void *)(a1 + 112) - *(void *)(**(void **)(a1 + 112) + 56), (*(_DWORD *)(a1 + 136) + 7 * v11));
  unsigned int v32 = v17;
  if (!v17)
  {
    uint64_t v17 = (*(uint64_t (**)(void, void, unint64_t))(**(void **)(a1 + 112) + 8))(*(void *)(a1 + 112) - *(void *)(**(void **)(a1 + 112) + 56), *(void *)(a1 + 144), v13);
    unsigned int v32 = v17;
    if (!v17)
    {
LABEL_58:
      int v14 = *(unsigned int **)(a1 + 144);
      uint64_t v15 = (unsigned int *)((char *)v14 + v13);
      if (v7 < 0)
      {
        unsigned int v18 = *v14++;
        unsigned int v16 = bswap32(v18);
      }
      else
      {
        unsigned int v16 = 0x7FFFFFFF;
      }
      if ((char *)v15 - (char *)v14 <= 6 && *(unsigned __int8 *)v14 == 255) {
        int v14 = v15;
      }
      if (v14 == v15)
      {
        unsigned int v20 = 0;
        unsigned int v19 = 0;
      }
      else
      {
        unsigned int v19 = 0;
        unsigned int v20 = 0;
        unsigned int v21 = v14;
        do
        {
          long long v30 = 0uLL;
          uint64_t v29 = 0;
          FSTCompactCodec_DecodeArc(v21, (int *)&v30, &v29);
          unsigned int v21 = (unsigned int *)((char *)v21 + v29);
          if (DWORD1(v30) == -2) {
            ++v19;
          }
          else {
            ++v20;
          }
          if ((char *)v15 - (char *)v21 <= 6 && *(unsigned __int8 *)v21 == 255) {
            unsigned int v21 = v15;
          }
        }
        while (v21 != v15);
      }
      uint64_t v17 = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v31);
      unsigned int v32 = v17;
      if (!v17)
      {
        uint64_t v22 = v31;
        *(_DWORD *)(v31 + 8) |= v8;
        *(_DWORD *)(v22 + 24) = a2;
        *(_DWORD *)(v22 + 28) = v16;
        if (v19)
        {
          __int16 v23 = *(_OWORD **)(v22 + 40);
          if (!v23 || *((_DWORD *)v23 - 1) <= v19)
          {
            uint64_t v24 = _FSTState_ReserveEpsilonArcsInternal(v22, v19, &v32);
            uint64_t v17 = v32;
            if (v32) {
              return v17;
            }
            __int16 v23 = (_OWORD *)v24;
          }
          uint64_t v22 = v31;
          if (v20) {
            goto LABEL_34;
          }
        }
        else
        {
          __int16 v23 = 0;
          if (v20)
          {
LABEL_34:
            unsigned int v25 = *(_OWORD **)(v22 + 56);
            if (!v25 || *((_DWORD *)v25 - 1) <= v20)
            {
              uint64_t v26 = _FSTState_ReserveArcsInternal(v22, v20, &v32);
              uint64_t v17 = v32;
              if (v32) {
                return v17;
              }
              unsigned int v25 = (_OWORD *)v26;
            }
            uint64_t v22 = v31;
            goto LABEL_41;
          }
        }
        unsigned int v25 = 0;
LABEL_41:
        *(_DWORD *)(v22 + 32) = v19;
        *(_DWORD *)(v22 + 48) = v20;
        if (v14 != v15)
        {
          while (1)
          {
            long long v30 = 0uLL;
            uint64_t v29 = 0;
            FSTCompactCodec_DecodeArc(v14, (int *)&v30, &v29);
            if (v23 && DWORD1(v30) == -2)
            {
              __int16 v27 = v23++;
            }
            else
            {
              if (!v25) {
                goto LABEL_48;
              }
              __int16 v27 = v25++;
            }
            *__int16 v27 = v30;
LABEL_48:
            int v14 = (unsigned int *)((char *)v14 + v29);
            if ((char *)v15 - (char *)v14 <= 6 && *(unsigned __int8 *)v14 == 255) {
              int v14 = v15;
            }
            if (v14 == v15)
            {
              uint64_t v22 = v31;
              uint64_t v17 = v32;
              goto LABEL_54;
            }
          }
        }
        uint64_t v17 = 0;
LABEL_54:
        *a4 = v22;
      }
    }
  }
  return v17;
}

uint64_t FSTStreamedCompact_FillBuffer()
{
  return err_GenerateErrorNotSupported();
}

uint64_t FSTStreamedCompact_GetFinalStateWeight(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  int v4 = *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 128) + 8)
                             + 8 * (a2 >> *(_WORD *)(*(void *)(a1 + 128) + 44)))
                 + 4 * (a2 & ~(-1 << *(_WORD *)(*(void *)(a1 + 128) + 44))));
  if ((v4 & 0x80000000) == 0)
  {
    uint64_t result = 0;
    unsigned int v6 = 0x7FFFFFFF;
LABEL_3:
    *a3 = v6;
    return result;
  }
  unsigned int v8 = 0;
  uint64_t result = (***(uint64_t (****)(void, void))(a1 + 112))(*(void *)(a1 + 112) - *(void *)(**(void **)(a1 + 112) + 56), *(_DWORD *)(a1 + 136) - (v4 & 0xFFFFFFF) + 8 * (v4 & 0xFFFFFFFu));
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(void, unsigned int *, uint64_t))(**(void **)(a1 + 112) + 8))(*(void *)(a1 + 112) - *(void *)(**(void **)(a1 + 112) + 56), &v8, 4);
    if (!result)
    {
      unsigned int v6 = bswap32(v8);
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t FSTStreamedCompact_GetMemoryInfo(uint64_t a1)
{
  return FSTBaseFlat_GetMemoryInfo(a1) + *(void *)(a1 + 152) + 4 * *(unsigned int *)(a1 + 120) + 48;
}

uint64_t FSTStreamedCompact_GetStateFlags(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  *a3 = *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 128) + 8)
                              + 8 * (a2 >> *(_WORD *)(*(void *)(a1 + 128) + 44)))
                  + 4 * (a2 & ~(-1 << *(_WORD *)(*(void *)(a1 + 128) + 44)))) & 0xF0000000;
  return 0;
}

void PNEW_FSTStreamedCompact_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 160, &v12);
  if (!v12)
  {
    FSTStreamedCompact_Con(v10, a2, a3, a4);
    int v12 = v11;
    if (v11)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
    }
    else
    {
      *(void *)(v10 + 16) = a1;
      *a5 = v10;
    }
  }
}

void PNEW_FSTStreamedCompact_ConFromIStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  int v15 = 0;
  unint64_t v13 = (void *)OOCAllocator_Malloc(a1, 160, &v15);
  if (!v15)
  {
    FSTStreamedCompact_ConFromIStream(v13, a2, a3, a4, a5);
    int v15 = v14;
    if (v14)
    {
      OOCAllocator_Free(a1, (uint64_t)v13);
      *a7 = 0;
    }
    else
    {
      v13[2] = a1;
      *a7 = v13;
    }
  }
}

void *GetFSTStreamedCompactClass()
{
  return &__FSTStreamedCompact;
}

unint64_t strhash(unint64_t result)
{
  if (result)
  {
    unint64_t v1 = result;
    int v2 = *(unsigned __int8 *)result;
    if (*(unsigned char *)result)
    {
      LODWORD(result) = 0;
      uint64_t v3 = (unsigned __int8 *)(v1 + 1);
      do
      {
        unsigned int v4 = v2 + 16 * result;
        if ((v4 & 0xF0000000) != 0) {
          uint64_t result = v4 & 0xFFFFFFF ^ ((v4 & 0xF0000000) >> 24);
        }
        else {
          uint64_t result = v4;
        }
        int v5 = *v3++;
        int v2 = v5;
      }
      while (v5);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

unint64_t strnhash(unint64_t result, int a2)
{
  if (result)
  {
    unint64_t v2 = result;
    int v3 = *(unsigned __int8 *)result;
    uint64_t result = 0;
    if (v3 && a2 != 0)
    {
      int v5 = (unsigned __int8 *)(v2 + 1);
      int v6 = a2 - 1;
      do
      {
        unsigned int v7 = v3 + 16 * result;
        if ((v7 & 0xF0000000) != 0) {
          uint64_t result = v7 & 0xFFFFFFF ^ ((v7 & 0xF0000000) >> 24);
        }
        else {
          uint64_t result = v7;
        }
        int v8 = *v5++;
        int v3 = v8;
        BOOL v10 = v6-- != 0;
      }
      while (v3 && v10);
    }
  }
  return result;
}

uint64_t fsttrim(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  int v10 = 0;
  uint64_t result = FST_QueryProperties(a3, 2048, &v10);
  if (!result)
  {
    if (v10)
    {
      uint64_t result = 0;
      *a4 = a3;
    }
    else
    {
      uint64_t v9 = 0;
      uint64_t result = PNEW_FSTTrim_Con(a1, a2, a3, &v9);
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 32))(a3);
        if (!result) {
          *a4 = v9;
        }
      }
    }
  }
  return result;
}

uint64_t PNEW_FSTTrim_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 216, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = FSTTrim_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *(void *)(v8 + 16) = a1;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t FSTTrim_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = _FSTUnaryOperator_Con(a1, a2, a3);
  unsigned int v9 = result;
  if (!result)
  {
    *(void *)a1 = &__FSTTrim;
    *(_DWORD *)(a1 + 32) = 268435462;
    *(void *)(a1 + 40) |= 0x80000000800uLL;
    *(_DWORD *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
    *(_DWORD *)(a1 + 96) = 0;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 112) = 0;
    *(_DWORD *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = 0;
    *(_DWORD *)(a1 + 144) = 16;
    uint64_t v6 = OOCAllocator_Malloc(a2, 64, &v9);
    *(void *)(a1 + 152) = v6;
    uint64_t result = v9;
    if (!v9)
    {
      uint64_t v7 = *(unsigned int *)(a1 + 144);
      unint64_t v8 = v6 + 4 * v7;
      *(void *)(a1 + 160) = v8;
      if (v7)
      {
        if (v8 <= v6 + 4) {
          unint64_t v8 = v6 + 4;
        }
        memset((void *)v6, 255, ((v8 + ~v6) & 0xFFFFFFFFFFFFFFFCLL) + 4);
        uint64_t result = v9;
      }
      else
      {
        uint64_t result = 0;
      }
      *(_DWORD *)(a1 + 168) = 0;
      *(void *)(a1 + 176) = 0;
      *(void *)(a1 + 184) = 0;
      *(_DWORD *)(a1 + 192) = -1;
    }
  }
  return result;
}

uint64_t FSTTrim_Des(uint64_t *a1)
{
  uint64_t v2 = a1[3];
  uint64_t v3 = a1[10];
  if (v3) {
    OOCAllocator_Free(a1[3], v3);
  }
  uint64_t v4 = a1[13];
  if (v4) {
    OOCAllocator_Free(v2, v4);
  }
  uint64_t v5 = a1[16];
  if (v5) {
    OOCAllocator_Free(v2, v5);
  }
  uint64_t v6 = a1[19];
  if (v6) {
    OOCAllocator_Free(v2, v6);
  }
  uint64_t v7 = a1[22];
  if (v7) {
    OOCAllocator_Free(v2, v7);
  }

  return FSTUnaryOperator_Des((uint64_t)a1);
}

uint64_t FSTTrim_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v17 = 0;
  int v16 = 0;
  unint64_t v8 = *(uint64_t **)(a1 + 64);
  uint64_t result = __FSTTrim_CheckCoaccessible(a1, a2, &v16);
  if (!result)
  {
    if (v16)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, _DWORD **))(*v8 + 120))(v8, a2, a3, &v17);
      if (result) {
        return result;
      }
      unsigned int v10 = v17;
      if ((a3 & 0xB) != 0 && v17)
      {
        if ((v17[2] & 0x3FFFFFE) != 0)
        {
          int v15 = 0;
          uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), (uint64_t *)&v15);
          if (result) {
            return result;
          }
          uint64_t result = FSTState_Copy((uint64_t)v15, (uint64_t)v17);
          if (result) {
            return result;
          }
          int v11 = v17[2];
          _OWORD v17[2] = v11 - 1;
          if ((v11 & 0x3FFFFFF) == 0) {
            return 9;
          }
          unsigned int v10 = v15;
          uint64_t v17 = v15;
        }
        int v12 = (unsigned int *)*((void *)v10 + 7);
        LODWORD(v15) = v10[12];
        uint64_t result = __FSTTrim_FilterArcsInPlace(a1, v12, (unsigned int *)&v15);
        if (result) {
          return result;
        }
        unint64_t v13 = v17;
        v17[12] = v15;
        int v14 = (unsigned int *)*((void *)v13 + 5);
        LODWORD(v15) = v13[8];
        uint64_t result = __FSTTrim_FilterArcsInPlace(a1, v14, (unsigned int *)&v15);
        if (result) {
          return result;
        }
        unsigned int v10 = v17;
        v17[8] = v15;
      }
    }
    else
    {
      LODWORD(v15) = 0;
      uint64_t result = (*(uint64_t (**)(uint64_t *, _DWORD **))(*v8 + 48))(v8, &v15);
      if (result) {
        return result;
      }
      if (v15 == a2)
      {
        uint64_t result = FSTStatePool_PopFSTState(v8[6], (uint64_t *)&v17);
        if (result) {
          return result;
        }
      }
      unsigned int v10 = v17;
    }
    uint64_t result = 0;
    *a4 = v10;
  }
  return result;
}

uint64_t __FSTTrim_CheckCoaccessible(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unsigned int v66 = 0;
  uint64_t v6 = a2 + 1;
  uint64_t v7 = *(void *)(a1 + 80);
  unint64_t v8 = *(unsigned char **)(a1 + 88);
  unsigned int v9 = v8 - v7;
  if (v6 >= (int)v8 - (int)v7)
  {
    unsigned int v10 = *(_DWORD *)(a1 + 72);
    if (v6 > v10)
    {
      uint64_t v11 = *(void *)(a1 + 24);
      unsigned int v12 = 2 * v10;
      unsigned int v13 = v10 + 1000000;
      if (v12 >= v13) {
        unsigned int v12 = v13;
      }
      if (v12 <= v6) {
        unsigned int v12 = v6;
      }
      if (v12 <= 8) {
        uint64_t v14 = 8;
      }
      else {
        uint64_t v14 = v12;
      }
      uint64_t v7 = OOCAllocator_Realloc(v11, v7, v14, &v66);
      *(void *)(a1 + 80) = v7;
      uint64_t result = v66;
      if (v66) {
        return result;
      }
      *(_DWORD *)(a1 + 72) = v14;
      unint64_t v8 = (unsigned char *)(v7 + v9);
      *(void *)(a1 + 88) = v8;
    }
    if ((unint64_t)v8 < v7 + v6)
    {
      do
      {
        *unint64_t v8 = 0;
        unint64_t v8 = (unsigned char *)(*(void *)(a1 + 88) + 1);
        *(void *)(a1 + 88) = v8;
      }
      while ((unint64_t)v8 < v7 + v6);
      uint64_t result = v66;
      if (v66) {
        return result;
      }
      uint64_t v7 = *(void *)(a1 + 80);
    }
  }
  if ((int)v8 - (int)v7 > a2)
  {
    int v16 = *(unsigned char *)(v7 + a2) & 0xC;
    if ((*(unsigned char *)(v7 + a2) & 0xC) != 0) {
      goto LABEL_18;
    }
  }
  unsigned int v64 = 0;
  uint64_t v17 = *(void *)(a1 + 24);
  unint64_t v18 = *(void *)(a1 + 152);
  unint64_t v19 = *(void *)(a1 + 160);
  if (v18 < v19)
  {
    if (v19 <= v18 + 4) {
      unint64_t v19 = v18 + 4;
    }
    memset((void *)v18, 255, ((v19 + ~v18) & 0xFFFFFFFFFFFFFFFCLL) + 4);
  }
  *(_DWORD *)(a1 + 168) = 0;
  uint64_t v20 = *(void *)(a1 + 176);
  if (v20)
  {
    OOCAllocator_Free(v17, v20);
    *(void *)(a1 + 176) = 0;
    uint64_t v17 = *(void *)(a1 + 24);
  }
  *(void *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 192) = -1;
  *(_DWORD *)(a1 + 96) = 0;
  uint64_t v21 = *(void *)(a1 + 104);
  if (v21)
  {
    OOCAllocator_Free(v17, v21);
    *(void *)(a1 + 104) = 0;
  }
  *(void *)(a1 + 112) = 0;
  unint64_t v22 = *(void *)(a1 + 152);
  unint64_t v23 = *(void *)(a1 + 160);
  if (v22 < v23)
  {
    if (v23 <= v22 + 4) {
      unint64_t v23 = v22 + 4;
    }
    memset((void *)v22, 255, ((v23 + ~v22) & 0xFFFFFFFFFFFFFFFCLL) + 4);
  }
  *(_DWORD *)(a1 + 168) = 0;
  uint64_t v24 = *(void *)(a1 + 176);
  if (v24)
  {
    OOCAllocator_Free(v17, v24);
    *(void *)(a1 + 176) = 0;
  }
  unsigned int v65 = 0;
  *(void *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 192) = -1;
  *(_DWORD *)(a1 + 204) = 0;
  *(_DWORD *)(a1 + 208) = 0;
  uint64_t result = __FSTTrim_DfsStk_PushNew(a1, a2, &v65);
  if (!result)
  {
    unsigned int v66 = 0;
    uint64_t result = __FSTTrim_DfsOnStateInit(a1, v65, &v66);
    if (!result)
    {
      uint64_t v25 = *(void *)(a1 + 112);
      if (*(void *)(a1 + 104) == v25)
      {
LABEL_99:
        uint64_t result = __FSTTrim_SIColl_Cleanup(a1);
        if (!result)
        {
          uint64_t v61 = *(void *)(a1 + 24);
          *(_DWORD *)(a1 + 96) = 0;
          uint64_t v62 = *(void *)(a1 + 104);
          if (v62)
          {
            OOCAllocator_Free(v61, v62);
            *(void *)(a1 + 104) = 0;
          }
          *(void *)(a1 + 112) = 0;
          uint64_t result = __FSTTrim_SIColl_Cleanup(a1);
          if (!result)
          {
            uint64_t v63 = *(void *)(a1 + 80);
            if (*(_DWORD *)(a1 + 88) - (int)v63 <= a2) {
              int v16 = 0;
            }
            else {
              int v16 = *(unsigned char *)(v63 + a2) & 0xC;
            }
LABEL_18:
            uint64_t result = 0;
            *a3 = v16 == 8;
            return result;
          }
        }
        return result;
      }
      BOOL v26 = 1;
      while (1)
      {
        uint64_t v27 = *(unsigned int *)(v25 - 32);
        uint64_t v28 = *(void *)(a1 + 176);
        uint64_t v29 = (unsigned int *)(v28 + 32 * v27);
        if (!v26)
        {
LABEL_44:
          uint64_t result = __FSTTrim_SIColl_SetColor(a1, *v29, 2);
          if (result) {
            return result;
          }
          uint64_t v33 = *(void *)(a1 + 112);
          *(void *)(v33 - 16) = 0;
          uint64_t v34 = *(void *)(v33 - 24);
          int v35 = *(_DWORD *)(v34 + 8);
          *(_DWORD *)(v34 + 8) = v35 - 1;
          if ((v35 & 0x3FFFFFF) == 0) {
            return 9;
          }
          *(void *)(v33 - 24) = 0;
          *(void *)(a1 + 112) = v33 - 32;
          if (*(void *)(a1 + 104) == v33 - 32)
          {
            __FSTTrim_DfsOnStateFinished(a1, v27, 0xFFFFFFFF);
          }
          else
          {
            uint64_t result = __FSTTrim_DfsOnStateFinished(a1, v27, *(_DWORD *)(v33 - 64));
            if (result) {
              return result;
            }
            unint64_t v36 = *(void *)(v33 - 48) + 16;
            *(void *)(v33 - 48) = v36;
            if (!*(_DWORD *)(v33 - 40))
            {
              uint64_t v37 = *(void *)(v33 - 56);
              if (v36 >= *(void *)(v37 + 56) + 16 * (unint64_t)*(unsigned int *)(v37 + 48))
              {
                *(void *)(v33 - 48) = *(void *)(v37 + 40);
                *(_DWORD *)(v33 - 40) = 1;
              }
            }
          }
          uint64_t v38 = *(void *)(a1 + 176) + 32 * v27;
          uint64_t v41 = *(void *)(v38 + 8);
          char v40 = (void *)(v38 + 8);
          uint64_t v39 = v41;
          int v42 = *(_DWORD *)(v41 + 8);
          if ((v42 & 0x3FFFFFF) == 1)
          {
            if ((v42 & 0x8000000) != 0) {
              uint64_t v43 = *(void *)(v39 + 16);
            }
            else {
              uint64_t v43 = 0;
            }
            uint64_t result = FSTStatePool_PushFSTState(v43, v39);
            if (result) {
              return result;
            }
          }
          else
          {
            *(_DWORD *)(v39 + 8) = v42 - 1;
            if ((v42 & 0x3FFFFFF) == 0) {
              return 9;
            }
          }
          *char v40 = 0;
          goto LABEL_60;
        }
        int v30 = *(_DWORD *)(v25 - 8);
        uint64_t v32 = *(void *)(v25 - 24);
        uint64_t v31 = *(unsigned int **)(v25 - 16);
        if (v30)
        {
          if ((unint64_t)v31 >= *(void *)(v32 + 40) + 16 * (unint64_t)*(unsigned int *)(v32 + 32)) {
            goto LABEL_44;
          }
        }
        else if ((unint64_t)v31 >= *(void *)(v32 + 56) + 16 * (unint64_t)*(unsigned int *)(v32 + 48) {
               && !*(_DWORD *)(v32 + 32))
        }
        {
          goto LABEL_44;
        }
        uint64_t v44 = *v31;
        uint64_t v45 = *(void *)(a1 + 80);
        unsigned int v46 = *(_DWORD *)(a1 + 88) - v45;
        if (v44 >= v46) {
          goto LABEL_70;
        }
        char v47 = *(unsigned char *)(v45 + v44);
        if ((v47 & 3) == 2) {
          break;
        }
        if ((v47 & 3) != 1)
        {
          if ((v47 & 3) == 0)
          {
            if ((*(unsigned char *)(v45 + v44) & 0xC) != 0)
            {
              if (!v66)
              {
                BOOL v26 = 0;
                goto LABEL_60;
              }
              if (v66 != 2) {
                goto LABEL_73;
              }
            }
            else
            {
LABEL_70:
              unsigned int v66 = 2;
            }
            uint64_t result = __FSTTrim_DfsStk_PushNew(a1, v44, &v64);
            if (result) {
              return result;
            }
            uint64_t result = __FSTTrim_DfsOnStateInit(a1, v64, &v66);
            if (result) {
              return result;
            }
          }
LABEL_73:
          BOOL v26 = 1;
          goto LABEL_60;
        }
        unsigned int v50 = 9 * ((1025 * v44) ^ ((1025 * v44) >> 6));
        for (uint64_t i = *(unsigned int *)(*(void *)(a1 + 152)
                                  + 4
                                  * (32769 * (v50 ^ (v50 >> 11))
                                   % ((*(void *)(a1 + 160) - *(void *)(a1 + 152)) >> 2)));
              (i & 0x80000000) == 0;
              uint64_t i = *(unsigned int *)(v28 + 32 * i + 24))
        {
          if (*(_DWORD *)(v28 + 32 * i) == v44) {
            break;
          }
        }
        uint64_t v52 = (unsigned int *)(v28 + 32 * i);
        signed int v53 = v52[5];
        uint64_t v54 = v28 + 32 * v27;
        signed int v56 = *(_DWORD *)(v54 + 16);
        int v55 = (signed int *)(v54 + 16);
        if (v53 < v56) {
          *int v55 = v53;
        }
        uint64_t v57 = *v52;
        if (v57 < v46 && (*(unsigned char *)(v45 + v57) & 0xC) == 8)
        {
          uint64_t result = __FSTTrim_SIColl_SetCoaccessible(a1, *v29, 8);
          if (result) {
            return result;
          }
          BOOL v26 = 0;
          int v58 = 0;
          uint64_t v31 = *(unsigned int **)(v25 - 16);
        }
        else
        {
          int v58 = 2;
          BOOL v26 = 1;
        }
        unsigned int v66 = v58;
        unint64_t v59 = (unint64_t)(v31 + 4);
        *(void *)(v25 - 16) = v59;
        if (!*(_DWORD *)(v25 - 8))
        {
LABEL_96:
          uint64_t v60 = *(void *)(v25 - 24);
          if (v59 >= *(void *)(v60 + 56) + 16 * (unint64_t)*(unsigned int *)(v60 + 48))
          {
            *(void *)(v25 - 16) = *(void *)(v60 + 40);
            *(_DWORD *)(v25 - 8) = 1;
          }
        }
LABEL_60:
        uint64_t v25 = *(void *)(a1 + 112);
        if (*(void *)(a1 + 104) == v25) {
          goto LABEL_99;
        }
      }
      int v48 = v47 & 0xC;
      if ((*(unsigned char *)(v45 + v44) & 0xC) != 0)
      {
        if (v48 == 4)
        {
          int v49 = 1;
        }
        else
        {
          if (v48 != 8)
          {
            int v49 = v66;
LABEL_95:
            BOOL v26 = v49 != 0;
            unint64_t v59 = (unint64_t)(v31 + 4);
            *(void *)(v25 - 16) = v59;
            if (!v30) {
              goto LABEL_96;
            }
            goto LABEL_60;
          }
          uint64_t result = __FSTTrim_SIColl_SetCoaccessible(a1, *v29, 8);
          if (result) {
            return result;
          }
          int v49 = 0;
          uint64_t v31 = *(unsigned int **)(v25 - 16);
        }
      }
      else
      {
        int v49 = 2;
      }
      unsigned int v66 = v49;
      int v30 = *(_DWORD *)(v25 - 8);
      goto LABEL_95;
    }
  }
  return result;
}

uint64_t __FSTTrim_FilterArcsInPlace(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  uint64_t v4 = *a3;
  if (v4)
  {
    unint64_t v7 = 0;
    unsigned int v8 = 0;
    int v11 = 0;
    unsigned int v9 = a2;
    while (1)
    {
      uint64_t result = __FSTTrim_CheckCoaccessible(a1, *v9, &v11);
      if (result) {
        break;
      }
      if (v11)
      {
        if (v7 > v8) {
          *(_OWORD *)&a2[4 * v8] = *(_OWORD *)v9;
        }
        ++v8;
      }
      ++v7;
      v9 += 4;
      if (v4 == v7) {
        goto LABEL_11;
      }
    }
  }
  else
  {
    unsigned int v8 = 0;
LABEL_11:
    uint64_t result = 0;
    *a3 = v8;
  }
  return result;
}

uint64_t FSTTrim_GetFinalStateWeight(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  int v7 = 0;
  uint64_t result = __FSTTrim_CheckCoaccessible(a1, a2, &v7);
  if (!result)
  {
    if (v7)
    {
      uint64_t v6 = *(uint64_t (**)(void))(**(void **)(a1 + 64) + 64);
      return v6();
    }
    else
    {
      uint64_t result = 0;
      *a3 = 0x7FFFFFFF;
    }
  }
  return result;
}

uint64_t FSTTrim_GetMaxStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = -1;
  return 0;
}

unint64_t FSTTrim_GetMemoryInfo(unsigned int *a1)
{
  return FSTUnaryOperator_GetMemoryInfo((uint64_t)a1)
       + a1[18]
       + 4 * (a1[36] + (unint64_t)a1[30])
       + 32 * (a1[42] + (unint64_t)a1[24])
       + 144;
}

uint64_t FSTTrim_GetStateFlags(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v8 = 0;
  uint64_t result = FSTTrim_FetchState(a1, a2, 4, &v8);
  if (!result)
  {
    if (!v8)
    {
      unsigned int v6 = 0;
      goto LABEL_11;
    }
    int v5 = *(_DWORD *)(v8 + 8);
    unsigned int v6 = v5 & 0xF0000000;
    if ((v5 & 0x3FFFFFF) != 1)
    {
      *(_DWORD *)(v8 + 8) = v5 - 1;
      if ((v5 & 0x3FFFFFF) == 0) {
        return 9;
      }
      goto LABEL_11;
    }
    if ((v5 & 0x8000000) != 0) {
      uint64_t v7 = *(void *)(v8 + 16);
    }
    else {
      uint64_t v7 = 0;
    }
    uint64_t result = FSTStatePool_PushFSTState(v7, v8);
    if (!result)
    {
LABEL_11:
      uint64_t result = 0;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t FSTTrim_Reset(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  *(_DWORD *)(a1 + 72) = 0;
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3)
  {
    OOCAllocator_Free(v2, v3);
    *(void *)(a1 + 80) = 0;
  }
  *(void *)(a1 + 88) = 0;

  return FSTUnaryOperator_Reset(a1);
}

void *GetFSTTrimClass()
{
  return &__FSTTrim;
}

uint64_t __FSTTrim_DfsStk_PushNew(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  uint64_t v6 = *(void *)(a1 + 24);
  long long v50 = 0u;
  long long v51 = 0u;
  LODWORD(v50) = a2;
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64));
  if (result) {
    return result;
  }
  *(void *)&long long v51 = -1;
  uint64_t v8 = *(void *)(a1 + 24);
  unsigned int v9 = 9 * ((1025 * v50) ^ ((1025 * v50) >> 6));
  unsigned int v10 = 32769 * (v9 ^ (v9 >> 11));
  unsigned int v52 = 0;
  int v11 = *(_DWORD **)(a1 + 152);
  unint64_t v12 = *(void *)(a1 + 160) - (void)v11;
  LODWORD(v13) = v11[v10 % (v12 >> 2)];
  if ((v13 & 0x80000000) != 0)
  {
LABEL_7:
    LODWORD(v13) = *(_DWORD *)(a1 + 192);
    if (v13 == -1)
    {
      uint64_t v17 = *(void *)(a1 + 176);
      unint64_t v18 = *(_OWORD **)(a1 + 184);
      uint64_t v13 = ((unint64_t)v18 - v17) >> 5;
      unsigned int v19 = 2 * (v12 >> 2);
      if (v19 >= v13)
      {
        unint64_t v23 = ((unint64_t)v18 - v17) >> 5;
      }
      else
      {
        unsigned int v20 = v19 | 1;
        uint64_t v21 = *(unsigned int *)(a1 + 144);
        if (v20 <= v21)
        {
          uint64_t v13 = 4 * v21;
        }
        else
        {
          if (v20 <= 8) {
            unsigned int v22 = 8;
          }
          else {
            unsigned int v22 = v20;
          }
          uint64_t v13 = 4 * v22;
          int v11 = (_DWORD *)OOCAllocator_Realloc(v8, (uint64_t)v11, v13, &v52);
          *(void *)(a1 + 152) = v11;
          uint64_t result = v52;
          if (v52) {
            return result;
          }
          *(_DWORD *)(a1 + 144) = v22;
          v12 &= 0x3FFFFFFFCuLL;
        }
        unint64_t v24 = (v12 >> 1) & 0xFFFFFFFE | 1;
        *(void *)(a1 + 160) = &v11[v24];
        cstdlib_memset(v11, 255, v13);
        uint64_t v17 = *(void *)(a1 + 176);
        unint64_t v18 = *(_OWORD **)(a1 + 184);
        unint64_t v23 = ((unint64_t)v18 - v17) >> 5;
        LODWORD(v13) = v23;
        if (v23)
        {
          uint64_t v25 = 0;
          BOOL v26 = (_DWORD *)(v17 + 24);
          do
          {
            if (((*v26 + 1) & 0x40000000) == 0)
            {
              unsigned int v27 = 9 * ((1025 * *(v26 - 6)) ^ ((1025 * *(v26 - 6)) >> 6));
              unsigned int v52 = 0;
              unint64_t v28 = 32769 * (v27 ^ (v27 >> 11))
                  - (32769 * (v27 ^ (v27 >> 11)) / v24) * (unint64_t)v24;
              uint64_t v29 = *(void *)(a1 + 152);
              *BOOL v26 = *(_DWORD *)(v29 + 4 * v28);
              *(_DWORD *)(v29 + 4 * v28) = v25;
            }
            ++v25;
            v26 += 8;
          }
          while ((((unint64_t)v18 - v17) >> 5) != v25);
        }
      }
      unsigned int v30 = v13 + 1;
      unsigned int v31 = *(_DWORD *)(a1 + 168);
      if ((int)v13 + 1 > v31)
      {
        unsigned int v32 = 2 * v31;
        unsigned int v33 = v31 + 1000000;
        if (v32 >= v33) {
          unsigned int v32 = v33;
        }
        if (v32 > v30) {
          unsigned int v30 = v32;
        }
        if (v30 <= 8) {
          unsigned int v34 = 8;
        }
        else {
          unsigned int v34 = v30;
        }
        uint64_t v35 = OOCAllocator_Realloc(v8, v17, 32 * v34, &v52);
        *(void *)(a1 + 176) = v35;
        uint64_t result = v52;
        if (v52) {
          return result;
        }
        *(_DWORD *)(a1 + 168) = v34;
        unint64_t v18 = (_OWORD *)(v35 + 32 * v23);
      }
      *(void *)(a1 + 184) = v18 + 2;
      *unint64_t v18 = v50;
      v18[1] = v51;
      uint64_t v15 = (int)v13;
    }
    else
    {
      uint64_t v15 = (int)v13;
      uint64_t v16 = *(void *)(a1 + 176) + 32 * (int)v13;
      *(_DWORD *)(a1 + 192) = (*(_DWORD *)(v16 + 24) & 0xBFFFFFFF) - 1;
      *(_OWORD *)uint64_t v16 = v50;
      *(_OWORD *)(v16 + 16) = v51;
    }
    uint64_t v36 = *(void *)(a1 + 152);
    unsigned int v37 = v10 % ((unint64_t)(*(void *)(a1 + 160) - v36) >> 2);
    *(_DWORD *)(*(void *)(a1 + 176) + 32 * v15 + 24) = *(_DWORD *)(v36 + 4 * v37);
    *(_DWORD *)(v36 + 4 * v37) = v13;
    uint64_t result = v52;
    unsigned int v52 = result;
    if (result) {
      return result;
    }
  }
  else
  {
    uint64_t v14 = *(void *)(a1 + 176);
    while (1)
    {
      unsigned int v52 = 0;
      if (v50 == *(_DWORD *)(v14 + 32 * v13)) {
        break;
      }
      LODWORD(v13) = *(_DWORD *)(v14 + 32 * v13 + 24);
      if ((v13 & 0x80000000) != 0) {
        goto LABEL_7;
      }
    }
    unsigned int v52 = 0;
  }
  ++MEMORY[8];
  BOOL v38 = MEMORY[0x30] == 0;
  uint64_t v39 = 56;
  if (!MEMORY[0x30]) {
    uint64_t v39 = 40;
  }
  uint64_t v40 = *(void *)v39;
  uint64_t v41 = *(void *)(a1 + 104);
  uint64_t v42 = *(void *)(a1 + 112);
  uint64_t v43 = v42 - v41;
  unsigned int v44 = ((unint64_t)(v42 - v41) >> 5) + 1;
  unsigned int v45 = *(_DWORD *)(a1 + 96);
  if (v44 <= v45) {
    goto LABEL_48;
  }
  unsigned int v46 = 2 * v45;
  unsigned int v47 = v45 + 1000000;
  if (v46 >= v47) {
    unsigned int v46 = v47;
  }
  if (v46 <= v44) {
    unsigned int v46 = v44;
  }
  if (v46 <= 8) {
    unsigned int v48 = 8;
  }
  else {
    unsigned int v48 = v46;
  }
  uint64_t v49 = OOCAllocator_Realloc(v6, v41, 32 * v48, &v52);
  *(void *)(a1 + 104) = v49;
  uint64_t result = v52;
  if (!v52)
  {
    *(_DWORD *)(a1 + 96) = v48;
    uint64_t v42 = v49 + (v43 & 0x1FFFFFFFE0);
LABEL_48:
    *(void *)(a1 + 112) = v42 + 32;
    *(_DWORD *)uint64_t v42 = v13;
    *(_DWORD *)(v42 + 4) = 0;
    *(void *)(v42 + 8) = 0;
    *(void *)(v42 + 16) = v40;
    *(_DWORD *)(v42 + 24) = v38;
    *(_DWORD *)(v42 + 28) = 0;
    uint64_t result = __FSTTrim_SIColl_SetColor(a1, a2, 1);
    if (!result) {
      *a3 = v13;
    }
  }
  return result;
}

uint64_t __FSTTrim_DfsOnStateInit(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unsigned int v21 = 0;
  uint64_t v6 = *(void *)(a1 + 176);
  uint64_t v7 = *(void *)(a1 + 128);
  uint64_t v8 = *(_DWORD **)(a1 + 136);
  unint64_t v9 = (unint64_t)v8 - v7;
  unsigned int v10 = (((unint64_t)v8 - v7) >> 2) + 1;
  unsigned int v11 = *(_DWORD *)(a1 + 120);
  if (v10 <= v11) {
    goto LABEL_11;
  }
  uint64_t v12 = *(void *)(a1 + 24);
  unsigned int v13 = 2 * v11;
  unsigned int v14 = v11 + 1000000;
  if (v13 >= v14) {
    unsigned int v13 = v14;
  }
  if (v13 <= v10) {
    unsigned int v13 = v10;
  }
  if (v13 <= 8) {
    unsigned int v15 = 8;
  }
  else {
    unsigned int v15 = v13;
  }
  uint64_t v16 = OOCAllocator_Realloc(v12, v7, 4 * v15, &v21);
  *(void *)(a1 + 128) = v16;
  uint64_t v17 = v21;
  if (!v21)
  {
    *(_DWORD *)(a1 + 120) = v15;
    uint64_t v8 = (_DWORD *)(v16 + (v9 & 0x3FFFFFFFCLL));
LABEL_11:
    unint64_t v18 = (int32x2_t *)(v6 + 32 * a2);
    *uint64_t v8 = v18->i32[0];
    *(void *)(a1 + 136) = v8 + 1;
    unsigned int v19 = *(_DWORD *)(a1 + 208);
    _OWORD v18[2] = vdup_n_s32(v19);
    *(_DWORD *)(a1 + 208) = v19 + 1;
    *a3 = 2;
    return v21;
  }
  return v17;
}

uint64_t __FSTTrim_SIColl_SetColor(uint64_t a1, unsigned int a2, char a3)
{
  unsigned int v16 = 0;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = *(void *)(a1 + 80);
  uint64_t v7 = *(unsigned char **)(a1 + 88);
  unsigned int v8 = v7 - v6;
  if (v5 < (int)v7 - (int)v6)
  {
LABEL_15:
    *(unsigned char *)(v6 + a2) = *(unsigned char *)(v6 + a2) & 0xFC | a3;
    return v16;
  }
  unsigned int v10 = *(_DWORD *)(a1 + 72);
  if (v5 <= v10)
  {
LABEL_12:
    if ((unint64_t)v7 < v6 + v5)
    {
      do
      {
        unsigned char *v7 = 0;
        uint64_t v7 = (unsigned char *)(*(void *)(a1 + 88) + 1);
        *(void *)(a1 + 88) = v7;
      }
      while ((unint64_t)v7 < v6 + v5);
      uint64_t v6 = *(void *)(a1 + 80);
    }
    goto LABEL_15;
  }
  uint64_t v11 = *(void *)(a1 + 24);
  unsigned int v12 = 2 * v10;
  unsigned int v13 = v10 + 1000000;
  if (v12 >= v13) {
    unsigned int v12 = v13;
  }
  if (v12 <= v5) {
    unsigned int v12 = v5;
  }
  if (v12 <= 8) {
    uint64_t v14 = 8;
  }
  else {
    uint64_t v14 = v12;
  }
  uint64_t v6 = OOCAllocator_Realloc(v11, v6, v14, &v16);
  *(void *)(a1 + 80) = v6;
  uint64_t result = v16;
  if (!v16)
  {
    *(_DWORD *)(a1 + 72) = v14;
    uint64_t v7 = (unsigned char *)(v6 + v8);
    *(void *)(a1 + 88) = v7;
    goto LABEL_12;
  }
  return result;
}

uint64_t __FSTTrim_DfsOnStateFinished(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v5 = *(void *)(a1 + 176);
  uint64_t v6 = a2;
  uint64_t v7 = (unsigned int *)(v5 + 32 * a2);
  unsigned int v8 = (_DWORD *)*((void *)v7 + 1);
  if ((v8[2] & 0x80000000) != 0)
  {
    unsigned int v9 = *v7;
    char v10 = 8;
  }
  else
  {
    if (v8[12] || v8[8]) {
      goto LABEL_7;
    }
    unsigned int v9 = *v7;
    char v10 = 4;
  }
  uint64_t result = __FSTTrim_SIColl_SetCoaccessible(a1, v9, v10);
  if (result) {
    return result;
  }
LABEL_7:
  uint64_t v12 = v5 + 32 * v6;
  int v13 = *(_DWORD *)(v12 + 16);
  int v14 = *(_DWORD *)(v12 + 20);
  unsigned int v15 = (_DWORD *)(v12 + 16);
  if (v14 == v13)
  {
    int v16 = 0;
    uint64_t v17 = *(void *)(a1 + 80);
    int v18 = *v7;
    unsigned int v19 = (unsigned int *)(((*(void *)(a1 + 136) - *(void *)(a1 + 128)) & 0x3FFFFFFFCLL) + *(void *)(a1 + 128) - 4);
    do
    {
      unsigned int v21 = *v19--;
      uint64_t v20 = v21;
      if (v21 < *(_DWORD *)(a1 + 88) - (int)v17 && (*(unsigned char *)(v17 + v20) & 0xC) == 8) {
        int v16 = 1;
      }
    }
    while (v18 != v20);
    do
    {
      uint64_t v22 = *(void *)(a1 + 136);
      unsigned int v23 = *(_DWORD *)(v22 - 4);
      *(void *)(a1 + 136) = v22 - 4;
      if (v16)
      {
        uint64_t result = __FSTTrim_SIColl_SetCoaccessible(a1, v23, 8);
        if (result) {
          return result;
        }
        int v18 = *v7;
      }
    }
    while (v18 != v23);
    ++*(_DWORD *)(a1 + 204);
  }
  if (a3 == -1) {
    return 0;
  }
  uint64_t v24 = *(void *)(a1 + 176);
  uint64_t v25 = *v7;
  uint64_t v26 = *(void *)(a1 + 80);
  if (v25 >= *(_DWORD *)(a1 + 88) - (int)v26
    || (*(unsigned char *)(v26 + v25) & 0xC) != 8
    || (uint64_t result = __FSTTrim_SIColl_SetCoaccessible(a1, *(_DWORD *)(v24 + 32 * a3), 8), !result))
  {
    uint64_t v27 = v24 + 32 * a3;
    int v29 = *(_DWORD *)(v27 + 16);
    unint64_t v28 = (_DWORD *)(v27 + 16);
    if (*v15 < v29)
    {
      uint64_t result = 0;
      _DWORD *v28 = *v15;
      return result;
    }
    return 0;
  }
  return result;
}

uint64_t __FSTTrim_SIColl_Cleanup(uint64_t a1)
{
  unsigned int v10 = 0;
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 152);
  if (v3) {
    OOCAllocator_Free(*(void *)(a1 + 24), v3);
  }
  uint64_t v4 = *(void *)(a1 + 176);
  if (v4) {
    OOCAllocator_Free(v2, v4);
  }
  *(_DWORD *)(a1 + 144) = 16;
  uint64_t v5 = OOCAllocator_Malloc(v2, 64, &v10);
  *(void *)(a1 + 152) = v5;
  uint64_t v6 = v10;
  if (!v10)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 144);
    unint64_t v8 = v5 + 4 * v7;
    *(void *)(a1 + 160) = v8;
    if (v7)
    {
      if (v8 <= v5 + 4) {
        unint64_t v8 = v5 + 4;
      }
      memset((void *)v5, 255, ((v8 + ~v5) & 0xFFFFFFFFFFFFFFFCLL) + 4);
      uint64_t v6 = v10;
    }
    else
    {
      uint64_t v6 = 0;
    }
    *(_DWORD *)(a1 + 168) = 0;
    *(void *)(a1 + 176) = 0;
    *(void *)(a1 + 184) = 0;
    *(_DWORD *)(a1 + 192) = -1;
  }
  return v6;
}

uint64_t __FSTTrim_SIColl_SetCoaccessible(uint64_t a1, unsigned int a2, char a3)
{
  unsigned int v16 = 0;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = *(void *)(a1 + 80);
  uint64_t v7 = *(unsigned char **)(a1 + 88);
  unsigned int v8 = v7 - v6;
  if (v5 < (int)v7 - (int)v6)
  {
LABEL_15:
    *(unsigned char *)(v6 + a2) = *(unsigned char *)(v6 + a2) & 0xF3 | a3;
    return v16;
  }
  unsigned int v10 = *(_DWORD *)(a1 + 72);
  if (v5 <= v10)
  {
LABEL_12:
    if ((unint64_t)v7 < v6 + v5)
    {
      do
      {
        unsigned char *v7 = 0;
        uint64_t v7 = (unsigned char *)(*(void *)(a1 + 88) + 1);
        *(void *)(a1 + 88) = v7;
      }
      while ((unint64_t)v7 < v6 + v5);
      uint64_t v6 = *(void *)(a1 + 80);
    }
    goto LABEL_15;
  }
  uint64_t v11 = *(void *)(a1 + 24);
  unsigned int v12 = 2 * v10;
  unsigned int v13 = v10 + 1000000;
  if (v12 >= v13) {
    unsigned int v12 = v13;
  }
  if (v12 <= v5) {
    unsigned int v12 = v5;
  }
  if (v12 <= 8) {
    uint64_t v14 = 8;
  }
  else {
    uint64_t v14 = v12;
  }
  uint64_t v6 = OOCAllocator_Realloc(v11, v6, v14, &v16);
  *(void *)(a1 + 80) = v6;
  uint64_t result = v16;
  if (!v16)
  {
    *(_DWORD *)(a1 + 72) = v14;
    uint64_t v7 = (unsigned char *)(v6 + v8);
    *(void *)(a1 + 88) = v7;
    goto LABEL_12;
  }
  return result;
}

uint64_t fstrescale(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, void *a6)
{
  uint64_t v9 = 0;
  uint64_t result = PNEW_FSTRescale_Con(a1, a2, a3, a4, a5, &v9);
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 32))(a3);
    if (!result) {
      *a6 = v9;
    }
  }
  return result;
}

uint64_t PNEW_FSTRescale_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 80, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = _FSTUnaryOperator_Con(v12, a2, a3);
    if (result)
    {
      unsigned int v14 = result;
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *(void *)uint64_t v12 = &__FSTRescale;
      *(_DWORD *)(v12 + 72) = a4;
      *(_DWORD *)(v12 + 76) = a5;
      *(void *)(v12 + 16) = a1;
      *a6 = v12;
    }
  }
  return result;
}

uint64_t FSTRescale_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t result = _FSTUnaryOperator_Con(a1, a2, a3);
  if (!result)
  {
    *(void *)a1 = &__FSTRescale;
    *(_DWORD *)(a1 + 72) = a4;
    *(_DWORD *)(a1 + 76) = a5;
  }
  return result;
}

uint64_t FSTRescale_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v19 = 0;
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, a3, &v19);
  if (!result)
  {
    uint64_t v7 = v19;
    if (!v19)
    {
LABEL_23:
      uint64_t result = 0;
      *a4 = v7;
      return result;
    }
    if ((*(_DWORD *)(v19 + 8) & 0x3FFFFFE) == 0)
    {
LABEL_8:
      uint64_t v9 = *(void *)(v7 + 40);
      uint64_t v10 = *(void *)(v7 + 56);
      uint64_t v11 = *(unsigned int *)(v7 + 48);
      uint64_t v12 = v10 + 16 * v11;
      if (v9 != v12)
      {
        uint64_t v13 = v9 + 16 * *(unsigned int *)(v7 + 32);
        do
        {
          if (v9 == v13 && !v11) {
            break;
          }
          if (v9 == v13) {
            uint64_t v9 = v10;
          }
          int v14 = *(_DWORD *)(a1 + 76);
          int v15 = v14 >= 0 ? *(_DWORD *)(a1 + 76) : v14 + 1;
          *(_DWORD *)(v9 + 12) = (*(_DWORD *)(v9 + 12) * *(_DWORD *)(a1 + 72) + (v15 >> 1)) / v14;
          v9 += 16;
        }
        while (v9 != v12);
      }
      if ((*(_DWORD *)(v7 + 8) & 0x80000000) != 0)
      {
        int v16 = *(_DWORD *)(a1 + 76);
        if (v16 >= 0) {
          int v17 = *(_DWORD *)(a1 + 76);
        }
        else {
          int v17 = v16 + 1;
        }
        *(_DWORD *)(v7 + 28) = (*(_DWORD *)(a1 + 72) * *(_DWORD *)(v7 + 28) + (v17 >> 1)) / v16;
      }
      goto LABEL_23;
    }
    uint64_t v18 = 0;
    uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v18);
    if (!result)
    {
      uint64_t result = FSTState_Copy(v18, v19);
      if (!result)
      {
        int v8 = *(_DWORD *)(v19 + 8);
        *(_DWORD *)(v19 + 8) = v8 - 1;
        if ((v8 & 0x3FFFFFF) == 0) {
          return 9;
        }
        uint64_t v7 = v18;
        goto LABEL_8;
      }
    }
  }
  return result;
}

uint64_t FSTRescale_GetFinalStateWeight(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 64))(*(void *)(a1 + 64));
  if (!result)
  {
    int v6 = *a3 * *(_DWORD *)(a1 + 72);
    *a3 = v6;
    int v7 = v6 + *(_DWORD *)(a1 + 76) / 2;
    *a3 = v7;
    *a3 = v7 / *(_DWORD *)(a1 + 76);
  }
  return result;
}

uint64_t FSTRescale_GetMemoryInfo(uint64_t a1)
{
  return FSTUnaryOperator_GetMemoryInfo(a1) + 8;
}

uint64_t FSTRescale_GetStateFlags(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 56))(*(void *)(a1 + 64));
}

void *GetFSTRescaleClass()
{
  return &__FSTRescale;
}

uint64_t FSTDump()
{
  return 0;
}

uint64_t FSTCountBfsContext_Con(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = FSTBfsContext_Con((uint64_t)a1, a2, a3);
  if (!v4)
  {
    *a1 = &__FSTCountBfsContext;
    cstdlib_memset(a1 + 10, 0, 0x18uLL);
  }
  return v4;
}

uint64_t FSTCountBfsContext_DiscoverState(_DWORD *a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 24);
  if (v2 > a1[20]) {
    a1[20] = v2;
  }
  ++a1[21];
  if ((*(_DWORD *)(a2 + 8) & 0x80000000) != 0) {
    ++a1[22];
  }
  return 0;
}

uint64_t FSTCountBfsContext_ExploreArc(_DWORD *a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 4) == -2) {
    ++a1[24];
  }
  if (*(_DWORD *)(a2 + 8) == -2) {
    ++a1[25];
  }
  return 0;
}

uint64_t PNEW_FSTCountBfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unsigned int v10 = 0;
  int v8 = (void *)OOCAllocator_Malloc(a1, 104, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = FSTCountBfsContext_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

void *GetFSTCountBfsContextClass()
{
  return &__FSTCountBfsContext;
}

void fstconcat(uint64_t a1, uint64_t a2, void *a3, unsigned __int32 a4, void *a5)
{
  int v6 = a3;
  if (a4 == 1)
  {
    *a5 = *a3;
  }
  else
  {
    unsigned int v10 = 0;
    PNEW_FSTConcat_Con(a1, a2, a3, a4, &v10);
    if (!v8)
    {
      *a5 = v10;
      if (a4)
      {
        uint64_t v9 = a4;
        do
        {
          if ((*(unsigned int (**)(void))(*(void *)*v6 + 32))(*v6)) {
            break;
          }
          v6 += 5;
          --v9;
        }
        while (v9);
      }
    }
  }
}

void PNEW_FSTConcat_Con(uint64_t a1, uint64_t a2, void *a3, unsigned __int32 a4, int8x8_t **a5)
{
  int v12 = 0;
  unsigned int v10 = (int8x8_t *)OOCAllocator_Malloc(a1, 96, &v12);
  if (!v12)
  {
    FSTConcat_Con(v10, a2, a3, a4);
    int v12 = v11;
    if (v11)
    {
      OOCAllocator_Free(a1, (uint64_t)v10);
      *a5 = 0;
    }
    else
    {
      v10[2] = (int8x8_t)a1;
      *a5 = v10;
    }
  }
}

void FSTConcat_Con(int8x8_t *a1, uint64_t a2, void *a3, unsigned __int32 a4)
{
  uint64_t v5 = a3;
  FST_Con(a1, a2, *(void *)(*a3 + 48));
  int v13 = v8;
  if (!v8)
  {
    *a1 = (int8x8_t)&__FSTConcat;
    a1[10] = 0;
    __int32 v9 = *(_DWORD *)(*v5 + 36);
    a1[4].i32[0] = 31;
    a1[4].i32[1] = v9;
    a1[8].i32[0] = a4;
    a1[9] = (int8x8_t)OOCAllocator_Malloc(a2, (unint64_t)a4 << 6, &v13);
    if (!v13)
    {
      a1[5] = vorr_s8(vand_s8(a1[5], (int8x8_t)0x300000003), (int8x8_t)0x1430000004000);
      if (a4)
      {
        uint64_t v10 = 0;
        unint64_t v11 = (unint64_t)a4 << 6;
        do
        {
          cstdlib_memcpy((void *)(*(void *)&a1[9] + v10), v5, 0x28uLL);
          (*(void (**)(void))(*(void *)*v5 + 24))(*v5);
          uint64_t v12 = *v5;
          v5 += 5;
          __FSTConcat_InheritProperties((uint64_t)a1, v12);
          v10 += 64;
        }
        while (v11 != v10);
      }
      __FSTConcat_InitComponents((uint64_t)a1);
    }
  }
}

double __FSTConcat_InheritProperties(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 40);
  int v2 = *(_DWORD *)(a2 + 44);
  if ((v3 & v2 & 0x200) != 0)
  {
    *(void *)&double result = *(void *)(a1 + 40) | 0x20000000200;
    *(double *)(a1 + 40) = result;
    int v3 = *(_DWORD *)(a2 + 40);
    int v2 = *(_DWORD *)(a2 + 44);
  }
  if ((v3 & v2 & 0x10000) != 0)
  {
    *(void *)&double result = *(void *)(a1 + 40) | 0x1000000010000;
    *(double *)(a1 + 40) = result;
    int v2 = *(_DWORD *)(a2 + 44);
  }
  if ((v2 & 0x4000) != 0)
  {
    LODWORD(v5) = *(void *)(a1 + 40) & 0xFFFFBFFF;
    *(void *)&double result = *(void *)(a1 + 40) | 0x400000004000;
    HIDWORD(v5) = HIDWORD(result);
    *(void *)(a1 + 40) = v5;
  }
  return result;
}

uint64_t __FSTConcat_InitComponents(uint64_t a1)
{
  *(void *)(a1 + 88) = -1;
  if (*(_DWORD *)(a1 + 64))
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    unsigned int v4 = 0;
    uint64_t v5 = *(void *)(a1 + 72);
    while (1)
    {
      int v17 = 0;
      uint64_t result = (*(uint64_t (**)(void, int *))(**(void **)(v5 + v2) + 48))(*(void *)(v5 + v2), &v17);
      if (result) {
        return result;
      }
      int v7 = (_DWORD *)(*(void *)(a1 + 72) + v2);
      v7[10] = v17;
      uint64_t result = (*(uint64_t (**)(void, int *))(**(void **)v7 + 72))(*(void *)v7, &v17);
      if (result) {
        return result;
      }
      int v8 = v17;
      if (v17 == -1)
      {
        memset(v16, 0, sizeof(v16));
        uint64_t result = FSTCount(*(void *)(a1 + 24), *(void *)(*(void *)(a1 + 72) + v2), (uint64_t)v16);
        if (result) {
          return result;
        }
        int v8 = v16[0];
        int v17 = v16[0];
      }
      uint64_t v5 = *(void *)(a1 + 72);
      uint64_t v9 = v5 + v2;
      *(_DWORD *)(v9 + 44) = v8;
      *(_DWORD *)(v9 + 48) = v4;
      if (-2 - v8 >= v4)
      {
        v4 += v8 + 1;
      }
      else
      {
        _FST_SetStatus(a1, 1);
        uint64_t v5 = *(void *)(a1 + 72);
        unsigned int v4 = -1;
      }
      uint64_t v10 = v5 + v2;
      int v11 = *(_DWORD *)(v5 + v2 + 8);
      if ((v11 & 0x20) != 0)
      {
        uint64_t v13 = *(unsigned int *)(v10 + 36);
        if (v13 == -1)
        {
LABEL_17:
          v11 |= 4u;
          *(_DWORD *)(v10 + 8) = v11;
          *(void *)(v10 + 56) = 0;
          goto LABEL_18;
        }
        uint64_t v12 = v5 + (v13 << 6);
      }
      else
      {
        if (v3 == *(_DWORD *)(a1 + 64) - 1) {
          goto LABEL_17;
        }
        uint64_t v12 = v5 + v2 + 64;
      }
      *(void *)(v10 + 56) = v12;
LABEL_18:
      unsigned int v14 = *(_DWORD *)(a1 + 92);
      if (v14 == -1)
      {
        if ((v11 & 8) != 0)
        {
          *(_DWORD *)(a1 + 92) = v3;
          unsigned int v14 = v3;
        }
        else
        {
          unsigned int v14 = -1;
        }
      }
      ++v3;
      v2 += 64;
      if (v3 >= *(unsigned int *)(a1 + 64))
      {
        if (v14 == -1) {
          break;
        }
        uint64_t v15 = *(void *)(a1 + 72);
        goto LABEL_26;
      }
    }
  }
  unsigned int v14 = 0;
  *(_DWORD *)(a1 + 92) = 0;
  uint64_t v15 = *(void *)(a1 + 72);
  *(_DWORD *)(v15 + 8) |= 8u;
LABEL_26:
  uint64_t result = 0;
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(v15 + ((unint64_t)v14 << 6) + 48)
                       + *(_DWORD *)(v15 + ((unint64_t)v14 << 6) + 40);
  return result;
}

void FSTConcat_ConFromBuffer(int8x8_t *a1, uint64_t a2, uint64_t a3, char *a4, unint64_t a5, char *a6)
{
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  FST_Con(a1, a2, a3);
  int v22 = v12;
  if (!v12)
  {
    *a1 = (int8x8_t)&__FSTConcat;
    uint64_t v13 = (void *)OOCAllocator_Malloc(a2, 24, &v22);
    a1[10] = (int8x8_t)v13;
    if (!v22)
    {
      cstdlib_memset(v13, 0, 0x18uLL);
      unsigned int v14 = (char **)a1[10];
      *unsigned int v14 = a4;
      v14[1] = a6;
      int v22 = __FSTConcat_ReadConfigFromBuffer((uint64_t)a1, a4, a5, &v21, &v20);
      if (!v22)
      {
        a1[5] = vorr_s8(vand_s8(a1[5], (int8x8_t)0x300000003), (int8x8_t)0x1430000004000);
        uint64_t v15 = v20;
        uint64_t v16 = v21;
        if (a1[8].i32[0])
        {
          uint64_t v17 = 0;
          unint64_t v18 = 0;
          while (1)
          {
            FSTCreateFromBuffer(a2, a3, *(unsigned int *)(v15 + 4 * v18), &a4[*(unsigned int *)(v16 + 4 * v18)], 0, (void *)(*(void *)&a1[9] + v17));
            int v22 = v19;
            if (v19) {
              break;
            }
            __FSTConcat_InheritProperties((uint64_t)a1, *(void *)(*(void *)&a1[9] + v17));
            ++v18;
            v17 += 64;
            if (v18 >= a1[8].u32[0]) {
              goto LABEL_8;
            }
          }
        }
        else
        {
LABEL_8:
          OOCAllocator_Free(a2, v16);
          OOCAllocator_Free(a2, v15);
          __FSTConcat_InitComponents((uint64_t)a1);
        }
      }
    }
  }
}

uint64_t __FSTConcat_ReadConfigFromBuffer(uint64_t a1, char *a2, unint64_t a3, uint64_t *a4, uint64_t *a5)
{
  unint64_t v24 = a3;
  int v23 = 0;
  uint64_t v10 = *(void *)(a1 + 24);
  uint64_t v11 = FST_ReadHeader((_DWORD *)a1, a2, &v23, &v24);
  unsigned int v25 = v11;
  if (!v11)
  {
    uint64_t v12 = v24 + 8;
    if (v24 + 8 <= a3
      && v23 == 1
      && (uint64_t v13 = &a2[v24],
          uint64_t v14 = *(unsigned int *)&a2[v24],
          *(_DWORD *)(a1 + 64) = v14,
          v12 + 40 * (unint64_t)v14 <= a3))
    {
      uint64_t v16 = *((unsigned int *)v13 + 1);
      *(void *)(a1 + 72) = OOCAllocator_Malloc(v10, v14 << 6, &v25);
      uint64_t v11 = v25;
      if (!v25)
      {
        uint64_t v17 = OOCAllocator_Malloc(v10, 4 * *(unsigned int *)(a1 + 64), &v25);
        uint64_t v11 = v25;
        if (!v25)
        {
          uint64_t v18 = v17;
          uint64_t v19 = OOCAllocator_Malloc(v10, 4 * *(unsigned int *)(a1 + 64), &v25);
          uint64_t v11 = v25;
          if (!v25)
          {
            uint64_t v11 = *(unsigned int *)(a1 + 64);
            if (v11)
            {
              unint64_t v20 = 0;
              uint64_t v21 = &a2[v16];
              int v22 = (_DWORD *)(*(void *)(a1 + 72) + 20);
              do
              {
                *(_DWORD *)(v18 + 4 * v20) = *(_DWORD *)v21;
                *(_DWORD *)(v19 + 4 * v20) = *((_DWORD *)v21 + 1);
                *(v22 - 3) = *((_DWORD *)v21 + 2);
                *(v22 - 2) = *((_DWORD *)v21 + 3);
                *(v22 - 1) = *((_DWORD *)v21 + 4);
                *int v22 = *((_DWORD *)v21 + 5);
                v22[1] = *((_DWORD *)v21 + 6);
                v22[2] = *((_DWORD *)v21 + 7);
                void v22[3] = *((_DWORD *)v21 + 8);
                v22[4] = *((_DWORD *)v21 + 9);
                v21 += 40;
                ++v20;
                v22 += 16;
              }
              while (v20 < *(unsigned int *)(a1 + 64));
              uint64_t v11 = v25;
            }
            *a4 = v18;
            *a5 = v19;
          }
        }
      }
    }
    else
    {
      return err_GenerateErrorData();
    }
  }
  return v11;
}

void FSTConcat_ConFromRandomReader(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  int v18 = 0;
  FST_Con((void *)a1, a2, a3);
  if (!v7)
  {
    uint64_t v17 = 0;
    *(void *)a1 = &__FSTConcat;
    unsigned int HeaderSizeInRandomReader = FST_GetHeaderSizeInRandomReader(a4, &v17);
    if (!HeaderSizeInRandomReader)
    {
      int v8 = v17;
      uint64_t v9 = (void *)OOCAllocator_Malloc(a2, 24, &HeaderSizeInRandomReader);
      *(void *)(a1 + 80) = v9;
      if (!HeaderSizeInRandomReader)
      {
        cstdlib_memset(v9, 0, 0x18uLL);
        *(void *)(*(void *)(a1 + 80) + 16) = a4;
        (*(void (**)(uint64_t))(*(void *)a4 + 48))(a4 - *(void *)(*(void *)a4 + 56));
        unsigned int HeaderSizeInRandomReader = (**(uint64_t (***)(uint64_t, void))a4)(a4 - *(void *)(*(void *)a4 + 56), v17);
        if (!HeaderSizeInRandomReader)
        {
          unsigned int HeaderSizeInRandomReader = (*(uint64_t (**)(uint64_t, int *, uint64_t))(*(void *)a4 + 8))(a4 - *(void *)(*(void *)a4 + 56), &v18, 4);
          if (!HeaderSizeInRandomReader)
          {
            unint64_t v10 = (v8 + 8 + 40 * v18);
            uint64_t v11 = (char *)OOCAllocator_Malloc(a2, v10, &HeaderSizeInRandomReader);
            if (!HeaderSizeInRandomReader)
            {
              unsigned int HeaderSizeInRandomReader = (**(uint64_t (***)(uint64_t, void))a4)(a4 - *(void *)(*(void *)a4 + 56), 0);
              if (!HeaderSizeInRandomReader)
              {
                unsigned int HeaderSizeInRandomReader = (*(uint64_t (**)(uint64_t, char *, unint64_t))(*(void *)a4 + 8))(a4 - *(void *)(*(void *)a4 + 56), v11, v10);
                if (!HeaderSizeInRandomReader)
                {
                  unsigned int HeaderSizeInRandomReader = __FSTConcat_ReadConfigFromBuffer(a1, v11, v10, &v20, &v19);
                  if (!HeaderSizeInRandomReader)
                  {
                    OOCAllocator_Free(a2, (uint64_t)v11);
                    uint64_t v12 = v19;
                    uint64_t v13 = v20;
                    if (*(_DWORD *)(a1 + 64))
                    {
                      uint64_t v14 = 0;
                      unint64_t v15 = 0;
                      while (1)
                      {
                        __FSTConcat_ConstructFstFromRandomReader((uint64_t *)a1, *(unsigned int *)(v13 + 4 * v15), *(_DWORD *)(v12 + 4 * v15), *(_DWORD *)(*(void *)(a1 + 72) + v14 + 8), (void *)(*(void *)(a1 + 72) + v14));
                        unsigned int HeaderSizeInRandomReader = v16;
                        if (v16) {
                          break;
                        }
                        ++v15;
                        v14 += 64;
                        if (v15 >= *(unsigned int *)(a1 + 64)) {
                          goto LABEL_14;
                        }
                      }
                    }
                    else
                    {
LABEL_14:
                      OOCAllocator_Free(a2, v13);
                      OOCAllocator_Free(a2, v12);
                      __FSTConcat_InitComponents(a1);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

void __FSTConcat_ConstructFstFromRandomReader(uint64_t *a1, uint64_t a2, unsigned int a3, char a4, void *a5)
{
  int v13 = 0;
  uint64_t v8 = a1[3];
  if ((a4 & 0x10) != 0)
  {
    unint64_t v10 = a3;
    uint64_t v11 = (const void *)OOCAllocator_Malloc(a1[3], a3, &v13);
    if (!v13)
    {
      int v13 = (***(uint64_t (****)(void, uint64_t))(a1[10] + 16))(*(void *)(a1[10] + 16) - *(void *)(**(void **)(a1[10] + 16) + 56), a2);
      if (!v13)
      {
        int v13 = (*(uint64_t (**)(void, const void *, unint64_t))(**(void **)(a1[10] + 16) + 8))(*(void *)(a1[10] + 16) - *(void *)(**(void **)(a1[10] + 16) + 56), v11, v10);
        if (!v13) {
          FSTCreateFromBuffer(v8, a1[6], v10, v11, v8, a5);
        }
      }
    }
  }
  else
  {
    uint64_t v12 = 0;
    if (!(*(unsigned int (**)(void, void, void, uint64_t *))(**(void **)(a1[10] + 16) + 32))(*(void *)(a1[10] + 16) - *(void *)(**(void **)(a1[10] + 16) + 56), a2, 0, &v12))
    {
      FSTCreateFromRandomReader(v8, a1[6], v12 + 24, a5);
      if (!v9) {
        (*(void (**)(uint64_t))(*(void *)v12 + 32))(v12);
      }
    }
  }
}

uint64_t FSTConcat_Des(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 64))
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    while (1)
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 72) + v2) + 32))(*(void *)(*(void *)(a1 + 72) + v2));
      if (result) {
        break;
      }
      ++v3;
      v2 += 64;
      if (v3 >= *(unsigned int *)(a1 + 64)) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    OOCAllocator_Free(*(void *)(a1 + 24), *(void *)(a1 + 72));
    uint64_t v5 = *(uint64_t **)(a1 + 80);
    if (v5)
    {
      uint64_t v6 = v5[1];
      if (v6)
      {
        OOCAllocator_Free(v6, *v5);
        uint64_t v5 = *(uint64_t **)(a1 + 80);
      }
      uint64_t v7 = v5[2];
      if (v7)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 40))(v7 - *(void *)(*(void *)v7 + 56));
        if (result) {
          return result;
        }
        uint64_t v5 = *(uint64_t **)(a1 + 80);
      }
      OOCAllocator_Free(*(void *)(a1 + 24), (uint64_t)v5);
    }
    return FST_Des(a1);
  }
  return result;
}

uint64_t FSTConcat_BorrowComponentFst(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 64) <= a2) {
    return 0;
  }
  else {
    return *(void *)(*(void *)(a1 + 72) + ((unint64_t)a2 << 6));
  }
}

uint64_t FSTConcat_FetchState(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t *a4)
{
  uint64_t v41 = 0;
  uint64_t v8 = *(char **)(a1 + 72);
  if (*(_DWORD *)(a1 + 88) == a2)
  {
    v8 += 64 * (unint64_t)*(unsigned int *)(a1 + 92);
  }
  else
  {
    uint64_t v9 = *(unsigned int *)(a1 + 64);
    if (v9 >= 2)
    {
      unint64_t v10 = v9 << 6;
      uint64_t v11 = &v8[64 * v9];
      do
      {
        uint64_t v12 = &v8[64 * (v10 >> 7)];
        if (*((_DWORD *)v12 + 12) > a2) {
          uint64_t v11 = v12;
        }
        else {
          uint64_t v8 = v12;
        }
        unint64_t v10 = v11 - v8;
      }
      while (v11 - v8 > 64);
    }
  }
  int v13 = *((_DWORD *)v8 + 12);
  if (v13 + *((_DWORD *)v8 + 10) == a2 && (v8[8] & 1) != 0) {
    goto LABEL_61;
  }
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t *))(**(void **)v8 + 120))(*(void *)v8, a2 - v13, 8, &v41);
  if (result) {
    return result;
  }
  uint64_t v15 = v41;
  if (!v41) {
    goto LABEL_61;
  }
  if ((*(_DWORD *)(v41 + 8) & 0x3FFFFFE) != 0)
  {
    uint64_t v40 = 0;
    uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v40);
    if (result) {
      return result;
    }
    uint64_t result = FSTState_Copy(v40, v41);
    if (result) {
      return result;
    }
    int v16 = *(_DWORD *)(v41 + 8);
    *(_DWORD *)(v41 + 8) = v16 - 1;
    if ((v16 & 0x3FFFFFF) == 0) {
      return 9;
    }
    uint64_t v15 = v40;
    uint64_t v41 = v40;
  }
  *(_DWORD *)(v15 + 24) = a2;
  uint64_t v17 = *(_DWORD **)(v15 + 40);
  int v18 = *(_DWORD **)(v15 + 56);
  uint64_t v19 = *(unsigned int *)(v15 + 48);
  uint64_t v20 = &v18[4 * v19];
  if (v17 != v20)
  {
    int v21 = *((_DWORD *)v8 + 12);
    int v22 = &v17[4 * *(unsigned int *)(v15 + 32)];
    do
    {
      if (v17 == v22 && !v19) {
        break;
      }
      if (v17 == v22) {
        uint64_t v17 = v18;
      }
      *v17 += v21;
      v17 += 4;
    }
    while (v17 != v20);
  }
  if ((*(_DWORD *)(v15 + 8) & 0x80000000) == 0
    || !*((void *)v8 + 7)
    || (uint64_t result = __FSTConcat_ConnectComponent(v15, (uint64_t)v8), !result))
  {
    if (*(_DWORD *)(a1 + 88) == a2)
    {
      unint64_t v23 = *(unsigned int *)(a1 + 64);
      if (v23)
      {
        for (unint64_t i = 0; i < v23; ++i)
        {
          if (i != *(_DWORD *)(a1 + 92))
          {
            uint64_t v25 = *(void *)(a1 + 72);
            uint64_t v26 = (void *)(v25 + (i << 6));
            if ((v26[1] & 8) != 0)
            {
              uint64_t v40 = 0;
              uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t *))(*(void *)*v26 + 120))(*v26, *((unsigned int *)v26 + 10), 8, &v40);
              if (result) {
                return result;
              }
              uint64_t v27 = v40;
              if (v40)
              {
                if ((*(_DWORD *)(v40 + 8) & 0x3FFFFFE) != 0)
                {
                  uint64_t v39 = 0;
                  uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v39);
                  if (result) {
                    return result;
                  }
                  uint64_t result = FSTState_Copy(v39, v40);
                  if (result) {
                    return result;
                  }
                  int v28 = *(_DWORD *)(v40 + 8);
                  *(_DWORD *)(v40 + 8) = v28 - 1;
                  if ((v28 & 0x3FFFFFF) == 0) {
                    return 9;
                  }
                  uint64_t v27 = v39;
                  uint64_t v40 = v39;
                }
                *(_DWORD *)(v27 + 24) = a2;
                int v29 = *(_DWORD **)(v27 + 40);
                unsigned int v30 = *(_DWORD **)(v27 + 56);
                uint64_t v31 = *(unsigned int *)(v27 + 48);
                unsigned int v32 = &v30[4 * v31];
                if (v29 != v32)
                {
                  int v33 = *(_DWORD *)(v25 + (i << 6) + 48);
                  unsigned int v34 = &v29[4 * *(unsigned int *)(v27 + 32)];
                  do
                  {
                    if (v29 == v34 && !v31) {
                      break;
                    }
                    if (v29 == v34) {
                      int v29 = v30;
                    }
                    *v29 += v33;
                    v29 += 4;
                  }
                  while (v29 != v32);
                }
                if ((*(_DWORD *)(v27 + 8) & 0x80000000) != 0 && *(void *)(v25 + (i << 6) + 56))
                {
                  uint64_t result = __FSTConcat_ConnectComponent(v27, v25 + (i << 6));
                  if (result) {
                    return result;
                  }
                  uint64_t v27 = v40;
                }
                uint64_t result = __FSTConcat_AddStateArcs(v41, v27, 0);
                if (result) {
                  return result;
                }
                int v35 = *(_DWORD *)(v40 + 8);
                if ((v35 & 0x3FFFFFF) == 1)
                {
                  if ((v35 & 0x8000000) != 0) {
                    uint64_t v36 = *(void *)(v40 + 16);
                  }
                  else {
                    uint64_t v36 = 0;
                  }
                  uint64_t result = FSTStatePool_PushFSTState(v36, v40);
                  if (result) {
                    return result;
                  }
                }
                else
                {
                  *(_DWORD *)(v40 + 8) = v35 - 1;
                  if ((v35 & 0x3FFFFFF) == 0) {
                    return 9;
                  }
                }
              }
              unint64_t v23 = *(unsigned int *)(a1 + 64);
            }
          }
        }
      }
    }
    int v37 = FST_CheckQuery(*(_DWORD *)(v41 + 8) & 0xF0000000, a3);
    uint64_t v38 = v41;
    if (v37) {
      goto LABEL_62;
    }
    uint64_t result = FSTStatePool_PushFSTState(*(void *)(a1 + 48), v41);
    if (result) {
      return result;
    }
LABEL_61:
    uint64_t v38 = 0;
LABEL_62:
    uint64_t result = 0;
    *a4 = v38;
  }
  return result;
}

uint64_t __FSTConcat_ConnectComponent(uint64_t a1, uint64_t a2)
{
  unsigned int v24 = 0;
  unsigned int v4 = *(void **)(a2 + 56);
  int v5 = *((_DWORD *)v4 + 2);
  if ((v5 & 1) == 0)
  {
    if (*((_DWORD *)v4 + 3) == -2)
    {
      uint64_t v6 = *(void *)(a1 + 40);
      if (v6)
      {
        unsigned int v7 = *(_DWORD *)(a1 + 32) + 1;
        if (*(_DWORD *)(v6 - 4) > v7)
        {
LABEL_17:
          uint64_t v12 = *(unsigned int *)(a1 + 32);
          uint64_t v13 = v6 + 16 * v12;
          *(_DWORD *)(a1 + 32) = v12 + 1;
          *(_DWORD *)(a1 + 8) |= 0x20000000u;
LABEL_21:
          *(void *)(v13 + 4) = *(void *)((char *)v4 + 12);
          *(_DWORD *)(v13 + 12) = *((_DWORD *)v4 + 5);
          *(_DWORD *)uint64_t v13 = *((_DWORD *)v4 + 12) + *((_DWORD *)v4 + 10);
          goto LABEL_22;
        }
      }
      else
      {
        unsigned int v7 = *(_DWORD *)(a1 + 32) + 1;
      }
      uint64_t v6 = _FSTState_ReserveEpsilonArcsInternal(a1, v7, &v24);
      if (v24) {
        return v24;
      }
      goto LABEL_17;
    }
    uint64_t v10 = *(void *)(a1 + 56);
    if (v10)
    {
      unsigned int v11 = *(_DWORD *)(a1 + 48) + 1;
      if (*(_DWORD *)(v10 - 4) > v11)
      {
LABEL_20:
        uint64_t v14 = *(unsigned int *)(a1 + 48);
        uint64_t v13 = v10 + 16 * v14;
        *(_DWORD *)(a1 + 48) = v14 + 1;
        goto LABEL_21;
      }
    }
    else
    {
      unsigned int v11 = *(_DWORD *)(a1 + 48) + 1;
    }
    uint64_t v10 = _FSTState_ReserveArcsInternal(a1, v11, &v24);
    if (v24) {
      return v24;
    }
    goto LABEL_20;
  }
  uint64_t v23 = 0;
  unsigned int v24 = (*(uint64_t (**)(void, void, uint64_t, uint64_t *))(*(void *)*v4 + 120))(*v4, *((unsigned int *)v4 + 10), 8, &v23);
  if (v24) {
    return v24;
  }
  if (!v23)
  {
LABEL_22:
    if ((v5 & 2) == 0 || !v4[7])
    {
LABEL_40:
      if ((*(unsigned char *)(a2 + 8) & 4) == 0) {
        *(_DWORD *)(a1 + 8) &= ~0x80000000;
      }
      return v24;
    }
    if (*((_DWORD *)v4 + 6) == -2)
    {
      uint64_t v15 = *(void *)(a1 + 40);
      if (v15)
      {
        unsigned int v16 = *(_DWORD *)(a1 + 32) + 1;
        if (*(_DWORD *)(v15 - 4) > v16) {
          goto LABEL_33;
        }
      }
      else
      {
        unsigned int v16 = *(_DWORD *)(a1 + 32) + 1;
      }
      uint64_t v15 = _FSTState_ReserveEpsilonArcsInternal(a1, v16, &v24);
LABEL_33:
      if (v24) {
        return v24;
      }
      uint64_t v19 = *(unsigned int *)(a1 + 32);
      uint64_t v20 = v15 + 16 * v19;
      *(_DWORD *)(a1 + 32) = v19 + 1;
      *(_DWORD *)(a1 + 8) |= 0x20000000u;
      goto LABEL_39;
    }
    uint64_t v17 = *(void *)(a1 + 56);
    if (v17)
    {
      unsigned int v18 = *(_DWORD *)(a1 + 48) + 1;
      if (*(_DWORD *)(v17 - 4) > v18) {
        goto LABEL_37;
      }
    }
    else
    {
      unsigned int v18 = *(_DWORD *)(a1 + 48) + 1;
    }
    uint64_t v17 = _FSTState_ReserveArcsInternal(a1, v18, &v24);
LABEL_37:
    if (v24) {
      return v24;
    }
    uint64_t v21 = *(unsigned int *)(a1 + 48);
    uint64_t v20 = v17 + 16 * v21;
    *(_DWORD *)(a1 + 48) = v21 + 1;
LABEL_39:
    *(void *)(v20 + 4) = v4[3];
    *(_DWORD *)(v20 + 12) = *((_DWORD *)v4 + 8);
    *(_DWORD *)uint64_t v20 = *(_DWORD *)(v4[7] + 48) + *(_DWORD *)(v4[7] + 40);
    goto LABEL_40;
  }
  unsigned int v24 = __FSTConcat_AddStateArcs(a1, v23, *((_DWORD *)v4 + 12));
  if (v24) {
    return v24;
  }
  int v8 = *(_DWORD *)(v23 + 8);
  if ((v8 & 0x3FFFFFF) != 1)
  {
    *(_DWORD *)(v23 + 8) = v8 - 1;
    if ((v8 & 0x3FFFFFF) == 0) {
      return 9;
    }
    unsigned int v24 = 0;
    goto LABEL_22;
  }
  if ((v8 & 0x8000000) != 0) {
    uint64_t v9 = *(void *)(v23 + 16);
  }
  else {
    uint64_t v9 = 0;
  }
  unsigned int v24 = FSTStatePool_PushFSTState(v9, v23);
  if (!v24) {
    goto LABEL_22;
  }
  return v24;
}

uint64_t __FSTConcat_AddStateArcs(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v25 = 0;
  int v6 = *(_DWORD *)(a2 + 32);
  if (!v6) {
    goto LABEL_11;
  }
  uint64_t v7 = *(void *)(a1 + 40);
  if (!v7)
  {
    unsigned int v8 = *(_DWORD *)(a1 + 32) + v6;
LABEL_6:
    uint64_t v7 = _FSTState_ReserveEpsilonArcsInternal(a1, v8, &v25);
    if (v25) {
      return v25;
    }
    goto LABEL_7;
  }
  unsigned int v8 = *(_DWORD *)(a1 + 32) + v6;
  if (*(_DWORD *)(v7 - 4) <= v8) {
    goto LABEL_6;
  }
LABEL_7:
  uint64_t v9 = *(unsigned int *)(a1 + 32);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32) + v9;
  uint64_t v10 = *(unsigned int *)(a2 + 32);
  if (v10)
  {
    unsigned int v11 = *(long long **)(a2 + 40);
    uint64_t v12 = &v11[v10];
    uint64_t v13 = (_OWORD *)(v7 + 16 * v9);
    do
    {
      long long v14 = *v11++;
      *uint64_t v13 = v14;
      *(_DWORD *)v13++ += a3;
    }
    while (v11 < v12);
  }
  *(_DWORD *)(a1 + 8) |= 0x20000000u;
LABEL_11:
  int v15 = *(_DWORD *)(a2 + 48);
  if (!v15) {
    return v25;
  }
  uint64_t v16 = *(void *)(a1 + 56);
  if (v16)
  {
    unsigned int v17 = *(_DWORD *)(a1 + 48) + v15;
    if (*(_DWORD *)(v16 - 4) > v17) {
      goto LABEL_17;
    }
  }
  else
  {
    unsigned int v17 = *(_DWORD *)(a1 + 48) + v15;
  }
  uint64_t v16 = _FSTState_ReserveArcsInternal(a1, v17, &v25);
LABEL_17:
  if (!v25)
  {
    uint64_t v18 = *(unsigned int *)(a1 + 48);
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48) + v18;
    uint64_t v19 = *(unsigned int *)(a2 + 48);
    if (v19)
    {
      uint64_t v20 = *(long long **)(a2 + 56);
      uint64_t v21 = &v20[v19];
      int v22 = (_OWORD *)(v16 + 16 * v18);
      do
      {
        long long v23 = *v20++;
        *int v22 = v23;
        *(_DWORD *)v22++ += a3;
      }
      while (v20 < v21);
    }
  }
  return v25;
}

uint64_t FSTConcat_FillBuffer(uint64_t a1, char *a2, unint64_t *a3)
{
  uint64_t v27 = 0;
  uint64_t result = FST_GetHeaderSizeInOutputBuffer(&v27);
  unsigned int v28 = result;
  if (!result)
  {
    uint64_t v7 = v27;
    uint64_t v8 = *(unsigned int *)(a1 + 64);
    uint64_t v9 = OOCAllocator_Malloc(*(void *)(a1 + 24), 8 * v8, &v28);
    uint64_t result = v28;
    if (!v28)
    {
      uint64_t v10 = v7 + 40 * v8 + 8;
      unint64_t v11 = v10;
      if (*(_DWORD *)(a1 + 64))
      {
        uint64_t v12 = 0;
        unint64_t v13 = 0;
        unint64_t v11 = v10;
        while (1)
        {
          uint64_t v26 = 0;
          uint64_t result = (*(uint64_t (**)(void, void, uint64_t *))(**(void **)(*(void *)(a1 + 72) + v12)
                                                                        + 80))(*(void *)(*(void *)(a1 + 72) + v12), 0, &v26);
          unsigned int v28 = result;
          if (result) {
            break;
          }
          unint64_t v14 = v26 | 0xFFFFFFFFFFFFFFFCLL;
          if ((v26 & 3) == 0) {
            unint64_t v14 = 0;
          }
          uint64_t v15 = v26 - v14;
          *(void *)(v9 + 8 * v13) = v26 - v14;
          v11 += v15;
          ++v13;
          v12 += 64;
          if (v13 >= *(unsigned int *)(a1 + 64)) {
            goto LABEL_9;
          }
        }
      }
      else
      {
LABEL_9:
        if (!a2 || *a3 < v11) {
          goto LABEL_11;
        }
        uint64_t result = FST_FillHeader((_DWORD *)a1, a2, 1, &v27);
        unsigned int v28 = result;
        if (result) {
          return result;
        }
        uint64_t v16 = &a2[v27];
        int v17 = v27 + 8;
        *(_DWORD *)uint64_t v16 = *(_DWORD *)(a1 + 64);
        *((_DWORD *)v16 + 1) = v17;
        if (!*(_DWORD *)(a1 + 64)) {
          goto LABEL_11;
        }
        unint64_t v18 = 0;
        uint64_t v19 = v16 + 8;
        uint64_t v20 = (_DWORD *)(*(void *)(a1 + 72) + 20);
        do
        {
          _DWORD *v19 = v10;
          uint64_t v21 = *(void *)(v9 + 8 * v18);
          v19[1] = v21;
          _OWORD v19[2] = *(v20 - 3);
          void v19[3] = *(v20 - 2);
          v19[4] = *(v20 - 1);
          v19[5] = *v20;
          v19[6] = v20[1];
          _OWORD v19[7] = v20[2];
          v19[8] = v20[3];
          v19[9] = v20[4];
          v19 += 10;
          v10 += v21;
          ++v18;
          unint64_t v22 = *(unsigned int *)(a1 + 64);
          v20 += 16;
        }
        while (v18 < v22);
        if (!v22)
        {
LABEL_11:
          *a3 = v11;
          OOCAllocator_Free(*(void *)(a1 + 24), v9);
          return v28;
        }
        uint64_t v23 = 0;
        unint64_t v24 = 0;
        while (1)
        {
          uint64_t v26 = *(void *)(v9 + v23);
          uint64_t v25 = *(void *)(*(void *)(a1 + 72) + 8 * v23);
          uint64_t result = (*(uint64_t (**)(uint64_t, _DWORD *, uint64_t *))(*(void *)v25 + 80))(v25, v19, &v26);
          unsigned int v28 = result;
          if (result) {
            break;
          }
          uint64_t v19 = (_DWORD *)((char *)v19 + *(void *)(v9 + v23));
          ++v24;
          v23 += 8;
          if (v24 >= *(unsigned int *)(a1 + 64)) {
            goto LABEL_11;
          }
        }
      }
    }
  }
  return result;
}

uint64_t FSTConcat_GetFinalStateWeight(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(char **)(a1 + 72);
  uint64_t v3 = *(unsigned int *)(a1 + 64);
  if (v3 >= 2)
  {
    unint64_t v4 = v3 << 6;
    int v5 = &v2[64 * v3];
    do
    {
      int v6 = &v2[64 * (v4 >> 7)];
      if (*((_DWORD *)v6 + 12) > a2) {
        int v5 = v6;
      }
      else {
        uint64_t v2 = v6;
      }
      unint64_t v4 = v5 - v2;
    }
    while (v5 - v2 > 64);
  }
  return (*(uint64_t (**)(void, void))(**(void **)v2 + 64))(*(void *)v2, a2 - *((_DWORD *)v2 + 12));
}

uint64_t FSTConcat_GetInitialStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 88);
  return 0;
}

uint64_t FSTConcat_GetMappedComponentStateId(uint64_t a1, unsigned int a2, int a3)
{
  unint64_t v3 = *(void *)(a1 + 72) + ((unint64_t)a2 << 6);
  if ((*(unsigned char *)(v3 + 8) & 8) != 0 && *(_DWORD *)(v3 + 40) == a3) {
    return *(unsigned int *)(a1 + 88);
  }
  else {
    return (*(_DWORD *)(v3 + 48) + a3);
  }
}

uint64_t FSTConcat_GetMaxBranchFactor(uint64_t a1, unsigned int *a2)
{
  if (*(_DWORD *)(a1 + 64))
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    unsigned int v6 = 0;
    unsigned int v7 = 0;
    while (1)
    {
      unsigned int v14 = 0;
      uint64_t result = (*(uint64_t (**)(void, unsigned int *))(**(void **)(*(void *)(a1 + 72) + v4) + 136))(*(void *)(*(void *)(a1 + 72) + v4), &v14);
      if (result) {
        break;
      }
      if (v14 > v7) {
        unsigned int v7 = v14;
      }
      uint64_t v9 = (void *)(*(void *)(a1 + 72) + v4);
      if ((v9[1] & 8) != 0)
      {
        uint64_t v13 = 0;
        uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t *))(*(void *)*v9 + 120))(*v9, *((unsigned int *)v9 + 10), 8, &v13);
        if (result) {
          return result;
        }
        if (v13)
        {
          v6 += *(_DWORD *)(v13 + 48) + *(_DWORD *)(v13 + 32);
          int v10 = *(_DWORD *)(v13 + 8);
          if ((v10 & 0x3FFFFFF) == 1)
          {
            if ((v10 & 0x8000000) != 0) {
              uint64_t v11 = *(void *)(v13 + 16);
            }
            else {
              uint64_t v11 = 0;
            }
            uint64_t result = FSTStatePool_PushFSTState(v11, v13);
            if (result) {
              return result;
            }
          }
          else
          {
            *(_DWORD *)(v13 + 8) = v10 - 1;
            if ((v10 & 0x3FFFFFF) == 0) {
              return 9;
            }
          }
        }
      }
      ++v5;
      v4 += 64;
      if (v5 >= *(unsigned int *)(a1 + 64)) {
        goto LABEL_19;
      }
    }
  }
  else
  {
    unsigned int v7 = 0;
    unsigned int v6 = 0;
LABEL_19:
    uint64_t result = 0;
    if (v6 <= v7) {
      unsigned int v12 = v7;
    }
    else {
      unsigned int v12 = v6;
    }
    *a2 = v12;
  }
  return result;
}

uint64_t FSTConcat_GetMaxNbrComponentFsts(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t FSTConcat_GetMaxStateId(uint64_t a1, int *a2)
{
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 168))(a1))
  {
    int v5 = -1;
  }
  else
  {
    unint64_t v4 = *(void *)(a1 + 72) + ((unint64_t)(*(_DWORD *)(a1 + 64) - 1) << 6);
    int v5 = *(_DWORD *)(v4 + 48) + *(_DWORD *)(v4 + 44);
  }
  *a2 = v5;
  return 0;
}

uint64_t FSTConcat_GetMemoryInfo(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 64);
  if (v1)
  {
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 72) + v3) + 96))(*(void *)(*(void *)(a1 + 72) + v3));
      v5 += v7 + v6;
      ++v4;
      v3 += 64;
    }
    while (v4 < *(unsigned int *)(a1 + 64));
  }
  return (v1 << 6) + 96;
}

uint64_t FSTConcat_GetStateFlags(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  if (*(_DWORD *)(a1 + 88) != a2)
  {
    uint64_t v8 = *(char **)(a1 + 72);
    uint64_t v9 = *(unsigned int *)(a1 + 64);
    if (v9 >= 2)
    {
      unint64_t v10 = v9 << 6;
      uint64_t v11 = &v8[64 * v9];
      do
      {
        unsigned int v12 = &v8[64 * (v10 >> 7)];
        if (*((_DWORD *)v12 + 12) > a2) {
          uint64_t v11 = v12;
        }
        else {
          uint64_t v8 = v12;
        }
        unint64_t v10 = v11 - v8;
      }
      while (v11 - v8 > 64);
    }
    uint64_t result = (*(uint64_t (**)(void, void, unsigned int *))(**(void **)v8 + 56))(*(void *)v8, a2 - *((_DWORD *)v8 + 12), a3);
    if (result) {
      return result;
    }
    if ((*a3 & 0x80000000) != 0)
    {
      uint64_t v13 = (void *)*((void *)v8 + 7);
      if (v13)
      {
        int v14 = *((_DWORD *)v13 + 2);
        if (v14)
        {
          uint64_t v18 = 0;
          uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t *))(*(void *)*v13 + 120))(*v13, *((unsigned int *)v13 + 10), 1, &v18);
          if (result) {
            return result;
          }
          uint64_t v15 = v18;
          if (v18)
          {
            if (*(_DWORD *)(v18 + 32)) {
              *a3 |= 0x20000000u;
            }
            int v16 = *(_DWORD *)(v15 + 8);
            if ((v16 & 0x3FFFFFF) == 1)
            {
              if ((v16 & 0x8000000) != 0) {
                uint64_t v17 = *(void *)(v15 + 16);
              }
              else {
                uint64_t v17 = 0;
              }
              uint64_t result = FSTStatePool_PushFSTState(v17, v15);
              if (result) {
                return result;
              }
            }
            else
            {
              *(_DWORD *)(v15 + 8) = v16 - 1;
              if ((v16 & 0x3FFFFFF) == 0) {
                return 9;
              }
            }
          }
        }
        else if (*((_DWORD *)v13 + 3) == -2)
        {
          *a3 |= 0x20000000u;
        }
        if ((v14 & 2) != 0 && v13[7] && *((_DWORD *)v13 + 6) == -2) {
          *a3 |= 0x20000000u;
        }
      }
    }
    if ((v8[8] & 4) == 0)
    {
      uint64_t result = 0;
      *a3 &= ~0x80000000;
      return result;
    }
    return 0;
  }
  uint64_t v18 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 120))(a1);
  if (result) {
    return result;
  }
  uint64_t v5 = v18;
  if (!v18)
  {
    *a3 = 0;
    return 0;
  }
  *a3 = *(_DWORD *)(v18 + 8) & 0xF0000000;
  int v6 = *(_DWORD *)(v5 + 8);
  if ((v6 & 0x3FFFFFF) != 1)
  {
    *(_DWORD *)(v5 + 8) = v6 - 1;
    if ((v6 & 0x3FFFFFF) == 0) {
      return 9;
    }
    return 0;
  }
  if ((v6 & 0x8000000) != 0) {
    uint64_t v7 = *(void *)(v5 + 16);
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t result = FSTStatePool_PushFSTState(v7, v5);
  if (!result) {
    return 0;
  }
  return result;
}

uint64_t FSTConcat_GetStatus(uint64_t a1)
{
  uint64_t Status = FST_GetStatus(a1);
  if (*(_DWORD *)(a1 + 64))
  {
    uint64_t v3 = 0;
    int v4 = 0;
    unint64_t v5 = 0;
    uint64_t v6 = *(void *)(a1 + 72);
    do
    {
      int v7 = (*(uint64_t (**)(void))(**(void **)(v6 + v3) + 168))(*(void *)(v6 + v3));
      uint64_t v6 = *(void *)(a1 + 72);
      int v8 = *(_DWORD *)(v6 + v3 + 44);
      BOOL v9 = __CFADD__(v8, v4);
      uint64_t Status = v7 | Status | v9;
      if (__CFADD__(v8, v4)) {
        int v8 = 0;
      }
      v4 += v8;
      ++v5;
      v3 += 64;
    }
    while (v5 < *(unsigned int *)(a1 + 64));
  }
  return Status;
}

uint64_t FSTConcat_Reset(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 64))
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    while (1)
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 72) + v2) + 112))(*(void *)(*(void *)(a1 + 72) + v2));
      if (result) {
        break;
      }
      ++v3;
      v2 += 64;
      if (v3 >= *(unsigned int *)(a1 + 64)) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    return __FSTConcat_InitComponents(a1);
  }
  return result;
}

void FSTConcat_SetStatePool(uint64_t a1, uint64_t a2)
{
  v4.n128_f64[0] = FST_SetStatePool(a1, a2);
  if (!v5 && *(_DWORD *)(a1 + 64))
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    do
    {
      if ((*(unsigned int (**)(void, uint64_t, __n128))(**(void **)(*(void *)(a1 + 72) + v6) + 128))(*(void *)(*(void *)(a1 + 72) + v6), a2, v4))
      {
        break;
      }
      ++v7;
      v6 += 64;
    }
    while (v7 < *(unsigned int *)(a1 + 64));
  }
}

void PNEW_FSTConcat_ConFromBuffer(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, unint64_t a5, char *a6, int8x8_t **a7)
{
  int v16 = 0;
  int v14 = (int8x8_t *)OOCAllocator_Malloc(a1, 96, &v16);
  if (!v16)
  {
    FSTConcat_ConFromBuffer(v14, a2, a3, a4, a5, a6);
    int v16 = v15;
    if (v15)
    {
      OOCAllocator_Free(a1, (uint64_t)v14);
      *a7 = 0;
    }
    else
    {
      _OWORD v14[2] = (int8x8_t)a1;
      *a7 = v14;
    }
  }
}

void PNEW_FSTConcat_ConFromRandomReader(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 96, &v12);
  if (!v12)
  {
    FSTConcat_ConFromRandomReader(v10, a2, a3, a4);
    int v12 = v11;
    if (v11)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
    }
    else
    {
      *(void *)(v10 + 16) = a1;
      *a5 = v10;
    }
  }
}

void *GetFSTConcatClass()
{
  return &__FSTConcat;
}

void FSTCompact2Builder_Con(void *a1, uint64_t a2)
{
  if (!FSTBufferBuilder_Con(a1, a2))
  {
    *a1 = &__FSTCompact2Builder;
    a1[9] = &unk_26D2166C0;
    __FSTCompact2Builder_Init((uint64_t)a1);
  }
}

void __FSTCompact2Builder_Init(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  long long v4 = 0u;
  long long v5 = 0u;
  memset(v3, 0, sizeof(v3));
  FST_Con(v3, *(void *)(a1 + 8), 0);
  if (!v2)
  {
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 80) = 0xFFFFFFFF00000001;
    *(void *)(a1 + 104) = 0xFFFFFFFF00000000;
    *(void *)(a1 + 64) = *(void *)&vand_s8(*(int8x8_t *)(a1 + 64), (int8x8_t)0x300000003) | 0x10000000100;
    if (!dpmemblock_Create(*(void *)(a1 + 8), 4, 0x400u, (uint64_t *)(a1 + 88)))
    {
      *(void *)(a1 + 96) = 0;
      if (!dpmemblock_Create(*(void *)(a1 + 8), 1, 0x400u, (uint64_t *)(a1 + 96)))
      {
        *(void *)&long long v4 = 0x200000028;
        *((void *)&v4 + 1) |= 0x10000000100uLL;
        if (!__FSTFlatBuilder_WriteFstBaseHeader((uint64_t *)a1, v3, &v6))
        {
          int v7 = -1;
          uint64_t v9 = 0;
          uint64_t v8 = 0;
          int v10 = v6 + 24;
          if (*(uint64_t *)(a1 + 48) < 0x7FFFFFFFFFFFFFE8)
          {
            if ((**(uint64_t (***)(int *, uint64_t, uint64_t, void))(a1 + 16))(&v7, 24, 1, *(void *)(a1 + 24)) != 1)err_GenerateErrorCallback(); {
            *(void *)(a1 + 48) += 24;
            }
          }
          else
          {
            err_GenerateErrorCallback();
          }
          FST_Des((uint64_t)v3);
        }
      }
    }
  }
}

void FSTCompact2Builder_ConToStream(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!FSTBufferBuilder_ConToStream(a1, a2, a3, a4, a5))
  {
    *a1 = &__FSTCompact2Builder;
    a1[9] = &unk_26D2166C0;
    __FSTCompact2Builder_Init((uint64_t)a1);
  }
}

uint64_t FSTCompact2Builder_Des(uint64_t a1)
{
  dpmemblock_Free(*(uint64_t **)(a1 + 88));
  dpmemblock_Free(*(uint64_t **)(a1 + 96));

  return FSTBufferBuilder_Des((uint64_t *)a1);
}

uint64_t FSTCompact2Builder_AddArc(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v9[0] = 0;
  v9[1] = 0;
  uint64_t v8 = 17;
  uint64_t result = FSTArc_Con(v9, a6, a3, a4, a5);
  if (!result)
  {
    FSTCompactCodec_EncodeArc((unsigned int *)v9, (uint64_t)v10, &v8);
    if (*(void *)(a1 + 48) <= (v8 ^ 0x7FFFFFFFFFFFFFFFLL))
    {
      if ((**(uint64_t (***)(unsigned char *))(a1 + 16))(v10) == 1) {
        uint64_t result = 0;
      }
      else {
        uint64_t result = err_GenerateErrorCallback();
      }
      *(void *)(a1 + 48) += v8;
    }
    else
    {
      return err_GenerateErrorCallback();
    }
  }
  return result;
}

uint64_t FSTCompact2Builder_ConvertFST(uint64_t a1, _DWORD *a2)
{
  v28[3] = *MEMORY[0x263EF8340];
  memset(v27, 0, sizeof(v27));
  uint64_t result = FSTCount(*(void *)(a1 + 8), (uint64_t)a2, (uint64_t)v27);
  if (result) {
    return result;
  }
  int v5 = v27[0];
  v28[0] = 0;
  unsigned int v6 = LODWORD(v27[0]) + 2;
  uint64_t v7 = *(void *)(a1 + 88);
  unsigned int v8 = *(_DWORD *)(v7 + 32);
  if (LODWORD(v27[0]) + 2 <= v8)
  {
    *(_DWORD *)(v7 + 32) = v6;
  }
  else
  {
    unsigned int v9 = v8 + 1;
    do
    {
      uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 88), v28, 0);
      if (v9 >= v6) {
        break;
      }
      ++v9;
    }
    while (!result);
    if (result) {
      return result;
    }
  }
  v28[0] = 0;
  uint64_t v10 = *(void *)(a1 + 96);
  unsigned int v11 = *(_DWORD *)(v10 + 32);
  if (v6 <= v11)
  {
    *(_DWORD *)(v10 + 32) = v6;
  }
  else
  {
    unsigned int v12 = v11 + 1;
    do
    {
      uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 96), v28, 0);
      if (v12 >= v6) {
        break;
      }
      ++v12;
    }
    while (!result);
    if (result) {
      return result;
    }
  }
  uint64_t result = (*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)a2 + 48))(a2, a1 + 108);
  if (!result)
  {
    v13.i32[0] = a2[11] & 0x3FFFF & a2[10];
    v13.i32[1] = a2[11] & 0x3FFFF;
    *(void *)(a1 + 64) = *(void *)&vorr_s8(vand_s8(*(int8x8_t *)(a1 + 64), (int8x8_t)0x300000003), v13) | 0x10000000100;
    if (v5 == -1)
    {
      return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 16))(a1 + 72 - *(void *)(*(void *)(a1 + 72) + 24));
    }
    else
    {
      uint64_t v14 = 0;
      uint64_t v15 = a1 + 72;
      while (1)
      {
        uint64_t v26 = 0;
        uint64_t result = (*(uint64_t (**)(_DWORD *, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 120))(a2, v14, 8, &v26);
        if (result) {
          break;
        }
        if (v26)
        {
          int v16 = *(_DWORD *)(v26 + 8);
          if (v16 < 0) {
            uint64_t v17 = *(unsigned int *)(v26 + 28);
          }
          else {
            uint64_t v17 = 0;
          }
          uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t, void))v15)(v15 - *(void *)(*(void *)v15 + 24), v14, v16 & 0xF0000000, v17, 0);
          if (result) {
            return result;
          }
          uint64_t v18 = v26;
          uint64_t v19 = *(unsigned int **)(v26 + 40);
          uint64_t v20 = *(void *)(v26 + 56) + 16 * *(unsigned int *)(v26 + 48);
          if (v19 != (unsigned int *)v20)
          {
            uint64_t v21 = &v19[4 * *(unsigned int *)(v26 + 32)];
            while (1)
            {
              uint64_t v25 = 17;
              if (v19 == v21)
              {
                uint64_t v18 = v26;
                if (!*(_DWORD *)(v26 + 48)) {
                  break;
                }
                uint64_t v19 = *(unsigned int **)(v26 + 56);
              }
              FSTCompactCodec_EncodeArc(v19, (uint64_t)v28, &v25);
              if (*(void *)(a1 + 48) <= (v25 ^ 0x7FFFFFFFFFFFFFFFLL))
              {
                uint64_t result = (**(uint64_t (***)(void *))(a1 + 16))(v28) == 1 ? 0 : err_GenerateErrorCallback();
                *(void *)(a1 + 48) += v25;
              }
              else
              {
                uint64_t result = err_GenerateErrorCallback();
              }
              if (result) {
                return result;
              }
              v19 += 4;
              if (v19 == (unsigned int *)v20)
              {
                uint64_t v18 = v26;
                break;
              }
            }
          }
          int v22 = *(_DWORD *)(v18 + 8);
          if ((v22 & 0x3FFFFFF) == 1)
          {
            if ((v22 & 0x8000000) != 0) {
              uint64_t v23 = *(void *)(v18 + 16);
            }
            else {
              uint64_t v23 = 0;
            }
            uint64_t result = FSTStatePool_PushFSTState(v23, v18);
            if (result) {
              return result;
            }
          }
          else
          {
            *(_DWORD *)(v18 + 8) = v22 - 1;
            if ((v22 & 0x3FFFFFF) == 0) {
              return 9;
            }
          }
        }
        else
        {
          uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, void, void))v15)(v15 - *(void *)(*(void *)v15 + 24), v14, 0, 0, 0);
          if (result) {
            return result;
          }
        }
        BOOL v24 = v14 == v5;
        uint64_t v14 = (v14 + 1);
        if (v24) {
          return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 16))(a1 + 72 - *(void *)(*(void *)(a1 + 72) + 24));
        }
      }
    }
  }
  return result;
}

void FSTCompact2Builder_Finalize(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v51 = v2;
  uint64_t v52 = 0;
  uint64_t v50 = 0;
  long long v48 = 0u;
  long long v49 = 0u;
  memset(v47, 0, sizeof(v47));
  FST_Con(v47, *(void *)(a1 + 8), 0);
  if (v3 || FST_GetHeaderSizeInOutputBuffer(&v50)) {
    return;
  }
  if (!*(_DWORD *)(a1 + 80))
  {
LABEL_97:
    FST_Des((uint64_t)v47);
    return;
  }
  int v4 = v50;
  if (*(_DWORD *)(a1 + 104))
  {
    unsigned int v5 = 0;
    do
    {
      int v6 = *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 88) + 8)
                                 + 8 * (v5 >> *(_WORD *)(*(void *)(a1 + 88) + 44)))
                     + 4 * (v5 & ~(-1 << *(_WORD *)(*(void *)(a1 + 88) + 44))));
      char v42 = *(unsigned char *)(*(void *)(*(void *)(*(void *)(a1 + 96) + 8)
                                 + 8 * (v5 >> *(_WORD *)(*(void *)(a1 + 96) + 44)))
                     + (v5 & ~(-1 << *(_WORD *)(*(void *)(a1 + 96) + 44))));
      char v43 = HIBYTE(v6);
      char v44 = BYTE2(v6);
      char v45 = BYTE1(v6);
      char v46 = v6;
      if (*(uint64_t *)(a1 + 48) <= 0x7FFFFFFFFFFFFFFALL)
      {
        int ErrorCallback = (**(uint64_t (***)(char *, uint64_t, uint64_t, void))(a1 + 16))(&v42, 5, 1, *(void *)(a1 + 24)) == 1? 0: err_GenerateErrorCallback();
        *(void *)(a1 + 48) += 5;
      }
      else
      {
        int ErrorCallback = err_GenerateErrorCallback();
      }
      if (ErrorCallback) {
        return;
      }
    }
    while (++v5 < *(_DWORD *)(a1 + 104));
  }
  dpmemblock_Reset(*(void *)(a1 + 88));
  dpmemblock_Reset(*(void *)(a1 + 96));
  char v42 = 0;
  char v43 = (v2 - v4 - 24) >> 24;
  char v44 = (v2 - v4 - 24) >> 16;
  char v45 = (unsigned __int16)(v2 - v4 - 24) >> 8;
  char v46 = v2 - v4 - 24;
  if (*(uint64_t *)(a1 + 48) <= 0x7FFFFFFFFFFFFFFALL)
  {
    if ((**(uint64_t (***)(char *, uint64_t, uint64_t, void))(a1 + 16))(&v42, 5, 1, *(void *)(a1 + 24)) == 1) {
      int v8 = 0;
    }
    else {
      int v8 = err_GenerateErrorCallback();
    }
    *(void *)(a1 + 48) += 5;
  }
  else
  {
    int v8 = err_GenerateErrorCallback();
  }
  if (!v8)
  {
    uint64_t v9 = *(void *)(a1 + 48);
    v10.i32[0] = *(_DWORD *)(a1 + 68) & 0x3FFFF & *(_DWORD *)(a1 + 64);
    v10.i32[1] = *(_DWORD *)(a1 + 68) & 0x3FFFF;
    *(void *)&long long v48 = 0x200000028;
    *((int8x8_t *)&v48 + 1) = vorr_s8(v10, vand_s8(*(int8x8_t *)((char *)&v48 + 8), (int8x8_t)0x300000003));
    if (!__FSTFlatBuilder_WriteFstBaseHeader((uint64_t *)a1, v47, &v50))
    {
      HIDWORD(v52) = *(_DWORD *)(a1 + 108);
      uint64_t v11 = v50;
      if (v50 >= 2000000000) {
        uint64_t v12 = 2000000000;
      }
      else {
        uint64_t v12 = v50;
      }
      int v13 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v12, 0);
      if (v13) {
        int v13 = err_GenerateErrorCallback();
      }
      *(void *)(a1 + 48) = v12;
      BOOL v14 = v13 == 0;
      if (!v13)
      {
        uint64_t v15 = v11 - v12;
        if (v11 - v12 >= 1)
        {
          do
          {
            if (v15 >= 2000000000) {
              uint64_t v16 = 2000000000;
            }
            else {
              uint64_t v16 = v15;
            }
            int v17 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v16, 0);
            if (v17) {
              int v17 = err_GenerateErrorCallback();
            }
            *(void *)(a1 + 48) = v16;
            BOOL v14 = v17 == 0;
            if (v17) {
              break;
            }
            BOOL v18 = v15 <= v16;
            v15 -= v16;
          }
          while (!v18);
        }
      }
      if (v14)
      {
        if ((**(uint64_t (***)(char *, uint64_t, uint64_t, void))(a1 + 16))((char *)&v52 + 4, 4, 1, *(void *)(a1 + 24)) == 1)
        {
          *(void *)(a1 + 48) += 4;
        }
        else
        {
          int v19 = err_GenerateErrorCallback();
          *(void *)(a1 + 48) += 4;
          if (v19) {
            return;
          }
        }
        LODWORD(v52) = *(_DWORD *)(a1 + 104);
        uint64_t v20 = v50 + 12;
        if (v50 + 12 >= 2000000000) {
          uint64_t v21 = 2000000000;
        }
        else {
          uint64_t v21 = v50 + 12;
        }
        int v22 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v21, 0);
        if (v22) {
          int v22 = err_GenerateErrorCallback();
        }
        *(void *)(a1 + 48) = v21;
        BOOL v23 = v22 == 0;
        if (!v22)
        {
          uint64_t v24 = v20 - v21;
          if (v20 - v21 >= 1)
          {
            do
            {
              if (v24 >= 2000000000) {
                uint64_t v25 = 2000000000;
              }
              else {
                uint64_t v25 = v24;
              }
              int v26 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v25, 0);
              if (v26) {
                int v26 = err_GenerateErrorCallback();
              }
              *(void *)(a1 + 48) = v25;
              BOOL v23 = v26 == 0;
              if (v26) {
                break;
              }
              BOOL v18 = v24 <= v25;
              v24 -= v25;
            }
            while (!v18);
          }
        }
        if (v23)
        {
          if ((**(uint64_t (***)(uint64_t *, uint64_t, uint64_t, void))(a1 + 16))(&v52, 4, 1, *(void *)(a1 + 24)) == 1)
          {
            *(void *)(a1 + 48) += 4;
          }
          else
          {
            int v27 = err_GenerateErrorCallback();
            *(void *)(a1 + 48) += 4;
            if (v27) {
              return;
            }
          }
          uint64_t v28 = v50 + 16;
          if (v50 + 16 >= 2000000000) {
            uint64_t v29 = 2000000000;
          }
          else {
            uint64_t v29 = v50 + 16;
          }
          int v30 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v29, 0);
          if (v30) {
            int v30 = err_GenerateErrorCallback();
          }
          *(void *)(a1 + 48) = v29;
          BOOL v31 = v30 == 0;
          if (!v30)
          {
            uint64_t v32 = v28 - v29;
            if (v28 - v29 >= 1)
            {
              do
              {
                if (v32 >= 2000000000) {
                  uint64_t v33 = 2000000000;
                }
                else {
                  uint64_t v33 = v32;
                }
                int v34 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v33, 0);
                if (v34) {
                  int v34 = err_GenerateErrorCallback();
                }
                *(void *)(a1 + 48) = v33;
                BOOL v31 = v34 == 0;
                if (v34) {
                  break;
                }
                BOOL v18 = v32 <= v33;
                v32 -= v33;
              }
              while (!v18);
            }
          }
          if (v31)
          {
            if ((**(uint64_t (***)(uint64_t *, uint64_t, uint64_t, void))(a1 + 16))(&v51, 4, 1, *(void *)(a1 + 24)) == 1)
            {
              *(void *)(a1 + 48) += 4;
            }
            else
            {
              int v35 = err_GenerateErrorCallback();
              *(void *)(a1 + 48) += 4;
              if (v35) {
                return;
              }
            }
            if (v9 >= 2000000000) {
              uint64_t v36 = 2000000000;
            }
            else {
              uint64_t v36 = v9;
            }
            int v37 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v36, 0);
            if (v37) {
              int v37 = err_GenerateErrorCallback();
            }
            *(void *)(a1 + 48) = v36;
            BOOL v38 = v37 == 0;
            if (!v37)
            {
              uint64_t v39 = v9 - v36;
              if (v9 - v36 >= 1)
              {
                do
                {
                  if (v39 >= 2000000000) {
                    uint64_t v40 = 2000000000;
                  }
                  else {
                    uint64_t v40 = v39;
                  }
                  int v41 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v40, 0);
                  if (v41) {
                    int v41 = err_GenerateErrorCallback();
                  }
                  *(void *)(a1 + 48) = v40;
                  BOOL v38 = v41 == 0;
                  if (v41) {
                    break;
                  }
                  BOOL v18 = v39 <= v40;
                  v39 -= v40;
                }
                while (!v18);
              }
            }
            if (v38)
            {
              *(void *)(a1 + 56) = v9;
              *(_DWORD *)(a1 + 80) = 0;
              goto LABEL_97;
            }
          }
        }
      }
    }
  }
}

uint64_t FSTCompact2Builder_InitializeState(uint64_t a1, unsigned int a2, int a3, unsigned int a4, int a5)
{
  uint64_t v10 = *(void *)(a1 + 48);
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  unsigned int v11 = a2 + 1;
  uint64_t v12 = *(void *)(a1 + 88);
  unsigned int v13 = *(_DWORD *)(v12 + 32);
  if (a2 + 1 <= v13)
  {
    *(_DWORD *)(v12 + 32) = v11;
  }
  else
  {
    unsigned int v14 = v13 + 1;
    do
    {
      uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 88), &v20, 0);
      if (v14 >= v11) {
        break;
      }
      ++v14;
    }
    while (!result);
    if (result) {
      return result;
    }
  }
  uint64_t v20 = 0;
  uint64_t v16 = *(void *)(a1 + 96);
  unsigned int v17 = *(_DWORD *)(v16 + 32);
  if (v11 <= v17)
  {
    *(_DWORD *)(v16 + 32) = v11;
  }
  else
  {
    unsigned int v18 = v17 + 1;
    do
    {
      uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 96), &v20, 0);
      if (v18 >= v11) {
        break;
      }
      ++v18;
    }
    while (!result);
    if (result) {
      return result;
    }
  }
  ++*(_DWORD *)(a1 + 104);
  *(_DWORD *)(a1 + 84) = a2;
  uint64_t result = FST_GetHeaderSizeInOutputBuffer(&v21);
  if (!result)
  {
    unint64_t v19 = v10 - v21 - 24;
    if (HIDWORD(v19))
    {
      return err_GenerateErrorLimit();
    }
    else
    {
      *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 88) + 8)
                            + 8 * (a2 >> *(_WORD *)(*(void *)(a1 + 88) + 44)))
                + 4 * (a2 & ~(-1 << *(_WORD *)(*(void *)(a1 + 88) + 44)))) = v19;
      *(unsigned char *)(*(void *)(*(void *)(*(void *)(a1 + 96) + 8)
                           + 8 * (a2 >> *(_WORD *)(*(void *)(a1 + 96) + 44)))
               + (~(-1 << *(_WORD *)(*(void *)(a1 + 96) + 44)) & a2)) = HIBYTE(a3);
      if (a5) {
        *(_DWORD *)(a1 + 108) = a2;
      }
      if (a3 < 0)
      {
        LODWORD(v20) = bswap32(a4);
        if (*(uint64_t *)(a1 + 48) < 0x7FFFFFFFFFFFFFFCLL)
        {
          if ((**(uint64_t (***)(uint64_t *, uint64_t, uint64_t, void))(a1 + 16))(&v20, 4, 1, *(void *)(a1 + 24)) == 1)uint64_t result = 0; {
          else
          }
            uint64_t result = err_GenerateErrorCallback();
          *(void *)(a1 + 48) += 4;
        }
        else
        {
          return err_GenerateErrorCallback();
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void PNEW_FSTCompact2Builder_Con(uint64_t a1, uint64_t a2, void *a3)
{
  int v8 = 0;
  int v6 = (void *)OOCAllocator_Malloc(a1, 112, &v8);
  if (!v8)
  {
    FSTCompact2Builder_Con(v6, a2);
    int v8 = v7;
    if (v7)
    {
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
    }
    else
    {
      *a3 = v6;
    }
  }
}

void PNEW_FSTCompact2Builder_ConToStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  int v14 = 0;
  uint64_t v12 = (void *)OOCAllocator_Malloc(a1, 112, &v14);
  if (!v14)
  {
    FSTCompact2Builder_ConToStream(v12, a2, a3, a4, a5);
    int v14 = v13;
    if (v13)
    {
      OOCAllocator_Free(a1, (uint64_t)v12);
      *a6 = 0;
    }
    else
    {
      *a6 = v12;
    }
  }
}

void *GetFSTCompact2BuilderClass()
{
  return &__FSTCompact2Builder;
}

void FSTMinimize(uint64_t a1, _DWORD *a2, int8x8_t **a3)
{
  long long v7 = 0u;
  memset(v6, 0, sizeof(v6));
  if (!FSTMinimizeDfsContext_Con((uint64_t)v6, a1, a2) && !FSTDfsContext_Dfs((uint64_t)v6))
  {
    if (DWORD2(v7))
    {
      if (FSTMinimizeDfsContext_FinalizeMinimizationForCyclicFst((uint64_t)v6)) {
        return;
      }
    }
    else if (FSTMinimizeDfsContext_FinalizeMinimizationForAcyclicFst((uint64_t)v6))
    {
      return;
    }
    *(int8x8_t *)&double v4 = FSTMinimizeDfsContext_GetMinimizedFst((uint64_t *)v6, a3);
    if (!v5) {
      (*(void (**)(_OWORD *, double))(*(void *)&v6[0] + 16))(v6, v4);
    }
  }
}

void fstminimize(uint64_t a1, uint64_t a2, int8x8_t *a3, int8x8_t **a4)
{
  int v8 = 0;
  if (!FST_QueryProperties((uint64_t)a3, 4096, &v8))
  {
    if (v8)
    {
      *a4 = a3;
    }
    else
    {
      FSTMinimize(a2, a3, a4);
      if (!v7) {
        (*(void (**)(int8x8_t *))(*(void *)a3 + 32))(a3);
      }
    }
  }
}

double FSTBuild_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result = FST_Con((void *)a1, a2, a3);
  if (!v5)
  {
    *(void *)a1 = &__FSTBuild;
    *(void *)(a1 + 64) = &unk_26D216790;
    *(void *)&double result = 0x20000001ELL;
    *(void *)(a1 + 72) = -1;
    *(_DWORD *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 96) = 0;
    uint64_t v6 = *(void *)(a1 + 40) | 0x10000000100;
    *(void *)(a1 + 32) = 0x20000001ELL;
    *(void *)(a1 + 40) = v6;
  }
  return result;
}

double FSTBuild_ConFromStateArray(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, int a6)
{
  double result = FST_Con((void *)a1, a2, a5);
  if (!v11)
  {
    *(void *)a1 = &__FSTBuild;
    *(void *)(a1 + 64) = &unk_26D216790;
    *(void *)&double result = 0x20000001ELL;
    *(_DWORD *)(a1 + 72) = -1;
    *(_DWORD *)(a1 + 76) = a6;
    *(_DWORD *)(a1 + 80) = a4;
    *(void *)(a1 + 88) = a3;
    *(void *)(a1 + 96) = a3 + 8 * a4;
    uint64_t v12 = *(void *)(a1 + 40) | 0x10000000100;
    *(void *)(a1 + 32) = 0x20000001ELL;
    *(void *)(a1 + 40) = v12;
  }
  return result;
}

uint64_t FSTBuild_Des(uint64_t *a1)
{
  int v3 = (uint64_t *)a1[11];
  unint64_t v2 = a1[12];
  if ((unint64_t)v3 < v2)
  {
    do
    {
      if (*v3)
      {
        uint64_t result = OOC_PlacementDeleteObject(a1[3], *v3);
        if (result) {
          return result;
        }
        unint64_t v2 = a1[12];
      }
      ++v3;
    }
    while ((unint64_t)v3 < v2);
    int v3 = (uint64_t *)a1[11];
  }
  if (v3) {
    OOCAllocator_Free(a1[3], (uint64_t)v3);
  }

  return FST_Des((uint64_t)a1);
}

uint64_t FSTBuild_AddArc(uint64_t a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 88) + 8 * a2);
  v11[2] = a4;
  v11[3] = a5;
  v11[0] = a6;
  v11[1] = a3;
  if (a3 == -2) {
    int v9 = 2;
  }
  else {
    int v9 = 4;
  }
  uint64_t result = FSTState_AddArcs(v8, v9, (uint64_t)v11, 1u);
  if (!result) {
    *(_DWORD *)(a1 + 72) = a2;
  }
  return result;
}

uint64_t FSTBuild_AddArcSequence(uint64_t a1, int a2, int a3, uint64_t a4, _DWORD *a5)
{
  unsigned int v27 = 0;
  if (a4 >= 1)
  {
    int v5 = a5;
    LODWORD(v7) = a2;
    unint64_t v9 = (unint64_t)&a5[4 * a4];
    while (1)
    {
      uint64_t v10 = *(void *)(a1 + 88);
      uint64_t v11 = *(void *)(v10 + 8 * v7);
      LODWORD(v7) = a3;
      if ((unint64_t)v5 >= v9 - 16) {
        goto LABEL_16;
      }
      int v12 = v5[1];
      uint64_t v13 = 32;
      if (v12 != -2) {
        uint64_t v13 = 48;
      }
      uint64_t v14 = 56;
      if (v12 == -2) {
        uint64_t v14 = 40;
      }
      uint64_t v15 = *(unsigned int *)(v11 + v13);
      if (!v15) {
        break;
      }
      uint64_t v16 = *(_DWORD **)(v11 + v14);
      unsigned int v17 = &v16[4 * v15];
      while (1)
      {
        if (v16[1] == v12 && v16[2] == v5[2] && v16[3] == v5[3])
        {
          LODWORD(v7) = *v16;
          if (*v16 != a3) {
            break;
          }
        }
        v16 += 4;
        if (v16 >= v17) {
          goto LABEL_15;
        }
      }
LABEL_29:
      v5 += 4;
      if ((unint64_t)v5 >= v9) {
        return v27;
      }
    }
LABEL_15:
    unint64_t v7 = (unint64_t)(*(void *)(a1 + 96) - v10) >> 3;
    uint64_t v18 = FSTBuild_InitializeState(a1, v7, 0, 0, 0);
    unsigned int v27 = v18;
    if (v18) {
      return v18;
    }
LABEL_16:
    if (v5[1] == -2)
    {
      unint64_t v19 = (_DWORD *)(v11 + 32);
      unsigned int v20 = *(_DWORD *)(v11 + 32);
      uint64_t v21 = *(void *)(v11 + 40);
      if (v21)
      {
        unsigned int v22 = v20 + 1;
        if (*(_DWORD *)(v21 - 4) > v20 + 1) {
          goto LABEL_27;
        }
      }
      else
      {
        unsigned int v22 = v20 + 1;
      }
      uint64_t v21 = _FSTState_ReserveEpsilonArcsInternal(v11, v22, &v27);
    }
    else
    {
      unint64_t v19 = (_DWORD *)(v11 + 48);
      unsigned int v20 = *(_DWORD *)(v11 + 48);
      uint64_t v21 = *(void *)(v11 + 56);
      if (v21)
      {
        unsigned int v23 = v20 + 1;
        if (*(_DWORD *)(v21 - 4) > v20 + 1) {
          goto LABEL_27;
        }
      }
      else
      {
        unsigned int v23 = v20 + 1;
      }
      uint64_t v21 = _FSTState_ReserveArcsInternal(v11, v23, &v27);
    }
LABEL_27:
    uint64_t v24 = v27;
    if (v27) {
      return v24;
    }
    uint64_t v25 = v21 + 16 * v20;
    _DWORD *v19 = v20 + 1;
    *(_DWORD *)uint64_t v25 = v7;
    *(void *)(v25 + 4) = *(void *)(v5 + 1);
    *(_DWORD *)(v25 + 12) = v5[3];
    goto LABEL_29;
  }
  return 0;
}

uint64_t FSTBuild_InitializeState(uint64_t a1, unsigned int a2, int a3, int a4, int a5)
{
  unsigned int v20 = 0;
  if (a5 == 1) {
    *(_DWORD *)(a1 + 76) = a2;
  }
  uint64_t v19 = 0;
  uint64_t v9 = a2 + 1;
  uint64_t v10 = *(void *)(a1 + 88);
  uint64_t v11 = *(void **)(a1 + 96);
  unint64_t v12 = (unint64_t)v11 - v10;
  if (v9 < (((unint64_t)v11 - v10) >> 3)) {
    goto LABEL_4;
  }
  unsigned int v15 = *(_DWORD *)(a1 + 80);
  if (v9 <= v15)
  {
LABEL_17:
    while ((unint64_t)v11 < v10 + 8 * v9)
    {
      *uint64_t v11 = 0;
      uint64_t v11 = (void *)(*(void *)(a1 + 96) + 8);
      *(void *)(a1 + 96) = v11;
    }
LABEL_4:
    uint64_t result = PNEW_FSTState_Con(*(void *)(a1 + 24), *(void *)(a1 + 24), *(void *)(a1 + 48), &v19);
    if (!result)
    {
      uint64_t v14 = v19;
      *(_DWORD *)(v19 + 8) |= a3;
      *(_DWORD *)(v14 + 24) = a2;
      *(_DWORD *)(v14 + 28) = a4;
      *(void *)(*(void *)(a1 + 88) + 8 * a2) = v14;
    }
    return result;
  }
  unsigned int v16 = 2 * v15;
  unsigned int v17 = v15 + 1000000;
  if (v16 >= v17) {
    unsigned int v16 = v17;
  }
  if (v16 <= v9) {
    unsigned int v16 = v9;
  }
  if (v16 <= 8) {
    unsigned int v18 = 8;
  }
  else {
    unsigned int v18 = v16;
  }
  uint64_t v10 = OOCAllocator_Realloc(*(void *)(a1 + 24), v10, 8 * v18, &v20);
  *(void *)(a1 + 88) = v10;
  uint64_t result = v20;
  if (!v20)
  {
    *(_DWORD *)(a1 + 80) = v18;
    uint64_t v11 = (void *)(v10 + (v12 & 0x7FFFFFFF8));
    *(void *)(a1 + 96) = v11;
    goto LABEL_17;
  }
  return result;
}

uint64_t FSTBuild_BorrowStateFn(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 88) + 8 * a2);
}

uint64_t FSTBuild_Clear(uint64_t a1)
{
  *(void *)(a1 + 72) = -1;
  int v3 = *(uint64_t **)(a1 + 88);
  unint64_t v2 = *(void *)(a1 + 96);
  if ((unint64_t)v3 < v2)
  {
    do
    {
      uint64_t v4 = *v3;
      if (*v3)
      {
        int v5 = *(_DWORD *)(v4 + 8);
        if ((v5 & 0x3FFFFFF) == 1)
        {
          if ((v5 & 0x8000000) != 0) {
            uint64_t v6 = *(void *)(v4 + 16);
          }
          else {
            uint64_t v6 = 0;
          }
          uint64_t result = FSTStatePool_PushFSTState(v6, v4);
          if (result) {
            return result;
          }
          unint64_t v2 = *(void *)(a1 + 96);
        }
        else
        {
          *(_DWORD *)(v4 + 8) = v5 - 1;
          if ((v5 & 0x3FFFFFF) == 0) {
            return 9;
          }
        }
      }
      ++v3;
    }
    while ((unint64_t)v3 < v2);
    int v3 = *(uint64_t **)(a1 + 88);
  }
  *(_DWORD *)(a1 + 80) = 0;
  if (v3)
  {
    OOCAllocator_Free(*(void *)(a1 + 24), (uint64_t)v3);
    *(void *)(a1 + 88) = 0;
  }
  uint64_t result = 0;
  *(void *)(a1 + 96) = 0;
  return result;
}

uint64_t FSTBuild_FetchNewState(uint64_t a1, unsigned int a2, int a3, int a4, int a5, void *a6)
{
  *a6 = 0;
  uint64_t result = FSTBuild_InitializeState(a1, a2, a3, a4, a5);
  if (!result)
  {
    uint64_t v10 = *(void *)(*(void *)(a1 + 88) + 8 * a2);
    *a6 = v10;
    ++*(_DWORD *)(v10 + 8);
  }
  return result;
}

uint64_t FSTBuild_FetchState(uint64_t a1, unsigned int a2, unsigned int a3, void *a4)
{
  *a4 = 0;
  uint64_t v4 = *(void *)(a1 + 88);
  if (((unint64_t)(*(void *)(a1 + 96) - v4) >> 3) > a2)
  {
    uint64_t v5 = *(void *)(v4 + 8 * a2);
    if (v5)
    {
      if (FST_CheckQuery(*(_DWORD *)(v5 + 8) & 0xF0000000, a3))
      {
        *a4 = v5;
        ++*(_DWORD *)(v5 + 8);
      }
    }
  }
  return 0;
}

uint64_t FSTBuild_FillBuffer(uint64_t a1, char *a2, int64_t *a3)
{
  int v5 = *(_DWORD *)(a1 + 36);
  int64_t v31 = 0;
  if (a2)
  {
    int64_t v31 = *a3;
    uint64_t result = FST_FillHeader((_DWORD *)a1, a2, 1, &v31);
    if (result) {
      return result;
    }
    uint64_t v8 = &a2[v31];
    *(_DWORD *)uint64_t v8 = *(_DWORD *)(a1 + 76);
    uint64_t v9 = v8 + 4;
    unint64_t v10 = *(void *)(a1 + 88);
    unint64_t v11 = *(void *)(a1 + 96);
    if (v10 < v11)
    {
      for (unint64_t i = *(uint64_t **)(a1 + 88); (unint64_t)i < v11; ++i)
      {
        uint64_t v13 = *i;
        if (*i)
        {
          unint64_t v14 = ((unint64_t)i - v10) >> 3;
          if (v14 >> 28) {
            return err_GenerateErrorLimit();
          }
          uint64_t v15 = *(unsigned int *)(v13 + 48);
          uint64_t v16 = *(unsigned int *)(v13 + 32);
          *uint64_t v9 = *(_DWORD *)(v13 + 8) & 0xF0000000 | v14;
          v9[1] = *(_DWORD *)(v13 + 28);
          void v9[2] = v16 + v15;
          v9 += 3;
          if (v16)
          {
            uint64_t v17 = *(void *)(v13 + 40);
            unint64_t v18 = v17 + 16 * v16;
            uint64_t v19 = (_DWORD *)(v17 + 8);
            do
            {
              unsigned int v20 = v19 - 2;
              *uint64_t v9 = *(v19 - 2);
              v9[1] = *(v19 - 1);
              if (v5 == 1)
              {
                uint64_t v21 = v9 + 2;
              }
              else
              {
                void v9[2] = *v19;
                uint64_t v21 = v9 + 3;
              }
              *uint64_t v21 = v19[1];
              uint64_t v9 = v21 + 1;
              v19 += 4;
            }
            while ((unint64_t)(v20 + 4) < v18);
          }
          if (v15)
          {
            uint64_t v22 = *(void *)(v13 + 56);
            unint64_t v23 = v22 + 16 * v15;
            uint64_t v24 = (_DWORD *)(v22 + 8);
            do
            {
              uint64_t v25 = v24 - 2;
              *uint64_t v9 = *(v24 - 2);
              v9[1] = *(v24 - 1);
              if (v5 == 1)
              {
                int v26 = v9 + 2;
              }
              else
              {
                void v9[2] = *v24;
                int v26 = v9 + 3;
              }
              *int v26 = v24[1];
              uint64_t v9 = v26 + 1;
              v24 += 4;
            }
            while ((unint64_t)(v25 + 4) < v23);
          }
        }
      }
    }
    uint64_t result = 0;
    int64_t v27 = (char *)v9 - a2;
  }
  else
  {
    uint64_t result = FST_GetHeaderSizeInOutputBuffer(&v31);
    if (result) {
      return result;
    }
    int64_t v27 = v31 + 4;
    unint64_t v28 = *(void *)(a1 + 88);
    for (unint64_t j = *(void *)(a1 + 96); v28 < j; v28 += 8)
    {
      if (*(void *)v28)
      {
        uint64_t v30 = 4 * (*(_DWORD *)(*(void *)v28 + 32) + *(_DWORD *)(*(void *)v28 + 48));
        if (v5 == 1) {
          uint64_t v30 = 0;
        }
        v27 += 12 * (*(_DWORD *)(*(void *)v28 + 32) + *(_DWORD *)(*(void *)v28 + 48)) + v30 + 12;
      }
    }
    uint64_t result = 0;
  }
  *a3 = v27;
  return result;
}

uint64_t FSTBuild_Finalize()
{
  return 0;
}

uint64_t FSTBuild_GetFinalStateWeight(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  *a3 = *(_DWORD *)(*(void *)(*(void *)(a1 + 88) + 8 * a2) + 28);
  return 0;
}

uint64_t FSTBuild_GetInitialStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 76);
  return 0;
}

uint64_t FSTBuild_GetMaxStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = ((*(void *)(a1 + 96) - *(void *)(a1 + 88)) >> 3) - 1;
  return 0;
}

uint64_t FSTBuild_GetMemoryInfo(uint64_t a1)
{
  uint64_t result = 8 * *(unsigned int *)(a1 + 80) + 108;
  uint64_t v4 = *(uint64_t **)(a1 + 88);
  unint64_t v3 = *(void *)(a1 + 96);
  while ((unint64_t)v4 < v3)
  {
    uint64_t v5 = *v4;
    if (*v4)
    {
      uint64_t v6 = *(void *)(v5 + 56);
      if (v6 || (uint64_t v6 = *(void *)(v5 + 40)) != 0) {
        uint64_t v6 = *(unsigned int *)(v6 - 4);
      }
      result += 16 * v6 + 64;
    }
    ++v4;
  }
  return result;
}

uint64_t FSTBuild_GetStateFlags(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  *a3 = *(_DWORD *)(*(void *)(*(void *)(a1 + 88) + 8 * a2) + 8) & 0xF0000000;
  return 0;
}

uint64_t FSTBuild_InitFromBuffer(uint64_t a1, char *a2, unint64_t a3)
{
  unint64_t v22 = 0;
  int v21 = 1;
  uint64_t result = (uint64_t)FST_GetHeaderSizeInInputBuffer(a2, (uint64_t *)&v22);
  if (!result)
  {
    if (v22 <= a3)
    {
      uint64_t result = FST_ReadHeader((_DWORD *)a1, a2, &v21, &v22);
      if (!result)
      {
        int v7 = *(_DWORD *)(a1 + 36);
        uint64_t v8 = &a2[v22 + 4];
        *(_DWORD *)(a1 + 76) = *(_DWORD *)&a2[v22];
        unint64_t v18 = &a2[a3];
        if (&a2[a3] - v8 < 12)
        {
          return 0;
        }
        else
        {
          do
          {
            unint64_t v9 = *((unsigned int *)v8 + 2);
            uint64_t v10 = *(_DWORD *)v8 & 0xFFFFFFF;
            uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, void, void))(a1 + 64))(a1 + 64 - *(void *)(*(void *)(a1 + 64) + 24), v10, *(_DWORD *)v8 & 0xF0000000, *((unsigned int *)v8 + 1), 0);
            if (result) {
              break;
            }
            v8 += 12;
            if (v9)
            {
              uint64_t v11 = 0;
              uint64_t v12 = *(void *)(*(void *)(a1 + 88) + 8 * v10);
              BOOL v13 = 1;
              do
              {
                uint64_t v19 = 0;
                uint64_t v20 = 0;
                int v14 = *((_DWORD *)v8 + 1);
                LODWORD(v19) = *(_DWORD *)v8;
                HIDWORD(v19) = v14;
                if (v7 == 1)
                {
                  uint64_t v15 = v8 + 8;
                }
                else
                {
                  LODWORD(v20) = *((_DWORD *)v8 + 2);
                  uint64_t v15 = v8 + 12;
                }
                int v16 = *v15;
                uint64_t v8 = (char *)(v15 + 1);
                HIDWORD(v20) = v16;
                if (v14 == -2) {
                  int v17 = 2;
                }
                else {
                  int v17 = 4;
                }
                uint64_t result = FSTState_AddArcs(v12, v17, (uint64_t)&v19, 1u);
                if (result) {
                  break;
                }
                BOOL v13 = ++v11 < v9;
              }
              while (v9 != v11);
              if (v13) {
                return result;
              }
            }
            else
            {
              uint64_t result = 0;
            }
          }
          while (v18 - v8 >= 12);
        }
      }
    }
    else
    {
      return err_GenerateErrorData();
    }
  }
  return result;
}

uint64_t FSTBuild_RemoveMatchingArcSequences(uint64_t a1, int a2, int a3, uint64_t a4, _DWORD *a5, int a6, void *a7)
{
  unsigned int v140 = 0;
  uint64_t v7 = *(void *)(a1 + 24);
  uint64_t v8 = 4 * a4;
  __b = (void *)OOCAllocator_Malloc(v7, 4 * a4, &v140);
  if (v140) {
    return v140;
  }
  __s2 = (_DWORD *)OOCAllocator_Malloc(v7, v8, &v140);
  if (v140) {
    return v140;
  }
  cstdlib_memset(__b, 0, v8);
  uint64_t v9 = OOCAllocator_Realloc(v7, 0, 96, &v140);
  if (v140) {
    return v140;
  }
  uint64_t v10 = v9;
  uint64_t v128 = v7;
  uint64_t v129 = 0;
  size_t __n = v8;
  uint64_t v127 = 0;
  uint64_t v11 = 0;
  int v12 = 0;
  uint64_t v125 = 0;
  BOOL v13 = (unsigned int *)(v9 + 12);
  *(_DWORD *)uint64_t v9 = a2;
  *(void *)(v9 + 4) = 0xFFFFFFFF00000000;
  uint64_t v14 = a1;
  uint64_t v15 = a5 + 1;
  uint64_t v16 = 8;
  while (1)
  {
    unsigned int v18 = *(v13 - 3);
    v13 -= 3;
    uint64_t v17 = v18;
    uint64_t v19 = *(void *)(v14 + 88);
    uint64_t v20 = *(void *)(v19 + 8 * v18);
    if (!v20) {
      goto LABEL_103;
    }
    uint64_t v21 = v13[1];
    unsigned int v22 = v13[2];
    if (!v12) {
      break;
    }
    unsigned int v23 = *(_DWORD *)(v20 + 32);
    int v24 = *(_DWORD *)(v20 + 48);
    if (v17 != a2)
    {
      if (v24 + v23 < 2) {
        goto LABEL_15;
      }
      BOOL v25 = !v23 && v24 == 2;
      if (v25)
      {
        if (**(_DWORD **)(v20 + 56) == v17)
        {
LABEL_15:
          if (!v11) {
            goto LABEL_144;
          }
          int v26 = *(_DWORD *)(v20 + 8);
          if ((v26 & 0x3FFFFFF) == 1)
          {
            uint64_t v27 = v10;
            uint64_t v28 = v16;
            if ((v26 & 0x8000000) != 0) {
              uint64_t v29 = *(void *)(v20 + 16);
            }
            else {
              uint64_t v29 = 0;
            }
            unsigned int v140 = FSTStatePool_PushFSTState(v29, v20);
            if (v140) {
              return v140;
            }
            uint64_t v10 = v27;
            uint64_t v14 = a1;
            uint64_t v19 = *(void *)(a1 + 88);
            uint64_t v15 = a5 + 1;
            uint64_t v16 = v28;
          }
          else
          {
            *(_DWORD *)(v20 + 8) = v26 - 1;
            if ((v26 & 0x3FFFFFF) == 0) {
              return 9;
            }
            unsigned int v140 = 0;
          }
          *(void *)(v19 + 8 * v17) = 0;
LABEL_103:
          int v12 = 1;
          uint64_t v11 = 1;
          goto LABEL_104;
        }
        unsigned int v23 = 0;
      }
    }
    if (v11)
    {
      uint64_t v60 = v16;
      if (v22 >= v23) {
        unsigned int v61 = v23;
      }
      else {
        unsigned int v61 = 0;
      }
      if (v22 >= v23) {
        int v62 = 4;
      }
      else {
        int v62 = 2;
      }
      LODWORD(v139) = v22 - v61;
      uint64_t v63 = v10;
      unsigned int v140 = FSTState_RemoveArcs(v20, v62, (uint64_t)&v139, 1);
      if (v140) {
        return v140;
      }
      uint64_t v10 = v63;
      unsigned int v64 = v22 - 1;
      uint64_t v15 = a5 + 1;
      uint64_t v16 = v60;
      uint64_t v14 = a1;
    }
    else
    {
      unsigned int v64 = v13[2];
    }
    if (v22 == v24 + v23)
    {
      int v12 = 0;
      uint64_t v11 = 0;
    }
    else
    {
      unint64_t v65 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v13 - v10) >> 2);
      unsigned int v66 = v65 + 1;
      if ((int)v65 + 1 > v16)
      {
        unsigned int v67 = 2 * v16;
        if (2 * (int)v16 >= (v16 + 1000000)) {
          unsigned int v67 = v16 + 1000000;
        }
        if (v67 > v66) {
          unsigned int v66 = v67;
        }
        if (v66 <= 8) {
          uint64_t v68 = 8;
        }
        else {
          uint64_t v68 = v66;
        }
        uint64_t v69 = v68;
        uint64_t v70 = OOCAllocator_Realloc(v128, v10, 12 * v68, &v140);
        if (v140) {
          return v140;
        }
        uint64_t v10 = v70;
        BOOL v13 = (unsigned int *)(v70 + 12 * v65);
        uint64_t v15 = a5 + 1;
        uint64_t v16 = v69;
        uint64_t v14 = a1;
      }
      int v12 = 0;
      uint64_t v11 = 0;
      *BOOL v13 = v17;
      v13[1] = v21;
      v13[2] = v64;
LABEL_98:
      v13 += 3;
    }
LABEL_104:
    if ((unsigned int *)v10 == v13)
    {
LABEL_198:
      if (__s2)
      {
        uint64_t v122 = v10;
        OOCAllocator_Free(v128, (uint64_t)__s2);
        uint64_t v10 = v122;
      }
      if (__b)
      {
        uint64_t v123 = v10;
        OOCAllocator_Free(v128, (uint64_t)__b);
        uint64_t v10 = v123;
      }
      if (v10) {
        OOCAllocator_Free(v128, v10);
      }
      *a7 = v125;
      return v140;
    }
  }
  unint64_t v30 = *(unsigned int *)(v20 + 32);
  unsigned int v31 = *(_DWORD *)(v20 + 48) + v30;
  unint64_t v32 = v22 + 1;
  if (v32 >= v31)
  {
LABEL_41:
    int v12 = 0;
    goto LABEL_104;
  }
  uint64_t v33 = (v21 + 1);
  while (1)
  {
    if (v32 >= v30) {
      int v34 = (unsigned int *)(*(void *)(v20 + 56) + 16 * v32 - 16 * v30);
    }
    else {
      int v34 = (unsigned int *)(*(void *)(v20 + 40) + 16 * v32);
    }
    unsigned int v35 = *v34;
    if (*v34 == v17) {
      goto LABEL_29;
    }
    unsigned int v36 = v34[2];
    if (v36 == -2)
    {
      unint64_t v71 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v13 - v10) >> 2);
      unsigned int v72 = v71 + 1;
      if ((int)v71 + 1 > v16)
      {
        uint64_t v73 = v11;
        unsigned int v74 = 2 * v16;
        if (2 * (int)v16 >= (v16 + 1000000)) {
          unsigned int v74 = v16 + 1000000;
        }
        if (v74 > v72) {
          unsigned int v72 = v74;
        }
        if (v72 <= 8) {
          uint64_t v75 = 8;
        }
        else {
          uint64_t v75 = v72;
        }
        uint64_t v76 = v75;
        uint64_t v77 = OOCAllocator_Realloc(v128, v10, 12 * v75, &v140);
        if (v140) {
          return v140;
        }
        uint64_t v10 = v77;
        BOOL v13 = (unsigned int *)(v77 + 12 * v71);
        uint64_t v15 = a5 + 1;
        uint64_t v16 = v76;
        uint64_t v11 = v73;
        uint64_t v14 = a1;
      }
      unsigned int v78 = v13 + 3;
      *BOOL v13 = v17;
      v13[1] = v21;
      v13[2] = v32;
      unint64_t v79 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v13 - v10 + 12) >> 2);
      if ((int)v79 + 1 > v16)
      {
        uint64_t v80 = v11;
        unsigned int v81 = 2 * v16;
        if (2 * (int)v16 >= (v16 + 1000000)) {
          unsigned int v81 = v16 + 1000000;
        }
        if (v81 <= (int)v79 + 1) {
          unsigned int v81 = v79 + 1;
        }
        if (v81 <= 8) {
          uint64_t v82 = 8;
        }
        else {
          uint64_t v82 = v81;
        }
        uint64_t v83 = v82;
        uint64_t v84 = OOCAllocator_Realloc(v128, v10, 12 * v82, &v140);
        if (v140) {
          return v140;
        }
        uint64_t v10 = v84;
        unsigned int v78 = (unsigned int *)(v84 + 12 * v79);
        uint64_t v15 = a5 + 1;
        uint64_t v16 = v83;
        uint64_t v11 = v80;
        uint64_t v14 = a1;
      }
      int v12 = 0;
      BOOL v13 = v78 + 3;
      *unsigned int v78 = v35;
      v78[1] = v21;
      v78[2] = -1;
      goto LABEL_104;
    }
    if (!v21) {
      break;
    }
    if (v36 == HIDWORD(v129) + v21)
    {
      __s2[v21] = v36;
      goto LABEL_43;
    }
LABEL_28:
    if (!a6)
    {
      if (*v34 == a3)
      {
        unint64_t v86 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v13 - v10) >> 2);
        unsigned int v87 = v86 + 1;
        if ((int)v86 + 1 > v16)
        {
          uint64_t v88 = v11;
          unsigned int v89 = 2 * v16;
          if (2 * (int)v16 >= (v16 + 1000000)) {
            unsigned int v89 = v16 + 1000000;
          }
          if (v89 > v87) {
            unsigned int v87 = v89;
          }
          if (v87 <= 8) {
            uint64_t v90 = 8;
          }
          else {
            uint64_t v90 = v87;
          }
          uint64_t v91 = v90;
          uint64_t v92 = OOCAllocator_Realloc(v128, v10, 12 * v90, &v140);
          if (v140) {
            return v140;
          }
          uint64_t v10 = v92;
          BOOL v13 = (unsigned int *)(v92 + 12 * v86);
          uint64_t v15 = a5 + 1;
          uint64_t v16 = v91;
          uint64_t v11 = v88;
          uint64_t v14 = a1;
        }
        *BOOL v13 = v17;
        v13[1] = v21;
        v13[2] = v32;
        v13 += 3;
LABEL_144:
        int v12 = 1;
        goto LABEL_104;
      }
      if (v21)
      {
        uint64_t v100 = *a5;
        if (v100)
        {
          unsigned int v101 = v34[2];
          unsigned int v102 = v15;
          while (1)
          {
            int v103 = *v102++;
            if (v101 == v103) {
              break;
            }
            if (!--v100) {
              goto LABEL_163;
            }
          }
          _DWORD *__s2 = v101;
          int v104 = 1;
        }
        else
        {
LABEL_163:
          int v104 = 0;
        }
        unint64_t v112 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v13 - v10) >> 2);
        unsigned int v118 = v112 + 1;
        if ((int)v112 + 1 <= v16) {
          goto LABEL_197;
        }
        uint64_t v113 = v11;
        unsigned int v119 = 2 * v16;
        if (2 * (int)v16 >= (v16 + 1000000)) {
          unsigned int v119 = v16 + 1000000;
        }
        if (v119 > v118) {
          unsigned int v118 = v119;
        }
        if (v118 <= 8) {
          uint64_t v120 = 8;
        }
        else {
          uint64_t v120 = v118;
        }
        uint64_t v116 = v120;
        uint64_t v121 = OOCAllocator_Realloc(v128, v10, 12 * v120, &v140);
        if (v140) {
          return v140;
        }
        uint64_t v10 = v121;
      }
      else
      {
        unint64_t v105 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v13 - v10) >> 2);
        unsigned int v106 = v105 + 1;
        if ((int)v105 + 1 > v16)
        {
          uint64_t v107 = v11;
          unsigned int v108 = 2 * v16;
          if (2 * (int)v16 >= (v16 + 1000000)) {
            unsigned int v108 = v16 + 1000000;
          }
          if (v108 > v106) {
            unsigned int v106 = v108;
          }
          if (v106 <= 8) {
            uint64_t v109 = 8;
          }
          else {
            uint64_t v109 = v106;
          }
          uint64_t v110 = v109;
          uint64_t v111 = OOCAllocator_Realloc(v128, v10, 12 * v109, &v140);
          if (v140) {
            return v140;
          }
          uint64_t v10 = v111;
          BOOL v13 = (unsigned int *)(v111 + 12 * v105);
          uint64_t v15 = a5 + 1;
          uint64_t v16 = v110;
          uint64_t v11 = v107;
          uint64_t v14 = a1;
        }
        *BOOL v13 = v17;
        v13[1] = 0;
        v13[2] = v32;
        unint64_t v112 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v13 - v10 + 12) >> 2);
        if ((int)v112 + 1 <= v16)
        {
          int v104 = 0;
          v13 += 3;
          goto LABEL_197;
        }
        uint64_t v113 = v11;
        unsigned int v114 = 2 * v16;
        if (2 * (int)v16 >= (v16 + 1000000)) {
          unsigned int v114 = v16 + 1000000;
        }
        if (v114 <= (int)v112 + 1) {
          unsigned int v114 = v112 + 1;
        }
        if (v114 <= 8) {
          uint64_t v115 = 8;
        }
        else {
          uint64_t v115 = v114;
        }
        uint64_t v116 = v115;
        uint64_t v117 = OOCAllocator_Realloc(v128, v10, 12 * v115, &v140);
        if (v140) {
          return v140;
        }
        uint64_t v10 = v117;
        int v104 = 0;
      }
      BOOL v13 = (unsigned int *)(v10 + 12 * v112);
      uint64_t v15 = a5 + 1;
      uint64_t v16 = v116;
      uint64_t v11 = v113;
      uint64_t v14 = a1;
LABEL_197:
      int v12 = 0;
      *BOOL v13 = v35;
      v13[1] = v104;
      goto LABEL_73;
    }
LABEL_29:
    if (v31 == ++v32) {
      goto LABEL_41;
    }
  }
  if (!v129)
  {
    LODWORD(v37) = *a5;
LABEL_36:
    if (v37) {
      goto LABEL_37;
    }
    goto LABEL_28;
  }
  uint64_t v37 = *a5;
  if (v36 == HIDWORD(v129)) {
    goto LABEL_36;
  }
  a5[v127] = a5[v37];
  LODWORD(v37) = *a5 - 1;
  BOOL v25 = *a5 == 1;
  *a5 = v37;
  if (v25) {
    goto LABEL_198;
  }
  LODWORD(v129) = 0;
LABEL_37:
  uint64_t v38 = 0;
  uint64_t v39 = v37;
  unsigned int v40 = v34[2];
  while (v40 != v15[v38])
  {
    if (v39 == ++v38) {
      goto LABEL_28;
    }
  }
  _DWORD *__s2 = v40;
  uint64_t v127 = v38 + 1;
  HIDWORD(v129) = v40;
LABEL_43:
  unint64_t v41 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v13 - v10) >> 2);
  unsigned int v42 = v41 + 1;
  if ((int)v41 + 1 <= v16)
  {
    size_t v48 = __n;
LABEL_56:
    *BOOL v13 = v17;
    v13[1] = v21;
    v13[2] = v32;
    v13 += 3;
    if (v33 != a4)
    {
      unint64_t v53 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v13 - v10) >> 2);
      unsigned int v54 = v53 + 1;
      if ((int)v53 + 1 > v16)
      {
        uint64_t v55 = v11;
        unsigned int v56 = 2 * v16;
        if (2 * (int)v16 >= (v16 + 1000000)) {
          unsigned int v56 = v16 + 1000000;
        }
        if (v56 > v54) {
          unsigned int v54 = v56;
        }
        if (v54 <= 8) {
          uint64_t v57 = 8;
        }
        else {
          uint64_t v57 = v54;
        }
        uint64_t v58 = v57;
        uint64_t v59 = OOCAllocator_Realloc(v128, v10, 12 * v57, &v140);
        if (v140) {
          return v140;
        }
        uint64_t v10 = v59;
        BOOL v13 = (unsigned int *)(v59 + 12 * v53);
        uint64_t v15 = a5 + 1;
        uint64_t v16 = v58;
        uint64_t v11 = v55;
        uint64_t v14 = a1;
      }
      int v12 = 0;
      *BOOL v13 = v35;
      v13[1] = v33;
LABEL_73:
      v13[2] = -1;
      goto LABEL_98;
    }
    unsigned int v49 = *v34;
    if (a6)
    {
      if (v49 != a3) {
        goto LABEL_144;
      }
      uint64_t v50 = v10;
      uint64_t v51 = v16;
      size_t v52 = v48;
      if (cstdlib_memcmp(__b, __s2, v48))
      {
        cstdlib_memcpy(__b, __s2, v52);
        ++v125;
      }
      int v12 = 1;
      uint64_t v11 = 1;
      LODWORD(v129) = 1;
      goto LABEL_131;
    }
    uint64_t v50 = v10;
    uint64_t v51 = v16;
    if (v49 == a3)
    {
      size_t v85 = v48;
      if (cstdlib_memcmp(__b, __s2, v48))
      {
        cstdlib_memcpy(__b, __s2, v85);
        ++v125;
      }
      int v12 = 1;
      uint64_t v11 = 1;
LABEL_131:
      uint64_t v15 = a5 + 1;
      uint64_t v16 = v51;
      uint64_t v10 = v50;
      goto LABEL_104;
    }
    uint64_t v139 = 0;
    unsigned int v140 = __FSTBuild_RemoveFollowingAndCountUnique(v14, v49, a3, &v139);
    if (v140) {
      return v140;
    }
    uint64_t v10 = v50;
    uint64_t v93 = v139;
    unint64_t v94 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v13 - v50) >> 2);
    unsigned int v95 = v94 + 1;
    uint64_t v16 = v51;
    if ((int)v94 + 1 > v51)
    {
      unsigned int v96 = 2 * v51;
      if (2 * (int)v51 >= (v51 + 1000000)) {
        unsigned int v96 = v51 + 1000000;
      }
      if (v96 > v95) {
        unsigned int v95 = v96;
      }
      if (v95 <= 8) {
        uint64_t v97 = 8;
      }
      else {
        uint64_t v97 = v95;
      }
      uint64_t v98 = v97;
      uint64_t v99 = OOCAllocator_Realloc(v128, v50, 12 * v97, &v140);
      if (v140) {
        return v140;
      }
      uint64_t v10 = v99;
      BOOL v13 = (unsigned int *)(v99 + 12 * v94);
      uint64_t v16 = v98;
    }
    v125 += v93;
    *BOOL v13 = v35;
    v13[1] = v33;
    v13[2] = -1;
    v13 += 3;
    int v12 = 1;
    uint64_t v11 = 1;
    uint64_t v15 = a5 + 1;
    uint64_t v14 = a1;
    goto LABEL_104;
  }
  uint64_t v43 = v11;
  unsigned int v44 = 2 * v16;
  if (2 * (int)v16 >= (v16 + 1000000)) {
    unsigned int v44 = v16 + 1000000;
  }
  if (v44 > v42) {
    unsigned int v42 = v44;
  }
  if (v42 <= 8) {
    uint64_t v45 = 8;
  }
  else {
    uint64_t v45 = v42;
  }
  uint64_t v46 = v45;
  uint64_t v47 = OOCAllocator_Realloc(v128, v10, 12 * v45, &v140);
  size_t v48 = __n;
  if (!v140)
  {
    uint64_t v10 = v47;
    BOOL v13 = (unsigned int *)(v47 + 12 * v41);
    uint64_t v15 = a5 + 1;
    uint64_t v16 = v46;
    uint64_t v11 = v43;
    uint64_t v14 = a1;
    goto LABEL_56;
  }
  return v140;
}

uint64_t __FSTBuild_RemoveFollowingAndCountUnique(uint64_t a1, unsigned int a2, int a3, uint64_t *a4)
{
  uint64_t v5 = *(void *)(a1 + 24);
  unsigned int v46 = 0;
  uint64_t v6 = *(void *)(*(void *)(a1 + 88) + 8 * a2);
  if (v6)
  {
    uint64_t v9 = a1;
    if (!*(_DWORD *)(v6 + 48) && !*(_DWORD *)(v6 + 32))
    {
LABEL_65:
      uint64_t v6 = 0;
      goto LABEL_66;
    }
    uint64_t v10 = (_DWORD *)OOCAllocator_Realloc(v5, 0, 32, &v46);
    uint64_t v6 = 0;
    if (!v46)
    {
      uint64_t v11 = (uint64_t)v10;
      uint64_t v42 = a2;
      uint64_t v43 = a4;
      *uint64_t v10 = a2;
      int v12 = v10 + 1;
      unsigned int v13 = 8;
      uint64_t v45 = v9;
      unsigned int v44 = a2;
      do
      {
        unsigned int v15 = *--v12;
        uint64_t v14 = v15;
        uint64_t v16 = *(void *)(*(void *)(v9 + 88) + 8 * v15);
        if (v16)
        {
          uint64_t v17 = *(unsigned int *)(v16 + 32);
          if (v17)
          {
            unsigned int v18 = *(int **)(v16 + 40);
            uint64_t v19 = &v18[4 * v17];
            do
            {
              int v20 = *v18;
              if (*v18 != v14 && v20 != a3)
              {
                unint64_t v22 = (unint64_t)v12 - v11;
                unsigned int v23 = (((unint64_t)v12 - v11) >> 2) + 1;
                if (v23 > v13)
                {
                  unsigned int v24 = 2 * v13;
                  if (2 * v13 >= v13 + 1000000) {
                    unsigned int v24 = v13 + 1000000;
                  }
                  if (v24 <= v23) {
                    unsigned int v24 = (((unint64_t)v12 - v11) >> 2) + 1;
                  }
                  if (v24 <= 8) {
                    unsigned int v13 = 8;
                  }
                  else {
                    unsigned int v13 = v24;
                  }
                  uint64_t v25 = OOCAllocator_Realloc(v5, v11, 4 * v13, &v46);
                  if (v46) {
                    goto LABEL_59;
                  }
                  uint64_t v11 = v25;
                  int v12 = (_DWORD *)(v25 + (v22 & 0x3FFFFFFFCLL));
                  int v20 = *v18;
                }
                *v12++ = v20;
              }
              v18 += 4;
            }
            while (v18 < v19);
          }
          uint64_t v26 = *(unsigned int *)(v16 + 48);
          if (v26)
          {
            uint64_t v27 = *(int **)(v16 + 56);
            uint64_t v28 = &v27[4 * v26];
            do
            {
              int v29 = *v27;
              if (*v27 != v14 && v29 != a3)
              {
                unint64_t v31 = (unint64_t)v12 - v11;
                unsigned int v32 = (((unint64_t)v12 - v11) >> 2) + 1;
                if (v32 > v13)
                {
                  unsigned int v33 = 2 * v13;
                  if (2 * v13 >= v13 + 1000000) {
                    unsigned int v33 = v13 + 1000000;
                  }
                  if (v33 <= v32) {
                    unsigned int v33 = (((unint64_t)v12 - v11) >> 2) + 1;
                  }
                  if (v33 <= 8) {
                    unsigned int v13 = 8;
                  }
                  else {
                    unsigned int v13 = v33;
                  }
                  uint64_t v34 = OOCAllocator_Realloc(v5, v11, 4 * v13, &v46);
                  if (v46) {
                    goto LABEL_59;
                  }
                  uint64_t v11 = v34;
                  int v12 = (_DWORD *)(v34 + (v31 & 0x3FFFFFFFCLL));
                  int v29 = *v27;
                }
                *v12++ = v29;
              }
              v27 += 4;
            }
            while (v27 < v28);
          }
          if (v14 == v44)
          {
            uint64_t v9 = v45;
          }
          else
          {
            int v35 = *(_DWORD *)(v16 + 8);
            uint64_t v9 = v45;
            if ((v35 & 0x3FFFFFF) == 1)
            {
              if ((v35 & 0x8000000) != 0) {
                uint64_t v36 = *(void *)(v16 + 16);
              }
              else {
                uint64_t v36 = 0;
              }
              unsigned int v46 = FSTStatePool_PushFSTState(v36, v16);
              if (v46)
              {
LABEL_59:
                uint64_t v6 = 0;
LABEL_60:
                a4 = v43;
                goto LABEL_66;
              }
            }
            else
            {
              *(_DWORD *)(v16 + 8) = v35 - 1;
              if ((v35 & 0x3FFFFFF) == 0)
              {
                uint64_t v6 = 0;
                unsigned int v46 = 9;
                goto LABEL_60;
              }
              unsigned int v46 = 0;
            }
            *(void *)(*(void *)(v45 + 88) + 8 * v14) = 0;
          }
        }
      }
      while ((_DWORD *)v11 != v12);
      uint64_t v37 = *(void *)(v9 + 88);
      uint64_t v38 = *(void *)(v37 + 8 * v42);
      int v39 = *(_DWORD *)(v38 + 8);
      if ((v39 & 0x3FFFFFF) == 1)
      {
        a4 = v43;
        if ((v39 & 0x8000000) != 0) {
          uint64_t v40 = *(void *)(v38 + 16);
        }
        else {
          uint64_t v40 = 0;
        }
        unsigned int v46 = FSTStatePool_PushFSTState(v40, v38);
        if (v46) {
          goto LABEL_65;
        }
        uint64_t v37 = *(void *)(v9 + 88);
      }
      else
      {
        *(_DWORD *)(v38 + 8) = v39 - 1;
        a4 = v43;
        if ((v39 & 0x3FFFFFF) == 0)
        {
          uint64_t v6 = 0;
          unsigned int v46 = 9;
          goto LABEL_66;
        }
        unsigned int v46 = 0;
      }
      *(void *)(v37 + 8 * v42) = 0;
      if (v11) {
        OOCAllocator_Free(v5, v11);
      }
      uint64_t v6 = 1;
    }
  }
LABEL_66:
  *a4 = v6;
  return v46;
}

uint64_t FSTBuild_SetFinalStateWeight(uint64_t result, unsigned int a2, int a3)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 88) + 8 * a2) + 28) = a3;
  return result;
}

uint64_t FSTBuild_SetStateFlags(uint64_t result, unsigned int a2, int a3)
{
  uint64_t v3 = *(void *)(*(void *)(result + 88) + 8 * a2);
  *(_DWORD *)(v3 + 8) |= a3;
  return result;
}

uint64_t FSTBuild_UnsetStateFlags(uint64_t result, unsigned int a2, int a3)
{
  uint64_t v3 = *(void *)(*(void *)(result + 88) + 8 * a2);
  *(_DWORD *)(v3 + 8) &= ~a3;
  return result;
}

void PNEW_FSTBuild_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 104, &v10);
  if (!v10)
  {
    FSTBuild_Con(v8, a2, a3);
    int v10 = v9;
    if (v9)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
    }
    else
    {
      *(void *)(v8 + 16) = a1;
      *a4 = v8;
    }
  }
}

void PNEW_FSTBuild_ConFromStateArray(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, int a6, uint64_t *a7)
{
  int v16 = 0;
  uint64_t v14 = OOCAllocator_Malloc(a1, 104, &v16);
  if (!v16)
  {
    FSTBuild_ConFromStateArray(v14, a2, a3, a4, a5, a6);
    int v16 = v15;
    if (v15)
    {
      OOCAllocator_Free(a1, v14);
      *a7 = 0;
    }
    else
    {
      *(void *)(v14 + 16) = a1;
      *a7 = v14;
    }
  }
}

void *GetFSTBuildClass()
{
  return &__FSTBuild;
}

double _FSTBaseFlat_Con(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, const void *a5, uint64_t a6, unsigned int a7)
{
  double result = FST_Con(a1, a2, a3);
  if (!v13)
  {
    *a1 = &__FSTBaseFlat;
    return _FSTBaseFlat_Init((uint64_t)a1, a4, a5, a6, a7);
  }
  return result;
}

double _FSTBaseFlat_Init(uint64_t a1, unint64_t a2, const void *a3, uint64_t a4, unsigned int a5)
{
  uint64_t v11 = 0;
  *(void *)(a1 + 72) = a2;
  *(void *)(a1 + 88) = a3;
  *(void *)(a1 + 96) = a4;
  if (!FST_GetHeaderSizeInInputBuffer(a3, &v11))
  {
    unint64_t v10 = v11 + 16;
    *(void *)(a1 + 80) = v11 + 16;
    if (v10 > a2)
    {
LABEL_3:
      err_GenerateErrorData();
      return result;
    }
    if (!FST_ReadHeader((_DWORD *)a1, a3, (_DWORD *)(a1 + 104), (unint64_t *)&v11))
    {
      if (*(_DWORD *)(a1 + 104) > a5) {
        goto LABEL_3;
      }
      *(_DWORD *)(a1 + 64) = *(_DWORD *)(v11 + *(void *)(a1 + 88) + 12);
      *(void *)&double result = *(void *)(a1 + 40) | 0x10000000100;
      *(double *)(a1 + 40) = result;
    }
  }
  return result;
}

void _FSTBaseFlat_ConEmpty(void *a1, uint64_t a2, uint64_t a3)
{
  FST_Con(a1, a2, a3);
  if (!v4)
  {
    *a1 = &__FSTBaseFlat;
    a1[11] = 0;
    a1[12] = 0;
  }
}

uint64_t FSTBaseFlat_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 96);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 88);
    if (v3) {
      OOCAllocator_Free(v2, v3);
    }
  }

  return FST_Des(a1);
}

uint64_t FSTBaseFlat_GetInitialStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(*(void *)(a1 + 80) + *(void *)(a1 + 88) - 16);
  return 0;
}

uint64_t FSTBaseFlat_GetMaxStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 64) - 1;
  return 0;
}

uint64_t FSTBaseFlat_GetMemoryInfo(uint64_t a1)
{
  if (*(void *)(a1 + 96)) {
    return *(void *)(a1 + 72) + 112;
  }
  else {
    return 0;
  }
}

void *GetFSTBaseFlatClass()
{
  return &__FSTBaseFlat;
}

uint64_t FSTDfs2Context_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = Object_Con((void *)a1);
  if (!v6)
  {
    *(void *)a1 = &__FSTDfs2Context;
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 16) = a3;
    (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
    *(_DWORD *)(a1 + 24) = 0;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_DWORD *)(a1 + 64) = 0;
  }
  return v6;
}

uint64_t FSTDfs2Context_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    OOCAllocator_Free(*(void *)(a1 + 8), v2);
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16));
  if (!result)
  {
    return Object_Des();
  }
  return result;
}

uint64_t FSTDfs2Context_Dfs(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v64 = *(void *)(a1 + 8);
  unsigned int DfsState = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (DfsState) {
    return DfsState;
  }
  unsigned int v67 = 0;
  unsigned int DfsState = (*(uint64_t (**)(uint64_t, unsigned int *))(*(void *)v2 + 48))(v2, &v67);
  if (DfsState) {
    return DfsState;
  }
  if (v67 == -1)
  {
    int v17 = 0;
    uint64_t v7 = 0;
    unsigned int v18 = 0;
  }
  else
  {
    long long v65 = 0u;
    long long v66 = 0u;
    unsigned int DfsState = __FSTDfs2Context_CreateDfsState(a1, v67, (uint64_t *)&v65);
    if (DfsState) {
      return DfsState;
    }
    int v4 = (_OWORD *)OOCAllocator_Realloc(v64, 0, 256, &DfsState);
    BOOL v5 = DfsState == 0;
    if (DfsState) {
      return DfsState;
    }
    long long v6 = v66;
    *int v4 = v65;
    v4[1] = v6;
    uint64_t v7 = (uint64_t)v4;
    uint64_t v8 = v67 + 1;
    uint64_t v9 = *(void *)(a1 + 32);
    unint64_t v10 = *(unsigned char **)(a1 + 40);
    unsigned int v11 = v10 - v9;
    if (v8 >= (int)v10 - (int)v9)
    {
      unsigned int v12 = *(_DWORD *)(a1 + 24);
      if (v8 > v12)
      {
        unsigned int v13 = 2 * v12;
        unsigned int v14 = v12 + 1000000;
        if (v13 >= v14) {
          unsigned int v13 = v14;
        }
        if (v13 <= v8) {
          unsigned int v13 = v67 + 1;
        }
        if (v13 <= 8) {
          uint64_t v15 = 8;
        }
        else {
          uint64_t v15 = v13;
        }
        uint64_t v16 = OOCAllocator_Realloc(v64, v9, v15, &DfsState);
        *(void *)(a1 + 32) = v16;
        if (DfsState) {
          return DfsState;
        }
        uint64_t v9 = v16;
        *(_DWORD *)(a1 + 24) = v15;
        unint64_t v10 = (unsigned char *)(v16 + v11);
        *(void *)(a1 + 40) = v10;
      }
      if ((unint64_t)v10 < v9 + v8)
      {
        do
        {
          *unint64_t v10 = 0;
          unint64_t v10 = (unsigned char *)(*(void *)(a1 + 40) + 1);
          *(void *)(a1 + 40) = v10;
        }
        while ((unint64_t)v10 < v9 + v8);
        uint64_t v9 = *(void *)(a1 + 32);
      }
    }
    *(unsigned char *)(v9 + v67) = 1;
    if (*(_DWORD *)(a1 + 48))
    {
      unsigned int DfsState = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 32))(a1, v65);
      if (DfsState) {
        return DfsState;
      }
    }
    int v17 = 8 * v5;
    unsigned int v18 = (char *)(v7 + 32);
  }
  if ((char *)v7 == v18)
  {
LABEL_105:
    unsigned int v61 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
    unsigned int DfsState = v61;
    if (v7 && !v61) {
      OOCAllocator_Free(v64, v7);
    }
    return DfsState;
  }
  unsigned int v63 = v17;
  uint64_t v19 = v18;
  while (1)
  {
    uint64_t v20 = *((void *)v19 - 4);
    v19 -= 32;
    uint64_t v21 = *(unsigned int *)(v20 + 24);
    unint64_t v22 = (unsigned int *)*((void *)v19 + 3);
    uint64_t v23 = (v21 + 1);
    uint64_t v24 = *(void *)(a1 + 32);
    uint64_t v25 = *(unsigned char **)(a1 + 40);
    unsigned int v26 = v25 - v24;
    uint64_t v27 = (char *)v7;
    if (v23 >= (int)v25 - (int)v24)
    {
      unsigned int v39 = *(_DWORD *)(a1 + 24);
      if (v23 > v39)
      {
        unsigned int v40 = 2 * v39;
        unsigned int v41 = v39 + 1000000;
        if (v40 >= v41) {
          unsigned int v40 = v41;
        }
        if (v40 <= v23) {
          unsigned int v40 = v21 + 1;
        }
        if (v40 <= 8) {
          uint64_t v42 = 8;
        }
        else {
          uint64_t v42 = v40;
        }
        uint64_t v43 = OOCAllocator_Realloc(v64, v24, v42, &DfsState);
        *(void *)(a1 + 32) = v43;
        if (DfsState) {
          return DfsState;
        }
        uint64_t v24 = v43;
        *(_DWORD *)(a1 + 24) = v42;
        uint64_t v25 = (unsigned char *)(v43 + v26);
        *(void *)(a1 + 40) = v25;
      }
      while ((unint64_t)v25 < v24 + v23)
      {
        *uint64_t v25 = 0;
        uint64_t v25 = (unsigned char *)(*(void *)(a1 + 40) + 1);
        *(void *)(a1 + 40) = v25;
      }
    }
    if (!v22) {
      break;
    }
    uint64_t v28 = *v22;
    uint64_t v29 = (v28 + 1);
    uint64_t v30 = *(void *)(a1 + 32);
    unsigned int v31 = v25 - v30;
    if (v29 >= (int)v25 - (int)v30)
    {
      unsigned int v32 = *(_DWORD *)(a1 + 24);
      if (v29 > v32)
      {
        unsigned int v33 = 2 * v32;
        unsigned int v34 = v32 + 1000000;
        if (v33 >= v34) {
          unsigned int v33 = v34;
        }
        if (v33 <= v29) {
          unsigned int v33 = v28 + 1;
        }
        if (v33 <= 8) {
          uint64_t v35 = 8;
        }
        else {
          uint64_t v35 = v33;
        }
        uint64_t v36 = OOCAllocator_Realloc(v64, v30, v35, &DfsState);
        *(void *)(a1 + 32) = v36;
        if (DfsState) {
          return DfsState;
        }
        uint64_t v30 = v36;
        *(_DWORD *)(a1 + 24) = v35;
        uint64_t v25 = (unsigned char *)(v36 + v31);
        *(void *)(a1 + 40) = v25;
      }
      if ((unint64_t)v25 < v30 + v29)
      {
        do
        {
          *uint64_t v25 = 0;
          uint64_t v25 = (unsigned char *)(*(void *)(a1 + 40) + 1);
          *(void *)(a1 + 40) = v25;
        }
        while ((unint64_t)v25 < v30 + v29);
        uint64_t v30 = *(void *)(a1 + 32);
      }
    }
    int v37 = *(unsigned __int8 *)(v30 + v28);
    if (v37 == 1)
    {
      if (*(_DWORD *)(a1 + 56))
      {
        unsigned int v38 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned int *))(*(void *)a1 + 48))(a1, v21, v22);
        goto LABEL_64;
      }
LABEL_65:
      uint64_t v47 = *((void *)v18 - 2);
      uint64_t v48 = *((void *)v18 - 1) + 16;
      *((void *)v18 - 1) = v48;
      if (v48 == v47) {
        goto LABEL_86;
      }
      if (v48 == *((void *)v18 - 3))
      {
        if (*(_DWORD *)(*(void *)v19 + 48))
        {
          uint64_t v49 = *(void *)(*(void *)v19 + 56);
          goto LABEL_87;
        }
LABEL_86:
        uint64_t v49 = 0;
LABEL_87:
        *((void *)v18 - 1) = v49;
      }
      uint64_t v19 = v18;
      goto LABEL_104;
    }
    if (v37 == 2)
    {
      if (*(_DWORD *)(a1 + 60))
      {
        unsigned int v38 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned int *))(*(void *)a1 + 56))(a1, v21, v22);
LABEL_64:
        unsigned int DfsState = v38;
        if (v38) {
          return DfsState;
        }
      }
      goto LABEL_65;
    }
    long long v65 = 0u;
    long long v66 = 0u;
    if (*(_DWORD *)(a1 + 52))
    {
      unsigned int DfsState = (*(uint64_t (**)(uint64_t, uint64_t, unsigned int *))(*(void *)a1 + 40))(a1, v21, v22);
      if (DfsState) {
        return DfsState;
      }
      uint64_t v30 = *(void *)(a1 + 32);
    }
    *(unsigned char *)(v30 + v28) = 1;
    unsigned int DfsState = __FSTDfs2Context_CreateDfsState(a1, v28, (uint64_t *)&v65);
    if (DfsState) {
      return DfsState;
    }
    int64_t v50 = v18 - v27;
    unsigned int v51 = ((unint64_t)(v18 - v27) >> 5) + 1;
    if (v51 > v63)
    {
      uint64_t v52 = (uint64_t)v27;
      unsigned int v53 = 2 * v63;
      if (2 * v63 >= v63 + 1000000) {
        unsigned int v53 = v63 + 1000000;
      }
      if (v53 > v51) {
        unsigned int v51 = v53;
      }
      if (v51 <= 8) {
        unsigned int v54 = 8;
      }
      else {
        unsigned int v54 = v51;
      }
      uint64_t v55 = OOCAllocator_Realloc(v64, v52, 32 * v54, &DfsState);
      if (DfsState) {
        return DfsState;
      }
      unsigned int v63 = v54;
      uint64_t v27 = (char *)v55;
      unsigned int v18 = (char *)(v55 + (v50 & 0x1FFFFFFFE0));
    }
    long long v56 = v66;
    *(_OWORD *)unsigned int v18 = v65;
    *((_OWORD *)v18 + 1) = v56;
    if (*(_DWORD *)(a1 + 48))
    {
      unsigned int DfsState = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 32))(a1, v65);
      if (DfsState) {
        return DfsState;
      }
    }
    uint64_t v19 = v18 + 32;
LABEL_104:
    unsigned int v18 = v19;
    uint64_t v7 = (uint64_t)v27;
    if (v27 == v19) {
      goto LABEL_105;
    }
  }
  *(unsigned char *)(*(void *)(a1 + 32) + v21) = 2;
  uint64_t v44 = *(void *)v19;
  int v45 = *(_DWORD *)(*(void *)v19 + 8);
  if ((v45 & 0x3FFFFFF) == 1)
  {
    if ((v45 & 0x8000000) != 0) {
      uint64_t v46 = *(void *)(v44 + 16);
    }
    else {
      uint64_t v46 = 0;
    }
    unsigned int v62 = FSTStatePool_PushFSTState(v46, v44);
    if (v62) {
      return v62;
    }
    goto LABEL_93;
  }
  *(_DWORD *)(v44 + 8) = v45 - 1;
  if ((v45 & 0x3FFFFFF) != 0)
  {
LABEL_93:
    *(_OWORD *)uint64_t v19 = 0u;
    *((_OWORD *)v19 + 1) = 0u;
    unsigned int DfsState = 0;
    if (*(_DWORD *)(a1 + 64))
    {
      if ((char *)v7 == v19)
      {
        unsigned int DfsState = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 64))(a1, v21, 0xFFFFFFFFLL);
        uint64_t v19 = (char *)v7;
        if (DfsState) {
          return DfsState;
        }
        goto LABEL_104;
      }
      unsigned int DfsState = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 64))(a1, v21, *(unsigned int *)(*((void *)v18 - 8) + 24));
      if (DfsState) {
        return DfsState;
      }
      uint64_t v57 = *((void *)v18 - 6);
      uint64_t v58 = *((void *)v18 - 5) + 16;
      *((void *)v18 - 5) = v58;
      if (v58 == v57) {
        goto LABEL_102;
      }
      if (v58 == *((void *)v18 - 7))
      {
        uint64_t v59 = *((void *)v18 - 8);
        if (*(_DWORD *)(v59 + 48)) {
          uint64_t v60 = *(void *)(v59 + 56);
        }
        else {
LABEL_102:
        }
          uint64_t v60 = 0;
        *((void *)v18 - 5) = v60;
        goto LABEL_104;
      }
    }
    goto LABEL_104;
  }
  return 9;
}

uint64_t __FSTDfs2Context_CreateDfsState(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 16) + 120))(*(void *)(a1 + 16), a2, 8, a3);
  if (!result)
  {
    uint64_t v5 = *a3;
    if (*a3)
    {
      uint64_t v6 = *(void *)(v5 + 40);
      a3[3] = v6;
      uint64_t v7 = *(unsigned int *)(v5 + 32);
      uint64_t v8 = v6 + 16 * v7;
      uint64_t v9 = *(void *)(v5 + 56);
      uint64_t v10 = *(unsigned int *)(v5 + 48);
      a3[1] = v8;
      a3[2] = v9 + 16 * v10;
      if (!v7)
      {
        if (v10) {
          uint64_t v11 = v9;
        }
        else {
          uint64_t v11 = 0;
        }
        a3[3] = v11;
      }
    }
    else
    {
      a3[1] = 0;
      a3[2] = 0;
      a3[3] = 0;
    }
  }
  return result;
}

uint64_t _FSTDfs2Context_ExploreBackArc()
{
  return err_GenerateErrorNotSupported();
}

uint64_t _FSTDfs2Context_ExploreForwardOrCrossArc()
{
  return err_GenerateErrorNotSupported();
}

uint64_t _FSTDfs2Context_ExploreTreeArc()
{
  return err_GenerateErrorNotSupported();
}

uint64_t _FSTDfs2Context_FinishDfs()
{
  return 0;
}

uint64_t _FSTDfs2Context_FinishState()
{
  return err_GenerateErrorNotSupported();
}

uint64_t _FSTDfs2Context_InitDfs()
{
  return 0;
}

uint64_t _FSTDfs2Context_InitState()
{
  return err_GenerateErrorNotSupported();
}

_DWORD *_FSTDfs2Context_SetDfsOptions(_DWORD *result, int a2, int a3, int a4, int a5, int a6)
{
  result[12] = a2;
  result[13] = a3;
  result[14] = a4;
  result[15] = a5;
  result[16] = a6;
  return result;
}

double PNEW_FSTDfs2Context_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  int v11 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 72, &v11);
  if (!v11)
  {
    int v10 = Object_Con((void *)v8);
    if (v10)
    {
      int v11 = v10;
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
    }
    else
    {
      *(void *)uint64_t v8 = &__FSTDfs2Context;
      *(void *)(v8 + 8) = a2;
      *(void *)(v8 + 16) = a3;
      (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
      *(_DWORD *)(v8 + 24) = 0;
      double result = 0.0;
      *(_OWORD *)(v8 + 32) = 0u;
      *(_OWORD *)(v8 + 48) = 0u;
      *(_DWORD *)(v8 + 64) = 0;
      *a4 = v8;
    }
  }
  return result;
}

void *GetFSTDfs2ContextClass()
{
  return &__FSTDfs2Context;
}

uint64_t FSTFormatRegistry_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__FSTFormatRegistry;
    *(void *)(a1 + 8) = a3;
    *(void *)(a1 + 16) = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
  }
  return result;
}

uint64_t FSTFormatRegistry_Des(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    OOCAllocator_Free(*(void *)(a1 + 16), v1);
  }

  return Object_Des();
}

uint64_t FSTFormatRegistry_DeleteInstance(uint64_t a1)
{
  if (!VoConGlobals_HasVariable(2010113315)) {
    return 0;
  }
  uint64_t Variable = VoConGlobals_GetVariable(2010113315);
  uint64_t v3 = *(void *)(Variable + 8);
  BOOL v4 = v3 == a1 || a1 == 0;
  if (!v4 && v3 != 0) {
    return 0;
  }
  uint64_t v6 = Variable;
  VoConGlobals_RemoveVariable(2010113315);
  uint64_t v7 = *(void *)(v6 + 16);

  return OOC_PlacementDeleteObject(v7, v6);
}

_DWORD *FSTFormatRegistry_GetFormat(uint64_t a1, int a2)
{
  uint64_t v2 = *(_DWORD **)(a1 + 32);
  uint64_t v3 = *(_DWORD **)(a1 + 40);
  while (v2 < v3 && *v2 != a2)
    v2 += 6;
  if (v2 == v3) {
    return 0;
  }
  else {
    return v2;
  }
}

uint64_t FSTFormatRegistry_GetInstance(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (VoConGlobals_HasVariable(2010113315)) {
    goto LABEL_2;
  }
  if (a1)
  {
    if (VoConGlobals_HasFreeVariables() || (uint64_t result = err_GenerateErrorNotSupported(), !result))
    {
      uint64_t result = PNEW_FSTFormatRegistry_Con(a1, a1, a2, a3);
      if (!result)
      {
        VoConGlobals_SetVariable(2010113315, *a3);
LABEL_2:
        uint64_t Variable = VoConGlobals_GetVariable(2010113315);
        uint64_t result = 0;
        *a3 = Variable;
      }
    }
  }
  else
  {
    return err_GenerateErrorNotSupported();
  }
  return result;
}

uint64_t PNEW_FSTFormatRegistry_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 48, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = Object_Con((void *)v8);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *(void *)uint64_t v8 = &__FSTFormatRegistry;
      *(void *)(v8 + 8) = a3;
      *(void *)(v8 + 16) = a2;
      *(_DWORD *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 0;
      *(void *)(v8 + 40) = 0;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t FSTFormatRegistry_RegisterFormat(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  unsigned int v20 = 0;
  unint64_t v8 = *(void *)(a1 + 32);
  unint64_t v9 = *(void *)(a1 + 40);
  unint64_t v10 = v8;
  if (v8 < v9)
  {
    unint64_t v10 = *(void *)(a1 + 32);
    do
    {
      if (*(_DWORD *)v10 == a2) {
        break;
      }
      v10 += 24;
    }
    while (v10 < v9);
  }
  if (v10 == v9 || v10 == 0)
  {
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - v8) >> 3);
    unsigned int v13 = *(_DWORD *)(a1 + 24);
    if ((int)v12 + 1 > v13)
    {
      unsigned int v14 = 2 * v13;
      unsigned int v15 = v13 + 1000000;
      if (v14 >= v15) {
        unsigned int v14 = v15;
      }
      if (v14 <= (int)v12 + 1) {
        unsigned int v14 = v12 + 1;
      }
      if (v14 <= 8) {
        unsigned int v16 = 8;
      }
      else {
        unsigned int v16 = v14;
      }
      uint64_t v17 = OOCAllocator_Realloc(*(void *)(a1 + 16), v8, 24 * v16, &v20);
      *(void *)(a1 + 32) = v17;
      uint64_t v18 = v20;
      if (v20) {
        return v18;
      }
      *(_DWORD *)(a1 + 24) = v16;
      unint64_t v9 = v17 + 24 * v12;
    }
    *(void *)(a1 + 40) = v9 + 24;
    *(_DWORD *)unint64_t v9 = a2;
    *(_DWORD *)(v9 + 4) = 0;
    *(void *)(v9 + 8) = a3;
    *(void *)(v9 + 16) = a4;
    return v20;
  }
  if (*(void *)(v10 + 8) == a3 && *(void *)(v10 + 16) == a4) {
    return 0;
  }

  return err_GenerateErrorNotSupported();
}

void *GetFSTFormatRegistryClass()
{
  return &__FSTFormatRegistry;
}

uint64_t FSTTopoSort_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = FSTDfsContext_Con(a1, a2, a3);
  if (!result)
  {
    *(void *)a1 = &__FSTTopoSort;
    *(void *)(a1 + 64) = 0;
    uint64_t result = dpmemblock_Create(a2, 4, 0x400u, (uint64_t *)(a1 + 64));
    if (!result)
    {
      *(_DWORD *)(a1 + 72) = 0;
      *(_DWORD *)(a1 + 56) = 1;
      *(_DWORD *)(a1 + 48) = 1;
    }
  }
  return result;
}

uint64_t FSTTopoSort_Des(uint64_t a1)
{
  dpmemblock_Free(*(uint64_t **)(a1 + 64));

  return FSTDfsContext_Des(a1);
}

uint64_t FSTTopoSort_DiscoverState()
{
  return 0;
}

uint64_t FSTTopoSort_ExploreNonTreeArc(uint64_t a1, int a2, unsigned int *a3)
{
  uint64_t v3 = *a3;
  if (v3 != a2 && *(unsigned char *)(*(void *)(a1 + 24) + v3) == 1) {
    *(_DWORD *)(a1 + 72) = 1;
  }
  return 0;
}

uint64_t FSTTopoSort_FinishState(uint64_t a1, int a2)
{
  BOOL v4 = 0;
  uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 64), &v4, 0);
  if (!result) {
    *BOOL v4 = a2;
  }
  return result;
}

uint64_t PNEW_FSTTopoSort_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 80, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = FSTTopoSort_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

void *GetFSTTopoSortClass()
{
  return &__FSTTopoSort;
}

double FSTCompact2_Con(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  *(void *)(a1 + 224) = a5;
  double result = FSTCompact2_ConFromBuffers((void *)a1, a2, a3, a4, a4, (const void **)(a1 + 224), a6);
  if (!v8)
  {
    *(void *)a1 = &__FSTCompact2;
    *(void *)&double result = *(void *)(a1 + 40) | 0x10000000100;
    *(double *)(a1 + 40) = result;
  }
  return result;
}

double FSTCompact2_ConFromBuffers(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, const void **a6, uint64_t a7)
{
  unsigned int v13 = *a6;
  double result = _FSTBaseFlat_Con(a1, a2, a3, a5, *a6, a7, 3u);
  if (!v15)
  {
    *a1 = &__FSTCompact2;
    a1[21] = a2;
    double result = _FSTBaseFlat_Init((uint64_t)a1, a4, v13, a7, 3u);
    if (!v16)
    {
      return __FSTCompact2_InitFromBuffers((uint64_t)a1, a4, a5, a6, a7);
    }
  }
  return result;
}

void FSTCompact2_ConForAddState(uint64_t a1, uint64_t a2, int a3)
{
  _FSTBaseFlat_ConEmpty((void *)a1, a2, 0);
  if (!v6)
  {
    *(void *)a1 = &__FSTCompact2;
    *(void *)(a1 + 168) = a2;
    *(_DWORD *)(a1 + 200) = 0;
    *(_DWORD *)(a1 + 216) = 0;
    *(_DWORD *)(a1 + 220) = a3;
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = 0;
    *(void *)(a1 + 120) = a1 + 224;
  }
}

double __FSTCompact2_InitFromBuffers(uint64_t a1, unint64_t a2, unint64_t a3, const void **a4, uint64_t a5)
{
  unsigned int v10 = (char *)*a4;
  int v16 = 0;
  unint64_t v15 = 0;
  if (!FST_GetHeaderSizeInInputBuffer(v10, (uint64_t *)&v15))
  {
    if (a3 >= a2) {
      a3 = a2;
    }
    if (a3 < v15 + 24) {
      goto LABEL_5;
    }
    double result = _FSTBaseFlat_Init(a1, a3, v10, a5, 3u);
    if (!v12)
    {
      *(void *)(a1 + 136) = 0;
      *(void *)(a1 + 144) = 0;
      *(void *)(a1 + 112) = a3;
      *(void *)(a1 + 120) = a4;
      *(void *)(a1 + 128) = (a2 + a3 - 1) / a3;
      if (!FST_ReadHeader((_DWORD *)a1, v10, &v16, &v15))
      {
        if (*(_DWORD *)(a1 + 32) != 40 || *(_DWORD *)(a1 + 104) != 3)
        {
LABEL_5:
          err_GenerateErrorData();
          return result;
        }
        uint64_t v13 = *(void *)&v10[v15 + 16];
        *(void *)&long long v14 = v13;
        *((void *)&v14 + 1) = HIDWORD(v13);
        *(_OWORD *)(a1 + 152) = v14;
        *(void *)&double result = *(void *)(a1 + 40) | 0x10000000100;
        *(double *)(a1 + 40) = result;
      }
    }
  }
  return result;
}

double FSTCompact2_ConFromFST(int8x8_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v41 = 0;
  uint64_t v39 = 0;
  uint64_t v38 = 0;
  int v40 = 0;
  *a1 = (int8x8_t)&__FSTCompact2;
  a1[21] = (int8x8_t)a2;
  int v36 = 0;
  int v37 = -1;
  if (*((_DWORD *)a3 + 8) != 30) {
    goto LABEL_41;
  }
  if ((*(unsigned int (**)(uint64_t *, int *))(*a3 + 72))(a3, &v37)) {
    return result;
  }
  int v7 = v37;
  if (v37 == -1)
  {
LABEL_41:
    if (FSTCount(a2, (uint64_t)a3, (uint64_t)&v37)) {
      return result;
    }
    int v7 = v37;
  }
  unsigned int v8 = v7 + 1;
  a1[8].i32[0] = v7 + 1;
  if (v7 == -1)
  {
    int v9 = 24;
LABEL_19:
    int HeaderSizeInOutputBuffer = FST_GetHeaderSizeInOutputBuffer(&v41);
    if (!HeaderSizeInOutputBuffer)
    {
      uint64_t v15 = (5 * v7 + 10);
      int v16 = v9 + v41;
      unint64_t v17 = v15 + (v9 + v41);
      uint64_t v18 = (char *)OOCAllocator_Malloc(a2, v17, &HeaderSizeInOutputBuffer);
      if (!HeaderSizeInOutputBuffer)
      {
        a1[4].i32[0] = 40;
        a1[4].i32[1] = *((_DWORD *)a3 + 9);
        v19.i32[0] = *((_DWORD *)a3 + 11) & 0x3FFFF & a3[5];
        v19.i32[1] = *((_DWORD *)a3 + 11) & 0x3FFFF;
        a1[5] = (int8x8_t)(*(void *)&vorr_s8(vand_s8(a1[5], (int8x8_t)0x300000003), v19) | 0x10000000100);
        int HeaderSizeInOutputBuffer = FST_FillHeader(a1, v18, 3, &v41);
        if (!HeaderSizeInOutputBuffer)
        {
          int HeaderSizeInOutputBuffer = (*(uint64_t (**)(uint64_t *, int *))(*a3 + 48))(a3, &v36);
          if (!HeaderSizeInOutputBuffer)
          {
            int v20 = v41;
            uint64_t v21 = &v18[v41];
            int v22 = v36;
            *((_DWORD *)v21 + 1) = 0;
            *((_DWORD *)v21 + 2) = 0;
            *(_DWORD *)uint64_t v21 = v22;
            *((_DWORD *)v21 + 3) = v37 + 1;
            *((_DWORD *)v21 + 4) = v16;
            *((_DWORD *)v21 + 5) = v20 + 24;
            unsigned int v34 = &v18[v16];
            int v23 = v21 + 24;
            if (v8)
            {
              uint64_t v24 = 0;
              uint64_t v25 = 0;
              unsigned int v26 = v21 + 24;
              while (1)
              {
                uint64_t v35 = 0;
                int HeaderSizeInOutputBuffer = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(*a3 + 120))(a3, v24, 8, &v35);
                if (HeaderSizeInOutputBuffer) {
                  break;
                }
                uint64_t v27 = v35;
                uint64_t v28 = &v34[v25];
                char *v28 = *(unsigned char *)(v35 + 11) & 0xF0;
                v28[1] = (v26 - v23) >> 24;
                v28[2] = (v26 - v23) >> 16;
                v28[3] = (unsigned __int16)((_WORD)v26 - v23) >> 8;
                void v28[4] = (_BYTE)v26 - v23;
                unsigned int v26 = __FSTCompact2_CompressState(v27, v26);
                int v29 = *(_DWORD *)(v35 + 8);
                if ((v29 & 0x3FFFFFF) == 1)
                {
                  if ((v29 & 0x8000000) != 0) {
                    uint64_t v30 = *(void *)(v35 + 16);
                  }
                  else {
                    uint64_t v30 = 0;
                  }
                  int HeaderSizeInOutputBuffer = FSTStatePool_PushFSTState(v30, v35);
                  if (HeaderSizeInOutputBuffer) {
                    return result;
                  }
                }
                else
                {
                  *(_DWORD *)(v35 + 8) = v29 - 1;
                  if ((v29 & 0x3FFFFFF) == 0) {
                    return result;
                  }
                  int HeaderSizeInOutputBuffer = 0;
                }
                v25 += 5;
                uint64_t v24 = (v24 + 1);
                if (5 * v8 == v25)
                {
                  uint64_t v31 = 5 * v8;
                  goto LABEL_37;
                }
              }
            }
            else
            {
              uint64_t v31 = 0;
              LODWORD(v26) = v21 + 24;
LABEL_37:
              unsigned int v32 = &v34[v31];
              *unsigned int v32 = 0;
              v32[1] = (v26 - v23) >> 24;
              v32[2] = (v26 - v23) >> 16;
              v32[3] = (unsigned __int16)((_WORD)v26 - v23) >> 8;
              v32[4] = (_BYTE)v26 - v23;
              unsigned int v33 = (const void **)OOCAllocator_Malloc(a2, 8, &HeaderSizeInOutputBuffer);
              if (!HeaderSizeInOutputBuffer)
              {
                *unsigned int v33 = v18;
                return FSTCompact2_ConFromBuffers(a1, a2, a3[6], v17, v17, v33, a2);
              }
            }
          }
        }
      }
    }
  }
  else
  {
    int v10 = 0;
    uint64_t v11 = 0;
    while (1)
    {
      uint64_t v35 = 0;
      if ((*(unsigned int (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(*a3 + 120))(a3, v11, 8, &v35)) {
        break;
      }
      int CompressedStateSize = __FSTCompact2_GetCompressedStateSize(v35);
      int v13 = *(_DWORD *)(v35 + 8);
      if ((v13 & 0x3FFFFFF) == 1)
      {
        if ((v13 & 0x8000000) != 0) {
          uint64_t v14 = *(void *)(v35 + 16);
        }
        else {
          uint64_t v14 = 0;
        }
        int HeaderSizeInOutputBuffer = FSTStatePool_PushFSTState(v14, v35);
        if (HeaderSizeInOutputBuffer) {
          return result;
        }
      }
      else
      {
        *(_DWORD *)(v35 + 8) = v13 - 1;
        if ((v13 & 0x3FFFFFF) == 0) {
          return result;
        }
        int HeaderSizeInOutputBuffer = 0;
      }
      v10 += CompressedStateSize;
      uint64_t v11 = (v11 + 1);
      if (v8 == v11)
      {
        int v9 = v10 + 24;
        goto LABEL_19;
      }
    }
  }
  return result;
}

unint64_t __FSTCompact2_GetCompressedStateSize(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 40);
  uint64_t v2 = *(void *)(a1 + 56) + 16 * *(unsigned int *)(a1 + 48);
  unint64_t v3 = ((unint64_t)*(unsigned int *)(a1 + 8) >> 29) & 4;
  if (v1 != (unsigned int *)v2)
  {
    uint64_t v5 = &v1[4 * *(unsigned int *)(a1 + 32)];
    do
    {
      if (v1 == v5)
      {
        if (!*(_DWORD *)(a1 + 48)) {
          return v3;
        }
        uint64_t v1 = *(unsigned int **)(a1 + 56);
      }
      v3 += FSTCompactCodec_GetArcSize(v1);
      v1 += 4;
    }
    while (v1 != (unsigned int *)v2);
  }
  return v3;
}

unsigned char *__FSTCompact2_CompressState(uint64_t a1, unsigned char *a2)
{
  int v9 = a2;
  unint64_t v3 = *(unsigned int **)(a1 + 40);
  uint64_t v4 = *(unsigned int *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 56) + 16 * *(unsigned int *)(a1 + 48);
  if ((*(_DWORD *)(a1 + 8) & 0x80000000) != 0)
  {
    int v6 = *(_DWORD *)(a1 + 28);
    *a2 = HIBYTE(v6);
    a2[1] = BYTE2(v6);
    a2[2] = BYTE1(v6);
    a2[3] = v6;
    a2 += 4;
    int v9 = a2;
  }
  if (v3 != (unsigned int *)v5)
  {
    int v7 = &v3[4 * v4];
    do
    {
      if (v3 == v7)
      {
        if (!*(_DWORD *)(a1 + 48)) {
          return v9;
        }
        unint64_t v3 = *(unsigned int **)(a1 + 56);
      }
      FSTCompactCodec_EncodeArcInc(v3, &v9);
      v3 += 4;
    }
    while (v3 != (unsigned int *)v5);
    return v9;
  }
  return a2;
}

uint64_t FSTCompact2_Des(uint64_t *a1)
{
  if (a1[12])
  {
    if ((unint64_t)a1[16] >= 2)
    {
      unint64_t v2 = 1;
      do
        OOCAllocator_Free(a1[12], *(void *)(a1[15] + 8 * v2++));
      while (v2 < a1[16]);
    }
    uint64_t v3 = a1[15];
    if ((uint64_t *)v3 != a1 + 28) {
      OOCAllocator_Free(a1[12], v3);
    }
  }
  OOCAllocator_Free(a1[3], a1[17]);

  return FSTBaseFlat_Des((uint64_t)a1);
}

uint64_t FSTCompact2_AddState(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    uint64_t v4 = *(void *)(a1 + 208) - *(void *)(a1 + 192);
    uint64_t v5 = (unsigned char *)(*(void *)(a1 + 184) + (5 * *(_DWORD *)(a2 + 24)));
    unsigned char *v5 = *(unsigned char *)(a2 + 11) & 0xF0;
    v5[1] = BYTE3(v4);
    void v5[2] = BYTE2(v4);
    v5[3] = BYTE1(v4);
    v5[4] = v4;
    *(void *)(a1 + 208) = __FSTCompact2_CompressState(a2, *(unsigned char **)(a1 + 208));
  }
  else
  {
    *(_DWORD *)(a1 + 200) += __FSTCompact2_GetCompressedStateSize(a2);
    ++*(_DWORD *)(a1 + 216);
  }
  return 0;
}

double FSTCompact2_AddStateFinish(int8x8_t *a1, int a2)
{
  if (!a2)
  {
    uint64_t v20 = v2;
    uint64_t v21 = v3;
    uint64_t v5 = (uint64_t)a1[21];
    uint64_t v18 = 0;
    __int32 v6 = a1[27].i32[0];
    int HeaderSizeInOutputBuffer = FST_GetHeaderSizeInOutputBuffer(&v18);
    if (!HeaderSizeInOutputBuffer)
    {
      uint64_t v8 = (v18 + a1[25].i32[0] + 24);
      unint64_t v9 = v8 + (5 * v6 + 5);
      int v10 = (char *)OOCAllocator_Malloc(v5, v9, &HeaderSizeInOutputBuffer);
      a1[22] = (int8x8_t)v10;
      if (!HeaderSizeInOutputBuffer)
      {
        uint64_t v11 = (uint64_t)&v10[v18 + 24];
        a1[23] = (int8x8_t)&v10[v8];
        a1[24] = (int8x8_t)v11;
        a1[26] = (int8x8_t)v11;
        uint64_t v12 = *(void *)&vand_s8(a1[5], (int8x8_t)0x300000003) | 0x10000000100;
        a1[4] = (int8x8_t)0x200000028;
        a1[5] = (int8x8_t)v12;
        int HeaderSizeInOutputBuffer = FST_FillHeader(a1, v10, 3, &v18);
        if (!HeaderSizeInOutputBuffer)
        {
          int v13 = v18;
          uint64_t v14 = (__int32 *)(*(void *)&a1[22] + v18);
          __int32 v15 = a1[27].i32[1];
          v14[1] = 0;
          _OWORD v14[2] = 0;
          *uint64_t v14 = v15;
          _OWORD v14[3] = a1[27].i32[0];
          v14[4] = v8;
          v14[5] = v13 + 24;
          uint64_t v16 = *(void *)&a1[23] + (5 * a1[27].i32[0]);
          *(unsigned char *)uint64_t v16 = 0;
          *(_DWORD *)(v16 + 1) = bswap32(a1[25].u32[0]);
          unint64_t v17 = (const void **)OOCAllocator_Malloc(v5, 8, &HeaderSizeInOutputBuffer);
          if (!HeaderSizeInOutputBuffer)
          {
            *unint64_t v17 = (const void *)a1[22];
            return __FSTCompact2_InitFromBuffers((uint64_t)a1, v9, v9, v17, v5);
          }
        }
      }
    }
  }
  return result;
}

uint64_t FSTCompact2_FetchState(void *a1, int a2, unsigned int a3, uint64_t *a4)
{
  int v28 = 0;
  __FSTCompact2_GetStateOffsetAndFlags(a1, a2, &v24, &v28);
  int v8 = v28;
  if (!FST_CheckQuery(v28, a3))
  {
    uint64_t Info = 0;
    *a4 = 0;
    return Info;
  }
  unsigned int v26 = 0;
  uint64_t v27 = 0;
  uint64_t v25 = 0;
  uint64_t Info = __FSTCompact2_GetInfo(a1, a2, (char **)&v27, &v26);
  if (!Info)
  {
    int v10 = v27;
    if (v8 < 0)
    {
      int v10 = v27 + 1;
      unsigned int v11 = bswap32(*v27++);
    }
    else
    {
      unsigned int v11 = 0x7FFFFFFF;
    }
    uint64_t v12 = v26;
    *(void *)&long long v24 = v10;
    if (v10 == v26)
    {
      unsigned int v13 = 0;
      unsigned int v14 = 0;
    }
    else
    {
      unsigned int v13 = 0;
      unsigned int v14 = 0;
      do
      {
        int v15 = FSTCompactCodec_ScanEncodedArc((uint64_t *)&v24);
        if (v15) {
          unsigned int v16 = v14;
        }
        else {
          unsigned int v16 = v13;
        }
        if (v15) {
          unsigned int v14 = v16 + 1;
        }
        else {
          unsigned int v13 = v16 + 1;
        }
      }
      while ((unsigned int *)v24 != v12);
    }
    uint64_t Info = FSTStatePool_PopFSTState(a1[6], &v25);
    unsigned int v29 = Info;
    if (!Info)
    {
      uint64_t v17 = v25;
      *(_DWORD *)(v25 + 8) |= v8;
      *(_DWORD *)(v17 + 24) = a2;
      *(_DWORD *)(v17 + 28) = v11;
      if (v14)
      {
        uint64_t v18 = *(_OWORD **)(v17 + 40);
        if (!v18 || *((_DWORD *)v18 - 1) <= v14)
        {
          uint64_t v19 = _FSTState_ReserveEpsilonArcsInternal(v17, v14, &v29);
          uint64_t Info = v29;
          if (v29) {
            return Info;
          }
          uint64_t v18 = (_OWORD *)v19;
        }
        uint64_t v17 = v25;
        if (v13) {
          goto LABEL_25;
        }
      }
      else
      {
        uint64_t v18 = 0;
        if (v13)
        {
LABEL_25:
          uint64_t v20 = *(_OWORD **)(v17 + 56);
          if (!v20 || *((_DWORD *)v20 - 1) <= v13)
          {
            uint64_t v21 = _FSTState_ReserveArcsInternal(v17, v13, &v29);
            uint64_t Info = v29;
            if (v29) {
              return Info;
            }
            uint64_t v20 = (_OWORD *)v21;
          }
          uint64_t v17 = v25;
          goto LABEL_32;
        }
      }
      uint64_t v20 = 0;
LABEL_32:
      *(_DWORD *)(v17 + 32) = v14;
      *(_DWORD *)(v17 + 48) = v13;
      if (v10 != v12)
      {
        while (1)
        {
          long long v24 = 0uLL;
          FSTCompactCodec_DecodeArcInc((int *)&v24, &v27);
          if (v18)
          {
            if (DWORD1(v24) == -2) {
              break;
            }
          }
          if (v20)
          {
            int v22 = v20++;
            goto LABEL_38;
          }
LABEL_39:
          if (v27 == v12)
          {
            uint64_t v17 = v25;
            uint64_t Info = v29;
            goto LABEL_42;
          }
        }
        int v22 = v18++;
LABEL_38:
        *int v22 = v24;
        goto LABEL_39;
      }
      uint64_t Info = 0;
LABEL_42:
      *a4 = v17;
    }
  }
  return Info;
}

void *__FSTCompact2_GetStateOffsetAndFlags(void *result, int a2, void *a3, _DWORD *a4)
{
  __int32 v6 = result;
  unint64_t v7 = result[19] + (5 * a2);
  unint64_t v8 = result[14];
  unint64_t v9 = v7 / v8;
  unint64_t v10 = v7 % v8;
  if (v10 + 5 <= v8)
  {
    unsigned int v14 = (unsigned __int8 *)(*(void *)(result[15] + 8 * v9) + v10);
    int v12 = *v14;
    unsigned int v13 = *(_DWORD *)(v14 + 1);
  }
  else
  {
    unint64_t v11 = v8 - v10;
    cstdlib_memcpy(&__dst, (const void *)(*(void *)(result[15] + 8 * v9) + v10), v8 - v10);
    double result = cstdlib_memcpy(&__dst + v11, *(const void **)(v6[15] + 8 * v9 + 8), 5 - v11);
    int v12 = __dst;
    unsigned int v13 = v16;
  }
  *a3 = bswap32(v13);
  *a4 = v12 << 24;
  return result;
}

uint64_t __FSTCompact2_GetInfo(void *a1, int a2, char **a3, void *a4)
{
  unsigned int v22 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  __FSTCompact2_GetStateOffsetAndFlags(a1, a2, &v21, &v19);
  __FSTCompact2_GetStateOffsetAndFlags(a1, a2 + 1, &v20, &v19);
  uint64_t v8 = a1[20];
  unint64_t v9 = v8 + v21;
  unint64_t v10 = v20 + v8;
  unint64_t v11 = a1[14];
  unint64_t v12 = v9 / v11;
  unint64_t v13 = v20 - v21;
  unsigned int v14 = (char *)(*(void *)(a1[15] + 8 * (v9 / v11)) + v9 % v11);
  *a3 = v14;
  unint64_t v15 = v10 / v11;
  if (v9 / v11 == v10 / v11)
  {
    uint64_t result = 0;
  }
  else
  {
    if (v13 <= a1[18])
    {
      uint64_t v17 = (void *)a1[17];
    }
    else
    {
      a1[18] = v13;
      OOCAllocator_Free(a1[3], a1[17]);
      uint64_t v17 = (void *)OOCAllocator_Malloc(a1[3], v13, &v22);
      a1[17] = v17;
      uint64_t result = v22;
      if (v22) {
        return result;
      }
      unint64_t v11 = a1[14];
      unsigned int v14 = *a3;
    }
    size_t v18 = v11 + v11 * v12 - v9;
    cstdlib_memcpy(v17, v14, v18);
    if (v13 - v18 > a1[14]) {
      return err_GenerateErrorInternal();
    }
    cstdlib_memcpy((void *)(a1[17] + v18), *(const void **)(a1[15] + 8 * v15), v13 - v18);
    unsigned int v14 = (char *)a1[17];
    *a3 = v14;
    uint64_t result = v22;
  }
  *a4 = &v14[v13];
  return result;
}

uint64_t FSTCompact2_FillBuffer(uint64_t a1, char *a2, unint64_t *a3)
{
  uint64_t v6 = *(void *)(a1 + 80) - 16;
  uint64_t v16 = 0;
  uint64_t v17 = v6;
  uint64_t result = (uint64_t)FST_GetHeaderSizeInInputBuffer(**(const void ***)(a1 + 120), &v17);
  if (!result)
  {
    uint64_t result = FST_GetHeaderSizeInOutputBuffer(&v16);
    if (!result)
    {
      unint64_t v8 = *(void *)(a1 + 72) - v17 + v16;
      if (a2 && *a3 >= v8)
      {
        uint64_t result = FST_FillHeader((_DWORD *)a1, a2, *(_DWORD *)(a1 + 104), &v16);
        if (result) {
          return result;
        }
        unint64_t v9 = &a2[v16];
        unint64_t v10 = (const void *)(**(void **)(a1 + 120) + v17);
        if (*(void *)(a1 + 128) == 1)
        {
          size_t v11 = *(void *)(a1 + 72) - v17;
        }
        else
        {
          cstdlib_memcpy(v9, v10, *(void *)(a1 + 112) - v17);
          size_t v12 = *(void *)(a1 + 112);
          unint64_t v13 = &a2[v12 + v16 - v17];
          unint64_t v14 = *(void *)(a1 + 128) - 1;
          unint64_t v15 = 1;
          if (v14 >= 2)
          {
            do
            {
              cstdlib_memcpy(v13, *(const void **)(*(void *)(a1 + 120) + 8 * v15), v12);
              size_t v12 = *(void *)(a1 + 112);
              v13 += v12;
              ++v15;
              unint64_t v14 = *(void *)(a1 + 128) - 1;
            }
            while (v15 < v14);
          }
          unint64_t v10 = *(const void **)(*(void *)(a1 + 120) + 8 * v15);
          size_t v11 = *(void *)(a1 + 72) - v12 * v14;
          unint64_t v9 = v13;
        }
        cstdlib_memcpy(v9, v10, v11);
      }
      uint64_t result = 0;
      *a3 = v8;
    }
  }
  return result;
}

uint64_t FSTCompact2_GetFinalStateWeight(void *a1, int a2, unsigned int *a3)
{
  int v10 = 0;
  __FSTCompact2_GetStateOffsetAndFlags(a1, a2, &v9, &v10);
  if ((v10 & 0x80000000) == 0)
  {
    uint64_t result = 0;
    unsigned int v7 = 0x7FFFFFFF;
LABEL_3:
    *a3 = v7;
    return result;
  }
  unint64_t v9 = 0;
  uint64_t result = __FSTCompact2_GetInfo(a1, a2, &v9, &v8);
  if (!result)
  {
    unsigned int v7 = bswap32(*(_DWORD *)v9);
    goto LABEL_3;
  }
  return result;
}

uint64_t FSTCompact2_GetStateFlags(void *a1, int a2, _DWORD *a3)
{
  __FSTCompact2_GetStateOffsetAndFlags(a1, a2, &v4, a3);
  return 0;
}

uint64_t FSTCompact2_WriteBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 168);
  uint64_t v5 = *(void *)(a1 + 80) - 16;
  uint64_t v14 = 0;
  uint64_t v15 = v5;
  uint64_t result = (uint64_t)FST_GetHeaderSizeInInputBuffer(**(const void ***)(a1 + 120), &v15);
  if (!result)
  {
    uint64_t result = FST_GetHeaderSizeInOutputBuffer(&v14);
    unsigned int v16 = result;
    if (!result)
    {
      uint64_t v7 = v14;
      uint64_t v8 = (void *)OOCAllocator_Malloc(v4, v14, &v16);
      uint64_t result = v16;
      if (!v16)
      {
        uint64_t result = FST_FillHeader((_DWORD *)a1, v8, *(_DWORD *)(a1 + 104), &v14);
        unsigned int v16 = result;
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a2 + 8))(a2 - *(void *)(*(void *)a2 + 56), v8, v7);
          unsigned int v16 = result;
          if (!result)
          {
            OOCAllocator_Free(v4, (uint64_t)v8);
            unint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 8);
            uint64_t v10 = a2 - *(void *)(*(void *)a2 + 56);
            uint64_t v11 = **(void **)(a1 + 120) + v15;
            if (*(void *)(a1 + 128) == 1)
            {
              return v9(v10, v11, *(void *)(a1 + 72) - v15);
            }
            else
            {
              uint64_t result = v9(v10, v11, *(void *)(a1 + 112) - v15);
              unsigned int v16 = result;
              if (!result)
              {
                unint64_t v12 = *(void *)(a1 + 128) - 1;
                unint64_t v13 = 1;
                if (v12 < 2)
                {
                  return (*(uint64_t (**)(uint64_t, void, unint64_t))(*(void *)a2 + 8))(a2 - *(void *)(*(void *)a2 + 56), *(void *)(*(void *)(a1 + 120) + 8 * v13), *(void *)(a1 + 72) - *(void *)(a1 + 112) * v12);
                }
                else
                {
                  while (1)
                  {
                    uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(*(void *)a2 + 8))(a2 - *(void *)(*(void *)a2 + 56), *(void *)(*(void *)(a1 + 120) + 8 * v13), *(void *)(a1 + 112));
                    unsigned int v16 = result;
                    if (result) {
                      break;
                    }
                    ++v13;
                    unint64_t v12 = *(void *)(a1 + 128) - 1;
                    if (v13 >= v12) {
                      return (*(uint64_t (**)(uint64_t, void, unint64_t))(*(void *)a2 + 8))(a2 - *(void *)(*(void *)a2 + 56), *(void *)(*(void *)(a1 + 120) + 8 * v13), *(void *)(a1 + 72) - *(void *)(a1 + 112) * v12);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void PNEW_FSTCompact2_Con(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  int v16 = 0;
  uint64_t v14 = OOCAllocator_Malloc(a1, 232, &v16);
  if (!v16)
  {
    FSTCompact2_Con(v14, a2, a3, a4, a5, a6);
    int v16 = v15;
    if (v15)
    {
      OOCAllocator_Free(a1, v14);
      *a7 = 0;
    }
    else
    {
      *(void *)(v14 + 16) = a1;
      *a7 = v14;
    }
  }
}

void PNEW_FSTCompact2_ConFromBuffers(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, const void **a6, uint64_t a7, void *a8)
{
  int v18 = 0;
  int v16 = (void *)OOCAllocator_Malloc(a1, 232, &v18);
  if (!v18)
  {
    FSTCompact2_ConFromBuffers(v16, a2, a3, a4, a5, a6, a7);
    int v18 = v17;
    if (v17)
    {
      OOCAllocator_Free(a1, (uint64_t)v16);
      *a8 = 0;
    }
    else
    {
      _OWORD v16[2] = a1;
      *a8 = v16;
    }
  }
}

void PNEW_FSTCompact2_ConFromFST(uint64_t a1, uint64_t a2, uint64_t *a3, int8x8_t **a4)
{
  int v10 = 0;
  uint64_t v8 = (int8x8_t *)OOCAllocator_Malloc(a1, 232, &v10);
  if (!v10)
  {
    FSTCompact2_ConFromFST(v8, a2, a3);
    int v10 = v9;
    if (v9)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
    }
    else
    {
      v8[2] = (int8x8_t)a1;
      *a4 = v8;
    }
  }
}

void PNEW_FSTCompact2_ConForAddState(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 232, &v10);
  if (!v10)
  {
    FSTCompact2_ConForAddState(v8, a2, a3);
    int v10 = v9;
    if (v9)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
    }
    else
    {
      *(void *)(v8 + 16) = a1;
      *a4 = v8;
    }
  }
}

void *GetFSTCompact2Class()
{
  return &__FSTCompact2;
}

uint64_t FSTCount(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0;
  long long v6 = 0u;
  memset(v5, 0, sizeof(v5));
  uint64_t result = FSTCountDfsContext_Con(v5, a1, a2);
  if (!result)
  {
    uint64_t result = FSTDfsContext_Dfs((uint64_t)v5);
    if (!result)
    {
      *(_OWORD *)a3 = v6;
      *(void *)(a3 + 16) = v7;
      return (*(uint64_t (**)(_OWORD *))(*(void *)&v5[0] + 16))(v5);
    }
  }
  return result;
}

void FSTReplace_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unsigned int a5, void *a6)
{
  FST_Con((void *)a1, a2, *(void *)(a3 + 48));
  int v23 = v12;
  if (!v12)
  {
    *(void *)a1 = &__FSTReplace;
    int v13 = *(_DWORD *)(a3 + 36);
    *(_DWORD *)(a1 + 32) = 4;
    *(_DWORD *)(a1 + 36) = v13;
    *(_DWORD *)(a1 + 64) = a5;
    *(void *)(a1 + 72) = OOCAllocator_Malloc(a2, 16 * (a5 + 1), &v23);
    if (!v23)
    {
      (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
      uint64_t v14 = *(void **)(a1 + 72);
      *uint64_t v14 = a3;
      int v23 = (*(uint64_t (**)(uint64_t, void *))(*(void *)a3 + 72))(a3, v14 + 1);
      if (!v23)
      {
        if (a5)
        {
          uint64_t v15 = 0;
          uint64_t v16 = 16 * a5;
          do
          {
            if (*a6)
            {
              (*(void (**)(void))(*(void *)*a6 + 24))(*a6);
              uint64_t v17 = *a6;
            }
            else
            {
              uint64_t v17 = 0;
            }
            uint64_t v18 = *(void *)(a1 + 72);
            uint64_t v19 = v18 + v15;
            *(void *)(v19 + 16) = v17;
            *(_DWORD *)(v19 + 24) = -1;
            ++a6;
            v15 += 16;
          }
          while (v16 != v15);
        }
        else
        {
          uint64_t v18 = *(void *)(a1 + 72);
        }
        *(_DWORD *)(a1 + 80) = *(_DWORD *)(v18 + 8) + 1;
        *(_DWORD *)(a1 + 84) = a4;
        *(void *)(a1 + 144) = 0;
        *(_DWORD *)(a1 + 88) = 16;
        uint64_t v20 = OOCAllocator_Malloc(a2, 64, &v23);
        *(void *)(a1 + 96) = v20;
        if (!v23)
        {
          uint64_t v21 = *(unsigned int *)(a1 + 88);
          unint64_t v22 = v20 + 4 * v21;
          *(void *)(a1 + 104) = v22;
          if (v21)
          {
            if (v22 <= v20 + 4) {
              unint64_t v22 = v20 + 4;
            }
            memset((void *)v20, 255, ((v22 + ~v20) & 0xFFFFFFFFFFFFFFFCLL) + 4);
          }
          *(_DWORD *)(a1 + 112) = 0;
          *(void *)(a1 + 120) = 0;
          *(void *)(a1 + 128) = 0;
          *(_DWORD *)(a1 + 136) = -1;
          *(void *)(a1 + 152) = a2;
        }
      }
    }
  }
}

uint64_t FSTReplace_Des(uint64_t a1)
{
  if (*(void *)(a1 + 72))
  {
    unsigned int v2 = 0;
    while (1)
    {
      uint64_t v3 = *(void *)(*(void *)(a1 + 72) + 16 * v2);
      if (v3)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 32))(v3);
        if (result) {
          break;
        }
      }
      if (++v2 > *(_DWORD *)(a1 + 64))
      {
        OOCAllocator_Free(*(void *)(a1 + 152), *(void *)(a1 + 72));
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    uint64_t v5 = *(void *)(a1 + 96);
    if (v5) {
      OOCAllocator_Free(*(void *)(a1 + 152), v5);
    }
    uint64_t v6 = *(void *)(a1 + 120);
    if (v6) {
      OOCAllocator_Free(*(void *)(a1 + 152), v6);
    }
    return FST_Des(a1);
  }
  return result;
}

uint64_t FSTReplace_BorrowComponentFst(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 64) <= a2) {
    return 0;
  }
  else {
    return *(void *)(*(void *)(a1 + 72) + 16 * a2);
  }
}

uint64_t FSTReplace_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v5 = a3;
  int v6 = a2;
  unsigned int v93 = 0;
  uint64_t v92 = 0;
  if (a3) {
    a3 = 8;
  }
  else {
    a3 = a3;
  }
  uint64_t v8 = *(_DWORD **)(a1 + 72);
  if (v8[2] >= a2)
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)v8 + 120))(*(void *)v8, a2, a3, &v92);
    unsigned int v93 = result;
    if (result) {
      return result;
    }
    uint64_t v26 = v92;
    if (!v92)
    {
      uint64_t result = 0;
      goto LABEL_96;
    }
    if ((*(_DWORD *)(v92 + 8) & 0x3FFFFFE) != 0)
    {
      *(void *)&long long v87 = 0;
      uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), (uint64_t *)&v87);
      if (result) {
        return result;
      }
      uint64_t result = FSTState_Copy(v87, v92);
      if (result) {
        return result;
      }
      int v27 = *(_DWORD *)(v92 + 8);
      *(_DWORD *)(v92 + 8) = v27 - 1;
      int v28 = v27 & 0x3FFFFFF;
      uint64_t result = 9;
      int v29 = (v27 & 0x3FFFFFF) != 0 ? 0 : 9;
      unsigned int v93 = v29;
      if (!v28) {
        return result;
      }
      uint64_t v26 = v87;
      uint64_t v92 = v87;
    }
    uint64_t v30 = *(_OWORD **)(v26 + 56);
    uint64_t v31 = *(unsigned int *)(v26 + 48);
    if (v31)
    {
      unint64_t v86 = a4;
      unint64_t v32 = *(void *)(v26 + 56);
      unsigned int v33 = &v30[v31];
      do
      {
        unsigned int v34 = v30;
        *v30++ = *(_OWORD *)v32;
        int v35 = *(_DWORD *)(v32 + 4);
        int v36 = *(_DWORD *)(a1 + 84);
        BOOL v37 = __OFSUB__(v35, v36);
        int v38 = v35 - v36;
        if (v38 < 0 == v37)
        {
          uint64_t v39 = (v38 + 1);
          if (v39 <= *(_DWORD *)(a1 + 64))
          {
            int v40 = (void *)(*(void *)(a1 + 72) + 16 * v39);
            if (*v40)
            {
              uint64_t v88 = 0;
              long long v87 = 0uLL;
              unint64_t v89 = 0xFFFFFFFE00000000;
              int v41 = *(_DWORD *)(v32 + 12);
              int v90 = -2;
              int v91 = v41;
              DWORD1(v87) = v39;
              int v42 = *(_DWORD *)(a1 + 80);
              DWORD2(v87) = *(_DWORD *)v32;
              HIDWORD(v87) = v42;
              uint64_t result = (*(uint64_t (**)(void, uint64_t *))(*(void *)*v40 + 72))(*v40, &v88);
              unsigned int v93 = result;
              if (result) {
                return result;
              }
              LODWORD(v88) = v88 + HIDWORD(v87);
              unsigned int v43 = DWORD1(v87) + 2309 * DWORD2(v87);
              uint64_t v44 = *(_DWORD **)(a1 + 96);
              unint64_t v45 = *(void *)(a1 + 104) - (void)v44;
              unsigned int v46 = v44[v43 % (v45 >> 2)];
              if ((v46 & 0x80000000) != 0)
              {
LABEL_53:
                unsigned int v46 = *(_DWORD *)(a1 + 136);
                if (v46 == -1)
                {
                  uint64_t v51 = *(void *)(a1 + 120);
                  uint64_t v52 = *(void *)(a1 + 128);
                  uint64_t v53 = (v52 - v51) >> 2;
                  unsigned int v46 = -858993459 * v53;
                  unsigned int v54 = 2 * (v45 >> 2);
                  if (v54 >= -858993459 * (int)v53)
                  {
                    unsigned int v60 = -858993459 * v53;
                  }
                  else
                  {
                    unsigned int v55 = v54 | 1;
                    uint64_t v56 = *(unsigned int *)(a1 + 88);
                    if (v55 <= v56)
                    {
                      size_t v58 = 4 * v56;
                    }
                    else
                    {
                      if (v55 <= 8) {
                        unsigned int v57 = 8;
                      }
                      else {
                        unsigned int v57 = v55;
                      }
                      uint64_t v44 = (_DWORD *)OOCAllocator_Realloc(*(void *)(a1 + 152), *(void *)(a1 + 96), 4 * v57, &v93);
                      *(void *)(a1 + 96) = v44;
                      uint64_t result = v93;
                      if (v93) {
                        return result;
                      }
                      *(_DWORD *)(a1 + 88) = v57;
                      v45 &= 0x3FFFFFFFCuLL;
                      size_t v58 = 4 * v57;
                    }
                    unint64_t v61 = (v45 >> 1) & 0xFFFFFFFE | 1;
                    *(void *)(a1 + 104) = &v44[v61];
                    cstdlib_memset(v44, 255, v58);
                    uint64_t v51 = *(void *)(a1 + 120);
                    uint64_t v52 = *(void *)(a1 + 128);
                    unsigned int v60 = -858993459 * ((v52 - v51) >> 2);
                    if (v60)
                    {
                      uint64_t v62 = 0;
                      unsigned int v63 = *(_DWORD **)(a1 + 120);
                      do
                      {
                        if (((*v63 + 1) & 0x40000000) == 0)
                        {
                          uint64_t result = v93;
                          if (v93) {
                            return result;
                          }
                          unint64_t v64 = (v63[1] + 2309 * v63[2]);
                          uint64_t v65 = v64 - (v64 / v61) * (unint64_t)v61;
                          uint64_t v66 = *(void *)(a1 + 96);
                          *unsigned int v63 = *(_DWORD *)(v66 + 4 * v65);
                          *(_DWORD *)(v66 + 4 * v65) = v62;
                        }
                        ++v62;
                        v63 += 5;
                      }
                      while (-858993459 * ((v52 - v51) >> 2) != v62);
                      unsigned int v46 = -858993459 * ((v52 - v51) >> 2);
                    }
                    else
                    {
                      unsigned int v46 = 0;
                    }
                  }
                  unsigned int v67 = v46 + 1;
                  unsigned int v68 = *(_DWORD *)(a1 + 112);
                  if (v46 + 1 > v68)
                  {
                    unsigned int v85 = v60;
                    unsigned int v69 = 2 * v68;
                    unsigned int v70 = v68 + 1000000;
                    if (v69 >= v70) {
                      unsigned int v69 = v70;
                    }
                    if (v69 > v67) {
                      unsigned int v67 = v69;
                    }
                    if (v67 <= 8) {
                      unsigned int v71 = 8;
                    }
                    else {
                      unsigned int v71 = v67;
                    }
                    uint64_t v72 = OOCAllocator_Realloc(*(void *)(a1 + 152), v51, 20 * v71, &v93);
                    *(void *)(a1 + 120) = v72;
                    uint64_t result = v93;
                    if (v93) {
                      return result;
                    }
                    *(_DWORD *)(a1 + 112) = v71;
                    uint64_t v52 = v72 + 20 * v85;
                  }
                  *(void *)(a1 + 128) = v52 + 20;
                  long long v73 = v87;
                  *(_DWORD *)(v52 + 16) = v88;
                  *(_OWORD *)uint64_t v52 = v73;
                  unsigned int v48 = v46;
                }
                else
                {
                  unsigned int v48 = *(_DWORD *)(a1 + 136);
                  uint64_t v49 = (_DWORD *)(*(void *)(a1 + 120) + 20 * (int)v46);
                  *(_DWORD *)(a1 + 136) = (*v49 & 0xBFFFFFFF) - 1;
                  long long v50 = v87;
                  v49[4] = v88;
                  *(_OWORD *)uint64_t v49 = v50;
                }
                uint64_t v74 = *(void *)(a1 + 96);
                unsigned int v75 = v43 % ((unint64_t)(*(void *)(a1 + 104) - v74) >> 2);
                *(_DWORD *)(*(void *)(a1 + 120) + 20 * (int)v48) = *(_DWORD *)(v74 + 4 * v75);
                *(_DWORD *)(v74 + 4 * v75) = v46;
                int v59 = 1;
              }
              else
              {
                uint64_t v47 = *(void *)(a1 + 120);
                while (*(void *)((char *)&v87 + 4) != *(void *)(v47 + 20 * v46 + 4))
                {
                  unsigned int v46 = *(_DWORD *)(v47 + 20 * v46);
                  if ((v46 & 0x80000000) != 0) {
                    goto LABEL_53;
                  }
                }
                int v59 = 0;
              }
              *(void *)(a1 + 144) = 0;
              uint64_t v76 = *(void *)(*(void *)(a1 + 72) + 16 * v39);
              uint64_t result = (*(uint64_t (**)(uint64_t, char *))(*(void *)v76 + 48))(v76, (char *)&v88 + 4);
              unsigned int v93 = result;
              if (result) {
                return result;
              }
              LODWORD(v89) = HIDWORD(v88) + *(_DWORD *)(*(void *)(a1 + 120) + 20 * (int)v46 + 12);
              uint64_t result = FSTState_AddArcs(v92, 2, (uint64_t)&v89, 1u);
              unsigned int v93 = result;
              if (result) {
                return result;
              }
              if (v59)
              {
                uint64_t v77 = *(void *)(a1 + 72);
                uint64_t v78 = v77 + 16 * v39;
                int v81 = *(_DWORD *)(v78 + 8);
                uint64_t v79 = v78 + 8;
                int v80 = v81;
                if (v81 == -1)
                {
                  uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v77 + 16 * v39) + 72))(*(void *)(v77 + 16 * v39), v79);
                  unsigned int v93 = result;
                  if (result) {
                    return result;
                  }
                  int v80 = *(_DWORD *)(*(void *)(a1 + 72) + 16 * v39 + 8);
                }
                *(_DWORD *)(a1 + 80) += v80 + 1;
              }
              uint64_t v30 = v34;
            }
          }
        }
        v32 += 16;
      }
      while (v32 < (unint64_t)v33);
      uint64_t v26 = v92;
      uint64_t v82 = *(void *)(v92 + 56);
      a4 = v86;
    }
    else
    {
      uint64_t v82 = *(void *)(v26 + 56);
    }
    *(_DWORD *)(v26 + 48) = ((unint64_t)v30 - v82) >> 4;
    int v25 = *(_DWORD *)(v26 + 8);
  }
  else
  {
    int v9 = *(unsigned int **)(a1 + 144);
    if (!v9 || (unsigned int v10 = v9[3], v10 > a2) || v9[4] <= a2)
    {
      int v9 = *(unsigned int **)(a1 + 120);
      uint64_t v11 = *(unsigned int **)(a1 + 128);
      unint64_t v12 = (char *)v11 - (char *)v9;
      if ((char *)v11 - (char *)v9 >= 21)
      {
        do
        {
          int v13 = &v9[5 * (v12 / 0x28)];
          if (v13[3] > a2) {
            uint64_t v11 = v13;
          }
          else {
            int v9 = v13;
          }
          unint64_t v12 = (char *)v11 - (char *)v9;
        }
        while ((char *)v11 - (char *)v9 > 20);
      }
      *(void *)(a1 + 144) = v9;
      unsigned int v10 = v9[3];
    }
    uint64_t v14 = *(void *)&v8[4 * v9[1]];
    uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t *))(*(void *)v14 + 120))(v14, a2 - v10, a3, &v92);
    unsigned int v93 = result;
    if (result) {
      return result;
    }
    uint64_t result = v92;
    if (!v92) {
      goto LABEL_96;
    }
    if ((*(_DWORD *)(v92 + 8) & 0x3FFFFFE) != 0)
    {
      *(void *)&long long v87 = 0;
      uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), (uint64_t *)&v87);
      if (result) {
        return result;
      }
      uint64_t result = FSTState_Copy(v87, v92);
      if (result) {
        return result;
      }
      int v16 = *(_DWORD *)(v92 + 8);
      *(_DWORD *)(v92 + 8) = v16 - 1;
      int v17 = v16 & 0x3FFFFFF;
      uint64_t result = 9;
      int v18 = (v16 & 0x3FFFFFF) != 0 ? 0 : 9;
      unsigned int v93 = v18;
      if (!v17) {
        return result;
      }
      uint64_t result = v87;
      uint64_t v92 = v87;
    }
    *(_DWORD *)(result + 24) = v6;
    uint64_t v19 = *(_DWORD **)(result + 40);
    uint64_t v20 = *(_DWORD **)(result + 56);
    uint64_t v21 = *(unsigned int *)(result + 48);
    unint64_t v22 = &v20[4 * v21];
    if (v19 != v22)
    {
      int v23 = &v19[4 * *(unsigned int *)(result + 32)];
      do
      {
        if (v19 == v23 && !v21) {
          break;
        }
        if (v19 == v23) {
          uint64_t v19 = v20;
        }
        *v19 += *(_DWORD *)(*(void *)(a1 + 144) + 12);
        v19 += 4;
      }
      while (v19 != v22);
    }
    int v24 = *(_DWORD *)(result + 8);
    if (v24 < 0)
    {
      *(void *)((char *)&v87 + 4) = 0x100000001;
      HIDWORD(v87) = *(_DWORD *)(result + 28);
      LODWORD(v87) = *(_DWORD *)(*(void *)(a1 + 144) + 8);
      uint64_t result = FSTState_AddArcs(result, 2, (uint64_t)&v87, 1u);
      unsigned int v93 = result;
      if (result) {
        return result;
      }
      uint64_t result = v92;
      int v24 = *(_DWORD *)(v92 + 8);
    }
    int v25 = v24 & 0x7FFFFFFF;
    *(_DWORD *)(result + 8) = v25;
  }
  int v84 = FST_CheckQuery(v25 & 0xF0000000, v5);
  uint64_t v83 = v92;
  if (v84)
  {
    uint64_t result = v93;
    goto LABEL_103;
  }
  uint64_t result = FSTStatePool_PushFSTState(*(void *)(a1 + 48), v92);
  if (!result)
  {
LABEL_96:
    uint64_t v83 = 0;
LABEL_103:
    *a4 = v83;
  }
  return result;
}

uint64_t FSTReplace_GetFinalStateWeight(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  *a3 = 0;
  uint64_t v3 = *(_DWORD **)(a1 + 72);
  if (v3[2] >= a2) {
    return (*(uint64_t (**)(void))(**(void **)v3 + 64))(*(void *)v3);
  }
  else {
    return 0;
  }
}

uint64_t FSTReplace_GetInitialStateId(uint64_t a1)
{
  return (*(uint64_t (**)(void))(***(void ***)(a1 + 72) + 48))(**(void **)(a1 + 72));
}

uint64_t FSTReplace_GetMaxNbrComponentFsts(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t FSTReplace_GetMaxStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = -1;
  return 0;
}

uint64_t FSTReplace_GetMemoryInfo(uint64_t a1)
{
  unsigned int v2 = 0;
  uint64_t v3 = 0;
  unsigned int v4 = *(_DWORD *)(a1 + 64);
  uint64_t v5 = *(unsigned int *)(a1 + 88);
  unsigned int v6 = *(_DWORD *)(a1 + 112);
  unsigned int v7 = v4;
  do
  {
    uint64_t v8 = *(void *)(*(void *)(a1 + 72) + 16 * v2);
    if (v8)
    {
      uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 96))(v8);
      v3 += v10 + v9;
      unsigned int v7 = *(_DWORD *)(a1 + 64);
    }
    ++v2;
  }
  while (v2 <= v7);
  return 4 * v5 + 16 * (v4 + 1) + 20 * v6;
}

uint64_t FSTReplace_GetStateFlags(uint64_t a1, unsigned int a2, int *a3)
{
  *a3 = 0;
  uint64_t v5 = *(_DWORD **)(a1 + 72);
  if (v5[2] >= a2)
  {
    uint64_t v24 = 0;
    uint64_t result = (*(uint64_t (**)(void))(**(void **)v5 + 120))(*(void *)v5);
    if (!result)
    {
      uint64_t v13 = v24;
      if (v24)
      {
        unint64_t v14 = *(void *)(v24 + 56);
        uint64_t v15 = *(unsigned int *)(v24 + 48);
        unsigned int v16 = *(_DWORD *)(v24 + 8) & 0xF0000000;
        *a3 = v16;
        if (v15)
        {
          unint64_t v17 = v14 + 16 * v15;
          int v18 = *(_DWORD *)(a1 + 84);
          while (1)
          {
            int v19 = *(_DWORD *)(v14 + 4);
            BOOL v20 = __OFSUB__(v19, v18);
            int v21 = v19 - v18;
            if (v21 < 0 == v20 && (v21 + 1) <= *(_DWORD *)(a1 + 64)) {
              break;
            }
            v14 += 16;
            if (v14 >= v17) {
              goto LABEL_22;
            }
          }
          *a3 = v16 | 0x20000000;
        }
LABEL_22:
        int v22 = *(_DWORD *)(v13 + 8);
        if ((v22 & 0x3FFFFFF) == 1)
        {
          if ((v22 & 0x8000000) != 0) {
            uint64_t v23 = *(void *)(v13 + 16);
          }
          else {
            uint64_t v23 = 0;
          }
          return FSTStatePool_PushFSTState(v23, v13);
        }
        else
        {
          *(_DWORD *)(v13 + 8) = v22 - 1;
          if ((v22 & 0x3FFFFFF) != 0) {
            return 0;
          }
          else {
            return 9;
          }
        }
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 120);
    uint64_t v7 = *(void *)(a1 + 128);
    unint64_t v8 = v7 - v6;
    if (v7 - v6 >= 21)
    {
      do
      {
        uint64_t v9 = v6 + 20 * (v8 / 0x28);
        if (*(_DWORD *)(v9 + 12) > a2) {
          uint64_t v7 = v9;
        }
        else {
          uint64_t v6 = v9;
        }
        unint64_t v8 = v7 - v6;
      }
      while (v7 - v6 > 20);
    }
    uint64_t v10 = *(void *)&v5[4 * *(unsigned int *)(v6 + 4)];
    uint64_t result = (*(uint64_t (**)(uint64_t, void, int *))(*(void *)v10 + 56))(v10, a2 - *(_DWORD *)(v6 + 12), a3);
    if (!result)
    {
      int v12 = *a3;
      if (*a3 < 0) {
        int v12 = *a3 | 0x20000000;
      }
      *a3 = v12 & 0x7FFFFFFF;
    }
  }
  return result;
}

double FSTReplace_SetStatePool(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  unint64_t v5 = -1;
  while (1)
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 72) + v4);
    if (v6)
    {
      if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v6 + 128))(v6, a2)) {
        break;
      }
    }
    ++v5;
    v4 += 16;
    if (v5 >= *(unsigned int *)(a1 + 64))
    {
      return FST_SetStatePool(a1, a2);
    }
  }
  return result;
}

void PNEW_FSTReplace_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unsigned int a5, void *a6, uint64_t *a7)
{
  int v16 = 0;
  uint64_t v14 = OOCAllocator_Malloc(a1, 160, &v16);
  if (!v16)
  {
    FSTReplace_Con(v14, a2, a3, a4, a5, a6);
    int v16 = v15;
    if (v15)
    {
      OOCAllocator_Free(a1, v14);
      *a7 = 0;
    }
    else
    {
      *(void *)(v14 + 16) = a1;
      *a7 = v14;
    }
  }
}

void *GetFSTReplaceClass()
{
  return &__FSTReplace;
}

uint64_t FSTStateQueueSCC_Con(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14 = Object_Con((void *)a1);
  unsigned int v20 = v14;
  if (!v14)
  {
    *(void *)a1 = &__FSTStateQueueSCC;
    *(void *)(a1 + 8) = &unk_26D216A80;
    *(void *)(a1 + 16) = a2;
    *(void *)(a1 + 80) = a5;
    *(void *)(a1 + 88) = a6;
    *(void *)(a1 + 96) = a7;
    *(void *)(a1 + 48) = 0xFFFFFFFF00000000;
    *(_DWORD *)(a1 + 24) = a3;
    int v15 = (void *)OOCAllocator_Malloc(a2, 8 * a3, &v20);
    *(void *)(a1 + 32) = v15;
    uint64_t v14 = v20;
    if (!v20)
    {
      uint64_t v16 = *(unsigned int *)(a1 + 24);
      *(void *)(a1 + 40) = &v15[v16];
      if (v16)
      {
        do
          *v15++ = 0;
        while ((unint64_t)v15 < *(void *)(a1 + 40));
      }
      *(_DWORD *)(a1 + 56) = 0;
      *(void *)(a1 + 64) = 0;
      *(void *)(a1 + 72) = 0;
      if (a3)
      {
        for (uint64_t i = 0; a3 != i; ++i)
        {
          if (*(_DWORD *)(a4 + 4 * i) == 1)
          {
            uint64_t v21 = 0;
            uint64_t v18 = PNEW_FSTStateQueueFifo_Con(*(void *)(a1 + 16), *(void *)(a1 + 16), &v21);
            if (v18) {
              return v18;
            }
            *(void *)(*(void *)(a1 + 32) + 8 * i) = v21 + 8;
          }
          else
          {
            *(void *)(*(void *)(a1 + 32) + 8 * i) = 0;
          }
        }
      }
      return 0;
    }
  }
  return v14;
}

uint64_t FSTStateQueueSCC_Des(uint64_t *a1)
{
  uint64_t v2 = a1[12];
  if (v2) {
    OOCAllocator_Free(v2, a1[10]);
  }
  unint64_t v4 = a1[4];
  unint64_t v3 = a1[5];
  if (v4 < v3)
  {
    do
    {
      if (*(void *)v4)
      {
        uint64_t result = OOC_PlacementDeleteObject(a1[2], *(void *)v4 - *(void *)(**(void **)v4 + 48));
        if (result) {
          return result;
        }
        unint64_t v3 = a1[5];
      }
      v4 += 8;
    }
    while (v4 < v3);
    unint64_t v4 = a1[4];
  }
  if (v4) {
    OOCAllocator_Free(a1[2], v4);
  }
  uint64_t v6 = a1[8];
  if (v6) {
    OOCAllocator_Free(a1[2], v6);
  }

  return Object_Des();
}

double FSTStateQueueSCC_Clear(uint64_t a1)
{
  uint64_t v2 = *(int *)(a1 + 48);
  if ((int)v2 <= *(_DWORD *)(a1 + 52))
  {
    do
    {
      uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8 * v2);
      if (v3)
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 40))(v3 - *(void *)(*(void *)v3 + 48))) {
          return result;
        }
      }
      else
      {
        uint64_t v5 = *(void *)(a1 + 64);
        if (v2 < (int)((unint64_t)(*(void *)(a1 + 72) - v5) >> 2)) {
          *(_DWORD *)(v5 + 4 * *(int *)(a1 + 48)) = -1;
        }
      }
    }
    while (v2++ < *(int *)(a1 + 52));
  }
  double result = NAN;
  *(void *)(a1 + 48) = 0xFFFFFFFF00000000;
  return result;
}

uint64_t FSTStateQueueSCC_Dequeue(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 48);
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8 * v1);
  if (v2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 16))(v2 - *(void *)(*(void *)v2 + 48));
  }
  uint64_t v4 = *(void *)(a1 + 64);
  if ((int)v1 < (int)((unint64_t)(*(void *)(a1 + 72) - v4) >> 2)) {
    *(_DWORD *)(v4 + 4 * v1) = -1;
  }
  return 0;
}

uint64_t FSTStateQueueSCC_Enqueue(uint64_t a1, unsigned int a2)
{
  unsigned int v24 = 0;
  int v4 = *(_DWORD *)(a1 + 48);
  int v5 = *(_DWORD *)(a1 + 52);
  uint64_t v6 = *(void *)(a1 + 80);
  uint64_t v7 = a2;
  int v8 = *(_DWORD *)(v6 + 4 * a2);
  if (v4 > v5)
  {
    *(_DWORD *)(a1 + 48) = v8;
    int v8 = *(_DWORD *)(v6 + 4 * a2);
LABEL_4:
    *(_DWORD *)(a1 + 52) = v8;
    goto LABEL_5;
  }
  if (v8 > v5) {
    goto LABEL_4;
  }
  if (v8 < v4) {
    *(_DWORD *)(a1 + 48) = v8;
  }
LABEL_5:
  uint64_t v9 = *(int *)(v6 + 4 * a2);
  uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8 * v9);
  if (v10)
  {
    uint64_t v11 = *(uint64_t (**)(uint64_t))(*(void *)v10 + 8);
    uint64_t v12 = v10 - *(void *)(*(void *)v10 + 48);
    return v11(v12);
  }
  uint64_t v14 = (v9 + 1);
  uint64_t v15 = *(void *)(a1 + 64);
  unint64_t v16 = *(void *)(a1 + 72);
  unint64_t v17 = v16 - v15;
  if (v14 < ((v16 - v15) >> 2))
  {
LABEL_24:
    *(_DWORD *)(v15 + 4 * *(int *)(*(void *)(a1 + 80) + 4 * v7)) = a2;
    return v24;
  }
  unsigned int v18 = *(_DWORD *)(a1 + 56);
  if (v14 <= v18)
  {
LABEL_20:
    if (v16 < v15 + 4 * (unint64_t)v14)
    {
      unint64_t v22 = v15 + 4 * v14;
      if (v22 <= v16 + 4) {
        unint64_t v22 = v16 + 4;
      }
      size_t v23 = ((v22 + ~v16) & 0xFFFFFFFFFFFFFFFCLL) + 4;
      memset((void *)v16, 255, v23);
      *(void *)(a1 + 72) = v16 + v23;
    }
    goto LABEL_24;
  }
  unsigned int v19 = 2 * v18;
  unsigned int v20 = v18 + 1000000;
  if (v19 < v20) {
    unsigned int v20 = v19;
  }
  if (v20 <= v14) {
    unsigned int v20 = v14;
  }
  if (v20 <= 8) {
    unsigned int v21 = 8;
  }
  else {
    unsigned int v21 = v20;
  }
  uint64_t v15 = OOCAllocator_Realloc(*(void *)(a1 + 16), *(void *)(a1 + 64), 4 * v21, &v24);
  *(void *)(a1 + 64) = v15;
  uint64_t result = v24;
  if (!v24)
  {
    *(_DWORD *)(a1 + 56) = v21;
    unint64_t v16 = v15 + (v17 & 0x3FFFFFFFCLL);
    *(void *)(a1 + 72) = v16;
    goto LABEL_20;
  }
  return result;
}

uint64_t FSTStateQueueSCC_Head(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 48);
  if (v2 <= *(_DWORD *)(a1 + 52))
  {
    while (1)
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8 * v2);
      if (v4)
      {
        int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 32))(v4 - *(void *)(*(void *)v4 + 48));
        int v3 = *(_DWORD *)(a1 + 48);
        if (v5) {
          goto LABEL_10;
        }
        uint64_t v6 = v3;
        if (*(void *)(*(void *)(a1 + 32) + 8 * v3)) {
          goto LABEL_11;
        }
      }
      else
      {
        uint64_t v6 = v2;
        int v3 = v2;
      }
      uint64_t v7 = *(void *)(a1 + 64);
      if (v3 < (int)((unint64_t)(*(void *)(a1 + 72) - v7) >> 2) && *(_DWORD *)(v7 + 4 * v6) != -1) {
        goto LABEL_11;
      }
LABEL_10:
      int v2 = v3 + 1;
      *(_DWORD *)(a1 + 48) = v3 + 1;
      if (v3++ >= *(_DWORD *)(a1 + 52)) {
        goto LABEL_11;
      }
    }
  }
  int v3 = *(_DWORD *)(a1 + 48);
LABEL_11:
  uint64_t v9 = *(char **)(*(void *)(a1 + 32) + 8 * v3);
  if (!v9) {
    return *(unsigned int *)(*(void *)(a1 + 64) + 4 * v3);
  }
  uint64_t v10 = **(uint64_t (***)(int64_t))v9;
  int64_t v11 = (int64_t)&v9[-*(void *)(*(void *)v9 + 48)];

  return v10(v11);
}

uint64_t FSTStateQueueSCC_IsEmpty(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 52);
  uint64_t v2 = *(int *)(a1 + 48);
  if ((int)v2 < v1) {
    return 0;
  }
  if ((int)v2 > v1) {
    return 1;
  }
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8 * v2);
  if (v4) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 32))(v4 - *(void *)(*(void *)v4 + 48));
  }
  uint64_t v5 = *(void *)(a1 + 64);
  if ((int)v2 >= (int)((unint64_t)(*(void *)(a1 + 72) - v5) >> 2)) {
    return 1;
  }
  return *(_DWORD *)(v5 + 4 * v2) == -1;
}

uint64_t FSTStateQueueSCC_Update(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8 * *(int *)(*(void *)(a1 + 80) + 4 * a2));
  if (v2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24))(v2 - *(void *)(*(void *)v2 + 48));
  }
  else {
    return 0;
  }
}

uint64_t PNEW_FSTStateQueueSCC_Con(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  unsigned int v18 = 0;
  uint64_t v16 = OOCAllocator_Malloc(a1, 104, &v18);
  uint64_t result = v18;
  if (!v18)
  {
    uint64_t result = FSTStateQueueSCC_Con(v16, a2, a3, a4, a5, a6, a7);
    unsigned int v18 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v16);
      *a8 = 0;
      return v18;
    }
    else
    {
      *a8 = v16;
    }
  }
  return result;
}

void *GetFSTStateQueueSCCClass()
{
  return &__FSTStateQueueSCC;
}

uint64_t FSTCountDfsContext_Con(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = FSTDfsContext_Con((uint64_t)a1, a2, a3);
  if (!v4)
  {
    *a1 = &__FSTCountDfsContext;
    cstdlib_memset(a1 + 8, 0, 0x18uLL);
    a1[6] = 0x100000001;
  }
  return v4;
}

uint64_t FSTCountDfsContext_DiscoverState(_DWORD *a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 24);
  if (v2 > a1[16]) {
    a1[16] = v2;
  }
  ++a1[17];
  if ((*(_DWORD *)(a2 + 8) & 0x80000000) != 0) {
    ++a1[18];
  }
  return 0;
}

uint64_t FSTCountDfsContext_ExploreNonTreeArc(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a3 + 4) == -2) {
    ++a1[20];
  }
  if (*(_DWORD *)(a3 + 8) == -2) {
    ++a1[21];
  }
  return 0;
}

uint64_t FSTCountDfsContext_ExploreTreeArc(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a3 + 4) == -2) {
    ++a1[20];
  }
  if (*(_DWORD *)(a3 + 8) == -2) {
    ++a1[21];
  }
  return 0;
}

uint64_t PNEW_FSTCountDfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unsigned int v10 = 0;
  int v8 = (void *)OOCAllocator_Malloc(a1, 88, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = FSTCountDfsContext_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

void *GetFSTCountDfsContextClass()
{
  return &__FSTCountDfsContext;
}

uint64_t FSTState_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = Object_Con((void *)a1);
  if (!v6)
  {
    *(void *)a1 = &__FSTState;
    *(void *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    *(_DWORD *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
    if (a3)
    {
      (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
      int v7 = 134217729;
      a2 = a3;
    }
    else
    {
      int v7 = 1;
    }
    *(void *)(a1 + 16) = a2;
    *(_DWORD *)(a1 + 8) = v7;
  }
  return v6;
}

uint64_t FSTState_Des(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 11) & 8) != 0)
  {
    int v3 = *(uint64_t **)(a1 + 16);
    uint64_t v2 = *(void *)(a1 + 40);
    if (!v2) {
      goto LABEL_8;
    }
    uint64_t v4 = v3 + 3;
    goto LABEL_6;
  }
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    int v3 = 0;
    uint64_t v4 = (uint64_t *)(a1 + 16);
LABEL_6:
    OOCAllocator_Free(*v4, v2 - 4);
    goto LABEL_8;
  }
  int v3 = 0;
LABEL_8:
  uint64_t v5 = *(void *)(a1 + 56);
  if (v5)
  {
    uint64_t v6 = (uint64_t *)(a1 + 16);
    if ((*(unsigned char *)(a1 + 11) & 8) != 0) {
      uint64_t v6 = (uint64_t *)(*v6 + 24);
    }
    OOCAllocator_Free(*v6, v5 - 4);
  }
  if (!v3 || (uint64_t result = (*(uint64_t (**)(uint64_t *))(*v3 + 32))(v3), !result))
  {
    return Object_Des();
  }
  return result;
}

uint64_t FSTState_AddArcs(uint64_t a1, int a2, uint64_t a3, unsigned int a4)
{
  uint64_t v5 = (long long *)a3;
  unsigned int v38 = 0;
  if (a2 == 2)
  {
    unsigned int v10 = *(_DWORD *)(a1 + 32);
    uint64_t v11 = *(void *)(a1 + 40);
    if (v11)
    {
      unsigned int v12 = v10 + a4;
      if (*(_DWORD *)(v11 - 4) > v10 + a4)
      {
LABEL_25:
        *(_DWORD *)(a1 + 32) = v10 + a4;
        if (a4)
        {
          uint64_t v26 = a4;
          do
          {
            long long v27 = *v5++;
            *(_OWORD *)(*(void *)(a1 + 40) + 16 * v10++) = v27;
            --v26;
          }
          while (v26);
        }
        goto LABEL_46;
      }
    }
    else
    {
      unsigned int v12 = v10 + a4;
    }
    uint64_t v25 = _FSTState_ReserveEpsilonArcsInternal(a1, v12, &v38);
    uint64_t v23 = v38;
    *(void *)(a1 + 40) = v25;
    if (v23) {
      return v23;
    }
    goto LABEL_25;
  }
  if (a2 == 4)
  {
    unsigned int v7 = *(_DWORD *)(a1 + 48);
    uint64_t v8 = *(void *)(a1 + 56);
    if (v8)
    {
      unsigned int v9 = v7 + a4;
      if (*(_DWORD *)(v8 - 4) > v7 + a4)
      {
LABEL_19:
        *(_DWORD *)(a1 + 48) = v7 + a4;
        if (!a4) {
          return 0;
        }
        uint64_t v23 = a4;
        do
        {
          long long v24 = *v5++;
          *(_OWORD *)(*(void *)(a1 + 56) + 16 * v7++) = v24;
          --v23;
        }
        while (v23);
        return v23;
      }
    }
    else
    {
      unsigned int v9 = v7 + a4;
    }
    uint64_t v22 = _FSTState_ReserveArcsInternal(a1, v9, &v38);
    uint64_t v23 = v38;
    *(void *)(a1 + 56) = v22;
    if (v23) {
      return v23;
    }
    goto LABEL_19;
  }
  uint64_t v13 = *(unsigned int *)(a1 + 48);
  int v14 = 0;
  if (a4)
  {
    uint64_t v15 = a4;
    uint64_t v16 = (int *)(a3 + 4);
    do
    {
      int v17 = *v16;
      v16 += 4;
      if (v17 == -2) {
        ++v14;
      }
      --v15;
    }
    while (v15);
  }
  uint64_t v18 = *(unsigned int *)(a1 + 32);
  int v19 = a4 - v14;
  uint64_t v20 = *(void *)(a1 + 56);
  if (v20)
  {
    unsigned int v21 = v19 + v13;
    if (*(_DWORD *)(v20 - 4) > (v19 + v13)) {
      goto LABEL_32;
    }
  }
  else
  {
    unsigned int v21 = v19 + v13;
  }
  uint64_t v28 = _FSTState_ReserveArcsInternal(a1, v21, &v38);
  uint64_t v23 = v38;
  if (v38) {
    return v23;
  }
  uint64_t v20 = v28;
LABEL_32:
  uint64_t v29 = *(void *)(a1 + 40);
  int v30 = *(_DWORD *)(a1 + 32);
  if (v29)
  {
    unsigned int v31 = v30 + v14;
    if (*(_DWORD *)(v29 - 4) > (v30 + v14)) {
      goto LABEL_38;
    }
  }
  else
  {
    unsigned int v31 = v30 + v14;
  }
  uint64_t v29 = _FSTState_ReserveEpsilonArcsInternal(a1, v31, &v38);
  uint64_t v23 = v38;
  if (v38) {
    return v23;
  }
LABEL_38:
  uint64_t v23 = (v14 + v18);
  *(_DWORD *)(a1 + 32) = v23;
  *(_DWORD *)(a1 + 48) = v19 + v13;
  if (a4)
  {
    unint64_t v32 = (_OWORD *)(v20 + 16 * v13);
    unsigned int v33 = (_OWORD *)(v29 + 16 * v18);
    unsigned int v34 = (_DWORD *)v5 + 1;
    uint64_t v35 = a4;
    do
    {
      if (*v34 == -2) {
        int v36 = v33;
      }
      else {
        int v36 = v32;
      }
      v33 += *v34 == -2;
      v32 += *v34 != -2;
      *int v36 = *(_OWORD *)(v34 - 1);
      v34 += 4;
      --v35;
    }
    while (v35);
    uint64_t v23 = *(unsigned int *)(a1 + 32);
  }
  if (v23)
  {
LABEL_46:
    uint64_t v23 = 0;
    *(_DWORD *)(a1 + 8) |= 0x20000000u;
  }
  return v23;
}

uint64_t _FSTState_ReserveArcsInternal(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  int v13 = 0;
  uint64_t v6 = *(void *)(a1 + 56);
  if (v6) {
    uint64_t v7 = v6 - 4;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v6 && *(_DWORD *)(v6 - 4) >= a2)
  {
    int v11 = 0;
  }
  else
  {
    uint64_t v8 = (uint64_t *)(a1 + 16);
    if ((*(unsigned char *)(a1 + 11) & 8) != 0) {
      uint64_t v8 = (uint64_t *)(*v8 + 24);
    }
    uint64_t v9 = a2 + 5;
    unsigned int v10 = (_DWORD *)OOCAllocator_Realloc(*v8, v7, (16 * v9) | 4, &v13);
    int v11 = v13;
    if (!v13)
    {
      *unsigned int v10 = v9;
      *(void *)(a1 + 56) = v10 + 1;
      int v11 = v13;
    }
  }
  *a3 = v11;
  return *(void *)(a1 + 56);
}

uint64_t _FSTState_ReserveEpsilonArcsInternal(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  int v13 = 0;
  uint64_t v6 = *(void *)(a1 + 40);
  if (v6) {
    uint64_t v7 = v6 - 4;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v6 && *(_DWORD *)(v6 - 4) >= a2)
  {
    int v11 = 0;
  }
  else
  {
    uint64_t v8 = (uint64_t *)(a1 + 16);
    if ((*(unsigned char *)(a1 + 11) & 8) != 0) {
      uint64_t v8 = (uint64_t *)(*v8 + 24);
    }
    uint64_t v9 = a2 + 5;
    unsigned int v10 = (_DWORD *)OOCAllocator_Realloc(*v8, v7, (16 * v9) | 4, &v13);
    int v11 = v13;
    if (!v13)
    {
      *unsigned int v10 = v9;
      *(void *)(a1 + 40) = v10 + 1;
      int v11 = v13;
    }
  }
  *a3 = v11;
  return *(void *)(a1 + 40);
}

uint64_t FSTState_Clean(uint64_t result)
{
  *(void *)(result + 24) = 0;
  *(_DWORD *)(result + 32) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 8) &= 0xFFFFFFFu;
  return result;
}

uint64_t FSTState_Copy(uint64_t a1, uint64_t a2)
{
  unsigned int v11 = 0;
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  int v4 = *(_DWORD *)(a1 + 8) & 0x8000000 | 1;
  *(_DWORD *)(a1 + 8) = v4;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8) & 0xF0000000 | v4;
  unsigned int v5 = *(_DWORD *)(a2 + 48);
  if (v5)
  {
    uint64_t v6 = *(_DWORD **)(a1 + 56);
    if (!v6 || *(v6 - 1) <= v5)
    {
      uint64_t v6 = (_DWORD *)_FSTState_ReserveArcsInternal(a1, v5, &v11);
      uint64_t v7 = v11;
      *(void *)(a1 + 56) = v6;
      if (v7) {
        return v7;
      }
    }
    cstdlib_memcpy(v6, *(const void **)(a2 + 56), 16 * *(unsigned int *)(a2 + 48));
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  }
  unsigned int v8 = *(_DWORD *)(a2 + 32);
  if (!v8) {
    return 0;
  }
  uint64_t v9 = *(void **)(a1 + 40);
  if (v9 && *((_DWORD *)v9 - 1) > v8
    || (uint64_t v9 = (void *)_FSTState_ReserveEpsilonArcsInternal(a1, v8, &v11), v7 = v11,
                                                                         *(void *)(a1 + 40) = v9,
                                                                         !v7))
  {
    cstdlib_memcpy(v9, *(const void **)(a2 + 40), 16 * *(unsigned int *)(a2 + 32));
    uint64_t v7 = 0;
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  }
  return v7;
}

uint64_t FSTState_FetchSortedArcs(uint64_t a1, uint64_t (*a2)(unsigned char *, unsigned char *), char **a3, unsigned int *a4)
{
  unsigned int v15 = 0;
  uint64_t v4 = *(unsigned int *)(a1 + 32);
  uint64_t v5 = *(unsigned int *)(a1 + 48);
  uint64_t v6 = *(const void **)(a1 + 40);
  uint64_t v7 = *(const void **)(a1 + 56);
  *a3 = 0;
  uint64_t v8 = (v5 + v4);
  *a4 = v8;
  if (v5 + v4)
  {
    unsigned int v12 = (uint64_t *)(a1 + 16);
    if ((*(unsigned char *)(a1 + 11) & 8) != 0) {
      unsigned int v12 = (uint64_t *)(*v12 + 24);
    }
    int v13 = (char *)OOCAllocator_Malloc(*v12, 16 * (v5 + v4), &v15);
    *a3 = v13;
    uint64_t v8 = v15;
    if (!v15)
    {
      if (v6)
      {
        cstdlib_memcpy(v13, v6, 16 * v4);
        int v13 = *a3;
      }
      if (v7)
      {
        cstdlib_memcpy(&v13[16 * v4], v7, 16 * v5);
        int v13 = *a3;
      }
      lhstdlib_qsort((uint64_t)v13, *a4, 0x10u, a2);
      return v15;
    }
  }
  return v8;
}

uint64_t FSTState_RemoveArcs(uint64_t a1, int a2, uint64_t a3, int a4)
{
  unsigned int v25 = 0;
  if (!a3 || !a4) {
    return v25;
  }
  uint64_t v7 = 56;
  if (a2 == 2) {
    uint64_t v7 = 40;
  }
  uint64_t v8 = 48;
  if (a2 == 2) {
    uint64_t v8 = 32;
  }
  uint64_t v9 = *(unsigned int *)(a1 + v8);
  unsigned int v10 = *(_OWORD **)(a1 + v7);
  uint64_t v11 = (v9 - a4);
  if (v9 == a4)
  {
    unsigned int v12 = 0;
LABEL_9:
    int v13 = (uint64_t *)(a1 + 16);
    if ((*(unsigned char *)(a1 + 11) & 8) != 0) {
      int v13 = (uint64_t *)(*v13 + 24);
    }
    OOCAllocator_Free(*v13, (uint64_t)v10 - 4);
    if (a2 == 2)
    {
      *(_DWORD *)(a1 + 32) = v11;
      *(void *)(a1 + 40) = v12;
      if (v9 == a4) {
        *(_DWORD *)(a1 + 8) &= ~0x20000000u;
      }
    }
    else if (a2 == 4)
    {
      *(_DWORD *)(a1 + 48) = v11;
      *(void *)(a1 + 56) = v12;
    }
    return v25;
  }
  unsigned int v15 = (uint64_t *)(a1 + 16);
  if ((*(unsigned char *)(a1 + 11) & 8) != 0) {
    unsigned int v15 = (uint64_t *)(*v15 + 24);
  }
  uint64_t v16 = (_DWORD *)OOCAllocator_Malloc(*v15, (16 * v11) | 4, &v25);
  if (!v25)
  {
    uint64_t v17 = 0;
    _DWORD *v16 = v11;
    unsigned int v12 = v16 + 1;
    uint64_t v18 = v10;
    int v19 = v16 + 1;
    do
    {
      unint64_t v20 = (unint64_t)&v10[*(unsigned int *)(a3 + 4 * v17)];
      if ((unint64_t)v18 >= v20)
      {
        uint64_t v22 = v18;
      }
      else
      {
        unsigned int v21 = v19;
        do
        {
          int v19 = v21 + 1;
          uint64_t v22 = v18 + 1;
          *unsigned int v21 = *v18;
          uint64_t v18 = v22;
          ++v21;
        }
        while ((unint64_t)v22 < v20);
      }
      uint64_t v18 = v22 + 1;
      ++v17;
    }
    while (v17 != a4);
    for (unint64_t i = (unint64_t)&v10[v9]; (unint64_t)v18 < i; ++v18)
      *v19++ = *v18;
    goto LABEL_9;
  }
  return v25;
}

uint64_t PNEW_FSTState_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 64, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = FSTState_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

void *GetFSTStateClass()
{
  return &__FSTState;
}

void FSTFlat_Con(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, const void *a5, uint64_t a6)
{
  _FSTBaseFlat_Con((void *)a1, a2, a3, a4, a5, a6, 3u);
  if (!v7)
  {
    *(void *)a1 = &__FSTFlat;
    if (*(_DWORD *)(a1 + 32) == 2)
    {
      uint64_t v9 = *(void *)(a1 + 80);
      uint64_t v8 = *(void *)(a1 + 88);
      uint64_t v10 = v8 + v9;
      int v11 = *(_DWORD *)(a1 + 104);
      if (v11 == 2)
      {
        uint64_t v8 = v10 + 4 * (*(_DWORD *)(a1 + 64) + 1);
      }
      else if (v11 != 1)
      {
        uint64_t v12 = *(unsigned int *)(v8 + v9 + 4);
        uint64_t v13 = v8 + *(unsigned int *)(v8 + v9);
        v8 += v12;
        *(void *)(a1 + 112) = v13;
        goto LABEL_12;
      }
      *(void *)(a1 + 112) = v10;
LABEL_12:
      *(void *)(a1 + 120) = v8;
      return;
    }
    err_GenerateErrorData();
  }
}

double FSTFlat_ConFromFST(int8x8_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = 0;
  unint64_t v10 = 0;
  if (!_FSTFlat_WriteBufferV2(a2, (_DWORD *)a3, &v9, (uint64_t *)&v10))
  {
    FSTFlat_Con((uint64_t)a1, a2, *(void *)(a3 + 48), v10, v9, a2);
    if (!v7)
    {
      v8.i32[0] = *(_DWORD *)(a3 + 44) & 0x3FFFF & *(_DWORD *)(a3 + 40);
      v8.i32[1] = *(_DWORD *)(a3 + 44) & 0x3FFFF;
      *(void *)&double result = *(void *)&vorr_s8(vand_s8(a1[5], (int8x8_t)0x300000003), v8) | 0x10000000100;
      *(double *)&a1[5] = result;
    }
  }
  return result;
}

uint64_t _FSTFlat_WriteBufferV2(uint64_t a1, _DWORD *a2, void *a3, uint64_t *a4)
{
  uint64_t v46 = 0;
  unsigned int v45 = -1;
  uint64_t v44 = 0;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v39 = 0u;
  uint64_t result = FSTCountDfsContext_Con(&v39, a1, (uint64_t)a2);
  if (!result)
  {
    uint64_t result = FSTDfsContext_Dfs((uint64_t)&v39);
    if (!result)
    {
      unsigned int v9 = v43;
      uint64_t v10 = DWORD2(v43);
      uint64_t v11 = HIDWORD(v43);
      uint64_t result = FST_GetHeaderSizeInOutputBuffer(&v46);
      v47[0] = result;
      if (!result)
      {
        uint64_t v12 = v46 + 16;
        uint64_t v13 = 16 * (v11 + v10) + 4 * (v9 + 2) + v46 + 16;
        int v14 = (char *)OOCAllocator_Malloc(a1, v13, v47);
        uint64_t result = v47[0];
        if (!v47[0])
        {
          cstdlib_memset(v14, 0, v13);
          int v15 = a2[8];
          a2[8] = 2;
          uint64_t result = FST_FillHeader(a2, v14, 2, &v46);
          v47[0] = result;
          if (!result)
          {
            a2[8] = v15;
            uint64_t result = (*(uint64_t (**)(_DWORD *, unsigned int *))(*(void *)a2 + 48))(a2, &v45);
            v47[0] = result;
            if (!result)
            {
              unsigned int v16 = 0;
              uint64_t v35 = v13;
              int v36 = &v14[v12];
              uint64_t v17 = (uint64_t)&v14[4 * v9 + 8 + v12];
              uint64_t v18 = &v14[v46];
              *(void *)uint64_t v18 = v45;
              *((_DWORD *)v18 + 2) = 0;
              *((_DWORD *)v18 + 3) = v9 + 1;
              uint64_t v19 = v17;
              int v33 = v17;
              unsigned int v34 = v14;
              do
              {
                unsigned int v20 = (v19 - v17) >> 4;
                uint64_t v38 = 0;
                uint64_t v21 = v16;
                if (*(unsigned char *)(*((void *)&v40 + 1) + v16))
                {
                  uint64_t result = (*(uint64_t (**)(_DWORD *, void, uint64_t, uint64_t *))(*(void *)a2 + 120))(a2, v16, 8, &v38);
                  v47[0] = result;
                  if (result) {
                    return result;
                  }
                  uint64_t v22 = v38;
                  if (v38)
                  {
                    uint64_t v23 = *(char **)(v38 + 40);
                    uint64_t v24 = *(unsigned int *)(v38 + 32);
                    uint64_t v25 = *(void *)(v38 + 56);
                    uint64_t v26 = *(unsigned int *)(v38 + 48);
                    int v27 = *(_DWORD *)(v38 + 8);
                    *(_DWORD *)&v36[4 * v21] = v27 & 0xF0000000 | v20;
                    if (v27 < 0)
                    {
                      int __src = *(_DWORD *)(v22 + 28);
                      uint64_t v28 = v24;
                      cstdlib_memcpy((void *)v19, &__src, 4uLL);
                      cstdlib_memset((void *)(v19 + 4), 0, 0xCuLL);
                      uint64_t v24 = v28;
                      v19 += 16;
                    }
                    uint64_t v29 = (char *)(v25 + 16 * v26);
                    if (v23 == v29)
                    {
                      LODWORD(v17) = v33;
                    }
                    else
                    {
                      int v30 = &v23[16 * v24];
                      LODWORD(v17) = v33;
                      do
                      {
                        if (v23 == v30)
                        {
                          if (!*(_DWORD *)(v38 + 48)) {
                            break;
                          }
                          uint64_t v23 = *(char **)(v38 + 56);
                        }
                        cstdlib_memcpy((void *)v19, v23, 0x10uLL);
                        v19 += 16;
                        v23 += 16;
                      }
                      while (v23 != v29);
                    }
                    int v31 = *(_DWORD *)(v38 + 8);
                    if ((v31 & 0x3FFFFFF) == 1)
                    {
                      int v14 = v34;
                      uint64_t v13 = v35;
                      if ((v31 & 0x8000000) != 0) {
                        uint64_t v32 = *(void *)(v38 + 16);
                      }
                      else {
                        uint64_t v32 = 0;
                      }
                      uint64_t result = FSTStatePool_PushFSTState(v32, v38);
                      v47[0] = result;
                      if (result) {
                        return result;
                      }
                    }
                    else
                    {
                      *(_DWORD *)(v38 + 8) = v31 - 1;
                      int v14 = v34;
                      uint64_t v13 = v35;
                      if ((v31 & 0x3FFFFFF) == 0) {
                        return 9;
                      }
                      v47[0] = 0;
                    }
                  }
                }
                else
                {
                  *(_DWORD *)&v36[4 * v16] = v20;
                }
                unsigned int v16 = v21 + 1;
              }
              while ((int)v21 + 1 <= v9);
              *(_DWORD *)&v36[4 * v16] = (v19 - v17) >> 4;
              uint64_t result = (*(uint64_t (**)(long long *))(v39 + 16))(&v39);
              if (!result)
              {
                *a3 = v14;
                *a4 = v13;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t FSTFlat_FetchState(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t *a4)
{
  unsigned int v39 = 0;
  if (*(_DWORD *)(a1 + 64) <= a2)
  {
    return err_GenerateErrorData();
  }
  int v7 = *(_DWORD *)(*(void *)(a1 + 112) + 4 * a2);
  unsigned int v8 = v7 & 0xF0000000;
  uint64_t result = FST_CheckQuery(v7 & 0xF0000000, a3);
  if (!result)
  {
    *a4 = 0;
    return result;
  }
  uint64_t v38 = 0;
  if (v7 < 0)
  {
    uint64_t v10 = *(void *)(a1 + 112);
    uint64_t v12 = *(void *)(a1 + 120);
    uint64_t v13 = *(_DWORD *)(v10 + 4 * a2) & 0xFFFFFFF;
    int v14 = (int *)(v12 + v13);
    int v15 = (int *)(v12 + 16 * v13);
    if (*(_DWORD *)(a1 + 104) == 1) {
      unsigned int v16 = v14;
    }
    else {
      unsigned int v16 = v15;
    }
    int v11 = *v16;
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 112);
    int v11 = 0x7FFFFFFF;
  }
  uint64_t v17 = (int *)(v10 + 4 * a2);
  int v18 = *v17;
  uint64_t v19 = v17[1] & 0xFFFFFFF;
  if (v18 < 0)
  {
    int v21 = v18 & 0xFFFFFFF;
    if (*(_DWORD *)(a1 + 104) == 1) {
      unsigned int v20 = v21 + 4;
    }
    else {
      unsigned int v20 = v21 + 1;
    }
  }
  else
  {
    unsigned int v20 = v18 & 0xFFFFFFF;
  }
  if (v20 > v19) {
    return err_GenerateErrorInternal();
  }
  if (v20 >= v19)
  {
    char v32 = 0;
    uint64_t v28 = 0;
  }
  else
  {
    int v22 = *(_DWORD *)(a1 + 104);
    uint64_t v23 = *(void *)(a1 + 120);
    uint64_t v24 = (char *)(v23 + 16 * v20);
    unint64_t v25 = v23 + 16 * v19;
    uint64_t v26 = (char *)(v23 + v20);
    unint64_t v27 = v23 + v19;
    if (v22 == 1) {
      uint64_t v28 = v26;
    }
    else {
      uint64_t v28 = v24;
    }
    if (v22 != 1) {
      unint64_t v27 = v25;
    }
    if (v28)
    {
      uint64_t v29 = v28;
      if ((unint64_t)v28 < v27)
      {
        uint64_t v29 = v28;
        do
        {
          if (*((_DWORD *)v29 + 1) != -2) {
            break;
          }
          v29 += 16;
        }
        while ((unint64_t)v29 < v27);
      }
      unint64_t v30 = (v27 - (unint64_t)v29) >> 4;
      unint64_t v31 = (unint64_t)(v29 - v28) >> 4;
      char v32 = 1;
      goto LABEL_35;
    }
    char v32 = 0;
  }
  LODWORD(v30) = 0;
  LODWORD(v31) = 0;
LABEL_35:
  uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), (uint64_t *)&v38);
  unsigned int v39 = result;
  if (result) {
    return result;
  }
  uint64_t v33 = (uint64_t)v38;
  v38[2] |= v8;
  *(_DWORD *)(v33 + 24) = a2;
  *(_DWORD *)(v33 + 28) = v11;
  if (v31) {
    char v34 = v32 ^ 1;
  }
  else {
    char v34 = 1;
  }
  if ((v34 & 1) == 0)
  {
    uint64_t v35 = *(_DWORD **)(v33 + 40);
    if (!v35 || *(v35 - 1) <= v31)
    {
      uint64_t v35 = (_DWORD *)_FSTState_ReserveEpsilonArcsInternal(v33, v31, &v39);
      uint64_t result = v39;
      if (v39) {
        return result;
      }
    }
    cstdlib_memcpy(v35, v28, 16 * v31);
    uint64_t v33 = (uint64_t)v38;
    v38[8] = v31;
  }
  if (v30) {
    char v36 = v32 ^ 1;
  }
  else {
    char v36 = 1;
  }
  if (v36) {
    goto LABEL_53;
  }
  BOOL v37 = *(_DWORD **)(v33 + 56);
  if (!v37 || *(v37 - 1) <= v30) {
    BOOL v37 = (_DWORD *)_FSTState_ReserveArcsInternal(v33, v30, &v39);
  }
  uint64_t result = v39;
  if (!v39)
  {
    cstdlib_memcpy(v37, &v28[16 * v31], 16 * v30);
    uint64_t v33 = (uint64_t)v38;
    v38[12] = v30;
LABEL_53:
    *a4 = v33;
    return v39;
  }
  return result;
}

uint64_t FSTFlat_FillBuffer(uint64_t a1, char *a2, unint64_t *a3)
{
  uint64_t v10 = 0;
  uint64_t v6 = *(void *)(a1 + 80);
  uint64_t result = FST_GetHeaderSizeInOutputBuffer(&v10);
  if (!result)
  {
    uint64_t v8 = v6 - 16;
    unint64_t v9 = *(void *)(a1 + 72) - (v6 - 16) + v10;
    if (!a2)
    {
LABEL_7:
      uint64_t result = 0;
      *a3 = v9;
      return result;
    }
    if (*a3 < v9) {
      return err_GenerateErrorData();
    }
    uint64_t result = FST_FillHeader((_DWORD *)a1, a2, *(_DWORD *)(a1 + 104), &v10);
    if (!result)
    {
      cstdlib_memcpy(&a2[v10], (const void *)(*(void *)(a1 + 88) + v8), v9 - v10);
      goto LABEL_7;
    }
  }
  return result;
}

uint64_t FSTFlat_GetFinalStateWeight(uint64_t a1, unsigned int a2, int *a3)
{
  int v3 = *(_DWORD *)(*(void *)(a1 + 112) + 4 * a2);
  if (v3 < 0)
  {
    uint64_t v5 = *(void *)(a1 + 120);
    uint64_t v6 = v3 & 0xFFFFFFF;
    int v7 = (int *)(v5 + v6);
    uint64_t v8 = (int *)(v5 + 16 * v6);
    if (*(_DWORD *)(a1 + 104) == 1) {
      uint64_t v8 = v7;
    }
    int v4 = *v8;
  }
  else
  {
    int v4 = 0x7FFFFFFF;
  }
  *a3 = v4;
  return 0;
}

uint64_t FSTFlat_GetMemoryInfo(uint64_t a1)
{
  return FSTBaseFlat_GetMemoryInfo(a1) + 24;
}

uint64_t FSTFlat_GetStateFlags(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  if (*(_DWORD *)(a1 + 64) <= a2) {
    return err_GenerateErrorData();
  }
  *a3 = *(_DWORD *)(*(void *)(a1 + 112) + 4 * a2) & 0xF0000000;
  return 0;
}

uint64_t _FSTFlat_WriteBufferV1(uint64_t a1, _DWORD *a2, void *a3, uint64_t *a4)
{
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  int v32 = -1;
  uint64_t v31 = 0;
  uint64_t result = FSTCount(a1, (uint64_t)a2, (uint64_t)&v33);
  if (!result)
  {
    uint64_t result = FST_GetHeaderSizeInOutputBuffer(&v31);
    unsigned int v36 = result;
    if (!result)
    {
      uint64_t v9 = v31 + 16;
      uint64_t v10 = v31 + 16 + 16 * HIDWORD(v34) + 4 * (v34 + (unint64_t)(v33 + 2));
      int v11 = (char *)OOCAllocator_Malloc(a1, v10, &v36);
      uint64_t result = v36;
      if (!v36)
      {
        int v12 = a2[8];
        a2[8] = 2;
        uint64_t result = FST_FillHeader(a2, v11, 1, &v31);
        unsigned int v36 = result;
        if (!result)
        {
          a2[8] = v12;
          uint64_t result = (*(uint64_t (**)(_DWORD *, int *))(*(void *)a2 + 48))(a2, &v32);
          unsigned int v36 = result;
          if (!result)
          {
            uint64_t v13 = 0;
            int v14 = (int *)&v11[v31];
            int v15 = v32;
            v14[1] = 0;
            _OWORD v14[2] = 0;
            *int v14 = v15;
            _OWORD v14[3] = v33 + 1;
            unsigned int v16 = &v11[v9];
            uint64_t v17 = &v11[4 * (v33 + 2) + v9];
            uint64_t v29 = v16;
            while (1)
            {
              uint64_t v30 = 0;
              uint64_t result = (*(uint64_t (**)(_DWORD *, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 120))(a2, v13, 8, &v30);
              unsigned int v36 = result;
              if (result) {
                break;
              }
              uint64_t v18 = v30;
              if (v30)
              {
                int v19 = *(_DWORD *)(v30 + 8);
                unsigned int v20 = *(char **)(v30 + 40);
                uint64_t v21 = *(unsigned int *)(v30 + 32);
                uint64_t v22 = *(void *)(v30 + 56);
                uint64_t v23 = *(unsigned int *)(v30 + 48);
                *(_DWORD *)&v16[4 * v13] = v17 - v11;
                if ((v17 - v11) >> 28) {
                  return err_GenerateErrorLimit();
                }
                unsigned int v24 = v19 & 0xF0000000 | (v17 - v11);
                *(_DWORD *)&v16[4 * v13] = v24;
                if ((v24 & 0x80000000) != 0)
                {
                  *(_DWORD *)uint64_t v17 = *(_DWORD *)(v18 + 28);
                  v17 += 4;
                }
                unint64_t v25 = (char *)(v22 + 16 * v23);
                if (v20 != v25)
                {
                  uint64_t v26 = &v20[16 * v21];
                  do
                  {
                    if (v20 == v26)
                    {
                      uint64_t v18 = v30;
                      if (!*(_DWORD *)(v30 + 48)) {
                        goto LABEL_20;
                      }
                      unsigned int v20 = *(char **)(v30 + 56);
                    }
                    cstdlib_memcpy(v17, v20, 0x10uLL);
                    v17 += 16;
                    v20 += 16;
                  }
                  while (v20 != v25);
                  uint64_t v18 = v30;
LABEL_20:
                  unsigned int v16 = v29;
                }
                int v27 = *(_DWORD *)(v18 + 8);
                if ((v27 & 0x3FFFFFF) == 1)
                {
                  if ((v27 & 0x8000000) != 0) {
                    uint64_t v28 = *(void *)(v18 + 16);
                  }
                  else {
                    uint64_t v28 = 0;
                  }
                  uint64_t result = FSTStatePool_PushFSTState(v28, v18);
                  unsigned int v36 = result;
                  if (result) {
                    return result;
                  }
                }
                else
                {
                  *(_DWORD *)(v18 + 8) = v27 - 1;
                  if ((v27 & 0x3FFFFFF) == 0) {
                    return 9;
                  }
                  unsigned int v36 = 0;
                }
              }
              uint64_t v13 = (v13 + 1);
              if (v13 > v33)
              {
                *(_DWORD *)&v16[4 * v13] = v17 - v11;
                *a3 = v11;
                *a4 = v10;
                return v36;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void PNEW_FSTFlat_Con(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, const void *a5, uint64_t a6, uint64_t *a7)
{
  int v16 = 0;
  uint64_t v14 = OOCAllocator_Malloc(a1, 136, &v16);
  if (!v16)
  {
    FSTFlat_Con(v14, a2, a3, a4, a5, a6);
    int v16 = v15;
    if (v15)
    {
      OOCAllocator_Free(a1, v14);
      *a7 = 0;
    }
    else
    {
      *(void *)(v14 + 16) = a1;
      *a7 = v14;
    }
  }
}

void PNEW_FSTFlat_ConFromFST(uint64_t a1, uint64_t a2, uint64_t a3, int8x8_t **a4)
{
  int v10 = 0;
  uint64_t v8 = (int8x8_t *)OOCAllocator_Malloc(a1, 136, &v10);
  if (!v10)
  {
    FSTFlat_ConFromFST(v8, a2, a3);
    int v10 = v9;
    if (v9)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
    }
    else
    {
      v8[2] = (int8x8_t)a1;
      *a4 = v8;
    }
  }
}

void *GetFSTFlatClass()
{
  return &__FSTFlat;
}

uint64_t FSTRegisterBaseFormats(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  uint64_t result = FSTFormatRegistry_GetInstance(a1, a2, &v3);
  if (!result)
  {
    uint64_t result = FSTFormatRegistry_RegisterFormat(v3, 30, (uint64_t)__PNEW_FSTBuild_Con, 0);
    if (!result)
    {
      uint64_t result = FSTFormatRegistry_RegisterFormat(v3, 33, (uint64_t)__PNEW_FSTIncrementalMinimization_Con, 0);
      if (!result)
      {
        uint64_t result = FSTFormatRegistry_RegisterFormat(v3, 2, (uint64_t)PNEW_FSTFlat_Con, (uint64_t)PNEW_FSTStreamedFlat_Con);
        if (!result)
        {
          uint64_t result = FSTFormatRegistry_RegisterFormat(v3, 3, (uint64_t)PNEW_FSTPacked_Con, 0);
          if (!result)
          {
            uint64_t result = FSTFormatRegistry_RegisterFormat(v3, 21, (uint64_t)PNEW_FSTCompact_Con, (uint64_t)PNEW_FSTStreamedCompact_Con);
            if (!result)
            {
              uint64_t result = FSTFormatRegistry_RegisterFormat(v3, 40, (uint64_t)PNEW_FSTCompact2_Con, (uint64_t)PNEW_FSTStreamedCompact2_Con);
              if (!result) {
                return FSTFormatRegistry_RegisterFormat(v3, 43, (uint64_t)PNEW_FSTCompactRnd_Con, (uint64_t)PNEW_FSTStreamedCompactRnd_Con);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void __PNEW_FSTBuild_Con(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, char *a5, uint64_t a6, uint64_t *a7)
{
  PNEW_FSTBuild_Con(a1, a2, 0, a7);
  if (!v11)
  {
    int v12 = FSTBuild_InitFromBuffer(*a7, a5, a4);
    if (a6)
    {
      if (!v12) {
        OOCAllocator_Free(a6, (uint64_t)a5);
      }
    }
  }
}

uint64_t __PNEW_FSTIncrementalMinimization_Con(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, char *a5, uint64_t a6, uint64_t *a7)
{
  PNEW_FSTIncrementalMinimization_ConFromBuffer(a1, a2, a3, a5, a4, a7);
  uint64_t v10 = v9;
  if (a6 && !v9) {
    OOCAllocator_Free(a6, (uint64_t)a5);
  }
  return v10;
}

uint64_t FSTPatched_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7, int a8)
{
  uint64_t v12 = a3;
  uint64_t v15 = _FSTUnaryOperator_Con(a1, a2, a3);
  unsigned int v60 = v15;
  if (v15) {
    return v15;
  }
  int v59 = 0;
  *(void *)a1 = &__FSTPatched;
  *(void *)(a1 + 72) = a2;
  *(void *)(a1 + 80) = a4;
  (*(void (**)(uint64_t))(*(void *)a4 + 24))(a4);
  *(_DWORD *)(a1 + 96) = a5;
  *(_DWORD *)(a1 + 100) = 0;
  uint64_t v16 = OOCAllocator_Malloc(a2, 24, &v60);
  *(void *)(a1 + 88) = v16;
  uint64_t v15 = v60;
  if (v60) {
    return v15;
  }
  *(_DWORD *)uint64_t v16 = 0;
  *(void *)(v16 + 8) = 0;
  *(void *)(v16 + 16) = 0;
  if (!a6) {
    return (*(uint64_t (**)(uint64_t, int *))(*(void *)v12 + 72))(v12, &v59);
  }
  uint64_t v17 = 0;
  uint64_t v57 = v12;
LABEL_5:
  if (a8)
  {
    uint64_t v18 = *(void *)(v16 + 8);
    unint64_t v19 = *(void *)(v16 + 16);
    unint64_t v20 = 0;
    unint64_t v21 = v19 - v18;
    if (v19 != v18)
    {
      unint64_t v22 = (uint64_t)v21 >> 3;
      uint64_t v23 = (2 * v17);
      unsigned int v24 = *(_DWORD *)(a7 + 4 * v23);
      while (1)
      {
        unint64_t v25 = v22 >> 1;
        unsigned int v26 = *(_DWORD *)(v18 + 8 * v20 + 8 * (v22 >> 1));
        if (v24 <= v26)
        {
          if (v24 == v26)
          {
            unint64_t v54 = v25 + v20;
            unsigned int v55 = v23 | 1;
            goto LABEL_57;
          }
        }
        else
        {
          unint64_t v27 = v25 + 1;
          v20 += v27;
          unint64_t v25 = v22 - v27;
        }
        unint64_t v22 = v25;
        if (!v25) {
          goto LABEL_21;
        }
      }
    }
    uint64_t v23 = (2 * v17);
LABEL_21:
    unsigned int v36 = *(_DWORD *)(a7 + 4 * v23);
    unsigned int v37 = *(_DWORD *)(a7 + 4 * (v23 | 1));
    unint64_t v38 = v21 >> 3;
    if (*(_DWORD *)v16 != (v21 >> 3) || v38 == -1) {
      goto LABEL_33;
    }
    unsigned int v39 = 2 * v38;
    if (2 * (int)v38 >= (v38 + 1000000)) {
      unsigned int v39 = v38 + 1000000;
    }
    if (v39 <= (int)v38 + 1) {
      unsigned int v40 = v38 + 1;
    }
    else {
      unsigned int v40 = v39;
    }
    if (v40 <= 8) {
      unsigned int v41 = 8;
    }
    else {
      unsigned int v41 = v40;
    }
    uint64_t v42 = OOCAllocator_Realloc(a2, v18, 8 * v41, &v60);
    uint64_t v16 = *(void *)(a1 + 88);
    *(void *)(v16 + 8) = v42;
    uint64_t v15 = v60;
    if (!v60)
    {
      *(_DWORD *)uint64_t v16 = v41;
      unint64_t v19 = v42 + (v21 & 0x7FFFFFFF8);
      *(void *)(v16 + 16) = v19;
      uint64_t v12 = v57;
LABEL_33:
      *(void *)(v16 + 16) = v19 + 8;
      unint64_t v43 = (v21 >> 3);
      BOOL v44 = v43 > v20;
      unint64_t v45 = v43 - v20;
      if (v44)
      {
        cstdlib_memmove((void *)(*(void *)(v16 + 8) + 8 * v20 + 8), (const void *)(*(void *)(v16 + 8) + 8 * v20), 8 * v45);
        uint64_t v16 = *(void *)(a1 + 88);
      }
      uint64_t v46 = (unsigned int *)(*(void *)(v16 + 8) + 8 * v20);
      *uint64_t v46 = v36;
LABEL_54:
      v46[1] = v37;
      goto LABEL_58;
    }
  }
  else
  {
    uint64_t v18 = *(void *)(v16 + 8);
    unint64_t v28 = *(void *)(v16 + 16);
    unint64_t v29 = 0;
    unint64_t v30 = v28 - v18;
    if (v28 != v18)
    {
      unint64_t v31 = (uint64_t)v30 >> 3;
      unsigned int v32 = *(_DWORD *)(a7 + 4 * v17);
      while (1)
      {
        unint64_t v33 = v31 >> 1;
        unsigned int v34 = *(_DWORD *)(v18 + 8 * v29 + 8 * (v31 >> 1));
        if (v32 <= v34)
        {
          if (v32 == v34)
          {
            unint64_t v54 = v33 + v29;
            unsigned int v55 = v17 + a6;
LABEL_57:
            *(_DWORD *)(v18 + 8 * v54 + 4) = *(_DWORD *)(a7 + 4 * v55);
LABEL_58:
            if (++v17 == a6) {
              return (*(uint64_t (**)(uint64_t, int *))(*(void *)v12 + 72))(v12, &v59);
            }
            goto LABEL_5;
          }
        }
        else
        {
          unint64_t v35 = v33 + 1;
          v29 += v35;
          unint64_t v33 = v31 - v35;
        }
        unint64_t v31 = v33;
        if (!v33) {
          goto LABEL_38;
        }
      }
    }
    unsigned int v32 = *(_DWORD *)(a7 + 4 * v17);
LABEL_38:
    unsigned int v37 = *(_DWORD *)(a7 + 4 * (v17 + a6));
    unint64_t v47 = v30 >> 3;
    if (*(_DWORD *)v16 != (v30 >> 3) || v47 == -1)
    {
LABEL_50:
      *(void *)(v16 + 16) = v28 + 8;
      unint64_t v52 = (v30 >> 3);
      BOOL v44 = v52 > v29;
      unint64_t v53 = v52 - v29;
      if (v44)
      {
        cstdlib_memmove((void *)(*(void *)(v16 + 8) + 8 * v29 + 8), (const void *)(*(void *)(v16 + 8) + 8 * v29), 8 * v53);
        uint64_t v16 = *(void *)(a1 + 88);
      }
      uint64_t v46 = (unsigned int *)(*(void *)(v16 + 8) + 8 * v29);
      *uint64_t v46 = v32;
      goto LABEL_54;
    }
    unsigned int v48 = 2 * v47;
    if (2 * (int)v47 >= (v47 + 1000000)) {
      unsigned int v48 = v47 + 1000000;
    }
    if (v48 <= (int)v47 + 1) {
      unsigned int v49 = v47 + 1;
    }
    else {
      unsigned int v49 = v48;
    }
    if (v49 <= 8) {
      unsigned int v50 = 8;
    }
    else {
      unsigned int v50 = v49;
    }
    uint64_t v51 = OOCAllocator_Realloc(a2, v18, 8 * v50, &v60);
    uint64_t v16 = *(void *)(a1 + 88);
    *(void *)(v16 + 8) = v51;
    uint64_t v15 = v60;
    if (!v60)
    {
      *(_DWORD *)uint64_t v16 = v50;
      unint64_t v28 = v51 + (v30 & 0x7FFFFFFF8);
      *(void *)(v16 + 16) = v28;
      uint64_t v12 = v57;
      goto LABEL_50;
    }
  }
  return v15;
}

uint64_t FSTPatched_ConWithMap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t result = _FSTUnaryOperator_Con(a1, a2, a3);
  if (!result)
  {
    int v13 = 0;
    *(void *)a1 = &__FSTPatched;
    *(void *)(a1 + 72) = a2;
    *(void *)(a1 + 80) = a4;
    (*(void (**)(uint64_t))(*(void *)a4 + 24))(a4);
    *(_DWORD *)(a1 + 96) = a5;
    *(_DWORD *)(a1 + 100) = 1;
    *(void *)(a1 + 88) = a6;
    return (*(uint64_t (**)(uint64_t, int *))(*(void *)a3 + 72))(a3, &v13);
  }
  return result;
}

uint64_t FSTPatched_Des(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 100))
  {
    uint64_t v2 = *(void *)(a1 + 88);
    *(_DWORD *)uint64_t v2 = 0;
    if (*(void *)(v2 + 8))
    {
      OOCAllocator_Free(*(void *)(a1 + 72), *(void *)(v2 + 8));
      uint64_t v2 = *(void *)(a1 + 88);
      *(void *)(v2 + 8) = 0;
    }
    *(void *)(v2 + 16) = 0;
    OOCAllocator_Free(*(void *)(a1 + 72), v2);
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 32))(*(void *)(a1 + 80));
  if (!result)
  {
    return FSTUnaryOperator_Des(a1);
  }
  return result;
}

uint64_t FSTPatched_BorrowArcsPointers(uint64_t result, void *a2, void *a3, void *a4, void *a5)
{
  uint64_t v5 = *(_DWORD **)(result + 56);
  if ((*(unsigned char *)(result + 11) & 0x20) != 0) {
    uint64_t v6 = &v5[4 * ((*v5 + v5[2] + 3) >> 2) + 4];
  }
  else {
    uint64_t v6 = *(_DWORD **)(result + 56);
  }
  uint64_t v7 = *(unsigned int *)(result + 32);
  uint64_t v8 = *(unsigned int *)(result + 48);
  uint64_t v9 = *(void *)(result + 40);
  if (a2) {
    *a2 = v9;
  }
  if (a3) {
    *a3 = v9 + 16 * v7;
  }
  if (a4) {
    *a4 = v6;
  }
  if (a5) {
    *a5 = &v5[4 * v8];
  }
  return result;
}

uint64_t FSTPatched_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v27 = -1;
  if (!__FSTPatched_IsInPatchFst(a1, a2, &v27))
  {
    uint64_t v9 = *(uint64_t (**)(void))(**(void **)(a1 + 64) + 120);
    return v9();
  }
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t *))(**(void **)(a1 + 80) + 120))(*(void *)(a1 + 80), v27, a3, a4);
  if (result) {
    return result;
  }
  uint64_t v10 = *a4;
  if (!*a4) {
    return 0;
  }
  if ((*(unsigned char *)(v10 + 11) & 0x20) == 0) {
    goto LABEL_9;
  }
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, a3, &v25);
  if (result) {
    return result;
  }
  uint64_t result = PNEW_FSTState_Con(*(void *)(a1 + 72), *(void *)(a1 + 72), *(void *)(*(void *)(a1 + 80) + 48), &v26);
  if (result) {
    return result;
  }
  uint64_t result = FSTState_Copy(v26, v25);
  if (result) {
    return result;
  }
  int v13 = *(_DWORD *)(v25 + 8);
  if ((v13 & 0x3FFFFFF) == 1)
  {
    if ((v13 & 0x8000000) != 0) {
      uint64_t v14 = *(void *)(v25 + 16);
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t result = FSTStatePool_PushFSTState(v14, v25);
    if (result) {
      return result;
    }
  }
  else
  {
    *(_DWORD *)(v25 + 8) = v13 - 1;
    if ((v13 & 0x3FFFFFF) == 0) {
      return 9;
    }
  }
  uint64_t v15 = *a4;
  int v16 = *(_DWORD *)(*a4 + 48);
  uint64_t v17 = *(int **)(*a4 + 56);
  unsigned int v18 = *(_DWORD *)(*a4 + 32);
  uint64_t v19 = *(void *)(*a4 + 40);
  uint64_t v20 = *v17;
  int v21 = v17[2];
  if (v20)
  {
    uint64_t result = FSTState_RemoveArcs(v26, 4, (uint64_t)(v17 + 4), *v17);
    if (result) {
      return result;
    }
  }
  if (v21)
  {
    uint64_t result = FSTState_RemoveArcs(v26, 2, (uint64_t)&v17[v20 + 4], v21);
    if (result) {
      return result;
    }
  }
  unsigned int v22 = ((v20 + v21 + 3) >> 2) + 1;
  if (v16 != v22)
  {
    uint64_t result = FSTState_AddArcs(v26, 4, (uint64_t)&v17[4 * v22], v16 - v22);
    if (result) {
      return result;
    }
  }
  if (v18)
  {
    uint64_t result = FSTState_AddArcs(v26, 2, v19, v18);
    if (result) {
      return result;
    }
  }
  int v23 = *(_DWORD *)(v15 + 8);
  if ((v23 & 0x3FFFFFF) != 1)
  {
    *(_DWORD *)(v15 + 8) = v23 - 1;
    if ((v23 & 0x3FFFFFF) != 0) {
      goto LABEL_37;
    }
    return 9;
  }
  if ((v23 & 0x8000000) != 0) {
    uint64_t v24 = *(void *)(v15 + 16);
  }
  else {
    uint64_t v24 = 0;
  }
  uint64_t result = FSTStatePool_PushFSTState(v24, v15);
  if (!result)
  {
LABEL_37:
    if (*a4)
    {
      uint64_t v10 = v26;
      *a4 = v26;
      if (v10)
      {
LABEL_9:
        uint64_t result = 0;
        int v11 = *(_DWORD *)(v10 + 8);
        unsigned int v12 = v11 & 0xD0000000;
        if (*(_DWORD *)(v10 + 32)) {
          unsigned int v12 = v11 & 0xD0000000 | 0x20000000;
        }
        *(_DWORD *)(v10 + 8) = v12 | v11;
        *(_DWORD *)(v10 + 24) = a2;
        return result;
      }
    }
    return 0;
  }
  return result;
}

uint64_t __FSTPatched_IsInPatchFst(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  *a3 = -1;
  unsigned int v3 = *(_DWORD *)(a1 + 96);
  BOOL v4 = a2 >= v3;
  unsigned int v5 = a2 - v3;
  if (v4)
  {
LABEL_10:
    *a3 = v5;
    return 1;
  }
  else
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 88) + 8);
    uint64_t v7 = *(void *)(*(void *)(a1 + 88) + 16);
    uint64_t v8 = v7 - v6;
    if (v7 != v6)
    {
      uint64_t v9 = 0;
      unint64_t v10 = v8 >> 3;
      do
      {
        unint64_t v11 = v10 >> 1;
        unsigned int v12 = *(_DWORD *)(v6 + 8 * v9 + 8 * (v10 >> 1));
        if (v12 >= a2)
        {
          if (v12 == a2)
          {
            unsigned int v5 = *(_DWORD *)(v6 + 8 * (v11 + v9) + 4);
            goto LABEL_10;
          }
        }
        else
        {
          unint64_t v13 = v11 + 1;
          v9 += v13;
          unint64_t v11 = v10 - v13;
        }
        unint64_t v10 = v11;
      }
      while (v11);
    }
    return 0;
  }
}

uint64_t FSTPatched_FillBuffer()
{
  return err_GenerateErrorNotSupported();
}

uint64_t FSTPatched_GetFinalStateWeight(uint64_t a1, unsigned int a2)
{
  unsigned int v5 = -1;
  if (__FSTPatched_IsInPatchFst(a1, a2, &v5)) {
    unsigned int v3 = *(uint64_t (**)(void))(**(void **)(a1 + 80) + 64);
  }
  else {
    unsigned int v3 = *(uint64_t (**)(void))(**(void **)(a1 + 64) + 64);
  }

  return v3();
}

uint64_t FSTPatched_GetMaxBranchFactor(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 136))(*(void *)(a1 + 64));
}

uint64_t FSTPatched_GetMaxStateId(uint64_t a1, _DWORD *a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 72))(*(void *)(a1 + 80));
  if (!result) {
    *a2 += *(_DWORD *)(a1 + 96);
  }
  return result;
}

uint64_t FSTPatched_GetMemoryInfo(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 96))(*(void *)(a1 + 64));
  return v2
       + (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 96))(*(void *)(a1 + 80))
       + 8 * **(unsigned int **)(a1 + 88)
       + 32;
}

uint64_t FSTPatched_GetStateFlags(void **a1, uint64_t a2, uint64_t a3)
{
  unsigned int v12 = -1;
  if (__FSTPatched_IsInPatchFst((uint64_t)a1, a2, &v12))
  {
    uint64_t result = (*(uint64_t (**)(void *, void, uint64_t))(*a1[10] + 56))(a1[10], v12, a3);
    if (!result)
    {
      if ((*(unsigned char *)(a3 + 3) & 0x20) != 0)
      {
        uint64_t v11 = 0;
        uint64_t result = ((uint64_t (*)(void **, uint64_t, uint64_t, uint64_t *))(*a1)[15])(a1, a2, 8, &v11);
        if (!result)
        {
          uint64_t v8 = v11;
          *(_DWORD *)a3 = *(_DWORD *)(v11 + 8) & 0xF0000000;
          int v9 = *(_DWORD *)(v8 + 8);
          if ((v9 & 0x3FFFFFF) == 1)
          {
            if ((v9 & 0x8000000) != 0) {
              uint64_t v10 = *(void *)(v8 + 16);
            }
            else {
              uint64_t v10 = 0;
            }
            return FSTStatePool_PushFSTState(v10, v8);
          }
          else
          {
            *(_DWORD *)(v8 + 8) = v9 - 1;
            if ((v9 & 0x3FFFFFF) != 0) {
              return 0;
            }
            else {
              return 9;
            }
          }
        }
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    uint64_t v7 = *(uint64_t (**)(void))(*a1[8] + 56);
    return v7();
  }
  return result;
}

uint64_t FSTPatched_HasDeltaArcs(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 8) >> 29) & 1;
}

uint64_t FSTPatched_MergeStates(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if ((*(unsigned char *)(a2 + 11) & 0x20) != 0)
  {
    v83[0] = 0;
    v83[1] = 0;
    uint64_t result = PNEW_FSTState_Con(a1, a1, 0, a4);
    if (!result)
    {
      uint64_t v16 = *a4;
      *(_DWORD *)(v16 + 28) = *(_DWORD *)(a3 + 28);
      *(_DWORD *)(v16 + 8) |= *(_DWORD *)(a3 + 8) & 0xF0000000;
      uint64_t v17 = *(unsigned int **)(a2 + 56);
      uint64_t v75 = *(unsigned int *)(a2 + 32);
      uint64_t v71 = *(void *)(a2 + 40);
      uint64_t v18 = *v17;
      unsigned int v76 = v17[1];
      int v77 = *(_DWORD *)(a2 + 48);
      unsigned int v19 = v17[2];
      int v73 = *(_DWORD *)(a3 + 48);
      unsigned int v74 = v17[3];
      uint64_t v20 = *(unsigned int **)(a3 + 56);
      unsigned int v72 = *(_DWORD *)(a3 + 32);
      uint64_t v21 = *(void *)(a3 + 40);
      unsigned int v22 = v20[1];
      uint64_t v80 = *v20;
      unsigned int v23 = v20[3];
      unsigned int v82 = v20[2];
      uint64_t result = FSTState_AddArcs(v16, 4, (uint64_t)v83, 1u);
      if (!result)
      {
        uint64_t v67 = v21;
        unsigned int v68 = v23;
        unsigned int v69 = v22;
        unsigned int v24 = 0;
        uint64_t v25 = v17 + 4;
        int v81 = v20 + 4;
        unsigned int v79 = v19;
        unsigned int v70 = v17;
        unsigned int v26 = 0;
        int v27 = 0;
        unsigned int v28 = 0;
        int v29 = 0;
        if (v18)
        {
          unsigned int v30 = v80;
          if (v80)
          {
            int v29 = 0;
            unsigned int v28 = 0;
            int v27 = 0;
            unsigned int v26 = 0;
            unsigned int v24 = 0;
            do
            {
              unsigned int v31 = v25[v24];
              unsigned int v32 = v81[v26] + v27;
              BOOL v33 = v31 > v32;
              if (v31 <= v32) {
                ++v24;
              }
              else {
                unsigned int v31 = v81[v26++] + v27;
              }
              if (!v33) {
                ++v27;
              }
              *((_DWORD *)v83 + v28++) = v31;
              if (v28 == 4)
              {
                uint64_t result = FSTState_AddArcs(*a4, 4, (uint64_t)v83, 1u);
                if (result) {
                  return result;
                }
                unsigned int v28 = 0;
              }
              ++v29;
            }
            while (v24 < v18 && v26 < v80);
          }
        }
        else
        {
          unsigned int v30 = v80;
        }
        if (v24 < v18)
        {
          int v34 = v18 - v24;
          v29 += v18 - v24;
          unint64_t v35 = &v70[v24 + 4];
          do
          {
            int v36 = *v35++;
            *((_DWORD *)v83 + v28++) = v36;
            if (v28 == 4)
            {
              uint64_t result = FSTState_AddArcs(*a4, 4, (uint64_t)v83, 1u);
              if (result) {
                return result;
              }
              unsigned int v28 = 0;
            }
            --v34;
          }
          while (v34);
          unsigned int v30 = v80;
        }
        unsigned int v37 = v79;
        unsigned int v64 = (v18 + v79 + 3) >> 2;
        unsigned int v65 = v64 + 1;
        if (v26 < v30)
        {
          unint64_t v38 = &v20[v26 + 4];
          while (1)
          {
            unsigned int v40 = *v38++;
            unsigned int v39 = v40;
            if (v40 >= v76 - (v77 - (v64 + 1))) {
              break;
            }
            *((_DWORD *)v83 + v28++) = v39 + v27;
            if (v28 == 4)
            {
              uint64_t result = FSTState_AddArcs(*a4, 4, (uint64_t)v83, 1u);
              if (result) {
                return result;
              }
              unsigned int v28 = 0;
            }
            ++v26;
            ++v29;
            if (v80 == v26)
            {
              unsigned int v30 = v80;
              unsigned int v26 = v80;
              goto LABEL_47;
            }
          }
          unsigned int v30 = v80;
LABEL_47:
          unsigned int v37 = v79;
        }
        unsigned int v41 = 0;
        uint64_t v78 = &v81[v30];
        uint64_t v66 = v20;
        if (v37 && v82)
        {
          int v42 = 0;
          int v43 = 0;
          unsigned int v44 = 0;
          unsigned int v41 = 0;
          unint64_t v45 = &v25[v18];
          do
          {
            unsigned int v46 = v45[v41];
            unsigned int v47 = v78[v44] + v43;
            BOOL v48 = v46 > v47;
            if (v46 <= v47) {
              ++v41;
            }
            else {
              unsigned int v46 = v78[v44++] + v43;
            }
            if (!v48) {
              ++v43;
            }
            *((_DWORD *)v83 + v28++) = v46;
            if (v28 == 4)
            {
              uint64_t result = FSTState_AddArcs(*a4, 4, (uint64_t)v83, 1u);
              if (result) {
                return result;
              }
              unsigned int v28 = 0;
            }
            ++v42;
          }
          while (v41 < v79 && v44 < v82);
        }
        else
        {
          unsigned int v44 = 0;
          int v43 = 0;
          int v42 = 0;
        }
        unsigned int v49 = v79 - v41;
        if (v79 > v41)
        {
          v42 += v49;
          unsigned int v50 = &v70[v18 + 4 + v41];
          do
          {
            int v51 = *v50++;
            *((_DWORD *)v83 + v28++) = v51;
            if (v28 == 4)
            {
              uint64_t result = FSTState_AddArcs(*a4, 4, (uint64_t)v83, 1u);
              if (result) {
                return result;
              }
              unsigned int v28 = 0;
            }
            --v49;
          }
          while (v49);
        }
        if (v44 < v82)
        {
          unint64_t v52 = &v66[v80 + 4 + v44];
          while (1)
          {
            unsigned int v54 = *v52++;
            unsigned int v53 = v54;
            if (v54 >= v74 - v75) {
              break;
            }
            *((_DWORD *)v83 + v28++) = v53 + v43;
            if (v28 == 4)
            {
              uint64_t result = FSTState_AddArcs(*a4, 4, (uint64_t)v83, 1u);
              if (result) {
                return result;
              }
              unsigned int v28 = 0;
            }
            ++v44;
            ++v42;
            if (v82 == v44)
            {
              unsigned int v44 = v82;
              break;
            }
          }
        }
        if (!v28) {
          goto LABEL_81;
        }
        if (v28 <= 3) {
          bzero((char *)v83 + 4 * v28, 4 * (3 - v28) + 4);
        }
        uint64_t result = FSTState_AddArcs(*a4, 4, (uint64_t)v83, 1u);
        if (!result)
        {
LABEL_81:
          if (v77 != v65)
          {
            uint64_t v55 = (uint64_t)&v70[4 * v65];
            unsigned int v56 = v77 - (v64 + 1);
            if (v56 <= 1) {
              unsigned int v56 = 1;
            }
            uint64_t v57 = 16 * v56;
            int v58 = v76 + v64 - v77 + 1;
            do
            {
              if (v26 == v80 || v58 != v81[v26])
              {
                uint64_t result = FSTState_AddArcs(*a4, 4, v55, 1u);
                if (result) {
                  return result;
                }
              }
              else
              {
                ++v26;
              }
              v55 += 16;
              ++v58;
              v57 -= 16;
            }
            while (v57);
          }
          unsigned int v59 = ((v80 + v82 + 3) >> 2) + 1;
          if (v73 == v59 || (uint64_t result = FSTState_AddArcs(*a4, 4, (uint64_t)&v66[4 * v59], v73 - v59), !result))
          {
            uint64_t v60 = v75;
            if (v75)
            {
              int v61 = v74 - v75;
              uint64_t v62 = v71;
              do
              {
                if (v44 == v82 || v61 != v78[v44])
                {
                  uint64_t result = FSTState_AddArcs(*a4, 2, v62, 1u);
                  if (result) {
                    return result;
                  }
                }
                else
                {
                  ++v44;
                }
                v62 += 16;
                ++v61;
                --v60;
              }
              while (v60);
            }
            if (!v72 || (uint64_t result = FSTState_AddArcs(*a4, 2, v67 + 16 * v44, v72), !result))
            {
              uint64_t result = 0;
              unsigned int v63 = *(_DWORD **)(*a4 + 56);
              *unsigned int v63 = v29;
              v63[1] = v69;
              v63[2] = v42;
              v63[3] = v68;
            }
          }
        }
      }
    }
  }
  else
  {
    uint64_t result = PNEW_FSTState_Con(a1, a1, 0, a4);
    if (!result)
    {
      uint64_t result = FSTState_Copy(*a4, a2);
      if (!result)
      {
        uint64_t v8 = *a4;
        int v9 = *(_DWORD *)(a3 + 48);
        uint64_t v10 = *(int **)(a3 + 56);
        unsigned int v11 = *(_DWORD *)(a3 + 32);
        uint64_t v12 = *(void *)(a3 + 40);
        uint64_t v13 = *v10;
        int v14 = v10[2];
        if (!v13 || (uint64_t result = FSTState_RemoveArcs(v8, 4, (uint64_t)(v10 + 4), *v10), !result))
        {
          if (!v14 || (uint64_t result = FSTState_RemoveArcs(v8, 2, (uint64_t)&v10[v13 + 4], v14), !result))
          {
            unsigned int v15 = ((v13 + v14 + 3) >> 2) + 1;
            if (v9 == v15 || (uint64_t result = FSTState_AddArcs(v8, 4, (uint64_t)&v10[4 * v15], v9 - v15), !result))
            {
              if (!v11 || (uint64_t result = FSTState_AddArcs(v8, 2, v12, v11), !result))
              {
                uint64_t result = 0;
                *(_DWORD *)(v8 + 8) &= ~0x20000000u;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t PNEW_FSTPatched_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7, int a8, uint64_t *a9)
{
  unsigned int v19 = 0;
  uint64_t v17 = OOCAllocator_Malloc(a1, 104, &v19);
  uint64_t result = v19;
  if (!v19)
  {
    uint64_t result = FSTPatched_Con(v17, a2, a3, a4, a5, a6, a7, a8);
    unsigned int v19 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v17);
      *a9 = 0;
      return v19;
    }
    else
    {
      *(void *)(v17 + 16) = a1;
      *a9 = v17;
    }
  }
  return result;
}

uint64_t PNEW_FSTPatched_ConWithMap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t *a7)
{
  unsigned int v16 = 0;
  uint64_t v14 = OOCAllocator_Malloc(a1, 104, &v16);
  uint64_t result = v16;
  if (!v16)
  {
    uint64_t result = FSTPatched_ConWithMap(v14, a2, a3, a4, a5, a6);
    unsigned int v16 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v14);
      *a7 = 0;
      return v16;
    }
    else
    {
      *(void *)(v14 + 16) = a1;
      *a7 = v14;
    }
  }
  return result;
}

void *GetFSTPatchedClass()
{
  return &__FSTPatched;
}

void fstnbestpaths(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5)
{
  if (!a4)
  {
    *a5 = a3;
    return;
  }
  if (a4 == 1)
  {
    uint64_t v8 = 0;
    if (PNEW_FSTBestPath_Con(a1, a2, a3, &v8)) {
      return;
    }
  }
  else
  {
    uint64_t v8 = 0;
    PNEW_FSTNBestPaths_Con(a1, a2, a3, a4, &v8);
    if (v7) {
      return;
    }
  }
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a3 + 32))(a3)) {
    *a5 = v8;
  }
}

void PNEW_FSTNBestPaths_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5)
{
  int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 112, &v12);
  if (!v12)
  {
    FSTNBestPaths_Con(v10, a2, a3, a4);
    int v12 = v11;
    if (v11)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
    }
    else
    {
      *(void *)(v10 + 16) = a1;
      *a5 = v10;
    }
  }
}

void FSTNBestPaths_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (!_FSTUnaryOperator_Con(a1, a2, a3))
  {
    *(void *)a1 = &__FSTNBestPaths;
    *(_DWORD *)(a1 + 72) = a4;
    *(_DWORD *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 96) = 0;
    __FSTNBestPaths_CalcPaths(a1);
  }
}

void __FSTNBestPaths_CalcPaths(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  unsigned int v3 = *(_DWORD **)(a1 + 64);
  uint64_t v147 = 0;
  memset(v146, 0, sizeof(v146));
  uint64_t v145 = 0;
  if (FSTStatePotentials_Con((uint64_t)v146, v2, (uint64_t)v3, 1)) {
    return;
  }
  (*(void (**)(_DWORD *))(*(void *)v3 + 24))(v3);
  fstreverse(v2, v2, v3, &v145);
  if (v4) {
    return;
  }
  if (FSTStatePotentials_SetRevInitialPotential((uint64_t)v146, v145)) {
    return;
  }
  uint64_t v5 = v145;
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t v155 = 0;
  uint64_t v156 = 0;
  unsigned int v154 = -1;
  unint64_t v151 = 0;
  uint64_t v152 = 0;
  uint64_t v153 = 0;
  uint64_t v157 = 0;
  v158[0] = (*(uint64_t (**)(uint64_t, unsigned int *))(*(void *)v145 + 48))(v145, &v154);
  if (v158[0]) {
    return;
  }
  uint64_t v8 = *(void *)(a1 + 88);
  uint64_t v7 = *(void *)(a1 + 96);
  uint64_t v9 = v7 - v8;
  unint64_t v10 = (unint64_t)(v7 - v8) >> 6;
  *(_DWORD *)(a1 + 104) = v10;
  unsigned int v11 = v10 + 1;
  unsigned int v12 = *(_DWORD *)(a1 + 80);
  if (v11 > v12)
  {
    unsigned int v13 = 2 * v12;
    unsigned int v14 = v12 + 1000000;
    if (v13 < v14) {
      unsigned int v14 = v13;
    }
    if (v14 > v11) {
      unsigned int v11 = v14;
    }
    if (v11 <= 8) {
      unsigned int v15 = 8;
    }
    else {
      unsigned int v15 = v11;
    }
    uint64_t v16 = OOCAllocator_Realloc(*(void *)(a1 + 24), v8, (unint64_t)v15 << 6, v158);
    *(void *)(a1 + 88) = v16;
    if (v158[0]) {
      return;
    }
    *(_DWORD *)(a1 + 80) = v15;
    uint64_t v7 = v16 + (v9 & 0x3FFFFFFFC0);
  }
  *(void *)(a1 + 96) = v7 + 64;
  v158[0] = FSTState_Con(v7, *(void *)(a1 + 24), 0);
  if (v158[0]) {
    return;
  }
  uint64_t v17 = *(void *)(a1 + 96);
  *(_DWORD *)(v17 - 40) = *(_DWORD *)(a1 + 104);
  uint64_t v18 = *(void *)(a1 + 88);
  unint64_t v19 = v17 - v18;
  unint64_t v20 = (unint64_t)(v17 - v18) >> 6;
  uint64_t v21 = (v20 + 1);
  unsigned int v22 = *(_DWORD *)(a1 + 80);
  if (v21 > v22)
  {
    unsigned int v23 = 2 * v22;
    unsigned int v24 = v22 + 1000000;
    if (v23 < v24) {
      unsigned int v24 = v23;
    }
    if (v24 <= v21) {
      unsigned int v24 = v20 + 1;
    }
    if (v24 <= 8) {
      unsigned int v25 = 8;
    }
    else {
      unsigned int v25 = v24;
    }
    uint64_t v26 = OOCAllocator_Realloc(*(void *)(a1 + 24), v18, (unint64_t)v25 << 6, v158);
    *(void *)(a1 + 88) = v26;
    if (v158[0]) {
      return;
    }
    *(_DWORD *)(a1 + 80) = v25;
    uint64_t v17 = v26 + (v19 & 0x3FFFFFFFC0);
  }
  *(void *)(a1 + 96) = v17 + 64;
  v158[0] = FSTState_Con(v17, *(void *)(a1 + 24), 0);
  if (v158[0]) {
    return;
  }
  *(_DWORD *)(*(void *)(a1 + 96) - 40) = v20;
  uint64_t v27 = (v19 >> 6);
  uint64_t v28 = *(void *)(a1 + 88) + (v27 << 6);
  *(_DWORD *)(v28 + 28) = 0;
  *(_DWORD *)(v28 + 8) |= 0x80000000;
  uint64_t v29 = v156;
  unsigned int v30 = v157;
  unint64_t v31 = (unint64_t)v157 - v156;
  if (v21 >= (((unint64_t)v157 - v156) >> 3))
  {
    if (v21 > v155)
    {
      unsigned int v32 = 2 * v155;
      if (2 * (int)v155 >= (v155 + 1000000)) {
        unsigned int v32 = v155 + 1000000;
      }
      if (v32 <= v21) {
        unsigned int v32 = v20 + 1;
      }
      if (v32 <= 8) {
        unsigned int v33 = 8;
      }
      else {
        unsigned int v33 = v32;
      }
      uint64_t v29 = OOCAllocator_Realloc(v6, v156, 8 * v33, v158);
      uint64_t v156 = v29;
      if (v158[0]) {
        return;
      }
      LODWORD(v155) = v33;
      unsigned int v30 = (void *)(v29 + (v31 & 0x7FFFFFFF8));
      uint64_t v157 = v30;
    }
    unint64_t v34 = v29 + 8 * v21;
    if ((unint64_t)v30 < v34)
    {
      do
        *v30++ = 0x7FFFFFFFFFFFFFFFLL;
      while ((unint64_t)v30 < v34);
      uint64_t v157 = v30;
    }
  }
  *(void *)(v29 + 8 * v27) = v154;
  unint64_t v35 = (char *)OOCAllocator_Realloc(v6, 0, 32, v158);
  if (v158[0]) {
    return;
  }
  unint64_t v36 = 0;
  uint64_t v37 = 0;
  unsigned int v133 = 0;
  *(_DWORD *)unint64_t v35 = v20;
  unint64_t v38 = v35 + 4;
  unint64_t v151 = v146;
  uint64_t v152 = &v155;
  LODWORD(v153) = -1;
  uint64_t v137 = v6;
  unsigned int v138 = 8;
  while (1)
  {
    uint64_t v150 = 0;
    long long v149 = 0uLL;
    unint64_t v39 = v38 - v35;
    unint64_t v40 = (unint64_t)(v38 - v35) >> 2;
    unsigned int v41 = v40 - 1;
    unsigned int v42 = v40 - 2;
    if (v40 >= 2)
    {
      unint64_t v141 = v36;
      int64_t v143 = v38 - v35;
      uint64_t v139 = v38;
      uint64_t v134 = v37;
      unsigned int v43 = *(_DWORD *)&v35[4 * v41];
      *(_DWORD *)&v35[4 * v41] = *(_DWORD *)v35;
      if (v42 >= 2)
      {
        unsigned int v45 = 0;
        unsigned int v46 = v42 >> 1;
        do
        {
          unsigned int v44 = (2 * v45) | 1;
          if (!__FSTNBestPaths_StatesLess(*(_DWORD *)&v35[8 * v45 + 8], *(_DWORD *)&v35[4 * v44], (uint64_t)&v151)) {
            unsigned int v44 = 2 * v45 + 2;
          }
          *(_DWORD *)&v35[4 * v45] = *(_DWORD *)&v35[4 * v44];
          unsigned int v45 = v44;
        }
        while (v44 < v46);
      }
      else
      {
        unsigned int v44 = 0;
      }
      if ((v41 & 1) == 0 && v44 == (v40 - 3) >> 1)
      {
        *(_DWORD *)&v35[4 * v44] = *(_DWORD *)&v35[4 * ((2 * v44) | 1)];
        unsigned int v44 = (2 * v44) | 1;
        goto LABEL_54;
      }
      if (v44)
      {
LABEL_54:
        while (1)
        {
          unsigned int v47 = v44 - 1;
          unsigned int v48 = (v44 - 1) >> 1;
          unsigned int v49 = *(_DWORD *)&v35[4 * v48];
          if (!__FSTNBestPaths_StatesLess(v49, v43, (uint64_t)&v151)) {
            break;
          }
          *(_DWORD *)&v35[4 * v44] = v49;
          unsigned int v44 = v47 >> 1;
          if (v47 <= 1) {
            goto LABEL_59;
          }
        }
        unsigned int v48 = v44;
      }
      else
      {
        unsigned int v48 = 0;
      }
LABEL_59:
      *(_DWORD *)&v35[4 * v48] = v43;
      uint64_t v6 = v137;
      uint64_t v37 = v134;
      unint64_t v38 = v139;
      unint64_t v36 = v141;
      unint64_t v39 = v143;
    }
    uint64_t v144 = *((unsigned int *)v38 - 1);
    if (v41 > v138)
    {
      if (v41 <= 8) {
        unsigned int v41 = 8;
      }
      uint64_t v50 = v37;
      uint64_t v51 = OOCAllocator_Realloc(v6, (uint64_t)v35, 4 * v41, v158);
      if (v158[0]) {
        goto LABEL_189;
      }
      uint64_t v37 = v50;
      unint64_t v35 = (char *)v51;
      LODWORD(v40) = v39 >> 2;
      unsigned int v138 = v41;
    }
    unint64_t v52 = (unsigned int *)(v156 + 8 * v144);
    uint64_t v53 = *v52;
    unsigned int v136 = v52[1];
    uint64_t v54 = (v53 + 2);
    unint64_t v55 = v36 - v37;
    if (v54 >= ((v36 - v37) >> 2))
    {
      if (v54 > v133)
      {
        unsigned int v56 = 2 * v133;
        if (2 * v133 >= v133 + 1000000) {
          unsigned int v56 = v133 + 1000000;
        }
        if (v56 <= v54) {
          unsigned int v56 = v53 + 2;
        }
        if (v56 <= 8) {
          unsigned int v56 = 8;
        }
        unsigned int v133 = v56;
        uint64_t v57 = OOCAllocator_Realloc(v6, v37, 4 * v56, v158);
        if (v158[0]) {
          goto LABEL_189;
        }
        uint64_t v37 = v57;
        unint64_t v36 = v57 + (v55 & 0x3FFFFFFFCLL);
      }
      if (v36 < v37 + 4 * v54)
      {
        unint64_t v58 = v37 + 4 * v54;
        if (v58 <= v36 + 4) {
          unint64_t v58 = v36 + 4;
        }
        size_t v59 = ((v58 + ~v36) & 0xFFFFFFFFFFFFFFFCLL) + 4;
        uint64_t v60 = v37;
        bzero((void *)v36, v59);
        uint64_t v37 = v60;
        v36 += v59;
      }
    }
    unint64_t v38 = &v35[4 * (v40 - 1)];
    uint64_t v61 = (v53 + 1);
    unsigned int v62 = *(_DWORD *)(v37 + 4 * v61) + 1;
    *(_DWORD *)(v37 + 4 * v61) = v62;
    unint64_t v142 = v36;
    if (v53 == -1) {
      break;
    }
    if (v62 <= *(_DWORD *)(a1 + 72))
    {
      unsigned int v140 = &v35[4 * (v40 - 1)];
      uint64_t v135 = v37;
      v158[0] = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)v5 + 120))(v5, v53, 8, &v150);
      if (v158[0]) {
        goto LABEL_189;
      }
      uint64_t v37 = v150;
      if (v150)
      {
        unsigned int v63 = *(long long **)(v150 + 40);
        uint64_t v131 = *(void *)(v150 + 56) + 16 * *(unsigned int *)(v150 + 48);
        if (v63 != (long long *)v131)
        {
          unint64_t v132 = &v63[*(unsigned int *)(v150 + 32)];
          do
          {
            int v148 = 0;
            if (v63 == v132)
            {
              uint64_t v37 = v150;
              if (!*(_DWORD *)(v150 + 48)) {
                goto LABEL_130;
              }
              unsigned int v63 = *(long long **)(v150 + 56);
            }
            long long v149 = *v63;
            int v64 = HIDWORD(v149);
            uint64_t v66 = *(void *)(a1 + 88);
            uint64_t v65 = *(void *)(a1 + 96);
            unint64_t v67 = v65 - v66;
            unint64_t v68 = (unint64_t)(v65 - v66) >> 6;
            unsigned int v69 = v68 + 1;
            unsigned int v70 = *(_DWORD *)(a1 + 80);
            if ((int)v68 + 1 > v70)
            {
              unsigned int v71 = 2 * v70;
              unsigned int v72 = v70 + 1000000;
              if (v71 < v72) {
                unsigned int v72 = v71;
              }
              if (v72 > v69) {
                unsigned int v69 = v72;
              }
              if (v69 <= 8) {
                unsigned int v73 = 8;
              }
              else {
                unsigned int v73 = v69;
              }
              uint64_t v74 = OOCAllocator_Realloc(*(void *)(a1 + 24), v66, (unint64_t)v73 << 6, v158);
              *(void *)(a1 + 88) = v74;
              if (v158[0]) {
                goto LABEL_189;
              }
              *(_DWORD *)(a1 + 80) = v73;
              uint64_t v65 = v74 + (v67 & 0x3FFFFFFFC0);
            }
            *(void *)(a1 + 96) = v65 + 64;
            v158[0] = FSTState_Con(v65, *(void *)(a1 + 24), 0);
            if (v158[0]) {
              goto LABEL_189;
            }
            *(_DWORD *)(*(void *)(a1 + 96) - 40) = v68;
            uint64_t v75 = *(void *)(a1 + 88);
            v158[0] = (*(uint64_t (**)(uint64_t, void, int *))(*(void *)v5 + 56))(v5, v149, &v148);
            if (v158[0]) {
              goto LABEL_189;
            }
            uint64_t v76 = v75 + ((unint64_t)(v67 >> 6) << 6);
            v148 &= 0x5FFFFFFFu;
            *(_DWORD *)(v76 + 8) |= v148;
            int v77 = v149;
            uint64_t v78 = v157;
            unint64_t v79 = (unint64_t)v157 - v156;
            unsigned int v80 = (((unint64_t)v157 - v156) >> 3) + 1;
            if (v80 > v155)
            {
              int v81 = v64;
              unsigned int v82 = 2 * v155;
              if (2 * (int)v155 >= (v155 + 1000000)) {
                unsigned int v82 = v155 + 1000000;
              }
              if (v82 <= v80) {
                unsigned int v82 = (((unint64_t)v157 - v156) >> 3) + 1;
              }
              if (v82 <= 8) {
                unsigned int v83 = 8;
              }
              else {
                unsigned int v83 = v82;
              }
              uint64_t v84 = OOCAllocator_Realloc(v137, v156, 8 * v83, v158);
              uint64_t v156 = v84;
              if (v158[0]) {
                goto LABEL_189;
              }
              LODWORD(v155) = v83;
              uint64_t v78 = (_DWORD *)(v84 + (v79 & 0x7FFFFFFF8));
              int v64 = v81;
            }
            uint64_t v157 = v78 + 2;
            *uint64_t v78 = v77;
            v78[1] = v64 + v136;
            LODWORD(v149) = v144;
            v158[0] = FSTState_AddArcs(v76, 1, (uint64_t)&v149, 1u);
            if (v158[0]) {
              goto LABEL_189;
            }
            unsigned int v85 = v140;
            int64_t v86 = v140 - v35;
            unsigned int v87 = ((unint64_t)(v140 - v35) >> 2) + 1;
            if (v87 <= v138)
            {
              uint64_t v6 = v137;
            }
            else
            {
              unsigned int v88 = 2 * v138;
              if (2 * v138 >= v138 + 1000000) {
                unsigned int v88 = v138 + 1000000;
              }
              if (v88 > v87) {
                unsigned int v87 = v88;
              }
              if (v87 <= 8) {
                unsigned int v87 = 8;
              }
              unsigned int v138 = v87;
              uint64_t v6 = v137;
              uint64_t v89 = OOCAllocator_Realloc(v137, (uint64_t)v35, 4 * v87, v158);
              if (v158[0]) {
                goto LABEL_189;
              }
              unint64_t v35 = (char *)v89;
              unsigned int v85 = (char *)(v89 + (v86 & 0x3FFFFFFFCLL));
            }
            *(_DWORD *)unsigned int v85 = v68;
            unsigned int v140 = v85 + 4;
            unint64_t v90 = (unint64_t)(v85 + 4 - v35) >> 2;
            unsigned int v91 = v90 - 1;
            if (v90 == 1)
            {
              unsigned int v93 = 0;
            }
            else
            {
              unsigned int v92 = v90 - 2;
              while (1)
              {
                unsigned int v93 = v92 >> 1;
                unsigned int v94 = *(_DWORD *)&v35[4 * (v92 >> 1)];
                if (!__FSTNBestPaths_StatesLess(v94, v68, (uint64_t)&v151)) {
                  break;
                }
                *(_DWORD *)&v35[4 * v91] = v94;
                unsigned int v91 = v92 >> 1;
                BOOL v95 = v92 > 1;
                unsigned int v92 = v93 - 1;
                if (!v95) {
                  goto LABEL_128;
                }
              }
              unsigned int v93 = v91;
            }
LABEL_128:
            *(_DWORD *)&v35[4 * v93] = v68;
            ++v63;
          }
          while (v63 != (long long *)v131);
          uint64_t v37 = v150;
        }
LABEL_130:
        int v96 = *(_DWORD *)(v37 + 8);
        if (v96 < 0)
        {
          int v97 = *(_DWORD *)(v37 + 28);
          uint64_t v99 = *(void *)(a1 + 88);
          uint64_t v98 = *(void *)(a1 + 96);
          unint64_t v100 = v98 - v99;
          unint64_t v101 = (unint64_t)(v98 - v99) >> 6;
          unsigned int v102 = v101 + 1;
          unsigned int v103 = *(_DWORD *)(a1 + 80);
          if ((int)v101 + 1 > v103)
          {
            unsigned int v104 = 2 * v103;
            unsigned int v105 = v103 + 1000000;
            if (v104 < v105) {
              unsigned int v105 = v104;
            }
            if (v105 > v102) {
              unsigned int v102 = v105;
            }
            if (v102 <= 8) {
              unsigned int v106 = 8;
            }
            else {
              unsigned int v106 = v102;
            }
            uint64_t v107 = OOCAllocator_Realloc(*(void *)(a1 + 24), v99, (unint64_t)v106 << 6, v158);
            *(void *)(a1 + 88) = v107;
            if (v158[0]) {
              goto LABEL_189;
            }
            *(_DWORD *)(a1 + 80) = v106;
            uint64_t v98 = v107 + (v100 & 0x3FFFFFFFC0);
          }
          *(void *)(a1 + 96) = v98 + 64;
          v158[0] = FSTState_Con(v98, *(void *)(a1 + 24), 0);
          if (v158[0]) {
            goto LABEL_189;
          }
          *(_DWORD *)(*(void *)(a1 + 96) - 40) = v101;
          uint64_t v108 = *(void *)(a1 + 88);
          uint64_t v109 = v157;
          unint64_t v110 = (unint64_t)v157 - v156;
          unsigned int v111 = (((unint64_t)v157 - v156) >> 3) + 1;
          if (v111 > v155)
          {
            unsigned int v112 = 2 * v155;
            if (2 * (int)v155 >= (v155 + 1000000)) {
              unsigned int v112 = v155 + 1000000;
            }
            if (v112 <= v111) {
              unsigned int v112 = (((unint64_t)v157 - v156) >> 3) + 1;
            }
            if (v112 <= 8) {
              unsigned int v113 = 8;
            }
            else {
              unsigned int v113 = v112;
            }
            uint64_t v114 = OOCAllocator_Realloc(v6, v156, 8 * v113, v158);
            uint64_t v156 = v114;
            if (v158[0]) {
              goto LABEL_189;
            }
            LODWORD(v155) = v113;
            uint64_t v109 = (_DWORD *)(v114 + (v110 & 0x7FFFFFFF8));
          }
          uint64_t v115 = (v100 >> 6);
          uint64_t v157 = v109 + 2;
          *uint64_t v109 = -1;
          v109[1] = v97 + v136;
          *(void *)((char *)&v149 + 4) = 0x100000001;
          HIDWORD(v149) = *(_DWORD *)(v150 + 28);
          LODWORD(v149) = v144;
          v158[0] = FSTState_AddArcs(v108 + (v115 << 6), 2, (uint64_t)&v149, 1u);
          if (v158[0]) {
            goto LABEL_189;
          }
          *(_DWORD *)(v108 + (v115 << 6) + 8) |= 0x20000000u;
          int64_t v116 = v140 - v35;
          unsigned int v117 = ((unint64_t)(v140 - v35) >> 2) + 1;
          if (v117 > v138)
          {
            unsigned int v118 = 2 * v138;
            if (2 * v138 >= v138 + 1000000) {
              unsigned int v118 = v138 + 1000000;
            }
            if (v118 > v117) {
              unsigned int v117 = v118;
            }
            if (v117 <= 8) {
              unsigned int v119 = 8;
            }
            else {
              unsigned int v119 = v117;
            }
            uint64_t v120 = OOCAllocator_Realloc(v137, (uint64_t)v35, 4 * v119, v158);
            if (v158[0]) {
              goto LABEL_189;
            }
            unint64_t v35 = (char *)v120;
            unsigned int v138 = v119;
            unsigned int v140 = (char *)(v120 + (v116 & 0x3FFFFFFFCLL));
          }
          *(_DWORD *)unsigned int v140 = v101;
          v140 += 4;
          unint64_t v121 = (unint64_t)(v140 - v35) >> 2;
          unsigned int v122 = v121 - 1;
          if (v121 == 1)
          {
            unsigned int v124 = 0;
          }
          else
          {
            unsigned int v123 = v121 - 2;
            while (1)
            {
              unsigned int v124 = v123 >> 1;
              unsigned int v125 = *(_DWORD *)&v35[4 * (v123 >> 1)];
              if (!__FSTNBestPaths_StatesLess(v125, v101, (uint64_t)&v151)) {
                break;
              }
              *(_DWORD *)&v35[4 * v122] = v125;
              unsigned int v122 = v123 >> 1;
              BOOL v95 = v123 > 1;
              unsigned int v123 = v124 - 1;
              if (!v95) {
                goto LABEL_173;
              }
            }
            unsigned int v124 = v122;
          }
LABEL_173:
          *(_DWORD *)&v35[4 * v124] = v101;
          uint64_t v37 = v150;
          int v96 = *(_DWORD *)(v150 + 8);
          uint64_t v6 = v137;
        }
        if ((v96 & 0x3FFFFFF) == 1)
        {
          if ((v96 & 0x8000000) != 0) {
            uint64_t v128 = *(void *)(v37 + 16);
          }
          else {
            uint64_t v128 = 0;
          }
          v158[0] = FSTStatePool_PushFSTState(v128, v37);
          uint64_t v6 = v137;
          uint64_t v37 = v135;
          unint64_t v38 = v140;
          if (v158[0]) {
            goto LABEL_189;
          }
          goto LABEL_182;
        }
        *(_DWORD *)(v37 + 8) = v96 - 1;
        if ((v96 & 0x3FFFFFF) == 0)
        {
          v158[0] = 9;
          goto LABEL_189;
        }
        v158[0] = 0;
      }
      uint64_t v37 = v135;
      unint64_t v38 = v140;
    }
LABEL_182:
    unint64_t v36 = v142;
    if (v35 == v38) {
      goto LABEL_183;
    }
  }
  uint64_t v126 = v37;
  uint64_t v127 = *(void *)(a1 + 88) + ((unint64_t)*(unsigned int *)(a1 + 104) << 6);
  *(void *)((char *)&v149 + 4) = 0x100000001;
  HIDWORD(v149) = 0;
  LODWORD(v149) = v144;
  v158[0] = FSTState_AddArcs(v127, 2, (uint64_t)&v149, 1u);
  if (v158[0]) {
    goto LABEL_189;
  }
  *(_DWORD *)(v127 + 8) |= 0x20000000u;
  uint64_t v37 = v126;
  if (*(_DWORD *)(v126 + 4 * v61) != *(_DWORD *)(a1 + 72))
  {
    unint64_t v38 = &v35[4 * (v40 - 1)];
    goto LABEL_182;
  }
LABEL_183:
  uint64_t v129 = v37;
  unint64_t v130 = *(void *)(a1 + 88) + ((unint64_t)*(unsigned int *)(a1 + 104) << 6);
  lhstdlib_udqsort(*(void *)(v130 + 40), *(_DWORD *)(v130 + 32), 0x10u, (uint64_t)&v151, (uint64_t (*)(char *, char *, uint64_t))__FSTNBestPaths_ArcsCompare);
  uint64_t v37 = v156;
  if (v156) {
    OOCAllocator_Free(v6, v156);
  }
  if (v35) {
    OOCAllocator_Free(v6, (uint64_t)v35);
  }
  if (v129) {
    OOCAllocator_Free(v6, v129);
  }
LABEL_189:
  if (!v158[0] && !(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v145 + 32))(v145, v37)) {
    (*(void (**)(_OWORD *))(*(void *)&v146[0] + 16))(v146);
  }
}

uint64_t FSTNBestPaths_Des(uint64_t *a1)
{
  unint64_t v2 = a1[11];
  if (v2 >= a1[12])
  {
LABEL_5:
    if (v2) {
      OOCAllocator_Free(a1[3], v2);
    }
    return FSTUnaryOperator_Des((uint64_t)a1);
  }
  else
  {
    while (1)
    {
      uint64_t result = (*(uint64_t (**)(unint64_t))(*(void *)v2 + 16))(v2);
      if (result) {
        break;
      }
      v2 += 64;
      if (v2 >= a1[12])
      {
        unint64_t v2 = a1[11];
        goto LABEL_5;
      }
    }
  }
  return result;
}

uint64_t FSTNBestPaths_FetchState(uint64_t a1, unsigned int a2, unsigned int a3, void *a4)
{
  *a4 = 0;
  uint64_t v4 = *(void *)(a1 + 88);
  if (((unint64_t)(*(void *)(a1 + 96) - v4) >> 6) > a2 && v4 != 0)
  {
    uint64_t v7 = v4 + ((unint64_t)a2 << 6);
    if (FST_CheckQuery(*(_DWORD *)(v7 + 8) & 0xF0000000, a3))
    {
      *a4 = v7;
      ++*(_DWORD *)(v7 + 8);
    }
  }
  return 0;
}

uint64_t FSTNBestPaths_GetFinalStateWeight(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  *a3 = 0x7FFFFFFF;
  uint64_t v3 = *(void *)(a1 + 88);
  if (v3) {
    BOOL v4 = ((unint64_t)(*(void *)(a1 + 96) - v3) >> 6) > a2;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    *a3 = *(_DWORD *)(v3 + ((unint64_t)a2 << 6) + 28);
  }
  return 0;
}

uint64_t FSTNBestPaths_GetInitialStateId(uint64_t a1, int *a2)
{
  if (((*(void *)(a1 + 96) - *(void *)(a1 + 88)) & 0x3FFFFFFFC0) != 0) {
    int v2 = *(_DWORD *)(a1 + 104);
  }
  else {
    int v2 = -1;
  }
  *a2 = v2;
  return 0;
}

uint64_t FSTNBestPaths_GetMaxStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = ((*(void *)(a1 + 96) - *(void *)(a1 + 88)) >> 6) - 1;
  return 0;
}

unint64_t FSTNBestPaths_GetMemoryInfo(uint64_t a1)
{
  return FSTUnaryOperator_GetMemoryInfo(a1) + ((unint64_t)*(unsigned int *)(a1 + 80) << 6) + 40;
}

uint64_t FSTNBestPaths_GetStateFlags(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  *a3 = 0;
  uint64_t v3 = *(void *)(a1 + 88);
  if (v3) {
    BOOL v4 = ((unint64_t)(*(void *)(a1 + 96) - v3) >> 6) > a2;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    *a3 = *(_DWORD *)(v3 + ((unint64_t)a2 << 6) + 8) & 0xF0000000;
  }
  return 0;
}

void FSTNBestPaths_Reset(uint64_t a1)
{
  if (!FSTUnaryOperator_Reset(a1))
  {
    *(_DWORD *)(a1 + 80) = 0;
    uint64_t v2 = *(void *)(a1 + 88);
    if (v2)
    {
      OOCAllocator_Free(*(void *)(a1 + 24), v2);
      *(void *)(a1 + 88) = 0;
    }
    *(void *)(a1 + 96) = 0;
    __FSTNBestPaths_CalcPaths(a1);
  }
}

void *GetFSTNBestPathsClass()
{
  return &__FSTNBestPaths;
}

BOOL __FSTNBestPaths_StatesLess(unsigned int a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a3 + 8) + 8);
  uint64_t v4 = *(unsigned int *)(v3 + 8 * a1);
  int v5 = *(_DWORD *)(a3 + 16);
  if (v4 == v5) {
    int v6 = 0;
  }
  else {
    int v6 = *(_DWORD *)(*(void *)(*(void *)a3 + 24) + 4 * v4);
  }
  uint64_t v7 = *(unsigned int *)(v3 + 8 * a2);
  if (v7 == v5) {
    int v8 = 0;
  }
  else {
    int v8 = *(_DWORD *)(*(void *)(*(void *)a3 + 24) + 4 * v7);
  }
  return *(_DWORD *)(v3 + 8 * a2 + 4) + v8 < *(_DWORD *)(v3 + 8 * a1 + 4) + v6;
}

uint64_t __FSTNBestPaths_ArcsCompare(unsigned int *a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a3 + 8) + 8);
  uint64_t v4 = (unsigned int *)(v3 + 8 * *a1);
  int v5 = (unsigned int *)(v3 + 8 * *a2);
  signed int v6 = v5[1];
  uint64_t v8 = *v4;
  signed int v7 = v4[1];
  int v9 = *(_DWORD *)(a3 + 16);
  if (v8 != v9) {
    v7 += *(_DWORD *)(*(void *)(*(void *)a3 + 24) + 4 * v8);
  }
  uint64_t v10 = *v5;
  if (v10 != v9) {
    v6 += *(_DWORD *)(*(void *)(*(void *)a3 + 24) + 4 * v10);
  }
  BOOL v11 = v7 < v6;
  BOOL v12 = v7 > v6;
  if (v11) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v12;
  }
}

uint64_t FSTMaxBranchDfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = FSTDfsContext_Con(a1, a2, a3);
  if (!result)
  {
    *(void *)a1 = &__FSTMaxBranchDfsContext;
    *(_DWORD *)(a1 + 64) = 0;
  }
  return result;
}

uint64_t FSTMaxBranchDfsContext_DiscoverState(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 32) + *(_DWORD *)(a2 + 48);
  if (v2 > *(_DWORD *)(a1 + 64)) {
    *(_DWORD *)(a1 + 64) = v2;
  }
  return 0;
}

uint64_t PNEW_FSTMaxBranchDfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 72, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = FSTDfsContext_Con(v8, a2, a3);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *(void *)uint64_t v8 = &__FSTMaxBranchDfsContext;
      *(_DWORD *)(v8 + 64) = 0;
      *a4 = v8;
    }
  }
  return result;
}

void *GetFSTMaxBranchDfsContextClass()
{
  return &__FSTMaxBranchDfsContext;
}

void fstnoepsilon(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5)
{
  int v12 = 0;
  if (!FST_QueryProperties(a3, 0x2000, &v12))
  {
    if (v12)
    {
      *a5 = a3;
    }
    else
    {
      uint64_t v11 = 0;
      PNEW_FSTNoEpsilon_Con(a1, a2, a3, a4, &v11);
      if (!v10 && !(*(unsigned int (**)(uint64_t))(*(void *)a3 + 32))(a3)) {
        *a5 = v11;
      }
    }
  }
}

void PNEW_FSTNoEpsilon_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5)
{
  int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 80, &v12);
  if (!v12)
  {
    FSTNoEpsilon_Con(v10, a2, a3, a4);
    int v12 = v11;
    if (v11)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
    }
    else
    {
      *(void *)(v10 + 16) = a1;
      *a5 = v10;
    }
  }
}

double FSTNoEpsilon_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (!_FSTUnaryOperator_Con(a1, a2, a3))
  {
    *(void *)a1 = &__FSTNoEpsilon;
    *(_DWORD *)(a1 + 32) = 37;
    *(void *)&double result = *(void *)(a1 + 40) | 0x200000002000;
    *(double *)(a1 + 40) = result;
    *(_DWORD *)(a1 + 72) = a4;
  }
  return result;
}

uint64_t FSTNoEpsilon_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  int v5 = a2;
  uint64_t v6 = a1;
  uint64_t v80 = 0;
  uint64_t v7 = *(void *)(a1 + 24);
  unsigned int v81 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, 8, &v80);
  if (v81) {
    return v81;
  }
  uint64_t v8 = *(unsigned int *)(v80 + 32);
  if (!v8)
  {
LABEL_13:
    *a4 = v80;
    return v81;
  }
  if (!*(_DWORD *)(v6 + 72))
  {
    unint64_t v11 = *(void *)(v80 + 40);
    unint64_t v12 = v11 + 16 * v8;
    while (*(_DWORD *)(v11 + 8) != -2 || *(_DWORD *)(v11 + 12))
    {
      v11 += 16;
      if (v11 >= v12) {
        goto LABEL_13;
      }
    }
  }
  int v9 = *(_DWORD *)(v80 + 8);
  if ((v9 & 0x3FFFFFF) == 1)
  {
    if ((v9 & 0x8000000) != 0) {
      uint64_t v10 = *(void *)(v80 + 16);
    }
    else {
      uint64_t v10 = 0;
    }
    unsigned int v81 = FSTStatePool_PushFSTState(v10, v80);
    if (v81) {
      return v81;
    }
  }
  else
  {
    *(_DWORD *)(v80 + 8) = v9 - 1;
    if ((v9 & 0x3FFFFFF) == 0) {
      return 9;
    }
    unsigned int v81 = 0;
  }
  unsigned int v13 = (_DWORD *)OOCAllocator_Realloc(v7, 0, 40, &v81);
  if (!v81)
  {
    unint64_t v14 = (unint64_t)v13;
    unint64_t v67 = a4;
    uint64_t v77 = v6;
    uint64_t v78 = v7;
    int v15 = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    int __src = 0;
    unsigned int v73 = 0;
    uint64_t v18 = 0;
    unint64_t v19 = 0;
    unsigned int v71 = 0;
    *unsigned int v13 = v5;
    unint64_t v20 = v13 + 1;
    uint64_t v21 = 10;
    int v68 = v5;
    int v69 = 0x7FFFFFFF;
    do
    {
      uint64_t v22 = *(unsigned int *)(v14 + 4 * v16);
      uint64_t v79 = 0;
      unsigned int v81 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(v6 + 64) + 120))(*(void *)(v6 + 64), v22, 8, &v79);
      if (v81) {
        return v81;
      }
      uint64_t v23 = v79;
      int v74 = *(_DWORD *)(v79 + 8);
      uint64_t v75 = v16;
      if (v74 < 0)
      {
        v15 |= 0x80000000;
        int v24 = v69;
        if (v69 >= *(_DWORD *)(v79 + 28)) {
          int v24 = *(_DWORD *)(v79 + 28);
        }
        int v69 = v24;
      }
      uint64_t v25 = v18;
      uint64_t v26 = v21;
      int v76 = v15;
      uint64_t v27 = *(unsigned int *)(v79 + 48);
      if (v27)
      {
        uint64_t v28 = *(const void **)(v79 + 56);
        uint64_t v29 = v73;
        int64_t v30 = v73 - v19;
        unsigned int v31 = v27 + ((unint64_t)(v73 - v19) >> 4);
        if (v31 > v71)
        {
          unsigned int v32 = 2 * v71;
          if (2 * v71 >= v71 + 1000000) {
            unsigned int v32 = v71 + 1000000;
          }
          if (v32 > v31) {
            unsigned int v31 = v32;
          }
          if (v31 <= 8) {
            unsigned int v31 = 8;
          }
          unsigned int v71 = v31;
          uint64_t v33 = OOCAllocator_Realloc(v78, (uint64_t)v19, 16 * v31, &v81);
          if (v81) {
            return v81;
          }
          unint64_t v19 = (unsigned char *)v33;
          uint64_t v29 = (char *)(v33 + (v30 & 0xFFFFFFFF0));
          uint64_t v6 = v77;
        }
        unint64_t v34 = v29;
        cstdlib_memcpy(v29, v28, 16 * v27);
        unsigned int v73 = &v34[16 * v27];
        uint64_t v23 = v79;
        uint64_t v25 = v18;
        uint64_t v26 = v21;
      }
      uint64_t v35 = *(unsigned int *)(v23 + 32);
      if (v35)
      {
        unsigned int v70 = v19;
        uint64_t v36 = 0;
        uint64_t v37 = *(void *)(v23 + 40);
        uint64_t v38 = (uint64_t)__src;
        do
        {
          unint64_t v39 = (int *)(v37 + 16 * v36);
          int v40 = *v39;
          if (v39[2] == -2 && !v39[3] || *(_DWORD *)(v6 + 72))
          {
            unsigned int v41 = (_DWORD *)v14;
            if (v14 >= (unint64_t)v20)
            {
LABEL_42:
              unint64_t v42 = (unint64_t)v20 - v14;
              LODWORD(v43) = (((unint64_t)v20 - v14) >> 2) + 1;
              if (v43 > v26)
              {
                uint64_t v44 = v25;
                unsigned int v45 = 2 * v26;
                if (2 * (int)v26 >= (v26 + 1000000)) {
                  unsigned int v45 = v26 + 1000000;
                }
                if (v45 > v43) {
                  LODWORD(v43) = v45;
                }
                if (v43 <= 8) {
                  uint64_t v43 = 8;
                }
                else {
                  uint64_t v43 = v43;
                }
                uint64_t v46 = v43;
                uint64_t v47 = v38;
                uint64_t v48 = OOCAllocator_Realloc(v78, v14, 4 * v43, &v81);
                if (v81) {
                  return v81;
                }
                uint64_t v38 = v47;
                unint64_t v14 = v48;
                unint64_t v20 = (_DWORD *)(v48 + (v42 & 0x3FFFFFFFCLL));
                uint64_t v25 = v44;
                uint64_t v26 = v46;
                uint64_t v6 = v77;
              }
              *v20++ = v40;
            }
            else
            {
              while (v40 != *v41)
              {
                if (++v41 >= v20) {
                  goto LABEL_42;
                }
              }
            }
          }
          else
          {
            unint64_t v49 = (unint64_t)&v17[-v38];
            LODWORD(v50) = ((unint64_t)&v17[-v38] >> 4) + 1;
            if (v50 > v25)
            {
              uint64_t v51 = v26;
              unsigned int v52 = 2 * v25;
              if (2 * (int)v25 >= (v25 + 1000000)) {
                unsigned int v52 = v25 + 1000000;
              }
              if (v52 > v50) {
                LODWORD(v50) = v52;
              }
              if (v50 <= 8) {
                uint64_t v50 = 8;
              }
              else {
                uint64_t v50 = v50;
              }
              uint64_t v53 = v50;
              uint64_t v54 = OOCAllocator_Realloc(v78, v38, 16 * v50, &v81);
              if (v81) {
                return v81;
              }
              uint64_t v38 = v54;
              uint64_t v17 = (char *)(v54 + (v49 & 0xFFFFFFFF0));
              uint64_t v25 = v53;
              uint64_t v26 = v51;
              uint64_t v6 = v77;
            }
            *(_OWORD *)uint64_t v17 = *(_OWORD *)v39;
            v17 += 16;
          }
          ++v36;
        }
        while (v36 != v35);
        int __src = (void *)v38;
        uint64_t v23 = v79;
        unint64_t v19 = v70;
      }
      int v55 = *(_DWORD *)(v23 + 8);
      if ((v55 & 0x3FFFFFF) == 1)
      {
        uint64_t v21 = v26;
        uint64_t v18 = v25;
        if ((v55 & 0x8000000) != 0) {
          uint64_t v56 = *(void *)(v23 + 16);
        }
        else {
          uint64_t v56 = 0;
        }
        unsigned int v81 = FSTStatePool_PushFSTState(v56, v23);
        if (v81) {
          return v81;
        }
      }
      else
      {
        *(_DWORD *)(v23 + 8) = v55 - 1;
        if ((v55 & 0x3FFFFFF) == 0) {
          return 9;
        }
        uint64_t v21 = v26;
        uint64_t v18 = v25;
        unsigned int v81 = 0;
      }
      uint64_t v16 = v75 + 1;
      int v15 = v76 | v74 & 0x50000000;
    }
    while (v75 + 1 < (unint64_t)(((unint64_t)v20 - v14) >> 2));
    uint64_t v79 = 0;
    unsigned int v81 = FSTStatePool_PopFSTState(*(void *)(v6 + 48), &v79);
    if (v81) {
      return v81;
    }
    uint64_t v57 = __src;
    unint64_t v58 = (unint64_t)(v17 - (unsigned char *)__src) >> 4;
    uint64_t v59 = v79;
    *(_DWORD *)(v79 + 8) |= v15;
    *(_DWORD *)(v59 + 24) = v68;
    *(_DWORD *)(v59 + 28) = v69;
    if (v58)
    {
      uint64_t v60 = *(_DWORD **)(v59 + 40);
      if (!v60 || *(v60 - 1) <= v58)
      {
        uint64_t v61 = _FSTState_ReserveEpsilonArcsInternal(v59, v58, &v81);
        if (v81) {
          return v81;
        }
        uint64_t v60 = (_DWORD *)v61;
        uint64_t v57 = __src;
      }
      cstdlib_memcpy(v60, v57, (v17 - (unsigned char *)__src) & 0xFFFFFFFF0);
      uint64_t v59 = v79;
      *(_DWORD *)(v79 + 32) = v58;
      *(_DWORD *)(v59 + 8) |= 0x20000000u;
    }
    unint64_t v62 = (unint64_t)(v73 - v19) >> 4;
    uint64_t v63 = v78;
    if (!v62)
    {
LABEL_87:
      uint64_t v65 = (uint64_t)__src;
      *unint64_t v67 = v59;
      if (v19)
      {
        OOCAllocator_Free(v63, (uint64_t)v19);
        uint64_t v65 = (uint64_t)__src;
      }
      if (v65) {
        OOCAllocator_Free(v63, v65);
      }
      if (v14) {
        OOCAllocator_Free(v63, v14);
      }
      return v81;
    }
    int v64 = *(_DWORD **)(v59 + 56);
    if (!v64 || *(v64 - 1) <= v62) {
      int v64 = (_DWORD *)_FSTState_ReserveArcsInternal(v59, (unint64_t)(v73 - v19) >> 4, &v81);
    }
    if (!v81)
    {
      cstdlib_memcpy(v64, v19, (v73 - v19) & 0xFFFFFFFF0);
      uint64_t v63 = v78;
      uint64_t v59 = v79;
      *(_DWORD *)(v79 + 48) = v62;
      goto LABEL_87;
    }
  }
  return v81;
}

uint64_t FSTNoEpsilon_GetMaxStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = -1;
  return 0;
}

uint64_t FSTNoEpsilon_GetMemoryInfo(uint64_t a1)
{
  return FSTUnaryOperator_GetMemoryInfo(a1) + 8;
}

void *GetFSTNoEpsilonClass()
{
  return &__FSTNoEpsilon;
}

uint64_t FSTNumberDfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = FSTDfsContext_Con(a1, a2, a3);
  if (!result)
  {
    *(void *)a1 = &__FSTNumberDfsContext;
    *(void *)(a1 + 64) = 0;
    uint64_t result = dpmemblock_Create(a2, 4, 0x400u, (uint64_t *)(a1 + 64));
    if (!result)
    {
      FSTDfsContext_SetDfsOptions((_DWORD *)a1, 1, 0, 0);
      return 0;
    }
  }
  return result;
}

uint64_t FSTNumberDfsContext_Des(uint64_t a1)
{
  dpmemblock_Free(*(uint64_t **)(a1 + 64));

  return FSTDfsContext_Des(a1);
}

uint64_t FSTNumberDfsContext_BorrowIndexArray(uint64_t a1)
{
  return a1 + 64;
}

uint64_t FSTNumberDfsContext_DiscoverState()
{
  return 0;
}

uint64_t FSTNumberDfsContext_FinishState(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = 0;
  unsigned int v21 = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)v4 + 120))(v4, a2, 8, &v22);
  if (result) {
    return result;
  }
  uint64_t v6 = *(unsigned int *)(v22 + 48);
  if (v6)
  {
    int v7 = 0;
    int v9 = (uint64_t *)(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 64);
    uint64_t v10 = *(unsigned int **)(v22 + 56);
    do
    {
      unsigned int v11 = *v10;
      v10 += 4;
      v7 += *(_DWORD *)(*(void *)(*(void *)(v8 + 8) + 8 * (v11 >> *(_WORD *)(v8 + 44)))
                      + 4 * (v11 & ~(-1 << *(_WORD *)(v8 + 44))));
      --v6;
    }
    while (v6);
    unsigned int v12 = *(_DWORD *)(v8 + 32);
    if ((int)a2 + 1 > v12)
    {
      uint64_t v20 = 0;
      unsigned int v13 = v12 + 1;
      do
      {
        uint64_t result = dpmemblock_GetNewElement(*v9, &v20, 0);
        if (v13 >= (int)a2 + 1) {
          break;
        }
        ++v13;
      }
      while (!result);
      if (result) {
        return result;
      }
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unsigned int *))(*(void *)v4 + 56))(v4, a2, &v21);
    if (result) {
      return result;
    }
    int v14 = v7 + (v21 >> 31);
  }
  else
  {
    int v9 = (uint64_t *)(a1 + 64);
    uint64_t v15 = *(void *)(a1 + 64);
    unsigned int v16 = *(_DWORD *)(v15 + 32);
    if ((int)a2 + 1 <= v16)
    {
      int v14 = 1;
      goto LABEL_21;
    }
    uint64_t v20 = 0;
    unsigned int v17 = v16 + 1;
    do
    {
      uint64_t result = dpmemblock_GetNewElement(*v9, &v20, 0);
      if (v17 >= (int)a2 + 1) {
        break;
      }
      ++v17;
    }
    while (!result);
    if (result) {
      return result;
    }
    int v14 = 1;
  }
  uint64_t v15 = *v9;
LABEL_21:
  *(_DWORD *)(*(void *)(*(void *)(v15 + 8) + 8 * (a2 >> *(_WORD *)(v15 + 44)))
            + 4 * (a2 & ~(-1 << *(_WORD *)(v15 + 44)))) = v14;
  int v18 = *(_DWORD *)(v22 + 8);
  if ((v18 & 0x3FFFFFF) != 1)
  {
    *(_DWORD *)(v22 + 8) = v18 - 1;
    if ((v18 & 0x3FFFFFF) == 0) {
      return 9;
    }
    return FSTDfsContext_FinishState();
  }
  if ((v18 & 0x8000000) != 0) {
    uint64_t v19 = *(void *)(v22 + 16);
  }
  else {
    uint64_t v19 = 0;
  }
  uint64_t result = FSTStatePool_PushFSTState(v19, v22);
  if (!result) {
    return FSTDfsContext_FinishState();
  }
  return result;
}

uint64_t PNEW_FSTNumberDfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 72, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = FSTNumberDfsContext_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

void *GetFSTNumberDfsContextClass()
{
  return &__FSTNumberDfsContext;
}

void fstunion(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  int v9 = a4;
  uint64_t v13 = 0;
  PNEW_FSTUnion_Con(a1, a2, a3, a4, a5, a6, a7, &v13);
  if (!v11)
  {
    *a8 = v13;
    if (a3)
    {
      uint64_t v12 = a3;
      do
      {
        if ((*(unsigned int (**)(void))(*(void *)*v9 + 32))(*v9)) {
          break;
        }
        ++v9;
        --v12;
      }
      while (v12);
    }
  }
}

void PNEW_FSTUnion_Con(uint64_t a1, uint64_t a2, unsigned int a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  int v18 = 0;
  uint64_t v16 = OOCAllocator_Malloc(a1, 224, &v18);
  if (!v18)
  {
    FSTUnion_Con(v16, a2, a3, a4, a5, a6, a7);
    int v18 = v17;
    if (v17)
    {
      OOCAllocator_Free(a1, v16);
      *a8 = 0;
    }
    else
    {
      *(void *)(v16 + 16) = a1;
      *a8 = v16;
    }
  }
}

void FSTUnion_Con(uint64_t a1, uint64_t a2, unsigned int a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  FST_Con((void *)a1, a2, *(void *)(*(void *)a4 + 48));
  int v27 = v14;
  if (!v14)
  {
    *(void *)a1 = &__FSTUnion;
    if (a3 >= 0x10000)
    {
      err_GenerateErrorLimit();
    }
    else
    {
      *(_WORD *)(a1 + 64) = a3;
      uint64_t v15 = (void *)OOCAllocator_Malloc(a2, 8 * a3, &v27);
      *(void *)(a1 + 72) = v15;
      if (!v27)
      {
        cstdlib_memcpy(v15, a4, 8 * a3);
        *(int8x8_t *)(a1 + 40) = vorr_s8(vand_s8(*(int8x8_t *)(a1 + 40), (int8x8_t)0x300000003), (int8x8_t)0x1430000004000);
        if (a3)
        {
          uint64_t v16 = 0;
          uint64_t v17 = *(void *)(a1 + 72);
          uint64_t v18 = 8 * a3;
          int v19 = 1;
          do
          {
            (*(void (**)(void))(**(void **)(v17 + v16) + 24))(*(void *)(v17 + v16));
            uint64_t v17 = *(void *)(a1 + 72);
            uint64_t v20 = *(_DWORD **)(v17 + v16);
            int v21 = v20[10];
            if (v20[9] == 2) {
              int v19 = 2;
            }
            int v22 = v20[11];
            if ((v21 & v22 & 0x200) != 0)
            {
              *(void *)(a1 + 40) |= 0x20000000200uLL;
              int v21 = v20[10];
              int v22 = v20[11];
            }
            if ((v22 & v21 & 0x10000) != 0)
            {
              *(void *)(a1 + 40) |= 0x1000000010000uLL;
              int v22 = v20[11];
            }
            if ((v22 & 0x4000) != 0)
            {
              LODWORD(v23) = *(void *)(a1 + 40) & 0xFFFFBFFF;
              HIDWORD(v23) = (*(void *)(a1 + 40) | 0x400000004000uLL) >> 32;
              *(void *)(a1 + 40) = v23;
            }
            v16 += 8;
          }
          while (v18 != v16);
        }
        else
        {
          int v19 = 1;
        }
        *(void *)(a1 + 80) = a5;
        *(void *)(a1 + 88) = a6;
        *(void *)(a1 + 96) = a7;
        *(_DWORD *)(a1 + 32) = 8;
        *(_DWORD *)(a1 + 36) = v19;
        *(_DWORD *)(a1 + 104) = 16;
        uint64_t v24 = OOCAllocator_Malloc(a2, 64, &v27);
        *(void *)(a1 + 112) = v24;
        if (!v27)
        {
          uint64_t v25 = *(unsigned int *)(a1 + 104);
          unint64_t v26 = v24 + 4 * v25;
          *(void *)(a1 + 120) = v26;
          if (v25)
          {
            if (v26 <= v24 + 4) {
              unint64_t v26 = v24 + 4;
            }
            memset((void *)v24, 255, ((v26 + ~v24) & 0xFFFFFFFFFFFFFFFCLL) + 4);
          }
          *(_DWORD *)(a1 + 128) = 0;
          *(void *)(a1 + 136) = 0;
          *(void *)(a1 + 144) = 0;
          *(_DWORD *)(a1 + 152) = -1;
          *(_DWORD *)(a1 + 168) = 0;
          *(_OWORD *)(a1 + 176) = 0u;
          *(_OWORD *)(a1 + 192) = 0u;
          *(_OWORD *)(a1 + 208) = 0u;
        }
      }
    }
  }
}

uint64_t FSTUnion_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (*(void *)(a1 + 72) && *(_WORD *)(a1 + 64))
  {
    uint64_t v3 = 0;
    while (1)
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 72) + 8 * v3);
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 32))(v4);
      if (result) {
        break;
      }
      if (++v3 >= (unint64_t)*(unsigned __int16 *)(a1 + 64)) {
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    uint64_t v6 = *(void *)(a1 + 112);
    if (v6) {
      OOCAllocator_Free(v2, v6);
    }
    uint64_t v7 = *(void *)(a1 + 136);
    if (v7) {
      OOCAllocator_Free(v2, v7);
    }
    uint64_t v8 = *(void *)(a1 + 176);
    if (v8) {
      OOCAllocator_Free(v2, v8);
    }
    OOCAllocator_Free(*(void *)(a1 + 24), *(void *)(a1 + 192));
    OOCAllocator_Free(*(void *)(a1 + 24), *(void *)(a1 + 208));
    OOCAllocator_Free(*(void *)(a1 + 24), *(void *)(a1 + 72));
    return FST_Des(a1);
  }
  return result;
}

uint64_t FSTUnion_BorrowComponentFst(uint64_t a1, unsigned int a2)
{
  if (*(unsigned __int16 *)(a1 + 64) <= a2) {
    return 0;
  }
  else {
    return *(void *)(*(void *)(a1 + 72) + 8 * (a2 + 1));
  }
}

uint64_t FSTUnion_FetchState(void *a1, unsigned int a2, unsigned int a3, uint64_t *a4)
{
  uint64_t v4 = a4;
  unsigned int v67 = 0;
  uint64_t v5 = a1[17];
  if (((unint64_t)(a1[18] - v5) >> 3) <= a2)
  {
    *a4 = 0;
    return err_GenerateErrorArg();
  }
  unsigned int v6 = a2;
  uint64_t v8 = (unsigned int *)(a1[22] + 16 * *(unsigned int *)(v5 + 8 * a2 + 4));
  unint64_t v9 = *v8;
  if (v9 >= 0x10000)
  {
    unsigned int v60 = a3;
    unint64_t v63 = 0;
    uint64_t v16 = 0;
    int v11 = 0;
    unsigned int v14 = 0;
    uint64_t v10 = 0;
    uint64_t v64 = a1[3];
    unint64_t v65 = 0;
    uint64_t v17 = (unsigned int *)((char *)v8 + ((v9 >> 12) & 0xFFFF0));
    int v18 = 1;
    do
    {
      unsigned int v19 = v8[2];
      if (v19 == -2)
      {
        uint64_t v66 = 0;
        uint64_t v20 = *(void *)(a1[9] + 8 * *(unsigned __int16 *)v8);
        uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, _DWORD **))(*(void *)v20 + 120))(v20, v8[1], 8, &v66);
        unsigned int v67 = result;
        if (result) {
          return result;
        }
        uint64_t v21 = (uint64_t)v66;
        if (v66)
        {
          if (v18) {
            v11 |= v66[2] & 0xF0000000;
          }
          int v22 = v66[12];
          int v23 = v66[8] + v10;
          uint64_t v24 = (v23 + v22);
          if (v23 + v22)
          {
            unint64_t v25 = 20 * (v23 + v22);
            uint64_t v26 = a1[24];
            if (v25 > a1[25])
            {
              a1[25] = v25;
              uint64_t v26 = OOCAllocator_Realloc(v64, v26, v25, &v67);
              a1[24] = v26;
              uint64_t result = v67;
              if (v67) {
                return result;
              }
              uint64_t v21 = (uint64_t)v66;
            }
            unint64_t v63 = v26 + 20 * v24;
            uint64_t v16 = (_DWORD *)(v26 + 20 * v10);
          }
          if (v16)
          {
            int v27 = *(int **)(v21 + 40);
            uint64_t v28 = *(int **)(v21 + 56);
            uint64_t v29 = *(unsigned int *)(v21 + 48);
            int64_t v30 = &v28[4 * v29];
            if (v27 != v30)
            {
              unsigned int v31 = &v27[4 * *(unsigned int *)(v21 + 32)];
              do
              {
                if (v27 == v31)
                {
                  int v27 = v28;
                  if (!v29) {
                    break;
                  }
                }
                uint64_t v32 = *(unsigned __int16 *)v8;
                int v33 = *v27;
                _DWORD *v16 = v32;
                v16[1] = v33;
                uint64_t v34 = a1[10];
                if (v34
                  && (uint64_t v35 = *(void *)(v34 + 8 * v32)) != 0
                  && (uint64_t v36 = v27[1], (v36 & 0x80000000) == 0))
                {
                  int v37 = *(_DWORD *)(v35 + 4 * v36);
                }
                else
                {
                  int v37 = v27[1];
                  LODWORD(v36) = v37;
                }
                _OWORD v16[2] = v37;
                unsigned int v38 = v8[2];
                if (v38 == -2)
                {
                  int v39 = v27[2];
                  void v16[3] = v39;
                  uint64_t v40 = a1[12];
                  if (!v40 || (v36 == -2 ? (BOOL v41 = (v39 & 0x40000000) == 0) : (BOOL v41 = 1), v41))
                  {
                    uint64_t v42 = a1[11];
                    if (!v42 || v39 < 1) {
                      goto LABEL_40;
                    }
                    int v43 = *(_DWORD *)(v42 + 4 * v32);
                  }
                  else
                  {
                    int v43 = *(_DWORD *)(v40 + 4 * v32);
                  }
                  void v16[3] = v43 + v39;
                }
                else
                {
                  void v16[3] = v38;
                }
LABEL_40:
                v16[4] = v27[3] + v8[3];
                v16 += 5;
                v27 += 4;
              }
              while (v27 != v30);
            }
          }
          int v44 = *(_DWORD *)(v21 + 8);
          if ((v44 & 0x3FFFFFF) == 1)
          {
            if ((v44 & 0x8000000) != 0) {
              uint64_t v45 = *(void *)(v21 + 16);
            }
            else {
              uint64_t v45 = 0;
            }
            uint64_t result = FSTStatePool_PushFSTState(v45, v21);
            unsigned int v67 = result;
            if (result) {
              return result;
            }
          }
          else
          {
            *(_DWORD *)(v21 + 8) = v44 - 1;
            if ((v44 & 0x3FFFFFF) == 0) {
              return 9;
            }
            unsigned int v67 = 0;
          }
        }
        else
        {
          uint64_t v24 = v10;
        }
        uint64_t v10 = v24;
      }
      else
      {
        unint64_t v46 = 20 * (v14 + 1);
        uint64_t v47 = a1[26];
        if (v46 > a1[27])
        {
          a1[27] = v46;
          uint64_t v47 = OOCAllocator_Realloc(v64, v47, v46, &v67);
          a1[26] = v47;
          uint64_t result = v67;
          if (v67) {
            return result;
          }
          unsigned int v19 = v8[2];
        }
        int v18 = 0;
        unint64_t v65 = v47 + 20 * (v14 + 1);
        uint64_t v48 = (_DWORD *)(v47 + 20 * v14);
        unsigned int v49 = v8[1];
        *uint64_t v48 = *(unsigned __int16 *)v8;
        v48[1] = v49;
        unsigned int v50 = v8[3];
        v48[3] = v19;
        v48[4] = v50;
        int v11 = 0x20000000;
        ++v14;
      }
      v8 += 4;
    }
    while (v8 < v17);
    if (v10 && (unint64_t v51 = a1[24]) != 0)
    {
      unint64_t v12 = v63;
      unint64_t v13 = v65;
      if (v63)
      {
        lhstdlib_qsort(a1[24], -858993459 * ((v63 - v51) >> 2), 0x14u, (uint64_t (*)(unsigned char *, unsigned char *))FSTUnionArcInputLess);
        if (v63 <= v51)
        {
          LODWORD(v10) = 0;
          if (v14)
          {
LABEL_66:
            unint64_t v54 = a1[26];
            if (v54) {
              BOOL v55 = v13 == 0;
            }
            else {
              BOOL v55 = 1;
            }
            if (!v55)
            {
              lhstdlib_qsort(a1[26], -858993459 * ((v13 - v54) >> 2), 0x14u, (uint64_t (*)(unsigned char *, unsigned char *))FSTUnionArcOutputLess);
              if (v13 <= v54)
              {
                unsigned int v14 = 0;
              }
              else
              {
                int v56 = 0;
LABEL_72:
                unint64_t v57 = v54 + 20;
                while (v57 < v13)
                {
                  int v58 = *(_DWORD *)(v57 + 12);
                  v57 += 20;
                  if (v58 != *(_DWORD *)(v54 + 12))
                  {
                    ++v56;
                    unint64_t v54 = v57 - 20;
                    goto LABEL_72;
                  }
                }
                unsigned int v14 = v56 + 1;
              }
            }
          }
LABEL_81:
          uint64_t v4 = a4;
          a3 = v60;
          unsigned int v6 = a2;
          goto LABEL_82;
        }
        LODWORD(v10) = 0;
LABEL_60:
        LODWORD(v10) = v10 + 1;
        unint64_t v52 = v51 + 20;
        while (v52 < v63)
        {
          int v53 = *(_DWORD *)(v52 + 8);
          v52 += 20;
          if (v53 != *(_DWORD *)(v51 + 8))
          {
            unint64_t v51 = v52 - 20;
            goto LABEL_60;
          }
        }
      }
    }
    else
    {
      unint64_t v12 = v63;
      unint64_t v13 = v65;
    }
    if (v14) {
      goto LABEL_66;
    }
    goto LABEL_81;
  }
  LODWORD(v10) = 0;
  int v11 = 0;
  unint64_t v12 = 0;
  unint64_t v13 = 0;
  unsigned int v14 = 0;
LABEL_82:
  if (!FST_CheckQuery(v11, a3))
  {
    *uint64_t v4 = 0;
    return v67;
  }
  uint64_t result = FSTStatePool_PopFSTState(a1[6], v4);
  unsigned int v67 = result;
  if (result) {
    return result;
  }
  uint64_t v59 = (_DWORD *)*v4;
  v59[2] = *(_DWORD *)(*v4 + 8) | v11;
  v59[6] = v6;
  v59[7] = 0;
  if (!(v10 + v14))
  {
    uint64_t result = 0;
    v59[12] = 0;
    v59[8] = 0;
    return result;
  }
  if (a1[26] && v13)
  {
    uint64_t result = __FSTUnion_MergeAndCollectForcedOutputArcs((uint64_t)a1, v13, (uint64_t)v59);
    unsigned int v67 = result;
    if (result) {
      return result;
    }
    uint64_t v59 = (_DWORD *)*v4;
  }
  if (a1[24] && v12)
  {
    uint64_t result = __FSTUnion_MergeAndCollectComponentArcs((uint64_t)a1, v12, (uint64_t)v59);
    if (result) {
      return result;
    }
    uint64_t v59 = (_DWORD *)*v4;
  }
  uint64_t result = 0;
  if (v59[8]) {
    v59[2] |= 0x20000000u;
  }
  return result;
}

uint64_t __FSTUnion_MergeAndCollectForcedOutputArcs(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unsigned int v15 = 0;
  unsigned int v6 = *(int **)(a1 + 208);
  unsigned int v7 = -858993459 * ((a2 - (unint64_t)v6) >> 2);
  uint64_t v8 = *(_DWORD **)(a3 + 40);
  if (v8 && *(v8 - 1) > v7 || (uint64_t v8 = (_DWORD *)_FSTState_ReserveEpsilonArcsInternal(a3, v7, &v15), (result = v15) == 0))
  {
    if ((unint64_t)v6 >= a2)
    {
      int v10 = 0;
LABEL_19:
      uint64_t result = 0;
      *(_DWORD *)(a3 + 32) = v10;
    }
    else
    {
      int v10 = 0;
      while (1)
      {
        *(_DWORD *)(a1 + 160) = (*(void *)(a1 + 184) - *(void *)(a1 + 176)) >> 4;
        int v11 = v6;
        do
        {
          if (v11[3] != v6[3]) {
            break;
          }
          uint64_t result = __FSTUnion_AddToState(a1, *v11, v11[1], -2, 0);
          unsigned int v15 = result;
          if (result) {
            return result;
          }
          v11 += 5;
        }
        while ((unint64_t)v11 < a2);
        uint64_t result = __FSTUnion_InsertState(a1, v8);
        unsigned int v15 = result;
        if (result) {
          break;
        }
        int v12 = v6[3];
        int v13 = v6[4];
        v8[1] = -2;
        v8[2] = v12;
        v8[3] = v13;
        while (1)
        {
          v6 += 5;
          if ((unint64_t)v6 >= a2 || v6[3] != v12) {
            break;
          }
          int v14 = v6[4];
          if (v14 < v13)
          {
            v8[3] = v14;
            int v13 = v14;
          }
        }
        ++v10;
        v8 += 4;
        if ((unint64_t)v6 >= a2) {
          goto LABEL_19;
        }
      }
    }
  }
  return result;
}

uint64_t __FSTUnion_MergeAndCollectComponentArcs(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unsigned int v32 = 0;
  unsigned int v6 = *(int **)(a1 + 192);
  unsigned int v7 = -858993459 * ((a2 - (unint64_t)v6) >> 2);
  uint64_t v8 = *(_DWORD **)(a3 + 56);
  if (v8 && *(v8 - 1) > v7 || (uint64_t v8 = (_DWORD *)_FSTState_ReserveArcsInternal(a3, v7, &v32), (result = v32) == 0))
  {
    for (unsigned int i = *(_DWORD *)(a3 + 32); (unint64_t)v6 < a2; unsigned int i = v31)
    {
      if (v6[2] != -2) {
        break;
      }
      uint64_t v11 = *(void *)(a3 + 40);
      if (v11)
      {
        unsigned int v12 = i + 1;
        if (*(_DWORD *)(v11 - 4) > i + 1) {
          goto LABEL_11;
        }
      }
      else
      {
        unsigned int v12 = i + 1;
      }
      uint64_t v11 = _FSTState_ReserveEpsilonArcsInternal(a3, v12, &v32);
      uint64_t result = v32;
      if (v32) {
        return result;
      }
LABEL_11:
      int v13 = (_DWORD *)(v11 + 16 * i);
      unsigned int v31 = i + 1;
      *(_DWORD *)(a3 + 32) = i + 1;
      int v14 = v6[3];
      v13[1] = v6[2];
      v13[2] = v14;
      unsigned int v15 = v13 + 2;
      int v16 = v6[4];
      void v13[3] = v16;
      uint64_t v17 = v13 + 3;
      int v18 = v6 + 5;
      if ((unint64_t)(v6 + 5) < a2)
      {
        int v19 = v14;
        do
        {
          if (v18[2] != -2 || v18[3] != v14) {
            break;
          }
          BOOL v20 = v14 == v19;
          int v19 = v14;
          if (!v20)
          {
            int v19 = -2;
            *unsigned int v15 = -2;
          }
          int v21 = v18[4];
          if (v21 < v16)
          {
            *uint64_t v17 = v21;
            int v16 = v21;
          }
          v18 += 5;
        }
        while ((unint64_t)v18 < a2);
      }
      *(_DWORD *)(a1 + 160) = (*(void *)(a1 + 184) - *(void *)(a1 + 176)) >> 4;
      while (v6 < v18)
      {
        if (*v15 == v6[3]) {
          int v22 = -2;
        }
        else {
          int v22 = v6[3];
        }
        uint64_t result = __FSTUnion_AddToState(a1, *v6, v6[1], v22, v6[4] - *v17);
        unsigned int v32 = result;
        if (result) {
          return result;
        }
        v6 += 5;
      }
      uint64_t result = __FSTUnion_InsertState(a1, v13);
      unsigned int v32 = result;
      if (result) {
        return result;
      }
    }
    if ((unint64_t)v6 >= a2)
    {
      int v23 = 0;
LABEL_56:
      uint64_t result = 0;
      *(_DWORD *)(a3 + 48) = v23;
      *(_DWORD *)(a3 + 32) = i;
    }
    else
    {
      int v23 = 0;
      while (1)
      {
        int v25 = v6[2];
        int v24 = v6[3];
        v8[1] = v25;
        v8[2] = v24;
        int v26 = v6[4];
        v8[3] = v26;
        int v27 = v6 + 5;
        if (v25 == -1)
        {
          while ((unint64_t)v27 < a2 && v27[2] == -1 && v27[3] == v24)
          {
            int v29 = v27[4];
            if (v29 < v26)
            {
              v8[3] = v29;
              int v26 = v29;
            }
            v27 += 5;
          }
        }
        else
        {
          while ((unint64_t)v27 < a2 && v27[2] == v25)
          {
            if (v27[3] != v24)
            {
              int v24 = -2;
              v8[2] = -2;
            }
            int v28 = v27[4];
            if (v28 < v26)
            {
              v8[3] = v28;
              int v26 = v28;
            }
            v27 += 5;
          }
        }
        *(_DWORD *)(a1 + 160) = (*(void *)(a1 + 184) - *(void *)(a1 + 176)) >> 4;
        while (v6 < v27)
        {
          if (v8[2] == v6[3]) {
            int v30 = -2;
          }
          else {
            int v30 = v6[3];
          }
          uint64_t result = __FSTUnion_AddToState(a1, *v6, v6[1], v30, v6[4] - v8[3]);
          unsigned int v32 = result;
          if (result) {
            return result;
          }
          v6 += 5;
        }
        uint64_t result = __FSTUnion_InsertState(a1, v8);
        unsigned int v32 = result;
        if (result) {
          break;
        }
        ++v23;
        v8 += 4;
        if ((unint64_t)v6 >= a2) {
          goto LABEL_56;
        }
      }
    }
  }
  return result;
}

uint64_t FSTUnion_FetchStateLabel(void *a1, unsigned int a2, char **a3)
{
  unsigned int v33 = 0;
  uint64_t v4 = a1[17];
  if (((unint64_t)(a1[18] - v4) >> 3) <= a2)
  {
    *a3 = 0;
    return err_GenerateErrorArg();
  }
  else
  {
    uint64_t v6 = a1[3];
    unsigned int v7 = (unsigned int *)(a1[22] + 16 * *(unsigned int *)(v4 + 8 * a2 + 4));
    *a3 = 0;
    if (!*v7) {
      return 0;
    }
    LODWORD(v8) = 0;
    int v9 = 0;
    int v10 = (int *)(v7 + 4);
    do
    {
      int v11 = *v10;
      v10 += 4;
      --v9;
      uint64_t v8 = (v8 + 46);
    }
    while (v11);
    if (v9)
    {
      unsigned int v12 = (char *)OOCAllocator_Malloc(v6, v8, &v33);
      *a3 = v12;
      uint64_t result = v33;
      if (!v33)
      {
        if (*v7)
        {
          uint64_t v14 = (uint64_t)&v12[v8];
          while (1)
          {
            int v15 = spr_pcat_err(v12, v14, "s", "[", &v33);
            uint64_t result = v33;
            if (v33) {
              break;
            }
            int v16 = &v12[v15];
            int v17 = spr_ulcat_err(v16, v14, "d", *v7, &v33);
            uint64_t result = v33;
            if (v33) {
              break;
            }
            int v18 = &v16[v17];
            int v19 = spr_pcat_err(v18, v14, "s", ",", &v33);
            uint64_t result = v33;
            if (v33) {
              break;
            }
            BOOL v20 = &v18[v19];
            int v21 = spr_ulcat_err(v20, v14, "d", v7[1], &v33);
            uint64_t result = v33;
            if (v33) {
              break;
            }
            int v22 = &v20[v21];
            int v23 = spr_pcat_err(v22, v14, "s", ",", &v33);
            uint64_t result = v33;
            if (v33) {
              break;
            }
            int v24 = &v22[v23];
            int v25 = spr_lcat_err(v24, v14, "d", (int)v7[2], &v33);
            uint64_t result = v33;
            if (v33) {
              break;
            }
            int v26 = &v24[v25];
            int v27 = spr_pcat_err(v26, v14, "s", ",", &v33);
            uint64_t result = v33;
            if (v33) {
              break;
            }
            int v28 = &v26[v27];
            int v29 = spr_lcat_err(v28, v14, "d", (int)v7[3], &v33);
            uint64_t result = v33;
            if (v33) {
              break;
            }
            int v30 = &v28[v29];
            int v31 = spr_pcat_err(v30, v14, "s", "] ", &v33);
            uint64_t result = v33;
            if (v33) {
              break;
            }
            unsigned int v12 = &v30[v31];
            unsigned int v32 = v7[4];
            v7 += 4;
            if (!v32) {
              goto LABEL_19;
            }
          }
        }
        else
        {
LABEL_19:
          *(v12 - 1) = 0;
          return v33;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t FSTUnion_GetFinalStateWeight(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *a3 = 0;
  return 0;
}

uint64_t FSTUnion_GetInitialStateId(uint64_t a1, _DWORD *a2)
{
  int v7 = 0;
  *(_DWORD *)(a1 + 160) = (*(void *)(a1 + 184) - *(void *)(a1 + 176)) >> 4;
  if (!*(_WORD *)(a1 + 64)) {
    return __FSTUnion_InsertState(a1, a2);
  }
  uint64_t v4 = 0;
  while (1)
  {
    uint64_t v5 = *(void *)(*(void *)(a1 + 72) + 8 * v4);
    uint64_t result = (*(uint64_t (**)(uint64_t, int *))(*(void *)v5 + 48))(v5, &v7);
    if (result) {
      break;
    }
    if (v7 != -1)
    {
      uint64_t result = __FSTUnion_AddToState(a1, v4, v7, -2, 0);
      if (result) {
        break;
      }
    }
    if (++v4 >= (unint64_t)*(unsigned __int16 *)(a1 + 64)) {
      return __FSTUnion_InsertState(a1, a2);
    }
  }
  return result;
}

uint64_t __FSTUnion_AddToState(uint64_t a1, int a2, int a3, int a4, int a5)
{
  unsigned int v21 = 0;
  uint64_t v10 = *(void *)(a1 + 176);
  int v11 = *(_DWORD **)(a1 + 184);
  for (unsigned int i = (_DWORD *)(v10 + 16 * *(unsigned int *)(a1 + 160)); i < v11; i += 4)
  {
    if (*(unsigned __int16 *)i == a2 && i[1] == a3 && i[2] == a4)
    {
      uint64_t result = 0;
      if (i[3] > a5) {
        i[3] = a5;
      }
      return result;
    }
  }
  unint64_t v13 = (unint64_t)v11 - v10;
  unsigned int v14 = (((unint64_t)v11 - v10) >> 4) + 1;
  unsigned int v15 = *(_DWORD *)(a1 + 168);
  if (v14 <= v15)
  {
LABEL_17:
    *(void *)(a1 + 184) = v11 + 4;
    *int v11 = (unsigned __int16)a2;
    v11[1] = a3;
    v11[2] = a4;
    v11[3] = a5;
    return v21;
  }
  unsigned int v16 = 2 * v15;
  unsigned int v17 = v15 + 1000000;
  if (v16 >= v17) {
    unsigned int v16 = v17;
  }
  if (v16 <= v14) {
    unsigned int v16 = v14;
  }
  if (v16 <= 8) {
    unsigned int v18 = 8;
  }
  else {
    unsigned int v18 = v16;
  }
  uint64_t v19 = OOCAllocator_Realloc(*(void *)(a1 + 24), v10, 16 * v18, &v21);
  *(void *)(a1 + 176) = v19;
  uint64_t result = v21;
  if (!v21)
  {
    *(_DWORD *)(a1 + 168) = v18;
    int v11 = (_DWORD *)(v19 + (v13 & 0xFFFFFFFF0));
    goto LABEL_17;
  }
  return result;
}

uint64_t __FSTUnion_InsertState(uint64_t a1, _DWORD *a2)
{
  unsigned int v48 = 0;
  uint64_t v4 = *(void *)(a1 + 176);
  uint64_t v5 = *(unsigned int *)(a1 + 160);
  unsigned int v6 = ((unint64_t)(*(void *)(a1 + 184) - v4) >> 4) - v5;
  uint64_t v47 = *(void *)(a1 + 24);
  if (v6 >= 2)
  {
    lhstdlib_qsort(v4 + 16 * v5, v6, 0x10u, (uint64_t (*)(unsigned char *, unsigned char *))FSTUnionStateLess);
    uint64_t v4 = *(void *)(a1 + 176);
    LODWORD(v5) = *(_DWORD *)(a1 + 160);
  }
  *(_DWORD *)(v4 + 16 * v5) |= v6 << 16;
  unsigned int StateHash = __FSTUnion_GetStateHash(a1, v5);
  uint64_t v8 = *(unsigned int *)(*(void *)(a1 + 112)
                       + 4 * (StateHash % ((*(void *)(a1 + 120) - *(void *)(a1 + 112)) >> 2)));
  if ((v8 & 0x80000000) != 0)
  {
LABEL_23:
    LODWORD(v21) = *(_DWORD *)(a1 + 152);
    if (v21 == -1)
    {
      uint64_t v23 = *(void *)(a1 + 136);
      int v25 = *(_DWORD **)(a1 + 144);
      unint64_t v21 = ((unint64_t)v25 - v23) >> 3;
      int v26 = *(char **)(a1 + 112);
      unint64_t v27 = *(void *)(a1 + 120) - (void)v26;
      if (((v27 >> 1) & 0xFFFFFFFE) >= v21)
      {
        unint64_t v32 = ((unint64_t)v25 - v23) >> 3;
      }
      else
      {
        unsigned int v28 = (v27 >> 1) | 1;
        uint64_t v29 = *(unsigned int *)(a1 + 104);
        if (v28 <= v29)
        {
          unint64_t v46 = a2;
          uint64_t v31 = 4 * v29;
        }
        else
        {
          if (v28 <= 8) {
            unsigned int v30 = 8;
          }
          else {
            unsigned int v30 = (v27 >> 1) | 1;
          }
          uint64_t v31 = 4 * v30;
          int v26 = (char *)OOCAllocator_Realloc(v47, (uint64_t)v26, v31, &v48);
          *(void *)(a1 + 112) = v26;
          uint64_t result = v48;
          if (v48) {
            return result;
          }
          unint64_t v46 = a2;
          *(_DWORD *)(a1 + 104) = v30;
          v27 &= 0x3FFFFFFFCuLL;
        }
        unint64_t v33 = (v27 >> 1) & 0xFFFFFFFE | 1;
        *(void *)(a1 + 120) = &v26[4 * v33];
        cstdlib_memset(v26, 255, v31);
        uint64_t v23 = *(void *)(a1 + 136);
        int v25 = *(_DWORD **)(a1 + 144);
        unint64_t v32 = ((unint64_t)v25 - v23) >> 3;
        LODWORD(v21) = v32;
        if (v32)
        {
          uint64_t v34 = 0;
          uint64_t v35 = *(_DWORD **)(a1 + 136);
          do
          {
            if (((*v35 + 1) & 0x40000000) == 0)
            {
              unsigned int v36 = __FSTUnion_GetStateHash(a1, v35[1]);
              uint64_t result = v48;
              if (v48) {
                return result;
              }
              unint64_t v37 = v36 - (v36 / v33) * (unint64_t)v33;
              uint64_t v38 = *(void *)(a1 + 112);
              *uint64_t v35 = *(_DWORD *)(v38 + 4 * v37);
              *(_DWORD *)(v38 + 4 * v37) = v34;
            }
            ++v34;
            v35 += 2;
          }
          while ((((unint64_t)v25 - v23) >> 3) != v34);
          unint64_t v32 = ((unint64_t)v25 - v23) >> 3;
          a2 = v46;
        }
        else
        {
          a2 = v46;
        }
      }
      unsigned int v39 = v21 + 1;
      unsigned int v40 = *(_DWORD *)(a1 + 128);
      if ((int)v21 + 1 > v40)
      {
        unsigned int v41 = 2 * v40;
        unsigned int v42 = v40 + 1000000;
        if (v41 < v42) {
          unsigned int v42 = v41;
        }
        if (v42 > v39) {
          unsigned int v39 = v42;
        }
        if (v39 <= 8) {
          unsigned int v43 = 8;
        }
        else {
          unsigned int v43 = v39;
        }
        uint64_t v23 = OOCAllocator_Realloc(v47, v23, 8 * v43, &v48);
        *(void *)(a1 + 136) = v23;
        uint64_t result = v48;
        if (v48) {
          return result;
        }
        *(_DWORD *)(a1 + 128) = v43;
        int v25 = (_DWORD *)(v23 + 8 * v32);
      }
      *(void *)(a1 + 144) = v25 + 2;
      *int v25 = 0;
      v25[1] = v5;
      uint64_t v22 = (int)v21;
    }
    else
    {
      uint64_t v22 = (int)v21;
      uint64_t v23 = *(void *)(a1 + 136);
      int v24 = (_DWORD *)(v23 + 8 * (int)v21);
      *(_DWORD *)(a1 + 152) = (*v24 & 0xBFFFFFFF) - 1;
      *int v24 = 0;
      v24[1] = v5;
    }
    uint64_t v44 = *(void *)(a1 + 112);
    unsigned int v45 = StateHash % ((unint64_t)(*(void *)(a1 + 120) - v44) >> 2);
    *(_DWORD *)(v23 + 8 * v22) = *(_DWORD *)(v44 + 4 * v45);
    *(_DWORD *)(v44 + 4 * v45) = v21;
    *a2 = v21;
    return v48;
  }
  uint64_t v9 = *(void *)(a1 + 136);
  while (1)
  {
    uint64_t v10 = *(void *)(a1 + 176);
    int v11 = (_DWORD *)(v10 + 16 * v5);
    unsigned int v12 = (_DWORD *)(v10 + 16 * *(unsigned int *)(v9 + 8 * v8 + 4));
    unint64_t v13 = *v11;
    unint64_t v14 = v13 >> 16;
    if (HIWORD(*v11) == HIWORD(*v12)) {
      break;
    }
LABEL_13:
    uint64_t v9 = *(void *)(a1 + 136);
    uint64_t v8 = *(unsigned int *)(v9 + 8 * v8);
    if ((v8 & 0x80000000) != 0) {
      goto LABEL_23;
    }
  }
  if (v13 >= 0x10000 && *v12 >= 0x10000u)
  {
    unsigned int v15 = &v11[4 * v14];
    unsigned int v16 = &v12[4 * v14];
    while (!cstdlib_memcmp(v11, v12, 0x10uLL))
    {
      v11 += 4;
      if (v11 < v15)
      {
        v12 += 4;
        if (v12 < v16) {
          continue;
        }
      }
      if ((v8 & 0x80000000) != 0) {
        goto LABEL_23;
      }
      goto LABEL_16;
    }
    goto LABEL_13;
  }
LABEL_16:
  *a2 = v8;
  unsigned int v17 = *(_DWORD *)(a1 + 160);
  uint64_t v18 = *(void *)(a1 + 176);
  if (v17 <= *(_DWORD *)(a1 + 168)) {
    goto LABEL_22;
  }
  if (v17 <= 8) {
    unsigned int v19 = 8;
  }
  else {
    unsigned int v19 = *(_DWORD *)(a1 + 160);
  }
  uint64_t v18 = OOCAllocator_Realloc(v47, v18, 16 * v19, &v48);
  *(void *)(a1 + 176) = v18;
  uint64_t result = v48;
  if (!v48)
  {
    *(_DWORD *)(a1 + 168) = v19;
    unsigned int v17 = *(_DWORD *)(a1 + 160);
LABEL_22:
    uint64_t result = 0;
    *(void *)(a1 + 184) = v18 + 16 * v17;
  }
  return result;
}

uint64_t FSTUnion_GetMaxNbrComponentFsts(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 64);
}

uint64_t FSTUnion_GetMaxStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = -1;
  return 0;
}

uint64_t FSTUnion_GetMemoryInfo(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int16 *)(a1 + 64);
  uint64_t v2 = *(unsigned int *)(a1 + 168);
  uint64_t v3 = *(unsigned int *)(a1 + 104);
  uint64_t v4 = *(unsigned int *)(a1 + 128);
  uint64_t v5 = *(void *)(a1 + 200);
  uint64_t v6 = *(void *)(a1 + 216);
  if (*(_WORD *)(a1 + 64))
  {
    unint64_t v8 = 0;
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = *(void *)(*(void *)(a1 + 72) + 8 * v8);
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 96))(v10);
      v9 += v12 + v11;
      ++v8;
    }
    while (v8 < *(unsigned __int16 *)(a1 + 64));
  }
  return 4 * v3 + 16 * v2 + v5 + v6 + 8 * (v4 + v1);
}

uint64_t FSTUnion_GetStatus(uint64_t a1)
{
  if (!*(_WORD *)(a1 + 64)) {
    return 0;
  }
  unint64_t v2 = 0;
  LODWORD(v3) = 0;
  do
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 72) + 8 * v2);
    uint64_t v3 = (*(unsigned int (**)(uint64_t))(*(void *)v4 + 168))(v4) | v3;
    ++v2;
  }
  while (v2 < *(unsigned __int16 *)(a1 + 64));
  return v3;
}

uint64_t FSTUnion_Reset(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  unint64_t v3 = *(void *)(a1 + 112);
  unint64_t v4 = *(void *)(a1 + 120);
  if (v3 < v4)
  {
    if (v4 <= v3 + 4) {
      unint64_t v4 = v3 + 4;
    }
    memset((void *)v3, 255, ((v4 + ~v3) & 0xFFFFFFFFFFFFFFFCLL) + 4);
  }
  *(_DWORD *)(a1 + 128) = 0;
  uint64_t v5 = *(void *)(a1 + 136);
  if (v5)
  {
    OOCAllocator_Free(v2, v5);
    *(void *)(a1 + 136) = 0;
  }
  *(void *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 152) = -1;
  *(_DWORD *)(a1 + 168) = 0;
  uint64_t v6 = *(void *)(a1 + 176);
  if (v6)
  {
    OOCAllocator_Free(v2, v6);
    *(void *)(a1 + 176) = 0;
  }
  *(void *)(a1 + 184) = 0;
  if (!*(void *)(a1 + 72) || !*(_WORD *)(a1 + 64)) {
    return 0;
  }
  uint64_t v7 = 0;
  while (1)
  {
    uint64_t v8 = *(void *)(*(void *)(a1 + 72) + 8 * v7);
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 112))(v8);
    if (result) {
      break;
    }
    if (++v7 >= (unint64_t)*(unsigned __int16 *)(a1 + 64)) {
      return 0;
    }
  }
  return result;
}

double FSTUnion_SetStatePool(uint64_t a1, uint64_t a2)
{
  if (*(_WORD *)(a1 + 64))
  {
    uint64_t v4 = 0;
    while (1)
    {
      uint64_t v5 = *(void *)(*(void *)(a1 + 72) + 8 * v4);
      if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v5 + 128))(v5, a2)) {
        break;
      }
      if (++v4 >= (unint64_t)*(unsigned __int16 *)(a1 + 64)) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    return FST_SetStatePool(a1, a2);
  }
  return result;
}

void *GetFSTUnionClass()
{
  return &__FSTUnion;
}

uint64_t FSTUnionStateLess(_DWORD *a1, _DWORD *a2)
{
  unsigned int v2 = *(unsigned __int16 *)a1;
  unsigned int v3 = *(unsigned __int16 *)a2;
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  if (v2 > v3) {
    return 1;
  }
  unsigned int v4 = a1[1];
  unsigned int v5 = a2[1];
  if (v4 < v5) {
    return 0xFFFFFFFFLL;
  }
  if (v4 > v5) {
    return 1;
  }
  int v6 = a1[2];
  int v7 = a2[2];
  if (v6 < v7) {
    return 0xFFFFFFFFLL;
  }
  if (v6 > v7) {
    return 1;
  }
  int v9 = a1[3];
  int v10 = a2[3];
  BOOL v11 = v9 < v10;
  BOOL v12 = v9 > v10;
  if (v11) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v12;
  }
}

uint64_t __FSTUnion_GetStateHash(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = (unsigned int *)(*(void *)(a1 + 176) + 16 * a2);
  unint64_t v3 = *v2;
  if (v3 < 0x10000) {
    return 0;
  }
  LODWORD(result) = 0;
  unsigned int v5 = (unsigned int *)((char *)v2 + ((v3 >> 12) & 0xFFFF0));
  do
  {
    uint64_t result = v2[3] + 2309 * (v2[2] + 2309 * (v2[1] + 2309 * (*v2 + 2309 * result)));
    v2 += 4;
  }
  while (v2 < v5);
  return result;
}

uint64_t FSTUnionArcInputLess(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 == -2) {
    return 0xFFFFFFFFLL;
  }
  int v4 = *(_DWORD *)(a2 + 8);
  if (v4 == -2) {
    return 1;
  }
  if (v2 >= v4) {
    int v5 = v2 > v4;
  }
  else {
    int v5 = -1;
  }
  if (v4 == -1) {
    unsigned int v6 = 1;
  }
  else {
    unsigned int v6 = v5;
  }
  if (v2 == -1) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v6;
  }
}

uint64_t FSTUnionArcOutputLess(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 12);
  int v3 = *(_DWORD *)(a2 + 12);
  BOOL v4 = v2 < v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v5;
  }
}

uint64_t FSTStateQueueTopoSort_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    long long v28 = 0u;
    memset(v27, 0, sizeof(v27));
    *(void *)a1 = &__FSTStateQueueTopoSort;
    *(void *)(a1 + 8) = &unk_26D216F18;
    *(void *)(a1 + 16) = a2;
    *(void *)(a1 + 48) = a2;
    *(void *)(a1 + 80) = 0xFFFFFFFF00000000;
    uint64_t result = FSTTopoSort_Con((uint64_t)v27, a2, a3);
    if (!result)
    {
      uint64_t result = FSTDfsContext_Dfs((uint64_t)v27);
      unsigned int v29 = result;
      if (!result)
      {
        *(void *)(a1 + 32) = 0;
        *(_DWORD *)(a1 + 24) = 0;
        *(void *)(a1 + 40) = 0;
        int v7 = *(_DWORD *)(v28 + 32);
        int v8 = v7 - 1;
        if (v7 < 1)
        {
          unsigned int v23 = 1;
        }
        else
        {
          uint64_t v9 = 0;
          unint64_t v10 = 0;
          unsigned int v11 = 0;
          unsigned int v12 = 0;
          do
          {
            uint64_t v13 = *(unsigned int *)(*(void *)(*(void *)(v28 + 8) + 8 * (v11 >> *(_WORD *)(v28 + 44)))
                                  + 4 * (v11 & ~(-1 << *(_WORD *)(v28 + 44))));
            uint64_t v14 = (v13 + 1);
            unint64_t v15 = v10 - v9;
            if (v14 >= ((v10 - v9) >> 2))
            {
              unsigned int v16 = *(_DWORD *)(a1 + 24);
              if (v14 > v16)
              {
                unsigned int v17 = 2 * v16;
                unsigned int v18 = v16 + 1000000;
                if (v17 < v18) {
                  unsigned int v18 = v17;
                }
                if (v18 <= v14) {
                  unsigned int v18 = v13 + 1;
                }
                if (v18 <= 8) {
                  unsigned int v19 = 8;
                }
                else {
                  unsigned int v19 = v18;
                }
                uint64_t v9 = OOCAllocator_Realloc(a2, v9, 4 * v19, &v29);
                *(void *)(a1 + 32) = v9;
                uint64_t result = v29;
                if (v29) {
                  return result;
                }
                *(_DWORD *)(a1 + 24) = v19;
                unint64_t v10 = v9 + (v15 & 0x3FFFFFFFCLL);
                *(void *)(a1 + 40) = v10;
              }
              if (v10 < v9 + 4 * v14)
              {
                unint64_t v20 = v9 + 4 * v14;
                unint64_t v21 = v10 + 4;
                if (v20 <= v10 + 4) {
                  unint64_t v20 = v10 + 4;
                }
                unint64_t v22 = (v20 + ~v10) & 0xFFFFFFFFFFFFFFFCLL;
                memset((void *)v10, 255, v22 + 4);
                unint64_t v10 = v21 + v22;
                *(void *)(a1 + 40) = v21 + v22;
              }
            }
            *(_DWORD *)(v9 + 4 * v13) = v8;
            if (v13 > v12) {
              unsigned int v12 = v13;
            }
            ++v11;
            --v8;
          }
          while (v8 != -1);
          unsigned int v23 = v12 + 1;
        }
        uint64_t result = (*(uint64_t (**)(_OWORD *))(*(void *)&v27[0] + 16))(v27);
        unsigned int v29 = result;
        if (!result)
        {
          *(_DWORD *)(a1 + 56) = v23;
          uint64_t v24 = OOCAllocator_Malloc(a2, 4 * v23, &v29);
          *(void *)(a1 + 64) = v24;
          uint64_t result = v29;
          if (!v29)
          {
            uint64_t v25 = *(unsigned int *)(a1 + 56);
            unint64_t v26 = v24 + 4 * v25;
            *(void *)(a1 + 72) = v26;
            if (v25)
            {
              if (v26 <= v24 + 4) {
                unint64_t v26 = v24 + 4;
              }
              memset((void *)v24, 255, ((v26 + ~v24) & 0xFFFFFFFFFFFFFFFCLL) + 4);
              return v29;
            }
            else
            {
              return 0;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t FSTStateQueueTopoSort_ConFromOrder(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  uint64_t v10 = Object_Con((void *)a1);
  unsigned int v15 = v10;
  if (!v10)
  {
    *(void *)a1 = &__FSTStateQueueTopoSort;
    *(void *)(a1 + 8) = &unk_26D216F18;
    *(void *)(a1 + 16) = a2;
    *(void *)(a1 + 80) = 0xFFFFFFFF00000000;
    *(_DWORD *)(a1 + 24) = a4;
    *(void *)(a1 + 32) = a3;
    *(void *)(a1 + 40) = a3 + 4 * a4;
    *(void *)(a1 + 48) = a5;
    *(_DWORD *)(a1 + 56) = a4 + 1;
    uint64_t v11 = OOCAllocator_Malloc(a2, 4 * (a4 + 1), &v15);
    *(void *)(a1 + 64) = v11;
    uint64_t v10 = v15;
    if (!v15)
    {
      uint64_t v12 = *(unsigned int *)(a1 + 56);
      unint64_t v13 = v11 + 4 * v12;
      *(void *)(a1 + 72) = v13;
      if (v12)
      {
        if (v13 <= v11 + 4) {
          unint64_t v13 = v11 + 4;
        }
        memset((void *)v11, 255, ((v13 + ~v11) & 0xFFFFFFFFFFFFFFFCLL) + 4);
        return v15;
      }
      else
      {
        return 0;
      }
    }
  }
  return v10;
}

uint64_t FSTStateQueueTopoSort_Des(uint64_t *a1)
{
  uint64_t v2 = a1[4];
  if (v2) {
    OOCAllocator_Free(a1[6], v2);
  }
  uint64_t v3 = a1[8];
  if (v3) {
    OOCAllocator_Free(a1[2], v3);
  }

  return Object_Des();
}

uint64_t FSTStateQueueTopoSort_Clear(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 80);
  if ((int)v1 <= *(_DWORD *)(a1 + 84))
  {
    uint64_t v2 = *(void *)(a1 + 64);
    do
      *(_DWORD *)(v2 + 4 * v1) = -1;
    while (v1++ < *(int *)(a1 + 84));
  }
  *(void *)(a1 + 80) = 0xFFFFFFFF00000000;
  return 0;
}

uint64_t FSTStateQueueTopoSort_Dequeue(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 64);
  *(_DWORD *)(v1 + 4 * *(int *)(a1 + 80)) = -1;
  int v2 = *(_DWORD *)(a1 + 84);
  uint64_t v3 = *(int *)(a1 + 80);
  if ((int)v3 <= v2)
  {
    BOOL v4 = (int *)(v1 + 4 * v3);
    int v5 = v3 - 1;
    do
    {
      int v6 = *v4++;
      if (v6 != -1) {
        break;
      }
      *(_DWORD *)(a1 + 80) = v5 + 2;
      ++v5;
    }
    while (v2 != v5);
  }
  return 0;
}

uint64_t FSTStateQueueTopoSort_Enqueue(uint64_t a1, unsigned int a2)
{
  int v2 = *(_DWORD *)(a1 + 80);
  int v3 = *(_DWORD *)(a1 + 84);
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = *(_DWORD *)(v4 + 4 * a2);
  if (v2 > v3)
  {
    *(_DWORD *)(a1 + 80) = v5;
    int v5 = *(_DWORD *)(v4 + 4 * a2);
LABEL_4:
    *(_DWORD *)(a1 + 84) = v5;
    goto LABEL_5;
  }
  if (v5 > v3) {
    goto LABEL_4;
  }
  if (v5 < v2) {
    *(_DWORD *)(a1 + 80) = v5;
  }
LABEL_5:
  *(_DWORD *)(*(void *)(a1 + 64) + 4 * *(int *)(v4 + 4 * a2)) = a2;
  return 0;
}

uint64_t FSTStateQueueTopoSort_Head(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 64) + 4 * *(int *)(a1 + 80));
}

BOOL FSTStateQueueTopoSort_IsEmpty(uint64_t a1)
{
  return *(_DWORD *)(a1 + 80) > *(_DWORD *)(a1 + 84);
}

uint64_t FSTStateQueueTopoSort_Update()
{
  return 0;
}

uint64_t PNEW_FSTStateQueueTopoSort_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 88, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = FSTStateQueueTopoSort_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t PNEW_FSTStateQueueTopoSort_ConFromOrder(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 88, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = FSTStateQueueTopoSort_ConFromOrder(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *a6 = v12;
    }
  }
  return result;
}

void *GetFSTStateQueueTopoSortClass()
{
  return &__FSTStateQueueTopoSort;
}

uint64_t FSTCompactCodec_GetArcSize(unsigned int *a1)
{
  unsigned int ArcEncoding = __FSTCompactCodec_GetArcEncoding(a1);
  uint64_t v2 = (ArcEncoding & 3) + 2;
  int v3 = ArcEncoding & 0xC;
  uint64_t v4 = v2 + 4;
  uint64_t v5 = v2 + 2;
  if (v3 == 4) {
    ++v2;
  }
  if (v3 == 8) {
    uint64_t v2 = v5;
  }
  if (v3 == 12) {
    uint64_t v2 = v4;
  }
  int v6 = ArcEncoding & 0x30;
  uint64_t v7 = v2 + 4;
  uint64_t v8 = v2 + 2;
  if (v6 == 16) {
    ++v2;
  }
  if (v6 == 32) {
    uint64_t v2 = v8;
  }
  if (v6 == 48) {
    uint64_t v2 = v7;
  }
  int v9 = ArcEncoding & 0xC0;
  uint64_t v10 = v2 + 2;
  uint64_t v11 = v2 + 4;
  if (ArcEncoding <= 0xBF) {
    uint64_t v11 = v2;
  }
  if (v9 == 64) {
    uint64_t v12 = v2 + 1;
  }
  else {
    uint64_t v12 = v11;
  }
  if (v9 == 128) {
    return v10;
  }
  else {
    return v12;
  }
}

uint64_t __FSTCompactCodec_GetArcEncoding(unsigned int *a1)
{
  unsigned int v1 = *a1;
  int v2 = a1[1];
  if (HIBYTE(*a1)) {
    char v3 = 3;
  }
  else {
    char v3 = 2;
  }
  if (v1 >= 0x10000) {
    unsigned __int8 v4 = v3;
  }
  else {
    unsigned __int8 v4 = 1;
  }
  if (v1 < 0x100) {
    unsigned __int8 v4 = 0;
  }
  if (HIWORD(v2)) {
    unsigned __int8 v5 = v4 | 0xC;
  }
  else {
    unsigned __int8 v5 = v4 | 8;
  }
  if (v2 <= 0xFF) {
    unsigned __int8 v5 = v4 | 4;
  }
  if (v2 < 0) {
    unsigned __int8 v5 = v4 | 0xC;
  }
  if (v2 != -2) {
    unsigned __int8 v4 = v5;
  }
  int v7 = a1[2];
  unsigned int v6 = a1[3];
  if (HIWORD(v7)) {
    unsigned __int8 v8 = v4 | 0x30;
  }
  else {
    unsigned __int8 v8 = v4 | 0x20;
  }
  if (v7 <= 0xFF) {
    unsigned __int8 v8 = v4 | 0x10;
  }
  if (v7 < 0) {
    unsigned __int8 v8 = v4 | 0x30;
  }
  if (v7 != -2) {
    unsigned __int8 v4 = v8;
  }
  if (v6)
  {
    if ((v6 & 0x80000000) != 0)
    {
      v4 |= 0xC0u;
    }
    else
    {
      if (HIWORD(v6)) {
        unsigned __int8 v9 = v4 | 0xC0;
      }
      else {
        unsigned __int8 v9 = v4 | 0x80;
      }
      v4 |= 0x40u;
      if (v6 > 0xFF) {
        return v9;
      }
    }
  }
  return v4;
}

uint64_t FSTCompactCodec_EncodeArcInc(unsigned int *a1, void *a2)
{
  uint64_t result = __FSTCompactCodec_GetArcEncoding(a1);
  unsigned __int8 v5 = (unsigned char *)*a2;
  unsigned int v6 = (unsigned char *)*a2;
  unsigned char *v6 = result;
  int v7 = v6 + 1;
  if ((result & 3) == 2)
  {
    unsigned int v8 = *a1;
    v5[1] = BYTE2(*a1);
    int v7 = v5 + 3;
    void v5[2] = BYTE1(v8);
    uint64_t v9 = 4;
  }
  else if ((result & 3) == 1)
  {
    unsigned int v8 = *a1;
    int v7 = v5 + 2;
    v5[1] = BYTE1(*a1);
    uint64_t v9 = 3;
  }
  else
  {
    unsigned int v8 = *a1;
    if ((result & 3) != 0)
    {
      v5[1] = HIBYTE(*a1);
      void v5[2] = BYTE2(v8);
      int v7 = v5 + 4;
      v5[3] = BYTE1(v8);
      uint64_t v9 = 5;
    }
    else
    {
      uint64_t v9 = 2;
    }
  }
  uint64_t v10 = &v5[v9];
  unsigned char *v7 = v8;
  int v11 = result & 0xC;
  switch(v11)
  {
    case 12:
      unsigned int v12 = a1[1];
      *uint64_t v10 = HIBYTE(v12);
      v10[1] = BYTE2(v12);
      unsigned int v14 = v10 + 3;
      v10[2] = BYTE1(v12);
      uint64_t v13 = 4;
      break;
    case 8:
      unsigned int v12 = a1[1];
      *uint64_t v10 = BYTE1(v12);
      unsigned int v14 = v10 + 1;
      uint64_t v13 = 2;
      break;
    case 4:
      unsigned int v12 = a1[1];
      uint64_t v13 = 1;
      unsigned int v14 = v10;
      break;
    default:
      goto LABEL_15;
  }
  v10 += v13;
  *unsigned int v14 = v12;
LABEL_15:
  int v15 = result & 0x30;
  switch(v15)
  {
    case 48:
      unsigned int v16 = a1[2];
      *uint64_t v10 = HIBYTE(v16);
      v10[1] = BYTE2(v16);
      unsigned int v18 = v10 + 3;
      v10[2] = BYTE1(v16);
      uint64_t v17 = 4;
      break;
    case 32:
      unsigned int v16 = a1[2];
      *uint64_t v10 = BYTE1(v16);
      unsigned int v18 = v10 + 1;
      uint64_t v17 = 2;
      break;
    case 16:
      unsigned int v16 = a1[2];
      uint64_t v17 = 1;
      unsigned int v18 = v10;
      break;
    default:
      goto LABEL_22;
  }
  v10 += v17;
  *unsigned int v18 = v16;
LABEL_22:
  if ((result & 0xC0) == 0x80)
  {
    unsigned int v19 = a1[3];
    *uint64_t v10 = BYTE1(v19);
    unint64_t v21 = v10 + 1;
    uint64_t v20 = 2;
    goto LABEL_28;
  }
  if ((result & 0xC0) == 0x40)
  {
    unsigned int v19 = a1[3];
    uint64_t v20 = 1;
    unint64_t v21 = v10;
LABEL_28:
    v10 += v20;
    *unint64_t v21 = v19;
    goto LABEL_29;
  }
  if (result >= 0xC0)
  {
    unsigned int v19 = a1[3];
    *uint64_t v10 = HIBYTE(v19);
    v10[1] = BYTE2(v19);
    unint64_t v21 = v10 + 3;
    v10[2] = BYTE1(v19);
    uint64_t v20 = 4;
    goto LABEL_28;
  }
LABEL_29:
  *a2 = v10;
  return result;
}

uint64_t FSTCompactCodec_EncodeArc(unsigned int *a1, uint64_t a2, void *a3)
{
  uint64_t v6 = a2;
  uint64_t result = FSTCompactCodec_EncodeArcInc(a1, &v6);
  *a3 = v6 - a2;
  return result;
}

int *FSTCompactCodec_DecodeArcInc(int *result, unsigned int **a2)
{
  int v2 = *a2;
  char v3 = *(unsigned char *)*a2;
  if ((v3 & 3) == 2)
  {
    *uint64_t result = (*((unsigned __int8 *)v2 + 1) << 16) | (*((unsigned __int8 *)v2 + 2) << 8) | *((unsigned __int8 *)v2 + 3);
    unsigned __int8 v4 = v2 + 1;
  }
  else if ((v3 & 3) == 1)
  {
    *uint64_t result = __rev16(*(unsigned __int16 *)((char *)v2 + 1));
    unsigned __int8 v4 = (unsigned int *)((char *)v2 + 3);
  }
  else if ((v3 & 3) != 0)
  {
    *uint64_t result = bswap32(*(unsigned int *)((char *)v2 + 1));
    unsigned __int8 v4 = (unsigned int *)((char *)v2 + 5);
  }
  else
  {
    unsigned __int8 v4 = (unsigned int *)((char *)v2 + 2);
    *uint64_t result = *((unsigned __int8 *)v2 + 1);
  }
  if ((v3 & 0xC) == 8)
  {
    unsigned int v6 = *(unsigned __int16 *)v4;
    unsigned __int8 v4 = (unsigned int *)((char *)v4 + 2);
    unsigned int v5 = __rev16(v6);
  }
  else if ((v3 & 0xC) == 4)
  {
    unsigned int v7 = *(unsigned __int8 *)v4;
    unsigned __int8 v4 = (unsigned int *)((char *)v4 + 1);
    unsigned int v5 = v7;
  }
  else if ((v3 & 0xC) != 0)
  {
    unsigned int v8 = *v4++;
    unsigned int v5 = bswap32(v8);
  }
  else
  {
    unsigned int v5 = -2;
  }
  result[1] = v5;
  if ((v3 & 0x30) == 0x20)
  {
    unsigned int v10 = *(unsigned __int16 *)v4;
    unsigned __int8 v4 = (unsigned int *)((char *)v4 + 2);
    unsigned int v9 = __rev16(v10);
  }
  else if ((v3 & 0x30) == 0x10)
  {
    unsigned int v11 = *(unsigned __int8 *)v4;
    unsigned __int8 v4 = (unsigned int *)((char *)v4 + 1);
    unsigned int v9 = v11;
  }
  else if ((v3 & 0x30) != 0)
  {
    unsigned int v12 = *v4++;
    unsigned int v9 = bswap32(v12);
  }
  else
  {
    unsigned int v9 = -2;
  }
  result[2] = v9;
  int v13 = v3 & 0xC0;
  if (v13 == 128)
  {
    unsigned int v14 = *(unsigned __int16 *)v4;
    unsigned __int8 v4 = (unsigned int *)((char *)v4 + 2);
    unsigned int v15 = __rev16(v14);
LABEL_29:
    result[3] = v15;
    goto LABEL_30;
  }
  if (v13 == 64)
  {
    unsigned int v16 = *(unsigned __int8 *)v4;
    unsigned __int8 v4 = (unsigned int *)((char *)v4 + 1);
    unsigned int v15 = v16;
    goto LABEL_29;
  }
  if (v13)
  {
    unsigned int v17 = *v4++;
    unsigned int v15 = bswap32(v17);
    goto LABEL_29;
  }
  result[3] = 0;
LABEL_30:
  *a2 = v4;
  return result;
}

int *FSTCompactCodec_DecodeArc(unsigned int *a1, int *a2, void *a3)
{
  unsigned int v6 = a1;
  uint64_t result = FSTCompactCodec_DecodeArcInc(a2, &v6);
  *a3 = (char *)v6 - (char *)a1;
  return result;
}

uint64_t FSTCompactCodec_ScanEncodedArc(uint64_t *a1)
{
  char v1 = *(unsigned char *)*a1;
  uint64_t v2 = (v1 & 3) + *a1 + 2;
  int v3 = v1 & 0xC;
  if ((v1 & 0xC) != 0)
  {
    if (v3 == 4) {
      uint64_t v2 = (v1 & 3) + *a1 + 3;
    }
    else {
      uint64_t v2 = (v1 & 3) + *a1 + 6;
    }
    if (v3 == 8) {
      uint64_t v2 = (v1 & 3) + *a1 + 4;
    }
    uint64_t v4 = 0;
  }
  else
  {
    uint64_t v4 = 1;
  }
  int v5 = v1 & 0x30;
  if ((*(unsigned char *)*a1 & 0x30) != 0)
  {
    uint64_t v6 = v2 + 2;
    if (v5 == 16) {
      ++v2;
    }
    else {
      v2 += 4;
    }
    if (v5 == 32) {
      uint64_t v2 = v6;
    }
  }
  int v7 = v1 & 0xC0;
  if (v7)
  {
    uint64_t v8 = v2 + 2;
    if (v7 == 64) {
      ++v2;
    }
    else {
      v2 += 4;
    }
    if (v7 == 128) {
      uint64_t v2 = v8;
    }
  }
  *a1 = v2;
  return v4;
}

uint64_t FSTMapStates_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = _FSTUnaryOperator_Con(a1, a2, a3);
  if (!result)
  {
    *(void *)a1 = &__FSTMapStates;
    *(_DWORD *)(a1 + 32) = 7;
    *(void *)(a1 + 72) = a4;
  }
  return result;
}

uint64_t FSTMapStates_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  if (*(void *)(v2 + 8))
  {
    OOCAllocator_Free(*(void *)(a1 + 24), *(void *)(v2 + 8));
    uint64_t v2 = *(void *)(a1 + 72);
  }
  OOCAllocator_Free(*(void *)(a1 + 24), v2);

  return FSTUnaryOperator_Des(a1);
}

uint64_t FSTMapStates_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = 0;
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, a3, &v22);
  if (!result)
  {
    uint64_t v7 = v22;
    if (!v22)
    {
LABEL_18:
      uint64_t result = 0;
      *a4 = v7;
      return result;
    }
    if ((*(_DWORD *)(v22 + 8) & 0x3FFFFFE) == 0)
    {
LABEL_8:
      uint64_t v9 = *(unsigned int *)(v7 + 48);
      if (v9)
      {
        unsigned int v10 = *(_DWORD **)(v7 + 56);
        unsigned int v11 = &v10[4 * v9];
        uint64_t v12 = *(void *)(*(void *)(a1 + 72) + 8);
        unint64_t v13 = (unint64_t)(*(void *)(*(void *)(a1 + 72) + 16) - v12) >> 2;
        do
        {
          uint64_t v14 = *v10;
          if (v14 < v13) {
            *unsigned int v10 = *(_DWORD *)(v12 + 4 * v14);
          }
          v10 += 4;
        }
        while (v10 < v11);
      }
      uint64_t v15 = *(unsigned int *)(v7 + 32);
      if (v15)
      {
        unsigned int v16 = *(_DWORD **)(v7 + 40);
        unsigned int v17 = &v16[4 * v15];
        uint64_t v18 = *(void *)(*(void *)(a1 + 72) + 8);
        unint64_t v19 = (unint64_t)(*(void *)(*(void *)(a1 + 72) + 16) - v18) >> 2;
        do
        {
          uint64_t v20 = *v16;
          if (v20 < v19) {
            _DWORD *v16 = *(_DWORD *)(v18 + 4 * v20);
          }
          v16 += 4;
        }
        while (v16 < v17);
      }
      goto LABEL_18;
    }
    uint64_t v21 = 0;
    uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v21);
    if (!result)
    {
      uint64_t result = FSTState_Copy(v21, v22);
      if (!result)
      {
        int v8 = *(_DWORD *)(v22 + 8);
        *(_DWORD *)(v22 + 8) = v8 - 1;
        if ((v8 & 0x3FFFFFF) == 0) {
          return 9;
        }
        uint64_t v7 = v21;
        goto LABEL_8;
      }
    }
  }
  return result;
}

uint64_t FSTMapStates_FillBuffer(uint64_t a1, char *a2, uint64_t *a3)
{
  uint64_t v10 = 0;
  if (a2)
  {
    uint64_t v10 = *a3;
    uint64_t result = FST_FillHeader((_DWORD *)a1, a2, 1, &v10);
    if (result) {
      return result;
    }
    uint64_t v7 = v10;
    int v8 = &a2[v10];
    uint64_t v9 = *a3 - v10;
  }
  else
  {
    *a3 = 0;
    uint64_t result = FST_GetHeaderSizeInOutputBuffer(&v10);
    if (result) {
      return result;
    }
    uint64_t v9 = 0;
    int v8 = 0;
    uint64_t v7 = v10;
  }
  uint64_t v10 = v9;
  uint64_t result = (*(uint64_t (**)(void, char *, uint64_t *))(**(void **)(a1 + 64) + 80))(*(void *)(a1 + 64), v8, &v10);
  if (!result) {
    *a3 = v10 + v7;
  }
  return result;
}

uint64_t FSTMapStates_GetInitialStateId(uint64_t a1, unsigned int *a2)
{
  unsigned int v7 = 0;
  uint64_t result = (*(uint64_t (**)(void, unsigned int *))(**(void **)(a1 + 64) + 48))(*(void *)(a1 + 64), &v7);
  if (!result)
  {
    unsigned int v5 = v7;
    if (v7 != -1)
    {
      uint64_t v6 = *(void *)(*(void *)(a1 + 72) + 8);
      if (v7 < ((unint64_t)(*(void *)(*(void *)(a1 + 72) + 16) - v6) >> 2)) {
        unsigned int v5 = *(_DWORD *)(v6 + 4 * v7);
      }
    }
    *a2 = v5;
  }
  return result;
}

uint64_t FSTMapStates_GetMappedStateId(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 72) + 8);
  if (((unint64_t)(*(void *)(*(void *)(a1 + 72) + 16) - v2) >> 2) <= a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *(unsigned int *)(v2 + 4 * a2);
  }
}

uint64_t FSTMapStates_GetMemoryInfo(uint64_t a1)
{
  return FSTUnaryOperator_GetMemoryInfo(a1) + 4 * **(unsigned int **)(a1 + 72) + 8;
}

uint64_t FSTMapStates_GetStateFlags(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 56))(*(void *)(a1 + 64));
}

uint64_t PNEW_FSTMapStates_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  unsigned int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 80, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = _FSTUnaryOperator_Con(v10, a2, a3);
    if (result)
    {
      unsigned int v12 = result;
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *(void *)uint64_t v10 = &__FSTMapStates;
      *(_DWORD *)(v10 + 32) = 7;
      *(void *)(v10 + 72) = a4;
      *(void *)(v10 + 16) = a1;
      *a5 = v10;
    }
  }
  return result;
}

void *GetFSTMapStatesClass()
{
  return &__FSTMapStates;
}

void FSTStreamedCompactRnd_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  int v29 = 0;
  int v30 = 0;
  unint64_t v27 = 0;
  long long v28 = 0;
  FST_AllocateExtendedHeaderFromRandomReader(a2, a4, 24, (const void **)&v28, &v27, &v29, &v30);
  if (!v8)
  {
    if (v30 != 43) {
      goto LABEL_13;
    }
    unint64_t v10 = v27;
    uint64_t v9 = v28;
    v28[2] = 44;
    double v11 = _FSTBaseFlat_Con((void *)a1, a2, a3, v10, v9, a2, 3u);
    if (v12) {
      return;
    }
    *(void *)a1 = &__FSTStreamedCompactRnd;
    *(void *)(a1 + 112) = a4;
    *(void *)(a1 + 144) = 0;
    *(void *)(a1 + 152) = 0;
    (*(void (**)(uint64_t, double))(*(void *)a4 + 48))(a4 - *(void *)(*(void *)a4 + 56), v11);
    if (v29 == 1)
    {
      unint64_t v13 = (char *)v28 + v10;
      uint64_t v15 = *(unsigned int *)((char *)v28 + v10 - 8);
      int v14 = *((_DWORD *)v13 - 1);
      *(void *)(a1 + 128) = 0;
      *(_DWORD *)(a1 + 136) = v14;
      *(_DWORD *)(a1 + 120) = *((_DWORD *)v13 - 3);
      if (!dpmemblock_Create(a2, 8, 0x400u, (uint64_t *)(a1 + 128))
        && !(**(unsigned int (***)(uint64_t, uint64_t))a4)(a4 - *(void *)(*(void *)a4 + 56), v15)
        && *(_DWORD *)(a1 + 120))
      {
        unsigned int v16 = 0;
        do
        {
          if ((*(unsigned int (**)(uint64_t, unsigned char *, uint64_t))(*(void *)a4 + 8))(a4 - *(void *)(*(void *)a4 + 56), v31, 8))
          {
            break;
          }
          int v25 = v31[0];
          int v17 = v31[1];
          int v18 = v31[2];
          int v19 = v31[3];
          int v20 = v31[4];
          int v21 = v31[5];
          int v22 = v31[6];
          int v23 = v31[7];
          unint64_t v26 = 0;
          if (dpmemblock_GetNewElement(*(void *)(a1 + 128), &v26, 0)) {
            break;
          }
          uint64_t v24 = v26;
          *unint64_t v26 = (v20 << 24) | (v21 << 16) | (v22 << 8) | v23;
          v24[1] = (v25 << 24) | (v17 << 16) | (v18 << 8) | v19;
          ++v16;
        }
        while (v16 < *(_DWORD *)(a1 + 120));
      }
    }
    else
    {
LABEL_13:
      err_GenerateErrorData();
    }
  }
}

void FSTStreamedCompactRnd_ConFromIStream(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *a1 = &__FSTStreamedCompactRnd;
  uint64_t v9 = 0;
  if (!PNEW_DataSectionRandomReader_Con(a2, a2, a4, a5, 0, 0, 0xFFFFFFFF, 0, &v9))
  {
    FSTStreamedCompactRnd_Con((uint64_t)a1, a2, a3, v9 + 24);
    if (!v8) {
      (*(void (**)(uint64_t))(*(void *)v9 + 32))(v9);
    }
  }
}

uint64_t FSTStreamedCompactRnd_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  dpmemblock_Free(*(uint64_t **)(a1 + 128));
  OOCAllocator_Free(v2, *(void *)(a1 + 144));
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 40))(*(void *)(a1 + 112) - *(void *)(**(void **)(a1 + 112) + 56));
  if (!result)
  {
    return FSTBaseFlat_Des(a1);
  }
  return result;
}

uint64_t FSTStreamedCompactRnd_FetchState(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t *a4)
{
  unsigned int v30 = 0;
  int v7 = *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 128) + 8)
                             + 8 * (a2 >> *(_WORD *)(*(void *)(a1 + 128) + 44)))
                 + 8 * (a2 & ~(-1 << *(_WORD *)(*(void *)(a1 + 128) + 44)))
                 + 4);
  unsigned int v8 = v7 & 0xF0000000;
  if (!FST_CheckQuery(v7 & 0xF0000000, a3))
  {
    uint64_t v12 = 0;
    *a4 = 0;
    return v12;
  }
  uint64_t v9 = *(void *)(*(void *)(*(void *)(a1 + 128) + 8) + 8 * (a2 >> *(_WORD *)(*(void *)(a1 + 128) + 44)))
     + 8 * (a2 & ~(-1 << *(_WORD *)(*(void *)(a1 + 128) + 44)));
  int v10 = *(_DWORD *)v9;
  LODWORD(v9) = *(_DWORD *)(v9 + 4);
  uint64_t v29 = 0;
  unint64_t v11 = v9 & 0xFFFFFFF;
  if ((v9 & 0xFFFFFFF) == 0) {
    goto LABEL_48;
  }
  if (*(void *)(a1 + 152) < v11)
  {
    *(void *)(a1 + 144) = OOCAllocator_Realloc(*(void *)(a1 + 24), *(void *)(a1 + 144), v11, &v30);
    uint64_t v12 = v30;
    if (v30) {
      return v12;
    }
    *(void *)(a1 + 152) = v11;
  }
  uint64_t v12 = (***(uint64_t (****)(void, void))(a1 + 112))(*(void *)(a1 + 112) - *(void *)(**(void **)(a1 + 112) + 56), (*(_DWORD *)(a1 + 136) + v10));
  unsigned int v30 = v12;
  if (!v12)
  {
    uint64_t v12 = (*(uint64_t (**)(void, void, unint64_t))(**(void **)(a1 + 112) + 8))(*(void *)(a1 + 112) - *(void *)(**(void **)(a1 + 112) + 56), *(void *)(a1 + 144), v11);
    unsigned int v30 = v12;
    if (!v12)
    {
LABEL_48:
      unint64_t v13 = *(unsigned int **)(a1 + 144);
      int v14 = (unsigned int *)((char *)v13 + v11);
      if (v7 < 0)
      {
        unsigned int v16 = *v13++;
        unsigned int v15 = bswap32(v16);
      }
      else
      {
        unsigned int v15 = 0x7FFFFFFF;
      }
      if (v13 == v14)
      {
        unsigned int v18 = 0;
        unsigned int v17 = 0;
      }
      else
      {
        unsigned int v17 = 0;
        unsigned int v18 = 0;
        int v19 = v13;
        do
        {
          long long v28 = 0uLL;
          uint64_t v27 = 0;
          FSTCompactCodec_DecodeArc(v19, (int *)&v28, &v27);
          int v19 = (unsigned int *)((char *)v19 + v27);
          if (DWORD1(v28) == -2) {
            ++v17;
          }
          else {
            ++v18;
          }
        }
        while (v19 != v14);
      }
      uint64_t v12 = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v29);
      unsigned int v30 = v12;
      if (!v12)
      {
        uint64_t v20 = v29;
        *(_DWORD *)(v29 + 8) |= v8;
        *(_DWORD *)(v20 + 24) = a2;
        *(_DWORD *)(v20 + 28) = v15;
        if (v17)
        {
          int v21 = *(_OWORD **)(v20 + 40);
          if (!v21 || *((_DWORD *)v21 - 1) <= v17)
          {
            uint64_t v22 = _FSTState_ReserveEpsilonArcsInternal(v20, v17, &v30);
            uint64_t v12 = v30;
            if (v30) {
              return v12;
            }
            int v21 = (_OWORD *)v22;
          }
          uint64_t v20 = v29;
          if (v18) {
            goto LABEL_27;
          }
        }
        else
        {
          int v21 = 0;
          if (v18)
          {
LABEL_27:
            int v23 = *(_OWORD **)(v20 + 56);
            if (!v23 || *((_DWORD *)v23 - 1) <= v18)
            {
              uint64_t v24 = _FSTState_ReserveArcsInternal(v20, v18, &v30);
              uint64_t v12 = v30;
              if (v30) {
                return v12;
              }
              int v23 = (_OWORD *)v24;
            }
            uint64_t v20 = v29;
            goto LABEL_34;
          }
        }
        int v23 = 0;
LABEL_34:
        *(_DWORD *)(v20 + 32) = v17;
        *(_DWORD *)(v20 + 48) = v18;
        if (v13 != v14)
        {
          while (1)
          {
            long long v28 = 0uLL;
            uint64_t v27 = 0;
            FSTCompactCodec_DecodeArc(v13, (int *)&v28, &v27);
            if (v21)
            {
              if (DWORD1(v28) == -2) {
                break;
              }
            }
            if (v23)
            {
              int v25 = v23++;
              goto LABEL_40;
            }
LABEL_41:
            unint64_t v13 = (unsigned int *)((char *)v13 + v27);
            if (v13 == v14)
            {
              uint64_t v20 = v29;
              uint64_t v12 = v30;
              goto LABEL_44;
            }
          }
          int v25 = v21++;
LABEL_40:
          *int v25 = v28;
          goto LABEL_41;
        }
        uint64_t v12 = 0;
LABEL_44:
        *a4 = v20;
      }
    }
  }
  return v12;
}

uint64_t FSTStreamedCompactRnd_FillBuffer()
{
  return err_GenerateErrorNotSupported();
}

uint64_t FSTStreamedCompactRnd_GetFinalStateWeight(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  uint64_t v4 = *(void *)(a1 + 128);
  char v5 = *(_WORD *)(v4 + 44);
  uint64_t v6 = *(void *)(*(void *)(v4 + 8) + 8 * (a2 >> v5));
  uint64_t v7 = a2 & ~(-1 << v5);
  if ((*(_DWORD *)(v6 + 8 * v7 + 4) & 0x80000000) == 0)
  {
    uint64_t result = 0;
    unsigned int v9 = 0x7FFFFFFF;
LABEL_3:
    *a3 = v9;
    return result;
  }
  unsigned int v11 = 0;
  uint64_t result = (***(uint64_t (****)(void, void))(a1 + 112))(*(void *)(a1 + 112) - *(void *)(**(void **)(a1 + 112) + 56), (*(_DWORD *)(a1 + 136) + *(_DWORD *)(v6 + 8 * v7)));
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(void, unsigned int *, uint64_t))(**(void **)(a1 + 112) + 8))(*(void *)(a1 + 112) - *(void *)(**(void **)(a1 + 112) + 56), &v11, 4);
    if (!result)
    {
      unsigned int v9 = bswap32(v11);
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t FSTStreamedCompactRnd_GetMemoryInfo(uint64_t a1)
{
  return FSTBaseFlat_GetMemoryInfo(a1) + *(void *)(a1 + 152) + (8 * *(_DWORD *)(a1 + 120)) + 48;
}

uint64_t FSTStreamedCompactRnd_GetStateFlags(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  *a3 = *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 128) + 8)
                              + 8 * (a2 >> *(_WORD *)(*(void *)(a1 + 128) + 44)))
                  + 8 * (a2 & ~(-1 << *(_WORD *)(*(void *)(a1 + 128) + 44)))
                  + 4) & 0xF0000000;
  return 0;
}

void PNEW_FSTStreamedCompactRnd_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 160, &v12);
  if (!v12)
  {
    FSTStreamedCompactRnd_Con(v10, a2, a3, a4);
    int v12 = v11;
    if (v11)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
    }
    else
    {
      *(void *)(v10 + 16) = a1;
      *a5 = v10;
    }
  }
}

void PNEW_FSTStreamedCompactRnd_ConFromIStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  int v15 = 0;
  unint64_t v13 = (void *)OOCAllocator_Malloc(a1, 160, &v15);
  if (!v15)
  {
    FSTStreamedCompactRnd_ConFromIStream(v13, a2, a3, a4, a5);
    int v15 = v14;
    if (v14)
    {
      OOCAllocator_Free(a1, (uint64_t)v13);
      *a7 = 0;
    }
    else
    {
      v13[2] = a1;
      *a7 = v13;
    }
  }
}

void *GetFSTStreamedCompactRndClass()
{
  return &__FSTStreamedCompactRnd;
}

void fstreverse(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t *a4)
{
  if (a3[8] == 28
    && (*(unsigned int (**)(_DWORD *))(*(void *)a3 + 144))(a3) == 1
    && (*(uint64_t (**)(_DWORD *, void))(*(void *)a3 + 152))(a3, 0))
  {
    uint64_t v8 = (*(uint64_t (**)(_DWORD *, void))(*(void *)a3 + 152))(a3, 0);
    *a4 = v8;
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  }
  else
  {
    uint64_t v11 = 0;
    PNEW_FSTReverse_Con(a1, a2, (uint64_t)a3, &v11);
    if (v9) {
      return;
    }
    *a4 = v11;
  }
  uint64_t v10 = *(void (**)(_DWORD *))(*(void *)a3 + 32);

  v10(a3);
}

void PNEW_FSTReverse_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 104, &v10);
  if (!v10)
  {
    FSTReverse_Con(v8, a2, a3);
    int v10 = v9;
    if (v9)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
    }
    else
    {
      *(void *)(v8 + 16) = a1;
      *a4 = v8;
    }
  }
}

void FSTReverse_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  FST_Con((void *)a1, a2, *(void *)(a3 + 48));
  if (v6) {
    return;
  }
  uint64_t v20 = 0;
  long long v19 = 0u;
  memset(v18, 0, sizeof(v18));
  *(void *)a1 = &__FSTReverse;
  int v7 = *(_DWORD *)(a3 + 36);
  LODWORD(v8) = *(void *)(a1 + 40) & 0xFFFFFEFF;
  HIDWORD(v8) = (*(void *)(a1 + 40) | 0x10000000100uLL) >> 32;
  *(_DWORD *)(a1 + 32) = 28;
  *(_DWORD *)(a1 + 36) = v7;
  *(void *)(a1 + 40) = v8;
  int v9 = *(_DWORD *)(a3 + 44);
  *(_DWORD *)(a1 + 40) = v9 & *(_DWORD *)(a3 + 40);
  *(_DWORD *)(a1 + 44) = v9;
  *(_DWORD *)(a1 + 64) = -1;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  if (FSTReverseDfsContext_Con((uint64_t)v18, a2, a3, a1)) {
    return;
  }
  int v21 = FSTDfsContext_Dfs((uint64_t)v18);
  if (v21) {
    return;
  }
  unint64_t v10 = *((void *)&v19 + 1) - v19;
  uint64_t v11 = (*((void *)&v19 + 1) - (void)v19) >> 2;
  if (v11 == 1)
  {
    *(_DWORD *)(a1 + 64) = *(_DWORD *)v19;
    goto LABEL_9;
  }
  if (!v11)
  {
    err_GenerateErrorNotSupported();
    return;
  }
  uint64_t v12 = (*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 3;
  *(_DWORD *)(a1 + 64) = v12;
  int v21 = _FSTReverse_InitializeState(a1, v12, 0x20000000, 0);
  if (!v21)
  {
    if ((uint64_t v13 = *(void *)(*(void *)(a1 + 80) + 8 * *(unsigned int *)(a1 + 64)),
          (int v14 = *(_DWORD **)(v13 + 40)) != 0)
      && *(v14 - 1) > v11
      || (int v14 = (_DWORD *)_FSTState_ReserveEpsilonArcsInternal(v13, v11, &v21), !v21))
    {
      uint64_t v15 = (v10 >> 2);
      if ((v10 >> 2))
      {
        uint64_t v16 = 0;
        uint64_t v17 = 4 * v15;
        do
        {
          int v21 = FSTArc_Con(v14, *(_DWORD *)(v19 + v16), -2, -2, 0);
          if (v21) {
            return;
          }
          v16 += 4;
          v14 += 4;
        }
        while (v17 != v16);
      }
      *(_DWORD *)(v13 + 32) = v11;
LABEL_9:
      *(_DWORD *)(a1 + 96) = HIDWORD(v20);
      (*(void (**)(_OWORD *))(*(void *)&v18[0] + 16))(v18);
    }
  }
}

uint64_t _FSTReverse_InitializeState(uint64_t a1, unsigned int a2, int a3, int a4)
{
  unsigned int v21 = 0;
  uint64_t v20 = 0;
  uint64_t v8 = *(void *)(a1 + 24);
  uint64_t v9 = a2 + 1;
  uint64_t v10 = *(void *)(a1 + 80);
  uint64_t v11 = *(void **)(a1 + 88);
  unint64_t v12 = (unint64_t)v11 - v10;
  if (v9 >= (((unint64_t)v11 - v10) >> 3))
  {
    unsigned int v13 = *(_DWORD *)(a1 + 72);
    if (v9 > v13)
    {
      unsigned int v14 = 2 * v13;
      unsigned int v15 = v13 + 1000000;
      if (v14 >= v15) {
        unsigned int v14 = v15;
      }
      if (v14 <= v9) {
        unsigned int v14 = v9;
      }
      if (v14 <= 8) {
        unsigned int v16 = 8;
      }
      else {
        unsigned int v16 = v14;
      }
      uint64_t v10 = OOCAllocator_Realloc(*(void *)(a1 + 24), v10, 8 * v16, &v21);
      *(void *)(a1 + 80) = v10;
      uint64_t result = v21;
      if (v21) {
        return result;
      }
      *(_DWORD *)(a1 + 72) = v16;
      uint64_t v11 = (void *)(v10 + (v12 & 0x7FFFFFFF8));
      *(void *)(a1 + 88) = v11;
    }
    unint64_t v18 = v10 + 8 * v9;
    if ((unint64_t)v11 < v18)
    {
      do
      {
        *uint64_t v11 = 0;
        uint64_t v11 = (void *)(*(void *)(a1 + 88) + 8);
        *(void *)(a1 + 88) = v11;
      }
      while ((unint64_t)v11 < v18);
      uint64_t v10 = *(void *)(a1 + 80);
    }
  }
  uint64_t v19 = *(void *)(v10 + 8 * a2);
  if (v19)
  {
LABEL_16:
    uint64_t result = 0;
    *(_DWORD *)(v19 + 8) |= a3;
    *(_DWORD *)(v19 + 28) = a4;
    return result;
  }
  uint64_t result = PNEW_FSTState_Con(v8, v8, *(void *)(a1 + 48), &v20);
  if (!result)
  {
    *(void *)(*(void *)(a1 + 80) + 8 * a2) = v20;
    *(_DWORD *)(v20 + 24) = a2;
    uint64_t v19 = *(void *)(*(void *)(a1 + 80) + 8 * a2);
    goto LABEL_16;
  }
  return result;
}

uint64_t FSTReverse_Des(void *a1)
{
  uint64_t v2 = a1[3];
  uint64_t v4 = (uint64_t *)a1[10];
  unint64_t v3 = a1[11];
  if ((unint64_t)v4 < v3)
  {
    do
    {
      if (*v4)
      {
        uint64_t result = OOC_PlacementDeleteObject(v2, *v4);
        if (result) {
          return result;
        }
        unint64_t v3 = a1[11];
      }
      ++v4;
    }
    while ((unint64_t)v4 < v3);
    uint64_t v4 = (uint64_t *)a1[10];
  }
  if (v4) {
    OOCAllocator_Free(v2, (uint64_t)v4);
  }

  return FST_Des((uint64_t)a1);
}

uint64_t FSTReverse_FetchState(uint64_t a1, unsigned int a2, unsigned int a3, void *a4)
{
  *a4 = 0;
  uint64_t v4 = *(void *)(a1 + 80);
  if (((unint64_t)(*(void *)(a1 + 88) - v4) >> 3) > a2)
  {
    uint64_t v5 = *(void *)(v4 + 8 * a2);
    if (v5)
    {
      if (FST_CheckQuery(*(_DWORD *)(v5 + 8) & 0xF0000000, a3))
      {
        *a4 = v5;
        ++*(_DWORD *)(v5 + 8);
      }
    }
  }
  return 0;
}

uint64_t FSTReverse_GetFinalStateWeight(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  *a3 = *(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 8 * a2) + 28);
  return 0;
}

uint64_t FSTReverse_GetInitialStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 64);
  return 0;
}

uint64_t FSTReverse_GetMaxStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = ((*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 3) - 1;
  return 0;
}

uint64_t FSTReverse_GetMemoryInfo(uint64_t a1)
{
  uint64_t result = 8 * *(unsigned int *)(a1 + 72) + 108;
  uint64_t v4 = *(uint64_t **)(a1 + 80);
  unint64_t v3 = *(void *)(a1 + 88);
  while ((unint64_t)v4 < v3)
  {
    uint64_t v5 = *v4;
    if (*v4)
    {
      uint64_t v6 = *(void *)(v5 + 56);
      if (v6 || (uint64_t v6 = *(void *)(v5 + 40)) != 0) {
        uint64_t v6 = *(unsigned int *)(v6 - 4);
      }
      result += 16 * v6 + 64;
    }
    ++v4;
  }
  return result;
}

uint64_t FSTReverse_GetStateFlags(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  *a3 = *(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 8 * a2) + 8) & 0xF0000000;
  return 0;
}

void *GetFSTReverseClass()
{
  return &__FSTReverse;
}

uint64_t FSTReverseDfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = FSTDfsContext_Con(a1, a2, a3);
  if (!result)
  {
    *(void *)a1 = &__FSTReverseDfsContext;
    *(void *)(a1 + 48) = 0x100000001;
    *(void *)(a1 + 64) = a4;
    (*(void (**)(uint64_t))(*(void *)a4 + 24))(a4);
    *(_DWORD *)(a1 + 100) = 0;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 48))(a3, a1 + 96);
    if (!result)
    {
      *(_DWORD *)(a1 + 72) = 0;
      *(void *)(a1 + 80) = 0;
      *(void *)(a1 + 88) = 0;
    }
  }
  return result;
}

uint64_t FSTReverseDfsContext_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2) {
    OOCAllocator_Free(*(void *)(a1 + 8), v2);
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 32))(*(void *)(a1 + 64));
  if (!result)
  {
    return FSTDfsContext_Des(a1);
  }
  return result;
}

uint64_t FSTReverseDfsContext_DiscoverState(uint64_t a1, _DWORD *a2)
{
  unsigned int v18 = 0;
  unsigned int v3 = a2[6];
  int v4 = a2[2];
  if ((v4 & 0x80000000) == 0)
  {
    if (v3 == *(_DWORD *)(a1 + 96)) {
      int v5 = v4 & 0x70000000 | 0x80000000;
    }
    else {
      int v5 = v4 & 0xF0000000;
    }
    return _FSTReverse_InitializeState(*(void *)(a1 + 64), v3, v5, 0);
  }
  if (!a2[7])
  {
    uint64_t v8 = *(void *)(a1 + 80);
    uint64_t v9 = *(unsigned int **)(a1 + 88);
    unint64_t v10 = (unint64_t)v9 - v8;
    unsigned int v11 = (((unint64_t)v9 - v8) >> 2) + 1;
    unsigned int v12 = *(_DWORD *)(a1 + 72);
    if (v11 > v12)
    {
      uint64_t v13 = *(void *)(a1 + 8);
      unsigned int v14 = 2 * v12;
      unsigned int v15 = v12 + 1000000;
      if (v14 >= v15) {
        unsigned int v14 = v15;
      }
      if (v14 <= v11) {
        unsigned int v14 = v11;
      }
      if (v14 <= 8) {
        unsigned int v16 = 8;
      }
      else {
        unsigned int v16 = v14;
      }
      uint64_t v17 = OOCAllocator_Realloc(v13, v8, 4 * v16, &v18);
      *(void *)(a1 + 80) = v17;
      uint64_t v6 = v18;
      if (v18) {
        return v6;
      }
      *(_DWORD *)(a1 + 72) = v16;
      uint64_t v9 = (unsigned int *)(v17 + (v10 & 0x3FFFFFFFCLL));
    }
    *uint64_t v9 = v3;
    *(void *)(a1 + 88) = v9 + 1;
    if (v3 == *(_DWORD *)(a1 + 96)) {
      int v5 = v4 & 0xF0000000;
    }
    else {
      int v5 = v4 & 0x70000000;
    }
    return _FSTReverse_InitializeState(*(void *)(a1 + 64), v3, v5, 0);
  }

  return err_GenerateErrorNotSupported();
}

uint64_t FSTReverseDfsContext_ExploreNonTreeArc(uint64_t a1, int a2, unsigned int *a3)
{
  uint64_t v6 = *a3;
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v8 = *(void *)(v7 + 80);
  if (v6 >= ((unint64_t)(*(void *)(v7 + 88) - v8) >> 3)
    || (uint64_t v9 = *(void *)(v8 + 8 * v6)) == 0)
  {
    uint64_t result = _FSTReverse_InitializeState(v7, *a3, 0, 0);
    if (result) {
      return result;
    }
    uint64_t v9 = *(void *)(*(void *)(*(void *)(a1 + 64) + 80) + 8 * v6);
  }
  long long v12 = *(_OWORD *)a3;
  LODWORD(v12) = a2;
  if (a3[1] == -2) {
    int v11 = 2;
  }
  else {
    int v11 = 4;
  }
  uint64_t result = FSTState_AddArcs(v9, v11, (uint64_t)&v12, 1u);
  if (!result && *a3 != a2 && *a3 == *(_DWORD *)(a1 + 96))
  {
    uint64_t result = 0;
    ++*(_DWORD *)(a1 + 100);
  }
  return result;
}

uint64_t FSTReverseDfsContext_ExploreTreeArc(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
}

uint64_t PNEW_FSTReverseDfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  unsigned int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 104, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = FSTReverseDfsContext_Con(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *a5 = v10;
    }
  }
  return result;
}

void *GetFSTReverseDfsContextClass()
{
  return &__FSTReverseDfsContext;
}

uint64_t FSTSimpleCache_Con(uint64_t a1, uint64_t a2)
{
  uint64_t result = _FSTUnaryOperator_Con(a1, *(void *)(a2 + 24), a2);
  if (!result)
  {
    *(void *)a1 = &__FSTSimpleCache;
    *(_DWORD *)(a1 + 32) = 268435459;
    *(_DWORD *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
  }
  return result;
}

uint64_t FSTSimpleCache_Des(void *a1)
{
  uint64_t v2 = a1[3];
  int v4 = (uint64_t *)a1[10];
  unint64_t v3 = a1[11];
  if ((unint64_t)v4 < v3)
  {
    do
    {
      uint64_t v5 = *v4;
      if (*v4)
      {
        int v6 = *(_DWORD *)(v5 + 8);
        if ((v6 & 0x3FFFFFF) == 1)
        {
          if ((v6 & 0x8000000) != 0) {
            uint64_t v7 = *(void *)(v5 + 16);
          }
          else {
            uint64_t v7 = 0;
          }
          uint64_t result = FSTStatePool_PushFSTState(v7, v5);
          if (result) {
            return result;
          }
          unint64_t v3 = a1[11];
        }
        else
        {
          *(_DWORD *)(v5 + 8) = v6 - 1;
          if ((v6 & 0x3FFFFFF) == 0) {
            return 9;
          }
        }
      }
      ++v4;
    }
    while ((unint64_t)v4 < v3);
    int v4 = (uint64_t *)a1[10];
  }
  if (v4) {
    OOCAllocator_Free(v2, (uint64_t)v4);
  }

  return FSTUnaryOperator_Des((uint64_t)a1);
}

uint64_t FSTSimpleCache_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7 = 0;
  uint64_t result = __FSTSimpleCache_LoadState(a1, a2, &v7);
  if (!result)
  {
    uint64_t v6 = v7;
    ++*(_DWORD *)(v7 + 8);
    *a4 = v6;
  }
  return result;
}

uint64_t __FSTSimpleCache_LoadState(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v21 = 0;
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t v20 = 0;
  uint64_t v7 = *(void *)(a1 + 80);
  uint64_t v8 = *(void **)(a1 + 88);
  unint64_t v9 = (unint64_t)v8 - v7;
  unint64_t v10 = ((unint64_t)v8 - v7) >> 3;
  uint64_t v11 = (a2 + 1);
  if (v10 <= a2 && v11 >= v10)
  {
    unsigned int v15 = *(_DWORD *)(a1 + 72);
    if (v11 > v15)
    {
      unsigned int v16 = 2 * v15;
      unsigned int v17 = v15 + 1000000;
      if (v16 >= v17) {
        unsigned int v16 = v17;
      }
      if (v16 <= v11) {
        unsigned int v16 = a2 + 1;
      }
      if (v16 <= 8) {
        unsigned int v18 = 8;
      }
      else {
        unsigned int v18 = v16;
      }
      uint64_t v7 = OOCAllocator_Realloc(v6, v7, 8 * v18, &v21);
      *(void *)(a1 + 80) = v7;
      uint64_t result = v21;
      if (v21) {
        return result;
      }
      *(_DWORD *)(a1 + 72) = v18;
      uint64_t v8 = (void *)(v7 + (v9 & 0x7FFFFFFF8));
      *(void *)(a1 + 88) = v8;
    }
    unint64_t v19 = v7 + 8 * v11;
    if ((unint64_t)v8 < v19)
    {
      do
      {
        *uint64_t v8 = 0;
        uint64_t v8 = (void *)(*(void *)(a1 + 88) + 8);
        *(void *)(a1 + 88) = v8;
      }
      while ((unint64_t)v8 < v19);
      uint64_t v7 = *(void *)(a1 + 80);
    }
  }
  uint64_t v13 = *(void *)(v7 + 8 * a2);
  uint64_t v20 = v13;
  if (v13)
  {
LABEL_6:
    uint64_t result = 0;
    *a3 = v13;
    return result;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, 8, &v20);
  if (!result)
  {
    *(void *)(*(void *)(a1 + 80) + 8 * a2) = v20;
    uint64_t v13 = v20;
    goto LABEL_6;
  }
  return result;
}

uint64_t FSTSimpleCache_GetFinalStateWeight(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v5 = 0;
  uint64_t result = __FSTSimpleCache_LoadState(a1, a2, &v5);
  if (!result) {
    *a3 = *(_DWORD *)(v5 + 28);
  }
  return result;
}

uint64_t FSTSimpleCache_GetMemoryInfo(uint64_t a1)
{
  uint64_t result = FSTUnaryOperator_GetMemoryInfo(a1) + 8 * *(unsigned int *)(a1 + 72) + 24;
  for (unsigned int i = *(uint64_t **)(a1 + 80); (unint64_t)i < *(void *)(a1 + 88); ++i)
  {
    uint64_t v4 = *i;
    if (*i)
    {
      uint64_t v5 = *(void *)(v4 + 56);
      if (v5 || (uint64_t v5 = *(void *)(v4 + 40)) != 0) {
        uint64_t v5 = *(unsigned int *)(v5 - 4);
      }
      result += 16 * v5 + 64;
    }
  }
  return result;
}

uint64_t FSTSimpleCache_GetStateFlags(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v5 = 0;
  uint64_t result = __FSTSimpleCache_LoadState(a1, a2, &v5);
  if (!result) {
    *a3 = *(_DWORD *)(v5 + 8) & 0xF0000000;
  }
  return result;
}

uint64_t PNEW_FSTSimpleCache_Con(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = OOCAllocator_Malloc(a1, 96, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = _FSTUnaryOperator_Con(v6, *(void *)(a2 + 24), a2);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *(void *)uint64_t v6 = &__FSTSimpleCache;
      *(_DWORD *)(v6 + 32) = 268435459;
      *(_DWORD *)(v6 + 72) = 0;
      *(void *)(v6 + 80) = 0;
      *(void *)(v6 + 88) = 0;
      *(void *)(v6 + 16) = a1;
      *a3 = v6;
    }
  }
  return result;
}

void *GetFSTSimpleCacheClass()
{
  return &__FSTSimpleCache;
}

void FSTStreamedFlat_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v20 = 0;
  unint64_t v18 = 0;
  unint64_t v19 = 0;
  int v17 = 0;
  uint64_t v8 = a4 + 24;
  FST_AllocateExtendedHeaderFromRandomReader(a2, a4 + 24, 24, (const void **)&v19, &v18, &v20, &v17);
  if (!v9)
  {
    if (v17 != 2) {
      goto LABEL_8;
    }
    unint64_t v11 = v18;
    unint64_t v10 = v19;
    _OWORD v19[2] = 18;
    double v12 = _FSTBaseFlat_Con((void *)a1, a2, a3, v11, v10, a2, 3u);
    int v21 = v13;
    if (v13) {
      return;
    }
    *(void *)a1 = &__FSTStreamedFlat;
    *(void *)(a1 + 112) = a4;
    *(void *)(a1 + 144) = 0;
    *(void *)(a1 + 152) = 0;
    (*(void (**)(uint64_t, double))(*(void *)a4 + 24))(a4, v12);
    if (v20 == 3)
    {
      unsigned int v14 = (char *)v19 + v11;
      uint64_t v15 = *(unsigned int *)((char *)v19 + v11 - 8);
      *(_DWORD *)(a1 + 136) = *(_DWORD *)((char *)v19 + v11 - 4);
      LODWORD(v14) = *((_DWORD *)v14 - 3);
      *(_DWORD *)(a1 + 120) = v14;
      uint64_t v16 = 4 * (v14 + 1);
      *(void *)(a1 + 128) = OOCAllocator_Malloc(a2, v16, &v21);
      if (!v21)
      {
        int v21 = (**(uint64_t (***)(uint64_t, uint64_t))v8)(v8 - *(void *)(*(void *)v8 + 56), v15);
        if (!v21) {
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)v8 + 8))(v8 - *(void *)(*(void *)v8 + 56), *(void *)(a1 + 128), v16);
        }
      }
    }
    else
    {
LABEL_8:
      err_GenerateErrorData();
    }
  }
}

void FSTStreamedFlat_ConFromIStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = 0;
  if (!PNEW_DataSectionRandomReader_Con(a2, a2, a4, a5, 0, 0, 0xFFFFFFFF, 0, &v8)) {
    FSTStreamedFlat_Con(a1, a2, a3, v8);
  }
}

uint64_t FSTStreamedFlat_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  OOCAllocator_Free(v2, *(void *)(a1 + 128));
  OOCAllocator_Free(v2, *(void *)(a1 + 144));
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 32))(*(void *)(a1 + 112));
  if (!result)
  {
    return FSTBaseFlat_Des(a1);
  }
  return result;
}

uint64_t FSTStreamedFlat_FetchState(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t *a4)
{
  unsigned int v25 = 0;
  int v7 = *(_DWORD *)(*(void *)(a1 + 128) + 4 * a2);
  unsigned int v8 = v7 & 0xF0000000;
  uint64_t result = FST_CheckQuery(v7 & 0xF0000000, a3);
  if (!result)
  {
    *a4 = 0;
    return result;
  }
  uint64_t v24 = 0;
  uint64_t v10 = *(void *)(a1 + 128);
  int v11 = *(_DWORD *)(v10 + 4 * a2);
  unsigned int v12 = *(_DWORD *)(v10 + 4 * (a2 + 1)) & 0xFFFFFFF;
  uint64_t v13 = v12 - (v11 & 0xFFFFFFF);
  if (v12 <= (v11 & 0xFFFFFFFu))
  {
    uint64_t v16 = 0;
    LODWORD(v15) = 0;
    LODWORD(v17) = 0;
    int v18 = 0x7FFFFFFF;
    goto LABEL_8;
  }
  unint64_t v14 = 16 * (v12 - (v11 & 0xFFFFFFF));
  if (v14 <= *(void *)(a1 + 152))
  {
    uint64_t v15 = *(int **)(a1 + 144);
  }
  else
  {
    uint64_t v15 = (int *)OOCAllocator_Realloc(*(void *)(a1 + 24), *(void *)(a1 + 144), 16 * (v12 - (v11 & 0xFFFFFFF)), &v25);
    *(void *)(a1 + 144) = v15;
    uint64_t result = v25;
    if (v25) {
      return result;
    }
    *(void *)(a1 + 152) = v14;
  }
  uint64_t result = (**(uint64_t (***)(uint64_t, void))(*(void *)(a1 + 112) + 24))(*(void *)(a1 + 112) + 24 - *(void *)(*(void *)(*(void *)(a1 + 112) + 24) + 56), (*(_DWORD *)(a1 + 136) + 16 * v11));
  unsigned int v25 = result;
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)(*(void *)(a1 + 112) + 24) + 8))(*(void *)(a1 + 112) + 24 - *(void *)(*(void *)(*(void *)(a1 + 112) + 24) + 56), *(void *)(a1 + 144), 16 * v13);
    unsigned int v25 = result;
    if (!result)
    {
      if (v7 < 0)
      {
        uint64_t v16 = v15 + 4;
        int v18 = *v15;
      }
      else
      {
        int v18 = 0x7FFFFFFF;
        if (!v15)
        {
          uint64_t v16 = 0;
          LODWORD(v17) = 0;
          goto LABEL_8;
        }
        uint64_t v16 = v15;
      }
      uint64_t v22 = (char *)&v15[4 * v13];
      int v23 = (char *)v16;
      if (v16 < (int *)v22)
      {
        int v23 = (char *)v16;
        do
        {
          if (*((_DWORD *)v23 + 1) != -2) {
            break;
          }
          v23 += 16;
        }
        while (v23 < v22);
      }
      uint64_t v15 = (int *)((unint64_t)(v22 - v23) >> 4);
      unint64_t v17 = (unint64_t)(v23 - (char *)v16) >> 4;
LABEL_8:
      uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), (uint64_t *)&v24);
      unsigned int v25 = result;
      if (result) {
        return result;
      }
      uint64_t v19 = (uint64_t)v24;
      v24[2] |= v8;
      *(_DWORD *)(v19 + 24) = a2;
      *(_DWORD *)(v19 + 28) = v18;
      if (v16 && v17)
      {
        int v20 = *(_DWORD **)(v19 + 40);
        if (!v20 || *(v20 - 1) <= v17)
        {
          int v20 = (_DWORD *)_FSTState_ReserveEpsilonArcsInternal(v19, v17, &v25);
          uint64_t result = v25;
          if (v25) {
            return result;
          }
        }
        cstdlib_memcpy(v20, v16, 16 * v17);
        uint64_t v19 = (uint64_t)v24;
        v24[8] = v17;
      }
      if (v16 && v15)
      {
        int v21 = *(_DWORD **)(v19 + 56);
        if (!v21 || *(v21 - 1) <= v15) {
          int v21 = (_DWORD *)_FSTState_ReserveArcsInternal(v19, v15, &v25);
        }
        uint64_t result = v25;
        if (v25) {
          return result;
        }
        cstdlib_memcpy(v21, &v16[4 * v17], 16 * v15);
        uint64_t v19 = (uint64_t)v24;
        v24[12] = v15;
      }
      *a4 = v19;
      return v25;
    }
  }
  return result;
}

uint64_t FSTStreamedFlat_FillBuffer()
{
  return err_GenerateErrorNotSupported();
}

uint64_t FSTStreamedFlat_GetFinalStateWeight(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  int v4 = *(_DWORD *)(*(void *)(a1 + 128) + 4 * a2);
  if (v4 < 0)
  {
    uint64_t result = (**(uint64_t (***)(uint64_t, void))(*(void *)(a1 + 112) + 24))(*(void *)(a1 + 112) + 24 - *(void *)(*(void *)(*(void *)(a1 + 112) + 24) + 56), (*(_DWORD *)(a1 + 136) + 16 * v4));
    if (!result)
    {
      uint64_t v7 = *(void *)(a1 + 112);
      uint64_t v8 = *(void *)(v7 + 24);
      int v9 = *(uint64_t (**)(uint64_t, _DWORD *, uint64_t))(v8 + 8);
      uint64_t v10 = v7 + 24 - *(void *)(v8 + 56);
      return v9(v10, a3, 4);
    }
  }
  else
  {
    uint64_t result = 0;
    *a3 = 0x7FFFFFFF;
  }
  return result;
}

uint64_t FSTStreamedFlat_GetMemoryInfo(uint64_t a1)
{
  return FSTBaseFlat_GetMemoryInfo(a1) + 4 * *(unsigned int *)(a1 + 120) + 16 * *(void *)(a1 + 152) + 48;
}

uint64_t FSTStreamedFlat_GetStateFlags(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  *a3 = *(_DWORD *)(*(void *)(a1 + 128) + 4 * a2) & 0xF0000000;
  return 0;
}

void PNEW_FSTStreamedFlat_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 160, &v12);
  if (!v12)
  {
    FSTStreamedFlat_Con(v10, a2, a3, a4);
    int v12 = v11;
    if (v11)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
    }
    else
    {
      *(void *)(v10 + 16) = a1;
      *a5 = v10;
    }
  }
}

void PNEW_FSTStreamedFlat_ConFromIStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  int v15 = 0;
  uint64_t v13 = OOCAllocator_Malloc(a1, 160, &v15);
  if (!v15)
  {
    FSTStreamedFlat_ConFromIStream(v13, a2, a3, a4, a5);
    int v15 = v14;
    if (v14)
    {
      OOCAllocator_Free(a1, v13);
      *a7 = 0;
    }
    else
    {
      *(void *)(v13 + 16) = a1;
      *a7 = v13;
    }
  }
}

void *GetFSTStreamedFlatClass()
{
  return &__FSTStreamedFlat;
}

uint64_t FSTSCCDfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = FSTDfs2Context_Con(a1, a2, a3);
  if (!v4)
  {
    *(void *)a1 = &__FSTSCCDfsContext;
    *(void *)(a1 + 192) = 0;
    *(_DWORD *)(a1 + 200) = 0;
    _FSTDfs2Context_SetDfsOptions((_DWORD *)a1, 1, 0, 1, 1, 1);
    *(_DWORD *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
    *(_DWORD *)(a1 + 96) = 0;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 112) = 0;
    *(_DWORD *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = 0;
    *(_DWORD *)(a1 + 144) = 0;
    *(void *)(a1 + 152) = 0;
    *(void *)(a1 + 160) = 0;
    *(_DWORD *)(a1 + 168) = 0;
    *(void *)(a1 + 176) = 0;
    *(void *)(a1 + 184) = 0;
  }
  return v4;
}

uint64_t FSTSCCDfsContext_Des(uint64_t *a1)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a1[10];
  if (v3) {
    OOCAllocator_Free(a1[1], v3);
  }
  uint64_t v4 = a1[13];
  if (v4) {
    OOCAllocator_Free(v2, v4);
  }
  uint64_t v5 = a1[16];
  if (v5) {
    OOCAllocator_Free(v2, v5);
  }
  uint64_t v6 = a1[19];
  if (v6) {
    OOCAllocator_Free(v2, v6);
  }
  uint64_t v7 = a1[22];
  if (v7) {
    OOCAllocator_Free(v2, v7);
  }

  return FSTDfs2Context_Des((uint64_t)a1);
}

uint64_t FSTSCCDfsContext_ReleaseScc(uint64_t result, void *a2, void *a3)
{
  *a2 = *(void *)(result + 176);
  *a3 = ((*(void *)(result + 184) - *(void *)(result + 176)) >> 2);
  *(_DWORD *)(result + 168) = 0;
  *(void *)(result + 176) = 0;
  *(void *)(result + 184) = 0;
  return result;
}

uint64_t _FSTSCCDfsContext_ExploreBackArc(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  uint64_t v3 = *a3;
  int v4 = *(_DWORD *)(*(void *)(a1 + 80) + 4 * v3);
  uint64_t v5 = *(void *)(a1 + 104);
  if (v4 < *(_DWORD *)(v5 + 4 * a2)) {
    *(_DWORD *)(v5 + 4 * a2) = v4;
  }
  if (v3 != a2) {
    *(_DWORD *)(a1 + 200) = 1;
  }
  return 0;
}

uint64_t _FSTSCCDfsContext_ExploreForwardOrCrossArc(void *a1, unsigned int a2, unsigned int *a3)
{
  uint64_t v3 = *a3;
  uint64_t v4 = a1[10];
  int v5 = *(_DWORD *)(v4 + 4 * v3);
  if (v5 < *(_DWORD *)(v4 + 4 * a2))
  {
    if (*(_DWORD *)(a1[16] + 4 * v3))
    {
      uint64_t v6 = a1[13];
      if (v5 < *(_DWORD *)(v6 + 4 * a2)) {
        *(_DWORD *)(v6 + 4 * a2) = v5;
      }
    }
  }
  return 0;
}

uint64_t _FSTSCCDfsContext_FinishDfs(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(_DWORD **)(a1 + 176);
  uint64_t v4 = ((*(void *)(a1 + 184) - (void)v3) >> 2);
  if (((*(void *)(a1 + 184) - (void)v3) >> 2))
  {
    do
    {
      *uint64_t v3 = *(_DWORD *)(a1 + 192) + ~*v3;
      ++v3;
      --v4;
    }
    while (v4);
  }
  *(_DWORD *)(a1 + 72) = 0;
  uint64_t v5 = *(void *)(a1 + 80);
  if (v5)
  {
    OOCAllocator_Free(v2, v5);
    *(void *)(a1 + 80) = 0;
  }
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  uint64_t v6 = *(void *)(a1 + 104);
  if (v6)
  {
    OOCAllocator_Free(v2, v6);
    *(void *)(a1 + 104) = 0;
  }
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 120) = 0;
  uint64_t v7 = *(void *)(a1 + 128);
  if (v7)
  {
    OOCAllocator_Free(v2, v7);
    *(void *)(a1 + 128) = 0;
  }
  *(void *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  uint64_t v8 = *(void *)(a1 + 152);
  if (v8)
  {
    OOCAllocator_Free(v2, v8);
    *(void *)(a1 + 152) = 0;
  }
  *(void *)(a1 + 160) = 0;
  return 0;
}

uint64_t _FSTSCCDfsContext_FinishState(uint64_t a1, unsigned int a2, unsigned int a3)
{
  unsigned int v17 = 0;
  if (*(_DWORD *)(*(void *)(a1 + 80) + 4 * a2) == *(_DWORD *)(*(void *)(a1 + 104) + 4 * a2))
  {
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = *(void *)(a1 + 152);
    uint64_t v8 = *(void *)(a1 + 160);
    do
    {
      uint64_t v9 = *(unsigned int *)(v8 - 4);
      *(_DWORD *)(*(void *)(a1 + 176) + 4 * v9) = *(_DWORD *)(a1 + 192);
      *(_DWORD *)(*(void *)(a1 + 128) + 4 * v9) = 0;
      unint64_t v10 = v8 - v7;
      unint64_t v11 = (unint64_t)(v8 - v7) >> 2;
      if ((v11 - 1) > *(_DWORD *)(a1 + 144))
      {
        if ((v11 - 1) >= 9) {
          unsigned int v12 = v11 - 1;
        }
        else {
          unsigned int v12 = 8;
        }
        uint64_t v13 = OOCAllocator_Realloc(v6, v7, 4 * v12, &v17);
        *(void *)(a1 + 152) = v13;
        if (v17) {
          return v17;
        }
        uint64_t v7 = v13;
        *(_DWORD *)(a1 + 144) = v12;
        LODWORD(v11) = v10 >> 2;
      }
      uint64_t v8 = v7 + 4 * (v11 - 1);
      *(void *)(a1 + 160) = v8;
    }
    while (v9 != a2);
    ++*(_DWORD *)(a1 + 192);
  }
  if (a3 != -1)
  {
    uint64_t v14 = *(void *)(a1 + 104);
    if (((unint64_t)(*(void *)(a1 + 112) - v14) >> 2) > a3)
    {
      int v15 = *(_DWORD *)(v14 + 4 * a2);
      if (v15 < *(_DWORD *)(v14 + 4 * a3)) {
        *(_DWORD *)(v14 + 4 * a3) = v15;
      }
    }
  }
  return v17;
}

uint64_t _FSTSCCDfsContext_InitState(uint64_t a1, uint64_t a2)
{
  unsigned int v52 = 0;
  uint64_t v3 = *(unsigned int *)(a2 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 152);
  uint64_t v6 = *(_DWORD **)(a1 + 160);
  unint64_t v7 = (unint64_t)v6 - v5;
  unsigned int v8 = (((unint64_t)v6 - v5) >> 2) + 1;
  unsigned int v9 = *(_DWORD *)(a1 + 144);
  if (v8 > v9)
  {
    unsigned int v10 = 2 * v9;
    unsigned int v11 = v9 + 1000000;
    if (v10 >= v11) {
      unsigned int v10 = v11;
    }
    if (v10 <= v8) {
      unsigned int v10 = v8;
    }
    if (v10 <= 8) {
      unsigned int v12 = 8;
    }
    else {
      unsigned int v12 = v10;
    }
    uint64_t v13 = OOCAllocator_Realloc(*(void *)(a1 + 8), v5, 4 * v12, &v52);
    *(void *)(a1 + 152) = v13;
    uint64_t result = v52;
    if (v52) {
      return result;
    }
    *(_DWORD *)(a1 + 144) = v12;
    uint64_t v6 = (_DWORD *)(v13 + (v7 & 0x3FFFFFFFCLL));
  }
  _DWORD *v6 = v3;
  *(void *)(a1 + 160) = v6 + 1;
  uint64_t v15 = (v3 + 1);
  uint64_t v16 = *(void *)(a1 + 176);
  unint64_t v17 = *(void *)(a1 + 184);
  unint64_t v18 = v17 - v16;
  if (v15 >= ((v17 - v16) >> 2))
  {
    unsigned int v19 = *(_DWORD *)(a1 + 168);
    if (v15 > v19)
    {
      unsigned int v20 = 2 * v19;
      unsigned int v21 = v19 + 1000000;
      if (v20 < v21) {
        unsigned int v21 = v20;
      }
      if (v21 <= v15) {
        unsigned int v21 = v3 + 1;
      }
      if (v21 <= 8) {
        unsigned int v22 = 8;
      }
      else {
        unsigned int v22 = v21;
      }
      uint64_t v16 = OOCAllocator_Realloc(v4, v16, 4 * v22, &v52);
      *(void *)(a1 + 176) = v16;
      uint64_t result = v52;
      if (v52) {
        return result;
      }
      *(_DWORD *)(a1 + 168) = v22;
      unint64_t v17 = v16 + (v18 & 0x3FFFFFFFCLL);
      *(void *)(a1 + 184) = v17;
    }
    if (v17 < v16 + 4 * v15)
    {
      unint64_t v23 = v16 + 4 * v15;
      if (v23 <= v17 + 4) {
        unint64_t v23 = v17 + 4;
      }
      size_t v24 = ((v23 + ~v17) & 0xFFFFFFFFFFFFFFFCLL) + 4;
      memset((void *)v17, 255, v24);
      *(void *)(a1 + 184) = v17 + v24;
    }
  }
  uint64_t v25 = *(void *)(a1 + 80);
  unint64_t v26 = *(void *)(a1 + 88);
  unint64_t v27 = v26 - v25;
  if (v15 >= ((v26 - v25) >> 2))
  {
    unsigned int v28 = *(_DWORD *)(a1 + 72);
    if (v15 > v28)
    {
      unsigned int v29 = 2 * v28;
      unsigned int v30 = v28 + 1000000;
      if (v29 < v30) {
        unsigned int v30 = v29;
      }
      if (v30 <= v15) {
        unsigned int v30 = v3 + 1;
      }
      if (v30 <= 8) {
        unsigned int v31 = 8;
      }
      else {
        unsigned int v31 = v30;
      }
      uint64_t v25 = OOCAllocator_Realloc(v4, v25, 4 * v31, &v52);
      *(void *)(a1 + 80) = v25;
      uint64_t result = v52;
      if (v52) {
        return result;
      }
      *(_DWORD *)(a1 + 72) = v31;
      unint64_t v26 = v25 + (v27 & 0x3FFFFFFFCLL);
      *(void *)(a1 + 88) = v26;
    }
    if (v26 < v25 + 4 * v15)
    {
      unint64_t v32 = v25 + 4 * v15;
      if (v32 <= v26 + 4) {
        unint64_t v32 = v26 + 4;
      }
      size_t v33 = ((v32 + ~v26) & 0xFFFFFFFFFFFFFFFCLL) + 4;
      memset((void *)v26, 255, v33);
      *(void *)(a1 + 88) = v26 + v33;
    }
  }
  uint64_t v34 = *(void *)(a1 + 104);
  unint64_t v35 = *(void *)(a1 + 112);
  unint64_t v36 = v35 - v34;
  if (v15 >= ((v35 - v34) >> 2))
  {
    unsigned int v37 = *(_DWORD *)(a1 + 96);
    if (v15 > v37)
    {
      unsigned int v38 = 2 * v37;
      unsigned int v39 = v37 + 1000000;
      if (v38 < v39) {
        unsigned int v39 = v38;
      }
      if (v39 <= v15) {
        unsigned int v39 = v3 + 1;
      }
      if (v39 <= 8) {
        unsigned int v40 = 8;
      }
      else {
        unsigned int v40 = v39;
      }
      uint64_t v34 = OOCAllocator_Realloc(v4, v34, 4 * v40, &v52);
      *(void *)(a1 + 104) = v34;
      uint64_t result = v52;
      if (v52) {
        return result;
      }
      *(_DWORD *)(a1 + 96) = v40;
      unint64_t v35 = v34 + (v36 & 0x3FFFFFFFCLL);
      *(void *)(a1 + 112) = v35;
    }
    if (v35 < v34 + 4 * v15)
    {
      unint64_t v41 = v34 + 4 * v15;
      if (v41 <= v35 + 4) {
        unint64_t v41 = v35 + 4;
      }
      size_t v42 = ((v41 + ~v35) & 0xFFFFFFFFFFFFFFFCLL) + 4;
      memset((void *)v35, 255, v42);
      *(void *)(a1 + 112) = v35 + v42;
    }
  }
  uint64_t v43 = *(void *)(a1 + 128);
  unint64_t v44 = *(void *)(a1 + 136);
  unint64_t v45 = v44 - v43;
  if (v15 < ((v44 - v43) >> 2))
  {
LABEL_71:
    *(_DWORD *)(*(void *)(a1 + 80) + 4 * v3) = *(_DWORD *)(a1 + 196);
    *(_DWORD *)(*(void *)(a1 + 104) + 4 * v3) = *(_DWORD *)(a1 + 196);
    *(_DWORD *)(v43 + 4 * v3) = 1;
    ++*(_DWORD *)(a1 + 196);
    return v52;
  }
  unsigned int v46 = *(_DWORD *)(a1 + 120);
  if (v15 <= v46)
  {
LABEL_67:
    if (v44 < v43 + 4 * v15)
    {
      unint64_t v50 = v43 + 4 * v15;
      if (v50 <= v44 + 4) {
        unint64_t v50 = v44 + 4;
      }
      size_t v51 = ((v50 + ~v44) & 0xFFFFFFFFFFFFFFFCLL) + 4;
      bzero((void *)v44, v51);
      *(void *)(a1 + 136) = v44 + v51;
    }
    goto LABEL_71;
  }
  unsigned int v47 = 2 * v46;
  unsigned int v48 = v46 + 1000000;
  if (v47 < v48) {
    unsigned int v48 = v47;
  }
  if (v48 <= v15) {
    unsigned int v48 = v3 + 1;
  }
  if (v48 <= 8) {
    unsigned int v49 = 8;
  }
  else {
    unsigned int v49 = v48;
  }
  uint64_t v43 = OOCAllocator_Realloc(v4, *(void *)(a1 + 128), 4 * v49, &v52);
  *(void *)(a1 + 128) = v43;
  uint64_t result = v52;
  if (!v52)
  {
    *(_DWORD *)(a1 + 120) = v49;
    unint64_t v44 = v43 + (v45 & 0x3FFFFFFFCLL);
    *(void *)(a1 + 136) = v44;
    goto LABEL_67;
  }
  return result;
}

uint64_t PNEW_FSTSCCDfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 208, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = FSTSCCDfsContext_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

void *GetFSTSCCDfsContextClass()
{
  return &__FSTSCCDfsContext;
}

const char *FSTStateLabelSet_BorrowString()
{
  return "";
}

uint64_t FSTStateLabelSet_Plus(uint64_t result, int a2)
{
  if (a2 != -2 && !*(unsigned char *)(result + 4))
  {
    *(unsigned char *)(result + 4) = 1;
    *(_DWORD *)uint64_t result = a2;
  }
  return result;
}

uint64_t FSTStateLabelSet_Minus(unsigned char *a1, uint64_t a2)
{
  if (a1[4] == 1 && *(unsigned char *)(a2 + 4) != 1) {
    return *(unsigned int *)a1;
  }
  else {
    return 4294967294;
  }
}

uint64_t FSTStatePotentials_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result = Object_Con((void *)a1);
  if (result) {
    return result;
  }
  *(void *)a1 = &__FSTStatePotentials;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 48) = 0;
  unsigned int v9 = (void *)(a1 + 48);
  *(_DWORD *)(a1 + 64) = a4;
  *(void *)(a1 + 56) = 0;
  long long v149 = 0;
  uint64_t v150 = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  unsigned int v10 = *(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a3 + 48);
  *(void *)(a1 + 56) = 0;
  uint64_t result = v10(a3, &v150);
  HIDWORD(v150) = result;
  if (result) {
    return result;
  }
  uint64_t v11 = (v150 + 1);
  if (v150 == -1)
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    unsigned int v15 = -1;
  }
  else
  {
    if (v11 >= 9) {
      uint64_t v16 = v11;
    }
    else {
      uint64_t v16 = 8;
    }
    uint64_t v12 = OOCAllocator_Realloc(*(void *)(a1 + 8), 0, 4 * v16, (_DWORD *)&v150 + 1);
    uint64_t result = HIDWORD(v150);
    if (HIDWORD(v150)) {
      return result;
    }
    unint64_t v17 = v12 + 4 * v11;
    if (v17 <= v12 + 4) {
      unint64_t v17 = v12 + 4;
    }
    size_t v18 = ((v17 + ~v12) & 0xFFFFFFFFFFFFFFFCLL) + 4;
    bzero((void *)v12, v18);
    unint64_t v14 = v12 + v18;
    unsigned int v15 = v150;
    uint64_t v13 = v16;
  }
  *(_DWORD *)(v12 + 4 * v15) = 1;
  int v19 = *(_DWORD *)(a1 + 64);
  if (v19)
  {
    uint64_t v23 = (v150 + 1);
    uint64_t v24 = *(void *)(a1 + 24);
    unint64_t v25 = *(void *)(a1 + 32);
    unint64_t v26 = v25 - v24;
    if (v23 >= ((v25 - v24) >> 2))
    {
      unsigned int v27 = *(_DWORD *)(a1 + 16);
      if (v23 > v27)
      {
        unsigned int v28 = 2 * v27;
        unsigned int v29 = v27 + 1000000;
        if (v28 < v29) {
          unsigned int v29 = v28;
        }
        if (v29 <= v23) {
          unsigned int v29 = v150 + 1;
        }
        if (v29 <= 8) {
          unsigned int v30 = 8;
        }
        else {
          unsigned int v30 = v29;
        }
        uint64_t v24 = OOCAllocator_Realloc(*(void *)(a1 + 8), v24, 4 * v30, (_DWORD *)&v150 + 1);
        *(void *)(a1 + 24) = v24;
        uint64_t result = HIDWORD(v150);
        if (HIDWORD(v150)) {
          return result;
        }
        *(_DWORD *)(a1 + 16) = v30;
        unint64_t v25 = v24 + (v26 & 0x3FFFFFFFCLL);
        *(void *)(a1 + 32) = v25;
      }
      if (v25 < v24 + 4 * v23)
      {
        unint64_t v31 = v24 + 4 * v23;
        if (v31 <= v25 + 4) {
          unint64_t v31 = v25 + 4;
        }
        size_t v32 = ((v31 + ~v25) & 0xFFFFFFFFFFFFFFFCLL) + 4;
        memset_pattern16((void *)v25, &unk_22078B380, v32);
        *(void *)(a1 + 32) = v25 + v32;
      }
    }
    unsigned int v33 = v150 + 1;
    if ((v150 + 1) >= 9) {
      uint64_t v34 = (v150 + 1);
    }
    else {
      uint64_t v34 = 8;
    }
    uint64_t __b = OOCAllocator_Realloc(*(void *)(a1 + 8), 0, 4 * v34, (_DWORD *)&v150 + 1);
    uint64_t result = HIDWORD(v150);
    if (HIDWORD(v150)) {
      return result;
    }
    unint64_t v35 = __b + 4 * v33;
    if (v35 <= __b + 4) {
      unint64_t v35 = __b + 4;
    }
    size_t v36 = ((v35 + ~__b) & 0xFFFFFFFFFFFFFFFCLL) + 4;
    memset_pattern16((void *)__b, &unk_22078B380, v36);
    *(_DWORD *)(*(void *)(a1 + 24) + 4 * v150) = 0;
    size_t v145 = __b + v36;
    *(_DWORD *)(__b + 4 * v150) = 0;
    uint64_t v144 = v34;
    if ((*(_DWORD *)(a1 + 64) & 2) == 0) {
      goto LABEL_15;
    }
LABEL_38:
    uint64_t v37 = (v150 + 1);
    uint64_t v38 = *(void *)(a1 + 48);
    unint64_t v39 = *(void *)(a1 + 56);
    unint64_t v40 = v39 - v38;
    if (v37 >= ((v39 - v38) >> 3))
    {
      unsigned int v41 = *(_DWORD *)(a1 + 40);
      if (v37 > v41)
      {
        unsigned int v42 = 2 * v41;
        unsigned int v43 = v41 + 1000000;
        if (v42 >= v43) {
          unsigned int v42 = v43;
        }
        if (v42 <= v37) {
          unsigned int v42 = v150 + 1;
        }
        if (v42 <= 8) {
          unsigned int v44 = 8;
        }
        else {
          unsigned int v44 = v42;
        }
        uint64_t v38 = OOCAllocator_Realloc(*(void *)(a1 + 8), v38, 8 * v44, (_DWORD *)&v150 + 1);
        *(void *)(a1 + 48) = v38;
        uint64_t result = HIDWORD(v150);
        if (HIDWORD(v150)) {
          return result;
        }
        *(_DWORD *)(a1 + 40) = v44;
        unint64_t v39 = v38 + (v40 & 0x7FFFFFFF8);
        *(void *)(a1 + 56) = v39;
      }
      for (unint64_t i = v38 + 8 * v37; v39 < i; *(void *)(a1 + 56) = v39)
      {
        *(_DWORD *)unint64_t v39 = -2;
        *(unsigned char *)(v39 + 4) = 0;
        *(_WORD *)(v39 + 5) = 0;
        *(unsigned char *)(v39 + 7) = 0;
        unint64_t v39 = *(void *)(a1 + 56) + 8;
      }
    }
    unsigned int v46 = v150 + 1;
    if ((v150 + 1) >= 9) {
      unsigned int v20 = v150 + 1;
    }
    else {
      unsigned int v20 = 8;
    }
    uint64_t v21 = OOCAllocator_Realloc(*(void *)(a1 + 8), 0, 8 * v20, (_DWORD *)&v150 + 1);
    uint64_t result = HIDWORD(v150);
    if (HIDWORD(v150)) {
      return result;
    }
    unint64_t v22 = v21;
    do
    {
      *(_DWORD *)unint64_t v22 = -2;
      *(unsigned char *)(v22 + 4) = 0;
      *(_WORD *)(v22 + 5) = 0;
      *(unsigned char *)(v22 + 7) = 0;
      v22 += 8;
    }
    while (v22 < v21 + 8 * (unint64_t)v46);
    uint64_t v47 = v150;
    *(void *)(*v9 + 8 * v150) = 4294967294;
    *(void *)(v21 + 8 * v47) = 4294967294;
    goto LABEL_58;
  }
  uint64_t v144 = 0;
  size_t v145 = 0;
  uint64_t __b = 0;
  if ((v19 & 2) != 0) {
    goto LABEL_38;
  }
LABEL_15:
  unsigned int v20 = 0;
  uint64_t v21 = 0;
  unint64_t v22 = 0;
LABEL_58:
  uint64_t result = IFSTStateQueue_Create(*(void *)(a1 + 8), *(void *)(a1 + 8), a3, &v149);
  HIDWORD(v150) = result;
  if (result) {
    return result;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, void))(*v149 + 8))((uint64_t)v149 - *(void *)(*v149 + 48), v150);
  HIDWORD(v150) = result;
  if (result) {
    return result;
  }
  if ((*(unsigned int (**)(uint64_t))(*v149 + 32))((uint64_t)v149 - *(void *)(*v149 + 48))) {
    goto LABEL_61;
  }
  unsigned int v131 = v20;
  while (2)
  {
    uint64_t v134 = (void *)v14;
    uint64_t v148 = 0;
    uint64_t v48 = (*(uint64_t (**)(uint64_t))*v149)((uint64_t)v149 - *(void *)(*v149 + 48));
    uint64_t result = (*(uint64_t (**)(uint64_t))(*v149 + 16))((uint64_t)v149 - *(void *)(*v149 + 48));
    HIDWORD(v150) = result;
    if (result) {
      return result;
    }
    uint64_t v49 = v48;
    *(_DWORD *)(v12 + 4 * v48) = 0;
    int v50 = *(_DWORD *)(a1 + 64);
    uint64_t v141 = v21;
    if (v50)
    {
      uint64_t v138 = v13;
      uint64_t v51 = (v48 + 1);
      uint64_t v52 = *(void *)(a1 + 24);
      unint64_t v53 = *(void *)(a1 + 32);
      unint64_t v54 = v53 - v52;
      if (v51 >= ((v53 - v52) >> 2))
      {
        unsigned int v55 = *(_DWORD *)(a1 + 16);
        if (v51 > v55)
        {
          unsigned int v56 = 2 * v55;
          unsigned int v57 = v55 + 1000000;
          if (v56 < v57) {
            unsigned int v57 = v56;
          }
          if (v57 <= v51) {
            unsigned int v57 = v48 + 1;
          }
          if (v57 <= 8) {
            unsigned int v58 = 8;
          }
          else {
            unsigned int v58 = v57;
          }
          uint64_t v52 = OOCAllocator_Realloc(*(void *)(a1 + 8), v52, 4 * v58, (_DWORD *)&v150 + 1);
          *(void *)(a1 + 24) = v52;
          uint64_t result = HIDWORD(v150);
          if (HIDWORD(v150)) {
            return result;
          }
          *(_DWORD *)(a1 + 16) = v58;
          unint64_t v53 = v52 + (v54 & 0x3FFFFFFFCLL);
          *(void *)(a1 + 32) = v53;
          uint64_t v49 = v48;
        }
        if (v53 < v52 + 4 * v51)
        {
          unint64_t v59 = v52 + 4 * v51;
          if (v59 <= v53 + 4) {
            unint64_t v59 = v53 + 4;
          }
          unint64_t v60 = (v59 + ~v53) & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v61 = v49;
          memset_pattern16((void *)v53, &unk_22078B380, v60 + 4);
          uint64_t v49 = v61;
          *(void *)(a1 + 32) = v53 + v60 + 4;
        }
      }
      int v133 = *(_DWORD *)(__b + 4 * v49);
      *(_DWORD *)(__b + 4 * v49) = 0x7FFFFFFF;
      int v50 = *(_DWORD *)(a1 + 64);
      uint64_t v13 = v138;
      uint64_t v21 = v141;
    }
    else
    {
      int v133 = 0x7FFFFFFF;
    }
    if ((v50 & 2) != 0)
    {
      uint64_t v63 = v13;
      uint64_t v64 = (v48 + 1);
      uint64_t v65 = *(void *)(a1 + 48);
      unint64_t v66 = *(void *)(a1 + 56);
      unint64_t v67 = v66 - v65;
      if (v64 >= ((v66 - v65) >> 3))
      {
        unsigned int v123 = *(_DWORD *)(a1 + 40);
        if (v64 > v123)
        {
          uint64_t v143 = v49;
          unsigned int v124 = 2 * v123;
          unsigned int v125 = v123 + 1000000;
          if (v124 >= v125) {
            unsigned int v124 = v125;
          }
          if (v124 <= v64) {
            unsigned int v124 = v48 + 1;
          }
          if (v124 <= 8) {
            unsigned int v126 = 8;
          }
          else {
            unsigned int v126 = v124;
          }
          uint64_t v65 = OOCAllocator_Realloc(*(void *)(a1 + 8), v65, 8 * v126, (_DWORD *)&v150 + 1);
          *(void *)(a1 + 48) = v65;
          uint64_t result = HIDWORD(v150);
          if (HIDWORD(v150)) {
            return result;
          }
          *(_DWORD *)(a1 + 40) = v126;
          unint64_t v66 = v65 + (v67 & 0x7FFFFFFF8);
          *(void *)(a1 + 56) = v66;
          uint64_t v49 = v143;
        }
        while (v66 < v65 + 8 * v64)
        {
          *(_DWORD *)unint64_t v66 = -2;
          *(unsigned char *)(v66 + 4) = 0;
          *(_WORD *)(v66 + 5) = 0;
          *(unsigned char *)(v66 + 7) = 0;
          unint64_t v66 = *(void *)(a1 + 56) + 8;
          *(void *)(a1 + 56) = v66;
        }
      }
      uint64_t v21 = v141;
      uint64_t v68 = v141 + 8 * v49;
      uint64_t v62 = *(void *)v68;
      *(_DWORD *)uint64_t v68 = -2;
      *(unsigned char *)(v68 + 4) = 0;
      *(_WORD *)(v68 + 5) = 0;
      *(unsigned char *)(v68 + 7) = 0;
      uint64_t v13 = v63;
    }
    else
    {
      uint64_t v62 = 4294967294;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a3 + 120))(a3, v48, 8, &v148);
    HIDWORD(v150) = result;
    if (result) {
      return result;
    }
    uint64_t v69 = v148;
    if (!v148)
    {
      unint64_t v14 = (unint64_t)v134;
      goto LABEL_254;
    }
    unsigned int v70 = *(unsigned int **)(v148 + 40);
    uint64_t v136 = *(void *)(v148 + 56) + 16 * *(unsigned int *)(v148 + 48);
    unint64_t v14 = (unint64_t)v134;
    if (v70 == (unsigned int *)v136) {
      goto LABEL_247;
    }
    uint64_t v137 = &v70[4 * *(unsigned int *)(v148 + 32)];
    uint64_t v132 = BYTE4(v62);
    uint64_t v129 = v62;
    unint64_t v130 = v62 & 0xFFFFFF0000000000;
    do
    {
      if (v70 == v137)
      {
        uint64_t v69 = v148;
        if (!*(_DWORD *)(v148 + 48)) {
          goto LABEL_247;
        }
        unsigned int v70 = *(unsigned int **)(v148 + 56);
      }
      uint64_t v142 = *v70;
      uint64_t v71 = (v142 + 1);
      unint64_t v72 = v14 - v12;
      if (v71 >= ((v14 - v12) >> 2))
      {
        if (v71 > v13)
        {
          unsigned int v73 = 2 * v13;
          if (2 * (int)v13 >= (v13 + 1000000)) {
            unsigned int v73 = v13 + 1000000;
          }
          if (v73 <= v71) {
            unsigned int v73 = v142 + 1;
          }
          if (v73 <= 8) {
            uint64_t v13 = 8;
          }
          else {
            uint64_t v13 = v73;
          }
          uint64_t v12 = OOCAllocator_Realloc(*(void *)(a1 + 8), v12, 4 * v13, (_DWORD *)&v150 + 1);
          uint64_t result = HIDWORD(v150);
          if (HIDWORD(v150)) {
            return result;
          }
          unint64_t v14 = v12 + (v72 & 0x3FFFFFFFCLL);
        }
        if (v14 < v12 + 4 * v71)
        {
          unint64_t v74 = v12 + 4 * v71;
          if (v74 <= v14 + 4) {
            unint64_t v74 = v14 + 4;
          }
          uint64_t v75 = v13;
          size_t v76 = ((v74 + ~v14) & 0xFFFFFFFFFFFFFFFCLL) + 4;
          bzero((void *)v14, v76);
          v14 += v76;
          uint64_t v13 = v75;
        }
      }
      if (*(unsigned char *)(a1 + 64))
      {
        uint64_t v139 = v13;
        uint64_t v79 = *(void *)(a1 + 24);
        unint64_t v80 = *(void *)(a1 + 32);
        unint64_t v81 = v80 - v79;
        if (v71 >= ((v80 - v79) >> 2))
        {
          unsigned int v82 = *(_DWORD *)(a1 + 16);
          if (v71 > v82)
          {
            unsigned int v83 = 2 * v82;
            unsigned int v84 = v82 + 1000000;
            if (v83 < v84) {
              unsigned int v84 = v83;
            }
            if (v84 <= v71) {
              unsigned int v84 = v142 + 1;
            }
            if (v84 <= 8) {
              unsigned int v85 = 8;
            }
            else {
              unsigned int v85 = v84;
            }
            uint64_t v79 = OOCAllocator_Realloc(*(void *)(a1 + 8), v79, 4 * v85, (_DWORD *)&v150 + 1);
            *(void *)(a1 + 24) = v79;
            uint64_t result = HIDWORD(v150);
            if (HIDWORD(v150)) {
              return result;
            }
            *(_DWORD *)(a1 + 16) = v85;
            unint64_t v80 = v79 + (v81 & 0x3FFFFFFFCLL);
            *(void *)(a1 + 32) = v80;
          }
          if (v80 < v79 + 4 * v71)
          {
            unint64_t v86 = v79 + 4 * v71;
            if (v86 <= v80 + 4) {
              unint64_t v86 = v80 + 4;
            }
            unint64_t v87 = (v86 + ~v80) & 0xFFFFFFFFFFFFFFFCLL;
            memset_pattern16((void *)v80, &unk_22078B380, v87 + 4);
            *(void *)(a1 + 32) = v80 + v87 + 4;
          }
        }
        uint64_t v88 = __b;
        if (v71 >= ((v145 - __b) >> 2))
        {
          uint64_t v89 = v144;
          if (v71 <= v144)
          {
            unint64_t v91 = v145;
          }
          else
          {
            unsigned int v90 = 2 * v144;
            if (2 * (int)v144 >= (v144 + 1000000)) {
              unsigned int v90 = v144 + 1000000;
            }
            if (v90 <= v71) {
              unsigned int v90 = v142 + 1;
            }
            if (v90 <= 8) {
              uint64_t v89 = 8;
            }
            else {
              uint64_t v89 = v90;
            }
            uint64_t v88 = OOCAllocator_Realloc(*(void *)(a1 + 8), __b, 4 * v89, (_DWORD *)&v150 + 1);
            uint64_t result = HIDWORD(v150);
            if (HIDWORD(v150)) {
              return result;
            }
            unint64_t v91 = v88 + ((v145 - __b) & 0x3FFFFFFFCLL);
          }
          uint64_t v144 = v89;
          uint64_t __b = v88;
          if (v91 < v88 + 4 * v71)
          {
            unint64_t v92 = v88 + 4 * v71;
            if (v92 <= v91 + 4) {
              unint64_t v92 = v91 + 4;
            }
            size_t v93 = ((v92 + ~v91) & 0xFFFFFFFFFFFFFFFCLL) + 4;
            memset_pattern16((void *)v91, &unk_22078B380, v93);
            v91 += v93;
          }
          size_t v145 = v91;
        }
        uint64_t v13 = v139;
        signed int v94 = v70[3] + v133;
        uint64_t v95 = *(void *)(a1 + 24);
        uint64_t j = v142;
        if (*(_DWORD *)(v95 + 4 * v142) <= v94)
        {
          int v77 = 0;
        }
        else
        {
          *(_DWORD *)(v95 + 4 * v142) = v94;
          if (*(_DWORD *)(__b + 4 * v142) < v94) {
            signed int v94 = *(_DWORD *)(__b + 4 * v142);
          }
          *(_DWORD *)(__b + 4 * v142) = v94;
          int v77 = 1;
        }
      }
      else
      {
        int v77 = 0;
        uint64_t j = v142;
      }
      if ((*(unsigned char *)(a1 + 64) & 2) == 0) {
        goto LABEL_225;
      }
      int v140 = v77;
      unsigned int v147 = 0;
      uint64_t v96 = *(void *)(a1 + 48);
      unint64_t v97 = *(void *)(a1 + 56);
      unint64_t v98 = v97 - v96;
      if (v71 >= ((v97 - v96) >> 3))
      {
        unsigned int v99 = *(_DWORD *)(a1 + 40);
        if (v71 > v99)
        {
          uint64_t v135 = (void *)v14;
          uint64_t v100 = v13;
          unsigned int v101 = 2 * v99;
          unsigned int v102 = v99 + 1000000;
          if (v101 >= v102) {
            unsigned int v101 = v102;
          }
          if (v101 <= v71) {
            unsigned int v101 = v142 + 1;
          }
          if (v101 <= 8) {
            unsigned int v103 = 8;
          }
          else {
            unsigned int v103 = v101;
          }
          uint64_t v96 = OOCAllocator_Realloc(*(void *)(a1 + 8), v96, 8 * v103, (_DWORD *)&v150 + 1);
          *(void *)(a1 + 48) = v96;
          uint64_t result = HIDWORD(v150);
          if (HIDWORD(v150)) {
            return result;
          }
          *(_DWORD *)(a1 + 40) = v103;
          unint64_t v97 = v96 + (v98 & 0x7FFFFFFF8);
          *(void *)(a1 + 56) = v97;
          uint64_t v13 = v100;
          unint64_t v14 = (unint64_t)v135;
        }
        while (v97 < v96 + 8 * v71)
        {
          *(_DWORD *)unint64_t v97 = -2;
          *(unsigned char *)(v97 + 4) = 0;
          *(_WORD *)(v97 + 5) = 0;
          *(unsigned char *)(v97 + 7) = 0;
          unint64_t v97 = *(void *)(a1 + 56) + 8;
          *(void *)(a1 + 56) = v97;
        }
      }
      if (v71 >= ((v22 - v141) >> 3))
      {
        if (v71 <= v131)
        {
          uint64_t v105 = v141;
        }
        else
        {
          unsigned int v104 = 2 * v131;
          if (2 * v131 >= v131 + 1000000) {
            unsigned int v104 = v131 + 1000000;
          }
          if (v104 <= v71) {
            unsigned int v104 = v142 + 1;
          }
          if (v104 <= 8) {
            unsigned int v104 = 8;
          }
          unsigned int v131 = v104;
          uint64_t v105 = OOCAllocator_Realloc(*(void *)(a1 + 8), v141, 8 * v104, (_DWORD *)&v150 + 1);
          uint64_t result = HIDWORD(v150);
          if (HIDWORD(v150)) {
            return result;
          }
          unint64_t v22 = v105 + ((v22 - v141) & 0x7FFFFFFF8);
        }
        uint64_t v141 = v105;
        unint64_t v106 = v105 + 8 * v71;
        for (uint64_t j = v142; v22 < v106; v22 += 8)
        {
          *(_DWORD *)unint64_t v22 = -2;
          *(unsigned char *)(v22 + 4) = 0;
          *(_WORD *)(v22 + 5) = 0;
          *(unsigned char *)(v22 + 7) = 0;
        }
      }
      else
      {
        uint64_t j = v142;
      }
      uint64_t v107 = *(void *)(*v9 + 8 * j);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unsigned int *))(*(void *)a3 + 56))(a3, j, &v147);
      HIDWORD(v150) = result;
      if (result) {
        return result;
      }
      if (!(v147 >> 30))
      {
        uint64_t v108 = v70[2];
        if (v108 == -2 || v132)
        {
          uint64_t v112 = v129;
          unint64_t v110 = v130;
          uint64_t v108 = v129;
          uint64_t v111 = v132;
          uint64_t v109 = v132;
          if (!BYTE4(v107)) {
            goto LABEL_212;
          }
          uint64_t v109 = v132;
          uint64_t v108 = v129;
          if (!v132)
          {
            uint64_t v108 = v129;
            unint64_t v110 = v107 & 0xFFFFFF0000000000;
            uint64_t v111 = BYTE4(v107);
            uint64_t v112 = v107;
            goto LABEL_212;
          }
        }
        else
        {
          uint64_t v109 = 1;
          unint64_t v110 = v130;
          uint64_t v111 = 1;
          uint64_t v112 = v70[2];
          if (!BYTE4(v107)) {
            goto LABEL_212;
          }
        }
        BOOL v116 = v109 == BYTE4(v107) && v108 == v107;
        if (v116) {
          uint64_t v108 = v107;
        }
        if (v116) {
          uint64_t v109 = BYTE4(v107);
        }
        else {
          uint64_t v109 = v109;
        }
        if (v116) {
          unint64_t v110 = v107 & 0xFFFFFF0000000000;
        }
        else {
          unint64_t v110 = 0;
        }
        if (v116) {
          uint64_t v111 = BYTE4(v107);
        }
        else {
          uint64_t v111 = 2;
        }
        if (v116) {
          uint64_t v112 = v107;
        }
        else {
          uint64_t v112 = 4294967294;
        }
LABEL_212:
        BOOL v117 = v111 == BYTE4(v107) && v112 == v107;
        int v77 = v140;
        if (!v117)
        {
          *(void *)(*v9 + 8 * j) = v110 | (v111 << 32) | v112;
          uint64_t v118 = v141 + 8 * j;
          if (*(unsigned char *)(v118 + 4))
          {
            if (!v109 || *(unsigned __int8 *)(v118 + 4) == v109 && *(_DWORD *)v118 == v108)
            {
              uint64_t v109 = *(void *)v118;
              unint64_t v119 = *(void *)v118 & 0xFFFFFFFF00000000;
              unint64_t v120 = *(void *)v118 & 0xFFFFFF0000000000;
            }
            else
            {
              unint64_t v120 = 0;
              unint64_t v119 = 0x200000000;
              LODWORD(v109) = -2;
            }
          }
          else
          {
            unint64_t v119 = v130 | (v109 << 32);
            LODWORD(v109) = v130 | v108;
            unint64_t v120 = v130;
          }
          *(void *)uint64_t v118 = v119 & 0xFF00000000 | v120 | v109;
          goto LABEL_224;
        }
        goto LABEL_225;
      }
      if (BYTE4(v107)) {
        BOOL v113 = 0;
      }
      else {
        BOOL v113 = v107 == 4294967294;
      }
      int v77 = v140;
      if (!v113)
      {
        uint64_t v114 = *v9 + 8 * j;
        *(_DWORD *)uint64_t v114 = -2;
        *(unsigned char *)(v114 + 4) = 0;
        *(_WORD *)(v114 + 5) = 0;
        *(unsigned char *)(v114 + 7) = 0;
        uint64_t v115 = v141 + 8 * j;
        *(_DWORD *)uint64_t v115 = -2;
        *(unsigned char *)(v115 + 4) = 0;
        *(_WORD *)(v115 + 5) = 0;
        *(unsigned char *)(v115 + 7) = 0;
LABEL_224:
        int v77 = 1;
      }
LABEL_225:
      if (v77)
      {
        uint64_t v121 = *v149;
        uint64_t v122 = (uint64_t)v149 - *(void *)(*v149 + 48);
        if (*(_DWORD *)(v12 + 4 * j))
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v121 + 24))(v122, j);
          HIDWORD(v150) = result;
          if (result) {
            return result;
          }
        }
        else
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v121 + 8))(v122, j);
          HIDWORD(v150) = result;
          if (result) {
            return result;
          }
          *(_DWORD *)(v12 + 4 * j) = 1;
        }
      }
      v70 += 4;
    }
    while (v70 != (unsigned int *)v136);
    uint64_t v69 = v148;
LABEL_247:
    int v127 = *(_DWORD *)(v69 + 8);
    uint64_t v21 = v141;
    if ((v127 & 0x3FFFFFF) == 1)
    {
      if ((v127 & 0x8000000) != 0) {
        uint64_t v128 = *(void *)(v69 + 16);
      }
      else {
        uint64_t v128 = 0;
      }
      uint64_t result = FSTStatePool_PushFSTState(v128, v69);
      HIDWORD(v150) = result;
      if (result) {
        return result;
      }
LABEL_254:
      if ((*(unsigned int (**)(uint64_t))(*v149 + 32))((uint64_t)v149 - *(void *)(*v149 + 48)))
      {
LABEL_61:
        if (v12) {
          OOCAllocator_Free(*(void *)(a1 + 8), v12);
        }
        if (__b) {
          OOCAllocator_Free(*(void *)(a1 + 8), __b);
        }
        if (v21) {
          OOCAllocator_Free(*(void *)(a1 + 8), v21);
        }
        return OOC_PlacementDeleteObject(*(void *)(a1 + 8), (uint64_t)v149 - *(void *)(*v149 + 48));
      }
      continue;
    }
    break;
  }
  *(_DWORD *)(v69 + 8) = v127 - 1;
  if ((v127 & 0x3FFFFFF) != 0)
  {
    HIDWORD(v150) = 0;
    goto LABEL_254;
  }
  return 9;
}

uint64_t FSTStatePotentials_Des(uint64_t *a1)
{
  uint64_t v2 = a1[3];
  if (v2) {
    OOCAllocator_Free(a1[1], v2);
  }
  uint64_t v3 = a1[6];
  if (v3) {
    OOCAllocator_Free(a1[1], v3);
  }

  return Object_Des();
}

uint64_t FSTStatePotentials_GetUsedMemory(uint64_t a1)
{
  return 4 * *(unsigned int *)(a1 + 16) + 8 * *(unsigned int *)(a1 + 40) + 72;
}

uint64_t FSTStatePotentials_SetRevInitialPotential(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = 0;
  unsigned int v22 = -1;
  uint64_t result = (*(uint64_t (**)(uint64_t, unsigned int *))(*(void *)a2 + 48))(a2, &v22);
  if (result) {
    return result;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t *))(*(void *)a2 + 120))(a2, v22, 8, &v23);
  unsigned int v24 = result;
  if (result) {
    return result;
  }
  if (v23)
  {
    uint64_t v5 = *(unsigned int **)(v23 + 40);
    uint64_t v6 = *(unsigned int *)(v23 + 48);
    uint64_t v7 = *(void *)(v23 + 56) + 16 * v6;
    if (v5 == (unsigned int *)v7)
    {
      int v9 = 0x7FFFFFFF;
    }
    else
    {
      uint64_t v8 = &v5[4 * *(unsigned int *)(v23 + 32)];
      int v9 = 0x7FFFFFFF;
      do
      {
        if (v5 == v8 && !v6) {
          break;
        }
        if (v5 == v8) {
          uint64_t v5 = *(unsigned int **)(v23 + 56);
        }
        if (v9 >= (int)(*(_DWORD *)(*(void *)(a1 + 24) + 4 * *v5) + v5[3])) {
          int v9 = *(_DWORD *)(*(void *)(a1 + 24) + 4 * *v5) + v5[3];
        }
        v5 += 4;
      }
      while (v5 != (unsigned int *)v7);
    }
    int v10 = *(_DWORD *)(v23 + 8);
    if ((v10 & 0x3FFFFFF) == 1)
    {
      if ((v10 & 0x8000000) != 0) {
        uint64_t v11 = *(void *)(v23 + 16);
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t result = FSTStatePool_PushFSTState(v11, v23);
      unsigned int v24 = result;
      if (result) {
        return result;
      }
    }
    else
    {
      *(_DWORD *)(v23 + 8) = v10 - 1;
      if ((v10 & 0x3FFFFFF) == 0) {
        return 9;
      }
      unsigned int v24 = 0;
    }
  }
  else
  {
    int v9 = 0x7FFFFFFF;
  }
  uint64_t v12 = v22 + 1;
  uint64_t v13 = *(void *)(a1 + 24);
  unint64_t v14 = *(void *)(a1 + 32);
  unint64_t v15 = v14 - v13;
  if (v12 < ((v14 - v13) >> 2))
  {
LABEL_38:
    *(_DWORD *)(v13 + 4 * v22) = v9;
    return v24;
  }
  unsigned int v16 = *(_DWORD *)(a1 + 16);
  if (v12 <= v16)
  {
LABEL_34:
    if (v14 < v13 + 4 * v12)
    {
      unint64_t v20 = v13 + 4 * v12;
      if (v20 <= v14 + 4) {
        unint64_t v20 = v14 + 4;
      }
      size_t v21 = ((v20 + ~v14) & 0xFFFFFFFFFFFFFFFCLL) + 4;
      memset_pattern16((void *)v14, &unk_22078B380, v21);
      *(void *)(a1 + 32) = v14 + v21;
    }
    goto LABEL_38;
  }
  unsigned int v17 = 2 * v16;
  unsigned int v18 = v16 + 1000000;
  if (v17 < v18) {
    unsigned int v18 = v17;
  }
  if (v18 <= v12) {
    unsigned int v18 = v22 + 1;
  }
  if (v18 <= 8) {
    unsigned int v19 = 8;
  }
  else {
    unsigned int v19 = v18;
  }
  uint64_t v13 = OOCAllocator_Realloc(*(void *)(a1 + 8), *(void *)(a1 + 24), 4 * v19, &v24);
  *(void *)(a1 + 24) = v13;
  uint64_t result = v24;
  if (!v24)
  {
    *(_DWORD *)(a1 + 16) = v19;
    unint64_t v14 = v13 + (v15 & 0x3FFFFFFFCLL);
    *(void *)(a1 + 32) = v14;
    goto LABEL_34;
  }
  return result;
}

uint64_t PNEW_FSTStatePotentials_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5)
{
  unsigned int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 72, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = FSTStatePotentials_Con(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *a5 = v10;
    }
  }
  return result;
}

void *GetFSTStatePotentialsClass()
{
  return &__FSTStatePotentials;
}

void FSTStreamedCompact2_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v25 = 0;
  uint64_t v26 = 0;
  unint64_t v24 = 0;
  FST_AllocateExtendedHeaderFromRandomReader(a2, a4, 24, (const void **)&v25, &v24, &v26, (_DWORD *)&v26 + 1);
  if (!v8)
  {
    if (HIDWORD(v26) != 40) {
      goto LABEL_15;
    }
    unint64_t v10 = v24;
    int v9 = v25;
    v25[2] = 41;
    double v11 = _FSTBaseFlat_Con((void *)a1, a2, a3, v10, v9, a2, 3u);
    if (v12) {
      return;
    }
    *(void *)a1 = &__FSTStreamedCompact2;
    *(void *)(a1 + 112) = a4;
    *(void *)(a1 + 152) = 0;
    *(void *)(a1 + 160) = 0;
    (*(void (**)(uint64_t, double))(*(void *)a4 + 48))(a4 - *(void *)(*(void *)a4 + 56), v11);
    if (v26 == 3)
    {
      uint64_t v13 = (char *)v25 + v10;
      uint64_t v15 = *(unsigned int *)((char *)v25 + v10 - 8);
      int v14 = *(_DWORD *)((char *)v25 + v10 - 4);
      *(void *)(a1 + 128) = 0;
      *(_DWORD *)(a1 + 144) = v14;
      *(_DWORD *)(a1 + 120) = *((_DWORD *)v13 - 3);
      if (!dpmemblock_Create(a2, 4, 0x400u, (uint64_t *)(a1 + 128)))
      {
        *(void *)(a1 + 136) = 0;
        if (!dpmemblock_Create(a2, 1, 0x400u, (uint64_t *)(a1 + 136))
          && !(**(unsigned int (***)(uint64_t, uint64_t))a4)(a4 - *(void *)(*(void *)a4 + 56), v15)
          && *(_DWORD *)(a1 + 120) != -1)
        {
          unsigned int v16 = 0;
          do
          {
            if ((*(unsigned int (**)(uint64_t, unsigned char *, uint64_t))(*(void *)a4 + 8))(a4 - *(void *)(*(void *)a4 + 56), v23, 5))
            {
              break;
            }
            char v17 = v23[0];
            int v18 = v23[1];
            int v19 = v23[2];
            int v20 = v23[3];
            int v21 = v23[4];
            unsigned int v22 = 0;
            if (dpmemblock_GetNewElement(*(void *)(a1 + 128), &v22, 0)) {
              break;
            }
            *unsigned int v22 = (v18 << 24) | (v19 << 16) | (v20 << 8) | v21;
            unsigned int v22 = 0;
            if (dpmemblock_GetNewElement(*(void *)(a1 + 136), &v22, 0)) {
              break;
            }
            *(unsigned char *)unsigned int v22 = v17;
            ++v16;
          }
          while (v16 < *(_DWORD *)(a1 + 120) + 1);
        }
      }
    }
    else
    {
LABEL_15:
      err_GenerateErrorData();
    }
  }
}

void FSTStreamedCompact2_ConFromIStream(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *a1 = &__FSTStreamedCompact2;
  uint64_t v9 = 0;
  if (!PNEW_DataSectionRandomReader_Con(a2, a2, a4, a5, 0, 0, 0xFFFFFFFF, 0, &v9))
  {
    FSTStreamedCompact2_Con((uint64_t)a1, a2, a3, v9 + 24);
    if (!v8) {
      (*(void (**)(uint64_t))(*(void *)v9 + 32))(v9);
    }
  }
}

uint64_t FSTStreamedCompact2_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  dpmemblock_Free(*(uint64_t **)(a1 + 128));
  dpmemblock_Free(*(uint64_t **)(a1 + 136));
  OOCAllocator_Free(v2, *(void *)(a1 + 152));
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 40))(*(void *)(a1 + 112) - *(void *)(**(void **)(a1 + 112) + 56));
  if (!result)
  {
    return FSTBaseFlat_Des(a1);
  }
  return result;
}

uint64_t FSTStreamedCompact2_FetchState(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t *a4)
{
  unsigned int v30 = 0;
  int v7 = *(unsigned __int8 *)(*(void *)(*(void *)(*(void *)(a1 + 136) + 8)
                                      + 8 * (a2 >> *(_WORD *)(*(void *)(a1 + 136) + 44)))
                          + (~(-1 << *(_WORD *)(*(void *)(a1 + 136) + 44)) & a2)) << 24;
  if (!FST_CheckQuery(v7, a3))
  {
    uint64_t v15 = 0;
    *a4 = 0;
    return v15;
  }
  uint64_t v8 = *(void *)(a1 + 128);
  uint64_t v9 = *(void *)(v8 + 8);
  LOBYTE(v8) = *(_WORD *)(v8 + 44);
  int v10 = *(_DWORD *)(*(void *)(v9 + 8 * (a2 >> v8)) + 4 * (a2 & ~(-1 << v8)));
  LODWORD(v8) = *(_DWORD *)(*(void *)(v9 + 8 * ((a2 + 1) >> v8)) + 4 * ((a2 + 1) & ~(-1 << v8)));
  uint64_t v29 = 0;
  unint64_t v11 = (v8 - v10);
  if (v8 == v10) {
    goto LABEL_49;
  }
  if (*(void *)(a1 + 160) < v11)
  {
    *(void *)(a1 + 152) = OOCAllocator_Realloc(*(void *)(a1 + 24), *(void *)(a1 + 152), v11, &v30);
    uint64_t v15 = v30;
    if (v30) {
      return v15;
    }
    *(void *)(a1 + 160) = v11;
  }
  uint64_t v15 = (***(uint64_t (****)(void, void))(a1 + 112))(*(void *)(a1 + 112) - *(void *)(**(void **)(a1 + 112) + 56), (*(_DWORD *)(a1 + 144) + v10));
  unsigned int v30 = v15;
  if (!v15)
  {
    uint64_t v15 = (*(uint64_t (**)(void, void, unint64_t))(**(void **)(a1 + 112) + 8))(*(void *)(a1 + 112) - *(void *)(**(void **)(a1 + 112) + 56), *(void *)(a1 + 152), v11);
    unsigned int v30 = v15;
    if (!v15)
    {
LABEL_49:
      int v12 = *(unsigned int **)(a1 + 152);
      uint64_t v13 = (unsigned int *)((char *)v12 + v11);
      if (v7 < 0)
      {
        unsigned int v16 = *v12++;
        unsigned int v14 = bswap32(v16);
      }
      else
      {
        unsigned int v14 = 0x7FFFFFFF;
      }
      if (v12 == v13)
      {
        unsigned int v18 = 0;
        unsigned int v17 = 0;
      }
      else
      {
        unsigned int v17 = 0;
        unsigned int v18 = 0;
        int v19 = v12;
        do
        {
          long long v28 = 0uLL;
          uint64_t v27 = 0;
          FSTCompactCodec_DecodeArc(v19, (int *)&v28, &v27);
          int v19 = (unsigned int *)((char *)v19 + v27);
          if (DWORD1(v28) == -2) {
            ++v17;
          }
          else {
            ++v18;
          }
        }
        while (v19 != v13);
      }
      uint64_t v15 = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v29);
      unsigned int v30 = v15;
      if (!v15)
      {
        uint64_t v20 = v29;
        *(_DWORD *)(v29 + 8) |= v7;
        *(_DWORD *)(v20 + 24) = a2;
        *(_DWORD *)(v20 + 28) = v14;
        if (v17)
        {
          int v21 = *(_OWORD **)(v20 + 40);
          if (!v21 || *((_DWORD *)v21 - 1) <= v17)
          {
            uint64_t v22 = _FSTState_ReserveEpsilonArcsInternal(v20, v17, &v30);
            uint64_t v15 = v30;
            if (v30) {
              return v15;
            }
            int v21 = (_OWORD *)v22;
          }
          uint64_t v20 = v29;
          if (v18) {
            goto LABEL_28;
          }
        }
        else
        {
          int v21 = 0;
          if (v18)
          {
LABEL_28:
            uint64_t v23 = *(_OWORD **)(v20 + 56);
            if (!v23 || *((_DWORD *)v23 - 1) <= v18)
            {
              uint64_t v24 = _FSTState_ReserveArcsInternal(v20, v18, &v30);
              uint64_t v15 = v30;
              if (v30) {
                return v15;
              }
              uint64_t v23 = (_OWORD *)v24;
            }
            uint64_t v20 = v29;
            goto LABEL_35;
          }
        }
        uint64_t v23 = 0;
LABEL_35:
        *(_DWORD *)(v20 + 32) = v17;
        *(_DWORD *)(v20 + 48) = v18;
        if (v12 != v13)
        {
          while (1)
          {
            long long v28 = 0uLL;
            uint64_t v27 = 0;
            FSTCompactCodec_DecodeArc(v12, (int *)&v28, &v27);
            if (v21)
            {
              if (DWORD1(v28) == -2) {
                break;
              }
            }
            if (v23)
            {
              unint64_t v25 = v23++;
              goto LABEL_41;
            }
LABEL_42:
            int v12 = (unsigned int *)((char *)v12 + v27);
            if (v12 == v13)
            {
              uint64_t v20 = v29;
              uint64_t v15 = v30;
              goto LABEL_45;
            }
          }
          unint64_t v25 = v21++;
LABEL_41:
          *unint64_t v25 = v28;
          goto LABEL_42;
        }
        uint64_t v15 = 0;
LABEL_45:
        *a4 = v20;
      }
    }
  }
  return v15;
}

uint64_t FSTStreamedCompact2_FillBuffer()
{
  return err_GenerateErrorNotSupported();
}

uint64_t FSTStreamedCompact2_GetFinalStateWeight(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  if ((*(char *)(*(void *)(*(void *)(*(void *)(a1 + 136) + 8)
                            + 8 * (a2 >> *(_WORD *)(*(void *)(a1 + 136) + 44)))
                + (~(-1 << *(_WORD *)(*(void *)(a1 + 136) + 44)) & a2)) & 0x80000000) == 0)
  {
    uint64_t result = 0;
    unsigned int v5 = 0x7FFFFFFF;
LABEL_3:
    *a3 = v5;
    return result;
  }
  uint64_t v7 = *(void *)(a1 + 128);
  uint64_t v8 = *(void *)(v7 + 8);
  LOBYTE(v7) = *(_WORD *)(v7 + 44);
  uint64_t v9 = *(void *)(v8 + 8 * (a2 >> v7));
  unsigned int v10 = 0;
  uint64_t result = (***(uint64_t (****)(void, void))(a1 + 112))(*(void *)(a1 + 112) - *(void *)(**(void **)(a1 + 112) + 56), (*(_DWORD *)(a1 + 144) + *(_DWORD *)(v9 + 4 * (a2 & ~(-1 << v7)))));
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(void, unsigned int *, uint64_t))(**(void **)(a1 + 112) + 8))(*(void *)(a1 + 112) - *(void *)(**(void **)(a1 + 112) + 56), &v10, 4);
    if (!result)
    {
      unsigned int v5 = bswap32(v10);
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t FSTStreamedCompact2_GetMemoryInfo(uint64_t a1)
{
  return FSTBaseFlat_GetMemoryInfo(a1) + *(void *)(a1 + 160) + (5 * *(_DWORD *)(a1 + 120)) + 56;
}

uint64_t FSTStreamedCompact2_GetStateFlags(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  *a3 = *(unsigned __int8 *)(*(void *)(*(void *)(*(void *)(a1 + 136) + 8)
                                       + 8 * (a2 >> *(_WORD *)(*(void *)(a1 + 136) + 44)))
                           + (~(-1 << *(_WORD *)(*(void *)(a1 + 136) + 44)) & a2)) << 24;
  return 0;
}

void PNEW_FSTStreamedCompact2_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 168, &v12);
  if (!v12)
  {
    FSTStreamedCompact2_Con(v10, a2, a3, a4);
    int v12 = v11;
    if (v11)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
    }
    else
    {
      *(void *)(v10 + 16) = a1;
      *a5 = v10;
    }
  }
}

void PNEW_FSTStreamedCompact2_ConFromIStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  int v15 = 0;
  uint64_t v13 = (void *)OOCAllocator_Malloc(a1, 168, &v15);
  if (!v15)
  {
    FSTStreamedCompact2_ConFromIStream(v13, a2, a3, a4, a5);
    int v15 = v14;
    if (v14)
    {
      OOCAllocator_Free(a1, (uint64_t)v13);
      *a7 = 0;
    }
    else
    {
      v13[2] = a1;
      *a7 = v13;
    }
  }
}

void *GetFSTStreamedCompact2Class()
{
  return &__FSTStreamedCompact2;
}

uint64_t FSTSearchCache_Con(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  uint64_t result = _FSTUnaryOperator_Con(a1, a2, a3);
  unsigned int v19 = result;
  if (result) {
    return result;
  }
  *(void *)a1 = &__FSTSearchCache;
  *(void *)(a1 + 128) = a4;
  *(void *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 160) = a5;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 32) = 39;
  if (!a5) {
    goto LABEL_14;
  }
  unsigned int v23 = 0;
  uint64_t v22 = 0;
  long long v21 = 0u;
  memset(v20, 0, sizeof(v20));
  uint64_t v11 = *(void *)(a1 + 24);
  int v12 = (unsigned int *)OOCAllocator_Malloc(v11, 4 * a4, &v23);
  uint64_t result = v23;
  if (v23) {
    return result;
  }
  uint64_t result = FSTCountBfsContext_Con(v20, v11, *(void *)(a1 + 64));
  unsigned int v23 = result;
  if (result) {
    return result;
  }
  uint64_t result = FSTBfsContext_BfsPartial((uint64_t)v20, v12, *(void *)(a1 + 128));
  unsigned int v23 = result;
  if (result) {
    return result;
  }
  *(void *)(a1 + 144) = DWORD1(v21);
  uint64_t result = (*(uint64_t (**)(_OWORD *))(*(void *)&v20[0] + 16))(v20);
  unsigned int v23 = result;
  if (result) {
    return result;
  }
  uint64_t v13 = *(void *)(a1 + 144);
  uint64_t v14 = OOCAllocator_Malloc(v11, 8 * v13, &v23);
  *(void *)(a1 + 152) = v14;
  uint64_t result = v23;
  if (v23) {
    return result;
  }
  if (v13 < 1)
  {
LABEL_13:
    OOCAllocator_Free(v11, (uint64_t)v12);
    uint64_t result = v23;
    unsigned int v19 = v23;
    if (v23) {
      return result;
    }
LABEL_14:
    *(_DWORD *)(a1 + 72) = 10;
    uint64_t v17 = OOCAllocator_Malloc(a2, 40, &v19);
    *(void *)(a1 + 80) = v17;
    uint64_t result = v19;
    if (!v19)
    {
      *(void *)(a1 + 88) = v17 + 4 * *(unsigned int *)(a1 + 72);
      *(_DWORD *)(a1 + 96) = 10;
      uint64_t v18 = OOCAllocator_Malloc(a2, 160, &v19);
      *(void *)(a1 + 104) = v18;
      uint64_t result = v19;
      if (!v19)
      {
        *(void *)(a1 + 112) = v18 + 16 * *(unsigned int *)(a1 + 96);
        *(_DWORD *)(a1 + 120) = -1;
        cstdlib_memset(*(void **)(a1 + 80), 255, 4 * *(unsigned int *)(a1 + 72));
        *(void *)(a1 + 112) = *(void *)(a1 + 104);
        *(_DWORD *)(a1 + 120) = -1;
        *(_DWORD *)(*(void *)(a3 + 48) + 40) = a4 + 10;
        return v19;
      }
    }
    return result;
  }
  int v15 = &v12[v13];
  unsigned int v16 = v12;
  while (1)
  {
    uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), *v16, 8, v14);
    unsigned int v23 = result;
    if (result) {
      return result;
    }
    ++v16;
    v14 += 8;
    if (v16 >= v15) {
      goto LABEL_13;
    }
  }
}

uint64_t FSTSearchCache_Des(void *a1)
{
  uint64_t v2 = a1[3];
  uint64_t v3 = (uint64_t *)a1[19];
  *(_DWORD *)(*(void *)(a1[8] + 48) + 40) = 10;
  unint64_t v5 = a1[13];
  unint64_t v4 = a1[14];
  while (v5 < v4)
  {
    uint64_t v6 = *(void *)(v5 + 8);
    if (v6)
    {
      int v7 = *(_DWORD *)(v6 + 8);
      if ((v7 & 0x3FFFFFF) == 1)
      {
        if ((v7 & 0x8000000) != 0) {
          uint64_t v8 = *(void *)(v6 + 16);
        }
        else {
          uint64_t v8 = 0;
        }
        uint64_t result = FSTStatePool_PushFSTState(v8, v6);
        if (result) {
          return result;
        }
        unint64_t v4 = a1[14];
      }
      else
      {
        *(_DWORD *)(v6 + 8) = v7 - 1;
        if ((v7 & 0x3FFFFFF) == 0) {
          return 9;
        }
      }
    }
    v5 += 16;
  }
  uint64_t v10 = a1[10];
  if (v10) {
    OOCAllocator_Free(v2, v10);
  }
  uint64_t v11 = a1[13];
  if (v11) {
    OOCAllocator_Free(v2, v11);
  }
  uint64_t v12 = a1[19];
  if (v12)
  {
    uint64_t v13 = a1[18];
    while ((unint64_t)v3 < v12 + 8 * v13)
    {
      uint64_t v14 = *v3;
      int v15 = *(_DWORD *)(*v3 + 8);
      if ((v15 & 0x3FFFFFF) == 1)
      {
        if ((v15 & 0x8000000) != 0) {
          uint64_t v16 = *(void *)(v14 + 16);
        }
        else {
          uint64_t v16 = 0;
        }
        uint64_t result = FSTStatePool_PushFSTState(v16, *v3);
        if (result) {
          return result;
        }
        uint64_t v13 = a1[18];
        uint64_t v12 = a1[19];
      }
      else
      {
        *(_DWORD *)(v14 + 8) = v15 - 1;
        if ((v15 & 0x3FFFFFF) == 0) {
          return 9;
        }
      }
      ++v3;
    }
    OOCAllocator_Free(v2, v12);
  }

  return FSTUnaryOperator_Des((uint64_t)a1);
}

uint64_t FSTSearchCache_Add(uint64_t a1, uint64_t a2)
{
  unsigned int v36 = 0;
  uint64_t v35 = 0;
  if (*(void *)(a1 + 136) < *(void *)(a1 + 128))
  {
    unsigned int v2 = a2;
    unint64_t v4 = (unsigned int *)(*(void *)(a1 + 80)
                        + 4 * (a2 % ((*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2)));
    while (1)
    {
      uint64_t v5 = *v4;
      if ((v5 & 0x80000000) != 0) {
        break;
      }
      unint64_t v4 = (unsigned int *)(*(void *)(a1 + 104) + 16 * v5);
      uint64_t v6 = *((void *)v4 + 1);
      if (*(_DWORD *)(v6 + 24) == a2) {
        goto LABEL_5;
      }
    }
    unsigned int v36 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, 8, &v35);
    if (!v36)
    {
      uint64_t v8 = v35;
      if (!v35)
      {
        ++*(void *)(a1 + 136);
        return v36;
      }
      LODWORD(v9) = *(_DWORD *)(a1 + 120);
      if (v9 == -1)
      {
        uint64_t v12 = *(void *)(a1 + 104);
        uint64_t v13 = *(void **)(a1 + 112);
        uint64_t v9 = ((unint64_t)v13 - v12) >> 4;
        uint64_t v14 = *(char **)(a1 + 80);
        unint64_t v15 = *(void *)(a1 + 88) - (void)v14;
        if (((v15 >> 1) & 0xFFFFFFFE) >= v9)
        {
          unint64_t v20 = ((unint64_t)v13 - v12) >> 4;
        }
        else
        {
          unsigned int v16 = (v15 >> 1) | 1;
          uint64_t v17 = *(unsigned int *)(a1 + 72);
          if (v16 <= v17)
          {
            uint64_t v9 = 4 * v17;
          }
          else
          {
            if (v16 <= 8) {
              unsigned int v18 = 8;
            }
            else {
              unsigned int v18 = (v15 >> 1) | 1;
            }
            uint64_t v9 = 4 * v18;
            uint64_t v19 = OOCAllocator_Realloc(*(void *)(a1 + 24), *(void *)(a1 + 80), v9, &v36);
            *(void *)(a1 + 80) = v19;
            if (v36) {
              return v36;
            }
            uint64_t v14 = (char *)v19;
            *(_DWORD *)(a1 + 72) = v18;
            v15 &= 0x3FFFFFFFCuLL;
          }
          unint64_t v21 = (v15 >> 1) & 0xFFFFFFFE | 1;
          *(void *)(a1 + 88) = &v14[4 * v21];
          cstdlib_memset(v14, 255, v9);
          uint64_t v12 = *(void *)(a1 + 104);
          uint64_t v13 = *(void **)(a1 + 112);
          unint64_t v20 = ((unint64_t)v13 - v12) >> 4;
          LODWORD(v9) = v20;
          if (v20)
          {
            uint64_t v22 = 0;
            uint64_t v23 = *(void *)(a1 + 104);
            do
            {
              if (((*(_DWORD *)v23 + 1) & 0x40000000) == 0)
              {
                if (v36) {
                  return v36;
                }
                unint64_t v24 = *(unsigned int *)(*(void *)(v23 + 8) + 24);
                uint64_t v25 = v24 - (v24 / v21) * (unint64_t)v21;
                uint64_t v26 = *(void *)(a1 + 80);
                *(_DWORD *)uint64_t v23 = *(_DWORD *)(v26 + 4 * v25);
                *(_DWORD *)(v26 + 4 * v25) = v22;
              }
              ++v22;
              v23 += 16;
            }
            while ((((unint64_t)v13 - v12) >> 4) != v22);
          }
        }
        unsigned int v27 = v9 + 1;
        unsigned int v28 = *(_DWORD *)(a1 + 96);
        if ((int)v9 + 1 > v28)
        {
          unsigned int v29 = 2 * v28;
          unsigned int v30 = v28 + 1000000;
          if (v29 >= v30) {
            unsigned int v29 = v30;
          }
          if (v29 > v27) {
            unsigned int v27 = v29;
          }
          if (v27 <= 8) {
            unsigned int v31 = 8;
          }
          else {
            unsigned int v31 = v27;
          }
          uint64_t v32 = OOCAllocator_Realloc(*(void *)(a1 + 24), v12, 16 * v31, &v36);
          *(void *)(a1 + 104) = v32;
          if (v36) {
            return v36;
          }
          *(_DWORD *)(a1 + 96) = v31;
          uint64_t v13 = (void *)(v32 + 16 * v20);
        }
        *(void *)(a1 + 112) = v13 + 2;
        *uint64_t v13 = 0;
        v13[1] = v8;
        uint64_t v10 = (int)v9;
      }
      else
      {
        uint64_t v10 = (int)v9;
        uint64_t v11 = *(void *)(a1 + 104) + 16 * (int)v9;
        *(_DWORD *)(a1 + 120) = (*(_DWORD *)v11 & 0xBFFFFFFF) - 1;
        *(void *)uint64_t v11 = 0;
        *(void *)(v11 + 8) = v8;
      }
      uint64_t v33 = *(void *)(a1 + 80);
      unsigned int v34 = v2 % ((unint64_t)(*(void *)(a1 + 88) - v33) >> 2);
      *(_DWORD *)(*(void *)(a1 + 104) + 16 * v10) = *(_DWORD *)(v33 + 4 * v34);
      *(_DWORD *)(v33 + 4 * v34) = v9;
      uint64_t v6 = v35;
      ++*(void *)(a1 + 136);
      if (v6) {
LABEL_5:
      }
        *(_DWORD *)(v6 + 8) |= 0x4000000u;
    }
  }
  return v36;
}

uint64_t FSTSearchCache_FetchState(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t *a4)
{
  *a4 = 0;
  uint64_t v5 = (unsigned int *)(*(void *)(a1 + 80)
                      + 4 * (a2 % ((*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2)));
  while (1)
  {
    uint64_t v6 = *v5;
    if ((v6 & 0x80000000) != 0) {
      break;
    }
    uint64_t v5 = (unsigned int *)(*(void *)(a1 + 104) + 16 * v6);
    uint64_t v8 = (uint64_t *)(v5 + 2);
    uint64_t v7 = *((void *)v5 + 1);
    if (*(_DWORD *)(v7 + 24) == a2)
    {
      if (FST_CheckQuery(*(_DWORD *)(v7 + 8) & 0xF0000000, a3))
      {
        uint64_t v9 = *v8;
        *a4 = *v8;
        if (v9) {
          goto LABEL_6;
        }
      }
      else
      {
        uint64_t v9 = *a4;
        if (*a4) {
LABEL_6:
        }
          ++*(_DWORD *)(v9 + 8);
      }
      return 0;
    }
  }
  uint64_t v11 = *(uint64_t (**)(void))(**(void **)(a1 + 64) + 120);

  return v11();
}

uint64_t FSTSearchCache_GetFinalStateWeight(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  uint64_t v3 = (unsigned int *)(*(void *)(a1 + 80)
                      + 4 * (a2 % ((*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2)));
  while (1)
  {
    uint64_t v4 = *v3;
    if ((v4 & 0x80000000) != 0) {
      break;
    }
    uint64_t v3 = (unsigned int *)(*(void *)(a1 + 104) + 16 * v4);
    uint64_t v5 = *((void *)v3 + 1);
    if (*(_DWORD *)(v5 + 24) == a2)
    {
      *a3 = *(_DWORD *)(v5 + 28);
      return 0;
    }
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 64))(*(void *)(a1 + 64));
}

uint64_t FSTSearchCache_GetMaxBranchFactor(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 136))(*(void *)(a1 + 64));
}

uint64_t FSTSearchCache_GetMemoryInfo(uint64_t a1)
{
  uint64_t MemoryInfo = FSTUnaryOperator_GetMemoryInfo(a1);
  for (unint64_t i = *(void *)(a1 + 104); i < *(void *)(a1 + 112); i += 16)
  {
    uint64_t v5 = *(void *)(i + 8);
    if (v5)
    {
      uint64_t v6 = *(void *)(v5 + 56);
      if (v6 || (uint64_t v6 = *(void *)(v5 + 40)) != 0) {
        uint64_t v6 = *(unsigned int *)(v6 - 4);
      }
      v3 += 16 * v6 + 64;
    }
  }
  return MemoryInfo + 4 * *(unsigned int *)(a1 + 72) + 16 * *(unsigned int *)(a1 + 96) + 96;
}

uint64_t FSTSearchCache_GetStateFlags(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  uint64_t v3 = (unsigned int *)(*(void *)(a1 + 80)
                      + 4 * (a2 % ((*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2)));
  while (1)
  {
    uint64_t v4 = *v3;
    if ((v4 & 0x80000000) != 0) {
      break;
    }
    uint64_t v3 = (unsigned int *)(*(void *)(a1 + 104) + 16 * v4);
    uint64_t v5 = *((void *)v3 + 1);
    if (*(_DWORD *)(v5 + 24) == a2)
    {
      *a3 = *(_DWORD *)(v5 + 8) & 0xF0000000;
      return 0;
    }
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 56))(*(void *)(a1 + 64));
}

uint64_t FSTSearchCache_Purge(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 104);
  uint64_t v1 = *(void *)(a1 + 112);
  if ((int)((unint64_t)(v1 - v2) >> 4) >= 1)
  {
    for (uint64_t i = 0; i < (int)((unint64_t)(v1 - v2) >> 4); ++i)
    {
      uint64_t v5 = (int *)(v2 + 16 * i);
      uint64_t v7 = v5 + 2;
      uint64_t v6 = *((void *)v5 + 1);
      if (v6)
      {
        int v8 = *(_DWORD *)(v6 + 8);
        if ((v8 & 0x4000000) != 0)
        {
          *(_DWORD *)(v6 + 8) = v8 & 0xFBFFFFFF;
        }
        else
        {
          uint64_t v9 = *(void *)(a1 + 80);
          uint64_t v10 = *(_DWORD *)(v6 + 24) % ((unint64_t)(*(void *)(a1 + 88) - v9) >> 2);
          uint64_t v11 = *(unsigned int *)(v9 + 4 * v10);
          if ((v11 & 0x80000000) != 0)
          {
            uint64_t v12 = 0xFFFFFFFFLL;
          }
          else
          {
            uint64_t v12 = 0xFFFFFFFFLL;
            do
            {
              if (i == v11) {
                break;
              }
              uint64_t v12 = v11;
              uint64_t v11 = *(unsigned int *)(v2 + 16 * v11);
            }
            while ((v11 & 0x80000000) == 0);
          }
          int v13 = *v5;
          int v14 = *(_DWORD *)(a1 + 120);
          *(_DWORD *)(a1 + 120) = i;
          int *v5 = (v14 + 1) | 0x40000000;
          if ((v12 & 0x80000000) != 0 && v13 < 0)
          {
            *(_DWORD *)(v9 + 4 * v10) = -1;
          }
          else if ((v12 & 0x80000000) != 0)
          {
            *(_DWORD *)(v9 + 4 * v10) = v13;
          }
          else
          {
            *(_DWORD *)(v2 + 16 * v12) = v13;
          }
          int v15 = *(_DWORD *)(v6 + 8);
          if ((v15 & 0x3FFFFFF) == 1)
          {
            if ((v15 & 0x8000000) != 0) {
              uint64_t v16 = *(void *)(v6 + 16);
            }
            else {
              uint64_t v16 = 0;
            }
            uint64_t result = FSTStatePool_PushFSTState(v16, v6);
            if (result) {
              return result;
            }
            uint64_t v2 = *(void *)(a1 + 104);
            uint64_t v1 = *(void *)(a1 + 112);
          }
          else
          {
            *(_DWORD *)(v6 + 8) = v15 - 1;
            if ((v15 & 0x3FFFFFF) == 0) {
              return 9;
            }
          }
          void *v7 = 0;
          --*(void *)(a1 + 136);
        }
      }
    }
  }
  return 0;
}

uint64_t FSTSearchCache_Reset(uint64_t a1)
{
  unint64_t v3 = *(void *)(a1 + 104);
  unint64_t v2 = *(void *)(a1 + 112);
  while (v3 < v2)
  {
    uint64_t v4 = *(void *)(v3 + 8);
    if (v4)
    {
      int v5 = *(_DWORD *)(v4 + 8);
      if ((v5 & 0x3FFFFFF) == 1)
      {
        if ((v5 & 0x8000000) != 0) {
          uint64_t v6 = *(void *)(v4 + 16);
        }
        else {
          uint64_t v6 = 0;
        }
        uint64_t result = FSTStatePool_PushFSTState(v6, v4);
        if (result) {
          return result;
        }
        unint64_t v2 = *(void *)(a1 + 112);
      }
      else
      {
        *(_DWORD *)(v4 + 8) = v5 - 1;
        if ((v5 & 0x3FFFFFF) == 0) {
          return 9;
        }
      }
    }
    v3 += 16;
  }
  cstdlib_memset(*(void **)(a1 + 80), 255, 4 * *(unsigned int *)(a1 + 72));
  uint64_t v7 = *(void *)(a1 + 104);
  *(void *)(a1 + 112) = v7;
  *(_DWORD *)(a1 + 120) = -1;
  *(void *)(a1 + 136) = 0;
  if (!*(_DWORD *)(a1 + 160)) {
    return FSTUnaryOperator_Reset(a1);
  }
  unsigned int v38 = 0;
  uint64_t v8 = *(void *)(a1 + 144);
  if (v8 <= 0) {
    return FSTUnaryOperator_Reset(a1);
  }
  uint64_t v9 = *(uint64_t **)(a1 + 152);
  unint64_t v10 = (unint64_t)&v9[v8];
  while (1)
  {
    uint64_t result = v38;
    if (v38) {
      break;
    }
    uint64_t v11 = *v9;
    unsigned int v12 = *(_DWORD *)(*v9 + 24);
    LODWORD(v13) = *(_DWORD *)(a1 + 120);
    if (v13 == -1)
    {
      uint64_t v16 = *(void **)(a1 + 112);
      uint64_t v13 = ((unint64_t)v16 - v7) >> 4;
      uint64_t v17 = *(char **)(a1 + 80);
      uint64_t v18 = (*(void *)(a1 + 88) - (void)v17) >> 1;
      if ((v18 & 0xFFFFFFFE) >= v13)
      {
        unint64_t v21 = ((unint64_t)v16 - v7) >> 4;
      }
      else
      {
        uint64_t v19 = *(unsigned int *)(a1 + 72);
        if ((v18 | 1) <= v19)
        {
          uint64_t v13 = 4 * v19;
        }
        else
        {
          if ((v18 | 1) <= 8) {
            unsigned int v20 = 8;
          }
          else {
            unsigned int v20 = v18 | 1;
          }
          uint64_t v13 = 4 * v20;
          uint64_t v17 = (char *)OOCAllocator_Realloc(*(void *)(a1 + 24), *(void *)(a1 + 80), v13, &v38);
          *(void *)(a1 + 80) = v17;
          uint64_t result = v38;
          if (v38) {
            return result;
          }
          *(_DWORD *)(a1 + 72) = v20;
          LODWORD(v18) = v18 & 0xFFFFFFFE;
        }
        unint64_t v22 = v18 & 0xFFFFFFFE | 1;
        *(void *)(a1 + 88) = &v17[4 * v22];
        cstdlib_memset(v17, 255, v13);
        uint64_t v7 = *(void *)(a1 + 104);
        uint64_t v16 = *(void **)(a1 + 112);
        unint64_t v21 = ((unint64_t)v16 - v7) >> 4;
        LODWORD(v13) = v21;
        if (v21)
        {
          uint64_t v23 = 0;
          uint64_t v24 = *(void *)(a1 + 104);
          do
          {
            if (((*(_DWORD *)v24 + 1) & 0x40000000) == 0)
            {
              uint64_t result = v38;
              if (v38) {
                return result;
              }
              unint64_t v25 = *(unsigned int *)(*(void *)(v24 + 8) + 24);
              uint64_t v26 = v25 - (v25 / v22) * (unint64_t)v22;
              uint64_t v27 = *(void *)(a1 + 80);
              *(_DWORD *)uint64_t v24 = *(_DWORD *)(v27 + 4 * v26);
              *(_DWORD *)(v27 + 4 * v26) = v23;
            }
            ++v23;
            v24 += 16;
          }
          while ((((unint64_t)v16 - v7) >> 4) != v23);
        }
      }
      unsigned int v28 = v13 + 1;
      unsigned int v29 = *(_DWORD *)(a1 + 96);
      if ((int)v13 + 1 > v29)
      {
        unsigned int v30 = 2 * v29;
        unsigned int v31 = v29 + 1000000;
        if (v30 >= v31) {
          unsigned int v30 = v31;
        }
        if (v30 > v28) {
          unsigned int v28 = v30;
        }
        if (v28 <= 8) {
          unsigned int v32 = 8;
        }
        else {
          unsigned int v32 = v28;
        }
        uint64_t v33 = OOCAllocator_Realloc(*(void *)(a1 + 24), v7, 16 * v32, &v38);
        *(void *)(a1 + 104) = v33;
        uint64_t result = v38;
        if (v38) {
          return result;
        }
        *(_DWORD *)(a1 + 96) = v32;
        uint64_t v16 = (void *)(v33 + 16 * v21);
      }
      *(void *)(a1 + 112) = v16 + 2;
      void *v16 = 0;
      v16[1] = v11;
      uint64_t v14 = (int)v13;
    }
    else
    {
      uint64_t v14 = (int)v13;
      uint64_t v15 = v7 + 16 * (int)v13;
      *(_DWORD *)(a1 + 120) = (*(_DWORD *)v15 & 0xBFFFFFFF) - 1;
      *(void *)uint64_t v15 = 0;
      *(void *)(v15 + 8) = v11;
    }
    uint64_t v34 = *(void *)(a1 + 80);
    unsigned int v35 = v12 % ((unint64_t)(*(void *)(a1 + 88) - v34) >> 2);
    uint64_t v7 = *(void *)(a1 + 104);
    *(_DWORD *)(v7 + 16 * v14) = *(_DWORD *)(v34 + 4 * v35);
    *(_DWORD *)(v34 + 4 * v35) = v13;
    uint64_t v36 = *v9++;
    *(_DWORD *)(v36 + 8) = (*(_DWORD *)(v36 + 8) + 1) | 0x4000000;
    ++*(void *)(a1 + 136);
    if ((unint64_t)v9 >= v10)
    {
      uint64_t result = v38;
      if (v38) {
        return result;
      }
      return FSTUnaryOperator_Reset(a1);
    }
  }
  return result;
}

uint64_t FSTSearchCache_Resize(uint64_t a1, unsigned int a2)
{
  unsigned int v24 = 0;
  if (*(void *)(a1 + 128) == a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 112))(a1);
  }
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v7 = (uint64_t *)(a1 + 104);
  unint64_t v6 = *(void *)(a1 + 104);
  *(_DWORD *)(*(void *)(a1 + 48) + 40) = a2 + 10;
  unint64_t v8 = *(void *)(a1 + 112);
  while (v6 < v8)
  {
    uint64_t v9 = *(void *)(v6 + 8);
    if (v9)
    {
      int v10 = *(_DWORD *)(v9 + 8);
      if ((v10 & 0x3FFFFFF) == 1)
      {
        if ((v10 & 0x8000000) != 0) {
          uint64_t v11 = *(void *)(v9 + 16);
        }
        else {
          uint64_t v11 = 0;
        }
        uint64_t result = FSTStatePool_PushFSTState(v11, v9);
        if (result) {
          return result;
        }
        unint64_t v8 = *(void *)(a1 + 112);
      }
      else
      {
        *(_DWORD *)(v9 + 8) = v10 - 1;
        if ((v10 & 0x3FFFFFF) == 0) {
          return 9;
        }
      }
    }
    v6 += 16;
  }
  unsigned int v24 = 0;
  uint64_t v12 = *(void *)(a1 + 80);
  if (v12) {
    OOCAllocator_Free(v5, v12);
  }
  if (*v7) {
    OOCAllocator_Free(v5, *v7);
  }
  if (!a2)
  {
    *(_DWORD *)(a1 + 72) = 1;
    uint64_t v15 = OOCAllocator_Malloc(v5, 4, &v24);
    *(void *)(a1 + 80) = v15;
    uint64_t result = v24;
    if (v24) {
      return result;
    }
    uint64_t v16 = *(unsigned int *)(a1 + 72);
    unint64_t v17 = v15 + 4 * v16;
    *(void *)(a1 + 88) = v17;
    if (v16)
    {
      if (v17 <= v15 + 4) {
        unint64_t v17 = v15 + 4;
      }
      memset((void *)v15, 255, ((v17 + ~v15) & 0xFFFFFFFFFFFFFFFCLL) + 4);
    }
    *(_DWORD *)(a1 + 96) = 0;
    uint64_t *v7 = 0;
    *(void *)(a1 + 112) = 0;
    goto LABEL_29;
  }
  *(_DWORD *)(a1 + 72) = a2;
  uint64_t v13 = OOCAllocator_Malloc(v5, 4 * a2, &v24);
  *(void *)(a1 + 80) = v13;
  uint64_t result = v24;
  if (!v24)
  {
    *(void *)(a1 + 88) = v13 + 4 * *(unsigned int *)(a1 + 72);
    *(_DWORD *)(a1 + 96) = a2;
    uint64_t v14 = OOCAllocator_Malloc(v5, 16 * a2, &v24);
    *(void *)(a1 + 104) = v14;
    uint64_t result = v24;
    if (!v24)
    {
      *(void *)(a1 + 112) = v14 + 16 * *(unsigned int *)(a1 + 96);
      *(_DWORD *)(a1 + 120) = -1;
      cstdlib_memset(*(void **)(a1 + 80), 255, 4 * *(unsigned int *)(a1 + 72));
      *(void *)(a1 + 112) = *(void *)(a1 + 104);
LABEL_29:
      *(_DWORD *)(a1 + 120) = -1;
      uint64_t v18 = *(void *)(a1 + 152);
      if (v18)
      {
        uint64_t v19 = *(void *)(a1 + 144);
        if (v19 > (unint64_t)a2)
        {
          if (v19 > a2)
          {
            for (uint64_t i = (uint64_t *)(v18 + 8 * a2); (unint64_t)i < v18 + 8 * v19; ++i)
            {
              uint64_t v21 = *i;
              int v22 = *(_DWORD *)(*i + 8);
              if ((v22 & 0x3FFFFFF) == 1)
              {
                if ((v22 & 0x8000000) != 0) {
                  uint64_t v23 = *(void *)(v21 + 16);
                }
                else {
                  uint64_t v23 = 0;
                }
                uint64_t result = FSTStatePool_PushFSTState(v23, *i);
                unsigned int v24 = result;
                if (result) {
                  return result;
                }
                uint64_t v19 = *(void *)(a1 + 144);
                uint64_t v18 = *(void *)(a1 + 152);
              }
              else
              {
                *(_DWORD *)(v21 + 8) = v22 - 1;
                if ((v22 & 0x3FFFFFF) == 0) {
                  return 9;
                }
                unsigned int v24 = 0;
              }
            }
          }
          if (a2)
          {
            *(void *)(a1 + 152) = OOCAllocator_Realloc(v5, v18, 8 * a2, &v24);
            uint64_t result = v24;
            if (v24) {
              return result;
            }
          }
          else
          {
            OOCAllocator_Free(v5, v18);
            *(void *)(a1 + 152) = 0;
          }
          *(void *)(a1 + 144) = a2;
        }
      }
      *(void *)(a1 + 128) = a2;
      return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 112))(a1);
    }
  }
  return result;
}

uint64_t PNEW_FSTSearchCache_Con(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 168, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = FSTSearchCache_Con(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *(void *)(v12 + 16) = a1;
      *a6 = v12;
    }
  }
  return result;
}

void *GetFSTSearchCacheClass()
{
  return &__FSTSearchCache;
}

uint64_t FSTPropertiesDfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = FSTDfsContext_Con(a1, a2, a3);
  if (!result)
  {
    *(void *)a1 = &__FSTPropertiesDfsContext;
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 88) = 0;
  }
  return result;
}

BOOL FSTPropertiesDfsContext_AbortDFS(uint64_t a1)
{
  return *(_DWORD *)(a1 + 68) == 0;
}

uint64_t FSTPropertiesDfsContext_DiscoverState(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 68);
  uint64_t v5 = *(unsigned int (**)(void))(a1 + 80);
  if (v5
    && (*(_DWORD *)(a2 + 48) >= 2u && !v5(*(void *)(a2 + 56))
     || *(_DWORD *)(a2 + 32) >= 2u && !(*(unsigned int (**)(void))(a1 + 80))(*(void *)(a2 + 40))))
  {
    int v6 = *(_DWORD *)(a1 + 88);
    int v7 = *(_DWORD *)(a1 + 72) | v6;
    *(_DWORD *)(a1 + 68) &= ~v6;
    *(_DWORD *)(a1 + 72) = v7;
    *(_DWORD *)(a1 + 76) &= ~v6;
    *(void *)(a1 + 80) = 0;
  }
  if ((v4 & 0x2000) != 0 && *(_DWORD *)(a2 + 32))
  {
    LODWORD(v8) = *(void *)(a1 + 68) & 0xFFFFDFFF;
    HIDWORD(v8) = (*(void *)(a1 + 68) | 0x200000002000uLL) >> 32;
    *(void *)(a1 + 68) = v8;
    *(_DWORD *)(a1 + 76) &= ~0x2000u;
  }
  if ((v4 & 0x4000) != 0)
  {
    if (!*(_DWORD *)(a2 + 28))
    {
      if (*(_DWORD *)(a2 + 48))
      {
        if (!*(_DWORD *)(*(void *)(a2 + 56) + 12))
        {
          while (1)
            ;
        }
      }
      else
      {
        if (!*(_DWORD *)(a2 + 32)) {
          goto LABEL_13;
        }
        if (!*(_DWORD *)(*(void *)(a2 + 40) + 12))
        {
          while (1)
            ;
        }
      }
    }
    LODWORD(v9) = *(void *)(a1 + 68) & 0xFFFFBFFF;
    HIDWORD(v9) = (*(void *)(a1 + 68) | 0x400000004000uLL) >> 32;
    *(void *)(a1 + 68) = v9;
    *(_DWORD *)(a1 + 76) &= ~0x4000u;
  }
LABEL_13:
  if ((v4 & 0x800) != 0 && (*(_DWORD *)(a2 + 8) & 0x80000000) == 0 && !*(_DWORD *)(a2 + 48) && !*(_DWORD *)(a2 + 32))
  {
    LODWORD(v10) = *(void *)(a1 + 68) & 0xFFFFF7FF;
    HIDWORD(v10) = (*(void *)(a1 + 68) | 0x80000000800uLL) >> 32;
    *(void *)(a1 + 68) = v10;
    *(_DWORD *)(a1 + 76) &= ~0x800u;
  }
  return 0;
}

uint64_t FSTPropertiesDfsContext_ExploreNonTreeArc(uint64_t a1, int a2, _DWORD *a3)
{
  unsigned int v3 = *(_DWORD *)(a1 + 68);
  unsigned int v4 = v3;
  if ((v3 & 0x200) != 0)
  {
    unsigned int v4 = *(_DWORD *)(a1 + 68);
    if (*(unsigned char *)(*(void *)(a1 + 24) + *a3) == 1)
    {
      unsigned int v4 = v3 & 0xFFFFFDFF;
      *(_DWORD *)(a1 + 68) = v3 & 0xFFFFFDFF;
      *(void *)(a1 + 72) |= 0x20000000200uLL;
    }
  }
  if ((v3 & 0x10000) != 0 && *a3 == a2)
  {
    v4 &= ~0x10000u;
    *(_DWORD *)(a1 + 68) = v4;
    *(void *)(a1 + 72) |= 0x1000000010000uLL;
  }
  if ((v3 & 0x8000) != 0)
  {
    *(_DWORD *)(a1 + 68) = v4 & 0xFFFF7FFF;
    LODWORD(v5) = *(void *)(a1 + 72) | 0x8000;
    HIDWORD(v5) = (*(void *)(a1 + 72) & 0xFFFF7FFFFFFF7FFFLL) >> 32;
    *(void *)(a1 + 72) = v5;
  }
  return 0;
}

uint64_t FSTPropertiesDfsContext_ExploreTreeArc()
{
  return 0;
}

uint64_t FSTPropertiesDfsContext_FinishState()
{
  return 0;
}

uint64_t FSTPropertiesDfsContext_GetDecidableProperties()
{
  return 126719;
}

uint64_t FSTPropertiesDfsContext_QueryProperties(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 40);
  int v6 = *(_DWORD *)(v5 + 44);
  *(_DWORD *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  int v7 = v6 & a2;
  int v8 = *(_DWORD *)(v5 + 40) & *(_DWORD *)(v5 + 44) & v6 & a2;
  *(_DWORD *)(a1 + 76) = v8;
  int v9 = v7 ^ a2;
  *(_DWORD *)(a1 + 64) = a2;
  *(_DWORD *)(a1 + 68) = v9;
  if (!v9)
  {
LABEL_31:
    uint64_t result = 0;
    int v26 = v8 & v9 | *(_DWORD *)(v5 + 40) & ~v9;
    int v27 = *(_DWORD *)(v5 + 44) | v9;
    *(_DWORD *)(v5 + 40) = v26;
    *(_DWORD *)(v5 + 44) = v27;
    *a3 = v8 & a2;
    return result;
  }
  FSTDfsContext_SetDfsOptions((_DWORD *)a1, 0, 0, (v9 & 0x18200) != 0);
  int v11 = *(_DWORD *)(a1 + 68);
  if ((v11 & 0xFFFE1100) == 0)
  {
    uint64_t v12 = 0;
    unsigned int v13 = 0;
    *(_DWORD *)(a1 + 76) = *(_DWORD *)(a1 + 76) & ~(*(_DWORD *)(a1 + 68) & 0x10200) | *(_DWORD *)(a1 + 68) & 0xE8FF;
    unsigned int v14 = __FSTArcsSortedByInput;
    do
    {
      int v15 = arcOrderFunct[v12];
      if ((v15 & v11) != 0)
      {
        *(void *)(a1 + 80) = v14;
        *(_DWORD *)(a1 + 88) = v15;
        ++v13;
      }
      unsigned int v14 = *(uint64_t (**)(uint64_t, unsigned int))&arcOrderFunct[v12 + 6];
      v12 += 4;
    }
    while (v12 != 36);
    if (v13 < 2) {
      goto LABEL_34;
    }
  }
  uint64_t result = err_GenerateErrorNotSupported();
  if (!result)
  {
LABEL_34:
    uint64_t result = FSTDfsContext_Dfs(a1);
    if (!result)
    {
      uint64_t v17 = *(void *)(a1 + 40);
      int v18 = *(_DWORD *)(a1 + 64);
      int v8 = *(_DWORD *)(a1 + 76);
      int v19 = v18 & ~*(_DWORD *)(v17 + 44) & 0x1EAFF;
      int v20 = *(_DWORD *)(a1 + 68) & ~v19;
      int v9 = *(_DWORD *)(a1 + 72) | v19;
      *(_DWORD *)(a1 + 68) = v20;
      *(_DWORD *)(a1 + 72) = v9;
      int v21 = *(_DWORD *)(v17 + 36);
      int v22 = v8 & v18;
      if (v21 == 1)
      {
        if ((v22 & 0xB) != 0)
        {
          v20 &= 0xFFFFFFF4;
          v9 |= 0xBu;
          *(_DWORD *)(a1 + 68) = v20;
          *(_DWORD *)(a1 + 72) = v9;
          v8 |= 0xBu;
          *(_DWORD *)(a1 + 76) = v8;
        }
        if ((v22 & 0xA0) != 0)
        {
          v20 &= 0xFFFFFF5F;
          v9 |= 0xA0u;
          *(_DWORD *)(a1 + 68) = v20;
          *(_DWORD *)(a1 + 72) = v9;
          v8 |= 0xA0u;
          *(_DWORD *)(a1 + 76) = v8;
        }
      }
      if ((v22 & 0xF8) != 0)
      {
        v20 &= ~1u;
        v9 |= 1u;
        *(_DWORD *)(a1 + 68) = v20;
        *(_DWORD *)(a1 + 72) = v9;
        v8 |= 1u;
        *(_DWORD *)(a1 + 76) = v8;
      }
      if ((v22 & 0x70) != 0)
      {
        v20 &= 0xFFFFFFF6;
        v9 |= 9u;
        *(_DWORD *)(a1 + 68) = v20;
        *(_DWORD *)(a1 + 72) = v9;
        v8 |= 9u;
        *(_DWORD *)(a1 + 76) = v8;
      }
      if ((v22 & 0x40) != 0)
      {
        v20 &= ~0x10u;
        v9 |= 0x10u;
        *(_DWORD *)(a1 + 68) = v20;
        *(_DWORD *)(a1 + 72) = v9;
        v8 |= 0x10u;
        *(_DWORD *)(a1 + 76) = v8;
      }
      if ((v22 & 0x10200) != 0)
      {
        v20 &= ~0x8000u;
        v9 |= 0x8000u;
        *(_DWORD *)(a1 + 68) = v20;
        *(_DWORD *)(a1 + 72) = v9;
        v8 &= ~0x8000u;
        *(_DWORD *)(a1 + 76) = v8;
      }
      if ((v18 & 0x400) != 0)
      {
        uint64_t v23 = *(unsigned char **)(a1 + 24);
        unint64_t v24 = *(void *)(a1 + 32);
        if ((unint64_t)v23 < v24)
        {
          unint64_t v25 = v24 - (void)v23;
          while (*v23)
          {
            ++v23;
            if (!--v25) {
              goto LABEL_30;
            }
          }
          v20 &= ~0x400u;
          v9 |= 0x400u;
          v8 &= ~0x400u;
          *(_DWORD *)(a1 + 76) = v8;
        }
LABEL_30:
        v9 |= 0x400u;
        *(_DWORD *)(a1 + 68) = v20 & 0xFFFFFBFF;
        *(_DWORD *)(a1 + 72) = v9;
      }
      goto LABEL_31;
    }
  }
  return result;
}

uint64_t PNEW_FSTPropertiesDfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 96, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = FSTDfsContext_Con(v8, a2, a3);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *(void *)uint64_t v8 = &__FSTPropertiesDfsContext;
      *(void *)(v8 + 72) = 0;
      *(void *)(v8 + 80) = 0;
      *(void *)(v8 + 64) = 0;
      *(_DWORD *)(v8 + 88) = 0;
      *a4 = v8;
    }
  }
  return result;
}

void *GetFSTPropertiesDfsContextClass()
{
  return &__FSTPropertiesDfsContext;
}

uint64_t __FSTArcsSortedByInput(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = (int *)(a1 + 20);
  for (uint64_t i = 16 * a2 - 16; i; i -= 16)
  {
    int v4 = *(v2 - 4);
    int v5 = *v2;
    v2 += 4;
    if (v4 > v5) {
      return 0;
    }
  }
  return 1;
}

uint64_t __FSTArcsSortedByOutput(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = (int *)(a1 + 24);
  for (uint64_t i = 16 * a2 - 16; i; i -= 16)
  {
    int v4 = *(v2 - 4);
    int v5 = *v2;
    v2 += 4;
    if (v4 > v5) {
      return 0;
    }
  }
  return 1;
}

uint64_t __FSTArcsSortedByTarget(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = (unsigned int *)(a1 + 16);
  for (uint64_t i = 16 * a2 - 16; i; i -= 16)
  {
    unsigned int v4 = *(v2 - 4);
    unsigned int v5 = *v2;
    v2 += 4;
    if (v4 > v5) {
      return 0;
    }
  }
  return 1;
}

uint64_t __FSTArcsSortedByInputOutput(uint64_t a1, unsigned int a2)
{
  if (a2 == 1) {
    return 1;
  }
  unint64_t v2 = (_DWORD *)(a1 + 24);
  uint64_t v3 = 16 * a2 - 16;
  while (1)
  {
    int v4 = *(v2 - 5);
    int v5 = *(v2 - 1);
    if (v4 > v5 || v4 >= v5 && *(v2 - 4) > *v2) {
      break;
    }
    v2 += 4;
    v3 -= 16;
    if (!v3) {
      return 1;
    }
  }
  return 0;
}

uint64_t __FSTArcsSortedByInputOutputWeight(uint64_t a1, unsigned int a2)
{
  if (a2 == 1) {
    return 1;
  }
  uint64_t v2 = 16 * a2 - 16;
  for (uint64_t i = (_DWORD *)(a1 + 20); ; i += 4)
  {
    int v4 = *(i - 4);
    if (v4 > *i) {
      break;
    }
    if (v4 >= *i)
    {
      int v5 = *(i - 3);
      int v6 = i[1];
      if (v5 > v6 || v5 >= v6 && *(i - 2) > i[2]) {
        break;
      }
    }
    v2 -= 16;
    if (!v2) {
      return 1;
    }
  }
  return 0;
}

uint64_t __FSTArcsSortedByInputOutputTarget(uint64_t a1, unsigned int a2)
{
  if (a2 == 1) {
    return 1;
  }
  uint64_t v2 = (_DWORD *)(a1 + 16);
  uint64_t v3 = 16 * a2 - 16;
  while (1)
  {
    int v4 = *(v2 - 3);
    int v5 = v2[1];
    if (v4 > v5) {
      break;
    }
    if (v4 >= v5)
    {
      int v6 = *(v2 - 2);
      int v7 = v2[2];
      if (v6 > v7 || v6 >= v7 && *(v2 - 4) > *v2) {
        break;
      }
    }
    v2 += 4;
    v3 -= 16;
    if (!v3) {
      return 1;
    }
  }
  return 0;
}

uint64_t __FSTArcsSortedByInputOutputWeightTarget(uint64_t a1, unsigned int a2)
{
  if (a2 == 1) {
    return 1;
  }
  uint64_t v2 = (_DWORD *)(a1 + 16);
  uint64_t v3 = 16 * a2 - 16;
  while (1)
  {
    int v4 = *(v2 - 3);
    int v5 = v2[1];
    if (v4 > v5) {
      break;
    }
    if (v4 >= v5)
    {
      int v6 = *(v2 - 2);
      int v7 = v2[2];
      if (v6 > v7) {
        break;
      }
      if (v6 >= v7)
      {
        int v8 = *(v2 - 1);
        int v9 = v2[3];
        if (v8 > v9 || v8 >= v9 && *(v2 - 4) > *v2) {
          break;
        }
      }
    }
    v2 += 4;
    v3 -= 16;
    if (!v3) {
      return 1;
    }
  }
  return 0;
}

uint64_t __FSTArcsSortedByInputTarget(uint64_t a1, unsigned int a2)
{
  if (a2 == 1) {
    return 1;
  }
  uint64_t v2 = a1 + 20;
  uint64_t v3 = 16 * a2 - 16;
  while (*(void *)(v2 - 20) <= *(void *)(v2 - 4))
  {
    v2 += 16;
    v3 -= 16;
    if (!v3) {
      return 1;
    }
  }
  return 0;
}

uint64_t __FSTArcsSortedByInputWeightOutputTarget(uint64_t a1, unsigned int a2)
{
  if (a2 == 1) {
    return 1;
  }
  uint64_t v2 = (_DWORD *)(a1 + 16);
  uint64_t v3 = 16 * a2 - 16;
  while (1)
  {
    int v4 = *(v2 - 3);
    int v5 = v2[1];
    if (v4 > v5) {
      break;
    }
    if (v4 >= v5)
    {
      int v6 = *(v2 - 1);
      int v7 = v2[3];
      if (v6 > v7) {
        break;
      }
      if (v6 >= v7)
      {
        int v8 = *(v2 - 2);
        int v9 = v2[2];
        if (v8 > v9 || v8 >= v9 && *(v2 - 4) > *v2) {
          break;
        }
      }
    }
    v2 += 4;
    v3 -= 16;
    if (!v3) {
      return 1;
    }
  }
  return 0;
}

uint64_t FSTMinimizeDfsContext_Con(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  int v6 = a3[9];
  uint64_t result = FSTDfsContext_Con(a1, a2, (uint64_t)a3);
  if (!result)
  {
    int v19 = 0;
    *(void *)a1 = &__FSTMinimizeDfsContext;
    *(_DWORD *)(a1 + 56) = 1;
    int v8 = v6 == 2 ? 32 : 128;
    *(_DWORD *)(a1 + 48) = 1;
    *(_DWORD *)(a1 + 120) = 0;
    *(void *)(a1 + 72) = a2;
    uint64_t result = FST_QueryProperties((uint64_t)a3, v8, &v19);
    if (!result)
    {
      if (v19)
      {
        *(void *)(a1 + 64) = a3;
        (*(void (**)(_DWORD *))(*(void *)a3 + 24))(a3);
      }
      else
      {
        int v18 = 0;
        if (a3[9] == 2) {
          int v17 = 273;
        }
        else {
          int v17 = 33;
        }
        uint64_t result = PNEW_FSTSort_Con(a2, a2, (uint64_t)a3, v17, &v18);
        if (result) {
          return result;
        }
        *(void *)(a1 + 64) = v18;
      }
      int v18 = 0;
      *(void *)(a1 + 88) = 0;
      int v9 = (uint64_t *)(a1 + 88);
      *(void *)(a1 + 80) = 0;
      uint64_t result = dpmemblock_Create(a2, 4, 0x400u, (uint64_t *)(a1 + 88));
      if (!result)
      {
        int v10 = -12;
        do
        {
          uint64_t result = dpmemblock_GetNewElement(*v9, &v18, 0);
          if (!v10) {
            break;
          }
          ++v10;
        }
        while (!result);
        if (!result)
        {
          uint64_t v11 = *v9;
          if (*(_DWORD *)(*v9 + 32))
          {
            unsigned int v12 = 0;
            uint64_t v13 = *(void *)(v11 + 8);
            __int16 v14 = *(_WORD *)(v11 + 44);
            do
            {
              uint64_t v15 = *(void *)(v13 + 8 * (v12 >> v14));
              if (!v15) {
                break;
              }
              *(_DWORD *)(v15 + 4 * (v12++ & ~(-1 << v14))) = -1;
            }
            while (v12 < *(_DWORD *)(v11 + 32));
          }
          *(void *)(a1 + 96) = 0;
          uint64_t result = dpmemblock_Create(a2, 12, 0x400u, (uint64_t *)(a1 + 96));
          if (!result)
          {
            *(void *)(a1 + 112) = 0;
            uint64_t v16 = (uint64_t *)(a1 + 112);
            *((_DWORD *)v16 - 2) = -1;
            return dpmemblock_Create(a2, 4, 0x400u, v16);
          }
        }
      }
    }
  }
  return result;
}

uint64_t FSTMinimizeDfsContext_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2)
  {
    if (*(void *)(v2 + 8))
    {
      OOCAllocator_Free(*(void *)(a1 + 72), *(void *)(v2 + 8));
      uint64_t v2 = *(void *)(a1 + 80);
    }
    OOCAllocator_Free(*(void *)(a1 + 72), v2);
  }

  return FSTDfsContext_Des(a1);
}

uint64_t FSTMinimizeDfsContext_DiscoverState()
{
  return 0;
}

uint64_t FSTMinimizeDfsContext_ExploreNonTreeArc(uint64_t a1, int a2, unsigned int *a3)
{
  uint64_t v3 = *a3;
  if (v3 != a2 && *(unsigned char *)(*(void *)(a1 + 24) + v3) == 1) {
    *(_DWORD *)(a1 + 120) = 1;
  }
  return 0;
}

uint64_t FSTMinimizeDfsContext_FinalizeMinimizationForAcyclicFst(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v2 = *(void *)(a1 + 32);
  unsigned int v56 = 0;
  uint64_t v57 = 0;
  dpmemblock_Free(*(uint64_t **)(a1 + 88));
  dpmemblock_Free(*(uint64_t **)(a1 + 96));
  *(_DWORD *)(a1 + 104) = -1;
  uint64_t v54 = 0;
  unsigned int v55 = 0;
  uint64_t result = dpmemblock_Create(*(void *)(a1 + 72), 4, 0x400u, (uint64_t *)&v55);
  if (!result)
  {
    unsigned int v5 = v2 - v3;
    int v6 = -12;
    do
    {
      uint64_t result = dpmemblock_GetNewElement((uint64_t)v55, &v54, 0);
      if (!v6) {
        break;
      }
      ++v6;
    }
    while (!result);
    if (!result)
    {
      int v7 = v55;
      if (*((_DWORD *)v55 + 8))
      {
        unsigned int v8 = 0;
        uint64_t v9 = v55[1];
        __int16 v10 = *((_WORD *)v55 + 22);
        do
        {
          uint64_t v11 = *(void *)(v9 + 8 * (v8 >> v10));
          if (!v11) {
            break;
          }
          *(_DWORD *)(v11 + 4 * (v8++ & ~(-1 << v10))) = -1;
        }
        while (v8 < *((_DWORD *)v7 + 8));
      }
      unsigned int v56 = 0;
      uint64_t result = dpmemblock_Create(*(void *)(a1 + 72), 8, 0x400u, (uint64_t *)&v56);
      unsigned int v58 = result;
      if (!result)
      {
        LODWORD(v57) = -1;
        unsigned int v12 = (_DWORD *)OOCAllocator_Malloc(*(void *)(a1 + 72), 24, &v58);
        *(void *)(a1 + 80) = v12;
        uint64_t result = v58;
        if (!v58)
        {
          _DWORD *v12 = v5;
          uint64_t v13 = OOCAllocator_Malloc(*(void *)(a1 + 72), 4 * v5, &v58);
          __int16 v14 = *(unsigned int **)(a1 + 80);
          *((void *)v14 + 1) = v13;
          uint64_t result = v58;
          if (!v58)
          {
            *((void *)v14 + 2) = v13 + 4 * *v14;
            if (v5)
            {
              for (uint64_t i = 0; i != v5; ++i)
                *(_DWORD *)(v13 + 4 * i) = i;
            }
            uint64_t v16 = *(void *)(a1 + 112);
            if (*(_DWORD *)(v16 + 32))
            {
              unsigned int v17 = 0;
              while (1)
              {
                uint64_t v18 = *(void *)(v16 + 8);
                __int16 v19 = *(_WORD *)(v16 + 44);
                uint64_t v20 = *(void *)(v18 + 8 * (v17 >> v19));
                if (!v20) {
                  goto LABEL_53;
                }
                uint64_t v21 = v17 & ~(-1 << v19);
                uint64_t v54 = 0;
                HIDWORD(v54) = *(_DWORD *)(v20 + 4 * v21);
                unsigned int v22 = __DistinctState_Hash(*(_DWORD **)(a1 + 64), *(void *)(a1 + 80), (uint64_t)&v54, (int *)&v58);
                uint64_t result = v58;
                if (v58) {
                  return result;
                }
                unsigned int v23 = *(_DWORD *)(*(void *)(v55[1] + 8 * ((v22 % *((_DWORD *)v55 + 8)) >> *((_WORD *)v55 + 22)))
                                + 4 * ((v22 % *((_DWORD *)v55 + 8)) & ~(-1 << *((_WORD *)v55 + 22))));
                if ((v23 & 0x80000000) != 0) {
                  break;
                }
                uint64_t v24 = v56[1];
                __int16 v25 = *((_WORD *)v56 + 22);
                while (1)
                {
                  int v26 = __DistinctState_Equal(*(void *)(a1 + 64), *(void *)(a1 + 80), (uint64_t)&v54, *(void *)(v24 + 8 * (v23 >> v25)) + 8 * (v23 & ~(-1 << v25)), (int *)&v58);
                  uint64_t result = v58;
                  if (v26) {
                    break;
                  }
                  if (v58) {
                    return result;
                  }
                  uint64_t v24 = v56[1];
                  __int16 v25 = *((_WORD *)v56 + 22);
                  unsigned int v23 = *(_DWORD *)(*(void *)(v24 + 8 * (v23 >> v25)) + 8 * (v23 & ~(-1 << v25)));
                  if ((v23 & 0x80000000) != 0) {
                    goto LABEL_25;
                  }
                }
                if (v58) {
                  return result;
                }
                *(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 8) + 4 * *(unsigned int *)(v20 + 4 * v21)) = *(_DWORD *)(*(void *)(v56[1] + 8 * (v23 >> *((_WORD *)v56 + 22))) + 8 * (v23 & ~(-1 << *((_WORD *)v56 + 22))) + 4);
LABEL_52:
                ++v17;
                uint64_t v16 = *(void *)(a1 + 112);
                if (v17 >= *(_DWORD *)(v16 + 32)) {
                  goto LABEL_53;
                }
              }
LABEL_25:
              unsigned int v27 = v57;
              unsigned int v28 = v56;
              if (v57 != -1)
              {
                char v29 = *((_WORD *)v56 + 22);
                uint64_t v30 = *(void *)(v56[1] + 8 * (v57 >> v29));
                unsigned int v31 = v57 & ~(-1 << v29);
                LODWORD(v57) = (*(_DWORD *)(v30 + 8 * v31) & 0xBFFFFFFF) - 1;
                *(void *)(v30 + 8 * v31) = v54;
LABEL_51:
                unsigned int v49 = v22 % *((_DWORD *)v55 + 8);
                char v50 = *((_WORD *)v55 + 22);
                uint64_t v51 = *(void *)(v55[1] + 8 * (v49 >> v50));
                unsigned int v52 = v49 & ~(-1 << v50);
                *(_DWORD *)(*(void *)(v56[1] + 8 * (v27 >> *((_WORD *)v56 + 22)))
                          + 8 * (v27 & ~(-1 << *((_WORD *)v56 + 22)))) = *(_DWORD *)(v51 + 4 * v52);
                *(_DWORD *)(v51 + 4 * v52) = v27;
                goto LABEL_52;
              }
              unsigned int v27 = *((_DWORD *)v56 + 8);
              unsigned int v32 = v55;
              unsigned int v33 = *((_DWORD *)v55 + 8);
              if (v27 <= 2 * v33)
              {
LABEL_49:
                unint64_t v53 = 0;
                uint64_t result = dpmemblock_GetNewElement((uint64_t)v28, &v53, 0);
                unsigned int v58 = result;
                if (result) {
                  return result;
                }
                *unint64_t v53 = v54;
                goto LABEL_51;
              }
              unint64_t v53 = 0;
              unsigned int v34 = (2 * v33) | 1;
              if (v34 <= v33)
              {
                *((_DWORD *)v55 + 8) = v34;
              }
              else
              {
                unsigned int v35 = v33 + 1;
                do
                {
                  uint64_t result = dpmemblock_GetNewElement((uint64_t)v55, &v53, 0);
                  unsigned int v58 = result;
                  if (v35 >= v34) {
                    break;
                  }
                  ++v35;
                }
                while (!result);
                if (result) {
                  return result;
                }
                unsigned int v32 = v55;
                unsigned int v34 = *((_DWORD *)v55 + 8);
                if (!v34) {
                  goto LABEL_41;
                }
              }
              unsigned int v36 = 0;
              uint64_t v37 = v32[1];
              __int16 v38 = *((_WORD *)v32 + 22);
              do
              {
                uint64_t v39 = *(void *)(v37 + 8 * (v36 >> v38));
                if (!v39) {
                  break;
                }
                *(_DWORD *)(v39 + 4 * (v36++ & ~(-1 << v38))) = -1;
              }
              while (v36 < *((_DWORD *)v32 + 8));
LABEL_41:
              unsigned int v28 = v56;
              unsigned int v27 = *((_DWORD *)v56 + 8);
              if (v27)
              {
                unint64_t v40 = *(_DWORD **)v56[1];
                if (v40)
                {
                  unsigned int v41 = 1;
                  do
                  {
                    if (((*v40 + 1) & 0x40000000) == 0)
                    {
                      unsigned int v42 = __DistinctState_Hash(*(_DWORD **)(a1 + 64), *(void *)(a1 + 80), (uint64_t)v40, (int *)&v58);
                      uint64_t result = v58;
                      if (v58) {
                        return result;
                      }
                      unsigned int v43 = v42 % v34;
                      char v44 = *((_WORD *)v55 + 22);
                      uint64_t v45 = *(void *)(v55[1] + 8 * (v43 >> v44));
                      unsigned int v46 = v43 & ~(-1 << v44);
                      *unint64_t v40 = *(_DWORD *)(v45 + 4 * v46);
                      *(_DWORD *)(v45 + 4 * v46) = v41 - 1;
                      unsigned int v28 = v56;
                    }
                    unsigned int v27 = *((_DWORD *)v28 + 8);
                    if (v41 >= v27) {
                      break;
                    }
                    char v47 = *((_WORD *)v28 + 22);
                    uint64_t v48 = *(void *)(v28[1] + 8 * (v41 >> v47));
                    unint64_t v40 = (_DWORD *)(v48 + 8 * (v41++ & ~(-1 << v47)));
                  }
                  while (v48);
                }
              }
              goto LABEL_49;
            }
LABEL_53:
            dpmemblock_Free(v55);
            dpmemblock_Free(v56);
            LODWORD(v57) = -1;
            dpmemblock_Free(*(uint64_t **)(a1 + 112));
            return v58;
          }
        }
      }
    }
  }
  return result;
}

uint64_t __DistinctState_Hash(_DWORD *a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v20 = 0;
  int v7 = (*(uint64_t (**)(_DWORD *, void, uint64_t, uint64_t *))(*(void *)a1 + 120))(a1, *(unsigned int *)(a3 + 4), 8, &v20);
  if (v7) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = v20 == 0;
  }
  if (v8)
  {
    uint64_t v9 = 0;
    goto LABEL_23;
  }
  uint64_t v10 = *(unsigned int *)(v20 + 48);
  uint64_t v11 = *(void *)(v20 + 56) + 16 * v10;
  unsigned int v12 = *(unsigned int **)(v20 + 40);
  uint64_t v13 = *(unsigned int *)(v20 + 32);
  if (v12 == (unsigned int *)v11)
  {
    int v14 = 0;
  }
  else
  {
    int v14 = 0;
    uint64_t v15 = &v12[4 * v13];
    do
    {
      if (v12 == v15)
      {
        unsigned int v12 = *(unsigned int **)(v20 + 56);
        if (!v10) {
          break;
        }
      }
      int v16 = v12[1] + 100003 * (*(_DWORD *)(*(void *)(a2 + 8) + 4 * *v12) + 100003 * v14);
      if (a1[9] == 2) {
        int v16 = v12[2] + 100003 * v16;
      }
      int v14 = v12[3] + 100003 * v16;
      v12 += 4;
    }
    while (v12 != (unsigned int *)v11);
  }
  uint64_t v9 = (v13 + v10 + 100003 * v14);
  int v17 = *(_DWORD *)(v20 + 8);
  if ((v17 & 0x3FFFFFF) == 1)
  {
    if ((v17 & 0x8000000) != 0) {
      uint64_t v18 = *(void *)(v20 + 16);
    }
    else {
      uint64_t v18 = 0;
    }
    int v7 = FSTStatePool_PushFSTState(v18, v20);
LABEL_23:
    if (v7) {
      goto LABEL_24;
    }
    return v9;
  }
  *(_DWORD *)(v20 + 8) = v17 - 1;
  if ((v17 & 0x3FFFFFF) == 0)
  {
    int v7 = 9;
LABEL_24:
    *a4 = v7;
  }
  return v9;
}

uint64_t __DistinctState_Equal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5)
{
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  int v9 = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t *))(*(void *)a1 + 120))(a1, *(unsigned int *)(a3 + 4), 8, &v24);
  if (v9
    || (int v9 = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t *))(*(void *)a1 + 120))(a1, *(unsigned int *)(a4 + 4), 8, &v23)) != 0)
  {
    uint64_t v10 = 0;
LABEL_4:
    *a5 = v9;
    return v10;
  }
  uint64_t v10 = 0;
  if (v24)
  {
    uint64_t v12 = v23;
    if (v23)
    {
      int v13 = *(_DWORD *)(v24 + 8);
      if (((*(_DWORD *)(v23 + 8) ^ v13) & 0x80000000) == 0)
      {
        uint64_t v14 = *(unsigned int *)(v24 + 48);
        if (v14 == *(_DWORD *)(v23 + 48))
        {
          uint64_t v15 = *(unsigned int *)(v24 + 32);
          if (v15 == *(_DWORD *)(v23 + 32))
          {
            uint64_t v16 = *(void *)(v24 + 56) + 16 * v14;
            int v17 = *(unsigned int **)(v24 + 40);
            if (v17 == (unsigned int *)v16)
            {
LABEL_39:
              uint64_t v10 = 1;
LABEL_23:
              if ((v13 & 0x3FFFFFF) == 1)
              {
                if ((v13 & 0x8000000) != 0) {
                  uint64_t v20 = *(void *)(v24 + 16);
                }
                else {
                  uint64_t v20 = 0;
                }
                int v9 = FSTStatePool_PushFSTState(v20, v24);
                if (v9) {
                  goto LABEL_4;
                }
                uint64_t v12 = v23;
              }
              else
              {
                *(_DWORD *)(v24 + 8) = v13 - 1;
                if ((v13 & 0x3FFFFFF) == 0) {
                  goto LABEL_35;
                }
              }
              int v21 = *(_DWORD *)(v12 + 8);
              if ((v21 & 0x3FFFFFF) == 1)
              {
                if ((v21 & 0x8000000) != 0) {
                  uint64_t v22 = *(void *)(v12 + 16);
                }
                else {
                  uint64_t v22 = 0;
                }
                int v9 = FSTStatePool_PushFSTState(v22, v12);
                if (v9) {
                  goto LABEL_4;
                }
                return v10;
              }
              *(_DWORD *)(v12 + 8) = v21 - 1;
              if ((v21 & 0x3FFFFFF) != 0) {
                return v10;
              }
LABEL_35:
              int v9 = 9;
              goto LABEL_4;
            }
            uint64_t v18 = &v17[4 * v15];
            __int16 v19 = *(unsigned int **)(v23 + 40);
            uint64_t v10 = 1;
            while (1)
            {
              if (v17 == v18)
              {
                if (!v14) {
                  goto LABEL_39;
                }
                __int16 v19 = *(unsigned int **)(v23 + 56);
                int v17 = *(unsigned int **)(v24 + 56);
              }
              if (*(_DWORD *)(*(void *)(a2 + 8) + 4 * *v17) != *(_DWORD *)(*(void *)(a2 + 8) + 4 * *v19)
                || v17[1] != v19[1]
                || v17[2] != v19[2]
                || v17[3] != v19[3])
              {
                break;
              }
              v17 += 4;
              v19 += 4;
              if (v17 == (unsigned int *)v16) {
                goto LABEL_23;
              }
            }
          }
        }
      }
      uint64_t v10 = 0;
      goto LABEL_23;
    }
  }
  return v10;
}

uint64_t FSTMinimizeDfsContext_FinalizeMinimizationForCyclicFst(uint64_t a1)
{
  unsigned int v114 = 0;
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v2 = *(void *)(a1 + 32);
  int v4 = (_DWORD *)OOCAllocator_Malloc(*(void *)(a1 + 72), 24, &v114);
  *(void *)(a1 + 80) = v4;
  if (!v114)
  {
    unsigned int v5 = v2 - v3;
    *int v4 = v5;
    uint64_t v6 = OOCAllocator_Malloc(*(void *)(a1 + 72), 4 * v5, &v114);
    int v7 = *(unsigned int **)(a1 + 80);
    *((void *)v7 + 1) = v6;
    if (!v114)
    {
      *((void *)v7 + 2) = v6 + 4 * *v7;
      if (v5)
      {
        for (uint64_t i = 0; i != v5; ++i)
          *(_DWORD *)(v6 + 4 * i) = i;
      }
      uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 112) + 32);
      if (!v10)
      {
        dpmemblock_Free(*(uint64_t **)(a1 + 88));
        dpmemblock_Free(*(uint64_t **)(a1 + 96));
        *(_DWORD *)(a1 + 104) = -1;
        dpmemblock_Free(*(uint64_t **)(a1 + 112));
        return v114;
      }
      uint64_t v113 = 0;
      int v11 = *(_DWORD *)(*(void *)(a1 + 64) + 36);
      uint64_t v12 = OOCAllocator_Malloc(*(void *)(a1 + 72), 8 * v10, &v114);
      if (!v114)
      {
        uint64_t v106 = v10;
        uint64_t v107 = v12;
        uint64_t v13 = *(void *)(a1 + 112);
        if (*(_DWORD *)(v13 + 32))
        {
          unsigned int v14 = 0;
          uint64_t v15 = (_DWORD *)v12;
          do
          {
            uint64_t v16 = *(void *)(v13 + 8);
            __int16 v17 = *(_WORD *)(v13 + 44);
            uint64_t v18 = *(void *)(v16 + 8 * (v14 >> v17));
            if (!v18) {
              break;
            }
            uint64_t v19 = v14 & ~(-1 << v17);
            LODWORD(v111) = 0;
            unint64_t v110 = 0;
            unsigned int v114 = (*(uint64_t (**)(void, void, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), *(unsigned int *)(v18 + 4 * v19), 8, &v113);
            if (v114) {
              return v114;
            }
            uint64_t v20 = *(unsigned int *)(v113 + 48);
            uint64_t v21 = *(void *)(v113 + 56) + 16 * v20;
            uint64_t v22 = *(_DWORD **)(v113 + 40);
            uint64_t v23 = *(unsigned int *)(v113 + 32);
            if (v22 == (_DWORD *)v21)
            {
              int v24 = 0;
            }
            else
            {
              int v24 = 0;
              __int16 v25 = &v22[4 * v23];
              do
              {
                if (v22 == v25)
                {
                  uint64_t v22 = *(_DWORD **)(v113 + 56);
                  if (!v20) {
                    break;
                  }
                }
                int v26 = v22[1] + 100003 * v24;
                if (v11 == 2) {
                  int v26 = v22[2] + 100003 * v26;
                }
                int v24 = v22[3] + 100003 * v26;
                v22 += 4;
              }
              while (v22 != (_DWORD *)v21);
            }
            HIDWORD(v110) = *(_DWORD *)(v18 + 4 * v19);
            LODWORD(v111) = v23 + v20 + 100003 * v24;
            uint64_t v27 = *(void *)(a1 + 88);
            unsigned int v28 = *(_DWORD *)(*(void *)(*(void *)(v27 + 8)
                                        + 8 * ((v111 % *(_DWORD *)(v27 + 32)) >> *(_WORD *)(v27 + 44)))
                            + 4 * ((v111 % *(_DWORD *)(v27 + 32)) & ~(-1 << *(_WORD *)(v27 + 44))));
            if ((v28 & 0x80000000) == 0)
            {
              uint64_t v29 = *(void *)(a1 + 96);
              uint64_t v30 = *(void *)(v29 + 8);
              __int16 v31 = *(_WORD *)(v29 + 44);
              while (!__StateSignature_Equal(*(void *)(a1 + 64), (uint64_t)&v110, *(void *)(v30 + 8 * (v28 >> v31)) + 12 * (v28 & ~(-1 << v31)), (int *)&v114))
              {
                if (v114) {
                  return v114;
                }
                uint64_t v32 = *(void *)(a1 + 96);
                uint64_t v30 = *(void *)(v32 + 8);
                __int16 v31 = *(_WORD *)(v32 + 44);
                unsigned int v28 = *(_DWORD *)(*(void *)(v30 + 8 * (v28 >> v31)) + 12 * (v28 & ~(-1 << v31)));
                if ((v28 & 0x80000000) != 0) {
                  goto LABEL_29;
                }
              }
              if (v114) {
                return v114;
              }
            }
LABEL_29:
            uint64_t v33 = *(unsigned int *)(v18 + 4 * v19);
            *uint64_t v15 = v33;
            unsigned int v34 = *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 96) + 8)
                                        + 8 * (v28 >> *(_WORD *)(*(void *)(a1 + 96) + 44)))
                            + 12 * (v28 & ~(-1 << *(_WORD *)(*(void *)(a1 + 96) + 44)))
                            + 4) & 0xBFFFFFFF;
            v15[1] = v34;
            *(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 8) + 4 * v33) = v34;
            int v35 = *(_DWORD *)(v113 + 8);
            if ((v35 & 0x3FFFFFF) == 1)
            {
              if ((v35 & 0x8000000) != 0) {
                uint64_t v36 = *(void *)(v113 + 16);
              }
              else {
                uint64_t v36 = 0;
              }
              unsigned int v114 = FSTStatePool_PushFSTState(v36, v113);
              if (v114) {
                return v114;
              }
            }
            else
            {
              *(_DWORD *)(v113 + 8) = v35 - 1;
              if ((v35 & 0x3FFFFFF) == 0) {
                return 9;
              }
              unsigned int v114 = 0;
            }
            v15 += 2;
            ++v14;
            uint64_t v13 = *(void *)(a1 + 112);
          }
          while (v14 < *(_DWORD *)(v13 + 32));
        }
        unsigned int v38 = v106;
        uint64_t v37 = (unsigned int *)v107;
        unint64_t v39 = v107 + 8 * v106;
        dpmemblock_Free(*(uint64_t **)(a1 + 88));
        dpmemblock_Free(*(uint64_t **)(a1 + 96));
        *(_DWORD *)(a1 + 104) = -1;
        dpmemblock_Free(*(uint64_t **)(a1 + 112));
        lhstdlib_qsort(v107, v106, 8u, (uint64_t (*)(unsigned char *, unsigned char *))ClassEntryLess);
        uint64_t v40 = 0;
        int v41 = 0;
        int v42 = 0;
        int v43 = v106 - 1;
LABEL_38:
        char v44 = &v37[2 * v40];
        unsigned int v47 = v44[1];
        uint64_t v45 = v44 + 1;
        unsigned int v46 = v47;
        uint64_t v48 = (v40 + 1);
        if (v40 == v43 || v46 != v37[2 * v48 + 1])
        {
          *uint64_t v45 = v41++;
          goto LABEL_91;
        }
        unsigned int v105 = v46;
        uint64_t v101 = (uint64_t)&v37[2 * v40];
        int v102 = v42;
        uint64_t v111 = 0;
        uint64_t v112 = 0;
        uint64_t v109 = 0;
        unint64_t v110 = 0;
        unsigned int v114 = dpmemblock_Create(*(void *)(a1 + 72), 4, 0x400u, (uint64_t *)&v110);
        if (v114) {
          return v114;
        }
        int v49 = -12;
        do
        {
          unsigned int NewElement = dpmemblock_GetNewElement((uint64_t)v110, &v109, 0);
          unsigned int v114 = NewElement;
          if (!v49) {
            break;
          }
          ++v49;
        }
        while (!NewElement);
        if (NewElement) {
          return v114;
        }
        uint64_t v51 = v110;
        if (*((_DWORD *)v110 + 8))
        {
          unsigned int v52 = 0;
          uint64_t v53 = v110[1];
          __int16 v54 = *((_WORD *)v110 + 22);
          do
          {
            uint64_t v55 = *(void *)(v53 + 8 * (v52 >> v54));
            if (!v55) {
              break;
            }
            *(_DWORD *)(v55 + 4 * (v52++ & ~(-1 << v54))) = -1;
          }
          while (v52 < *((_DWORD *)v51 + 8));
        }
        uint64_t v111 = 0;
        unsigned int v114 = dpmemblock_Create(*(void *)(a1 + 72), 8, 0x400u, (uint64_t *)&v111);
        if (v114) {
          return v114;
        }
        LODWORD(v112) = -1;
        uint64_t v48 = v40;
        int v103 = v40;
        int v104 = v41;
        while (1)
        {
          unsigned int v56 = &v37[2 * v48];
          unsigned int v58 = v56[1];
          uint64_t v57 = v56 + 1;
          if (v58 != v105)
          {
LABEL_87:
            unsigned int v89 = *((_DWORD *)v111 + 8);
            int v43 = v106 - 1;
            int v42 = v102;
            if (v89 >= 2)
            {
              lhstdlib_qsort(v101, v48 - v40, 8u, (uint64_t (*)(unsigned char *, unsigned char *))ClassEntryLess);
              unsigned int v89 = *((_DWORD *)v111 + 8);
              int v42 = 1;
            }
            v41 += v89;
            dpmemblock_Free(v110);
            dpmemblock_Free(v111);
LABEL_91:
            int v90 = v42;
            uint64_t v40 = v48;
            if (v48 >= v38)
            {
              uint64_t v91 = *(void *)(*(void *)(a1 + 80) + 8);
              unint64_t v92 = v37;
              do
              {
                uint64_t v94 = *v92;
                unsigned int v93 = v92[1];
                v92 += 2;
                *(_DWORD *)(v91 + 4 * v94) = v93;
              }
              while ((unint64_t)v92 < v39);
              uint64_t v40 = 0;
              int v41 = 0;
              int v42 = 0;
              if (!v90)
              {
                unsigned int v95 = *v37;
                unsigned int v96 = v37[1];
                uint64_t v97 = *(void *)(*(void *)(a1 + 80) + 8);
                unint64_t v98 = v37;
                do
                {
                  uint64_t v100 = *v98;
                  unsigned int v99 = v98[1];
                  v98 += 2;
                  if (v99 != v96) {
                    unsigned int v95 = v100;
                  }
                  *(_DWORD *)(v97 + 4 * v100) = v95;
                  unsigned int v96 = v99;
                }
                while ((unint64_t)v98 < v39);
                OOCAllocator_Free(*(void *)(a1 + 72), (uint64_t)v37);
                return v114;
              }
            }
            goto LABEL_38;
          }
          uint64_t v109 = 0;
          HIDWORD(v109) = v37[2 * v48];
          unsigned int v59 = __DistinctState_Hash(*(_DWORD **)(a1 + 64), *(void *)(a1 + 80), (uint64_t)&v109, (int *)&v114);
          if (v114) {
            return v114;
          }
          unsigned int v60 = v59;
          unsigned int v61 = *(_DWORD *)(*(void *)(v110[1] + 8 * ((v59 % *((_DWORD *)v110 + 8)) >> *((_WORD *)v110 + 22)))
                          + 4 * ((v59 % *((_DWORD *)v110 + 8)) & ~(-1 << *((_WORD *)v110 + 22))));
          if ((v61 & 0x80000000) == 0)
          {
            uint64_t v62 = v111[1];
            __int16 v63 = *((_WORD *)v111 + 22);
            while (!__DistinctState_Equal(*(void *)(a1 + 64), *(void *)(a1 + 80), (uint64_t)&v109, *(void *)(v62 + 8 * (v61 >> v63)) + 8 * (v61 & ~(-1 << v63)), (int *)&v114))
            {
              if (v114) {
                return v114;
              }
              uint64_t v62 = v111[1];
              __int16 v63 = *((_WORD *)v111 + 22);
              unsigned int v61 = *(_DWORD *)(*(void *)(v62 + 8 * (v61 >> v63)) + 8 * (v61 & ~(-1 << v63)));
              if ((v61 & 0x80000000) != 0) {
                goto LABEL_58;
              }
            }
            if (v114) {
              return v114;
            }
            goto LABEL_85;
          }
LABEL_58:
          unsigned int v61 = v112;
          uint64_t v64 = v111;
          if (v112 == -1) {
            break;
          }
          char v65 = *((_WORD *)v111 + 22);
          uint64_t v66 = *(void *)(v111[1] + 8 * (v112 >> v65));
          unsigned int v67 = v112 & ~(-1 << v65);
          LODWORD(v112) = (*(_DWORD *)(v66 + 8 * v67) & 0xBFFFFFFF) - 1;
          *(void *)(v66 + 8 * v67) = v109;
LABEL_84:
          unsigned int v85 = v60 % *((_DWORD *)v110 + 8);
          char v86 = *((_WORD *)v110 + 22);
          uint64_t v87 = *(void *)(v110[1] + 8 * (v85 >> v86));
          unsigned int v88 = v85 & ~(-1 << v86);
          *(_DWORD *)(*(void *)(v111[1] + 8 * (v61 >> *((_WORD *)v111 + 22)))
                    + 8 * (v61 & ~(-1 << *((_WORD *)v111 + 22)))) = *(_DWORD *)(v87 + 4 * v88);
          *(_DWORD *)(v87 + 4 * v88) = v61;
LABEL_85:
          LODWORD(v40) = v103;
          int v41 = v104;
          *uint64_t v57 = v61 + v104;
          uint64_t v48 = (v48 + 1);
          unsigned int v38 = v106;
          uint64_t v37 = (unsigned int *)v107;
          if (v48 == v106)
          {
            uint64_t v48 = v106;
            goto LABEL_87;
          }
        }
        unsigned int v61 = *((_DWORD *)v111 + 8);
        uint64_t v68 = v110;
        unsigned int v69 = *((_DWORD *)v110 + 8);
        if (v61 <= 2 * v69)
        {
LABEL_82:
          uint64_t v108 = 0;
          unsigned int v114 = dpmemblock_GetNewElement((uint64_t)v64, &v108, 0);
          if (v114) {
            return v114;
          }
          *uint64_t v108 = v109;
          goto LABEL_84;
        }
        uint64_t v108 = 0;
        unsigned int v70 = (2 * v69) | 1;
        if (v70 <= v69)
        {
          *((_DWORD *)v110 + 8) = v70;
        }
        else
        {
          unsigned int v71 = v69 + 1;
          do
          {
            unsigned int v72 = dpmemblock_GetNewElement((uint64_t)v110, &v108, 0);
            unsigned int v114 = v72;
            if (v71 >= v70) {
              break;
            }
            ++v71;
          }
          while (!v72);
          if (v72) {
            return v114;
          }
          uint64_t v68 = v110;
          unsigned int v70 = *((_DWORD *)v110 + 8);
          if (!v70) {
            goto LABEL_74;
          }
        }
        unsigned int v73 = 0;
        uint64_t v74 = v68[1];
        __int16 v75 = *((_WORD *)v68 + 22);
        do
        {
          uint64_t v76 = *(void *)(v74 + 8 * (v73 >> v75));
          if (!v76) {
            break;
          }
          *(_DWORD *)(v76 + 4 * (v73++ & ~(-1 << v75))) = -1;
        }
        while (v73 < *((_DWORD *)v68 + 8));
LABEL_74:
        uint64_t v64 = v111;
        unsigned int v61 = *((_DWORD *)v111 + 8);
        if (v61)
        {
          int v77 = *(_DWORD **)v111[1];
          if (v77)
          {
            unsigned int v78 = 1;
            do
            {
              if (((*v77 + 1) & 0x40000000) == 0)
              {
                unsigned int v79 = __DistinctState_Hash(*(_DWORD **)(a1 + 64), *(void *)(a1 + 80), (uint64_t)v77, (int *)&v114);
                if (v114) {
                  return v114;
                }
                char v80 = *((_WORD *)v110 + 22);
                uint64_t v81 = *(void *)(v110[1] + 8 * ((v79 % v70) >> v80));
                unsigned int v82 = (v79 % v70) & ~(-1 << v80);
                *int v77 = *(_DWORD *)(v81 + 4 * v82);
                *(_DWORD *)(v81 + 4 * v82) = v78 - 1;
                uint64_t v64 = v111;
              }
              unsigned int v61 = *((_DWORD *)v64 + 8);
              if (v78 >= v61) {
                break;
              }
              char v83 = *((_WORD *)v64 + 22);
              uint64_t v84 = *(void *)(v64[1] + 8 * (v78 >> v83));
              int v77 = (_DWORD *)(v84 + 8 * (v78++ & ~(-1 << v83)));
            }
            while (v84);
          }
        }
        goto LABEL_82;
      }
    }
  }
  return v114;
}

uint64_t __StateSignature_Equal(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  if (*(_DWORD *)(a2 + 8) != *(_DWORD *)(a3 + 8)) {
    return 0;
  }
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  int v7 = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t *))(*(void *)a1 + 120))(a1, *(unsigned int *)(a2 + 4), 8, &v22);
  if (v7
    || (int v7 = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t *))(*(void *)a1 + 120))(a1, *(_DWORD *)(a3 + 4) & 0xBFFFFFFF, 8, &v21)) != 0)
  {
    uint64_t v8 = 0;
LABEL_5:
    *a4 = v7;
    return v8;
  }
  uint64_t v8 = 0;
  if (v22)
  {
    uint64_t v10 = v21;
    if (v21)
    {
      int v11 = *(_DWORD *)(v22 + 8);
      if (((*(_DWORD *)(v21 + 8) ^ v11) & 0x80000000) == 0)
      {
        uint64_t v12 = *(unsigned int *)(v22 + 48);
        if (v12 == *(_DWORD *)(v21 + 48))
        {
          uint64_t v13 = *(unsigned int *)(v22 + 32);
          if (v13 == *(_DWORD *)(v21 + 32))
          {
            uint64_t v14 = *(void *)(v22 + 56) + 16 * v12;
            uint64_t v15 = *(_DWORD **)(v22 + 40);
            if (v15 == (_DWORD *)v14)
            {
LABEL_40:
              uint64_t v8 = 1;
LABEL_24:
              if ((v11 & 0x3FFFFFF) == 1)
              {
                if ((v11 & 0x8000000) != 0) {
                  uint64_t v18 = *(void *)(v22 + 16);
                }
                else {
                  uint64_t v18 = 0;
                }
                int v7 = FSTStatePool_PushFSTState(v18, v22);
                if (v7) {
                  goto LABEL_5;
                }
                uint64_t v10 = v21;
              }
              else
              {
                *(_DWORD *)(v22 + 8) = v11 - 1;
                if ((v11 & 0x3FFFFFF) == 0) {
                  goto LABEL_36;
                }
              }
              int v19 = *(_DWORD *)(v10 + 8);
              if ((v19 & 0x3FFFFFF) == 1)
              {
                if ((v19 & 0x8000000) != 0) {
                  uint64_t v20 = *(void *)(v10 + 16);
                }
                else {
                  uint64_t v20 = 0;
                }
                int v7 = FSTStatePool_PushFSTState(v20, v10);
                if (v7) {
                  goto LABEL_5;
                }
                return v8;
              }
              *(_DWORD *)(v10 + 8) = v19 - 1;
              if ((v19 & 0x3FFFFFF) != 0) {
                return v8;
              }
LABEL_36:
              int v7 = 9;
              goto LABEL_5;
            }
            uint64_t v16 = &v15[4 * v13];
            __int16 v17 = *(_DWORD **)(v21 + 40);
            uint64_t v8 = 1;
            while (1)
            {
              if (v15 == v16)
              {
                if (!v12) {
                  goto LABEL_40;
                }
                __int16 v17 = *(_DWORD **)(v21 + 56);
                uint64_t v15 = *(_DWORD **)(v22 + 56);
              }
              if (v15[1] != v17[1] || v15[2] != v17[2] || v15[3] != v17[3]) {
                break;
              }
              v15 += 4;
              v17 += 4;
              if (v15 == (_DWORD *)v14) {
                goto LABEL_24;
              }
            }
          }
        }
      }
      uint64_t v8 = 0;
      goto LABEL_24;
    }
  }
  return v8;
}

uint64_t ClassEntryLess(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 4);
  unsigned int v3 = *(_DWORD *)(a2 + 4);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t FSTMinimizeDfsContext_FinishState(uint64_t a1, uint64_t a2)
{
  int v2 = a2;
  uint64_t v62 = 0;
  BOOL v4 = *(_DWORD **)(a1 + 64);
  int v5 = v4[9];
  uint64_t result = (*(uint64_t (**)(_DWORD *, uint64_t, uint64_t, uint64_t *))(*(void *)v4 + 120))(v4, a2, 8, &v62);
  unsigned int v63 = result;
  if (result) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = v62 == 0;
  }
  if (v7) {
    return result;
  }
  uint64_t v8 = *(_DWORD **)(v62 + 56);
  uint64_t v9 = *(unsigned int *)(v62 + 48);
  uint64_t v10 = &v8[4 * v9];
  int v11 = *(_DWORD **)(v62 + 40);
  uint64_t v12 = *(unsigned int *)(v62 + 32);
  unsigned int v61 = 0;
  uint64_t v60 = 0;
  if (v11 == v10)
  {
    int v13 = 0;
  }
  else
  {
    int v13 = 0;
    uint64_t v14 = &v11[4 * v12];
    do
    {
      if (v11 == v14)
      {
        int v11 = v8;
        if (!v9) {
          break;
        }
      }
      int v15 = v11[1] + 100003 * v13;
      if (v5 == 2) {
        int v15 = v11[2] + 100003 * v15;
      }
      int v13 = v11[3] + 100003 * v15;
      v11 += 4;
    }
    while (v11 != v10);
  }
  unsigned int v16 = v12 + v9 + 100003 * v13;
  uint64_t v17 = *(void *)(a1 + 88);
  uint64_t v18 = *(void *)(v17 + 8);
  unsigned int v19 = v16 % *(_DWORD *)(v17 + 32);
  LOBYTE(v17) = *(_WORD *)(v17 + 44);
  uint64_t v20 = *(void *)(v18 + 8 * (v19 >> v17));
  HIDWORD(v60) = v2;
  unsigned int v61 = v16;
  unsigned int v21 = *(_DWORD *)(v20 + 4 * (v19 & ~(-1 << v17)));
  if ((v21 & 0x80000000) != 0)
  {
LABEL_21:
    unsigned int v27 = *(_DWORD *)(a1 + 104);
    uint64_t v28 = *(void *)(a1 + 96);
    if (v27 != -1)
    {
      uint64_t v29 = (_DWORD *)(*(void *)(*(void *)(v28 + 8) + 8 * (v27 >> *(_WORD *)(v28 + 44)))
                     + 12 * (v27 & ~(-1 << *(_WORD *)(v28 + 44))));
      *(_DWORD *)(a1 + 104) = (*v29 & 0xBFFFFFFF) - 1;
      v29[2] = v61;
      *(void *)uint64_t v29 = v60;
LABEL_23:
      uint64_t v30 = *(void *)(a1 + 88);
      unsigned int v31 = v16 % *(_DWORD *)(v30 + 32);
      uint64_t v32 = *(void *)(v30 + 8);
      LOBYTE(v30) = *(_WORD *)(v30 + 44);
      uint64_t v33 = *(void *)(v32 + 8 * (v31 >> v30));
      LODWORD(v30) = v31 & ~(-1 << v30);
      *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 96) + 8)
                            + 8 * (v27 >> *(_WORD *)(*(void *)(a1 + 96) + 44)))
                + 12 * (v27 & ~(-1 << *(_WORD *)(*(void *)(a1 + 96) + 44)))) = *(_DWORD *)(v33
                                                                                               + 4 * v30);
      *(_DWORD *)(v33 + 4 * v30) = v27;
      goto LABEL_24;
    }
    unsigned int v27 = *(_DWORD *)(v28 + 32);
    uint64_t v36 = *(void *)(a1 + 88);
    unsigned int v37 = *(_DWORD *)(v36 + 32);
    if (v27 <= 2 * v37)
    {
LABEL_56:
      unsigned int v59 = 0;
      uint64_t result = dpmemblock_GetNewElement(v28, &v59, 0);
      if (result) {
        return result;
      }
      unsigned int v58 = v59;
      void *v59 = v60;
      *((_DWORD *)v58 + 2) = v61;
      goto LABEL_23;
    }
    unsigned int v59 = 0;
    unsigned int v38 = (2 * v37) | 1;
    if (v38 <= v37)
    {
      *(_DWORD *)(v36 + 32) = v38;
    }
    else
    {
      unsigned int v39 = v37 + 1;
      do
      {
        uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 88), &v59, 0);
        if (v39 >= v38) {
          break;
        }
        ++v39;
      }
      while (!result);
      if (result) {
        return result;
      }
      uint64_t v36 = *(void *)(a1 + 88);
      unsigned int v38 = *(_DWORD *)(v36 + 32);
      if (!v38) {
        goto LABEL_50;
      }
    }
    unsigned int v44 = 0;
    uint64_t v45 = *(void *)(v36 + 8);
    __int16 v46 = *(_WORD *)(v36 + 44);
    do
    {
      uint64_t v47 = *(void *)(v45 + 8 * (v44 >> v46));
      if (!v47) {
        break;
      }
      *(_DWORD *)(v47 + 4 * (v44++ & ~(-1 << v46))) = -1;
    }
    while (v44 < *(_DWORD *)(v36 + 32));
LABEL_50:
    uint64_t v28 = *(void *)(a1 + 96);
    unsigned int v27 = *(_DWORD *)(v28 + 32);
    if (v27)
    {
      unsigned int v48 = 0;
      uint64_t v49 = *(void *)(v28 + 8);
      __int16 v50 = *(_WORD *)(v28 + 44);
      int v51 = ~(-1 << v50);
      do
      {
        uint64_t v52 = *(void *)(v49 + 8 * (v48 >> v50));
        if (!v52) {
          break;
        }
        uint64_t v53 = (_DWORD *)(v52 + 12 * (v48 & v51));
        if (((*v53 + 1) & 0x40000000) == 0)
        {
          unsigned int v54 = *(_DWORD *)(v52 + 12 * (v48 & v51) + 8) % v38;
          char v55 = *(_WORD *)(v36 + 44);
          uint64_t v56 = *(void *)(*(void *)(v36 + 8) + 8 * (v54 >> v55));
          unsigned int v57 = v54 & ~(-1 << v55);
          *uint64_t v53 = *(_DWORD *)(v56 + 4 * v57);
          *(_DWORD *)(v56 + 4 * v57) = v48;
          unsigned int v27 = *(_DWORD *)(v28 + 32);
        }
        ++v48;
      }
      while (v48 < v27);
    }
    goto LABEL_56;
  }
  uint64_t v22 = *(void *)(a1 + 96);
  uint64_t v23 = *(void *)(v22 + 8);
  __int16 v24 = *(_WORD *)(v22 + 44);
  while (1)
  {
    int v25 = __StateSignature_Equal(*(void *)(a1 + 64), (uint64_t)&v60, *(void *)(v23 + 8 * (v21 >> v24)) + 12 * (v21 & ~(-1 << v24)), (int *)&v63);
    uint64_t result = v63;
    if (v25) {
      break;
    }
    if (v63) {
      return result;
    }
    uint64_t v26 = *(void *)(a1 + 96);
    uint64_t v23 = *(void *)(v26 + 8);
    __int16 v24 = *(_WORD *)(v26 + 44);
    unsigned int v21 = *(_DWORD *)(*(void *)(v23 + 8 * (v21 >> v24)) + 12 * (v21 & ~(-1 << v24)));
    if ((v21 & 0x80000000) != 0) {
      goto LABEL_21;
    }
  }
  if (!v63)
  {
    if ((*(unsigned char *)(*(void *)(*(void *)(*(void *)(a1 + 96) + 8)
                               + 8 * (v21 >> *(_WORD *)(*(void *)(a1 + 96) + 44)))
                   + 12 * (v21 & ~(-1 << *(_WORD *)(*(void *)(a1 + 96) + 44)))
                   + 7) & 0x40) == 0)
    {
      unsigned int v59 = 0;
      uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 112), &v59, 0);
      if (result) {
        return result;
      }
      uint64_t v40 = *(void *)(a1 + 96);
      uint64_t v41 = *(void *)(v40 + 8);
      LOBYTE(v40) = *(_WORD *)(v40 + 44);
      unsigned int v42 = v21 >> v40;
      LODWORD(v40) = v21 & ~(-1 << v40);
      *(_DWORD *)unsigned int v59 = *(_DWORD *)(*(void *)(v41 + 8 * v42) + 12 * v40 + 4);
      uint64_t v43 = *(void *)(v41 + 8 * v42) + 12 * v40;
      *(_DWORD *)(v43 + 4) |= 0x40000000u;
    }
    unsigned int v59 = 0;
    uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 112), &v59, 0);
    if (!result)
    {
      *(_DWORD *)unsigned int v59 = v2;
LABEL_24:
      int v34 = *(_DWORD *)(v62 + 8);
      if ((v34 & 0x3FFFFFF) == 1)
      {
        if ((v34 & 0x8000000) != 0) {
          uint64_t v35 = *(void *)(v62 + 16);
        }
        else {
          uint64_t v35 = 0;
        }
        return FSTStatePool_PushFSTState(v35, v62);
      }
      else
      {
        *(_DWORD *)(v62 + 8) = v34 - 1;
        if ((v34 & 0x3FFFFFF) != 0) {
          return 0;
        }
        else {
          return 9;
        }
      }
    }
  }
  return result;
}

int8x8_t FSTMinimizeDfsContext_GetMinimizedFst(uint64_t *a1, int8x8_t **a2)
{
  uint64_t v8 = 0;
  if (!PNEW_FSTMapStates_Con(a1[9], a1[9], a1[8], a1[10], (uint64_t *)&v8))
  {
    a1[10] = 0;
    if (!(*(unsigned int (**)(uint64_t))(*(void *)a1[8] + 32))(a1[8]))
    {
      int v5 = v8;
      int8x8_t result = vorr_s8(v8[5], (int8x8_t)0x110000001000);
      v8[5] = vand_s8(result, (int8x8_t)0xFFFDFB00FFFDFA00);
      uint64_t v6 = a1[8];
      int v7 = *(_DWORD *)(v6 + 40);
      LODWORD(v6) = *(_DWORD *)(v6 + 44) & 0x16A00;
      v5[5].i32[0] = v6 & v7 | result.i32[0] & 0xFFFC9000;
      v5[5].i32[1] = v6 | result.i32[1] & 0xFFFC9100;
      *a2 = v5;
    }
  }
  return result;
}

uint64_t PNEW_FSTMinimizeDfsContext_Con(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 128, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = FSTMinimizeDfsContext_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

void *GetFSTMinimizeDfsContextClass()
{
  return &__FSTMinimizeDfsContext;
}

void FSTCompactRndBuilder_Con(void *a1, uint64_t a2)
{
  if (!FSTBufferBuilder_Con(a1, a2))
  {
    *a1 = &__FSTCompactRndBuilder;
    a1[9] = &unk_26D217608;
    __FSTCompactRndBuilder_Init((uint64_t)a1);
  }
}

void __FSTCompactRndBuilder_Init(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  long long v4 = 0u;
  long long v5 = 0u;
  memset(v3, 0, sizeof(v3));
  FST_Con(v3, *(void *)(a1 + 8), 0);
  if (!v2)
  {
    *(void *)(a1 + 96) = 0;
    *(_OWORD *)(a1 + 80) = xmmword_22078B3A0;
    *(void *)(a1 + 104) = 0xFFFFFFFF00000000;
    *(void *)(a1 + 64) = *(void *)&vand_s8(*(int8x8_t *)(a1 + 64), (int8x8_t)0x300000003) | 0x10000000100;
    if (!dpmemblock_Create(*(void *)(a1 + 8), 8, 0x400u, (uint64_t *)(a1 + 96)))
    {
      *(void *)&long long v4 = 0x20000002BLL;
      *((void *)&v4 + 1) |= 0x10000000100uLL;
      if (!__FSTCompactRndBuilder_WriteFstBaseHeader((uint64_t *)a1, v3, &v6))
      {
        int v7 = -1;
        uint64_t v9 = 0;
        uint64_t v8 = 0;
        int v10 = v6 + 24;
        if (*(uint64_t *)(a1 + 48) < 0x7FFFFFFFFFFFFFE8)
        {
          if ((**(uint64_t (***)(int *, uint64_t, uint64_t, void))(a1 + 16))(&v7, 24, 1, *(void *)(a1 + 24)) != 1)err_GenerateErrorCallback(); {
          *(void *)(a1 + 48) += 24;
          }
        }
        else
        {
          err_GenerateErrorCallback();
        }
        FST_Des((uint64_t)v3);
      }
    }
  }
}

void FSTCompactRndBuilder_ConToStream(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!FSTBufferBuilder_ConToStream(a1, a2, a3, a4, a5))
  {
    *a1 = &__FSTCompactRndBuilder;
    a1[9] = &unk_26D217608;
    __FSTCompactRndBuilder_Init((uint64_t)a1);
  }
}

uint64_t FSTCompactRndBuilder_Des(uint64_t a1)
{
  dpmemblock_Free(*(uint64_t **)(a1 + 96));

  return FSTBufferBuilder_Des((uint64_t *)a1);
}

uint64_t FSTCompactRndBuilder_AddArc(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v9[0] = 0;
  v9[1] = 0;
  uint64_t v8 = 17;
  uint64_t result = FSTArc_Con(v9, a6, a3, a4, a5);
  if (!result)
  {
    FSTCompactCodec_EncodeArc((unsigned int *)v9, (uint64_t)v10, &v8);
    if (*(void *)(a1 + 48) <= (v8 ^ 0x7FFFFFFFFFFFFFFFLL))
    {
      if ((**(uint64_t (***)(unsigned char *))(a1 + 16))(v10) == 1) {
        uint64_t result = 0;
      }
      else {
        uint64_t result = err_GenerateErrorCallback();
      }
      *(void *)(a1 + 48) += v8;
    }
    else
    {
      return err_GenerateErrorCallback();
    }
  }
  return result;
}

uint64_t FSTCompactRndBuilder_ConvertFST(uint64_t a1, _DWORD *a2)
{
  v29[3] = *MEMORY[0x263EF8340];
  memset(v28, 0, sizeof(v28));
  uint64_t result = FSTCount(*(void *)(a1 + 8), (uint64_t)a2, (uint64_t)v28);
  if (result) {
    return result;
  }
  int v5 = v28[0];
  v29[0] = 0;
  unsigned int v6 = LODWORD(v28[0]) + 2;
  uint64_t v7 = *(void *)(a1 + 96);
  unsigned int v8 = *(_DWORD *)(v7 + 32);
  if (LODWORD(v28[0]) + 2 <= v8)
  {
    *(_DWORD *)(v7 + 32) = v6;
    if (!v6) {
      goto LABEL_13;
    }
    goto LABEL_10;
  }
  unsigned int v9 = v8 + 1;
  do
  {
    uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 96), v29, 0);
    if (v9 >= v6) {
      break;
    }
    ++v9;
  }
  while (!result);
  if (result) {
    return result;
  }
  uint64_t v7 = *(void *)(a1 + 96);
  if (*(_DWORD *)(v7 + 32))
  {
LABEL_10:
    unsigned int v10 = 0;
    uint64_t v11 = *(void *)(v7 + 8);
    __int16 v12 = *(_WORD *)(v7 + 44);
    do
    {
      uint64_t v13 = *(void *)(v11 + 8 * (v10 >> v12));
      if (!v13) {
        break;
      }
      *(void *)(v13 + 8 * (v10++ & ~(-1 << v12))) = 0xFFFFFFFFLL;
    }
    while (v10 < *(_DWORD *)(v7 + 32));
  }
LABEL_13:
  uint64_t result = (*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)a2 + 48))(a2, a1 + 108);
  if (!result)
  {
    v14.i32[0] = a2[11] & 0x3FFFF & a2[10];
    v14.i32[1] = a2[11] & 0x3FFFF;
    *(void *)(a1 + 64) = *(void *)&vorr_s8(vand_s8(*(int8x8_t *)(a1 + 64), (int8x8_t)0x300000003), v14) | 0x10000000100;
    if (v5 == -1)
    {
      return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 16))(a1 + 72 - *(void *)(*(void *)(a1 + 72) + 24));
    }
    else
    {
      uint64_t v15 = 0;
      uint64_t v16 = a1 + 72;
      while (1)
      {
        uint64_t v27 = 0;
        uint64_t result = (*(uint64_t (**)(_DWORD *, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 120))(a2, v15, 8, &v27);
        if (result) {
          break;
        }
        if (v27)
        {
          int v17 = *(_DWORD *)(v27 + 8);
          if (v17 < 0) {
            uint64_t v18 = *(unsigned int *)(v27 + 28);
          }
          else {
            uint64_t v18 = 0;
          }
          uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t, void))v16)(v16 - *(void *)(*(void *)v16 + 24), v15, v17 & 0xF0000000, v18, 0);
          if (result) {
            return result;
          }
          uint64_t v19 = v27;
          uint64_t v20 = *(unsigned int **)(v27 + 40);
          uint64_t v21 = *(void *)(v27 + 56) + 16 * *(unsigned int *)(v27 + 48);
          if (v20 != (unsigned int *)v21)
          {
            uint64_t v22 = &v20[4 * *(unsigned int *)(v27 + 32)];
            while (1)
            {
              uint64_t v26 = 17;
              if (v20 == v22)
              {
                uint64_t v19 = v27;
                if (!*(_DWORD *)(v27 + 48)) {
                  break;
                }
                uint64_t v20 = *(unsigned int **)(v27 + 56);
              }
              FSTCompactCodec_EncodeArc(v20, (uint64_t)v29, &v26);
              if (*(void *)(a1 + 48) <= (v26 ^ 0x7FFFFFFFFFFFFFFFLL))
              {
                uint64_t result = (**(uint64_t (***)(void *))(a1 + 16))(v29) == 1 ? 0 : err_GenerateErrorCallback();
                *(void *)(a1 + 48) += v26;
              }
              else
              {
                uint64_t result = err_GenerateErrorCallback();
              }
              if (result) {
                return result;
              }
              v20 += 4;
              if (v20 == (unsigned int *)v21)
              {
                uint64_t v19 = v27;
                break;
              }
            }
          }
          int v23 = *(_DWORD *)(v19 + 8);
          if ((v23 & 0x3FFFFFF) == 1)
          {
            if ((v23 & 0x8000000) != 0) {
              uint64_t v24 = *(void *)(v19 + 16);
            }
            else {
              uint64_t v24 = 0;
            }
            uint64_t result = FSTStatePool_PushFSTState(v24, v19);
            if (result) {
              return result;
            }
          }
          else
          {
            *(_DWORD *)(v19 + 8) = v23 - 1;
            if ((v23 & 0x3FFFFFF) == 0) {
              return 9;
            }
          }
        }
        else
        {
          uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, void, void))v16)(v16 - *(void *)(*(void *)v16 + 24), v15, 0, 0, 0);
          if (result) {
            return result;
          }
        }
        BOOL v25 = v15 == v5;
        uint64_t v15 = (v15 + 1);
        if (v25) {
          return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 16))(a1 + 72 - *(void *)(*(void *)(a1 + 72) + 24));
        }
      }
    }
  }
  return result;
}

void FSTCompactRndBuilder_Finalize(uint64_t a1)
{
  uint64_t v49 = *MEMORY[0x263EF8340];
  long long v42 = 0u;
  long long v43 = 0u;
  memset(v41, 0, sizeof(v41));
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v44 = 0;
  uint64_t v45 = v2;
  FST_Con(v41, *(void *)(a1 + 8), 0);
  if (!v3
    && !FST_GetHeaderSizeInOutputBuffer(&v44)
    && (*(_DWORD *)(a1 + 84) == -1 || !__FSTCompactRndBuilder_CloseState(a1, (int)v2 - (int)v44 - 24))
    && *(_DWORD *)(a1 + 80))
  {
    if (*(_DWORD *)(a1 + 104))
    {
      unsigned int v4 = 0;
      while (1)
      {
        int v5 = (int *)(*(void *)(*(void *)(*(void *)(a1 + 96) + 8)
                               + 8 * (v4 >> *(_WORD *)(*(void *)(a1 + 96) + 44)))
                   + 8 * (v4 & ~(-1 << *(_WORD *)(*(void *)(a1 + 96) + 44))));
        int v6 = *v5;
        LODWORD(v5) = v5[1];
        v48[0] = BYTE3(v5);
        v48[1] = BYTE2(v5);
        v48[2] = BYTE1(v5);
        v48[3] = (_BYTE)v5;
        v48[4] = HIBYTE(v6);
        v48[5] = BYTE2(v6);
        v48[6] = BYTE1(v6);
        v48[7] = v6;
        if (*(uint64_t *)(a1 + 48) < 0x7FFFFFFFFFFFFFF8)
        {
          int ErrorCallback = (**(uint64_t (***)(unsigned char *, uint64_t, uint64_t, void))(a1 + 16))(v48, 8, 1, *(void *)(a1 + 24)) == 1? 0: err_GenerateErrorCallback();
          *(void *)(a1 + 48) += 8;
        }
        else
        {
          int ErrorCallback = err_GenerateErrorCallback();
        }
        if (ErrorCallback) {
          break;
        }
        if (++v4 >= *(_DWORD *)(a1 + 104)) {
          goto LABEL_17;
        }
      }
    }
    else
    {
LABEL_17:
      dpmemblock_Reset(*(void *)(a1 + 96));
      uint64_t v8 = *(void *)(a1 + 48);
      v9.i32[0] = *(_DWORD *)(a1 + 68) & 0x3FFFF & *(_DWORD *)(a1 + 64);
      v9.i32[1] = *(_DWORD *)(a1 + 68) & 0x3FFFF;
      *(void *)&long long v42 = 0x20000002BLL;
      *((int8x8_t *)&v42 + 1) = vorr_s8(v9, vand_s8(*(int8x8_t *)((char *)&v42 + 8), (int8x8_t)0x300000003));
      if (!__FSTCompactRndBuilder_WriteFstBaseHeader((uint64_t *)a1, v41, &v44)
        && !FST_Des((uint64_t)v41))
      {
        int v47 = *(_DWORD *)(a1 + 108);
        uint64_t v10 = v44;
        if (v44 >= 2000000000) {
          uint64_t v11 = 2000000000;
        }
        else {
          uint64_t v11 = v44;
        }
        int v12 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v11, 0);
        if (v12) {
          int v12 = err_GenerateErrorCallback();
        }
        *(void *)(a1 + 48) = v11;
        BOOL v13 = v12 == 0;
        if (!v12)
        {
          uint64_t v14 = v10 - v11;
          if (v10 - v11 >= 1)
          {
            do
            {
              if (v14 >= 2000000000) {
                uint64_t v15 = 2000000000;
              }
              else {
                uint64_t v15 = v14;
              }
              int v16 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v15, 0);
              if (v16) {
                int v16 = err_GenerateErrorCallback();
              }
              *(void *)(a1 + 48) = v15;
              BOOL v13 = v16 == 0;
              if (v16) {
                break;
              }
              BOOL v17 = v14 <= v15;
              v14 -= v15;
            }
            while (!v17);
          }
        }
        if (v13)
        {
          if ((**(uint64_t (***)(int *, uint64_t, uint64_t, void))(a1 + 16))(&v47, 4, 1, *(void *)(a1 + 24)) == 1)
          {
            *(void *)(a1 + 48) += 4;
          }
          else
          {
            int v18 = err_GenerateErrorCallback();
            *(void *)(a1 + 48) += 4;
            if (v18) {
              return;
            }
          }
          int v46 = *(_DWORD *)(a1 + 104);
          uint64_t v19 = v44 + 12;
          if (v44 + 12 >= 2000000000) {
            uint64_t v20 = 2000000000;
          }
          else {
            uint64_t v20 = v44 + 12;
          }
          int v21 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v20, 0);
          if (v21) {
            int v21 = err_GenerateErrorCallback();
          }
          *(void *)(a1 + 48) = v20;
          BOOL v22 = v21 == 0;
          if (!v21)
          {
            uint64_t v23 = v19 - v20;
            if (v19 - v20 >= 1)
            {
              do
              {
                if (v23 >= 2000000000) {
                  uint64_t v24 = 2000000000;
                }
                else {
                  uint64_t v24 = v23;
                }
                int v25 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v24, 0);
                if (v25) {
                  int v25 = err_GenerateErrorCallback();
                }
                *(void *)(a1 + 48) = v24;
                BOOL v22 = v25 == 0;
                if (v25) {
                  break;
                }
                BOOL v17 = v23 <= v24;
                v23 -= v24;
              }
              while (!v17);
            }
          }
          if (v22)
          {
            if ((**(uint64_t (***)(int *, uint64_t, uint64_t, void))(a1 + 16))(&v46, 4, 1, *(void *)(a1 + 24)) == 1)
            {
              *(void *)(a1 + 48) += 4;
            }
            else
            {
              int v26 = err_GenerateErrorCallback();
              *(void *)(a1 + 48) += 4;
              if (v26) {
                return;
              }
            }
            uint64_t v27 = v44 + 16;
            if (v44 + 16 >= 2000000000) {
              uint64_t v28 = 2000000000;
            }
            else {
              uint64_t v28 = v44 + 16;
            }
            int v29 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v28, 0);
            if (v29) {
              int v29 = err_GenerateErrorCallback();
            }
            *(void *)(a1 + 48) = v28;
            BOOL v30 = v29 == 0;
            if (!v29)
            {
              uint64_t v31 = v27 - v28;
              if (v27 - v28 >= 1)
              {
                do
                {
                  if (v31 >= 2000000000) {
                    uint64_t v32 = 2000000000;
                  }
                  else {
                    uint64_t v32 = v31;
                  }
                  int v33 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v32, 0);
                  if (v33) {
                    int v33 = err_GenerateErrorCallback();
                  }
                  *(void *)(a1 + 48) = v32;
                  BOOL v30 = v33 == 0;
                  if (v33) {
                    break;
                  }
                  BOOL v17 = v31 <= v32;
                  v31 -= v32;
                }
                while (!v17);
              }
            }
            if (v30)
            {
              if ((**(uint64_t (***)(uint64_t *, uint64_t, uint64_t, void))(a1 + 16))(&v45, 4, 1, *(void *)(a1 + 24)) == 1)
              {
                *(void *)(a1 + 48) += 4;
              }
              else
              {
                int v34 = err_GenerateErrorCallback();
                *(void *)(a1 + 48) += 4;
                if (v34) {
                  return;
                }
              }
              if (v8 >= 2000000000) {
                uint64_t v35 = 2000000000;
              }
              else {
                uint64_t v35 = v8;
              }
              int v36 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v35, 0);
              if (v36) {
                int v36 = err_GenerateErrorCallback();
              }
              *(void *)(a1 + 48) = v35;
              BOOL v37 = v36 == 0;
              if (!v36)
              {
                uint64_t v38 = v8 - v35;
                if (v8 - v35 >= 1)
                {
                  do
                  {
                    if (v38 >= 2000000000) {
                      uint64_t v39 = 2000000000;
                    }
                    else {
                      uint64_t v39 = v38;
                    }
                    int v40 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 24), v39, 0);
                    if (v40) {
                      int v40 = err_GenerateErrorCallback();
                    }
                    *(void *)(a1 + 48) = v39;
                    BOOL v37 = v40 == 0;
                    if (v40) {
                      break;
                    }
                    BOOL v17 = v38 <= v39;
                    v38 -= v39;
                  }
                  while (!v17);
                }
              }
              if (v37)
              {
                *(void *)(a1 + 56) = v8;
                *(_DWORD *)(a1 + 80) = 0;
              }
            }
          }
        }
      }
    }
  }
}

uint64_t __FSTCompactRndBuilder_CloseState(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 96);
  unsigned int v5 = *(_DWORD *)(v4 + 32);
  unsigned int v6 = *(_DWORD *)(a1 + 84);
  int v7 = *(_DWORD *)(a1 + 88);
  if (v6 < v5)
  {
LABEL_12:
    uint64_t result = 0;
    BOOL v13 = (_DWORD *)(*(void *)(*(void *)(v4 + 8) + 8 * (v6 >> *(_WORD *)(v4 + 44)))
                   + 8 * (v6 & ~(-1 << *(_WORD *)(v4 + 44))));
    int v14 = *(_DWORD *)(a1 + 92) | (a2 - v7);
    *BOOL v13 = *(_DWORD *)(a1 + 88);
    v13[1] = v14;
    *(_DWORD *)(a1 + 84) = -1;
    return result;
  }
  uint64_t v15 = 0;
  unsigned int v8 = v6 + 1;
  if (v6 + 1 <= v5)
  {
    *(_DWORD *)(v4 + 32) = v8;
LABEL_9:
    if (v5 <= v6)
    {
      uint64_t v11 = *(void *)(v4 + 8);
      __int16 v12 = *(_WORD *)(v4 + 44);
      do
      {
        *(void *)(*(void *)(v11 + 8 * (v5 >> v12)) + 8 * (v5 & ~(-1 << v12))) = 0xFFFFFFFFLL;
        ++v5;
        unsigned int v6 = *(_DWORD *)(a1 + 84);
      }
      while (v5 <= v6);
    }
    goto LABEL_12;
  }
  unsigned int v9 = v5 + 1;
  do
  {
    uint64_t result = dpmemblock_GetNewElement(*(void *)(a1 + 96), &v15, 0);
    if (v9 >= v8) {
      break;
    }
    ++v9;
  }
  while (!result);
  if (!result)
  {
    unsigned int v6 = *(_DWORD *)(a1 + 84);
    uint64_t v4 = *(void *)(a1 + 96);
    goto LABEL_9;
  }
  return result;
}

uint64_t __FSTCompactRndBuilder_WriteFstBaseHeader(uint64_t *a1, _DWORD *a2, uint64_t *a3)
{
  uint64_t result = FST_GetHeaderSizeInOutputBuffer(a3);
  unsigned int v8 = result;
  if (!result)
  {
    int v7 = (void *)OOCAllocator_Malloc(a1[1], *a3, &v8);
    uint64_t result = v8;
    if (!v8)
    {
      uint64_t result = FST_FillHeader(a2, v7, 1, a3);
      unsigned int v8 = result;
      if (!result)
      {
        if ((*(unsigned int (**)(uint64_t, void, void))(a1[2] + 8))(a1[3], 0, 0))
        {
          uint64_t result = err_GenerateErrorCallback();
          unsigned int v8 = result;
        }
        else
        {
          uint64_t result = v8;
        }
        a1[6] = 0;
        if (!result)
        {
          if ((*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))a1[2])(v7, *a3, 1, a1[3]) == 1)
          {
            uint64_t result = v8;
          }
          else
          {
            uint64_t result = err_GenerateErrorCallback();
            unsigned int v8 = result;
          }
          a1[6] += *a3;
          if (!result)
          {
            OOCAllocator_Free(a1[1], (uint64_t)v7);
            return v8;
          }
        }
      }
    }
  }
  return result;
}

uint64_t FSTCompactRndBuilder_InitializeState(uint64_t a1, int a2, int a3, unsigned int a4, int a5)
{
  uint64_t v10 = *(void *)(a1 + 48);
  uint64_t v14 = 0;
  uint64_t result = FST_GetHeaderSizeInOutputBuffer(&v14);
  if (!result)
  {
    int v12 = v10 - v14 - 24;
    if (*(_DWORD *)(a1 + 84) == -1 || (uint64_t result = __FSTCompactRndBuilder_CloseState(a1, v12), !result))
    {
      if ((a2 + 1) > *(_DWORD *)(a1 + 104)) {
        *(_DWORD *)(a1 + 104) = a2 + 1;
      }
      *(_DWORD *)(a1 + 88) = v12;
      *(_DWORD *)(a1 + 92) = a3;
      *(_DWORD *)(a1 + 84) = a2;
      if (a5) {
        *(_DWORD *)(a1 + 108) = a2;
      }
      if (a3 < 0)
      {
        unsigned int v13 = bswap32(a4);
        if (*(uint64_t *)(a1 + 48) < 0x7FFFFFFFFFFFFFFCLL)
        {
          if ((**(uint64_t (***)(unsigned int *, uint64_t, uint64_t, void))(a1 + 16))(&v13, 4, 1, *(void *)(a1 + 24)) == 1)uint64_t result = 0; {
          else
          }
            uint64_t result = err_GenerateErrorCallback();
          *(void *)(a1 + 48) += 4;
        }
        else
        {
          return err_GenerateErrorCallback();
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void PNEW_FSTCompactRndBuilder_Con(uint64_t a1, uint64_t a2, void *a3)
{
  int v8 = 0;
  unsigned int v6 = (void *)OOCAllocator_Malloc(a1, 112, &v8);
  if (!v8)
  {
    FSTCompactRndBuilder_Con(v6, a2);
    int v8 = v7;
    if (v7)
    {
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
    }
    else
    {
      *a3 = v6;
    }
  }
}

void PNEW_FSTCompactRndBuilder_ConToStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  int v14 = 0;
  int v12 = (void *)OOCAllocator_Malloc(a1, 112, &v14);
  if (!v14)
  {
    FSTCompactRndBuilder_ConToStream(v12, a2, a3, a4, a5);
    int v14 = v13;
    if (v13)
    {
      OOCAllocator_Free(a1, (uint64_t)v12);
      *a6 = 0;
    }
    else
    {
      *a6 = v12;
    }
  }
}

void *GetFSTCompactRndBuilderClass()
{
  return &__FSTCompactRndBuilder;
}

uint64_t FSTCopyLabels_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result = _FSTUnaryOperator_Con(a1, a2, a3);
  if (!result)
  {
    *(void *)a1 = &__FSTCopyLabels;
    *(_DWORD *)(a1 + 32) = 268435460;
    *(_DWORD *)(a1 + 72) = a4;
  }
  return result;
}

uint64_t FSTCopyLabels_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  char v5 = a3;
  uint64_t v11 = 0;
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, a3, &v11);
  if (!result)
  {
    uint64_t v8 = v11;
    if ((v5 & 0xB) == 0 || !v11) {
      goto LABEL_12;
    }
    if ((*(_DWORD *)(v11 + 8) & 0x3FFFFFE) != 0)
    {
      uint64_t v10 = 0;
      uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v10);
      if (result) {
        return result;
      }
      uint64_t result = FSTState_Copy(v10, v11);
      if (result) {
        return result;
      }
      int v9 = *(_DWORD *)(v11 + 8);
      *(_DWORD *)(v11 + 8) = v9 - 1;
      if ((v9 & 0x3FFFFFF) == 0) {
        return 9;
      }
      uint64_t v8 = v10;
      uint64_t v11 = v10;
    }
    uint64_t result = __FSTCopyLabels_Copy(*(void *)(v8 + 56), *(_DWORD *)(v8 + 48), *(_DWORD *)(a1 + 72));
    if (!result)
    {
      uint64_t result = __FSTCopyLabels_Copy(*(void *)(v11 + 40), *(_DWORD *)(v11 + 32), *(_DWORD *)(a1 + 72));
      if (!result)
      {
        uint64_t v8 = v11;
LABEL_12:
        uint64_t result = 0;
        *a4 = v8;
      }
    }
  }
  return result;
}

uint64_t __FSTCopyLabels_Copy(unint64_t a1, unsigned int a2, int a3)
{
  if ((a3 & 0xFFFFFFEF) != 0) {
    return err_GenerateErrorArg();
  }
  unint64_t v4 = a1 + 16 * a2;
  if ((a3 & 0x10) != 0)
  {
    if (a2)
    {
      do
      {
        unsigned int v5 = *(_DWORD *)(a1 + 4);
        if (v5 < 0xFFFFFFFE || *(_DWORD *)(a1 + 8) >> 30 != 1) {
          *(_DWORD *)(a1 + 8) = v5;
        }
        a1 += 16;
      }
      while (a1 < v4);
    }
  }
  else if (a2)
  {
    do
    {
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
      a1 += 16;
    }
    while (a1 < v4);
  }
  return 0;
}

uint64_t FSTCopyLabels_GetMemoryInfo(uint64_t a1)
{
  return FSTUnaryOperator_GetMemoryInfo(a1) + 8;
}

uint64_t FSTCopyLabels_GetStateFlags(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 56))(*(void *)(a1 + 64));
}

uint64_t PNEW_FSTCopyLabels_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5)
{
  unsigned int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 80, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = _FSTUnaryOperator_Con(v10, a2, a3);
    if (result)
    {
      unsigned int v12 = result;
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *(void *)uint64_t v10 = &__FSTCopyLabels;
      *(_DWORD *)(v10 + 32) = 268435460;
      *(_DWORD *)(v10 + 72) = a4;
      *(void *)(v10 + 16) = a1;
      *a5 = v10;
    }
  }
  return result;
}

void *GetFSTCopyLabelsClass()
{
  return &__FSTCopyLabels;
}

uint64_t fstbestpath(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7 = 0;
  uint64_t result = PNEW_FSTBestPath_Con(a1, a2, a3, &v7);
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 32))(a3);
    if (!result) {
      *a4 = v7;
    }
  }
  return result;
}

uint64_t PNEW_FSTBestPath_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 128, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = FSTBestPath_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *(void *)(v8 + 16) = a1;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t FSTBestPath_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = _FSTUnaryOperator_Con(a1, a2, a3);
  unsigned int v10 = v5;
  if (!v5)
  {
    *(void *)a1 = &__FSTBestPath;
    *(_DWORD *)(a1 + 72) = 10;
    uint64_t v6 = OOCAllocator_Malloc(a2, 40, &v10);
    *(void *)(a1 + 80) = v6;
    uint64_t v5 = v10;
    if (!v10)
    {
      uint64_t v7 = *(unsigned int *)(a1 + 72);
      unint64_t v8 = v6 + 4 * v7;
      *(void *)(a1 + 88) = v8;
      if (v7)
      {
        if (v8 <= v6 + 4) {
          unint64_t v8 = v6 + 4;
        }
        memset((void *)v6, 255, ((v8 + ~v6) & 0xFFFFFFFFFFFFFFFCLL) + 4);
      }
      *(_DWORD *)(a1 + 96) = 0;
      *(void *)(a1 + 104) = 0;
      *(void *)(a1 + 112) = 0;
      *(_DWORD *)(a1 + 120) = -1;
      return __FSTBestPath_CalcBestPath(a1);
    }
  }
  return v5;
}

uint64_t __FSTBestPath_CalcBestPath(uint64_t a1)
{
  unsigned int v158 = 0;
  uint64_t v157 = 0;
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 64);
  uint64_t result = (*(uint64_t (**)(uint64_t, unsigned int *))(*(void *)v3 + 48))(v3, &v158);
  v159[0] = result;
  if (result) {
    return result;
  }
  uint64_t v5 = v158 + 1;
  if (v158 == -1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    size_t v155 = 0;
  }
  else
  {
    if (v5 >= 9) {
      uint64_t v8 = v5;
    }
    else {
      uint64_t v8 = 8;
    }
    uint64_t v6 = OOCAllocator_Realloc(v2, 0, 4 * v8, v159);
    uint64_t result = v159[0];
    if (v159[0]) {
      return result;
    }
    unint64_t v9 = v6 + 4 * v5;
    if (v9 <= v6 + 4) {
      unint64_t v9 = v6 + 4;
    }
    size_t v10 = ((v9 + ~v6) & 0xFFFFFFFFFFFFFFFCLL) + 4;
    memset_pattern16((void *)v6, &unk_22078B380, v10);
    size_t v155 = v6 + v10;
    uint64_t v7 = v8;
  }
  uint64_t v11 = v158 + 1;
  if (v158 == -1)
  {
    unsigned int v149 = 0;
    uint64_t v12 = 0;
    size_t v13 = 0;
  }
  else
  {
    if (v11 >= 9) {
      unsigned int v14 = v158 + 1;
    }
    else {
      unsigned int v14 = 8;
    }
    uint64_t v12 = OOCAllocator_Realloc(v2, 0, 4 * v14, v159);
    uint64_t result = v159[0];
    if (v159[0]) {
      return result;
    }
    unint64_t v15 = v12 + 4 * v11;
    if (v15 <= v12 + 4) {
      unint64_t v15 = v12 + 4;
    }
    size_t v16 = ((v15 + ~v12) & 0xFFFFFFFFFFFFFFFCLL) + 4;
    bzero((void *)v12, v16);
    size_t v13 = v12 + v16;
    unsigned int v149 = v14;
  }
  unint64_t v154 = v13;
  uint64_t v17 = v158 + 1;
  if (v158 == -1)
  {
    unsigned int v143 = 0;
    uint64_t v18 = 0;
    size_t v150 = 0;
  }
  else
  {
    if (v17 >= 9) {
      unsigned int v19 = v158 + 1;
    }
    else {
      unsigned int v19 = 8;
    }
    uint64_t v18 = OOCAllocator_Realloc(v2, 0, 4 * v19, v159);
    uint64_t result = v159[0];
    if (v159[0]) {
      return result;
    }
    unint64_t v20 = v18 + 4 * v17;
    if (v20 <= v18 + 4) {
      unint64_t v20 = v18 + 4;
    }
    uint64_t v21 = v6;
    size_t v22 = ((v20 + ~v18) & 0xFFFFFFFFFFFFFFFCLL) + 4;
    memset((void *)v18, 255, v22);
    size_t v150 = v18 + v22;
    uint64_t v6 = v21;
    unsigned int v143 = v19;
  }
  uint64_t v23 = v158 + 1;
  if (v158 == -1)
  {
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    unint64_t v151 = 0;
  }
  else
  {
    if (v23 >= 9) {
      uint64_t v24 = v23;
    }
    else {
      uint64_t v24 = 8;
    }
    uint64_t v25 = OOCAllocator_Realloc(v2, 0, 4 * v24, v159);
    uint64_t result = v159[0];
    if (v159[0]) {
      return result;
    }
    unint64_t v26 = v25 + 4 * v23;
    if (v26 <= v25 + 4) {
      unint64_t v26 = v25 + 4;
    }
    uint64_t v27 = v7;
    size_t v28 = ((v26 + ~v25) & 0xFFFFFFFFFFFFFFFCLL) + 4;
    bzero((void *)v25, v28);
    unint64_t v151 = v25 + v28;
    uint64_t v7 = v27;
  }
  *(_DWORD *)(v6 + 4 * v158) = 0;
  *(_DWORD *)(v12 + 4 * v158) = 1;
  uint64_t v29 = v18;
  *(_DWORD *)(v18 + 4 * v158) = -1;
  *(_DWORD *)(v25 + 4 * v158) = 0;
  uint64_t result = IFSTStateQueue_Create(v2, v2, v3, &v157);
  v159[0] = result;
  if (result) {
    return result;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, void))(*v157 + 8))((uint64_t)v157 - *(void *)(*v157 + 48), v158);
  v159[0] = result;
  if (result) {
    return result;
  }
  uint64_t v147 = v12;
  uint64_t v148 = v25;
  if ((*(unsigned int (**)(uint64_t))(*v157 + 32))((uint64_t)v157 - *(void *)(*v157 + 48)))
  {
    unsigned int v30 = -1;
    unsigned int v135 = -1;
LABEL_43:
    uint64_t v145 = v6;
    unsigned int v158 = v30;
    uint64_t v152 = v29;
    if (v30 == -1)
    {
      uint64_t v39 = *(void *)(a1 + 104);
      unsigned int v32 = -1;
LABEL_190:
      unsigned int v105 = *(_DWORD **)(a1 + 112);
      uint64_t v107 = v147;
      uint64_t v106 = v148;
      if (-1431655765 * (((unint64_t)v105 - v39) >> 2) || (unsigned int v158 = v135, v135 == -1))
      {
LABEL_191:
        if (v145) {
          OOCAllocator_Free(v2, v145);
        }
        if (v107) {
          OOCAllocator_Free(v2, v107);
        }
        if (v152) {
          OOCAllocator_Free(v2, v152);
        }
        if (v106) {
          OOCAllocator_Free(v2, v106);
        }
        return OOC_PlacementDeleteObject(v2, (uint64_t)v157 - *(void *)(*v157 + 48));
      }
      else
      {
        while (1)
        {
          int v108 = v32 == -1 ? 0 : *(_DWORD *)(v106 + 4 * v32);
          uint64_t result = v159[0];
          if (v159[0]) {
            break;
          }
          uint64_t v109 = *(unsigned int **)(a1 + 80);
          unint64_t v110 = *(void *)(a1 + 88) - (void)v109;
          unint64_t v111 = v110 >> 2;
          uint64_t v112 = v135 % (v110 >> 2);
          uint64_t v113 = v109[v112];
          if ((v113 & 0x80000000) != 0)
          {
LABEL_208:
            LODWORD(v114) = *(_DWORD *)(a1 + 120);
            if (v114 == -1)
            {
              unint64_t v114 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v105 - v39) >> 2);
              unsigned int v118 = v114;
              if (2 * (int)v111 < v114)
              {
                unsigned int v119 = (2 * v111) | 1;
                uint64_t v120 = *(unsigned int *)(a1 + 72);
                if (v119 <= v120)
                {
                  uint64_t v122 = 4 * v120;
                }
                else
                {
                  if (v119 <= 8) {
                    unsigned int v121 = 8;
                  }
                  else {
                    unsigned int v121 = (2 * v111) | 1;
                  }
                  uint64_t v122 = 4 * v121;
                  uint64_t v109 = (unsigned int *)OOCAllocator_Realloc(v2, *(void *)(a1 + 80), v122, v159);
                  *(void *)(a1 + 80) = v109;
                  uint64_t result = v159[0];
                  if (v159[0]) {
                    return result;
                  }
                  *(_DWORD *)(a1 + 72) = v121;
                  v110 &= 0x3FFFFFFFCuLL;
                }
                unint64_t v123 = (v110 >> 1) & 0xFFFFFFFE | 1;
                *(void *)(a1 + 88) = &v109[v123];
                cstdlib_memset(v109, 255, v122);
                uint64_t v39 = *(void *)(a1 + 104);
                unsigned int v105 = *(_DWORD **)(a1 + 112);
                unsigned int v118 = -1431655765 * (((uint64_t)v105 - v39) >> 2);
                if (v118)
                {
                  uint64_t v124 = 0;
                  unsigned int v125 = *(_DWORD **)(a1 + 104);
                  do
                  {
                    if (((*v125 + 1) & 0x40000000) == 0)
                    {
                      uint64_t result = v159[0];
                      if (v159[0]) {
                        return result;
                      }
                      unint64_t v126 = v125[1]
                           - (v125[1] / v123) * (unint64_t)v123;
                      uint64_t v127 = *(void *)(a1 + 80);
                      *unsigned int v125 = *(_DWORD *)(v127 + 4 * v126);
                      *(_DWORD *)(v127 + 4 * v126) = v124;
                    }
                    ++v124;
                    v125 += 3;
                  }
                  while (-1431655765 * (((uint64_t)v105 - v39) >> 2) != v124);
                  LODWORD(v114) = -1431655765 * (((uint64_t)v105 - v39) >> 2);
                }
                else
                {
                  LODWORD(v114) = 0;
                }
              }
              unsigned int v128 = v114 + 1;
              unsigned int v129 = *(_DWORD *)(a1 + 96);
              if ((int)v114 + 1 > v129)
              {
                unsigned int v130 = 2 * v129;
                unsigned int v131 = v129 + 1000000;
                if (v130 >= v131) {
                  unsigned int v130 = v131;
                }
                if (v130 > v128) {
                  unsigned int v128 = v130;
                }
                if (v128 <= 8) {
                  unsigned int v132 = 8;
                }
                else {
                  unsigned int v132 = v128;
                }
                uint64_t v39 = OOCAllocator_Realloc(v2, v39, 12 * v132, v159);
                *(void *)(a1 + 104) = v39;
                uint64_t result = v159[0];
                if (v159[0]) {
                  return result;
                }
                *(_DWORD *)(a1 + 96) = v132;
                unsigned int v105 = (_DWORD *)(v39 + 12 * v118);
              }
              *(void *)(a1 + 112) = v105 + 3;
              *unsigned int v105 = 0;
              v105[1] = v135;
              v105[2] = v108;
              uint64_t v109 = *(unsigned int **)(a1 + 80);
              uint64_t v112 = v135 % ((*(void *)(a1 + 88) - (void)v109) >> 2);
              int v115 = v114;
              v105 += 3;
            }
            else
            {
              int v115 = *(_DWORD *)(a1 + 120);
              BOOL v116 = (_DWORD *)(v39 + 12 * (int)v114);
              *(_DWORD *)(a1 + 120) = (*v116 & 0xBFFFFFFF) - 1;
              *BOOL v116 = 0;
              v116[1] = v135;
              v116[2] = v108;
            }
            *(_DWORD *)(v39 + 12 * v115) = v109[v112];
            v109[v112] = v114;
            unsigned int v117 = v158;
            uint64_t v107 = v147;
          }
          else
          {
            while (v135 != *(_DWORD *)(v39 + 12 * v113 + 4))
            {
              uint64_t v113 = *(unsigned int *)(v39 + 12 * v113);
              if ((v113 & 0x80000000) != 0) {
                goto LABEL_208;
              }
            }
            uint64_t v107 = v147;
            unsigned int v117 = v135;
          }
          uint64_t v106 = v148;
          unsigned int v32 = v117;
          unsigned int v158 = *(_DWORD *)(v152 + 4 * v117);
          unsigned int v135 = v158;
          if (v158 == -1) {
            goto LABEL_191;
          }
        }
      }
      return result;
    }
    uint64_t v31 = v29;
    unsigned int v32 = -1;
    while (2)
    {
      if (v32 == -1) {
        int v33 = 0;
      }
      else {
        int v33 = *(_DWORD *)(v148 + 4 * v32);
      }
      uint64_t result = v159[0];
      if (!v159[0])
      {
        int v34 = *(char **)(a1 + 80);
        unint64_t v35 = *(void *)(a1 + 88) - (void)v34;
        uint64_t v36 = v30 % (v35 >> 2);
        BOOL v37 = &v34[4 * v36];
        while (1)
        {
          unsigned int v38 = *(_DWORD *)v37;
          if ((v38 & 0x80000000) != 0) {
            break;
          }
          uint64_t v39 = *(void *)(a1 + 104);
          BOOL v37 = (char *)(v39 + 12 * v38);
          if (v30 == *((_DWORD *)v37 + 1)) {
            goto LABEL_85;
          }
        }
        int v40 = *(_DWORD *)(a1 + 120);
        if (v40 == -1)
        {
          uint64_t v39 = *(void *)(a1 + 104);
          long long v43 = *(_DWORD **)(a1 + 112);
          uint64_t v44 = ((uint64_t)v43 - v39) >> 2;
          int v40 = -1431655765 * v44;
          unsigned int v45 = 2 * (v35 >> 2);
          if (v45 >= -1431655765 * (int)v44)
          {
            unsigned int v50 = -1431655765 * v44;
          }
          else
          {
            unsigned int v46 = v45 | 1;
            uint64_t v47 = *(unsigned int *)(a1 + 72);
            if (v46 <= v47)
            {
              uint64_t v49 = 4 * v47;
            }
            else
            {
              if (v46 <= 8) {
                unsigned int v48 = 8;
              }
              else {
                unsigned int v48 = v46;
              }
              uint64_t v49 = 4 * v48;
              int v34 = (char *)OOCAllocator_Realloc(v2, *(void *)(a1 + 80), v49, v159);
              *(void *)(a1 + 80) = v34;
              uint64_t result = v159[0];
              if (v159[0]) {
                return result;
              }
              *(_DWORD *)(a1 + 72) = v48;
              v35 &= 0x3FFFFFFFCuLL;
            }
            unint64_t v51 = (v35 >> 1) & 0xFFFFFFFE | 1;
            *(void *)(a1 + 88) = &v34[4 * v51];
            cstdlib_memset(v34, 255, v49);
            uint64_t v39 = *(void *)(a1 + 104);
            long long v43 = *(_DWORD **)(a1 + 112);
            unsigned int v50 = -1431655765 * (((uint64_t)v43 - v39) >> 2);
            if (v50)
            {
              uint64_t v52 = 0;
              uint64_t v53 = *(_DWORD **)(a1 + 104);
              do
              {
                if (((*v53 + 1) & 0x40000000) == 0)
                {
                  uint64_t result = v159[0];
                  if (v159[0]) {
                    return result;
                  }
                  unint64_t v54 = v53[1]
                      - (v53[1] / v51) * (unint64_t)v51;
                  uint64_t v55 = *(void *)(a1 + 80);
                  *uint64_t v53 = *(_DWORD *)(v55 + 4 * v54);
                  *(_DWORD *)(v55 + 4 * v54) = v52;
                }
                ++v52;
                v53 += 3;
              }
              while (-1431655765 * (((uint64_t)v43 - v39) >> 2) != v52);
              int v40 = -1431655765 * (((uint64_t)v43 - v39) >> 2);
            }
            else
            {
              int v40 = 0;
            }
            uint64_t v31 = v29;
          }
          unsigned int v56 = v40 + 1;
          unsigned int v57 = *(_DWORD *)(a1 + 96);
          if (v40 + 1 > v57)
          {
            unsigned int v58 = 2 * v57;
            unsigned int v59 = v57 + 1000000;
            if (v58 >= v59) {
              unsigned int v58 = v59;
            }
            if (v58 > v56) {
              unsigned int v56 = v58;
            }
            if (v56 <= 8) {
              unsigned int v60 = 8;
            }
            else {
              unsigned int v60 = v56;
            }
            uint64_t v39 = OOCAllocator_Realloc(v2, v39, 12 * v60, v159);
            *(void *)(a1 + 104) = v39;
            uint64_t result = v159[0];
            if (v159[0]) {
              return result;
            }
            *(_DWORD *)(a1 + 96) = v60;
            long long v43 = (_DWORD *)(v39 + 12 * v50);
            uint64_t v31 = v29;
          }
          *(void *)(a1 + 112) = v43 + 3;
          _DWORD *v43 = 0;
          v43[1] = v30;
          v43[2] = v33;
          int v34 = *(char **)(a1 + 80);
          uint64_t v36 = v30 % ((*(void *)(a1 + 88) - (void)v34) >> 2);
          int v41 = v40;
        }
        else
        {
          int v41 = *(_DWORD *)(a1 + 120);
          uint64_t v39 = *(void *)(a1 + 104);
          long long v42 = (_DWORD *)(v39 + 12 * v40);
          *(_DWORD *)(a1 + 120) = (*v42 & 0xBFFFFFFF) - 1;
          _DWORD *v42 = 0;
          v42[1] = v30;
          v42[2] = v33;
        }
        *(_DWORD *)(v39 + 12 * v41) = *(_DWORD *)&v34[4 * v36];
        *(_DWORD *)&v34[4 * v36] = v40;
        unsigned int v30 = v158;
LABEL_85:
        unsigned int v32 = v30;
        unsigned int v30 = *(_DWORD *)(v31 + 4 * v30);
        unsigned int v158 = v30;
        if (v30 != -1) {
          continue;
        }
        goto LABEL_190;
      }
      break;
    }
  }
  else
  {
    int v134 = 0x7FFFFFFF;
    unsigned int v135 = -1;
    unsigned int v30 = -1;
    int v133 = 0x7FFFFFFF;
    unint64_t v61 = v151;
    while (1)
    {
      uint64_t v156 = 0;
      uint64_t v62 = (*(uint64_t (**)(uint64_t))*v157)((uint64_t)v157 - *(void *)(*v157 + 48));
      uint64_t result = (*(uint64_t (**)(uint64_t))(*v157 + 16))((uint64_t)v157 - *(void *)(*v157 + 48));
      v159[0] = result;
      if (result) {
        break;
      }
      *(_DWORD *)(v147 + 4 * v62) = 0;
      int v141 = *(_DWORD *)(v6 + 4 * v62);
      int v136 = v62;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)v3 + 120))(v3, v62, 8, &v156);
      v159[0] = result;
      if (result) {
        break;
      }
      uint64_t v63 = v156;
      if (v156)
      {
        int v64 = *(_DWORD *)(v156 + 8);
        uint64_t v137 = v24;
        if (v64 < 0)
        {
          int v65 = *(_DWORD *)(v156 + 32);
          int v72 = *(_DWORD *)(v156 + 28) + v141;
          int v73 = v133;
          BOOL v74 = v133 <= v72;
          if (v133 >= v72) {
            int v73 = *(_DWORD *)(v156 + 28) + v141;
          }
          int v133 = v73;
          if (!v74) {
            unsigned int v30 = v62;
          }
          unsigned int v66 = *(_DWORD *)(v156 + 48);
        }
        else
        {
          int v65 = *(_DWORD *)(v156 + 32);
          unsigned int v66 = *(_DWORD *)(v156 + 48);
          BOOL v67 = v65 + v66 == 0;
          int v68 = v134;
          BOOL v69 = v134 > v141;
          BOOL v70 = !v67 || !v69;
          if (v67 && v69) {
            int v68 = v141;
          }
          unsigned int v71 = v135;
          if (!v70) {
            unsigned int v71 = v62;
          }
          int v134 = v68;
          unsigned int v135 = v71;
        }
        uint64_t v75 = v29;
        uint64_t v76 = *(unsigned int **)(v156 + 40);
        uint64_t v139 = *(void *)(v156 + 56) + 16 * v66;
        if (v76 != (unsigned int *)v139)
        {
          int v140 = &v76[4 * v65];
          int v77 = 1;
          do
          {
            if (v76 == v140)
            {
              uint64_t v63 = v156;
              if (!*(_DWORD *)(v156 + 48)) {
                goto LABEL_179;
              }
              uint64_t v76 = *(unsigned int **)(v156 + 56);
            }
            int v142 = v77;
            uint64_t v144 = v7;
            uint64_t v146 = v6;
            uint64_t v153 = v75;
            uint64_t v78 = *v76;
            uint64_t v79 = (v78 + 1);
            size_t v80 = v155 - v6;
            if (v79 >= (v80 >> 2))
            {
              if (v79 <= v144)
              {
                uint64_t v82 = v146;
                unint64_t v83 = v155;
              }
              else
              {
                LODWORD(v81) = 2 * v144;
                if (2 * (int)v144 >= (v144 + 1000000)) {
                  LODWORD(v81) = v144 + 1000000;
                }
                if (v81 <= v79) {
                  LODWORD(v81) = v78 + 1;
                }
                if (v81 <= 8) {
                  uint64_t v81 = 8;
                }
                else {
                  uint64_t v81 = v81;
                }
                uint64_t v144 = v81;
                uint64_t v82 = OOCAllocator_Realloc(v2, v146, 4 * v81, v159);
                uint64_t result = v159[0];
                if (v159[0]) {
                  return result;
                }
                unint64_t v83 = v82 + (v80 & 0x3FFFFFFFCLL);
              }
              uint64_t v146 = v82;
              if (v83 < v82 + 4 * v79)
              {
                unint64_t v84 = v82 + 4 * v79;
                if (v84 <= v83 + 4) {
                  unint64_t v84 = v83 + 4;
                }
                size_t v85 = ((v84 + ~v83) & 0xFFFFFFFFFFFFFFFCLL) + 4;
                memset_pattern16((void *)v83, &unk_22078B380, v85);
                v83 += v85;
              }
              size_t v155 = v83;
            }
            unint64_t v86 = v154;
            if (v79 >= ((v154 - v147) >> 2))
            {
              if (v79 <= v149)
              {
                uint64_t v88 = v147;
              }
              else
              {
                unsigned int v87 = 2 * v149;
                if (2 * v149 >= v149 + 1000000) {
                  unsigned int v87 = v149 + 1000000;
                }
                if (v87 <= v79) {
                  unsigned int v87 = v78 + 1;
                }
                if (v87 <= 8) {
                  unsigned int v87 = 8;
                }
                unsigned int v149 = v87;
                uint64_t v88 = OOCAllocator_Realloc(v2, v147, 4 * v87, v159);
                uint64_t result = v159[0];
                if (v159[0]) {
                  return result;
                }
                unint64_t v86 = v88 + ((v154 - v147) & 0x3FFFFFFFCLL);
              }
              uint64_t v147 = v88;
              if (v86 < v88 + 4 * v79)
              {
                unint64_t v89 = v88 + 4 * v79;
                if (v89 <= v86 + 4) {
                  unint64_t v89 = v86 + 4;
                }
                size_t v90 = ((v89 + ~v86) & 0xFFFFFFFFFFFFFFFCLL) + 4;
                bzero((void *)v86, v90);
                v86 += v90;
              }
            }
            if (v79 >= ((v150 - v153) >> 2))
            {
              uint64_t v138 = v78;
              if (v79 <= v143)
              {
                unint64_t v93 = v61;
                unint64_t v94 = v150;
                uint64_t v92 = v153;
              }
              else
              {
                unsigned int v91 = 2 * v143;
                if (2 * v143 >= v143 + 1000000) {
                  unsigned int v91 = v143 + 1000000;
                }
                if (v91 <= v79) {
                  unsigned int v91 = v78 + 1;
                }
                if (v91 <= 8) {
                  unsigned int v91 = 8;
                }
                unsigned int v143 = v91;
                uint64_t v92 = OOCAllocator_Realloc(v2, v153, 4 * v91, v159);
                uint64_t result = v159[0];
                if (v159[0]) {
                  return result;
                }
                unint64_t v93 = v61;
                unint64_t v94 = v92 + ((v150 - v153) & 0x3FFFFFFFCLL);
              }
              uint64_t v153 = v92;
              if (v94 < v92 + 4 * v79)
              {
                unint64_t v95 = v92 + 4 * v79;
                if (v95 <= v94 + 4) {
                  unint64_t v95 = v94 + 4;
                }
                size_t v96 = ((v95 + ~v94) & 0xFFFFFFFFFFFFFFFCLL) + 4;
                memset((void *)v94, 255, v96);
                v94 += v96;
              }
              size_t v150 = v94;
              unint64_t v61 = v93;
              uint64_t v78 = v138;
            }
            unint64_t v154 = v86;
            if (v79 >= ((v61 - v148) >> 2))
            {
              if (v79 <= v137)
              {
                uint64_t v98 = v148;
              }
              else
              {
                LODWORD(v97) = 2 * v137;
                if (2 * (int)v137 >= (v137 + 1000000)) {
                  LODWORD(v97) = v137 + 1000000;
                }
                if (v97 <= v79) {
                  LODWORD(v97) = v79;
                }
                if (v97 <= 8) {
                  uint64_t v97 = 8;
                }
                else {
                  uint64_t v97 = v97;
                }
                uint64_t v137 = v97;
                uint64_t v98 = OOCAllocator_Realloc(v2, v148, 4 * v97, v159);
                uint64_t result = v159[0];
                if (v159[0]) {
                  return result;
                }
                unint64_t v61 = v98 + ((v61 - v148) & 0x3FFFFFFFCLL);
              }
              uint64_t v148 = v98;
              if (v61 < v98 + 4 * v79)
              {
                unint64_t v99 = v98 + 4 * v79;
                if (v99 <= v61 + 4) {
                  unint64_t v99 = v61 + 4;
                }
                size_t v100 = ((v99 + ~v61) & 0xFFFFFFFFFFFFFFFCLL) + 4;
                bzero((void *)v61, v100);
                v61 += v100;
              }
            }
            uint64_t v75 = v153;
            uint64_t v6 = v146;
            signed int v101 = v76[3] + v141;
            if (*(_DWORD *)(v146 + 4 * v78) > v101)
            {
              *(_DWORD *)(v146 + 4 * v78) = v101;
              *(_DWORD *)(v153 + 4 * v78) = v136;
              *(_DWORD *)(v148 + 4 * v78) = v142;
              uint64_t v102 = *v157;
              uint64_t v103 = (uint64_t)v157 - *(void *)(*v157 + 48);
              if (*(_DWORD *)(v147 + 4 * v78))
              {
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v102 + 24))(v103, v78);
                v159[0] = result;
                uint64_t v75 = v153;
                if (result) {
                  return result;
                }
              }
              else
              {
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v102 + 8))(v103, v78);
                v159[0] = result;
                if (result) {
                  return result;
                }
                *(_DWORD *)(v147 + 4 * v78) = 1;
                uint64_t v75 = v153;
              }
            }
            v76 += 4;
            int v77 = v142 + 1;
            uint64_t v7 = v144;
          }
          while (v76 != (unsigned int *)v139);
          uint64_t v63 = v156;
LABEL_179:
          int v64 = *(_DWORD *)(v63 + 8);
        }
        uint64_t v24 = v137;
        if ((v64 & 0x3FFFFFF) == 1)
        {
          uint64_t v29 = v75;
          if ((v64 & 0x8000000) != 0) {
            uint64_t v104 = *(void *)(v63 + 16);
          }
          else {
            uint64_t v104 = 0;
          }
          uint64_t result = FSTStatePool_PushFSTState(v104, v63);
          v159[0] = result;
          if (result) {
            return result;
          }
        }
        else
        {
          *(_DWORD *)(v63 + 8) = v64 - 1;
          if ((v64 & 0x3FFFFFF) == 0) {
            return 9;
          }
          uint64_t v29 = v75;
          v159[0] = 0;
        }
      }
      if ((*(unsigned int (**)(uint64_t))(*v157 + 32))((uint64_t)v157 - *(void *)(*v157 + 48))) {
        goto LABEL_43;
      }
    }
  }
  return result;
}

uint64_t FSTBestPath_Des(uint64_t *a1)
{
  uint64_t v2 = a1[10];
  if (v2) {
    OOCAllocator_Free(a1[3], v2);
  }
  uint64_t v3 = a1[13];
  if (v3) {
    OOCAllocator_Free(a1[3], v3);
  }

  return FSTUnaryOperator_Des((uint64_t)a1);
}

uint64_t FSTBestPath_FetchState(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t *a4)
{
  if (a2 == -1)
  {
    uint64_t result = 0;
    *a4 = 0;
    return result;
  }
  uint64_t v20 = 0;
  uint64_t v7 = *(void *)(a1 + 104);
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), *(unsigned int *)(v7 + 12 * a2 + 4), a3, &v20);
  if (!result)
  {
    uint64_t v9 = v20;
    if (!v20)
    {
LABEL_17:
      uint64_t result = 0;
      *a4 = v9;
      return result;
    }
    if ((*(_DWORD *)(v20 + 8) & 0x3FFFFFE) == 0)
    {
LABEL_9:
      *(_DWORD *)(v9 + 24) = a2;
      int v11 = *(_DWORD *)(v7 + 12 * a2 + 8);
      if (v11)
      {
        unsigned int v12 = v11 - 1;
        unsigned int v13 = *(_DWORD *)(v9 + 32);
        BOOL v14 = v12 >= v13;
        unsigned int v15 = v12 - v13;
        if (!v14)
        {
          size_t v16 = *(_OWORD **)(v9 + 40);
          _OWORD *v16 = v16[v12];
          *(_DWORD *)size_t v16 = a2 - 1;
          *(_DWORD *)(v9 + 32) = 1;
          *(_DWORD *)(v9 + 48) = 0;
          unsigned int v17 = *(_DWORD *)(v9 + 8) | 0x20000000;
LABEL_16:
          *(_DWORD *)(v9 + 8) = v17;
          goto LABEL_17;
        }
        uint64_t v18 = *(_OWORD **)(v9 + 56);
        *uint64_t v18 = v18[v15];
        *(_DWORD *)uint64_t v18 = a2 - 1;
        *(_DWORD *)(v9 + 32) = 0;
        *(_DWORD *)(v9 + 48) = 1;
      }
      else
      {
        *(_DWORD *)(v9 + 32) = 0;
        *(_DWORD *)(v9 + 48) = 0;
      }
      unsigned int v17 = *(_DWORD *)(v9 + 8) & 0xDFFFFFFF;
      goto LABEL_16;
    }
    uint64_t v19 = 0;
    uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v19);
    if (!result)
    {
      uint64_t result = FSTState_Copy(v19, v20);
      if (!result)
      {
        int v10 = *(_DWORD *)(v20 + 8);
        *(_DWORD *)(v20 + 8) = v10 - 1;
        if ((v10 & 0x3FFFFFF) == 0) {
          return 9;
        }
        uint64_t v9 = v19;
        goto LABEL_9;
      }
    }
  }
  return result;
}

uint64_t FSTBestPath_GetFinalStateWeight(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 64) + 64))(*(void *)(a1 + 64), *(unsigned int *)(*(void *)(a1 + 104) + 12 * a2 + 4));
}

uint64_t FSTBestPath_GetInitialStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = -1431655765 * ((*(void *)(a1 + 112) - *(void *)(a1 + 104)) >> 2) - 1;
  return 0;
}

uint64_t FSTBestPath_GetMappedStateId(void *a1, unsigned int a2)
{
  uint64_t v2 = (int *)(a1[10] + 4 * (a2 % ((a1[11] - a1[10]) >> 2)));
  do
  {
    int v3 = *v2;
    if (*v2 < 0) {
      break;
    }
    uint64_t v2 = (int *)(a1[13] + 12 * v3);
  }
  while (v2[1] != a2);
  if (v3 < 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v3;
  }
}

uint64_t FSTBestPath_GetMaxStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = -1431655765 * ((*(void *)(a1 + 112) - *(void *)(a1 + 104)) >> 2) - 1;
  return 0;
}

uint64_t FSTBestPath_GetMemoryInfo(uint64_t a1)
{
  return FSTUnaryOperator_GetMemoryInfo(a1) + 4 * *(unsigned int *)(a1 + 72) + 12 * *(unsigned int *)(a1 + 96) + 56;
}

uint64_t FSTBestPath_GetStateFlags(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 64) + 56))(*(void *)(a1 + 64), *(unsigned int *)(*(void *)(a1 + 104) + 12 * a2 + 4));
}

uint64_t FSTBestPath_Reset(uint64_t a1)
{
  uint64_t result = FSTUnaryOperator_Reset(a1);
  if (!result)
  {
    unint64_t v3 = *(void *)(a1 + 80);
    unint64_t v4 = *(void *)(a1 + 88);
    if (v3 < v4)
    {
      if (v4 <= v3 + 4) {
        unint64_t v4 = v3 + 4;
      }
      memset((void *)v3, 255, ((v4 + ~v3) & 0xFFFFFFFFFFFFFFFCLL) + 4);
    }
    *(_DWORD *)(a1 + 96) = 0;
    uint64_t v5 = *(void *)(a1 + 104);
    if (v5)
    {
      OOCAllocator_Free(*(void *)(a1 + 24), v5);
      *(void *)(a1 + 104) = 0;
    }
    *(void *)(a1 + 112) = 0;
    *(_DWORD *)(a1 + 120) = -1;
    return __FSTBestPath_CalcBestPath(a1);
  }
  return result;
}

void *GetFSTBestPathClass()
{
  return &__FSTBestPath;
}

uint64_t FSTNumber_Con(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = _FSTUnaryOperator_Con((uint64_t)a1, a2, a3);
  if (!result)
  {
    *a1 = &__FSTNumber;
    a1[9] = 0;
    uint64_t result = PNEW_FSTNumberDfsContext_Con(a2, a2, a3, a1 + 9);
    if (!result)
    {
      uint64_t result = FSTDfsContext_Dfs(a1[9]);
      if (!result)
      {
        uint64_t v7 = FSTNumberDfsContext_BorrowIndexArray(a1[9]);
        uint64_t result = 0;
        a1[10] = v7;
      }
    }
  }
  return result;
}

uint64_t FSTNumber_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  if (!v2 || (uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 24), v2), !result))
  {
    return FSTUnaryOperator_Des(a1);
  }
  return result;
}

uint64_t FSTNumber_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v15 = 0;
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, a3, &v15);
  if (!result)
  {
    uint64_t v7 = v15;
    if ((*(_DWORD *)(v15 + 8) & 0x3FFFFFE) != 0)
    {
      uint64_t v14 = 0;
      uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v14);
      if (result) {
        return result;
      }
      uint64_t result = FSTState_Copy(v14, v15);
      if (result) {
        return result;
      }
      int v8 = *(_DWORD *)(v15 + 8);
      *(_DWORD *)(v15 + 8) = v8 - 1;
      if ((v8 & 0x3FFFFFF) == 0) {
        return 9;
      }
      uint64_t v7 = v14;
      uint64_t v15 = v14;
    }
    uint64_t v9 = *(unsigned int *)(v7 + 48);
    if (v9)
    {
      uint64_t v10 = **(void **)(a1 + 80);
      uint64_t v11 = *(void *)(v10 + 8);
      __int16 v12 = *(_WORD *)(v10 + 44);
      unsigned int v13 = (_DWORD *)(*(void *)(v7 + 56) + 8);
      do
      {
        *unsigned int v13 = *(_DWORD *)(*(void *)(v11 + 8 * (*(v13 - 2) >> v12))
                         + 4 * (*(v13 - 2) & ~(-1 << v12)));
        v13 += 4;
        --v9;
      }
      while (v9);
    }
    uint64_t result = 0;
    *a4 = v7;
  }
  return result;
}

uint64_t PNEW_FSTNumber_Con(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unsigned int v10 = 0;
  int v8 = (void *)OOCAllocator_Malloc(a1, 88, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = FSTNumber_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      v8[2] = a1;
      *a4 = v8;
    }
  }
  return result;
}

void *GetFSTNumberClass()
{
  return &__FSTNumber;
}

uint64_t fstpartial(uint64_t a1, uint64_t a2, _DWORD *a3, void *a4)
{
  if (a3[8] == 12)
  {
    uint64_t result = 0;
    *a4 = a3;
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t result = PNEW_FSTPartial_Con(a1, a2, (uint64_t)a3, &v7);
    if (!result)
    {
      uint64_t result = (*(uint64_t (**)(_DWORD *))(*(void *)a3 + 32))(a3);
      if (!result) {
        *a4 = v7;
      }
    }
  }
  return result;
}

uint64_t PNEW_FSTPartial_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 152, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = FSTPartial_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *(void *)(v8 + 16) = a1;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t FSTPartial_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = _FSTUnaryOperator_Con(a1, a2, a3);
  unsigned int v11 = v6;
  if (!v6)
  {
    *(void *)a1 = &__FSTPartial;
    *(_DWORD *)(a1 + 72) = 1;
    uint64_t v7 = OOCAllocator_Malloc(a2, 4, &v11);
    *(void *)(a1 + 80) = v7;
    uint64_t v6 = v11;
    if (!v11)
    {
      uint64_t v8 = *(unsigned int *)(a1 + 72);
      unint64_t v9 = v7 + 4 * v8;
      *(void *)(a1 + 88) = v9;
      if (v8)
      {
        if (v9 <= v7 + 4) {
          unint64_t v9 = v7 + 4;
        }
        memset((void *)v7, 255, ((v9 + ~v7) & 0xFFFFFFFFFFFFFFFCLL) + 4);
      }
      *(_DWORD *)(a1 + 96) = 0;
      *(void *)(a1 + 104) = 0;
      *(void *)(a1 + 112) = 0;
      *(_DWORD *)(a1 + 120) = -1;
      *(_DWORD *)(a1 + 32) = 12;
      uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 48))(a3, a1 + 128);
      if (!v6)
      {
        *(void *)(a1 + 136) = 0;
        *(_DWORD *)(a1 + 144) = 1;
      }
    }
  }
  return v6;
}

uint64_t FSTPartial_Des(uint64_t *a1)
{
  uint64_t v2 = a1[10];
  if (v2) {
    OOCAllocator_Free(a1[3], v2);
  }
  uint64_t v3 = a1[13];
  if (v3) {
    OOCAllocator_Free(a1[3], v3);
  }
  uint64_t result = FSTPartial_ClearInitialStates((uint64_t)a1);
  if (!result)
  {
    return FSTUnaryOperator_Des((uint64_t)a1);
  }
  return result;
}

uint64_t FSTPartial_ClearInitialStates(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 136);
  if (!v2) {
    goto LABEL_10;
  }
  int v3 = *(_DWORD *)(v2 + 8);
  if ((v3 & 0x3FFFFFF) != 1)
  {
    *(_DWORD *)(v2 + 8) = v3 - 1;
    if ((v3 & 0x3FFFFFF) == 0) {
      return 9;
    }
    goto LABEL_9;
  }
  if ((v3 & 0x8000000) != 0) {
    uint64_t v4 = *(void *)(v2 + 16);
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t result = FSTStatePool_PushFSTState(v4, v2);
  if (!result)
  {
LABEL_9:
    *(void *)(a1 + 136) = 0;
LABEL_10:
    uint64_t result = 0;
    *(_DWORD *)(a1 + 144) = 1;
  }
  return result;
}

uint64_t FSTPartial_AddInitialStates(uint64_t a1, unsigned int a2, int *a3)
{
  unsigned int v21 = 0;
  if (!a2) {
    return 0;
  }
  if (*(void *)(a1 + 136)) {
    goto LABEL_3;
  }
  uint64_t v11 = *(void *)(a1 + 64);
  uint64_t v20 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t *))(*(void *)v11 + 120))(v11, *(unsigned int *)(a1 + 128), 8, &v20);
  unsigned int v21 = result;
  if (result) {
    return result;
  }
  if (*(_DWORD *)(a1 + 144))
  {
    uint64_t v12 = v20;
    if ((*(_DWORD *)(v20 + 8) & 0x3FFFFFE) == 0)
    {
LABEL_29:
      *(void *)(a1 + 136) = v12;
LABEL_3:
      uint64_t v6 = OOCAllocator_Malloc(*(void *)(a1 + 24), 16 * a2, &v21);
      uint64_t result = v21;
      if (!v21)
      {
        uint64_t v8 = 0;
        do
        {
          int v9 = *a3++;
          uint64_t v10 = v6 + v8;
          *(_DWORD *)uint64_t v10 = v9;
          *(void *)(v10 + 4) = 0x100000001;
          *(_DWORD *)(v10 + 12) = 0;
          v8 += 16;
        }
        while (16 * a2 != v8);
        uint64_t result = FSTState_AddArcs(*(void *)(a1 + 136), 2, v6, a2);
        unsigned int v21 = result;
        if (!result)
        {
          OOCAllocator_Free(*(void *)(a1 + 24), v6);
          return v21;
        }
      }
      return result;
    }
    uint64_t v19 = 0;
    uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v19);
    if (result) {
      return result;
    }
    uint64_t result = FSTState_Copy(v19, v20);
    if (result) {
      return result;
    }
    int v13 = *(_DWORD *)(v20 + 8);
    *(_DWORD *)(v20 + 8) = v13 - 1;
    int v14 = v13 & 0x3FFFFFF;
    uint64_t result = 9;
    int v15 = (v13 & 0x3FFFFFF) != 0 ? 0 : 9;
    unsigned int v21 = v15;
    if (!v14) {
      return result;
    }
LABEL_28:
    uint64_t v12 = v19;
    goto LABEL_29;
  }
  uint64_t v19 = 0;
  uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v19);
  if (result) {
    return result;
  }
  uint64_t v16 = v20;
  uint64_t v12 = v19;
  *(_DWORD *)(v19 + 8) |= *(_DWORD *)(v20 + 8) & 0xF0000000 | 0x20000000;
  *(_DWORD *)(v12 + 24) = *(_DWORD *)(a1 + 128);
  *(_DWORD *)(v12 + 28) = *(_DWORD *)(v16 + 28);
  int v17 = *(_DWORD *)(v16 + 8);
  if ((v17 & 0x3FFFFFF) != 1)
  {
    *(_DWORD *)(v16 + 8) = v17 - 1;
    if ((v17 & 0x3FFFFFF) == 0) {
      return 9;
    }
    unsigned int v21 = 0;
    goto LABEL_29;
  }
  if ((v17 & 0x8000000) != 0) {
    uint64_t v18 = *(void *)(v16 + 16);
  }
  else {
    uint64_t v18 = 0;
  }
  uint64_t result = FSTStatePool_PushFSTState(v18, v16);
  unsigned int v21 = result;
  if (!result) {
    goto LABEL_28;
  }
  return result;
}

uint64_t FSTPartial_CheckFlagsOfModifiedState(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int *a7)
{
  if (*(_DWORD *)(a1 + 128) == a2) {
    goto LABEL_2;
  }
  int v14 = (unsigned int *)(*(void *)(a1 + 80)
                       + 4 * (a2 % ((*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2)));
  do
  {
    unsigned int v15 = *v14;
    if ((*v14 & 0x80000000) != 0) {
      goto LABEL_22;
    }
    int v14 = (unsigned int *)(*(void *)(a1 + 104) + 12 * v15);
  }
  while (v14[1] != a2);
  if (a4 | a3)
  {
    unsigned int v26 = 0;
    uint64_t result = __FSTPartial_GetCompressedFlags(a1, a2, v15, &v26);
    if (result) {
      return result;
    }
    unsigned int v17 = (v26 << 24) & 0xFE000000;
    BOOL v18 = (v17 & a3) != 0 || a3 == 0;
    BOOL v19 = v18;
    BOOL v20 = (v17 & a4) == 0 || a4 == 0;
    if (!v20 || !v19)
    {
LABEL_22:
      int v8 = 0;
      goto LABEL_31;
    }
  }
  if (!(a6 | a5))
  {
LABEL_2:
    int v8 = 1;
  }
  else
  {
    int v22 = *(_DWORD *)(*(void *)(a1 + 104) + 12 * v15 + 8);
    int v23 = (a5 == 0) | v22;
    BOOL v25 = (v22 & 1) == 0 || a6 == 0;
    int v8 = v25 & v23;
  }
LABEL_31:
  uint64_t result = 0;
  *a7 = v8;
  return result;
}

uint64_t __FSTPartial_GetCompressedFlags(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int *a4)
{
  unsigned int v5 = *(_DWORD *)(*(void *)(a1 + 104) + 12 * a3 + 8);
  if ((v5 & 0x80000000) != 0)
  {
    int v10 = 0;
    uint64_t result = (*(uint64_t (**)(void, uint64_t, int *))(**(void **)(a1 + 64) + 56))(*(void *)(a1 + 64), a2, &v10);
    if (!result)
    {
      unsigned int v9 = v5 & 1 | ((v10 & ~(v5 << 8) | (v5 << 16)) >> 24);
      *(_DWORD *)(*(void *)(a1 + 104) + 12 * a3 + 8) = v9;
      *a4 = v9;
    }
  }
  else
  {
    uint64_t result = 0;
    *a4 = v5;
  }
  return result;
}

uint64_t FSTPartial_ClearModifiedStates(uint64_t a1)
{
  unsigned int v9 = 0;
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2) {
    OOCAllocator_Free(*(void *)(a1 + 24), v2);
  }
  uint64_t v3 = *(void *)(a1 + 104);
  if (v3) {
    OOCAllocator_Free(*(void *)(a1 + 24), v3);
  }
  *(_DWORD *)(a1 + 72) = 1;
  uint64_t v4 = OOCAllocator_Malloc(*(void *)(a1 + 24), 4, &v9);
  *(void *)(a1 + 80) = v4;
  uint64_t v5 = v9;
  if (!v9)
  {
    uint64_t v6 = *(unsigned int *)(a1 + 72);
    unint64_t v7 = v4 + 4 * v6;
    *(void *)(a1 + 88) = v7;
    if (v6)
    {
      if (v7 <= v4 + 4) {
        unint64_t v7 = v4 + 4;
      }
      memset((void *)v4, 255, ((v7 + ~v4) & 0xFFFFFFFFFFFFFFFCLL) + 4);
      uint64_t v5 = v9;
    }
    else
    {
      uint64_t v5 = 0;
    }
    *(_DWORD *)(a1 + 96) = 0;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 112) = 0;
    *(_DWORD *)(a1 + 120) = -1;
  }
  return v5;
}

uint64_t FSTPartial_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v25 = 0;
  uint64_t v8 = *(void *)(a1 + 64);
  if (*(_DWORD *)(a1 + 128) != a2) {
    goto LABEL_6;
  }
  uint64_t v9 = *(void *)(a1 + 136);
  if (v9)
  {
    uint64_t v25 = *(void *)(a1 + 136);
    if (FST_CheckQuery(*(_DWORD *)(v9 + 8) & 0xF0000000, a3)) {
      ++*(_DWORD *)(v9 + 8);
    }
    else {
LABEL_24:
    }
      uint64_t v25 = 0;
    goto LABEL_25;
  }
  if (*(_DWORD *)(a1 + 144))
  {
LABEL_6:
    int v10 = (unsigned int *)(*(void *)(a1 + 80)
                         + 4 * (a2 % ((*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2)));
    do
    {
      unsigned int v11 = *v10;
      if ((*v10 & 0x80000000) != 0)
      {
        uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(*(void *)v8 + 120))(*(void *)(a1 + 64), a2, a3, &v25);
        if (result) {
          return result;
        }
        goto LABEL_25;
      }
      int v10 = (unsigned int *)(*(void *)(a1 + 104) + 12 * v11);
    }
    while (v10[1] != a2);
    unsigned int v23 = 0;
    uint64_t result = __FSTPartial_GetCompressedFlags(a1, a2, v11, &v23);
    if (result) {
      return result;
    }
    char v13 = v23;
    signed int v14 = v23 << 24;
    unsigned int v15 = (v23 << 24) & 0xFE000000;
    if (!FST_CheckQuery(v15, a3)) {
      goto LABEL_24;
    }
    if (v14 >= 0) {
      int v16 = 0x7FFFFFFF;
    }
    else {
      int v16 = 0;
    }
    if ((v13 & 1) == 0)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)v8 + 120))(v8, a2, 8, &v25);
      if (result) {
        return result;
      }
      uint64_t v17 = v25;
      int v18 = *(_DWORD *)(v25 + 8);
      if ((v18 & 0x3FFFFFE) == 0) {
        goto LABEL_21;
      }
      uint64_t v24 = 0;
      uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v24);
      if (!result)
      {
        uint64_t result = FSTState_Copy(v24, v25);
        if (!result)
        {
          int v19 = *(_DWORD *)(v25 + 8);
          *(_DWORD *)(v25 + 8) = v19 - 1;
          if ((v19 & 0x3FFFFFF) != 0)
          {
            uint64_t v17 = v24;
            uint64_t v25 = v24;
            int v18 = *(_DWORD *)(v24 + 8);
LABEL_21:
            *(_DWORD *)(v17 + 8) = v18 & 0xFFFFFFF | v15;
            *(_DWORD *)(v17 + 28) = v16;
            goto LABEL_25;
          }
          return 9;
        }
      }
      return result;
    }
    uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v25);
    LODWORD(v24) = result;
    if (result) {
      return result;
    }
    uint64_t v21 = v25;
    *(_DWORD *)(v25 + 8) |= v15;
    *(_DWORD *)(v21 + 24) = a2;
    *(_DWORD *)(v21 + 28) = v16;
    if ((v13 & 0x40) != 0)
    {
      int v22 = *(_DWORD **)(v21 + 56);
      if (!v22 || *(v22 - 1) <= 1u)
      {
        int v22 = (_DWORD *)_FSTState_ReserveArcsInternal(v21, 1u, &v24);
        uint64_t result = v24;
        if (v24) {
          return result;
        }
      }
      *(_DWORD *)(v25 + 48) = 1;
      uint64_t result = FSTArc_Con(v22, a2, 0, 0, 0);
      if (result) {
        return result;
      }
    }
    goto LABEL_25;
  }
  uint64_t v24 = 0;
  uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v24);
  if (!result)
  {
    uint64_t v20 = v24;
    *(_DWORD *)(v24 + 24) = a2;
    uint64_t v25 = v20;
LABEL_25:
    uint64_t result = 0;
    *a4 = v25;
  }
  return result;
}

uint64_t FSTPartial_FillBuffer(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 80))(*(void *)(a1 + 64));
}

uint64_t FSTPartial_GetFinalStateWeight(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v4 = (unsigned int *)(*(void *)(a1 + 80)
                      + 4 * (a2 % ((*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2)));
  while (1)
  {
    unsigned int v5 = *v4;
    if ((*v4 & 0x80000000) != 0) {
      break;
    }
    uint64_t v4 = (unsigned int *)(*(void *)(a1 + 104) + 12 * v5);
    if (v4[1] == a2)
    {
      unsigned int v9 = 0;
      uint64_t result = __FSTPartial_GetCompressedFlags(a1, a2, v5, &v9);
      if (!result)
      {
        if ((v9 & 0x80) != 0) {
          int v7 = 0;
        }
        else {
          int v7 = 0x7FFFFFFF;
        }
        *a3 = v7;
      }
      return result;
    }
  }
  uint64_t v8 = *(uint64_t (**)(void))(**(void **)(a1 + 64) + 64);

  return v8();
}

uint64_t FSTPartial_GetInitialStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 128);
  uint64_t v2 = *(void *)(a1 + 136);
  if (v2 && *(_DWORD *)(v2 + 32) == 1) {
    *a2 = **(_DWORD **)(v2 + 40);
  }
  return 0;
}

uint64_t FSTPartial_GetMemoryInfo(uint64_t a1)
{
  return FSTUnaryOperator_GetMemoryInfo(a1) + 4 * *(unsigned int *)(a1 + 72) + 12 * *(unsigned int *)(a1 + 96) + 80;
}

uint64_t FSTPartial_GetStateFlags(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  if (*(_DWORD *)(a1 + 128) == a2 && (uint64_t v4 = *(void *)(a1 + 136)) != 0)
  {
    uint64_t result = 0;
    unsigned int v6 = *(_DWORD *)(v4 + 8) & 0xF0000000;
  }
  else
  {
    int v7 = (unsigned int *)(*(void *)(a1 + 80)
                        + 4 * (a2 % ((*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2)));
    do
    {
      unsigned int v8 = *v7;
      if ((*v7 & 0x80000000) != 0)
      {
        unsigned int v9 = *(uint64_t (**)(void))(**(void **)(a1 + 64) + 56);
        return v9();
      }
      int v7 = (unsigned int *)(*(void *)(a1 + 104) + 12 * v8);
    }
    while (v7[1] != a2);
    unsigned int v10 = 0;
    uint64_t result = __FSTPartial_GetCompressedFlags(a1, a2, v8, &v10);
    if (result) {
      return result;
    }
    unsigned int v6 = (v10 << 24) & 0xFE000000;
  }
  *a3 = v6;
  return result;
}

uint64_t FSTPartial_ModifyState(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  unsigned int v41 = 0;
  unsigned int v10 = *(_DWORD **)(a1 + 80);
  unint64_t v11 = *(void *)(a1 + 88) - (void)v10;
  uint64_t v12 = a2 % (v11 >> 2);
  char v13 = &v10[v12];
  while (1)
  {
    unsigned int v14 = *v13;
    if ((*v13 & 0x80000000) != 0) {
      break;
    }
    uint64_t v15 = *(void *)(a1 + 104);
    char v13 = (unsigned int *)(v15 + 12 * v14);
    if (v13[1] == a2) {
      goto LABEL_37;
    }
  }
  unsigned int v16 = *(_DWORD *)(a1 + 120);
  if (v16 != -1)
  {
    unsigned int v17 = *(_DWORD *)(a1 + 120);
    uint64_t v15 = *(void *)(a1 + 104);
    int v18 = (_DWORD *)(v15 + 12 * (int)v16);
    *(_DWORD *)(a1 + 120) = (*v18 & 0xBFFFFFFF) - 1;
    *int v18 = 0;
    v18[1] = a2;
    _OWORD v18[2] = 0;
LABEL_35:
    *(_DWORD *)(v15 + 12 * (int)v17) = v10[v12];
    v10[v12] = v16;
    if ((v16 & 0x80000000) != 0) {
      return v41;
    }
    unsigned int v14 = v16;
LABEL_37:
    if (a5) {
      unsigned int v39 = -2147483647;
    }
    else {
      unsigned int v39 = 0x80000000;
    }
    *(_DWORD *)(v15 + 12 * v14 + 8) = HIWORD(a4) & 0xFF00 | (HIBYTE(a3) << 16) | v39;
    return v41;
  }
  uint64_t v15 = *(void *)(a1 + 104);
  int v19 = *(_DWORD **)(a1 + 112);
  uint64_t v20 = ((uint64_t)v19 - v15) >> 2;
  unsigned int v16 = -1431655765 * v20;
  unsigned int v21 = 2 * (v11 >> 2);
  if (v21 >= -1431655765 * (int)v20)
  {
    unsigned int v27 = -1431655765 * v20;
  }
  else
  {
    unsigned int v22 = v21 | 1;
    uint64_t v23 = *(unsigned int *)(a1 + 72);
    if (v22 <= v23)
    {
      uint64_t v25 = 4 * v23;
    }
    else
    {
      if (v22 <= 8) {
        unsigned int v24 = 8;
      }
      else {
        unsigned int v24 = v22;
      }
      uint64_t v25 = 4 * v24;
      uint64_t v26 = OOCAllocator_Realloc(*(void *)(a1 + 24), (uint64_t)v10, v25, &v41);
      *(void *)(a1 + 80) = v26;
      if (v41) {
        return v41;
      }
      unsigned int v10 = (_DWORD *)v26;
      *(_DWORD *)(a1 + 72) = v24;
      v11 &= 0x3FFFFFFFCuLL;
    }
    unint64_t v28 = (v11 >> 1) & 0xFFFFFFFE | 1;
    *(void *)(a1 + 88) = &v10[v28];
    cstdlib_memset(v10, 255, v25);
    uint64_t v15 = *(void *)(a1 + 104);
    int v19 = *(_DWORD **)(a1 + 112);
    unsigned int v27 = -1431655765 * (((uint64_t)v19 - v15) >> 2);
    if (v27)
    {
      uint64_t v29 = 0;
      unsigned int v30 = *(_DWORD **)(a1 + 104);
      do
      {
        if (((*v30 + 1) & 0x40000000) == 0)
        {
          if (v41) {
            return v41;
          }
          unint64_t v31 = v30[1] - (v30[1] / v28) * (unint64_t)v28;
          uint64_t v32 = *(void *)(a1 + 80);
          *unsigned int v30 = *(_DWORD *)(v32 + 4 * v31);
          *(_DWORD *)(v32 + 4 * v31) = v29;
        }
        ++v29;
        v30 += 3;
      }
      while (-1431655765 * (((uint64_t)v19 - v15) >> 2) != v29);
      unsigned int v16 = -1431655765 * (((uint64_t)v19 - v15) >> 2);
    }
    else
    {
      unsigned int v16 = 0;
    }
  }
  unsigned int v33 = v16 + 1;
  unsigned int v34 = *(_DWORD *)(a1 + 96);
  if (v16 + 1 <= v34)
  {
LABEL_34:
    *(void *)(a1 + 112) = v19 + 3;
    _DWORD *v19 = 0;
    v19[1] = a2;
    _OWORD v19[2] = 0;
    unsigned int v10 = *(_DWORD **)(a1 + 80);
    uint64_t v12 = a2 % ((*(void *)(a1 + 88) - (void)v10) >> 2);
    unsigned int v17 = v16;
    goto LABEL_35;
  }
  unsigned int v35 = 2 * v34;
  unsigned int v36 = v34 + 1000000;
  if (v35 >= v36) {
    unsigned int v35 = v36;
  }
  if (v35 > v33) {
    unsigned int v33 = v35;
  }
  if (v33 <= 8) {
    unsigned int v37 = 8;
  }
  else {
    unsigned int v37 = v33;
  }
  uint64_t v38 = OOCAllocator_Realloc(*(void *)(a1 + 24), v15, 12 * v37, &v41);
  *(void *)(a1 + 104) = v38;
  if (!v41)
  {
    uint64_t v15 = v38;
    *(_DWORD *)(a1 + 96) = v37;
    int v19 = (_DWORD *)(v38 + 12 * v27);
    goto LABEL_34;
  }
  return v41;
}

uint64_t FSTPartial_Reset(uint64_t a1)
{
  uint64_t result = FSTUnaryOperator_Reset(a1);
  if (!result)
  {
    if (*(void *)(a1 + 136))
    {
      uint64_t v3 = *(void *)(a1 + 64);
      uint64_t v6 = 0;
      uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t *))(*(void *)v3 + 120))(v3, *(unsigned int *)(a1 + 128), 8, &v6);
      if (!result)
      {
        int v4 = *(_DWORD *)(v6 + 8);
        if ((v4 & 0x3FFFFFF) == 1)
        {
          if ((v4 & 0x8000000) != 0) {
            uint64_t v5 = *(void *)(v6 + 16);
          }
          else {
            uint64_t v5 = 0;
          }
          return FSTStatePool_PushFSTState(v5, v6);
        }
        else
        {
          *(_DWORD *)(v6 + 8) = v4 - 1;
          if ((v4 & 0x3FFFFFF) != 0) {
            return 0;
          }
          else {
            return 9;
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *GetFSTPartialClass()
{
  return &__FSTPartial;
}

uint64_t FSTRmEpsilonLocalDfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = FSTDfsContext_Con(a1, a2, a3);
  if (!result)
  {
    *(void *)a1 = &__FSTRmEpsilonLocalDfsContext;
    *(void *)(a1 + 48) = 0x100000001;
    *(_DWORD *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    *(_DWORD *)(a1 + 88) = 0;
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 104) = 0;
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 48);
    return v6(a3, a1 + 112);
  }
  return result;
}

uint64_t FSTRmEpsilonLocalDfsContext_Des(uint64_t *a1)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a1[9];
  if (v3) {
    OOCAllocator_Free(a1[1], v3);
  }
  uint64_t v4 = a1[12];
  if (v4) {
    OOCAllocator_Free(v2, v4);
  }

  return FSTDfsContext_Des((uint64_t)a1);
}

uint64_t FSTRmEpsilonLocalDfsContext_DiscoverState(uint64_t a1, uint64_t a2)
{
  unsigned int v29 = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = (*(_DWORD *)(a2 + 24) + 1);
  uint64_t v6 = *(void *)(a1 + 96);
  unint64_t v7 = *(void *)(a1 + 104);
  unint64_t v8 = v7 - v6;
  if (v5 >= ((v7 - v6) >> 2))
  {
    unsigned int v9 = *(_DWORD *)(a1 + 88);
    if (v5 > v9)
    {
      unsigned int v10 = 2 * v9;
      unsigned int v11 = v9 + 1000000;
      if (v10 < v11) {
        unsigned int v11 = v10;
      }
      if (v11 <= v5) {
        unsigned int v11 = v5;
      }
      if (v11 <= 8) {
        unsigned int v12 = 8;
      }
      else {
        unsigned int v12 = v11;
      }
      uint64_t v13 = OOCAllocator_Realloc(*(void *)(a1 + 8), v6, 4 * v12, &v29);
      *(void *)(a1 + 96) = v13;
      if (v29) {
        return v29;
      }
      uint64_t v6 = v13;
      *(_DWORD *)(a1 + 88) = v12;
      unint64_t v7 = v13 + (v8 & 0x3FFFFFFFCLL);
      *(void *)(a1 + 104) = v7;
    }
    if (v7 < v6 + 4 * v5)
    {
      unint64_t v14 = v6 + 4 * v5;
      if (v14 <= v7 + 4) {
        unint64_t v14 = v7 + 4;
      }
      size_t v15 = ((v14 + ~v7) & 0xFFFFFFFFFFFFFFFCLL) + 4;
      bzero((void *)v7, v15);
      *(void *)(a1 + 104) = v7 + v15;
    }
  }
  uint64_t v16 = (*(_DWORD *)(a2 + 24) + 1);
  uint64_t v17 = *(void *)(a1 + 72);
  unint64_t v18 = *(void *)(a1 + 80);
  unint64_t v19 = v18 - v17;
  if (v16 < ((v18 - v17) >> 2))
  {
LABEL_31:
    uint64_t v27 = *(unsigned int *)(a1 + 112);
    if (v27 == *(_DWORD *)(a2 + 24)) {
      ++*(_DWORD *)(v17 + 4 * v27);
    }
    if ((*(_DWORD *)(a2 + 8) & 0x80000000) != 0) {
      ++*(_DWORD *)(*(void *)(a1 + 96) + 4 * *(unsigned int *)(a2 + 24));
    }
    return v29;
  }
  unsigned int v20 = *(_DWORD *)(a1 + 64);
  if (v16 <= v20)
  {
LABEL_27:
    if (v18 < v17 + 4 * v16)
    {
      unint64_t v25 = v17 + 4 * v16;
      if (v25 <= v18 + 4) {
        unint64_t v25 = v18 + 4;
      }
      size_t v26 = ((v25 + ~v18) & 0xFFFFFFFFFFFFFFFCLL) + 4;
      bzero((void *)v18, v26);
      *(void *)(a1 + 80) = v18 + v26;
    }
    goto LABEL_31;
  }
  unsigned int v21 = 2 * v20;
  unsigned int v22 = v20 + 1000000;
  if (v21 < v22) {
    unsigned int v22 = v21;
  }
  if (v22 <= v16) {
    unsigned int v22 = *(_DWORD *)(a2 + 24) + 1;
  }
  if (v22 <= 8) {
    unsigned int v23 = 8;
  }
  else {
    unsigned int v23 = v22;
  }
  uint64_t v24 = OOCAllocator_Realloc(v4, *(void *)(a1 + 72), 4 * v23, &v29);
  *(void *)(a1 + 72) = v24;
  if (!v29)
  {
    uint64_t v17 = v24;
    *(_DWORD *)(a1 + 64) = v23;
    unint64_t v18 = v24 + (v19 & 0x3FFFFFFFCLL);
    *(void *)(a1 + 80) = v18;
    goto LABEL_27;
  }
  return v29;
}

uint64_t FSTRmEpsilonLocalDfsContext_ExploreNonTreeArc(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unsigned int v28 = 0;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = a2 + 1;
  uint64_t v8 = *(void *)(a1 + 96);
  unint64_t v9 = *(void *)(a1 + 104);
  unint64_t v10 = v9 - v8;
  if (v7 >= ((v9 - v8) >> 2))
  {
    unsigned int v11 = *(_DWORD *)(a1 + 88);
    if (v7 > v11)
    {
      unsigned int v12 = 2 * v11;
      unsigned int v13 = v11 + 1000000;
      if (v12 < v13) {
        unsigned int v13 = v12;
      }
      if (v13 <= v7) {
        unsigned int v13 = v7;
      }
      if (v13 <= 8) {
        unsigned int v14 = 8;
      }
      else {
        unsigned int v14 = v13;
      }
      uint64_t v8 = OOCAllocator_Realloc(*(void *)(a1 + 8), v8, 4 * v14, &v28);
      *(void *)(a1 + 96) = v8;
      uint64_t result = v28;
      if (v28) {
        return result;
      }
      *(_DWORD *)(a1 + 88) = v14;
      unint64_t v9 = v8 + (v10 & 0x3FFFFFFFCLL);
      *(void *)(a1 + 104) = v9;
    }
    if (v9 < v8 + 4 * v7)
    {
      unint64_t v16 = v8 + 4 * v7;
      if (v16 <= v9 + 4) {
        unint64_t v16 = v9 + 4;
      }
      size_t v17 = ((v16 + ~v9) & 0xFFFFFFFFFFFFFFFCLL) + 4;
      bzero((void *)v9, v17);
      *(void *)(a1 + 104) = v9 + v17;
    }
  }
  uint64_t v18 = (*a3 + 1);
  uint64_t v19 = *(void *)(a1 + 72);
  unint64_t v20 = *(void *)(a1 + 80);
  unint64_t v21 = v20 - v19;
  if (v18 < ((v20 - v19) >> 2))
  {
LABEL_31:
    ++*(_DWORD *)(*(void *)(a1 + 96) + 4 * a2);
    ++*(_DWORD *)(v19 + 4 * *a3);
    return v28;
  }
  unsigned int v22 = *(_DWORD *)(a1 + 64);
  if (v18 <= v22)
  {
LABEL_27:
    if (v20 < v19 + 4 * v18)
    {
      unint64_t v26 = v19 + 4 * v18;
      if (v26 <= v20 + 4) {
        unint64_t v26 = v20 + 4;
      }
      size_t v27 = ((v26 + ~v20) & 0xFFFFFFFFFFFFFFFCLL) + 4;
      bzero((void *)v20, v27);
      *(void *)(a1 + 80) = v20 + v27;
    }
    goto LABEL_31;
  }
  unsigned int v23 = 2 * v22;
  unsigned int v24 = v22 + 1000000;
  if (v23 < v24) {
    unsigned int v24 = v23;
  }
  if (v24 <= v18) {
    unsigned int v24 = *a3 + 1;
  }
  if (v24 <= 8) {
    unsigned int v25 = 8;
  }
  else {
    unsigned int v25 = v24;
  }
  uint64_t v19 = OOCAllocator_Realloc(v6, *(void *)(a1 + 72), 4 * v25, &v28);
  *(void *)(a1 + 72) = v19;
  uint64_t result = v28;
  if (!v28)
  {
    *(_DWORD *)(a1 + 64) = v25;
    unint64_t v20 = v19 + (v21 & 0x3FFFFFFFCLL);
    *(void *)(a1 + 80) = v20;
    goto LABEL_27;
  }
  return result;
}

uint64_t FSTRmEpsilonLocalDfsContext_ExploreTreeArc(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
}

uint64_t PNEW_FSTRmEpsilonLocalDfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 120, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = FSTRmEpsilonLocalDfsContext_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

void *GetFSTRmEpsilonLocalDfsContextClass()
{
  return &__FSTRmEpsilonLocalDfsContext;
}

void fstcompact(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7 = 0;
  PNEW_FSTCompact_ConFromFST(a1, a2, a3, &v7);
  if (!v6 && !(*(unsigned int (**)(uint64_t))(*(void *)a3 + 32))(a3)) {
    *a4 = v7;
  }
}

void PNEW_FSTCompact_ConFromFST(uint64_t a1, uint64_t a2, uint64_t a3, int8x8_t **a4)
{
  int v10 = 0;
  uint64_t v8 = (int8x8_t *)OOCAllocator_Malloc(a1, 176, &v10);
  if (!v10)
  {
    FSTCompact_ConFromFST(v8, a2, a3);
    int v10 = v9;
    if (v9)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
    }
    else
    {
      v8[2] = (int8x8_t)a1;
      *a4 = v8;
    }
  }
}

double FSTCompact_Con(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  *(void *)(a1 + 168) = a5;
  double result = FSTCompact_ConFromBuffers(a1, a2, a3, a4, a4, (const void **)(a1 + 168), a6);
  if (!v8)
  {
    *(void *)a1 = &__FSTCompact;
    *(void *)&double result = *(void *)(a1 + 40) | 0x10000000100;
    *(double *)(a1 + 40) = result;
  }
  return result;
}

double FSTCompact_ConFromBuffers(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, const void **a6, uint64_t a7)
{
  unsigned int v14 = (char *)*a6;
  int v20 = 0;
  unint64_t v19 = 0;
  if (!FST_GetHeaderSizeInInputBuffer(v14, (uint64_t *)&v19))
  {
    if (a5 >= a4) {
      a5 = a4;
    }
    if (a5 < v19 + 24) {
      goto LABEL_5;
    }
    double result = _FSTBaseFlat_Con((void *)a1, a2, a3, a5, v14, a7, 3u);
    if (!v16)
    {
      *(void *)a1 = &__FSTCompact;
      *(void *)(a1 + 136) = 0;
      *(void *)(a1 + 144) = 0;
      *(void *)(a1 + 112) = a5;
      *(void *)(a1 + 120) = a6;
      *(void *)(a1 + 128) = (a4 + a5 - 1) / a5;
      if (!FST_ReadHeader((_DWORD *)a1, v14, &v20, &v19))
      {
        if (*(_DWORD *)(a1 + 32) != 21 || *(_DWORD *)(a1 + 104) != 3)
        {
LABEL_5:
          err_GenerateErrorData();
          return result;
        }
        if ((a5 & 3) != 0 && *(void *)(a1 + 128) >= 2uLL)
        {
          err_GenerateErrorInternal();
        }
        else
        {
          uint64_t v17 = *(void *)&v14[v19 + 16];
          *(void *)&long long v18 = v17;
          *((void *)&v18 + 1) = HIDWORD(v17);
          *(_OWORD *)(a1 + 152) = v18;
          *(void *)&double result = *(void *)(a1 + 40) | 0x10000000100;
          *(double *)(a1 + 40) = result;
        }
      }
    }
  }
  return result;
}

void FSTCompact_ConFromFST(int8x8_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v59 = 0;
  uint64_t __b = 0;
  memset(v58, 0, sizeof(v58));
  int v57 = 0;
  *a1 = (int8x8_t)&__FSTCompact;
  if (!FSTCount(a2, a3, (uint64_t)v58))
  {
    int v6 = v58[0];
    uint64_t v7 = (LODWORD(v58[0]) + 1);
    if (LODWORD(v58[0]) == -1)
    {
      int v8 = 24;
LABEL_29:
      int HeaderSizeInOutputBuffer = FST_GetHeaderSizeInOutputBuffer(&v59);
      if (!HeaderSizeInOutputBuffer)
      {
        uint64_t v18 = 4 * (v6 + 2);
        int v19 = 4 - ((v8 + v59) & 3);
        if (((v8 + v59) & 3) == 0) {
          int v19 = 0;
        }
        uint64_t v20 = (v19 + v8 + v59);
        unint64_t v21 = v18 + v20;
        unsigned int v22 = (char *)OOCAllocator_Malloc(a2, v18 + v20, &HeaderSizeInOutputBuffer);
        if (!HeaderSizeInOutputBuffer)
        {
          a1[4].i32[0] = 21;
          a1[4].i32[1] = *(_DWORD *)(a3 + 36);
          v23.i32[0] = *(_DWORD *)(a3 + 44) & 0x3FFFF & *(_DWORD *)(a3 + 40);
          v23.i32[1] = *(_DWORD *)(a3 + 44) & 0x3FFFF;
          a1[5] = (int8x8_t)(*(void *)&vorr_s8(vand_s8(a1[5], (int8x8_t)0x300000003), v23) | 0x10000000100);
          int HeaderSizeInOutputBuffer = FST_FillHeader(a1, v22, 3, &v59);
          if (!HeaderSizeInOutputBuffer)
          {
            int HeaderSizeInOutputBuffer = (*(uint64_t (**)(uint64_t, int *))(*(void *)a3 + 48))(a3, &v57);
            if (!HeaderSizeInOutputBuffer)
            {
              int v24 = v59;
              unsigned int v25 = &v22[v59];
              int v26 = v57;
              *((_DWORD *)v25 + 1) = 0;
              *((_DWORD *)v25 + 2) = 0;
              *(_DWORD *)unsigned int v25 = v26;
              *((_DWORD *)v25 + 3) = LODWORD(v58[0]) + 1;
              *((_DWORD *)v25 + 4) = v20;
              *((_DWORD *)v25 + 5) = v24 + 24;
              uint64_t v53 = v22;
              size_t v27 = &v22[v20];
              int v28 = v25 + 24;
              uint64_t __b = v25 + 24;
              if (v7)
              {
                uint64_t v29 = 0;
                int v55 = v25 + 24;
                while (1)
                {
                  uint64_t v56 = 0;
                  int HeaderSizeInOutputBuffer = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a3 + 120))(a3, v29, 8, &v56);
                  if (HeaderSizeInOutputBuffer) {
                    break;
                  }
                  uint64_t v30 = v56;
                  int v31 = *(_DWORD *)(v56 + 8);
                  uint64_t v32 = *(unsigned int **)(v56 + 40);
                  uint64_t v33 = *(unsigned int *)(v56 + 32);
                  uint64_t v34 = *(void *)(v56 + 56);
                  uint64_t v35 = *(unsigned int *)(v56 + 48);
                  unsigned int v36 = __b;
                  unsigned int v37 = ((int)__b - v28) / 7;
                  *(_DWORD *)&v27[4 * v29] = v37;
                  if (v37 >> 28)
                  {
                    err_GenerateErrorLimit();
                    return;
                  }
                  unsigned int v38 = v31 & 0xF0000000 | v37;
                  unsigned int v39 = v27;
                  *(_DWORD *)&v27[4 * v29] = v38;
                  if ((v38 & 0x80000000) != 0)
                  {
                    int v40 = *(_DWORD *)(v30 + 28);
                    uint64_t __b = v36 + 1;
                    *unsigned int v36 = HIBYTE(v40);
                    unsigned int v41 = __b;
                    uint64_t __b = (char *)__b + 1;
                    *unsigned int v41 = BYTE2(v40);
                    long long v42 = __b;
                    uint64_t __b = (char *)__b + 1;
                    unsigned char *v42 = BYTE1(v40);
                    long long v43 = __b;
                    uint64_t __b = (char *)__b + 1;
                    unsigned char *v43 = v40;
                  }
                  uint64_t v44 = (unsigned int *)(v34 + 16 * v35);
                  if (v32 != v44)
                  {
                    unsigned int v45 = &v32[4 * v33];
                    do
                    {
                      if (v32 == v45)
                      {
                        if (!*(_DWORD *)(v56 + 48)) {
                          break;
                        }
                        uint64_t v32 = *(unsigned int **)(v56 + 56);
                      }
                      FSTCompactCodec_EncodeArcInc(v32, &__b);
                      v32 += 4;
                    }
                    while (v32 != v44);
                  }
                  int v46 = *(_DWORD *)(v56 + 8);
                  if ((v46 & 0x3FFFFFF) == 1)
                  {
                    size_t v27 = v39;
                    if ((v46 & 0x8000000) != 0) {
                      uint64_t v47 = *(void *)(v56 + 16);
                    }
                    else {
                      uint64_t v47 = 0;
                    }
                    int v28 = v55;
                    int HeaderSizeInOutputBuffer = FSTStatePool_PushFSTState(v47, v56);
                    if (HeaderSizeInOutputBuffer) {
                      return;
                    }
                  }
                  else
                  {
                    *(_DWORD *)(v56 + 8) = v46 - 1;
                    if ((v46 & 0x3FFFFFF) == 0) {
                      return;
                    }
                    size_t v27 = v39;
                    int HeaderSizeInOutputBuffer = 0;
                    int v28 = v55;
                  }
                  unsigned int v48 = (char *)__b;
                  unsigned int v49 = ((int)__b - v28) % 7u;
                  unsigned int v50 = v49 ^ 7;
                  if (v49) {
                    BOOL v51 = v50 == 0;
                  }
                  else {
                    BOOL v51 = 1;
                  }
                  if (!v51)
                  {
                    cstdlib_memset(__b, 255, v49 ^ 7);
                    unsigned int v48 = (char *)__b + v50;
                    uint64_t __b = v48;
                  }
                  if (++v29 == v7) {
                    goto LABEL_63;
                  }
                }
              }
              else
              {
                uint64_t v7 = 0;
                unsigned int v48 = v25 + 24;
LABEL_63:
                if (v48 < v27)
                {
                  cstdlib_memset(v48, 255, (v27 - v48));
                  LODWORD(v48) = __b;
                }
                *(_DWORD *)&v27[4 * v7] = ((int)v48 - v28) / 7u;
                uint64_t v52 = (const void **)OOCAllocator_Malloc(a2, 8, &HeaderSizeInOutputBuffer);
                if (!HeaderSizeInOutputBuffer)
                {
                  *uint64_t v52 = v53;
                  FSTCompact_ConFromBuffers((uint64_t)a1, a2, *(void *)(a3 + 48), v21, v21, v52, a2);
                }
              }
            }
          }
        }
      }
    }
    else
    {
      uint64_t v54 = (LODWORD(v58[0]) + 1);
      unint64_t v9 = 0;
      uint64_t v10 = 0;
      while (1)
      {
        uint64_t v56 = 0;
        int HeaderSizeInOutputBuffer = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a3 + 120))(a3, v10, 8, &v56);
        if (HeaderSizeInOutputBuffer) {
          break;
        }
        uint64_t v11 = v56;
        int v12 = *(_DWORD *)(v56 + 8);
        unsigned int v13 = *(unsigned int **)(v56 + 40);
        uint64_t v14 = *(void *)(v56 + 56) + 16 * *(unsigned int *)(v56 + 48);
        if (v12 < 0) {
          v9 += 4;
        }
        if (v13 != (unsigned int *)v14)
        {
          size_t v15 = &v13[4 * *(unsigned int *)(v56 + 32)];
          do
          {
            if (v13 == v15)
            {
              uint64_t v11 = v56;
              if (!*(_DWORD *)(v56 + 48)) {
                goto LABEL_16;
              }
              unsigned int v13 = *(unsigned int **)(v56 + 56);
            }
            v9 += FSTCompactCodec_GetArcSize(v13);
            v13 += 4;
          }
          while (v13 != (unsigned int *)v14);
          uint64_t v11 = v56;
LABEL_16:
          int v12 = *(_DWORD *)(v11 + 8);
        }
        if ((v12 & 0x3FFFFFF) == 1)
        {
          if ((v12 & 0x8000000) != 0) {
            uint64_t v16 = *(void *)(v11 + 16);
          }
          else {
            uint64_t v16 = 0;
          }
          int HeaderSizeInOutputBuffer = FSTStatePool_PushFSTState(v16, v11);
          if (HeaderSizeInOutputBuffer) {
            return;
          }
        }
        else
        {
          *(_DWORD *)(v11 + 8) = v12 - 1;
          if ((v12 & 0x3FFFFFF) == 0) {
            return;
          }
          int HeaderSizeInOutputBuffer = 0;
        }
        unint64_t v17 = (v9 % 7) ^ 7;
        if (!(v9 % 7)) {
          unint64_t v17 = 0;
        }
        v9 += v17;
        BOOL v51 = v10 == v6;
        uint64_t v10 = (v10 + 1);
        if (v51)
        {
          int v8 = v9 + 24;
          uint64_t v7 = v54;
          goto LABEL_29;
        }
      }
    }
  }
}

uint64_t FSTCompact_Des(uint64_t *a1)
{
  if (a1[12])
  {
    if ((unint64_t)a1[16] >= 2)
    {
      unint64_t v2 = 1;
      do
        OOCAllocator_Free(a1[12], *(void *)(a1[15] + 8 * v2++));
      while (v2 < a1[16]);
    }
    uint64_t v3 = a1[15];
    if ((uint64_t *)v3 != a1 + 21) {
      OOCAllocator_Free(a1[12], v3);
    }
  }
  OOCAllocator_Free(a1[3], a1[17]);

  return FSTBaseFlat_Des((uint64_t)a1);
}

uint64_t FSTCompact_FetchState(uint64_t *a1, unsigned int a2, unsigned int a3, uint64_t *a4)
{
  unint64_t v7 = a1[19] + 4 * a2;
  int v8 = *(_DWORD *)(*(void *)(a1[15] + 8 * (v7 / a1[14])) + v7 % a1[14]);
  unsigned int v9 = v8 & 0xF0000000;
  if (!FST_CheckQuery(v8 & 0xF0000000, a3))
  {
    uint64_t Info = 0;
    *a4 = 0;
    return Info;
  }
  int v28 = 0;
  uint64_t v29 = 0;
  uint64_t v27 = 0;
  uint64_t Info = __FSTCompact_GetInfo(a1, a2, (char **)&v29, &v28);
  if (!Info)
  {
    uint64_t v11 = v29;
    if (v8 < 0)
    {
      uint64_t v11 = v29 + 1;
      unsigned int v12 = bswap32(*v29++);
    }
    else
    {
      unsigned int v12 = 0x7FFFFFFF;
    }
    unsigned int v13 = v28;
    if ((char *)v28 - (char *)v11 <= 6 && *(unsigned __int8 *)v11 == 255)
    {
      unsigned int v15 = 0;
      unsigned int v16 = 0;
      uint64_t v29 = v28;
    }
    else
    {
      *(void *)&long long v26 = v11;
      BOOL v14 = v11 == v28;
      unsigned int v15 = 0;
      unsigned int v16 = 0;
      if (v11 != v28)
      {
        do
        {
          while (1)
          {
            int v17 = FSTCompactCodec_ScanEncodedArc((uint64_t *)&v26);
            unsigned int v18 = v17 ? v16 : v15;
            if (v17) {
              unsigned int v16 = v18 + 1;
            }
            else {
              unsigned int v15 = v18 + 1;
            }
            if ((uint64_t)((uint64_t)v13 - v26) <= 6) {
              break;
            }
            if ((unsigned int *)v26 == v13) {
              goto LABEL_24;
            }
          }
        }
        while ((unsigned int *)v26 != v13 && *(unsigned __int8 *)v26 != 255);
LABEL_24:
        uint64_t Info = FSTStatePool_PopFSTState(a1[6], &v27);
        unsigned int v30 = Info;
        if (Info) {
          return Info;
        }
        uint64_t v19 = v27;
        *(_DWORD *)(v27 + 8) |= v9;
        *(_DWORD *)(v19 + 24) = a2;
        *(_DWORD *)(v19 + 28) = v12;
        if (v16)
        {
          uint64_t v20 = *(_OWORD **)(v19 + 40);
          if (!v20 || *((_DWORD *)v20 - 1) <= v16)
          {
            uint64_t v21 = _FSTState_ReserveEpsilonArcsInternal(v19, v16, &v30);
            uint64_t Info = v30;
            if (v30) {
              return Info;
            }
            uint64_t v20 = (_OWORD *)v21;
          }
          uint64_t v19 = v27;
          if (v15) {
            goto LABEL_31;
          }
        }
        else
        {
          uint64_t v20 = 0;
          if (v15)
          {
LABEL_31:
            unsigned int v22 = *(_OWORD **)(v19 + 56);
            if (!v22 || *((_DWORD *)v22 - 1) <= v15)
            {
              uint64_t v23 = _FSTState_ReserveArcsInternal(v19, v15, &v30);
              uint64_t Info = v30;
              if (v30) {
                return Info;
              }
              unsigned int v22 = (_OWORD *)v23;
            }
            uint64_t v19 = v27;
            goto LABEL_38;
          }
        }
        unsigned int v22 = 0;
LABEL_38:
        *(_DWORD *)(v19 + 32) = v16;
        *(_DWORD *)(v19 + 48) = v15;
        if (v14)
        {
          uint64_t Info = 0;
          goto LABEL_50;
        }
        while (1)
        {
          long long v26 = 0uLL;
          FSTCompactCodec_DecodeArcInc((int *)&v26, &v29);
          if (v20)
          {
            if (DWORD1(v26) == -2) {
              break;
            }
          }
          if (v22)
          {
            int v24 = v22++;
            goto LABEL_45;
          }
LABEL_46:
          if ((char *)v13 - (char *)v29 <= 6 && *(unsigned __int8 *)v29 == 255 || v29 == v13)
          {
            uint64_t v19 = v27;
            uint64_t Info = v30;
LABEL_50:
            *a4 = v19;
            return Info;
          }
        }
        int v24 = v20++;
LABEL_45:
        *int v24 = v26;
        goto LABEL_46;
      }
    }
    BOOL v14 = 1;
    goto LABEL_24;
  }
  return Info;
}

uint64_t __FSTCompact_GetInfo(uint64_t *a1, unsigned int a2, char **a3, void *a4)
{
  unsigned int v21 = 0;
  uint64_t v6 = a1[19];
  uint64_t v7 = a1[20];
  unint64_t v8 = a1[14];
  uint64_t v9 = a1[15];
  uint64_t v10 = 7
      * (*(_DWORD *)(*(void *)(v9 + 8 * ((v6 + 4 * (unint64_t)a2) / v8)) + (v6 + 4 * (unint64_t)a2) % v8) & 0xFFFFFFF);
  uint64_t v11 = 7
      * (*(_DWORD *)(*(void *)(v9 + 8 * ((v6 + 4 * (unint64_t)(a2 + 1)) / v8))
                   + (v6 + 4 * (unint64_t)(a2 + 1)) % v8) & 0xFFFFFFF);
  uint64_t v12 = v7 + v10;
  unint64_t v13 = (v7 + v10) / v8;
  unint64_t v14 = (v7 + v11) / v8;
  unint64_t v15 = v11 - v10;
  unsigned int v16 = (char *)(*(void *)(v9 + 8 * v13) + (v7 + v10) % v8);
  *a3 = v16;
  if (v13 == v14)
  {
    uint64_t result = 0;
  }
  else
  {
    if (v15 <= a1[18])
    {
      uint64_t v19 = (void *)a1[17];
    }
    else
    {
      a1[18] = v15;
      OOCAllocator_Free(a1[3], a1[17]);
      uint64_t v19 = (void *)OOCAllocator_Malloc(a1[3], v15, &v21);
      a1[17] = (uint64_t)v19;
      uint64_t result = v21;
      if (v21) {
        return result;
      }
      unint64_t v8 = a1[14];
      unsigned int v16 = *a3;
    }
    size_t v20 = v8 + v8 * v13 - v12;
    cstdlib_memcpy(v19, v16, v20);
    if (v15 - v20 > a1[14]) {
      return err_GenerateErrorInternal();
    }
    cstdlib_memcpy((void *)(a1[17] + v20), *(const void **)(a1[15] + 8 * v14), v15 - v20);
    unsigned int v16 = (char *)a1[17];
    *a3 = v16;
    uint64_t result = v21;
  }
  *a4 = &v16[v15];
  return result;
}

uint64_t FSTCompact_FillBuffer(uint64_t a1, char *a2, unint64_t *a3)
{
  uint64_t v6 = *(void *)(a1 + 80) - 16;
  uint64_t v16 = 0;
  uint64_t v17 = v6;
  uint64_t result = (uint64_t)FST_GetHeaderSizeInInputBuffer(**(const void ***)(a1 + 120), &v17);
  if (!result)
  {
    uint64_t result = FST_GetHeaderSizeInOutputBuffer(&v16);
    if (!result)
    {
      unint64_t v8 = *(void *)(a1 + 72) - v17 + v16;
      if (a2 && *a3 >= v8)
      {
        uint64_t result = FST_FillHeader((_DWORD *)a1, a2, *(_DWORD *)(a1 + 104), &v16);
        if (result) {
          return result;
        }
        uint64_t v9 = &a2[v16];
        uint64_t v10 = (const void *)(**(void **)(a1 + 120) + v17);
        if (*(void *)(a1 + 128) == 1)
        {
          size_t v11 = *(void *)(a1 + 72) - v17;
        }
        else
        {
          cstdlib_memcpy(v9, v10, *(void *)(a1 + 112) - v17);
          size_t v12 = *(void *)(a1 + 112);
          unint64_t v13 = &a2[v12 + v16 - v17];
          unint64_t v14 = *(void *)(a1 + 128) - 1;
          unint64_t v15 = 1;
          if (v14 >= 2)
          {
            do
            {
              cstdlib_memcpy(v13, *(const void **)(*(void *)(a1 + 120) + 8 * v15), v12);
              size_t v12 = *(void *)(a1 + 112);
              v13 += v12;
              ++v15;
              unint64_t v14 = *(void *)(a1 + 128) - 1;
            }
            while (v15 < v14);
          }
          uint64_t v10 = *(const void **)(*(void *)(a1 + 120) + 8 * v15);
          size_t v11 = *(void *)(a1 + 72) - v12 * v14;
          uint64_t v9 = v13;
        }
        cstdlib_memcpy(v9, v10, v11);
      }
      uint64_t result = 0;
      *a3 = v8;
    }
  }
  return result;
}

uint64_t FSTCompact_GetFinalStateWeight(uint64_t *a1, unsigned int a2, unsigned int *a3)
{
  unint64_t v4 = a1[19] + 4 * a2;
  if ((*(_DWORD *)(*(void *)(a1[15] + 8 * (v4 / a1[14])) + v4 % a1[14]) & 0x80000000) == 0)
  {
    uint64_t result = 0;
    unsigned int v6 = 0x7FFFFFFF;
LABEL_3:
    *a3 = v6;
    return result;
  }
  unint64_t v8 = 0;
  uint64_t result = __FSTCompact_GetInfo(a1, a2, &v8, &v7);
  if (!result)
  {
    unsigned int v6 = bswap32(*(_DWORD *)v8);
    goto LABEL_3;
  }
  return result;
}

uint64_t FSTCompact_GetStateFlags(void *a1, unsigned int a2, unsigned int *a3)
{
  unint64_t v3 = a1[19] + 4 * a2;
  *a3 = *(_DWORD *)(*(void *)(a1[15] + 8 * (v3 / a1[14])) + v3 % a1[14]) & 0xF0000000;
  return 0;
}

void PNEW_FSTCompact_Con(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  int v16 = 0;
  uint64_t v14 = OOCAllocator_Malloc(a1, 176, &v16);
  if (!v16)
  {
    FSTCompact_Con(v14, a2, a3, a4, a5, a6);
    int v16 = v15;
    if (v15)
    {
      OOCAllocator_Free(a1, v14);
      *a7 = 0;
    }
    else
    {
      *(void *)(v14 + 16) = a1;
      *a7 = v14;
    }
  }
}

void PNEW_FSTCompact_ConFromBuffers(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, const void **a6, uint64_t a7, uint64_t *a8)
{
  int v18 = 0;
  uint64_t v16 = OOCAllocator_Malloc(a1, 176, &v18);
  if (!v18)
  {
    FSTCompact_ConFromBuffers(v16, a2, a3, a4, a5, a6, a7);
    int v18 = v17;
    if (v17)
    {
      OOCAllocator_Free(a1, v16);
      *a8 = 0;
    }
    else
    {
      *(void *)(v16 + 16) = a1;
      *a8 = v16;
    }
  }
}

void *GetFSTCompactClass()
{
  return &__FSTCompact;
}

uint64_t fstsort(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5)
{
  int v12 = 0;
  uint64_t result = FSTSort_TypeToProperty(a4, &v13);
  if (!result)
  {
    uint64_t result = FST_QueryProperties(a3, 1024, &v12);
    if (!result)
    {
      if (v12)
      {
        uint64_t result = 0;
        *a5 = a3;
      }
      else
      {
        size_t v11 = 0;
        uint64_t result = PNEW_FSTSort_Con(a1, a2, a3, a4, &v11);
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 32))(a3);
          if (!result) {
            *a5 = (uint64_t)v11;
          }
        }
      }
    }
  }
  return result;
}

uint64_t FSTSort_TypeToProperty(int a1, int *a2)
{
  if (a1 <= 32)
  {
    if (a1 > 3)
    {
      if (a1 == 4)
      {
        int v2 = 4;
        goto LABEL_22;
      }
      if (a1 == 17)
      {
        int v2 = 8;
        goto LABEL_22;
      }
    }
    else
    {
      if (a1 == 1)
      {
        int v2 = 1;
        goto LABEL_22;
      }
      if (a1 == 2)
      {
        int v2 = 2;
        goto LABEL_22;
      }
    }
  }
  else if (a1 <= 272)
  {
    if (a1 == 33)
    {
      int v2 = 128;
      goto LABEL_22;
    }
    if (a1 == 209)
    {
      int v2 = 16;
      goto LABEL_22;
    }
  }
  else
  {
    switch(a1)
    {
      case 273:
        int v2 = 32;
        goto LABEL_22;
      case 2201:
        int v2 = 0x20000;
        goto LABEL_22;
      case 2257:
        int v2 = 64;
LABEL_22:
        *a2 = v2;
        return 0;
    }
  }
  return err_GenerateErrorNotSupported();
}

uint64_t PNEW_FSTSort_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int8x8_t **a5)
{
  unsigned int v12 = 0;
  uint64_t v10 = (int8x8_t *)OOCAllocator_Malloc(a1, 80, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = FSTSort_Con(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      v10[2] = (int8x8_t)a1;
      *a5 = v10;
    }
  }
  return result;
}

uint64_t FSTSort_Con(int8x8_t *a1, uint64_t a2, uint64_t a3, int a4)
{
  int v11 = 0;
  uint64_t result = _FSTUnaryOperator_Con((uint64_t)a1, a2, a3);
  if (!result)
  {
    *a1 = (int8x8_t)&__FSTSort;
    a1[4].i32[0] = 5;
    uint64_t result = FSTSort_TypeToProperty(a4, &v11);
    if (!result)
    {
      unsigned int v8 = v11;
      if (v11 <= 31)
      {
        uint64_t v9 = FSTArcIsTargetLess;
        switch(v11)
        {
          case 1:
            uint64_t v10 = FSTArcIsInputLess;
            goto LABEL_22;
          case 2:
            uint64_t v10 = FSTArcIsOutputLess;
            goto LABEL_22;
          case 3:
          case 5:
          case 6:
          case 7:
            goto LABEL_15;
          case 4:
            goto LABEL_23;
          case 8:
            unsigned int v8 = 9;
            uint64_t v10 = FSTArcIsInputAndOutputLess;
            goto LABEL_22;
          default:
            if (v11 != 16) {
              goto LABEL_15;
            }
            unsigned int v8 = 25;
            uint64_t v10 = FSTArcIsInputAndOutputAndWeightLess;
            break;
        }
        goto LABEL_22;
      }
      if (v11 > 127)
      {
        if (v11 == 128)
        {
          unsigned int v8 = 129;
          uint64_t v10 = FSTArcIsInputAndTargetLess;
          goto LABEL_22;
        }
        if (v11 == 0x20000)
        {
          uint64_t v9 = FSTArcIsInputAndWeightAndOutputAndTargetLess;
          unsigned int v8 = 131073;
LABEL_23:
          a1[9] = (int8x8_t)v9;
          _FSTUnaryOperator_InheritProperties(a1, a3, v8, 256, v8 ^ 0x200FF, 130560);
          return 0;
        }
      }
      else
      {
        if (v11 == 32)
        {
          unsigned int v8 = 41;
          uint64_t v10 = FSTArcIsInputAndOutputAndTargetLess;
          goto LABEL_22;
        }
        if (v11 == 64)
        {
          unsigned int v8 = 89;
          uint64_t v10 = FSTArcIsInputAndOutputAndWeightAndTargetLess;
LABEL_22:
          uint64_t v9 = (uint64_t (*)(_DWORD *, _DWORD *))v10;
          goto LABEL_23;
        }
      }
LABEL_15:
      a1[9] = 0;
      return err_GenerateErrorNotSupported();
    }
  }
  return result;
}

uint64_t FSTArcIsTargetLess(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

uint64_t FSTArcIsInputAndOutputLess(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 4);
  int v3 = *(_DWORD *)(a2 + 4);
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  if (v2 > v3) {
    return 1;
  }
  int v5 = *(_DWORD *)(a1 + 8);
  int v6 = *(_DWORD *)(a2 + 8);
  BOOL v7 = v5 < v6;
  BOOL v8 = v5 > v6;
  if (v7) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v8;
  }
}

uint64_t FSTArcIsInputAndOutputAndWeightLess(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[1];
  int v3 = a2[1];
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  if (v2 > v3) {
    return 1;
  }
  int v4 = a1[2];
  int v5 = a2[2];
  if (v4 < v5) {
    return 0xFFFFFFFFLL;
  }
  if (v4 > v5) {
    return 1;
  }
  int v7 = a1[3];
  int v8 = a2[3];
  BOOL v10 = __OFSUB__(v7, v8);
  BOOL v9 = v7 - v8 < 0;
  BOOL v11 = v7 > v8;
  if (v9 != v10) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v11;
  }
}

uint64_t FSTArcIsInputAndOutputAndTargetLess(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[1];
  int v3 = a2[1];
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  if (v2 > v3) {
    return 1;
  }
  int v4 = a1[2];
  int v5 = a2[2];
  if (v4 < v5) {
    return 0xFFFFFFFFLL;
  }
  if (v4 > v5) {
    return 1;
  }
  if (*a1 >= *a2) {
    return *a1 > *a2;
  }
  return 0xFFFFFFFFLL;
}

uint64_t FSTArcIsInputAndOutputAndWeightAndTargetLess(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[1];
  int v3 = a2[1];
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  if (v2 > v3) {
    return 1;
  }
  int v4 = a1[2];
  int v5 = a2[2];
  if (v4 < v5) {
    return 0xFFFFFFFFLL;
  }
  if (v4 > v5) {
    return 1;
  }
  int v6 = a1[3];
  int v7 = a2[3];
  if (v6 < v7) {
    return 0xFFFFFFFFLL;
  }
  if (v6 > v7) {
    return 1;
  }
  if (*a1 >= *a2) {
    return *a1 > *a2;
  }
  return 0xFFFFFFFFLL;
}

uint64_t FSTArcIsInputAndWeightAndOutputAndTargetLess(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[1];
  int v3 = a2[1];
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  if (v2 > v3) {
    return 1;
  }
  int v4 = a1[3];
  int v5 = a2[3];
  if (v4 < v5) {
    return 0xFFFFFFFFLL;
  }
  if (v4 > v5) {
    return 1;
  }
  int v6 = a1[2];
  int v7 = a2[2];
  if (v6 < v7) {
    return 0xFFFFFFFFLL;
  }
  if (v6 > v7) {
    return 1;
  }
  if (*a1 >= *a2) {
    return *a1 > *a2;
  }
  return 0xFFFFFFFFLL;
}

uint64_t FSTArcIsInputLess(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 4);
  int v3 = *(_DWORD *)(a2 + 4);
  BOOL v4 = v2 < v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v5;
  }
}

uint64_t FSTArcIsInputAndTargetLess(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[1];
  int v3 = a2[1];
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  if (v2 > v3) {
    return 1;
  }
  if (*a1 >= *a2) {
    return *a1 > *a2;
  }
  return 0xFFFFFFFFLL;
}

uint64_t FSTArcIsOutputLess(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  int v3 = *(_DWORD *)(a2 + 8);
  BOOL v4 = v2 < v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v5;
  }
}

uint64_t FSTSort_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v11 = 0;
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, a3, &v11);
  if (!result)
  {
    uint64_t v7 = v11;
    if (!v11) {
      goto LABEL_10;
    }
    int v8 = *(uint64_t (**)(unsigned char *, unsigned char *))(a1 + 72);
    if (!v8) {
      goto LABEL_10;
    }
    if ((*(_DWORD *)(v11 + 8) & 0x3FFFFFE) == 0)
    {
LABEL_9:
      lhstdlib_qsort(*(void *)(v7 + 56), *(_DWORD *)(v7 + 48), 0x10u, v8);
      lhstdlib_qsort(*(void *)(v11 + 40), *(_DWORD *)(v11 + 32), 0x10u, *(uint64_t (**)(unsigned char *, unsigned char *))(a1 + 72));
      uint64_t v7 = v11;
LABEL_10:
      uint64_t result = 0;
      *a4 = v7;
      return result;
    }
    uint64_t v10 = 0;
    uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v10);
    if (!result)
    {
      uint64_t result = FSTState_Copy(v10, v11);
      if (!result)
      {
        int v9 = *(_DWORD *)(v11 + 8);
        *(_DWORD *)(v11 + 8) = v9 - 1;
        if ((v9 & 0x3FFFFFF) == 0) {
          return 9;
        }
        uint64_t v7 = v10;
        uint64_t v11 = v10;
        int v8 = *(uint64_t (**)(unsigned char *, unsigned char *))(a1 + 72);
        goto LABEL_9;
      }
    }
  }
  return result;
}

uint64_t FSTSort_FillBuffer(uint64_t a1, char *a2, uint64_t *a3)
{
  uint64_t v10 = 0;
  if (a2)
  {
    uint64_t v10 = *a3;
    uint64_t result = FST_FillHeader((_DWORD *)a1, a2, 1, &v10);
    if (result) {
      return result;
    }
    uint64_t v7 = v10;
    int v8 = &a2[v10];
    uint64_t v9 = *a3 - v10;
  }
  else
  {
    *a3 = 0;
    uint64_t result = FST_GetHeaderSizeInOutputBuffer(&v10);
    if (result) {
      return result;
    }
    uint64_t v9 = 0;
    int v8 = 0;
    uint64_t v7 = v10;
  }
  uint64_t v10 = v9;
  uint64_t result = (*(uint64_t (**)(void, char *, uint64_t *))(**(void **)(a1 + 64) + 80))(*(void *)(a1 + 64), v8, &v10);
  if (!result) {
    *a3 = v10 + v7;
  }
  return result;
}

uint64_t FSTSort_GetMemoryInfo(uint64_t a1)
{
  return FSTUnaryOperator_GetMemoryInfo(a1) + 8;
}

uint64_t FSTSort_GetStateFlags(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 56))(*(void *)(a1 + 64));
}

void *GetFSTSortClass()
{
  return &__FSTSort;
}

uint64_t FSTMapLabels_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t result = _FSTUnaryOperator_Con(a1, a2, a3);
  if (!result)
  {
    *(void *)a1 = &__FSTMapLabels;
    *(_DWORD *)(a1 + 32) = 11;
    *(_DWORD *)(a1 + 72) = a4;
    *(void *)(a1 + 80) = a5;
  }
  return result;
}

uint64_t FSTMapLabels_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v21 = 0;
  *a4 = 0;
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, a3, &v21);
  uint64_t v7 = v21;
  if (result) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = v21 == 0;
  }
  if (!v8)
  {
    uint64_t v9 = *(void *)(a1 + 80);
    int v10 = *(_DWORD *)(a1 + 72);
    if ((*(_DWORD *)(v21 + 8) & 0x3FFFFFE) != 0)
    {
      uint64_t v20 = 0;
      uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v20);
      if (result) {
        return result;
      }
      uint64_t result = FSTState_Copy(v20, v21);
      if (result) {
        return result;
      }
      int v11 = *(_DWORD *)(v21 + 8);
      *(_DWORD *)(v21 + 8) = v11 - 1;
      if ((v11 & 0x3FFFFFF) == 0) {
        return 9;
      }
      uint64_t v7 = v20;
    }
    uint64_t v12 = *(void *)(v7 + 40);
    uint64_t v13 = *(void *)(v7 + 56);
    uint64_t v14 = *(unsigned int *)(v7 + 48);
    uint64_t v15 = v13 + 16 * v14;
    if (v12 != v15)
    {
      uint64_t v16 = v12 + 16 * *(unsigned int *)(v7 + 32);
      while (1)
      {
        if (v12 == v16)
        {
          uint64_t v12 = v13;
          if (!v14) {
            goto LABEL_22;
          }
        }
        if (v10 != 1) {
          break;
        }
        int v17 = (_DWORD *)(v12 + 8);
        uint64_t v18 = *(unsigned int *)(v12 + 8);
        if ((v18 & 0x80000000) == 0) {
          goto LABEL_19;
        }
LABEL_21:
        v12 += 16;
        if (v12 == v15) {
          goto LABEL_22;
        }
      }
      if (v10) {
        goto LABEL_21;
      }
      int v17 = (_DWORD *)(v12 + 4);
      uint64_t v18 = *(unsigned int *)(v12 + 4);
      if ((v18 & 0x80000000) != 0) {
        goto LABEL_21;
      }
LABEL_19:
      uint64_t v19 = *(void *)(v9 + 8);
      if ((int)v18 < (int)((unint64_t)(*(void *)(v9 + 16) - v19) >> 2)) {
        *int v17 = *(_DWORD *)(v19 + 4 * v18);
      }
      goto LABEL_21;
    }
LABEL_22:
    uint64_t result = 0;
    *a4 = v7;
  }
  return result;
}

uint64_t FSTMapLabels_FillBuffer(uint64_t a1, char *a2, uint64_t *a3)
{
  uint64_t v10 = 0;
  if (a2)
  {
    uint64_t v10 = *a3;
    uint64_t result = FST_FillHeader((_DWORD *)a1, a2, 1, &v10);
    if (result) {
      return result;
    }
    uint64_t v7 = v10;
    BOOL v8 = &a2[v10];
    uint64_t v9 = *a3 - v10;
  }
  else
  {
    *a3 = 0;
    uint64_t result = FST_GetHeaderSizeInOutputBuffer(&v10);
    if (result) {
      return result;
    }
    uint64_t v9 = 0;
    BOOL v8 = 0;
    uint64_t v7 = v10;
  }
  uint64_t v10 = v9;
  uint64_t result = (*(uint64_t (**)(void, char *, uint64_t *))(**(void **)(a1 + 64) + 80))(*(void *)(a1 + 64), v8, &v10);
  if (!result) {
    *a3 = v10 + v7;
  }
  return result;
}

uint64_t FSTMapLabels_GetMemoryInfo(uint64_t a1)
{
  return FSTUnaryOperator_GetMemoryInfo(a1) + 4 * **(unsigned int **)(a1 + 80) + 16;
}

uint64_t FSTMapLabels_GetStateFlags(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 56))(*(void *)(a1 + 64));
}

uint64_t PNEW_FSTMapLabels_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 88, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = _FSTUnaryOperator_Con(v12, a2, a3);
    if (result)
    {
      unsigned int v14 = result;
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *(void *)uint64_t v12 = &__FSTMapLabels;
      *(_DWORD *)(v12 + 32) = 11;
      *(_DWORD *)(v12 + 72) = a4;
      *(void *)(v12 + 80) = a5;
      *(void *)(v12 + 16) = a1;
      *a6 = v12;
    }
  }
  return result;
}

void *GetFSTMapLabelsClass()
{
  return &__FSTMapLabels;
}

uint64_t FSTBfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = Object_Con((void *)a1);
  unsigned int v11 = v6;
  if (!v6)
  {
    *(void *)a1 = &__FSTBfsContext;
    *(_DWORD *)(a1 + 24) = 100;
    uint64_t v7 = OOCAllocator_Malloc(a2, 400, &v11);
    *(void *)(a1 + 32) = v7;
    uint64_t v6 = v11;
    if (!v11)
    {
      uint64_t v8 = *(unsigned int *)(a1 + 24);
      unint64_t v9 = v7 + 4 * v8;
      *(void *)(a1 + 40) = v9;
      if (v8)
      {
        if (v9 <= v7 + 4) {
          unint64_t v9 = v7 + 4;
        }
        memset((void *)v7, 255, ((v9 + ~v7) & 0xFFFFFFFFFFFFFFFCLL) + 4);
      }
      *(_DWORD *)(a1 + 48) = 0;
      *(void *)(a1 + 56) = 0;
      *(void *)(a1 + 64) = 0;
      *(_DWORD *)(a1 + 72) = -1;
      *(void *)(a1 + 16) = a3;
      (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
      *(void *)(a1 + 8) = a2;
      return v11;
    }
  }
  return v6;
}

uint64_t FSTBfsContext_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    OOCAllocator_Free(*(void *)(a1 + 8), v2);
  }
  uint64_t v3 = *(void *)(a1 + 56);
  if (v3) {
    OOCAllocator_Free(*(void *)(a1 + 8), v3);
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16));
  if (!result)
  {
    return Object_Des();
  }
  return result;
}

uint64_t FSTBfsContext_BfsPartial(uint64_t a1, _DWORD *a2, unint64_t a3)
{
  unsigned int v47 = 0;
  if (((*(void *)(a1 + 64) - *(void *)(a1 + 56)) & 0x7FFFFFFF8) != 0)
  {
    cstdlib_memset(*(void **)(a1 + 32), 255, 4 * *(unsigned int *)(a1 + 24));
    *(void *)(a1 + 64) = *(void *)(a1 + 56);
    *(_DWORD *)(a1 + 72) = -1;
  }
  unsigned int v46 = 0;
  uint64_t v6 = OOCAllocator_Malloc(*(void *)(a1 + 8), 400, &v47);
  if (!v47)
  {
    uint64_t v7 = (_DWORD *)v6;
    unsigned int v47 = (*(uint64_t (**)(void, unsigned int *))(**(void **)(a1 + 16) + 48))(*(void *)(a1 + 16), &v46);
    if (!v47)
    {
      unsigned int v9 = v46;
      if (v46 == -1)
      {
        int v20 = 0;
      }
      else
      {
        _DWORD *v7 = v46;
        if (v47) {
          return v47;
        }
        unsigned int v10 = v46;
        unsigned int v11 = *(unsigned int **)(a1 + 32);
        unint64_t v12 = *(void *)(a1 + 40) - (void)v11;
        uint64_t v13 = v46 % (v12 >> 2);
        uint64_t v14 = v11[v13];
        if ((v14 & 0x80000000) != 0)
        {
LABEL_12:
          LODWORD(v16) = *(_DWORD *)(a1 + 72);
          if (v16 == -1)
          {
            uint64_t v18 = *(void *)(a1 + 56);
            uint64_t v21 = *(_DWORD **)(a1 + 64);
            uint64_t v16 = ((unint64_t)v21 - v18) >> 3;
            unsigned int v22 = 2 * (v12 >> 2);
            if (v22 >= v16)
            {
              unint64_t v27 = ((unint64_t)v21 - v18) >> 3;
            }
            else
            {
              unsigned int v23 = v22 | 1;
              uint64_t v24 = *(unsigned int *)(a1 + 24);
              if (v23 <= v24)
              {
                uint64_t v16 = 4 * v24;
              }
              else
              {
                if (v23 <= 8) {
                  unsigned int v25 = 8;
                }
                else {
                  unsigned int v25 = v23;
                }
                uint64_t v16 = 4 * v25;
                uint64_t v26 = OOCAllocator_Realloc(*(void *)(a1 + 8), *(void *)(a1 + 32), v16, &v47);
                *(void *)(a1 + 32) = v26;
                if (v47) {
                  return v47;
                }
                unsigned int v11 = (unsigned int *)v26;
                *(_DWORD *)(a1 + 24) = v25;
                v12 &= 0x3FFFFFFFCuLL;
              }
              unint64_t v28 = (v12 >> 1) & 0xFFFFFFFE | 1;
              *(void *)(a1 + 40) = &v11[v28];
              cstdlib_memset(v11, 255, v16);
              uint64_t v18 = *(void *)(a1 + 56);
              uint64_t v21 = *(_DWORD **)(a1 + 64);
              unint64_t v27 = ((unint64_t)v21 - v18) >> 3;
              LODWORD(v16) = v27;
              if (v27)
              {
                uint64_t v29 = 0;
                unsigned int v30 = (_DWORD *)(v18 + 4);
                do
                {
                  if (((*v30 + 1) & 0x40000000) == 0)
                  {
                    if (v47) {
                      return v47;
                    }
                    unint64_t v31 = *(v30 - 1)
                        - (*(v30 - 1) / v28) * (unint64_t)v28;
                    uint64_t v32 = *(void *)(a1 + 32);
                    *unsigned int v30 = *(_DWORD *)(v32 + 4 * v31);
                    *(_DWORD *)(v32 + 4 * v31) = v29;
                  }
                  ++v29;
                  v30 += 2;
                }
                while ((((unint64_t)v21 - v18) >> 3) != v29);
              }
            }
            unsigned int v33 = v16 + 1;
            unsigned int v34 = *(_DWORD *)(a1 + 48);
            if ((int)v16 + 1 > v34)
            {
              unsigned int v35 = 2 * v34;
              unsigned int v36 = v34 + 1000000;
              if (v35 >= v36) {
                unsigned int v35 = v36;
              }
              if (v35 > v33) {
                unsigned int v33 = v35;
              }
              if (v33 <= 8) {
                unsigned int v37 = 8;
              }
              else {
                unsigned int v37 = v33;
              }
              uint64_t v38 = OOCAllocator_Realloc(*(void *)(a1 + 8), v18, 8 * v37, &v47);
              *(void *)(a1 + 56) = v38;
              if (v47) {
                return v47;
              }
              uint64_t v18 = v38;
              *(_DWORD *)(a1 + 48) = v37;
              uint64_t v21 = (_DWORD *)(v38 + 8 * v27);
            }
            *(void *)(a1 + 64) = v21 + 2;
            *uint64_t v21 = v10;
            v21[1] = 0;
            unsigned int v11 = *(unsigned int **)(a1 + 32);
            uint64_t v13 = v10 % ((*(void *)(a1 + 40) - (void)v11) >> 2);
            uint64_t v17 = (int)v16;
          }
          else
          {
            uint64_t v17 = (int)v16;
            uint64_t v18 = *(void *)(a1 + 56);
            uint64_t v19 = (_DWORD *)(v18 + 8 * (int)v16);
            *(_DWORD *)(a1 + 72) = (v19[1] & 0xBFFFFFFF) - 1;
            _DWORD *v19 = v10;
            v19[1] = 0;
          }
          *(_DWORD *)(v18 + 8 * v17 + 4) = v11[v13];
          v11[v13] = v16;
        }
        else
        {
          uint64_t v15 = *(void *)(a1 + 56);
          while (v46 != *(_DWORD *)(v15 + 8 * v14))
          {
            uint64_t v14 = *(unsigned int *)(v15 + 8 * v14 + 4);
            if ((v14 & 0x80000000) != 0) {
              goto LABEL_12;
            }
          }
        }
        int v20 = 1;
      }
      if (v9 == -1 || !a3)
      {
LABEL_55:
        if (v7) {
          OOCAllocator_Free(*(void *)(a1 + 8), (uint64_t)v7);
        }
      }
      else
      {
        unsigned int v39 = a2;
        int v40 = 0;
        uint64_t v45 = 0;
        long long v42 = v39;
        long long v43 = v39;
        while (1)
        {
          int v41 = v7[v40];
          if (v40 == 99) {
            int v40 = 0;
          }
          else {
            ++v40;
          }
          int v44 = v41;
          unsigned int v47 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 120))(*(void *)(a1 + 16));
          if (v47) {
            break;
          }
          unsigned int v47 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 24))(a1, 0);
          if (v47) {
            break;
          }
          if (v42) {
            *v43++ = v44;
          }
          if (v40 != v20 && ++v45 < a3) {
            continue;
          }
          goto LABEL_55;
        }
      }
    }
  }
  return v47;
}

void *GetFSTBfsContextClass()
{
  return &__FSTBfsContext;
}

void fstcompose(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, void *a5)
{
  uint64_t v9 = 0;
  PNEW_FSTCompose_Con(a1, a2, a3, a4, &v9);
  if (!v8
    && !(*(unsigned int (**)(_DWORD *))(*(void *)a3 + 32))(a3)
    && !(*(unsigned int (**)(uint64_t))(*(void *)a4 + 32))(a4))
  {
    *a5 = v9;
  }
}

void PNEW_FSTCompose_Con(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t *a5)
{
  int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 152, &v12);
  if (!v12)
  {
    FSTCompose_Con(v10, a2, a3, a4);
    int v12 = v11;
    if (v11)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
    }
    else
    {
      *(void *)(v10 + 16) = a1;
      *a5 = v10;
    }
  }
}

void FSTCompose_Con(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  double v8 = FST_Con((void *)a1, a2, 0);
  if (!v9)
  {
    int v14 = 0;
    *(void *)a1 = &__FSTCompose;
    int v10 = a3[9];
    *(_DWORD *)(a1 + 32) = 268435457;
    *(_DWORD *)(a1 + 36) = v10;
    *(void *)(a1 + 64) = a2;
    (*(void (**)(_DWORD *, double))(*(void *)a3 + 24))(a3, v8);
    (*(void (**)(uint64_t))(*(void *)a4 + 24))(a4);
    *(void *)(a1 + 72) = a3;
    *(void *)(a1 + 80) = a4;
    if (!FST_QueryProperties((uint64_t)a3, 2, &v14))
    {
      *(_DWORD *)(a1 + 144) = v14 != 0;
      int v15 = FST_QueryProperties(a4, 1, &v14);
      if (!v15)
      {
        *(_DWORD *)(a1 + 148) = v14 != 0;
        *(_DWORD *)(a1 + 88) = 16;
        uint64_t v11 = OOCAllocator_Malloc(*(void *)(a1 + 64), 64, &v15);
        *(void *)(a1 + 96) = v11;
        if (!v15)
        {
          uint64_t v12 = *(unsigned int *)(a1 + 88);
          unint64_t v13 = v11 + 4 * v12;
          *(void *)(a1 + 104) = v13;
          if (v12)
          {
            if (v13 <= v11 + 4) {
              unint64_t v13 = v11 + 4;
            }
            memset((void *)v11, 255, ((v13 + ~v11) & 0xFFFFFFFFFFFFFFFCLL) + 4);
          }
          *(_DWORD *)(a1 + 112) = 0;
          *(void *)(a1 + 120) = 0;
          *(void *)(a1 + 128) = 0;
          *(_DWORD *)(a1 + 136) = -1;
        }
      }
    }
  }
}

uint64_t FSTCompose_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 96);
  if (v2) {
    OOCAllocator_Free(*(void *)(a1 + 64), v2);
  }
  uint64_t v3 = *(void *)(a1 + 120);
  if (v3) {
    OOCAllocator_Free(*(void *)(a1 + 64), v3);
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 72) + 32))(*(void *)(a1 + 72));
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 32))(*(void *)(a1 + 80));
    if (!result)
    {
      return FST_Des(a1);
    }
  }
  return result;
}

uint64_t FSTCompose_BorrowComponentFst(uint64_t a1, int a2)
{
  if (a2 == 1)
  {
    uint64_t v2 = a1 + 80;
    return *(void *)v2;
  }
  if (!a2)
  {
    uint64_t v2 = a1 + 72;
    return *(void *)v2;
  }
  return 0;
}

uint64_t FSTCompose_FetchState(uint64_t a1, unsigned int a2, char a3, void *a4)
{
  uint64_t v61 = 0;
  uint64_t result = FSTStatePool_PopFSTState(*(void *)(*(void *)(a1 + 72) + 48), &v61);
  if (result) {
    return result;
  }
  uint64_t v9 = v61;
  uint64_t v62 = 0;
  uint64_t v63 = 0;
  *(_DWORD *)(v61 + 24) = a2;
  long long v64 = *(_OWORD *)(*(void *)(a1 + 120) + 16 * a2);
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t *))(**(void **)(a1 + 72) + 120))(*(void *)(a1 + 72), v64, 8, &v63);
  if (result) {
    return result;
  }
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t *))(**(void **)(a1 + 80) + 120))(*(void *)(a1 + 80), DWORD1(v64), 8, &v62);
  if (result) {
    return result;
  }
  uint64_t v10 = v63;
  if ((a3 & 0xC) != 0 && (*(_DWORD *)(v63 + 8) & 0x80000000) != 0)
  {
    uint64_t v11 = v62;
    if ((*(_DWORD *)(v62 + 8) & 0x80000000) != 0)
    {
      *(_DWORD *)(v9 + 8) |= 0x80000000;
      int v12 = *(_DWORD *)(v10 + 28);
      int v13 = *(_DWORD *)(v11 + 28);
      BOOL v14 = v13 == 0x7FFFFFFF || v12 == 0x7FFFFFFF;
      int v15 = v13 + v12;
      if (v14) {
        int v15 = 0x7FFFFFFF;
      }
      *(_DWORD *)(v9 + 28) = v15;
    }
  }
  if ((a3 & 0xB) == 0) {
    goto LABEL_82;
  }
  v73[0] = 0;
  v66[0] = 0;
  v66[1] = 0;
  v65[0] = 0;
  v65[1] = 0;
  uint64_t v16 = *(unsigned int *)(v10 + 48);
  uint64_t v17 = *(unsigned int *)(v10 + 32);
  uint64_t v18 = *(unsigned int *)(v62 + 48);
  uint64_t v58 = *(unsigned int *)(v62 + 32);
  uint64_t v19 = *(int **)(v10 + 40);
  int __src = *(void **)(v62 + 56);
  unsigned int v60 = *(int **)(v10 + 56);
  int v57 = *(int **)(v62 + 40);
  uint64_t v71 = 0;
  uint64_t v72 = 0;
  uint64_t v69 = 0;
  uint64_t v70 = 0;
  uint64_t v67 = 0;
  uint64_t v68 = 0;
  if (*(_DWORD *)(a1 + 144))
  {
    int v20 = 0;
    uint64_t v21 = 0;
  }
  else
  {
    if (v16)
    {
      if (v16 <= 8) {
        unsigned int v44 = 8;
      }
      else {
        unsigned int v44 = v16;
      }
      int v20 = (void *)OOCAllocator_Realloc(*(void *)(a1 + 64), 0, 16 * v44, v73);
      uint64_t result = v73[0];
      if (v73[0]) {
        return result;
      }
    }
    else
    {
      int v20 = 0;
    }
    if (v17)
    {
      if (v17 <= 8) {
        unsigned int v47 = 8;
      }
      else {
        unsigned int v47 = v17;
      }
      uint64_t v21 = (void *)OOCAllocator_Realloc(*(void *)(a1 + 64), 0, 16 * v47, v73);
      uint64_t result = v73[0];
      if (v73[0]) {
        return result;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    if (v16)
    {
      cstdlib_memcpy(v20, v60, 16 * v16);
      lhstdlib_qsort((uint64_t)v20, v16, 0x10u, (uint64_t (*)(unsigned char *, unsigned char *))CmpFSTArc_ByOutput);
      unsigned int v60 = (int *)v20;
    }
    if (v17)
    {
      cstdlib_memcpy(v21, v19, 16 * v17);
      lhstdlib_qsort((uint64_t)v21, v17, 0x10u, (uint64_t (*)(unsigned char *, unsigned char *))CmpFSTArc_ByOutput);
      uint64_t v19 = (int *)v21;
    }
  }
  if (*(_DWORD *)(a1 + 148) || !v18)
  {
    unsigned __int8 __dst = 0;
  }
  else
  {
    if (v18 <= 8) {
      unsigned int v22 = 8;
    }
    else {
      unsigned int v22 = v18;
    }
    unsigned __int8 __dst = (void *)OOCAllocator_Realloc(*(void *)(a1 + 64), 0, 16 * v22, v73);
    uint64_t result = v73[0];
    if (v73[0]) {
      return result;
    }
    cstdlib_memcpy(__dst, __src, 16 * v18);
    lhstdlib_qsort((uint64_t)__dst, v18, 0x10u, (uint64_t (*)(unsigned char *, unsigned char *))CmpFSTArc_ByInput);
    int __src = __dst;
  }
  uint64_t FirstByOutput = __FSTCompose_FindFirstByOutput((uint64_t)v60, (uint64_t)&v60[4 * v16]);
  uint64_t v54 = (int *)__FSTCompose_FindFirstByOutput((uint64_t)v19, (uint64_t)&v19[4 * v17]);
  uint64_t result = FSTArc_Con(v66, v64, -2, -3, 0);
  v73[0] = result;
  if (result) {
    return result;
  }
  uint64_t result = FSTArc_Con(v65, SDWORD1(v64), -3, -2, 0);
  v73[0] = result;
  if (result) {
    return result;
  }
  uint64_t v51 = (uint64_t)v21;
  uint64_t v52 = (int *)FirstByOutput;
  if (!v58)
  {
LABEL_31:
    unint64_t v53 = ((char *)v54 - (char *)v19) >> 4;
    if (v54 != v19)
    {
      if (v53 <= 1) {
        uint64_t v26 = 1;
      }
      else {
        uint64_t v26 = ((char *)v54 - (char *)v19) >> 4;
      }
      unint64_t v27 = v19;
      do
      {
        uint64_t result = __FSTCompose_CombineArcPair(a1, (uint64_t)&v64, v27, (int *)v65, (unsigned int *)&v67);
        v73[0] = result;
        if (result) {
          return result;
        }
        v27 += 4;
      }
      while (--v26);
    }
    uint64_t v49 = (uint64_t)v20;
    if (v58 && v54 != v19)
    {
      uint64_t v28 = 0;
      uint64_t v29 = ((char *)v54 - (char *)v19) >> 4;
      if (v53 <= 1) {
        uint64_t v29 = 1;
      }
      uint64_t v48 = v29;
LABEL_43:
      uint64_t v50 = v28;
      unsigned int v30 = &v19[4 * v28];
      unint64_t v31 = v57;
      uint64_t v32 = v58;
      while (1)
      {
        uint64_t result = __FSTCompose_CombineArcPair(a1, (uint64_t)&v64, v30, v31, (unsigned int *)&v67);
        v73[0] = result;
        if (result) {
          return result;
        }
        v31 += 4;
        if (!--v32)
        {
          uint64_t v28 = v50 + 1;
          if (v50 + 1 != v48) {
            goto LABEL_43;
          }
          break;
        }
      }
    }
    uint64_t result = __FSTCompose_CombineArcArrays(a1, (uint64_t)&v64, v54, (int)v17 - (int)v53, (unint64_t)__src, v18, (unsigned int *)&v67);
    v73[0] = result;
    if (result) {
      return result;
    }
    unint64_t v33 = ((char *)v52 - (char *)v60) >> 4;
    if (v52 != v60)
    {
      if (v33 <= 1) {
        uint64_t v34 = 1;
      }
      else {
        uint64_t v34 = ((char *)v52 - (char *)v60) >> 4;
      }
      unsigned int v35 = v60;
      do
      {
        uint64_t result = __FSTCompose_CombineArcPair(a1, (uint64_t)&v64, v35, (int *)v65, (unsigned int *)&v70);
        v73[0] = result;
        if (result) {
          return result;
        }
        v35 += 4;
      }
      while (--v34);
    }
    if (v58 && v52 != v60)
    {
      uint64_t v36 = 0;
      if (v33 <= 1) {
        uint64_t v37 = 1;
      }
      else {
        uint64_t v37 = ((char *)v52 - (char *)v60) >> 4;
      }
      uint64_t v55 = v37;
LABEL_61:
      uint64_t v38 = v57;
      uint64_t v39 = v58;
      while (1)
      {
        uint64_t result = __FSTCompose_CombineArcPair(a1, (uint64_t)&v64, &v60[4 * v36], v38, (unsigned int *)&v70);
        v73[0] = result;
        if (result) {
          return result;
        }
        v38 += 4;
        if (!--v39)
        {
          if (++v36 != v55) {
            goto LABEL_61;
          }
          break;
        }
      }
    }
    uint64_t result = __FSTCompose_CombineArcArrays(a1, (uint64_t)&v64, v52, (int)v16 - (int)v33, (unint64_t)__src, v18, (unsigned int *)&v70);
    v73[0] = result;
    if (result) {
      return result;
    }
    unint64_t v40 = (unint64_t)(v72 - v71) >> 4;
    if (v40)
    {
      uint64_t result = FSTState_AddArcs(v9, 4, v71, v40);
      v73[0] = result;
      if (result) {
        return result;
      }
    }
    unint64_t v41 = (unint64_t)(v69 - v68) >> 4;
    if (v41)
    {
      uint64_t result = FSTState_AddArcs(v9, 2, v68, v41);
      v73[0] = result;
      if (result) {
        return result;
      }
    }
    if (v49) {
      OOCAllocator_Free(*(void *)(a1 + 64), v49);
    }
    if (v51) {
      OOCAllocator_Free(*(void *)(a1 + 64), v51);
    }
    if (__dst) {
      OOCAllocator_Free(*(void *)(a1 + 64), (uint64_t)__dst);
    }
    if (v71) {
      OOCAllocator_Free(*(void *)(a1 + 64), v71);
    }
    if (v68) {
      OOCAllocator_Free(*(void *)(a1 + 64), v68);
    }
    uint64_t result = v73[0];
    if (v73[0]) {
      return result;
    }
    uint64_t v10 = v63;
LABEL_82:
    int v42 = *(_DWORD *)(v10 + 8);
    if ((v42 & 0x3FFFFFF) == 1)
    {
      if ((v42 & 0x8000000) != 0) {
        uint64_t v43 = *(void *)(v10 + 16);
      }
      else {
        uint64_t v43 = 0;
      }
      uint64_t result = FSTStatePool_PushFSTState(v43, v10);
      if (result) {
        return result;
      }
    }
    else
    {
      *(_DWORD *)(v10 + 8) = v42 - 1;
      if ((v42 & 0x3FFFFFF) == 0) {
        return 9;
      }
    }
    int v45 = *(_DWORD *)(v62 + 8);
    if ((v45 & 0x3FFFFFF) == 1)
    {
      if ((v45 & 0x8000000) != 0) {
        uint64_t v46 = *(void *)(v62 + 16);
      }
      else {
        uint64_t v46 = 0;
      }
      uint64_t result = FSTStatePool_PushFSTState(v46, v62);
      if (result) {
        return result;
      }
LABEL_114:
      uint64_t result = 0;
      *a4 = v61;
      return result;
    }
    *(_DWORD *)(v62 + 8) = v45 - 1;
    if ((v45 & 0x3FFFFFF) != 0) {
      goto LABEL_114;
    }
    return 9;
  }
  unsigned int v25 = v57;
  uint64_t v24 = v58;
  while (1)
  {
    uint64_t result = __FSTCompose_CombineArcPair(a1, (uint64_t)&v64, (int *)v66, v25, (unsigned int *)&v67);
    v73[0] = result;
    if (result) {
      return result;
    }
    v25 += 4;
    if (!--v24) {
      goto LABEL_31;
    }
  }
}

uint64_t FSTCompose_GetFinalStateWeight(uint64_t a1, unsigned int a2, int *a3)
{
  uint64_t v8 = 0;
  uint64_t result = FSTCompose_FetchState(a1, a2, 4, &v8);
  if (!result)
  {
    if (!v8)
    {
      int v5 = 0x7FFFFFFF;
      goto LABEL_11;
    }
    int v5 = *(_DWORD *)(v8 + 28);
    int v6 = *(_DWORD *)(v8 + 8);
    if ((v6 & 0x3FFFFFF) != 1)
    {
      *(_DWORD *)(v8 + 8) = v6 - 1;
      if ((v6 & 0x3FFFFFF) == 0) {
        return 9;
      }
      goto LABEL_11;
    }
    if ((v6 & 0x8000000) != 0) {
      uint64_t v7 = *(void *)(v8 + 16);
    }
    else {
      uint64_t v7 = 0;
    }
    uint64_t result = FSTStatePool_PushFSTState(v7, v8);
    if (!result)
    {
LABEL_11:
      uint64_t result = 0;
      *a3 = v5;
    }
  }
  return result;
}

uint64_t FSTCompose_GetInitialStateId(uint64_t a1, _DWORD *a2)
{
  long long v40 = 0uLL;
  uint64_t result = (*(uint64_t (**)(void, long long *))(**(void **)(a1 + 72) + 48))(*(void *)(a1 + 72), &v40);
  if (result) {
    return result;
  }
  uint64_t result = (*(uint64_t (**)(void, char *))(**(void **)(a1 + 80) + 48))(*(void *)(a1 + 80), (char *)&v40 + 4);
  if (result) {
    return result;
  }
  uint64_t v5 = 0;
  unsigned int v6 = 0;
  DWORD2(v40) = 0;
  do
  {
    unsigned int v6 = (1025 * (*(_DWORD *)((char *)&v40 + v5) + v6)) ^ ((1025 * (*(_DWORD *)((char *)&v40 + v5) + v6)) >> 6);
    v5 += 4;
  }
  while (v5 != 12);
  unsigned int v7 = 32769 * ((9 * v6) ^ ((9 * v6) >> 11));
  unsigned int v41 = 0;
  uint64_t v8 = *(_DWORD **)(a1 + 96);
  unint64_t v9 = *(void *)(a1 + 104) - (void)v8;
  LODWORD(v10) = v8[v7 % (v9 >> 2)];
  if ((v10 & 0x80000000) == 0)
  {
    uint64_t v11 = *(void *)(a1 + 120);
    while (1)
    {
      unsigned int v41 = 0;
      if (v40 == *(_DWORD *)(v11 + 16 * v10)
        && *(void *)(v11 + 16 * v10 + 4) == DWORD1(v40))
      {
        break;
      }
      LODWORD(v10) = *(_DWORD *)(v11 + 16 * v10 + 12);
      if ((v10 & 0x80000000) != 0) {
        goto LABEL_10;
      }
    }
    uint64_t result = 0;
    goto LABEL_41;
  }
LABEL_10:
  LODWORD(v10) = *(_DWORD *)(a1 + 136);
  if (v10 != -1)
  {
    uint64_t v12 = (int)v10;
    uint64_t v13 = *(void *)(a1 + 120) + 16 * (int)v10;
    *(_DWORD *)(a1 + 136) = (*(_DWORD *)(v13 + 12) & 0xBFFFFFFF) - 1;
    *(_OWORD *)uint64_t v13 = v40;
LABEL_40:
    uint64_t v38 = *(void *)(a1 + 96);
    unsigned int v39 = v7 % ((unint64_t)(*(void *)(a1 + 104) - v38) >> 2);
    *(_DWORD *)(*(void *)(a1 + 120) + 16 * v12 + 12) = *(_DWORD *)(v38 + 4 * v39);
    *(_DWORD *)(v38 + 4 * v39) = v10;
    uint64_t result = v41;
LABEL_41:
    *a2 = v10;
    return result;
  }
  uint64_t v14 = *(void *)(a1 + 120);
  int v15 = *(_OWORD **)(a1 + 128);
  uint64_t v10 = ((unint64_t)v15 - v14) >> 4;
  unsigned int v16 = 2 * (v9 >> 2);
  if (v16 >= v10)
  {
    unint64_t v20 = ((unint64_t)v15 - v14) >> 4;
  }
  else
  {
    unsigned int v17 = v16 | 1;
    uint64_t v18 = *(unsigned int *)(a1 + 88);
    if (v17 <= v18)
    {
      uint64_t v10 = 4 * v18;
    }
    else
    {
      if (v17 <= 8) {
        unsigned int v19 = 8;
      }
      else {
        unsigned int v19 = v17;
      }
      uint64_t v10 = 4 * v19;
      uint64_t v8 = (_DWORD *)OOCAllocator_Realloc(*(void *)(a1 + 64), (uint64_t)v8, v10, &v41);
      *(void *)(a1 + 96) = v8;
      uint64_t result = v41;
      if (v41) {
        return result;
      }
      *(_DWORD *)(a1 + 88) = v19;
      v9 &= 0x3FFFFFFFCuLL;
    }
    unint64_t v21 = (v9 >> 1) & 0xFFFFFFFE | 1;
    *(void *)(a1 + 104) = &v8[v21];
    cstdlib_memset(v8, 255, v10);
    uint64_t v14 = *(void *)(a1 + 120);
    int v15 = *(_OWORD **)(a1 + 128);
    unint64_t v20 = ((unint64_t)v15 - v14) >> 4;
    LODWORD(v10) = v20;
    if (v20)
    {
      uint64_t v22 = 0;
      uint64_t v23 = *(void *)(a1 + 120);
      do
      {
        uint64_t v24 = v14 + 16 * v22;
        int v26 = *(_DWORD *)(v24 + 12);
        unsigned int v25 = (_DWORD *)(v24 + 12);
        if (((v26 + 1) & 0x40000000) == 0)
        {
          uint64_t v27 = 0;
          unsigned int v28 = 0;
          do
          {
            unsigned int v28 = (1025 * (*(_DWORD *)(v23 + v27) + v28)) ^ ((1025 * (*(_DWORD *)(v23 + v27) + v28)) >> 6);
            v27 += 4;
          }
          while (v27 != 12);
          unint64_t v29 = 32769 * ((9 * v28) ^ ((9 * v28) >> 11));
          unsigned int v41 = 0;
          uint64_t v30 = v29 - (v29 / v21) * (unint64_t)v21;
          uint64_t v31 = *(void *)(a1 + 96);
          *unsigned int v25 = *(_DWORD *)(v31 + 4 * v30);
          *(_DWORD *)(v31 + 4 * v30) = v22;
        }
        ++v22;
        v23 += 16;
      }
      while (v22 != (((unint64_t)v15 - v14) >> 4));
    }
  }
  unsigned int v32 = v10 + 1;
  unsigned int v33 = *(_DWORD *)(a1 + 112);
  if ((int)v10 + 1 <= v33)
  {
LABEL_39:
    *(void *)(a1 + 128) = v15 + 1;
    *int v15 = v40;
    uint64_t v12 = (int)v10;
    goto LABEL_40;
  }
  unsigned int v34 = 2 * v33;
  unsigned int v35 = v33 + 1000000;
  if (v34 >= v35) {
    unsigned int v34 = v35;
  }
  if (v34 > v32) {
    unsigned int v32 = v34;
  }
  if (v32 <= 8) {
    unsigned int v36 = 8;
  }
  else {
    unsigned int v36 = v32;
  }
  uint64_t v37 = OOCAllocator_Realloc(*(void *)(a1 + 64), v14, 16 * v36, &v41);
  *(void *)(a1 + 120) = v37;
  uint64_t result = v41;
  if (!v41)
  {
    *(_DWORD *)(a1 + 112) = v36;
    int v15 = (_OWORD *)(v37 + 16 * v20);
    goto LABEL_39;
  }
  return result;
}

uint64_t FSTCompose_GetMaxNbrComponentFsts()
{
  return 2;
}

uint64_t FSTCompose_GetMaxStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = -1;
  return 0;
}

uint64_t FSTCompose_GetMemoryInfo(uint64_t a1)
{
  return 4 * *(unsigned int *)(a1 + 88) + 16 * *(unsigned int *)(a1 + 112) + 152;
}

uint64_t FSTCompose_GetStateFlags(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  uint64_t v8 = 0;
  uint64_t result = FSTCompose_FetchState(a1, a2, 4, &v8);
  if (!result)
  {
    if (!v8)
    {
      unsigned int v6 = 0;
      goto LABEL_11;
    }
    int v5 = *(_DWORD *)(v8 + 8);
    unsigned int v6 = v5 & 0xF0000000;
    if ((v5 & 0x3FFFFFF) != 1)
    {
      *(_DWORD *)(v8 + 8) = v5 - 1;
      if ((v5 & 0x3FFFFFF) == 0) {
        return 9;
      }
      goto LABEL_11;
    }
    if ((v5 & 0x8000000) != 0) {
      uint64_t v7 = *(void *)(v8 + 16);
    }
    else {
      uint64_t v7 = 0;
    }
    uint64_t result = FSTStatePool_PushFSTState(v7, v8);
    if (!result)
    {
LABEL_11:
      uint64_t result = 0;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t FSTCompose_Reset(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 96);
  unint64_t v3 = *(void *)(a1 + 104);
  if (v2 < v3)
  {
    if (v3 <= v2 + 4) {
      unint64_t v3 = v2 + 4;
    }
    memset((void *)v2, 255, ((v3 + ~v2) & 0xFFFFFFFFFFFFFFFCLL) + 4);
  }
  *(_DWORD *)(a1 + 112) = 0;
  uint64_t v4 = *(void *)(a1 + 120);
  if (v4)
  {
    OOCAllocator_Free(*(void *)(a1 + 64), v4);
    *(void *)(a1 + 120) = 0;
  }
  *(void *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 136) = -1;

  return FST_Reset();
}

void *GetFSTComposeClass()
{
  return &__FSTCompose;
}

uint64_t CmpFSTArc_ByOutput(uint64_t a1, uint64_t a2)
{
  return (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8));
}

uint64_t CmpFSTArc_ByInput(uint64_t a1, uint64_t a2)
{
  return (*(_DWORD *)(a1 + 4) - *(_DWORD *)(a2 + 4));
}

uint64_t __FSTCompose_FindFirstByOutput(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  unint64_t v3 = (unint64_t)(a2 - a1) >> 4;
  if (v3 && *(int *)(a1 + 8) <= -2)
  {
    if (v3 < 2)
    {
      return a2;
    }
    else
    {
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      FSTArc_Con(&v14, 0, 0, -1, 0);
      uint64_t v5 = v2 + 16;
      unsigned int v6 = v3 - 1;
      while (1)
      {
        uint64_t v7 = v5 + 16 * (v6 >> 1);
        int v8 = *(_DWORD *)(v7 + 8);
        if ((int)v15 <= v8 && (int)v15 > *(_DWORD *)(v7 - 8)) {
          break;
        }
        BOOL v9 = (int)v15 <= v8;
        BOOL v10 = (int)v15 > v8;
        uint64_t v11 = v7 + 16;
        if (!v9) {
          uint64_t v5 = v11;
        }
        unsigned int v12 = v6 - v10;
        unsigned int v6 = (v6 - v10) >> 1;
        if (v12 <= 1)
        {
          uint64_t v7 = 0;
          break;
        }
      }
      if (v7) {
        return v7;
      }
      else {
        return a2;
      }
    }
  }
  return v2;
}

uint64_t __FSTCompose_CombineArcPair(uint64_t a1, uint64_t a2, int *a3, int *a4, unsigned int *a5)
{
  int v7 = *a3;
  int v8 = a3[1];
  int v9 = a3[2];
  int v10 = a3[3];
  int v11 = *a4;
  int v12 = a4[1];
  int v13 = a4[2];
  int v14 = a4[3];
  int v15 = *(_DWORD *)(a2 + 8);
  if (v9 < 0 || v12 < 0)
  {
    if (v9 != -2 || v12 != -2)
    {
      if (v9 == -3 && v12 == -2)
      {
        if (v15 != 2)
        {
          unsigned int v16 = 1;
          goto LABEL_4;
        }
      }
      else if (v9 == -2 && v12 == -3 && v15 != 1)
      {
        unsigned int v16 = 2;
        goto LABEL_4;
      }
      return 0;
    }
    unsigned int v16 = 0;
    uint64_t result = 0;
    if (v15) {
      return result;
    }
  }
  else
  {
    unsigned int v16 = 0;
  }
LABEL_4:
  uint64_t v17 = 0;
  unsigned int v18 = 0;
  LODWORD(v69) = *a3;
  DWORD1(v69) = v11;
  *((void *)&v69 + 1) = v16;
  do
  {
    unsigned int v18 = (1025 * (*(_DWORD *)((char *)&v69 + v17) + v18)) ^ ((1025 * (*(_DWORD *)((char *)&v69 + v17) + v18)) >> 6);
    v17 += 4;
  }
  while (v17 != 12);
  unsigned int v19 = 32769 * ((9 * v18) ^ ((9 * v18) >> 11));
  unsigned int v70 = 0;
  unint64_t v20 = *(_DWORD **)(a1 + 96);
  unint64_t v21 = *(void *)(a1 + 104) - (void)v20;
  unint64_t v22 = v21 >> 2;
  LODWORD(v23) = v20[v19 % (v21 >> 2)];
  if ((v23 & 0x80000000) != 0)
  {
LABEL_12:
    LODWORD(v23) = *(_DWORD *)(a1 + 136);
    if (v23 == -1)
    {
      uint64_t v33 = *(void *)(a1 + 120);
      unsigned int v34 = *(_OWORD **)(a1 + 128);
      uint64_t v23 = ((unint64_t)v34 - v33) >> 4;
      if (2 * (int)v22 >= v23)
      {
        unint64_t v38 = ((unint64_t)v34 - v33) >> 4;
      }
      else
      {
        unsigned int v35 = (2 * v22) | 1;
        uint64_t v36 = *(unsigned int *)(a1 + 88);
        if (v35 <= v36)
        {
          uint64_t v23 = 4 * v36;
        }
        else
        {
          if (v35 <= 8) {
            unsigned int v37 = 8;
          }
          else {
            unsigned int v37 = (2 * v22) | 1;
          }
          uint64_t v23 = 4 * v37;
          unint64_t v20 = (_DWORD *)OOCAllocator_Realloc(*(void *)(a1 + 64), (uint64_t)v20, v23, &v70);
          *(void *)(a1 + 96) = v20;
          uint64_t result = v70;
          if (v70) {
            return result;
          }
          *(_DWORD *)(a1 + 88) = v37;
          v21 &= 0x3FFFFFFFCuLL;
        }
        unint64_t v39 = (v21 >> 1) & 0xFFFFFFFE | 1;
        *(void *)(a1 + 104) = &v20[v39];
        cstdlib_memset(v20, 255, v23);
        uint64_t v33 = *(void *)(a1 + 120);
        unsigned int v34 = *(_OWORD **)(a1 + 128);
        unint64_t v38 = ((unint64_t)v34 - v33) >> 4;
        LODWORD(v23) = v38;
        if (v38)
        {
          uint64_t v40 = 0;
          uint64_t v41 = *(void *)(a1 + 120);
          do
          {
            uint64_t v42 = v33 + 16 * v40;
            int v44 = *(_DWORD *)(v42 + 12);
            uint64_t v43 = (_DWORD *)(v42 + 12);
            if (((v44 + 1) & 0x40000000) == 0)
            {
              uint64_t v45 = 0;
              unsigned int v46 = 0;
              do
              {
                unsigned int v46 = (1025 * (*(_DWORD *)(v41 + v45) + v46)) ^ ((1025 * (*(_DWORD *)(v41 + v45) + v46)) >> 6);
                v45 += 4;
              }
              while (v45 != 12);
              unint64_t v47 = 32769 * ((9 * v46) ^ ((9 * v46) >> 11));
              unsigned int v70 = 0;
              uint64_t v48 = v47 - (v47 / v39) * (unint64_t)v39;
              uint64_t v49 = *(void *)(a1 + 96);
              _DWORD *v43 = *(_DWORD *)(v49 + 4 * v48);
              *(_DWORD *)(v49 + 4 * v48) = v40;
            }
            ++v40;
            v41 += 16;
          }
          while (v40 != (((unint64_t)v34 - v33) >> 4));
        }
      }
      unsigned int v50 = v23 + 1;
      unsigned int v51 = *(_DWORD *)(a1 + 112);
      if ((int)v23 + 1 > v51)
      {
        unsigned int v52 = 2 * v51;
        unsigned int v53 = v51 + 1000000;
        if (v52 >= v53) {
          unsigned int v52 = v53;
        }
        if (v52 > v50) {
          unsigned int v50 = v52;
        }
        if (v50 <= 8) {
          unsigned int v54 = 8;
        }
        else {
          unsigned int v54 = v50;
        }
        uint64_t v55 = OOCAllocator_Realloc(*(void *)(a1 + 64), v33, 16 * v54, &v70);
        *(void *)(a1 + 120) = v55;
        uint64_t result = v70;
        if (v70) {
          return result;
        }
        *(_DWORD *)(a1 + 112) = v54;
        unsigned int v34 = (_OWORD *)(v55 + 16 * v38);
      }
      *(void *)(a1 + 128) = v34 + 1;
      *unsigned int v34 = v69;
      uint64_t v26 = (int)v23;
    }
    else
    {
      uint64_t v26 = (int)v23;
      uint64_t v27 = *(void *)(a1 + 120) + 16 * (int)v23;
      *(_DWORD *)(a1 + 136) = (*(_DWORD *)(v27 + 12) & 0xBFFFFFFF) - 1;
      *(_OWORD *)uint64_t v27 = v69;
    }
    uint64_t v56 = *(void *)(a1 + 96);
    unsigned int v57 = v19 % ((unint64_t)(*(void *)(a1 + 104) - v56) >> 2);
    *(_DWORD *)(*(void *)(a1 + 120) + 16 * v26 + 12) = *(_DWORD *)(v56 + 4 * v57);
    *(_DWORD *)(v56 + 4 * v57) = v23;
  }
  else
  {
    uint64_t v24 = *(void *)(a1 + 120);
    while (1)
    {
      unsigned int v70 = 0;
      if (v7 == *(_DWORD *)(v24 + 16 * v23))
      {
        uint64_t v25 = v24 + 16 * v23;
        if (v11 == *(_DWORD *)(v25 + 4) && v16 == *(_DWORD *)(v25 + 8)) {
          break;
        }
      }
      LODWORD(v23) = *(_DWORD *)(v24 + 16 * v23 + 12);
      if ((v23 & 0x80000000) != 0) {
        goto LABEL_12;
      }
    }
  }
  uint64_t v59 = *((void *)a5 + 1);
  uint64_t v58 = (_DWORD *)*((void *)a5 + 2);
  unint64_t v60 = (unint64_t)v58 - v59;
  unsigned int v61 = (((unint64_t)v58 - v59) >> 4) + 1;
  unsigned int v62 = *a5;
  if (v61 <= *a5)
  {
LABEL_73:
    *((void *)a5 + 2) = v58 + 4;
    if (v14 == 0x7FFFFFFF || v10 == 0x7FFFFFFF) {
      int v68 = 0x7FFFFFFF;
    }
    else {
      int v68 = v14 + v10;
    }
    return FSTArc_Con(v58, v23, v8, v13, v68);
  }
  unsigned int v63 = 2 * v62;
  unsigned int v64 = v62 + 1000000;
  if (v63 < v64) {
    unsigned int v64 = v63;
  }
  if (v64 > v61) {
    unsigned int v61 = v64;
  }
  if (v61 <= 8) {
    unsigned int v65 = 8;
  }
  else {
    unsigned int v65 = v61;
  }
  uint64_t v66 = OOCAllocator_Realloc(*(void *)(a1 + 64), v59, 16 * v65, &v70);
  *((void *)a5 + 1) = v66;
  uint64_t result = v70;
  if (!v70)
  {
    *a5 = v65;
    uint64_t v58 = (_DWORD *)(v66 + (v60 & 0xFFFFFFFF0));
    goto LABEL_73;
  }
  return result;
}

uint64_t __FSTCompose_CombineArcArrays(uint64_t a1, uint64_t a2, int *a3, int a4, unint64_t a5, unsigned int a6, unsigned int *a7)
{
  uint64_t result = 0;
  if (a4 && a6)
  {
    unint64_t v9 = a5;
    int v10 = a3;
    unint64_t v11 = a5 + 16 * a6;
    if (a3[2] <= *(_DWORD *)(v11 - 12)
      && (unint64_t v12 = (unint64_t)&a3[4 * a4], *(_DWORD *)(v12 - 8) >= *(_DWORD *)(a5 + 4)))
    {
      while (1)
      {
        int v15 = v10;
        int v16 = v10[2];
        uint64_t v17 = v10 + 4;
        do
        {
          int v10 = v17;
          if ((unint64_t)v17 >= v12) {
            break;
          }
          int v18 = v17[2];
          v17 += 4;
        }
        while (v18 == v16);
        unsigned int v19 = (int *)v9;
        if (v9 < v11)
        {
          do
          {
            if (v19[1] >= v16) {
              break;
            }
            v19 += 4;
          }
          while ((unint64_t)v19 < v11);
        }
        unint64_t v9 = (unint64_t)v19;
        if ((unint64_t)v19 < v11)
        {
          unint64_t v9 = (unint64_t)v19;
          do
          {
            if (*(_DWORD *)(v9 + 4) != v16) {
              break;
            }
            v9 += 16;
          }
          while (v9 < v11);
        }
        if (v15 < v10) {
          break;
        }
LABEL_23:
        uint64_t result = 0;
        if ((unint64_t)v10 >= v12) {
          return result;
        }
      }
      while (1)
      {
        unint64_t v20 = v19;
        if ((unint64_t)v19 < v9) {
          break;
        }
LABEL_21:
        BOOL v21 = v15 >= v10 - 4;
        v15 += 4;
        if (v21) {
          goto LABEL_23;
        }
      }
      while (1)
      {
        uint64_t result = __FSTCompose_CombineArcPair(a1, a2, v15, v20, a7);
        if (result) {
          break;
        }
        v20 += 4;
        if ((unint64_t)v20 >= v9) {
          goto LABEL_21;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void fstpush(uint64_t a1, uint64_t a2, uint64_t a3, __int32 a4, void *a5)
{
  int v8 = 0;
  PNEW_FSTPush_Con(a1, a2, a3, a4, &v8);
  if (!v7 && !(*(unsigned int (**)(uint64_t))(*(void *)a3 + 32))(a3)) {
    *a5 = v8;
  }
}

void PNEW_FSTPush_Con(uint64_t a1, uint64_t a2, uint64_t a3, __int32 a4, int8x8_t **a5)
{
  int v12 = 0;
  int v10 = (int8x8_t *)OOCAllocator_Malloc(a1, 104, &v12);
  if (!v12)
  {
    FSTPush_Con(v10, a2, a3, a4);
    int v12 = v11;
    if (v11)
    {
      OOCAllocator_Free(a1, (uint64_t)v10);
      *a5 = 0;
    }
    else
    {
      v10[2] = (int8x8_t)a1;
      *a5 = v10;
    }
  }
}

void FSTPush_Con(int8x8_t *a1, uint64_t a2, uint64_t a3, __int32 a4)
{
  if (!_FSTUnaryOperator_Con((uint64_t)a1, a2, a3))
  {
    *a1 = (int8x8_t)&__FSTPush;
    a1[4].i32[0] = 47;
    _FSTUnaryOperator_InheritProperties(a1, a3, 0, 0, 0, 0x3FFFF);
    a1[12].i32[0] = a4;
    a1[9] = 0;
    __FSTPush_Init((uint64_t)a1);
  }
}

void __FSTPush_Init(uint64_t a1)
{
  unint64_t v3 = (uint64_t *)(a1 + 72);
  uint64_t v2 = *(void *)(a1 + 72);
  uint64_t v4 = *(_DWORD **)(a1 + 64);
  uint64_t v5 = *(void *)(a1 + 24);
  if (!v2 || !OOC_PlacementDeleteObject(*(void *)(a1 + 24), v2))
  {
    int v12 = 0;
    if (!(*(unsigned int (**)(_DWORD *, uint64_t))(*(void *)v4 + 48))(v4, a1 + 84))
    {
      *(_DWORD *)(a1 + 80) = *(_DWORD *)(a1 + 84);
      *(_DWORD *)(a1 + 92) = 0;
      PNEW_FSTReverse_Con(v5, v5, (uint64_t)v4, (uint64_t *)&v12);
      if (!v6 && !PNEW_FSTStatePotentials_Con(v5, v5, (uint64_t)v12, *(_DWORD *)(a1 + 96) & 3, v3))
      {
        if (*(unsigned char *)(a1 + 96)) {
          *(_DWORD *)(a1 + 92) = *(_DWORD *)(*(void *)(*(void *)(a1 + 72) + 24) + 4 * *(unsigned int *)(a1 + 84));
        }
        int v7 = v12;
        int v8 = v4[11] | 0x200;
        v4[10] = v4[10] & 0xFFFFFDFF | ((((v12[10] & v12[11]) >> 9) & 1) << 9);
        v4[11] = v8;
        int v9 = v7[10];
        int v10 = v7[11];
        if (!(*(unsigned int (**)(_DWORD *, uint64_t))(*(void *)v4 + 72))(v4, a1 + 88))
        {
          if ((v9 & v10 & 0x200) != 0)
          {
            int v11 = v12;
            if (*(_DWORD *)(a1 + 92))
            {
              if (v12[24]) {
                *(_DWORD *)(a1 + 80) = *(_DWORD *)(a1 + 88) + 1;
              }
            }
          }
          else
          {
            int v11 = v12;
          }
          (*(void (**)(_DWORD *))(*(void *)v11 + 32))(v11);
        }
      }
    }
  }
}

uint64_t FSTPush_Des(uint64_t a1)
{
  uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 24), *(void *)(a1 + 72));
  if (!result)
  {
    return FSTUnaryOperator_Des(a1);
  }
  return result;
}

uint64_t FSTPush_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v5 = a2;
  uint64_t v27 = 0;
  if (*(_DWORD *)(a1 + 80) == a2 && *(_DWORD *)(a1 + 84) != a2)
  {
    v26[0] = 0;
    v26[1] = 0;
    uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v27);
    if (!result)
    {
      uint64_t v12 = v27;
      *(_DWORD *)(v27 + 8) |= 0x20000000u;
      *(_DWORD *)(v12 + 24) = v5;
      *(_DWORD *)(v12 + 28) = 0x7FFFFFFF;
      uint64_t result = FSTArc_Con(v26, *(_DWORD *)(a1 + 84), -2, -2, *(_DWORD *)(a1 + 92));
      if (!result)
      {
        uint64_t result = FSTState_AddArcs(v27, 2, (uint64_t)v26, 1u);
        if (!result)
        {
          uint64_t v8 = v27;
LABEL_48:
          uint64_t result = 0;
          *a4 = v8;
          return result;
        }
      }
    }
    return result;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, a3, &v27);
  if (result) {
    return result;
  }
  uint64_t v8 = v27;
  if (!v27) {
    goto LABEL_48;
  }
  v26[0] = 4294967294;
  int v9 = *(_DWORD *)(a1 + 96);
  if ((v9 & 1) == 0)
  {
    int v10 = 0;
    BOOL v11 = 0;
    if ((v9 & 2) == 0) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  int v10 = *(_DWORD *)(*(void *)(*(void *)(a1 + 72) + 24) + 4 * v5);
  BOOL v11 = v10 != 0x7FFFFFFF;
  if ((v9 & 2) != 0)
  {
LABEL_13:
    v26[0] = *(void *)(*(void *)(*(void *)(a1 + 72) + 48) + 8 * v5);
    BOOL v11 = 1;
  }
LABEL_14:
  if ((*(_DWORD *)(v27 + 8) & 0x3FFFFFE) == 0)
  {
LABEL_19:
    if (v11)
    {
      int v14 = *(unsigned int **)(v8 + 40);
      uint64_t v15 = *(void *)(v8 + 56) + 16 * *(unsigned int *)(v8 + 48);
      if (v14 != (unsigned int *)v15)
      {
        int v16 = &v14[4 * *(unsigned int *)(v8 + 32)];
        do
        {
          if (v14 == v16)
          {
            uint64_t v8 = v27;
            if (!*(_DWORD *)(v27 + 48)) {
              goto LABEL_32;
            }
            int v14 = *(unsigned int **)(v27 + 56);
          }
          int v17 = *(_DWORD *)(a1 + 96);
          if (v17)
          {
            int v18 = *(_DWORD *)(*(void *)(*(void *)(a1 + 72) + 24) + 4 * *v14);
            if (v18 != 0x7FFFFFFF) {
              v14[3] += v18 - v10;
            }
          }
          if ((v17 & 2) != 0)
          {
            uint64_t v25 = 0;
            uint64_t v25 = *(void *)(*(void *)(*(void *)(a1 + 72) + 48) + 8 * *v14);
            FSTStateLabelSet_Plus((uint64_t)&v25, v14[2]);
            _OWORD v14[2] = FSTStateLabelSet_Minus(&v25, (uint64_t)v26);
          }
          v14 += 4;
        }
        while (v14 != (unsigned int *)v15);
        uint64_t v8 = v27;
      }
LABEL_32:
      if (*(_DWORD *)(v8 + 8) & 0x80000000) != 0 && (*(unsigned char *)(a1 + 96)) {
        *(_DWORD *)(v8 + 28) -= v10;
      }
    }
    if (*(_DWORD *)(a1 + 80) == v5)
    {
      int v19 = *(_DWORD *)(a1 + 92);
      if (v19)
      {
        unint64_t v20 = *(_DWORD **)(v8 + 40);
        BOOL v21 = *(_DWORD **)(v8 + 56);
        uint64_t v22 = *(unsigned int *)(v8 + 48);
        uint64_t v23 = &v21[4 * v22];
        if (v20 != v23)
        {
          uint64_t v24 = &v20[4 * *(unsigned int *)(v8 + 32)];
          do
          {
            if (v20 == v24)
            {
              unint64_t v20 = v21;
              if (!v22) {
                break;
              }
            }
            if (*v20 != v5 && (*(unsigned char *)(a1 + 96) & 1) != 0) {
              v20[3] += v19;
            }
            v20 += 4;
          }
          while (v20 != v23);
        }
        if (*(_DWORD *)(v8 + 8) & 0x80000000) != 0 && (*(unsigned char *)(a1 + 96)) {
          *(_DWORD *)(v8 + 28) += v19;
        }
      }
    }
    goto LABEL_48;
  }
  uint64_t v25 = 0;
  uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v25);
  if (!result)
  {
    uint64_t result = FSTState_Copy(v25, v27);
    if (!result)
    {
      int v13 = *(_DWORD *)(v27 + 8);
      *(_DWORD *)(v27 + 8) = v13 - 1;
      if ((v13 & 0x3FFFFFF) == 0) {
        return 9;
      }
      uint64_t v8 = v25;
      uint64_t v27 = v25;
      goto LABEL_19;
    }
  }
  return result;
}

uint64_t FSTPush_GetFinalStateWeight(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  if (*(_DWORD *)(a1 + 80) == a2) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 96) & 1) == 0) {
    return 0;
  }
  int v3 = *(_DWORD *)(*(void *)(*(void *)(a1 + 72) + 24) + 4 * a2);
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 64))(*(void *)(a1 + 64));
  if (!result) {
    *a3 = -v3;
  }
  return result;
}

uint64_t FSTPush_GetInitialStateId(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 80);
  return 0;
}

uint64_t FSTPush_GetMaxStateId(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[22];
  if (a1[20] != a1[21]) {
    ++v2;
  }
  *a2 = v2;
  return 0;
}

uint64_t FSTPush_GetMemoryInfo(uint64_t a1)
{
  uint64_t MemoryInfo = FSTUnaryOperator_GetMemoryInfo(a1);
  return MemoryInfo + FSTStatePotentials_GetUsedMemory(*(void *)(a1 + 72)) + 32;
}

void FSTPush_Reset(uint64_t a1)
{
  if (!FSTUnaryOperator_Reset(a1))
  {
    __FSTPush_Init(a1);
  }
}

void *GetFSTPushClass()
{
  return &__FSTPush;
}

uint64_t MemOutStream_Con(void *a1, uint64_t a2)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__MemOutStream;
    a1[1] = 0;
    a1[5] = __MemOutStream_Seek;
    a1[3] = 0;
    a1[4] = __MemOutStream_Write;
    a1[7] = __MemOutStream_Finished;
    a1[8] = a2;
    a1[6] = __MemOutStream_Error;
    a1[9] = 0;
    a1[2] = 0;
  }
  return result;
}

uint64_t __MemOutStream_Seek(uint64_t a1, uint64_t a2, int a3)
{
  if (*(void *)(a1 + 16) < a2) {
    return 1;
  }
  if (a3) {
    return 0;
  }
  uint64_t result = 0;
  *(void *)(a1 + 72) = a2;
  return result;
}

uint64_t __MemOutStream_Write(void *__src, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5 = a3;
  size_t v7 = a3 * a2;
  uint64_t v8 = a4[9];
  if (v8 != a4[2])
  {
    cstdlib_memcpy((void *)(a4[1] + v8), __src, v7);
LABEL_13:
    a4[9] += v7;
    return v5;
  }
  int v17 = 0;
  unint64_t v9 = v8 + v7;
  size_t v10 = a4[3];
  uint64_t v11 = a4[1];
  if (v8 + v7 <= v10)
  {
LABEL_12:
    cstdlib_memcpy((void *)(v11 + v8), __src, v7);
    a4[2] += v7;
    goto LABEL_13;
  }
  unint64_t v12 = v10 + (v10 >> 1);
  unint64_t v13 = v10 + 10000000;
  if (v12 >= v13) {
    unint64_t v12 = v13;
  }
  if (v9 <= v12) {
    uint64_t v14 = v12;
  }
  else {
    uint64_t v14 = v9;
  }
  uint64_t v15 = OOCAllocator_Realloc(a4[8], v11, v14, &v17);
  a4[1] = v15;
  if (!v17)
  {
    uint64_t v11 = v15;
    a4[3] = v14;
    uint64_t v8 = a4[2];
    goto LABEL_12;
  }
  return 0;
}

uint64_t __MemOutStream_Finished()
{
  return 0;
}

uint64_t __MemOutStream_Error()
{
  return 0;
}

uint64_t MemOutStream_Des(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    OOCAllocator_Free(*(void *)(a1 + 64), v1);
  }

  return Object_Des();
}

uint64_t MemOutStream_BorrowBuffer(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t MemOutStream_BorrowOStreamItf(uint64_t a1)
{
  return a1 + 32;
}

uint64_t MemOutStream_GetSize(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t MemOutStream_ReleaseBuffer(void *a1, uint64_t *a2, void *a3, void *a4)
{
  unsigned int v12 = 0;
  size_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  uint64_t v8 = a1[8];
  if (a2 && a3 && a4)
  {
    *a2 = OOCAllocator_Realloc(v8, v6, a1[2], &v12);
    uint64_t result = v12;
    if (v12) {
      return result;
    }
    *a3 = a1[2];
    *a4 = a1[8];
  }
  else
  {
    OOCAllocator_Free(v8, v6);
  }
  uint64_t result = 0;
  a1[9] = 0;
  v7[1] = 0;
  v7[2] = 0;
  void *v7 = 0;
  return result;
}

uint64_t PNEW_MemOutStream_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = (void *)OOCAllocator_Malloc(a1, 80, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = Object_Con(v6);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      void *v6 = &__MemOutStream;
      v6[1] = 0;
      v6[5] = __MemOutStream_Seek;
      v6[3] = 0;
      v6[4] = __MemOutStream_Write;
      _OWORD v6[7] = __MemOutStream_Finished;
      v6[8] = a2;
      v6[6] = __MemOutStream_Error;
      v6[9] = 0;
      v6[2] = 0;
      *a3 = v6;
    }
  }
  return result;
}

void *GetMemOutStreamClass()
{
  return &__MemOutStream;
}

uint64_t MemInStream_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)(a1 + 16) = MemInStream_fseek;
    *(void *)a1 = &__MemInStream;
    *(void *)(a1 + 8) = MemInStream_fread;
    *(void *)(a1 + 32) = MemInStream_ffinished;
    *(void *)(a1 + 40) = a2;
    *(void *)(a1 + 24) = MemInStream_ferror;
    *(void *)(a1 + 48) = a2 + a3;
    *(void *)(a1 + 56) = a2;
    *(_DWORD *)(a1 + 64) = 0;
  }
  return result;
}

BOOL MemInStream_fseek(uint64_t a1, uint64_t a2, int a3)
{
  switch(a3)
  {
    case 0:
      uint64_t v4 = *(void *)(a1 + 40);
LABEL_7:
      unint64_t v3 = v4 + a2;
      goto LABEL_8;
    case 1:
      uint64_t v4 = *(void *)(a1 + 56);
      goto LABEL_7;
    case 2:
      unint64_t v3 = *(void *)(a1 + 48) - a2;
LABEL_8:
      *(void *)(a1 + 56) = v3;
      goto LABEL_10;
  }
  unint64_t v3 = *(void *)(a1 + 56);
LABEL_10:
  BOOL v5 = v3 > *(void *)(a1 + 48) || v3 < *(void *)(a1 + 40);
  *(_DWORD *)(a1 + 64) = v5;
  return v5;
}

size_t MemInStream_fread(void *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a4 + 64))
  {
    size_t v5 = 0;
  }
  else
  {
    size_t v7 = *(const void **)(a4 + 56);
    if (a3 * a2 >= *(void *)(a4 + 48) - (void)v7) {
      size_t v5 = *(void *)(a4 + 48) - (void)v7;
    }
    else {
      size_t v5 = a3 * a2;
    }
    cstdlib_memcpy(a1, v7, v5);
    *(void *)(a4 + 56) += v5;
  }
  return v5 / a2;
}

uint64_t MemInStream_ffinished(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t MemInStream_ferror(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t MemInStream_BorrowIStreamItf(uint64_t a1)
{
  return a1 + 8;
}

uint64_t PNEW_MemInStream_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 72, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = Object_Con((void *)v8);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *(void *)(v8 + 16) = MemInStream_fseek;
      *(void *)uint64_t v8 = &__MemInStream;
      *(void *)(v8 + 8) = MemInStream_fread;
      *(void *)(v8 + 32) = MemInStream_ffinished;
      *(void *)(v8 + 40) = a2;
      *(void *)(v8 + 24) = MemInStream_ferror;
      *(void *)(v8 + 48) = a2 + a3;
      *(void *)(v8 + 56) = a2;
      *(_DWORD *)(v8 + 64) = 0;
      *a4 = v8;
    }
  }
  return result;
}

void *GetMemInStreamClass()
{
  return &__MemInStream;
}

uint64_t dpmemblock_Create(uint64_t a1, int a2, unsigned int a3, uint64_t *a4)
{
  unsigned int v15 = 0;
  uint64_t v8 = OOCAllocator_Calloc(a1, 1, 48, &v15);
  uint64_t result = v15;
  if (!v15)
  {
    *(void *)uint64_t v8 = a1;
    *(_DWORD *)(v8 + 16) = a2;
    int v10 = a3 > 1;
    unsigned int v11 = a3 - v10;
    if (a3 == v10)
    {
      __int16 v12 = 0;
    }
    else
    {
      __int16 v12 = 0;
      do
      {
        ++v12;
        BOOL v13 = v11 > 1;
        v11 >>= 1;
      }
      while (v13);
    }
    *(_WORD *)(v8 + 44) = v12;
    *(_DWORD *)(v8 + 20) = 1 << v12;
    *(_DWORD *)(v8 + 40) = -1;
    *a4 = v8;
  }
  if (result) {
    BOOL v14 = v8 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (!v14)
  {
    OOCAllocator_Free(a1, v8);
    return v15;
  }
  return result;
}

uint64_t dpmemblock_Free(uint64_t *a1)
{
  uint64_t v2 = *a1;
  dpmemblock_Reset((uint64_t)a1);

  return OOCAllocator_Free(v2, (uint64_t)a1);
}

uint64_t dpmemblock_Reset(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t v4 = (void *)(a1 + 24);
  unint64_t v3 = *(unsigned int *)(a1 + 24);
  if (v3)
  {
    for (unint64_t i = 0; i < v3; ++i)
    {
      uint64_t v6 = *(void *)(*(void *)(a1 + 8) + 8 * i);
      if (v6)
      {
        OOCAllocator_Free(v2, v6);
        unint64_t v3 = *(unsigned int *)v4;
      }
    }
  }
  uint64_t result = OOCAllocator_Free(v2, *(void *)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  *uint64_t v4 = 0;
  v4[1] = 0;
  *(_DWORD *)(a1 + 40) = -1;
  return result;
}

uint64_t dpmemblock_GetNewElement(uint64_t a1, void *a2, unsigned int *a3)
{
  unsigned int v6 = *(_DWORD *)(a1 + 32);
  if (v6 == *(_DWORD *)(a1 + 36))
  {
    uint64_t result = dpmemblock_ExtendBlock(a1);
    if (result) {
      return result;
    }
    unsigned int v6 = *(_DWORD *)(a1 + 32);
  }
  *a2 = *(void *)(*(void *)(a1 + 8) + 8 * (v6 >> *(_WORD *)(a1 + 44)))
      + (v6 - (v6 >> *(_WORD *)(a1 + 44) << *(_WORD *)(a1 + 44))) * *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 32) = v6 + 1;
  uint64_t result = 0;
  if (a3) {
    *a3 = v6;
  }
  return result;
}

uint64_t dpmemblock_ExtendBlock(uint64_t a1)
{
  unsigned int v10 = 0;
  uint64_t v2 = *(void *)a1;
  int v3 = *(_DWORD *)(a1 + 24);
  if (v3 == *(_DWORD *)(a1 + 28))
  {
    if (v3)
    {
      int v4 = v3 + 10;
      uint64_t v5 = OOCAllocator_Realloc(*(void *)a1, *(void *)(a1 + 8), 8 * (v3 + 10), &v10);
      uint64_t result = v10;
      if (v10) {
        return result;
      }
      *(void *)(a1 + 8) = v5;
    }
    else
    {
      *(void *)(a1 + 8) = OOCAllocator_Malloc(*(void *)a1, 80, &v10);
      uint64_t result = v10;
      if (v10) {
        return result;
      }
      int v4 = 10;
    }
    *(_DWORD *)(a1 + 28) = v4;
  }
  uint64_t v7 = OOCAllocator_Malloc(v2, (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16)), &v10);
  uint64_t v8 = *(unsigned int *)(a1 + 24);
  *(void *)(*(void *)(a1 + 8) + 8 * v8) = v7;
  uint64_t result = v10;
  if (!v10)
  {
    int v9 = v8 + 1;
    *(_DWORD *)(a1 + 24) = v9;
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 20) * v9;
  }
  return result;
}

uint64_t dpmemblock_GetNewElementWithReUse(uint64_t a1, void *a2, unsigned int *a3)
{
  unsigned int v6 = *(_DWORD *)(a1 + 40);
  if (v6 == -1)
  {
    unsigned int v6 = *(_DWORD *)(a1 + 32);
    if (v6 == *(_DWORD *)(a1 + 36))
    {
      uint64_t result = dpmemblock_ExtendBlock(a1);
      if (result) {
        return result;
      }
      unsigned int v6 = *(_DWORD *)(a1 + 32);
    }
    *a2 = *(void *)(*(void *)(a1 + 8) + 8 * (v6 >> *(_WORD *)(a1 + 44)))
        + (v6 - (v6 >> *(_WORD *)(a1 + 44) << *(_WORD *)(a1 + 44))) * *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 32) = v6 + 1;
  }
  else
  {
    char v7 = *(_WORD *)(a1 + 44);
    uint64_t v8 = *(void *)(*(void *)(a1 + 8) + 8 * (v6 >> v7));
    uint64_t v9 = (v6 - (v6 >> v7 << v7)) * *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(v8 + v9);
    *a2 = v8 + v9;
  }
  uint64_t result = 0;
  if (a3) {
    *a3 = v6;
  }
  return result;
}

uint64_t dpmemblock_GetElement(uint64_t a1, unsigned int a2, void *a3)
{
  if (*(_DWORD *)(a1 + 32) <= a2) {
    return err_GenerateErrorInternal();
  }
  *a3 = *(void *)(*(void *)(a1 + 8) + 8 * (a2 >> *(_WORD *)(a1 + 44)))
      + (a2 - (a2 >> *(_WORD *)(a1 + 44) << *(_WORD *)(a1 + 44))) * *(_DWORD *)(a1 + 16);
  return 0;
}

uint64_t dpmemblock_GetLastElementID(uint64_t a1, _DWORD *a2)
{
  int v2 = *(_DWORD *)(a1 + 32);
  if (!v2) {
    return err_GenerateErrorInternal();
  }
  *a2 = v2 - 1;
  return 0;
}

uint64_t dpmemblock_GetUnitSize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

_DWORD *dpmemblock_ReturnElement(_DWORD *result, unsigned int a2)
{
  unsigned int v2 = result[4];
  if (v2 >= 4)
  {
    int v4 = result;
    uint64_t result = cstdlib_memcpy((void *)(*(void *)(*((void *)result + 1) + 8 * (a2 >> *((_WORD *)result + 22)))+ (a2 - (a2 >> *((_WORD *)result + 22) << *((_WORD *)result + 22))) * v2), result + 10, 4uLL);
    v4[10] = a2;
  }
  return result;
}

uint64_t GetNull()
{
  return 0;
}

uint64_t Object_Des()
{
  return 0;
}

void *GetObjectClass()
{
  return &__Object;
}

uint64_t Object__IsKindOf(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t result = *(void *)result;
    if (result)
    {
      while (result != a2)
      {
        uint64_t result = (*(uint64_t (**)(void))(result + 8))();
        if (!result) {
          return result;
        }
      }
      return 1;
    }
  }
  return result;
}

uint64_t OOC_PlacementDeleteObject(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  if (!v4) {
    OOCAllocator_Free(a1, a2);
  }
  return v4;
}

uint64_t Object_Con(void *a1)
{
  *a1 = &__Object;
  return 0;
}

uint64_t RefCounted_Con(uint64_t a1, int a2)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__RefCounted;
    *(void *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 8) = a2;
  }
  return result;
}

uint64_t RefCounted_DecRefCount(uint64_t a1)
{
  if (atomic_decrement((_DWORD *)(a1 + 8)) != 1) {
    return 0;
  }
  *(_DWORD *)(a1 + 8) = 1;
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    return OOC_PlacementDeleteObject(v2, a1);
  }
  else
  {
    uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 16);
    return v4(a1);
  }
}

uint64_t RefCounted_GetRefCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t RefCounted_IncRefCount(uint64_t a1)
{
  return atomic_increment((_DWORD *)(a1 + 8));
}

uint64_t PNEW_RefCounted_Con(uint64_t a1, int a2, uint64_t *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = OOCAllocator_Malloc(a1, 24, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = Object_Con((void *)v6);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *(void *)uint64_t v6 = &__RefCounted;
      *(_DWORD *)(v6 + 8) = a2;
      *(void *)(v6 + 16) = a1;
      *a3 = v6;
    }
  }
  return result;
}

void *GetRefCountedClass()
{
  return &__RefCounted;
}

uint64_t OOCAllocator_Con(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  long long v3 = a2[1];
  *(_OWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 16) = v3;
  *(void *)(a1 + 32) = a3;
  return 0;
}

uint64_t OOCAllocator_ConWithLogging(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4)
{
  long long v4 = a3[1];
  *(_OWORD *)a1 = *a3;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = a4;
  return 0;
}

uint64_t OOCAllocator_Des()
{
  return 0;
}

uint64_t OOCAllocator_Calloc(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  if (!a2)
  {
    int ErrorInternal = err_GenerateErrorInternal();
LABEL_6:
    uint64_t v6 = 0;
    goto LABEL_7;
  }
  uint64_t v5 = (*(uint64_t (**)(void))(a1 + 8))(*(void *)(a1 + 32));
  if (!v5)
  {
    int ErrorInternal = err_GenerateErrorResource();
    goto LABEL_6;
  }
  uint64_t v6 = v5;
  int ErrorInternal = 0;
LABEL_7:
  *a4 = ErrorInternal;
  return v6;
}

uint64_t OOCAllocator_Free(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(result + 24))(*(void *)(result + 32));
  }
  return result;
}

uint64_t OOCAllocator_Malloc(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2)
  {
    int ErrorInternal = err_GenerateErrorInternal();
LABEL_6:
    uint64_t v5 = 0;
    goto LABEL_7;
  }
  uint64_t v4 = (*(uint64_t (**)(void))a1)(*(void *)(a1 + 32));
  if (!v4)
  {
    int ErrorInternal = err_GenerateErrorResource();
    goto LABEL_6;
  }
  uint64_t v5 = v4;
  int ErrorInternal = 0;
LABEL_7:
  *a3 = ErrorInternal;
  return v5;
}

uint64_t OOCAllocator_Realloc(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  if (!a3)
  {
    int ErrorInternal = err_GenerateErrorInternal();
LABEL_6:
    uint64_t v6 = 0;
    goto LABEL_7;
  }
  uint64_t v5 = (*(uint64_t (**)(void))(a1 + 16))(*(void *)(a1 + 32));
  if (!v5)
  {
    int ErrorInternal = err_GenerateErrorResource();
    goto LABEL_6;
  }
  uint64_t v6 = v5;
  int ErrorInternal = 0;
LABEL_7:
  *a4 = ErrorInternal;
  return v6;
}

__n128 PNEW_OOCAllocator_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v7 = (*(uint64_t (**)(void, uint64_t))a1)(*(void *)(a1 + 32), 40);
  if (v7 || !err_GenerateErrorResource())
  {
    __n128 result = *(__n128 *)a2;
    long long v9 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
    *(_OWORD *)(v7 + 16) = v9;
    *(void *)(v7 + 32) = a3;
    *a4 = v7;
  }
  return result;
}

uint64_t PDELETE_OOCAllocator(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(void))(a1 + 24))(*(void *)(a1 + 32));
  }
  return 0;
}

uint64_t compare_and_swap(_DWORD *a1, int a2, int a3)
{
  uint64_t result = *a1;
  if (result == a2) {
    *a1 = a3;
  }
  return result;
}

uint64_t atomic_increment(_DWORD *a1)
{
  uint64_t v1 = *a1;
  *a1 = v1 + 1;
  return v1;
}

uint64_t atomic_decrement(_DWORD *a1)
{
  uint64_t v1 = *a1;
  *a1 = v1 - 1;
  return v1;
}

uint64_t PtrList_Con(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)(a1 + 32) = a2;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = &__PtrList;
    *(_DWORD *)(a1 + 24) = a4;
    return _PtrList_ResizeList(a1, a3);
  }
  return result;
}

uint64_t _PtrList_ResizeList(uint64_t a1, unsigned int a2)
{
  uint64_t result = 0;
  unsigned int v8 = 0;
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  if (v4 < a2)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 24) + v4;
    if (v5 <= a2) {
      unsigned int v6 = a2;
    }
    else {
      unsigned int v6 = v5;
    }
    uint64_t v7 = OOCAllocator_Realloc(*(void *)(a1 + 32), *(void *)(a1 + 8), 8 * v6, &v8);
    uint64_t result = v8;
    if (!v8)
    {
      *(void *)(a1 + 8) = v7;
      *(_DWORD *)(a1 + 20) = v6;
    }
  }
  return result;
}

uint64_t PtrList_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    OOCAllocator_Free(*(void *)(a1 + 32), v2);
    *(void *)(a1 + 8) = 0;
  }

  return Object_Des();
}

uint64_t PtrList_Append(uint64_t a1, uint64_t a2)
{
  uint64_t result = _PtrList_ResizeList(a1, *(_DWORD *)(a1 + 16) + 1);
  if (!result)
  {
    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v6 = *(unsigned int *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = v6 + 1;
    *(void *)(v5 + 8 * v6) = a2;
  }
  return result;
}

uint64_t PtrList_CreateSubList(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t *a4)
{
  unsigned int v5 = a3;
  uint64_t result = PNEW_PtrList_Con(*(void *)(a1 + 32), *(void *)(a1 + 32), a3, (a3 >> 1) + 1, a4);
  if (!result)
  {
    if (v5 + a2 <= a2)
    {
      return 0;
    }
    else
    {
      for (uint64_t i = 8 * a2; ; i += 8)
      {
        uint64_t v10 = *a4;
        uint64_t v11 = *(void *)(*(void *)(a1 + 8) + i);
        uint64_t result = _PtrList_ResizeList(*a4, *(_DWORD *)(*a4 + 16) + 1);
        if (result) {
          break;
        }
        uint64_t v12 = *(void *)(v10 + 8);
        uint64_t v13 = *(unsigned int *)(v10 + 16);
        *(_DWORD *)(v10 + 16) = v13 + 1;
        *(void *)(v12 + 8 * v13) = v11;
        if (!--v5) {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t PNEW_PtrList_Con(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t *a5)
{
  unsigned int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 40, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = PtrList_Con(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *a5 = v10;
    }
  }
  return result;
}

uint64_t PtrList_ItemN(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 8) + 8 * a2);
}

uint64_t PtrList_Find(uint64_t a1, uint64_t a2, unsigned int (*a3)(uint64_t *, uint64_t *))
{
  uint64_t v7 = 0;
  uint64_t v8 = a2;
  if (!*(_DWORD *)(a1 + 16)) {
    return 0;
  }
  uint64_t v5 = 0;
  while (1)
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 8) + 8 * v5);
    if (!a3(&v8, &v7)) {
      break;
    }
    if (++v5 >= (unint64_t)*(unsigned int *)(a1 + 16)) {
      return 0;
    }
  }
  return v7;
}

uint64_t PtrList_NrItems(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t PtrList_Insert(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t result = _PtrList_ResizeList(a1, *(_DWORD *)(a1 + 16) + 1);
  if (!result)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (v7 > a2)
    {
      uint64_t v8 = 8 * v7;
      uint64_t v9 = 8 * (v7 - 1);
      unsigned int v10 = *(_DWORD *)(a1 + 16);
      do
      {
        *(void *)(*(void *)(a1 + 8) + v8) = *(void *)(*(void *)(a1 + 8) + v9);
        v8 -= 8;
        v9 -= 8;
        --v10;
      }
      while (v10 > a2);
    }
    *(void *)(*(void *)(a1 + 8) + 8 * a2) = a3;
    *(_DWORD *)(a1 + 16) = v7 + 1;
  }
  return result;
}

uint64_t PtrList_Prepend(uint64_t a1, uint64_t a2)
{
  uint64_t result = _PtrList_ResizeList(a1, *(_DWORD *)(a1 + 16) + 1);
  if (!result)
  {
    int v5 = *(_DWORD *)(a1 + 16);
    if (v5)
    {
      uint64_t v6 = *(unsigned int *)(a1 + 16);
      do
      {
        *(void *)(*(void *)(a1 + 8) + 8 * v6) = *(void *)(*(void *)(a1 + 8) + 8 * (v6 - 1));
        --v6;
      }
      while (v6);
    }
    **(void **)(a1 + 8) = a2;
    *(_DWORD *)(a1 + 16) = v5 + 1;
  }
  return result;
}

uint64_t PtrList_Remove(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 16);
  if (v2)
  {
    uint64_t v3 = 0;
    while (*(void *)(*(void *)(result + 8) + 8 * v3) != a2)
    {
      if (v2 == ++v3) {
        return result;
      }
    }
    uint64_t v4 = (v2 - 1);
    if (v4 > v3)
    {
      do
      {
        *(void *)(*(void *)(result + 8) + 8 * v3) = *(void *)(*(void *)(result + 8) + 8 * v3 + 8);
        ++v3;
      }
      while (v4 != v3);
    }
    *(_DWORD *)(result + 16) = v4;
  }
  return result;
}

uint64_t PtrList_RemoveAll(uint64_t result)
{
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t PtrList_SetItemN(uint64_t result, unsigned int a2, uint64_t a3)
{
  *(void *)(*(void *)(result + 8) + 8 * a2) = a3;
  return result;
}

uint64_t PtrList_Sort(uint64_t result, uint64_t (*a2)(unsigned char *, unsigned char *))
{
  unsigned int v3 = *(_DWORD *)(result + 16);
  if (v3) {
    return lhstdlib_qsort(*(void *)(result + 8), v3, 8u, a2);
  }
  return result;
}

uint64_t PtrList_StUdSort(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 0;
  unsigned int v9 = 0;
  uint64_t v5 = *(unsigned int *)(a1 + 16);
  if (v5 >= 2)
  {
    uint64_t v8 = OOCAllocator_Malloc(*(void *)(a1 + 32), 4 * v5, &v9);
    uint64_t result = v9;
    if (!v9)
    {
      lhstdlib_studqsort(*(void *)(a1 + 8), *(_DWORD *)(a1 + 16), 8u, v8, a3, a2);
      OOCAllocator_Free(*(void *)(a1 + 32), v8);
      return v9;
    }
  }
  return result;
}

uint64_t PtrList_UdSort(uint64_t result, uint64_t (*a2)(char *, char *, uint64_t), uint64_t a3)
{
  unsigned int v4 = *(_DWORD *)(result + 16);
  if (v4) {
    return lhstdlib_udqsort(*(void *)(result + 8), v4, 8u, a3, a2);
  }
  return result;
}

uint64_t _PtrList_BorrowPtrListAllocator(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void *GetPtrListClass()
{
  return &__PtrList;
}

uint64_t AVLTree_Con(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t a5)
{
  uint64_t result = Object_Con((void *)a1);
  unsigned int v11 = result;
  if (!result)
  {
    *(void *)a1 = &__AVLTree;
    *(void *)(a1 + 24) = a2;
    *(_DWORD *)(a1 + 32) = a3;
    *(_DWORD *)(a1 + 36) = a4;
    *(void *)(a1 + 40) = a5;
    *(void *)(a1 + 48) = 0x1FFFFFFF00000000;
    *(_DWORD *)(a1 + 16) = 0x1FFFFFFF;
    *(_DWORD *)(a1 + 56) = 0;
    *(void *)(a1 + 8) = OOCAllocator_Malloc(a2, 16 * a3, &v11);
    return v11;
  }
  return result;
}

uint64_t AVLTree_Des(uint64_t a1)
{
  OOCAllocator_Free(*(void *)(a1 + 24), *(void *)(a1 + 8));

  return Object_Des();
}

uint64_t AVLTree_Find(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4)
{
  unsigned int v4 = *(_DWORD *)(a1 + 48);
  if (v4)
  {
    if (v4 == 1)
    {
      unsigned int v5 = 1;
    }
    else
    {
      unsigned int v5 = 1;
      do
      {
        ++v5;
        BOOL v7 = v4 > 3;
        v4 >>= 1;
      }
      while (v7);
    }
    unsigned int v8 = 0;
    *a3 = *(_DWORD *)(a1 + 16);
    return _AVLTree_FindInSubTree(a1, v5 + (v5 >> 1), &v8, a2, a3, a4);
  }
  else
  {
    uint64_t result = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t _AVLTree_FindInSubTree(uint64_t a1, unsigned int a2, unsigned int *a3, uint64_t a4, int *a5, _DWORD *a6)
{
  unsigned int v6 = *a3 + 1;
  *a3 = v6;
  if (v6 > a2)
  {
LABEL_8:
    return err_GenerateErrorLimit();
  }
  while (1)
  {
    Iteunsigned int m = AVLNode_GetItem(*(void *)(a1 + 8) + 16 * *a5);
    int v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 40))(a4, Item);
    if (!v14)
    {
      *a6 = 1;
      return 0;
    }
    uint64_t v15 = *a5;
    if (v14 < 0) {
      break;
    }
    int RightIx = AVLNode_GetRightIx(*(void *)(a1 + 8) + 16 * v15);
    *a5 = RightIx;
    if (RightIx == 0x1FFFFFFF) {
      goto LABEL_12;
    }
LABEL_7:
    unsigned int v18 = *a3 + 1;
    *a3 = v18;
    if (v18 > a2) {
      goto LABEL_8;
    }
  }
  int v17 = *(_DWORD *)(*(void *)(a1 + 8) + 16 * v15) & 0x1FFFFFFF;
  *a5 = v17;
  if (v17 != 0x1FFFFFFF) {
    goto LABEL_7;
  }
LABEL_12:
  *a6 = 0;
  return 0;
}

uint64_t AVLTree_Insert(uint64_t a1, uint64_t a2, int *a3)
{
  unsigned int v3 = *(_DWORD *)(a1 + 48);
  unsigned int v4 = 2;
  if (v3 >= 2)
  {
    do
    {
      ++v4;
      BOOL v5 = v3 > 3;
      v3 >>= 1;
    }
    while (v5);
  }
  unsigned int v7 = 0;
  return _AVLTree_InsertToSubTree(a1, v4 + (v4 >> 1), &v7, a2, (int *)(a1 + 16), a3);
}

uint64_t _AVLTree_InsertToSubTree(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, int *a5, int *a6)
{
  unsigned int v7 = *a3 + 1;
  *a3 = v7;
  if (v7 > a2)
  {
    uint64_t result = err_GenerateErrorLimit();
    goto LABEL_13;
  }
  uint64_t v13 = *a5;
  if (v13 == 0x1FFFFFFF)
  {
    uint64_t result = _AVLTree_GetNewIndex(a1, a5);
    if (result) {
      goto LABEL_13;
    }
    uint64_t result = AVLNode_Con((void *)(*(void *)(a1 + 8) + 16 * *a5), a4);
    *(_DWORD *)(a1 + 56) = 1;
LABEL_12:
    *a6 = *a5;
    goto LABEL_13;
  }
  Iteunsigned int m = AVLNode_GetItem(*(void *)(a1 + 8) + 16 * v13);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 40))(a4, Item);
  if (!result)
  {
    *(_DWORD *)(a1 + 56) = 0;
    goto LABEL_12;
  }
  uint64_t v16 = *a5;
  if ((result & 0x80000000) != 0)
  {
    int RightIx = *(_DWORD *)(*(void *)(a1 + 8) + 16 * v16) & 0x1FFFFFFF;
    uint64_t result = _AVLTree_InsertToSubTree(a1, a2, a3, a4, &RightIx, a6);
    if (result) {
      goto LABEL_13;
    }
    uint64_t v17 = *(void *)(a1 + 8);
    *(_DWORD *)(v17 + 16 * *a5) &= 0xE0000000;
    *(_DWORD *)(v17 + 16 * *a5) |= RightIx & 0x1FFFFFFF;
    if (!*(_DWORD *)(a1 + 56)) {
      goto LABEL_18;
    }
    int v18 = -536870912;
  }
  else
  {
    int RightIx = AVLNode_GetRightIx(*(void *)(a1 + 8) + 16 * v16);
    uint64_t result = _AVLTree_InsertToSubTree(a1, a2, a3, a4, &RightIx, a6);
    if (result) {
      goto LABEL_13;
    }
    uint64_t v17 = *(void *)(a1 + 8);
    *(_DWORD *)(v17 + 16 * *a5 + 4) = RightIx;
    if (!*(_DWORD *)(a1 + 56)) {
      goto LABEL_18;
    }
    int v18 = 0x20000000;
  }
  *(_DWORD *)(v17 + 16 * *a5) += v18;
LABEL_18:
  int v19 = *(_DWORD *)(v17 + 16 * *a5);
  uint64_t result = 0;
  switch(v19 >> 29)
  {
    case -2:
      if (*(_DWORD *)(v17 + 16 * (v19 & 0x1FFFFFFF)) >> 29 == 1)
      {
        int v22 = v19 & 0x1FFFFFFF;
        _AVLTree_RotateLeft(a1, &v22);
        uint64_t v20 = *(void *)(a1 + 8);
        *(_DWORD *)(v20 + 16 * *a5) &= 0xE0000000;
        *(_DWORD *)(v20 + 16 * *a5) |= v22 & 0x1FFFFFFF;
      }
      _AVLTree_RotateRight(a1, a5);
      goto LABEL_25;
    case -1:
    case 1:
      break;
    case 0:
      goto LABEL_25;
    case 2:
      if (*(_DWORD *)(v17 + 16 * AVLNode_GetRightIx(v17 + 16 * *a5)) >> 29 == 7)
      {
        int v21 = AVLNode_GetRightIx(*(void *)(a1 + 8) + 16 * *a5);
        _AVLTree_RotateRight(a1, &v21);
        *(_DWORD *)(*(void *)(a1 + 8) + 16 * *a5 + 4) = v21;
      }
      _AVLTree_RotateLeft(a1, a5);
LABEL_25:
      uint64_t result = 0;
      *(_DWORD *)(a1 + 56) = 0;
      break;
    default:
      uint64_t result = err_GenerateErrorInternal();
      break;
  }
LABEL_13:
  --*a3;
  return result;
}

uint64_t AVLTree_ItemN(uint64_t a1, unsigned int a2)
{
  return AVLNode_GetItem(*(void *)(a1 + 8) + 16 * a2);
}

uint64_t AVLTree_NrItems(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t _AVLTree_Enlarge(uint64_t a1)
{
  unsigned int v3 = 0;
  unsigned int v1 = *(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 32) = v1;
  *(void *)(a1 + 8) = OOCAllocator_Realloc(*(void *)(a1 + 24), *(void *)(a1 + 8), 16 * v1, &v3);
  return v3;
}

uint64_t _AVLTree_GetNewIndex(uint64_t a1, _DWORD *a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 32);
  unsigned int v5 = *(_DWORD *)(a1 + 48) + 1;
  if (v4 < v5)
  {
    unsigned int v10 = 0;
    unsigned int v6 = *(_DWORD *)(a1 + 36) + v4;
    *(_DWORD *)(a1 + 32) = v6;
    *(void *)(a1 + 8) = OOCAllocator_Realloc(*(void *)(a1 + 24), *(void *)(a1 + 8), 16 * v6, &v10);
    uint64_t result = v10;
    if (v10) {
      return result;
    }
    unsigned int v5 = *(_DWORD *)(a1 + 48) + 1;
  }
  uint64_t result = 0;
  int v8 = *(_DWORD *)(a1 + 52);
  if (v8 == 0x1FFFFFFF) {
    int v9 = 0;
  }
  else {
    int v9 = v8 + 1;
  }
  *(_DWORD *)(a1 + 48) = v5;
  *(_DWORD *)(a1 + 52) = v9;
  *a2 = v9;
  return result;
}

uint64_t _AVLTree_RotateLeft(uint64_t a1, _DWORD *a2)
{
  unsigned int v4 = (int *)(*(void *)(a1 + 8) + 16 * *a2);
  uint64_t result = AVLNode_GetRightIx((uint64_t)v4);
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = 16 * result;
  int v8 = *(_DWORD *)(v6 + v7);
  *(_DWORD *)(v6 + v7) = v8 & 0xE0000000;
  v4[1] = v8 & 0x1FFFFFFF;
  *(_DWORD *)(v6 + v7) = v8 & 0xE0000000 | *a2 & 0x1FFFFFFF;
  *a2 = result;
  int v9 = *(_DWORD *)(v6 + v7);
  int v10 = ~((v9 >> 29) & ~(v9 >> 31)) + (*v4 >> 29);
  *unsigned int v4 = *v4 & 0x1FFFFFFF | ((~((v9 >> 29) & ~(v9 >> 31)) + (*v4 >> 29)) << 29);
  *(_DWORD *)(v6 + v7) = (*(_DWORD *)(v6 + v7) & 0x1FFFFFFF | (((v10 & (v10 >> 31)) + (v9 >> 29)) << 29))
                       - 0x20000000;
  return result;
}

uint64_t _AVLTree_RotateRight(uint64_t a1, int *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = 16 * *a2;
  int v5 = *(_DWORD *)(v3 + v4);
  int v6 = v5 & 0x1FFFFFFF;
  uint64_t v7 = (int *)(v3 + 16 * (v5 & 0x1FFFFFFF));
  *(_DWORD *)(v3 + v4) = v5 & 0xE0000000;
  uint64_t result = AVLNode_GetRightIx((uint64_t)v7);
  *(_DWORD *)(v3 + v4) |= result & 0x1FFFFFFF;
  v7[1] = *a2;
  *a2 = v6;
  int v9 = *(_DWORD *)(v3 + v4);
  int v10 = *v7;
  int v11 = (v9 >> 29) - ((v10 >> 29) & (v10 >> 31)) + 1;
  *(_DWORD *)(v3 + v4) = v9 & 0x1FFFFFFF | (v11 << 29);
  int *v7 = (*v7 & 0x1FFFFFFF | (((v11 & ~(v11 >> 31)) + (v10 >> 29)) << 29)) + 0x20000000;
  return result;
}

uint64_t PNEW_AVLTree_Con(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 64, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = AVLTree_Con(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *a6 = v12;
    }
  }
  return result;
}

void *GetAVLTreeClass()
{
  return &__AVLTree;
}

uint64_t AVLNode_Con(void *a1, uint64_t a2)
{
  a1[1] = a2;
  *a1 = 0xE0000000E0000000;
  return 0;
}

uint64_t AVLNode_GetItem(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t AVLNode_GetRightIx(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

double PNEW_AVLNode_Con(uint64_t a1, uint64_t a2, void *a3)
{
  int v7 = 0;
  int v5 = (void *)OOCAllocator_Malloc(a1, 16, &v7);
  if (!v7)
  {
    v5[1] = a2;
    double result = -2.68156382e154;
    void *v5 = 0xE0000000E0000000;
    *a3 = v5;
  }
  return result;
}

uint64_t PDELETE_AVLNode(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t PtrStack_Con(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 16) = a3;
    *(void *)a1 = &__PtrStack;
    *(void *)(a1 + 8) = a2;
  }
  return result;
}

uint64_t PtrStack_Des(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    OOCAllocator_Free(*(void *)(a1 + 8), v1);
  }

  return Object_Des();
}

BOOL PtrStack_Has(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  unint64_t v3 = *(unsigned int *)(a1 + 24);
  if (v3)
  {
    for (unint64_t i = 0; i < v3; ++i)
    {
      if (*(void *)(*(void *)(a1 + 32) + 8 * i) == a2) {
        break;
      }
      if (a3)
      {
        int v8 = a3();
        unint64_t v3 = *(unsigned int *)(a1 + 24);
        if (!v8) {
          break;
        }
      }
    }
    unint64_t v9 = i;
  }
  else
  {
    unint64_t v3 = 0;
    unint64_t v9 = 0;
  }
  return v9 < v3;
}

uint64_t PtrStack_Put(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  unsigned int v5 = v4 + 1;
  if (v4 + 1 <= *(_DWORD *)(a1 + 20))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    goto LABEL_5;
  }
  unsigned int v9 = 0;
  uint64_t v6 = OOCAllocator_Realloc(*(void *)(a1 + 8), *(void *)(a1 + 32), 8 * (*(_DWORD *)(a1 + 16) + v4), &v9);
  *(void *)(a1 + 32) = v6;
  uint64_t v7 = v9;
  if (!v9)
  {
    *(_DWORD *)(a1 + 20) += *(_DWORD *)(a1 + 16);
    unsigned int v4 = *(_DWORD *)(a1 + 24);
    unsigned int v5 = v4 + 1;
LABEL_5:
    uint64_t v7 = 0;
    *(void *)(v6 + 8 * v4) = a2;
    *(_DWORD *)(a1 + 24) = v5;
  }
  return v7;
}

uint64_t PtrStack_Remove(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 24);
  if (!v1) {
    return 3;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 24) = v1 - 1;
  return result;
}

uint64_t PNEW_PtrStack_Con(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 40, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = Object_Con((void *)v8);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *(void *)(v8 + 32) = 0;
      *(_DWORD *)(v8 + 20) = 0;
      *(_DWORD *)(v8 + 24) = 0;
      *(_DWORD *)(v8 + 16) = a3;
      *(void *)uint64_t v8 = &__PtrStack;
      *(void *)(v8 + 8) = a2;
      *a4 = v8;
    }
  }
  return result;
}

void *GetPtrStackClass()
{
  return &__PtrStack;
}

uint64_t ElementArray_Con(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__ElementArray;
    *(void *)(a1 + 8) = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 28) = a4;
    *(_DWORD *)(a1 + 32) = 0;
    *(void *)(a1 + 16) = 0;
    return ElementArray_ResizeArray(a1, a3);
  }
  return result;
}

uint64_t ElementArray_ResizeArray(uint64_t a1, int a2)
{
  unsigned int v10 = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = *(unsigned int *)(a1 + 28);
  if (v5) {
    uint64_t v7 = v5 - v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = OOCAllocator_Realloc(v4, v7, (v6 + v6 * a2), &v10);
  uint64_t result = v10;
  if (!v10)
  {
    *(void *)(a1 + 16) = v8 + *(unsigned int *)(a1 + 28);
    *(_DWORD *)(a1 + 24) = a2;
    *(_DWORD *)(a1 + 32) = a2;
  }
  return result;
}

uint64_t ElementArray_Con2(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__ElementArray;
    uint64_t result = ElementArray_Con(a1, a2, a3, a4);
    if (!result) {
      *(_DWORD *)(a1 + 24) = 0;
    }
  }
  return result;
}

uint64_t ElementArray_Des(uint64_t a1)
{
  OOCAllocator_Free(*(void *)(a1 + 8), *(void *)(a1 + 16) - *(unsigned int *)(a1 + 28));

  return Object_Des();
}

uint64_t ElementArray_Clear(uint64_t result)
{
  *(_DWORD *)(result + 24) = 0;
  return result;
}

BOOL ElementArray_IsFull(uint64_t a1)
{
  return *(_DWORD *)(a1 + 24) == *(_DWORD *)(a1 + 32);
}

uint64_t ElementArray_ItemLast(uint64_t a1, _DWORD *a2)
{
  int v9 = 0;
  int v4 = *(_DWORD *)(a1 + 24);
  if (v4 != *(_DWORD *)(a1 + 32)) {
    goto LABEL_8;
  }
  if (v4) {
    int v5 = 2 * v4;
  }
  else {
    int v5 = 1;
  }
  uint64_t v6 = OOCAllocator_Realloc(*(void *)(a1 + 8), *(void *)(a1 + 16) - *(unsigned int *)(a1 + 28), (*(_DWORD *)(a1 + 28) + *(_DWORD *)(a1 + 28) * v5), &v9);
  if (!v9)
  {
    *(_DWORD *)(a1 + 32) = v5;
    *(void *)(a1 + 16) = v6 + *(unsigned int *)(a1 + 28);
LABEL_8:
    *a2 = 0;
    int v7 = *(_DWORD *)(a1 + 24);
    uint64_t result = *(void *)(a1 + 16) + (*(_DWORD *)(a1 + 28) * v7);
    goto LABEL_9;
  }
  *a2 = v9;
  int v7 = *(_DWORD *)(a1 + 24);
  uint64_t result = *(void *)(a1 + 16) - *(unsigned int *)(a1 + 28);
LABEL_9:
  *(_DWORD *)(a1 + 24) = v7 + 1;
  return result;
}

uint64_t ElementArray_ItemN(uint64_t a1, int a2)
{
  return *(void *)(a1 + 16) + (*(_DWORD *)(a1 + 28) * a2);
}

uint64_t ElementArray_ReallocArray(uint64_t a1, unsigned int a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  uint64_t result = ElementArray_ResizeArray(a1, a2);
  if (!result && v4 < a2) {
    *(_DWORD *)(a1 + 24) = v4;
  }
  return result;
}

_DWORD *ElementArray_RemoveRange(_DWORD *result, unsigned int a2, unsigned int a3)
{
  unsigned int v3 = a2 - a3;
  if (a2 < a3)
  {
    unsigned int v4 = result;
    unsigned int v5 = result[6];
    if (v5 > a3)
    {
      uint64_t result = cstdlib_memmove((void *)(*((void *)result + 2) + result[7] * a2), (const void *)(*((void *)result + 2) + result[7] * a3), result[7] * (v5 - a3));
      unsigned int v5 = v4[6];
    }
    v4[6] = v3 + v5;
  }
  return result;
}

uint64_t PNEW_ElementArray_Con(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t *a5)
{
  unsigned int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 40, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = ElementArray_Con(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *a5 = v10;
    }
  }
  return result;
}

uint64_t PNEW_ElementArray_Con2(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t *a5)
{
  unsigned int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 40, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = ElementArray_Con2(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *a5 = v10;
    }
  }
  return result;
}

void *GetElementArrayClass()
{
  return &__ElementArray;
}

uint64_t PtrQueue_Con(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__PtrQueue;
    *(void *)(a1 + 8) = 0;
    uint64_t result = PNEW_PtrList_Con(a2, a2, a3, a4, (uint64_t *)(a1 + 8));
    if (!result)
    {
      *(void *)(a1 + 24) = a2;
      *(_DWORD *)(a1 + 16) = a3;
      *(_DWORD *)(a1 + 20) = a4;
    }
  }
  return result;
}

uint64_t PtrQueue_Des(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    OOC_PlacementDeleteObject(*(void *)(a1 + 24), v1);
  }
  Object_Des();
  return 0;
}

BOOL PtrQueue_Has(uint64_t a1, uint64_t a2, unsigned int (*a3)(uint64_t, uint64_t))
{
  unsigned int v4 = _PtrQueue_Find(a1, a2, a3);
  return v4 < PtrList_NrItems(*(void *)(a1 + 8));
}

uint64_t _PtrQueue_Find(uint64_t a1, uint64_t a2, unsigned int (*a3)(uint64_t, uint64_t))
{
  for (uint64_t i = 0; i < PtrList_NrItems(*(void *)(a1 + 8)); uint64_t i = (i + 1))
  {
    if (PtrList_ItemN(*(void *)(a1 + 8), i) == a2) {
      break;
    }
    if (a3)
    {
      uint64_t v7 = PtrList_ItemN(*(void *)(a1 + 8), i);
      if (!a3(v7, a2)) {
        break;
      }
    }
  }
  return i;
}

BOOL PtrQueue_IsEmpty(uint64_t a1)
{
  return PtrList_NrItems(*(void *)(a1 + 8)) == 0;
}

BOOL PtrQueue_IsFull(uint64_t a1)
{
  return !*(_DWORD *)(a1 + 20) && PtrList_NrItems(*(void *)(a1 + 8)) == *(_DWORD *)(a1 + 16);
}

uint64_t PtrQueue_Item(uint64_t a1)
{
  if (!PtrList_NrItems(*(void *)(a1 + 8))) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 8);

  return PtrList_ItemN(v2, 0);
}

uint64_t PtrQueue_ItemN(uint64_t a1, unsigned int a2)
{
  return PtrList_ItemN(*(void *)(a1 + 8), a2);
}

uint64_t PtrQueue_NrItems(uint64_t a1)
{
  return PtrList_NrItems(*(void *)(a1 + 8));
}

uint64_t PtrQueue_Put(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 20) || PtrList_NrItems(*(void *)(a1 + 8)) != *(_DWORD *)(a1 + 16))
  {
    uint64_t v5 = *(void *)(a1 + 8);
    return PtrList_Append(v5, a2);
  }
  else
  {
    return err_GenerateErrorLimit();
  }
}

uint64_t PtrQueue_Remove(uint64_t a1)
{
  if (PtrList_NrItems(*(void *)(a1 + 8)) || (uint64_t result = err_GenerateErrorState(), !result))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v4 = PtrQueue_Item(a1);
    PtrList_Remove(v3, v4);
    return 0;
  }
  return result;
}

uint64_t PtrQueue_SetItemN(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return PtrList_SetItemN(*(void *)(a1 + 8), a2, a3);
}

uint64_t PtrQueue_Sort(uint64_t a1, uint64_t (*a2)(unsigned char *, unsigned char *))
{
  return PtrList_Sort(*(void *)(a1 + 8), a2);
}

uint64_t PNEW_PtrQueue_Con(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t *a5)
{
  unsigned int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 32, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = PtrQueue_Con(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *a5 = v10;
    }
  }
  return result;
}

void *GetPtrQueueClass()
{
  return &__PtrQueue;
}

uint64_t BinBlockStreamWriter_Con(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5, int a6, int a7, int a8)
{
  return _BinBlockStreamWriter_Con2(a1, a2, a3, a4, a5, a6, a7, a8, 0);
}

uint64_t _BinBlockStreamWriter_Con2(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5, int a6, int a7, int a8, int a9)
{
  uint64_t result = BinBlockStreamWriter_ConTypeLess(a1, a2, a3, a4, a5);
  if (!result)
  {
    *(_DWORD *)(a1 + 76) = a9;
    if (a8)
    {
      return BinBlockStreamWriter_WriteHeader(a1, a6, a7, a8);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t BinBlockStreamWriter_ConTypeLess(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t result = RefCounted_Con(a1, 1);
  unsigned int v13 = result;
  if (!result)
  {
    *(void *)a1 = &__BinBlockStreamWriter;
    *(void *)(a1 + 24) = &unk_26D217DF0;
    int v11 = (void *)OOCAllocator_Malloc(a2, 32, &v13);
    *(void *)(a1 + 48) = v11;
    uint64_t result = v13;
    if (!v13)
    {
      cstdlib_memcpy(v11, a3, 0x20uLL);
      *(void *)(a1 + 56) = a4;
      if (a5)
      {
        *(_DWORD *)(a1 + 72) = *a5;
        unsigned int v12 = (void *)OOCAllocator_Malloc(a2, 4, &v13);
        *(void *)(a1 + 64) = v12;
        uint64_t result = v13;
        if (v13) {
          return result;
        }
        cstdlib_memcpy(v12, a5, 4uLL);
      }
      else
      {
        *(void *)(a1 + 64) = 0;
        *(_DWORD *)(a1 + 72) = 1;
      }
      *(_WORD *)(a1 + 88) = 4;
      *(void *)(a1 + 32) = 0;
      *(void *)(a1 + 40) = a2;
      *(_WORD *)(a1 + 108) = 0;
      *(_DWORD *)(a1 + 76) = 0;
      *(void *)(a1 + 96) = 0;
      *(void *)(a1 + 112) = 0;
      *(void *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 128) = 0;
      return v13;
    }
  }
  return result;
}

uint64_t BinBlockStreamWriter_WriteHeader(uint64_t a1, int a2, int a3, __int16 a4)
{
  unsigned int v12 = 0;
  if ((*(unsigned int (**)(uint64_t))(*(void *)(a1 + 24) + 80))(a1 + 24 - *(void *)(*(void *)(a1 + 24) + 120)))
  {
    return err_GenerateErrorInternal();
  }
  else
  {
    *(_WORD *)(a1 + 104) = 12 * a4 + 4;
    __int16 v9 = 12 * a4 + 8;
    if (!*(_DWORD *)(a1 + 72)) {
      __int16 v9 = 12 * a4 + 4;
    }
    *(_WORD *)(a1 + 106) = v9;
    uint64_t v10 = (void *)OOCAllocator_Malloc(*(void *)(a1 + 40), (unsigned __int16)(12 * a4 + 4) & 0xFFFC, &v12);
    *(void *)(a1 + 96) = v10;
    uint64_t v11 = v12;
    if (!v12)
    {
      cstdlib_memset(v10, 255, 4uLL);
      cstdlib_memset((void *)(*(void *)(a1 + 96) + 4), 0, *(unsigned __int16 *)(a1 + 104) - 4);
      *(_WORD *)(a1 + 110) = a4;
      *(_DWORD *)(a1 + 80) = a2;
      *(_DWORD *)(a1 + 84) = a3;
      return _BinBlockStreamWriter_WriteHeaderAndToc(a1, 0);
    }
    return v11;
  }
}

uint64_t BinBlockStreamWriter_Des(void *a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(a1[3] + 72))((uint64_t)a1 - *(void *)(a1[3] + 120) + 24);
  if (!result)
  {
    uint64_t v3 = a1[12];
    if (v3) {
      OOCAllocator_Free(a1[5], v3);
    }
    return RefCounted_Des(a1);
  }
  return result;
}

uint64_t BinBlockStreamWriter_AddDependencies(uint64_t a1, int *a2, const char **a3, uint64_t a4)
{
  uint64_t v26 = 0;
  uint64_t v8 = a1 + 24;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)(a1 + 24) + 32))(a1 + 24 - *(void *)(*(void *)(a1 + 24) + 120), 270065117, 0x10000, &v26);
  unsigned int v27 = result;
  if (!result)
  {
    uint64_t v10 = v8;
    uint64_t v11 = 0;
    if (a4)
    {
      unsigned int v12 = a3;
      uint64_t v13 = a4;
      do
      {
        unsigned int v14 = *v12++;
        v11 += (cstdlib_strlen(v14) & 0xFFFFFFFFFFFFFFFCLL) + 8;
        --v13;
      }
      while (v13);
    }
    uint64_t v15 = OOCAllocator_Malloc(*(void *)(a1 + 40), v11, &v27);
    uint64_t result = v27;
    if (!v27)
    {
      uint64_t v24 = a1;
      uint64_t v25 = v15;
      if (a4)
      {
        uint64_t v16 = (_DWORD *)v15;
        do
        {
          int v17 = *a2++;
          _DWORD *v16 = v17;
          size_t v18 = cstdlib_strlen(*a3);
          char v19 = v18;
          unint64_t v20 = v18 + 1;
          unint64_t v21 = v18 & 0xFFFFFFFFFFFFFFFCLL;
          unint64_t v22 = (v18 & 0xFFFFFFFFFFFFFFFCLL) + 4;
          cstdlib_memcpy(v16 + 1, *a3, v18 + 1);
          uint64_t v23 = (char *)v16 + v20 + 4;
          if (v20 < v22)
          {
            bzero(v23, ~v19 & 3);
            uint64_t v23 = (char *)v16 + v21 + 8;
          }
          ++a3;
          uint64_t v16 = v23;
          --a4;
        }
        while (a4);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v26 + 8))(v26 - *(void *)(*(void *)v26 + 56), v25, v11);
      unsigned int v27 = result;
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 48))(v10 - *(void *)(*(void *)v10 + 120), v26);
        unsigned int v27 = result;
        if (!result)
        {
          OOCAllocator_Free(*(void *)(v24 + 40), v25);
          return v27;
        }
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamWriter_AddInterruptible(uint64_t a1)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  uint64_t result = PNEW_ParamDB_Con(*(void *)(a1 + 40), *(void *)(a1 + 40), &v6);
  if (!result)
  {
    uint64_t result = ParamDB_AddPublicParam(v6, 987249153, 2, (uint64_t)ParameterCheck_NoCheck);
    if (!result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)(a1 + 24) + 32))(a1 + 24 - *(void *)(*(void *)(a1 + 24) + 120), 987184693, 0x10000, &v3);
      if (!result)
      {
        uint64_t result = ParamDB_FetchBinaryBuffer(v6, &v5, &v4);
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 8))(v3 - *(void *)(*(void *)v3 + 56), v5, v4);
          if (!result)
          {
            ParamDB_ReturnBinaryBuffer(v6, v5);
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 24) + 48))(a1 + 24 - *(void *)(*(void *)(a1 + 24) + 120), v3);
            if (!result) {
              return OOC_PlacementDeleteObject(*(void *)(a1 + 40), v6);
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamWriter_CalculateExpectedBinBlockSize(uint64_t a1, unsigned int *a2, unsigned int a3, int a4, int *a5)
{
  int v5 = 12 * a3 + 44;
  unsigned int v6 = 12 * a3 + 4;
  if ((v6 & 0x3FFC) != 0) {
    int v7 = (v6 >> 14) + 1;
  }
  else {
    int v7 = v6 >> 14;
  }
  int v8 = v5 + 4 * v7;
  if (a4) {
    int v5 = v8;
  }
  int v9 = v5 + 12 * a3;
  if (a3)
  {
    uint64_t v10 = a3;
    do
    {
      unsigned int v11 = *a2++;
      v9 += v11;
      unsigned int v12 = v11 >> 14;
      if ((v11 & 0x3FFF) != 0) {
        unsigned int v13 = v12 + 1;
      }
      else {
        unsigned int v13 = v12;
      }
      int v14 = v9 + 4 * v13;
      if (a4) {
        int v9 = v14;
      }
      --v10;
    }
    while (v10);
  }
  *a5 = v9;
  return 0;
}

uint64_t BinBlockStreamWriter_Close(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 128) == 1) {
    return 0;
  }
  uint64_t result = _BinBlockStreamWriter_WriteHeaderAndToc(a1, 1);
  if (!result)
  {
    if ((*(unsigned int (**)(void, void, void))(*(void *)(a1 + 48) + 8))(*(void *)(a1 + 56), *(void *)(a1 + 32) + *(unsigned int *)(a1 + 76), 0))
    {
LABEL_5:
      return err_GenerateErrorCallback();
    }
    uint64_t v3 = *(void *)(a1 + 64);
    if (v3)
    {
      OOCAllocator_Free(*(void *)(a1 + 40), v3);
      *(void *)(a1 + 64) = 0;
    }
    uint64_t v4 = *(void *)(a1 + 48);
    if (v4)
    {
      if (!*(_DWORD *)(a1 + 76))
      {
        if ((*(unsigned int (**)(void, void))(v4 + 24))(*(void *)(a1 + 56), 0)) {
          goto LABEL_5;
        }
        uint64_t v4 = *(void *)(a1 + 48);
      }
      OOCAllocator_Free(*(void *)(a1 + 40), v4);
      *(void *)(a1 + 48) = 0;
    }
    uint64_t result = 0;
    *(_DWORD *)(a1 + 128) = 1;
  }
  return result;
}

uint64_t _BinBlockStreamWriter_WriteHeaderAndToc(uint64_t a1, int a2)
{
  if ((*(unsigned int (**)(void, void, void))(*(void *)(a1 + 48) + 8))(*(void *)(a1 + 56), *(unsigned int *)(a1 + 76), 0))
  {
    return err_GenerateErrorCallback();
  }
  else
  {
    unsigned int v13 = 0;
    unsigned int v12 = 0;
    uint64_t v5 = OOCAllocator_Malloc(*(void *)(a1 + 40), 40, &v13);
    uint64_t result = v13;
    if (!v13)
    {
      int v6 = *(_DWORD *)(a1 + 72) != 0;
      int v7 = *(_DWORD *)(a1 + 80);
      int v8 = *(_DWORD *)(a1 + 32);
      int v9 = *(unsigned __int16 *)(a1 + 88);
      int v10 = v8 + (v6 << 14) + *(_DWORD *)(a1 + 84) + v7 + v9 + *(unsigned __int16 *)(a1 + 106) + 1;
      *(_DWORD *)uint64_t v5 = v7;
      *(_DWORD *)(v5 + 4) = *(_DWORD *)(a1 + 84);
      *(_DWORD *)(v5 + 8) = v8;
      *(_WORD *)(v5 + 12) = v9;
      *(_WORD *)(v5 + 14) = 1;
      *(_WORD *)(v5 + 16) = (_WORD)v6 << 14;
      *(_WORD *)(v5 + 18) = *(_WORD *)(a1 + 106);
      *(_DWORD *)(v5 + 20) = 0;
      *(_DWORD *)(v5 + 24) = v10;
      int v11 = *(unsigned __int16 *)(a1 + 106);
      *(_DWORD *)(v5 + 28) = 270012440;
      *(_DWORD *)(v5 + 32) = v11;
      *(_DWORD *)(v5 + 36) = 0x10000;
      if ((**(uint64_t (***)(uint64_t, uint64_t, uint64_t, void))(a1 + 48))(v5, 1, 40, *(void *)(a1 + 56)) == 40)
      {
        if (!a2) {
          *(void *)(a1 + 32) = 40;
        }
        uint64_t result = PNEW_DataSectionWriter_Con(*(void *)(a1 + 40), *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56), *(_DWORD *)(a1 + 72), 0x4000, (*(_DWORD *)(a1 + 76) + 40), (uint64_t *)&v12);
        unsigned int v13 = result;
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(v12[3] + 8))((uint64_t)v12 - *(void *)(v12[3] + 56) + 24, *(void *)(a1 + 96), *(unsigned __int16 *)(a1 + 104));
          unsigned int v13 = result;
          if (!result)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t))(v12[3] + 32))((uint64_t)v12 - *(void *)(v12[3] + 56) + 24);
            unsigned int v13 = result;
            if (!result)
            {
              if (!a2) {
                *(void *)(a1 + 32) += (*(uint64_t (**)(uint64_t))v12[3])((uint64_t)v12
              }
                                                                                  - *(void *)(v12[3] + 56) + 24);
              uint64_t result = (*(uint64_t (**)(void *))(*v12 + 32))(v12);
              unsigned int v13 = result;
              if (!result)
              {
                OOCAllocator_Free(*(void *)(a1 + 40), v5);
                return v13;
              }
            }
          }
        }
      }
      else
      {
        return err_GenerateErrorCallback();
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamWriter_CopySectionInterruptible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v16 = 0;
  int v10 = *(_DWORD *)(a1 + 72) == 1;
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 72))(a2 - *(void *)(*(void *)a2 + 208)) == v10 << 14)
  {
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v15 = 0;
    unsigned int v14 = 0;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *, unsigned int *, _DWORD *))(*(void *)a2 + 16))(a2 - *(void *)(*(void *)a2 + 208), a3, a4, &v18, &v14, a5);
    if (!result)
    {
      if (*a5)
      {
        return 0;
      }
      else
      {
        uint64_t v13 = *(void *)(a1 + 24);
        uint64_t v12 = a1 + 24;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t *))(v13 + 32))(v12 - *(void *)(v13 + 120), a3, v14, &v17);
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)v17 + 48))(v17 - *(void *)(*(void *)v17 + 56), 0);
          if (!result)
          {
            while (1)
            {
              uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *, _DWORD *))(*(void *)v18 + 8))(v18 - *(void *)(*(void *)v18 + 48), &v16, &v15, a5);
              if (result) {
                break;
              }
              if (*a5) {
                return 0;
              }
              if (v15)
              {
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v17 + 8))(v17 - *(void *)(*(void *)v17 + 56), v16);
                if (result) {
                  return result;
                }
                if (v15) {
                  continue;
                }
              }
              uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 48))(v12 - *(void *)(*(void *)v12 + 120), v17);
              if (!result) {
                return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 32))(a2 - *(void *)(*(void *)a2 + 208), v18);
              }
              return result;
            }
          }
        }
      }
    }
  }
  else
  {
    return err_GenerateErrorData();
  }
  return result;
}

uint64_t BinBlockStreamWriter_FetchBinBlockStreamWriter(uint64_t a1, int a2, int a3, int a4, void *a5)
{
  *(_DWORD *)(a1 + 124) = 1;
  uint64_t result = _BinBlockStreamWriter_AddSection(a1, a2, 0, -1, 0);
  if (!result)
  {
    uint64_t v11 = 0;
    uint64_t result = _PNEW_BinBlockStreamWriter_Con2(*(void *)(a1 + 40), *(void *)(a1 + 40), *(const void **)(a1 + 48), *(void *)(a1 + 56), *(_DWORD **)(a1 + 64), a2, a3, a4, *(_DWORD *)(a1 + 76) + *(_DWORD *)(a1 + 32), &v11);
    if (!result) {
      *a5 = v11 + 24;
    }
  }
  return result;
}

uint64_t _BinBlockStreamWriter_AddSection(uint64_t a1, int a2, int a3, int a4, int a5)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  unsigned int v10 = *(unsigned __int16 *)(a1 + 108);
  if (a5)
  {
    *(_DWORD *)(a1 + 120) = a3;
    if (v10 <= *(unsigned __int16 *)(a1 + 110))
    {
      uint64_t v11 = (_DWORD *)(*(void *)(a1 + 96) + 4 * (3 * v10 - 1));
      *uint64_t v11 = a3;
      if ((*(unsigned int (**)(void, void, void))(*(void *)(a1 + 48) + 8))(*(void *)(a1 + 56), (*(_DWORD *)(a1 + 76) + v11[1]), 0))
      {
        return err_GenerateErrorCallback();
      }
      goto LABEL_9;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 112) = a2;
    *(_DWORD *)(a1 + 116) = a4;
    *(_DWORD *)(a1 + 120) = a3;
    if (v10 < *(unsigned __int16 *)(a1 + 110))
    {
      uint64_t v13 = *(_DWORD **)(a1 + 96);
      *uint64_t v13 = v10 + 1;
      unsigned int v14 = &v13[3 * v10];
      v14[1] = a2;
      _OWORD v14[2] = a3;
      _OWORD v14[3] = *(void *)(a1 + 32);
      LOWORD(v10) = v10 + 1;
LABEL_9:
      v15[0] = a2;
      v15[1] = a3;
      v15[2] = a4;
      if ((**(uint64_t (***)(_DWORD *, uint64_t, uint64_t, void))(a1 + 48))(v15, 4, 3, *(void *)(a1 + 56)) != 3)return err_GenerateErrorCallback(); {
      if (!a5)
      }
        *(void *)(a1 + 32) += 12;
      uint64_t result = 0;
      *(_WORD *)(a1 + 108) = v10;
      return result;
    }
  }

  return err_GenerateErrorData();
}

uint64_t _PNEW_BinBlockStreamWriter_Con2(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5, int a6, int a7, int a8, int a9, uint64_t *a10)
{
  unsigned int v20 = 0;
  uint64_t v18 = OOCAllocator_Malloc(a1, 136, &v20);
  uint64_t result = v20;
  if (!v20)
  {
    uint64_t result = _BinBlockStreamWriter_Con2(v18, a2, a3, a4, a5, a6, a7, a8, a9);
    unsigned int v20 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v18);
      *a10 = 0;
      return v20;
    }
    else
    {
      *(void *)(v18 + 16) = a1;
      *a10 = v18;
    }
  }
  return result;
}

uint64_t BinBlockStreamWriter_FetchBinBlockStreamWriter2(uint64_t a1, int a2, int a3, int a4, int a5, void *a6)
{
  return BinBlockStreamWriter_FetchBinBlockStreamWriter3(a1, a2, a3, a4, a5, 0, a6);
}

uint64_t BinBlockStreamWriter_FetchBinBlockStreamWriter3(uint64_t a1, int a2, int a3, int a4, int a5, _DWORD *a6, void *a7)
{
  int v8 = a6;
  if (!a6) {
    int v8 = *(_DWORD **)(a1 + 64);
  }
  *(_DWORD *)(a1 + 124) = 1;
  uint64_t result = _BinBlockStreamWriter_AddSection(a1, a2, 0, -1, 0);
  if (!result)
  {
    uint64_t v14 = 0;
    uint64_t result = _PNEW_BinBlockStreamWriter_Con2(*(void *)(a1 + 40), *(void *)(a1 + 40), *(const void **)(a1 + 48), *(void *)(a1 + 56), v8, a3, a4, a5, *(_DWORD *)(a1 + 76) + *(_DWORD *)(a1 + 32), &v14);
    if (!result) {
      *a7 = v14 + 24;
    }
  }
  return result;
}

uint64_t BinBlockStreamWriter_FetchSectionDataStreamWriter(uint64_t a1, int a2, int a3, void *a4)
{
  *(_DWORD *)(a1 + 124) = 1;
  uint64_t result = _BinBlockStreamWriter_AddSection(a1, a2, 0, a3, 0);
  if (!result)
  {
    uint64_t v7 = 0;
    uint64_t result = PNEW_DataSectionWriter_Con(*(void *)(a1 + 40), *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56), *(_DWORD *)(a1 + 72), 0x4000, *(void *)(a1 + 32) + *(unsigned int *)(a1 + 76), &v7);
    if (!result) {
      *a4 = v7 + 24;
    }
  }
  return result;
}

BOOL BinBlockStreamWriter_IsHeaderWritten(uint64_t a1)
{
  return *(void *)(a1 + 96) != 0;
}

uint64_t BinBlockStreamWriter_ReturnBinBlockStreamWriter(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 124) = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 72))(a2 - *(void *)(*(void *)a2 + 120));
  if (!result)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 56))(a2 - *(void *)(*(void *)a2 + 120));
    uint64_t result = _BinBlockStreamWriter_AddSection(a1, *(_DWORD *)(a1 + 112), v5, *(_DWORD *)(a1 + 116), 1);
    if (!result)
    {
      uint64_t v6 = *(void *)(a1 + 32) + v5;
      *(void *)(a1 + 32) = v6;
      if ((*(unsigned int (**)(void, uint64_t, void))(*(void *)(a1 + 48) + 8))(*(void *)(a1 + 56), v6 + *(unsigned int *)(a1 + 76), 0))
      {
        return err_GenerateErrorCallback();
      }
      else
      {
        int v8 = *(uint64_t (**)(uint64_t))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 96))(a2 - *(void *)(*(void *)a2 + 120))
                                               + 32);
        uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 96))(a2 - *(void *)(*(void *)a2 + 120));
        return v8(v7);
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamWriter_ReturnSectionDataStreamWriter(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 124) = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2 - *(void *)(*(void *)a2 + 56));
  if (!result)
  {
    uint64_t v5 = (**(uint64_t (***)(uint64_t))a2)(a2 - *(void *)(*(void *)a2 + 56));
    uint64_t result = _BinBlockStreamWriter_AddSection(a1, *(_DWORD *)(a1 + 112), v5, *(_DWORD *)(a1 + 116), 1);
    if (!result)
    {
      uint64_t v6 = *(void *)(a1 + 32) + v5;
      *(void *)(a1 + 32) = v6;
      if ((*(unsigned int (**)(void, uint64_t, void))(*(void *)(a1 + 48) + 8))(*(void *)(a1 + 56), v6 + *(unsigned int *)(a1 + 76), 0))
      {
        return err_GenerateErrorCallback();
      }
      else
      {
        int v8 = *(uint64_t (**)(uint64_t))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 56))
                                               + 32);
        uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 56));
        return v8(v7);
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamWriter_nbrBytesWritten(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t PNEW_BinBlockStreamWriter_Con(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5, int a6, int a7, int a8, uint64_t *a9)
{
  unsigned int v19 = 0;
  uint64_t v17 = OOCAllocator_Malloc(a1, 136, &v19);
  uint64_t result = v19;
  if (!v19)
  {
    uint64_t result = _BinBlockStreamWriter_Con2(v17, a2, a3, a4, a5, a6, a7, a8, 0);
    unsigned int v19 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v17);
      *a9 = 0;
      return v19;
    }
    else
    {
      *(void *)(v17 + 16) = a1;
      *a9 = v17;
    }
  }
  return result;
}

uint64_t PNEW_BinBlockStreamWriter_ConTypeLess(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 136, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = BinBlockStreamWriter_ConTypeLess(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *(void *)(v12 + 16) = a1;
      *a6 = v12;
    }
  }
  return result;
}

void *GetBinBlockStreamWriterClass()
{
  return &__BinBlockStreamWriter;
}

uint64_t adler3200(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  if (!a2) {
    return 1;
  }
  unsigned int v3 = HIWORD(a1);
  unsigned int v4 = (unsigned __int16)a1;
  if (a3 < 0x10)
  {
    for (; a3; --a3)
    {
      int v5 = *a2++;
      v4 += v5;
      v3 += v4;
    }
    if (v4 > 0xFFF0) {
      v4 -= 65521;
    }
    v3 %= 0xFFF1u;
    return v4 | (v3 << 16);
  }
  if (a3 >> 4 >= 0x15B)
  {
    do
    {
      a3 -= 5552;
      int v7 = -347;
      int v8 = a2;
      do
      {
        unsigned int v9 = v4 + *v8;
        unsigned int v10 = v9 + v3;
        unsigned int v11 = v9 + v8[1];
        unsigned int v12 = v10 + v11;
        unsigned int v13 = v11 + v8[2];
        unsigned int v14 = v12 + v13;
        unsigned int v15 = v13 + v8[3];
        unsigned int v16 = v14 + v15;
        unsigned int v17 = v15 + v8[4];
        unsigned int v18 = v16 + v17;
        unsigned int v19 = v17 + v8[5];
        unsigned int v20 = v18 + v19;
        unsigned int v21 = v19 + v8[6];
        int v22 = v20 + v21;
        unsigned int v23 = v21 + v8[7];
        int v24 = v22 + v23;
        unsigned int v25 = v23 + v8[8];
        int v26 = v24 + v25;
        int v27 = v25 + v8[9];
        int v28 = v26 + v27;
        int v29 = v27 + v8[10];
        int v30 = v28 + v29;
        int v31 = v29 + v8[11];
        int v32 = v30 + v31;
        int v33 = v31 + v8[12];
        int v34 = v32 + v33;
        int v35 = v33 + v8[13];
        int v36 = v34 + v35;
        int v37 = v35 + v8[14];
        int v38 = v36 + v37;
        unsigned int v4 = v37 + v8[15];
        unsigned int v3 = v38 + v4;
        v8 += 16;
      }
      while (!__CFADD__(v7++, 1));
      a2 += 5552;
      v4 %= 0xFFF1u;
      v3 %= 0xFFF1u;
    }
    while (a3 >> 4 > 0x15A);
    if (!a3) {
      return v4 | (v3 << 16);
    }
    if (a3 < 0x10) {
      goto LABEL_23;
    }
  }
  do
  {
    a3 -= 16;
    unsigned int v40 = v4 + *a2;
    unsigned int v41 = v40 + v3;
    unsigned int v42 = v40 + a2[1];
    unsigned int v43 = v41 + v42;
    unsigned int v44 = v42 + a2[2];
    unsigned int v45 = v43 + v44;
    unsigned int v46 = v44 + a2[3];
    unsigned int v47 = v45 + v46;
    unsigned int v48 = v46 + a2[4];
    unsigned int v49 = v47 + v48;
    unsigned int v50 = v48 + a2[5];
    unsigned int v51 = v49 + v50;
    unsigned int v52 = v50 + a2[6];
    int v53 = v51 + v52;
    unsigned int v54 = v52 + a2[7];
    int v55 = v53 + v54;
    unsigned int v56 = v54 + a2[8];
    int v57 = v55 + v56;
    int v58 = v56 + a2[9];
    int v59 = v57 + v58;
    int v60 = v58 + a2[10];
    int v61 = v59 + v60;
    int v62 = v60 + a2[11];
    int v63 = v61 + v62;
    int v64 = v62 + a2[12];
    int v65 = v63 + v64;
    int v66 = v64 + a2[13];
    int v67 = v65 + v66;
    int v68 = v66 + a2[14];
    int v69 = v67 + v68;
    unsigned int v4 = v68 + a2[15];
    unsigned int v3 = v69 + v4;
    a2 += 16;
  }
  while (a3 > 0xF);
  if (a3)
  {
LABEL_23:
    do
    {
      int v70 = *a2++;
      v4 += v70;
      v3 += v4;
      --a3;
    }
    while (a3);
  }
  v4 %= 0xFFF1u;
  v3 %= 0xFFF1u;
  return v4 | (v3 << 16);
}

uint64_t DataSectionRandomReader_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8)
{
  return _DataSectionRandomReader_ConInternal(a1, a2, a3, a4, a5, a6, a7, a8, 0);
}

uint64_t _DataSectionRandomReader_ConInternal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, int a9)
{
  uint64_t result = RefCounted_Con(a1, 1);
  unsigned int v25 = result;
  if (result) {
    return result;
  }
  *(void *)a1 = &__DataSectionRandomReader;
  *(void *)(a1 + 24) = &off_26D217EA0;
  *(void *)(a1 + 80) = a4;
  *(void *)(a1 + 88) = a5;
  BOOL v18 = (a8 & 1) != 0 && (__int16)a8 <= -1;
  int v19 = a8 & 0x7FFE;
  BOOL v20 = !v18 || v19 == 0;
  unsigned int v21 = v19 << 15;
  if (v20) {
    unsigned int v21 = a8;
  }
  *(_DWORD *)(a1 + 48) = v21;
  *(void *)(a1 + 32) = &off_26D217EE0;
  *(void *)(a1 + 40) = a6;
  unint64_t v22 = a7;
  *(void *)(a1 + 64) = a7;
  *(void *)(a1 + 72) = a3;
  *(void *)(a1 + 104) = a2;
  *(_DWORD *)(a1 + 152) = a9;
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 136) = xmmword_2207249B0;
  if (v21)
  {
    unint64_t v23 = v21 + 4;
    unint64_t v22 = a7 - 4 * ((a7 + (unint64_t)v21 + 3) / v23);
    *(void *)(a1 + 56) = v22;
    if (v21 <= 0x1000)
    {
      *(_DWORD *)(a1 + 112) = 1;
      *(void *)(a1 + 120) = OOCAllocator_Malloc(a2, v23, &v25);
      uint64_t result = v25;
      if (v25) {
        return result;
      }
      unsigned int v21 = *(_DWORD *)(a1 + 48);
      unint64_t v22 = *(void *)(a1 + 56);
      int v24 = *(uint64_t (***)())(a1 + 24);
      goto LABEL_16;
    }
  }
  else
  {
    *(void *)(a1 + 56) = a7;
  }
  int v24 = &off_26D217EA0;
LABEL_16:
  if (v22 < v21) {
    unsigned int v21 = v22;
  }
  *(_DWORD *)(a1 + 96) = v22;
  *(_DWORD *)(a1 + 100) = v21;
  return ((uint64_t (*)(uint64_t, void))*v24)(a1 + 24 - (void)v24[7], 0);
}

uint64_t DataSectionRandomReader_ConForInterruptible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, int a9)
{
  return _DataSectionRandomReader_ConInternal(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t DataSectionRandomReader_Des(void *a1)
{
  uint64_t v2 = a1[11];
  if (!v2
    || (uint64_t result = (**(uint64_t (***)(uint64_t))v2)(v2 - *(void *)(*(void *)v2 + 8)), !result))
  {
    OOCAllocator_Free(a1[13], a1[15]);
    return RefCounted_Des(a1);
  }
  return result;
}

uint64_t DataSectionRandomReader_Clone(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v4 = *(void *)(a1 + 64);
  unsigned int v5 = v4 - a2;
  if (v4 >= a2)
  {
    unsigned int v7 = *(_DWORD *)(a1 + 48);
    if (HIWORD(v7)) {
      unsigned __int16 v8 = (v7 >> 15) | 0x8001;
    }
    else {
      unsigned __int16 v8 = *(_DWORD *)(a1 + 48);
    }
    return PNEW_DataSectionRandomReader_Con(*(void *)(a1 + 104), *(void *)(a1 + 104), *(void *)(a1 + 72), *(void *)(a1 + 80), a3, *(void *)(a1 + 40) + a2, v5, v8, a4);
  }
  else
  {
    return err_GenerateErrorArg();
  }
}

uint64_t PNEW_DataSectionRandomReader_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, uint64_t *a9)
{
  unsigned int v19 = 0;
  uint64_t v17 = OOCAllocator_Malloc(a1, 160, &v19);
  uint64_t result = v19;
  if (!v19)
  {
    uint64_t result = _DataSectionRandomReader_ConInternal(v17, a2, a3, a4, a5, a6, a7, a8, 0);
    unsigned int v19 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v17);
      *a9 = 0;
      return v19;
    }
    else
    {
      *(void *)(v17 + 16) = a1;
      *a9 = v17;
    }
  }
  return result;
}

uint64_t DataSectionRandomReader_GetDataSize(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t DataSectionRandomReader_Read(uint64_t a1, char *__dst, unint64_t a3)
{
  if (*(unsigned int *)(a1 + 96) >= a3) {
    return __DataSectionRandomReader_ReadInternalInterruptible(a1, a3, 0, __dst, &v5, &v4);
  }

  return err_GenerateErrorData();
}

uint64_t __DataSectionRandomReader_ReadInternalInterruptible(uint64_t a1, unint64_t a2, int a3, char *__dst, uint64_t *a5, _DWORD *a6)
{
  unsigned __int16 v8 = __dst;
  unint64_t v10 = a2;
  unsigned int v30 = 0;
  *a6 = 0;
  if (*(_DWORD *)(a1 + 48))
  {
    uint64_t v12 = 0;
    if (a2)
    {
      do
      {
        unint64_t v13 = *(unsigned int *)(a1 + 100);
        if (v10 >= v13) {
          size_t v14 = *(unsigned int *)(a1 + 100);
        }
        else {
          size_t v14 = v10;
        }
        if (*(_DWORD *)(a1 + 112))
        {
          uint64_t v15 = *(void *)(a1 + 144);
          if (*(void *)(a1 + 128) != *(void *)(a1 + 136))
          {
            uint64_t v16 = v13 + v15 + 4;
            uint64_t v17 = (**(uint64_t (***)(void, uint64_t, uint64_t, void))(a1 + 72))(*(void *)(a1 + 120), 1, v16, *(void *)(a1 + 80));
            if (!__DataSectionRandomReader_ReadCallOk(a1, v16, v17, 0, a6, &v30)) {
              return v30;
            }
            uint64_t v18 = *(void *)(a1 + 120);
            *(void *)(a1 + 136) = *(void *)(a1 + 128);
            int v19 = *(_DWORD *)(v18 + *(void *)(a1 + 144) + *(unsigned int *)(a1 + 100));
            unsigned int v20 = adler3200(0, 0, 0);
            if (v19 != adler3200(v20, *(unsigned __int8 **)(a1 + 120), *(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 144)))return err_GenerateErrorData(); {
            uint64_t v15 = *(void *)(a1 + 144);
            }
          }
          cstdlib_memcpy(v8, (const void *)(*(void *)(a1 + 120) + v15), v14);
          *(void *)(a1 + 144) += v14;
        }
        else
        {
          uint64_t v21 = (**(uint64_t (***)(void *, uint64_t, size_t, void))(a1 + 72))(v8, 1, v14, *(void *)(a1 + 80));
          int v22 = __DataSectionRandomReader_ReadCallOk(a1, v14, v21, a3, a6, &v30);
          size_t v14 = v21;
          if (!v22) {
            return v30;
          }
        }
        int v23 = *(_DWORD *)(a1 + 100) - v14;
        *(_DWORD *)(a1 + 100) = v23;
        if (v23)
        {
          v12 += v14;
        }
        else
        {
          int v24 = *(_DWORD *)(a1 + 112);
          if (!v24)
          {
            uint64_t v25 = (**(uint64_t (***)(char *, uint64_t, uint64_t, void))(a1 + 72))(v29, 1, 4, *(void *)(a1 + 80));
            if (!__DataSectionRandomReader_ReadCallOk(a1, 4, v25, a3, a6, &v30)) {
              return v30;
            }
            int v24 = *(_DWORD *)(a1 + 112);
          }
          unint64_t v26 = *(unsigned int *)(a1 + 48);
          v12 += v14;
          if ((unint64_t)*(unsigned int *)(a1 + 96) - v12 < v26) {
            LODWORD(v26) = *(_DWORD *)(a1 + 96) - v12;
          }
          *(_DWORD *)(a1 + 100) = v26;
          if (v24)
          {
            *(void *)(a1 + 128) += *(void *)(a1 + 144) + 4;
            *(void *)(a1 + 144) = 0;
          }
        }
        v8 += v14;
        v10 -= v14;
      }
      while (v10);
    }
    *(_DWORD *)(a1 + 96) -= v12;
    *a5 = v12;
  }
  else
  {
    uint64_t v27 = (**(uint64_t (***)(void *, uint64_t, unint64_t, void))(a1 + 72))(__dst, 1, a2, *(void *)(a1 + 80));
    *a5 = v27;
    __DataSectionRandomReader_ReadCallOk(a1, v10, v27, a3, a6, &v30);
  }
  return v30;
}

uint64_t DataSectionRandomReader_ReadInterruptible(uint64_t a1, char *__dst, unint64_t a3, _DWORD *a4)
{
  *a4 = 0;
  if (*(unsigned int *)(a1 + 96) >= a3) {
    return __DataSectionRandomReader_ReadInternalInterruptible(a1, a3, 0, __dst, &v5, a4);
  }

  return err_GenerateErrorData();
}

uint64_t DataSectionRandomReader_ReadPartial(uint64_t a1, char *__dst, unint64_t a3, uint64_t *a4)
{
  if (*(unsigned int *)(a1 + 96) >= a3) {
    unint64_t v6 = a3;
  }
  else {
    unint64_t v6 = *(unsigned int *)(a1 + 96);
  }
  return __DataSectionRandomReader_ReadInternalInterruptible(a1, v6, 1, __dst, a4, &v8);
}

uint64_t DataSectionRandomReader_Seek(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = *(void *)(a1 + 56);
  if (v2 < a2)
  {
    return err_GenerateErrorData();
  }
  unsigned int v5 = v2 - a2;
  *(_DWORD *)(a1 + 96) = v2 - a2;
  unsigned int v6 = *(_DWORD *)(a1 + 48);
  int v7 = a2 / v6;
  unsigned int v8 = a2 + 4 * v7;
  if (v6 + v6 * v7 - a2 < v5) {
    unsigned int v5 = v6 + v6 * v7 - a2;
  }
  *(_DWORD *)(a1 + 100) = v5;
  if (*(_DWORD *)(a1 + 112))
  {
    uint64_t v9 = v7 * (v6 + 4);
    if (*(void *)(a1 + 136) == v9
      || !(*(unsigned int (**)(void, uint64_t, void))(*(void *)(a1 + 72) + 8))(*(void *)(a1 + 80), *(void *)(a1 + 40) + v9, 0))
    {
      *(void *)(a1 + 128) = v9;
      *(void *)(a1 + 144) = v8 - v9;
      return 0;
    }
  }
  else if (!(*(unsigned int (**)(void, void, void))(*(void *)(a1 + 72) + 8))(*(void *)(a1 + 80), *(void *)(a1 + 40) + v8, 0))
  {
    return 0;
  }

  return err_GenerateErrorCallback();
}

uint64_t PNEW_DataSectionRandomReader_ConForInterruptible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, int a9, uint64_t *a10)
{
  unsigned int v20 = 0;
  uint64_t v18 = OOCAllocator_Malloc(a1, 160, &v20);
  uint64_t result = v20;
  if (!v20)
  {
    uint64_t result = _DataSectionRandomReader_ConInternal(v18, a2, a3, a4, a5, a6, a7, a8, a9);
    unsigned int v20 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v18);
      *a10 = 0;
      return v20;
    }
    else
    {
      *(void *)(v18 + 16) = a1;
      *a10 = v18;
    }
  }
  return result;
}

uint64_t _PNEW_DataSectionRandomReader_ConInternal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, int a9, uint64_t *a10)
{
  unsigned int v20 = 0;
  uint64_t v18 = OOCAllocator_Malloc(a1, 160, &v20);
  uint64_t result = v20;
  if (!v20)
  {
    uint64_t result = _DataSectionRandomReader_ConInternal(v18, a2, a3, a4, a5, a6, a7, a8, a9);
    unsigned int v20 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v18);
      *a10 = 0;
      return v20;
    }
    else
    {
      *(void *)(v18 + 16) = a1;
      *a10 = v18;
    }
  }
  return result;
}

void *GetDataSectionRandomReaderClass()
{
  return &__DataSectionRandomReader;
}

uint64_t __DataSectionRandomReader_ReadCallOk(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5, _DWORD *a6)
{
  if (a3 == a2) {
    return 1;
  }
  if ((*(unsigned int (**)(void))(*(void *)(a1 + 72) + 16))(*(void *)(a1 + 80)))
  {
    int ErrorCallback = err_GenerateErrorCallback();
LABEL_5:
    int v12 = ErrorCallback;
    uint64_t result = 0;
    *a6 = v12;
    return result;
  }
  if (a4)
  {
    uint64_t result = 0;
    *a5 = 0;
  }
  else
  {
    if (!*(_DWORD *)(a1 + 152))
    {
      int ErrorCallback = err_GenerateErrorData();
      goto LABEL_5;
    }
    uint64_t result = 0;
    *a5 = 1;
  }
  return result;
}

uint64_t DataSectionWriter_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, __int16 a6, uint64_t a7)
{
  uint64_t v14 = RefCounted_Con(a1, 1);
  if (!v14)
  {
    *(void *)a1 = &__DataSectionWriter;
    *(void *)(a1 + 40) = a2;
    *(void *)(a1 + 48) = a3;
    *(void *)(a1 + 56) = a4;
    *(_DWORD *)(a1 + 64) = a5;
    *(_DWORD *)(a1 + 108) = 0;
    *(_WORD *)(a1 + 80) = a6;
    *(void *)(a1 + 72) = a7;
    *(void *)(a1 + 24) = &unk_26D217F38;
    *(void *)(a1 + 32) = 0;
    *(_WORD *)(a1 + 82) = a6;
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 96) = 0x4000;
    *(_DWORD *)(a1 + 104) = adler3200(0, 0, 0);
  }
  return v14;
}

uint64_t DataSectionWriter_Des(void *a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(a1[3] + 32))((uint64_t)a1 - *(void *)(a1[3] + 56) + 24);
  if (!result)
  {
    uint64_t v3 = a1[11];
    if (v3) {
      OOCAllocator_Free(a1[5], v3);
    }
    return RefCounted_Des(a1);
  }
  return result;
}

uint64_t DataSectionWriter_BorrowDataBlock(uint64_t *a1, uint64_t *a2, void *a3)
{
  unsigned int v9 = 0;
  uint64_t v6 = a1[11];
  if (v6 || (uint64_t v6 = OOCAllocator_Malloc(a1[5], a1[12], &v9), a1[11] = v6, (v7 = v9) == 0))
  {
    uint64_t v7 = 0;
    *a2 = v6;
    *a3 = a1[12];
  }
  return v7;
}

uint64_t DataSectionWriter_Close(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 108)) {
    return 0;
  }
  *(_DWORD *)(a1 + 108) = 1;
  if (!*(_DWORD *)(a1 + 64) || *(unsigned __int16 *)(a1 + 82) == *(unsigned __int16 *)(a1 + 80)) {
    return 0;
  }
  else {
    return _DataSectionWriter_AddCheckSum(a1);
  }
}

uint64_t _DataSectionWriter_AddCheckSum(uint64_t a1)
{
  int v4 = *(_DWORD *)(a1 + 104);
  if ((**(uint64_t (***)(int *, uint64_t, uint64_t, void))(a1 + 48))(&v4, 1, 4, *(void *)(a1 + 56)) != 4) {
    return err_GenerateErrorCallback();
  }
  *(void *)(a1 + 32) += 4;
  *(_WORD *)(a1 + 82) = *(_WORD *)(a1 + 80);
  int v2 = adler3200(0, 0, 0);
  uint64_t result = 0;
  *(_DWORD *)(a1 + 104) = v2;
  return result;
}

uint64_t DataSectionWriter_CommitDataBlock(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)(a1 + 24) + 8))(a1 + 24 - *(void *)(*(void *)(a1 + 24) + 56), *(void *)(a1 + 88), a2);
}

uint64_t DataSectionWriter_GetNbrBytesWritten(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t DataSectionWriter_LendData(uint64_t a1, unsigned __int8 *a2, unint64_t a3)
{
  unint64_t v3 = a3;
  int v4 = a2;
  if (!*(_DWORD *)(a1 + 64))
  {
    if ((**(uint64_t (***)(unsigned __int8 *, uint64_t, unint64_t, void))(a1 + 48))(a2, 1, a3, *(void *)(a1 + 56)) != a3)
    {
      return err_GenerateErrorCallback();
    }
LABEL_14:
    uint64_t result = 0;
    *(void *)(a1 + 32) += v3;
    return result;
  }
  if (!a3) {
    goto LABEL_14;
  }
  unsigned __int16 v6 = *(_WORD *)(a1 + 82);
  unint64_t v7 = a3;
  unint64_t v3 = 0;
  while (1)
  {
    unint64_t v8 = v7 >= v6 ? v6 : v7;
    if ((**(uint64_t (***)(unsigned __int8 *, uint64_t, unint64_t, void))(a1 + 48))(v4, 1, v8, *(void *)(a1 + 56)) != v8)return err_GenerateErrorCallback(); {
    int v9 = adler3200(*(_DWORD *)(a1 + 104), v4, v8);
    }
    *(_DWORD *)(a1 + 104) = v9;
    int v10 = *(unsigned __int16 *)(a1 + 82);
    unsigned __int16 v6 = v10 - v8;
    *(_WORD *)(a1 + 82) = v10 - v8;
    if (v10 == (unsigned __int16)v8)
    {
      int v12 = v9;
      if ((**(uint64_t (***)(int *, uint64_t, uint64_t, void))(a1 + 48))(&v12, 1, 4, *(void *)(a1 + 56)) != 4)return err_GenerateErrorCallback(); {
      *(_DWORD *)(a1 + 104) = adler3200(0, 0, 0);
      }
      unsigned __int16 v6 = *(_WORD *)(a1 + 80);
      *(_WORD *)(a1 + 82) = v6;
      v3 += 4;
    }
    v4 += v8;
    v3 += v8;
    v7 -= v8;
    if (!v7) {
      goto LABEL_14;
    }
  }
}

uint64_t DataSectionWriter_UseCheckSum(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 108) || *(void *)(a1 + 32)) {
    return err_GenerateErrorInternal();
  }
  *(_DWORD *)(a1 + 64) = a2;
  if (a2) {
    *(_WORD *)(a1 + 80) = *(_WORD *)(a1 + 82);
  }
  else {
    *(_WORD *)(a1 + 80) = 0;
  }
  return 0;
}

uint64_t PNEW_DataSectionWriter_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, __int16 a6, uint64_t a7, uint64_t *a8)
{
  unsigned int v18 = 0;
  uint64_t v16 = OOCAllocator_Malloc(a1, 112, &v18);
  uint64_t result = v18;
  if (!v18)
  {
    uint64_t result = DataSectionWriter_Con(v16, a2, a3, a4, a5, a6, a7);
    unsigned int v18 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v16);
      *a8 = 0;
      return v18;
    }
    else
    {
      *(void *)(v16 + 16) = a1;
      *a8 = v16;
    }
  }
  return result;
}

void *GetDataSectionWriterClass()
{
  return &__DataSectionWriter;
}

uint64_t BinBlockStreamReader_Con(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v6 = _BinBlockStreamReader_ConInternal(a1, a2, a3, a4, a5, 1, 0);
  if (!v6)
  {
    uint64_t v9 = 0;
    uint64_t inited = _BinBlockStreamReader_InitInternal(a1, 0, 1, (int *)&v9 + 1, &v9);
    if (inited)
    {
      uint64_t v6 = inited;
      BinBlockStreamReader_Des(a1);
    }
    else if (v9 == 1 || HIDWORD(v9) == 1)
    {
      return err_GenerateErrorData();
    }
    else
    {
      return 0;
    }
  }
  return v6;
}

uint64_t _BinBlockStreamReader_ConInternal(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5, int a6, uint64_t a7)
{
  uint64_t result = RefCounted_Con(a1, 1);
  unsigned int v17 = result;
  if (!result)
  {
    *(void *)a1 = &__BinBlockStreamReader;
    *(void *)(a1 + 24) = &unk_26D217FA8;
    *(void *)(a1 + 32) = &unk_26D217FB8;
    *(_WORD *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 112) = 0;
    *(void *)(a1 + 40) = &unk_26D2180A0;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 54) = 0;
    *(void *)(a1 + 120) = a2;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = 0;
    *(_DWORD *)(a1 + 144) = a6;
    *(void *)(a1 + 148) = 0;
    *(void *)(a1 + 160) = a7;
    uint64_t v15 = (void *)OOCAllocator_Malloc(a2, 32, &v17);
    *(void *)(a1 + 80) = v15;
    uint64_t result = v17;
    if (!v17)
    {
      cstdlib_memcpy(v15, a3, 0x20uLL);
      *(void *)(a1 + 88) = a4;
      if (a5)
      {
        *(_DWORD *)(a1 + 64) = *a5;
        uint64_t v16 = (void *)OOCAllocator_Malloc(a2, 4, &v17);
        *(void *)(a1 + 96) = v16;
        uint64_t result = v17;
        if (v17) {
          return result;
        }
        cstdlib_memcpy(v16, a5, 4uLL);
      }
      else
      {
        *(void *)(a1 + 96) = 0;
        *(_DWORD *)(a1 + 64) = 1;
      }
      return PNEW_ParamDB_Con(a2, a2, (void *)(a1 + 136));
    }
  }
  return result;
}

uint64_t _BinBlockStreamReader_InitInternal(uint64_t a1, int a2, int a3, int *a4, _DWORD *a5)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  *a4 = 0;
  *a5 = 0;
  uint64_t v9 = *(void *)(a1 + 136);
  if (a2) {
    int v10 = 2;
  }
  else {
    int v10 = 0;
  }
  unsigned int ErrorData = ParamDB_AddPublicParam(v9, 987249153, v10, (uint64_t)__BinBlockStreamReader_IsValidInterruptibleStatus);
  if (ErrorData) {
    return ErrorData;
  }
  unint64_t v33 = 0;
  uint64_t v34 = 0;
  int v32 = 0;
  if ((**(uint64_t (***)(int *, uint64_t, uint64_t, void))(a1 + 80))(&v36, 1, 28, *(void *)(a1 + 88)) != 28)
  {
    if ((*(unsigned int (**)(void))(*(void *)(a1 + 80) + 16))(*(void *)(a1 + 88))) {
      goto LABEL_11;
    }
    if (ParamDB_GetParam(*(void *)(a1 + 136), 987249153) == 2)
    {
      *a5 = 1;
      return ErrorData;
    }
    if (!a3) {
      goto LABEL_56;
    }
    return err_GenerateErrorData();
  }
  int v11 = v36;
  int v12 = v37;
  *(_DWORD *)(a1 + 48) = v36;
  *(_DWORD *)(a1 + 52) = v12;
  int v13 = v38;
  *(_DWORD *)(a1 + 56) = v38;
  int v14 = v39;
  *(_WORD *)(a1 + 60) = v39;
  int v15 = v40;
  int v16 = v41;
  *(_WORD *)(a1 + 72) = v41;
  unsigned int v17 = v42;
  if (*(_DWORD *)(a1 + 64))
  {
    if (v44)
    {
      if (v12 + v11 + v13 + v14 + v15 + v16 + v42 + v43 != v44) {
        goto LABEL_56;
      }
      int v18 = 0;
    }
    else
    {
      int v18 = 1;
    }
    if (v16) {
      int v20 = v18;
    }
    else {
      int v20 = 1;
    }
  }
  else
  {
    int v20 = 0;
  }
  if (v15 != 1)
  {
    if (!a3) {
      goto LABEL_56;
    }
    return err_GenerateErrorData();
  }
  if ((**(uint64_t (***)(int *, uint64_t, uint64_t, void))(a1 + 80))(&v36, 1, 12, *(void *)(a1 + 88)) != 12)
  {
    if (!(*(unsigned int (**)(void))(*(void *)(a1 + 80) + 16))(*(void *)(a1 + 88)))
    {
      if (ParamDB_GetParam(*(void *)(a1 + 136), 987249153) == 2)
      {
        *a5 = 1;
      }
      else if (a3)
      {
        unsigned int ErrorData = err_GenerateErrorData();
      }
      else
      {
        *a4 = 1;
      }
      goto LABEL_44;
    }
LABEL_11:
    if (a3) {
      return err_GenerateErrorCallback();
    }
LABEL_56:
    int v23 = 1;
    goto LABEL_57;
  }
  if (v36 != 270012440 || v37 != v17 || v38 != 0x10000)
  {
    if (!a3) {
      goto LABEL_56;
    }
    return err_GenerateErrorData();
  }
  unsigned int ErrorData = PNEW_DataSectionReader_ConForInterruptibleStream(*(void *)(a1 + 120), *(void *)(a1 + 120), *(void *)(a1 + 80), *(void *)(a1 + 88), (*(_DWORD *)(a1 + 112) + 40), v17, *(_DWORD *)(a1 + 64), *(unsigned __int16 *)(a1 + 72), &v34);
  if (ErrorData) {
    return ErrorData;
  }
  uint64_t v21 = (**(uint64_t (***)(uint64_t))(v34 + 24))(v34 + 24 - *(void *)(*(void *)(v34 + 24) + 48));
  unsigned int ErrorData = (*(uint64_t (**)(uint64_t, unsigned int **, unint64_t *, int *, _DWORD *))(*(void *)(v34 + 32) + 16))(v34 + 32 - *(void *)(*(void *)(v34 + 32) + 48), &v32, &v33, a4, a5);
  if (ErrorData) {
    return ErrorData;
  }
  if (*a5)
  {
    unsigned int ParameterSection = (*(uint64_t (**)(uint64_t))(*(void *)v34 + 32))(v34);
    goto LABEL_29;
  }
  if (*a4 == 1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v34 + 32))(v34);
  }
  unint64_t v24 = v33;
  if (v33 < 4 || v33 == v21)
  {
    if (a3) {
      return err_GenerateErrorLimit();
    }
    goto LABEL_56;
  }
  uint64_t v25 = v32;
  uint64_t v26 = *v32;
  *(_DWORD *)(a1 + 68) = v26;
  if (v26 == -1 || v24 < 12 * v26 + 4)
  {
    if (!a3)
    {
      *a4 = 1;
      return (*(uint64_t (**)(uint64_t))(*(void *)v34 + 32))(v34);
    }
    return err_GenerateErrorData();
  }
  if (v26)
  {
    uint64_t v28 = OOCAllocator_Malloc(*(void *)(a1 + 120), 12 * v26, &ErrorData);
    *(void *)(a1 + 104) = v28;
    if (ErrorData) {
      return ErrorData;
    }
    uint64_t v29 = *(unsigned int *)(a1 + 68);
    if (v29)
    {
      unsigned int v30 = v25 + 2;
      int v31 = (_DWORD *)(v28 + 8);
      do
      {
        *(v31 - 2) = *(v30 - 1);
        *(v31 - 1) = *v30;
        *int v31 = v30[1];
        v31 += 3;
        v30 += 3;
        --v29;
      }
      while (v29);
    }
  }
  else
  {
    *(void *)(a1 + 104) = 0;
  }
  unsigned int ErrorData = (*(uint64_t (**)(uint64_t))(*(void *)v34 + 32))(v34);
  if (ErrorData) {
    return ErrorData;
  }
  *(_DWORD *)(a1 + 128) = 0;
  if (ParamDB_GetParam(*(void *)(a1 + 136), 987249153) != 2)
  {
    unsigned int ParameterSection = __BinBlockStreamReader_ReadParameterSection((void *)a1);
LABEL_29:
    unsigned int ErrorData = ParameterSection;
    if (ParameterSection) {
      return ErrorData;
    }
  }
LABEL_44:
  if (v20)
  {
    int v23 = 2;
LABEL_57:
    *a4 = v23;
  }
  return ErrorData;
}

uint64_t BinBlockStreamReader_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  uint64_t result = OOC_PlacementDeleteObject(v2, *(void *)(a1 + 136));
  if (result) {
    return result;
  }
  uint64_t v4 = *(void *)(a1 + 104);
  if (v4) {
    OOCAllocator_Free(v2, v4);
  }
  uint64_t v5 = *(void *)(a1 + 80);
  if (v5)
  {
    if (!*(_DWORD *)(a1 + 112) && *(_DWORD *)(a1 + 144))
    {
      if ((*(unsigned int (**)(void))(v5 + 24))(*(void *)(a1 + 88)))
      {
        return err_GenerateErrorCallback();
      }
      uint64_t v5 = *(void *)(a1 + 80);
    }
    OOCAllocator_Free(v2, v5);
  }
  uint64_t v6 = *(void *)(a1 + 96);
  if (v6) {
    OOCAllocator_Free(v2, v6);
  }
  uint64_t result = RefCounted_Des(a1);
  if (!result)
  {
    unint64_t v7 = *(char **)(a1 + 160);
    if (v7)
    {
      unint64_t v8 = **(uint64_t (***)(int64_t))v7;
      int64_t v9 = (int64_t)&v7[-*(void *)(*(void *)v7 + 8)];
      return v8(v9);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_Con2(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t result = _BinBlockStreamReader_ConInternal(a1, a2, a3, a4, a5, 1, 0);
  if (!result)
  {
    uint64_t v8 = 0;
    *(void *)a1 = &__BinBlockStreamReader;
    *(void *)(a1 + 32) = &unk_26D217FB8;
    *(void *)(a1 + 40) = &unk_26D2180A0;
    *(void *)(a1 + 24) = &unk_26D217FA8;
    uint64_t result = _BinBlockStreamReader_InitInternal(a1, 1, 1, (int *)&v8, (_DWORD *)&v8 + 1);
    if (!result)
    {
      int v7 = v8;
      if (v8 == 2) {
        *(_DWORD *)(a1 + 152) = 1;
      }
      if (HIDWORD(v8) == 1) {
        *(_DWORD *)(a1 + 148) = 1;
      }
      uint64_t result = 0;
      if (v7 == 1) {
        *(_DWORD *)(a1 + 148) = 1;
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_Con3(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t result = _BinBlockStreamReader_ConInternal(a1, a2, a3, a4, a5, 1, 0);
  if (!result)
  {
    uint64_t v8 = 0;
    *(void *)a1 = &__BinBlockStreamReader;
    *(void *)(a1 + 32) = &unk_26D217FB8;
    *(void *)(a1 + 40) = &unk_26D2180A0;
    *(void *)(a1 + 24) = &unk_26D217FA8;
    uint64_t result = _BinBlockStreamReader_InitInternal(a1, 1, 0, (int *)&v8, (_DWORD *)&v8 + 1);
    if (!result)
    {
      int v7 = v8;
      if (v8 == 2) {
        *(_DWORD *)(a1 + 152) = 1;
      }
      if (HIDWORD(v8) == 1) {
        *(_DWORD *)(a1 + 148) = 1;
      }
      uint64_t result = 0;
      if (v7 == 1) {
        *(_DWORD *)(a1 + 148) = 1;
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_BorrowIStream(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

uint64_t BinBlockStreamReader_BorrowIStreamInst(uint64_t a1)
{
  return *(void *)(a1 + 88);
}

uint64_t BinBlockStreamReader_BorrowIStreamParams(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

uint64_t BinBlockStreamReader_CheckCRC(uint64_t a1, _DWORD *a2)
{
  *a2 = 0;
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 40) + 200))(a1 + 40 - *(void *)(*(void *)(a1 + 40)
                                                                                                 + 208));
}

uint64_t BinBlockStreamReader_CheckCRCInterruptible(uint64_t a1, int *a2, _DWORD *a3)
{
  uint64_t v25 = *(unsigned int *)(a1 + 112);
  *a3 = 0;
  if (*(_DWORD *)(a1 + 152))
  {
    uint64_t result = 0;
    *a2 = 2;
  }
  else
  {
    uint64_t v28 = 0;
    long long v26 = 0u;
    long long v27 = 0u;
    int v24 = 1;
    int v7 = *(unsigned int (***)(void, void, void))(a1 + 80);
    uint64_t v8 = *(void *)(a1 + 88);
    uint64_t v9 = *(void *)(a1 + 120);
    uint64_t result = PtrStack_Con((uint64_t)&v26, v9, 1);
    unsigned int v29 = result;
    if (!result)
    {
      if (v7[1](v8, *(unsigned int *)(a1 + 112), 0))
      {
        return err_GenerateErrorCallback();
      }
      else
      {
        int v10 = 0;
        do
        {
          if (v10)
          {
            uint64_t result = (*(uint64_t (**)(void))(**(void **)v10 + 32))(*(void *)v10);
            unsigned int v29 = result;
            if (!result)
            {
              OOCAllocator_Free(v9, (uint64_t)v10);
              int v10 = *(_DWORD **)(v28 + 8 * (DWORD2(v27) - 1));
              uint64_t result = PtrStack_Remove((uint64_t)&v26);
              unsigned int v29 = result;
              if (!result)
              {
                unsigned int v11 = v10[2];
                goto LABEL_17;
              }
            }
            return result;
          }
          int v10 = (_DWORD *)OOCAllocator_Malloc(v9, 16, &v29);
          uint64_t result = v29;
          if (!v29)
          {
            uint64_t result = _BinBlockStreamReader_CreateForInterruptibleStreamInternal(v9, v7, v8, &v24, v25, 1, 0, 0, 0, v10, a2, a3);
            unsigned int v29 = result;
            if (!result) {
              goto LABEL_15;
            }
          }
          return result;
LABEL_15:
          if ((*a2 - 1) < 2 || *a3 == 1) {
            break;
          }
          unsigned int v11 = 0;
          v10[2] = 0;
LABEL_17:
          while (v11 < (*(unsigned int (**)(uint64_t))(*(void *)(*(void *)v10 + 32) + 96))(*(void *)v10 + 32 - *(void *)(*(void *)(*(void *)v10 + 32) + 224)))
          {
            uint64_t v23 = 0;
            int v22 = 0;
            uint64_t result = __BinBlockStreamReader_SeekSectionByTocIndex_CheckCRC(*(void *)v10, v10[2], &v23, &v22, &v25, a2, a3);
            unsigned int v29 = result;
            if (result) {
              return result;
            }
            if (*a2 == 1 || *a3 == 1) {
              goto LABEL_40;
            }
            if (v22 == -1)
            {
              ++v10[2];
              uint64_t result = PtrStack_Put((uint64_t)&v26, (uint64_t)v10);
              unsigned int v29 = result;
              if (result) {
                return result;
              }
              int v10 = 0;
              break;
            }
            long long v20 = 0u;
            memset(v21, 0, sizeof(v21));
            long long v19 = 0u;
            uint64_t v17 = 0;
            uint64_t v18 = 0;
            Paraunsigned int m = ParamDB_GetParam(*(void *)(*(void *)v10 + 136), 987249153);
            int v13 = *(_DWORD *)(*(void *)v10 + 64);
            unsigned int v14 = *(unsigned __int16 *)(*(void *)v10 + 72);
            if (Param == 2) {
              uint64_t result = DataSectionReader_ConForInterruptibleStream(&v19, v9, (uint64_t)v7, v8, v25, v23, v13, v14);
            }
            else {
              uint64_t result = DataSectionReader_Con(&v19, v9, (uint64_t)v7, v8, v25, v23, v13, v14);
            }
            unsigned int v29 = result;
            if (result) {
              return result;
            }
            uint64_t v15 = (**((uint64_t (***)(char *))&v20 + 1))((char *)&v20
                                                                 - *(void *)(*((void *)&v20 + 1) + 48) + 8);
            uint64_t v18 = v15;
            while (v18 == v15 && !*a2 && !*a3)
            {
              uint64_t result = (*(uint64_t (**)(char *, uint64_t *, uint64_t *, int *, _DWORD *))(*(void *)&v21[0]
                                                                                                + 16))((char *)v21 - *(void *)(*(void *)&v21[0] + 48), &v17, &v18, a2, a3);
              unsigned int v29 = result;
              if (result) {
                return result;
              }
            }
            uint64_t result = (*(uint64_t (**)(long long *))(v19 + 32))(&v19);
            unsigned int v29 = result;
            if (result) {
              return result;
            }
            if (*a2 == 1 || *a3 == 1) {
              goto LABEL_39;
            }
            unsigned int v11 = v10[2] + 1;
            v10[2] = v11;
          }
        }
        while (DWORD2(v27));
LABEL_39:
        if (!v10) {
          goto LABEL_42;
        }
LABEL_40:
        for (uint64_t result = PtrStack_Put((uint64_t)&v26, (uint64_t)v10); ; uint64_t result = PtrStack_Remove((uint64_t)&v26))
        {
          unsigned int v29 = result;
          if (result) {
            break;
          }
LABEL_42:
          if (!DWORD2(v27)) {
            return (*(uint64_t (**)(long long *))(v26 + 16))(&v26);
          }
          int v16 = *(void **)(v28 + 8 * (DWORD2(v27) - 1));
          if (*v16)
          {
            uint64_t result = (*(uint64_t (**)(void))(*(void *)*v16 + 32))(*v16);
            unsigned int v29 = result;
            if (result) {
              return result;
            }
          }
          OOCAllocator_Free(v9, (uint64_t)v16);
        }
      }
    }
  }
  return result;
}

uint64_t _BinBlockStreamReader_CreateForInterruptibleStreamInternal(uint64_t a1, const void *a2, uint64_t a3, _DWORD *a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, int *a11, _DWORD *a12)
{
  uint64_t v17 = 0;
  uint64_t result = _PNEW_BinBlockStreamReader_ConInternal(a1, a1, a2, a3, a4, a8, a9, (uint64_t *)&v17);
  if (!result)
  {
    int v16 = v17;
    *a10 = v17;
    v16[28] = a5;
    uint64_t result = _BinBlockStreamReader_InitInternal((uint64_t)v16, a6, a7, a11, a12);
    if (!result)
    {
      if (*a12)
      {
        uint64_t result = (*(uint64_t (**)(_DWORD *))(*(void *)v16 + 32))(v16);
        if (!result) {
          *a10 = 0;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t __BinBlockStreamReader_SeekSectionByTocIndex_CheckCRC(uint64_t a1, unsigned int a2, void *a3, _DWORD *a4, void *a5, _DWORD *a6, _DWORD *a7)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  *a3 = *(unsigned int *)(*(void *)(a1 + 104) + 12 * a2 + 4);
  *a6 = 0;
  *a7 = 0;
  if ((*(unsigned int (**)(void, void, void))(*(void *)(a1 + 80) + 8))(*(void *)(a1 + 88), (*(_DWORD *)(a1 + 112) + *(_DWORD *)(*(void *)(a1 + 104) + 12 * a2 + 8)), 0))
  {
    return err_GenerateErrorCallback();
  }
  else if ((**(uint64_t (***)(_DWORD *, uint64_t, uint64_t, void))(a1 + 80))(v18, 1, 12, *(void *)(a1 + 88)) == 12)
  {
    unsigned int v16 = v18[0];
    uint64_t v15 = v18[1];
    *a4 = v18[2];
    uint64_t v17 = *(void *)(a1 + 104);
    uint64_t result = 0;
    if (*(void *)(v17 + 12 * a2) == __PAIR64__(v15, v16))
    {
      *a5 = (*(_DWORD *)(a1 + 112) + *(_DWORD *)(v17 + 12 * a2 + 8) + 12);
      *a3 = v15;
    }
    else
    {
      *a6 = 1;
    }
  }
  else if ((*(unsigned int (**)(void))(*(void *)(a1 + 80) + 16))(*(void *)(a1 + 88)))
  {
    return err_GenerateErrorCallback();
  }
  else if (ParamDB_GetParam(*(void *)(a1 + 136), 987249153) == 2)
  {
    uint64_t result = 0;
    *a7 = 1;
  }
  else
  {
    return err_GenerateErrorData();
  }
  return result;
}

BOOL BinBlockStreamReader_IsInterruptible(uint64_t a1)
{
  return ParamDB_GetParam(*(void *)(a1 + 136), 987249153) == 2;
}

uint64_t BinBlockStreamReader_CheckDependency(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(void *)(a1 + 40) + 56))(a1 + 40 - *(void *)(*(void *)(a1 + 40) + 208), a2, a3, &v5);
  if (result) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = v5 == 0;
  }
  if (!v4) {
    return err_GenerateErrorData();
  }
  return result;
}

uint64_t BinBlockStreamReader_CheckDependencyInterruptible(uint64_t a1, int a2, const char *a3, _DWORD *a4)
{
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)(a1 + 32) + 32))(a1 + 32 - *(void *)(*(void *)(a1 + 32) + 224), 270065117) == 1)
  {
    __s = 0;
    uint64_t v14 = 0;
    uint64_t v12 = 0;
    int v11 = 0;
    uint64_t v9 = *(void *)(a1 + 40);
    uint64_t v8 = a1 + 40;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t *, int *, _DWORD *))(v9 + 8))(v8 - *(void *)(v9 + 208), 270065117, 0, &v14, &v11, a4);
    if (!result)
    {
      if (*a4)
      {
        return 0;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, char **, uint64_t *, _DWORD *))(*(void *)v14 + 8))(v14 - *(void *)(*(void *)v14 + 48), &__s, &v12, a4);
        if (!result)
        {
          if (*a4) {
            return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 32))(v8 - *(void *)(*(void *)v8 + 208), v14);
          }
          uint64_t result = _BinBlockStreamReader_CheckDependency(__s, v12, a2, a3);
          if (!result) {
            return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 32))(v8 - *(void *)(*(void *)v8 + 208), v14);
          }
        }
      }
    }
  }
  else
  {
    return err_GenerateErrorData();
  }
  return result;
}

uint64_t _BinBlockStreamReader_CheckDependency(char *__s, int a2, int a3, const char *a4)
{
  uint64_t v6 = __s;
  int v7 = &__s[a2];
  while (v6 < v7)
  {
    uint64_t v8 = v6 + 4;
    int v9 = *(_DWORD *)v6;
    v6 += (cstdlib_strlen(v6 + 4) + 8) & 0xFFFFFFFC;
    if (v9 == a3)
    {
      uint64_t result = cstdlib_strcmp(a4, v8);
      if (!result) {
        return result;
      }
      break;
    }
  }

  return err_GenerateErrorData();
}

uint64_t BinBlockStreamReader_CheckVersion(uint64_t a1, unsigned int a2)
{
  int v3 = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 64))(a1 + 32 - *(void *)(*(void *)(a1 + 32)
                                                                                              + 224));
  if (!((v3 ^ a2) >> 16) && BYTE1(v3) <= BYTE1(a2)) {
    return 0;
  }

  return err_GenerateErrorVersion();
}

BOOL BinBlockStreamReader_IsVersionAccepted(unsigned int a1, int a2)
{
  return !((a2 ^ a1) >> 16) && BYTE1(a1) <= BYTE1(a2);
}

uint64_t BinBlockStreamReader_CreateForInterruptibleStream(uint64_t a1, const void *a2, uint64_t a3, _DWORD *a4, void *a5, _DWORD *a6)
{
  uint64_t v10 = 0;
  int v9 = 0;
  uint64_t result = _BinBlockStreamReader_CreateForInterruptibleStreamInternal(a1, a2, a3, a4, 0, 0, 1, 1, 0, &v10, &v9, a6);
  if (!result)
  {
    if (*a6)
    {
      uint64_t result = 0;
      *a5 = 0;
    }
    else if (v9 == 1)
    {
      return err_GenerateErrorData();
    }
    else
    {
      uint64_t result = 0;
      *a5 = v10 + 40;
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchBinBlockStreamReader(uint64_t a1, int a2, int a3, void *a4)
{
  int v12 = 0;
  uint64_t v10 = 0;
  uint64_t v6 = *(void *)(a1 + 120);
  uint64_t v8 = 0;
  uint64_t result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v11, &v12, &v10, &v8);
  if (!result)
  {
    if (v8 != 1 && v12 == -1)
    {
      uint64_t v9 = 0;
      (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
      uint64_t result = _BinBlockStreamReader_CreateForInterruptibleStreamInternal(v6, *(const void **)(a1 + 80), *(void *)(a1 + 88), *(_DWORD **)(a1 + 96), v10, 0, 1, 1, a1 + 24, &v9, (int *)&v8 + 1, &v8);
      if (result) {
        return result;
      }
      if (v8 != 1 && HIDWORD(v8) != 1)
      {
        uint64_t result = 0;
        *a4 = v9 + 32;
        *(_DWORD *)(a1 + 128) = 1;
        return result;
      }
    }
    else if (((vars8 ^ (2 * vars8)) & 0x4000000000000000) != 0)
    {
      __break(0xC471u);
    }
    return err_GenerateErrorData();
  }
  return result;
}

uint64_t __BinBlockStreamReader_SeekSection(uint64_t a1, int a2, int a3, void *a4, _DWORD *a5, void *a6, _DWORD *a7)
{
  uint64_t v7 = *(unsigned int *)(a1 + 68);
  if (!v7)
  {
    int v13 = 0;
    LODWORD(v9) = 0;
    goto LABEL_9;
  }
  uint64_t v9 = 0;
  int v10 = 0;
  uint64_t v11 = *(int **)(a1 + 104);
  while (1)
  {
    int v12 = *v11;
    v11 += 3;
    if (v12 == a2) {
      break;
    }
LABEL_6:
    if (v7 == ++v9) {
      goto LABEL_10;
    }
  }
  if (v10 != a3)
  {
    ++v10;
    goto LABEL_6;
  }
  int v15 = 0;
  uint64_t result = __BinBlockStreamReader_SeekSectionByTocIndex_CheckCRC(a1, v9, a4, a5, a6, &v15, a7);
  if (result) {
    return result;
  }
  if (v15 == 1)
  {
LABEL_10:
    return err_GenerateErrorData();
  }
  int v13 = *(_DWORD *)(a1 + 68);
LABEL_9:
  if (v9 == v13) {
    goto LABEL_10;
  }
  return 0;
}

uint64_t BinBlockStreamReader_FetchBinBlockStreamReaderInterruptible(uint64_t a1, int a2, int a3, void *a4, _DWORD *a5)
{
  int v14 = 0;
  uint64_t v12 = 0;
  uint64_t v8 = *(void *)(a1 + 120);
  uint64_t result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v13, &v14, &v12, a5);
  if (!result)
  {
    if (*a5) {
      return 0;
    }
    uint64_t v11 = 0;
    int v10 = 0;
    if (v14 != -1) {
      return err_GenerateErrorData();
    }
    (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
    uint64_t result = _BinBlockStreamReader_CreateForInterruptibleStreamInternal(v8, *(const void **)(a1 + 80), *(void *)(a1 + 88), *(_DWORD **)(a1 + 96), v12, 1, 1, 1, a1 + 24, &v11, &v10, a5);
    if (!result)
    {
      if (!*a5)
      {
        *a4 = v11 + 40;
        *(_DWORD *)(a1 + 128) = 1;
        if (v10 != 1) {
          return 0;
        }
        return err_GenerateErrorData();
      }
      uint64_t result = 0;
      *a4 = 0;
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchDependency(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(void *)(a1 + 40) + 152))(a1 + 40 - *(void *)(*(void *)(a1 + 40) + 208), a2, a3, &v5);
  if (result) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = v5 == 0;
  }
  if (!v4) {
    return err_GenerateErrorData();
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchDependencyInterruptible(void *a1, int a2, void *a3, _DWORD *a4)
{
  *a3 = 0;
  *a4 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a1[4] + 32))((uint64_t)a1 - *(void *)(a1[4] + 224) + 32, 270065117);
  if (result)
  {
    if (result == 1)
    {
      __s = 0;
      uint64_t v18 = 0;
      uint64_t v16 = 0;
      int v15 = 0;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t *, int *, _DWORD *))(a1[5] + 8))((uint64_t)a1 - *(void *)(a1[5] + 208) + 40, 270065117, 0, &v18, &v15, a4);
      if (!result)
      {
        if (*a4)
        {
          return 0;
        }
        else
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, char **, uint64_t *, _DWORD *))(*(void *)v18 + 8))(v18 - *(void *)(*(void *)v18 + 48), &__s, &v16, a4);
          unsigned int v19 = result;
          if (!result)
          {
            if (!*a4)
            {
              uint64_t v9 = __s;
              int v10 = &__s[v16];
              while (v9 < v10)
              {
                uint64_t v11 = v9 + 4;
                int v12 = *(_DWORD *)v9;
                v9 += (cstdlib_strlen(v9 + 4) + 8) & 0xFFFFFFFC;
                if (v12 == a2)
                {
                  size_t v13 = cstdlib_strlen(v11) + 1;
                  int v14 = (void *)OOCAllocator_Malloc(a1[15], v13, &v19);
                  *a3 = v14;
                  uint64_t result = v19;
                  if (v19) {
                    return result;
                  }
                  cstdlib_memcpy(v14, v11, v13);
                  return (*(uint64_t (**)(uint64_t, uint64_t))(a1[5] + 32))((uint64_t)a1 - *(void *)(a1[5] + 208) + 40, v18);
                }
              }
            }
            return (*(uint64_t (**)(uint64_t, uint64_t))(a1[5] + 32))((uint64_t)a1 - *(void *)(a1[5] + 208) + 40, v18);
          }
        }
      }
    }
    else
    {
      return err_GenerateErrorData();
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchDependencyTypes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(void *)(a1 + 40) + 184))(a1 + 40 - *(void *)(*(void *)(a1 + 40) + 208), a2, a3, &v5);
  if (result) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = v5 == 0;
  }
  if (!v4) {
    return err_GenerateErrorData();
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchDependencyTypesInterruptible(void *a1, uint64_t *a2, uint64_t *a3, _DWORD *a4)
{
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a1[4] + 32))((uint64_t)a1 - *(void *)(a1[4] + 224) + 32, 270065117);
  if (result)
  {
    if (result == 1)
    {
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      uint64_t v22 = 0;
      int v21 = 0;
      uint64_t v9 = (char *)(a1 + 5);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t *, int *, _DWORD *))(a1[5] + 8))((uint64_t)a1 - *(void *)(a1[5] + 208) + 40, 270065117, 0, &v24, &v21, a4);
      if (!result)
      {
        if (*a4) {
          return 0;
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, const char **, uint64_t *, _DWORD *))(*(void *)v24 + 8))(v24 - *(void *)(*(void *)v24 + 48), &v23, &v22, a4);
        unsigned int v25 = result;
        if (!result)
        {
          if (*a4) {
            return (*(uint64_t (**)(char *, uint64_t))(*(void *)v9 + 32))(&v9[-*(void *)(*(void *)v9 + 208)], v24);
          }
          if (v22 <= 4)
          {
            uint64_t v14 = *a3;
          }
          else
          {
            int v10 = v23;
            unint64_t v11 = (unint64_t)&v23[v22];
            int v12 = v23 + 4;
            do
            {
              int v13 = cstdlib_strlen(v12);
              uint64_t v14 = *a3 + 1;
              *a3 = v14;
              v10 += (v13 + 8) & 0xFFFFFFFC;
              int v12 = v10 + 4;
            }
            while ((unint64_t)(v10 + 4) < v11);
          }
          *a2 = OOCAllocator_Malloc(a1[15], 8 * v14, &v25);
          uint64_t result = v25;
          if (!v25)
          {
            if (*a3)
            {
              uint64_t v15 = 0;
              unsigned int v16 = 1;
              uint64_t v17 = v23;
              do
              {
                uint64_t v18 = *(unsigned int *)v17;
                int v19 = cstdlib_strlen(v17 + 4);
                *(void *)(*a2 + 8 * v15) = v18;
                v17 += (v19 + 8) & 0xFFFFFFFC;
                uint64_t v15 = v16;
              }
              while (*a3 > (unint64_t)v16++);
            }
            return (*(uint64_t (**)(char *, uint64_t))(*(void *)v9 + 32))(&v9[-*(void *)(*(void *)v9 + 208)], v24);
          }
        }
      }
    }
    else
    {
      return err_GenerateErrorData();
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchRawSectionDataStreamReaderInterruptible(uint64_t a1, int a2, int a3, void *a4, _DWORD *a5, _DWORD *a6)
{
  return _BinBlockStreamReader_FetchSectionDataStreamReaderInterruptibleExt(a1, a2, a3, 1, a4, a5, a6);
}

uint64_t _BinBlockStreamReader_FetchSectionDataStreamReaderInterruptibleExt(uint64_t a1, int a2, int a3, int a4, void *a5, _DWORD *a6, _DWORD *a7)
{
  int v21 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v18 = 0;
  uint64_t v12 = *(void *)(a1 + 120);
  if (a4) {
    BOOL v13 = 0;
  }
  else {
    BOOL v13 = *(_DWORD *)(a1 + 64) == 1;
  }
  int v14 = v13;
  uint64_t result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v20, &v21, &v19, a7);
  if (!result)
  {
    if (*a7)
    {
      return 0;
    }
    else
    {
      int v16 = v21;
      if (a4 || v21 != -1)
      {
        if (a4 == 1) {
          unsigned int v17 = 0;
        }
        else {
          unsigned int v17 = *(unsigned __int16 *)(a1 + 72);
        }
        uint64_t result = PNEW_DataSectionReader_ConForInterruptibleStream(v12, v12, *(void *)(a1 + 80), *(void *)(a1 + 88), v19, v20, v14, v17, &v18);
        if (!result)
        {
          *a5 = v18 + 32;
          *a6 = v16;
          *(_DWORD *)(a1 + 128) = 1;
        }
      }
      else
      {
        return err_GenerateErrorData();
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchSectionDataStreamReader(uint64_t a1, int a2, int a3, void *a4, _DWORD *a5)
{
  int v15 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v12 = 0;
  uint64_t v8 = *(void *)(a1 + 120);
  int v11 = 0;
  uint64_t result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v14, &v15, &v13, &v11);
  if (!result)
  {
    if (v11 == 1 || (int v10 = v15, v15 == -1))
    {
      return err_GenerateErrorData();
    }
    else
    {
      uint64_t result = PNEW_DataSectionReader_Con(v8, v8, *(void *)(a1 + 80), *(void *)(a1 + 88), v13, v14, *(_DWORD *)(a1 + 64), *(unsigned __int16 *)(a1 + 72), &v12);
      if (!result)
      {
        *a4 = v12 + 24;
        *a5 = v10;
        *(_DWORD *)(a1 + 128) = 1;
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchSectionDataStreamReaderInterruptible(uint64_t a1, int a2, int a3, void *a4, _DWORD *a5, _DWORD *a6)
{
  return _BinBlockStreamReader_FetchSectionDataStreamReaderInterruptibleExt(a1, a2, a3, 0, a4, a5, a6);
}

uint64_t BinBlockStreamReader_GetAlignment(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 60);
}

uint64_t BinBlockStreamReader_GetCRCBlockSize(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 72);
}

uint64_t BinBlockStreamReader_GetCRCBlockSizeInterruptible(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 72);
}

uint64_t BinBlockStreamReader_GetNrSectionInstances(uint64_t result, int a2)
{
  uint64_t v2 = *(unsigned int *)(result + 68);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = result;
  LODWORD(result) = 0;
  BOOL v4 = *(int **)(v3 + 104);
  do
  {
    int v5 = *v4;
    v4 += 3;
    if (v5 == a2) {
      uint64_t result = (result + 1);
    }
    else {
      uint64_t result = result;
    }
    --v2;
  }
  while (v2);
  return result;
}

uint64_t BinBlockStreamReader_GetNrSections(uint64_t a1)
{
  return *(unsigned int *)(a1 + 68);
}

uint64_t BinBlockStreamReader_GetSectionDataIfAvailable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v9 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int *))(*(void *)(a1 + 40) + 64))(a1 + 40 - *(void *)(*(void *)(a1 + 40) + 208), a2, a3, a4, a5, a6, a7, &v9);
  if (result) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = v9 == 0;
  }
  if (!v8) {
    return err_GenerateErrorData();
  }
  return result;
}

uint64_t BinBlockStreamReader_GetSectionDataIfAvailableInterruptible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t *a6, uint64_t *a7, _DWORD *a8)
{
  *a8 = 0;
  *a6 = 0;
  *a7 = 0;
  unsigned int v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 32) + 32))(a1 + 32 - *(void *)(*(void *)(a1 + 32) + 224), a3);
  uint64_t result = 0;
  if (v16 > a4)
  {
    uint64_t v23 = 0;
    int v22 = 0;
    uint64_t v19 = *(void *)(a1 + 40);
    uint64_t v18 = a1 + 40;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *, int *, _DWORD *))(v19 + 8))(v18 - *(void *)(v19 + 208), a3, a4, &v23, &v22, a8);
    unsigned int v24 = result;
    if (!result)
    {
      if (*a8) {
        return 0;
      }
      if ((v22 ^ a5) >> 16 || BYTE1(v22) > BYTE1(a5)) {
        return err_GenerateErrorVersion();
      }
      uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v23 + 24))(v23 - *(void *)(*(void *)v23 + 48));
      if (!v20)
      {
        uint64_t v21 = 0;
LABEL_14:
        if (*a8)
        {
          OOCAllocator_Free(a2, v21);
          return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v18 + 32))(v18 - *(void *)(*(void *)v18 + 208), v23);
        }
        else
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v18 + 32))(v18 - *(void *)(*(void *)v18 + 208), v23);
          if (!result)
          {
            *a6 = v21;
            *a7 = v20;
          }
        }
        return result;
      }
      uint64_t v21 = OOCAllocator_Malloc(a2, v20, &v24);
      uint64_t result = v24;
      if (!v24)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, _DWORD *))(*(void *)v23 + 32))(v23 - *(void *)(*(void *)v23 + 48), v21, a8);
        unsigned int v24 = result;
        if (!result) {
          goto LABEL_14;
        }
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_GetSectionDataRandomReader(uint64_t a1, int a2, int a3, void *a4, _DWORD *a5)
{
  int v15 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v12 = 0;
  uint64_t v8 = *(void *)(a1 + 120);
  int v11 = 0;
  uint64_t result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v14, &v15, &v13, &v11);
  if (!result)
  {
    if (v11 == 1 || (int v10 = v15, v15 == -1))
    {
      return err_GenerateErrorData();
    }
    else
    {
      uint64_t result = PNEW_DataSectionRandomReader_Con(v8, v8, *(void *)(a1 + 80), *(void *)(a1 + 88), a1 + 24, v13, v14, *(unsigned __int16 *)(a1 + 72), &v12);
      if (!result)
      {
        (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
        uint64_t result = 0;
        *a4 = v12 + 24;
        *a5 = v10;
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_GetSectionDataRandomReaderInterruptible(uint64_t a1, int a2, int a3, void *a4, _DWORD *a5, _DWORD *a6)
{
  int v22 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v19 = 0;
  uint64_t v10 = *(void *)(a1 + 120);
  uint64_t result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v21, &v22, &v20, a6);
  if (!result)
  {
    if (*a6 == 1)
    {
      return 0;
    }
    else
    {
      int v12 = v22;
      if (v22 == -1)
      {
        return err_GenerateErrorData();
      }
      else
      {
        uint64_t v13 = *(void *)(a1 + 88);
        uint64_t v18 = *(void *)(a1 + 80);
        uint64_t v14 = v20;
        unsigned int v15 = v21;
        unsigned int v16 = *(unsigned __int16 *)(a1 + 72);
        Paraunsigned int m = ParamDB_GetParam(*(void *)(a1 + 136), 987249153);
        uint64_t result = PNEW_DataSectionRandomReader_ConForInterruptible(v10, v10, v18, v13, a1 + 24, v14, v15, v16, Param == 2, &v19);
        if (!result)
        {
          (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
          uint64_t result = 0;
          *a4 = v19 + 32;
          *a5 = v12;
        }
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_GetSectionID(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  *a3 = 0;
  uint64_t v3 = *(void *)(a1 + 104);
  uint64_t result = *(unsigned int *)(v3 + 12 * a2);
  if (a2)
  {
    int v5 = 0;
    unsigned int v6 = a2 - 1;
    do
    {
      uint64_t v7 = v6;
      if (*(_DWORD *)(v3 + 12 * v6) == result) {
        *a3 = ++v5;
      }
      --v6;
    }
    while (v7);
  }
  return result;
}

uint64_t BinBlockStreamReader_GetSectionVersion(uint64_t a1, int a2, int a3, _DWORD *a4)
{
  int v9 = 0;
  int v6 = 0;
  uint64_t result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v8, &v9, &v7, &v6);
  if (!result && v6 != 1)
  {
    if (v9 == -1)
    {
      return err_GenerateErrorData();
    }
    else
    {
      uint64_t result = 0;
      *a4 = v9;
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_GetSize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t BinBlockStreamReader_GetType(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t BinBlockStreamReader_GetVersion(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

uint64_t BinBlockStreamReader_IsDataSection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, int *))(*(void *)(a1 + 40) + 176))(a1 + 40 - *(void *)(*(void *)(a1 + 40) + 208), a2, a3, a4, &v6);
  if (result) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v6 == 1;
  }
  if (v5) {
    return err_GenerateErrorData();
  }
  return result;
}

uint64_t BinBlockStreamReader_IsDataSectionInterruptible(uint64_t a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  int v9 = 0;
  uint64_t result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v8, &v9, &v7, a5);
  if (!result) {
    *a4 = v9 != -1;
  }
  return result;
}

BOOL BinBlockStreamReader_IsValidHeaderCRC(uint64_t a1)
{
  return *(_DWORD *)(a1 + 148) == 0;
}

uint64_t BinBlockStreamReader_NotifyFinished(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
}

uint64_t BinBlockStreamReader_ReturnBinBlockStreamReader(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) = 0;
  BOOL v5 = *(uint64_t (**)(uint64_t))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 144))(a2 - *(void *)(*(void *)a2 + 224))
                                         + 32);
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 144))(a2 - *(void *)(*(void *)a2 + 224));

  return v5(v3);
}

uint64_t BinBlockStreamReader_ReturnBinBlockStreamReaderInterruptible(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) = 0;
  BOOL v5 = *(uint64_t (**)(uint64_t))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 160))(a2 - *(void *)(*(void *)a2 + 208))
                                         + 32);
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 160))(a2 - *(void *)(*(void *)a2 + 208));

  return v5(v3);
}

uint64_t BinBlockStreamReader_ReturnDependency(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t BinBlockStreamReader_ReturnDependencyTypes(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 40) + 192))(a1 + 40 - *(void *)(*(void *)(a1 + 40)
                                                                                                 + 208));
}

uint64_t BinBlockStreamReader_ReturnDependencyTypesInterruptible(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t BinBlockStreamReader_ReturnRawSectionDataStreamReaderInterruptible(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 40) + 32))(a1 + 40 - *(void *)(*(void *)(a1 + 40)
                                                                                                + 208));
}

uint64_t BinBlockStreamReader_ReturnSectionDataStreamReader(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) = 0;
  BOOL v5 = *(uint64_t (**)(uint64_t))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 48))
                                         + 32);
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 48));

  return v5(v3);
}

uint64_t BinBlockStreamReader_ReturnSectionDataStreamReaderInterruptible(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) = 0;
  BOOL v5 = *(uint64_t (**)(uint64_t))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 48))
                                         + 32);
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 48));

  return v5(v3);
}

uint64_t _PNEW_BinBlockStreamReader_ConInternal(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5, int a6, uint64_t a7, uint64_t *a8)
{
  unsigned int v18 = 0;
  uint64_t v16 = OOCAllocator_Malloc(a1, 168, &v18);
  uint64_t result = v18;
  if (!v18)
  {
    uint64_t result = _BinBlockStreamReader_ConInternal(v16, a2, a3, a4, a5, a6, a7);
    unsigned int v18 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v16);
      *a8 = 0;
      return v18;
    }
    else
    {
      *(void *)(v16 + 16) = a1;
      *a8 = v16;
    }
  }
  return result;
}

BOOL __BinBlockStreamReader_IsValidInterruptibleStatus(unsigned int a1)
{
  return a1 < 3;
}

uint64_t __BinBlockStreamReader_ReadParameterSection(void *a1)
{
  unsigned int v2 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[4] + 32))((uint64_t)a1 - *(void *)(a1[4] + 224) + 32, 987184693);
  if (v2 < 2)
  {
    if (v2 != 1)
    {
      ParamDB_SetParam(a1[17], 987249153, 1);
      return 0;
    }
    uint64_t v8 = 0;
    int v7 = 0;
    uint64_t v5 = 0;
    int v6 = 0;
    int v4 = 0;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t *, int *, int *))(a1[5] + 8))((uint64_t)a1 - *(void *)(a1[5] + 208) + 40, 987184693, 0, &v8, &v7, &v4);
    if (result) {
      return result;
    }
    if (!v4)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, unsigned __int16 **, uint64_t *, int *))(*(void *)v8 + 8))(v8 - *(void *)(*(void *)v8 + 48), &v6, &v5, &v4);
      if (result) {
        return result;
      }
      if (!v4)
      {
        uint64_t result = ParamDB_LoadBinaryBuffer(a1[17], v6);
        if (result) {
          return result;
        }
        if (ParamDB_GetParam(a1[17], 987249153)) {
          return (*(uint64_t (**)(uint64_t, uint64_t))(a1[5] + 32))((uint64_t)a1 - *(void *)(a1[5] + 208) + 40, v8);
        }
      }
    }
    return err_GenerateErrorData();
  }

  return err_GenerateErrorData();
}

uint64_t PNEW_BinBlockStreamReader_Con(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 168, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = BinBlockStreamReader_Con(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *(void *)(v12 + 16) = a1;
      *a6 = v12;
    }
  }
  return result;
}

uint64_t PNEW_BinBlockStreamReader_Con2(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 168, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = BinBlockStreamReader_Con2(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *(void *)(v12 + 16) = a1;
      *a6 = v12;
    }
  }
  return result;
}

uint64_t PNEW_BinBlockStreamReader_Con3(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 168, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = BinBlockStreamReader_Con3(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *(void *)(v12 + 16) = a1;
      *a6 = v12;
    }
  }
  return result;
}

void *GetBinBlockStreamReaderClass()
{
  return &__BinBlockStreamReader;
}

uint64_t DataSectionReader_Con(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int a7, unsigned int a8)
{
  uint64_t v16 = RefCounted_Con((uint64_t)a1, 1);
  if (!v16)
  {
    *a1 = &__DataSectionReader;
    a1[3] = &unk_26D2181A8;
    a1[4] = &unk_26D2181E0;
    __DataSectionReader_ConInternal((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8, 0);
  }
  return v16;
}

uint64_t __DataSectionReader_ConInternal(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int a7, unsigned int a8, int a9)
{
  uint64_t v9 = result;
  *(void *)(result + 96) = a3;
  *(void *)(result + 104) = a4;
  *(_DWORD *)(result + 40) = a7;
  BOOL v10 = (a8 & 1) != 0 && (__int16)a8 <= -1;
  int v11 = a8 & 0x7FFE;
  BOOL v12 = !v10 || v11 == 0;
  unsigned int v13 = v11 << 15;
  if (v12) {
    unsigned int v14 = a8;
  }
  else {
    unsigned int v14 = v13;
  }
  *(_DWORD *)(result + 72) = v14;
  if (v14 <= 0x4000) {
    uint64_t v15 = 0x4000;
  }
  else {
    uint64_t v15 = v14;
  }
  *(void *)(result + 48) = 0;
  *(void *)(result + 56) = v15;
  *(void *)(result + 64) = a5;
  unint64_t v16 = a6;
  *(void *)(result + 88) = a6;
  *(void *)(result + 128) = a2;
  *(_DWORD *)(result + 136) = a9;
  if (v14)
  {
    *(void *)(result + 80) = a6 - 4 * ((a6 + (unint64_t)v14 + 3) / (v14 + 4));
    uint64_t result = adler3200(0, 0, 0);
    *(_DWORD *)(v9 + 120) = result;
    unsigned int v14 = *(_DWORD *)(v9 + 72);
    unint64_t v16 = *(void *)(v9 + 80);
  }
  else
  {
    *(void *)(result + 80) = a6;
  }
  if (v16 < v14) {
    unsigned int v14 = v16;
  }
  *(_DWORD *)(v9 + 112) = v16;
  *(_DWORD *)(v9 + 116) = v14;
  return result;
}

uint64_t DataSectionReader_ConForInterruptibleStream(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int a7, unsigned int a8)
{
  uint64_t v16 = RefCounted_Con((uint64_t)a1, 1);
  if (!v16)
  {
    *a1 = &__DataSectionReader;
    a1[3] = &unk_26D2181A8;
    a1[4] = &unk_26D2181E0;
    __DataSectionReader_ConInternal((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8, 1);
  }
  return v16;
}

uint64_t DataSectionReader_Des(uint64_t a1)
{
  OOCAllocator_Free(*(void *)(a1 + 128), *(void *)(a1 + 48));

  return RefCounted_Des(a1);
}

uint64_t DataSectionReader_BorrowDataBlock(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(void *)(a1 + 32) + 8))(a1 + 32 - *(void *)(*(void *)(a1 + 32) + 48), a2, a3, &v5);
  if (result) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = v5 == 0;
  }
  if (!v4) {
    return err_GenerateErrorData();
  }
  return result;
}

uint64_t DataSectionReader_BorrowDataBlockInterruptible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *, uint64_t))(*(void *)(a1 + 32) + 16))(a1 + 32 - *(void *)(*(void *)(a1 + 32) + 48), a2, a3, &v6, a4);
  if (result) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v6 == 1;
  }
  if (v5) {
    return err_GenerateErrorData();
  }
  return result;
}

uint64_t DataSectionReader_BorrowDataBlockWithCheck(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, int *))(*(void *)(a1 + 32) + 16))(a1 + 32 - *(void *)(*(void *)(a1 + 32) + 48), a2, a3, a4, &v6);
  if (result) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = v6 == 0;
  }
  if (!v5) {
    return err_GenerateErrorData();
  }
  return result;
}

uint64_t DataSectionReader_BorrowDataBlockWithCheckInterruptible(uint64_t a1, void *a2, void *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned int v13 = 0;
  BOOL v10 = *(unsigned __int8 **)(a1 + 48);
  if (v10
    || (BOOL v10 = (unsigned __int8 *)OOCAllocator_Malloc(*(void *)(a1 + 128), *(void *)(a1 + 56) + 4, &v13),
        *(void *)(a1 + 48) = v10,
        (uint64_t result = v13) == 0))
  {
    uint64_t v12 = 0;
    uint64_t result = __DataSectionReader_FillBufferWithCheck(a1, v10, *(void *)(a1 + 56), &v12, a4, a5);
    unsigned int v13 = result;
    if (!result)
    {
      if (*a5)
      {
        if (*(_DWORD *)(a1 + 136))
        {
          OOCAllocator_Free(*(void *)(a1 + 128), *(void *)(a1 + 48));
          *(void *)(a1 + 48) = 0;
          return v13;
        }
        else
        {
          uint64_t result = 0;
          *a4 = 0;
        }
      }
      else
      {
        uint64_t result = 0;
        *a2 = *(void *)(a1 + 48);
        *a3 = v12;
      }
    }
  }
  return result;
}

uint64_t __DataSectionReader_FillBufferWithCheck(uint64_t a1, unsigned __int8 *a2, unint64_t a3, uint64_t *a4, _DWORD *a5, _DWORD *a6)
{
  *a5 = 2 * (*(_DWORD *)(a1 + 72) == 0);
  *a6 = 0;
  *a4 = 0;
  unint64_t v6 = *(unsigned int *)(a1 + 112);
  if (!v6) {
    return 0;
  }
  if (v6 >= a3) {
    unint64_t v11 = a3;
  }
  else {
    unint64_t v11 = *(unsigned int *)(a1 + 112);
  }
  if (*(_DWORD *)(a1 + 72))
  {
    uint64_t v13 = 0;
    uint64_t ErrorCallback = 0;
    uint64_t v15 = a2;
    while (1)
    {
      if (!v11) {
        goto LABEL_49;
      }
      unint64_t v16 = v11 >= *(unsigned int *)(a1 + 116) ? *(unsigned int *)(a1 + 116) : v11;
      if (*(_DWORD *)(a1 + 72) && (v11 > v16 + 4 || *(unsigned __int8 **)(a1 + 48) == a2))
      {
        char v18 = 0;
        uint64_t v17 = 4;
      }
      else
      {
        uint64_t v17 = 0;
        char v18 = 1;
      }
      if ((**(uint64_t (***)(unsigned __int8 *, uint64_t, uint64_t, void))(a1 + 96))(v15, 1, v17 + v16, *(void *)(a1 + 104)) != v17 + v16)break; {
      if (*(_DWORD *)(a1 + 40))
      }
        *(_DWORD *)(a1 + 120) = adler3200(*(_DWORD *)(a1 + 120), v15, v16);
      int v19 = *(_DWORD *)(a1 + 116) - v16;
      *(_DWORD *)(a1 + 116) = v19;
      if (v19)
      {
        v13 += v16;
      }
      else
      {
        if (v18)
        {
          uint64_t v20 = v27;
          if ((**(uint64_t (***)(unsigned char *, uint64_t, uint64_t, void))(a1 + 96))(v27, 1, 4, *(void *)(a1 + 104)) != 4)
          {
            if ((*(unsigned int (**)(void))(*(void *)(a1 + 96) + 16))(*(void *)(a1 + 104)))
            {
              uint64_t ErrorCallback = err_GenerateErrorCallback();
              goto LABEL_34;
            }
            *a6 = 1;
            int v22 = 3;
LABEL_36:
            if (v22 != 3) {
              return ErrorCallback;
            }
            goto LABEL_49;
          }
        }
        else
        {
          uint64_t v20 = &v15[v16];
        }
        if (*(_DWORD *)(a1 + 40))
        {
          if (*(_DWORD *)v20 != *(_DWORD *)(a1 + 120))
          {
            *a5 = 1;
LABEL_34:
            int v22 = 4;
            goto LABEL_36;
          }
          *(_DWORD *)(a1 + 120) = adler3200(0, 0, 0);
        }
        unint64_t v21 = *(unsigned int *)(a1 + 72);
        v13 += v16;
        if ((unint64_t)*(unsigned int *)(a1 + 112) - v13 < v21) {
          LODWORD(v21) = *(_DWORD *)(a1 + 112) - v13;
        }
        *(_DWORD *)(a1 + 116) = v21;
      }
      v15 += v16;
      v11 -= v16;
    }
    if ((*(unsigned int (**)(void))(*(void *)(a1 + 96) + 16))(*(void *)(a1 + 104))) {
      return err_GenerateErrorCallback();
    }
    *a6 = 1;
LABEL_49:
    *(_DWORD *)(a1 + 112) -= v13;
    *a4 = v13;
    return ErrorCallback;
  }
  uint64_t v23 = (**(uint64_t (***)(unsigned __int8 *, uint64_t, unint64_t, void))(a1 + 96))(a2, 1, v11, *(void *)(a1 + 104));
  if (v23 == v11)
  {
LABEL_47:
    uint64_t ErrorCallback = 0;
    *(_DWORD *)(a1 + 112) -= v23;
    *a4 = v23;
    return ErrorCallback;
  }
  if (!(*(unsigned int (**)(void))(*(void *)(a1 + 96) + 16))(*(void *)(a1 + 104)))
  {
    *a6 = 1;
    goto LABEL_47;
  }

  return err_GenerateErrorCallback();
}

uint64_t DataSectionReader_FillData(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3 = 0;
  uint64_t result = __DataSectionReader_FillBufferWithCheck(a1, a2, *(void *)(a1 + 80), &v4, (_DWORD *)&v3 + 1, &v3);
  if (!result)
  {
    if (HIDWORD(v3) == 1 || v3)
    {
      return err_GenerateErrorData();
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t DataSectionReader_FillDataInterruptible(uint64_t a1, unsigned __int8 *a2, _DWORD *a3)
{
  int v6 = 0;
  uint64_t result = __DataSectionReader_FillBufferWithCheck(a1, a2, *(void *)(a1 + 80), &v7, &v6, a3);
  if (!result)
  {
    if (v6 == 1 || *a3 && !*(_DWORD *)(a1 + 136))
    {
      return err_GenerateErrorData();
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t DataSectionReader_GetDataBlockSize(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t DataSectionReader_GetDataSize(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

uint64_t PNEW_DataSectionReader_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int a7, unsigned int a8, void *a9)
{
  unsigned int v19 = 0;
  uint64_t v17 = (void *)OOCAllocator_Malloc(a1, 144, &v19);
  uint64_t result = v19;
  if (!v19)
  {
    uint64_t result = DataSectionReader_Con(v17, a2, a3, a4, a5, a6, a7, a8);
    unsigned int v19 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v17);
      *a9 = 0;
      return v19;
    }
    else
    {
      _OWORD v17[2] = a1;
      *a9 = v17;
    }
  }
  return result;
}

uint64_t PNEW_DataSectionReader_ConForInterruptibleStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int a7, unsigned int a8, void *a9)
{
  unsigned int v19 = 0;
  uint64_t v17 = (void *)OOCAllocator_Malloc(a1, 144, &v19);
  uint64_t result = v19;
  if (!v19)
  {
    uint64_t result = DataSectionReader_ConForInterruptibleStream(v17, a2, a3, a4, a5, a6, a7, a8);
    unsigned int v19 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v17);
      *a9 = 0;
      return v19;
    }
    else
    {
      _OWORD v17[2] = a1;
      *a9 = v17;
    }
  }
  return result;
}

void *GetDataSectionReaderClass()
{
  return &__DataSectionReader;
}

uint64_t ParamDB_Con(void *a1, uint64_t a2)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__ParamDB;
    a1[1] = a2;
    return PNEW_PtrList_Con(a2, a2, 0xAu, 10, a1 + 2);
  }
  return result;
}

uint64_t ParamDB_Des(uint64_t a1)
{
  if (PtrList_NrItems(*(void *)(a1 + 16)))
  {
    unsigned int v2 = 0;
    do
    {
      uint64_t v3 = *(void *)(a1 + 8);
      uint64_t v4 = PtrList_ItemN(*(void *)(a1 + 16), v2);
      OOCAllocator_Free(v3, v4);
      ++v2;
    }
    while (v2 < PtrList_NrItems(*(void *)(a1 + 16)));
  }
  uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 8), *(void *)(a1 + 16));
  if (!result)
  {
    return Object_Des();
  }
  return result;
}

uint64_t ParamDB_AddComputedParam(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  return __ParamDB_AddParam(a1, a2, a3, a4, a5, 0, 1);
}

uint64_t __ParamDB_AddParam(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, _DWORD *a6, int a7)
{
  unsigned int v16 = 0;
  int v17 = a2;
  PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v17, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
  uint64_t v13 = OOCAllocator_Malloc(*(void *)(a1 + 8), 48, &v16);
  uint64_t result = v16;
  if (!v16)
  {
    int v15 = v17;
    *(void *)(v13 + 16) = a6;
    *(_DWORD *)uint64_t v13 = v15;
    *(_DWORD *)(v13 + 4) = a3;
    if (a6) {
      *a6 = a3;
    }
    else {
      *(_DWORD *)(v13 + 8) = a3;
    }
    *(void *)(v13 + 24) = a4;
    *(void *)(v13 + 40) = a5;
    *(_DWORD *)(v13 + 32) = a7;
    *(_DWORD *)(v13 + 36) = 0;
    return PtrList_Append(*(void *)(a1 + 16), v13);
  }
  return result;
}

uint64_t ParamDB_AddComputedParamRef(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  return __ParamDB_AddParam(a1, a2, a3, a4, a5, a6, 1);
}

uint64_t ParamDB_AddPrivateParam(uint64_t a1, int a2, int a3, uint64_t a4)
{
  return __ParamDB_AddParam(a1, a2, a3, a4, 0, 0, 0);
}

uint64_t ParamDB_AddPrivateParamRef(uint64_t a1, int a2, int a3, uint64_t a4, _DWORD *a5)
{
  return __ParamDB_AddParam(a1, a2, a3, a4, 0, a5, 0);
}

uint64_t ParamDB_AddPrivateReadOnlyParam(uint64_t a1, int a2, int a3)
{
  return __ParamDB_AddParam(a1, a2, a3, 0, 0, 0, 0);
}

uint64_t ParamDB_AddPublicParam(uint64_t a1, int a2, int a3, uint64_t a4)
{
  return __ParamDB_AddParam(a1, a2, a3, a4, 0, 0, 1);
}

uint64_t ParamDB_AddPublicParamRef(uint64_t a1, int a2, int a3, uint64_t a4, _DWORD *a5)
{
  return __ParamDB_AddParam(a1, a2, a3, a4, 0, a5, 1);
}

uint64_t ParamDB_AddPublicReadOnlyParam(uint64_t a1, int a2, int a3)
{
  return __ParamDB_AddParam(a1, a2, a3, 0, 0, 0, 1);
}

uint64_t ParamDB_CalculateBinaryBufferSize(uint64_t a1)
{
  return (16 * PtrList_NrItems(*(void *)(a1 + 16))) | 4;
}

uint64_t ParamDB_FetchAllParams(uint64_t a1, uint64_t *a2, void *a3)
{
  unsigned int v10 = 0;
  uint64_t result = PtrList_NrItems(*(void *)(a1 + 16));
  if (result)
  {
    LODWORD(v7) = result;
    uint64_t v8 = OOCAllocator_Malloc(*(void *)(a1 + 8), 4 * result, &v10);
    uint64_t result = v10;
    if (v10) {
      return result;
    }
    uint64_t v9 = 0;
    uint64_t v7 = v7;
    do
    {
      *(_DWORD *)(v8 + 4 * v9) = *(_DWORD *)PtrList_ItemN(*(void *)(a1 + 16), v9);
      ++v9;
    }
    while (v7 != v9);
    uint64_t result = v10;
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
  }
  *a2 = v8;
  *a3 = v7;
  return result;
}

uint64_t ParamDB_FetchBinaryBuffer(uint64_t a1, void *a2, uint64_t *a3)
{
  unsigned int v19 = 0;
  uint64_t result = PtrList_NrItems(*(void *)(a1 + 16));
  if (result)
  {
    int v7 = result;
    uint64_t v8 = (16 * result) | 4u;
    uint64_t v9 = (_WORD *)OOCAllocator_Malloc(*(void *)(a1 + 8), v8, &v19);
    uint64_t result = v19;
    if (v19) {
      return result;
    }
    unsigned int v10 = 0;
    *uint64_t v9 = v7;
    v9[1] = v7;
    unint64_t v11 = v9 + 2;
    uint64_t v12 = v9;
    do
    {
      uint64_t v13 = PtrList_ItemN(*(void *)(a1 + 16), v10);
      *unint64_t v11 = *(_DWORD *)v13;
      unsigned int v14 = *(_DWORD **)(v13 + 16);
      if (!v14) {
        unsigned int v14 = (_DWORD *)(v13 + 8);
      }
      *((_DWORD *)v12 + 2) = *v14;
      v12 += 4;
      ++v10;
      unint64_t v11 = v12 + 2;
    }
    while (v10 != v7);
    unsigned int v15 = 0;
    uint64_t v16 = 2;
    do
    {
      int v17 = &v12[v16];
      char v18 = (_DWORD *)PtrList_ItemN(*(void *)(a1 + 16), v15);
      *int v17 = *v18;
      v17[1] = v18[1];
      ++v15;
      v16 += 4;
    }
    while (v7 != v15);
    uint64_t result = v19;
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  *a2 = v9;
  *a3 = v8;
  return result;
}

uint64_t ParamDB_FetchComputableParams(uint64_t a1, uint64_t *a2, void *a3)
{
  unsigned int v14 = 0;
  if (PtrList_NrItems(*(void *)(a1 + 16)) && PtrList_NrItems(*(void *)(a1 + 16)))
  {
    unsigned int v6 = 0;
    unsigned int v7 = 0;
    do
    {
      uint64_t v8 = PtrList_ItemN(*(void *)(a1 + 16), v6);
      if (*(void *)(v8 + 40) && *(_DWORD *)(v8 + 32)) {
        ++v7;
      }
      ++v6;
    }
    while (v6 < PtrList_NrItems(*(void *)(a1 + 16)));
    if (v7)
    {
      uint64_t v9 = OOCAllocator_Malloc(*(void *)(a1 + 8), 4 * v7, &v14);
      uint64_t result = v14;
      if (v14) {
        return result;
      }
      if (PtrList_NrItems(*(void *)(a1 + 16)))
      {
        unsigned int v11 = 0;
        unsigned int v12 = 0;
        do
        {
          uint64_t v13 = PtrList_ItemN(*(void *)(a1 + 16), v11);
          if (*(void *)(v13 + 40))
          {
            if (*(_DWORD *)(v13 + 32)) {
              *(_DWORD *)(v9 + 4 * v12++) = *(_DWORD *)v13;
            }
          }
          ++v11;
        }
        while (v11 < PtrList_NrItems(*(void *)(a1 + 16)));
      }
    }
    else
    {
      uint64_t v9 = 0;
    }
  }
  else
  {
    uint64_t v9 = 0;
    unsigned int v7 = 0;
  }
  *a2 = v9;
  *a3 = v7;
  return v14;
}

uint64_t ParamDB_FetchPublicParams(uint64_t a1, uint64_t *a2, void *a3)
{
  unsigned int v13 = 0;
  if (!PtrList_NrItems(*(void *)(a1 + 16)) || !PtrList_NrItems(*(void *)(a1 + 16)))
  {
    unsigned int v7 = 0;
LABEL_16:
    uint64_t v8 = 0;
    goto LABEL_17;
  }
  unsigned int v6 = 0;
  unsigned int v7 = 0;
  do
  {
    if (*(_DWORD *)(PtrList_ItemN(*(void *)(a1 + 16), v6) + 32)) {
      ++v7;
    }
    ++v6;
  }
  while (v6 < PtrList_NrItems(*(void *)(a1 + 16)));
  if (!v7) {
    goto LABEL_16;
  }
  uint64_t v8 = OOCAllocator_Malloc(*(void *)(a1 + 8), 8 * v7, &v13);
  uint64_t result = v13;
  if (v13) {
    return result;
  }
  if (PtrList_NrItems(*(void *)(a1 + 16)))
  {
    unsigned int v10 = 0;
    unsigned int v11 = 0;
    do
    {
      unsigned int v12 = (unsigned int *)PtrList_ItemN(*(void *)(a1 + 16), v10);
      if (v12[8]) {
        *(void *)(v8 + 8 * v11++) = *v12;
      }
      ++v10;
    }
    while (v10 < PtrList_NrItems(*(void *)(a1 + 16)));
  }
LABEL_17:
  *a2 = v8;
  *a3 = v7;
  return v13;
}

uint64_t ParamDB_GetFactoryParam(uint64_t a1, int a2)
{
  int v3 = a2;
  return *(unsigned int *)(PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v3, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem)+ 4);
}

BOOL CompareItem(_DWORD **a1, _DWORD **a2)
{
  return **a1 != **a2;
}

uint64_t ParamDB_GetParam(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v5, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
  int v3 = *(unsigned int **)(v2 + 16);
  if (!v3) {
    int v3 = (unsigned int *)(v2 + 8);
  }
  return *v3;
}

BOOL ParamDB_HasParam(uint64_t a1, int a2)
{
  int v3 = a2;
  return PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v3, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem) != 0;
}

BOOL ParamDB_IsComputedParam(uint64_t a1, int a2)
{
  int v3 = a2;
  return *(void *)(PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v3, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem)+ 40) != 0;
}

uint64_t ParamDB_IsParamValueValid(uint64_t a1, int a2, uint64_t a3)
{
  int v7 = a2;
  uint64_t v4 = PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v7, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
  int v5 = *(uint64_t (**)(uint64_t))(v4 + 24);
  if (v5) {
    return v5(a3);
  }
  else {
    return *(_DWORD *)(v4 + 8) == a3;
  }
}

uint64_t ParamDB_LoadAllParamsFromBinaryBuffer(uint64_t a1, unsigned __int16 *a2)
{
  return __ParamDB_LoadParams(a1, a2, 1);
}

uint64_t __ParamDB_LoadParams(uint64_t a1, unsigned __int16 *a2, int a3)
{
  int v26 = 0;
  uint64_t v5 = *a2;
  unsigned int v6 = a2[1];
  int v7 = a2 + 2;
  if (a2[1])
  {
    unsigned int v8 = 0;
    uint64_t v9 = &v7[4 * v5];
    do
    {
      uint64_t v10 = *((unsigned int *)v9 + 1);
      int v26 = *(_DWORD *)v9;
      uint64_t v11 = PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v26, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
      if (v11)
      {
        uint64_t v12 = v11;
        unsigned int v13 = *(unsigned int (**)(uint64_t))(v11 + 24);
        if (v13 && !v13(v10)) {
          return err_GenerateErrorData();
        }
        unsigned int v14 = *(_DWORD **)(v12 + 16);
        if (v14) {
          *unsigned int v14 = v10;
        }
        else {
          *(_DWORD *)(v12 + 8) = v10;
        }
        int v27 = v26;
        uint64_t v16 = PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v27, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
        *(_DWORD *)(v16 + 4) = v10;
        *(_DWORD *)(v16 + 36) = 1;
      }
      else if (a3)
      {
        uint64_t result = __ParamDB_AddParam(a1, v26, v10, (uint64_t)ParameterCheck_NoCheck, 0, 0, 0);
        if (result) {
          return result;
        }
      }
      ++v8;
      v9 += 4;
    }
    while (v8 < v6);
  }
  if (v5)
  {
    for (unsigned int i = 0; i < v5; ++i)
    {
      uint64_t v18 = *((unsigned int *)v7 + 1);
      int v26 = *(_DWORD *)v7;
      uint64_t v19 = PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v26, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
      if (v19)
      {
        uint64_t v20 = v19;
        unint64_t v21 = *(unsigned int (**)(uint64_t))(v19 + 24);
        if (v21 && !v21(v18)) {
          return err_GenerateErrorData();
        }
        int v22 = *(_DWORD **)(v20 + 16);
        if (v22) {
          *int v22 = v18;
        }
        else {
          *(_DWORD *)(v20 + 8) = v18;
        }
      }
      else if (a3)
      {
        uint64_t result = __ParamDB_AddParam(a1, v26, v18, (uint64_t)ParameterCheck_NoCheck, 0, 0, 0);
        if (result) {
          return result;
        }
      }
      v7 += 4;
    }
  }
  if (!v6)
  {
    uint64_t result = PtrList_NrItems(*(void *)(a1 + 16));
    if (!result) {
      return result;
    }
    unsigned int v23 = 0;
    int v24 = 0;
    do
    {
      unsigned int v25 = (_DWORD *)PtrList_ItemN(*(void *)(a1 + 16), v23);
      if (!v25[8]) {
        v25[1] = v25[2];
      }
      unsigned int v23 = (unsigned __int16)++v24;
    }
    while (PtrList_NrItems(*(void *)(a1 + 16)) > (unsigned __int16)v24);
  }
  return 0;
}

uint64_t ParamDB_LoadBinaryBuffer(uint64_t a1, unsigned __int16 *a2)
{
  return __ParamDB_LoadParams(a1, a2, 0);
}

uint64_t ParamDB_RemoveParam(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v3 = PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v5, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
  PtrList_Remove(*(void *)(a1 + 16), v3);
  return OOCAllocator_Free(*(void *)(a1 + 8), v3);
}

uint64_t ParamDB_ResetAllParamsToFactorySetting(uint64_t a1)
{
  uint64_t result = PtrList_NrItems(*(void *)(a1 + 16));
  if (result)
  {
    unsigned int v3 = 0;
    do
    {
      uint64_t v4 = PtrList_ItemN(*(void *)(a1 + 16), v3);
      int v5 = *(_DWORD *)(v4 + 4);
      unsigned int v6 = *(_DWORD **)(v4 + 16);
      if (v6) {
        _DWORD *v6 = v5;
      }
      else {
        *(_DWORD *)(v4 + 8) = v5;
      }
      ++v3;
      uint64_t result = PtrList_NrItems(*(void *)(a1 + 16));
    }
    while (v3 < result);
  }
  return result;
}

uint64_t ParamDB_ResetParamToFactorySetting(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t result = PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v5, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
  int v3 = *(_DWORD *)(result + 4);
  uint64_t v4 = *(_DWORD **)(result + 16);
  if (v4) {
    *uint64_t v4 = v3;
  }
  else {
    *(_DWORD *)(result + 8) = v3;
  }
  return result;
}

uint64_t ParamDB_ReturnAllParams(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t ParamDB_ReturnBinaryBuffer(uint64_t a1, uint64_t a2)
{
  return OOCAllocator_Free(*(void *)(a1 + 8), a2);
}

uint64_t ParamDB_ReturnComputableParams(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t ParamDB_ReturnPublicParams(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t ParamDB_SetFactoryParam(uint64_t a1, int a2, int a3)
{
  int v5 = a2;
  uint64_t result = PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v5, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
  *(_DWORD *)(result + 4) = a3;
  *(_DWORD *)(result + 36) = 1;
  return result;
}

uint64_t ParamDB_SetParam(uint64_t a1, int a2, int a3)
{
  int v6 = a2;
  uint64_t result = PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v6, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
  int v5 = *(_DWORD **)(result + 16);
  if (v5) {
    _DWORD *v5 = a3;
  }
  else {
    *(_DWORD *)(result + 8) = a3;
  }
  return result;
}

uint64_t ParamDB_UpdateAllComputedParams(uint64_t a1)
{
  uint64_t result = PtrList_NrItems(*(void *)(a1 + 16));
  if (result)
  {
    unsigned int v3 = 0;
    do
    {
      uint64_t v4 = (unsigned int *)PtrList_ItemN(*(void *)(a1 + 16), v3);
      uint64_t v5 = *((void *)v4 + 5);
      if (v5)
      {
        int v6 = v4;
        uint64_t v8 = 0;
        uint64_t result = (**(uint64_t (***)(uint64_t, void, uint64_t *))v5)(v5 - *(void *)(*(void *)v5 + 8), *v4, &v8);
        if (result) {
          return result;
        }
        int v7 = (_DWORD *)*((void *)v6 + 2);
        if (v7) {
          _DWORD *v7 = v8;
        }
        else {
          v6[2] = v8;
        }
      }
      ++v3;
    }
    while (v3 < PtrList_NrItems(*(void *)(a1 + 16)));
    return 0;
  }
  return result;
}

uint64_t ParamDB_UpdateComputedParam(uint64_t a1, int a2)
{
  int v6 = a2;
  uint64_t v5 = 0;
  uint64_t v2 = (unsigned int *)PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v6, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
  uint64_t result = (***((uint64_t (****)(void, void, uint64_t *))v2 + 5))(*((void *)v2 + 5) - *(void *)(**((void **)v2 + 5) + 8), *v2, &v5);
  if (!result)
  {
    uint64_t v4 = (_DWORD *)*((void *)v2 + 2);
    if (v4) {
      *uint64_t v4 = v5;
    }
    else {
      v2[2] = v5;
    }
  }
  return result;
}

uint64_t PNEW_ParamDB_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  int v6 = (void *)OOCAllocator_Malloc(a1, 24, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = ParamDB_Con(v6, a2);
    unsigned int v8 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *a3 = v6;
    }
  }
  return result;
}

void *GetParamDBClass()
{
  return &__ParamDB;
}

BOOL ParameterCheck_Boolean(unsigned int a1)
{
  return a1 < 2;
}

BOOL ParameterCheck_NonNegative(int a1)
{
  return a1 >= 0;
}

BOOL ParameterCheck_Positive(int a1)
{
  return a1 > 0;
}

BOOL ParameterCheck_NonNegativeShort(unsigned int a1)
{
  return a1 < 0x10000;
}

BOOL ParameterCheck_PositiveShort(int a1)
{
  return (a1 - 1) < 0xFFFF;
}

uint64_t ParameterCheck_NoCheck()
{
  return 1;
}

uint64_t NullLogger_Con(void *a1)
{
  uint64_t result = RefCounted_Con((uint64_t)a1, 1);
  if (!result)
  {
    *a1 = &__NullLogger;
    a1[3] = &unk_26D218260;
  }
  return result;
}

uint64_t NullLogger_GetTimerMs(uint64_t a1, void *a2)
{
  *a2 = 0;
  return 0;
}

uint64_t NullLogger_IsEnabled()
{
  return 0;
}

uint64_t NullLogger_LogBinaryData()
{
  return 0;
}

uint64_t NullLogger_LogTextArg0()
{
  return 0;
}

uint64_t NullLogger_LogTextArg1()
{
  return 0;
}

uint64_t NullLogger_LogTextArg2()
{
  return 0;
}

uint64_t NullLogger_LogTextArg3()
{
  return 0;
}

uint64_t NullLogger_LogTextArg4()
{
  return 0;
}

uint64_t NullLogger_LogTextArgVar()
{
  return 0;
}

uint64_t PNEW_NullLogger_Con(uint64_t a1, void *a2)
{
  unsigned int v6 = 0;
  uint64_t v4 = (void *)OOCAllocator_Malloc(a1, 32, &v6);
  uint64_t result = v6;
  if (!v6)
  {
    uint64_t result = RefCounted_Con((uint64_t)v4, 1);
    if (result)
    {
      unsigned int v6 = result;
      OOCAllocator_Free(a1, (uint64_t)v4);
      *a2 = 0;
      return v6;
    }
    else
    {
      *uint64_t v4 = &__NullLogger;
      _OWORD v4[2] = a1;
      v4[3] = &unk_26D218260;
      *a2 = v4;
    }
  }
  return result;
}

void *GetNullLoggerClass()
{
  return &__NullLogger;
}

uint64_t Logger_Con(void *a1, uint64_t a2, const char *a3, uint64_t a4)
{
  uint64_t result = RefCounted_Con((uint64_t)a1, 1);
  unsigned int v11 = result;
  if (!result)
  {
    *a1 = &__Logger;
    a1[3] = &unk_26D2182F0;
    a1[6] = a2;
    size_t v9 = cstdlib_strlen(a3);
    uint64_t v10 = (char *)OOCAllocator_Malloc(a2, v9 + 1, &v11);
    a1[5] = v10;
    uint64_t result = v11;
    if (!v11)
    {
      cstdlib_strcpy(v10, a3);
      a1[4] = a4;
      return v11;
    }
  }
  return result;
}

uint64_t Logger_Des(uint64_t a1)
{
  OOCAllocator_Free(*(void *)(a1 + 48), *(void *)(a1 + 40));

  return RefCounted_Des(a1);
}

uint64_t Logger_BorrowName(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t Logger_GetTimerMs(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32) - *(void *)(**(void **)(a1 + 32) + 48));
}

uint64_t Logger_IsEnabled(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32) - *(void *)(**(void **)(a1 + 32) + 48));
}

uint64_t Logger_LogBinaryData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32) - *(void *)(**(void **)(a1 + 32) + 48));
  if (result)
  {
    uint64_t v10 = *(void *)(a1 + 32);
    uint64_t v9 = *(void *)(a1 + 40);
    unsigned int v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v10 + 8);
    uint64_t v12 = v10 - *(void *)(*(void *)v10 + 48);
    return v11(v12, v9, a2, a3, a4);
  }
  return result;
}

uint64_t Logger_LogTextArg0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32) - *(void *)(**(void **)(a1 + 32) + 48));
  if (result)
  {
    unsigned int v8 = *(char **)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v9 = **(uint64_t (***)(int64_t, uint64_t, uint64_t, uint64_t, void, void))v8;
    int64_t v10 = (int64_t)&v8[-*(void *)(*(void *)v8 + 48)];
    return v9(v10, v7, a2, a3, 0, 0);
  }
  return result;
}

uint64_t Logger_LogTextArg1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[1] = *MEMORY[0x263EF8340];
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32) - *(void *)(**(void **)(a1 + 32) + 48));
  if (result)
  {
    v9[0] = a4;
    return (***(uint64_t (****)(void, void, uint64_t, uint64_t, void *, uint64_t))(a1 + 32))(*(void *)(a1 + 32) - *(void *)(**(void **)(a1 + 32) + 48), *(void *)(a1 + 40), a2, a3, v9, 1);
  }
  return result;
}

uint64_t Logger_LogTextArg2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v11[2] = *MEMORY[0x263EF8340];
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32) - *(void *)(**(void **)(a1 + 32) + 48));
  if (result)
  {
    v11[0] = a4;
    v11[1] = a5;
    return (***(uint64_t (****)(void, void, uint64_t, uint64_t, void *, uint64_t))(a1 + 32))(*(void *)(a1 + 32) - *(void *)(**(void **)(a1 + 32) + 48), *(void *)(a1 + 40), a2, a3, v11, 2);
  }
  return result;
}

uint64_t Logger_LogTextArg3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void v13[3] = *MEMORY[0x263EF8340];
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32) - *(void *)(**(void **)(a1 + 32) + 48));
  if (result)
  {
    v13[0] = a4;
    v13[1] = a5;
    v13[2] = a6;
    return (***(uint64_t (****)(void, void, uint64_t, uint64_t, void *, uint64_t))(a1 + 32))(*(void *)(a1 + 32) - *(void *)(**(void **)(a1 + 32) + 48), *(void *)(a1 + 40), a2, a3, v13, 3);
  }
  return result;
}

uint64_t Logger_LogTextArg4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v15[4] = *MEMORY[0x263EF8340];
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32) - *(void *)(**(void **)(a1 + 32) + 48));
  if (result)
  {
    v15[0] = a4;
    v15[1] = a5;
    v15[2] = a6;
    _DWORD v15[3] = a7;
    return (***(uint64_t (****)(void, void, uint64_t, uint64_t, void *, uint64_t))(a1 + 32))(*(void *)(a1 + 32) - *(void *)(**(void **)(a1 + 32) + 48), *(void *)(a1 + 40), a2, a3, v15, 4);
  }
  return result;
}

uint64_t Logger_LogTextArgVar(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32) - *(void *)(**(void **)(a1 + 32) + 48));
  if (result)
  {
    uint64_t v12 = *(char **)(a1 + 32);
    uint64_t v11 = *(void *)(a1 + 40);
    unsigned int v13 = **(uint64_t (***)(int64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v12;
    int64_t v14 = (int64_t)&v12[-*(void *)(*(void *)v12 + 48)];
    return v13(v14, v11, a2, a3, a4, a5);
  }
  return result;
}

uint64_t PNEW_Logger_Con(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, void *a5)
{
  unsigned int v12 = 0;
  int64_t v10 = (void *)OOCAllocator_Malloc(a1, 56, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = Logger_Con(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      v10[2] = a1;
      *a5 = v10;
    }
  }
  return result;
}

void *GetLoggerClass()
{
  return &__Logger;
}

uint64_t NullLog_Con(void *a1)
{
  uint64_t result = VoConObject_Con(a1);
  if (!result)
  {
    *a1 = &__NullLog;
    a1[7] = &unk_26D2183C8;
    a1[3] = &unk_26D218380;
  }
  return result;
}

uint64_t NullLog_CastToIVoConObject(uint64_t a1)
{
  return a1 + 24;
}

uint64_t NullLog_DisableAllEvents()
{
  return 0;
}

uint64_t NullLog_DisableEvents()
{
  return 0;
}

uint64_t NullLog_EnableAllEvents()
{
  return 0;
}

uint64_t NullLog_EnableEvents()
{
  return 0;
}

uint64_t NullLog_GetTimerMs(uint64_t a1, void *a2)
{
  *a2 = 0;
  return 0;
}

uint64_t NullLog_IsEventEnabled()
{
  return 1;
}

uint64_t NullLog_LogBinaryData()
{
  return 0;
}

uint64_t NullLog_LogString()
{
  return 0;
}

uint64_t NullLog_LogTextVarArgs()
{
  return 0;
}

uint64_t NullLog_QueryInterface(uint64_t a1, uint64_t a2, void *a3)
{
  if (a2 != 1012437602) {
    return VoConObject_QueryInterface(a1, a2, a3);
  }
  *a3 = a1 + 56;
  return 0;
}

uint64_t PNEW_NullLog_Con(uint64_t a1, void *a2)
{
  unsigned int v6 = 0;
  uint64_t v4 = (void *)OOCAllocator_Malloc(a1, 64, &v6);
  uint64_t result = v6;
  if (!v6)
  {
    uint64_t result = VoConObject_Con(v4);
    if (result)
    {
      unsigned int v6 = result;
      OOCAllocator_Free(a1, (uint64_t)v4);
      *a2 = 0;
      return v6;
    }
    else
    {
      *uint64_t v4 = &__NullLog;
      v4[7] = &unk_26D2183C8;
      _OWORD v4[2] = a1;
      v4[3] = &unk_26D218380;
      *a2 = v4;
    }
  }
  return result;
}

void *GetNullLogClass()
{
  return &__NullLog;
}

uint64_t StreamLogger_Con(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7)
{
  uint64_t result = _EventLogger_Con((uint64_t)a1, a2, a3, a4, a5, a6, a7);
  if (!result)
  {
    *a1 = &__StreamLogger;
    a1[3] = &unk_26D218450;
    a1[7] = &unk_26D218498;
    a1[21] = a2;
  }
  return result;
}

uint64_t StreamLogger_LogBinaryData(void *a1, const char *a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  int64_t v10 = (uint64_t (**)(void, void, void, void))a1[19];
  uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t))(a1[7] + 24))((uint64_t)a1 - *(void *)(a1[7] + 80) + 56, a3);
  if (result)
  {
    uint64_t result = __StreamLogger_WritePrefix((uint64_t)a1, a2, a3);
    if (!result)
    {
      unsigned int v12 = &v15[(int)spr_pcat_noerr(v15, (uint64_t)&v16, "s", "(")];
      unsigned int v13 = &v12[(int)spr_ulcat_noerr(v12, (uint64_t)&v16, "d", a5)];
      int64_t v14 = &v13[(int)spr_pcat_noerr(v13, (uint64_t)&v16, "s", ")")] - v15;
      if ((*v10)(v15, 1, v14, a1[20]) == v14
        && (!a4 || (*v10)(a4, 1, a5, a1[20]) == a5)
        && (*v10)(&g_szEOL, 1, 1, a1[20]) == 1)
      {
        return 0;
      }
      else
      {
        return err_GenerateErrorCallback();
      }
    }
  }
  return result;
}

uint64_t __StreamLogger_WritePrefix(uint64_t a1, const char *a2, unint64_t a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  unsigned int v6 = *(uint64_t (***)(char *, uint64_t, int64_t, void))(a1 + 152);
  unint64_t TickCount = _EventLogger_GetTickCount(a1);
  unsigned int v8 = &v15[(int)spr_ulcat_noerr(v15, (uint64_t)&v16, "15d", TickCount)];
  uint64_t v9 = &v8[(int)spr_pcat_noerr(v8, (uint64_t)&v16, "s", " ")];
  int64_t v10 = &v9[(int)spr_ulcat_noerr(v9, (uint64_t)&v16, "8x", a3)];
  uint64_t v11 = &v10[(int)spr_pcat_noerr(v10, (uint64_t)&v16, "s", " ")];
  unsigned int v12 = &v11[(int)spr_pcat_noerr(v11, (uint64_t)&v16, "20s", a2)];
  int64_t v13 = &v12[(int)spr_pcat_noerr(v12, (uint64_t)&v16, "s", " ")] - v15;
  if ((*v6)(v15, 1, v13, *(void *)(a1 + 160)) == v13) {
    return 0;
  }
  else {
    return err_GenerateErrorCallback();
  }
}

uint64_t StreamLogger_LogTextVarArgs(void *a1, const char *a2, unint64_t a3, char *a4, uint64_t a5, unint64_t a6)
{
  *(void *)&v35[1] = *MEMORY[0x263EF8340];
  unsigned int v33 = 0;
  unsigned int v12 = (uint64_t (**)(void *, uint64_t, uint64_t, void))a1[19];
  uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t))(a1[7] + 24))((uint64_t)a1 - *(void *)(a1[7] + 80) + 56, a3);
  if (result)
  {
    size_t v14 = cstdlib_strlen(a4);
    int v32 = v12;
    if (!v14) {
      goto LABEL_15;
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      if (a4[v15] == 10) {
        ++v16;
      }
      ++v15;
    }
    while (v14 != v15);
    if (v16)
    {
      uint64_t v17 = OOCAllocator_Calloc(a1[21], 1, v14 + v16 + 1, &v33);
      uint64_t result = v33;
      if (!v33)
      {
        for (uint64_t i = 0; ; ++i)
        {
          int v19 = *a4;
          if (v19 == 10)
          {
            *(unsigned char *)(v17 + i++) = 92;
            LOBYTE(v19) = 110;
          }
          else if (!*a4)
          {
            a4 = (char *)v17;
            goto LABEL_16;
          }
          *(unsigned char *)(v17 + i) = v19;
          ++a4;
        }
      }
    }
    else
    {
LABEL_15:
      uint64_t v17 = 0;
LABEL_16:
      if (*a4)
      {
        uint64_t v29 = a5;
        unint64_t v30 = a6;
        unsigned int v31 = 0;
        uint64_t v20 = __s;
        while (1)
        {
          unint64_t v21 = cstdlib_strchr(a4, 37);
          if (!v21) {
            unint64_t v21 = &a4[cstdlib_strlen(a4)];
          }
          int v22 = (unsigned char *)(v21 - a4 >= v35 - v20 ? v35 - v20 : v21 - a4);
          cstdlib_strncpy(v20, a4, v22);
          uint64_t v20 = &v22[(void)v20];
          if (!*v21) {
            break;
          }
          if (v21[1] == 37)
          {
            v20 += (int)spr_pcat_noerr(v20, (uint64_t)v35, "s", "%");
            a4 = v21 + 2;
            if (!v21[2]) {
              break;
            }
          }
          else
          {
            unsigned int v23 = spr_parse_formatspecifier(v21 + 1);
            if (v23 == v21 + 1 || v31 >= v30)
            {
              v20 += (int)spr_pcat_noerr(v20, (uint64_t)v35, "s", v21);
              break;
            }
            a4 = v23;
            int v24 = *(const char **)(v29 + 8 * v31);
            if (v24) {
              int v25 = spr_cat_noerr(v20, (uint64_t)v35, v21 + 1, v23, v24);
            }
            else {
              int v25 = spr_pcat_noerr(v20, (uint64_t)v35, "s", "(NULL)");
            }
            v20 += v25;
            ++v31;
            if (!*a4) {
              break;
            }
          }
        }
      }
      else
      {
        uint64_t v20 = __s;
      }
      char *v20 = 0;
      OOCAllocator_Free(a1[21], v17);
      uint64_t result = __StreamLogger_WritePrefix((uint64_t)a1, a2, a3);
      unsigned int v33 = result;
      if (!result)
      {
        int v26 = (uint64_t (*)(char *, uint64_t, size_t, void))*v32;
        size_t v27 = cstdlib_strlen(__s);
        uint64_t v28 = v26(__s, 1, v27, a1[20]);
        if (v28 == cstdlib_strlen(__s) && (*v32)(&g_szEOL, 1, 1, a1[20]) == 1) {
          return v33;
        }
        else {
          return err_GenerateErrorCallback();
        }
      }
    }
  }
  return result;
}

uint64_t StreamLogger_QueryInterface(uint64_t a1, uint64_t a2, void *a3)
{
  if (a2 != 1012437602) {
    return VoConObject_QueryInterface(a1, a2, a3);
  }
  *a3 = a1 + 56;
  return 0;
}

uint64_t PNEW_StreamLogger_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7, void *a8)
{
  unsigned int v18 = 0;
  uint64_t v16 = (void *)OOCAllocator_Malloc(a1, 176, &v18);
  uint64_t result = v18;
  if (!v18)
  {
    uint64_t result = _EventLogger_Con((uint64_t)v16, a2, a3, a4, a5, a6, a7);
    if (result)
    {
      unsigned int v18 = result;
      OOCAllocator_Free(a1, (uint64_t)v16);
      *a8 = 0;
      return v18;
    }
    else
    {
      void *v16 = &__StreamLogger;
      v16[7] = &unk_26D218498;
      v16[21] = a2;
      _OWORD v16[2] = a1;
      void v16[3] = &unk_26D218450;
      *a8 = v16;
    }
  }
  return result;
}

void *GetStreamLoggerClass()
{
  return &__StreamLogger;
}

uint64_t LogDispatcher_Con(void *a1, uint64_t a2)
{
  uint64_t result = RefCounted_Con((uint64_t)a1, 1);
  if (!result)
  {
    *a1 = &__LogDispatcher;
    a1[3] = &unk_26D218520;
    a1[4] = &unk_26D218558;
    a1[6] = a2;
    return PNEW_PtrList_Con(a2, a2, 2u, 2, a1 + 5);
  }
  return result;
}

uint64_t LogDispatcher_Des(uint64_t a1)
{
  uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 48), *(void *)(a1 + 40));
  if (!result)
  {
    return RefCounted_Des(a1);
  }
  return result;
}

uint64_t LogDispatcher_Add(uint64_t a1, uint64_t a2)
{
  return PtrList_Append(*(void *)(a1 + 40), a2);
}

uint64_t LogDispatcher_GetTimerMs(uint64_t a1, void *a2)
{
  *a2 = 0;
  uint64_t result = PtrList_NrItems(*(void *)(a1 + 40));
  if (result)
  {
    unsigned int v5 = 0;
    while (1)
    {
      uint64_t v6 = PtrList_ItemN(*(void *)(a1 + 40), v5);
      if ((*(unsigned int (**)(uint64_t, void *))(*(void *)v6 + 72))(v6 - *(void *)(*(void *)v6 + 80), a2))
      {
        break;
      }
      if (++v5 >= PtrList_NrItems(*(void *)(a1 + 40))) {
        return 0;
      }
    }
    return 1;
  }
  return result;
}

uint64_t LogDispatcher_IsEventEnabled(uint64_t a1, uint64_t a2)
{
  uint64_t result = PtrList_NrItems(*(void *)(a1 + 40));
  if (result)
  {
    unsigned int v5 = 0;
    while (1)
    {
      uint64_t v6 = PtrList_ItemN(*(void *)(a1 + 40), v5);
      if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v6 + 24))(v6 - *(void *)(*(void *)v6 + 80), a2))
      {
        break;
      }
      if (++v5 >= PtrList_NrItems(*(void *)(a1 + 40))) {
        return 0;
      }
    }
    return 1;
  }
  return result;
}

uint64_t LogDispatcher_LogBinaryData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = PtrList_NrItems(*(void *)(a1 + 40));
  if (result)
  {
    unsigned int v11 = 0;
    while (1)
    {
      uint64_t v12 = PtrList_ItemN(*(void *)(a1 + 40), v11);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v12 + 16))(v12 - *(void *)(*(void *)v12 + 80), a2, a3, a4, a5);
      if (result) {
        break;
      }
      if (++v11 >= PtrList_NrItems(*(void *)(a1 + 40))) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t LogDispatcher_LogTextVarArgs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t result = PtrList_NrItems(*(void *)(a1 + 40));
  if (result)
  {
    unsigned int v13 = 0;
    while (1)
    {
      uint64_t v14 = PtrList_ItemN(*(void *)(a1 + 40), v13);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v14 + 8))(v14 - *(void *)(*(void *)v14 + 80), a2, a3, a4, a5, a6);
      if (result) {
        break;
      }
      if (++v13 >= PtrList_NrItems(*(void *)(a1 + 40))) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t LogDispatcher_Remove(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t PNEW_LogDispatcher_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = (void *)OOCAllocator_Malloc(a1, 56, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = LogDispatcher_Con(v6, a2);
    unsigned int v8 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      v6[2] = a1;
      *a3 = v6;
    }
  }
  return result;
}

void *GetLogDispatcherClass()
{
  return &__LogDispatcher;
}

uint64_t _EventLogger_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7)
{
  uint64_t result = VoConObject_Con2((void *)a1, a2);
  unsigned int v16 = result;
  if (!result)
  {
    *(void *)(a1 + 56) = &unk_26D2185F8;
    *(void *)a1 = &__EventLogger;
    *(void *)(a1 + 64) = a2;
    *(void *)(a1 + 104) = a4;
    *(void *)(a1 + 112) = a5;
    *(_OWORD *)(a1 + 72) = 0u;
    *(_OWORD *)(a1 + 88) = 0u;
    *(void *)(a1 + 120) = 1;
    *(void *)(a1 + 136) = 0;
    *(void *)(a1 + 144) = 0;
    uint64_t v15 = (void *)OOCAllocator_Malloc(a2, 32, &v16);
    *(void *)(a1 + 152) = v15;
    uint64_t result = v16;
    if (!v16)
    {
      cstdlib_memcpy(v15, a6, 0x20uLL);
      *(void *)(a1 + 160) = a7;
      *(void *)(a1 + 128) = a3;
      return (**(uint64_t (***)(uint64_t, uint64_t))a3)(a3 - *(void *)(*(void *)a3 + 32), a1 + 56);
    }
  }
  return result;
}

uint64_t _EventLogger_ResetOverflowCount(uint64_t result)
{
  *(void *)(result + 136) = 0;
  *(void *)(result + 144) = 0;
  return result;
}

uint64_t EventLogger_Des(uint64_t a1)
{
  __EventLogger_ResetEvents((uint64_t *)a1);
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 128) + 8))(*(void *)(a1 + 128) - *(void *)(**(void **)(a1 + 128) + 32), a1 + 56);
  if (result) {
    return result;
  }
  uint64_t v3 = *(void *)(a1 + 152);
  if (v3)
  {
    if ((*(unsigned int (**)(void, void))(v3 + 24))(*(void *)(a1 + 160), 0))
    {
      return err_GenerateErrorCallback();
    }
    OOCAllocator_Free(*(void *)(a1 + 64), *(void *)(a1 + 152));
  }

  return VoConObject_Des(a1);
}

uint64_t __EventLogger_ResetEvents(uint64_t *a1)
{
  OOCAllocator_Free(a1[8], a1[9]);
  a1[9] = 0;
  a1[10] = 0;
  uint64_t result = OOCAllocator_Free(a1[8], a1[11]);
  a1[15] = 0;
  a1[11] = 0;
  a1[12] = 0;
  return result;
}

uint64_t EventLogger_CastToIVoConObject(uint64_t a1)
{
  return a1 + 24;
}

uint64_t EventLogger_DisableAllEvents(uint64_t a1)
{
  *(_DWORD *)(a1 + 124) = 1;
  return 0;
}

uint64_t EventLogger_DisableEvents(uint64_t *a1, const void *a2, uint64_t a3)
{
  unsigned int v9 = 0;
  __EventLogger_ResetEvents(a1);
  uint64_t v6 = (void *)OOCAllocator_Malloc(a1[8], 8 * a3, &v9);
  a1[11] = (uint64_t)v6;
  uint64_t v7 = v9;
  if (!v9)
  {
    cstdlib_memcpy(v6, a2, 8 * a3);
    a1[12] = a3;
    return v9;
  }
  return v7;
}

uint64_t EventLogger_EnableAllEvents(uint64_t a1)
{
  *(_DWORD *)(a1 + 120) = 1;
  return 0;
}

uint64_t EventLogger_EnableEvents(uint64_t *a1, const void *a2, uint64_t a3)
{
  unsigned int v9 = 0;
  __EventLogger_ResetEvents(a1);
  uint64_t v6 = (void *)OOCAllocator_Malloc(a1[8], 8 * a3, &v9);
  a1[9] = (uint64_t)v6;
  uint64_t v7 = v9;
  if (!v9)
  {
    cstdlib_memcpy(v6, a2, 8 * a3);
    a1[10] = a3;
    return v9;
  }
  return v7;
}

uint64_t EventLogger_GetTimerMs(uint64_t a1, void *a2)
{
  *a2 = 0;
  return 0;
}

uint64_t EventLogger_IsEventEnabled(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 124)) {
    return 0;
  }
  if (!*(_DWORD *)(a1 + 120))
  {
    uint64_t v3 = *(void *)(a1 + 72);
    if (v3)
    {
      unint64_t v4 = *(void *)(a1 + 80);
      if (v4)
      {
        uint64_t v5 = 0;
        unsigned int v6 = 1;
        while (*(void *)(v3 + 8 * v5) != a2)
        {
          uint64_t result = 0;
          uint64_t v5 = v6;
          BOOL v7 = v4 >= v6;
          BOOL v8 = v4 == v6++;
          if (v8 || !v7) {
            return result;
          }
        }
        return 1;
      }
    }
    else
    {
      uint64_t v9 = *(void *)(a1 + 88);
      if (v9)
      {
        unint64_t v10 = *(void *)(a1 + 96);
        if (v10)
        {
          uint64_t v11 = 0;
          unsigned int v12 = 1;
          uint64_t result = 1;
          while (*(void *)(v9 + 8 * v11) != a2)
          {
            uint64_t v11 = v12;
            BOOL v7 = v10 >= v12;
            BOOL v8 = v10 == v12++;
            if (v8 || !v7) {
              return result;
            }
          }
          return 0;
        }
        return 1;
      }
    }
    return 0;
  }
  return 1;
}

uint64_t EventLogger_LogString(uint64_t a1, char *__s)
{
  unint64_t v4 = **(uint64_t (***)(char *, uint64_t, size_t, void))(a1 + 152);
  size_t v5 = cstdlib_strlen(__s);
  uint64_t v6 = v4(__s, 1, v5, *(void *)(a1 + 160));
  if (v6 == cstdlib_strlen(__s)) {
    return 0;
  }

  return err_GenerateErrorCallback();
}

uint64_t _EventLogger_BorrowAllocator(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t _EventLogger_GetOverflowCount(uint64_t a1)
{
  return *(void *)(a1 + 144);
}

unint64_t _EventLogger_GetTickCount(uint64_t a1)
{
  unint64_t result = (*(uint64_t (**)(void))(a1 + 104))(*(void *)(a1 + 112));
  if (result < *(void *)(a1 + 136)) {
    ++*(void *)(a1 + 144);
  }
  *(void *)(a1 + 136) = result;
  return result;
}

void *GetEventLoggerClass()
{
  return &__EventLogger;
}

uint64_t StreamInfo_Con(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = VoConObject_Con2(a1, a2);
  if (!v6)
  {
    *a1 = &__StreamInfo;
    a1[7] = &unk_26D2186C8;
    a1[8] = &unk_26D218780;
    a1[3] = &unk_26D218680;
    a1[9] = &unk_26D2187C8;
    a1[10] = a2;
    BOOL v7 = *(void (**)(uint64_t))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a3 + 144))(a3 - *(void *)(*(void *)a3 + 224))
                                        + 24);
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 144))(a3 - *(void *)(*(void *)a3 + 224));
    v7(v8);
    a1[11] = 0;
    a1[12] = a3;
  }
  return v6;
}

uint64_t StreamInfo_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 88);
  if (!v2) {
    goto LABEL_6;
  }
  if (PtrList_NrItems(v2))
  {
    unsigned int v3 = 0;
    do
    {
      uint64_t v4 = PtrList_ItemN(*(void *)(a1 + 88), v3);
      OOCAllocator_Free(*(void *)(a1 + 80), *(void *)(v4 + 8));
      OOCAllocator_Free(*(void *)(a1 + 80), v4);
      ++v3;
    }
    while (v3 < PtrList_NrItems(*(void *)(a1 + 88)));
  }
  uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 80), *(void *)(a1 + 88));
  if (!result)
  {
LABEL_6:
    uint64_t v6 = *(uint64_t (**)(uint64_t))(*(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 96)
                                                                                          + 144))(*(void *)(a1 + 96)- *(void *)(**(void **)(a1 + 96) + 224))+ 32);
    uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 96) + 144))(*(void *)(a1 + 96) - *(void *)(**(void **)(a1 + 96) + 224));
    uint64_t result = v6(v7);
    if (!result)
    {
      return VoConObject_Des(a1);
    }
  }
  return result;
}

uint64_t StreamInfo_AddUserData(uint64_t *a1, uint64_t a2, const void *a3, size_t a4)
{
  uint64_t v11 = 0;
  uint64_t result = __StreamInfo_BorrowUserDataList(a1, &v11);
  unsigned int v12 = result;
  if (!result)
  {
    uint64_t v9 = (void *)OOCAllocator_Calloc(a1[10], 1, 24, &v12);
    uint64_t result = v12;
    if (!v12)
    {
      *uint64_t v9 = a2;
      unint64_t v10 = (void *)OOCAllocator_Malloc(a1[10], a4, &v12);
      v9[1] = v10;
      uint64_t result = v12;
      if (!v12)
      {
        cstdlib_memcpy(v10, a3, a4);
        void v9[2] = a4;
        return PtrList_Append(v11, (uint64_t)v9);
      }
    }
  }
  return result;
}

uint64_t __StreamInfo_BorrowUserDataList(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a1 + 11;
  uint64_t v3 = a1[11];
  if (v3) {
    goto LABEL_2;
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1[12] + 192))(a1[12] - *(void *)(*(void *)a1[12]
                                                                                                + 224)))
  {
    uint64_t v7 = a1[12];
    unsigned int v13 = 0;
  }
  else
  {
    uint64_t result = err_GenerateErrorData();
    unsigned int v13 = result;
    if (result) {
      return result;
    }
    uint64_t v7 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v7 + 32))(v7 - *(void *)(*(void *)v7 + 224), 1186660419))
  {
    uint64_t v12 = 0;
    uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))v7)(v7 - *(void *)(*(void *)v7 + 224), 1186660419, 0, &v12);
    if (!result)
    {
      unsigned int v8 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 96))(v12 - *(void *)(*(void *)v12 + 224));
      uint64_t result = PNEW_PtrList_Con(a1[10], a1[10], v8, 10, v4);
      unsigned int v13 = result;
      if (!result)
      {
        if (v8)
        {
          uint64_t v9 = 0;
          while (1)
          {
            int v11 = 0;
            unint64_t v10 = (void *)OOCAllocator_Calloc(a1[10], 1, 24, &v13);
            uint64_t result = v13;
            if (v13) {
              break;
            }
            *unint64_t v10 = (*(unsigned int (**)(uint64_t, uint64_t, int *))(*(void *)v12 + 104))(v12 - *(void *)(*(void *)v12 + 224), v9, &v11);
            uint64_t result = PtrList_Append(*v4, (uint64_t)v10);
            unsigned int v13 = result;
            if (result) {
              return result;
            }
            uint64_t v9 = (v9 + 1);
            if (v8 == v9) {
              goto LABEL_14;
            }
          }
        }
        else
        {
LABEL_14:
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 16))(v7 - *(void *)(*(void *)v7 + 224), v12);
        }
      }
    }
  }
  else
  {
    uint64_t result = PNEW_PtrList_Con(a1[10], a1[10], 0xAu, 10, v4);
  }
  if (!result)
  {
    uint64_t v3 = *v4;
LABEL_2:
    uint64_t result = 0;
    *a2 = v3;
  }
  return result;
}

uint64_t StreamInfo_Archive(uint64_t *a1, void **a2)
{
  uint64_t v38 = 0;
  unsigned __int16 v37 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t *, unsigned __int16 *))(*a1 + 424))(a1, &v37);
  if (result) {
    return result;
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1[12] + 192))(a1[12] - *(void *)(*(void *)a1[12]
                                                                                                + 224)))
  {
    uint64_t v5 = a1[12];
    unsigned int v39 = 0;
  }
  else
  {
    uint64_t result = err_GenerateErrorData();
    unsigned int v39 = result;
    if (result) {
      return result;
    }
    uint64_t v5 = 0;
  }
  uint64_t v6 = a1[11];
  if (v6)
  {
    if (!PtrList_NrItems(v6)) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v5 + 32))(v5 - *(void *)(*(void *)v5 + 224), 1186660419))
  {
LABEL_7:
    ++v37;
  }
LABEL_8:
  if (((unsigned int (*)(char *))(*a2)[10])((char *)a2 - (*a2)[15])
    || (int v25 = (uint64_t (*)(char *, uint64_t, uint64_t, void))**a2,
        int v26 = (char *)a2 - (*a2)[15],
        uint64_t v27 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 56))(v5 - *(void *)(*(void *)v5 + 224)),
        uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 64))(v5 - *(void *)(*(void *)v5 + 224)),
        uint64_t result = v25(v26, v27, v28, v37),
        !result))
  {
    uint64_t result = PNEW_PtrStack_Con(a1[10], a1[10], 10, &v38);
    unsigned int v39 = result;
    if (!result)
    {
      uint64_t v7 = OOCAllocator_Malloc(a1[10], 24, &v39);
      uint64_t result = v39;
      if (!v39)
      {
        *(void *)uint64_t v7 = v5;
        *(void *)(v7 + 8) = a2;
        *(_DWORD *)(v7 + 16) = 0;
        uint64_t result = PtrStack_Put(v38, v7);
        unsigned int v39 = result;
        if (!result)
        {
          uint64_t v8 = v38;
          int v9 = *(_DWORD *)(v38 + 24);
          if (v9)
          {
            while (2)
            {
              unint64_t v10 = *(unsigned int **)(*(void *)(v8 + 32) + 8 * (v9 - 1));
              for (uint64_t i = v10[4];
                    i < (*(unsigned int (**)(void))(**(void **)v10 + 96))(*(void *)v10 - *(void *)(**(void **)v10 + 224));
                    uint64_t i = (i + 1))
              {
                int v35 = 0;
                unsigned int v36 = 0;
                uint64_t v12 = (*(uint64_t (**)(void, uint64_t, unsigned int *))(**(void **)v10 + 104))(*(void *)v10 - *(void *)(**(void **)v10 + 224), i, &v36);
                uint64_t result = (*(uint64_t (**)(void, void, void, int *))(**(void **)v10 + 160))(*(void *)v10 - *(void *)(**(void **)v10 + 224), v12, v36, &v35);
                unsigned int v39 = result;
                if (result) {
                  return result;
                }
                if (v35)
                {
                  uint64_t v33 = 0;
                  uint64_t v34 = 0;
                  unsigned int v32 = 0;
                  uint64_t result = (*(uint64_t (**)(void, uint64_t, void, char **, unsigned int *))(**(void **)v10 + 8))(*(void *)v10 - *(void *)(**(void **)v10 + 224), v12, v36, &v34, &v32);
                  unsigned int v39 = result;
                  if (result) {
                    return result;
                  }
                  uint64_t result = (*(uint64_t (**)(void, uint64_t, void, uint64_t *))(**((void **)v10 + 1) + 32))(*((void *)v10 + 1) - *(void *)(**((void **)v10 + 1) + 120), v12, v32, &v33);
                  unsigned int v39 = result;
                  if (result) {
                    return result;
                  }
                  if ((*(unsigned int (**)(uint64_t *, uint64_t))(*a1 + 400))(a1, v12))
                  {
                    uint64_t v30 = 0;
                    uint64_t v31 = 0;
                    uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t *, uint64_t *))(*a1 + 408))(a1, v12, &v31, &v30);
                    unsigned int v39 = result;
                    if (result) {
                      return result;
                    }
                    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v33 + 8))(v33 - *(void *)(*(void *)v33 + 56), v31, v30);
                    unsigned int v39 = result;
                    if (result) {
                      return result;
                    }
                    unsigned int v39 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*a1 + 416))(a1, v12, v31);
                    if (v39) {
                      return v39;
                    }
                  }
                  else
                  {
                    uint64_t result = __StreamInfo_CopySectionData((uint64_t)v34, v33);
                    unsigned int v39 = result;
                    if (result) {
                      return result;
                    }
                  }
                  uint64_t result = (*(uint64_t (**)(void, char *))(**(void **)v10 + 24))(*(void *)v10 - *(void *)(**(void **)v10 + 224), v34);
                  unsigned int v39 = result;
                  if (result) {
                    return result;
                  }
                  uint64_t result = (*(uint64_t (**)(void, uint64_t))(**((void **)v10 + 1) + 48))(*((void *)v10 + 1) - *(void *)(**((void **)v10 + 1) + 120), v33);
                  unsigned int v39 = result;
                  if (result) {
                    return result;
                  }
                }
                else if (v12 != 1186660419)
                {
                  if (v12 != 638215866)
                  {
                    uint64_t v33 = 0;
                    uint64_t v34 = 0;
                    LODWORD(v31) = 0;
                    unsigned int v39 = (***(uint64_t (****)(void, uint64_t, void, char **))v10)(*(void *)v10 - *(void *)(**(void **)v10 + 224), v12, v36, &v34);
                    if (v39) {
                      return v39;
                    }
                    LODWORD(v31) = (*(uint64_t (**)(char *))(*(void *)v34 + 88))(&v34[-*(void *)(*(void *)v34 + 224)]) != 0;
                    uint64_t v19 = *((void *)v10 + 1);
                    uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t *, uint64_t *))(*(void *)v19 + 24);
                    uint64_t v20 = v19 - *(void *)(*(void *)v19 + 120);
                    uint64_t v21 = (*(uint64_t (**)(char *))(*(void *)v34 + 56))(&v34[-*(void *)(*(void *)v34 + 224)]);
                    uint64_t v22 = (*(uint64_t (**)(char *))(*(void *)v34 + 64))(&v34[-*(void *)(*(void *)v34 + 224)]);
                    unsigned __int16 v23 = (*(uint64_t (**)(char *))(*(void *)v34 + 96))(&v34[-*(void *)(*(void *)v34 + 224)]);
                    unsigned int v39 = v29(v20, v12, v21, v22, v23, &v31, &v33);
                    if (v39) {
                      return v39;
                    }
                    v10[4] = i + 1;
                    uint64_t v24 = OOCAllocator_Malloc(a1[10], 24, &v39);
                    if (v39) {
                      return v39;
                    }
                    *(void *)uint64_t v24 = v34;
                    *(void *)(v24 + 8) = v33;
                    *(_DWORD *)(v24 + 16) = 0;
                    unsigned int v39 = PtrStack_Put(v38, v24);
                    if (v39) {
                      return v39;
                    }
                    goto LABEL_43;
                  }
                  uint64_t v33 = 0;
                  uint64_t v34 = 0;
                  uint64_t v31 = 0;
                  uint64_t result = (***(uint64_t (****)(void, uint64_t, void, uint64_t *))v10)(*(void *)v10 - *(void *)(**(void **)v10 + 224), 638215866, v36, &v31);
                  unsigned int v39 = result;
                  if (result) {
                    return result;
                  }
                  uint64_t v13 = *((void *)v10 + 1);
                  uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)v13 + 8);
                  uint64_t v15 = v13 - *(void *)(*(void *)v13 + 120);
                  uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v31 + 64))(v31 - *(void *)(*(void *)v31 + 224));
                  uint64_t result = v14(v15, 638215866, v16, 2, &v33);
                  unsigned int v39 = result;
                  if (result) {
                    return result;
                  }
                  uint64_t result = PNEW_StringPool_Con(a1[10], a1[10], v31, &v34);
                  unsigned int v39 = result;
                  if (result) {
                    return result;
                  }
                  uint64_t result = (**((uint64_t (***)(uint64_t, uint64_t))v34 + 7))((uint64_t)&v34[-*(void *)(*((void *)v34 + 7) + 16) + 56], v33);
                  unsigned int v39 = result;
                  if (result) {
                    return result;
                  }
                  uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)v10 + 16))(*(void *)v10 - *(void *)(**(void **)v10 + 224), v31);
                  unsigned int v39 = result;
                  if (result) {
                    return result;
                  }
                  uint64_t result = (*(uint64_t (**)(void, uint64_t))(**((void **)v10 + 1) + 40))(*((void *)v10 + 1) - *(void *)(**((void **)v10 + 1) + 120), v33);
                  unsigned int v39 = result;
                  if (result) {
                    return result;
                  }
                  unsigned int v39 = (*(uint64_t (**)(char *))(*(void *)v34 + 32))(v34);
                  if (v39) {
                    return v39;
                  }
                }
              }
              uint64_t result = PtrStack_Remove(v38);
              unsigned int v39 = result;
              if (result) {
                return result;
              }
              int v17 = *(_DWORD *)(v38 + 24);
              if (v17)
              {
                unsigned int v18 = *(void ***)(*(void *)(v38 + 32) + 8 * (v17 - 1));
                uint64_t result = (*(uint64_t (**)(char *, void))(**v18 + 16))((char *)*v18 - *(void *)(**v18 + 224), *(void *)v10);
                unsigned int v39 = result;
                if (result) {
                  return result;
                }
                uint64_t result = (*(uint64_t (**)(char *, void))(*v18[1] + 40))((char *)v18[1] - *(void *)(*v18[1] + 120), *((void *)v10 + 1));
                unsigned int v39 = result;
                if (result) {
                  return result;
                }
              }
              OOCAllocator_Free(a1[10], (uint64_t)v10);
LABEL_43:
              uint64_t v8 = v38;
              int v9 = *(_DWORD *)(v38 + 24);
              if (v9) {
                continue;
              }
              break;
            }
          }
          uint64_t result = OOC_PlacementDeleteObject(a1[10], v8);
          unsigned int v39 = result;
          if (!result) {
            return StreamInfo_ArchiveUserData(a1, (uint64_t)a2);
          }
        }
      }
    }
  }
  return result;
}

uint64_t _StreamInfo_BorrowBinBlockStreamReader(uint64_t a1, void *a2)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 96) + 192))(*(void *)(a1 + 96) - *(void *)(**(void **)(a1 + 96) + 224)))
  {
    *a2 = *(void *)(a1 + 96);
    return 0;
  }
  else
  {
    return err_GenerateErrorData();
  }
}

uint64_t __StreamInfo_CopySectionData(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  for (uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)a1 + 8))(a1 - *(void *)(*(void *)a1 + 48), &v7, &v6);
        !result;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)a1 + 8))(a1 - *(void *)(*(void *)a1 + 48), &v7, &v6))
  {
    if (v7) {
      BOOL v5 = v6 == 0;
    }
    else {
      BOOL v5 = 1;
    }
    if (v5) {
      return 0;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2 - *(void *)(*(void *)a2 + 56));
    if (result) {
      return result;
    }
  }
  return result;
}

uint64_t StreamInfo_ArchiveUserData(uint64_t *a1, uint64_t a2)
{
  uint64_t v23 = 0;
  uint64_t result = __StreamInfo_BorrowUserDataList(a1, &v23);
  if (result) {
    return result;
  }
  uint64_t result = PtrList_NrItems(v23);
  if (!result) {
    return result;
  }
  uint64_t v22 = 0;
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1[12] + 192))(a1[12] - *(void *)(*(void *)a1[12]
                                                                                                + 224)))
  {
    uint64_t v5 = a1[12];
  }
  else
  {
    uint64_t result = err_GenerateErrorData();
    if (result) {
      return result;
    }
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t *))(*(void *)a2 + 8);
  uint64_t v7 = a2 - *(void *)(*(void *)a2 + 120);
  unsigned __int16 v8 = PtrList_NrItems(a1[11]);
  uint64_t result = v6(v7, 1186660419, 0x10000, v8, &v22);
  if (result) {
    return result;
  }
  if (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v5 + 32))(v5 - *(void *)(*(void *)v5 + 224), 1186660419))goto LABEL_20; {
  uint64_t v21 = 0;
  }
  uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))v5)(v5 - *(void *)(*(void *)v5 + 224), 1186660419, 0, &v21);
  if (result) {
    return result;
  }
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v21 + 96))(v21 - *(void *)(*(void *)v21 + 224)))
  {
LABEL_19:
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 16))(v5 - *(void *)(*(void *)v5 + 224), v21);
    if (result) {
      return result;
    }
LABEL_20:
    uint64_t v12 = v23;
    if (!PtrList_NrItems(v23)) {
      return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 120), v22);
    }
    unsigned int v13 = 0;
    while (1)
    {
      uint64_t v14 = (unsigned int *)PtrList_ItemN(v12, v13);
      if (*((void *)v14 + 1))
      {
        uint64_t v15 = v14;
        uint64_t v21 = 0;
        uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t *))(*(void *)v22 + 32))(v22 - *(void *)(*(void *)v22 + 120), *v14, 0x10000, &v21);
        if (result) {
          break;
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v21 + 8))(v21 - *(void *)(*(void *)v21 + 56), *((void *)v15 + 1), *((void *)v15 + 2));
        if (result) {
          break;
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v22 + 48))(v22 - *(void *)(*(void *)v22 + 120), v21);
        if (result) {
          break;
        }
      }
      if (++v13 >= PtrList_NrItems(v12)) {
        return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 120), v22);
      }
    }
    return result;
  }
  uint64_t v9 = 0;
  uint64_t v10 = v23;
  while (1)
  {
    uint64_t v20 = 0;
    int v19 = 0;
    uint64_t v20 = (*(unsigned int (**)(uint64_t, uint64_t, int *))(*(void *)v21 + 104))(v21 - *(void *)(*(void *)v21 + 224), v9, &v19);
    uint64_t v11 = PtrList_Find(v10, (uint64_t)&v20, (unsigned int (*)(uint64_t *, uint64_t *))__StreamInfo_UserDataCompareFunc);
    if (v11)
    {
      if (!*(void *)(v11 + 8))
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        unsigned int v16 = 0;
        uint64_t result = (*(uint64_t (**)(uint64_t, void, void, uint64_t *, unsigned int *))(*(void *)v21 + 8))(v21 - *(void *)(*(void *)v21 + 224), v20, 0, &v18, &v16);
        if (result) {
          return result;
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, void, void, uint64_t *))(*(void *)v22 + 32))(v22 - *(void *)(*(void *)v22 + 120), v20, v16, &v17);
        if (result) {
          return result;
        }
        uint64_t result = __StreamInfo_CopySectionData(v18, v17);
        if (result) {
          return result;
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v22 + 48))(v22 - *(void *)(*(void *)v22 + 120), v17);
        if (result) {
          return result;
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v21 + 24))(v21 - *(void *)(*(void *)v21 + 224), v18);
        if (result) {
          return result;
        }
      }
    }
    uint64_t v9 = (v9 + 1);
    if (v9 >= (*(unsigned int (**)(uint64_t))(*(void *)v21 + 96))(v21 - *(void *)(*(void *)v21 + 224))) {
      goto LABEL_19;
    }
  }
}

BOOL __StreamInfo_UserDataCompareFunc(void **a1, void **a2)
{
  return **a1 != **a2;
}

uint64_t StreamInfo_CastToIVoConObject(uint64_t a1)
{
  return a1 + 24;
}

uint64_t StreamInfo_CheckCRC(uint64_t a1, _DWORD *a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 96) + 192))(*(void *)(a1 + 96) - *(void *)(**(void **)(a1 + 96) + 224));
  if (result)
  {
    uint64_t v5 = *(void *)(a1 + 96);
    uint64_t v6 = *(uint64_t (**)(uint64_t, _DWORD *))(*(void *)v5 + 184);
    uint64_t v7 = v5 - *(void *)(*(void *)v5 + 224);
    return v6(v7, a2);
  }
  else
  {
    *a2 = 1;
  }
  return result;
}

uint64_t StreamInfo_CheckDependency(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  unint64_t v14 = 0;
  uint64_t v15 = 0;
  *a3 = 0;
  uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t *))a2)(a2 - *(void *)(*(void *)a2 + 176), &v17);
  if (!result)
  {
    uint64_t v8 = *(void *)(a1 + 56);
    uint64_t v7 = a1 + 56;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *, unint64_t *))(v8 + 16))(v7 - *(void *)(v8 + 176), &v15, &v14);
    if (!result)
    {
      uint64_t v9 = v15;
      if (!v14) {
        return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 24))(v7 - *(void *)(*(void *)v7 + 176), v9);
      }
      uint64_t v10 = 0;
      unsigned int v11 = 1;
      while (1)
      {
        uint64_t v12 = *(void *)(v15 + 8 * v10);
        if (v12 == 1161757918)
        {
          *a3 = 3;
          return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 24))(v7 - *(void *)(*(void *)v7 + 176), v9);
        }
        if (v12 == v17) {
          break;
        }
        uint64_t v10 = v11;
        if (v14 <= v11++) {
          return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 24))(v7 - *(void *)(*(void *)v7 + 176), v9);
        }
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v7 + 136))(v7 - *(void *)(*(void *)v7 + 176), v17, &v16);
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, _DWORD *))(*(void *)a2 + 168))(a2 - *(void *)(*(void *)a2 + 176), v16, a3);
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 144))(v7 - *(void *)(*(void *)v7 + 176), v16);
          if (!result)
          {
            uint64_t v9 = v15;
            return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 24))(v7 - *(void *)(*(void *)v7 + 176), v9);
          }
        }
      }
    }
  }
  return result;
}

uint64_t StreamInfo_CheckDependencyString(uint64_t a1, const char *a2, int *a3)
{
  uint64_t v9 = 0;
  __s2 = 0;
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 96) + 192))(*(void *)(a1 + 96) - *(void *)(**(void **)(a1 + 96) + 224)))
  {
    uint64_t v6 = *(void *)(a1 + 96);
  }
  else
  {
    uint64_t result = err_GenerateErrorData();
    if (result) {
      return result;
    }
    uint64_t v6 = 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, char **, uint64_t *))(*(void *)v6 + 48))(v6 - *(void *)(*(void *)v6 + 224), *(void *)(a1 + 80), 270008321, 0, 0x10000, &__s2, &v9);
  if (!result)
  {
    if (__s2)
    {
      if (cstdlib_strcmp(a2, __s2)) {
        int v8 = 2;
      }
      else {
        int v8 = 1;
      }
    }
    else
    {
      int v8 = 2;
    }
    *a3 = v8;
    OOCAllocator_Free(*(void *)(a1 + 80), (uint64_t)__s2);
    return 0;
  }
  return result;
}

uint64_t StreamInfo_FetchDependency(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 96) + 192))(*(void *)(a1 + 96) - *(void *)(**(void **)(a1 + 96) + 224)))
  {
    uint64_t v6 = *(void *)(a1 + 96);
  }
  else
  {
    uint64_t result = err_GenerateErrorData();
    if (result) {
      return result;
    }
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 136);
  uint64_t v8 = v6 - *(void *)(*(void *)v6 + 224);

  return v7(v8, a2, a3);
}

uint64_t StreamInfo_FetchDependencyString(uint64_t a1, void *a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  *a2 = 0;
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 96) + 192))(*(void *)(a1 + 96) - *(void *)(**(void **)(a1 + 96) + 224)))
  {
    uint64_t v4 = *(void *)(a1 + 96);
  }
  else
  {
    uint64_t result = err_GenerateErrorData();
    if (result) {
      return result;
    }
    uint64_t v4 = 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t *, uint64_t *))(*(void *)v4 + 48))(v4 - *(void *)(*(void *)v4 + 224), *(void *)(a1 + 80), 270008321, 0, 0x10000, &v8, &v7);
  if (result) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = v8 == 0;
  }
  if (!v6)
  {
    uint64_t result = 0;
    *a2 = v8;
  }
  return result;
}

uint64_t StreamInfo_FetchDependentOnTypes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 96) + 192))(*(void *)(a1 + 96) - *(void *)(**(void **)(a1 + 96) + 224)))
  {
    uint64_t v6 = *(void *)(a1 + 96);
  }
  else
  {
    uint64_t result = err_GenerateErrorData();
    if (result) {
      return result;
    }
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 168);
  uint64_t v8 = v6 - *(void *)(*(void *)v6 + 224);

  return v7(v8, a2, a3);
}

uint64_t StreamInfo_FetchUserData(uint64_t *a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v15 = a2;
  uint64_t v13 = 0;
  uint64_t result = __StreamInfo_BorrowUserDataList(a1, &v13);
  unsigned int v14 = result;
  if (!result)
  {
    uint64_t v8 = PtrList_Find(v13, (uint64_t)&v15, (unsigned int (*)(uint64_t *, uint64_t *))__StreamInfo_UserDataCompareFunc);
    if (*(void *)(v8 + 8))
    {
      uint64_t v9 = v8;
      uint64_t v10 = (void *)OOCAllocator_Malloc(a1[10], *(void *)(v8 + 16), &v14);
      *a3 = v10;
      uint64_t result = v14;
      if (!v14)
      {
        cstdlib_memcpy(v10, *(const void **)(v9 + 8), *(void *)(v9 + 16));
        *a4 = *(void *)(v9 + 16);
        return v14;
      }
    }
    else
    {
      uint64_t v12 = 0;
      if ((*(unsigned int (**)(uint64_t))(*(void *)a1[12] + 192))(a1[12] - *(void *)(*(void *)a1[12] + 224)))
      {
        uint64_t v11 = a1[12];
        unsigned int v14 = 0;
      }
      else
      {
        uint64_t result = err_GenerateErrorData();
        unsigned int v14 = result;
        if (result) {
          return result;
        }
        uint64_t v11 = 0;
      }
      uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))v11)(v11 - *(void *)(*(void *)v11 + 224), 1186660419, 0, &v12);
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, void *, void *))(*(void *)v12 + 48))(v12 - *(void *)(*(void *)v12 + 224), a1[10], v15, 0, 0x10000, a3, a4);
        unsigned int v14 = result;
        if (!result) {
          return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v11 + 16))(v11 - *(void *)(*(void *)v11 + 224), v12);
        }
      }
    }
  }
  return result;
}

uint64_t StreamInfo_FetchUserDataIDList(uint64_t *a1, uint64_t *a2, void *a3)
{
  uint64_t v13 = 0;
  uint64_t result = __StreamInfo_BorrowUserDataList(a1, &v13);
  unsigned int v14 = result;
  if (!result)
  {
    uint64_t v7 = v13;
    unsigned int v8 = PtrList_NrItems(v13);
    uint64_t v9 = v8;
    if (v7) {
      BOOL v10 = v8 == 0;
    }
    else {
      BOOL v10 = 1;
    }
    if (v10)
    {
      uint64_t result = 0;
      uint64_t v11 = 0;
    }
    else
    {
      uint64_t v11 = OOCAllocator_Malloc(a1[10], 8 * v8, &v14);
      uint64_t result = v14;
      if (v14) {
        return result;
      }
      uint64_t v12 = 0;
      do
      {
        *(void *)(v11 + 8 * v12) = *(void *)PtrList_ItemN(v7, v12);
        ++v12;
      }
      while (v9 != v12);
      uint64_t result = v14;
    }
    *a2 = v11;
    *a3 = v9;
  }
  return result;
}

uint64_t StreamInfo_GetType(uint64_t a1, void *a2)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 96) + 192))(*(void *)(a1 + 96) - *(void *)(**(void **)(a1 + 96) + 224)))
  {
    uint64_t v4 = *(void *)(a1 + 96);
LABEL_3:
    unsigned int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 56))(v4 - *(void *)(*(void *)v4 + 224));
    uint64_t result = 0;
    *a2 = v5;
    return result;
  }
  uint64_t result = err_GenerateErrorData();
  if (!result)
  {
    uint64_t v4 = 0;
    goto LABEL_3;
  }
  return result;
}

uint64_t StreamInfo_GetVersion(uint64_t a1, void *a2, _DWORD *a3)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 96) + 192))(*(void *)(a1 + 96) - *(void *)(**(void **)(a1 + 96) + 224)))
  {
    uint64_t v6 = *(void *)(a1 + 96);
LABEL_3:
    unsigned int v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 64))(v6 - *(void *)(*(void *)v6 + 224));
    uint64_t result = 0;
    *a2 = v7;
    *a3 = 2;
    return result;
  }
  uint64_t result = err_GenerateErrorData();
  if (!result)
  {
    uint64_t v6 = 0;
    goto LABEL_3;
  }
  return result;
}

uint64_t StreamInfo_HasUserData(uint64_t *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a2;
  uint64_t v4 = __StreamInfo_BorrowUserDataList(a1, &v6);
  if (!v4) {
    *a3 = PtrList_Find(v6, (uint64_t)&v7, (unsigned int (*)(uint64_t *, uint64_t *))__StreamInfo_UserDataCompareFunc) != 0;
  }
  return v4;
}

uint64_t StreamInfo_IsReadyToArchive()
{
  return 1;
}

uint64_t StreamInfo_QueryInterface(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  switch(a2)
  {
    case 653755852:
      uint64_t v3 = a1 + 72;
      goto LABEL_7;
    case 1310403890:
      uint64_t v3 = a1 + 64;
      goto LABEL_7;
    case 1204988275:
      uint64_t v3 = a1 + 56;
LABEL_7:
      *a3 = v3;
      return 0;
  }
  return VoConObject_QueryInterface(a1, a2, a3);
}

uint64_t StreamInfo_RemoveUserData(uint64_t *a1, uint64_t a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = a2;
  uint64_t v3 = __StreamInfo_BorrowUserDataList(a1, &v6);
  if (!v3)
  {
    uint64_t v4 = PtrList_Find(v6, (uint64_t)&v7, (unsigned int (*)(uint64_t *, uint64_t *))__StreamInfo_UserDataCompareFunc);
    PtrList_Remove(a1[11], v4);
    OOCAllocator_Free(a1[10], *(void *)(v4 + 8));
    OOCAllocator_Free(a1[10], v4);
  }
  return v3;
}

uint64_t StreamInfo_ReturnDependency(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 96) + 192))(*(void *)(a1 + 96) - *(void *)(**(void **)(a1 + 96) + 224)))
  {
    uint64_t v4 = *(void *)(a1 + 96);
  }
  else
  {
    uint64_t result = err_GenerateErrorData();
    if (result) {
      return result;
    }
    uint64_t v4 = 0;
  }
  unsigned int v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 128);
  uint64_t v6 = v4 - *(void *)(*(void *)v4 + 224);

  return v5(v6, a2);
}

uint64_t StreamInfo_ReturnDependencyString(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t StreamInfo_ReturnDependentOnTypes(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 96) + 192))(*(void *)(a1 + 96) - *(void *)(**(void **)(a1 + 96) + 224)))
  {
    uint64_t v4 = *(void *)(a1 + 96);
  }
  else
  {
    uint64_t result = err_GenerateErrorData();
    if (result) {
      return result;
    }
    uint64_t v4 = 0;
  }
  unsigned int v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 176);
  uint64_t v6 = v4 - *(void *)(*(void *)v4 + 224);

  return v5(v6, a2);
}

uint64_t StreamInfo_ReturnUserData(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t StreamInfo_ReturnUserDataIDList(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t _StreamInfo_FetchDataSectionBuffer()
{
  return 0;
}

uint64_t _StreamInfo_GetNbrSections(uint64_t a1, _WORD *a2)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 96) + 192))(*(void *)(a1 + 96) - *(void *)(**(void **)(a1 + 96) + 224)))
  {
    uint64_t v4 = *(void *)(a1 + 96);
  }
  else
  {
    uint64_t result = err_GenerateErrorData();
    if (result) {
      return result;
    }
    uint64_t v4 = 0;
  }
  __int16 v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 96))(v4 - *(void *)(*(void *)v4 + 224));
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 32))(v4 - *(void *)(*(void *)v4 + 224), 1186660419);
  uint64_t result = 0;
  if (v6) {
    __int16 v8 = v5 - 1;
  }
  else {
    __int16 v8 = v5;
  }
  *a2 = v8;
  return result;
}

uint64_t _StreamInfo_IsDataSectionChanged()
{
  return 0;
}

uint64_t _StreamInfo_ReturnDataSectionBuffer()
{
  return 0;
}

uint64_t PNEW_StreamInfo_Con(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unsigned int v10 = 0;
  __int16 v8 = (void *)OOCAllocator_Malloc(a1, 104, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = StreamInfo_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      v8[2] = a1;
      *a4 = v8;
    }
  }
  return result;
}

void *GetStreamInfoClass()
{
  return &__StreamInfo;
}

uint64_t _ConfigStreamInfo_Con(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = StreamInfo_Con(a1, a2, a3);
  if (!result)
  {
    *a1 = &__ConfigStreamInfo;
    a1[3] = &unk_26D218830;
    a1[13] = &unk_26D2189B0;
    a1[14] = 0;
  }
  return result;
}

uint64_t ConfigStreamInfo_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 112);
  if (!v2 || (uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 80), v2), !result))
  {
    return StreamInfo_Des(a1);
  }
  return result;
}

uint64_t ConfigStreamInfo_DoLazyInitialization(uint64_t *a1)
{
  if (a1[14]) {
    return 0;
  }
  uint64_t result = PNEW_ParamDB_Con(a1[10], a1[10], a1 + 14);
  if (!result)
  {
    uint64_t v3 = *(uint64_t (**)(uint64_t *))(*a1 + 576);
    return v3(a1);
  }
  return result;
}

uint64_t ConfigStreamInfo_FetchAllComputableParams(uint64_t a1, void *a2, void *a3)
{
  *a2 = 0;
  *a3 = 0;
  return 0;
}

uint64_t ConfigStreamInfo_FetchAllParams()
{
  return err_GenerateErrorNotSupported();
}

uint64_t ConfigStreamInfo_FetchSupportedParams(uint64_t a1, uint64_t *a2, void *a3)
{
  return ParamDB_FetchPublicParams(*(void *)(a1 + 112), a2, a3);
}

uint64_t _ConfigStreamInfo_BorrowUserParamDB(uint64_t a1)
{
  return *(void *)(a1 + 112);
}

uint64_t ConfigStreamInfo_GetFactorySetting(uint64_t a1, int a2, void *a3)
{
  *a3 = (int)ParamDB_GetFactoryParam(*(void *)(a1 + 112), a2);
  return 0;
}

uint64_t ConfigStreamInfo_GetParam(uint64_t a1, int a2, void *a3)
{
  *a3 = (int)ParamDB_GetParam(*(void *)(a1 + 112), a2);
  return 0;
}

BOOL ConfigStreamInfo_HasParam(uint64_t a1, int a2)
{
  return ParamDB_HasParam(*(void *)(a1 + 112), a2);
}

BOOL ConfigStreamInfo_IsComputedParam(uint64_t a1, int a2)
{
  return ParamDB_IsComputedParam(*(void *)(a1 + 112), a2);
}

uint64_t ConfigStreamInfo_IsParamValueValid(uint64_t a1, int a2, uint64_t a3)
{
  return ParamDB_IsParamValueValid(*(void *)(a1 + 112), a2, a3);
}

uint64_t ConfigStreamInfo_QueryInterface(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (a2 != 715978428) {
    return StreamInfo_QueryInterface(a1, a2, a3);
  }
  *a3 = a1 + 104;
  return 0;
}

uint64_t ConfigStreamInfo_ResetAllParamsToFactorySetting(uint64_t a1)
{
  return 0;
}

uint64_t ConfigStreamInfo_ResetParamToFactorySetting(uint64_t a1, int a2)
{
  return 0;
}

uint64_t ConfigStreamInfo_ReturnAllComputableParams()
{
  return 0;
}

uint64_t ConfigStreamInfo_ReturnAllParams()
{
  return err_GenerateErrorNotSupported();
}

uint64_t ConfigStreamInfo_ReturnSupportedParams(uint64_t a1, uint64_t a2)
{
  return ParamDB_ReturnPublicParams(*(void *)(a1 + 112), a2);
}

uint64_t ConfigStreamInfo_SetParam(uint64_t a1, int a2, int a3)
{
  return 0;
}

uint64_t ConfigStreamInfo_UpdateAllComputedParams(uint64_t a1)
{
  return ParamDB_UpdateAllComputedParams(*(void *)(a1 + 112));
}

uint64_t ConfigStreamInfo_UpdateComputedParam(uint64_t a1, int a2)
{
  return ParamDB_UpdateComputedParam(*(void *)(a1 + 112), a2);
}

uint64_t _ConfigStreamInfo_AddParam(uint64_t a1, int a2, int a3, uint64_t a4)
{
  return ParamDB_AddPublicParam(*(void *)(a1 + 112), a2, a3, a4);
}

uint64_t _ConfigStreamInfo_AddReadOnlyParam(uint64_t a1, int a2, int a3)
{
  return ParamDB_AddPublicReadOnlyParam(*(void *)(a1 + 112), a2, a3);
}

uint64_t _ConfigStreamInfo_LoadParams(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a1 + 80);
  uint64_t v6 = *(void *)(a1 + 112);
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, unsigned __int16 **, uint64_t *))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 224), v5, a3, a4, a5, &v9, &v8);
  if (!result)
  {
    if (v9)
    {
      uint64_t result = ParamDB_LoadAllParamsFromBinaryBuffer(v6, v9);
      if (!result)
      {
        OOCAllocator_Free(v5, (uint64_t)v9);
        return 0;
      }
    }
    else
    {
      return err_GenerateErrorData();
    }
  }
  return result;
}

void *GetConfigStreamInfoClass()
{
  return &__ConfigStreamInfo;
}

uint64_t StreamInfoFactory_Con(void *a1, uint64_t a2)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__StreamInfoFactory;
    a1[1] = &unk_26D218A60;
    a1[2] = a2;
  }
  return result;
}

uint64_t StreamInfoFactory_Create(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = 0;
  uint64_t result = PNEW_StreamInfo_Con(*(void *)(a1 + 16), *(void *)(a1 + 16), a2, &v5);
  if (!result) {
    *a3 = v5 + 56;
  }
  return result;
}

uint64_t StreamInfoFactory_Has()
{
  return 0;
}

uint64_t PNEW_StreamInfoFactory_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = (void *)OOCAllocator_Malloc(a1, 24, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = Object_Con(v6);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      void *v6 = &__StreamInfoFactory;
      v6[1] = &unk_26D218A60;
      v6[2] = a2;
      *a3 = v6;
    }
  }
  return result;
}

void *GetStreamInfoFactoryClass()
{
  return &__StreamInfoFactory;
}

void StringPoolIteratorHandlerStaticCDSHash_Con(void *a1, uint64_t a2, uint64_t a3)
{
  _StringPoolIteratorHandler_Con(a1);
  if (!v6)
  {
    *a1 = &__StringPoolIteratorHandlerStaticCDSHash;
    a1[5] = a3;
    a1[6] = a2;
  }
}

uint64_t StringPoolIteratorHandlerStaticCDSHash_Des(void *a1)
{
  uint64_t v2 = a1[1];
  if (!v2 || (uint64_t result = OOC_PlacementDeleteObject(a1[6], v2), !result))
  {
    OOCAllocator_Free(a1[6], a1[3]);
    a1[3] = 0;
    return StringPoolIteratorHandler_Des(a1);
  }
  return result;
}

uint64_t StringPoolIteratorHandlerStaticCDSHash_First(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (!*(_DWORD *)(v1 + 40)) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(*(void *)(v1 + 8) + 96))(v1 + 8 - *(void *)(*(void *)(v1 + 8) + 128), *(unsigned int *)(a1 + 16), *(void *)(a1 + 24));
  if (!result)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(v4 + 8);
    v4 += 8;
    *(void *)(a1 + 16) = *(unsigned int *)(v4 + 72);
    uint64_t result = (*(uint64_t (**)(uint64_t))(v5 + 88))(v4 - *(void *)(v5 + 128));
    if (!result) {
      *(_DWORD *)(a1 + 32) = 0;
    }
  }
  return result;
}

uint64_t StringPoolIteratorHandlerStaticCDSHash_Next(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(*(void *)(*(void *)(a1 + 40) + 8) + 96))(*(void *)(a1 + 40) + 8 - *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 128), *(unsigned int *)(a1 + 16), *(void *)(a1 + 24));
  if (result) {
    return result;
  }
  *(void *)(a1 + 24) = 0;
  if (*(_DWORD *)(a1 + 32))
  {
    uint64_t result = *(void *)(a1 + 8);
    if (!result) {
      return result;
    }
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 32);
LABEL_12:
    return v3();
  }
  unint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(a1 + 40);
  if (v4 >= (*(_DWORD *)(v5 + 80) + *(_DWORD *)(v5 + 40) - 1))
  {
    *(_DWORD *)(a1 + 32) = 1;
    *(void *)(a1 + 16) = 0;
    uint64_t result = *(void *)(a1 + 8);
    if (!result) {
      return result;
    }
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 24);
    goto LABEL_12;
  }
  *(void *)(a1 + 16) = v4 + 1;
  uint64_t v6 = *(void *)(v5 + 8);
  uint64_t v7 = *(uint64_t (**)(uint64_t))(v6 + 88);
  uint64_t v8 = v5 + 8 - *(void *)(v6 + 128);

  return v7(v8);
}

void PNEW_StringPoolIteratorHandlerStaticCDSHash_Con(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v10 = 0;
  uint64_t v8 = (void *)OOCAllocator_Malloc(a1, 56, &v10);
  if (!v10)
  {
    _StringPoolIteratorHandler_Con(v8);
    if (v9)
    {
      int v10 = v9;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
    }
    else
    {
      *uint64_t v8 = &__StringPoolIteratorHandlerStaticCDSHash;
      v8[5] = a3;
      v8[6] = a2;
      *a4 = v8;
    }
  }
}

void *GetStringPoolIteratorHandlerStaticCDSHashClass()
{
  return &__StringPoolIteratorHandlerStaticCDSHash;
}

double _StringPoolIteratorHandler_Con(void *a1)
{
  if (!Object_Con(a1))
  {
    *a1 = &__StringPoolIteratorHandler;
    a1[1] = 0;
    a1[2] = 0;
    a1[3] = 0;
    *(void *)&double result = 1;
    a1[4] = 1;
  }
  return result;
}

uint64_t StringPoolIteratorHandler_BorrowCurrent(uint64_t result)
{
  while (*(_DWORD *)(result + 32))
  {
    double result = *(void *)(result + 8);
    if (!result) {
      return result;
    }
  }
  result += 16;
  return result;
}

uint64_t StringPoolIteratorHandler_IsDone(uint64_t a1)
{
  do
  {
    uint64_t v1 = *(unsigned int *)(a1 + 32);
    if (!v1) {
      break;
    }
    a1 = *(void *)(a1 + 8);
  }
  while (a1);
  return v1;
}

uint64_t StringPoolIteratorHandler_IsModified(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t StringPoolIteratorHandler_Modify(uint64_t result)
{
  *(_DWORD *)(result + 36) = 1;
  return result;
}

uint64_t StringPoolIteratorHandler_SetNext(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8) = a2;
  return result;
}

void *GetStringPoolIteratorHandlerClass()
{
  return &__StringPoolIteratorHandler;
}

uint64_t StringPoolIterator_Con(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = VoConObject_Con2(a1, a2);
  if (!result)
  {
    *a1 = &__StringPoolIterator;
    a1[3] = &unk_26D218B08;
    a1[7] = &unk_26D218B50;
    a1[8] = a2;
    a1[9] = a3;
    a1[10] = a4;
    a1[11] = a5;
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a5 + 24))(a5);
    if (!result)
    {
      a1[9] = a3;
      (*(void (**)(uint64_t))(*(void *)a3 + 80))(a3 - *(void *)(*(void *)a3 + 104));
      return 0;
    }
  }
  return result;
}

uint64_t StringPoolIterator_Des(uint64_t a1)
{
  uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 64), *(void *)(a1 + 88));
  if (!result)
  {
    uint64_t result = (***(uint64_t (****)(void, uint64_t))(a1 + 80))(*(void *)(a1 + 80) - *(void *)(**(void **)(a1 + 80) + 8), a1);
    if (!result)
    {
      (*(void (**)(void))(**(void **)(a1 + 72) + 88))(*(void *)(a1 + 72) - *(void *)(**(void **)(a1 + 72) + 104));
      return VoConObject_Des(a1);
    }
  }
  return result;
}

uint64_t StringPoolIterator_BorrowCurrent(uint64_t a1)
{
  if (StringPoolIteratorHandler_IsModified(*(void *)(a1 + 88))
    || StringPoolIteratorHandler_IsDone(*(void *)(a1 + 88)))
  {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 88);

  return StringPoolIteratorHandler_BorrowCurrent(v3);
}

uint64_t StringPoolIterator_CastToIVoConObject(uint64_t a1)
{
  return a1 + 24;
}

uint64_t StringPoolIterator_First(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 24))(*(void *)(a1 + 88));
}

uint64_t StringPoolIterator_IsDone(uint64_t a1)
{
  return StringPoolIteratorHandler_IsDone(*(void *)(a1 + 88));
}

uint64_t StringPoolIterator_Next(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 32))(*(void *)(a1 + 88));
}

uint64_t StringPoolIterator_QueryInterface(uint64_t a1, uint64_t a2, void *a3)
{
  if (StringPoolIteratorHandler_IsModified(*(void *)(a1 + 88)))
  {
    return err_GenerateErrorInconsistent();
  }
  else if (a2 == 647862307)
  {
    *a3 = a1 + 56;
    return 0;
  }
  else
  {
    return VoConObject_QueryInterface(a1, a2, a3);
  }
}

uint64_t StringPoolIterator_StringPoolModified(uint64_t a1)
{
  return StringPoolIteratorHandler_Modify(*(void *)(a1 + 88));
}

uint64_t PNEW_StringPoolIterator_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = (void *)OOCAllocator_Malloc(a1, 96, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = StringPoolIterator_Con(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      v12[2] = a1;
      *a6 = v12;
    }
  }
  return result;
}

void *GetStringPoolIteratorClass()
{
  return &__StringPoolIterator;
}

uint64_t _StringPoolHandlerDynamic_Con(uint64_t a1, uint64_t a2)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__StringPoolHandlerDynamic;
    *(void *)(a1 + 8) = &unk_26D218BA8;
    *(void *)(a1 + 168) = a2;
    stringpool_md5_init((_OWORD *)(a1 + 16));
    cstdlib_memset((void *)(a1 + 108), 0, 0x24uLL);
    uint64_t result = PNEW_PtrList_Con(*(void *)(a1 + 168), *(void *)(a1 + 168), 5u, 1, (uint64_t *)(a1 + 152));
    if (!result)
    {
      *(_DWORD *)(a1 + 144) = 1;
      *(void *)(a1 + 160) = 0;
    }
  }
  return result;
}

uint64_t StringPoolHandlerDynamic_Des(uint64_t a1)
{
  uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 168), *(void *)(a1 + 152));
  if (!result)
  {
    return Object_Des();
  }
  return result;
}

uint64_t StringPoolHandlerDynamic_AddListener(uint64_t a1, const void *a2, uint64_t a3)
{
  unsigned int v8 = 0;
  if (PtrList_Find(*(void *)(a1 + 152), a3, (unsigned int (*)(uint64_t *, uint64_t *))__StringPoolHandlerDynamic_CompareListeners))
  {
    return err_GenerateErrorArg();
  }
  else
  {
    uint64_t v7 = (void *)OOCAllocator_Malloc(*(void *)(a1 + 168), 16, &v8);
    uint64_t result = v8;
    if (!v8)
    {
      cstdlib_memcpy(v7, a2, 8uLL);
      v7[1] = a3;
      return PtrList_Append(*(void *)(a1 + 152), (uint64_t)v7);
    }
  }
  return result;
}

BOOL __StringPoolHandlerDynamic_CompareListeners(void *a1, uint64_t a2)
{
  return *(void *)(*(void *)a2 + 8) != *a1;
}

uint64_t StringPoolHandlerDynamic_Archive(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = (**(uint64_t (***)(uint64_t))(a1 + 8))(a1 + 8 - *(void *)(*(void *)(a1 + 8) + 128));
  if (!PtrList_NrItems(*(void *)(v2 + 144))) {
    return 0;
  }
  unsigned int v4 = 0;
  while (1)
  {
    uint64_t v5 = PtrList_ItemN(*(void *)(a1 + 152), v4);
    if ((*(unsigned int (**)(void, uint64_t))v5)(*(void *)(v5 + 8), v3)) {
      break;
    }
    if (++v4 >= PtrList_NrItems(*(void *)(a1 + 152))) {
      return 0;
    }
  }

  return err_GenerateErrorCallback();
}

uint64_t StringPoolHandlerDynamic_BorrowSignature(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  if (!*(void *)(a1 + 160)
    || !stringpool_md5_is_initial_state((_DWORD *)(a1 + 16))
    || (uint64_t result = (***(uint64_t (****)(void))(a1 + 160))(*(void *)(a1 + 160) - *(void *)(**(void **)(a1 + 160) + 8))) == 0)
  {
    __StringPoolHandlerDynamic_BootstrapSignature((unsigned int *)a1);
    if (*(_DWORD *)(a1 + 144))
    {
      memset(v3, 0, 92);
      cstdlib_memcpy(v3, (const void *)(a1 + 16), 0x5CuLL);
      stringpool_md5_finish((unsigned int *)v3, (unsigned char *)(a1 + 108));
      *(_DWORD *)(a1 + 144) = 0;
    }
    return a1 + 108;
  }
  return result;
}

BOOL StringPoolHandlerDynamic_HasListener(uint64_t a1)
{
  return PtrList_NrItems(*(void *)(a1 + 152)) != 0;
}

uint64_t StringPoolHandlerDynamic_RemoveAllListeners(uint64_t a1)
{
  int v2 = PtrList_NrItems(*(void *)(a1 + 152));
  if (v2)
  {
    int v3 = v2;
    for (unsigned int i = 0; i != v3; ++i)
    {
      uint64_t v5 = PtrList_ItemN(*(void *)(a1 + 152), i);
      OOCAllocator_Free(*(void *)(a1 + 168), v5);
    }
  }
  PtrList_RemoveAll(*(void *)(a1 + 152));
  return 0;
}

uint64_t StringPoolHandlerDynamic_RemoveListener(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = PtrList_Find(*(void *)(a1 + 152), a2, (unsigned int (*)(uint64_t *, uint64_t *))__StringPoolHandlerDynamic_CompareListeners);
  if (v3)
  {
    uint64_t v4 = v3;
    PtrList_Remove(*(void *)(a1 + 152), v3);
    OOCAllocator_Free(*(void *)(a1 + 168), v4);
    return 0;
  }
  else
  {
    return err_GenerateErrorArg();
  }
}

uint64_t StringPoolHandlerDynamic_SetBootstrapSignature(uint64_t result, uint64_t a2)
{
  *(void *)(result + 160) = a2;
  return result;
}

uint64_t StringPoolHandlerDynamic_VerifySignature(uint64_t a1, const char *a2, _DWORD *a3)
{
  uint64_t v5 = (const char *)(**(uint64_t (***)(uint64_t))(a1 + 8))(a1 + 8 - *(void *)(*(void *)(a1 + 8) + 128));
  *a3 = cstdlib_strcmp(v5, a2) == 0;
  return 0;
}

uint64_t _StringPoolHandlerDynamic_AddStringToSignature(unsigned int *a1, char *a2, unsigned int a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  unsigned int v10 = 0;
  __StringPoolHandlerDynamic_BootstrapSignature(a1);
  a1[36] = 1;
  int v6 = cstdlib_strlen(a2);
  uint64_t v7 = a1 + 4;
  stringpool_md5_append(v7, (int *)a2, v6);
  spr_ulcat_err(__s, (uint64_t)&v12, "d", a3, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    int v9 = cstdlib_strlen(__s);
    stringpool_md5_append(v7, (int *)__s, v9);
    return v10;
  }
  return result;
}

unsigned int *__StringPoolHandlerDynamic_BootstrapSignature(unsigned int *result)
{
  if (*((void *)result + 20))
  {
    uint64_t v1 = result;
    int v2 = result + 4;
    uint64_t result = (unsigned int *)stringpool_md5_is_initial_state(result + 4);
    if (result)
    {
      uint64_t v3 = (int *)(***((uint64_t (****)(void))v1 + 20))(*((void *)v1 + 20) - *(void *)(**((void **)v1 + 20) + 8));
      uint64_t v4 = (const char *)(***((uint64_t (****)(void))v1 + 20))(*((void *)v1 + 20) - *(void *)(**((void **)v1 + 20) + 8));
      uint64_t v5 = (int)cstdlib_strlen(v4);
      return stringpool_md5_append(v2, v3, v5);
    }
  }
  return result;
}

uint64_t _StringPoolHandlerDynamic_FillOutMD5StateForArchive(uint64_t a1, void *__dst, size_t a3)
{
  return 0;
}

uint64_t _StringPoolHandlerDynamic_InitializeMD5StateFromArchive(uint64_t a1, const void *a2, size_t a3)
{
  if (a3 == 92)
  {
    cstdlib_memcpy((void *)(a1 + 16), a2, a3);
    return 0;
  }
  else
  {
    return err_GenerateErrorData();
  }
}

void *GetStringPoolHandlerDynamicClass()
{
  return &__StringPoolHandlerDynamic;
}

uint64_t StringPoolHandlerDynamicAVLTree_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result = _StringPoolHandlerDynamic_Con(a1, a2);
  if (!result)
  {
    *(void *)a1 = &__StringPoolHandlerDynamicAVLTree;
    *(void *)(a1 + 8) = &unk_26D218C48;
    *(void *)(a1 + 176) = a2;
    *(_DWORD *)(a1 + 192) = a4;
    *(_DWORD *)(a1 + 196) = 0;
    *(void *)(a1 + 184) = 0;
    if (a3)
    {
      uint64_t v9 = 0;
      unsigned int v10 = 0;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, _DWORD **, uint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), a2, 673589633, 0, 0x10000, &v10, &v9);
      if (!result)
      {
        if (v10)
        {
          uint64_t result = __StringPoolHandlerDynamicAVLTree_ReadStrings(a1, v10);
          if (!result)
          {
            OOCAllocator_Free(*(void *)(a1 + 176), (uint64_t)v10);
            return 0;
          }
        }
        else
        {
          return err_GenerateErrorData();
        }
      }
    }
    else
    {
      uint64_t result = PNEW_AVLTree_Con(a2, a2, 0xAu, 10, (uint64_t)__StringPoolHandlerDynamicAVLTree_CompareStrings, (uint64_t *)(a1 + 184));
      if (!result) {
        *(_DWORD *)(a1 + 196) = 0;
      }
    }
  }
  return result;
}

uint64_t __StringPoolHandlerDynamicAVLTree_ReadStrings(uint64_t a1, _DWORD *a2)
{
  if (*a2 == 92)
  {
    uint64_t result = _StringPoolHandlerDynamic_InitializeMD5StateFromArchive(a1, a2 + 1, 0x5CuLL);
    if (!result)
    {
      int v5 = a2[24];
      unsigned int v6 = v5 ? a2[24] : 10;
      uint64_t result = PNEW_AVLTree_Con(*(void *)(a1 + 176), *(void *)(a1 + 176), v6, 10, (uint64_t)__StringPoolHandlerDynamicAVLTree_CompareStrings, (uint64_t *)(a1 + 184));
      if (!result)
      {
        if (v5)
        {
          uint64_t v7 = (char *)(a2 + 25);
          int v8 = v5;
          while (1)
          {
            uint64_t result = __StringPoolHandlerDynamicAVLTree_AddStringToTree(a1, *(void *)(a1 + 184), v7);
            if (result) {
              break;
            }
            v7 += cstdlib_strlen(v7) + 1;
            if (!--v8) {
              goto LABEL_11;
            }
          }
        }
        else
        {
LABEL_11:
          uint64_t result = 0;
          *(_DWORD *)(a1 + 196) = v5;
        }
      }
    }
  }
  else
  {
    return err_GenerateErrorData();
  }
  return result;
}

uint64_t _StringPoolHandlerDynamicAVLTree_ConInternal(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = _StringPoolHandlerDynamic_Con(a1, a2);
  if (!result)
  {
    *(void *)a1 = &__StringPoolHandlerDynamicAVLTree;
    *(void *)(a1 + 8) = &unk_26D218C48;
    *(_DWORD *)(a1 + 192) = a3;
    *(_DWORD *)(a1 + 196) = 0;
    *(void *)(a1 + 176) = a2;
    *(void *)(a1 + 184) = 0;
  }
  return result;
}

uint64_t StringPoolHandlerDynamicAVLTree_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 184);
  if (!v2) {
    goto LABEL_6;
  }
  if (AVLTree_NrItems(v2))
  {
    unint64_t v3 = 0;
    do
    {
      uint64_t v4 = *(void *)(a1 + 176);
      uint64_t v5 = AVLTree_ItemN(*(void *)(a1 + 184), v3);
      OOCAllocator_Free(v4, v5);
      ++v3;
    }
    while (v3 < AVLTree_NrItems(*(void *)(a1 + 184)));
  }
  uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 176), *(void *)(a1 + 184));
  if (!result)
  {
LABEL_6:
    return StringPoolHandlerDynamic_Des(a1);
  }
  return result;
}

uint64_t StringPoolHandlerDynamicAVLTree_AddString(uint64_t a1, char *a2, void *a3)
{
  uint64_t v9 = 0;
  uint64_t result = AVLTree_Find(*(void *)(a1 + 184), (uint64_t)a2, (int *)&v9, (_DWORD *)&v9 + 1);
  if (!result)
  {
    if (HIDWORD(v9))
    {
      unsigned int v7 = v9 + *(_DWORD *)(a1 + 192);
LABEL_4:
      uint64_t result = 0;
      *a3 = v7;
      return result;
    }
    uint64_t result = __StringPoolHandlerDynamicAVLTree_AddStringToTree(a1, *(void *)(a1 + 184), a2);
    if (!result)
    {
      int v8 = *(_DWORD *)(a1 + 192);
      LODWORD(v9) = v8 + AVLTree_NrItems(*(void *)(a1 + 184)) - 1;
      uint64_t result = _StringPoolHandlerDynamic_AddStringToSignature((unsigned int *)a1, a2, v9);
      if (!result)
      {
        unsigned int v7 = v9;
        goto LABEL_4;
      }
    }
  }
  return result;
}

uint64_t __StringPoolHandlerDynamicAVLTree_AddStringToTree(uint64_t a1, uint64_t a2, char *__s)
{
  uint64_t v9 = 0;
  size_t v6 = cstdlib_strlen(__s);
  unsigned int v7 = (char *)OOCAllocator_Malloc(*(void *)(a1 + 176), v6 + 1, (_DWORD *)&v9 + 1);
  uint64_t result = HIDWORD(v9);
  if (!HIDWORD(v9))
  {
    cstdlib_strcpy(v7, __s);
    uint64_t result = AVLTree_Insert(a2, (uint64_t)v7, (int *)&v9);
    if (!result) {
      ++*(_DWORD *)(a1 + 196);
    }
  }
  return result;
}

uint64_t StringPoolHandlerDynamicAVLTree_Archive(uint64_t a1, uint64_t a2)
{
  uint64_t result = StringPoolHandlerDynamic_Archive(a1);
  if (!result)
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v17 = 0;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 32))(a2 - *(void *)(*(void *)a2 + 120), 673589633, 0x10000, &v19);
    if (!result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, _DWORD **, uint64_t *))(*(void *)v19 + 16))(v19 - *(void *)(*(void *)v19 + 56), &v18, &v17);
      if (!result)
      {
        uint64_t v5 = v18;
        *uint64_t v18 = 92;
        uint64_t result = _StringPoolHandlerDynamic_FillOutMD5StateForArchive(a1, v5 + 1, 0x5CuLL);
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v19 + 24))(v19 - *(void *)(*(void *)v19 + 56), 96);
          unsigned int v20 = result;
          if (!result)
          {
            int v6 = AVLTree_NrItems(*(void *)(a1 + 184));
            uint64_t v17 = 0;
            if (v6)
            {
              for (unsigned int i = 0; i != v6; ++i)
              {
                int v8 = (const char *)AVLTree_ItemN(*(void *)(a1 + 184), i);
                size_t v9 = cstdlib_strlen(v8);
                uint64_t v10 = v9 + v17 + 1;
                uint64_t v17 = v10;
              }
              uint64_t v11 = v10 + 4;
            }
            else
            {
              uint64_t v11 = 4;
            }
            uint64_t v17 = v11;
            uint64_t v12 = (_DWORD *)OOCAllocator_Malloc(*(void *)(a1 + 176), v11, &v20);
            uint64_t v18 = v12;
            uint64_t result = v20;
            if (!v20)
            {
              _DWORD *v12 = v6;
              if (v6)
              {
                unsigned int v13 = 0;
                unsigned int v14 = (char *)(v12 + 1);
                do
                {
                  uint64_t v15 = (const char *)AVLTree_ItemN(*(void *)(a1 + 184), v13);
                  size_t v16 = cstdlib_strlen(v15) + 1;
                  cstdlib_memcpy(v14, v15, v16);
                  v14 += v16;
                  ++v13;
                }
                while (v6 != v13);
                uint64_t v12 = v18;
              }
              uint64_t result = (*(uint64_t (**)(uint64_t, _DWORD *, uint64_t))(*(void *)v19 + 8))(v19 - *(void *)(*(void *)v19 + 56), v12, v17);
              unsigned int v20 = result;
              if (!result)
              {
                OOCAllocator_Free(*(void *)(a1 + 176), (uint64_t)v18);
                return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 120), v19);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t StringPoolHandlerDynamicAVLTree_CreateFromStreamInterruptible(uint64_t a1, uint64_t a2, int a3, uint64_t *a4, _DWORD *a5)
{
  uint64_t result = _PNEW_StringPoolHandlerDynamicAVLTree_ConInternal(a1, a1, a3, a4);
  if (!result)
  {
    uint64_t result = _StringPoolHandlerDynamicAVLTree_InitInternal(*a4, a2, a5);
    if (!result)
    {
      if (*a5)
      {
        uint64_t v10 = *a4;
        return OOC_PlacementDeleteObject(a1, v10);
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t _PNEW_StringPoolHandlerDynamicAVLTree_ConInternal(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 200, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = _StringPoolHandlerDynamic_Con(v8, a2);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *(void *)uint64_t v8 = &__StringPoolHandlerDynamicAVLTree;
      *(void *)(v8 + 8) = &unk_26D218C48;
      *(_DWORD *)(v8 + 192) = a3;
      *(_DWORD *)(v8 + 196) = 0;
      *(void *)(v8 + 176) = a2;
      *(void *)(v8 + 184) = 0;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t _StringPoolHandlerDynamicAVLTree_InitInternal(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v6 = 0;
    unsigned int v7 = 0;
    uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, _DWORD **, uint64_t *, _DWORD *))(*(void *)a2 + 64))(a2 - *(void *)(*(void *)a2 + 208), *(void *)(a1 + 176), 673589633, 0, 0x10000, &v7, &v6, a3);
    if (result) {
      return result;
    }
    if (*a3) {
      return 0;
    }
    if (v7)
    {
      uint64_t result = __StringPoolHandlerDynamicAVLTree_ReadStrings(a1, v7);
      if (!result)
      {
        OOCAllocator_Free(*(void *)(a1 + 176), (uint64_t)v7);
        return 0;
      }
    }
    else
    {
      return err_GenerateErrorData();
    }
  }
  else
  {
    uint64_t result = PNEW_AVLTree_Con(*(void *)(a1 + 176), *(void *)(a1 + 176), 0xAu, 10, (uint64_t)__StringPoolHandlerDynamicAVLTree_CompareStrings, (uint64_t *)(a1 + 184));
    if (!result) {
      *(_DWORD *)(a1 + 196) = 0;
    }
  }
  return result;
}

void StringPoolHandlerDynamicAVLTree_CreateIteratorHandler(uint64_t a1, void *a2)
{
  if (*(_DWORD *)(a1 + 196))
  {
    uint64_t v5 = 0;
    PNEW_StringPoolIteratorHandlerDynamicAVLTree_Con(*(void *)(a1 + 176), a1, *(void *)(a1 + 176), &v5);
    if (v3) {
      return;
    }
    uint64_t v4 = v5;
  }
  else
  {
    uint64_t v4 = 0;
  }
  *a2 = v4;
}

uint64_t StringPoolHandlerDynamicAVLTree_FetchStringForIterator(uint64_t a1, unsigned int a2, uint64_t *a3)
{
  *a3 = 0;
  unsigned int v4 = *(_DWORD *)(a1 + 192);
  BOOL v5 = a2 >= v4;
  unsigned int v6 = a2 - v4;
  if (v5 && *(_DWORD *)(a1 + 196) + v4 > a2) {
    *a3 = AVLTree_ItemN(*(void *)(a1 + 184), v6);
  }
  return 0;
}

uint64_t StringPoolHandlerDynamicAVLTree_GetKey(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4)
{
  int v8 = 0;
  *a4 = 0;
  *a3 = 0;
  uint64_t result = AVLTree_Find(*(void *)(a1 + 184), a2, &v8, a4);
  if (!result)
  {
    if (*a4) {
      *a3 = (v8 + *(_DWORD *)(a1 + 192));
    }
  }
  return result;
}

uint64_t StringPoolHandlerDynamicAVLTree_GetNbrOfStrings(uint64_t a1)
{
  return *(unsigned int *)(a1 + 196);
}

uint64_t StringPoolHandlerDynamicAVLTree_GetOffsetOfStringIds(uint64_t a1)
{
  return *(unsigned int *)(a1 + 192);
}

uint64_t StringPoolHandlerDynamicAVLTree_GetString(uint64_t a1, uint64_t a2, unint64_t a3, char **a4)
{
  uint64_t result = 0;
  unsigned int v12 = 0;
  *a4 = 0;
  unint64_t v6 = *(unsigned int *)(a1 + 192);
  if (v6 <= a3)
  {
    if ((*(_DWORD *)(a1 + 196) + v6) <= a3)
    {
      return 0;
    }
    else
    {
      size_t v9 = (const char *)AVLTree_ItemN(*(void *)(a1 + 184), (int)a3 - (int)v6);
      size_t v10 = cstdlib_strlen(v9);
      uint64_t v11 = (char *)OOCAllocator_Malloc(a2, v10 + 1, &v12);
      *a4 = v11;
      uint64_t result = v12;
      if (!v12)
      {
        cstdlib_strcpy(v11, v9);
        return v12;
      }
    }
  }
  return result;
}

uint64_t StringPoolHandlerDynamicAVLTree_ReturnStringForIterator()
{
  return 0;
}

uint64_t PNEW_StringPoolHandlerDynamicAVLTree_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5)
{
  unsigned int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 200, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = StringPoolHandlerDynamicAVLTree_Con(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *a5 = v10;
    }
  }
  return result;
}

void *GetStringPoolHandlerDynamicAVLTreeClass()
{
  return &__StringPoolHandlerDynamicAVLTree;
}

uint64_t StringPoolHandlerDynamicPtrList_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result = _StringPoolHandlerDynamic_Con(a1, a2);
  if (!result)
  {
    *(void *)a1 = &__StringPoolHandlerDynamicPtrList;
    *(void *)(a1 + 8) = &unk_26D218CE8;
    *(void *)(a1 + 176) = a2;
    *(_DWORD *)(a1 + 184) = a4;
    *(_DWORD *)(a1 + 188) = 0;
    *(void *)(a1 + 192) = 0;
    if (a3)
    {
      uint64_t v9 = 0;
      uint64_t v10 = 0;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, _DWORD **, uint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), a2, 638938463, 0, 0x10000, &v10, &v9);
      if (!result)
      {
        if (v10)
        {
          uint64_t result = __StringPoolHandlerDynamicPtrList_ReadStrings(a1, v10);
          if (!result)
          {
            OOCAllocator_Free(*(void *)(a1 + 176), (uint64_t)v10);
            return 0;
          }
        }
        else
        {
          return err_GenerateErrorData();
        }
      }
    }
    else
    {
      uint64_t result = PNEW_PtrList_Con(a2, a2, 0xAu, 10, (uint64_t *)(a1 + 192));
      if (!result) {
        *(_DWORD *)(a1 + 188) = 0;
      }
    }
  }
  return result;
}

uint64_t __StringPoolHandlerDynamicPtrList_ReadStrings(uint64_t a1, _DWORD *a2)
{
  if (*a2 == 92)
  {
    uint64_t result = _StringPoolHandlerDynamic_InitializeMD5StateFromArchive(a1, a2 + 1, 0x5CuLL);
    if (!result)
    {
      int v5 = a2[24];
      unsigned int v6 = v5 ? a2[24] : 10;
      uint64_t result = PNEW_PtrList_Con(*(void *)(a1 + 176), *(void *)(a1 + 176), v6, 10, (uint64_t *)(a1 + 192));
      if (!result)
      {
        if (v5)
        {
          unsigned int v7 = (char *)(a2 + 25);
          int v8 = v5;
          while (1)
          {
            uint64_t result = __StringPoolHandlerDynamicPtrList_AddStringToList(a1, *(void *)(a1 + 192), v7);
            if (result) {
              break;
            }
            v7 += cstdlib_strlen(v7) + 1;
            if (!--v8) {
              goto LABEL_11;
            }
          }
        }
        else
        {
LABEL_11:
          uint64_t result = 0;
          *(_DWORD *)(a1 + 188) = v5;
        }
      }
    }
  }
  else
  {
    return err_GenerateErrorData();
  }
  return result;
}

uint64_t _StringPoolHandlerDynamicPtrList_ConInternal(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = _StringPoolHandlerDynamic_Con(a1, a2);
  if (!result)
  {
    *(void *)a1 = &__StringPoolHandlerDynamicPtrList;
    *(void *)(a1 + 8) = &unk_26D218CE8;
    *(void *)(a1 + 176) = a2;
    *(_DWORD *)(a1 + 184) = a3;
    *(_DWORD *)(a1 + 188) = 0;
    *(void *)(a1 + 192) = 0;
  }
  return result;
}

uint64_t StringPoolHandlerDynamicPtrList_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 192);
  if (!v2) {
    goto LABEL_6;
  }
  if (PtrList_NrItems(v2))
  {
    unint64_t v3 = 0;
    do
    {
      uint64_t v4 = *(void *)(a1 + 176);
      uint64_t v5 = PtrList_ItemN(*(void *)(a1 + 192), v3);
      OOCAllocator_Free(v4, v5);
      ++v3;
    }
    while (v3 < PtrList_NrItems(*(void *)(a1 + 192)));
  }
  uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 176), *(void *)(a1 + 192));
  if (!result)
  {
LABEL_6:
    return StringPoolHandlerDynamic_Des(a1);
  }
  return result;
}

uint64_t StringPoolHandlerDynamicPtrList_AddString(uint64_t a1, char *a2, void *a3)
{
  if (PtrList_NrItems(*(void *)(a1 + 192)))
  {
    unsigned int v6 = 0;
    while (1)
    {
      unsigned int v7 = (const char *)PtrList_ItemN(*(void *)(a1 + 192), v6);
      uint64_t result = cstdlib_strcmp(v7, a2);
      if (!result) {
        break;
      }
      if (++v6 >= PtrList_NrItems(*(void *)(a1 + 192))) {
        goto LABEL_5;
      }
    }
    *a3 = *(_DWORD *)(a1 + 184) + v6;
  }
  else
  {
LABEL_5:
    uint64_t result = __StringPoolHandlerDynamicPtrList_AddStringToList(a1, *(void *)(a1 + 192), a2);
    if (!result)
    {
      int v9 = *(_DWORD *)(a1 + 184);
      uint64_t v10 = v9 + PtrList_NrItems(*(void *)(a1 + 192)) - 1;
      *a3 = v10;
      return _StringPoolHandlerDynamic_AddStringToSignature((unsigned int *)a1, a2, v10);
    }
  }
  return result;
}

uint64_t __StringPoolHandlerDynamicPtrList_AddStringToList(uint64_t a1, uint64_t a2, char *__s)
{
  unsigned int v9 = 0;
  size_t v6 = cstdlib_strlen(__s);
  unsigned int v7 = (char *)OOCAllocator_Malloc(*(void *)(a1 + 176), v6 + 1, &v9);
  uint64_t result = v9;
  if (!v9)
  {
    cstdlib_strcpy(v7, __s);
    uint64_t result = PtrList_Append(a2, (uint64_t)v7);
    if (!result) {
      ++*(_DWORD *)(a1 + 188);
    }
  }
  return result;
}

uint64_t StringPoolHandlerDynamicPtrList_Archive(uint64_t a1, uint64_t a2)
{
  uint64_t result = StringPoolHandlerDynamic_Archive(a1);
  if (!result)
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v17 = 0;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 32))(a2 - *(void *)(*(void *)a2 + 120), 638938463, 0x10000, &v19);
    if (!result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, _DWORD **, uint64_t *))(*(void *)v19 + 16))(v19 - *(void *)(*(void *)v19 + 56), &v18, &v17);
      if (!result)
      {
        uint64_t v5 = v18;
        *uint64_t v18 = 92;
        uint64_t result = _StringPoolHandlerDynamic_FillOutMD5StateForArchive(a1, v5 + 1, 0x5CuLL);
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v19 + 24))(v19 - *(void *)(*(void *)v19 + 56), 96);
          unsigned int v20 = result;
          if (!result)
          {
            int v6 = PtrList_NrItems(*(void *)(a1 + 192));
            uint64_t v17 = 0;
            if (v6)
            {
              for (unsigned int i = 0; i != v6; ++i)
              {
                int v8 = (const char *)PtrList_ItemN(*(void *)(a1 + 192), i);
                size_t v9 = cstdlib_strlen(v8);
                uint64_t v10 = v9 + v17 + 1;
                uint64_t v17 = v10;
              }
              uint64_t v11 = v10 + 4;
            }
            else
            {
              uint64_t v11 = 4;
            }
            uint64_t v17 = v11;
            unsigned int v12 = (_DWORD *)OOCAllocator_Malloc(*(void *)(a1 + 176), v11, &v20);
            uint64_t v18 = v12;
            uint64_t result = v20;
            if (!v20)
            {
              _DWORD *v12 = v6;
              if (v6)
              {
                unsigned int v13 = 0;
                unsigned int v14 = (char *)(v12 + 1);
                do
                {
                  uint64_t v15 = (const char *)PtrList_ItemN(*(void *)(a1 + 192), v13);
                  size_t v16 = cstdlib_strlen(v15) + 1;
                  cstdlib_memcpy(v14, v15, v16);
                  v14 += v16;
                  ++v13;
                }
                while (v6 != v13);
                unsigned int v12 = v18;
              }
              uint64_t result = (*(uint64_t (**)(uint64_t, _DWORD *, uint64_t))(*(void *)v19 + 8))(v19 - *(void *)(*(void *)v19 + 56), v12, v17);
              unsigned int v20 = result;
              if (!result)
              {
                OOCAllocator_Free(*(void *)(a1 + 176), (uint64_t)v18);
                return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 120), v19);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t StringPoolHandlerDynamicPtrList_CreateFromStreamInterruptible(uint64_t a1, uint64_t a2, int a3, uint64_t *a4, _DWORD *a5)
{
  uint64_t result = _PNEW_StringPoolHandlerDynamicPtrList_ConInternal(a1, a1, a3, a4);
  if (!result)
  {
    uint64_t result = _StringPoolHandlerDynamicPtrList_InitInternal(*a4, a2, a5);
    if (!result)
    {
      if (*a5)
      {
        uint64_t v10 = *a4;
        return OOC_PlacementDeleteObject(a1, v10);
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t _PNEW_StringPoolHandlerDynamicPtrList_ConInternal(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 200, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = _StringPoolHandlerDynamic_Con(v8, a2);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *(void *)uint64_t v8 = &__StringPoolHandlerDynamicPtrList;
      *(void *)(v8 + 8) = &unk_26D218CE8;
      *(void *)(v8 + 176) = a2;
      *(_DWORD *)(v8 + 184) = a3;
      *(_DWORD *)(v8 + 188) = 0;
      *(void *)(v8 + 192) = 0;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t _StringPoolHandlerDynamicPtrList_InitInternal(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v6 = 0;
    unsigned int v7 = 0;
    uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, _DWORD **, uint64_t *, _DWORD *))(*(void *)a2 + 64))(a2 - *(void *)(*(void *)a2 + 208), *(void *)(a1 + 176), 638938463, 0, 0x10000, &v7, &v6, a3);
    if (result) {
      return result;
    }
    if (*a3) {
      return 0;
    }
    if (v7)
    {
      uint64_t result = __StringPoolHandlerDynamicPtrList_ReadStrings(a1, v7);
      if (!result)
      {
        OOCAllocator_Free(*(void *)(a1 + 176), (uint64_t)v7);
        return 0;
      }
    }
    else
    {
      return err_GenerateErrorData();
    }
  }
  else
  {
    uint64_t result = PNEW_PtrList_Con(*(void *)(a1 + 176), *(void *)(a1 + 176), 0xAu, 10, (uint64_t *)(a1 + 192));
    if (!result) {
      *(_DWORD *)(a1 + 188) = 0;
    }
  }
  return result;
}

void StringPoolHandlerDynamicPtrList_CreateIteratorHandler(uint64_t a1, void *a2)
{
  if (*(_DWORD *)(a1 + 188))
  {
    uint64_t v5 = 0;
    PNEW_StringPoolIteratorHandlerDynamicPtrList_Con(*(void *)(a1 + 176), a1, *(void *)(a1 + 176), &v5);
    if (v3) {
      return;
    }
    uint64_t v4 = v5;
  }
  else
  {
    uint64_t v4 = 0;
  }
  *a2 = v4;
}

uint64_t StringPoolHandlerDynamicPtrList_FetchStringForIterator(uint64_t a1, unsigned int a2, uint64_t *a3)
{
  *a3 = 0;
  unsigned int v4 = *(_DWORD *)(a1 + 184);
  BOOL v5 = a2 >= v4;
  unsigned int v6 = a2 - v4;
  if (v5 && *(_DWORD *)(a1 + 188) + v4 > a2) {
    *a3 = PtrList_ItemN(*(void *)(a1 + 192), v6);
  }
  return 0;
}

uint64_t StringPoolHandlerDynamicPtrList_GetKey(uint64_t a1, const char *a2, void *a3, _DWORD *a4)
{
  *a4 = 0;
  *a3 = 0;
  if (PtrList_NrItems(*(void *)(a1 + 192)))
  {
    unsigned int v8 = 0;
    while (1)
    {
      size_t v9 = (const char *)PtrList_ItemN(*(void *)(a1 + 192), v8);
      if (!cstdlib_strcmp(v9, a2)) {
        break;
      }
      if (++v8 >= PtrList_NrItems(*(void *)(a1 + 192))) {
        return 0;
      }
    }
    *a4 = 1;
    *a3 = *(_DWORD *)(a1 + 184) + v8;
  }
  return 0;
}

uint64_t StringPoolHandlerDynamicPtrList_GetNbrOfStrings(uint64_t a1)
{
  return *(unsigned int *)(a1 + 188);
}

uint64_t StringPoolHandlerDynamicPtrList_GetOffsetOfStringIds(uint64_t a1)
{
  return *(unsigned int *)(a1 + 184);
}

uint64_t StringPoolHandlerDynamicPtrList_GetString(uint64_t a1, uint64_t a2, unint64_t a3, char **a4)
{
  uint64_t result = 0;
  unsigned int v12 = 0;
  *a4 = 0;
  unint64_t v6 = *(unsigned int *)(a1 + 184);
  if (v6 <= a3)
  {
    if ((*(_DWORD *)(a1 + 188) + v6) <= a3)
    {
      return 0;
    }
    else
    {
      size_t v9 = (const char *)PtrList_ItemN(*(void *)(a1 + 192), (int)a3 - (int)v6);
      size_t v10 = cstdlib_strlen(v9);
      uint64_t v11 = (char *)OOCAllocator_Malloc(a2, v10 + 1, &v12);
      *a4 = v11;
      uint64_t result = v12;
      if (!v12)
      {
        cstdlib_strcpy(v11, v9);
        return v12;
      }
    }
  }
  return result;
}

uint64_t StringPoolHandlerDynamicPtrList_ReturnStringForIterator()
{
  return 0;
}

uint64_t PNEW_StringPoolHandlerDynamicPtrList_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5)
{
  unsigned int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 200, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = StringPoolHandlerDynamicPtrList_Con(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *a5 = v10;
    }
  }
  return result;
}

void *GetStringPoolHandlerDynamicPtrListClass()
{
  return &__StringPoolHandlerDynamicPtrList;
}

uint64_t StringPool_Con(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v23 = 0;
  uint64_t result = VoConObject_Con2(a1, a2);
  if (result) {
    return result;
  }
  *a1 = &__StringPool;
  a1[7] = &unk_26D218DE8;
  a1[8] = &unk_26D218E00;
  a1[9] = &unk_26D218E70;
  a1[3] = &unk_26D218DA0;
  uint64_t result = __StringPool_Init((uint64_t)a1, a2);
  if (result) {
    return result;
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a3 + 56))(a3 - *(void *)(*(void *)a3 + 224)) == 638215866)
  {
    unsigned int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 64))(a3 - *(void *)(*(void *)a3 + 224));
    if (BinBlockStreamReader_IsVersionAccepted(v7, 0x10000))
    {
      a1[11] = 0;
      unsigned int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 96))(a3 - *(void *)(*(void *)a3 + 224));
      if (v8)
      {
        uint64_t v9 = 0;
        uint64_t v10 = v8;
        while (1)
        {
          int v22 = 0;
          if ((*(unsigned int (**)(uint64_t, uint64_t, int *))(*(void *)a3 + 104))(a3 - *(void *)(*(void *)a3 + 224), v9, &v22) == 662313442)break; {
          if (v10 == ++v9)
          }
          {
            int v11 = 1;
            goto LABEL_11;
          }
        }
        uint64_t v24 = 0;
        uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a3)(a3 - *(void *)(*(void *)a3 + 224), 662313442, 0, &v24);
        if (result) {
          return result;
        }
        uint64_t result = PNEW_StringPoolHandlerStaticCDSHash_Con(a1[10], a1[10], v24, 1, &v23);
        if (result) {
          return result;
        }
        uint64_t v18 = v23;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3 - *(void *)(*(void *)a3 + 224), v24);
        if (result) {
          return result;
        }
        uint64_t v20 = *(void *)(v18 + 8);
        uint64_t v19 = v18 + 8;
        int v21 = (*(uint64_t (**)(uint64_t))(v20 + 80))(v19 - *(void *)(v20 + 128));
        int v11 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 72))(v19 - *(void *)(*(void *)v19 + 128))
            + v21;
        a1[11] = v19;
LABEL_11:
        uint64_t v12 = 0;
        while (1)
        {
          int v22 = 0;
          int v13 = (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a3 + 104))(a3 - *(void *)(*(void *)a3 + 224), v12, &v22);
          if (v13 == 673589633)
          {
            uint64_t v24 = 0;
            uint64_t v14 = a1[10];
            uint64_t v15 = v14;
            uint64_t v16 = a3;
            goto LABEL_24;
          }
          if (v13 == 638938463) {
            break;
          }
          if (v10 == ++v12) {
            goto LABEL_23;
          }
        }
        uint64_t v24 = 0;
        uint64_t result = PNEW_StringPoolHandlerDynamicPtrList_Con(a1[10], a1[10], a3, v11, &v24);
        if (!result) {
          goto LABEL_25;
        }
      }
      else
      {
        int v11 = 1;
LABEL_23:
        uint64_t v24 = 0;
        uint64_t v14 = a1[10];
        uint64_t v15 = v14;
        uint64_t v16 = 0;
LABEL_24:
        uint64_t result = PNEW_StringPoolHandlerDynamicAVLTree_Con(v14, v15, v16, v11, &v24);
        if (!result)
        {
LABEL_25:
          uint64_t v17 = v24 + 8;
          if (v23)
          {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 120))(v17 - *(void *)(*(void *)v17 + 128), v23 + 16);
            StringPoolHandlerStaticCDSHash_SetNext(v23, v17);
            return 0;
          }
          else
          {
            uint64_t result = 0;
            a1[11] = v17;
          }
        }
      }
    }
    else
    {
      return err_GenerateErrorVersion();
    }
  }
  else
  {
    return err_GenerateErrorData();
  }
  return result;
}

uint64_t __StringPool_Init(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 80) = a2;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 104) = 0;
  uint64_t result = PNEW_PtrList_Con(a2, a2, 0xAu, 10, (uint64_t *)(a1 + 96));
  unsigned int v5 = result;
  if (!result)
  {
    *(_DWORD *)(a1 + 112) = 1;
    unsigned int v4 = (void *)OOCAllocator_Calloc(*(void *)(a1 + 80), 1, 56, &v5);
    *(void *)(a1 + 120) = v4;
    uint64_t result = v5;
    if (!v5)
    {
      *unsigned int v4 = verifySignature;
      v4[1] = addListener;
      _OWORD v4[2] = removeListener;
      v4[3] = addString;
      _OWORD v4[4] = fetchString;
      v4[5] = returnString;
      v4[6] = getKey;
    }
  }
  return result;
}

uint64_t StringPool_ConFromStrings(void *a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t result = VoConObject_Con2(a1, a2);
  if (!result)
  {
    *a1 = &__StringPool;
    a1[7] = &unk_26D218DE8;
    a1[8] = &unk_26D218E00;
    a1[9] = &unk_26D218E70;
    a1[3] = &unk_26D218DA0;
    uint64_t result = __StringPool_Init((uint64_t)a1, a2);
    if (!result)
    {
      uint64_t v10 = 0;
      uint64_t result = PNEW_StringPoolHandlerDynamicAVLTree_Con(a1[10], a1[10], 0, 1, &v10);
      if (!result)
      {
        a1[11] = v10 + 8;
        if (a3 && a4 >= 1)
        {
          uint64_t v9 = &a3[a4];
          do
          {
            uint64_t v10 = 0;
            uint64_t result = (*(uint64_t (**)(void, void, uint64_t *))(*(void *)a1[11] + 24))(a1[11] - *(void *)(*(void *)a1[11] + 128), *a3, &v10);
            if (result) {
              break;
            }
            ++a3;
          }
          while (a3 < v9);
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t _StringPool_ConInternal(void *a1, uint64_t a2)
{
  uint64_t result = VoConObject_Con2(a1, a2);
  if (!result)
  {
    *a1 = &__StringPool;
    a1[7] = &unk_26D218DE8;
    a1[8] = &unk_26D218E00;
    a1[9] = &unk_26D218E70;
    a1[3] = &unk_26D218DA0;
    return __StringPool_Init((uint64_t)a1, a2);
  }
  return result;
}

uint64_t StringPool_Des(uint64_t *a1)
{
  uint64_t result = OOC_PlacementDeleteObject(a1[10], a1[12]);
  if (!result)
  {
    uint64_t result = _StringPool_Cleanup((uint64_t)a1);
    if (!result)
    {
      OOCAllocator_Free(a1[10], a1[15]);
      return VoConObject_Des((uint64_t)a1);
    }
  }
  return result;
}

uint64_t _StringPool_Cleanup(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (!v1) {
    return 0;
  }
  uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 80), v1 - *(void *)(*(void *)v1 + 128));
  if (!result) {
    *(void *)(a1 + 88) = 0;
  }
  return result;
}

uint64_t StringPool_AddListener(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88) - *(void *)(**(void **)(a1 + 88) + 128));
}

uint64_t StringPool_AddString(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v9 = 0;
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, int *))(**(void **)(a1 + 88) + 40))(*(void *)(a1 + 88) - *(void *)(**(void **)(a1 + 88) + 128), a2, a3, &v9);
  if (!(result | v9))
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 88) + 24))(*(void *)(a1 + 88) - *(void *)(**(void **)(a1 + 88) + 128), a2, a3);
    if (!result)
    {
      if (PtrList_NrItems(*(void *)(a1 + 96)))
      {
        unsigned int v7 = 0;
        do
        {
          uint64_t v8 = PtrList_ItemN(*(void *)(a1 + 96), v7);
          StringPoolIterator_StringPoolModified(v8);
          ++v7;
        }
        while (v7 < PtrList_NrItems(*(void *)(a1 + 96)));
      }
      uint64_t result = 0;
      *(_DWORD *)(a1 + 112) = 1;
    }
  }
  return result;
}

uint64_t StringPool_Archive(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 80))(a2 - *(void *)(*(void *)a2 + 120))
    || (uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t, uint64_t))a2)(a2 - *(void *)(*(void *)a2 + 120), 638215866, 0x10000, 2), !result))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    unsigned int v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 8);
    uint64_t v6 = v4 - *(void *)(*(void *)v4 + 128);
    return v5(v6, a2);
  }
  return result;
}

uint64_t StringPool_BorrowInterface(uint64_t a1, void *a2, void *a3)
{
  *a2 = *(void *)(a1 + 120);
  *a3 = a1;
  return 0;
}

uint64_t StringPool_BorrowSignature(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 112)) {
    return *(void *)(a1 + 104);
  }
  uint64_t result = (***(uint64_t (****)(void))(a1 + 88))(*(void *)(a1 + 88) - *(void *)(**(void **)(a1 + 88)
                                                                                              + 128));
  *(void *)(a1 + 104) = result;
  *(_DWORD *)(a1 + 112) = 0;
  return result;
}

void StringPool_CreateFromStreamInterruptible(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  if (!_PNEW_StringPool_ConInternal(a1, a1, a3))
  {
    _StringPool_InitInternal(*a3, a2, a4);
    if (!v7)
    {
      if (*a4)
      {
        if (!(*(unsigned int (**)(uint64_t))(*(void *)*a3 + 32))(*a3)) {
          *a3 = 0;
        }
      }
    }
  }
}

uint64_t _PNEW_StringPool_ConInternal(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = (void *)OOCAllocator_Malloc(a1, 128, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = _StringPool_ConInternal(v6, a2);
    unsigned int v8 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      v6[2] = a1;
      *a3 = v6;
    }
  }
  return result;
}

void _StringPool_InitInternal(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v18 = 0;
  *a3 = 0;
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 80))(a2 - *(void *)(*(void *)a2 + 208)) == 638215866)
  {
    unsigned int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 88))(a2 - *(void *)(*(void *)a2 + 208));
    if (BinBlockStreamReader_IsVersionAccepted(v6, 0x10000))
    {
      *(void *)(a1 + 88) = 0;
      unsigned int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 112))(a2 - *(void *)(*(void *)a2 + 208));
      if (v7)
      {
        uint64_t v8 = 0;
        uint64_t v9 = v7;
        while (1)
        {
          int v17 = 0;
          if ((*(unsigned int (**)(uint64_t, uint64_t, int *))(*(void *)a2 + 120))(a2 - *(void *)(*(void *)a2 + 208), v8, &v17) == 662313442)break; {
          if (v9 == ++v8)
          }
            goto LABEL_7;
        }
        uint64_t v19 = 0;
        if (!(**(unsigned int (***)(uint64_t, uint64_t, void, uint64_t *, _DWORD *))a2)(a2 - *(void *)(*(void *)a2 + 208), 662313442, 0, &v19, a3))
        {
          if (*a3) {
            goto LABEL_7;
          }
          StringPoolHandlerStaticCDSHash_CreateFromStreamInterruptible(*(void *)(a1 + 80), v19, 1, &v18, a3);
          if (!v14
            && (!v19
             || !(*(unsigned int (**)(uint64_t))(*(void *)a2 + 24))(a2 - *(void *)(*(void *)a2 + 208))))
          {
            if (!*a3)
            {
              uint64_t v15 = v18 + 8;
              int v16 = (*(uint64_t (**)(uint64_t))(*(void *)(v18 + 8) + 80))(v18 + 8 - *(void *)(*(void *)(v18 + 8) + 128));
              int v10 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 72))(v15 - *(void *)(*(void *)v15 + 128))
                  + v16;
              *(void *)(a1 + 88) = v15;
              goto LABEL_8;
            }
LABEL_7:
            int v10 = 1;
LABEL_8:
            uint64_t v11 = 0;
            while (1)
            {
              int v17 = 0;
              int v12 = (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a2 + 120))(a2 - *(void *)(*(void *)a2 + 208), v11, &v17);
              if (v12 == 673589633) {
                break;
              }
              if (v12 == 638938463)
              {
                uint64_t v19 = 0;
                if (StringPoolHandlerDynamicPtrList_CreateFromStreamInterruptible(*(void *)(a1 + 80), a2, v10, &v19, a3))return; {
                goto LABEL_14;
                }
              }
LABEL_18:
              if (!*a3 && v9 != ++v11) {
                continue;
              }
              uint64_t v13 = 0;
              goto LABEL_28;
            }
            uint64_t v19 = 0;
            if (StringPoolHandlerDynamicAVLTree_CreateFromStreamInterruptible(*(void *)(a1 + 80), a2, v10, &v19, a3))return; {
LABEL_14:
            }
            if (*a3)
            {
              if (_StringPool_Cleanup(a1)) {
                return;
              }
            }
            else
            {
              uint64_t v13 = v19 + 8;
              if (v19 != -8) {
                goto LABEL_28;
              }
            }
            goto LABEL_18;
          }
        }
      }
      else
      {
        uint64_t v13 = 0;
        int v10 = 1;
LABEL_28:
        if (!*a3)
        {
          if (!v13)
          {
            uint64_t v19 = 0;
            if (PNEW_StringPoolHandlerDynamicAVLTree_Con(*(void *)(a1 + 80), *(void *)(a1 + 80), 0, v10, &v19))return; {
            uint64_t v13 = v19 + 8;
            }
          }
          if (v18)
          {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v13 + 120))(v13 - *(void *)(*(void *)v13 + 128), v18 + 16);
            StringPoolHandlerStaticCDSHash_SetNext(v18, v13);
          }
          else
          {
            *(void *)(a1 + 88) = v13;
          }
        }
      }
    }
    else
    {
      err_GenerateErrorVersion();
    }
  }
  else
  {
    err_GenerateErrorData();
  }
}

uint64_t StringPool_CreateIterator(uint64_t a1, void *a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  uint64_t result = (*(uint64_t (**)(void, uint64_t *))(**(void **)(a1 + 88) + 112))(*(void *)(a1 + 88) - *(void *)(**(void **)(a1 + 88) + 128), &v5);
  if (!result)
  {
    if (v5)
    {
      uint64_t result = PNEW_StringPoolIterator_Con(*(void *)(a1 + 80), *(void *)(a1 + 80), a1 + 64, a1 + 72, v5, &v6);
      if (!result)
      {
        uint64_t result = PtrList_Append(*(void *)(a1 + 96), v6);
        *a2 = v6 + 56;
      }
    }
    else
    {
      return err_GenerateErrorArg();
    }
  }
  return result;
}

uint64_t StringPool_FetchString(uint64_t a1, uint64_t a2, void *a3)
{
  *a3 = 0;
  return (*(uint64_t (**)(void, void, uint64_t))(**(void **)(a1 + 88) + 32))(*(void *)(a1 + 88) - *(void *)(**(void **)(a1 + 88) + 128), *(void *)(a1 + 80), a2);
}

uint64_t StringPool_GetKey(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 40))(*(void *)(a1 + 88) - *(void *)(**(void **)(a1 + 88) + 128));
}

BOOL StringPool_IsClosable(uint64_t a1)
{
  if (PtrList_NrItems(*(void *)(a1 + 96))
    || (*(unsigned int (**)(void))(**(void **)(a1 + 88) + 104))(*(void *)(a1 + 88) - *(void *)(**(void **)(a1 + 88) + 128)))
  {
    return 0;
  }

  return VoConObject_IsClosable(a1);
}

uint64_t StringPool_IsReadyToArchive()
{
  return 1;
}

uint64_t StringPool_QueryInterface(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (a2 == 653755852)
  {
    uint64_t v3 = a1 + 56;
    goto LABEL_5;
  }
  if (a2 == 626109316)
  {
    uint64_t v3 = a1 + 64;
LABEL_5:
    *a3 = v3;
    return 0;
  }
  return VoConObject_QueryInterface(a1, a2, a3);
}

uint64_t StringPool_RemoveAllListeners(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 48))(*(void *)(a1 + 88) - *(void *)(**(void **)(a1 + 88) + 128));
}

uint64_t StringPool_RemoveListener(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 56))(*(void *)(a1 + 88) - *(void *)(**(void **)(a1 + 88) + 128));
}

uint64_t StringPool_RemoveListeningIterator(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = PtrList_Find(*(void *)(a1 + 96), a2, (unsigned int (*)(uint64_t *, uint64_t *))__StringPool_CompareListeningIterators);
  if (v3)
  {
    PtrList_Remove(*(void *)(a1 + 96), v3);
    return 0;
  }
  else
  {
    return err_GenerateErrorArg();
  }
}

BOOL __StringPool_CompareListeningIterators(void *a1, void *a2)
{
  return *a1 != *a2;
}

uint64_t StringPool_ReturnString(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t StringPool_VerifySignature(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *a3 = 0;
  return (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 64))(*(void *)(a1 + 88) - *(void *)(**(void **)(a1 + 88) + 128));
}

uint64_t PNEW_StringPool_Con(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = (void *)OOCAllocator_Malloc(a1, 128, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = StringPool_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      v8[2] = a1;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t PNEW_StringPool_ConFromStrings(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5)
{
  unsigned int v12 = 0;
  unsigned int v10 = (void *)OOCAllocator_Malloc(a1, 128, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = StringPool_ConFromStrings(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      v10[2] = a1;
      *a5 = v10;
    }
  }
  return result;
}

void *GetStringPoolClass()
{
  return &__StringPool;
}

uint64_t verifySignature(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 64))(a1 + 64 - *(void *)(*(void *)(a1 + 64) + 104));
}

uint64_t addListener(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 64) + 8))(a1 + 64 - *(void *)(*(void *)(a1 + 64)
                                                                                               + 104));
}

uint64_t removeListener(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 64) + 16))(a1 + 64 - *(void *)(*(void *)(a1 + 64)
                                                                                                + 104));
}

uint64_t addString(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64 - *(void *)(*(void *)(a1 + 64)
                                                                                                + 104));
}

uint64_t fetchString(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 64) + 40))(a1 + 64 - *(void *)(*(void *)(a1 + 64)
                                                                                                + 104));
}

uint64_t returnString(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 64) + 48))(a1 + 64 - *(void *)(*(void *)(a1 + 64)
                                                                                                + 104));
}

uint64_t getKey(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 64) + 56))(a1 + 64 - *(void *)(*(void *)(a1 + 64)
                                                                                                + 104));
}

uint64_t StringPoolStreamInfo_Con(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = StreamInfo_Con(a1, a2, a3);
  if (!result)
  {
    *a1 = &__StringPoolStreamInfo;
    a1[7] = &unk_26D218EF8;
  }
  return result;
}

uint64_t StringPoolStreamInfo_CheckDependencyString(uint64_t a1, const char *a2, int *a3)
{
  __s2 = 0;
  uint64_t v5 = a1 + 56;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, char **))(*(void *)(a1 + 56) + 136))(a1 + 56 - *(void *)(*(void *)(a1 + 56) + 176), 638215866, &__s2);
  if (!result)
  {
    if (cstdlib_strcmp(a2, __s2)) {
      int v7 = 2;
    }
    else {
      int v7 = 1;
    }
    *a3 = v7;
    return (*(uint64_t (**)(uint64_t, char *))(*(void *)v5 + 144))(v5 - *(void *)(*(void *)v5 + 176), __s2);
  }
  return result;
}

uint64_t StringPoolStreamInfo_FetchDependency(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v18 = 0;
  *a3 = 0;
  uint64_t result = _StreamInfo_BorrowBinBlockStreamReader(a1, &v18);
  unsigned int v19 = result;
  if (!result)
  {
    if ((*(unsigned int (**)(uint64_t))(*(void *)v18 + 56))(v18 - *(void *)(*(void *)v18 + 224)) != a2) {
      return 0;
    }
    uint64_t v16 = 0;
    int v17 = 0;
    uint64_t v7 = *(void *)(a1 + 80);
    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v18 + 32))(v18 - *(void *)(*(void *)v18 + 224), 662313442))
    {
      __src[0] = 0;
      uint64_t v14 = 0;
      size_t __n = 0;
      unsigned int v19 = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))v18)(v18 - *(void *)(*(void *)v18 + 224), 662313442, 0, &v14);
      if (v19) {
        return v19;
      }
      unsigned int v19 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, void **, size_t *))(*(void *)v14 + 48))(v14 - *(void *)(*(void *)v14 + 224), v7, 666710947, 0, 0x10000, __src, &__n);
      if (v19) {
        return v19;
      }
      if (__n != 36) {
        return err_GenerateErrorData();
      }
      uint64_t v8 = (void *)OOCAllocator_Malloc(v7, 36, &v19);
      if (v19) {
        return v19;
      }
      uint64_t v9 = (uint64_t)v8;
      cstdlib_memcpy(v8, __src[0], __n);
      OOCAllocator_Free(v7, (uint64_t)__src[0]);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v18 + 16))(v18 - *(void *)(*(void *)v18 + 224), v14);
      unsigned int v19 = result;
      if (result) {
        return result;
      }
    }
    else
    {
      uint64_t v9 = 0;
    }
    unsigned int v19 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, _DWORD **, uint64_t *))(*(void *)v18 + 48))(v18 - *(void *)(*(void *)v18 + 224), v7, 673589633, 0, 0x10000, &v17, &v16);
    if (!v19)
    {
      if (!v17) {
        goto LABEL_17;
      }
      long long v23 = 0u;
      memset(v24, 0, sizeof(v24));
      long long v21 = 0u;
      long long v22 = 0u;
      *(_OWORD *)int __src = 0u;
      if (*v17 == 92)
      {
        cstdlib_memcpy(__src, v17 + 1, 0x5CuLL);
        if (stringpool_md5_is_initial_state(__src))
        {
          OOCAllocator_Free(v7, (uint64_t)v17);
        }
        else
        {
          unsigned int v12 = (unsigned char *)OOCAllocator_Malloc(v7, 36, &v19);
          if (v19) {
            return v19;
          }
          uint64_t v13 = v12;
          stringpool_md5_finish((unsigned int *)__src, v12);
          OOCAllocator_Free(v7, (uint64_t)v17);
          if (v13)
          {
            *a3 = (uint64_t)v13;
            uint64_t v10 = v7;
            uint64_t v11 = v9;
            goto LABEL_18;
          }
        }
LABEL_17:
        *a3 = v9;
        uint64_t v10 = v7;
        uint64_t v11 = 0;
LABEL_18:
        OOCAllocator_Free(v10, v11);
        return v19;
      }
      return err_GenerateErrorData();
    }
    return v19;
  }
  return result;
}

uint64_t StringPoolStreamInfo_ReturnDependency(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t _StringPoolStreamInfo_GetNbrSections(uint64_t a1, _WORD *a2)
{
  *a2 = 2;
  return 0;
}

uint64_t PNEW_StringPoolStreamInfo_Con(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = (void *)OOCAllocator_Malloc(a1, 104, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = StreamInfo_Con(v8, a2, a3);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *uint64_t v8 = &__StringPoolStreamInfo;
      v8[7] = &unk_26D218EF8;
      v8[2] = a1;
      *a4 = v8;
    }
  }
  return result;
}

void *GetStringPoolStreamInfoClass()
{
  return &__StringPoolStreamInfo;
}

void StringPoolIteratorHandlerDynamicPtrList_Con(void *a1, uint64_t a2, uint64_t a3)
{
  _StringPoolIteratorHandler_Con(a1);
  if (!v6)
  {
    *a1 = &__StringPoolIteratorHandlerDynamicPtrList;
    a1[5] = a2;
    a1[6] = a3;
  }
}

uint64_t StringPoolIteratorHandlerDynamicPtrList_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2 || (uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 48), v2), !result))
  {
    return StringPoolIteratorHandler_Des(a1);
  }
  return result;
}

uint64_t StringPoolIteratorHandlerDynamicPtrList_First(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 36))
  {
    return err_GenerateErrorInconsistent();
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if (*(_DWORD *)(v3 + 188))
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(*(void *)(v3 + 8) + 96))(v3 + 8 - *(void *)(*(void *)(v3 + 8) + 128), *(unsigned int *)(a1 + 16), *(void *)(a1 + 24));
      if (!result)
      {
        uint64_t v4 = *(void *)(a1 + 40);
        uint64_t v5 = *(void *)(v4 + 8);
        v4 += 8;
        *(void *)(a1 + 16) = *(unsigned int *)(v4 + 176);
        uint64_t result = (*(uint64_t (**)(uint64_t))(v5 + 88))(v4 - *(void *)(v5 + 128));
        if (!result) {
          *(_DWORD *)(a1 + 32) = 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t StringPoolIteratorHandlerDynamicPtrList_Next(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 36))
  {
    return err_GenerateErrorInconsistent();
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(*(void *)(*(void *)(a1 + 40) + 8) + 96))(*(void *)(a1 + 40) + 8 - *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 128), *(unsigned int *)(a1 + 16), *(void *)(a1 + 24));
  if (result) {
    return result;
  }
  *(void *)(a1 + 24) = 0;
  if (*(_DWORD *)(a1 + 32))
  {
    uint64_t result = *(void *)(a1 + 8);
    if (!result) {
      return result;
    }
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 32);
LABEL_16:
    return v3();
  }
  unint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(a1 + 40);
  if (v4 >= (*(_DWORD *)(v5 + 184) + *(_DWORD *)(v5 + 188) - 1))
  {
    *(_DWORD *)(a1 + 32) = 1;
    *(void *)(a1 + 16) = 0;
    uint64_t result = *(void *)(a1 + 8);
    if (!result) {
      return result;
    }
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 24);
    goto LABEL_16;
  }
  *(void *)(a1 + 16) = v4 + 1;
  uint64_t v6 = *(void *)(v5 + 8);
  uint64_t v7 = *(uint64_t (**)(uint64_t))(v6 + 88);
  uint64_t v8 = v5 + 8 - *(void *)(v6 + 128);

  return v7(v8);
}

void PNEW_StringPoolIteratorHandlerDynamicPtrList_Con(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v10 = 0;
  uint64_t v8 = (void *)OOCAllocator_Malloc(a1, 56, &v10);
  if (!v10)
  {
    _StringPoolIteratorHandler_Con(v8);
    if (v9)
    {
      int v10 = v9;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
    }
    else
    {
      *uint64_t v8 = &__StringPoolIteratorHandlerDynamicPtrList;
      v8[5] = a2;
      v8[6] = a3;
      *a4 = v8;
    }
  }
}

void *GetStringPoolIteratorHandlerDynamicPtrListClass()
{
  return &__StringPoolIteratorHandlerDynamicPtrList;
}

void StringPoolIteratorHandlerDynamicAVLTree_Con(void *a1, uint64_t a2, uint64_t a3)
{
  _StringPoolIteratorHandler_Con(a1);
  if (!v6)
  {
    *a1 = &__StringPoolIteratorHandlerDynamicAVLTree;
    a1[5] = a2;
    a1[6] = a3;
  }
}

uint64_t StringPoolIteratorHandlerDynamicAVLTree_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2 || (uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 48), v2), !result))
  {
    return StringPoolIteratorHandler_Des(a1);
  }
  return result;
}

uint64_t StringPoolIteratorHandlerDynamicAVLTree_First(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 36))
  {
    return err_GenerateErrorInconsistent();
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if (*(_DWORD *)(v3 + 196))
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(*(void *)(v3 + 8) + 96))(v3 + 8 - *(void *)(*(void *)(v3 + 8) + 128), *(unsigned int *)(a1 + 16), *(void *)(a1 + 24));
      if (!result)
      {
        uint64_t v4 = *(void *)(a1 + 40);
        uint64_t v5 = *(void *)(v4 + 8);
        v4 += 8;
        *(void *)(a1 + 16) = *(unsigned int *)(v4 + 184);
        uint64_t result = (*(uint64_t (**)(uint64_t))(v5 + 88))(v4 - *(void *)(v5 + 128));
        if (!result) {
          *(_DWORD *)(a1 + 32) = 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t StringPoolIteratorHandlerDynamicAVLTree_Next(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 36))
  {
    return err_GenerateErrorInconsistent();
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(*(void *)(*(void *)(a1 + 40) + 8) + 96))(*(void *)(a1 + 40) + 8 - *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 128), *(unsigned int *)(a1 + 16), *(void *)(a1 + 24));
  if (result) {
    return result;
  }
  *(void *)(a1 + 24) = 0;
  if (*(_DWORD *)(a1 + 32))
  {
    uint64_t result = *(void *)(a1 + 8);
    if (!result) {
      return result;
    }
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 32);
LABEL_16:
    return v3();
  }
  unint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(a1 + 40);
  if (v4 >= (*(_DWORD *)(v5 + 192) + *(_DWORD *)(v5 + 196) - 1))
  {
    *(_DWORD *)(a1 + 32) = 1;
    *(void *)(a1 + 16) = 0;
    uint64_t result = *(void *)(a1 + 8);
    if (!result) {
      return result;
    }
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 24);
    goto LABEL_16;
  }
  *(void *)(a1 + 16) = v4 + 1;
  uint64_t v6 = *(void *)(v5 + 8);
  uint64_t v7 = *(uint64_t (**)(uint64_t))(v6 + 88);
  uint64_t v8 = v5 + 8 - *(void *)(v6 + 128);

  return v7(v8);
}

void PNEW_StringPoolIteratorHandlerDynamicAVLTree_Con(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v10 = 0;
  uint64_t v8 = (void *)OOCAllocator_Malloc(a1, 56, &v10);
  if (!v10)
  {
    _StringPoolIteratorHandler_Con(v8);
    if (v9)
    {
      int v10 = v9;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
    }
    else
    {
      *uint64_t v8 = &__StringPoolIteratorHandlerDynamicAVLTree;
      v8[5] = a2;
      v8[6] = a3;
      *a4 = v8;
    }
  }
}

void *GetStringPoolIteratorHandlerDynamicAVLTreeClass()
{
  return &__StringPoolIteratorHandlerDynamicAVLTree;
}

uint64_t StringPoolHandlerStaticCDSHash_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v12 = 0;
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__StringPoolHandlerStaticCDSHash;
    *(void *)(a1 + 8) = &unk_26D2190A8;
    *(void *)(a1 + 16) = &unk_26D219130;
    *(void *)(a1 + 24) = a2;
    *(_DWORD *)(a1 + 80) = a4;
    *(void *)(a1 + 88) = 0;
    if ((*(unsigned int (**)(uint64_t))(*(void *)a3 + 56))(a3 - *(void *)(*(void *)a3 + 224)) == 666722330)
    {
      unsigned int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 64))(a3 - *(void *)(*(void *)a3 + 224));
      if (BinBlockStreamReader_IsVersionAccepted(v9, 0x10000))
      {
        uint64_t v10 = 0;
        int __src = 0;
        uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a3)(a3 - *(void *)(*(void *)a3 + 224), 667399612, 0, &v12);
        if (!result)
        {
          uint64_t result = PNEW_CDSHash_Con(a2, a2, v12, (uint64_t *)(a1 + 32));
          if (!result)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3 - *(void *)(*(void *)a3 + 224), v12);
            if (!result)
            {
              *(_DWORD *)(a1 + 40) = CDSHash_GetNbrKeyEntries(*(void *)(a1 + 32));
              uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, void **, uint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), a2, 666710947, 0, 0x10000, &__src, &v10);
              if (!result)
              {
                if (v10 == 36)
                {
                  cstdlib_memcpy((void *)(a1 + 44), __src, 0x24uLL);
                  OOCAllocator_Free(a2, (uint64_t)__src);
                  return 0;
                }
                else
                {
                  return err_GenerateErrorData();
                }
              }
            }
          }
        }
      }
      else
      {
        return err_GenerateErrorVersion();
      }
    }
    else
    {
      return err_GenerateErrorData();
    }
  }
  return result;
}

uint64_t _StringPoolHandlerStaticCDSHash_ConInternal(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__StringPoolHandlerStaticCDSHash;
    *(void *)(a1 + 8) = &unk_26D2190A8;
    *(void *)(a1 + 16) = &unk_26D219130;
    *(void *)(a1 + 24) = a2;
    *(_DWORD *)(a1 + 80) = a3;
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

uint64_t StringPoolHandlerStaticCDSHash_Des(uint64_t *a1)
{
  uint64_t result = _StringPoolHandlerStaticCDSHash_Cleanup(a1);
  if (!result)
  {
    return Object_Des();
  }
  return result;
}

uint64_t _StringPoolHandlerStaticCDSHash_Cleanup(uint64_t *a1)
{
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 32))(v2);
    if (result) {
      return result;
    }
    a1[4] = 0;
  }
  uint64_t v4 = a1[11];
  if (!v4) {
    return 0;
  }
  uint64_t result = OOC_PlacementDeleteObject(a1[3], v4 - *(void *)(*(void *)v4 + 128));
  if (!result) {
    a1[11] = 0;
  }
  return result;
}

uint64_t StringPoolHandlerStaticCDSHash_AddListener(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 16))(v1 - *(void *)(*(void *)v1 + 128));
  }
  else {
    return 0;
  }
}

uint64_t StringPoolHandlerStaticCDSHash_AddString(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 24))(v1 - *(void *)(*(void *)v1 + 128));
  }
  else {
    return 0;
  }
}

uint64_t StringPoolHandlerStaticCDSHash_Archive(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 16))(a2 - *(void *)(*(void *)a2 + 120), 662313442, 666722330, 0x10000, 6, &v7);
  if (!result)
  {
    uint64_t v6 = 0;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)v7 + 16))(v7 - *(void *)(*(void *)v7 + 120), 667399612, 388438978, 0x10000, 3, &v6);
    if (!result)
    {
      uint64_t result = CDSHash_Archive(*(void *)(a1 + 32), v6);
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 40))(v7 - *(void *)(*(void *)v7 + 120), v6);
        if (!result)
        {
          uint64_t v6 = 0;
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)v7 + 32))(v7 - *(void *)(*(void *)v7 + 120), 666710947, 0x10000, &v6);
          if (!result)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 8))(v6 - *(void *)(*(void *)v6 + 56), a1 + 44, 36);
            if (!result)
            {
              uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 48))(v7 - *(void *)(*(void *)v7 + 120), v6);
              if (!result)
              {
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 120), v7);
                if (!result)
                {
                  uint64_t v5 = *(void *)(a1 + 88);
                  if (v5) {
                    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 8))(v5 - *(void *)(*(void *)v5 + 128), a2);
                  }
                  else {
                    return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t StringPoolHandlerStaticCDSHash_BorrowSignature(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    return (**(uint64_t (***)(uint64_t))v1)(v1 - *(void *)(*(void *)v1 + 128));
  }
  else {
    return a1 + 44;
  }
}

uint64_t StringPoolHandlerStaticCDSHash_BorrowStaticSignature(uint64_t a1)
{
  return a1 + 44;
}

void StringPoolHandlerStaticCDSHash_CreateFromStreamInterruptible(uint64_t a1, uint64_t a2, int a3, uint64_t *a4, _DWORD *a5)
{
  if (!_PNEW_StringPoolHandlerStaticCDSHash_ConInternal(a1, a1, a3, a4))
  {
    _StringPoolHandlerStaticCDSHash_InitInternal(*a4, a2, a5);
    if (!v9)
    {
      if (*a5)
      {
        if (!OOC_PlacementDeleteObject(a1, *a4)) {
          *a4 = 0;
        }
      }
    }
  }
}

uint64_t _PNEW_StringPoolHandlerStaticCDSHash_ConInternal(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 96, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = Object_Con((void *)v8);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *(void *)uint64_t v8 = &__StringPoolHandlerStaticCDSHash;
      *(void *)(v8 + 8) = &unk_26D2190A8;
      *(void *)(v8 + 16) = &unk_26D219130;
      *(void *)(v8 + 24) = a2;
      *(_DWORD *)(v8 + 80) = a3;
      *(void *)(v8 + 88) = 0;
      *(void *)(v8 + 32) = 0;
      *a4 = v8;
    }
  }
  return result;
}

void _StringPoolHandlerStaticCDSHash_InitInternal(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  int __src = 0;
  uint64_t v10 = 0;
  uint64_t v8 = 0;
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 80))(a2 - *(void *)(*(void *)a2 + 208)) == 666722330)
  {
    unsigned int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 88))(a2 - *(void *)(*(void *)a2 + 208));
    if (BinBlockStreamReader_IsVersionAccepted(v6, 0x10000))
    {
      if (!(**(unsigned int (***)(uint64_t, uint64_t, void, uint64_t *, _DWORD *))a2)(a2 - *(void *)(*(void *)a2 + 208), 667399612, 0, &v10, a3))
      {
        if (*a3 || (CDSHash_CreateFromStreamInterruptible(*(void *)(a1 + 24), v10, (uint64_t *)(a1 + 32), a3), !v7))
        {
          if (!v10
            || !(*(unsigned int (**)(uint64_t))(*(void *)a2 + 24))(a2 - *(void *)(*(void *)a2 + 208)))
          {
            if (!*a3)
            {
              *(_DWORD *)(a1 + 40) = CDSHash_GetNbrKeyEntries(*(void *)(a1 + 32));
              if ((*(unsigned int (**)(uint64_t, void, uint64_t, void, uint64_t, void **, uint64_t *, _DWORD *))(*(void *)a2 + 64))(a2 - *(void *)(*(void *)a2 + 208), *(void *)(a1 + 24), 666710947, 0, 0x10000, &__src, &v8, a3))
              {
                return;
              }
              if (!*a3)
              {
                if (v8 != 36 || !__src)
                {
                  err_GenerateErrorData();
                  return;
                }
                cstdlib_memcpy((void *)(a1 + 44), __src, 0x24uLL);
              }
            }
            OOCAllocator_Free(*(void *)(a1 + 24), (uint64_t)__src);
            if (*a3) {
              _StringPoolHandlerStaticCDSHash_Cleanup((uint64_t *)a1);
            }
          }
        }
      }
    }
    else
    {
      err_GenerateErrorVersion();
    }
  }
  else
  {
    err_GenerateErrorData();
  }
}

uint64_t StringPoolHandlerStaticCDSHash_CreateIteratorHandler(uint64_t a1, void *a2)
{
  uint64_t v13 = 0;
  if (*(_DWORD *)(a1 + 40))
  {
    PNEW_StringPoolIteratorHandlerStaticCDSHash_Con(*(void *)(a1 + 24), *(void *)(a1 + 24), a1, &v13);
    uint64_t v5 = v4;
    if (!v4)
    {
      uint64_t v6 = v13;
      *a2 = v13;
      uint64_t v7 = *(void *)(a1 + 88);
      if (v7)
      {
        uint64_t v12 = 0;
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v7 + 112))(v7 - *(void *)(*(void *)v7 + 128), &v12);
        if (!v5) {
          (*(void (**)(void, uint64_t))(*(void *)*a2 + 40))(*a2, v12);
        }
      }
      else
      {
        (*(void (**)(uint64_t, void))(*(void *)v6 + 40))(v6, 0);
        return 0;
      }
    }
    return v5;
  }
  uint64_t v8 = *(void *)(a1 + 88);
  if (!v8)
  {
    uint64_t v5 = 0;
    *a2 = 0;
    return v5;
  }
  int v9 = *(uint64_t (**)(uint64_t))(*(void *)v8 + 112);
  uint64_t v10 = v8 - *(void *)(*(void *)v8 + 128);

  return v9(v10);
}

uint64_t StringPoolHandlerStaticCDSHash_FetchStringForIterator(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8 - *(void *)(*(void *)(a1 + 8) + 128), *(void *)(a1 + 24), a2, a3);
}

uint64_t StringPoolHandlerStaticCDSHash_GetKey(uint64_t a1, char *a2, void *a3, _DWORD *a4)
{
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  unint64_t v10 = 0;
  *a3 = (*(_DWORD *)(a1 + 80) - 1);
  *a4 = 0;
  uint64_t result = utf8_str_to_utf16(*(void *)(a1 + 24), a2, &v11, &v10);
  if (!result)
  {
    uint64_t result = CDSHash_GetInputHash(*(void *)(a1 + 32), v11, 0, (int *)&v12, (unsigned int *)&v12 + 1);
    if (!result)
    {
      OOCAllocator_Free(*(void *)(a1 + 24), v11);
      if (HIDWORD(v12))
      {
        uint64_t result = 0;
        *a3 = (*(_DWORD *)(a1 + 80) + v12);
        *a4 = 1;
      }
      else
      {
        uint64_t v9 = *(void *)(a1 + 88);
        if (v9) {
          return (*(uint64_t (**)(uint64_t, char *, void *, _DWORD *))(*(void *)v9 + 40))(v9 - *(void *)(*(void *)v9 + 128), a2, a3, a4);
        }
        else {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t StringPoolHandlerStaticCDSHash_GetNbrOfStrings(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t StringPoolHandlerStaticCDSHash_GetOffsetOfStringIds(uint64_t a1)
{
  return *(unsigned int *)(a1 + 80);
}

uint64_t StringPoolHandlerStaticCDSHash_GetString(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4)
{
  unsigned int v16 = 0;
  unint64_t v7 = *(unsigned int *)(a1 + 80);
  *a4 = 0;
  if (v7 > a3 || (*(_DWORD *)(a1 + 40) + v7) <= a3)
  {
    uint64_t v12 = *(void *)(a1 + 88);
    if (v12)
    {
      uint64_t v13 = *(uint64_t (**)(uint64_t))(*(void *)v12 + 32);
      uint64_t v14 = v12 - *(void *)(*(void *)v12 + 128);
      return v13(v14);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    unsigned int v8 = CDSHash_UnhashKey(*(void *)(a1 + 32));
    if (v8)
    {
      unsigned int v9 = v8;
      unint64_t v10 = (unsigned __int16 *)OOCAllocator_Calloc(a2, v8 + 1, 2, &v16);
      uint64_t result = v16;
      if (!v16)
      {
        CDSHash_UnhashKey(*(void *)(a1 + 32));
        CDSHash_DecodeKey(*(void *)(a1 + 32), v9 + 1, (uint64_t)v10);
        unint64_t v15 = 0;
        uint64_t result = utf16_str_to_utf8(a2, v10, a4, &v15);
        unsigned int v16 = result;
        if (!result)
        {
          OOCAllocator_Free(a2, (uint64_t)v10);
          return v16;
        }
      }
    }
    else
    {
      return err_GenerateErrorInconsistent();
    }
  }
  return result;
}

uint64_t StringPoolHandlerStaticCDSHash_HasListener(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 104))(v1 - *(void *)(*(void *)v1 + 128));
  }
  else {
    return 0;
  }
}

uint64_t StringPoolHandlerStaticCDSHash_RemoveAllListeners(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 48))(v1 - *(void *)(*(void *)v1 + 128));
  }
  else {
    return 0;
  }
}

uint64_t StringPoolHandlerStaticCDSHash_RemoveListener(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 56))(v1 - *(void *)(*(void *)v1 + 128));
  }
  else {
    return 0;
  }
}

uint64_t StringPoolHandlerStaticCDSHash_ReturnStringForIterator(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(a1 + 80);
  if (v3 <= a2 && *(_DWORD *)(a1 + 40) + v3 > a2)
  {
    OOCAllocator_Free(*(void *)(a1 + 24), a3);
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 88);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = *(uint64_t (**)(uint64_t))(*(void *)v4 + 96);
  uint64_t v6 = v4 - *(void *)(*(void *)v4 + 128);

  return v5(v6);
}

uint64_t StringPoolHandlerStaticCDSHash_SetNext(uint64_t result, uint64_t a2)
{
  *(void *)(result + 88) = a2;
  return result;
}

uint64_t StringPoolHandlerStaticCDSHash_VerifySignature(uint64_t a1, const char *a2, _DWORD *a3)
{
  if (!cstdlib_strcmp((const char *)(a1 + 44), a2))
  {
    *a3 = 1;
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 88);
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(uint64_t (**)(uint64_t, const char *, _DWORD *))(*(void *)v6 + 64);
  uint64_t v8 = v6 - *(void *)(*(void *)v6 + 128);

  return v7(v8, a2, a3);
}

uint64_t PNEW_StringPoolHandlerStaticCDSHash_Con(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5)
{
  unsigned int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 96, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = StringPoolHandlerStaticCDSHash_Con(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *a5 = v10;
    }
  }
  return result;
}

void *GetStringPoolHandlerStaticCDSHashClass()
{
  return &__StringPoolHandlerStaticCDSHash;
}

double stringpool_md5_init(_OWORD *a1)
{
  cstdlib_memset(a1, 0, 0x5CuLL);
  *a1 = xmmword_22078B3D0;
  double result = 1.18065836e-230;
  *((void *)a1 + 2) = 0x1032547698BADCFELL;
  *((_DWORD *)a1 + 22) = 0;
  return result;
}

BOOL stringpool_md5_is_initial_state(_DWORD *a1)
{
  return !*a1 && !a1[1] && a1[2] == 1732584193 && a1[3] == -271733879 && a1[4] == -1732584194 && a1[5] == 271733878;
}

unsigned int *stringpool_md5_append(unsigned int *result, int *__src, uint64_t a3)
{
  if (a3 < 1) {
    return result;
  }
  uint64_t v3 = a3;
  uint64_t v4 = __src;
  uint64_t v5 = result;
  unint64_t v6 = *result;
  uint64_t v7 = (v6 >> 3) & 0x3F;
  unsigned int v8 = result[1] + ((unint64_t)a3 >> 29);
  *double result = v6 + 8 * a3;
  result[1] = v8;
  if (__CFADD__(v6, 8 * a3)) {
    result[1] = v8 + 1;
  }
  if (v7)
  {
    if ((unint64_t)(v7 + a3) <= 0x40) {
      unsigned int v9 = a3;
    }
    else {
      unsigned int v9 = 64 - v7;
    }
    double result = (unsigned int *)cstdlib_memcpy((char *)result + v7 + 24, __src, v9);
    if (v7 + (int)v9 < 64) {
      return result;
    }
    uint64_t v4 = (int *)((char *)v4 + (int)v9);
    v3 -= (int)v9;
    double result = (unsigned int *)stringpool_md5_process(v5, v5 + 6);
  }
  if (v3 < 64)
  {
    LODWORD(v10) = v3;
    if (!v3) {
      return result;
    }
    goto LABEL_14;
  }
  do
  {
    double result = (unsigned int *)stringpool_md5_process(v5, v4);
    v4 += 16;
    uint64_t v10 = v3 - 64;
    BOOL v11 = (unint64_t)v3 > 0x7F;
    v3 -= 64;
  }
  while (v11);
  if (v10)
  {
LABEL_14:
    return (unsigned int *)cstdlib_memcpy(v5 + 6, v4, v10);
  }
  return result;
}

uint64_t stringpool_md5_process(_DWORD *a1, int *a2)
{
  uint64_t v90 = *MEMORY[0x263EF8340];
  int v4 = a1[2];
  int v3 = a1[3];
  int v5 = a1[4];
  int v6 = a1[5];
  if ((a2 & 3) != 0)
  {
    cstdlib_memcpy(__dst, a2, 0x40uLL);
    a2 = (int *)__dst;
  }
  int v8 = *a2;
  int v7 = a2[1];
  HIDWORD(v9) = v4 + (v5 & v3) + (v6 & ~v3) + *a2 - 680876936;
  LODWORD(v9) = HIDWORD(v9);
  int v10 = (v9 >> 25) + v3;
  HIDWORD(v9) = v6 + v7 + (v5 & ~v10) + (v10 & v3) - 389564586;
  LODWORD(v9) = HIDWORD(v9);
  int v11 = (v9 >> 20) + v10;
  int v12 = a2[2];
  int v13 = a2[3];
  HIDWORD(v9) = v5 + v12 + (v3 & ~v11) + (v11 & v10) + 606105819;
  LODWORD(v9) = HIDWORD(v9);
  int v14 = (v9 >> 15) + v11;
  HIDWORD(v9) = v3 + v13 + (v10 & ~v14) + (v14 & v11) - 1044525330;
  LODWORD(v9) = HIDWORD(v9);
  int v15 = (v9 >> 10) + v14;
  int v16 = a2[4];
  int v17 = a2[5];
  HIDWORD(v9) = v10 + v16 + (v11 & ~v15) + (v15 & v14) - 176418897;
  LODWORD(v9) = HIDWORD(v9);
  int v18 = (v9 >> 25) + v15;
  HIDWORD(v9) = v17 + v11 + (v14 & ~v18) + (v18 & v15) + 1200080426;
  LODWORD(v9) = HIDWORD(v9);
  int v19 = (v9 >> 20) + v18;
  int v21 = a2[6];
  int v20 = a2[7];
  HIDWORD(v9) = v21 + v14 + (v15 & ~v19) + (v19 & v18) - 1473231341;
  LODWORD(v9) = HIDWORD(v9);
  int v22 = (v9 >> 15) + v19;
  HIDWORD(v9) = v20 + v15 + (v18 & ~v22) + (v22 & v19) - 45705983;
  LODWORD(v9) = HIDWORD(v9);
  int v23 = (v9 >> 10) + v22;
  int v25 = a2[8];
  int v24 = a2[9];
  HIDWORD(v9) = v25 + v18 + (v19 & ~v23) + (v23 & v22) + 1770035416;
  LODWORD(v9) = HIDWORD(v9);
  int v26 = (v9 >> 25) + v23;
  HIDWORD(v9) = v24 + v19 + (v22 & ~v26) + (v26 & v23) - 1958414417;
  LODWORD(v9) = HIDWORD(v9);
  int v27 = (v9 >> 20) + v26;
  int v28 = a2[10];
  int v29 = a2[11];
  HIDWORD(v9) = v28 + v22 + (v23 & ~v27) + (v27 & v26) - 42063;
  LODWORD(v9) = HIDWORD(v9);
  int v30 = (v9 >> 15) + v27;
  HIDWORD(v9) = v29 + v23 + (v26 & ~v30) + (v30 & v27) - 1990404162;
  LODWORD(v9) = HIDWORD(v9);
  int v31 = (v9 >> 10) + v30;
  int v33 = a2[12];
  uint64_t result = a2[13];
  HIDWORD(v9) = v33 + v26 + (v27 & ~v31) + (v31 & v30) + 1804603682;
  LODWORD(v9) = HIDWORD(v9);
  int v34 = (v9 >> 25) + v31;
  HIDWORD(v9) = result + v27 + (v30 & ~v34) + (v34 & v31) - 40341101;
  LODWORD(v9) = HIDWORD(v9);
  int v35 = (v9 >> 20) + v34;
  int v37 = a2[14];
  int v36 = a2[15];
  HIDWORD(v9) = v37 + v30 + (v31 & ~v35) + (v35 & v34) - 1502002290;
  LODWORD(v9) = HIDWORD(v9);
  int v38 = (v9 >> 15) + v35;
  HIDWORD(v9) = v36 + v31 + (v34 & ~v38) + (v38 & v35) + 1236535329;
  LODWORD(v9) = HIDWORD(v9);
  int v39 = (v9 >> 10) + v38;
  HIDWORD(v9) = v7 + v34 + (v38 & ~v35) - 165796510 + (v39 & v35);
  LODWORD(v9) = HIDWORD(v9);
  int v40 = (v9 >> 27) + v39;
  HIDWORD(v9) = v21 + v35 + (v39 & ~v38) - 1069501632 + (v40 & v38);
  LODWORD(v9) = HIDWORD(v9);
  int v41 = (v9 >> 23) + v40;
  HIDWORD(v9) = v29 + v38 + (v40 & ~v39) + 643717713 + (v41 & v39);
  LODWORD(v9) = HIDWORD(v9);
  int v42 = (v9 >> 18) + v41;
  HIDWORD(v9) = v8 + v39 + (v41 & ~v40) - 373897302 + (v42 & v40);
  LODWORD(v9) = HIDWORD(v9);
  int v43 = (v9 >> 12) + v42;
  HIDWORD(v9) = v17 + v40 + (v42 & ~v41) - 701558691 + (v43 & v41);
  LODWORD(v9) = HIDWORD(v9);
  int v44 = (v9 >> 27) + v43;
  HIDWORD(v9) = v28 + v41 + (v43 & ~v42) + 38016083 + (v44 & v42);
  LODWORD(v9) = HIDWORD(v9);
  int v45 = (v9 >> 23) + v44;
  HIDWORD(v9) = v36 + v42 + (v44 & ~v43) - 660478335 + (v45 & v43);
  LODWORD(v9) = HIDWORD(v9);
  int v46 = (v9 >> 18) + v45;
  HIDWORD(v9) = v16 + v43 + (v45 & ~v44) - 405537848 + (v46 & v44);
  LODWORD(v9) = HIDWORD(v9);
  int v47 = (v9 >> 12) + v46;
  HIDWORD(v9) = v24 + v44 + (v46 & ~v45) + 568446438 + (v47 & v45);
  LODWORD(v9) = HIDWORD(v9);
  int v48 = (v9 >> 27) + v47;
  HIDWORD(v9) = v37 + v45 + (v47 & ~v46) - 1019803690 + (v48 & v46);
  LODWORD(v9) = HIDWORD(v9);
  int v49 = (v9 >> 23) + v48;
  HIDWORD(v9) = v13 + v46 + (v48 & ~v47) - 187363961 + (v49 & v47);
  LODWORD(v9) = HIDWORD(v9);
  int v50 = (v9 >> 18) + v49;
  HIDWORD(v9) = v25 + v47 + (v49 & ~v48) + 1163531501 + (v50 & v48);
  LODWORD(v9) = HIDWORD(v9);
  int v51 = (v9 >> 12) + v50;
  HIDWORD(v9) = result + v48 + (v50 & ~v49) - 1444681467 + (v51 & v49);
  LODWORD(v9) = HIDWORD(v9);
  int v52 = (v9 >> 27) + v51;
  HIDWORD(v9) = v12 + v49 + (v51 & ~v50) - 51403784 + (v52 & v50);
  LODWORD(v9) = HIDWORD(v9);
  int v53 = (v9 >> 23) + v52;
  HIDWORD(v9) = v20 + v50 + (v52 & ~v51) + 1735328473 + (v53 & v51);
  LODWORD(v9) = HIDWORD(v9);
  int v54 = (v9 >> 18) + v53;
  HIDWORD(v9) = v33 + v51 + (v53 & ~v52) - 1926607734 + (v54 & v52);
  LODWORD(v9) = HIDWORD(v9);
  int v55 = (v9 >> 12) + v54;
  HIDWORD(v9) = v17 + v52 - 378558 + (v55 ^ v54 ^ v53);
  LODWORD(v9) = HIDWORD(v9);
  int v56 = (v9 >> 28) + v55;
  HIDWORD(v9) = v25 + v53 - 2022574463 + (v55 ^ v54 ^ v56);
  LODWORD(v9) = HIDWORD(v9);
  int v57 = (v9 >> 21) + v56;
  HIDWORD(v9) = v29 + v54 + 1839030562 + (v56 ^ v55 ^ v57);
  LODWORD(v9) = HIDWORD(v9);
  int v58 = (v9 >> 16) + v57;
  HIDWORD(v9) = v37 + v55 - 35309556 + (v57 ^ v56 ^ v58);
  LODWORD(v9) = HIDWORD(v9);
  int v59 = (v9 >> 9) + v58;
  HIDWORD(v9) = v7 + v56 - 1530992060 + (v58 ^ v57 ^ v59);
  LODWORD(v9) = HIDWORD(v9);
  int v60 = (v9 >> 28) + v59;
  HIDWORD(v9) = v16 + v57 + 1272893353 + (v59 ^ v58 ^ v60);
  LODWORD(v9) = HIDWORD(v9);
  int v61 = (v9 >> 21) + v60;
  HIDWORD(v9) = v20 + v58 - 155497632 + (v60 ^ v59 ^ v61);
  LODWORD(v9) = HIDWORD(v9);
  int v62 = (v9 >> 16) + v61;
  HIDWORD(v9) = v28 + v59 - 1094730640 + (v61 ^ v60 ^ v62);
  LODWORD(v9) = HIDWORD(v9);
  int v63 = (v9 >> 9) + v62;
  HIDWORD(v9) = result + v60 + 681279174 + (v62 ^ v61 ^ v63);
  LODWORD(v9) = HIDWORD(v9);
  int v64 = (v9 >> 28) + v63;
  HIDWORD(v9) = v8 + v61 - 358537222 + (v63 ^ v62 ^ v64);
  LODWORD(v9) = HIDWORD(v9);
  int v65 = (v9 >> 21) + v64;
  HIDWORD(v9) = v13 + v62 - 722521979 + (v64 ^ v63 ^ v65);
  LODWORD(v9) = HIDWORD(v9);
  int v66 = (v9 >> 16) + v65;
  HIDWORD(v9) = v21 + v63 + 76029189 + (v65 ^ v64 ^ v66);
  LODWORD(v9) = HIDWORD(v9);
  int v67 = (v9 >> 9) + v66;
  HIDWORD(v9) = v24 + v64 - 640364487 + (v66 ^ v65 ^ v67);
  LODWORD(v9) = HIDWORD(v9);
  int v68 = (v9 >> 28) + v67;
  HIDWORD(v9) = v33 + v65 - 421815835 + (v67 ^ v66 ^ v68);
  LODWORD(v9) = HIDWORD(v9);
  int v69 = (v9 >> 21) + v68;
  HIDWORD(v9) = v36 + v66 + 530742520 + (v68 ^ v67 ^ v69);
  LODWORD(v9) = HIDWORD(v9);
  int v70 = (v9 >> 16) + v69;
  HIDWORD(v9) = v12 + v67 - 995338651 + (v69 ^ v68 ^ v70);
  LODWORD(v9) = HIDWORD(v9);
  int v71 = (v9 >> 9) + v70;
  HIDWORD(v9) = v8 + v68 - 198630844 + ((v71 | ~v69) ^ v70);
  LODWORD(v9) = HIDWORD(v9);
  int v72 = (v9 >> 26) + v71;
  HIDWORD(v9) = v20 + v69 + 1126891415 + ((v72 | ~v70) ^ v71);
  LODWORD(v9) = HIDWORD(v9);
  int v73 = (v9 >> 22) + v72;
  HIDWORD(v9) = v37 + v70 - 1416354905 + ((v73 | ~v71) ^ v72);
  LODWORD(v9) = HIDWORD(v9);
  int v74 = (v9 >> 17) + v73;
  HIDWORD(v9) = v17 + v71 - 57434055 + ((v74 | ~v72) ^ v73);
  LODWORD(v9) = HIDWORD(v9);
  int v75 = (v9 >> 11) + v74;
  HIDWORD(v9) = v33 + v72 + 1700485571 + ((v75 | ~v73) ^ v74);
  LODWORD(v9) = HIDWORD(v9);
  int v76 = (v9 >> 26) + v75;
  HIDWORD(v9) = v13 + v73 - 1894986606 + ((v76 | ~v74) ^ v75);
  LODWORD(v9) = HIDWORD(v9);
  int v77 = (v9 >> 22) + v76;
  HIDWORD(v9) = v28 + v74 - 1051523 + ((v77 | ~v75) ^ v76);
  LODWORD(v9) = HIDWORD(v9);
  int v78 = (v9 >> 17) + v77;
  HIDWORD(v9) = v7 + v75 - 2054922799 + ((v78 | ~v76) ^ v77);
  LODWORD(v9) = HIDWORD(v9);
  int v79 = (v9 >> 11) + v78;
  HIDWORD(v9) = v25 + v76 + 1873313359 + ((v79 | ~v77) ^ v78);
  LODWORD(v9) = HIDWORD(v9);
  int v80 = (v9 >> 26) + v79;
  HIDWORD(v9) = v36 + v77 - 30611744 + ((v80 | ~v78) ^ v79);
  LODWORD(v9) = HIDWORD(v9);
  int v81 = (v9 >> 22) + v80;
  HIDWORD(v9) = v21 + v78 - 1560198380 + ((v81 | ~v79) ^ v80);
  LODWORD(v9) = HIDWORD(v9);
  int v82 = (v9 >> 17) + v81;
  HIDWORD(v9) = result + v79 + 1309151649 + ((v82 | ~v80) ^ v81);
  LODWORD(v9) = HIDWORD(v9);
  int v83 = (v9 >> 11) + v82;
  HIDWORD(v9) = v16 + v80 - 145523070 + ((v83 | ~v81) ^ v82);
  LODWORD(v9) = HIDWORD(v9);
  int v84 = (v9 >> 26) + v83;
  HIDWORD(v9) = v29 + v81 - 1120210379 + ((v84 | ~v82) ^ v83);
  LODWORD(v9) = HIDWORD(v9);
  int v85 = (v9 >> 22) + v84;
  HIDWORD(v9) = v12 + v82 + 718787259 + ((v85 | ~v83) ^ v84);
  LODWORD(v9) = HIDWORD(v9);
  int v86 = (v9 >> 17) + v85;
  HIDWORD(v9) = v24 + v83 - 343485551 + ((v86 | ~v84) ^ v85);
  LODWORD(v9) = HIDWORD(v9);
  int v87 = v86 + a1[3];
  a1[2] += v84;
  a1[3] = v87 + (v9 >> 11);
  int v88 = a1[5];
  a1[4] += v86;
  a1[5] = v85 + v88;
  return result;
}

unsigned int *stringpool_md5_finish(unsigned int *a1, unsigned char *a2)
{
  uint64_t v2 = a2;
  char v4 = 0;
  uint64_t v5 = 0;
  uint64_t v21 = *MEMORY[0x263EF8340];
  int64x2_t v6 = (int64x2_t)xmmword_220774290;
  unsigned int v7 = a1[22];
  uint64x2_t v8 = (uint64x2_t)vdupq_n_s64(8uLL);
  int64x2_t v9 = vdupq_n_s64(2uLL);
  do
  {
    uint64_t v10 = v5 >> 2;
    if (vmovn_s64((int64x2_t)vcgtq_u64(v8, (uint64x2_t)v6)).u8[0]) {
      *((unsigned char *)__src + v5) = a1[v10] >> (v4 & 0x10);
    }
    if (vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(8uLL), *(uint64x2_t *)&v6)).i32[1]) {
      *((unsigned char *)__src + v5 + 1) = a1[v10] >> (v4 & 0x10 | 8);
    }
    v5 += 2;
    int64x2_t v6 = vaddq_s64(v6, v9);
    v4 += 16;
  }
  while (v5 != 8);
  if (v7) {
    int v11 = (uint64_t *)a2;
  }
  else {
    int v11 = &v19;
  }
  stringpool_md5_append(a1, stringpool_md5_finish_pad, ((55 - (*a1 >> 3)) & 0x3Fu) + 1);
  uint64_t result = stringpool_md5_append(a1, __src, 8);
  int v13 = 0;
  for (uint64_t i = 0; i != 16; ++i)
  {
    *((unsigned char *)v11 + i) = *(unsigned int *)((char *)a1 + (i & 0xFFFFFFFC) + 8) >> (v13 & 0x18);
    v13 += 8;
  }
  if (!a1[22])
  {
    for (uint64_t j = 0; j != 16; ++j)
    {
      if (*((unsigned __int8 *)v11 + j) >= 0xA0u) {
        char v16 = (*((unsigned char *)v11 + j) >> 4) + 55;
      }
      else {
        char v16 = (*((unsigned char *)v11 + j) >> 4) | 0x30;
      }
      *uint64_t v2 = v16;
      unsigned int v17 = *((unsigned char *)v11 + j) & 0xF;
      char v18 = v17 + 55;
      if (v17 < 0xA) {
        char v18 = *((unsigned char *)v11 + j) & 0xF | 0x30;
      }
      v2[1] = v18;
      v2 += 2;
    }
    *(_DWORD *)uint64_t v2 = 0;
  }
  return result;
}

uint64_t stringpool_md5_set_mode_text(uint64_t result)
{
  *(_DWORD *)(result + 88) = 0;
  return result;
}

uint64_t stringpool_md5_set_mode_binary(uint64_t result)
{
  *(_DWORD *)(result + 88) = 1;
  return result;
}

uint64_t stringpool_md5_get_size(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 88)) {
    return 16;
  }
  else {
    return 36;
  }
}

uint64_t XPBufferWriter_Con(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = Object_Con((void *)a1);
  if (!v4)
  {
    *(void *)a1 = &__XPBufferWriter;
    *(void *)(a1 + 64) = a2;
    int ByteOrder = Platform_GetByteOrder();
    *(_DWORD *)(a1 + 48) = 0;
    *(_DWORD *)(a1 + 52) = ByteOrder;
    *(_OWORD *)(a1 + 8) = 0u;
    *(_OWORD *)(a1 + 24) = 0u;
    *(void *)(a1 + 40) = 1;
    *(unsigned char *)(a1 + 56) = 0;
  }
  return v4;
}

uint64_t XPBufferWriter_Des(uint64_t a1)
{
  uint64_t v2 = (_OWORD *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1)
  {
    OOCAllocator_Free(*(void *)(a1 + 64), v1);
    *uint64_t v2 = 0u;
    v2[1] = 0u;
  }

  return Object_Des();
}

uint64_t XPBufferWriter_ClearBuffer(uint64_t a1)
{
  uint64_t v2 = (_OWORD *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1)
  {
    OOCAllocator_Free(*(void *)(a1 + 64), v1);
    *uint64_t v2 = 0u;
    v2[1] = 0u;
  }
  return 0;
}

uint64_t XPBufferWriter_GetBuffer(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  return v1;
}

uint64_t XPBufferWriter_NextWriteAlignment(uint64_t a1, unint64_t a2)
{
  while (*(void *)(a1 + 24) % a2)
  {
    uint64_t result = XPBufferWriter_WriteU8((uint64_t *)a1, *(unsigned char *)(a1 + 56));
    if (result) {
      return result;
    }
  }
  return 0;
}

uint64_t XPBufferWriter_WriteU8(uint64_t *a1, char a2)
{
  char __src = a2;
  uint64_t v3 = _XPBufferWriter_ReallocBuffer(a1, 1uLL);
  if (!v3)
  {
    cstdlib_memcpy((void *)(a1[1] + a1[3]), &__src, 1uLL);
    unint64_t v4 = a1[3] + 1;
    if (v4 > a1[2]) {
      a1[2] = v4;
    }
    a1[3] = v4;
  }
  return v3;
}

uint64_t XPBufferWriter_ReserveBufferSize(uint64_t *a1, unint64_t a2)
{
  uint64_t result = 0;
  unsigned int v6 = 0;
  if (a1[4] < a2)
  {
    uint64_t v5 = OOCAllocator_Realloc(a1[8], a1[1], a2, &v6);
    a1[1] = v5;
    uint64_t result = v6;
    if (!v6)
    {
      if (v5)
      {
        uint64_t result = 0;
        a1[4] += a2;
      }
      else
      {
        return err_GenerateErrorResource();
      }
    }
  }
  return result;
}

uint64_t XPBufferWriter_SeekBuffer(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) < a2) {
    return err_GenerateErrorArg();
  }
  *(void *)(a1 + 24) = a2;
  return 0;
}

uint64_t XPBufferWriter_SetReallocSize(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = a2;
  return result;
}

uint64_t XPBufferWriter_WriteBuffer(uint64_t *a1, const void *a2, unint64_t a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t result = _XPBufferWriter_ReallocBuffer(a1, a3);
  if (!result)
  {
    cstdlib_memcpy((void *)(a1[1] + a1[3]), a2, a3);
    unint64_t v7 = a1[3] + a3;
    if (v7 > a1[2]) {
      a1[2] = v7;
    }
    uint64_t result = 0;
    a1[3] = v7;
  }
  return result;
}

uint64_t _XPBufferWriter_ReallocBuffer(uint64_t *a1, unint64_t a2)
{
  uint64_t result = 0;
  unsigned int v6 = 0;
  uint64_t v4 = a1[4];
  if (v4 - a1[2] < a2)
  {
    if (a1[5] <= a2) {
      uint64_t v5 = a2;
    }
    else {
      uint64_t v5 = a1[5];
    }
    a1[1] = OOCAllocator_Realloc(a1[8], a1[1], v5 + v4, &v6);
    uint64_t result = v6;
    if (!v6) {
      a1[4] += v5;
    }
  }
  return result;
}

uint64_t XPBufferWriter_WriteChar(uint64_t *a1, char a2)
{
  char __src = a2;
  uint64_t v3 = _XPBufferWriter_ReallocBuffer(a1, 1uLL);
  if (!v3)
  {
    cstdlib_memcpy((void *)(a1[1] + a1[3]), &__src, 1uLL);
    unint64_t v4 = a1[3] + 1;
    if (v4 > a1[2]) {
      a1[2] = v4;
    }
    a1[3] = v4;
  }
  return v3;
}

uint64_t XPBufferWriter_WriteS16(uint64_t a1, __int16 a2)
{
  __int16 __src = a2;
  uint64_t v3 = _XPBufferWriter_ReallocBuffer((uint64_t *)a1, 2uLL);
  if (!v3)
  {
    if (*(_DWORD *)(a1 + 48)) {
      Platform_Swap((unint64_t)&__src, 1u, 2uLL);
    }
    cstdlib_memcpy((void *)(*(void *)(a1 + 8) + *(void *)(a1 + 24)), &__src, 2uLL);
    unint64_t v4 = *(void *)(a1 + 24) + 2;
    if (v4 > *(void *)(a1 + 16)) {
      *(void *)(a1 + 16) = v4;
    }
    *(void *)(a1 + 24) = v4;
  }
  return v3;
}

uint64_t XPBufferWriter_WriteS32(uint64_t a1, int a2)
{
  int __src = a2;
  uint64_t v3 = _XPBufferWriter_ReallocBuffer((uint64_t *)a1, 4uLL);
  if (!v3)
  {
    if (*(_DWORD *)(a1 + 48)) {
      Platform_Swap((unint64_t)&__src, 1u, 4uLL);
    }
    cstdlib_memcpy((void *)(*(void *)(a1 + 8) + *(void *)(a1 + 24)), &__src, 4uLL);
    unint64_t v4 = *(void *)(a1 + 24) + 4;
    if (v4 > *(void *)(a1 + 16)) {
      *(void *)(a1 + 16) = v4;
    }
    *(void *)(a1 + 24) = v4;
  }
  return v3;
}

uint64_t XPBufferWriter_WriteS8(uint64_t *a1, char a2)
{
  char __src = a2;
  uint64_t v3 = _XPBufferWriter_ReallocBuffer(a1, 1uLL);
  if (!v3)
  {
    cstdlib_memcpy((void *)(a1[1] + a1[3]), &__src, 1uLL);
    unint64_t v4 = a1[3] + 1;
    if (v4 > a1[2]) {
      a1[2] = v4;
    }
    a1[3] = v4;
  }
  return v3;
}

uint64_t XPBufferWriter_WriteString(uint64_t *a1, char *__s)
{
  unint64_t v4 = cstdlib_strlen(__s) + 1;
  uint64_t v5 = _XPBufferWriter_ReallocBuffer(a1, v4);
  if (!v5)
  {
    cstdlib_memcpy((void *)(a1[1] + a1[3]), __s, v4);
    unint64_t v6 = a1[3] + v4;
    if (v6 > a1[2]) {
      a1[2] = v6;
    }
    a1[3] = v6;
  }
  return v5;
}

uint64_t XPBufferWriter_WriteU16(uint64_t a1, __int16 a2)
{
  __int16 __src = a2;
  uint64_t v3 = _XPBufferWriter_ReallocBuffer((uint64_t *)a1, 2uLL);
  if (!v3)
  {
    if (*(_DWORD *)(a1 + 48)) {
      Platform_Swap((unint64_t)&__src, 1u, 2uLL);
    }
    cstdlib_memcpy((void *)(*(void *)(a1 + 8) + *(void *)(a1 + 24)), &__src, 2uLL);
    unint64_t v4 = *(void *)(a1 + 24) + 2;
    if (v4 > *(void *)(a1 + 16)) {
      *(void *)(a1 + 16) = v4;
    }
    *(void *)(a1 + 24) = v4;
  }
  return v3;
}

uint64_t XPBufferWriter_WriteU32(uint64_t a1, int a2)
{
  int __src = a2;
  uint64_t v3 = _XPBufferWriter_ReallocBuffer((uint64_t *)a1, 4uLL);
  if (!v3)
  {
    if (*(_DWORD *)(a1 + 48)) {
      Platform_Swap((unint64_t)&__src, 1u, 4uLL);
    }
    cstdlib_memcpy((void *)(*(void *)(a1 + 8) + *(void *)(a1 + 24)), &__src, 4uLL);
    unint64_t v4 = *(void *)(a1 + 24) + 4;
    if (v4 > *(void *)(a1 + 16)) {
      *(void *)(a1 + 16) = v4;
    }
    *(void *)(a1 + 24) = v4;
  }
  return v3;
}

uint64_t PNEW_XPBufferWriter_Con(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = OOCAllocator_Malloc(a1, 72, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = XPBufferWriter_Con(v6, a2);
    unsigned int v8 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *a3 = v6;
    }
  }
  return result;
}

void *GetXPBufferWriterClass()
{
  return &__XPBufferWriter;
}

BOOL Platform_NeedByteSwap(int a1)
{
  return a1 != 0;
}

uint64_t Platform_GetByteOrder()
{
  return 0;
}

unint64_t Platform_Swap(unint64_t result, unsigned int a2, unint64_t a3)
{
  uint64_t v3 = a2 * a3;
  if (v3 >= 1)
  {
    unint64_t v4 = result + v3;
    unint64_t v5 = a3 >> 1;
    do
    {
      if (a3 >= 2)
      {
        uint64_t v6 = 0;
        unint64_t v7 = a3 - 1;
        do
        {
          char v8 = *(unsigned char *)(result + v7);
          *(unsigned char *)(result + v7) = *(unsigned char *)(result + v6);
          *(unsigned char *)(result + v6++) = v8;
          --v7;
        }
        while (v5 > v6);
        result += v6;
      }
      result += v5;
    }
    while (result < v4);
  }
  return result;
}

uint64_t Platform_GetStringFormat()
{
  return 0;
}

uint64_t ucs2len(uint64_t a1)
{
  uint64_t v1 = 0;
  do
  {
    int v2 = *(unsigned __int16 *)(a1 + v1);
    v1 += 2;
  }
  while (v2);
  return (v1 >> 1) - 1;
}

uint64_t ucs2ncpy(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  if (a3)
  {
    size_t v5 = 2 * a3 - 2;
    for (uint64_t i = (_WORD *)(a1 + 2); ; ++i)
    {
      int v7 = *a2;
      *(i - 1) = v7;
      if (!v7) {
        break;
      }
      ++a2;
      v5 -= 2;
      if (!--a3) {
        return a1;
      }
    }
    if (a3 != 1) {
      bzero(i, v5);
    }
  }
  return a1;
}

uint64_t ucs2chr(uint64_t a1, int a2)
{
  uint64_t v2 = a1 - 2;
  do
  {
    int v4 = *(unsigned __int16 *)(v2 + 2);
    v2 += 2;
    int v3 = v4;
    if (v4) {
      BOOL v5 = v3 == a2;
    }
    else {
      BOOL v5 = 1;
    }
  }
  while (!v5);
  if (v3 == a2) {
    return v2;
  }
  else {
    return 0;
  }
}

uint64_t ucs2rchr(uint64_t a1, int a2)
{
  uint64_t v2 = 0;
  do
  {
    int v3 = *(unsigned __int16 *)(a1 + v2);
    v2 += 2;
  }
  while (v3);
  do
  {
    uint64_t v5 = v2 - 2;
    if (v2 == 2) {
      return 0;
    }
    int v4 = *(unsigned __int16 *)(a1 + v2 - 2);
    v2 -= 2;
  }
  while (v4 != a2);
  return a1 + v5;
}

_WORD *ucs2str(_WORD *a1, unsigned __int16 *a2)
{
  int v3 = a1;
  uint64_t v4 = 0;
  while (a2[v4++])
    ;
  uint64_t v6 = (v4 * 2) >> 1;
  uint64_t v7 = v6 - 1;
  if (v6 == 1) {
    return 0;
  }
  int v8 = (unsigned __int16)*a1;
  if (!*a1) {
    return 0;
  }
  int v9 = *a2;
  while (v8 != v9 || ucs2ncmp(v3, a2, v7))
  {
    int v10 = (unsigned __int16)v3[1];
    ++v3;
    int v8 = v10;
    if (!v10) {
      return 0;
    }
  }
  return v3;
}

uint64_t ucs2ncmp(_WORD *a1, unsigned __int16 *a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t v3 = a3 - 1;
  if (a3 != 1)
  {
    uint64_t v4 = 2 * a3 - 2;
    uint64_t v5 = (_WORD *)((char *)a1 + v4);
    uint64_t v6 = (unsigned __int16 *)((char *)a2 + v4);
    while (*a1 && (unsigned __int16)*a1 == *a2)
    {
      ++a1;
      ++a2;
      if (!--v3)
      {
        a1 = v5;
        a2 = v6;
        return (unsigned __int16)*a1 - *a2;
      }
    }
  }
  return (unsigned __int16)*a1 - *a2;
}

unsigned __int16 *ucs2ncat(unsigned __int16 *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  while (*v3++)
    ;
  for (uint64_t i = 0; ; ++i)
  {
    uint64_t v6 = &v3[i];
    if (a3 == i) {
      break;
    }
    int v7 = *(unsigned __int16 *)(a2 + 2 * i);
    *(v6 - 1) = v7;
    if (!v7) {
      return result;
    }
  }
  *(v6 - 1) = 0;
  return result;
}

unsigned __int16 *utf16chr(unsigned __int16 *result, unsigned __int16 *a2)
{
  int v2 = *result;
  if (*result)
  {
    do
    {
      if (v2 == *a2)
      {
        if ((v2 & 0xFC00) != 0xD800) {
          return result;
        }
        int v2 = result[1];
        if (result[1])
        {
          int v4 = a2[1];
          ++a2;
          int v3 = v4;
          if (v4)
          {
            if (v2 == v3) {
              return result;
            }
          }
        }
        --a2;
      }
      else
      {
        int v2 = result[1];
      }
      ++result;
    }
    while (v2);
  }
  return 0;
}

unsigned __int8 *lhstdlib_strtok2(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 **a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  memset(v11, 0, sizeof(v11));
  do
  {
    unsigned int v3 = *a2++;
    *((unsigned char *)v11 + ((unint64_t)v3 >> 3)) |= 1 << (v3 & 7);
  }
  while (v3);
  if (!a1) {
    a1 = *a3;
  }
  do
  {
    unsigned int v5 = *a1++;
    unsigned int v4 = v5;
    int v6 = (1 << (v5 & 7)) & *((unsigned __int8 *)v11 + ((unint64_t)v5 >> 3));
    if (v5) {
      BOOL v7 = v6 == 0;
    }
    else {
      BOOL v7 = 1;
    }
  }
  while (!v7);
  int v8 = a1 - 1;
  if (v4)
  {
    while (1)
    {
      int v9 = a1;
      if ((*((unsigned __int8 *)v11 + ((unint64_t)v4 >> 3)) >> (v4 & 7))) {
        break;
      }
      ++a1;
      unsigned int v4 = *v9;
      if (!*v9) {
        goto LABEL_16;
      }
    }
    *(a1 - 1) = 0;
  }
  else
  {
    int v9 = a1 - 1;
  }
LABEL_16:
  *a3 = v9;
  if (v8 == v9) {
    return 0;
  }
  else {
    return v8;
  }
}

uint64_t lhstdlib_pqsort(uint64_t result, unint64_t a2, unint64_t a3, uint64_t (*a4)(void), uint64_t a5)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  if (a2 >= 2 && a3)
  {
    int v8 = (unsigned char *)result;
    int v9 = 0;
    memset(v47, 0, sizeof(v47));
    memset(v46, 0, sizeof(v46));
    unint64_t v10 = result + (a2 - 1) * a3;
    uint64_t v44 = -(uint64_t)a3;
    uint64_t v41 = -2 * a3;
    uint64_t v40 = ~a3;
    while (1)
    {
      unint64_t v11 = (v10 - (unint64_t)v8) / a3 + 1;
      if (v11 < 9) {
        break;
      }
      int v43 = v9;
      int v42 = &v8[a3];
      uint64_t v12 = v44;
      while (1)
      {
        unint64_t v13 = (v11 >> 1) * a3;
        if (v13)
        {
          int v14 = v8;
          unint64_t v15 = a3;
          do
          {
            char v16 = v14[v13];
            v14[v13] = *v14;
            *v14++ = v16;
            --v15;
          }
          while (v15);
        }
        unsigned int v17 = (unsigned char *)(v10 + a3);
        char v18 = v8;
        while (1)
        {
          uint64_t v19 = v17;
          int v20 = v18;
          unint64_t v21 = a3;
          do
          {
            unint64_t v22 = v21;
            char v18 = &v20[v21];
            if ((unint64_t)&v20[v21] > v10) {
              break;
            }
            int v23 = ((uint64_t (*)(unsigned char *, unsigned char *, uint64_t))a4)(&v20[v21], v8, a5);
            unint64_t v21 = v22 + a3;
          }
          while (v23 < 1);
          uint64_t v24 = 0;
          int v45 = v19;
          int v25 = &v19[v12];
          do
          {
            uint64_t v26 = v24;
            uint64_t result = (uint64_t)&v25[v24];
            if (&v25[v24] <= v8) {
              break;
            }
            uint64_t result = a4();
            uint64_t v24 = v26 - a3;
          }
          while ((result & 0x80000000) == 0);
          uint64_t v12 = v44;
          unsigned int v17 = &v45[v44 + v26];
          if (v17 < v18) {
            break;
          }
          if (v17 != v18)
          {
            int v27 = &v45[v26];
            uint64_t v28 = v44;
            do
            {
              char v29 = v20[v22];
              v20[v22] = v27[v28];
              v27[v28] = v29;
              ++v20;
              BOOL v30 = __CFADD__(v28++, 1);
            }
            while (!v30);
          }
        }
        if (v17 != v8)
        {
          int v31 = &v45[v26];
          uint64_t v32 = v44;
          int v33 = v8;
          do
          {
            char v34 = *v33;
            *v33++ = v31[v32];
            v31[v32] = v34;
            BOOL v30 = __CFADD__(v32++, 1);
          }
          while (!v30);
        }
        if ((uint64_t)&v45[v40 - (void)v8 + v26] >= (uint64_t)(v10 - (void)v20 - v22)) {
          break;
        }
        if ((unint64_t)&v20[v22] < v10)
        {
          *((void *)v47 + v43) = &v20[v22];
          *((void *)v46 + v43++) = v10;
        }
        if (v42 >= v17)
        {
          int v9 = v43;
          goto LABEL_48;
        }
        unint64_t v10 = (unint64_t)&v45[v41 + v26];
        unint64_t v11 = (unint64_t)&v45[v41 - (void)v8 + v26] / a3 + 1;
        if (v11 < 9)
        {
          int v9 = v43;
          goto LABEL_32;
        }
      }
      if (v42 >= &v45[v44 + v26])
      {
        int v9 = v43;
      }
      else
      {
        *((void *)v47 + v43) = v8;
        *((void *)v46 + v43) = &v45[v41 + v26];
        int v9 = v43 + 1;
      }
      int v8 = &v20[v22];
      if ((unint64_t)&v20[v22] >= v10)
      {
LABEL_48:
        BOOL v39 = __OFSUB__(v9--, 1);
        if (v9 < 0 != v39) {
          return result;
        }
        int v8 = (unsigned char *)*((void *)v47 + v9);
        unint64_t v10 = *((void *)v46 + v9);
      }
    }
LABEL_32:
    while (v10 > (unint64_t)v8)
    {
      int v35 = v8;
      if ((unint64_t)&v8[a3] <= v10)
      {
        int v36 = &v8[a3];
        int v35 = v8;
        do
        {
          uint64_t result = ((uint64_t (*)(unsigned char *, unsigned char *, uint64_t))a4)(v36, v35, a5);
          if ((int)result > 0) {
            int v35 = v36;
          }
          v36 += a3;
        }
        while ((unint64_t)v36 <= v10);
      }
      if (v35 != (unsigned char *)v10)
      {
        uint64_t v37 = 0;
        do
        {
          char v38 = v35[v37];
          v35[v37] = *(unsigned char *)(v10 + v37);
          *(unsigned char *)(v10 + v37++) = v38;
        }
        while (a3 != v37);
      }
      v10 += v44;
    }
    goto LABEL_48;
  }
  return result;
}

char *lhstdlib_MergeSortedLists(char *__dst, int a2, char *__src, int a4, unsigned int a5, unsigned int a6, uint64_t (*a7)(char *, char *))
{
  int v9 = __dst;
  unint64_t v10 = &__dst[(a2 - 1) * a6];
  unint64_t v11 = &__src[(a4 - 1) * a6];
  unint64_t v12 = (a4 + a2);
  size_t v13 = a6;
  if (v12 > a5)
  {
    unint64_t v14 = a5;
    uint64_t v15 = -(uint64_t)a6;
    unint64_t v16 = (a5 - (unint64_t)v12) * a6;
    while (1)
    {
      if (v11 < __src)
      {
        v10 += v16;
        goto LABEL_15;
      }
      if (v10 < v9) {
        break;
      }
      unsigned __int8 __dst = (char *)a7(v10, v11);
      if ((int)__dst <= 0) {
        uint64_t v17 = 0;
      }
      else {
        uint64_t v17 = v15;
      }
      v10 += v17;
      if ((int)__dst <= 0) {
        uint64_t v18 = v15;
      }
      else {
        uint64_t v18 = 0;
      }
      v11 += v18;
      --v12;
      v16 += v13;
      if (v12 <= v14) {
        goto LABEL_15;
      }
    }
    v11 += v16;
  }
LABEL_15:
  if (v11 >= __src)
  {
    uint64_t v19 = &v9[(a5 - 1) * a6];
    while (v10 >= v9)
    {
      if ((a7(v10, v11) & 0x80000000) != 0)
      {
        unsigned __int8 __dst = (char *)cstdlib_memcpy(v19, v11, v13);
        v11 -= a6;
      }
      else
      {
        unsigned __int8 __dst = (char *)cstdlib_memcpy(v19, v10, v13);
        v10 -= a6;
      }
      v19 -= a6;
      if (v19 < v9 || v11 < __src) {
        return __dst;
      }
    }
    return (char *)cstdlib_memcpy(v9, __src, (v11 + v13 - __src));
  }
  return __dst;
}

uint64_t lhstdlib_qsort(uint64_t result, unsigned int a2, unsigned int a3, uint64_t (*a4)(unsigned char *, unsigned char *))
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  if (a2 >= 2)
  {
    unsigned int v4 = a3;
    if (a3)
    {
      int v6 = (unsigned char *)result;
      int v7 = 0;
      memset(v45, 0, sizeof(v45));
      memset(v44, 0, sizeof(v44));
      unint64_t v8 = result + (a2 - 1) * a3;
      uint64_t v9 = a3;
      uint64_t v43 = -(uint64_t)a3;
      uint64_t v38 = -2 * a3;
      int v37 = -2 * a3;
      unint64_t v36 = ~(unint64_t)a3;
      int v10 = -a3;
      while (1)
      {
        unsigned int v11 = ((int)v8 - (int)v6) / v4 + 1;
        if (v11 < 9) {
          break;
        }
        int v41 = v7;
        uint64_t v40 = &v6[v9];
        while (1)
        {
          uint64_t v12 = (v11 >> 1) * v4;
          if (v12)
          {
            unsigned int v13 = v4;
            unint64_t v14 = v6;
            do
            {
              char v15 = v14[v12];
              v14[v12] = *v14;
              *v14++ = v15;
              --v13;
            }
            while (v13);
          }
          unint64_t v16 = (unsigned char *)(v8 + v9);
          uint64_t v17 = v6;
          while (1)
          {
            uint64_t v18 = v17;
            uint64_t v19 = v9;
            do
            {
              uint64_t v20 = v19;
              uint64_t v17 = &v18[v19];
              if ((unint64_t)&v18[v19] > v8) {
                break;
              }
              uint64_t result = a4(&v18[v19], v6);
              uint64_t v19 = v20 + v9;
            }
            while ((int)result < 1);
            uint64_t v21 = 0;
            int v42 = v16;
            unint64_t v22 = (unint64_t)&v16[v43];
            do
            {
              int v23 = (unsigned char *)v22;
              uint64_t v24 = v21;
              if (v22 <= (unint64_t)v6) {
                break;
              }
              uint64_t result = a4((unsigned char *)v22, v6);
              unint64_t v22 = (unint64_t)&v23[v43];
              uint64_t v21 = v24 + v9;
            }
            while ((result & 0x80000000) == 0);
            if (v23 < v17) {
              break;
            }
            unint64_t v16 = v23;
            if (v23 != v17)
            {
              uint64_t v25 = 0;
              uint64_t v26 = &v18[v20];
              do
              {
                char v27 = v26[v25];
                v26[v25] = v23[v25];
                v23[v25++] = v27;
              }
              while (v10 + v25);
              unint64_t v16 = v23;
            }
          }
          if (v23 != v6)
          {
            uint64_t v28 = 0;
            do
            {
              char v29 = v6[v28];
              v6[v28] = v23[v28];
              v23[v28++] = v29;
            }
            while (v9 != v28);
          }
          if ((uint64_t)&v42[v36 - (void)v6 - v24] >= (uint64_t)(v8 - (void)v18 - v20)) {
            break;
          }
          if ((unint64_t)&v18[v20] < v8)
          {
            *((void *)v45 + v41) = &v18[v20];
            *((void *)v44 + v41++) = v8;
          }
          unsigned int v4 = a3;
          if (v40 >= v23)
          {
            int v7 = v41;
            goto LABEL_47;
          }
          unint64_t v8 = (unint64_t)&v42[v38 - v24];
          unsigned int v11 = (v37 - (int)v6 + (int)v42 - (int)v24) / a3 + 1;
          if (v11 < 9)
          {
            int v7 = v41;
            goto LABEL_30;
          }
        }
        if (v40 >= v23)
        {
          int v7 = v41;
        }
        else
        {
          *((void *)v45 + v41) = v6;
          *((void *)v44 + v41) = &v42[v38 - v24];
          int v7 = v41 + 1;
        }
        int v6 = &v18[v20];
        BOOL v34 = (unint64_t)&v18[v20] >= v8;
        unsigned int v4 = a3;
        if (v34)
        {
LABEL_47:
          BOOL v35 = __OFSUB__(v7--, 1);
          if (v7 < 0 != v35) {
            return result;
          }
          int v6 = (unsigned char *)*((void *)v45 + v7);
          unint64_t v8 = *((void *)v44 + v7);
        }
      }
LABEL_30:
      while (v8 > (unint64_t)v6)
      {
        BOOL v30 = v6;
        if ((unint64_t)&v6[v9] <= v8)
        {
          int v31 = &v6[v9];
          BOOL v30 = v6;
          do
          {
            uint64_t result = a4(v31, v30);
            if ((int)result > 0) {
              BOOL v30 = v31;
            }
            v31 += v9;
          }
          while ((unint64_t)v31 <= v8);
        }
        if (v30 != (unsigned char *)v8)
        {
          uint64_t v32 = 0;
          do
          {
            char v33 = v30[v32];
            v30[v32] = *(unsigned char *)(v8 + v32);
            *(unsigned char *)(v8 + v32++) = v33;
          }
          while (v9 != v32);
        }
        v8 += v43;
      }
      goto LABEL_47;
    }
  }
  return result;
}

uint64_t lhstdlib_udqsort(uint64_t result, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t (*a5)(char *, char *, uint64_t))
{
  uint64_t v73 = *MEMORY[0x263EF8340];
  if (a2 >= 2 && a3)
  {
    long long v71 = 0u;
    long long v70 = 0u;
    long long v69 = 0u;
    long long v68 = 0u;
    long long v67 = 0u;
    long long v66 = 0u;
    long long v65 = 0u;
    long long v64 = 0u;
    long long v63 = 0u;
    long long v62 = 0u;
    long long v61 = 0u;
    long long v60 = 0u;
    long long v59 = 0u;
    long long v58 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    uint64_t v56 = 0;
    uint64_t v57 = result;
    uint64_t v8 = a3;
    uint64_t v72 = 0;
    uint64_t v41 = result + (a2 - 1) * a3;
    int v9 = 1;
    long long v49 = 0u;
    while (1)
    {
      unsigned int v10 = v9 - 1;
      unsigned int v11 = (char *)*(&v57 + v10);
      int v40 = v10;
      uint64_t v12 = (char *)*(&v41 + v10);
      unsigned int v13 = ((int)v12 - (int)v11) / a3 + 1;
      if (v13 >= 9) {
        break;
      }
      uint64_t v28 = v12;
LABEL_44:
      while (v28 > v11)
      {
        unint64_t v36 = v11;
        if (&v11[a3] <= v28)
        {
          int v37 = &v11[v8];
          unint64_t v36 = v11;
          do
          {
            uint64_t result = a5(v37, v36, a4);
            if ((int)result > 0) {
              unint64_t v36 = v37;
            }
            v37 += a3;
          }
          while (v37 <= v28);
        }
        if (v36 != v28)
        {
          uint64_t v38 = 0;
          do
          {
            char v39 = v36[v38];
            v36[v38] = v28[v38];
            v28[v38++] = v39;
          }
          while (v8 != v38);
        }
        v28 -= a3;
      }
      int v9 = v40;
      if (v40 <= 0) {
        return result;
      }
    }
    while (1)
    {
      uint64_t v14 = (v13 >> 1) * a3;
      char v15 = &v11[v14];
      int v16 = a5(&v11[v14], v11, a4);
      if (v14 && v16 < 0)
      {
        unsigned int v17 = a3;
        uint64_t v18 = v11;
        do
        {
          char v19 = v18[v14];
          v18[v14] = *v18;
          *v18++ = v19;
          --v17;
        }
        while (v17);
      }
      if ((a5(v12, &v11[v14], a4) & 0x80000000) != 0 && v15 != v12)
      {
        unsigned int v20 = a3;
        uint64_t v21 = v12;
        unint64_t v22 = &v11[v14];
        do
        {
          char v23 = *v22;
          *v22++ = *v21;
          *v21++ = v23;
          --v20;
        }
        while (v20);
      }
      int v24 = a5(&v11[v14], v11, a4);
      if (v14 && v24 < 0)
      {
        unsigned int v25 = a3;
        uint64_t v26 = v11;
        do
        {
          char v27 = v26[v14];
          v26[v14] = *v26;
          *v26++ = v27;
          --v25;
        }
        while (v25);
      }
      uint64_t v28 = &v11[a3];
      char v29 = &v12[-a3];
      do
      {
        while ((a5(v28, v15, a4) & 0x80000000) != 0)
          v28 += a3;
        uint64_t result = a5(v29, v15, a4);
        if ((int)result >= 1)
        {
          do
          {
            v29 -= a3;
            uint64_t result = a5(v29, v15, a4);
          }
          while ((int)result > 0);
        }
        if (v28 <= v29)
        {
          if (v28 != v29)
          {
            unsigned int v30 = a3;
            int v31 = v29;
            uint64_t v32 = v28;
            do
            {
              char v33 = *v32;
              *v32++ = *v31;
              *v31++ = v33;
              --v30;
            }
            while (v30);
          }
          if (v15 == v29) {
            BOOL v34 = v28;
          }
          else {
            BOOL v34 = v15;
          }
          if (v15 == v28) {
            char v15 = v29;
          }
          else {
            char v15 = v34;
          }
          v28 += a3;
          v29 -= a3;
        }
      }
      while (v28 <= v29);
      if (v29 - v11 > v12 - v28) {
        break;
      }
      char v29 = v12;
      BOOL v35 = v28 >= v12;
      uint64_t v12 = v28;
      if (!v35) {
        goto LABEL_39;
      }
LABEL_41:
      unsigned int v13 = ((int)v28 - (int)v11) / a3 + 1;
      uint64_t v12 = v28;
      if (v13 <= 8) {
        goto LABEL_44;
      }
    }
    uint64_t v28 = v11;
    BOOL v35 = v11 >= v29;
    unsigned int v11 = v29;
    if (v35)
    {
      unsigned int v11 = v29;
    }
    else
    {
LABEL_39:
      *(&v57 + v40) = (uint64_t)v28;
      *(&v41 + v40++) = (uint64_t)v29;
    }
    uint64_t v28 = v12;
    goto LABEL_41;
  }
  return result;
}

uint64_t lhstdlib_studqsort(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v25[0] = a1;
  v25[1] = a6;
  v25[2] = a5;
  v25[3] = a3;
  if (!a2) {
    return lhstdlib_udqsort(a4, 0, 4u, (uint64_t)v25, (uint64_t (*)(char *, char *, uint64_t))stablecmp);
  }
  uint64_t v9 = 0;
  uint64_t v10 = a2;
  do
  {
    *(_DWORD *)(a4 + 4 * v9) = v9;
    ++v9;
  }
  while (a2 != v9);
  uint64_t result = lhstdlib_udqsort(a4, a2, 4u, (uint64_t)v25, (uint64_t (*)(char *, char *, uint64_t))stablecmp);
  for (unint64_t i = 0; i != v10; ++i)
  {
    unint64_t v13 = *(unsigned int *)(a4 + 4 * i);
    LODWORD(v14) = i;
    if (i >= v13)
    {
      do
      {
        unsigned int v19 = v14;
        unint64_t v14 = *(unsigned int *)(a4 + 4 * v14);
      }
      while (i > v14);
      if (i != v14)
      {
        if (a3)
        {
          unsigned int v20 = v14 * a3;
          if (i * a3 != v14 * a3)
          {
            unint64_t v14 = v19;
            uint64_t v21 = (char *)(a1 + v20);
            unsigned int v22 = a3;
            char v23 = (char *)(a1 + i * a3);
            do
            {
              char v24 = *v23;
              *v23++ = *v21;
              *v21++ = v24;
              --v22;
            }
            while (v22);
            LODWORD(v14) = *(_DWORD *)(a4 + 4 * v14);
          }
        }
        *(_DWORD *)(a4 + 4 * i) = v14;
      }
    }
    else if (a3 && i * a3 != v13 * a3)
    {
      char v15 = (char *)(a1 + v13 * a3);
      unsigned int v16 = a3;
      unsigned int v17 = (char *)(a1 + i * a3);
      do
      {
        char v18 = *v17;
        *v17++ = *v15;
        *v15++ = v18;
        --v16;
      }
      while (v16);
    }
  }
  return result;
}

uint64_t stablecmp(int *a1, int *a2, uint64_t a3)
{
  int v3 = *a1;
  int v4 = *a2;
  LODWORD(result) = (*(uint64_t (**)(void, void, void))(a3 + 8))(*(void *)a3 + (*a1 * *(_DWORD *)(a3 + 24)), *(void *)a3 + (*a2 * *(_DWORD *)(a3 + 24)), *(void *)(a3 + 16));
  if (result) {
    return result;
  }
  else {
    return (v3 - v4);
  }
}

uint64_t lhstdlib_iqsort(uint64_t result, unsigned int a2, uint64_t a3, int (*a4)(uint64_t, uint64_t), uint64_t (*a5)(uint64_t, uint64_t), uint64_t (*a6)(uint64_t, uint64_t))
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  if (a2 >= 2)
  {
    uint64_t v9 = result;
    int v36 = 0;
    uint64_t v10 = result + a2 - 1;
    while (2)
    {
      while (2)
      {
        int v35 = v9 + 1;
        while (1)
        {
          unsigned int v11 = v10 - v9 + 1;
          if (v11 <= 8)
          {
            while ((int)v10 > (int)v9)
            {
              if ((int)v9 <= (int)v10) {
                int v28 = v10;
              }
              else {
                int v28 = v9;
              }
              int v29 = v28 + 1;
              uint64_t v30 = a6(v9, a3);
              uint64_t v31 = v9;
              do
              {
                uint64_t v32 = a6(v31, a3);
                if (a4(v32, v30) > 0) {
                  uint64_t v30 = v32;
                }
                uint64_t v31 = (v31 + 1);
              }
              while (v29 != v31);
              uint64_t v33 = a6(v10, a3);
              uint64_t result = a5(v30, v33);
              uint64_t v10 = (v10 - 1);
            }
            goto LABEL_36;
          }
          uint64_t v15 = v9 + (v11 >> 1);
          uint64_t v12 = a6(v9, a3);
          uint64_t v13 = a6(v15, a3);
          a5(v13, v12);
          int v14 = v10 + 1;
          LODWORD(v15) = v9;
          while (1)
          {
            int v16 = (int)v15 <= (int)v10 ? v10 : v15;
            int v17 = -v16;
            uint64_t v18 = (v15 + 1);
            do
            {
              uint64_t v15 = v18;
              if (v17 + v18 == 1) {
                break;
              }
              uint64_t v19 = a6(v18, a3);
              int v20 = a4(v19, v12);
              uint64_t v18 = (v15 + 1);
            }
            while (v20 < 1);
            uint64_t v21 = (v14 - 2);
            do
            {
              uint64_t v22 = v21;
              int v14 = v21 + 1;
              uint64_t v23 = a6((v21 + 1), a3);
              uint64_t v24 = v23;
              if (v14 <= (int)v9) {
                break;
              }
              int v25 = a4(v23, v12);
              uint64_t v21 = (v22 - 1);
            }
            while ((v25 & 0x80000000) == 0);
            if ((int)v22 + 2 <= (int)v15) {
              break;
            }
            uint64_t v26 = a6(v15, a3);
            a5(v26, v24);
          }
          uint64_t result = a5(v12, v24);
          int v27 = v22 + 1;
          if ((int)v22 - (int)v9 >= (int)v10 - (int)v15) {
            break;
          }
          if ((int)v10 > (int)v15)
          {
            v38[v36 + 30] = v15;
            v38[v36++] = v10;
          }
          uint64_t v10 = v22;
          if (v35 >= v27) {
            goto LABEL_36;
          }
        }
        if (v35 < v27)
        {
          v38[v36 + 30] = v9;
          v38[v36++] = v22;
        }
        uint64_t v9 = v15;
        if ((int)v10 > (int)v15) {
          continue;
        }
        break;
      }
LABEL_36:
      int v34 = v36 - 1;
      if (v36 >= 1)
      {
        uint64_t v9 = v38[v34 + 30];
        --v36;
        uint64_t v10 = v38[v34];
        continue;
      }
      break;
    }
  }
  return result;
}

unint64_t lhstdlib_pbsearch(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, unint64_t, uint64_t), uint64_t a6, _DWORD *a7)
{
  uint64_t v8 = (a3 - 1) * a4;
  if (v8 < 0)
  {
    unint64_t v20 = 0;
    unint64_t v12 = a2;
    goto LABEL_20;
  }
  unint64_t v23 = a2;
  uint64_t v24 = a7;
  unint64_t v12 = a2;
  unint64_t v13 = a2 + v8;
  while (a3 < 2)
  {
    if (!a3) {
      goto LABEL_15;
    }
    int v14 = a5(a1, v12, a6);
    if (!v14)
    {
      unint64_t v20 = v12;
      goto LABEL_19;
    }
    unint64_t v15 = v12 + a4;
    unint64_t v16 = v13 - a4;
    BOOL v17 = v14 >= 0;
    a3 = 1;
LABEL_11:
    if (v17) {
      unint64_t v12 = v15;
    }
    else {
      unint64_t v13 = v16;
    }
    if (v12 > v13)
    {
LABEL_15:
      unint64_t v20 = 0;
      goto LABEL_19;
    }
  }
  unint64_t v18 = a3 >> 1;
  uint64_t v19 = (a3 & 1) + (a3 >> 1) - 1;
  unint64_t v20 = v12 + v19 * a4;
  int v21 = a5(a1, v20, a6);
  if (v21)
  {
    unint64_t v15 = v20 + a4;
    unint64_t v16 = v20 - a4;
    BOOL v17 = v21 >= 0;
    if (v21 < 0) {
      a3 = v19;
    }
    else {
      a3 = v18;
    }
    goto LABEL_11;
  }
  v12 += v19 * a4;
LABEL_19:
  a2 = v23;
  a7 = v24;
LABEL_20:
  *a7 = (uint64_t)(v12 - a2) / (int)a4;
  return v20;
}

unint64_t lhstdlib_bsearch(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t (*a5)(uint64_t, unint64_t), _DWORD *a6)
{
  uint64_t v8 = (a3 - 1) * a4;
  if (v8 < 0)
  {
    unint64_t v19 = 0;
    unint64_t v12 = a2;
    goto LABEL_20;
  }
  uint64_t v22 = a6;
  unint64_t v11 = a2 + v8;
  unint64_t v12 = a2;
  while (a3 < 2)
  {
    if (!a3) {
      goto LABEL_15;
    }
    int v13 = a5(a1, v12);
    if (!v13)
    {
      unint64_t v19 = v12;
      goto LABEL_19;
    }
    unint64_t v14 = v12 + a4;
    unint64_t v15 = v11 - a4;
    BOOL v16 = v13 >= 0;
    a3 = 1;
LABEL_11:
    if (v16) {
      unint64_t v12 = v14;
    }
    else {
      unint64_t v11 = v15;
    }
    if (v12 > v11)
    {
LABEL_15:
      unint64_t v19 = 0;
      goto LABEL_19;
    }
  }
  unint64_t v17 = a3 >> 1;
  uint64_t v18 = (a3 & 1) + (a3 >> 1) - 1;
  unint64_t v19 = v12 + v18 * a4;
  int v20 = a5(a1, v19);
  if (v20)
  {
    unint64_t v14 = v19 + a4;
    unint64_t v15 = v19 - a4;
    BOOL v16 = v20 >= 0;
    if (v20 < 0) {
      a3 = v18;
    }
    else {
      a3 = v17;
    }
    goto LABEL_11;
  }
  v12 += v18 * a4;
LABEL_19:
  a6 = v22;
LABEL_20:
  *a6 = (v12 - a2) / a4;
  return v19;
}

uint64_t utf8_str_to_ucs2(uint64_t a1, char *__s, uint64_t *a3, uint64_t *a4)
{
  unsigned int v20 = 0;
  size_t v8 = cstdlib_strlen(__s);
  unint64_t v19 = __s;
  if (!v8)
  {
    unint64_t v15 = (_WORD *)*a3;
    if (!*a3)
    {
      if (!a1) {
        return err_GenerateErrorLimit();
      }
      unint64_t v15 = (_WORD *)OOCAllocator_Malloc(a1, 2, &v20);
      *a3 = (uint64_t)v15;
      if (v20) {
        return v20;
      }
      *a4 = 2;
    }
    *unint64_t v15 = 0;
    return v20;
  }
  size_t v9 = v8;
  uint64_t v10 = utf8_char_count((uint64_t *)&v19);
  if (v10 == -1) {
    return err_GenerateErrorCharacter();
  }
  uint64_t v11 = v10;
  uint64_t v12 = 2 * v10;
  if (2 * v10 < (unint64_t)*a4)
  {
    uint64_t v13 = *a3;
    goto LABEL_5;
  }
  if (!a1) {
    return err_GenerateErrorLimit();
  }
  uint64_t v16 = v12 + 2;
  uint64_t v13 = OOCAllocator_Realloc(a1, *a3, v12 + 2, &v20);
  *a3 = v13;
  if (!v20)
  {
    *a4 = v16;
LABEL_5:
    uint64_t v18 = (_WORD *)v13;
    unint64_t v19 = __s;
    if (!utf8_to_ucs2(&v19, &__s[v9], &v18, v13 + 2 * v11))
    {
      *uint64_t v18 = 0;
      return v20;
    }
    return err_GenerateErrorCharacter();
  }
  return v20;
}

uint64_t ucs2_str_to_utf8(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t *a4)
{
  unsigned int v18 = 0;
  uint64_t v8 = ucs2len(a2);
  unint64_t v17 = a2;
  if (!v8)
  {
    unint64_t v14 = (unsigned char *)*a3;
    if (!*a3)
    {
      if (!a1) {
        return err_GenerateErrorLimit();
      }
      unint64_t v14 = (unsigned char *)OOCAllocator_Malloc(a1, 1, &v18);
      *a3 = (uint64_t)v14;
      if (v18) {
        return v18;
      }
      *a4 = 1;
    }
    *unint64_t v14 = 0;
    return v18;
  }
  uint64_t v9 = v8;
  unint64_t v10 = ucs2_utf8_byte_count(&v17);
  if (v10 == -1) {
    return err_GenerateErrorCharacter();
  }
  unint64_t v11 = v10;
  if (v10 < *a4)
  {
    uint64_t v12 = (unsigned char *)*a3;
    goto LABEL_5;
  }
  if (!a1) {
    return err_GenerateErrorLimit();
  }
  uint64_t v12 = (unsigned char *)OOCAllocator_Realloc(a1, *a3, v10 + 1, &v18);
  *a3 = (uint64_t)v12;
  if (!v18)
  {
    *a4 = v11 + 1;
LABEL_5:
    uint64_t v16 = v12;
    unint64_t v17 = a2;
    if (!ucs2_to_utf8(&v17, a2 + 2 * v9, &v16, (unint64_t)&v12[v11]))
    {
      unsigned char *v16 = 0;
      return v18;
    }
    return err_GenerateErrorCharacter();
  }
  return v18;
}

uint64_t utf8_str_to_utf16(uint64_t a1, char *__s, uint64_t *a3, unint64_t *a4)
{
  unsigned int v18 = 0;
  size_t v8 = cstdlib_strlen(__s);
  unint64_t v17 = (unsigned __int8 *)__s;
  if (!v8)
  {
    unint64_t v14 = (_WORD *)*a3;
    if (!*a3)
    {
      if (!a1) {
        return err_GenerateErrorLimit();
      }
      unint64_t v14 = (_WORD *)OOCAllocator_Malloc(a1, 2, &v18);
      *a3 = (uint64_t)v14;
      if (v18) {
        return v18;
      }
      *a4 = 2;
    }
    *unint64_t v14 = 0;
    return v18;
  }
  size_t v9 = v8;
  unint64_t v10 = utf8_utf16_byte_count(&v17);
  if (v10 == -1) {
    return err_GenerateErrorCharacter();
  }
  unint64_t v11 = v10;
  if (v10 < *a4)
  {
    uint64_t v12 = (_WORD *)*a3;
    goto LABEL_5;
  }
  if (!a1) {
    return err_GenerateErrorLimit();
  }
  uint64_t v12 = (_WORD *)OOCAllocator_Realloc(a1, *a3, v10 + 2, &v18);
  *a3 = (uint64_t)v12;
  if (!v18)
  {
    *a4 = v11 + 1;
LABEL_5:
    uint64_t v16 = v12;
    unint64_t v17 = (unsigned __int8 *)__s;
    if (!utf8_to_utf16((char **)&v17, (unint64_t)&__s[v9], &v16, (unint64_t)v12 + v11))
    {
      _WORD *v16 = 0;
      return v18;
    }
    return err_GenerateErrorCharacter();
  }
  return v18;
}

uint64_t utf16_str_to_utf8(uint64_t a1, unsigned __int16 *a2, uint64_t *a3, unint64_t *a4)
{
  unsigned int v18 = 0;
  uint64_t v8 = utf16_byte_count(a2);
  unint64_t v17 = a2;
  if (!v8)
  {
    unint64_t v14 = (unsigned char *)*a3;
    if (!*a3)
    {
      if (!a1) {
        return err_GenerateErrorLimit();
      }
      unint64_t v14 = (unsigned char *)OOCAllocator_Malloc(a1, 1, &v18);
      *a3 = (uint64_t)v14;
      if (v18) {
        return v18;
      }
      *a4 = 1;
    }
    *unint64_t v14 = 0;
    return v18;
  }
  uint64_t v9 = v8;
  unint64_t v10 = utf16_utf8_byte_count(&v17);
  if (v10 == -1) {
    return err_GenerateErrorCharacter();
  }
  unint64_t v11 = v10;
  if (v10 < *a4)
  {
    uint64_t v12 = *a3;
    goto LABEL_5;
  }
  if (!a1) {
    return err_GenerateErrorLimit();
  }
  uint64_t v12 = OOCAllocator_Realloc(a1, *a3, v10 + 1, &v18);
  *a3 = v12;
  if (!v18)
  {
    *a4 = v11 + 1;
LABEL_5:
    uint64_t v16 = (unsigned char *)v12;
    unint64_t v17 = a2;
    if (!utf16_to_utf8(&v17, (char *)a2 + v9, &v16, v12 + v11))
    {
      unsigned char *v16 = 0;
      return v18;
    }
    return err_GenerateErrorCharacter();
  }
  return v18;
}

uint64_t utf8_check_named_string(const char *a1)
{
  uint64_t result = cstdlib_strlen(a1);
  if (result)
  {
    int v3 = (char *)a1;
    uint64_t result = utf8full_check(&v3, (unint64_t)&a1[result]);
    if (result) {
      return err_GenerateErrorCharacter();
    }
  }
  return result;
}

uint64_t utf8_check_named_letters(char *a1, uint64_t a2)
{
  int v4 = a1;
  if (!a2) {
    return 0;
  }
  uint64_t v2 = a2;
  while (!utf8full_check_letter(&v4))
  {
    if (!--v2) {
      return 0;
    }
  }
  return err_GenerateErrorCharacter();
}

BOOL string_is_utf8(const char *a1)
{
  size_t v2 = cstdlib_strlen(a1);
  if (!v2) {
    return 1;
  }
  int v4 = (char *)a1;
  return utf8full_check(&v4, (unint64_t)&a1[v2]) == 0;
}

uint64_t priv_utf8_to_ucs2(unsigned __int8 **a1, unint64_t a2, unsigned __int16 **a3, unint64_t a4)
{
  int v4 = *a1;
  if (a3) {
    unsigned int v5 = *a3;
  }
  else {
    unsigned int v5 = 0;
  }
  if ((unint64_t)v4 >= a2)
  {
LABEL_21:
    uint64_t v12 = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v6 = *v4;
      uint64_t v7 = trailing_bytes_for_utf8_start_byte[v6];
      if (v7 == -1) {
        break;
      }
      if ((unint64_t)&v4[v7] >= a2)
      {
        uint64_t v12 = 2;
        goto LABEL_26;
      }
      if (v5 && (unint64_t)(v5 + 1) > a4)
      {
        uint64_t v12 = 3;
        goto LABEL_26;
      }
      if ((v6 & 0xF0) == 0xE0)
      {
        int v8 = (char)v4[1];
        if (v8 > -65) {
          break;
        }
        int v9 = (char)v4[2];
        if (v9 > -65) {
          break;
        }
        v4 += 3;
        LOWORD(v6) = (v8 << 6) + ((_WORD)v6 << 12) + v9;
      }
      else if ((v6 & 0xE0) == 0xC0)
      {
        int v10 = (char)v4[1];
        if (v10 > -65) {
          break;
        }
        v4 += 2;
        LOWORD(v6) = v10 + ((_WORD)v6 << 6);
      }
      else
      {
        ++v4;
      }
      unsigned __int16 v11 = v6 - priv_utf8_to_ucs2_shifted_utf8_marks[v7];
      if (v11 >> 11 == 27)
      {
        v4 -= 3;
        break;
      }
      if (v5) {
        *v5++ = v11;
      }
      if ((unint64_t)v4 >= a2) {
        goto LABEL_21;
      }
    }
    uint64_t v12 = 1;
  }
LABEL_26:
  *a1 = v4;
  if (a3) {
    *a3 = v5;
  }
  return v12;
}

uint64_t utf8_check(unsigned __int8 **a1, unint64_t a2)
{
  return priv_utf8_to_ucs2(a1, a2, 0, 0);
}

unsigned __int8 *utf8_sync(unsigned __int8 *a1, unint64_t a2)
{
  do
  {
    uint64_t result = a1;
    if ((unint64_t)a1 >= a2) {
      break;
    }
    ++a1;
  }
  while (trailing_bytes_for_utf8_start_byte[*result] == 255);
  return result;
}

uint64_t utf8_char_count(uint64_t *a1)
{
  uint64_t v1 = *a1 + 1;
  int v2 = *(unsigned __int8 *)*a1;
  if (*(unsigned char *)*a1)
  {
    uint64_t v3 = 0;
    uint64_t v1 = *a1;
    while (1)
    {
      uint64_t v4 = trailing_bytes_for_utf8_start_byte[v2];
      if (v4 == -1) {
        break;
      }
      uint64_t v5 = v1 + v4;
      int v6 = *(unsigned __int8 *)(v5 + 1);
      uint64_t v1 = v5 + 1;
      int v2 = v6;
      ++v3;
      if (!v6)
      {
        ++v1;
        goto LABEL_8;
      }
    }
    uint64_t v3 = -1;
  }
  else
  {
    uint64_t v3 = 0;
  }
LABEL_8:
  *a1 = v1;
  return v3;
}

uint64_t ucs2_to_utf8(unint64_t *a1, unint64_t a2, unsigned char **a3, unint64_t a4)
{
  uint64_t v4 = (unsigned __int16 *)*a1;
  uint64_t v5 = *a3;
  if (*a1 >= a2)
  {
LABEL_14:
    uint64_t v13 = 0;
    goto LABEL_18;
  }
  while (1)
  {
    int v6 = v4;
    unsigned int v8 = *v4++;
    unsigned int v7 = v8;
    if ((v8 & 0xF800) == 0xD800)
    {
      uint64_t v13 = 1;
      goto LABEL_17;
    }
    if (v7 > 0x7F) {
      break;
    }
    if ((unint64_t)(v5 + 1) > a4) {
      goto LABEL_16;
    }
    unsigned char *v5 = v7;
    uint64_t v9 = 1;
LABEL_13:
    v5 += v9;
    if ((unint64_t)v4 >= a2) {
      goto LABEL_14;
    }
  }
  if (v7 < 0x800) {
    uint64_t v10 = 1;
  }
  else {
    uint64_t v10 = 2;
  }
  unsigned __int16 v11 = &v5[v10];
  if ((unint64_t)(v11 + 1) <= a4)
  {
    *unsigned __int16 v11 = v7 & 0x3F | 0x80;
    char v12 = v7 >> 6;
    if (v7 > 0x7FF)
    {
      *(v11 - 1) = v12 & 0x3F | 0x80;
      *(v11 - 2) = (v7 >> 12) | 0xE0;
      uint64_t v9 = 3;
    }
    else
    {
      *(v11 - 1) = v12 | 0xC0;
      uint64_t v9 = 2;
    }
    goto LABEL_13;
  }
LABEL_16:
  uint64_t v13 = 3;
LABEL_17:
  uint64_t v4 = v6;
LABEL_18:
  *a1 = (unint64_t)v4;
  *a3 = v5;
  return v13;
}

_WORD *ucs2_sync(_WORD *a1, unint64_t a2)
{
  do
  {
    uint64_t result = a1;
    if ((unint64_t)a1 >= a2) {
      break;
    }
    ++a1;
  }
  while ((*result & 0xF800) == 0xD800);
  return result;
}

uint64_t ucs2_utf8_byte_count(void *a1)
{
  uint64_t v1 = (unsigned __int16 *)(*a1 + 2);
  unsigned int v2 = *(unsigned __int16 *)*a1;
  if (*(_WORD *)*a1)
  {
    uint64_t v3 = 0;
    while (1)
    {
      if (v2 >= 0x80)
      {
        if (v2 >= 0x800)
        {
          if ((v2 & 0xF800) == 0xD800)
          {
            --v1;
            uint64_t v3 = -1;
            goto LABEL_13;
          }
          uint64_t v4 = 3;
        }
        else
        {
          uint64_t v4 = 2;
        }
      }
      else
      {
        uint64_t v4 = 1;
      }
      v3 += v4;
      unsigned int v5 = *v1++;
      unsigned int v2 = v5;
      if (!v5) {
        goto LABEL_13;
      }
    }
  }
  uint64_t v3 = 0;
LABEL_13:
  *a1 = v1;
  return v3;
}

uint64_t utf8_check_letter(unsigned __int8 **a1)
{
  uint64_t v1 = trailing_bytes_for_utf8_start_byte[**a1];
  if (v1 == -1) {
    return 1;
  }
  else {
    return priv_utf8_to_ucs2(a1, (unint64_t)&(*a1)[v1 + 1], 0, 0);
  }
}

uint64_t utf8_letter_byte_count(unsigned __int8 **a1)
{
  return trailing_bytes_for_utf8_start_byte[**a1] + 1;
}

uint64_t utf8_letter_to_ucs2(unsigned __int8 **a1, unsigned __int16 **a2)
{
  uint64_t v2 = trailing_bytes_for_utf8_start_byte[**a1];
  if (v2 == -1) {
    return 1;
  }
  else {
    return priv_utf8_to_ucs2(a1, (unint64_t)&(*a1)[v2 + 1], a2, (unint64_t)(*a2 + 1));
  }
}

uint64_t utf8_to_utf16(char **a1, unint64_t a2, _WORD **a3, unint64_t a4)
{
  return priv_utf8_to_utf16(a1, a2, a3, a4, 0);
}

uint64_t priv_utf8_to_utf16(char **a1, unint64_t a2, _WORD **a3, unint64_t a4, void *a5)
{
  unsigned int v5 = *a1;
  if (a3) {
    int v6 = *a3;
  }
  else {
    int v6 = 0;
  }
  if ((unint64_t)v5 < a2)
  {
    uint64_t v7 = 0;
    while (1)
    {
      unint64_t v8 = *v5;
      uint64_t v9 = trailing_bytes_for_utf8_start_byte_0[v8];
      if (v9 == -1) {
        goto LABEL_44;
      }
      if ((unint64_t)&v5[v9] >= a2)
      {
        uint64_t v19 = 2;
        goto LABEL_45;
      }
      if ((v8 & 0xF8) == 0xF0)
      {
        int v10 = v5[1];
        if (v10 > -65) {
          goto LABEL_40;
        }
        int v11 = v5[2];
        if (v11 > -65)
        {
LABEL_41:
          v5 += 2;
          goto LABEL_44;
        }
        int v12 = v5[3];
        if (v12 > -65)
        {
          v5 += 3;
          goto LABEL_44;
        }
        v5 += 4;
        unint64_t v8 = v12
           + ((((unint64_t)v10 << 6) + (v8 << 12) + v11) << 6);
      }
      else if ((v8 & 0xF0) == 0xE0)
      {
        int v13 = v5[1];
        if (v13 > -65)
        {
LABEL_40:
          ++v5;
          goto LABEL_44;
        }
        int v14 = v5[2];
        if (v14 > -65) {
          goto LABEL_41;
        }
        v5 += 3;
        unint64_t v8 = ((unint64_t)v13 << 6) + (v8 << 12) + v14;
      }
      else if ((v8 & 0xE0) == 0xC0)
      {
        int v15 = v5[1];
        if (v15 > -65)
        {
          uint64_t v19 = 1;
          ++v5;
          goto LABEL_45;
        }
        v5 += 2;
        unint64_t v8 = v15 + (v8 << 6);
      }
      else
      {
        ++v5;
      }
      unint64_t v16 = v8 - priv_utf8_to_utf16_shifted_utf8_marks[v9];
      if (v16 >> 16)
      {
        if (v16 >> 16 > 0x10)
        {
LABEL_38:
          v5 += (char)~(_BYTE)v9;
LABEL_44:
          uint64_t v19 = 1;
          goto LABEL_45;
        }
        int v17 = v16 & 0x3FF | 0xDC00;
        LODWORD(v16) = ((v16 + 67043328) >> 10) - 10240;
        if (v6)
        {
LABEL_27:
          if (v17) {
            uint64_t v18 = 2;
          }
          else {
            uint64_t v18 = 1;
          }
          if ((unint64_t)&v6[v18] > a4)
          {
            v5 += ~v9;
            uint64_t v19 = 3;
            goto LABEL_45;
          }
          _WORD *v6 = v16;
          if (v17)
          {
            v6[1] = v17;
            v6 += 2;
          }
          else
          {
            ++v6;
          }
        }
      }
      else
      {
        if ((v16 | 0x400) >> 10 == 55) {
          goto LABEL_38;
        }
        int v17 = 0;
        if (v6) {
          goto LABEL_27;
        }
      }
      ++v7;
      if ((unint64_t)v5 >= a2) {
        goto LABEL_37;
      }
    }
  }
  uint64_t v7 = 0;
LABEL_37:
  uint64_t v19 = 0;
LABEL_45:
  *a1 = v5;
  if (a3) {
    *a3 = v6;
  }
  if (a5) {
    *a5 = v7;
  }
  return v19;
}

uint64_t priv_utf16_to_utf8(unsigned __int16 **a1, unint64_t a2, unsigned char **a3, unint64_t a4)
{
  uint64_t v4 = *a1;
  if (a3) {
    unsigned int v5 = *a3;
  }
  else {
    unsigned int v5 = 0;
  }
  if ((unint64_t)v4 >= a2)
  {
    uint64_t v14 = 0;
    goto LABEL_37;
  }
  int v6 = *a1;
  while (1)
  {
    unsigned int v8 = *v6++;
    unint64_t v7 = v8;
    int v9 = v8 & 0xFC00;
    if (v9 == 55296) {
      break;
    }
    if (v9 == 56320) {
      goto LABEL_32;
    }
    if (v5) {
      goto LABEL_13;
    }
LABEL_29:
    uint64_t v4 = v6;
    if ((unint64_t)v6 >= a2)
    {
      uint64_t v14 = 0;
      uint64_t v4 = v6;
      goto LABEL_37;
    }
  }
  if ((unint64_t)v6 >= a2)
  {
    uint64_t v14 = 2;
    goto LABEL_37;
  }
  int v10 = *v6;
  if ((v10 & 0xFC00) != 0xDC00)
  {
LABEL_32:
    uint64_t v14 = 1;
    goto LABEL_37;
  }
  unint64_t v7 = (v10 - 56320) + (v7 << 10) - 56557568;
  int v6 = v4 + 2;
  if (!v5) {
    goto LABEL_29;
  }
LABEL_13:
  if (v7 < 0x80)
  {
    if ((unint64_t)(v5 + 1) > a4) {
      goto LABEL_33;
    }
    LODWORD(v11) = 0;
    unsigned char *v5 = v7;
    goto LABEL_28;
  }
  if (v7 < 0x10000) {
    uint64_t v11 = 2;
  }
  else {
    uint64_t v11 = 3;
  }
  if (v7 <= 0x7FF) {
    uint64_t v12 = 1;
  }
  else {
    uint64_t v12 = v11;
  }
  int v13 = &v5[v12];
  if ((unint64_t)(v13 + 1) <= a4)
  {
    *int v13 = v7 & 0x3F | 0x80;
    if (v7 <= 0x7FF)
    {
      *(v13 - 1) = (v7 >> 6) | 0xC0;
      LODWORD(v11) = 1;
    }
    else
    {
      *(v13 - 1) = (v7 >> 6) & 0x3F | 0x80;
      if ((v7 - 2048) >> 11 > 0x1E)
      {
        *(v13 - 2) = (v7 >> 12) & 0x3F | 0x80;
        *(v13 - 3) = (v7 >> 18) | 0xF0;
      }
      else
      {
        *(v13 - 2) = (v7 >> 12) | 0xE0;
      }
    }
LABEL_28:
    v5 += (v11 + 1);
    goto LABEL_29;
  }
LABEL_33:
  uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
  if (v7 >> 16) {
    uint64_t v15 = 0x7FFFFFFFFFFFFFFELL;
  }
  uint64_t v4 = &v6[v15];
  uint64_t v14 = 3;
LABEL_37:
  *a1 = v4;
  if (a3) {
    *a3 = v5;
  }
  return v14;
}

uint64_t utf16_check(unsigned __int16 **a1, unint64_t a2)
{
  return priv_utf16_to_utf8(a1, a2, 0, 0);
}

uint64_t utf16_char_count(__int16 **a1)
{
  uint64_t v1 = *a1;
  __int16 v2 = **a1;
  if (!v2) {
    return 0;
  }
  uint64_t result = 0;
  while (1)
  {
    uint64_t v4 = v1 + 1;
    int v5 = v2 & 0xFC00;
    if (v5 == 55296) {
      break;
    }
    if (v5 == 56320) {
      return -1;
    }
LABEL_8:
    ++result;
    __int16 v2 = *v4;
    uint64_t v1 = v4;
    if (!*v4) {
      return result;
    }
  }
  if (*v4)
  {
    uint64_t v4 = v1 + 2;
    goto LABEL_8;
  }
  return -1;
}

_WORD *utf16_sync(_WORD *result, _WORD *a2)
{
  while (result < a2)
  {
    int v2 = *result & 0xFC00;
    if (v2 == 56320)
    {
      uint64_t v3 = result + 1;
    }
    else
    {
      if (v2 != 55296) {
        return result;
      }
      uint64_t v3 = result + 1;
      if (result + 1 == a2) {
        return a2;
      }
      if ((*v3 & 0xFC00) == 0xDC00) {
        return result;
      }
    }
    uint64_t result = v3;
  }
  return result;
}

uint64_t utf16_utf8_byte_count(unsigned __int16 **a1)
{
  uint64_t v1 = *a1;
  int v2 = *a1 + 1;
  unsigned int v3 = **a1;
  if (**a1)
  {
    uint64_t v4 = 0;
    while (1)
    {
      if (v3 > 0x7F)
      {
        if (v3 > 0x7FF)
        {
          if (v3 >> 11 <= 0x1A) {
            goto LABEL_12;
          }
          if (v3 >> 10 > 0x36)
          {
            if (v3 < 0xE000)
            {
LABEL_17:
              uint64_t v4 = -1;
              int v2 = v1;
              goto LABEL_16;
            }
LABEL_12:
            v4 += 3;
            goto LABEL_13;
          }
          if ((*v2 & 0xFC00) != 0xDC00) {
            goto LABEL_17;
          }
          v4 += 4;
          int v2 = v1 + 2;
        }
        else
        {
          v4 += 2;
        }
      }
      else
      {
        ++v4;
      }
LABEL_13:
      uint64_t v1 = v2;
      unsigned int v5 = (unsigned __int16)*v2++;
      unsigned int v3 = v5;
      if (!v5) {
        goto LABEL_16;
      }
    }
  }
  uint64_t v4 = 0;
LABEL_16:
  *a1 = v2;
  return v4;
}

uint64_t utf8_utf16_byte_count(unsigned __int8 **a1)
{
  uint64_t v1 = 0;
  int v2 = *a1;
  while (1)
  {
    unsigned int v3 = v2;
    unsigned int v6 = *v2;
    uint64_t v4 = v2 + 1;
    uint64_t v5 = v6;
    if (!v6) {
      break;
    }
    uint64_t v7 = trailing_bytes_for_utf8_start_byte_0[v5];
    if ((v5 & 0xF8) == 0xF0) {
      uint64_t v8 = 4;
    }
    else {
      uint64_t v8 = 2;
    }
    v1 += v8;
    int v2 = &v4[v7];
    if (v7 == -1)
    {
      uint64_t v1 = -1;
      goto LABEL_9;
    }
  }
  unsigned int v3 = v4;
LABEL_9:
  *a1 = v3;
  return v1;
}

uint64_t utf16_letter_byte_count(_WORD *a1)
{
  int v1 = *a1 & 0xFC00;
  uint64_t v2 = 2;
  if (v1 == 55296) {
    uint64_t v2 = 4;
  }
  if (v1 == 56320) {
    return 0;
  }
  else {
    return v2;
  }
}

uint64_t utf8_letter_to_utf16(char **a1, _WORD **a2)
{
  uint64_t v2 = trailing_bytes_for_utf8_start_byte_0[**a1];
  if (v2 == -1) {
    return 1;
  }
  else {
    return priv_utf8_to_utf16(a1, (unint64_t)&(*a1)[v2 + 1], a2, (unint64_t)(*a2 + 2), 0);
  }
}

unsigned __int8 *utf8full_sync(unsigned __int8 *a1, unint64_t a2)
{
  do
  {
    uint64_t result = a1;
    if ((unint64_t)a1 >= a2) {
      break;
    }
    ++a1;
  }
  while (trailing_bytes_for_utf8_start_byte_0[*result] == 255);
  return result;
}

uint64_t utf8full_char_count(char **a1, unint64_t a2, void *a3)
{
  return priv_utf8_to_utf16(a1, a2, 0, 0, a3);
}

uint64_t utf8full_check(char **a1, unint64_t a2)
{
  return priv_utf8_to_utf16(a1, a2, 0, 0, 0);
}

uint64_t utf8full_check_letter(char **a1)
{
  uint64_t v1 = trailing_bytes_for_utf8_start_byte_0[**a1];
  if (v1 == -1) {
    return 1;
  }
  else {
    return priv_utf8_to_utf16(a1, (unint64_t)&(*a1)[v1 + 1], 0, 0, 0);
  }
}

uint64_t utf8full_letter_byte_count(unsigned __int8 **a1)
{
  return trailing_bytes_for_utf8_start_byte_0[**a1] + 1;
}

uint64_t utf16_byte_count(_WORD *a1)
{
  __int16 v1 = *a1;
  if (!*a1) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v4 = a1 + 1;
  do
  {
    int v5 = v1 & 0xFC00;
    if (v5 == 55296) {
      uint64_t v6 = 4;
    }
    else {
      uint64_t v6 = 2;
    }
    if (v5 == 56320) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = v6;
    }
    result += v7;
    int v8 = *v4++;
    __int16 v1 = v8;
  }
  while (v8);
  return result;
}

size_t spr_lcat(char *a1, uint64_t a2, char *a3, uint64_t a4)
{
  __int16 v14 = 0;
  unint64_t v13 = 0;
  if ((catParseFormatString(a3, (char *)&v14 + 1, &v13, &v14) & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  __int16 v12 = 45;
  size_t result = 0xFFFFFFFFLL;
  if ((char)v14 > 99)
  {
    if ((char)v14 == 100)
    {
      int v9 = 0;
      unsigned int v8 = 10;
      goto LABEL_13;
    }
    if ((char)v14 != 120) {
      return result;
    }
    int v9 = 0;
LABEL_11:
    unsigned int v8 = 16;
    goto LABEL_13;
  }
  if ((char)v14 == 88)
  {
    int v9 = 1;
    goto LABEL_11;
  }
  if ((char)v14 != 99) {
    return result;
  }
  unsigned int v8 = 0;
  int v9 = 0;
LABEL_13:
  if (SHIBYTE(v14) == 32)
  {
    int v10 = 32;
  }
  else
  {
    if (SHIBYTE(v14) != 48) {
      return result;
    }
    int v10 = 48;
  }
  if (a4 >= 0) {
    unint64_t v11 = a4;
  }
  else {
    unint64_t v11 = -a4;
  }
  return catUnsignedLongToASCII((char *)((unint64_t)&v12 & (a4 >> 63)), v10, v11, v8, v9, v13, a1, a2);
}

uint64_t catParseFormatString(char *a1, char *a2, void *a3, unsigned char *a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  size_t v8 = cstdlib_strlen(a1);
  if (v8 - 13 < 0xFFFFFFFFFFFFFFF4) {
    return 0xFFFFFFFFLL;
  }
  size_t v10 = v8;
  *a4 = a1[v8 - 1];
  unint64_t v11 = cstdlib_strpbrk(a1, "123456789");
  if (v11)
  {
    size_t v12 = (size_t)&a1[v10 + ~(unint64_t)v11];
    cstdlib_memcpy(__dst, v11, v12);
    __dst[v12] = 0;
    uint64_t v13 = (int)cstdlib_atoi(__dst);
  }
  else
  {
    uint64_t v13 = 0;
  }
  *a3 = v13;
  __dst[0] = *a1;
  __dst[1] = 0;
  __int16 v14 = cstdlib_strpbrk((char *)__dst, "-+0 #");
  if (v14) {
    char v15 = *v14;
  }
  else {
    char v15 = 32;
  }
  uint64_t result = 0;
  *a2 = v15;
  return result;
}

size_t catUnsignedLongToASCII(char *__s, int a2, unint64_t a3, unsigned int a4, int a5, unint64_t a6, char *a7, uint64_t a8)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  char v29 = 0;
  if (a4)
  {
    uint64_t v13 = 0;
    if (a5) {
      char v14 = 55;
    }
    else {
      char v14 = 87;
    }
    do
    {
      int v15 = a3 % a4;
      if (v15 << 24 >= 167772160) {
        char v16 = v14;
      }
      else {
        char v16 = 48;
      }
      v27[v13-- + 19] = v16 + v15;
      BOOL v17 = a3 >= a4;
      a3 /= a4;
    }
    while (v17);
    uint64_t v18 = -v13;
    uint64_t v19 = &v29 + v13;
    if (__s)
    {
LABEL_10:
      size_t v20 = cstdlib_strlen(__s);
      uint64_t v21 = v20 + v18;
      goto LABEL_15;
    }
  }
  else
  {
    if (a3 > 0xFF) {
      return 4294967293;
    }
    uint64_t v19 = &v28;
    char v28 = a3;
    uint64_t v18 = 1;
    if (__s) {
      goto LABEL_10;
    }
  }
  size_t v20 = 0;
  uint64_t v21 = v18;
LABEL_15:
  if (a6 >= v20 + v18) {
    size_t v23 = a6 - (v20 + v18);
  }
  else {
    size_t v23 = 0;
  }
  size_t v22 = v23 + v21;
  if (a7)
  {
    if (a8 - (uint64_t)a7 <= v22)
    {
      return 4294967294;
    }
    else
    {
      if (a2 == 32)
      {
        uint64_t v24 = (char *)cstdlib_memset(a7, 32, v23);
        int v25 = &v24[v23];
        if (__s)
        {
          cstdlib_memcpy(&v24[v23], __s, v20);
          v25 += v20;
        }
      }
      else
      {
        if (__s)
        {
          cstdlib_memcpy(a7, __s, v20);
          a7 += v20;
        }
        int v25 = (char *)cstdlib_memset(a7, a2, v23) + v23;
      }
      cstdlib_strcpy(v25, v19);
    }
  }
  return v22;
}

size_t spr_ulcat(char *a1, uint64_t a2, char *a3, unint64_t a4)
{
  __int16 v13 = 0;
  unint64_t v12 = 0;
  if ((catParseFormatString(a3, (char *)&v13 + 1, &v12, &v13) & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  if ((char)v13 > 99)
  {
    if ((char)v13 == 100)
    {
      int v8 = 0;
      unsigned int v7 = 10;
      goto LABEL_12;
    }
    if ((char)v13 != 120) {
      return 0xFFFFFFFFLL;
    }
    int v8 = 0;
LABEL_10:
    unsigned int v7 = 16;
    goto LABEL_12;
  }
  if ((char)v13 == 88)
  {
    int v8 = 1;
    goto LABEL_10;
  }
  if ((char)v13 != 99) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = 0;
  int v8 = 0;
LABEL_12:
  if (SHIBYTE(v13) == 32)
  {
    int v9 = 32;
    goto LABEL_17;
  }
  if (SHIBYTE(v13) != 48) {
    return 0xFFFFFFFFLL;
  }
  int v9 = 48;
LABEL_17:
  unint64_t v11 = v12;

  return catUnsignedLongToASCII(0, v9, a4, v7, v8, v11, a1, a2);
}

size_t spr_pcat(void *a1, uint64_t a2, char *a3, const char *a4)
{
  __int16 v15 = 0;
  size_t v14 = 0;
  if ((catParseFormatString(a3, (char *)&v15 + 1, &v14, &v15) & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  if ((char)v15 == 115)
  {
    int v8 = SHIBYTE(v15);
    if ((SHIBYTE(v15) | 0x10) == 0x30)
    {
      size_t v9 = v14;
      size_t v10 = cstdlib_strlen(a4);
      if (v10 <= v9) {
        size_t v11 = v9;
      }
      else {
        size_t v11 = v10;
      }
      if (v9 >= v10) {
        size_t v12 = v9 - v10;
      }
      else {
        size_t v12 = 0;
      }
      if (a1)
      {
        if (a2 - (uint64_t)a1 <= v11)
        {
          return 4294967294;
        }
        else
        {
          __int16 v13 = (char *)cstdlib_memset(a1, v8, v12);
          cstdlib_strcpy(&v13[v12], a4);
        }
      }
      return v11;
    }
    return 0xFFFFFFFFLL;
  }
  if ((char)v15 != 112) {
    return 0xFFFFFFFFLL;
  }

  return catUnsignedLongToASCII(0, 48, (unint64_t)a4, 0x10u, 1, 0x10uLL, (char *)a1, a2);
}

uint64_t spr_cat_version(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v26 = 0;
  uint64_t v8 = 14 * a2;
  uint64_t v9 = OOCAllocator_Malloc(a3, 14 * a2, &v26);
  uint64_t result = v26;
  if (!v26)
  {
    __s = (char *)v9;
    uint64_t v23 = a3;
    uint64_t v24 = a4;
    if (a2)
    {
      unint64_t v11 = 0;
      uint64_t v12 = v9 + v8;
      __int16 v13 = (char *)v9;
      do
      {
        unint64_t v14 = *(unsigned int *)(a1 + 4 * v11);
        unint64_t v15 = BYTE1(v14);
        unint64_t v16 = *(_DWORD *)(a1 + 4 * v11);
        BOOL v17 = &v13[(int)spr_ulcat_noerr(v13, v12, "d", v14 >> 16)];
        uint64_t v18 = &v17[(int)spr_pcat_noerr(v17, v12, "s", ".")];
        uint64_t v19 = &v18[(int)spr_ulcat_noerr(v18, v12, "d", v15)];
        size_t v20 = &v19[(int)spr_pcat_noerr(v19, v12, "s", ".")];
        int v21 = spr_ulcat_noerr(v20, v12, "d", v16);
        __int16 v13 = &v20[v21];
        if (v11 < a2 - 1) {
          v13 += (int)spr_pcat_noerr(&v20[v21], v12, "s", "|");
        }
        ++v11;
      }
      while (a2 != v11);
    }
    size_t v22 = cstdlib_strlen(__s);
    *uint64_t v24 = OOCAllocator_Realloc(v23, (uint64_t)__s, v22 + 1, &v26);
    return v26;
  }
  return result;
}

size_t spr_lcat_err(char *a1, uint64_t a2, char *a3, uint64_t a4, _DWORD *a5)
{
  *a5 = 0;
  size_t v6 = spr_lcat(a1, a2, a3, a4);
  if (v6 == -2) {
    *a5 = err_GenerateErrorInternal();
  }
  return v6;
}

size_t spr_ulcat_err(char *a1, uint64_t a2, char *a3, unint64_t a4, _DWORD *a5)
{
  *a5 = 0;
  size_t v6 = spr_ulcat(a1, a2, a3, a4);
  if (v6 == -2) {
    *a5 = err_GenerateErrorInternal();
  }
  return v6;
}

size_t spr_pcat_err(void *a1, uint64_t a2, char *a3, const char *a4, _DWORD *a5)
{
  *a5 = 0;
  size_t v6 = spr_pcat(a1, a2, a3, a4);
  if (v6 == -2) {
    *a5 = err_GenerateErrorInternal();
  }
  return v6;
}

uint64_t spr_lcat_noerr(char *a1, uint64_t a2, char *a3, uint64_t a4)
{
  LODWORD(result) = spr_lcat(a1, a2, a3, a4);
  if (result == -2) {
    return 0;
  }
  else {
    return result;
  }
}

uint64_t spr_ulcat_noerr(char *a1, uint64_t a2, char *a3, unint64_t a4)
{
  LODWORD(result) = spr_ulcat(a1, a2, a3, a4);
  if (result == -2) {
    return 0;
  }
  else {
    return result;
  }
}

uint64_t spr_pcat_noerr(void *a1, uint64_t a2, char *a3, const char *a4)
{
  LODWORD(result) = spr_pcat(a1, a2, a3, a4);
  if (result == -2) {
    return 0;
  }
  else {
    return result;
  }
}

uint64_t spr_cat_noerr(char *a1, uint64_t a2, unsigned char *__src, unsigned char *a4, const char *a5)
{
  uint64_t result = 0;
  uint64_t v12 = *MEMORY[0x263EF8340];
  unint64_t v7 = a4 - __src;
  if (a4 != __src && v7 <= 0xB)
  {
    cstdlib_memcpy(__dst, __src, a4 - __src);
    uint64_t result = 0;
    __dst[v7] = 0;
    unsigned int v10 = __dst[v7 - 1] - 88;
    if (v10 <= 0x20)
    {
      if (((1 << v10) & 0x100001801) != 0)
      {
        LODWORD(result) = spr_lcat(a1, a2, __dst, *(int *)a5);
      }
      else
      {
        if (((1 << v10) & 0x9000000) == 0) {
          return result;
        }
        LODWORD(result) = spr_pcat(a1, a2, __dst, a5);
      }
      if (result == -2) {
        return 0;
      }
      else {
        return result;
      }
    }
  }
  return result;
}

unsigned char *spr_parse_formatspecifier(unsigned char *result)
{
  if (!result) {
    return result;
  }
  int v1 = *result;
  if (!*result) {
    return 0;
  }
  uint64_t v2 = 1;
  while ((v1 | 0x10) != 0x30)
  {
    if ((v1 - 48) > 9) {
      goto LABEL_15;
    }
LABEL_9:
    int v1 = result[v2];
    if (result[v2]) {
      BOOL v3 = v2 <= 12;
    }
    else {
      BOOL v3 = 0;
    }
    ++v2;
    if (!v3) {
      return result;
    }
  }
  if (v2 == 1 || (v1 - 48) < 0xA) {
    goto LABEL_9;
  }
LABEL_15:
  unsigned int v4 = v1 - 88;
  int v5 = &result[v2];
  if (((1 << v4) & 0x109001801) == 0) {
    int v5 = result;
  }
  if (v4 <= 0x20) {
    return v5;
  }
  return result;
}

uint64_t str2lhps(const char *a1, uint64_t a2)
{
  if (a1)
  {
    *(void *)(a2 + 8) = a1;
    size_t v4 = (size_t)&a1[cstdlib_strlen(a1) + 2];
    *(void *)(a2 + 16) = a1;
    *(void *)(a2 + 24) = v4;
  }
  else
  {
    **(unsigned char **)(a2 + 8) = *(unsigned char *)(a2 + 32);
    size_t v4 = *(void *)(a2 + 24);
  }
  uint64_t v5 = *(void *)(a2 + 8);
  *(void *)a2 = v5;
  size_t v6 = v4 - v5;
  if ((uint64_t)(v4 - v5) < 3) {
    return 0;
  }
  uint64_t v8 = (unsigned __int8 *)(v5 + 2);
  while (1)
  {
    unsigned int v9 = *(v8 - 2);
    if (v9 > 0x2D)
    {
      if (v9 > 0x4A)
      {
        if (v9 > 0x5D)
        {
          if (v9 == 96 || v9 > 0x7A) {
            goto LABEL_73;
          }
        }
        else if (v9 - 91 < 0xFFFFFFF1)
        {
          goto LABEL_73;
        }
        goto LABEL_41;
      }
      if (v9 > 0x39)
      {
        if (v9 < 0x3F || v9 == 70) {
          goto LABEL_73;
        }
        goto LABEL_41;
      }
      if (v9 - 47 >= 8) {
        goto LABEL_41;
      }
      goto LABEL_73;
    }
    if (v9 > 0x20) {
      break;
    }
    if (v9 > 0xC)
    {
      if (v9 != 13 && v9 < 0x20) {
        goto LABEL_73;
      }
    }
    else if (v9 < 9 || v9 == 12)
    {
      goto LABEL_73;
    }
    *(void *)a2 = v8 - 1;
    *(void *)(a2 + 8) = v8++ - 1;
    if ((uint64_t)--v6 <= 2) {
      return 0;
    }
  }
  if (v9 > 0x26)
  {
    if (v9 == 39) {
      goto LABEL_41;
    }
    if (v9 == 42)
    {
      unint64_t v11 = v8 - 1;
      *(void *)(a2 + 8) = v8 - 1;
      unsigned int v12 = *(v8 - 1);
      if (v12 > 0x2D)
      {
        if (v12 <= 0x3B)
        {
          if (v12 - 58 >= 0xFFFFFFF5) {
            return 0;
          }
          goto LABEL_107;
        }
        BOOL v13 = v12 == 63;
      }
      else
      {
        BOOL v13 = v12 == 33;
        if (v12 > 0x21)
        {
          if (v12 != 44) {
            return 0;
          }
LABEL_107:
          uint64_t v8 = v11 + 1;
          *(void *)(a2 + 8) = v11 + 1;
          LOBYTE(v14) = v11[1];
          goto LABEL_193;
        }
      }
      if (!v13) {
        return 0;
      }
      *(void *)(a2 + 8) = v8;
      unsigned int v14 = *v8;
      unint64_t v11 = v8;
      if (v14 != 92) {
        goto LABEL_193;
      }
      goto LABEL_107;
    }
LABEL_73:
    uint64_t result = 0;
    *(void *)(a2 + 8) = v8 - 1;
    return result;
  }
  if (v9 - 37 < 0xFFFFFFFD) {
    goto LABEL_73;
  }
LABEL_41:
  *(void *)(a2 + 8) = --v8;
  *(void *)(a2 + 16) = v8;
  while (2)
  {
    unsigned int v14 = *v8;
    if (v14 > 0x3C)
    {
      if (v14 > 0x5B)
      {
        if (v14 > 0x7A)
        {
          if (v14 == 124 || v14 >= 0x7F) {
            goto LABEL_193;
          }
        }
        else if (v14 >= 0x5D && v14 != 96)
        {
          goto LABEL_193;
        }
        goto LABEL_71;
      }
      if (v14 <= 0x45)
      {
        if (v14 != 62) {
          goto LABEL_193;
        }
        goto LABEL_71;
      }
      if (v14 == 70 || v14 == 75) {
        goto LABEL_71;
      }
LABEL_193:
      *(unsigned char *)(a2 + 32) = v14;
      *uint64_t v8 = 0;
      return *(void *)a2;
    }
    if (v14 > 0x2B)
    {
      if (v14 > 0x36)
      {
        if (v14 != 58 && v14 < 0x3C) {
          goto LABEL_193;
        }
      }
      else if (v14 != 45 && v14 < 0x30)
      {
        goto LABEL_193;
      }
      goto LABEL_71;
    }
    if (v14 <= 0x24)
    {
      if (v14 != 33) {
        goto LABEL_193;
      }
      goto LABEL_71;
    }
    if (v14 != 37)
    {
      if (v14 < 0x27) {
        goto LABEL_109;
      }
      if (v14 < 0x2B) {
        goto LABEL_193;
      }
LABEL_71:
      *(void *)(a2 + 8) = ++v8;
      *(void *)(a2 + 16) = v8;
      if (v8 != (unsigned __int8 *)v4) {
        continue;
      }
      return 0;
    }
    break;
  }
  do
  {
    BOOL v17 = v8 + 1;
    *(void *)(a2 + 8) = v8 + 1;
    if ((unsigned __int8 *)v4 == v8 + 1) {
      return 0;
    }
    unsigned int v15 = *v17;
    if (v15 > 0x22)
    {
      if (v15 == 37 || v15 >= 0x7F) {
        goto LABEL_192;
      }
    }
    else
    {
      if (v15 < 0x21) {
        goto LABEL_192;
      }
      if (v15 != 33)
      {
        *(void *)(a2 + 8) = v8 + 2;
        if ((unsigned __int8 *)v4 != v8 + 2)
        {
          unsigned int v16 = v8[2];
          if (v16 > 0x22)
          {
            if (v16 == 37 || v16 > 0x7E) {
              goto LABEL_192;
            }
          }
          else if (v16 != 33)
          {
            goto LABEL_192;
          }
          BOOL v17 = v8 + 3;
          *(void *)(a2 + 8) = v8 + 3;
          if ((unsigned __int8 *)v4 != v8 + 3)
          {
            while (1)
            {
              unsigned int v18 = *v17;
              if (v18 > 0x22)
              {
                if (v18 == 37 || v18 >= 0x7F) {
                  goto LABEL_192;
                }
              }
              else
              {
                if (v18 < 0x21) {
                  goto LABEL_192;
                }
                if (v18 != 33) {
                  goto LABEL_83;
                }
              }
              uint64_t result = 0;
              *(void *)(a2 + 8) = ++v17;
              if (v17 == (unsigned __int8 *)v4) {
                return result;
              }
            }
          }
        }
        return 0;
      }
    }
LABEL_83:
    uint64_t v8 = v17 + 1;
    *(void *)(a2 + 8) = v17 + 1;
    *(void *)(a2 + 16) = v17 + 1;
    if ((unsigned __int8 *)v4 == v17 + 1) {
      return 0;
    }
    unsigned int v14 = *v8;
    if (v14 < 0x25) {
      goto LABEL_193;
    }
  }
  while (v14 == 37);
  if (v14 > 0x26) {
    goto LABEL_193;
  }
LABEL_109:
  uint64_t v19 = v8 + 1;
  *(void *)(a2 + 8) = v8 + 1;
  if ((unsigned __int8 *)v4 == v8 + 1) {
    return 0;
  }
  while (2)
  {
    unsigned int v20 = v8[1];
    if (v20 > 0x3E)
    {
      if (v20 > 0x5A)
      {
        if (v20 > 0x5F)
        {
          if (v20 == 96 || v20 > 0x7A) {
            goto LABEL_192;
          }
        }
        else if (v20 < 0x5E)
        {
          goto LABEL_192;
        }
        goto LABEL_133;
      }
      BOOL v22 = v20 == 70;
      if (v20 > 0x46) {
        BOOL v22 = v20 == 75;
      }
      if (!v22) {
        goto LABEL_133;
      }
LABEL_192:
      *(void *)(a2 + 8) = v8;
      LOBYTE(v14) = *v8;
      goto LABEL_193;
    }
    if (v20 > 0x27)
    {
      if (v20 > 0x2E)
      {
        if (v20 - 58 < 0xFFFFFFFD) {
          goto LABEL_192;
        }
      }
      else if (v20 != 46)
      {
        goto LABEL_192;
      }
    }
    else if (v20 < 0x22 || v20 - 37 < 2)
    {
      goto LABEL_192;
    }
LABEL_133:
    uint64_t v8 = v19 + 1;
    *(void *)(a2 + 8) = v19 + 1;
    *(void *)(a2 + 16) = v19 + 1;
    if ((unsigned __int8 *)v4 == v19 + 1) {
      return 0;
    }
    while (2)
    {
      unsigned int v14 = *v8;
      if (v14 > 0x3C)
      {
        if (v14 > 0x5B)
        {
          if (v14 > 0x7A)
          {
            if (v14 == 124 || v14 >= 0x7F) {
              goto LABEL_193;
            }
          }
          else if (v14 >= 0x5D && v14 != 96)
          {
            goto LABEL_193;
          }
        }
        else if (v14 > 0x45)
        {
          if (v14 != 70 && v14 != 75) {
            goto LABEL_193;
          }
        }
        else if (v14 != 62)
        {
          goto LABEL_193;
        }
        goto LABEL_163;
      }
      if (v14 > 0x2B)
      {
        if (v14 > 0x36)
        {
          if (v14 != 58 && v14 < 0x3C) {
            goto LABEL_193;
          }
        }
        else if (v14 != 45 && v14 < 0x30)
        {
          goto LABEL_193;
        }
        goto LABEL_163;
      }
      if (v14 <= 0x24)
      {
        if (v14 != 33) {
          goto LABEL_193;
        }
        goto LABEL_163;
      }
      if (v14 == 37)
      {
        while (1)
        {
          uint64_t v23 = v8 + 1;
          *(void *)(a2 + 8) = v8 + 1;
          if ((unsigned __int8 *)v4 == v8 + 1) {
            return 0;
          }
          unsigned int v25 = *v23;
          if (v25 > 0x22)
          {
            if (v25 == 37 || v25 > 0x7E) {
              goto LABEL_192;
            }
          }
          else
          {
            if (v25 < 0x21) {
              goto LABEL_192;
            }
            if (v25 != 33)
            {
              *(void *)(a2 + 8) = v8 + 2;
              if ((unsigned __int8 *)v4 == v8 + 2) {
                return 0;
              }
              unsigned int v26 = v8[2];
              if (v26 > 0x22)
              {
                if (v26 == 37 || v26 > 0x7E) {
                  goto LABEL_192;
                }
              }
              else if (v26 != 33)
              {
                goto LABEL_192;
              }
              uint64_t v23 = v8 + 3;
              *(void *)(a2 + 8) = v8 + 3;
              if ((unsigned __int8 *)v4 != v8 + 3)
              {
                while (1)
                {
                  unsigned int v24 = *v23;
                  if (v24 > 0x22)
                  {
                    if (v24 == 37 || v24 >= 0x7F) {
                      goto LABEL_192;
                    }
                  }
                  else
                  {
                    if (v24 < 0x21) {
                      goto LABEL_192;
                    }
                    if (v24 != 33) {
                      goto LABEL_186;
                    }
                  }
                  uint64_t result = 0;
                  *(void *)(a2 + 8) = ++v23;
                  if (v23 == (unsigned __int8 *)v4) {
                    return result;
                  }
                }
              }
              return 0;
            }
          }
LABEL_186:
          uint64_t v8 = v23 + 1;
          *(void *)(a2 + 8) = v23 + 1;
          *(void *)(a2 + 16) = v23 + 1;
          if ((unsigned __int8 *)v4 == v23 + 1) {
            return 0;
          }
          unsigned int v14 = *v8;
          if (v14 < 0x25) {
            goto LABEL_193;
          }
          if (v14 != 37)
          {
            if (v14 > 0x26) {
              goto LABEL_193;
            }
            goto LABEL_190;
          }
        }
      }
      if (v14 >= 0x27)
      {
        if (v14 < 0x2B) {
          goto LABEL_193;
        }
LABEL_163:
        uint64_t result = 0;
        *(void *)(a2 + 8) = ++v8;
        *(void *)(a2 + 16) = v8;
        if (v8 == (unsigned __int8 *)v4) {
          return result;
        }
        continue;
      }
      break;
    }
LABEL_190:
    uint64_t result = 0;
    uint64_t v19 = v8 + 1;
    *(void *)(a2 + 8) = v8 + 1;
    if ((unsigned __int8 *)v4 != v8 + 1) {
      continue;
    }
    return result;
  }
}

uint64_t LHString_Con(void *a1, uint64_t a2)
{
  return LHString_ConFromCPtr(a1, a2, gc_szEmptyString);
}

uint64_t LHString_ConFromCPtr(void *a1, uint64_t a2, const char *a3)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__LHString;
    return LHString_ConFromCPtrInterval((uint64_t)a1, a2, a3, 0);
  }
  return result;
}

uint64_t LHString_ConFromCPtrInterval(uint64_t a1, uint64_t a2, const char *a3, const char *a4)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__LHString;
    *(void *)(a1 + 24) = a2;
    uint64_t result = __LHString_GetCopy(a1, a3, a4, (char **)(a1 + 8));
    if (!result)
    {
      int v9 = cstdlib_strlen(*(const char **)(a1 + 8));
      uint64_t result = 0;
      *(void *)(a1 + 16) = (v9 + 1);
    }
  }
  return result;
}

uint64_t __LHString_GetCopy(uint64_t a1, const char *a2, const char *a3, char **a4)
{
  if (a2) {
    size_t v6 = a2;
  }
  else {
    size_t v6 = (const char *)&gc_szEmptyString;
  }
  if (!a3) {
    a3 = &v6[cstdlib_strlen(v6)];
  }
  unsigned int v10 = 0;
  unsigned int v7 = a3 - v6;
  uint64_t v8 = (char *)OOCAllocator_Malloc(*(void *)(a1 + 24), (a3 - v6 + 1), &v10);
  uint64_t result = v10;
  if (!v10)
  {
    cstdlib_strncpy(v8, v6, v7);
    v8[v7] = 0;
    *a4 = v8;
    return v10;
  }
  return result;
}

uint64_t LHString_ConFromFilename(void *a1, uint64_t a2, const char *a3)
{
  uint64_t result = LHString_ConFromCPtr(a1, a2, a3);
  if (!result)
  {
    *a1 = &__LHString;
    a1[3] = a2;
  }
  return result;
}

uint64_t LHString_ConFromStream(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v9 = 0;
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__LHString;
    *(_DWORD *)(a1 + 20) = 0;
    *(void *)(a1 + 24) = a2;
    unsigned int v7 = (_DWORD *)(a1 + 16);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(void *)a3 + 24))(a3 - *(void *)(*(void *)a3 + 88), 4, a1 + 16, &v9);
    unsigned int v10 = result;
    if (!result)
    {
      if (v9 != 4) {
        return err_GenerateErrorArg();
      }
      uint64_t v8 = OOCAllocator_Malloc(*(void *)(a1 + 24), *(unsigned int *)(a1 + 16), &v10);
      *(void *)(a1 + 8) = v8;
      uint64_t result = v10;
      if (!v10)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, int *))(*(void *)a3 + 24))(a3 - *(void *)(*(void *)a3 + 88), *v7, v8, &v9);
        unsigned int v10 = result;
        if (!result)
        {
          if (v9 == *v7) {
            return 0;
          }
          return err_GenerateErrorArg();
        }
      }
    }
  }
  return result;
}

uint64_t LHString_ConFromString(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = LHString_ConFromCPtr(a1, a2, *(const char **)(a3 + 8));
  if (!result)
  {
    *a1 = &__LHString;
    a1[3] = a2;
  }
  return result;
}

uint64_t LHString_ConFromUTF16CPtr(void *a1, uint64_t a2, unsigned __int16 *a3)
{
  unint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__LHString;
    a1[3] = a2;
    uint64_t result = utf16_str_to_utf8(a2, a3, (uint64_t *)&v8, &v7);
    if (!result)
    {
      uint64_t result = LHString_ConFromCPtr(a1, a2, v8);
      if (!result)
      {
        OOCAllocator_Free(a1[3], (uint64_t)v8);
        return 0;
      }
    }
  }
  return result;
}

uint64_t LHString_ConFromUTF8CPtr(void *a1, uint64_t a2, const char *a3)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__LHString;
    a1[3] = a2;
    return LHString_ConFromCPtr(a1, a2, a3);
  }
  return result;
}

uint64_t LHString_ConReserve(void *a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__LHString;
    a1[3] = a2;
    uint64_t result = LHString_ConFromCPtr(a1, a2, gc_szEmptyString);
    if (!result)
    {
      return LHString_Reserve((uint64_t)a1, a3, a4);
    }
  }
  return result;
}

uint64_t LHString_Reserve(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result = 0;
  unsigned int v8 = 0;
  if (*(_DWORD *)(a1 + 16) >= a2) {
    goto LABEL_4;
  }
  uint64_t v7 = OOCAllocator_Realloc(*(void *)(a1 + 24), *(void *)(a1 + 8), a2, &v8);
  *(void *)(a1 + 8) = v7;
  if (v7)
  {
    *(_DWORD *)(a1 + 16) = a2;
    uint64_t result = v8;
LABEL_4:
    *(_DWORD *)(a1 + 20) = a3;
    return result;
  }
  return err_GenerateErrorResource();
}

uint64_t LHString_Des(uint64_t *a1)
{
  OOCAllocator_Free(a1[3], a1[1]);
  a1[2] = 0;

  return Object_Des();
}

uint64_t LHString_Append(uint64_t a1, const char *a2)
{
  BOOL v3 = a2;
  return LHString_AppendEx(a1, &v3, 1u);
}

uint64_t LHString_AppendEx(uint64_t a1, const char **a2, unsigned int a3)
{
  size_t v4 = a2;
  int v6 = 0;
  if (a3)
  {
    uint64_t v7 = a3;
    unsigned int v8 = a2;
    do
    {
      if (*v8) {
        v6 += cstdlib_strlen(*v8);
      }
      ++v8;
      --v7;
    }
    while (v7);
  }
  if (cstdlib_strlen(*(const char **)(a1 + 8)) == -1
    || __CFADD__(v6, cstdlib_strlen(*(const char **)(a1 + 8)) + 1))
  {
    return err_GenerateErrorArg();
  }
  else
  {
    unsigned int v10 = v6 + cstdlib_strlen(*(const char **)(a1 + 8)) + 1;
    while (1)
    {
      unsigned int v11 = *(_DWORD *)(a1 + 16);
      if (v10 <= v11) {
        break;
      }
      int v12 = *(_DWORD *)(a1 + 20);
      unsigned int v13 = v12 + v11;
      if (v12) {
        unsigned int v14 = v13;
      }
      else {
        unsigned int v14 = v10;
      }
      uint64_t result = LHString_Reserve(a1, v14, v12);
      if (result) {
        return result;
      }
    }
    if (a3)
    {
      uint64_t v15 = a3;
      do
      {
        unsigned int v16 = *v4;
        if (*v4)
        {
          size_t v17 = cstdlib_strlen(*v4);
          if (v17)
          {
            size_t v18 = v17;
            if (v17 + cstdlib_strlen(*(const char **)(a1 + 8)) < *(unsigned int *)(a1 + 16)) {
              cstdlib_strncat(*(char **)(a1 + 8), v16, v18);
            }
          }
        }
        ++v4;
        --v15;
      }
      while (v15);
    }
    return 0;
  }
}

size_t LHString_Length(uint64_t a1)
{
  return cstdlib_strlen(*(const char **)(a1 + 8));
}

uint64_t LHString_Capacity(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t LHString_BorrowCPtr(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t LHString_Erase(uint64_t a1)
{
  unsigned int v2 = cstdlib_strlen(gc_szEmptyString);

  return LHString_SetContentFromNCPtr(a1, gc_szEmptyString, v2);
}

uint64_t LHString_SetContentFromCPtr(uint64_t a1, char *__s)
{
  unsigned int v4 = cstdlib_strlen(__s);

  return LHString_SetContentFromNCPtr(a1, __s, v4);
}

uint64_t LHString_FindAndReplace(uint64_t a1, unsigned __int8 *a2, const char *a3)
{
  if (cstdlib_strlen(*(const char **)(a1 + 8)))
  {
    unint64_t v6 = 0;
    do
    {
      uint64_t v7 = *(const char **)(a1 + 8);
      if (v7[v6] == *a2)
      {
        v7[v6] = *a3;
        uint64_t v7 = *(const char **)(a1 + 8);
      }
      ++v6;
    }
    while (v6 < cstdlib_strlen(v7));
  }
  return 0;
}

uint64_t LHString_FreeUTF16CPtr(uint64_t a1, uint64_t a2)
{
  return OOCAllocator_Free(*(void *)(a1 + 24), a2);
}

uint64_t LHString_FreeUTF8CPtr(uint64_t a1, uint64_t a2)
{
  return OOCAllocator_Free(*(void *)(a1 + 24), a2);
}

uint64_t LHString_GetUTF16CPtr(uint64_t a1)
{
  unint64_t v2 = 0;
  uint64_t v3 = 0;
  utf8_str_to_utf16(*(void *)(a1 + 24), *(char **)(a1 + 8), &v3, &v2);
  return v3;
}

char *LHString_GetUTF8CPtr(uint64_t a1)
{
  unint64_t v2 = 0;
  __LHString_GetCopy(a1, *(const char **)(a1 + 8), 0, &v2);
  return v2;
}

BOOL LHString_IsEmpty(uint64_t a1)
{
  int v1 = *(const char **)(a1 + 8);
  return v1 == (const char *)&gc_szEmptyString || !cstdlib_strlen(v1);
}

BOOL LHString_IsEqualToCPtr(uint64_t a1, const char *a2)
{
  unint64_t v2 = *(const char **)(a1 + 8);
  if (a2)
  {
    return cstdlib_strcmp(v2, a2) == 0;
  }
  else
  {
    if (!v2) {
      return 1;
    }
    return cstdlib_strlen(v2) == 0;
  }
}

BOOL LHString_IsEqualToString(uint64_t a1, uint64_t a2)
{
  return LHString_IsEqualToCPtr(a1, *(const char **)(a2 + 8));
}

uint64_t LHString_SetContentFromNCPtr(uint64_t a1, const char *a2, unsigned int a3)
{
  size_t v6 = a3 + 1;
  while (1)
  {
    unsigned int v7 = *(_DWORD *)(a1 + 16);
    if (v6 <= v7) {
      break;
    }
    int v8 = *(_DWORD *)(a1 + 20);
    unsigned int v9 = v8 + v7;
    if (v8) {
      unsigned int v10 = v9;
    }
    else {
      unsigned int v10 = v6;
    }
    uint64_t result = LHString_Reserve(a1, v10, v8);
    if (result) {
      return result;
    }
  }
  cstdlib_memset(*(void **)(a1 + 8), 0, v6);
  cstdlib_strncpy(*(char **)(a1 + 8), a2, a3);
  return 0;
}

size_t LHString_Split(uint64_t a1, const char *a2, uint64_t a3)
{
  size_t result = cstdlib_strlen(*(const char **)(a1 + 8));
  if (result)
  {
    unsigned int v7 = *(char **)(a1 + 8);
    if (v7)
    {
      uint64_t v10 = 0;
      while (1)
      {
        int v8 = cstdlib_strstr(v7, a2);
        size_t result = PNEW_LHString_ConFromCPtrInterval(*(void *)(a1 + 24), *(void *)(a1 + 24), v7, v8, &v10);
        if (result) {
          break;
        }
        uint64_t v9 = v10;
        if (cstdlib_strlen(*(const char **)(v10 + 8)))
        {
          size_t result = PtrList_Append(a3, v9);
          if (result) {
            return result;
          }
        }
        else
        {
          size_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 24), v9);
          if (result) {
            return result;
          }
        }
        unsigned int v7 = v8 + 1;
        if (!v8) {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t PNEW_LHString_ConFromCPtrInterval(uint64_t a1, uint64_t a2, const char *a3, const char *a4, uint64_t *a5)
{
  unsigned int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 32, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = LHString_ConFromCPtrInterval(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *a5 = v10;
    }
  }
  return result;
}

uint64_t LHString_Trim(uint64_t a1)
{
  __s = 0;
  unint64_t v2 = *(const char **)(a1 + 8);
  uint64_t v3 = &v2[cstdlib_strlen(v2)];
  unsigned int v4 = *(const char **)(a1 + 8);
  if (v4 >= v3)
  {
    size_t v6 = 0;
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v5 = 0;
    size_t v6 = 0;
    unsigned int v7 = *(unsigned __int8 *)v4;
    if (v7 < 0xE0) {
      uint64_t v8 = 2;
    }
    else {
      uint64_t v8 = 3;
    }
    if ((v7 & 0x80u) == 0) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = v8;
    }
    do
    {
      if ((v7 & 0x80) == 0 && (v7 - 9 < 5 || v7 == 32))
      {
        BOOL v10 = 0;
        if (!v5) {
          uint64_t v5 = v4;
        }
      }
      else
      {
        uint64_t v5 = 0;
        BOOL v10 = v6 == 0;
      }
      if (v10) {
        size_t v6 = v4;
      }
      v4 += v9;
      unsigned int v7 = *(unsigned __int8 *)v4;
      if (v7 < 0xE0) {
        uint64_t v11 = 2;
      }
      else {
        uint64_t v11 = 3;
      }
      if ((v7 & 0x80u) == 0) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v11;
      }
    }
    while (v4 < v3);
  }
  if (v5) {
    unsigned int v12 = v5;
  }
  else {
    unsigned int v12 = v4;
  }
  if (v6) {
    unsigned int v13 = v6;
  }
  else {
    unsigned int v13 = v12;
  }
  uint64_t result = __LHString_GetCopy(a1, v13, v12, &__s);
  if (!result)
  {
    uint64_t v15 = __s;
    unsigned int v16 = cstdlib_strlen(__s);
    uint64_t result = LHString_SetContentFromNCPtr(a1, v15, v16);
    if (!result)
    {
      OOCAllocator_Free(*(void *)(a1 + 24), (uint64_t)v15);
      return 0;
    }
  }
  return result;
}

uint64_t LHString_WriteToStream(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  int v5 = v4 & 3;
  if ((v4 & 3) != 0) {
    uint64_t v6 = 4 - (v4 & 3u);
  }
  else {
    uint64_t v6 = 0;
  }
  int v10 = v6 + v4;
  uint64_t result = (*(uint64_t (**)(uint64_t, int *, uint64_t))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 88), &v10, 4);
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 88), *(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (result) {
      BOOL v8 = 1;
    }
    else {
      BOOL v8 = v5 == 0;
    }
    if (!v8)
    {
      int v9 = 0;
      return (*(uint64_t (**)(uint64_t, int *, uint64_t))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 88), &v9, v6);
    }
  }
  return result;
}

uint64_t PNEW_LHString_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = (void *)OOCAllocator_Malloc(a1, 32, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = LHString_ConFromCPtr(v6, a2, gc_szEmptyString);
    unsigned int v8 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *a3 = v6;
    }
  }
  return result;
}

uint64_t PNEW_LHString_ConFromCPtr(uint64_t a1, uint64_t a2, const char *a3, void *a4)
{
  unsigned int v10 = 0;
  unsigned int v8 = (void *)OOCAllocator_Malloc(a1, 32, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = LHString_ConFromCPtr(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t PNEW_LHString_ConFromString(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unsigned int v10 = 0;
  unsigned int v8 = (void *)OOCAllocator_Malloc(a1, 32, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = LHString_ConFromCPtr(v8, a2, *(const char **)(a3 + 8));
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *unsigned int v8 = &__LHString;
      v8[3] = a2;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t PNEW_LHString_ConFromFilename(uint64_t a1, uint64_t a2, const char *a3, void *a4)
{
  unsigned int v10 = 0;
  unsigned int v8 = (void *)OOCAllocator_Malloc(a1, 32, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = LHString_ConFromCPtr(v8, a2, a3);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *unsigned int v8 = &__LHString;
      v8[3] = a2;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t PNEW_LHString_ConFromUTF8CPtr(uint64_t a1, uint64_t a2, const char *a3, void *a4)
{
  unsigned int v10 = 0;
  unsigned int v8 = (void *)OOCAllocator_Malloc(a1, 32, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = LHString_ConFromUTF8CPtr(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t PNEW_LHString_ConFromUTF16CPtr(uint64_t a1, uint64_t a2, unsigned __int16 *a3, void *a4)
{
  unsigned int v10 = 0;
  unsigned int v8 = (void *)OOCAllocator_Malloc(a1, 32, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = LHString_ConFromUTF16CPtr(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t PNEW_LHString_ConReserve(uint64_t a1, uint64_t a2, unsigned int a3, int a4, void *a5)
{
  unsigned int v12 = 0;
  unsigned int v10 = (void *)OOCAllocator_Malloc(a1, 32, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = LHString_ConReserve(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *a5 = v10;
    }
  }
  return result;
}

uint64_t PNEW_LHString_ConFromStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 32, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = LHString_ConFromStream(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

void *GetLHStringClass()
{
  return &__LHString;
}

uint64_t lhi_IsValidLanguageString(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    size_t v2 = cstdlib_strlen((const char *)result);
    if (v2 < 3) {
      return 0;
    }
    if (v2 != 3)
    {
      unint64_t v3 = 3;
      while (1)
      {
        int v4 = *(unsigned __int8 *)(v1 + v3);
        if (v4 != 124 && v4 != 0) {
          break;
        }
        v3 += 4;
        if (v3 >= v2) {
          return 1;
        }
      }
      return 0;
    }
    return 1;
  }
  return result;
}

uint64_t lhi_TranscriptionSpecIsCompatible(uint64_t *a1, uint64_t *a2, void *a3)
{
  *a3 = 0;
  uint64_t v6 = (const char *)a1[2];
  if (v6)
  {
    unsigned int v7 = (const char *)a2[2];
    if (v7)
    {
      if (cstdlib_strcmp(v6, v7)) {
        *a3 |= 2uLL;
      }
    }
  }
  uint64_t v8 = (const char *)a1[3];
  if (v8)
  {
    int v9 = (const char *)a2[3];
    if (v9)
    {
      if (cstdlib_strcmp(v8, v9)) {
        *a3 |= 4uLL;
      }
    }
  }
  uint64_t v10 = *a2;
  if (!*a2)
  {
LABEL_26:
    *a3 |= 1uLL;
    return 0;
  }
  if (lhi_IsValidLanguageString(*a1) && lhi_IsValidLanguageString(*a2))
  {
    do
    {
      for (uint64_t i = *a1; ; i += 4)
      {
        for (uint64_t j = 0; j != 3; ++j)
        {
          int v13 = *(unsigned __int8 *)(i + j);
          if ((v13 - 97) < 0x1A) {
            LOBYTE(v13) = v13 - 32;
          }
          __s1[j] = v13;
        }
        for (uint64_t k = 0; k != 3; ++k)
        {
          int v15 = *(unsigned __int8 *)(v10 + k);
          if ((v15 - 97) < 0x1A) {
            LOBYTE(v15) = v15 - 32;
          }
          __s2[k] = v15;
        }
        if (!cstdlib_memcmp(__s1, __s2, 3uLL)) {
          break;
        }
        if (!*(unsigned char *)(i + 3)) {
          goto LABEL_26;
        }
      }
      int v16 = *(unsigned __int8 *)(v10 + 3);
      v10 += 4;
    }
    while (v16);
    return 0;
  }

  return err_GenerateErrorData();
}

uint64_t lhi_TranscriptionSpecCheckCompatibility(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = 0;
  uint64_t result = lhi_TranscriptionSpecIsCompatible(a1, a2, &v4);
  if (!result)
  {
    char v3 = v4;
    if ((v4 & 1) == 0 || (uint64_t result = err_GenerateErrorData(), !result))
    {
      if ((v3 & 8) == 0 || (uint64_t result = err_GenerateErrorData(), !result))
      {
        if ((v3 & 2) == 0 || (uint64_t result = err_GenerateErrorData(), !result))
        {
          if ((v3 & 4) != 0)
          {
            return err_GenerateErrorData();
          }
          else
          {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t lhi_LogPhoneticTranscriptions(uint64_t a1, const char *a2, const char *a3, uint64_t a4, unint64_t a5)
{
  uint64_t result = 0;
  *(void *)&v19[1] = *MEMORY[0x263EF8340];
  if (a4)
  {
    if (a5)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1 - *(void *)(*(void *)a1 + 88));
      if (result)
      {
        int v16 = a2;
        unint64_t v10 = 0;
        uint64_t v11 = &v18;
        unsigned int v12 = 1;
        do
        {
          if (*(_DWORD *)(a4 + 24 * v10) == 1)
          {
            int v13 = *(const char **)(a4 + 24 * v10 + 8);
            unsigned int v14 = v11;
          }
          else
          {
            unsigned int v14 = v11;
            int v13 = "<non-phonetic>";
          }
          v11 += (int)spr_pcat_noerr(v14, (uint64_t)v19, "s", v13);
          if (a5 == v12) {
            break;
          }
          unint64_t v10 = v12;
          v11 += (int)spr_pcat_noerr(v11, (uint64_t)v19, "s", " ");
          ++v12;
        }
        while (a5 > v10);
        *uint64_t v11 = 0;
        return (*(uint64_t (**)(uint64_t, const char *, const char *, ...))(*(void *)a1 + 32))(a1 - *(void *)(*(void *)a1 + 88), v16, "Found %d transcriptions for '%s': %s", v15, v16, a3);
      }
    }
  }
  return result;
}

uint64_t EDConstants_Con(void *a1, uint64_t a2, int a3)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__EDConstants;
    a1[1] = a2;
    if (a3 == 24)
    {
      return 0;
    }
    else
    {
      return err_GenerateErrorArg();
    }
  }
  return result;
}

uint64_t PNEW_EDConstants_Con(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = (void *)OOCAllocator_Malloc(a1, 16, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = EDConstants_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

void *GetEDConstantsClass()
{
  return &__EDConstants;
}

uint64_t CDSHash_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = 0;
  uint64_t result = VoConObject_Con2((void *)a1, a2);
  if (!result)
  {
    *(void *)a1 = &__CDSHash;
    *(void *)(a1 + 104) = a2;
    if ((*(unsigned int (**)(uint64_t))(*(void *)a3 + 56))(a3 - *(void *)(*(void *)a3 + 224)) == 388438978)
    {
      unsigned int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 64))(a3 - *(void *)(*(void *)a3 + 224));
      if (BinBlockStreamReader_IsVersionAccepted(v7, 0x10000))
      {
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a3)(a3 - *(void *)(*(void *)a3 + 224), 1162560581, 0, &v10);
        if (!result)
        {
          uint64_t result = PNEW_EHashTableFSM_Con2(*(void *)(a1 + 104), *(void *)(a1 + 104), v10, (uint64_t *)(a1 + 56));
          if (!result)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3 - *(void *)(*(void *)a3 + 224), v10);
            if (!result)
            {
              uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t *, uint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), *(void *)(a1 + 104), 1128612933, 0, 0x10000, &v12, &v11);
              if (!result)
              {
                unsigned int v8 = v11 >> 2;
                *(_DWORD *)(a1 + 64) = v11 >> 2;
                uint64_t v9 = v12 + 2 * v8;
                *(void *)(a1 + 72) = v12;
                *(void *)(a1 + 80) = v9;
                uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), *(void *)(a1 + 104), 1329808453, 0, 0x10000, a1 + 88, &v11);
                if (!result) {
                  return PNEW_EDConstants_Con(*(void *)(a1 + 104), *(void *)(a1 + 88), v11, (void *)(a1 + 96));
                }
              }
            }
          }
        }
      }
      else
      {
        return err_GenerateErrorVersion();
      }
    }
    else
    {
      return err_GenerateErrorData();
    }
  }
  return result;
}

uint64_t _CDSHash_ConInternal(void *a1, uint64_t a2)
{
  uint64_t result = VoConObject_Con2(a1, a2);
  if (!result)
  {
    *a1 = &__CDSHash;
    a1[12] = 0;
    a1[13] = a2;
    a1[9] = 0;
    a1[7] = 0;
    a1[11] = 0;
  }
  return result;
}

uint64_t CDSHash_Des(void *a1)
{
  uint64_t result = _CDSHash_Cleanup(a1);
  if (!result)
  {
    return VoConObject_Des((uint64_t)a1);
  }
  return result;
}

uint64_t _CDSHash_Cleanup(void *a1)
{
  OOCAllocator_Free(a1[13], a1[11]);
  a1[11] = 0;
  uint64_t v2 = a1[12];
  if (v2)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[13], v2);
    if (result) {
      return result;
    }
    a1[12] = 0;
  }
  OOCAllocator_Free(a1[13], a1[9]);
  a1[9] = 0;
  uint64_t v4 = a1[7];
  if (!v4) {
    return 0;
  }
  uint64_t result = OOC_PlacementDeleteObject(a1[13], v4);
  if (!result) {
    a1[7] = 0;
  }
  return result;
}

uint64_t CDSHash_Archive(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 80))(a2 - *(void *)(*(void *)a2 + 120))
    || (uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t, uint64_t))a2)(a2 - *(void *)(*(void *)a2 + 120), 388438978, 0x10000, 6), !result))
  {
    uint64_t v8 = 0;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 8))(a2 - *(void *)(*(void *)a2 + 120), 1162560581, 0x10000, 8, &v8);
    if (!result)
    {
      uint64_t result = EHashTableFSM_Archive(*(void *)(a1 + 56), v8);
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 120), v8);
        if (!result)
        {
          uint64_t v8 = 0;
          uint64_t v5 = *(unsigned int *)(a1 + 64);
          uint64_t v6 = *(void *)(a1 + 72);
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 32))(a2 - *(void *)(*(void *)a2 + 120), 1128612933, 0x10000, &v8);
          if (!result)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 8))(v8 - *(void *)(*(void *)v8 + 56), v6, 4 * v5);
            if (!result)
            {
              uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 120), v8);
              unsigned int v9 = result;
              if (!result)
              {
                uint64_t v8 = 0;
                unsigned int v7 = (void *)OOCAllocator_Calloc(*(void *)(a1 + 104), 24, 1, &v9);
                uint64_t result = v9;
                if (!v9)
                {
                  cstdlib_memcpy(v7, *(const void **)(*(void *)(a1 + 96) + 8), 0x18uLL);
                  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 32))(a2 - *(void *)(*(void *)a2 + 120), 1329808453, 0x10000, &v8);
                  unsigned int v9 = result;
                  if (!result)
                  {
                    uint64_t result = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)v8 + 8))(v8 - *(void *)(*(void *)v8 + 56), v7, 24);
                    unsigned int v9 = result;
                    if (!result)
                    {
                      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 120), v8);
                      unsigned int v9 = result;
                      if (!result)
                      {
                        OOCAllocator_Free(*(void *)(a1 + 104), (uint64_t)v7);
                        return v9;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void CDSHash_CreateFromStreamInterruptible(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  if (!_PNEW_CDSHash_ConInternal(a1, a1, a3))
  {
    _CDSHash_InitInternal(*a3, a2, a4);
    if (!v7)
    {
      if (*a4)
      {
        if (!(*(unsigned int (**)(uint64_t))(*(void *)*a3 + 32))(*a3)) {
          *a3 = 0;
        }
      }
    }
  }
}

uint64_t _PNEW_CDSHash_ConInternal(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = (void *)OOCAllocator_Malloc(a1, 112, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = VoConObject_Con2(v6, a2);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      void *v6 = &__CDSHash;
      v6[12] = 0;
      v6[13] = a2;
      v6[9] = 0;
      _OWORD v6[7] = 0;
      v6[11] = 0;
      v6[2] = a1;
      *a3 = v6;
    }
  }
  return result;
}

void _CDSHash_InitInternal(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 80))(a2 - *(void *)(*(void *)a2 + 208)) == 388438978)
  {
    unsigned int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 88))(a2 - *(void *)(*(void *)a2 + 208));
    if (BinBlockStreamReader_IsVersionAccepted(v6, 0x10000))
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      uint64_t v10 = 0;
      if (!(**(unsigned int (***)(uint64_t, uint64_t, void, uint64_t *, _DWORD *))a2)(a2 - *(void *)(*(void *)a2 + 208), 1162560581, 0, &v10, a3))
      {
        if (*a3)
        {
LABEL_5:
          _CDSHash_Cleanup((void *)a1);
          return;
        }
        EHashTableFSM_CreateFromStreamInterruptible(*(void *)(a1 + 104), v10, (uint64_t *)(a1 + 56), a3);
        if (!v7
          && !(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2 - *(void *)(*(void *)a2 + 208), v10))
        {
          if (*a3) {
            goto LABEL_5;
          }
          if (!(*(unsigned int (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t *, uint64_t *, _DWORD *))(*(void *)a2 + 64))(a2 - *(void *)(*(void *)a2 + 208), *(void *)(a1 + 104), 1128612933, 0, 0x10000, &v12, &v11, a3))
          {
            if (*a3) {
              goto LABEL_5;
            }
            unsigned int v8 = v11 >> 2;
            *(_DWORD *)(a1 + 64) = v11 >> 2;
            uint64_t v9 = v12 + 2 * v8;
            *(void *)(a1 + 72) = v12;
            *(void *)(a1 + 80) = v9;
            if (!(*(unsigned int (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t *, _DWORD *))(*(void *)a2 + 64))(a2 - *(void *)(*(void *)a2 + 208), *(void *)(a1 + 104), 1329808453, 0, 0x10000, a1 + 88, &v11, a3))
            {
              if (*a3) {
                goto LABEL_5;
              }
              PNEW_EDConstants_Con(*(void *)(a1 + 104), *(void *)(a1 + 88), v11, (void *)(a1 + 96));
            }
          }
        }
      }
    }
    else
    {
      err_GenerateErrorVersion();
    }
  }
  else
  {
    err_GenerateErrorData();
  }
}

uint64_t CDSHash_DecodeKey(uint64_t result, int a2, uint64_t a3)
{
  uint64_t v3 = (a2 - 1);
  if (a2 == 1)
  {
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v6 = *(void *)(result + 72);
    uint64_t v5 = *(void *)(result + 80);
    do
    {
      int v7 = 0;
      do
      {
        uint64_t v8 = (unsigned __int16)v7;
        int v9 = *(unsigned __int16 *)(v5 + 2 * (unsigned __int16)v7++);
      }
      while (v9 != *(unsigned __int16 *)(a3 + 2 * v4));
      *(_WORD *)(a3 + 2 * v4++) = *(_WORD *)(v6 + 2 * v8);
    }
    while (v4 != v3);
  }
  *(_WORD *)(a3 + 2 * v3) = 0;
  return result;
}

uint64_t CDSHash_GetInputHash(uint64_t a1, uint64_t a2, int a3, int *a4, unsigned int *a5)
{
  unsigned int v19 = 0;
  uint64_t v10 = ucs2len(a2);
  uint64_t v11 = v10 + 1;
  uint64_t v12 = OOCAllocator_Malloc(*(void *)(a1 + 104), 2 * (v10 + 1), &v19);
  if (v19) {
    return v19;
  }
  int v13 = (unsigned __int16 *)v12;
  if (v10)
  {
    unint64_t v14 = 0;
    while (1)
    {
      int v18 = 0;
      __int16 v17 = *(_WORD *)(a2 + 2 * v14);
      if (!v17)
      {
        uint64_t v11 = v14 + 1;
        goto LABEL_14;
      }
      if (lhstdlib_bsearch((uint64_t)&v17, *(void *)(a1 + 72), *(unsigned int *)(a1 + 64), 2uLL, (uint64_t (*)(uint64_t, unint64_t))CmpLH_U16, &v18))
      {
        unint64_t v15 = v14 + 1;
      }
      else
      {
        if (!a3 || !v14)
        {
          *a5 = 0;
          if (v13) {
            goto LABEL_19;
          }
          return v19;
        }
        unint64_t v15 = v14 + 1;
        uint64_t v11 = v14 + 1;
      }
      v13[v14] = *(_WORD *)(*(void *)(a1 + 80) + 2 * v18);
      unint64_t v14 = v15;
      if (v15 >= v11 - 1) {
        goto LABEL_14;
      }
    }
  }
  uint64_t v11 = 1;
LABEL_14:
  v13[v11 - 1] = *(_WORD *)(*(void *)(*(void *)(a1 + 96) + 8) + 8);
  if (!EHashTableFSM_HashLongestMatch(*(uint64_t **)(a1 + 56), v13, v11, a4, a5) && (!a3 || !*a5)) {
    *a5 = 0;
  }
LABEL_19:
  OOCAllocator_Free(*(void *)(a1 + 104), (uint64_t)v13);
  return v19;
}

uint64_t CmpLH_U16(unsigned __int16 *a1, unsigned __int16 *a2)
{
  unsigned int v2 = *a1;
  unsigned int v3 = *a2;
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t CDSHash_GetNbrKeyEntries(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 96) + 8) + 12) | (*(unsigned __int16 *)(*(void *)(*(void *)(a1 + 96) + 8) + 10) << 16);
}

uint64_t CDSHash_UnhashKey(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 32))(*(void *)(a1 + 56));
}

uint64_t PNEW_CDSHash_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 112, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = CDSHash_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *(void *)(v8 + 16) = a1;
      *a4 = v8;
    }
  }
  return result;
}

void *GetCDSHashClass()
{
  return &__CDSHash;
}

uint64_t CDSBase_Con(void *a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v8 = 0;
  uint64_t result = PNEW_BinBlockStreamReader_Con(a2, a2, a3, a4, a5, &v8);
  if (!result)
  {
    uint64_t result = CDSHash_Con((uint64_t)a1, a2, v8 + 32);
    if (!result)
    {
      *a1 = &__CDSBase;
      uint64_t result = _CDSBase_Init((uint64_t)a1, v8 + 32);
      if (!result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)v8 + 32))(v8);
      }
    }
  }
  return result;
}

uint64_t _CDSBase_Init(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 56))(a2 - *(void *)(*(void *)a2 + 224)) == 388438978)
  {
    unsigned int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2 - *(void *)(*(void *)a2 + 224));
    if (BinBlockStreamReader_IsVersionAccepted(v4, 0x10000))
    {
      uint64_t v7 = 0;
      uint64_t v8 = 0;
      uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a2)(a2 - *(void *)(*(void *)a2 + 224), 1096172613, 0, &v6);
      if (!result)
      {
        uint64_t result = PNEW_EHashTableFSM_Con2(*(void *)(a1 + 104), *(void *)(a1 + 104), v6, (uint64_t *)(a1 + 112));
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2 - *(void *)(*(void *)a2 + 224), v6);
          if (!result)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 224), *(void *)(a1 + 104), 1145128005, 0, 0x10000, a1 + 120, &v7);
            if (!result)
            {
              uint64_t result = PNEW_EBitMap_Con(*(void *)(a1 + 104), *(void *)(a1 + 120), (uint64_t *)(a1 + 128));
              if (!result)
              {
                uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t *, uint64_t *))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 224), *(void *)(a1 + 104), 1128547397, 0, 0x10000, &v8, &v7);
                if (!result)
                {
                  *(void *)(a1 + 136) = v8;
                  cstdlib_memcpy((void *)(a1 + 144), (const void *)(*(void *)(*(void *)(a1 + 96) + 8) + 18), 4uLL);
                  uint64_t result = 0;
                  *(unsigned char *)(a1 + 147) = 0;
                }
              }
            }
          }
        }
      }
    }
    else
    {
      return err_GenerateErrorVersion();
    }
  }
  else
  {
    return err_GenerateErrorData();
  }
  return result;
}

uint64_t CDSBase_Con2(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = CDSHash_Con((uint64_t)a1, a2, a3);
  if (!result)
  {
    *a1 = &__CDSBase;
    return _CDSBase_Init((uint64_t)a1, a3);
  }
  return result;
}

uint64_t CDSBase_Des(void *a1)
{
  OOCAllocator_Free(a1[13], a1[17]);
  OOCAllocator_Free(a1[13], a1[15]);
  uint64_t result = OOC_PlacementDeleteObject(a1[13], a1[16]);
  if (!result)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[13], a1[14]);
    if (!result)
    {
      return CDSHash_Des(a1);
    }
  }
  return result;
}

uint64_t CDSBase_GetFieldSeparator(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 96) + 8) + 2);
}

uint64_t CDSBase_GetNbrValueEntries(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 96) + 8) + 16) | (*(unsigned __int16 *)(*(void *)(*(void *)(a1 + 96) + 8) + 14) << 16);
}

uint64_t CDSBase_GetOutputString(uint64_t a1, uint64_t a2, int a3, uint64_t *a4, unsigned int *a5, int *a6, unsigned int *a7)
{
  int v26 = 0;
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  *a7 = 0;
  uint64_t result = CDSHash_GetInputHash(a1, a2, a3, &v26, a7);
  unsigned int v27 = result;
  if (!result)
  {
    if (!*a7) {
      return 0;
    }
    int v13 = **(unsigned __int16 **)(*(void *)(a1 + 96) + 8);
    uint64_t v14 = *(void *)(a1 + 128);
    *(void *)(v14 + 16) = (v26 * v13);
    uint64_t NBits = EBitMap_GetNBits(v14, v13);
    uint64_t v16 = OOCAllocator_Malloc(*(void *)(a1 + 104), 2 * *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 96) + 8) + 4), &v27);
    uint64_t result = v27;
    if (!v27)
    {
      unsigned int v17 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 112) + 32))(*(void *)(a1 + 112), NBits, v16);
      uint64_t v18 = OOCAllocator_Malloc(*(void *)(a1 + 104), v17 + 1, &v27);
      uint64_t result = v27;
      if (!v27)
      {
        if (v17)
        {
          int v19 = 0;
          unsigned int v20 = (unsigned char *)v18;
          int v21 = (unsigned __int16 *)v16;
          uint64_t v22 = v17;
          do
          {
            unsigned int v23 = *v21++;
            int v24 = *(char *)(*(void *)(a1 + 136) + v23);
            *v20++ = *(unsigned char *)(*(void *)(a1 + 136) + v23);
            if (*(char *)(*(void *)(*(void *)(a1 + 96) + 8) + 2) == v24) {
              ++v19;
            }
            --v22;
          }
          while (v22);
          int v25 = v19 + 1;
        }
        else
        {
          int v25 = 1;
          if (!v16)
          {
LABEL_15:
            *(unsigned char *)(v18 + v17) = 0;
            *a4 = v18;
            *a5 = v17;
            *a6 = v25;
            return v27;
          }
        }
        OOCAllocator_Free(*(void *)(a1 + 104), v16);
        goto LABEL_15;
      }
    }
  }
  return result;
}

uint64_t CDSBase_GetTranscriptionType(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 96) + 8) + 22);
}

uint64_t PNEW_CDSBase_Con(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5, void *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = (void *)OOCAllocator_Malloc(a1, 152, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = CDSBase_Con(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      v12[2] = a1;
      *a6 = v12;
    }
  }
  return result;
}

uint64_t PNEW_CDSBase_Con2(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = (void *)OOCAllocator_Malloc(a1, 152, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = CDSBase_Con2(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      v8[2] = a1;
      *a4 = v8;
    }
  }
  return result;
}

void *GetCDSBaseClass()
{
  return &__CDSBase;
}

uint64_t EBitMap_Con(uint64_t a1, uint64_t a2)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__EBitMap;
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 24) = 3;
  }
  return result;
}

uint64_t EBitMap_AlignAddr(uint64_t result, char a2)
{
  int v2 = *(_DWORD *)(result + 16);
  while ((v2++ & ~(-1 << a2)) != 0)
    ;
  *(void *)(result + 16) = (v2 - 1);
  return result;
}

uint64_t EBitMap_GetBit(uint64_t a1)
{
  return (*(unsigned __int8 *)(*(void *)(a1 + 8) + (*(void *)(a1 + 16) >> *(_DWORD *)(a1 + 24))) >> (*(void *)(a1 + 16) & 7)) & 1;
}

uint64_t EBitMap_GetBitIncAddr(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  unint64_t v1 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v1 + 1;
  return (*(unsigned __int8 *)(v2 + (v1 >> *(_DWORD *)(a1 + 24))) >> (v1 & 7)) & 1;
}

uint64_t EBitMap_GetNBitAddress(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = *(void *)(a1 + 16);
  unint64_t v4 = v3 >> *(_DWORD *)(a1 + 24);
  LODWORD(v3) = v3 & 7;
  unsigned int v5 = (0xFFu >> v3) & *(unsigned __int8 *)(v2 + v4);
  unsigned int v6 = v3 + a2;
  uint64_t v7 = (int)(v5 << (v6 - 8));
  unint64_t v8 = v6 - 17;
  if (v6 < 0x11)
  {
    LOBYTE(v14) = 16;
    uint64_t v9 = 1;
  }
  else
  {
    uint64_t v9 = (v8 >> 3) + 2;
    unsigned int v10 = (unsigned __int8 *)(v4 + v2 + 1);
    uint64_t v11 = (v8 >> 3) + 1;
    int v12 = -16;
    do
    {
      int v13 = *v10++;
      v7 += v13 << (v6 + v12);
      v12 -= 8;
      --v11;
    }
    while (v11);
    int v14 = -v12;
  }
  return v7 + (*(unsigned __int8 *)(v2 + v4 + v9) >> (v14 - v6));
}

uint64_t EBitMap_GetNBits(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 24);
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = v3 + a2;
  *(void *)(a1 + 16) = v4;
  if (v4 <= v3)
  {
    int v5 = 0;
  }
  else
  {
    int v5 = 0;
    unsigned int v6 = v3;
    do
    {
      v5 |= *(unsigned __int8 *)(*(void *)(a1 + 8) + ((unint64_t)v6 >> v2)) >> (v6 & 7) << (v6 - v3);
      unsigned int v6 = (v6 & 0xFFFFFFF8) + 8;
    }
    while (v6 < v4);
  }
  return v5 & ~(-1 << a2);
}

uint64_t PNEW_EBitMap_Con(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = OOCAllocator_Malloc(a1, 32, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = Object_Con((void *)v6);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *(void *)uint64_t v6 = &__EBitMap;
      *(void *)(v6 + 8) = a2;
      *(void *)(v6 + 16) = 0;
      *(_DWORD *)(v6 + 24) = 3;
      *a3 = v6;
    }
  }
  return result;
}

void *GetEBitMapClass()
{
  return &__EBitMap;
}

uint64_t EHuffmanBitmap_Con(void *a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t result = EHuffman_Con1(a1, a2, a3, a4, a5);
  if (!result) {
    *a1 = &__EHuffmanBitmap;
  }
  return result;
}

uint64_t EHuffmanBitmap_Con2(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = EHuffman_Con2(a1, a2, a3);
  if (!result) {
    *a1 = &__EHuffmanBitmap;
  }
  return result;
}

uint64_t _EHuffmanBitmap_ConInternal(void *a1, uint64_t a2)
{
  uint64_t result = _EHuffman_ConInternal(a1, a2);
  if (!result) {
    *a1 = &__EHuffmanBitmap;
  }
  return result;
}

uint64_t EHuffmanBitmap_CreateFromStreamInterruptible(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t result = _PNEW_EHuffmanBitmap_ConInternal(a1, a1, a3);
  if (!result)
  {
    uint64_t result = _EHuffman_InitInternal((uint64_t *)*a3, a2, a4);
    if (!result)
    {
      if (*a4 == 1)
      {
        uint64_t result = OOC_PlacementDeleteObject(a1, *a3);
        *a3 = 0;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t _PNEW_EHuffmanBitmap_ConInternal(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = (void *)OOCAllocator_Malloc(a1, 64, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = _EHuffman_ConInternal(v6, a2);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      void *v6 = &__EHuffmanBitmap;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t EHuffmanBitmap_Decode(uint64_t a1, uint64_t a2)
{
  EHuffman_Reset(a1);
  int v4 = *(_DWORD *)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 16) >> v4;
  uint64_t v6 = *(void *)(a2 + 16) & 7;
  while (EHuffman_Eat(a1))
  {
    if (v6 == 7)
    {
      ++v5;
      LODWORD(v6) = 0;
    }
    else
    {
      LODWORD(v6) = v6 + 1;
    }
  }
  *(void *)(a2 + 16) = ((v5 << v4) | v6) + 1;

  return EHuffman_GetResult(a1);
}

uint64_t PNEW_EHuffmanBitmap_Con(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5, void *a6)
{
  unsigned int v14 = 0;
  int v12 = (void *)OOCAllocator_Malloc(a1, 64, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = EHuffman_Con1(v12, a2, a3, a4, a5);
    if (result)
    {
      unsigned int v14 = result;
      OOCAllocator_Free(a1, (uint64_t)v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      void *v12 = &__EHuffmanBitmap;
      *a6 = v12;
    }
  }
  return result;
}

uint64_t PNEW_EHuffmanBitmap_Con2(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unsigned int v10 = 0;
  unsigned int v8 = (void *)OOCAllocator_Malloc(a1, 64, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = EHuffman_Con2(v8, a2, a3);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *unsigned int v8 = &__EHuffmanBitmap;
      *a4 = v8;
    }
  }
  return result;
}

void *GetEHuffmanBitmapClass()
{
  return &__EHuffmanBitmap;
}

uint64_t _EHashTable_Con(void *a1)
{
  uint64_t result = Object_Con(a1);
  if (!result) {
    *a1 = &__EHashTable;
  }
  return result;
}

void *GetEHashTableClass()
{
  return &__EHashTable;
}

uint64_t EHashTableFSM_Con(void *a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v11 = 0;
  uint64_t result = _EHashTable_Con(a1);
  if (!result)
  {
    *a1 = &__EHashTableFSM;
    a1[12] = a2;
    uint64_t result = PNEW_BinBlockStreamReader_Con(a2, a2, a3, a4, a5, &v11);
    if (!result)
    {
      uint64_t result = EHashTableFSM_Con2((uint64_t)a1, a1[12], v11 + 32);
      if (!result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)v11 + 32))(v11);
      }
    }
  }
  return result;
}

uint64_t EHashTableFSM_Con2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = _EHashTable_Con((void *)a1);
  if (!result)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    *(void *)a1 = &__EHashTableFSM;
    *(void *)(a1 + 96) = a2;
    uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a3)(a3 - *(void *)(*(void *)a3 + 224), 1313231686, 0, &v7);
    if (!result)
    {
      uint64_t result = PNEW_EHashTableFirstNode_Con2(*(void *)(a1 + 96), *(void *)(a1 + 96), v7, (uint64_t *)(a1 + 8));
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3 - *(void *)(*(void *)a3 + 224), v7);
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), *(void *)(a1 + 96), 1296192326, 0, 0x10000, a1 + 16, &v8);
          if (!result)
          {
            *(_DWORD *)(a1 + 32) = 8 * v8;
            uint64_t result = PNEW_EBitMap_Con(*(void *)(a1 + 96), *(void *)(a1 + 16), (uint64_t *)(a1 + 24));
            if (!result)
            {
              uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a3)(a3 - *(void *)(*(void *)a3 + 224), 1145656134, 0, &v7);
              if (!result)
              {
                uint64_t result = PNEW_EHuffmanBitmap_Con2(*(void *)(a1 + 96), *(void *)(a1 + 96), v7, (void *)(a1 + 40));
                if (!result)
                {
                  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3 - *(void *)(*(void *)a3 + 224), v7);
                  if (!result)
                  {
                    uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a3)(a3 - *(void *)(*(void *)a3 + 224), 1313166150, 0, &v7);
                    if (!result)
                    {
                      uint64_t result = PNEW_EHuffmanBitmap_Con2(*(void *)(a1 + 96), *(void *)(a1 + 96), v7, (void *)(a1 + 48));
                      if (!result)
                      {
                        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3 - *(void *)(*(void *)a3 + 224), v7);
                        if (!result)
                        {
                          uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a3)(a3 - *(void *)(*(void *)a3 + 224), 1179603782, 0, &v7);
                          if (!result)
                          {
                            uint64_t result = PNEW_EHuffmanBitmap_Con2(*(void *)(a1 + 96), *(void *)(a1 + 96), v7, (void *)(a1 + 56));
                            if (!result)
                            {
                              uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3 - *(void *)(*(void *)a3 + 224), v7);
                              if (!result)
                              {
                                uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a3)(a3 - *(void *)(*(void *)a3 + 224), 1095258950, 0, &v7);
                                if (!result)
                                {
                                  uint64_t result = PNEW_EHuffmanBitmap_Con2(*(void *)(a1 + 96), *(void *)(a1 + 96), v7, (void *)(a1 + 64));
                                  if (!result)
                                  {
                                    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3 - *(void *)(*(void *)a3 + 224), v7);
                                    if (!result)
                                    {
                                      uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a3)(a3 - *(void *)(*(void *)a3 + 224), 1229738822, 0, &v7);
                                      if (!result)
                                      {
                                        uint64_t result = PNEW_EHuffmanBitmap_Con2(*(void *)(a1 + 96), *(void *)(a1 + 96), v7, (void *)(a1 + 72));
                                        if (!result)
                                        {
                                          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3 - *(void *)(*(void *)a3 + 224), v7);
                                          if (!result)
                                          {
                                            uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), *(void *)(a1 + 96), 1329812294, 0, 0x10000, a1 + 80, &v8);
                                            if (!result) {
                                              return PNEW_FSMConstants_Con(*(void *)(a1 + 96), *(unsigned __int16 **)(a1 + 80), (uint64_t *)(a1 + 88));
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

double _EHashTableFSM_ConInternal(uint64_t a1, uint64_t a2)
{
  if (!_EHashTable_Con((void *)a1))
  {
    *(void *)a1 = &__EHashTableFSM;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    double result = 0.0;
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
    *(_OWORD *)(a1 + 72) = 0u;
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 96) = a2;
  }
  return result;
}

uint64_t EHashTableFSM_Des(void *a1)
{
  uint64_t result = _EHashTableFSM_Cleanup(a1);
  if (!result)
  {
    return Object_Des();
  }
  return result;
}

uint64_t _EHashTableFSM_Cleanup(void *a1)
{
  uint64_t v2 = a1[11];
  if (v2)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[12], v2);
    if (result) {
      return result;
    }
    a1[11] = 0;
  }
  OOCAllocator_Free(a1[12], a1[10]);
  a1[10] = 0;
  uint64_t v4 = a1[9];
  if (v4)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[12], v4);
    if (result) {
      return result;
    }
    a1[9] = 0;
  }
  uint64_t v5 = a1[8];
  if (v5)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[12], v5);
    if (result) {
      return result;
    }
    a1[8] = 0;
  }
  uint64_t v6 = a1[7];
  if (v6)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[12], v6);
    if (result) {
      return result;
    }
    a1[7] = 0;
  }
  uint64_t v7 = a1[6];
  if (v7)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[12], v7);
    if (result) {
      return result;
    }
    a1[6] = 0;
  }
  uint64_t v8 = a1[5];
  if (v8)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[12], v8);
    if (result) {
      return result;
    }
    a1[5] = 0;
  }
  uint64_t v9 = a1[3];
  if (v9)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[12], v9);
    if (result) {
      return result;
    }
    a1[3] = 0;
  }
  OOCAllocator_Free(a1[12], a1[2]);
  a1[2] = 0;
  uint64_t v10 = a1[1];
  if (!v10) {
    return 0;
  }
  uint64_t result = OOC_PlacementDeleteObject(a1[12], v10);
  if (!result) {
    a1[1] = 0;
  }
  return result;
}

uint64_t EHashTableFSM_Archive(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 8))(a2 - *(void *)(*(void *)a2 + 120), 1313231686, 0x10000, 3, &v8);
  if (!result)
  {
    uint64_t result = EHashTableFirstNode_Archive(*(void *)(a1 + 8), v8);
    if (!result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 120), v8);
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 32))(a2 - *(void *)(*(void *)a2 + 120), 1296192326, 0x10000, &v7);
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, void, unint64_t))(*(void *)v7 + 8))(v7 - *(void *)(*(void *)v7 + 56), *(void *)(a1 + 16), (unint64_t)*(unsigned int *)(a1 + 32) >> 3);
          if (!result)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 120), v7);
            if (!result)
            {
              uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 8))(a2 - *(void *)(*(void *)a2 + 120), 1145656134, 0x10000, 2, &v8);
              if (!result)
              {
                uint64_t result = EHuffman_Archive(*(void *)(a1 + 40), v8);
                if (!result)
                {
                  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 120), v8);
                  if (!result)
                  {
                    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 8))(a2 - *(void *)(*(void *)a2 + 120), 1313166150, 0x10000, 2, &v8);
                    if (!result)
                    {
                      uint64_t result = EHuffman_Archive(*(void *)(a1 + 48), v8);
                      if (!result)
                      {
                        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 120), v8);
                        if (!result)
                        {
                          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 8))(a2 - *(void *)(*(void *)a2 + 120), 1179603782, 0x10000, 2, &v8);
                          if (!result)
                          {
                            uint64_t result = EHuffman_Archive(*(void *)(a1 + 56), v8);
                            if (!result)
                            {
                              uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 120), v8);
                              if (!result)
                              {
                                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 8))(a2 - *(void *)(*(void *)a2 + 120), 1095258950, 0x10000, 2, &v8);
                                if (!result)
                                {
                                  uint64_t result = EHuffman_Archive(*(void *)(a1 + 64), v8);
                                  if (!result)
                                  {
                                    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 120), v8);
                                    if (!result)
                                    {
                                      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 8))(a2 - *(void *)(*(void *)a2 + 120), 1229738822, 0x10000, 2, &v8);
                                      if (!result)
                                      {
                                        uint64_t result = EHuffman_Archive(*(void *)(a1 + 72), v8);
                                        if (!result)
                                        {
                                          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 120), v8);
                                          if (!result)
                                          {
                                            uint64_t v5 = 0;
                                            uint64_t v6 = 0;
                                            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 32))(a2 - *(void *)(*(void *)a2 + 120), 1329812294, 0x10000, &v7);
                                            if (!result)
                                            {
                                              uint64_t result = FSMConstants_GetBuffer(*(void *)(a1 + 88), *(void *)(a1 + 96), &v6, &v5);
                                              if (!result)
                                              {
                                                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 8))(v7 - *(void *)(*(void *)v7 + 56), v6, v5);
                                                if (!result)
                                                {
                                                  OOCAllocator_Free(*(void *)(a1 + 96), v6);
                                                  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 120), v7);
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void EHashTableFSM_CreateFromStreamInterruptible(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  _PNEW_EHashTableFSM_ConInternal(a1, a1, a3);
  if (!v8
    && !_EHashTableFSM_InitInternal(*a3, a2, a4)
    && *a4
    && !OOC_PlacementDeleteObject(a1, *a3))
  {
    *a3 = 0;
  }
}

double _PNEW_EHashTableFSM_ConInternal(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int v9 = 0;
  uint64_t v6 = OOCAllocator_Malloc(a1, 104, &v9);
  if (!v9)
  {
    int v8 = _EHashTable_Con((void *)v6);
    if (v8)
    {
      int v9 = v8;
      OOCAllocator_Free(a1, v6);
      *a3 = 0;
    }
    else
    {
      *(void *)uint64_t v6 = &__EHashTableFSM;
      *(void *)(v6 + 8) = 0;
      *(void *)(v6 + 16) = 0;
      *(void *)(v6 + 24) = 0;
      double result = 0.0;
      *(_OWORD *)(v6 + 40) = 0u;
      *(_OWORD *)(v6 + 56) = 0u;
      *(_OWORD *)(v6 + 72) = 0u;
      *(void *)(v6 + 88) = 0;
      *(void *)(v6 + 96) = a2;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t _EHashTableFSM_InitInternal(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *, _DWORD *))a2)(a2 - *(void *)(*(void *)a2 + 208), 1313231686, 0, &v11, a3);
  if (result) {
    return result;
  }
  if (!*a3)
  {
    uint64_t result = EHashTableFirstNode_CreateFromStreamInterruptible(*(void *)(a1 + 96), v11, (uint64_t *)(a1 + 8), a3);
    if (result) {
      return result;
    }
  }
  if (v11)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2 - *(void *)(*(void *)a2 + 208));
    if (result) {
      return result;
    }
    uint64_t v11 = 0;
  }
  if (!*a3)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t *, _DWORD *))(*(void *)a2 + 64))(a2 - *(void *)(*(void *)a2 + 208), *(void *)(a1 + 96), 1296192326, 0, 0x10000, a1 + 16, &v12, a3);
    if (result) {
      return result;
    }
    if (!*a3)
    {
      *(_DWORD *)(a1 + 32) = 8 * v12;
      uint64_t result = PNEW_EBitMap_Con(*(void *)(a1 + 96), *(void *)(a1 + 16), (uint64_t *)(a1 + 24));
      if (result) {
        return result;
      }
      uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *, _DWORD *))a2)(a2 - *(void *)(*(void *)a2 + 208), 1145656134, 0, &v11, a3);
      if (result) {
        return result;
      }
      if (!*a3)
      {
        uint64_t result = EHuffmanBitmap_CreateFromStreamInterruptible(*(void *)(a1 + 96), v11, (uint64_t *)(a1 + 40), a3);
        if (result) {
          return result;
        }
      }
    }
  }
  if (v11)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2 - *(void *)(*(void *)a2 + 208));
    if (result) {
      return result;
    }
    uint64_t v11 = 0;
  }
  if (*a3) {
    return _EHashTableFSM_Cleanup((void *)a1);
  }
  uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *, _DWORD *))a2)(a2 - *(void *)(*(void *)a2 + 208), 1313166150, 0, &v11, a3);
  if (result) {
    return result;
  }
  uint64_t v7 = v11;
  if (*a3)
  {
    if (!v11) {
      goto LABEL_29;
    }
    goto LABEL_25;
  }
  uint64_t result = EHuffmanBitmap_CreateFromStreamInterruptible(*(void *)(a1 + 96), v11, (uint64_t *)(a1 + 48), a3);
  if (result) {
    return result;
  }
  uint64_t v7 = v11;
  if (v11)
  {
LABEL_25:
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2 - *(void *)(*(void *)a2 + 208), v7);
    if (result) {
      return result;
    }
    uint64_t v11 = 0;
  }
LABEL_29:
  if (*a3) {
    return _EHashTableFSM_Cleanup((void *)a1);
  }
  uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *, _DWORD *))a2)(a2 - *(void *)(*(void *)a2 + 208), 1179603782, 0, &v11, a3);
  if (result) {
    return result;
  }
  uint64_t v8 = v11;
  if (*a3)
  {
    if (!v11) {
      goto LABEL_37;
    }
    goto LABEL_33;
  }
  uint64_t result = EHuffmanBitmap_CreateFromStreamInterruptible(*(void *)(a1 + 96), v11, (uint64_t *)(a1 + 56), a3);
  if (result) {
    return result;
  }
  uint64_t v8 = v11;
  if (v11)
  {
LABEL_33:
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2 - *(void *)(*(void *)a2 + 208), v8);
    if (result) {
      return result;
    }
    uint64_t v11 = 0;
  }
LABEL_37:
  if (*a3) {
    return _EHashTableFSM_Cleanup((void *)a1);
  }
  uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *, _DWORD *))a2)(a2 - *(void *)(*(void *)a2 + 208), 1095258950, 0, &v11, a3);
  if (result) {
    return result;
  }
  uint64_t v9 = v11;
  if (*a3)
  {
    if (!v11) {
      goto LABEL_45;
    }
    goto LABEL_41;
  }
  uint64_t result = EHuffmanBitmap_CreateFromStreamInterruptible(*(void *)(a1 + 96), v11, (uint64_t *)(a1 + 64), a3);
  if (result) {
    return result;
  }
  uint64_t v9 = v11;
  if (v11)
  {
LABEL_41:
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2 - *(void *)(*(void *)a2 + 208), v9);
    if (result) {
      return result;
    }
    uint64_t v11 = 0;
  }
LABEL_45:
  if (*a3) {
    return _EHashTableFSM_Cleanup((void *)a1);
  }
  uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *, _DWORD *))a2)(a2 - *(void *)(*(void *)a2 + 208), 1229738822, 0, &v11, a3);
  if (!result)
  {
    uint64_t v10 = v11;
    if (*a3)
    {
      if (!v11)
      {
LABEL_53:
        if (*a3) {
          return _EHashTableFSM_Cleanup((void *)a1);
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t *, _DWORD *))(*(void *)a2 + 64))(a2 - *(void *)(*(void *)a2 + 208), *(void *)(a1 + 96), 1329812294, 0, 0x10000, a1 + 80, &v12, a3);
        if (!result)
        {
          if (*a3) {
            return _EHashTableFSM_Cleanup((void *)a1);
          }
          uint64_t result = PNEW_FSMConstants_Con(*(void *)(a1 + 96), *(unsigned __int16 **)(a1 + 80), (uint64_t *)(a1 + 88));
          if (!result)
          {
            if (*a3) {
              return _EHashTableFSM_Cleanup((void *)a1);
            }
            return 0;
          }
        }
        return result;
      }
    }
    else
    {
      uint64_t result = EHuffmanBitmap_CreateFromStreamInterruptible(*(void *)(a1 + 96), v11, (uint64_t *)(a1 + 72), a3);
      if (result) {
        return result;
      }
      uint64_t v10 = v11;
      if (!v11) {
        goto LABEL_53;
      }
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2 - *(void *)(*(void *)a2 + 208), v10);
    if (result) {
      return result;
    }
    uint64_t v11 = 0;
    goto LABEL_53;
  }
  return result;
}

uint64_t EHashTableFSM_Hash(uint64_t *a1, unsigned __int16 *a2, unsigned int a3, int *a4)
{
  return EHashTableFSM_HashLongestMatch(a1, a2, a3, a4, 0);
}

uint64_t EHashTableFSM_HashLongestMatch(uint64_t *a1, unsigned __int16 *a2, unsigned int a3, int *a4, unsigned int *a5)
{
  unsigned int v53 = 0;
  *a4 = 0;
  if (a5) {
    *a5 = 0;
  }
  uint64_t result = EHashTableFirstNode_Hash(a1[1], *a2, a4, &v53);
  if (result)
  {
    unsigned int v11 = v53;
    uint64_t v12 = a1[11];
    if (v53 <= *(unsigned __int8 *)(v12 + 18))
    {
      unsigned int v11 = *(_DWORD *)(v12 + 8);
      unsigned int v53 = v11;
    }
    if (a3 == 1) {
      return 1;
    }
    unsigned int v47 = a3 - 1;
    long long v48 = a5;
    if (a3)
    {
      long long v50 = a2;
      int v13 = 0;
      unsigned int v14 = *(unsigned __int16 *)(v12 + 14);
      unsigned int v51 = *(unsigned __int16 *)(v12 + 12);
      unsigned int v52 = 0;
      unsigned int v15 = 1;
      unint64_t v16 = v11;
      unsigned int v49 = a3;
      while (1)
      {
        uint64_t v17 = a1[3];
        *(void *)(v17 + 16) = v16;
        unsigned int v18 = EHuffmanBitmap_Decode(a1[5], v17);
        unsigned int v19 = v18;
        if (v18 < v51) {
          break;
        }
        if (v18 != v51)
        {
          if (v18 - v51 <= 1) {
            int v22 = 1;
          }
          else {
            int v22 = v18 - v51;
          }
          unsigned int v23 = v15 + v22;
          do
          {
            unsigned int v24 = v14;
            if (v15 < a3) {
              unsigned int v24 = v50[v15];
            }
            unsigned __int16 v25 = EHuffmanBitmap_Decode(a1[6], a1[3]);
            if (v14 == v25)
            {
              int v13 = *a4;
              unsigned int v52 = v15;
            }
            if (v24 != v25) {
              goto LABEL_77;
            }
            ++v15;
            --v22;
          }
          while (v22);
          unsigned int v15 = v23;
        }
        if (v15 == a3) {
          goto LABEL_75;
        }
        unint64_t v26 = EHuffmanBitmap_Decode(a1[9], a1[3]);
        unint64_t v16 = v26;
        uint64_t v27 = a1[11];
        unint64_t v28 = *(unsigned __int8 *)(v27 + 18);
        if (v26 > v28) {
          unint64_t v16 = v26 << *(unsigned char *)(v27 + 16);
        }
        if (v16)
        {
          if (v16 <= v28)
          {
            uint64_t v29 = a1[3];
LABEL_70:
            EBitMap_AlignAddr(v29, *(unsigned char *)(v27 + 16));
            unint64_t v16 = *(void *)(a1[3] + 16);
          }
        }
        else
        {
          int LeafWidth = EHuffman_GetLeafWidth(a1[9]);
          unint64_t v16 = EBitMap_GetNBits(a1[3], LeafWidth) << *(unsigned char *)(a1[11] + 16);
        }
LABEL_71:
        if (v15 > a3)
        {
          unsigned int v11 = v53;
          goto LABEL_74;
        }
      }
      unsigned int v20 = v14;
      if (v15 < a3) {
        unsigned int v20 = v50[v15];
      }
      int v21 = EHuffmanBitmap_Decode(a1[6], a1[3]);
      if (v14 == (unsigned __int16)v21)
      {
        int v13 = *a4;
        if (v20 == v14)
        {
          unsigned int v52 = v15;
LABEL_43:
          unsigned int v35 = 1;
          if (v19 >= 2)
          {
            while (1)
            {
              if (v20 <= (unsigned __int16)v21) {
                goto LABEL_57;
              }
              v21 += EHuffmanBitmap_Decode(a1[7], a1[3]);
              if (v14 != (unsigned __int16)v21) {
                break;
              }
              int v13 = *a4;
              if (v14 != v20)
              {
                int v39 = v13 + 1;
                unsigned int v52 = v15;
LABEL_55:
                *a4 = v39;
                goto LABEL_56;
              }
              unsigned int v52 = v15;
LABEL_56:
              if (++v35 >= v19) {
                goto LABEL_57;
              }
            }
            unint64_t v36 = EHuffmanBitmap_Decode(a1[9], a1[3]);
            unint64_t v16 = v36;
            uint64_t v37 = a1[11];
            if (v36 > *(unsigned __int8 *)(v37 + 18)) {
              unint64_t v16 = v36 << *(unsigned char *)(v37 + 16);
            }
            if (!v16)
            {
              int v38 = EHuffman_GetLeafWidth(a1[9]);
              unint64_t v16 = EBitMap_GetNBits(a1[3], v38) << *(unsigned char *)(a1[11] + 16);
            }
            if (v20 == (unsigned __int16)v21) {
              goto LABEL_56;
            }
            int v39 = *a4 + EHuffmanBitmap_Decode(a1[8], a1[3]);
            goto LABEL_55;
          }
LABEL_57:
          if (v20 != (unsigned __int16)v21) {
            goto LABEL_77;
          }
          ++v15;
          a3 = v49;
          if (v15 == v49) {
            goto LABEL_75;
          }
          if (v16 > *(unsigned __int8 *)(a1[11] + 18)) {
            goto LABEL_71;
          }
          EHuffmanBitmap_Decode(a1[8], a1[3]);
          BOOL v40 = v19 >= v35;
          unsigned int v41 = v19 - v35;
          if (v41 != 0 && v40)
          {
            do
            {
              v20 += EHuffmanBitmap_Decode(a1[7], a1[3]);
              if (v14 != (unsigned __int16)v20)
              {
                unint64_t v42 = EHuffmanBitmap_Decode(a1[9], a1[3]);
                uint64_t v43 = a1[11];
                if (v42 > *(unsigned __int8 *)(v43 + 18)) {
                  v42 <<= *(unsigned char *)(v43 + 16);
                }
                if (!v42)
                {
                  int v44 = EHuffman_GetLeafWidth(a1[9]);
                  EBitMap_GetNBits(a1[3], v44);
                }
                EHuffmanBitmap_Decode(a1[8], a1[3]);
              }
              --v41;
            }
            while (v41);
          }
          uint64_t v29 = a1[3];
          uint64_t v27 = a1[11];
          goto LABEL_70;
        }
        int v33 = v13 + 1;
        unsigned int v52 = v15;
      }
      else
      {
        unint64_t v30 = EHuffmanBitmap_Decode(a1[9], a1[3]);
        unint64_t v16 = v30;
        uint64_t v31 = a1[11];
        if (v30 > *(unsigned __int8 *)(v31 + 18)) {
          unint64_t v16 = v30 << *(unsigned char *)(v31 + 16);
        }
        if (!v16)
        {
          int v32 = EHuffman_GetLeafWidth(a1[9]);
          unint64_t v16 = EBitMap_GetNBits(a1[3], v32) << *(unsigned char *)(a1[11] + 16);
        }
        if (v20 == (unsigned __int16)v21) {
          goto LABEL_43;
        }
        int v33 = *a4 + EHuffmanBitmap_Decode(a1[8], a1[3]);
      }
      *a4 = v33;
      goto LABEL_43;
    }
    int v13 = 0;
    unsigned int v52 = 0;
LABEL_74:
    if (v11 == 1)
    {
LABEL_75:
      long long v45 = v48;
      if (!v48) {
        return 1;
      }
      uint64_t result = 1;
      unsigned int v46 = v47;
    }
    else
    {
LABEL_77:
      uint64_t result = 0;
      *a4 = v13;
      long long v45 = v48;
      unsigned int v46 = v52;
      if (!v48) {
        return result;
      }
    }
    *long long v45 = v46;
  }
  return result;
}

unint64_t _EHashTableFSM_DecodeLink(uint64_t *a1)
{
  unint64_t result = EHuffmanBitmap_Decode(a1[9], a1[3]);
  uint64_t v3 = a1[11];
  if (result > *(unsigned __int8 *)(v3 + 18)) {
    result <<= *(unsigned char *)(v3 + 16);
  }
  return result;
}

uint64_t _EHashTableFSM_GetAddress(uint64_t *a1)
{
  int LeafWidth = EHuffman_GetLeafWidth(a1[9]);
  return EBitMap_GetNBits(a1[3], LeafWidth) << *(unsigned char *)(a1[11] + 16);
}

uint64_t EHashTableFSM_Unhash(uint64_t *a1, unsigned int a2, _WORD *a3)
{
  uint64_t v3 = a3;
  unsigned int v47 = 0;
  unsigned int v48 = a2;
  EHashTableFirstNode_Unhash(a1[1], &v48, a3, &v47);
  unsigned int v5 = v47;
  uint64_t v6 = a1[11];
  if (v47 <= *(unsigned __int8 *)(v6 + 18))
  {
    uint64_t v7 = *(unsigned int *)(v6 + 8);
    *(void *)(a1[3] + 16) = v7;
    if (v5 >= 2)
    {
      unsigned int v8 = 1;
      do
      {
        _EHashTableFSM_SkipState(a1);
        ++v8;
      }
      while (v8 < v47);
      LODWORD(v7) = *(_DWORD *)(a1[3] + 16);
      uint64_t v6 = a1[11];
    }
    unsigned int v47 = v7;
    unsigned int v5 = v7;
  }
  int v9 = *(unsigned __int16 *)(v6 + 14);
  unsigned int v10 = *(unsigned __int16 *)(v6 + 12);
  uint64_t v11 = 1;
  unint64_t v12 = v5;
  int v44 = v3;
  unsigned int v43 = v10;
  do
  {
    while (1)
    {
      while (1)
      {
        uint64_t v13 = a1[3];
        *(void *)(v13 + 16) = v12;
        unsigned int v14 = EHuffmanBitmap_Decode(a1[5], v13);
        if (v14 >= v10) {
          break;
        }
        if (!v14)
        {
          uint64_t v34 = v11;
          goto LABEL_67;
        }
        int v15 = 0;
        int v16 = 0;
        unsigned int v46 = v14;
        unsigned int v17 = v14 - 1;
        while (1)
        {
          uint64_t v18 = v16 ? 56 : 48;
          v15 += EHuffmanBitmap_Decode(*(uint64_t *)((char *)a1 + v18), a1[3]);
          if (v9 == (unsigned __int16)v15)
          {
            unint64_t v19 = 1;
          }
          else
          {
            unint64_t v20 = EHuffmanBitmap_Decode(a1[9], a1[3]);
            unint64_t v12 = v20;
            uint64_t v21 = a1[11];
            if (v20 > *(unsigned __int8 *)(v21 + 18)) {
              unint64_t v12 = v20 << *(unsigned char *)(v21 + 16);
            }
            if (!v12)
            {
              int LeafWidth = EHuffman_GetLeafWidth(a1[9]);
              unint64_t v12 = EBitMap_GetNBits(a1[3], LeafWidth) << *(unsigned char *)(a1[11] + 16);
            }
            unint64_t v19 = EHuffmanBitmap_Decode(a1[8], a1[3]);
            if (v19 >= v48)
            {
              uint64_t v23 = a1[11];
              if (v12 <= *(unsigned __int8 *)(v23 + 18))
              {
                uint64_t v24 = a1[3];
                uint64_t v45 = *(void *)(v24 + 16);
                if (v16 + 1 < v46)
                {
                  unsigned int v25 = v17;
                  int v26 = v15;
                  do
                  {
                    v26 += EHuffmanBitmap_Decode(a1[7], a1[3]);
                    if (v9 != (unsigned __int16)v26)
                    {
                      unint64_t v27 = EHuffmanBitmap_Decode(a1[9], a1[3]);
                      uint64_t v28 = a1[11];
                      if (v27 > *(unsigned __int8 *)(v28 + 18)) {
                        v27 <<= *(unsigned char *)(v28 + 16);
                      }
                      if (!v27)
                      {
                        int v29 = EHuffman_GetLeafWidth(a1[9]);
                        EBitMap_GetNBits(a1[3], v29);
                      }
                      EHuffmanBitmap_Decode(a1[8], a1[3]);
                    }
                    --v25;
                  }
                  while (v25);
                  uint64_t v24 = a1[3];
                  uint64_t v23 = a1[11];
                }
                EBitMap_AlignAddr(v24, *(unsigned char *)(v23 + 16));
                if (v12 >= 2)
                {
                  unsigned int v30 = 2;
                  do
                    _EHashTableFSM_SkipState(a1);
                  while (v12 > v30++);
                }
                uint64_t v32 = a1[3];
                unint64_t v12 = *(void *)(v32 + 16);
                *(void *)(v32 + 16) = v45;
              }
            }
          }
          unsigned int v33 = v48;
          if (v19 >= v48) {
            break;
          }
          v48 -= v19;
          ++v16;
          --v17;
          if (v16 == v46)
          {
            uint64_t v34 = v11;
            uint64_t v3 = v44;
            unsigned int v10 = v43;
            goto LABEL_67;
          }
        }
        uint64_t v3 = v44;
        if (v44) {
          v44[v11] = v15;
        }
        *(void *)(a1[3] + 16) = v12;
        unsigned int v10 = v43;
        if (v9 != (unsigned __int16)v15)
        {
          uint64_t v34 = (v11 + 1);
          goto LABEL_67;
        }
        unsigned int v48 = v33 - 1;
        if (v33 == 1) {
          return v11;
        }
      }
      if (v14 != v10) {
        break;
      }
LABEL_49:
      --v48;
      uint64_t v11 = (v11 - 1);
      if (!v48) {
        return v11;
      }
    }
    if (v14 - v10 <= 1) {
      int v35 = 1;
    }
    else {
      int v35 = v14 - v10;
    }
    uint64_t v34 = (v11 + v35);
    do
    {
      unsigned __int16 v36 = EHuffmanBitmap_Decode(a1[6], a1[3]);
      if (v3) {
        v3[v11] = v36;
      }
      LODWORD(v11) = v11 + 1;
      --v35;
    }
    while (v35);
    if (v9 == v36)
    {
      LODWORD(v11) = v34;
      goto LABEL_49;
    }
    unint64_t v37 = EHuffmanBitmap_Decode(a1[9], a1[3]);
    unint64_t v12 = v37;
    uint64_t v38 = a1[11];
    unint64_t v39 = *(unsigned __int8 *)(v38 + 18);
    if (v37 > v39) {
      unint64_t v12 = v37 << *(unsigned char *)(v38 + 16);
    }
    if (v12)
    {
      if (v12 <= v39)
      {
        EBitMap_AlignAddr(a1[3], *(unsigned char *)(v38 + 16));
        if (v12 >= 2)
        {
          unsigned int v40 = 1;
          do
          {
            _EHashTableFSM_SkipState(a1);
            ++v40;
          }
          while (v40 < v12);
        }
        unint64_t v12 = *(void *)(a1[3] + 16);
      }
    }
    else
    {
      int v41 = EHuffman_GetLeafWidth(a1[9]);
      unint64_t v12 = EBitMap_GetNBits(a1[3], v41) << *(unsigned char *)(a1[11] + 16);
    }
LABEL_67:
    uint64_t v11 = v34;
  }
  while (v48);
  return v11;
}

uint64_t _EHashTableFSM_SkipState(uint64_t *a1)
{
  unsigned int v2 = EHuffmanBitmap_Decode(a1[5], a1[3]);
  uint64_t v3 = a1[11];
  int v4 = *(unsigned __int16 *)(v3 + 14);
  LODWORD(v3) = *(unsigned __int16 *)(v3 + 12);
  BOOL v5 = v2 >= v3;
  unsigned int v6 = v2 - v3;
  if (v5)
  {
    if (v6)
    {
      int v15 = v6 <= 1 ? 1 : v6;
      do
      {
        unsigned __int16 v16 = EHuffmanBitmap_Decode(a1[6], a1[3]);
        --v15;
      }
      while (v15);
      if (v4 != v16)
      {
        unint64_t v17 = EHuffmanBitmap_Decode(a1[9], a1[3]);
        uint64_t v18 = a1[11];
        if (v17 > *(unsigned __int8 *)(v18 + 18)) {
          v17 <<= *(unsigned char *)(v18 + 16);
        }
        if (!v17)
        {
          int LeafWidth = EHuffman_GetLeafWidth(a1[9]);
          EBitMap_GetNBits(a1[3], LeafWidth);
        }
      }
    }
  }
  else
  {
    unsigned __int16 v7 = EHuffmanBitmap_Decode(a1[6], a1[3]);
    if (v4 != v7)
    {
      unint64_t v8 = EHuffmanBitmap_Decode(a1[9], a1[3]);
      uint64_t v9 = a1[11];
      if (v8 > *(unsigned __int8 *)(v9 + 18)) {
        v8 <<= *(unsigned char *)(v9 + 16);
      }
      if (!v8)
      {
        int v10 = EHuffman_GetLeafWidth(a1[9]);
        EBitMap_GetNBits(a1[3], v10);
      }
      EHuffmanBitmap_Decode(a1[8], a1[3]);
    }
    if (v2 >= 2)
    {
      unsigned int v11 = v2 - 1;
      do
      {
        v7 += EHuffmanBitmap_Decode(a1[7], a1[3]);
        if (v4 != v7)
        {
          unint64_t v12 = EHuffmanBitmap_Decode(a1[9], a1[3]);
          uint64_t v13 = a1[11];
          if (v12 > *(unsigned __int8 *)(v13 + 18)) {
            v12 <<= *(unsigned char *)(v13 + 16);
          }
          if (!v12)
          {
            int v14 = EHuffman_GetLeafWidth(a1[9]);
            EBitMap_GetNBits(a1[3], v14);
          }
          EHuffmanBitmap_Decode(a1[8], a1[3]);
        }
        --v11;
      }
      while (v11);
    }
  }
  uint64_t v20 = a1[3];
  char v21 = *(unsigned char *)(a1[11] + 16);

  return EBitMap_AlignAddr(v20, v21);
}

uint64_t PNEW_EHashTableFSM_Con(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5, void *a6)
{
  unsigned int v14 = 0;
  unint64_t v12 = (void *)OOCAllocator_Malloc(a1, 104, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = EHashTableFSM_Con(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *a6 = v12;
    }
  }
  return result;
}

uint64_t PNEW_EHashTableFSM_Con2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 104, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = EHashTableFSM_Con2(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

void *GetEHashTableFSMClass()
{
  return &__EHashTableFSM;
}

uint64_t EHashTableFirstNode_Con(void *a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v11 = 0;
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__EHashTableFirstNode;
    uint64_t result = PNEW_BinBlockStreamReader_Con(a2, a2, a3, a4, a5, &v11);
    if (!result)
    {
      uint64_t result = EHashTableFirstNode_Con2((uint64_t)a1, a2, v11 + 32);
      if (!result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)v11 + 32))(v11);
      }
    }
  }
  return result;
}

uint64_t EHashTableFirstNode_Con2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    unint64_t v8 = 0;
    *(void *)a1 = &__EHashTableFirstNode;
    *(void *)(a1 + 48) = a2;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t, unint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), a2, 1313164870, 0, 0x10000, a1 + 16, &v8);
    if (!result)
    {
      *(_DWORD *)(a1 + 8) = v8 >> 1;
      uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, unint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), *(void *)(a1 + 48), 1414745670, 0, 0x10000, a1 + 24, &v8);
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, unint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), *(void *)(a1 + 48), 1095257670, 0, 0x10000, a1 + 40, &v8);
        if (!result)
        {
          unint64_t v7 = 4 * (unint64_t)*(unsigned int *)(a1 + 8) / v8;
          *(_DWORD *)(a1 + 32) = v7;
          if ((v7 - 1) >= 2) {
            return err_GenerateErrorData();
          }
          else {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t _EHashTableFirstNode_ConInternal(void *a1, uint64_t a2)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__EHashTableFirstNode;
    a1[5] = 0;
    a1[6] = a2;
    a1[2] = 0;
    a1[3] = 0;
  }
  return result;
}

uint64_t EHashTableFirstNode_Des(uint64_t *a1)
{
  _EHashTableFirstNode_Cleanup(a1);

  return Object_Des();
}

uint64_t _EHashTableFirstNode_Cleanup(uint64_t *a1)
{
  a1[5] = 0;
  OOCAllocator_Free(a1[6], a1[3]);
  a1[3] = 0;
  OOCAllocator_Free(a1[6], a1[2]);
  a1[2] = 0;
  return 0;
}

uint64_t EHashTableFirstNode_Archive(uint64_t a1, uint64_t a2)
{
  unsigned int v12 = 0;
  uint64_t v11 = 0;
  uint64_t v4 = 2 * *(unsigned int *)(a1 + 8);
  BOOL v5 = (void *)OOCAllocator_Malloc(*(void *)(a1 + 48), v4, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    cstdlib_memcpy(v5, *(const void **)(a1 + 16), v4);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 32))(a2 - *(void *)(*(void *)a2 + 120), 1313164870, 0x10000, &v11);
    unsigned int v12 = result;
    if (!result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)v11 + 8))(v11 - *(void *)(*(void *)v11 + 56), v5, v4);
      unsigned int v12 = result;
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 120), v11);
        unsigned int v12 = result;
        if (!result)
        {
          OOCAllocator_Free(*(void *)(a1 + 48), (uint64_t)v5);
          uint64_t v7 = 4 * *(unsigned int *)(a1 + 8);
          unint64_t v8 = (void *)OOCAllocator_Malloc(*(void *)(a1 + 48), v7, &v12);
          uint64_t result = v12;
          if (!v12)
          {
            cstdlib_memcpy(v8, *(const void **)(a1 + 24), v7);
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 32))(a2 - *(void *)(*(void *)a2 + 120), 1414745670, 0x10000, &v11);
            unsigned int v12 = result;
            if (!result)
            {
              uint64_t result = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)v11 + 8))(v11 - *(void *)(*(void *)v11 + 56), v8, v7);
              unsigned int v12 = result;
              if (!result)
              {
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 120), v11);
                unsigned int v12 = result;
                if (!result)
                {
                  OOCAllocator_Free(*(void *)(a1 + 48), (uint64_t)v8);
                  unint64_t v9 = 4 * (unint64_t)*(unsigned int *)(a1 + 8) / *(unsigned int *)(a1 + 32);
                  unsigned int v10 = (void *)OOCAllocator_Malloc(*(void *)(a1 + 48), v9, &v12);
                  uint64_t result = v12;
                  if (!v12)
                  {
                    cstdlib_memcpy(v10, *(const void **)(a1 + 40), v9);
                    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 32))(a2 - *(void *)(*(void *)a2 + 120), 1095257670, 0x10000, &v11);
                    unsigned int v12 = result;
                    if (!result)
                    {
                      uint64_t result = (*(uint64_t (**)(uint64_t, void *, unint64_t))(*(void *)v11 + 8))(v11 - *(void *)(*(void *)v11 + 56), v10, v9);
                      unsigned int v12 = result;
                      if (!result)
                      {
                        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 120), v11);
                        unsigned int v12 = result;
                        if (!result)
                        {
                          OOCAllocator_Free(*(void *)(a1 + 48), (uint64_t)v10);
                          return v12;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t EHashTableFirstNode_CreateFromStreamInterruptible(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t result = _PNEW_EHashTableFirstNode_ConInternal(a1, a1, a3);
  if (!result)
  {
    uint64_t result = _EHashTableFirstNode_InitInternal(*a3, a2, a4);
    if (!result)
    {
      if (*a4)
      {
        uint64_t result = OOC_PlacementDeleteObject(a1, *a3);
        if (!result) {
          *a3 = 0;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t _PNEW_EHashTableFirstNode_ConInternal(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  unsigned int v6 = (void *)OOCAllocator_Malloc(a1, 56, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = Object_Con(v6);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      void *v6 = &__EHashTableFirstNode;
      v6[5] = 0;
      v6[6] = a2;
      v6[2] = 0;
      v6[3] = 0;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t _EHashTableFirstNode_InitInternal(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unint64_t v8 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, unint64_t *, _DWORD *))(*(void *)a2 + 64))(a2 - *(void *)(*(void *)a2 + 208), *(void *)(a1 + 48), 1313164870, 0, 0x10000, a1 + 16, &v8, a3);
  if (!result)
  {
    if (*a3)
    {
LABEL_3:
      _EHashTableFirstNode_Cleanup((uint64_t *)a1);
      return 0;
    }
    *(_DWORD *)(a1 + 8) = v8 >> 1;
    uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, unint64_t *, _DWORD *))(*(void *)a2 + 64))(a2 - *(void *)(*(void *)a2 + 208), *(void *)(a1 + 48), 1414745670, 0, 0x10000, a1 + 24, &v8, a3);
    if (!result)
    {
      if (*a3) {
        goto LABEL_3;
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, unint64_t *, _DWORD *))(*(void *)a2 + 64))(a2 - *(void *)(*(void *)a2 + 208), *(void *)(a1 + 48), 1095257670, 0, 0x10000, a1 + 40, &v8, a3);
      if (!result)
      {
        if (*a3) {
          goto LABEL_3;
        }
        unint64_t v7 = 4 * (unint64_t)*(unsigned int *)(a1 + 8) / v8;
        *(_DWORD *)(a1 + 32) = v7;
        if ((v7 - 1) < 2) {
          return 0;
        }
        return err_GenerateErrorData();
      }
    }
  }
  return result;
}

uint64_t EHashTableFirstNode_Hash(uint64_t a1, unsigned int a2, _DWORD *a3, _DWORD *a4)
{
  int v4 = *(_DWORD *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(a1 + 40);
  int v7 = *(_DWORD *)(a1 + 32);
  if (v7 == 1)
  {
    if (v4)
    {
      uint64_t v8 = 0;
      int v9 = 0;
      while (*(unsigned __int16 *)(v5 + 2 * v8) < a2)
      {
        v9 += *(_DWORD *)(v6 + 4 * v8++);
        if (v4 == v8) {
          return 0;
        }
      }
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  if (v7 != 2 || !v4)
  {
LABEL_13:
    LODWORD(v8) = 0;
    int v9 = 0;
    goto LABEL_14;
  }
  uint64_t v8 = 0;
  int v9 = 0;
  while (*(unsigned __int16 *)(v5 + 2 * v8) < a2)
  {
    v9 += *(unsigned __int16 *)(v6 + 2 * v8++);
    if (v4 == v8) {
      return 0;
    }
  }
LABEL_14:
  if (v8 == v4 || *(unsigned __int16 *)(v5 + 2 * v8) != a2) {
    return 0;
  }
  *a3 = v9;
  *a4 = *(_DWORD *)(*(void *)(a1 + 24) + 4 * v8);
  return 1;
}

uint64_t EHashTableFirstNode_Unhash(uint64_t result, unsigned int *a2, _WORD *a3, _DWORD *a4)
{
  int v4 = *(unsigned __int16 **)(result + 40);
  unsigned int v5 = *a2 + 1;
  int v6 = *(_DWORD *)(result + 32);
  if (v6 != 1)
  {
    if (v6 == 2)
    {
      unsigned int v7 = *v4;
      if (v5 > v7)
      {
        unsigned int v8 = 0;
        do
        {
          v5 -= v7;
          unsigned int v7 = v4[++v8];
        }
        while (v5 > v7);
        goto LABEL_12;
      }
    }
LABEL_11:
    unsigned int v8 = 0;
    goto LABEL_12;
  }
  unsigned int v9 = *(_DWORD *)v4;
  if (*(_DWORD *)v4 >= v5) {
    goto LABEL_11;
  }
  unsigned int v8 = 0;
  do
  {
    v5 -= v9;
    unsigned int v9 = *(_DWORD *)&v4[2 * ++v8];
  }
  while (v9 < v5);
LABEL_12:
  *a2 = v5;
  if (a3) {
    *a3 = *(_WORD *)(*(void *)(result + 16) + 2 * v8);
  }
  *a4 = *(_DWORD *)(*(void *)(result + 24) + 4 * v8);
  return result;
}

uint64_t PNEW_EHashTableFirstNode_Con(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5, void *a6)
{
  unsigned int v14 = 0;
  unsigned int v12 = (void *)OOCAllocator_Malloc(a1, 56, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = EHashTableFirstNode_Con(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *a6 = v12;
    }
  }
  return result;
}

uint64_t PNEW_EHashTableFirstNode_Con2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 56, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = EHashTableFirstNode_Con2(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

void *GetEHashTableFirstNodeClass()
{
  return &__EHashTableFirstNode;
}

uint64_t FSMConstants_Con(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__FSMConstants;
    *(_WORD *)(a1 + 12) = bswap32(*a2) >> 16;
    *(_DWORD *)(a1 + 8) = bswap32(*(_DWORD *)((char *)a2 + 7));
    *(_WORD *)(a1 + 14) = bswap32(a2[2]) >> 16;
    *(unsigned char *)(a1 + 16) = *((unsigned char *)a2 + 2);
    *(unsigned char *)(a1 + 17) = *((unsigned char *)a2 + 3);
    *(unsigned char *)(a1 + 18) = *((unsigned char *)a2 + 6);
  }
  return result;
}

uint64_t FSMConstants_GetBuffer(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  unsigned int v10 = 0;
  unsigned int v7 = (unsigned char *)OOCAllocator_Malloc(a2, 11, &v10);
  uint64_t v8 = v10;
  if (!v10)
  {
    unsigned char *v7 = *(unsigned char *)(a1 + 13);
    v7[1] = *(unsigned char *)(a1 + 12);
    v7[7] = *(unsigned char *)(a1 + 11);
    v7[8] = *(_WORD *)(a1 + 10);
    v7[9] = BYTE1(*(_DWORD *)(a1 + 8));
    v7[10] = *(_DWORD *)(a1 + 8);
    v7[4] = *(unsigned char *)(a1 + 15);
    v7[5] = *(unsigned char *)(a1 + 14);
    v7[2] = *(unsigned char *)(a1 + 16);
    _OWORD v7[3] = *(unsigned char *)(a1 + 17);
    v7[6] = *(unsigned char *)(a1 + 18);
    *a3 = v7;
    *a4 = 11;
    return v10;
  }
  return v8;
}

uint64_t PNEW_FSMConstants_Con(uint64_t a1, unsigned __int16 *a2, uint64_t *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = OOCAllocator_Malloc(a1, 24, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = FSMConstants_Con(v6, a2);
    unsigned int v8 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *a3 = v6;
    }
  }
  return result;
}

void *GetFSMConstantsClass()
{
  return &__FSMConstants;
}

uint64_t _ELeaf_Con(void *a1)
{
  uint64_t result = Object_Con(a1);
  if (!result) {
    *a1 = &__ELeaf;
  }
  return result;
}

void *GetELeafClass()
{
  return &__ELeaf;
}

uint64_t EHuffman_Con1(void *a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v11 = 0;
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    a1[7] = a2;
    *a1 = &__EHuffman;
    uint64_t result = PNEW_BinBlockStreamReader_Con(a2, a2, a3, a4, a5, &v11);
    if (!result)
    {
      uint64_t result = EHuffman_Con2(a1, a1[7], v11 + 32);
      if (!result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)v11 + 32))(v11);
      }
    }
  }
  return result;
}

uint64_t EHuffman_Con2(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    uint64_t v10 = 0;
    *a1 = &__EHuffman;
    a1[7] = a2;
    unsigned int v7 = (unsigned __int16 **)(a1 + 1);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, void *, uint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), a2, 1381258568, 0, 0x10000, a1 + 1, &v10);
    if (!result)
    {
      int v8 = (*v7)[1];
      if (v8 == 8 || v8 == 16)
      {
        uint64_t result = _EHuffman_CreateTree((uint64_t)a1, (uint64_t)(*v7 + 2), v8, **v7);
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, void *, uint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), a1[7], 1162630472, 0, 0x10000, a1 + 4, &v10);
          if (!result) {
            return _EHuffman_CreateLeafArray((uint64_t)a1, a1[4] + 2, *(unsigned __int16 *)a1[4], v10 - 2);
          }
        }
      }
      else
      {
        return err_GenerateErrorData();
      }
    }
  }
  return result;
}

uint64_t _EHuffman_CreateTree(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (a3 == 16)
  {
    uint64_t v6 = 0;
    uint64_t result = PNEW_ETree16_Con(*(void *)(a1 + 56), a2, a4, &v6);
    if (result) {
      return result;
    }
    goto LABEL_6;
  }
  if (a3 == 8)
  {
    uint64_t v6 = 0;
    uint64_t result = PNEW_ETree08_Con(*(void *)(a1 + 56), a2, a4, &v6);
    if (result) {
      return result;
    }
LABEL_6:
    *(void *)(a1 + 24) = v6;
    return result;
  }
  return 0;
}

uint64_t _EHuffman_CreateLeafArray(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = 0;
  uint64_t result = PNEW_ELeaf08_Con(*(void *)(a1 + 56), a2, a3, 8 * a4 / (unint64_t)a3, &v6);
  if (!result) {
    *(void *)(a1 + 48) = v6;
  }
  return result;
}

uint64_t _EHuffman_ConInternal(void *a1, uint64_t a2)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__EHuffman;
    a1[1] = 0;
    a1[6] = 0;
    a1[7] = a2;
    a1[3] = 0;
    a1[4] = 0;
  }
  return result;
}

uint64_t EHuffman_Des(uint64_t *a1)
{
  uint64_t result = _EHuffman_Cleanup(a1);
  if (!result)
  {
    return Object_Des();
  }
  return result;
}

uint64_t _EHuffman_Cleanup(uint64_t *a1)
{
  uint64_t v2 = a1[3];
  if (v2)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[7], v2);
    if (result) {
      return result;
    }
    a1[3] = 0;
  }
  OOCAllocator_Free(a1[7], a1[1]);
  a1[1] = 0;
  uint64_t v4 = a1[6];
  if (v4)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[7], v4);
    if (result) {
      return result;
    }
    a1[6] = 0;
  }
  OOCAllocator_Free(a1[7], a1[4]);
  uint64_t result = 0;
  a1[4] = 0;
  return result;
}

uint64_t EHuffman_Archive(uint64_t a1, uint64_t a2)
{
  unsigned int v12 = 0;
  uint64_t v11 = 0;
  size_t v4 = ((*(_DWORD *)(*(void *)(a1 + 24) + 24) >> 2) * *(_DWORD *)(*(void *)(a1 + 24) + 8)
                    + (*(_DWORD *)(*(void *)(a1 + 24) + 24) >> 2));
  unsigned int v5 = (_WORD *)OOCAllocator_Malloc(*(void *)(a1 + 56), v4 + 4, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t v7 = *(void *)(a1 + 24);
    v5[1] = *(_DWORD *)(v7 + 24);
    _WORD *v5 = *(_WORD *)(v7 + 8) + 1;
    cstdlib_memcpy(v5 + 2, *(const void **)(v7 + 16), v4);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 32))(a2 - *(void *)(*(void *)a2 + 120), 1381258568, 0x10000, &v11);
    unsigned int v12 = result;
    if (!result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, _WORD *, size_t))(*(void *)v11 + 8))(v11 - *(void *)(*(void *)v11 + 56), v5, v4 + 4);
      unsigned int v12 = result;
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 120), v11);
        unsigned int v12 = result;
        if (!result)
        {
          OOCAllocator_Free(*(void *)(a1 + 56), (uint64_t)v5);
          int v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48));
          size_t v9 = ((*(_DWORD *)(*(void *)(a1 + 48) + 20) * v8)
              + (unint64_t)(-(*(_DWORD *)(*(void *)(a1 + 48) + 20) * v8) & 7)) >> 3;
          uint64_t v10 = (_WORD *)OOCAllocator_Malloc(*(void *)(a1 + 56), v9 + 2, &v12);
          uint64_t result = v12;
          if (!v12)
          {
            *uint64_t v10 = v8;
            cstdlib_memcpy(v10 + 1, *(const void **)(*(void *)(a1 + 48) + 8), v9);
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 32))(a2 - *(void *)(*(void *)a2 + 120), 1162630472, 0x10000, &v11);
            unsigned int v12 = result;
            if (!result)
            {
              uint64_t result = (*(uint64_t (**)(uint64_t, _WORD *, size_t))(*(void *)v11 + 8))(v11 - *(void *)(*(void *)v11 + 56), v10, v9 + 2);
              unsigned int v12 = result;
              if (!result)
              {
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 120), v11);
                unsigned int v12 = result;
                if (!result)
                {
                  OOCAllocator_Free(*(void *)(a1 + 56), (uint64_t)v10);
                  return v12;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t EHuffman_CreateFromStreamInterruptible(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t result = _PNEW_EHuffman_ConInternal(a1, a1, a3);
  if (!result)
  {
    uint64_t result = _EHuffman_InitInternal((uint64_t *)*a3, a2, a4);
    if (!result)
    {
      if (*a4 == 1)
      {
        uint64_t result = OOC_PlacementDeleteObject(a1, *a3);
        if (!result) {
          *a3 = 0;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t _PNEW_EHuffman_ConInternal(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = (void *)OOCAllocator_Malloc(a1, 64, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = Object_Con(v6);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      void *v6 = &__EHuffman;
      v6[1] = 0;
      v6[6] = 0;
      _OWORD v6[7] = a2;
      v6[3] = 0;
      v6[4] = 0;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t _EHuffman_InitInternal(uint64_t *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v10 = 0;
  uint64_t v6 = (unsigned __int16 **)(a1 + 1);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t *, uint64_t *, _DWORD *))(*(void *)a2 + 64))(a2 - *(void *)(*(void *)a2 + 208), a1[7], 1381258568, 0, 0x10000, a1 + 1, &v10, a3);
  if (!result)
  {
    if (*a3 == 1) {
      return _EHuffman_Cleanup(a1);
    }
    int v8 = (*v6)[1];
    if (v8 == 8 || v8 == 16)
    {
      uint64_t result = _EHuffman_CreateTree((uint64_t)a1, (uint64_t)(*v6 + 2), v8, **v6);
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t *, uint64_t *, _DWORD *))(*(void *)a2 + 64))(a2 - *(void *)(*(void *)a2 + 208), a1[7], 1162630472, 0, 0x10000, a1 + 4, &v10, a3);
        if (!result)
        {
          if (*a3 == 1) {
            return _EHuffman_Cleanup(a1);
          }
          return _EHuffman_CreateLeafArray((uint64_t)a1, a1[4] + 2, *(unsigned __int16 *)a1[4], v10 - 2);
        }
      }
    }
    else
    {
      return err_GenerateErrorData();
    }
  }
  return result;
}

uint64_t EHuffman_Eat(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 24))(*(void *)(a1 + 24));
}

uint64_t EHuffman_GetLeafWidth(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48));
}

uint64_t EHuffman_GetResult(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 24))(*(void *)(a1 + 48), *(unsigned int *)(*(void *)(a1 + 24) + 12));
}

uint64_t EHuffman_Reset(uint64_t a1)
{
  return ETree_Reset(*(void *)(a1 + 24));
}

uint64_t PNEW_EHuffman_Con1(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _DWORD *a5, void *a6)
{
  unsigned int v14 = 0;
  unsigned int v12 = (void *)OOCAllocator_Malloc(a1, 64, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = EHuffman_Con1(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *a6 = v12;
    }
  }
  return result;
}

uint64_t PNEW_EHuffman_Con2(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unsigned int v10 = 0;
  int v8 = (void *)OOCAllocator_Malloc(a1, 64, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = EHuffman_Con2(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

void *GetEHuffmanClass()
{
  return &__EHuffman;
}

uint64_t _ETree_Con(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__ETree;
    *(_DWORD *)(a1 + 8) = a3 - 1;
    *(_DWORD *)(a1 + 12) = a3 - 1;
    *(void *)(a1 + 16) = a2;
    *(_DWORD *)(a1 + 24) = a4;
  }
  return result;
}

uint64_t ETree_Reset(uint64_t result)
{
  *(_DWORD *)(result + 12) = *(_DWORD *)(result + 8);
  return result;
}

void *GetETreeClass()
{
  return &__ETree;
}

uint64_t ELeaf16_Con(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = _ELeaf_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__ELeaf16;
    *(void *)(a1 + 8) = a2;
    *(_DWORD *)(a1 + 16) = a3;
  }
  return result;
}

uint64_t ELeaf16_GetLeafWidth(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t ELeaf16_GetResult(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 16);
  if (!v2) {
    return *(unsigned int *)(a1 + 16);
  }
  if (v2 == 16) {
    return *(unsigned __int16 *)(*(void *)(a1 + 8) + 2 * a2);
  }
  unsigned int v5 = 0;
  uint64_t result = 0;
  unint64_t v6 = v2 * a2;
  uint64_t v7 = *(void *)(a1 + 8);
  do
  {
    LODWORD(v8) = 16 - (v6 & 0xF);
    if (v8 >= v2 - v5) {
      uint64_t v8 = v2 - v5;
    }
    else {
      uint64_t v8 = v8;
    }
    result |= ((*(unsigned __int16 *)(v7 + ((v6 >> 3) & 0x1FFFFFFFFFFFFFFELL)) >> (v6 & 0xF)) & ~(-1 << v8)) << v5;
    v6 += v8;
    v5 += v8;
  }
  while (v5 < v2);
  return result;
}

uint64_t PNEW_ELeaf16_Con(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 24, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = _ELeaf_Con((void *)v8);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *(void *)uint64_t v8 = &__ELeaf16;
      *(void *)(v8 + 8) = a2;
      *(_DWORD *)(v8 + 16) = a3;
      *a4 = v8;
    }
  }
  return result;
}

void *GetELeaf16Class()
{
  return &__ELeaf16;
}

uint64_t ELeaf08_Con(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t result = _ELeaf_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__ELeaf08;
    *(void *)(a1 + 8) = a2;
    *(_DWORD *)(a1 + 16) = a3;
    *(_DWORD *)(a1 + 20) = a4;
  }
  return result;
}

uint64_t ELeaf08_GetLeafWidth(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t ELeaf08_GetResult(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  unsigned int v3 = v2 * a2 + v2;
  if (v2 * a2 >= v3)
  {
    int v4 = 0;
  }
  else
  {
    int v4 = 0;
    unsigned int v5 = v2 * a2;
    do
    {
      v4 |= *(unsigned __int8 *)(*(void *)(a1 + 8) + ((unint64_t)v5 >> 3)) >> (v5 & 7) << (v5 - v2 * a2);
      unsigned int v5 = (v5 & 0xFFFFFFF8) + 8;
    }
    while (v5 < v3);
  }
  return v4 & ~(-1 << v2);
}

uint64_t PNEW_ELeaf08_Con(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t *a5)
{
  unsigned int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 24, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = _ELeaf_Con((void *)v10);
    if (result)
    {
      unsigned int v12 = result;
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *(void *)uint64_t v10 = &__ELeaf08;
      *(void *)(v10 + 8) = a2;
      *(_DWORD *)(v10 + 16) = a3;
      *(_DWORD *)(v10 + 20) = a4;
      *a5 = v10;
    }
  }
  return result;
}

void *GetELeaf08Class()
{
  return &__ELeaf08;
}

uint64_t ETree08_Con(void *a1, uint64_t a2, int a3)
{
  uint64_t result = _ETree_Con((uint64_t)a1, a2, a3, 8);
  if (!result) {
    *a1 = &__ETree08;
  }
  return result;
}

BOOL ETree08_Eat(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  unsigned int v3 = (unsigned __int8 *)(v2 + 2 * *(unsigned int *)(a1 + 12));
  if (!a2) {
    ++v3;
  }
  unsigned int v4 = *v3;
  *(_DWORD *)(a1 + 12) = v4;
  return *(unsigned __int8 *)(v2 + 2 * v4) != 255;
}

uint64_t PNEW_ETree08_Con(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = (void *)OOCAllocator_Malloc(a1, 32, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = _ETree_Con((uint64_t)v8, a2, a3, 8);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *uint64_t v8 = &__ETree08;
      *a4 = v8;
    }
  }
  return result;
}

void *GetETree08Class()
{
  return &__ETree08;
}

uint64_t ETree16_Con(void *a1, uint64_t a2, int a3)
{
  uint64_t result = _ETree_Con((uint64_t)a1, a2, a3, 16);
  if (!result) {
    *a1 = &__ETree16;
  }
  return result;
}

BOOL ETree16_Eat(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  unsigned int v3 = *(unsigned __int16 *)(v2 + 4 * *(unsigned int *)(a1 + 12) + 2 * (a2 == 0));
  *(_DWORD *)(a1 + 12) = v3;
  return *(__int16 *)(v2 + 4 * v3) != -1;
}

uint64_t PNEW_ETree16_Con(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = (void *)OOCAllocator_Malloc(a1, 32, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = _ETree_Con((uint64_t)v8, a2, a3, 16);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *uint64_t v8 = &__ETree16;
      *a4 = v8;
    }
  }
  return result;
}

void *GetETree16Class()
{
  return &__ETree16;
}

void *voc_BorrowGlobalVarPtr(void *result, void *a2)
{
  if (a2) {
    *a2 = 13;
  }
  if (result) {
    *uint64_t result = &g_aGlobals;
  }
  return result;
}

uint64_t fi_init(_WORD *a1, uint64_t a2, _WORD *a3, uint64_t a4, void *a5, int a6, uint64_t a7, const char *a8, __int16 a9, char a10)
{
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v34 = 0;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v31 = 0u;
  uint64_t inited = InitRsrcFunction(a1, a2, &v36);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t inited = InitRsrcFunction(a3, a4, &v35);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t v19 = heap_Calloc(*(void **)(v36 + 8), 1, 16);
  if (!v19) {
    return 2692751370;
  }
  uint64_t v20 = (void *)v19;
  cstdlib_memset(&v31, 0, 0x30uLL);
  *(void *)&long long v31 = a1;
  *((void *)&v31 + 1) = a2;
  *(void *)&long long v32 = a3;
  *((void *)&v32 + 1) = a4;
  cstdlib_strcpy((char *)&v33, a8);
  DWORD2(v33) = a6;
  BYTE14(v33) = a10;
  WORD6(v33) = a9;
  uint64_t ObjcForThisApi_1 = getObjcForThisApi_1(v36, v35);
  uint64_t AddRefCountedObject = objc_GetAddRefCountedObject(ObjcForThisApi_1, a7, (uint64_t (*)(void, void, uint64_t, _OWORD *, uint64_t))fi_ObjcLoad, (void (*)(void, void, _OWORD *))fi_ObjcClose, (uint64_t)&v31, &v34);
  if ((AddRefCountedObject & 0x80000000) != 0)
  {
    uint64_t v29 = AddRefCountedObject;
  }
  else
  {
    uint64_t v23 = *(void *)(v34 + 32);
    v20[1] = v23;
    uint64_t v24 = *(uint64_t **)v23;
    if (!parse_fi_binary_model(*(uint64_t **)v23, *(void *)(v23 + 8), v20))
    {
      uint64_t v29 = 0;
      *a5 = v20;
      return v29;
    }
    log_OutText(*v24, (uint64_t)"FastInfer", 0, 0, (uint64_t)"parse binary model failed!", v25, v26, v27, v31);
    uint64_t v28 = getObjcForThisApi_1(v36, v35);
    objc_ReleaseObject(v28, v23 + 16);
    uint64_t v29 = 2692751367;
  }
  heap_Free(*(void **)(v36 + 8), (uint64_t)v20);
  return v29;
}

uint64_t fi_ObjcLoad(_WORD *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  memset(__dst, 0, sizeof(__dst));
  uint64_t inited = InitRsrcFunction(a1, a2, &v56);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t inited = InitRsrcFunction(*(_WORD **)(a5 + 16), *(void *)(a5 + 24), &v57);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t v11 = 2692751367;
  cstdlib_memcpy(__dst, v56, 0x1A0uLL);
  long long v32 = *(_OWORD *)(v57 + 32);
  uint64_t v12 = *(unsigned int *)(a5 + 40);
  int v13 = *(unsigned __int8 *)(a5 + 46);
  int v14 = *(unsigned __int16 *)(a5 + 44);
  long long v62 = 0;
  char v61 = 0;
  *(void *)__s1 = 0;
  long long v58 = 0;
  long long v59 = 0;
  uint64_t v15 = heap_Calloc(*((void **)&__dst[0] + 1), 1, 272);
  if (v15)
  {
    uint64_t v16 = v15;
    if (fi_rsc_create(__dst, &v58))
    {
LABEL_5:
      if (v58)
      {
        fi_rsc_destroy(v58);
        long long v58 = 0;
      }
      heap_Free(*((void **)&__dst[0] + 1), v16);
      goto LABEL_10;
    }
    *(void *)uint64_t v16 = v58;
    if ((ssftriff_reader_ObjOpen(a1, a2, v12, a3, (char *)(a5 + 32), v14 | (v13 << 16), (uint64_t *)&v62) & 0x80000000) != 0)
    {
      uint64_t v11 = 2692751364;
      goto LABEL_5;
    }
    uint64_t v25 = ssftriff_reader_OpenChunk((uint64_t)v62, (__int32 *)&__s1[4], (unsigned int *)__s1, &v59);
    uint64_t v26 = v25;
    if ((v25 & 0x80000000) != 0)
    {
      uint64_t v11 = v25;
      goto LABEL_5;
    }
    if (cstdlib_strcmp(&__s1[4], "FIBM"))
    {
      log_OutText(*v58, (uint64_t)"FastInfer", 0, 0, (uint64_t)"not found chunk: %s", v27, v28, v29, (uint64_t)"FIBM");
      goto LABEL_5;
    }
    unsigned int v30 = (void *)(*(uint64_t (**)(uint64_t, void))v58[1])(v58[2], *(unsigned int *)__s1);
    *(void *)(v16 + 8) = v30;
    if (!v30)
    {
      uint64_t v11 = 2692751370;
      goto LABEL_5;
    }
    cstdlib_memcpy(v30, v59, *(unsigned int *)__s1);
    cstdlib_strcpy((char *)(v16 + 16), a3);
    *(void *)(a4 + 32) = v16;
    uint64_t v11 = v26;
  }
  else
  {
    uint64_t v11 = 2692751370;
  }
LABEL_10:
  if (v62)
  {
    ssftriff_reader_CloseChunk((uint64_t)v62);
    ssftriff_reader_ObjClose(v62, v17, v18, v19, v20, v21, v22, v23);
  }
  return v11;
}

uint64_t fi_ObjcClose(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v8 = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v8);
  if ((result & 0x80000000) == 0)
  {
    unsigned int v5 = *(void **)(a3 + 32);
    if (!v5) {
      return 0;
    }
    uint64_t v6 = v8;
    uint64_t v7 = (void *)*v5;
    if (v5[1])
    {
      (*(void (**)(void))(v7[1] + 48))(v7[2]);
      v5[1] = 0;
    }
    else if (!v7)
    {
LABEL_7:
      heap_Free(*(void **)(v6 + 8), (uint64_t)v5);
      return 0;
    }
    fi_rsc_destroy(v7);
    goto LABEL_7;
  }
  return result;
}

uint64_t getObjcForThisApi_1(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  __s1 = 0;
  if (a2
    && ((paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"clcpppipelinemode", &__s1) & 0x80000000) != 0
     || !__s1
     || !*__s1
     || !cstdlib_strcmp(__s1, "internal")))
  {
    uint64_t v2 = a2;
  }
  return *(void *)(v2 + 48);
}

uint64_t fi_deinit(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (!a3) {
    return 0;
  }
  if (*a3) {
    fi_net_destroy(*a3);
  }
  uint64_t v6 = a3[1];
  uint64_t ObjcForThisApi_1 = getObjcForThisApi_1(a1, a2);
  uint64_t v8 = objc_ReleaseObject(ObjcForThisApi_1, v6 + 16);
  heap_Free(*(void **)(a1 + 8), (uint64_t)a3);
  return v8;
}

uint64_t fi_predict(uint64_t ***a1, const void **a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 2692751360;
  if (!a1) {
    return 2692751367;
  }
  size_t v9 = *a1;
  unsigned int v10 = *v9;
  if (!fi_net_predict(v9, a2, a3, a4, a5, a6, a7, a8)) {
    return 0;
  }
  log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"FI Prediction failed!", v11, v12, v13, v15);
  return v8;
}

BOOL almost_equal_doubles(double a1, double a2)
{
  double v2 = vabdd_f64(a1, a2);
  if (v2 < 1.0e-150) {
    return 1;
  }
  double v4 = fabs(a1);
  double v5 = fabs(a2);
  if (v4 <= v5) {
    double v4 = v5;
  }
  return v2 / v4 < 0.00000001;
}

double fabs_fdlibm(double a1)
{
  return fabs(a1);
}

BOOL almost_equal_floats(double a1, float a2)
{
  float v2 = fabs((float)(*(float *)&a1 - a2));
  if (v2 < 0.00001) {
    return 1;
  }
  *((float *)&a1 + 1) = a2;
  float32x2_t v4 = vcvt_f32_f64(vabsq_f64(vcvtq_f64_f32(*(float32x2_t *)&a1)));
  if (v4.f32[0] <= v4.f32[1]) {
    v4.f32[0] = v4.f32[1];
  }
  return (float)(v2 / v4.f32[0]) < 0.01;
}

void fast_exp_c(float *a1, int a2, float *a3)
{
  if (a2 >= 1)
  {
    uint64_t v5 = a2;
    do
    {
      float v6 = *a1++;
      *a3++ = expf(fmaxf(fminf(v6, 80.0), -80.0));
      --v5;
    }
    while (v5);
  }
}

float fast_exp_single(float a1)
{
  return expf(fmaxf(fminf(a1, 80.0), -80.0));
}

void fast_exp(float *a1, int a2, float *a3)
{
  unsigned int v3 = a3;
  float32x2_t v4 = a1;
  if (((a3 | a1) & 0x1F) != 0)
  {
    if (a2 >= 1)
    {
      uint64_t v5 = a2;
      do
      {
        float v6 = *v4++;
        *v3++ = expf(fmaxf(fminf(v6, 80.0), -80.0));
        --v5;
      }
      while (v5);
    }
  }
  else if (a2 >= 1)
  {
    uint64_t v7 = a2;
    do
    {
      float v8 = *v4++;
      *v3++ = expf(fmaxf(fminf(v8, 80.0), -80.0));
      --v7;
    }
    while (v7);
  }
}

float fast_log_approx_single(float a1)
{
  return (float)((float)((float)((SLODWORD(a1) >> 23) - 127) + 1.0)
               + (float)((float)((float)(COERCE_FLOAT(LODWORD(a1) - (((SLODWORD(a1) >> 23) - 127) << 23)) + -1.5)
                               * (float)((float)((float)(COERCE_FLOAT(LODWORD(a1) - (((SLODWORD(a1) >> 23) - 127) << 23))
                                                       + -1.5)
                                               * (float)((float)((float)(COERCE_FLOAT(LODWORD(a1)- (((SLODWORD(a1) >> 23) - 127) << 23))+ -1.5)* 0.16541)+ -0.33951))+ 0.95909))+ -0.41445))* 0.69315;
}

float Q_rsqrt(float a1)
{
  return (float)((float)((float)((float)(a1 * -0.5) * COERCE_FLOAT(1597463174 - (SLODWORD(a1) >> 1)))
                       * COERCE_FLOAT(1597463174 - (SLODWORD(a1) >> 1)))
               + 1.5)
       * COERCE_FLOAT(1597463174 - (SLODWORD(a1) >> 1));
}

float Q_powf_1_75(float a1)
{
  return (float)(a1 * a1)
       * (float)((float)((float)((float)((float)(a1 * -0.25)
                                       * (float)(COERCE_FLOAT(1331219312 - (SLODWORD(a1) >> 2))
                                               * COERCE_FLOAT(1331219312 - (SLODWORD(a1) >> 2))))
                               * (float)(COERCE_FLOAT(1331219312 - (SLODWORD(a1) >> 2))
                                       * COERCE_FLOAT(1331219312 - (SLODWORD(a1) >> 2))))
                       + 1.25)
               * COERCE_FLOAT(1331219312 - (SLODWORD(a1) >> 2)));
}

float *fill_array_f32_c(float *result, unsigned int a2, float a3)
{
  if (a2)
  {
    uint64_t v3 = a2;
    do
    {
      *result++ = a3;
      --v3;
    }
    while (v3);
  }
  return result;
}

float *fill_array_f32(float *result, unsigned int a2, float a3)
{
  if ((result & 0x1F) != 0)
  {
    if (a2)
    {
      uint64_t v3 = a2;
      do
      {
        *result++ = a3;
        --v3;
      }
      while (v3);
    }
  }
  else if (a2)
  {
    uint64_t v4 = a2;
    do
    {
      *result++ = a3;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t max_array_f32_c(uint64_t result, float *a2, float *a3)
{
  if (result)
  {
    uint64_t v3 = result;
    do
    {
      if (*a3 > *a2) {
        *a2 = *a3;
      }
      ++a3;
      ++a2;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t max_array_f32(uint64_t result, float *a2, float *a3)
{
  if (((a3 | a2) & 0x1F) != 0)
  {
    if (result)
    {
      uint64_t v3 = result;
      do
      {
        if (*a3 > *a2) {
          *a2 = *a3;
        }
        ++a2;
        ++a3;
        --v3;
      }
      while (v3);
    }
  }
  else if (result)
  {
    uint64_t v4 = result;
    do
    {
      if (*a3 > *a2) {
        *a2 = *a3;
      }
      ++a2;
      ++a3;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t relu_array_f32_c(uint64_t result, float *a2)
{
  if (result)
  {
    uint64_t v2 = result;
    do
    {
      if (*a2 < 0.0) {
        *a2 = 0.0;
      }
      ++a2;
      --v2;
    }
    while (v2);
  }
  return result;
}

uint64_t relu_array_f32(uint64_t result, float *a2)
{
  if ((a2 & 0x1F) != 0)
  {
    if (result)
    {
      uint64_t v2 = result;
      do
      {
        if (*a2 < 0.0) {
          *a2 = 0.0;
        }
        ++a2;
        --v2;
      }
      while (v2);
    }
  }
  else if (result)
  {
    uint64_t v3 = result;
    do
    {
      if (*a2 < 0.0) {
        *a2 = 0.0;
      }
      ++a2;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t leaky_array_f32_c(uint64_t result, float *a2, float a3)
{
  if (result)
  {
    uint64_t v3 = result;
    do
    {
      if (*a2 < 0.0) {
        *a2 = *a2 * a3;
      }
      ++a2;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t leaky_array_f32(uint64_t result, float *a2, float a3)
{
  if ((a2 & 0x1F) != 0)
  {
    if (result)
    {
      uint64_t v3 = result;
      do
      {
        if (*a2 < 0.0) {
          *a2 = *a2 * a3;
        }
        ++a2;
        --v3;
      }
      while (v3);
    }
  }
  else if (result)
  {
    uint64_t v4 = result;
    do
    {
      if (*a2 < 0.0) {
        *a2 = *a2 * a3;
      }
      ++a2;
      --v4;
    }
    while (v4);
  }
  return result;
}

float softsign_array_f32_c(unsigned int a1, float *a2)
{
  if (a1)
  {
    uint64_t v2 = a1;
    float result = 1.0;
    do
    {
      float v4 = fabs(*a2);
      *a2 = *a2 / (float)(v4 + 1.0);
      ++a2;
      --v2;
    }
    while (v2);
  }
  return result;
}

float softsign_array_f32(unsigned int a1, float *a2)
{
  if ((a2 & 0x1F) != 0)
  {
    if (a1)
    {
      uint64_t v2 = a1;
      float result = 1.0;
      do
      {
        float v4 = fabs(*a2);
        *a2 = *a2 / (float)(v4 + 1.0);
        ++a2;
        --v2;
      }
      while (v2);
    }
  }
  else if (a1)
  {
    uint64_t v5 = a1;
    float result = 1.0;
    do
    {
      float v6 = fabs(*a2);
      *a2 = *a2 / (float)(v6 + 1.0);
      ++a2;
      --v5;
    }
    while (v5);
  }
  return result;
}

void gmm_c(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a2 >= 1)
  {
    uint64_t v10 = 0;
    uint64_t v11 = a2;
    uint64_t v12 = a1;
    do
    {
      if (a1 >= 1)
      {
        uint64_t v13 = 0;
        float v14 = *(float *)(a5 + 4 * v10) * *(float *)(a5 + 4 * v10);
        float v15 = *(float *)(a3 + 4 * v10)
            * (float)((float)((float)((float)((float)((float)(v14 * 6.2832) * -0.5)
                                            * COERCE_FLOAT(1597463174 - (COERCE_INT(v14 * 6.2832) >> 1)))
                                    * COERCE_FLOAT(1597463174 - (COERCE_INT(v14 * 6.2832) >> 1)))
                            + 1.5)
                    * COERCE_FLOAT(1597463174 - (COERCE_INT(v14 * 6.2832) >> 1)));
        float v16 = 1.0 / (float)((float)(v14 * 2.0) + 1.0e-10);
        do
        {
          float v17 = (float)(int)v13 - *(float *)(a4 + 4 * v10);
          *(float *)(a6 + 4 * v13) = *(float *)(a6 + 4 * v13)
                                   + (float)(v15 * expf(fmaxf(fminf(v16 * (float)-(float)(v17 * v17), 80.0), -80.0)));
          ++v13;
        }
        while (v12 != v13);
      }
      ++v10;
    }
    while (v10 != v11);
  }
}

double exp_fdlibm(double a1)
{
  uint64_t v1 = *(void *)&a1 >> 63;
  uint64_t v2 = HIDWORD(*(void *)&a1) & 0x7FFFFFFFLL;
  if (v2 < 0x40862E42)
  {
    if (v2 < 0x3FD62E43)
    {
      int v8 = 0;
      double v6 = 0.0;
      if (a1 + 1.0e300 > 1.0 && v2 >> 20 <= 0x3E2) {
        return a1 + 1.0;
      }
      double v7 = 0.0;
LABEL_19:
      double v10 = a1
          - a1
          * a1
          * (a1
           * a1
           * (a1 * a1 * (a1 * a1 * (a1 * a1 * 0.000000041381368 + -0.00000165339022) + 0.0000661375632) + -0.00277777778)
           + 0.166666667);
      double v11 = a1 * v10;
      if (v8)
      {
        double v12 = v6 - (v7 - v11 / (2.0 - v10)) + 1.0;
        int v13 = v8 << 20;
        if (v8 < -1021) {
          return COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v6 - (v7 - v11 / (2.0 - v10)) + 1.0) | ((unint64_t)(v13 + 1048576000 + HIDWORD(v12)) << 32))
        }
               * 9.33263619e-302;
        unint64_t v9 = COERCE_UNSIGNED_INT64(v6 - (v7 - v11 / (2.0 - v10)) + 1.0) | ((unint64_t)(v13 + HIDWORD(v12)) << 32);
        return *(double *)&v9;
      }
      a1 = a1 - v11 / (v10 + -2.0);
      return a1 + 1.0;
    }
    if (v2 <= 0x3FF0A2B1)
    {
      double v6 = a1 - dbl_22078B7B0[v1];
      double v7 = dbl_22078B7C0[v1];
      int v8 = (a1 >= 0.0) - (*(void *)&a1 >> 63);
LABEL_18:
      a1 = v6 - v7;
      goto LABEL_19;
    }
LABEL_17:
    int v8 = (int)(dbl_22078B7A0[v1] + a1 * 1.44269504);
    double v6 = a1 + (double)v8 * -0.69314718;
    double v7 = (double)v8 * 1.90821493e-10;
    goto LABEL_18;
  }
  if (v2 >> 20 < 0x7FF)
  {
    if (a1 > 709.782713)
    {
      unint64_t v9 = 0x7FF0000000000000;
      return *(double *)&v9;
    }
    double v4 = 0.0;
    if (a1 < -745.133219) {
      return v4;
    }
    goto LABEL_17;
  }
  int v3 = HIDWORD(a1) & 0xFFFFF | LODWORD(a1);
  double v4 = 0.0;
  if (a1 >= 0.0) {
    double v4 = a1;
  }
  double v5 = a1 + a1;
  if (v3) {
    return v5;
  }
  return v4;
}

double log_fdlibm(double a1)
{
  uint64_t v1 = HIDWORD(*(void *)&a1);
  if (SHIDWORD(a1) >= 0x100000)
  {
    int v2 = -1023;
  }
  else
  {
    if (!(HIDWORD(a1) & 0x7FFFFFFF | LODWORD(a1))) {
      return 4286578690.0;
    }
    if ((*(void *)&a1 & 0x8000000000000000) != 0) {
      return 2147483650.0;
    }
    a1 = a1 * 1.80143985e16;
    uint64_t v1 = HIDWORD(*(void *)&a1);
    int v2 = -1077;
  }
  if ((int)v1 >= 2146435072) {
    return a1 + a1;
  }
  unsigned int v4 = (v1 & 0xFFFFF) + 614244;
  int v5 = v2 + ((int)v1 >> 20) + (v4 >> 20);
  double v6 = COERCE_DOUBLE(LODWORD(a1) | ((unint64_t)((v4 & 0x100000 | v1 & 0xFFFFF) ^ 0x3FF00000) << 32)) + -1.0;
  if (((v1 + 2) & 0xFFFFFu) > 2)
  {
    double v9 = v6 / (v6 + 2.0);
    double v10 = (double)v5;
    double v11 = v9 * v9;
    double v12 = v11 * v11 * (v11 * v11 * (v11 * v11 * 0.153138377 + 0.222221984) + 0.4)
        + v11 * (v11 * v11 * (v11 * v11 * (v11 * v11 * 0.147981986 + 0.181835722) + 0.285714287) + 0.666666667);
    if ((int)(((v1 & 0xFFFFF) - 398458) | (440401 - (v1 & 0xFFFFF))) < 1)
    {
      double v16 = v6 - v12;
      if (!v5) {
        return v6 - v9 * v16;
      }
      double v15 = v10 * -1.90821493e-10 + v9 * v16;
    }
    else
    {
      double v13 = v6 * (v6 * 0.5);
      double v14 = v13 + v12;
      if (!v5)
      {
        double v8 = v13 - v9 * v14;
        return v6 - v8;
      }
      double v15 = v13 - (v10 * 1.90821493e-10 + v9 * v14);
    }
    return -(v15 - v6 - v10 * 0.69314718);
  }
  double v7 = fabs(v6);
  if (v7 >= 1.0e-150 && v7 / fmax(v7, 0.0) >= 0.00000001)
  {
    double v8 = v6 * v6 * (v6 * -0.333333333 + 0.5);
    if (v5) {
      return -(v8 + (double)v5 * -1.90821493e-10 - v6 - (double)v5 * 0.69314718);
    }
    return v6 - v8;
  }
  if (v5) {
    return (double)v5 * 1.90821493e-10 + (double)v5 * 0.69314718;
  }
  else {
    return 0.0;
  }
}

float get_amp(uint64_t a1, float *a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    unsigned int v4 = (float *)(a1 + 4);
    do
    {
      float result = sqrtf((float)(*v4 * *v4) + (float)(*(v4 - 1) * *(v4 - 1)));
      *a2++ = result;
      v4 += 2;
      --v3;
    }
    while (v3);
  }
  return result;
}

float reflect_padding(uint64_t a1, int a2, int a3)
{
  if (a3)
  {
    unsigned int v3 = a3 + 1;
    if ((a3 + 1) > 2) {
      uint64_t v4 = (a3 + 1);
    }
    else {
      uint64_t v4 = 2;
    }
    unsigned int v5 = a3 - 1;
    uint64_t v6 = v4 - 1;
    uint64_t v7 = v6;
    do
    {
      *(_DWORD *)(a1 + 4 * v5--) = *(_DWORD *)(a1 + 4 * v3++);
      --v7;
    }
    while (v7);
    unsigned int v8 = a3 + a2;
    unsigned int v9 = a3 + a2 - 2;
    do
    {
      float result = *(float *)(a1 + 4 * v9);
      *(float *)(a1 + 4 * v8++) = result;
      --v9;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t complex_add(float *a1, float *a2, int a3)
{
  return axpy((2 * a3), a2, 1, a1, 1, 1.0);
}

uint64_t complex_sub(float *a1, float *a2, int a3)
{
  return axpy((2 * a3), a2, 1, a1, 1, -1.0);
}

float interleave_c(int a1, int *a2, float *a3, uint64_t a4)
{
  if (a1 >= 1)
  {
    uint64_t v4 = a1;
    unsigned int v5 = (float *)(a4 + 4);
    do
    {
      int v6 = *a2++;
      *((_DWORD *)v5 - 1) = v6;
      float v7 = *a3++;
      float result = v7;
      float *v5 = v7;
      v5 += 2;
      --v4;
    }
    while (v4);
  }
  return result;
}

float interleave(int a1, int *a2, float *a3, uint64_t a4)
{
  if ((((a3 | a2) | a4) & 0x1F) != 0)
  {
    if (a1 >= 1)
    {
      uint64_t v4 = a1;
      unsigned int v5 = (float *)(a4 + 4);
      do
      {
        int v6 = *a2++;
        *((_DWORD *)v5 - 1) = v6;
        float v7 = *a3++;
        float result = v7;
        float *v5 = v7;
        v5 += 2;
        --v4;
      }
      while (v4);
    }
  }
  else if (a1 >= 1)
  {
    uint64_t v9 = a1;
    double v10 = (float *)(a4 + 4);
    do
    {
      int v11 = *a2++;
      *((_DWORD *)v10 - 1) = v11;
      float v12 = *a3++;
      float result = v12;
      *double v10 = v12;
      v10 += 2;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t sample_from_pdf(float *a1, int a2, float a3, float a4, float a5)
{
  uint64_t v9 = a2;
  if (a2 <= 0)
  {
    fast_exp(a1, a2, a1);
    float v16 = 1.0e-18;
  }
  else
  {
    uint64_t v10 = 0;
    float v11 = a3 + 1.0;
    do
    {
      a1[v10] = v11 * a1[v10];
      ++v10;
    }
    while (a2 != v10);
    fast_exp(a1, a2, a1);
    float v12 = 0.0;
    uint64_t v13 = v9;
    double v14 = a1;
    do
    {
      float v15 = *v14++;
      float v12 = v12 + v15;
      --v13;
    }
    while (v13);
    float v16 = v12 + 1.0e-18;
  }
  float v17 = 1.0 / v16;
  float v18 = fmaxf(-(float)(a4 - (float)(v17 * *a1)), 0.0);
  *a1 = v18;
  uint64_t result = (a2 - 1);
  if (a2 > 1)
  {
    uint64_t v20 = a1 + 1;
    uint64_t v21 = v9 - 1;
    do
    {
      float v18 = v18 + fmaxf((float)(v17 * *v20) - a4, 0.0);
      *v20++ = v18;
      --v21;
    }
    while (v21);
    uint64_t v22 = 0;
    while ((float)(a1[(int)result] * a5) > a1[v22])
    {
      if (result == ++v22) {
        return result;
      }
    }
    return v22;
  }
  return result;
}

float prepare_cdf(float *a1, unsigned int a2, float a3, float a4)
{
  if (a2)
  {
    uint64_t v7 = 0;
    float v8 = a3 + 1.0;
    uint64_t v9 = a2;
    do
    {
      a1[v7] = v8 * a1[v7];
      ++v7;
    }
    while (a2 != v7);
    fast_exp(a1, a2, a1);
    float v10 = 0.0;
    float v11 = a1;
    do
    {
      float v12 = *v11++;
      float v10 = v10 + v12;
      --v9;
    }
    while (v9);
    float v13 = v10 + 1.0e-18;
  }
  else
  {
    fast_exp(a1, 0, a1);
    float v13 = 1.0e-18;
  }
  float v14 = 1.0 / v13;
  float v15 = fmaxf(-(float)(a4 - (float)(v14 * *a1)), 0.0);
  *a1 = v15;
  if (a2 >= 2)
  {
    float v16 = a1 + 1;
    uint64_t v17 = a2 - 1;
    do
    {
      float v15 = v15 + fmaxf((float)(v14 * *v16) - a4, 0.0);
      *v16++ = v15;
      --v17;
    }
    while (v17);
  }
  return a1[a2 - 1];
}

uint64_t sample_cdf(uint64_t a1, unsigned int a2, float a3)
{
  uint64_t v3 = a2 - 1;
  if (a2 == 1) {
    return 0;
  }
  uint64_t v5 = 0;
  float v6 = *(float *)(a1 + 4 * v3) * a3;
  uint64_t result = a2 >> 1;
  while (*(float *)(a1 + 4 * v5) < v6)
  {
    if (v3 == ++v5) {
      return result;
    }
  }
  return v5;
}

void *celt_lpc(void *a1, void *a2, float *a3, unsigned int a4)
{
  float v8 = *a3;
  size_t v9 = 4 * a4;
  cstdlib_memset(a1, 0, v9);
  uint64_t result = cstdlib_memset(a2, 0, v9);
  if (*a3 != 0.0)
  {
    uint64_t v11 = 0;
    uint64_t v12 = -1;
    do
    {
      if (v11 == a4) {
        break;
      }
      float v13 = 0.0;
      if (v11)
      {
        float v14 = (float *)a1;
        uint64_t v15 = v11;
        do
        {
          float v16 = *v14++;
          float v13 = v13 + (float)(v16 * a3[v15--]);
        }
        while (v15);
      }
      uint64_t v17 = v11 + 1;
      float v18 = (float)-(float)(v13 + a3[(v11 + 1)]) / v8;
      *((float *)a2 + v11) = v18;
      *((float *)a1 + v11) = v18;
      if (((v11 + 1) & 0xFFFFFFFELL) != 0)
      {
        unint64_t v19 = 0;
        uint64_t v20 = v12;
        do
        {
          float v21 = *((float *)a1 + v19);
          float v22 = *((float *)a1 + v20);
          *((float *)a1 + v19) = v21 + (float)(v18 * v22);
          *((float *)a1 + v20) = v22 + (float)(v18 * v21);
          ++v19;
          --v20;
        }
        while (v19 < v17 >> 1);
      }
      float v8 = v8 + (float)((float)-(float)(v18 * v18) * v8);
      ++v12;
      uint64_t v11 = v17;
    }
    while (v8 >= (float)(*a3 * 0.001));
  }
  return result;
}

float ulaw2lin8(float a1)
{
  float v1 = a1 + -128.0;
  float v2 = flt_22078B760[v1 >= 0.0];
  return v2 * (float)(expf(fmaxf(fminf((float)(fabsf(v1) * 0.0078125) * 5.5452, 80.0), -80.0)) + -1.0);
}

uint64_t lin2ulaw8(float a1)
{
  float v1 = (float)(fabsf(a1) * 0.007782) + 1.0;
  if (a1 < 0.0) {
    float v2 = -(float)((float)((float)((float)((float)((float)((SLODWORD(v1) >> 23) - 127) + 1.0)
  }
                                        + (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))
                                                                + -1.5)
                                                        * (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* 0.16541)+ -0.33951))+ 0.95909))+ -0.41445))* 0.69315)* 128.0)/ 5.5452);
  else {
    float v2 = (float)((float)((float)((float)((float)((SLODWORD(v1) >> 23) - 127) + 1.0)
  }
                               + (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))
                                                       + -1.5)
                                               * (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* 0.16541)+ -0.33951))+ 0.95909))+ -0.41445))* 0.69315)* 128.0)/ 5.5452;
  float v3 = v2 + 128.0;
  if (v3 < 0.0) {
    float v3 = 0.0;
  }
  float v4 = v3 + 0.5;
  BOOL v5 = v3 <= 255.0;
  float v6 = 255.5;
  if (v5) {
    return v4;
  }
  return v6;
}

float ulaw2lin7(float a1)
{
  float v1 = a1 + -64.0;
  float v2 = flt_22078B768[v1 >= 0.0];
  return v2 * (float)(expf(fmaxf(fminf((float)(fabsf(v1) * 0.015625) * 4.852, 80.0), -80.0)) + -1.0);
}

uint64_t lin2ulaw7(float a1)
{
  float v1 = (float)(fabsf(a1) * 0.0038757) + 1.0;
  if (a1 < 0.0) {
    float v2 = -(float)((float)((float)((float)((float)((float)((SLODWORD(v1) >> 23) - 127) + 1.0)
  }
                                        + (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))
                                                                + -1.5)
                                                        * (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* 0.16541)+ -0.33951))+ 0.95909))+ -0.41445))* 0.69315)* 64.0)/ 4.852);
  else {
    float v2 = (float)((float)((float)((float)((float)((SLODWORD(v1) >> 23) - 127) + 1.0)
  }
                               + (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))
                                                       + -1.5)
                                               * (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* 0.16541)+ -0.33951))+ 0.95909))+ -0.41445))* 0.69315)* 64.0)/ 4.852;
  float v3 = v2 + 64.0;
  if (v3 < 0.0) {
    float v3 = 0.0;
  }
  float v4 = v3 + 0.5;
  BOOL v5 = v3 <= 127.0;
  float v6 = 127.5;
  if (v5) {
    return v4;
  }
  return v6;
}

uint64_t opus_fft_alloc_twiddles(uint64_t *a1, unsigned int a2, uint64_t *a3)
{
  *a3 = 0;
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 64))(a1[2], 1, 64);
  uint64_t v10 = v6;
  if (v6)
  {
    *(_DWORD *)uint64_t v6 = a2;
    *(float *)(v6 + 4) = 1.0 / (float)a2;
    uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[1] + 72))(a1[2], 8 * a2);
    *(void *)(v10 + 56) = v11;
    if (v11)
    {
      uint64_t v15 = a2;
      if (a2)
      {
        uint64_t v16 = 0;
        uint64_t v17 = (float *)(v11 + 4);
        do
        {
          __float2 v18 = __sincosf_stret((float)(-6.2832 / (float)a2) * (float)v16);
          *(v17 - 1) = v18.__cosval;
          *uint64_t v17 = v18.__sinval;
          ++v16;
          v17 += 2;
        }
        while (a2 != v16);
      }
      unsigned int v19 = 0;
      unsigned int v20 = 0;
      *(_DWORD *)(v10 + 8) = -1;
      uint64_t v21 = v10 + 12;
      int v22 = 1;
      unsigned int v23 = a2;
      unsigned int v24 = 4;
      do
      {
        unsigned int v25 = v22;
        unsigned int v26 = v19;
        if (v23 % v24)
        {
          do
          {
            int v27 = v24 + 2;
            if (v24 == 2) {
              int v27 = 3;
            }
            if (v24 == 4) {
              unsigned int v24 = 2;
            }
            else {
              unsigned int v24 = v27;
            }
            if (v24 * v24 > v23 || v24 > 0x7D00) {
              unsigned int v24 = v23;
            }
          }
          while (v23 % v24);
          if (v24 > 5)
          {
            uint64_t v36 = 7;
            goto LABEL_37;
          }
        }
        uint64_t v29 = 2 * v20;
        *(_WORD *)(v21 + 2 * v29) = v24;
        if (v24 == 2 && v20 >= 2)
        {
          *(_WORD *)(v21 + 2 * v29) = 4;
          *(_WORD *)(v10 + 16) = 2;
        }
        v23 /= v24;
        ++v20;
        ++v22;
        unsigned int v19 = v26 + 2;
      }
      while (v23 > 1);
      if (v20 >= 2)
      {
        unint64_t v30 = (unint64_t)v25 >> 1;
        if (v30 <= 1) {
          unint64_t v30 = 1;
        }
        long long v31 = (__int16 *)(v10 + 12);
        do
        {
          __int16 v32 = *v31;
          *long long v31 = *(_WORD *)(v21 + 2 * v26);
          v31 += 2;
          *(_WORD *)(v21 + 2 * v26) = v32;
          v26 -= 2;
          --v30;
        }
        while (v30);
      }
      if (v20)
      {
        uint64_t v33 = 0;
        uint64_t v34 = 2 * v25;
        do
        {
          a2 /= *(unsigned __int16 *)(v21 + 2 * v33);
          *(_WORD *)(v21 + 2 * (v33 + 1)) = a2;
          v33 += 2;
        }
        while (v34 != v33);
      }
      long long v35 = (_WORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1[1] + 72))(a1[2], 2 * v15);
      *(void *)(v10 + 48) = v35;
      if (v35)
      {
        compute_bitrev_table(0, v35, 1, (unsigned __int16 *)(v10 + 12));
        uint64_t v36 = 0;
        goto LABEL_42;
      }
    }
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v38);
    uint64_t v36 = 10;
LABEL_37:
    if (*(void *)(v10 + 56))
    {
      (*(void (**)(uint64_t))(a1[1] + 80))(a1[2]);
      *(void *)(v10 + 56) = 0;
    }
    if (*(void *)(v10 + 48))
    {
      (*(void (**)(uint64_t))(a1[1] + 80))(a1[2]);
      *(void *)(v10 + 48) = 0;
    }
    (*(void (**)(uint64_t, uint64_t))(a1[1] + 80))(a1[2], v10);
    uint64_t v10 = 0;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v38);
    uint64_t v36 = 10;
  }
LABEL_42:
  *a3 = v10;
  return v36;
}

uint64_t compute_bitrev_table(uint64_t result, _WORD *a2, uint64_t a3, unsigned __int16 *a4)
{
  int v5 = result;
  uint64_t v6 = *a4;
  int v7 = a4[1];
  if (v7 == 1)
  {
    if (*a4)
    {
      int v8 = 0;
      do
      {
        *a2 = v8++ + result;
        a2 += a3;
      }
      while (v6 > (unsigned __int16)v8);
    }
  }
  else if (*a4)
  {
    int v9 = 0;
    uint64_t v10 = a4 + 2;
    uint64_t v11 = v6 * a3;
    uint64_t v12 = 2 * a3;
    do
    {
      uint64_t result = compute_bitrev_table((unsigned __int16)v5, a2, v11, v10);
      v5 += v7;
      ++v9;
      a2 = (_WORD *)((char *)a2 + v12);
    }
    while ((int)v6 > (__int16)v9);
  }
  return result;
}

uint64_t opus_fft_impl(uint64_t result, int8x16_t *a2)
{
  uint64_t v208 = *MEMORY[0x263EF8340];
  uint64_t v2 = 1;
  int v3 = *(_DWORD *)(result + 8);
  v207[0] = 1;
  float v4 = (unsigned __int16 *)(result + 14);
  int v5 = -1;
  int v6 = 1;
  do
  {
    v6 *= *(v4 - 1);
    v207[v2] = v6;
    int v7 = *v4;
    v4 += 2;
    ++v2;
    v5 += 2;
  }
  while (v7 != 1);
  int v202 = v3 & ~(v3 >> 31);
  int v8 = *(unsigned __int16 *)(result + 2 * v5 + 12);
  __int16 v206 = &a2->i8[4];
  i32 = (float *)a2[2].i32;
  uint64_t v9 = v2 - 2;
  uint64_t v203 = result;
  do
  {
    unsigned int v10 = v8;
    uint64_t v204 = v9;
    if (v9)
    {
      unsigned int v11 = 2 * v9;
      int v8 = *(unsigned __int16 *)(result + 4 * (int)v9 + 10);
      int v12 = v9;
    }
    else
    {
      unsigned int v11 = 0;
      int v12 = 0;
      int v8 = 1;
    }
    switch(*(_WORD *)(result + 2 * v11 + 12))
    {
      case 2:
        int v13 = v207[v12];
        if (v10 == 1)
        {
          if (v13)
          {
            uint64_t v14 = a2;
            do
            {
              float32x4_t v15 = (float32x4_t)vextq_s8(*v14, *v14, 8uLL);
              v16.i64[0] = vaddq_f32(v15, *(float32x4_t *)v14).u64[0];
              v16.i64[1] = vsubq_f32(v15, *(float32x4_t *)v14).i64[1];
              *v14++ = v16;
              --v13;
            }
            while (v13);
          }
        }
        else
        {
          for (uint64_t i = i32; v13; --v13)
          {
            float v137 = *i;
            float v138 = i[1];
            float v139 = *(i - 8);
            float v140 = *(i - 7);
            float *i = v139 - *i;
            i[1] = v140 - v138;
            *(i - 8) = v137 + v139;
            *(i - 7) = v138 + v140;
            float v141 = i[2];
            float v142 = i[3];
            float v143 = (float)(v141 + v142) * 0.70711;
            float v144 = (float)(v142 - v141) * 0.70711;
            float v145 = *(i - 6);
            float v146 = *(i - 5);
            i[2] = v145 - v143;
            i[3] = v146 - v144;
            *(i - 6) = v145 + v143;
            *(i - 5) = v144 + v146;
            float v148 = i[4];
            float v147 = i[5];
            float v149 = *(i - 4);
            float v150 = *(i - 3);
            i[4] = v149 - v147;
            i[5] = v148 + v150;
            *(i - 4) = v147 + v149;
            *(i - 3) = v150 - v148;
            float v152 = i[6];
            float v151 = i[7];
            float v153 = (float)(v151 - v152) * 0.70711;
            float v154 = (float)(v151 + v152) * -0.70711;
            float v155 = *(i - 2);
            float v156 = *(i - 1);
            i[6] = v155 - v153;
            i[7] = v156 - v154;
            *(i - 2) = v155 + v153;
            *(i - 1) = v154 + v156;
            i += 16;
          }
        }
        break;
      case 3:
        uint64_t v17 = v207[v12];
        if (v17)
        {
          int v18 = 0;
          uint64_t v19 = 0;
          uint64_t v20 = (v17 << v202);
          uint64_t v21 = *(void *)(v203 + 56);
          uint64_t v22 = v10;
          float v23 = *(float *)(v21 + 8 * v20 * (unint64_t)v10 + 4);
          uint64_t v24 = 2 * v10;
          unsigned int v25 = (float *)(v21 + 4);
          uint64_t v26 = 16 * v20;
          uint64_t v27 = 4 * v22;
          uint64_t v28 = 8 * v20;
          do
          {
            uint64_t v29 = v25;
            unint64_t v30 = v25;
            uint64_t v31 = v22;
            __int16 v32 = (float *)&v206[8 * v18];
            do
            {
              uint64_t v33 = &v32[v24];
              float v34 = v32[v24 - 1];
              float v35 = v32[v24];
              float v36 = *(v29 - 1);
              float v37 = (float)(v34 * v36) - (float)(v35 * *v29);
              float v38 = (float)(v36 * v35) + (float)(v34 * *v29);
              long long v39 = &v32[v27];
              float v40 = v32[v27 - 1];
              float v41 = v32[4 * v22];
              float v42 = *(v30 - 1);
              float v43 = (float)(v40 * v42) - (float)(v41 * *v30);
              float v44 = (float)(v42 * v41) + (float)(v40 * *v30);
              float v45 = v38 + v44;
              float v46 = v38 - v44;
              *(v33 - 1) = *(v32 - 1) - (float)((float)(v37 + v43) * 0.5);
              *uint64_t v33 = *v32 - (float)(v45 * 0.5);
              float v47 = v23 * (float)(v37 - v43);
              float v48 = v23 * v46;
              *(v32 - 1) = (float)(v37 + v43) + *(v32 - 1);
              *__int16 v32 = v45 + *v32;
              v32 += 2;
              float v49 = *v33 - v47;
              *(v39 - 1) = v48 + *(v33 - 1);
              float *v39 = v49;
              float v50 = *(v33 - 1) - v48;
              float v51 = v47 + *v33;
              *(v33 - 1) = v50;
              *uint64_t v33 = v51;
              unint64_t v30 = (float *)((char *)v30 + v26);
              uint64_t v29 = (float *)((char *)v29 + v28);
              --v31;
            }
            while (v31);
            ++v19;
            v18 += v8;
          }
          while (v19 != v17);
        }
        break;
      case 4:
        uint64_t v52 = v207[v12];
        if (v10 == 1)
        {
          if (v52)
          {
            long long v53 = (float *)a2;
            do
            {
              float v54 = v53[1];
              float v55 = v53[4];
              float v56 = v53[5];
              float v57 = *v53 - v55;
              float v58 = v54 - v56;
              float v59 = *v53 + v55;
              float v60 = v54 + v56;
              float v61 = v53[2];
              float v62 = v53[3];
              float v63 = v53[6];
              float v64 = v53[7];
              v53[4] = v59 - (float)(v61 + v63);
              v53[5] = v60 - (float)(v62 + v64);
              *long long v53 = v59 + (float)(v61 + v63);
              v53[1] = v60 + (float)(v62 + v64);
              v53[2] = v57 + (float)(v62 - v64);
              void v53[3] = v58 - (float)(v61 - v63);
              v53[6] = v57 - (float)(v62 - v64);
              v53[7] = v58 + (float)(v61 - v63);
              v53 += 8;
              LODWORD(v52) = v52 - 1;
            }
            while (v52);
          }
        }
        else if (v52)
        {
          int v157 = 0;
          uint64_t v158 = 0;
          uint64_t v159 = (v52 << v202);
          uint64_t v160 = *(void *)(v203 + 56) + 4;
          uint64_t v161 = 24 * v159;
          uint64_t v162 = 16 * v159;
          uint64_t v163 = 8 * v159;
          do
          {
            if (v10)
            {
              uint64_t v164 = 0;
              uint64_t v165 = (uint64_t)&v206[8 * v10 + 8 * v157];
              uint64_t v166 = (uint64_t)&v206[16 * v10 + 8 * v157];
              uint64_t v167 = (uint64_t)&v206[24 * v10 + 8 * v157];
              int v168 = (float *)v160;
              int v169 = (float *)v160;
              uint64_t v170 = (float *)v160;
              unint64_t v171 = &v206[8 * v157];
              do
              {
                unsigned int v172 = (float *)&v171[v164];
                int v173 = (float *)(v165 + v164);
                float v174 = *(float *)(v165 + v164 - 4);
                float v175 = *(float *)(v165 + v164);
                float v176 = *(v168 - 1);
                float v177 = (float)(v174 * v176) - (float)(v175 * *v168);
                float v178 = (float)(v176 * v175) + (float)(v174 * *v168);
                uint64_t v179 = (float *)(v166 + v164);
                float v180 = *(float *)(v166 + v164 - 4);
                float v181 = *(float *)(v166 + v164);
                float v182 = *(v169 - 1);
                float v183 = (float)(v180 * v182) - (float)(v181 * *v169);
                float v184 = (float)(v182 * v181) + (float)(v180 * *v169);
                uint64_t v185 = (float *)(v167 + v164);
                float v186 = *(float *)(v167 + v164 - 4);
                float v187 = *(float *)(v167 + v164);
                float v188 = *(v170 - 1);
                float v189 = (float)(v186 * v188) - (float)(v187 * *v170);
                float v190 = (float)(v188 * v187) + (float)(v186 * *v170);
                float v191 = *(float *)&v171[v164 - 4];
                float v192 = *(float *)&v171[v164];
                float v193 = v191 - v183;
                float v194 = v192 - v184;
                float v195 = v183 + v191;
                float v196 = v184 + v192;
                float v197 = v177 + v189;
                float v198 = v178 + v190;
                float v199 = v177 - v189;
                float v200 = v178 - v190;
                *(v179 - 1) = v195 - v197;
                *uint64_t v179 = v196 - v198;
                *(v172 - 1) = v195 + v197;
                *unsigned int v172 = v198 + v196;
                *(v173 - 1) = v193 + v200;
                float *v173 = v194 - v199;
                v164 += 8;
                *(v185 - 1) = v193 - v200;
                *uint64_t v185 = v194 + v199;
                uint64_t v170 = (float *)((char *)v170 + v161);
                int v169 = (float *)((char *)v169 + v162);
                int v168 = (float *)((char *)v168 + v163);
              }
              while (8 * v10 != v164);
            }
            ++v158;
            v157 += v8;
          }
          while (v158 != v52);
        }
        break;
      case 5:
        uint64_t v65 = v207[v12];
        if (v65)
        {
          int v66 = 0;
          uint64_t v67 = 0;
          uint64_t v68 = (v65 << v202);
          uint64_t v69 = *(void *)(v203 + 56);
          unint64_t v70 = v68 * (unint64_t)v10;
          long long v71 = (float *)(v69 + 8 * v70);
          float v72 = *v71;
          float v73 = v71[1];
          int v74 = (float *)(v69 + 16 * v70);
          float v75 = *v74;
          float v76 = v74[1];
          int v77 = (float *)(v69 + 4);
          uint64_t v78 = 24 * v68;
          uint64_t v79 = 32 * v68;
          uint64_t v80 = 16 * v68;
          uint64_t v81 = 8 * v68;
          do
          {
            if (v10)
            {
              uint64_t v82 = 0;
              uint64_t v83 = (uint64_t)&a2[2 * v10].i64[v66];
              uint64_t v84 = (uint64_t)&a2->i64[3 * v10 + v66];
              uint64_t v85 = (uint64_t)&a2[v10].i64[v66];
              int v86 = v77;
              uint64_t v87 = (uint64_t)&a2->i64[v10 + v66];
              int v88 = v77;
              unint64_t v89 = v77;
              uint64_t v90 = v77;
              unsigned int v91 = &a2->i8[8 * v66];
              do
              {
                uint64_t v92 = (float *)(v83 + v82);
                unint64_t v93 = (float *)(v84 + v82);
                unint64_t v94 = (float *)(v85 + v82);
                unint64_t v95 = (float *)(v87 + v82);
                size_t v96 = (float *)&v91[v82];
                float v98 = *(float *)&v91[v82];
                float v97 = *(float *)&v91[v82 + 4];
                float v99 = *(v86 - 1);
                float v100 = *(float *)(v87 + v82);
                float v101 = *(float *)(v87 + v82 + 4);
                float v102 = (float)(v100 * v99) - (float)(v101 * *v86);
                float v103 = (float)(v99 * v101) + (float)(v100 * *v86);
                float v105 = *(float *)(v85 + v82);
                float v104 = *(float *)(v85 + v82 + 4);
                float v106 = *(v88 - 1);
                float v107 = (float)(v105 * v106) - (float)(v104 * *v88);
                float v108 = (float)(v106 * v104) + (float)(v105 * *v88);
                float v109 = *(v90 - 1);
                float v110 = *(float *)(v84 + v82);
                float v111 = *(float *)(v84 + v82 + 4);
                float v112 = (float)(v110 * v109) - (float)(v111 * *v90);
                float v113 = v109 * v111;
                float v114 = *(v89 - 1);
                float v115 = *(float *)(v83 + v82);
                float v116 = *(float *)(v83 + v82 + 4);
                float v117 = v113 + (float)(v110 * *v90);
                float v118 = (float)(v115 * v114) - (float)(v116 * *v89);
                float v119 = (float)(v114 * v116) + (float)(v115 * *v89);
                float v120 = v102 + v118;
                float v121 = v103 + v119;
                float v122 = v102 - v118;
                float v123 = v103 - v119;
                float v124 = v107 + v112;
                float v125 = v108 + v117;
                float v126 = v107 - v112;
                float v127 = v108 - v117;
                float *v96 = v98 + (float)(v124 + v120);
                v96[1] = v97 + (float)(v125 + v121);
                float v128 = v98 + (float)((float)(v75 * v124) + (float)(v120 * v72));
                float v129 = v97 + (float)((float)(v75 * v125) + (float)(v121 * v72));
                float v130 = (float)(v76 * v127) + (float)(v123 * v73);
                float v131 = (float)(v76 * v126) + (float)(v122 * v73);
                float v132 = v98 + (float)((float)(v72 * v124) + (float)(v120 * v75));
                float v133 = v97 + (float)((float)(v72 * v125) + (float)(v121 * v75));
                float v134 = (float)(v127 * v73) - (float)(v123 * v76);
                float *v95 = v128 - v130;
                v95[1] = v129 + v131;
                float v135 = (float)(v122 * v76) - (float)(v126 * v73);
                float *v92 = v130 + v128;
                v92[1] = v129 - v131;
                v82 += 8;
                uint64_t v90 = (float *)((char *)v90 + v78);
                *unint64_t v94 = v134 + v132;
                v94[1] = v133 + v135;
                float *v93 = v132 - v134;
                v93[1] = v133 - v135;
                unint64_t v89 = (float *)((char *)v89 + v79);
                int v88 = (float *)((char *)v88 + v80);
                int v86 = (float *)((char *)v86 + v81);
              }
              while (8 * v10 != v82);
            }
            ++v67;
            v66 += v8;
          }
          while (v67 != v65);
        }
        break;
      default:
        break;
    }
    uint64_t result = v203;
    uint64_t v9 = v204 - 1;
  }
  while (v204 > 0);
  return result;
}

uint64_t opus_fft_c(unsigned int *a1, float32x2_t *a2, int8x16_t *a3)
{
  uint64_t v3 = *a1;
  if (v3)
  {
    float v4 = (const float *)(a1 + 1);
    int v5 = (unsigned __int16 *)*((void *)a1 + 6);
    float32x2_t v6 = vld1_dup_f32(v4);
    do
    {
      unsigned int v8 = *v5++;
      uint64_t v7 = v8;
      float32x2_t v9 = *a2++;
      *(float32x2_t *)&a3->i8[8 * v7] = vmul_f32(v6, v9);
      --v3;
    }
    while (v3);
  }
  return opus_fft_impl((uint64_t)a1, a3);
}

float opus_ifft_c(unsigned int *a1, uint64_t a2, int8x16_t *a3)
{
  if (*a1)
  {
    unint64_t v5 = 0;
    do
    {
      a3->i64[*(unsigned __int16 *)(*((void *)a1 + 6) + 2 * v5)] = *(void *)(a2 + 8 * v5);
      ++v5;
      unint64_t v6 = *a1;
    }
    while (v5 < v6);
    if (v6)
    {
      uint64_t v7 = (float *)&a3->i32[1];
      do
      {
        float *v7 = -*v7;
        v7 += 2;
        --v6;
      }
      while (v6);
    }
  }
  opus_fft_impl((uint64_t)a1, a3);
  uint64_t v9 = *a1;
  if (v9)
  {
    unsigned int v10 = (float *)&a3->i32[1];
    do
    {
      float result = -*v10;
      *unsigned int v10 = result;
      v10 += 2;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t fi_get_window_function(const char *a1)
{
  uint64_t result = cstdlib_strcmp(a1, "HANNING");
  if (result) {
    return cstdlib_strcmp(a1, "TRIANGLE") == 0;
  }
  return result;
}

float window_function(int a1, float a2, float a3)
{
  float v3 = -1.0;
  if (a1 == 1) {
    return 1.0 - fabsf((float)(a2 - (float)((float)(a3 + -1.0) * 0.5)) / (float)(a3 * 0.5));
  }
  if (!a1) {
    return (float)(cosf((float)(a2 * 6.2832) / (float)(a3 + -1.0)) * -0.5) + 0.5;
  }
  return v3;
}

uint64_t fi_stft(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, unsigned int a7, unsigned int a8)
{
  uint64_t v27 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  long long __b = 0u;
  long long v24 = 0u;
  uint64_t v14 = a7;
  float32x4_t v15 = (float *)(a2 + 4 * a7);
  int8x16_t v16 = &v15[a7];
  reflect_padding(a3, a5, a7 >> 1);
  uint64_t v17 = fft_plan_dft_r2c_1d(a1, v14, (uint64_t)v16, a4, 3, (uint64_t *)&__b);
  if (!v17)
  {
    unsigned int v18 = a8 + a8 * (a5 / a8);
    if (v18)
    {
      for (unsigned int i = 0; i < v18; i += a8)
      {
        xmy_toz(a7, v15, (float *)(a3 + 4 * i), v16);
        v21[2] = v25;
        v21[3] = v26;
        uint64_t v22 = v27;
        v21[0] = __b;
        v21[1] = v24;
        fft_execute((unsigned int *)v21);
        *(void *)&long long v25 = v25 + 8 * v14;
      }
    }
    *(void *)&long long v25 = &v16[a7];
  }
  fft_destroy_plan(a1, (uint64_t)&__b);
  return v17;
}

uint64_t fi_istft(uint64_t *a1, float *a2, uint64_t a3, float *a4, unsigned int a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  LODWORD(v10) = a5;
  int v13 = a1;
  int v14 = a8 * a5;
  int v57 = a7 - a8;
  uint64_t v64 = 0;
  long long v62 = 0u;
  long long v63 = 0u;
  long long __b = 0u;
  long long v61 = 0u;
  unsigned int v52 = a7 + a8 - 1;
  uint64_t v15 = v52 / a8;
  int v16 = v15 - 1;
  BOOL v17 = v15 < a5 && a7 >= a8;
  uint64_t v19 = a1[1];
  uint64_t v18 = a1[2];
  uint64_t v20 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v19 + 16);
  unsigned int v21 = v16 * a8;
  int v55 = a8 * a5 + a7 - a8;
  uint64_t v53 = v16 * a8 + a7;
  if (v17) {
    uint64_t v22 = v21 + a7;
  }
  else {
    uint64_t v22 = a8 * a5 + a7 - a8;
  }
  uint64_t v23 = v20(v18, v22, 4);
  if (v23)
  {
    uint64_t v27 = (float *)v23;
    unsigned int v54 = a8;
    unsigned int v51 = v14;
    uint64_t v28 = &a2[a7];
    uint64_t v29 = fft_plan_dft_c2r_1d((uint64_t)v13, a7, (uint64_t)&v28[a7 + a7], (uint64_t)&v28[a7], 3, (uint64_t *)&__b);
    if (v29)
    {
      uint64_t v30 = v29;
LABEL_40:
      double v45 = fft_destroy_plan((uint64_t)v13, (uint64_t)&__b);
      (*(void (**)(uint64_t, float *, double))(v13[1] + 48))(v13[2], v27, v45);
      return v30;
    }
    float v50 = a2;
    uint64_t v31 = a7 + (v10 - 1) * v54;
    __int16 v32 = a4;
    cstdlib_memset(a4, 0, 4 * v31);
    if (v10)
    {
      float v48 = v27;
      float v49 = v13;
      unsigned int v33 = 0;
      int v34 = 0;
      uint64_t v10 = v10;
      uint64_t v35 = v10;
      do
      {
        *(void *)&long long v61 = a3 + 8 * v33;
        v58[2] = v62;
        void v58[3] = v63;
        uint64_t v59 = v64;
        v58[0] = __b;
        v58[1] = v61;
        fft_execute((unsigned int *)v58);
        fi_multiply_add_ansic(&a4[v34], &v28[a7], v28, a7);
        v34 += v54;
        v33 += a7;
        --v35;
      }
      while (v35);
      uint64_t v27 = v48;
      int v13 = v49;
      __int16 v32 = a4;
      if (v15 < v10)
      {
        if (a7 < v54)
        {
          log_OutText(*v49, (uint64_t)"FastInfer", 0, 0, (uint64_t)"hop_size > window_size!", v36, v37, v38, v15);
          uint64_t v30 = 7;
          goto LABEL_40;
        }
        if (v52 >= v54)
        {
          int v41 = 0;
          if (v15 <= 1) {
            uint64_t v42 = 1;
          }
          else {
            uint64_t v42 = v15;
          }
          do
          {
            axpy(a7, v50, 1, &v48[v41], 1, 1.0);
            v41 += v54;
            --v42;
          }
          while (v42);
        }
        uint64_t v43 = v53;
        if (v53)
        {
          float v44 = v48;
          do
          {
            if (*v44 != 0.0) {
              *float v44 = 1.0 / *v44;
            }
            ++v44;
            --v43;
          }
          while (v43);
        }
        xmy(v15 * v54, v48, 1, a4, 1);
        xmy(v57, &v48[v15 * v54], 1, &a4[v51], 1);
        do
        {
          xmy(v54, &v48[v21], 1, &a4[v15 * v54], 1);
          LODWORD(v15) = v15 + 1;
        }
        while (v15 != v10);
LABEL_39:
        uint64_t v30 = 0;
        goto LABEL_40;
      }
      int v39 = 0;
      do
      {
        axpy(a7, v50, 1, &v48[v39], 1, 1.0);
        v39 += v54;
        --v10;
      }
      while (v10);
    }
    if (v31)
    {
      float v40 = v27;
      do
      {
        if (*v40 != 0.0) {
          *float v40 = 1.0 / *v40;
        }
        ++v40;
        --v31;
      }
      while (v31);
    }
    xmy(v55, v27, 1, v32, 1);
    goto LABEL_39;
  }
  log_OutText(*v13, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Memory allocation failed", v24, v25, v26, v47);
  fft_destroy_plan((uint64_t)v13, (uint64_t)&__b);
  return 10;
}

float xmy_c(int a1, float *a2, int a3, float *a4, int a5)
{
  if (a1 >= 1)
  {
    uint64_t v5 = a1;
    do
    {
      float result = *a2 * *a4;
      *a4 = result;
      a4 += a5;
      a2 += a3;
      --v5;
    }
    while (v5);
  }
  return result;
}

float xmy(int a1, float *a2, int a3, float *a4, int a5)
{
  if ((a2 & 0x1F) != 0)
  {
    if (a1 >= 1)
    {
      uint64_t v5 = a1;
      do
      {
        float result = *a2 * *a4;
        *a4 = result;
        a4 += a5;
        a2 += a3;
        --v5;
      }
      while (v5);
    }
  }
  else if (a1 >= 1)
  {
    uint64_t v7 = a1;
    do
    {
      float result = *a2 * *a4;
      *a4 = result;
      a4 += a5;
      a2 += a3;
      --v7;
    }
    while (v7);
  }
  return result;
}

float xmy_toz_c(int a1, float *a2, float *a3, float *a4)
{
  if (a1 >= 1)
  {
    uint64_t v4 = a1;
    do
    {
      float v5 = *a3++;
      float v6 = v5;
      float v7 = *a2++;
      float result = v6 * v7;
      *a4++ = result;
      --v4;
    }
    while (v4);
  }
  return result;
}

float xmy_toz(int a1, float *a2, float *a3, float *a4)
{
  if (((a3 | a2) & 0xF) != 0)
  {
    if (a1 >= 1)
    {
      uint64_t v4 = a1;
      do
      {
        float v5 = *a3++;
        float v6 = v5;
        float v7 = *a2++;
        float result = v6 * v7;
        *a4++ = result;
        --v4;
      }
      while (v4);
    }
  }
  else if (a1 >= 1)
  {
    uint64_t v9 = a1;
    do
    {
      float v10 = *a3++;
      float v11 = v10;
      float v12 = *a2++;
      float result = v11 * v12;
      *a4++ = result;
      --v9;
    }
    while (v9);
  }
  return result;
}

float *fi_multiply_add_ansic(float *result, float *a2, float *a3, unsigned int a4)
{
  if (a4)
  {
    uint64_t v4 = a4;
    do
    {
      float v5 = *a2++;
      float v6 = v5;
      float v7 = *a3++;
      *float result = *result + (float)(v6 * v7);
      ++result;
      --v4;
    }
    while (v4);
  }
  return result;
}

float fi_multiply_multiply_add_ansic(float *a1, float *a2, float *a3, float *a4, float *a5, unsigned int a6)
{
  if (a6)
  {
    uint64_t v6 = a6;
    do
    {
      float v7 = *a1++;
      float v8 = v7;
      float v9 = *a2++;
      float v10 = v9;
      float v11 = *a3++;
      float v12 = v11;
      float v13 = *a4++;
      float result = (float)(v12 * v13) + (float)(v8 * v10);
      *a5++ = result;
      --v6;
    }
    while (v6);
  }
  return result;
}

float fi_multiply_multiply_add(float *a1, float *a2, float *a3, float *a4, float *a5, unsigned int a6)
{
  if ((((a2 | a1) | (a3 | a4)) & 0x1F) != 0)
  {
    if (a6)
    {
      uint64_t v6 = a6;
      do
      {
        float v7 = *a1++;
        float v8 = v7;
        float v9 = *a2++;
        float v10 = v9;
        float v11 = *a3++;
        float v12 = v11;
        float v13 = *a4++;
        float result = (float)(v12 * v13) + (float)(v8 * v10);
        *a5++ = result;
        --v6;
      }
      while (v6);
    }
  }
  else if (a6)
  {
    uint64_t v15 = a6;
    do
    {
      float v16 = *a1++;
      float v17 = v16;
      float v18 = *a2++;
      float v19 = v18;
      float v20 = *a3++;
      float v21 = v20;
      float v22 = *a4++;
      float result = (float)(v21 * v22) + (float)(v17 * v19);
      *a5++ = result;
      --v15;
    }
    while (v15);
  }
  return result;
}

float *fi_multiply_add(float *result, float *a2, float *a3, unsigned int a4)
{
  if ((((a2 | result) | a3) & 0x1F) != 0)
  {
    if (a4)
    {
      uint64_t v4 = a4;
      do
      {
        float v5 = *a2++;
        float v6 = v5;
        float v7 = *a3++;
        *float result = *result + (float)(v6 * v7);
        ++result;
        --v4;
      }
      while (v4);
    }
  }
  else if (a4)
  {
    uint64_t v8 = a4;
    do
    {
      float v9 = *a2++;
      float v10 = v9;
      float v11 = *a3++;
      *float result = *result + (float)(v10 * v11);
      ++result;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t fft_plan_dft_c2r_1d(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t *__b)
{
  cstdlib_memset(__b, 0, 0x48uLL);
  __b[4] = 0;
  __b[5] = a4;
  __b[2] = a3;
  __b[3] = 0;
  *(_DWORD *)long long __b = a2;
  *((_DWORD *)__b + 1) = 2;
  *((_DWORD *)__b + 2) = a5;
  uint64_t v12 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 8) + 64))(*(void *)(a1 + 16), a2, 4);
  __b[6] = v12;
  if (v12)
  {
    uint64_t v13 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 8) + 64))(*(void *)(a1 + 16), a2, 4);
    __b[7] = v13;
    if (v13)
    {
      uint64_t v14 = (*(uint64_t (**)(void, unint64_t, uint64_t))(*(void *)(a1 + 8) + 64))(*(void *)(a1 + 16), (unint64_t)(5 * a2) >> 2, 4);
      __b[8] = v14;
      if (v14)
      {
        uint64_t v15 = (_DWORD *)__b[7];
        *uint64_t v15 = 0;
        makewt(*(_DWORD *)__b >> 2, v15, v14);
        makect(*(_DWORD *)__b >> 2, __b[7], (float *)(__b[8] + 4 * ((unint64_t)*(unsigned int *)__b >> 2)));
        return 0;
      }
    }
    if (__b[6])
    {
      (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
      __b[6] = 0;
    }
  }
  if (__b[7])
  {
    (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
    __b[7] = 0;
  }
  if (__b[8])
  {
    (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
    __b[8] = 0;
  }
  return 10;
}

void makewt(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  *a2 = a1;
  a2[1] = 1;
  if ((int)a1 >= 3)
  {
    unint64_t v6 = a1 >> 1;
    float v7 = 0.7854 / (float)(int)v6;
    float v8 = cosf(v7 * (float)(int)v6);
    *(_DWORD *)a3 = 1065353216;
    *(float *)(a3 + 4) = v8;
    if (v6 == 4)
    {
      __float2 v9 = __sincosf_stret(v7 + v7);
      *(float *)(a3 + 8) = v9.__cosval;
      *(float *)(a3 + 12) = v9.__sinval;
    }
    else if (a1 >= 0xA)
    {
      makeipt(a1, (uint64_t)a2);
      *(float *)(a3 + 8) = 0.5 / cosf(v7 + v7);
      *(float *)(a3 + 12) = 0.5 / cosf(v7 * 6.0);
      float v10 = (float *)(a3 + 28);
      unint64_t v11 = 4;
      do
      {
        __float2 v12 = __sincosf_stret(v7 * (float)(int)v11);
        *(v10 - 3) = v12.__cosval;
        *(v10 - 2) = v12.__sinval;
        __float2 v13 = __sincosf_stret((float)(v7 * 3.0) * (float)(int)v11);
        *(v10 - 1) = v13.__cosval;
        *float v10 = -v13.__sinval;
        v11 += 4;
        v10 += 4;
      }
      while (v11 < v6);
    }
    if (a1 >= 6)
    {
      unsigned int v14 = 0;
      do
      {
        uint64_t v15 = v14 + v6;
        unint64_t v16 = v6 >> 1;
        *(_DWORD *)(a3 + 4 * v15) = 1065353216;
        *(float *)(a3 + 4 * (v15 + 1)) = v8;
        if (v16 == 4)
        {
          int v17 = *(_DWORD *)(a3 + 4 * (v14 + 5));
          *(_DWORD *)(a3 + 4 * (v15 + 2)) = *(_DWORD *)(a3 + 4 * (v14 + 4));
          *(_DWORD *)(a3 + 4 * (v15 + 3)) = v17;
        }
        else if (v6 >= 0xA)
        {
          float v18 = *(float *)(a3 + 4 * (v14 + 6));
          *(float *)(a3 + 4 * (v15 + 2)) = 0.5 / *(float *)(a3 + 4 * (v14 + 4));
          *(float *)(a3 + 4 * (v15 + 3)) = 0.5 / v18;
          float v19 = (long long *)(a3 + 32 + 4 * v14);
          float v20 = (_OWORD *)(a3 + 16 + 4 * v15);
          unint64_t v21 = 4;
          do
          {
            long long v22 = *v19;
            v19 += 2;
            *v20++ = v22;
            v21 += 4;
          }
          while (v21 < v16);
        }
        unsigned int v14 = v15;
        BOOL v23 = v6 > 5;
        LODWORD(v6) = v6 >> 1;
      }
      while (v23);
    }
  }
}

void makect(unsigned int a1, uint64_t a2, float *a3)
{
  *(_DWORD *)(a2 + 4) = a1;
  if ((int)a1 >= 2)
  {
    LODWORD(v5) = a1 >> 1;
    float v6 = 0.7854 / (float)(a1 >> 1);
    float v7 = cosf(v6 * (float)(a1 >> 1));
    *a3 = v7;
    a3[v5] = v7 * 0.5;
    if (a1 >= 4)
    {
      if (v5 <= 2) {
        uint64_t v5 = 2;
      }
      else {
        uint64_t v5 = v5;
      }
      uint64_t v8 = 4 * a1 - 4;
      for (uint64_t i = 1; i != v5; ++i)
      {
        __float2 v10 = __sincosf_stret(v6 * (float)(int)i);
        a3[i] = v10.__cosval * 0.5;
        *(float *)((char *)a3 + v8) = v10.__sinval * 0.5;
        v8 -= 4;
      }
    }
  }
}

uint64_t fft_plan_dft_r2c_1d(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t *__b)
{
  cstdlib_memset(__b, 0, 0x48uLL);
  __b[2] = 0;
  __b[3] = a3;
  __b[4] = a4;
  __b[5] = 0;
  *(_DWORD *)long long __b = a2;
  *((_DWORD *)__b + 1) = 1;
  *((_DWORD *)__b + 2) = a5;
  uint64_t v12 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 8) + 64))(*(void *)(a1 + 16), a2, 4);
  __b[6] = v12;
  if (v12)
  {
    uint64_t v13 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 8) + 64))(*(void *)(a1 + 16), a2, 4);
    __b[7] = v13;
    if (v13)
    {
      uint64_t v14 = (*(uint64_t (**)(void, unint64_t, uint64_t))(*(void *)(a1 + 8) + 64))(*(void *)(a1 + 16), (unint64_t)(5 * a2) >> 2, 4);
      __b[8] = v14;
      if (v14)
      {
        uint64_t v15 = (_DWORD *)__b[7];
        *uint64_t v15 = 0;
        makewt(*(_DWORD *)__b >> 2, v15, v14);
        makect(*(_DWORD *)__b >> 2, __b[7], (float *)(__b[8] + 4 * ((unint64_t)*(unsigned int *)__b >> 2)));
        return 0;
      }
    }
    if (__b[6])
    {
      (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
      __b[6] = 0;
    }
  }
  if (__b[7])
  {
    (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
    __b[7] = 0;
  }
  if (__b[8])
  {
    (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
    __b[8] = 0;
  }
  return 10;
}

float32_t fft_execute(unsigned int *a1)
{
  unint64_t v1 = *a1;
  uint64_t v2 = (float *)*((void *)a1 + 2);
  float v3 = (_DWORD *)*((void *)a1 + 4);
  if (a1[1] == 1)
  {
    uint64_t v4 = (float *)*((void *)a1 + 6);
    uint64_t v5 = (int *)*((void *)a1 + 7);
    uint64_t v6 = *((void *)a1 + 8);
    if (v2)
    {
      cstdlib_memcpy(*((void **)a1 + 6), v2, 4 * (2 * v1));
      float32_t result = cftfsub(2 * v1, (uint64_t)v4, (uint64_t)v5, *v5, v6);
      if ((int)v1 >= 1)
      {
        uint64_t v8 = (float *)(v3 + 1);
        __float2 v9 = v4 + 1;
        do
        {
          *(v8 - 1) = *(v9 - 1);
          float v10 = *v9;
          v9 += 2;
          float32_t result = -v10;
          *uint64_t v8 = -v10;
          v8 += 2;
          --v1;
        }
        while (v1);
      }
    }
    else
    {
      cstdlib_memcpy(*((void **)a1 + 6), *((const void **)a1 + 3), 4 * v1);
      rdft(v1, 1, v4, v5, v6);
      *float v3 = *(_DWORD *)v4;
      v3[1] = 0;
      unint64_t v17 = v1 >> 1;
      if ((int)v1 >= 4)
      {
        unint64_t v18 = v17 - 1;
        float v19 = (float *)(v3 + 3);
        float v20 = v4 + 3;
        do
        {
          *(v19 - 1) = *(v20 - 1);
          float v21 = *v20;
          v20 += 2;
          float *v19 = -v21;
          v19 += 2;
          --v18;
        }
        while (v18);
      }
      float32_t result = v4[1];
      long long v22 = (float32_t *)&v3[2 * v17];
      *long long v22 = result;
      v22[1] = 0.0;
    }
  }
  else
  {
    uint64_t v11 = *((void *)a1 + 6);
    uint64_t v12 = (int *)*((void *)a1 + 7);
    uint64_t v13 = *((void *)a1 + 8);
    if (v3)
    {
      cstdlib_memcpy(*((void **)a1 + 6), v2, 4 * (2 * v1));
      float32_t result = cftbsub(2 * v1, v11, (uint64_t)v12, *v12, v13);
      if ((int)v1 >= 1)
      {
        uint64_t v14 = (float *)(v3 + 1);
        uint64_t v15 = (float *)(v11 + 4);
        do
        {
          *(v14 - 1) = *(v15 - 1);
          float v16 = *v15;
          v15 += 2;
          float32_t result = -v16;
          *uint64_t v14 = -v16;
          v14 += 2;
          --v1;
        }
        while (v1);
      }
    }
    else
    {
      BOOL v23 = (float *)*((void *)a1 + 5);
      *(float *)uint64_t v11 = *v2;
      *(float *)(v11 + 4) = v2[2 * (v1 >> 1)];
      if ((int)v1 >= 4)
      {
        uint64_t v24 = (v1 >> 1) - 1;
        uint64_t v25 = v2 + 3;
        uint64_t v26 = (float *)(v11 + 12);
        do
        {
          *(v26 - 1) = *(v25 - 1);
          float v27 = *v25;
          v25 += 2;
          *uint64_t v26 = -v27;
          v26 += 2;
          --v24;
        }
        while (v24);
      }
      float32_t result = rdft(v1, -1, (float *)v11, v12, v13);
      if ((int)v1 >= 1)
      {
        do
        {
          float v28 = *(float *)v11;
          v11 += 4;
          float32_t result = v28 + v28;
          *v23++ = v28 + v28;
          --v1;
        }
        while (v1);
      }
    }
  }
  return result;
}

double fft_destroy_plan(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 48))
  {
    (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
    *(void *)(a2 + 48) = 0;
  }
  if (*(void *)(a2 + 56))
  {
    (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
    *(void *)(a2 + 56) = 0;
  }
  if (*(void *)(a2 + 64))
  {
    (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
    *(void *)(a2 + 64) = 0;
  }
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  double result = 0.0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  return result;
}

float32_t cdft(unsigned int a1, int a2, uint64_t a3, int *a4, uint64_t a5)
{
  int v6 = *a4;
  if (a2 < 0) {
    return cftbsub(a1, a3, (uint64_t)a4, v6, a5);
  }
  else {
    return cftfsub(a1, a3, (uint64_t)a4, v6, a5);
  }
}

float32_t cftfsub(unsigned int a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  if ((int)a1 < 9)
  {
    if (a1 == 4)
    {
      v11.i64[0] = *(void *)a2;
      v12.i64[0] = *(void *)(a2 + 8);
      v11.i64[1] = *(void *)a2;
      v12.i64[1] = v12.i64[0];
      *(void *)&long long v13 = vaddq_f32(v11, v12).u64[0];
      float32x4_t v10 = vsubq_f32(v11, v12);
      *((void *)&v13 + 1) = v10.i64[1];
      *(_OWORD *)a2 = v13;
    }
    else if (a1 == 8)
    {
      v10.f32[0] = cftf040((float *)a2);
    }
  }
  else if (a1 < 0x21)
  {
    if (a1 == 32)
    {
      cftf161((float *)a2, (float *)(a5 + 4 * (a4 - 8)));
      *(double *)v10.i64 = bitrv216(a2);
    }
    else
    {
      cftf081((float *)a2, a5);
      v10.i64[0] = *(void *)(a2 + 8);
      *(void *)&long long v14 = *(void *)(a2 + 48);
      uint64_t v15 = *(void *)(a2 + 24);
      *(void *)(a2 + 8) = *(void *)(a2 + 32);
      *((void *)&v14 + 1) = v10.i64[0];
      *(_OWORD *)(a2 + 24) = v14;
      *(void *)(a2 + 48) = v15;
    }
  }
  else
  {
    cftf1st(a1, (float *)a2, (float *)(a5 + 4 * (int)(a4 - (a1 >> 2))));
    if (a1 < 0x201)
    {
      if (a1 < 0x81) {
        cftfx41(a1, (float *)a2, a4, a5);
      }
      else {
        cftleaf(a1, 1, (float *)a2, a4, a5);
      }
    }
    else
    {
      cftrec4(a1, a2, a4, a5);
    }
    v10.f32[0] = bitrv2(a1, a3, a2);
  }
  return v10.f32[0];
}

float32_t cftbsub(unsigned int a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  if ((int)a1 < 9)
  {
    if (a1 == 4)
    {
      v11.i64[0] = *(void *)a2;
      v12.i64[0] = *(void *)(a2 + 8);
      v11.i64[1] = *(void *)a2;
      v12.i64[1] = v12.i64[0];
      *(void *)&long long v13 = vaddq_f32(v11, v12).u64[0];
      float32x4_t v10 = vsubq_f32(v11, v12);
      *((void *)&v13 + 1) = v10.i64[1];
      *(_OWORD *)a2 = v13;
    }
    else if (a1 == 8)
    {
      v10.f32[0] = cftb040((float *)a2);
    }
  }
  else if (a1 < 0x21)
  {
    if (a1 == 32)
    {
      cftf161((float *)a2, (float *)(a5 + 4 * (a4 - 8)));
      *(double *)v10.i64 = bitrv216neg(a2);
    }
    else
    {
      cftf081((float *)a2, a5);
      *(double *)v10.i64 = bitrv208neg(a2);
    }
  }
  else
  {
    cftb1st(a1, (float *)a2, (float *)(a5 + 4 * (int)(a4 - (a1 >> 2))));
    if (a1 < 0x201)
    {
      if (a1 < 0x81) {
        cftfx41(a1, (float *)a2, a4, a5);
      }
      else {
        cftleaf(a1, 1, (float *)a2, a4, a5);
      }
    }
    else
    {
      cftrec4(a1, a2, a4, a5);
    }
    v10.f32[0] = bitrv2conj(a1, a3, a2);
  }
  return v10.f32[0];
}

float32_t rdft(int a1, int a2, float *a3, int *a4, uint64_t a5)
{
  int v9 = a4[1];
  uint64_t v10 = *a4;
  if (a2 < 0)
  {
    float32_t result = (float)(*a3 - a3[1]) * 0.5;
    float v13 = *a3 - result;
    *a3 = v13;
    a3[1] = result;
    if (a1 < 5)
    {
      if (a1 == 4)
      {
        float v20 = a3[2];
        float v21 = a3[3];
        float v22 = result - v21;
        float32_t result = result + v21;
        *a3 = v13 + v20;
        a3[1] = result;
        a3[2] = v13 - v20;
        a3[3] = v22;
      }
    }
    else
    {
      rftbsub(a1, (uint64_t)a3, v9, a5 + 4 * v10);
      return cftbsub(a1, (uint64_t)a3, (uint64_t)a4, v10, a5);
    }
  }
  else
  {
    if (a1 < 5)
    {
      float v11 = *a3;
      if (a1 == 4)
      {
        float v15 = a3[1];
        float v14 = a3[2];
        float v16 = v11 - v14;
        float v17 = a3[3];
        float v11 = v11 + v14;
        a3[1] = v15 + v17;
        a3[2] = v16;
        a3[3] = v15 - v17;
      }
    }
    else
    {
      cftfsub(a1, (uint64_t)a3, (uint64_t)a4, *a4, a5);
      rftfsub(a1, (uint64_t)a3, v9, a5 + 4 * v10);
      float v11 = *a3;
    }
    float v18 = a3[1];
    float v19 = v11 - v18;
    float32_t result = v11 + v18;
    *a3 = result;
    a3[1] = v19;
  }
  return result;
}

float rftfsub(int a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a1 >= 6)
  {
    unint64_t v4 = a1 >> 1;
    int v5 = 2 * a3 / (int)v4;
    int v6 = (float *)(a4 - 4 * v5 + 4 * a3);
    uint64_t v7 = 4 * v5;
    uint64_t v8 = -4 * v5;
    int v9 = (float *)(a2 + 4 * a1 - 4);
    uint64_t v10 = (float *)(a4 + v7);
    float v11 = (float *)(a2 + 12);
    unint64_t v12 = 2;
    float result = 0.5;
    do
    {
      float v14 = 0.5 - *v6;
      float v15 = *(v11 - 1);
      float v16 = v15 - *(v9 - 1);
      float v17 = *v11 + *v9;
      float v18 = (float)(v14 * v16) - (float)(*v10 * v17);
      float v19 = (float)(*v10 * v16) + (float)(v14 * v17);
      float v20 = *v11 - v19;
      *(v11 - 1) = v15 - v18;
      *float v11 = v20;
      v12 += 2;
      int v6 = (float *)((char *)v6 + v8);
      float v21 = *v9 - v19;
      *(v9 - 1) = *(v9 - 1) + v18;
      *int v9 = v21;
      v9 -= 2;
      uint64_t v10 = (float *)((char *)v10 + v7);
      v11 += 2;
    }
    while (v12 < v4);
  }
  return result;
}

float rftbsub(int a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a1 >= 6)
  {
    unint64_t v4 = a1 >> 1;
    int v5 = 2 * a3 / (int)v4;
    int v6 = (float *)(a4 - 4 * v5 + 4 * a3);
    uint64_t v7 = 4 * v5;
    uint64_t v8 = -4 * v5;
    int v9 = (float *)(a2 + 4 * a1 - 4);
    uint64_t v10 = (float *)(a4 + v7);
    float v11 = (float *)(a2 + 12);
    unint64_t v12 = 2;
    float result = 0.5;
    do
    {
      float v14 = 0.5 - *v6;
      float v15 = *(v11 - 1);
      float v16 = v15 - *(v9 - 1);
      float v17 = *v11 + *v9;
      float v18 = (float)(*v10 * v17) + (float)(v14 * v16);
      float v19 = (float)(v14 * v17) - (float)(*v10 * v16);
      float v20 = *v11 - v19;
      *(v11 - 1) = v15 - v18;
      *float v11 = v20;
      v12 += 2;
      int v6 = (float *)((char *)v6 + v8);
      float v21 = *v9 - v19;
      *(v9 - 1) = *(v9 - 1) + v18;
      *int v9 = v21;
      v9 -= 2;
      uint64_t v10 = (float *)((char *)v10 + v7);
      v11 += 2;
    }
    while (v12 < v4);
  }
  return result;
}

uint64_t makeipt(uint64_t result, uint64_t a2)
{
  *(void *)(a2 + 8) = 0x1000000000;
  if ((int)result >= 33)
  {
    int v2 = 2;
    do
    {
      int v3 = 2 * v2;
      if (v2 < 2 * v2)
      {
        int v4 = 16 * v2;
        int v5 = (_DWORD *)(a2 + 4 * (v2 + (uint64_t)v3));
        int v6 = (_DWORD *)(a2 + 8 * v2);
        uint64_t v7 = (int *)(a2 + 4 * v2);
        uint64_t v8 = v3 - (uint64_t)v2;
        do
        {
          int v9 = *v7++;
          *v6++ = 4 * v9;
          *v5++ = v4 + 4 * v9;
          --v8;
        }
        while (v8);
      }
      int v2 = v3;
      BOOL v10 = result > 0x83;
      float result = result >> 2;
    }
    while (v10);
  }
  return result;
}

float cftf1st(int a1, float *a2, float *a3)
{
  uint64_t v3 = 2 * (a1 >> 3);
  int v4 = 4 * (a1 >> 3);
  float v5 = a2[v4];
  float v6 = a2[1];
  float v7 = *a2 + v5;
  uint64_t v8 = &a2[4 * (a1 >> 3)];
  float v9 = v8[1];
  float v10 = v6 + v9;
  float v11 = *a2 - v5;
  uint64_t v12 = 2 * (a1 >> 3);
  float v13 = a2[v12];
  float v14 = v6 - v9;
  float v15 = a2[6 * (a1 >> 3)];
  float v16 = v13 + v15;
  float v17 = a2[(int)(v3 | 1)];
  int v18 = (6 * (a1 >> 3)) | 1;
  float v19 = a2[v18];
  float v20 = v13 - v15;
  *a2 = v7 + v16;
  a2[1] = v10 + (float)(v17 + v19);
  a2[v12] = v7 - v16;
  a2[(int)(v3 | 1)] = v10 - (float)(v17 + v19);
  a2[v4] = v11 - (float)(v17 - v19);
  v8[1] = v14 + v20;
  a2[6 * (a1 >> 3)] = v11 + (float)(v17 - v19);
  a2[v18] = v14 - v20;
  uint64_t v21 = (uint64_t)a1 >> 3;
  float v22 = a3[1];
  float v23 = a3[2];
  float v24 = a3[3];
  uint64_t v25 = v21 - 2;
  if (a1 < 40)
  {
    float v48 = 0.0;
    float v47 = 1.0;
    float v49 = 1.0;
    float v50 = 0.0;
  }
  else
  {
    uint64_t v26 = 0;
    uint64_t v27 = 24 * v21;
    uint64_t v28 = v27 + 12;
    uint64_t v29 = 4 * v4;
    uint64_t v30 = v29 + 12;
    uint64_t v31 = v29 - 4;
    uint64_t v32 = v27 - 4;
    unsigned int v33 = a3 + 7;
    uint64_t v34 = 24 * (a1 >> 3) + 16;
    uint64_t v35 = 2 * (a1 >> 3);
    uint64_t v36 = v35 * 4 - 8;
    uint64_t v37 = 8 * v3 + 16;
    uint64_t v38 = 8 * v3 - 8;
    uint64_t v39 = 12 * v3 - 8;
    float v40 = 1.0;
    float v41 = 0.0;
    float v42 = 0.0;
    uint64_t v43 = 16 * v3 - 16;
    uint64_t v44 = 2;
    uint64_t v45 = (v3 << 34) - 0x200000000;
    float v46 = 1.0;
    do
    {
      float v47 = v33[v26 - 3];
      float v48 = v33[v26 - 2];
      float v49 = v33[v26 - 1];
      float v50 = v33[v26];
      float v51 = v40 + v49;
      unsigned int v52 = &a2[v26];
      uint64_t v53 = (float *)((char *)a2 + v37);
      float v54 = *(float *)((char *)a2 + v37 - 8);
      float v55 = a2[v26 + 2];
      float v56 = a2[v26 + 3];
      float v57 = v41 + v50;
      float v58 = v55 + v54;
      float v59 = *(float *)((char *)a2 + v30);
      float v60 = v56 + v59;
      float v61 = v55 - v54;
      float v62 = v56 - v59;
      float v63 = a2[v26 + 4];
      float v64 = a2[v26 + 5];
      float v65 = *(float *)((char *)a2 + v37);
      float v66 = *(float *)((char *)a2 + v37 + 4);
      float v67 = v63 + v65;
      float v68 = v64 + v66;
      float v69 = v63 - v65;
      float v70 = v64 - v66;
      long long v71 = &a2[v35];
      float v72 = (float *)((char *)a2 + v34);
      float v73 = *(float *)((char *)a2 + v34 - 8);
      float v74 = v23 * (float)(v46 + v47);
      float v75 = a2[v35 + 2];
      float v76 = a2[v35 + 3];
      float v77 = v75 + v73;
      float v78 = *(float *)((char *)a2 + v28);
      float v79 = v23 * (float)(v42 + v48);
      float v80 = v76 + v78;
      float v81 = v75 - v73;
      float v82 = v76 - v78;
      float v84 = a2[v35 + 4];
      float v83 = a2[v35 + 5];
      float v85 = v24 * v51;
      float v87 = *(float *)((char *)a2 + v34);
      float v86 = *(float *)((char *)a2 + v34 + 4);
      float v88 = v84 + v87;
      float v89 = v84 - v87;
      float v90 = v24 * v57;
      v52[2] = v58 + v77;
      v52[3] = v60 + v80;
      v52[4] = v67 + v88;
      v52[5] = v68 + (float)(v83 + v86);
      v71[2] = v58 - v77;
      v71[3] = v60 - v80;
      v71[4] = v67 - v88;
      v71[5] = v68 - (float)(v83 + v86);
      *(v53 - 2) = (float)(v74 * (float)(v61 - v82)) - (float)(v79 * (float)(v62 + v81));
      float v91 = v69 - (float)(v83 - v86);
      *(float *)((char *)a2 + v30) = (float)(v79 * (float)(v61 - v82)) + (float)(v74 * (float)(v62 + v81));
      float v92 = v61 + v82;
      float v93 = v62 - v81;
      *uint64_t v53 = (float)(v47 * v91) - (float)(v48 * (float)(v70 + v89));
      v53[1] = (float)(v48 * v91) + (float)(v47 * (float)(v70 + v89));
      float v94 = (float)((float)(v24 * v57) * v93) + (float)(v85 * v92);
      float v95 = (float)(v85 * v93) - (float)((float)(v24 * v57) * v92);
      float v96 = v69 + (float)(v83 - v86);
      *(v72 - 2) = v94;
      float v97 = v70 - v89;
      *(float *)((char *)a2 + v28) = v95;
      *float v72 = (float)(v50 * v97) + (float)(v49 * v96);
      v72[1] = (float)(v49 * v97) - (float)(v50 * v96);
      float v98 = (float *)((char *)a2 + v36);
      float v99 = (float *)((char *)a2 + v39);
      float v101 = *(float *)((char *)a2 + v39 - 4);
      float v100 = *(float *)((char *)a2 + v39);
      float v102 = *(float *)((char *)a2 + v36);
      float v103 = *(float *)((char *)a2 + v36 + 4);
      float v104 = v102 + v100;
      float v105 = *(float *)((char *)a2 + v32);
      float v106 = v102 - v100;
      float v107 = *(float *)((char *)a2 + v36 - 8);
      float v108 = *(float *)((char *)a2 + v36 - 4);
      float v109 = *(float *)((char *)a2 + v39 - 8);
      float v110 = v107 + v109;
      float v111 = v108 + v101;
      float v112 = v107 - v109;
      float v113 = v108 - v101;
      float v114 = (float *)((char *)a2 + v38);
      float v115 = *(float *)((char *)a2 + v38 - 4);
      float v116 = *(float *)((char *)a2 + v38);
      float v117 = (float *)((char *)a2 + v43);
      float v118 = v103 + v105;
      float v119 = *(float *)((char *)a2 + v43 + 4);
      float v120 = *(float *)((char *)a2 + v43 + 8);
      float v121 = v116 + v120;
      float v122 = *(float *)((char *)a2 + v31);
      float v123 = v103 - v105;
      uint64_t v124 = (v45 >> 30) | 4;
      float v125 = *(float *)((char *)a2 + v124);
      float v126 = v116 - v120;
      float v127 = *(float *)((char *)a2 + v38 - 8);
      float v128 = v122 + v125;
      float v129 = *(float *)((char *)a2 + v43);
      float v130 = v127 + v129;
      float v131 = v122 - v125;
      float v132 = v127 - v129;
      *float v98 = v104 + v121;
      v98[1] = v118 + v128;
      *(v98 - 2) = v110 + v130;
      *(v98 - 1) = v111 + (float)(v115 + v119);
      float *v114 = v104 - v121;
      *(float *)((char *)a2 + v31) = v118 - v128;
      *(v114 - 2) = v110 - v130;
      *(v114 - 1) = v111 - (float)(v115 + v119);
      float v133 = (float)(v79 * (float)(v106 - v131)) - (float)(v74 * (float)(v123 + v126));
      float v134 = (float)(v74 * (float)(v106 - v131)) + (float)(v79 * (float)(v123 + v126));
      float v135 = v106 + v131;
      float v136 = v123 - v126;
      *float v99 = v133;
      *(float *)((char *)a2 + v32) = v134;
      v44 += 4;
      *(v99 - 2) = (float)(v48 * (float)(v112 - (float)(v115 - v119))) - (float)(v47 * (float)(v113 + v132));
      *(v99 - 1) = (float)(v47 * (float)(v112 - (float)(v115 - v119))) + (float)(v48 * (float)(v113 + v132));
      v28 += 16;
      v30 += 16;
      v31 -= 16;
      v26 += 4;
      v34 += 16;
      v117[2] = (float)(v85 * v136) + (float)(v90 * v135);
      v36 -= 16;
      v37 += 16;
      v35 += 4;
      v38 -= 16;
      *(float *)((char *)a2 + v124) = (float)(v90 * v136) - (float)(v85 * v135);
      v39 -= 16;
      v45 -= 0x400000000;
      v43 -= 16;
      float v41 = v50;
      v32 -= 16;
      *float v117 = (float)(v49 * (float)(v113 - v132)) + (float)(v50 * (float)(v112 + (float)(v115 - v119)));
      v117[1] = (float)(v50 * (float)(v113 - v132)) - (float)(v49 * (float)(v112 + (float)(v115 - v119)));
      float v40 = v49;
      float v42 = v48;
      float v46 = v47;
    }
    while (v44 < v25);
  }
  float v137 = v23 * (float)(v22 + v47);
  float v138 = v23 * (float)(v22 + v48);
  float v139 = v24 * (float)(v49 - v22);
  float v140 = v24 * (float)(v50 - v22);
  float v141 = a2[v25];
  float v142 = &a2[5 * v21];
  float v143 = *(v142 - 2);
  float v144 = *(v142 - 1);
  float v145 = v141 + v143;
  float v146 = &a2[v21];
  float v147 = *(v146 - 1);
  float v148 = v147 + v144;
  float v149 = v141 - v143;
  float v150 = v147 - v144;
  float v151 = &a2[3 * (int)v21];
  float v152 = &a2[7 * v21];
  float v153 = *(v152 - 2);
  float v154 = *(v151 - 2);
  float v155 = *(v151 - 1);
  float v156 = v154 + v153;
  int v157 = &a2[7 * v21];
  float v158 = *(v157 - 1);
  float v159 = v154 - v153;
  a2[v25] = v145 + v156;
  *(v146 - 1) = v148 + (float)(v155 + v158);
  *(v151 - 2) = v145 - v156;
  *(v151 - 1) = v148 - (float)(v155 + v158);
  float v160 = v149 - (float)(v155 - v158);
  *(v142 - 2) = (float)(v137 * v160) - (float)(v138 * (float)(v150 + v159));
  *(v142 - 1) = (float)(v138 * v160) + (float)(v137 * (float)(v150 + v159));
  float v161 = v149 + (float)(v155 - v158);
  float v162 = v150 - v159;
  *(v152 - 2) = (float)(v140 * v162) + (float)(v139 * v161);
  *(v157 - 1) = (float)(v139 * v162) - (float)(v140 * v161);
  float v163 = v146[1];
  float v164 = v142[1];
  float v165 = *v146 + *v142;
  float v166 = v163 + v164;
  float v167 = *v146 - *v142;
  float v168 = v163 - v164;
  float v169 = v151[1];
  float v170 = v157[1];
  float v171 = *v151 + *v157;
  float v172 = v169 + v170;
  float v173 = *v151 - *v157;
  float v174 = v169 - v170;
  *float v146 = v165 + v171;
  v146[1] = v166 + v172;
  *float v151 = v165 - v171;
  v151[1] = v166 - v172;
  float *v142 = v22 * (float)((float)(v167 - v174) - (float)(v168 + v173));
  v142[1] = v22 * (float)((float)(v168 + v173) + (float)(v167 - v174));
  float v175 = v167 + v174;
  float v176 = v168 - v173;
  *int v157 = -(float)(v22 * (float)(v176 + v175));
  v157[1] = -(float)(v22 * (float)(v176 - v175));
  float v177 = v146[2];
  float v178 = v146[3];
  float v179 = v142[2];
  float v180 = v142[3];
  float v181 = v177 + v179;
  float v182 = v178 + v180;
  float v183 = v177 - v179;
  float v184 = v178 - v180;
  float v185 = v151[2];
  float v186 = v151[3];
  float v187 = v157[2];
  float v188 = v157[3];
  float v189 = v185 + v187;
  float v190 = v186 + v188;
  float v191 = v185 - v187;
  float v192 = v186 - v188;
  v146[2] = v181 + v189;
  v146[3] = v182 + v190;
  v151[2] = v181 - v189;
  v151[3] = v182 - v190;
  v142[2] = (float)(v138 * (float)(v183 - v192)) - (float)(v137 * (float)(v184 + v191));
  v142[3] = (float)(v137 * (float)(v183 - v192)) + (float)(v138 * (float)(v184 + v191));
  float v193 = v183 + v192;
  float v194 = (float)(v139 * (float)(v184 - v191)) + (float)(v140 * v193);
  float result = (float)(v140 * (float)(v184 - v191)) - (float)(v139 * v193);
  v157[2] = v194;
  v157[3] = result;
  return result;
}

void cftrec4(int a1, uint64_t a2, int a3, uint64_t a4)
{
  int v7 = a1;
  int v8 = a1;
  if (a1 >= 513)
  {
    unsigned int v9 = a1;
    do
    {
      int v8 = v9 >> 2;
      cftmdl1(v9 >> 2, (float *)(a2 + 4 * (int)(v7 - (v9 >> 2))), a4 + 4 * (int)(a3 - (v9 >> 3)));
      BOOL v10 = v9 > 0x803;
      v9 >>= 2;
    }
    while (v10);
  }
  cftleaf(v8, 1, (float *)(a2 + 4 * (v7 - v8)), a3, a4);
  if (v7 - v8 >= 1)
  {
    int v11 = 1;
    do
    {
      int v12 = cfttree(v8, v7 - v8, v11, a2, a3, a4);
      cftleaf(v8, v12, (float *)(a2 + 4 * (-2 * v8 + v7)), a3, a4);
      ++v11;
      v7 -= v8;
    }
    while (v7 - v8 > 0);
  }
}

float cftleaf(int a1, int a2, float *a3, int a4, uint64_t a5)
{
  int v7 = (float *)(a5 + 4 * a4 - 32);
  if (a1 == 512)
  {
    uint64_t v8 = a5 + 4 * a4;
    uint64_t v9 = v8 - 256;
    cftmdl1(128, a3, v8 - 256);
    cftf161(a3, v7);
    BOOL v10 = (float *)(v8 - 128);
    cftf162(a3 + 32, (float *)(v8 - 128));
    cftf161(a3 + 64, v7);
    cftf161(a3 + 96, v7);
    uint64_t v11 = v8 - 512;
    cftmdl2(128, a3 + 128, v11);
    cftf161(a3 + 128, v7);
    cftf162(a3 + 160, v10);
    cftf161(a3 + 192, v7);
    cftf162(a3 + 224, v10);
    cftmdl1(128, a3 + 256, v9);
    cftf161(a3 + 256, v7);
    cftf162(a3 + 288, v10);
    cftf161(a3 + 320, v7);
    cftf161(a3 + 352, v7);
    int v12 = a3 + 384;
    if (a2)
    {
      cftmdl1(128, v12, v9);
      cftf161(a3 + 480, v7);
    }
    else
    {
      cftmdl2(128, v12, v11);
      cftf162(a3 + 480, v10);
    }
    cftf161(a3 + 384, v7);
    cftf162(a3 + 416, v10);
    return cftf161(a3 + 448, v7);
  }
  else
  {
    uint64_t v13 = a5 + 4 * a4;
    uint64_t v14 = v13 - 128;
    cftmdl1(64, a3, v13 - 128);
    cftf081(a3, (uint64_t)v7);
    cftf082(a3 + 16, v7);
    cftf081(a3 + 32, (uint64_t)v7);
    cftf081(a3 + 48, (uint64_t)v7);
    uint64_t v15 = v13 - 256;
    cftmdl2(64, a3 + 64, v15);
    cftf081(a3 + 64, (uint64_t)v7);
    cftf082(a3 + 80, v7);
    cftf081(a3 + 96, (uint64_t)v7);
    cftf082(a3 + 112, v7);
    cftmdl1(64, a3 + 128, v14);
    cftf081(a3 + 128, (uint64_t)v7);
    cftf082(a3 + 144, v7);
    cftf081(a3 + 160, (uint64_t)v7);
    cftf081(a3 + 176, (uint64_t)v7);
    float v16 = a3 + 192;
    if (a2)
    {
      cftmdl1(64, v16, v14);
      cftf081(a3 + 240, (uint64_t)v7);
    }
    else
    {
      cftmdl2(64, v16, v15);
      cftf082(a3 + 240, v7);
    }
    cftf081(a3 + 192, (uint64_t)v7);
    cftf082(a3 + 208, v7);
    return cftf081(a3 + 224, (uint64_t)v7);
  }
}

float cftfx41(int a1, float *a2, int a3, uint64_t a4)
{
  uint64_t v5 = a4 + 4 * a3;
  float v6 = (float *)(v5 - 32);
  if (a1 == 128)
  {
    uint64_t v8 = a3;
    cftf161(a2, (float *)(v5 - 32));
    cftf162(a2 + 32, (float *)(a4 + 4 * v8 - 128));
    cftf161(a2 + 64, v6);
    return cftf161(a2 + 96, v6);
  }
  else
  {
    cftf081(a2, v5 - 32);
    cftf082(a2 + 16, v6);
    cftf081(a2 + 32, (uint64_t)v6);
    return cftf081(a2 + 48, (uint64_t)v6);
  }
}

float bitrv2(int a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = a1 >> 2;
  if (a1 < 36)
  {
    int v8 = a1 >> 1;
    uint64_t v9 = 4;
    int v4 = 1;
    if (v3 == 8)
    {
LABEL_8:
      uint64_t v10 = 0;
      uint64_t v11 = 8 * v4;
      uint64_t v12 = v4;
      uint64_t v13 = a2 + 4 * v4;
      uint64_t v231 = 2 * (int)v9 + v8;
      uint64_t v232 = v4;
      uint64_t v233 = a2;
      do
      {
        uint64_t v14 = v10 + v12;
        if (v10)
        {
          uint64_t v15 = 0;
          uint64_t v16 = 0;
          uint64_t v234 = v10 + v12;
          uint64_t v17 = *(int *)(a2 + 4 * v14);
          uint64_t v18 = 4 * (int)v10;
          uint64_t v239 = (v9 << 33) + (v17 << 33);
          uint64_t v240 = 8 * v17;
          unint64_t v238 = ((unint64_t)(3 * v9) << 32) + (v17 << 33);
          uint64_t v19 = v231 + (int)v9 + 2 * v17;
          uint64_t v237 = (v19 << 32) + 0x300000000;
          int v236 = 2 * v17;
          int v20 = v9 + 2 * v17;
          int v21 = 2 * (v9 + v17);
          int v22 = 3 * v9 + 2 * v17;
          int v23 = v8 + 3 * v9 + 2 + 2 * v17;
          uint64_t v24 = v231 + 2 * v17;
          uint64_t v25 = (v24 << 32) + 0x300000000;
          uint64_t v26 = (v24 << 32) + 0x200000000;
          uint64_t v27 = (int)v9 + (uint64_t)v8 + 2 * v17;
          uint64_t v28 = (v27 << 32) + 0x300000000;
          uint64_t v29 = (v27 << 32) + 0x200000000;
          uint64_t v30 = 4 * (int)v9 + 8 * v17;
          uint64_t v31 = a3 + 8 * (int)v9 + 8 * v17;
          uint64_t v32 = a3 + 12 * (int)v9 + 8 * v17;
          uint64_t v33 = 4 * v19;
          uint64_t v34 = 4 * v27;
          uint64_t v35 = 4 * v24;
          uint64_t v36 = a3;
          uint64_t v235 = v10;
          uint64_t v37 = 4 * v8 + 8 * v17;
          do
          {
            uint64_t v38 = v13;
            uint64_t v39 = v18 + 2 * *(int *)(v13 + v16);
            float v40 = (_DWORD *)(v36 + v240);
            int v41 = *(_DWORD *)(v36 + v240);
            int v42 = *(_DWORD *)(v36 + v240 + 4);
            uint64_t v43 = (4 * v39) | 4;
            int v44 = *(_DWORD *)(a3 + v43);
            *float v40 = *(_DWORD *)(a3 + 4 * v39);
            v40[1] = v44;
            *(_DWORD *)(a3 + 4 * v39) = v41;
            uint64_t v45 = (int)v39 + (uint64_t)(int)v11;
            float v46 = (_DWORD *)(v36 + v30);
            *(_DWORD *)(a3 + v43) = v42;
            int v47 = *(_DWORD *)(v36 + v30);
            int v48 = *(_DWORD *)(v36 + v30 + 4);
            uint64_t v49 = (4 * v45) | 4;
            int v50 = *(_DWORD *)(a3 + v49);
            *float v46 = *(_DWORD *)(a3 + 4 * v45);
            v46[1] = v50;
            *(_DWORD *)(a3 + 4 * v45) = v47;
            *(_DWORD *)(a3 + v49) = v48;
            int v51 = *(_DWORD *)(v31 + 4 * v16);
            uint64_t v52 = (int)v45 - (uint64_t)(int)v9;
            uint64_t v53 = ((v239 + v15) >> 30) | 4;
            int v54 = *(_DWORD *)(a3 + v53);
            uint64_t v55 = (4 * v52) | 4;
            int v56 = *(_DWORD *)(a3 + v55);
            *(_DWORD *)(v31 + 4 * v16) = *(_DWORD *)(a3 + 4 * v52);
            *(_DWORD *)(a3 + v53) = v56;
            *(_DWORD *)(a3 + 4 * v52) = v51;
            *(_DWORD *)(a3 + v55) = v54;
            uint64_t v57 = v11 + (int)v52;
            int v58 = *(_DWORD *)(v32 + 4 * v16);
            uint64_t v59 = ((uint64_t)(v238 + v15) >> 30) | 4;
            float v60 = (_DWORD *)(a3 + 4 * v57);
            int v61 = *(_DWORD *)(a3 + v59);
            uint64_t v62 = (4 * v57) | 4;
            int v63 = *(_DWORD *)(a3 + v62);
            *(_DWORD *)(v32 + 4 * v16) = *v60;
            *(_DWORD *)(a3 + v59) = v63;
            *float v60 = v58;
            *(_DWORD *)(a3 + v62) = v61;
            v57 += 2;
            float v64 = (_DWORD *)(v36 + v33);
            int v65 = *(_DWORD *)(v36 + v33);
            int v66 = *(_DWORD *)(v36 + v33 + 4);
            int v67 = v60[3];
            *float v64 = *(_DWORD *)(a3 + 4 * v57);
            v64[1] = v67;
            *(_DWORD *)(a3 + 4 * v57) = v65;
            v60[3] = v66;
            uint64_t v68 = (int)v57 - (uint64_t)(int)v11;
            float v69 = (_DWORD *)(v36 + v35);
            int v70 = *(_DWORD *)(v36 + v35);
            int v71 = *(_DWORD *)(v36 + v35 + 4);
            float v72 = (_DWORD *)(a3 + 4 * v68);
            int v73 = v72[1];
            *float v69 = *v72;
            v69[1] = v73;
            *float v72 = v70;
            v72[1] = v71;
            uint64_t v74 = (int)v68 + (uint64_t)(int)v9;
            float v75 = (_DWORD *)(v36 + v34);
            int v76 = *(_DWORD *)(v36 + v34);
            int v77 = *(_DWORD *)(v36 + v34 + 4);
            float v78 = (_DWORD *)(a3 + 4 * v74);
            int v79 = v78[1];
            *float v75 = *v78;
            v75[1] = v79;
            *float v78 = v76;
            v78[1] = v77;
            uint64_t v80 = (int)v74 - (uint64_t)(int)v11;
            float v81 = (_DWORD *)(v36 + v37);
            int v82 = *(_DWORD *)(v36 + v37);
            int v83 = *(_DWORD *)(v36 + v37 + 4);
            float v84 = (_DWORD *)(a3 + 4 * v80);
            int v85 = v84[1];
            *float v81 = *v84;
            v81[1] = v85;
            *float v84 = v82;
            v84[1] = v83;
            float v86 = (_DWORD *)(a3 + 4 * ((int)v80 + (uint64_t)v8));
            int v87 = *(_DWORD *)(v36 + v37 + 8);
            int v88 = *(_DWORD *)(v36 + v37 + 12);
            int v89 = v86[1];
            v81[2] = *v86;
            v81[3] = v89;
            *float v86 = v87;
            v86[1] = v88;
            uint64_t v90 = (v29 + v15) >> 30;
            int v91 = *(_DWORD *)(a3 + v90);
            uint64_t v92 = (v28 + v15) >> 30;
            int v93 = *(_DWORD *)(a3 + v92);
            uint64_t v94 = (int)v74 + v8;
            float v95 = (_DWORD *)(a3 + 4 * v94);
            int v96 = v95[1];
            *(_DWORD *)(a3 + v90) = *v95;
            *(_DWORD *)(a3 + v92) = v96;
            _DWORD *v95 = v91;
            v95[1] = v93;
            uint64_t v97 = v94 - (int)v9;
            uint64_t v98 = (v26 + v15) >> 30;
            int v99 = *(_DWORD *)(a3 + v98);
            uint64_t v100 = (v25 + v15) >> 30;
            int v101 = *(_DWORD *)(a3 + v100);
            float v102 = (_DWORD *)(a3 + 4 * v97);
            int v103 = v102[1];
            *(_DWORD *)(a3 + v98) = *v102;
            *(_DWORD *)(a3 + v100) = v103;
            *float v102 = v99;
            v102[1] = v101;
            uint64_t v104 = (int)v97 + (uint64_t)(int)v11;
            int v105 = *(_DWORD *)(a3 + 4 * (v23 + (int)v16));
            uint64_t v106 = (v237 + v15) >> 30;
            int v107 = *(_DWORD *)(a3 + v106);
            float v108 = (_DWORD *)(a3 + 4 * v104);
            int v109 = v108[1];
            *(_DWORD *)(a3 + 4 * (v23 + (int)v16)) = *v108;
            *(_DWORD *)(a3 + v106) = v109;
            *float v108 = v105;
            v108[1] = v107;
            LODWORD(v106) = v22 + v16 + 2;
            v104 -= 2;
            int v110 = *(_DWORD *)(a3 + 4 * (int)v106);
            LODWORD(v98) = v22 + v16 + 3;
            int v111 = *(_DWORD *)(a3 + 4 * (int)v98);
            int v112 = *(v108 - 1);
            *(_DWORD *)(a3 + 4 * (int)v106) = *(_DWORD *)(a3 + 4 * v104);
            *(_DWORD *)(a3 + 4 * (int)v98) = v112;
            *(_DWORD *)(a3 + 4 * v104) = v110;
            *(v108 - 1) = v111;
            LODWORD(v106) = v21 + v16 + 2;
            int v113 = *(_DWORD *)(a3 + 4 * (int)v106);
            uint64_t v114 = (int)v104 - (uint64_t)(int)v11;
            LODWORD(v98) = v21 + v16 + 3;
            int v115 = *(_DWORD *)(a3 + 4 * (int)v98);
            float v116 = (_DWORD *)(a3 + 4 * v114);
            int v117 = v116[1];
            *(_DWORD *)(a3 + 4 * (int)v106) = *v116;
            *(_DWORD *)(a3 + 4 * (int)v98) = v117;
            *float v116 = v113;
            v116[1] = v115;
            LODWORD(v106) = v20 + v16 + 2;
            int v118 = *(_DWORD *)(a3 + 4 * (int)v106);
            uint64_t v119 = (int)v114 + (uint64_t)(int)v9;
            LODWORD(v98) = v20 + v16 + 3;
            int v120 = *(_DWORD *)(a3 + 4 * (int)v98);
            float v121 = (_DWORD *)(a3 + 4 * v119);
            int v122 = v121[1];
            *(_DWORD *)(a3 + 4 * (int)v106) = *v121;
            *(_DWORD *)(a3 + 4 * (int)v98) = v122;
            *float v121 = v118;
            v121[1] = v120;
            LODWORD(v106) = v236 + v16 + 2;
            int v123 = *(_DWORD *)(a3 + 4 * (int)v106);
            uint64_t v124 = (_DWORD *)(a3 + 4 * ((int)v119 - (uint64_t)(int)v11));
            int v125 = v124[1];
            *(_DWORD *)(a3 + 4 * (int)v106) = *v124;
            LODWORD(v98) = v236 + v16 + 3;
            int v126 = *(_DWORD *)(a3 + 4 * (int)v98);
            *(_DWORD *)(a3 + 4 * (int)v98) = v125;
            uint64_t v13 = v38;
            *uint64_t v124 = v123;
            v124[1] = v126;
            v16 += 4;
            v36 += 16;
            v15 += 0x400000000;
            --v10;
          }
          while (v10);
          uint64_t v12 = v232;
          a2 = v233;
          uint64_t v14 = v234;
          uint64_t v10 = v235;
        }
        else
        {
          LODWORD(v18) = 0;
        }
        uint64_t v127 = 2 * *(int *)(a2 + 4 * v14) + (int)v18;
        uint64_t v128 = v127 + 2;
        uint64_t v129 = (int)v127 + (uint64_t)v8;
        int v130 = *(_DWORD *)(a3 + 4 * (v127 + 2));
        uint64_t v131 = a3 + 4 * v127;
        int v132 = *(_DWORD *)(v131 + 12);
        float v133 = (_DWORD *)(a3 + 4 * v129);
        int v134 = v133[1];
        *(_DWORD *)(a3 + 4 * v128) = *v133;
        *(_DWORD *)(v131 + 12) = v134;
        *float v133 = v130;
        v133[1] = v132;
        uint64_t v135 = (int)v128 + (uint64_t)(int)v9;
        uint64_t v136 = (int)v129 + (uint64_t)(int)v11;
        int v137 = *(_DWORD *)(a3 + 4 * v135);
        uint64_t v138 = (4 * v135) | 4;
        int v139 = *(_DWORD *)(a3 + v138);
        float v140 = (_DWORD *)(a3 + 4 * v136);
        int v141 = v140[1];
        *(_DWORD *)(a3 + 4 * v135) = *v140;
        *(_DWORD *)(a3 + v138) = v141;
        *float v140 = v137;
        v140[1] = v139;
        uint64_t v142 = (int)v135 + (uint64_t)(int)v9;
        uint64_t v143 = (int)v136 - (uint64_t)(int)v9;
        float v144 = (int *)(a3 + 4 * v142);
        int v145 = *v144;
        uint64_t v146 = (4 * v142) | 4;
        int v147 = *(_DWORD *)(a3 + v146);
        float v148 = (int *)(a3 + 4 * v143);
        int v149 = v148[1];
        *float v144 = *v148;
        *(_DWORD *)(a3 + v146) = v149;
        *float v148 = v145;
        v148[1] = v147;
        int v150 = *(v144 - 2);
        int v151 = *(v144 - 1);
        float v152 = (int *)(a3 + 4 * ((int)v143 - (uint64_t)v8));
        int v153 = v152[1];
        *(v144 - 2) = *v152;
        *(v144 - 1) = v153;
        *float v152 = v150;
        v152[1] = v151;
        float v154 = (int *)(a3 + 4 * ((int)v142 + v8));
        int v155 = *v154;
        int v156 = v154[1];
        int v157 = *(_DWORD *)(a3 + 4 * ((int)v143 + 3));
        *float v154 = *(_DWORD *)(a3 + 4 * ((int)v143 + 2));
        v154[1] = v157;
        *(_DWORD *)(a3 + 4 * ((int)v143 + 2)) = v155;
        *(_DWORD *)(a3 + 4 * ((int)v143 + 3)) = v156;
        LODWORD(v142) = v142 + v9;
        float result = *(float *)(a3 + 4 * (int)v142);
        uint64_t v159 = (4 * (int)v142) | 4;
        int v160 = *(_DWORD *)(a3 + v159);
        float v161 = (_DWORD *)(a3 + 4 * ((int)v143 + (int)v11));
        int v162 = v161[1];
        *(_DWORD *)(a3 + 4 * (int)v142) = *v161;
        *(_DWORD *)(a3 + v159) = v162;
        *(float *)float v161 = result;
        v161[1] = v160;
        ++v10;
      }
      while (v10 != v12);
      return result;
    }
  }
  else
  {
    int v4 = 1;
    do
    {
      int v5 = v4;
      v4 *= 2;
      unsigned int v6 = v3 >> 2;
      BOOL v7 = v3 > 0x23;
      v3 >>= 2;
    }
    while (v7);
    int v8 = a1 >> 1;
    uint64_t v9 = (8 * v5);
    if (v6 == 8)
    {
      if (v4 < 1) {
        return result;
      }
      goto LABEL_8;
    }
    if (v4 < 1) {
      return result;
    }
  }
  uint64_t v163 = 0;
  uint64_t v164 = v4;
  uint64_t v165 = (int)v9;
  uint64_t v166 = v8;
  int v167 = v8 + v9 + 2;
  uint64_t v168 = a3 + 4;
  uint64_t v169 = a2 + 4 * v4;
  uint64_t v170 = v165 + v8;
  do
  {
    uint64_t v171 = v163 + v164;
    if (v163)
    {
      uint64_t v172 = 0;
      int v173 = *(_DWORD *)(a2 + 4 * v171);
      uint64_t v174 = 4 * (int)v163;
      uint64_t v175 = v170 + v173;
      uint64_t v176 = (v175 << 32) + 0x300000000;
      int v177 = v165 + v173;
      int v178 = v167 + v173;
      float v179 = (int *)(v168 + 4 * v173);
      float v180 = (int *)(v168 + 4 * (v165 + v173));
      float v181 = (int *)(a3 + 8 + 4 * (v166 + v173));
      uint64_t v182 = v163;
      float v183 = (int *)(v168 + 4 * v175);
      do
      {
        uint64_t v184 = *(int *)(v169 + v172) + v174;
        int v185 = *(v179 - 1);
        int v186 = *v179;
        float v187 = (int *)(a3 + 4 * v184);
        int v188 = v187[1];
        *(v179 - 1) = *v187;
        *float v179 = v188;
        *float v187 = v185;
        v187[1] = v186;
        uint64_t v189 = v165 + (int)v184;
        int v190 = *(v180 - 1);
        int v191 = *v180;
        float v192 = (int *)(a3 + 4 * v189);
        int v193 = v192[1];
        *(v180 - 1) = *v192;
        *float v180 = v193;
        *float v192 = v190;
        v192[1] = v191;
        int v194 = *(v183 - 1);
        int v195 = *v183;
        int v196 = v192[3];
        *(v183 - 1) = *(_DWORD *)(a3 + 4 * (v189 + 2));
        *float v183 = v196;
        *(_DWORD *)(a3 + 4 * (v189 + 2)) = v194;
        v192[3] = v195;
        uint64_t v197 = (int)v189 + 2 - v165;
        int v198 = *(v181 - 2);
        int v199 = *(v181 - 1);
        float v200 = (int *)(a3 + 4 * v197);
        int v201 = v200[1];
        *(v181 - 2) = *v200;
        *(v181 - 1) = v201;
        *float v200 = v198;
        v200[1] = v199;
        int v202 = (int *)(a3 + 4 * ((int)v197 + (int)v166));
        int v203 = *v181;
        int v204 = v181[1];
        int v205 = v202[1];
        *float v181 = *v202;
        v181[1] = v205;
        v181 += 4;
        *int v202 = v203;
        v202[1] = v204;
        int v206 = *(_DWORD *)(a3 + 4 * (v178 + (int)v172));
        int v207 = *(_DWORD *)(a3 + (v176 >> 30));
        uint64_t v208 = (_DWORD *)(a3 + 4 * ((int)v189 + 2 + (int)v166));
        int v209 = v208[1];
        *(_DWORD *)(a3 + 4 * (v178 + (int)v172)) = *v208;
        *(_DWORD *)(a3 + (v176 >> 30)) = v209;
        *uint64_t v208 = v206;
        v208[1] = v207;
        LODWORD(v208) = v177 + v172 + 2;
        int v210 = *(_DWORD *)(a3 + 4 * (int)v208);
        LODWORD(v202) = v177 + v172 + 3;
        int v211 = *(_DWORD *)(a3 + 4 * (int)v202);
        LODWORD(v189) = v189 + v166;
        __int16 v212 = (_DWORD *)(a3 + 4 * (int)v189);
        int v213 = v212[1];
        *(_DWORD *)(a3 + 4 * (int)v208) = *v212;
        *(_DWORD *)(a3 + 4 * (int)v202) = v213;
        *__int16 v212 = v210;
        v212[1] = v211;
        LODWORD(v208) = v173 + v172 + 2;
        int v214 = *(_DWORD *)(a3 + 4 * (int)v208);
        LODWORD(v202) = v173 + v172 + 3;
        int v215 = *(_DWORD *)(a3 + 4 * (int)v202);
        char v216 = (_DWORD *)(a3 + 4 * ((int)v189 - v165));
        int v217 = v216[1];
        *(_DWORD *)(a3 + 4 * (int)v208) = *v216;
        v172 += 4;
        v176 += 0x400000000;
        v179 += 4;
        *(_DWORD *)(a3 + 4 * (int)v202) = v217;
        *char v216 = v214;
        v216[1] = v215;
        v180 += 4;
        v183 += 4;
        --v182;
      }
      while (v182);
    }
    else
    {
      LODWORD(v174) = 0;
    }
    uint64_t v218 = *(int *)(a2 + 4 * v171) + (uint64_t)(int)v174;
    uint64_t v219 = v218 + 2;
    int v220 = v218 + v166;
    int v221 = *(_DWORD *)(a3 + 4 * (v218 + 2));
    uint64_t v222 = a3 + 4 * v218;
    uint64_t v223 = (_DWORD *)(a3 + 4 * ((int)v218 + (int)v166));
    int v224 = v223[1];
    *(_DWORD *)(a3 + 4 * v219) = *v223;
    int v225 = *(_DWORD *)(v222 + 12);
    *(_DWORD *)(v222 + 12) = v224;
    *uint64_t v223 = v221;
    v223[1] = v225;
    uint64_t v226 = v165 + (int)v219;
    LODWORD(v219) = v220 + v165;
    uint64_t v227 = a3 + 4 * v226;
    float result = *(float *)v227;
    int v228 = *(_DWORD *)(v227 + 4);
    int v229 = (_DWORD *)(a3 + 4 * (int)v219);
    int v230 = v229[1];
    *(_DWORD *)uint64_t v227 = *v229;
    *(_DWORD *)(v227 + 4) = v230;
    *(float *)int v229 = result;
    v229[1] = v228;
    ++v163;
  }
  while (v163 != v164);
  return result;
}

float cftf161(float *a1, float *a2)
{
  float v2 = a1[1];
  float v3 = a1[16];
  float v4 = a1[17];
  float v5 = *a1 + v3;
  float v6 = v2 + v4;
  float v7 = *a1 - v3;
  float v8 = v2 - v4;
  float v9 = a1[8];
  float v10 = a1[9];
  float v11 = a1[24];
  float v12 = a1[25];
  float v13 = v10 - v12;
  float v122 = v5 + (float)(v9 + v11);
  float v123 = v6 + (float)(v10 + v12);
  float v118 = v6 - (float)(v10 + v12);
  float v119 = v5 - (float)(v9 + v11);
  float v117 = v7 - (float)(v10 - v12);
  float v14 = v8 + (float)(v9 - v11);
  float v15 = v7 + v13;
  float v16 = v8 - (float)(v9 - v11);
  float v17 = a1[2];
  float v18 = a1[3];
  float v19 = a1[18];
  float v20 = a1[19];
  float v21 = v17 + v19;
  float v22 = v18 + v20;
  float v23 = v17 - v19;
  float v24 = v18 - v20;
  float v25 = a1[10];
  float v26 = a1[11];
  float v27 = a1[26];
  float v28 = a1[27];
  float v29 = v25 - v27;
  float v30 = v26 - v28;
  float v120 = v22 + (float)(v26 + v28);
  float v121 = v21 + (float)(v25 + v27);
  float v31 = v21 - (float)(v25 + v27);
  float v32 = a2[2];
  float v33 = a2[3];
  float v34 = v22 - (float)(v26 + v28);
  float v35 = (float)(v32 * (float)(v23 - v30)) - (float)(v33 * (float)(v24 + v29));
  float v36 = (float)(v33 * (float)(v23 - v30)) + (float)(v32 * (float)(v24 + v29));
  float v37 = v23 + v30;
  float v38 = v24 - v29;
  float v39 = (float)(v33 * (float)(v23 + v30)) - (float)(v32 * v38);
  float v40 = (float)(v32 * v37) + (float)(v33 * v38);
  float v41 = a1[6];
  float v42 = a1[7];
  float v43 = a1[22];
  float v44 = a1[23];
  float v45 = a1[14];
  float v46 = a1[15];
  float v47 = a1[30];
  float v48 = a1[31];
  float v49 = (float)(v41 - v43) - (float)(v46 - v48);
  float v50 = (float)(v42 - v44) + (float)(v45 - v47);
  float v51 = (float)(v33 * v49) - (float)(v32 * v50);
  float v52 = (float)(v32 * v49) + (float)(v33 * v50);
  float v53 = (float)(v41 - v43) + (float)(v46 - v48);
  float v54 = (float)(v42 - v44) - (float)(v45 - v47);
  float v55 = (float)(v32 * v53) - (float)(v33 * v54);
  float v56 = v33 * v53;
  float v58 = a1[4];
  float v57 = a1[5];
  float v59 = v56 + (float)(v32 * v54);
  float v60 = a1[20];
  float v61 = a1[21];
  float v62 = v58 + v60;
  float v63 = v58 - v60;
  float v64 = v57 + v61;
  float v65 = v57 - v61;
  float v67 = a1[12];
  float v66 = a1[13];
  float v68 = a1[28];
  float v69 = a1[29];
  float v70 = v67 + v68;
  float v71 = v67 - v68;
  float v72 = v66 + v69;
  float v73 = v66 - v69;
  float v74 = v62 + v70;
  float v75 = v62 - v70;
  float v76 = v64 + v72;
  float v77 = v64 - v72;
  float v78 = (float)(v63 - v73) - (float)(v65 + v71);
  float v79 = (float)(v65 + v71) + (float)(v63 - v73);
  float v80 = v63 + v73;
  float v81 = v65 - v71;
  float v82 = v81 + v80;
  float v83 = v81 - v80;
  float v84 = v41 + v43;
  float v85 = v42 + v44;
  float v86 = v84 + (float)(v45 + v47);
  float v87 = v84 - (float)(v45 + v47);
  float v88 = (float)(v42 + v44) + (float)(v46 + v48);
  float v89 = v85 - (float)(v46 + v48);
  float v90 = a2[1];
  float v91 = v90 * v82;
  float v92 = v15 - v91;
  float v93 = v15 + v91;
  float v94 = v90 * v83;
  float v95 = v16 - v94;
  float v96 = v16 + v94;
  float v97 = v39 - v55;
  float v98 = v39 + v55;
  float v99 = v40 - v59;
  float v100 = v40 + v59;
  a1[24] = v92 + v97;
  a1[25] = v95 + v99;
  a1[26] = v92 - v97;
  a1[27] = v95 - v99;
  a1[28] = v93 - v100;
  a1[29] = v96 + v98;
  float v101 = v90 * v78;
  float v102 = v90 * v79;
  a1[30] = v93 + v100;
  a1[31] = v96 - v98;
  float v103 = v117 + v101;
  float v104 = v14 + v102;
  float v105 = v117 - v101;
  float v106 = v14 - v102;
  float v107 = v35 + v51;
  float v108 = v35 - v51;
  a1[16] = v103 + v107;
  a1[17] = v104 + (float)(v36 + v52);
  a1[18] = v103 - v107;
  a1[19] = v104 - (float)(v36 + v52);
  a1[20] = v105 - (float)(v36 - v52);
  a1[21] = v106 + v108;
  a1[22] = v105 + (float)(v36 - v52);
  a1[23] = v106 - v108;
  float v109 = v90 * (float)((float)(v31 - v89) - (float)(v34 + v87));
  float v110 = v90 * (float)((float)(v34 + v87) + (float)(v31 - v89));
  float v111 = v34 - v87;
  float v112 = v90 * (float)((float)(v31 + v89) - v111);
  float v113 = v90 * (float)(v111 + (float)(v31 + v89));
  float v114 = v118 + v75;
  float v115 = v118 - v75;
  a1[8] = (float)(v119 - v77) + v109;
  a1[9] = v114 + v110;
  a1[10] = (float)(v119 - v77) - v109;
  a1[11] = v114 - v110;
  a1[12] = (float)(v119 + v77) - v113;
  a1[13] = v115 + v112;
  a1[14] = (float)(v119 + v77) + v113;
  a1[15] = v115 - v112;
  *a1 = (float)(v122 + v74) + (float)(v121 + v86);
  a1[1] = (float)(v123 + v76) + (float)(v120 + v88);
  a1[2] = (float)(v122 + v74) - (float)(v121 + v86);
  a1[3] = (float)(v123 + v76) - (float)(v120 + v88);
  a1[4] = (float)(v122 - v74) - (float)(v120 - v88);
  a1[5] = (float)(v123 - v76) + (float)(v121 - v86);
  float result = (float)(v123 - v76) - (float)(v121 - v86);
  a1[6] = (float)(v122 - v74) + (float)(v120 - v88);
  a1[7] = result;
  return result;
}

double bitrv216(uint64_t a1)
{
  double result = *(double *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)&long long v3 = *(void *)(a1 + 24);
  *(void *)&long long v4 = *(void *)(a1 + 40);
  *(void *)&long long v5 = *(void *)(a1 + 96);
  uint64_t v6 = *(void *)(a1 + 104);
  uint64_t v8 = *(void *)(a1 + 56);
  *(void *)&long long v7 = *(void *)(a1 + 64);
  *((void *)&v7 + 1) = *(void *)(a1 + 32);
  *(void *)&long long v9 = *(void *)(a1 + 112);
  *(_OWORD *)(a1 + 8) = v7;
  *((void *)&v5 + 1) = v2;
  *(_OWORD *)(a1 + 24) = v5;
  uint64_t v10 = *(void *)(a1 + 88);
  *(void *)(a1 + 40) = *(void *)(a1 + 80);
  *((double *)&v9 + 1) = result;
  *((void *)&v4 + 1) = v6;
  *((void *)&v3 + 1) = v10;
  *(_OWORD *)(a1 + 80) = v4;
  *(_OWORD *)(a1 + 96) = v3;
  *(_OWORD *)(a1 + 56) = v9;
  *(void *)(a1 + 112) = v8;
  return result;
}

float cftf081(float *a1, uint64_t a2)
{
  float v2 = *(float *)(a2 + 4);
  float v3 = a1[1];
  float v4 = a1[8];
  float v5 = a1[9];
  float v6 = *a1 + v4;
  float v7 = v3 + v5;
  float v8 = *a1 - v4;
  float v9 = v3 - v5;
  float v10 = a1[4];
  float v11 = a1[5];
  float v12 = a1[12];
  float v13 = a1[13];
  float v14 = v10 + v12;
  float v15 = v11 + v13;
  float v16 = v10 - v12;
  float v17 = v11 - v13;
  float v18 = v6 + v14;
  float v19 = v7 + v15;
  float v20 = v6 - v14;
  float v21 = v7 - v15;
  float v22 = v8 - v17;
  float v23 = v9 + v16;
  float v24 = v8 + v17;
  float v25 = v9 - v16;
  float v26 = a1[2];
  float v27 = a1[3];
  float v28 = a1[10];
  float v29 = a1[11];
  float v30 = v26 + v28;
  float v31 = v27 + v29;
  float v32 = v26 - v28;
  float v33 = v27 - v29;
  float v34 = a1[6];
  float v35 = a1[7];
  float v36 = a1[14];
  float v37 = a1[15];
  float v38 = v34 + v36;
  float v39 = v35 + v37;
  float v40 = v34 - v36;
  float v41 = v35 - v37;
  float v42 = v30 + v38;
  float v43 = v30 - v38;
  float v44 = v32 - v41;
  float v45 = v32 + v41;
  float v46 = v33 + v40;
  float v47 = v33 - v40;
  float v48 = v2 * (float)(v44 - v46);
  float v49 = v2 * (float)(v46 + v44);
  float v50 = v2 * (float)(v45 - v47);
  float v51 = v2 * (float)(v47 + v45);
  a1[8] = v22 + v48;
  a1[9] = v23 + v49;
  a1[10] = v22 - v48;
  a1[11] = v23 - v49;
  a1[12] = v24 - v51;
  a1[13] = v25 + v50;
  a1[14] = v24 + v51;
  a1[15] = v25 - v50;
  *a1 = v18 + v42;
  a1[1] = v19 + (float)(v31 + v39);
  a1[2] = v18 - v42;
  a1[3] = v19 - (float)(v31 + v39);
  a1[4] = v20 - (float)(v31 - v39);
  a1[5] = v21 + v43;
  float result = v21 - v43;
  a1[6] = v20 + (float)(v31 - v39);
  a1[7] = result;
  return result;
}

double bitrv208(uint64_t a1)
{
  double result = *(double *)(a1 + 8);
  *(void *)&long long v2 = *(void *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a1 + 8) = *(void *)(a1 + 32);
  *((double *)&v2 + 1) = result;
  *(_OWORD *)(a1 + 24) = v2;
  *(void *)(a1 + 48) = v3;
  return result;
}

float cftf040(float *a1)
{
  float v1 = a1[1];
  float v2 = a1[4];
  float v3 = a1[5];
  float v4 = *a1 + v2;
  float v5 = v1 + v3;
  float v6 = *a1 - v2;
  float v7 = v1 - v3;
  float v8 = a1[2];
  float v9 = a1[3];
  float v10 = a1[6];
  float v11 = a1[7];
  float v12 = v8 + v10;
  float v13 = v9 + v11;
  float v14 = v8 - v10;
  float v15 = v9 - v11;
  *a1 = v4 + v12;
  a1[1] = v5 + v13;
  a1[2] = v6 - v15;
  a1[3] = v7 + v14;
  a1[4] = v4 - v12;
  a1[5] = v5 - v13;
  float result = v6 + v15;
  a1[6] = result;
  a1[7] = v7 - v14;
  return result;
}

float32x4_t cftx020(uint64_t *a1)
{
  v1.i64[0] = *a1;
  v2.i64[0] = a1[1];
  v1.i64[1] = *a1;
  v2.i64[1] = v2.i64[0];
  *(void *)&long long v3 = vaddq_f32(v1, v2).u64[0];
  float32x4_t result = vsubq_f32(v1, v2);
  *((void *)&v3 + 1) = result.i64[1];
  *(_OWORD *)a1 = v3;
  return result;
}

float cftb1st(int a1, float *a2, float *a3)
{
  uint64_t v3 = 2 * (a1 >> 3);
  int v4 = 4 * (a1 >> 3);
  float v5 = a2[v4];
  float v6 = a2[1];
  float v7 = *a2 + v5;
  float v8 = &a2[4 * (a1 >> 3)];
  float v9 = v8[1];
  float v10 = (float)-v6 - v9;
  float v11 = *a2 - v5;
  uint64_t v12 = 2 * (a1 >> 3);
  float v13 = a2[v12];
  float v14 = v9 - v6;
  float v15 = a2[6 * (a1 >> 3)];
  float v16 = v13 + v15;
  float v17 = a2[(int)(v3 | 1)];
  int v18 = (6 * (a1 >> 3)) | 1;
  float v19 = a2[v18];
  float v20 = v13 - v15;
  *a2 = v7 + v16;
  a2[1] = v10 - (float)(v17 + v19);
  a2[v12] = v7 - v16;
  a2[(int)(v3 | 1)] = v10 + (float)(v17 + v19);
  a2[v4] = v11 + (float)(v17 - v19);
  v8[1] = v14 + v20;
  a2[6 * (a1 >> 3)] = v11 - (float)(v17 - v19);
  a2[v18] = v14 - v20;
  uint64_t v21 = (uint64_t)a1 >> 3;
  float v22 = a3[1];
  float v23 = a3[2];
  float v24 = a3[3];
  uint64_t v25 = v21 - 2;
  if (a1 < 40)
  {
    float v48 = 0.0;
    float v47 = 1.0;
    float v49 = 1.0;
    float v50 = 0.0;
  }
  else
  {
    uint64_t v26 = 0;
    uint64_t v27 = 24 * v21;
    uint64_t v28 = v27 + 12;
    uint64_t v29 = 4 * v4;
    uint64_t v30 = v29 + 12;
    uint64_t v31 = v29 - 4;
    uint64_t v32 = v27 - 4;
    float v33 = a3 + 7;
    uint64_t v34 = 24 * (a1 >> 3) + 16;
    uint64_t v35 = 2 * (a1 >> 3);
    uint64_t v36 = v35 * 4 - 8;
    uint64_t v37 = 8 * v3 + 16;
    uint64_t v38 = 8 * v3 - 8;
    uint64_t v39 = 12 * v3 - 8;
    float v40 = 1.0;
    float v41 = 0.0;
    float v42 = 0.0;
    uint64_t v43 = 16 * v3 - 16;
    uint64_t v44 = 2;
    uint64_t v45 = (v3 << 34) - 0x200000000;
    float v46 = 1.0;
    do
    {
      float v47 = v33[v26 - 3];
      float v48 = v33[v26 - 2];
      float v49 = v33[v26 - 1];
      float v50 = v33[v26];
      float v51 = v40 + v49;
      float v52 = &a2[v26];
      float v53 = (float *)((char *)a2 + v37);
      float v54 = *(float *)((char *)a2 + v37 - 8);
      float v55 = v41 + v50;
      float v56 = a2[v26 + 2];
      float v57 = a2[v26 + 3];
      float v58 = v56 + v54;
      float v59 = *(float *)((char *)a2 + v30);
      float v60 = -v57;
      float v61 = v56 - v54;
      float v62 = v59 - v57;
      float v63 = a2[v26 + 4];
      float v64 = a2[v26 + 5];
      float v65 = v60 - v59;
      float v67 = *(float *)((char *)a2 + v37);
      float v66 = *(float *)((char *)a2 + v37 + 4);
      float v68 = v63 + v67;
      float v69 = (float)-v64 - v66;
      float v70 = v63 - v67;
      float v71 = v23 * (float)(v46 + v47);
      float v72 = v66 - v64;
      float v73 = &a2[v35];
      float v74 = (float *)((char *)a2 + v34);
      float v75 = *(float *)((char *)a2 + v34 - 8);
      float v76 = v23 * (float)(v42 + v48);
      float v78 = a2[v35 + 2];
      float v77 = a2[v35 + 3];
      float v79 = v78 + v75;
      float v80 = *(float *)((char *)a2 + v28);
      float v81 = v77 + v80;
      float v82 = v24 * v51;
      float v83 = v78 - v75;
      float v84 = v77 - v80;
      float v86 = a2[v35 + 4];
      float v85 = a2[v35 + 5];
      float v87 = v24 * v55;
      float v88 = *(float *)((char *)a2 + v34);
      float v89 = *(float *)((char *)a2 + v34 + 4);
      float v90 = v86 + v88;
      float v91 = v85 + v89;
      float v92 = v86 - v88;
      float v93 = v85 - v89;
      v52[4] = v68 + v90;
      v52[5] = v69 - v91;
      v52[2] = v58 + v79;
      v52[3] = v65 - v81;
      v73[2] = v58 - v79;
      _DWORD v73[3] = v65 + v81;
      v73[4] = v68 - v90;
      v73[5] = v69 + v91;
      *(v53 - 2) = (float)(v71 * (float)(v61 + v84)) - (float)(v76 * (float)(v62 + v83));
      *(float *)((char *)a2 + v30) = (float)(v76 * (float)(v61 + v84)) + (float)(v71 * (float)(v62 + v83));
      float v94 = v62 - v83;
      *float v53 = (float)(v47 * (float)(v70 + v93)) - (float)(v48 * (float)(v72 + v92));
      v53[1] = (float)(v48 * (float)(v70 + v93)) + (float)(v47 * (float)(v72 + v92));
      *(v74 - 2) = (float)(v87 * v94) + (float)(v82 * (float)(v61 - v84));
      float v95 = v70 - v93;
      *(float *)((char *)a2 + v28) = (float)(v82 * v94) - (float)(v87 * (float)(v61 - v84));
      float *v74 = (float)(v50 * (float)(v72 - v92)) + (float)(v49 * v95);
      v74[1] = (float)(v49 * (float)(v72 - v92)) - (float)(v50 * v95);
      float v96 = (float *)((char *)a2 + v36);
      float v97 = (float *)((char *)a2 + v39);
      float v99 = *(float *)((char *)a2 + v39 - 4);
      float v98 = *(float *)((char *)a2 + v39);
      float v100 = *(float *)((char *)a2 + v36);
      float v101 = *(float *)((char *)a2 + v36 + 4);
      float v102 = v100 + v98;
      float v103 = -v101;
      float v104 = *(float *)((char *)a2 + v32);
      float v105 = v100 - v98;
      float v107 = *(float *)((char *)a2 + v36 - 8);
      float v106 = *(float *)((char *)a2 + v36 - 4);
      float v108 = *(float *)((char *)a2 + v39 - 8);
      float v109 = v107 + v108;
      float v110 = -v106;
      float v111 = v107 - v108;
      float v112 = (float *)((char *)a2 + v38);
      float v113 = *(float *)((char *)a2 + v38);
      float v114 = (float *)((char *)a2 + v43);
      float v115 = *(float *)((char *)a2 + v31);
      float v116 = v99 - v106;
      float v117 = *(float *)((char *)a2 + v43 + 4);
      float v118 = *(float *)((char *)a2 + v43 + 8);
      uint64_t v119 = (v45 >> 30) | 4;
      float v120 = *(float *)((char *)a2 + v119);
      float v121 = v104 - v101;
      float v122 = v113 + v118;
      float v123 = v115 + v120;
      float v124 = v113 - v118;
      float v125 = v115 - v120;
      float v126 = v103 - v104;
      float v128 = *(float *)((char *)a2 + v38 - 8);
      float v127 = *(float *)((char *)a2 + v38 - 4);
      float v129 = *(float *)((char *)a2 + v43);
      float v130 = v127 + v117;
      float v131 = v110 - v99;
      float v132 = v127 - v117;
      float *v96 = v102 + v122;
      v96[1] = v126 - v123;
      *(v96 - 2) = v109 + (float)(v128 + v129);
      *(v96 - 1) = v131 - v130;
      *float v112 = v102 - v122;
      *(float *)((char *)a2 + v31) = v126 + v123;
      *(v112 - 2) = v109 - (float)(v128 + v129);
      *(v112 - 1) = v131 + v130;
      float v133 = (float)(v76 * (float)(v105 + v125)) - (float)(v71 * (float)(v121 + v124));
      float v134 = (float)(v71 * (float)(v105 + v125)) + (float)(v76 * (float)(v121 + v124));
      float v135 = v105 - v125;
      float v136 = v121 - v124;
      *float v97 = v133;
      *(float *)((char *)a2 + v32) = v134;
      v44 += 4;
      *(v97 - 2) = (float)(v48 * (float)(v111 + v132)) - (float)(v47 * (float)(v116 + (float)(v128 - v129)));
      *(v97 - 1) = (float)(v47 * (float)(v111 + v132)) + (float)(v48 * (float)(v116 + (float)(v128 - v129)));
      v28 += 16;
      v30 += 16;
      v31 -= 16;
      v26 += 4;
      v34 += 16;
      v114[2] = (float)(v82 * v136) + (float)(v87 * v135);
      v36 -= 16;
      v37 += 16;
      v35 += 4;
      v38 -= 16;
      *(float *)((char *)a2 + v119) = (float)(v87 * v136) - (float)(v82 * v135);
      v39 -= 16;
      v45 -= 0x400000000;
      v43 -= 16;
      float v41 = v50;
      v32 -= 16;
      float *v114 = (float)(v49 * (float)(v116 - (float)(v128 - v129))) + (float)(v50 * (float)(v111 - v132));
      v114[1] = (float)(v50 * (float)(v116 - (float)(v128 - v129))) - (float)(v49 * (float)(v111 - v132));
      float v40 = v49;
      float v42 = v48;
      float v46 = v47;
    }
    while (v44 < v25);
  }
  float v137 = v23 * (float)(v22 + v47);
  float v138 = v23 * (float)(v22 + v48);
  float v139 = v24 * (float)(v49 - v22);
  float v140 = v24 * (float)(v50 - v22);
  float v141 = a2[v25];
  uint64_t v142 = &a2[5 * v21];
  float v143 = *(v142 - 2);
  float v144 = *(v142 - 1);
  float v145 = v141 + v143;
  uint64_t v146 = &a2[v21];
  float v147 = *(v146 - 1);
  float v148 = (float)-v147 - v144;
  float v149 = v141 - v143;
  float v150 = v144 - v147;
  int v151 = &a2[3 * (int)v21];
  float v152 = &a2[7 * v21];
  float v153 = *(v152 - 2);
  float v154 = *(v151 - 2);
  float v155 = *(v151 - 1);
  float v156 = v154 + v153;
  int v157 = &a2[7 * v21];
  float v158 = *(v157 - 1);
  float v159 = v154 - v153;
  a2[v25] = v145 + v156;
  *(v146 - 1) = v148 - (float)(v155 + v158);
  *(v151 - 2) = v145 - v156;
  *(v151 - 1) = v148 + (float)(v155 + v158);
  float v160 = v149 + (float)(v155 - v158);
  *(v142 - 2) = (float)(v137 * v160) - (float)(v138 * (float)(v150 + v159));
  *(v142 - 1) = (float)(v138 * v160) + (float)(v137 * (float)(v150 + v159));
  float v161 = v149 - (float)(v155 - v158);
  float v162 = v150 - v159;
  *(v152 - 2) = (float)(v140 * v162) + (float)(v139 * v161);
  *(v157 - 1) = (float)(v139 * v162) - (float)(v140 * v161);
  float v163 = v146[1];
  float v164 = v142[1];
  float v165 = *v146 + *v142;
  float v166 = (float)-v163 - v164;
  float v167 = *v146 - *v142;
  float v168 = v164 - v163;
  float v169 = v151[1];
  float v170 = v157[1];
  float v171 = *v151 + *v157;
  float v172 = v169 + v170;
  float v173 = *v151 - *v157;
  float v174 = v169 - v170;
  *uint64_t v146 = v165 + v171;
  v146[1] = v166 - v172;
  *int v151 = v165 - v171;
  v151[1] = v166 + v172;
  float *v142 = v22 * (float)((float)(v167 + v174) - (float)(v168 + v173));
  v142[1] = v22 * (float)((float)(v168 + v173) + (float)(v167 + v174));
  float v175 = v167 - v174;
  float v176 = v168 - v173;
  *int v157 = -(float)(v22 * (float)(v176 + v175));
  v157[1] = -(float)(v22 * (float)(v176 - v175));
  float v177 = v146[2];
  float v178 = v146[3];
  float v179 = v142[2];
  float v180 = v142[3];
  float v181 = v177 + v179;
  float v182 = (float)-v178 - v180;
  float v183 = v177 - v179;
  float v184 = v180 - v178;
  float v185 = v151[2];
  float v186 = v151[3];
  float v187 = v157[2];
  float v188 = v157[3];
  float v189 = v185 + v187;
  float v190 = v186 + v188;
  float v191 = v185 - v187;
  float v192 = v186 - v188;
  v146[2] = v181 + v189;
  v146[3] = v182 - v190;
  v151[2] = v181 - v189;
  v151[3] = v182 + v190;
  v142[2] = (float)(v138 * (float)(v183 + v192)) - (float)(v137 * (float)(v184 + v191));
  v142[3] = (float)(v137 * (float)(v183 + v192)) + (float)(v138 * (float)(v184 + v191));
  float v193 = v183 - v192;
  float v194 = (float)(v139 * (float)(v184 - v191)) + (float)(v140 * v193);
  float result = (float)(v140 * (float)(v184 - v191)) - (float)(v139 * v193);
  v157[2] = v194;
  v157[3] = result;
  return result;
}

float bitrv2conj(int a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = a1 >> 2;
  if (a1 < 36)
  {
    int v8 = a1 >> 1;
    uint64_t v9 = 4;
    int v4 = 1;
    if (v3 == 8)
    {
LABEL_8:
      uint64_t v10 = 0;
      uint64_t v11 = 8 * v4;
      uint64_t v12 = v4;
      uint64_t v13 = a2 + 4 * v4;
      uint64_t v235 = 2 * (int)v9 + v8;
      uint64_t v236 = v4;
      uint64_t v237 = a2;
      do
      {
        uint64_t v14 = v10 + v12;
        if (v10)
        {
          uint64_t v15 = 0;
          uint64_t v16 = 0;
          uint64_t v238 = v10 + v12;
          uint64_t v17 = *(int *)(a2 + 4 * v14);
          uint64_t v18 = 4 * (int)v10;
          uint64_t v243 = (v9 << 33) + (v17 << 33);
          uint64_t v244 = 8 * v17;
          unint64_t v242 = ((unint64_t)(3 * v9) << 32) + (v17 << 33);
          uint64_t v19 = v235 + (int)v9 + 2 * v17;
          uint64_t v241 = (v19 << 32) + 0x300000000;
          int v240 = 2 * v17;
          int v20 = v9 + 2 * v17;
          int v21 = 2 * (v9 + v17);
          int v22 = 3 * v9 + 2 * v17;
          int v23 = v8 + 3 * v9 + 2 + 2 * v17;
          uint64_t v24 = v235 + 2 * v17;
          uint64_t v25 = (v24 << 32) + 0x300000000;
          uint64_t v26 = (v24 << 32) + 0x200000000;
          uint64_t v27 = (int)v9 + (uint64_t)v8 + 2 * v17;
          uint64_t v28 = (v27 << 32) + 0x300000000;
          uint64_t v29 = (v27 << 32) + 0x200000000;
          uint64_t v30 = 4 * (int)v9 + 8 * v17;
          uint64_t v31 = a3 + 8 * (int)v9 + 8 * v17;
          uint64_t v32 = a3 + 12 * (int)v9 + 8 * v17;
          uint64_t v33 = 4 * v19;
          uint64_t v34 = 4 * v27;
          uint64_t v35 = 4 * v24;
          uint64_t v36 = a3;
          uint64_t v239 = v10;
          uint64_t v37 = 4 * v8 + 8 * v17;
          do
          {
            uint64_t v38 = v13;
            uint64_t v39 = v18 + 2 * *(int *)(v13 + v16);
            uint64_t v40 = v36 + v244;
            int v41 = *(_DWORD *)(v36 + v244);
            float v42 = -*(float *)(v36 + v244 + 4);
            uint64_t v43 = (4 * v39) | 4;
            float v44 = -*(float *)(a3 + v43);
            *(_DWORD *)uint64_t v40 = *(_DWORD *)(a3 + 4 * v39);
            *(float *)(v40 + 4) = v44;
            *(_DWORD *)(a3 + 4 * v39) = v41;
            *(float *)(a3 + v43) = v42;
            uint64_t v45 = (int)v39 + (uint64_t)(int)v11;
            uint64_t v46 = v36 + v30;
            int v47 = *(_DWORD *)(v36 + v30);
            uint64_t v48 = (4 * v45) | 4;
            float v49 = -*(float *)(v36 + v30 + 4);
            float v50 = -*(float *)(a3 + v48);
            *(_DWORD *)uint64_t v46 = *(_DWORD *)(a3 + 4 * v45);
            *(float *)(v46 + 4) = v50;
            *(_DWORD *)(a3 + 4 * v45) = v47;
            *(float *)(a3 + v48) = v49;
            uint64_t v51 = (int)v45 - (uint64_t)(int)v9;
            int v52 = *(_DWORD *)(v31 + 4 * v16);
            uint64_t v53 = ((v243 + v15) >> 30) | 4;
            float v54 = *(float *)(a3 + v53);
            uint64_t v55 = (4 * v51) | 4;
            float v56 = -*(float *)(a3 + v55);
            *(_DWORD *)(v31 + 4 * v16) = *(_DWORD *)(a3 + 4 * v51);
            *(float *)(a3 + v53) = v56;
            *(_DWORD *)(a3 + 4 * v51) = v52;
            *(float *)(a3 + v55) = -v54;
            uint64_t v57 = v11 + (int)v51;
            int v58 = *(_DWORD *)(v32 + 4 * v16);
            uint64_t v59 = ((uint64_t)(v242 + v15) >> 30) | 4;
            uint64_t v60 = a3 + 4 * v57;
            uint64_t v61 = (4 * v57) | 4;
            float v62 = -*(float *)(a3 + v59);
            float v63 = -*(float *)(a3 + v61);
            *(_DWORD *)(v32 + 4 * v16) = *(_DWORD *)v60;
            *(float *)(a3 + v59) = v63;
            *(_DWORD *)uint64_t v60 = v58;
            *(float *)(a3 + v61) = v62;
            v57 += 2;
            uint64_t v64 = v36 + v33;
            int v65 = *(_DWORD *)(v36 + v33);
            float v66 = -*(float *)(v36 + v33 + 4);
            float v67 = -*(float *)(v60 + 12);
            *(_DWORD *)uint64_t v64 = *(_DWORD *)(a3 + 4 * v57);
            *(float *)(v64 + 4) = v67;
            *(_DWORD *)(a3 + 4 * v57) = v65;
            uint64_t v68 = (int)v57 - (uint64_t)(int)v11;
            *(float *)(v60 + 12) = v66;
            uint64_t v69 = v36 + v35;
            int v70 = *(_DWORD *)(v36 + v35);
            uint64_t v71 = a3 + 4 * v68;
            float v72 = -*(float *)(v36 + v35 + 4);
            float v73 = -*(float *)(v71 + 4);
            *(_DWORD *)uint64_t v69 = *(_DWORD *)v71;
            *(float *)(v69 + 4) = v73;
            *(_DWORD *)uint64_t v71 = v70;
            *(float *)(v71 + 4) = v72;
            uint64_t v74 = (int)v68 + (uint64_t)(int)v9;
            uint64_t v75 = v36 + v34;
            int v76 = *(_DWORD *)(v36 + v34);
            float v77 = -*(float *)(v36 + v34 + 4);
            uint64_t v78 = a3 + 4 * v74;
            float v79 = -*(float *)(v78 + 4);
            *(_DWORD *)uint64_t v75 = *(_DWORD *)v78;
            *(float *)(v75 + 4) = v79;
            *(_DWORD *)uint64_t v78 = v76;
            *(float *)(v78 + 4) = v77;
            uint64_t v80 = (int)v74 - (uint64_t)(int)v11;
            uint64_t v81 = v36 + v37;
            int v82 = *(_DWORD *)(v36 + v37);
            float v83 = -*(float *)(v36 + v37 + 4);
            uint64_t v84 = a3 + 4 * v80;
            float v85 = -*(float *)(v84 + 4);
            *(_DWORD *)uint64_t v81 = *(_DWORD *)v84;
            *(float *)(v81 + 4) = v85;
            *(_DWORD *)uint64_t v84 = v82;
            *(float *)(v84 + 4) = v83;
            int v86 = *(_DWORD *)(v36 + v37 + 8);
            uint64_t v87 = a3 + 4 * ((int)v80 + (uint64_t)v8);
            float v88 = -*(float *)(v36 + v37 + 12);
            float v89 = -*(float *)(v87 + 4);
            *(_DWORD *)(v81 + 8) = *(_DWORD *)v87;
            *(float *)(v81 + 12) = v89;
            *(_DWORD *)uint64_t v87 = v86;
            *(float *)(v87 + 4) = v88;
            uint64_t v90 = (v29 + v15) >> 30;
            uint64_t v91 = (v28 + v15) >> 30;
            int v92 = *(_DWORD *)(a3 + v90);
            uint64_t v93 = (int)v74 + v8;
            uint64_t v94 = a3 + 4 * v93;
            float v95 = -*(float *)(a3 + v91);
            float v96 = -*(float *)(v94 + 4);
            *(_DWORD *)(a3 + v90) = *(_DWORD *)v94;
            *(float *)(a3 + v91) = v96;
            uint64_t v97 = v93 - (int)v9;
            uint64_t v98 = (v26 + v15) >> 30;
            *(_DWORD *)uint64_t v94 = v92;
            *(float *)(v94 + 4) = v95;
            uint64_t v99 = (v25 + v15) >> 30;
            float v100 = *(float *)(a3 + v99);
            uint64_t v101 = a3 + 4 * v97;
            int v102 = *(_DWORD *)(a3 + v98);
            float v103 = -*(float *)(v101 + 4);
            *(_DWORD *)(a3 + v98) = *(_DWORD *)v101;
            *(float *)(a3 + v99) = v103;
            *(_DWORD *)uint64_t v101 = v102;
            *(float *)(v101 + 4) = -v100;
            int v104 = *(_DWORD *)(a3 + 4 * (v23 + (int)v16));
            uint64_t v105 = (v241 + v15) >> 30;
            uint64_t v106 = (int)v97 + (uint64_t)(int)v11;
            uint64_t v107 = a3 + 4 * v106;
            float v108 = -*(float *)(v107 + 4);
            float v109 = -*(float *)(a3 + v105);
            *(_DWORD *)(a3 + 4 * (v23 + (int)v16)) = *(_DWORD *)v107;
            *(float *)(a3 + v105) = v108;
            *(_DWORD *)uint64_t v107 = v104;
            *(float *)(v107 + 4) = v109;
            LODWORD(v105) = v22 + v16 + 2;
            v106 -= 2;
            LODWORD(v99) = v22 + v16 + 3;
            int v110 = *(_DWORD *)(a3 + 4 * (int)v105);
            float v111 = *(float *)(a3 + 4 * (int)v99);
            float v112 = -*(float *)(v107 - 4);
            *(_DWORD *)(a3 + 4 * (int)v105) = *(_DWORD *)(a3 + 4 * v106);
            *(float *)(a3 + 4 * (int)v99) = v112;
            *(_DWORD *)(a3 + 4 * v106) = v110;
            LODWORD(v105) = v21 + v16 + 2;
            uint64_t v113 = (int)v106 - (uint64_t)(int)v11;
            *(float *)(v107 - 4) = -v111;
            LODWORD(v99) = v21 + v16 + 3;
            float v114 = *(float *)(a3 + 4 * (int)v99);
            uint64_t v115 = a3 + 4 * v113;
            int v116 = *(_DWORD *)(a3 + 4 * (int)v105);
            float v117 = -*(float *)(v115 + 4);
            *(_DWORD *)(a3 + 4 * (int)v105) = *(_DWORD *)v115;
            *(float *)(a3 + 4 * (int)v99) = v117;
            LODWORD(v105) = v20 + v16 + 2;
            *(_DWORD *)uint64_t v115 = v116;
            *(float *)(v115 + 4) = -v114;
            int v118 = *(_DWORD *)(a3 + 4 * (int)v105);
            LODWORD(v99) = v20 + v16 + 3;
            float v119 = *(float *)(a3 + 4 * (int)v99);
            uint64_t v120 = (int)v113 + (uint64_t)(int)v9;
            uint64_t v121 = a3 + 4 * v120;
            float v122 = *(float *)(v121 + 4);
            *(_DWORD *)(a3 + 4 * (int)v105) = *(_DWORD *)v121;
            *(float *)(a3 + 4 * (int)v99) = -v122;
            *(_DWORD *)uint64_t v121 = v118;
            *(float *)(v121 + 4) = -v119;
            LODWORD(v105) = v240 + v16 + 2;
            int v123 = *(_DWORD *)(a3 + 4 * (int)v105);
            uint64_t v124 = a3 + 4 * ((int)v120 - (uint64_t)(int)v11);
            float v125 = *(float *)(v124 + 4);
            *(_DWORD *)(a3 + 4 * (int)v105) = *(_DWORD *)v124;
            LODWORD(v99) = v240 + v16 + 3;
            float v126 = *(float *)(a3 + 4 * (int)v99);
            *(float *)(a3 + 4 * (int)v99) = -v125;
            *(_DWORD *)uint64_t v124 = v123;
            *(float *)(v124 + 4) = -v126;
            uint64_t v13 = v38;
            v16 += 4;
            v36 += 16;
            v15 += 0x400000000;
            --v10;
          }
          while (v10);
          uint64_t v12 = v236;
          a2 = v237;
          uint64_t v14 = v238;
          uint64_t v10 = v239;
        }
        else
        {
          LODWORD(v18) = 0;
        }
        uint64_t v127 = 2 * *(int *)(a2 + 4 * v14) + (int)v18;
        uint64_t v128 = v127 + 2;
        *(float *)(a3 + ((4 * v127) | 4)) = -*(float *)(a3 + ((4 * v127) | 4));
        int v129 = *(_DWORD *)(a3 + 4 * (v127 + 2));
        uint64_t v130 = (int)v127 + (uint64_t)v8;
        uint64_t v131 = a3 + 4 * v127;
        float v132 = -*(float *)(v131 + 12);
        uint64_t v133 = a3 + 4 * v130;
        float v134 = -*(float *)(v133 + 4);
        *(_DWORD *)(a3 + 4 * v128) = *(_DWORD *)v133;
        *(float *)(v131 + 12) = v134;
        *(_DWORD *)uint64_t v133 = v129;
        *(float *)(v133 + 4) = v132;
        *(float *)(v133 + 12) = -*(float *)(v133 + 12);
        uint64_t v135 = (int)v128 + (uint64_t)(int)v9;
        uint64_t v136 = (int)v130 + (uint64_t)(int)v11;
        int v137 = *(_DWORD *)(a3 + 4 * v135);
        uint64_t v138 = (4 * v135) | 4;
        float v139 = -*(float *)(a3 + v138);
        uint64_t v140 = a3 + 4 * v136;
        float v141 = -*(float *)(v140 + 4);
        *(_DWORD *)(a3 + 4 * v135) = *(_DWORD *)v140;
        *(float *)(a3 + v138) = v141;
        *(_DWORD *)uint64_t v140 = v137;
        *(float *)(v140 + 4) = v139;
        uint64_t v142 = (int)v135 + (uint64_t)(int)v9;
        uint64_t v143 = (int)v136 - (uint64_t)(int)v9;
        float v144 = (float *)(a3 + 4 * v142);
        float v145 = *v144;
        uint64_t v146 = (4 * v142) | 4;
        float v147 = *(float *)(a3 + v146);
        float v148 = (float *)(a3 + 4 * v143);
        float v149 = -v148[1];
        *float v144 = *v148;
        *(float *)(a3 + v146) = v149;
        *float v148 = v145;
        v148[1] = -v147;
        int v150 = *((_DWORD *)v144 - 2);
        float v151 = -*(v144 - 1);
        float v152 = (float *)(a3 + 4 * ((int)v143 - (uint64_t)v8));
        float v153 = -v152[1];
        *(v144 - 2) = *v152;
        *(v144 - 1) = v153;
        *(_DWORD *)float v152 = v150;
        v152[1] = v151;
        float v154 = (float *)(a3 + 4 * ((int)v142 + v8));
        float v155 = *v154;
        float v156 = -v154[1];
        float v157 = -*(float *)(a3 + 4 * ((int)v143 + 3));
        *float v154 = *(float *)(a3 + 4 * ((int)v143 + 2));
        v154[1] = v157;
        *(float *)(a3 + 4 * ((int)v143 + 2)) = v155;
        *(float *)(a3 + 4 * ((int)v143 + 3)) = v156;
        LODWORD(v142) = v142 + v9;
        float v158 = (float *)(a3 + 4 * (int)v142);
        *(v158 - 1) = -*(v158 - 1);
        float v159 = *v158;
        uint64_t v160 = (4 * (int)v142) | 4;
        float v161 = -*(float *)(a3 + v160);
        float v162 = (float *)(a3 + 4 * ((int)v143 + (int)v11));
        float v163 = -v162[1];
        *float v158 = *v162;
        *(float *)(a3 + v160) = v163;
        *float v162 = v159;
        v162[1] = v161;
        float result = -v162[3];
        v162[3] = result;
        ++v10;
      }
      while (v10 != v12);
      return result;
    }
  }
  else
  {
    int v4 = 1;
    do
    {
      int v5 = v4;
      v4 *= 2;
      unsigned int v6 = v3 >> 2;
      BOOL v7 = v3 > 0x23;
      v3 >>= 2;
    }
    while (v7);
    int v8 = a1 >> 1;
    uint64_t v9 = (8 * v5);
    if (v6 == 8)
    {
      if (v4 < 1) {
        return result;
      }
      goto LABEL_8;
    }
    if (v4 < 1) {
      return result;
    }
  }
  uint64_t v165 = 0;
  uint64_t v166 = v4;
  uint64_t v167 = (int)v9;
  uint64_t v168 = v8;
  int v169 = v8 + v9 + 2;
  uint64_t v170 = a3 + 4;
  uint64_t v171 = a2 + 4 * v4;
  uint64_t v172 = v167 + v8;
  do
  {
    uint64_t v173 = v165 + v166;
    if (v165)
    {
      uint64_t v174 = 0;
      int v175 = *(_DWORD *)(a2 + 4 * v173);
      uint64_t v176 = 4 * (int)v165;
      uint64_t v177 = v172 + v175;
      uint64_t v178 = (v177 << 32) + 0x300000000;
      int v179 = v167 + v175;
      int v180 = v169 + v175;
      float v181 = (float *)(v170 + 4 * v175);
      float v182 = (float *)(v170 + 4 * (v167 + v175));
      uint64_t v183 = a3 + 8 + 4 * (v168 + v175);
      uint64_t v184 = v165;
      float v185 = (float *)(v170 + 4 * v177);
      do
      {
        uint64_t v186 = *(int *)(v171 + v174) + v176;
        int v187 = *((_DWORD *)v181 - 1);
        float v188 = -*v181;
        float v189 = (float *)(a3 + 4 * v186);
        float v190 = -v189[1];
        *(v181 - 1) = *v189;
        *float v181 = v190;
        *(_DWORD *)float v189 = v187;
        v189[1] = v188;
        uint64_t v191 = v167 + (int)v186;
        int v192 = *((_DWORD *)v182 - 1);
        float v193 = (float *)(a3 + 4 * v191);
        float v194 = -*v182;
        float v195 = -v193[1];
        *(v182 - 1) = *v193;
        *float v182 = v195;
        *(_DWORD *)float v193 = v192;
        v193[1] = v194;
        int v196 = *((_DWORD *)v185 - 1);
        float v197 = -*v185;
        float v198 = -v193[3];
        *(v185 - 1) = *(float *)(a3 + 4 * (v191 + 2));
        *float v185 = v198;
        *(_DWORD *)(a3 + 4 * (v191 + 2)) = v196;
        v193[3] = v197;
        uint64_t v199 = (int)v191 + 2 - v167;
        int v200 = *(_DWORD *)(v183 - 8);
        float v201 = -*(float *)(v183 - 4);
        uint64_t v202 = a3 + 4 * v199;
        float v203 = -*(float *)(v202 + 4);
        *(_DWORD *)(v183 - 8) = *(_DWORD *)v202;
        *(float *)(v183 - 4) = v203;
        *(_DWORD *)uint64_t v202 = v200;
        *(float *)(v202 + 4) = v201;
        int v204 = *(_DWORD *)v183;
        float v205 = -*(float *)(v183 + 4);
        uint64_t v206 = a3 + 4 * ((int)v199 + (int)v168);
        float v207 = -*(float *)(v206 + 4);
        *(_DWORD *)uint64_t v183 = *(_DWORD *)v206;
        *(float *)(v183 + 4) = v207;
        v183 += 16;
        *(_DWORD *)uint64_t v206 = v204;
        *(float *)(v206 + 4) = v205;
        int v208 = *(_DWORD *)(a3 + 4 * (v180 + (int)v174));
        uint64_t v209 = a3 + 4 * ((int)v191 + 2 + (int)v168);
        float v210 = -*(float *)(a3 + (v178 >> 30));
        float v211 = -*(float *)(v209 + 4);
        *(_DWORD *)(a3 + 4 * (v180 + (int)v174)) = *(_DWORD *)v209;
        *(float *)(a3 + (v178 >> 30)) = v211;
        *(_DWORD *)uint64_t v209 = v208;
        *(float *)(v209 + 4) = v210;
        LODWORD(v209) = v179 + v174 + 2;
        int v212 = *(_DWORD *)(a3 + 4 * (int)v209);
        LODWORD(v206) = v179 + v174 + 3;
        uint64_t v213 = (int)v191 + (int)v168;
        float v214 = -*(float *)(a3 + 4 * (int)v206);
        uint64_t v215 = a3 + 4 * v213;
        float v216 = -*(float *)(v215 + 4);
        *(_DWORD *)(a3 + 4 * (int)v209) = *(_DWORD *)v215;
        *(float *)(a3 + 4 * (int)v206) = v216;
        LODWORD(v209) = v175 + v174 + 2;
        *(_DWORD *)uint64_t v215 = v212;
        *(float *)(v215 + 4) = v214;
        int v217 = *(_DWORD *)(a3 + 4 * (int)v209);
        LODWORD(v206) = v175 + v174 + 3;
        float v218 = *(float *)(a3 + 4 * (int)v206);
        uint64_t v219 = a3 + 4 * (v213 - v167);
        float v220 = *(float *)(v219 + 4);
        *(_DWORD *)(a3 + 4 * (int)v209) = *(_DWORD *)v219;
        v174 += 4;
        v178 += 0x400000000;
        v181 += 4;
        *(float *)(a3 + 4 * (int)v206) = -v220;
        *(_DWORD *)uint64_t v219 = v217;
        *(float *)(v219 + 4) = -v218;
        v182 += 4;
        v185 += 4;
        --v184;
      }
      while (v184);
    }
    else
    {
      LODWORD(v176) = 0;
    }
    uint64_t v221 = *(int *)(a2 + 4 * v173) + (uint64_t)(int)v176;
    uint64_t v222 = v221 + 2;
    int v223 = v221 + v168;
    uint64_t v224 = a3 + 4 * v221;
    *(float *)(v224 + 4) = -*(float *)(v224 + 4);
    int v225 = *(_DWORD *)(a3 + 4 * (v221 + 2));
    float v226 = -*(float *)(v224 + 12);
    uint64_t v227 = a3 + 4 * ((int)v221 + (int)v168);
    float v228 = -*(float *)(v227 + 4);
    *(_DWORD *)(a3 + 4 * v222) = *(_DWORD *)v227;
    *(float *)(v224 + 12) = v228;
    *(_DWORD *)uint64_t v227 = v225;
    *(float *)(v227 + 4) = v226;
    *(float *)(v227 + 12) = -*(float *)(v227 + 12);
    uint64_t v229 = v167 + (int)v222;
    LODWORD(v222) = v223 + v167;
    int v230 = (float *)(a3 + 4 * v229);
    *(v230 - 1) = -*(v230 - 1);
    float v231 = *v230;
    float v232 = -v230[1];
    uint64_t v233 = (float *)(a3 + 4 * (int)v222);
    float v234 = -v233[1];
    *int v230 = *v233;
    v230[1] = v234;
    float *v233 = v231;
    v233[1] = v232;
    float result = -v233[3];
    v233[3] = result;
    ++v165;
  }
  while (v165 != v166);
  return result;
}

double bitrv216neg(uint64_t a1)
{
  double result = *(double *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  *(void *)&long long v6 = *(void *)(a1 + 72);
  *(void *)&long long v7 = *(void *)(a1 + 80);
  *(void *)&long long v8 = *(void *)(a1 + 88);
  *(void *)&long long v9 = *(void *)(a1 + 96);
  *(void *)&long long v11 = *(void *)(a1 + 112);
  *(void *)&long long v10 = *(void *)(a1 + 120);
  uint64_t v12 = *(void *)(a1 + 64);
  *((void *)&v10 + 1) = *(void *)(a1 + 56);
  *(void *)&long long v13 = *(void *)(a1 + 104);
  *((void *)&v8 + 1) = *(void *)(a1 + 24);
  *(_OWORD *)(a1 + 8) = v10;
  *(_OWORD *)(a1 + 24) = v8;
  *((void *)&v13 + 1) = v4;
  *((double *)&v6 + 1) = result;
  *(_OWORD *)(a1 + 40) = v13;
  *((void *)&v11 + 1) = v5;
  *(_OWORD *)(a1 + 72) = v11;
  *((void *)&v7 + 1) = v2;
  *(_OWORD *)(a1 + 88) = v7;
  *((void *)&v9 + 1) = v3;
  *(_OWORD *)(a1 + 104) = v9;
  *(_OWORD *)(a1 + 56) = v6;
  *(void *)(a1 + 120) = v12;
  return result;
}

double bitrv208neg(uint64_t a1)
{
  double result = *(double *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)&long long v4 = *(void *)(a1 + 48);
  *(void *)&long long v3 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 32);
  *((void *)&v3 + 1) = *(void *)(a1 + 24);
  *(void *)&long long v6 = *(void *)(a1 + 40);
  *((double *)&v6 + 1) = result;
  *(_OWORD *)(a1 + 8) = v3;
  *((void *)&v4 + 1) = v2;
  *(_OWORD *)(a1 + 40) = v4;
  *(_OWORD *)(a1 + 24) = v6;
  *(void *)(a1 + 56) = v5;
  return result;
}

float cftb040(float *a1)
{
  float v1 = a1[1];
  float v2 = a1[4];
  float v3 = a1[5];
  float v4 = *a1 + v2;
  float v5 = v1 + v3;
  float v6 = *a1 - v2;
  float v7 = v1 - v3;
  float v8 = a1[2];
  float v9 = a1[3];
  float v10 = a1[6];
  float v11 = a1[7];
  float v12 = v8 + v10;
  float v13 = v9 + v11;
  float v14 = v8 - v10;
  float v15 = v9 - v11;
  *a1 = v4 + v12;
  a1[1] = v5 + v13;
  a1[2] = v6 + v15;
  a1[3] = v7 - v14;
  a1[4] = v4 - v12;
  a1[5] = v5 - v13;
  float result = v6 - v15;
  a1[6] = result;
  a1[7] = v7 + v14;
  return result;
}

float cftmdl1(int a1, float *a2, uint64_t a3)
{
  uint64_t v3 = (uint64_t)a1 >> 3;
  uint64_t v4 = 2 * (a1 >> 3);
  int v5 = 4 * (a1 >> 3);
  float v6 = a2[v5];
  float v7 = a2[1];
  float v8 = *a2 + v6;
  float v9 = &a2[4 * (a1 >> 3)];
  float v10 = v9[1];
  float v11 = v7 + v10;
  float v12 = *a2 - v6;
  float v13 = v7 - v10;
  uint64_t v14 = 2 * (a1 >> 3);
  float v15 = a2[v14];
  float v16 = a2[6 * (a1 >> 3)];
  float v17 = v15 + v16;
  float v18 = a2[(int)(v4 | 1)];
  int v19 = (6 * (a1 >> 3)) | 1;
  float v20 = a2[v19];
  float v21 = v15 - v16;
  *a2 = v8 + v17;
  a2[1] = v11 + (float)(v18 + v20);
  a2[v14] = v8 - v17;
  a2[(int)(v4 | 1)] = v11 - (float)(v18 + v20);
  a2[v5] = v12 - (float)(v18 - v20);
  a2[6 * (a1 >> 3)] = v12 + (float)(v18 - v20);
  v9[1] = v13 + v21;
  a2[v19] = v13 - v21;
  float v22 = *(float *)(a3 + 4);
  if (a1 >= 24)
  {
    uint64_t v23 = 24 * v3;
    uint64_t v24 = v23 + 12;
    uint64_t v25 = 4 * v5;
    uint64_t v26 = v25 + 12;
    uint64_t v27 = v25 - 4;
    uint64_t v28 = v23 - 4;
    uint64_t v29 = (float *)(a3 + 28);
    uint64_t v30 = 8 * (a1 >> 3) - 8;
    uint64_t v31 = 16 * (a1 >> 3) - 8;
    uint64_t v32 = 24 * (a1 >> 3) - 8;
    uint64_t v33 = 32 * (a1 >> 3) - 8;
    uint64_t v34 = 4 * v4 + 8;
    uint64_t v35 = 8 * v4 + 8;
    uint64_t v36 = 12 * v4 + 8;
    uint64_t v37 = 2;
    uint64_t v38 = 3;
    uint64_t v39 = (v4 << 34) - 0x200000000;
    do
    {
      float v40 = *(v29 - 3);
      float v41 = *(v29 - 2);
      float v43 = *(v29 - 1);
      float v42 = *v29;
      float v44 = &a2[v38];
      float v45 = a2[v38 - 1];
      float v46 = a2[v38];
      float v47 = *(float *)((char *)a2 + v35);
      float v48 = *(float *)((char *)a2 + v26);
      float v49 = v45 + v47;
      float v50 = v46 + v48;
      float v51 = v45 - v47;
      int v52 = (float *)((char *)a2 + v34);
      float v53 = *(float *)((char *)a2 + v36);
      float v54 = v46 - v48;
      float v55 = *(float *)((char *)a2 + v34);
      float v56 = *(float *)((char *)a2 + v34 + 4);
      float v57 = v55 + v53;
      float v58 = *(float *)((char *)a2 + v24);
      float v59 = v55 - v53;
      float v60 = v56 - v58;
      *(v44 - 1) = v49 + v57;
      *float v44 = v50 + (float)(v56 + v58);
      float v61 = v50 - (float)(v56 + v58);
      float v62 = v51 - (float)(v56 - v58);
      *int v52 = v49 - v57;
      v52[1] = v61;
      float v63 = (float)(v41 * v62) + (float)(v40 * (float)(v54 + v59));
      *(float *)((char *)a2 + v35) = (float)(v40 * v62) - (float)(v41 * (float)(v54 + v59));
      float v64 = v51 + v60;
      float v65 = v54 - v59;
      *(float *)((char *)a2 + v26) = v63;
      *(float *)((char *)a2 + v36) = (float)(v42 * v65) + (float)(v43 * v64);
      *(float *)((char *)a2 + v24) = (float)(v43 * v65) - (float)(v42 * v64);
      float v66 = (float *)((char *)a2 + v30);
      float v67 = *(float *)((char *)a2 + v32);
      float v68 = *(float *)((char *)a2 + v30);
      float v69 = *(float *)((char *)a2 + v30 + 4);
      float v70 = v68 + v67;
      float v71 = *(float *)((char *)a2 + v28);
      float v72 = *(float *)((char *)a2 + v31);
      float v73 = v69 + v71;
      float v74 = v68 - v67;
      float v75 = *(float *)((char *)a2 + v33);
      float v76 = *(float *)((char *)a2 + v27);
      float v77 = v69 - v71;
      float v78 = v72 + v75;
      uint64_t v79 = (v39 >> 30) | 4;
      float v80 = *(float *)((char *)a2 + v79);
      float v81 = v72 - v75;
      *float v66 = v70 + v78;
      v66[1] = v73 + (float)(v76 + v80);
      *(float *)((char *)a2 + v31) = v70 - v78;
      *(float *)((char *)a2 + v27) = v73 - (float)(v76 + v80);
      *(float *)((char *)a2 + v32) = (float)(v41 * (float)(v74 - (float)(v76 - v80)))
                                   - (float)(v40 * (float)(v77 + v81));
      float v82 = (float)(v40 * (float)(v74 - (float)(v76 - v80))) + (float)(v41 * (float)(v77 + v81));
      float v83 = v74 + (float)(v76 - v80);
      *(float *)((char *)a2 + v28) = v82;
      v37 += 2;
      *(float *)((char *)a2 + v33) = (float)(v43 * (float)(v77 - v81)) + (float)(v42 * v83);
      v24 += 8;
      v26 += 8;
      v27 -= 8;
      *(float *)((char *)a2 + v79) = (float)(v42 * (float)(v77 - v81)) - (float)(v43 * v83);
      v28 -= 8;
      v29 += 4;
      v30 -= 8;
      v31 -= 8;
      v39 -= 0x200000000;
      v32 -= 8;
      v33 -= 8;
      v34 += 8;
      v35 += 8;
      v36 += 8;
      v38 += 2;
    }
    while (v37 < v3);
  }
  uint64_t v84 = 3 * v3;
  uint64_t v85 = 5 * v3;
  uint64_t v86 = 7 * v3;
  float v87 = a2[5 * v3];
  float v88 = &a2[v3];
  float v89 = v88[1];
  float v90 = a2[(int)v85 + 1];
  float v91 = *v88 + v87;
  float v92 = v89 + v90;
  float v93 = *v88 - v87;
  float v94 = v89 - v90;
  float v95 = a2[v84];
  float v96 = a2[v86];
  float v97 = v95 + v96;
  float v98 = a2[(int)v84 + 1];
  float v99 = a2[(int)v86 + 1];
  float v100 = v95 - v96;
  *float v88 = v91 + v97;
  v88[1] = v92 + (float)(v98 + v99);
  a2[v84] = v91 - v97;
  a2[(int)v84 + 1] = v92 - (float)(v98 + v99);
  a2[v85] = v22 * (float)((float)(v93 - (float)(v98 - v99)) - (float)(v94 + v100));
  a2[(int)v85 + 1] = v22 * (float)((float)(v94 + v100) + (float)(v93 - (float)(v98 - v99)));
  float v101 = v93 + (float)(v98 - v99);
  float v102 = v94 - v100;
  a2[v86] = -(float)(v22 * (float)(v102 + v101));
  float result = -(float)(v22 * (float)(v102 - v101));
  a2[(int)v86 + 1] = result;
  return result;
}

uint64_t cfttree(int a1, int a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  unsigned int v10 = a1;
  if ((a3 & 3) != 0)
  {
    float v11 = (float *)(a4 + 4 * (a2 - a1));
    if ((a3 & 1) == 0)
    {
      cftmdl2(a1, v11, a6 + 4 * (a5 - a1));
      return 0;
    }
    cftmdl1(a1, v11, a6 + 4 * (a5 - (a1 >> 1)));
    return 1;
  }
  do
  {
    unsigned int v12 = a3;
    v10 *= 4;
    a3 >>= 2;
  }
  while ((v12 & 0xC) == 0);
  if (((v12 >> 2) & 1) == 0)
  {
    if ((int)v10 >= 129)
    {
      do
      {
        cftmdl2(v10, (float *)(a4 + 4 * (int)(a2 - v10)), a6 + 4 * (int)(a5 - v10));
        BOOL v13 = v10 > 0x203;
        v10 >>= 2;
      }
      while (v13);
    }
    return 0;
  }
  if ((int)v10 < 129) {
    return 1;
  }
  uint64_t v14 = (v12 >> 2) & 1;
  do
  {
    cftmdl1(v10, (float *)(a4 + 4 * (int)(a2 - v10)), a6 + 4 * (int)(a5 - (v10 >> 1)));
    BOOL v13 = v10 > 0x203;
    v10 >>= 2;
  }
  while (v13);
  return v14;
}

float cftmdl2(int a1, float *a2, uint64_t a3)
{
  int v3 = a1 >> 3;
  uint64_t v4 = (uint64_t)a1 >> 3;
  uint64_t v5 = 2 * (a1 >> 3);
  float v6 = *(float *)(a3 + 4);
  float v7 = &a2[4 * (a1 >> 3)];
  float v8 = a2[1];
  float v9 = v7[1];
  float v10 = *a2 - v9;
  float v11 = v8 + *v7;
  float v12 = *a2 + v9;
  float v13 = v8 - *v7;
  uint64_t v14 = 2 * (a1 >> 3);
  float v15 = a2[v14];
  float v16 = &a2[6 * (a1 >> 3)];
  float v17 = v16[1];
  float v18 = v15 - v17;
  uint64_t v19 = (int)(v5 | 1);
  float v20 = a2[v19];
  float v21 = v20 + *v16;
  float v22 = v15 + v17;
  float v23 = v20 - *v16;
  float v24 = v6 * (float)(v18 - v21);
  float v25 = v6 * (float)(v18 + v21);
  *a2 = v10 + v24;
  a2[1] = v11 + v25;
  a2[v14] = v10 - v24;
  a2[v19] = v11 - v25;
  float v26 = v6 * (float)(v22 - v23);
  float v27 = v6 * (float)(v22 + v23);
  float *v7 = v12 - v27;
  v7[1] = v13 + v26;
  float *v16 = v12 + v27;
  v16[1] = v13 - v26;
  if (a1 >= 24)
  {
    uint64_t v28 = 4 * v3;
    uint64_t v29 = a3 + 16 * v3;
    uint64_t v30 = 24 * v3 + 8;
    uint64_t v31 = (float *)(a3 + 28);
    uint64_t v32 = 8 * v5 + 8;
    uint64_t v33 = 4 * v5 + 12;
    uint64_t v34 = 16 * v5 - 8;
    uint64_t v35 = (float *)(v29 - 8);
    uint64_t v36 = 24 * v4;
    uint64_t v37 = v36 + 12;
    uint64_t v38 = 4 * v28;
    uint64_t v39 = 4 * v28 + 12;
    uint64_t v40 = v38 - 4;
    uint64_t v41 = v36 - 4;
    uint64_t v42 = 4 * v5 - 8;
    uint64_t v43 = 8 * v5 - 8;
    uint64_t v44 = 12 * v5 - 8;
    uint64_t v45 = 2;
    uint64_t v46 = 2;
    uint64_t v47 = (v5 << 34) - 0x200000000;
    do
    {
      float v48 = *(v31 - 3);
      float v49 = *(v31 - 2);
      float v51 = *(v31 - 1);
      float v50 = *v31;
      float v52 = *(v35 - 2);
      float v53 = *(v35 - 1);
      float v54 = *v35;
      float v55 = v35[1];
      float v56 = &a2[v46];
      float v57 = *(float *)((char *)a2 + v39);
      float v58 = *(float *)((char *)a2 + v32);
      float v59 = a2[v46];
      float v60 = a2[v46 + 1];
      float v61 = v59 - v57;
      float v62 = v60 + v58;
      float v63 = v59 + v57;
      float v64 = (float *)((char *)a2 + v33);
      float v65 = *(float *)((char *)a2 + v33 - 4);
      float v66 = *(float *)((char *)a2 + v33);
      float v67 = v60 - v58;
      float v68 = *(float *)((char *)a2 + v37);
      float v69 = *(float *)((char *)a2 + v30);
      float v70 = v65 - v68;
      float v71 = v66 + v69;
      float v72 = v65 + v68;
      float v73 = v66 - v69;
      float v74 = v49 * v61;
      float v75 = (float)(v48 * v61) - (float)(v49 * v62);
      float v76 = v74 + (float)(v48 * v62);
      float v77 = (float)(v53 * v70) - (float)(v52 * v71);
      float v78 = (float)(v52 * v70) + (float)(v53 * v71);
      *float v56 = v75 + v77;
      v56[1] = v76 + v78;
      *(v64 - 1) = v75 - v77;
      *float v64 = v76 - v78;
      float v79 = (float)(v50 * v67) + (float)(v51 * v63);
      float v80 = (float)(v51 * v67) - (float)(v50 * v63);
      float v81 = (float)(v54 * v73) + (float)(v55 * v72);
      float v82 = (float)(v55 * v73) - (float)(v54 * v72);
      *(float *)((char *)a2 + v32) = v79 + v81;
      *(float *)((char *)a2 + v39) = v80 + v82;
      *(float *)((char *)a2 + v30) = v79 - v81;
      *(float *)((char *)a2 + v37) = v80 - v82;
      float v83 = (float *)((char *)a2 + v42);
      float v84 = *(float *)((char *)a2 + v41);
      float v85 = *(float *)((char *)a2 + v42);
      float v86 = *(float *)((char *)a2 + v42 + 4);
      float v87 = *(float *)((char *)a2 + v44);
      float v88 = *(float *)((char *)a2 + v43);
      float v89 = v85 - v84;
      uint64_t v90 = (v47 >> 30) | 4;
      float v91 = *(float *)((char *)a2 + v90);
      float v92 = v86 + v87;
      float v93 = v85 + v84;
      float v94 = *(float *)((char *)a2 + v40);
      float v95 = *(float *)((char *)a2 + v34);
      float v96 = v86 - v87;
      float v97 = v88 - v91;
      float v98 = v94 + v95;
      float v99 = v88 + v91;
      float v100 = v94 - v95;
      float v101 = (float)(v52 * v89) - (float)(v53 * v92);
      float v102 = (float)(v53 * v89) + (float)(v52 * v92);
      float v103 = (float)(v49 * v97) - (float)(v48 * v98);
      float v104 = (float)(v48 * v97) + (float)(v49 * v98);
      *float v83 = v101 + v103;
      v83[1] = v102 + v104;
      float v105 = (float)(v55 * v96) + (float)(v54 * v93);
      float v106 = (float)(v54 * v96) - (float)(v55 * v93);
      *(float *)((char *)a2 + v43) = v101 - v103;
      float v107 = (float)(v51 * v100) + (float)(v50 * v99);
      *(float *)((char *)a2 + v40) = v102 - v104;
      *(float *)((char *)a2 + v44) = v105 + v107;
      float v108 = (float)(v50 * v100) - (float)(v51 * v99);
      *(float *)((char *)a2 + v41) = v106 + v108;
      v45 += 2;
      v46 += 2;
      *(float *)((char *)a2 + v34) = v105 - v107;
      v30 += 8;
      v31 += 4;
      v32 += 8;
      *(float *)((char *)a2 + v90) = v106 - v108;
      v33 += 8;
      v34 -= 8;
      v35 -= 4;
      v37 += 8;
      v39 += 8;
      v40 -= 8;
      v41 -= 8;
      v47 -= 0x200000000;
      v42 -= 8;
      v43 -= 8;
      v44 -= 8;
    }
    while (v45 < v4);
  }
  float v109 = *(float *)(a3 + 4 * v5);
  float v110 = *(float *)(a3 + 4 * v19);
  uint64_t v111 = 3 * v4;
  uint64_t v112 = 5 * v4;
  uint64_t v113 = 7 * v4;
  float v114 = &a2[v4];
  uint64_t v115 = &a2[v112];
  float v116 = v115[1];
  float v117 = v114[1];
  float v118 = *v114 - v116;
  float v119 = v117 + *v115;
  float v120 = *v114 + v116;
  float v121 = a2[v111];
  float v122 = v117 - *v115;
  int v123 = &a2[v113];
  float v124 = v123[1];
  float v125 = a2[(int)v111 + 1];
  float v126 = v121 - v124;
  float v127 = a2[(int)v113];
  float v128 = v125 + v127;
  float v129 = v121 + v124;
  float v130 = v125 - v127;
  float v131 = (float)(v109 * v118) - (float)(v110 * v119);
  float v132 = (float)(v110 * v118) + (float)(v109 * v119);
  float v133 = (float)(v110 * v126) - (float)(v109 * v128);
  float v134 = (float)(v109 * v126) + (float)(v110 * v128);
  float *v114 = v131 + v133;
  v114[1] = v132 + v134;
  a2[v111] = v131 - v133;
  a2[(int)v111 + 1] = v132 - v134;
  float v135 = (float)(v110 * v120) - (float)(v109 * v122);
  float v136 = (float)(v109 * v120) + (float)(v110 * v122);
  float v137 = (float)(v109 * v129) - (float)(v110 * v130);
  float v138 = (float)(v110 * v129) + (float)(v109 * v130);
  *uint64_t v115 = v135 - v137;
  v115[1] = v136 - v138;
  a2[(int)v113] = v135 + v137;
  float result = v136 + v138;
  v123[1] = result;
  return result;
}

float cftf162(float *a1, float *a2)
{
  float v2 = a1[2];
  float v3 = a1[3];
  float v5 = a1[18];
  float v4 = a1[19];
  float v6 = a2[4];
  float v7 = a2[5];
  float v114 = (float)(v7 * (float)(v2 - v4)) + (float)(v6 * (float)(v3 + v5));
  float v116 = (float)(v6 * (float)(v2 - v4)) - (float)(v7 * (float)(v3 + v5));
  float v8 = a1[10];
  float v9 = a1[11];
  float v11 = a1[26];
  float v10 = a1[27];
  float v13 = a2[6];
  float v12 = a2[7];
  float v111 = (float)(v13 * (float)(v8 - v10)) - (float)(v12 * (float)(v9 + v11));
  float v113 = (float)-(float)(v13 * (float)(v9 + v11)) - (float)(v12 * (float)(v8 - v10));
  float v14 = v2 + v4;
  float v15 = v3 - v5;
  float v109 = (float)(v13 * v15) - (float)(v12 * v14);
  float v110 = (float)(v12 * v15) + (float)(v13 * v14);
  float v16 = (float)(v6 * (float)(v9 - v11)) - (float)(v7 * (float)(v8 + v10));
  float v17 = a1[4];
  float v18 = a1[5];
  float v20 = a1[20];
  float v19 = a1[21];
  float v21 = a2[8];
  float v22 = a2[9];
  float v23 = (float)(v21 * (float)(v17 - v19)) - (float)(v22 * (float)(v18 + v20));
  float v107 = (float)(v22 * (float)(v17 - v19)) + (float)(v21 * (float)(v18 + v20));
  float v108 = (float)(v7 * (float)(v9 - v11)) + (float)(v6 * (float)(v8 + v10));
  float v24 = a1[12];
  float v25 = a1[13];
  float v27 = a1[28];
  float v26 = a1[29];
  float v28 = (float)(v22 * (float)(v24 - v26)) - (float)(v21 * (float)(v25 + v27));
  float v29 = (float)(v21 * (float)(v24 - v26)) + (float)(v22 * (float)(v25 + v27));
  float v30 = v17 + v19;
  float v31 = v18 - v20;
  float v106 = (float)(v22 * v30) - (float)(v21 * v31);
  float v104 = (float)(v21 * v30) + (float)(v22 * v31);
  float v32 = (float)(v21 * (float)(v24 + v26)) - (float)(v22 * (float)(v25 - v27));
  float v33 = (float)(v22 * (float)(v24 + v26)) + (float)(v21 * (float)(v25 - v27));
  float v34 = a1[6];
  float v35 = a1[7];
  float v37 = a1[22];
  float v36 = a1[23];
  float v38 = v34 - v36;
  float v39 = a1[14];
  float v40 = a1[15];
  float v42 = a1[30];
  float v41 = a1[31];
  float v43 = (float)(v7 * (float)(v39 - v41)) - (float)(v6 * (float)(v40 + v42));
  float v44 = (float)(v6 * (float)(v39 - v41)) + (float)(v7 * (float)(v40 + v42));
  float v45 = v34 + v36;
  float v46 = (float)(v6 * (float)(v35 - v37)) + (float)(v7 * v45);
  float v47 = a2[1];
  float v48 = (float)(v7 * (float)(v35 - v37)) - (float)(v6 * v45);
  float v49 = a1[8];
  float v50 = a1[9];
  float v51 = v35 + v37;
  float v52 = (float)(v12 * v51) + (float)(v13 * v38);
  float v53 = (float)(v13 * v51) - (float)(v12 * v38);
  float v54 = v39 + v41;
  float v56 = a1[24];
  float v55 = a1[25];
  float v57 = v40 - v42;
  float v58 = (float)-(float)(v13 * v57) - (float)(v12 * v54);
  float v59 = (float)(v13 * v54) - (float)(v12 * v57);
  float v60 = v47 * (float)((float)(v49 - v55) - (float)(v50 + v56));
  float v61 = a1[1];
  float v62 = a1[16];
  float v63 = a1[17];
  float v64 = *a1 - v63;
  float v65 = v64 + v60;
  float v66 = v64 - v60;
  float v67 = v47 * (float)((float)(v49 - v55) + (float)(v50 + v56));
  float v68 = (float)(v61 + v62) + v67;
  float v69 = (float)(v61 + v62) - v67;
  float v70 = *a1 + v63;
  float v71 = v61 - v62;
  float v72 = v47 * (float)((float)(v49 + v55) + (float)(v50 - v56));
  float v103 = v70 - v72;
  float v73 = v70 + v72;
  float v74 = v47 * (float)((float)(v49 + v55) - (float)(v50 - v56));
  float v75 = v71 + v74;
  float v105 = v71 - v74;
  float v76 = v114 + v111;
  float v77 = v114 - v111;
  float v78 = v109 - v16;
  float v115 = v109 + v16;
  float v79 = v23 + v28;
  float v80 = v23 - v28;
  float v81 = v107 + v29;
  float v82 = v107 - v29;
  float v83 = v32;
  float v84 = v106 - v32;
  float v85 = v104 - v33;
  float v112 = v104 + v33;
  float v86 = v52 + v43;
  float v87 = v52 - v43;
  float v88 = v53 + v44;
  float v89 = v53 - v44;
  float v90 = v46 + v58;
  float v91 = v46 - v58;
  float v92 = v48 + v59;
  float v93 = v48 - v59;
  *a1 = (float)(v65 + v79) + (float)((float)(v116 + v113) + v86);
  a1[1] = (float)(v68 + v81) + (float)(v76 + v88);
  a1[2] = (float)(v65 + v79) - (float)((float)(v116 + v113) + v86);
  a1[3] = (float)(v68 + v81) - (float)(v76 + v88);
  a1[4] = (float)(v65 - v79) - (float)(v76 - v88);
  a1[5] = (float)(v68 - v81) + (float)((float)(v116 + v113) - v86);
  a1[6] = (float)(v65 - v79) + (float)(v76 - v88);
  a1[7] = (float)(v68 - v81) - (float)((float)(v116 + v113) - v86);
  float v94 = v47 * (float)((float)((float)(v116 - v113) - v89) - (float)(v77 + v87));
  float v95 = v47 * (float)((float)((float)(v116 - v113) - v89) + (float)(v77 + v87));
  a1[8] = (float)(v66 - v82) + v94;
  a1[9] = (float)(v69 + v80) + v95;
  a1[10] = (float)(v66 - v82) - v94;
  a1[11] = (float)(v69 + v80) - v95;
  float v96 = v47 * (float)((float)((float)(v116 - v113) + v89) - (float)(v77 - v87));
  float v97 = v47 * (float)((float)((float)(v116 - v113) + v89) + (float)(v77 - v87));
  a1[12] = (float)(v66 + v82) - v97;
  a1[13] = (float)(v69 - v80) + v96;
  a1[14] = (float)(v66 + v82) + v97;
  a1[15] = (float)(v69 - v80) - v96;
  a1[16] = (float)(v103 + v84) + (float)((float)(v110 - v108) - v90);
  a1[17] = (float)(v75 + v85) + (float)(v78 - v92);
  a1[18] = (float)(v103 + v84) - (float)((float)(v110 - v108) - v90);
  a1[19] = (float)(v75 + v85) - (float)(v78 - v92);
  a1[20] = (float)(v103 - v84) - (float)(v78 + v92);
  a1[21] = (float)(v75 - v85) + (float)((float)(v110 - v108) + v90);
  a1[22] = (float)(v103 - v84) + (float)(v78 + v92);
  a1[23] = (float)(v75 - v85) - (float)((float)(v110 - v108) + v90);
  float v98 = v47 * (float)((float)((float)(v110 + v108) + v93) - (float)(v115 - v91));
  float v99 = v47 * (float)((float)((float)(v110 + v108) + v93) + (float)(v115 - v91));
  a1[24] = (float)(v73 - v112) + v98;
  a1[25] = (float)(v105 + (float)(v106 + v83)) + v99;
  a1[26] = (float)(v73 - v112) - v98;
  a1[27] = (float)(v105 + (float)(v106 + v83)) - v99;
  float v100 = v47 * (float)((float)((float)(v110 + v108) - v93) - (float)(v115 + v91));
  float v101 = v47 * (float)((float)((float)(v110 + v108) - v93) + (float)(v115 + v91));
  a1[28] = (float)(v73 + v112) - v101;
  a1[29] = (float)(v105 - (float)(v106 + v83)) + v100;
  float result = (float)(v73 + v112) + v101;
  a1[30] = result;
  a1[31] = (float)(v105 - (float)(v106 + v83)) - v100;
  return result;
}

float cftf082(float *a1, float *a2)
{
  float v2 = a2[1];
  float v3 = a2[2];
  float v4 = a2[3];
  float v5 = a1[1];
  float v7 = a1[8];
  float v6 = a1[9];
  float v8 = *a1 - v6;
  float v9 = v5 + v7;
  float v10 = *a1 + v6;
  float v11 = v5 - v7;
  float v12 = a1[4];
  float v13 = a1[5];
  float v15 = a1[12];
  float v14 = a1[13];
  float v16 = v2 * (float)((float)(v12 - v14) - (float)(v13 + v15));
  float v17 = v2 * (float)((float)(v12 - v14) + (float)(v13 + v15));
  float v18 = v12 + v14;
  float v19 = v13 - v15;
  float v20 = v2 * (float)(v18 - v19);
  float v21 = v2 * (float)(v18 + v19);
  float v22 = a1[2];
  float v23 = a1[3];
  float v25 = a1[10];
  float v24 = a1[11];
  float v26 = (float)(v3 * (float)(v22 - v24)) - (float)(v4 * (float)(v23 + v25));
  float v27 = (float)(v4 * (float)(v22 - v24)) + (float)(v3 * (float)(v23 + v25));
  float v28 = v22 + v24;
  float v29 = v23 - v25;
  float v30 = (float)(v4 * v28) - (float)(v3 * v29);
  float v31 = (float)(v3 * v28) + (float)(v4 * v29);
  float v32 = a1[6];
  float v33 = a1[7];
  float v35 = a1[14];
  float v34 = a1[15];
  float v36 = (float)(v4 * (float)(v32 - v34)) - (float)(v3 * (float)(v33 + v35));
  float v37 = (float)(v3 * (float)(v32 - v34)) + (float)(v4 * (float)(v33 + v35));
  float v38 = v32 + v34;
  float v39 = v33 - v35;
  float v40 = (float)(v3 * v38) - (float)(v4 * v39);
  float v41 = (float)(v4 * v38) + (float)(v3 * v39);
  *a1 = (float)(v8 + v16) + (float)(v26 + v36);
  a1[1] = (float)(v9 + v17) + (float)(v27 + v37);
  a1[2] = (float)(v8 + v16) - (float)(v26 + v36);
  a1[3] = (float)(v9 + v17) - (float)(v27 + v37);
  a1[4] = (float)(v8 - v16) - (float)(v27 - v37);
  a1[5] = (float)(v9 - v17) + (float)(v26 - v36);
  a1[6] = (float)(v8 - v16) + (float)(v27 - v37);
  a1[7] = (float)(v9 - v17) - (float)(v26 - v36);
  a1[8] = (float)(v10 - v21) + (float)(v30 - v40);
  a1[9] = (float)(v11 + v20) + (float)(v31 - v41);
  a1[10] = (float)(v10 - v21) - (float)(v30 - v40);
  a1[11] = (float)(v11 + v20) - (float)(v31 - v41);
  float v42 = v10 + v21;
  float v43 = v11 - v20;
  a1[12] = v42 - (float)(v31 + v41);
  a1[13] = v43 + (float)(v30 + v40);
  float result = v42 + (float)(v31 + v41);
  a1[14] = result;
  a1[15] = v43 - (float)(v30 + v40);
  return result;
}

float dctsub(int a1, uint64_t a2, int a3, float *a4)
{
  int v4 = a1 >> 1;
  if (a1 >= 4)
  {
    int v5 = a3 / a1;
    float v6 = &a4[a3 - a3 / a1];
    if (v4 <= 2) {
      uint64_t v7 = 2;
    }
    else {
      uint64_t v7 = v4;
    }
    float v8 = (float *)(a2 + 4 * a1 - 4);
    float v9 = (float *)(a2 + 4);
    uint64_t v10 = v7 - 1;
    uint64_t v11 = -4 * v5;
    float v12 = &a4[v5];
    do
    {
      float v13 = *v12 - *v6;
      float v14 = *v12 + *v6;
      float v15 = *v9;
      float v16 = -(float)(v13 * *v8);
      *float v9 = (float)(v14 * *v8) + (float)(v13 * *v9);
      ++v9;
      *v8-- = v16 + (float)(v14 * v15);
      float v6 = (float *)((char *)v6 + v11);
      v12 += a3 / a1;
      --v10;
    }
    while (v10);
  }
  float result = *a4 * *(float *)(a2 + 4 * v4);
  *(float *)(a2 + 4 * v4) = result;
  return result;
}

float dstsub(int a1, uint64_t a2, int a3, float *a4)
{
  int v4 = a1 >> 1;
  if (a1 >= 4)
  {
    int v5 = a3 / a1;
    float v6 = &a4[a3 - a3 / a1];
    if (v4 <= 2) {
      uint64_t v7 = 2;
    }
    else {
      uint64_t v7 = v4;
    }
    float v8 = (float *)(a2 + 4 * a1 - 4);
    float v9 = (float *)(a2 + 4);
    uint64_t v10 = v7 - 1;
    uint64_t v11 = -4 * v5;
    float v12 = &a4[v5];
    do
    {
      float v13 = *v12 - *v6;
      float v14 = *v12 + *v6;
      float v15 = *v8;
      float v16 = -(float)(v13 * *v9);
      *float v8 = (float)(v14 * *v9) + (float)(v13 * *v8);
      --v8;
      *v9++ = v16 + (float)(v14 * v15);
      float v6 = (float *)((char *)v6 + v11);
      v12 += a3 / a1;
      --v10;
    }
    while (v10);
  }
  float result = *a4 * *(float *)(a2 + 4 * v4);
  *(float *)(a2 + 4 * v4) = result;
  return result;
}

uint64_t axpy_c(uint64_t result, float *a2, int a3, float *a4, int a5, float a6)
{
  if ((int)result >= 1)
  {
    uint64_t v6 = result;
    do
    {
      *a4 = *a4 + (float)(a6 * *a2);
      a4 += a5;
      a2 += a3;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t axpy(uint64_t result, float *a2, int a3, float *a4, int a5, float a6)
{
  if (((a4 | a2) & 0x1F) != 0)
  {
    if ((int)result >= 1)
    {
      uint64_t v6 = result;
      do
      {
        *a4 = *a4 + (float)(a6 * *a2);
        a4 += a5;
        a2 += a3;
        --v6;
      }
      while (v6);
    }
  }
  else if ((int)result >= 1)
  {
    uint64_t v7 = result;
    do
    {
      *a4 = *a4 + (float)(a6 * *a2);
      a4 += a5;
      a2 += a3;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t axpby_f32_c(uint64_t result, float *a2, float *a3, float *a4, float a5, float a6)
{
  if ((int)result >= 1)
  {
    uint64_t v6 = result;
    do
    {
      float v7 = *a2++;
      float v8 = v7;
      float v9 = *a3++;
      *a4++ = (float)(v9 * a6) + (float)(a5 * v8);
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t axpby_f32(uint64_t result, float *a2, float *a3, float *a4, float a5, float a6)
{
  if ((a2 & 0x1F) != 0)
  {
    if ((int)result >= 1)
    {
      uint64_t v6 = result;
      do
      {
        float v7 = *a2++;
        float v8 = v7;
        float v9 = *a3++;
        *a4++ = (float)(v9 * a6) + (float)(a5 * v8);
        --v6;
      }
      while (v6);
    }
  }
  else if ((int)result >= 1)
  {
    uint64_t v10 = result;
    do
    {
      float v11 = *a2++;
      float v12 = v11;
      float v13 = *a3++;
      *a4++ = (float)(v13 * a6) + (float)(a5 * v12);
      --v10;
    }
    while (v10);
  }
  return result;
}

float dot(float *a1, signed int a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5 = (~a5 + a2);
  if ((int)v5 < 1)
  {
    unsigned int v12 = 0;
    float result = 0.0;
  }
  else
  {
    uint64_t v6 = (float *)(a3 + 4 * a5);
    float result = 0.0;
    float v8 = a1;
    do
    {
      float v9 = *v8++;
      float v10 = v9;
      float v11 = *v6++;
      float result = result + (float)(v10 * v11);
      --v5;
    }
    while (v5);
    unsigned int v12 = a2 - a5 - 1;
  }
  if ((int)v12 < a2)
  {
    float v13 = (float *)(a4 + 4 * (a5 - a2 + 1 + (unint64_t)v12));
    float v14 = &a1[v12];
    unint64_t v15 = a2 - (unint64_t)v12;
    do
    {
      float v16 = *v14++;
      float v17 = v16;
      float v18 = *v13++;
      float result = result + (float)(v17 * v18);
      --v15;
    }
    while (v15);
  }
  return result;
}

uint64_t src_generate_fir_coeffs(uint64_t *a1, unsigned int a2, float **a3, float a4)
{
  uint64_t v8 = a2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], a2, 4);
  if (!v9) {
    goto LABEL_26;
  }
  float v13 = (float *)v9;
  if (a2)
  {
    uint64_t v14 = 0;
    float v15 = a4 + a4;
    do
    {
      float v16 = v15 * (float)((float)v14 - (float)((float)(int)(a2 - 1) * 0.5));
      float v17 = 1.0;
      if (v16 != 0.0) {
        float v17 = sinf(v16 * 3.1416) / (float)(v16 * 3.1416);
      }
      v13[v14++] = v15 * v17;
    }
    while (v8 != v14);
  }
  uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v8, 4);
  if (v18)
  {
    if (a2)
    {
      uint64_t v19 = 0;
      do
      {
        int v20 = 0;
        float v21 = (float)((float)((float)((float)v19 * 2.0) + 2.0) - (float)((float)a2 + 1.0))
            / (float)((float)a2 + 1.0);
        float v22 = (float)(sqrtf(1.0 - (float)(v21 * v21)) * 3.2) * 0.5;
        float v23 = 0.0;
        unsigned int v24 = 1;
        for (int i = 2; i != 11; ++i)
        {
          if (v24 >= 2)
          {
            int v28 = 0;
            int v26 = 1;
            float v27 = v22;
            do
            {
              float v27 = v22 * v27;
              v26 *= v28 + 2;
              ++v28;
            }
            while (v20 != v28);
          }
          else
          {
            int v26 = 1;
            float v27 = v22;
          }
          float v23 = v23 + (float)((float)(v27 / (float)v26) * (float)(v27 / (float)v26));
          ++v24;
          ++v20;
        }
        int v29 = 0;
        float v30 = 0.0;
        unsigned int v31 = 1;
        for (int j = 2; j != 11; ++j)
        {
          if (v31 >= 2)
          {
            int v35 = 0;
            int v33 = 1;
            float v34 = 1.6;
            do
            {
              float v34 = v34 * 1.6;
              v33 *= v35 + 2;
              ++v35;
            }
            while (v29 != v35);
          }
          else
          {
            int v33 = 1;
            float v34 = 1.6;
          }
          float v30 = v30 + (float)((float)(v34 / (float)v33) * (float)(v34 / (float)v33));
          ++v31;
          ++v29;
        }
        *(float *)(v18 + 4 * v19++) = (float)(v23 + 1.0) / (float)(v30 + 1.0);
      }
      while (v19 != v8);
      float v36 = v13;
      float v37 = (float *)v18;
      do
      {
        float v38 = *v37++;
        *float v36 = v38 * *v36;
        ++v36;
        --v8;
      }
      while (v8);
    }
    *a3 = v13;
    (*(void (**)(uint64_t, uint64_t))(a1[1] + 48))(a1[2], v18);
    return 0;
  }
  else
  {
LABEL_26:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v40);
    return 10;
  }
}

uint64_t src_generate_fir_filter(uint64_t *a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, uint64_t *a6)
{
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 48);
  if (!v12) {
    goto LABEL_13;
  }
  uint64_t v16 = v12;
  int v17 = a3 / a4;
  uint64_t v18 = a3 % a4 ? (v17 + 1) : v17;
  uint64_t v19 = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], v18 * a4, 4);
  if (!v19) {
    goto LABEL_13;
  }
  unsigned int v20 = 0;
  do
  {
    unsigned int v21 = v20 + 1;
    if (v18)
    {
      uint64_t v22 = 0;
      uint64_t v23 = v18;
      do
      {
        *(_DWORD *)(v19 + 4 * (v21 * v18 + ~v22++)) = *(_DWORD *)(a2 + 4 * v20);
        v20 += a4;
        --v23;
      }
      while (v23);
    }
    unsigned int v20 = v21;
  }
  while (v21 != a4);
  *(void *)uint64_t v16 = v19;
  *(_DWORD *)(v16 + 8) = a4;
  *(_DWORD *)(v16 + 12) = v18;
  *(_DWORD *)(v16 + 16) = a4;
  *(_DWORD *)(v16 + 20) = a5;
  *(void *)(v16 + 24) = 0;
  *(_DWORD *)(v16 + 40) = v18 - 1;
  uint64_t v24 = (*(uint64_t (**)(uint64_t))(a1[1] + 16))(a1[2]);
  *(void *)(v16 + 32) = v24;
  if (v24)
  {
    uint64_t result = 0;
    *a6 = v16;
  }
  else
  {
LABEL_13:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v13, v14, v15, v26);
    return 10;
  }
  return result;
}

uint64_t src_generate(uint64_t *a1, unsigned int a2, int a3, uint64_t *a4)
{
  uint64_t v11 = 0;
  *a4 = 0;
  uint64_t fir_filter = src_generate_fir_coeffs(a1, 0x108u, &v11, 0.5 / (float)a2);
  uint64_t v9 = v11;
  if (!fir_filter)
  {
    uint64_t fir_filter = src_generate_fir_filter(a1, (uint64_t)v11, 0x108u, a2, a3, a4);
    if (!v9) {
      return fir_filter;
    }
    goto LABEL_3;
  }
  if (v11) {
LABEL_3:
  }
    (*(void (**)(uint64_t, float *))(a1[1] + 48))(a1[2], v9);
  return fir_filter;
}

uint64_t src_filt(uint64_t *a1, int *a2, unsigned int a3, uint64_t a4)
{
  unsigned int v7 = *((_DWORD *)a1 + 6);
  int v6 = *((_DWORD *)a1 + 7);
  if (v6 >= (int)a3)
  {
    uint64_t v9 = 0;
    uint64_t v13 = (_DWORD *)a1[4];
  }
  else
  {
    LODWORD(v9) = 0;
    unsigned int v10 = *((_DWORD *)a1 + 4);
    signed int v11 = *((_DWORD *)a1 + 3);
    int v26 = *((_DWORD *)a1 + 5) % v10;
    int v27 = *((_DWORD *)a1 + 5);
    uint64_t v12 = *a1;
    float v25 = a1;
    uint64_t v13 = (_DWORD *)a1[4];
    do
    {
      unsigned int v14 = v9;
      uint64_t v15 = v13;
      float v16 = dot((float *)(v12 + 4 * v11 * v7), v11, (uint64_t)v13, (uint64_t)a2, v6);
      uint64_t v13 = v15;
      uint64_t v9 = v14 + 1;
      *(float *)(a4 + 4 * v14) = v16 * (float)v10;
      v6 += (v7 + v27) / v10;
      unsigned int v7 = (v7 + v26) % v10;
    }
    while (v6 < (int)a3);
    a1 = v25;
  }
  *((_DWORD *)a1 + 6) = v7;
  *((_DWORD *)a1 + 7) = v6 - a3;
  uint64_t v17 = *((unsigned int *)a1 + 10);
  if (v17 >= a3)
  {
    uint64_t v18 = v17 - a3;
    if (v17 != a3)
    {
      unsigned int v19 = a3;
      unsigned int v20 = v13;
      do
      {
        *v20++ = v13[v19++];
        --v18;
      }
      while (v18);
    }
    if (a3)
    {
      uint64_t v21 = a3;
      int v22 = v17 - a3;
      do
      {
        int v23 = *a2++;
        v13[v22++] = v23;
        --v21;
      }
      while (v21);
    }
  }
  else
  {
    cstdlib_memcpy(v13, &a2[a3 - v17], 4 * v17);
  }
  return v9;
}

void gemm_cmp(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, float32x4_t *a7)
{
}

uint64_t gemm_impl(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, uint64_t))
{
  if (a9) {
    return a9(result, a2, a3);
  }
  return result;
}

void gemm(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, float32x4_t *a7, _DWORD *a8, uint64_t a9)
{
  if (!a8)
  {
    LODWORD(v15) = 1;
    unsigned int v16 = a4;
LABEL_12:
    gemm_v2((uint64_t)a1, v15, a2, a3, a4, a5, a4, a6, v16, a7, a3);
    return;
  }
  if (!*a8)
  {
    uint64_t v15 = a8[2];
    if (a8[4])
    {
      gemm_impl_qntz((uint64_t)a1, v15, a2, a3, a4, a5, a6, (uint64_t)a7, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))gemm_v5);
      return;
    }
    if (v15) {
      unsigned int v16 = a4;
    }
    else {
      unsigned int v16 = a3;
    }
    goto LABEL_12;
  }
  uint64_t v14 = *a1;

  log_OutText(v14, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Block Sparse only support SSE or NEON \n", a5, (uint64_t)a7, (uint64_t)a8, a9);
}

uint64_t gemm_impl_qntz(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  if (a9) {
    return a9(result, a2, a3, a4);
  }
  return result;
}

void gemm_ex(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t *a9, int a10, _DWORD *a11)
{
  if (a11)
  {
    if (*a11)
    {
      uint64_t v17 = *a1;
      log_OutText(v17, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Block Sparse only support SSE or NEON\n", a5, a6, a8, (uint64_t)a9);
      return;
    }
    uint64_t v18 = a11[2];
    if (a11[4])
    {
      LODWORD(v20) = a10;
      LODWORD(v19) = a8;
      gemm_impl_ex_qntz((uint64_t)a1, v18, a2, a3, a4, a5, a6, a7, v19, (uint64_t)a9, v20, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))gemm_v5);
      return;
    }
  }
  else
  {
    LODWORD(v18) = 1;
  }

  gemm_v2((uint64_t)a1, v18, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t gemm_impl_ex_qntz(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t (*a12)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  if (a12) {
    return a12(result, a2, a3, a4);
  }
  return result;
}

uint64_t gemm_impl_ex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t (*a12)(void))
{
  if (a12) {
    return a12();
  }
  return result;
}

float clip(float a1, float a2, float a3)
{
  if (a1 <= a3) {
    a3 = a1;
  }
  if (a1 >= a2) {
    return a3;
  }
  else {
    return a2;
  }
}

uint64_t _denormalize(float *a1, unsigned int a2, uint64_t a3)
{
  if (*(_DWORD *)a3)
  {
    if (*(_DWORD *)(a3 + 4))
    {
      if (a2)
      {
        int v3 = *(_DWORD *)(a3 + 12);
        float v4 = (float)-v3;
        int v5 = *(_DWORD *)(a3 + 8);
        float v6 = (float)v3;
        float v7 = (float)*(int *)(a3 + 16);
        uint64_t v8 = a2;
        do
        {
          float v9 = *a1;
          if (v5)
          {
            float v10 = *(float *)(a3 + 20);
            float v11 = -v10;
            if (v9 <= v10) {
              float v10 = *a1;
            }
            if (v9 >= v11) {
              float v9 = v10;
            }
            else {
              float v9 = v11;
            }
            *a1 = v9;
          }
          *a1++ = (float)((float)((float)((float)(v9 + *(float *)(a3 + 20)) * v4)
                                / (float)(*(float *)(a3 + 20) + *(float *)(a3 + 20)))
                        + v6)
                + v7;
          --v8;
        }
        while (v8);
      }
    }
    else if (a2)
    {
      int v12 = *(_DWORD *)(a3 + 8);
      int v13 = *(_DWORD *)(a3 + 12);
      float v14 = (float)-v13;
      float v15 = (float)v13;
      float v16 = (float)*(int *)(a3 + 16);
      uint64_t v17 = a2;
      do
      {
        float v18 = *a1;
        if (v12)
        {
          float v19 = *(float *)(a3 + 20);
          if (v18 <= v19) {
            float v19 = *a1;
          }
          if (v18 >= 0.0) {
            float v18 = v19;
          }
          else {
            float v18 = 0.0;
          }
          *a1 = v18;
        }
        *a1++ = (float)((float)((float)(v18 * v14) / *(float *)(a3 + 20)) + v15) + v16;
        --v17;
      }
      while (v17);
    }
  }
  return 0;
}

void fast_tanh_c(float *a1, int a2, float *a3)
{
  if (a2 >= 1)
  {
    uint64_t v5 = a2;
    do
    {
      float v6 = 1.0;
      if (*a1 <= 9.0)
      {
        float v6 = -1.0;
        if (*a1 >= -9.0) {
          float v6 = tanhf(*a1);
        }
      }
      *a3++ = v6;
      ++a1;
      --v5;
    }
    while (v5);
  }
}

void fast_tanh(float *a1, int a2, float *a3)
{
  float v4 = a1;
  if ((a1 & 0x1F) != 0)
  {
    if (a2 >= 1)
    {
      uint64_t v5 = a2;
      do
      {
        float v6 = 1.0;
        if (*v4 <= 9.0)
        {
          float v6 = -1.0;
          if (*v4 >= -9.0) {
            float v6 = tanhf(*v4);
          }
        }
        *a3++ = v6;
        ++v4;
        --v5;
      }
      while (v5);
    }
  }
  else if (a2 >= 1)
  {
    uint64_t v7 = a2;
    do
    {
      float v8 = 1.0;
      if (*v4 <= 9.0)
      {
        float v8 = -1.0;
        if (*v4 >= -9.0) {
          float v8 = tanhf(*v4);
        }
      }
      *a3++ = v8;
      ++v4;
      --v7;
    }
    while (v7);
  }
}

void fast_tanh_approx(float *a1, int a2, float *a3)
{
  float v4 = a1;
  if ((a1 & 0x1F) != 0)
  {
    if (a2 >= 1)
    {
      uint64_t v5 = a2;
      do
      {
        float v6 = 1.0;
        if (*v4 <= 9.0)
        {
          float v6 = -1.0;
          if (*v4 >= -9.0) {
            float v6 = tanhf(*v4);
          }
        }
        *a3++ = v6;
        ++v4;
        --v5;
      }
      while (v5);
    }
  }
  else if (a2 >= 1)
  {
    uint64_t v7 = a2;
    do
    {
      float v8 = 1.0;
      if (*v4 <= 9.0)
      {
        float v8 = -1.0;
        if (*v4 >= -9.0) {
          float v8 = tanhf(*v4);
        }
      }
      *a3++ = v8;
      ++v4;
      --v7;
    }
    while (v7);
  }
}

void gelu_array_f32_c(unsigned int a1, float *a2)
{
  if (a1)
  {
    uint64_t v3 = a1;
    do
    {
      float v4 = *a2;
      float v5 = (float)(*a2 * (float)(*a2 * (float)(*a2 * 0.035677))) + (float)(*a2 * 0.79789);
      *a2++ = v4 * (float)(1.0 - (float)(1.0 / (float)(expf(v5 + v5) + 1.0)));
      --v3;
    }
    while (v3);
  }
}

void gelu_array_f32(unsigned int a1, float *a2)
{
  float v2 = a2;
  if ((a2 & 0x1F) != 0)
  {
    if (a1)
    {
      uint64_t v3 = a1;
      do
      {
        float v4 = *v2;
        float v5 = (float)(*v2 * (float)(*v2 * (float)(*v2 * 0.035677))) + (float)(*v2 * 0.79789);
        *v2++ = v4 * (float)(1.0 - (float)(1.0 / (float)(expf(v5 + v5) + 1.0)));
        --v3;
      }
      while (v3);
    }
  }
  else if (a1)
  {
    uint64_t v6 = a1;
    do
    {
      float v7 = *v2;
      float v8 = (float)(*v2 * (float)(*v2 * (float)(*v2 * 0.035677))) + (float)(*v2 * 0.79789);
      *v2++ = v7 * (float)(1.0 - (float)(1.0 / (float)(expf(v8 + v8) + 1.0)));
      --v6;
    }
    while (v6);
  }
}

void sigmoid_c(float *a1, unsigned int a2, float *a3)
{
  if (a2)
  {
    uint64_t v5 = a2;
    do
    {
      float v6 = *a1++;
      float v7 = 1.0 / (fast_exp_single(-v6) + 1.0);
      *a3++ = v7;
      --v5;
    }
    while (v5);
  }
}

void sigmoid(float *a1, unsigned int a2, float *a3)
{
}

void sigmoid_approx(float *a1, unsigned int a2, float *a3)
{
}

void softmax_simple(float *a1, unsigned int a2, float *a3)
{
  uint64_t v3 = a3;
  if (a2)
  {
    uint64_t v4 = a2;
    float v5 = -3.4028e38;
    uint64_t v6 = a2;
    float v7 = a1;
    do
    {
      float v8 = *v7++;
      float v9 = v8;
      if (v8 > v5) {
        float v5 = v9;
      }
      --v6;
    }
    while (v6);
    do
    {
      *(float *)((char *)a3 + v6) = *(float *)((char *)a1 + v6) - v5;
      v6 += 4;
    }
    while (4 * a2 != v6);
    fast_exp(a3, a2, a3);
    float v10 = 0.0;
    uint64_t v11 = v4;
    int v12 = v3;
    do
    {
      float v13 = *v12++;
      float v10 = v10 + v13;
      --v11;
    }
    while (v11);
    if (v10 != 0.0)
    {
      float v14 = 1.0 / v10;
      do
      {
        *uint64_t v3 = v14 * *v3;
        ++v3;
        --v4;
      }
      while (v4);
    }
  }
  else
  {
    fast_exp(a3, 0, a3);
  }
}

void softmax_simple_temp(float *a1, unsigned int a2, float *a3, float a4)
{
  if (a4 >= 0.00000001)
  {
    uint64_t v4 = a3;
    if (a2)
    {
      uint64_t v5 = a2;
      float v6 = -3.4028e38;
      uint64_t v7 = a2;
      float v8 = a1;
      float v9 = 1.0 / a4;
      do
      {
        float v10 = *v8++;
        float v11 = v10;
        if (v10 > v6) {
          float v6 = v11;
        }
        --v7;
      }
      while (v7);
      do
      {
        *(float *)((char *)a3 + v7) = v9 * (float)(*(float *)((char *)a1 + v7) - v6);
        v7 += 4;
      }
      while (4 * a2 != v7);
      fast_exp(a3, a2, a3);
      float v12 = 0.0;
      uint64_t v13 = v5;
      float v14 = v4;
      do
      {
        float v15 = *v14++;
        float v12 = v12 + v15;
        --v13;
      }
      while (v13);
      if (v12 != 0.0)
      {
        float v16 = 1.0 / v12;
        do
        {
          *uint64_t v4 = v16 * *v4;
          ++v4;
          --v5;
        }
        while (v5);
      }
    }
    else
    {
      fast_exp(a3, 0, a3);
    }
  }
}

void softmax(float *a1, unsigned int a2, int a3, float *a4, float a5)
{
  if (a5 >= 0.00000001)
  {
    if (a3 == 1)
    {
      if ((float)(a5 + -1.0) >= 0.00000001 || (float)(1.0 - a5) >= 0.00000001)
      {
        softmax_simple_temp(a1, a2, a4, a5);
      }
      else
      {
        softmax_simple(a1, a2, a4);
      }
    }
    else if (a2)
    {
      int v8 = 0;
      uint64_t v9 = a2;
      float v10 = -3.4028e38;
      uint64_t v11 = a2;
      float v12 = 1.0 / a5;
      do
      {
        if (a1[v8] > v10) {
          float v10 = a1[v8];
        }
        v8 += a3;
        --v11;
      }
      while (v11);
      int v13 = 0;
      float v14 = v12 * v10;
      float v15 = 0.0;
      uint64_t v16 = a2;
      do
      {
        float v17 = expf((float)(v12 * a1[v13]) - v14);
        float v15 = v15 + v17;
        a4[v13] = v17;
        v13 += a3;
        --v16;
      }
      while (v16);
      if (v15 != 0.0)
      {
        int v18 = 0;
        do
        {
          a4[v18] = (float)(1.0 / v15) * a4[v18];
          v18 += a3;
          --v9;
        }
        while (v9);
      }
    }
  }
}

uint64_t oneNorm(uint64_t result, unsigned int a2, int a3, uint64_t a4)
{
  if (a2)
  {
    unsigned int v4 = 0;
    uint64_t v5 = a2;
    float v6 = 0.0;
    uint64_t v7 = a2;
    do
    {
      float v6 = v6 + *(float *)(result + 4 * v4);
      v4 += a3;
      --v7;
    }
    while (v7);
    if (v6 != 0.0)
    {
      unsigned int v8 = 0;
      float v9 = 1.0 / v6;
      do
      {
        *(float *)(a4 + 4 * v8) = v9 * *(float *)(a4 + 4 * v8);
        v8 += a3;
        --v5;
      }
      while (v5);
    }
  }
  return result;
}

uint64_t getLargestIdx(uint64_t a1, int a2)
{
  if (a2 < 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = 0;
  LODWORD(v3) = -1;
  float v4 = -3.4028e38;
  do
  {
    float v5 = *(float *)(a1 + 4 * v2);
    if (v5 >= v4) {
      uint64_t v3 = v2;
    }
    else {
      uint64_t v3 = v3;
    }
    if (v5 >= v4) {
      float v4 = *(float *)(a1 + 4 * v2);
    }
    ++v2;
  }
  while (a2 != v2);
  return v3;
}

uint64_t matrix_transpose(uint64_t result, unsigned int a2, int a3)
{
  unint64_t v3 = 0;
  LODWORD(v4) = a3 * a2;
  if (a3 * a2 <= 1) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = v4;
  }
  do
  {
    int v5 = 1;
    LODWORD(v6) = v3;
    do
    {
      unint64_t v6 = v6 / a2 + v6 % a2 * a3;
      --v5;
    }
    while (v3 < v6);
    if (v3 <= v6 && v5 != 0)
    {
      int v8 = *(_DWORD *)(result + 4 * v3);
      unsigned int v9 = v3;
      do
      {
        unint64_t v10 = v9 / a2 + v9 % a2 * a3;
        int v11 = v8;
        if (v3 != v10) {
          int v11 = *(_DWORD *)(result + 4 * v10);
        }
        *(_DWORD *)(result + 4 * v9) = v11;
        unsigned int v9 = v9 / a2 + v9 % a2 * a3;
      }
      while (v3 < v10);
    }
    ++v3;
  }
  while (v3 != v4);
  return result;
}

uint64_t sparse_sgemv_accum16_c(uint64_t result, float *a2, int a3, int *a4, uint64_t a5)
{
  if (a3 >= 1)
  {
    for (unint64_t i = 0; i < a3; i += 16)
    {
      int v7 = *a4++;
      int v6 = v7;
      if (v7 >= 1)
      {
        int v8 = (float *)(result + 4 * i);
        float v9 = *v8;
        float v10 = v8[1];
        float v11 = v8[2];
        float v12 = v8[3];
        float v13 = v8[4];
        float v14 = v8[5];
        float v15 = v8[6];
        float v16 = v8[7];
        float v17 = v8[8];
        float v18 = v8[9];
        float v19 = v8[10];
        float v20 = v8[11];
        float v21 = v8[12];
        float v22 = v8[13];
        float v23 = v8[14];
        float v24 = v8[15];
        do
        {
          uint64_t v25 = *a4++;
          float v26 = *(float *)(a5 + 4 * v25);
          float v9 = v9 + (float)(*a2 * v26);
          *int v8 = v9;
          float v10 = v10 + (float)(a2[1] * v26);
          v8[1] = v10;
          float v11 = v11 + (float)(a2[2] * v26);
          v8[2] = v11;
          float v12 = v12 + (float)(a2[3] * v26);
          v8[3] = v12;
          float v13 = v13 + (float)(a2[4] * v26);
          _DWORD v8[4] = v13;
          float v14 = v14 + (float)(a2[5] * v26);
          v8[5] = v14;
          float v15 = v15 + (float)(a2[6] * v26);
          v8[6] = v15;
          float v16 = v16 + (float)(a2[7] * v26);
          v8[7] = v16;
          float v17 = v17 + (float)(a2[8] * v26);
          v8[8] = v17;
          float v18 = v18 + (float)(a2[9] * v26);
          v8[9] = v18;
          float v19 = v19 + (float)(a2[10] * v26);
          v8[10] = v19;
          float v20 = v20 + (float)(a2[11] * v26);
          v8[11] = v20;
          float v21 = v21 + (float)(a2[12] * v26);
          v8[12] = v21;
          float v22 = v22 + (float)(a2[13] * v26);
          v8[13] = v22;
          float v23 = v23 + (float)(a2[14] * v26);
          v8[14] = v23;
          float v24 = v24 + (float)(a2[15] * v26);
          v8[15] = v24;
          a2 += 16;
          --v6;
        }
        while (v6);
      }
    }
  }
  return result;
}

uint64_t sparse_sgemv_accum16(uint64_t result, float *a2, int a3, int *a4, uint64_t a5)
{
  return sparse_sgemv_accum16_c(result, a2, a3, a4, a5);
}

float accum4_c(unsigned int a1, float *a2, float *a3, float *a4, float *a5, float *a6)
{
  if (a1)
  {
    uint64_t v6 = a1;
    do
    {
      float v7 = *a2++;
      float v8 = v7;
      float v9 = *a3++;
      float v10 = v8 + v9;
      float v11 = *a4++;
      float v12 = v10 + v11;
      float v13 = *a5++;
      float result = v12 + v13;
      *a6++ = result;
      --v6;
    }
    while (v6);
  }
  return result;
}

float accum4(unsigned int a1, float *a2, float *a3, float *a4, float *a5, float *a6)
{
  if ((a2 & 0x1F) != 0)
  {
    if (a1)
    {
      uint64_t v6 = a1;
      do
      {
        float v7 = *a2++;
        float v8 = v7;
        float v9 = *a3++;
        float v10 = v8 + v9;
        float v11 = *a4++;
        float v12 = v10 + v11;
        float v13 = *a5++;
        float result = v12 + v13;
        *a6++ = result;
        --v6;
      }
      while (v6);
    }
  }
  else if (a1)
  {
    uint64_t v15 = a1;
    do
    {
      float v16 = *a2++;
      float v17 = v16;
      float v18 = *a3++;
      float v19 = v17 + v18;
      float v20 = *a4++;
      float v21 = v19 + v20;
      float v22 = *a5++;
      float result = v21 + v22;
      *a6++ = result;
      --v15;
    }
    while (v15);
  }
  return result;
}

void _amp_to_db(float *a1, int a2, int a3)
{
  LODWORD(v3) = a2;
  float v5 = expf((float)((float)a3 / 20.0) * 2.3026);
  if (v3)
  {
    float v6 = v5;
    uint64_t v3 = v3;
    do
    {
      float v7 = *a1;
      if (v6 > *a1) {
        float v7 = v6;
      }
      *a1++ = log10f(v7) * 20.0;
      --v3;
    }
    while (v3);
  }
}

void _db_to_amp(float *a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v3 = a2;
    do
    {
      *a1 = __exp10f(*a1 * 0.05);
      ++a1;
      --v3;
    }
    while (v3);
  }
}

float *_inv_preemphasis(float *result, unsigned int a2, float a3)
{
  if (a3 != 0.0 && a2 >= 2)
  {
    float v4 = *result++;
    float v5 = v4;
    uint64_t v6 = a2 - 1;
    do
    {
      float v5 = *result + (float)(a3 * v5);
      *result++ = v5;
      --v6;
    }
    while (v6);
  }
  return result;
}

float *_scale_to_one(float *result, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    float v3 = 0.01;
    uint64_t v4 = a2;
    float v5 = result;
    do
    {
      float v6 = *v5++;
      float v7 = fabsf(v6);
      if (v7 > v3) {
        float v3 = v7;
      }
      --v4;
    }
    while (v4);
    do
    {
      *float result = *result / v3;
      ++result;
      --v2;
    }
    while (v2);
  }
  return result;
}

float *_scale_to_pcm16(float *result, unsigned int a2)
{
  if (a2)
  {
    float v2 = 0.01;
    uint64_t v3 = a2;
    uint64_t v4 = result;
    do
    {
      float v5 = *v4++;
      float v6 = fabsf(v5);
      if (v6 > v2) {
        float v2 = v6;
      }
      --v3;
    }
    while (v3);
    do
    {
      *((_WORD *)result + v3) = (int)((float)((float)(result[v3] * 32767.0) / v2) + 0.5);
      ++v3;
    }
    while (a2 != v3);
  }
  return result;
}

float V2AddDot1x1(int a1, float *a2, float *a3, uint64_t a4, float *a5)
{
  float v5 = 0.0;
  if (a1 >= 1)
  {
    do
    {
      float v6 = *a2++;
      float v7 = v6;
      float v8 = *a3++;
      float v5 = v5 + (float)(v7 * v8);
      --a1;
    }
    while (a1);
  }
  float result = v5 + *a5;
  *a5 = result;
  return result;
}

float32x4_t V2AddDot1x4(int a1, float *a2, __int32 *a3, int a4, float32x4_t *a5)
{
  if (a1 < 1)
  {
    float32x4_t v5 = 0uLL;
  }
  else
  {
    float32x4_t v5 = 0uLL;
    do
    {
      float v6 = *a2++;
      v7.i32[0] = *a3;
      float v8 = &a3[3 * a4];
      v7.i32[1] = a3[a4];
      v7.i32[2] = a3[2 * a4];
      ++a3;
      v7.i32[3] = *v8;
      float32x4_t v5 = vmlaq_n_f32(v5, v7, v6);
      --a1;
    }
    while (a1);
  }
  float32x4_t result = vaddq_f32(v5, *a5);
  *a5 = result;
  return result;
}

float V2AddDot4x1(int a1, float *a2, int a3, float *a4, uint64_t a5, float *a6, int a7)
{
  if (a1 < 1)
  {
    float v10 = 0.0;
    float v9 = 0.0;
    float v8 = 0.0;
    float v7 = 0.0;
  }
  else
  {
    float v7 = 0.0;
    float v8 = 0.0;
    float v9 = 0.0;
    float v10 = 0.0;
    do
    {
      float v11 = a2[a3];
      float v12 = a2[2 * a3];
      float v13 = *a2;
      float v14 = a2[3 * a3];
      ++a2;
      float v15 = *a4++;
      float v10 = v10 + (float)(v13 * v15);
      float v9 = v9 + (float)(v11 * v15);
      float v8 = v8 + (float)(v12 * v15);
      float v7 = v7 + (float)(v14 * v15);
      --a1;
    }
    while (a1);
  }
  *a6 = v10 + *a6;
  a6[a7] = v9 + a6[a7];
  a6[2 * a7] = v8 + a6[2 * a7];
  uint64_t v16 = 3 * a7;
  float result = v7 + a6[v16];
  a6[v16] = result;
  return result;
}

float V2AddDot4x4(int a1, uint64_t a2, int a3, uint64_t a4, int a5, float32x4_t *a6, int a7)
{
  if (a1 < 1)
  {
    float32x4_t v8 = 0uLL;
    float v21 = 0.0;
    float v20 = 0.0;
    float v19 = 0.0;
    float v18 = 0.0;
    float v17 = 0.0;
    float v16 = 0.0;
    float v15 = 0.0;
    float v14 = 0.0;
    float v13 = 0.0;
    float v12 = 0.0;
    float v11 = 0.0;
    float v10 = 0.0;
  }
  else
  {
    uint64_t v7 = 0;
    float32x4_t v8 = 0uLL;
    uint64_t v9 = a4 + 8 * a5;
    float v10 = 0.0;
    float v11 = 0.0;
    float v12 = 0.0;
    float v13 = 0.0;
    float v14 = 0.0;
    float v15 = 0.0;
    float v16 = 0.0;
    float v17 = 0.0;
    float v18 = 0.0;
    float v19 = 0.0;
    float v20 = 0.0;
    float v21 = 0.0;
    do
    {
      float v22 = *(float *)(a2 + 4 * a3 + 4 * v7);
      float v23 = *(float *)(a2 + 8 * a3 + 4 * v7);
      float v24 = *(float *)(a2 + 12 * a3 + 4 * v7);
      v25.i32[0] = *(_DWORD *)(a4 + 4 * v7);
      float v26 = *(float *)(a4 + 12 * a5 + 4 * v7);
      float v21 = v21 + (float)(v22 * v25.f32[0]);
      float v17 = v17 + (float)(v23 * v25.f32[0]);
      float v13 = v13 + (float)(v24 * v25.f32[0]);
      v25.i32[1] = *(_DWORD *)(a4 + 4 * a5 + 4 * v7);
      v25.i64[1] = __PAIR64__(LODWORD(v26), *(_DWORD *)(v9 + 4 * v7));
      float32x4_t v8 = vmlaq_n_f32(v8, v25, *(float *)(a2 + 4 * v7));
      float v20 = v20 + (float)(v22 * v25.f32[1]);
      float v19 = v19 + (float)(v22 * *(float *)(v9 + 4 * v7));
      float v18 = v18 + (float)(v22 * v26);
      float v16 = v16 + (float)(v23 * v25.f32[1]);
      float v15 = v15 + (float)(v23 * *(float *)(v9 + 4 * v7));
      float v14 = v14 + (float)(v23 * v26);
      float v12 = v12 + (float)(v24 * v25.f32[1]);
      float v11 = v11 + (float)(v24 * *(float *)(v9 + 4 * v7));
      float v10 = v10 + (float)(v24 * v26);
      ++v7;
    }
    while (a1 != v7);
  }
  *a6 = vaddq_f32(v8, *a6);
  int v27 = &a6->f32[a7];
  float v28 = v27[1];
  *int v27 = v21 + *v27;
  v27[1] = v20 + v28;
  float v29 = v18 + v27[3];
  v27[2] = v19 + v27[2];
  void v27[3] = v29;
  a6->f32[2 * a7] = v17 + a6->f32[2 * a7];
  float v30 = &a6->f32[2 * a7];
  float v31 = v30[2];
  v30[1] = v16 + v30[1];
  v30[2] = v15 + v31;
  v30[3] = v14 + v30[3];
  a6->f32[3 * a7] = v13 + a6->f32[3 * a7];
  float v32 = &a6->f32[3 * a7];
  float v33 = v32[2];
  v32[1] = v12 + v32[1];
  v32[2] = v11 + v33;
  float result = v10 + v32[3];
  v32[3] = result;
  return result;
}

void gemm_v2(uint64_t a1, int a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, float32x4_t *a10, int a11)
{
  int v12 = a3;
  if (a3 >= 0) {
    int v14 = a3;
  }
  else {
    int v14 = a3 + 3;
  }
  if (a4 >= 0) {
    int v15 = a4;
  }
  else {
    int v15 = a4 + 3;
  }
  int padded_len = get_padded_len(a7, 8u);
  int v17 = get_padded_len(a9, 8u);
  int v71 = v17;
  if (a2)
  {
    LODWORD(v19) = v15 & 0xFFFFFFFC;
    if (v12 < 4)
    {
      unsigned int v34 = 0;
      float v33 = (__int32 *)a8;
      float v32 = a10;
      int v24 = a4;
    }
    else
    {
      int v64 = v12;
      uint64_t v76 = 0;
      uint64_t v20 = 0;
      unsigned int v63 = v15 & 0xFFFFFFFC;
      uint64_t v19 = (int)v19;
      uint64_t v21 = (int)(v14 & 0xFFFFFFFC);
      uint64_t v22 = 16 * v17;
      uint64_t v66 = 4 * v17;
      float v23 = a10;
      int v24 = a4;
      uint64_t v65 = v21;
      uint64_t v69 = (int)v19;
      uint64_t v67 = v22;
      do
      {
        float v73 = v23;
        if (v24 < 4)
        {
          uint64_t v28 = 0;
        }
        else
        {
          uint64_t v25 = 0;
          uint64_t v26 = v19;
          uint64_t v27 = a8;
          do
          {
            V2AddDot4x4(a5, a6 + 4 * v20 * padded_len, padded_len, v27, v71, v23, a11);
            v25 += 4;
            ++v23;
            v27 += v22;
          }
          while (v25 < v26);
          uint64_t v28 = v25;
          int v24 = a4;
          uint64_t v21 = v65;
        }
        if ((int)v28 < v24)
        {
          float v29 = &a10[v76].f32[v28];
          float v30 = (float *)(a8 + v66 * v28);
          uint64_t v31 = a4 - v28;
          do
          {
            V2AddDot4x1(a5, (float *)(a6 + 4 * v20 * padded_len), padded_len, v30, v18, v29++, a11);
            float v30 = (float *)((char *)v30 + v66);
            --v31;
          }
          while (v31);
        }
        v20 += 4;
        float v23 = &v73[a11];
        v76 += a11;
        int v24 = a4;
        uint64_t v19 = v69;
        uint64_t v22 = v67;
      }
      while (v20 < v21);
      float v33 = (__int32 *)a8;
      float v32 = a10;
      unsigned int v34 = v20;
      int v12 = v64;
      LODWORD(v19) = v63;
    }
    if ((int)v34 < v12)
    {
      uint64_t v44 = v71;
      uint64_t v45 = (int)v19;
      uint64_t v46 = v34;
      uint64_t v47 = padded_len;
      uint64_t v48 = v12;
      uint64_t v49 = v24;
      uint64_t v70 = padded_len;
      float v50 = (float32x4_t *)((char *)v32 + 4 * a11 * (unint64_t)v34);
      uint64_t v51 = 4 * a11;
      uint64_t v68 = v48;
      do
      {
        if (v24 < 4)
        {
          uint64_t v55 = 0;
        }
        else
        {
          uint64_t v52 = 0;
          uint64_t v77 = v46;
          float v53 = (float *)(a6 + 4 * v46 * v47);
          float v54 = v33;
          float v74 = v50;
          do
          {
            V2AddDot1x4(a5, v53, v54, v71, v50);
            v52 += 4;
            ++v50;
            v54 += 4 * v71;
          }
          while (v52 < v45);
          uint64_t v55 = v52;
          int v24 = a4;
          uint64_t v44 = v71;
          float v32 = a10;
          uint64_t v46 = v77;
          uint64_t v47 = v70;
          uint64_t v51 = 4 * a11;
          uint64_t v48 = v68;
          float v50 = v74;
        }
        if ((int)v55 < v24)
        {
          do
          {
            if (a5 < 1)
            {
              float v57 = 0.0;
            }
            else
            {
              float v56 = (float *)&v33[v55 * v44];
              float v57 = 0.0;
              int v58 = a5;
              float v59 = (float *)(a6 + 4 * v46 * v47);
              do
              {
                float v60 = *v59++;
                float v61 = v60;
                float v62 = *v56++;
                float v57 = v57 + (float)(v61 * v62);
                --v58;
              }
              while (v58);
            }
            v32->f32[v55 + v46 * a11] = v57 + v32->f32[v55 + v46 * a11];
            ++v55;
          }
          while (v55 != v49);
        }
        ++v46;
        float v50 = (float32x4_t *)((char *)v50 + v51);
      }
      while (v46 != v48);
    }
  }
  else if (v12 >= 1)
  {
    uint64_t v35 = 0;
    uint64_t v36 = 4 * v17;
    do
    {
      if (a5 >= 1)
      {
        uint64_t v37 = 0;
        float v38 = (float *)a8;
        do
        {
          if (a4 >= 1)
          {
            float v39 = *(float *)(a6 + 4 * v35 * padded_len + 4 * v37);
            uint64_t v40 = v38;
            uint64_t v41 = a4;
            float v42 = &a10->f32[v35 * a11];
            do
            {
              float v43 = *v40++;
              float *v42 = *v42 + (float)(v39 * v43);
              ++v42;
              --v41;
            }
            while (v41);
          }
          ++v37;
          float v38 = (float *)((char *)v38 + v36);
        }
        while (v37 != a5);
      }
      ++v35;
    }
    while (v35 != v12);
  }
}

void gemm_v5(uint64_t a1, int a2, int a3, int a4, int a5, float *a6, uint64_t a7, char *a8, unsigned int a9, float *a10, int a11, uint64_t a12)
{
  if (a12)
  {
    int v12 = *(float **)(a12 + 24);
    if (v12)
    {
      uint64_t v19 = a10;
      float v20 = *v12;
      float v21 = v12[1];
      int padded_len = get_padded_len(a7, 8u);
      int v23 = get_padded_len(a9, 0x20u);
      if (a2)
      {
        if (a3 >= 1)
        {
          uint64_t v24 = 0;
          do
          {
            if (a4 >= 1)
            {
              uint64_t v25 = 0;
              uint64_t v26 = v24 * a11;
              uint64_t v27 = a8;
              do
              {
                if (a5 >= 1)
                {
                  float v28 = a10[v25 + v26];
                  float v29 = a6;
                  float v30 = v27;
                  uint64_t v31 = a5;
                  do
                  {
                    float v32 = *v29++;
                    float v33 = v32;
                    int v34 = *v30++;
                    float v28 = v28 + (float)(v33 * (float)(v21 + (float)(v20 * (float)v34)));
                    a10[v25 + v26] = v28;
                    --v31;
                  }
                  while (v31);
                }
                ++v25;
                v27 += v23;
              }
              while (v25 != a4);
            }
            ++v24;
            a6 += padded_len;
          }
          while (v24 != a3);
        }
      }
      else if (a3 >= 1)
      {
        uint64_t v35 = 0;
        do
        {
          if (a5 >= 1)
          {
            uint64_t v36 = 0;
            uint64_t v37 = a8;
            do
            {
              if (a4 >= 1)
              {
                float v38 = v37;
                float v39 = v19;
                uint64_t v40 = a4;
                do
                {
                  int v41 = *v38++;
                  float *v39 = *v39 + (float)(a6[v36 + v35 * padded_len] * (float)(v21 + (float)(v20 * (float)v41)));
                  ++v39;
                  --v40;
                }
                while (v40);
              }
              ++v36;
              v37 += v23;
            }
            while (v36 != a5);
          }
          ++v35;
          v19 += a11;
        }
        while (v35 != a3);
      }
    }
  }
}

uint64_t pack_bsc_data(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  unsigned int padded_len = get_padded_len(a3, 4u);
  unsigned int v12 = get_padded_len(a4, 4u);
  uint64_t v13 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 8) + 64))(*(void *)(a1 + 16), 1, 32);
  if (!v13) {
    return 10;
  }
  uint64_t v14 = v13;
  uint64_t result = 0;
  *(_DWORD *)(v14 + 24) = padded_len >> 2;
  *(_DWORD *)(v14 + 28) = v12 >> 2;
  uint64_t v16 = a5 + 4 * (16 * a2);
  *(void *)uint64_t v14 = a5;
  *(void *)(v14 + 8) = v16 + 4 * (v12 >> 2) + 4;
  *(void *)(v14 + 16) = v16;
  *a6 = v14;
  return result;
}

uint64_t get_bsc_data_len(int a1, uint64_t a2)
{
  return 17 * a1 + (get_padded_len(a2, 4u) >> 2) + 1;
}

uint64_t pack_bsr_data(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  unsigned int padded_len = get_padded_len(a3, 4u);
  unsigned int v12 = get_padded_len(a4, 4u);
  uint64_t v13 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 8) + 64))(*(void *)(a1 + 16), 1, 32);
  if (!v13) {
    return 10;
  }
  uint64_t v14 = v13;
  uint64_t result = 0;
  *(_DWORD *)(v14 + 24) = padded_len >> 2;
  *(_DWORD *)(v14 + 28) = v12 >> 2;
  uint64_t v16 = a5 + 4 * (16 * a2);
  *(void *)uint64_t v14 = a5;
  *(void *)(v14 + 8) = v16;
  *(void *)(v14 + 16) = v16 + 4 * (padded_len >> 2) + 4;
  *a6 = v14;
  return result;
}

uint64_t get_bsr_data_len(int a1, uint64_t a2)
{
  return 17 * a1 + (get_padded_len(a2, 4u) >> 2) + 1;
}

uint64_t fi_layer_name_to_type(const char *a1)
{
  if (!cstdlib_strcmp(a1, "[avgpool1d]")) {
    return 8;
  }
  if (!cstdlib_strcmp(a1, "[avgpool2d]")) {
    return 14;
  }
  if (!cstdlib_strcmp(a1, "[blstm]")) {
    return 4;
  }
  uint64_t result = cstdlib_strcmp(a1, "[conv1d]");
  if (result)
  {
    if (cstdlib_strcmp(a1, "[conv2d]"))
    {
      if (cstdlib_strcmp(a1, "[fc]"))
      {
        if (cstdlib_strcmp(a1, "[flatten]"))
        {
          if (cstdlib_strcmp(a1, "[globalavgpool1d]"))
          {
            if (cstdlib_strcmp(a1, "[globalavgpool2d]"))
            {
              if (cstdlib_strcmp(a1, "[globalmaxpool1d]"))
              {
                if (cstdlib_strcmp(a1, "[globalmaxpool2d]"))
                {
                  if (cstdlib_strcmp(a1, "[gru]"))
                  {
                    if (cstdlib_strcmp(a1, "[bgru]"))
                    {
                      if (cstdlib_strcmp(a1, "[input]"))
                      {
                        if (cstdlib_strcmp(a1, "[label]"))
                        {
                          if (cstdlib_strcmp(a1, "[lstm]"))
                          {
                            if (cstdlib_strcmp(a1, "[maxpool1d]"))
                            {
                              if (cstdlib_strcmp(a1, "[maxpool2d]"))
                              {
                                if (cstdlib_strcmp(a1, "[nest]"))
                                {
                                  if (cstdlib_strcmp(a1, "[minpool1d]"))
                                  {
                                    if (cstdlib_strcmp(a1, "[minpool2d]"))
                                    {
                                      if (cstdlib_strcmp(a1, "[norm]"))
                                      {
                                        if (cstdlib_strcmp(a1, "[normonline]"))
                                        {
                                          if (cstdlib_strcmp(a1, "[repeat]"))
                                          {
                                            if (cstdlib_strcmp(a1, "[rnn]"))
                                            {
                                              if (cstdlib_strcmp(a1, "[softmax]"))
                                              {
                                                if (cstdlib_strcmp(a1, "[merge]"))
                                                {
                                                  if (cstdlib_strcmp(a1, "[tee]"))
                                                  {
                                                    if (cstdlib_strcmp(a1, "[wavernn]"))
                                                    {
                                                      if (cstdlib_strcmp(a1, "[sampling]"))
                                                      {
                                                        if (cstdlib_strcmp(a1, "[mulaw]"))
                                                        {
                                                          if (cstdlib_strcmp(a1, "[ffn]"))
                                                          {
                                                            if (cstdlib_strcmp(a1, "[attention]"))
                                                            {
                                                              if (cstdlib_strcmp(a1, "[trans_enc]"))
                                                              {
                                                                if (cstdlib_strcmp(a1, "[trans_encoder]"))
                                                                {
                                                                  if (cstdlib_strcmp(a1, "[trans_dec]"))
                                                                  {
                                                                    if (cstdlib_strcmp(a1, "[trans_decoder]"))
                                                                    {
                                                                      if (cstdlib_strcmp(a1, "[embedding]"))
                                                                      {
                                                                        if (cstdlib_strcmp(a1, "[highway]"))
                                                                        {
                                                                          if (cstdlib_strcmp(a1, "[gl]"))
                                                                          {
                                                                            if (cstdlib_strcmp(a1, "[highways]"))
                                                                            {
                                                                              if (cstdlib_strcmp(a1, "[conv1dnorm]"))
                                                                              {
                                                                                if (cstdlib_strcmp(a1, "[conv1dproj]"))
                                                                                {
                                                                                  if (cstdlib_strcmp(a1, "[conv1dbank]"))
                                                                                  {
                                                                                    if (cstdlib_strcmp(a1, "[cbhg]"))
                                                                                    {
                                                                                      if (cstdlib_strcmp(a1, "[tacodecoder]"))
                                                                                      {
                                                                                        if (cstdlib_strcmp(a1, "[tacotron]"))
                                                                                        {
                                                                                          if (cstdlib_strcmp(a1, "[invpreemph]"))
                                                                                          {
                                                                                            if (cstdlib_strcmp(a1, "[lpcnet]"))
                                                                                            {
                                                                                              if (cstdlib_strcmp(a1, "[tacotron_len]"))
                                                                                              {
                                                                                                if (cstdlib_strcmp(a1, "[multiband_lpcnet]"))
                                                                                                {
                                                                                                  if (cstdlib_strcmp(a1, "[tacotron_stream]"))
                                                                                                  {
                                                                                                    if (cstdlib_strcmp(a1, "[attention_albert]"))
                                                                                                    {
                                                                                                      if (cstdlib_strcmp(a1, "[albert_trans_enc]"))
                                                                                                      {
                                                                                                        if (cstdlib_strcmp(a1, "[albert_trans_encoder]"))
                                                                                                        {
                                                                                                          if (cstdlib_strcmp(a1, "[convtrans1d]"))
                                                                                                          {
                                                                                                            if (cstdlib_strcmp(a1, "[mrf]"))
                                                                                                            {
                                                                                                              if (cstdlib_strcmp(a1, "[pqmf]"))
                                                                                                              {
                                                                                                                if (cstdlib_strcmp(a1, "[reshape]"))
                                                                                                                {
                                                                                                                  if (cstdlib_strcmp(a1, "[upsample]")) {
                                                                                                                    return 1000000;
                                                                                                                  }
                                                                                                                  else {
                                                                                                                    return 73;
                                                                                                                  }
                                                                                                                }
                                                                                                                else
                                                                                                                {
                                                                                                                  return 72;
                                                                                                                }
                                                                                                              }
                                                                                                              else
                                                                                                              {
                                                                                                                return 71;
                                                                                                              }
                                                                                                            }
                                                                                                            else
                                                                                                            {
                                                                                                              return 70;
                                                                                                            }
                                                                                                          }
                                                                                                          else
                                                                                                          {
                                                                                                            return 69;
                                                                                                          }
                                                                                                        }
                                                                                                        else
                                                                                                        {
                                                                                                          return 43;
                                                                                                        }
                                                                                                      }
                                                                                                      else
                                                                                                      {
                                                                                                        return 42;
                                                                                                      }
                                                                                                    }
                                                                                                    else
                                                                                                    {
                                                                                                      return 41;
                                                                                                    }
                                                                                                  }
                                                                                                  else
                                                                                                  {
                                                                                                    return 68;
                                                                                                  }
                                                                                                }
                                                                                                else
                                                                                                {
                                                                                                  return 67;
                                                                                                }
                                                                                              }
                                                                                              else
                                                                                              {
                                                                                                return 66;
                                                                                              }
                                                                                            }
                                                                                            else
                                                                                            {
                                                                                              return 65;
                                                                                            }
                                                                                          }
                                                                                          else
                                                                                          {
                                                                                            return 64;
                                                                                          }
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                          return 63;
                                                                                        }
                                                                                      }
                                                                                      else
                                                                                      {
                                                                                        return 62;
                                                                                      }
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                      return 55;
                                                                                    }
                                                                                  }
                                                                                  else
                                                                                  {
                                                                                    return 51;
                                                                                  }
                                                                                }
                                                                                else
                                                                                {
                                                                                  return 52;
                                                                                }
                                                                              }
                                                                              else
                                                                              {
                                                                                return 50;
                                                                              }
                                                                            }
                                                                            else
                                                                            {
                                                                              return 54;
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            return 56;
                                                                          }
                                                                        }
                                                                        else
                                                                        {
                                                                          return 53;
                                                                        }
                                                                      }
                                                                      else
                                                                      {
                                                                        return 39;
                                                                      }
                                                                    }
                                                                    else
                                                                    {
                                                                      return 38;
                                                                    }
                                                                  }
                                                                  else
                                                                  {
                                                                    return 37;
                                                                  }
                                                                }
                                                                else
                                                                {
                                                                  return 36;
                                                                }
                                                              }
                                                              else
                                                              {
                                                                return 35;
                                                              }
                                                            }
                                                            else
                                                            {
                                                              return 34;
                                                            }
                                                          }
                                                          else
                                                          {
                                                            return 33;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          return 32;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        return 28;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      return 27;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    return 26;
                                                  }
                                                }
                                                else
                                                {
                                                  return 31;
                                                }
                                              }
                                              else
                                              {
                                                return 6;
                                              }
                                            }
                                            else
                                            {
                                              return 2;
                                            }
                                          }
                                          else
                                          {
                                            return 21;
                                          }
                                        }
                                        else
                                        {
                                          return 40;
                                        }
                                      }
                                      else
                                      {
                                        return 22;
                                      }
                                    }
                                    else
                                    {
                                      return 17;
                                    }
                                  }
                                  else
                                  {
                                    return 11;
                                  }
                                }
                                else
                                {
                                  return 25;
                                }
                              }
                              else
                              {
                                return 16;
                              }
                            }
                            else
                            {
                              return 10;
                            }
                          }
                          else
                          {
                            return 3;
                          }
                        }
                        else
                        {
                          return 20;
                        }
                      }
                      else
                      {
                        return 30;
                      }
                    }
                    else
                    {
                      return 24;
                    }
                  }
                  else
                  {
                    return 23;
                  }
                }
                else
                {
                  return 19;
                }
              }
              else
              {
                return 13;
              }
            }
            else
            {
              return 18;
            }
          }
          else
          {
            return 12;
          }
        }
        else
        {
          return 7;
        }
      }
      else
      {
        return 5;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

const char *fi_layer_type_to_name(unsigned int a1)
{
  if (a1 > 0x49) {
    return "[]";
  }
  else {
    return (&off_26456CC38)[a1];
  }
}

uint64_t fi_get_input_data_type(const char *a1)
{
  uint64_t result = cstdlib_strcmp(a1, "InputDataNormal");
  if (result)
  {
    if (cstdlib_strcmp(a1, "InputDataOneHotIndex"))
    {
      if (cstdlib_strcmp(a1, "InputDataSparse")) {
        return 0;
      }
      else {
        return 3;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t fi_layer_if_has_weights(unsigned int a1)
{
  if (a1 > 0x47) {
    return 0;
  }
  else {
    return dword_22078B954[a1];
  }
}

uint64_t fi_layer_free(uint64_t result)
{
  if (result)
  {
    float v1 = *(uint64_t (**)(void))(result + 136);
    if (v1) {
      return v1();
    }
  }
  return result;
}

uint64_t fi_layer_alloc_weights(uint64_t *a1, uint64_t a2, int a3, int a4)
{
  *(_DWORD *)(a2 + 112) = a4;
  *(_DWORD *)(a2 + 116) = 1;
  *(_DWORD *)(a2 + 96) = a3;
  *(_DWORD *)(a2 + 80) = a4 + a3;
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(a1[1] + 16))(a1[2]);
  *(void *)(a2 + 72) = v6;
  if (v6)
  {
    uint64_t v10 = v6;
    uint64_t result = 0;
    *(void *)(a2 + 104) = v10 + *(unsigned int *)(a2 + 96);
    *(void *)(a2 + 88) = v10;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v12);
    return 10;
  }
  return result;
}

void *fi_layer_free_weights(void *result, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 116))
  {
    float v2 = (void *)(a2 + 72);
    if (*(void *)(a2 + 72))
    {
      (*(void (**)(void))(result[1] + 48))(result[2]);
      *float v2 = 0;
    }
    return cstdlib_memset(v2, 0, 0x30uLL);
  }
  return result;
}

uint64_t fi_layer_find_weights_via_offset(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *(void *)(a1 + 72) = a2 + *a3;
  float32x4_t v5 = *(uint64_t (**)(uint64_t))(a1 + 184);
  if (!v5 || (uint64_t result = v5(a1), !result))
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 152))(a1, a1 + 96, a1 + 112);
    if (!result)
    {
      uint64_t v7 = *(unsigned int *)(a1 + 96);
      int v8 = *(_DWORD *)(a1 + 112) + v7;
      *(_DWORD *)(a1 + 80) = v8;
      *(_DWORD *)(a1 + 116) = 0;
      uint64_t v9 = *(void *)(a1 + 72);
      *(void *)(a1 + 104) = v9 + v7;
      *(void *)(a1 + 88) = v9;
      *a3 += v8;
    }
  }
  return result;
}

uint64_t fi_layer_zero_numbers_in_input(uint64_t *a1, float *a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = 0;
  if (a3)
  {
    uint64_t v9 = a3;
    do
    {
      float v10 = *a2++;
      if (v10 == 0.0) {
        ++v8;
      }
      --v9;
    }
    while (v9);
  }
  log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"%s, TOTAL: %d, ZERO: %d, %%: %.2f", a6, a7, a8, a4);
  return 0;
}

uint64_t fi_shape_set(int a1, const void *a2, int a3, _DWORD *a4)
{
  if (!a4) {
    return 7;
  }
  *a4 = a1;
  cstdlib_memcpy(a4 + 1, a2, 0xCuLL);
  uint64_t result = 0;
  a4[4] = a3;
  return result;
}

uint64_t fi_shape_merge(_DWORD *a1, _DWORD *a2)
{
  uint64_t v2 = 7;
  if (a1 && a2)
  {
    if (*a1 == *a2)
    {
      int v3 = a1[4];
      uint64_t v2 = 7;
      if (v3 && v3 == a2[4])
      {
        BOOL v4 = *a1 == 2 && a1[1] == a2[1];
        uint64_t v2 = 0;
        a2[v4 + 1] += a1[v4 + 1];
      }
    }
    else
    {
      return 7;
    }
  }
  return v2;
}

uint64_t fi_shape_dump(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"FI_SHAPE_T(%s): ndim=%d, dims=(%d, %d, %d), elemBytes=%d", a6, a7, a8, a3);
}

void *fi_shape_copy(void *a1, const void *a2)
{
  return cstdlib_memcpy(a1, a2, 0x14uLL);
}

uint64_t fi_shape_get_step(_DWORD *a1)
{
  if (*a1 == 1) {
    return 1;
  }
  else {
    return a1[1];
  }
}

uint64_t fi_shape_get_input_dim(int *a1, int *a2)
{
  int v2 = *a1;
  if (*a1 == 3)
  {
    int v3 = a1[2] * a1[1] * a1[3];
    goto LABEL_7;
  }
  if (v2 == 2)
  {
    int v3 = a1[2];
    goto LABEL_7;
  }
  if (v2 == 1)
  {
    int v3 = a1[1];
LABEL_7:
    uint64_t result = 0;
    *a2 = v3;
    return result;
  }
  return 7;
}

uint64_t fi_shape_get_conv_chw(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  if (*a1 == 2)
  {
    uint64_t result = 0;
    *a3 = a1[1];
    *a4 = a1[2];
    *a2 = 1;
  }
  else if (*a1 == 3)
  {
    uint64_t result = 0;
    *a2 = a1[1];
    *a3 = a1[2];
    *a4 = a1[3];
  }
  else
  {
    return 7;
  }
  return result;
}

uint64_t fi_shape_set_conv2d_chw(_DWORD *a1, int a2, int a3, int a4)
{
  if (*a1 != 3) {
    return 7;
  }
  uint64_t result = 0;
  a1[1] = a2;
  a1[2] = a3;
  a1[3] = a4;
  return result;
}

uint64_t fi_shape_get_channel(_DWORD *a1)
{
  if (*a1 == 3) {
    return a1[1];
  }
  else {
    return 1;
  }
}

uint64_t fi_shape_get_size(int *a1, int *a2)
{
  int v3 = *a1;
  if (*a1 == 3)
  {
    uint64_t result = 0;
    int v5 = a1[2] * a1[1] * a1[3];
  }
  else if (v3 == 2)
  {
    uint64_t result = 0;
    int v5 = a1[2] * a1[1];
  }
  else if (v3 == 1)
  {
    uint64_t result = 0;
    int v5 = a1[1];
  }
  else
  {
    int v5 = 0;
    uint64_t result = 7;
  }
  *a2 = v5;
  return result;
}

uint64_t fi_shape_get_bytes(int *a1, _DWORD *a2)
{
  int v2 = *a1;
  if (*a1 == 3)
  {
    int v3 = a1[2] * a1[1] * a1[3];
  }
  else if (v2 == 2)
  {
    int v3 = a1[2] * a1[1];
  }
  else
  {
    if (v2 != 1) {
      return 7;
    }
    int v3 = a1[1];
  }
  uint64_t v4 = 0;
  *a2 = a1[4] * v3;
  return v4;
}

uint64_t fi_shape_is_same(unsigned int *a1, _DWORD *a2)
{
  uint64_t v2 = *a1;
  if (v2 == *a2 && a1[4] == a2[4])
  {
    if (!v2) {
      return 1;
    }
    int v3 = (int *)(a1 + 1);
    uint64_t v4 = a2 + 1;
    while (1)
    {
      int v6 = *v3++;
      int v5 = v6;
      int v7 = *v4++;
      if (v5 != v7) {
        break;
      }
      if (!--v2) {
        return 1;
      }
    }
  }
  return 0;
}

uint64_t transpose_and_order(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  unsigned int v7 = a1;
  int padded_len = get_padded_len(a1, 8u);
  unsigned int v9 = 0;
  unsigned int v10 = 0;
  if (v7 >= 4 && a2 >= 4)
  {
    unsigned int v10 = 0;
    unsigned int v9 = 0;
    int v11 = 2 * padded_len;
    unint64_t v12 = a2 & 0xFFFFFFFC;
    int v13 = 3 * padded_len;
    do
    {
      if (v12)
      {
        unint64_t v14 = 0;
        unsigned int v15 = v9;
        do
        {
          *(_DWORD *)(a4 + 4 * v10) = *(_DWORD *)(a3 + 4 * v15);
          *(_DWORD *)(a4 + 4 * (v10 + 1)) = *(_DWORD *)(a3 + 4 * (padded_len + v15));
          *(_DWORD *)(a4 + 4 * (v10 + 2)) = *(_DWORD *)(a3 + 4 * (v11 + v15));
          *(_DWORD *)(a4 + 4 * (v10 + 3)) = *(_DWORD *)(a3 + 4 * (v13 + v15));
          *(_DWORD *)(a4 + 4 * (v10 + 4)) = *(_DWORD *)(a3 + 4 * (v15 + 1));
          *(_DWORD *)(a4 + 4 * (v10 + 5)) = *(_DWORD *)(a3 + 4 * (padded_len + v15 + 1));
          *(_DWORD *)(a4 + 4 * (v10 + 6)) = *(_DWORD *)(a3 + 4 * (v11 + v15 + 1));
          *(_DWORD *)(a4 + 4 * (v10 + 7)) = *(_DWORD *)(a3 + 4 * (v13 + v15 + 1));
          *(_DWORD *)(a4 + 4 * (v10 + 8)) = *(_DWORD *)(a3 + 4 * (v15 + 2));
          *(_DWORD *)(a4 + 4 * (v10 + 9)) = *(_DWORD *)(a3 + 4 * (padded_len + v15 + 2));
          *(_DWORD *)(a4 + 4 * (v10 + 10)) = *(_DWORD *)(a3 + 4 * (v11 + v15 + 2));
          *(_DWORD *)(a4 + 4 * (v10 + 11)) = *(_DWORD *)(a3 + 4 * (v13 + v15 + 2));
          *(_DWORD *)(a4 + 4 * (v10 + 12)) = *(_DWORD *)(a3 + 4 * (v15 + 3));
          *(_DWORD *)(a4 + 4 * (v10 + 13)) = *(_DWORD *)(a3 + 4 * (padded_len + v15 + 3));
          *(_DWORD *)(a4 + 4 * (v10 + 14)) = *(_DWORD *)(a3 + 4 * (v11 + v15 + 3));
          *(_DWORD *)(a4 + 4 * (v10 + 15)) = *(_DWORD *)(a3 + 4 * (v13 + v15 + 3));
          v10 += 16;
          v14 += 4;
          v15 += 4 * padded_len;
        }
        while (v14 < v12);
      }
      else
      {
        LODWORD(v14) = 0;
      }
      if (v14 < a2)
      {
        unsigned int v16 = v9 + padded_len * v14;
        unint64_t v17 = a2 - (unint64_t)v14;
        do
        {
          *(_DWORD *)(a4 + 4 * v10) = *(_DWORD *)(a3 + 4 * v16);
          *(_DWORD *)(a4 + 4 * (v10 + 1)) = *(_DWORD *)(a3 + 4 * (v16 + 1));
          *(_DWORD *)(a4 + 4 * (v10 + 2)) = *(_DWORD *)(a3 + 4 * (v16 + 2));
          *(_DWORD *)(a4 + 4 * (v10 + 3)) = *(_DWORD *)(a3 + 4 * (v16 + 3));
          v10 += 4;
          v16 += padded_len;
          --v17;
        }
        while (v17);
      }
      v9 += 4;
    }
    while (v9 < (v7 & 0xFFFFFFFC));
  }
  if (v9 < v7)
  {
    do
    {
      if (a2)
      {
        uint64_t v18 = a2;
        unsigned int v19 = v9;
        do
        {
          *(_DWORD *)(a4 + 4 * v10++) = *(_DWORD *)(a3 + 4 * v19);
          v19 += padded_len;
          --v18;
        }
        while (v18);
      }
      ++v9;
    }
    while (v9 != v7);
  }
  return 0;
}

uint64_t transpose_b(uint64_t result, unsigned int a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    unsigned int v4 = 0;
    unsigned int v5 = 0;
    do
    {
      if (a2)
      {
        uint64_t v6 = a2;
        unsigned int v7 = v5;
        unsigned int v8 = v4;
        do
        {
          *(_DWORD *)(a4 + 4 * v8++) = *(_DWORD *)(a3 + 4 * v7);
          v7 += result;
          --v6;
        }
        while (v6);
      }
      ++v5;
      v4 += a2;
    }
    while (v5 != result);
  }
  return result;
}

uint64_t add_timing_signal_1d(uint64_t *a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6, uint64_t *a7)
{
  double v15 = log((float)((float)a5 / (float)a4));
  uint64_t v16 = *a7;
  if (v16)
  {
    unsigned int v17 = a6 + a2;
    if (v17 > a6)
    {
      unsigned int v18 = a3 >> 1;
      float v19 = -v15 / ((float)(a3 >> 1) + -1.0);
      if (a3 >> 1 <= 1) {
        uint64_t v20 = 1;
      }
      else {
        uint64_t v20 = v18;
      }
      uint64_t v21 = 4 * (a3 >> 1) + 4 * ((a3 >> 1) + (a3 & 1));
      uint64_t v22 = v16 + 4 * v18;
      do
      {
        if (a3 >= 2)
        {
          uint64_t v23 = 0;
          float v24 = (float)a6;
          do
          {
            float v25 = exp((float)(v19 * (float)v23));
            *(float *)(v16 + 4 * v23) = sinf(v24 * v25) + *(float *)(v16 + 4 * v23);
            ++v23;
          }
          while (v20 != v23);
          uint64_t v26 = 0;
          do
          {
            float v27 = exp((float)(v19 * (float)v26));
            *(float *)(v22 + 4 * v26) = cosf(v24 * v27) + *(float *)(v22 + 4 * v26);
            ++v26;
          }
          while (v20 != v26);
        }
        ++a6;
        v16 += v21;
        v22 += v21;
      }
      while (a6 != v17);
    }
    return 0;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"output buffer for positional encoding cannot be NULL!", v12, v13, v14, v29);
    return 10;
  }
}

uint64_t fi_get_activation(const char *a1)
{
  uint64_t result = cstdlib_strcmp(a1, "linear");
  if (result)
  {
    if (cstdlib_strcmp(a1, "sigmoid"))
    {
      if (cstdlib_strcmp(a1, "hardsigmoid"))
      {
        if (cstdlib_strcmp(a1, "tanh"))
        {
          if (cstdlib_strcmp(a1, "relu"))
          {
            if (cstdlib_strcmp(a1, "elu"))
            {
              if (cstdlib_strcmp(a1, "leaky"))
              {
                if (cstdlib_strcmp(a1, "softsign"))
                {
                  if (cstdlib_strcmp(a1, "softmax"))
                  {
                    if (cstdlib_strcmp(a1, "softplus"))
                    {
                      if (cstdlib_strcmp(a1, "tanh_approx"))
                      {
                        if (cstdlib_strcmp(a1, "sigmoid_approx"))
                        {
                          if (cstdlib_strcmp(a1, "gelu"))
                          {
                            if (cstdlib_strcmp(a1, "leaky_dot_two"))
                            {
                              if (cstdlib_strcmp(a1, "leaky_dot_two_inverse")) {
                                return 3;
                              }
                              else {
                                return 14;
                              }
                            }
                            else
                            {
                              return 13;
                            }
                          }
                          else
                          {
                            return 12;
                          }
                        }
                        else
                        {
                          return 11;
                        }
                      }
                      else
                      {
                        return 10;
                      }
                    }
                    else
                    {
                      return 8;
                    }
                  }
                  else
                  {
                    return 9;
                  }
                }
                else
                {
                  return 7;
                }
              }
              else
              {
                return 5;
              }
            }
            else
            {
              return 4;
            }
          }
          else
          {
            return 3;
          }
        }
        else
        {
          return 2;
        }
      }
      else
      {
        return 6;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void fi_activate_array(float *a1, uint64_t a2, int a3)
{
  unsigned int v4 = a1;
  switch(a3)
  {
    case 0:
      return;
    case 1:
      sigmoid(a1, a2, a1);
      break;
    case 2:
      fast_tanh(a1, a2, a1);
      break;
    case 3:
      relu_array_f32(a2, a1);
      break;
    case 7:
      softsign_array_f32(a2, a1);
      break;
    case 9:
      softmax(a1, a2, 1, a1, 1.0);
      break;
    case 10:
      fast_tanh_approx(a1, a2, a1);
      break;
    case 11:
      sigmoid_approx(a1, a2, a1);
      break;
    case 12:
      gelu_array_f32(a2, a1);
      break;
    case 13:
      float v7 = 0.2;
      goto LABEL_32;
    case 14:
      float v7 = 5.0;
LABEL_32:
      leaky_array_f32(a2, a1, v7);
      break;
    default:
      if (a2)
      {
        uint64_t v5 = a2;
        do
        {
          activate(a3, *v4);
          *(_DWORD *)v4++ = v6;
          --v5;
        }
        while (v5);
      }
      break;
  }
}

void activate(int a1, float a2)
{
  switch(a1)
  {
    case 1:
    case 11:
      exp_fdlibm((float)-a2);
      break;
    case 2:
    case 10:
      if (a2 <= 350.0) {
        exp_fdlibm((float)(a2 + a2));
      }
      break;
    case 4:
      if (a2 < 0.0) {
        exp_fdlibm(a2);
      }
      break;
    case 7:
      fabs_fdlibm(a2);
      break;
    case 8:
      double v2 = exp_fdlibm(a2);
      log_fdlibm(v2 + 1.0);
      break;
    case 12:
      float v3 = (float)((float)((float)(a2 * 0.035677) * a2) * a2) + (float)(a2 * 0.79789);
      if (v3 <= 350.0) {
        exp_fdlibm((float)(v3 + v3));
      }
      break;
    default:
      return;
  }
}

uint64_t fi_activate_array_s8(uint64_t result, char *a2, unsigned int a3, int a4)
{
  if (a3)
  {
    int v6 = (float *)result;
    uint64_t v7 = a3;
    do
    {
      float v8 = s8_to_f32(*a2, *v6, v6[1]);
      activate(a4, v8);
      uint64_t result = f32_to_s8(v9, *v6, v6[1]);
      *a2++ = result;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t fi_activate_array_s16(uint64_t result, __int16 *a2, unsigned int a3, int a4)
{
  if (a3)
  {
    int v6 = (float *)result;
    uint64_t v7 = a3;
    do
    {
      float v8 = s16_to_f32(*a2, *v6, v6[1]);
      activate(a4, v8);
      uint64_t result = f32_to_s16(v9, *v6, v6[1]);
      *a2++ = result;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t alloc_aligned_mem(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (!a3) {
    return 0;
  }
  if (-8 - a2 < a3) {
    return 0;
  }
  uint64_t result = heap_Alloc(a1, a2 + a3 + 7);
  if (result)
  {
    uint64_t v5 = result;
    result += 8 + ((((a2 - 1) & ~(result + 8)) + 1) & (a2 - 1));
    *(void *)(result - 8) = v5;
  }
  return result;
}

void *calloc_aligned_mem(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  size_t v4 = a4 * a3;
  uint64_t v5 = (void *)alloc_aligned_mem(a1, a2, a4 * a3);
  int v6 = v5;
  if (v5) {
    cstdlib_memset(v5, 0, v4);
  }
  return v6;
}

uint64_t realloc_aligned_mem(uint64_t *a1, uint64_t a2, uint64_t a3, size_t a4)
{
  if (!a4) {
    return 0;
  }
  uint64_t v6 = a2;
  if (a2)
  {
    if (-8 - a3 >= a4)
    {
      uint64_t v7 = *(void *)(a2 - 8);
      uint64_t v8 = heap_Realloc(a1, v7, a3 + a4 + 7);
      if (v8)
      {
        uint64_t v9 = v8;
        if (v8 != v7)
        {
          uint64_t v10 = v6 - v7;
          uint64_t v11 = ((((a3 - 1) & ~(v8 + 8)) + 1) & (a3 - 1)) + 8;
          uint64_t v6 = v8 + v11;
          if (v11 != v10) {
            cstdlib_memmove((void *)(v8 + v11), (const void *)(v8 + v10), a4);
          }
          *(void *)(v6 - 8) = v9;
        }
        return v6;
      }
    }
    return 0;
  }

  return alloc_aligned_mem((uint64_t)a1, a3, a4);
}

void *free_aligned_mem(void *result, uint64_t a2)
{
  if (a2) {
    return heap_Free(result, *(void *)(a2 - 8));
  }
  return result;
}

uint64_t alloc_aligned_32_mem(uint64_t a1, unint64_t a2)
{
  return alloc_aligned_mem(a1, 32, a2);
}

uint64_t realloc_aligned_32_mem(uint64_t *a1, uint64_t a2, size_t a3)
{
  return realloc_aligned_mem(a1, a2, 32, a3);
}

void *calloc_aligned_32_mem(uint64_t a1, uint64_t a2, uint64_t a3)
{
  size_t v3 = a3 * a2;
  size_t v4 = (void *)alloc_aligned_mem(a1, 32, a3 * a2);
  uint64_t v5 = v4;
  if (v4) {
    cstdlib_memset(v4, 0, v3);
  }
  return v5;
}

void *free_mem(void *result, uint64_t a2)
{
  if (a2) {
    return heap_Free(result, a2);
  }
  return result;
}

BOOL fi_version_cmp(uint64_t a1, int *a2, char *__s)
{
  uint64_t v23 = 0;
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = **(uint64_t (***)(uint64_t, size_t))(a1 + 8);
  size_t v8 = cstdlib_strlen(__s);
  uint64_t v9 = (char *)v7(v6, v8 + 1);
  if (v9)
  {
    uint64_t v13 = v9;
    cstdlib_strcpy(v9, __s);
    uint64_t v14 = (unsigned __int8 *)extstdlib_strtok_r(v13, ".", &v23);
    int v15 = *a2;
    if (v15 == cstdlib_atoi(v14)
      && (uint64_t v16 = (unsigned __int8 *)extstdlib_strtok_r(0, ".", &v23),
          int v17 = a2[1],
          v17 == cstdlib_atoi(v16)))
    {
      unsigned int v18 = (unsigned __int8 *)extstdlib_strtok_r(0, ".", &v23);
      int v19 = a2[2];
      BOOL v20 = v19 == cstdlib_atoi(v18);
    }
    else
    {
      BOOL v20 = 0;
    }
    (*(void (**)(void, char *))(*(void *)(a1 + 8) + 48))(*(void *)(a1 + 16), v13);
  }
  else
  {
    log_OutText(*(void *)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v22);
    return 0;
  }
  return v20;
}

uint64_t fi_version_cfg(uint64_t *a1, uint64_t a2)
{
  size_t v4 = (int *)(a2 + 12);
  if (fi_version_cmp((uint64_t)a1, (int *)(a2 + 12), "0.0.0"))
  {
    uint64_t result = 0;
    *(void *)(a2 + 32) = 0;
    *(_DWORD *)(a2 + 24) = 0;
  }
  else
  {
    uint64_t result = fi_alloc_version_feature_gates(a1, a2);
    if (!result)
    {
      if (fi_version_cmp((uint64_t)a1, v4, "1.0.0"))
      {
        uint64_t result = 0;
        **(_DWORD **)(a2 + 32) = 1;
      }
      else if (fi_version_cmp((uint64_t)a1, v4, "1.1.0"))
      {
        uint64_t result = 0;
        uint64_t v6 = *(void *)(a2 + 32);
        *(void *)&long long v7 = 0x100000001;
        *((void *)&v7 + 1) = 0x100000001;
        *(_OWORD *)uint64_t v6 = v7;
        *(void *)(v6 + 16) = 0x100000001;
        *(_DWORD *)(v6 + 24) = 1;
      }
      else if (fi_version_cmp((uint64_t)a1, v4, "1.1.1"))
      {
        uint64_t result = 0;
        size_t v8 = *(_OWORD **)(a2 + 32);
        *(void *)&long long v9 = 0x100000001;
        *((void *)&v9 + 1) = 0x100000001;
        *size_t v8 = v9;
        v8[1] = v9;
      }
      else if (fi_version_cmp((uint64_t)a1, v4, "1.2.0"))
      {
        uint64_t result = 0;
        uint64_t v10 = *(void *)(a2 + 32);
        *(void *)&long long v11 = 0x100000001;
        *((void *)&v11 + 1) = 0x100000001;
        *(_OWORD *)uint64_t v10 = v11;
        *(_OWORD *)(v10 + 16) = v11;
        *(_DWORD *)(v10 + 32) = 1;
      }
      else
      {
        return 7;
      }
    }
  }
  return result;
}

uint64_t fi_alloc_version_feature_gates(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 9, 4);
  *(void *)(a2 + 32) = v4;
  if (v4)
  {
    uint64_t result = 0;
    *(_DWORD *)(a2 + 24) = 9;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v5, v6, v7, v9);
    return 10;
  }
  return result;
}

BOOL fi_feat_is_enabled(uint64_t a1, unsigned int a2, unsigned int a3)
{
  BOOL result = 0;
  if (a1)
  {
    if (a2 < a3) {
      return *(_DWORD *)(a1 + 4 * a2) == 1;
    }
  }
  return result;
}

BOOL fi_feat_is_enabled_or_value_specified(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a1 + 32);
  if (a3)
  {
    if (!v10)
    {
      if (fi_alloc_version_feature_gates(*(uint64_t **)a1, a1)) {
        return 0;
      }
      uint64_t v10 = *(void *)(a1 + 32);
    }
    if (!*(_DWORD *)(v10 + 4 * a2))
    {
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"Enabling feature gate %d during packing because a non-default value was specified\n", a6, a7, a8, a2);
      uint64_t v10 = *(void *)(a1 + 32);
    }
    *(_DWORD *)(v10 + 4 * a2) = 1;
  }
  if (v10) {
    BOOL v11 = *(_DWORD *)(a1 + 24) > a2;
  }
  else {
    BOOL v11 = 0;
  }
  if (v11) {
    return *(_DWORD *)(v10 + 4 * a2) == 1;
  }
  return 0;
}

uint64_t get_mat_length(int *a1)
{
  if (a1) {
    int v1 = *a1;
  }
  else {
    int v1 = 0;
  }
  return get_weight_length(a1) + v1;
}

uint64_t get_weight_length(_DWORD *a1)
{
  if (!a1)
  {
    int padded_len = get_padded_len(0, 8u);
    int v6 = 0;
    return (v6 * padded_len);
  }
  int v2 = a1[1];
  if ((v2 & 8) != 0) {
    unsigned int v3 = 32;
  }
  else {
    unsigned int v3 = 8;
  }
  if (v2)
  {
    int v8 = a1[2];
    if ((v2 & 2) != 0)
    {
      uint64_t v11 = get_padded_len(a1[4], 8u);
      return get_bsr_data_len(v8, v11);
    }
    else
    {
      uint64_t v9 = a1[5];
      int v10 = a1[2];
      return get_bsc_data_len(v10, v9);
    }
  }
  else
  {
    if ((v2 & 2) == 0)
    {
      int padded_len = get_padded_len(a1[4], v3);
      int v6 = a1[5];
      return (v6 * padded_len);
    }
    int v4 = a1[4];
    return get_padded_len(a1[5], v3) * v4;
  }
}

uint64_t fi_net_init(uint64_t *a1, uint64_t ***a2)
{
  uint64_t v7 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 200);
  if (v7)
  {
    uint64_t result = 0;
    float *v7 = a1;
    v7[24] = (uint64_t *)12345;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"alloc pNet failed!", v4, v5, v6, v9);
    uint64_t result = 10;
  }
  *a2 = v7;
  return result;
}

uint64_t fi_net_layers_init(uint64_t **a1)
{
  if (!a1) {
    return 7;
  }
  uint64_t v2 = *((unsigned int *)a1 + 2);
  if (!v2) {
    return 7;
  }
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))((*a1)[1] + 16))((*a1)[2], v2, 8);
  a1[14] = (uint64_t *)v3;
  if (v3) {
    return 0;
  }
  log_OutText(**a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"alloc pNet->layers failed!", v4, v5, v6, v8);
  return 10;
}

uint64_t fi_net_destroy(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)result;
    if (*(void *)(result + 112))
    {
      if (!*(_DWORD *)(result + 8)) {
        goto LABEL_7;
      }
      unint64_t v3 = 0;
      do
      {
        fi_layer_free(*(void *)(*(void *)(v1 + 112) + 8 * v3));
        *(void *)(*(void *)(v1 + 112) + 8 * v3++) = 0;
      }
      while (v3 < *(unsigned int *)(v1 + 8));
      if (*(void *)(v1 + 112))
      {
LABEL_7:
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        *(void *)(v1 + 112) = 0;
      }
    }
    if (*(void *)(v1 + 144))
    {
      (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
      *(void *)(v1 + 144) = 0;
    }
    *(_DWORD *)(v1 + 152) = 0;
    if (*(void *)(v1 + 160))
    {
      (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
      *(void *)(v1 + 160) = 0;
    }
    *(_DWORD *)(v1 + 168) = 0;
    if (*(void *)(v1 + 128))
    {
      (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
      *(void *)(v1 + 128) = 0;
    }
    *(_DWORD *)(v1 + 136) = 0;
    uint64_t v4 = *(void *)(v2 + 16);
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v2 + 8) + 48);
    return v5(v4, v1);
  }
  return result;
}

uint64_t fi_net_predict(uint64_t **a1, const void **a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return fi_net_predict_ex(a1, a2, a3, a4, 0, 0, 1, a8);
}

uint64_t fi_net_predict_ex(uint64_t **a1, const void **a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 7;
  if (a1 && a2 && a4)
  {
    char v11 = a7;
    a1[22] = (uint64_t *)a5;
    a1[23] = (uint64_t *)a6;
    uint64_t updated = fi_net_update_shape(a1, a3, a3, (uint64_t)a4, a5, a6, a7, a8);
    if (updated)
    {
      uint64_t v8 = updated;
      uint64_t v21 = **a1;
      uint64_t v22 = "fi net update shape failed!";
    }
    else
    {
      uint64_t v23 = fi_net_validate_weights_length(a1, v14, v15, v16, v17, v18, v19, v20);
      if (v23)
      {
        uint64_t v8 = v23;
        uint64_t v21 = **a1;
        uint64_t v22 = "fi net weights invalid!";
      }
      else
      {
        uint64_t glbIn = fi_net_allocate_glbIn((uint64_t)a1);
        if (glbIn)
        {
          uint64_t v8 = glbIn;
          uint64_t v21 = **a1;
          uint64_t v22 = "fi net allocate glbIn failed!";
        }
        else
        {
          uint64_t v25 = fi_net_copy_indata_to_glbIn_then_free((uint64_t)a1, a2);
          if (v25)
          {
            uint64_t v8 = v25;
            uint64_t v21 = **a1;
            uint64_t v22 = "input data copy to aligned memory and free failed!";
          }
          else
          {
            if (v11)
            {
              if (*a2) {
                (*(void (**)(uint64_t))((*a1)[1] + 80))((*a1)[2]);
              }
              *a2 = 0;
            }
            uint64_t v8 = fi_net_forward(a1);
            if (!v8)
            {
              *a4 = a1[18];
              return v8;
            }
            uint64_t v21 = **a1;
            uint64_t v22 = "fi net do forward failed!";
          }
        }
      }
    }
    log_OutText(v21, (uint64_t)"FastInfer", 0, 0, (uint64_t)v22, v18, v19, v20, v27);
  }
  return v8;
}

uint64_t fi_net_predict_notfree_input(uint64_t **a1, const void **a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 7;
  if (a1 && a2 && a4)
  {
    uint64_t updated = fi_net_update_shape(a1, a3, a3, (uint64_t)a4, a5, a6, a7, a8);
    if (updated)
    {
      uint64_t v8 = updated;
      uint64_t v20 = **a1;
      uint64_t v21 = "fi net update shape failed!";
    }
    else
    {
      uint64_t v22 = fi_net_validate_weights_length(a1, v13, v14, v15, v16, v17, v18, v19);
      if (v22)
      {
        uint64_t v8 = v22;
        uint64_t v20 = **a1;
        uint64_t v21 = "fi net weights invalid!";
      }
      else
      {
        uint64_t glbIn = fi_net_allocate_glbIn((uint64_t)a1);
        if (glbIn)
        {
          uint64_t v8 = glbIn;
          uint64_t v20 = **a1;
          uint64_t v21 = "fi net allocate glbIn failed!";
        }
        else
        {
          uint64_t v24 = fi_net_copy_indata_to_glbIn_then_free((uint64_t)a1, a2);
          if (v24)
          {
            uint64_t v8 = v24;
            uint64_t v20 = **a1;
            uint64_t v21 = "input data copy to aligned memory and free failed!";
          }
          else
          {
            uint64_t v8 = fi_net_forward(a1);
            if (!v8)
            {
              *a4 = a1[18];
              return v8;
            }
            uint64_t v20 = **a1;
            uint64_t v21 = "fi net do forward failed!";
          }
        }
      }
    }
    log_OutText(v20, (uint64_t)"FastInfer", 0, 0, (uint64_t)v21, v17, v18, v19, v26);
  }
  return v8;
}

uint64_t fi_net_update_shape(uint64_t **__src, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = (char *)__src + 52;
  if (*((_DWORD *)__src + 13)) {
    cstdlib_memcpy(__src + 9, v10, 0x14uLL);
  }
  else {
    log_OutText(**__src, (uint64_t)"FastInfer", 4, 0, (uint64_t)"it seems no [input] for this network,pNet->inshape won't be set by pNet->netCfg.model_inshapemake sure you set pNet->inshape correctly!", a6, a7, a8, v33);
  }
  uint64_t step = fi_shape_get_step(v10);
  if (step)
  {
    if (step != a2)
    {
      log_OutText(**__src, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Error: input data step mismatch! model step= %d, input data step= %d", v12, v13, v14, step);
      log_OutText(**__src, (uint64_t)"FastInfer", 0, 0, (uint64_t)"fi_net_validate_and_update_network_inshape failed!", v15, v16, v17, v34);
      return 7;
    }
  }
  else
  {
    log_OutText(**__src, (uint64_t)"FastInfer", 4, 0, (uint64_t)"data step changes from %d to %d", v12, v13, v14, 0);
    *((_DWORD *)__src + 19) = a2;
  }
  if (!*((_DWORD *)__src + 2)) {
    goto LABEL_17;
  }
  unint64_t v19 = 0;
  uint64_t v20 = (char *)(__src + 9);
  do
  {
    uint64_t v21 = __src[14][v19];
    cstdlib_memset((void *)(v21 + 20), 0, 0x14uLL);
    cstdlib_memset((void *)(v21 + 40), 0, 0x14uLL);
    *(_DWORD *)(v21 + 36) = 4;
    *(_DWORD *)(v21 + 56) = 4;
    uint64_t v22 = *(uint64_t (**)(uint64_t, char *))(v21 + 144);
    if (v22)
    {
      uint64_t v23 = v22(v21, v20);
      if (v23)
      {
        uint64_t v18 = v23;
        uint64_t v27 = **__src;
        float v28 = fi_layer_type_to_name(*(_DWORD *)(v21 + 8));
        log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)"update shape of %s layer failed!", v29, v30, v31, (uint64_t)v28);
        return v18;
      }
    }
    else
    {
      cstdlib_memcpy((void *)(v21 + 20), v20, 0x14uLL);
      cstdlib_memcpy((void *)(v21 + 40), v20, 0x14uLL);
    }
    ++v19;
    unint64_t v24 = *((unsigned int *)__src + 2);
    uint64_t v20 = (char *)(v21 + 40);
  }
  while (v19 < v24);
  if (v24)
  {
    uint64_t v25 = (char *)__src + 92;
    uint64_t v26 = (char *)(__src[14][(v24 - 1)] + 40);
  }
  else
  {
LABEL_17:
    uint64_t v25 = (char *)__src + 92;
    uint64_t v26 = (char *)(__src + 9);
  }
  cstdlib_memcpy(v25, v26, 0x14uLL);
  return 0;
}

uint64_t fi_net_validate_weights_length(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v32 = 0;
  log_OutText(**a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Validate weights and biases length of all layers ...", a6, a7, a8, v30);
  unint64_t v12 = *((unsigned int *)a1 + 2);
  if (!v12)
  {
LABEL_11:
    log_OutText(**a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Validate weights and biases length of all layers Done!", v9, v10, v11, v31);
    return 0;
  }
  uint64_t v13 = 0;
  while (1)
  {
    uint64_t v14 = a1[14][v13];
    if (!*(void *)(v14 + 152)) {
      goto LABEL_10;
    }
    uint64_t v15 = **a1;
    uint64_t v16 = fi_layer_type_to_name(*(_DWORD *)(v14 + 8));
    log_OutText(v15, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Validate layer %s ...", v17, v18, v19, (uint64_t)v16);
    uint64_t v20 = *(uint64_t (**)(uint64_t))(v14 + 184);
    if (v20)
    {
      uint64_t v21 = v20(v14);
      if (v21) {
        break;
      }
    }
    uint64_t v22 = (*(uint64_t (**)(uint64_t, char *, uint64_t *))(v14 + 152))(v14, (char *)&v32 + 4, &v32);
    if (v22)
    {
      uint64_t v24 = v22;
      uint64_t v25 = **a1;
      uint64_t v26 = "Get wanted weight and biases length failed!";
      goto LABEL_17;
    }
    uint64_t v23 = *(unsigned int *)(v14 + 96);
    if (HIDWORD(v32) != v23)
    {
      uint64_t v27 = **(void **)v14;
      float v28 = "weights length in model: %d Bytes, but wanted: %d Bytes";
LABEL_15:
      log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v9, v10, v11, v23);
      return 7;
    }
    uint64_t v23 = *(unsigned int *)(v14 + 112);
    if (v32 != v23)
    {
      uint64_t v27 = **(void **)v14;
      float v28 = "biases length in model: %d Bytes, but wanted: %d Bytes";
      goto LABEL_15;
    }
    unint64_t v12 = *((unsigned int *)a1 + 2);
LABEL_10:
    if (++v13 >= v12) {
      goto LABEL_11;
    }
  }
  uint64_t v24 = v21;
  uint64_t v25 = **a1;
  uint64_t v26 = "dispatching weights for layer %d failed!";
  uint64_t v31 = v13;
LABEL_17:
  log_OutText(v25, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v9, v10, v11, v31);
  return v24;
}

uint64_t fi_net_allocate_glbIn(uint64_t a1)
{
  unsigned int v8 = 0;
  if (!a1) {
    return 7;
  }
  uint64_t bytes = fi_shape_get_bytes((int *)(a1 + 72), &v8);
  if (!bytes)
  {
    uint64_t bytes = maybe_enlarge_array(*(uint64_t **)a1, (uint64_t *)(a1 + 160), (unsigned int *)(a1 + 168), v8);
    if (bytes) {
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"enlarge pNet->glbIn failed!", v3, v4, v5, v7);
    }
    else {
      cstdlib_memset(*(void **)(a1 + 160), 0, *(unsigned int *)(a1 + 168));
    }
  }
  return bytes;
}

uint64_t fi_net_copy_indata_to_glbIn_then_free(uint64_t a1, const void **a2)
{
  LODWORD(__n) = 0;
  uint64_t v3 = *a2;
  uint64_t bytes = fi_shape_get_bytes((int *)(a1 + 72), &__n);
  if (bytes != 7) {
    cstdlib_memcpy(*(void **)(a1 + 160), v3, __n);
  }
  return bytes;
}

uint64_t fi_net_forward(uint64_t **a1)
{
  long long v36 = 0u;
  long long v37 = 0u;
  if (!a1 || !a1[20]) {
    return 7;
  }
  *((void *)&v36 + 1) = a1[15];
  DWORD2(v37) = *((_DWORD *)a1 + 49);
  if (!*((_DWORD *)a1 + 2)) {
    return 0;
  }
  unint64_t v2 = 0;
  uint64_t v34 = a1 + 5;
  uint64_t v35 = (uint64_t *)(a1 + 18);
  while (1)
  {
    uint64_t v3 = a1[14][v2];
    LODWORD(v36) = v2;
    *(void *)&long long v37 = 1;
    unsigned int v38 = 0;
    uint64_t bytes = fi_shape_get_bytes((int *)(v3 + 40), &v38);
    if (bytes) {
      return bytes;
    }
    uint64_t v5 = maybe_enlarge_array(*a1, v35, (unsigned int *)a1 + 38, v38);
    if (v5)
    {
      uint64_t v27 = v5;
      uint64_t v28 = **a1;
      uint64_t v29 = "enlarge pNet->glbOut failed!";
      goto LABEL_38;
    }
    uint64_t v9 = *(uint64_t (**)(uint64_t))(v3 + 160);
    if (v9)
    {
      uint64_t v10 = v9(v3);
      if (v10)
      {
        uint64_t v27 = v10;
        uint64_t v30 = **a1;
        uint64_t v31 = fi_layer_type_to_name(*(_DWORD *)(v3 + 8));
        uint64_t v29 = "request global buffer failed for layer %s!";
        goto LABEL_37;
      }
    }
    uint64_t v11 = maybe_enlarge_array(*a1, (uint64_t *)a1 + 16, (unsigned int *)a1 + 34, *(_DWORD *)(v3 + 248));
    if (v11)
    {
      uint64_t v27 = v11;
      uint64_t v28 = **a1;
      uint64_t v29 = "enlarge global buffer failed!";
      goto LABEL_38;
    }
    *(void *)(v3 + 240) = a1[16];
    *(_DWORD *)(v3 + 248) = *((_DWORD *)a1 + 34);
    unint64_t v12 = *(uint64_t (**)(uint64_t))(v3 + 168);
    if (v12)
    {
      uint64_t v13 = v12(v3);
      if (v13) {
        break;
      }
    }
    uint64_t v14 = (*(uint64_t (**)(uint64_t **, uint64_t, uint64_t *, uint64_t *, long long *))(v3 + 128))(v34, v3, a1[20], a1[18], &v36);
    if (v14)
    {
      uint64_t v27 = v14;
      uint64_t v30 = **a1;
      uint64_t v31 = fi_layer_type_to_name(*(_DWORD *)(v3 + 8));
      uint64_t v29 = "forward %s layer failed!";
      goto LABEL_37;
    }
    if (DWORD1(v37) == 1)
    {
      uint64_t bytes = fi_net_update_shape_from_layer(a1, v2, v15, v16, v17, v18, v19, v20);
      if (bytes) {
        return bytes;
      }
    }
    unint64_t v21 = (*((_DWORD *)a1 + 2) - 1);
    if (v37)
    {
      if (v2 >= v21) {
        goto LABEL_18;
      }
LABEL_17:
      uint64_t v22 = a1[20];
      a1[20] = a1[18];
      a1[18] = v22;
      LODWORD(v22) = *((_DWORD *)a1 + 42);
      *((_DWORD *)a1 + 42) = *((_DWORD *)a1 + 38);
      *((_DWORD *)a1 + 38) = v22;
      goto LABEL_18;
    }
    if (v2 == v21) {
      goto LABEL_17;
    }
LABEL_18:
    uint64_t v23 = 20;
    if (v2 >= v21) {
      uint64_t v23 = 18;
    }
    uint64_t v24 = a1[22];
    if (v24)
    {
      if (*(_DWORD *)(v3 + 8) == 26)
      {
        uint64_t v25 = a1[v23];
        uint64_t v26 = *(void *)(v3 + 120);
        if (((unsigned int (*)(uint64_t *, uint64_t, uint64_t *, uint64_t))v24)(a1[23], v26, v25, v3 + 40))
        {
          unsigned int v38 = 0;
          uint64_t bytes = fi_shape_get_size((int *)(v3 + 40), (int *)&v38);
          if (bytes) {
            return bytes;
          }
          cstdlib_memcpy(*(void **)(v26 + 80), v25, *(_DWORD *)(v3 + 56) * v38);
        }
      }
    }
    if (++v2 >= *((unsigned int *)a1 + 2)) {
      return 0;
    }
  }
  uint64_t v27 = v13;
  uint64_t v30 = **a1;
  uint64_t v31 = fi_layer_type_to_name(*(_DWORD *)(v3 + 8));
  uint64_t v29 = "assign sublayer global buffer failed for layer %s!";
LABEL_37:
  uint64_t v33 = (uint64_t)v31;
  uint64_t v28 = v30;
LABEL_38:
  log_OutText(v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)v29, v6, v7, v8, v33);
  return v27;
}

uint64_t fi_net_update_shape_from_layer(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = *((_DWORD *)a1 + 2);
  if (v9 <= a2)
  {
    log_OutText(**a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"invalid layer_i: %d!", a6, a7, a8, a2);
    return 7;
  }
  else
  {
    unint64_t v10 = 0;
    unint64_t v11 = a2;
    unint64_t v12 = a1 + 9;
    do
    {
      uint64_t v13 = a1[14][v10];
      uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t **))(v13 + 144);
      if (v14)
      {
        if (v10 > v11)
        {
          uint64_t v15 = v14(a1[14][v10], v12);
          if (v15)
          {
            uint64_t v17 = v15;
            uint64_t v18 = **a1;
            uint64_t v19 = fi_layer_type_to_name(*(_DWORD *)(v13 + 8));
            log_OutText(v18, (uint64_t)"FastInfer", 0, 0, (uint64_t)"update shape of %s layer failed!", v20, v21, v22, (uint64_t)v19);
            return v17;
          }
          unsigned int v9 = *((_DWORD *)a1 + 2);
        }
        unint64_t v12 = (uint64_t **)(v13 + 40);
      }
      ++v10;
    }
    while (v10 < v9);
    if (v9) {
      uint64_t v16 = (const void *)(a1[14][v9 - 1] + 40);
    }
    else {
      uint64_t v16 = a1 + 9;
    }
    cstdlib_memcpy((char *)a1 + 92, v16, 0x14uLL);
    return 0;
  }
}

uint64_t fi_net_show(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"GLOBAL - [Layers:%d]", a6, a7, a8, *(unsigned int *)(a1 + 8));
  uint64_t result = fi_shape_dump(*(uint64_t **)a1, a1 + 72, (uint64_t)"GLOBAL", v9, v10, v11, v12, v13);
  if (*(_DWORD *)(a1 + 8))
  {
    unint64_t v18 = 0;
    do
    {
      uint64_t v19 = *(void *)(*(void *)(a1 + 112) + 8 * v18);
      if (v19)
      {
        uint64_t v20 = fi_layer_type_to_name(*(_DWORD *)(v19 + 8));
        fi_shape_dump(*(uint64_t **)a1, v19 + 20, (uint64_t)v20, v21, v22, v23, v24, v25);
        ++v18;
        log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"%s at %d", v26, v27, v28, (uint64_t)v20);
        uint64_t result = fi_shape_dump(*(uint64_t **)a1, v19 + 40, (uint64_t)v20, v29, v30, v31, v32, v33);
      }
      else
      {
        uint64_t result = log_OutText(**(void **)a1, (uint64_t)"FastInfer", 1, 0, (uint64_t)"Layer %d is NULL", v15, v16, v17, ++v18);
      }
    }
    while (v18 < *(unsigned int *)(a1 + 8));
  }
  return result;
}

BOOL fi_net_is_last_layer_label_layer(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  return v1 && *(_DWORD *)(*(void *)(*(void *)(a1 + 112) + 8 * (v1 - 1)) + 8) == 20;
}

uint64_t fi_net_set_vlogdir(uint64_t a1, uint64_t a2)
{
  uint64_t result = 7;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0;
      *(void *)(a1 + 120) = a2;
    }
  }
  return result;
}

uint64_t maybe_enlarge_array(uint64_t *a1, uint64_t *a2, unsigned int *a3, unsigned int a4)
{
  uint64_t result = 0;
  if (a2 && a3)
  {
    unsigned int v7 = a4;
    if (*a3 >= a4)
    {
      return 0;
    }
    else
    {
      if (*a2)
      {
        (*(void (**)(uint64_t))(a1[1] + 48))(a1[2]);
        *a2 = 0;
      }
      uint64_t v9 = (*(uint64_t (**)(uint64_t, void))a1[1])(a1[2], v7);
      if (v9)
      {
        uint64_t v13 = v9;
        uint64_t result = 0;
        *a2 = v13;
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"enlarge array failed!", v10, v11, v12, v14);
        unsigned int v7 = 0;
        uint64_t result = 10;
      }
      *a3 = v7;
    }
  }
  return result;
}

uint64_t fi_net_wanted_weights_length(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v16 = 0;
  *a2 = 0;
  *a3 = 0;
  unint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3)
  {
    for (unint64_t i = 0; i < v3; ++i)
    {
      uint64_t v8 = *(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 112) + 8 * i) + 152);
      if (v8)
      {
        uint64_t v9 = v8();
        if (v9)
        {
          uint64_t v13 = v9;
          log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Get wanted weight and biases length failed!", v10, v11, v12, v15);
          return v13;
        }
        *a2 += HIDWORD(v16);
        *a3 += v16;
        unint64_t v3 = *(unsigned int *)(a1 + 8);
      }
    }
  }
  return 0;
}

uint64_t fi_net_find_weights_via_offset(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3)
  {
    for (unint64_t i = 0; i < v3; ++i)
    {
      uint64_t v8 = *(void *)(*(void *)(a1 + 112) + 8 * i);
      if (*(void *)(v8 + 152))
      {
        uint64_t weights_via_offset = fi_layer_find_weights_via_offset(v8, a2, a3);
        if (weights_via_offset)
        {
          uint64_t v13 = weights_via_offset;
          log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"find weights for layer %d failed!", v10, v11, v12, i);
          return v13;
        }
        unint64_t v3 = *(unsigned int *)(a1 + 8);
      }
    }
  }
  return 0;
}

__n128 fi_net_borrow_output_data(uint64_t a1, char *__s1, uint64_t *a3, __n128 *a4)
{
  unint64_t v4 = *(unsigned int *)(a1 + 8);
  if (v4)
  {
    for (unint64_t i = 0; i < v4; ++i)
    {
      uint64_t v10 = *(void *)(*(void *)(a1 + 112) + 8 * i);
      if (*(_DWORD *)(v10 + 8) == 26)
      {
        if (!cstdlib_strcmp(__s1, *(const char **)(v10 + 120)))
        {
          *a3 = tee_layer_get_output_buffer(v10);
          unsigned __int32 v12 = *(_DWORD *)(v10 + 56);
          __n128 result = *(__n128 *)(v10 + 40);
          *a4 = result;
          a4[1].n128_u32[0] = v12;
          return result;
        }
        unint64_t v4 = *(unsigned int *)(a1 + 8);
      }
    }
  }
  return result;
}

uint64_t fi_net_borrow_tee_layername(uint64_t a1, int a2, void *a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (!v3) {
    return 0;
  }
  int v4 = 0;
  for (uint64_t i = *(void *)(a1 + 112); *(_DWORD *)(*(void *)i + 8) != 26; i += 8)
  {
LABEL_6:
    if (!--v3) {
      return 0;
    }
  }
  if (v4 != a2)
  {
    ++v4;
    goto LABEL_6;
  }
  if (a3) {
    *a3 = *(void *)(*(void *)i + 120);
  }
  return 1;
}

uint64_t fi_net_reset(uint64_t a1)
{
  if (!a1) {
    return 7;
  }
  *(_DWORD *)(a1 + 192) = 12345;
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    for (unint64_t i = 0; i < v2; ++i)
    {
      int v4 = *(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 112) + 8 * i) + 176);
      if (v4)
      {
        uint64_t result = v4();
        if (result) {
          return result;
        }
        unint64_t v2 = *(unsigned int *)(a1 + 8);
      }
    }
  }
  return 0;
}

uint64_t fi_net_update_param(uint64_t a1)
{
  if (!a1) {
    return 7;
  }
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    for (unint64_t i = 0; i < v2; ++i)
    {
      int v4 = *(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 112) + 8 * i) + 224);
      if (v4)
      {
        uint64_t result = v4();
        if (result) {
          return result;
        }
        unint64_t v2 = *(unsigned int *)(a1 + 8);
      }
    }
  }
  return 0;
}

uint64_t fi_net_give_address(uint64_t a1)
{
  if (!a1) {
    return 7;
  }
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    for (unint64_t i = 0; i < v2; ++i)
    {
      int v4 = *(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 112) + 8 * i) + 232);
      if (v4)
      {
        uint64_t result = v4();
        if (result) {
          return result;
        }
        unint64_t v2 = *(unsigned int *)(a1 + 8);
      }
    }
  }
  return 0;
}

uint64_t fi_rsc_create(void *a1, void *a2)
{
  int v4 = (void *)a1[1];
  uint64_t v5 = (uint64_t (**)(uint64_t, unint64_t))calloc_aligned_32_mem((uint64_t)v4, 1, 88);
  if (v5)
  {
    uint64_t v6 = v5;
    unsigned int v7 = calloc_aligned_32_mem((uint64_t)v4, 1, 104);
    if (v7)
    {
      uint64_t v8 = v7;
      void *v6 = alloc_aligned_32_mem;
      v6[1] = (uint64_t (*)(uint64_t, unint64_t))realloc_aligned_32_mem;
      v6[2] = (uint64_t (*)(uint64_t, unint64_t))calloc_aligned_32_mem;
      v6[3] = (uint64_t (*)(uint64_t, unint64_t))alloc_aligned_mem;
      v6[4] = (uint64_t (*)(uint64_t, unint64_t))realloc_aligned_mem;
      v6[5] = (uint64_t (*)(uint64_t, unint64_t))calloc_aligned_mem;
      v6[6] = (uint64_t (*)(uint64_t, unint64_t))free_aligned_mem;
      v6[9] = (uint64_t (*)(uint64_t, unint64_t))alloc_mem;
      v6[8] = (uint64_t (*)(uint64_t, unint64_t))calloc_mem;
      _OWORD v6[7] = (uint64_t (*)(uint64_t, unint64_t))realloc_mem;
      v6[10] = (uint64_t (*)(uint64_t, unint64_t))free_mem;
      v7[2] = v4;
      void *v7 = a1[4];
      v7[1] = v6;
      fi_thread_init((uint64_t)(v7 + 3), a1);
      *((_DWORD *)v8 + 24) = 2;
      *a2 = v8;
      log_OutText(*v8, (uint64_t)"FastInfer", 4, 0, (uint64_t)"FI GEMM macro: (None)", v9, v10, v11, v13);
      return 0;
    }
    free_aligned_mem(v4, (uint64_t)v6);
  }
  return 10;
}

void *fi_rsc_destroy(void *result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    fi_thread_deinit((uint64_t)(result + 3), (uint64_t)result);
    uint64_t v2 = *(void *)(v1 + 8);
    if (v2)
    {
      free_aligned_mem(*(void **)(v1 + 16), v2);
      *(void *)(v1 + 8) = 0;
    }
    uint64_t v3 = *(void **)(v1 + 16);
    return free_aligned_mem(v3, v1);
  }
  return result;
}

uint64_t fi_rsc_set_maxthreads(uint64_t a1, unsigned int a2)
{
  if (a2 <= 1) {
    uint64_t v2 = 1;
  }
  else {
    uint64_t v2 = 2;
  }
  *(_DWORD *)(a1 + 96) = v2;
  return v2;
}

uint64_t get_padded_len(uint64_t result, unsigned int a2)
{
  unsigned int v2 = result / a2 * a2;
  BOOL v3 = result == v2;
  unsigned int v4 = a2 + v2;
  if (v3) {
    return result;
  }
  else {
    return v4;
  }
}

uint64_t get_padded_bytes(unsigned int a1, unsigned int a2)
{
  unsigned int v2 = a1 >> 2;
  int v3 = (a1 >> 2) / a2 * a2;
  BOOL v4 = a1 >> 2 == v3;
  unsigned int v5 = a2 + v3;
  if (!v4) {
    unsigned int v2 = v5;
  }
  return 4 * v2;
}

void *calloc_padded_2d(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  int v4 = a3 / a2 * a2;
  BOOL v5 = a3 == v4;
  unsigned int v6 = a2 + v4;
  if (v5) {
    unsigned int v6 = a3;
  }
  int v7 = a4 / a2 * a2;
  BOOL v5 = a4 == v7;
  unsigned int v8 = a2 + v7;
  if (v5) {
    unsigned int v8 = a4;
  }
  size_t v9 = 4 * v8 * v6;
  uint64_t v10 = (void *)(**(uint64_t (***)(void, size_t))(a1 + 8))(*(void *)(a1 + 16), v9);
  uint64_t v11 = v10;
  if (v10) {
    cstdlib_memset(v10, 0, v9);
  }
  return v11;
}

void *calloc_padded_1d(uint64_t a1, unsigned int a2, unsigned int a3)
{
  int v3 = a3 / a2 * a2;
  BOOL v4 = a3 == v3;
  unsigned int v5 = a2 + v3;
  if (v4) {
    unsigned int v5 = a3;
  }
  size_t v6 = 4 * v5;
  int v7 = (void *)(**(uint64_t (***)(void, size_t))(a1 + 8))(*(void *)(a1 + 16), v6);
  unsigned int v8 = v7;
  if (v7) {
    cstdlib_memset(v7, 0, v6);
  }
  return v8;
}

uint64_t fi_thread_init(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = a2[51];
    *(void *)a1 = v3;
    a2 = (void *)a2[1];
  }
  else
  {
    uint64_t v3 = *(void *)a1;
  }
  *(_DWORD *)(a1 + 8) = 1;
  uint64_t result = semaphore_ObjectOpen(v3, a2, 1, 1, (uint64_t *)(a1 + 16));
  if ((result & 0x80000000) != 0) {
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

uint64_t fi_thread_deinit(uint64_t a1, uint64_t a2)
{
  fi_rsc_checkDestroySecondThread(a2);
  uint64_t v3 = *(void *)(a1 + 16);

  return semaphore_ObjectClose(v3);
}

uint64_t fi_rsc_checkDestroySecondThread(uint64_t a1)
{
  uint64_t result = semaphore_Acquire(*(void **)(a1 + 40));
  if ((result & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 32) >= 2u)
    {
      *(void *)(a1 + 80) = 0;
      if ((semaphore_Release(*(void **)(a1 + 48)) & 0x80000000) == 0) {
        thread_Join(*(void **)(a1 + 64));
      }
      semaphore_ObjectClose(*(void *)(a1 + 48));
      semaphore_ObjectClose(*(void *)(a1 + 56));
      thread_ObjClose(*(void *)(a1 + 64));
      *(_DWORD *)(a1 + 32) = 1;
    }
    uint64_t v3 = *(void **)(a1 + 40);
    return semaphore_Release(v3);
  }
  return result;
}

uint64_t fi_rsc_checkCreateSecondThread(uint64_t a1)
{
  uint64_t result = semaphore_Acquire(*(void **)(a1 + 40));
  if ((result & 0x80000000) != 0) {
    return result;
  }
  if (*(_DWORD *)(a1 + 32) == 1)
  {
    log_OutText(*(void *)a1, (uint64_t)"FastInfer", 2, 0, (uint64_t)"FastInfer multithreaded mode enabled", v3, v4, v5, v11);
    size_t v6 = (uint64_t *)(a1 + 48);
    if ((semaphore_ObjectOpen(*(void *)(a1 + 24), *(void **)(a1 + 16), 0, 1, (uint64_t *)(a1 + 48)) & 0x80000000) != 0) {
      goto LABEL_12;
    }
    int v7 = (uint64_t *)(a1 + 56);
    if ((semaphore_ObjectOpen(*(void *)(a1 + 24), *(void **)(a1 + 16), 0, 1, (uint64_t *)(a1 + 56)) & 0x80000000) != 0)
    {
      uint64_t v8 = *v6;
    }
    else
    {
      if ((thread_ObjOpen(*(void *)(a1 + 24), *(void **)(a1 + 16), (uint64_t *)(a1 + 64)) & 0x80000000) == 0)
      {
        if (!thread_Start(*(void **)(a1 + 64)))
        {
          int v9 = 2;
          goto LABEL_13;
        }
        semaphore_ObjectClose(*v6);
        semaphore_ObjectClose(*v7);
        thread_ObjClose(*(void *)(a1 + 64));
LABEL_12:
        int v9 = 0;
LABEL_13:
        *(_DWORD *)(a1 + 32) = v9;
        goto LABEL_14;
      }
      semaphore_ObjectClose(*v6);
      uint64_t v8 = *v7;
    }
    semaphore_ObjectClose(v8);
    goto LABEL_12;
  }
LABEL_14:
  uint64_t v10 = *(void **)(a1 + 40);

  return semaphore_Release(v10);
}

uint64_t fastinfer_workerthread(uint64_t a1)
{
  do
  {
    if ((semaphore_Acquire(*(void **)(a1 + 48)) & 0x80000000) != 0) {
      break;
    }
    unsigned int v2 = *(uint64_t (**)(uint64_t, void))(a1 + 80);
    if (!v2) {
      return 0;
    }
    *(_DWORD *)(a1 + 88) = v2(a1, *(void *)(a1 + 72));
  }
  while ((semaphore_Release(*(void **)(a1 + 56)) & 0x80000000) == 0);
  *(_DWORD *)(a1 + 88) = 512;
  return 0;
}

BOOL fi_thread_checkQueueTask(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((semaphore_Acquire(*(void **)(a1 + 16)) & 0x80000000) != 0) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 8) == 2)
  {
    *(void *)(a1 + 48) = a2;
    *(void *)(a1 + 56) = a3;
    int v6 = semaphore_Release(*(void **)(a1 + 24));
    BOOL v7 = v6 >= 0;
    *(_DWORD *)(a1 + 8) = ~(v6 >> 31) & 3;
  }
  else
  {
    BOOL v7 = 0;
  }
  semaphore_Release(*(void **)(a1 + 16));
  return v7;
}

uint64_t fi_thread_wait4Task(uint64_t a1)
{
  int v2 = semaphore_Acquire(*(void **)(a1 + 32));
  if ((semaphore_Acquire(*(void **)(a1 + 16)) & 0x80000000) != 0) {
    return 0;
  }
  if (v2 < 0) {
    *(_DWORD *)(a1 + 64) = 512;
  }
  *(_DWORD *)(a1 + 8) = 2;
  semaphore_Release(*(void **)(a1 + 16));
  return *(unsigned int *)(a1 + 64);
}

uint64_t fi_one_hot(unsigned int a1, void *a2, unsigned int a3)
{
  if (!a2) {
    return 7;
  }
  if (a3) {
    bzero(a2, 4 * a3);
  }
  uint64_t result = 0;
  if (a1 < a3) {
    *((_DWORD *)a2 + a1) = 1065353216;
  }
  return result;
}

uint64_t fi_argmax(uint64_t result, int a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = result;
  uint64_t v3 = 0;
  LODWORD(result) = 0;
  float v4 = 0.0;
  do
  {
    if (*(float *)(v2 + 4 * v3) <= v4)
    {
      uint64_t result = result;
    }
    else
    {
      float v4 = *(float *)(v2 + 4 * v3);
      uint64_t result = v3;
    }
    ++v3;
  }
  while (a2 != v3);
  return result;
}

uint64_t get_bytesOfElem(unsigned int a1, unsigned char *a2)
{
  if (a1 > 2) {
    return 7;
  }
  char v2 = a1;
  uint64_t result = 0;
  *a2 = 0x20104u >> (8 * v2);
  return result;
}

uint64_t *do_analysis(uint64_t *result, float *a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4)
  {
    if (a3)
    {
      uint64_t v8 = a3;
      double v9 = 0.0;
      float v10 = 0.0;
      uint64_t v11 = a3;
      unsigned __int32 v12 = a2;
      float v13 = 0.0;
      do
      {
        float v14 = *v12++;
        float v15 = v14;
        double v9 = v9 + v14;
        if (v14 > v10) {
          float v10 = v15;
        }
        if (v15 < v13) {
          float v13 = v15;
        }
        --v11;
      }
      while (v11);
      double v16 = (double)a3;
      float v17 = v9 / (double)a3;
      double v18 = 0.0;
      do
      {
        float v19 = *a2++;
        double v18 = v18 + (float)(v19 - v17) * (float)(v19 - v17);
        --v8;
      }
      while (v8);
    }
    else
    {
      double v16 = (double)0;
      double v9 = 0.0;
      float v17 = 0.0 / (double)0;
      float v10 = 0.0;
      float v13 = 0.0;
      double v18 = 0.0;
    }
    *(float *)a4 = v13;
    *(float *)(a4 + 4) = v10;
    *(float *)(a4 + 8) = v17;
    *(double *)(a4 + 16) = v9;
    *(double *)(a4 + 24) = v18 / v16;
    return (uint64_t *)log_OutText(*result, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Model analyzed result: min=%f, max=%f, mean=%f, sum=%f, variance=%f", a6, a7, a8, COERCE__INT64(v13));
  }
  return result;
}

BOOL is_quantization_valid(int a1)
{
  return (a1 - 1) < 2;
}

const char *get_quant_type_str(unsigned int a1)
{
  if (a1 > 2) {
    return "";
  }
  else {
    return (&off_26456CE88)[a1];
  }
}

uint64_t f32_to_s8(float a1, float a2, float a3)
{
  return (int)((float)((float)(a1 - a2) / a3) + 0.5);
}

uint64_t f32_to_s16(float a1, float a2, float a3)
{
  return (int)((float)((float)(a1 - a2) / a3) + 0.5);
}

uint64_t quant_array_f32_to_s8(uint64_t *a1, float *a2, unsigned int a3, float a4, float a5)
{
  uint64_t v10 = a3;
  uint64_t v11 = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], a3, 1);
  uint64_t v16 = v11;
  if (v11)
  {
    if (a3)
    {
      v15.n128_u64[0] = 0.5;
      float v17 = a2;
      double v18 = (unsigned char *)v11;
      do
      {
        float v19 = *v17++;
        *v18++ = (int)((float)((float)(v19 - a4) / a5) + 0.5);
        --v10;
      }
      while (v10);
      goto LABEL_8;
    }
    if (a2) {
LABEL_8:
    }
      (*(void (**)(uint64_t, float *, __n128))(a1[1] + 48))(a1[2], a2, v15);
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v21);
  }
  return v16;
}

uint64_t quant_array_f32_to_s16(uint64_t *a1, float *a2, unsigned int a3, float a4, float a5)
{
  uint64_t v10 = a3;
  uint64_t v11 = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], a3, 2);
  uint64_t v16 = v11;
  if (v11)
  {
    if (a3)
    {
      v15.n128_u64[0] = 0.5;
      float v17 = a2;
      double v18 = (_WORD *)v11;
      do
      {
        float v19 = *v17++;
        *v18++ = (int)((float)((float)(v19 - a4) / a5) + 0.5);
        --v10;
      }
      while (v10);
      goto LABEL_8;
    }
    if (a2) {
LABEL_8:
    }
      (*(void (**)(uint64_t, float *, __n128))(a1[1] + 48))(a1[2], a2, v15);
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v21);
  }
  return v16;
}

float s8_to_f32(int a1, float a2, float a3)
{
  return a2 + (float)((float)a1 * a3);
}

float s16_to_f32(int a1, float a2, float a3)
{
  return a2 + (float)((float)a1 * a3);
}

uint64_t parse_fi_binary_model_inner(uint64_t *a1, uint64_t a2, unsigned int *a3, _DWORD *a4, void *a5)
{
  v571 = 0;
  uint64_t v10 = fi_net_init(a1, &v571);
  if (v10)
  {
    uint64_t v14 = v10;
    uint64_t v15 = *a1;
    uint64_t v16 = "init network failed!";
    goto LABEL_8;
  }
  *a3 = 4;
  cstdlib_memcpy(v571 + 1, (const void *)(a2 + *a4), 4uLL);
  *a4 += *a3;
  log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v17, v18, v19, 0);
  *a3 = 12;
  cstdlib_memcpy((char *)v571 + 12, (const void *)(a2 + *a4), 0xCuLL);
  *a4 += *a3;
  log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v20, v21, v22, 0);
  *a3 = 20;
  cstdlib_memcpy((char *)v571 + 52, (const void *)(a2 + *a4), 0x14uLL);
  *a4 += *a3;
  log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v23, v24, v25, 0);
  if (fi_version_cmp((uint64_t)a1, (int *)v571 + 3, "0.0.0"))
  {
    uint64_t v29 = 0;
    uint64_t v30 = v571;
    v571[5] = *(uint64_t **)((char *)v571 + 12);
    *((_DWORD *)v30 + 12) = *((_DWORD *)v30 + 5);
    *((_DWORD *)v30 + 6) = 0;
  }
  else
  {
    *a3 = 12;
    cstdlib_memcpy(v571 + 5, (const void *)(a2 + *a4), 0xCuLL);
    *a4 += *a3;
    log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v31, v32, v33, 0);
    *a3 = 4;
    cstdlib_memcpy(v571 + 3, (const void *)(a2 + *a4), 4uLL);
    *a4 += *a3;
    log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v34, v35, v36, 0);
    int v37 = *((_DWORD *)v571 + 6);
    *a3 = 4 * v37;
    uint64_t v38 = *a4;
    uint64_t v29 = (uint64_t *)(a2 + v38);
    *a4 = v38 + 4 * v37;
    log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v39, v40, v41, 0);
    uint64_t v30 = v571;
  }
  v30[4] = v29;
  log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Network layers number: ", v26, v27, v28, *((unsigned int *)v30 + 2));
  fi_shape_dump(a1, (uint64_t)v571 + 52, (uint64_t)"non-changed network model inshape: ", v42, v43, v44, v45, v46);
  uint64_t v47 = fi_net_layers_init(v571);
  if (v47)
  {
    uint64_t v14 = v47;
    uint64_t v15 = *a1;
    uint64_t v16 = "init layers failed!";
    goto LABEL_8;
  }
  if (!*((_DWORD *)v571 + 2))
  {
LABEL_177:
    uint64_t v542 = *a1;
    v543 = "load model done!";
    uint64_t v544 = 4;
LABEL_178:
    log_OutText(v542, (uint64_t)"FastInfer", v544, 0, (uint64_t)v543, v11, v12, v13, v547);
    uint64_t v14 = 0;
    *a5 = v571;
    return v14;
  }
  unint64_t v50 = 0;
  v548 = a5;
  uint64_t v550 = a2;
  while (2)
  {
    v570 = 0;
    int v569 = 0;
    uint64_t v567 = 0;
    uint64_t __b = 0;
    cstdlib_memset(&__b, 0, 0xCuLL);
    *a3 = 4;
    cstdlib_memcpy(&__b, (const void *)(a2 + *a4), 4uLL);
    *a4 += *a3;
    log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v51, v52, v53, (uint64_t)"");
    *a3 = 4;
    cstdlib_memcpy((char *)&__b + 4, (const void *)(a2 + *a4), 4uLL);
    *a4 += *a3;
    log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v54, v55, v56, (uint64_t)"");
    if (fi_feat_is_enabled((uint64_t)v571[4], 3u, *((_DWORD *)v571 + 6)))
    {
      *a3 = 4;
      cstdlib_memcpy(&v569, (const void *)(a2 + *a4), 4uLL);
      *a4 += *a3;
      log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v57, v58, v59, (uint64_t)"");
    }
    cstdlib_memset(&v567, 0, 8uLL);
    *a3 = 8;
    cstdlib_memcpy(&v567, (const void *)(a2 + *a4), 8uLL);
    *a4 += *a3;
    log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v60, v61, v62, (uint64_t)"");
    uint64_t v66 = fi_layer_type_to_name(__b);
    switch((int)__b)
    {
      case 0:
        *(_OWORD *)v551 = 0u;
        memset(v552, 0, 20);
        cstdlib_memset(v551, 0, 0x24uLL);
        v551[1] = (void *)0x100000001;
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v125, v126, v127, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v551 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v128, v129, v130, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy(v552, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v131, v132, v133, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v552 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v134, v135, v136, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v552 + 12, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v137, v138, v139, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy(&v552[1], (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v140, v141, v142, (uint64_t)v66);
        if (fi_feat_is_enabled((uint64_t)v571[4], 0, *((_DWORD *)v571 + 6)))
        {
          *a3 = 4;
          cstdlib_memcpy(&v551[1], (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v143, v144, v145, (uint64_t)v66);
          *a3 = 4;
          cstdlib_memcpy((char *)&v551[1] + 4, (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v146, v147, v148, (uint64_t)v66);
        }
        if (fi_feat_is_enabled((uint64_t)v571[4], 1u, *((_DWORD *)v571 + 6)))
        {
          *a3 = 4;
          cstdlib_memcpy((char *)v552 + 8, (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v149, v150, v151, (uint64_t)v66);
        }
        else
        {
          DWORD2(v552[0]) = 1;
        }
        uint64_t v538 = create_conv1d_layer(a1, v551, &v567, (uint64_t)(v571 + 1), &v570);
        if (!v538) {
          goto LABEL_95;
        }
        uint64_t v14 = v538;
        uint64_t v15 = *a1;
        uint64_t v16 = "create conv1d layer failed!";
        goto LABEL_8;
      case 1:
        *(_OWORD *)v551 = 0u;
        memset(v552, 0, 20);
        cstdlib_memset(v551, 0, 0x24uLL);
        v551[1] = (void *)0x100000001;
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v152, v153, v154, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v551 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v155, v156, v157, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy(v552, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v158, v159, v160, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v552 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v161, v162, v163, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v552 + 12, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v164, v165, v166, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy(&v552[1], (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v167, v168, v169, (uint64_t)v66);
        if (fi_feat_is_enabled((uint64_t)v571[4], 0, *((_DWORD *)v571 + 6)))
        {
          *a3 = 4;
          cstdlib_memcpy(&v551[1], (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v170, v171, v172, (uint64_t)v66);
          *a3 = 4;
          cstdlib_memcpy((char *)&v551[1] + 4, (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v173, v174, v175, (uint64_t)v66);
        }
        if (fi_feat_is_enabled((uint64_t)v571[4], 1u, *((_DWORD *)v571 + 6)))
        {
          *a3 = 4;
          cstdlib_memcpy((char *)v552 + 8, (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v176, v177, v178, (uint64_t)v66);
        }
        else
        {
          DWORD2(v552[0]) = 1;
        }
        uint64_t v539 = create_conv2d_layer(a1, v551, &v567, &v570);
        if (!v539) {
          goto LABEL_95;
        }
        uint64_t v14 = v539;
        uint64_t v15 = *a1;
        uint64_t v16 = "create conv2d layer failed!";
        goto LABEL_8;
      case 2:
        LODWORD(v551[1]) = 0;
        v551[0] = 0;
        cstdlib_memset(v551, 0, 0xCuLL);
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v179, v180, v181, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v551 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v182, v183, v184, (uint64_t)v66);
        if (fi_feat_is_enabled((uint64_t)v571[4], 2u, *((_DWORD *)v571 + 6)))
        {
          *a3 = 4;
          cstdlib_memcpy(&v551[1], (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v185, v186, v187, (uint64_t)v66);
        }
        uint64_t v188 = create_rnn_layer(a1, (unsigned int *)&__b, v551, &v567, &v570);
        if (!v188) {
          goto LABEL_95;
        }
        uint64_t v14 = v188;
        uint64_t v15 = *a1;
        uint64_t v16 = "create rnn layer failed!";
        goto LABEL_8;
      case 3:
        v551[0] = 0;
        v551[1] = 0;
        DWORD2(v552[0]) = 0;
        *(void *)&v552[0] = 0;
        cstdlib_memset(v551, 0, 0x1CuLL);
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v189, v190, v191, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v551 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v192, v193, v194, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy(&v551[1], (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v195, v196, v197, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)&v551[1] + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v198, v199, v200, (uint64_t)v66);
        if (LODWORD(v551[0]) == 2)
        {
          *a3 = 4;
          cstdlib_memcpy(v552, (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v201, v202, v203, (uint64_t)v66);
        }
        if (fi_feat_is_enabled((uint64_t)v571[4], 2u, *((_DWORD *)v571 + 6)))
        {
          *a3 = 4;
          cstdlib_memcpy((char *)v552 + 8, (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v204, v205, v206, (uint64_t)v66);
        }
        if (fi_feat_is_enabled((uint64_t)v571[4], 6u, *((_DWORD *)v571 + 6)))
        {
          *a3 = 4;
          cstdlib_memcpy((char *)v552 + 4, (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v207, v208, v209, (uint64_t)v66);
        }
        uint64_t v210 = create_lstm_layer(a1, &__b, v551, &v567, v571 + 1, &v570);
        if (!v210) {
          goto LABEL_95;
        }
        uint64_t v14 = v210;
        uint64_t v15 = *a1;
        uint64_t v16 = "create lstm layer failed!";
        goto LABEL_8;
      case 4:
        v551[0] = 0;
        v551[1] = 0;
        DWORD2(v552[0]) = 0;
        *(void *)&v552[0] = 0;
        cstdlib_memset(v551, 0, 0x1CuLL);
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v211, v212, v213, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v551 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v214, v215, v216, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy(&v551[1], (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v217, v218, v219, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)&v551[1] + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v220, v221, v222, (uint64_t)v66);
        if (LODWORD(v551[0]) == 2)
        {
          *a3 = 4;
          cstdlib_memcpy(v552, (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v223, v224, v225, (uint64_t)v66);
        }
        if (fi_feat_is_enabled((uint64_t)v571[4], 2u, *((_DWORD *)v571 + 6)))
        {
          *a3 = 4;
          cstdlib_memcpy((char *)v552 + 8, (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v226, v227, v228, (uint64_t)v66);
        }
        if (fi_feat_is_enabled((uint64_t)v571[4], 6u, *((_DWORD *)v571 + 6)))
        {
          *a3 = 4;
          cstdlib_memcpy((char *)v552 + 4, (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v229, v230, v231, (uint64_t)v66);
        }
        uint64_t v232 = create_blstm_layer(a1, (unsigned int *)&__b, v551, &v567, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (!v232) {
          goto LABEL_95;
        }
        uint64_t v14 = v232;
        uint64_t v15 = *a1;
        uint64_t v16 = "create blstm layer failed!";
        goto LABEL_8;
      case 5:
        v551[0] = 0;
        cstdlib_memset(v551, 0, 8uLL);
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v233, v234, v235, (uint64_t)v66);
        if (fi_feat_is_enabled((uint64_t)v571[4], 5u, *((_DWORD *)v571 + 6)))
        {
          *a3 = 4;
          cstdlib_memcpy((char *)v551 + 4, (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v236, v237, v238, (uint64_t)v66);
        }
        else
        {
          HIDWORD(v551[0]) = 1;
        }
        tee_paraunsigned int m = create_fc_layer(a1, &__b, v551, &v567, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (tee_param) {
          goto LABEL_180;
        }
        goto LABEL_95;
      case 6:
        LODWORD(v551[0]) = 0;
        cstdlib_memset(v551, 0, 4uLL);
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v239, v240, v241, (uint64_t)v66);
        uint64_t v242 = create_softmax_layer(a1, &__b, v551, &v567, &v570);
        if (!v242) {
          goto LABEL_95;
        }
        uint64_t v14 = v242;
        uint64_t v15 = *a1;
        uint64_t v16 = "create softmax layer failed!";
        goto LABEL_8;
      case 7:
        LODWORD(v551[0]) = 0;
        cstdlib_memset(v551, 0, 4uLL);
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v243, v244, v245, (uint64_t)v66);
        uint64_t v246 = create_flatten_layer(a1, v551, &v570);
        if (!v246) {
          goto LABEL_95;
        }
        uint64_t v14 = v246;
        uint64_t v15 = *a1;
        uint64_t v16 = "create flatten layer failed!";
        goto LABEL_8;
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
        *(_OWORD *)v551 = 0u;
        memset(v552, 0, 20);
        cstdlib_memset(v551, 0, 0x24uLL);
        v551[1] = (void *)0x100000001;
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v67, v68, v69, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v551 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v70, v71, v72, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy(v552, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v73, v74, v75, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v552 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v76, v77, v78, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v552 + 12, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v79, v80, v81, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy(&v552[1], (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v82, v83, v84, (uint64_t)v66);
        if (fi_feat_is_enabled((uint64_t)v571[4], 0, *((_DWORD *)v571 + 6)))
        {
          *a3 = 4;
          cstdlib_memcpy(&v551[1], (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v85, v86, v87, (uint64_t)v66);
          *a3 = 4;
          cstdlib_memcpy((char *)&v551[1] + 4, (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v88, v89, v90, (uint64_t)v66);
        }
        uint64_t v91 = create_pooling1d_layer(a1, __b, v551, &v567, &v570);
        if (!v91) {
          goto LABEL_23;
        }
        uint64_t v14 = v91;
        uint64_t v545 = *a1;
        v546 = "create pooling1d layer failed!";
        goto LABEL_185;
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
        *(_OWORD *)v551 = 0u;
        memset(v552, 0, 20);
        cstdlib_memset(v551, 0, 0x24uLL);
        v551[1] = (void *)0x100000001;
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v95, v96, v97, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v551 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v98, v99, v100, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy(v552, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v101, v102, v103, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v552 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v104, v105, v106, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v552 + 12, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v107, v108, v109, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy(&v552[1], (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v110, v111, v112, (uint64_t)v66);
        if (fi_feat_is_enabled((uint64_t)v571[4], 0, *((_DWORD *)v571 + 6)))
        {
          *a3 = 4;
          cstdlib_memcpy(&v551[1], (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v113, v114, v115, (uint64_t)v66);
          *a3 = 4;
          cstdlib_memcpy((char *)&v551[1] + 4, (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v116, v117, v118, (uint64_t)v66);
        }
        uint64_t v119 = create_pooling2d_layer(a1, __b, v551, &v567, &v570);
        if (!v119)
        {
LABEL_23:
          a5 = v548;
          goto LABEL_95;
        }
        uint64_t v14 = v119;
        uint64_t v545 = *a1;
        v546 = "create pooling2d layer failed!";
LABEL_185:
        log_OutText(v545, (uint64_t)"FastInfer", 0, 0, (uint64_t)v546, v92, v93, v94, v547);
        goto LABEL_186;
      case 20:
        *(void *)&long long v553 = 0;
        memset(v552, 0, sizeof(v552));
        *(_OWORD *)v551 = 0u;
        cstdlib_memset(v551, 0, 0x38uLL);
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v247, v248, v249, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v551 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v250, v251, v252, (uint64_t)v66);
        int v253 = HIDWORD(v551[0]);
        *a3 = HIDWORD(v551[0]);
        uint64_t v254 = *a4;
        v551[1] = (void *)(a2 + v254);
        *a4 = v254 + v253;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v255, v256, v257, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy(v552, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v258, v259, v260, (uint64_t)v66);
        if (LODWORD(v552[0]))
        {
          int v264 = LODWORD(v551[0]) * LODWORD(v551[0]);
          *a3 = 4 * LODWORD(v551[0]) * LODWORD(v551[0]);
          uint64_t v265 = *a4;
          uint64_t v266 = a2 + v265;
          *a4 = v265 + 4 * v264;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v261, v262, v263, (uint64_t)v66);
          *((void *)&v552[0] + 1) = v266;
        }
        *a3 = 4;
        cstdlib_memcpy(&v552[1], (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v267, v268, v269, (uint64_t)v66);
        if (LODWORD(v552[1]))
        {
          int v273 = (int)v551[0];
          *a3 = 4 * LODWORD(v551[0]);
          uint64_t v274 = *a4;
          uint64_t v275 = a2 + v274;
          *a4 = v274 + 4 * v273;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v270, v271, v272, (uint64_t)v66);
          *((void *)&v552[1] + 1) = v275;
        }
        LODWORD(v553) = 0;
        uint64_t v276 = create_label_layer(a1, v551, &v567, (uint64_t *)&v570);
        if (!v276) {
          goto LABEL_95;
        }
        uint64_t v14 = v276;
        uint64_t v15 = *a1;
        uint64_t v16 = "create label layer failed!";
        goto LABEL_8;
      case 21:
        LODWORD(v551[0]) = 0;
        cstdlib_memset(v551, 0, 4uLL);
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v277, v278, v279, (uint64_t)v66);
        uint64_t v283 = create_repeat_layer(a1, &__b, v551, &v567, &v570, v280, v281, v282);
        if (!v283) {
          goto LABEL_95;
        }
        uint64_t v14 = v283;
        uint64_t v15 = *a1;
        uint64_t v16 = "create repeat layer failed!";
        goto LABEL_8;
      case 22:
      case 40:
        uint64_t v120 = create_norm_layer(a1, &__b, &v570);
        if (!v120) {
          goto LABEL_95;
        }
        uint64_t v14 = v120;
        uint64_t v15 = *a1;
        uint64_t v16 = "create norm layer failed!";
        goto LABEL_8;
      case 23:
        v551[0] = 0;
        v551[1] = 0;
        LODWORD(v552[0]) = 0;
        cstdlib_memset(v551, 0, 0x14uLL);
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v284, v285, v286, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v551 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v287, v288, v289, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy(&v551[1], (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v290, v291, v292, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)&v551[1] + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v293, v294, v295, (uint64_t)v66);
        if (fi_feat_is_enabled((uint64_t)v571[4], 2u, *((_DWORD *)v571 + 6)))
        {
          *a3 = 4;
          cstdlib_memcpy(v552, (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v296, v297, v298, (uint64_t)v66);
        }
        uint64_t v299 = create_gru_layer(a1, (unsigned int *)&__b, v551, &v567, (uint64_t)(v571 + 1), &v570);
        if (!v299) {
          goto LABEL_95;
        }
        uint64_t v14 = v299;
        uint64_t v15 = *a1;
        uint64_t v16 = "create gru layer failed!";
        goto LABEL_8;
      case 24:
        v551[0] = 0;
        v551[1] = 0;
        LODWORD(v552[0]) = 0;
        cstdlib_memset(v551, 0, 0x14uLL);
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v300, v301, v302, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v551 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v303, v304, v305, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy(&v551[1], (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v306, v307, v308, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)&v551[1] + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v309, v310, v311, (uint64_t)v66);
        if (fi_feat_is_enabled((uint64_t)v571[4], 2u, *((_DWORD *)v571 + 6)))
        {
          *a3 = 4;
          cstdlib_memcpy(v552, (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v312, v313, v314, (uint64_t)v66);
        }
        uint64_t v315 = create_bgru_layer(a1, &__b, v551, &v567, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (!v315) {
          goto LABEL_95;
        }
        uint64_t v14 = v315;
        uint64_t v15 = *a1;
        uint64_t v16 = "create bgru layer failed!";
        goto LABEL_8;
      case 25:
        LODWORD(v551[0]) = 0;
        HIDWORD(v566) = 0;
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v316, v317, v318, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)&v566 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v319, v320, v321, (uint64_t)v66);
        uint64_t v322 = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], HIDWORD(v566), 8);
        if (v322)
        {
          uint64_t v323 = v322;
          if (HIDWORD(v566))
          {
            v324 = v66;
            unint64_t v325 = 0;
            uint64_t v326 = v322;
            while (1)
            {
              uint64_t v327 = parse_fi_binary_model_inner(a1, v550, a3, a4, v326);
              if (v327) {
                break;
              }
              ++v325;
              int v328 = HIDWORD(v566);
              v326 += 8;
              if (v325 >= HIDWORD(v566))
              {
                uint64_t v66 = v324;
                a2 = v550;
                goto LABEL_175;
              }
            }
            uint64_t v14 = v327;
            uint64_t v16 = "parse nest layer submodel failed!";
LABEL_182:
            uint64_t v15 = *a1;
            goto LABEL_8;
          }
          int v328 = 0;
LABEL_175:
          uint64_t v541 = create_nest_layer(a1, (int)v551[0], v328, v323, &v570);
          if (v541)
          {
            uint64_t v14 = v541;
            uint64_t v16 = "create nest layer failed!";
            goto LABEL_182;
          }
          goto LABEL_95;
        }
        uint64_t v542 = *a1;
        v543 = "out of memory!";
        uint64_t v544 = 0;
        goto LABEL_178;
      case 26:
        v551[0] = 0;
        uint64_t v566 = 0;
        tee_paraunsigned int m = create_tee_param(a1, (uint64_t *)v551);
        if (tee_param) {
          goto LABEL_180;
        }
        *a3 = 72;
        cstdlib_memcpy(v551[0], (const void *)(a2 + *a4), 0x48uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v329, v330, v331, (uint64_t)v66);
        uint64_t v332 = tee_param_alloc_sources(a1, (uint64_t)v551[0]);
        if (!v332)
        {
          if (*((_DWORD *)v551[0] + 17))
          {
            uint64_t v333 = 0;
            unint64_t v334 = 0;
            while (1)
            {
              *a3 = 4;
              cstdlib_memcpy((char *)&v566 + 4, (const void *)(a2 + *a4), 4uLL);
              *a4 += *a3;
              log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v335, v336, v337, (uint64_t)v66);
              int v338 = HIDWORD(v566);
              *a3 = HIDWORD(v566);
              uint64_t v339 = *a4;
              __s1 = (char *)(a2 + v339);
              *a4 = v339 + v338;
              log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v340, v341, v342, (uint64_t)v66);
              *a3 = 4;
              cstdlib_memcpy((void *)(*((void *)v551[0] + 9) + v333 + 8), (const void *)(a2 + *a4), 4uLL);
              *a4 += *a3;
              log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v343, v344, v345, (uint64_t)v66);
              *a3 = 4;
              cstdlib_memcpy((void *)(*((void *)v551[0] + 9) + v333 + 12), (const void *)(a2 + *a4), 4uLL);
              *a4 += *a3;
              log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v346, v347, v348, (uint64_t)v66);
              *a3 = 4;
              cstdlib_memcpy(&v566, (const void *)(a2 + *a4), 4uLL);
              *a4 += *a3;
              log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v349, v350, v351, (uint64_t)v66);
              uint64_t v352 = *((void *)v551[0] + 9) + v333;
              *(_DWORD *)(v352 + 16) = v566;
              uint64_t source_layer = tee_source_cfg_get_source_layer(a1, (void *)v352, __s1, v571[14], v50, v353, v354, v355);
              if (source_layer) {
                break;
              }
              ++v334;
              v333 += 24;
              a2 = v550;
              if (v334 >= *((unsigned int *)v551[0] + 17)) {
                goto LABEL_90;
              }
            }
            uint64_t v14 = source_layer;
            free_tee_param((uint64_t)a1, (uint64_t)v551[0]);
LABEL_186:
            a5 = v548;
            goto LABEL_9;
          }
LABEL_90:
          uint64_t tee_layer_take_param_ownership = create_tee_layer_take_param_ownership(a1, (uint64_t *)v551, (uint64_t *)&v570);
          a5 = v548;
          if (tee_layer_take_param_ownership)
          {
            uint64_t v14 = tee_layer_take_param_ownership;
            free_tee_param((uint64_t)a1, (uint64_t)v551[0]);
            uint64_t v15 = *a1;
            uint64_t v16 = "create tee layer failed!";
LABEL_8:
            log_OutText(v15, (uint64_t)"FastInfer", 0, 0, (uint64_t)v16, v11, v12, v13, v547);
            goto LABEL_9;
          }
LABEL_95:
          if (fi_layer_if_has_weights(__b) == 1)
          {
            LOBYTE(v551[0]) = 0;
            bytesOfEleunsigned int m = get_bytesOfElem(*((_DWORD *)v571 + 12), v551);
            if (bytesOfElem)
            {
              uint64_t v14 = bytesOfElem;
              uint64_t v15 = *a1;
              uint64_t v16 = "get bytes of elem failed!";
              goto LABEL_8;
            }
            *a3 = 4;
            cstdlib_memcpy(v570 + 10, (const void *)(a2 + *a4), 4uLL);
            *a4 += *a3;
            log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v373, v374, v375, (uint64_t)v66);
            *a3 = 4;
            cstdlib_memcpy(v570 + 12, (const void *)(a2 + *a4), 4uLL);
            *a4 += *a3;
            log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v376, v377, v378, (uint64_t)v66);
            *a3 = 4;
            cstdlib_memcpy(v570 + 14, (const void *)(a2 + *a4), 4uLL);
            *a4 += *a3;
            log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v379, v380, v381, (uint64_t)v66);
            uint64_t v382 = *a4;
            *a4 += 32 - (*a4 & 0x1F);
            log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"Skip PADDING Bytes [start, len, end]:  %d,  %d, %d", v383, v384, v385, v382);
            v386 = v570;
            unsigned int v387 = *((_DWORD *)v570 + 20) / LOBYTE(v551[0]) * LOBYTE(v551[0]);
            *a3 = v387;
            uint64_t v388 = *a4;
            v386[9] = (uint64_t *)(a2 + v388);
            *a4 = v388 + v387;
            log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v389, v390, v391, (uint64_t)v66);
            log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Layer:%s, weights bytes: %d, biases bytes: %d, total bytes: %d", v392, v393, v394, (uint64_t)v66);
            v395 = v570;
            v396 = v570[9];
            v570[13] = (uint64_t *)((char *)v396 + *((unsigned int *)v570 + 24));
            v395[11] = v396;
          }
          else
          {
            log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Layer %s does not have weights and biases, skipped.", v369, v370, v371, (uint64_t)v66);
            v395 = v570;
          }
          v571[14][v50++] = (uint64_t)v395;
          if (v50 >= *((unsigned int *)v571 + 2)) {
            goto LABEL_177;
          }
          continue;
        }
        uint64_t v14 = v332;
        free_tee_param((uint64_t)a1, (uint64_t)v551[0]);
LABEL_9:
        uint64_t v48 = v571;
        *a5 = v571;
        fi_net_destroy((uint64_t)v48);
        return v14;
      case 27:
        long long v553 = 0u;
        *(_OWORD *)v551 = 0u;
        memset(v552, 0, sizeof(v552));
        cstdlib_memset(v551, 0, 0x40uLL);
        *a3 = 64;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x40uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v358, v359, v360, (uint64_t)v66);
        uint64_t wavernn_layer = create_wavernn_layer(a1, (uint64_t)v551, (uint64_t)(v571 + 1), (uint64_t)(v571 + 24), (uint64_t *)&v570);
        if (!wavernn_layer) {
          goto LABEL_95;
        }
        uint64_t v14 = wavernn_layer;
        uint64_t v15 = *a1;
        uint64_t v16 = "create wavernn layer failed!";
        goto LABEL_8;
      case 28:
        v551[0] = 0;
        cstdlib_memset(v551, 0, 8uLL);
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v362, v363, v364, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v551 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v365, v366, v367, (uint64_t)v66);
        uint64_t sampling_layer = create_sampling_layer(a1, v551, (uint64_t)(v571 + 24), (uint64_t *)&v570);
        if (!sampling_layer) {
          goto LABEL_95;
        }
        uint64_t v14 = sampling_layer;
        uint64_t v15 = *a1;
        uint64_t v16 = "create sampling layer failed!";
        goto LABEL_8;
      case 31:
        v551[0] = 0;
        v551[1] = 0;
        uint64_t v566 = 0;
        cstdlib_memset(v551, 0, 0x10uLL);
        *a3 = 4;
        cstdlib_memcpy((char *)&v566 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v397, v398, v399, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy(&v566, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v400, v401, v402, (uint64_t)v66);
        int v403 = v566;
        *a3 = v566;
        uint64_t v404 = *a4;
        uint64_t v405 = (uint64_t)v66;
        v406 = (const char *)(a2 + v404);
        *a4 = v404 + v403;
        v407 = (const char *)v405;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v408, v409, v410, v405);
        tee_paraunsigned int m = config_merge_layer_param(a1, (uint64_t)v551, HIDWORD(v566), v406, v571[14], v50);
        if (tee_param) {
          goto LABEL_180;
        }
        uint64_t v411 = create_merge_layer(a1, v551, &v570);
        if (v411)
        {
          uint64_t v14 = v411;
          uint64_t v15 = *a1;
          uint64_t v16 = "create merge layer failed!";
          goto LABEL_8;
        }
        uint64_t v66 = v407;
        a2 = v550;
        goto LABEL_95;
      case 32:
        LODWORD(v551[0]) = 0;
        cstdlib_memset(v551, 0, 4uLL);
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v412, v413, v414, (uint64_t)v66);
        uint64_t mulaw_layer = create_mulaw_layer(a1, v551, (uint64_t *)&v570);
        if (!mulaw_layer) {
          goto LABEL_95;
        }
        uint64_t v14 = mulaw_layer;
        uint64_t v15 = *a1;
        uint64_t v16 = "create mulaw layer failed!";
        goto LABEL_8;
      case 33:
        v551[0] = 0;
        v551[1] = 0;
        LODWORD(v552[0]) = 0;
        cstdlib_memset(v551, 0, 0x14uLL);
        *a3 = 20;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x14uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v416, v417, v418, (uint64_t)v66);
        uint64_t v419 = create_ffn_layer(a1, (int32x2_t *)v551, &v567, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (!v419) {
          goto LABEL_95;
        }
        uint64_t v14 = v419;
        uint64_t v15 = *a1;
        uint64_t v16 = "create ffn layer failed!";
        goto LABEL_8;
      case 34:
        long long v553 = 0u;
        *(_OWORD *)v551 = 0u;
        memset(v552, 0, sizeof(v552));
        cstdlib_memset(v551, 0, 0x40uLL);
        *a3 = 64;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x40uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v420, v421, v422, (uint64_t)v66);
        uint64_t v423 = create_att_layer(a1, (unsigned int *)v551, &v567, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (!v423) {
          goto LABEL_95;
        }
        uint64_t v14 = v423;
        uint64_t v15 = *a1;
        uint64_t v16 = "create att layer failed!";
        goto LABEL_8;
      case 35:
        *(_OWORD *)v551 = 0u;
        memset(v552, 0, 28);
        cstdlib_memset(v551, 0, 0x2CuLL);
        *a3 = 44;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x2CuLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v424, v425, v426, (uint64_t)v66);
        uint64_t v427 = create_trans_enc_layer(a1, (int *)v551, &v567, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (!v427) {
          goto LABEL_95;
        }
        uint64_t v14 = v427;
        uint64_t v15 = *a1;
        uint64_t v16 = "create trans_enc layer failed!";
        goto LABEL_8;
      case 36:
        memset(v552, 0, sizeof(v552));
        *(_OWORD *)v551 = 0u;
        cstdlib_memset(v551, 0, 0x30uLL);
        *a3 = 48;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x30uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v428, v429, v430, (uint64_t)v66);
        uint64_t v431 = create_trans_encoder(a1, (int *)v551, &v567, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (!v431) {
          goto LABEL_95;
        }
        uint64_t v14 = v431;
        uint64_t v15 = *a1;
        uint64_t v16 = "create trans_encoder failed!";
        goto LABEL_8;
      case 37:
        LODWORD(v553) = 0;
        memset(v552, 0, sizeof(v552));
        *(_OWORD *)v551 = 0u;
        cstdlib_memset(v551, 0, 0x34uLL);
        *a3 = 52;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x34uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v432, v433, v434, (uint64_t)v66);
        uint64_t v435 = create_trans_dec_layer(a1, v551, &v567, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (!v435) {
          goto LABEL_95;
        }
        uint64_t v14 = v435;
        uint64_t v15 = *a1;
        uint64_t v16 = "create trans_dec layer failed!";
        goto LABEL_8;
      case 38:
        *(void *)&long long v553 = 0;
        memset(v552, 0, sizeof(v552));
        *(_OWORD *)v551 = 0u;
        cstdlib_memset(v551, 0, 0x38uLL);
        *a3 = 56;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x38uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v436, v437, v438, (uint64_t)v66);
        uint64_t v439 = create_trans_decoder(a1, (unsigned int *)v551, &v567, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (!v439) {
          goto LABEL_95;
        }
        uint64_t v14 = v439;
        uint64_t v15 = *a1;
        uint64_t v16 = "create trans_decoder failed!";
        goto LABEL_8;
      case 39:
        v551[0] = 0;
        cstdlib_memset(v551, 0, 8uLL);
        *a3 = 8;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 8uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v440, v441, v442, (uint64_t)v66);
        uint64_t v443 = create_embedding_layer(a1, v551, &v570);
        if (!v443) {
          goto LABEL_95;
        }
        uint64_t v14 = v443;
        uint64_t v15 = *a1;
        uint64_t v16 = "create embedding layer failed!";
        goto LABEL_8;
      case 41:
        *(void *)&long long v554 = 0;
        long long v553 = 0u;
        *(_OWORD *)v551 = 0u;
        memset(v552, 0, sizeof(v552));
        cstdlib_memset(v551, 0, 0x48uLL);
        *a3 = 72;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x48uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v444, v445, v446, (uint64_t)v66);
        uint64_t v447 = create_att_albert_layer(a1, (unsigned int *)v551, &v567, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (!v447) {
          goto LABEL_95;
        }
        uint64_t v14 = v447;
        uint64_t v15 = *a1;
        uint64_t v16 = "create att albert layer failed!";
        goto LABEL_8;
      case 42:
        memset(v552, 0, sizeof(v552));
        *(_OWORD *)v551 = 0u;
        cstdlib_memset(v551, 0, 0x30uLL);
        *a3 = 48;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x30uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v448, v449, v450, (uint64_t)v66);
        uint64_t v451 = create_albert_trans_enc_layer(a1, (int32x4_t *)v551, &v567, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (!v451) {
          goto LABEL_95;
        }
        uint64_t v14 = v451;
        uint64_t v15 = *a1;
        uint64_t v16 = "create albert trans_enc layer failed!";
        goto LABEL_8;
      case 43:
        long long v554 = 0u;
        long long v555 = 0u;
        long long v553 = 0u;
        *(_OWORD *)v551 = 0u;
        memset(v552, 0, sizeof(v552));
        cstdlib_memset(v551, 0, 0x60uLL);
        *a3 = 96;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x60uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v452, v453, v454, (uint64_t)v66);
        uint64_t v455 = create_albert_trans_encoder(a1, (int32x4_t *)v551, &v567, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (!v455) {
          goto LABEL_95;
        }
        uint64_t v14 = v455;
        uint64_t v15 = *a1;
        uint64_t v16 = "create albert trans_encoder failed!";
        goto LABEL_8;
      case 50:
        *(_OWORD *)v551 = 0u;
        memset(v552, 0, 20);
        cstdlib_memset(v551, 0, 0x24uLL);
        *a3 = 36;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x24uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v456, v457, v458, (uint64_t)v66);
        tee_paraunsigned int m = create_conv1d_norm_layer(a1, v551, &v567, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (tee_param) {
          goto LABEL_180;
        }
        goto LABEL_95;
      case 51:
        v551[0] = 0;
        cstdlib_memset(v551, 0, 8uLL);
        *a3 = 8;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 8uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v459, v460, v461, (uint64_t)v66);
        tee_paraunsigned int m = create_conv1d_bank(a1, (unsigned int *)v551, &v567, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (tee_param) {
          goto LABEL_180;
        }
        goto LABEL_95;
      case 52:
        v551[0] = 0;
        v551[1] = 0;
        cstdlib_memset(v551, 0, 0x10uLL);
        *a3 = 16;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x10uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v462, v463, v464, (uint64_t)v66);
        tee_paraunsigned int m = create_conv1d_proj_layer(a1, (unsigned int *)v551, &v567, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (tee_param) {
          goto LABEL_180;
        }
        goto LABEL_95;
      case 53:
        v551[0] = 0;
        cstdlib_memset(v551, 0, 8uLL);
        *a3 = 8;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 8uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v465, v466, v467, (uint64_t)v66);
        tee_paraunsigned int m = create_highway_layer(a1, (int *)v551, &v567, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (tee_param) {
          goto LABEL_180;
        }
        goto LABEL_95;
      case 54:
        LODWORD(v551[1]) = 0;
        v551[0] = 0;
        cstdlib_memset(v551, 0, 0xCuLL);
        *a3 = 12;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0xCuLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v468, v469, v470, (uint64_t)v66);
        tee_paraunsigned int m = create_highways(a1, (int *)v551, &v567, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (tee_param) {
          goto LABEL_180;
        }
        goto LABEL_95;
      case 55:
        *(_OWORD *)v551 = 0u;
        memset(v552, 0, 20);
        cstdlib_memset(v551, 0, 0x24uLL);
        *a3 = 36;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x24uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v471, v472, v473, (uint64_t)v66);
        tee_paraunsigned int m = create_cbhg_layer(a1, v551, &v567, (uint64_t)(v571 + 1), &v570);
        if (tee_param) {
          goto LABEL_180;
        }
        goto LABEL_95;
      case 56:
        v551[0] = 0;
        v551[1] = 0;
        *(void *)&v552[0] = 0;
        cstdlib_memset(v551, 0, 0x18uLL);
        *a3 = 24;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x18uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v474, v475, v476, (uint64_t)v66);
        uint64_t v477 = create_gl_layer(a1, &__b, v551, &v570);
        if (!v477) {
          goto LABEL_95;
        }
        uint64_t v14 = v477;
        uint64_t v15 = *a1;
        uint64_t v16 = "create gl layer failed!";
        goto LABEL_8;
      case 62:
        *(void *)&long long v555 = 0;
        long long v553 = 0u;
        long long v554 = 0u;
        memset(v552, 0, sizeof(v552));
        *(_OWORD *)v551 = 0u;
        cstdlib_memset(v551, 0, 0x58uLL);
        *a3 = 88;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x58uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v478, v479, v480, (uint64_t)v66);
        tee_paraunsigned int m = create_tacodecoder_layer(a1, v551, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (tee_param) {
          goto LABEL_180;
        }
        goto LABEL_95;
      case 63:
      case 66:
        long long v559 = 0u;
        memset(v560, 0, 28);
        long long v557 = 0u;
        long long v558 = 0u;
        long long v555 = 0u;
        long long v556 = 0u;
        long long v553 = 0u;
        long long v554 = 0u;
        memset(v552, 0, sizeof(v552));
        *(_OWORD *)v551 = 0u;
        cstdlib_memset(v551, 0, 0xBCuLL);
        *a3 = 188;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0xBCuLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v121, v122, v123, (uint64_t)v66);
        tee_paraunsigned int m = create_tacotron(a1, v551, &v567, (uint64_t)(v571 + 1), __b, (uint64_t *)&v570);
        if (tee_param) {
          goto LABEL_180;
        }
        goto LABEL_95;
      case 64:
        v551[0] = 0;
        cstdlib_memset(v551, 0, 8uLL);
        *a3 = 8;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 8uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v481, v482, v483, (uint64_t)v66);
        uint64_t v484 = create_invpreemph_layer(a1, &__b, v551, &v570);
        if (!v484) {
          goto LABEL_95;
        }
        uint64_t v14 = v484;
        uint64_t v15 = *a1;
        uint64_t v16 = "create invpreemph layer failed!";
        goto LABEL_8;
      case 65:
        long long v559 = 0u;
        memset(v560, 0, 20);
        long long v557 = 0u;
        long long v558 = 0u;
        long long v555 = 0u;
        long long v556 = 0u;
        long long v553 = 0u;
        long long v554 = 0u;
        memset(v552, 0, sizeof(v552));
        *(_OWORD *)v551 = 0u;
        cstdlib_memset(v551, 0, 0xB4uLL);
        *a3 = 180;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0xB4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v485, v486, v487, (uint64_t)v66);
        tee_paraunsigned int m = create_lpcnet_layer(a1, (int *)v551, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (tee_param) {
          goto LABEL_180;
        }
        goto LABEL_95;
      case 67:
        LODWORD(v564) = 0;
        long long v562 = 0u;
        long long v563 = 0u;
        long long v561 = 0u;
        long long v559 = 0u;
        memset(v560, 0, sizeof(v560));
        long long v557 = 0u;
        long long v558 = 0u;
        long long v555 = 0u;
        long long v556 = 0u;
        long long v553 = 0u;
        long long v554 = 0u;
        memset(v552, 0, sizeof(v552));
        *(_OWORD *)v551 = 0u;
        cstdlib_memset(v551, 0, 0xF4uLL);
        *a3 = 244;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0xF4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v488, v489, v490, (uint64_t)v66);
        tee_paraunsigned int m = create_multiband_lpcnet_layer(a1, (int *)v551, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (tee_param) {
          goto LABEL_180;
        }
        goto LABEL_95;
      case 68:
        uint64_t v565 = 0;
        long long v563 = 0u;
        long long v564 = 0u;
        long long v561 = 0u;
        long long v562 = 0u;
        memset(v560, 0, sizeof(v560));
        long long v558 = 0u;
        long long v559 = 0u;
        long long v556 = 0u;
        long long v557 = 0u;
        long long v554 = 0u;
        long long v555 = 0u;
        long long v553 = 0u;
        *(_OWORD *)v551 = 0u;
        memset(v552, 0, sizeof(v552));
        cstdlib_memset(v551, 0, 0x108uLL);
        *a3 = 264;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x108uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v491, v492, v493, (uint64_t)v66);
        tee_paraunsigned int m = create_tacotron_stream(a1, (int32x2_t *)v551, &v567, (uint64_t)(v571 + 1), __b, (uint64_t *)&v570);
        if (tee_param) {
          goto LABEL_180;
        }
        goto LABEL_95;
      case 69:
        *(_OWORD *)v551 = 0u;
        memset(v552, 0, 20);
        cstdlib_memset(v551, 0, 0x24uLL);
        v551[1] = (void *)0x100000001;
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v494, v495, v496, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v551 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v497, v498, v499, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy(v552, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v500, v501, v502, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v552 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v503, v504, v505, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v552 + 12, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v506, v507, v508, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy(&v552[1], (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v509, v510, v511, (uint64_t)v66);
        if (fi_feat_is_enabled((uint64_t)v571[4], 0, *((_DWORD *)v571 + 6)))
        {
          *a3 = 4;
          cstdlib_memcpy(&v551[1], (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v512, v513, v514, (uint64_t)v66);
          *a3 = 4;
          cstdlib_memcpy((char *)&v551[1] + 4, (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v515, v516, v517, (uint64_t)v66);
        }
        if (fi_feat_is_enabled((uint64_t)v571[4], 1u, *((_DWORD *)v571 + 6)))
        {
          *a3 = 4;
          cstdlib_memcpy((char *)v552 + 8, (const void *)(a2 + *a4), 4uLL);
          *a4 += *a3;
          log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v518, v519, v520, (uint64_t)v66);
        }
        else
        {
          DWORD2(v552[0]) = 1;
        }
        uint64_t convtrans1d_layer = create_convtrans1d_layer(a1, v551, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (!convtrans1d_layer) {
          goto LABEL_95;
        }
        uint64_t v14 = convtrans1d_layer;
        uint64_t v15 = *a1;
        uint64_t v16 = "create convtrans1d layer failed!";
        goto LABEL_8;
      case 70:
        *(void *)&long long v557 = 0;
        long long v555 = 0u;
        long long v556 = 0u;
        long long v553 = 0u;
        long long v554 = 0u;
        memset(v552, 0, sizeof(v552));
        *(_OWORD *)v551 = 0u;
        cstdlib_memset(v551, 0, 0x78uLL);
        *a3 = 120;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x78uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v521, v522, v523, (uint64_t)v66);
        tee_paraunsigned int m = create_mrf_layer(a1, (unsigned int *)v551, (uint64_t)(v571 + 1), (uint64_t *)&v570);
        if (tee_param) {
          goto LABEL_180;
        }
        goto LABEL_95;
      case 71:
        v551[0] = 0;
        cstdlib_memset(v551, 0, 8uLL);
        *a3 = 4;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v524, v525, v526, (uint64_t)v66);
        *a3 = 4;
        cstdlib_memcpy((char *)v551 + 4, (const void *)(a2 + *a4), 4uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v527, v528, v529, (uint64_t)v66);
        tee_paraunsigned int m = create_pqmf_layer(a1, v551, &v570);
        if (!tee_param) {
          goto LABEL_95;
        }
LABEL_180:
        uint64_t v14 = tee_param;
        goto LABEL_9;
      case 72:
        *(_OWORD *)v551 = 0u;
        memset(v552, 0, 28);
        cstdlib_memset(v551, 0, 0x2CuLL);
        *a3 = 44;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x2CuLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v530, v531, v532, (uint64_t)v66);
        uint64_t v533 = create_reshape_layer(a1, v551, &v570);
        if (!v533) {
          goto LABEL_95;
        }
        uint64_t v14 = v533;
        uint64_t v15 = *a1;
        uint64_t v16 = "create reshape layer failed!";
        goto LABEL_8;
      case 73:
        *(_OWORD *)v551 = 0u;
        v552[0] = 0u;
        cstdlib_memset(v551, 0, 0x20uLL);
        *a3 = 32;
        cstdlib_memcpy(v551, (const void *)(a2 + *a4), 0x20uLL);
        *a4 += *a3;
        log_OutText(*a1, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v534, v535, v536, (uint64_t)v66);
        uint64_t v537 = create_upsample_layer(a1, v551, &v570);
        if (!v537) {
          goto LABEL_95;
        }
        uint64_t v14 = v537;
        uint64_t v15 = *a1;
        uint64_t v16 = "create upsample layer failed!";
        goto LABEL_8;
      default:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"error: unknown layer type %s!", v63, v64, v65, (uint64_t)v66);
        uint64_t v14 = 7;
        goto LABEL_9;
    }
  }
}