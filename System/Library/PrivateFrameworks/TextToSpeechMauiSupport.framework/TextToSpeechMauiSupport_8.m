char *mfs_bnfData_Delta_norm(char *result, char *a2, unsigned int a3, float *a4)
{
  uint64_t v4;
  float v5;
  uint64_t v6;
  char *v7;
  char *v8;
  float v9;
  int v10;
  float v11;
  int v12;
  float v13;
  float v14;
  int v15;
  float v16;
  int v17;

  if (a3)
  {
    v4 = a3;
    v5 = 0.0;
    v6 = a3;
    v7 = a2;
    v8 = result;
    v9 = 0.0;
    do
    {
      v10 = *v8++;
      v11 = (float)(v10 * v10);
      v12 = *v7++;
      v9 = v9 + v11;
      v5 = v5 + (float)(v12 * v12);
      --v6;
    }
    while (v6);
    v13 = sqrtf(v9);
    v14 = sqrtf(v5);
    do
    {
      v15 = *result++;
      v16 = (float)v15;
      v17 = *a2++;
      *a4++ = (float)(v16 / v13) - (float)((float)v17 / v14);
      --v4;
    }
    while (v4);
  }
  return result;
}

float mfs_bnfData_CosineCost(char *a1, char *a2, unsigned int a3)
{
  if (a3)
  {
    int v3 = 0;
    int v4 = 0;
    int v5 = 0;
    uint64_t v6 = a3;
    do
    {
      int v8 = *a1++;
      int v7 = v8;
      int v9 = *a2++;
      v5 += v9 * v7;
      v4 += v7 * v7;
      v3 += v9 * v9;
      --v6;
    }
    while (v6);
    float v10 = (float)v5;
    float v11 = (float)v4;
    float v12 = (float)v3;
  }
  else
  {
    float v10 = 0.0;
    float v11 = 0.0;
    float v12 = 0.0;
  }
  return 1.0 - (float)(v10 / (float)(sqrtf(v11) * sqrtf(v12)));
}

float mfs_bnfData_CosineCost_LeftSidedPreNormalised(float *a1, char *a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    float v4 = 0.0;
    float v5 = 0.0;
    do
    {
      int v7 = *a2++;
      int v6 = v7;
      float v8 = (float)v7;
      float v9 = *a1++;
      float v5 = v5 + (float)(v8 * v9);
      float v4 = v4 + (float)(v6 * v6);
      --v3;
    }
    while (v3);
  }
  else
  {
    float v5 = 0.0;
    float v4 = 0.0;
  }
  return 1.0 - (float)(v5 / sqrtf(v4));
}

float mfs_bnfData_CosineCost_Normalised(float *a1, float *a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    float v4 = 0.0;
    do
    {
      float v5 = *a2++;
      float v6 = v5;
      float v7 = *a1++;
      float v4 = v4 + (float)(v6 * v7);
      --v3;
    }
    while (v3);
  }
  else
  {
    float v4 = 0.0;
  }
  return 1.0 - v4;
}

float mfs_bnfData_CosineCost_F32(float *a1, float *a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    float v4 = 0.0;
    float v5 = 0.0;
    float v6 = 0.0;
    do
    {
      float v7 = *a1++;
      float v8 = v7;
      float v9 = *a2++;
      float v6 = v6 + (float)(v8 * v9);
      float v5 = v5 + (float)(v8 * v8);
      float v4 = v4 + (float)(v9 * v9);
      --v3;
    }
    while (v3);
  }
  else
  {
    float v6 = 0.0;
    float v5 = 0.0;
    float v4 = 0.0;
  }
  return 1.0 - (float)(v6 / (float)(sqrtf(v5) * sqrtf(v4)));
}

float mfs_bnfData_Distance(uint64_t a1, float *a2, unsigned int a3)
{
  uint64_t v3 = *(unsigned __int8 *)(a1 + 1932);
  if (*(unsigned char *)(a1 + 1932))
  {
    float v4 = (char *)(*(void *)(a1 + 1936) + v3 * a3);
    float v5 = 0.0;
    float v6 = 0.0;
    do
    {
      int v8 = *v4++;
      int v7 = v8;
      float v9 = (float)v8;
      float v10 = *a2++;
      float v6 = v6 + (float)(v9 * v10);
      float v5 = v5 + (float)(v7 * v7);
      --v3;
    }
    while (v3);
  }
  else
  {
    float v6 = 0.0;
    float v5 = 0.0;
  }
  float result = 1.0 - (float)(v6 / sqrtf(v5));
  uint64_t v12 = *(void *)(a1 + 1904);
  if (v12) {
    return result * *(float *)(v12 + 4 * a3);
  }
  return result;
}

uint64_t mfs_bnfData_Clusterize_Block_Distance_fxd16(uint64_t a1, uint64_t a2, __int16 *a3, unsigned int a4, int a5, uint64_t a6, float a7)
{
  uint64_t v35 = 0;
  uint64_t v11 = a5 - 2;
  uint64_t v12 = *(unsigned __int8 *)(a1 + 1520);
  v13 = (void *)(a1 + 8 * v11);
  uint64_t v14 = a4;
  uint64_t v15 = *(unsigned int *)(v13[108] + 4 * a4);
  if (*(_DWORD *)(a1 + 1524) != 1)
  {
    uint64_t v21 = 0;
    uint64_t v35 = *(void *)(v13[134] + 8 * a4);
    if (!v15) {
      goto LABEL_11;
    }
LABEL_6:
    unsigned int v22 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = *(void *)(*(void *)(a1 + 8 * v11 + 1136) + 8 * v14);
    uint64_t v25 = v35;
    do
    {
      int v26 = 0;
      if (v12)
      {
        uint64_t v27 = v12;
        v28 = a3;
        v29 = (char *)(v25 + v22);
        do
        {
          int v31 = *v29++;
          int v30 = v31;
          int v32 = *v28++;
          v26 += v32 * v30;
          --v27;
        }
        while (v27);
      }
      *(float *)(a6 + 4 * v23) = (float)((float)-(float)(*(float *)(v24 + 4 * v23) * (float)v26) * a7) + 1.0;
      ++v23;
      v22 += v12;
    }
    while (v23 != v15);
    goto LABEL_11;
  }
  uint64_t v34 = a2;
  uint64_t v21 = brk_DataMap(*(void *)(a2 + 24), *(void *)(a1 + 2464), (*(_DWORD *)(v13[192] + 4 * a4) + *(_DWORD *)(a1 + 1528)), (v15 * v12), (uint64_t)&v35);
  if ((v21 & 0x80000000) != 0)
  {
    UNICORN__log_select_Error(v34, 74001, (uint64_t)"ODLBNF DataMap (%u,%u) Error %x", v16, v17, v18, v19, v20);
    return v21;
  }
  a2 = v34;
  if (v15) {
    goto LABEL_6;
  }
LABEL_11:
  if (*(_DWORD *)(a1 + 1524) == 1) {
    return brk_DataUnmap(*(void *)(a2 + 24), *(void *)(a1 + 2464), v35);
  }
  return v21;
}

uint64_t mfs_bnfData_Clusterize_Block_Distance_RandomProjection(uint64_t a1, uint64_t a2, char *a3, unsigned int a4, int a5, uint64_t a6)
{
  uint64_t v43 = 0;
  unint64_t v10 = *(unsigned __int8 *)(a1 + 1520);
  if (*(unsigned char *)(a1 + 1520)) {
    float v11 = 3.1416 / (float)((float)v10 * 8.0);
  }
  else {
    float v11 = 0.3927;
  }
  uint64_t v12 = (void *)(a1 + 8 * (a5 - 2));
  uint64_t v13 = *(unsigned int *)(v12[108] + 4 * a4);
  if (*(_DWORD *)(a1 + 1524) != 1)
  {
    uint64_t v40 = 0;
    uint64_t v41 = a1;
    uint64_t v39 = a2;
    uint64_t v43 = *(void *)(v12[134] + 8 * a4);
    if (!v13) {
      goto LABEL_21;
    }
    goto LABEL_9;
  }
  uint64_t v14 = brk_DataMap(*(void *)(a2 + 24), *(void *)(a1 + 2464), (*(_DWORD *)(v12[192] + 4 * a4) + *(_DWORD *)(a1 + 1528)), (v13 * v10), (uint64_t)&v43);
  uint64_t v20 = v14;
  if ((v14 & 0x80000000) != 0)
  {
    UNICORN__log_select_Error(a2, 74001, (uint64_t)"ODLBNF DataMap (%u,%u) Error %x", v15, v16, v17, v18, v19);
    return v20;
  }
  uint64_t v40 = v14;
  uint64_t v41 = a1;
  uint64_t v39 = a2;
  if (v13)
  {
LABEL_9:
    unsigned int v21 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = v43;
    uint64_t v42 = v43 + 1;
    uint64_t v24 = a3 + 1;
    do
    {
      if ((v10 & 3) != 0)
      {
        if (v10)
        {
          unsigned int v25 = 0;
          unint64_t v26 = v10;
          uint64_t v27 = a3;
          v28 = (char *)(v23 + v21);
          do
          {
            char v30 = *v27++;
            char v29 = v30;
            char v31 = *v28++;
            v25 += BitsSetTable256[(v31 ^ v29)];
            --v26;
          }
          while (v26);
          goto LABEL_20;
        }
      }
      else if (v10)
      {
        unint64_t v32 = 0;
        int v33 = 0;
        int v34 = 0;
        int v35 = 0;
        int v36 = 0;
        uint64_t v37 = v42 + v21;
        do
        {
          v36 += BitsSetTable256[(*(unsigned char *)(v37 + v32 - 1) ^ a3[v32])];
          v35 += BitsSetTable256[*(unsigned char *)(v37 + v32) ^ v24[v32]];
          v34 += BitsSetTable256[*(unsigned char *)(v37 + v32 + 1) ^ v24[v32 + 1]];
          v33 += BitsSetTable256[*(unsigned char *)(v37 + v32 + 2) ^ v24[v32 + 2]];
          v32 += 4;
        }
        while (v32 < v10);
        unsigned int v25 = v35 + v36 + v34 + v33;
        goto LABEL_20;
      }
      unsigned int v25 = 0;
LABEL_20:
      *(float *)(a6 + 4 * v22++) = 1.0 - cosf(v11 * (float)v25);
      v21 += v10;
    }
    while (v22 != v13);
  }
LABEL_21:
  uint64_t v20 = v40;
  if (*(_DWORD *)(v41 + 1524) == 1) {
    return brk_DataUnmap(*(void *)(v39 + 24), *(void *)(v41 + 2464), v43);
  }
  return v20;
}

uint64_t mfs_bnfData_Distance_Unit_ID_fxd16(uint64_t result, uint64_t a2, __int16 *a3, unsigned int a4)
{
  uint64_t v6 = result;
  uint64_t v19 = 0;
  uint64_t v7 = *(unsigned __int8 *)(result + 1520);
  if (*(_DWORD *)(result + 1524) == 1)
  {
    float result = brk_DataMap(*(void *)(a2 + 24), *(void *)(result + 2464), (*(_DWORD *)(result + 1528)+ *(_DWORD *)(*(void *)(result + 848)+ 4 * (a4 / *(_DWORD *)(*(void *)(result + 568) + 5992)))* v7), v7, (uint64_t)&v19);
    if ((result & 0x80000000) != 0) {
      return UNICORN__log_select_Error(a2, 74001, (uint64_t)"ODLBNF DataMap (%u,%u) Error %x", v8, v9, v10, v11, v12);
    }
    uint64_t v13 = v19;
  }
  else
  {
    uint64_t v13 = *(void *)(result + 1000)
        + (*(_DWORD *)(*(void *)(result + 848)
                                   + 4 * (a4 / *(_DWORD *)(*(void *)(result + 568) + 5992)))
                       * v7);
    uint64_t v19 = v13;
  }
  if (v7)
  {
    int v14 = 0;
    uint64_t v15 = (char *)v13;
    do
    {
      int v17 = *v15++;
      int v16 = v17;
      int v18 = *a3++;
      v14 += v18 * v16;
      --v7;
    }
    while (v7);
  }
  if (*(_DWORD *)(v6 + 1524) == 1) {
    return brk_DataUnmap(*(void *)(a2 + 24), *(void *)(v6 + 2464), v13);
  }
  return result;
}

void mfs_bnfData_Distance_Unit_ID_RandomProjection(uint64_t a1, uint64_t a2, char *a3, unsigned int a4)
{
  unint64_t v7 = *(unsigned __int8 *)(a1 + 1520);
  uint64_t v27 = 0;
  if (v7) {
    float v8 = 3.1416 / (float)((float)v7 * 8.0);
  }
  else {
    float v8 = 0.3927;
  }
  if (*(_DWORD *)(a1 + 1524) == 1)
  {
    if ((brk_DataMap(*(void *)(a2 + 24), *(void *)(a1 + 2464), (*(_DWORD *)(a1 + 1528)+ *(_DWORD *)(*(void *)(a1 + 848) + 4 * (a4 / *(_DWORD *)(*(void *)(a1 + 568) + 5992)))* v7), v7, (uint64_t)&v27) & 0x80000000) != 0)
    {
      UNICORN__log_select_Error(a2, 74001, (uint64_t)"ODLBNF DataMap (%u,%u) Error %x", v9, v10, v11, v12, v13);
      return;
    }
    uint64_t v14 = v27;
  }
  else
  {
    uint64_t v14 = *(void *)(a1 + 1000)
        + (*(_DWORD *)(*(void *)(a1 + 848) + 4 * (a4 / *(_DWORD *)(*(void *)(a1 + 568) + 5992)))
                       * v7);
    uint64_t v27 = v14;
  }
  if ((v7 & 3) != 0)
  {
    if (v7)
    {
      unsigned int v15 = 0;
      int v16 = (char *)v14;
      do
      {
        char v18 = *a3++;
        char v17 = v18;
        char v19 = *v16++;
        v15 += BitsSetTable256[(v19 ^ v17)];
        --v7;
      }
      while (v7);
      goto LABEL_18;
    }
  }
  else if (v7)
  {
    unint64_t v20 = 0;
    int v21 = 0;
    int v22 = 0;
    int v23 = 0;
    int v24 = 0;
    uint64_t v25 = v14 + 1;
    unint64_t v26 = a3 + 1;
    do
    {
      v24 += BitsSetTable256[(*(unsigned char *)(v14 + v20) ^ a3[v20])];
      v23 += BitsSetTable256[*(unsigned char *)(v25 + v20) ^ v26[v20]];
      v22 += BitsSetTable256[*(unsigned char *)(v25 + v20 + 1) ^ v26[v20 + 1]];
      v21 += BitsSetTable256[*(unsigned char *)(v25 + v20 + 2) ^ v26[v20 + 2]];
      v20 += 4;
    }
    while (v20 < v7);
    unsigned int v15 = v23 + v24 + v22 + v21;
    goto LABEL_18;
  }
  unsigned int v15 = 0;
LABEL_18:
  cosf(v8 * (float)v15);
  if (*(_DWORD *)(a1 + 1524) == 1) {
    brk_DataUnmap(*(void *)(a2 + 24), *(void *)(a1 + 2464), v14);
  }
}

uint64_t clamp_u32(unsigned int a1, unsigned int a2, unsigned int a3)
{
  if (a1 >= a3) {
    unsigned int v3 = a3;
  }
  else {
    unsigned int v3 = a1;
  }
  if (a1 >= a2) {
    return v3;
  }
  else {
    return a2;
  }
}

uint64_t clamp_s32(signed int a1, unsigned int a2, signed int a3)
{
  if (a1 >= a3) {
    unsigned int v3 = a3;
  }
  else {
    unsigned int v3 = a1;
  }
  if (a1 >= (int)a2) {
    return v3;
  }
  else {
    return a2;
  }
}

uint64_t UNICORN__redistributeInjectDur(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10 = UNICORN__mfs_SegmentList_Length(a1 + 1552);
  if (*a2 != 3) {
    return 2229280775;
  }
  if (v10 >= 7)
  {
    uint64_t v11 = 0;
    int v12 = *(_DWORD *)(a3 + 24);
    int v13 = 4 * v12;
    int v14 = 3 * v12;
    unsigned int v15 = (unsigned int *)(a5 + 16);
    int v16 = (_DWORD *)(a4 + 196);
    uint64_t v17 = 28 * (v10 - 3) - 84;
    uint64_t v18 = 3;
    do
    {
      int v19 = *a2;
      BOOL v20 = (*a2 & 1) == 0 || v19 < 2;
      unsigned int v21 = (*a2 - 1) >> 1;
      if (v20) {
        unsigned int v21 = (*a2 >> 1) - 1;
      }
      if (v18 != v21 + (int)v18 / *a2 * v19) {
        goto LABEL_48;
      }
      if (*(v16 - 11) == 1 && !*(v16 - 21))
      {
        unsigned int v22 = *(v15 - 2);
        uint64_t v23 = *(void *)(a1 + 1568);
        unsigned int v24 = *(_DWORD *)(v23 + v11 + 68);
        int v25 = v22 - v24;
        if (v22 > v24)
        {
          if (v25 >= 0) {
            int v26 = v22 - v24;
          }
          else {
            int v26 = v25 + 1;
          }
          int v27 = v26 >> 1;
          if (v25 >= v13) {
            int v25 = v27;
          }
          *(v15 - 1) += v25;
          unsigned int v28 = v22 - v25;
          goto LABEL_19;
        }
        if (v22 < v24)
        {
          BOOL v29 = __OFSUB__(v24, v22);
          int v30 = v24 - v22;
          if (v30 < 0 != v29) {
            int v31 = v30 + 1;
          }
          else {
            int v31 = v30;
          }
          int v32 = v31 >> 1;
          if (v30 >= v13) {
            int v30 = v32;
          }
          if (*(_DWORD *)(v23 + v11 + 96) > v14)
          {
            int v33 = *(v15 - 1);
            if (v25 + v33 > v14)
            {
              *(v15 - 1) = v33 - v30;
              unsigned int v28 = v22 + v30;
LABEL_19:
              *(v15 - 2) = v28;
            }
          }
        }
      }
      if (*(v16 - 10) == 1 && !*v16)
      {
        unsigned int v34 = *v15;
        uint64_t v35 = *(void *)(a1 + 1568);
        unsigned int v36 = *(_DWORD *)(v35 + v11 + 124);
        int v37 = *v15 - v36;
        if (*v15 <= v36)
        {
          if (v34 >= v36) {
            goto LABEL_48;
          }
          BOOL v29 = __OFSUB__(v36, v34);
          int v41 = v36 - v34;
          if (v41 < 0 != v29) {
            int v42 = v41 + 1;
          }
          else {
            int v42 = v41;
          }
          int v43 = v42 >> 1;
          if (v41 >= v13) {
            int v41 = v43;
          }
          if (*(_DWORD *)(v35 + v11 + 96) <= v14) {
            goto LABEL_48;
          }
          int v44 = *(v15 - 1);
          if (v37 + v44 <= v14) {
            goto LABEL_48;
          }
          *(v15 - 1) = v44 - v41;
          unsigned int v40 = v34 + v41;
        }
        else
        {
          if (v37 >= 0) {
            int v38 = *v15 - v36;
          }
          else {
            int v38 = v37 + 1;
          }
          int v39 = v38 >> 1;
          if (v37 >= v13) {
            int v37 = v39;
          }
          *(v15 - 1) += v37;
          unsigned int v40 = v34 - v37;
        }
        *unsigned int v15 = v40;
      }
LABEL_48:
      ++v15;
      v16 += 10;
      v11 += 28;
      ++v18;
    }
    while (v17 != v11);
  }
  return 0;
}

uint64_t mfs_Psola_CalculateAdjustments_ByOne(int *a1, uint64_t a2, uint64_t a3, int a4, int a5, int *a6)
{
  uint64_t v11 = (uint64_t)a1;
  uint64_t v102 = *MEMORY[0x263EF8340];
  int v12 = *a1;
  uint64_t v13 = *(void *)(a2 + 1568);
  uint64_t v14 = a4;
  uint64_t v15 = *(void *)(a2 + 1536);
  int v16 = (unsigned int *)(a3 + 40 * a4);
  if (a4 <= 0) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = (unsigned int *)(a3 + 40 * (a4 - 1));
  }
  unsigned int v18 = *(_DWORD *)(v13 + 28 * a4);
  v97 = v16;
  *int v16 = v18;
  if (v18 == -1)
  {
    int v19 = 0;
  }
  else
  {
    int v19 = *(_DWORD *)(v13 + 28 * a4 + 8);
    uint64_t v15 = v13;
  }
  int v20 = *(_DWORD *)(v15 + 28 * a4 + 12);
  unsigned int v21 = (_DWORD *)(a3 + 40 * a4);
  v21[1] = v19;
  v21[2] = v20;
  v21[5] = 1000;
  if (!a4)
  {
    uint64_t v46 = a3 + 40 * a4;
    *(_DWORD *)(v46 + 32) = 0;
    *(_DWORD *)(v46 + 12) = 1000;
    goto LABEL_97;
  }
  int v96 = v12;
  BOOL v22 = *v17 + 1 == v18;
  if (*v17 + 1 == v18) {
    int v23 = 1;
  }
  else {
    int v23 = 100;
  }
  uint64_t v24 = a3 + 40 * a4;
  *(_DWORD *)(v24 + 32) = v22;
  int v25 = (_DWORD *)(v24 + 32);
  v17[9] = v22;
  *(v25 - 2) = v23;
  v17[7] = v23;
  *(v25 - 5) = 1000;
  int v26 = v25 - 5;
  v17[4] = 1000;
  int v27 = UnicornAddon_UID2AddonId(*(void *)(a2 + 1776), *(_DWORD *)(a2 + 1784), v18);
  uint64_t v28 = *(void *)(a2 + 1776);
  uint64_t v29 = v11;
  if (v27 != -1)
  {
    uint64_t v30 = v28 + 48 * v27;
    uint64_t v29 = *(void *)(v30 + 16);
    *v97 -= *(_DWORD *)(v30 + 24);
  }
  uint64_t v95 = v29;
  int v94 = v27;
  int v31 = UnicornAddon_UID2AddonId(v28, *(_DWORD *)(a2 + 1784), *v17);
  if (v31 != -1)
  {
    uint64_t v32 = *(void *)(a2 + 1776) + 48 * v31;
    uint64_t v11 = *(void *)(v32 + 16);
    *v17 -= *(_DWORD *)(v32 + 24);
  }
  int v33 = v96;
  int v34 = a4 / v96;
  uint64_t v35 = (unsigned int *)v95;
  unsigned int v36 = *(_DWORD **)(v95 + 568);
  int v37 = v36[2880];
  if ((v37 - 1) <= 1 && !*v25 && *v17 != -1)
  {
    unsigned int v47 = *v97;
    if (*v97 != -1)
    {
      int v91 = v31;
      int v92 = a5;
      uint64_t v101 = 0;
      long long v99 = 0u;
      long long v100 = 0u;
      unsigned int v98 = 0;
      UNICORN__mfs_Stub_ParamMap_GetAcousticVector(*(void *)(a2 + 1072), v95, a2, v47, (uint64_t)&v99, (int *)&v98, 0.0);
      v93 = a6;
      if (v48 < 0 || (uint64_t v49 = v98, (int)v98 < 1))
      {
LABEL_32:
        int v52 = 1000;
      }
      else
      {
        v50 = (float *)v100;
        while (1)
        {
          float v51 = exp(*v50);
          int v52 = (int)(v51 + 0.5);
          if (v52 >= 10) {
            break;
          }
          ++v50;
          if (!--v49) {
            goto LABEL_32;
          }
        }
      }
      unsigned int v53 = *v17;
      uint64_t v101 = 0;
      long long v99 = 0u;
      long long v100 = 0u;
      unsigned int v98 = 0;
      UNICORN__mfs_Stub_ParamMap_GetAcousticVector(*(void *)(a2 + 1072), v11, a2, v53, (uint64_t)&v99, (int *)&v98, 0.0);
      if (v54 < 0 || (uint64_t v55 = v98, (int)v98 < 1))
      {
LABEL_38:
        int v59 = 1000;
        int v60 = 1000;
        a6 = v93;
        int v31 = v91;
        a5 = v92;
        int v33 = v96;
        int v34 = a4 / v96;
        uint64_t v35 = (unsigned int *)v95;
      }
      else
      {
        uint64_t v56 = v100;
        while (1)
        {
          float v57 = exp(*(float *)(v56 + 4 * ((int)v55 - 1)));
          int v58 = (int)(v57 + 0.5);
          if (v58 > 9) {
            break;
          }
          if (!--v55) {
            goto LABEL_38;
          }
        }
        int v59 = 1000;
        a6 = v93;
        int v31 = v91;
        a5 = v92;
        int v33 = v96;
        int v34 = a4 / v96;
        uint64_t v35 = (unsigned int *)v95;
        int v60 = 1000;
        if (v52 != 1000 && v58 != 1000)
        {
          int v89 = v52 + v58;
          if (v52 + v58 < 0 != __OFADD__(v52, v58)) {
            ++v89;
          }
          int v90 = 1000 * (v89 >> 1);
          int v59 = v90 / v52;
          int v60 = v90 / v58;
        }
      }
      *int v26 = v59;
      v17[4] = v60;
      unsigned int v36 = (_DWORD *)*((void *)v35 + 71);
      int v37 = v36[2880];
    }
  }
  int v38 = a4 - v34 * v33;
  if ((v37 & 0xFFFFFFFE) == 2)
  {
    if (v38 + 1 == v33)
    {
      unint64_t v39 = *v35;
      uint64_t v40 = (int)*v35 * (uint64_t)v34;
      if ((int)*v35 < 1) {
        goto LABEL_40;
      }
      int v41 = 0;
      int v42 = (int *)(a3 + 40 * v40 + 8);
      uint64_t v43 = *v35;
      do
      {
        int v44 = *v42;
        v42 += 10;
        v41 += v44;
        --v43;
      }
      while (v43);
      if (v41 < 1) {
LABEL_40:
      }
        int v45 = 1000;
      else {
        int v45 = (int)(float)((float)(*(float *)(*(void *)(a2 + 384) + 312 * v34 + 32) * 1000.0) / (float)v41);
      }
      if (*(_DWORD *)(a3 + 40 * v40) + v39 - 1 != *(_DWORD *)(a3 + 40 * ((int)v39 - 1 + (int)v40)))
      {
        if ((int)v39 < 1) {
          goto LABEL_58;
        }
        int v61 = v36[6];
        if (*(_DWORD *)(a3 + 40 * v40 + 8) == v61)
        {
LABEL_44:
          if (v45 >= 1300) {
            int v45 = 1300;
          }
          if (v45 <= 700) {
            int v45 = 700;
          }
        }
        else
        {
          unint64_t v77 = 0;
          v78 = (int *)(a3 + 40 * v40 + 48);
          while (v39 - 1 != v77)
          {
            int v79 = *v78;
            v78 += 10;
            ++v77;
            if (v79 == v61)
            {
              if (v77 < v39) {
                goto LABEL_44;
              }
              break;
            }
          }
        }
      }
      int v62 = v36[2886];
      if (v45 < v62) {
        int v62 = v45;
      }
      if (v45 >= v36[2885]) {
        int v63 = v62;
      }
      else {
        int v63 = v36[2885];
      }
      if ((int)v39 >= 1)
      {
        v64 = (_DWORD *)(a3 + 40 * v40);
        do
        {
          if (*v64 != -1) {
            v64[5] = v63;
          }
          v64 += 10;
          --v39;
        }
        while (v39);
      }
    }
LABEL_58:
    if (v38 && a4 + 1 != a5) {
      goto LABEL_61;
    }
  }
  *a6 = a4;
LABEL_61:
  uint64_t v65 = *(void *)(a2 + 8);
  if (*(unsigned char *)(*(void *)(v65 + 32) + v34) == 1 && v38 == v33 - 1 && v33 - 1 <= a4)
  {
    int v66 = v34 | *(unsigned __int16 *)(*(void *)(v65 + 1784) + 2 * v34);
    if ((int)*(float *)(*(void *)(a2 + 384) + 312 * v34 + 32) > 50 && v66 == 0) {
      int v68 = 50;
    }
    else {
      int v68 = (int)*(float *)(*(void *)(a2 + 384) + 312 * v34 + 32);
    }
    uint64_t v69 = v14 - v38;
    if (v33 == 2 && *(_DWORD *)(a3 + 40 * (int)v69) == -1 && (uint64_t v70 = (int)v69 + 1, *(_DWORD *)(a3 + 40 * v70) == -1))
    {
      int v86 = v36[6];
      *(_DWORD *)(a3 + 40 * (int)v69 + 8) = v86;
      BOOL v87 = __OFSUB__(v68, v86);
      int v88 = v68 - v86;
      if ((v88 < 0) ^ v87 | (v88 == 0)) {
        *(_DWORD *)(a3 + 40 * v70 + 8) = 0;
      }
      else {
        *(_DWORD *)(a3 + 40 * v70 + 8) = v88;
      }
    }
    else
    {
      uint64_t v71 = v69 + 1;
      if (*(_DWORD *)(a3 + 40 * (v69 + 1)) == -1)
      {
        int v72 = v31;
        int v73 = a5;
        if (v33 < 1)
        {
          int v74 = 0;
        }
        else
        {
          int v74 = 0;
          uint64_t v69 = (int)v69;
          v75 = (_DWORD *)(40 * (int)v14 - 40 * v38 + a3 + 8);
          do
          {
            if (v71 != v69) {
              v74 += *v75;
            }
            v75 += 10;
          }
          while (v69++ < v14);
        }
        if (v68 <= v74) {
          int v80 = 0;
        }
        else {
          int v80 = v68 - v74;
        }
        uint64_t v81 = a3 + 40 * v71;
        UNICORN__log_select_Diag(*(void *)(a2 + 1072), 2, (uint64_t)"PSOLA: changing dead unit duration from %d to %d ms");
        *(_DWORD *)(v81 + 8) = v80;
        a5 = v73;
        int v31 = v72;
      }
    }
  }
  if (v94 == -1) {
    int v82 = 0;
  }
  else {
    int v82 = *(_DWORD *)(*(void *)(a2 + 1776) + 48 * v94 + 24);
  }
  *v97 += v82;
  if (v31 == -1) {
    int v83 = 0;
  }
  else {
    int v83 = *(_DWORD *)(*(void *)(a2 + 1776) + 48 * v31 + 24);
  }
  *v17 += v83;
LABEL_97:
  if (a4 + 1 >= a5)
  {
    uint64_t v84 = a3 + 40 * (int)v14;
    *(_DWORD *)(v84 + 36) = 0;
    *(_DWORD *)(v84 + 16) = 1000;
    *a6 = a5;
  }
  return 0;
}

uint64_t UnicornSearch_StageTwo_TreeIndex_Cascaded(uint64_t a1, uint64_t a2)
{
  uint64_t v204 = *MEMORY[0x263EF8340];
  memset(v199, 0, sizeof(v199));
  long long v197 = 0u;
  long long v198 = 0u;
  long long __b = 0u;
  unsigned int v2 = a2 + *(_DWORD *)(a1 + 96) * *(_DWORD *)(a1 + 92);
  uint64_t v3 = v2 - 2;
  uint64_t v4 = *(void *)(*(void *)(a1 + 136) + 16);
  if (*(_DWORD *)(*(void *)(a1 + 144) + 4 * v3))
  {
    uint64_t updated = 0;
    *(_DWORD *)(*(void *)(v4 + 32 * v3) + 4) = 0;
    return updated;
  }
  uint64_t v8 = *(void *)(a1 + 112);
  uint64_t v9 = *(void *)(a1 + 120);
  long long v200 = *(_OWORD *)(v8 + 6640);
  __asm { FMOV            V1.2S, #1.0 }
  uint64_t v201 = *(void *)(v8 + 6656);
  uint64_t v202 = _D1;
  int v203 = 1065353216;
  cstdlib_memset(&__b, 0, 0x50uLL);
  uint64_t v14 = *(void *)(v9 + 1768);
  BOOL v15 = !v14 || !*(_DWORD *)(v14 + 16) && !*(_DWORD *)(v14 + 12);
  uint64_t v16 = *(void *)(a1 + 112);
  if (*(int *)(v16 + 6752) > 1) {
    return 2229280769;
  }
  BOOL v191 = v15;
  int v17 = *(_DWORD *)(a1 + 92);
  int v18 = *(_DWORD *)(a1 + 96);
  *(_DWORD *)(a1 + 280) = *(_DWORD *)(*(void *)(*(void *)(a1 + 128) + 16) + 4 * a2);
  if (*(float *)(v16 + 6704) == 0.0)
  {
    uint64_t updated = 0;
  }
  else
  {
    uint64_t updated = mfs_UpdateTargetQuantizedTrajectory_LF0(*(void *)(a1 + 104), *(void *)(a1 + 120), a1 + 176);
    if ((updated & 0x80000000) != 0) {
      return updated;
    }
  }
  uint64_t v19 = *(void *)(a1 + 336);
  if (v19)
  {
    uint64_t v20 = (a2 + v18 * v17 - 2);
    mfs_TCost_Elf0_Manhattan_TreeIndex(*(float **)(a1 + 112), *(void *)(a1 + 120), (uint64_t *)(*(void *)(a1 + 120) + 1088), v20, a1 + 176, *(_DWORD *)(*(void *)(*(void *)(a1 + 128) + 64) + 4 * a2), a2, *(unsigned __int8 *)(a1 + 345) == 1, *(float *)(v19 + 4 * (2 * v20)), *(float *)(v19 + 4 * ((2 * v20) | 1u)));
  }
  if (!*(unsigned char *)(a1 + 156) && *(unsigned char *)(a1 + 345) == 1)
  {
    float v21 = 4295000000.0;
    goto LABEL_160;
  }
  unsigned int v193 = updated;
  uint64_t v192 = v9;
  unsigned int v188 = *(_DWORD *)(a1 + 100);
  unsigned int v22 = *(_DWORD *)(a1 + 380);
  uint64_t v24 = *(void *)(a1 + 112);
  uint64_t v23 = *(void *)(a1 + 120);
  int v25 = *(int **)(v23 + 1096);
  int v26 = *v25;
  cstdlib_memset(&__b, 0, 0x50uLL);
  if (v25[482] == 1)
  {
    *(void *)((char *)&v199[1] + 4) = __PAIR64__(v22, v188);
    LODWORD(v199[1]) = 0;
    if (v22)
    {
      if (a2 == 2)
      {
        HIDWORD(v199[0]) = 1;
      }
      else
      {
        uint64_t v27 = v26 + 1 == a2 ? 0x200000002 : 0x100000004;
        *(void *)((char *)v199 + 12) = v27;
      }
    }
    else
    {
      HIDWORD(v199[0]) = 0;
    }
    *(void *)&long long __b = GetBnfTargetVectorPacked(v23, v3 / *(_DWORD *)(v24 + 5992), (float *)&v198 + 2);
    if (*(int *)(v24 + 6752) >= 1)
    {
      if (v2 != 2)
      {
        if (*(_DWORD *)(*(void *)(a1 + 144) + 4 * (v2 - 3))) {
          uint64_t BnfTargetVectorPacked = 0;
        }
        else {
          uint64_t BnfTargetVectorPacked = GetBnfTargetVectorPacked(v23, (v2 - 3) / *(_DWORD *)(v24 + 5992), (float *)&v198 + 3);
        }
        *((void *)&__b + 1) = BnfTargetVectorPacked;
      }
      unsigned int v29 = (v2 - 1) / *(_DWORD *)(v24 + 5992);
      if (v29 < v188)
      {
        if (*(_DWORD *)(*(void *)(a1 + 144) + 4 * (v2 - 1))) {
          uint64_t v30 = 0;
        }
        else {
          uint64_t v30 = GetBnfTargetVectorPacked(v23, v29, (float *)v199);
        }
        *(void *)&long long v197 = v30;
      }
      if (*(int *)(v24 + 6752) >= 2)
      {
        if (v3 >= 2)
        {
          if (*(_DWORD *)(*(void *)(a1 + 144) + 4 * (v2 - 4))) {
            uint64_t v31 = 0;
          }
          else {
            uint64_t v31 = GetBnfTargetVectorPacked(v23, (v2 - 4) / *(_DWORD *)(v24 + 5992), (float *)v199 + 1);
          }
          *((void *)&v197 + 1) = v31;
        }
        unsigned int v32 = v2 / *(_DWORD *)(v24 + 5992);
        if (v32 < v188)
        {
          if (*(_DWORD *)(*(void *)(a1 + 144) + 4 * v2)) {
            uint64_t v33 = 0;
          }
          else {
            uint64_t v33 = GetBnfTargetVectorPacked(v23, v32, (float *)v199 + 2);
          }
          *(void *)&long long v198 = v33;
        }
      }
    }
  }
  float v34 = *((float *)&v200 + LODWORD(v199[1])) * (float)*(int *)(*(void *)(a1 + 112) + 5564);
  unsigned int v35 = (int)v34;
  uint64_t v36 = v4 + 32 * v3;
  int v38 = *(_DWORD *)(v36 + 16);
  int v37 = (_DWORD *)(v36 + 16);
  unsigned int v39 = v193;
  if (v38 > (int)v34)
  {
    unsigned int v39 = mfs_CostList_Select(*(void *)(a1 + 136), v2 - 2, 1, (int)v34);
    uint64_t v40 = *(void *)(*(void *)(a1 + 136) + 16) + 32 * v3;
    unsigned int v42 = *(_DWORD *)(v40 + 16);
    int v41 = (unsigned int *)(v40 + 16);
    if (v42 > v35) {
      *int v41 = v35;
    }
  }
  if (UNICORN__log_select_GetLogLevel(*(void *)(*(void *)(v192 + 1072) + 32)) >= 3) {
    *(_DWORD *)(v192 + 1956) += *v37;
  }
  unsigned int v194 = v39;
  v189 = v37;
  if (HIDWORD(v199[0]) == 4)
  {
    int v59 = *(void **)(a1 + 120);
    uint64_t v60 = v59[137];
    if (*(_DWORD *)(v60 + 1928) != 1) {
      goto LABEL_117;
    }
    int v61 = *(_DWORD **)(a1 + 112);
    if (!v61[1688]) {
      goto LABEL_117;
    }
    uint64_t v62 = v59[138];
    uint64_t v63 = v62 + 32 * v3;
    int v65 = *(_DWORD *)(v63 + 16);
    v64 = (unsigned int *)(v63 + 16);
    if (!v65) {
      goto LABEL_117;
    }
    uint64_t v66 = 0;
    unint64_t v67 = 0;
    float v68 = 1.0 - *(float *)(v59[169] + 4 * v3);
    uint64_t v69 = (uint64_t *)(v62 + 32 * v3);
    uint64_t v70 = *v69;
    float v21 = 4295000000.0;
    v182 = v64;
    uint64_t v185 = v59[137];
    while (1)
    {
      int v71 = v61[1496];
      int v72 = (unsigned int *)(v71
                           ? v70 + v66 + 8
                           : *(void *)(v60 + 1064) + 4 * (2 * *(_DWORD *)(v70 + v66 + 8)));
      int v73 = *(_DWORD *)(v70 + v66);
      uint64_t v74 = *v72;
      if (!*((void *)&__b + 1)) {
        break;
      }
      float v75 = *(float *)(v59[164] + 4);
      if (((*(_DWORD *)(v59[144] + 4 * (((v73 - 1) / v61[1498]) >> 5)) >> ((v73 - 1) / v61[1498])) & 1) == 0)
      {
        float v79 = (*(float (**)(uint64_t, void, float))(a1 + 392))(v185, *(void *)(a1 + 56), *((float *)&v198 + 3));
        v64 = v182;
        uint64_t v60 = v185;
        float v76 = (float)(v75 * v79) + 0.0;
        if (v61[1496]) {
          goto LABEL_86;
        }
LABEL_85:
        uint64_t v74 = *(unsigned int *)(*(void *)(v60 + 1064) + 4 * ((2 * *(_DWORD *)(*v69 + v66 + 8)) | 1u));
        goto LABEL_86;
      }
      float v76 = (float)(v75 * *(float *)(v59[145] + 4 * v74)) + 0.0;
      if (!v71) {
        goto LABEL_85;
      }
LABEL_86:
      if ((void)v197)
      {
        float v77 = *(float *)(v59[164] + 8);
        if ((*(_DWORD *)(v59[144] + 4 * (((v73 + 1) / v61[1498]) >> 5)) >> ((v73 + 1) / v61[1498])))
        {
          float v78 = *(float *)(v59[145] + 4 * v74);
        }
        else
        {
          (*(void (**)(uint64_t, void, float))(a1 + 392))(v185, *(void *)(a1 + 56), *(float *)v199);
          v64 = v182;
          uint64_t v60 = v185;
        }
        float v76 = v76 + (float)(v77 * v78);
      }
      uint64_t v70 = *v69;
      uint64_t v80 = *v69 + v66;
      float v81 = *(float *)(v80 + 4);
      float v82 = (float)(v68 * v76) + v81;
      *(float *)(v80 + 4) = v82;
      if (v82 < v21) {
        float v21 = (float)(v68 * v76) + v81;
      }
      ++v67;
      v66 += 12;
      if (v67 >= *v64) {
        goto LABEL_118;
      }
    }
    float v76 = 0.0;
    if (v71) {
      goto LABEL_86;
    }
    goto LABEL_85;
  }
  if (HIDWORD(v199[0]) != 2)
  {
    if (HIDWORD(v199[0]) == 1)
    {
      uint64_t v43 = *(void *)(a1 + 120);
      uint64_t v44 = *(void *)(v43 + 1096);
      if (*(_DWORD *)(v44 + 1928) == 1)
      {
        uint64_t v45 = *(void *)(a1 + 112);
        if (*(_DWORD *)(v45 + 6752))
        {
          if (*((void *)&__b + 1))
          {
            float v46 = 1.0 - *(float *)(*(void *)(v43 + 1352) + 4 * v3);
            uint64_t v47 = *(void *)(v43 + 1104);
            int v48 = (uint64_t *)(v47 + 32 * v3);
            float v49 = 0.0;
            if (*(_DWORD *)v44 > v3
              || *(_DWORD *)(v43 + 1120) != v3 / *(_DWORD *)v44 - 1
              || !*(void *)(v43 + 1128)
              || !*(void *)(v43 + 1136))
            {
              goto LABEL_186;
            }
            float v49 = *(float *)(v45 + 6004);
            uint64_t v50 = v47 + 32 * v3;
            unint64_t v51 = *(unsigned int *)(v50 + 16);
            v181 = (unsigned int *)(v50 + 16);
            if (*(_DWORD *)(v50 + 16))
            {
              uint64_t v52 = 0;
              unint64_t v53 = 0;
              unsigned int v54 = 0;
              uint64_t v55 = *v48;
              do
              {
                int v56 = *(_DWORD *)(v55 + v52);
                if (v56 >= 1)
                {
                  if ((*(_DWORD *)(*(void *)(v43 + 1128) + 4 * (((v56 - 1) / *(_DWORD *)(v45 + 5992)) >> 5)) >> ((v56 - 1) / *(_DWORD *)(v45 + 5992))))
                  {
                    ++v54;
                    *(float *)(v55 + v52 + 4) = *(float *)(v55 + v52 + 4)
                                              + (float)(v46
                                                      * (float)(*(float *)(*(void *)(v43 + 1312) + 4)
                                                              * *(float *)(*(void *)(v43 + 1136)
                                                                         + 4
                                                                         * *(unsigned int *)(*(void *)(v44 + 1064)
                                                                                           + 4
                                                                                           * (2 * *(_DWORD *)(v55 + v52 + 8))))));
                  }
                  else if (*(_DWORD *)(v45 + 6000))
                  {
                    *(float *)(v55 + v52 + 4) = v49 + *(float *)(v55 + v52 + 4);
                  }
                  else
                  {
                    float v57 = *(float *)(*(void *)(v43 + 1312) + 4);
                    unsigned int v184 = v54;
                    float v58 = (*(float (**)(uint64_t, void, void, float))(a1 + 392))(v44, *(void *)(a1 + 56), *((void *)&__b + 1), *((float *)&v198 + 3));
                    unsigned int v54 = v184;
                    uint64_t v55 = *v48;
                    *(float *)(*v48 + v52 + 4) = *(float *)(*v48 + v52 + 4) + (float)(v46 * (float)(v57 * v58));
                    unint64_t v51 = *v181;
                  }
                }
                ++v53;
                v52 += 12;
              }
              while (v53 < v51);
            }
            else
            {
              unsigned int v54 = 0;
            }
            unsigned int v156 = *(_DWORD *)(v45 + 6000);
            if (v156 && v54 < v156)
            {
LABEL_186:
              uint64_t v158 = v47 + 32 * v3;
              unsigned int v161 = *(_DWORD *)(v158 + 16);
              v160 = (unsigned int *)(v158 + 16);
              unint64_t v159 = v161;
              if (v161)
              {
                uint64_t v162 = 0;
                unint64_t v163 = 0;
                uint64_t v164 = *v48;
                do
                {
                  int v165 = *(_DWORD *)(v164 + v162);
                  if (v165 >= 1)
                  {
                    float v166 = *(float *)(*(void *)(v43 + 1312) + 4);
                    float v167 = (*(float (**)(uint64_t, void, void, void, float))(a1 + 392))(v44, *(void *)(a1 + 56), *((void *)&__b + 1), (v165 - 1), *((float *)&v198 + 3));
                    uint64_t v164 = *v48;
                    *(float *)(*v48 + v162 + 4) = (float)(v46 * (float)(v166 * v167))
                                                + (float)(*(float *)(*v48 + v162 + 4) - v49);
                    unint64_t v159 = *v160;
                  }
                  ++v163;
                  v162 += 12;
                  float v21 = 4295000000.0;
                }
                while (v163 < v159);
                goto LABEL_118;
              }
            }
          }
        }
      }
    }
    else
    {
      UnicornSearch_TreeIndex_InnerDefault_Cascaded(a1, (void *)(*(void *)(a1 + 120) + 1088), v2 - 2, (uint64_t)&__b);
    }
LABEL_117:
    float v21 = 4295000000.0;
    goto LABEL_118;
  }
  uint64_t v83 = *(void *)(a1 + 120);
  uint64_t v84 = *(void *)(v83 + 1096);
  if (*(_DWORD *)(v84 + 1928) != 1) {
    goto LABEL_117;
  }
  uint64_t v85 = *(void *)(a1 + 112);
  if (!*(_DWORD *)(v85 + 6752) || !(void)v197) {
    goto LABEL_117;
  }
  float v86 = 1.0 - *(float *)(*(void *)(v83 + 1352) + 4 * v3);
  int v87 = *(_DWORD *)(*(void *)(v84 + 568) + 11548) - 1;
  uint64_t v88 = *(void *)(v83 + 1104);
  int v89 = (uint64_t *)(v88 + 32 * v3);
  unsigned int v90 = v3 / *(_DWORD *)v84 + 1;
  float v91 = 0.0;
  if (v90 < *(_DWORD *)(a1 + 88)
    && *(_DWORD *)(v83 + 1168) == v90
    && *(void *)(v83 + 1176)
    && *(void *)(v83 + 1184))
  {
    float v91 = *(float *)(v85 + 6004);
    uint64_t v180 = *(void *)(v83 + 1104);
    int v92 = (uint64_t *)(v88 + 32 * v3);
    unint64_t v93 = *((unsigned int *)v92 + 4);
    v183 = (unsigned int *)(v92 + 2);
    v186 = v92;
    if (*((_DWORD *)v92 + 4))
    {
      uint64_t v94 = 0;
      unint64_t v95 = 0;
      unsigned int v96 = 0;
      uint64_t v97 = *v92;
      do
      {
        int v98 = *(_DWORD *)(v97 + v94);
        if (v98 < v87)
        {
          if ((*(_DWORD *)(*(void *)(v83 + 1176) + 4 * (((v98 + 1) / *(_DWORD *)(v85 + 5992)) >> 5)) >> ((v98 + 1) / *(_DWORD *)(v85 + 5992))))
          {
            ++v96;
            *(float *)(v97 + v94 + 4) = *(float *)(v97 + v94 + 4)
                                      + (float)(v86
                                              * (float)(*(float *)(*(void *)(v83 + 1312) + 8)
                                                      * *(float *)(*(void *)(v83 + 1184)
                                                                 + 4
                                                                 * *(unsigned int *)(*(void *)(v84 + 1064)
                                                                                   + 4
                                                                                   * ((2 * *(_DWORD *)(v97 + v94 + 8)) | 1u)))));
          }
          else if (*(_DWORD *)(v85 + 6000))
          {
            *(float *)(v97 + v94 + 4) = v91 + *(float *)(v97 + v94 + 4);
          }
          else
          {
            float v99 = *(float *)(*(void *)(v83 + 1312) + 8);
            float v100 = (*(float (**)(uint64_t, void, void, float))(a1 + 392))(v84, *(void *)(a1 + 56), v197, *(float *)v199);
            uint64_t v97 = *v186;
            *(float *)(*v186 + v94 + 4) = *(float *)(*v186 + v94 + 4) + (float)(v86 * (float)(v99 * v100));
            unint64_t v93 = *v183;
          }
        }
        ++v95;
        v94 += 12;
      }
      while (v95 < v93);
    }
    else
    {
      unsigned int v96 = 0;
    }
    unsigned int v168 = *(_DWORD *)(v85 + 6000);
    BOOL v169 = !v168 || v96 >= v168;
    int v89 = v186;
    uint64_t v88 = v180;
    if (v169) {
      goto LABEL_117;
    }
  }
  uint64_t v170 = v88 + 32 * v3;
  unsigned int v173 = *(_DWORD *)(v170 + 16);
  v172 = (unsigned int *)(v170 + 16);
  unint64_t v171 = v173;
  if (!v173) {
    goto LABEL_117;
  }
  uint64_t v174 = 0;
  unint64_t v175 = 0;
  uint64_t v176 = *v89;
  do
  {
    int v177 = *(_DWORD *)(v176 + v174);
    if (v177 < v87)
    {
      float v178 = *(float *)(*(void *)(v83 + 1312) + 8);
      float v179 = (*(float (**)(uint64_t, void, void, void, float))(a1 + 392))(v84, *(void *)(a1 + 56), v197, (v177 + 1), *(float *)v199);
      uint64_t v176 = *v89;
      *(float *)(*v89 + v174 + 4) = (float)(v86 * (float)(v178 * v179)) + (float)(*(float *)(*v89 + v174 + 4) - v91);
      unint64_t v171 = *v172;
    }
    ++v175;
    v174 += 12;
    float v21 = 4295000000.0;
  }
  while (v175 < v171);
LABEL_118:
  if (HIDWORD(v199[0]) == 4)
  {
    uint64_t v9 = v192;
    uint64_t updated = v194;
    uint64_t v101 = v189;
  }
  else
  {
    float v102 = *((float *)&v200 + LODWORD(v199[1]) + 3) * (float)*(int *)(*(void *)(a1 + 112) + 5564);
    unsigned int v103 = (int)v102;
    uint64_t v101 = v189;
    uint64_t v9 = v192;
    uint64_t updated = v194;
    if (*v189 > (int)v102)
    {
      uint64_t updated = mfs_CostList_Select(*(void *)(a1 + 136), v3, 1, (int)v102);
      uint64_t v104 = *(void *)(*(void *)(a1 + 136) + 16) + 32 * v3;
      unsigned int v106 = *(_DWORD *)(v104 + 16);
      v105 = (unsigned int *)(v104 + 16);
      if (v106 > v103) {
        unsigned int *v105 = v103;
      }
    }
  }
  if (UNICORN__log_select_GetLogLevel(*(void *)(*(void *)(v9 + 1072) + 32)) >= 3) {
    *(_DWORD *)(v9 + 1960) += *v101;
  }
  if (HIDWORD(v199[0]) == 4) {
    goto LABEL_160;
  }
  if (HIDWORD(v199[0]) == 2)
  {
    v124 = *(void **)(a1 + 120);
    uint64_t v125 = v124[137];
    if (*(_DWORD *)(v125 + 1928) != 1) {
      goto LABEL_160;
    }
    v126 = *(_DWORD **)(a1 + 112);
    if (!v126[1688] || !*((void *)&__b + 1)) {
      goto LABEL_160;
    }
    unsigned int v195 = updated;
    uint64_t v127 = v124[138];
    uint64_t v128 = v127 + 32 * v3;
    unsigned int v131 = *(_DWORD *)(v128 + 16);
    v130 = (unsigned int *)(v128 + 16);
    unint64_t v129 = v131;
    if (!v131) {
      goto LABEL_158;
    }
    uint64_t v132 = 0;
    unint64_t v133 = 0;
    float v134 = 1.0 - *(float *)(v124[169] + 4 * v3);
    v135 = (uint64_t *)(v127 + 32 * v3);
    uint64_t v136 = *v135;
    do
    {
      if (v126[1496]) {
        v137 = (unsigned int *)(v136 + v132 + 8);
      }
      else {
        v137 = (unsigned int *)(*(void *)(v125 + 1064) + 4 * (2 * *(_DWORD *)(v136 + v132 + 8)));
      }
      if ((*(_DWORD *)(v124[144] + 4 * (((*(_DWORD *)(v136 + v132) - 1) / v126[1498]) >> 5)) >> ((*(_DWORD *)(v136 + v132) - 1) / v126[1498])))
      {
        float v138 = *(float *)(v124[164] + 4) * *(float *)(v124[145] + 4 * *v137);
      }
      else
      {
        float v139 = *(float *)(v124[164] + 4);
        float v138 = v139
             * (*(float (**)(uint64_t, void, void, float))(a1 + 392))(v125, *(void *)(a1 + 56), *((void *)&__b + 1), *((float *)&v198 + 3));
        uint64_t v136 = *v135;
        unint64_t v129 = *v130;
      }
      float v140 = (float)(v134 * v138) + *(float *)(v136 + v132 + 4);
      *(float *)(v136 + v132 + 4) = v140;
      if (v140 < v21) {
        float v21 = v140;
      }
      ++v133;
      v132 += 12;
    }
    while (v133 < v129);
    goto LABEL_157;
  }
  if (HIDWORD(v199[0]) != 1)
  {
    UnicornSearch_TreeIndex_InnerDefault_Cascaded(a1, (void *)(*(void *)(a1 + 120) + 1088), v3, (uint64_t)&__b);
    goto LABEL_160;
  }
  v107 = *(void **)(a1 + 120);
  uint64_t v108 = v107[137];
  if (*(_DWORD *)(v108 + 1928) == 1)
  {
    unsigned int v195 = updated;
    v109 = *(_DWORD **)(a1 + 112);
    if (!v109[1688]) {
      goto LABEL_158;
    }
    if (!(void)v197) {
      goto LABEL_158;
    }
    uint64_t v110 = v107[138];
    uint64_t v111 = v110 + 32 * v3;
    unint64_t v112 = *(unsigned int *)(v111 + 16);
    v190 = (unsigned int *)(v111 + 16);
    if (!*(_DWORD *)(v111 + 16)) {
      goto LABEL_158;
    }
    uint64_t v113 = 0;
    unint64_t v114 = 0;
    float v115 = 1.0 - *(float *)(v107[169] + 4 * v3);
    v187 = (uint64_t *)(v110 + 32 * v3);
    uint64_t v116 = *v187;
    do
    {
      if (v109[1496]) {
        v117 = (unsigned int *)(v116 + v113 + 8);
      }
      else {
        v117 = (unsigned int *)(*(void *)(v108 + 1064) + 4 * ((2 * *(_DWORD *)(v116 + v113 + 8)) | 1u));
      }
      int v118 = *(_DWORD *)(v116 + v113) + 1;
      uint64_t v119 = *v117;
      if ((*(_DWORD *)(v107[144] + 4 * ((v118 / v109[1498]) >> 5)) >> (v118 / v109[1498])))
      {
        float v120 = *(float *)(v107[164] + 8) * *(float *)(v107[145] + 4 * v119);
      }
      else
      {
        float v121 = (*(float (**)(uint64_t, void, void, void, float))(a1 + 392))(v108, *(void *)(a1 + 56), v197, (*(_DWORD *)(v116 + v113) + 1), *(float *)v199);
        float v122 = *(float *)(v107[164] + 8);
        *(_DWORD *)(v107[144] + 4 * ((v118 / v109[1498]) >> 5)) |= 1 << (v118 / v109[1498]);
        float v120 = v121 * v122;
        *(float *)(v107[145] + 4 * v119) = v121;
        uint64_t v116 = *v187;
        unint64_t v112 = *v190;
      }
      float v123 = (float)(v115 * v120) + *(float *)(v116 + v113 + 4);
      *(float *)(v116 + v113 + 4) = v123;
      if (v123 < v21) {
        float v21 = v123;
      }
      ++v114;
      v113 += 12;
    }
    while (v114 < v112);
LABEL_157:
    uint64_t v9 = v192;
LABEL_158:
    uint64_t updated = v195;
  }
LABEL_160:
  uint64_t v141 = v4 + 32 * v3;
  unsigned int v144 = *(_DWORD *)(v141 + 16);
  v143 = (_DWORD *)(v141 + 16);
  unint64_t v142 = v144;
  uint64_t v145 = *(void *)(a1 + 112);
  signed int v146 = (int)(float)*(int *)(v145 + 5564);
  float v147 = *(float *)(v145 + 6636);
  char v148 = !v191;
  if (v147 <= 0.0) {
    char v148 = 1;
  }
  if ((v148 & 1) == 0)
  {
    int v149 = 0;
    if (v142 && v146 >= 1)
    {
      int v149 = 0;
      float v150 = v21 + v147;
      v151 = (float *)(*(void *)(v4 + 32 * v3) + 4);
      unint64_t v152 = 1;
      do
      {
        float v153 = *v151;
        v151 += 3;
        if (v153 < v150) {
          ++v149;
        }
        if (v152 >= v142) {
          break;
        }
        ++v152;
      }
      while (v149 < v146);
    }
    if (v149 >= v146) {
      int v149 = (int)(float)*(int *)(v145 + 5564);
    }
    int v154 = (int)(float)*(int *)(v145 + 6632);
    if (v149 <= v154) {
      signed int v146 = v154;
    }
    else {
      signed int v146 = v149;
    }
  }
  if ((int)v142 > v146)
  {
    uint64_t updated = mfs_CostList_Select(*(void *)(a1 + 136), v3, 1, v146);
    UNICORN__mfs_CostList_Prune(*(void **)(a1 + 136), v3, v146);
  }
  if (UNICORN__log_select_GetLogLevel(*(void *)(*(void *)(v9 + 1072) + 32)) >= 3) {
    *(_DWORD *)(v9 + 1964) += *v143;
  }
  UNICORN__log_select_Diag(*(void *)(a1 + 56), 11, (uint64_t)"costlist(%d)\n");
  return updated;
}

void UnicornSearch_TreeIndex_InnerDefault_Cascaded(uint64_t a1, void *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = a2[1];
  if (*(_DWORD *)(v4 + 1928) == 1)
  {
    if (*(_DWORD *)(*(void *)(a1 + 112) + 6752))
    {
      uint64_t v7 = a2[2];
      uint64_t v8 = v7 + 32 * a3;
      int v10 = *(_DWORD *)(v8 + 16);
      uint64_t v9 = (unsigned int *)(v8 + 16);
      if (v10)
      {
        uint64_t v12 = 0;
        unint64_t v13 = 0;
        float v14 = 1.0 - *(float *)(*(void *)(*(void *)(a1 + 120) + 1352) + 4 * a3);
        int v15 = *(_DWORD *)(*(void *)(v4 + 568) + 11548) - 1;
        uint64_t v16 = (uint64_t *)(v7 + 32 * a3);
        uint64_t v17 = *v16;
        do
        {
          int v18 = *(_DWORD *)(v17 + v12);
          if (*(void *)(a4 + 8)) {
            BOOL v19 = v18 < 1;
          }
          else {
            BOOL v19 = 1;
          }
          float v20 = 0.0;
          if (!v19)
          {
            float v21 = *(float *)(a2[28] + 4);
            float v20 = (float)(v21
                        * (*(float (**)(uint64_t, void, float))(a1 + 392))(v4, *(void *)(a1 + 56), *(float *)(a4 + 44)))+ 0.0;
          }
          if (*(void *)(a4 + 16)) {
            BOOL v22 = v18 < v15;
          }
          else {
            BOOL v22 = 0;
          }
          if (v22)
          {
            float v23 = *(float *)(a2[28] + 8);
            float v20 = v20
                + (float)(v23
                        * (*(float (**)(uint64_t, void, float))(a1 + 392))(v4, *(void *)(a1 + 56), *(float *)(a4 + 48)));
          }
          uint64_t v17 = *v16;
          *(float *)(*v16 + v12 + 4) = (float)(v14 * v20) + *(float *)(*v16 + v12 + 4);
          ++v13;
          v12 += 12;
        }
        while (v13 < *v9);
      }
    }
  }
}

uint64_t UNICORN__mfs_TCost_Init(uint64_t a1, uint64_t a2, _DWORD *__b)
{
  cstdlib_memset(__b, 0, 0xA0uLL);
  *long long __b = *(_DWORD *)(a2 + 212) + *(_DWORD *)(a2 + 208);
  float v6 = 1.0 / (float)(*(float *)(a2 + 5428) + *(float *)(a2 + 5432));
  *((float *)__b + 1) = v6;
  __b[3] = *(_DWORD *)(a2 + 5532);
  __b[2] = *(_DWORD *)(a2 + 208);
  __b[27] = *(_DWORD *)(a2 + 5432);
  __b[28] = *(_DWORD *)(a2 + 5428);
  float v7 = *(float *)(a2 + 5424);
  *((float *)__b + 29) = v7;
  *((float *)__b + 1) = v6 * v7;
  UNICORN__mfs_F32Vect_Init(a1, (void *)__b + 7);
  UNICORN__mfs_F32Vect_Init(a1, (void *)__b + 10);
  *((void *)__b + 3) = 0;
  *((void *)__b + 4) = 0;
  *((void *)__b + 19) = mfs_TCost_Elf0_Manhattan_Clusterize;
  return 0;
}

uint64_t mfs_TCost_EnableSIMD(uint64_t a1, int a2)
{
  if (!a1) {
    return 8;
  }
  uint64_t result = 0;
  uint64_t v4 = mfs_TCost_Elf0_Manhattan_Clusterize_SIMD;
  if (!a2) {
    uint64_t v4 = mfs_TCost_Elf0_Manhattan_Clusterize;
  }
  *(void *)(a1 + 152) = v4;
  return result;
}

uint64_t UNICORN__mfs_FillTgtVect(uint64_t a1, uint64_t a2, uint64_t a3, signed int a4)
{
  uint64_t v8 = *(void *)(a2 + 24);
  int v9 = *(_DWORD *)(v8 + 1520);
  int v10 = *(_DWORD *)(v8 + 3040);
  *(_DWORD *)(a3 + 104) = a4;
  uint64_t v11 = a3 + 56;
  UNICORN__mfs_F32Vect_Clear((void *)(a3 + 56));
  uint64_t result = UNICORN__mfs_F32Vect_Create(v11, a4);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  uint64_t v13 = a3 + 80;
  UNICORN__mfs_F32Vect_Clear((void *)(a3 + 80));
  uint64_t result = UNICORN__mfs_F32Vect_Create(a3 + 80, a4 + *(_DWORD *)a3 - 1);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  uint64_t v14 = v9;
  uint64_t v15 = *(void *)(a3 + 64);
  *(void *)(a3 + 24) = *(void *)(*(void *)(v8 + 1576) + 8 * v9);
  *(void *)(a3 + 32) = v15;
  if (a4 < 1)
  {
LABEL_21:
    uint64_t v24 = *(void *)(a2 + 24);
    *(_DWORD *)(v24 + 3040) = v10;
    *(_DWORD *)(v24 + 1520) = v9;
    return result;
  }
  char v16 = 0;
  int v17 = 0;
  float v18 = -1.0;
  float v19 = 1.0;
  while ((*(unsigned char *)(*(void *)(a2 + 48) + v14) & 4) == 0)
  {
    float v20 = -1.0e10;
    float v21 = 1.0;
    if ((v16 & 1) == 0) {
      goto LABEL_9;
    }
LABEL_13:
    uint64_t result = UNICORN__mfs_F32Vect_Pad(v11, v20);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    float v23 = sqrtf(v21);
    if (v18 != v21) {
      float v19 = v23;
    }
    uint64_t result = UNICORN__mfs_F32Vect_Pad(v13, v19);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    if (v18 != v21) {
      float v18 = v21;
    }
    ++v14;
    ++v17;
    char v16 = 1;
    if (v17 == a4)
    {
      int v9 = v14;
      goto LABEL_21;
    }
  }
  float v20 = **(float **)(*(void *)(v8 + 3096) + 8 * v10);
  float v21 = **(float **)(*(void *)(v8 + 3136) + 8 * v10++);
  if (v16) {
    goto LABEL_13;
  }
LABEL_9:
  if (*(int *)(a1 + 208) < 1) {
    goto LABEL_13;
  }
  uint64_t v22 = 0;
  while (1)
  {
    uint64_t result = UNICORN__mfs_F32Vect_Pad(v13, sqrtf(*(float *)(*(void *)(*(void *)(v8 + 1616) + 8 * v14) + 4 * v22)));
    if ((result & 0x80000000) != 0) {
      return result;
    }
    if (++v22 >= *(int *)(a1 + 208)) {
      goto LABEL_13;
    }
  }
}

void *UNICORN__mfs_TCost_Clear(uint64_t a1)
{
  UNICORN__mfs_F32Vect_Clear((void *)(a1 + 56));

  return UNICORN__mfs_F32Vect_Clear((void *)(a1 + 80));
}

void mfs_TCost_BNFCandidateCostStream(uint64_t a1, uint64_t a2, uint64_t a3, int a4, float *a5, unsigned int a6, int a7)
{
  uint64_t v62 = *MEMORY[0x263EF8340];
  float v7 = *(float **)(a1 + 32);
  uint64_t v8 = *(float **)(a3 + 16);
  uint64_t v9 = *(unsigned int *)(a1 + 104);
  a5[2] = 0.0;
  *a5 = 0.0;
  if (v9)
  {
    switch(a7)
    {
      case 1:
        float v59 = *v7;
        v58[0] = *v8;
        int v42 = v9 - 1;
        uint64_t v43 = a4 - 1;
        if ((int)v9 < 3)
        {
          float v60 = v7[v42];
          unsigned int v44 = 2;
        }
        else
        {
          float v61 = v7[v42];
          v58[2] = v8[v43];
          float v60 = *(float *)((char *)v7 + ((2 * v9) & 0x1FFFFFFFCLL));
          LODWORD(v43) = a4 >> 1;
          unsigned int v44 = 3;
        }
        v58[1] = v8[(int)v43];
        a5[2] = mfs_bnfData_CosineCost_F32(&v59, v58, v44) * *(float *)(a1 + 108);
        float v39 = *(float *)(a1 + 116);
        int v57 = v9 - a4;
        if ((int)v9 - a4 < 0) {
          int v57 = a4 - v9;
        }
        float v55 = (float)v57;
        float v56 = (float)a4;
        goto LABEL_50;
      case 2:
      case 5:
        if (*(_DWORD *)(a1 + 120) == 1)
        {
          float v14 = 0.0;
          if (a4 < 3)
          {
LABEL_13:
            float v22 = sqrtf(v14) / (float)((float)((float)a4 + -2.0) * 3.0);
            goto LABEL_35;
          }
          uint64_t v15 = v8 + 2;
          uint64_t v16 = (a4 - 1) - 1;
          while (1)
          {
            float v17 = *(v15 - 1);
            if (v17 <= 0.0)
            {
              float v21 = 1000.0;
              float v20 = 5.0;
            }
            else
            {
              float v18 = *(v15 - 2);
              float v19 = *v15;
              float v14 = v14 + UNICORN__mfsLLCost(v17 - *(float *)(a1 + 124), *(float *)(a1 + 136));
              if (v18 <= 0.0 || v19 <= 0.0) {
                goto LABEL_12;
              }
              float v14 = v14
                  + UNICORN__mfsLLCost((float)((float)(v19 * 0.5) + (float)(v18 * -0.5)) - *(float *)(a1 + 128), *(float *)(a1 + 140));
              float v20 = (float)((float)(v18 + v19) + (float)(v17 * -2.0)) - *(float *)(a1 + 132);
              float v21 = *(float *)(a1 + 144);
            }
            float v14 = v14 + UNICORN__mfsLLCost(v20, v21);
LABEL_12:
            ++v15;
            if (!--v16) {
              goto LABEL_13;
            }
          }
        }
        float v45 = 0.0;
        if (a4 >= 3)
        {
          float v46 = v8 + 1;
          uint64_t v47 = (a4 - 1) - 1;
          do
          {
            if (*v46 > 0.0) {
              float v45 = v45 + UNICORN__mfsLLCost(5.0, 1000.0);
            }
            ++v46;
            --v47;
          }
          while (v47);
        }
        float v22 = sqrtf(v45);
LABEL_35:
        if (a7 == 5)
        {
          float v48 = v8[1];
          float v49 = v7[(int)v9 - 1];
          uint64_t v50 = &v8[a4];
          float v51 = *(v50 - 2);
          if (*v7 <= v48) {
            float v52 = v8[1];
          }
          else {
            float v52 = *v7;
          }
          if (v49 <= v51) {
            float v53 = *(v50 - 2);
          }
          else {
            float v53 = v7[(int)v9 - 1];
          }
          float v22 = v22 + (float)((float)(vabds_f32(*v7, v48) / v52) + (float)(vabds_f32(v49, v51) / v53));
        }
        a5[2] = v22 * *(float *)(a1 + 108);
        float v39 = *(float *)(a1 + 116);
        int v54 = -2 - (v9 - a4);
        if ((int)v9 - a4 + 2 >= 0) {
          int v54 = v9 - a4 + 2;
        }
        float v55 = (float)v54;
        float v56 = (float)a4 + -2.0;
LABEL_50:
        float v41 = v55 / v56;
LABEL_51:
        *a5 = v41 * v39;
        break;
      case 3:
      case 4:
        float v23 = (float *)((char *)&UNICORN__tblSubUnitLRWeights + 12 * a6);
        float v24 = v7[(int)v9 - 1];
        uint64_t v25 = a4 - 1;
        float v26 = v8[v25];
        float v27 = v7[((int)v9 - 1) >> 1];
        float v28 = v8[(int)v25 >> 1];
        float v29 = vabds_f32(*v7, *v8);
        if (*v7 <= *v8) {
          float v30 = *v8;
        }
        else {
          float v30 = *v7;
        }
        float v31 = (float)(v29 / v30) * *v23;
        float v32 = vabds_f32(v24, v26);
        if (v24 <= v26) {
          float v33 = v8[v25];
        }
        else {
          float v33 = v7[(int)v9 - 1];
        }
        float v34 = v31 + (float)((float)(v32 / v33) * v23[1]);
        float v35 = vabds_f32(v27, v28);
        if (v27 <= v28) {
          float v27 = v8[(int)v25 >> 1];
        }
        float v36 = v35 / v27;
        float v37 = (float)a4;
        float v38 = v34
            + (float)((float)(v36 * v23[2])
                    * (float)((float)((float)a4 + (float)(int)v9) / (float)((float)a4 * (float)(int)v9)));
        if (a7 == 4) {
          float v38 = (float)(vabds_f32((float)(*v7 - v24) / (float)(int)v9, (float)(*v8 - v26) / v37) * *(float *)(a2 + 6776))
        }
              + (float)((float)(1.0 - *(float *)(a2 + 6776)) * v38);
        a5[2] = v38 * *(float *)(a1 + 108);
        float v39 = *(float *)(a1 + 116);
        int v40 = v9 - a4;
        if ((int)v9 - a4 < 0) {
          int v40 = a4 - v9;
        }
        float v41 = (float)v40 / v37;
        goto LABEL_51;
      default:
        return;
    }
  }
}

float mfs_TCost_BNFCandidateCostStreamElf0(uint64_t a1, uint64_t a2, uint64_t a3, int a4, float *a5, unsigned int a6, float *a7, int a8, float result)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(float **)(a3 + 16);
  int v10 = *(_DWORD *)(a1 + 104);
  a5[2] = 0.0;
  *a5 = 0.0;
  if (v10)
  {
    if ((a8 - 3) < 2)
    {
      uint64_t v16 = (float *)((char *)&UNICORN__tblSubUnitLRWeights + 12 * a6);
      float v17 = *v9;
      float v18 = a7[1];
      float v19 = &v9[a4];
      float v20 = *(v19 - 1);
      float v21 = vabds_f32(*a7, v17);
      if (*a7 <= v17) {
        float v22 = v17;
      }
      else {
        float v22 = *a7;
      }
      float v23 = (float)(v21 / v22) * *v16;
      float v24 = vabds_f32(v18, v20);
      if (v18 <= v20) {
        float v25 = *(v19 - 1);
      }
      else {
        float v25 = a7[1];
      }
      float v26 = v23 + (float)((float)(v24 / v25) * v16[1]);
      float v27 = (float)a4;
      if (a8 == 4) {
        float v26 = (float)(vabds_f32((float)(*a7 - v18) / (float)v10, (float)(v17 - v20) / (float)a4) * *(float *)(a2 + 6776))
      }
            + (float)((float)(1.0 - *(float *)(a2 + 6776)) * v26);
      a5[2] = v26 * *(float *)(a1 + 108);
      int v28 = v10 - a4;
      if (v10 - a4 < 0) {
        int v28 = a4 - v10;
      }
    }
    else
    {
      if (a8)
      {
        if (a8 != 1) {
          return result;
        }
        float v14 = a7[1];
        v30[0] = *a7;
        v29[0] = *v9;
        v30[1] = v14;
        v29[1] = v9[a4 - 1];
        float v15 = mfs_bnfData_CosineCost_F32(v30, v29, 2u) * *(float *)(a1 + 108);
      }
      else
      {
        float v15 = *(float *)(a1 + 108) * sqrtf((float)(*a7 - *v9) + (float)(a7[1] - v9[a4 - 1]));
      }
      a5[2] = v15;
      int v28 = v10 - a4;
      if (v10 - a4 < 0) {
        int v28 = a4 - v10;
      }
      float v27 = (float)a4;
    }
    uint64_t result = (float)((float)v28 / v27) * *(float *)(a1 + 116);
    *a5 = result;
  }
  return result;
}

uint64_t mfs_LogElf0Targets_Clustered(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  if (a4) {
    return UNICORN__log_select_Diag(result, 10, (uint64_t)"PHN:%3d  STA:%d - F0_LEFT_PGEN:%5.2f F0_LEFT_RNN :%5.2f   F0_RIGHT_PGEN:%5.2f F0_RIGHT_RNN :%5.2f\n");
  }
  return result;
}

uint64_t LogEdgeLF0Targets(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a3 + 104)) {
    return UNICORN__log_select_Diag(result, 10, (uint64_t)"PHN:%3d  STA:%d - F0_LEFT_PGEN:%5.2f F0_LEFT_RNN :%5.2f   F0_RIGHT_PGEN:%5.2f F0_RIGHT_RNN :%5.2f\n");
  }
  return result;
}

uint64_t UNICORN__mfs_TCost_SetTarget(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, int a5)
{
  uint64_t v8 = UNICORN__mfs_FillTgtVect(*(void *)(a2 + 568), a3, a1, *(_DWORD *)(a4[2] + 4 * a5));
  *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(void *)(a4[14] + 8 * a5) + 4);
  *(float *)(a1 + 136) = UNICORN__bet5_finv(sqrtf(*(float *)(*(void *)(a4[19] + 8 * a5) + 4)));
  *(_DWORD *)(a1 + 128) = *(_DWORD *)(*(void *)(a4[14] + 8 * a5) + 8);
  *(float *)(a1 + 140) = UNICORN__bet5_finv(sqrtf(*(float *)(*(void *)(a4[19] + 8 * a5) + 8)));
  *(_DWORD *)(a1 + 132) = *(_DWORD *)(*(void *)(a4[14] + 8 * a5) + 12);
  *(float *)(a1 + 144) = UNICORN__bet5_finv(sqrtf(*(float *)(*(void *)(a4[19] + 8 * a5) + 12)));
  *(_DWORD *)(a1 + 120) = (*(unsigned __int8 *)(a4[22] + a5) >> 2) & 1;
  return v8;
}

void UNICORN__mfs_TCost_Copy(void *a1, uint64_t *a2)
{
  uint64_t v4 = (uint64_t)(a1 + 7);
  UNICORN__mfs_F32Vect_Clear(a1 + 7);
  UNICORN__mfs_F32Vect_Clear(a1 + 10);
  cstdlib_memcpy(a1, a2, 0xA0uLL);
  UNICORN__mfs_F32Vect_Copy(v4, a2 + 7);
  UNICORN__mfs_F32Vect_Copy((uint64_t)(a1 + 10), a2 + 10);
  uint64_t v5 = a1[8];
  a1[3] = a2[3];
  a1[4] = v5;
}

uint64_t GetBnfTargetVectorPacked(uint64_t a1, int a2, float *a3)
{
  *a3 = VectBlock_Get_IndexElm_LH_F32(a1 + 1928, a2);
  if (*(_DWORD *)(a1 + 1944))
  {
    return VectBlock_Get_IndexPtr_LH_S8(a1 + 1864, a2);
  }
  else
  {
    return VectBlock_Get_IndexPtr_LH_S16(a1 + 1880, a2);
  }
}

uint64_t Search_TreeIndex(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned int a7, uint64_t a8, signed int a9)
{
  uint64_t v12 = *(int **)(a1 + 104);
  uint64_t v41 = *(void *)(a1 + 112);
  uint64_t v13 = &v12[2 * a2];
  uint64_t v14 = *(void *)(a1 + 120);
  float v15 = (unsigned int *)(*(void *)(*((void *)v13 + 96) + 8 * (int)a3)
                       + 40 * *(int *)(*(void *)(a5 + 8 * a2 + 56) + 4 * (int)a3));
  uint64_t v16 = *v15;
  unint64_t v17 = v15[1];
  uint64_t v18 = *((void *)v13 + 101);
  float v19 = *(float *)(*(void *)(v14 + 1352) + 4 * a9);
  float v20 = **(float **)(a8 + 224);
  uint64_t v21 = *(void *)(a8 + 16) + 32 * a9;
  int v22 = *v12;
  uint64_t v34 = v18;
  uint64_t v35 = v16;
  uint64_t v37 = *(int *)(*(void *)(a5 + 8 * a2 + 56) + 4 * (int)a3);
  int v36 = *(_DWORD *)(v21 + 16);
  if (*(_DWORD *)(v21 + 20) >= v17)
  {
    LODWORD(result) = 0;
  }
  else
  {
    uint64_t result = UNICORN__mfs_CostList_Resize((void *)a8, a9, v17);
    if ((result & 0x80000000) != 0) {
      return result;
    }
  }
  unsigned int v38 = result;
  int v24 = a9 / v22;
  float v42 = 0.0;
  uint64_t BnfTargetVectorPacked = GetBnfTargetVectorPacked(v14, a9 / *(_DWORD *)(v41 + 5992), &v42);
  if (*(_DWORD *)(v41 + 5992) == 1 || *(_DWORD *)(a8 + 56) != v24)
  {
    (*(void (**)(int *, void, uint64_t, uint64_t, uint64_t, void, float))(a1 + 384))(v12, *(void *)(a1 + 56), BnfTargetVectorPacked, v37, a3, *(void *)(a8 + 104), v42);
    *(_DWORD *)(a8 + 56) = v24;
  }
  if (v17)
  {
    uint64_t result = v38;
    if (v36 - a6 >= a7) {
      return result;
    }
    unint64_t v26 = 0;
    float v27 = (_DWORD *)(v34 + 4 * v35);
    uint64_t v28 = (int)a3 - 2;
    float v29 = (float)(1.0 - v19) * v20;
    uint64_t v30 = *(unsigned int *)(*((void *)v12 + 106)
                          + 4 * (*v27 / *(_DWORD *)(*((void *)v12 + 71) + 5992)));
    do
    {
      unsigned int v31 = v27[v26];
      float v32 = *(float *)(*(void *)(a8 + 104) + 4 * v26);
      uint64_t v33 = *(void *)(a8 + 72);
      *(_DWORD *)(*(void *)(a8 + 64) + 4 * ((v31 / *(_DWORD *)(v41 + 5992)) >> 5)) |= 1 << (v31
                                                                                              / *(_DWORD *)(v41 + 5992));
      *(float *)(v33 + 4 * v30) = v32;
      mfs_CostList_PadWithBnfOffset((void *)a8, a9, v31, v30 + v26, v29 * v32);
      *(_DWORD *)(*(void *)(a8 + 112 + 8 * v28) + 4 * (v26 >> 5)) |= 1 << v26;
      ++v26;
    }
    while (v26 < v17 && *(_DWORD *)(*(void *)(a8 + 16) + 32 * a9 + 16) - a6 < a7);
  }
  return v38;
}

uint64_t Search_PruneBNF_TreeIndex(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, int a6, unsigned int a7, uint64_t a8, signed int a9)
{
  *(void *)&v160[4] = *MEMORY[0x263EF8340];
  int v141 = *(unsigned __int8 *)(a4 + 1);
  uint64_t v12 = *(_DWORD **)(a1 + 104);
  uint64_t v13 = *(void *)(a1 + 112);
  uint64_t v14 = *(void *)(a1 + 120);
  float v147 = v12 + 192;
  uint64_t v148 = *(int *)(*(void *)(a5 + 8 * a2 + 56) + 4 * a3);
  float v15 = (unsigned int *)(*(void *)(*(void *)&v12[2 * a2 + 192] + 8 * a3) + 40 * (int)v148);
  unsigned int v16 = v15[1];
  float v17 = *(float *)(*(void *)(v14 + 1352) + 4 * a9);
  float v18 = **(float **)(a8 + 224);
  uint64_t v149 = *v15;
  float v150 = &v12[2 * a2 + 202];
  unsigned int v19 = *(_DWORD *)(*v150 + 4 * v149);
  uint64_t v140 = *(void *)(a8 + 16);
  v151 = v12;
  int v20 = *v12;
  float v154 = 0.0;
  float v155 = 0.0;
  BET5_GenericRules_Param_GetLocalValue(v13, v14, 1u, a9, &v155);
  if ((v21 & 0x80000000) != 0) {
    return v21;
  }
  uint64_t v152 = v13;
  BET5_GenericRules_Param_GetLocalValue(v13, v14, 2u, a9, &v154);
  if ((v21 & 0x80000000) != 0) {
    return v21;
  }
  uint64_t v145 = a3;
  uint64_t v146 = a2;
  uint64_t v134 = a3 - 2;
  cstdlib_memset(__b, 0, 0x400uLL);
  if (UNICORN__log_select_GetLogLevel(*(void *)(*(void *)(v14 + 1072) + 32)) >= 3) {
    *(_DWORD *)(v14 + 1948) += *(_DWORD *)(*(void *)(*(void *)&v147[2 * a2] + 8 * a3) + 40 * (int)v148 + 4);
  }
  uint64_t v135 = v14;
  uint64_t v22 = v13;
  uint64_t v23 = *((void *)v151 + 71);
  unsigned int v24 = v19 / *(_DWORD *)(v23 + 5992);
  int v25 = *(_DWORD *)(*((void *)v151 + 106) + 4 * v24);
  int v26 = *(_DWORD *)(v152 + 5984)
      ? v25 + *(_DWORD *)(v23 + 11564) / *v151 * v134
      : *(_DWORD *)(*((void *)v151 + 106) + 4 * v24);
  if (*(_DWORD *)(*(void *)(a8 + 16) + 32 * a9 + 20) < v16)
  {
    uint64_t v21 = UNICORN__mfs_CostList_Resize((void *)a8, a9, v16);
    uint64_t v22 = v152;
    if ((v21 & 0x80000000) != 0) {
      return v21;
    }
  }
  uint64_t v27 = *(void *)(v14 + 1768);
  if (v27
    && *(_DWORD *)(v27 + 12) == 1
    && *(_DWORD *)(v27 + 8) > a9
    && *(float *)(*(void *)v27 + 48 * a9 + 16) != 0.0)
  {
    unsigned int v28 = *(_DWORD *)(v27 + 20);
    if (v28 >= 0x64) {
      int v29 = 100;
    }
    else {
      int v29 = v28;
    }
  }
  else
  {
    int v29 = -1;
  }
  float v30 = 0.0;
  uint64_t v31 = (a9 / v20);
  int v129 = v26;
  int v130 = v29;
  if (v141 == 1)
  {
    uint64_t v136 = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
LABEL_28:
    int v142 = 1;
    float v35 = 0.0;
    goto LABEL_38;
  }
  float v34 = *(float *)(v22 + 6160);
  if (v34 < *(float *)(v22 + 6164) || v29 != -1)
  {
    uint64_t v38 = *((void *)v151 + 71);
    int v39 = *(_DWORD *)(v38 + 24);
    uint64_t v32 = (v39 * *(_DWORD *)(a5 + 24));
    uint64_t v33 = (*(_DWORD *)(a5 + 28) * v39);
    if (v29)
    {
      if (v29 == -1)
      {
        float v35 = v34 * (float)v33;
      }
      else
      {
        float v40 = *(float *)(v38 + 11572) * 1000.0 * (float)(130 - v29);
        float v35 = v40 / 100.0;
      }
    }
    else
    {
      float v35 = 1000.0;
    }
    uint64_t v136 = (float (*)(void, uint64_t, uint64_t, float, float))PhonemeDurationOutlierDistance_LegacyOrTuning;
    if (UNICORN__log_select_GetLogLevel(*(void *)(*(void *)(a1 + 56) + 32)) < 3)
    {
      int v142 = 0;
    }
    else
    {
      UNICORN__log_select_Diag(*(void *)(a1 + 56), 3, (uint64_t)"phonidx %u: dist duroutlier legacy: phondur target %u msecs, stdevdur %u msecs, threshold %u msecs\n");
      int v142 = 0;
      uint64_t v136 = (float (*)(void, uint64_t, uint64_t, float, float))PhonemeDurationOutlierDistance_LegacyOrTuning;
    }
    uint64_t v22 = v152;
    goto LABEL_38;
  }
  float v35 = v155;
  if (v155 == 0.0
    || (uint64_t v36 = *(void *)(v22 + 11624)) == 0
    || (uint64_t v37 = *(void *)(v22 + 11632)) == 0
    || v134 >= *(_DWORD *)(v22 + 11608)
    || v148 > *(_DWORD *)(*(void *)(v22 + 11616) + 4 * v134))
  {
    uint64_t v136 = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    goto LABEL_28;
  }
  uint64_t v32 = (*(_DWORD *)(*(void *)(v36 + 8 * v134) + 4 * v148)
                     + *(_DWORD *)(*((void *)v151 + 71) + 24) * *(_DWORD *)(a5 + 24)) >> 1;
  uint64_t v133 = *(unsigned int *)(*(void *)(v37 + 8 * v134) + 4 * v148);
  float v30 = v154;
  uint64_t v136 = (float (*)(void, uint64_t, uint64_t, float, float))PhonemeDurationOutlierDistance;
  if (UNICORN__log_select_GetLogLevel(*(void *)(*(void *)(a1 + 56) + 32)) < 3)
  {
    int v142 = 0;
    uint64_t v22 = v152;
    uint64_t v33 = v133;
  }
  else
  {
    uint64_t v33 = v133;
    UNICORN__log_select_Diag(*(void *)(a1 + 56), 3, (uint64_t)"phonidx %u: dist duroutlier: phondur target %u msecs [(predicted %u + meancluster %u)/2], stdevcluster %u msecs, param1 %.3f, param2 %.3f\n");
    uint64_t v22 = v152;
    int v142 = 0;
    uint64_t v136 = (float (*)(void, uint64_t, uint64_t, float, float))PhonemeDurationOutlierDistance;
  }
LABEL_38:
  if (*(_DWORD *)(a8 + 56) != v31)
  {
    uint64_t v21 = Search_BNFCostCache_Fill(a1, v31, *(void *)(a1 + 136) + 56);
    uint64_t v22 = v152;
    if ((v21 & 0x80000000) != 0) {
      return v21;
    }
  }
  if (*(_DWORD *)(*((void *)v151 + 71) + 5992) != 1)
  {
    unsigned int v41 = v31 + 1;
    if ((v31 + 1) < *(_DWORD *)(a1 + 88) && v41 != *(_DWORD *)(a8 + 80))
    {
      uint64_t v21 = Search_BNFCostCache_Fill(a1, v41, *(void *)(a1 + 136) + 80);
      uint64_t v22 = v152;
      if ((v21 & 0x80000000) != 0) {
        return v21;
      }
    }
  }
  uint64_t v132 = v33;
  if (a3 < 3 || *(_DWORD *)(v22 + 5992) == 1 || *(_DWORD *)(a8 + 56) != v31) {
    goto LABEL_52;
  }
  int v42 = 0;
  uint64_t v43 = (a9 - 1);
  if (a9 < 1 || *(_DWORD *)(v22 + 6200) || v130 != -1) {
    goto LABEL_53;
  }
  if (*(float *)(*(void *)(v14 + 1352) + 4 * v43) != *(float *)(*(void *)(v14 + 1352) + 4 * a9)
    || *(_DWORD *)(*(void *)(a1 + 144) + 4 * v43))
  {
    goto LABEL_52;
  }
  float v156 = 0.0;
  float v157 = 0.0;
  uint64_t v125 = v22;
  BET5_GenericRules_Param_GetLocalValue(v22, v14, 1u, a9 - 1, &v157);
  if ((v21 & 0x80000000) != 0) {
    return v21;
  }
  BET5_GenericRules_Param_GetLocalValue(v125, v14, 2u, v43, &v156);
  if ((v21 & 0x80000000) != 0) {
    return v21;
  }
  if (v157 == v155)
  {
    uint64_t v22 = v152;
    if (v156 != v154)
    {
LABEL_52:
      int v42 = 0;
      goto LABEL_53;
    }
    int v42 = 1;
  }
  else
  {
    int v42 = 0;
    uint64_t v22 = v152;
  }
LABEL_53:
  uint64_t v144 = v32;
  uint64_t v44 = *(void *)(a1 + 104);
  uint64_t v45 = *(void *)(v44 + 2376);
  if (!v45)
  {
    uint64_t List = 0;
    unsigned int v46 = 0;
    float v60 = (void *)a8;
LABEL_116:
    if (v42)
    {
      uint64_t List = mfs_ClonePrevList(v60, a9, v134);
      if ((List & 0x80000000) != 0) {
        return List;
      }
      if (UNICORN__log_select_GetLogLevel(*(void *)(*(void *)(a1 + 56) + 32)) >= 4) {
        UNICORN__log_select_Diag(*(void *)(a1 + 56), 3, (uint64_t)"[Stage1 costs cloned from previous costlist.]\n");
      }
      goto LABEL_168;
    }
    float v78 = 1.0 - v17;
    float v79 = (void *)(v140 + 32 * a9);
    if (v142)
    {
      uint64_t v80 = *(void *)&v147[2 * v146];
      int v81 = v148;
      if (!*(_DWORD *)(v22 + 6200))
      {
        uint64_t v82 = *(void *)(v80 + 8 * v145);
        uint64_t v83 = v82 + 40 * (int)v148;
        int v85 = *(_DWORD *)(v83 + 4);
        uint64_t v84 = (unsigned int *)(v83 + 4);
        if (v85)
        {
          float v139 = (void *)(v140 + 32 * a9);
          unint64_t v86 = 0;
          uint64_t v87 = *(void *)(a8 + 72);
          do
          {
            float v88 = *(float *)(v87 + 4 * (v25 + v86));
            double v89 = ComputeFuzzyDist(v46, (uint64_t)&v157, v25 + (int)v86);
            float v90 = v88 + *(float *)&v89;
            unsigned int v91 = (float)(v90 * 10.0);
            if (v91 >= 0xFF) {
              int v92 = v160;
            }
            else {
              int v92 = &__b[v91];
            }
            ++*v92;
            *(float *)(*(void *)(a8 + 104) + 4 * v86++) = v90;
          }
          while (v86 < *v84);
LABEL_148:
          int v81 = v148;
          uint64_t v22 = v152;
          float v79 = v139;
        }
LABEL_149:
        int v108 = __b[0];
        for (uint64_t i = 1; i != 256; ++i)
        {
          v108 += __b[i];
          __b[i] = v108;
        }
        unsigned int v110 = (float)(*(float *)(v22 + 6156) * 10.0);
        if (v110 - 1 <= 0xFE)
        {
          while (__b[v110 - 1] < *(_DWORD *)(v22 + 6148))
          {
            if (++v110 == 256)
            {
              unsigned int v110 = 256;
              break;
            }
          }
        }
        unint64_t v111 = v110;
        unsigned int v112 = v110 != 0;
        uint64_t v113 = &__b[v110 - 1];
        while (v111 >= 2)
        {
          if (*(v113 - 1) <= *(_DWORD *)(v22 + 6148))
          {
            unsigned int v112 = v111;
            break;
          }
          --v111;
          unsigned int v114 = *v113--;
          if (v114 <= *(_DWORD *)(v22 + 6152))
          {
            unsigned int v112 = v111 + 1;
            break;
          }
        }
        uint64_t v115 = v82 + 40 * v81;
        unsigned int v118 = *(_DWORD *)(v115 + 4);
        uint64_t v116 = (unsigned int *)(v115 + 4);
        unint64_t v117 = v118;
        if (v118)
        {
          unint64_t v119 = 0;
          uint64_t v120 = a9;
          float v121 = (unsigned int *)(v140 + 32 * a9 + 16);
          do
          {
            unsigned int v122 = *v121;
            if (*v121 - a6 >= a7) {
              break;
            }
            float v123 = *(float *)(*(void *)(a8 + 104) + 4 * v119);
            if ((float)(v123 * 10.0) <= (float)v112)
            {
              uint64_t v124 = *v79 + 12 * v122;
              *(_DWORD *)uint64_t v124 = *(_DWORD *)(*v150 + 4 * (v149 + v119));
              *(float *)(v124 + 4) = (float)(v78 * v18) * v123;
              *(_DWORD *)(v124 + 8) = v25 + v119;
              *float v121 = v122 + 1;
              *(_DWORD *)(*(void *)(a8 + 112 + 8 * (int)v134) + 4 * (v119 >> 5)) |= 1 << v119;
              unint64_t v117 = *v116;
            }
            ++v119;
          }
          while (v119 < v117);
          goto LABEL_169;
        }
LABEL_168:
        uint64_t v120 = a9;
LABEL_169:
        if (UNICORN__log_select_GetLogLevel(*(void *)(*(void *)(v135 + 1072) + 32)) >= 3) {
          *(_DWORD *)(v135 + 1952) += *(_DWORD *)(v140 + 32 * v120 + 16);
        }
        return List;
      }
    }
    else
    {
      uint64_t v80 = *(void *)&v147[2 * v146];
      int v81 = v148;
    }
    uint64_t v82 = *(void *)(v80 + 8 * v145);
    if (!*(_DWORD *)(v82 + 40 * v81 + 4)) {
      goto LABEL_149;
    }
    float v139 = (void *)(v140 + 32 * a9);
    unint64_t v93 = 0;
    while (1)
    {
      uint64_t v94 = *(unsigned int *)(*v150 + 4 * (v149 + v93));
      if (v142)
      {
        int v95 = v25 + v93;
        uint64_t v96 = (v25 + v93);
        float v97 = 0.0;
      }
      else
      {
        float v97 = v136(*(_DWORD *)(*((void *)v151 + 71) + 24)* *(unsigned __int8 *)(*((void *)v151 + 307) + (v25 + v93)), v144, v132, v35, v30);
        if (v97 >= 9999.9)
        {
          int v95 = v25 + v93;
          uint64_t v98 = a8;
          goto LABEL_144;
        }
        int v95 = v25 + v93;
        uint64_t v96 = (v25 + v93);
      }
      uint64_t v98 = a8;
      float v97 = v97 + *(float *)(*(void *)(a8 + 72) + 4 * v96);
      if (*(_DWORD *)(v152 + 6200))
      {
        if (*(_DWORD *)(v152 + 6196))
        {
          int v99 = *(char *)(*((void *)v151 + 130) + (v129 + v93));
          float v100 = *(float *)(v152 + 6192);
          if (v99 < (int)v100)
          {
            float v101 = (float)v99 / v100;
LABEL_143:
            float v97 = v97 * v101;
          }
        }
        else
        {
          float v102 = *(float *)(*((void *)v151 + 74) + 16 * v94);
          float v103 = *(float *)(v152 + 6192);
          if (v102 < v103)
          {
            float v101 = v102 / v103;
            goto LABEL_143;
          }
        }
      }
LABEL_144:
      double v104 = ComputeFuzzyDist(v46, (uint64_t)&v157, v95);
      float v105 = v97 + *(float *)&v104;
      unsigned int v106 = (float)(v105 * 10.0);
      if (v106 >= 0xFF) {
        v107 = v160;
      }
      else {
        v107 = &__b[v106];
      }
      ++*v107;
      *(float *)(*(void *)(v98 + 104) + 4 * v93++) = v105;
      uint64_t v82 = *(void *)(*(void *)&v147[2 * v146] + 8 * v145);
      if (v93 >= *(unsigned int *)(v82 + 40 * (int)v148 + 4)) {
        goto LABEL_148;
      }
    }
  }
  unsigned int v46 = 0;
  unsigned int v47 = 0;
  uint64_t v131 = *(void *)(a1 + 120);
  float v156 = 0.0;
  uint64_t v48 = *(unsigned int *)(v44 + 2384) + 1;
  do
  {
    if (!--v48) {
      break;
    }
    if (*(_DWORD *)(v45 + 20))
    {
      *(void *)&v158[v47] = v45;
      unsigned int v46 = ++v47;
    }
    v45 += 64;
  }
  while (v47 < 0x64);
  int v128 = v42;
  if (*(void *)(v44 + 2392))
  {
    if (v47 > 0x63)
    {
      uint64_t List = 0;
LABEL_87:
      int v127 = v25;
      unsigned int v61 = 0;
      uint64_t v62 = *(void *)(a1 + 120);
      uint64_t v63 = (v31 + 1);
      while (1)
      {
        uint64_t v64 = *(void *)&v158[v61];
        uint64_t v65 = *(unsigned int *)(v64 + 16);
        uint64_t v66 = *(void *)(v62 + 8);
        if ((v65 - 253) > 1)
        {
          uint64_t v69 = *(void *)(v66 + 8 * v65 + 16);
          if (!v69) {
            goto LABEL_101;
          }
          float v68 = (unsigned __int8 *)(v69 + v31);
          goto LABEL_97;
        }
        uint64_t v67 = *(void *)(v66 + 32);
        if (!v67) {
          goto LABEL_101;
        }
        if (v65 == 253)
        {
          if (v31)
          {
            float v68 = (unsigned __int8 *)(v67 + (v31 - 1));
LABEL_97:
            unsigned int v70 = *v68;
            goto LABEL_99;
          }
        }
        else if (v63 < *(_DWORD *)(a1 + 88))
        {
          float v68 = (unsigned __int8 *)(v67 + v63);
          goto LABEL_97;
        }
        unsigned int v70 = 1;
LABEL_99:
        LOBYTE(v158[v61]) = v70;
        if (*(_DWORD *)(v64 + 36) <= v70)
        {
LABEL_101:
          if (UNICORN__log_select_GetLogLevel(*(void *)(*(void *)(a1 + 56) + 32)) >= 3) {
            UNICORN__log_select_Diag(*(void *)(a1 + 56), 3, (uint64_t)"\nphonidx %u: Warning : fuzzy table %s has been deactivated for target feature value %u\n");
          }
          unsigned int v71 = v61 + 1;
          if (v61 + 1 < v46)
          {
            unint64_t v72 = v46 - (unint64_t)v71;
            int v73 = &v158[v71];
            unsigned int v74 = v61;
            do
            {
              long long v75 = *v73++;
              v158[v74++] = v75;
              --v72;
            }
            while (v72);
          }
          unsigned int v47 = --v46;
          goto LABEL_107;
        }
        ++v61;
LABEL_107:
        if (v61 >= v47)
        {
          int v25 = v127;
          goto LABEL_109;
        }
      }
    }
    if (*(_DWORD *)(v44 + 2400))
    {
      unint64_t v49 = 0;
      while (1)
      {
        uint64_t v50 = *(void *)(v44 + 2392);
        uint64_t List = BET5_GenericRules_Rule_Matches(v131, (unsigned int *)(v50 + 48 * v49), v31, &v156);
        if ((List & 0x80000000) != 0) {
          return List;
        }
        if (v156 != 0.0)
        {
          uint64_t v52 = *(unsigned int *)(v50 + 48 * v49 + 16);
          if (v52)
          {
            uint64_t v53 = 0;
            uint64_t v54 = *(void *)(v50 + 48 * v49 + 24);
            do
            {
              if (*(_DWORD *)(v54 + 12 * v53) == 4)
              {
                if (v46)
                {
                  uint64_t v55 = 0;
                  uint64_t v56 = *(void *)(v44 + 2376);
                  uint64_t v57 = *(unsigned int *)(v54 + 12 * v53 + 8);
                  uint64_t v58 = v46;
                  float v59 = &v157;
                  while (*(_DWORD *)(*(void *)v59 + 16) != *(_DWORD *)(v56 + (v57 << 6) + 16))
                  {
                    ++v55;
                    v59 += 4;
                    if (v46 == v55) {
                      goto LABEL_77;
                    }
                  }
                  *(void *)float v59 = v56 + (v57 << 6);
                }
                else
                {
                  LODWORD(v55) = 0;
                }
                if (v55 == v46)
                {
                  uint64_t v56 = *(void *)(v44 + 2376);
                  uint64_t v57 = *(unsigned int *)(v54 + 12 * v53 + 8);
                  uint64_t v58 = v46;
LABEL_77:
                  *(void *)&v158[v58] = v56 + (v57 << 6);
                  ++v46;
                }
              }
              ++v53;
            }
            while (v53 != v52);
          }
        }
        if (v46 >= 0x64) {
          break;
        }
        ++v49;
        unsigned int v47 = v46;
        if (v49 >= *(unsigned int *)(v44 + 2400)) {
          goto LABEL_84;
        }
      }
      unsigned int v47 = v46;
      goto LABEL_87;
    }
  }
  uint64_t List = 0;
LABEL_84:
  if (v47) {
    goto LABEL_87;
  }
LABEL_109:
  if (UNICORN__log_select_GetLogLevel(*(void *)(*(void *)(a1 + 56) + 32)) <= 2)
  {
    float v60 = (void *)a8;
  }
  else
  {
    float v60 = (void *)a8;
    if (v46)
    {
      uint64_t v76 = 0;
      float v77 = v158;
      do
      {
        ++v77;
        UNICORN__log_select_Diag(*(void *)(a1 + 56), 3, (uint64_t)"phonidx %u: dist fuzzy %u:%s: target feature value: %u\n");
        ++v76;
      }
      while (v46 != v76);
    }
  }
  uint64_t v22 = v152;
  int v42 = v128;
  if ((List & 0x80000000) == 0) {
    goto LABEL_116;
  }
  return List;
}

uint64_t Search_BNFCostCache_Fill(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v6 = *(void *)(a1 + 112);
  if (*(_DWORD *)(v6 + 5992) == 1)
  {
    int v7 = *(_DWORD *)v5 * a2;
    unsigned int v8 = *(_DWORD *)v5 + 2;
  }
  else
  {
    unsigned int v8 = 3;
    int v7 = a2;
  }
  uint64_t v27 = *(void *)(a1 + 120);
  uint64_t v9 = *(void *)(*(void *)(a1 + 72) + 384);
  cstdlib_memset(*(void **)(a3 + 8), 0, 4 * *(unsigned int *)(a3 + 4));
  uint64_t result = 0;
  if (v8 < 3)
  {
LABEL_11:
    *(_DWORD *)a3 = a2;
  }
  else
  {
    float v28 = 0.0;
    uint64_t v11 = 2;
    while (1)
    {
      uint64_t v12 = *(unsigned int *)(*(void *)(v9 + 312 * a2 + 64) + 4 * v11);
      uint64_t BnfTargetVectorPacked = GetBnfTargetVectorPacked(v27, v7, &v28);
      uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, void, float))(a1 + 384))(v5, *(void *)(a1 + 56), BnfTargetVectorPacked, v12, v11, *(void *)(*(void *)(a1 + 136) + 104), v28);
      if ((result & 0x80000000) != 0) {
        break;
      }
      uint64_t v14 = *(void *)(*(void *)(v5 + 776) + 8 * v11);
      uint64_t v15 = v14 + 40 * (int)v12;
      int v17 = *(_DWORD *)(v15 + 4);
      unsigned int v16 = (unsigned int *)(v15 + 4);
      if (v17)
      {
        unint64_t v18 = 0;
        uint64_t v19 = *(unsigned int *)(v14 + 40 * (int)v12);
        uint64_t v20 = *(void *)(v5 + 816);
        int v21 = *(_DWORD *)(*(void *)(v5 + 848)
                        + 4 * (*(_DWORD *)(v20 + 4 * v19) / *(_DWORD *)(*(void *)(v5 + 568) + 5992)));
        uint64_t v22 = *(void *)(*(void *)(a1 + 136) + 104);
        uint64_t v23 = *(void *)(a3 + 8);
        uint64_t v24 = *(void *)(a3 + 16);
        do
        {
          unsigned int v25 = *(_DWORD *)(v20 + 4 * (v19 + v18)) / *(_DWORD *)(v6 + 5992);
          *(_DWORD *)(v23 + 4 * (v25 >> 5)) |= 1 << v25;
          *(_DWORD *)(v24 + 4 * (v21 + v18)) = *(_DWORD *)(v22 + 4 * v18);
          ++v18;
        }
        while (v18 < *v16);
      }
      ++v11;
      ++v7;
      if (v11 == v8) {
        goto LABEL_11;
      }
    }
  }
  return result;
}

double ComputeFuzzyDist(unsigned int a1, uint64_t a2, int a3)
{
  if (!a1) {
    return 0.0;
  }
  uint64_t v3 = a1;
  uint64_t v4 = (unsigned __int8 *)(a2 + 8);
  double result = 0.0;
  do
  {
    uint64_t v6 = *((void *)v4 - 1);
    uint64_t v7 = *(void *)(v6 + 40);
    if (v7) {
      *(float *)&double result = *(float *)&result
    }
                        + *(float *)(*(void *)(v6 + 24)
                                   + 4
                                   * (*(unsigned __int8 *)(v7
                                                         + *(unsigned __int8 *)(v6 + 49)
                                                         + *(unsigned __int8 *)(v6 + 48) * a3)
                                    + *(_DWORD *)(v6 + 36) * *v4));
    v4 += 16;
    --v3;
  }
  while (v3);
  return result;
}

uint64_t UnicornSearch_Create(uint64_t a1)
{
  uint64_t v2 = heap_Calloc(*(void **)(a1 + 8), 1, 400);
  uint64_t v3 = v2;
  if (v2)
  {
    *(_DWORD *)(v2 + 360) = 1;
    uint64_t v4 = heap_Calloc(*(void **)(a1 + 8), 1, 16);
    *(void *)(v3 + 352) = v4;
    if (v4
      && (*(_DWORD *)(v3 + 376) = 1,
          uint64_t v5 = heap_Calloc(*(void **)(a1 + 8), 1, 16),
          (*(void *)(v3 + 368) = v5) != 0))
    {
      *(void *)uint64_t v3 = UnicornSearch_Open;
      *(void *)(v3 + 8) = UnicornSearch_Set;
      *(void *)(v3 + 16) = UnicornSearch_Process;
      *(void *)(v3 + 24) = UnicornSearch_ProcessOne;
      *(void *)(v3 + 32) = UnicornSearch_Reset;
      *(void *)(v3 + 40) = UnicornSearch_Close;
      *(void *)(v3 + 48) = UnicornSearch_SetSIMDCallback;
      *(void *)(v3 + 56) = a1;
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

uint64_t UnicornSearch_Open(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = 2229280778;
  if (a1)
  {
    uint64_t v5 = (int *)a2[1];
    uint64_t v4 = (_DWORD *)a2[2];
    uint64_t v6 = *a2;
    *(void *)(a1 + 104) = v5;
    *(void *)(a1 + 112) = v4;
    *(void *)(a1 + 72) = v6;
    *(void *)(a1 + 80) = v4;
    *(void *)(a1 + 64) = v5;
    int v7 = *v5;
    int v8 = *(_DWORD *)(v6 + 392);
    *(_DWORD *)(a1 + 88) = v8;
    if (v4[1496]) {
      int v9 = 1;
    }
    else {
      int v9 = v7;
    }
    *(_DWORD *)(a1 + 96) = v7;
    *(_DWORD *)(a1 + 100) = v8 * v9;
    *(void *)(a1 + 120) = v6;
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = v6 + 1088;
    *(unsigned char *)(a1 + 156) = 1;
    *(_DWORD *)(a1 + 160) = v4[1548];
    *(unsigned char *)(a1 + 164) = 0;
    *(_DWORD *)(a1 + 168) = v4[1693];
    uint64_t v10 = *(void *)(v6 + 1808);
    if (v10)
    {
      heap_Free(*(void **)(*(void *)(a1 + 56) + 8), v10);
      uint64_t v6 = *(void *)(a1 + 120);
      *(void *)(v6 + 1808) = 0;
    }
    uint64_t v11 = *(void *)(v6 + 1816);
    if (v11)
    {
      heap_Free(*(void **)(*(void *)(a1 + 56) + 8), v11);
      uint64_t v6 = *(void *)(a1 + 120);
      *(void *)(v6 + 1816) = 0;
    }
    *(_DWORD *)(v6 + 1824) = 0;
    *(void *)(a1 + 336) = *(void *)(v6 + 1896);
    uint64_t v12 = heap_Calloc(*(void **)(*(void *)(a1 + 56) + 8), (*(_DWORD *)(a1 + 96) * *(_DWORD *)(a1 + 88)), 4);
    *(void *)(a1 + 144) = v12;
    if (v12)
    {
      int v13 = *(_DWORD *)(a1 + 88);
      int v14 = *(_DWORD *)(a1 + 96);
      uint64_t v15 = *(void *)(a1 + 120);
      if (v14 * v13)
      {
        uint64_t v16 = 0;
        unint64_t v17 = 0;
        unint64_t v18 = *(void **)(v15 + 1768);
        do
        {
          if (v18)
          {
            if (*(_DWORD *)(*v18 + v16)) {
              BOOL v19 = 0;
            }
            else {
              BOOL v19 = **(_DWORD **)(*v18 + v16 + 8) > *(_DWORD *)(*(void *)(a1 + 112) + 11548);
            }
            *(_DWORD *)(v12 + 4 * v17) = v19;
            int v13 = *(_DWORD *)(a1 + 88);
            int v14 = *(_DWORD *)(a1 + 96);
          }
          ++v17;
          unint64_t v20 = (v14 * v13);
          v16 += 48;
        }
        while (v17 < v20);
      }
      else
      {
        LODWORD(v20) = 0;
      }
      uint64_t v21 = UNICORN__mfs_CostList_Init(*(void *)(a1 + 56), *(void *)(a1 + 104), (unsigned int *)(v15 + 1088), v20, 0);
      uint64_t v22 = *(void *)(a1 + 112);
      *(void *)(*(void *)(a1 + 136) + 224) = &tblBNFContextWeights[5 * *(int *)(v22 + 6752)];
      if ((v21 & 0x80000000) != 0) {
        return v21;
      }
      uint64_t v2 = UNICORN__mfs_TCost_Init(*(void *)(a1 + 56), v22, (_DWORD *)(a1 + 176));
      if ((v2 & 0x80000000) == 0)
      {
        uint64_t v23 = *(unsigned int *)(*(void *)(a1 + 72) + 32);
        *(_DWORD *)(a1 + 152) = 0;
        if ((int)v23 >= 1)
        {
          uint64_t v24 = 0;
          uint64_t v25 = *(void *)(a1 + 80) + 184;
          do
          {
            if (*(_DWORD *)(v25 + 4 * v24) == 2) {
              break;
            }
            *(_DWORD *)(a1 + 152) = ++v24;
          }
          while (v23 != v24);
        }
        int v26 = *(_DWORD **)(a1 + 112);
        if (v26[1535])
        {
          if (v26[1495])
          {
            uint64_t v27 = *(void **)(a1 + 352);
            *uint64_t v27 = 0;
            v27[1] = Search_Diphone_PruneBNF;
            if (*(_DWORD *)(*(void *)(a1 + 104) + 1928) != 1) {
              goto LABEL_42;
            }
            goto LABEL_36;
          }
          if (*(_DWORD *)(*(void *)(a1 + 104) + 1928) == 1)
          {
            *(_DWORD *)(a1 + 380) = 1;
            float v28 = *(void **)(a1 + 352);
            int v29 = Search_PruneBNF_TreeIndex;
            goto LABEL_35;
          }
          uint64_t v31 = *(void **)(a1 + 352);
          uint64_t v32 = Search_PruneBNF;
        }
        else
        {
          if (*(_DWORD *)(*(void *)(a1 + 104) + 1928) == 1)
          {
            *(_DWORD *)(a1 + 380) = 1;
            float v28 = *(void **)(a1 + 352);
            int v29 = Search_TreeIndex;
LABEL_35:
            void *v28 = 0;
            v28[1] = v29;
LABEL_36:
            float v30 = *(void **)(a1 + 368);
            *float v30 = 0;
            v30[1] = UnicornSearch_StageTwo_TreeIndex_Sliced;
            if (v26[1688] == 1 && v26[1700] == 9) {
              v30[1] = UnicornSearch_StageTwo_TreeIndex_Cascaded;
            }
            return v2;
          }
          uint64_t v31 = *(void **)(a1 + 352);
          uint64_t v32 = Search_NoPrune;
        }
        *uint64_t v31 = 0;
        v31[1] = v32;
LABEL_42:
        uint64_t v33 = *(void **)(a1 + 368);
        *uint64_t v33 = 0;
        v33[1] = UnicornSearch_StageTwo_Default;
      }
    }
  }
  return v2;
}

uint64_t UnicornSearch_Set(uint64_t a1, unsigned int a2)
{
  *(_DWORD *)(a1 + 92) = a2;
  *(void *)(a1 + 128) = *(void *)(*(void *)(a1 + 72) + 384) + 312 * a2;
  UNICORN__log_select_Diag(*(void *)(a1 + 56), 11, (uint64_t)"[Phoneme %d]\n");
  UNICORN__mfs_Ling_GetPhonCtxt(*(void *)(*(void *)(a1 + 72) + 8), *(_DWORD *)(a1 + 92), (unsigned char *)(a1 + 344));
  UNICORN__mfs_Ling_LogPhonCtxt(*(void *)(a1 + 56), *(void *)(a1 + 80), *(void *)(*(void *)(a1 + 72) + 8), *(_DWORD *)(a1 + 92));
  if (*(_DWORD *)(a1 + 380) && *(_DWORD *)(*(void *)(a1 + 112) + 5992) != 1)
  {
    uint64_t v3 = *(void *)(a1 + 136);
    long long v7 = *(_OWORD *)(v3 + 32);
    uint64_t v8 = *(void *)(v3 + 48);
    *(_OWORD *)(v3 + 32) = *(_OWORD *)(v3 + 56);
    *(void *)(v3 + 48) = *(void *)(v3 + 72);
    uint64_t v4 = *(void *)(a1 + 136);
    *(void *)(v4 + 72) = *(void *)(v4 + 96);
    *(_OWORD *)(v4 + 56) = *(_OWORD *)(v4 + 80);
    uint64_t v5 = *(void *)(a1 + 136);
    *(_OWORD *)(v5 + 80) = v7;
    *(void *)(v5 + 96) = v8;
  }
  if (*(_DWORD *)(*(void *)(a1 + 104) + 1928) == 1) {
    Unicorn_CostListBlock_Set(*(void *)(a1 + 136), *(void *)(a1 + 128));
  }
  return 0;
}

uint64_t UnicornSearch_Process(uint64_t a1)
{
  if (*(int *)(a1 + 88) < 1) {
    return 0;
  }
  unsigned int v2 = 0;
  while (1)
  {
    UnicornSearch_Set(a1, v2);
    uint64_t result = UnicornSearch_ProcessOne(a1, v3);
    if ((result & 0x80000000) != 0) {
      break;
    }
    if ((signed int)++v2 >= *(_DWORD *)(a1 + 88)) {
      return 0;
    }
  }
  return result;
}

uint64_t UnicornSearch_ProcessOne(uint64_t a1, __n128 a2)
{
  int v3 = *(_DWORD *)(a1 + 96);
  if ((v3 - 1) <= 0xFFFFFFFC)
  {
    uint64_t v4 = 0;
    int v5 = v3 * *(_DWORD *)(a1 + 92);
    unint64_t v6 = 2;
    while (1)
    {
      if (*(unsigned char *)(a1 + 345) == 1)
      {
        if (!*(unsigned char *)(a1 + 156) || v6 == 3 && v3 == 3) {
          goto LABEL_18;
        }
        if (v6 == 2)
        {
          long long v7 = (unsigned char *)(a1 + 344);
          if (!*(_DWORD *)(a1 + 92)) {
            goto LABEL_18;
          }
LABEL_12:
          if (*v7 == 1) {
            goto LABEL_18;
          }
          goto LABEL_13;
        }
        if (v6 == v3 + 1)
        {
          long long v7 = (unsigned char *)(a1 + 346);
          if (*(_DWORD *)(a1 + 92) == *(_DWORD *)(a1 + 88) - 1) {
            goto LABEL_18;
          }
          goto LABEL_12;
        }
      }
LABEL_13:
      unsigned int v8 = v5 + v6 - 2;
      uint64_t v9 = *(void *)(a1 + 120);
      uint64_t v10 = *(uint64_t **)(v9 + 1768);
      if (!v10)
      {
        uint64_t v12 = (v5 + v6 - 2);
LABEL_17:
        uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, uint64_t, void, void, void))(*(void *)(a1 + 352) + 8))(a1, 1, v6, a1 + 344, *(void *)(a1 + 128), *(unsigned int *)(*(void *)(*(void *)(a1 + 136) + 16) + 32 * v12 + 16), *(unsigned int *)(*(void *)(a1 + 112) + 5548));
        if ((v4 & 0x80000000) != 0) {
          return v4;
        }
        goto LABEL_18;
      }
      uint64_t v11 = *v10;
      uint64_t v12 = (v5 + v6 - 2);
      if (*(_DWORD *)(v11 + 48 * v8)) {
        goto LABEL_17;
      }
      UNICORN__mfs_CostList_Add(0.0, *(void *)(a1 + 104), (void *)(v9 + 1088), v8, *(_DWORD *)(*(void *)(v11 + 48 * v12 + 8)+ 4 * (*(_DWORD *)(v11 + 48 * v12 + 24) - 1)));
LABEL_18:
      ++v6;
      int v3 = *(_DWORD *)(a1 + 96);
      unint64_t v13 = (v3 + 2);
      if (v6 >= v13)
      {
        if (v13 >= 3)
        {
          uint64_t v14 = *(void *)(a1 + 120);
          uint64_t v15 = *(void **)(v14 + 1768);
          uint64_t v16 = 2;
          a2.n128_u32[0] = 1167867904;
          do
          {
            if (v15)
            {
              uint64_t v17 = (v5 - 2 + v16);
              if (*(_DWORD *)(*v15 + 48 * v17) == 1)
              {
                uint64_t v18 = *(void *)(v14 + 1104) + 32 * v17;
                uint64_t v19 = *(unsigned int *)(v18 + 16);
                if (v19)
                {
                  uint64_t v20 = 0;
                  uint64_t v21 = *v15 + 48 * v17;
                  uint64_t v22 = *(unsigned int *)(v21 + 24);
                  uint64_t v23 = (int **)(v21 + 8);
                  do
                  {
                    if (v22)
                    {
                      uint64_t v24 = (_DWORD *)(*(void *)v18 + 12 * v20);
                      int v27 = *v24;
                      uint64_t v25 = (float *)(v24 + 1);
                      int v26 = v27;
                      float v28 = *v23;
                      uint64_t v29 = v22;
                      do
                      {
                        int v30 = *v28++;
                        if (v26 == v30) {
                          *uint64_t v25 = *v25 + 5000.0;
                        }
                        --v29;
                      }
                      while (v29);
                    }
                    ++v20;
                  }
                  while (v20 != v19);
                }
              }
            }
            ++v16;
          }
          while (v16 != v13);
        }
        goto LABEL_34;
      }
    }
  }
  uint64_t v4 = 0;
LABEL_34:
  if ((v3 - 1) <= 0xFFFFFFFC)
  {
    uint64_t v31 = 2;
    do
    {
      uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, __n128))(*(void *)(a1 + 368) + 8))(a1, v31, a2);
      if ((v4 & 0x80000000) != 0) {
        break;
      }
      uint64_t v31 = (v31 + 1);
    }
    while (v31 < *(_DWORD *)(a1 + 96) + 2);
  }
  return v4;
}

uint64_t UnicornSearch_Reset()
{
  return 0;
}

uint64_t UnicornSearch_Close(uint64_t a1)
{
  UNICORN__mfs_TCost_Clear(a1 + 176);
  uint64_t v2 = *(void *)(a1 + 144);
  if (v2)
  {
    heap_Free(*(void **)(*(void *)(a1 + 56) + 8), v2);
    *(void *)(a1 + 144) = 0;
  }
  return 0;
}

uint64_t UnicornSearch_SetSIMDCallback(uint64_t *a1, int a2)
{
  if (!*(_DWORD *)(a1[14] + 6728))
  {
    if (a2)
    {
      a1[48] = (uint64_t)mfs_bnfData_Clusterize_Block_Distance_fxd16_SIMD;
      uint64_t v9 = mfs_bnfData_Distance_Unit_ID_fxd16_SIMD;
    }
    else
    {
      a1[48] = (uint64_t)mfs_bnfData_Clusterize_Block_Distance_fxd16;
      uint64_t v9 = mfs_bnfData_Distance_Unit_ID_fxd16;
    }
    goto LABEL_11;
  }
  if (!a2)
  {
LABEL_13:
    a1[49] = (uint64_t)mfs_bnfData_Distance_Unit_ID_RandomProjection;
    a1[48] = (uint64_t)mfs_bnfData_Clusterize_Block_Distance_RandomProjection;
    goto LABEL_14;
  }
  HIDWORD(v4) = *(unsigned __int8 *)(a1[13] + 1520);
  LODWORD(v4) = (HIDWORD(v4) << 24) - 0x8000000;
  unsigned int v5 = (v4 >> 27);
  BOOL v6 = v5 > 7;
  int v7 = (1 << v5) & 0xAB;
  if (v6 || v7 == 0)
  {
    UNICORN__log_select_Diag(a1[7], 1, (uint64_t)"WARNING : SIMD Random Projection Search only available for BNF size of16/32/48/64 Bytes, current size %d;"
               " fallback to ANSIC implementation. \n");
    goto LABEL_13;
  }
  a1[48] = (uint64_t)mfs_bnfData_Clusterize_Block_Distance_RandomProjection_SIMD;
  uint64_t v9 = mfs_bnfData_Distance_Unit_ID_RandomProjection_SIMD;
LABEL_11:
  a1[49] = (uint64_t)v9;
LABEL_14:
  mfs_TCost_EnableSIMD((uint64_t)(a1 + 22), a2);
  return 0;
}

void *UnicornSearch_Destroy(uint64_t *a1)
{
  UNICORN__log_select_Diag(a1[7], 10, (uint64_t)"+Destroy\n");
  heap_Free(*(void **)(a1[7] + 8), a1[44]);
  a1[44] = 0;
  heap_Free(*(void **)(a1[7] + 8), a1[46]);
  a1[46] = 0;
  UNICORN__log_select_Diag(a1[7], 10, (uint64_t)"--Destroy\n");
  uint64_t v2 = *(void **)(a1[7] + 8);

  return heap_Free(v2, (uint64_t)a1);
}

uint64_t UnicornSearch_StageTwo_Default(uint64_t a1, uint64_t a2)
{
  v54[1] = *MEMORY[0x263EF8340];
  unsigned int v3 = a2 + *(_DWORD *)(a1 + 96) * *(_DWORD *)(a1 + 92);
  uint64_t v4 = v3 - 2;
  uint64_t v6 = *(void *)(a1 + 112);
  uint64_t v5 = *(void *)(a1 + 120);
  float v7 = *(float *)(*(void *)(v5 + 1352) + 4 * v4);
  v54[0] = 0;
  if (*(_DWORD *)(v6 + 5992) != 1)
  {
    UNICORN__log_select_Diag(*(void *)(a1 + 56), 1, (uint64_t)"CONFIG ERROR : Search is not implemented for Phoneme Substate Modeling\n");
    return 2229280768;
  }
  uint64_t v46 = a1 + 176;
  uint64_t updated = UNICORN__mfs_TCost_SetTarget(a1 + 176, *(void *)(a1 + 104), v5, *(void **)(a1 + 128), a2);
  if ((updated & 0x80000000) == 0)
  {
    if (*(float *)(*(void *)(a1 + 112) + 6704) == 0.0
      || (uint64_t updated = mfs_UpdateTargetQuantizedTrajectory_LF0(*(void *)(a1 + 104), *(void *)(a1 + 120), v46),
          (updated & 0x80000000) == 0))
    {
      uint64_t v10 = *(void *)(a1 + 336);
      if (v10)
      {
        LODWORD(v54[0]) = *(_DWORD *)(v10 + 4 * (2 * v4));
        HIDWORD(v54[0]) = *(_DWORD *)(v10 + 4 * ((2 * v4) | 1u));
      }
      if (!*(unsigned char *)(a1 + 156) && *(unsigned char *)(a1 + 345) == 1)
      {
        uint64_t v11 = *(void *)(a1 + 136);
        LODWORD(v12) = *(_DWORD *)(*(void *)(v11 + 16) + 32 * v4 + 16);
LABEL_69:
        unsigned int v42 = *(_DWORD *)(*(void *)(a1 + 112) + 5564);
        if (v12 > v42)
        {
          uint64_t updated = mfs_CostList_Select(v11, v4, 1, v42);
          UNICORN__mfs_CostList_Prune(*(void **)(a1 + 136), v4, *(_DWORD *)(*(void *)(a1 + 112) + 5564));
        }
        goto LABEL_71;
      }
      IndexPtr_LH_F32 = (float *)VectBlock_Get_IndexPtr_LH_F32(*(void *)(a1 + 120) + 1848, v3 - 2);
      int v13 = *(_DWORD *)(*(void *)(a1 + 112) + 6752);
      if (v13 < 1)
      {
        uint64_t v48 = 0;
      }
      else
      {
        if (v3 - 1 >= *(_DWORD *)(a1 + 100))
        {
          uint64_t v48 = 0;
        }
        else
        {
          uint64_t v48 = (float *)VectBlock_Get_IndexPtr_LH_F32(*(void *)(a1 + 120) + 1848, v3 - 1);
          int v13 = *(_DWORD *)(*(void *)(a1 + 112) + 6752);
        }
        if (v13 >= 2 && v3 < *(_DWORD *)(a1 + 100))
        {
          unsigned int v47 = (float *)VectBlock_Get_IndexPtr_LH_F32(*(void *)(a1 + 120) + 1848, v3);
          if (v3 == 2)
          {
LABEL_19:
            uint64_t v14 = 0;
            goto LABEL_27;
          }
LABEL_21:
          if (*(int *)(*(void *)(a1 + 112) + 6752) < 1) {
            uint64_t v14 = 0;
          }
          else {
            uint64_t v14 = (float *)VectBlock_Get_IndexPtr_LH_F32(*(void *)(a1 + 120) + 1848, v3 - 3);
          }
          if (v4 >= 2 && *(int *)(*(void *)(a1 + 112) + 6752) >= 2)
          {
            uint64_t v15 = (float *)VectBlock_Get_IndexPtr_LH_F32(*(void *)(a1 + 120) + 1848, v3 - 4);
LABEL_28:
            uint64_t v16 = *(void *)(a1 + 136);
            uint64_t v18 = *(void *)(v16 + 16);
            uint64_t v17 = (void *)(v16 + 16);
            if (!*(_DWORD *)(v18 + 32 * v4 + 16))
            {
LABEL_71:
              UNICORN__log_select_Diag(*(void *)(a1 + 56), 11, (uint64_t)"costlist(%d)\n");
              return updated;
            }
            uint64_t v19 = 0;
            unint64_t v20 = 0;
            float v21 = 1.0 - v7;
            BOOL v23 = (float)(1.0 - v7) > 0.0 && IndexPtr_LH_F32 != 0;
            BOOL v45 = v23;
            while (1)
            {
              uint64_t v51 = 0;
              memset(v50, 0, sizeof(v50));
              int v24 = *(unsigned char *)(a1 + 164) == 1 ? *(_DWORD *)(a1 + 280) : 0;
              unsigned int v25 = *(_DWORD *)(*(void *)(*v17 + 32 * v4) + v19);
              int v49 = v24;
              UNICORN__mfs_Stub_ParamMap_GetAcousticVector(*(void *)(a1 + 56), *(void *)(a1 + 104), *(void *)(a1 + 120), v25, (uint64_t)v50, &v49, 0.0);
              uint64_t updated = v27;
              if ((v27 & 0x80000000) != 0) {
                return updated;
              }
              uint64_t v28 = *(void *)(a1 + 112);
              unsigned int v29 = *(unsigned __int8 *)(a1 + 164);
              if (*(void *)(a1 + 336)) {
                mfs_TCost_BNFCandidateCostStreamElf0(v46, v28, (uint64_t)v50, v49, &v52, v29, (float *)v54, *(_DWORD *)(a1 + 168), v26);
              }
              else {
                mfs_TCost_BNFCandidateCostStream(v46, v28, (uint64_t)v50, v49, &v52, v29, *(_DWORD *)(a1 + 168));
              }
              if (*(unsigned char *)(a1 + 164))
              {
                float v30 = *(float *)(a1 + 180) * *(float *)(a1 + 292);
                float v52 = v30
                    * UNICORN__CandidatePhonemeDurationDistanceBasic(*(void *)(a1 + 104), v25, a2, *(_DWORD *)(*(void *)(a1 + 128) + 24));
              }
              UNICORN__mfs_ParamMap_UnMapSection(*(void *)(a1 + 120));
              float v31 = 0.0;
              if (v45)
              {
                uint64_t v32 = *(void *)(a1 + 112);
                if (*(_DWORD *)(v32 + 6140))
                {
                  float v33 = *(float *)(*(void *)(*(void *)(*(void *)(a1 + 136) + 16) + 32 * v4) + v19 + 4);
                }
                else
                {
                  float v33 = mfs_bnfData_Distance(*(void *)(a1 + 104), IndexPtr_LH_F32, v25);
                  uint64_t v32 = *(void *)(a1 + 112);
                }
                float v31 = v33 * tblBNFContextWeights[5 * *(int *)(v32 + 6752)];
              }
              if (v14 && v25 && v21 > 0.0)
              {
                float v34 = tblBNFContextWeights[5 * *(int *)(*(void *)(a1 + 112) + 6752) + 1];
                float v31 = v31 + (float)(v34 * mfs_bnfData_Distance(*(void *)(a1 + 104), v14, v25 - 1));
              }
              if (v15 && v25 >= 2 && v21 > 0.0)
              {
                float v35 = tblBNFContextWeights[5 * *(int *)(*(void *)(a1 + 112) + 6752) + 3];
                float v31 = v31 + (float)(v35 * mfs_bnfData_Distance(*(void *)(a1 + 104), v15, v25 - 2));
              }
              if (v48)
              {
                uint64_t v36 = *(void *)(a1 + 112);
                if (v25 < *(_DWORD *)(v36 + 11548) - 1 && v21 > 0.0)
                {
                  float v37 = tblBNFContextWeights[5 * *(int *)(v36 + 6752) + 2];
                  float v31 = v31 + (float)(v37 * mfs_bnfData_Distance(*(void *)(a1 + 104), v48, v25 + 1));
                }
              }
              if (v47)
              {
                uint64_t v38 = *(void *)(a1 + 112);
                if (v25 < *(_DWORD *)(v38 + 11548) - 2 && v21 > 0.0)
                {
                  float v39 = tblBNFContextWeights[5 * *(int *)(v38 + 6752) + 4];
                  float v31 = v31 + (float)(v39 * mfs_bnfData_Distance(*(void *)(a1 + 104), v47, v25 + 2));
                }
              }
              float v40 = v53;
              if (*(unsigned char *)(a1 + 345) == 1)
              {
                float v40 = v53 * 0.01;
                float v53 = v53 * 0.01;
              }
              float v41 = (float)(v7 * v40) + (float)(v21 * v31);
              UNICORN__log_select_Diag(*(void *)(a1 + 56), 11, (uint64_t)"%f = BNF(%f) LF0(%f) DUR(%f)\n");
              UNICORN__mfs_CostList_UpdateCost(*(void *)(a1 + 136), v4, v20++, v41);
              uint64_t v11 = *(void *)(a1 + 136);
              uint64_t v17 = (void *)(v11 + 16);
              unint64_t v12 = *(unsigned int *)(*(void *)(v11 + 16) + 32 * v4 + 16);
              v19 += 12;
              if (v20 >= v12) {
                goto LABEL_69;
              }
            }
          }
LABEL_27:
          uint64_t v15 = 0;
          goto LABEL_28;
        }
      }
      unsigned int v47 = 0;
      if (v3 == 2) {
        goto LABEL_19;
      }
      goto LABEL_21;
    }
  }
  return updated;
}

uint64_t select_bet5_deserializeFeatures(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v10 = 0;
  int v11 = 0;
  unsigned int v12 = 0;
  uint64_t v13 = *a5;
  __src = 0;
  unsigned int v50 = 0;
  uint64_t v14 = v13 + 2748;
  do
  {
    int v15 = *(unsigned __int8 *)(v14 + v10);
    if (*(unsigned char *)(v14 + v10))
    {
      if (v15 == 2)
      {
        v12 += 2;
      }
      else if (v15 == 1)
      {
        ++v12;
        ++v11;
      }
      else if ((unsigned __int16)v10 - 53 <= 1)
      {
        v12 += 4 * *(unsigned __int16 *)(v13 + 3360);
      }
    }
    ++v10;
  }
  while (v10 != 218);
  uint64_t v16 = *(void **)(v13 + 3336);
  if (v16 && *v16)
  {
    uint64_t v17 = 0;
    uint64_t v18 = v16 + 1;
    while (v18[v17++])
      ;
    v12 += v17;
  }
  else
  {
    LODWORD(v17) = 0;
  }
  uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, void **, unsigned int *))(a2 + 88))(a3, a4, &__src, &v50);
  if ((v20 & 0x80000000) != 0) {
    return v20;
  }
  if (!v12) {
    return 21;
  }
  int v21 = v50 / v12;
  if (v50 % v12) {
    return 21;
  }
  *((_WORD *)a5 + 5) = v21;
  uint64_t v49 = a1;
  uint64_t v23 = heap_Calloc(*(void **)(a1 + 8), (unsigned __int16)v21 * v11, 1);
  if (!v23) {
    return 2229280778;
  }
  int v24 = (char *)v23;
  unsigned int v45 = v20;
  uint64_t v46 = a2;
  uint64_t v47 = a3;
  uint64_t v48 = a4;
  uint64_t v25 = 0;
  float v26 = (char *)__src;
  uint64_t v27 = v13 + 2748;
  do
  {
    int v28 = *(unsigned __int8 *)(v27 + v25);
    if (!*(unsigned char *)(v27 + v25)) {
      goto LABEL_36;
    }
    if (v28 == 2)
    {
      uint64_t v30 = *((unsigned __int16 *)a5 + 5);
      float v31 = (void *)heap_Calloc(*(void **)(v49 + 8), v30, 2);
      a5[v25 + 220] = (uint64_t)v31;
      if (!v31) {
        return 2229280778;
      }
      cstdlib_memcpy(v31, v26, 2 * v30);
      v26 += 2 * v30;
    }
    else
    {
      if (v28 == 1)
      {
        size_t v29 = *((unsigned __int16 *)a5 + 5);
        a5[v25 + 2] = (uint64_t)v24;
        cstdlib_memcpy(v24, v26, v29);
        v24 += v29;
      }
      else
      {
        if ((unsigned __int16)v25 - 53 > 1) {
          goto LABEL_36;
        }
        if (v25 == 53) {
          uint64_t v32 = 448;
        }
        else {
          uint64_t v32 = 449;
        }
        int v33 = *(unsigned __int16 *)(v13 + 3360) * *((unsigned __int16 *)a5 + 5);
        float v34 = (void *)heap_Calloc(*(void **)(v49 + 8), *(unsigned __int16 *)(v13 + 3360) * (unint64_t)*((unsigned __int16 *)a5 + 5), 4);
        a5[v32] = (uint64_t)v34;
        if (!v34) {
          return 2229280778;
        }
        size_t v29 = (4 * v33);
        cstdlib_memcpy(v34, v26, v29);
      }
      v26 += v29;
    }
LABEL_36:
    ++v25;
  }
  while (v25 != 218);
  if (!v17) {
    goto LABEL_51;
  }
  uint64_t v35 = heap_Calloc(*(void **)(v49 + 8), v17 * *((unsigned __int16 *)a5 + 5), 1);
  if (!v35) {
    return 2229280778;
  }
  uint64_t v36 = v35;
  uint64_t v37 = heap_Calloc(*(void **)(v49 + 8), v17, 8);
  a5[438] = v37;
  uint64_t v20 = 2229280778;
  if (v37)
  {
    unsigned __int16 v38 = 0;
    do
    {
      size_t v39 = *((unsigned __int16 *)a5 + 5);
      uint64_t v40 = v38;
      *(void *)(a5[438] + 8 * v38) = v36;
      cstdlib_memcpy(*(void **)(a5[438] + 8 * v38), v26, v39);
      if (cstdlib_strncmp(*(const char **)(*(void *)(v13 + 3336) + 8 * v40), "INNO_", 5uLL))
      {
        float v41 = *(const char ***)(*(void *)(v13 + 3344) + 8 * v40);
        size_t v42 = cstdlib_strlen("FEATIDX");
        unsigned int Index = usextract_getIndex(v41, "FEATIDX", (unint64_t)&aFeatidx[v42]);
        if (Index == -1)
        {
          if (cstdlib_strcmp(*(const char **)(*(void *)(*a5 + 3336) + 8 * v40), "POS"))
          {
            if (!cstdlib_strcmp(*(const char **)(*(void *)(*a5 + 3336) + 8 * v40), "PHR")) {
              a5[64] = *(void *)(a5[438] + 8 * v40);
            }
          }
          else
          {
            a5[63] = *(void *)(a5[438] + 8 * v40);
          }
        }
        else
        {
          a5[*(unsigned __int8 *)(*(void *)(*(void *)(*a5 + 3352) + 8 * v40) + Index) + 2] = *(void *)(a5[438] + 8 * v40);
        }
      }
      else
      {
        unsigned int v44 = cstdlib_atoi((unsigned __int8 *)(*(void *)(*(void *)(*a5 + 3336) + 8 * v40) + 5)) + 79;
        if (v44 <= 0x5E) {
          a5[v44 + 2] = *(void *)(a5[438] + 8 * v40);
        }
      }
      v26 += v39;
      v36 += v39;
      unsigned __int16 v38 = v40 + 1;
    }
    while (v17 > (unsigned __int16)(v40 + 1));
LABEL_51:
    (*(void (**)(uint64_t, uint64_t, void))(v46 + 96))(v47, v48, v12 * *((unsigned __int16 *)a5 + 5));
    return v45;
  }
  return v20;
}

void *select_bet5_deserializeFeatures_Free(void *result, void *a2)
{
  uint64_t v2 = *a2;
  if (!*a2) {
    return result;
  }
  uint64_t v4 = result;
  uint64_t v5 = 0;
  int v6 = 0;
  float v7 = a2;
  do
  {
    int v8 = *(unsigned __int8 *)(v2 + 2748 + v5);
    if (v8 == 2)
    {
      uint64_t v9 = v7[220];
      if (!v9) {
        goto LABEL_11;
      }
      uint64_t v10 = &a2[v5 + 220];
LABEL_10:
      uint64_t result = heap_Free((void *)v4[1], v9);
      *uint64_t v10 = 0;
      goto LABEL_11;
    }
    if (v8 != 1) {
      goto LABEL_11;
    }
    if (v6)
    {
      int v6 = 1;
      goto LABEL_11;
    }
    uint64_t v10 = v7 + 2;
    uint64_t v9 = v7[2];
    int v6 = 1;
    if (v9) {
      goto LABEL_10;
    }
LABEL_11:
    ++v5;
    ++v7;
  }
  while (v5 != 218);
  uint64_t v11 = a2[448];
  if (v11)
  {
    uint64_t result = heap_Free((void *)v4[1], v11);
    a2[448] = 0;
  }
  uint64_t v12 = a2[449];
  if (v12)
  {
    uint64_t result = heap_Free((void *)v4[1], v12);
    a2[449] = 0;
  }
  uint64_t v13 = *(void **)(v2 + 3336);
  if (v13)
  {
    if (*v13)
    {
      uint64_t v14 = (uint64_t *)a2[438];
      if (v14)
      {
        if (*v14)
        {
          heap_Free((void *)v4[1], *v14);
          *(void *)a2[438] = 0;
          uint64_t v14 = (uint64_t *)a2[438];
        }
        uint64_t result = heap_Free((void *)v4[1], (uint64_t)v14);
        a2[438] = 0;
      }
    }
  }
  return result;
}

uint64_t precomp_getGranularStep(uint64_t a1)
{
  return *(unsigned int *)(a1 + 1080);
}

uint64_t precomp_Init(uint64_t *a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v4 = 2229280774;
  if (!a2) {
    return v4;
  }
  if (!a3) {
    return v4;
  }
  if (!a4) {
    return v4;
  }
  uint64_t v4 = 2229280778;
  uint64_t v9 = heap_Calloc(*(void **)(*(void *)(a2 + 1072) + 8), 1, 1120);
  *a1 = v9;
  if (!v9) {
    return v4;
  }
  uint64_t v10 = v9;
  int v11 = 100000;
  uint64_t v12 = *(void *)(a2 + 1072);
  *(void *)uint64_t v9 = v12;
  *(void *)(v9 + 8) = a4;
  *(void *)(v9 + 16) = a3;
  *(void *)(v9 + 24) = a2;
  *(void *)(v9 + 32) = a4;
  *(void *)(v9 + 40) = a3;
  *(void *)(v9 + 48) = a4;
  *(void *)(v9 + 56) = a3;
  *(void *)(v9 + 1104) = -1;
  *(void *)(v9 + 64) = *(void *)(a2 + 1776);
  *(_DWORD *)(v9 + 72) = *(_DWORD *)(a2 + 1784);
  *(_DWORD *)(v9 + 1056) = 0;
  *(_DWORD *)(v9 + 1080) = 1;
  *(void *)(v9 + 1048) = 0;
  *(_OWORD *)(v9 + 1016) = 0u;
  *(_OWORD *)(v9 + 1032) = 0u;
  *(_OWORD *)(v9 + 1000) = 0u;
  *(_DWORD *)(v9 + 1076) = a3[2887];
  uint64_t v13 = *(void *)(a2 + 1912);
  if (v13)
  {
    int v14 = a3[1667];
    LODWORD(v13) = v14 < 100000;
    if (v14 >= 100000) {
      int v11 = 100000;
    }
    else {
      int v11 = a3[1667];
    }
  }
  *(_DWORD *)(v9 + 1068) = v13;
  *(_DWORD *)(v9 + 1060) = v11;
  *(_DWORD *)(v9 + 1064) = *(void *)(a4 + 1920) != 0;
  *(_DWORD *)(v9 + 1072) = *(void *)(a4 + 1912) != 0;
  *(_DWORD *)(v9 + 1084) = a3[1681];
  *(_DWORD *)(v9 + 1088) = a3[1679];
  *(_DWORD *)(v9 + 960) = 1;
  unsigned int v15 = *(_DWORD *)(a4 + 1652) | (*(_DWORD *)(a4 + 1652) >> 1);
  unsigned int v16 = v15 | (v15 >> 2) | ((v15 | (v15 >> 2)) >> 4);
  *(_DWORD *)(v9 + 964) = tab32[(130329821 * (v16 | (v16 >> 8) | ((v16 | (v16 >> 8)) >> 16))) >> 27] + 1;
  unsigned int v17 = *(_DWORD *)(a4 + 2436) | (*(_DWORD *)(a4 + 2436) >> 1);
  unsigned int v18 = v17 | (v17 >> 2) | ((v17 | (v17 >> 2)) >> 4);
  *(_DWORD *)(v9 + 968) = tab32[(130329821 * (v18 | (v18 >> 8) | ((v18 | (v18 >> 8)) >> 16))) >> 27] + 1;
  *(_OWORD *)(v9 + 976) = 0uLL;
  uint64_t v19 = *(uint64_t **)(v12 + 8);
  *(void *)(v10 + 992) = v19;
  int v20 = a3[1391];
  *(_DWORD *)(v10 + 988) = v20;
  *(_DWORD *)(v10 + 984) = v20;
  uint64_t v21 = heap_Realloc(v19, 0, (8 * v20));
  *(void *)(v10 + 976) = v21;
  if (!v21) {
    return v4;
  }
  unsigned int v22 = *(_DWORD *)(*(void *)(v10 + 16) + 5564);

  return precomp_AllocPreFetchLeftNodes(v10, v22);
}

uint64_t precomp_AllocPreFetchLeftNodes(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 1056) >= (signed int)a2) {
    return 0;
  }
  uint64_t v4 = 2229280778;
  uint64_t v5 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 1000), 4 * a2);
  *(void *)(a1 + 1000) = v5;
  if (v5)
  {
    uint64_t v6 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 1008), 4 * a2);
    *(void *)(a1 + 1008) = v6;
    if (v6)
    {
      uint64_t v7 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 1016), 4 * a2);
      *(void *)(a1 + 1016) = v7;
      if (v7)
      {
        uint64_t v8 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 1024), 4 * a2);
        *(void *)(a1 + 1024) = v8;
        if (v8)
        {
          uint64_t v9 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 1032), 4 * a2);
          *(void *)(a1 + 1032) = v9;
          if (v9)
          {
            uint64_t v10 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 1040), 4 * a2);
            *(void *)(a1 + 1040) = v10;
            if (v10)
            {
              uint64_t v11 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 1048), 4 * a2);
              *(void *)(a1 + 1048) = v11;
              if (v11)
              {
                uint64_t v4 = 0;
                *(_DWORD *)(a1 + 1056) = a2;
              }
            }
          }
        }
      }
    }
  }
  return v4;
}

uint64_t precomp_Release(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (*a1)
    {
      uint64_t v3 = *(void *)(v2 + 1000);
      if (v3)
      {
        heap_Free(*(void **)(*(void *)v2 + 8), v3);
        *(void *)(v2 + 1000) = 0;
      }
      uint64_t v4 = *(void *)(v2 + 1008);
      if (v4)
      {
        heap_Free(*(void **)(*(void *)v2 + 8), v4);
        *(void *)(v2 + 1008) = 0;
      }
      uint64_t v5 = *(void *)(v2 + 1016);
      if (v5)
      {
        heap_Free(*(void **)(*(void *)v2 + 8), v5);
        *(void *)(v2 + 1016) = 0;
      }
      uint64_t v6 = *(void *)(v2 + 1024);
      if (v6)
      {
        heap_Free(*(void **)(*(void *)v2 + 8), v6);
        *(void *)(v2 + 1024) = 0;
      }
      uint64_t v7 = *(void *)(v2 + 1032);
      if (v7)
      {
        heap_Free(*(void **)(*(void *)v2 + 8), v7);
        *(void *)(v2 + 1032) = 0;
      }
      uint64_t v8 = *(void *)(v2 + 1040);
      if (v8)
      {
        heap_Free(*(void **)(*(void *)v2 + 8), v8);
        *(void *)(v2 + 1040) = 0;
      }
      uint64_t v9 = *(void *)(v2 + 1048);
      if (v9)
      {
        heap_Free(*(void **)(*(void *)v2 + 8), v9);
        *(void *)(v2 + 1048) = 0;
      }
      *(_DWORD *)(v2 + 1056) = 0;
      if (*(_DWORD *)(v2 + 960))
      {
        uint64_t v10 = *(void *)(v2 + 976);
        if (v10)
        {
          heap_Free(*(void **)(v2 + 992), v10);
          *(void *)(v2 + 976) = 0;
          *(_DWORD *)(v2 + 988) = 0;
        }
      }
      heap_Free(*(void **)(*(void *)v2 + 8), *a1);
      *a1 = 0;
    }
  }
  return 0;
}

uint64_t precomp_SetupLeftRightData(uint64_t a1, unsigned int **a2, int a3)
{
  if (a3)
  {
    *(_OWORD *)(a1 + 32) = *(_OWORD *)(a1 + 48);
    *(void *)(a1 + 88) = *(void *)(a1 + 96);
    *(_DWORD *)(a1 + 76) = *(_DWORD *)(a1 + 80);
    *(_DWORD *)(a1 + 1104) = *(_DWORD *)(a1 + 1108);
  }
  uint64_t result = UnicornAddon_UID2AddonId(*(void *)(a1 + 64), *(_DWORD *)(a1 + 72), **a2);
  *(_DWORD *)(a1 + 1108) = result;
  if (result == -1)
  {
    int v8 = 0;
    uint64_t v7 = (uint64_t *)(a1 + 8);
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 64) + 48 * (int)result;
    uint64_t v7 = (uint64_t *)(v6 + 16);
    int v8 = *(_DWORD *)(v6 + 24);
  }
  uint64_t v9 = *v7;
  uint64_t v10 = *(void *)(v9 + 2416);
  uint64_t v11 = *(void *)(v9 + 568);
  *(void *)(a1 + 48) = v9;
  *(void *)(a1 + 56) = v11;
  *(void *)(a1 + 96) = v10;
  *(_DWORD *)(a1 + 80) = v8;
  if (a3)
  {
    int v12 = *(_DWORD *)(a1 + 1104);
    if (v12 == -1)
    {
      if (result != -1)
      {
        uint64_t v13 = (uint64_t *)(*(void *)(a1 + 64) + 48 * (int)result + 40);
        goto LABEL_12;
      }
    }
    else if (result == -1)
    {
      uint64_t v13 = (uint64_t *)(*(void *)(a1 + 64) + 48 * v12 + 32);
LABEL_12:
      uint64_t v14 = *v13;
LABEL_14:
      *(void *)(a1 + 104) = v14;
      return result;
    }
    uint64_t v14 = 0;
    goto LABEL_14;
  }
  return result;
}

uint64_t precomp_SetLayer(uint64_t result, int a2)
{
  int v2 = *(_DWORD *)(result + 1068);
  if (v2) {
    int v2 = *(_DWORD *)(*(void *)(*(void *)(result + 24) + 1912) + 4 * a2);
  }
  *(_DWORD *)(result + 112) = v2;
  uint64_t v3 = *(void *)(result + 32);
  if (v3 == *(void *)(result + 8) && *(void *)(result + 48) == v3)
  {
    *(_DWORD *)(result + 1064) = *(void *)(v3 + 1920) != 0;
    uint64_t v12 = *(void *)(v3 + 1912);
    *(_DWORD *)(result + 1072) = v12 != 0;
    uint64_t v13 = *(void *)(result + 40);
    *(_DWORD *)(result + 1084) = *(_DWORD *)(v13 + 6724);
    *(_DWORD *)(result + 1088) = *(_DWORD *)(v13 + 6716);
    if (v12) {
      return result;
    }
  }
  else
  {
    *(_DWORD *)(result + 1064) = 0;
    *(_DWORD *)(result + 1072) = 0;
    uint64_t v4 = *(void *)(result + 40);
    *(_DWORD *)(result + 1084) = *(_DWORD *)(v4 + 6724);
    *(_DWORD *)(result + 1088) = *(_DWORD *)(v4 + 6716);
  }
  uint64_t v5 = *(void *)(result + 24);
  uint64_t v6 = *(void *)(v5 + 1328);
  uint64_t v7 = *(void *)(v5 + 1336);
  int v8 = *(float **)(v6 + 8 * a2);
  uint64_t v9 = -64;
  do
  {
    uint64_t v10 = (float *)(result + 832 + v9);
    *(v10 - 32) = *(float *)(v7 + 4 * a2) * *v8;
    float v11 = *(float *)(v7 + 4 * a2) * v8[2];
    *(v10 - 16) = v11;
    *uint64_t v10 = *(float *)(v7 + 4 * a2) * v8[1];
    v10[16] = v11 * 1000.0;
    v9 += 4;
  }
  while (v9);
  return result;
}

uint64_t precomp_FetchRightNode(uint64_t result, int a2, int *a3, int *a4, int a5)
{
  if (a5 >= 1)
  {
    uint64_t v5 = *(void *)(result + 32);
    uint64_t v6 = *(float **)(result + 40);
    uint64_t v7 = *(void *)(v5 + 1640);
    int v8 = *(_DWORD *)(v5 + 1652);
    float v9 = v6[1504];
    float v10 = v6[1509];
    float v11 = v6[1514];
    uint64_t v12 = *(void *)(result + 56);
    float v13 = *(float *)(v12 + 6016);
    float v14 = *(float *)(v12 + 6056);
    uint64_t v15 = a5;
    uint64_t v16 = result + 448;
    unsigned int v17 = (void *)(result + 256);
    uint64_t v18 = *(void *)(result + 96);
    do
    {
      int v20 = *a3++;
      int v19 = v20;
      if (v20 == *(_DWORD *)(result + 1076)) {
        int v19 = 0;
      }
      int v21 = *a4++;
      unsigned int v22 = (unsigned __int16 *)(v18 + 24 * v21);
      *(_DWORD *)(v16 + 128) = *((_DWORD *)v22 + 1);
      unsigned int v23 = *v22;
      *(_DWORD *)(v16 - 64) = v23;
      unsigned int v24 = v22[6];
      *(_DWORD *)uint64_t v16 = v24;
      if (*(_DWORD *)(result + 1104) != *(_DWORD *)(result + 1108))
      {
        if (*(_DWORD *)(result + 1084)) {
          uint64_t v25 = 2436;
        }
        else {
          uint64_t v25 = 2432;
        }
        unsigned int v26 = *(_DWORD *)(v5 + v25) - 1;
        float v27 = v13 + (float)((float)v23 / v14);
        if (v27 < v9) {
          float v27 = v9;
        }
        if (v27 > v10) {
          float v27 = v10;
        }
        unsigned int v23 = (float)(v11 * (float)(v27 - v9));
        if (v26 < v23) {
          unsigned int v23 = v26;
        }
        *(_DWORD *)(v16 - 64) = v23;
        uint64_t v28 = *(void *)(result + 104);
        if (v28)
        {
          unsigned int v24 = *(_DWORD *)(v28 + 4 * v24);
          *(_DWORD *)uint64_t v16 = v24;
        }
      }
      if (!*(_DWORD *)(result + 1084))
      {
        *unsigned int v17 = v7 + 4 * v24 * v8;
        *(v17 - 16) = *(void *)(v5 + 2424)
                    + ((unint64_t)(*(_DWORD *)(v5 + 2436) * v23) << (2 * (*(_DWORD *)(result + 1088) == 0)));
      }
      if (*(_DWORD *)(result + 1064)) {
        int v29 = *(_DWORD *)(*(void *)(*(void *)(result + 48) + 1920) + 4 * v19);
      }
      else {
        int v29 = 0;
      }
      *(_DWORD *)(v16 + 64) = v29;
      if (*(_DWORD *)(result + 1072))
      {
        uint64_t v30 = *(void *)(*(void *)(result + 48) + 1912);
        if (v30) {
          float v31 = *(float *)(v30 + 4 * v19);
        }
        else {
          float v31 = 1.0;
        }
        float v32 = (float)((float)(v31 * 0.5) + 0.5) * *(float *)(*(void *)(result + 16) + 5516);
        int v33 = *(float **)(*(void *)(*(void *)(result + 24) + 1328) + 8 * a2);
        *(float *)(v16 + 192) = v32 * *v33;
        float v34 = v32 * v33[2];
        *(float *)(v16 + 256) = v34;
        *(float *)(v16 + 320) = v32 * v33[1];
        *(float *)(v16 + 384) = v34 * 1000.0;
      }
      v16 += 4;
      ++v17;
      --v15;
    }
    while (v15);
  }
  return result;
}

uint64_t precomp_FetchLeftNodes(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v4 = result;
  uint64_t v5 = a3[3];
  if ((int)v5 > *(_DWORD *)(result + 1056)) {
    uint64_t result = precomp_AllocPreFetchLeftNodes(result, a3[3]);
  }
  if ((int)v5 >= 1)
  {
    uint64_t v6 = *(void *)(v4 + 88);
    uint64_t v7 = *(_DWORD **)(v4 + 1000);
    int v8 = *(_DWORD **)(v4 + 1008);
    float v9 = *(_DWORD **)(v4 + 1016);
    float v10 = *(_DWORD **)(v4 + 1024);
    float v11 = *(_DWORD **)(v4 + 1032);
    uint64_t v12 = *(float **)(v4 + 1048);
    float v13 = *(float **)(v4 + 1040);
    float v14 = (int *)(*(void *)a3 + 4);
    do
    {
      int v15 = *(_DWORD *)(v4 + 1076);
      uint64_t result = *(v14 - 1);
      uint64_t v16 = v6 + 24 * *v14;
      *uint64_t v7 = *(unsigned __int16 *)(v16 + 14);
      *int v8 = *(unsigned __int16 *)(v16 + 2);
      *float v9 = *(_DWORD *)(v16 + 8);
      *float v10 = *(_DWORD *)(v16 + 16);
      *float v11 = *(_DWORD *)(v16 + 20);
      *uint64_t v12 = 0.0;
      float *v13 = 0.0;
      if (*(_DWORD *)(v4 + 1064))
      {
        if ((int)result >= v15) {
          uint64_t result = 0;
        }
        else {
          uint64_t result = result;
        }
        uint64_t v17 = *(void *)(v4 + 40);
        float v18 = *(float *)(*(void *)(*(void *)(v4 + 32) + 1920) + 4 * (int)result);
        float *v13 = v18;
        if (v18 <= 0.0) {
          float v19 = 0.0;
        }
        else {
          float v19 = 1.0 / v18;
        }
        *uint64_t v12 = v19 * *(float *)(v17 + 6784);
      }
      v14 += 6;
      ++v13;
      ++v12;
      ++v11;
      ++v10;
      ++v9;
      ++v8;
      ++v7;
      --v5;
    }
    while (v5);
  }
  return result;
}

_DWORD *precomp_SetupJoinCallback(_DWORD *result, int a2)
{
  int v2 = result;
  if (!a2 || result[277] != -1) {
    goto LABEL_3;
  }
  int v4 = result[271];
  if (!v4)
  {
    int v6 = result[266];
    uint64_t v5 = result + 224;
    if (v6)
    {
      uint64_t result = cstdlib_memset(v5, 255, 0x40uLL);
      uint64_t v7 = precomp_DoInnerLoop_simd_full_support;
      goto LABEL_17;
    }
LABEL_12:
    uint64_t result = cstdlib_memset(v5, 0, 0x40uLL);
    if (v2[267])
    {
      if (v2[271])
      {
        *((void *)v2 + 137) = precomp_DoInnerLoop_T_16R_simd_nosylrate;
        int v3 = 16;
        goto LABEL_4;
      }
      uint64_t v7 = precomp_DoInnerLoop_simd_nosylrate;
    }
    else
    {
      uint64_t v7 = precomp_DoInnerLoop_simd_nosylrate_nopitchdeviation;
    }
LABEL_17:
    *((void *)v2 + 137) = v7;
    int v3 = 4;
    goto LABEL_4;
  }
  if (v4 == 1 && result[267] == 1 && !result[266])
  {
    uint64_t v5 = result + 224;
    goto LABEL_12;
  }
LABEL_3:
  *((void *)result + 137) = precomp_DoInnerLoop;
  int v3 = 1;
LABEL_4:
  v2[270] = v3;
  return result;
}

uint64_t precomp_DoInnerLoop(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4, int a5)
{
  uint64_t v7 = *(void *)(a1 + 32);
  float v8 = *(float *)(*(void *)(a1 + 40) + 6720);
  int v9 = *(_DWORD *)(*(void *)(a1 + 16) + 6664);
  int v10 = *(_DWORD *)(a1 + 1060);
  uint64_t v11 = *(void *)(v7 + 1640);
  int v12 = *(_DWORD *)(v7 + 1652);
  uint64_t v13 = *a2;
  int v15 = (int *)(*a2 + 24 * a4);
  int v16 = *v15;
  int v40 = v15[1];
  int v41 = v16;
  precomp_FetchRightNode(a1, a5, &v41, &v40, 1);
  uint64_t v17 = *((unsigned int *)a3 + 3);
  if ((int)v17 < 1)
  {
    uint64_t v19 = 0;
    float v22 = 10000000.0;
  }
  else
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = *a3;
    uint64_t v21 = 4 * v17;
    float v22 = 10000000.0;
    while (1)
    {
      float v23 = *(float *)(v20 + 12);
      if (v23 > v22) {
        break;
      }
      if (*(_DWORD *)v20 != v16 - 1)
      {
        int v24 = *(_DWORD *)(a1 + 384);
        int v25 = v24 - *(_DWORD *)(*(void *)(a1 + 1008) + v18);
        if (v25 >= 0) {
          int v26 = v24 - *(_DWORD *)(*(void *)(a1 + 1008) + v18);
        }
        else {
          int v26 = *(_DWORD *)(*(void *)(a1 + 1008) + v18) - v24;
        }
        float v27 = 0.0;
        if (v26 >= v9)
        {
          int v28 = *(_DWORD *)(a1 + 112) - v25;
          if (v28 < 0) {
            int v28 = -v28;
          }
          if (v28 <= v10)
          {
            int v30 = *(_DWORD *)(a1 + 1084);
            unsigned int v31 = *(_DWORD *)(*(void *)(a1 + 1032) + v18);
            if (*(_DWORD *)(*(void *)(a1 + 40) + 6716))
            {
              float v32 = (void *)(a1 + 128);
              if (v30)
              {
                unsigned int v31 = v24 + *(_DWORD *)(v7 + 2436) * v31;
                float v32 = (void *)(v7 + 2424);
              }
              LOBYTE(v27) = *(unsigned char *)(*v32 + v31);
              float v29 = *(float *)(*(void *)(a1 + 1024) + v18) + (float)((float)LODWORD(v27) * (float)(v8 / 255.0));
            }
            else
            {
              int v33 = (void *)(a1 + 128);
              if (v30)
              {
                unsigned int v31 = v24 + *(_DWORD *)(v7 + 2436) * v31;
                int v33 = (void *)(v7 + 2424);
              }
              float v29 = *(float *)(*v33 + 4 * v31) + *(float *)(*(void *)(a1 + 1024) + v18);
            }
          }
          else
          {
            float v29 = 1000.0;
          }
          float v27 = v29 * *(float *)(a1 + 704);
        }
        float v34 = v23 + v27;
        if (*(void *)(a1 + 32) == *(void *)(a1 + 48) || *(void *)(a1 + 104))
        {
          if (*(_DWORD *)(a1 + 1084))
          {
            unsigned int v35 = *(_DWORD *)(a1 + 448) + *(_DWORD *)(*(void *)(a1 + 1000) + v18) * v12;
            uint64_t v36 = v11;
          }
          else
          {
            uint64_t v36 = *(void *)(a1 + 256);
            unsigned int v35 = *(_DWORD *)(*(void *)(a1 + 1000) + v18);
          }
          float v34 = v34
              + (float)((float)((float)(*(float *)(v36 + 4 * v35) + *(float *)(*(void *)(a1 + 1016) + v18))
                              + *(float *)(a1 + 576))
                      * *(float *)(a1 + 768));
        }
        float v23 = v34 + *(float *)(a1 + 640);
        if (*(_DWORD *)(a1 + 1064)) {
          float v23 = v23
        }
              + (float)(*(float *)(*(void *)(a1 + 1048) + v18)
                      * vabds_f32(*(float *)(a1 + 512), *(float *)(*(void *)(a1 + 1040) + v18)));
      }
      if (v23 < v22 || v19 == 0)
      {
        uint64_t v19 = v20;
        float v22 = v23;
      }
      v18 += 4;
      v20 += 24;
      if (v21 == v18) {
        goto LABEL_39;
      }
    }
    if (!v19)
    {
      uint64_t v19 = v20;
      float v22 = *(float *)(v20 + 12);
    }
  }
LABEL_39:
  uint64_t v38 = v13 + 24 * a4;
  *(float *)(v38 + 12) = v22 + *(float *)(v38 + 12);
  *(void *)(v38 + 16) = v19;
  if (v19) {
    ++*(_DWORD *)(v19 + 8);
  }
  return 0;
}

uint64_t precomp_DoInnerLoop__AssignZeroPathCosts(uint64_t a1, void *a2, uint64_t *a3, int a4)
{
  uint64_t v4 = *((unsigned int *)a3 + 3);
  if ((int)v4 < 1)
  {
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = *a3;
    do
    {
      uint64_t v7 = v6;
      if (v5)
      {
        uint64_t v7 = v5;
        if (*(float *)(v6 + 12) > 0.0) {
          break;
        }
      }
      v6 += 24;
      uint64_t v5 = v7;
      --v4;
    }
    while (v4);
  }
  uint64_t v8 = *a2 + 24 * a4;
  *(float *)(v8 + 12) = *(float *)(v8 + 12) + 0.0;
  *(void *)(v8 + 16) = v5;
  if (v5) {
    ++*(_DWORD *)(v5 + 8);
  }
  return 0;
}

uint64_t precomp_RightLayerOptimize(uint64_t a1, uint64_t a2)
{
  unint64_t v5 = *(unsigned int *)(a1 + 16);
  uint64_t v6 = *(void *)(a2 + 48);
  uint64_t v7 = *(_DWORD **)(a2 + 56);
  *(void *)(a2 + 984) = v5;
  if ((v5 & 0x80000000) != 0) {
    *(_DWORD *)(a2 + 988) = v5;
  }
  uint64_t v8 = 2229280778;
  uint64_t v9 = heap_Realloc(*(uint64_t **)(a2 + 992), *(void *)(a2 + 976), (8 * v5));
  *(void *)(a2 + 976) = v9;
  if (v9)
  {
    uint64_t v10 = v9;
    if ((int)v5 >= 40 && *(_DWORD *)(a2 + 960) != 0)
    {
      uint64_t v16 = 0;
      for (int i = 0; ; ++i)
      {
        unsigned int v18 = *(_DWORD *)(*(void *)a1 + v16) - *(_DWORD *)(a2 + 80);
        if (v7[1691])
        {
          if (v7[1496]) {
            unsigned int v18 = *(_DWORD *)(*(void *)(v6 + 848) + 4 * (v18 / v7[1498]))
          }
                + v7[2891] / *(_DWORD *)v6 * (v18 % *(_DWORD *)v6);
          else {
            unsigned int v18 = *(_DWORD *)(*(void *)(v6 + 848) + 4 * (v18 / v7[1498]));
          }
        }
        int v19 = *(_DWORD *)(a2 + 988);
        if (v19 != 0x7FFFFFFF)
        {
          uint64_t v20 = (_WORD *)(*(void *)(a2 + 96) + 24 * v18);
          int v21 = (unsigned __int16)v20[6];
          int v22 = *(_DWORD *)(a2 + 968);
          LOWORD(v2) = *v20;
          if (v19 >= *(_DWORD *)(a2 + 984))
          {
            *(_DWORD *)(a2 + 984) = v19 + 1;
            uint64_t v10 = heap_Realloc(*(uint64_t **)(a2 + 992), v10, (8 * (v19 + 1)));
            *(void *)(a2 + 976) = v10;
            if (!v10) {
              return 2229280778;
            }
          }
          uint64_t v23 = v10 + 8 * *(int *)(a2 + 988);
          *(float *)uint64_t v23 = (float)v2 + (float)(v21 << (v22 + 1));
          *(_DWORD *)(v23 + 4) = i;
          ++*(_DWORD *)(a2 + 988);
        }
        v16 += 12;
        if (12 * v5 == v16)
        {
          ssft_qsort(v10, v5, 8, (uint64_t (*)(unint64_t, unint64_t))compareDiag);
          return 0;
        }
      }
    }
    if ((int)v5 >= 1)
    {
      for (int j = 0; v5 != j; ++j)
      {
        int v13 = *(_DWORD *)(a2 + 988);
        if (v13 != 0x7FFFFFFF)
        {
          if (v13 >= *(_DWORD *)(a2 + 984))
          {
            int v14 = v13 + 1;
            *(_DWORD *)(a2 + 984) = v14;
            uint64_t v10 = heap_Realloc(*(uint64_t **)(a2 + 992), v10, (8 * v14));
            *(void *)(a2 + 976) = v10;
            if (!v10) {
              return v8;
            }
          }
          int v15 = (_DWORD *)(v10 + 8 * *(int *)(a2 + 988));
          *int v15 = 0;
          v15[1] = j;
          ++*(_DWORD *)(a2 + 988);
        }
      }
    }
    return 0;
  }
  return v8;
}

uint64_t compareDiag(float *a1, float *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a2 < *a1;
  }
}

uint64_t TransWeights_InitCopy(uint64_t a1, int *a2, uint64_t a3, unsigned int a4)
{
  int v7 = *a2;
  if (*a2 >= 0) {
    int v8 = *a2;
  }
  else {
    int v8 = v7 + 1;
  }
  if ((*(_DWORD *)(a1 + 6800) - 7) >= 5) {
    float v9 = 1.0;
  }
  else {
    float v9 = 2.0;
  }
  uint64_t v10 = UNICORN__ffcalloc(*(void **)(*(void *)(a3 + 1072) + 8), a4, 4);
  if (!v10) {
    return 2229280778;
  }
  int v12 = v10;
  v11.i32[0] = 1.0;
  if ((*(_DWORD *)(a1 + 6800) - 7) >= 5) {
    *(float *)v11.i32 = (float)(*(float *)(a1 + 5504) + *(float *)(a1 + 5488)) + *(float *)(a1 + 5492);
  }
  if (*(int *)(a3 + 392) >= 1)
  {
    uint64_t v13 = 0;
    LODWORD(v14) = 0;
    int v15 = 0;
    int v16 = v8 >> 1;
    if (v16 <= 2) {
      int v17 = 2;
    }
    else {
      int v17 = v16;
    }
    int v29 = v17 - 1;
    int v30 = v16;
    float32x4_t v31 = (float32x4_t)vdupq_lane_s32(v11, 0);
    do
    {
      uint64_t v18 = *(void *)(a3 + 384);
      if (v15)
      {
        if (v7 >= 2 && v16 < *a2)
        {
          uint64_t v14 = (int)v14;
          do
          {
            *(float *)v12[v14] = UNICORN__mfs_Ling_TransWeightsDiphADJ(*(void **)(a3 + 8), *v15)
                               * *(float *)(*(void *)(a3 + 1360) + 4 * v14);
            *(float *)(v12[v14] + 4) = UNICORN__mfs_Ling_TransWeightsDiphMCP(*(void **)(a3 + 8), *v15)
                                       * *(float *)(a1 + 5488);
            float v19 = UNICORN__mfs_Ling_TransWeightsDiphLF0(*(void **)(a3 + 8), *v15);
            uint64_t v20 = (float32x4_t *)v12[v14];
            v20->f32[2] = v19 * *(float *)(a1 + 5492);
            v20->i32[3] = 0;
            *uint64_t v20 = vdivq_f32(*v20, v31);
            ++v14;
            ++v16;
          }
          while (v16 < *a2);
          int v16 = v30;
        }
        *(float *)v12[(int)v14] = v9
                                * (float)(UNICORN__mfs_Ling_TransWeightsPhonADJ(*(void **)(a3 + 8), *v15)
                                        * *(float *)(*(void *)(a3 + 1360) + 4 * (int)v14));
        *(float *)(v12[(int)v14] + 4) = v9
                                        * (float)(UNICORN__mfs_Ling_TransWeightsPhonMCP(*(void **)(a3 + 8), *v15)
                                                * *(float *)(a1 + 5488));
        float v21 = UNICORN__mfs_Ling_TransWeightsPhonLF0(*(void **)(a3 + 8), *v15);
        int v22 = (float32x4_t *)v12[(int)v14];
        v22->f32[2] = v9 * (float)(v21 * *(float *)(a1 + 5492));
        v22->i32[3] = 0;
        *int v22 = vdivq_f32(*v22, v31);
        LODWORD(v14) = v14 + 1;
        if (v7 >= 4)
        {
          uint64_t v14 = (int)v14;
          int v23 = v29;
          do
          {
            float v24 = v9
                * (float)(UNICORN__mfs_Ling_TransWeightsDiphADJ(*(void **)(a3 + 8), *v15)
                        * *(float *)(*(void *)(a3 + 1360) + 4 * v14));
            int v25 = (float *)v12[v14];
            *int v25 = v24;
            if ((*(_DWORD *)(a1 + 6800) - 7) <= 4 && v15[6] == *a2) {
              *int v25 = v24 + 1.0;
            }
            *(float *)(v12[v14] + 4) = v9
                                       * (float)(UNICORN__mfs_Ling_TransWeightsDiphMCP(*(void **)(a3 + 8), *v15)
                                               * *(float *)(a1 + 5488));
            float v26 = UNICORN__mfs_Ling_TransWeightsDiphLF0(*(void **)(a3 + 8), *v15);
            float v27 = (float32x4_t *)v12[v14];
            v27->f32[2] = v9 * (float)(v26 * *(float *)(a1 + 5492));
            v27->i32[3] = 0;
            *float v27 = vdivq_f32(*v27, v31);
            ++v14;
            --v23;
          }
          while (v23);
          int v16 = v30;
        }
      }
      else
      {
        LODWORD(v14) = v14 + v16;
      }
      int v15 = (int *)(v18 + 312 * v13++);
    }
    while (v13 < *(int *)(a3 + 392));
  }
  uint64_t result = 0;
  *(void *)(a3 + 1328) = v12;
  return result;
}

uint64_t Install_DynamicBeams_Unicorn(uint64_t a1, unsigned int *a2, uint64_t a3, int a4)
{
  uint64_t v8 = heap_Calloc(*(void **)(*(void *)(a3 + 1072) + 8), 4 * a4, 4);
  *(void *)(a3 + 1336) = v8;
  if (!v8) {
    return 2229280778;
  }
  *(void *)(a3 + 1344) = v8 + 4 * a4;
  *(void *)(a3 + 1352) = v8 + 8 * a4;
  *(void *)(a3 + 1360) = v8 + 12 * a4;
  if (*(int *)(a3 + 392) >= 1)
  {
    uint64_t v9 = 0;
    int v10 = 0;
    do
    {
      uint64_t v11 = *(void *)(a3 + 384);
      float v12 = *(float *)(a1 + 5516);
      float v13 = *(float *)(a1 + 5524);
      float v14 = *(float *)(a1 + 5504);
      switch(UNICORN__mfs_Ling_WrdPosInPhrs(*(void *)(a3 + 8), v9))
      {
        case 1u:
          if (*(float *)(a1 + 5772) != 0.0) {
            float v13 = *(float *)(a1 + 5772);
          }
          if (*(float *)(a1 + 5620) != 0.0) {
            float v12 = *(float *)(a1 + 5620);
          }
          float v15 = *(float *)(a1 + 5852);
          goto LABEL_30;
        case 2u:
          if (*(float *)(a1 + 5780) != 0.0) {
            float v13 = *(float *)(a1 + 5780);
          }
          if (*(float *)(a1 + 5636) != 0.0) {
            float v12 = *(float *)(a1 + 5636);
          }
          float v15 = *(float *)(a1 + 5860);
          goto LABEL_30;
        case 3u:
          if (*(float *)(a1 + 5776) != 0.0) {
            float v13 = *(float *)(a1 + 5776);
          }
          if (*(float *)(a1 + 5628) != 0.0) {
            float v12 = *(float *)(a1 + 5628);
          }
          float v15 = *(float *)(a1 + 5856);
          goto LABEL_30;
        case 4u:
          if (*(float *)(a1 + 5768) != 0.0) {
            float v13 = *(float *)(a1 + 5768);
          }
          if (*(float *)(a1 + 5612) != 0.0) {
            float v12 = *(float *)(a1 + 5612);
          }
          float v15 = *(float *)(a1 + 5848);
          goto LABEL_30;
        case 5u:
          if (*(float *)(a1 + 5764) != 0.0) {
            float v13 = *(float *)(a1 + 5764);
          }
          if (*(float *)(a1 + 5604) != 0.0) {
            float v12 = *(float *)(a1 + 5604);
          }
          float v15 = *(float *)(a1 + 5844);
LABEL_30:
          if (v15 != 0.0) {
            float v14 = v15;
          }
          break;
        default:
          break;
      }
      switch(UNICORN__mfs_Ling_WrdPosShpInPhrs(*(void *)(a3 + 8), v9))
      {
        case 0u:
          if (*(float *)(a1 + 5784) != 0.0) {
            float v13 = *(float *)(a1 + 5784);
          }
          if (*(float *)(a1 + 5652) != 0.0) {
            float v12 = *(float *)(a1 + 5652);
          }
          float v16 = *(float *)(a1 + 5864);
          goto LABEL_62;
        case 1u:
          if (*(float *)(a1 + 5792) != 0.0) {
            float v13 = *(float *)(a1 + 5792);
          }
          if (*(float *)(a1 + 5660) != 0.0) {
            float v12 = *(float *)(a1 + 5660);
          }
          float v16 = *(float *)(a1 + 5872);
          goto LABEL_62;
        case 2u:
          if (*(float *)(a1 + 5788) != 0.0) {
            float v13 = *(float *)(a1 + 5788);
          }
          if (*(float *)(a1 + 5652) != 0.0) {
            float v12 = *(float *)(a1 + 5652);
          }
          float v16 = *(float *)(a1 + 5868);
          goto LABEL_62;
        case 3u:
          if (*(float *)(a1 + 5796) != 0.0) {
            float v13 = *(float *)(a1 + 5796);
          }
          float v17 = *(float *)(a1 + 5668);
          goto LABEL_59;
        case 4u:
          if (*(float *)(a1 + 5804) != 0.0) {
            float v13 = *(float *)(a1 + 5804);
          }
          if (*(float *)(a1 + 5684) != 0.0) {
            float v12 = *(float *)(a1 + 5684);
          }
          float v16 = *(float *)(a1 + 5884);
          goto LABEL_62;
        case 5u:
          if (*(float *)(a1 + 5800) != 0.0) {
            float v13 = *(float *)(a1 + 5800);
          }
          float v17 = *(float *)(a1 + 5676);
LABEL_59:
          if (v17 != 0.0) {
            float v12 = v17;
          }
          float v16 = *(float *)(a1 + 5876);
LABEL_62:
          if (v16 != 0.0) {
            float v14 = v16;
          }
          break;
        default:
          break;
      }
      switch(UNICORN__mfs_Ling_WrdProminence(*(void *)(a3 + 8), v9))
      {
        case 0u:
          if (*(float *)(a1 + 5808) != 0.0) {
            float v13 = *(float *)(a1 + 5808);
          }
          if (*(float *)(a1 + 5692) != 0.0) {
            float v12 = *(float *)(a1 + 5692);
          }
          float v18 = *(float *)(a1 + 5888);
          goto LABEL_85;
        case 1u:
          if (*(float *)(a1 + 5812) != 0.0) {
            float v13 = *(float *)(a1 + 5812);
          }
          if (*(float *)(a1 + 5700) != 0.0) {
            float v12 = *(float *)(a1 + 5700);
          }
          float v18 = *(float *)(a1 + 5892);
          goto LABEL_85;
        case 2u:
          if (*(float *)(a1 + 5816) != 0.0) {
            float v13 = *(float *)(a1 + 5816);
          }
          if (*(float *)(a1 + 5708) != 0.0) {
            float v12 = *(float *)(a1 + 5708);
          }
          float v18 = *(float *)(a1 + 5896);
          goto LABEL_85;
        case 3u:
          if (*(float *)(a1 + 5820) != 0.0) {
            float v13 = *(float *)(a1 + 5820);
          }
          if (*(float *)(a1 + 5716) != 0.0) {
            float v12 = *(float *)(a1 + 5716);
          }
          float v18 = *(float *)(a1 + 5900);
LABEL_85:
          if (v18 != 0.0) {
            float v14 = v18;
          }
          break;
        default:
          break;
      }
      switch(UNICORN__mfs_Ling_WrdShpProminence(*(void *)(a3 + 8), v9))
      {
        case 0u:
          if (*(float *)(a1 + 5824) != 0.0) {
            float v13 = *(float *)(a1 + 5824);
          }
          if (*(float *)(a1 + 5724) != 0.0) {
            float v12 = *(float *)(a1 + 5724);
          }
          float v19 = *(float *)(a1 + 5904);
          goto LABEL_113;
        case 1u:
          if (*(float *)(a1 + 5828) != 0.0) {
            float v13 = *(float *)(a1 + 5828);
          }
          if (*(float *)(a1 + 5732) != 0.0) {
            float v12 = *(float *)(a1 + 5732);
          }
          float v19 = *(float *)(a1 + 5908);
          goto LABEL_113;
        case 2u:
          if (*(float *)(a1 + 5832) != 0.0) {
            float v13 = *(float *)(a1 + 5832);
          }
          if (*(float *)(a1 + 5740) != 0.0) {
            float v12 = *(float *)(a1 + 5740);
          }
          float v19 = *(float *)(a1 + 5912);
          goto LABEL_113;
        case 3u:
          if (*(float *)(a1 + 5836) != 0.0) {
            float v13 = *(float *)(a1 + 5836);
          }
          if (*(float *)(a1 + 5748) != 0.0) {
            float v12 = *(float *)(a1 + 5748);
          }
          float v19 = *(float *)(a1 + 5916);
          goto LABEL_113;
        case 4u:
          if (*(float *)(a1 + 5840) != 0.0) {
            float v13 = *(float *)(a1 + 5840);
          }
          if (*(float *)(a1 + 5756) != 0.0) {
            float v12 = *(float *)(a1 + 5756);
          }
          float v19 = *(float *)(a1 + 5920);
LABEL_113:
          if (v19 != 0.0) {
            float v14 = v19;
          }
          break;
        default:
          break;
      }
      uint64_t v20 = *a2;
      if ((int)v20 >= 1)
      {
        uint64_t v21 = 0;
        uint64_t v22 = 4 * v10;
        uint64_t v23 = *(void *)(a3 + 1360);
        uint64_t v24 = *(void *)(v11 + 312 * v9 + 176) + 2;
        int v25 = v10 - 1;
        uint64_t v26 = *(void *)(a3 + 1344) + v22;
        uint64_t v27 = v23 + v22;
        do
        {
          float v28 = v12;
          float v29 = v13;
          float v30 = v14;
          if ((*(unsigned char *)(v24 + v21) & 4) == 0)
          {
            float v31 = *(float *)(a1 + 5520);
            if (v31 == 0.0) {
              float v32 = 1.0;
            }
            else {
              float v32 = *(float *)(a1 + 5520);
            }
            float v29 = v13 * v32;
            float v28 = v12 * v32;
            if (v31 == 0.0) {
              float v30 = v14;
            }
            else {
              float v30 = v14 * v31;
            }
          }
          if (v29 < 0.0) {
            float v29 = 0.0;
          }
          if (v29 > 1.0) {
            float v29 = 1.0;
          }
          if (v28 < 0.0) {
            float v28 = 0.0;
          }
          if (v28 > 1.0) {
            float v28 = 1.0;
          }
          *(_DWORD *)(v26 + 4 * v21) = *(_DWORD *)(a1 + 5568);
          if (v10 + v21 < 1)
          {
            *(float *)(v27 + 4 * v21) = v30;
            *(float *)(*(void *)(a3 + 1352) + v22 + 4 * v21) = v29;
            uint64_t v33 = *(void *)(a3 + 1336);
          }
          else
          {
            *(float *)(v27 + 4 * v21) = (float)(*(float *)(v23 + 4 * (v25 + v21)) * 0.6)
                                      + (float)(v30 * 0.4);
            *(float *)(*(void *)(a3 + 1352) + v22 + 4 * v21) = (float)(*(float *)(*(void *)(a3 + 1352)
                                                                                  + 4 * (v25 + v21))
                                                                       * 0.6)
                                                               + (float)(v29 * 0.4);
            uint64_t v33 = *(void *)(a3 + 1336);
            float v28 = (float)(*(float *)(v33 + 4 * (v25 + v21)) * 0.6) + (float)(v28 * 0.4);
          }
          uint64_t v34 = v21 + 1;
          *(float *)(v33 + v22 + 4 * v21) = v28;
          uint64_t v21 = v34;
        }
        while (v20 != v34);
        v10 += v34;
      }
      ++v9;
    }
    while (v9 < *(int *)(a3 + 392));
  }
  return 0;
}

uint64_t UNICORN__mfs_S32Vect_Init(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = v2;
  return result;
}

void *UNICORN__mfs_S32Vect_Clear(void *result)
{
  v1 = result;
  uint64_t v2 = result[1];
  if (v2)
  {
    uint64_t result = heap_Free((void *)*result, v2);
    v1[1] = 0;
  }
  v1[2] = 0;
  return result;
}

uint64_t UNICORN__mfs_S32Vect_Reserve(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 && *(_DWORD *)(a1 + 20) >= a2) {
    return 0;
  }
  uint64_t v5 = heap_Realloc(*(uint64_t **)a1, v4, 4 * a2);
  if (!v5) {
    return 2229280778;
  }
  uint64_t v6 = v5;
  uint64_t v7 = *(unsigned int *)(a1 + 16);
  if (a2 > v7) {
    cstdlib_memset((void *)(v5 + 4 * v7), 0, 4 * (a2 - v7));
  }
  uint64_t result = 0;
  *(void *)(a1 + 8) = v6;
  *(_DWORD *)(a1 + 20) = a2;
  return result;
}

uint64_t UNICORN__mfs_S32Vect_Add(uint64_t a1, int a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  if (v4 >= *(_DWORD *)(a1 + 20))
  {
    uint64_t v5 = heap_Realloc(*(uint64_t **)a1, *(void *)(a1 + 8), 4 * (v4 + 1));
    if (!v5) {
      return 2229280778;
    }
    *(void *)(a1 + 8) = v5;
    unsigned int v4 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) = v4 + 1;
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 8);
  }
  uint64_t v6 = 0;
  *(_DWORD *)(v5 + 4 * v4) = a2;
  ++*(_DWORD *)(a1 + 16);
  return v6;
}

uint64_t UNICORN__mfs_S32Vect_Pad(uint64_t a1, int a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  if (v2 >= *(_DWORD *)(a1 + 20)) {
    return 2229280778;
  }
  uint64_t result = 0;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * v2) = a2;
  ++*(_DWORD *)(a1 + 16);
  return result;
}

uint64_t UNICORN__mfs_U32Vect_Init(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = v2;
  return result;
}

void *UNICORN__mfs_U32Vect_Clear(void *result)
{
  v1 = result;
  uint64_t v2 = result[1];
  if (v2)
  {
    uint64_t result = heap_Free((void *)*result, v2);
    v1[1] = 0;
  }
  v1[2] = 0;
  return result;
}

uint64_t UNICORN__mfs_U32Vect_Reserve(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 20) == a2) {
    return 0;
  }
  uint64_t result = 0;
  if (a2 && *(_DWORD *)(a1 + 16) <= a2)
  {
    uint64_t v5 = heap_Realloc(*(uint64_t **)a1, *(void *)(a1 + 8), 4 * a2);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(unsigned int *)(a1 + 16);
      if (a2 > v7) {
        cstdlib_memset((void *)(v5 + 4 * v7), 0, 4 * (a2 - v7));
      }
      uint64_t result = 0;
      *(void *)(a1 + 8) = v6;
      *(_DWORD *)(a1 + 20) = a2;
    }
    else
    {
      return 2229280778;
    }
  }
  return result;
}

uint64_t UNICORN__mfs_U32Vect_Add(uint64_t a1, int a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  if (v4 >= *(_DWORD *)(a1 + 20))
  {
    uint64_t v5 = heap_Realloc(*(uint64_t **)a1, *(void *)(a1 + 8), 4 * (v4 + 1));
    if (!v5) {
      return 2229280778;
    }
    *(void *)(a1 + 8) = v5;
    unsigned int v4 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) = v4 + 1;
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 8);
  }
  uint64_t v6 = 0;
  *(_DWORD *)(v5 + 4 * v4) = a2;
  ++*(_DWORD *)(a1 + 16);
  return v6;
}

uint64_t UNICORN__mfs_F32Vect_Init(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = v2;
  return result;
}

float UNICORN__mfs_F32Vect_Copy(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = v4;
  UNICORN__mfs_F32Vect_Create(a1, *((_DWORD *)a2 + 4));
  unint64_t v6 = *(unsigned int *)(a1 + 16);
  unint64_t v7 = *((unsigned int *)a2 + 4);
  if (v6 < v7)
  {
    unint64_t v8 = *(unsigned int *)(a1 + 20);
    do
    {
      if (v6 < v8)
      {
        float result = *(float *)(a2[1] + 4 * v6);
        *(float *)(*(void *)(a1 + 8) + 4 * v6++) = result;
        *(_DWORD *)(a1 + 16) = v6;
        unint64_t v7 = *((unsigned int *)a2 + 4);
      }
    }
    while (v6 < v7);
  }
  return result;
}

uint64_t UNICORN__mfs_F32Vect_Create(uint64_t a1, unsigned int a2)
{
  *(void *)(a1 + 16) = 0;
  if (!a2) {
    return 0;
  }
  uint64_t v4 = 4 * a2;
  uint64_t v5 = (void *)heap_Alloc(*(void *)a1, v4);
  if (!v5) {
    return 2229280778;
  }
  unint64_t v6 = v5;
  cstdlib_memset(v5, 0, v4);
  uint64_t result = 0;
  *(void *)(a1 + 8) = v6;
  *(_DWORD *)(a1 + 20) = a2;
  return result;
}

uint64_t UNICORN__mfs_F32Vect_Pad(uint64_t a1, float a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  if (v2 >= *(_DWORD *)(a1 + 20)) {
    return 2229280778;
  }
  uint64_t result = 0;
  *(float *)(*(void *)(a1 + 8) + 4 * v2) = a2;
  *(_DWORD *)(a1 + 16) = v2 + 1;
  return result;
}

void *UNICORN__mfs_F32Vect_Clear(void *result)
{
  v1 = result;
  uint64_t v2 = result[1];
  if (v2)
  {
    uint64_t result = heap_Free((void *)*result, v2);
    v1[1] = 0;
  }
  v1[2] = 0;
  return result;
}

uint64_t mfs_F32Vect_Reserve(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 && *(_DWORD *)(a1 + 20) >= a2) {
    return 0;
  }
  uint64_t v5 = heap_Realloc(*(uint64_t **)a1, v4, 4 * a2);
  if (!v5) {
    return 2229280778;
  }
  uint64_t v6 = v5;
  uint64_t v7 = *(unsigned int *)(a1 + 16);
  if (a2 > v7) {
    cstdlib_memset((void *)(v5 + 4 * v7), 0, 4 * (a2 - v7));
  }
  uint64_t result = 0;
  *(void *)(a1 + 8) = v6;
  *(_DWORD *)(a1 + 20) = a2;
  return result;
}

uint64_t UNICORN__mfs_DPLinks_Init(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = v2;
  return result;
}

void *UNICORN__mfs_DPLinks_Clear(void *result)
{
  v1 = result;
  uint64_t v2 = result[1];
  if (v2)
  {
    uint64_t result = heap_Free((void *)*result, v2);
    v1[1] = 0;
  }
  v1[2] = 0;
  return result;
}

uint64_t UNICORN__mfs_DPLinks_Reserve(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 20) == a2) {
    return 0;
  }
  uint64_t result = 0;
  if (a2 && *(_DWORD *)(a1 + 16) <= a2)
  {
    uint64_t v5 = heap_Realloc(*(uint64_t **)a1, *(void *)(a1 + 8), 8 * a2);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(unsigned int *)(a1 + 16);
      if (a2 > v7) {
        cstdlib_memset((void *)(v5 + 8 * v7), 0, 8 * (a2 - v7));
      }
      uint64_t result = 0;
      *(void *)(a1 + 8) = v6;
      *(_DWORD *)(a1 + 20) = a2;
    }
    else
    {
      return 2229280778;
    }
  }
  return result;
}

uint64_t UNICORN__mfs_DPLinks_Add(uint64_t a1, void *a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  if (v4 >= *(_DWORD *)(a1 + 20))
  {
    uint64_t v5 = heap_Realloc(*(uint64_t **)a1, *(void *)(a1 + 8), 8 * (v4 + 1));
    if (!v5) {
      return 2229280778;
    }
    *(void *)(a1 + 8) = v5;
    unsigned int v4 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) = v4 + 1;
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 8);
  }
  uint64_t v6 = 0;
  *(void *)(v5 + 8 * v4) = *a2;
  ++*(_DWORD *)(a1 + 16);
  return v6;
}

uint64_t UNICORN__mfs_InitStream(uint64_t a1, void *__b, _DWORD *a3)
{
  cstdlib_memset(__b, 0, 0x7C0uLL);
  *((void *)__b + 134) = a1;

  return UNICORN__InitVStream(a1, (char *)__b, a3);
}

void *UNICORN__mfs_DeInitStream(void *result)
{
  if (result)
  {
    v1 = result;
    if (result[134])
    {
      UNICORN__mfs_CostList_DeInit(result + 136);
      uint64_t v2 = v1[165];
      if (v2)
      {
        heap_Free(*(void **)(v1[134] + 8), v2);
        v1[165] = 0;
      }
      UNICORN__ff_free(*(void **)(v1[134] + 8), (uint64_t *)v1[166]);
      uint64_t v3 = v1[167];
      if (v3)
      {
        heap_Free(*(void **)(v1[134] + 8), v3);
        v1[167] = 0;
      }
      for (uint64_t i = 208; i != 213; ++i)
      {
        uint64_t v5 = v1[i];
        if (v5)
        {
          heap_Free(*(void **)(v1[134] + 8), v5);
          v1[i] = 0;
        }
      }
      uint64_t v6 = v1[224];
      if (v6)
      {
        heap_Free(*(void **)(v1[134] + 8), v6);
        v1[224] = 0;
      }
      uint64_t v7 = v1[225];
      if (v7)
      {
        heap_Free(*(void **)(v1[134] + 8), v7);
        v1[225] = 0;
      }
      uint64_t v8 = v1[227];
      if (v8)
      {
        heap_Free(*(void **)(v1[134] + 8), v8);
        v1[227] = 0;
      }
      UNICORN__mfs_DPLinks_Clear(v1 + 172);
      UNICORN__mfs_UnitSequence_DeInit((uint64_t)(v1 + 175));
      UNICORN__mfs_SegmentList_DeInit(v1 + 190);
      UNICORN__mfs_SegmentList_DeInit(v1 + 194);
      uint64_t v9 = v1[8];
      if (v9 && *(_DWORD *)(v9 + 244))
      {
        unint64_t v10 = 0;
        do
        {
          if (*(_DWORD *)(v9 + 4 * v10 + 224))
          {
            UNICORN__DeInitMSDUttModel(v1 + 7, v10);
            uint64_t v9 = v1[8];
          }
          ++v10;
        }
        while (v10 < *(unsigned int *)(v9 + 244));
      }
      UNICORN__DeInitVStream(v1);
      for (uint64_t j = 231; j != 243; j += 2)
        VectBlock_Destroy((void **)v1[134], &v1[j]);
      return cstdlib_memset(v1, 0, 0x7C0uLL);
    }
  }
  return result;
}

uint64_t UNICORN__mfs_LoadStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t result = UNICORN__LoadVStream(a1, a2, a3);
  if ((result & 0x80000000) == 0)
  {
    UNICORN__mfs_DPLinks_Init(*(void *)(a1 + 1072), (void *)(a1 + 1376));
    uint64_t result = UNICORN__mfs_UnitSequence_Init(*(void *)(a1 + 1072), (uint64_t *)(a1 + 1400), a2, a4, a5);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = UNICORN__mfs_SegmentList_Init(*(void *)(a1 + 1072), a2, (void *)(a1 + 1520));
      if ((result & 0x80000000) == 0) {
        uint64_t result = UNICORN__mfs_SegmentList_Init(*(void *)(a1 + 1072), a2, (void *)(a1 + 1552));
      }
    }
    *(_DWORD *)(a1 + 1976) = *(_DWORD *)(a3 + 6768);
    *(void *)(a1 + 1776) = a4;
    *(_DWORD *)(a1 + 1784) = a5;
  }
  return result;
}

uint64_t BET5_GenericRules_Rule_Matches(uint64_t a1, unsigned int *a2, int a3, _DWORD *a4)
{
  unsigned int v4 = *(_DWORD *)(a1 + 392);
  *a4 = 1;
  unint64_t v5 = *a2;
  if (v5)
  {
    uint64_t v6 = 0;
    for (uint64_t i = *((void *)a2 + 1) + 5; ; i += 40)
    {
      int v8 = *(char *)(i - 1) + a3;
      if (v8 < 0 || v8 >= v4)
      {
        if ((*(_DWORD *)(i - 5) - 253) >= 2) {
          break;
        }
        unsigned int v10 = 1;
      }
      else
      {
        uint64_t v9 = *(void *)(*(void *)(a1 + 8) + 8 * *(unsigned int *)(i - 5) + 16);
        if (!v9) {
          break;
        }
        unsigned int v10 = *(unsigned __int8 *)(v9 + v8);
      }
      if (((*(unsigned __int8 *)(i + ((unint64_t)v10 >> 3)) >> (v10 & 7)) & 1) == 0) {
        break;
      }
      if (++v6 >= v5) {
        return 0;
      }
    }
    *a4 = 0;
  }
  return 0;
}

uint64_t BET5_GenericRules_ParamActions_AllocMemoryAndInit(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v3 = a2[600];
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *((void *)a2 + 299);
  if (!v4) {
    return 0;
  }
  uint64_t v6 = (void *)(v4 + 40);
  uint64_t v7 = v3 + 1;
  do
  {
    if (!--v7) {
      return 0;
    }
    int v8 = *((_DWORD *)v6 - 2);
    if (v8) {
      int v8 = *v6 != 0;
    }
    v6 += 6;
  }
  while (!v8);
  uint64_t v9 = 2229280778;
  int v10 = *a2;
  int v12 = *(_DWORD *)(a3 + 392);
  uint64_t v52 = *(void *)(a3 + 1072);
  uint64_t v13 = heap_Calloc(*(void **)(v52 + 8), 8, 8);
  *(void *)(a3 + 1368) = v13;
  if (!v13) {
    return v9;
  }
  uint64_t v14 = v13;
  unsigned int v50 = a2;
  unint64_t v15 = a2[600];
  if (!v15)
  {
    unint64_t v15 = 0;
    float v19 = a2;
    goto LABEL_28;
  }
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = (v12 * v10);
  int v54 = 0;
  float v19 = v50;
  while (1)
  {
    uint64_t v20 = *((void *)v50 + 299);
    if (v20)
    {
      uint64_t v21 = v20 + 48 * v16;
      int v23 = *(_DWORD *)(v21 + 32);
      uint64_t v22 = (unsigned int *)(v21 + 32);
      if (v23)
      {
        uint64_t v24 = v20 + 48 * v16;
        uint64_t v26 = *(void *)(v24 + 40);
        int v25 = (void *)(v24 + 40);
        if (v26) {
          break;
        }
      }
    }
LABEL_24:
    if (++v16 >= v15)
    {
      if ((v17 & 0x80000000) != 0) {
        return v17;
      }
LABEL_28:
      int v49 = *v19;
      uint64_t v37 = *(unsigned int *)(a3 + 392);
      int v55 = 0;
      uint64_t v51 = v37;
      if (v37)
      {
        uint64_t v38 = 0;
        do
        {
          if (v15)
          {
            uint64_t v39 = 0;
            uint64_t v40 = *((void *)v19 + 299);
            do
            {
              if (v40)
              {
                uint64_t v41 = *(unsigned int *)(v40 + 48 * v39 + 32);
                if (v41)
                {
                  uint64_t v42 = *(void *)(v40 + 48 * v39 + 40);
                  if (v42)
                  {
                    BET5_GenericRules_Rule_Matches(a3, (unsigned int *)(v40 + 48 * v39), v38, &v55);
                    if (v55)
                    {
                      uint64_t v43 = (_DWORD *)(v42 + 12);
                      do
                      {
                        int v44 = *(v43 - 3);
                        uint64_t v45 = *(void *)(v14 + 8 * *(v43 - 2));
                        if (v44 == 9 || v44 == 7) {
                          *(_DWORD *)(v45 + 4 * (v49 * v38)) = *v43;
                        }
                        if ((v44 & 0xFFFFFFFE) == 8) {
                          *(_DWORD *)(v45 + 4 * (v49 * (v38 + 1) - 1)) = *v43;
                        }
                        v43 += 4;
                        --v41;
                      }
                      while (v41);
                    }
                  }
                }
              }
              ++v39;
            }
            while (v39 != v15);
            float v19 = v50;
            uint64_t v47 = v38 + 1;
          }
          else
          {
            uint64_t v47 = v38 + 1;
          }
          uint64_t v38 = v47;
        }
        while (v47 != v51);
      }
      return 0;
    }
  }
  uint64_t v27 = 0;
  while (1)
  {
    uint64_t v28 = *v25 + 16 * v27;
    int v30 = *(_DWORD *)(v28 + 4);
    float v29 = (unsigned int *)(v28 + 4);
    BET5_Param_GetGlobalValue(a1, v30, &v54);
    uint64_t v17 = v31;
    if ((v31 & 0x80000000) != 0) {
      return v31;
    }
    uint64_t v14 = *(void *)(a3 + 1368);
    uint64_t v32 = *v29;
    if (!*(void *)(v14 + 8 * v32)) {
      break;
    }
LABEL_22:
    if (++v27 >= (unint64_t)*v22)
    {
      unint64_t v15 = v50[600];
      goto LABEL_24;
    }
  }
  if (BET5_Param_GetType(v32) != 1) {
    return 2229280768;
  }
  uint64_t v33 = heap_Calloc(*(void **)(v52 + 8), v18, 4);
  uint64_t v34 = *v29;
  *(void *)(*(void *)(a3 + 1368) + 8 * v34) = v33;
  uint64_t v14 = *(void *)(a3 + 1368);
  unsigned int v35 = *(_DWORD **)(v14 + 8 * v34);
  if (v35)
  {
    if (v18)
    {
      uint64_t v36 = v18;
      do
      {
        *v35++ = v54;
        --v36;
      }
      while (v36);
    }
    goto LABEL_22;
  }
  return 2229280778;
}

void *BET5_GenericRules_ParamActions_FreeMemory(void *result)
{
  if (result[171])
  {
    v1 = result;
    uint64_t v2 = 0;
    uint64_t v3 = result[134];
    do
    {
      uint64_t v4 = *(void *)(v1[171] + v2);
      if (v4) {
        heap_Free(*(void **)(v3 + 8), v4);
      }
      v2 += 8;
    }
    while (v2 != 64);
    unint64_t v5 = *(void **)(v3 + 8);
    uint64_t v6 = v1[171];
    return heap_Free(v5, v6);
  }
  return result;
}

float BET5_GenericRules_Param_GetLocalValue(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, float *a5)
{
  float result = BET5_Param_GetGlobalValue(a1, a3, a5);
  if ((v10 & 0x80000000) == 0)
  {
    uint64_t v11 = *(void *)(a2 + 1368);
    if (v11)
    {
      uint64_t v12 = *(void *)(v11 + 8 * a3);
      if (v12)
      {
        float result = *(float *)(v12 + 4 * a4);
        *a5 = result;
      }
    }
  }
  return result;
}

uint64_t UNICORN__mfs_UnitSequence_Init(uint64_t a1, uint64_t *__b, uint64_t a3, uint64_t a4, int a5)
{
  *long long __b = a1;
  __b[1] = a3;
  UNICORN__mfs_S32Vect_Init(a1, __b + 6);
  UNICORN__mfs_F32Vect_Init(a1, __b + 9);
  UNICORN__mfs_S32Vect_Init(a1, __b + 12);
  __b[2] = a4;
  *((_DWORD *)__b + 6) = a5;
  return 0;
}

void *UNICORN__mfs_UnitSequence_DeInit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    heap_Free(*(void **)(*(void *)a1 + 8), v2);
    *(void *)(a1 + 32) = 0;
  }
  *(_DWORD *)(a1 + 40) = 0;
  UNICORN__mfs_S32Vect_Clear((void *)(a1 + 48));
  UNICORN__mfs_F32Vect_Clear((void *)(a1 + 72));
  float result = UNICORN__mfs_S32Vect_Clear((void *)(a1 + 96));
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return result;
}

uint64_t mfs_UnitSequence_SequencePartial(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  memset(__b, 0, sizeof(__b));
  uint64_t v10 = *(void *)(a2 + 8);
  int v11 = *(_DWORD *)(*(void *)(v10 + 568) + 11548);
  cstdlib_memset(__b, 0, 0x108uLL);
  uint64_t v12 = heap_Realloc(*(uint64_t **)(*(void *)a2 + 8), *(void *)(a2 + 32), 264 * *(unsigned int *)(a2 + 64));
  if (!v12) {
    return 2229280778;
  }
  *(void *)(a2 + 32) = v12;
  *(_DWORD *)(a2 + 40) = 0;
  int v13 = *(_DWORD *)(a2 + 64);
  if (v13 > 0)
  {
    uint64_t v14 = 0;
    unsigned int v15 = 0;
    while (1)
    {
      if (v14 + 1 == v13)
      {
        int v16 = *(_DWORD *)&__b[4];
      }
      else
      {
        int v16 = *(_DWORD *)&__b[4];
        if (*(_DWORD *)(*(void *)(a2 + 56) + 4 * v14 + 4) != *(_DWORD *)(*(void *)(a2 + 56) + 4 * v14) + 1)
        {
          ++*(_DWORD *)&__b[4];
          memcpy((void *)(*(void *)(a2 + 32) + 264 * v15), __b, 0x108uLL);
          unsigned int v15 = *(_DWORD *)(a2 + 40) + 1;
          *(_DWORD *)(a2 + 40) = v15;
          int v17 = *(_DWORD *)&__b[4];
          *(_DWORD *)long long __b = *(_DWORD *)&__b[4];
          int v13 = *(_DWORD *)(a2 + 64);
          goto LABEL_9;
        }
      }
      int v17 = v16 + 1;
      *(_DWORD *)&__b[4] = v17;
LABEL_9:
      if (++v14 >= v13) {
        goto LABEL_13;
      }
    }
  }
  unsigned int v15 = 0;
  int v17 = *(_DWORD *)&__b[4];
LABEL_13:
  if (v17 != *(_DWORD *)__b)
  {
    memcpy((void *)(*(void *)(a2 + 32) + 264 * v15), __b, 0x108uLL);
    ++*(_DWORD *)(a2 + 40);
  }
  if (a4 >= a5) {
    return 0;
  }
  int v19 = a5 - 1;
  uint64_t v20 = 4 * a4;
  do
  {
    unsigned __int16 v26 = 0;
    int v25 = 0;
    int v21 = *(_DWORD *)(*(void *)(a2 + 56) + v20);
    int v22 = *(_DWORD *)(*(void *)(a2 + 104) + v20);
    if (v22 == -1)
    {
      mfs_GetMessageOffsetAndDur_Msecs(v10, *(_DWORD *)(*(void *)(a2 + 56) + v20), &v25, &v26);
    }
    else
    {
      mfs_GetMessageOffsetAndDur_Msecs(*(void *)(*(void *)(a2 + 16) + 48 * v22 + 16), *(_DWORD *)(*(void *)(a2 + 56) + v20), &v25, &v26);
      v21 += *(_DWORD *)(*(void *)(a2 + 16) + 48 * *(int *)(*(void *)(a2 + 104) + v20) + 24);
    }
    if (v21 == v11) {
      int v23 = -1;
    }
    else {
      int v23 = v21;
    }
    uint64_t result = UNICORN__mfs_SegmentList_Add(a3, v23, *(unsigned char *)(a1 + a4 / *(_DWORD *)v10), v25, v26);
    if ((result & 0x80000000) != 0) {
      break;
    }
    v20 += 4;
  }
  while (v19 != a4++);
  return result;
}

void *Allocate_ML_TRAJ_GEN_SPACE(uint64_t a1, size_t __size)
{
  unsigned int v2 = __size;
  *(_DWORD *)a1 = __size;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  uint64_t v4 = __size;
  *(void *)(a1 + 16) = malloc(__size);
  if (v2)
  {
    uint64_t v5 = 0;
    do
      *(unsigned char *)(*(void *)(a1 + 16) + v5++) = 0;
    while (v4 != v5);
  }
  uint64_t v6 = (char *)malloc(32 * v2);
  uint64_t v7 = 0;
  *(void *)(a1 + 8) = v6;
  *(void *)(a1 + 24) = v6;
  do
  {
    uint64_t v8 = a1 + v7;
    *(void *)(v8 + 32) = &v6[4 * v4];
    v6 += 8 * v4;
    *(void *)(v8 + 56) = v6;
    v7 += 8;
  }
  while (v7 != 24);
  *(void *)(a1 + 120) = &v6[4 * v4];

  return Allocate_EQ_SYM5DIAG(a1 + 80, v2);
}

double Deallocate_ML_TRAJ_GEN_SPACE(uint64_t a1)
{
  if (*(_DWORD *)a1)
  {
    free(*(void **)(a1 + 16));
    free(*(void **)(a1 + 8));
    return Deallocate_EQ_SYM5DIAG(a1 + 80);
  }
  return result;
}

uint64_t ML_TRAJ_GEN_SPACE_set_sizes(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v3 = 0;
  unsigned int v4 = a2 - a3;
  if (a2 > a3 && *(_DWORD *)a1 >= a2)
  {
    *(_DWORD *)(a1 + 4) = a2;
    *(_DWORD *)(a1 + 128) = v4;
    *(_DWORD *)(a1 + 80) = v4;
    if (a2 >= 1)
    {
      for (uint64_t i = 0; i != a2; *(unsigned char *)(*(void *)(a1 + 16) + i++) = 0)
        ;
    }
    return 1;
  }
  return v3;
}

float *Gen_ML_Trajectory(float *result, double a2)
{
  unsigned int v2 = result;
  int v3 = *((_DWORD *)result + 1);
  uint64_t v4 = (v3 - 1);
  if (v3 == 1)
  {
    **((_DWORD **)result + 15) = **((_DWORD **)result + 4);
    return result;
  }
  uint64_t v5 = (unsigned char *)*((void *)result + 2);
  if (*v5)
  {
    uint64_t v6 = (float *)*((void *)result + 4);
    *(float *)&a2 = *v6 - **((float **)result + 3);
    *uint64_t v6 = *(float *)&a2;
  }
  if (v3 < 3)
  {
    LODWORD(v4) = 1;
  }
  else
  {
    uint64_t v7 = 0;
    LODWORD(a2) = -0.5;
    do
    {
      if (v5[v7 + 1])
      {
        uint64_t v8 = *((void *)result + 3) + 4 * v7;
        *(float *)(*((void *)result + 4) + 4 * v7 + 4) = *(float *)(*((void *)result + 4) + 4 * v7 + 4)
                                                         - *(float *)(v8 + 4);
        *(float *)(*((void *)result + 6) + 4 * v7 + 4) = *(float *)(*((void *)result + 6) + 4 * v7 + 4)
                                                         + (float)(*(float *)(v8 + 4) * 2.0);
      }
      if (v5[v7])
      {
        uint64_t v9 = *((void *)result + 3);
        uint64_t v10 = *((void *)result + 6);
        *(float *)(*((void *)result + 5) + 4 * v7 + 4) = *(float *)(*((void *)result + 5) + 4 * v7 + 4)
                                                         + (float)(*(float *)(v9 + 4 * v7) * 0.5);
        *(float *)(v10 + 4 * v7 + 4) = *(float *)(v10 + 4 * v7 + 4) - *(float *)(v9 + 4 * v7);
      }
      if (v5[v7 + 2])
      {
        uint64_t v11 = *((void *)result + 3) + 4 * v7;
        uint64_t v12 = *((void *)result + 6);
        *(float *)(*((void *)result + 5) + 4 * v7 + 4) = *(float *)(*((void *)result + 5) + 4 * v7 + 4)
                                                         + (float)(*(float *)(v11 + 8) * -0.5);
        *(float *)(v12 + 4 * v7 + 4) = *(float *)(v12 + 4 * v7 + 4) - *(float *)(v11 + 8);
      }
      ++v7;
    }
    while (v4 - 1 != v7);
  }
  if (v5[v4])
  {
    uint64_t v13 = *((void *)result + 4);
    *(float *)&a2 = *(float *)(v13 + 4 * v4)
                  - *(float *)(*((void *)result + 3) + 4 * v4);
    *(_DWORD *)(v13 + 4 * v4) = LODWORD(a2);
  }
  if (v3 == 3)
  {
    if (*v5)
    {
      unsigned int v16 = 0;
LABEL_39:
      if (!v5[1])
      {
        uint64_t v34 = *((void *)v2 + 7);
        uint64_t v35 = *((void *)v2 + 9);
        uint64_t v36 = *(float **)(*((void *)v2 + 12) + 8 * v16);
        *uint64_t v36 = *(float *)(v34 + 4) + (float)(*(float *)(v35 + 4) * 4.0);
        if (v5[2])
        {
          unsigned int v37 = 1;
        }
        else
        {
          v36[1] = *(float *)(v35 + 4) * -2.0;
          unsigned int v37 = 2;
        }
        bzero(&v36[v37], (v37 * 4) ^ 0xC);
        *(float *)&a2 = (float)((float)(*(float *)(v35 + 4) * -2.0) * *(float *)(*((void *)v2 + 6) + 4))
                      + (float)(*(float *)(v34 + 4) * *(float *)(*((void *)v2 + 4) + 4));
        *(_DWORD *)(*((void *)v2 + 13) + 4 * v16++) = LODWORD(a2);
      }
      if (v5[2]) {
        goto LABEL_86;
      }
      uint64_t v45 = *((void *)v2 + 7);
      uint64_t v44 = *((void *)v2 + 8);
      uint64_t v46 = *((void *)v2 + 9);
      uint64_t v47 = *(void *)(*((void *)v2 + 12) + 8 * v16);
      uint64_t v15 = v16;
      *(float *)uint64_t v47 = (float)(*(float *)(v46 + 4) + (float)(*(float *)(v44 + 4) * 0.25)) + *(float *)(v45 + 8);
      *(_DWORD *)(v47 + 4) = 0;
      *(_DWORD *)(v47 + 8) = 0;
      float v48 = (float)(*(float *)(v46 + 4) * *(float *)(*((void *)v2 + 6) + 4))
          + (float)((float)(*(float *)(v44 + 4) * 0.5) * *(float *)(*((void *)v2 + 5) + 4));
      float v49 = *(float *)(v45 + 8);
      float v50 = *(float *)(*((void *)v2 + 4) + 8);
      goto LABEL_84;
    }
    int v23 = (float *)*((void *)result + 7);
    uint64_t v22 = *((void *)result + 8);
    uint64_t v24 = *((void *)result + 9);
    int v25 = (float *)**((void **)result + 12);
    *int v25 = *(float *)(v24 + 4) + (float)(*v23 + (float)(*(float *)(v22 + 4) * 0.25));
    int v26 = v5[1];
    if (v5[1])
    {
      unsigned int v27 = 0;
    }
    else
    {
      v25[1] = *(float *)(v24 + 4) * -2.0;
      unsigned int v27 = 1;
    }
    if (!v5[2])
    {
      v25[v27 + 1] = *(float *)(v24 + 4) + (float)(*(float *)(v22 + 4) * -0.25);
      if (!v26)
      {
LABEL_38:
        *(float *)&a2 = (float)((float)((float)(*(float *)(v22 + 4) * -0.5) * *(float *)(*((void *)v2 + 5) + 4))
                              + (float)(*v23 * **((float **)v2 + 4)))
                      + (float)(*(float *)(v24 + 4) * *(float *)(*((void *)v2 + 6) + 4));
        **((_DWORD **)v2 + 13) = LODWORD(a2);
        unsigned int v16 = 1;
        goto LABEL_39;
      }
      unsigned int v27 = 1;
    }
    bzero(&v25[v27 + 1], 4 * (v27 ^ 1) + 4);
    goto LABEL_38;
  }
  uint64_t v14 = (v3 - 2);
  if (v3 != 2)
  {
    if (*v5)
    {
      int v17 = 0;
      goto LABEL_48;
    }
    float v29 = (float *)*((void *)result + 7);
    uint64_t v28 = *((void *)result + 8);
    uint64_t v30 = *((void *)result + 9);
    uint64_t v31 = (float *)**((void **)result + 12);
    *uint64_t v31 = *(float *)(v30 + 4) + (float)(*v29 + (float)(*(float *)(v28 + 4) * 0.25));
    int v32 = v5[1];
    if (v5[1])
    {
      unsigned int v33 = 0;
    }
    else
    {
      v31[1] = *(float *)(v30 + 4) * -2.0;
      unsigned int v33 = 1;
    }
    if (!v5[2])
    {
      v31[v33 + 1] = *(float *)(v30 + 4) + (float)(*(float *)(v28 + 4) * -0.25);
      if (!v32)
      {
LABEL_47:
        *(float *)&a2 = (float)((float)((float)(*(float *)(v28 + 4) * -0.5) * *(float *)(*((void *)v2 + 5) + 4))
                              + (float)(*v29 * **((float **)v2 + 4)))
                      + (float)(*(float *)(v30 + 4) * *(float *)(*((void *)v2 + 6) + 4));
        **((_DWORD **)v2 + 13) = LODWORD(a2);
        int v17 = 1;
LABEL_48:
        if (v5[1])
        {
LABEL_61:
          if (v3 >= 5)
          {
            uint64_t v51 = 2;
            while (v5[v51])
            {
              uint64_t v52 = v51 + 1;
LABEL_73:
              uint64_t v51 = v52;
              if (v52 == v14) {
                goto LABEL_76;
              }
            }
            uint64_t v55 = *((void *)v2 + 7);
            uint64_t v54 = *((void *)v2 + 8);
            uint64_t v56 = *((void *)v2 + 9);
            uint64_t v52 = v51 + 1;
            uint64_t v57 = *(float **)(*((void *)v2 + 12) + 8 * v17);
            *uint64_t v57 = *(float *)(v56 + 4 * (v51 + 1))
                 + (float)((float)((float)((float)(*(float *)(v56 + 4 * (v51 - 1))
                                                 + (float)(*(float *)(v54 + 4 * (v51 - 1)) * 0.25))
                                         + *(float *)(v55 + 4 * v51))
                                 + (float)(*(float *)(v56 + 4 * v51) * 4.0))
                         + (float)(*(float *)(v54 + 4 * (v51 + 1)) * 0.25));
            int v58 = v5[v51 + 1];
            if (v5[v51 + 1])
            {
              uint64_t v59 = 0;
            }
            else
            {
              v57[1] = (float)(*(float *)(v56 + 4 * v52) * -2.0) + (float)(*(float *)(v56 + 4 * v51) * -2.0);
              uint64_t v59 = 1;
            }
            if (!v5[(v51 + 2)])
            {
              v57[v59 + 1] = *(float *)(v56 + 4 * v52) + (float)(*(float *)(v54 + 4 * v52) * -0.25);
              if (!v58)
              {
LABEL_72:
                uint64_t v60 = *((void *)v2 + 6);
                uint64_t v53 = v51 - 1;
                *(float *)&a2 = (float)((float)((float)((float)((float)(*(float *)(v56 + 4 * v53)
                                                                      * *(float *)(v60 + 4 * v53))
                                                              + (float)((float)(*(float *)(v54 + 4 * v53) * 0.5)
                                                                      * *(float *)(*((void *)v2 + 5) + 4 * v53)))
                                                      + (float)(*(float *)(v55 + 4 * v51)
                                                              * *(float *)(*((void *)v2 + 4) + 4 * v51)))
                                              + (float)((float)(*(float *)(v56 + 4 * v51) * -2.0)
                                                      * *(float *)(v60 + 4 * v51)))
                                      + (float)((float)(*(float *)(v54 + 4 * v52) * -0.5)
                                              * *(float *)(*((void *)v2 + 5) + 4 * v52)))
                              + (float)(*(float *)(v56 + 4 * v52) * *(float *)(v60 + 4 * v52));
                *(_DWORD *)(*((void *)v2 + 13) + 4 * v17++) = LODWORD(a2);
                goto LABEL_73;
              }
              uint64_t v59 = 1;
            }
            bzero(&v57[v59 + 1], 4 * (v59 ^ 1) + 4);
            goto LABEL_72;
          }
          LODWORD(v14) = 2;
LABEL_76:
          if (v5[v14])
          {
            uint64_t v61 = (v14 + 1);
          }
          else
          {
            uint64_t v62 = (int)v14 - 1;
            uint64_t v63 = *((void *)v2 + 7);
            uint64_t v64 = *((void *)v2 + 8);
            uint64_t v65 = *((void *)v2 + 9);
            uint64_t v66 = *(float **)(*((void *)v2 + 12) + 8 * v17);
            *uint64_t v66 = (float)((float)(*(float *)(v65 + 4 * v62) + (float)(*(float *)(v64 + 4 * v62) * 0.25))
                         + *(float *)(v63 + 4 * v14))
                 + (float)(*(float *)(v65 + 4 * v14) * 4.0);
            uint64_t v61 = v14 + 1;
            if (v5[v61])
            {
              unsigned int v67 = 1;
            }
            else
            {
              v66[1] = *(float *)(v65 + 4 * v14) * -2.0;
              unsigned int v67 = 2;
            }
            bzero(&v66[v67], (v67 * 4) ^ 0xC);
            *(float *)&a2 = (float)((float)((float)(*(float *)(v65 + 4 * v62) * *(float *)(*((void *)v2 + 6) + 4 * v62))
                                          + (float)((float)(*(float *)(v64 + 4 * v62) * 0.5)
                                                  * *(float *)(*((void *)v2 + 5) + 4 * v62)))
                                  + (float)(*(float *)(v63 + 4 * v14)
                                          * *(float *)(*((void *)v2 + 4) + 4 * v14)))
                          + (float)((float)(*(float *)(v65 + 4 * v14) * -2.0)
                                  * *(float *)(*((void *)v2 + 6) + 4 * v14));
            *(_DWORD *)(*((void *)v2 + 13) + 4 * v17++) = LODWORD(a2);
          }
          if (v5[v61]) {
            goto LABEL_86;
          }
          uint64_t v69 = *((void *)v2 + 7);
          uint64_t v68 = *((void *)v2 + 8);
          uint64_t v70 = *((void *)v2 + 9);
          uint64_t v71 = *(void *)(*((void *)v2 + 12) + 8 * v17);
          uint64_t v15 = v17;
          *(float *)uint64_t v71 = (float)(*(float *)(v70 + 4 * v14)
                                + (float)(*(float *)(v68 + 4 * v14) * 0.25))
                        + *(float *)(v69 + 4 * v61);
          *(_DWORD *)(v71 + 4) = 0;
          *(_DWORD *)(v71 + 8) = 0;
          float v48 = (float)(*(float *)(v70 + 4 * v14)
                      * *(float *)(*((void *)v2 + 6) + 4 * v14))
              + (float)((float)(*(float *)(v68 + 4 * v14) * 0.5)
                      * *(float *)(*((void *)v2 + 5) + 4 * v14));
          float v49 = *(float *)(v69 + 4 * v61);
          float v50 = *(float *)(*((void *)v2 + 4) + 4 * v61);
LABEL_84:
          *(float *)&a2 = v48 + (float)(v49 * v50);
          goto LABEL_85;
        }
        uint64_t v39 = *((void *)v2 + 7);
        uint64_t v38 = *((void *)v2 + 8);
        uint64_t v40 = *((void *)v2 + 9);
        uint64_t v41 = *(float **)(*((void *)v2 + 12) + 8 * v17);
        *uint64_t v41 = *(float *)(v40 + 8)
             + (float)((float)(*(float *)(v39 + 4) + (float)(*(float *)(v40 + 4) * 4.0))
                     + (float)(*(float *)(v38 + 8) * 0.25));
        int v42 = v5[2];
        if (v5[2])
        {
          unsigned int v43 = 0;
        }
        else
        {
          v41[1] = (float)(*(float *)(v40 + 8) * -2.0) + (float)(*(float *)(v40 + 4) * -2.0);
          unsigned int v43 = 1;
        }
        if (!v5[3])
        {
          v41[v43 + 1] = *(float *)(v40 + 8) + (float)(*(float *)(v38 + 8) * -0.25);
          if (!v42)
          {
LABEL_60:
            *(float *)&a2 = (float)((float)((float)((float)(*(float *)(v40 + 4) * -2.0)
                                                  * *(float *)(*((void *)v2 + 6) + 4))
                                          + (float)(*(float *)(v39 + 4) * *(float *)(*((void *)v2 + 4) + 4)))
                                  + (float)((float)(*(float *)(v38 + 8) * -0.5) * *(float *)(*((void *)v2 + 5) + 8)))
                          + (float)(*(float *)(v40 + 8) * *(float *)(*((void *)v2 + 6) + 8));
            *(_DWORD *)(*((void *)v2 + 13) + 4 * v17++) = LODWORD(a2);
            goto LABEL_61;
          }
          unsigned int v43 = 1;
        }
        bzero(&v41[v43 + 1], 4 * (v43 ^ 1) + 4);
        goto LABEL_60;
      }
      unsigned int v33 = 1;
    }
    bzero(&v31[v33 + 1], 4 * (v33 ^ 1) + 4);
    goto LABEL_47;
  }
  if (*v5)
  {
    uint64_t v15 = 0;
  }
  else
  {
    uint64_t v18 = (_DWORD *)*((void *)result + 7);
    int v19 = (_DWORD *)**((void **)result + 12);
    *int v19 = *v18;
    v19[1] = 0;
    v19[2] = 0;
    *(float *)&a2 = *(float *)v18 * **((float **)result + 4);
    **((_DWORD **)result + 13) = LODWORD(a2);
    uint64_t v15 = 1;
  }
  if (v5[1]) {
    goto LABEL_86;
  }
  uint64_t v20 = *((void *)result + 7);
  int v21 = *(_DWORD **)(*((void *)result + 12) + 8 * v15);
  *int v21 = *(_DWORD *)(v20 + 4);
  v21[1] = 0;
  v21[2] = 0;
  *(float *)&a2 = *(float *)(v20 + 4) * *(float *)(*((void *)result + 4) + 4);
LABEL_85:
  *(_DWORD *)(*((void *)v2 + 13) + 4 * v15) = LODWORD(a2);
LABEL_86:
  unint64_t v72 = (float *)*((void *)v2 + 15);

  return solve_EQ_SYM5DIAG((unsigned int *)v2 + 20, v72, a2);
}

uint64_t mfs_TCost_Elf0_Manhattan_TreeIndex(float *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, int a8, float a9, float a10)
{
  uint64_t v11 = *a3;
  uint64_t v10 = a3[1];
  uint64_t v12 = a4;
  int v13 = *(_DWORD *)(a3[2] + 32 * a4 + 16);
  uint64_t v83 = 0;
  *(void *)uint64_t v84 = 0;
  int v82 = 0;
  if (!v13) {
    return 0;
  }
  BET5_GenericRules_Param_GetLocalValue((uint64_t)a1, a2, 3u, a4, &v84[1]);
  if ((v22 & 0x80000000) != 0) {
    return v22;
  }
  BET5_GenericRules_Param_GetLocalValue((uint64_t)a1, a2, 4u, a4, (float *)&v83);
  if ((v22 & 0x80000000) != 0) {
    return v22;
  }
  BET5_GenericRules_Param_GetLocalValue((uint64_t)a1, a2, 5u, a4, (float *)&v82);
  if ((v22 & 0x80000000) != 0) {
    return v22;
  }
  BET5_GenericRules_Param_GetLocalValue((uint64_t)a1, a2, 6u, a4, v84);
  if ((v22 & 0x80000000) != 0) {
    return v22;
  }
  BET5_GenericRules_Param_GetLocalValue((uint64_t)a1, a2, 7u, a4, (float *)&v83 + 1);
  uint64_t v24 = v23;
  if ((v23 & 0x80000000) == 0)
  {
    unsigned int v25 = *(_DWORD *)(*(void *)(*(void *)(v10 + 776) + 8 * (int)a7) + 40 * a6 + 4);
    int v26 = *(uint64_t **)(a2 + 1768);
    if (v26 && *((_DWORD *)v26 + 4))
    {
      unsigned int v27 = *((_DWORD *)v26 + 2);
      unsigned int v28 = -1;
      if (v27 > a4 && v25)
      {
        uint64_t v29 = v10 + 8 * (int)a7;
        uint64_t v30 = *(__int16 **)(*(void *)(v29 + 1184) + 8 * a6);
        uint64_t v31 = *(__int16 **)(*(void *)(v29 + 1248) + 8 * a6);
        float v32 = a1[1504];
        uint64_t v33 = *v26;
        float v34 = *(float *)(*v26 + 48 * v12 + 20);
        if (v34 == 0.0
          && (!a4 || *(float *)(v33 + 48 * (a4 - 1) + 20) == 0.0)
          && ((int)a4 + 1 >= v27 || *(float *)(v33 + 48 * (a4 + 1) + 20) == 0.0))
        {
          goto LABEL_37;
        }
        unsigned int v28 = *((_DWORD *)v26 + 6);
        float v35 = 0.0;
        uint64_t v36 = *(unsigned int *)(*(void *)(*(void *)(v10 + 776) + 8 * (int)a7) + 40 * a6 + 4);
        unsigned int v37 = v31;
        uint64_t v38 = v30;
        float v39 = 0.0;
        float v40 = 1.0 / a1[1514];
        do
        {
          int v41 = *v38++;
          float v42 = v32 + (float)((float)v41 * v40);
          int v43 = *v37++;
          float v39 = v39 + v42;
          float v35 = v35 + (float)(v32 + (float)((float)v43 * v40));
          --v36;
        }
        while (v36);
        float v44 = v39 / (float)v25;
        float v45 = 0.0;
        uint64_t v46 = *(unsigned int *)(*(void *)(*(void *)(v10 + 776) + 8 * (int)a7) + 40 * a6 + 4);
        float v47 = 0.0;
        float v48 = v35 / (float)v25;
        do
        {
          int v49 = *v30++;
          float v47 = v47
              + (float)((float)((float)(v32 + (float)((float)v49 * v40)) - v44)
                      * (float)((float)(v32 + (float)((float)v49 * v40)) - v44));
          int v50 = *v31++;
          float v45 = v45
              + (float)((float)((float)(v32 + (float)((float)v50 * v40)) - v48)
                      * (float)((float)(v32 + (float)((float)v50 * v40)) - v48));
          --v46;
        }
        while (v46);
        float v51 = sqrt(v47 / (double)v25);
        double v52 = sqrt(v45 / (double)v25);
        float v53 = v34;
        if (a4)
        {
          float v53 = v34;
          if (v34 == 0.0) {
            float v53 = *(float *)(v33 + 48 * (a4 - 1) + 20);
          }
        }
        float v54 = v52;
        float v55 = a9 + (float)((float)(v51 + v51) * v53);
        if (v53 == 0.0) {
          float v55 = a9;
        }
        if (v34 == 0.0 && (int)a4 + 1 < v27) {
          float v34 = *(float *)(v33 + 48 * (a4 + 1) + 20);
        }
        float v56 = a10 + (float)((float)(v54 + v54) * v34);
        if (v34 == 0.0) {
          float v57 = a10;
        }
        else {
          float v57 = v56;
        }
        a10 = 1.0;
        if (v55 <= 0.0) {
          a9 = 1.0;
        }
        else {
          a9 = v55;
        }
        if (v57 > 0.0) {
          a10 = v57;
        }
      }
LABEL_38:
      int v58 = *(_DWORD *)(*(void *)(*(void *)(v10 + 776) + 8 * (int)a7) + 40 * a6 + 4);
      float v59 = *(float *)(a5 + 108) * *(float *)(*(void *)(a2 + 1352) + 4 * v12);
      if (v28 != -1) {
        float v59 = v59 + (float)(v59 * (float)v28);
      }
      if (a8) {
        float v60 = v59 * 0.01;
      }
      else {
        float v60 = v59;
      }
      uint64_t v61 = *(unsigned int *)(a5 + 104);
      float v62 = 0.0;
      if ((v61 - 256) >= 0xFFFFFF01) {
        float v62 = (float)(a9 - a10) * a1[v61 + 2616];
      }
      if (UNICORN__log_select_GetLogLevel(*(void *)(v11 + 32)) >= 3)
      {
        double v78 = v84[1];
        double v79 = v60;
        double v76 = v60;
        double v77 = (float)(v60 * v84[1]);
        double v74 = (float)(v60 * (float)(1.0 - v84[1]));
        double v75 = (float)(1.0 - v84[1]);
        double v72 = a10;
        double v73 = v62;
        double v70 = a1[2901];
        double v71 = a9;
        double v68 = a1[2897];
        double v69 = a1[2899];
        double v66 = a1[2898];
        double v67 = a1[2900];
        double v65 = a1[2896];
        HIDWORD(v64) = HIDWORD(a4);
        UNICORN__log_select_Diag(v11, 3, (uint64_t)"stateidx %u: dist pitch: SPEECHBASE MEAN left %.3f, right %.3f, slope %.3f; SPEECHBASE STDEV left %.3"
                   "f, right %.3f, slope %.3f; TARGET left %.3f, right %.3f, slope %.3f; WEIGHTS edge %.3f(=%.3f*%.3f), s"
                   "lope %.3f(=%.3f*%.3f)\n");
      }
      if (v58)
      {
        LODWORD(v64) = v82;
        return (*(uint64_t (**)(float *, uint64_t *, uint64_t, void, uint64_t, float, float, float, float, float, float, float, float, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double))(a5 + 152))(a1, a3, a4, a6, a7, a9, a10, v62, v60, v84[1], v84[0], *((float *)&v83 + 1), *(float *)&v83, v64, v65, v66, v67, v68, v69,
                 v70,
                 v71,
                 v72,
                 v73,
                 v74,
                 v75,
                 v76,
                 v77,
                 v78,
                 v79);
      }
      return v24;
    }
LABEL_37:
    unsigned int v28 = -1;
    goto LABEL_38;
  }
  return v24;
}

float helperForPitchOutlierPruning(float a1, float a2, float a3, float a4, float a5, float a6)
{
  float v6 = vabds_f32(a1, a2);
  float v7 = a3 * a4;
  float v8 = v6 * (float)(a5 * a6);
  BOOL v9 = v6 <= v7;
  float result = 0.0;
  if (!v9) {
    return v8;
  }
  return result;
}

uint64_t mfs_TCost_Elf0_Manhattan_Clusterize(float *a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12, float a13, float a14)
{
  uint64_t v17 = *(void *)(a2 + 8);
  int v18 = *(_DWORD *)(*(void *)(*(void *)(v17 + 776) + 8 * a5) + 40 * a4 + 4);
  if (v18)
  {
    uint64_t v19 = 0;
    uint64_t v20 = 8 * a5 - 16;
    uint64_t v21 = v17 + v20;
    uint64_t v22 = *(void *)(*(void *)(v17 + v20 + 1328) + 8 * a4);
    uint64_t v23 = *(void *)(*(void *)(v21 + 1264) + 8 * a4);
    uint64_t v24 = *(void *)(*(void *)(v21 + 1200) + 8 * a4);
    uint64_t v25 = *(void *)(*(void *)(a2 + 16) + 32 * a3);
    uint64_t v26 = *(void *)(a2 + v20 + 112);
    BOOL v27 = a12 != 0.0 || a11 != 0.0;
    BOOL v28 = a12 > 0.0 && a11 > 0.0;
    int v29 = a13 != 0.0 || v27;
    BOOL v30 = a13 > 0.0;
    if (a14 != 0.0) {
      int v29 = 1;
    }
    float v31 = (float)((float)(1.0 - a10) * a9) * a12;
    if (a14 <= 0.0) {
      BOOL v30 = 0;
    }
    do
    {
      if ((*(_DWORD *)(v26 + 4 * (v19 >> 5)) >> v19))
      {
        float v32 = a1[1514];
        float v33 = a1[1504];
        float v34 = (float)((float)*(__int16 *)(v24 + 2 * v19) / v32) + v33;
        float v35 = v33 + (float)((float)*(__int16 *)(v23 + 2 * v19) / v32);
        float v36 = vabds_f32(a6, v34);
        if (v34 >= a6) {
          float v37 = v34;
        }
        else {
          float v37 = a6;
        }
        float v38 = v36 / v37;
        float v39 = vabds_f32(a7, v35);
        if (v35 >= a7) {
          float v40 = v35;
        }
        else {
          float v40 = a7;
        }
        float v41 = v34 - v35;
        float v42 = &a1[*(unsigned __int8 *)(v22 + v19)];
        float v43 = *(float *)(v25 + 4)
            + (float)(a9
                    * (float)((float)(fabsf(a8 - (float)(v41 * v42[2616])) * a10)
                            + (float)((float)(1.0 - a10) * (float)(v38 + (float)(v39 / v40)))));
        *(float *)(v25 + 4) = v43;
        if (v29)
        {
          if (v28)
          {
            if (v36 <= (float)(a1[2897] * a11)) {
              float v44 = 0.0;
            }
            else {
              float v44 = v31 * v36;
            }
            float v45 = v43 + v44;
            if (v39 <= (float)(a1[2899] * a11)) {
              float v46 = 0.0;
            }
            else {
              float v46 = v31 * v39;
            }
            float v43 = v45 + v46;
            *(float *)(v25 + 4) = v43;
          }
          if (v30)
          {
            float v47 = vabds_f32(a8, v41 * v42[2616]);
            if (v47 <= (float)(a1[2901] * a13)) {
              float v48 = 0.0;
            }
            else {
              float v48 = (float)((float)(a9 * a10) * a14) * v47;
            }
            *(float *)(v25 + 4) = v43 + v48;
          }
        }
        v25 += 12;
      }
      ++v19;
    }
    while (v18 != v19);
  }
  return 0;
}

uint64_t mfs_TCost_Elf0_Manhattan_List(uint64_t a1, uint64_t a2, unsigned int a3, float a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, uint64_t a12, int a13, float a14)
{
  uint64_t v18 = *(void *)(a2 + 8);
  uint64_t v17 = *(void *)(a2 + 16);
  int v19 = *(_DWORD *)(a1 + 5984);
  if (v19) {
    int v19 = *(_DWORD *)(*(void *)(v18 + 568) + 11564) / *(_DWORD *)v18 * (a13 - 2);
  }
  uint64_t v20 = *(unsigned int *)(v17 + 32 * a3 + 16);
  if (v20)
  {
    uint64_t v21 = *(void *)(v18 + 1032);
    uint64_t v22 = *(void *)(v17 + 32 * a3);
    uint64_t v23 = *(void *)(v18 + 848);
    unsigned int v24 = *(_DWORD *)(*(void *)(v18 + 568) + 5992);
    uint64_t v25 = *(void *)(v18 + 1016);
    uint64_t v26 = *(void *)(v18 + 1024);
    BOOL v27 = a10 != 0.0 || a9 != 0.0;
    BOOL v28 = a10 > 0.0 && a9 > 0.0;
    int v29 = a11 != 0.0 || v27;
    BOOL v30 = a11 > 0.0;
    if (a14 != 0.0) {
      int v29 = 1;
    }
    float v31 = (float)((float)(1.0 - a8) * a7) * a10;
    if (a14 <= 0.0) {
      BOOL v30 = 0;
    }
    float v32 = (float *)(v22 + 4);
    do
    {
      uint64_t v33 = (*(_DWORD *)(v23 + 4 * (*((_DWORD *)v32 - 1) / v24)) + v19);
      float v34 = *(float *)(a1 + 6056);
      float v35 = *(float *)(a1 + 6016);
      float v36 = (float)((float)*(__int16 *)(v25 + 2 * v33) / v34) + v35;
      float v37 = v35 + (float)((float)*(__int16 *)(v26 + 2 * v33) / v34);
      float v38 = vabds_f32(a4, v36);
      if (v36 >= a4) {
        float v39 = v36;
      }
      else {
        float v39 = a4;
      }
      float v40 = v38 / v39;
      float v41 = vabds_f32(a5, v37);
      if (v37 >= a5) {
        float v42 = v37;
      }
      else {
        float v42 = a5;
      }
      float v43 = v36 - v37;
      float v44 = *v32
          + (float)(a7
                  * (float)((float)(fabsf(a6- (float)(v43* *(float *)(a1 + 4 * *(unsigned __int8 *)(v21 + v33) + 10464)))* a8)+ (float)((float)(1.0 - a8) * (float)(v40 + (float)(v41 / v42)))));
      *float v32 = v44;
      if (v29)
      {
        if (v28)
        {
          if (v38 <= (float)(*(float *)(a1 + 11588) * a9)) {
            float v45 = 0.0;
          }
          else {
            float v45 = v31 * v38;
          }
          float v46 = v44 + v45;
          if (v41 <= (float)(*(float *)(a1 + 11596) * a9)) {
            float v47 = 0.0;
          }
          else {
            float v47 = v31 * v41;
          }
          float v44 = v46 + v47;
          *float v32 = v44;
        }
        if (v30)
        {
          float v48 = vabds_f32(a6, v43 * *(float *)(a1 + 4 * *(unsigned __int8 *)(v21 + v33) + 10464));
          if (v48 <= (float)(*(float *)(a1 + 11604) * a11)) {
            float v49 = 0.0;
          }
          else {
            float v49 = (float)((float)(a7 * a8) * a14) * v48;
          }
          *float v32 = v44 + v49;
        }
      }
      v32 += 3;
      --v20;
    }
    while (v20);
  }
  return 0;
}

float UNICORN__CandidatePhonemeDurationDistanceBasic(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  unsigned int v4 = *(unsigned __int8 *)(*(void *)(a1 + 2456) + a2);
  int v5 = v4 - a4;
  if ((int)(v4 - a4) < 0) {
    int v5 = a4 - v4;
  }
  return (float)v5 / (float)v4;
}

uint64_t UNICORN__CandidatePhonemeDurationDistance(uint64_t a1, unsigned int a2, uint64_t a3, int a4, int a5)
{
  int v5 = *(unsigned __int8 *)(*(void *)(a1 + 2456) + a2);
  int v6 = v5 - a4;
  if (v5 - a4 < 0) {
    int v6 = a4 - v5;
  }
  char v8 = v5 < a4 && v6 > a5;
  unsigned int v9 = v6 << v8;
  if (v6 > 2 * a5) {
    return (5 * v6);
  }
  else {
    return v9;
  }
}

BOOL UNICORN__IsPhonemeDurationOutlier(uint64_t a1, unsigned int a2, float a3, uint64_t a4, int a5, int a6)
{
  int v6 = *(unsigned __int8 *)(*(void *)(a1 + 2456) + a2) - a5;
  if (v6 < 0) {
    int v6 = a5 - *(unsigned __int8 *)(*(void *)(a1 + 2456) + a2);
  }
  return (float)((float)a6 * a3) < (float)v6;
}

float PhonemeDurationOutlierDistance(int a1, int a2, unsigned int a3, float a4, float a5)
{
  unsigned int v5 = a1 - a2;
  if (a1 - a2 < 0) {
    unsigned int v5 = a2 - a1;
  }
  float v6 = (float)v5 * a5;
  BOOL v7 = (float)((float)a3 * a4) < (float)v5;
  float result = 0.0;
  if (v7) {
    return v6;
  }
  return result;
}

float PhonemeDurationOutlierDistance_LegacyOrTuning(int a1, int a2, float a3)
{
  unsigned int v3 = a1 - a2;
  if (a1 - a2 < 0) {
    unsigned int v3 = a2 - a1;
  }
  BOOL v4 = (float)v3 <= a3;
  float result = 9999.9;
  if (v4) {
    return 0.0;
  }
  return result;
}

void UNICORN__UniformStateDuration(float a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v4 = (int)(float)(a1 * 0.5);
  *(_DWORD *)(a3 + 24) = v4;
  if (*a4 >= 1)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = 2;
    do
      *(_DWORD *)(v5 + 4 * v6) = 0;
    while (v6++ <= *a4);
    int v4 = *(_DWORD *)(a3 + 24);
  }
  if (v4)
  {
    uint64_t v8 = *(void *)(a3 + 16);
    int v9 = 2;
    do
    {
      ++*(_DWORD *)(v8 + 4 * v9);
      if (v9 == *a4 + 1) {
        int v9 = 2;
      }
      else {
        ++v9;
      }
      --v4;
    }
    while (v4);
  }
}

void UNICORN__StateDuration(float a1, uint64_t a2, uint64_t a3, int *a4)
{
  *(_DWORD *)(a3 + 24) = 0;
  uint64_t v4 = *a4;
  if ((int)v4 >= 1)
  {
    int v5 = 0;
    uint64_t v6 = (int *)(*(void *)(a3 + 16) + 8);
    do
    {
      int v7 = *v6++;
      v5 += v7;
      --v4;
    }
    while (v4);
    if (v5) {
      float v8 = a1 / (float)v5;
    }
    else {
      float v8 = 0.0;
    }
    uint64_t v9 = *(void *)(a3 + 16);
    uint64_t v10 = 2;
    do
    {
      int v11 = (int)(float)((float)(v8 * (float)*(int *)(v9 + 4 * v10)) + 0.5);
      if (v11 <= 1) {
        int v11 = 1;
      }
      *(_DWORD *)(v9 + 4 * v10) = v11;
      *(_DWORD *)(a3 + 24) += v11;
    }
    while (v10++ <= *a4);
  }
}

void UNICORN__MaxLLStateDuration(uint64_t a1, uint64_t a2, unsigned int *a3, float *a4, float a5)
{
  uint64_t v9 = *a3;
  if ((int)v9 <= 0)
  {
    float v19 = *a4 + a5;
    if (v19 >= (float)(int)v9) {
      float v15 = v19;
    }
    else {
      float v15 = (float)(int)v9;
    }
    float v18 = 0.0;
  }
  else
  {
    uint64_t v10 = (float *)(*(void *)(*(void *)(*((void *)a3 + 12) + 8 * *(int *)(a2 + 36)) + 8 * *(int *)(a2 + 8))
                  + 8);
    float v11 = 0.0;
    uint64_t v12 = *a3;
    float v13 = 0.0;
    do
    {
      float v13 = v13 + *v10;
      float v11 = v11 + v10[v9];
      ++v10;
      --v12;
    }
    while (v12);
    float v14 = *a4 + a5;
    if (v14 >= (float)(int)v9) {
      float v15 = v14;
    }
    else {
      float v15 = (float)(int)v9;
    }
    BOOL v16 = v11 == 0.0;
    float v17 = (float)(v15 - v13) / v11;
    if (v16) {
      float v18 = 0.0;
    }
    else {
      float v18 = v17;
    }
  }
  UNICORN__log_select_Diag(a1, 10, (uint64_t)"SetMaxLLPhonemeDuration %f\n");
  *(_DWORD *)(a2 + 24) = 0;
  if ((int)*a3 < 1)
  {
    float v25 = 0.0;
  }
  else
  {
    uint64_t v20 = 2;
    do
    {
      UNICORN__log_select_Diag(a1, 10, (uint64_t)"state %d before %d");
      uint64_t v21 = *(void *)(*(void *)(*((void *)a3 + 12) + 8 * *(int *)(a2 + 36)) + 8 * *(int *)(a2 + 8));
      int v22 = (int)(float)((float)(*(float *)(v21 + 4 * v20) + (float)(v18 * *(float *)(v21 + 4 * (int)(v20 + *a3))))
                       + 0.5);
      if (v22 <= 1) {
        int v22 = 1;
      }
      *(_DWORD *)(*(void *)(a2 + 16) + 4 * v20) = v22;
      UNICORN__log_select_Diag(a1, 10, (uint64_t)" after %d\n");
      int v23 = *(_DWORD *)(a2 + 24) + *(_DWORD *)(*(void *)(a2 + 16) + 4 * v20);
      *(_DWORD *)(a2 + 24) = v23;
      BOOL v24 = v20++ <= (int)*a3;
    }
    while (v24);
    float v25 = (float)v23;
  }
  float v26 = v15 - v25;
  float v27 = fabs((float)(v15 - v25));
  if (v27 >= 0.99999)
  {
    do
    {
      if (v26 <= 0.0) {
        int v28 = 1;
      }
      else {
        int v28 = -1;
      }
      if (v26 > 0.0) {
        int v29 = 1;
      }
      else {
        int v29 = -1;
      }
      LODWORD(v30) = *a3;
      if ((int)*a3 < 1) {
        break;
      }
      uint64_t v31 = 2;
      float v32 = -1.0e10;
      uint64_t v33 = 0xFFFFFFFFLL;
      do
      {
        uint64_t v34 = *(void *)(*(void *)(*((void *)a3 + 12) + 8 * *(int *)(a2 + 36)) + 8 * *(int *)(a2 + 8));
        float v35 = (float)(*(_DWORD *)(*(void *)(a2 + 16) + 4 * v31) + v29) - *(float *)(v34 + 4 * v31);
        float v36 = UNICORN__bet5_finv(*(float *)(v34 + 4 * ((int)v31 + (int)v30)));
        float v37 = UNICORN__mfsLogLikelihood(v35, v36);
        if (v37 > v32 && *(_DWORD *)(*(void *)(a2 + 16) + 4 * v31) > v28)
        {
          float v38 = v37;
          UNICORN__log_select_Diag(a1, 10, (uint64_t)"state %d LL %f dur %d incr %d t2 %f\n");
          uint64_t v33 = v31;
          float v32 = v38;
        }
        uint64_t v30 = (int)*a3;
        BOOL v24 = v31++ <= v30;
      }
      while (v24);
      if ((int)v33 < 1) {
        break;
      }
      *(_DWORD *)(*(void *)(a2 + 16) + 4 * v33) += v29;
      *(_DWORD *)(a2 + 24) += v29;
      float v26 = v26 - (float)v29;
      float v39 = fabs(v26);
    }
    while (v39 >= 0.99999);
  }
  *a4 = v26;
}

void *mfs_DeInitDataAndParam(void *a1, uint64_t a2, void *a3)
{
  UNICORN__mfs_DeInitData((uint64_t)a1, a2);
  StatValues_FreeMemory(a1, (uint64_t)(a3 + 1446));

  return UNICORN__mfs_DeInitParam((uint64_t)a1, a3);
}

void *UNICORN__mfs_DeInitData(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 2464);
  if (v4) {
    brk_DataClose(*(void *)(a1 + 24), v4);
  }
  uint64_t v5 = 768;
  uint64_t v6 = 1624;
  do
  {
    uint64_t v7 = *(void *)(a2 + v5);
    if (v7)
    {
      *(void *)(a2 + v5) = v7 + 16;
      heap_Free(*(void **)(a1 + 8), v7 + 16);
    }
    UNICORN__mfs_SparseMtx_DeInit((void *)(a2 + v6));
    v5 += 8;
    v6 += 16;
  }
  while (v5 != 808);
  mfs_bnfData_DeInit((void *)a2, a1);
  UNICORN__DeInitVData((void *)a1, (char *)a2);
  uint64_t v8 = *(void *)(a2 + 1944);
  if (v8 && *(void *)(*(void *)(a2 + 568) + 9816)) {
    free_aligned_mem(*(void **)(a1 + 8), v8);
  }
  uint64_t v9 = *(void *)(a2 + 2392);
  if (v9)
  {
    if (*(_DWORD *)(a2 + 2400))
    {
      uint64_t v10 = 0;
      unint64_t v11 = 0;
      do
      {
        uint64_t v12 = (uint64_t *)(*(void *)(a2 + 2392) + v10);
        heap_Free(*(void **)(a1 + 8), v12[1]);
        heap_Free(*(void **)(a1 + 8), v12[3]);
        heap_Free(*(void **)(a1 + 8), v12[5]);
        ++v11;
        v10 += 48;
      }
      while (v11 < *(unsigned int *)(a2 + 2400));
      uint64_t v9 = *(void *)(a2 + 2392);
    }
    heap_Free(*(void **)(a1 + 8), v9);
    *(void *)(a2 + 2392) = 0;
  }
  uint64_t v13 = *(void *)(a2 + 2376);
  if (v13)
  {
    unint64_t v14 = *(unsigned int *)(a2 + 2384);
    if (v14)
    {
      unint64_t v15 = 0;
      uint64_t v16 = 56;
      do
      {
        uint64_t v17 = *(void *)(*(void *)(a2 + 2376) + v16);
        if (v17)
        {
          heap_Free(*(void **)(a1 + 8), v17);
          unint64_t v14 = *(unsigned int *)(a2 + 2384);
        }
        ++v15;
        v16 += 64;
      }
      while (v15 < v14);
      uint64_t v13 = *(void *)(a2 + 2376);
    }
    heap_Free(*(void **)(a1 + 8), v13);
    *(void *)(a2 + 2376) = 0;
  }
  heap_Free(*(void **)(a1 + 8), *(void *)(a2 + 2408));

  return cstdlib_memset((void *)a2, 0, 0x9A8uLL);
}

void *StatValues_FreeMemory(void *a1, uint64_t a2)
{
  StatValues_auxFree(a1, (uint64_t *)(a2 + 56), *(_DWORD *)(a2 + 40));
  StatValues_auxFree(a1, (uint64_t *)(a2 + 64), *(_DWORD *)(a2 + 40));
  StatValues_auxFree(a1, (uint64_t *)(a2 + 72), *(_DWORD *)(a2 + 40));
  StatValues_auxFree(a1, (uint64_t *)(a2 + 80), *(_DWORD *)(a2 + 40));
  uint64_t v4 = (void *)a1[1];
  uint64_t v5 = *(void *)(a2 + 48);

  return heap_Free(v4, v5);
}

uint64_t UNICORN__mfs_InitData(uint64_t a1, void *__b, _DWORD *a3)
{
  cstdlib_memset(__b, 0, 0x9A8uLL);
  uint64_t v6 = (void *)heap_Calloc(*(void **)(a1 + 8), 1, 6416);
  *((void *)__b + 301) = v6;
  if (!v6) {
    return 2229280778;
  }
  cstdlib_memset(v6, 0, 0x1910uLL);

  return UNICORN__InitVData(a1, (char *)__b, a3);
}

uint64_t UNICORN__mfs_LoadData(uint64_t a1, uint64_t a2, int a3, int32x2_t *a4, int32x2_t *a5)
{
  uint64_t VData = UNICORN__LoadVData(a1, (uint64_t)a4, (uint64_t)a5);
  if ((VData & 0x80000000) != 0) {
    return VData;
  }
  a4[31].i32[0] = 1;
  a4[71] = (int32x2_t)a5;
  if (a2)
  {
    if (a3 == 1)
    {
      uint64_t VData = brk_DataOpen(*(void *)(a1 + 24));
      if ((VData & 0x80000000) != 0) {
        return VData;
      }
    }
  }
  a4[72] = a5[852];
  a4[73] = a5[855];
  a4[74] = a5[882];
  if (!a5[1443].i32[1])
  {
    unsigned __int32 v11 = a5[883].u32[0];
    if (v11) {
      a5[1443].i32[1] = (v11 >> 4) - 1;
    }
  }
  a4[307] = a5[1197];
  if (a5[900])
  {
    uint64_t v12 = a5[16].u32[1];
    if ((int)v12 >= 1)
    {
      uint64_t v13 = a5 + 23;
      unint64_t v14 = a5 + 897;
      unint64_t v15 = a4 + 76;
      do
      {
        __int32 v16 = v13->i32[0];
        uint64_t v13 = (int32x2_t *)((char *)v13 + 4);
        if (v16)
        {
          v15[-1] = *v14;
          v15->i32[0] = v14[1].i32[1];
        }
        v14 += 3;
        v15 += 4;
        --v12;
      }
      while (v12);
    }
    a4[95].i32[0] = a5[901].u32[0] / (4 * (unint64_t)a5[26].u32[0]);
  }
  uint64_t v17 = 2229280778;
  int32x2_t v18 = a5[915];
  int32x2_t v19 = a5[918];
  int32x2_t v20 = a5[912];
  uint64_t v21 = heap_Calloc(*(void **)(a1 + 8), a4->u32[0], 8);
  a4[97] = (int32x2_t)v21;
  if (v21)
  {
    a4[97] = (int32x2_t)(v21 - 16);
    uint64_t v22 = heap_Calloc(*(void **)(a1 + 8), a4->u32[0], 8);
    a4[98] = (int32x2_t)v22;
    if (v22)
    {
      a4[98] = (int32x2_t)(v22 - 16);
      uint64_t v23 = heap_Calloc(*(void **)(a1 + 8), a4->u32[0], 8);
      a4[96] = (int32x2_t)v23;
      if (v23)
      {
        a4[96] = (int32x2_t)(v23 - 16);
        uint64_t v24 = a4->u32[0];
        if ((int)v24 >= 1)
        {
          uint64_t v25 = v24 + 2;
          uint64_t v26 = 40 * a4[3].i32[0];
          uint64_t v27 = 2;
          do
          {
            *(int32x2_t *)(*(void *)&a4[97] + 8 * v27) = v18;
            *(void *)(*(void *)&a4[97] + 8 * v27) -= 40;
            *(void *)&v18 += 40 * *(int *)(*(void *)&a4[5] + 4 * v27);
            *(int32x2_t *)(*(void *)&a4[98] + 8 * v27) = v19;
            *(void *)(*(void *)&a4[98] + 8 * v27) -= 40;
            *(void *)&v19 += 40 * *(int *)(*(void *)&a4[6] + 4 * v27);
            *(int32x2_t *)(*(void *)&a4[96] + 8 * v27) = v20;
            *(void *)(*(void *)&a4[96] + 8 * v27++) -= 40;
            *(void *)&v20 += v26;
          }
          while (v25 != v27);
        }
        a4[102] = a5[930];
        a4[103] = a5[933];
        a4[101] = a5[927];
        a4[200] = a5[945];
        a4[201] = a5[1065];
        a4[202] = a5[948];
        int v28 = a4 + 205;
        if (a5[840].i32[1])
        {
          uint64_t VData = mfs_FullMtx_Load(v28, *(char **)&a5[960], 0, 0, 0);
          if ((VData & 0x80000000) != 0) {
            return VData;
          }
          uint64_t VData = mfs_FullMtx_Load(&a4[207], *(char **)&a5[963], 0, 0, 0);
          if ((VData & 0x80000000) != 0) {
            return VData;
          }
        }
        else
        {
          uint64_t VData = UNICORN__mfs_SparseMtx_Load((uint64_t)v28, (uint64_t)&a5[959]);
          if ((VData & 0x80000000) != 0) {
            return VData;
          }
          uint64_t VData = UNICORN__mfs_SparseMtx_Load((uint64_t)&a4[207], (uint64_t)&a5[962]);
          if ((VData & 0x80000000) != 0) {
            return VData;
          }
        }
        if (a5[990])
        {
          uint64_t VData = UNICORN__mfs_FSM_Load((uint64_t)&a4[218], (uint64_t)&a5[989]);
          if ((VData & 0x80000000) != 0) {
            return VData;
          }
        }
        if (a5[993])
        {
          uint64_t VData = UNICORN__mfs_FSM_Load((uint64_t)&a4[223], (uint64_t)&a5[992]);
          if ((VData & 0x80000000) != 0) {
            return VData;
          }
        }
        a4[238] = a5[1017];
        a4[239] = a5[1032];
        a4[240] = a5[1047];
        uint64_t VData = mfs_bnfData_Init(a5, a4, a1);
        if ((VData & 0x80000000) != 0) {
          return VData;
        }
        a4[302] = a5[1077];
        uint64_t VData = mfs_FullMtx_Load(&a4[303], *(char **)&a5[1098], a5[839].i32[1], &a5[840], 0);
        if ((VData & 0x80000000) != 0) {
          return VData;
        }
        uint64_t v34 = (char *)a5[1215];
        if (v34)
        {
          if (a5[836].i32[1])
          {
            uint64_t VData = mfs_FullMtx_Load(&a4[305], v34, 0, 0, 0);
            if ((VData & 0x80000000) != 0) {
              return VData;
            }
          }
        }
        uint64_t VData = InitializeSymbolicDataLayout(a1, (uint64_t)a4, (uint64_t)a5, v29, v30, v31, v32, v33);
        if ((VData & 0x80000000) != 0) {
          return VData;
        }
        uint64_t VData = InitializeFuzzyTables(a1, (uint64_t)a4, (uint64_t)a5, v35, v36, v37, v38, v39);
        if ((VData & 0x80000000) != 0) {
          return VData;
        }
        uint64_t VData = InitializeGenericContextRules(a1, (uint64_t)a4, (uint64_t)a5, v40, v41, v42, v43, v44);
        if ((VData & 0x80000000) != 0) {
          return VData;
        }
        StatValues_ComputeDurStatFromData((uint64_t)a4, (uint64_t)a5);
        if (!*(void *)&a5[1227])
        {
          int32x2_t v47 = a5[1002];
          if (v47) {
            a4[243] = v47;
          }
          goto LABEL_46;
        }
        float v45 = (void *)alloc_aligned_32_mem(*(void *)(a1 + 8), a5[1228].u32[0]);
        a4[243] = (int32x2_t)v45;
        if (v45)
        {
          cstdlib_memcpy(v45, *(const void **)&a5[1227], a5[1228].u32[0]);
LABEL_46:
          UNICORN__log_select_Diag(a1, 1, (uint64_t)"Loaded %d states from %d threshold at %d\n");
          return 0;
        }
      }
    }
  }
  return v17;
}

uint64_t InitializeSymbolicDataLayout(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a3 + 9936);
  if (!v8)
  {
    uint64_t v8 = *(void *)(a3 + 10056);
    if (!v8)
    {
      cstdlib_memset((void *)(a2 + 1952), 0, 0x1A8uLL);
      return 0;
    }
  }
  if (*(_DWORD *)(v8 + 16) >= 0x65u)
  {
    uint64_t v9 = 2229280769;
    uint64_t v10 = "Current engine does not support version %d of the layout of symbolic data (max support %d).";
LABEL_7:
    UNICORN__log_select_Error(a1, 0, (uint64_t)v10, a4, a5, a6, a7, a8);
    return v9;
  }
  uint64_t v11 = *(unsigned __int8 *)(v8 + 20);
  *(_DWORD *)(a2 + 1952) = v11;
  if (v11 >= 0x65)
  {
    uint64_t v9 = 2229280769;
    uint64_t v10 = "Too many symbolic features (%d) !";
    goto LABEL_7;
  }
  if (v11)
  {
    uint64_t v12 = 0;
    uint64_t v13 = 4 * v11;
    do
    {
      *(_DWORD *)(a2 + 1956 + v12) = *(unsigned __int8 *)(v8 + 24 + v12);
      v12 += 4;
    }
    while (v13 != v12);
    unsigned int v14 = v12 + 24;
  }
  else
  {
    unsigned int v14 = 24;
  }
  uint64_t v9 = 0;
  *(_DWORD *)(a2 + 2368) = v14;
  *(void *)(a2 + 2360) = v8 + v14;
  return v9;
}

uint64_t InitializeFuzzyTables(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(void *)(a3 + 10176);
  unsigned int v52 = 0;
  BOOL v12 = *(float *)(a3 + 6620) != 0.0 || *(float *)(a3 + 6624) != 0.0 || *(float *)(a3 + 6628) != 0.0;
  int __dst = 0;
  *(void *)(a2 + 2376) = 0;
  *(_DWORD *)(a2 + 2384) = 0;
  if (!v11)
  {
    unsigned int v14 = 0;
    unsigned int v15 = 0;
    if (!v12) {
      goto LABEL_10;
    }
    goto LABEL_8;
  }
  if (*(_DWORD *)v11 < 0x65u)
  {
    unsigned int v15 = *(unsigned __int8 *)(v11 + 4);
    *(_DWORD *)(a2 + 2384) = v15;
    unsigned int v14 = (const char *)(v11 + 8);
    if (!v12)
    {
LABEL_10:
      unsigned int v16 = v15;
      if (!v15) {
        return 0;
      }
      goto LABEL_11;
    }
LABEL_8:
    unsigned int v16 = v15 + 1;
    *(_DWORD *)(a2 + 2384) = v15 + 1;
LABEL_11:
    uint64_t v13 = 2229280768;
    uint64_t v17 = heap_Calloc(*(void **)(a1 + 8), v16, 64);
    *(void *)(a2 + 2376) = v17;
    if (!v17) {
      return 2229280778;
    }
    if (v14 && v15)
    {
      uint64_t v23 = 0;
      do
      {
        *(void *)(*(void *)(a2 + 2376) + v23) = v14;
        uint64_t v24 = &v14[cstdlib_strlen(v14) + 1];
        *(void *)(*(void *)(a2 + 2376) + v23 + 8) = v24;
        uint64_t v25 = &v24[cstdlib_strlen(v24)];
        cstdlib_memcpy(&__dst, v25 + 1, 4uLL);
        *(_DWORD *)(*(void *)(a2 + 2376) + v23 + 16) = __dst;
        cstdlib_memcpy(&__dst, v25 + 5, 4uLL);
        uint64_t v26 = *(void *)(a2 + 2376) + v23;
        *(_DWORD *)(v26 + 20) = __dst != 0;
        uint64_t v27 = (char *)(v25 + 9);
        uint64_t v28 = mfs_FullMtx_Load((void *)(v26 + 24), v27, 0, 0, (int *)&v52);
        if ((v28 & 0x80000000) != 0) {
          return v28;
        }
        unsigned int v14 = &v27[v52];
        v23 += 64;
      }
      while ((unint64_t)v15 << 6 != v23);
    }
    if (v12)
    {
      uint64_t v28 = AddFuzzyTableFromInternalTagSoftScoring(a1, a2, a3, v15);
      if ((v28 & 0x80000000) != 0) {
        return v28;
      }
    }
    uint64_t v29 = *(unsigned int *)(a2 + 2384);
    if (v29)
    {
      uint64_t v30 = 0;
      uint64_t v31 = *(unsigned int *)(a2 + 1952);
      do
      {
        if (v31)
        {
          uint64_t v32 = 0;
          uint64_t v33 = *(void *)(a2 + 2376);
          while (*(_DWORD *)(v33 + (v30 << 6) + 16) != *(_DWORD *)(a2 + 1956 + 4 * v32))
          {
            if (v31 == ++v32) {
              goto LABEL_29;
            }
          }
          uint64_t v34 = v33 + (v30 << 6);
          *(void *)(v34 + 40) = *(void *)(a2 + 2360);
          *(unsigned char *)(v34 + 48) = v31;
          *(unsigned char *)(v34 + 49) = v32;
        }
        else
        {
          LODWORD(v32) = 0;
        }
        if (v32 == v31)
        {
LABEL_29:
          uint64_t v35 = *(void *)(a2 + 2376) + (v30 << 6);
          if (*(_DWORD *)(v35 + 16) == 29)
          {
            *(void *)(v35 + 40) = *(void *)(a2 + 1048);
            *(_WORD *)(v35 + 48) = 1;
          }
        }
        ++v30;
      }
      while (v30 != v29);
      uint64_t v36 = *(void *)(a2 + 2376);
      uint64_t v37 = v29;
      uint64_t v38 = v36;
      do
      {
        if (!*(void *)(v38 + 40))
        {
          float v49 = "\n"
                "\n"
                "Fuzzy table %s:\n"
                "Corresponding symbolic feature %s is not available in the data.\n"
                "Please check S_FILENAME_CLUST_SYM_FEAT.\n"
                "You might also need to regenerate the symbolic data.";
LABEL_61:
          UNICORN__log_select_Error(a1, 0, (uint64_t)v49, v18, v19, v20, v21, v22);
          return v13;
        }
        v38 += 64;
        --v37;
      }
      while (v37);
      uint64_t v39 = 0;
      while (2)
      {
        int v40 = 0;
        uint64_t v41 = v29;
        uint64_t v42 = (_DWORD *)(v36 + 20);
        do
        {
          if (*(_DWORD *)(v36 + (v39 << 6) + 16) == *(v42 - 1) && *v42)
          {
            if (v40)
            {
              float v49 = "\n"
                    "\n"
                    "Following fuzzy tables are set as default fuzzy tables for feature %s:\n"
                    "%s\n"
                    "%s\n"
                    "There should be maximum one default fuzzy table per feature.";
              goto LABEL_61;
            }
            int v40 = 1;
          }
          v42 += 16;
          --v41;
        }
        while (v41);
        if (++v39 != v29) {
          continue;
        }
        break;
      }
      unint64_t v43 = *(unsigned int *)(a2 + 1952);
      if (v43)
      {
        for (unint64_t i = 0; i < v43; ++i)
        {
          uint64_t v45 = *(unsigned int *)(a2 + 2384);
          if (v45)
          {
            uint64_t v46 = 0;
            int32x2_t v47 = (int *)(*(void *)(a2 + 2376) + 16);
            while (1)
            {
              int v48 = *v47;
              v47 += 16;
              if (*(_DWORD *)(a2 + 4 * i + 1956) == v48) {
                break;
              }
              if (v45 == ++v46) {
                goto LABEL_52;
              }
            }
          }
          else
          {
            LODWORD(v46) = 0;
          }
          if (v46 == v45)
          {
LABEL_52:
            UNICORN__log_select_Diag(a1, 0, (uint64_t)"\n\nSystem contains data which is not used:\nsymbolic feature %d.  Please consider removing.\n\n");
            unint64_t v43 = *(unsigned int *)(a2 + 1952);
          }
          uint64_t v13 = 0;
        }
        return v13;
      }
    }
    return 0;
  }
  UNICORN__log_select_Error(a1, 0, (uint64_t)"Current engine does not support version %d of fuzzy tables (max support %d).", a4, a5, a6, a7, a8);
  return 2229280769;
}

uint64_t InitializeGenericContextRules(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a3 + 10296);
  *(void *)(a2 + 2392) = 0;
  *(_DWORD *)(a2 + 2400) = 0;
  if (!v8) {
    return 0;
  }
  uint64_t v9 = a1;
  unsigned int v10 = *(_DWORD *)v8;
  if (*(_DWORD *)v8 >= 0x6Fu)
  {
    uint64_t v11 = "Current engine does not support version %d of context rules (max support %d).";
    uint64_t v12 = 0;
LABEL_4:
    UNICORN__log_select_Error(a1, v12, (uint64_t)v11, a4, a5, a6, a7, a8);
    return 2229280769;
  }
  uint64_t v15 = *(unsigned __int8 *)(v8 + 4);
  *(_DWORD *)(a2 + 2400) = v15;
  if (!v15) {
    return 0;
  }
  uint64_t v16 = heap_Calloc(*(void **)(a1 + 8), v15, 48);
  *(void *)(a2 + 2392) = v16;
  if (!v16) {
    return 2229280778;
  }
  if (!*(_DWORD *)(a2 + 2400)) {
    return 0;
  }
  uint64_t v17 = 0;
  uint64_t v18 = (unsigned int *)(v8 + 8);
  uint64_t v52 = v9;
  while (1)
  {
    uint64_t v19 = *(void *)(a2 + 2392);
    uint64_t v20 = (unsigned int *)(v19 + 48 * v17);
    unsigned int v23 = *v18;
    uint64_t v22 = v18 + 1;
    uint64_t v21 = v23;
    *uint64_t v20 = v23;
    if (v23)
    {
      uint64_t v24 = heap_Calloc(*(void **)(v9 + 8), v21, 40);
      uint64_t v25 = v19 + 48 * v17;
      *(void *)(v25 + 8) = v24;
      uint64_t v26 = (uint64_t *)(v25 + 8);
      if (!v24) {
        return 2229280778;
      }
      if (*v20) {
        break;
      }
    }
LABEL_16:
    unsigned int v33 = *v22;
    uint64_t v18 = v22 + 1;
    uint64_t v32 = v33;
    uint64_t v34 = v19 + 48 * v17;
    *(_DWORD *)(v34 + 16) = v33;
    uint64_t v35 = (unsigned int *)(v34 + 16);
    if (v33)
    {
      uint64_t v36 = heap_Calloc(*(void **)(v9 + 8), v32, 12);
      *(void *)(v19 + 48 * v17 + 24) = v36;
      if (!v36) {
        return 2229280778;
      }
      uint64_t v37 = *v35;
      if (v37)
      {
        uint64_t v38 = (unsigned int *)(v36 + 8);
        do
        {
          *((void *)v38 - 1) = *(void *)v18;
          unsigned int v39 = v18[2];
          v18 += 3;
          *uint64_t v38 = v39;
          v38 += 3;
          --v37;
        }
        while (v37);
      }
    }
    if (v10 >= 0x6E)
    {
      unsigned int v41 = *v18++;
      uint64_t v40 = v41;
      uint64_t v42 = v19 + 48 * v17;
      *(_DWORD *)(v42 + 32) = v41;
      unint64_t v43 = (_DWORD *)(v42 + 32);
      if (v41)
      {
        uint64_t v44 = heap_Calloc(*(void **)(v9 + 8), v40, 16);
        uint64_t v45 = v19 + 48 * v17;
        *(void *)(v45 + 40) = v44;
        uint64_t v46 = (uint64_t *)(v45 + 40);
        if (!v44) {
          return 2229280778;
        }
        if (*v43)
        {
          uint64_t v47 = 0;
          unint64_t v48 = 0;
          while (1)
          {
            uint64_t v49 = *v46;
            uint64_t v50 = *v46 + v47 * 4;
            *(_DWORD *)uint64_t v50 = v18[v47];
            uint64_t v51 = *(void *)&v18[v47 + 1];
            *(void *)(v50 + 4) = v51;
            if (v51 > 7 || BET5_Param_GetType(v51) != 1) {
              break;
            }
            *(_DWORD *)(v49 + v47 * 4 + 12) = v18[v47 + 3];
            ++v48;
            v47 += 4;
            if (v48 >= *v43)
            {
              uint64_t v18 = (unsigned int *)((char *)v18 + v47 * 4);
              uint64_t v9 = v52;
              goto LABEL_30;
            }
          }
          uint64_t v11 = "Generic context rule param action %d not supported\n";
          a1 = v52;
          uint64_t v12 = 55010;
          goto LABEL_4;
        }
      }
    }
LABEL_30:
    uint64_t result = 0;
    if (++v17 >= (unint64_t)*(unsigned int *)(a2 + 2400)) {
      return result;
    }
  }
  uint64_t v27 = 0;
  unint64_t v28 = 0;
  while (1)
  {
    uint64_t v29 = *v26;
    unsigned int v30 = v22[v27 + 1];
    *(_DWORD *)(*v26 + v27 * 4) = v22[v27];
    if (v30 != (char)v30) {
      return 2229280768;
    }
    uint64_t v31 = v29 + v27 * 4;
    *(unsigned char *)(v31 + 4) = v30;
    cstdlib_memcpy((void *)(v31 + 5), &v22[v27 + 2], 0x20uLL);
    ++v28;
    v27 += 10;
    if (v28 >= *v20)
    {
      uint64_t v22 = (unsigned int *)((char *)v22 + v27 * 4);
      uint64_t v9 = v52;
      goto LABEL_16;
    }
  }
}

void StatValues_ComputeDurStatFromData(uint64_t a1, uint64_t a2)
{
  if (*(float *)(a2 + 11576) == 0.0
    && *(float *)(a2 + 11580) == 0.0
    && *(float *)(a2 + 11568) == 0.0
    && *(float *)(a2 + 11572) == 0.0)
  {
    unsigned int v4 = *(_DWORD *)(a2 + 11564);
    if (*(_DWORD *)(a2 + 5984)) {
      v4 >>= *(_DWORD *)(a2 + 5988) != 0;
    }
    if (v4)
    {
      unsigned int v5 = 0;
      uint64_t v6 = *(unsigned __int8 **)(a1 + 2456);
      int v7 = *(unsigned __int8 *)(a2 + 24);
      uint64_t v8 = v4;
      double v9 = 0.0;
      uint64_t v10 = v4;
      double v11 = 0.0;
      do
      {
        int v12 = *v6++;
        double v13 = (double)(v7 * v12) / 1000.0;
        if (v13 != 0.0)
        {
          double v11 = v11 + v13;
          float v14 = log(v13);
          double v9 = v9 + v14;
          ++v5;
        }
        --v10;
      }
      while (v10);
      if (v5)
      {
        double v11 = v11 / (double)v5;
        unsigned int v15 = v5;
        double v9 = v9 / (double)v5;
      }
      else
      {
        unsigned int v15 = 0;
      }
      uint64_t v18 = *(unsigned __int8 **)(a1 + 2456);
      int v19 = *(unsigned __int8 *)(a2 + 24);
      double v17 = 0.0;
      double v16 = 0.0;
      do
      {
        int v20 = *v18++;
        double v21 = (double)(v19 * v20) / 1000.0;
        if (v21 != 0.0)
        {
          double v16 = v16 + (v21 - v11) * (v21 - v11);
          float v22 = log(v21);
          double v17 = v17 + (v22 - v9) * (v22 - v9);
        }
        --v8;
      }
      while (v8);
      if (v5)
      {
        float v23 = sqrt(v16 / (double)v15);
        double v16 = v23;
        float v24 = sqrt(v17 / (double)v15);
        double v17 = v24;
      }
    }
    else
    {
      double v11 = 0.0;
      double v9 = 0.0;
      double v16 = 0.0;
      double v17 = 0.0;
    }
    float v25 = v11;
    *(float *)(a2 + 11568) = v25;
    float v26 = v16;
    *(float *)(a2 + 11572) = v26;
    float v27 = v9;
    *(float *)(a2 + 11576) = v27;
    float v28 = v17;
    *(float *)(a2 + 11580) = v28;
  }
}

void *UNICORN__mfs_GetMsgName(void *a1, unsigned int a2)
{
  if (a1 && (v2 = a1[72]) != 0 && (uint64_t v3 = a1[73]) != 0 && *(_DWORD *)(a1[71] + 11548) > a2) {
    return (void *)(v3 + *(unsigned int *)(v2 + 12 * a2));
  }
  else {
    return &UNICORN__mfs_GetMsgName_szEmpty;
  }
}

uint64_t mfs_GetMessageOffsetAndDur_Frames(uint64_t result, int a2, _DWORD *a3, _WORD *a4)
{
  uint64_t v4 = *(void *)(result + 592);
  if (v4)
  {
    uint64_t v5 = a2;
    if (a4) {
      *a4 = *(_WORD *)(v4 + 16 * a2 + 8);
    }
    if (a3)
    {
      int v6 = a2 & (a2 >> 31);
      int v7 = (unsigned __int16 *)(v4 + 16 * a2 - 6);
      while (1)
      {
        BOOL v8 = __OFSUB__(a2--, 1);
        if (a2 < 0 != v8) {
          break;
        }
        int v9 = *v7;
        v7 -= 8;
        if (v9 != *(unsigned __int16 *)(v4 + 16 * v5 + 10))
        {
          int v6 = a2 + 1;
          break;
        }
      }
      *a3 = *(_DWORD *)(v4 + 16 * v5 + 4) - *(_DWORD *)(v4 + 16 * v6 + 4);
    }
  }
  else
  {
    uint64_t v10 = *(_DWORD **)(result + 568);
    if (v10[2887] == a2)
    {
      if (a3) {
        *a3 = 0;
      }
      if (a4) {
        *a4 = 0;
      }
    }
    else
    {
      if (a3) {
        *a3 = 0;
      }
      if (a4)
      {
        int v11 = v10[1496];
        if (v11)
        {
          unsigned int v12 = v10[2891];
          unsigned int v13 = v10[1498];
          int v11 = a2 % v13 * (v12 / *(_DWORD *)result);
        }
        else
        {
          unsigned int v13 = v10[1498];
        }
        *a4 = *(unsigned __int8 *)(*(void *)(result + 1032)
                                 + (*(_DWORD *)(*(void *)(result + 848) + 4 * (a2 / v13)) + v11));
      }
    }
  }
  return result;
}

uint64_t mfs_GetMessageOffsetAndDur_Msecs(uint64_t a1, int a2, _DWORD *a3, _WORD *a4)
{
  int v9 = 0;
  __int16 v8 = 0;
  uint64_t result = mfs_GetMessageOffsetAndDur_Frames(a1, a2, &v9, &v8);
  if (a3) {
    *a3 = *(_DWORD *)(*(void *)(a1 + 568) + 24) * v9;
  }
  if (a4) {
    *a4 = v8 * *(_WORD *)(*(void *)(a1 + 568) + 24);
  }
  return result;
}

uint64_t AddFuzzyTableFromInternalTagSoftScoring(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v6 = (unsigned __int8 *)(a3 + 6232);
  uint64_t v7 = *(void *)(a2 + 2376);
  uint64_t v8 = a4;
  int v9 = (void *)(v7 + ((unint64_t)a4 << 6));
  *int v9 = "FUZZY TABLE DERIVED FROM INTERNAL TAG SOFT SCORING";
  v9[1] = "INTERNAL_TAG";
  v9[2] = 0x10000001DLL;
  LODWORD(v10) = -1;
  do
    uint64_t v10 = (v10 + 1);
  while (*(void *)(a3 + 8 * v10 + 2728));
  *(int32x2_t *)(v7 + ((unint64_t)a4 << 6) + 32) = vdup_n_s32(v10);
  uint64_t v11 = heap_Calloc(*(void **)(a1 + 8), 4, (v10 * v10));
  if (!v11) {
    return 2229280778;
  }
  uint64_t v12 = *(void *)(a2 + 2376) + (v8 << 6);
  *(void *)(v12 + 24) = v11;
  *(void *)(v12 + 56) = v11;
  if (v10)
  {
    uint64_t v13 = 0;
    unsigned int v14 = 0;
    do
    {
      uint64_t v15 = 0;
      double v16 = (float *)(v11 + 4 * v14);
      double v17 = v6 + 256;
      do
      {
        if (v13 + v15)
        {
          if (*(unsigned __int8 *)(a3 + v13 + 6232) != *(v17 - 256)) {
            *double v16 = *(float *)(a3 + 6620) + *v16;
          }
          if (*(unsigned __int8 *)(a3 + v13 + 6360) != *(v17 - 128)) {
            *double v16 = *(float *)(a3 + 6624) + *v16;
          }
          if (*(unsigned __int8 *)(a3 + v13 + 6488) != *v17) {
            *double v16 = *(float *)(a3 + 6628) + *v16;
          }
        }
        --v15;
        ++v16;
        ++v17;
      }
      while (-(uint64_t)v10 != v15);
      ++v13;
      v14 += v10;
    }
    while (v13 != v10);
    unsigned int v18 = 0;
    uint64_t v19 = 0;
    int v20 = *(unsigned __int8 *)(a3 + 6616);
    do
    {
      if (*(unsigned __int8 *)(a3 + v19 + 6232) == v20)
      {
        double v21 = (_DWORD *)(v11 + 4 * v18);
        uint64_t v22 = v10;
        float v23 = v6;
        do
        {
          int v24 = *v23++;
          if (v24 != v20) {
            *double v21 = 1176256410;
          }
          ++v21;
          --v22;
        }
        while (v22);
      }
      ++v19;
      v18 += v10;
    }
    while (v19 != v10);
  }
  return 0;
}

uint64_t StatValues_AllocMemoryForClusterStatValues(uint64_t a1, uint64_t *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v8 = 2229280778;
  uint64_t v9 = a3;
  uint64_t v10 = heap_Calloc(*(void **)(a1 + 8), a3, 8);
  *a2 = v10;
  if (v10)
  {
    if (a3)
    {
      uint64_t v11 = 0;
      while (1)
      {
        *(void *)(*a2 + 8 * v11) = heap_Calloc(*(void **)(a1 + 8), (*(_DWORD *)(a4 + 4 * v11) + 1), 4);
        if (!*(void *)(*a2 + 8 * v11)) {
          break;
        }
        if (v9 == ++v11) {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return v8;
}

uint64_t StatValues_AllocMemoryForClusterCount(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = heap_Calloc(*(void **)(a1 + 8), *(unsigned int *)(a2 + 40), 4);
  *(void *)(a2 + 48) = v3;
  if (v3) {
    return 0;
  }
  else {
    return 2229280778;
  }
}

void *StatValues_auxFree(void *result, uint64_t *a2, unsigned int a3)
{
  uint64_t v4 = *a2;
  if (v4)
  {
    uint64_t v5 = result;
    if (a3)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 8 * a3;
      do
      {
        uint64_t v8 = *(void *)(*a2 + v6);
        if (v8) {
          heap_Free((void *)v5[1], v8);
        }
        v6 += 8;
      }
      while (v7 != v6);
      uint64_t v4 = *a2;
    }
    uint64_t result = heap_Free((void *)v5[1], v4);
    *a2 = 0;
  }
  return result;
}

uint64_t ViterbiEE_Init(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a2 + 1072);
  *(void *)a1 = v6;
  *(void *)(a1 + 8) = a4;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = *(void *)(a2 + 1776);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 1784);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = *(void *)(v6 + 8);
  uint64_t result = precomp_Init((uint64_t *)(a1 + 48), a2, a3, a4);
  if ((result & 0x80000000) == 0) {
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 1976);
  }
  return result;
}

uint64_t ViterbiEE_EnableSIMD(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 56) = a2;
  }
  return result;
}

uint64_t ViterbiEE_Release(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (v2)
  {
    int v3 = *(_DWORD *)(a1 + 76);
    if (v3 >= 1)
    {
      uint64_t v4 = 0;
      for (uint64_t i = 0; i < v3; ++i)
      {
        if (*(void *)(v2 + v4))
        {
          heap_Free(*(void **)(v2 + v4 + 16), *(void *)(v2 + v4));
          uint64_t v2 = *(void *)(a1 + 64);
          uint64_t v6 = v2 + v4;
          *(void *)uint64_t v6 = 0;
          *(_DWORD *)(v6 + 12) = 0;
          int v3 = *(_DWORD *)(a1 + 76);
        }
        v4 += 32;
      }
    }
    heap_Free(*(void **)(a1 + 80), v2);
    *(void *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 76) = 0;
  }
  precomp_Release((uint64_t *)(a1 + 48));
  return 0;
}

uint64_t ViterbiEE_Decode(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = 2229280778;
  float v7 = *(float *)(*(void *)(a1 + 16) + 5516);
  int v8 = *(_DWORD *)(*(void *)(*(void *)(a1 + 8) + 568) + 11548);
  int v9 = *(_DWORD *)(a1 + 76);
  UNICORN__log_select_Diag(*(void *)a1, 2, (uint64_t)"ViterbiEE::Decode(|%d|)\n");
  uint64_t v10 = *(uint64_t **)(*(void *)a1 + 8);
  uint64_t v11 = *(unsigned int *)(a2 + 16);
  uint64_t v12 = heap_Realloc(v10, 0, (24 * v11));
  if (!v12) {
    return v6;
  }
  uint64_t v13 = v12;
  precomp_SetupLeftRightData(*(void *)(a1 + 48), (unsigned int **)a2, v9);
  uint64_t v14 = *(void *)(a1 + 48);
  double v16 = *(unsigned int **)(v14 + 48);
  uint64_t v15 = *(_DWORD **)(v14 + 56);
  unsigned int v113 = *v16;
  unsigned int v114 = v15[2891];
  if (*(_DWORD *)(v14 + 1108) == -1) {
    double v17 = "Layer %d setup: candidates will come from main voice";
  }
  else {
    double v17 = "Layer %d setup: candidates will come from addon %d";
  }
  UNICORN__log_select_Diag(*(void *)a1, 2, (uint64_t)v17);
  uint64_t v116 = a1;
  uint64_t v18 = precomp_RightLayerOptimize(a2, *(void *)(a1 + 48));
  if ((v18 & 0x80000000) != 0) {
    return v18;
  }
  int v110 = a3;
  unint64_t v111 = v10;
  int v112 = v11;
  if ((int)v11 < 1)
  {
    float v25 = (uint64_t *)a1;
  }
  else
  {
    uint64_t v19 = 0;
    int v20 = 0;
    float v21 = 1.0 - v7;
    uint64_t v22 = 24 * v11;
    float v23 = 0.0;
    uint64_t v24 = 4;
    int v115 = v114 / v113;
    float v25 = (uint64_t *)v116;
    do
    {
      uint64_t v26 = v25[6];
      uint64_t v27 = *(void *)a2 + 12 * *(int *)(*(void *)(v26 + 976) + v24);
      float v28 = *(float *)(v27 + 4);
      int v29 = *(_DWORD *)v27 - *(_DWORD *)(v26 + 80);
      *(_DWORD *)(v13 + v19) = v29;
      if (v29 == v8) {
        unsigned int v30 = 0;
      }
      else {
        unsigned int v30 = v29;
      }
      if (v15[1691])
      {
        if (v15[1496]) {
          unsigned int v30 = *(_DWORD *)(*((void *)v16 + 106) + 4 * (v30 / v15[1498])) + v30 % *v16 * v115;
        }
        else {
          unsigned int v30 = *(_DWORD *)(*((void *)v16 + 106) + 4 * (v30 / v15[1498]));
        }
      }
      float v31 = v21 * v28;
      uint64_t v32 = v13 + v19;
      *(void *)(v32 + 16) = 0;
      *(float *)(v32 + 12) = v31;
      *(_DWORD *)(v32 + 4) = v30;
      *(_DWORD *)(v32 + 8) = 0;
      if (v31 < v23 || v19 == 0) {
        float v23 = v31;
      }
      UNICORN__log_select_Diag(*v25, 12, (uint64_t)"Candidate %d : id %d target cost %.4f\n");
      float v25 = (uint64_t *)v116;
      ++v20;
      v19 += 24;
      v24 += 8;
    }
    while (v22 != v19);
  }
  UNICORN__log_select_Diag(*v25, 2, (uint64_t)"Min Viterbi target cost: %.3f\n");
  uint64_t v34 = v116;
  int v35 = *(_DWORD *)(v116 + 76);
  uint64_t v6 = 2229280778;
  if (v35 != 0x7FFFFFFF)
  {
    if (v35 < *(_DWORD *)(v116 + 72))
    {
      uint64_t v36 = *(void *)(v116 + 64);
      if (!v36) {
        goto LABEL_30;
      }
      goto LABEL_29;
    }
    int v37 = v35 + 1;
    *(_DWORD *)(v116 + 72) = v37;
    uint64_t v36 = heap_Realloc(*(uint64_t **)(v116 + 80), *(void *)(v116 + 64), (32 * v37));
    uint64_t v34 = v116;
    *(void *)(v116 + 64) = v36;
    if (v36)
    {
LABEL_29:
      uint64_t v38 = v36 + 32 * *(int *)(v34 + 76);
      *(void *)uint64_t v38 = v13;
      *(_DWORD *)(v38 + 8) = v112;
      *(_DWORD *)(v38 + 12) = v112;
      *(void *)(v38 + 16) = v111;
      *(void *)(v38 + 24) = v112;
      ++*(_DWORD *)(v34 + 76);
    }
  }
LABEL_30:
  uint64_t v39 = *(void *)(v34 + 64);
  if (v39)
  {
    uint64_t v6 = 0;
    if (v112 >= 1)
    {
      int v40 = *(_DWORD *)(v34 + 76);
      if (v40 >= 2)
      {
        int v41 = *(_DWORD *)(*(void *)(v34 + 16) + 11548);
        uint64_t v42 = (v40 - 1);
        uint64_t v43 = v39 + 32 * v42;
        uint64_t v44 = v39 + 32 * (v40 - 2);
        uint64_t v45 = v34;
        UNICORN__log_select_Diag(*(void *)v34, 2, (uint64_t)"ViterbiEE::UpdateBestPath()\n");
        ssft_qsort(*(void *)v44, *(unsigned int *)(v44 + 12), 24, (uint64_t (*)(unint64_t, unint64_t))comparePathScores);
        precomp_SetLayer(*(void *)(v45 + 48), v42);
        precomp_SetupJoinCallback(*(_DWORD **)(v45 + 48), *(_DWORD *)(v45 + 56));
        if (*(_DWORD *)(v43 + 12) == 1 && **(_DWORD **)v43 == v41) {
          BOOL v46 = 1;
        }
        else {
          BOOL v46 = *(_DWORD *)(v44 + 12) == 1 && **(_DWORD **)v44 == v41;
        }
        unsigned int LogLevel = UNICORN__log_select_GetLogLevel(*(void *)(*(void *)(*(void *)(v116 + 24) + 1072) + 32));
        unint64_t v48 = (uint64_t *)v116;
        if (LogLevel >= 3)
        {
          uint64_t v49 = *(unsigned int *)(v44 + 12);
          uint64_t v50 = *(void *)(v116 + 24);
          *(_DWORD *)(v50 + 1972) += v49;
          if ((int)v49 >= 1)
          {
            uint64_t v51 = (float *)(*(void *)v44 + 12);
            do
            {
              if (*v51 < 10000000.0) {
                ++*(_DWORD *)(v50 + 1968);
              }
              v51 += 6;
              --v49;
            }
            while (v49);
          }
        }
        if (*(_DWORD *)(*(void *)(v116 + 16) + 5996)) {
          char v52 = v46;
        }
        else {
          char v52 = 1;
        }
        if ((v52 & 1) == 0
          && !((int)v42 % **(_DWORD **)(v116 + 8))
          && (uint64_t v53 = *(void *)(v116 + 48), *(_DWORD *)(v53 + 1104) == -1)
          && *(_DWORD *)(v53 + 1108) == -1)
        {
          LODWORD(v58) = *(_DWORD *)(v43 + 12);
          if ((int)v58 >= 1)
          {
            uint64_t v92 = 0;
            uint64_t v93 = 0;
            uint64_t v94 = *(void *)v116;
            do
            {
              int v95 = *(_DWORD **)v43;
              int v96 = *(_DWORD *)(*(void *)v43 + 24 * v92);
              int v97 = v96 - 1;
              if (v96 < 1)
              {
                UNICORN__log_select_Diag(v94, 2, (uint64_t)"ViterbiEE_DoNestedLoop_UnitBulking: Unexpected unitIDCurrent==0");
                unint64_t v48 = (uint64_t *)v116;
                int v97 = 0;
              }
              uint64_t v98 = *(unsigned int *)(v44 + 12);
              int v99 = v98 + 7;
              if ((int)v98 >= 0) {
                int v99 = *(_DWORD *)(v44 + 12);
              }
              uint64_t v100 = v99 & 0xFFFFFFF8;
              if ((int)v98 < 8)
              {
                LODWORD(v101) = 0;
              }
              else
              {
                uint64_t v101 = 0;
                float v102 = (_DWORD *)(*(void *)v44 + 96);
                while (*(v102 - 24) != v97)
                {
                  if (*(v102 - 18) == v97)
                  {
                    LODWORD(v101) = v101 + 1;
                    goto LABEL_157;
                  }
                  if (*(v102 - 12) == v97)
                  {
                    LODWORD(v101) = v101 + 2;
                    goto LABEL_157;
                  }
                  if (*(v102 - 6) == v97)
                  {
                    LODWORD(v101) = v101 + 3;
                    goto LABEL_157;
                  }
                  if (*v102 == v97)
                  {
                    LODWORD(v101) = v101 + 4;
                    goto LABEL_157;
                  }
                  if (v102[6] == v97)
                  {
                    LODWORD(v101) = v101 + 5;
                    goto LABEL_157;
                  }
                  if (v102[12] == v97)
                  {
                    LODWORD(v101) = v101 + 6;
                    goto LABEL_157;
                  }
                  if (v102[18] == v97)
                  {
                    LODWORD(v101) = v101 + 7;
                    goto LABEL_157;
                  }
                  v101 += 8;
                  v102 += 48;
                  if (v101 >= (int)v100) {
                    break;
                  }
                }
              }
              if (v101 == v100)
              {
                if ((int)v98 - (int)v100 >= 1)
                {
                  LODWORD(v101) = *(_DWORD *)(v44 + 12);
                  float v103 = (int *)(*(void *)v44 + 24 * v100);
                  while (1)
                  {
                    int v104 = *v103;
                    v103 += 6;
                    if (v104 == v97) {
                      break;
                    }
                    if (v98 == ++v100) {
                      goto LABEL_157;
                    }
                  }
                }
                LODWORD(v101) = v100;
              }
LABEL_157:
              if (v101 == v98)
              {
                if (!v93)
                {
                  uint64_t v105 = *(void *)v44;
                  do
                  {
                    if (!v93 || *(float *)(v105 + 12) < *(float *)(v93 + 12)) {
                      uint64_t v93 = v105;
                    }
                    v105 += 24;
                    --v98;
                  }
                  while (v98);
                }
                unsigned int v106 = (float *)&v95[6 * v92];
                v106[3] = v106[3] + (float)(*(float *)(v93 + 12) + 4.0);
                *((void *)v106 + 2) = v93;
                v107 = (_DWORD *)(v93 + 8);
              }
              else
              {
                uint64_t v108 = *(void *)v44 + 24 * (int)v101;
                v109 = (float *)&v95[6 * v92];
                v109[3] = *(float *)(v108 + 12) + v109[3];
                *((void *)v109 + 2) = v108;
                v107 = (_DWORD *)(v108 + 8);
              }
              ++*v107;
              ++v92;
              uint64_t v58 = *(int *)(v43 + 12);
            }
            while (v92 < v58);
          }
        }
        else
        {
          int v54 = *(_DWORD *)(v43 + 12);
          if (v46)
          {
            if (v54 >= 1)
            {
              int v55 = 0;
              do
              {
                precomp_DoInnerLoop__AssignZeroPathCosts(v48[6], (void *)(v39 + 32 * v42), (uint64_t *)v44, v55);
                unint64_t v48 = (uint64_t *)v116;
                ++v55;
              }
              while (v55 < *(_DWORD *)(v43 + 12));
            }
            goto LABEL_81;
          }
          int GranularStep = precomp_getGranularStep(*(void *)(v116 + 48));
          precomp_FetchLeftNodes(*(void *)(v116 + 48), v42, (unsigned int *)v44);
          if (GranularStep < 1) {
            int GranularStep = 1;
          }
          else {
            int v54 = v54 / GranularStep * GranularStep;
          }
          unint64_t v48 = (uint64_t *)v116;
          int v57 = 0;
          if (v54 >= 1)
          {
            do
            {
              (*(void (**)(uint64_t, uint64_t, uint64_t))(v48[6] + 1096))(v48[6], v39 + 32 * v42, v44);
              unint64_t v48 = (uint64_t *)v116;
              v57 += GranularStep;
            }
            while (v57 < v54);
          }
          while (1)
          {
            LODWORD(v58) = *(_DWORD *)(v43 + 12);
            if (v57 >= (int)v58) {
              break;
            }
            precomp_DoInnerLoop(v48[6], (uint64_t *)(v39 + 32 * v42), (uint64_t *)v44, v57, v42);
            unint64_t v48 = (uint64_t *)v116;
            ++v57;
          }
        }
        if (v110 && (int)v58 >= 1)
        {
          unint64_t v59 = 0;
          float v60 = 0;
          uint64_t v61 = *(_DWORD **)v43;
          uint64_t v62 = v58;
          uint64_t v63 = 24 * v58;
          do
          {
            if (!v60 || *(float *)&v61[v59 / 4 + 3] < v60[3]) {
              float v60 = (float *)&v61[v59 / 4];
            }
            v59 += 24;
          }
          while (v63 != v59);
          if (v60)
          {
            uint64_t v64 = *((void *)v60 + 2);
            if (v64)
            {
              unint64_t v65 = 0;
              uint64_t v66 = 24 * v62;
              do
              {
                uint64_t v67 = *(void *)&v61[v65 / 4 + 4];
                if (v67)
                {
                  if (v67 == v64) {
                    *(_DWORD *)(v64 + 8) = 1;
                  }
                  else {
                    *(_DWORD *)(v67 + 8) = 0;
                  }
                }
                v65 += 24;
              }
              while (v66 != v65);
              *uint64_t v61 = v41;
              *((void *)v61 + 2) = v64;
              v61[3] = *((_DWORD *)v60 + 3);
              *(_DWORD *)(v43 + 12) = 1;
              *(_DWORD *)(v39 + 32 * v42 + 24) = 1;
            }
          }
        }
LABEL_81:
        if (UNICORN__log_select_GetLogLevel(*(void *)(*v48 + 32)) >= 3)
        {
          uint64_t v68 = *(unsigned int *)(v43 + 12);
          if ((int)v68 >= 1)
          {
            double v69 = 0;
            double v70 = *(float **)v43;
            do
            {
              if (!v69 || v70[3] < v69[3]) {
                double v69 = v70;
              }
              v70 += 6;
              --v68;
            }
            while (v68);
            if (v69) {
              UNICORN__log_select_Diag(*(void *)v116, 3, (uint64_t)"Viterbi updateBestPath(): best candidate %d (cost %.3f)\n");
            }
          }
        }
        int v71 = *(_DWORD *)(v116 + 76);
        if (v71 <= 1) {
          return 0;
        }
        uint64_t v72 = *(void *)(v116 + 64);
        if (*(_DWORD *)(*(void *)(v116 + 48) + 1108) == -1)
        {
          float v73 = *(float *)(*(void *)(v116 + 16) + 5568) * 10.0;
          double v74 = (unsigned int *)(v72 + 32 * (v71 - 1));
          uint64_t v75 = v74[3];
          if ((int)v75 < 1)
          {
            uint64_t v76 = 0;
          }
          else
          {
            uint64_t v76 = 0;
            uint64_t v77 = *(void *)v74;
            uint64_t v78 = v74[3];
            do
            {
              if (!v76 || *(float *)(v77 + 12) < *(float *)(v76 + 12)) {
                uint64_t v76 = v77;
              }
              v77 += 24;
              --v78;
            }
            while (v78);
          }
          if (v73 < 40.0)
          {
            uint64_t v79 = *(void *)(*(void *)(v116 + 24) + 1768);
            if (v79)
            {
              if (*(_DWORD *)(v79 + 16) || (int)v75 < 1 || *(_DWORD *)(v79 + 12)) {
                goto LABEL_111;
              }
            }
            else if ((int)v75 < 1)
            {
              goto LABEL_111;
            }
            uint64_t v80 = (float *)(*(void *)v74 + 12);
            do
            {
              if (*v80 > (float)(v73 + *(float *)(v76 + 12))) {
                *uint64_t v80 = 10000000.0;
              }
              v80 += 6;
              --v75;
            }
            while (v75);
          }
        }
LABEL_111:
        int v81 = (uint64_t *)(v72 + 32 * (v71 - 2));
        uint64_t v82 = *((unsigned int *)v81 + 3);
        if ((int)v82 >= 1)
        {
          uint64_t v83 = 0;
          uint64_t v84 = *v81;
          int v85 = v81 + 3;
          unint64_t v86 = v81 - 1;
          do
          {
            if (!*(_DWORD *)(v84 + 24 * v83 + 8))
            {
              --*v85;
              uint64_t v87 = *(void *)(v84 + 24 * v83 + 16);
              if (v87)
              {
                float v88 = v86;
                do
                {
                  int v89 = *(_DWORD *)(v87 + 8);
                  BOOL v90 = __OFSUB__(v89--, 1);
                  *(_DWORD *)(v87 + 8) = v89;
                  if (!((v89 < 0) ^ v90 | (v89 == 0))) {
                    break;
                  }
                  --*(_DWORD *)v88;
                  v88 -= 4;
                  uint64_t v87 = *(void *)(v87 + 16);
                }
                while (v87);
              }
            }
            ++v83;
          }
          while (v83 != v82);
        }
        return 0;
      }
    }
  }
  return v6;
}

uint64_t ViterbiEE_Backtrack(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t result = 2229280783;
  if ((a2 & 0x80000000) == 0)
  {
    int v9 = *(_DWORD *)(a1 + 76);
    if (v9 > a2)
    {
      uint64_t v11 = (a3 - 1);
      if (a3 >= 1 && v9 >= a3)
      {
        int v12 = a3 - a2;
        if (a3 - a2 < 1)
        {
          return 2229280775;
        }
        else
        {
          uint64_t v17 = *(int *)(a5 + 16);
          int v33 = *(_DWORD *)(*(void *)(*(void *)(a1 + 8) + 568) + 11548);
          uint64_t result = UNICORN__mfs_S32Vect_Reserve(a5, (int)v17 + v12);
          if ((result & 0x80000000) == 0)
          {
            if (!a6 || (uint64_t result = mfs_F32Vect_Reserve(a6, (int)v17 + v12), (result & 0x80000000) == 0))
            {
              if (!a7 || (uint64_t result = UNICORN__mfs_S32Vect_Reserve(a7, (int)v17 + v12), (result & 0x80000000) == 0))
              {
                uint64_t BestNode = ViterbiEE_GetBestNode((uint64_t *)(*(void *)(a1 + 64) + 32 * v11), *(_DWORD *)(a1 + 76) != a3);
                if (BestNode)
                {
                  uint64_t v19 = BestNode;
                  do
                  {
                    UNICORN__log_select_Diag(*(void *)a1, 3, (uint64_t)"Unit %d, cost %.3f\n");
                    UNICORN__mfs_S32Vect_Pad(a5, *(_DWORD *)v19);
                    if (a6) {
                      UNICORN__mfs_F32Vect_Pad(a6, *(float *)(v19 + 12));
                    }
                    uint64_t v19 = *(void *)(v19 + 16);
                    if (v19) {
                      BOOL v20 = v12 <= 1;
                    }
                    else {
                      BOOL v20 = 1;
                    }
                    --v12;
                  }
                  while (!v20);
                }
                uint64_t v21 = *(int *)(a5 + 16);
                if ((int)v17 < (int)v21 - 1)
                {
                  uint64_t v22 = *(void *)(a5 + 8);
                  uint64_t v23 = v21 - 1;
                  uint64_t v24 = v17;
                  do
                  {
                    int v25 = *(_DWORD *)(v22 + 4 * v24);
                    *(_DWORD *)(v22 + 4 * v24) = *(_DWORD *)(v22 + 4 * v23);
                    *(_DWORD *)(v22 + 4 * v23) = v25;
                    if (a6)
                    {
                      uint64_t v26 = *(void *)(a6 + 8);
                      int v27 = *(_DWORD *)(v26 + 4 * v24);
                      *(_DWORD *)(v26 + 4 * v24) = *(_DWORD *)(v26 + 4 * v23);
                      *(_DWORD *)(v26 + 4 * v23) = v27;
                    }
                    ++v24;
                    --v23;
                  }
                  while (v24 < v23);
                }
                if (**(_DWORD **)(a1 + 8) == 2)
                {
                  char v35 = 0;
                  __int16 v34 = 0;
                  if ((int)v17 < *(_DWORD *)(a5 + 16))
                  {
                    uint64_t v28 = v17;
                    do
                    {
                      UNICORN__mfs_Ling_GetPhonCtxt(a4, (int)v28 / **(_DWORD **)(a1 + 8), &v34);
                      if (HIBYTE(v34) == 1) {
                        *(_DWORD *)(*(void *)(a5 + 8) + 4 * v28) = v33;
                      }
                      ++v28;
                    }
                    while (v28 < *(int *)(a5 + 16));
                  }
                }
                if (a7 && (int)v17 < *(_DWORD *)(a5 + 16))
                {
                  uint64_t v29 = 48 * v17;
                  do
                  {
                    if (*(_DWORD *)(*(void *)(a5 + 8) + 4 * v17) == v33
                      || (unsigned int v30 = *(uint64_t **)(*(void *)(a1 + 24) + 1768)) == 0
                      || (uint64_t v31 = *v30, *(_DWORD *)(v31 + v29)))
                    {
                      int v32 = -1;
                    }
                    else
                    {
                      int v32 = UnicornAddon_UID2AddonId(*(void *)(a1 + 32), *(_DWORD *)(a1 + 40), **(_DWORD **)(v31 + v29 + 8));
                    }
                    uint64_t result = 0;
                    *(_DWORD *)(*(void *)(a7 + 8) + 4 * v17++) = v32;
                    v29 += 48;
                  }
                  while (v17 < *(int *)(a5 + 16));
                }
                else
                {
                  return 0;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t ViterbiEE_GetBestNode(uint64_t *a1, int a2)
{
  uint64_t v2 = *((unsigned int *)a1 + 3);
  if ((int)v2 < 1) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v5 = *a1;
  do
  {
    if ((!a2 || *(int *)(v5 + 8) >= 1) && (!result || *(float *)(v5 + 12) < *(float *)(result + 12))) {
      uint64_t result = v5;
    }
    v5 += 24;
    --v2;
  }
  while (v2);
  return result;
}

uint64_t ViterbiEE_GetUniquePathLength(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 76);
  if (v2 <= a2) {
    int v2 = a2;
  }
  int v3 = a2 - 1;
  uint64_t v4 = v2 - (uint64_t)a2;
  uint64_t v5 = (32 * a2) | 0x18;
  while (v4)
  {
    int v6 = *(_DWORD *)(*(void *)(a1 + 64) + v5);
    ++v3;
    --v4;
    v5 += 32;
    if (v6 >= 2) {
      return (v3 - a2);
    }
  }
  int v3 = v2;
  return (v3 - a2);
}

uint64_t ViterbiForcedEE_GetPathLength(uint64_t a1, int a2)
{
  uint64_t v2 = *(int *)(a1 + 76);
  uint64_t v3 = *(void *)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(v3 + 5928);
  unsigned int v5 = **(_DWORD **)(a1 + 8) * *(_DWORD *)(v3 + 5932);
  uint64_t v6 = a2;
  if ((int)v2 <= a2) {
    int v7 = a2;
  }
  else {
    int v7 = *(_DWORD *)(a1 + 76);
  }
  unsigned int v8 = ~a2 + v2;
  uint64_t v9 = (32 * a2) | 0x18;
  int v10 = a2;
  int v11 = a2;
  do
  {
    if (v7 == v6) {
      break;
    }
    if (*(_DWORD *)(*(void *)(a1 + 64) + v9) <= v4) {
      ++v10;
    }
    if (v8 > v5) {
      ++v11;
    }
    BOOL v12 = v6 < v10 || v6 < v11;
    ++v6;
    --v8;
    v9 += 32;
  }
  while (v12);
  if (v10 <= a2) {
    int v13 = v11;
  }
  else {
    int v13 = v10;
  }
  uint64_t v14 = (v13 - a2);
  if ((int)v14 >= 1)
  {
    uint64_t v15 = *(void *)(a1 + 64);
    uint64_t v16 = v15 + 32 * (v2 - 1);
    uint64_t BestNode = (_DWORD *)ViterbiEE_GetBestNode((uint64_t *)(v15 + 32 * (v13 - 1)), 1);
    for (uint64_t i = 0; i != (*(_DWORD *)(v16 + 12) & ~(*(int *)(v16 + 12) >> 31)); ++i)
    {
      if (*(float *)(*(void *)v16 + 24 * i + 12) >= 10000000.0)
      {
        BOOL v21 = 0;
      }
      else
      {
        uint64_t v19 = *(void *)v16 + 24 * i;
        if ((int)v2 > v13)
        {
          int v20 = v2;
          do
          {
            uint64_t v19 = *(void *)(v19 + 16);
            --v20;
          }
          while (v20 > v13);
        }
        BOOL v21 = *(_DWORD *)v19 == *BestNode;
      }
      if (v21) {
        return v14;
      }
    }
    return 0;
  }
  return v14;
}

uint64_t ViterbiForcedEE_KillPaths(uint64_t result, int a2, int a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(result + 64);
  int v5 = *(_DWORD *)(*(void *)(a4 + 8) + 4 * a2);
  uint64_t v6 = *(void *)(result + 8);
  if ((*(_DWORD *)v6 != 2 || v5 != *(_DWORD *)(*(void *)(v6 + 568) + 11548))
    && *(_DWORD *)(v4 + 32 * a2 + 24) != 1)
  {
    int v7 = (uint64_t *)(v4 + 32 * a3);
    uint64_t v8 = *((unsigned int *)v7 + 3);
    if ((int)v8 >= 1)
    {
      uint64_t v9 = 0;
      uint64_t v10 = *v7;
      do
      {
        uint64_t v11 = v10 + 24 * v9;
        if (a3 > a2)
        {
          int v12 = a3;
          do
          {
            uint64_t v11 = *(void *)(v11 + 16);
            --v12;
          }
          while (v12 > a2);
        }
        if (*(_DWORD *)v11 != v5) {
          *(_DWORD *)(v10 + 24 * v9 + 12) = 1259902592;
        }
        ++v9;
      }
      while (v9 != v8);
    }
  }
  return result;
}

uint64_t comparePathScores(uint64_t a1, uint64_t a2)
{
  float v2 = *(float *)(a1 + 12);
  float v3 = *(float *)(a2 + 12);
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v3 < v2;
  }
}

uint64_t UNICORN__mfs_Ling_GetPhonCtxt(uint64_t result, int a2, unsigned char *a3)
{
  if (a2 < 1) {
    char v3 = 0;
  }
  else {
    char v3 = *(unsigned char *)(*(void *)(result + 32) + (a2 - 1));
  }
  *a3 = v3;
  uint64_t v4 = a2 + 1;
  if ((int)v4 >= *(__int16 *)(result + 10)) {
    char v5 = 0;
  }
  else {
    char v5 = *(unsigned char *)(*(void *)(result + 32) + v4);
  }
  a3[2] = v5;
  a3[1] = *(unsigned char *)(*(void *)(result + 32) + a2);
  return result;
}

uint64_t UNICORN__mfs_Ling_LogPhonCtxt(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result = UNICORN__log_select_GetLogLevel(*(void *)(a1 + 32));
  if (result >= 3)
  {
    uint64_t v9 = *(void *)(a3 + 32);
    if (a4 >= 1)
    {
      for (uint64_t i = 0; i != 256; ++i)
      {
        if (*(unsigned __int8 *)(a2 + 4780 + i) == *(unsigned __int8 *)(v9 + (a4 - 1))) {
          break;
        }
      }
    }
    for (uint64_t j = 0; j != 256; ++j)
    {
      if (*(unsigned __int8 *)(a2 + 4780 + j) == *(unsigned __int8 *)(v9 + a4)) {
        break;
      }
    }
    uint64_t v12 = a4 + 1;
    if ((int)v12 < *(__int16 *)(a3 + 10))
    {
      uint64_t v13 = 0;
      int v14 = *(unsigned __int8 *)(v9 + v12);
      do
      {
        if (*(unsigned __int8 *)(a2 + 4780 + v13) == v14) {
          break;
        }
        ++v13;
      }
      while (v13 != 256);
    }
    return UNICORN__log_select_Diag(a1, 3, (uint64_t)"[%c-%c+%c]\n");
  }
  return result;
}

uint64_t UNICORN__mfs_Ling_HmmPhonemeToLhTts(uint64_t a1, int a2)
{
  uint64_t v2 = 0;
  while (*(unsigned __int8 *)(a1 + 4780 + v2) != a2)
  {
    if (++v2 == 256)
    {
      LOBYTE(v2) = 0;
      return v2;
    }
  }
  return v2;
}

uint64_t UNICORN__mfs_Ling_CenterPhoneme(uint64_t a1, int a2)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 32) + a2);
}

uint64_t UNICORN__mfs_Ling_SylPos(uint64_t a1, int a2)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 152) + a2);
}

uint64_t UNICORN__mfs_Ling_WrdPosShpInPhrs(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 1496);
  if (v2) {
    return *(unsigned __int8 *)(v2 + a2);
  }
  else {
    return 100;
  }
}

uint64_t UNICORN__mfs_Ling_WrdPosInPhrs(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 104);
  if (v2) {
    return *(unsigned __int8 *)(v2 + a2);
  }
  else {
    return 0;
  }
}

uint64_t UNICORN__mfs_Ling_WrdProminence(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 536);
  if (v2) {
    return *(unsigned __int8 *)(v2 + a2);
  }
  else {
    return 5;
  }
}

uint64_t UNICORN__mfs_Ling_WrdShpProminence(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 1424);
  if (v2) {
    return *(unsigned __int8 *)(v2 + a2);
  }
  else {
    return 5;
  }
}

BOOL UNICORN__mfs_Ling_IsSyllableBegin(uint64_t a1, int a2)
{
  return *(unsigned char *)(*(void *)(a1 + 112) + a2) != 0;
}

BOOL UNICORN__mfs_Ling_IsWordBegin(uint64_t a1, int a2)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 112) + a2) > 1u;
}

const char *UNICORN__mfs_Ling_IsVowel(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = *(const char **)(*(void *)(a1 + 5040) + 8 * *(unsigned __int8 *)(*(void *)(a2 + 32) + a3));
  if (result) {
    return (const char *)(strcmp(result, "VV") == 0);
  }
  return result;
}

const char *UNICORN__mfs_Ling_IsVowelVowelTrans(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 < 1) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = *(unsigned __int8 *)(*(void *)(a2 + 32) + (a3 - 1));
  }
  uint64_t v6 = *(void *)(a1 + 5040);
  uint64_t result = *(const char **)(v6 + 8 * v5);
  if (result)
  {
    if (!strcmp(result, "VV"))
    {
      uint64_t result = *(const char **)(v6 + 8 * *(unsigned __int8 *)(*(void *)(a2 + 32) + a3));
      if (result) {
        return (const char *)(strcmp(result, "VV") == 0);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL UNICORN__mfs_Ling_IsInvariantPhoneme(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(unsigned __int8 *)(*(void *)(a2 + 32) + a3);
  uint64_t v4 = *(const char **)(*(void *)(a1 + 5040) + 8 * v3);
  if (!v4) {
    return 0;
  }
  if (!strcmp(*(const char **)(*(void *)(a1 + 5040) + 8 * v3), "SIL") || !strcmp(v4, "UC")) {
    return 1;
  }
  if (strcmp(v4, "MC")) {
    return 0;
  }
  return *(unsigned char *)(*(void *)(a2 + 184) + a3) != 2;
}

float UNICORN__mfs_Ling_TransWeightsDiphADJ(void *a1, int a2)
{
  uint64_t v2 = *(unsigned __int16 *)(*a1 + 3360);
  float result = 0.0;
  if (*(_WORD *)(*a1 + 3360))
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(int **)(*a1 + 3368);
    while (1)
    {
      int v6 = *v5;
      v5 += 3;
      if (v6 == 1) {
        break;
      }
      if (-v2 == --v4) {
        return result;
      }
    }
    if ((int)v4 <= 0) {
      return (float)*(unsigned int *)(a1[448] + 4 * ((int)v2 * a2 - (int)v4)) / 100000.0;
    }
  }
  return result;
}

float UNICORN__mfs_Ling_TransWeightsDiphMCP(void *a1, int a2)
{
  uint64_t v2 = *(unsigned __int16 *)(*a1 + 3360);
  float result = 0.0;
  if (*(_WORD *)(*a1 + 3360))
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(int **)(*a1 + 3368);
    while (1)
    {
      int v6 = *v5;
      v5 += 3;
      if (v6 == 3) {
        break;
      }
      if (-v2 == --v4) {
        return result;
      }
    }
    if ((int)v4 <= 0) {
      return (float)*(unsigned int *)(a1[448] + 4 * ((int)v2 * a2 - (int)v4)) / 1000.0;
    }
  }
  return result;
}

float UNICORN__mfs_Ling_TransWeightsDiphLF0(void *a1, int a2)
{
  uint64_t v2 = *(unsigned __int16 *)(*a1 + 3360);
  float result = 0.0;
  if (*(_WORD *)(*a1 + 3360))
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(int **)(*a1 + 3368);
    while (1)
    {
      int v6 = *v5;
      v5 += 3;
      if (v6 == 2) {
        break;
      }
      if (-v2 == --v4) {
        return result;
      }
    }
    if ((int)v4 <= 0) {
      return (float)*(unsigned int *)(a1[448] + 4 * ((int)v2 * a2 - (int)v4)) / 1000.0;
    }
  }
  return result;
}

float UNICORN__mfs_Ling_TransWeightsPhonADJ(void *a1, int a2)
{
  uint64_t v2 = *(unsigned __int16 *)(*a1 + 3360);
  float result = 0.0;
  if (*(_WORD *)(*a1 + 3360))
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(int **)(*a1 + 3368);
    while (1)
    {
      int v6 = *v5;
      v5 += 3;
      if (v6 == 1) {
        break;
      }
      if (-v2 == --v4) {
        return result;
      }
    }
    if ((int)v4 <= 0) {
      return (float)*(unsigned int *)(a1[449] + 4 * ((int)v2 * a2 - (int)v4)) / 100000.0;
    }
  }
  return result;
}

float UNICORN__mfs_Ling_TransWeightsPhonMCP(void *a1, int a2)
{
  uint64_t v2 = *(unsigned __int16 *)(*a1 + 3360);
  float result = 0.0;
  if (*(_WORD *)(*a1 + 3360))
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(int **)(*a1 + 3368);
    while (1)
    {
      int v6 = *v5;
      v5 += 3;
      if (v6 == 3) {
        break;
      }
      if (-v2 == --v4) {
        return result;
      }
    }
    if ((int)v4 <= 0) {
      return (float)*(unsigned int *)(a1[449] + 4 * ((int)v2 * a2 - (int)v4)) / 1000.0;
    }
  }
  return result;
}

float UNICORN__mfs_Ling_TransWeightsPhonLF0(void *a1, int a2)
{
  uint64_t v2 = *(unsigned __int16 *)(*a1 + 3360);
  float result = 0.0;
  if (*(_WORD *)(*a1 + 3360))
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(int **)(*a1 + 3368);
    while (1)
    {
      int v6 = *v5;
      v5 += 3;
      if (v6 == 2) {
        break;
      }
      if (-v2 == --v4) {
        return result;
      }
    }
    if ((int)v4 <= 0) {
      return (float)*(unsigned int *)(a1[449] + 4 * ((int)v2 * a2 - (int)v4)) / 1000.0;
    }
  }
  return result;
}

uint64_t UNICORN__mfs_Ling_DisplayFeatureValue(uint64_t a1)
{
  return UNICORN__log_select_Diag(a1, 1, (uint64_t)"Phoneme: %d, FeatureId: %d, Value: %d \n");
}

uint64_t UNICORN__mfs_Ling_SetFeatureValue(uint64_t result, unsigned int a2, int a3, char a4)
{
  *(unsigned char *)(*(void *)(result + 8 * a2 + 16) + a3) = a4;
  return result;
}

uint64_t UNICORN__mfs_ParamGenStart(uint64_t a1, int *a2, _DWORD *a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = *(void *)a1;
  uint64_t inited = UNICORN__InitUttModel(*(void *)a1, (char *)(a1 + 56), a2, *(__int16 *)(*(void *)(a1 + 8) + 10));
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  *(_DWORD *)(a1 + 16) = a3[8];
  *(void *)(a1 + 1072) = v6;
  if (*(int *)(a1 + 392) >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v56 = 0;
    uint64_t v57 = 0;
    uint64_t v64 = (uint64_t)(v4 + 64);
    uint64_t v51 = a3 + 182;
    uint64_t v52 = *(void *)(*(void *)(a1 + 8) + 1784);
    uint64_t v55 = (uint64_t)a3;
    float v60 = v4;
    uint64_t v63 = v6;
    while (1)
    {
      UNICORN__log_select_Diag(v6, 21, (uint64_t)"[phoneme %d]\n");
      uint64_t v14 = *(void *)(a1 + 384);
      uint64_t v58 = v14;
      if (*(int *)(a1 + 32) >= 1)
      {
        uint64_t v15 = 0;
        uint64_t v16 = v51;
        do
        {
          uint64_t v17 = &a3[v15];
          int v20 = v17[61];
          uint64_t v19 = v17 + 61;
          int v18 = v20;
          if (v20 < 1)
          {
            LODWORD(v21) = 0;
          }
          else
          {
            uint64_t v21 = 0;
            uint64_t v22 = (const char **)&a3[2 * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 8) + 248) + v8) + 682];
            do
            {
              uint64_t v23 = *(const char **)&v16[2 * v21];
              if (v23 && *v22)
              {
                if (!cstdlib_strcmp(v23, *v22)) {
                  goto LABEL_14;
                }
                int v18 = *v19;
              }
              ++v21;
            }
            while (v21 < v18);
            LODWORD(v21) = 0;
LABEL_14:
            uint64_t v14 = v58;
          }
          *(_DWORD *)(v14 + 312 * v8 + 4 * v15++ + 36) = v21;
          v16 += 10;
        }
        while (v15 < *(int *)(a1 + 32));
      }
      uint64_t v4 = v60;
      if (v52)
      {
        if (a3[29])
        {
          uint64_t v46 = 2229280769;
          unint64_t v48 = "Phoneme level segmentation is not currently supported\n";
          uint64_t v49 = v6;
          uint64_t v50 = 58016;
          goto LABEL_55;
        }
        if (a3[28]) {
          break;
        }
      }
      uint64_t v24 = (int32x2_t *)(v14 + 312 * v8);
      v24[1].i32[0] = UNICORN__TreeSearch(*(void *)(a1 + 8), v8, v64, 0, 0);
      UNICORN__log_select_Diag(v6, 6, (uint64_t)"DUR pdf id %d\n");
      uint64_t inited = UNICORN__FindDurPDF(v24, v60, 0, v24[4].i32[1], 0.0);
      if ((inited & 0x80000000) != 0) {
        return inited;
      }
      *(_DWORD *)(a1 + 408) += *(_DWORD *)(v14 + 312 * v8 + 24);
      int v25 = *(_DWORD *)(a1 + 32);
      if (v25 >= 1)
      {
        for (uint64_t i = 0; i < v25; ++i)
        {
          uint64_t v27 = *(void *)(a1 + 24);
          if (!*(_DWORD *)(v27 + 1520 * i + 1472))
          {
            if (*(_DWORD *)(v27 + 1520 * i + 1480))
            {
              uint64_t v28 = a1 + 8 * i;
              int v29 = *v4 * v8;
              uint64_t v56 = *(void *)(*(void *)(v28 + 208) + 8 * v29);
              uint64_t v57 = *(void *)(*(void *)(v28 + 168) + 8 * v29);
            }
            unsigned int v30 = (char *)v4 + 2 * i;
            if (*((_WORD *)v30 + 176))
            {
              uint64_t v31 = 0;
              uint64_t v32 = v14;
              unint64_t v33 = 0;
              uint64_t v34 = v32 + 312 * v8;
              char v35 = (void *)(v34 + 8 * i);
              uint64_t v61 = (unsigned __int16 *)(v30 + 352);
              uint64_t v62 = &v4[2 * i + 78];
              uint64_t v36 = a3;
              int v37 = v35 + 7;
              int v54 = &v4[i + 1];
              uint64_t v38 = v35 + 12;
              uint64_t v39 = v35 + 17;
              uint64_t v53 = &v36[i + 46];
              unint64_t v59 = (int *)(v34 + 4 * i + 36);
              do
              {
                uint64_t v40 = *(unsigned __int16 *)(*(void *)v62 + v31);
                *(_DWORD *)(*v37 + 4 * v40) = UNICORN__TreeSearch(*(void *)(a1 + 8), v8, v64, i, v33);
                UNICORN__log_select_Diag(v63, 6, (uint64_t)"%s pdf state %d id %d\n");
                uint64_t v41 = *(void *)(a1 + 24);
                if (*(_DWORD *)(v41 + 1520 * i + 1480))
                {
                  int v42 = v40 - 2;
                  int v43 = v42 + v42 * *v54;
                  *(void *)(*v38 + 8 * v40) = v57 + 4 * v43;
                  *(void *)(*v38 + 8 * v40) -= 4;
                  *(void *)(*v39 + 8 * v40) = v56 + 4 * v43;
                  *(void *)(*v39 + 8 * v40) -= 4;
                  uint64_t v44 = *(void **)(a1 + 1768);
                  if (v44 && *v53 == 2) {
                    uint64_t LF0PDF_PerStateRho = UNICORN__FindLF0PDF_PerStateRho(i, v40, (uint64_t)v24, (uint64_t)v60, v55, *v59, *(_DWORD *)(*(void *)(a1 + 24) + 1520 * i + 1484), *(float *)(*v44 + 48 * (v42 + *v60 * v8) + 20));
                  }
                  else {
                    uint64_t LF0PDF_PerStateRho = UNICORN__FindMsdPDF(i, v40, (uint64_t)v24, (uint64_t)v60, v55, *v59);
                  }
                  uint64_t v46 = LF0PDF_PerStateRho;
                  if ((LF0PDF_PerStateRho & 0x80000000) != 0) {
                    return v46;
                  }
                }
                else if (*(_DWORD *)(v41 + 1520 * i + 1476))
                {
                  uint64_t inited = UNICORN__FindContPDF(i, v40, (uint64_t)v24, (uint64_t)v60, *v59);
                  if ((inited & 0x80000000) != 0) {
                    return inited;
                  }
                }
                ++v33;
                v31 += 16;
              }
              while (v33 < *v61);
              int v25 = *(_DWORD *)(a1 + 32);
              a3 = (_DWORD *)v55;
              uint64_t v4 = v60;
              uint64_t v14 = v58;
            }
          }
        }
      }
      ++v8;
      uint64_t v6 = v63;
      if (v8 >= *(int *)(a1 + 392)) {
        goto LABEL_42;
      }
    }
    uint64_t v46 = 2229280769;
    unint64_t v48 = "State level segmentation is not currently supported\n";
    uint64_t v49 = v6;
    uint64_t v50 = 58017;
LABEL_55:
    UNICORN__log_select_Error(v49, v50, (uint64_t)v48, v9, v10, v11, v12, v13);
    return v46;
  }
LABEL_42:
  if (UNICORN__log_select_GetLogLevel(*(void *)(v6 + 32)) >= 0x15) {
    OutLabel_1(a1);
  }
  uint64_t inited = mfs_SegmentList_InitPrealloc(v6, (uint64_t)v4, *v4 * *(__int16 *)(*(void *)(a1 + 8) + 10), a1 + 1520);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t inited = mfs_SegmentList_InitPrealloc(v6, (uint64_t)v4, *v4 * *(__int16 *)(*(void *)(a1 + 8) + 10), a1 + 1552);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  if (!a3[1684]) {
    return 2229280769;
  }

  return PredictPipeline_ProcessStart(a1, (uint64_t)v4, (uint64_t)a3);
}

uint64_t OutLabel_1(uint64_t result)
{
  if (*(int *)(result + 392) >= 1)
  {
    uint64_t v1 = result;
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    int v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(v1 + 384) + v2;
      float result = UNICORN__log_select_Diag(*(void *)v1, 21, (uint64_t)"%d %d %d [%d]\n");
      v4 += *(_DWORD *)(v5 + 24);
      ++v3;
      v2 += 312;
    }
    while (v3 < *(int *)(v1 + 392));
  }
  return result;
}

uint64_t UNICORN__mfs_ParamGenContinue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a3 + 6736)) {
    return PredictPipeline_Process(*(void *)(a1 + 1760));
  }
  else {
    return 2229280769;
  }
}

uint64_t mfs_FillModelSegmentsPartial(int *a1, uint64_t *a2, uint64_t a3, int a4, int a5, uint64_t a6)
{
  LODWORD(v8) = a4;
  UNICORN__log_select_Diag(*a2, 1, (uint64_t)"  -> GetParametricSegments\n");
  if ((int)v8 < 1)
  {
    int v13 = 0;
  }
  else
  {
    uint64_t v12 = 0;
    int v13 = 0;
    int v14 = *a1;
    do
    {
      if (v14 >= 1)
      {
        uint64_t v15 = (int *)(*(void *)(a2[48] + 312 * v12 + 16) + 8);
        uint64_t v16 = (v14 + 2) - 2;
        do
        {
          int v17 = *v15++;
          v13 += *(_DWORD *)(a3 + 24) * v17;
          --v16;
        }
        while (v16);
      }
      ++v12;
    }
    while (v12 != v8);
  }
  if ((int)v8 > a5) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v8 = (int)v8;
  int v19 = a5 + 1;
  LODWORD(v20) = *a1;
  while ((int)v20 < 1)
  {
LABEL_17:
    if (v19 == ++v8) {
      return result;
    }
  }
  uint64_t v21 = a2[48] + 312 * v8;
  uint64_t v24 = *(void *)(v21 + 16);
  uint64_t v23 = (uint64_t *)(v21 + 16);
  uint64_t v22 = v24;
  int v25 = *(_DWORD *)(a3 + 24);
  uint64_t v26 = 2;
  while (1)
  {
    uint64_t result = UNICORN__mfs_SegmentList_Add(a6, -1, *(unsigned char *)(*(void *)(a2[1] + 32) + v8), v13, v25 * *(_DWORD *)(v22 + 4 * v26));
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t v22 = *v23;
    int v25 = *(_DWORD *)(a3 + 24);
    v13 += v25 * *(_DWORD *)(*v23 + 4 * v26);
    uint64_t v20 = *a1;
    if (v26++ > v20) {
      goto LABEL_17;
    }
  }
}

void UNICORN__FreeRemainingStreams(uint64_t a1)
{
  if (*(int *)(a1 + 32) >= 1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = 16;
    do
    {
      UNICORN__FreePStreamSM(*(void *)(a1 + 24) + v3);
      ++v2;
      v3 += 1520;
    }
    while (v2 < *(int *)(a1 + 32));
  }
}

uint64_t mfs_FillModelSegments(int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return mfs_FillModelSegmentsPartial(a1, (uint64_t *)a2, a3, 0, *(_DWORD *)(a2 + 392) - 1, a4);
}

uint64_t mfs_TCost_Elf0_Manhattan_Clusterize_SIMD(float *a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, double a6, double a7, double a8, float a9, float a10, float a11, float a12, float a13, float a14)
{
  float v20 = 1.0 - a10;
  uint64_t v21 = *(void *)(a2 + 8);
  uint64_t v22 = *(void *)(*(void *)(a2 + 16) + 32 * a3);
  uint64_t v23 = 8 * a5 - 16;
  uint64_t v24 = v21 + v23;
  int v25 = *(int16x4_t **)(*(void *)(v21 + v23 + 1200) + 8 * a4);
  uint64_t v26 = *(int16x4_t **)(*(void *)(v21 + v23 + 1264) + 8 * a4);
  unsigned int v27 = *(_DWORD *)(*(void *)(*(void *)(v21 + 776) + 8 * a5) + 40 * a4 + 4);
  uint64_t v28 = *(unsigned __int8 **)(*(void *)(v24 + 1328) + 8 * a4);
  int v29 = *(unsigned __int8 **)(a2 + v23 + 112);
  float v30 = a9 * a10;
  float v31 = (float)(1.0 - a10) * a9;
  *(float *)v17.i32 = a1[2897] * a11;
  *(float *)v18.i32 = a1[2899] * a11;
  float v32 = a1[2901];
  unsigned int v33 = v27 & 0xFFFFFFF8;
  if ((v27 & 0xFFFFFFF8) != 0)
  {
    uint64_t v34 = 0;
    unsigned int v35 = 0;
    float32x4_t v36 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a6, 0);
    float32x4_t v37 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a7, 0);
    float32x4_t v38 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a8, 0);
    uint64_t v39 = a1 + 1514;
    float32x4_t v40 = vld1q_dup_f32(v39);
    float32x4_t v41 = vrecpeq_f32(v40);
    float32x4_t v42 = vmulq_f32(v41, vrecpsq_f32(v40, v41));
    float32x4_t v43 = vmulq_f32(vrecpsq_f32(v40, v42), v42);
    uint64_t v44 = a1 + 1504;
    float32x4_t v45 = vld1q_dup_f32(v44);
    float32x4_t v46 = (float32x4_t)vdupq_lane_s32(v17, 0);
    float32x4_t v47 = (float32x4_t)vdupq_lane_s32(v18, 0);
    BOOL v48 = a11 != 0.0;
    if (a12 != 0.0) {
      BOOL v48 = 1;
    }
    if (a13 != 0.0) {
      BOOL v48 = 1;
    }
    if (a14 != 0.0) {
      BOOL v48 = 1;
    }
    uint64_t v49 = v29;
    while (1)
    {
      unsigned int v51 = *v49++;
      unsigned int v50 = v51;
      uint64_t v52 = (__int32 *)&v28[v34];
      if ((v51 & 0xF) == 0) {
        goto LABEL_16;
      }
      v19.i32[0] = *v52;
      float32x4_t v53 = vaddq_f32(v45, vmulq_f32(v43, vcvtq_f32_s32(vmovl_s16(*v25))));
      float32x4_t v54 = vaddq_f32(v45, vmulq_f32(v43, vcvtq_f32_s32(vmovl_s16(*v26))));
      float32x4_t v55 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v19.f32)));
      float32x4_t v56 = vrecpeq_f32(v55);
      float32x4_t v57 = vmulq_f32(v56, vrecpsq_f32(v55, v56));
      float32x4_t v58 = vmulq_f32(vrecpsq_f32(v55, v57), v57);
      float32x4_t v59 = vabdq_f32(v36, v53);
      float32x4_t v60 = vmaxq_f32(v36, v53);
      float32x4_t v61 = vrecpeq_f32(v60);
      float32x4_t v62 = vmulq_f32(v61, vrecpsq_f32(v60, v61));
      float32x4_t v63 = vmulq_f32(v59, vmulq_f32(vrecpsq_f32(v60, v62), v62));
      float32x4_t v64 = vabdq_f32(v37, v54);
      float32x4_t v65 = vmaxq_f32(v37, v54);
      float32x4_t v66 = vrecpeq_f32(v65);
      float32x4_t v67 = vmulq_f32(v66, vrecpsq_f32(v65, v66));
      float32x4_t v68 = vabdq_f32(v38, vmulq_f32(v58, vsubq_f32(v53, v54)));
      float32x4_t v19 = vmulq_n_f32(vaddq_f32(vmulq_n_f32(v68, a10), vmulq_n_f32(vaddq_f32(v63, vmulq_f32(v64, vmulq_f32(vrecpsq_f32(v65, v67), v67))), v20)), a9);
      if (v48)
      {
        float32x4_t v86 = vaddq_f32((float32x4_t)vandq_s8((int8x16_t)vmulq_n_f32(vmulq_n_f32(v59, a12), v31), (int8x16_t)vcgtq_f32(v59, v46)), v19);
        int8x16_t v87 = (int8x16_t)vcgtq_f32(v64, v47);
        float32x4_t v19 = vaddq_f32(vaddq_f32(v86, (float32x4_t)vandq_s8((int8x16_t)vmulq_n_f32(vmulq_n_f32(v64, a12), v31), v87)), (float32x4_t)vandq_s8((int8x16_t)vmulq_n_f32(vmulq_n_f32(v68, a14), v30), v87));
        if ((v50 & 1) == 0)
        {
LABEL_12:
          if ((v50 & 2) == 0) {
            goto LABEL_13;
          }
          goto LABEL_26;
        }
      }
      else if ((v50 & 1) == 0)
      {
        goto LABEL_12;
      }
      uint64_t v88 = v22 + 12 * v35++;
      *(float *)(v88 + 4) = v19.f32[0] + *(float *)(v88 + 4);
      if ((v50 & 2) == 0)
      {
LABEL_13:
        if ((v50 & 4) == 0) {
          goto LABEL_14;
        }
        goto LABEL_27;
      }
LABEL_26:
      uint64_t v89 = v22 + 12 * v35++;
      *(float *)(v89 + 4) = v19.f32[1] + *(float *)(v89 + 4);
      if ((v50 & 4) == 0)
      {
LABEL_14:
        if ((v50 & 8) == 0) {
          goto LABEL_16;
        }
LABEL_15:
        uint64_t v69 = v22 + 12 * v35++;
        *(float *)(v69 + 4) = v19.f32[3] + *(float *)(v69 + 4);
        goto LABEL_16;
      }
LABEL_27:
      uint64_t v90 = v22 + 12 * v35++;
      *(float *)(v90 + 4) = v19.f32[2] + *(float *)(v90 + 4);
      if ((v50 & 8) != 0) {
        goto LABEL_15;
      }
LABEL_16:
      if (v50 < 0x10) {
        goto LABEL_22;
      }
      v19.i32[0] = v52[1];
      float32x4_t v70 = vaddq_f32(v45, vmulq_f32(v43, vcvtq_f32_s32(vmovl_s16(v25[1]))));
      float32x4_t v71 = vaddq_f32(v45, vmulq_f32(v43, vcvtq_f32_s32(vmovl_s16(v26[1]))));
      float32x4_t v72 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v19.f32)));
      float32x4_t v73 = vrecpeq_f32(v72);
      float32x4_t v74 = vmulq_f32(v73, vrecpsq_f32(v72, v73));
      float32x4_t v75 = vmulq_f32(vrecpsq_f32(v72, v74), v74);
      float32x4_t v76 = vabdq_f32(v36, v70);
      float32x4_t v77 = vmaxq_f32(v36, v70);
      float32x4_t v78 = vrecpeq_f32(v77);
      float32x4_t v79 = vmulq_f32(v78, vrecpsq_f32(v77, v78));
      float32x4_t v80 = vmulq_f32(v76, vmulq_f32(vrecpsq_f32(v77, v79), v79));
      float32x4_t v81 = vabdq_f32(v37, v71);
      float32x4_t v82 = vmaxq_f32(v37, v71);
      float32x4_t v83 = vrecpeq_f32(v82);
      float32x4_t v84 = vmulq_f32(v83, vrecpsq_f32(v82, v83));
      float32x4_t v85 = vabdq_f32(v38, vmulq_f32(v75, vsubq_f32(v70, v71)));
      float32x4_t v19 = vmulq_n_f32(vaddq_f32(vmulq_n_f32(v85, a10), vmulq_n_f32(vaddq_f32(v80, vmulq_f32(v81, vmulq_f32(vrecpsq_f32(v82, v84), v84))), v20)), a9);
      if (v48)
      {
        float32x4_t v91 = vaddq_f32((float32x4_t)vandq_s8((int8x16_t)vmulq_n_f32(vmulq_n_f32(v76, a12), v31), (int8x16_t)vcgtq_f32(v76, v46)), v19);
        int8x16_t v92 = (int8x16_t)vcgtq_f32(v81, v47);
        float32x4_t v19 = vaddq_f32(vaddq_f32(v91, (float32x4_t)vandq_s8((int8x16_t)vmulq_n_f32(vmulq_n_f32(v81, a12), v31), v92)), (float32x4_t)vandq_s8((int8x16_t)vmulq_n_f32(vmulq_n_f32(v85, a14), v30), v92));
        if ((v50 & 0x10) == 0)
        {
LABEL_19:
          if ((v50 & 0x20) == 0) {
            goto LABEL_20;
          }
          goto LABEL_31;
        }
      }
      else if ((v50 & 0x10) == 0)
      {
        goto LABEL_19;
      }
      uint64_t v93 = v22 + 12 * v35++;
      *(float *)(v93 + 4) = v19.f32[0] + *(float *)(v93 + 4);
      if ((v50 & 0x20) == 0)
      {
LABEL_20:
        if ((v50 & 0x40) == 0) {
          goto LABEL_21;
        }
        goto LABEL_32;
      }
LABEL_31:
      uint64_t v94 = v22 + 12 * v35++;
      *(float *)(v94 + 4) = v19.f32[1] + *(float *)(v94 + 4);
      if ((v50 & 0x40) == 0)
      {
LABEL_21:
        if ((v50 & 0x80) != 0) {
          goto LABEL_33;
        }
        goto LABEL_22;
      }
LABEL_32:
      uint64_t v95 = v22 + 12 * v35++;
      *(float *)(v95 + 4) = v19.f32[2] + *(float *)(v95 + 4);
      if ((v50 & 0x80) != 0)
      {
LABEL_33:
        uint64_t v96 = v22 + 12 * v35++;
        *(float *)(v96 + 4) = v19.f32[3] + *(float *)(v96 + 4);
      }
LABEL_22:
      v26 += 2;
      v25 += 2;
      v34 += 8;
      if (v34 >= v33)
      {
        unsigned int v33 = ((v33 - 1) & 0xFFFFFFF8) + 8;
        v28 += v34;
        goto LABEL_35;
      }
    }
  }
  unsigned int v35 = 0;
LABEL_35:
  if (v33 < v27)
  {
    float v97 = v32 * a13;
    BOOL v98 = a11 != 0.0;
    if (a12 != 0.0) {
      BOOL v98 = 1;
    }
    if (a13 != 0.0) {
      BOOL v98 = 1;
    }
    if (a14 != 0.0) {
      BOOL v98 = 1;
    }
    float v99 = v31 * a12;
    float v100 = v30 * a14;
    do
    {
      if ((*(_DWORD *)&v29[4 * (v33 >> 5)] >> v33))
      {
        float v101 = (float)v25->i16[0];
        float v102 = 1.0 / a1[1514];
        float v103 = a1[1504];
        float v104 = (float)v26->i16[0];
        float v105 = v103 + (float)(v101 * v102);
        float v106 = v103 + (float)(v104 * v102);
        float v107 = vabds_f32(*(float *)&a6, v105);
        if (v105 >= *(float *)&a6) {
          float v108 = v105;
        }
        else {
          float v108 = *(float *)&a6;
        }
        float v109 = v107 / v108;
        float v110 = vabds_f32(*(float *)&a7, v106);
        if (v106 >= *(float *)&a7) {
          float v111 = v106;
        }
        else {
          float v111 = *(float *)&a7;
        }
        uint64_t v112 = v22 + 12 * v35;
        float v114 = *(float *)(v112 + 4);
        unsigned int v113 = (float *)(v112 + 4);
        float v115 = v114
             + (float)(a9
                     * (float)((float)(fabsf(*(float *)&a8 - (float)((float)(v105 - v106) * a1[*v28 + 2616])) * a10)
                             + (float)(v20 * (float)(v109 + (float)(v110 / v111)))));
        *unsigned int v113 = v115;
        if (v98)
        {
          float v116 = a1[1514];
          float v117 = a1[1504];
          float v118 = (float)(v101 / v116) + v117;
          float v119 = vabds_f32(*(float *)&a6, v118);
          if (v119 > *(float *)v17.i32)
          {
            float v115 = v115 + (float)(v99 * v119);
            *unsigned int v113 = v115;
            float v116 = a1[1514];
            float v117 = a1[1504];
          }
          float v120 = (float)(v104 / v116) + v117;
          float v121 = vabds_f32(*(float *)&a7, v120);
          if (v121 > *(float *)v18.i32)
          {
            float v115 = v115 + (float)(v99 * v121);
            *unsigned int v113 = v115;
          }
          float v122 = vabds_f32(*(float *)&a8, (float)(v118 - v120) * a1[*v28 + 2616]);
          if (v122 > v97) {
            *unsigned int v113 = v115 + (float)(v100 * v122);
          }
        }
        ++v35;
      }
      int v25 = (int16x4_t *)((char *)v25 + 2);
      uint64_t v26 = (int16x4_t *)((char *)v26 + 2);
      ++v28;
      ++v33;
    }
    while (v27 != v33);
  }
  return 0;
}

uint64_t mfs_bnfData_Clusterize_Block_Distance_fxd16_SIMD(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, float *a6, float a7)
{
  uint64_t v116 = 0;
  uint64_t v11 = a5 - 2;
  uint64_t v12 = (void *)(a1 + 8 * v11);
  uint64_t v13 = a4;
  uint64_t v14 = *(unsigned int *)(v12[108] + 4 * a4);
  unsigned int v15 = *(unsigned __int8 *)(a1 + 1520);
  if (*(_DWORD *)(a1 + 1524) == 1)
  {
    uint64_t v16 = a2;
    uint64_t result = brk_DataMap(*(void *)(a2 + 24), *(void *)(a1 + 2464), (*(_DWORD *)(v12[192] + 4 * a4) + *(_DWORD *)(a1 + 1528)), v14 * v15, (uint64_t)&v116);
    if ((result & 0x80000000) != 0)
    {
      uint64_t v115 = result;
      UNICORN__log_select_Error(v16, 74001, (uint64_t)"ODLBNF DataMap (%u,%u) Error %x", v18, v19, v20, v21, v22);
      return v115;
    }
    a2 = v16;
  }
  else
  {
    uint64_t result = 0;
    uint64_t v116 = *(void *)(v12[134] + 8 * a4);
  }
  uint64_t v23 = *(float **)(*(void *)(a1 + 8 * v11 + 1136) + 8 * v13);
  if (v15 == 160)
  {
    if (v14)
    {
      uint64_t v24 = v116;
      do
      {
        int8x16_t v25 = *(int8x16_t *)(v24 + 16);
        int16x8_t v26 = vmovl_s8(*(int8x8_t *)v24);
        int16x8_t v27 = vmovl_high_s8(*(int8x16_t *)v24);
        int16x8_t v28 = *(int16x8_t *)(a3 + 16);
        int32x4_t v29 = vmull_s16(*(int16x4_t *)v26.i8, *(int16x4_t *)a3);
        int32x4_t v30 = vmull_high_s16(v26, *(int16x8_t *)a3);
        int32x4_t v31 = vmull_s16(*(int16x4_t *)v27.i8, *(int16x4_t *)v28.i8);
        int32x4_t v32 = vpaddq_s32(v29, v30);
        int32x4_t v33 = vmull_high_s16(v27, v28);
        int16x8_t v34 = vmovl_s8(*(int8x8_t *)v25.i8);
        int16x8_t v35 = vmovl_high_s8(v25);
        int16x8_t v36 = *(int16x8_t *)(a3 + 32);
        int16x8_t v37 = *(int16x8_t *)(a3 + 48);
        int32x4_t v38 = vpaddq_s32(v31, v33);
        int32x4_t v39 = vmull_s16(*(int16x4_t *)v34.i8, *(int16x4_t *)v36.i8);
        int32x4_t v40 = vmull_high_s16(v34, v36);
        int32x4_t v41 = vmull_s16(*(int16x4_t *)v35.i8, *(int16x4_t *)v37.i8);
        int32x4_t v42 = vmull_high_s16(v35, v37);
        int32x4_t v43 = vpaddq_s32(v39, v40);
        int8x16_t v45 = *(int8x16_t *)(v24 + 32);
        int8x16_t v44 = *(int8x16_t *)(v24 + 48);
        int16x8_t v46 = vmovl_s8(*(int8x8_t *)v45.i8);
        int16x8_t v47 = vmovl_high_s8(v45);
        int16x8_t v48 = *(int16x8_t *)(a3 + 64);
        int16x8_t v49 = *(int16x8_t *)(a3 + 80);
        int32x4_t v50 = vpaddq_s32(v41, v42);
        int32x4_t v51 = vmull_s16(*(int16x4_t *)v46.i8, *(int16x4_t *)v48.i8);
        int32x4_t v52 = vmull_high_s16(v46, v48);
        int32x4_t v53 = vmull_s16(*(int16x4_t *)v47.i8, *(int16x4_t *)v49.i8);
        int32x4_t v54 = vmull_high_s16(v47, v49);
        int16x8_t v55 = vmovl_s8(*(int8x8_t *)v44.i8);
        int32x4_t v56 = vpaddq_s32(v51, v52);
        int16x8_t v57 = vmovl_high_s8(v44);
        int16x8_t v58 = *(int16x8_t *)(a3 + 112);
        int32x4_t v59 = vpaddq_s32(v53, v54);
        int32x4_t v60 = vpaddq_s32(vmull_s16(*(int16x4_t *)v55.i8, *(int16x4_t *)(a3 + 96)), vmull_high_s16(v55, *(int16x8_t *)(a3 + 96)));
        int32x4_t v61 = vmull_s16(*(int16x4_t *)v57.i8, *(int16x4_t *)v58.i8);
        int32x4_t v62 = vmull_high_s16(v57, v58);
        int8x16_t v63 = *(int8x16_t *)(v24 + 64);
        int8x16_t v64 = *(int8x16_t *)(v24 + 80);
        int32x4_t v65 = vpaddq_s32(v61, v62);
        int16x8_t v66 = vmovl_s8(*(int8x8_t *)v63.i8);
        int16x8_t v67 = vmovl_high_s8(v63);
        int32x4_t v68 = vaddq_s32(v43, v32);
        int32x4_t v69 = vpaddq_s32(vmull_s16(*(int16x4_t *)v66.i8, *(int16x4_t *)(a3 + 128)), vmull_high_s16(v66, *(int16x8_t *)(a3 + 128)));
        int32x4_t v70 = vpaddq_s32(vmull_s16(*(int16x4_t *)v67.i8, *(int16x4_t *)(a3 + 144)), vmull_high_s16(v67, *(int16x8_t *)(a3 + 144)));
        int32x4_t v71 = vaddq_s32(v50, v38);
        int16x8_t v72 = vmovl_s8(*(int8x8_t *)v64.i8);
        int16x8_t v73 = vmovl_high_s8(v64);
        int32x4_t v74 = vaddq_s32(v56, v60);
        int32x4_t v75 = vpaddq_s32(vmull_s16(*(int16x4_t *)v73.i8, *(int16x4_t *)(a3 + 176)), vmull_high_s16(v73, *(int16x8_t *)(a3 + 176)));
        int32x4_t v76 = vaddq_s32(v59, v65);
        int8x16_t v77 = *(int8x16_t *)(v24 + 96);
        int8x16_t v78 = *(int8x16_t *)(v24 + 112);
        int16x8_t v79 = vmovl_s8(*(int8x8_t *)v77.i8);
        int16x8_t v80 = vmovl_high_s8(v77);
        int32x4_t v81 = vaddq_s32(v69, vpaddq_s32(vmull_s16(*(int16x4_t *)v72.i8, *(int16x4_t *)(a3 + 160)), vmull_high_s16(v72, *(int16x8_t *)(a3 + 160))));
        int32x4_t v82 = vaddq_s32(v70, v75);
        int32x4_t v83 = vpaddq_s32(vmull_s16(*(int16x4_t *)v80.i8, *(int16x4_t *)(a3 + 208)), vmull_high_s16(v80, *(int16x8_t *)(a3 + 208)));
        int16x8_t v84 = vmovl_s8(*(int8x8_t *)v78.i8);
        int16x8_t v85 = vmovl_high_s8(v78);
        int32x4_t v86 = vaddq_s32(v68, v74);
        int32x4_t v87 = vaddq_s32(v71, v76);
        int32x4_t v88 = vpaddq_s32(vmull_s16(*(int16x4_t *)v85.i8, *(int16x4_t *)(a3 + 240)), vmull_high_s16(v85, *(int16x8_t *)(a3 + 240)));
        int8x16_t v89 = *(int8x16_t *)(v24 + 128);
        int8x16_t v90 = *(int8x16_t *)(v24 + 144);
        int16x8_t v91 = vmovl_s8(*(int8x8_t *)v89.i8);
        int16x8_t v92 = vmovl_high_s8(v89);
        int32x4_t v93 = vaddq_s32(v86, vaddq_s32(v81, vpaddq_s32(vmull_s16(*(int16x4_t *)v79.i8, *(int16x4_t *)(a3 + 192)), vmull_high_s16(v79, *(int16x8_t *)(a3 + 192)))));
        int32x4_t v94 = vaddq_s32(v88, vpaddq_s32(vmull_s16(*(int16x4_t *)v92.i8, *(int16x4_t *)(a3 + 272)), vmull_high_s16(v92, *(int16x8_t *)(a3 + 272))));
        int16x8_t v95 = vmovl_s8(*(int8x8_t *)v90.i8);
        int32x4_t v96 = vaddq_s32(v87, vaddq_s32(v82, v83));
        int16x8_t v97 = vmovl_high_s8(v90);
        int32x4_t v98 = vpaddq_s32(vaddq_s32(v93, vaddq_s32(vaddq_s32(vpaddq_s32(vmull_s16(*(int16x4_t *)v84.i8, *(int16x4_t *)(a3 + 224)), vmull_high_s16(v84, *(int16x8_t *)(a3 + 224))), vpaddq_s32(vmull_s16(*(int16x4_t *)v91.i8, *(int16x4_t *)(a3 + 256)), vmull_high_s16(v91, *(int16x8_t *)(a3 + 256)))), vpaddq_s32(vmull_s16(*(int16x4_t *)v95.i8, *(int16x4_t *)(a3 + 288)), vmull_high_s16(v95, *(int16x8_t *)(a3 + 288))))), vaddq_s32(v96, vaddq_s32(v94, vpaddq_s32(vmull_s16(*(int16x4_t *)v97.i8, *(int16x4_t *)(a3 + 304)),
                      vmull_high_s16(v97, *(int16x8_t *)(a3 + 304))))));
        int32x4_t v99 = vpaddq_s32(v98, v98);
        float v100 = *v23++;
        *a6++ = (float)((float)-(float)(v100 * a7) * (float)vpaddq_s32(v99, v99).i32[0]) + 1.0;
        v24 += 160;
        --v14;
      }
      while (v14);
    }
  }
  else if (v14)
  {
    unsigned int v101 = 0;
    uint64_t v102 = 0;
    uint64_t v103 = v116;
    do
    {
      if (v15)
      {
        uint64_t v104 = 0;
        int32x4_t v105 = 0uLL;
        int32x4_t v106 = 0uLL;
        float v107 = (int16x8_t *)a3;
        do
        {
          int8x16_t v108 = *(int8x16_t *)(v103 + v101 + v104);
          int16x8_t v109 = vmovl_s8(*(int8x8_t *)v108.i8);
          int16x8_t v110 = *v107;
          int16x8_t v111 = v107[1];
          v107 += 2;
          int16x8_t v112 = vmovl_high_s8(v108);
          int32x4_t v105 = vaddq_s32(vpaddq_s32(vmull_s16(*(int16x4_t *)v109.i8, *(int16x4_t *)v110.i8), vmull_high_s16(v109, v110)), v105);
          int32x4_t v106 = vaddq_s32(vpaddq_s32(vmull_s16(*(int16x4_t *)v112.i8, *(int16x4_t *)v111.i8), vmull_high_s16(v112, v111)), v106);
          v104 += 16;
        }
        while (v104 < v15);
      }
      else
      {
        int32x4_t v106 = 0uLL;
        int32x4_t v105 = 0uLL;
      }
      int32x4_t v113 = vpaddq_s32(v105, v106);
      int32x4_t v114 = vpaddq_s32(v113, v113);
      a6[v102] = (float)((float)-(float)(v23[v102] * a7) * (float)vpaddq_s32(v114, v114).i32[0]) + 1.0;
      ++v102;
      v101 += v15;
    }
    while (v102 != v14);
  }
  if (*(_DWORD *)(a1 + 1524) == 1) {
    return brk_DataUnmap(*(void *)(a2 + 24), *(void *)(a1 + 2464), v116);
  }
  return result;
}

uint64_t mfs_bnfData_Distance_Unit_ID_fxd16_SIMD(uint64_t result, uint64_t a2, int16x8_t *a3, unsigned int a4)
{
  uint64_t v6 = result;
  uint64_t v22 = 0;
  uint64_t v7 = *(unsigned __int8 *)(result + 1520);
  if (*(_DWORD *)(result + 1524) == 1)
  {
    uint64_t result = brk_DataMap(*(void *)(a2 + 24), *(void *)(result + 2464), (*(_DWORD *)(result + 1528)+ *(_DWORD *)(*(void *)(result + 848)+ 4 * (a4 / *(_DWORD *)(*(void *)(result + 568) + 5992)))* v7), v7, (uint64_t)&v22);
    if ((result & 0x80000000) != 0) {
      return UNICORN__log_select_Error(a2, 74001, (uint64_t)"ODLBNF DataMap (%u,%u) Error %x", v8, v9, v10, v11, v12);
    }
    uint64_t v13 = v22;
  }
  else
  {
    uint64_t v13 = *(void *)(result + 1000)
        + (*(_DWORD *)(*(void *)(result + 848)
                                   + 4 * (a4 / *(_DWORD *)(*(void *)(result + 568) + 5992)))
                       * v7);
    uint64_t v22 = v13;
  }
  if (v7 && v7 != 160)
  {
    uint64_t v14 = 0;
    int32x4_t v15 = 0uLL;
    int32x4_t v16 = 0uLL;
    do
    {
      int8x16_t v17 = *(int8x16_t *)(v13 + v14);
      int16x8_t v18 = vmovl_s8(*(int8x8_t *)v17.i8);
      int16x8_t v19 = *a3;
      int16x8_t v20 = a3[1];
      a3 += 2;
      int16x8_t v21 = vmovl_high_s8(v17);
      int32x4_t v15 = vaddq_s32(vpaddq_s32(vmull_s16(*(int16x4_t *)v18.i8, *(int16x4_t *)v19.i8), vmull_high_s16(v18, v19)), v15);
      int32x4_t v16 = vaddq_s32(vpaddq_s32(vmull_s16(*(int16x4_t *)v21.i8, *(int16x4_t *)v20.i8), vmull_high_s16(v21, v20)), v16);
      v14 += 16;
    }
    while (v14 < v7);
  }
  if (*(_DWORD *)(v6 + 1524) == 1) {
    return brk_DataUnmap(*(void *)(a2 + 24), *(void *)(v6 + 2464), v13);
  }
  return result;
}

uint64_t mfs_bnfData_Clusterize_Block_Distance_RandomProjection_SIMD(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a6;
  uint64_t v10 = a2;
  uint64_t v146 = 0;
  uint64_t v12 = *(unsigned __int8 *)(a1 + 1520);
  float v13 = 3.1416 / (float)((float)v12 * 8.0);
  if (!*(unsigned char *)(a1 + 1520)) {
    float v13 = 0.3927;
  }
  float v145 = v13;
  uint64_t v14 = (void *)(a1 + 8 * ((int)a5 - 2));
  unint64_t v15 = *(unsigned int *)(v14[108] + 4 * a4);
  if (*(_DWORD *)(a1 + 1524) == 1)
  {
    uint64_t v16 = brk_DataMap(*(void *)(a2 + 24), *(void *)(a1 + 2464), (*(_DWORD *)(v14[192] + 4 * a4) + *(_DWORD *)(a1 + 1528)), (v15 * v12), (uint64_t)&v146);
    if ((v16 & 0x80000000) != 0)
    {
      UNICORN__log_select_Error(v10, 74001, (uint64_t)"ODLBNF DataMap (%u,%u) Error %x", a4, a5, a6, a7, a8);
      return v16;
    }
  }
  else
  {
    uint64_t v16 = 0;
    uint64_t v146 = *(int8x16_t **)(v14[134] + 8 * a4);
  }
  HIDWORD(v17) = v12;
  LODWORD(v17) = v12 - 8;
  unsigned int v18 = v15 >> 2;
  switch((v17 >> 3))
  {
    case 0u:
      if (v15 >= 4)
      {
        int16x8_t v19 = v146;
        float64x2_t v20 = vld1q_dup_f64((const double *)a3);
        int16x8_t v21 = (float32x4_t *)v8;
        if (v18 <= 1) {
          unsigned int v22 = 1;
        }
        else {
          unsigned int v22 = v15 >> 2;
        }
        __asm { FMOV            V0.4S, #1.0 }
        float32x4_t v123 = _Q0;
        int8x16_t v128 = (int8x16_t)v20;
        float v118 = v21;
        do
        {
          float32x4_t v140 = vmulq_n_f32(vcvtq_f32_u32((uint32x4_t)vuzp1q_s32((int32x4_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(veorq_s8(*v19, v128))))), (int32x4_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(veorq_s8(*(int8x16_t *)((char *)v19 + 2 * v12), v128))))))), v145);
          float v133 = cosf(v140.f32[1]);
          v28.f32[0] = cosf(v140.f32[0]);
          v28.f32[1] = v133;
          float32x4_t v134 = v28;
          float v29 = cosf(v140.f32[2]);
          float32x4_t v30 = v134;
          v30.f32[2] = v29;
          float32x4_t v135 = v30;
          float v31 = cosf(v140.f32[3]);
          float32x4_t v32 = v135;
          v32.f32[3] = v31;
          *v21++ = vsubq_f32(v123, v32);
          int16x8_t v19 = (int8x16_t *)((char *)v19 + 4 * v12);
          --v22;
        }
        while (v22);
        uint64_t v146 = v19;
        uint64_t v8 = (uint64_t)v118;
      }
      float v33 = v145;
      if ((v15 & 0xFFFFFFFC) < v15)
      {
        int16x8_t v34 = (int8x8_t *)v146;
        int16x8_t v35 = (float *)(v8 + 16 * (v15 >> 2));
        int v36 = v15 - 4 * (v15 >> 2);
        do
        {
          float v37 = cosf(v33* (float)vpaddl_u32(vpaddl_u16(vpaddl_u8((uint8x8_t)vcnt_s8(veor_s8(*(int8x8_t *)a3, *v34))))));
          float v33 = v145;
          *v35++ = 1.0 - v37;
          int16x8_t v34 = (int8x8_t *)((char *)v34 + v12);
          uint64_t v146 = (int8x16_t *)v34;
          --v36;
        }
        while (v36);
      }
      goto LABEL_64;
    case 1u:
      if (v15 >= 4)
      {
        int32x4_t v38 = v146;
        uint64_t v119 = v10;
        if (v18 <= 1) {
          unsigned int v39 = 1;
        }
        else {
          unsigned int v39 = v15 >> 2;
        }
        uint64_t v40 = v8;
        int32x4_t v41 = (float32x2_t *)(v8 + 8);
        __asm { FMOV            V8.2S, #1.0 }
        do
        {
          int32x4_t v43 = v38;
          int64x2_t v44 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(veorq_s8(*(int8x16_t *)a3, *v38)))));
          int64x2_t v45 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(veorq_s8(*(int8x16_t *)((char *)v38 + v12), *(int8x16_t *)a3)))));
          int16x8_t v46 = (int8x16_t *)((char *)v38 + v12 + v12);
          int16x8_t v47 = &v46->i8[v12];
          int64x2_t v136 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(veorq_s8(*(int8x16_t *)((char *)v46 + v12), *(int8x16_t *)a3)))));
          int64x2_t v141 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(veorq_s8(*v46, *(int8x16_t *)a3)))));
          *(float32x2_t *)v44.i8 = vmul_n_f32(vcvt_f32_u32((uint32x2_t)vmovn_s64(vaddq_s64(vzip1q_s64(v44, v45), vzip2q_s64(v44, v45)))), v145);
          float v124 = *(float *)v44.i32;
          float v129 = cosf(*(float *)&v44.i32[1]);
          v48.f32[0] = cosf(v124);
          v48.f32[1] = v129;
          v41[-1] = vsub_f32(_D8, v48);
          float32x2_t v49 = vmul_n_f32(vcvt_f32_u32((uint32x2_t)vmovn_s64(vaddq_s64(vzip1q_s64(v141, v136), vzip2q_s64(v141, v136)))), v145);
          v136.i32[0] = v49.i32[0];
          v141.i32[0] = cosf(v49.f32[1]);
          v50.f32[0] = cosf(*(float *)v136.i32);
          v50.i32[1] = v141.i32[0];
          *int32x4_t v41 = vsub_f32(_D8, v50);
          v41 += 2;
          int32x4_t v38 = (int8x16_t *)&v47[v12];
          --v39;
        }
        while (v39);
        uint64_t v10 = v119;
        uint64_t v146 = (int8x16_t *)((char *)v43 + 4 * v12);
        uint64_t v8 = v40;
      }
      float v51 = v145;
      if ((v15 & 0xFFFFFFFC) >= v15) {
        goto LABEL_64;
      }
      int32x4_t v52 = v146;
      int32x4_t v53 = (float *)(v8 + 16 * (v15 >> 2));
      int v54 = v15 - 4 * (v15 >> 2);
      do
      {
        uint32x4_t v55 = vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(veorq_s8(*(int8x16_t *)a3, *v52))));
        float v56 = cosf(v51 * (float)vpadalq_u32((uint64x2_t)vdupq_laneq_s64((int64x2_t)vpaddlq_u32(v55), 1), v55).u32[0]);
        float v51 = v145;
        *v53++ = 1.0 - v56;
        int32x4_t v52 = (int8x16_t *)((char *)v52 + v12);
        --v54;
      }
      while (v54);
      break;
    case 3u:
      if (v15 >= 4)
      {
        int16x8_t v57 = v146;
        uint64_t v120 = v10;
        if (v18 <= 1) {
          unsigned int v58 = 1;
        }
        else {
          unsigned int v58 = v15 >> 2;
        }
        uint64_t v59 = v8;
        int32x4_t v60 = (float32x2_t *)(v8 + 8);
        __asm { FMOV            V8.2S, #1.0 }
        do
        {
          int32x4_t v62 = v57;
          int8x16_t v63 = *(int8x16_t *)(a3 + 16);
          int8x16_t v64 = (int8x16_t *)((char *)v57 + v12 + v12);
          int32x4_t v65 = &v64->i8[v12];
          int64x2_t v66 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vaddq_s8(vcntq_s8(veorq_s8(v63, v57[1])), vcntq_s8(veorq_s8(*(int8x16_t *)a3, *v57))))));
          int64x2_t v67 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vaddq_s8(vcntq_s8(veorq_s8(*(int8x16_t *)((char *)&v57[1] + v12), v63)), vcntq_s8(veorq_s8(*(int8x16_t *)((char *)v57 + v12), *(int8x16_t *)a3))))));
          int64x2_t v137 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vaddq_s8(vcntq_s8(veorq_s8(*(int8x16_t *)((char *)&v64[1] + v12), v63)), vcntq_s8(veorq_s8(*(int8x16_t *)((char *)v64 + v12), *(int8x16_t *)a3))))));
          int64x2_t v142 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vaddq_s8(vcntq_s8(veorq_s8(v64[1], v63)), vcntq_s8(veorq_s8(*v64, *(int8x16_t *)a3))))));
          *(float32x2_t *)v66.i8 = vmul_n_f32(vcvt_f32_u32((uint32x2_t)vmovn_s64(vaddq_s64(vzip1q_s64(v66, v67), vzip2q_s64(v66, v67)))), v145);
          float v125 = *(float *)v66.i32;
          float v130 = cosf(*(float *)&v66.i32[1]);
          v68.f32[0] = cosf(v125);
          v68.f32[1] = v130;
          v60[-1] = vsub_f32(_D8, v68);
          float32x2_t v69 = vmul_n_f32(vcvt_f32_u32((uint32x2_t)vmovn_s64(vaddq_s64(vzip1q_s64(v142, v137), vzip2q_s64(v142, v137)))), v145);
          v137.i32[0] = v69.i32[0];
          v142.i32[0] = cosf(v69.f32[1]);
          v70.f32[0] = cosf(*(float *)v137.i32);
          v70.i32[1] = v142.i32[0];
          *int32x4_t v60 = vsub_f32(_D8, v70);
          v60 += 2;
          int16x8_t v57 = (int8x16_t *)&v65[v12];
          --v58;
        }
        while (v58);
        uint64_t v10 = v120;
        uint64_t v146 = (int8x16_t *)((char *)v62 + 4 * v12);
        uint64_t v8 = v59;
      }
      float v71 = v145;
      if ((v15 & 0xFFFFFFFC) >= v15) {
        goto LABEL_64;
      }
      int32x4_t v52 = v146;
      int16x8_t v72 = (float *)(v8 + 16 * (v15 >> 2));
      int v73 = v15 - 4 * (v15 >> 2);
      do
      {
        uint32x4_t v74 = vpaddlq_u16(vpaddlq_u8((uint8x16_t)vaddq_s8(vcntq_s8(veorq_s8(*(int8x16_t *)(a3 + 16), v52[1])), vcntq_s8(veorq_s8(*(int8x16_t *)a3, *v52)))));
        float v75 = cosf(v71 * (float)vpadalq_u32((uint64x2_t)vdupq_laneq_s64((int64x2_t)vpaddlq_u32(v74), 1), v74).u32[0]);
        float v71 = v145;
        *v72++ = 1.0 - v75;
        int32x4_t v52 = (int8x16_t *)((char *)v52 + v12);
        --v73;
      }
      while (v73);
      break;
    case 5u:
      if (v15 >= 4)
      {
        int32x4_t v76 = v146;
        uint64_t v121 = v10;
        if (v18 <= 1) {
          unsigned int v77 = 1;
        }
        else {
          unsigned int v77 = v15 >> 2;
        }
        uint64_t v78 = v8;
        int16x8_t v79 = (float32x2_t *)(v8 + 8);
        __asm { FMOV            V8.2S, #1.0 }
        do
        {
          int32x4_t v81 = v76;
          int8x16_t v82 = *(int8x16_t *)(a3 + 16);
          int8x16_t v83 = *(int8x16_t *)(a3 + 32);
          int64x2_t v84 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vaddq_s8(vaddq_s8(vcntq_s8(veorq_s8(v82, v76[1])), vcntq_s8(veorq_s8(*(int8x16_t *)a3, *v76))), vcntq_s8(veorq_s8(v83, v76[2]))))));
          int64x2_t v85 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vaddq_s8(vaddq_s8(vcntq_s8(veorq_s8(*(int8x16_t *)((char *)&v76[1] + v12), v82)), vcntq_s8(veorq_s8(*(int8x16_t *)((char *)v76 + v12), *(int8x16_t *)a3))), vcntq_s8(veorq_s8(*(int8x16_t *)((char *)&v76[2] + v12), v83))))));
          int32x4_t v86 = (int8x16_t *)((char *)v76 + v12 + v12);
          int32x4_t v87 = &v86->i8[v12];
          int64x2_t v138 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vaddq_s8(vaddq_s8(vcntq_s8(veorq_s8(*(int8x16_t *)((char *)&v86[1] + v12), v82)), vcntq_s8(veorq_s8(*(int8x16_t *)((char *)v86 + v12), *(int8x16_t *)a3))), vcntq_s8(veorq_s8(*(int8x16_t *)((char *)&v86[2] + v12), v83))))));
          int64x2_t v143 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vaddq_s8(vaddq_s8(vcntq_s8(veorq_s8(v86[1], v82)), vcntq_s8(veorq_s8(*v86, *(int8x16_t *)a3))), vcntq_s8(veorq_s8(v86[2], v83))))));
          *(float32x2_t *)v84.i8 = vmul_n_f32(vcvt_f32_u32((uint32x2_t)vmovn_s64(vaddq_s64(vzip1q_s64(v84, v85), vzip2q_s64(v84, v85)))), v145);
          float v126 = *(float *)v84.i32;
          float v131 = cosf(*(float *)&v84.i32[1]);
          v88.f32[0] = cosf(v126);
          v88.f32[1] = v131;
          v79[-1] = vsub_f32(_D8, v88);
          float32x2_t v89 = vmul_n_f32(vcvt_f32_u32((uint32x2_t)vmovn_s64(vaddq_s64(vzip1q_s64(v143, v138), vzip2q_s64(v143, v138)))), v145);
          v138.i32[0] = v89.i32[0];
          v143.i32[0] = cosf(v89.f32[1]);
          v90.f32[0] = cosf(*(float *)v138.i32);
          v90.i32[1] = v143.i32[0];
          *int16x8_t v79 = vsub_f32(_D8, v90);
          v79 += 2;
          int32x4_t v76 = (int8x16_t *)&v87[v12];
          --v77;
        }
        while (v77);
        uint64_t v10 = v121;
        uint64_t v146 = (int8x16_t *)((char *)v81 + 4 * v12);
        uint64_t v8 = v78;
      }
      float v91 = v145;
      if ((v15 & 0xFFFFFFFC) >= v15) {
        goto LABEL_64;
      }
      int32x4_t v52 = v146;
      int16x8_t v92 = (float *)(v8 + 16 * (v15 >> 2));
      int v93 = v15 - 4 * (v15 >> 2);
      do
      {
        uint32x4_t v94 = vpaddlq_u16(vpaddlq_u8((uint8x16_t)vaddq_s8(vaddq_s8(vcntq_s8(veorq_s8(*(int8x16_t *)(a3 + 16), v52[1])), vcntq_s8(veorq_s8(*(int8x16_t *)a3, *v52))), vcntq_s8(veorq_s8(*(int8x16_t *)(a3 + 32), v52[2])))));
        float v95 = cosf(v91 * (float)vpadalq_u32((uint64x2_t)vdupq_laneq_s64((int64x2_t)vpaddlq_u32(v94), 1), v94).u32[0]);
        float v91 = v145;
        *v92++ = 1.0 - v95;
        int32x4_t v52 = (int8x16_t *)((char *)v52 + v12);
        --v93;
      }
      while (v93);
      break;
    case 7u:
      if (v15 >= 4)
      {
        int32x4_t v96 = v146;
        uint64_t v122 = v10;
        if (v18 <= 1) {
          unsigned int v97 = 1;
        }
        else {
          unsigned int v97 = v15 >> 2;
        }
        uint64_t v98 = v8;
        int32x4_t v99 = (float32x2_t *)(v8 + 8);
        __asm { FMOV            V8.2S, #1.0 }
        do
        {
          unsigned int v101 = v96;
          int8x16_t v102 = *(int8x16_t *)(a3 + 16);
          int8x16_t v103 = *(int8x16_t *)(a3 + 32);
          int8x16_t v104 = *(int8x16_t *)(a3 + 48);
          int64x2_t v105 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vaddq_s8(vaddq_s8(vcntq_s8(veorq_s8(v102, v96[1])), vcntq_s8(veorq_s8(*(int8x16_t *)a3, *v96))), vaddq_s8(vcntq_s8(veorq_s8(v103, v96[2])), vcntq_s8(veorq_s8(v104, v96[3])))))));
          int64x2_t v106 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vaddq_s8(vaddq_s8(vcntq_s8(veorq_s8(*(int8x16_t *)((char *)&v96[1] + v12), v102)), vcntq_s8(veorq_s8(*(int8x16_t *)((char *)v96 + v12), *(int8x16_t *)a3))), vaddq_s8(vcntq_s8(veorq_s8(*(int8x16_t *)((char *)&v96[2] + v12), v103)), vcntq_s8(veorq_s8(*(int8x16_t *)((char *)&v96[3] + v12), v104)))))));
          float v107 = (int8x16_t *)((char *)v96 + v12 + v12);
          int64x2_t v144 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vaddq_s8(vaddq_s8(vcntq_s8(veorq_s8(v107[1], v102)), vcntq_s8(veorq_s8(*v107, *(int8x16_t *)a3))), vaddq_s8(vcntq_s8(veorq_s8(v107[2], v103)), vcntq_s8(veorq_s8(v107[3], v104)))))));
          int8x16_t v108 = &v107->i8[v12];
          int64x2_t v139 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vaddq_s8(vaddq_s8(vcntq_s8(veorq_s8(*(int8x16_t *)((char *)&v107[1] + v12), v102)), vcntq_s8(veorq_s8(*(int8x16_t *)((char *)v107 + v12), *(int8x16_t *)a3))), vaddq_s8(vcntq_s8(veorq_s8(*(int8x16_t *)((char *)&v107[2] + v12), v103)), vcntq_s8(veorq_s8(*(int8x16_t *)((char *)&v107[3] + v12), v104)))))));
          *(float32x2_t *)v105.i8 = vmul_n_f32(vcvt_f32_u32((uint32x2_t)vmovn_s64(vaddq_s64(vzip1q_s64(v105, v106), vzip2q_s64(v105, v106)))), v145);
          float v127 = *(float *)v105.i32;
          float v132 = cosf(*(float *)&v105.i32[1]);
          v109.f32[0] = cosf(v127);
          v109.f32[1] = v132;
          v99[-1] = vsub_f32(_D8, v109);
          float32x2_t v110 = vmul_n_f32(vcvt_f32_u32((uint32x2_t)vmovn_s64(vaddq_s64(vzip1q_s64(v144, v139), vzip2q_s64(v144, v139)))), v145);
          v139.i32[0] = v110.i32[0];
          v144.i32[0] = cosf(v110.f32[1]);
          v111.f32[0] = cosf(*(float *)v139.i32);
          v111.i32[1] = v144.i32[0];
          *int32x4_t v99 = vsub_f32(_D8, v111);
          v99 += 2;
          int32x4_t v96 = (int8x16_t *)&v108[v12];
          --v97;
        }
        while (v97);
        uint64_t v10 = v122;
        uint64_t v146 = (int8x16_t *)((char *)v101 + 4 * v12);
        uint64_t v8 = v98;
      }
      float v112 = v145;
      if ((v15 & 0xFFFFFFFC) >= v15) {
        goto LABEL_64;
      }
      int32x4_t v52 = v146;
      int32x4_t v113 = (float *)(v8 + 16 * (v15 >> 2));
      int v114 = v15 - 4 * (v15 >> 2);
      do
      {
        uint32x4_t v115 = vpaddlq_u16(vpaddlq_u8((uint8x16_t)vaddq_s8(vaddq_s8(vcntq_s8(veorq_s8(*(int8x16_t *)(a3 + 16), v52[1])), vcntq_s8(veorq_s8(*(int8x16_t *)a3, *v52))), vaddq_s8(vcntq_s8(veorq_s8(*(int8x16_t *)(a3 + 32), v52[2])), vcntq_s8(veorq_s8(*(int8x16_t *)(a3 + 48), v52[3]))))));
        float v116 = cosf(v112 * (float)vpadalq_u32((uint64x2_t)vdupq_laneq_s64((int64x2_t)vpaddlq_u32(v115), 1), v115).u32[0]);
        float v112 = v145;
        *v113++ = 1.0 - v116;
        int32x4_t v52 = (int8x16_t *)((char *)v52 + v12);
        --v114;
      }
      while (v114);
      break;
    default:
      UNICORN__log_select_Error(v10, 74001, (uint64_t)"Unsupported BNF size %d", a4, a5, a6, a7, a8);
      return 2229280769;
  }
  uint64_t v146 = v52;
LABEL_64:
  if (*(_DWORD *)(a1 + 1524) == 1) {
    return brk_DataUnmap(*(void *)(v10 + 24), *(void *)(a1 + 2464), (uint64_t)v146);
  }
  return v16;
}

void mfs_bnfData_Distance_Unit_ID_RandomProjection_SIMD(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(unsigned __int8 *)(a1 + 1520);
  uint64_t v18 = 0;
  if (v11) {
    float v12 = 3.1416 / (float)((float)v11 * 8.0);
  }
  else {
    float v12 = 0.3927;
  }
  if (*(_DWORD *)(a1 + 1524) == 1)
  {
    if ((brk_DataMap(*(void *)(a2 + 24), *(void *)(a1 + 2464), (*(_DWORD *)(a1 + 1528)+ *(_DWORD *)(*(void *)(a1 + 848)+ 4 * (a4 / *(_DWORD *)(*(void *)(a1 + 568) + 5992)))* v11), v11, (uint64_t)&v18) & 0x80000000) != 0)
    {
      UNICORN__log_select_Error(a2, 74001, (uint64_t)"ODLBNF DataMap (%u,%u) Error %x", a4, a5, a6, a7, a8);
      return;
    }
  }
  else
  {
    uint64_t v18 = *(void *)(a1 + 1000)
        + (*(_DWORD *)(*(void *)(a1 + 848)
                                   + 4 * (a4 / *(_DWORD *)(*(void *)(a1 + 568) + 5992)))
                       * v11);
  }
  HIDWORD(v13) = v11;
  LODWORD(v13) = v11 - 8;
  switch((v13 >> 3))
  {
    case 0u:
      uint64_t v14 = v18;
      unsigned int v15 = vpaddl_u32(vpaddl_u16(vpaddl_u8((uint8x8_t)vcnt_s8(veor_s8(*(int8x8_t *)a3, *(int8x8_t *)v18)))));
      goto LABEL_16;
    case 1u:
      uint64_t v14 = v18;
      uint8x16_t v16 = (uint8x16_t)vcntq_s8(veorq_s8(*(int8x16_t *)a3, *(int8x16_t *)v18));
      goto LABEL_15;
    case 3u:
      uint64_t v14 = v18;
      uint8x16_t v16 = (uint8x16_t)vaddq_s8(vcntq_s8(veorq_s8(*(int8x16_t *)(a3 + 16), *(int8x16_t *)(v18 + 16))), vcntq_s8(veorq_s8(*(int8x16_t *)a3, *(int8x16_t *)v18)));
      goto LABEL_15;
    case 5u:
      uint64_t v14 = v18;
      uint8x16_t v16 = (uint8x16_t)vaddq_s8(vaddq_s8(vcntq_s8(veorq_s8(*(int8x16_t *)(a3 + 16), *(int8x16_t *)(v18 + 16))), vcntq_s8(veorq_s8(*(int8x16_t *)a3, *(int8x16_t *)v18))), vcntq_s8(veorq_s8(*(int8x16_t *)(a3 + 32), *(int8x16_t *)(v18 + 32))));
      goto LABEL_15;
    case 7u:
      uint64_t v14 = v18;
      uint8x16_t v16 = (uint8x16_t)vaddq_s8(vaddq_s8(vcntq_s8(veorq_s8(*(int8x16_t *)(a3 + 16), *(int8x16_t *)(v18 + 16))), vcntq_s8(veorq_s8(*(int8x16_t *)a3, *(int8x16_t *)v18))), vaddq_s8(vcntq_s8(veorq_s8(*(int8x16_t *)(a3 + 32), *(int8x16_t *)(v18 + 32))), vcntq_s8(veorq_s8(*(int8x16_t *)(a3 + 48), *(int8x16_t *)(v18 + 48)))));
LABEL_15:
      uint32x4_t v17 = vpaddlq_u16(vpaddlq_u8(v16));
      unsigned int v15 = vpadalq_u32((uint64x2_t)vdupq_laneq_s64((int64x2_t)vpaddlq_u32(v17), 1), v17).u32[0];
LABEL_16:
      cosf(v12 * (float)v15);
      if (*(_DWORD *)(a1 + 1524) == 1) {
        brk_DataUnmap(*(void *)(a2 + 24), *(void *)(a1 + 2464), v14);
      }
      break;
    default:
      UNICORN__log_select_Error(a2, 74001, (uint64_t)"Unsupported BNF size %d", a4, a5, a6, a7, a8);
      break;
  }
}

uint64_t precomp_DoInnerLoop_simd_full_support(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v68 = *MEMORY[0x263EF8340];
  uint64_t v7 = *a2;
  uint64_t v8 = a4;
  uint64_t v9 = (__int32 *)(*a2 + 24 * a4);
  v67.i32[0] = *v9;
  v67.i32[1] = v9[6];
  v67.i32[2] = v9[12];
  v67.i32[3] = v9[18];
  int32x4_t v65 = v67;
  v66[0] = v9[1];
  v66[1] = v9[7];
  v66[2] = v9[13];
  v66[3] = v9[19];
  precomp_FetchRightNode(a1, a5, v67.i32, v66, 4);
  int v12 = *(_DWORD *)(a1 + 1088);
  uint64_t v13 = *(void *)(a1 + 128);
  uint64_t v14 = *(void *)(a1 + 136);
  int8x16_t v15 = 0uLL;
  uint64_t v16 = *(void *)(a1 + 144);
  uint64_t v17 = *(void *)(a1 + 152);
  if (v12)
  {
    v10.i32[0] = *(_DWORD *)(*(void *)(a1 + 40) + 6720);
    v11.i32[0] = 998277249;
    uint64_t v18 = *(void *)(a1 + 152);
    uint64_t v19 = *(void *)(a1 + 144);
    uint64_t v20 = *(void *)(a1 + 136);
    uint64_t v21 = *(void *)(a1 + 128);
    float32x4_t v22 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmulq_f32(v10, v11), 0);
    uint64_t v17 = 0;
    uint64_t v16 = 0;
    uint64_t v14 = 0;
    uint64_t v13 = 0;
  }
  else
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    float32x4_t v22 = 0uLL;
  }
  uint64_t v23 = *(unsigned int *)(a3 + 12);
  uint64_t v24 = *(const float **)a3;
  if ((int)v23 < 1)
  {
    float32x4_t v28 = (float32x4_t)vdupq_n_s32(0x4B189680u);
  }
  else
  {
    uint64_t v25 = 0;
    v26.i64[0] = -1;
    v26.i64[1] = -1;
    int32x4_t v27 = vaddq_s32(v65, v26);
    float32x4_t v28 = (float32x4_t)vdupq_n_s32(0x4B189680u);
    int8x16_t v15 = 0uLL;
    float v29 = *(const float **)a3;
    do
    {
      float32x4_t v30 = v29 + 3;
      float32x4_t v31 = vld1q_dup_f32(v30);
      int8x8_t v32 = (int8x8_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32(v28, v31))), 0xFuLL));
      v32.i16[0] = vminv_u16((uint16x4_t)v32);
      if (v32.i8[0]) {
        break;
      }
      uint64_t v33 = *(unsigned int *)(*(void *)(a1 + 1032) + 4 * v25);
      if (v12)
      {
        v32.i8[0] = *(unsigned char *)(v19 + v33);
        v32.i8[4] = *(unsigned char *)(v18 + v33);
        v34.i32[0] = *(unsigned __int8 *)(v21 + v33);
        v34.i32[1] = *(unsigned __int8 *)(v20 + v33);
        v34.u64[1] = (unint64_t)vand_s8(v32, (int8x8_t)0xFF000000FFLL);
        float32x4_t v35 = vmulq_f32(v22, vcvtq_f32_u32(v34));
      }
      else
      {
        v35.i32[0] = *(_DWORD *)(v13 + 4 * v33);
        v35.i32[1] = *(_DWORD *)(v14 + 4 * v33);
        v35.i32[2] = *(_DWORD *)(v16 + 4 * v33);
        v35.i32[3] = *(_DWORD *)(v17 + 4 * v33);
      }
      int v36 = (const float *)(*(void *)(a1 + 1008) + 4 * v25);
      int32x4_t v37 = (int32x4_t)vld1q_dup_f32(v36);
      int32x4_t v38 = vsubq_s32(*(int32x4_t *)(a1 + 384), v37);
      unsigned int v39 = (const float *)(*(void *)(a1 + 16) + 6664);
      int32x4_t v40 = (int32x4_t)vld1q_dup_f32(v39);
      int32x4_t v41 = vabsq_s32(v38);
      int32x4_t v42 = (const float *)(a1 + 112);
      int32x4_t v43 = (int32x4_t)vld1q_dup_f32(v42);
      int32x4_t v44 = vabsq_s32(vsubq_s32(v43, v38));
      int64x2_t v45 = (const float *)(a1 + 1060);
      int32x4_t v46 = (int32x4_t)vld1q_dup_f32(v45);
      int8x16_t v47 = (int8x16_t)vcgtq_s32(v40, v41);
      float32x2_t v48 = (const float *)(*(void *)(a1 + 1024) + 4 * v25);
      float32x4_t v49 = vld1q_dup_f32(v48);
      float32x4_t v50 = (float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_s32(v44, v46), *(int8x16_t *)(a1 + 832), (int8x16_t)vmulq_f32(*(float32x4_t *)(a1 + 704), vaddq_f32(v35, v49))), v47);
      if (*(void *)(a1 + 32) == *(void *)(a1 + 48) || *(void *)(a1 + 104))
      {
        uint64_t v51 = *(unsigned int *)(*(void *)(a1 + 1000) + 4 * v25);
        v52.i32[0] = *(_DWORD *)(*(void *)(a1 + 256) + 4 * v51);
        v52.i32[1] = *(_DWORD *)(*(void *)(a1 + 264) + 4 * v51);
        v52.i32[2] = *(_DWORD *)(*(void *)(a1 + 272) + 4 * v51);
        v52.i32[3] = *(_DWORD *)(*(void *)(a1 + 280) + 4 * v51);
        int32x4_t v53 = (const float *)(*(void *)(a1 + 1016) + 4 * v25);
        float32x4_t v54 = vld1q_dup_f32(v53);
        float32x4_t v50 = vaddq_f32(vmulq_f32(*(float32x4_t *)(a1 + 768), vaddq_f32(*(float32x4_t *)(a1 + 576), vaddq_f32(v52, v54))), v50);
      }
      int32x4_t v55 = (int32x4_t)vld1q_dup_f32(v29);
      float v56 = (const float *)(*(void *)(a1 + 1040) + 4 * v25);
      float32x4_t v57 = vld1q_dup_f32(v56);
      float32x4_t v58 = vaddq_f32(v31, (float32x4_t)vbicq_s8((int8x16_t)vaddq_f32(vaddq_f32(v50, *(float32x4_t *)(a1 + 640)), (float32x4_t)vandq_s8(*(int8x16_t *)(a1 + 896), (int8x16_t)vmulq_n_f32(vabdq_f32(*(float32x4_t *)(a1 + 512), v57), *(float *)(*(void *)(a1 + 1048) + 4 * v25)))), (int8x16_t)vceqq_s32(v55, v27)));
      int8x16_t v59 = (int8x16_t)vcgtq_f32(v28, v58);
      float32x4_t v28 = (float32x4_t)vbslq_s8(v59, (int8x16_t)v58, (int8x16_t)v28);
      int8x16_t v15 = vbslq_s8(v59, (int8x16_t)vdupq_n_s32(v25++), v15);
      v29 += 6;
    }
    while (v23 != v25);
  }
  uint64_t v60 = v7 + 24 * (int)v8;
  *(float *)(v60 + 12) = v28.f32[0] + *(float *)(v60 + 12);
  *(void *)(v60 + 16) = &v24[6 * v15.i32[0]];
  if (v24) {
    ++LODWORD(v24[6 * v15.i32[0] + 2]);
  }
  uint64_t v61 = v7 + 24 * (v8 + 1);
  *(float *)(v61 + 12) = v28.f32[1] + *(float *)(v61 + 12);
  *(void *)(v61 + 16) = &v24[6 * v15.i32[1]];
  if (v24) {
    ++LODWORD(v24[6 * v15.i32[1] + 2]);
  }
  uint64_t v62 = v7 + 24 * (v8 + 2);
  *(float *)(v62 + 12) = v28.f32[2] + *(float *)(v62 + 12);
  *(void *)(v62 + 16) = &v24[6 * v15.i32[2]];
  if (v24) {
    ++LODWORD(v24[6 * v15.i32[2] + 2]);
  }
  uint64_t v63 = v7 + 24 * (v8 + 3);
  *(float *)(v63 + 12) = v28.f32[3] + *(float *)(v63 + 12);
  *(void *)(v63 + 16) = &v24[6 * v15.i32[3]];
  if (v24) {
    ++LODWORD(v24[6 * v15.i32[3] + 2]);
  }
  return 0;
}

uint64_t precomp_DoInnerLoop_simd_nosylrate(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  uint64_t v7 = *a2;
  uint64_t v8 = a4;
  uint64_t v9 = (__int32 *)(*a2 + 24 * a4);
  v65.i32[0] = *v9;
  v65.i32[1] = v9[6];
  v65.i32[2] = v9[12];
  v65.i32[3] = v9[18];
  int32x4_t v63 = v65;
  v64[0] = v9[1];
  v64[1] = v9[7];
  v64[2] = v9[13];
  v64[3] = v9[19];
  precomp_FetchRightNode(a1, a5, v65.i32, v64, 4);
  int v12 = *(_DWORD *)(a1 + 1088);
  uint64_t v13 = *(void *)(a1 + 128);
  uint64_t v14 = *(void *)(a1 + 136);
  int8x16_t v15 = 0uLL;
  uint64_t v16 = *(void *)(a1 + 144);
  uint64_t v17 = *(void *)(a1 + 152);
  if (v12)
  {
    v10.i32[0] = *(_DWORD *)(*(void *)(a1 + 40) + 6720);
    v11.i32[0] = 998277249;
    uint64_t v18 = *(void *)(a1 + 152);
    uint64_t v19 = *(void *)(a1 + 144);
    uint64_t v20 = *(void *)(a1 + 136);
    uint64_t v21 = *(void *)(a1 + 128);
    float32x4_t v22 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmulq_f32(v10, v11), 0);
    uint64_t v17 = 0;
    uint64_t v16 = 0;
    uint64_t v14 = 0;
    uint64_t v13 = 0;
  }
  else
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    float32x4_t v22 = 0uLL;
  }
  uint64_t v23 = *(unsigned int *)(a3 + 12);
  uint64_t v24 = *(const float **)a3;
  if ((int)v23 < 1)
  {
    float32x4_t v28 = (float32x4_t)vdupq_n_s32(0x4B189680u);
  }
  else
  {
    uint64_t v25 = 0;
    v26.i64[0] = -1;
    v26.i64[1] = -1;
    int32x4_t v27 = vaddq_s32(v63, v26);
    float32x4_t v28 = (float32x4_t)vdupq_n_s32(0x4B189680u);
    int8x16_t v15 = 0uLL;
    float v29 = *(const float **)a3;
    do
    {
      float32x4_t v30 = v29 + 3;
      float32x4_t v31 = vld1q_dup_f32(v30);
      int8x8_t v32 = (int8x8_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32(v28, v31))), 0xFuLL));
      v32.i16[0] = vminv_u16((uint16x4_t)v32);
      if (v32.i8[0]) {
        break;
      }
      uint64_t v33 = *(unsigned int *)(*(void *)(a1 + 1032) + 4 * v25);
      if (v12)
      {
        v32.i8[0] = *(unsigned char *)(v19 + v33);
        v32.i8[4] = *(unsigned char *)(v18 + v33);
        v34.i32[0] = *(unsigned __int8 *)(v21 + v33);
        v34.i32[1] = *(unsigned __int8 *)(v20 + v33);
        v34.u64[1] = (unint64_t)vand_s8(v32, (int8x8_t)0xFF000000FFLL);
        float32x4_t v35 = vmulq_f32(v22, vcvtq_f32_u32(v34));
      }
      else
      {
        v35.i32[0] = *(_DWORD *)(v13 + 4 * v33);
        v35.i32[1] = *(_DWORD *)(v14 + 4 * v33);
        v35.i32[2] = *(_DWORD *)(v16 + 4 * v33);
        v35.i32[3] = *(_DWORD *)(v17 + 4 * v33);
      }
      int v36 = (const float *)(*(void *)(a1 + 1008) + 4 * v25);
      int32x4_t v37 = (int32x4_t)vld1q_dup_f32(v36);
      int32x4_t v38 = vsubq_s32(*(int32x4_t *)(a1 + 384), v37);
      unsigned int v39 = (const float *)(*(void *)(a1 + 16) + 6664);
      int32x4_t v40 = (int32x4_t)vld1q_dup_f32(v39);
      int32x4_t v41 = vabsq_s32(v38);
      int32x4_t v42 = (const float *)(a1 + 112);
      int32x4_t v43 = (int32x4_t)vld1q_dup_f32(v42);
      int32x4_t v44 = vabsq_s32(vsubq_s32(v43, v38));
      int64x2_t v45 = (const float *)(a1 + 1060);
      int32x4_t v46 = (int32x4_t)vld1q_dup_f32(v45);
      int8x16_t v47 = (int8x16_t)vcgtq_s32(v40, v41);
      float32x2_t v48 = (const float *)(*(void *)(a1 + 1024) + 4 * v25);
      float32x4_t v49 = vld1q_dup_f32(v48);
      float32x4_t v50 = (float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_s32(v44, v46), *(int8x16_t *)(a1 + 832), (int8x16_t)vmulq_f32(*(float32x4_t *)(a1 + 704), vaddq_f32(v35, v49))), v47);
      if (*(void *)(a1 + 32) == *(void *)(a1 + 48) || *(void *)(a1 + 104))
      {
        uint64_t v51 = *(unsigned int *)(*(void *)(a1 + 1000) + 4 * v25);
        v52.i32[0] = *(_DWORD *)(*(void *)(a1 + 256) + 4 * v51);
        v52.i32[1] = *(_DWORD *)(*(void *)(a1 + 264) + 4 * v51);
        v52.i32[2] = *(_DWORD *)(*(void *)(a1 + 272) + 4 * v51);
        v52.i32[3] = *(_DWORD *)(*(void *)(a1 + 280) + 4 * v51);
        int32x4_t v53 = (const float *)(*(void *)(a1 + 1016) + 4 * v25);
        float32x4_t v54 = vld1q_dup_f32(v53);
        float32x4_t v50 = vaddq_f32(vmulq_f32(*(float32x4_t *)(a1 + 768), vaddq_f32(*(float32x4_t *)(a1 + 576), vaddq_f32(v52, v54))), v50);
      }
      int32x4_t v55 = (int32x4_t)vld1q_dup_f32(v29);
      float32x4_t v56 = vaddq_f32(v31, (float32x4_t)vbicq_s8((int8x16_t)vaddq_f32(v50, *(float32x4_t *)(a1 + 640)), (int8x16_t)vceqq_s32(v55, v27)));
      int8x16_t v57 = (int8x16_t)vcgtq_f32(v28, v56);
      float32x4_t v28 = (float32x4_t)vbslq_s8(v57, (int8x16_t)v56, (int8x16_t)v28);
      int8x16_t v15 = vbslq_s8(v57, (int8x16_t)vdupq_n_s32(v25++), v15);
      v29 += 6;
    }
    while (v23 != v25);
  }
  uint64_t v58 = v7 + 24 * (int)v8;
  *(float *)(v58 + 12) = v28.f32[0] + *(float *)(v58 + 12);
  *(void *)(v58 + 16) = &v24[6 * v15.i32[0]];
  if (v24) {
    ++LODWORD(v24[6 * v15.i32[0] + 2]);
  }
  uint64_t v59 = v7 + 24 * (v8 + 1);
  *(float *)(v59 + 12) = v28.f32[1] + *(float *)(v59 + 12);
  *(void *)(v59 + 16) = &v24[6 * v15.i32[1]];
  if (v24) {
    ++LODWORD(v24[6 * v15.i32[1] + 2]);
  }
  uint64_t v60 = v7 + 24 * (v8 + 2);
  *(float *)(v60 + 12) = v28.f32[2] + *(float *)(v60 + 12);
  *(void *)(v60 + 16) = &v24[6 * v15.i32[2]];
  if (v24) {
    ++LODWORD(v24[6 * v15.i32[2] + 2]);
  }
  uint64_t v61 = v7 + 24 * (v8 + 3);
  *(float *)(v61 + 12) = v28.f32[3] + *(float *)(v61 + 12);
  *(void *)(v61 + 16) = &v24[6 * v15.i32[3]];
  if (v24) {
    ++LODWORD(v24[6 * v15.i32[3] + 2]);
  }
  return 0;
}

uint64_t precomp_DoInnerLoop_T_simd_nosylrate(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v78 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = *(void *)(v7 + 1640);
  int v9 = *(_DWORD *)(v7 + 1652);
  uint64_t v10 = *a2;
  uint64_t v11 = a4;
  int v12 = (__int32 *)(*a2 + 24 * a4);
  v77.i32[0] = *v12;
  v77.i32[1] = v12[6];
  v77.i32[2] = v12[12];
  v77.i32[3] = v12[18];
  int32x4_t v75 = v77;
  v76[0] = v12[1];
  v76[1] = v12[7];
  v76[2] = v12[13];
  v76[3] = v12[19];
  precomp_FetchRightNode(a1, a5, v77.i32, v76, 4);
  int v16 = *(_DWORD *)(a1 + 1088);
  uint64_t v17 = *(void *)(v7 + 2424);
  uint64_t v18 = *(_DWORD **)(a1 + 1032);
  int v19 = *(_DWORD *)(v7 + 2436);
  uint64_t v20 = (v19 * *v18);
  if (v16)
  {
    uint64_t v21 = 0;
    uint64_t v22 = v17 + v20;
    v13.i32[0] = *(_DWORD *)(*(void *)(a1 + 40) + 6720);
    v14.i32[0] = 998277249;
    float32x4_t v23 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmulq_f32(v13, v14), 0);
  }
  else
  {
    uint64_t v22 = 0;
    uint64_t v21 = v17 + 4 * v20;
    float32x4_t v23 = 0uLL;
  }
  unint64_t v24 = *(unsigned int *)(a3 + 12);
  uint64_t v25 = *(const float **)a3;
  if ((int)v24 < 1)
  {
    float32x4_t v31 = (float32x4_t)vdupq_n_s32(0x4B189680u);
    int8x16_t v34 = 0uLL;
  }
  else
  {
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    v29.i64[0] = -1;
    v29.i64[1] = -1;
    int32x4_t v30 = vaddq_s32(v75, v29);
    float32x4_t v31 = (float32x4_t)vdupq_n_s32(0x4B189680u);
    int8x8_t v32 = *(int **)(a1 + 1000);
    int v33 = *v32;
    int8x16_t v34 = 0uLL;
    float32x4_t v35 = *(const float **)a3;
    do
    {
      uint64_t v36 = v26 + 1;
      if (v26 + 1 >= v24) {
        int v37 = v26;
      }
      else {
        int v37 = v26 + 1;
      }
      uint64_t v38 = (v19 * v18[v37]);
      if (v16)
      {
        uint64_t v39 = v17 + v38;
        uint64_t v28 = v22;
        uint64_t v40 = v21;
      }
      else
      {
        uint64_t v40 = v17 + 4 * v38;
        uint64_t v39 = v22;
        uint64_t v27 = v21;
      }
      int32x4_t v41 = v35 + 3;
      float32x4_t v42 = vld1q_dup_f32(v41);
      if (vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32(v31, v42))), 0xFuLL)))) {
        break;
      }
      int32x4_t v43 = *(int32x4_t *)(a1 + 384);
      unsigned int v44 = HIDWORD(*(void *)(a1 + 384));
      unsigned int v45 = *(void *)(a1 + 392);
      if (v16)
      {
        v15.i8[0] = *(unsigned char *)(v28 + v45);
        v15.i8[4] = *(unsigned char *)(v28 + v43.u32[3]);
        v46.i32[0] = *(unsigned __int8 *)(v28 + v43.u32[0]);
        v46.i32[1] = *(unsigned __int8 *)(v28 + v44);
        v46.u64[1] = (unint64_t)vand_s8(*(int8x8_t *)v15.i8, (int8x8_t)0xFF000000FFLL);
        float32x4_t v47 = vmulq_f32(v23, vcvtq_f32_u32(v46));
      }
      else
      {
        v47.i32[0] = *(_DWORD *)(v27 + 4 * v43.u32[0]);
        v47.i32[1] = *(_DWORD *)(v27 + 4 * v44);
        v47.i32[2] = *(_DWORD *)(v27 + 4 * v45);
        v47.i32[3] = *(_DWORD *)(v27 + 4 * v43.u32[3]);
      }
      float32x2_t v48 = (const float *)(*(void *)(a1 + 1008) + 4 * v26);
      int32x4_t v49 = (int32x4_t)vld1q_dup_f32(v48);
      int32x4_t v50 = vsubq_s32(v43, v49);
      uint64_t v51 = (const float *)(*(void *)(a1 + 16) + 6664);
      int32x4_t v52 = (int32x4_t)vld1q_dup_f32(v51);
      int32x4_t v53 = vabsq_s32(v50);
      float32x4_t v54 = (const float *)(a1 + 112);
      int32x4_t v55 = (int32x4_t)vld1q_dup_f32(v54);
      int32x4_t v56 = vabsq_s32(vsubq_s32(v55, v50));
      int8x16_t v57 = (const float *)(a1 + 1060);
      int32x4_t v58 = (int32x4_t)vld1q_dup_f32(v57);
      int8x16_t v59 = (int8x16_t)vcgtq_s32(v52, v53);
      uint64_t v60 = (const float *)(*(void *)(a1 + 1024) + 4 * v26);
      float32x4_t v61 = vld1q_dup_f32(v60);
      float32x4_t v62 = (float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_s32(v56, v58), *(int8x16_t *)(a1 + 832), (int8x16_t)vmulq_f32(*(float32x4_t *)(a1 + 704), vaddq_f32(v47, v61))), v59);
      if (*(void *)(a1 + 32) == *(void *)(a1 + 48) || *(void *)(a1 + 104))
      {
        uint64_t v63 = v8 + 4 * (v33 * v9);
        v64.i32[0] = *(_DWORD *)(v63 + 4 * *(unsigned int *)(a1 + 448));
        v64.i32[1] = *(_DWORD *)(v63 + 4 * *(unsigned int *)(a1 + 452));
        v64.i32[2] = *(_DWORD *)(v63 + 4 * *(unsigned int *)(a1 + 456));
        v64.i32[3] = *(_DWORD *)(v63 + 4 * *(unsigned int *)(a1 + 460));
        int32x4_t v65 = (const float *)(*(void *)(a1 + 1016) + 4 * v26);
        float32x4_t v66 = vld1q_dup_f32(v65);
        float32x4_t v62 = vaddq_f32(vmulq_f32(*(float32x4_t *)(a1 + 768), vaddq_f32(*(float32x4_t *)(a1 + 576), vaddq_f32(v64, v66))), v62);
      }
      int v33 = v32[v37];
      int32x4_t v67 = (int32x4_t)vld1q_dup_f32(v35);
      int8x16_t v15 = (int8x16_t)vceqq_s32(v67, v30);
      float32x4_t v68 = vaddq_f32(v42, (float32x4_t)vbicq_s8((int8x16_t)vaddq_f32(v62, *(float32x4_t *)(a1 + 640)), v15));
      int8x16_t v69 = (int8x16_t)vcgtq_f32(v31, v68);
      float32x4_t v31 = (float32x4_t)vbslq_s8(v69, (int8x16_t)v68, (int8x16_t)v31);
      v35 += 6;
      int8x16_t v34 = vbslq_s8(v69, (int8x16_t)vdupq_n_s32(v26++), v34);
      uint64_t v21 = v40;
      uint64_t v22 = v39;
    }
    while (v24 != v36);
  }
  uint64_t v70 = v10 + 24 * (int)v11;
  *(float *)(v70 + 12) = v31.f32[0] + *(float *)(v70 + 12);
  *(void *)(v70 + 16) = &v25[6 * v34.i32[0]];
  if (v25) {
    ++LODWORD(v25[6 * v34.i32[0] + 2]);
  }
  uint64_t v71 = v10 + 24 * (v11 + 1);
  *(float *)(v71 + 12) = v31.f32[1] + *(float *)(v71 + 12);
  *(void *)(v71 + 16) = &v25[6 * v34.i32[1]];
  if (v25) {
    ++LODWORD(v25[6 * v34.i32[1] + 2]);
  }
  uint64_t v72 = v10 + 24 * (v11 + 2);
  *(float *)(v72 + 12) = v31.f32[2] + *(float *)(v72 + 12);
  *(void *)(v72 + 16) = &v25[6 * v34.i32[2]];
  if (v25) {
    ++LODWORD(v25[6 * v34.i32[2] + 2]);
  }
  uint64_t v73 = v10 + 24 * (v11 + 3);
  *(float *)(v73 + 12) = v31.f32[3] + *(float *)(v73 + 12);
  *(void *)(v73 + 16) = &v25[6 * v34.i32[3]];
  if (v25) {
    ++LODWORD(v25[6 * v34.i32[3] + 2]);
  }
  return 0;
}

uint64_t precomp_DoInnerLoop_T_8R_simd_nosylrate(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v122 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(void *)(v9 + 1640);
  int v11 = *(_DWORD *)(v9 + 1652);
  memset(v114, 0, sizeof(v114));
  uint64_t v12 = *a2;
  int8x16_t v117 = 0u;
  int8x16_t v118 = 0u;
  memset_pattern16(&__b, &unk_220785790, 0x20uLL);
  unint64_t v13 = 0;
  char v14 = 1;
  v15.i64[0] = -1;
  v15.i64[1] = -1;
  do
  {
    int v16 = (int *)(v12 + 24 * (v13 + a4));
    *(void *)&v114[v13 / 2] = v16;
    v116[v13] = *v16;
    int v17 = v16[6];
    *((void *)v114 + (v13 | 1)) = v16 + 6;
    v116[v13 | 1] = v17;
    int v18 = v16[12];
    *((void *)v114 + (v13 | 2)) = v16 + 12;
    v116[v13 | 2] = v18;
    int v19 = v16[18];
    *((void *)v114 + (v13 | 3)) = v16 + 18;
    v116[v13 | 3] = v19;
    v119[v13 / 4] = vaddq_s32(*(int32x4_t *)&v116[v13], v15);
    v115[v13] = v16[1];
    v115[v13 | 1] = v16[7];
    v115[v13 | 2] = v16[13];
    char v20 = v14;
    v115[v13 | 3] = v16[19];
    unint64_t v13 = 4;
    char v14 = 0;
  }
  while ((v20 & 1) != 0);
  precomp_FetchRightNode(a1, a5, v116, v115, 8);
  int v24 = *(_DWORD *)(a1 + 1088);
  uint64_t v25 = *(void *)(v9 + 2424);
  uint64_t v26 = *(_DWORD **)(a1 + 1032);
  int v27 = *(_DWORD *)(v9 + 2436);
  uint64_t v28 = (v27 * *v26);
  if (v24)
  {
    uint64_t v29 = 0;
    uint64_t v30 = v25 + v28;
    v21.i32[0] = *(_DWORD *)(*(void *)(a1 + 16) + 6720);
    v22.i32[0] = 998277249;
    float32x4_t v31 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmulq_f32(v21, v22), 0);
  }
  else
  {
    uint64_t v30 = 0;
    uint64_t v29 = v25 + 4 * v28;
    float32x4_t v31 = 0uLL;
  }
  unint64_t v32 = *(unsigned int *)(a3 + 12);
  int v33 = *(const float **)a3;
  if ((int)v32 >= 1)
  {
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t v36 = 0;
    int v37 = *(int **)(a1 + 1000);
    int v38 = *v37;
    int8x16_t v39 = 0uLL;
    uint64_t v40 = v33;
    int8x16_t v41 = 0uLL;
    do
    {
      unint64_t v42 = v34 + 1;
      if (v34 + 1 >= v32) {
        int v43 = v34;
      }
      else {
        int v43 = v34 + 1;
      }
      uint64_t v44 = (v27 * v26[v43]);
      if (v24)
      {
        uint64_t v45 = v25 + v44;
        uint64_t v36 = v30;
        uint64_t v46 = v29;
      }
      else
      {
        uint64_t v46 = v25 + 4 * v44;
        uint64_t v45 = v30;
        uint64_t v35 = v29;
      }
      uint64_t v47 = v10 + 4 * (v38 * v11);
      float32x2_t v48 = v40 + 3;
      float32x4_t v49 = vld1q_dup_f32(v48);
      if (vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32((float32x4_t)__b, v49))), 0xFuLL))))
      {
        int v55 = 0;
      }
      else
      {
        int32x4_t v50 = *(int32x4_t *)(a1 + 384);
        unsigned int v51 = HIDWORD(*(void *)(a1 + 384));
        unsigned int v52 = *(void *)(a1 + 392);
        if (v24)
        {
          v23.i8[0] = *(unsigned char *)(v36 + v52);
          v23.i8[4] = *(unsigned char *)(v36 + v50.u32[3]);
          v53.i32[0] = *(unsigned __int8 *)(v36 + v50.u32[0]);
          v53.i32[1] = *(unsigned __int8 *)(v36 + v51);
          v53.u64[1] = (unint64_t)vand_s8(*(int8x8_t *)v23.i8, (int8x8_t)0xFF000000FFLL);
          float32x4_t v54 = vmulq_f32(v31, vcvtq_f32_u32(v53));
        }
        else
        {
          v54.i32[0] = *(_DWORD *)(v35 + 4 * v50.u32[0]);
          v54.i32[1] = *(_DWORD *)(v35 + 4 * v51);
          v54.i32[2] = *(_DWORD *)(v35 + 4 * v52);
          v54.i32[3] = *(_DWORD *)(v35 + 4 * v50.u32[3]);
        }
        int32x4_t v56 = (const float *)(*(void *)(a1 + 1008) + 4 * v34);
        int32x4_t v57 = (int32x4_t)vld1q_dup_f32(v56);
        int32x4_t v58 = vsubq_s32(v50, v57);
        int8x16_t v59 = (const float *)(*(void *)(a1 + 16) + 6664);
        int32x4_t v60 = (int32x4_t)vld1q_dup_f32(v59);
        int32x4_t v61 = vabsq_s32(v58);
        float32x4_t v62 = (const float *)(a1 + 112);
        int32x4_t v63 = (int32x4_t)vld1q_dup_f32(v62);
        int32x4_t v64 = vabsq_s32(vsubq_s32(v63, v58));
        int32x4_t v65 = (const float *)(a1 + 1060);
        int32x4_t v66 = (int32x4_t)vld1q_dup_f32(v65);
        int8x16_t v67 = (int8x16_t)vcgtq_s32(v60, v61);
        float32x4_t v68 = (const float *)(*(void *)(a1 + 1024) + 4 * v34);
        float32x4_t v69 = vld1q_dup_f32(v68);
        float32x4_t v70 = (float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_s32(v64, v66), *(int8x16_t *)(a1 + 832), (int8x16_t)vmulq_f32(*(float32x4_t *)(a1 + 704), vaddq_f32(v54, v69))), v67);
        if (*(void *)(a1 + 32) == *(void *)(a1 + 48) || *(void *)(a1 + 104))
        {
          v71.i32[0] = *(_DWORD *)(v47 + 4 * *(unsigned int *)(a1 + 448));
          v71.i32[1] = *(_DWORD *)(v47 + 4 * *(unsigned int *)(a1 + 452));
          v71.i32[2] = *(_DWORD *)(v47 + 4 * *(unsigned int *)(a1 + 456));
          v71.i32[3] = *(_DWORD *)(v47 + 4 * *(unsigned int *)(a1 + 460));
          uint64_t v72 = (const float *)(*(void *)(a1 + 1016) + 4 * v34);
          float32x4_t v73 = vld1q_dup_f32(v72);
          float32x4_t v70 = vaddq_f32(vmulq_f32(*(float32x4_t *)(a1 + 768), vaddq_f32(*(float32x4_t *)(a1 + 576), vaddq_f32(v71, v73))), v70);
        }
        int32x4_t v74 = (int32x4_t)vld1q_dup_f32(v40);
        float32x4_t v75 = vaddq_f32(v49, (float32x4_t)vbicq_s8((int8x16_t)vaddq_f32(v70, *(float32x4_t *)(a1 + 640)), (int8x16_t)vceqq_s32(v74, v119[0])));
        int8x16_t v23 = (int8x16_t)vcgtq_f32((float32x4_t)__b, v75);
        int8x16_t __b = vbslq_s8(v23, (int8x16_t)v75, __b);
        int8x16_t v41 = vbslq_s8(v23, (int8x16_t)vdupq_n_s32(v34), v41);
        int8x16_t v117 = v41;
        int v55 = 1;
      }
      if (vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32((float32x4_t)v121, v49))), 0xFuLL))))
      {
        int v81 = 0;
      }
      else
      {
        int32x4_t v76 = *(int32x4_t *)(a1 + 400);
        unsigned int v77 = HIDWORD(*(void *)(a1 + 400));
        unsigned int v78 = *(void *)(a1 + 408);
        if (v24)
        {
          v23.i8[0] = *(unsigned char *)(v36 + v78);
          v23.i8[4] = *(unsigned char *)(v36 + v76.u32[3]);
          v79.i32[0] = *(unsigned __int8 *)(v36 + v76.u32[0]);
          v79.i32[1] = *(unsigned __int8 *)(v36 + v77);
          v79.u64[1] = (unint64_t)vand_s8(*(int8x8_t *)v23.i8, (int8x8_t)0xFF000000FFLL);
          float32x4_t v80 = vmulq_f32(v31, vcvtq_f32_u32(v79));
        }
        else
        {
          v80.i32[0] = *(_DWORD *)(v35 + 4 * v76.u32[0]);
          v80.i32[1] = *(_DWORD *)(v35 + 4 * v77);
          v80.i32[2] = *(_DWORD *)(v35 + 4 * v78);
          v80.i32[3] = *(_DWORD *)(v35 + 4 * v76.u32[3]);
        }
        int8x16_t v82 = (const float *)(*(void *)(a1 + 1008) + 4 * v34);
        int32x4_t v83 = (int32x4_t)vld1q_dup_f32(v82);
        int32x4_t v84 = vsubq_s32(v76, v83);
        int64x2_t v85 = (const float *)(*(void *)(a1 + 16) + 6664);
        int32x4_t v86 = (int32x4_t)vld1q_dup_f32(v85);
        int32x4_t v87 = vabsq_s32(v84);
        float32x2_t v88 = (const float *)(a1 + 112);
        int32x4_t v89 = (int32x4_t)vld1q_dup_f32(v88);
        int32x4_t v90 = vabsq_s32(vsubq_s32(v89, v84));
        float v91 = (const float *)(a1 + 1060);
        int32x4_t v92 = (int32x4_t)vld1q_dup_f32(v91);
        int8x16_t v93 = (int8x16_t)vcgtq_s32(v86, v87);
        uint32x4_t v94 = (const float *)(*(void *)(a1 + 1024) + 4 * v34);
        float32x4_t v95 = vld1q_dup_f32(v94);
        float32x4_t v96 = (float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_s32(v90, v92), *(int8x16_t *)(a1 + 848), (int8x16_t)vmulq_f32(*(float32x4_t *)(a1 + 720), vaddq_f32(v80, v95))), v93);
        if (*(void *)(a1 + 32) == *(void *)(a1 + 48) || *(void *)(a1 + 104))
        {
          v97.i32[0] = *(_DWORD *)(v47 + 4 * *(unsigned int *)(a1 + 464));
          v97.i32[1] = *(_DWORD *)(v47 + 4 * *(unsigned int *)(a1 + 468));
          v97.i32[2] = *(_DWORD *)(v47 + 4 * *(unsigned int *)(a1 + 472));
          v97.i32[3] = *(_DWORD *)(v47 + 4 * *(unsigned int *)(a1 + 476));
          uint64_t v98 = (const float *)(*(void *)(a1 + 1016) + 4 * v34);
          float32x4_t v99 = vld1q_dup_f32(v98);
          float32x4_t v96 = vaddq_f32(vmulq_f32(*(float32x4_t *)(a1 + 784), vaddq_f32(*(float32x4_t *)(a1 + 592), vaddq_f32(v97, v99))), v96);
        }
        int32x4_t v100 = (int32x4_t)vld1q_dup_f32(v40);
        int8x16_t v23 = (int8x16_t)vceqq_s32(v100, v119[1]);
        float32x4_t v101 = vaddq_f32(v49, (float32x4_t)vbicq_s8((int8x16_t)vaddq_f32(v96, *(float32x4_t *)(a1 + 656)), v23));
        int8x16_t v102 = (int8x16_t)vcgtq_f32((float32x4_t)v121, v101);
        int8x16_t v121 = vbslq_s8(v102, (int8x16_t)v101, v121);
        int8x16_t v39 = vbslq_s8(v102, (int8x16_t)vdupq_n_s32(v34), v39);
        int8x16_t v118 = v39;
        int v81 = 1;
      }
      if (!(v81 | v55)) {
        break;
      }
      int v38 = v37[v43];
      v40 += 6;
      ++v34;
      uint64_t v29 = v46;
      uint64_t v30 = v45;
    }
    while (v42 < v32);
  }
  uint64_t v103 = 0;
  char v104 = 1;
  do
  {
    char v105 = v104;
    long long v106 = *(long long *)((char *)&v117 + 2 * v103);
    long long v107 = *(long long *)((char *)&__b + 2 * v103);
    uint64_t v108 = *(void *)&v114[v103];
    *(float *)(v108 + 12) = *(float *)&v107 + *(float *)(v108 + 12);
    *(void *)(v108 + 16) = &v33[6 * (int)v106];
    if (v33) {
      ++LODWORD(v33[6 * (int)v106 + 2]);
    }
    uint64_t v109 = 4 * v103;
    uint64_t v110 = *(void *)((char *)v114 + (v109 | 8));
    *(float *)(v110 + 12) = *((float *)&v107 + 1) + *(float *)(v110 + 12);
    *(void *)(v110 + 16) = &v33[6 * SDWORD1(v106)];
    if (v33) {
      ++LODWORD(v33[6 * SDWORD1(v106) + 2]);
    }
    uint64_t v111 = *(void *)((char *)v114 + (v109 | 0x10));
    *(float *)(v111 + 12) = *((float *)&v107 + 2) + *(float *)(v111 + 12);
    *(void *)(v111 + 16) = &v33[6 * SDWORD2(v106)];
    if (v33) {
      ++LODWORD(v33[6 * SDWORD2(v106) + 2]);
    }
    uint64_t v112 = *(void *)((char *)v114 + (v109 | 0x18));
    *(float *)(v112 + 12) = *((float *)&v107 + 3) + *(float *)(v112 + 12);
    *(void *)(v112 + 16) = &v33[6 * SHIDWORD(v106)];
    if (v33) {
      ++LODWORD(v33[6 * SHIDWORD(v106) + 2]);
    }
    char v104 = 0;
    uint64_t v103 = 2;
  }
  while ((v105 & 1) != 0);
  return 0;
}

uint64_t precomp_DoInnerLoop_T_16R_simd_nosylrate(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4, int a5)
{
  uint64_t v187 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(void *)(v9 + 1640);
  int v11 = *(_DWORD *)(v9 + 1652);
  uint64_t v12 = v175;
  long long v174 = 0u;
  memset(v175, 0, sizeof(v175));
  uint64_t v13 = *a2;
  int8x16_t v178 = 0u;
  int8x16_t v179 = 0u;
  int8x16_t v180 = 0u;
  int8x16_t v181 = 0u;
  memset_pattern16(&__b, &unk_220785790, 0x40uLL);
  unint64_t v14 = 0;
  int32x4_t v15 = (int *)(v13 + 24 * a4 + 76);
  unint64_t v16 = -4;
  v17.i64[0] = -1;
  v17.i64[1] = -1;
  do
  {
    int v18 = &v177[v14 / 4];
    *int v18 = *(v15 - 19);
    int v19 = *(v15 - 13);
    *(v12 - 2) = v15 - 19;
    *(v12 - 1) = v15 - 13;
    v18[1] = v19;
    v18[2] = *(v15 - 7);
    int v20 = *(v15 - 1);
    *uint64_t v12 = v15 - 7;
    v12[1] = v15 - 1;
    v12 += 4;
    v18[3] = v20;
    v182[v14 / 0x10] = vaddq_s32(*(int32x4_t *)&v177[v14 / 4], v17);
    float32x4_t v21 = &v176[v14 / 4];
    *float32x4_t v21 = *(v15 - 18);
    v21[1] = *(v15 - 12);
    v21[2] = *(v15 - 6);
    v16 += 4;
    int v22 = *v15;
    v15 += 24;
    v21[3] = v22;
    v14 += 16;
  }
  while (v16 < 0xC);
  precomp_FetchRightNode(a1, a5, v177, v176, 16);
  int v26 = *(_DWORD *)(a1 + 1088);
  uint64_t v27 = *(void *)(v9 + 2424);
  uint64_t v28 = *(_DWORD **)(a1 + 1032);
  int v29 = *(_DWORD *)(v9 + 2436);
  uint64_t v30 = (v29 * *v28);
  if (v26)
  {
    uint64_t v31 = 0;
    uint64_t v32 = v27 + v30;
    v23.i32[0] = *(_DWORD *)(*(void *)(a1 + 40) + 6720);
    v24.i32[0] = 998277249;
    float32x4_t v33 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmulq_f32(v23, v24), 0);
  }
  else
  {
    uint64_t v32 = 0;
    uint64_t v31 = v27 + 4 * v30;
    float32x4_t v33 = 0uLL;
  }
  unint64_t v34 = *((unsigned int *)a3 + 3);
  if ((int)v34 >= 1)
  {
    uint64_t v35 = 0;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    int8x16_t v39 = *(int **)(a1 + 1000);
    int v40 = *v39;
    int v41 = 255;
    int8x16_t v42 = 0uLL;
    int8x16_t v43 = 0uLL;
    int8x16_t v44 = 0uLL;
    int v45 = 255;
    int v46 = 255;
    int v47 = 255;
    int8x16_t v48 = 0uLL;
    do
    {
      if (!(v46 | v47 | v45 | v41)) {
        break;
      }
      uint64_t v49 = v36 + 1;
      int v50 = v36 + 1 >= v34 ? v36 : (int)v36 + 1;
      uint64_t v51 = (v29 * v28[v50]);
      if (v26)
      {
        uint64_t v52 = v27 + v51;
        uint64_t v38 = v32;
        uint64_t v53 = v31;
      }
      else
      {
        uint64_t v53 = v27 + 4 * v51;
        uint64_t v52 = v32;
        uint64_t v37 = v31;
      }
      uint64_t v54 = v10 + 4 * (v40 * v11);
      uint64_t v55 = *a3;
      int32x4_t v56 = (const float *)(*a3 + v35);
      int32x4_t v57 = v56 + 3;
      float32x4_t v58 = vld1q_dup_f32(v57);
      if (vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32((float32x4_t)__b, v58))), 0xFuLL))))
      {
        int v47 = 0;
      }
      else
      {
        int32x4_t v59 = *(int32x4_t *)(a1 + 384);
        unsigned int v60 = HIDWORD(*(void *)(a1 + 384));
        unsigned int v61 = *(void *)(a1 + 392);
        if (v26)
        {
          v25.i8[0] = *(unsigned char *)(v38 + v61);
          v25.i8[4] = *(unsigned char *)(v38 + v59.u32[3]);
          v62.i32[0] = *(unsigned __int8 *)(v38 + v59.u32[0]);
          v62.i32[1] = *(unsigned __int8 *)(v38 + v60);
          v62.u64[1] = (unint64_t)vand_s8(*(int8x8_t *)v25.i8, (int8x8_t)0xFF000000FFLL);
          float32x4_t v63 = vmulq_f32(v33, vcvtq_f32_u32(v62));
        }
        else
        {
          v63.i32[0] = *(_DWORD *)(v37 + 4 * v59.u32[0]);
          v63.i32[1] = *(_DWORD *)(v37 + 4 * v60);
          v63.i32[2] = *(_DWORD *)(v37 + 4 * v61);
          v63.i32[3] = *(_DWORD *)(v37 + 4 * v59.u32[3]);
        }
        int32x4_t v64 = (const float *)(*(void *)(a1 + 1008) + 4 * v36);
        int32x4_t v65 = (int32x4_t)vld1q_dup_f32(v64);
        int32x4_t v66 = vsubq_s32(v59, v65);
        int8x16_t v67 = (const float *)(*(void *)(a1 + 16) + 6664);
        int32x4_t v68 = (int32x4_t)vld1q_dup_f32(v67);
        int32x4_t v69 = vabsq_s32(v66);
        float32x4_t v70 = (const float *)(a1 + 112);
        int32x4_t v71 = (int32x4_t)vld1q_dup_f32(v70);
        int32x4_t v72 = vabsq_s32(vsubq_s32(v71, v66));
        float32x4_t v73 = (const float *)(a1 + 1060);
        int32x4_t v74 = (int32x4_t)vld1q_dup_f32(v73);
        int8x16_t v75 = (int8x16_t)vcgtq_s32(v68, v69);
        int32x4_t v76 = (const float *)(*(void *)(a1 + 1024) + 4 * v36);
        float32x4_t v77 = vld1q_dup_f32(v76);
        float32x4_t v78 = (float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_s32(v72, v74), *(int8x16_t *)(a1 + 832), (int8x16_t)vmulq_f32(*(float32x4_t *)(a1 + 704), vaddq_f32(v63, v77))), v75);
        if (*(void *)(a1 + 32) == *(void *)(a1 + 48) || *(void *)(a1 + 104))
        {
          v79.i32[0] = *(_DWORD *)(v54 + 4 * *(unsigned int *)(a1 + 448));
          v79.i32[1] = *(_DWORD *)(v54 + 4 * *(unsigned int *)(a1 + 452));
          v79.i32[2] = *(_DWORD *)(v54 + 4 * *(unsigned int *)(a1 + 456));
          v79.i32[3] = *(_DWORD *)(v54 + 4 * *(unsigned int *)(a1 + 460));
          float32x4_t v80 = (const float *)(*(void *)(a1 + 1016) + 4 * v36);
          float32x4_t v81 = vld1q_dup_f32(v80);
          float32x4_t v78 = vaddq_f32(vmulq_f32(*(float32x4_t *)(a1 + 768), vaddq_f32(*(float32x4_t *)(a1 + 576), vaddq_f32(v79, v81))), v78);
        }
        int32x4_t v82 = (int32x4_t)vld1q_dup_f32(v56);
        float32x4_t v83 = vaddq_f32(v58, (float32x4_t)vbicq_s8((int8x16_t)vaddq_f32(v78, *(float32x4_t *)(a1 + 640)), (int8x16_t)vceqq_s32(v82, v182[0])));
        int8x16_t v25 = (int8x16_t)vcgtq_f32((float32x4_t)__b, v83);
        int8x16_t __b = vbslq_s8(v25, (int8x16_t)v83, __b);
        int8x16_t v48 = vbslq_s8(v25, (int8x16_t)vdupq_n_s32(v36), v48);
        int8x16_t v178 = v48;
        int v47 = 1;
      }
      if (vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32((float32x4_t)v184, v58))), 0xFuLL))))
      {
        int v46 = 0;
      }
      else
      {
        int32x4_t v84 = *(int32x4_t *)(a1 + 400);
        unsigned int v85 = HIDWORD(*(void *)(a1 + 400));
        unsigned int v86 = *(void *)(a1 + 408);
        if (v26)
        {
          v25.i8[0] = *(unsigned char *)(v38 + v86);
          v25.i8[4] = *(unsigned char *)(v38 + v84.u32[3]);
          v87.i32[0] = *(unsigned __int8 *)(v38 + v84.u32[0]);
          v87.i32[1] = *(unsigned __int8 *)(v38 + v85);
          v87.u64[1] = (unint64_t)vand_s8(*(int8x8_t *)v25.i8, (int8x8_t)0xFF000000FFLL);
          float32x4_t v88 = vmulq_f32(v33, vcvtq_f32_u32(v87));
        }
        else
        {
          v88.i32[0] = *(_DWORD *)(v37 + 4 * v84.u32[0]);
          v88.i32[1] = *(_DWORD *)(v37 + 4 * v85);
          v88.i32[2] = *(_DWORD *)(v37 + 4 * v86);
          v88.i32[3] = *(_DWORD *)(v37 + 4 * v84.u32[3]);
        }
        int32x4_t v89 = (const float *)(*(void *)(a1 + 1008) + 4 * v36);
        int32x4_t v90 = (int32x4_t)vld1q_dup_f32(v89);
        int32x4_t v91 = vsubq_s32(v84, v90);
        int32x4_t v92 = (const float *)(*(void *)(a1 + 16) + 6664);
        int32x4_t v93 = (int32x4_t)vld1q_dup_f32(v92);
        int32x4_t v94 = vabsq_s32(v91);
        float32x4_t v95 = (const float *)(a1 + 112);
        int32x4_t v96 = (int32x4_t)vld1q_dup_f32(v95);
        int32x4_t v97 = vabsq_s32(vsubq_s32(v96, v91));
        uint64_t v98 = (const float *)(a1 + 1060);
        int32x4_t v99 = (int32x4_t)vld1q_dup_f32(v98);
        int8x16_t v100 = (int8x16_t)vcgtq_s32(v93, v94);
        float32x4_t v101 = (const float *)(*(void *)(a1 + 1024) + 4 * v36);
        float32x4_t v102 = vld1q_dup_f32(v101);
        float32x4_t v103 = (float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_s32(v97, v99), *(int8x16_t *)(a1 + 848), (int8x16_t)vmulq_f32(*(float32x4_t *)(a1 + 720), vaddq_f32(v88, v102))), v100);
        if (*(void *)(a1 + 32) == *(void *)(a1 + 48) || *(void *)(a1 + 104))
        {
          v104.i32[0] = *(_DWORD *)(v54 + 4 * *(unsigned int *)(a1 + 464));
          v104.i32[1] = *(_DWORD *)(v54 + 4 * *(unsigned int *)(a1 + 468));
          v104.i32[2] = *(_DWORD *)(v54 + 4 * *(unsigned int *)(a1 + 472));
          v104.i32[3] = *(_DWORD *)(v54 + 4 * *(unsigned int *)(a1 + 476));
          char v105 = (const float *)(*(void *)(a1 + 1016) + 4 * v36);
          float32x4_t v106 = vld1q_dup_f32(v105);
          float32x4_t v103 = vaddq_f32(vmulq_f32(*(float32x4_t *)(a1 + 784), vaddq_f32(*(float32x4_t *)(a1 + 592), vaddq_f32(v104, v106))), v103);
        }
        long long v107 = (const float *)(v55 + v35);
        int32x4_t v108 = (int32x4_t)vld1q_dup_f32(v107);
        float32x4_t v109 = vaddq_f32(v58, (float32x4_t)vbicq_s8((int8x16_t)vaddq_f32(v103, *(float32x4_t *)(a1 + 656)), (int8x16_t)vceqq_s32(v108, v182[1])));
        int8x16_t v25 = (int8x16_t)vcgtq_f32((float32x4_t)v184, v109);
        int8x16_t v184 = vbslq_s8(v25, (int8x16_t)v109, v184);
        int8x16_t v44 = vbslq_s8(v25, (int8x16_t)vdupq_n_s32(v36), v44);
        int8x16_t v179 = v44;
        int v46 = 1;
      }
      int v40 = v39[v50];
      if (vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32((float32x4_t)v185, v58))), 0xFuLL))))
      {
        int v45 = 0;
      }
      else
      {
        int32x4_t v110 = *(int32x4_t *)(a1 + 416);
        unsigned int v111 = HIDWORD(*(void *)(a1 + 416));
        unsigned int v112 = *(void *)(a1 + 424);
        if (v26)
        {
          v25.i8[0] = *(unsigned char *)(v38 + v112);
          v25.i8[4] = *(unsigned char *)(v38 + v110.u32[3]);
          v113.i32[0] = *(unsigned __int8 *)(v38 + v110.u32[0]);
          v113.i32[1] = *(unsigned __int8 *)(v38 + v111);
          v113.u64[1] = (unint64_t)vand_s8(*(int8x8_t *)v25.i8, (int8x8_t)0xFF000000FFLL);
          float32x4_t v114 = vmulq_f32(v33, vcvtq_f32_u32(v113));
        }
        else
        {
          v114.i32[0] = *(_DWORD *)(v37 + 4 * v110.u32[0]);
          v114.i32[1] = *(_DWORD *)(v37 + 4 * v111);
          v114.i32[2] = *(_DWORD *)(v37 + 4 * v112);
          v114.i32[3] = *(_DWORD *)(v37 + 4 * v110.u32[3]);
        }
        uint32x4_t v115 = (const float *)(*(void *)(a1 + 1008) + 4 * v36);
        int32x4_t v116 = (int32x4_t)vld1q_dup_f32(v115);
        int32x4_t v117 = vsubq_s32(v110, v116);
        int8x16_t v118 = (const float *)(*(void *)(a1 + 16) + 6664);
        int32x4_t v119 = (int32x4_t)vld1q_dup_f32(v118);
        int32x4_t v120 = vabsq_s32(v117);
        int8x16_t v121 = (const float *)(a1 + 112);
        int32x4_t v122 = (int32x4_t)vld1q_dup_f32(v121);
        int32x4_t v123 = vabsq_s32(vsubq_s32(v122, v117));
        float v124 = (const float *)(a1 + 1060);
        int32x4_t v125 = (int32x4_t)vld1q_dup_f32(v124);
        int8x16_t v126 = (int8x16_t)vcgtq_s32(v119, v120);
        float v127 = (const float *)(*(void *)(a1 + 1024) + 4 * v36);
        float32x4_t v128 = vld1q_dup_f32(v127);
        float32x4_t v129 = (float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_s32(v123, v125), *(int8x16_t *)(a1 + 864), (int8x16_t)vmulq_f32(*(float32x4_t *)(a1 + 736), vaddq_f32(v114, v128))), v126);
        if (*(void *)(a1 + 32) == *(void *)(a1 + 48) || *(void *)(a1 + 104))
        {
          v130.i32[0] = *(_DWORD *)(v54 + 4 * *(unsigned int *)(a1 + 480));
          v130.i32[1] = *(_DWORD *)(v54 + 4 * *(unsigned int *)(a1 + 484));
          v130.i32[2] = *(_DWORD *)(v54 + 4 * *(unsigned int *)(a1 + 488));
          v130.i32[3] = *(_DWORD *)(v54 + 4 * *(unsigned int *)(a1 + 492));
          float v131 = (const float *)(*(void *)(a1 + 1016) + 4 * v36);
          float32x4_t v132 = vld1q_dup_f32(v131);
          float32x4_t v129 = vaddq_f32(vmulq_f32(*(float32x4_t *)(a1 + 800), vaddq_f32(*(float32x4_t *)(a1 + 608), vaddq_f32(v130, v132))), v129);
        }
        float v133 = (const float *)(v55 + v35);
        int32x4_t v134 = (int32x4_t)vld1q_dup_f32(v133);
        float32x4_t v135 = vaddq_f32(v58, (float32x4_t)vbicq_s8((int8x16_t)vaddq_f32(v129, *(float32x4_t *)(a1 + 672)), (int8x16_t)vceqq_s32(v134, v182[2])));
        int8x16_t v25 = (int8x16_t)vcgtq_f32((float32x4_t)v185, v135);
        int8x16_t v185 = vbslq_s8(v25, (int8x16_t)v135, v185);
        int8x16_t v43 = vbslq_s8(v25, (int8x16_t)vdupq_n_s32(v36), v43);
        int8x16_t v180 = v43;
        int v45 = 1;
      }
      if (vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32((float32x4_t)v186, v58))), 0xFuLL))))
      {
        int v41 = 0;
      }
      else
      {
        int32x4_t v136 = *(int32x4_t *)(a1 + 432);
        unsigned int v137 = HIDWORD(*(void *)(a1 + 432));
        unsigned int v138 = *(void *)(a1 + 440);
        if (v26)
        {
          v25.i8[0] = *(unsigned char *)(v38 + v138);
          v25.i8[4] = *(unsigned char *)(v38 + v136.u32[3]);
          v139.i32[0] = *(unsigned __int8 *)(v38 + v136.u32[0]);
          v139.i32[1] = *(unsigned __int8 *)(v38 + v137);
          v139.u64[1] = (unint64_t)vand_s8(*(int8x8_t *)v25.i8, (int8x8_t)0xFF000000FFLL);
          float32x4_t v140 = vmulq_f32(v33, vcvtq_f32_u32(v139));
        }
        else
        {
          v140.i32[0] = *(_DWORD *)(v37 + 4 * v136.u32[0]);
          v140.i32[1] = *(_DWORD *)(v37 + 4 * v137);
          v140.i32[2] = *(_DWORD *)(v37 + 4 * v138);
          v140.i32[3] = *(_DWORD *)(v37 + 4 * v136.u32[3]);
        }
        int64x2_t v141 = (const float *)(*(void *)(a1 + 1008) + 4 * v36);
        int32x4_t v142 = (int32x4_t)vld1q_dup_f32(v141);
        int32x4_t v143 = vsubq_s32(v136, v142);
        int64x2_t v144 = (const float *)(*(void *)(a1 + 16) + 6664);
        int32x4_t v145 = (int32x4_t)vld1q_dup_f32(v144);
        int32x4_t v146 = vabsq_s32(v143);
        float v147 = (const float *)(a1 + 112);
        int32x4_t v148 = (int32x4_t)vld1q_dup_f32(v147);
        int32x4_t v149 = vabsq_s32(vsubq_s32(v148, v143));
        float v150 = (const float *)(a1 + 1060);
        int32x4_t v151 = (int32x4_t)vld1q_dup_f32(v150);
        int8x16_t v152 = (int8x16_t)vcgtq_s32(v145, v146);
        float v153 = (const float *)(*(void *)(a1 + 1024) + 4 * v36);
        float32x4_t v154 = vld1q_dup_f32(v153);
        float32x4_t v155 = (float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_s32(v149, v151), *(int8x16_t *)(a1 + 880), (int8x16_t)vmulq_f32(*(float32x4_t *)(a1 + 752), vaddq_f32(v140, v154))), v152);
        if (*(void *)(a1 + 32) == *(void *)(a1 + 48) || *(void *)(a1 + 104))
        {
          v156.i32[0] = *(_DWORD *)(v54 + 4 * *(unsigned int *)(a1 + 496));
          v156.i32[1] = *(_DWORD *)(v54 + 4 * *(unsigned int *)(a1 + 500));
          v156.i32[2] = *(_DWORD *)(v54 + 4 * *(unsigned int *)(a1 + 504));
          v156.i32[3] = *(_DWORD *)(v54 + 4 * *(unsigned int *)(a1 + 508));
          float v157 = (const float *)(*(void *)(a1 + 1016) + 4 * v36);
          float32x4_t v158 = vld1q_dup_f32(v157);
          float32x4_t v155 = vaddq_f32(vmulq_f32(*(float32x4_t *)(a1 + 816), vaddq_f32(*(float32x4_t *)(a1 + 624), vaddq_f32(v156, v158))), v155);
        }
        unint64_t v159 = (const float *)(v55 + v35);
        int32x4_t v160 = (int32x4_t)vld1q_dup_f32(v159);
        int8x16_t v25 = (int8x16_t)vceqq_s32(v160, v182[3]);
        float32x4_t v161 = vaddq_f32(v58, (float32x4_t)vbicq_s8((int8x16_t)vaddq_f32(v155, *(float32x4_t *)(a1 + 688)), v25));
        int8x16_t v162 = (int8x16_t)vcgtq_f32((float32x4_t)v186, v161);
        int8x16_t v186 = vbslq_s8(v162, (int8x16_t)v161, v186);
        int8x16_t v42 = vbslq_s8(v162, (int8x16_t)vdupq_n_s32(v36), v42);
        int8x16_t v181 = v42;
        int v41 = 1;
      }
      v35 += 24;
      ++v36;
      uint64_t v31 = v53;
      uint64_t v32 = v52;
    }
    while (v34 != v49);
  }
  uint64_t v163 = 0;
  uint64_t v164 = *a3;
  int v165 = v175;
  unint64_t v166 = -4;
  do
  {
    long long v167 = *(long long *)((char *)&v178 + v163);
    long long v168 = *(long long *)((char *)&__b + v163);
    uint64_t v169 = *(v165 - 2);
    *(float *)(v169 + 12) = *(float *)&v168 + *(float *)(v169 + 12);
    *(void *)(v169 + 16) = v164 + 24 * (int)v167;
    if (v164) {
      ++*(_DWORD *)(v164 + 24 * (int)v167 + 8);
    }
    uint64_t v170 = *(v165 - 1);
    *(float *)(v170 + 12) = *((float *)&v168 + 1) + *(float *)(v170 + 12);
    *(void *)(v170 + 16) = v164 + 24 * SDWORD1(v167);
    if (v164) {
      ++*(_DWORD *)(v164 + 24 * SDWORD1(v167) + 8);
    }
    uint64_t v171 = *v165;
    *(float *)(v171 + 12) = *((float *)&v168 + 2) + *(float *)(*v165 + 12);
    *(void *)(v171 + 16) = v164 + 24 * SDWORD2(v167);
    if (v164) {
      ++*(_DWORD *)(v164 + 24 * SDWORD2(v167) + 8);
    }
    uint64_t v172 = v165[1];
    *(float *)(v172 + 12) = *((float *)&v168 + 3) + *(float *)(v172 + 12);
    *(void *)(v172 + 16) = v164 + 24 * SHIDWORD(v167);
    if (v164) {
      ++*(_DWORD *)(v164 + 24 * SHIDWORD(v167) + 8);
    }
    v166 += 4;
    v163 += 16;
    v165 += 4;
  }
  while (v166 < 0xC);
  return 0;
}

uint64_t precomp_DoInnerLoop_simd_nosylrate_nopitchdeviation(float32x4_t *a1, uint64_t *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  uint64_t v7 = *a2;
  uint64_t v8 = a4;
  uint64_t v9 = (__int32 *)(*a2 + 24 * a4);
  v53.i32[0] = *v9;
  v53.i32[1] = v9[6];
  v53.i32[2] = v9[12];
  v53.i32[3] = v9[18];
  int32x4_t v51 = v53;
  v52[0] = v9[1];
  v52[1] = v9[7];
  v52[2] = v9[13];
  v52[3] = v9[19];
  precomp_FetchRightNode((uint64_t)a1, a5, v53.i32, v52, 4);
  __int32 v12 = a1[68].i32[0];
  uint64_t v13 = a1[8].i64[0];
  uint64_t v14 = a1[8].i64[1];
  int8x16_t v15 = 0uLL;
  uint64_t v16 = a1[9].i64[0];
  uint64_t v17 = a1[9].i64[1];
  if (v12)
  {
    v10.i32[0] = *(_DWORD *)(a1[2].i64[1] + 6720);
    v11.i32[0] = 998277249;
    uint64_t v18 = a1[9].i64[1];
    uint64_t v19 = a1[9].i64[0];
    uint64_t v20 = a1[8].i64[1];
    uint64_t v21 = a1[8].i64[0];
    float32x4_t v22 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmulq_f32(v10, v11), 0);
    uint64_t v17 = 0;
    uint64_t v16 = 0;
    uint64_t v14 = 0;
    uint64_t v13 = 0;
  }
  else
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    float32x4_t v22 = 0uLL;
  }
  uint64_t v23 = *(unsigned int *)(a3 + 12);
  float32x4_t v24 = *(const float **)a3;
  if ((int)v23 < 1)
  {
    float32x4_t v28 = (float32x4_t)vdupq_n_s32(0x4B189680u);
  }
  else
  {
    uint64_t v25 = 0;
    v26.i64[0] = -1;
    v26.i64[1] = -1;
    int32x4_t v27 = vaddq_s32(v51, v26);
    float32x4_t v28 = (float32x4_t)vdupq_n_s32(0x4B189680u);
    int8x16_t v15 = 0uLL;
    int v29 = *(const float **)a3;
    do
    {
      uint64_t v30 = v29 + 3;
      float32x4_t v31 = vld1q_dup_f32(v30);
      int8x8_t v32 = (int8x8_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32(v28, v31))), 0xFuLL));
      v32.i16[0] = vminv_u16((uint16x4_t)v32);
      if (v32.i8[0]) {
        break;
      }
      uint64_t v33 = *(unsigned int *)(a1[64].i64[1] + 4 * v25);
      if (v12)
      {
        v32.i8[0] = *(unsigned char *)(v19 + v33);
        v32.i8[4] = *(unsigned char *)(v18 + v33);
        v34.i32[0] = *(unsigned __int8 *)(v21 + v33);
        v34.i32[1] = *(unsigned __int8 *)(v20 + v33);
        v34.u64[1] = (unint64_t)vand_s8(v32, (int8x8_t)0xFF000000FFLL);
        float32x4_t v35 = vmulq_f32(v22, vcvtq_f32_u32(v34));
      }
      else
      {
        v35.i32[0] = *(_DWORD *)(v13 + 4 * v33);
        v35.i32[1] = *(_DWORD *)(v14 + 4 * v33);
        v35.i32[2] = *(_DWORD *)(v16 + 4 * v33);
        v35.i32[3] = *(_DWORD *)(v17 + 4 * v33);
      }
      uint64_t v36 = (const float *)(a1[64].i64[0] + 4 * v25);
      float32x4_t v37 = vld1q_dup_f32(v36);
      float32x4_t v38 = vmulq_f32(a1[44], vaddq_f32(v35, v37));
      if (a1[2].i64[0] == a1[3].i64[0] || a1[6].i64[1])
      {
        uint64_t v39 = *(unsigned int *)(a1[62].i64[1] + 4 * v25);
        v40.i32[0] = *(_DWORD *)(a1[16].i64[0] + 4 * v39);
        v40.i32[1] = *(_DWORD *)(a1[16].i64[1] + 4 * v39);
        v40.i32[2] = *(_DWORD *)(a1[17].i64[0] + 4 * v39);
        v40.i32[3] = *(_DWORD *)(a1[17].i64[1] + 4 * v39);
        int v41 = (const float *)(a1[63].i64[1] + 4 * v25);
        float32x4_t v42 = vld1q_dup_f32(v41);
        float32x4_t v38 = vaddq_f32(v38, vmulq_f32(a1[48], vaddq_f32(a1[36], vaddq_f32(v40, v42))));
      }
      int32x4_t v43 = (int32x4_t)vld1q_dup_f32(v29);
      float32x4_t v44 = vaddq_f32(v31, (float32x4_t)vbicq_s8((int8x16_t)vaddq_f32(v38, a1[40]), (int8x16_t)vceqq_s32(v43, v27)));
      int8x16_t v45 = (int8x16_t)vcgtq_f32(v28, v44);
      float32x4_t v28 = (float32x4_t)vbslq_s8(v45, (int8x16_t)v44, (int8x16_t)v28);
      int8x16_t v15 = vbslq_s8(v45, (int8x16_t)vdupq_n_s32(v25++), v15);
      v29 += 6;
    }
    while (v23 != v25);
  }
  uint64_t v46 = v7 + 24 * (int)v8;
  *(float *)(v46 + 12) = v28.f32[0] + *(float *)(v46 + 12);
  *(void *)(v46 + 16) = &v24[6 * v15.i32[0]];
  if (v24) {
    ++LODWORD(v24[6 * v15.i32[0] + 2]);
  }
  uint64_t v47 = v7 + 24 * (v8 + 1);
  *(float *)(v47 + 12) = v28.f32[1] + *(float *)(v47 + 12);
  *(void *)(v47 + 16) = &v24[6 * v15.i32[1]];
  if (v24) {
    ++LODWORD(v24[6 * v15.i32[1] + 2]);
  }
  uint64_t v48 = v7 + 24 * (v8 + 2);
  *(float *)(v48 + 12) = v28.f32[2] + *(float *)(v48 + 12);
  *(void *)(v48 + 16) = &v24[6 * v15.i32[2]];
  if (v24) {
    ++LODWORD(v24[6 * v15.i32[2] + 2]);
  }
  uint64_t v49 = v7 + 24 * (v8 + 3);
  *(float *)(v49 + 12) = v28.f32[3] + *(float *)(v49 + 12);
  *(void *)(v49 + 16) = &v24[6 * v15.i32[3]];
  if (v24) {
    ++LODWORD(v24[6 * v15.i32[3] + 2]);
  }
  return 0;
}

uint64_t UNICORN__InitTreeSet(int a1, void *__b)
{
  return 0;
}

void *UNICORN__DeInitTreeSet(void *result, char *__b)
{
  if (__b)
  {
    uint64_t v3 = (uint64_t)result;
    for (uint64_t i = 56; i != 96; i += 8)
    {
      uint64_t v5 = *(void *)&__b[i];
      if (v5) {
        heap_Free(*(void **)(v3 + 8), v5);
      }
    }
    return cstdlib_memset(__b, 0, 0x70uLL);
  }
  return result;
}

uint64_t UNICORN__LoadTreesFile(uint64_t a1, uint64_t a2, int a3, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  unsigned __int16 v30 = 0;
  uint64_t v9 = *a4;
  if (a4[4] - v9 >= 8 && *(unsigned char *)(*((void *)a4 + 1) + v9) == 48)
  {
    *a4 = v9 + 2;
    uint64_t v12 = a3;
    uint64_t v13 = (_WORD *)(a2 + 2 * a3 + 96);
    if (UNICORN__xfread_BET5(v13, 2u, 1, a4) == 1
      && UNICORN__xfread_BET5(&v30, 2u, 1, a4) == 1
      && UNICORN__xfread_BET5((void *)(a2 + 2 * v12), 2u, 1, a4) == 1)
    {
      int v14 = UNICORN__xfread2ptr_BET5((void *)(a2 + 8 * v12 + 16), 1u, v30, a4);
      if (v14 == v30)
      {
        if (*a4) {
          ++*a4;
        }
        uint64_t v15 = heap_Calloc(*(void **)(v8 + 8), 16, (unsigned __int16)*v13);
        uint64_t v21 = a2 + 8 * v12;
        *(void *)(v21 + 56) = v15;
        float32x4_t v22 = (uint64_t *)(v21 + 56);
        if (!v15)
        {
          UNICORN__log_select_Error(v8, 55000, (uint64_t)"LoadTreesFile : out of memory for type %s\n", v16, v17, v18, v19, v20);
          return 2229280778;
        }
        if (!*v13) {
          return 0;
        }
        uint64_t v23 = 0;
        unint64_t v24 = 0;
        while (UNICORN__xfread_BET5((void *)(v15 + v23), 2u, 1, a4) == 1)
        {
          if (UNICORN__xfread_BET5((void *)(*v22 + v23 + 2), 2u, 1, a4) != 1) {
            break;
          }
          int v25 = UNICORN__xfread2ptr_BET5((void *)(*v22 + v23 + 8), 2u, 3 * *(unsigned __int16 *)(*v22 + v23 + 2), a4);
          uint64_t v15 = *v22;
          if (v25 != 3 * *(unsigned __int16 *)(*v22 + v23 + 2)) {
            break;
          }
          uint64_t v26 = 0;
          ++v24;
          v23 += 16;
          if (v24 >= (unsigned __int16)*v13) {
            return v26;
          }
        }
        uint64_t v26 = 2229280772;
        int32x4_t v27 = "LoadTreesFile : corrupt tree nodes for type %s, state %u\n";
        a1 = v8;
        uint64_t v28 = 55015;
      }
      else
      {
        uint64_t v26 = 2229280772;
        int32x4_t v27 = "LoadTreesFile : corrupt tree questions for type %s\n";
        a1 = v8;
        uint64_t v28 = 55013;
      }
    }
    else
    {
      uint64_t v26 = 2229280772;
      int32x4_t v27 = "LoadTreesFile : corrupt tree header for type %s\n";
      a1 = v8;
      uint64_t v28 = 55012;
    }
  }
  else
  {
    uint64_t v26 = 2229280772;
    int32x4_t v27 = "LoadTreesFile : invalid tree data version for type %s\n";
    uint64_t v28 = 55011;
  }
  UNICORN__log_select_Error(a1, v28, (uint64_t)v27, (uint64_t)a4, a5, a6, a7, a8);
  return v26;
}

uint64_t UNICORN__TreeSearch(uint64_t a1, int a2, uint64_t a3, int a4, int a5)
{
  LOWORD(v5) = 0;
  uint64_t v6 = a3 + 8 * a4;
  uint64_t v7 = *(void *)(v6 + 16);
  uint64_t v8 = *(void *)(*(void *)(v6 + 56) + 16 * a5 + 8);
  uint64_t v9 = a2 + 2;
  uint64_t v10 = a2 + 1;
  while (2)
  {
    uint64_t v11 = -(uint64_t)(__int16)v5;
    uint64_t v12 = (unsigned __int16 *)(v8 + 6 * (int)v11);
    uint64_t v13 = (unsigned __int8 *)(v7 + *v12);
    uint64_t v14 = *v13;
    int v15 = v13[1];
    uint64_t v5 = v12[1];
    switch(*v13)
    {
      case 0xFCu:
        if (a2 < 2) {
          goto LABEL_20;
        }
        unsigned __int8 v16 = *(unsigned char *)(*(void *)(a1 + 32) + (a2 - 2));
        if (v13[1]) {
          goto LABEL_24;
        }
        goto LABEL_39;
      case 0xFDu:
        if (a2 < 1) {
          goto LABEL_20;
        }
        unsigned __int8 v16 = *(unsigned char *)(*(void *)(a1 + 32) + (a2 - 1));
        if (v13[1]) {
          goto LABEL_24;
        }
        goto LABEL_39;
      case 0xFEu:
        if ((int)v10 >= *(__int16 *)(a1 + 10)) {
          goto LABEL_20;
        }
        unsigned __int8 v16 = *(unsigned char *)(*(void *)(a1 + 32) + v10);
        if (v13[1]) {
          goto LABEL_24;
        }
        goto LABEL_39;
      case 0xFFu:
        if ((int)v9 >= *(__int16 *)(a1 + 10))
        {
LABEL_20:
          unsigned __int8 v16 = -1;
          if (v13[1]) {
            goto LABEL_24;
          }
        }
        else
        {
          unsigned __int8 v16 = *(unsigned char *)(*(void *)(a1 + 32) + v9);
          if (v13[1]) {
            goto LABEL_24;
          }
        }
        goto LABEL_39;
      default:
        if (v14 == 3)
        {
          unsigned int v17 = *(unsigned __int16 *)(*(void *)(a1 + 1784) + 2 * a2);
          BOOL v18 = v17 > 0x19;
          unsigned __int8 v16 = 10 * v17;
          if (v18) {
            unsigned __int8 v16 = -1;
          }
          if (!v13[1]) {
            goto LABEL_39;
          }
        }
        else
        {
          uint64_t v19 = *(void *)(a1 + 8 * v14 + 16);
          if (!v19) {
            goto LABEL_39;
          }
          unsigned __int8 v16 = *(unsigned char *)(v19 + a2);
          if (!v13[1]) {
            goto LABEL_39;
          }
        }
LABEL_24:
        uint64_t v20 = v13 + 2;
        if (v15 == 255)
        {
          if (*v20 <= v16 && v13[3] >= v16) {
            goto LABEL_30;
          }
        }
        else
        {
          int v21 = v15 - 1;
          if (v21)
          {
            int v22 = 0;
            while (1)
            {
              int v23 = v21 + v22;
              if (v21 + v22 < 0 != __OFADD__(v21, v22)) {
                ++v23;
              }
              int v24 = v23 >> 1;
              unsigned int v25 = v20[v24];
              if (v25 == v16) {
                break;
              }
              if (v16 < v25) {
                int v21 = v24 - 1;
              }
              else {
                int v22 = v24 + 1;
              }
              if (v22 > v21) {
                goto LABEL_39;
              }
            }
LABEL_30:
            uint64_t v5 = *(unsigned __int16 *)(v8 + 6 * (int)v11 + 4);
            goto LABEL_39;
          }
          if (*v20 == v16) {
            goto LABEL_30;
          }
        }
LABEL_39:
        if ((v5 & 0x8000) != 0) {
          continue;
        }
        return v5;
    }
  }
}

uint64_t UNICORN__mlpg_cpy(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 16);
  if ((int)v1 >= 1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = *(unsigned int *)(result + 20);
    do
    {
      if ((int)v3 >= 1)
      {
        uint64_t v4 = 0;
        uint64_t v5 = *(void *)(result + 112);
        do
        {
          if (v5)
          {
            if (*(unsigned char *)(v5 + v4) == 1) {
              *(_DWORD *)(*(void *)(*(void *)(result + 40) + 8 * v4) + 4 * v2) = *(_DWORD *)(*(void *)(*(void *)(result + 72) + 8 * v4)
            }
                                                                                               + 4 * v2);
          }
          ++v4;
        }
        while (v3 != v4);
      }
      ++v2;
    }
    while (v2 != v1);
  }
  return result;
}

float UNICORN__mlpg(uint64_t a1, int a2)
{
  unint64_t v4 = *(unsigned int *)(a1 + 20);
  if ((int)v4 <= 0)
  {
    uint64_t v9 = *(float ***)(a1 + 96);
    LODWORD(v11) = *(_DWORD *)(a1 + 24);
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = a2;
    uint64_t v8 = *(void *)(a1 + 72);
    uint64_t v7 = *(void *)(a1 + 80);
    uint64_t v9 = *(float ***)(a1 + 96);
    uint64_t v10 = *(void *)(a1 + 104);
    uint64_t v11 = *(unsigned int *)(a1 + 24);
    uint64_t v12 = *(unsigned int **)(a1 + 32);
    uint64_t v13 = *v12;
    uint64_t v66 = v13;
    uint64_t v67 = a2;
    int32x4_t v68 = v9;
    do
    {
      uint64_t v14 = *(void *)(v7 + 8 * v5);
      *(float *)(v10 + 4 * v5) = *(float *)(v14 + 4 * v6) * *(float *)(*(void *)(v8 + 8 * v5) + 4 * v6);
      int v15 = v9[v5];
      *int v15 = *(float *)(v14 + 4 * v6);
      if ((int)v11 >= 2)
      {
        bzero(v15 + 1, 4 * (v11 - 1));
        uint64_t v13 = v66;
        uint64_t v6 = v67;
        uint64_t v9 = v68;
      }
      if ((int)v13 >= 2)
      {
        uint64_t v16 = *((void *)v12 + 1);
        for (uint64_t i = 1; i != v13; ++i)
        {
          BOOL v18 = *(int **)(v16 + 8 * i);
          uint64_t v19 = *v18;
          uint64_t v20 = v18[1];
          if ((int)v19 <= (int)v20)
          {
            uint64_t v21 = -4 * v19;
            uint64_t v22 = -v19;
            do
            {
              if (v19 + v5 < v4)
              {
                uint64_t v23 = *(void *)(*((void *)v12 + 2) + 8 * i);
                float v24 = *(float *)(v23 - 4 * v19);
                if (v24 != 0.0)
                {
                  int v25 = a2 + *(_DWORD *)(a1 + 16) * i;
                  uint64_t v26 = 8 * (v19 + v5);
                  float v27 = v24 * *(float *)(*(void *)(v7 + v26) + 4 * v25);
                  *(float *)(v10 + 4 * v5) = *(float *)(v10 + 4 * v5)
                                           + (float)(v27 * *(float *)(*(void *)(v8 + v26) + 4 * v25));
                  if ((int)v11 >= 1)
                  {
                    uint64_t v28 = 0;
                    uint64_t v29 = v23 + v21;
                    do
                    {
                      BOOL v30 = v22 + v28 <= v20 && v28 < (uint64_t)(v4 - v5);
                      if (v30)
                      {
                        float v31 = *(float *)(v29 + 4 * v28);
                        if (v31 != 0.0) {
                          v15[v28] = v15[v28] + (float)(v27 * v31);
                        }
                      }
                      ++v28;
                    }
                    while (v11 != v28);
                  }
                }
              }
              ++v19;
              v21 -= 4;
              --v22;
            }
            while (v20 + 1 != v19);
          }
        }
      }
      ++v5;
    }
    while (v5 != v4);
  }
  int8x8_t v32 = *v9;
  float v33 = sqrtf(**v9);
  **uint64_t v9 = v33;
  if ((int)v11 >= 2)
  {
    uint64_t v34 = v11 - 1;
    float32x4_t v35 = v32 + 1;
    do
    {
      *float32x4_t v35 = *v35 / v33;
      ++v35;
      --v34;
    }
    while (v34);
  }
  if ((int)v4 <= 1)
  {
    int32x4_t v53 = *(float **)(a1 + 88);
    *int32x4_t v53 = **(float **)(a1 + 104) / v33;
  }
  else
  {
    uint64_t v36 = 0;
    uint64_t v37 = 1;
    float32x4_t v38 = v9;
    do
    {
      if ((int)v11 < 2)
      {
        *v9[v37] = sqrtf(*v9[v37]);
      }
      else
      {
        uint64_t v39 = v36;
        uint64_t v40 = 1;
        do
        {
          if ((v39 & 0x8000000000000000) == 0)
          {
            float v41 = v9[v39][v40];
            *v9[v37] = *v9[v37] - (float)(v41 * v41);
          }
          ++v40;
          --v39;
        }
        while (v11 != v40);
        float32x4_t v42 = v9[v37];
        float v43 = sqrtf(*v42);
        *float32x4_t v42 = v43;
        uint64_t v44 = *(unsigned int *)(*(void *)(a1 + 32) + 32);
        uint64_t v45 = 1;
        do
        {
          uint64_t v46 = v45 + 1;
          if ((int)v44 > 0)
          {
            uint64_t v47 = v45;
            uint64_t v48 = v38;
            uint64_t v49 = v44;
            do
            {
              if (v45 != v11 - 1) {
                v42[v45] = v42[v45] - (float)((*v48)[v47] * (*v48)[v46]);
              }
              --v47;
              --v48;
              --v49;
            }
            while (v49);
          }
          v42[v45] = v42[v45] / v43;
          ++v45;
        }
        while (v46 != v11);
      }
      ++v37;
      ++v36;
      ++v38;
    }
    while (v37 != v4);
    uint64_t v50 = 0;
    int32x4_t v51 = *(float **)(a1 + 104);
    float v52 = *v51 / *v32;
    int32x4_t v53 = *(float **)(a1 + 88);
    *int32x4_t v53 = v52;
    for (uint64_t j = 1; j != v4; ++j)
    {
      float v55 = 0.0;
      if ((int)v11 >= 2)
      {
        uint64_t v56 = v50;
        uint64_t v57 = 1;
        do
        {
          if ((v56 & 0x8000000000000000) == 0)
          {
            float v58 = v9[v56][v57];
            if (v58 != 0.0) {
              float v55 = v55 + (float)(v58 * v53[v56]);
            }
          }
          ++v57;
          --v56;
        }
        while (v11 != v57);
      }
      v53[j] = (float)(v51[j] - v55) / *v9[j];
      ++v50;
    }
  }
  float result = v53[(int)v4 - 1] / *v9[(int)v4 - 1];
  uint64_t v60 = *(void *)(a1 + 40);
  *(float *)(*(void *)(v60 + 8 * ((int)v4 - 1)) + 4 * a2) = result;
  if ((int)v4 >= 2)
  {
    uint64_t v61 = (v4 - 2);
    uint64_t v62 = v60 + 8 * v61;
    do
    {
      float v63 = 0.0;
      if ((int)v11 >= 2)
      {
        uint64_t v64 = 1;
        do
        {
          if (v61 + v64 < (uint64_t)v4)
          {
            float v65 = v9[v61][v64];
            if (v65 != 0.0) {
              float v63 = v63 + (float)(v65 * *(float *)(*(void *)(v62 + 8 * v64) + 4 * a2));
            }
          }
          ++v64;
        }
        while (v11 != v64);
      }
      float result = (float)(v53[v61] - v63) / *v9[v61];
      *(float *)(*(void *)(v60 + 8 * v61) + 4 * a2) = result;
      v62 -= 8;
      BOOL v30 = v61-- <= 0;
    }
    while (!v30);
  }
  return result;
}

uint64_t UNICORN__dummy_solver(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 16);
  if ((int)v1 >= 1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = *(unsigned int *)(result + 20);
    do
    {
      if ((int)v3 >= 1)
      {
        unint64_t v4 = *(uint64_t **)(result + 40);
        uint64_t v5 = v3;
        do
        {
          uint64_t v6 = *v4++;
          *(_DWORD *)(v6 + 4 * v2) = 0;
          --v5;
        }
        while (v5);
      }
      ++v2;
    }
    while (v2 != v1);
  }
  return result;
}

void UNICORN__mlpg_c(uint64_t a1, int a2)
{
  if (*(int *)(a1 + 20) < 2)
  {
    UNICORN__meancpy(a1);
  }
  else
  {
    *(float *)&double v4 = UNICORN__ConstW_Calc_R_and_r(a1, a2);
    UNICORN__ConstW_Cholesky(a1, v4);
    UNICORN__ConstW_Cholesky_forward(a1);
    UNICORN__ConstW_Cholesky_backward(a1, a2);
  }
}

uint64_t UNICORN__select_bet5_FeatureExtractObjOpen(_WORD *a1, int a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v16 = 0;
  *a5 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v16);
  if ((inited & 0x80000000) == 0)
  {
    uint64_t v9 = (void *)heap_Calloc(*(void **)(v16 + 8), 1, 24);
    if (v9)
    {
      *uint64_t v9 = v16;
      v9[1] = a3;
      v9[2] = a4;
      *a5 = v9;
    }
    else
    {
      log_OutPublic(*(void *)(v16 + 32), (uint64_t)"SELECT_BET5", 55000, 0, v10, v11, v12, v13, v15);
      return 2229280778;
    }
  }
  return inited;
}

uint64_t UNICORN__select_bet5_FeatureExtractObjClose(uint64_t a1)
{
  if (a1) {
    heap_Free(*(void **)(*(void *)a1 + 8), a1);
  }
  return 0;
}

uint64_t UNICORN__select_bet5_FeatureExtractProcessStart(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *__b, _DWORD *a6)
{
  cstdlib_memset(__b, 0, 0xE48uLL);
  *int8x16_t __b = a2;
  uint64_t v12 = *a1;
  uint64_t v13 = a1[2];

  return usextract_ProcessStart(v12, (uint64_t)"SELECT_BET5", v13, a3, a4, (uint64_t)__b, a6);
}

uint64_t UNICORN__select_bet5_FeatureExtractProcess(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _DWORD *a9, uint64_t a10, uint64_t *a11, unsigned int *a12)
{
  uint64_t v14 = a1;
  unsigned int v15 = a12;
  uint64_t v120 = *MEMORY[0x263EF8340];
  uint64_t v16 = *a1;
  unsigned int v118 = 0;
  if (a11) {
    BOOL v17 = a12 == 0;
  }
  else {
    BOOL v17 = 1;
  }
  int v18 = !v17;
  if (!v17)
  {
    *a11 = 0;
    *a12 = 0;
  }
  int v113 = v18;
  uint64_t v19 = 0;
  int v20 = 0;
  uint64_t v21 = *(__int16 *)(a10 + 10);
  do
  {
    if (*(unsigned char *)(*(void *)a10 + 2748 + v19) == 1) {
      ++v20;
    }
    ++v19;
  }
  while (v19 != 218);
  uint64_t v22 = heap_Calloc(*(void **)(v16 + 8), (v20 * v21), 1);
  if (!v22) {
    goto LABEL_135;
  }
  uint64_t v27 = v22;
  uint32x4_t v115 = v14;
  for (uint64_t i = 0; i != 218; ++i)
  {
    uint64_t v29 = *(void *)a10;
    int v30 = *(unsigned __int8 *)(*(void *)a10 + i + 2748);
    if (*(unsigned char *)(*(void *)a10 + i + 2748))
    {
      if (v30 == 2)
      {
        uint64_t v31 = heap_Calloc(*(void **)(v16 + 8), v21, 2);
        *(void *)(a10 + 8 * i + 1760) = v31;
        if (!v31) {
          goto LABEL_43;
        }
      }
      else if (v30 == 1)
      {
        *(void *)(a10 + 8 * i + 16) = v27;
        v27 += v21;
      }
      else
      {
        switch((int)i)
        {
          case '.':
            uint64_t v32 = heap_Calloc(*(void **)(v16 + 8), v21, 9);
            *(void *)(a10 + 3560) = v32;
            if (!v32) {
              goto LABEL_43;
            }
            continue;
          case '/':
          case '0':
          case '1':
          case '2':
          case '7':
            goto LABEL_28;
          case '3':
            int v34 = *(unsigned __int16 *)(v29 + 2966);
            if (v34)
            {
              uint64_t v35 = heap_Calloc(*(void **)(v16 + 8), (v34 * v21), 4);
              *(void *)(a10 + 3568) = v35;
              if (!v35) {
                goto LABEL_43;
              }
            }
            continue;
          case '4':
            int v36 = *(unsigned __int16 *)(v29 + 2966);
            if (v36)
            {
              uint64_t v37 = heap_Calloc(*(void **)(v16 + 8), (v36 * v21), 4);
              *(void *)(a10 + 3576) = v37;
              if (!v37) {
                goto LABEL_43;
              }
            }
            continue;
          case '5':
            int v38 = *(unsigned __int16 *)(v29 + 3360);
            if (v38)
            {
              uint64_t v39 = heap_Calloc(*(void **)(v16 + 8), (v38 * v21), 4);
              *(void *)(a10 + 3584) = v39;
              if (!v39) {
                goto LABEL_43;
              }
            }
            continue;
          case '6':
            int v40 = *(unsigned __int16 *)(v29 + 3360);
            if (v40)
            {
              uint64_t v41 = heap_Calloc(*(void **)(v16 + 8), (v40 * v21), 4);
              *(void *)(a10 + 3592) = v41;
              if (!v41) {
                goto LABEL_43;
              }
            }
            continue;
          case '8':
            int v42 = *(unsigned __int16 *)(v29 + 2966);
            if (v42)
            {
              uint64_t v43 = heap_Calloc(*(void **)(v16 + 8), (v42 * v21), 1);
              *(void *)(a10 + 3600) = v43;
              if (!v43) {
                goto LABEL_43;
              }
            }
            continue;
          default:
            if (i == 24)
            {
              uint64_t v33 = heap_Calloc(*(void **)(v16 + 8), v21, 8);
              *(void *)(a10 + 3552) = v33;
              if (!v33)
              {
LABEL_43:
                int v44 = -2065686518;
                log_OutPublic(*(void *)(v16 + 32), (uint64_t)"SELECT_BET5", 55000, 0, v23, v24, v25, v26, v111);
                goto LABEL_44;
              }
            }
            else
            {
LABEL_28:
              log_OutPublic(*(void *)(*v14 + 32), (uint64_t)"SELECT_BET5", 55007, (uint64_t)"%s%u", v23, v24, v25, v26, "feature");
            }
            break;
        }
      }
    }
  }
  unsigned int v45 = *(unsigned __int16 *)(*(void *)a10 + 3578);
  if (v45 >= 4)
  {
    log_OutPublic(*(void *)(v16 + 32), (uint64_t)"SELECT_BET5", 55000, (uint64_t)"Invalid number of states per phoneme", v23, v24, v25, v26, "%s%u");
    int v44 = -2065686513;
    goto LABEL_136;
  }
  uint64_t v46 = (void *)heap_Calloc(*(void **)(v16 + 8), v45 * v21, 4);
  *(void *)(a10 + 3608) = v46;
  if (!v46)
  {
    int v44 = -2065686518;
    log_OutPublic(*(void *)(v16 + 32), (uint64_t)"SELECT_BET5", 55000, 0, v47, v48, v49, v50, v111);
    goto LABEL_136;
  }
  if (*(unsigned __int16 *)(*(void *)a10 + 3578) * v21) {
    memset(v46, 255, 4 * *(unsigned __int16 *)(*(void *)a10 + 3578) * v21);
  }
  int GenericFeatureLayers = usextract_allocateGenericFeatureLayers(*v14, (uint64_t)"SELECT_BET5", (void *)a10, v21);
  if (GenericFeatureLayers < 0)
  {
    int v44 = GenericFeatureLayers;
    goto LABEL_136;
  }
  int v44 = usextract_Process(*v14, (uint64_t)"SELECT_BET5", v14[2], a3, a4, a10, v52, v53);
  if ((v44 & 0x80000000) == 0)
  {
    if (*(void *)(a10 + 3504))
    {
      uint64_t v54 = **(const char ***)(*(void *)a10 + 3336);
      if (v54)
      {
        uint64_t v55 = 0;
        unsigned int v56 = 1;
        do
        {
          int v57 = cstdlib_strncmp(v54, "INNO_", 5uLL);
          uint64_t v58 = *(void *)a10;
          if (v57)
          {
            int32x4_t v59 = *(const char ***)(*(void *)(v58 + 3344) + 8 * v55);
            size_t v60 = cstdlib_strlen("FEATIDX");
            unsigned int Index = usextract_getIndex(v59, "FEATIDX", (unint64_t)&aFeatidx[v60]);
            if (Index == -1)
            {
              if (cstdlib_strcmp(*(const char **)(*(void *)(*(void *)a10 + 3336) + 8 * v55), "POS"))
              {
                if (!cstdlib_strcmp(*(const char **)(*(void *)(*(void *)a10 + 3336) + 8 * v55), "PHR")) {
                  *(void *)(a10 + 512) = *(void *)(*(void *)(a10 + 3504) + 8 * v55);
                }
              }
              else
              {
                *(void *)(a10 + 504) = *(void *)(*(void *)(a10 + 3504) + 8 * v55);
              }
            }
            else
            {
              *(void *)(a10
                        + 8
                        * *(unsigned __int8 *)(*(void *)(*(void *)(*(void *)a10 + 3352) + 8 * v55) + Index)
                        + 16) = *(void *)(*(void *)(a10 + 3504) + 8 * v55);
            }
          }
          else
          {
            unsigned int v62 = cstdlib_atoi((unsigned __int8 *)(*(void *)(*(void *)(v58 + 3336) + 8 * v55) + 5)) + 79;
            if (v62 <= 0x5E) {
              *(void *)(a10 + 8 * v62 + 16) = *(void *)(*(void *)(a10 + 3504) + 8 * v55);
            }
          }
          uint64_t v55 = v56;
          uint64_t v54 = *(const char **)(*(void *)(*(void *)a10 + 3336) + 8 * v56++);
        }
        while (v54);
      }
    }
    int v63 = *(__int16 *)(a10 + 10);
    unsigned int v112 = v63 & ~(v63 >> 31);
    if (UNICORN__log_select_GetLogLevel(*(void *)(v16 + 32)) >= 6)
    {
      LH_itoa(0x4Eu, (char *)v119, 0xAu);
      for (uint64_t j = 0; j != 218; ++j)
      {
        float v65 = "application/x-realspeak-usplosives;version=4.0";
        switch((int)j)
        {
          case 2:
            char v117 = 5;
            char v116 = 0;
            log_OutBinary(*(void *)(v16 + 32), (uint64_t)"SELECT_BET5", 99, 0, (uint64_t)v119, (uint64_t)"text/x-realspeak-usphonemes;charset=tts",
              (uint64_t)&v117,
              1u,
              0);
            log_OutBinary(*(void *)(v16 + 32), (uint64_t)"SELECT_BET5", 99, 0, (uint64_t)v119, (uint64_t)"text/x-realspeak-usphonemes;charset=tts",
              *(void *)(a10 + 8 * j + 16),
              v112,
              0);
            log_OutBinary(*(void *)(v16 + 32), (uint64_t)"SELECT_BET5", 99, 0, (uint64_t)v119, (uint64_t)"text/x-realspeak-usphonemes;charset=tts",
              (uint64_t)&v116,
              1u,
              0);
            continue;
          case 3:
            float v65 = "application/x-realspeak-usdurs;version=4.0";
            goto LABEL_71;
          case 4:
            goto LABEL_71;
          case 5:
            float v65 = "application/x-realspeak-usmarkers-u16;version=4.0";
LABEL_71:
            int v66 = *(unsigned __int8 *)(*(void *)a10 + j + 2748);
            if (v66 == 2)
            {
              log_OutBinary(*(void *)(v16 + 32), (uint64_t)"SELECT_BET5", 99, 0, (uint64_t)v119, (uint64_t)v65, *(void *)(a10 + 8 * j + 1760), 2 * v112, 0);
            }
            else if (v66 == 1)
            {
              log_OutBinary(*(void *)(v16 + 32), (uint64_t)"SELECT_BET5", 99, 0, (uint64_t)v119, (uint64_t)v65, *(void *)(a10 + 8 * j + 16), v112, 0);
            }
            break;
          default:
            continue;
        }
      }
    }
    paramc_ParamGetUInt(*(void *)(v16 + 40), (uint64_t)"waitfactor", &v118);
    unint64_t v67 = *(unsigned int *)(a10 + 3520);
    if (v67)
    {
      uint64_t v68 = 0;
      for (unint64_t k = 0; k < v67; ++k)
      {
        uint64_t v70 = *(void *)(a10 + 3512);
        if (*(_DWORD *)(v70 + v68) == 25)
        {
          unsigned int v118 = *(_DWORD *)(v70 + v68 + 24);
          int v44 = paramc_ParamSetUInt(*(void *)(v16 + 40), (uint64_t)"waitfactor", v118);
          if (v44 < 0)
          {
            log_OutPublic(*(void *)(v16 + 32), (uint64_t)"SELECT_BET5", 55009, (uint64_t)"%s%s%s%d%s%x", v71, v72, v73, v74, "parameter");
LABEL_44:
            unsigned int v15 = a12;
            uint64_t v14 = v115;
            goto LABEL_136;
          }
          unint64_t v67 = *(unsigned int *)(a10 + 3520);
        }
        v68 += 32;
      }
    }
    featextract_adjustSilAudioOrder(a10);
    if (v63 < 1)
    {
      int v75 = 0;
      unsigned int v15 = a12;
      if (!v113) {
        goto LABEL_112;
      }
    }
    else
    {
      int v75 = 0;
      int32x4_t v76 = *(_DWORD **)(a10 + 3608);
      if (v112 <= 1) {
        uint64_t v77 = 1;
      }
      else {
        uint64_t v77 = v112;
      }
      unsigned int v15 = a12;
      do
      {
        if (*v76 == -2) {
          ++v75;
        }
        v76 += *(unsigned __int16 *)(*(void *)a10 + 3578);
        --v77;
      }
      while (v77);
      if (!v113) {
        goto LABEL_112;
      }
    }
    int v78 = v112 - v75;
    int v79 = *(_DWORD *)(a10 + 3520);
    uint64_t v80 = (v79 + v78);
    *unsigned int v15 = v80;
    if (!(v79 + v78)) {
      goto LABEL_112;
    }
    uint64_t v81 = heap_Calloc(*(void **)(v16 + 8), v80, 32);
    *a11 = v81;
    if (!v81)
    {
      int v44 = -2065686518;
      log_OutPublic(*(void *)(v16 + 32), (uint64_t)"SELECT_BET5", 55000, 0, v82, v83, v84, v85, v111);
LABEL_134:
      uint64_t v14 = v115;
      goto LABEL_136;
    }
    unsigned int v86 = (void *)heap_Calloc(*(void **)(v16 + 8), *(__int16 *)(a10 + 10), 2);
    uint64_t v14 = v115;
    if (v86)
    {
      uint64_t v87 = (uint64_t)v86;
      cstdlib_memcpy(v86, *(const void **)(a10 + 1800), 2 * *(__int16 *)(a10 + 10));
      if (*v15)
      {
        unsigned int v88 = 0;
        unint64_t v89 = 0;
        unsigned int v90 = 0;
        while (v89 < *(unsigned int *)(a10 + 3520))
        {
          if (v88 >= v112)
          {
            float32x4_t v95 = (_OWORD *)(*(void *)(a10 + 3512) + 32 * v89);
            long long v96 = v95[1];
            int32x4_t v97 = (_OWORD *)(*a11 + 32 * v90);
            _OWORD *v97 = *v95;
            v97[1] = v96;
            ++v90;
            ++v89;
          }
          else
          {
            if (!*(_WORD *)(v87 + 2 * v88)) {
              break;
            }
            int32x4_t v91 = (_OWORD *)(*a11 + 32 * v90);
            int32x4_t v92 = (_OWORD *)(*(void *)(a10 + 3512) + 32 * v89);
            long long v93 = v92[1];
            *int32x4_t v91 = *v92;
            v91[1] = v93;
            ++v90;
            ++v89;
            --*(_WORD *)(v87 + 2 * v88);
          }
LABEL_110:
          if (v90 >= *v15) {
            goto LABEL_111;
          }
        }
        if (*(_DWORD *)(*(void *)(a10 + 3608) + 4 * v88 * *(unsigned __int16 *)(*(void *)a10 + 3578)) != -2)
        {
          int32x4_t v94 = (_DWORD *)(*a11 + 32 * v90);
          *int32x4_t v94 = 33;
          v94[6] = *(unsigned __int8 *)(*(void *)(a10 + 32) + v88);
          if (v90) {
            *(_DWORD *)(*a11 + 32 * v90 + 12) = *(_DWORD *)(*a11 + 32 * (v90 - 1) + 12);
          }
          ++v90;
        }
        ++v88;
        goto LABEL_110;
      }
LABEL_111:
      heap_Free(*(void **)(v16 + 8), v87);
LABEL_112:
      uint64_t v98 = a2;
      if (v63 >= 1)
      {
        uint64_t v99 = 0;
        if (v112 <= 1) {
          uint64_t v100 = 1;
        }
        else {
          uint64_t v100 = v112;
        }
        do
        {
          uint64_t v101 = *(void *)(a10 + 248);
          if (!*(unsigned char *)(v101 + v99)) {
            *(unsigned char *)(v101 + v99) = -1;
          }
          uint64_t v102 = *(void *)(a10 + 192);
          if (*(unsigned char *)(*(void *)(a10 + 32) + v99) == 35) {
            char v103 = 1;
          }
          else {
            char v103 = 2 * *(unsigned char *)(v102 + v99);
          }
          *(unsigned char *)(v102 + v99) = v103;
          uint64_t v104 = *(void *)(a10 + 32);
          if ((unsigned __int16)(v63 & ~(unsigned __int16)(v63 >> 31)) - 1 == v99 && *(unsigned char *)(v104 + v99) == 35)
          {
            uint64_t v105 = a3;
            uint64_t v106 = a4;
            signed int v107 = *(unsigned __int16 *)(*(void *)(a10 + 1784) + 2 * v99);
            v119[0] = 0;
            paramc_ParamGetUInt(*(void *)(v16 + 40), (uint64_t)"finalsentencefound", v119);
            uint64_t v98 = a2;
            if (!v107)
            {
              if (v119[0] == 1 || !v118) {
                signed int v107 = *(_DWORD *)(a2 + 24);
              }
              else {
                signed int v107 = 200 * v118;
              }
            }
            if (v107 >= 0xFFFF) {
              __int16 v108 = -1;
            }
            else {
              __int16 v108 = v107;
            }
            *(_WORD *)(*(void *)(a10 + 1784) + 2 * v99) = v108;
            uint64_t v104 = *(void *)(a10 + 32);
            a4 = v106;
            a3 = v105;
            unsigned int v15 = a12;
          }
          *(unsigned char *)(v104 + v99) = *(unsigned char *)(v98 + *(unsigned __int8 *)(v104 + v99) + 4780);
          ++v99;
        }
        while (v100 != v99);
      }
      *a9 = v118;
      goto LABEL_134;
    }
LABEL_135:
    int v44 = -2065686518;
    log_OutPublic(*(void *)(v16 + 32), (uint64_t)"SELECT_BET5", 55000, 0, v23, v24, v25, v26, v111);
  }
LABEL_136:
  if (v15 && a11 && v44 < 0 && *a11)
  {
    heap_Free(*(void **)(v16 + 8), *a11);
    *a11 = 0;
    *unsigned int v15 = 0;
  }
  LODWORD(result) = (*(uint64_t (**)(uint64_t, uint64_t))(v14[2] + 64))(a3, a4);
  if ((int)result >= 0 || v44 <= -1) {
    return v44;
  }
  else {
    return result;
  }
}

uint64_t UNICORN__select_bet5_FeatureExtractProcessEnd(uint64_t *a1, void *a2)
{
  if (!*a2) {
    return 0;
  }
  uint64_t v4 = *a1;
  uint64_t v5 = usextract_ProcessEnd(*a1, (uint64_t)"SELECT_BET5", (uint64_t)a2);
  usextract_freeGenericFeatureLayers((void *)*a1, (uint64_t)"SELECT_BET5", a2);
  uint64_t v10 = 0;
  int v11 = 1;
  do
  {
    int v12 = *(unsigned __int8 *)(*a2 + v10 + 2748);
    if (*(unsigned char *)(*a2 + v10 + 2748))
    {
      if (v12 == 2)
      {
        uint64_t v14 = a2[v10 + 220];
        if (v14) {
LABEL_11:
        }
          heap_Free(*(void **)(v4 + 8), v14);
      }
      else if (v12 == 1)
      {
        if (v11)
        {
          uint64_t v13 = a2[v10 + 2];
          if (v13) {
            heap_Free(*(void **)(v4 + 8), v13);
          }
          int v11 = 0;
        }
      }
      else
      {
        switch((int)v10)
        {
          case '.':
            uint64_t v14 = a2[445];
            if (v14) {
              goto LABEL_11;
            }
            break;
          case '/':
          case '0':
          case '1':
          case '2':
          case '7':
            goto LABEL_20;
          case '3':
            uint64_t v14 = a2[446];
            if (v14) {
              goto LABEL_11;
            }
            break;
          case '4':
            uint64_t v14 = a2[447];
            if (v14) {
              goto LABEL_11;
            }
            break;
          case '5':
            uint64_t v14 = a2[448];
            if (v14) {
              goto LABEL_11;
            }
            break;
          case '6':
            uint64_t v14 = a2[449];
            if (v14) {
              goto LABEL_11;
            }
            break;
          case '8':
            uint64_t v14 = a2[450];
            if (v14) {
              goto LABEL_11;
            }
            break;
          default:
            if (v10 == 24)
            {
              uint64_t v14 = a2[444];
              if (v14) {
                goto LABEL_11;
              }
            }
            else
            {
LABEL_20:
              log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"SELECT_BET5", 55010, (uint64_t)"%s%u", v6, v7, v8, v9, "feature");
            }
            break;
        }
      }
    }
    ++v10;
  }
  while (v10 != 218);
  uint64_t v15 = a2[451];
  if (v15) {
    heap_Free(*(void **)(v4 + 8), v15);
  }
  cstdlib_memset(a2, 0, 8uLL);
  return v5;
}

uint64_t UNICORN__LoadModelFile(uint64_t a1, _DWORD *a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = a3;
  if (a2[a3 + 46])
  {
    uint64_t v10 = &a2[a3];
    unsigned int v12 = v10[18];
    int v11 = v10 + 18;
    uint64_t v13 = heap_Calloc(*(void **)(a1 + 8), v12, 8);
    *((void *)a2 + 12) = v13;
    if (!v13) {
      return 2229280778;
    }
    if (*v11 >= 1)
    {
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      uint64_t v16 = a2 + 6;
      uint64_t v78 = a4;
      while (1)
      {
        BOOL v17 = (unsigned int *)(a4 + 24 * v14);
        if (UNICORN__xfread_BET5(a2, 4u, 1, v17) != 1 || (*a2 & 0x80000000) != 0)
        {
          uint64_t v71 = "LoadModelFile: the number of HMM states is illegal for %s %d\n";
          uint64_t v72 = a1;
          uint64_t v73 = 55020;
          goto LABEL_67;
        }
        if (UNICORN__xfread_BET5(v16, 4u, 1, v17) != 1 || (int v23 = *v16, (*v16 & 0x80000000) != 0))
        {
          uint64_t v71 = "LoadModelFile: the number of PDFs is illegal for %s %d\n";
          uint64_t v72 = a1;
          uint64_t v73 = 55021;
          goto LABEL_67;
        }
        if (!v15)
        {
          uint64_t v24 = heap_Calloc(*(void **)(a1 + 8), (*v11 * v23), 8);
          if (!v24) {
            return 2229280778;
          }
          uint64_t v15 = v24;
          int v23 = *v16;
        }
        uint64_t v25 = v9;
        uint64_t v26 = a5;
        *(void *)(*((void *)a2 + 12) + 8 * v14) = v15 + 8 * v23 * (int)v14;
        *(void *)(*((void *)a2 + 12) + 8 * v14) -= 8;
        if (v23 >= 1) {
          break;
        }
LABEL_16:
        ++v14;
        a5 = v26;
        uint64_t v9 = v25;
        uint64_t v16 = a2 + 6;
        a4 = v78;
        if (v14 >= *v11) {
          goto LABEL_17;
        }
      }
      uint64_t v27 = 0;
      int v28 = *a2;
      uint64_t v29 = 8;
      while (1)
      {
        int v30 = UNICORN__xfread2ptr_BET5((void *)(*(void *)(*((void *)a2 + 12) + 8 * v14) + v29), 4u, (2 * v28), v17);
        int v28 = *a2;
        if (v30 != 2 * *a2) {
          break;
        }
        uint64_t v31 = *(void *)(*((void *)a2 + 12) + 8 * v14) + 8 * v27;
        *(void *)(v31 + 8) -= 8;
        ++v27;
        v29 += 8;
        if (v27 >= (int)a2[6]) {
          goto LABEL_16;
        }
      }
      uint64_t v71 = "LoadModelFile: PDF read failed for %s %d\n";
      uint64_t v72 = a1;
      uint64_t v73 = 55022;
      goto LABEL_67;
    }
  }
LABEL_17:
  uint64_t v81 = a1;
  uint64_t v32 = &a2[v9];
  if (v32[51])
  {
    uint64_t v33 = (int *)(v32 + 18);
    uint64_t v34 = heap_Calloc(*(void **)(a1 + 8), v32[18], 8);
    uint64_t v76 = v9;
    uint64_t v35 = &a2[2 * v9];
    *((void *)v35 + 13) = v34;
    int v36 = v35 + 26;
    uint64_t v37 = 2229280778;
    if (!v34) {
      return v37;
    }
    uint64_t v75 = heap_Calloc(*(void **)(v81 + 8), (*a2 * *v33), 8);
    if (!v75) {
      return v37;
    }
    uint64_t v9 = v76;
    if (*v33 >= 1)
    {
      uint64_t v38 = 0;
      uint64_t v39 = &a2[v76 + 1];
      int v40 = (uint64_t *)&a2[2 * v76 + 8];
      uint64_t v79 = a4;
      while (1)
      {
        uint64_t v41 = (unsigned int *)(a4 + 24 * v38);
        if (UNICORN__xfread_BET5(v39, 4u, 1, v41) != 1 || *v39 < 0)
        {
          uint64_t v71 = "LoadModelFile: the vector size is illegal for %s %d\n";
          uint64_t v72 = v81;
          uint64_t v73 = 55023;
          goto LABEL_67;
        }
        int v42 = UNICORN__xfread2ptr_BET5(v40, 4u, *a2, v41);
        if (v42 != *a2)
        {
          uint64_t v71 = "LoadModelFile: reading the number of PDFs failed for %s %d\n";
          uint64_t v72 = v81;
          uint64_t v73 = 55024;
          goto LABEL_67;
        }
        uint64_t v43 = *v40;
        *v40 -= 8;
        if (v42 > 0) {
          break;
        }
        *(void *)(*v36 + 8 * v38) = v75 + 8 * v42 * (int)v38;
        *(void *)(*v36 + 8 * v38) -= 16;
LABEL_34:
        ++v38;
        uint64_t v9 = v76;
        a4 = v79;
        if (v38 >= *v33) {
          goto LABEL_35;
        }
      }
      uint64_t v44 = 0;
      do
      {
        if ((*(_DWORD *)(v43 + 4 * v44) & 0x80000000) != 0)
        {
          uint64_t v71 = "LoadModelFile: the number of PDFs for %s at state %d is illegal\n";
          uint64_t v72 = v81;
          uint64_t v73 = 55025;
          goto LABEL_67;
        }
        ++v44;
      }
      while ((v42 + 2) - 2 != v44);
      *(void *)(*v36 + 8 * v38) = v75 + 8 * v42 * (int)v38;
      *(void *)(*v36 + 8 * v38) -= 16;
      uint64_t v45 = *v40;
      int v46 = *v39;
      uint64_t v47 = 16;
      uint64_t v48 = 2;
      while (1)
      {
        int v49 = UNICORN__xfread2ptr_BET5((void *)(*(void *)(*v36 + 8 * v38) + v47), 4u, (2 * *(_DWORD *)(v45 + 4 * v48) * v46), v41);
        uint64_t v45 = *v40;
        int v46 = *v39;
        if (v49 != 2 * *(_DWORD *)(*v40 + 4 * v48) * *v39) {
          break;
        }
        v47 += 8;
        BOOL v50 = v48++ <= (int)*a2;
        if (!v50) {
          goto LABEL_34;
        }
      }
      uint64_t v71 = "LoadModelFile: PDF read failed for %s %d\n";
      uint64_t v72 = v81;
      uint64_t v73 = 55026;
      goto LABEL_67;
    }
  }
LABEL_35:
  if (!v32[56]) {
    return 0;
  }
  int32x4_t v51 = &a2[v9];
  unsigned int v53 = v51[18];
  uint64_t v52 = v51 + 18;
  uint64_t v54 = heap_Calloc(*(void **)(v81 + 8), v53, 8);
  uint64_t v55 = v9;
  unsigned int v56 = &a2[2 * v9];
  *((void *)v56 + 18) = v54;
  int v57 = v56 + 36;
  uint64_t v37 = 2229280778;
  if (v54)
  {
    uint64_t v58 = heap_Calloc(*(void **)(v81 + 8), (*a2 * *v52), 8);
    if (v58)
    {
      if (*v52 >= 1)
      {
        uint64_t v77 = v58;
        uint64_t v80 = a4;
        uint64_t v59 = 0;
        size_t v60 = &a2[v55 + 1];
        uint64_t v61 = (uint64_t *)&a2[2 * v55 + 8];
        while (1)
        {
          unsigned int v62 = (unsigned int *)(a4 + 24 * v59);
          if (UNICORN__xfread_BET5(&a2[v55 + 1], 4u, 1, v62) != 1 || *v60 < 0)
          {
            uint64_t v71 = "LoadModelFile: the vector size is illegal for %s %d\n";
            uint64_t v72 = v81;
            uint64_t v73 = 55027;
            goto LABEL_67;
          }
          int v63 = UNICORN__xfread2ptr_BET5(&a2[2 * v55 + 8], 4u, *a2, v62);
          if (v63 != *a2)
          {
            uint64_t v71 = "LoadModelFile: reading the number of PDFs failed for %s %d\n";
            uint64_t v72 = v81;
            uint64_t v73 = 55028;
            goto LABEL_67;
          }
          uint64_t v64 = *v61;
          *v61 -= 8;
          if (v63 > 0) {
            break;
          }
          *(void *)(*v57 + 8 * v59) = v77 + 8 * v63 * (int)v59;
          *(void *)(*v57 + 8 * v59) -= 16;
LABEL_52:
          uint64_t v37 = 0;
          ++v59;
          a4 = v80;
          if (v59 >= *v52) {
            return v37;
          }
        }
        uint64_t v65 = 0;
        do
        {
          if ((*(_DWORD *)(v64 + 4 * v65) & 0x80000000) != 0)
          {
            uint64_t v71 = "LoadModelFile: the number of PDFs for %s at state %d is illegal\n";
            uint64_t v72 = v81;
            uint64_t v73 = 55029;
            goto LABEL_67;
          }
          ++v65;
        }
        while ((v63 + 2) - 2 != v65);
        *(void *)(*v57 + 8 * v59) = v77 + 8 * v63 * (int)v59;
        *(void *)(*v57 + 8 * v59) -= 16;
        uint64_t v66 = *v61;
        int v67 = *v60;
        uint64_t v68 = 16;
        uint64_t v69 = 2;
        while (1)
        {
          int v70 = UNICORN__xfread2ptr_BET5((void *)(*(void *)(*v57 + 8 * v59) + v68), 4u, (4 * *(_DWORD *)(v66 + 4 * v69) * v67), v62);
          uint64_t v66 = *v61;
          int v67 = *v60;
          if (v70 != 4 * *(_DWORD *)(*v61 + 4 * v69) * *v60) {
            break;
          }
          v68 += 8;
          BOOL v50 = v69++ <= (int)*a2;
          if (!v50) {
            goto LABEL_52;
          }
        }
        uint64_t v71 = "LoadModelFile: PDF read failed for %s %d\n";
        uint64_t v72 = v81;
        uint64_t v73 = 55030;
LABEL_67:
        UNICORN__log_select_Error(v72, v73, (uint64_t)v71, v18, v19, v20, v21, v22);
        return 2229280772;
      }
      return 0;
    }
  }
  return v37;
}

uint64_t UNICORN__FindDurPDF(int32x2_t *a1, int *a2, int a3, int a4, float a5)
{
  uint64_t v5 = a1[1].i32[0];
  a1[3] = 0;
  a1[4].i32[0] = 0;
  LODWORD(v6) = *a2;
  if (*a2 >= 1)
  {
    uint64_t v7 = *(void *)(*(void *)(*((void *)a2 + 12) + 8 * a4) + 8 * v5);
    int32x2_t v8 = a1[2];
    uint64_t v9 = 2;
    __asm { FMOV            V3.2D, #0.5 }
    float v15 = 0.0;
    do
    {
      float v16 = *(float *)(v7 + 4 * ((int)v9 + (int)v6));
      float v17 = *(float *)(v7 + 4 * v9) + (float)(v16 * a5);
      if (v17 < 0.0) {
        float v17 = 0.0;
      }
      if (a2[62])
      {
        if (v17 > 4000.0) {
          float v17 = 4000.0;
        }
      }
      else if (v17 > 4000.0)
      {
        float v17 = v15 * 0.5;
      }
      v18.f32[0] = v17 + (float)a3;
      v18.i32[1] = sqrtf(v16);
      int32x2_t v19 = vmovn_s64(vcvtq_s64_f64(vaddq_f64(vcvtq_f64_f32(v18), _Q3)));
      *(_DWORD *)(*(void *)&v8 + 4 * v9) = v19.i32[0];
      a1[3] = vadd_s32(a1[3], v19);
      a3 += (int)(float)(v17 - (float)*(int *)(*(void *)&v8 + 4 * v9));
      uint64_t v6 = *a2;
      float v15 = v17;
    }
    while (v9++ <= v6);
  }
  return 0;
}

uint64_t UNICORN__FindContPDF(int a1, int a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5 = (void *)(a3 + 8 * a1);
  uint64_t v6 = *(int *)(a4 + 4 * a1 + 4);
  uint64_t v7 = *(void *)(*(void *)(*(void *)(a4 + 8 * a1 + 104) + 8 * a5) + 8 * a2)
     + 4 * (2 * *(_DWORD *)(v5[7] + 4 * a2) - 2) * (int)v6;
  *(void *)(v5[12] + 8 * a2) = v7;
  *(void *)(v5[17] + 8 * a2) = v7 + 4 * v6;
  return 0;
}

uint64_t UNICORN__FindMsdPDF(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v6 = a4 + 4 * a1;
  int v9 = *(_DWORD *)(v6 + 4);
  uint64_t v7 = (int *)(v6 + 4);
  int v8 = v9;
  if (v9 >= 1)
  {
    int v10 = 0;
    uint64_t v11 = a2;
    uint64_t v12 = *(void *)(*(void *)(*(void *)(a4 + 8 * a1 + 144) + 8 * a6) + 8 * a2)
        + 4 * (4 * *(_DWORD *)(*(void *)(a3 + 8 * a1 + 56) + 4 * a2) - 4) * v8;
    uint64_t v13 = a3 + 8 * a1;
    uint64_t v14 = a5 + 4 * a1;
    float v15 = (void *)(v13 + 96);
    float v16 = (void *)(v13 + 136);
    float v17 = (int *)(v14 + 184);
    float32x2_t v18 = (float *)(v14 + 1128);
    uint64_t v19 = 1;
    do
    {
      uint64_t v20 = v12 + 4 * v10;
      uint64_t v21 = *(void *)(*v15 + 8 * v11);
      *(_DWORD *)(v21 + 4 * v19) = *(_DWORD *)v20;
      float v22 = *(float *)(v20 + 4);
      *(float *)(*(void *)(*v16 + 8 * v11) + 4 * v19) = v22;
      float v23 = *(float *)(a5 + 44);
      if (v23 != 0.0 && *v17 == 2) {
        *(float *)(v21 + 4 * v19) = *(float *)(v21 + 4 * v19) + (float)(v22 * v23);
      }
      if (v19 == 1)
      {
        int v24 = *v17;
        if (*v17 == 2) {
          *(_DWORD *)(*(void *)(a3 + 184) + 4 * v11) = *(_DWORD *)(v20 + 8);
        }
        float v25 = *(float *)(v20 + 8);
        uint64_t v26 = 1 << v24;
        uint64_t v27 = *(void *)(a3 + 176);
        if (v25 <= *v18) {
          char v28 = *(unsigned char *)(v27 + v11) & ~(_BYTE)v26;
        }
        else {
          char v28 = *(unsigned char *)(v27 + v11) | v26;
        }
        *(unsigned char *)(v27 + v11) = v28;
      }
      v10 += 4;
    }
    while (v19++ < *v7);
  }
  return 0;
}

uint64_t UNICORN__FindDurPDF_PerStateRho(uint64_t a1, int *a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v6 = *(int *)(a1 + 8);
  *(_DWORD *)(a1 + 24) = 0;
  LODWORD(v7) = *a2;
  if (*a2 >= 1)
  {
    uint64_t v13 = 0;
    uint64_t v14 = a5;
    float v15 = 0.0;
    do
    {
      uint64_t v16 = *(void *)(*(void *)(*((void *)a2 + 12) + 8 * v14) + 8 * v6);
      float v17 = *(float *)(v16 + 4 * v13 + 8);
      float v18 = *(float *)(a3 + 4 * v13);
      if (v18 != 0.0)
      {
        float v19 = *(float *)(v16 + 4 * (v13 + (int)v7) + 8);
        if (a6) {
          float v19 = UNICORN__bet5_finv(v19);
        }
        float v17 = v17 + (float)(v18 * sqrtf(v19));
      }
      if (v17 >= 0.0) {
        float v20 = v17;
      }
      else {
        float v20 = 0.0;
      }
      if (a2[62])
      {
        if (v20 > 4000.0) {
          float v20 = 4000.0;
        }
      }
      else if (v20 > 4000.0)
      {
        float v20 = v15 * 0.5;
      }
      double v21 = (float)(v20 + (float)a4) + 0.5;
      uint64_t v22 = *(void *)(a1 + 16) + 4 * v13;
      *(_DWORD *)(v22 + 8) = (int)v21;
      *(_DWORD *)(a1 + 24) += (int)v21;
      a4 += (int)(float)(v20 - (float)*(int *)(v22 + 8));
      uint64_t v7 = *a2;
      uint64_t v23 = v13 + 2;
      ++v13;
      float v15 = v20;
    }
    while (v23 <= v7);
  }
  return 0;
}

uint64_t UNICORN__FindLF0PDF_PerStateRho(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, float a8)
{
  uint64_t v8 = a4 + 4 * a1;
  int v11 = *(_DWORD *)(v8 + 4);
  int v10 = (int *)(v8 + 4);
  int v9 = v11;
  if (v11 >= 1)
  {
    uint64_t v14 = a2;
    uint64_t v15 = *(void *)(*(void *)(*(void *)(a4 + 8 * a1 + 144) + 8 * a6) + 8 * a2)
        + 4 * (4 * *(_DWORD *)(*(void *)(a3 + 8 * a1 + 56) + 4 * a2) - 4) * v9;
    uint64_t v16 = a3 + 8 * a1;
    uint64_t v17 = a5 + 4 * a1;
    float v18 = (void *)(v16 + 96);
    float v19 = (void *)(v16 + 136);
    float v20 = (float *)(v17 + 1128);
    double v21 = (_DWORD *)(v17 + 184);
    uint64_t v22 = 1;
    do
    {
      uint64_t v23 = (float *)(v15 + 4 * (4 * (int)v22 - 4));
      int v24 = (float *)(*(void *)(*v18 + 8 * v14) + 4 * v22);
      *int v24 = *v23;
      float v25 = v23[1];
      *(float *)(*(void *)(*v19 + 8 * v14) + 4 * v22) = v25;
      if (a8 != 0.0)
      {
        if (a7)
        {
          float v26 = sqrtf(UNICORN__bet5_finv(v25));
          int v24 = (float *)(*(void *)(*v18 + 8 * v14) + 4 * v22);
        }
        else
        {
          float v26 = sqrtf(v25);
        }
        *int v24 = *v24 + (float)(v26 * a8);
      }
      if (v22 == 1)
      {
        *(float *)(*(void *)(a3 + 184) + 4 * v14) = v23[2];
        uint64_t v27 = 1 << *v21;
        uint64_t v28 = *(void *)(a3 + 176);
        if (v23[2] <= *v20) {
          char v29 = *(unsigned char *)(v28 + v14) & ~(_BYTE)v27;
        }
        else {
          char v29 = *(unsigned char *)(v28 + v14) | v27;
        }
        *(unsigned char *)(v28 + v14) = v29;
      }
    }
    while (v22++ < *v10);
  }
  return 0;
}

void *UNICORN__DeInitModelSet(uint64_t a1, char *__b)
{
  if (*((int *)__b + 61) >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = (uint64_t **)(__b + 144);
    uint64_t v6 = __b + 224;
    do
    {
      if (*(v6 - 10))
      {
        uint64_t v7 = (void *)*((void *)__b + 12);
        if (v7)
        {
          if (*v7)
          {
            *v7 += 8;
            heap_Free(*(void **)(a1 + 8), **((void **)__b + 12));
            uint64_t v7 = (void *)*((void *)__b + 12);
          }
          heap_Free(*(void **)(a1 + 8), (uint64_t)v7);
          *((void *)__b + 12) = 0;
        }
      }
      if (*(v6 - 5))
      {
        uint64_t v8 = *(v5 - 5);
        if (v8)
        {
          if (*v8)
          {
            *v8 += 16;
            heap_Free(*(void **)(a1 + 8), **(v5 - 5));
            uint64_t v8 = *(v5 - 5);
          }
          heap_Free(*(void **)(a1 + 8), (uint64_t)v8);
        }
      }
      if (*v6)
      {
        int v9 = *v5;
        if (*v5)
        {
          if (*v9)
          {
            *v9 += 16;
            heap_Free(*(void **)(a1 + 8), **v5);
            int v9 = *v5;
          }
          heap_Free(*(void **)(a1 + 8), (uint64_t)v9);
        }
      }
      ++v4;
      ++v5;
      ++v6;
    }
    while (v4 < *((int *)__b + 61));
  }

  return cstdlib_memset(__b, 0, 0x100uLL);
}

uint64_t UNICORN__InitUttModel(uint64_t a1, char *__b, int *a3, unsigned int a4)
{
  uint64_t v8 = 2229280778;
  cstdlib_memset(__b, 0, 0x168uLL);
  *(void *)int8x16_t __b = a1;
  *((void *)__b + 1) = a3;
  *((_DWORD *)__b + 84) = a4;
  *((_DWORD *)__b + 87) = *a3 * a4;
  uint64_t v9 = heap_Calloc(*(void **)(a1 + 8), a4, 312);
  *((void *)__b + 41) = v9;
  if (v9)
  {
    uint64_t v10 = heap_Calloc(*(void **)(a1 + 8), (*a3 * *((_DWORD *)__b + 84)), 4);
    *((void *)__b + 4) = v10;
    if (v10)
    {
      uint64_t v11 = heap_Calloc(*(void **)(a1 + 8), (*a3 * *((_DWORD *)__b + 84)), 4);
      *((void *)__b + 26) = v11;
      if (v11)
      {
        uint64_t v12 = heap_Calloc(*(void **)(a1 + 8), (*a3 * *((_DWORD *)__b + 84)), 1);
        *((void *)__b + 24) = v12;
        if (v12)
        {
          uint64_t v13 = heap_Calloc(*(void **)(a1 + 8), (*a3 * *((_DWORD *)__b + 84)), 4);
          *((void *)__b + 25) = v13;
          if (v13)
          {
            int v14 = a3[61];
            if (v14 >= 1)
            {
              uint64_t v15 = 0;
              uint64_t v16 = a3 + 56;
              uint64_t v17 = __b + 112;
              do
              {
                if (!*(v16 - 10))
                {
                  uint64_t v18 = heap_Calloc(*(void **)(a1 + 8), (*a3 * *((_DWORD *)__b + 84)), 4);
                  *(v17 - 5) = v18;
                  if (!v18) {
                    return v8;
                  }
                  float v19 = *(void **)(a1 + 8);
                  int v20 = *((_DWORD *)__b + 84);
                  double v21 = *v16
                      ? UNICORN__int32_ccalloc(v19, 2 * v20 * *a3, *(v16 - 55) + 1)
                      : (void *)heap_Calloc(v19, (2 * v20 * *a3), 8);
                  *uint64_t v17 = v21;
                  if (!v21) {
                    return v8;
                  }
                  v17[5] = &v21[*a3 * *((_DWORD *)__b + 84)];
                  int v14 = a3[61];
                }
                ++v15;
                ++v16;
                ++v17;
              }
              while (v15 < v14);
            }
            uint64_t v22 = *((unsigned int *)__b + 84);
            if ((int)v22 >= 1)
            {
              uint64_t v23 = 0;
              uint64_t v26 = *a3;
              float v25 = a3 + 46;
              uint64_t v24 = v26;
              uint64_t v27 = 96;
              do
              {
                uint64_t v28 = *((void *)__b + 41);
                uint64_t v29 = v28 + 312 * v23;
                *(_DWORD *)uint64_t v29 = v23;
                uint64_t v30 = v23 * v24;
                uint64_t v31 = *((void *)__b + 26) + 4 * v23 * v24;
                uint64_t v32 = *((void *)__b + 24) + v23 * v24;
                uint64_t v33 = *((void *)__b + 25) + 4 * v23 * v24;
                *(void *)(v29 + 16) = *((void *)__b + 4) + 4 * v23 * v24 - 8;
                *(void *)(v29 + 176) = v32 - 2;
                *(void *)(v29 + 184) = v33 - 8;
                *(void *)(v29 + 192) = v31 - 8;
                if (v14 >= 1)
                {
                  uint64_t v34 = (uint64_t *)(v28 + v27);
                  uint64_t v35 = __b + 112;
                  uint64_t v36 = v14;
                  uint64_t v37 = v25;
                  do
                  {
                    if (!*v37++)
                    {
                      uint64_t v39 = *(v35 - 5) + 4 * v30;
                      *(v34 - 5) = v39;
                      uint64_t v40 = *v35 + 8 * v30;
                      *uint64_t v34 = v40;
                      uint64_t v41 = v35[5] + 8 * v30;
                      *(v34 - 5) = v39 - 8;
                      *uint64_t v34 = v40 - 16;
                      v34[5] = v41 - 16;
                    }
                    ++v34;
                    ++v35;
                    --v36;
                  }
                  while (v36);
                }
                ++v23;
                v27 += 312;
              }
              while (v23 != v22);
            }
            return 0;
          }
        }
      }
    }
  }
  return v8;
}

void *UNICORN__DeInitUttModel(void *result)
{
  uint64_t v1 = result;
  if (*result && result[41])
  {
    uint64_t v2 = result[1];
    uint64_t v3 = result[4];
    if (v3)
    {
      heap_Free(*(void **)(*result + 8), v3);
      v1[4] = 0;
    }
    uint64_t v4 = v1[26];
    if (v4)
    {
      heap_Free(*(void **)(*v1 + 8), v4);
      v1[26] = 0;
    }
    uint64_t v5 = v1[24];
    if (v5)
    {
      heap_Free(*(void **)(*v1 + 8), v5);
      v1[24] = 0;
    }
    uint64_t v6 = v1[25];
    if (v6)
    {
      heap_Free(*(void **)(*v1 + 8), v6);
      v1[25] = 0;
    }
    if (*(int *)(v2 + 244) >= 1)
    {
      uint64_t v7 = 0;
      do
      {
        if (!*(_DWORD *)(v2 + 184 + 4 * v7))
        {
          uint64_t v8 = &v1[v7];
          uint64_t v9 = v8[9];
          if (v9)
          {
            heap_Free(*(void **)(*v1 + 8), v9);
            v8[9] = 0;
          }
          uint64_t v10 = v8[14];
          if (v10)
          {
            heap_Free(*(void **)(*v1 + 8), v10);
            v8[14] = 0;
          }
        }
        ++v7;
      }
      while (v7 < *(int *)(v2 + 244));
    }
    uint64_t result = heap_Free(*(void **)(*v1 + 8), v1[41]);
  }
  v1[41] = 0;
  *((_DWORD *)v1 + 84) = 0;
  void *v1 = 0;
  return result;
}

void *UNICORN__DeInitMSDUttModel(void *result, int a2)
{
  uint64_t v2 = result[1];
  if (!*(_DWORD *)(v2 + 4 * a2 + 184))
  {
    uint64_t v3 = result;
    uint64_t v4 = a2;
    uint64_t v5 = &result[a2];
    uint64_t v6 = v5[9];
    if (v6)
    {
      uint64_t result = heap_Free(*(void **)(*result + 8), v6);
      v5[9] = 0;
    }
    uint64_t v9 = (void *)v5[14];
    uint64_t v8 = (uint64_t **)(v5 + 14);
    uint64_t v7 = v9;
    if (*(_DWORD *)(v2 + 4 * v4 + 224))
    {
      *v7 += 4;
      uint64_t result = UNICORN__int32_free(*(void **)(*v3 + 8), *v8);
    }
    else
    {
      if (!v7) {
        return result;
      }
      uint64_t result = heap_Free(*(void **)(*v3 + 8), (uint64_t)v7);
    }
    *uint64_t v8 = 0;
  }
  return result;
}

uint64_t UNICORN__InitModelSet(int a1, char *__b, _DWORD *a3)
{
  cstdlib_memset(__b, 0, 0x100uLL);
  int v5 = a3[33];
  *((_DWORD *)__b + 61) = v5;
  if (v5 >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = __b + 204;
    uint64_t v8 = 287;
    do
    {
      *((_DWORD *)v7 - 33) = a3[61];
      uint64_t v9 = __b + 184;
      if (v8 != 287)
      {
        if (a3[287]) {
          uint64_t v9 = &__b[4 * v6 + 224];
        }
        else {
          uint64_t v9 = v7;
        }
      }
      ++a3;
      *(_DWORD *)uint64_t v9 = 1;
      ++v6;
      uint64_t v10 = v8 - 286;
      ++v8;
      v7 += 4;
    }
    while (v10 < *((int *)__b + 61));
  }
  return 0;
}

uint64_t UNICORN__meancpy(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 16);
  if ((int)v1 >= 1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = *(unsigned int *)(result + 20);
    do
    {
      if ((int)v3 >= 1)
      {
        uint64_t v4 = *(uint64_t **)(result + 72);
        int v5 = *(uint64_t **)(result + 40);
        uint64_t v6 = v3;
        do
        {
          uint64_t v7 = *v4++;
          int v8 = *(_DWORD *)(v7 + 4 * v2);
          uint64_t v9 = *v5++;
          *(_DWORD *)(v9 + 4 * v2) = v8;
          --v6;
        }
        while (v6);
      }
      ++v2;
    }
    while (v2 != v1);
  }
  return result;
}

float UNICORN__ConstW_Calc_R_and_r(uint64_t a1, int a2)
{
  uint64_t v3 = *(float ***)(a1 + 96);
  uint64_t v2 = *(float **)(a1 + 104);
  uint64_t v4 = *(uint64_t **)(a1 + 72);
  int v5 = *(uint64_t **)(a1 + 80);
  int v6 = *(_DWORD *)(a1 + 16);
  int v7 = *(_DWORD *)(a1 + 20);
  uint64_t v8 = a2;
  uint64_t v9 = *v5;
  uint64_t v10 = v5[1];
  float v11 = *(float *)(*v5 + 4 * a2);
  uint64_t v12 = *v4;
  uint64_t v13 = v4[1];
  float v14 = v11 * *(float *)(*v4 + 4 * a2);
  *uint64_t v2 = v14;
  float v15 = *(float *)(v10 + 4 * (v6 + a2));
  uint64_t v16 = v6 + a2;
  float v17 = v14 + (float)((float)(v15 * -0.5) * *(float *)(v13 + 4 * v16));
  *uint64_t v2 = v17;
  uint64_t v18 = a2 + 2 * v6;
  float v19 = *(float *)(v9 + 4 * v18);
  float v20 = v17 + (float)((float)(v19 * -2.0) * *(float *)(v12 + 4 * v18));
  *uint64_t v2 = v20;
  float v21 = *(float *)(v10 + 4 * v18);
  *uint64_t v2 = v20 + (float)(v21 * *(float *)(v13 + 4 * v18));
  uint64_t v22 = *v3;
  *uint64_t v22 = v11 + (float)((float)((float)(v19 * 4.0) + (float)(v15 * 0.25)) + v21);
  v22[1] = (float)(v19 * -2.0) + (float)(v21 * -2.0);
  v22[2] = v21 + (float)(v15 * -0.25);
  if (v7 < 3)
  {
    LODWORD(v23) = 1;
  }
  else
  {
    uint64_t v23 = (v7 - 1);
    uint64_t v24 = v3 + 1;
    float v25 = v2 + 1;
    uint64_t v26 = v5 + 2;
    uint64_t v27 = v4 + 2;
    uint64_t v28 = v23 - 1;
    do
    {
      float v29 = *(float *)(v10 + 4 * v8);
      float v30 = v29 * *(float *)(v13 + 4 * v8);
      *float v25 = v30;
      uint64_t v31 = *(v26 - 2);
      float v32 = *(float *)(v31 + 4 * v16);
      uint64_t v33 = *(v27 - 2);
      float v34 = v30 + (float)((float)(v32 * 0.5) * *(float *)(v33 + 4 * v16));
      *float v25 = v34;
      uint64_t v36 = *v26++;
      uint64_t v35 = v36;
      float v37 = *(float *)(v36 + 4 * v16);
      uint64_t v39 = *v27++;
      uint64_t v38 = v39;
      float v40 = v34 + (float)((float)(v37 * -0.5) * *(float *)(v39 + 4 * v16));
      *float v25 = v40;
      float v41 = *(float *)(v31 + 4 * v18);
      float v42 = v40 + (float)(v41 * *(float *)(v33 + 4 * v18));
      *float v25 = v42;
      float v43 = *(float *)(v10 + 4 * v18);
      float v44 = v42 + (float)((float)(v43 * -2.0) * *(float *)(v13 + 4 * v18));
      *float v25 = v44;
      float v45 = *(float *)(v35 + 4 * v18);
      *v25++ = v44 + (float)(v45 * *(float *)(v39 + 4 * v18));
      int v46 = *v24++;
      *int v46 = (float)((float)((float)((float)(v29 + (float)(v32 * 0.25)) + (float)(v37 * 0.25)) + v41) + v45)
           + (float)(v43 * 4.0);
      v46[1] = (float)(v45 * -2.0) + (float)(v43 * -2.0);
      v46[2] = v45 + (float)(v37 * -0.25);
      uint64_t v13 = v38;
      uint64_t v10 = v35;
      --v28;
    }
    while (v28);
    uint64_t v10 = v5[v23];
    uint64_t v13 = v4[v23];
  }
  float v47 = *(float *)(v10 + 4 * v8);
  float v48 = v47 * *(float *)(v13 + 4 * v8);
  v2[v23] = v48;
  uint64_t v49 = v5[(int)v23 - 1];
  float v50 = *(float *)(v49 + 4 * v16);
  uint64_t v51 = v4[(int)v23 - 1];
  float v52 = v48 + (float)((float)(v50 * 0.5) * *(float *)(v51 + 4 * v16));
  v2[v23] = v52;
  float v53 = *(float *)(v49 + 4 * v18);
  float v54 = v52 + (float)(v53 * *(float *)(v51 + 4 * v18));
  v2[v23] = v54;
  float v55 = *(float *)(v10 + 4 * v18);
  v2[v23] = v54 + (float)((float)(v55 * -2.0) * *(float *)(v13 + 4 * v18));
  unsigned int v56 = v3[v23];
  float result = v47 + (float)((float)(v53 + (float)(v50 * 0.25)) + (float)(v55 * 4.0));
  *unsigned int v56 = result;
  v56[1] = 0.0;
  v56[2] = 0.0;
  return result;
}

float UNICORN__ConstW_Cholesky(uint64_t a1, double a2)
{
  uint64_t v2 = *(void *)(a1 + 96);
  uint64_t v4 = *(_DWORD **)v2;
  uint64_t v3 = *(float **)(v2 + 8);
  LODWORD(a2) = **(_DWORD **)v2;
  float32x2_t v5 = vdiv_f32(*(float32x2_t *)(*(void *)v2 + 4), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a2, 0));
  *(float32x2_t *)(v4 + 1) = v5;
  float v6 = v3[1];
  *(float *)&a2 = *v3 + (float)((float)((float)-v5.f32[0] * v5.f32[0]) * *(float *)&a2);
  *uint64_t v3 = *(float *)&a2;
  float v7 = (float)(v6 + (float)((float)-(float)(*((float *)v4 + 1) * *((float *)v4 + 2)) * *(float *)v4)) / *(float *)&a2;
  float v8 = v3[2] / *(float *)&a2;
  v3[1] = v7;
  v3[2] = v8;
  uint64_t v9 = *(unsigned int *)(a1 + 20);
  if ((int)v9 >= 3)
  {
    uint64_t v10 = (float **)(v2 + 16);
    uint64_t v11 = v9 - 2;
    do
    {
      uint64_t v12 = *v10;
      float v13 = (*v10)[1];
      float v14 = **v10 + (float)((float)-(float)(v7 * v7) * *(float *)&a2);
      *uint64_t v12 = v14;
      *(float *)&a2 = v14 + (float)((float)-(float)((*(v10 - 2))[2] * (*(v10 - 2))[2]) * **(v10 - 2));
      *uint64_t v12 = *(float *)&a2;
      float v7 = (float)(v13 + (float)((float)-(float)(v3[1] * v3[2]) * *v3)) / *(float *)&a2;
      float v15 = v12[2] / *(float *)&a2;
      v12[1] = v7;
      v12[2] = v15;
      ++v10;
      uint64_t v3 = v12;
      --v11;
    }
    while (v11);
  }
  return *(float *)&a2;
}

float UNICORN__ConstW_Cholesky_forward(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 96);
  uint64_t v1 = *(float **)(a1 + 104);
  uint64_t v3 = *(float **)(a1 + 88);
  float v4 = *v1;
  *uint64_t v3 = *v1;
  uint64_t v5 = *v2;
  float result = v1[1] - (float)(*(float *)(*v2 + 4) * v4);
  v3[1] = result;
  uint64_t v7 = *(unsigned int *)(a1 + 20);
  if ((int)v7 >= 3)
  {
    float v8 = v3 + 2;
    uint64_t v9 = v1 + 2;
    uint64_t v10 = v2 + 1;
    uint64_t v11 = v7 - 2;
    do
    {
      float v12 = *v9++;
      float v13 = v12;
      float v14 = *(float *)(v5 + 8);
      uint64_t v15 = *v10++;
      uint64_t v5 = v15;
      float result = v13 - (float)((float)(v14 * *(v8 - 2)) + (float)(*(float *)(v15 + 4) * result));
      *v8++ = result;
      --v11;
    }
    while (v11);
  }
  return result;
}

float UNICORN__ConstW_Cholesky_backward(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 20);
  uint64_t v3 = *(void *)(a1 + 88);
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = *(void *)(a1 + 40);
  float v6 = *(float *)(v3 + 4 * (v2 - 1)) / **(float **)(v4 + 8 * (v2 - 1));
  *(float *)(*(void *)(v5 + 8 * (v2 - 1)) + 4 * a2) = v6;
  uint64_t v7 = *(float **)(v4 + 8 * (v2 - 2));
  float result = (float)(*(float *)(v3 + 4 * (v2 - 2)) / *v7) - (float)(v7[1] * v6);
  *(float *)(*(void *)(v5 + 8 * (v2 - 2)) + 4 * a2) = result;
  BOOL v9 = __OFSUB__(v2, 3);
  uint64_t v10 = (v2 - 3);
  if ((int)v10 < 0 == v9)
  {
    uint64_t v11 = (void *)(v5 + 8 * v10 + 16);
    float v12 = v11;
    do
    {
      uint64_t v13 = *--v12;
      float result = (float)((float)(*(float *)(v3 + 4 * v10) / **(float **)(v4 + 8 * v10))
                     - (float)(*(float *)(*(void *)(v4 + 8 * v10) + 4) * *(float *)(v13 + 4 * a2)))
             - (float)(*(float *)(*(void *)(v4 + 8 * v10) + 8) * *(float *)(*v11 + 4 * a2));
      *(float *)(*(v11 - 2) + 4 * a2) = result;
      --v10;
      uint64_t v11 = v12;
    }
    while (v10 != -1);
  }
  return result;
}

void UNICORN__mlpg2(uint64_t a1, int a2)
{
  if (*(int *)(a1 + 20) < 2)
  {
    UNICORN__meancpy(a1);
  }
  else
  {
    *(float *)&double v4 = UNICORN__ConstW_Calc_R_and_r(a1, a2);
    UNICORN__ConstW_Cholesky(a1, v4);
    UNICORN__ConstW_Cholesky_forward(a1);
    UNICORN__ConstW_Cholesky_backward(a1, a2);
  }
}

char *UNICORN__heap_StrDup(void *a1, char *__s)
{
  if (!__s) {
    return 0;
  }
  int v4 = cstdlib_strlen(__s);
  uint64_t v5 = (char *)heap_Calloc(a1, (v4 + 1), 1);
  float v6 = v5;
  if (v5) {
    cstdlib_strcpy(v5, __s);
  }
  return v6;
}

uint64_t UNICORN__xfread_BET5(void *a1, unsigned int a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v5 = a3;
  uint64_t v6 = *a4;
  unsigned int v7 = a4[4];
  if (v6 + a3 * a2 > v7) {
    uint64_t v5 = (v7 - v6) / a2;
  }
  if (v5)
  {
    size_t v8 = v5 * a2;
    cstdlib_memcpy(a1, (const void *)(*((void *)a4 + 1) + v6), v8);
    *a4 += v8;
  }
  return v5;
}

uint64_t UNICORN__xfread2ptr_BET5(void *a1, unsigned int a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v4 = *a4;
  if (a2 >= 2 && v4 % a2) {
    return 0;
  }
  unsigned int v5 = a4[4];
  if (v4 + a3 * a2 > v5) {
    a3 = (v5 - v4) / a2;
  }
  if (a3)
  {
    *a1 = *((void *)a4 + 1) + v4;
    *a4 = v4 + a3 * a2;
  }
  return a3;
}

uint64_t UNICORN__log_select_Diag(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = a3 - 1;
  do
    int v4 = *(unsigned __int8 *)++v3;
  while (v4 == 10);
  return log_VOutText(*(void *)(a1 + 32), (uint64_t)"SELECT_BET5", (a2 + 2), 0, v3);
}

uint64_t UNICORN__log_select_Error(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return log_OutPublic(*(void *)(a1 + 32), (uint64_t)"SELECT_BET5", a2, 0, a5, a6, a7, a8, v9);
}

uint64_t UNICORN__log_select_GetLogLevel(uint64_t a1)
{
  unsigned int LogLevel = log_GetLogLevel(a1);
  if (LogLevel >= 3) {
    return LogLevel - 2;
  }
  else {
    return 0;
  }
}

float UNICORN__bet5_finv(float a1)
{
  float v1 = 0.0;
  if (a1 < 1.0e19 && a1 > -1.0e19)
  {
    if (a1 > 1.0e-19 || a1 < 0.0)
    {
      if (a1 < -1.0e-19 || a1 >= 0.0) {
        return 1.0 / a1;
      }
      else {
        return -1.0e38;
      }
    }
    else
    {
      return 1.0e38;
    }
  }
  return v1;
}

void *UNICORN__ddcalloc(void *a1, unsigned int a2, int a3)
{
  uint64_t v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    uint64_t v7 = a2;
    uint64_t v3 = (void *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      uint64_t v8 = heap_Calloc(a1, a3 * a2, 4);
      *uint64_t v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          uint64_t v9 = 1;
          uint64_t v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

void *UNICORN__ddcalloc_64(void *a1, unsigned int a2, int a3)
{
  uint64_t v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    uint64_t v7 = a2;
    uint64_t v3 = (void *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      uint64_t v8 = heap_Calloc(a1, a3 * a2, 4);
      *uint64_t v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          uint64_t v9 = 1;
          uint64_t v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

void *UNICORN__dd_free(void *result, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

void *UNICORN__dd_free_64(void *result, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

void *UNICORN__ffcalloc(void *a1, unsigned int a2, int a3)
{
  uint64_t v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    uint64_t v7 = a2;
    uint64_t v3 = (void *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      uint64_t v8 = heap_Calloc(a1, a3 * a2, 4);
      *uint64_t v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          uint64_t v9 = 1;
          uint64_t v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

void *UNICORN__ff_free(void *result, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

void *UNICORN__int32_ccalloc(void *a1, unsigned int a2, int a3)
{
  uint64_t v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    uint64_t v7 = a2;
    uint64_t v3 = (void *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      uint64_t v8 = heap_Calloc(a1, a3 * a2, 4);
      *uint64_t v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          uint64_t v9 = 1;
          uint64_t v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

void *UNICORN__int32_free(void *result, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

void *UNICORN__iicalloc(void *a1, unsigned int a2, int a3)
{
  uint64_t v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    uint64_t v7 = a2;
    uint64_t v3 = (void *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      uint64_t v8 = heap_Calloc(a1, a3 * a2, 4);
      *uint64_t v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          uint64_t v9 = 1;
          uint64_t v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

void *UNICORN__ii_free(void *result, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

float UNICORN__mul_int32_Q8_24_to_int32(float a1, float a2)
{
  return a1 * a2;
}

float UNICORN__mul_int32_Q8_24_to_Q8_24(float a1, float a2)
{
  return a1 * a2;
}

float UNICORN__mul_Q18_14_Q1_15_to_Q18_14(float a1, float a2)
{
  return a1 * a2;
}

float UNICORN__div_int32_int32_to_Q8_24(float a1, float a2)
{
  return a1 / a2;
}

float UNICORN__div_Q8_24_Q12_20_to_Q8_24(float a1, float a2)
{
  return a1 / a2;
}

float UNICORN__div_Q18_14_Q18_14_to_Q18_14(float a1, float a2)
{
  return a1 / a2;
}

uint64_t UNICORN__InitDWinSet(int a1, void *__b, uint64_t a3)
{
  cstdlib_memset(__b, 0, 0xC8uLL);
  uint64_t v5 = *(unsigned int *)(a3 + 132);
  if ((int)v5 >= 1)
  {
    for (uint64_t i = 0; i != v5; ++i)
    {
      uint64_t v7 = a3 + 4 * i;
      int v10 = *(_DWORD *)(v7 + 224);
      uint64_t v8 = (int *)(v7 + 224);
      int v9 = v10;
      if (v10 >= 1)
      {
        int v11 = 0;
        do
        {
          *((_DWORD *)__b + 10 * i) = v9 + 1;
          ++v11;
          int v9 = *v8;
        }
        while (v11 < *v8);
      }
    }
  }
  return 0;
}

void **UNICORN__DeInitDWinSet(void **result, char *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    for (uint64_t i = 0; i != 200; i += 40)
    {
      uint64_t v5 = &a2[i];
      UNICORN__ii_free(v3[1], *(uint64_t **)&a2[i + 8]);
      uint64_t v6 = *(uint64_t **)&a2[i + 16];
      if (v6)
      {
        if (!*v6 || (heap_Free(v3[1], *v6), **((void **)v5 + 2) = 0, (uint64_t v6 = (uint64_t *)*((void *)v5 + 2)) != 0))
        {
          heap_Free(v3[1], (uint64_t)v6);
          *((void *)v5 + 2) = 0;
        }
      }
    }
    return (void **)cstdlib_memset(a2, 0, 0xC8uLL);
  }
  return result;
}

uint64_t UNICORN__LoadDWinFile(uint64_t a1, uint64_t a2, int a3, unsigned int *a4)
{
  uint64_t v5 = (unsigned int *)(a2 + 40 * a3);
  if (!*v5) {
    return 0;
  }
  uint64_t v9 = 2229280778;
  int v10 = UNICORN__iicalloc(*(void **)(a1 + 8), *v5, 2);
  uint64_t v11 = a2 + 40 * a3;
  *(void *)(v11 + 8) = v10;
  float v12 = (int ***)(v11 + 8);
  if (v10)
  {
    uint64_t v13 = heap_Calloc(*(void **)(a1 + 8), *v5, 8);
    uint64_t v14 = a2 + 40 * a3;
    *(void *)(v14 + 16) = v13;
    uint64_t v15 = (uint64_t **)(v14 + 16);
    if (v13)
    {
      *(void *)**float v12 = 0;
      **uint64_t v15 = heap_Calloc(*(void **)(a1 + 8), 1, 4);
      uint64_t v16 = (_DWORD *)**v15;
      if (v16)
      {
        *uint64_t v16 = 1065353216;
        LODWORD(v17) = *v5;
        if ((int)*v5 <= 1)
        {
LABEL_9:
          uint64_t v27 = a2 + 40 * a3;
          *(_DWORD *)(v27 + 24) = 0;
          uint64_t v28 = (_DWORD *)(v27 + 24);
          v28[1] = 0;
          if ((int)v17 < 1)
          {
            int v30 = 0;
          }
          else
          {
            int v29 = 0;
            int v30 = 0;
            uint64_t v31 = *v12;
            uint64_t v17 = v17;
            do
            {
              float v32 = *v31;
              int v33 = **v31;
              if (v30 > v33)
              {
                _DWORD *v28 = v33;
                int v30 = v33;
              }
              int v34 = v32[1];
              if (v29 < v34)
              {
                v28[1] = v34;
                int v29 = v34;
              }
              ++v31;
              --v17;
            }
            while (v17);
            if (v30 < v29)
            {
              uint64_t v9 = 0;
              *(_DWORD *)(a2 + 40 * a3 + 32) = v29;
              return v9;
            }
          }
          uint64_t v9 = 0;
          *(_DWORD *)(a2 + 40 * a3 + 32) = v30;
          return v9;
        }
        uint64_t v18 = 1;
        uint64_t v19 = 1;
        while (1)
        {
          unsigned int v20 = UNICORN__xfread2ptr_BET5(&(*v15)[v19], 4u, 0xFFFFFFFFLL, a4);
          if (!v20) {
            break;
          }
          (*v15)[v19] += 4 * (v20 >> 1);
          uint64_t v26 = (*v12)[v19];
          *uint64_t v26 = -(v20 >> 1);
          v26[1] = (v20 & 1) + (v20 >> 1) - 1;
          ++v18;
          uint64_t v17 = (int)*v5;
          ++v19;
          a4 += 6;
          if (v18 >= v17) {
            goto LABEL_9;
          }
        }
        UNICORN__log_select_Error(a1, 55019, (uint64_t)"InitDWin: illegal data\n", v21, v22, v23, v24, v25);
        return 2229280772;
      }
    }
  }
  return v9;
}

void *UNICORN__InitSMatrices(uint64_t a1, void *__b)
{
  float result = cstdlib_memset(__b, 0, 0x40uLL);
  *int8x16_t __b = a1;
  return result;
}

double UNICORN__FreeSMatrices(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)a1)
    {
      int v2 = *(uint64_t **)(a1 + 24);
      if (v2)
      {
        if (!*(_DWORD *)(a1 + 8))
        {
          UNICORN__dd_free(*(void **)(*(void *)a1 + 8), v2);
          UNICORN__dd_free_64(*(void **)(*(void *)a1 + 8), *(uint64_t **)(a1 + 48));
          uint64_t v3 = *(void *)(a1 + 40);
          if (v3) {
            heap_Free(*(void **)(*(void *)a1 + 8), v3);
          }
        }
        *(_DWORD *)(a1 + 60) = 0;
        double result = 0.0;
        *(_OWORD *)(a1 + 44) = 0u;
        *(_OWORD *)(a1 + 28) = 0u;
        *(_OWORD *)(a1 + 12) = 0u;
      }
    }
  }
  return result;
}

uint64_t UNICORN__InitPStreamSM(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  if (a2
    && *(void *)(a2 + 24)
    && *((_DWORD *)a1 + 3) == *(_DWORD *)(a2 + 12)
    && *((_DWORD *)a1 + 5) == *(_DWORD *)(a2 + 16)
    && *((_DWORD *)a1 + 6) == *(_DWORD *)(a2 + 20))
  {
    uint64_t result = 0;
    long long v6 = *(_OWORD *)(a2 + 48);
    long long v8 = *(_OWORD *)a2;
    long long v7 = *(_OWORD *)(a2 + 16);
    *((_OWORD *)a1 + 5) = *(_OWORD *)(a2 + 32);
    *((_OWORD *)a1 + 6) = v6;
    *((_OWORD *)a1 + 3) = v8;
    *((_OWORD *)a1 + 4) = v7;
LABEL_18:
    *((_DWORD *)a1 + 14) = 1;
    return result;
  }
  a1[6] = v4;
  uint64_t v9 = (long long *)(a1 + 6);
  int v10 = *((_DWORD *)a1 + 3);
  *((_DWORD *)a1 + 14) = 0;
  *((_DWORD *)a1 + 15) = v10;
  uint64_t v11 = *(uint64_t *)((char *)a1 + 20);
  a1[8] = v11;
  float v12 = (uint64_t *)a1[9];
  int v13 = v11;
  if (v12)
  {
    UNICORN__dd_free(*(void **)(v4 + 8), v12);
    a1[9] = 0;
    int v13 = *((_DWORD *)a1 + 5);
    int v10 = *((_DWORD *)a1 + 3);
  }
  uint64_t v14 = UNICORN__ddcalloc(*(void **)(v4 + 8), 2 * v13, v10);
  a1[9] = (uint64_t)v14;
  if (!v14) {
    goto LABEL_19;
  }
  uint64_t v15 = *((int *)a1 + 5);
  a1[10] = (uint64_t)&v14[v15];
  uint64_t v16 = (uint64_t *)a1[12];
  if (v16)
  {
    UNICORN__dd_free_64(*(void **)(v4 + 8), v16);
    a1[12] = 0;
    LODWORD(v15) = *((_DWORD *)a1 + 5);
  }
  uint64_t v17 = UNICORN__ddcalloc_64(*(void **)(v4 + 8), v15, *((_DWORD *)a1 + 6));
  a1[12] = (uint64_t)v17;
  if (!v17) {
    goto LABEL_19;
  }
  uint64_t v18 = a1[11];
  if (v18)
  {
    heap_Free(*(void **)(v4 + 8), v18);
    a1[11] = 0;
  }
  uint64_t v19 = heap_Calloc(*(void **)(v4 + 8), (2 * *((_DWORD *)a1 + 5)), 4);
  a1[11] = v19;
  if (v19)
  {
    a1[13] = v19 + 4 * *((int *)a1 + 5);
    if (a2)
    {
      UNICORN__FreeSMatrices(a2);
      uint64_t result = 0;
      long long v20 = *v9;
      long long v21 = *((_OWORD *)a1 + 4);
      long long v22 = *((_OWORD *)a1 + 6);
      *(_OWORD *)(a2 + 32) = *((_OWORD *)a1 + 5);
      *(_OWORD *)(a2 + 48) = v22;
      *(_OWORD *)a2 = v20;
      *(_OWORD *)(a2 + 16) = v21;
      goto LABEL_18;
    }
    return 0;
  }
  else
  {
LABEL_19:
    UNICORN__FreeSMatrices((uint64_t)(a1 + 6));
    return 2229280778;
  }
}

double UNICORN__FreePStreamSM(uint64_t a1)
{
  return UNICORN__FreeSMatrices(a1 + 48);
}

uint64_t UNICORN__InitPStreamParam(char *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)a1;
  *((_DWORD *)a1 + 6) = (2 * *(_DWORD *)(*((void *)a1 + 4) + 32)) | 1;
  if (a2)
  {
    uint64_t v5 = *(void *)(a2 + 40);
    if (v5)
    {
      if (*((_DWORD *)a1 + 5) == *(_DWORD *)(a2 + 20) && *((_DWORD *)a1 + 4) == *(_DWORD *)(a2 + 16))
      {
        *((void *)a1 + 5) = v5;
        long long v6 = a1 + 8;
LABEL_14:
        uint64_t result = 0;
        *long long v6 = 1;
        return result;
      }
    }
  }
  *((_DWORD *)a1 + 2) = 0;
  long long v6 = a1 + 8;
  long long v7 = (uint64_t *)*((void *)a1 + 5);
  if (v7)
  {
    UNICORN__int32_free(*(void **)(v4 + 8), v7);
    *((void *)a1 + 5) = 0;
  }
  long long v8 = UNICORN__int32_ccalloc(*(void **)(v4 + 8), *((_DWORD *)a1 + 5), *((_DWORD *)a1 + 4));
  *((void *)a1 + 5) = v8;
  if (v8) {
    uint64_t result = 0;
  }
  else {
    uint64_t result = 2229280778;
  }
  if (a2 && v8)
  {
    UNICORN__FreePStreamParam((void *)a2);
    memcpy((void *)a2, a1, 0x2D8uLL);
    goto LABEL_14;
  }
  return result;
}

void *UNICORN__FreePStreamParam(void *result)
{
  if (*result)
  {
    float v1 = result;
    int v2 = (uint64_t *)result[5];
    if (v2)
    {
      if (!*((_DWORD *)result + 2)) {
        uint64_t result = UNICORN__int32_free(*(void **)(*result + 8), v2);
      }
      v1[5] = 0;
      *((_DWORD *)v1 + 2) = 0;
    }
  }
  return result;
}

uint64_t UNICORN__ParamGenStart(uint64_t a1, int *a2, int *a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  uint64_t v6 = *(void *)a1;
  uint64_t result = UNICORN__InitUttModel(*(void *)a1, (char *)(a1 + 56), a2, *(__int16 *)(*(void *)(a1 + 8) + 10));
  if ((result & 0x80000000) == 0)
  {
    *(_DWORD *)(v5 + 16) = a3[8];
    int v13 = a3[7];
    if (v13 >= 1 && v13 < *(_DWORD *)(v5 + 404))
    {
      UNICORN__log_select_Error(v6, 55018, (uint64_t)"Specified length of generated speech is too short (this sentence is composed from %d states), specify more than %d milliseconds\n", v8, v9, v10, v11, v12);
      return 2229280775;
    }
    if (*(int *)(v5 + 392) >= 1)
    {
      uint64_t v14 = 0;
      uint64_t v87 = 0;
      uint64_t v88 = 0;
      uint64_t v94 = v5;
      uint64_t v95 = (uint64_t)(v4 + 64);
      int v15 = *(_DWORD *)(v5 + 32);
      uint64_t v83 = a3 + 182;
      uint64_t v84 = *(void *)(*(void *)(v5 + 8) + 1784);
      float v16 = -0.5;
      float v17 = 0.0;
      float v18 = 0.0;
      uint64_t v86 = (uint64_t)a3;
      uint64_t v91 = (uint64_t)v4;
      uint64_t v93 = v6;
      while (1)
      {
        uint64_t v19 = *(void *)(v5 + 384);
        long long v20 = (int32x2_t *)(v19 + 312 * v14);
        uint64_t v89 = v19;
        long long v96 = v20;
        if (v15 >= 1)
        {
          uint64_t v21 = 0;
          long long v22 = v83;
          do
          {
            uint64_t v23 = &a3[v21];
            int v26 = v23[61];
            uint64_t v25 = v23 + 61;
            int v24 = v26;
            if (v26 < 1)
            {
              LODWORD(v27) = 0;
            }
            else
            {
              uint64_t v27 = 0;
              uint64_t v28 = (const char **)&a3[2 * *(unsigned __int8 *)(*(void *)(*(void *)(v5 + 8) + 248) + v20->i32[0])
                                     + 682];
              do
              {
                int v29 = *(const char **)&v22[2 * v27];
                if (v29 && *v28)
                {
                  if (!cstdlib_strcmp(v29, *v28)) {
                    goto LABEL_18;
                  }
                  int v24 = *v25;
                }
                ++v27;
              }
              while (v27 < v24);
              LODWORD(v27) = 0;
LABEL_18:
              uint64_t v19 = v89;
              long long v20 = v96;
            }
            *(_DWORD *)(v19 + 312 * v14 + 4 * v21++ + 36) = v27;
            v22 += 10;
          }
          while (v21 < *(int *)(v5 + 32));
        }
        UNICORN__log_select_Diag(v6, 21, (uint64_t)"[phoneme %d]\n");
        if (!v84) {
          goto LABEL_39;
        }
        if (a3[29])
        {
          uint64_t v35 = v89 + 312 * v14;
          *(_DWORD *)(v35 + 8) = UNICORN__TreeSearch(*(void *)(v5 + 8), v14, v95, 0, 0);
          UNICORN__log_select_Diag(v6, 6, (uint64_t)"DUR pdf id %d\n");
          uint64_t result = UNICORN__FindDurPDF(v96, v4, 0, *(_DWORD *)(v35 + 36), *(float *)(v5 + 16));
          if ((result & 0x80000000) != 0) {
            return result;
          }
          LOWORD(v36) = *(_WORD *)(*(void *)(*(void *)(v5 + 8) + 1784) + 2 * v96->i32[0]);
          float v37 = UNICORN__div_int32_int32_to_Q8_24((float)v36, (float)a3[6]);
          if (v37 != 0.0)
          {
            float v38 = v37;
            float v39 = 0.0;
            float v40 = 0.0;
            if (*v4 >= 1)
            {
              uint64_t v41 = 2;
              do
              {
                float v40 = v40 + UNICORN__int32_to_Q12_20((float)*(int *)(*(void *)(v89 + 312 * v14 + 16) + 4 * v41));
                BOOL v42 = v41++ <= *v4;
              }
              while (v42);
            }
            float v43 = v16 + v38;
            float v44 = UNICORN__div_Q8_24_Q12_20_to_Q8_24(v43, v40);
            uint64_t v45 = v89 + 312 * v14;
            *(_DWORD *)(v45 + 24) = 0;
            int v46 = (_DWORD *)(v45 + 24);
            if (*v4 >= 1)
            {
              float v47 = v44;
              uint64_t v48 = v89 + 312 * v14;
              uint64_t v51 = *(void *)(v48 + 16);
              float v50 = (uint64_t *)(v48 + 16);
              uint64_t v49 = v51;
              uint64_t v52 = 2;
              do
              {
                float v53 = UNICORN__mul_int32_Q8_24_to_Q8_24((float)*(int *)(v49 + 4 * v52), v47);
                int v54 = (int)UNICORN__Q8_24_to_int32(v53 + 0.5);
                if (v54 <= 1) {
                  int v55 = 1;
                }
                else {
                  int v55 = v54;
                }
                uint64_t v49 = *v50;
                *(_DWORD *)(*v50 + 4 * v52) = v55;
                int v56 = *v46 + v55;
                *int v46 = v56;
                BOOL v42 = v52++ <= *v4;
              }
              while (v42);
              float v39 = (float)v56;
            }
            float v16 = v43 - UNICORN__int32_to_Q8_24(v39);
          }
          uint64_t v57 = v89;
          *(_DWORD *)(v5 + 408) += *(_DWORD *)(v89 + 312 * v14 + 24);
          goto LABEL_47;
        }
        if (a3[28])
        {
          UNICORN__log_select_Error(v6, 55017, (uint64_t)"State level segmentation is not currently supported\n", v30, v31, v32, v33, v34);
        }
        else
        {
LABEL_39:
          uint64_t v58 = v89 + 312 * v14;
          *(_DWORD *)(v58 + 8) = UNICORN__TreeSearch(*(void *)(v5 + 8), v14, v95, 0, 0);
          uint64_t v59 = (int *)(v58 + 8);
          UNICORN__log_select_Diag(v6, 6, (uint64_t)"DUR pdf id %d\n");
          if (!a3[7])
          {
            uint64_t result = UNICORN__FindDurPDF(v96, v4, 0, *(_DWORD *)(v89 + 312 * v14 + 36), *(float *)(v5 + 16));
            if ((result & 0x80000000) != 0) {
              return result;
            }
            SetSilenceDuration_1(v5, v4, (uint64_t)a3, (int *)v96);
            *(_DWORD *)(v5 + 408) += *(_DWORD *)(v89 + 312 * v14 + 24);
            uint64_t v57 = v89;
            goto LABEL_47;
          }
          uint64_t v60 = *v4;
          if ((int)v60 >= 1)
          {
            uint64_t v57 = v89;
            uint64_t v61 = (float *)(*(void *)(*(void *)(*((void *)v4 + 12) + 8 * *(int *)(v89 + 312 * v14 + 36))
                                      + 8 * *v59)
                          + 8);
            uint64_t v62 = (v60 + 2) - 2;
            do
            {
              float v18 = v18 + *v61;
              float v17 = v17 + v61[v60];
              ++v61;
              --v62;
            }
            while (v62);
            goto LABEL_47;
          }
        }
        uint64_t v57 = v89;
LABEL_47:
        uint64_t v85 = v14;
        int v15 = *(_DWORD *)(v5 + 32);
        if (v15 >= 1)
        {
          for (uint64_t i = 0; i < v15; ++i)
          {
            uint64_t v64 = *(void *)(v5 + 24);
            if (!*(_DWORD *)(v64 + 1520 * i + 1472))
            {
              if (*(_DWORD *)(v64 + 1520 * i + 1480))
              {
                uint64_t v65 = v5 + 8 * i;
                int v66 = *v4 * v85;
                uint64_t v87 = *(void *)(*(void *)(v65 + 208) + 8 * v66);
                uint64_t v88 = *(void *)(*(void *)(v65 + 168) + 8 * v66);
              }
              int v67 = (char *)v4 + 2 * i;
              if (*((_WORD *)v67 + 176))
              {
                uint64_t v68 = 0;
                unint64_t v69 = 0;
                int32x4_t v92 = (unsigned __int16 *)(v67 + 352);
                uint64_t v70 = v57 + 312 * v85;
                uint64_t v71 = (void *)(v70 + 8 * i);
                uint64_t v72 = v71 + 7;
                uint64_t v73 = v71 + 12;
                uint64_t v74 = v71 + 17;
                unsigned int v90 = (int *)(v70 + 4 * i + 36);
                do
                {
                  uint64_t v75 = *(unsigned __int16 *)(*(void *)&v4[2 * i + 78] + v68);
                  *(_DWORD *)(*v72 + 4 * v75) = UNICORN__TreeSearch(*(void *)(v94 + 8), v96->i32[0], v95, i, v69);
                  UNICORN__log_select_Diag(v93, 6, (uint64_t)"%s pdf state %d id %d\n");
                  uint64_t v76 = *(void *)(v94 + 24);
                  if (*(_DWORD *)(v76 + 1520 * i + 1480))
                  {
                    int v77 = v75 - 2 + (v75 - 2) * v4[i + 1];
                    *(void *)(*v73 + 8 * v75) = v88 + 4 * v77;
                    *(void *)(*v73 + 8 * v75) -= 4;
                    *(void *)(*v74 + 8 * v75) = v87 + 4 * v77;
                    *(void *)(*v74 + 8 * v75) -= 4;
                    uint64_t result = UNICORN__FindMsdPDF(i, v75, (uint64_t)v96, v91, v86, *v90);
                    if ((result & 0x80000000) != 0) {
                      return result;
                    }
                  }
                  else if (*(_DWORD *)(v76 + 1520 * i + 1476))
                  {
                    uint64_t result = UNICORN__FindContPDF(i, v75, (uint64_t)v96, v91, *v90);
                    if ((result & 0x80000000) != 0) {
                      return result;
                    }
                  }
                  ++v69;
                  v68 += 16;
                }
                while (v69 < *v92);
                uint64_t v5 = v94;
                int v15 = *(_DWORD *)(v94 + 32);
                a3 = (int *)v86;
                uint64_t v4 = (int *)v91;
                uint64_t v57 = v89;
              }
            }
          }
        }
        uint64_t v14 = v85 + 1;
        uint64_t v6 = v93;
        if (v85 + 1 >= *(int *)(v5 + 392))
        {
          int v13 = a3[7];
          goto LABEL_66;
        }
      }
    }
    float v18 = 0.0;
    float v17 = 0.0;
LABEL_66:
    if (v13 < 1
      || (float v78 = UNICORN__int32_to_Q18_14((float)v13),
          float v79 = UNICORN__div_Q18_14_Q18_14_to_Q18_14(v78 - v18, v17),
          *(float *)(v5 + 16) = UNICORN__Q18_14_to_Q1_15(v79),
          *(int *)(v5 + 392) < 1))
    {
LABEL_71:
      if (UNICORN__log_select_GetLogLevel(*(void *)(v6 + 32)) >= 0x15) {
        OutLabel_2(v5);
      }
      UNICORN__log_select_Diag(v6, 2, (uint64_t)">> tree search done\n");
      AddBreakMarks_1(v5, v4, (uint64_t)a3);
      return ParamGenLT_1(v5, v4);
    }
    else
    {
      uint64_t v80 = 0;
      uint64_t v81 = 0;
      while (1)
      {
        uint64_t v82 = (int32x2_t *)(*(void *)(v5 + 384) + v80);
        uint64_t result = UNICORN__FindDurPDF(v82, v4, 0, v82[4].i32[1], *(float *)(v5 + 16));
        if ((result & 0x80000000) != 0) {
          break;
        }
        SetSilenceDuration_1(v5, v4, (uint64_t)a3, (int *)v82);
        *(_DWORD *)(v5 + 408) += v82[3].i32[0];
        ++v81;
        v80 += 312;
        if (v81 >= *(int *)(v5 + 392)) {
          goto LABEL_71;
        }
      }
    }
  }
  return result;
}

void SetSilenceDuration_1(uint64_t a1, int *a2, uint64_t a3, int *a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *a4;
  if (*(unsigned char *)(*(void *)(v4 + 32) + v5) == 1)
  {
    int v8 = *(unsigned __int16 *)(*(void *)(v4 + 1784) + 2 * v5) / *(int *)(a3 + 24);
    LODWORD(v4) = *a2;
    if (v8 <= *a2)
    {
      if ((int)v4 >= 1)
      {
        uint64_t v14 = *((void *)a4 + 2);
        uint64_t v15 = 2;
        do
        {
          *(_DWORD *)(v14 + 4 * v15) = 1;
          BOOL v11 = v15++ <= *a2;
        }
        while (v11);
        LODWORD(v4) = *a2;
      }
      a4[6] = v4;
    }
    else
    {
      if (v8 >= a4[6])
      {
        if ((int)v4 < 1)
        {
          int v12 = 0;
          int v13 = 0;
        }
        else
        {
          int v13 = 0;
          int v12 = 0;
          uint64_t v16 = *((void *)a4 + 2);
          uint64_t v17 = 2;
          do
          {
            int v18 = *(_DWORD *)(v16 + 4 * v17);
            if (v18 <= 0)
            {
              int v18 = 1;
              *(_DWORD *)(v16 + 4 * v17) = 1;
              LODWORD(v4) = *a2;
            }
            BOOL v19 = v17 == 2 || v17 == v4 + 1;
            if (v19) {
              int v20 = 0;
            }
            else {
              int v20 = v18;
            }
            v12 += v20;
            if (!v19) {
              int v18 = 0;
            }
            v13 += v18;
            BOOL v11 = v17++ <= (int)v4;
          }
          while (v11);
        }
      }
      else
      {
        if ((int)v4 >= 1)
        {
          uint64_t v9 = *((void *)a4 + 2);
          uint64_t v10 = 2;
          do
          {
            *(_DWORD *)(v9 + 4 * v10) = 1;
            uint64_t v4 = *a2;
            BOOL v11 = v10++ <= v4;
          }
          while (v11);
        }
        int v12 = v4 - 2;
        int v13 = 2;
      }
      float v21 = UNICORN__div_int32_int32_to_Q8_24((float)(v8 - v13), (float)v12);
      a4[6] = v13;
      LODWORD(v22) = *a2;
      if (*a2 >= 3)
      {
        float v23 = v21;
        uint64_t v24 = 3;
        do
        {
          if (v24 >= (int)v22) {
            int v25 = v8 - v13;
          }
          else {
            int v25 = (int)UNICORN__mul_int32_Q8_24_to_int32((float)*(int *)(*((void *)a4 + 2) + 4 * v24), v23);
          }
          if (v25 <= 1) {
            int v25 = 1;
          }
          *(_DWORD *)(*((void *)a4 + 2) + 4 * v24) = v25;
          int v13 = a4[6] + v25;
          a4[6] = v13;
          uint64_t v22 = *a2;
          BOOL v11 = v24++ < v22;
        }
        while (v11);
      }
    }
  }
}

uint64_t OutLabel_2(uint64_t result)
{
  if (*(int *)(result + 392) >= 1)
  {
    uint64_t v1 = result;
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    int v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(v1 + 384) + v2;
      uint64_t result = UNICORN__log_select_Diag(*(void *)v1, 21, (uint64_t)"%d %d %d [%d]\n");
      v4 += *(_DWORD *)(v5 + 24);
      ++v3;
      v2 += 312;
    }
    while (v3 < *(int *)(v1 + 392));
  }
  return result;
}

uint64_t AddBreakMarks_1(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t result = cstdlib_strcmp(*(const char **)(a3 + 80), "PHRASE_TIME");
  if (result)
  {
    uint64_t result = cstdlib_strcmp(*(const char **)(a3 + 80), "PHRASE");
    if (result)
    {
      uint64_t result = cstdlib_strcmp(*(const char **)(a3 + 80), "WORD");
      if (result)
      {
        uint64_t result = cstdlib_strcmp(*(const char **)(a3 + 80), "SYLLABLE");
        if (result)
        {
          uint64_t result = cstdlib_strcmp(*(const char **)(a3 + 80), "TIME");
          if (result)
          {
            uint64_t result = cstdlib_strcmp(*(const char **)(a3 + 80), "NONE");
            if (result)
            {
              uint64_t v12 = *(void *)a1;
              return UNICORN__log_select_Error(v12, 55036, (uint64_t)"valid breaker is required\n", v7, v8, v9, v10, v11);
            }
          }
          else
          {
            uint64_t v39 = *(unsigned int *)(a1 + 392);
            if ((int)v39 >= 1)
            {
              uint64_t v40 = 0;
              int v41 = 0;
              int v42 = *(_DWORD *)(a3 + 88);
              int v43 = *a2;
              uint64_t v44 = *(void *)(a1 + 384);
              int v45 = v42;
              int v46 = 0;
              do
              {
                if (v43 >= 1)
                {
                  uint64_t result = *(void *)(v44 + 312 * v40 + 16) + 8;
                  uint64_t v47 = (v43 + 2) - 2;
                  int v46 = v41;
                  do
                  {
                    int v48 = *(_DWORD *)result;
                    result += 4;
                    v46 += v48;
                    --v47;
                  }
                  while (v47);
                }
                if (v46 > v45)
                {
                  int v45 = v41 + v42;
                  uint64_t v49 = v44 + 312 * v40;
                  uint64_t result = *(_DWORD *)(v49 + 4) | 2u;
                  *(_DWORD *)(v49 + 4) = result;
                }
                ++v40;
                int v41 = v46;
              }
              while (v40 != v39);
            }
          }
        }
        else
        {
          int v35 = *(_DWORD *)(a1 + 392);
          if (v35 >= 3)
          {
            uint64_t v36 = (v35 - 2);
            float v37 = *(int **)(a1 + 384);
            uint64_t v38 = *(void *)(*(void *)(a1 + 8) + 112);
            do
            {
              if (*(unsigned char *)(v38 + *v37)) {
                v37[79] |= 2u;
              }
              v37 += 78;
              --v36;
            }
            while (v36);
          }
        }
      }
      else
      {
        int v31 = *(_DWORD *)(a1 + 392);
        if (v31 >= 3)
        {
          uint64_t v32 = (v31 - 2);
          uint64_t v33 = *(int **)(a1 + 384);
          uint64_t v34 = *(void *)(*(void *)(a1 + 8) + 112);
          do
          {
            if ((*(unsigned char *)(v34 + *v33) & 0xFE) == 2) {
              v33[79] |= 2u;
            }
            v33 += 78;
            --v32;
          }
          while (v32);
        }
      }
    }
    else
    {
      int v27 = *(_DWORD *)(a1 + 392);
      if (v27 >= 3)
      {
        uint64_t v28 = (v27 - 2);
        int v29 = *(int **)(a1 + 384);
        uint64_t v30 = *(void *)(*(void *)(a1 + 8) + 112);
        do
        {
          if (*(unsigned char *)(v30 + *v29) == 3) {
            v29[79] |= 2u;
          }
          v29 += 78;
          --v28;
        }
        while (v28);
      }
    }
  }
  else
  {
    uint64_t v13 = *(int *)(a1 + 392);
    if ((int)v13 >= 1)
    {
      uint64_t v14 = 0;
      int v15 = 0;
      uint64_t v16 = *(void *)(a1 + 384);
      int v17 = *a2;
      int v18 = *(_DWORD *)(a3 + 88);
      uint64_t v19 = *(void *)(*(void *)(a1 + 8) + 112);
      uint64_t v20 = v13 - 2;
      uint64_t v21 = *(unsigned int *)(a1 + 392);
      do
      {
        if (v17 < 1)
        {
          int v22 = 0;
        }
        else
        {
          int v22 = 0;
          float v23 = (int *)(*(void *)(v16 + 312 * v14 + 16) + 8);
          uint64_t v24 = (v17 + 2) - 2;
          do
          {
            int v25 = *v23++;
            v22 += v25;
            --v24;
          }
          while (v24);
        }
        v15 += v22;
        if (v15 > v18)
        {
          *(_DWORD *)(v16 + 312 * v14 + 4) |= 2u;
          int v15 = v22;
        }
        uint64_t result = v16 + 312 * v14;
        if (*(unsigned char *)(v19 + *(int *)result) == 3 && v14 < v20)
        {
          int v15 = 0;
          *(_DWORD *)(result + 316) |= 2u;
        }
        ++v14;
      }
      while (v14 != v21);
    }
  }
  return result;
}

uint64_t ParamGenLT_1(uint64_t a1, int *a2)
{
  uint64_t v3 = *(void *)a1;
  uint64_t v4 = 2229280778;
  memset(__b, 0, 512);
  memset(v78, 0, sizeof(v78));
  memset(v77, 0, sizeof(v77));
  cstdlib_memset(__b, 0, 0x2D8uLL);
  UNICORN__InitSMatrices(v3, v78);
  UNICORN__InitSMatrices(v3, v77);
  uint64_t v5 = heap_Calloc(*(void **)(v3 + 8), (*(_DWORD *)(a1 + 408) + 1), 1);
  *(void *)(a1 + 48) = v5;
  if (!v5) {
    return v4;
  }
  uint64_t v6 = heap_Calloc(*(void **)(v3 + 8), (*(_DWORD *)(a1 + 408) + 1), 4);
  *(void *)(a1 + 40) = v6;
  if (!v6) {
    return v4;
  }
  int v7 = *(_DWORD *)(a1 + 392);
  if (v7 >= 1)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    LODWORD(v10) = *a2;
    do
    {
      if ((int)v10 >= 1)
      {
        uint64_t v11 = *(void *)(a1 + 384) + 312 * v8;
        uint64_t v14 = *(void *)(v11 + 16);
        uint64_t v12 = (uint64_t *)(v11 + 16);
        uint64_t v13 = v14;
        int v15 = v12 + 20;
        uint64_t v16 = 2;
        do
        {
          if (*(int *)(v13 + 4 * v16) >= 1)
          {
            int v17 = 0;
            uint64_t v18 = v9;
            do
            {
              *(unsigned char *)(*(void *)(a1 + 48) + v18) = *(unsigned char *)(*v15 + v16);
              *(_DWORD *)(*(void *)(a1 + 40) + 4 * v18++) = *(_DWORD *)(v12[21] + 4 * v16);
              uint64_t v13 = *v12;
              ++v17;
            }
            while (v17 < *(_DWORD *)(*v12 + 4 * v16));
            v9 += v17;
          }
          uint64_t v19 = *(unsigned int *)(a1 + 32);
          if ((int)v19 >= 1)
          {
            uint64_t v20 = *(_DWORD **)(a1 + 24);
            do
            {
              if (v20[370] && ((1 << v20[1]) & (unint64_t)*(unsigned __int8 *)(*v15 + v16)) >> v20[1]) {
                v20[9] += *(_DWORD *)(v13 + 4 * v16);
              }
              v20 += 380;
              --v19;
            }
            while (v19);
          }
          uint64_t v10 = *a2;
          BOOL v21 = v16++ <= v10;
        }
        while (v21);
        int v7 = *(_DWORD *)(a1 + 392);
      }
      ++v8;
    }
    while (v8 < v7);
  }
  if (*(int *)(a1 + 32) < 1)
  {
    uint64_t v4 = 0;
    goto LABEL_65;
  }
  uint64_t v22 = 0;
  unint64_t v23 = 0;
  uint64_t v4 = 0;
  uint64_t v24 = (void *)(a1 + 56);
  while (1)
  {
    uint64_t v25 = *(void *)(a1 + 24);
    uint64_t v26 = v25 + 1520 * v22;
    if (*(_DWORD *)(v26 + 1480)) {
      break;
    }
LABEL_61:
    if (++v22 >= *(int *)(a1 + 32)) {
      goto LABEL_65;
    }
  }
  if (!*(_DWORD *)(v25 + 1520 * v22 + 36))
  {
LABEL_60:
    UNICORN__DeInitMSDUttModel(v24, v22);
    goto LABEL_61;
  }
  int v27 = (uint64_t *)(v26 + 16);
  uint64_t inited = UNICORN__InitPStreamParam((char *)(v26 + 16), 0);
  if ((inited & 0x80000000) == 0)
  {
    uint64_t v29 = UNICORN__InitPStreamSM(v27, (uint64_t)v78);
    uint64_t v4 = v29;
    if ((v29 & 0x80000000) != 0) {
      goto LABEL_65;
    }
    int v31 = *(_DWORD *)(a1 + 392);
    if (v31 >= 1)
    {
      int v67 = v27;
      unsigned int v68 = v29;
      uint64_t v32 = 0;
      int v33 = 0;
      int v34 = 0;
      uint64_t v35 = v25 + 1520 * v22;
      uint64_t v36 = v35 + 48;
      float v37 = (void *)(v35 + 88);
      uint64_t v38 = (void *)(v35 + 96);
      int v39 = *a2;
      uint64_t v74 = v22;
      do
      {
        if (v39 >= 1)
        {
          uint64_t v69 = v32;
          uint64_t v40 = *(void *)(a1 + 384) + 312 * v32;
          uint64_t v41 = v40 + 8 * v22;
          uint64_t v42 = *(void *)(v40 + 16);
          uint64_t v71 = (uint64_t *)(v40 + 16);
          uint64_t v30 = (void *)(v41 + 96);
          int v43 = (void *)(v41 + 136);
          uint64_t v44 = 2;
          do
          {
            if (*(int *)(v42 + 4 * v44) >= 1)
            {
              uint64_t v45 = v34;
              uint64_t v46 = *(void *)(a1 + 24);
              int v47 = 1;
              uint64_t v75 = v44;
              do
              {
                if (*(int *)(v46 + 1520 * v22 + 28) >= 1)
                {
                  int v72 = v47;
                  uint64_t v48 = 0;
                  int v73 = v33;
                  uint64_t v49 = v33;
                  uint64_t v76 = v33;
                  do
                  {
                    int v50 = *(_DWORD *)(v46 + 1520 * v22 + 4);
                    uint64_t v51 = 1 << v50;
                    uint64_t v52 = (1 << v50);
                    v23 |= v52;
                    float v53 = *(int **)(*(void *)(*(void *)v36 + 8) + 8 * v48);
                    int v55 = *v53;
                    int v54 = v53[1];
                    if (v55 <= v54)
                    {
                      uint64_t v56 = v52 ^ 0xFF;
                      int v57 = v54 - v55 + 1;
                      unsigned int v58 = v34 + v55;
                      do
                      {
                        uint64_t v59 = v56;
                        if ((v58 & 0x80000000) == 0)
                        {
                          uint64_t v59 = v56;
                          if (*(_DWORD *)(a1 + 408) >= (signed int)v58) {
                            uint64_t v59 = *(unsigned __int8 *)(*(void *)(a1 + 48) + v58);
                          }
                        }
                        v23 &= v59;
                        ++v58;
                        --v57;
                      }
                      while (v57);
                    }
                    if ((unint64_t)(v51 & *(unsigned char *)(*(void *)(a1 + 48) + v45)) >> v50)
                    {
                      if (!v48 || (v51 & v23) >> v50)
                      {
                        uint64_t v60 = 4 * v48 + 4;
                        *(_DWORD *)(*(void *)(*v37 + 8 * v49) + 4 * v48) = *(_DWORD *)(*(void *)(*v30 + 8 * v44)
                                                                                       + v60);
                        float v61 = *(float *)(*(void *)(*v43 + 8 * v44) + v60);
                        if (*(_DWORD *)(v46 + 1520 * v22 + 1484))
                        {
                          *(float *)(*(void *)(*v38 + 8 * v49) + 4 * v48) = v61;
                        }
                        else
                        {
                          uint64_t v62 = v38;
                          uint64_t v63 = v36;
                          uint64_t v64 = v30;
                          float v65 = UNICORN__bet5_finv(v61);
                          uint64_t v30 = v64;
                          uint64_t v44 = v75;
                          uint64_t v49 = v76;
                          uint64_t v36 = v63;
                          uint64_t v22 = v74;
                          uint64_t v38 = v62;
                          *(float *)(*(void *)(*v62 + 8 * v76) + 4 * v48) = v65;
                          uint64_t v46 = *(void *)(a1 + 24);
                        }
                      }
                      else
                      {
                        *(_DWORD *)(*(void *)(*v37 + 8 * v49) + 4 * v48) = 0;
                        *(_DWORD *)(*(void *)(*v38 + 8 * v49) + 4 * v48) = 0;
                      }
                    }
                    ++v48;
                  }
                  while (v48 < *(int *)(v46 + 1520 * v22 + 28));
                  uint64_t v42 = *v71;
                  int v33 = v73;
                  int v47 = v72;
                }
                if (((1 << *(_DWORD *)(v46 + 1520 * v22 + 4)) & (unint64_t)*(unsigned __int8 *)(*(void *)(a1 + 48) + v45)) >> *(_DWORD *)(v46 + 1520 * v22 + 4)) {
                  ++v33;
                }
                ++v45;
                ++v34;
                BOOL v21 = v47++ < *(_DWORD *)(v42 + 4 * v44);
              }
              while (v21);
              int v39 = *a2;
              int v34 = v45;
            }
            BOOL v21 = v44++ <= v39;
          }
          while (v21);
          int v31 = *(_DWORD *)(a1 + 392);
          uint64_t v32 = v69;
        }
        ++v32;
      }
      while (v32 < v31);
      uint64_t v24 = (void *)(a1 + 56);
      if (v33 < 1)
      {
        uint64_t v4 = v68;
        int v27 = v67;
      }
      else
      {
        int v27 = v67;
        (**(void (***)(uint64_t *, void, uint64_t, void *))(*(void *)(a1 + 24) + 1520 * v22 + 1496))(v67, 0, v36, v30);
        uint64_t v4 = v68;
      }
    }
    UNICORN__FreePStreamSM((uint64_t)v27);
    goto LABEL_60;
  }
  uint64_t v4 = inited;
LABEL_65:
  UNICORN__FreePStreamParam(__b);
  UNICORN__FreeSMatrices((uint64_t)v78);
  UNICORN__FreeSMatrices((uint64_t)v77);
  return v4;
}

uint64_t UNICORN__ParamGenFrames(uint64_t *a1, int *a2, _DWORD *a3)
{
  uint64_t v4 = a1;
  uint64_t v5 = *a1;
  memset(__b, 0, 512);
  memset(v121, 0, sizeof(v121));
  memset(v120, 0, sizeof(v120));
  *a3 = 0;
  cstdlib_memset(__b, 0, 0x2D8uLL);
  UNICORN__InitSMatrices(v5, v121);
  uint64_t v103 = v5;
  UNICORN__InitSMatrices(v5, v120);
  int v6 = *((_DWORD *)v4 + 99);
  uint64_t v7 = v4[48] + 312 * v6;
  *(_DWORD *)(v7 + 4) &= ~2u;
  int v8 = *((_DWORD *)v4 + 98);
  BOOL v9 = __OFSUB__(v8, v6);
  int v10 = v8 - v6;
  if ((v10 < 0) ^ v9 | (v10 == 0))
  {
    LODWORD(v12) = 0;
    unsigned int v11 = 0;
  }
  else
  {
    unsigned int v11 = 0;
    LODWORD(v12) = 0;
    while ((*(unsigned char *)(v7 + 4) & 2) == 0)
    {
      uint64_t v13 = *a2;
      if ((int)v13 >= 1)
      {
        uint64_t v14 = (int *)(*(void *)(v7 + 16) + 8);
        do
        {
          int v15 = *v14++;
          LODWORD(v12) = v15 + v12;
          --v13;
        }
        while (v13);
      }
      v7 += 312;
      if (++v11 == v10)
      {
        unsigned int v11 = v10;
        break;
      }
    }
  }
  UNICORN__log_select_Diag(v5, 2, (uint64_t)"| processing %d models %d frames <=> ");
  if (*((int *)v4 + 8) >= 1)
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    int v18 = 0;
    int v119 = 0;
    int v19 = 0;
    unsigned int inited = 0;
    uint64_t v101 = -(uint64_t)v11;
    unsigned int v102 = v11;
    uint32x4_t v115 = v4;
    uint64_t v106 = a2;
    while (1)
    {
      uint64_t v20 = v4[3];
      if (*(_DWORD *)(v20 + 1520 * v16 + 1476))
      {
        uint64_t v21 = v20 + 1520 * v16;
        signed int v107 = (void **)(v21 + 56);
        uint64_t v116 = v16;
        char v117 = (char *)(v21 + 16);
        if (*(void *)(v21 + 56))
        {
          UNICORN__FreePStreamParam((void *)(v21 + 16));
          uint64_t v16 = v116;
        }
        uint64_t v22 = v4[3] + 1520 * v16;
        int v23 = *(_DWORD *)(v22 + 1488);
        uint64_t v111 = *(unsigned int *)(v22 + 1492);
        int v24 = *((_DWORD *)v4 + 99);
        int v25 = *((_DWORD *)v4 + 98);
        if ((int)(v17 + v11 + v24) < v25 && v18 < v23)
        {
          int v27 = *a2;
          uint64_t v28 = v7;
          do
          {
            if (v27 >= 1)
            {
              uint64_t v29 = (int *)(*(void *)(v28 + 16) + 8);
              uint64_t v30 = (v27 + 2) - 2;
              do
              {
                int v31 = *v29++;
                v18 += v31;
                --v30;
              }
              while (v30);
            }
            v28 += 312;
            uint64_t v17 = (v17 + 1);
          }
          while ((int)(v17 + v11 + v24) < v25 && v18 < v23);
        }
        if (v24 > v119 && v19 < v23)
        {
          uint64_t v33 = v7 + 312 * v101;
          int v34 = *a2;
          do
          {
            if (v34 >= 1)
            {
              uint64_t v35 = (int *)(*(void *)(v33 - 296) + 8);
              uint64_t v36 = (v34 + 2) - 2;
              do
              {
                int v37 = *v35++;
                v19 += v37;
                --v36;
              }
              while (v36);
            }
            if (v24 <= ++v119) {
              break;
            }
            v33 -= 312;
          }
          while (v19 < v23);
        }
        uint64_t v108 = v7;
        uint64_t v104 = v17;
        UNICORN__log_select_Diag(v103, 3, (uint64_t)"L: %d %d  R: %d %d\n");
        uint64_t v38 = v20 + 1520 * v116;
        *(_DWORD *)(v38 + 36) = v12;
        float32x4_t v109 = (unsigned int *)(v38 + 36);
        *(_DWORD *)(v38 + 764) = v111 + v12 + v18 + v19 + v111;
        unsigned int inited = UNICORN__InitPStreamParam(v117, 0);
        if ((inited & 0x80000000) != 0) {
          goto LABEL_96;
        }
        uint64_t v39 = v20 + 1520 * v116;
        int v42 = *(_DWORD *)(v39 + 32);
        uint64_t v41 = (int *)(v39 + 32);
        int v40 = v42;
        uint64_t v16 = v116;
        if (v42 >= 1)
        {
          uint64_t v43 = 0;
          float32x4_t v114 = (char *)(v107 + 86);
          unsigned int v112 = (int *)(v109 + 182);
          uint64_t v44 = v20 + 1520 * v116;
          uint64_t v45 = (_DWORD **)(v44 + 776);
          uint64_t v46 = (void *)(v44 + 816);
          int v47 = (void *)(v44 + 824);
          uint64_t v118 = v17 + v102 + v119;
          uint64_t v105 = (void *)(v44 + 784);
          uint64_t v48 = 0;
          while (1)
          {
            if (*(_DWORD *)(*(void *)(v115[3] + 1520 * v116 + 1512) + 4 * v48) == 1)
            {
              uint64_t v49 = UNICORN__InitPStreamParam(v114, (uint64_t)__b);
              if ((v49 & 0x80000000) != 0)
              {
                uint64_t v51 = v49;
                goto LABEL_98;
              }
              uint64_t v50 = UNICORN__InitPStreamSM((uint64_t *)v114, (uint64_t)v120);
              uint64_t v51 = v50;
              if ((v50 & 0x80000000) != 0) {
                goto LABEL_98;
              }
              unsigned int inited = v50;
              uint64_t v113 = v48;
              if ((int)v111 < 1)
              {
                LODWORD(v52) = 0;
              }
              else
              {
                uint64_t v52 = 0;
                uint64_t v53 = *v112 & ~(*v112 >> 31);
                do
                {
                  if (v52 == v53) {
                    break;
                  }
                  uint64_t v54 = **v45;
                  if ((int)v54 >= 1)
                  {
                    int v55 = *(_DWORD **)(*v46 + 8 * v52);
                    uint64_t v56 = *(_DWORD **)(*v47 + 8 * v52);
                    do
                    {
                      *v55++ = 0;
                      *v56++ = 1065353216;
                      --v54;
                    }
                    while (v54);
                  }
                  ++v52;
                }
                while (v52 != v111);
              }
              LODWORD(v12) = v52;
              if ((int)v118 >= 1)
              {
                uint64_t v57 = 0;
                uint64_t v58 = v115[48];
                int v59 = *((_DWORD *)v115 + 99);
                int v60 = *v106;
                uint64_t v61 = (*v106 + 2);
                LODWORD(v12) = v52;
                do
                {
                  int v62 = v57 - v119 + v59;
                  if (v60 >= 1)
                  {
                    uint64_t v63 = v58 + 312 * v62;
                    uint64_t v64 = *(void *)(v63 + 16);
                    uint64_t v65 = v63 + 8 * v116;
                    int v66 = (void *)(v65 + 96);
                    int v67 = (void *)(v65 + 136);
                    uint64_t v68 = 2;
                    do
                    {
                      int v69 = *(_DWORD *)(v64 + 4 * v68);
                      if (v69 >= 1)
                      {
                        uint64_t v70 = **v45;
                        uint64_t v12 = (int)v12;
                        int v71 = 1;
                        do
                        {
                          if ((int)v70 >= 1)
                          {
                            uint64_t v72 = *(void *)(*v66 + 8 * v68);
                            int v73 = *(_DWORD **)(*v46 + 8 * v12);
                            uint64_t v74 = *(void *)(*v67 + 8 * v68);
                            uint64_t v75 = *(_DWORD **)(*v47 + 8 * v12);
                            uint64_t v76 = 4 * *v41;
                            uint64_t v77 = v70;
                            uint64_t v78 = v43;
                            do
                            {
                              *v73++ = *(_DWORD *)(v72 + v78);
                              *v75++ = *(_DWORD *)(v74 + v78);
                              v78 += v76;
                              --v77;
                            }
                            while (v77);
                          }
                          ++v12;
                        }
                        while (v71++ != v69);
                      }
                      ++v68;
                    }
                    while (v68 != v61);
                  }
                  ++v57;
                }
                while (v57 != v118);
                uint64_t v108 = v58 + 312 * v62;
              }
              if (*(_DWORD *)(v115[3] + 1520 * v116 + 1484)) {
                BOOL v80 = 0;
              }
              else {
                BOOL v80 = (int)v52 < (int)v12;
              }
              if (v80)
              {
                uint64_t v81 = v52;
                LODWORD(v52) = **v45;
                do
                {
                  if ((int)v52 >= 1)
                  {
                    uint64_t v82 = 0;
                    uint64_t v83 = *(void *)(*v47 + 8 * v81);
                    do
                    {
                      float v84 = UNICORN__bet5_finv(*(float *)(v83 + 4 * v82));
                      uint64_t v83 = *(void *)(*v47 + 8 * v81);
                      *(float *)(v83 + 4 * v82++) = v84;
                      uint64_t v52 = (int)**v45;
                    }
                    while (v82 < v52);
                  }
                  ++v81;
                }
                while (v81 != v12);
              }
              int v85 = *v112;
              if ((int)v12 >= *v112)
              {
                uint64_t v91 = v116;
                uint64_t v48 = v113;
              }
              else
              {
                uint64_t v86 = **v45;
                uint64_t v87 = (int)v12;
                uint64_t v48 = v113;
                do
                {
                  if ((int)v86 >= 1)
                  {
                    uint64_t v88 = *(_DWORD **)(*v46 + 8 * v87);
                    uint64_t v89 = *(_DWORD **)(*v47 + 8 * v87);
                    uint64_t v90 = v86;
                    do
                    {
                      *v88++ = 0;
                      *v89++ = 1065353216;
                      --v90;
                    }
                    while (v90);
                  }
                  ++v87;
                }
                while (v87 != v85);
                LODWORD(v12) = v85;
                uint64_t v91 = v116;
              }
              (*(void (**)(char *, void))(*(void *)(v115[3] + 1520 * v91 + 1496) + 8 * v48))(v114, 0);
              uint64_t v92 = *v109;
              if ((int)v92 >= 1)
              {
                uint64_t v93 = *v107;
                uint64_t v94 = (int **)(*v105 + 8 * (v19 + (int)v111));
                do
                {
                  uint64_t v95 = *v94++;
                  int v96 = *v95;
                  uint64_t v97 = *v93++;
                  *(_DWORD *)(v97 + 4 * v48) = v96;
                  --v92;
                }
                while (v92);
              }
              UNICORN__FreePStreamSM((uint64_t)v114);
              UNICORN__FreePStreamParam(v114);
              int v40 = *v41;
            }
            ++v48;
            v43 += 4;
            if (v48 >= v40)
            {
              uint64_t v4 = v115;
              a2 = v106;
              unsigned int v11 = v102;
              uint64_t v16 = v116;
              goto LABEL_90;
            }
          }
        }
        unsigned int v11 = v102;
LABEL_90:
        uint64_t v17 = v104;
        uint64_t v7 = v108;
      }
      if (++v16 >= *((int *)v4 + 8)) {
        goto LABEL_94;
      }
    }
  }
  unsigned int inited = 0;
LABEL_94:
  signed int v98 = *((_DWORD *)v4 + 99) + v11;
  *((_DWORD *)v4 + 99) = v98;
  if (v98 >= *((_DWORD *)v4 + 98)) {
    *a3 = 1;
  }
LABEL_96:
  uint64_t v51 = inited;
LABEL_98:
  UNICORN__FreePStreamParam(__b);
  UNICORN__FreeSMatrices((uint64_t)v121);
  UNICORN__FreeSMatrices((uint64_t)v120);
  return v51;
}

uint64_t UNICORN__InitVData(int a1, char *__b, _DWORD *a3)
{
  cstdlib_memset(__b, 0, 0x238uLL);
  uint64_t result = UNICORN__InitModelSet(a1, __b, a3);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = UNICORN__InitTreeSet(a1, __b + 256);
    if ((result & 0x80000000) == 0)
    {
      return UNICORN__InitDWinSet(a1, __b + 368, (uint64_t)a3);
    }
  }
  return result;
}

void *UNICORN__DeInitVData(void *a1, char *a2)
{
  UNICORN__DeInitModelSet((uint64_t)a1, a2);
  UNICORN__DeInitTreeSet(a1, a2 + 256);
  UNICORN__DeInitDWinSet((void **)a1, a2 + 368);

  return cstdlib_memset(a2, 0, 0x238uLL);
}

uint64_t UNICORN__LoadVData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(int *)(a2 + 244) < 1) {
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t v7 = a2 + 256;
  uint64_t v8 = a2 + 368;
  uint64_t v9 = a3 + 1408;
  int v10 = (unsigned int *)(a3 + 1288);
  do
  {
    uint64_t ModelFile = UNICORN__LoadModelFile(a1, (_DWORD *)a2, v6, v9, a3);
    if ((ModelFile & 0x80000000) != 0) {
      return ModelFile;
    }
    uint64_t ModelFile = UNICORN__LoadTreesFile(a1, v7, v6, v10, a3, v12, v13, v14);
    if ((ModelFile & 0x80000000) != 0) {
      return ModelFile;
    }
    uint64_t ModelFile = UNICORN__LoadDWinFile(a1, v8, v6, (unsigned int *)(v9 + 600));
    if ((ModelFile & 0x80000000) != 0) {
      return ModelFile;
    }
    ++v6;
    uint64_t v20 = *(int *)(a2 + 244);
    v9 += 120;
    v10 += 6;
  }
  while (v6 < v20);
  if ((int)v20 < 1) {
    return 0;
  }
  uint64_t v21 = 0;
  while (1)
  {
    if (!*(void *)(a2 + 8 * v21 + 312))
    {
      uint64_t v31 = 2229280775;
      uint64_t v33 = "%s tree is required\n";
      uint64_t v34 = a1;
      uint64_t v35 = 55032;
      goto LABEL_37;
    }
    uint64_t v22 = a2 + 4 * v21;
    if (*(_DWORD *)(v22 + 184) && !*(void *)(a2 + 96))
    {
LABEL_38:
      uint64_t v31 = 2229280775;
      uint64_t v33 = "%s PDF is required\n";
      uint64_t v34 = a1;
      uint64_t v35 = 55033;
      goto LABEL_37;
    }
    int v23 = *(_DWORD *)(v22 + 204);
    if (v23)
    {
      if (!*(void *)(a2 + 8 * v21 + 104)) {
        goto LABEL_38;
      }
      if (!*(_DWORD *)(a2 + 4 * v21 + 224))
      {
        char v24 = 1;
        goto LABEL_19;
      }
    }
    else if (!*(_DWORD *)(a2 + 4 * v21 + 224))
    {
      goto LABEL_31;
    }
    if (!*(void *)(a2 + 8 * v21 + 144)) {
      goto LABEL_38;
    }
    char v24 = 0;
LABEL_19:
    uint64_t v25 = *(unsigned int *)(a2 + 4 * v21 + 72);
    if ((int)v25 >= 1) {
      break;
    }
LABEL_26:
    if (v23) {
      char v30 = 0;
    }
    else {
      char v30 = v24;
    }
    if ((v30 & 1) == 0 && *(_DWORD *)(a2 + 4 * v21 + 4) % *(_DWORD *)(v8 + 40 * v21))
    {
      uint64_t v31 = 2229280775;
      uint64_t v33 = "The number of dynamic windows for %s is not correct %d %d\n";
      uint64_t v34 = a1;
      uint64_t v35 = 55035;
      goto LABEL_37;
    }
LABEL_31:
    uint64_t v31 = 0;
    if (++v21 == *(_DWORD *)(a2 + 244)) {
      return v31;
    }
  }
  uint64_t v26 = 0;
  uint64_t v27 = a2 + 8 * v21;
  uint64_t v28 = (void *)(v27 + 104);
  uint64_t v29 = (void *)(v27 + 144);
  while ((!v23 || *(void *)(*v28 + 8 * v26)) && ((v24 & 1) != 0 || *(void *)(*v29 + 8 * v26)))
  {
    if (v25 == ++v26) {
      goto LABEL_26;
    }
  }
  uint64_t v31 = 2229280775;
  uint64_t v33 = "%s PDF layer %d is required\n";
  uint64_t v34 = a1;
  uint64_t v35 = 55034;
LABEL_37:
  UNICORN__log_select_Error(v34, v35, (uint64_t)v33, v15, v16, v17, v18, v19);
  return v31;
}

uint64_t UNICORN__InitVStream(uint64_t a1, char *__b, _DWORD *a3)
{
  cstdlib_memset(__b, 0, 0x430uLL);
  *(void *)int8x16_t __b = a1;
  uint64_t v6 = a3[33];
  *((_DWORD *)__b + 8) = v6;
  uint64_t v7 = heap_Calloc(*(void **)(a1 + 8), v6, 1520);
  *((void *)__b + 3) = v7;
  if (!v7) {
    return 2229280778;
  }
  if (*((int *)__b + 8) >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = __b + 432;
    int v10 = a3 + 36;
    do
    {
      cstdlib_strcpy(v9, "");
      if (cstdlib_strlen(*(const char **)&v10[2 * v8])) {
        cstdlib_strcpy(v9, *(const char **)&v10[2 * v8]);
      }
      ++v8;
      uint64_t v11 = *((int *)__b + 8);
      v9 += 128;
    }
    while (v8 < v11);
    if ((int)v11 >= 1)
    {
      uint64_t v12 = 0;
      uint64_t v13 = *((void *)__b + 3);
      int v14 = a3[18];
      uint64_t v15 = 1520 * *((unsigned int *)__b + 8);
      do
      {
        uint64_t v16 = v13 + v12;
        *(_DWORD *)(v16 + 4) = a3[46];
        *(void *)(v16 + 16) = a1;
        *(void *)(v16 + 744) = a1;
        if (v12)
        {
          if (a3[287]) {
            *(_DWORD *)(v13 + v12 + 1480) = 1;
          }
          else {
            *(_DWORD *)(v13 + v12 + 1476) = 1;
          }
        }
        else
        {
          *(_DWORD *)(v13 + 1472) = 1;
        }
        if (v14 == 1) {
          *(_DWORD *)(v13 + v12 + 1484) = 1;
        }
        ++a3;
        v12 += 1520;
      }
      while (v15 != v12);
    }
  }
  return 0;
}

uint64_t UNICORN__LoadVStream(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(int *)(a1 + 32) < 1) {
    return 0;
  }
  uint64_t v3 = a3;
  uint64_t v4 = a2;
  uint64_t v6 = 0;
  uint64_t v7 = a2 + 368;
  uint64_t v8 = *(void *)(a1 + 24);
  uint64_t v50 = a2 + 368;
  while (1)
  {
    uint64_t v9 = (_DWORD *)(v7 + 40 * v6);
    uint64_t v10 = v8 + 1520 * v6;
    *(void *)(v10 + 48) = v9;
    int v11 = *(_DWORD *)(v10 + 1476);
    if (v11) {
      *(void *)(v8 + 1520 * v6 + 776) = v9;
    }
    if (*(_DWORD *)(v8 + 1520 * v6 + 1472))
    {
      if (v11) {
        goto LABEL_7;
      }
      goto LABEL_8;
    }
    uint64_t v13 = v4 + 4 * v6;
    uint64_t v14 = v8 + 1520 * v6;
    *(_DWORD *)(v14 + 28) = *(_DWORD *)(v13 + 4);
    int v15 = *(_DWORD *)(v13 + 4) / *v9;
    *(_DWORD *)(v14 + 32) = v15;
    *(void *)(v14 + 1488) = *(void *)(v3 + 92);
    uint64_t v16 = heap_Calloc(*(void **)(*(void *)a1 + 8), (2 * v15), 8);
    uint64_t v17 = *(void *)(a1 + 24);
    *(void *)(v17 + 1520 * v6 + 1496) = v16;
    if (!v16) {
      return 2229280778;
    }
    uint64_t v18 = v17 + 1520 * v6;
    uint64_t v19 = *(int *)(v18 + 32);
    *(void *)(v18 + 1504) = v16 + 8 * v19;
    if ((int)v19 >= 1) {
      break;
    }
LABEL_28:
    uint64_t v40 = heap_Calloc(*(void **)(*(void *)a1 + 8), v19, 4);
    uint64_t v41 = *(void *)(a1 + 24);
    *(void *)(v41 + 1520 * v6 + 1512) = v40;
    if (!v40) {
      return 2229280778;
    }
    if (*(int *)(v41 + 1520 * v6 + 32) >= 1)
    {
      uint64_t v42 = 0;
      uint64_t v43 = (void *)(v3 + 8 * v6 + 1248);
      while (1)
      {
        if (cstdlib_strcmp(*(const char **)(*v43 + 8 * v42), "OFF"))
        {
          if (cstdlib_strcmp(*(const char **)(*v43 + 8 * v42), "ON"))
          {
            uint64_t v47 = *(void *)a1;
            uint64_t v48 = "valid breaker setting is required for stream %d\n";
            goto LABEL_43;
          }
          int v44 = 1;
        }
        else
        {
          int v44 = 0;
        }
        uint64_t v45 = *(void *)(a1 + 24) + 1520 * v6;
        *(_DWORD *)(*(void *)(v45 + 1512) + 4 * v42++) = v44;
        if (v42 >= *(int *)(v45 + 32))
        {
          uint64_t v4 = a2;
          break;
        }
      }
    }
    UNICORN__log_select_Diag(*(void *)a1, 1, (uint64_t)"%s: vSize = %d, order = %d, nLayer = %d\n");
    uint64_t v8 = *(void *)(a1 + 24);
    uint64_t v7 = v50;
    if (*(_DWORD *)(v8 + 1520 * v6 + 1476))
    {
LABEL_7:
      uint64_t v12 = v8 + 1520 * v6;
      *(_DWORD *)(v12 + 756) = *(_DWORD *)(v4 + 4 * v6 + 4);
      *(_DWORD *)(v12 + 760) = 1;
    }
LABEL_8:
    if (++v6 >= *(int *)(a1 + 32)) {
      return 0;
    }
  }
  uint64_t v20 = 0;
  uint64_t v21 = v3 + 8 * v6;
  uint64_t v22 = (void *)(v21 + 1168);
  int v23 = (void *)(v21 + 1208);
  while (1)
  {
    int v24 = cstdlib_strcmp(*(const char **)(*v22 + 8 * v20), "MLPG");
    uint64_t v25 = (uint64_t (*)())UNICORN__mlpg;
    if (v24)
    {
      int v26 = cstdlib_strcmp(*(const char **)(*v22 + 8 * v20), "MLPG2");
      uint64_t v25 = (uint64_t (*)())UNICORN__mlpg2;
      if (v26)
      {
        int v27 = cstdlib_strcmp(*(const char **)(*v22 + 8 * v20), "MLPG_OPT");
        uint64_t v25 = UNICORN__mlpg_opt;
        if (v27)
        {
          int v28 = cstdlib_strcmp(*(const char **)(*v22 + 8 * v20), "DUMMY_SOLVER");
          uint64_t v25 = (uint64_t (*)())UNICORN__dummy_solver;
          if (v28) {
            break;
          }
        }
      }
    }
    *(void *)(*(void *)(*(void *)(a1 + 24) + 1520 * v6 + 1496) + 8 * v20) = v25;
    if (*v23)
    {
      uint64_t v34 = *(const char **)(*v23 + 8 * v20);
      if (v34)
      {
        int v35 = cstdlib_strcmp(v34, "MLPG");
        uint64_t v36 = (uint64_t (*)())UNICORN__mlpg;
        if (v35
          && (int v37 = cstdlib_strcmp(*(const char **)(*v23 + 8 * v20), "MLPG2"),
              uint64_t v36 = (uint64_t (*)())UNICORN__mlpg2,
              v37)
          && (v38 = cstdlib_strcmp(*(const char **)(*v23 + 8 * v20), "MLPG_OPT"), uint64_t v36 = UNICORN__mlpg_opt, v38)
          && (int v39 = cstdlib_strcmp(*(const char **)(*v23 + 8 * v20), "DUMMY_SOLVER"),
              uint64_t v36 = (uint64_t (*)())UNICORN__dummy_solver,
              v39))
        {
          if (**(unsigned char **)(*v23 + 8 * v20))
          {
            uint64_t v47 = *(void *)a1;
            uint64_t v48 = "invalid solver 2 for stream %d: %s\n";
            goto LABEL_43;
          }
        }
        else
        {
          *(void *)(*(void *)(*(void *)(a1 + 24) + 1520 * v6 + 1504) + 8 * v20) = v36;
        }
      }
    }
    ++v20;
    uint64_t v19 = *(int *)(*(void *)(a1 + 24) + 1520 * v6 + 32);
    if (v20 >= v19)
    {
      uint64_t v3 = a3;
      uint64_t v4 = a2;
      goto LABEL_28;
    }
  }
  uint64_t v47 = *(void *)a1;
  uint64_t v48 = "invalid solver for stream %d: %s\n";
LABEL_43:
  UNICORN__log_select_Error(v47, 55036, (uint64_t)v48, v29, v30, v31, v32, v33);
  return 2229280775;
}

void *UNICORN__DeInitVStream(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*result)
    {
      if (*((int *)result + 8) >= 1)
      {
        uint64_t v2 = 0;
        uint64_t v3 = result[3];
        uint64_t v4 = 1512;
        do
        {
          if (!v3) {
            break;
          }
          UNICORN__FreePStreamSM(v3 + v4 - 1496);
          UNICORN__FreePStreamParam((void *)(v1[3] + v4 - 1496));
          UNICORN__FreePStreamSM(v1[3] + v4 - 768);
          UNICORN__FreePStreamParam((void *)(v1[3] + v4 - 768));
          uint64_t v3 = v1[3];
          uint64_t v5 = *(void *)(v3 + v4 - 16);
          if (v5)
          {
            heap_Free(*(void **)(*v1 + 8), v5);
            uint64_t v3 = v1[3];
            *(void *)(v3 + v4 - 16) = 0;
          }
          uint64_t v6 = *(void *)(v3 + v4);
          if (v6)
          {
            heap_Free(*(void **)(*v1 + 8), v6);
            uint64_t v3 = v1[3];
            *(void *)(v3 + v4) = 0;
          }
          ++v2;
          v4 += 1520;
        }
        while (v2 < *((int *)v1 + 8));
      }
      uint64_t v7 = v1[6];
      if (v7)
      {
        heap_Free(*(void **)(*v1 + 8), v7);
        v1[6] = 0;
      }
      uint64_t v8 = v1[5];
      if (v8)
      {
        heap_Free(*(void **)(*v1 + 8), v8);
        v1[5] = 0;
      }
      uint64_t v9 = v1[3];
      if (v9)
      {
        heap_Free(*(void **)(*v1 + 8), v9);
        v1[3] = 0;
      }
      UNICORN__DeInitUttModel(v1 + 7);
      return cstdlib_memset(v1, 0, 0x430uLL);
    }
  }
  return result;
}

void *UNICORN__InitVParam(_DWORD *a1)
{
  uint64_t result = cstdlib_memset(a1, 0, 0x1528uLL);
  a1[32] = 1;
  return result;
}

void *UNICORN__DeInitVParam(uint64_t a1, void *__b)
{
  if (__b[676])
  {
    for (uint64_t i = 0; i != 20; ++i)
    {
      if (*(void *)(__b[676] + 8 * i))
      {
        for (uint64_t j = 0; j != 800; j += 8)
        {
          uint64_t v6 = *(void *)(*(void *)(__b[676] + 8 * i) + j);
          if (v6)
          {
            heap_Free(*(void **)(a1 + 8), v6);
            *(void *)(*(void *)(__b[676] + 8 * i) + j) = 0;
          }
        }
        uint64_t v7 = *(void *)(__b[676] + 8 * i);
        if (v7)
        {
          heap_Free(*(void **)(a1 + 8), v7);
          *(void *)(__b[676] + 8 * i) = 0;
        }
      }
      uint64_t v8 = *(void *)(__b[675] + 8 * i);
      if (v8)
      {
        heap_Free(*(void **)(a1 + 8), v8);
        *(void *)(__b[675] + 8 * i) = 0;
      }
      uint64_t v9 = *(void *)(__b[674] + 8 * i);
      if (v9)
      {
        heap_Free(*(void **)(a1 + 8), v9);
        *(void *)(__b[674] + 8 * i) = 0;
      }
    }
    uint64_t v10 = __b[676];
    if (v10)
    {
      heap_Free(*(void **)(a1 + 8), v10);
      __b[676] = 0;
    }
    uint64_t v11 = __b[675];
    if (v11)
    {
      heap_Free(*(void **)(a1 + 8), v11);
      __b[675] = 0;
    }
    uint64_t v12 = __b[674];
    if (v12)
    {
      heap_Free(*(void **)(a1 + 8), v12);
      __b[674] = 0;
    }
  }
  uint64_t v13 = __b[10];
  if (v13)
  {
    heap_Free(*(void **)(a1 + 8), v13);
    __b[10] = 0;
  }
  uint64_t v14 = __b[15];
  if (v14)
  {
    heap_Free(*(void **)(a1 + 8), v14);
    __b[15] = 0;
  }
  uint64_t v15 = __b[632];
  if (v15)
  {
    heap_Free(*(void **)(a1 + 8), v15);
    __b[632] = 0;
  }
  uint64_t v16 = 0;
  uint64_t v17 = __b;
  do
  {
    uint64_t v18 = (char *)&__b[v16];
    uint64_t v19 = *((void *)v18 + 18);
    if (v19)
    {
      heap_Free(*(void **)(a1 + 8), v19);
      *((void *)v18 + 18) = 0;
    }
    uint64_t v20 = *((void *)v18 + 36);
    if (v20)
    {
      heap_Free(*(void **)(a1 + 8), v20);
      *((void *)v18 + 36) = 0;
    }
    for (uint64_t k = 0; k != 5; ++k)
    {
      uint64_t v22 = &v17[k];
      uint64_t v23 = v17[k + 41];
      if (v23)
      {
        heap_Free(*(void **)(a1 + 8), v23);
        v22[41] = 0;
      }
      uint64_t v24 = v22[91];
      if (v24)
      {
        heap_Free(*(void **)(a1 + 8), v24);
        v22[91] = 0;
      }
    }
    for (uint64_t m = 116; m != 121; ++m)
    {
      uint64_t v26 = v17[m];
      if (v26)
      {
        heap_Free(*(void **)(a1 + 8), v26);
        v17[m] = 0;
      }
    }
    int v27 = (char *)__b + 4 * v16;
    int v29 = *((_DWORD *)v27 + 51);
    int v28 = (unsigned int *)(v27 + 204);
    if (v29)
    {
      unint64_t v30 = 0;
      uint64_t v31 = (char *)&__b[v16];
      uint64_t v32 = v31 + 1248;
      uint64_t v33 = v31 + 1168;
      uint64_t v34 = v31 + 1208;
      do
      {
        if (*v32)
        {
          uint64_t v35 = *(void *)(*v32 + 8 * v30);
          if (v35)
          {
            heap_Free(*(void **)(a1 + 8), v35);
            *(void *)(*v32 + 8 * v30) = 0;
          }
        }
        if (*v33)
        {
          uint64_t v36 = *(void *)(*v33 + 8 * v30);
          if (v36)
          {
            heap_Free(*(void **)(a1 + 8), v36);
            *(void *)(*v33 + 8 * v30) = 0;
          }
        }
        if (*v34)
        {
          uint64_t v37 = *(void *)(*v34 + 8 * v30);
          if (v37)
          {
            heap_Free(*(void **)(a1 + 8), v37);
            *(void *)(*v34 + 8 * v30) = 0;
          }
        }
        ++v30;
      }
      while (v30 < *v28);
    }
    int v38 = (char *)&__b[v16];
    uint64_t v39 = *((void *)v38 + 156);
    if (v39)
    {
      heap_Free(*(void **)(a1 + 8), v39);
      *((void *)v38 + 156) = 0;
    }
    uint64_t v40 = *((void *)v38 + 146);
    if (v40)
    {
      heap_Free(*(void **)(a1 + 8), v40);
      *((void *)v38 + 146) = 0;
    }
    uint64_t v41 = (char *)&__b[v16];
    uint64_t v42 = *((void *)v41 + 151);
    if (v42)
    {
      uint64_t v43 = v41 + 1208;
      heap_Free(*(void **)(a1 + 8), v42);
      *uint64_t v43 = 0;
    }
    ++v16;
    v17 += 5;
  }
  while (v16 != 5);
  for (uint64_t n = 341; n != 597; ++n)
  {
    uint64_t v45 = __b[n];
    if (v45)
    {
      heap_Free(*(void **)(a1 + 8), v45);
      __b[n] = 0;
    }
  }
  if (__b[630])
  {
    for (iuint64_t i = 0; ii != 2048; ii += 8)
    {
      uint64_t v47 = *(void *)(__b[630] + ii);
      if (v47)
      {
        heap_Free(*(void **)(a1 + 8), v47);
        *(void *)(__b[630] + ii) = 0;
      }
    }
    heap_Free(*(void **)(a1 + 8), __b[630]);
  }

  return cstdlib_memset(__b, 0, 0x1528uLL);
}

uint64_t VectBlock_Create(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v4 = a1;
  if (a2)
  {
    uint64_t v7 = a2;
    uint64_t v8 = heap_Calloc(*(void **)(a1 + 8), a3, 1);
    *(void *)uint64_t v7 = v8;
    if (v8)
    {
      *(_DWORD *)(v7 + 8) = a3;
      *(_DWORD *)(v7 + 12) = a4;
      return 1;
    }
    uint64_t v10 = "VectBlock_Create, Error, Out of memory\n";
    a1 = v4;
    LODWORD(a2) = 0;
  }
  else
  {
    uint64_t v10 = "VectBlock_Create, Error, NULL Ptr\n";
  }
  UNICORN__log_select_Diag(a1, a2, (uint64_t)v10);
  return 0;
}

void *VectBlock_Clear(void *a1)
{
  return cstdlib_memset(a1, 0, 0x10uLL);
}

void **VectBlock_Destroy(void **result, uint64_t *__b)
{
  if (__b)
  {
    uint64_t v3 = *__b;
    if (v3)
    {
      heap_Free(result[1], v3);
      *int8x16_t __b = 0;
    }
    return (void **)cstdlib_memset(__b, 0, 0x10uLL);
  }
  return result;
}

uint64_t VectBlock_Set_Size(uint64_t result, int a2)
{
  *(_DWORD *)(result + 12) = a2;
  return result;
}

uint64_t VectBlock_Get_StartPtr_LH_F32(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t VectBlock_Get_IndexPtr_LH_F32(uint64_t a1, int a2)
{
  if (*(void *)a1) {
    return *(void *)a1 + 4 * (*(_DWORD *)(a1 + 12) * a2);
  }
  else {
    return 0;
  }
}

float VectBlock_Get_IndexElm_LH_F32(uint64_t a1, int a2)
{
  return *(float *)(*(void *)a1 + 4 * (*(_DWORD *)(a1 + 12) * a2));
}

void *VectBlock_Set_StartPtr_LH_F32(void *result, uint64_t a2)
{
  *uint64_t result = a2;
  return result;
}

uint64_t VectBlock_Get_StartPtr_LH_S32(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t VectBlock_Get_IndexPtr_LH_S32(uint64_t a1, int a2)
{
  if (*(void *)a1) {
    return *(void *)a1 + 4 * (*(_DWORD *)(a1 + 12) * a2);
  }
  else {
    return 0;
  }
}

uint64_t VectBlock_Get_IndexElm_LH_S32(uint64_t a1, int a2)
{
  return *(unsigned int *)(*(void *)a1 + 4 * (*(_DWORD *)(a1 + 12) * a2));
}

void *VectBlock_Set_StartPtr_LH_S32(void *result, uint64_t a2)
{
  *uint64_t result = a2;
  return result;
}

uint64_t VectBlock_Get_StartPtr_LH_S8(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t VectBlock_Get_IndexPtr_LH_S8(uint64_t a1, int a2)
{
  if (*(void *)a1) {
    return *(void *)a1 + (*(_DWORD *)(a1 + 12) * a2);
  }
  else {
    return 0;
  }
}

uint64_t VectBlock_Get_IndexElm_LH_S8(uint64_t a1, int a2)
{
  return *(char *)(*(void *)a1 + (*(_DWORD *)(a1 + 12) * a2));
}

void *VectBlock_Set_StartPtr_LH_S8(void *result, uint64_t a2)
{
  *uint64_t result = a2;
  return result;
}

uint64_t VectBlock_Get_StartPtr_LH_S16(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t VectBlock_Get_IndexPtr_LH_S16(uint64_t a1, int a2)
{
  if (*(void *)a1) {
    return *(void *)a1 + 2 * (*(_DWORD *)(a1 + 12) * a2);
  }
  else {
    return 0;
  }
}

uint64_t VectBlock_Get_IndexElm_LH_S16(uint64_t a1, int a2)
{
  return *(__int16 *)(*(void *)a1 + 2 * (*(_DWORD *)(a1 + 12) * a2));
}

void *VectBlock_Set_StartPtr_LH_S16(void *result, uint64_t a2)
{
  *uint64_t result = a2;
  return result;
}

uint64_t ANNFactory_CreateANNLibInstance(void *a1, uint64_t a2)
{
  uint64_t v3 = AnnObject_Create(a2);
  *a1 = v3;
  a1[1] = AnnObject_Open;
  a1[2] = AnnObject_Set;
  a1[3] = AnnObject_Process;
  a1[4] = AnnObject_Get;
  a1[5] = AnnObject_Reset;
  a1[6] = AnnObject_Close;
  a1[7] = AnnObject_SetLayerAdjuster;
  a1[8] = AnnObject_GetInputDimension;
  a1[9] = AnnObject_Destroy;
  if (v3) {
    return 0;
  }
  else {
    return 2229280778;
  }
}

uint64_t ANNFactory_CreateFastInferInstance(void *a1, uint64_t a2)
{
  uint64_t v3 = FastInferObject_Create(a2);
  *a1 = v3;
  a1[1] = FastInferObject_Open;
  a1[2] = FastInferObject_BorrowModelInputs;
  a1[3] = FastInferObject_Process;
  a1[4] = FastInferObject_BorrowModelOutputLayer;
  a1[5] = FastInferObject_Reset;
  a1[6] = FastInferObject_Close;
  a1[7] = FastInferObject_SetLayerAdjuster;
  a1[8] = FastInferObject_GetInputDimension;
  a1[9] = FastInferObject_Destroy;
  if (v3) {
    return 0;
  }
  else {
    return 2229280778;
  }
}

void *NnetGetModel@<X0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  a2[7] = 0u;
  a2[8] = 0u;
  a2[5] = 0u;
  a2[6] = 0u;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  cstdlib_memset(a2, 0, 0x90uLL);
  uint64_t v4 = (void *)heap_Calloc(*(void **)(a1 + 8), 1, 16);
  *((void *)a2 + 11) = v4;
  uint64_t result = NnetInit(v4);
  *((void *)a2 + 8) = NNEval;
  *((void *)a2 + 9) = NNFree;
  *((void *)a2 + 10) = NNReset;
  return result;
}

uint64_t NNEval(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)(a2 + 120) = 0;
  *(void *)(a2 + 128) = 0;
  uint64_t result = NnetForward(a1, *(uint64_t ***)(a2 + 88), *(float32x4_t **)(a2 + 104), *(_DWORD *)(a2 + 112), *(unsigned int *)(a2 + 116), a6, a7, a8);
  if (!result)
  {
    uint64_t OutputLayer = NnetGetOutputLayer(*(uint64_t ***)(a2 + 88));
    if (OutputLayer)
    {
      uint64_t v11 = OutputLayer;
      uint64_t result = 0;
      *(void *)(a2 + 120) = *(void *)(v11 + 24);
      *(void *)(a2 + 128) = *(void *)(v11 + 32);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void *NNFree(void **a1, uint64_t a2)
{
  uint64_t result = NnetClear(a1, *(uint64_t ***)(a2 + 88));
  uint64_t v5 = *(void *)(a2 + 88);
  if (v5)
  {
    uint64_t result = heap_Free(a1[1], v5);
    *(void *)(a2 + 88) = 0;
  }
  return result;
}

void *NNReset(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = **(uint64_t ***)(a2 + 88);
  if (v2)
  {
    uint64_t v3 = *v2;
    if (*v2)
    {
      uint64_t v4 = v2 + 1;
      do
      {
        uint64_t result = cstdlib_memset(*(void **)(v3 + 24), 0, 4 * (*(_DWORD *)(v3 + 32) * *(_DWORD *)(v3 + 36)));
        uint64_t v6 = *v4++;
        uint64_t v3 = v6;
      }
      while (v6);
    }
  }
  return result;
}

uint64_t AdapterGetModel@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, int a3@<W2>, _OWORD *a4@<X8>)
{
  a4[7] = 0u;
  a4[8] = 0u;
  a4[5] = 0u;
  a4[6] = 0u;
  a4[3] = 0u;
  a4[4] = 0u;
  a4[1] = 0u;
  a4[2] = 0u;
  *a4 = 0u;
  cstdlib_memset(a4, 0, 0x90uLL);
  uint64_t v8 = heap_Calloc(*(void **)(a1 + 8), 1, 16);
  *((void *)a4 + 11) = v8;
  uint64_t result = ModelAdapterInit(a1, v8, a2, a3);
  *((void *)a4 + 8) = AdapterEval;
  *((void *)a4 + 9) = AdapterFree;
  *((void *)a4 + 10) = AdapterReset;
  return result;
}

BOOL AdapterEval(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)(a2 + 128) = 0;
  uint64_t v8 = a2 + 128;
  *(void *)(a2 + 120) = 0;
  uint64_t v9 = ModelAdapterEval(a1, *(uint64_t **)(a2 + 88), (int *)(a2 + 128), (_DWORD *)(a2 + 132), a5, a6, a7, a8);
  *(void *)(v8 - 8) = v9;
  return v9 == 0;
}

void *AdapterFree(uint64_t a1, uint64_t a2)
{
  uint64_t result = ModelAdapterFree((void *)a1, *(uint64_t **)(a2 + 88));
  uint64_t v5 = *(void *)(a2 + 88);
  if (v5) {
    uint64_t result = heap_Free(*(void **)(a1 + 8), v5);
  }
  *(void *)(a2 + 88) = 0;
  return result;
}

void *AdapterReset(void *result, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 120);
  if (v3) {
    uint64_t result = heap_Free((void *)result[1], v3);
  }
  *(void *)(a2 + 120) = 0;
  return result;
}

uint64_t ModelAdapterInit(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v7 = heap_Calloc(*(void **)(a1 + 8), a3, 40);
  *(void *)a2 = v7;
  if (!v7) {
    return 1;
  }
  uint64_t result = 0;
  *(_DWORD *)(a2 + 8) = a3;
  *(_DWORD *)(a2 + 12) = a4;
  return result;
}

void *ModelAdapterFree(void *result, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (v3) {
    uint64_t result = heap_Free((void *)result[1], v3);
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

uint64_t ModelAdapterSet(void *a1, int a2, uint64_t a3, int a4, int a5, int a6, uint64_t a7)
{
  uint64_t v7 = *a1 + 40 * a2;
  *(void *)(v7 + 8) = a3;
  *(_DWORD *)uint64_t v7 = 0;
  *(_DWORD *)(v7 + 16) = a4;
  *(_DWORD *)(v7 + 20) = a5;
  *(_DWORD *)(v7 + 24) = a6;
  *(void *)(v7 + 32) = a7;
  return 0;
}

uint64_t ModelAdapterSetNnet(void *a1, int a2, uint64_t a3, int a4, int a5, int a6, uint64_t a7)
{
  uint64_t v7 = *a1 + 40 * a2;
  *(void *)(v7 + 8) = a3;
  *(_DWORD *)uint64_t v7 = 1;
  *(_DWORD *)(v7 + 16) = a4;
  *(_DWORD *)(v7 + 20) = a5;
  *(_DWORD *)(v7 + 24) = a6;
  *(void *)(v7 + 32) = a7;
  return 0;
}

uint64_t ModelAdapterEval(uint64_t a1, uint64_t *a2, int *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a2 + 3))
  {
    if (!*((_DWORD *)a2 + 2)) {
      return 0;
    }
  }
  else
  {
    *((_DWORD *)a2 + 3) = 0;
    uint64_t v41 = *((unsigned int *)a2 + 2);
    if (!v41) {
      return 0;
    }
    int v42 = 0;
    uint64_t v43 = *a2;
    do
    {
      uint64_t v44 = *(void *)(v43 + 8);
      if (!v44) {
        return 0;
      }
      if (*(_DWORD *)v43)
      {
        if (*(_DWORD *)v43 != 1) {
          return 0;
        }
        uint64_t v45 = (_DWORD *)(v44 + 36);
      }
      else
      {
        uint64_t v45 = (_DWORD *)(v44 + 132);
      }
      v42 += ((2 * *(_DWORD *)(v43 + 24)) | 1) * *v45;
      *((_DWORD *)a2 + 3) = v42;
      v43 += 40;
      --v41;
    }
    while (v41);
  }
  int v50 = 0;
  uint64_t v9 = 0;
  unint64_t v10 = 0;
  uint64_t v11 = *a2;
  while (1)
  {
    int v12 = *(_DWORD *)(v11 + 40 * v10);
    if (v12) {
      break;
    }
    uint64_t v17 = *(void *)(v11 + 40 * v10 + 8);
    uint64_t v14 = (uint64_t *)(v17 + 120);
    uint64_t v15 = (int *)(v17 + 128);
    uint64_t v16 = (int *)(v17 + 132);
LABEL_9:
    int v56 = *v16;
    int v18 = *v15;
    uint64_t v19 = *v14;
    uint64_t v20 = v11 + 40 * v10;
    int v23 = *(_DWORD *)(v20 + 16);
    uint64_t v22 = (_DWORD *)(v20 + 16);
    int v21 = v23;
    if (v23 == -1)
    {
      int v21 = 0;
      *uint64_t v22 = 0;
    }
    uint64_t v24 = v11 + 40 * v10;
    int v27 = *(_DWORD *)(v24 + 20);
    uint64_t v26 = (_DWORD *)(v24 + 20);
    int v25 = v27;
    if (v27 == -1)
    {
      int v25 = v56 - 1;
      *uint64_t v26 = v56 - 1;
      if (v9) {
        goto LABEL_17;
      }
    }
    else if (v9)
    {
      goto LABEL_17;
    }
    *a3 = v18;
    int v28 = *((_DWORD *)a2 + 3);
    *a4 = v28;
    uint64_t v9 = heap_Calloc(*(void **)(a1 + 8), (*a3 * v28), 4);
    if (!v9) {
      return v9;
    }
    uint64_t v11 = *a2;
    int v21 = *(_DWORD *)(*a2 + 40 * v10 + 16);
    int v25 = *(_DWORD *)(*a2 + 40 * v10 + 20);
LABEL_17:
    int v29 = v25 - v21;
    int v30 = *(_DWORD *)(v11 + 40 * v10 + 24);
    if (((2 * v30) | 1) + ((2 * v30) | 1u) * v29 + v50 > *a4)
    {
      ANNError(a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/modeladapter.c", 143, (uint64_t)"Error: ModelAdapterEval: Output dimension specified %d is smaller than expected %d.\n", a5, a6, a7, a8);
      return 0;
    }
    int v49 = ((2 * v30) | 1) + ((2 * v30) | 1) * v29 + v50;
    uint64_t v53 = v9;
    if ((v30 & 0x80000000) == 0)
    {
      int v31 = -v30;
      int v32 = -(v56 * v30);
      do
      {
        if (v18 >= 1)
        {
          int v33 = 0;
          int v55 = *(_DWORD *)(v11 + 40 * v10 + 20) - *(_DWORD *)(v11 + 40 * v10 + 16);
          int v54 = v50 + (v55 + 1) * (v30 + v31);
          int v51 = v32;
          do
          {
            if (v33 + v31 >= 0 && v33 + v31 < v18 && (v55 & 0x80000000) == 0)
            {
              uint64_t v34 = *a2;
              uint64_t v35 = (float *)(v53 + 4 * (v54 + *a4 * v33));
              int v36 = *(_DWORD *)(*a2 + 40 * v10 + 16) + v32;
              uint64_t v37 = (v55 + 1);
              int v38 = v35;
              do
              {
                *v38++ = *(float *)(v19 + 4 * v36++);
                --v37;
              }
              while (v37);
              if (*(void *)(v34 + 40 * v10 + 32))
              {
                uint64_t v39 = (v55 + 1);
                do
                {
                  *uint64_t v35 = (*(float (**)(float))(*a2 + 40 * v10 + 32))(*v35);
                  ++v35;
                  --v39;
                }
                while (v39);
              }
            }
            ++v33;
            v32 += v56;
          }
          while (v33 != v18);
          uint64_t v11 = *a2;
          int v32 = v51;
        }
        int v30 = *(_DWORD *)(v11 + 40 * v10 + 24);
        v32 += v56;
      }
      while (v31++ < v30);
    }
    ++v10;
    int v50 = v49;
    uint64_t v9 = v53;
    if (v10 >= *((unsigned int *)a2 + 2)) {
      return v9;
    }
  }
  if (v12 != 1) {
    return 0;
  }
  uint64_t v13 = *(void *)(v11 + 40 * v10 + 8);
  if (v13)
  {
    uint64_t v14 = (uint64_t *)(v13 + 24);
    uint64_t v15 = (int *)(v13 + 32);
    uint64_t v16 = (int *)(v13 + 36);
    goto LABEL_9;
  }
  if (v9)
  {
    heap_Free(*(void **)(a1 + 8), v9);
    return 0;
  }
  return v9;
}

uint64_t ann_Load(void **a1, uint64_t *__b, char *a3)
{
  v116[100] = *MEMORY[0x263EF8340];
  uint64_t v5 = 2229280775;
  if (!__b || !a3) {
    goto LABEL_22;
  }
  cstdlib_memset(__b, 0, 0x10uLL);
  bzero(v116, 0x320uLL);
  NodeNumberOfChildreuint64_t n = GetNodeNumberOfChildren(a3);
  if (!NodeNumberOfChildren)
  {
    uint64_t v13 = "Error loading ANN: empty ANN tree";
    uint64_t v14 = (uint64_t)a1;
    uint64_t v15 = 592;
    goto LABEL_21;
  }
  uint64_t v12 = (NodeNumberOfChildren - 1);
  if (v12 > 0x64)
  {
    uint64_t v13 = "Error loading ANN: too many external data references";
    uint64_t v14 = (uint64_t)a1;
    uint64_t v15 = 595;
    goto LABEL_21;
  }
  uint64_t v106 = a1;
  uint64_t v16 = 0;
LABEL_8:
  if (v16 != v12)
  {
    NodeChild = (char *)GetNodeChild(a3, (int)v16 + 1);
    if (NodeChild)
    {
      int v18 = NodeChild;
      uint64_t v19 = v12;
      if (!GetNodeNumberOfChildren(NodeChild))
      {
        LODWORD(__dst) = 0;
        cstdlib_memcpy(&__dst, v18, 4uLL);
        uint64_t v20 = (char *)(v18 + 4);
        int v21 = 2147483646;
        uint64_t v22 = v18 + 4;
        while (v22 < &v20[__dst])
        {
          int v23 = &v22[cstdlib_strlen(v22) + 1];
          if (!cstdlib_strcmp(v22, "END"))
          {
            uint64_t v22 = v23;
LABEL_18:
            if (v22 < &v20[__dst])
            {
              uint64_t v12 = v19;
              v116[v16++] = v22;
              if (v22) {
                goto LABEL_8;
              }
            }
            break;
          }
          if (v23 >= &v20[__dst]) {
            break;
          }
          uint64_t v22 = &v23[cstdlib_strlen(v23) + 1];
          if (!--v21) {
            goto LABEL_18;
          }
        }
      }
      uint64_t v13 = "Error loading external data";
      a1 = v106;
      uint64_t v14 = (uint64_t)v106;
      uint64_t v15 = 606;
    }
    else
    {
      uint64_t v13 = "Error loading external data";
      a1 = v106;
      uint64_t v14 = (uint64_t)v106;
      uint64_t v15 = 602;
    }
    goto LABEL_21;
  }
  int v25 = (char *)GetNodeChild(a3, 0);
  if (!v25)
  {
    uint64_t v13 = "Error loading ANN";
    a1 = v106;
    uint64_t v14 = (uint64_t)v106;
    uint64_t v15 = 612;
    goto LABEL_21;
  }
  uint64_t v26 = v25;
  a1 = v106;
  if (!GetNodeAttributeValue_String(v25, "dimInput"))
  {
    uint64_t v13 = "Error in config file. Required attribute [dimInput] missing from the root node of the ANN tree.";
    uint64_t v14 = (uint64_t)v106;
    uint64_t v15 = 615;
    goto LABEL_21;
  }
  NodeAttributeValue_String = (unsigned __int8 *)GetNodeAttributeValue_String(v26, "dimInput");
  if (!NodeAttributeValue_String || (int v28 = cstdlib_atoi(NodeAttributeValue_String), v28 <= 0))
  {
    uint64_t v13 = "Error in config file. Wrong value (%d) for attribute [dimInput] of the root node of the ANN tree.";
    uint64_t v14 = (uint64_t)v106;
    uint64_t v15 = 618;
    goto LABEL_21;
  }
  *((_DWORD *)__b + 3) = v28;
  unsigned int v29 = GetNodeNumberOfChildren(v26);
  if (!v29)
  {
    uint64_t v13 = "Error loading ANN: no models in stack";
    uint64_t v14 = (uint64_t)v106;
    uint64_t v15 = 623;
    goto LABEL_21;
  }
  *((_DWORD *)__b + 2) = v29;
  uint64_t v30 = v29;
  uint64_t v31 = heap_Calloc(v106[1], v29, 144);
  *int8x16_t __b = v31;
  __s1 = (char *)v31;
  if (!v31)
  {
    uint64_t v13 = "Allocation error";
    uint64_t v14 = (uint64_t)v106;
    uint64_t v15 = 629;
    goto LABEL_21;
  }
  uint64_t v32 = 0;
  while (1)
  {
    int v33 = (char *)GetNodeChild(v26, v32);
    if (!v33)
    {
      uint64_t v13 = "Error loading model";
      uint64_t v14 = (uint64_t)a1;
      uint64_t v15 = 636;
      goto LABEL_21;
    }
    uint64_t v34 = v33;
    uint64_t v35 = GetNodeAttributeValue_String(v33, "name");
    int v36 = GetNodeAttributeValue_String(v34, "type");
    uint64_t v104 = v35;
    if (!v35 || (uint64_t v37 = v36) == 0)
    {
      uint64_t v13 = "Error loading model %u";
      uint64_t v14 = (uint64_t)a1;
      uint64_t v15 = 641;
      goto LABEL_21;
    }
    int v38 = GetNodeAttributeValue_String(v34, "input");
    if (!cstdlib_strcmp(v37, "nnet"))
    {
      uint64_t v41 = &__s1[144 * v32];
      NnetGetModel((uint64_t)a1, &__dst);
      *(_OWORD *)uint64_t v41 = __dst;
      long long v42 = v108;
      long long v43 = v109;
      long long v44 = v111;
      *((_OWORD *)v41 + 3) = v110;
      *((_OWORD *)v41 + 4) = v44;
      *((_OWORD *)v41 + 1) = v42;
      *((_OWORD *)v41 + 2) = v43;
      long long v45 = v112;
      long long v46 = v113;
      long long v47 = v115;
      *((_OWORD *)v41 + 7) = v114;
      *((_OWORD *)v41 + 8) = v47;
      *((_OWORD *)v41 + 5) = v45;
      *((_OWORD *)v41 + 6) = v46;
      if (!LoadNnetModel(a1, v34, *((void **)v41 + 11), (uint64_t)v116, v12)) {
        goto LABEL_90;
      }
      uint64_t v13 = "Error loading nnet model %s";
      uint64_t v14 = (uint64_t)a1;
      uint64_t v15 = 649;
      goto LABEL_21;
    }
    if (!cstdlib_strcmp(v37, "nnet_cascade"))
    {
      uint64_t v48 = &__s1[144 * v32];
      NnetGetModel((uint64_t)a1, &__dst);
      *(_OWORD *)uint64_t v48 = __dst;
      long long v49 = v108;
      long long v50 = v109;
      long long v51 = v111;
      *((_OWORD *)v48 + 3) = v110;
      *((_OWORD *)v48 + 4) = v51;
      *((_OWORD *)v48 + 1) = v49;
      *((_OWORD *)v48 + 2) = v50;
      long long v52 = v112;
      long long v53 = v113;
      long long v54 = v115;
      *((_OWORD *)v48 + 7) = v114;
      *((_OWORD *)v48 + 8) = v54;
      *((_OWORD *)v48 + 5) = v52;
      *((_OWORD *)v48 + 6) = v53;
      if (!LoadNnetModel(a1, v34, *((void **)v48 + 11), (uint64_t)v116, v12))
      {
        int v55 = 1;
        goto LABEL_91;
      }
      uint64_t v13 = "Error loading nnet model %s";
      uint64_t v14 = (uint64_t)a1;
      uint64_t v15 = 656;
      goto LABEL_21;
    }
    if (cstdlib_strcmp(v37, "adapter"))
    {
      uint64_t v13 = "Unknown model type %s";
      uint64_t v14 = (uint64_t)a1;
      uint64_t v15 = 684;
      goto LABEL_21;
    }
    if (GetNodeAttributeValue_String(v34, "dim")
      && (uint64_t v39 = (unsigned __int8 *)GetNodeAttributeValue_String(v34, "dim")) != 0)
    {
      int v40 = cstdlib_atoi(v39);
    }
    else
    {
      int v40 = 0;
    }
    int v56 = &__s1[144 * v32];
    unsigned int v57 = GetNodeNumberOfChildren(v34);
    AdapterGetModel((uint64_t)a1, v57, v40, &__dst);
    *(_OWORD *)int v56 = __dst;
    long long v58 = v108;
    long long v59 = v109;
    long long v60 = v111;
    *((_OWORD *)v56 + 3) = v110;
    *((_OWORD *)v56 + 4) = v60;
    *((_OWORD *)v56 + 1) = v58;
    *((_OWORD *)v56 + 2) = v59;
    long long v61 = v112;
    long long v62 = v113;
    long long v63 = v115;
    *((_OWORD *)v56 + 7) = v114;
    *((_OWORD *)v56 + 8) = v63;
    *((_OWORD *)v56 + 5) = v61;
    *((_OWORD *)v56 + 6) = v62;
    uint64_t v64 = (void *)*((void *)v56 + 11);
    int v100 = GetNodeNumberOfChildren(v34);
    if (!v100) {
      goto LABEL_90;
    }
    uint64_t v95 = v64;
    unsigned int v65 = 0;
    uint64_t v102 = v30;
    uint64_t v103 = v12;
    while (1)
    {
      int v101 = v65;
      int v66 = (char *)GetNodeChild(v34, v65);
      if (!v66)
      {
        a1 = v106;
        uint64_t v92 = (uint64_t)v106;
        uint64_t v93 = 359;
LABEL_103:
        uint64_t v94 = "Error loading adapter model";
        goto LABEL_89;
      }
      int v71 = v66;
      uint64_t v72 = GetNodeAttributeValue_String(v66, "type");
      int v73 = GetNodeAttributeValue_String(v71, "model");
      if (!v73)
      {
        a1 = v106;
        uint64_t v92 = (uint64_t)v106;
        uint64_t v93 = 365;
        goto LABEL_103;
      }
      uint64_t v74 = v73;
      if (GetNodeAttributeValue_String(v71, "layerIdx"))
      {
        uint64_t v75 = (unsigned __int8 *)GetNodeAttributeValue_String(v71, "layerIdx");
        if (v75) {
          int v96 = cstdlib_atoi(v75);
        }
        else {
          int v96 = 0;
        }
      }
      else
      {
        int v96 = -1;
      }
      if (GetNodeAttributeValue_String(v71, "dimFrom"))
      {
        uint64_t v76 = (unsigned __int8 *)GetNodeAttributeValue_String(v71, "dimFrom");
        if (v76) {
          int v99 = cstdlib_atoi(v76);
        }
        else {
          int v99 = 0;
        }
      }
      else
      {
        int v99 = -1;
      }
      if (GetNodeAttributeValue_String(v71, "dimTo"))
      {
        uint64_t v77 = (unsigned __int8 *)GetNodeAttributeValue_String(v71, "dimTo");
        if (v77) {
          int v98 = cstdlib_atoi(v77);
        }
        else {
          int v98 = 0;
        }
      }
      else
      {
        int v98 = -1;
      }
      if (GetNodeAttributeValue_String(v71, "ctx")
        && (uint64_t v78 = (unsigned __int8 *)GetNodeAttributeValue_String(v71, "ctx")) != 0)
      {
        float v79 = v72;
        int v97 = cstdlib_atoi(v78);
      }
      else
      {
        float v79 = v72;
        int v97 = 0;
      }
      BOOL v80 = GetNodeAttributeValue_String(v71, "transform");
      if (!v32) {
        goto LABEL_88;
      }
      uint64_t v81 = v80;
      uint64_t v82 = 0;
      uint64_t v83 = (uint64_t)__s1;
      while (cstdlib_strcmp((const char *)v83, v74))
      {
        ++v82;
        v83 += 144;
        if (v32 == v82) {
          goto LABEL_88;
        }
      }
      if ((v82 & 0x80000000) != 0)
      {
LABEL_88:
        a1 = v106;
        uint64_t v92 = (uint64_t)v106;
        uint64_t v93 = 376;
        uint64_t v94 = "LoadAdapterModel: Unknown model specified %s";
        goto LABEL_89;
      }
      if (v81)
      {
        if (cstdlib_strcmp(v81, "exp"))
        {
          a1 = v106;
          uint64_t v92 = (uint64_t)v106;
          uint64_t v93 = 386;
          uint64_t v94 = "LoadAdapterModel: unknown transform %s specified";
          goto LABEL_89;
        }
        float v84 = my_expf;
      }
      else
      {
        float v84 = 0;
      }
      if (!v79) {
        break;
      }
      if (cstdlib_strcmp(v79, "nnet"))
      {
        a1 = v106;
        uint64_t v92 = (uint64_t)v106;
        uint64_t v93 = 405;
        uint64_t v94 = "LoadAdapterModel: Unknown adapter type %s";
        goto LABEL_89;
      }
      uint64_t v85 = *(void *)(v83 + 88);
      unsigned int v86 = *(_DWORD *)(v85 + 8);
      int v87 = v86 - 1;
      if (v96 >= 0) {
        int v87 = v96;
      }
      if (v87 >= v86)
      {
        a1 = v106;
        uint64_t v92 = (uint64_t)v106;
        uint64_t v93 = 400;
        uint64_t v94 = "LoadAdapterModel: layerIdx out of range";
        goto LABEL_89;
      }
      int v88 = v101;
      uint64_t v12 = v103;
      if (ModelAdapterSetNnet(v95, v101, *(void *)(*(void *)v85 + 8 * v87), v99, v98, v97, (uint64_t)v84))
      {
        a1 = v106;
        uint64_t v92 = (uint64_t)v106;
        uint64_t v93 = 402;
        uint64_t v94 = "LoadAdapterModel: error in ModelAdapterSetNnet";
        goto LABEL_89;
      }
LABEL_86:
      int v55 = 0;
      unsigned int v65 = v88 + 1;
      a1 = v106;
      uint64_t v30 = v102;
      if (v65 == v100) {
        goto LABEL_91;
      }
    }
    int v88 = v101;
    uint64_t v12 = v103;
    if (!ModelAdapterSet(v95, v101, v83, v99, v98, v97, (uint64_t)v84)) {
      goto LABEL_86;
    }
    a1 = v106;
    uint64_t v92 = (uint64_t)v106;
    uint64_t v93 = 392;
    uint64_t v94 = "LoadAdapterModel: error in ModelAdapterSet";
LABEL_89:
    uint64_t v30 = v102;
    uint64_t v12 = v103;
    if (ANNError(v92, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/ann.c", v93, (uint64_t)v94, v67, v68, v69, v70))
    {
      uint64_t v13 = "Error loading adapter model %s";
      uint64_t v14 = (uint64_t)a1;
      uint64_t v15 = 680;
      goto LABEL_21;
    }
LABEL_90:
    int v55 = 0;
LABEL_91:
    uint64_t v89 = &__s1[144 * v32];
    *((_DWORD *)v89 + 34) = v55;
    cstdlib_strcpy(v89, v104);
    if (v38) {
      break;
    }
LABEL_99:
    if (++v32 == v30) {
      return 0;
    }
  }
  if (v32)
  {
    uint64_t v90 = 0;
    uint64_t v91 = __s1;
    while (cstdlib_strcmp(v91, v38))
    {
      ++v90;
      v91 += 144;
      if (v32 == v90) {
        goto LABEL_114;
      }
    }
    if ((v90 & 0x80000000) == 0)
    {
      *(void *)&__s1[144 * v32 + 96] = v91;
      goto LABEL_99;
    }
  }
LABEL_114:
  uint64_t v13 = "Unknown models specified as input %s";
  uint64_t v14 = (uint64_t)a1;
  uint64_t v15 = 692;
LABEL_21:
  uint64_t v5 = 2229280772;
  if (!ANNError(v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/ann.c", v15, (uint64_t)v13, v8, v9, v10, v11))return 0; {
LABEL_22:
  }
  ann_Unload(a1, __b);
  return v5;
}

void *ann_Unload(void *result, uint64_t *__b)
{
  if (__b)
  {
    uint64_t v3 = *__b;
    if (v3)
    {
      uint64_t v4 = (uint64_t)result;
      unint64_t v5 = *((unsigned int *)__b + 2);
      if (!v5) {
        goto LABEL_9;
      }
      uint64_t v6 = 0;
      for (unint64_t i = 0; i < v5; ++i)
      {
        uint64_t v8 = *(void (**)(uint64_t))(*__b + v6 + 72);
        if (v8)
        {
          v8(v4);
          unint64_t v5 = *((unsigned int *)__b + 2);
        }
        v6 += 144;
      }
      uint64_t v3 = *__b;
      if (*__b)
      {
LABEL_9:
        heap_Free(*(void **)(v4 + 8), v3);
        *int8x16_t __b = 0;
      }
    }
    return cstdlib_memset(__b, 0, 0x10uLL);
  }
  return result;
}

uint64_t ann_Eval(uint64_t a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  bzero(v34, 0x320uLL);
  uint64_t v13 = 2229280775;
  if (!a2 || !a3 || !a4) {
    goto LABEL_26;
  }
  if (*(_DWORD *)(a2 + 8))
  {
    unint64_t v14 = 0;
    int v33 = *(_DWORD *)(a2 + 12);
    unint64_t v15 = *(void *)a2;
    unint64_t v16 = *(void *)a2;
    uint64_t v30 = a2;
    do
    {
      uint64_t v17 = *(void *)(v16 + 96);
      if (v17)
      {
        if (*(_DWORD *)(v16 + 136))
        {
          if (v14 >= 0x64)
          {
            ANNError(a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/ann.c", 795, (uint64_t)"Error evaluating ANN: too many layers with stacked input features (type=nnet_cascade)", v9, v10, v11, v12);
            uint64_t v13 = 2229280783;
            goto LABEL_26;
          }
          int v18 = *(_DWORD *)(v17 + 132);
          int v19 = v18 + v33;
          uint64_t v20 = a4;
          uint64_t v21 = heap_Alloc(*(void *)(a1 + 8), 4 * ((v18 + v33) * a4));
          unint64_t v31 = v14;
          v34[v14] = v21;
          if (!v21) {
            goto LABEL_31;
          }
          uint64_t v22 = v21;
          if (a5
            && (int v23 = *(const char **)(a5 + 8)) != 0
            && !cstdlib_strcmp(*(const char **)(v16 + 96), v23)
            && *(void *)(a5 + 16))
          {
            uint64_t v25 = heap_Calloc(*(void **)(a1 + 8), (*(_DWORD *)(*(void *)(v16 + 96) + 132)* *(_DWORD *)(*(void *)(v16 + 96) + 128)), 4);
            if (!v25)
            {
LABEL_31:
              uint64_t v13 = 2229280778;
              goto LABEL_26;
            }
            uint64_t v26 = (int *)v25;
            (*(void (**)(void, void, void, void, uint64_t))a5)(*(void *)(*(void *)(v16 + 96) + 120), (*(_DWORD *)(*(void *)(v16 + 96) + 132) * *(_DWORD *)(*(void *)(v16 + 96) + 128)), *(void *)(a5 + 16), *(unsigned int *)(a5 + 24), v25);
            stackFeats(a3, v20, v33, v26, v18, v22);
            heap_Free(*(void **)(a1 + 8), (uint64_t)v26);
          }
          else
          {
            stackFeats(a3, v20, v33, *(int **)(*(void *)(v16 + 96) + 120), v18, v22);
          }
          a2 = v30;
          unint64_t v14 = v31 + 1;
          *(void *)(v16 + 104) = v22;
          *(_DWORD *)(v16 + 112) = *(_DWORD *)(*(void *)(v16 + 96) + 128);
          a4 = v20;
        }
        else
        {
          *(void *)(v16 + 104) = *(void *)(v17 + 120);
          *(_DWORD *)(v16 + 112) = *(_DWORD *)(v17 + 128);
          int v19 = *(_DWORD *)(v17 + 132);
        }
      }
      else
      {
        *(void *)(v16 + 104) = a3;
        *(_DWORD *)(v16 + 112) = a4;
        int v19 = v33;
      }
      *(_DWORD *)(v16 + 116) = v19;
      uint64_t v24 = *(unsigned int (**)(uint64_t, unint64_t))(v16 + 64);
      if (!v24 || v24(a1, v16))
      {
        ANNError(a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/ann.c", 857, (uint64_t)"NNModel evaluation error, model %d", v9, v10, v11, v12);
        uint64_t v13 = 2229280785;
        goto LABEL_26;
      }
      v16 += 144;
      v15 += 144;
    }
    while (v16 < *(void *)a2 + 144 * (unint64_t)*(unsigned int *)(a2 + 8));
  }
  uint64_t v13 = 0;
LABEL_26:
  for (uint64_t i = 0; i != 100; ++i)
  {
    uint64_t v28 = v34[i];
    if (v28)
    {
      heap_Free(*(void **)(a1 + 8), v28);
      v34[i] = 0;
    }
  }
  return v13;
}

int *stackFeats(int *result, int a2, int a3, int *a4, int a5, uint64_t a6)
{
  if (a2 >= 1)
  {
    uint64_t v6 = 0;
    int v7 = 0;
    uint64_t v8 = a2;
    int v9 = 0;
    do
    {
      if (a3 >= 1)
      {
        int v9 = a3 + v7;
        uint64_t v10 = a3;
        uint64_t v11 = result;
        uint64_t v12 = (_DWORD *)(a6 + 4 * v7);
        do
        {
          int v13 = *v11++;
          *v12++ = v13;
          --v10;
        }
        while (v10);
      }
      if (a5 >= 1)
      {
        unint64_t v14 = (_DWORD *)(a6 + 4 * v9);
        int v9 = a5 + (a3 & ~(a3 >> 31)) + v7;
        uint64_t v15 = a5;
        unint64_t v16 = a4;
        do
        {
          int v17 = *v16++;
          *v14++ = v17;
          --v15;
        }
        while (v15);
      }
      ++v6;
      result += a3;
      a4 += a5;
      int v7 = v9;
    }
    while (v6 != v8);
  }
  return result;
}

uint64_t ann_GetNNModel(uint64_t *a1, char *__s2, void *a3)
{
  uint64_t v3 = 2229280775;
  if (a1)
  {
    if (__s2)
    {
      if (a3)
      {
        *a3 = 0;
        uint64_t v7 = *((unsigned int *)a1 + 2);
        if (v7)
        {
          unsigned int v8 = 0;
          uint64_t v9 = 0;
          uint64_t v10 = *a1;
          uint64_t v11 = 144 * v7;
          while (cstdlib_strcmp((const char *)(v10 + v9), __s2))
          {
            v9 += 144;
            ++v8;
            if (v11 == v9) {
              return v3;
            }
          }
          if ((v8 & 0x80000000) == 0 && *((_DWORD *)a1 + 2) > v8)
          {
            uint64_t v3 = 0;
            *a3 = *a1 + v9;
          }
        }
      }
    }
  }
  return v3;
}

uint64_t ann_Reset(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    if (*(void *)a2)
    {
      unint64_t v3 = *(unsigned int *)(a2 + 8);
      if (v3)
      {
        uint64_t v4 = result;
        uint64_t v5 = 0;
        for (unint64_t i = 0; i < v3; ++i)
        {
          uint64_t v7 = *(uint64_t (**)(uint64_t))(*(void *)a2 + v5 + 80);
          if (v7)
          {
            uint64_t result = v7(v4);
            unint64_t v3 = *(unsigned int *)(a2 + 8);
          }
          v5 += 144;
        }
      }
    }
  }
  return result;
}

uint64_t GetNodeNumberOfChildren(char *a1)
{
  NodeAttributeValue_String = (unsigned __int8 *)GetNodeAttributeValue_String(a1, "children");
  if (NodeAttributeValue_String) {
    LODWORD(NodeAttributeValue_String) = cstdlib_atoi(NodeAttributeValue_String);
  }
  return NodeAttributeValue_String & ~((int)NodeAttributeValue_String >> 31);
}

const char *GetNodeChild(char *a1, unsigned int a2)
{
  if (GetNodeNumberOfChildren(a1) > a2)
  {
    uint64_t __dst = 0;
    cstdlib_memcpy((char *)&__dst + 4, a1, 4uLL);
    uint64_t v4 = a1 + 4;
    int v5 = -1;
    uint64_t v6 = a1 + 4;
    while (v6 < &v4[HIDWORD(__dst)])
    {
      uint64_t v7 = &v6[cstdlib_strlen(v6) + 1];
      if (!cstdlib_strcmp(v6, "END"))
      {
        uint64_t result = 0;
        if (-v5 <= 0x7FFFFFFD && v7 < &v4[HIDWORD(__dst)])
        {
          int v9 = 0;
          while (a2 != v9)
          {
            cstdlib_memcpy(&__dst, v7, 4uLL);
            unint64_t v10 = (unint64_t)&v4[HIDWORD(__dst)];
            if ((unint64_t)(v7 + 4) >= v10) {
              return 0;
            }
            uint64_t result = 0;
            if ((v9 - v5) <= 0x7FFFFFFC)
            {
              v7 += __dst + 4;
              ++v9;
              if ((unint64_t)v7 < v10) {
                continue;
              }
            }
            return result;
          }
          return v7;
        }
        return result;
      }
      if (v7 < &v4[HIDWORD(__dst)])
      {
        uint64_t v6 = &v7[cstdlib_strlen(v7) + 1];
        if (--v5 != -2147483647) {
          continue;
        }
      }
      return 0;
    }
  }
  return 0;
}

const char *GetNodeAttributeValue_String(char *__src, const char *a2)
{
  if (!a2) {
    return 0;
  }
  int __dst = 0;
  cstdlib_memcpy(&__dst, __src, 4uLL);
  if (__dst)
  {
    uint64_t v4 = __src + 4;
    int v5 = 2147483645;
    uint64_t v6 = __src + 4;
    while (cstdlib_strcmp(v6, "END"))
    {
      uint64_t v7 = &v6[cstdlib_strlen(v6) + 1];
      if (v7 >= &v4[__dst]) {
        break;
      }
      if (!cstdlib_strcmp(v6, a2)) {
        return v7;
      }
      size_t v8 = cstdlib_strlen(v7);
      uint64_t result = 0;
      if (v5-- != 0)
      {
        uint64_t v6 = &v7[v8 + 1];
        if (v6 < &v4[__dst]) {
          continue;
        }
      }
      return result;
    }
  }
  return 0;
}

uint64_t LoadNnetModel(void **a1, char *a2, void *a3, uint64_t a4, unsigned int a5)
{
  NodeNumberOfChildreuint64_t n = GetNodeNumberOfChildren(a2);
  if (!NnetAlloc(a1, (uint64_t)a3, NodeNumberOfChildren))
  {
    if (!NodeNumberOfChildren) {
      return NodeNumberOfChildren;
    }
    uint64_t v19 = 0;
    uint64_t v34 = NodeNumberOfChildren;
    unsigned int v35 = a5;
    while (1)
    {
      NodeChild = (char *)GetNodeChild(a2, v19);
      if (!NodeChild)
      {
        uint64_t v15 = "Error loading nnet model";
        uint64_t v16 = (uint64_t)a1;
        uint64_t v17 = 269;
        goto LABEL_3;
      }
      uint64_t v21 = NodeChild;
      NodeAttributeValue_String = GetNodeAttributeValue_String(NodeChild, "name");
      int v23 = GetNodeAttributeValue_String(v21, "type");
      if (!NodeAttributeValue_String || (uint64_t v24 = v23) == 0)
      {
        uint64_t v15 = "Error loading nnet model";
        uint64_t v16 = (uint64_t)a1;
        uint64_t v17 = 274;
        goto LABEL_3;
      }
      if (!GetNodeAttributeValue_String(v21, "file"))
      {
        uint64_t v15 = "Error in config file. Required attribute [file] missing.";
        uint64_t v16 = (uint64_t)a1;
        uint64_t v17 = 277;
        goto LABEL_3;
      }
      uint64_t v25 = (unsigned __int8 *)GetNodeAttributeValue_String(v21, "file");
      if (v25)
      {
        unsigned int v26 = cstdlib_atoi(v25);
        if ((v26 & 0x80000000) != 0) {
          goto LABEL_45;
        }
      }
      else
      {
        unsigned int v26 = 0;
      }
      if (v26 >= a5)
      {
LABEL_45:
        uint64_t v15 = "Invalid external data buffer index %d";
        uint64_t v16 = (uint64_t)a1;
        uint64_t v17 = 280;
        return ANNError(v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/ann.c", v17, (uint64_t)v15, v11, v12, v13, v14);
      }
      uint64_t v27 = a4;
      uint64_t v28 = GetNodeAttributeValue_String(v21, "dir");
      unsigned int v29 = GetNodeAttributeValue_String(v21, "firstL");
      if (cstdlib_strcmp(v24, "conv"))
      {
        if (cstdlib_strcmp(v24, "sigm"))
        {
          if (cstdlib_strcmp(v24, "relu"))
          {
            if (cstdlib_strcmp(v24, "lstm"))
            {
              uint64_t v15 = "Unknown nnet layer type %s";
              uint64_t v16 = (uint64_t)a1;
              uint64_t v17 = 295;
              return ANNError(v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/ann.c", v17, (uint64_t)v15, v11, v12, v13, v14);
            }
            int v30 = 2;
            int v31 = 1;
            if (!v28) {
              goto LABEL_32;
            }
          }
          else
          {
            int v31 = 0;
            int v30 = 3;
            if (!v28) {
              goto LABEL_32;
            }
          }
        }
        else
        {
          int v31 = 0;
          int v30 = 1;
          if (!v28) {
            goto LABEL_32;
          }
        }
      }
      else
      {
        int v31 = 0;
        int v30 = 0;
        if (!v28) {
          goto LABEL_32;
        }
      }
      if (cstdlib_strcmp(v28, "back") && cstdlib_strcmp(v28, "bwd"))
      {
        if (cstdlib_strcmp(v28, "forward") && cstdlib_strcmp(v28, "fwd"))
        {
          uint64_t v15 = "Unknown nnet dir %s (expected fwd/bwd)";
          uint64_t v16 = (uint64_t)a1;
          uint64_t v17 = 301;
          return ANNError(v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/ann.c", v17, (uint64_t)v15, v11, v12, v13, v14);
        }
LABEL_32:
        a4 = v27;
        NodeNumberOfChildreuint64_t n = NnetReadLayerAttila(a1, (uint64_t)a3, v19, v30, *(char **)(v27 + 8 * v26));
        if (!v29) {
          goto LABEL_40;
        }
        goto LABEL_33;
      }
      a4 = v27;
      uint64_t LayerAttila = NnetReadLayerAttila(a1, (uint64_t)a3, v19, v30, *(char **)(v27 + 8 * v26));
      if (!v31)
      {
        uint64_t v15 = "Unexpected dir attribute on non-recurrent layer";
        uint64_t v16 = (uint64_t)a1;
        uint64_t v17 = 307;
        goto LABEL_3;
      }
      NodeNumberOfChildreuint64_t n = LayerAttila;
      LstmSetLayerDir(*(void *)(*(void *)(*a3 + 8 * v19) + 8), 1);
      if (!v29)
      {
LABEL_40:
        BOOL v32 = 0;
        if (!v31) {
          goto LABEL_35;
        }
LABEL_34:
        LstmSetFirstLayer(*(void *)(*(void *)(*a3 + 8 * v19) + 8), v32);
        goto LABEL_35;
      }
LABEL_33:
      BOOL v32 = cstdlib_strcmp(v29, "1") == 0;
      if (v31) {
        goto LABEL_34;
      }
LABEL_35:
      if (NodeNumberOfChildren) {
        return NodeNumberOfChildren;
      }
      ++v19;
      a5 = v35;
      if (v34 == v19) {
        return 0;
      }
    }
  }
  uint64_t v15 = "Allocation error";
  uint64_t v16 = (uint64_t)a1;
  uint64_t v17 = 263;
LABEL_3:

  return ANNError(v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/ann.c", v17, (uint64_t)v15, v11, v12, v13, v14);
}

void *AnnObject_Create(uint64_t a1)
{
  uint64_t result = (void *)heap_Calloc(*(void **)(a1 + 8), 1, 72);
  if (result) {
    *uint64_t result = a1;
  }
  return result;
}

void *AnnObject_Destroy(uint64_t a1)
{
  return heap_Free(*(void **)(*(void *)a1 + 8), a1);
}

uint64_t AnnObject_GetInputDimension(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t AnnObject_Open(uint64_t a1, char *a2)
{
  if (!a1) {
    return 2229280778;
  }
  *(_DWORD *)(a1 + 36) = 0;
  uint64_t v3 = ann_Load(*(void ***)a1, (uint64_t *)(a1 + 8), a2);
  if ((v3 & 0x80000000) != 0) {
    UNICORN__log_select_Diag(*(void *)a1, 0, (uint64_t)"AnnObject_Open, Error loading ANN\n");
  }
  else {
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 20);
  }
  return v3;
}

uint64_t AnnObject_Close(void *a1)
{
  if (!a1) {
    return 2229280778;
  }
  AnnObject_ClearLayerAdjuster(a1);
  ann_Unload((void *)*a1, a1 + 1);
  return 0;
}

void *AnnObject_ClearLayerAdjuster(void *a1)
{
  uint64_t v2 = a1[7];
  if (v2) {
    heap_Free(*(void **)(*a1 + 8), v2);
  }

  return cstdlib_memset(a1 + 5, 0, 0x20uLL);
}

uint64_t AnnObject_Reset(uint64_t a1)
{
  if (!a1) {
    return 2229280778;
  }
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  AnnObject_ClearLayerAdjuster((void *)a1);
  ann_Reset(*(void *)a1, a1 + 8);
  return 0;
}

uint64_t AnnObject_Process(uint64_t a1)
{
  if (!a1) {
    return 2229280778;
  }
  uint64_t v2 = ann_Eval(*(void *)a1, a1 + 8, *(int **)(a1 + 24), *(unsigned int *)(a1 + 32), a1 + 40);
  if ((v2 & 0x80000000) != 0) {
    UNICORN__log_select_Diag(*(void *)a1, 0, (uint64_t)"AnnObject_Process, Error evaluating ANN\n");
  }
  return v2;
}

uint64_t AnnObject_Set(uint64_t a1, uint64_t a2, int a3)
{
  if (!a1) {
    return 2229280778;
  }
  uint64_t result = 0;
  *(void *)(a1 + 24) = a2;
  *(_DWORD *)(a1 + 32) = a3;
  return result;
}

uint64_t AnnObject_Get(uint64_t *a1, char *a2, void *a3, _DWORD *a4, _DWORD *a5)
{
  if (!a1) {
    return 2229280778;
  }
  uint64_t v12 = 0;
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  uint64_t NNModel = ann_GetNNModel(a1 + 1, a2, &v12);
  if ((NNModel & 0x80000000) != 0)
  {
    UNICORN__log_select_Diag(*a1, 0, (uint64_t)"AnnObject_Get, Error, Expected output '%s' not found in ANN\n");
  }
  else
  {
    uint64_t v10 = v12;
    *a3 = *(void *)(v12 + 120);
    *a4 = *(_DWORD *)(v10 + 128);
    *a5 = *(_DWORD *)(v10 + 132);
  }
  return NNModel;
}

uint64_t AnnObject_SetLayerAdjuster(uint64_t a1, uint64_t a2, int *a3, unsigned int a4, uint64_t a5)
{
  uint64_t v5 = 2229280775;
  if (a1)
  {
    AnnObject_ClearLayerAdjuster((void *)a1);
    uint64_t v11 = a4;
    uint64_t v12 = (_DWORD *)heap_Calloc(*(void **)(*(void *)a1 + 8), a4, 4);
    *(void *)(a1 + 56) = v12;
    if (v12)
    {
      if (a4)
      {
        do
        {
          int v13 = *a3++;
          *v12++ = v13;
          --v11;
        }
        while (v11);
      }
      uint64_t v5 = 0;
      *(_DWORD *)(a1 + 64) = a4;
      *(void *)(a1 + 40) = a5;
      *(void *)(a1 + 48) = a2;
    }
    else
    {
      UNICORN__log_select_Diag(*(void *)a1, 0, (uint64_t)"AnnObject_SetLayerAdjuster, Error, Out of memory\n");
      return 2229280778;
    }
  }
  return v5;
}

void *NnetClear(void **a1, uint64_t **__b)
{
  uint64_t v3 = *__b;
  if (*__b)
  {
    uint64_t v5 = *v3;
    if (!*v3) {
      goto LABEL_7;
    }
    do
    {
      NnetClearLayer(a1, v5);
      if (*v3) {
        heap_Free(a1[1], *v3);
      }
      *uint64_t v3 = 0;
      uint64_t v6 = v3[1];
      ++v3;
      uint64_t v5 = v6;
    }
    while (v6);
    uint64_t v3 = *__b;
    if (*__b)
    {
LABEL_7:
      heap_Free(a1[1], (uint64_t)v3);
      *int8x16_t __b = 0;
    }
  }

  return cstdlib_memset(__b, 0, 0x10uLL);
}

void **NnetClearLayer(void **result, uint64_t a2)
{
  uint64_t v3 = (uint64_t)result;
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4) {
    uint64_t result = (void **)heap_Free(result[1], v4);
  }
  *(void *)(a2 + 24) = 0;
  uint64_t v5 = *(void **)(a2 + 8);
  if (v5)
  {
    if (*(_DWORD *)a2 == 2)
    {
      uint64_t result = (void **)NnetClearLstmLayerParams(v3, *(void **)(a2 + 8));
    }
    else
    {
      if (*(_DWORD *)a2) {
        goto LABEL_13;
      }
      uint64_t v6 = v5[1];
      if (v6)
      {
        uint64_t result = (void **)heap_Free(*(void **)(v3 + 8), v6);
        v5[1] = 0;
      }
      uint64_t v7 = v5[2];
      if (v7) {
        uint64_t result = (void **)heap_Free(*(void **)(v3 + 8), v7);
      }
      *uint64_t v5 = 0;
      v5[1] = 0;
      v5[2] = 0;
    }
    uint64_t v5 = *(void **)(a2 + 8);
    if (!v5)
    {
LABEL_14:
      *(void *)(a2 + 8) = 0;
      return result;
    }
LABEL_13:
    uint64_t result = (void **)heap_Free(*(void **)(v3 + 8), (uint64_t)v5);
    goto LABEL_14;
  }
  return result;
}

void *NnetInit(void *a1)
{
  return cstdlib_memset(a1, 0, 0x10uLL);
}

BOOL NnetAlloc(void **a1, uint64_t a2, int a3)
{
  NnetClear(a1, (uint64_t **)a2);
  *(_DWORD *)(a2 + 8) = a3;
  uint64_t v6 = heap_Calloc(a1[1], (a3 + 1), 8);
  *(void *)a2 = v6;
  if (!v6) {
    return 1;
  }
  *(void *)(v6 + 8 * a3) = 0;
  return *(void *)a2 == 0;
}

uint64_t NnetReadConvolutionalLayerAttila(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v29 = 0;
  uint64_t __dst = 0;
  uint64_t v28 = 0;
  *(_DWORD *)a2 = 0;
  uint64_t v6 = heap_Calloc(*(void **)(a1 + 8), 1, 24);
  *(void *)(a2 + 8) = v6;
  if (v6)
  {
    uint64_t v11 = v6;
    cstdlib_memcpy((char *)&__dst + 4, a3, 4uLL);
    cstdlib_memcpy(&__dst, a3 + 4, 4uLL);
    cstdlib_memcpy((char *)&v29 + 4, a3 + 8, 4uLL);
    cstdlib_memcpy(&v29, a3 + 12, 4uLL);
    int v16 = HIDWORD(v29);
    if (HIDWORD(v29) >= v29) {
      int v17 = v29;
    }
    else {
      int v17 = HIDWORD(v29);
    }
    if (v17 == 1 && HIDWORD(__dst) == 1)
    {
      if (HIDWORD(v29) <= v29) {
        int v16 = v29;
      }
      *(_DWORD *)uint64_t v11 = v16;
      int v18 = __dst;
      *(_DWORD *)(v11 + 4) = __dst;
      uint64_t v19 = heap_Calloc(*(void **)(a1 + 8), (v18 * v16), 4);
      *(void *)(v11 + 8) = v19;
      if (v19)
      {
        uint64_t v20 = heap_Calloc(*(void **)(a1 + 8), *(unsigned int *)(v11 + 4), 4);
        *(void *)(v11 + 16) = v20;
        if (v20)
        {
          uint64_t v21 = a3 + 16;
          cstdlib_memcpy(*(void **)(v11 + 8), v21, 4 * (*(_DWORD *)(v11 + 4) * *(_DWORD *)v11));
          uint64_t v22 = &v21[4 * *(_DWORD *)(v11 + 4) * *(_DWORD *)v11];
          cstdlib_memcpy((char *)&v28 + 4, v22, 4uLL);
          if (HIDWORD(v28) == 1 || HIDWORD(v28) == *(_DWORD *)v11)
          {
            if (HIDWORD(v28))
            {
              unsigned int v27 = 0;
              do
              {
                v22 += 4;
                cstdlib_memcpy(&v28, v22, 4uLL);
                ++v27;
              }
              while (v27 < HIDWORD(v28));
            }
            cstdlib_memcpy((char *)&v28 + 4, v22 + 4, 4uLL);
            if (HIDWORD(v28) == *(_DWORD *)(v11 + 4))
            {
              cstdlib_memcpy(*(void **)(v11 + 16), v22 + 8, 4 * HIDWORD(v28));
              return 0;
            }
            int v23 = "corrupt weights file";
            uint64_t v24 = a1;
            uint64_t v25 = 168;
          }
          else
          {
            int v23 = "corrupt weights file";
            uint64_t v24 = a1;
            uint64_t v25 = 154;
          }
        }
        else
        {
          int v23 = "allocation error";
          uint64_t v24 = a1;
          uint64_t v25 = 144;
        }
      }
      else
      {
        int v23 = "allocation error";
        uint64_t v24 = a1;
        uint64_t v25 = 139;
      }
    }
    else
    {
      int v23 = "corrupt weights file";
      uint64_t v24 = a1;
      uint64_t v25 = 131;
    }
    return ANNError(v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/nnet.c", v25, (uint64_t)v23, v12, v13, v14, v15);
  }
  else
  {
    return ANNError(a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/nnet.c", 117, (uint64_t)"allocation error", v7, v8, v9, v10);
  }
}

uint64_t NnetReadLayerAttila(void **a1, uint64_t a2, unsigned int a3, int a4, char *a5)
{
  if (*(_DWORD *)(a2 + 8) <= a3) {
    return 1;
  }
  uint64_t v10 = a3;
  uint64_t v11 = *(void *)(*(void *)a2 + 8 * a3);
  if (v11) {
    NnetClearLayer(a1, v11);
  }
  else {
    *(void *)(*(void *)a2 + 8 * a3) = heap_Calloc(a1[1], 1, 40);
  }
  uint64_t v17 = *(void *)(*(void *)a2 + 8 * v10);
  if (a3) {
    uint64_t v18 = *(void *)(*(void *)a2 + 8 * (a3 - 1));
  }
  else {
    uint64_t v18 = 0;
  }
  *(void *)(v17 + 8) = 0;
  *(void *)(v17 + 16) = v18;
  *(void *)(v17 + 32) = 0;
  switch(a4)
  {
    case 0:
      uint64_t result = NnetReadConvolutionalLayerAttila((uint64_t)a1, v17, a5);
      if (!result) {
        goto LABEL_11;
      }
      break;
    case 1:
    case 3:
      *(_DWORD *)uint64_t v17 = a4;
      goto LABEL_11;
    case 2:
      uint64_t result = NnetReadLstmLayer((uint64_t)a1, v17, (uint64_t)a5);
      if (!result) {
LABEL_11:
      }
        uint64_t result = 0;
      break;
    default:
      uint64_t result = ANNError((uint64_t)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/nnet.c", 215, (uint64_t)"LoadNeuralNetFiles", v12, v13, v14, v15);
      break;
  }
  return result;
}

uint64_t NnetForward(uint64_t a1, uint64_t **a2, float32x4_t *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v26 = a5;
  int v27 = a4;
  if (a2 && (uint64_t v9 = *a2) != 0)
  {
    uint64_t v10 = a3;
    if (a3 && a4 && a5)
    {
      uint64_t v11 = *v9;
      if (!*v9) {
        return 0;
      }
      while (1)
      {
        uint64_t v12 = *(void *)(v11 + 16);
        if (v12)
        {
          uint64_t v10 = *(float32x4_t **)(v12 + 24);
          a5 = *(unsigned int *)(v12 + 36);
          int v26 = *(_DWORD *)(v12 + 36);
        }
        switch(*(_DWORD *)v11)
        {
          case 0:
            uint64_t v13 = *(void *)(v11 + 8);
            if (allocLayer(a1, v11, v27, *(_DWORD *)(v13 + 4))) {
              return 1;
            }
            ncblas_sgemm((_DWORD *)(v11 + 36), (unsigned int *)&v27, (_DWORD *)v13, *(float **)(v13 + 8), (int *)v13, v10->f32, &v26, *(void *)(v11 + 24), (int *)(v11 + 36));
            if (*(_DWORD *)(v11 + 32) * *(_DWORD *)(v11 + 36))
            {
              unint64_t v14 = *(void *)(v11 + 24);
              do
              {
                ncblas_saxpy((unsigned int *)(v11 + 36), *(void *)(v13 + 16), v14);
                uint64_t v15 = *(unsigned int *)(v11 + 36);
                v14 += 4 * v15;
              }
              while (v14 < *(void *)(v11 + 24) + 4 * (unint64_t)(*(_DWORD *)(v11 + 32) * v15));
            }
            goto LABEL_27;
          case 1:
            if (allocLayer(a1, v11, v27, a5)) {
              return 1;
            }
            if (v26 * v27)
            {
              int v16 = *(float **)(v11 + 24);
              uint64_t v17 = &v16[v26 * v27];
              do
              {
                float v18 = v10->f32[0];
                uint64_t v10 = (float32x4_t *)((char *)v10 + 4);
                *v16++ = 1.0 / (float)(expf(-v18) + 1.0);
              }
              while (v16 < v17);
            }
            goto LABEL_27;
          case 2:
            if (allocLayer(a1, v11, v27, *(_DWORD *)(*(void *)(v11 + 8) + 4))
              || NnetEvalLstmLayer(a1, v11, v10, v27, v26))
            {
              return 1;
            }
            goto LABEL_27;
          case 3:
            if (allocLayer(a1, v11, v27, a5)) {
              return 1;
            }
            if (v26 * v27)
            {
              uint64_t v19 = *(float **)(v11 + 24);
              uint64_t v20 = &v19[v26 * v27];
              do
              {
                float v21 = v10->f32[0];
                uint64_t v10 = (float32x4_t *)((char *)v10 + 4);
                *v19++ = fmaxf(v21, 0.0);
              }
              while (v19 < v20);
            }
LABEL_27:
            uint64_t v10 = *(float32x4_t **)(v11 + 24);
            a5 = *(unsigned int *)(v11 + 36);
            int v26 = *(_DWORD *)(v11 + 36);
            uint64_t v22 = v9[1];
            ++v9;
            uint64_t v11 = v22;
            if (!v22) {
              return 0;
            }
            break;
          default:
            return ANNError(a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/nnet.c", 309, (uint64_t)"Unexpected layer type", a5, a6, a7, a8);
        }
      }
    }
    uint64_t v24 = "Wrong input";
    uint64_t v25 = 246;
  }
  else
  {
    uint64_t v24 = "Network not initialized";
    uint64_t v25 = 244;
  }

  return ANNError(a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/nnet.c", v25, (uint64_t)v24, a5, a6, a7, a8);
}

uint64_t allocLayer(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v8 = *(void *)(a2 + 24);
  if (v8)
  {
    unsigned int v9 = a4 * a3;
    if (*(_DWORD *)(a2 + 36) * *(_DWORD *)(a2 + 32) == a4 * a3)
    {
      *(_DWORD *)(a2 + 32) = a3;
      *(_DWORD *)(a2 + 36) = a4;
      return 0;
    }
    heap_Free(*(void **)(a1 + 8), v8);
    *(void *)(a2 + 24) = 0;
  }
  else
  {
    unsigned int v9 = a4 * a3;
  }
  uint64_t v10 = heap_Calloc(*(void **)(a1 + 8), v9, 4);
  *(void *)(a2 + 24) = v10;
  *(_DWORD *)(a2 + 32) = a3;
  *(_DWORD *)(a2 + 36) = a4;
  if (v10) {
    return 0;
  }

  return ANNError(a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/nnet.c", 234, (uint64_t)"allocation error", v11, v12, v13, v14);
}

uint64_t NnetGetOutputLayer(uint64_t **a1)
{
  uint64_t v1 = 0;
  uint64_t v2 = *a1;
  do
  {
    uint64_t result = v1;
    uint64_t v4 = *v2++;
    uint64_t v1 = v4;
  }
  while (v4);
  return result;
}

float NnetLayerGetOutput(uint64_t a1, int a2, int a3)
{
  return *(float *)(*(void *)(a1 + 24) + 4 * (a3 + *(_DWORD *)(a1 + 36) * a2));
}

uint64_t ANNError(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  log_OutPublic(*(void *)(a1 + 32), (uint64_t)"SELECT_BET5", 0, 0, a5, a6, a7, a8, v9);
  return 1;
}

uint64_t check_zero_generic(uint64_t result, float *a2, _DWORD *a3)
{
  if ((int)result >= 1)
  {
    uint64_t v3 = result;
    do
    {
      float v4 = *a2++;
      *a3++ = v4 != 0.0;
      --v3;
    }
    while (v3);
  }
  return result;
}

void sigm_inplace(float *a1, int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    unint64_t v3 = (unint64_t)&a1[a2];
    do
    {
      *uint64_t v2 = 1.0 / (float)(expf(-*v2) + 1.0);
      ++v2;
    }
    while ((unint64_t)v2 < v3);
  }
}

void tanh_inplace(float *a1, int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    unint64_t v3 = (unint64_t)&a1[a2];
    do
    {
      *uint64_t v2 = tanhf(*v2);
      ++v2;
    }
    while ((unint64_t)v2 < v3);
  }
}

void tanh_mul_inplace(float *a1, float *a2, float *a3, unsigned int a4)
{
  if (a4)
  {
    uint64_t v7 = a4;
    do
    {
      float v8 = *a2++;
      float v9 = v8;
      float v10 = *a1++;
      *a3++ = v9 * tanhf(v10);
      --v7;
    }
    while (v7);
  }
}

float *multiply_add(float *result, float *a2, float *a3, unsigned int a4)
{
  if (a4)
  {
    uint64_t v4 = a4;
    do
    {
      float v5 = *a2++;
      float v6 = v5;
      float v7 = *a3++;
      *uint64_t result = *result + (float)(v6 * v7);
      ++result;
      --v4;
    }
    while (v4);
  }
  return result;
}

float multiply_multiply_add(float *a1, float *a2, float *a3, float *a4, float *a5, unsigned int a6)
{
  if (a6)
  {
    uint64_t v6 = a6;
    do
    {
      float v7 = *a1++;
      float v8 = v7;
      float v9 = *a2++;
      float v10 = v9;
      float v11 = *a3++;
      float v12 = v11;
      float v13 = *a4++;
      float result = (float)(v12 * v13) + (float)(v8 * v10);
      *a5++ = result;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t NnetReadLstmLayer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v37 = 0;
  int v38 = (const void *)a3;
  unsigned int v35 = 0;
  int v36 = 0;
  uint64_t __dst = 0;
  uint64_t v34 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v30 = 0;
  *(_DWORD *)a2 = 2;
  uint64_t v6 = heap_Calloc(*(void **)(a1 + 8), 1, 144);
  *(void *)(a2 + 8) = v6;
  if (v6)
  {
    uint64_t v11 = v6;
    cstdlib_memcpy((void *)(v6 + 4), (const void *)a3, 4uLL);
    int v38 = (const void *)(a3 + 4);
    *(_DWORD *)(v11 + 16) = 1;
    readVecBuffers(a1, &v38, 4u, &v37, (unsigned int *)&__dst + 1, (_DWORD *)&v31 + 1);
    readVecBuffers(a1, &v38, 4u, &v36, (unsigned int *)&__dst, &v31);
    readVecBuffers(a1, &v38, 3u, &v35, (unsigned int *)&v32 + 1, (_DWORD *)&v30 + 1);
    readVecBuffers(a1, &v38, 4u, &v34, (unsigned int *)&v32, &v30);
    int v16 = v36;
    uint64_t v17 = v37;
    float v18 = v34;
    uint64_t v19 = v35;
    if (v37 && v36 && v35 && v34)
    {
      int v20 = *(_DWORD *)(v11 + 4);
      unsigned int v21 = HIDWORD(__dst) / (4 * v20);
      *(_DWORD *)uint64_t v11 = v21;
      *(void *)(v11 + 24) = v17;
      unint64_t v22 = HIDWORD(v31);
      *(void *)(v11 + 56) = &v17[HIDWORD(v31) & 0xFFFFFFFC];
      *(void *)(v11 + 120) = &v17[4 * ((v22 >> 1) & 0x3FFFFFFF)];
      *(void *)(v11 + 88) = &v17[(3 * v22) & 0xFFFFFFFC];
      if (*(_DWORD *)(v11 + 16))
      {
        NnetTransposeMatrix(a1, v17, v21, v20);
        NnetTransposeMatrix(a1, *(_DWORD **)(v11 + 56), *(_DWORD *)v11, *(_DWORD *)(v11 + 4));
        NnetTransposeMatrix(a1, *(_DWORD **)(v11 + 120), *(_DWORD *)v11, *(_DWORD *)(v11 + 4));
        NnetTransposeMatrix(a1, *(_DWORD **)(v11 + 88), *(_DWORD *)v11, *(_DWORD *)(v11 + 4));
        BOOL v23 = *(_DWORD *)(v11 + 16) == 0;
      }
      else
      {
        BOOL v23 = 1;
      }
      *(void *)(v11 + 32) = v16;
      unint64_t v26 = v31;
      *(void *)(v11 + 64) = &v16[v31 & 0xFFFFFFFC];
      *(void *)(v11 + 128) = &v16[4 * ((v26 >> 1) & 0x3FFFFFFF)];
      *(void *)(v11 + 96) = &v16[(3 * v26) & 0xFFFFFFFC];
      if (!v23)
      {
        NnetTransposeMatrix(a1, v16, *(_DWORD *)(v11 + 4), *(_DWORD *)(v11 + 4));
        NnetTransposeMatrix(a1, *(_DWORD **)(v11 + 64), *(_DWORD *)(v11 + 4), *(_DWORD *)(v11 + 4));
        NnetTransposeMatrix(a1, *(_DWORD **)(v11 + 128), *(_DWORD *)(v11 + 4), *(_DWORD *)(v11 + 4));
        NnetTransposeMatrix(a1, *(_DWORD **)(v11 + 96), *(_DWORD *)(v11 + 4), *(_DWORD *)(v11 + 4));
      }
      uint64_t result = 0;
      int v27 = v30;
      uint64_t v28 = &v18[v30 & 0xFFFFFFFC];
      *(void *)(v11 + 136) = &v18[4 * (((unint64_t)v30 >> 1) & 0x3FFFFFFF)];
      int v29 = HIDWORD(v30);
      *(void *)(v11 + 72) = &v19[4 * (HIDWORD(v30) / 3uLL)];
      *(void *)(v11 + 80) = v28;
      *(void *)(v11 + 40) = v19;
      *(void *)(v11 + 48) = v18;
      *(void *)(v11 + 104) = &v19[4 * ((2 * v29) / 3uLL)];
      *(void *)(v11 + 112) = &v18[(3 * v27) & 0xFFFFFFFC];
    }
    else
    {
      uint64_t v25 = *(void *)(a2 + 8);
      if (v25) {
        heap_Free(*(void **)(a1 + 8), v25);
      }
      *(void *)(a2 + 8) = 0;
      if (v17) {
        heap_Free(*(void **)(a1 + 8), (uint64_t)v17);
      }
      if (v16) {
        heap_Free(*(void **)(a1 + 8), (uint64_t)v16);
      }
      if (v19) {
        heap_Free(*(void **)(a1 + 8), (uint64_t)v19);
      }
      if (v18) {
        heap_Free(*(void **)(a1 + 8), (uint64_t)v18);
      }
      return ANNError(a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/lstm.c", 366, (uint64_t)"error reading weights file", v12, v13, v14, v15);
    }
  }
  else
  {
    return ANNError(a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/lstm.c", 341, (uint64_t)"allocation error", v7, v8, v9, v10);
  }
  return result;
}

void *readVecBuffers(uint64_t a1, const void **a2, unsigned int a3, char **a4, unsigned int *__dst, _DWORD *a6)
{
  *a4 = 0;
  cstdlib_memcpy(__dst, *a2, 4uLL);
  *a2 = (char *)*a2 + 4;
  uint64_t v12 = ((*__dst / a3 + 3) & 0xFFFFFFFC) * a3;
  *a6 = v12;
  unsigned int v13 = *__dst;
  uint64_t v14 = (char *)heap_Calloc(*(void **)(a1 + 8), v12, 4);
  if (v14)
  {
    uint64_t v19 = v14;
    *a4 = v14;
    size_t v20 = 4 * (v13 / a3);
    cstdlib_memcpy(v14, *a2, v20);
    unsigned int v21 = (char *)*a2 + v20;
    *a2 = v21;
    if (a3 == 4)
    {
      cstdlib_memcpy(&v19[v12], v21, v20);
      unint64_t v22 = (char *)*a2 + v20;
      *a2 = v22;
      cstdlib_memcpy(&v19[4 * ((v12 >> 1) & 0x3FFFFFFE)], v22, 4 * (v13 / 4));
      BOOL v23 = (char *)*a2 + v20;
      *a2 = v23;
      unsigned int v24 = (3 * v12) >> 2;
    }
    else
    {
      cstdlib_memcpy(&v19[4 * (v12 / 3uLL)], v21, v20);
      BOOL v23 = (char *)*a2 + v20;
      *a2 = v23;
      unsigned int v24 = 2 * (int)v12 / 3u;
    }
    uint64_t result = cstdlib_memcpy(&v19[4 * v24], v23, v20);
    *a2 = (char *)*a2 + v20;
  }
  else
  {
    return (void *)ANNError(a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/lstm.c", 234, (uint64_t)"allocation error", v15, v16, v17, v18);
  }
  return result;
}

void *NnetTransposeMatrix(uint64_t a1, _DWORD *a2, int a3, int a4)
{
  uint64_t v8 = (a4 * a3);
  uint64_t result = (void *)heap_Calloc(*(void **)(a1 + 8), (v8 + 3) & 0xFFFFFFFC, 4);
  if (result)
  {
    uint64_t v10 = (uint64_t)result;
    if ((int)v8 >= 1)
    {
      for (uint64_t i = 0; i != v8; ++i)
        *((_DWORD *)result + i) = a2[(int)i / a4 + (int)i % a4 * a3];
    }
    cstdlib_memcpy(a2, result, 4 * v8);
    uint64_t v12 = *(void **)(a1 + 8);
    return heap_Free(v12, v10);
  }
  return result;
}

void *NnetClearLstmLayerParams(uint64_t a1, void *__b)
{
  uint64_t v4 = __b[3];
  if (v4)
  {
    heap_Free(*(void **)(a1 + 8), v4);
    __b[3] = 0;
  }
  uint64_t v5 = __b[4];
  if (v5)
  {
    heap_Free(*(void **)(a1 + 8), v5);
    __b[4] = 0;
  }
  uint64_t v6 = __b[5];
  if (v6)
  {
    heap_Free(*(void **)(a1 + 8), v6);
    __b[5] = 0;
  }
  uint64_t v7 = __b[6];
  if (v7)
  {
    heap_Free(*(void **)(a1 + 8), v7);
    __b[6] = 0;
  }

  return cstdlib_memset(__b, 0, 0x90uLL);
}

uint64_t NnetEvalLstmLayer(uint64_t a1, uint64_t a2, float32x4_t *a3, int a4, int a5)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  memset(v36, 0, sizeof(v36));
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = heap_Calloc(*(void **)(a1 + 8), (*(_DWORD *)(a2 + 36) + 3) & 0xFFFFFFFC, 4);
  uint64_t v10 = (float32x4_t *)heap_Calloc(*(void **)(a1 + 8), (*(_DWORD *)(a2 + 36) + 3) & 0xFFFFFFFC, 4);
  uint64_t v11 = 0;
  if (v10) {
    BOOL v12 = v9 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  int v13 = v12;
  do
  {
    uint64_t v14 = (*(_DWORD *)(a2 + 36) + 3) & 0xFFFFFFFC;
    uint64_t v15 = (void *)heap_Calloc(*(void **)(a1 + 8), v14, 4);
    *(void *)((char *)v36 + v11) = v15;
    if (v15) {
      cstdlib_memset(v15, 0, 4 * v14);
    }
    else {
      int v13 = 1;
    }
    v11 += 8;
  }
  while (v11 != 32);
  uint64_t v16 = (unsigned int *)heap_Calloc(*(void **)(a1 + 8), (a5 + 3) & 0xFFFFFFFC, 4);
  unsigned int v21 = v16;
  if (!v16 || v13)
  {
    if (v9) {
      heap_Free(*(void **)(a1 + 8), v9);
    }
    if (v10) {
      heap_Free(*(void **)(a1 + 8), (uint64_t)v10);
    }
    for (uint64_t i = 0; i != 32; i += 8)
    {
      uint64_t v27 = *(void *)((char *)v36 + i);
      if (v27)
      {
        heap_Free(*(void **)(a1 + 8), v27);
        *(void *)((char *)v36 + i) = 0;
      }
    }
    if (v21) {
      heap_Free(*(void **)(a1 + 8), (uint64_t)v21);
    }
    return ANNError(a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AccessibilitySpeechEngines/TextToSpeechMauiSupport/Vendor/code/vocalizer/ttssrc.a/tts_main/be/bet5/ann/annlib/src/lstm.c", 499, (uint64_t)"allocation error", v17, v18, v19, v20);
  }
  else
  {
    uint64_t v33 = v9;
    if (*(_DWORD *)(v8 + 8))
    {
      LstmEval(v8, (float32x4_t *)((char *)a3 + 4 * ((a4 - 1) * a5)), a5, v9, v10, *(unsigned int *)(a2 + 36), (float *)(*(void *)(a2 + 24) + 4 * (*(_DWORD *)(a2 + 36) * (a4 - 1))), (float32x4_t **)v36, v16);
      uint64_t v22 = (a4 - 2);
      if (a4 >= 2)
      {
        uint64_t v23 = v22 + 1;
        unsigned int v24 = (float32x4_t *)((char *)a3 + 4 * a5 * v22);
        do
        {
          uint64_t v25 = v23 - 1;
          LstmEval(v8, v24, a5, *(void *)(a2 + 24) + 4 * v23 * *(int *)(a2 + 36), v10, *(int *)(a2 + 36), (float *)(*(void *)(a2 + 24) + 4 * (v23 - 1) * *(int *)(a2 + 36)), (float32x4_t **)v36, v21);
          unsigned int v24 = (float32x4_t *)((char *)v24 - 4 * a5);
          uint64_t v23 = v25;
        }
        while (v25);
      }
    }
    else
    {
      LstmEval(v8, a3, a5, v9, v10, *(unsigned int *)(a2 + 36), *(float **)(a2 + 24), (float32x4_t **)v36, v16);
      if (a4 >= 2)
      {
        uint64_t v29 = 1;
        uint64_t v30 = (float32x4_t *)((char *)a3 + 4 * a5);
        do
        {
          LstmEval(v8, v30, a5, *(void *)(a2 + 24) + 4 * (v29 - 1) * *(int *)(a2 + 36), v10, *(int *)(a2 + 36), (float *)(*(void *)(a2 + 24) + 4 * v29 * *(int *)(a2 + 36)), (float32x4_t **)v36, v21);
          ++v29;
          uint64_t v30 = (float32x4_t *)((char *)v30 + 4 * a5);
        }
        while (a4 != v29);
      }
    }
    if (v33) {
      heap_Free(*(void **)(a1 + 8), v33);
    }
    if (v10) {
      heap_Free(*(void **)(a1 + 8), (uint64_t)v10);
    }
    heap_Free(*(void **)(a1 + 8), (uint64_t)v21);
    for (uint64_t j = 0; j != 32; j += 8)
    {
      uint64_t v32 = *(void *)((char *)v36 + j);
      if (v32)
      {
        heap_Free(*(void **)(a1 + 8), v32);
        *(void *)((char *)v36 + j) = 0;
      }
    }
    return 0;
  }
}

void LstmEval(uint64_t a1, float32x4_t *a2, int a3, uint64_t a4, float32x4_t *a5, uint64_t a6, float *a7, float32x4_t **a8, unsigned int *a9)
{
  uint64_t v16 = *a8;
  uint64_t v15 = a8[1];
  uint64_t v17 = a8[2];
  uint64_t v31 = a8[3];
  if (*(_DWORD *)(a1 + 12)) {
    ann_check_zero_SIMD(a3, a2, (uint64_t)a9);
  }
  int v34 = a3;
  uint64_t v18 = a6;
  __uint64_t n = 4 * a6;
  cstdlib_memcpy(v16, *(const void **)(a1 + 48), __n);
  uint64_t v19 = *(int8x16_t **)(a1 + 24);
  uint64_t v33 = (uint64_t)a2;
  if (*(_DWORD *)(a1 + 12)) {
    cblas_sgemv_CMP_4M_T_SIMD(a6, v34, v19, (uint64_t)a2, v16, a9);
  }
  else {
    cblas_sgemv_4M_T_SIMD(a6, v34, (float32x4_t *)v19, (uint64_t)a2, v16);
  }
  cblas_sgemv_4M_T_SIMD(a6, a6, *(float32x4_t **)(a1 + 32), a4, v16);
  multiply_add_SIMD(v16, *(float32x4_t **)(a1 + 40), a5, a6);
  if (a6)
  {
    uint64_t v20 = (float *)v16;
    do
    {
      *uint64_t v20 = 1.0 / (float)(expf(-*v20) + 1.0);
      ++v20;
    }
    while (v20 < &v16->f32[a6]);
  }
  cstdlib_memcpy(v15, *(const void **)(a1 + 80), __n);
  unsigned int v21 = *(int8x16_t **)(a1 + 56);
  if (*(_DWORD *)(a1 + 12)) {
    cblas_sgemv_CMP_4M_T_SIMD(a6, v34, v21, v33, v15, a9);
  }
  else {
    cblas_sgemv_4M_T_SIMD(a6, v34, (float32x4_t *)v21, v33, v15);
  }
  cblas_sgemv_4M_T_SIMD(a6, a6, *(float32x4_t **)(a1 + 64), a4, v15);
  multiply_add_SIMD(v15, *(float32x4_t **)(a1 + 72), a5, a6);
  if (a6)
  {
    uint64_t v22 = (float *)v15;
    do
    {
      *uint64_t v22 = 1.0 / (float)(expf(-*v22) + 1.0);
      ++v22;
    }
    while (v22 < &v15->f32[a6]);
  }
  cstdlib_memcpy(v31, *(const void **)(a1 + 136), __n);
  uint64_t v23 = *(int8x16_t **)(a1 + 120);
  if (*(_DWORD *)(a1 + 12)) {
    cblas_sgemv_CMP_4M_T_SIMD(a6, v34, v23, v33, v31, a9);
  }
  else {
    cblas_sgemv_4M_T_SIMD(a6, v34, (float32x4_t *)v23, v33, v31);
  }
  cblas_sgemv_4M_T_SIMD(a6, a6, *(float32x4_t **)(a1 + 128), a4, v31);
  if (a6)
  {
    unsigned int v24 = (float *)v31;
    do
    {
      *unsigned int v24 = tanhf(*v24);
      ++v24;
    }
    while (v24 < &v31->f32[a6]);
  }
  multiply_multiply_add_SIMD(a5, v15, v16, v31, a5, a6);
  cstdlib_memcpy(v17, *(const void **)(a1 + 112), __n);
  uint64_t v25 = *(int8x16_t **)(a1 + 88);
  if (*(_DWORD *)(a1 + 12)) {
    cblas_sgemv_CMP_4M_T_SIMD(a6, v34, v25, v33, v17, a9);
  }
  else {
    cblas_sgemv_4M_T_SIMD(a6, v34, (float32x4_t *)v25, v33, v17);
  }
  cblas_sgemv_4M_T_SIMD(a6, a6, *(float32x4_t **)(a1 + 96), a4, v17);
  multiply_add_SIMD(v17, *(float32x4_t **)(a1 + 104), a5, a6);
  if (a6)
  {
    unint64_t v26 = &v17->f32[a6];
    uint64_t v27 = (float *)v17;
    do
    {
      *uint64_t v27 = 1.0 / (float)(expf(-*v27) + 1.0);
      ++v27;
    }
    while (v27 < v26);
    do
    {
      float32_t v28 = v17->f32[0];
      uint64_t v17 = (float32x4_t *)((char *)v17 + 4);
      float v29 = v28;
      float v30 = a5->f32[0];
      a5 = (float32x4_t *)((char *)a5 + 4);
      *a7++ = v29 * tanhf(v30);
      --v18;
    }
    while (v18);
  }
}

uint64_t LstmSetLayerDir(uint64_t result, int a2)
{
  *(_DWORD *)(result + 8) = a2;
  return result;
}

uint64_t LstmSetFirstLayer(uint64_t result, int a2)
{
  *(_DWORD *)(result + 12) = a2;
  return result;
}

uint64_t ncblas_saxpy(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  if ((int)v3 >= 1)
  {
    if ((v3 & 0xFFFFFFFC) != 0)
    {
      unint64_t v4 = 0;
      uint64_t v5 = (float *)(a2 + 8);
      uint64_t v6 = (float *)(a3 + 8);
      do
      {
        float v7 = *(v6 - 1);
        *(v6 - 2) = *(v5 - 2) + *(v6 - 2);
        *(v6 - 1) = *(v5 - 1) + v7;
        float v8 = v6[1];
        *uint64_t v6 = *v5 + *v6;
        v6[1] = v5[1] + v8;
        v4 += 4;
        v5 += 4;
        v6 += 4;
      }
      while (v4 < (v3 & 0x7FFFFFFC));
    }
    else
    {
      LODWORD(v4) = 0;
    }
    if ((int)v4 < (int)v3)
    {
      uint64_t v9 = (float *)(a3 + 4 * v4);
      uint64_t v10 = (float *)(a2 + 4 * v4);
      uint64_t v11 = v3 - v4;
      do
      {
        float v12 = *v10++;
        *uint64_t v9 = v12 + *v9;
        ++v9;
        --v11;
      }
      while (v11);
    }
  }
  return 0;
}

uint64_t ncblas_sgemm(_DWORD *a1, unsigned int *a2, _DWORD *a3, float *a4, int *a5, float *a6, int *a7, uint64_t a8, int *a9)
{
  uint64_t v9 = *a1;
  if ((v9 & 0x80000000) == 0)
  {
    uint64_t v10 = *a2;
    if ((v10 & 0x80000000) == 0)
    {
      uint64_t v11 = *a3;
      if ((v11 & 0x80000000) == 0)
      {
        uint64_t v12 = *a5;
        int v13 = (int)v11 <= 1 ? 1 : *a3;
        if ((int)v12 >= v13)
        {
          uint64_t v14 = *a7;
          if ((int)v14 >= v13)
          {
            int v15 = v9 <= 1 ? 1 : *a1;
            if (v10 && v9)
            {
              int v16 = *a9;
              if (*a9 >= v15 && v11 != 0)
              {
                uint64_t v18 = v9 + 1;
                uint64_t v19 = v10 + 1;
                uint64_t v20 = 4 * v12;
                uint64_t v21 = 4 * v14;
                uint64_t v22 = 1;
                do
                {
                  uint64_t v23 = a4;
                  uint64_t v24 = 1;
                  do
                  {
                    float v25 = 0.0;
                    uint64_t v26 = v11;
                    uint64_t v27 = a6;
                    float32_t v28 = v23;
                    do
                    {
                      float v29 = *v28++;
                      float v30 = v29;
                      float v31 = *v27++;
                      float v25 = v25 + (float)(v30 * v31);
                      --v26;
                    }
                    while (v26);
                    *(float *)(a8 + 4 * (v16 * ((int)v22 - 1) - 1 + (int)v24)) = v25
                                                                                 + *(float *)(a8
                                                                                            + 4
                                                                                            * (v16 * ((int)v22 - 1)
                                                                                             - 1
                                                                                             + (int)v24));
                    ++v24;
                    uint64_t v23 = (float *)((char *)v23 + v20);
                  }
                  while (v24 != v18);
                  ++v22;
                  a6 = (float *)((char *)a6 + v21);
                }
                while (v22 != v19);
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

void ann_check_zero_SIMD(int a1, float32x4_t *a2, uint64_t a3)
{
  if ((int)(a1 & 0xFFFFFFFC) < 1)
  {
    LODWORD(v3) = 0;
    uint64_t v13 = 0;
  }
  else
  {
    uint64_t v3 = 0;
    __asm { FMOV            V1.4S, #1.0 }
    do
    {
      float32x4_t v9 = *a2++;
      int v10 = vaddvq_s32((int32x4_t)vandq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v9), (int8x16_t)vcgtzq_f32(v9)), (int8x16_t)xmmword_2206E3A20));
      int v11 = vaddvq_s32((int32x4_t)vandq_s8((int8x16_t)vceqq_f32(v9, _Q1), (int8x16_t)xmmword_2206E3A20));
      int v12 = v11 << 8;
      if ((~(v11 | ~v10) & 0xF) != 0) {
        int v12 = 0;
      }
      *(_DWORD *)(a3 + v3) = v10 | v12;
      v3 += 4;
    }
    while ((((a1 & 0xFFFFFFFC) - 4 + 3) & 0x1FFFFFFFCLL) + 4 != v3);
    uint64_t v13 = 4 * ((((a1 & 0xFFFFFFFC) - 1) >> 2) + 1);
  }
  if ((int)v3 < a1) {
    memset_pattern16((void *)(a3 + v13), &unk_2206E3270, 4 * (~v3 + a1) + 4);
  }
}

uint64_t cblas_sgemv_CMP_4M_T_SIMD(uint64_t result, int a2, int8x16_t *a3, uint64_t a4, float32x4_t *a5, unsigned int *a6)
{
  LODWORD(v6) = 0;
  if ((int)result >= 4 && a2 >= 4)
  {
    unint64_t v7 = a2 & 0xFFFFFFFC;
    if ((int)v7 >= 1)
    {
      uint64_t v8 = 0;
      int v9 = result & 0xFFFFFFFC;
      int v10 = (float *)&a3->i32[result & 0xFFFFFFFC];
      do
      {
        uint64_t v11 = result - (uint64_t)v9;
        int v12 = v10;
        uint64_t v13 = &a5->f32[v9];
        if (v9 < (int)result)
        {
          do
          {
            float v14 = *v12++;
            float *v13 = *v13 + (float)(v14 * *(float *)(a4 + 4 * v8));
            ++v13;
            --v11;
          }
          while (v11);
        }
        ++v8;
        v10 += result;
      }
      while (v8 != v7);
      unint64_t v6 = 0;
      uint64_t v15 = 16 * (int)result;
      uint64_t v16 = (uint64_t)a3->i64 + 12 * (int)result;
      uint64_t v17 = &a3->i64[(int)result];
      uint64_t v18 = a3;
      uint64_t v19 = (uint64_t)a3->i64 + 4 * (int)result;
      do
      {
        unsigned int v21 = *a6++;
        unint64_t v20 = v21;
        if (v21)
        {
          if ((v20 & 0xF00) != 0)
          {
            if (v9 >= 1)
            {
              uint64_t v22 = 0;
              int8x16_t v23 = zero_one[(v20 >> 8) & 1];
              int8x16_t v24 = zero_one[(v20 >> 9) & 1];
              int8x16_t v25 = zero_one[(v20 >> 10) & 1];
              unsigned int v26 = (v20 >> 11) & 1;
              uint64_t v27 = a5;
              float32_t v28 = v18;
              int8x16_t v29 = zero_one[v26];
              do
              {
                *uint64_t v27 = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(*v27, (float32x4_t)vandq_s8(*v28, v23)), (float32x4_t)vandq_s8(*(int8x16_t *)((char *)v28 + 4 * (int)result), v24)), (float32x4_t)vandq_s8(*(int8x16_t *)((char *)v28 + 8 * (int)result), v25)), (float32x4_t)vandq_s8(*(int8x16_t *)((char *)v28 + 12 * (int)result), v29));
                ++v27;
                v22 += 4;
                ++v28;
              }
              while (v22 < v9);
            }
          }
          else if (v9 >= 1)
          {
            unint64_t v30 = 0;
            uint64_t v31 = 0;
            uint64_t v32 = (const float *)(a4 + 4 * v6);
            float32x4_t v33 = vld1q_dup_f32(v32);
            int v34 = (const float *)(a4 + ((4 * v6) | 4));
            float32x4_t v35 = vld1q_dup_f32(v34);
            int v36 = (const float *)(a4 + ((4 * v6) | 8));
            float32x4_t v37 = vld1q_dup_f32(v36);
            int v38 = (const float *)(a4 + ((4 * v6) | 0xC));
            float32x4_t v39 = vld1q_dup_f32(v38);
            do
            {
              a5[v30 / 2] = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(a5[v30 / 2], vmulq_f32(v33, (float32x4_t)v18[v30 / 2])), vmulq_f32(v35, *(float32x4_t *)(v19 + v30 * 8))), vmulq_f32(v37, *(float32x4_t *)&v17[v30])), vmulq_f32(v39, *(float32x4_t *)(v16 + v30 * 8)));
              v31 += 4;
              v30 += 2;
            }
            while (v31 < v9);
          }
        }
        v6 += 4;
        uint64_t v18 = (int8x16_t *)((char *)v18 + v15);
        v16 += v15;
        uint64_t v17 = (uint64_t *)((char *)v17 + v15);
        v19 += v15;
      }
      while (v6 < v7);
    }
  }
  if ((int)v6 < a2)
  {
    uint64_t v40 = v6;
    uint64_t v41 = (float *)&a3->i32[(int)result * (unint64_t)v6];
    do
    {
      if ((int)result >= 1)
      {
        uint64_t v42 = result;
        long long v43 = (float *)a5;
        long long v44 = v41;
        do
        {
          float v45 = *v44++;
          *long long v43 = *v43 + (float)(v45 * *(float *)(a4 + 4 * v40));
          ++v43;
          --v42;
        }
        while (v42);
      }
      ++v40;
      v41 += (int)result;
    }
    while (v40 != a2);
  }
  return result;
}

uint64_t cblas_sgemv_4M_T_SIMD(uint64_t result, int a2, float32x4_t *a3, uint64_t a4, float32x4_t *a5)
{
  LODWORD(v5) = 0;
  if ((int)result >= 4 && a2 >= 4)
  {
    unint64_t v6 = a2 & 0xFFFFFFFC;
    if ((int)v6 >= 1)
    {
      uint64_t v7 = 0;
      int v8 = result & 0xFFFFFFFC;
      int v9 = &a3->f32[result & 0xFFFFFFFC];
      do
      {
        uint64_t v10 = result - (uint64_t)v8;
        uint64_t v11 = v9;
        int v12 = &a5->f32[v8];
        if (v8 < (int)result)
        {
          do
          {
            float v13 = *v11++;
            *int v12 = *v12 + (float)(v13 * *(float *)(a4 + 4 * v7));
            ++v12;
            --v10;
          }
          while (v10);
        }
        ++v7;
        v9 += result;
      }
      while (v7 != v6);
      unint64_t v5 = 0;
      float v14 = a3;
      do
      {
        if (v8 >= 1)
        {
          uint64_t v15 = 0;
          uint64_t v16 = (const float *)(a4 + 4 * v5);
          float32x4_t v17 = vld1q_dup_f32(v16);
          uint64_t v18 = (const float *)(a4 + ((4 * v5) | 4));
          float32x4_t v19 = vld1q_dup_f32(v18);
          unint64_t v20 = (const float *)(a4 + ((4 * v5) | 8));
          float32x4_t v21 = vld1q_dup_f32(v20);
          uint64_t v22 = (const float *)(a4 + ((4 * v5) | 0xC));
          float32x4_t v23 = vld1q_dup_f32(v22);
          int8x16_t v24 = a5;
          int8x16_t v25 = v14;
          do
          {
            *int8x16_t v24 = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(*v24, vmulq_f32(v17, *v25)), vmulq_f32(v19, *(float32x4_t *)((char *)v25 + 4 * (int)result))), vmulq_f32(v21, *(float32x4_t *)((char *)v25 + 8 * (int)result))), vmulq_f32(v23, *(float32x4_t *)((char *)v25 + 12 * (int)result)));
            ++v24;
            v15 += 4;
            ++v25;
          }
          while (v15 < v8);
        }
        v5 += 4;
        v14 += (int)result;
      }
      while (v5 < v6);
    }
  }
  if ((int)v5 < a2)
  {
    uint64_t v26 = v5;
    uint64_t v27 = &a3->f32[(int)result * (unint64_t)v5];
    do
    {
      if ((int)result >= 1)
      {
        uint64_t v28 = result;
        int8x16_t v29 = (float *)a5;
        unint64_t v30 = v27;
        do
        {
          float v31 = *v30++;
          float *v29 = *v29 + (float)(v31 * *(float *)(a4 + 4 * v26));
          ++v29;
          --v28;
        }
        while (v28);
      }
      ++v26;
      v27 += (int)result;
    }
    while (v26 != a2);
  }
  return result;
}

float32_t multiply_multiply_add_SIMD(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, float32x4_t *a5, unsigned int a6)
{
  if ((a6 & 0xFFFFFFFC) != 0)
  {
    unint64_t v6 = 0;
    uint64_t v7 = a5;
    int v8 = a4;
    int v9 = a3;
    uint64_t v10 = a2;
    uint64_t v11 = a1;
    do
    {
      float32x4_t v12 = *v11++;
      float32x4_t v13 = v12;
      float32x4_t v14 = *v10++;
      float32x4_t v15 = v14;
      float32x4_t v16 = *v9++;
      float32x4_t v17 = v16;
      float32x4_t v18 = *v8++;
      float32x4_t v19 = vaddq_f32(vmulq_f32(v13, v15), vmulq_f32(v17, v18));
      *v7++ = v19;
      v6 += 4;
    }
    while (v6 < (a6 & 0xFFFFFFFC));
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if (v6 < a6)
  {
    unint64_t v20 = &a1->f32[v6];
    float32x4_t v21 = &a2->f32[v6];
    uint64_t v22 = &a3->f32[v6];
    float32x4_t v23 = &a4->f32[v6];
    int8x16_t v24 = &a5->i32[v6];
    unint64_t v25 = a6 - (unint64_t)v6;
    do
    {
      float v26 = *v20++;
      float v27 = v26;
      float v28 = *v21++;
      float v29 = v28;
      float v30 = *v22++;
      float v31 = v30;
      float v32 = *v23++;
      v19.f32[0] = (float)(v31 * v32) + (float)(v27 * v29);
      *v24++ = v19.i32[0];
      --v25;
    }
    while (v25);
  }
  return v19.f32[0];
}

float32_t multiply_add_SIMD(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3, unsigned int a4)
{
  if ((a4 & 0xFFFFFFFC) != 0)
  {
    unint64_t v4 = 0;
    unint64_t v5 = a3;
    unint64_t v6 = a2;
    uint64_t v7 = a1;
    do
    {
      float32x4_t v8 = *v6++;
      float32x4_t v9 = v8;
      float32x4_t v10 = *v5++;
      float32x4_t v11 = vaddq_f32(*v7, vmulq_f32(v9, v10));
      *v7++ = v11;
      v4 += 4;
    }
    while (v4 < (a4 & 0xFFFFFFFC));
  }
  else
  {
    LODWORD(v4) = 0;
  }
  if (v4 < a4)
  {
    float32x4_t v12 = &a2->f32[v4];
    float32x4_t v13 = &a3->f32[v4];
    float32x4_t v14 = &a1->f32[v4];
    unint64_t v15 = a4 - (unint64_t)v4;
    do
    {
      float v16 = *v12++;
      float v17 = v16;
      float v18 = *v13++;
      v11.f32[0] = *v14 + (float)(v17 * v18);
      *v14++ = v11.f32[0];
      --v15;
    }
    while (v15);
  }
  return v11.f32[0];
}

float *tanh_mul_inplace_approx_ansi_c(float *result, float *a2, float *a3, int a4)
{
  if (a4)
  {
    unint64_t v4 = &result[a4];
    do
    {
      float v5 = *result++;
      float v6 = fmaxf(fminf(v5, 4.9), -4.9);
      float v7 = *a2++;
      *a3++ = (float)(v7
                    * (float)(v6
                            * (float)((float)((float)(v6 * v6)
                                            * (float)((float)((float)(v6 * v6) * (float)((float)(v6 * v6) + 378.0))
                                                    + 17325.0))
                                    + 135140.0)))
            / (float)((float)((float)(v6 * v6)
                            * (float)((float)((float)(v6 * v6) * (float)((float)((float)(v6 * v6) * 28.0) + 3150.0))
                                    + 62370.0))
                    + 135140.0);
    }
    while (result < v4);
  }
  return result;
}

void sigm_inplace_approx_ansi_c(float *a1, int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    unint64_t v3 = (unint64_t)&a1[a2];
    do
    {
      float v4 = *v2;
      float v5 = 1.0;
      if (*v2 <= 30.0)
      {
        float v5 = 0.0;
        if (v4 >= -30.0) {
          float v5 = 1.0 / (float)(expf(-v4) + 1.0);
        }
      }
      *v2++ = v5;
    }
    while ((unint64_t)v2 < v3);
  }
}

float *tanh_inplace_approx_ansi_c(float *result, int a2)
{
  if (a2)
  {
    uint64_t v2 = &result[a2];
    do
    {
      float v3 = fmaxf(fminf(*result, 4.9), -4.9);
      *result++ = (float)(v3
                        * (float)((float)((float)(v3 * v3)
                                        * (float)((float)((float)(v3 * v3) * (float)((float)(v3 * v3) + 378.0)) + 17325.0))
                                + 135140.0))
                / (float)((float)((float)(v3 * v3)
                                * (float)((float)((float)(v3 * v3) * (float)((float)((float)(v3 * v3) * 28.0) + 3150.0))
                                        + 62370.0))
                        + 135140.0);
    }
    while (result < v2);
  }
  return result;
}

uint64_t cblas_sgemv_generic(uint64_t result, int a2, float *a3, float *a4, uint64_t a5)
{
  if ((int)result >= 1)
  {
    uint64_t v5 = 0;
    do
    {
      if (a2 >= 1)
      {
        float v6 = *(float *)(a5 + 4 * v5);
        uint64_t v7 = a2;
        float32x4_t v8 = a4;
        float32x4_t v9 = a3;
        do
        {
          float v10 = *v9++;
          float v11 = v10;
          float v12 = *v8++;
          float v6 = v6 + (float)(v11 * v12);
          *(float *)(a5 + 4 * v5) = v6;
          --v7;
        }
        while (v7);
      }
      ++v5;
      a3 += a2;
    }
    while (v5 != result);
  }
  return result;
}

uint64_t cblas_sgemv_generic_T(uint64_t result, int a2, float *a3, uint64_t a4, float *a5)
{
  if (a2 >= 1)
  {
    for (uint64_t i = 0; i != a2; ++i)
    {
      if ((int)result >= 1)
      {
        uint64_t v6 = result;
        uint64_t v7 = a5;
        float32x4_t v8 = a3;
        do
        {
          float v9 = *v8++;
          *uint64_t v7 = *v7 + (float)(v9 * *(float *)(a4 + 4 * i));
          ++v7;
          --v6;
        }
        while (v6);
      }
      a3 += (int)result;
    }
  }
  return result;
}

void *FastInferObject_Create(uint64_t a1)
{
  uint64_t result = (void *)heap_Calloc(*(void **)(a1 + 8), 1, 72);
  if (result) {
    *uint64_t result = a1;
  }
  return result;
}

void *FastInferObject_Destroy(uint64_t a1)
{
  return heap_Free(*(void **)(*(void *)a1 + 8), a1);
}

uint64_t FastInferObject_GetInputDimension(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t FastInferObject_Open(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 2229280768;
  if (!a1) {
    return 2229280778;
  }
  *(_DWORD *)(a1 + 36) = 0;
  uint64_t v5 = fi_rsc_create(*(void **)a1, (void *)(a1 + 8));
  if (v5)
  {
    uint64_t v11 = v5;
    uint64_t v12 = *(void *)a1;
    float32x4_t v13 = "FastInfer Resource creation failed: %d";
  }
  else
  {
    uint64_t v14 = a1 + 16;
    uint64_t v15 = parse_fi_binary_model(*(uint64_t **)(a1 + 8), a2, (void *)(a1 + 16));
    if (v15)
    {
      uint64_t v11 = v15;
      uint64_t v12 = *(void *)a1;
      float32x4_t v13 = "FastInfer NN binary model parsing failed: %d";
    }
    else
    {
      if (*(_DWORD *)(*(void *)v14 + 52) == 2)
      {
        uint64_t v2 = 0;
        *(_DWORD *)(a1 + 36) = *(_DWORD *)(*(void *)v14 + 60);
        return v2;
      }
      uint64_t v12 = *(void *)a1;
      float32x4_t v13 = "FastInfer NN binary model has an invalid number of dimensions: %d";
      uint64_t v11 = 0;
    }
  }
  UNICORN__log_select_Error(v12, v11, (uint64_t)v13, v6, v7, v8, v9, v10);
  return v2;
}

uint64_t FastInferObject_Close(void *a1)
{
  if (!a1) {
    return 2229280778;
  }
  FastInferObject_ClearLayerAdjuster(a1);
  uint64_t v2 = a1[2];
  if (v2)
  {
    fi_net_destroy(v2);
    a1[2] = 0;
  }
  uint64_t result = a1[1];
  if (result)
  {
    fi_rsc_destroy((void *)result);
    uint64_t result = 0;
    a1[1] = 0;
  }
  return result;
}

void *FastInferObject_ClearLayerAdjuster(void *a1)
{
  uint64_t v2 = a1[6];
  if (v2) {
    heap_Free(*(void **)(*a1 + 8), v2);
  }

  return cstdlib_memset(a1 + 5, 0, 0x20uLL);
}

uint64_t FastInferObject_Reset(uint64_t a1)
{
  if (!a1) {
    return 2229280778;
  }
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  FastInferObject_ClearLayerAdjuster((void *)a1);
  return 0;
}

uint64_t FastInferObject_Process(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 2229280768;
  if (!a1) {
    return 2229280778;
  }
  uint64_t v17 = 0;
  uint64_t v10 = fi_net_predict_ex(*(uint64_t ***)(a1 + 16), (const void **)(a1 + 24), *(unsigned int *)(a1 + 32), &v17, (uint64_t)FastInferObject_LayerAdjusterCB, a1, 0, a8);
  if (!v10) {
    return 0;
  }
  UNICORN__log_select_Error(*(void *)a1, v10, (uint64_t)"FastInferObject_Process, Error evaluating ANN\n", v11, v12, v13, v14, v15);
  return v8;
}

uint64_t FastInferObject_LayerAdjusterCB(uint64_t a1, char *__s1, uint64_t a3, _DWORD *a4)
{
  if (*(void *)(a1 + 64) && !cstdlib_strcmp(__s1, *(const char **)(a1 + 40)))
  {
    if (*a4 == 2)
    {
      (*(void (**)(uint64_t, void, void, void, uint64_t))(a1 + 64))(a3, (a4[2] * a4[1]), *(void *)(a1 + 48), *(unsigned int *)(a1 + 56), a3);
      return 1;
    }
    UNICORN__log_select_Error(*(void *)a1, 0, (uint64_t)"FastInferObject_LayerAdjusterCB called with an invalid dimension (%d, expected 2)\n", v7, v8, v9, v10, v11);
  }
  return 0;
}

uint64_t FastInferObject_BorrowModelInputs(uint64_t a1, uint64_t a2, int a3)
{
  if (!a1) {
    return 2229280778;
  }
  uint64_t result = 0;
  *(void *)(a1 + 24) = a2;
  *(_DWORD *)(a1 + 32) = a3;
  return result;
}

uint64_t FastInferObject_BorrowModelOutputLayer(uint64_t *a1, char *a2, uint64_t *a3, _DWORD *a4, unsigned __int32 *a5)
{
  uint64_t v5 = 2229280775;
  if (!a1) {
    return 2229280778;
  }
  __n128 v19 = 0uLL;
  int v20 = 0;
  fi_net_borrow_output_data(a1[2], a2, a3, &v19);
  if (v10)
  {
    UNICORN__log_select_Error(*a1, v10, (uint64_t)"fi_net_borrow_output_data failed - Expected output '%s' not found in ANN\n", v11, v12, v13, v14, v15);
    unsigned __int32 v16 = 0;
    *a3 = 0;
    *a4 = 0;
  }
  else
  {
    uint64_t v5 = 0;
    unsigned __int32 v17 = v19.n128_u32[0];
    *a4 = v19.n128_u32[1];
    unsigned __int32 v16 = v19.n128_u32[2];
    if (v17 <= 1) {
      unsigned __int32 v16 = 0;
    }
  }
  *a5 = v16;
  return v5;
}

uint64_t FastInferObject_SetLayerAdjuster(uint64_t a1, uint64_t a2, int *a3, unsigned int a4, uint64_t a5)
{
  uint64_t v5 = 2229280775;
  if (a1)
  {
    FastInferObject_ClearLayerAdjuster((void *)a1);
    uint64_t v11 = a4;
    uint64_t v12 = (_DWORD *)heap_Calloc(*(void **)(*(void *)a1 + 8), a4, 4);
    *(void *)(a1 + 48) = v12;
    if (v12)
    {
      if (a4)
      {
        do
        {
          int v18 = *a3++;
          *v12++ = v18;
          --v11;
        }
        while (v11);
      }
      uint64_t v5 = 0;
      *(void *)(a1 + 64) = a5;
      *(_DWORD *)(a1 + 56) = a4;
      *(void *)(a1 + 40) = a2;
    }
    else
    {
      UNICORN__log_select_Error(*(void *)a1, 0, (uint64_t)"FastInferObject_SetLayerAdjuster, Error, Out of memory\n", v13, v14, v15, v16, v17);
      return 2229280778;
    }
  }
  return v5;
}

uint64_t synth_bet5_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2229280769;
  }
  uint64_t result = 0;
  *a2 = &ISynth_Bet5;
  return result;
}

uint64_t synth_bet5_ClassOpen(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v5 = 0;
  if (!a3) {
    return 2229280775;
  }
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v5);
  if ((result & 0x80000000) == 0)
  {
    *(void *)a3 = v5;
    *(_DWORD *)(a3 + 8) = 9357;
  }
  return result;
}

uint64_t synth_bet5_ClassClose()
{
  return 0;
}

uint64_t synth_bet5_ObjOpen(uint64_t a1, int a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t Object = 2229280775;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  unsigned int v32 = 0;
  long long v30 = xmmword_26D214CC8;
  float v31 = off_26D214CD8;
  if (a5)
  {
    uint64_t inited = InitRsrcFunction(a3, a4, &v34);
    if ((inited & 0x80000000) != 0)
    {
      return inited;
    }
    else
    {
      if ((safeh_HandleCheck(a1, a2, 9357, 416) & 0x80000000) == 0)
      {
        *(void *)a5 = 0;
        *(_DWORD *)(a5 + 8) = 0;
        log_OutText(*(void *)(v34 + 32), (uint64_t)"SYNTH_BET5", 4, 0, (uint64_t)"Entering synth_bet5_ObjOpen", v12, v13, v14, v28);
        uint64_t v15 = (void *)heap_Calloc(*(void **)(v34 + 8), 1, 22608);
        if (!v15)
        {
          log_OutPublic(*(void *)(v34 + 32), (uint64_t)"SYNTH_BET5", 59000, 0, v16, v17, v18, v19, v29);
          uint64_t Object = 2229280778;
          goto LABEL_20;
        }
        uint64_t v20 = (uint64_t)v15;
        *uint64_t v15 = a3;
        v15[1] = a4;
        uint64_t v21 = v34;
        v15[2] = v34;
        v15[3] = a1;
        v15[10] = 0;
        Listeuint64_t n = critsec_ObjOpen(*(void *)(v21 + 16), *(void **)(v21 + 8), v15 + 4);
        if ((Listen & 0x80000000) != 0) {
          goto LABEL_16;
        }
        *(void *)&long long v30 = v20;
        Listeuint64_t n = synth_bet5_loc_ParamGetListen(v20, "volume", 0, 100, 0x50u, &v30, &v32);
        if ((Listen & 0x80000000) != 0
          || (Listeuint64_t n = synth_bet5_loc_ParamGetListen(v20, "rate", 50, 400, 0x64u, &v30, &v32), (Listen & 0x80000000) != 0)
          || (Listeuint64_t n = synth_bet5_loc_ParamGetListen(v20, "rate_baseline", 50, 400, 0x64u, &v30, &v32),
              (Listen & 0x80000000) != 0)
          || (Listeuint64_t n = synth_bet5_loc_ParamGetListen(v20, "waitfactor", 0, 9, 2u, &v30, &v32), (Listen & 0x80000000) != 0)
          || (Listeuint64_t n = synth_bet5_loc_ParamGetListen(v20, "pitch", 50, 200, 0x64u, &v30, &v32),
              (Listen & 0x80000000) != 0)
          || (Listeuint64_t n = synth_bet5_loc_ParamGetListen(v20, "pitch_baseline", 50, 200, 0x64u, &v30, &v32),
              (Listen & 0x80000000) != 0)
          || (Listeuint64_t n = synth_bet5_loc_SynthInit(v20), (Listen & 0x80000000) != 0))
        {
LABEL_16:
          uint64_t Object = Listen;
        }
        else
        {
          uint64_t Object = objc_GetObject(*(void *)(v34 + 48), (uint64_t)"SYNTHSTREAM", &v33);
          if ((Object & 0x80000000) == 0)
          {
            *(void *)(v20 + 21496) = *(void *)(v33 + 8);
            *(void *)a5 = v20;
            *(_DWORD *)(a5 + 8) = 9356;
LABEL_20:
            log_OutText(*(void *)(v34 + 32), (uint64_t)"SYNTH_BET5", 4, 0, (uint64_t)"synth_bet5_ObjOpen: %x", v24, v25, v26, Object);
            return Object;
          }
          log_OutPublic(*(void *)(*(void *)(v20 + 16) + 32), (uint64_t)"SYNTH_BET5", 59001, 0, v23, v24, v25, v26, v29);
        }
        *(void *)a5 = v20;
        *(_DWORD *)(a5 + 8) = 9356;
        synth_bet5_ObjClose(v20, *(void *)(a5 + 8));
        *(void *)a5 = 0;
        *(_DWORD *)(a5 + 8) = 0;
        goto LABEL_20;
      }
      return 2229280776;
    }
  }
  return Object;
}

uint64_t synth_bet5_ObjClose(uint64_t a1, int a2)
{
  int v3 = safeh_HandleCheck(a1, a2, 9356, 22608);
  if (v3 < 0) {
    return 2229280776;
  }
  int v7 = v3;
  uint64_t v8 = *(void *)(a1 + 16);
  log_OutText(*(void *)(v8 + 32), (uint64_t)"SYNTH_BET5", 4, 0, (uint64_t)"Entering synth_bet5_ObjClose", v4, v5, v6, v44);
  uint64_t v9 = *(void *)(v8 + 40);
  uint64_t v46 = a1;
  long long v45 = *(long long *)((char *)&xmmword_26D214CC8 + 8);
  long long v47 = *(long long *)((char *)&xmmword_26D214CC8 + 8);
  int v10 = paramc_ListenerRemove(v9, "volume", (long long *)&v46);
  uint64_t v11 = *(void *)(v8 + 40);
  if (v10 >= 0) {
    int v12 = v7;
  }
  else {
    int v12 = v10;
  }
  uint64_t v46 = a1;
  long long v47 = v45;
  int v13 = paramc_ListenerRemove(v11, "rate", (long long *)&v46);
  uint64_t v14 = *(void *)(v8 + 40);
  if (v13 < 0 && v12 > -1) {
    int v12 = v13;
  }
  uint64_t v46 = a1;
  long long v47 = v45;
  int v16 = paramc_ListenerRemove(v14, "rate_baseline", (long long *)&v46);
  uint64_t v17 = *(void *)(v8 + 40);
  if (v16 < 0 && v12 > -1) {
    int v12 = v16;
  }
  uint64_t v46 = a1;
  long long v47 = v45;
  int v19 = paramc_ListenerRemove(v17, "waitfactor", (long long *)&v46);
  uint64_t v20 = *(void *)(v8 + 40);
  if (v19 < 0 && v12 > -1) {
    int v12 = v19;
  }
  uint64_t v46 = a1;
  long long v47 = v45;
  int v22 = paramc_ListenerRemove(v20, "pitch", (long long *)&v46);
  uint64_t v23 = *(void *)(v8 + 40);
  if (v22 < 0 && v12 > -1) {
    int v12 = v22;
  }
  uint64_t v46 = a1;
  long long v47 = v45;
  int v25 = paramc_ListenerRemove(v23, "pitch_baseline", (long long *)&v46);
  uint64_t v26 = *(void *)(v8 + 40);
  if (v25 < 0 && v12 > -1) {
    int v12 = v25;
  }
  uint64_t v46 = a1;
  long long v47 = v45;
  int v28 = paramc_ListenerRemove(v26, "audiooutputbufsamples", (long long *)&v46);
  BOOL v29 = v28 >= 0 || v12 <= -1;
  uint64_t v30 = *(void *)(v8 + 40);
  float v31 = *(unsigned char **)(a1 + 21424);
  if (v29) {
    LODWORD(v32) = v12;
  }
  else {
    LODWORD(v32) = v28;
  }
  uint64_t v46 = a1;
  long long v47 = v45;
  int v33 = paramc_ListenerRemove(v30, v31, (long long *)&v46);
  if ((int)v32 > -1 && v33 < 0) {
    uint64_t v32 = v33;
  }
  else {
    uint64_t v32 = v32;
  }
  synth_bet5_loc_LoadAddons((_WORD **)a1, "");
  heap_Free(*(void **)(v8 + 8), *(void *)(a1 + 21424));
  if (*(void *)(a1 + 21496))
  {
    int v35 = objc_ReleaseObject(*(void *)(v8 + 48), (uint64_t)"SYNTHSTREAM");
    if ((int)v32 > -1 && v35 < 0) {
      uint64_t v32 = v35;
    }
    else {
      uint64_t v32 = v32;
    }
  }
  if (*(void *)(a1 + 80))
  {
    uint64_t v32 = Lookup_ObjClose((uint64_t *)(a1 + 80));
    *(void *)(a1 + 80) = 0;
  }
  uint64_t v37 = *(void *)(a1 + 32);
  if (v37)
  {
    int v38 = critsec_ObjClose(v37);
    if ((int)v32 > -1 && v38 < 0) {
      uint64_t v32 = v38;
    }
    else {
      uint64_t v32 = v32;
    }
  }
  heap_Free(*(void **)(v8 + 8), a1);
  log_OutText(*(void *)(v8 + 32), (uint64_t)"SYNTH_BET5", 4, 0, (uint64_t)"synth_bet5_ObjClose: %x", v40, v41, v42, v32);
  return v32;
}

uint64_t synth_bet5_ObjReopen(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 9356, 22608) & 0x80000000) != 0) {
    return 2229280776;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  log_OutText(*(void *)(v6 + 32), (uint64_t)"SYNTH_BET5", 4, 0, (uint64_t)"Entering synth_bet5_ObjReopen", v3, v4, v5, v12);
  uint64_t v7 = synth_bet5_loc_SynthInit(a1);
  log_OutText(*(void *)(v6 + 32), (uint64_t)"SYNTH_BET5", 4, 0, (uint64_t)"synth_bet5_ObjReopen: %x", v8, v9, v10, v7);
  return v7;
}

uint64_t synth_bet5_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if ((safeh_HandleCheck(a1, a2, 9356, 22608) & 0x80000000) != 0) {
    return 2229280776;
  }
  synstrmaux_InitStreamOpener(a1 + 21504, *(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET5");
  *(_DWORD *)(a1 + 22588) = 0;
  *(_WORD *)(a1 + 22592) = -2;
  *(void *)(a1 + 22596) = 0x100000001;
  *(_DWORD *)(a1 + 22552) = 0;
  *(void *)(a1 + 22576) = 0;
  if (synstrmaux_BuildAudioContentType("audio/L16;rate=", *(_DWORD *)(a1 + 48), (char *)(a1 + 21444), 0x30uLL) > 0x2F) {
    return 9;
  }
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21504), (uint64_t)"application/x-realspeak-unit-index-in-sentence;version=4.0",
    0,
    a1 + 22392);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21504), (uint64_t)"application/x-realspeak-psola-f0begin;version=4.0",
    0,
    a1 + 22408);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21504), (uint64_t)"application/x-realspeak-psola-f0end;version=4.0",
    0,
    a1 + 22424);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21504), (uint64_t)"application/x-realspeak-psola-duration;version=4.0",
    0,
    a1 + 22440);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21504), (uint64_t)"application/x-realspeak-psola-maxfade-l;version=4.0",
    0,
    a1 + 22456);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21504), (uint64_t)"application/x-realspeak-psola-maxfade-r;version=4.0",
    0,
    a1 + 22472);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21504), (uint64_t)"application/x-realspeak-psola-adjacent-l;version=4.0",
    0,
    a1 + 22488);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21504), (uint64_t)"application/x-realspeak-psola-adjacent-r;version=4.0",
    0,
    a1 + 22504);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21504), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
    0,
    a1 + 22328);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21504), (uint64_t)"application/x-realspeak-usids;version=4.0",
    0,
    a1 + 22344);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21504), (uint64_t)"application/x-realspeak-usoffsets;version=5.0",
    0,
    a1 + 22360);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21504), (uint64_t)"application/x-realspeak-usdurs-32;version=5.0",
    0,
    a1 + 22376);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 21504), a1 + 21444, a1 + 22520);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 21504), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
    a1 + 22536);
  uint64_t v8 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 21504), *(void *)(a1 + 21496), a3, a4);
  if ((v8 & 0x80000000) != 0) {
    synth_bet5_ProcessEnd(a1, a2);
  }
  return v8;
}

uint64_t synth_bet5_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  DirectEndStreauint64_t m = -2065686518;
  float v147 = 0;
  if ((safeh_HandleCheck(a1, a2, 9356, 22608) & 0x80000000) == 0)
  {
    *a5 = 1;
    log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET5", 3, 0, (uint64_t)"SYNTH-IN   ----------------- synth_bet5_Process [enter] -----------------", v8, v9, v10, v118);
    v154[0] = 0;
    uint64_t v152 = 0;
    long long v153 = 0uLL;
    uint64_t v150 = 0;
    uint64_t v151 = 0;
    int32x4_t v148 = 0;
    uint64_t v149 = 0;
    uint64_t v145 = 0;
    uint64_t v146 = 0;
    uint64_t v143 = 0;
    uint64_t v144 = 0;
    uint64_t v142 = 0;
    uint64_t v140 = 0;
    uint64_t v141 = 0;
    uint64_t v138 = 0;
    uint64_t v139 = 0;
    uint64_t v136 = 0;
    uint64_t v137 = 0;
    uint64_t v11 = (*(uint64_t (**)(void, void, char *, void *))(*(void *)(a1 + 21496) + 144))(*(void *)(a1 + 22344), *(void *)(a1 + 22352), (char *)&v153 + 12, v154);
    if ((v11 & 0x80000000) != 0)
    {
      uint64_t v20 = v11;
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET5", 59004, (uint64_t)"%s%x", v12, v13, v14, v15, "lhError");
      goto LABEL_130;
    }
    uint64_t v20 = (*(uint64_t (**)(void, void, uint64_t *, char *))(*(void *)(a1 + 21496) + 144))(*(void *)(a1 + 22328), *(void *)(a1 + 22336), &v149, (char *)v154 + 4);
    if ((v20 & 0x80000000) == 0)
    {
      if (!v149 && !HIDWORD(v153) && LODWORD(v154[0]) && HIDWORD(v154[0]))
      {
        uint64_t v20 = synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 21504), *(void *)(a1 + 21496));
        if ((v20 & 0x80000000) != 0) {
          goto LABEL_130;
        }
        unsigned int v21 = 0;
        unsigned int v22 = 0;
LABEL_38:
        if (!(v21 | v22) || !*a5) {
          goto LABEL_130;
        }
        if (v22)
        {
          uint64_t v41 = (*(uint64_t (**)(void, void, void **, void))(*(void *)(a1 + 21496) + 112))(*(void *)(a1 + 22536), *(void *)(a1 + 22544), &v147, 32 * v22);
          if ((v41 & 0x80000000) != 0)
          {
            uint64_t v20 = v41;
            log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET5", 59007, (uint64_t)"%s%s%s%x", v42, v43, v44, v45, "stream");
            goto LABEL_130;
          }
        }
        uint64_t v46 = critsec_Enter(*(void **)(a1 + 32));
        if ((v46 & 0x80000000) != 0)
        {
          uint64_t v20 = v46;
          goto LABEL_130;
        }
        if (v22 && v148 && v147) {
          cstdlib_memcpy(v147, v148, 32 * v22);
        }
        if (v21)
        {
          uint64_t v47 = v146;
          uint64_t v48 = v143;
          if (!*(_DWORD *)(v143 + 4))
          {
            *(_WORD *)(a1 + 22592) = -2;
            FreePsolaData((void *)a1);
            int v49 = UNICORN__Psola_Initialise((uint64_t *)(a1 + 22576), *(void *)(a1 + 16), *(_DWORD *)(a1 + 48));
            if (v49 < 0)
            {
              int v106 = v49;
              log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET5", 59000, 0, v50, v51, v52, v53, v119);
              int v102 = 0;
              DirectEndStreauint64_t m = v106;
              goto LABEL_99;
            }
          }
          uint64_t v54 = heap_Realloc(*(uint64_t **)(*(void *)(a1 + 16) + 8), *(void *)(*(void *)(a1 + 22576) + 128), 40 * (*(_DWORD *)(*(void *)(a1 + 22576) + 120) + v21));
          *(void *)(*(void *)(a1 + 22576) + 128) = v54;
          if (v54)
          {
            long long v59 = (int *)(a1 + 22568);
            int v60 = *(_DWORD *)(a1 + 22568);
            int v61 = v60 - *(_DWORD *)(v48 + 4);
            unsigned int v62 = v21 - v61;
            int v63 = v21 - v61 + 1;
            uint64_t v64 = heap_Realloc(*(uint64_t **)(*(void *)(a1 + 16) + 8), *(void *)(a1 + 22560), 8 * (v63 + v60));
            *(void *)(a1 + 22560) = v64;
            if (v64)
            {
              cstdlib_memset((void *)(v64 + 8 * *v59), 0, 8 * v63);
              if (v21 == v61)
              {
                unsigned int v65 = *v59 + v62;
                *(void *)(*(void *)(a1 + 22560) + 8 * v65) = 0;
                *long long v59 = v65;
                goto LABEL_54;
              }
              uint64_t v88 = 0;
              DirectEndStreauint64_t m = 0;
              if (v62 <= 1) {
                uint64_t v89 = 1;
              }
              else {
                uint64_t v89 = v62;
              }
              uint64_t v133 = v89;
              while (1)
              {
                uint64_t v90 = (v61 + v88);
                int v91 = concat_UID2AddonId(*(void *)(a1 + 21432), *(_DWORD *)(a1 + 21440), *(_DWORD *)(v47 + 4 * v90));
                concat_enableAddon(a1 + 56, v91);
                uint64_t v92 = newPeriDesc(*(void *)(a1 + 16));
                int v93 = *v59;
                uint64_t v94 = (v88 + *v59);
                *(void *)(*(void *)(a1 + 22560) + 8 * v94) = v92;
                uint64_t v95 = *(void *)(a1 + 22560);
                int v96 = *(void **)(v95 + 8 * v94);
                if (!v96) {
                  break;
                }
                int v97 = *(_DWORD *)(v47 + 4 * v90);
                if (v97 == -1)
                {
                  *int v96 = 0;
                }
                else
                {
                  int v98 = Lookup_UnitPeriInfo(*(void **)(a1 + 88), v97 - *(_DWORD *)(a1 + 108), (uint64_t)v96);
                  if (v98 < 0)
                  {
                    DirectEndStreauint64_t m = v98;
                    goto LABEL_97;
                  }
                  DirectEndStreauint64_t m = Psola_AssignPeriRanges_0(*(unsigned __int16 **)(*(void *)(a1 + 22560)
                                                                                  + 8 * (v88 + *v59)));
                  uint64_t v95 = *(void *)(a1 + 22560);
                  int v93 = *v59;
                  uint64_t v94 = (v88 + *v59);
                }
                uint64_t v99 = *(void *)(v95 + 8 * v94);
                if (!*(_WORD *)(v99 + 4))
                {
                  __int16 v100 = *(_WORD *)(v99 + 2);
                  if (v100)
                  {
                    *(_WORD *)(v99 + 4) = 1;
                    *(_WORD *)(v99 + 2) = v100 - 1;
                  }
                }
                if (v133 == ++v88)
                {
                  unsigned int v101 = v93 + v21 - v61;
                  *(void *)(v95 + 8 * v101) = 0;
                  *long long v59 = v101;
                  if ((DirectEndStream & 0x80000000) == 0) {
                    goto LABEL_54;
                  }
                  goto LABEL_97;
                }
              }
            }
            DirectEndStreauint64_t m = -2065686518;
          }
LABEL_97:
          log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET5", 59000, 0, v55, v56, v57, v58, v119);
          goto LABEL_98;
        }
LABEL_54:
        *(void *)(*(void *)(a1 + 22576) + 152) = *(void *)(a1 + 22560);
        int v66 = UNICORN__concat_init(*(void *)(a1 + 16), 0, 0, (uint64_t)"", (uint64_t)synth_bet5_loc_WsolaOutputCB, a1, 0, 0, a1 + 56, *(_DWORD *)(a1 + 22556), 1);
        if (v66 < 0 || (int v66 = UNICORN__concat_initW(a1 + 56), v66 < 0))
        {
          DirectEndStreauint64_t m = v66;
        }
        else
        {
          synth_bet5_loc_ProceedToNextPhonemeMarkerForSynthesizing(a1, (uint64_t)v147, v22);
          synth_bet5_loc_ProceedToNextPhonemeMarkerForDelivering(a1, (uint64_t)v147, v22);
          if (!v21) {
            goto LABEL_107;
          }
          int32x4_t v125 = (uint64_t *)(a1 + 56);
          unint64_t v67 = 0;
          int8x16_t v126 = (__int16 *)(a1 + 22592);
          int32x4_t v122 = (unsigned int *)(a1 + 22600);
          uint64_t v68 = -8;
          unsigned int v123 = v22;
          float v124 = a5;
          do
          {
            uint64_t v69 = v146;
            uint64_t v71 = v144;
            uint64_t v70 = v145;
            uint64_t v127 = v142;
            uint64_t v128 = v141;
            uint64_t v129 = v140;
            uint64_t v130 = v139;
            uint64_t v131 = v138;
            uint64_t v132 = v137;
            uint64_t v134 = v136;
            uint64_t v135 = v68;
            uint64_t v72 = *(void *)(*(void *)(a1 + 16) + 32);
            uint64_t v73 = *(unsigned int *)(v146 + 4 * v67);
            UNICORN__concat_Dur2Sample(*(_DWORD *)(a1 + 120), *(_DWORD *)(v144 + 4 * v67));
            log_OutText(v72, (uint64_t)"SYNTH_BET5", 3, 0, (uint64_t)"SYNTH-IN   unitId %d (phonstate %d): %d msec (= %d smp)\n", v74, v75, v76, v73);
            uint64_t v77 = *(void *)(a1 + 22576);
            uint64_t v78 = (_DWORD *)(*(void *)(v77 + 128) + 40 * *(int *)(v77 + 120));
            _DWORD *v78 = *(_DWORD *)(v69 + 4 * v67);
            v78[1] = *(_DWORD *)(v70 + 4 * v67);
            v78[2] = *(_DWORD *)(v71 + 4 * v67);
            v78[3] = *(_DWORD *)(v127 + 4 * v67);
            _OWORD v78[4] = *(_DWORD *)(v128 + 4 * v67);
            v78[5] = *(_DWORD *)(v129 + 4 * v67);
            v78[6] = *(_DWORD *)(v130 + 4 * v67);
            v78[7] = *(_DWORD *)(v131 + 4 * v67);
            v78[8] = *(_DWORD *)(v132 + 4 * v67);
            v78[9] = *(_DWORD *)(v134 + 4 * v67);
            DirectEndStreauint64_t m = UNICORN__Psola_Synthesis((uint64_t)v125, v77);
            if (DirectEndStream < 0)
            {
              log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET5", 59100, 0, v79, v80, v81, v82, v121);
              unsigned int v84 = v123;
              uint64_t v83 = v124;
              uint64_t v85 = (unsigned __int16 *)(a1 + 22584);
            }
            else
            {
              ++*v126;
              unsigned int v84 = v123;
              uint64_t v83 = v124;
              uint64_t v85 = (unsigned __int16 *)(a1 + 22584);
              log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET5", 3, 0, (uint64_t)"SYNTH-OUT  generated %d samples covering %d units for phoneme [%c]", v80, v81, v82, *(unsigned int *)(a1 + 22588));
              if (*v126 == *(unsigned __int16 *)(a1 + 22584))
              {
                synth_bet5_loc_UpdatePhonemeMarkerDeliveringUnits(a1, (uint64_t)v147, v123);
                synth_bet5_loc_ProceedToNextPhonemeMarkerForDelivering(a1, (uint64_t)v147, v123);
                DirectEndStreauint64_t m = 0;
              }
            }
            if (!(++v67 % *v85)) {
              synth_bet5_loc_ProceedToNextPhonemeMarkerForSynthesizing(a1, (uint64_t)v147, v84);
            }
            uint64_t v68 = v135 + 8;
          }
          while ((DirectEndStream & 0x80000000) == 0 && v67 < v21);
          if (DirectEndStream < 0) {
            goto LABEL_98;
          }
          if (v67)
          {
            BOOL v86 = (*(_DWORD *)(v143 + v68) & 1) == 0;
            if (*(_DWORD *)(v143 + v68))
            {
              if ((UNICORN__Psola_OutputFinalSilence(v125, *(void *)(a1 + 22576)) & 0x80000000) != 0) {
                log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET5", 59100, 0, v108, v109, v110, v111, v119);
              }
              synth_bet5_loc_UpdatePhonemeMarkerDeliveringUnits(a1, (uint64_t)v147, v84);
              synth_bet5_loc_ProceedToNextPhonemeMarkerForDelivering(a1, (uint64_t)v147, v84);
            }
            else if (*v122 <= 0xFFFFFFFD)
            {
              unsigned int v84 = *v122;
            }
            else
            {
              unsigned int v84 = 0;
            }
            char v107 = 0;
            *uint64_t v83 = 1;
          }
          else
          {
LABEL_107:
            unsigned int v84 = *(_DWORD *)(a1 + 22600);
            if (v84 > 0xFFFFFFFD)
            {
              DirectEndStreauint64_t m = synth_bet5_loc_ReadDirectEndStream((void *)a1, 0, 0);
              int v102 = 0;
              goto LABEL_125;
            }
            LODWORD(v67) = 0;
            char v107 = 1;
            BOOL v86 = 1;
          }
          if (!v84
            || (int v112 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 21496) + 120))(*(void *)(a1 + 22536), *(void *)(a1 + 22544), 32 * v84), (v112 & 0x80000000) == 0))
          {
            if (v107)
            {
              DirectEndStreauint64_t m = synth_bet5_loc_ReadDirectEndStream((void *)a1, 0, v84);
              int v102 = 0;
              if (!v86)
              {
LABEL_123:
                *(void *)(a1 + 22596) = 0x100000001;
                goto LABEL_99;
              }
            }
            else
            {
              int v102 = *(_DWORD *)(v143 + 8 * (v67 - 1)) & 1;
              DirectEndStreauint64_t m = synth_bet5_loc_ReadDirectEndStream((void *)a1, v67, v84);
              if (!v86) {
                goto LABEL_123;
              }
            }
LABEL_125:
            *(void *)(a1 + 22596) = -1;
LABEL_99:
            int v103 = critsec_Leave(*(void **)(a1 + 32));
            if (DirectEndStream > -1 && v103 < 0) {
              uint64_t v20 = v103;
            }
            else {
              uint64_t v20 = DirectEndStream;
            }
            if (v102)
            {
              uint64_t v105 = "SYNTH-OUT   ----------------- synth_bet5_Process [exit eos] -----------------";
LABEL_131:
              log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET5", 3, 0, (uint64_t)v105, v17, v18, v19, v119);
              return v20;
            }
LABEL_130:
            uint64_t v105 = "SYNTH-OUT   ----------------- synth_bet5_Process [exit] -----------------";
            goto LABEL_131;
          }
          DirectEndStreauint64_t m = v112;
          log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET5", 59007, (uint64_t)"%s%s%s%x", v113, v114, v115, v116, "stream");
        }
LABEL_98:
        int v102 = 0;
        goto LABEL_99;
      }
      if (!HIDWORD(v153))
      {
        unsigned int v22 = 0;
        unsigned int v21 = 0;
        *a5 = 0;
        goto LABEL_38;
      }
      uint64_t v26 = (*(uint64_t (**)(void, void, uint64_t *, char *))(*(void *)(a1 + 21496) + 88))(*(void *)(a1 + 22344), *(void *)(a1 + 22352), &v146, (char *)&v153 + 12);
      if ((v26 & 0x80000000) != 0)
      {
        uint64_t v20 = v26;
        uint64_t v87 = *(void *)(*(void *)(a1 + 16) + 32);
      }
      else
      {
        HIDWORD(v153) >>= 2;
        uint64_t v31 = (*(uint64_t (**)(void, void, uint64_t *, char *))(*(void *)(a1 + 21496) + 88))(*(void *)(a1 + 22360), *(void *)(a1 + 22368), &v145, (char *)&v153 + 8);
        if ((v31 & 0x80000000) != 0)
        {
          uint64_t v20 = v31;
          uint64_t v87 = *(void *)(*(void *)(a1 + 16) + 32);
        }
        else
        {
          DWORD2(v153) >>= 2;
          uint64_t v32 = (*(uint64_t (**)(void, void, uint64_t *, char *))(*(void *)(a1 + 21496) + 88))(*(void *)(a1 + 22376), *(void *)(a1 + 22384), &v144, (char *)&v153 + 4);
          if ((v32 & 0x80000000) != 0)
          {
            uint64_t v20 = v32;
            uint64_t v87 = *(void *)(*(void *)(a1 + 16) + 32);
          }
          else
          {
            DWORD1(v153) >>= 2;
            uint64_t v33 = (*(uint64_t (**)(void, void, uint64_t *, long long *))(*(void *)(a1 + 21496) + 88))(*(void *)(a1 + 22392), *(void *)(a1 + 22400), &v143, &v153);
            if ((v33 & 0x80000000) != 0)
            {
              uint64_t v20 = v33;
              uint64_t v87 = *(void *)(*(void *)(a1 + 16) + 32);
            }
            else
            {
              LODWORD(v153) = v153 >> 3;
              uint64_t v34 = (*(uint64_t (**)(void, void, uint64_t *, char *))(*(void *)(a1 + 21496) + 88))(*(void *)(a1 + 22408), *(void *)(a1 + 22416), &v142, (char *)&v152 + 4);
              if ((v34 & 0x80000000) != 0)
              {
                uint64_t v20 = v34;
                uint64_t v87 = *(void *)(*(void *)(a1 + 16) + 32);
              }
              else
              {
                HIDWORD(v152) >>= 2;
                uint64_t v35 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *))(*(void *)(a1 + 21496) + 88))(*(void *)(a1 + 22424), *(void *)(a1 + 22432), &v141, &v152);
                if ((v35 & 0x80000000) != 0)
                {
                  uint64_t v20 = v35;
                  uint64_t v87 = *(void *)(*(void *)(a1 + 16) + 32);
                }
                else
                {
                  LODWORD(v152) = v152 >> 2;
                  uint64_t v36 = (*(uint64_t (**)(void, void, uint64_t *, char *))(*(void *)(a1 + 21496) + 88))(*(void *)(a1 + 22440), *(void *)(a1 + 22448), &v140, (char *)&v151 + 4);
                  if ((v36 & 0x80000000) != 0)
                  {
                    uint64_t v20 = v36;
                    uint64_t v87 = *(void *)(*(void *)(a1 + 16) + 32);
                  }
                  else
                  {
                    HIDWORD(v151) >>= 2;
                    uint64_t v37 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *))(*(void *)(a1 + 21496)
                                                                                          + 88))(*(void *)(a1 + 22456), *(void *)(a1 + 22464), &v139, &v151);
                    if ((v37 & 0x80000000) != 0)
                    {
                      uint64_t v20 = v37;
                      uint64_t v87 = *(void *)(*(void *)(a1 + 16) + 32);
                    }
                    else
                    {
                      LODWORD(v151) = v151 >> 2;
                      uint64_t v38 = (*(uint64_t (**)(void, void, uint64_t *, char *))(*(void *)(a1 + 21496) + 88))(*(void *)(a1 + 22472), *(void *)(a1 + 22480), &v138, (char *)&v150 + 4);
                      if ((v38 & 0x80000000) != 0)
                      {
                        uint64_t v20 = v38;
                        uint64_t v87 = *(void *)(*(void *)(a1 + 16) + 32);
                      }
                      else
                      {
                        HIDWORD(v150) >>= 2;
                        uint64_t v39 = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *))(*(void *)(a1 + 21496)
                                                                                              + 88))(*(void *)(a1 + 22488), *(void *)(a1 + 22496), &v137, &v150);
                        if ((v39 & 0x80000000) != 0)
                        {
                          uint64_t v20 = v39;
                          uint64_t v87 = *(void *)(*(void *)(a1 + 16) + 32);
                        }
                        else
                        {
                          LODWORD(v150) = v150 >> 2;
                          uint64_t v40 = (*(uint64_t (**)(void, void, uint64_t *, char *))(*(void *)(a1 + 21496)
                                                                                             + 88))(*(void *)(a1 + 22504), *(void *)(a1 + 22512), &v136, (char *)&v149 + 4);
                          if ((v40 & 0x80000000) == 0)
                          {
                            HIDWORD(v149) >>= 2;
                            uint64_t v20 = (*(uint64_t (**)(void, void, const void **, uint64_t *))(*(void *)(a1 + 21496) + 88))(*(void *)(a1 + 22328), *(void *)(a1 + 22336), &v148, &v149);
                            if ((v20 & 0x80000000) != 0)
                            {
                              uint64_t v23 = *(void *)(*(void *)(a1 + 16) + 32);
                              uint64_t v120 = "contentType";
                              uint64_t v24 = "%s%s%s%x";
                            }
                            else
                            {
                              unsigned int v22 = v149 >> 5;
                              LODWORD(v149) = v149 >> 5;
                              unsigned int v21 = HIDWORD(v153);
                              if (__PAIR64__(HIDWORD(v153), HIDWORD(v153)) == *(void *)((char *)&v153 + 4)
                                && HIDWORD(v153) == v153
                                && HIDWORD(v153) == HIDWORD(v152)
                                && HIDWORD(v153) == v152
                                && HIDWORD(v153) == HIDWORD(v151)
                                && HIDWORD(v153) == v151
                                && HIDWORD(v153) == HIDWORD(v150)
                                && HIDWORD(v153) == v150
                                && HIDWORD(v153) == HIDWORD(v149))
                              {
                                goto LABEL_38;
                              }
                              uint64_t v23 = *(void *)(*(void *)(a1 + 16) + 32);
                              uint64_t v20 = 2229280768;
                              LODWORD(v120) = -2065686528;
                              uint64_t v24 = "Consistency check failed when reading synthstreams";
                            }
                            uint64_t v25 = 59005;
LABEL_13:
                            log_OutPublic(v23, (uint64_t)"SYNTH_BET5", v25, (uint64_t)v24, v16, v17, v18, v19, v120);
                            goto LABEL_130;
                          }
                          uint64_t v20 = v40;
                          uint64_t v87 = *(void *)(*(void *)(a1 + 16) + 32);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      log_OutPublic(v87, (uint64_t)"SYNTH_BET5", 59005, (uint64_t)"%s%s%s%x", v27, v28, v29, v30, "contentType");
      goto LABEL_130;
    }
    uint64_t v23 = *(void *)(*(void *)(a1 + 16) + 32);
    uint64_t v120 = "lhError";
    uint64_t v24 = "%s%x";
    uint64_t v25 = 59004;
    goto LABEL_13;
  }
  return 2229280776;
}

uint64_t synth_bet5_ProcessEnd(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 9356, 22608) & 0x80000000) != 0) {
    return 2229280776;
  }
  *(_DWORD *)(a1 + 22552) = 0;
  Lookup_DeInit(*(uint64_t **)(a1 + 80));
  FreePsolaData((void *)a1);
  UNICORN__concat_final_deinitW((uint64_t *)(a1 + 56));
  uint64_t v3 = *(void *)(a1 + 21496);

  return synstrmaux_CloseStreams((_WORD *)(a1 + 21504), v3);
}

uint64_t synth_bet5_loc_ParamCheckChange(int a1, char *__s1, const char *a3, _DWORD *a4)
{
  if (cstdlib_strcmp(__s1, "audiooutputbufsamples"))
  {
    if (cstdlib_strcmp(__s1, "volume"))
    {
      if (cstdlib_strcmp(__s1, "rate"))
      {
        if (!cstdlib_strcmp(__s1, "rate_baseline"))
        {
          BOOL v8 = __CFADD__(LH_atoi(a3) - 401, 351);
LABEL_25:
          if (v8) {
            uint64_t result = 0;
          }
          else {
            uint64_t result = 2229280783;
          }
          goto LABEL_28;
        }
        if (!cstdlib_strcmp(__s1, "ratewpm"))
        {
          uint64_t result = 2229280769;
          goto LABEL_28;
        }
        if (cstdlib_strcmp(__s1, "waitfactor"))
        {
          if (cstdlib_strcmp(__s1, "pitch_baseline") && cstdlib_strcmp(__s1, "pitch"))
          {
            uint64_t result = 0;
            goto LABEL_28;
          }
          BOOL v8 = __CFADD__(LH_atoi(a3) - 201, 151);
          goto LABEL_25;
        }
        if (LH_atoi(a3) <= 9) {
          uint64_t result = 0;
        }
        else {
          uint64_t result = 2229280783;
        }
      }
      else if (LH_atoi(a3) - 401 >= 0xFFFFFEA1)
      {
        uint64_t result = 0;
      }
      else
      {
        uint64_t result = 2229280783;
      }
    }
    else if (LH_atoi(a3) <= 0x64)
    {
      uint64_t result = 0;
    }
    else
    {
      uint64_t result = 2229280783;
    }
  }
  else if ((int)LH_atoi(a3) <= 0)
  {
    uint64_t result = 2229280783;
  }
  else
  {
    uint64_t result = 0;
  }
LABEL_28:
  *a4 = (int)result >= 0;
  return result;
}

uint64_t synth_bet5_loc_ParamLearnChange(uint64_t a1, char *__s1, char *a3)
{
  if (cstdlib_strcmp(__s1, "audiooutputbufsamples")
    && cstdlib_strcmp(__s1, "volume")
    && cstdlib_strcmp(__s1, "rate")
    && cstdlib_strcmp(__s1, "rate_baseline")
    && cstdlib_strcmp(__s1, "pitch_baseline")
    && cstdlib_strcmp(__s1, "ratewpm")
    && cstdlib_strcmp(__s1, "waitfactor")
    && cstdlib_strcmp(__s1, "pitch"))
  {
    if (cstdlib_strcmp(__s1, *(const char **)(a1 + 21424)))
    {
      return 0;
    }
    else
    {
      return synth_bet5_loc_LoadAddons((_WORD **)a1, a3);
    }
  }
  else
  {
    uint64_t v7 = LH_atoi(a3);
    return synth_bet5_loc_ParamSet(a1, __s1, (uint64_t)v7);
  }
}

uint64_t synth_bet5_loc_ParamGetListen(uint64_t a1, unsigned char *a2, signed int a3, signed int a4, unsigned int a5, long long *a6, unsigned int *a7)
{
  if ((paramc_ParamGetInt(*(void *)(*(void *)(a1 + 16) + 40), (uint64_t)a2, a7) & 0x80000000) != 0
    || (a5 = a3, (int)*a7 < a3)
    || (a5 = a4, (int)*a7 > a4))
  {
    uint64_t v14 = paramc_ParamSetInt(*(void *)(*(void *)(a1 + 16) + 40), (uint64_t)a2, a5);
    *a7 = a5;
    if ((v14 & 0x80000000) != 0)
    {
      uint64_t v20 = v14;
      uint64_t v21 = *(void *)(*(void *)(a1 + 16) + 32);
      uint64_t v25 = "parameter";
      uint64_t v23 = "%s%s";
      uint64_t v22 = 59009;
      goto LABEL_8;
    }
  }
  uint64_t v19 = *(void *)(*(void *)(a1 + 16) + 40);
  long long v26 = *a6;
  uint64_t v27 = *((void *)a6 + 2);
  uint64_t v20 = paramc_ListenerAdd(v19, a2, &v26);
  if ((v20 & 0x80000000) != 0)
  {
    uint64_t v21 = *(void *)(*(void *)(a1 + 16) + 32);
    uint64_t v22 = 59010;
    uint64_t v23 = 0;
LABEL_8:
    log_OutPublic(v21, (uint64_t)"SYNTH_BET5", v22, (uint64_t)v23, v15, v16, v17, v18, v25);
  }
  return v20;
}

uint64_t synth_bet5_loc_SynthInit(uint64_t a1)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 16);
  unsigned int v33 = 0;
  uint64_t v31 = 0;
  __s2 = 0;
  uint64_t v3 = a1 + 80;
  if (*(void *)(a1 + 80))
  {
    Lookup_ObjClose((uint64_t *)(a1 + 80));
    *(void *)uint64_t v3 = 0;
  }
  uint64_t UInt = paramc_ParamGetUInt(*(void *)(v2 + 40), (uint64_t)"frequencyhz", (unsigned int *)(a1 + 48));
  if ((UInt & 0x80000000) != 0)
  {
    uint64_t Str = UInt;
    goto LABEL_16;
  }
  uint64_t v30 = 0;
  *(_DWORD *)(a1 + 120) = *(_DWORD *)(a1 + 48);
  uint64_t RegularBrokerString = betX_CreateRegularBrokerString(v2, 2, v34, 0x100uLL);
  if ((RegularBrokerString & 0x80000000) != 0) {
    return RegularBrokerString;
  }
  uint64_t v10 = Lookup_ObjOpen(*(_WORD **)a1, *(void *)(a1 + 8), *(void *)(a1 + 24), (uint64_t)v34, (uint64_t *)v3);
  if ((v10 & 0x80000000) != 0)
  {
    uint64_t Str = v10;
    *(void *)uint64_t v3 = 0;
    return Str;
  }
  Lookup_GetComponentID(*(void *)v3, &__s2);
  if (!__s2 || !*__s2) {
    goto LABEL_18;
  }
  *(void *)&long long __s1 = 0;
  uint64_t Str = paramc_ParamGetStr(*(void *)(v2 + 40), (uint64_t)"voicecomponentid", &__s1);
  if ((Str & 0x80000000) != 0)
  {
LABEL_16:
    log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET5", 59008, (uint64_t)"%s%s", v5, v6, v7, v8, "parameter");
    return Str;
  }
  if ((void)__s1 && *(unsigned char *)__s1 && cstdlib_strcmp((const char *)__s1, __s2))
  {
    paramc_ParamGetStr(*(void *)(v2 + 40), (uint64_t)"voice", &v31);
    if (v31 && *v31) {
      uint64_t v16 = *(void *)(*(void *)(a1 + 16) + 32);
    }
    else {
      uint64_t v16 = *(void *)(*(void *)(a1 + 16) + 32);
    }
    log_OutPublic(v16, (uint64_t)"SYNTH_BET5", 59013, (uint64_t)"%s%s", v12, v13, v14, v15, "voice");
    return Str;
  }
LABEL_18:
  *(_DWORD *)(v3 + 22476) = 1;
  *(_DWORD *)(a1 + 156) = 1;
  uint64_t RegularBrokerString = paramc_ParamGetInt(*(void *)(*(void *)(a1 + 16) + 40), (uint64_t)"bet5nstatesperphoneme", &v33);
  if ((RegularBrokerString & 0x80000000) != 0) {
    return RegularBrokerString;
  }
  *(_WORD *)(v3 + 22504) = v33;
  uint64_t v17 = *(char **)(a1 + 21424);
  uint64_t RegularBrokerString = betX_CreateAddonListParamName(*(void *)(a1 + 16), (char **)(a1 + 21424));
  if ((RegularBrokerString & 0x80000000) != 0) {
    return RegularBrokerString;
  }
  if (!v17)
  {
    uint64_t RegularBrokerString = paramc_ParamSetStr(*(void *)(*(void *)(a1 + 16) + 40), *(void *)(a1 + 21424), "");
    if ((RegularBrokerString & 0x80000000) == 0) {
      goto LABEL_29;
    }
    return RegularBrokerString;
  }
  if (!cstdlib_strcmp(v17, *(const char **)(a1 + 21424))) {
    goto LABEL_30;
  }
  __s = 0;
  if (*(_DWORD *)(v3 + 21360))
  {
    uint64_t RegularBrokerString = synth_bet5_loc_LoadAddons((_WORD **)a1, "");
    if ((RegularBrokerString & 0x80000000) != 0) {
      return RegularBrokerString;
    }
  }
  uint64_t v18 = *(void *)(v2 + 40);
  *(void *)&long long __s1 = a1;
  *((void *)&__s1 + 1) = synth_bet5_loc_ParamCheckChange;
  uint64_t v29 = synth_bet5_loc_ParamLearnChange;
  paramc_ListenerRemove(v18, v17, &__s1);
  paramc_ParamGetStr(*(void *)(v2 + 40), *(void *)(a1 + 21424), &__s);
  if (__s)
  {
    uint64_t RegularBrokerString = synth_bet5_loc_LoadAddons((_WORD **)a1, __s);
    if ((RegularBrokerString & 0x80000000) != 0) {
      return RegularBrokerString;
    }
  }
LABEL_29:
  uint64_t v19 = *(void *)(*(void *)(a1 + 16) + 40);
  uint64_t v20 = *(unsigned char **)(a1 + 21424);
  *(void *)&long long __s1 = a1;
  *((void *)&__s1 + 1) = synth_bet5_loc_ParamCheckChange;
  uint64_t v29 = synth_bet5_loc_ParamLearnChange;
  uint64_t RegularBrokerString = paramc_ListenerAdd(v19, v20, &__s1);
  if ((RegularBrokerString & 0x80000000) != 0) {
    return RegularBrokerString;
  }
LABEL_30:
  heap_Free(*(void **)(v2 + 8), (uint64_t)v17);
  uint64_t Int = paramc_ParamGetInt(*(void *)(*(void *)(a1 + 16) + 40), (uint64_t)"volume", &v33);
  if ((Int & 0x80000000) == 0)
  {
    uint64_t Int = synth_bet5_loc_ParamSet(a1, "volume", v33);
    if ((Int & 0x80000000) == 0)
    {
      uint64_t Int = paramc_ParamGetInt(*(void *)(*(void *)(a1 + 16) + 40), (uint64_t)"rate_baseline", &v33);
      if ((Int & 0x80000000) == 0)
      {
        uint64_t Int = synth_bet5_loc_ParamSet(a1, "rate_baseline", v33);
        if ((Int & 0x80000000) == 0)
        {
          uint64_t Int = paramc_ParamGetInt(*(void *)(*(void *)(a1 + 16) + 40), (uint64_t)"pitch_baseline", &v33);
          if ((Int & 0x80000000) == 0)
          {
            uint64_t Int = synth_bet5_loc_ParamSet(a1, "pitch_baseline", v33);
            if ((Int & 0x80000000) == 0)
            {
              uint64_t Int = paramc_ParamGetInt(*(void *)(*(void *)(a1 + 16) + 40), (uint64_t)"rate", &v33);
              if ((Int & 0x80000000) == 0)
              {
                uint64_t Int = synth_bet5_loc_ParamSet(a1, "rate", v33);
                if ((Int & 0x80000000) == 0)
                {
                  uint64_t Int = paramc_ParamGetInt(*(void *)(*(void *)(a1 + 16) + 40), (uint64_t)"waitfactor", &v33);
                  if ((Int & 0x80000000) == 0)
                  {
                    uint64_t Int = synth_bet5_loc_ParamSet(a1, "waitfactor", v33);
                    if ((Int & 0x80000000) == 0)
                    {
                      uint64_t Int = paramc_ParamGetInt(*(void *)(*(void *)(a1 + 16) + 40), (uint64_t)"pitch", &v33);
                      if ((Int & 0x80000000) == 0) {
                        uint64_t Int = synth_bet5_loc_ParamSet(a1, "pitch", v33);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  uint64_t Str = Int;
  if (!Lookup_HasSupportForPsola(*(void *)v3, (_DWORD *)&v30 + 1, &v30))
  {
    log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET5", 3, 0, (uint64_t)"PMK data not available, PSOLA not possible", v22, v23, v24, v26);
    return 2229280769;
  }
  return Str;
}

uint64_t synth_bet5_loc_ParamSet(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v6 = critsec_Enter(*(void **)(a1 + 32));
  if ((v6 & 0x80000000) == 0)
  {
    if (cstdlib_strcmp(a2, "volume"))
    {
      if (cstdlib_strcmp(a2, "rate_baseline"))
      {
        uint64_t v10 = 2229280783;
        if (!cstdlib_strcmp(a2, "rate"))
        {
          uint64_t v17 = MapProsodyValue_Scaling(50, 100, 400, *(_DWORD *)(a1 + 44), a3);
          if ((v17 - 401) >= 0xFFFFFEA1)
          {
            double v21 = (double)(int)v17;
            log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET5", 3, 0, (uint64_t)"Set rate %d (synth %f)", v18, v19, v20, v17);
            *(double *)(a1 + 21400) = v21;
            goto LABEL_19;
          }
          goto LABEL_24;
        }
        if (!cstdlib_strcmp(a2, "ratewpm"))
        {
          uint64_t v10 = 2229280769;
          goto LABEL_24;
        }
        if (cstdlib_strcmp(a2, "pitch_baseline"))
        {
          if (cstdlib_strcmp(a2, "pitch"))
          {
LABEL_19:
            uint64_t v10 = v6;
            goto LABEL_24;
          }
          uint64_t v11 = MapProsodyValue_Scaling(50, 100, 200, *(_DWORD *)(a1 + 40), a3);
          if ((v11 - 201) >= 0xFFFFFF69)
          {
            double v15 = (double)((int)v11 - 100) + (double)((int)v11 - 100);
            log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET5", 3, 0, (uint64_t)"Set pitch %d (synth %f)", v12, v13, v14, v11);
            *(double *)(a1 + 21408) = v15;
            goto LABEL_19;
          }
LABEL_24:
          critsec_Leave(*(void **)(a1 + 32));
          return v10;
        }
        if ((a3 - 201) < 0xFFFFFF69) {
          goto LABEL_24;
        }
        unsigned int v26 = 0;
        *(_DWORD *)(a1 + 40) = a3;
        uint64_t v22 = "pitch";
        paramc_ParamGetInt(*(void *)(*(void *)(a1 + 16) + 40), (uint64_t)"pitch", &v26);
        uint64_t v23 = v26;
LABEL_21:
        synth_bet5_loc_ParamSet(a1, v22, v23);
        uint64_t v10 = 0;
        goto LABEL_24;
      }
      if ((a3 - 401) >= 0xFFFFFEA1)
      {
        unsigned int v25 = 0;
        *(_DWORD *)(a1 + 44) = a3;
        uint64_t v22 = "rate";
        paramc_ParamGetInt(*(void *)(*(void *)(a1 + 16) + 40), (uint64_t)"rate", &v25);
        uint64_t v23 = v25;
        goto LABEL_21;
      }
    }
    else if (a3 <= 0x64)
    {
      if (a3 <= 0x50) {
        double v16 = (double)(int)a3 / 80.0;
      }
      else {
        double v16 = ((double)(int)a3 + -80.0) / 20.0 + 1.0;
      }
      log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET5", 3, 0, (uint64_t)"Set volume %d (synth %f)", v7, v8, v9, a3);
      *(double *)(a1 + 21392) = v16;
      goto LABEL_19;
    }
    uint64_t v10 = 2229280783;
    goto LABEL_24;
  }
  return v6;
}

uint64_t synth_bet5_loc_LoadAddons(_WORD **a1, char *__s)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  memset(__sa, 0, sizeof(__sa));
  memset(v51, 0, sizeof(v51));
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  *(_OWORD *)int8x16_t __b = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v26 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  *(_OWORD *)uint64_t __dst = 0u;
  uint64_t v4 = (int *)(a1 + 2680);
  if (*((_DWORD *)a1 + 5360))
  {
    unint64_t v5 = 0;
    uint64_t v6 = 4;
    do
    {
      Lookup_DeInit(*(uint64_t **)&a1[2679][v6]);
      Lookup_ObjClose((uint64_t *)&a1[2679][v6]);
      ++v5;
      v6 += 12;
    }
    while (v5 < *v4);
  }
  *uint64_t v4 = 0;
  *((_DWORD *)a1 + 26) = 0;
  if (__s && cstdlib_strlen(__s))
  {
    size_t v17 = 0;
    if (betX_GetVAOName(__s, &v17, __b, 0x100uLL))
    {
      while (1)
      {
        uint64_t v18 = 0;
        uint64_t VAOBrokerString = paramc_ParamSetStr(*((void *)a1[2] + 5), (uint64_t)"voiceaddon", __b);
        if ((VAOBrokerString & 0x80000000) != 0) {
          return VAOBrokerString;
        }
        uint64_t VAOBrokerString = betX_CreateVAOBrokerString((uint64_t)a1[2], 3, (char *)__sa, 0x100uLL, 1);
        if ((VAOBrokerString & 0x80000000) != 0) {
          return VAOBrokerString;
        }
        size_t v8 = cstdlib_strlen((const char *)__sa);
        if (!IsThisUrlOrRealPath((char *)__sa, v8, 0))
        {
          int v16 = 0;
          uint64_t VAOBrokerString = brokeraux_ComposeBrokerString((uint64_t)a1[2], (const char *)__sa, 0, 0, 0, 0, 0, v51, 0x100uLL);
          if ((VAOBrokerString & 0x80000000) != 0) {
            return VAOBrokerString;
          }
          uint64_t VAOBrokerString = Lookup_CheckForDataFile(*a1, (uint64_t)a1[1], v51, &v16);
          if ((VAOBrokerString & 0x80000000) != 0) {
            return VAOBrokerString;
          }
          if (v16 && (Lookup_ObjOpen(*a1, (uint64_t)a1[1], (uint64_t)a1[3], (uint64_t)v51, &v18) & 0x80000000) != 0) {
            uint64_t v18 = 0;
          }
        }
        if (!v18)
        {
          uint64_t VAOBrokerString = Lookup_ObjOpen(*a1, (uint64_t)a1[1], (uint64_t)a1[3], (uint64_t)__sa, &v18);
          if ((VAOBrokerString & 0x80000000) != 0) {
            return VAOBrokerString;
          }
        }
        uint64_t v9 = heap_Realloc(*((uint64_t **)a1[2] + 1), (uint64_t)a1[2679], 24 * (*v4 + 1));
        a1[2679] = (_WORD *)v9;
        if (!v9) {
          break;
        }
        *(void *)(v9 + 24 * *v4 + 8) = v18;
        cstdlib_strcpy(__dst, "voiceaddonoffset.");
        if (cstdlib_strlen(__b))
        {
          uint64_t v10 = 0;
          unsigned int v11 = 1;
          do
          {
            __dst[v10 + 17] = cstdlib_tolower(__b[v10]);
            uint64_t v10 = v11;
          }
          while (cstdlib_strlen(__b) > v11++);
        }
        uint64_t Int = paramc_ParamGetInt(*((void *)a1[2] + 5), (uint64_t)__dst, &a1[2679][12 * *v4 + 8]);
        if ((Int & 0x80000000) == 0)
        {
          int v14 = *v4 + 1;
          *uint64_t v4 = v14;
          a1[12] = a1[2679];
          *((_DWORD *)a1 + 26) = v14;
          cstdlib_memset(__sa, 0, 0x100uLL);
          cstdlib_memset(__b, 0, 0x100uLL);
          cstdlib_memset(__dst, 0, 0x100uLL);
          if (betX_GetVAOName(__s, &v17, __b, 0x100uLL)) {
            continue;
          }
        }
        return Int;
      }
      return 2229280778;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    heap_Free(*((void **)a1[2] + 1), (uint64_t)a1[2679]);
    uint64_t Int = 0;
    a1[2679] = 0;
    a1[12] = 0;
  }
  return Int;
}

uint64_t synth_bet5_loc_ProceedToNextPhonemeMarkerForSynthesizing(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v4 = result;
  unint64_t v5 = (unsigned int *)(result + 22596);
  int v6 = *(_DWORD *)(result + 22596);
  if (v6 == -2)
  {
    unsigned int v7 = 0;
  }
  else if (v6 == -1)
  {
    unsigned int v7 = 1;
  }
  else
  {
    unsigned int v7 = v6 + 1;
  }
  if (v7 < a3)
  {
    size_t v8 = (unsigned int *)(a2 + 32 * v7 + 24);
    while (2)
    {
      int v9 = *(v8 - 6);
      switch(v9)
      {
        case 16:
          critsec_Leave(*(void **)(v4 + 32));
          uint64_t v10 = *(void *)(*(void *)(v4 + 16) + 40);
          unsigned int v11 = *v8;
          uint64_t v12 = "pitch";
          goto LABEL_21;
        case 17:
          critsec_Leave(*(void **)(v4 + 32));
          uint64_t v10 = *(void *)(*(void *)(v4 + 16) + 40);
          unsigned int v11 = *v8;
          uint64_t v12 = "timbre";
          goto LABEL_21;
        case 18:
          critsec_Leave(*(void **)(v4 + 32));
          uint64_t v10 = *(void *)(*(void *)(v4 + 16) + 40);
          unsigned int v11 = *v8;
          goto LABEL_18;
        case 19:
          critsec_Leave(*(void **)(v4 + 32));
          unsigned int v13 = 100 * *v8;
          unsigned int v14 = v13 / 0xC8;
          if (v13 / 0xC8 <= 0x32) {
            unsigned int v14 = 50;
          }
          if (v13 <= 0x13947) {
            unsigned int v11 = v14;
          }
          else {
            unsigned int v11 = 400;
          }
          uint64_t v10 = *(void *)(*(void *)(v4 + 16) + 40);
LABEL_18:
          uint64_t v12 = "rate";
          goto LABEL_21;
        case 20:
        case 21:
        case 22:
        case 23:
          goto LABEL_22;
        case 24:
          critsec_Leave(*(void **)(v4 + 32));
          uint64_t v10 = *(void *)(*(void *)(v4 + 16) + 40);
          unsigned int v11 = *v8;
          uint64_t v12 = "volume";
          goto LABEL_21;
        case 25:
          critsec_Leave(*(void **)(v4 + 32));
          uint64_t v10 = *(void *)(*(void *)(v4 + 16) + 40);
          unsigned int v11 = *v8;
          uint64_t v12 = "waitfactor";
LABEL_21:
          paramc_ParamSetUInt(v10, (uint64_t)v12, v11);
          uint64_t result = critsec_Enter(*(void **)(v4 + 32));
          goto LABEL_22;
        default:
          if (v9 == 33) {
            goto LABEL_27;
          }
LABEL_22:
          v8 += 8;
          if (a3 == ++v7) {
            break;
          }
          continue;
      }
      break;
    }
  }
  unsigned int v7 = -1;
LABEL_27:
  *unint64_t v5 = v7;
  return result;
}

uint64_t synth_bet5_loc_ProceedToNextPhonemeMarkerForDelivering(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = (_DWORD *)(result + 22552);
  unsigned int v4 = *(_DWORD *)(result + 22600);
  if (v4 <= 0xFFFFFFFD) {
    uint64_t v5 = v4 + 1;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5 >= a3)
  {
LABEL_8:
    LODWORD(v5) = -1;
  }
  else
  {
    uint64_t v7 = result;
    size_t v8 = (_DWORD *)(a2 + 32 * v5);
    while (*v8 != 33)
    {
      marker_logOutText(*(void *)(*(void *)(v7 + 16) + 32), (uint64_t)"SYNTH_BET5", 3, (uint64_t)"SYNTH-IN  ", (uint64_t)v8);
      v8[3] = *v3;
      v8[4] = 0;
      uint64_t result = marker_logOutText(*(void *)(*(void *)(v7 + 16) + 32), (uint64_t)"SYNTH_BET5", 3, (uint64_t)"SYNTH-OUT ", (uint64_t)v8);
      LODWORD(v5) = v5 + 1;
      v8 += 8;
      if (a3 == v5) {
        goto LABEL_8;
      }
    }
  }
  v3[12] = v5;
  return result;
}

uint64_t synth_bet5_loc_UpdatePhonemeMarkerDeliveringUnits(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = result + 22552;
  uint64_t v4 = *(unsigned int *)(result + 22600);
  if (v4 <= 0xFFFFFFFD && v4 < a3)
  {
    uint64_t v7 = (_DWORD *)(a2 + 32 * v4);
    if (*v7 == 33)
    {
      uint64_t v8 = result;
      marker_logOutText(*(void *)(*(void *)(result + 16) + 32), (uint64_t)"SYNTH_BET5", 3, (uint64_t)"SYNTH-IN  ", (uint64_t)v7);
      int v9 = *(_DWORD *)v3;
      uint64_t v10 = a2 + 32 * *(unsigned int *)(v3 + 48);
      int v11 = *(_DWORD *)(v3 + 36);
      *(_DWORD *)(v10 + 12) = *(_DWORD *)v3;
      *(_DWORD *)(v10 + 16) = v11;
      *(_DWORD *)(v3 + 36) = 0;
      *(_WORD *)(v3 + 40) = 0;
      *(_DWORD *)uint64_t v3 = v11 + v9;
      uint64_t v12 = *(void *)(*(void *)(v8 + 16) + 32);
      return marker_logOutText(v12, (uint64_t)"SYNTH_BET5", 3, (uint64_t)"SYNTH-OUT ", v10);
    }
  }
  return result;
}

uint64_t synth_bet5_loc_ReadDirectEndStream(void *a1, int a2, int a3)
{
  if (!a3)
  {
    uint64_t v9 = 0;
LABEL_6:
    if (!a2) {
      return v9;
    }
    uint64_t v11 = (*(uint64_t (**)(void, void, void))(a1[2687] + 96))(a1[2793], a1[2794], (4 * a2));
    if ((v11 & 0x80000000) != 0)
    {
      uint64_t v29 = v11;
      uint64_t v30 = *(void *)(a1[2] + 32);
    }
    else
    {
      uint64_t v16 = (*(uint64_t (**)(void, void, void))(a1[2687] + 96))(a1[2795], a1[2796], (4 * a2));
      if ((v16 & 0x80000000) != 0)
      {
        uint64_t v29 = v16;
        uint64_t v30 = *(void *)(a1[2] + 32);
      }
      else
      {
        uint64_t v17 = (*(uint64_t (**)(void, void, void))(a1[2687] + 96))(a1[2797], a1[2798], (4 * a2));
        if ((v17 & 0x80000000) == 0)
        {
          uint64_t v18 = (*(uint64_t (**)(void, void, void))(a1[2687] + 96))(a1[2799], a1[2800], (8 * a2));
          if ((v18 & 0x80000000) != 0)
          {
            uint64_t v31 = v18;
            uint64_t v32 = *(void *)(a1[2] + 32);
          }
          else
          {
            uint64_t v23 = (*(uint64_t (**)(void, void, void))(a1[2687] + 96))(a1[2801], a1[2802], (4 * a2));
            if ((v23 & 0x80000000) != 0)
            {
              uint64_t v31 = v23;
              uint64_t v32 = *(void *)(a1[2] + 32);
            }
            else
            {
              uint64_t v24 = (*(uint64_t (**)(void, void, void))(a1[2687] + 96))(a1[2803], a1[2804], (4 * a2));
              if ((v24 & 0x80000000) != 0)
              {
                uint64_t v31 = v24;
                uint64_t v32 = *(void *)(a1[2] + 32);
              }
              else
              {
                uint64_t v25 = (*(uint64_t (**)(void, void, void))(a1[2687] + 96))(a1[2805], a1[2806], (4 * a2));
                if ((v25 & 0x80000000) != 0)
                {
                  uint64_t v31 = v25;
                  uint64_t v32 = *(void *)(a1[2] + 32);
                }
                else
                {
                  uint64_t v26 = (*(uint64_t (**)(void, void, void))(a1[2687] + 96))(a1[2807], a1[2808], (4 * a2));
                  if ((v26 & 0x80000000) != 0)
                  {
                    uint64_t v31 = v26;
                    uint64_t v32 = *(void *)(a1[2] + 32);
                  }
                  else
                  {
                    uint64_t v27 = (*(uint64_t (**)(void, void, void))(a1[2687] + 96))(a1[2809], a1[2810], (4 * a2));
                    if ((v27 & 0x80000000) != 0)
                    {
                      uint64_t v31 = v27;
                      uint64_t v32 = *(void *)(a1[2] + 32);
                    }
                    else
                    {
                      uint64_t v28 = (*(uint64_t (**)(void, void, void))(a1[2687] + 96))(a1[2811], a1[2812], (4 * a2));
                      if ((v28 & 0x80000000) == 0)
                      {
                        uint64_t v9 = (*(uint64_t (**)(void, void, void))(a1[2687] + 96))(a1[2813], a1[2814], (4 * a2));
                        if ((v9 & 0x80000000) == 0) {
                          return v9;
                        }
                        uint64_t v10 = *(void *)(a1[2] + 32);
                        goto LABEL_4;
                      }
                      uint64_t v31 = v28;
                      uint64_t v32 = *(void *)(a1[2] + 32);
                    }
                  }
                }
              }
            }
          }
          log_OutPublic(v32, (uint64_t)"SYNTH_BET5", 59006, (uint64_t)"%s%s%s%x", v19, v20, v21, v22, "contentType");
          return v31;
        }
        uint64_t v29 = v17;
        uint64_t v30 = *(void *)(a1[2] + 32);
      }
    }
    log_OutPublic(v30, (uint64_t)"SYNTH_BET5", 59006, (uint64_t)"%s%s%s%x", v12, v13, v14, v15, "contentType");
    return v29;
  }
  uint64_t v9 = (*(uint64_t (**)(void, void, void))(a1[2687] + 96))(a1[2791], a1[2792], (32 * a3));
  if ((v9 & 0x80000000) == 0) {
    goto LABEL_6;
  }
  uint64_t v10 = *(void *)(a1[2] + 32);
LABEL_4:
  log_OutPublic(v10, (uint64_t)"SYNTH_BET5", 59006, (uint64_t)"%s%s%s%x", v5, v6, v7, v8, "contentType");
  return v9;
}

uint64_t synth_bet5_loc_WsolaOutputCB(uint64_t a1, uint64_t a2, int a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, void))(*(void *)(a1 + 21496) + 104))(*(void *)(a1 + 22520), *(void *)(a1 + 22528), a2, (2 * a3));
  *(_DWORD *)(a1 + 22588) += a3;
  return result;
}

void *FreePsolaData(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = (uint64_t **)result[2820];
  if (v2)
  {
    uint64_t v3 = *v2;
    if (*v2)
    {
      uint64_t v4 = 0;
      unsigned int v5 = 1;
      do
      {
        freePeriDesc(v1[2], v3);
        *(void *)(v1[2820] + 8 * v4) = 0;
        uint64_t v2 = (uint64_t **)v1[2820];
        uint64_t v4 = v5;
        uint64_t v3 = v2[v5++];
      }
      while (v3);
    }
    uint64_t result = heap_Free(*(void **)(v1[2] + 8), (uint64_t)v2);
    v1[2820] = 0;
  }
  *((_DWORD *)v1 + 5642) = 0;
  uint64_t v6 = (void *)v1[2822];
  if (v6)
  {
    uint64_t result = UNICORN__Psola_Deinitialise(v1[2], v6);
    v1[2822] = 0;
  }
  return result;
}

uint64_t UNICORN__writeToPeriVec(uint64_t a1, unsigned int a2, __int16 a3)
{
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (v6 <= a2)
  {
    uint64_t v7 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 8), 2 * (v6 + 150));
    if (!v7) {
      return 2229280778;
    }
    *(void *)(a1 + 8) = v7;
    *(_DWORD *)(a1 + 16) += 150;
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  uint64_t v8 = 0;
  *(_WORD *)(v7 + 2 * a2) = a3;
  return v8;
}

void *newPeriDesc(uint64_t a1)
{
  uint64_t v2 = (void *)heap_Alloc(*(void *)(a1 + 8), 80);
  uint64_t v3 = v2;
  if (v2)
  {
    cstdlib_memset(v2, 0, 0x50uLL);
    uint64_t v4 = heap_Alloc(*(void *)(a1 + 8), 300);
    v3[2] = v4;
    if (v4)
    {
      *((_DWORD *)v3 + 6) = 150;
      v3[1] = a1;
      uint64_t v5 = heap_Alloc(*(void *)(a1 + 8), 300);
      v3[5] = v5;
      if (v5)
      {
        *((_DWORD *)v3 + 12) = 150;
        v3[4] = a1;
        uint64_t v6 = heap_Alloc(*(void *)(a1 + 8), 300);
        v3[8] = v6;
        if (v6)
        {
          *((_DWORD *)v3 + 18) = 150;
          v3[7] = a1;
          return v3;
        }
      }
      uint64_t v7 = v3[2];
      if (v7) {
        heap_Free(*(void **)(a1 + 8), v7);
      }
    }
    uint64_t v8 = v3[5];
    if (v8) {
      heap_Free(*(void **)(a1 + 8), v8);
    }
    uint64_t v9 = v3[8];
    if (v9) {
      heap_Free(*(void **)(a1 + 8), v9);
    }
    return 0;
  }
  return v3;
}

void *freePeriDesc(uint64_t a1, uint64_t *a2)
{
  heap_Free(*(void **)(a1 + 8), a2[2]);
  heap_Free(*(void **)(a1 + 8), a2[5]);
  heap_Free(*(void **)(a1 + 8), a2[8]);
  uint64_t v4 = *(void **)(a1 + 8);

  return heap_Free(v4, (uint64_t)a2);
}

uint64_t UNICORN__Psola_GetDecodedUnitData(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5, int a6, int a7, unsigned int a8, _WORD *a9, int *a10, _DWORD *a11, _DWORD *a12)
{
  if (!a3) {
    return 0;
  }
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  v37[0] = 0;
  v37[1] = 0;
  uint64_t UnitData = Lookup_GetUnitData(*(void **)(a1 + 32), a4, (uint64_t)v37);
  if ((UnitData & 0x80000000) != 0) {
    return UnitData;
  }
  if (a6 + a5 + a7 <= a8)
  {
    int v20 = HIDWORD(v37[0]);
    if (HIDWORD(v37[0]) >= a5) {
      unsigned int v21 = a5;
    }
    else {
      unsigned int v21 = HIDWORD(v37[0]);
    }
    *a10 = v21;
    *a11 = a6;
    *a12 = a7;
    int v22 = *a10;
    int v23 = *a10 + a7 + *a11;
    long long v40 = 0;
    BOOL v25 = a4 == -1 && *(_DWORD *)(a1 + 100) != 0;
    uint64_t Segment = UNICORN__concat_getSegment(a1, a4, v20 - v22, v23, (uint64_t)&v38, v25);
    if ((Segment & 0x80000000) == 0)
    {
      uint64_t v26 = HIDWORD(v39);
      uint64_t v27 = (uint64_t)v40;
      if (HIDWORD(v39))
      {
        double v29 = *(double *)(a1 + 21336);
        uint64_t v30 = HIDWORD(v39);
        uint64_t v31 = v40;
        do
        {
          float v32 = v29 * *v31;
          *uint64_t v31 = v32;
          int v33 = -956301312;
          if (v32 < -32768.0 || (int v33 = 1191181824, v32 > 32767.0)) {
            *(_DWORD *)uint64_t v31 = v33;
          }
          ++v31;
          --v30;
        }
        while (v30);
        long long v34 = (float *)v27;
        do
        {
          float v35 = *v34++;
          *a9++ = (int)v35;
          --v26;
        }
        while (v26);
      }
      heap_Free(*(void **)(*(void *)a1 + 8), v27);
    }
  }
  else
  {
    *a10 = 0;
    *a11 = 0;
    uint64_t Segment = 2229280777;
    *a12 = 0;
  }
  return Segment;
}

uint64_t UNICORN__concat_getSegment(uint64_t a1, unsigned int a2, unsigned int a3, int a4, uint64_t a5, int a6)
{
  unsigned int v6 = a4;
  *(_DWORD *)(a5 + 12) = a4;
  uint64_t v9 = (int *)(a5 + 12);
  *(_DWORD *)(a5 + 8) = a4;
  if (a4 <= 0)
  {
    *uint64_t v9 = 0;
    UNICORN__log_wsola_Diag(*(void *)a1, 1, (uint64_t)"WARNING: Segment in unit %d has a duration of %d\n");
    return 2229280775;
  }
  uint64_t v11 = *(uint64_t **)(*(void *)a1 + 8);
  if (!a6)
  {
    uint64_t v16 = heap_Calloc(v11, a4, 2);
    if (!v16)
    {
      uint64_t v14 = 2229280778;
      goto LABEL_32;
    }
    int v22 = (__int16 *)v16;
    if (a2 <= 0xFFFFFFFD)
    {
      Lookup_Init(*(void *)(a1 + 32), a3, *v9);
      Lookup_Decode(*(void *)(a1 + 32), v9, (uint64_t)v22);
      unsigned int v6 = *v9;
    }
    if (a2 == -2)
    {
      unsigned int v25 = *(_DWORD *)(a1 + 96);
      if (v25 > a3)
      {
        if (*v9 + a3 > v25) {
          unsigned int v6 = v25 - a3;
        }
        uint64_t v24 = (void *)(a1 + 88);
        goto LABEL_22;
      }
      uint64_t v30 = *(void *)a1;
      uint64_t v31 = 59012;
    }
    else
    {
      if (a2 != -1)
      {
LABEL_23:
        uint64_t v26 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a5 + 16), 4 * *(unsigned int *)(a5 + 12));
        *(void *)(a5 + 16) = v26;
        if (v26)
        {
          uint64_t v27 = *v9;
          if (v27)
          {
            for (unint64_t i = 0; i != v27; ++i)
            {
              float v29 = 0.0;
              if (i < v6) {
                float v29 = (float)v22[i];
              }
              *(float *)(v26 + 4 * i) = v29;
            }
          }
          heap_Free(*(void **)(*(void *)a1 + 8), (uint64_t)v22);
          return 0;
        }
        uint64_t v14 = 2229280778;
        heap_Free(*(void **)(*(void *)a1 + 8), (uint64_t)v22);
LABEL_32:
        UNICORN__log_wsola_Error(*(void *)a1, 59000, 0, v17, v18, v19, v20, v21);
        return v14;
      }
      unsigned int v23 = *(_DWORD *)(a1 + 80);
      if (v23 > a3)
      {
        if (*v9 + a3 > v23) {
          unsigned int v6 = v23 - a3;
        }
        uint64_t v24 = (void *)(a1 + 72);
LABEL_22:
        cstdlib_memcpy(v22, (const void *)(*v24 + 2 * a3), 2 * v6);
        goto LABEL_23;
      }
      uint64_t v30 = *(void *)a1;
      uint64_t v31 = 59011;
    }
    UNICORN__log_wsola_Error(v30, v31, 0, v17, v18, v19, v20, v21);
    return 2229280783;
  }
  uint64_t v12 = (void *)heap_Realloc(v11, *(void *)(a5 + 16), 4 * a4);
  *(void *)(a5 + 16) = v12;
  if (v12)
  {
    uint64_t v13 = *v9;
    if (v13) {
      bzero(v12, 4 * v13);
    }
    return 0;
  }
  uint64_t v14 = 2229280778;
  UNICORN__log_wsola_Diag(*(void *)a1, 1, (uint64_t)"ERROR: Out of memory\n");
  heap_Free(*(void **)(*(void *)a1 + 8), 0);
  return v14;
}

uint64_t UNICORN__Psola_SynthSilence(uint64_t *a1, int *a2, int a3, int *a4)
{
  Psola_FlushOlaBufPart_0(a1, a2, *a4);
  int v8 = *a4 + a3;
  *a4 = v8;
  if (*a2 <= v8) {
    Psola_AddToOlaBufAux_0(a1, a2, (uint64_t)v10, 0, 0, v8);
  }
  return 0;
}

void Psola_FlushOlaBufPart_0(uint64_t *a1, _DWORD *a2, int a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  int v3 = a3 - *a2;
  if (v3 >= 1)
  {
    int v6 = a2[1];
    int v7 = a2[2];
    if (v3 >= v7) {
      signed int v8 = a2[2];
    }
    else {
      signed int v8 = v3;
    }
    if (v8 >= 12000 - v6) {
      signed int v9 = 12000 - v6;
    }
    else {
      signed int v9 = v8;
    }
    if (v3 >= v7) {
      signed int v10 = v7 - v9;
    }
    else {
      signed int v10 = v3 - v9;
    }
    if (v9 >= 1)
    {
      UNICORN__Wsola__write_audioX(a1, (uint64_t)(a2 + 3), v6, v9);
      bzero((char *)a2 + 2 * a2[1] + 12, 2 * v9);
    }
    if (v10 >= 1)
    {
      UNICORN__Wsola__write_audioX(a1, (uint64_t)(a2 + 3), 0, v10);
      bzero(a2 + 3, 2 * v10);
    }
    int v11 = v3 - v9 - v10;
    if (v11 >= 1)
    {
      uint64_t v16 = 0;
      memset(v15, 0, sizeof(v15));
      do
      {
        if (v11 >= 100) {
          unsigned int v12 = 100;
        }
        else {
          unsigned int v12 = v11;
        }
        UNICORN__Wsola__write_audioX(a1, (uint64_t)v15, 0, v12);
        BOOL v13 = __OFSUB__(v11, v12);
        v11 -= v12;
      }
      while (!((v11 < 0) ^ v13 | (v11 == 0)));
    }
    int v14 = a2[1] + v3;
    *a2 += v3;
    a2[1] = v14 % 12000;
    a2[2] -= v10 + v9;
  }
}

uint64_t UNICORN__Psola_Initialise(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v6 = 2229280778;
  uint64_t v7 = heap_Calloc(*(void **)(a2 + 8), 1, 160);
  *a1 = v7;
  if (v7)
  {
    uint64_t v8 = v7;
    *(unsigned char *)(v7 + 136) = 1;
    uint64_t v9 = heap_Alloc(*(void *)(a2 + 8), 24012);
    *(void *)(v8 + 16) = v9;
    if (v9)
    {
      uint64_t v10 = heap_Alloc(*(void *)(a2 + 8), 48000);
      *(void *)(v8 + 24) = v10;
      if (v10)
      {
        uint64_t v11 = heap_Calloc(*(void **)(a2 + 8), 1, 48);
        *(void *)(v8 + 32) = v11;
        if (v11)
        {
          *(void *)(v11 + 8) = 961;
          uint64_t v12 = heap_Alloc(*(void *)(a2 + 8), 1922);
          BOOL v13 = *(uint64_t **)(v8 + 32);
          uint64_t *v13 = v12;
          if (v12)
          {
            v13[3] = 961;
            uint64_t v14 = heap_Alloc(*(void *)(a2 + 8), 1922);
            uint64_t v15 = *(void *)(v8 + 32);
            *(void *)(v15 + 16) = v14;
            if (v14)
            {
              *(void *)(v15 + 40) = 961;
              uint64_t v16 = heap_Alloc(*(void *)(a2 + 8), 1922);
              *(void *)(*(void *)(v8 + 32) + 32) = v16;
              if (v16)
              {
                uint64_t v17 = newModPeriDesc(a2);
                *(void *)(v8 + 88) = v17;
                if (v17)
                {
                  uint64_t v18 = newModPeriDesc(a2);
                  *(void *)(v8 + 96) = v18;
                  if (v18)
                  {
                    bzero(*(void **)(v8 + 16), 0x5DCCuLL);
                    *(void *)(v8 + 112) = 0;
                    uint64_t v19 = *(void *)(v8 + 96);
                    *(_WORD *)uint64_t v19 = 0;
                    *(_DWORD *)(v19 + 2) = 0;
                    uint64_t v20 = *(void *)(v8 + 88);
                    *(_WORD *)uint64_t v20 = 0;
                    *(_DWORD *)(v20 + 2) = 0;
                    uint64_t v21 = Psola_SetUpCrossFading_0(a3, 100, 100, (unsigned __int16 *)v19, (unsigned __int16 *)v20, (_DWORD *)(v8 + 8), (int *)(v8 + 12));
                    if ((v21 & 0x80000000) != 0)
                    {
                      return v21;
                    }
                    else
                    {
                      uint64_t v6 = 0;
                      *(void *)uint64_t v8 = 0x100000000;
                      *(_DWORD *)(v8 + 120) = 0;
                      *(_DWORD *)(v8 + 124) = a3;
                      *(_DWORD *)(v8 + 64) = 0;
                      *(int32x2_t *)(v8 + 140) = vdup_n_s32(0x42200000u);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v6;
}

void *newModPeriDesc(uint64_t a1)
{
  uint64_t v2 = (void *)heap_Alloc(*(void *)(a1 + 8), 80);
  int v3 = v2;
  if (v2)
  {
    cstdlib_memset(v2, 0, 0x50uLL);
    uint64_t v4 = heap_Alloc(*(void *)(a1 + 8), 300);
    v3[2] = v4;
    if (v4)
    {
      *((_DWORD *)v3 + 6) = 150;
      v3[1] = a1;
      uint64_t v5 = heap_Alloc(*(void *)(a1 + 8), 300);
      v3[5] = v5;
      if (v5)
      {
        *((_DWORD *)v3 + 12) = 150;
        v3[4] = a1;
        uint64_t v6 = heap_Alloc(*(void *)(a1 + 8), 300);
        v3[8] = v6;
        if (v6)
        {
          *((_DWORD *)v3 + 18) = 150;
          v3[7] = a1;
          return v3;
        }
      }
      uint64_t v7 = v3[2];
      if (v7) {
        heap_Free(*(void **)(a1 + 8), v7);
      }
    }
    uint64_t v8 = v3[5];
    if (v8) {
      heap_Free(*(void **)(a1 + 8), v8);
    }
    uint64_t v9 = v3[8];
    if (v9) {
      heap_Free(*(void **)(a1 + 8), v9);
    }
    return 0;
  }
  return v3;
}

uint64_t Psola_SetUpCrossFading_0(int a1, int a2, int a3, unsigned __int16 *a4, unsigned __int16 *a5, _DWORD *a6, int *a7)
{
  int v11 = a2 * a1;
  uint64_t v12 = 274877907 * a2 * a1;
  unint64_t v13 = (unint64_t)v12 >> 63;
  uint64_t v14 = v12 >> 38;
  int v15 = a3 * a1 / 1000;
  uint64_t v16 = a4[1] + *a4;
  *a7 = 0;
  if (a4[2])
  {
    unint64_t v43 = (unint64_t)v12 >> 63;
    int v45 = a2 * a1;
    uint64_t v17 = 0;
    int v18 = 0;
    do
    {
      if (v17 >= a5[1] >> 1 || v18 >= v15) {
        break;
      }
      uint64_t v20 = *((void *)a5 + 8);
      int v21 = *(__int16 *)(v20 + 2 * (v17 + *a5));
      UNICORN__writeToPeriVec((uint64_t)(a4 + 28), v16 + v17, *(_WORD *)(v20 + 2 * (v17 + *a5)));
      int v18 = *a7 + v21;
      *a7 = v18;
      ++v17;
    }
    while (v17 < a4[2]);
    int v11 = v45;
    LODWORD(v13) = v43;
  }
  else
  {
    LOWORD(v17) = 0;
  }
  int v46 = v14 + v13;
  a4[2] = v17;
  *a6 = 0;
  LODWORD(v22) = *a5;
  if (*a5)
  {
    int v23 = 0;
    if (a4[1] && v11 >= 1000)
    {
      uint64_t v24 = 2 * v16 - 2;
      int v25 = -1;
      unint64_t v26 = 1;
      do
      {
        int v27 = v25;
        int v28 = *(__int16 *)(*((void *)a4 + 8) + v24);
        UNICORN__writeToPeriVec((uint64_t)(a5 + 28), v22 + v25, *(_WORD *)(*((void *)a4 + 8) + v24));
        int v23 = *a6 + v28;
        *a6 = v23;
        unint64_t v22 = *a5;
        if (v26 >= v22) {
          break;
        }
        int v25 = v27 - 1;
        BOOL v29 = v26++ >= ((unint64_t)a4[1] + 1) >> 1;
        v24 -= 2;
      }
      while (!v29 && v23 < v46);
      int v31 = -v27;
    }
    else
    {
      int v31 = 0;
    }
    unsigned int v32 = v22;
  }
  else
  {
    int v23 = 0;
    int v31 = 0;
    unsigned int v32 = 0;
  }
  unsigned int v33 = v32 - v31;
  if ((int)(v32 - v31) >= 1)
  {
    uint64_t v34 = a5[1];
    uint64_t v35 = a5[2];
    if (v33 < v32 + v34 + v35)
    {
      __int16 v42 = v32 - v31;
      int v44 = v15;
      uint64_t v36 = 0;
      uint64_t v37 = 2 * -v31 + 2 * v32;
      uint64_t v38 = v35 + v34 - -v31;
      do
      {
        UNICORN__writeToPeriVec((uint64_t)(a5 + 4), v36, *(_WORD *)(*((void *)a5 + 2) + v37 + 2 * v36));
        UNICORN__writeToPeriVec((uint64_t)(a5 + 16), v36, *(_WORD *)(*((void *)a5 + 5) + v37 + 2 * v36));
        UNICORN__writeToPeriVec((uint64_t)(a5 + 28), v36, *(_WORD *)(*((void *)a5 + 8) + v37 + 2 * v36));
        ++v36;
      }
      while (v38 != v36);
      LOWORD(v22) = *a5;
      int v23 = *a6;
      LOWORD(v33) = v42;
      int v15 = v44;
    }
    *a5 = v22 - v33;
  }
  int v39 = v46;
  if (v23 < v46) {
    int v39 = v23;
  }
  *a6 = v39;
  int v40 = *a7;
  if (*a7 >= v15) {
    int v40 = v15;
  }
  *a7 = v40;
  if (!((*a6 + v40 < 0) ^ __OFADD__(*a6, v40) | (*a6 + v40 == 0)) || !a4[1]) {
    return 0;
  }
  if (a5[1]) {
    return 2229280783;
  }
  return 0;
}

uint64_t UNICORN__Psola_Synthesis(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = a1;
  uint64_t v4 = a1 + 21304;
  uint64_t v5 = *(void *)(a2 + 128);
  uint64_t v6 = *(int *)(a2 + 120);
  uint64_t v7 = *(void **)(a1 + 8);
  unsigned int v8 = *(_DWORD *)(v5 + 40 * (int)v6);
  if (v6) {
    int v9 = *(_DWORD *)(v5 + 40 * (int)(v6 - *(unsigned __int8 *)(a2 + 136)));
  }
  else {
    int v9 = -1;
  }
  uint64_t v10 = v5 + 40 * (int)v6;
  float v11 = (float)*(unsigned int *)(v3 + 64) / 1000.0;
  *(_DWORD *)uint64_t v4 = v8;
  *(int32x2_t *)(v3 + 21312) = vcvt_s32_f32(vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)(v10 + 4)), v11));
  *(_DWORD *)(v4 + 16) = 0;
  *(unsigned char *)(v4 + 20) = 34;
  *(_DWORD *)(v4 + 24) = v8 == -1;
  MsgName = UNICORN__mfs_GetMsgName(v7, v8);
  unint64_t v13 = MsgName;
  double v14 = *(double *)(v3 + 21344);
  if (v14 != 0.0)
  {
    int v15 = (int)((v14 * 0.5 + 100000.0) / v14);
    if (v15)
    {
      if (v15 != 1000)
      {
        uint64_t v16 = v5 + 40 * (int)v6;
        uint64_t v17 = 274877907 * (*(_DWORD *)(v16 + 20) * v15 + 500);
        *(_DWORD *)(v16 + 20) = (v17 >> 38) + ((unint64_t)v17 >> 63);
      }
    }
  }
  int v19 = *(_DWORD *)(v10 + 4);
  int v18 = *(_DWORD *)(v10 + 8);
  uint64_t v20 = *(void *)(v2 + 152);
  uint64_t v21 = *(void *)(v20 + 8 * v6);
  *(void *)(v2 + 80) = v21;
  if (v6) {
    uint64_t v22 = *(void *)(v20 + 8 * ((int)v6 - 1));
  }
  else {
    uint64_t v22 = 0;
  }
  *(void *)(v2 + 72) = v22;
  if (v8 == -1)
  {
    int v168 = v6;
    uint64_t v170 = v5;
    int v172 = v18;
    int v166 = v19;
    long long v167 = MsgName;
    unsigned int v173 = v9;
    uint64_t v174 = v2;
    uint64_t v36 = *(void *)(v2 + 96);
    *(_DWORD *)uint64_t v36 = 0;
    *(_WORD *)(v36 + 4) = 0;
    goto LABEL_16;
  }
  __int16 v23 = *(_WORD *)(v21 + 4);
  if (!v23)
  {
    ++*(unsigned char *)(v2 + 136);
LABEL_50:
    ++*(_DWORD *)(v2 + 120);
    uint64_t v51 = *(uint64_t **)(v3 + 32);
    return Lookup_DeInit(v51);
  }
  unsigned int v173 = v9;
  *(unsigned char *)(v2 + 136) = 1;
  uint64_t v24 = v3;
  double v25 = *(double *)(v3 + 21352) * 0.5 + 100.0;
  unint64_t v26 = (_DWORD *)(v5 + 40 * (int)v6);
  int v27 = v26[3] * (int)v25;
  int v28 = (v27 + 50) / 100;
  int v29 = v26[4] * (int)v25;
  int v30 = (v29 + 50) / 100;
  v26[3] = v28;
  v26[4] = v30;
  uint64_t v31 = v26[5];
  uint64_t v32 = *(unsigned __int16 *)(v21 + 2);
  unsigned __int16 v33 = v32 + v23;
  unsigned __int16 v34 = v32 + v23 - 1;
  if (v32 <= v34)
  {
    int v35 = 0;
    int v40 = *(unsigned __int16 *)(v21 + 2);
    do
      v35 += *(__int16 *)(*(void *)(v21 + 40) + 2 * (unsigned __int16)v40++);
    while ((unsigned __int16)v40 <= v34);
  }
  else
  {
    int v35 = 0;
  }
  int v41 = *(_DWORD *)(v2 + 124);
  if ((v31 & 0x80000000) != 0)
  {
    if (v41 >= 0) {
      int v42 = *(_DWORD *)(v2 + 124);
    }
    else {
      int v42 = v41 + 1;
    }
    int v43 = (1000 * v35 + (v42 >> 1)) / v41;
    if (v43 >= 0) {
      int v44 = (1000 * v35 + (v42 >> 1)) / v41;
    }
    else {
      int v44 = v43 + 1;
    }
    uint64_t v31 = ((-1000 * (int)v31 + (v44 >> 1)) / v43);
  }
  int v195 = v35;
  if (v31) {
    int v195 = ((int)v31 * v35 + 500) / 1000;
  }
  uint64_t v174 = v2;
  int v45 = *(_WORD **)(v2 + 96);
  uint64_t result = 2229280786;
  if (v27 >= 50 && v29 < 50 || v27 <= 49 && v29 > 49) {
    return result;
  }
  unsigned __int16 v155 = v33;
  int v168 = v6;
  uint64_t v170 = v5;
  int v172 = v18;
  int v166 = v19;
  long long v167 = v13;
  *int v45 = 0;
  int v188 = (v27 + 50) / 100;
  int v157 = v41;
  if (v32)
  {
    int v185 = (v29 + 50) / 100;
    unsigned int v190 = v31;
    for (uint64_t i = 0; i != v32; ++i)
    {
      UNICORN__writeToPeriVec((uint64_t)(v45 + 4), i, i);
      UNICORN__writeToPeriVec((uint64_t)(v45 + 16), i, 0);
      UNICORN__writeToPeriVec((uint64_t)(v45 + 28), i, *(_WORD *)(*(void *)(v21 + 40) + 2 * i));
      ++*v45;
    }
    int v28 = v188;
    uint64_t v31 = v190;
    int v30 = v185;
  }
  else
  {
    LODWORD(i) = 0;
  }
  v45[1] = 0;
  if (v32 <= v34)
  {
    int v73 = 0;
    unsigned int v74 = 0;
    unsigned int v75 = 0;
    int v164 = v30 - v28;
    if (v35 >= 0) {
      int v76 = v35;
    }
    else {
      int v76 = v35 + 1;
    }
    int v154 = v76 >> 1;
    uint64_t v181 = (uint64_t)(v45 + 28);
    uint64_t v183 = (uint64_t)(v45 + 4);
    uint64_t v179 = (uint64_t)(v45 + 16);
    uint64_t v156 = v24;
    uint64_t v193 = v21;
    unsigned __int16 v177 = v34;
    unint64_t v175 = v45;
    while (1)
    {
      uint64_t v77 = (unsigned __int16)v32;
      uint64_t v78 = *(unsigned __int16 *)(*(void *)(v21 + 40) + 2 * (unsigned __int16)v32);
      if (v31) {
        v75 += ((int)v31 * (int)v78 + 500) / 1000;
      }
      else {
        unsigned int v75 = v74 + v78;
      }
      int v79 = i <= 0x2710 ? 10000 : i;
      int v191 = v79;
      BOOL v80 = (unsigned __int16)v32 == v34 && v74 == 0;
      BOOL v81 = v80;
      BOOL v82 = v74 + (v78 >> 1) > v75 && !v81;
      int v158 = v73;
      if (!v82) {
        break;
      }
LABEL_130:
      int v73 = v158 + v78;
      LOWORD(v32) = v77 + 1;
      uint64_t v24 = v156;
      uint64_t v21 = v193;
      if ((unsigned __int16)(v77 + 1) > v34) {
        goto LABEL_69;
      }
    }
    __int16 v83 = 0;
    unsigned int v186 = v78 >> 1;
    int v160 = v154 + v73 * v164;
    while (1)
    {
      int v84 = v28;
      if (v31)
      {
        uint64_t v85 = v193;
        if (!v195) {
          goto LABEL_103;
        }
        int v86 = (int)(v195 / 2 + v74 * v164) / v195;
      }
      else
      {
        uint64_t v85 = v193;
        if (!v35) {
          goto LABEL_103;
        }
        int v86 = v160 / v35;
      }
      int v84 = v86 + v28;
LABEL_103:
      unsigned int v87 = v78;
      if (*(_WORD *)(*(void *)(v85 + 64) + 2 * v77) == 1)
      {
        if (v84 < 1)
        {
          unsigned int v87 = v78;
          if ((v84 & 0x80000000) == 0) {
            goto LABEL_108;
          }
          int v84 = -v84;
          int v88 = v84 >> 1;
          unsigned int v89 = v157;
        }
        else
        {
          int v88 = 1000 * *(__int16 *)(*(void *)(v85 + 40) + 2 * v77);
          unsigned int v89 = v84 >> 1;
        }
        unsigned int v87 = (int)(v88 + v89) / v84;
      }
LABEL_108:
      if (v191 == i) {
        return 2229280777;
      }
      if (v87 <= 0x10) {
        unsigned int v90 = 16;
      }
      else {
        unsigned int v90 = v87;
      }
      if (v90 >= 0x3C1) {
        int v91 = 961;
      }
      else {
        int v91 = v90;
      }
      uint64_t v92 = v85;
      uint64_t v93 = v31;
      uint64_t v94 = v77;
      uint64_t v95 = v78;
      UNICORN__writeToPeriVec(v183, i, v77);
      UNICORN__writeToPeriVec(v181, i, v91);
      if (*(_WORD *)(*(void *)(v92 + 64) + 2 * v94)) {
        __int16 v96 = 0;
      }
      else {
        __int16 v96 = v83;
      }
      UNICORN__writeToPeriVec(v179, i, v96);
      uint64_t v78 = v95;
      uint64_t v77 = v94;
      uint64_t v31 = v93;
      int v45 = v175;
      unsigned __int16 v34 = v177;
      int v28 = v188;
      __int16 v83 = 1 - v83;
      v74 += v91;
      if (!v31) {
        unsigned int v75 = v74;
      }
      LODWORD(i) = i + 1;
      ++v175[1];
      BOOL v98 = v77 == v177 && v74 == 0;
      if (v74 + v186 > v75 && !v98) {
        goto LABEL_130;
      }
    }
  }
LABEL_69:
  unsigned __int16 v69 = *(_WORD *)(v21 + 4) + *(_WORD *)(v21 + 2) + *(_WORD *)(v21 + 6);
  v45[2] = 0;
  uint64_t v3 = v24;
  if (v155 >= v69)
  {
LABEL_16:
    uint64_t v2 = v174;
    int v37 = *(_DWORD *)(v174 + 124);
    int v38 = *(_DWORD *)(v170 + 40 * v168 + 24);
    if (v168 < 1) {
      int v39 = 100;
    }
    else {
      int v39 = *(_DWORD *)(v170 + 40 * (v168 - 1) + 28);
    }
    uint64_t v197 = 0;
    uint64_t result = Psola_SetUpCrossFading_0(v37, v38, v39, *(unsigned __int16 **)(v174 + 88), *(unsigned __int16 **)(v174 + 96), (_DWORD *)&v197 + 1, (int *)&v197);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    if (!v168) {
      goto LABEL_49;
    }
    if (v173 == -1)
    {
      unsigned int v48 = *(_DWORD *)(v174 + 124) * *(unsigned __int16 *)(v174 + 106) / 0x3E8;
      UNICORN__log_wsola_Diag(*(void *)v3, 3, (uint64_t)"Parametric silence for s32uint64_t i = %d\n");
    }
    else
    {
      UNICORN__log_wsola_Diag(*(void *)v3, 3, (uint64_t)"Non silence unit %d for s32uint64_t i = %d\n");
      if (**(_WORD **)(v174 + 72)) {
        unsigned int v48 = -1;
      }
      else {
        unsigned int v48 = (int)((double)(*(_DWORD *)(v174 + 124) * *(unsigned __int16 *)(v174 + 106)) / 1000.0);
      }
    }
    UNICORN__log_wsola_Diag(*(void *)v3, 3, (uint64_t)"SynthSilence debugging, s32i=%d, s32SilLen %d\n");
    UNICORN__log_wsola_Diag(*(void *)v3, 3, (uint64_t)"SynthSilence - next unit is going to be %d\n");
    if ((v48 & 0x80000000) == 0)
    {
      UNICORN__Psola_SynthSilence((uint64_t *)v3, *(int **)(v174 + 16), (int)(*(_DWORD *)(v170 + 40 * v168 - 20) * v48 + 500) / 1000, (int *)v174);
LABEL_49:
      UNICORN__log_wsola_Diag(*(void *)v3, 3, (uint64_t)"BANANA: Synthesis of unit %d has just been completed\n\n");
      *(_WORD *)(v2 + 104) = v166;
      *(_WORD *)(v2 + 106) = v172;
      *(_DWORD *)(v2 + 108) = 0;
      *(void *)(v2 + 112) = v167;
      *(int8x16_t *)(v2 + 88) = vextq_s8(*(int8x16_t *)(v2 + 88), *(int8x16_t *)(v2 + 88), 8uLL);
      int v50 = v197;
      *(_DWORD *)(v2 + 8) = HIDWORD(v197);
      *(_DWORD *)(v2 + 12) = v50;
      *(_DWORD *)(v2 + 4) = 3 - *(_DWORD *)(v2 + 4);
      goto LABEL_50;
    }
    uint64_t v52 = *(unsigned __int16 **)(v174 + 72);
    uint64_t v53 = *(_WORD **)(v174 + 24);
    v199[0] = 0;
    int v198 = 0;
    uint64_t v54 = (__int16 *)*((void *)v52 + 2);
    int v55 = *v54;
    if (v55 <= 0) {
      unsigned int v56 = -v55;
    }
    else {
      unsigned int v56 = 0;
    }
    uint64_t v57 = (unsigned __int16)(v52[1] + v52[2] + v52[3] - 1);
    int v58 = *(__int16 *)(*((void *)v52 + 5) + 2 * v57) + v54[v57];
    int v59 = *v52;
    int v60 = (v58 - v59) & ~((v58 - v59) >> 31);
    uint64_t v61 = *(unsigned int *)(v3 + 48);
    if (v173 == -1 || !v61)
    {
      if ((v61 & 0x80000000) == 0) {
        goto LABEL_134;
      }
    }
    else
    {
      uint64_t v62 = 0;
      uint64_t v63 = *(void *)(v3 + 40);
      uint64_t v64 = (unsigned int *)(v63 + 16);
      while (1)
      {
        unsigned int v65 = *v64;
        v64 += 6;
        if (v65 > v173) {
          break;
        }
        if (v61 == ++v62)
        {
          LODWORD(v62) = *(_DWORD *)(v3 + 48);
          break;
        }
      }
      if ((int)v61 >= (int)v62 && v3 && (v62 & 0x80000000) == 0)
      {
        if (v62)
        {
          uint64_t v66 = v63 + 24 * (v62 - 1);
          unint64_t v67 = (void *)(v66 + 8);
          int v68 = *(_DWORD *)(v66 + 16);
LABEL_135:
          *(void *)(v3 + 32) = *v67;
          *(_DWORD *)(v3 + 52) = v68;
          int v59 = *v52;
          goto LABEL_137;
        }
LABEL_134:
        int v68 = 0;
        unint64_t v67 = (void *)(v3 + 24);
        goto LABEL_135;
      }
    }
    int v68 = *(_DWORD *)(v3 + 52);
LABEL_137:
    uint64_t result = UNICORN__Psola_GetDecodedUnitData(v3, v49, v174 + 104, v173 - v68, v56, v59, v60, 0x5DC0u, v53, (int *)v199 + 1, &v198, v199);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t result = 2229280777;
    int v99 = HIDWORD(v199[0]);
    if (HIDWORD(v199[0]) + **((__int16 **)v52 + 2) < 0
      || HIDWORD(v199[0]) + v58 > v198 + HIDWORD(v199[0]) + LODWORD(v199[0]))
    {
      return result;
    }
    UNICORN__log_wsola_Diag(*(void *)v3, 3, (uint64_t)"About to call synthesis for unitID %d\n");
    __int16 v100 = *(unsigned __int16 **)(v174 + 88);
    uint64_t v101 = *v100;
    int v102 = v100[1];
    uint64_t v103 = *((void *)v100 + 8);
    int v104 = 0;
    if (*v100)
    {
      int v105 = *v100;
      int v106 = (__int16 *)*((void *)v100 + 8);
      do
      {
        int v107 = *v106++;
        v104 += v107;
        --v105;
      }
      while (v105);
    }
    int v108 = v102 + v101;
    int v109 = *(_DWORD *)(v174 + 8);
    int v110 = *(_DWORD *)(v174 + 12);
    int v111 = 0;
    if (v100[1])
    {
      int v112 = (__int16 *)(v103 + 2 * v101);
      do
      {
        int v113 = *v112++;
        v111 += v113;
        --v102;
      }
      while (v102);
    }
    uint64_t v114 = v108 + v100[2];
    int v115 = HIDWORD(v197);
    int v116 = *(_DWORD *)v174;
    int v182 = v110 + v109;
    if ((v182 < 0) ^ __OFADD__(v110, v109) | (v182 == 0))
    {
      unsigned int v117 = *(unsigned __int16 *)(v103 + 2 * *v100);
      int v182 = (int)((v117 + (v117 >> 15)) << 16) >> 17;
      int v178 = *(_DWORD *)v174;
    }
    else
    {
      int v178 = v116 - v109;
    }
    int v180 = v197 + HIDWORD(v197);
    if (((int)v197 + HIDWORD(v197) < 0) ^ __OFADD__(v197, HIDWORD(v197)) | (v197 + HIDWORD(v197) == 0))
    {
      unsigned int v118 = *(unsigned __int16 *)(v103 + 2 * (v108 - 1));
      int v115 = (__int16)(v118 + (v118 >> 15)) >> 1;
      int v180 = v115;
    }
    int v119 = v116 + v111;
    if (v114)
    {
      int v176 = v99;
      uint64_t v120 = 0;
      int v121 = 0;
      uint64_t v122 = *(void *)(v174 + 24);
      uint64_t v123 = *(void *)(v174 + 32);
      uint64_t v169 = (int *)(v174 + 64);
      int8x16_t v184 = *(int **)(v174 + 16);
      int v163 = v119 - v115;
      uint64_t v189 = *(void *)(v174 + 72);
      int v196 = v116 - v104;
      uint64_t v159 = (v114 - 1);
      float32x4_t v161 = (uint64_t *)(v123 + 16);
      uint64_t v162 = (v114 + 1);
      uint64_t v187 = *(unsigned __int16 **)(v174 + 88);
      uint64_t v171 = v114;
      uint64_t v165 = v122;
      do
      {
        uint64_t v194 = v120;
        int v192 = v121;
        if (v120)
        {
          if (v120 == v114)
          {
            uint64_t v124 = *(__int16 *)(*((void *)v100 + 2) + 2 * v159);
            LODWORD(v125) = *(__int16 *)(*(void *)(v189 + 40) + 2 * v124);
            uint64_t result = Psola_CopyDataPart_0(*(uint64_t **)(*(void *)v3 + 8), v122, v176 + *(__int16 *)(*(void *)(v189 + 16) + 2 * v124), v125, (uint64_t *)v123);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            int8x16_t v126 = (uint64_t *)v3;
            LODWORD(v127) = 0;
            int v128 = 0;
            uint64_t v129 = (__int16 *)(*((void *)v100 + 8) + 2 * v159);
            uint64_t v130 = v167;
            int v131 = v166;
            int v132 = v172;
          }
          else
          {
            int v134 = *(unsigned __int16 *)(*((void *)v100 + 5) + 2 * v120);
            uint64_t v135 = *(__int16 *)(*((void *)v100 + 2) + 2 * v120);
            uint64_t v136 = v135 - 1;
            uint64_t v137 = *(void *)(v189 + 40);
            uint64_t v138 = *(void *)(v189 + 16);
            if (v134)
            {
              unint64_t v125 = *(__int16 *)(v137 + 2 * v135);
              unint64_t v127 = *(__int16 *)(v137 + 2 * v136);
              int v139 = *(__int16 *)(v138 + 2 * v135);
              uint64_t v140 = (uint64_t *)v3;
              uint64_t result = Psola_ReallocIfNeeded_0(*(uint64_t **)(*(void *)v3 + 8), (uint64_t *)v123, v125);
              if ((int)v125 >= 1 && (result & 0x80000000) == 0)
              {
                uint64_t v141 = (__int16 *)(v122 + 2 * (v176 + v139));
                uint64_t v142 = (_WORD *)(*(void *)v123 + 2 * v125 - 2);
                int v143 = v125;
                do
                {
                  __int16 v144 = *v141++;
                  *v142-- = v144;
                  --v143;
                }
                while (v143);
              }
              int v131 = v166;
              if ((result & 0x80000000) != 0) {
                return result;
              }
              int v145 = *(__int16 *)(*(void *)(v189 + 16) + 2 * v136);
              uint64_t result = Psola_ReallocIfNeeded_0(*(uint64_t **)(*(void *)v3 + 8), v161, v127);
              if ((int)v127 >= 1 && (result & 0x80000000) == 0)
              {
                uint64_t v146 = (__int16 *)(v122 + 2 * (v176 + v145));
                float v147 = (_WORD *)(*v161 + 2 * v127 - 2);
                int v148 = v127;
                do
                {
                  __int16 v149 = *v146++;
                  *v147-- = v149;
                  --v148;
                }
                while (v148);
              }
              uint64_t v130 = v167;
            }
            else
            {
              LODWORD(v125) = *(__int16 *)(v137 + 2 * v136);
              LODWORD(v127) = *(__int16 *)(v137 + 2 * v135);
              uint64_t result = Psola_CopyDataPart_0(*(uint64_t **)(*(void *)v3 + 8), v122, v176 + *(__int16 *)(v138 + 2 * v136), v125, (uint64_t *)v123);
              if ((result & 0x80000000) != 0) {
                return result;
              }
              uint64_t v140 = (uint64_t *)v3;
              uint64_t result = Psola_CopyDataPart_0(*(uint64_t **)(*(void *)v3 + 8), v122, v176 + *(__int16 *)(*(void *)(v189 + 16) + 2 * v135), v127, v161);
              uint64_t v130 = v167;
              int v131 = v166;
            }
            int v132 = v172;
            if ((result & 0x80000000) != 0) {
              return result;
            }
            int8x16_t v126 = v140;
            uint64_t v150 = (__int16 *)(*((void *)v187 + 8) + 2 * v194);
            int v151 = *v150;
            uint64_t v129 = v150 - 1;
            int v128 = v151;
          }
          int v152 = *v129;
          long long v167 = v130;
          int v166 = v131;
          int v172 = v132;
          if ((int)v125 > v152)
          {
            cstdlib_memmove(*(void **)v123, (const void *)(*(void *)v123 + 2 * ((int)v125 - *v129)), 2 * *v129);
            LODWORD(v125) = v152;
          }
        }
        else
        {
          uint64_t v133 = **((__int16 **)v100 + 2);
          LODWORD(v127) = *(__int16 *)(*(void *)(v189 + 40) + 2 * v133);
          uint64_t result = Psola_CopyDataPart_0(*(uint64_t **)(*(void *)v3 + 8), v122, v176 + *(__int16 *)(*(void *)(v189 + 16) + 2 * v133), v127, v161);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          int8x16_t v126 = (uint64_t *)v3;
          LODWORD(v125) = 0;
          int v128 = **((__int16 **)v100 + 8);
        }
        if ((int)v127 >= v128) {
          LODWORD(v127) = v128;
        }
        Psola_ApplyHanning_0(*(__int16 **)(v123 + 32), v169, *(__int16 **)v123, v125, 1);
        Psola_ApplyHanning_0(*(__int16 **)(v123 + 32), v169, *(__int16 **)(v123 + 16), v127, 0);
        Psola_ApplyFadingPart(*(__int16 **)v123, v125, v196 - v125, v178, v182, 1);
        Psola_ApplyFadingPart(*(__int16 **)(v123 + 16), v127, v196, v178, v182, 1);
        Psola_ApplyFadingPart(*(__int16 **)v123, v125, v196 - v125, v163, v180, 0);
        Psola_ApplyFadingPart(*(__int16 **)(v123 + 16), v127, v196, v163, v180, 0);
        Psola_AddToOlaBuf_0(v126, v184, *(void *)v123, v125, v196 - v125);
        Psola_AddToOlaBuf_0(v126, v184, *(void *)(v123 + 16), v127, v196);
        int v121 = 1;
        v196 += v128;
        uint64_t v114 = v171;
        uint64_t v122 = v165;
        if (!v192)
        {
          if (v196 >= *(_DWORD *)v174 + 961 || v194 == v171)
          {
            Psola_FlushOlaBufPart_0(v126, v184, *(_DWORD *)v174);
            int v121 = 1;
          }
          else
          {
            int v121 = 0;
          }
        }
        uint64_t v120 = v194 + 1;
        uint64_t v3 = (uint64_t)v126;
        __int16 v100 = v187;
      }
      while (v194 + 1 != v162);
      uint64_t v2 = v174;
      int v119 = *(_DWORD *)v174 + v111;
    }
    *(_DWORD *)uint64_t v2 = v119;
    goto LABEL_49;
  }
  uint64_t v70 = v155;
  uint64_t v71 = v69;
  if (i <= 0x2710) {
    int v72 = 10000;
  }
  else {
    int v72 = i;
  }
  while (v72 != i)
  {
    UNICORN__writeToPeriVec((uint64_t)(v45 + 4), i, v70);
    UNICORN__writeToPeriVec((uint64_t)(v45 + 16), i, 0);
    UNICORN__writeToPeriVec((uint64_t)(v45 + 28), i, *(_WORD *)(*(void *)(v21 + 40) + 2 * v70));
    LODWORD(i) = i + 1;
    ++v45[2];
    if (v71 == ++v70) {
      goto LABEL_16;
    }
  }
  return 2229280777;
}

uint64_t UNICORN__concat_initUnit(uint64_t a1, int a2, int a3, int a4)
{
  *(_DWORD *)(a1 + 21304) = a2;
  *(_DWORD *)(a1 + 21312) = a3;
  *(_DWORD *)(a1 + 21316) = a4;
  *(_DWORD *)(a1 + 21320) = 0;
  *(unsigned char *)(a1 + 21324) = 34;
  *(_DWORD *)(a1 + 21328) = a2 == -1;
  return 0;
}

uint64_t UNICORN__concat_Dur2Sample(unsigned int a1, int a2)
{
  return (int)(float)((float)((float)a1 / 1000.0) * (float)a2);
}

uint64_t UNICORN__Psola_OutputFinalSilence(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 128) + 40 * *(int *)(a2 + 120);
  int v5 = *(_DWORD *)(v4 - 20) * (int)((double)(*(_DWORD *)(a2 + 124) * *(_DWORD *)(v4 - 32)) / 1000.0);
  if (v5 >= 500) {
    UNICORN__Psola_SynthSilence(a1, *(int **)(a2 + 16), (v5 + 500) / 0x3E8u, (int *)a2);
  }
  Psola_FlushOlaBufPart_0(a1, *(_DWORD **)(a2 + 16), *(_DWORD *)(*(void *)(a2 + 16) + 8) + **(_DWORD **)(a2 + 16));
  return 0;
}

void *UNICORN__Psola_Deinitialise(uint64_t a1, void *a2)
{
  uint64_t v4 = a2[2];
  if (v4) {
    heap_Free(*(void **)(a1 + 8), v4);
  }
  uint64_t v5 = a2[3];
  if (v5) {
    heap_Free(*(void **)(a1 + 8), v5);
  }
  uint64_t v6 = (uint64_t *)a2[4];
  if (v6)
  {
    if (*v6)
    {
      heap_Free(*(void **)(a1 + 8), *v6);
      uint64_t v6 = (uint64_t *)a2[4];
    }
    if (v6[2])
    {
      heap_Free(*(void **)(a1 + 8), v6[2]);
      uint64_t v6 = (uint64_t *)a2[4];
    }
    if (v6[4])
    {
      heap_Free(*(void **)(a1 + 8), v6[4]);
      uint64_t v6 = (uint64_t *)a2[4];
    }
    heap_Free(*(void **)(a1 + 8), (uint64_t)v6);
  }
  uint64_t v7 = (uint64_t *)a2[11];
  if (v7) {
    freeModPeriDesc(a1, v7);
  }
  unsigned int v8 = (uint64_t *)a2[12];
  if (v8) {
    freeModPeriDesc(a1, v8);
  }
  uint64_t v9 = a2[16];
  if (v9)
  {
    heap_Free(*(void **)(a1 + 8), v9);
    a2[16] = 0;
  }
  uint64_t v10 = *(void **)(a1 + 8);

  return heap_Free(v10, (uint64_t)a2);
}

void *freeModPeriDesc(uint64_t a1, uint64_t *a2)
{
  heap_Free(*(void **)(a1 + 8), a2[2]);
  heap_Free(*(void **)(a1 + 8), a2[5]);
  heap_Free(*(void **)(a1 + 8), a2[8]);
  uint64_t v4 = *(void **)(a1 + 8);

  return heap_Free(v4, (uint64_t)a2);
}

uint64_t Psola_AssignPeriRanges_0(unsigned __int16 *a1)
{
  unsigned __int16 v1 = a1[3];
  uint64_t v2 = (unsigned __int16)(a1[2] + a1[1] + v1);
  if (a1[2] + a1[1] + v1)
  {
    uint64_t v4 = 0;
    a1[1] = 0;
    uint64_t v5 = (__int16 *)*((void *)a1 + 2);
    while (*v5 < 0)
    {
      a1[1] = ++v4;
      ++v5;
      if (v2 == v4)
      {
        a1[2] = 0;
LABEL_16:
        a1[3] = v2 - v4;
        return 0;
      }
    }
    a1[2] = 0;
    if (v4 >= v2) {
      goto LABEL_16;
    }
    __int16 v6 = 0;
    uint64_t v7 = v2 - v4;
    int v8 = *a1;
    do
    {
      int v9 = *v5++;
      if (v9 >= v8) {
        break;
      }
      a1[2] = ++v6;
      --v7;
    }
    while (v7);
    a1[3] = v2 - (v4 + v6);
    if (!(_WORD)v4 && v6)
    {
      a1[1] = 1;
      if (v6 == 1)
      {
        uint64_t v10 = (v2 - 1);
        if (v2 != 1)
        {
          do
          {
            UNICORN__writeToPeriVec((uint64_t)(a1 + 4), v2, *(_WORD *)(*((void *)a1 + 2) + 2 * v10));
            UNICORN__writeToPeriVec((uint64_t)(a1 + 16), v2, *(_WORD *)(*((void *)a1 + 5) + 2 * v10));
            UNICORN__writeToPeriVec((uint64_t)(a1 + 28), v2, *(_WORD *)(*((void *)a1 + 8) + 2 * v10));
            LODWORD(v2) = v2 - 1;
            --v10;
          }
          while (v10);
        }
        UNICORN__writeToPeriVec((uint64_t)(a1 + 16), 1u, **((__int16 **)a1 + 5) / 2);
        UNICORN__writeToPeriVec((uint64_t)(a1 + 16), 0, **((_WORD **)a1 + 5) - *(_WORD *)(*((void *)a1 + 5) + 2));
        UNICORN__writeToPeriVec((uint64_t)(a1 + 4), 1u, **((_WORD **)a1 + 5) + **((_WORD **)a1 + 2));
        uint64_t v11 = (uint64_t)(a1 + 28);
        UNICORN__writeToPeriVec(v11, 0, 0);
        UNICORN__writeToPeriVec(v11, 1u, 0);
      }
      else
      {
        a1[2] = v6 - 1;
      }
    }
  }
  return 0;
}

uint64_t UNICORN__concat_Sample2Dur(unsigned int a1, int a2)
{
  return (int)(float)((float)a2 / (float)((float)a1 / 1000.0));
}

float UNICORN__concat_Dur2SampleF32(float a1, float a2)
{
  return (float)(a1 / 1000.0) * a2;
}

float UNICORN__concat_Sample2DurF32(float a1, float a2)
{
  return a2 / (float)(a1 / 1000.0);
}

uint64_t UNICORN__Wsola__write_audioX(uint64_t *a1, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t v8 = a4;
  uint64_t v9 = heap_Calloc(*(void **)(*a1 + 8), a4, 2);
  if (v9)
  {
    uint64_t v15 = v9;
    if (a4)
    {
      uint64_t v16 = 0;
      do
      {
        *(_WORD *)(v9 + 2 * v16) = *(_WORD *)(a2 + 2 * (a3 + v16));
        ++v16;
      }
      while (v8 != v16);
      uint64_t v17 = (void (*)(uint64_t, uint64_t, uint64_t))a1[7];
      if (v17) {
        v17(a1[2], v9, v8);
      }
    }
    heap_Free(*(void **)(*a1 + 8), v15);
    return 0;
  }
  else
  {
    UNICORN__log_wsola_Error(*a1, 59000, 0, v10, v11, v12, v13, v14);
    return 2229280778;
  }
}

uint64_t UNICORN__Wsola__write_audio(uint64_t *a1, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t v8 = a4;
  uint64_t v9 = heap_Calloc(*(void **)(*a1 + 8), a4, 2);
  if (v9)
  {
    uint64_t v15 = v9;
    if (a4)
    {
      uint64_t v16 = 0;
      uint64_t v17 = *(void *)(a2 + 16);
      do
      {
        *(_WORD *)(v9 + 2 * v16) = (int)*(float *)(v17 + 4 * (a3 + v16));
        ++v16;
      }
      while (v8 != v16);
      int v18 = (void (*)(uint64_t, uint64_t, uint64_t))a1[7];
      if (v18) {
        v18(a1[2], v9, v8);
      }
    }
    heap_Free(*(void **)(*a1 + 8), v15);
    return 0;
  }
  else
  {
    UNICORN__log_wsola_Error(*a1, 59000, 0, v10, v11, v12, v13, v14);
    return 2229280778;
  }
}

void UNICORN__Wsola__windowinit(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  float v3 = (float)v2;
  uint64_t v4 = *(void *)(a2 + 16);
  int v5 = *(_DWORD *)(a1 + 21192);
  if ((v5 - 1) >= 2)
  {
    if (!v5 && v2)
    {
      uint64_t v13 = 0;
      float v14 = 1.0;
      float v15 = 0.0;
      float v16 = 1.0 / v3;
      do
      {
        *(float *)(v4 + 4 * v2 + v13) = v14;
        *(float *)(v4 + v13) = v15;
        float v14 = v14 - v16;
        float v15 = v16 + v15;
        v13 += 4;
      }
      while (4 * v2 != v13);
    }
  }
  else if (v2)
  {
    uint64_t v6 = 0;
    double v7 = v3 + v3;
    uint64_t v8 = v4 + 4 * v2;
    do
    {
      float v9 = cos(((float)v6 + (float)v6) * 3.14159265 / v7);
      float v10 = v9 * -0.5 + 0.5;
      *(float *)(v4 + 4 * v6) = v10;
      float v11 = cos(((float)v2 + (float)v2) * 3.14159265 / v7);
      float v12 = v11 * -0.5 + 0.5;
      *(float *)(v8 + 4 * v6++) = v12;
      --v2;
    }
    while (v2);
  }
}

uint64_t UNICORN__concat_initW(uint64_t a1)
{
  *(_DWORD *)(a1 + 104) = 0;
  uint64_t v2 = a1 + 104;
  int v3 = *(_DWORD *)(a1 + 64);
  *(_DWORD *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 21296) = *(_DWORD *)(a1 + 21332) != 0;
  if (v3 > 15999)
  {
    if (v3 != 16000)
    {
      if (v3 == 22050)
      {
        char v5 = 4;
        unsigned int v6 = 440;
        goto LABEL_13;
      }
      if (v3 != 16036)
      {
LABEL_18:
        UNICORN__log_wsola_Diag(*(void *)a1, 1, (uint64_t)"ERROR: Unsupported sampling rate = %d\n");
        return 2229280775;
      }
    }
LABEL_11:
    unsigned int v6 = (int)((float)v3 / 1000.0 * 20.0) & 0xFFFFFFFC;
    char v5 = 1;
    goto LABEL_13;
  }
  if (v3 == 8000 || v3 == 8018) {
    goto LABEL_11;
  }
  if (v3 != 11025) {
    goto LABEL_18;
  }
  char v5 = 2;
  unsigned int v6 = 220;
LABEL_13:
  *(unsigned char *)(a1 + 128) = v5;
  *(_DWORD *)(a1 + 112) = v6;
  *(_DWORD *)(a1 + 116) = v6 >> 1;
  *(_DWORD *)(a1 + 120) = 2 * v6;
  *(_DWORD *)(a1 + 124) = 3 * v6;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 140) = 0;
  *(void *)(a1 + 132) = 0;
  *(_DWORD *)(a1 + 148) = 0;
  if (!*(void *)(a1 + 152))
  {
    uint64_t v7 = UNICORN__Vector__Create(*(void **)(*(void *)a1 + 8), 3 * v6);
    *(void *)(a1 + 152) = v7;
    if (!v7)
    {
      uint64_t v9 = 2229280778;
      uint64_t v10 = *(void *)a1;
      float v11 = "ERROR: Out of memory when allocating oladbuf\n";
LABEL_21:
      UNICORN__log_wsola_Diag(v10, 1, (uint64_t)v11);
      return v9;
    }
  }
  uint64_t v8 = *(void *)(a1 + 160);
  if (!v8)
  {
    uint64_t v8 = UNICORN__Vector__Create(*(void **)(*(void *)a1 + 8), *(_DWORD *)(a1 + 120));
    *(void *)(a1 + 160) = v8;
    if (!v8)
    {
      uint64_t v9 = 2229280778;
      uint64_t v10 = *(void *)a1;
      float v11 = "ERROR: Out of memory when allocating wsolaWindow\n";
      goto LABEL_21;
    }
  }
  UNICORN__Wsola__windowinit(v2, v8);
  return 0;
}

uint64_t UNICORN__concat_deinitW(uint64_t a1)
{
  return 0;
}

uint64_t UNICORN__concat_final_deinitW(uint64_t *a1)
{
  return 0;
}

uint64_t concat_enableAddon(uint64_t a1, int a2)
{
  uint64_t v2 = 2229280770;
  if (a1 && a2 >= -1 && *(_DWORD *)(a1 + 48) > a2)
  {
    if (a2 == -1)
    {
      int v5 = 0;
      uint64_t v4 = (void *)(a1 + 24);
    }
    else
    {
      uint64_t v3 = *(void *)(a1 + 40) + 24 * a2;
      uint64_t v4 = (void *)(v3 + 8);
      int v5 = *(_DWORD *)(v3 + 16);
    }
    uint64_t v2 = 0;
    *(void *)(a1 + 32) = *v4;
    *(_DWORD *)(a1 + 52) = v5;
  }
  return v2;
}

uint64_t concat_UID2AddonId(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a3 != -1 && a2)
  {
    unint64_t v5 = 0;
    unsigned int v6 = (unsigned int *)(a1 + 16);
    do
    {
      unsigned int v7 = *v6;
      v6 += 6;
      if (v7 > a3) {
        break;
      }
      ++v5;
    }
    while (v5 < a2);
    return (v5 - 1);
  }
  return result;
}

uint64_t UNICORN__concat_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, uint64_t a9, int a10, int a11)
{
  *(void *)a9 = a1;
  *(void *)(a9 + 8) = a2;
  *(_DWORD *)(a9 + 21332) = a11 != 0;
  *(_DWORD *)(a9 + 100) = a10;
  *(void *)(a9 + 56) = a5;
  *(void *)(a9 + 16) = a6;
  *(void *)(a9 + 72) = a7;
  *(_DWORD *)(a9 + 80) = a8;
  return 0;
}

void Psola_AddToOlaBuf_0(uint64_t *a1, int *a2, uint64_t a3, int a4, int a5)
{
  if (*a2 <= a5)
  {
    int v5 = a5;
    int v6 = a4;
    if (a4 < 1)
    {
      Psola_AddToOlaBufAux_0(a1, a2, (uint64_t)v13, 0, 0, a5);
    }
    else
    {
      int v10 = 0;
      do
      {
        if (v6 >= 12000) {
          int v11 = 12000;
        }
        else {
          int v11 = v6;
        }
        Psola_AddToOlaBufAux_0(a1, a2, a3, v10, v11, v5);
        v10 += v11;
        v5 += v11;
        BOOL v12 = __OFSUB__(v6, v11);
        v6 -= v11;
      }
      while (!((v6 < 0) ^ v12 | (v6 == 0)));
    }
  }
}

void Psola_AddToOlaBufAux_0(uint64_t *a1, int *a2, uint64_t a3, int a4, int a5, int a6)
{
  int v11 = a6 + a5;
  int v12 = a6 + a5 - 12000;
  int v13 = *a2;
  if (v12 > *a2)
  {
    Psola_FlushOlaBufPart_0(a1, a2, v12);
    int v13 = *a2;
  }
  int v14 = (a6 - v13 + a2[1]) % 12000;
  if (12000 - v14 >= a5) {
    int v15 = a5;
  }
  else {
    int v15 = 12000 - v14;
  }
  int v16 = a5 - v15;
  if (v15 >= 1)
  {
    uint64_t v17 = (_WORD *)a2 + v14 + 6;
    int v18 = (__int16 *)(a3 + 2 * a4);
    int v19 = v15;
    do
    {
      __int16 v20 = *v18++;
      *v17++ += v20;
      --v19;
    }
    while (v19);
  }
  if (v16 >= 1)
  {
    int v21 = v15 + a4;
    uint64_t v22 = a2 + 3;
    __int16 v23 = (__int16 *)(a3 + 2 * v21);
    do
    {
      __int16 v24 = *v23++;
      *v22++ += v24;
      --v16;
    }
    while (v16);
  }
  int v25 = v11 - v13;
  if (a2[2] > v25) {
    int v25 = a2[2];
  }
  a2[2] = v25;
}

uint64_t Psola_CopyDataPart_0(uint64_t *a1, uint64_t a2, int a3, unsigned int a4, uint64_t *a5)
{
  uint64_t v8 = a4;
  uint64_t v9 = Psola_ReallocIfNeeded_0(a1, a5, a4);
  if ((v9 & 0x80000000) == 0) {
    cstdlib_memcpy((void *)*a5, (const void *)(a2 + 2 * a3), 2 * v8);
  }
  return v9;
}

__int16 *Psola_ApplyHanning_0(__int16 *result, int *a2, __int16 *a3, int a4, int a5)
{
  if (a4)
  {
    if (*a2 != a4)
    {
      if (a4 >= 1)
      {
        uint64_t v5 = 0;
        int v6 = result;
        do
        {
          *v6++ = HanningTab_0[(int)v5 / a4]
                + (HanningTab_0[(int)v5 / a4 + 1] - HanningTab_0[(int)v5 / a4]) * ((int)v5 % a4) / a4;
          v5 += 200;
        }
        while (200 * a4 != v5);
      }
      *a2 = a4;
    }
    if (a5)
    {
      if (a4 >= 1)
      {
        uint64_t v7 = a4;
        do
        {
          int v8 = *result++;
          *a3 = v8 * *a3 / 0x8000;
          ++a3;
          --v7;
        }
        while (v7);
      }
    }
    else if (a4 >= 1)
    {
      uint64_t v9 = a4;
      do
      {
        int v10 = *result++;
        *a3 = (0x7FFF - v10) * *a3 / 0x8000;
        ++a3;
        --v9;
      }
      while (v9);
    }
  }
  return result;
}

uint64_t Psola_ReallocIfNeeded_0(uint64_t *a1, uint64_t *a2, unint64_t a3)
{
  if (a2[1] >= a3) {
    return 0;
  }
  unint64_t v4 = (a3 & 0xFFFFFFFFFFFFFE00) + 512;
  uint64_t v5 = heap_Realloc(a1, *a2, 2 * v4);
  if (!v5) {
    return 2229280778;
  }
  uint64_t v6 = v5;
  uint64_t result = 0;
  *a2 = v6;
  a2[1] = v4;
  return result;
}

uint64_t UNICORN__Vector__Clear(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  uint64_t v2 = *(void **)(a1 + 16);
  if (!v2) {
    return 1;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3) {
    bzero(v2, 4 * v3);
  }
  return 0;
}

uint64_t UNICORN__Vector__Create(void *a1, unsigned int a2)
{
  uint64_t v4 = heap_Calloc(a1, 1, 24);
  uint64_t v5 = v4;
  if (v4)
  {
    *(void *)uint64_t v4 = a1;
    *(_DWORD *)(v4 + 8) = a2;
    *(_DWORD *)(v4 + 12) = 0;
    uint64_t v6 = (void *)heap_Calloc(a1, a2, 4);
    *(void *)(v5 + 16) = v6;
    if (v6)
    {
      uint64_t v7 = *(unsigned int *)(v5 + 8);
      if (v7) {
        bzero(v6, 4 * v7);
      }
    }
    else
    {
      heap_Free(a1, v5);
      return 0;
    }
  }
  return v5;
}

uint64_t *UNICORN__Window__Remove(uint64_t *result)
{
  if (result)
  {
    unsigned __int16 v1 = result;
    if (*result)
    {
      heap_Free(*(void **)*result, *(void *)(*result + 16));
      *(void *)(*v1 + 16) = 0;
      uint64_t result = heap_Free(*(void **)*v1, *v1);
      uint64_t *v1 = 0;
    }
  }
  return result;
}

uint64_t UNICORN__log_wsola_Diag(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = a3 - 1;
  do
    int v4 = *(unsigned __int8 *)++v3;
  while (v4 == 10);
  return log_VOutText(*(void *)(a1 + 32), (uint64_t)"SYNTH_BET5", (a2 + 2), 0, v3);
}

uint64_t UNICORN__log_wsola_Error(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return log_OutPublic(*(void *)(a1 + 32), (uint64_t)"SYNTH_BET5", a2, 0, a5, a6, a7, a8, v9);
}

float sonicGetSpeed(uint64_t a1)
{
  return *(float *)(a1 + 32);
}

uint64_t sonicSetSpeed(uint64_t result, float a2)
{
  *(float *)(result + 32) = a2;
  return result;
}

float sonicGetPitch(uint64_t a1)
{
  return *(float *)(a1 + 40);
}

uint64_t sonicSetPitch(uint64_t result, float a2)
{
  *(float *)(result + 40) = a2;
  return result;
}

float sonicGetRate(uint64_t a1)
{
  return *(float *)(a1 + 44);
}

uint64_t sonicSetRate(uint64_t result, float a2)
{
  *(float *)(result + 44) = a2;
  *(void *)(result + 48) = 0;
  return result;
}

uint64_t sonicGetChordPitch(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t sonicSetChordPitch(uint64_t result, int a2)
{
  *(_DWORD *)(result + 56) = a2;
  return result;
}

uint64_t sonicGetQuality(uint64_t a1)
{
  return *(unsigned int *)(a1 + 60);
}

uint64_t sonicSetQuality(uint64_t result, int a2)
{
  *(_DWORD *)(result + 60) = a2;
  return result;
}

float sonicGetVolume(uint64_t a1)
{
  return *(float *)(a1 + 36);
}

uint64_t sonicSetVolume(uint64_t result, float a2)
{
  *(float *)(result + 36) = a2;
  return result;
}

void *sonicDestroyStream(void *result, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    freeStreamBuffers(result, a2);
    int v4 = (void *)v3[1];
    return heap_Free(v4, (uint64_t)a2);
  }
  return result;
}

void *freeStreamBuffers(void *result, uint64_t *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *a2;
  if (v4) {
    uint64_t result = heap_Free((void *)result[1], v4);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    uint64_t result = heap_Free((void *)v3[1], v5);
  }
  uint64_t v6 = a2[2];
  if (v6) {
    uint64_t result = heap_Free((void *)v3[1], v6);
  }
  uint64_t v7 = a2[3];
  if (v7)
  {
    int v8 = (void *)v3[1];
    return heap_Free(v8, v7);
  }
  return result;
}

uint64_t sonicCreateStream(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v6 = heap_Calloc(*(void **)(a1 + 8), 1, 128);
  if (v6)
  {
    if (allocateStreamBuffers(a1, v6, a2, a3))
    {
      __asm { FMOV            V0.4S, #1.0 }
      *(_OWORD *)(v6 + 32) = _Q0;
      *(void *)(v6 + 48) = 0;
      *(void *)(v6 + 56) = 0;
      *(_DWORD *)(v6 + 120) = 1112014848;
    }
    else
    {
      return 0;
    }
  }
  return v6;
}

uint64_t allocateStreamBuffers(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  int v8 = a3 / 65;
  uint64_t v9 = (2 * (a3 / 65));
  *(_DWORD *)(a2 + 68) = v9;
  uint64_t v10 = 2 * a4;
  uint64_t v11 = heap_Calloc(*(void **)(a1 + 8), v9, v10);
  *(void *)a2 = v11;
  if (!v11) {
    goto LABEL_6;
  }
  *(_DWORD *)(a2 + 76) = v9;
  uint64_t v12 = heap_Calloc(*(void **)(a1 + 8), v9, v10);
  *(void *)(a2 + 8) = v12;
  if (!v12) {
    goto LABEL_6;
  }
  *(_DWORD *)(a2 + 72) = v9;
  uint64_t v13 = heap_Calloc(*(void **)(a1 + 8), v9, v10);
  *(void *)(a2 + 16) = v13;
  if (v13 && (uint64_t v14 = heap_Calloc(*(void **)(a1 + 8), v9, 2), (*(void *)(a2 + 24) = v14) != 0))
  {
    *(_DWORD *)(a2 + 64) = a4;
    *(void *)(a2 + 48) = 0;
    *(_DWORD *)(a2 + 92) = a3 / 400;
    *(_DWORD *)(a2 + 96) = v8;
    *(_DWORD *)(a2 + 100) = v9;
    *(_DWORD *)(a2 + 108) = a3;
    *(_DWORD *)(a2 + 112) = 0;
    return 1;
  }
  else
  {
LABEL_6:
    freeStreamBuffers((void *)a1, (uint64_t *)a2);
    heap_Free(*(void **)(a1 + 8), a2);
    return 0;
  }
}

uint64_t sonicGetSampleRate(uint64_t a1)
{
  return *(unsigned int *)(a1 + 108);
}

uint64_t sonicSetSampleRate(void *a1, uint64_t a2, int a3)
{
  freeStreamBuffers(a1, (uint64_t *)a2);
  unsigned int v6 = *(_DWORD *)(a2 + 64);

  return allocateStreamBuffers((uint64_t)a1, a2, a3, v6);
}

uint64_t sonicGetNumChannels(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t sonicSetNumChannels(void *a1, uint64_t a2, unsigned int a3)
{
  freeStreamBuffers(a1, (uint64_t *)a2);
  int v6 = *(_DWORD *)(a2 + 108);

  return allocateStreamBuffers((uint64_t)a1, a2, v6, a3);
}

uint64_t sonicReadFloatFromStream(uint64_t a1, float *a2, signed int a3)
{
  signed int v3 = *(_DWORD *)(a1 + 84);
  if (!v3) {
    return 0;
  }
  if (v3 >= a3) {
    uint64_t v5 = a3;
  }
  else {
    uint64_t v5 = v3;
  }
  if (v3 <= a3) {
    int v6 = 0;
  }
  else {
    int v6 = v3 - a3;
  }
  uint64_t v7 = *(__int16 **)(a1 + 8);
  int v8 = *(_DWORD *)(a1 + 64);
  if (v8 * v5)
  {
    int v9 = v8 * v5;
    uint64_t v10 = v7;
    do
    {
      int v11 = *v10++;
      *a2++ = (float)v11 / 32767.0;
      --v9;
    }
    while (v9);
  }
  if (v6 >= 1) {
    cstdlib_memmove(v7, &v7[(v8 * v5)], (2 * v6 * v8));
  }
  *(_DWORD *)(a1 + 84) = v6;
  return v5;
}

uint64_t sonicReadShortFromStream(uint64_t a1, void *__dst, signed int a3)
{
  signed int v3 = *(_DWORD *)(a1 + 84);
  if (!v3) {
    return 0;
  }
  if (v3 >= a3) {
    uint64_t v5 = a3;
  }
  else {
    uint64_t v5 = v3;
  }
  if (v3 <= a3) {
    int v6 = 0;
  }
  else {
    int v6 = v3 - a3;
  }
  cstdlib_memcpy(__dst, *(const void **)(a1 + 8), (2 * v5 * *(_DWORD *)(a1 + 64)));
  if (v6 >= 1) {
    cstdlib_memmove(*(void **)(a1 + 8), (const void *)(*(void *)(a1 + 8) + 2 * (*(_DWORD *)(a1 + 64) * v5)), (2 * v6 * *(_DWORD *)(a1 + 64)));
  }
  *(_DWORD *)(a1 + 84) = v6;
  return v5;
}

uint64_t sonicReadUnsignedCharFromStream(uint64_t a1, unsigned char *a2, signed int a3)
{
  signed int v3 = *(_DWORD *)(a1 + 84);
  if (!v3) {
    return 0;
  }
  if (v3 >= a3) {
    uint64_t v5 = a3;
  }
  else {
    uint64_t v5 = v3;
  }
  if (v3 <= a3) {
    int v6 = 0;
  }
  else {
    int v6 = v3 - a3;
  }
  int v7 = *(_DWORD *)(a1 + 64) * v5;
  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      char v9 = *(unsigned char *)(v8 + 1);
      v8 += 2;
      *a2++ = v9 ^ 0x80;
      --v7;
    }
    while (v7);
  }
  if (v6 >= 1) {
    cstdlib_memmove(*(void **)(a1 + 8), (const void *)(*(void *)(a1 + 8) + 2 * (*(_DWORD *)(a1 + 64) * v5)), (2 * v6 * *(_DWORD *)(a1 + 64)));
  }
  *(_DWORD *)(a1 + 84) = v6;
  return v5;
}

uint64_t sonicFlushStream(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 100);
  float v5 = *(float *)(a2 + 32);
  float v6 = *(float *)(a2 + 40);
  float v7 = *(float *)(a2 + 44);
  int v9 = *(_DWORD *)(a2 + 80);
  int v8 = *(_DWORD *)(a2 + 84);
  int v10 = *(_DWORD *)(a2 + 88);
  uint64_t result = enlargeInputBufferIfNeeded(a1, a2, v9 + 2 * v4);
  if (result)
  {
    cstdlib_memset((void *)(*(void *)a2 + 2 * (*(_DWORD *)(a2 + 64) * v9)), 0, (4 * v4 * *(_DWORD *)(a2 + 64)));
    *(_DWORD *)(a2 + 80) += 2 * v4;
    uint64_t result = processStreamInput(a1, a2);
    if (result)
    {
      int v12 = v8
          + (int)(float)((float)((float)((float)((float)v9 / (float)(v5 / v6)) + (float)v10) / (float)(v6 * v7)) + 0.5);
      if (*(_DWORD *)(a2 + 84) > v12) {
        *(_DWORD *)(a2 + 84) = v12;
      }
      *(_DWORD *)(a2 + 80) = 0;
      *(_DWORD *)(a2 + 104) = 0;
      uint64_t result = 1;
      *(_DWORD *)(a2 + 88) = 0;
    }
  }
  return result;
}

uint64_t enlargeInputBufferIfNeeded(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = *(_DWORD *)(a2 + 68);
  if (*(_DWORD *)(a2 + 80) + a3 <= v3) {
    return 1;
  }
  unsigned int v5 = v3 + a3 + (v3 >> 1);
  *(_DWORD *)(a2 + 68) = v5;
  uint64_t result = heap_Realloc(*(uint64_t **)(a1 + 8), *(void *)a2, 2 * *(unsigned int *)(a2 + 64) * (unint64_t)v5);
  *(void *)a2 = result;
  if (result) {
    return 1;
  }
  return result;
}

uint64_t sonicWriteShortToStream(uint64_t a1, uint64_t a2, const void *a3, unsigned int a4)
{
  if (a4)
  {
    uint64_t result = enlargeInputBufferIfNeeded(a1, a2, a4);
    if (!result) {
      return result;
    }
    cstdlib_memcpy((void *)(*(void *)a2 + 2 * (*(_DWORD *)(a2 + 64) * *(_DWORD *)(a2 + 80))), a3, 2 * *(unsigned int *)(a2 + 64) * (unint64_t)a4);
    *(_DWORD *)(a2 + 80) += a4;
  }

  return processStreamInput(a1, a2);
}

uint64_t sonicSamplesAvailable(uint64_t a1)
{
  return *(unsigned int *)(a1 + 84);
}

uint64_t overlapAdd(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2 >= 1)
  {
    uint64_t v5 = 0;
    do
    {
      if ((int)result >= 1)
      {
        uint64_t v6 = 0;
        int v7 = 0;
        int v8 = result << 16;
        int v9 = result;
        do
        {
          *(_WORD *)(a3 + v6) = ((v8 >> 16) * *(__int16 *)(a4 + v6) + (v7 >> 16) * *(__int16 *)(a5 + v6))
                              / (__int16)result;
          v8 -= 0x10000;
          v7 += 0x10000;
          v6 += 2 * a2;
          --v9;
        }
        while (v9);
      }
      ++v5;
      a4 += 2;
      a5 += 2;
      a3 += 2;
    }
    while (v5 != a2);
  }
  return result;
}

uint64_t sonicWriteFloatToStream(uint64_t a1, uint64_t a2, float *a3, int a4)
{
  if (a4)
  {
    int v8 = *(_DWORD *)(a2 + 64);
    uint64_t result = enlargeInputBufferIfNeeded(a1, a2, a4);
    if (!result) {
      return result;
    }
    int v10 = *(_DWORD *)(a2 + 80);
    if (v8)
    {
      int v11 = v8 * a4;
      int v12 = (_WORD *)(*(void *)a2 + 2 * *(_DWORD *)(a2 + 64) * v10);
      do
      {
        float v13 = *a3++;
        *v12++ = (int)(float)(v13 * 32767.0);
        --v11;
      }
      while (v11);
    }
    *(_DWORD *)(a2 + 80) = v10 + a4;
  }

  return processStreamInput(a1, a2);
}

uint64_t processStreamInput(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 84);
  float v4 = *(float *)(a2 + 44);
  float v5 = *(float *)(a2 + 32) / *(float *)(a2 + 40);
  if (*(_DWORD *)(a2 + 56)) {
    float v6 = 1.0;
  }
  else {
    float v6 = *(float *)(a2 + 40);
  }
  if (v5 <= 1.00001 && v5 >= 0.99999)
  {
    uint64_t result = copyToOutput(a1, a2, *(const void **)a2, *(_DWORD *)(a2 + 80));
    if (result)
    {
      int v79 = v3;
      *(_DWORD *)(a2 + 80) = 0;
      goto LABEL_36;
    }
    return result;
  }
  int v79 = *(_DWORD *)(a2 + 84);
  int v8 = *(_DWORD *)(a2 + 80);
  int v9 = *(_DWORD *)(a2 + 100);
  if (v8 < v9) {
    goto LABEL_36;
  }
  int v10 = 0;
  do
  {
    int v11 = *(_DWORD *)(a2 + 104);
    if (v11 >= 1)
    {
      if (v11 >= *(_DWORD *)(a2 + 100)) {
        LODWORD(v12) = *(_DWORD *)(a2 + 100);
      }
      else {
        LODWORD(v12) = *(_DWORD *)(a2 + 104);
      }
      if (!copyToOutput(a1, a2, (const void *)(*(void *)a2 + 2 * *(_DWORD *)(a2 + 64) * v10), v12)) {
        goto LABEL_36;
      }
      *(_DWORD *)(a2 + 104) -= v12;
LABEL_27:
      if (!v12) {
        goto LABEL_36;
      }
      goto LABEL_28;
    }
    float v13 = (__int16 *)(*(void *)a2 + 2 * *(_DWORD *)(a2 + 64) * v10);
    uint64_t PitchPeriod = findPitchPeriod(a2, v13, 1);
    int v15 = PitchPeriod;
    int v16 = *(_DWORD *)(a2 + 64);
    if (v5 <= 1.0)
    {
      float v18 = (float)(int)PitchPeriod;
      if (v5 >= 0.5)
      {
        *(_DWORD *)(a2 + 104) = (int)(float)((float)((float)((float)(v5 * 2.0) + -1.0) / (float)(1.0 - v5)) * v18);
        uint64_t v12 = PitchPeriod;
      }
      else
      {
        uint64_t v12 = (int)(float)((float)(v5 / (float)(1.0 - v5)) * v18);
      }
      int v19 = v12 + PitchPeriod;
      if (!enlargeOutputBufferIfNeeded(a1, a2, (int)v12 + (int)PitchPeriod)) {
        goto LABEL_36;
      }
      cstdlib_memcpy((void *)(*(void *)(a2 + 8) + 2 * *(_DWORD *)(a2 + 84) * v16), v13, (2 * v16 * v15));
      overlapAdd(v12, v16, *(void *)(a2 + 8) + 2 * (*(_DWORD *)(a2 + 84) + v15) * v16, (uint64_t)&v13[v16 * v15], (uint64_t)v13);
      *(_DWORD *)(a2 + 84) += v19;
      goto LABEL_27;
    }
    if (v5 >= 2.0)
    {
      uint64_t v17 = (int)(float)((float)(int)PitchPeriod / (float)(v5 + -1.0));
    }
    else
    {
      *(_DWORD *)(a2 + 104) = PitchPeriod * (int)(float)((float)(2.0 - v5) / (float)(v5 + -1.0));
      uint64_t v17 = PitchPeriod;
    }
    if (enlargeOutputBufferIfNeeded(a1, a2, v17))
    {
      overlapAdd(v17, v16, *(void *)(a2 + 8) + 2 * *(_DWORD *)(a2 + 84) * v16, (uint64_t)v13, (uint64_t)&v13[v16 * v15]);
      *(_DWORD *)(a2 + 84) += v17;
    }
    else
    {
      LODWORD(v17) = 0;
    }
    LODWORD(v12) = v17 + v15;
    if (!v17) {
      goto LABEL_36;
    }
LABEL_28:
    v10 += v12;
  }
  while (v10 + v9 <= v8);
  int v20 = *(_DWORD *)(a2 + 80) - v10;
  if (v20 >= 1) {
    cstdlib_memmove(*(void **)a2, (const void *)(*(void *)a2 + 2 * (*(_DWORD *)(a2 + 64) * v10)), (2 * v20 * *(_DWORD *)(a2 + 64)));
  }
  *(_DWORD *)(a2 + 80) = v20;
LABEL_36:
  if (*(_DWORD *)(a2 + 56))
  {
    float v21 = *(float *)(a2 + 40);
    int v22 = v79;
    if (v21 != 1.0 && *(_DWORD *)(a2 + 84) != v79)
    {
      uint64_t v23 = *(unsigned int *)(a2 + 64);
      uint64_t result = moveNewSamplesToPitchBuffer(a1, a2, v79);
      if (!result) {
        return result;
      }
      if (*(_DWORD *)(a2 + 88) >= *(_DWORD *)(a2 + 100))
      {
        LODWORD(v24) = 0;
        while (1)
        {
          int v25 = findPitchPeriod(a2, (__int16 *)(*(void *)(a2 + 16) + 2 * (int)v24 * (int)v23), 0);
          float v26 = (float)v25 / v21;
          uint64_t v27 = (int)v26;
          uint64_t result = enlargeOutputBufferIfNeeded(a1, a2, (int)v26);
          if (!result) {
            return result;
          }
          int v28 = *(_DWORD *)(a2 + 84);
          uint64_t v29 = *(void *)(a2 + 16);
          uint64_t v30 = *(void *)(a2 + 8) + 2 * v28 * (int)v23;
          uint64_t v31 = v29 + 2 * (int)v24 * (int)v23;
          if (v21 >= 1.0)
          {
            overlapAdd(v27, v23, v30, v31, v29 + 2 * (v25 + (int)v24 - (int)v27) * (int)v23);
            int v28 = *(_DWORD *)(a2 + 84);
          }
          else if ((int)v23 >= 1)
          {
            uint64_t v32 = 0;
            __int16 v33 = v25 - v27;
            do
            {
              if ((int)v27 >= 1)
              {
                int v34 = 0;
                int v35 = (unsigned __int16 *)(v31 + 2 * v32);
                uint64_t v36 = (_WORD *)v30;
                unsigned __int16 v37 = v25;
                int v38 = v35;
                do
                {
                  if (v34 >= (int)v27 - v25)
                  {
                    if (v34 >= v25)
                    {
                      if (v25) {
                        unsigned int v39 = (unsigned __int16)(v33 + v34) * *v38 / (unsigned __int16)v25;
                      }
                      else {
                        LOWORD(v39) = 0;
                      }
                      *uint64_t v36 = v39;
                    }
                    else
                    {
                      *uint64_t v36 = (unsigned __int16)(v33 + v34) * *v38 / (unsigned __int16)v25 + v37 * *v35;
                      v35 += v23;
                    }
                    v38 += v23;
                  }
                  else
                  {
                    *uint64_t v36 = v37 * *v35 / (unsigned __int16)v25;
                    v35 += v23;
                  }
                  ++v34;
                  --v37;
                  v36 += v23;
                }
                while (v27 != v34);
              }
              ++v32;
              v30 += 2;
            }
            while (v32 != v23);
          }
          *(_DWORD *)(a2 + 84) = v28 + v27;
          LODWORD(v24) = v25 + v24;
          if (*(_DWORD *)(a2 + 88) - (int)v24 < *(_DWORD *)(a2 + 100)) {
            goto LABEL_98;
          }
        }
      }
LABEL_97:
      LODWORD(v24) = 0;
LABEL_98:
      removePitchSamples((void **)a2, v24);
    }
LABEL_99:
    float v69 = *(float *)(a2 + 36);
    double v70 = (float)(v69 + -0.8);
    if (v70 > 0.00000001 || v70 < -0.00000001)
    {
      int v71 = *(_DWORD *)(a2 + 64);
      uint64_t v72 = (int)(float)(v69 * 100.0);
      uint64_t v73 = ((*(_DWORD *)(a2 + 84) - v22) * v71);
      if (v69 > 1.0) {
        uint64_t v72 = 100;
      }
      if ((int)v73 >= 1)
      {
        unsigned int v74 = (__int16 *)(*(void *)(a2 + 8) + 2 * v71 * v22);
        int v75 = aVolScaleFactor[v72];
        do
        {
          int v76 = *v74 * v75;
          unsigned int v77 = v76 >> 15;
          if (v76 < -1073709056) {
            LOWORD(v77) = -32767;
          }
          if (v76 <= 0x3FFFFFFF) {
            __int16 v78 = v77;
          }
          else {
            __int16 v78 = 0x7FFF;
          }
          *v74++ = v78;
          --v73;
        }
        while (v73);
      }
    }
    return 1;
  }
  int v22 = v79;
  if ((float)(v4 * v6) == 1.0) {
    goto LABEL_99;
  }
  int v40 = *(_DWORD *)(a2 + 108);
  int v41 = (int)(float)((float)v40 / (float)(v4 * v6));
  if (v40 > 0x4000 || v41 > 0x4000)
  {
    do
    {
      do
      {
        int v42 = v41;
        int v43 = v40;
        v41 >>= 1;
        v40 >>= 1;
      }
      while (v42 > 32769);
    }
    while (v43 > 32769);
  }
  if (*(_DWORD *)(a2 + 84) == v79) {
    goto LABEL_99;
  }
  int v44 = *(_DWORD *)(a2 + 64);
  uint64_t result = moveNewSamplesToPitchBuffer(a1, a2, v79);
  if (!result) {
    return result;
  }
  if (*(int *)(a2 + 88) < 13) {
    goto LABEL_97;
  }
  uint64_t v24 = 0;
  int v45 = *(_DWORD *)(a2 + 48);
  int v46 = *(_DWORD *)(a2 + 52);
  while (++v45 * v41 <= v46 * v40)
  {
LABEL_92:
    *(_DWORD *)(a2 + 48) = v45;
    if (v45 == v40)
    {
      *(_DWORD *)(a2 + 48) = 0;
      if (v46 != v41) {
        return 0;
      }
      int v46 = 0;
      int v45 = 0;
      *(_DWORD *)(a2 + 52) = 0;
    }
    if (++v24 >= *(int *)(a2 + 88) - 12) {
      goto LABEL_98;
    }
  }
  while (1)
  {
    uint64_t result = enlargeOutputBufferIfNeeded(a1, a2, 1);
    if (!result) {
      return result;
    }
    int v47 = *(_DWORD *)(a2 + 84);
    int v48 = *(_DWORD *)(a2 + 48);
    int v49 = *(_DWORD *)(a2 + 52);
    if (v44 <= 0)
    {
      int v45 = v48 + 1;
      int v53 = v45 * v41;
    }
    else
    {
      int v50 = 0;
      uint64_t v51 = *(void *)(a2 + 16) + 2 * (v44 * v24);
      uint64_t v52 = (_WORD *)(*(void *)(a2 + 8) + 2 * (v47 * v44));
      int v45 = v48 + 1;
      int v53 = v45 * v41;
      int v54 = 50 * (v45 * v41 + ~(v49 * v40));
      int v55 = v54 / v41;
      int v56 = v54 % v41;
      uint64_t v57 = 2 * *(int *)(a2 + 64);
      int v58 = (char *)&sincTable + 2 * v55;
      do
      {
        uint64_t v59 = 0;
        uint64_t v60 = 0;
        int v61 = 0;
        int v62 = 0;
        do
        {
          int v63 = 2
              * ((v41 - v56) * *(__int16 *)&v58[v60] + v56 * *(__int16 *)&v58[v60 + 2])
              / v41
              * *(__int16 *)(v51 + v59);
          unsigned int v64 = v63 + v62;
          int v65 = (v63 + v62) ^ v62;
          v59 += v57;
          if ((v63 ^ v62) >= 0) {
            int v66 = (v62 >> 31) | 1;
          }
          else {
            int v66 = 0;
          }
          int v67 = v66 + v61;
          if (v65 < 0) {
            int v61 = v67;
          }
          v60 += 100;
          int v62 = v64;
        }
        while (v60 != 1200);
        if (v61 <= 0)
        {
          if (v61 < 0) {
            LOWORD(v68) = 0x8000;
          }
          else {
            unsigned int v68 = HIWORD(v64);
          }
        }
        else
        {
          LOWORD(v68) = 0x7FFF;
        }
        *v52++ = v68;
        v51 += 2;
        ++v50;
      }
      while (v50 != v44);
    }
    int v46 = v49 + 1;
    *(_DWORD *)(a2 + 52) = v46;
    *(_DWORD *)(a2 + 84) = v47 + 1;
    if (v53 <= v46 * v40) {
      goto LABEL_92;
    }
  }
}

uint64_t sonicWriteUnsignedCharToStream(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4)
{
  if (a4)
  {
    int v8 = *(_DWORD *)(a2 + 64);
    uint64_t result = enlargeInputBufferIfNeeded(a1, a2, a4);
    if (!result) {
      return result;
    }
    int v10 = *(_DWORD *)(a2 + 80);
    if (v8)
    {
      int v11 = v8 * a4;
      uint64_t v12 = (_WORD *)(*(void *)a2 + 2 * *(_DWORD *)(a2 + 64) * v10);
      do
      {
        __int16 v13 = *a3++;
        *v12++ = (v13 << 8) ^ 0x8000;
        --v11;
      }
      while (v11);
    }
    *(_DWORD *)(a2 + 80) = v10 + a4;
  }

  return processStreamInput(a1, a2);
}

uint64_t sonicChangeFloatSpeed(uint64_t a1, float *a2, int a3, int a4, int a5, unsigned int a6, float a7, float a8, float a9, float a10)
{
  Streauint64_t m = sonicCreateStream(a1, a5, a6);
  if (!Stream) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v19 = Stream;
  *(float *)(Stream + 40) = a8;
  *(float *)(Stream + 44) = a9;
  *(void *)(Stream + 48) = 0;
  *(float *)(Stream + 32) = a7;
  *(float *)(Stream + 36) = a10;
  *(_DWORD *)(Stream + 56) = a4;
  sonicWriteFloatToStream(a1, Stream, a2, a3);
  sonicFlushStream(a1, v19);
  uint64_t v20 = *(unsigned int *)(v19 + 84);
  sonicReadFloatFromStream(v19, a2, *(_DWORD *)(v19 + 84));
  freeStreamBuffers((void *)a1, (uint64_t *)v19);
  heap_Free(*(void **)(a1 + 8), v19);
  return v20;
}

uint64_t sonicChangeShortSpeed(uint64_t a1, void *a2, unsigned int a3, int a4, int a5, unsigned int a6, float a7, float a8, float a9, float a10)
{
  Streauint64_t m = sonicCreateStream(a1, a5, a6);
  if (!Stream) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v19 = Stream;
  *(float *)(Stream + 40) = a8;
  *(float *)(Stream + 44) = a9;
  *(void *)(Stream + 48) = 0;
  *(float *)(Stream + 32) = a7;
  *(float *)(Stream + 36) = a10;
  *(_DWORD *)(Stream + 56) = a4;
  sonicWriteShortToStream(a1, Stream, a2, a3);
  sonicFlushStream(a1, v19);
  uint64_t v20 = *(unsigned int *)(v19 + 84);
  sonicReadShortFromStream(v19, a2, *(_DWORD *)(v19 + 84));
  freeStreamBuffers((void *)a1, (uint64_t *)v19);
  heap_Free(*(void **)(a1 + 8), v19);
  return v20;
}

uint64_t copyToOutput(uint64_t a1, uint64_t a2, const void *a3, int a4)
{
  uint64_t result = enlargeOutputBufferIfNeeded(a1, a2, a4);
  if (result)
  {
    cstdlib_memcpy((void *)(*(void *)(a2 + 8) + 2 * (*(_DWORD *)(a2 + 64) * *(_DWORD *)(a2 + 84))), a3, (2 * a4 * *(_DWORD *)(a2 + 64)));
    *(_DWORD *)(a2 + 84) += a4;
    return 1;
  }
  return result;
}

uint64_t findPitchPeriod(uint64_t a1, __int16 *a2, int a3)
{
  int v6 = *(_DWORD *)(a1 + 108);
  if (v6 < 4001)
  {
    int v8 = 1;
  }
  else
  {
    unsigned int v7 = v6 / 0xFA0u;
    if (*(_DWORD *)(a1 + 60)) {
      int v8 = 1;
    }
    else {
      int v8 = v7;
    }
  }
  int v10 = *(_DWORD *)(a1 + 92);
  int v9 = *(_DWORD *)(a1 + 96);
  uint64_t v19 = 0;
  if (v8 == 1 && *(_DWORD *)(a1 + 64) == 1)
  {
    int v11 = (unsigned __int16 *)a2;
    int v12 = v10;
LABEL_20:
    uint64_t PitchPeriodInRange = findPitchPeriodInRange(v11, v12, v9, (int *)&v19 + 1, (int *)&v19);
    goto LABEL_21;
  }
  downSampleInput(a1, a2, v8);
  uint64_t PitchPeriodInRange = findPitchPeriodInRange(*(unsigned __int16 **)(a1 + 24), v10 / v8, v9 / v8, (int *)&v19 + 1, (int *)&v19);
  if (v8 != 1)
  {
    int v14 = PitchPeriodInRange * v8 + 4 * v8;
    if ((int)PitchPeriodInRange * v8 - 4 * v8 <= *(_DWORD *)(a1 + 92)) {
      int v15 = *(_DWORD *)(a1 + 92);
    }
    else {
      int v15 = PitchPeriodInRange * v8 - 4 * v8;
    }
    if (v14 >= *(_DWORD *)(a1 + 96)) {
      int v9 = *(_DWORD *)(a1 + 96);
    }
    else {
      int v9 = v14;
    }
    if (*(_DWORD *)(a1 + 64) == 1)
    {
      int v11 = (unsigned __int16 *)a2;
    }
    else
    {
      downSampleInput(a1, a2, 1);
      int v11 = *(unsigned __int16 **)(a1 + 24);
    }
    int v12 = v15;
    goto LABEL_20;
  }
LABEL_21:
  int v16 = HIDWORD(v19);
  uint64_t v17 = PitchPeriodInRange;
  if (HIDWORD(v19))
  {
    uint64_t v17 = PitchPeriodInRange;
    if (*(_DWORD *)(a1 + 112))
    {
      if (a3)
      {
        uint64_t v17 = PitchPeriodInRange;
        if (3 * HIDWORD(v19) < (int)v19) {
          goto LABEL_29;
        }
        uint64_t v17 = PitchPeriodInRange;
        if (3 * *(_DWORD *)(a1 + 116) >= 2 * HIDWORD(v19)) {
          goto LABEL_29;
        }
      }
      else
      {
        uint64_t v17 = PitchPeriodInRange;
        if (*(_DWORD *)(a1 + 116) >= SHIDWORD(v19)) {
          goto LABEL_29;
        }
      }
      uint64_t v17 = *(unsigned int *)(a1 + 112);
    }
  }
LABEL_29:
  *(_DWORD *)(a1 + 112) = PitchPeriodInRange;
  *(_DWORD *)(a1 + 116) = v16;
  return v17;
}

uint64_t findPitchPeriodInRange(unsigned __int16 *a1, int a2, int a3, int *a4, int *a5)
{
  if (a2 <= a3)
  {
    int v9 = 0;
    uint64_t v10 = a2;
    int v11 = a3 + 1;
    uint64_t v12 = a2;
    uint64_t result = 0xFFFFFFFFLL;
    int v13 = 255;
    int v6 = 1;
    do
    {
      if (v10 < 1)
      {
        int v14 = 0;
      }
      else
      {
        int v14 = 0;
        int v15 = v10;
        int v16 = a1;
        do
        {
          unsigned int v17 = *v16;
          unsigned int v18 = v16[v12];
          ++v16;
          unsigned __int16 v19 = v18 - v17;
          BOOL v20 = v17 >= v18;
          unsigned __int16 v21 = v17 - v18;
          if (!v20) {
            unsigned __int16 v21 = v19;
          }
          v14 += v21;
          --v15;
        }
        while (v15);
      }
      if (result == -1 || v14 * (int)result < v6 * (int)v10)
      {
        uint64_t result = v10;
        int v6 = v14;
      }
      int v22 = v14 * v13;
      if (v14 * v13 > v9 * (int)v10) {
        int v13 = v10;
      }
      if (v22 > v9 * (int)v10) {
        int v9 = v14;
      }
      ++v10;
      ++v12;
    }
    while (v11 != v10);
    int v5 = v9 / v13;
  }
  else
  {
    int v5 = 0;
    int v6 = 1;
    uint64_t result = 0xFFFFFFFFLL;
  }
  *a4 = v6 / (int)result;
  *a5 = v5;
  return result;
}

uint64_t downSampleInput(uint64_t result, __int16 *a2, int a3)
{
  int v3 = *(_DWORD *)(result + 100) / a3;
  if (v3 >= 1)
  {
    int v4 = 0;
    int v5 = *(_DWORD *)(result + 64) * a3;
    int v6 = *(_WORD **)(result + 24);
    do
    {
      if (v5 < 1)
      {
        int v7 = 0;
      }
      else
      {
        int v7 = 0;
        int v8 = v5;
        int v9 = a2;
        do
        {
          int v10 = *v9++;
          v7 += v10;
          --v8;
        }
        while (v8);
        a2 += (v5 - 1) + 1;
      }
      *v6++ = v7 / v5;
      ++v4;
    }
    while (v4 != v3);
  }
  return result;
}

uint64_t enlargeOutputBufferIfNeeded(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = *(_DWORD *)(a2 + 76);
  if (*(_DWORD *)(a2 + 84) + a3 <= v3) {
    return 1;
  }
  unsigned int v5 = v3 + a3 + (v3 >> 1);
  *(_DWORD *)(a2 + 76) = v5;
  uint64_t result = heap_Realloc(*(uint64_t **)(a1 + 8), *(void *)(a2 + 8), 2 * *(unsigned int *)(a2 + 64) * (unint64_t)v5);
  *(void *)(a2 + 8) = result;
  if (result) {
    return 1;
  }
  return result;
}

uint64_t moveNewSamplesToPitchBuffer(uint64_t a1, uint64_t a2, int a3)
{
  int v5 = *(_DWORD *)(a2 + 88);
  int v6 = *(_DWORD *)(a2 + 84) - a3;
  int v7 = *(_DWORD *)(a2 + 64);
  int v8 = *(_DWORD *)(a2 + 72);
  if (v5 + v6 <= v8)
  {
    uint64_t result = *(void *)(a2 + 16);
  }
  else
  {
    int v9 = v8 + v6 + (v8 >> 1);
    *(_DWORD *)(a2 + 72) = v9;
    uint64_t result = heap_Realloc(*(uint64_t **)(a1 + 8), *(void *)(a2 + 16), (2 * v7 * v9));
    *(void *)(a2 + 16) = result;
    if (!result) {
      return result;
    }
    int v5 = *(_DWORD *)(a2 + 88);
  }
  cstdlib_memcpy((void *)(result + 2 * v5 * v7), (const void *)(*(void *)(a2 + 8) + 2 * v7 * a3), (2 * v6 * v7));
  int v11 = *(_DWORD *)(a2 + 88) + v6;
  *(_DWORD *)(a2 + 84) = a3;
  *(_DWORD *)(a2 + 88) = v11;
  return 1;
}

void **removePitchSamples(void **result, int a2)
{
  if (a2)
  {
    int v3 = result;
    int v4 = a2;
    int v5 = *((_DWORD *)result + 22) - a2;
    if (v5)
    {
      uint64_t result = (void **)cstdlib_memmove(result[2], (char *)result[2] + 2 * *((_DWORD *)result + 16) * a2, (2 * *((_DWORD *)result + 16) * v5));
      int v4 = *((_DWORD *)v3 + 22);
    }
    *((_DWORD *)v3 + 22) = v4 - a2;
  }
  return result;
}

uint64_t siren_log_Diag(uint64_t a1, uint64_t a2)
{
  return log_VOutText(*(void *)(a1 + 32), (uint64_t)"SELECT_BET6", 3, 0, a2);
}

uint64_t siren_log_Trace(uint64_t a1, uint64_t a2)
{
  return log_VOutText(*(void *)(a1 + 32), (uint64_t)"SELECT_BET6", 5, 0, a2);
}

uint64_t siren_log_Error(uint64_t a1, uint64_t a2)
{
  return log_VOutText(*(void *)(a1 + 32), (uint64_t)"SELECT_BET6", 0, 0, a2);
}

uint64_t siren_compute_stream_hash(char *a1, unsigned int a2, char *a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  unsigned int v7 = 32;
  cstdlib_memset(__b, 0, 0x10uLL);
  MD5Init(v10);
  MD5Update((uint64_t)v10, a1, a2);
  MD5Final((uint64_t)__b, (unsigned int *)v10);
  if (base64_encode((uint64_t)__b, 0x10u, (uint64_t)__src, &v7)) {
    __src[0] = 0;
  }
  else {
    __src[v7] = 0;
  }
  cstdlib_strcpy(a3, __src);
  return 0;
}

uint64_t siren_pipeline_Init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  int v8 = (void *)heap_Calloc(*(void **)(a1 + 8), 1, 112);
  if (!v8)
  {
    int v12 = 10;
LABEL_13:
    uint64_t v9 = 0;
    uint64_t result = v12 | 0x84E02000;
    goto LABEL_14;
  }
  uint64_t v9 = (uint64_t)v8;
  *int v8 = a1;
  v8[12] = a2;
  uint64_t v10 = heap_Calloc(*(void **)(a1 + 8), 1, 144);
  *(void *)(v9 + 16) = v10;
  if (!v10)
  {
    int v12 = 10;
    goto LABEL_12;
  }
  *(void *)uint64_t v10 = a1;
  *(void *)(v10 + 96) = 0;
  *(_DWORD *)(v10 + 104) = 0;
  *(void *)(v9 + 8) = a3;
  *(_DWORD *)(v10 + 116) = 0;
  *(_DWORD *)(v9 + 52) = 0;
  *(_DWORD *)(v9 + 56) = 0;
  *(void *)(v10 + 124) = *(void *)(a3 + 9136);
  *(_DWORD *)(v10 + 132) = *(_DWORD *)(a3 + 9144);
  *(_DWORD *)(v9 + 44) = 0;
  *(_DWORD *)(v9 + 104) = 0;
  *(_DWORD *)(v9 + 108) = *(unsigned __int8 *)(a3 + 7399);
  if (*(_DWORD *)(a3 + 9116) || *(_DWORD *)(a3 + 9120) || *(_DWORD *)(a3 + 9128))
  {
    int v11 = feat_phone_Init(a3, v10);
  }
  else
  {
    int v12 = feat_phone_Init(a3, v10);
    if (v12) {
      goto LABEL_12;
    }
    int v12 = infer_dur_init(*(uint64_t **)(v9 + 16), *(void *)(a3 + 8024));
    if (v12) {
      goto LABEL_12;
    }
    int v11 = feat_frame_Init(a3 + 7992, a3 + 8008, *(void *)(v9 + 16));
  }
  int v12 = v11;
  if (v11 || (result = infer_acoustic_init(*(uint64_t **)(v9 + 16), *(void *)(a3 + 8040)), (int v12 = result) != 0))
  {
LABEL_12:
    siren_pipeline_DeInit(v9);
    goto LABEL_13;
  }
LABEL_14:
  *a4 = v9;
  return result;
}

uint64_t siren_pipeline_DeInit(uint64_t __b)
{
  if (__b)
  {
    uint64_t v2 = *(void *)__b;
    int v3 = *(uint64_t **)(__b + 16);
    if (v3)
    {
      if (v3[4]) {
        feat_phone_Close(*(uint64_t **)(__b + 16));
      }
      if (v3[5]) {
        feat_frame_Close(v3);
      }
      if (v3[6]) {
        infer_dur_end(v3);
      }
      if (v3[7]) {
        infer_acoustic_end(v3);
      }
      uint64_t v4 = v3[12];
      if (v4) {
        heap_Free(*(void **)(v2 + 8), v4);
      }
      cstdlib_memset(v3, 0, 0x90uLL);
      heap_Free(*(void **)(v2 + 8), (uint64_t)v3);
    }
    cstdlib_memset((void *)__b, 0, 0x70uLL);
    heap_Free(*(void **)(v2 + 8), __b);
  }
  return 0;
}

uint64_t siren_pipeline_ProcessStart(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = *(void *)(a1 + 16);
  int v14 = *(_DWORD *)(a1 + 52);
  if (v14 == 6 || v14 == 1)
  {
    *(_DWORD *)(a1 + 52) = 0;
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"SELECT_BET6", 72001, (uint64_t)"%s%s", (uint64_t)a5, a6, a7, a8, "warning");
    int v14 = *(_DWORD *)(a1 + 52);
  }
  if (v14) {
    return 2229280785;
  }
  *(void *)(v13 + 8) = a2;
  *(void *)(v13 + 16) = a3;
  *(_DWORD *)(v13 + 24) = a4;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 48) = xmmword_220785F50;
  *a5 = 1;
  if (!*(_DWORD *)(*(void *)(a1 + 16) + 116)) {
    return 0;
  }
  int v17 = chunking_Init((uint64_t *)v13, *(void *)(a1 + 8));
  if (v17) {
    return v17 | 0x84E02000;
  }
  else {
    return 0;
  }
}

uint64_t siren_pipeline_Process(uint64_t a1, int *a2, int *a3, int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = a2;
  int v12 = *(int32x2_t **)(a1 + 8);
  __int32 v13 = v12[1140].i32[0];
  if (v12[1146].i32[0] < 2u)
  {
    if (v13 || v12[1141].i32[0]) {
      goto LABEL_24;
    }
    if (v12[1139].i32[1])
    {
LABEL_32:
      return siren_pipeline_Process_seq2seq_ST(a1, a2, a3, a4);
    }
    uint64_t v35 = *(void *)(a1 + 16);
    __int32 v36 = v12[1144].i32[0];
    __int32 v37 = v12[1144].i32[1];
    int v38 = *(_DWORD *)(a1 + 52);
    if (v38 != 4 && v38 != 1)
    {
      int v45 = 17;
      goto LABEL_53;
    }
    if (*(_DWORD *)(a1 + 56))
    {
      __int32 v39 = v12[1144].i32[1];
      int v45 = feat_phone_Process(*(void *)(a1 + 16));
      if (v45) {
        goto LABEL_53;
      }
      int v46 = *(uint64_t **)(a1 + 96);
      if (v46 && *v46) {
        compstats_Start(*v46, v46[1], 3, v40, v41, v42, v43, v44);
      }
      int v45 = infer_dur_process((uint64_t)v12, (uint64_t *)v35);
      uint64_t v52 = *(uint64_t **)(a1 + 96);
      if (v52 && *v52) {
        compstats_Stop(*v52, v52[1], 3, v47, v48, v49, v50, v51);
      }
      if (v45) {
        goto LABEL_53;
      }
      siren_pipeline_loc_ForceFESilDur(a1);
      int v45 = feat_frame_Process(v35);
      if (v45) {
        goto LABEL_53;
      }
      if (*(_DWORD *)(v35 + 116))
      {
        int v45 = chunking_Process(v12, v35, 0, 0);
        if (v45) {
          goto LABEL_53;
        }
        __int32 v37 = v39;
        unsigned int v53 = *(_DWORD *)(*(void *)(v35 + 48) + 24)
            + (2 * *(unsigned __int16 *)(*(void *)(v35 + 72) + 24) - 2) * v39;
      }
      else
      {
        unsigned int v53 = *(_DWORD *)(*(void *)(v35 + 48) + 24);
        __int32 v37 = v39;
      }
      uint64_t v55 = heap_Calloc(*(void **)(*(void *)a1 + 8), v53, 4 * v12[1150].u32[1]);
      *(void *)(a1 + 80) = v55;
      if (!v55)
      {
        int v45 = 10;
        goto LABEL_53;
      }
      *(_DWORD *)(a1 + 56) = 0;
    }
    int v56 = *(uint64_t **)(a1 + 96);
    if (v56 && *v56) {
      compstats_Start(*v56, v56[1], 4, (uint64_t)a4, a5, a6, a7, a8);
    }
    if (*(_DWORD *)(v35 + 116))
    {
      uint64_t v57 = *(unsigned int *)(a1 + 60);
      uint64_t v58 = *(void *)(*(void *)(v35 + 72) + 16);
      if (v57) {
        int v59 = *(_DWORD *)(v58 + 4 * (v57 - 1)) + 1;
      }
      else {
        int v59 = 0;
      }
      int v68 = *(_DWORD *)(v58 + 4 * v57);
      if (v68 < v59)
      {
        int v45 = 7;
        goto LABEL_53;
      }
      int v69 = (v59 - v36) & ~((v59 - v36) >> 31);
      int v70 = v68 + v36;
      if (v68 + v36 >= *(_DWORD *)(*(void *)(v35 + 48) + 24)) {
        int v70 = v68;
      }
      int v107 = v70;
      __int32 v108 = v37;
      unsigned int v71 = v70 - v69 + 1;
      int v45 = infer_acoustic_process_range(v35, (v59 - v36) & ~((v59 - v36) >> 31), v71);
      if (v45) {
        goto LABEL_53;
      }
      uint64_t v72 = *(char **)(*(void *)(v35 + 56) + 24);
      if (v36 | v108)
      {
        __int32 v73 = v36 - v108;
        if (v69 != v59)
        {
          v72 += 4 * (v12[1150].i32[1] * v73);
          v71 -= v73;
        }
        if (v107 == v68) {
          __int32 v73 = 0;
        }
        v71 -= v73;
      }
      cstdlib_memcpy((void *)(*(void *)(a1 + 80) + 4 * (v12[1150].i32[1] * *(_DWORD *)(a1 + 28))), v72, 4 * v12[1150].i32[1] * v71);
      if (*(_WORD *)(*(void *)(v35 + 8) + 10))
      {
        uint64_t v74 = 0;
        unsigned int v75 = 0;
        do
        {
          int v76 = v74 + 1;
          if (v74 + 1 >= (unint64_t)*(unsigned __int16 *)(*(void *)(v35 + 8) + 10)) {
            break;
          }
          v75 += *(_DWORD *)(*(void *)(*(void *)(v35 + 48) + 56) + 4 * v74++);
        }
        while (v75 <= v68);
      }
      else
      {
        int v76 = 0;
      }
      unsigned int v77 = *(_DWORD *)(a1 + 28) + v71;
      *(_DWORD *)(a1 + 24) = v76;
      *(_DWORD *)(a1 + 28) = v77;
      int v78 = *(_DWORD *)(a1 + 60) + 1;
      *(_DWORD *)(a1 + 60) = v78;
      if (v78 == *(unsigned __int16 *)(*(void *)(v35 + 72) + 24)) {
        int v67 = 5;
      }
      else {
        int v67 = 4;
      }
LABEL_87:
      *(_DWORD *)(a1 + 52) = v67;
      int v79 = *(uint64_t **)(a1 + 96);
      if (v79 && *v79)
      {
        compstats_Stop(*v79, v79[1], 4, v62, v63, v64, v65, v66);
        int v67 = *(_DWORD *)(a1 + 52);
      }
      uint64_t result = 0;
      goto LABEL_122;
    }
    int v45 = infer_acoustic_process_range(v35, 0, *(unsigned int *)(*(void *)(v35 + 48) + 24));
    if (!v45)
    {
      uint64_t v60 = *(void *)(v35 + 56);
      int v61 = *(_DWORD *)(*(void *)(v35 + 48) + 24);
      *(_DWORD *)(a1 + 24) = *(unsigned __int16 *)(*(void *)(v35 + 8) + 10);
      *(_DWORD *)(a1 + 28) = v61;
      cstdlib_memcpy(*(void **)(a1 + 80), *(const void **)(v60 + 24), 4 * (v12[1150].i32[1] * v61));
      int v67 = 5;
      goto LABEL_87;
    }
LABEL_53:
    *(_DWORD *)(a1 + 52) = 6;
    *a4 = 6;
    return v45 | 0x84E02000;
  }
  if (!v13 && !v12[1141].i32[0])
  {
    if (!v12[1139].i32[1])
    {
      int v14 = *(uint64_t **)(a1 + 16);
      __int32 v15 = v12[1144].i32[0];
      __int32 v16 = v12[1144].i32[1];
      int v17 = *(_DWORD *)(a1 + 52);
      if (v17 != 4 && v17 != 1)
      {
        int v23 = 17;
        goto LABEL_51;
      }
      if (*(_DWORD *)(a1 + 56))
      {
        int v23 = feat_phone_Process(*(void *)(a1 + 16));
        if (v23) {
          goto LABEL_51;
        }
        uint64_t v24 = *(uint64_t **)(a1 + 96);
        if (v24 && *v24) {
          compstats_Start(*v24, v24[1], 3, v18, v19, v20, v21, v22);
        }
        int v23 = infer_dur_process((uint64_t)v12, v14);
        uint64_t v30 = *(uint64_t **)(a1 + 96);
        if (v30 && *v30) {
          compstats_Stop(*v30, v30[1], 3, v25, v26, v27, v28, v29);
        }
        if (v23) {
          goto LABEL_51;
        }
        siren_pipeline_loc_ForceFESilDur(a1);
        int v23 = feat_frame_Process((uint64_t)v14);
        if (v23) {
          goto LABEL_51;
        }
        uint64_t v31 = *(void *)(a1 + 16);
        if (v10 && a3)
        {
          if (*(_DWORD *)(a1 + 52) == 6 || (uint64_t v32 = *(void *)(v31 + 48)) == 0) {
            uint64_t v33 = 0;
          }
          else {
            uint64_t v33 = *(void *)(v32 + 56);
          }
          unsigned int v54 = *a3;
          if (*a3)
          {
            unsigned int v54 = 0;
            unsigned int v80 = 0;
            int v81 = 0;
            unsigned int v82 = 0;
            __int16 v83 = v10 + 4;
            do
            {
              int v84 = *(v83 - 4);
              *(v83 - 1) = v81;
              if (v84 == 33)
              {
                *__int16 v83 = *(_DWORD *)(v33 + 4 * v80++);
                v81 += *(_DWORD *)(v33 + 4 * v80);
              }
              else
              {
                *__int16 v83 = 0;
                if (v84 == 18) {
                  ++v54;
                }
              }
              ++v82;
              v83 += 8;
            }
            while (v82 < *a3);
          }
          *(_DWORD *)(v31 + 104) = v54;
        }
        else
        {
          unsigned int v54 = *(_DWORD *)(v31 + 104);
        }
        if (a3 && v10 && v54)
        {
          uint64_t v85 = heap_Calloc(*(void **)(*(void *)a1 + 8), v54, 4);
          *(void *)(v31 + 96) = v85;
          if (!v85)
          {
            int v23 = -2065686518;
            goto LABEL_51;
          }
          unsigned int v86 = *a3;
          if (*a3)
          {
            unsigned int v87 = 0;
            unsigned int v88 = 0;
            do
            {
              if (*v10 == 18)
              {
                *(_DWORD *)(v85 + 4 * v87++) = v10[3];
                unsigned int v86 = *a3;
              }
              v10 += 8;
              ++v88;
            }
            while (v88 < v86);
          }
        }
        int v23 = chunking_Process(v12, (uint64_t)v14, 0, 0);
        if (v23)
        {
LABEL_51:
          *(_DWORD *)(a1 + 52) = 6;
          *a4 = 6;
          return v23 | 0x84E02000;
        }
        uint64_t v89 = heap_Calloc(*(void **)(*(void *)a1 + 8), *(_DWORD *)(v14[6] + 24) + (2 * *(unsigned __int16 *)(v14[9] + 24) - 2) * v16, 4 * v12[1150].u32[1]);
        *(void *)(a1 + 80) = v89;
        calc_Max_Frame_Len(*(void *)(a1 + 16));
        if (!v89)
        {
          int v23 = 10;
          goto LABEL_51;
        }
        *(_DWORD *)(a1 + 56) = 0;
      }
      unsigned int v90 = *(uint64_t **)(a1 + 96);
      if (v90 && *v90) {
        compstats_Start(*v90, v90[1], 4, (uint64_t)a4, a5, a6, a7, a8);
      }
      uint64_t v91 = *(unsigned int *)(a1 + 104);
      uint64_t v92 = v14[10];
      if (v91 == *(_DWORD *)v92)
      {
        uint64_t result = 0;
        int v67 = 5;
        *(_DWORD *)(a1 + 52) = 5;
LABEL_122:
        *a4 = v67;
        return result;
      }
      if (*(_DWORD *)(a1 + 28) > *(_DWORD *)(*(void *)(v92 + 16) + 4 * v91))
      {
LABEL_118:
        uint64_t v93 = *(uint64_t **)(a1 + 96);
        if (v93)
        {
          if (*v93) {
            compstats_Stop(*v93, v93[1], 4, (uint64_t)a4, a5, a6, a7, a8);
          }
        }
        uint64_t result = 0;
        int v67 = *(_DWORD *)(a1 + 52);
        goto LABEL_122;
      }
      uint64_t v94 = *(unsigned int *)(a1 + 60);
      uint64_t v95 = *(void *)(v14[9] + 16);
      if (v94) {
        int v96 = *(_DWORD *)(v95 + 4 * (v94 - 1)) + 1;
      }
      else {
        int v96 = 0;
      }
      int v97 = *(_DWORD *)(v95 + 4 * v94);
      if (v97 >= v96)
      {
        int v98 = (v96 - v15) & ~((v96 - v15) >> 31);
        int v99 = v97 + v15;
        int v109 = *(_DWORD *)(v14[6] + 24);
        if (v97 + v15 < v109) {
          v97 += v15;
        }
        unsigned int v100 = v97 - v98 + 1;
        int v23 = infer_acoustic_process_range((uint64_t)v14, (v96 - v15) & ~((v96 - v15) >> 31), v100);
        if (!v23)
        {
          uint64_t v101 = *(char **)(v14[7] + 24);
          if (v15)
          {
            if (v98 != v96)
            {
              v101 += 4 * (v12[1150].i32[1] * v15);
              v100 -= v15;
            }
            if (v99 >= v109) {
              __int32 v102 = 0;
            }
            else {
              __int32 v102 = v15;
            }
            v100 -= v102;
          }
          cstdlib_memcpy((void *)(*(void *)(a1 + 80) + 4 * (v12[1150].i32[1] * *(_DWORD *)(a1 + 28))), v101, 4 * v12[1150].i32[1] * v100);
          uint64_t v103 = *(unsigned __int16 *)(v14[1] + 10);
          if (*(_WORD *)(v14[1] + 10))
          {
            uint64_t v104 = 0;
            unsigned int v105 = 0;
            while (v105 <= *(_DWORD *)(*(void *)(v14[10] + 16) + 4 * *(unsigned int *)(a1 + 104)))
            {
              v105 += *(_DWORD *)(*(void *)(v14[6] + 56) + 4 * v104++);
              if (v103 == v104) {
                goto LABEL_146;
              }
            }
            LODWORD(v103) = v104;
          }
LABEL_146:
          unsigned int v106 = *(_DWORD *)(a1 + 28) + v100;
          *(_DWORD *)(a1 + 24) = v103;
          *(_DWORD *)(a1 + 28) = v106;
          ++*(_DWORD *)(a1 + 60);
          *(_DWORD *)(a1 + 52) = 4;
          goto LABEL_118;
        }
      }
      else
      {
        int v23 = 7;
      }
      goto LABEL_51;
    }
    goto LABEL_32;
  }
LABEL_24:
  if (v12[1141].i32[1])
  {
    return siren_pipeline_Process_seq2seq_stream_ST(a1, a2, a3, a4);
  }
  else
  {
    return siren_pipeline_Process_seq2seq_frame_ST(a1, a2, a3, a4);
  }
}

uint64_t siren_pipeline_Process_seq2seq_stream_ST(uint64_t a1, int *a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v123 = *MEMORY[0x263EF8340];
  int v6 = *(_DWORD *)(a1 + 52);
  if (v6 == 6
    || (uint64_t v7 = *(void *)(a1 + 8),
        uint64_t v8 = *(void *)(a1 + 16),
        unsigned int v9 = *(unsigned __int16 *)(*(void *)(v8 + 8) + 10),
        __src = 0,
        (v6 - 5) < 0xFFFFFFFC))
  {
    int updated = 17;
LABEL_4:
    *(_DWORD *)(a1 + 52) = 6;
    *a4 = 6;
    return updated | 0x84E02000;
  }
  if (!*(_DWORD *)(a1 + 56)) {
    goto LABEL_31;
  }
  int updated = feat_phone_Process(v8);
  if (updated) {
    goto LABEL_4;
  }
  *(_DWORD *)(a1 + 44) = 0;
  paramc_ParamGetStr(*(void *)(*(void *)a1 + 40), (uint64_t)"styleset", &__src);
  if (__src)
  {
    cstdlib_strcpy(__dst, __src);
    unint64_t v14 = *a3;
    if (v14)
    {
      unint64_t v15 = 0;
      unsigned int v16 = a2[3];
      int v17 = a2;
      do
      {
        if (v17[3] > v16) {
          break;
        }
        if (*v17 == 60)
        {
          seq2seq_select_speaker(a1, (uint64_t)v17, __src, __dst);
          unint64_t v14 = *a3;
        }
        ++v15;
        v17 += 8;
      }
      while (v15 < v14);
    }
  }
  if (*(_DWORD *)(v8 + 116))
  {
LABEL_15:
    int updated = chunking_Process((int32x2_t *)v7, v8, (uint64_t)a2, a3);
    if (!updated)
    {
      int updated = chunking_markers(*(void *)a1, v8, a2, a3);
      if (!updated) {
        goto LABEL_27;
      }
    }
    goto LABEL_4;
  }
  unint64_t v18 = *a3;
  if (!v18) {
    goto LABEL_27;
  }
  unint64_t v19 = 0;
  uint64_t v20 = a2;
  uint64_t v21 = a2;
  while (1)
  {
    int v22 = *v21;
    v21 += 8;
    if (v22 == 21) {
      break;
    }
LABEL_23:
    ++v19;
    uint64_t v20 = v21;
    if (v19 >= v18) {
      goto LABEL_26;
    }
  }
  if (cstdlib_strcmp(*((const char **)v20 + 3), "spell"))
  {
    unint64_t v18 = *a3;
    goto LABEL_23;
  }
  *(_DWORD *)(v8 + 116) = 1;
  chunking_Init((uint64_t *)v8, *(void *)(a1 + 8));
LABEL_26:
  if (*(_DWORD *)(v8 + 116)) {
    goto LABEL_15;
  }
LABEL_27:
  if (*(_DWORD *)(v8 + 120)) {
    *(_DWORD *)(a1 + 48) = (float)(*(float *)(*(void *)(a1 + 8) + 9176)
  }
                                               * (float)*(unsigned int *)(*(void *)(a1 + 8) + 9180))
                         / 0xA;
  uint64_t v23 = heap_Alloc(*(void *)(*(void *)a1 + 8), 4 * *(_DWORD *)(v7 + 9136) * v9 * *(_DWORD *)(v7 + 9204));
  *(void *)(a1 + 80) = v23;
  if (!v23)
  {
    int updated = 10;
    goto LABEL_4;
  }
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(v7 + 9136) * v9;
  *(_DWORD *)(a1 + 56) = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(void *)(a1 + 16);
LABEL_31:
  uint64_t v24 = *(void *)(v8 + 72);
  uint64_t v25 = *(void *)(v8 + 88);
  if (*(_DWORD *)(v8 + 116))
  {
    uint64_t v26 = *(void *)(v8 + 64);
    uint64_t v27 = *(unsigned int *)(a1 + 60);
    int v28 = *(unsigned __int16 *)(v26 + 48) - 1;
    BOOL v29 = v27 == v28;
    uint64_t v30 = *(_DWORD **)(v26 + 16);
    if (v27)
    {
      int v31 = v30[(v27 - 1)];
      unsigned int v32 = v31 + 1;
      int v33 = v30[v27] - (v27 == v28);
      if (v33 == v31) {
        unsigned int v34 = v31 + 1;
      }
      else {
        unsigned int v34 = v33;
      }
      if (v34 < v32)
      {
        int updated = 7;
        goto LABEL_86;
      }
      uint64_t v36 = *(void *)(v25 + 8);
      int v117 = *(_DWORD *)(v36 + 4 * (v27 - 1)) + 1;
    }
    else
    {
      int v117 = 0;
      unsigned int v32 = 0;
      if ((__PAIR64__(*v30, v28) - 1) >> 32 == -1) {
        unsigned int v34 = 0;
      }
      else {
        unsigned int v34 = (__PAIR64__(*v30, v28) - 1) >> 32;
      }
      uint64_t v36 = *(void *)(v25 + 8);
      uint64_t v27 = 0;
    }
    int v115 = *(_DWORD *)(v36 + 4 * v27);
    int v35 = v34 - v32 + 1;
  }
  else
  {
    int v117 = 0;
    if (v9 <= 2) {
      int v35 = 1;
    }
    else {
      int v35 = v9 - 2;
    }
    int v115 = *a3 - 1;
    unsigned int v32 = 1;
    unsigned int v34 = v35;
    BOOL v29 = 1;
  }
  uint64_t v119 = *(void *)(v8 + 72);
  if ((*(_DWORD *)(a1 + 52) & 0xFFFFFFFE) != 2)
  {
    unsigned int v41 = v34;
    uint64_t v42 = heap_Alloc(*(void *)(*(void *)a1 + 8), 40);
    *(void *)(a1 + 72) = v42;
    if (!v42) {
      goto LABEL_85;
    }
    *(_DWORD *)(v42 + 8) = 200002;
    uint64_t v43 = heap_Alloc(*(void *)(*(void *)a1 + 8), 800008);
    **(void **)(a1 + 72) = v43;
    if (!v43) {
      goto LABEL_85;
    }
    uint64_t v44 = heap_Alloc(*(void *)(*(void *)a1 + 8), 4);
    uint64_t v45 = *(void *)(a1 + 72);
    *(void *)(v45 + 32) = v44;
    if (!v44) {
      goto LABEL_85;
    }
    *(_DWORD *)(v45 + 16) = *(_DWORD *)(a1 + 44);
    unsigned int v34 = v41;
    uint64_t v24 = v119;
    if (*(_DWORD *)(v8 + 120))
    {
      *(_DWORD *)(a1 + 64) = 0;
      *(_WORD *)(v119 + 24) = 0;
      uint64_t v111 = (unsigned __int16)((*(_DWORD *)(v8 + 124) * v35) / *(_DWORD *)(a1 + 48) + 10);
      uint64_t v46 = heap_Calloc(*(void **)(*(void *)a1 + 8), v111, 4);
      *(void *)(v119 + 16) = v46;
      if (!v46
        || (uint64_t v47 = heap_Calloc(*(void **)(*(void *)a1 + 8), v111, 4),
            uint64_t v24 = v119,
            *(void *)(v25 + 16) = v47,
            unsigned int v34 = v41,
            !v47))
      {
LABEL_85:
        int updated = 10;
        goto LABEL_86;
      }
    }
  }
  int v37 = *(_DWORD *)(v8 + 120);
  unsigned int v113 = v34;
  BOOL v114 = v29;
  if (!v37)
  {
    unsigned int v39 = 0;
    uint64_t v48 = (unsigned int ***)(a1 + 72);
    *(_DWORD *)(*(void *)(a1 + 72) + 20) = 0;
    goto LABEL_66;
  }
  int v38 = *(_DWORD *)(a1 + 64);
  if (v38 == 1)
  {
    unsigned int v39 = **(_DWORD **)(v24 + 16) + 1;
    float v49 = (float)v39 + (float)((float)v39 * *(float *)(v7 + 9160));
LABEL_63:
    unsigned int v40 = (float)(v49 + -1.0);
    goto LABEL_64;
  }
  if (v38)
  {
    uint64_t v50 = *(void *)(v24 + 16);
    unsigned int v39 = *(_DWORD *)(v50 + 4 * (v38 - 1)) + 1;
    float v49 = (float)v39 + (float)((float)(v39 - *(_DWORD *)(v50 + 4 * (v38 - 2))) * *(float *)(v7 + 9160));
    goto LABEL_63;
  }
  unsigned int v39 = 0;
  unsigned int v40 = *(_DWORD *)(a1 + 48);
LABEL_64:
  uint64_t v48 = (unsigned int ***)(a1 + 72);
  uint64_t v51 = *(void *)(a1 + 72);
  *(_DWORD *)(v51 + 20) = v37 == 1;
  if (v37 == 1)
  {
    *(_DWORD *)(v51 + 24) = v38 == 0;
    **(_DWORD **)(v51 + 32) = 0;
    *(_DWORD *)(v51 + 28) = v40 - v39 + 1;
  }
LABEL_66:
  int updated = fi_net_update_param(**(void **)(v8 + 56));
  if (updated) {
    goto LABEL_86;
  }
  int updated = infer_acoustic_seq2seq_process_range_stream((uint64_t *)v8, v32, v35);
  if (updated) {
    goto LABEL_86;
  }
  unsigned int v52 = *(_DWORD *)(*(void *)(v8 + 56) + 40) >> 2;
  unsigned int v112 = *(_DWORD *)(v7 + 9204);
  unsigned int v53 = v52 / v112;
  unsigned int v54 = v52 / v112 + v39;
  unsigned int v55 = v54 - 1;
  unsigned int v56 = ***v48;
  if (*(_DWORD *)(v8 + 120))
  {
    uint64_t v57 = (int *)(*v48)[4];
    if (v56 > 0x9C3) {
      int v58 = 1;
    }
    else {
      int v58 = *v57;
    }
    *uint64_t v57 = v58;
    *(_DWORD *)(*(void *)(v119 + 16) + 4 * *(unsigned int *)(a1 + 64)) = v55;
    ++*(_WORD *)(v119 + 24);
    if (*(_DWORD *)(a1 + 64)) {
      v39 -= 2;
    }
    unsigned int v59 = v54 - 3;
    if (*v57 != 1) {
      unsigned int v55 = v59;
    }
  }
  int v60 = *(_DWORD *)(a1 + 28);
  int v61 = *(_DWORD *)(a1 + 40);
  unsigned int v110 = v56;
  if (v53 > v61 - v60)
  {
    do
      v61 *= 2;
    while (v53 > v61 - v60);
    *(_DWORD *)(a1 + 40) = v61;
  }
  uint64_t v62 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 80), 4 * (*(_DWORD *)(v7 + 9204) * v61));
  *(void *)(a1 + 80) = v62;
  if (!v62) {
    goto LABEL_85;
  }
  if (!v114)
  {
    uint64_t v64 = *v48;
    int v66 = *(*v48)[4];
    unsigned int v65 = v113;
    unsigned int v67 = v117;
    int v68 = v115;
    goto LABEL_91;
  }
  int v63 = *(_DWORD *)(v8 + 120);
  uint64_t v64 = *v48;
  unsigned int v65 = v113;
  if (v63)
  {
    int v66 = *v64[4];
    unsigned int v67 = v117;
    int v68 = v115;
    if (v66 == 1)
    {
      int v63 = 0;
      BOOL v69 = 1;
      goto LABEL_93;
    }
LABEL_91:
    BOOL v69 = v66 == 1;
    int v63 = 1;
  }
  else
  {
    BOOL v69 = 1;
    unsigned int v67 = v117;
    int v68 = v115;
  }
LABEL_93:
  uint64_t v70 = v67;
  uint64_t v71 = (uint64_t)&a2[8 * v67];
  unint64_t v72 = v68 - v67 + 1;
  uint64_t v74 = *(void *)(a1 + 8);
  uint64_t v73 = *(void *)(a1 + 16);
  uint64_t v116 = *(void *)(v73 + 88);
  uint64_t v118 = v73;
  if (*(_DWORD *)(v73 + 120) && (int v75 = *(_DWORD *)(a1 + 64)) != 0)
  {
    int v76 = *(_DWORD *)(*(void *)(*(void *)(v73 + 88) + 16) + 4 * (v75 - 1));
    int v77 = *(_DWORD *)(v74 + 9188);
    uint64_t v78 = (v76 + 1);
    if (v76 == -1)
    {
      LODWORD(v78) = 0;
      unsigned int v79 = 0;
    }
    else
    {
      unsigned int v79 = 0;
      unsigned int v80 = (int *)v71;
      uint64_t v81 = v78;
      do
      {
        int v82 = *v80;
        v80 += 8;
        if (v82 == 33) {
          ++v79;
        }
        --v81;
      }
      while (v81);
    }
  }
  else
  {
    LODWORD(v78) = 0;
    unsigned int v79 = 0;
    int v77 = *(_DWORD *)(v74 + 9188);
  }
  unsigned int v120 = v52;
  int v107 = *(_DWORD *)(v7 + 9188);
  int v108 = *(_DWORD *)(a1 + 32);
  uint64_t v83 = v78;
  uint64_t v109 = v70;
  if (v78 >= v72)
  {
    LODWORD(v87) = v78;
  }
  else
  {
    uint64_t v84 = 0;
    uint64_t v85 = (uint64_t)(*v64 + 1);
    uint64_t v86 = (uint64_t)&a2[8 * v70 + 3 + 8 * v78];
    unint64_t v87 = v78;
    do
    {
      int v88 = v39 * v77;
      if (*(_DWORD *)(v71 + 32 * v87) == 33)
      {
        ++v79;
        unint64_t v89 = v71 + 32 * v87;
        *(_DWORD *)(v89 + 12) = v88;
        unsigned int v90 = (_DWORD *)(v89 + 12);
        v90[1] = 0;
        if (v39 <= v55)
        {
          int v91 = 0;
          do
          {
            if (*(_DWORD *)(v85 + 4 * v39) > v79) {
              break;
            }
            v91 += v77;
            v90[1] = v91;
            ++v39;
          }
          while (v39 <= v55);
        }
        else
        {
          int v91 = 0;
        }
        if (v87 > v78 && *(_DWORD *)(v71 + 32 * v87 + 24) == 35)
        {
          uint64_t v93 = (_DWORD *)v86;
          uint64_t v94 = v84;
          do
          {
            unsigned int v95 = *(v93 - 3);
            BOOL v99 = v95 > 0x28;
            uint64_t v96 = (1 << v95) & 0x10004000100;
            BOOL v97 = v99 || v96 == 0;
            if (!v97 && *v93 == *v90) {
              *v93 += v91;
            }
            v93 += 8;
            --v94;
          }
          while (v94);
        }
      }
      else
      {
        unint64_t v92 = v71 + 32 * v87;
        *(_DWORD *)(v92 + 12) = v88;
        *(_DWORD *)(v92 + 16) = 0;
      }
      if (v39 > v55) {
        int v98 = v63;
      }
      else {
        int v98 = 0;
      }
      ++v87;
      BOOL v99 = !v69 || v79 > v65;
      if (!v99) {
        int v98 = 0;
      }
      if (v87 >= v72) {
        break;
      }
      ++v84;
    }
    while (!v98);
  }
  int v100 = v78;
  bubble_sort_markers(v71, v78, v87);
  if (v87 - 1 - v100 != -1)
  {
    int v101 = v87 - v100;
    __int32 v102 = &a2[8 * v83 + 3 + 8 * v109];
    do
    {
      *v102 += v108 + v107 * (v53 - v110);
      v102 += 8;
      --v101;
    }
    while (v101);
  }
  if (*(_DWORD *)(v118 + 120)) {
    *(_DWORD *)(*(void *)(v116 + 16) + 4 * *(unsigned int *)(a1 + 64)) = v87 - 1;
  }
  if (v112 <= v120)
  {
    cstdlib_memcpy((void *)(*(void *)(a1 + 80) + 4 * (*(_DWORD *)(v7 + 9204) * *(_DWORD *)(a1 + 28))), *(const void **)(*(void *)(v8 + 56) + 24), 4 * *(_DWORD *)(v7 + 9204) * v53);
    int v103 = *(_DWORD *)(a1 + 32) + *(_DWORD *)(v7 + 9188) * v53;
    *(_DWORD *)(a1 + 28) += v53;
    *(_DWORD *)(a1 + 32) = v103;
  }
  if (*(_DWORD *)(v8 + 120)
    && (int v104 = *(_DWORD *)(a1 + 64), *(_DWORD *)(a1 + 64) = v104 + 1, !**(_DWORD **)(*(void *)(a1 + 72) + 32)))
  {
    BOOL v105 = v104 == 0;
    int v106 = 2;
  }
  else
  {
    ++*(_DWORD *)(a1 + 60);
    BOOL v105 = !v114;
    int v106 = 4;
  }
  if (!v105) {
    ++v106;
  }
  int updated = 0;
  *(_DWORD *)(a1 + 52) = v106;
LABEL_86:
  if ((*(_DWORD *)(a1 + 52) & 0xFFFFFFFE) == 4) {
    seq2seq_stream_free_NNState((void *)a1);
  }
  if (updated) {
    goto LABEL_4;
  }
  uint64_t result = 0;
  *a4 = *(_DWORD *)(a1 + 52);
  return result;
}

uint64_t siren_pipeline_Process_seq2seq_frame_ST(uint64_t a1, int *a2, int *a3, int *a4)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  BOOL v69 = 1;
  __src = 0;
  int v6 = *(_DWORD *)(a1 + 52);
  if (v6 == 6 || (v6 - 1) > 3)
  {
    uint64_t v17 = 0;
    int v12 = 17;
LABEL_17:
    *a4 = v6;
    goto LABEL_18;
  }
  uint64_t v10 = *(int32x2_t **)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  int v11 = *(unsigned __int16 *)(*(void *)(v9 + 8) + 10);
  if (!*(_DWORD *)(a1 + 56)) {
    goto LABEL_38;
  }
  int v12 = feat_phone_Process(*(void *)(a1 + 16));
  if (v12) {
    goto LABEL_23;
  }
  *(_DWORD *)(a1 + 44) = 0;
  paramc_ParamGetStr(*(void *)(*(void *)a1 + 40), (uint64_t)"styleset", &__src);
  if (__src)
  {
    cstdlib_strcpy(__dst, __src);
    unint64_t v13 = *a3;
    if (v13)
    {
      unint64_t v14 = 0;
      unsigned int v15 = a2[3];
      unsigned int v16 = a2;
      do
      {
        if (v16[3] > v15) {
          break;
        }
        if (*v16 == 60)
        {
          seq2seq_select_speaker(a1, (uint64_t)v16, __src, __dst);
          unint64_t v13 = *a3;
        }
        ++v14;
        v16 += 8;
      }
      while (v14 < v13);
    }
  }
  if (*(_DWORD *)(v9 + 116))
  {
LABEL_13:
    int v12 = chunking_Process(v10, v9, (uint64_t)a2, a3);
    if (!v12)
    {
      int v12 = chunking_markers(*(void *)a1, v9, a2, a3);
      if (!v12) {
        goto LABEL_34;
      }
    }
    goto LABEL_23;
  }
  unint64_t v19 = *a3;
  if (!v19) {
    goto LABEL_34;
  }
  unint64_t v20 = 0;
  uint64_t v21 = a2;
  int v22 = a2;
  while (1)
  {
    int v23 = *v22;
    v22 += 8;
    if (v23 == 21) {
      break;
    }
LABEL_30:
    ++v20;
    uint64_t v21 = v22;
    if (v20 >= v19) {
      goto LABEL_33;
    }
  }
  if (cstdlib_strcmp(*((const char **)v21 + 3), "spell"))
  {
    unint64_t v19 = *a3;
    goto LABEL_30;
  }
  *(_DWORD *)(v9 + 116) = 1;
  chunking_Init((uint64_t *)v9, *(void *)(a1 + 8));
LABEL_33:
  if (*(_DWORD *)(v9 + 116)) {
    goto LABEL_13;
  }
LABEL_34:
  if (*(_DWORD *)(*(void *)(a1 + 16) + 120)) {
    *(_DWORD *)(a1 + 48) = (float)(*(float *)(*(void *)(a1 + 8) + 9176)
  }
                                               * (float)*(unsigned int *)(*(void *)(a1 + 8) + 9180))
                         / 0xA;
  uint64_t v24 = heap_Alloc(*(void *)(*(void *)a1 + 8), 4 * (v10[1142].i32[0] * v11 * v10[1150].i32[1]));
  *(void *)(a1 + 80) = v24;
  if (!v24) {
    goto LABEL_47;
  }
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = v10[1142].i32[0] * v11;
  *(_DWORD *)(a1 + 56) = 0;
LABEL_38:
  uint64_t v25 = heap_Calloc(*(void **)(*(void *)a1 + 8), 1, 16);
  if (!v25)
  {
LABEL_47:
    int v12 = 10;
    goto LABEL_23;
  }
  uint64_t v17 = v25;
  uint64_t v26 = heap_Alloc(*(void *)(*(void *)a1 + 8), 800008);
  if (!v26)
  {
LABEL_52:
    int v12 = 10;
    goto LABEL_19;
  }
  *(_DWORD *)(v17 + 8) = 200002;
  *(void *)uint64_t v17 = v26;
  fi_net_give_address(**(void **)(v9 + 56));
  if (!*(_DWORD *)(v9 + 116))
  {
    int v33 = *a3;
    BOOL v69 = 1;
    int v34 = infer_acoustic_seq2seq_process_range_FrameInfer(a1 + 44, (uint64_t *)v9, 1, v11 - 2);
    if (v34) {
      goto LABEL_67;
    }
    unsigned int v35 = *(_DWORD *)(*(void *)(v9 + 56) + 40);
    unsigned __int32 v36 = v10[1150].u32[1];
    int v34 = calc_Marker_Pos_seq2seq_notrim(a1, (uint64_t)v10, (uint64_t)a2, v33, **(_DWORD **)v17, *(_DWORD *)(*(void *)v17 + 4), *(void *)v17 + 8);
    if (v34) {
      goto LABEL_67;
    }
    unsigned int v37 = (v35 >> 2) / v36;
    *(_DWORD *)(a1 + 24) = *(unsigned __int16 *)(*(void *)(v9 + 8) + 10);
    if (v37 <= *(_DWORD *)(a1 + 40))
    {
      int v38 = *(void **)(a1 + 80);
    }
    else
    {
      *(_DWORD *)(a1 + 40) = v37;
      int v38 = (void *)heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 80), 4 * v10[1150].i32[1] * v37);
      *(void *)(a1 + 80) = v38;
      if (!v38) {
        goto LABEL_52;
      }
    }
    cstdlib_memcpy(v38, *(const void **)(*(void *)(v9 + 56) + 24), 4 * v10[1150].i32[1] * v37);
    int v12 = 0;
    *(_DWORD *)(a1 + 28) = v37;
    int v6 = 5;
    goto LABEL_85;
  }
  if ((*(_DWORD *)(a1 + 52) & 0xFFFFFFFE) == 2)
  {
    unsigned int v27 = 0;
    goto LABEL_43;
  }
  uint64_t v39 = *(unsigned int *)(a1 + 60);
  uint64_t v40 = *(void *)(v9 + 64);
  int v41 = *(unsigned __int16 *)(v40 + 48) - 1;
  BOOL v69 = v39 == v41;
  uint64_t v42 = *(void *)(v40 + 16);
  if (v39) {
    unsigned int v43 = *(_DWORD *)(v42 + 4 * (v39 - 1)) + 1;
  }
  else {
    unsigned int v43 = 0;
  }
  unsigned int v45 = *(_DWORD *)(v42 + 4 * v39) - (v39 == v41);
  uint64_t v46 = *(void *)(*(void *)(v9 + 88) + 8);
  if (v39) {
    unsigned int v47 = *(_DWORD *)(v46 + 4 * (v39 - 1)) + 1;
  }
  else {
    unsigned int v47 = 0;
  }
  int v48 = *(_DWORD *)(v46 + 4 * v39);
  if (v45 == v43 - 1) {
    goto LABEL_64;
  }
  if (v45 < v43)
  {
    int v12 = 7;
    goto LABEL_19;
  }
  if (v45 == v43)
  {
LABEL_64:
    unsigned int v45 = v43;
  }
  else
  {
    unsigned int v53 = *(uint64_t **)(v9 + 32);
    uint64_t v55 = *v53;
    uint64_t v54 = v53[1];
    int v56 = *(_DWORD *)(v55 + 12);
    if (*(float *)(v54 + 4 * (v56 * v43 + 1)) == 1.0)
    {
      ++v43;
      *(_WORD *)(*(void *)(v40 + 40) + 2 * v39) = 200;
    }
    if (*(float *)(v54 + 4 * (v56 * v45 + 1)) == 1.0)
    {
      --v45;
      *(_WORD *)(*(void *)(v40 + 32) + 2 * v39) = 200;
    }
  }
  int v34 = infer_acoustic_seq2seq_process_range_FrameInfer(a1 + 44, (uint64_t *)v9, v43, v45 - v43 + 1);
  if (!v34)
  {
    unsigned __int32 v66 = v10[1150].u32[1];
    unsigned int v67 = *(_DWORD *)(*(void *)(v9 + 56) + 40);
    uint64_t v49 = v47;
    int v50 = v48 - v47;
    uint64_t v51 = (uint64_t)&a2[8 * v47];
    unsigned int v52 = v50 + 1;
    int v34 = calc_Marker_Pos_seq2seq_notrim(a1, (uint64_t)v10, v51, v50 + 1, **(_DWORD **)v17, *(_DWORD *)(*(void *)v17 + 4), *(void *)v17 + 8);
    if (!v34)
    {
      uint64_t v65 = v51;
      unsigned int v27 = (v67 >> 2) / v66;
      int v60 = *(_DWORD *)(a1 + 28);
      int v61 = *(_DWORD *)(a1 + 40);
      if (v27 > v61 - v60)
      {
        do
          v61 *= 2;
        while (v27 > v61 - v60);
        *(_DWORD *)(a1 + 40) = v61;
      }
      uint64_t v62 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 80), 4 * (v10[1150].i32[1] * v61));
      *(void *)(a1 + 80) = v62;
      if (!v62)
      {
        int v12 = 10;
        goto LABEL_18;
      }
      if (*(_DWORD *)(v9 + 120))
      {
        *(_DWORD *)(a1 + 64) = 0;
        int v12 = chunking_frames(a1, *(void *)a1, (uint64_t)v10, v27, v9);
        if (v12
          || (int v12 = chunking_secondary_markers(*(void *)a1, (uint64_t)v10, v9, v65, v52, (unsigned int *)&v69)) != 0)
        {
LABEL_18:
          if (v17) {
            goto LABEL_19;
          }
          goto LABEL_22;
        }
      }
      if (v52)
      {
        int v63 = *(_DWORD *)(a1 + 32);
        uint64_t v64 = &a2[8 * v49 + 3];
        do
        {
          *v64 += v63;
          v64 += 8;
          --v52;
        }
        while (v52);
      }
LABEL_43:
      if (*(_DWORD *)(v9 + 120))
      {
        uint64_t v28 = *(unsigned int *)(a1 + 64);
        uint64_t v29 = *(void *)(v9 + 72);
        unsigned int v30 = *(unsigned __int16 *)(v29 + 24);
        if (v28 <= v30)
        {
          uint64_t v31 = *(void *)(v29 + 16);
          if (v28) {
            int v32 = *(_DWORD *)(v31 + 4 * (v28 - 1)) + 3;
          }
          else {
            int v32 = 0;
          }
          int v57 = *(_DWORD *)(v31 + 4 * v28) - v32;
          if (v28 == v30 - 1) {
            int v58 = v57 + 1;
          }
          else {
            int v58 = v57 + 3;
          }
          cstdlib_memcpy((void *)(*(void *)(a1 + 80) + 4 * (v10[1150].i32[1] * *(_DWORD *)(a1 + 28))), (const void *)(*(void *)(*(void *)(v9 + 56) + 24) + 4 * (v10[1150].i32[1] * v32)), 4 * (v10[1150].i32[1] * v58));
          LODWORD(v28) = *(_DWORD *)(a1 + 32) + v10[1148].i32[1] * v58;
          *(_DWORD *)(a1 + 28) += v58;
          *(_DWORD *)(a1 + 32) = v28;
          LODWORD(v28) = *(_DWORD *)(a1 + 64);
          unsigned int v30 = *(unsigned __int16 *)(*(void *)(v9 + 72) + 24);
        }
        *(_DWORD *)(a1 + 64) = v28 + 1;
        if ((int)v28 + 1 < v30)
        {
          if (v28) {
            int v6 = 3;
          }
          else {
            int v6 = 2;
          }
LABEL_84:
          int v12 = 0;
LABEL_85:
          *(_DWORD *)(a1 + 52) = v6;
          goto LABEL_17;
        }
      }
      else
      {
        cstdlib_memcpy((void *)(*(void *)(a1 + 80) + 4 * (v10[1150].i32[1] * *(_DWORD *)(a1 + 28))), *(const void **)(*(void *)(v9 + 56) + 24), 4 * v10[1150].i32[1] * v27);
        int v44 = *(_DWORD *)(a1 + 32) + v10[1148].i32[1] * v27;
        *(_DWORD *)(a1 + 28) += v27;
        *(_DWORD *)(a1 + 32) = v44;
      }
      int v59 = *(_DWORD *)(a1 + 60) + 1;
      *(_DWORD *)(a1 + 60) = v59;
      if (v59 == *(unsigned __int16 *)(*(void *)(v9 + 64) + 48)) {
        int v6 = 5;
      }
      else {
        int v6 = 4;
      }
      goto LABEL_84;
    }
  }
LABEL_67:
  int v12 = v34;
LABEL_19:
  if (*(void *)v17) {
    heap_Free(*(void **)(*(void *)a1 + 8), *(void *)v17);
  }
  heap_Free(*(void **)(*(void *)a1 + 8), v17);
LABEL_22:
  if (!v12) {
    return 0;
  }
LABEL_23:
  *(_DWORD *)(a1 + 52) = 6;
  *a4 = 6;
  return v12 | 0x84E02000;
}

uint64_t siren_pipeline_Process_seq2seq_ST(uint64_t a1, int *a2, int *a3, int *a4)
{
  BOOL v114 = 0;
  int v6 = *(_DWORD *)(a1 + 52);
  if (v6 == 6 || (v6 != 4 ? (BOOL v7 = v6 == 1) : (BOOL v7 = 1), !v7))
  {
    uint64_t v20 = 0;
    int v13 = 17;
    goto LABEL_27;
  }
  int v11 = *(int32x2_t **)(a1 + 8);
  uint64_t v10 = *(void *)(a1 + 16);
  int v12 = *(unsigned __int16 *)(*(void *)(v10 + 8) + 10);
  if (*(_DWORD *)(a1 + 56))
  {
    int v13 = feat_phone_Process(*(void *)(a1 + 16));
    if (v13) {
      goto LABEL_33;
    }
    *(_DWORD *)(a1 + 44) = 0;
    paramc_ParamGetStr(*(void *)(*(void *)a1 + 40), (uint64_t)"styleset", &v114);
    if (v114)
    {
      cstdlib_strcpy(0, v114);
      unint64_t v14 = *a3;
      if (v14)
      {
        unint64_t v15 = 0;
        unsigned int v16 = a2[3];
        uint64_t v17 = a2;
        do
        {
          if (v17[3] > v16) {
            break;
          }
          if (*v17 == 60)
          {
            seq2seq_select_speaker(a1, (uint64_t)v17, v114, 0);
            unint64_t v14 = *a3;
          }
          ++v15;
          v17 += 8;
        }
        while (v15 < v14);
      }
    }
    if (*(_DWORD *)(v10 + 116))
    {
      int v13 = chunking_Process(v11, v10, 0, 0);
      if (v13) {
        goto LABEL_33;
      }
      int v13 = chunking_markers(*(void *)a1, v10, a2, a3);
      if (v13) {
        goto LABEL_33;
      }
    }
    uint64_t v18 = heap_Alloc(*(void *)(*(void *)a1 + 8), 2 * (v11[1142].i32[0] * v12 * *(_DWORD *)(*(void *)(a1 + 8) + 9188)));
    *(void *)(a1 + 88) = v18;
    if (!v18) {
      goto LABEL_35;
    }
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 36) = v11[1142].i32[0] * v12 * *(_DWORD *)(*(void *)(a1 + 8) + 9188);
    *(_DWORD *)(a1 + 56) = 0;
  }
  uint64_t v19 = heap_Alloc(*(void *)(*(void *)a1 + 8), 16);
  if (!v19)
  {
LABEL_35:
    int v13 = 10;
    goto LABEL_33;
  }
  uint64_t v20 = v19;
  uint64_t v21 = heap_Alloc(*(void *)(*(void *)a1 + 8), 800008);
  *(void *)uint64_t v20 = v21;
  if (!v21)
  {
    int v13 = 10;
LABEL_31:
    heap_Free(*(void **)(*(void *)a1 + 8), v20);
    goto LABEL_32;
  }
  *(_DWORD *)(v20 + 8) = 200002;
  fi_net_give_address(**(void **)(v10 + 56));
  if (!*(_DWORD *)(v10 + 116))
  {
    uint64_t v115 = 0;
    unsigned int v27 = v12 - 2;
    int v28 = *a3;
    unsigned int v110 = v27;
    int v13 = infer_acoustic_seq2seq_process_range(a1 + 44, (uint64_t *)v10, 1, v27);
    if (v13) {
      goto LABEL_29;
    }
    unsigned int v29 = *(_DWORD *)(*(void *)(v10 + 56) + 44);
    int v13 = calc_Marker_Pos_seq2seq((_DWORD *)a1, (uint64_t)v11, (uint64_t)a2, v28, **(_DWORD **)v20, *(_DWORD *)(*(void *)v20 + 4), *(void *)v20 + 8, (_DWORD *)&v115 + 1, &v115);
    if (v13) {
      goto LABEL_29;
    }
    unsigned int v30 = v29 >> 1;
    *(_DWORD *)(a1 + 24) = *(unsigned __int16 *)(*(void *)(v10 + 8) + 10);
    if (v29 >> 1 <= *(_DWORD *)(a1 + 36))
    {
      int v32 = *(void **)(a1 + 88);
      size_t v31 = v29 & 0xFFFFFFFE;
    }
    else
    {
      *(_DWORD *)(a1 + 36) = v30;
      size_t v31 = v29 & 0xFFFFFFFE;
      int v32 = (void *)heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 88), v31);
      *(void *)(a1 + 88) = v32;
      if (!v32)
      {
        int v13 = 10;
LABEL_29:
        if (*(void *)v20) {
          heap_Free(*(void **)(*(void *)a1 + 8), *(void *)v20);
        }
        goto LABEL_31;
      }
    }
    cstdlib_memcpy(v32, *(const void **)(*(void *)(v10 + 56) + 32), v31);
    *(_DWORD *)(a1 + 32) = v30;
    int v6 = 5;
    *(_DWORD *)(a1 + 52) = 5;
    LODWORD(v51) = 1;
    BOOL v52 = 1;
    unsigned int v53 = v29 >> 1;
    goto LABEL_81;
  }
  uint64_t v115 = 0;
  uint64_t v22 = *(unsigned int *)(a1 + 60);
  uint64_t v23 = *(void *)(v10 + 64);
  uint64_t v24 = *(void *)(v23 + 16);
  if (v22) {
    unsigned int v25 = *(_DWORD *)(v24 + 4 * (v22 - 1)) + 1;
  }
  else {
    unsigned int v25 = 1;
  }
  unsigned int v33 = *(_DWORD *)(v24 + 4 * v22) - (v22 == *(unsigned __int16 *)(v23 + 48) - 1);
  uint64_t v34 = *(void *)(*(void *)(v10 + 88) + 8);
  if (v22) {
    unsigned int v35 = *(_DWORD *)(v34 + 4 * (v22 - 1)) + 1;
  }
  else {
    unsigned int v35 = 0;
  }
  unsigned int v36 = v25;
  if (v33 != v25 - 1)
  {
    unsigned int v36 = v33;
    if (v33 < v25)
    {
      int v13 = 7;
      goto LABEL_28;
    }
  }
  int v108 = *(_DWORD *)(v34 + 4 * v22);
  int v104 = *(unsigned __int16 *)(v23 + 48) - 1;
  unsigned int v37 = *(uint64_t **)(v10 + 32);
  uint64_t v39 = *v37;
  uint64_t v38 = v37[1];
  int v40 = *(_DWORD *)(v39 + 12);
  if (*(float *)(v38 + 4 * (v40 * v25 + 1)) == 1.0)
  {
    ++v25;
    *(_WORD *)(*(void *)(v23 + 40) + 2 * v22) = 200;
  }
  unsigned int v112 = a2;
  if (*(float *)(v38 + 4 * (v40 * v36 + 1)) == 1.0)
  {
    --v36;
    *(_WORD *)(*(void *)(v23 + 32) + 2 * v22) = 200;
  }
  unsigned int v110 = v36;
  unsigned int v106 = v25;
  int v13 = infer_acoustic_seq2seq_process_range(a1 + 44, (uint64_t *)v10, v25, v36 - v25 + 1);
  if (!v13)
  {
    unsigned int v103 = *(_DWORD *)(*(void *)(v10 + 56) + 44);
    uint64_t v41 = v35;
    uint64_t v42 = (uint64_t)&v112[8 * v35];
    int v43 = v108 - v35;
    int v44 = v108 - v35 + 1;
    int v13 = calc_Marker_Pos_seq2seq((_DWORD *)a1, (uint64_t)v11, v42, v43 + 1, **(_DWORD **)v20, *(_DWORD *)(*(void *)v20 + 4), *(void *)v20 + 8, (_DWORD *)&v115 + 1, &v115);
    if (!v13)
    {
      if (v44)
      {
        int v45 = *(_DWORD *)(a1 + 32);
        uint64_t v46 = &v112[8 * v41 + 3];
        do
        {
          *v46 += v45;
          v46 += 8;
          --v44;
        }
        while (v44);
      }
      unsigned int v47 = v103 >> 1;
      if (*(_DWORD *)(a1 + 60))
      {
        uint64_t v48 = *(void *)(v10 + 56);
        unint64_t v49 = *(unsigned int *)(v48 + 44);
        if (v49 >= 2)
        {
          uint64_t v55 = 0;
          uint64_t v56 = *(void *)(v48 + 32);
          unint64_t v50 = v49 >> 1;
          int v57 = v11[1142].i32[1];
          a2 = v112;
          while (1)
          {
            int v58 = *(__int16 *)(v56 + 2 * v55);
            if (v58 < -v57 || v57 < v58) {
              break;
            }
            if (v50 == ++v55) {
              goto LABEL_72;
            }
          }
          LODWORD(v50) = v55;
        }
        else
        {
          LODWORD(v50) = 0;
          a2 = v112;
        }
LABEL_72:
        uint64_t v54 = v11[1142].i32[0] * v11[1148].i32[1] * (v50 / v11[1148].i32[1] / v11[1142].i32[0]);
        v47 -= v54;
      }
      else
      {
        uint64_t v54 = 0;
        a2 = v112;
      }
      int v61 = *(_DWORD *)(a1 + 32);
      unsigned int v60 = *(_DWORD *)(a1 + 36);
      if (v47 > v60 - v61)
      {
        do
          v60 *= 2;
        while (v47 > v60 - v61);
        *(_DWORD *)(a1 + 36) = v60;
      }
      uint64_t v62 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 88), 2 * v60);
      *(void *)(a1 + 88) = v62;
      if (!v62)
      {
        int v13 = 10;
        goto LABEL_28;
      }
      BOOL v52 = v22 == v104;
      cstdlib_memcpy((void *)(v62 + 2 * *(unsigned int *)(a1 + 32)), (const void *)(*(void *)(*(void *)(v10 + 56) + 32) + 2 * v54), 2 * v47);
      unsigned int v53 = *(_DWORD *)(a1 + 32) + v47;
      *(_DWORD *)(a1 + 32) = v53;
      int v63 = *(_DWORD *)(a1 + 60) + 1;
      *(_DWORD *)(a1 + 60) = v63;
      if (v63 == *(unsigned __int16 *)(*(void *)(v10 + 64) + 48)) {
        int v6 = 5;
      }
      else {
        int v6 = 4;
      }
      *(_DWORD *)(a1 + 52) = v6;
      LODWORD(v51) = v106;
LABEL_81:
      int v64 = v110 + v52;
      uint64_t v65 = *(_DWORD **)(a1 + 8);
      if (v53)
      {
        uint64_t v66 = 0;
        int v67 = v65[2285];
        do
        {
          int v68 = *(__int16 *)(*(void *)(a1 + 88) + 2 * v66);
          if (v68 < -v67 || v67 < v68) {
            goto LABEL_90;
          }
          ++v66;
        }
        while (v53 != v66);
        LODWORD(v66) = v53;
      }
      else
      {
        LODWORD(v66) = 0;
      }
LABEL_90:
      if ((int)v51 > v64)
      {
        int v13 = 0;
        goto LABEL_27;
      }
      int v100 = 0;
      uint64_t v70 = *a3;
      uint64_t v71 = *(void *)(*(void *)(a1 + 16) + 8);
      uint64_t v72 = v65[2284] * v65[2297] * (v66 / v65[2297] / v65[2284]);
      uint64_t v51 = (int)v51;
      int v73 = v64 + 1;
      uint64_t v99 = (v70 - 1);
      int v98 = &a2[8 * v99 + 3];
      int v101 = a2 + 4;
      uint64_t v107 = v70;
      uint64_t v109 = *(_DWORD **)(a1 + 8);
      uint64_t v105 = v71;
      int v102 = v64 + 1;
      unsigned int v113 = a2;
LABEL_93:
      if (*(_DWORD *)(a1 + 108) != *(unsigned __int8 *)(*(void *)(v71 + 32) + v51)) {
        goto LABEL_121;
      }
      int v74 = *(unsigned __int16 *)(*(void *)(v71 + 1784) + 2 * v51);
      if (!*(_WORD *)(*(void *)(v71 + 1784) + 2 * v51)) {
        goto LABEL_121;
      }
      int v75 = v65[4];
      if (!v70)
      {
LABEL_101:
        unsigned int v79 = 0;
        goto LABEL_102;
      }
      uint64_t v76 = v70;
      int v77 = a2;
      int v78 = v51;
      while (1)
      {
        if (*v77 == 33)
        {
          if (!v78)
          {
            unsigned int v90 = v77[3];
            if (v90 >= v53) {
              unsigned int v79 = v53;
            }
            else {
              unsigned int v79 = v90;
            }
            if ((int)v70 >= 1 && v90 > v53)
            {
              unint64_t v92 = v98;
              uint64_t v91 = v99;
              int v93 = *v98;
              uint64_t v94 = v70;
              int v95 = v100;
              if (*v98 <= v53)
              {
LABEL_131:
                int v100 = v95;
                v113[8 * v91 + 4] += v53 - v95;
              }
              else
              {
                while (1)
                {
                  int v95 = v93;
                  *unint64_t v92 = v53;
                  v113[8 * v91 + 4] = 0;
                  if (v94 <= 1) {
                    break;
                  }
                  uint64_t v91 = (v94 - 2);
                  uint64_t v96 = &v113[8 * v91];
                  unsigned int v97 = v96[3];
                  unint64_t v92 = v96 + 3;
                  int v93 = v97;
                  --v94;
                  if (v97 <= v53) {
                    goto LABEL_131;
                  }
                }
                int v100 = v93;
              }
              unsigned int v79 = v53;
            }
LABEL_102:
            unsigned int v80 = v75 * v74 / 0x3E8u;
            unsigned int v81 = *(_DWORD *)(a1 + 36);
            uint64_t v111 = v51;
            if (v81 < v80 + v53)
            {
              do
                v81 *= 2;
              while (v81 < v80 + v53);
              *(_DWORD *)(a1 + 36) = v81;
            }
            int v82 = (char *)heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 88), 2 * v81);
            *(void *)(a1 + 88) = v82;
            cstdlib_memmove(&v82[2 * v79 + 2 * v80], &v82[2 * v79], 2 * (*(_DWORD *)(a1 + 32) - v79));
            unsigned int v83 = v80;
            unsigned int v84 = v79;
            if ((int)v72 - 1 < v80)
            {
              unsigned int v84 = v79;
              unsigned int v83 = v80;
              do
              {
                cstdlib_memcpy(&v82[2 * v84], v82, 2 * v72);
                v84 += v72;
                v83 -= v72;
              }
              while (v83 >= v72);
            }
            if (v83)
            {
              size_t v85 = 2 * v83;
              uint64_t v86 = &v82[2 * v84];
              if (v83 >= v72) {
                cstdlib_memset(v86, 0, v85);
              }
              else {
                cstdlib_memcpy(v86, v82, v85);
              }
            }
            unsigned int v53 = *(_DWORD *)(a1 + 32) + v80;
            *(_DWORD *)(a1 + 32) = v53;
            uint64_t v70 = v107;
            if (v107)
            {
              unint64_t v87 = v101;
              uint64_t v88 = v107;
              uint64_t v65 = v109;
              uint64_t v51 = v111;
              uint64_t v71 = v105;
              int v73 = v102;
              do
              {
                unsigned int v89 = *(v87 - 1);
                if (*v87 + v89 >= v79) {
                  *v87 += v80;
                }
                if (v89 >= v79) {
                  *(v87 - 1) = v89 + v80;
                }
                v87 += 8;
                --v88;
              }
              while (v88);
              a2 = v113;
            }
            else
            {
              uint64_t v51 = v111;
              a2 = v113;
              uint64_t v65 = v109;
              uint64_t v71 = v105;
              int v73 = v102;
            }
LABEL_121:
            if (v73 == ++v51)
            {
              int v13 = 0;
              int v6 = *(_DWORD *)(a1 + 52);
LABEL_27:
              *a4 = v6;
              break;
            }
            goto LABEL_93;
          }
          --v78;
        }
        v77 += 8;
        if (!--v76) {
          goto LABEL_101;
        }
      }
    }
  }
LABEL_28:
  if (v20) {
    goto LABEL_29;
  }
LABEL_32:
  if (v13)
  {
LABEL_33:
    *(_DWORD *)(a1 + 52) = 6;
    *a4 = 6;
    return v13 | 0x84E02000;
  }
  return 0;
}

uint64_t siren_pipeline_ProcessEnd(void *a1, _DWORD *a2)
{
  int v2 = *((_DWORD *)a1 + 13);
  if ((v2 - 2) <= 3)
  {
    *a2 = v2;
    *((_DWORD *)a1 + 26) = 0;
    a1[3] = 0;
    *((_DWORD *)a1 + 13) = 0;
    uint64_t v4 = a1[10];
    if (v4)
    {
      heap_Free(*(void **)(*a1 + 8), v4);
      a1[10] = 0;
    }
    uint64_t v5 = a1[11];
    if (v5)
    {
      heap_Free(*(void **)(*a1 + 8), v5);
      a1[11] = 0;
    }
    uint64_t v6 = a1[2];
    if (v6 && *(_DWORD *)(v6 + 116)) {
      chunking_Close((uint64_t *)v6, a1[1]);
    }
    if (a1[9]) {
      seq2seq_stream_free_NNState(a1);
    }
  }
  return 0;
}

uint64_t siren_pipeline_freeSecondaryChunkingMemory(void *a1)
{
  if (a1)
  {
    uint64_t v2 = a1[2];
    if (v2)
    {
      if (*(_DWORD *)(v2 + 120))
      {
        uint64_t v3 = *(void *)(v2 + 88);
        if (v3)
        {
          uint64_t v4 = *(void *)(v3 + 16);
          if (v4)
          {
            heap_Free(*(void **)(*a1 + 8), v4);
            uint64_t v2 = a1[2];
            *(void *)(*(void *)(v2 + 88) + 16) = 0;
          }
        }
        uint64_t v5 = *(void *)(v2 + 72);
        if (v5)
        {
          uint64_t v6 = *(void *)(v5 + 16);
          if (v6)
          {
            heap_Free(*(void **)(*a1 + 8), v6);
            *(void *)(*(void *)(a1[2] + 72) + 16) = 0;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t siren_pipline_GetPhoneChunkingSpellPause(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(*(void *)(*(void *)(a1 + 16) + 64) + 24)
                             + 2 * (*(_DWORD *)(a1 + 60) - 1));
}

uint64_t siren_pipeline_GetSecondaryChunkingCount(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 16) + 72) + 24);
}

uint64_t siren_pipeline_GetPhoneChunkingCount(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 16) + 64) + 48);
}

uint64_t siren_pipeline_GetMarkerCount(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 16) + 88) + 8);
  if (a2) {
    int v3 = -*(_DWORD *)(v2 + 4 * (a2 - 1));
  }
  else {
    int v3 = 1;
  }
  return (v3 + *(_DWORD *)(v2 + 4 * a2));
}

uint64_t siren_pipeline_GetSecondaryMarkerCount(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 64);
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 16) + 88) + 16);
  unsigned int v3 = v1 - 1;
  if (v1 != 1) {
    int v1 = -*(_DWORD *)(v2 + 4 * (v1 - 2));
  }
  return (v1 + *(_DWORD *)(v2 + 4 * v3));
}

uint64_t siren_pipeline_GetAudioStream(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 52) == 6 || !*(void *)(*(void *)(result + 16) + 56)) {
      return 0;
    }
    else {
      return *(void *)(result + 88);
    }
  }
  return result;
}

uint64_t siren_pipeline_GetAcousticStream(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 52) == 6 || !*(void *)(*(void *)(result + 16) + 56)) {
      return 0;
    }
    else {
      return *(void *)(result + 80);
    }
  }
  return result;
}

uint64_t siren_pipeline_GetSampleChunk(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 52) == 6) {
      return 0;
    }
    else {
      return *(void *)(*(void *)(result + 16) + 80);
    }
  }
  return result;
}

uint64_t siren_pipeline_GetFrameChunk(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 52) == 6) {
      return 0;
    }
    else {
      return *(void *)(*(void *)(result + 16) + 72);
    }
  }
  return result;
}

uint64_t siren_pipeline_GetFeatPhone(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 52) == 6) {
      return 0;
    }
    else {
      return *(void *)(*(void *)(result + 16) + 32);
    }
  }
  return result;
}

uint64_t siren_pipeline_GetFeatFrame(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 52) == 6) {
      return 0;
    }
    else {
      return *(void *)(*(void *)(result + 16) + 40);
    }
  }
  return result;
}

uint64_t siren_pipeline_GetDurationStream(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 52) == 6) {
      return 0;
    }
    uint64_t v1 = *(void *)(*(void *)(result + 16) + 48);
    if (!v1) {
      return 0;
    }
    else {
      return *(void *)(v1 + 56);
    }
  }
  return result;
}

uint64_t siren_pipeline_GetPhoneCount(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 52) == 6) {
      return 0;
    }
    else {
      return *(unsigned int *)(result + 24);
    }
  }
  return result;
}

uint64_t siren_pipeline_GetFrameCount(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 52) == 6) {
      return 0;
    }
    else {
      return *(unsigned int *)(result + 28);
    }
  }
  return result;
}

uint64_t siren_pipeline_GetFrameSize(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(*(void *)(result + 8) + 9204);
  }
  return result;
}

uint64_t siren_pipeline_GetMaxSample(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 36);
  }
  return result;
}

uint64_t siren_pipeline_GetiSample(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 32);
  }
  return result;
}

uint64_t siren_pipeline_GetTotalPhoneCount(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 52) == 6) {
      return 0;
    }
    else {
      return *(unsigned __int16 *)(*(void *)(*(void *)(result + 16) + 8) + 10);
    }
  }
  return result;
}

uint64_t siren_pipeline_GetTailingPauseLen(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 52) == 6) {
      return 0;
    }
    uint64_t v1 = *(void *)(result + 16);
    if (!*(_DWORD *)(v1 + 116) || *(_DWORD *)(v1 + 120) && *(_DWORD *)(result + 64)) {
      return 0;
    }
    else {
      return *(unsigned __int16 *)(*(void *)(*(void *)(v1 + 64) + 32)
    }
                                 + 2 * (*(_DWORD *)(result + 60) - 1));
  }
  return result;
}

uint64_t siren_pipeline_GetTotalFrameCount(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 52) == 6) {
      return 0;
    }
    else {
      return *(unsigned int *)(*(void *)(*(void *)(result + 16) + 48) + 24);
    }
  }
  return result;
}

uint64_t siren_pipeline_GetAcousticStreamSize(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 52) == 6) {
      return 0;
    }
    else {
      return (*(_DWORD *)(*(void *)(result + 8) + 9204) * *(_DWORD *)(result + 28));
    }
  }
  return result;
}

uint64_t siren_pipeline_SetChunking(uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(result + 16) + 116) = a2;
  return result;
}

uint64_t siren_pipeline_SetSecondaryChunking(uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(result + 16) + 120) = a2;
  return result;
}

uint64_t siren_pipeline_SetNFrameInfer(uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(result + 16) + 136) = a2;
  return result;
}

uint64_t siren_pipeline_SetSpeakerID(uint64_t result, int a2)
{
  *(_DWORD *)(result + 44) = a2;
  return result;
}

uint64_t siren_pipeline_GetChunking(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 16) + 116);
}

uint64_t siren_pipeline_GetSecondaryChunking(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 16) + 120);
}

uint64_t siren_pipeline_GetSampleChunkCounter(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 104);
  }
  return result;
}

uint64_t siren_pipeline_SetSampleChunkCounter(uint64_t result, int a2)
{
  *(_DWORD *)(result + 104) = a2;
  return result;
}

uint64_t siren_pipeline_reset_acoustic_net_seed(uint64_t a1)
{
  return infer_acoustic_reset_seed(*(void *)(a1 + 16));
}

char *seq2seq_select_speaker(uint64_t a1, uint64_t a2, char *a3, const char *a4)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  strcpy(__charset, ",");
  unint64_t v15 = 0;
  uint64_t result = (char *)cstdlib_memset(__b, 0, 0x9C4uLL);
  if (a3)
  {
    uint64_t v9 = extstdlib_strtok_r(a3, __charset, &v15);
    if (v9)
    {
      uint64_t v10 = v9;
      LODWORD(v11) = 0;
      do
      {
        int v12 = (char *)&__b[25 * v11];
        uint64_t v11 = (v11 + 1);
        cstdlib_strcpy(v12, v10);
        uint64_t v10 = extstdlib_strtok_r(0, __charset, &v15);
      }
      while (v10);
      if (v11)
      {
        uint64_t v13 = 0;
        for (uint64_t i = (const char *)__b; cstdlib_strcmp(*(const char **)(a2 + 24), i); i += 50)
        {
          if (v11 == ++v13) {
            return cstdlib_strcpy(a3, a4);
          }
        }
        *(_DWORD *)(a1 + 44) = v13;
      }
    }
    return cstdlib_strcpy(a3, a4);
  }
  return result;
}

uint64_t chunking_markers(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4)
{
  uint64_t v6 = *(void *)(a2 + 64);
  uint64_t v7 = *(void *)(a2 + 88);
  *(_WORD *)uint64_t v7 = *a4;
  uint64_t v8 = *(unsigned __int16 *)(v6 + 48);
  *(_WORD *)(v7 + 24) = v8;
  uint64_t v9 = heap_Calloc(*(void **)(a1 + 8), v8, 4);
  *(void *)(v7 + 8) = v9;
  if (!v9) {
    return 10;
  }
  if (v8)
  {
    uint64_t v10 = 0;
    unsigned __int16 v11 = 0;
    unsigned __int16 v12 = 0;
    uint64_t v13 = *(void *)(v6 + 16);
    do
    {
      for (unsigned int i = *(_DWORD *)(v13 + 4 * v10); i >= v12; ++v11)
      {
        if (*a4 <= v11) {
          break;
        }
        int v15 = *a3;
        a3 += 8;
        if (v15 == 33) {
          ++v12;
        }
      }
      *(_DWORD *)(v9 + 4 * v10++) = v11 - 1;
    }
    while (v10 != v8);
  }
  return 0;
}

void *seq2seq_stream_free_NNState(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = (uint64_t *)result[9];
    if (v2)
    {
      if (*v2)
      {
        heap_Free(*(void **)(*result + 8), *v2);
        uint64_t v2 = (uint64_t *)v1[9];
      }
      if (v2[4])
      {
        heap_Free(*(void **)(*v1 + 8), v2[4]);
        uint64_t v2 = (uint64_t *)v1[9];
      }
      uint64_t result = heap_Free(*(void **)(*v1 + 8), (uint64_t)v2);
      v1[9] = 0;
    }
  }
  return result;
}

uint64_t bubble_sort_markers(uint64_t result, unsigned int a2, int a3)
{
  if (a3)
  {
    uint64_t v3 = (a3 - 1);
    if (v3 > a2)
    {
      int v4 = 0;
      uint64_t v5 = a2;
      while (1)
      {
        uint64_t v6 = (long long *)(result + 32 * v5++);
        uint64_t v7 = (long long *)(result + 32 * v5);
        if (*((_DWORD *)v6 + 3) > *((_DWORD *)v7 + 3))
        {
          long long v8 = *v6;
          long long v10 = v6[1];
          long long v9 = v7[1];
          *uint64_t v6 = *v7;
          v6[1] = v9;
          *uint64_t v7 = v8;
          v7[1] = v10;
          int v4 = 1;
        }
        if (v5 == v3)
        {
          if (!v4) {
            break;
          }
          int v4 = 0;
          uint64_t v5 = a2;
          if (v3 <= a2) {
            break;
          }
        }
      }
    }
  }
  return result;
}

uint64_t calc_Marker_Pos_seq2seq_notrim(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, unsigned int a6, uint64_t a7)
{
  unint64_t v14 = (_DWORD *)heap_Alloc(*(void *)(*(void *)a1 + 8), 4 * a6);
  if (v14)
  {
    uint64_t v32 = 0;
    transferAlign(a7, v14, a6, a5, (_DWORD *)&v32 + 1, &v32);
    if (a4)
    {
      uint64_t v15 = 0;
      LODWORD(v16) = 0;
      int v17 = *(_DWORD *)(a2 + 9188);
      uint64_t v18 = a3;
      unsigned int v19 = 1;
      do
      {
        if (*(_DWORD *)v18 == 33)
        {
          ++v19;
          *(void *)(v18 + 12) = (v16 * v17);
          if (v16 < a6)
          {
            uint64_t v16 = v16;
            int v20 = v17;
            while (v14[v16] <= v19)
            {
              *(_DWORD *)(v18 + 16) = v20;
              ++v16;
              v20 += v17;
              if (a6 == v16)
              {
                LODWORD(v16) = a6;
                break;
              }
            }
          }
          if (*(_DWORD *)(v18 + 24) == 35)
          {
            if (v15)
            {
              uint64_t v21 = a3 + 32 * v15;
              uint64_t v22 = (_DWORD *)(v21 + 12);
              uint64_t v23 = (_DWORD *)(v21 + 16);
              uint64_t v24 = (_DWORD *)(a3 + 12);
              uint64_t v25 = v15;
              do
              {
                unsigned int v26 = *(v24 - 3);
                BOOL v27 = v26 > 0x28;
                uint64_t v28 = (1 << v26) & 0x10004000100;
                BOOL v29 = v27 || v28 == 0;
                if (!v29 && *v24 == *v22) {
                  *v24 += *v23;
                }
                v24 += 8;
                --v25;
              }
              while (v25);
              LODWORD(v16) = v15;
            }
            else
            {
              LODWORD(v16) = 0;
            }
          }
        }
        else
        {
          *(void *)(v18 + 12) = (v16 * v17);
        }
        v18 += 32;
        ++v15;
      }
      while (v15 != a4);
    }
    bubble_sort_markers(a3, 0, a4);
    uint64_t v30 = 0;
  }
  else
  {
    uint64_t v30 = 10;
  }
  heap_Free(*(void **)(*(void *)a1 + 8), (uint64_t)v14);
  return v30;
}

uint64_t chunking_frames(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  unsigned int v8 = 10;
  if (*(_DWORD *)(a1 + 48) <= 0xAu) {
    unsigned int v9 = 10;
  }
  else {
    unsigned int v9 = *(_DWORD *)(a1 + 48);
  }
  uint64_t v10 = *(void *)(a5 + 72);
  *(_WORD *)(v10 + 10) = a4;
  unsigned __int16 v11 = (unsigned int *)heap_Calloc(*(void **)(a2 + 8), (unsigned __int16)(a4 / v9 + 1), 4);
  *(void *)(v10 + 16) = v11;
  if (!v11) {
    goto LABEL_23;
  }
  if (v9 >= a4)
  {
    unsigned __int16 v13 = 0;
    unsigned int v15 = 0;
  }
  else
  {
    unsigned int v12 = 0;
    unsigned __int16 v13 = 0;
    float v14 = *(float *)(a3 + 9160);
    do
    {
      unsigned int v15 = v9;
      v11[v13] = v9 - 1;
      unsigned int v9 = (float)((float)v9 + (float)((float)(v9 - v12) * v14));
      ++v13;
      unsigned int v12 = v15;
    }
    while (v9 < a4);
  }
  if (v15 < a4) {
    v11[v13++] = a4 - 1;
  }
  uint64_t v16 = v13 - 2;
  if (v13 >= 2u)
  {
    unsigned int v17 = v11[v16];
    if (v11[v13 - 1] <= v17 + 2) {
      v11[v16] = v17 - 2;
    }
  }
  *(_WORD *)(v10 + 24) = v13;
  if (v13 == 2)
  {
    float v19 = (float)v11[1] + (float)((float)(*v11 + 1) * *(float *)(a3 + 9160));
    float v20 = (float)*v11;
  }
  else
  {
    if (v13 == 1)
    {
      float v18 = *(float *)(a3 + 9160) * (float)(*v11 + 1);
      goto LABEL_21;
    }
    uint64_t v21 = &v11[v13];
    unsigned int v22 = *(v21 - 2);
    float v19 = (float)*(v21 - 1) + (float)((float)(v22 - *(v21 - 3) + 1) * *(float *)(a3 + 9160));
    float v20 = (float)v22;
  }
  float v18 = (float)(v19 - v20) + 1.0;
LABEL_21:
  unsigned int v8 = 0;
  if (*(_DWORD *)(a1 + 48) < v18) {
    *(_DWORD *)(a1 + 48) = v18;
  }
LABEL_23:
  if (v11) {
    return v8;
  }
  else {
    return v8 | 0x84E02000;
  }
}

uint64_t chunking_secondary_markers(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int *a6)
{
  uint64_t v10 = *(void *)(a3 + 72);
  uint64_t v11 = *(void *)(a3 + 88);
  uint64_t v12 = *(unsigned __int16 *)(v10 + 24);
  uint64_t v13 = heap_Calloc(*(void **)(a1 + 8), v12, 4);
  *(void *)(v11 + 16) = v13;
  if (v13)
  {
    if (v12)
    {
      uint64_t v14 = 0;
      LODWORD(v15) = 0;
      uint64_t v16 = *(void *)(v10 + 16);
      do
      {
        uint64_t v17 = v14;
        if (v15 < a5)
        {
          unsigned int v18 = *(_DWORD *)(v16 + 4 * v14) + 1;
          uint64_t v15 = v15;
          float v19 = (unsigned int *)(a4 + 12 + 32 * v15);
          while (1)
          {
            unsigned int v20 = *v19;
            v19 += 8;
            if (v20 / *(_DWORD *)(a2 + 9188) >= v18) {
              break;
            }
            if (a5 == ++v15)
            {
              LODWORD(v15) = a5;
              break;
            }
          }
        }
        *(_DWORD *)(v13 + 4 * v17) = v15 - 1;
        uint64_t v14 = v17 + 1;
      }
      while (v17 + 1 != v12);
      uint64_t v21 = v17;
    }
    else
    {
      uint64_t v21 = 0xFFFFFFFFLL;
    }
    unsigned int v22 = *a6;
    if (*a6)
    {
      unsigned int v22 = 0;
      *(_DWORD *)(v13 + 4 * v21) = a5 - 1;
    }
  }
  else
  {
    unsigned int v22 = 10;
  }
  if (v13) {
    return v22;
  }
  else {
    return v22 | 0x84E02000;
  }
}

uint64_t transferAlign(uint64_t result, _DWORD *a2, unsigned int a3, int a4, _DWORD *a5, _DWORD *a6)
{
  *a5 = 0;
  *a6 = 0;
  if (a3)
  {
    int v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = a3;
    do
    {
      a2[v7] = 0;
      if (a4)
      {
        uint64_t v9 = 0;
        float v10 = 0.0;
        do
        {
          float v11 = *(float *)(result + 4 * (v6 + v9));
          if (v11 > v10)
          {
            a2[v7] = v9;
            float v10 = v11;
          }
          ++v9;
        }
        while (a4 != v9);
      }
      ++v7;
      v6 += a4;
    }
    while (v7 != a3);
    if (a3 >= 2)
    {
      uint64_t v12 = a2 + 1;
      uint64_t v13 = a3 - 1;
      do
      {
        unsigned int v15 = *(v12 - 1);
        unsigned int v14 = *v12;
        if (*v12 >= v15)
        {
          if (!v14)
          {
            ++*a5;
            unsigned int v14 = *v12;
          }
        }
        else
        {
          *uint64_t v12 = v15;
          unsigned int v14 = v15;
        }
        if (v14 == a4 - 1) {
          ++*a6;
        }
        ++v12;
        --v13;
      }
      while (v13);
    }
    do
    {
      ++*a2++;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t calc_Marker_Pos_seq2seq(_DWORD *a1, uint64_t a2, uint64_t a3, int a4, int a5, unsigned int a6, uint64_t a7, _DWORD *a8, _DWORD *a9)
{
  uint64_t v17 = (_DWORD *)heap_Alloc(*(void *)(*(void *)a1 + 8), 4 * a6);
  if (v17)
  {
    transferAlign(a7, v17, a6, a5, a8, a9);
    if (a4)
    {
      int v18 = 0;
      int v19 = a1[15];
      BOOL v20 = v19 == 0;
      unsigned int v21 = v19 != 0;
      if (v20) {
        LODWORD(v22) = 0;
      }
      else {
        LODWORD(v22) = *a8;
      }
      int v23 = 5 * *(_DWORD *)(a2 + 9188);
      do
      {
        if (*(_DWORD *)a3 == 33)
        {
          ++v21;
          *(void *)(a3 + 12) = (v22 * v23);
          if (v22 < a6)
          {
            uint64_t v22 = v22;
            int v24 = v23;
            while (v17[v22] <= v21)
            {
              *(_DWORD *)(a3 + 16) = v24;
              ++v22;
              v24 += v23;
              if (a6 == v22)
              {
                LODWORD(v22) = a6;
                break;
              }
            }
          }
        }
        else
        {
          *(void *)(a3 + 12) = (v22 * v23);
        }
        a3 += 32;
        ++v18;
      }
      while (v18 != a4);
    }
    uint64_t v25 = 0;
  }
  else
  {
    uint64_t v25 = 10;
  }
  heap_Free(*(void **)(*(void *)a1 + 8), (uint64_t)v17);
  return v25;
}

uint64_t siren_pipeline_loc_ForceFESilDur(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  uint64_t v2 = *(void *)(v1 + 8);
  uint64_t v3 = *(unsigned __int16 *)(v2 + 10);
  if (*(_WORD *)(v2 + 10))
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(void *)(result + 8);
    uint64_t v6 = *(void *)(v2 + 32);
    do
    {
      if (*(_DWORD *)(result + 108) == *(unsigned __int8 *)(v6 + v4))
      {
        unsigned int v7 = *(unsigned __int16 *)(*(void *)(v2 + 1784) + 2 * v4);
        if (*(_WORD *)(*(void *)(v2 + 1784) + 2 * v4))
        {
          unsigned int v8 = *(unsigned __int16 *)(v5 + 32);
          if (v8 <= v7) {
            int v9 = v7 / v8;
          }
          else {
            int v9 = 2;
          }
          uint64_t v10 = *(void *)(v1 + 48);
          uint64_t v11 = *(void *)(v10 + 56);
          *(_DWORD *)(v10 + 24) += v9 - *(_DWORD *)(v11 + 4 * v4);
          *(_DWORD *)(v11 + 4 * v4) = v9;
        }
      }
      ++v4;
    }
    while (v3 != v4);
  }
  return result;
}

uint64_t calc_Max_Frame_Len(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 72);
  uint64_t v2 = *(unsigned __int16 *)(v1 + 24);
  if (*(_WORD *)(v1 + 24))
  {
    uint64_t v3 = *(void *)(v1 + 16);
    do
    {
      v3 += 4;
      --v2;
    }
    while (v2);
  }
  return result;
}

uint64_t select_bet6_FeatureExtractObjOpen(_WORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  uint64_t v24 = 0;
  *a8 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v24);
  if ((inited & 0x80000000) == 0)
  {
    uint64_t v15 = heap_Calloc(*(void **)(v24 + 8), 1, 72);
    if (!v15)
    {
      log_OutPublic(*(void *)(v24 + 32), (uint64_t)"SELECT_BET6", 72000, 0, v16, v17, v18, v19, v23);
      return 2229280778;
    }
    uint64_t v20 = v15;
    *(void *)uint64_t v15 = v24;
    *(void *)(v15 + 8) = a3;
    *(void *)(v15 + 16) = a4;
    *(void *)(v15 + 24) = a5;
    *(void *)(v15 + 32) = a6;
    *(_DWORD *)(v15 + 48) = a7 != 0;
    if (a7)
    {
      int v21 = nnfeatex_Init(v15 + 56, a4, a5, a7, v24);
      if (v21)
      {
        uint64_t inited = v21 | 0x84E02000;
        select_bet6_FeatureExtractObjClose(v20);
        return inited;
      }
      uint64_t inited = 0;
      *(void *)(v20 + 40) = a7;
    }
    *a8 = v20;
  }
  return inited;
}

uint64_t select_bet6_FeatureExtractObjClose(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 48))
  {
    int v2 = nnfeatex_DeInit((uint64_t *)(a1 + 56));
    if (v2) {
      uint64_t v3 = v2 | 0x84E02000;
    }
    else {
      uint64_t v3 = 0;
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  heap_Free(*(void **)(*(void *)a1 + 8), a1);
  return v3;
}

uint64_t select_bet6_FeatureExtractObjReopen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a1 + 48))
  {
    int v8 = nnfeatex_DeInit((uint64_t *)(a1 + 56));
    if (v8) {
      return v8 | 0x84E02000;
    }
  }
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a3;
  *(_DWORD *)(a1 + 48) = a4 != 0;
  if (!a4) {
    return 0;
  }
  *(void *)(a1 + 40) = a4;
  int v10 = nnfeatex_Init(a1 + 56, *(void *)(a1 + 16), a2, a4, *(void *)a1);
  if (v10) {
    return v10 | 0x84E02000;
  }
  else {
    return 0;
  }
}

uint64_t select_bet6_FeatureExtractProcessStart(uint64_t a1, uint64_t a2, uint64_t a3, void *__b, uint64_t a5, uint64_t a6, _DWORD *a7)
{
  cstdlib_memset(__b, 0, 0xE48uLL);
  uint64_t v12 = *(void *)(a1 + 16);
  *int8x16_t __b = *(void *)(a1 + 24);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, void))(v12 + 272))(a2, a3, 128, 3, 0, 0);
  if (*(_DWORD *)(a1 + 48))
  {
    int v13 = nnfeatex_ProcessStart((uint64_t *)(a1 + 56), a2, a3, __b, a7);
    if (v13) {
      return v13 | 0x84E02000;
    }
  }
  uint64_t v15 = *(void *)a1;
  uint64_t v16 = *(void *)(a1 + 16);

  return usextract_ProcessStart(v15, (uint64_t)"SELECT_BET6", v16, a2, a3, (uint64_t)__b, a7);
}

uint64_t select_bet6_FeatureExtractProcess(uint64_t *a1, uint64_t a2, uint64_t a3, unsigned int *a4, uint64_t a5, uint64_t *a6, _DWORD *a7, uint64_t *a8, _DWORD *a9)
{
  uint64_t v113 = *MEMORY[0x263EF8340];
  uint64_t v13 = *a1;
  if (a8) {
    BOOL v14 = a9 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  int v15 = !v14;
  if (!v14)
  {
    *a8 = 0;
    *a9 = 0;
  }
  uint64_t v16 = 0;
  int v17 = 0;
  uint64_t v18 = *(__int16 *)(a5 + 10);
  do
  {
    if (*(unsigned char *)(*(void *)a5 + 2748 + v16) == 1) {
      ++v17;
    }
    ++v16;
  }
  while (v16 != 218);
  uint64_t v19 = heap_Calloc(*(void **)(v13 + 8), (v17 * v18), 1);
  if (!v19) {
    goto LABEL_123;
  }
  uint64_t v24 = v19;
  int v103 = v15;
  int v104 = a4;
  for (uint64_t i = 0; i != 218; ++i)
  {
    uint64_t v26 = *(void *)a5;
    int v27 = *(unsigned __int8 *)(*(void *)a5 + i + 2748);
    if (*(unsigned char *)(*(void *)a5 + i + 2748))
    {
      if (v27 == 2)
      {
        uint64_t v28 = heap_Calloc(*(void **)(v13 + 8), v18, 2);
        *(void *)(a5 + 8 * i + 1760) = v28;
        if (!v28) {
          goto LABEL_123;
        }
      }
      else if (v27 == 1)
      {
        *(void *)(a5 + 8 * i + 16) = v24;
        v24 += v18;
      }
      else
      {
        switch((int)i)
        {
          case '.':
            uint64_t v29 = heap_Calloc(*(void **)(v13 + 8), v18, 9);
            *(void *)(a5 + 3560) = v29;
            if (!v29) {
              goto LABEL_123;
            }
            continue;
          case '/':
          case '0':
          case '1':
          case '2':
          case '7':
            goto LABEL_28;
          case '3':
            int v31 = *(unsigned __int16 *)(v26 + 2966);
            if (v31)
            {
              uint64_t v32 = heap_Calloc(*(void **)(v13 + 8), (v31 * v18), 4);
              *(void *)(a5 + 3568) = v32;
              if (!v32) {
                goto LABEL_123;
              }
            }
            continue;
          case '4':
            int v33 = *(unsigned __int16 *)(v26 + 2966);
            if (v33)
            {
              uint64_t v34 = heap_Calloc(*(void **)(v13 + 8), (v33 * v18), 4);
              *(void *)(a5 + 3576) = v34;
              if (!v34) {
                goto LABEL_123;
              }
            }
            continue;
          case '5':
            int v35 = *(unsigned __int16 *)(v26 + 3360);
            if (v35)
            {
              uint64_t v36 = heap_Calloc(*(void **)(v13 + 8), (v35 * v18), 4);
              *(void *)(a5 + 3584) = v36;
              if (!v36) {
                goto LABEL_123;
              }
            }
            continue;
          case '6':
            int v37 = *(unsigned __int16 *)(v26 + 3360);
            if (v37)
            {
              uint64_t v38 = heap_Calloc(*(void **)(v13 + 8), (v37 * v18), 4);
              *(void *)(a5 + 3592) = v38;
              if (!v38) {
                goto LABEL_123;
              }
            }
            continue;
          case '8':
            int v39 = *(unsigned __int16 *)(v26 + 2966);
            if (v39)
            {
              uint64_t v40 = heap_Calloc(*(void **)(v13 + 8), (v39 * v18), 1);
              *(void *)(a5 + 3600) = v40;
              if (!v40) {
                goto LABEL_123;
              }
            }
            continue;
          default:
            if (i == 24)
            {
              uint64_t v30 = heap_Calloc(*(void **)(v13 + 8), v18, 8);
              *(void *)(a5 + 3552) = v30;
              if (!v30) {
                goto LABEL_123;
              }
            }
            else
            {
LABEL_28:
              log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"SELECT_BET6", 72003, (uint64_t)"%s%u", v20, v21, v22, v23, "feature");
            }
            break;
        }
      }
    }
  }
  unsigned int v41 = *(unsigned __int16 *)(*(void *)a5 + 3578);
  if (v41 >= 4)
  {
    log_OutPublic(*(void *)(v13 + 32), (uint64_t)"SELECT_BET6", 72003, (uint64_t)"Invalid number of states per phoneme", v20, v21, v22, v23, "%s%u");
    int v42 = -2065686513;
    goto LABEL_124;
  }
  int v43 = (void *)heap_Calloc(*(void **)(v13 + 8), v41 * v18, 4);
  *(void *)(a5 + 3608) = v43;
  if (!v43) {
    goto LABEL_123;
  }
  if (*(unsigned __int16 *)(*(void *)a5 + 3578) * v18) {
    memset(v43, 255, 4 * *(unsigned __int16 *)(*(void *)a5 + 3578) * v18);
  }
  int GenericFeatureLayers = usextract_allocateGenericFeatureLayers(*a1, (uint64_t)"SELECT_BET6", (void *)a5, v18);
  if (GenericFeatureLayers < 0)
  {
    int v42 = GenericFeatureLayers;
    goto LABEL_124;
  }
  int v42 = usextract_Process(*a1, (uint64_t)"SELECT_BET6", a1[2], a2, a3, a5, v45, v46);
  if ((v42 & 0x80000000) == 0)
  {
    if (*(void *)(a5 + 3504))
    {
      unsigned int v47 = **(const char ***)(*(void *)a5 + 3336);
      if (v47)
      {
        uint64_t v48 = 0;
        unsigned int v49 = 1;
        do
        {
          int v50 = cstdlib_strncmp(v47, "INNO_", 5uLL);
          uint64_t v51 = *(void *)a5;
          if (v50)
          {
            BOOL v52 = *(const char ***)(*(void *)(v51 + 3344) + 8 * v48);
            size_t v53 = cstdlib_strlen("FEATIDX");
            unsigned int Index = usextract_getIndex(v52, "FEATIDX", (unint64_t)&aFeatidx[v53]);
            if (Index == -1)
            {
              if (cstdlib_strcmp(*(const char **)(*(void *)(*(void *)a5 + 3336) + 8 * v48), "POS"))
              {
                if (!cstdlib_strcmp(*(const char **)(*(void *)(*(void *)a5 + 3336) + 8 * v48), "PHR")) {
                  *(void *)(a5 + 512) = *(void *)(*(void *)(a5 + 3504) + 8 * v48);
                }
              }
              else
              {
                *(void *)(a5 + 504) = *(void *)(*(void *)(a5 + 3504) + 8 * v48);
              }
            }
            else
            {
              *(void *)(a5
                        + 8 * *(unsigned __int8 *)(*(void *)(*(void *)(*(void *)a5 + 3352) + 8 * v48) + Index)
                        + 16) = *(void *)(*(void *)(a5 + 3504) + 8 * v48);
            }
          }
          else
          {
            unsigned int v55 = cstdlib_atoi((unsigned __int8 *)(*(void *)(*(void *)(v51 + 3336) + 8 * v48) + 5)) + 79;
            if (v55 <= 0x5E) {
              *(void *)(a5 + 8 * v55 + 16) = *(void *)(*(void *)(a5 + 3504) + 8 * v48);
            }
          }
          uint64_t v48 = v49;
          unsigned int v47 = *(const char **)(*(void *)(*(void *)a5 + 3336) + 8 * v49++);
        }
        while (v47);
      }
    }
    int v56 = *(__int16 *)(a5 + 10);
    if (*((_DWORD *)a1 + 12))
    {
      int v57 = nnfeatex_Process(a1 + 7, a2, a3, a5, 0, 0, a6, a7, 1);
      if (v57)
      {
        int v42 = v57 | 0x84E02000;
        log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"SELECT_BET6", 72001, (uint64_t)"%x", v58, v59, v60, v61, v57 | 0x84E02000);
        goto LABEL_124;
      }
      int v42 = 0;
    }
    unsigned int v107 = v56 & ~(v56 >> 31);
    if (log_select_GetLogLevel(*(void *)(v13 + 32)) >= 6)
    {
      LH_itoa(0x4Eu, (char *)v112, 0xAu);
      for (uint64_t j = 0; j != 218; ++j)
      {
        int v63 = "application/x-realspeak-usplosives;version=4.0";
        switch((int)j)
        {
          case 2:
            char v111 = 5;
            char v110 = 0;
            log_OutBinary(*(void *)(v13 + 32), (uint64_t)"SELECT_BET6", 99, 0, (uint64_t)v112, (uint64_t)"text/x-realspeak-usphonemes;charset=tts",
              (uint64_t)&v111,
              1u,
              0);
            log_OutBinary(*(void *)(v13 + 32), (uint64_t)"SELECT_BET6", 99, 0, (uint64_t)v112, (uint64_t)"text/x-realspeak-usphonemes;charset=tts",
              *(void *)(a5 + 8 * j + 16),
              v107,
              0);
            log_OutBinary(*(void *)(v13 + 32), (uint64_t)"SELECT_BET6", 99, 0, (uint64_t)v112, (uint64_t)"text/x-realspeak-usphonemes;charset=tts",
              (uint64_t)&v110,
              1u,
              0);
            continue;
          case 3:
            int v63 = "application/x-realspeak-usdurs;version=4.0";
            goto LABEL_75;
          case 4:
            goto LABEL_75;
          case 5:
            int v63 = "application/x-realspeak-usmarkers-u16;version=4.0";
LABEL_75:
            int v64 = *(unsigned __int8 *)(*(void *)a5 + j + 2748);
            if (v64 == 2)
            {
              log_OutBinary(*(void *)(v13 + 32), (uint64_t)"SELECT_BET6", 99, 0, (uint64_t)v112, (uint64_t)v63, *(void *)(a5 + 8 * j + 1760), 2 * v107, 0);
            }
            else if (v64 == 1)
            {
              log_OutBinary(*(void *)(v13 + 32), (uint64_t)"SELECT_BET6", 99, 0, (uint64_t)v112, (uint64_t)v63, *(void *)(a5 + 8 * j + 16), v107, 0);
            }
            break;
          default:
            continue;
        }
      }
    }
    unint64_t v65 = *(unsigned int *)(a5 + 3520);
    if (v65)
    {
      uint64_t v66 = 0;
      for (unint64_t k = 0; k < v65; ++k)
      {
        uint64_t v68 = *(void *)(a5 + 3512);
        if (*(_DWORD *)(v68 + v66) == 25)
        {
          unsigned int v69 = *(_DWORD *)(v68 + v66 + 24);
          *int v104 = v69;
          int v42 = paramc_ParamSetInt(*(void *)(v13 + 40), (uint64_t)"waitfactor", v69);
          if (v42 < 0)
          {
            uint64_t v101 = *(void *)(v13 + 32);
            goto LABEL_136;
          }
          unint64_t v65 = *(unsigned int *)(a5 + 3520);
        }
        v66 += 32;
      }
    }
    featextract_adjustSilAudioOrder(a5);
    if (!v103) {
      goto LABEL_101;
    }
    int v74 = *(_DWORD *)(a5 + 3520);
    uint64_t v75 = v74 + v107;
    *a9 = v75;
    if (!(v74 + v107)) {
      goto LABEL_101;
    }
    uint64_t v76 = heap_Calloc(*(void **)(v13 + 8), v75, 32);
    *a8 = v76;
    if (v76)
    {
      int v77 = (void *)heap_Calloc(*(void **)(v13 + 8), *(__int16 *)(a5 + 10), 2);
      if (v77)
      {
        uint64_t v78 = (uint64_t)v77;
        cstdlib_memcpy(v77, *(const void **)(a5 + 1800), 2 * *(__int16 *)(a5 + 10));
        if (*a9)
        {
          uint64_t v79 = 0;
          unint64_t v80 = 0;
          unsigned int v81 = 0;
          unint64_t v82 = 0;
          while (v82 < *(unsigned int *)(a5 + 3520))
          {
            if (v81 >= v107)
            {
              uint64_t v88 = (_OWORD *)(*a8 + v79);
              unsigned int v89 = (_OWORD *)(*(void *)(a5 + 3512) + 32 * v82);
              long long v90 = v89[1];
              *uint64_t v88 = *v89;
              v88[1] = v90;
              ++v82;
              goto LABEL_99;
            }
            uint64_t v83 = v81;
            if (!*(_WORD *)(v78 + 2 * v81)) {
              goto LABEL_97;
            }
            unsigned int v84 = (_OWORD *)(*a8 + v79);
            size_t v85 = (_OWORD *)(*(void *)(a5 + 3512) + 32 * v82);
            long long v86 = v85[1];
            *unsigned int v84 = *v85;
            v84[1] = v86;
            ++v82;
            --*(_WORD *)(v78 + 2 * v81);
LABEL_99:
            ++v80;
            v79 += 32;
            if (v80 >= *a9) {
              goto LABEL_100;
            }
          }
          uint64_t v83 = v81;
LABEL_97:
          unint64_t v87 = (_DWORD *)(*a8 + v79);
          *unint64_t v87 = 33;
          v87[6] = *(unsigned __int8 *)(*(void *)(a5 + 32) + v83);
          ++v81;
          goto LABEL_99;
        }
LABEL_100:
        heap_Free(*(void **)(v13 + 8), v78);
LABEL_101:
        if (v56 < 1) {
          goto LABEL_124;
        }
        uint64_t v91 = 0;
        if (v107 <= 1) {
          uint64_t v92 = 1;
        }
        else {
          uint64_t v92 = v107;
        }
        while (1)
        {
          uint64_t v93 = *(void *)(a5 + 248);
          if (!*(unsigned char *)(v93 + v91)) {
            *(unsigned char *)(v93 + v91) = -1;
          }
          uint64_t v94 = *(void *)(a5 + 192);
          if (*(unsigned char *)(*(void *)(a5 + 32) + v91) == 35) {
            char v95 = 1;
          }
          else {
            char v95 = 2 * *(unsigned char *)(v94 + v91);
          }
          *(unsigned char *)(v94 + v91) = v95;
          uint64_t v96 = *(void *)(a5 + 32);
          if ((unsigned __int16)v107 - 1 == v91 && *(unsigned char *)(v96 + v91) == 35)
          {
            v112[0] = 0;
            paramc_ParamGetUInt(*(void *)(v13 + 40), (uint64_t)"finalsentencefound", v112);
            if (v112[0] == 1)
            {
              int v42 = paramc_ParamSetInt(*(void *)(v13 + 40), (uint64_t)"waitfactor", 0);
              if (v42 < 0)
              {
                uint64_t v101 = *(void *)(v13 + 32);
LABEL_136:
                log_OutPublic(v101, (uint64_t)"SELECT_BET6", 72003, (uint64_t)"%s%s%s%d%s%x", v70, v71, v72, v73, "parameter");
                goto LABEL_124;
              }
              int v97 = 0;
              uint64_t v98 = *(void *)(a5 + 1784);
            }
            else
            {
              uint64_t v98 = *(void *)(a5 + 1784);
              int v97 = *(unsigned __int16 *)(v98 + 2 * v91) + 200 * *v104;
            }
            if (v97 <= 1) {
              int v97 = 1;
            }
            if (v97 >= 0xFFFF) {
              LOWORD(v97) = -1;
            }
            *(_WORD *)(v98 + 2 * v91) = v97;
            uint64_t v96 = *(void *)(a5 + 32);
          }
          *(unsigned char *)(v96 + v91) = *(unsigned char *)(a1[4] + *(unsigned __int8 *)(v96 + v91) + 7356);
          if (v92 == ++v91) {
            goto LABEL_124;
          }
        }
      }
    }
LABEL_123:
    int v42 = -2065686518;
    log_OutPublic(*(void *)(v13 + 32), (uint64_t)"SELECT_BET6", 72000, 0, v20, v21, v22, v23, v102);
  }
LABEL_124:
  if (a9 && a8 && v42 < 0 && *a8)
  {
    heap_Free(*(void **)(v13 + 8), *a8);
    *a8 = 0;
    *a9 = 0;
  }
  LODWORD(result) = (*(uint64_t (**)(uint64_t, uint64_t))(a1[2] + 64))(a2, a3);
  if ((int)result >= 0 || v42 <= -1) {
    return v42;
  }
  else {
    return result;
  }
}

uint64_t select_bet6_FeatureExtractProcessEnd(uint64_t *a1, void *a2, uint64_t *a3, _DWORD *a4)
{
  if (!*a2) {
    return 0;
  }
  uint64_t v6 = *a1;
  if (*((_DWORD *)a1 + 12))
  {
    int v7 = nnfeatex_ProcessEnd(a1 + 7, a3, a4);
    if (v7) {
      unsigned int v8 = v7 | 0x84E02000;
    }
    else {
      unsigned int v8 = 0;
    }
    uint64_t v9 = *a1;
  }
  else
  {
    unsigned int v8 = 0;
    uint64_t v9 = *a1;
  }
  unsigned int v11 = usextract_ProcessEnd(v9, (uint64_t)"SELECT_BET6", (uint64_t)a2);
  usextract_freeGenericFeatureLayers((void *)*a1, (uint64_t)"SELECT_BET6", a2);
  uint64_t v16 = 0;
  int v17 = 1;
  do
  {
    int v18 = *(unsigned __int8 *)(*a2 + v16 + 2748);
    if (*(unsigned char *)(*a2 + v16 + 2748))
    {
      if (v18 == 2)
      {
        uint64_t v20 = a2[v16 + 220];
        if (v20) {
LABEL_18:
        }
          heap_Free(*(void **)(v6 + 8), v20);
      }
      else if (v18 == 1)
      {
        if (v17)
        {
          uint64_t v19 = a2[v16 + 2];
          if (v19) {
            heap_Free(*(void **)(v6 + 8), v19);
          }
          int v17 = 0;
        }
      }
      else
      {
        switch((int)v16)
        {
          case '.':
            uint64_t v20 = a2[445];
            if (v20) {
              goto LABEL_18;
            }
            break;
          case '/':
          case '0':
          case '1':
          case '2':
          case '7':
            goto LABEL_27;
          case '3':
            uint64_t v20 = a2[446];
            if (v20) {
              goto LABEL_18;
            }
            break;
          case '4':
            uint64_t v20 = a2[447];
            if (v20) {
              goto LABEL_18;
            }
            break;
          case '5':
            uint64_t v20 = a2[448];
            if (v20) {
              goto LABEL_18;
            }
            break;
          case '6':
            uint64_t v20 = a2[449];
            if (v20) {
              goto LABEL_18;
            }
            break;
          case '8':
            uint64_t v20 = a2[450];
            if (v20) {
              goto LABEL_18;
            }
            break;
          default:
            if (v16 == 24)
            {
              uint64_t v20 = a2[444];
              if (v20) {
                goto LABEL_18;
              }
            }
            else
            {
LABEL_27:
              log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"SELECT_BET6", 72003, (uint64_t)"%s%u", v12, v13, v14, v15, "feature");
            }
            break;
        }
      }
    }
    ++v16;
  }
  while (v16 != 218);
  uint64_t v21 = a2[451];
  if (v21) {
    heap_Free(*(void **)(v6 + 8), v21);
  }
  cstdlib_memset(a2, 0, 8uLL);
  if (v8) {
    return v8;
  }
  else {
    return v11;
  }
}

uint64_t select_bet6_VoiceOpen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 0;
  uint64_t result = 2229280775;
  if (a1 && a2 && a4)
  {
    uint64_t result = objc_GetAddRefCountedObject(*(void *)(a1 + 48), a3, (uint64_t (*)(void, void, uint64_t, _OWORD *, uint64_t))select_bet6_loc_ObjcVoiceOpen, (void (*)(void, void, _OWORD *))select_bet6_loc_ObjcVoiceClose, a2, &v7);
    if ((result & 0x80000000) == 0)
    {
      *(void *)a4 = *(void *)(v7 + 32);
      *(_DWORD *)(a4 + 8) = 135971;
    }
  }
  return result;
}

uint64_t select_bet6_loc_ObjcVoiceOpen(_WORD *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  int v63 = 0;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  memset(__dst, 0, sizeof(__dst));
  uint64_t inited = InitRsrcFunction(a1, a2, &v63);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  cstdlib_memcpy(__dst, v63, 0x1A0uLL);
  long long v39 = *(_OWORD *)(a5 + 32);
  int v64 = 0;
  uint64_t v11 = ssftriff_reader_ObjOpen(a1, a2, 0, a3, "SEL6", 1031, (uint64_t *)&v64);
  if ((v11 & 0x80000000) != 0)
  {
    uint64_t v19 = v11;
    uint64_t v21 = 0;
  }
  else
  {
    uint64_t v19 = 2229280778;
    uint64_t v20 = (void *)heap_Calloc(*((void **)&__dst[0] + 1), 1, 38000);
    uint64_t v21 = (uint64_t)v20;
    if (v20)
    {
      cstdlib_memset(v20, 0, 0x9470uLL);
      cstdlib_strcpy((char *)v21, a3);
      cstdlib_strcpy((char *)(v21 + 9496), a3);
      cstdlib_memset((void *)(v21 + 11488), 255, 0x100uLL);
      cstdlib_memset((void *)(v21 + 12392), 255, 0x11CuLL);
      cstdlib_memset((void *)(v21 + 12720), 255, 0x20uLL);
      *(_DWORD *)(v21 + 11868) = 1;
      cstdlib_memset(__b, 0, 0x50uLL);
      uint64_t v22 = heap_Calloc(*((void **)&__dst[0] + 1), 57, 4);
      if (v22)
      {
        *(void *)(v21 + 9320) = v22;
        *(_DWORD *)(v21 + 9328) = 57;
        if ((fi_rsc_create(__dst, (void *)(v21 + 128)) & 0x80000000) != 0)
        {
          log_OutPublic(v39, (uint64_t)"SELECT_BET6", 72001, (uint64_t)"%s%x", v23, v24, v25, v26, "lhError");
          uint64_t v19 = 2229280776;
        }
        else
        {
          cstdlib_memset((void *)(v21 + 7816), -1, 0x12CuLL);
          uint64_t v19 = select_bet6_ParseRiff((uint64_t)__dst, v21, (uint64_t)v64, 0, (uint64_t)__b);
          if ((v19 & 0x80000000) != 0)
          {
            select_bet6_loc_LogChunkStack((uint64_t)__dst, (uint64_t)a3, __b);
          }
          else
          {
            int v27 = *(uint64_t **)(v21 + 11808);
            if (v27)
            {
              uint64_t v28 = *v27;
              if (v28)
              {
                uint64_t v29 = 0;
                unsigned int v30 = 1;
                do
                {
                  *(void *)(v21 + 8 * v29 + 5440) = v28;
                  uint64_t v29 = v30;
                  uint64_t v28 = *(void *)(*(void *)(v21 + 11808) + 8 * v30++);
                }
                while (v28);
              }
            }
            *(_WORD *)(v21 + 12922) = 1;
            *(void *)&long long v31 = 0x100000001;
            *((void *)&v31 + 1) = 0x100000001;
            *(_OWORD *)(v21 + 12512) = v31;
            *(_OWORD *)(v21 + 12528) = v31;
            *(void *)(v21 + 12544) = 0x100000001;
            *(_DWORD *)(v21 + 12556) = 1;
            *(_OWORD *)(v21 + 12572) = v31;
            *(_OWORD *)(v21 + 12588) = v31;
            *(_OWORD *)(v21 + 12604) = v31;
            *(_OWORD *)(v21 + 12620) = v31;
            *(_OWORD *)(v21 + 12636) = v31;
            *(_DWORD *)(v21 + 12652) = 1;
            *(void *)(v21 + 12656) = 0x100000001;
            *(_DWORD *)(v21 + 12094) = 33620481;
            *(unsigned char *)(v21 + 12121) = 1;
            *(void *)(v21 + 12099) = 0x101010101010101;
            *(void *)(v21 + 12107) = 0x101010101010101;
            *(_DWORD *)(v21 + 12143) = -1;
            *(void *)(v21 + 12157) = 0x101010101010101;
            *(_WORD *)(v21 + 12147) = -255;
            *(void *)(v21 + 12162) = 0x101010101010101;
            *(void *)(v21 + 12265) = 0x101010101010101;
            *(void *)(v21 + 12273) = 0x101010101010101;
            *(void *)(v21 + 12281) = 0x101010101010101;
            if ((*(_DWORD *)(v21 + 12448) & 0x80000000) == 0) {
              *(_WORD *)(v21 + 12123) = 257;
            }
            if ((*(_DWORD *)(v21 + 12464) & 0x80000000) == 0) {
              *(unsigned char *)(v21 + 12125) = 1;
            }
            if ((*(_DWORD *)(v21 + 12480) & 0x80000000) == 0) {
              *(unsigned char *)(v21 + 12126) = 1;
            }
            if ((*(_DWORD *)(v21 + 12484) & 0x80000000) == 0) {
              *(unsigned char *)(v21 + 12127) = 1;
            }
            if ((*(_DWORD *)(v21 + 12488) & 0x80000000) == 0) {
              *(unsigned char *)(v21 + 12128) = 1;
            }
            if ((*(_DWORD *)(v21 + 12492) & 0x80000000) == 0) {
              *(unsigned char *)(v21 + 12129) = 1;
            }
            if ((*(_DWORD *)(v21 + 12736) & 0x80000000) == 0 || (*(_DWORD *)(v21 + 12740) & 0x80000000) == 0) {
              *(unsigned char *)(v21 + 12116) = 8;
            }
            uint64_t v32 = (_WORD *)(v21 + 37744);
            if (*(_DWORD *)(v21 + 11904)) {
              *(unsigned char *)(v21 + 12138) = 9;
            }
            *(_WORD *)(v21 + 12168) = 257;
            *(void *)(v21 + 12157) = 0x101010101010101;
            *(_WORD *)(v21 + 12165) = 257;
            *(_DWORD *)(v21 + 7944) = 4000;
            *(_OWORD *)(v21 + 7928) = xmmword_220775700;
            cstdlib_memset((void *)(v21 + 8208), 0, 0x400uLL);
            uint64_t v33 = cstdlib_strlen((const char *)(v21 + 9946));
            if (v33)
            {
              uint64_t v34 = (unsigned __int8 *)(v21 + 9946);
              do
              {
                if (*(unsigned char *)(v21 + *v34 + 7492)) {
                  *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)(v21 + *v34 + 7492) + 8208) = (v34[257] & 0xDF) == 86;
                }
                ++v34;
                --v33;
              }
              while (v33);
            }
            uint64_t v35 = *(void *)(v21 + 37752);
            if (v35)
            {
              LODWORD(v35) = (unsigned __int16)*v32;
              if (*v32)
              {
                uint64_t v35 = *(void *)(v21 + 37760);
                if (v35) {
                  LODWORD(v35) = *(_WORD *)(v21 + 37768) != 0;
                }
              }
            }
            *(_DWORD *)(v21 + 37776) = v35;
          }
        }
      }
    }
  }
  if (v64)
  {
    ssftriff_reader_ObjClose(v64, v12, v13, v14, v15, v16, v17, v18);
    int v64 = 0;
  }
  if ((v19 & 0x80000000) != 0)
  {
    if ((v19 & 0x7FF00000) == 0xA200000)
    {
      if ((v19 & 0x1FFF) == 0x14) {
        uint64_t v36 = 72002;
      }
      else {
        uint64_t v36 = 72003;
      }
      log_OutPublic(v39, (uint64_t)"SELECT_BET6", v36, (uint64_t)"%s%x", v15, v16, v17, v18, "lhError");
      uint64_t v19 = (v19 & 0x1FFF) - 2065686528;
    }
    else if ((v19 & 0x1FFD | 2) != 0xA)
    {
      log_OutPublic(v39, (uint64_t)"SELECT_BET6", 72003, (uint64_t)"%s%x", v15, v16, v17, v18, "lhError");
    }
    select_bet6_loc_VoiceClose(__dst, (char *)v21);
  }
  else
  {
    *(void *)(a4 + 32) = v21;
  }
  return v19;
}

uint64_t select_bet6_loc_ObjcVoiceClose(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v6);
  if ((inited & 0x80000000) == 0) {
    select_bet6_loc_VoiceClose(v6, *(char **)(a3 + 32));
  }
  return inited;
}

uint64_t select_bet6_VoiceClose(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = 2229280775;
  if (!a1 || !a2) {
    return v2;
  }
  if ((safeh_HandleCheck(*a2, a2[1], 135971, 38000) & 0x80000000) != 0) {
    return 2229280776;
  }
  uint64_t v5 = *a2;
  if (!*a2) {
    return 2229281036;
  }
  uint64_t v6 = *(void *)(a1 + 48);

  return objc_ReleaseObject(v6, v5);
}

uint64_t select_bet6_GetSirenVoice(uint64_t *a1)
{
  if ((safeh_HandleCheck(*a1, a1[1], 135971, 38000) & 0x80000000) != 0) {
    return 0;
  }
  if (*a1) {
    return *a1 + 128;
  }
  return 0;
}

uint64_t select_bet6_GetVoiceBrkString(uint64_t *a1)
{
  if ((safeh_HandleCheck(*a1, a1[1], 135971, 38000) & 0x80000000) != 0) {
    return 0;
  }
  else {
    return *a1;
  }
}

uint64_t select_bet6_ParseRiff(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = (const char *)a5;
  uint64_t v6 = a4;
  uint64_t v9 = a1;
  uint64_t v141 = *MEMORY[0x263EF8340];
  int v10 = (unsigned __int16 *)(a2 + 37744);
  uint64_t v126 = a2 + 8204;
  unsigned int v134 = 0;
  char v133 = 0;
  *(_DWORD *)__src = 0;
  uint64_t v11 = (char *)(a5 + 5 * a4);
  uint64_t v119 = (uint64_t *)(a2 + 37760);
  BOOL v114 = (void *)(a2 + 7492);
  unsigned int v120 = (void *)(a2 + 11844);
  uint64_t v110 = a2 + 8184;
  uint64_t v112 = a2 + 8168;
  uint64_t v115 = a2 + 8152;
  uint64_t v118 = a2 + 8120;
  uint64_t v117 = a2 + 8136;
  uint64_t v123 = (void *)(a2 + 7792);
  int v108 = (uint64_t *)(a2 + 11808);
  uint64_t v109 = (unsigned char *)(a2 + 11744);
  char v111 = (unsigned char *)(a2 + 10717);
  uint64_t v113 = (unsigned char *)(a2 + 10460);
  uint64_t v116 = (unsigned char *)(a2 + 10203);
  long long __s1 = (char *)(a5 + 5);
  __s = (char *)(a2 + 9946);
  int v128 = (unsigned __int16 *)(a2 + 37744);
  unint64_t v127 = v11;
  while (1)
  {
    uint64_t v12 = ssftriff_reader_OpenChunk(a3, (__int32 *)__src, &v134, 0);
    if ((v12 & 0x80000000) != 0) {
      goto LABEL_413;
    }
    cstdlib_strcpy(v11, __src);
    if (v6 == 1) {
      break;
    }
    if (v6)
    {
      if (cstdlib_strcmp(v5, "FEEX") || cstdlib_strcmp(__s1, "VCAT")) {
        goto LABEL_403;
      }
      unsigned int v17 = v134;
      v138[0] = 0;
      LODWORD(v12) = ssftriff_reader_GetChunkData(a3, v134, v138);
      if ((v12 & 0x80000000) != 0) {
        goto LABEL_400;
      }
      if (!cstdlib_strcmp(__src, "ALPH"))
      {
        LODWORD(__s2[0]) = 257;
        LODWORD(v12) = ssftriff_reader_ReadStringZ(a3, (uint64_t)v138[0], v17, 0, __s, (unsigned int *)__s2);
        if ((v12 & 0x80000000) == 0)
        {
          *(_WORD *)(v126 + 3636) = 255;
          if (cstdlib_strlen(__s))
          {
            uint64_t v93 = 0;
            unsigned int v94 = 1;
            do
            {
              char v95 = (unsigned __int8 *)(a2 + v93 + 9946);
              unsigned int v96 = *v95;
              if (v96 < *(unsigned __int8 *)(v126 + 3636))
              {
                *(unsigned char *)(v126 + 3636) = v96;
                unsigned int v96 = *v95;
              }
              if (v96 > *(unsigned __int8 *)(v126 + 3637))
              {
                *(unsigned char *)(v126 + 3637) = v96;
                unsigned int v96 = *v95;
              }
              *(unsigned char *)(a2 + v96 + 11488) = v94 - 1;
              uint64_t v93 = v94;
              BOOL v105 = cstdlib_strlen(__s) > v94++;
            }
            while (v105);
          }
        }
        uint64_t v9 = a1;
        goto LABEL_404;
      }
      if (cstdlib_strcmp(__src, "VOIC"))
      {
        if (cstdlib_strcmp(__src, "COVO"))
        {
          if (cstdlib_strcmp(__src, "PLOS"))
          {
            if (cstdlib_strcmp(__src, "DIFF"))
            {
              if (cstdlib_strcmp(__src, "TAGA")) {
                goto LABEL_37;
              }
              int RiffStringTable = uselect_LoadRiffStringTable(v9, a3, (_WORD *)v138[0], v17, v108);
LABEL_399:
              LODWORD(v12) = RiffStringTable;
LABEL_400:
              int v18 = 1;
              goto LABEL_402;
            }
            LODWORD(__s2[0]) = 64;
            uint64_t v99 = v138[0];
            uint64_t v100 = a3;
            unsigned int v101 = v17;
            unsigned int v102 = v109;
          }
          else
          {
            LODWORD(__s2[0]) = 257;
            uint64_t v99 = v138[0];
            uint64_t v100 = a3;
            unsigned int v101 = v17;
            unsigned int v102 = v111;
          }
        }
        else
        {
          LODWORD(__s2[0]) = 257;
          uint64_t v99 = v138[0];
          uint64_t v100 = a3;
          unsigned int v101 = v17;
          unsigned int v102 = v113;
        }
      }
      else
      {
        LODWORD(__s2[0]) = 257;
        uint64_t v99 = v138[0];
        uint64_t v100 = a3;
        unsigned int v101 = v17;
        unsigned int v102 = v116;
      }
      int RiffStringTable = ssftriff_reader_ReadStringZ(v100, (uint64_t)v99, v101, 0, v102, (unsigned int *)__s2);
      goto LABEL_399;
    }
    if (!cstdlib_strcmp(__src, "VCFG"))
    {
      unsigned int v19 = v134;
      unsigned int v137 = 0;
      *(void *)uint64_t v135 = 0;
      uint64_t v136 = 0;
      int ChunkData = ssftriff_reader_GetChunkData(a3, v134, v135);
      if (ChunkData < 0) {
        goto LABEL_377;
      }
      uint64_t v21 = heap_StrDup(*(void **)(v9 + 8), "PHRASE");
      *(void *)(a2 + 216) = v21;
      LODWORD(v12) = -2065686518;
      if (v21)
      {
        *(_DWORD *)(a2 + 224) = 1000;
        if (v19)
        {
          unsigned int v22 = 0;
          while (1)
          {
            LOBYTE(v138[0]) = 0;
            LOBYTE(__s2[0]) = 0;
            unsigned int v137 = 64;
            int v23 = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v135, v19, v22, __s2, &v137);
            if (v23 < 0) {
              break;
            }
            unsigned int v24 = v137 + v22;
            unsigned int v137 = 256;
            int ChunkData = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v135, v19, v24, v138, &v137);
            if (ChunkData < 0) {
              goto LABEL_371;
            }
            unsigned int v25 = v137;
            cstdlib_strcpy(__dst, "bet3voiceoverride.");
            cstdlib_strcat(__dst, (const char *)__s2);
            if ((paramc_ParamGetStr(*(void *)(v9 + 40), (uint64_t)__dst, &v136) & 0x80000000) != 0 || !v136 || !*v136) {
              uint64_t v136 = (char *)v138;
            }
            if (!cstdlib_strcmp((const char *)__s2, "ALPHA")) {
              *(_DWORD *)(a2 + 136) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "BETA")) {
              *(_DWORD *)(a2 + 140) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "VUV_REL_AMP")) {
              *(_DWORD *)(a2 + 148) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "VOL")) {
              *(_DWORD *)(a2 + 172) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "MVF_BOOST")) {
              *(_DWORD *)(a2 + 176) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "FS")) {
              *(_DWORD *)(a2 + 144) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "ORDER")) {
              *(_DWORD *)(a2 + 152) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "FRAME_SIZE")) {
              *(_DWORD *)(a2 + 160) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SPEECH_F0_MEAN")) {
              *(_DWORD *)(a2 + 192) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "PDF_VARIANCE_TYPE")) {
              *(_DWORD *)(a2 + 208) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "BREAKER"))
            {
              uint64_t v26 = *(void *)(a2 + 216);
              if (v26) {
                heap_Free(*(void **)(v9 + 8), v26);
              }
              int v27 = heap_StrDup(*(void **)(v9 + 8), v136);
              *(void *)(a2 + 216) = v27;
              if (!v27)
              {
                LODWORD(v12) = -2065686518;
                goto LABEL_378;
              }
            }
            if (!cstdlib_strcmp((const char *)__s2, "BRK_LENGTH")) {
              *(_DWORD *)(a2 + 224) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "BRK_TC")) {
              *(_DWORD *)(a2 + 228) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "BRK_ZPAD")) {
              *(_DWORD *)(a2 + 232) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "ALGN_ST")) {
              *(_DWORD *)(a2 + 248) = LH_atoi(v136) != 0;
            }
            if (!cstdlib_strcmp((const char *)__s2, "ALGN_PH")) {
              *(_DWORD *)(a2 + 252) = LH_atoi(v136) != 0;
            }
            if (!cstdlib_strcmp((const char *)__s2, "VSYNTH")) {
              *(void *)(a2 + 7784) = heap_StrDup(*(void **)(v9 + 8), v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "FFTSZ")) {
              *(_DWORD *)(a2 + 7816) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "EN_MEAN")) {
              *(_DWORD *)(a2 + 7820) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "FEED_EN_MEAN_LOOKAHEAD")) {
              *(_DWORD *)(a2 + 7828) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "COUNT_UV_DISTANCE")) {
              *(_DWORD *)(a2 + 7824) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SAMPLE_RATE")) {
              *(_DWORD *)(a2 + 7832) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "AMPPAR_ENERGY")) {
              *(_DWORD *)(a2 + 7836) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "AMPPAR_SIZE")) {
              *(_DWORD *)(a2 + 7840) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SPCPAR_FREQWARP")) {
              *(_DWORD *)(a2 + 7844) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "AMPPAR_ENHANCE_ALPHA")) {
              *(_DWORD *)(a2 + 7848) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "AMPPAR_ENHANCE_ALPHA_UNVOICED")) {
              *(_DWORD *)(a2 + 7852) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "FRAME_SIZE_MRCC")) {
              *(_DWORD *)(a2 + 7856) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_PHS_EXTRAP_USE")) {
              *(_DWORD *)(a2 + 7860) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_NOISE_FREQ_TH")) {
              *(_DWORD *)(a2 + 7864) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_FREQNOISE_USE")) {
              *(_DWORD *)(a2 + 7868) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_FREQNOISE_MVF_USE")) {
              *(_DWORD *)(a2 + 7872) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_FREQNOISE_LO")) {
              *(_DWORD *)(a2 + 7876) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_FREQNOISE_HI")) {
              *(_DWORD *)(a2 + 7880) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_AUXNOISE_UNIFORM")) {
              *(_DWORD *)(a2 + 7884) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_AUXNOISE_USE")) {
              *(_DWORD *)(a2 + 7888) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_AUXNOISE_MVF_USE")) {
              *(_DWORD *)(a2 + 7892) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_AUXNOISE_MIXHARM_LO")) {
              *(_DWORD *)(a2 + 7896) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_AUXNOISE_MIXHARM_HI")) {
              *(_DWORD *)(a2 + 7900) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_AUXNOISE_RES_LO")) {
              *(_DWORD *)(a2 + 7904) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_AUXNOISE_RES_HI")) {
              *(_DWORD *)(a2 + 7908) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_ALIGN_CUTOFF_FREQ")) {
              *(_DWORD *)(a2 + 7912) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_DEBUZZ_PROCESS_MVF")) {
              *(_DWORD *)(a2 + 7916) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "AMPPAR_ATTENUATE_UV")) {
              *(_DWORD *)(a2 + 7920) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_SKIP_WEAK_HARM_RATIO")) {
              *(_DWORD *)(a2 + 7924) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_DEBUZZ_PROCESS_MVF_SMOOTH_WIN")) {
              *(_DWORD *)(a2 + 7948) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_DEBUZZ_PROCESS_MVF_LOW_EN_THR")) {
              *(_DWORD *)(a2 + 7952) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_DEBUZZ_PROCESS_MVF_RATIO_EN_THR")) {
              *(_DWORD *)(a2 + 7956) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_DEBUZZ_PROCESS_MVF_LOW_EN_MVF_THR")) {
              *(_DWORD *)(a2 + 7960) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_DEBUZZ_PROCESS_MVF_BY_LOW_EN")) {
              *(_DWORD *)(a2 + 7964) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_DEBUZZ_PROCESS_MVF_BY_RATIO_EN")) {
              *(_DWORD *)(a2 + 7968) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_DEBUZZ_PROCESS_MVF_0")) {
              *(_DWORD *)(a2 + 7972) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_DEBUZZ_PROCESS_MVF_1")) {
              *(_DWORD *)(a2 + 7976) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_DEBUZZ_PROCESS_MVF_2")) {
              *(_DWORD *)(a2 + 7980) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_DEBUZZ_PROCESS_MVF_3")) {
              *(_DWORD *)(a2 + 7984) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "AMPPAR_BITS")) {
              *(_DWORD *)(a2 + 7988) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "PHSPAR_USE")) {
              *(_DWORD *)(a2 + 7992) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "AMPPAR_USE")) {
              *(_DWORD *)(a2 + 7996) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "USE_LOG2")) {
              *(_DWORD *)(a2 + 8000) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "AMPPAR_ENHANCE_POWSPC")) {
              *(_DWORD *)(a2 + 8004) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_AUXNOISE_ATTENUATE")) {
              *(_DWORD *)(a2 + 8008) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_AUXNOISE_ATTENUATE_LO")) {
              *(_DWORD *)(a2 + 8012) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_AUXNOISE_ATTENUATE_HI")) {
              *(_DWORD *)(a2 + 8016) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_APPLY_DEEMP")) {
              *(_DWORD *)(a2 + 8020) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_HI_RES_ALIGN")) {
              *(_DWORD *)(a2 + 8024) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_FAST_AUX_HARM")) {
              *(_DWORD *)(a2 + 8028) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_FIX_OLA")) {
              *(_DWORD *)(a2 + 8032) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_DC_GUARD_VOICED")) {
              *(_DWORD *)(a2 + 8036) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_DC_GUARD_UNVOICED")) {
              *(_DWORD *)(a2 + 8040) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_NYQUIST_GUARD")) {
              *(_DWORD *)(a2 + 8044) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "PHSPAR_SIZE")) {
              *(_DWORD *)(a2 + 8048) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "PHSPAR_FLIP")) {
              *(_DWORD *)(a2 + 8052) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "AMPPAR_ENERGY_NORM_TH")) {
              *(_DWORD *)(a2 + 8056) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SPCPAR_FREQWARP_ALPHA")) {
              *(_DWORD *)(a2 + 8060) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_PHS_ALIGN_WITH_CONST")) {
              *(_DWORD *)(a2 + 8064) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_AUXNOISE_NORM_GLOBAL")) {
              *(_DWORD *)(a2 + 8068) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_DEEMP_COEF")) {
              *(_DWORD *)(a2 + 8072) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_USE_NOISE_MODULATION")) {
              *(_DWORD *)(a2 + 8076) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "SYN_NOISE_MODULATION_FACTOR")) {
              *(_DWORD *)(a2 + 8080) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "MAX_FRAME_SIZE")) {
              *(_DWORD *)(a2 + 8084) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "MIN_FRAME_SIZE")) {
              *(_DWORD *)(a2 + 8088) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "MIN_FFT_SIZE")) {
              *(_DWORD *)(a2 + 8092) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "FRAME_SIZE_INC_NUM")) {
              *(_DWORD *)(a2 + 8096) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "FRAME_SIZE_DEC_NUM")) {
              *(_DWORD *)(a2 + 8100) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "ANAL_FFT_SIZE")) {
              *(_DWORD *)(a2 + 8104) = LH_atoi(v136);
            }
            if (!cstdlib_strcmp((const char *)__s2, "FFT_SIZE")) {
              *(_DWORD *)(a2 + 8108) = LH_atoi(v136);
            }
            unsigned int v22 = v25 + v24;
            if (v22 >= v19) {
              goto LABEL_371;
            }
          }
          int ChunkData = v23;
        }
LABEL_371:
        *(_WORD *)(a2 + 168) = 0;
        *(_WORD *)(a2 + 180) = 0;
        *(void *)(a2 + 184) = 0;
        cstdlib_strcpy(__dst, "bet3voiceoverride.");
        cstdlib_strcat(__dst, "BREAKER");
        if ((paramc_ParamGetStr(*(void *)(v9 + 40), (uint64_t)__dst, &v136) & 0x80000000) == 0)
        {
          uint64_t v97 = *(void *)(a2 + 216);
          if (v97)
          {
            heap_Free(*(void **)(v9 + 8), v97);
            *(void *)(a2 + 216) = 0;
          }
          uint64_t v98 = heap_StrDup(*(void **)(v9 + 8), v136);
          *(void *)(a2 + 216) = v98;
          LODWORD(v12) = -2065686518;
          if (!v98) {
            goto LABEL_378;
          }
        }
        cstdlib_strcpy(__dst, "bet3voiceoverride.");
        cstdlib_strcat(__dst, "BRK_LENGTH");
        if ((paramc_ParamGetStr(*(void *)(v9 + 40), (uint64_t)__dst, &v136) & 0x80000000) == 0) {
          *(_DWORD *)(a2 + 224) = LH_atoi(v136);
        }
LABEL_377:
        LODWORD(v12) = ChunkData;
      }
LABEL_378:
      uint64_t v11 = v127;
      int v10 = v128;
      goto LABEL_404;
    }
    if (!cstdlib_strcmp(__src, "EQUA"))
    {
      LODWORD(v12) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v10[124] + 37784), v123);
      if ((v12 & 0x80000000) == 0) {
        ++v10[124];
      }
      goto LABEL_404;
    }
    if (!cstdlib_strcmp(__src, "FEEX") || !cstdlib_strcmp(__src, "NNFE"))
    {
      uint64_t v29 = v9;
      uint64_t v30 = a2;
      uint64_t v31 = a3;
      uint64_t v32 = 1;
      goto LABEL_235;
    }
    int64_t v13 = v134;
    *(void *)uint64_t __dst = 0;
    LODWORD(v12) = ssftriff_reader_GetChunkData(a3, v134, __dst);
    if ((v12 & 0x80000000) != 0) {
      goto LABEL_400;
    }
    if (cstdlib_strcmp(__src, "B6PM"))
    {
      if (cstdlib_strcmp(__src, "B6DF") && cstdlib_strcmp(__src, "B6AF"))
      {
        if (!cstdlib_strcmp(__src, "B6DM") || !cstdlib_strcmp(__src, "B6AM") || !cstdlib_strcmp(__src, "B6VM"))
        {
          uint64_t v14 = v115;
          if (cstdlib_strcmp(__src, "B6DM"))
          {
            uint64_t v14 = v112;
            if (cstdlib_strcmp(__src, "B6AM"))
            {
              *(_DWORD *)(a2 + 9240) = 1;
              uint64_t v14 = v110;
            }
          }
          uint64_t v15 = *(void *)(a2 + 128);
          if (v15)
          {
            uint64_t v16 = (void *)(**(uint64_t (***)(void, int64_t))(v15 + 8))(*(void *)(v15 + 16), v13);
            *(void *)uint64_t v14 = v16;
            if (!v16)
            {
              int v18 = 1;
              LODWORD(v12) = -2065686518;
              goto LABEL_402;
            }
            cstdlib_memcpy(v16, *(const void **)__dst, v13);
            *(_DWORD *)(v14 + 8) = v13;
          }
          else
          {
            LODWORD(v12) = -2065686521;
          }
          int v18 = 1;
          goto LABEL_402;
        }
LABEL_37:
        int v18 = 0;
        goto LABEL_402;
      }
      long long v52 = v5;
      int v53 = cstdlib_strcmp(__src, "B6DF");
      uint64_t v54 = 8120;
      if (v53) {
        uint64_t v54 = 8136;
      }
      uint64_t v121 = v54;
      uint64_t v55 = v118;
      if (v53) {
        uint64_t v55 = v117;
      }
      *(void *)int v131 = v55;
      uint64_t v56 = *(void *)__dst;
      unint64_t v57 = **(_DWORD **)__dst;
      int v58 = *(_DWORD *)(*(void *)__dst + 4);
      uint64_t v59 = heap_Calloc(*(void **)(v9 + 8), v57, 16);
      LODWORD(v12) = -2065686518;
      if (v59)
      {
        int v63 = 0;
        uint64_t v64 = v56 + 8;
        LODWORD(v65) = 0;
        if (v13 >= 0x18 && v57)
        {
          uint64_t v66 = 0;
          unint64_t v65 = 0;
          int v63 = 0;
          do
          {
            int v67 = (_DWORD *)(v59 + v66);
            *int v67 = *(_DWORD *)(v56 + v66 + 8);
            int v68 = *(_DWORD *)(v56 + v66 + 12);
            v67[1] = v68;
            int v69 = *(_DWORD *)(v56 + v66 + 16);
            v67[2] = v69;
            v67[3] = *(_DWORD *)(v56 + v66 + 20);
            if (v68) {
              int v70 = v69;
            }
            else {
              int v70 = 1;
            }
            v63 += v70;
            ++v65;
            uint64_t v71 = v66 + 16;
            if (v65 >= v57) {
              break;
            }
            int64_t v72 = v66 + 40;
            v66 += 16;
          }
          while (v72 <= v13);
          uint64_t v64 = v56 + v71 + 8;
        }
        if (v65 == v57 && v64 - v56 == v13 && v63 == v58)
        {
          LODWORD(v12) = 0;
          *(void *)(a2 + v121) = v59;
          int v18 = 1;
          *(_DWORD *)(*(void *)v131 + 8) = v57;
          *(_DWORD *)(*(void *)v131 + 12) = v58;
LABEL_389:
          uint64_t v5 = v52;
          uint64_t v11 = v127;
          int v10 = v128;
          goto LABEL_402;
        }
        heap_Free(*(void **)(v9 + 8), v59);
        LODWORD(v12) = -2065686262;
      }
      log_OutText(*(void *)(v9 + 32), (uint64_t)"SELECT_BET6", 3, 0, (uint64_t)"Error parsing Siren NN feature list (chunk %s)", v60, v61, v62, (uint64_t)__src);
      int v18 = 1;
      goto LABEL_389;
    }
    unsigned int v107 = v5;
    memset(__s2, 0, sizeof(__s2));
    if ((int)v13 < 1) {
      goto LABEL_394;
    }
    signed int v73 = 0;
    unsigned int v122 = -1;
    uint64_t v130 = v6;
    while (1)
    {
      LODWORD(v136) = 64;
      int StringZ = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)__dst, v13, v73, v138, (unsigned int *)&v136);
      if (StringZ < 0) {
        break;
      }
      unsigned int v75 = v136 + v73;
      LODWORD(v136) = 64;
      LODWORD(v12) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)__dst, v13, v75, __s2, (unsigned int *)&v136);
      if ((v12 & 0x80000000) != 0) {
        goto LABEL_393;
      }
      int v76 = (int)v136;
      uint64_t v6 = v130;
      if (!cstdlib_strcmp((const char *)v138, "SILENCE_DURATION")) {
        unsigned int v122 = LH_atoi((const char *)__s2);
      }
      if (!cstdlib_strcmp((const char *)v138, "SILENCE_DURATION") && v122 != -1)
      {
        *(_DWORD *)(a2 + 8200) = 1;
        *(_WORD *)uint64_t v126 = v122;
      }
      if (!cstdlib_strcmp((const char *)v138, "ACOUSTIC_INFERENCE_OVERLAP_NFRAMES")) {
        *(_DWORD *)(a2 + 9280) = LH_atoi((const char *)__s2);
      }
      if (!cstdlib_strcmp((const char *)v138, "VOCODER_OVERLAP_NFRAMES")) {
        *(_DWORD *)(a2 + 9284) = LH_atoi((const char *)__s2);
      }
      if (!cstdlib_strcmp((const char *)v138, "REAL_TIME_FACTOR"))
      {
        cstdlib_atof((unsigned __int8 *)__s2);
        *(float *)&double v77 = v77;
        *(_DWORD *)(a2 + 9288) = LODWORD(v77);
      }
      if (!cstdlib_strcmp((const char *)v138, "LATENCY")) {
        *(_DWORD *)(a2 + 9292) = LH_atou((const char *)__s2);
      }
      if (!cstdlib_strcmp((const char *)v138, "NNVOCODER_OVERLAP_NFRAMES")) {
        *(_DWORD *)(a2 + 9300) = LH_atou((const char *)__s2);
      }
      if (!cstdlib_strcmp((const char *)v138, "NNVOCODER_REAL_TIME_FACTOR"))
      {
        cstdlib_atof((unsigned __int8 *)__s2);
        *(float *)&double v78 = v78;
        *(_DWORD *)(a2 + 9304) = LODWORD(v78);
      }
      if (!cstdlib_strcmp((const char *)v138, "NNVOCODER_LATENCY")) {
        *(_DWORD *)(a2 + 9308) = LH_atou((const char *)__s2);
      }
      if (!cstdlib_strcmp((const char *)v138, "NNVOCODER_THREADSN")) {
        *(_DWORD *)(a2 + 9296) = LH_atou((const char *)__s2);
      }
      if (!cstdlib_strcmp((const char *)v138, "NNVOCODER_BCHUNKING")) {
        *(_DWORD *)(a2 + 9312) = LH_atoi((const char *)__s2) != 0;
      }
      if (!cstdlib_strcmp((const char *)v138, "NNVOCODER_HOPSIZE")) {
        *(_DWORD *)(a2 + 9316) = LH_atou((const char *)__s2);
      }
      if (!cstdlib_strcmp((const char *)v138, "ACOUSTIC_OUTPUT_DIM")) {
        *(_DWORD *)(a2 + 9332) = LH_atou((const char *)__s2);
      }
      if (!cstdlib_strcmp((const char *)v138, "N_FRAME_INFERENCE")) {
        *(_DWORD *)(a2 + 9336) = LH_atou((const char *)__s2);
      }
      if (!cstdlib_strcmp((const char *)v138, "B_NN_SYNTH")) {
        *(_DWORD *)(a2 + 9240) = LH_atoi((const char *)__s2) != 0;
      }
      if (!cstdlib_strcmp((const char *)v138, "B_SEQ2SEQ_ACOUSTIC")) {
        *(_DWORD *)(a2 + 9244) = LH_atoi((const char *)__s2) != 0;
      }
      if (!cstdlib_strcmp((const char *)v138, "B_SEQ2SEQ_NNVOCODER")) {
        *(_DWORD *)(a2 + 9248) = LH_atoi((const char *)__s2) != 0;
      }
      if (!cstdlib_strcmp((const char *)v138, "B_SEQ2SEQ_NNVOCODER_MULTIBAND")) {
        *(_DWORD *)(a2 + 9252) = LH_atoi((const char *)__s2) != 0;
      }
      if (!cstdlib_strcmp((const char *)v138, "B_PARALLEL_NNVOCODER")) {
        *(_DWORD *)(a2 + 9256) = LH_atoi((const char *)__s2) != 0;
      }
      if (!cstdlib_strcmp((const char *)v138, "B_TACOTRON_STREAM_DECODER")) {
        *(_DWORD *)(a2 + 9260) = LH_atoi((const char *)__s2) != 0;
      }
      if (!cstdlib_strcmp((const char *)v138, "B_CHUNK_SEARCH_BACKWARDS")) {
        *(_DWORD *)(a2 + 9276) = LH_atoi((const char *)__s2) != 0;
      }
      if (!cstdlib_strcmp((const char *)v138, "TACOTRON_PHONE2FRAME_SCALE")) {
        *(_DWORD *)(a2 + 9264) = LH_atou((const char *)__s2);
      }
      if (!cstdlib_strcmp((const char *)v138, "TACOTRON_PCM_SIL_THRESHOLD")) {
        *(_DWORD *)(a2 + 9268) = LH_atou((const char *)__s2);
      }
      if (!cstdlib_strcmp((const char *)v138, "TACOTRON_CHUNK_SEARCH_PHONES")) {
        *(_DWORD *)(a2 + 9272) = LH_atou((const char *)__s2);
      }
      signed int v73 = v76 + v75;
      if (!cstdlib_strcmp((const char *)v138, "FIR_TAP_NUM"))
      {
        uint64_t v79 = *(void *)__dst;
        unsigned int v80 = LH_atou((const char *)__s2);
        unsigned int v81 = v80;
        if (v80 <= *(_DWORD *)(a2 + 9328))
        {
          *(_DWORD *)(a2 + 9328) = v80;
          if (v80)
          {
            uint64_t v83 = v80;
LABEL_345:
            uint64_t v84 = 0;
            do
            {
              LODWORD(v136) = 64;
              int v85 = ssftriff_reader_ReadStringZ(a3, v79, v13, v73, v138, (unsigned int *)&v136);
              if ((v85 & 0x80000000) == 0)
              {
                v73 += (int)v136;
                LODWORD(v136) = 64;
                int v85 = ssftriff_reader_ReadStringZ(a3, v79, v13, v73, __s2, (unsigned int *)&v136);
              }
              int v86 = v85;
              cstdlib_atof((unsigned __int8 *)__s2);
              *(float *)&double v87 = v87;
              *(_DWORD *)(*(void *)(a2 + 9320) + 4 * v84) = LODWORD(v87);
              uint64_t v6 = v130;
              if (v86 < 0) {
                break;
              }
              ++v84;
              int v88 = (int)v136;
              if (v73 >= (int)v13) {
                int v88 = 0;
              }
              v73 += v88;
            }
            while (v83 != v84);
          }
        }
        else
        {
          uint64_t v82 = heap_Realloc(*(uint64_t **)(v9 + 8), *(void *)(a2 + 9320), 4 * v80);
          *(void *)(a2 + 9320) = v82;
          if (v82)
          {
            uint64_t v83 = v81;
            *(_DWORD *)(a2 + 9328) = v81;
            goto LABEL_345;
          }
        }
      }
      int v10 = v128;
      uint64_t v9 = a1;
      uint64_t v11 = v127;
      if (v73 >= (int)v13) {
        goto LABEL_394;
      }
    }
    LODWORD(v12) = StringZ;
LABEL_393:
    uint64_t v6 = v130;
LABEL_394:
    int v18 = 1;
    uint64_t v5 = v107;
LABEL_402:
    if (!v18) {
LABEL_403:
    }
      select_bet6_loc_LogChunkStack(v9, a2, v5);
LABEL_404:
    int v104 = ssftriff_reader_CloseChunk(a3);
    BOOL v105 = (int)v12 > -1 && v104 < 0;
    if (v105) {
      uint64_t v12 = v104;
    }
    else {
      uint64_t v12 = v12;
    }
    if ((v12 & 0x80000000) != 0)
    {
LABEL_413:
      if ((v12 & 0x1FFF) == 0x14)
      {
        uint64_t v12 = 0;
        *uint64_t v11 = 0;
      }
      return v12;
    }
  }
  if (!cstdlib_strcmp(v5, "FEEX"))
  {
    if (!cstdlib_strcmp(__src, "VCAT"))
    {
      v138[0] = 0;
      uint64_t v33 = ssftriff_reader_GetChunkData(a3, v134, v138);
      if ((v33 & 0x80000000) != 0) {
        return v33;
      }
      uint64_t v29 = v9;
      uint64_t v30 = a2;
      uint64_t v31 = a3;
      uint64_t v32 = 2;
LABEL_235:
      LODWORD(v12) = select_bet6_ParseRiff(v29, v30, v31, v32, v5);
      goto LABEL_404;
    }
    unsigned int v28 = v134;
    if (cstdlib_strcmp(__src, "VBOP"))
    {
      if (cstdlib_strcmp(__src, "PRE3"))
      {
        if (cstdlib_strcmp(__src, "TRA3"))
        {
          uint64_t v9 = a1;
          if (cstdlib_strcmp(__src, "PHM3"))
          {
            LODWORD(v12) = 0;
            goto LABEL_403;
          }
          v138[0] = 0;
          LODWORD(v12) = ssftriff_reader_GetChunkData(a3, v28, v138);
          if ((v12 & 0x80000000) != 0) {
            goto LABEL_404;
          }
          uint64_t v34 = v138[0];
          if (v28 >= 0x100) {
            size_t v35 = 256;
          }
          else {
            size_t v35 = v28;
          }
          uint64_t v36 = v114;
LABEL_241:
          cstdlib_memcpy(v36, v34, v35);
          goto LABEL_404;
        }
        LOWORD(__s2[0]) = 0;
        v138[0] = 0;
        LODWORD(v12) = ssftriff_reader_GetChunkData(a3, v28, v138);
        if ((v12 & 0x80000000) == 0 && v28 >= 2)
        {
          unsigned __int16 v89 = 0;
          do
          {
            cstdlib_memcpy(__s2, (char *)v138[0] + 2 * v89, 2uLL);
            if (LOWORD(__s2[0]) < 8u) {
              *(_DWORD *)(a2 + 4 * LOWORD(__s2[0]) + 12720) = 1;
            }
            else {
              log_OutText(*(void *)(a1 + 32), (uint64_t)"SELECT_BET6", 3, 0, (uint64_t)"Unknown transition feature: %u for %s", v90, v91, v92, LOWORD(__s2[0]));
            }
            ++v89;
          }
          while (v28 >> 1 > v89);
        }
      }
      else
      {
        LOWORD(__s2[0]) = 0;
        v138[0] = 0;
        LODWORD(v12) = ssftriff_reader_GetChunkData(a3, v28, v138);
        if ((v12 & 0x80000000) == 0 && v28 >= 2)
        {
          unsigned __int16 v39 = 0;
          do
          {
            cstdlib_memcpy(__s2, (char *)v138[0] + 2 * v39, 2uLL);
            if (LOWORD(__s2[0]) < 0x47u) {
              *(_DWORD *)(a2 + 4 * LOWORD(__s2[0]) + 12392) = 1;
            }
            else {
              log_OutText(*(void *)(a1 + 32), (uint64_t)"SELECT_BET6", 3, 0, (uint64_t)"Unknown preselection feature: %u for %s", v40, v41, v42, LOWORD(__s2[0]));
            }
            ++v39;
          }
          while (v28 >> 1 > v39);
        }
      }
      uint64_t v9 = a1;
      goto LABEL_404;
    }
    v138[0] = 0;
    LODWORD(v12) = ssftriff_reader_GetChunkData(a3, v28, v138);
    if ((v12 & 0x80000000) != 0) {
      goto LABEL_404;
    }
    uint64_t v34 = v138[0];
    if (v28 >= 0xF8) {
      size_t v35 = 248;
    }
    else {
      size_t v35 = v28;
    }
    uint64_t v36 = v120;
    goto LABEL_241;
  }
  if (cstdlib_strcmp(v5, "NNFE")) {
    goto LABEL_403;
  }
  v138[0] = 0;
  uint64_t v12 = ssftriff_reader_GetChunkData(a3, v134, v138);
  if ((v12 & 0x80000000) == 0)
  {
    if (cstdlib_strcmp(__src, "NNLT"))
    {
      if (cstdlib_strcmp(__src, "NNUF")) {
        goto LABEL_403;
      }
      long long v43 = v138[0];
      v10[12] = *(_WORD *)v138[0];
      LODWORD(v12) = uselect_LoadRiffStringTable(v9, a3, v43, v134, v119);
      goto LABEL_404;
    }
    int v37 = v5;
    unsigned int v38 = *v10;
    if (v38 > 0x10)
    {
      LODWORD(v12) = -2065686524;
LABEL_265:
      uint64_t v5 = v37;
      goto LABEL_404;
    }
    long long v44 = (char *)v138[0];
    unsigned int v45 = v134;
    if (!*((void *)v10 + 1))
    {
      uint64_t v46 = heap_Calloc(*(void **)(v9 + 8), 18, 16);
      *((void *)v10 + 1) = v46;
      LODWORD(v12) = -2065686518;
      if (!v46) {
        goto LABEL_265;
      }
      LOWORD(v38) = *v10;
    }
    *int v10 = v38 + 1;
    LODWORD(__s2[0]) = 0;
    int StringW = ssftriff_reader_ReadStringW(a3, (uint64_t)v44, v45, 0, 0, __s2);
    if ((StringW & 0x80000000) == 0 || (LODWORD(v12) = StringW, (StringW & 0x1FFF) == 9))
    {
      long long v48 = (unsigned char *)heap_Alloc(*(void *)(v9 + 8), LODWORD(__s2[0]));
      *(void *)(*((void *)v10 + 1) + 16 * *v10 - 16) = v48;
      LODWORD(v12) = -2065686518;
      if (v48)
      {
        int v49 = ssftriff_reader_ReadStringW(a3, (uint64_t)v44, v45, 0, v48, __s2);
        if ((v49 & 0x80000000) == 0)
        {
          uint64_t v50 = (LODWORD(__s2[0]) - 1) + 2;
          if (__s2[0]) {
            long long v51 = &v44[v50];
          }
          else {
            long long v51 = &v44[v50 + 1];
          }
          int v49 = uselect_LoadRiffStringTable(v9, a3, v51, ((__PAIR64__(v45, __s2[0] & 1) - 1) >> 32) - (LODWORD(__s2[0]) + 1), (uint64_t *)(*((void *)v10 + 1) + 16 * *v10 - 8));
        }
        LODWORD(v12) = v49;
      }
    }
    goto LABEL_265;
  }
  return v12;
}

uint64_t select_bet6_loc_LogChunkStack(uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  cstdlib_strcpy(__dst, "");
  if (*a3)
  {
    unsigned int v8 = 1;
    uint64_t v9 = a3;
    do
    {
      cstdlib_strcat(__dst, "/");
      cstdlib_strcat(__dst, v9);
      uint64_t v9 = &a3[5 * v8++];
    }
    while (*v9);
  }
  return log_OutText(*(void *)(a1 + 32), (uint64_t)"SELECT_BET6", 3, 0, (uint64_t)"Unknown data: %s for %s", v5, v6, v7, (uint64_t)__dst);
}

void *select_bet6_loc_VoiceClose(void *result, char *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)*((void *)a2 + 16);
    if (v4)
    {
      if (*((void *)a2 + 1019))
      {
        (*(void (**)(void))(v4[1] + 48))(v4[2]);
        *((void *)a2 + 1019) = 0;
        *((_DWORD *)a2 + 2040) = 0;
      }
      if (*((void *)a2 + 1021))
      {
        (*(void (**)(void))(v4[1] + 48))(v4[2]);
        *((void *)a2 + 1021) = 0;
        *((_DWORD *)a2 + 2044) = 0;
      }
      if (*((void *)a2 + 1023))
      {
        (*(void (**)(void))(v4[1] + 48))(v4[2]);
        *((void *)a2 + 1023) = 0;
        *((_DWORD *)a2 + 2048) = 0;
      }
      fi_rsc_destroy(v4);
    }
    uint64_t v5 = (uint64_t *)*((void *)a2 + 1476);
    if (v5 && *v5)
    {
      uint64_t v6 = 0;
      unsigned int v7 = 1;
      do
      {
        *(void *)&a2[8 * v6 + 5440] = 0;
        uint64_t v5 = (uint64_t *)*((void *)a2 + 1476);
        uint64_t v6 = v7;
      }
      while (v5[v7++]);
    }
    uint64_t v9 = a2 + 37744;
    uselect_FreeRiffStringTable(v3, v5);
    uselect_FreeRiffStringTable(v3, *((uint64_t **)a2 + 1477));
    select_bet6_loc_FreeSirenFeatList((void **)v3, (uint64_t)(a2 + 8120));
    select_bet6_loc_FreeSirenFeatList((void **)v3, (uint64_t)(a2 + 8136));
    uint64_t v10 = *((void *)a2 + 27);
    if (v10) {
      heap_Free((void *)v3[1], v10);
    }
    uint64_t v11 = *((void *)a2 + 1165);
    if (v11)
    {
      heap_Free((void *)v3[1], v11);
      *((void *)a2 + 1165) = 0;
    }
    *((void *)a2 + 27) = 0;
    if (*((_WORD *)a2 + 18996))
    {
      unint64_t v12 = 0;
      do
        ssftriff_reader_ReleaseChunkData(*(void **)&a2[8 * v12++ + 37784]);
      while (v12 < *((unsigned __int16 *)a2 + 18996));
    }
    *((_WORD *)a2 + 18996) = 0;
    *a2 = 0;
    if (*((_DWORD *)a2 + 9444))
    {
      uselect_FreeRiffStringTable(v3, *((uint64_t **)a2 + 4720));
      uint64_t v13 = *((void *)a2 + 4719);
      if (v13)
      {
        if (*v9)
        {
          uint64_t v14 = 0;
          unint64_t v15 = 0;
          do
          {
            uint64_t v16 = *((void *)a2 + 4719);
            uint64_t v17 = *(void *)(v16 + v14);
            if (v17)
            {
              heap_Free((void *)v3[1], v17);
              uint64_t v16 = *((void *)a2 + 4719);
            }
            uselect_FreeRiffStringTable(v3, *(uint64_t **)(v16 + v14 + 8));
            ++v15;
            v14 += 16;
          }
          while (v15 < (unsigned __int16)*v9);
          uint64_t v13 = *((void *)a2 + 4719);
        }
        heap_Free((void *)v3[1], v13);
        *((void *)a2 + 4719) = 0;
        *uint64_t v9 = 0;
      }
    }
    cstdlib_memset(a2, 0, 0x9470uLL);
    int v18 = (void *)v3[1];
    return heap_Free(v18, (uint64_t)a2);
  }
  return result;
}

void **select_bet6_loc_FreeSirenFeatList(void **result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    uint64_t result = *(void ***)a2;
    if (*(void *)a2)
    {
      cstdlib_memset(result, 0, 16 * *(unsigned int *)(a2 + 8));
      heap_Free(v3[1], *(void *)a2);
      return (void **)cstdlib_memset((void *)a2, 0, 8uLL);
    }
  }
  return result;
}

uint64_t select_bet6_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2229280769;
  }
  uint64_t result = 0;
  *a2 = &ISelect_Bet6;
  return result;
}

uint64_t select_bet6_ClassOpen(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v5 = 0;
  if (!a3) {
    return 2229280775;
  }
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v5);
  if ((result & 0x80000000) == 0)
  {
    *(void *)a3 = v5;
    *(_DWORD *)(a3 + 8) = 135969;
  }
  return result;
}

uint64_t select_bet6_ClassClose()
{
  return 0;
}

uint64_t select_bet6_ObjOpen(uint64_t a1, int a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v5 = 2229280775;
  memset(v46, 0, sizeof(v46));
  if (a5)
  {
    v45[0] = 0;
    v45[1] = 0;
    uint64_t inited = InitRsrcFunction(a3, a4, &v44);
    if ((inited & 0x80000000) != 0)
    {
      return inited;
    }
    else
    {
      int v12 = 135970;
      if ((safeh_HandleCheck(a1, a2, 135969, 416) & 0x80000000) == 0)
      {
        *(void *)a5 = 0;
        *(_DWORD *)(a5 + 8) = 0;
        log_OutText(*(void *)(v44 + 32), (uint64_t)"SELECT_BET6", 4, 0, (uint64_t)"Entering select_bet6_ObjOpen", v13, v14, v15, v39);
        uint64_t v16 = (uint64_t *)heap_Calloc(*(void **)(v44 + 8), 1, 4680);
        uint64_t v21 = v44;
        if (!v16)
        {
          log_OutPublic(*(void *)(v44 + 32), (uint64_t)"SELECT_BET6", 72000, 0, v17, v18, v19, v20, v40);
          return 2229280778;
        }
        unsigned int v22 = v16;
        *uint64_t v16 = a1;
        v16[1] = v21;
        if (log_GetLogLevel(*(void *)(v44 + 32)) >= 2) {
          compstats_ObjOpen(a3, a4, 5u, (uint64_t)(v22 + 583));
        }
        uint64_t Object = objc_GetObject(*(void *)(v44 + 48), (uint64_t)"SYNTHSTREAM", &v43);
        if ((Object & 0x80000000) == 0)
        {
          v22[463] = *(void *)(v43 + 8);
          uint64_t Object = objc_GetObject(*(void *)(v44 + 48), (uint64_t)"LINGDB", &v43);
          if ((Object & 0x80000000) == 0)
          {
            uint64_t v28 = v44;
            v22[3] = *(void *)(v43 + 8);
            betX_CreateRegularBrokerString(v28, 0, (char *)v46, 0x80uLL);
            uint64_t v5 = select_bet6_VoiceOpen(*v22, v22[1], (uint64_t)v46, (uint64_t)v45);
            if ((v5 & 0x80000000) != 0) {
              goto LABEL_23;
            }
            uint64_t v29 = v45[0];
            v22[2] = v45[0];
            if (!v29)
            {
              log_OutPublic(*(void *)(v22[1] + 32), (uint64_t)"SELECT_BET6", 72001, 0, v24, v25, v26, v27, v40);
              goto LABEL_25;
            }
            uint64_t v30 = v29 + 9344;
            uint64_t v31 = v29 + 136;
            int v32 = *(_DWORD *)(v29 + 37776);
            uint64_t v33 = v29 + 37744;
            if (v32) {
              uint64_t v34 = v33;
            }
            else {
              uint64_t v34 = 0;
            }
            uint64_t Object = select_bet6_FeatureExtractObjOpen(a3, a4, v22[463], v22[3], v30, v31, v34, v22 + 575);
            if ((Object & 0x80000000) == 0)
            {
              uint64_t v35 = *(void *)(v44 + 40);
              uint64_t v41 = v22;
              long long v42 = xmmword_26D214D60;
              uint64_t v36 = paramc_ListenerAdd(v35, "waitfactor", &v41);
              uint64_t v37 = v22[1];
              if ((v36 & 0x80000000) != 0)
              {
                uint64_t v5 = v36;
                goto LABEL_24;
              }
              if ((paramc_ParamGetInt(*(void *)(v37 + 40), (uint64_t)"waitfactor", (_DWORD *)v22 + 1155) & 0x80000000) != 0) {
                *((_DWORD *)v22 + 1155) = 2;
              }
              uint64_t v5 = siren_pipeline_Init(v44, (uint64_t)(v22 + 583), v22[2] + 128, v22 + 576);
              if ((v5 & 0x80000000) == 0) {
                goto LABEL_25;
              }
LABEL_23:
              uint64_t v37 = v22[1];
LABEL_24:
              log_OutPublic(*(void *)(v37 + 32), (uint64_t)"SELECT_BET6", 72001, (uint64_t)"%s%x", v24, v25, v26, v27, "lhError");
              *(void *)a5 = v22;
              *(_DWORD *)(a5 + 8) = 135970;
              select_bet6_ObjClose(v22, *(void *)(a5 + 8));
              unsigned int v22 = 0;
              int v12 = 0;
LABEL_25:
              *(void *)a5 = v22;
              *(_DWORD *)(a5 + 8) = v12;
              log_OutText(*(void *)(v44 + 32), (uint64_t)"SELECT_BET6", 4, 0, (uint64_t)"select_bet6_ObjOpen: %x", v25, v26, v27, v5);
              return v5;
            }
          }
        }
        uint64_t v5 = Object;
        goto LABEL_23;
      }
      return 2229280776;
    }
  }
  return v5;
}

uint64_t select_bet6_ObjClose(uint64_t *a1, int a2)
{
  if ((safeh_HandleCheck((uint64_t)a1, a2, 135970, 4680) & 0x80000000) != 0) {
    return 2229280776;
  }
  uint64_t v30 = 0;
  uint64_t v6 = a1[1];
  log_OutText(*(void *)(v6 + 32), (uint64_t)"SELECT_BET6", 4, 0, (uint64_t)"Entering select_bet6_ObjClose", v3, v4, v5, v26);
  uint64_t v29 = a1[2];
  LODWORD(v30) = 135971;
  LODWORD(v7) = select_bet6_VoiceClose(*a1, &v29);
  uint64_t v8 = a1[583];
  if (v8) {
    compstats_ObjClose(v8, a1[584]);
  }
  uint64_t v9 = *(void *)(v6 + 40);
  uint64_t v27 = a1;
  long long v28 = xmmword_26D214D60;
  int v10 = paramc_ListenerRemove(v9, "waitfactor", (long long *)&v27);
  if ((int)v7 > -1 && v10 < 0) {
    uint64_t v7 = v10;
  }
  else {
    uint64_t v7 = v7;
  }
  uint64_t v12 = a1[576];
  if (v12)
  {
    int v13 = siren_pipeline_DeInit(v12);
    if ((int)v7 > -1 && v13 < 0) {
      uint64_t v7 = v13;
    }
    else {
      uint64_t v7 = v7;
    }
  }
  uint64_t v15 = a1[575];
  if (v15)
  {
    int ObjClose = select_bet6_FeatureExtractObjClose(v15);
    if ((int)v7 > -1 && ObjClose < 0) {
      uint64_t v7 = ObjClose;
    }
    else {
      uint64_t v7 = v7;
    }
  }
  if (a1[3])
  {
    int v18 = objc_ReleaseObject(*(void *)(v6 + 48), (uint64_t)"LINGDB");
    if ((int)v7 > -1 && v18 < 0) {
      uint64_t v7 = v18;
    }
    else {
      uint64_t v7 = v7;
    }
  }
  if (a1[463])
  {
    int v20 = objc_ReleaseObject(*(void *)(v6 + 48), (uint64_t)"SYNTHSTREAM");
    if ((int)v7 > -1 && v20 < 0) {
      uint64_t v7 = v20;
    }
    else {
      uint64_t v7 = v7;
    }
  }
  heap_Free(*(void **)(v6 + 8), (uint64_t)a1);
  log_OutText(*(void *)(v6 + 32), (uint64_t)"SELECT_BET6", 4, 0, (uint64_t)"Leaving select_bet6_ObjClose: %x", v22, v23, v24, v7);
  return v7;
}

uint64_t select_bet6_ObjReopen(uint64_t *a1, int a2)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  *(_OWORD *)long long __s1 = 0u;
  long long v27 = 0u;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 135970, 4680) & 0x80000000) != 0) {
    return 2229280776;
  }
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  log_OutText(*(void *)(a1[1] + 32), (uint64_t)"SELECT_BET6", 4, 0, (uint64_t)"Entering select_bet6_ObjReopen", v3, v4, v5, v23);
  LODWORD(v9) = betX_CreateRegularBrokerString(a1[1], 0, __s1, 0x80uLL);
  if ((v9 & 0x80000000) == 0 && (int v10 = (const char *)a1[2]) != 0 && cstdlib_strcmp(__s1, v10))
  {
    int v11 = siren_pipeline_DeInit(a1[576]);
    if (v11 < 0) {
      LODWORD(v9) = v11;
    }
    uint64_t v24 = a1[2];
    LODWORD(v25) = 135971;
    int v12 = select_bet6_VoiceClose(*a1, &v24);
    if (v12 < 0 || (int v12 = select_bet6_VoiceOpen(*a1, a1[1], (uint64_t)__s1, (uint64_t)&v24), v12 < 0))
    {
      ObjReopeuint64_t n = v12;
    }
    else
    {
      uint64_t v13 = v24;
      a1[2] = v24;
      if ((siren_pipeline_Init(a1[1], (uint64_t)(a1 + 583), v13 + 128, a1 + 576) & 0x80000000) != 0) {
        select_bet6_VoiceClose(*a1, &v24);
      }
      uint64_t v14 = a1[2];
      uint64_t v15 = v14 + 9344;
      uint64_t v16 = v14 + 136;
      int v17 = *(_DWORD *)(v14 + 37776);
      uint64_t v18 = v14 + 37744;
      if (v17) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = 0;
      }
      ObjReopeuint64_t n = select_bet6_FeatureExtractObjReopen(a1[575], v15, v16, v19);
      if (ObjReopen < 0) {
        select_bet6_VoiceClose(*a1, &v24);
      }
    }
  }
  else
  {
    ObjReopeuint64_t n = 0;
  }
  if (ObjReopen >= 0 || (int)v9 <= -1) {
    uint64_t v9 = v9;
  }
  else {
    uint64_t v9 = ObjReopen;
  }
  log_OutText(*(void *)(a1[1] + 32), (uint64_t)"SELECT_BET6", 4, 0, (uint64_t)"select_bet6_ObjReopen: %x", v6, v7, v8, v9);
  return v9;
}

uint64_t select_bet6_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v16 = 0;
  int v17 = 0;
  if ((safeh_HandleCheck(a1, a2, 135970, 4680) & 0x80000000) != 0) {
    return 2229280776;
  }
  synstrmaux_InitStreamOpener(a1 + 3776, *(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SELECT_BET6");
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 3776), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
    a1 + 3712);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 3776), (uint64_t)"application/x-realspeak-bet6-speech-frames", a1 + 3728);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 3776), (uint64_t)"application/x-realspeak-bet6-sample-chunk", a1 + 3744);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 3776), (uint64_t)"applcation/x-realspeak-bet6-select-audio", a1 + 3760);
  uint64_t v7 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 3776), *(void *)(a1 + 3704), a3, a4);
  if ((v7 & 0x80000000) != 0) {
    synstrmaux_CloseStreams((_WORD *)(a1 + 3776), *(void *)(a1 + 3704));
  }
  *(void *)(a1 + 4632) = 0;
  *(_DWORD *)(a1 + 4640) = 0;
  *(_DWORD *)(a1 + 4624) = 0;
  *(_DWORD *)(a1 + 4616) = 0;
  *(_OWORD *)(a1 + 4648) = 0u;
  cstdlib_memset((void *)(a1 + 32), 0, 0xE48uLL);
  siren_pipeline_SetNFrameInfer(*(void *)(a1 + 4608), *(_DWORD *)(*(void *)(a1 + 16) + 9336));
  if ((paramc_ParamGetStr(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"bet6earlyemissionallowed", &v17) & 0x80000000) == 0
    && v17
    && *v17)
  {
    if (cstdlib_strchr("nNfF0", (char)*v17))
    {
      int v8 = 0;
    }
    else
    {
      cstdlib_strchr("yYtT12", (char)*v17);
      int v8 = 1;
    }
    siren_pipeline_SetChunking(*(void *)(a1 + 4608), v8);
    siren_pipeline_SetSecondaryChunking(*(void *)(a1 + 4608), v8);
  }
  if ((paramc_ParamGetStr(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"style", &v16) & 0x80000000) == 0
    && v16
    && *v16)
  {
    if (cstdlib_strchr("nN0", (char)*v16))
    {
      int v12 = 0;
    }
    else
    {
      cstdlib_strchr("lL1", (char)*v16);
      int v12 = 1;
    }
    siren_pipeline_SetSpeakerID(*(void *)(a1 + 4608), v12);
  }
  if (*(_DWORD *)(*(void *)(a1 + 16) + 9296) >= 2u
    && siren_pipeline_GetChunking(*(void *)(a1 + 4608)))
  {
    log_OutText(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SELECT_BET6", 1, 0, (uint64_t)"Multi-thread on, but chunking is inactive!", v9, v10, v11, (uint64_t)v16);
  }
  uint64_t v13 = *(void *)(a1 + 16);
  if (*(_DWORD *)(v13 + 9296) >= 2u && !*(_DWORD *)(v13 + 9312)) {
    log_OutText(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SELECT_BET6", 0, 0, (uint64_t)"Multi-thread on , but NnvocoderChuning is inactive! Have a look on Riffpack config.", v9, v10, v11, (uint64_t)v16);
  }
  if ((v7 & 0x80000000) == 0)
  {
    uint64_t v14 = *(void *)(a1 + 4664);
    if (v14) {
      compstats_Reset(v14);
    }
  }
  siren_pipeline_reset_acoustic_net_seed(*(void *)(a1 + 4608));
  return v7;
}

uint64_t select_bet6_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int *a5)
{
  uint64_t v9 = safeh_HandleCheck(a1, a2, 135970, 4680);
  if ((v9 & 0x80000000) != 0) {
    return 2229280776;
  }
  if (!a1) {
    goto LABEL_19;
  }
  uint64_t v15 = *(_DWORD **)(a1 + 16);
  int v16 = v15[2311];
  if (v15[2324] >= 2u)
  {
    uint64_t v28 = v9;
    if (v16) {
      return v28;
    }
    int v98 = 0;
    int v17 = (void *)(a1 + 32);
    *a5 = 1;
    uint64_t v34 = *(void *)(a1 + 4664);
    if (v34) {
      compstats_Start(v34, *(void *)(a1 + 4672), 0, v10, v11, v12, v13, v14);
    }
    uint64_t v19 = (_DWORD *)(a1 + 4616);
    int v35 = *(_DWORD *)(a1 + 4616);
    if (v35 == 5 || !v35)
    {
      *(_DWORD *)(a1 + 4616) = 0;
      uint64_t v36 = *(void *)(a1 + 4664);
      if (v36) {
        compstats_Start(v36, *(void *)(a1 + 4672), 1, v10, v11, v12, v13, v14);
      }
      uint64_t v22 = (uint64_t *)(a1 + 3688);
      uint64_t v23 = (_DWORD *)(a1 + 3696);
      uint64_t v28 = select_bet6_FeatureExtractProcessStart(*(void *)(a1 + 4600), a3, a4, (void *)(a1 + 32), a1 + 3688, a1 + 3696, &v98);
      if ((v28 & 0x80000000) == 0)
      {
        if (*(__int16 *)(a1 + 42) <= 1)
        {
          int v29 = v98;
          if (v98) {
            goto LABEL_39;
          }
          goto LABEL_42;
        }
        goto LABEL_55;
      }
      goto LABEL_54;
    }
    uint64_t v70 = *(void *)(a1 + 4664);
    if (v70) {
      compstats_Start(v70, *(void *)(a1 + 4672), 2, v10, v11, v12, v13, v14);
    }
    unsigned int v53 = siren_pipeline_Process(*(void *)(a1 + 4608), *(int **)(a1 + 4632), (int *)(a1 + 4640), (int *)(a1 + 4616), v11, v12, v13, v14);
    int v54 = *(_DWORD *)(a1 + 4616);
    if (v53 || (v54 & 0xFFFFFFFE) != 4)
    {
LABEL_106:
      if (v54 == 6) {
        int v75 = 1;
      }
      else {
        int v75 = 4;
      }
      *a5 = v75;
      if (*v19 == 6) {
        uint64_t v28 = v53 | 0x84E02000;
      }
      else {
        uint64_t v28 = v53;
      }
      goto LABEL_153;
    }
    int v71 = select_bet6_loc_WriteStreams_MT(a1);
    uint64_t v28 = v71 & (v71 >> 31);
    if (*(_DWORD *)(a1 + 4616) != 5) {
      goto LABEL_151;
    }
    int v62 = select_bet6_loc_WriteStreams_MT(a1);
LABEL_93:
    if (v62 < 0 && (int)v28 > -1) {
      LODWORD(v28) = v62;
    }
    if (*(_DWORD *)(a1 + 4640))
    {
      heap_Free(*(void **)(*(void *)(a1 + 8) + 8), *(void *)(a1 + 4632));
      *(_DWORD *)(a1 + 4624) = 0;
      *(void *)(a1 + 4632) = 0;
      *(void *)(a1 + 4640) = 0;
      *(_DWORD *)(a1 + 4656) = 0;
      *(void *)(a1 + 4648) = 0;
    }
    int ProcessEnd = select_bet6_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 4600), v17, (uint64_t *)(a1 + 3688), (_DWORD *)(a1 + 3696));
    if (ProcessEnd < 0 && (int)v28 > -1) {
      LODWORD(v28) = ProcessEnd;
    }
    goto LABEL_144;
  }
  if (!v16 && !v15[2312] && !v15[2314] && !v15[2315])
  {
LABEL_19:
    int v100 = 0;
    int v17 = (void *)(a1 + 32);
    *a5 = 1;
    uint64_t v30 = *(void *)(a1 + 4664);
    if (v30) {
      compstats_Start(v30, *(void *)(a1 + 4672), 0, v10, v11, v12, v13, v14);
    }
    uint64_t v19 = (_DWORD *)(a1 + 4616);
    int v31 = *(_DWORD *)(a1 + 4616);
    if (v31 == 5 || !v31)
    {
      *(_DWORD *)(a1 + 4616) = 0;
      uint64_t v32 = *(void *)(a1 + 4664);
      if (v32) {
        compstats_Start(v32, *(void *)(a1 + 4672), 1, v10, v11, v12, v13, v14);
      }
      uint64_t v22 = (uint64_t *)(a1 + 3688);
      uint64_t v23 = (_DWORD *)(a1 + 3696);
      uint64_t v28 = select_bet6_FeatureExtractProcessStart(*(void *)(a1 + 4600), a3, a4, (void *)(a1 + 32), a1 + 3688, a1 + 3696, &v100);
      if ((v28 & 0x80000000) == 0)
      {
        if (*(__int16 *)(a1 + 42) <= 1)
        {
          int v29 = v100;
          if (v100)
          {
            int updated = select_bet6_loc_UpdateMarkers(a1, 1);
            select_bet6_loc_WriteStreams(a1, updated, 3u);
            goto LABEL_39;
          }
LABEL_42:
          *a5 = v29;
          int v37 = select_bet6_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 4600), v17, v22, v23);
          if ((int)v28 > -1 && v37 < 0) {
            int v39 = v37;
          }
          else {
            int v39 = v28;
          }
          int v40 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 24) + 64))(a3, a4);
          if (v39 > -1 && v40 < 0) {
            uint64_t v28 = v40;
          }
          else {
            uint64_t v28 = v39;
          }
          goto LABEL_85;
        }
LABEL_55:
        uint64_t Process = select_bet6_FeatureExtractProcess(*(uint64_t **)(a1 + 4600), a3, a4, (unsigned int *)(a1 + 4620), (uint64_t)v17, v22, v23, (uint64_t *)(a1 + 4632), (_DWORD *)(a1 + 4640));
        if ((Process & 0x80000000) != 0)
        {
          uint64_t v28 = Process;
        }
        else
        {
          int v51 = *(_DWORD *)(a1 + 3696) * *(unsigned __int16 *)(a1 + 42);
          *(_DWORD *)(a1 + 3696) = v51;
          uint64_t v28 = siren_pipeline_ProcessStart(*(void *)(a1 + 4608), (uint64_t)v17, *(void *)(a1 + 3688), v51, v19, v48, v49, v50);
          if ((v28 & 0x80000000) == 0)
          {
            *a5 = 4;
            goto LABEL_85;
          }
        }
        select_bet6_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 4600), v17, v22, v23);
        goto LABEL_85;
      }
LABEL_54:
      log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SELECT_BET6", 72001, (uint64_t)"%s%x", v24, v25, v26, v27, "lhError");
LABEL_85:
      uint64_t v67 = *(void *)(a1 + 4664);
      if (!v67) {
        return v28;
      }
      uint64_t v68 = *(void *)(a1 + 4672);
      uint64_t v69 = 1;
      goto LABEL_155;
    }
    uint64_t v52 = *(void *)(a1 + 4664);
    if (v52) {
      compstats_Start(v52, *(void *)(a1 + 4672), 2, v10, v11, v12, v13, v14);
    }
    unsigned int v53 = siren_pipeline_Process(*(void *)(a1 + 4608), *(int **)(a1 + 4632), (int *)(a1 + 4640), (int *)(a1 + 4616), v11, v12, v13, v14);
    int v54 = *(_DWORD *)(a1 + 4616);
    if (v53 || (v54 & 0xFFFFFFFE) != 4) {
      goto LABEL_106;
    }
    BOOL v55 = v54 == 4;
    if (v54 == 4) {
      int v56 = 1;
    }
    else {
      int v56 = 2;
    }
    if (v55) {
      int v57 = 0;
    }
    else {
      int v57 = 3;
    }
    if (*(_DWORD *)(a1 + 4624)) {
      unsigned int v58 = v56;
    }
    else {
      unsigned int v58 = v57;
    }
    int v59 = select_bet6_loc_UpdateMarkers(a1, 0);
    int v60 = select_bet6_loc_WriteStreams(a1, v59, v58);
    uint64_t v28 = v60 & (v60 >> 31);
    *(_DWORD *)(a1 + 4644) += v59;
    *(_DWORD *)(a1 + 4648) = siren_pipeline_GetPhoneCount(*(void *)(a1 + 4608));
    *(_DWORD *)(a1 + 4652) = siren_pipeline_GetFrameCount(*(void *)(a1 + 4608));
    ++*(_DWORD *)(a1 + 4624);
    if (*(_DWORD *)(a1 + 4616) != 5) {
      goto LABEL_151;
    }
    int v61 = select_bet6_loc_UpdateMarkers(a1, 1);
    int v62 = select_bet6_loc_WriteStreams(a1, v61, 3u);
    goto LABEL_93;
  }
  int v99 = 0;
  int v17 = (void *)(a1 + 32);
  *a5 = 1;
  uint64_t v18 = *(void *)(a1 + 4664);
  if (v18) {
    compstats_Start(v18, *(void *)(a1 + 4672), 0, v10, v11, v12, v13, v14);
  }
  uint64_t v19 = (_DWORD *)(a1 + 4616);
  int v20 = *(_DWORD *)(a1 + 4616);
  if (v20 == 5 || !v20)
  {
    *(_DWORD *)(a1 + 4616) = 0;
    uint64_t v21 = *(void *)(a1 + 4664);
    if (v21) {
      compstats_Start(v21, *(void *)(a1 + 4672), 1, v10, v11, v12, v13, v14);
    }
    uint64_t v22 = (uint64_t *)(a1 + 3688);
    uint64_t v23 = (_DWORD *)(a1 + 3696);
    uint64_t v28 = select_bet6_FeatureExtractProcessStart(*(void *)(a1 + 4600), a3, a4, (void *)(a1 + 32), a1 + 3688, a1 + 3696, &v99);
    if ((v28 & 0x80000000) == 0)
    {
      if (*(__int16 *)(a1 + 42) <= 1)
      {
        int v29 = v99;
        if (v99)
        {
          select_bet6_loc_UpdateMarkers(a1, 1);
LABEL_39:
          if (*(_DWORD *)(a1 + 4640))
          {
            heap_Free(*(void **)(*(void *)(a1 + 8) + 8), *(void *)(a1 + 4632));
            *(_DWORD *)(a1 + 4624) = 0;
            *(void *)(a1 + 4632) = 0;
            *(void *)(a1 + 4648) = 0;
            *(void *)(a1 + 4640) = 0;
            *(_DWORD *)(a1 + 4656) = 0;
          }
          LODWORD(v28) = synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 3776), *(void *)(a1 + 3704));
          int v29 = 1;
          goto LABEL_42;
        }
        goto LABEL_42;
      }
      goto LABEL_55;
    }
    goto LABEL_54;
  }
  uint64_t v63 = *(void *)(a1 + 4664);
  if (v63) {
    compstats_Start(v63, *(void *)(a1 + 4672), 2, v10, v11, v12, v13, v14);
  }
  uint64_t v64 = (int *)(a1 + 4640);
  unsigned int v53 = siren_pipeline_Process(*(void *)(a1 + 4608), *(int **)(a1 + 4632), (int *)(a1 + 4640), (int *)(a1 + 4616), v11, v12, v13, v14);
  int v54 = *(_DWORD *)(a1 + 4616);
  if (v53 || (v54 - 2) > 3) {
    goto LABEL_106;
  }
  unsigned int v65 = *(_DWORD *)(a1 + 4624);
  switch(v54)
  {
    case 2:
      unsigned int v66 = 0;
      break;
    case 3:
      unsigned int v66 = 1;
      break;
    case 5:
      if (siren_pipeline_GetSecondaryChunking(*(void *)(a1 + 4608))
        && siren_pipeline_GetSecondaryChunkingCount(*(void *)(a1 + 4608)) > 1)
      {
        unsigned int v66 = 5;
      }
      else if (siren_pipeline_GetChunking(*(void *)(a1 + 4608)) {
             && siren_pipeline_GetPhoneChunkingCount(*(void *)(a1 + 4608)) > 1)
      }
      {
        unsigned int v66 = 6;
      }
      else
      {
        unsigned int v66 = 3;
      }
      break;
    default:
      if (siren_pipeline_GetSecondaryChunking(*(void *)(a1 + 4608))
        && siren_pipeline_GetSecondaryChunkingCount(*(void *)(a1 + 4608)) > 1)
      {
        unsigned int v66 = 2;
      }
      else
      {
        unsigned int v66 = 4;
      }
      break;
  }
  if (siren_pipeline_GetChunking(*(void *)(a1 + 4608)))
  {
    int SecondaryChunking = siren_pipeline_GetSecondaryChunking(*(void *)(a1 + 4608));
    uint64_t v77 = *(void *)(a1 + 4608);
    if (SecondaryChunking) {
      int SecondaryMarkerCount = siren_pipeline_GetSecondaryMarkerCount(v77);
    }
    else {
      int SecondaryMarkerCount = siren_pipeline_GetMarkerCount(v77, v65);
    }
    int v79 = SecondaryMarkerCount;
  }
  else
  {
    int v79 = *v64;
  }
  uint64_t v80 = select_bet6_loc_WriteStreams(a1, v79, v66);
  if ((v80 & 0x80000000) != 0)
  {
    uint64_t v28 = v80;
    log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SELECT_BET6", 72001, (uint64_t)"%s%x", v81, v82, v83, v84, "lhError");
  }
  else
  {
    uint64_t v28 = 0;
  }
  *(_DWORD *)(a1 + 4644) += v79;
  uint64_t v85 = *(void *)(a1 + 4608);
  if (*(_DWORD *)(*(void *)(a1 + 16) + 9244)) {
    *(_DWORD *)(a1 + 4656) = siren_pipeline_GetiSample(v85);
  }
  else {
    *(_DWORD *)(a1 + 4652) = siren_pipeline_GetFrameCount(v85);
  }
  ++*(_DWORD *)(a1 + 4624);
  if ((*(_DWORD *)(a1 + 4616) & 0xFFFFFFFE) == 4)
  {
    uint64_t v28 = siren_pipeline_freeSecondaryChunkingMemory(*(void **)(a1 + 4608));
    if (*(_DWORD *)(a1 + 4616) == 5)
    {
      if (*v64)
      {
        heap_Free(*(void **)(*(void *)(a1 + 8) + 8), *(void *)(a1 + 4632));
        *(_DWORD *)(a1 + 4624) = 0;
        *(void *)(a1 + 4632) = 0;
        *(void *)(a1 + 4640) = 0;
        *(_DWORD *)(a1 + 4656) = 0;
        *(void *)(a1 + 4648) = 0;
      }
      int v86 = select_bet6_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 4600), (void *)(a1 + 32), (uint64_t *)(a1 + 3688), (_DWORD *)(a1 + 3696));
      if ((int)v28 > -1 && v86 < 0) {
        LODWORD(v28) = v86;
      }
LABEL_144:
      int v88 = siren_pipeline_ProcessEnd(*(void **)(a1 + 4608), v19);
      if ((int)v28 > -1 && v88 < 0) {
        uint64_t v28 = v88;
      }
      else {
        uint64_t v28 = v28;
      }
      int v90 = 1;
      goto LABEL_152;
    }
  }
LABEL_151:
  int v90 = 2;
LABEL_152:
  *a5 = v90;
LABEL_153:
  uint64_t v67 = *(void *)(a1 + 4664);
  if (!v67) {
    return v28;
  }
  uint64_t v68 = *(void *)(a1 + 4672);
  uint64_t v69 = 2;
LABEL_155:
  compstats_Stop(v67, v68, v69, v41, v42, v43, v44, v45);
  uint64_t v96 = *(void *)(a1 + 4664);
  if (v96) {
    compstats_Stop(v96, *(void *)(a1 + 4672), 0, v91, v92, v93, v94, v95);
  }
  return v28;
}

uint64_t select_bet6_ProcessEnd(uint64_t a1, int a2)
{
  int v3 = safeh_HandleCheck(a1, a2, 135970, 4680);
  if (v3 < 0) {
    return 2229280776;
  }
  LODWORD(v4) = v3;
  if ((*(_DWORD *)(a1 + 4616) - 2) <= 2)
  {
    int ProcessEnd = select_bet6_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 4600), (void *)(a1 + 32), (uint64_t *)(a1 + 3688), (_DWORD *)(a1 + 3696));
    if (ProcessEnd < 0) {
      LODWORD(v4) = ProcessEnd;
    }
    siren_pipeline_ProcessEnd(*(void **)(a1 + 4608), (_DWORD *)(a1 + 4616));
    if ((int)v4 > 0) {
      LODWORD(v4) = v4 | 0x84E02000;
    }
    if (*(_DWORD *)(a1 + 4640))
    {
      heap_Free(*(void **)(*(void *)(a1 + 8) + 8), *(void *)(a1 + 4632));
      *(_DWORD *)(a1 + 4624) = 0;
      *(void *)(a1 + 4632) = 0;
      *(void *)(a1 + 4648) = 0;
      *(void *)(a1 + 4640) = 0;
      *(_DWORD *)(a1 + 4656) = 0;
    }
  }
  int v6 = synstrmaux_CloseStreams((_WORD *)(a1 + 3776), *(void *)(a1 + 3704));
  if (v6 >= 0 || (int)v4 <= -1) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = v6;
  }
  if ((v4 & 0x80000000) == 0)
  {
    uint64_t v8 = *(void *)(a1 + 4664);
    if (v8) {
      compstats_Log(v8, *(void *)(a1 + 4672), *(void *)(*(void *)(a1 + 8) + 32), "Selection Detail", (uint64_t)select_bet6_ProcessEnd_szLabels, 0, 0);
    }
  }
  return v4;
}

uint64_t select_bet6_loc_ParamLearnChange(uint64_t a1, char *__s1, const char *a3)
{
  unsigned int v12 = 0;
  if (!cstdlib_strcmp(__s1, "waitfactor"))
  {
    unsigned int v11 = 0;
    if (!cstdlib_strcmp(__s1, "waitfactor"))
    {
      paramc_ParamGetUInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"finalsentencefound", &v11);
      if (v11 != 1)
      {
        uint64_t v7 = LH_atoi(a3);
        select_bet6_loc_ParamSet(a1, __s1, (uint64_t)v7);
      }
    }
    uint64_t v8 = (uint64_t)LH_atoi(a3);
    uint64_t v9 = a1;
    uint64_t v10 = __s1;
    return select_bet6_loc_ParamSet(v9, v10, v8);
  }
  if (cstdlib_strcmp(__s1, "finalsentencefound")) {
    return 0;
  }
  if ((unsigned __int16)LH_atou(a3) != 1)
  {
    paramc_ParamGetUInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"waitfactorbackup", &v12);
    uint64_t v8 = v12;
    uint64_t v10 = "waitfactor";
    uint64_t v9 = a1;
    return select_bet6_loc_ParamSet(v9, v10, v8);
  }
  paramc_ParamSetUInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"waitfactorbackup", *(_DWORD *)(a1 + 4620));

  return select_bet6_loc_ParamSet(a1, "waitfactor", 0);
}

uint64_t select_bet6_loc_ParamSet(uint64_t a1, char *__s1, uint64_t a3)
{
  if (cstdlib_strcmp(__s1, "waitfactor")) {
    return 0;
  }
  if ((a3 & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 4620) = a3;
    log_OutText(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SELECT_BET6", 3, 0, (uint64_t)"Set wait factor %d", v5, v6, v7, a3);
    return 0;
  }
  return 2229280783;
}

uint64_t select_bet6_loc_WriteStreams_MT(uint64_t a1)
{
  int FrameSize = siren_pipeline_GetFrameSize(*(void *)(a1 + 4608));
  AcousticStreauint64_t m = siren_pipeline_GetAcousticStream(*(void *)(a1 + 4608));
  SampleChununint64_t k = siren_pipeline_GetSampleChunk(*(void *)(a1 + 4608));
  if (AcousticStream) {
    BOOL v5 = SampleChunk == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    return 10;
  }
  uint64_t v7 = SampleChunk;
  unsigned int SampleChunkCounter = siren_pipeline_GetSampleChunkCounter(*(void *)(a1 + 4608));
  unsigned int FrameCount = siren_pipeline_GetFrameCount(*(void *)(a1 + 4608));
  if (SampleChunkCounter < *(_DWORD *)v7 && FrameCount > *(_DWORD *)(*(void *)(v7 + 16) + 4 * SampleChunkCounter))
  {
    int updated = select_bet6_loc_UpdateMarkers_MT(a1, *(_DWORD *)(a1 + 4616) == 5);
    int v11 = updated;
    if (updated)
    {
      uint64_t v12 = (*(uint64_t (**)(void, void, uint64_t, void))(*(void *)(a1 + 3704) + 104))(*(void *)(a1 + 3712), *(void *)(a1 + 3720), *(void *)(a1 + 4632) + 32 * *(unsigned int *)(a1 + 4644), (32 * updated));
      if ((v12 & 0x80000000) != 0) {
        return v12;
      }
    }
    uint64_t v13 = *(void *)(a1 + 3704);
    uint64_t v14 = *(void *)(a1 + 16);
    int v36 = *(_DWORD *)(v14 + 9332);
    int v37 = v11;
    uint64_t v15 = *(unsigned int *)(v14 + 9296);
    uint64_t v16 = *(void *)(v7 + 16);
    int v17 = *(_DWORD *)(*(void *)(v7 + 8) + 4 * SampleChunkCounter);
    uint64_t v18 = *(void *)(a1 + 3728);
    uint64_t v19 = *(void *)(a1 + 3736);
    uint64_t v39 = *(void *)(a1 + 3744);
    int v41 = 3;
    uint64_t v38 = *(void *)(a1 + 3752);
    int v34 = *(_DWORD *)(v16 + 4 * SampleChunkCounter);
    int v35 = v17;
    if (!SampleChunkCounter) {
      int v41 = 0;
    }
    if (*(_DWORD *)v7 == 1 || SampleChunkCounter == *(_DWORD *)v7 - 1)
    {
      if (*(_DWORD *)v7 == 1) {
        int v20 = 4;
      }
      else {
        int v20 = 2;
      }
      int v41 = v20;
    }
    int v40 = 0;
    uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, int *, uint64_t))(v13 + 104))(v18, v19, &v41, 4);
    if ((v21 & 0x80000000) == 0)
    {
      uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(v13 + 104))(v18, v19, AcousticStream + 4 * (v35 * FrameSize), (4 * v36 * (v34 - v35 + 1)));
      if ((v6 & 0x80000000) != 0)
      {
LABEL_43:
        int v22 = v37;
        goto LABEL_44;
      }
      int v22 = v37;
      if (!v15)
      {
LABEL_40:
        ++SampleChunkCounter;
LABEL_44:
        siren_pipeline_SetSampleChunkCounter(*(void *)(a1 + 4608), SampleChunkCounter);
        *(_DWORD *)(a1 + 4648) = siren_pipeline_GetPhoneCount(*(void *)(a1 + 4608));
        *(_DWORD *)(a1 + 4652) = siren_pipeline_GetFrameCount(*(void *)(a1 + 4608));
        *(_DWORD *)(a1 + 4644) += v22;
        ++*(_DWORD *)(a1 + 4624);
        return v6;
      }
      unsigned int v23 = v15 * SampleChunkCounter;
      int v24 = *(_DWORD *)(*(void *)(v7 + 24) + 4 * v15 * SampleChunkCounter);
      uint64_t v25 = v15;
      unsigned int v26 = v15 * SampleChunkCounter;
      while (1)
      {
        int v27 = *(_DWORD *)(*(void *)(v7 + 24) + 4 * v26);
        BOOL v28 = *(_DWORD *)(*(void *)(v7 + 32) + 4 * v26) == -1 && v27 == 0;
        int v29 = v28 ? 0 : v24;
        int v40 = v27 - v29;
        uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, int *, uint64_t))(v13 + 104))(v39, v38, &v40, 4);
        if ((v21 & 0x80000000) != 0) {
          break;
        }
        ++v26;
        if (!--v25)
        {
          int v22 = v37;
          while (1)
          {
            int v30 = *(_DWORD *)(*(void *)(v7 + 32) + 4 * v23);
            BOOL v31 = v30 == -1 && *(_DWORD *)(*(void *)(v7 + 24) + 4 * v23) == 0;
            int v32 = v31 ? 0 : v24;
            int v40 = v30 - v32;
            uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, int *, uint64_t))(v13 + 104))(v39, v38, &v40, 4);
            if ((v6 & 0x80000000) != 0) {
              goto LABEL_44;
            }
            ++v23;
            if (!--v15) {
              goto LABEL_40;
            }
          }
        }
      }
    }
    uint64_t v6 = v21;
    goto LABEL_43;
  }
  return 0;
}

uint64_t select_bet6_loc_UpdateMarkers_MT(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 4644) == *(_DWORD *)(a1 + 4640)) {
    return 0;
  }
  unsigned int PhoneCount = siren_pipeline_GetPhoneCount(*(void *)(a1 + 4608));
  siren_pipeline_GetDurationStream(*(void *)(a1 + 4608));
  uint64_t result = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 4644);
  unsigned int v7 = *(_DWORD *)(a1 + 4648);
  int v8 = *(_DWORD *)(a1 + 4660);
  for (uint64_t i = (_DWORD *)(*(void *)(a1 + 4632) + 32 * v6 + 16); ; i += 8)
  {
    unsigned int v10 = v6 + result;
    if ((v7 >= PhoneCount || v10 >= *(_DWORD *)(a1 + 4640)) && (!a2 || v10 >= *(_DWORD *)(a1 + 4640))) {
      break;
    }
    if (*(i - 4) == 33)
    {
      int v8 = *i + *(i - 1);
      ++v7;
    }
    uint64_t result = (result + 1);
  }
  *(_DWORD *)(a1 + 4660) = v8;
  return result;
}

uint64_t select_bet6_loc_UpdateMarkers(uint64_t a1, int a2)
{
  if (a1 && *(_DWORD *)(*(void *)(a1 + 16) + 9296) >= 2u)
  {
    return select_bet6_loc_UpdateMarkers_MT(a1, a2);
  }
  else if (*(_DWORD *)(a1 + 4644) == *(_DWORD *)(a1 + 4640))
  {
    return 0;
  }
  else
  {
    unsigned int PhoneCount = siren_pipeline_GetPhoneCount(*(void *)(a1 + 4608));
    DurationStreauint64_t m = siren_pipeline_GetDurationStream(*(void *)(a1 + 4608));
    uint64_t result = 0;
    uint64_t v7 = *(unsigned int *)(a1 + 4644);
    unsigned int v8 = *(_DWORD *)(a1 + 4648);
    int v9 = *(_DWORD *)(a1 + 4660);
    for (uint64_t i = (_DWORD *)(*(void *)(a1 + 4632) + 32 * v7 + 16); ; i += 8)
    {
      unsigned int v11 = v7 + result;
      if ((v8 >= PhoneCount || v11 >= *(_DWORD *)(a1 + 4640)) && (!a2 || v11 >= *(_DWORD *)(a1 + 4640))) {
        break;
      }
      int v12 = *(i - 4);
      *(i - 1) = v9;
      if (v12 == 33)
      {
        *uint64_t i = *(_DWORD *)(DurationStream + 4 * v8);
        v9 += *(_DWORD *)(DurationStream + 4 * v8++);
      }
      else
      {
        *uint64_t i = 0;
      }
      uint64_t result = (result + 1);
    }
    *(_DWORD *)(a1 + 4660) = v9;
  }
  return result;
}

uint64_t select_bet6_loc_WriteStreams(uint64_t a1, int a2, unsigned int a3)
{
  if (!a1) {
    goto LABEL_17;
  }
  uint64_t v6 = *(_DWORD **)(a1 + 16);
  if (v6[2324] < 2u)
  {
    if (v6[2311])
    {
      AudioStreauint64_t m = siren_pipeline_GetAudioStream(*(void *)(a1 + 4608));
      int v8 = siren_pipeline_GetiSample(*(void *)(a1 + 4608));
      LODWORD(v31) = siren_pipeline_GetTailingPauseLen(*(void *)(a1 + 4608));
      if (AudioStream)
      {
        if (!a2
          || (uint64_t v9 = (*(uint64_t (**)(void, void, uint64_t, void))(*(void *)(a1 + 3704) + 104))(*(void *)(a1 + 3712), *(void *)(a1 + 3720), *(void *)(a1 + 4632) + 32 * *(unsigned int *)(a1 + 4644), (32 * a2)), (v9 & 0x80000000) == 0))
        {
          (*(void (**)(void, void, float *, uint64_t))(*(void *)(a1 + 3704) + 104))(*(void *)(a1 + 3760), *(void *)(a1 + 3768), &v31, 4);
          return (*(uint64_t (**)(void, void, uint64_t, void))(*(void *)(a1 + 3704) + 104))(*(void *)(a1 + 3760), *(void *)(a1 + 3768), AudioStream + 2 * *(unsigned int *)(a1 + 4656), (2 * (v8 - *(_DWORD *)(a1 + 4656))));
        }
        return v9;
      }
      return 10;
    }
    if (v6[2312] || v6[2314] || v6[2315])
    {
      float v31 = 0.0;
      if (a2)
      {
        uint64_t v11 = (*(uint64_t (**)(void, void, uint64_t, void))(*(void *)(a1 + 3704) + 104))(*(void *)(a1 + 3712), *(void *)(a1 + 3720), *(void *)(a1 + 4632) + 32 * *(unsigned int *)(a1 + 4644), (32 * a2));
        if ((v11 & 0x80000000) != 0) {
          return v11;
        }
      }
      else
      {
        uint64_t v11 = 0;
      }
      unsigned int FrameCount = siren_pipeline_GetFrameCount(*(void *)(a1 + 4608));
      TailingPauseLeuint64_t n = siren_pipeline_GetTailingPauseLen(*(void *)(a1 + 4608));
      if (FrameCount > *(_DWORD *)(a1 + 4652))
      {
        float v29 = (float)a3;
        int FrameSize = siren_pipeline_GetFrameSize(*(void *)(a1 + 4608));
        (*(void (**)(void, void, float *, uint64_t))(*(void *)(a1 + 3704) + 104))(*(void *)(a1 + 3728), *(void *)(a1 + 3736), &v29, 4);
        int Chunking = siren_pipeline_GetChunking(*(void *)(a1 + 4608));
        if (a3 - 2 <= 4 && Chunking) {
          LODWORD(v31) = siren_pipline_GetPhoneChunkingSpellPause(*(void *)(a1 + 4608));
        }
        (*(void (**)(void, void, float *, uint64_t))(*(void *)(a1 + 3704) + 104))(*(void *)(a1 + 3728), *(void *)(a1 + 3736), &v31, 4);
        (*(void (**)(void, void, int *, uint64_t))(*(void *)(a1 + 3704) + 104))(*(void *)(a1 + 3728), *(void *)(a1 + 3736), &TailingPauseLen, 4);
        AcousticStreauint64_t m = siren_pipeline_GetAcousticStream(*(void *)(a1 + 4608));
        if (a3 <= 5 && ((1 << a3) & 0x26) != 0)
        {
          int v24 = *(uint64_t (**)(void, void, uint64_t, void))(*(void *)(a1 + 3704) + 104);
          int v25 = *(_DWORD *)(a1 + 4652);
          uint64_t v26 = AcousticStream + 4 * ((v25 - 4) * FrameSize);
          int v27 = FrameCount - v25 + 4;
        }
        else
        {
          int v24 = *(uint64_t (**)(void, void, uint64_t, void))(*(void *)(a1 + 3704) + 104);
          int v28 = *(_DWORD *)(a1 + 4652);
          uint64_t v26 = AcousticStream + 4 * (v28 * FrameSize);
          int v27 = FrameCount - v28;
        }
        return v24(*(void *)(a1 + 3728), *(void *)(a1 + 3736), v26, (4 * FrameSize * v27));
      }
      return v11;
    }
LABEL_17:
    if (a2)
    {
      uint64_t v11 = (*(uint64_t (**)(void, void, uint64_t, void))(*(void *)(a1 + 3704) + 104))(*(void *)(a1 + 3712), *(void *)(a1 + 3720), *(void *)(a1 + 4632) + 32 * *(unsigned int *)(a1 + 4644), (32 * a2));
      if ((v11 & 0x80000000) != 0) {
        return v11;
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    unsigned int v12 = siren_pipeline_GetFrameCount(*(void *)(a1 + 4608));
    if (v12 > *(_DWORD *)(a1 + 4652))
    {
      unsigned int v13 = v12;
      float v31 = (float)a3;
      (*(void (**)(void, void, float *, uint64_t))(*(void *)(a1 + 3704) + 104))(*(void *)(a1 + 3728), *(void *)(a1 + 3736), &v31, 4);
      uint64_t v14 = siren_pipeline_GetAcousticStream(*(void *)(a1 + 4608));
      uint64_t v15 = *(uint64_t (**)(void, void, uint64_t, void))(*(void *)(a1 + 3704) + 104);
      int v16 = *(_DWORD *)(a1 + 4652);
      uint64_t v17 = v14 + 4 * siren_pipeline_GetFrameSize(*(void *)(a1 + 4608)) * v16;
      unsigned int v18 = v13 - *(_DWORD *)(a1 + 4652);
      int v19 = siren_pipeline_GetFrameSize(*(void *)(a1 + 4608));
      return v15(*(void *)(a1 + 3728), *(void *)(a1 + 3736), v17, 4 * v18 * v19);
    }
    return v11;
  }

  return select_bet6_loc_WriteStreams_MT(a1);
}

char *heap_StrDup(void *a1, char *__s)
{
  if (!__s) {
    return 0;
  }
  int v4 = cstdlib_strlen(__s);
  BOOL v5 = (char *)heap_Calloc(a1, (v4 + 1), 1);
  uint64_t v6 = v5;
  if (v5) {
    cstdlib_strcpy(v5, __s);
  }
  return v6;
}

uint64_t xfread_BET3(void *a1, unsigned int a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v5 = a3;
  uint64_t v6 = *a4;
  unsigned int v7 = a4[4];
  if (v6 + a3 * a2 > v7) {
    uint64_t v5 = (v7 - v6) / a2;
  }
  if (v5)
  {
    size_t v8 = v5 * a2;
    cstdlib_memcpy(a1, (const void *)(*((void *)a4 + 1) + v6), v8);
    *a4 += v8;
  }
  return v5;
}

uint64_t xfread2ptr_BET3(void *a1, unsigned int a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v4 = *a4;
  if (a2 >= 2 && v4 % a2) {
    return 0;
  }
  unsigned int v5 = a4[4];
  if (v4 + a3 * a2 > v5) {
    a3 = (v5 - v4) / a2;
  }
  if (a3)
  {
    *a1 = *((void *)a4 + 1) + v4;
    *a4 = v4 + a3 * a2;
  }
  return a3;
}

uint64_t log_out_Event(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  uint64_t v9 = a3 - 1;
  do
    int v10 = *(unsigned __int8 *)++v9;
  while (v10 == 10);
  return log_VOutEvent(*(uint64_t ***)(a1 + 32), a2, v9, &a9);
}

uint64_t log_select_Diag(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = a3 - 1;
  do
    int v4 = *(unsigned __int8 *)++v3;
  while (v4 == 10);
  return log_VOutText(*(void *)(a1 + 32), (uint64_t)"SELECT_BET3", (a2 + 2), 0, v3);
}

uint64_t log_select_Error(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return log_OutPublic(*(void *)(a1 + 32), (uint64_t)"SELECT_BET3", a2, 0, a5, a6, a7, a8, v9);
}

uint64_t log_select_GetLogLevel(uint64_t a1)
{
  unsigned int LogLevel = log_GetLogLevel(a1);
  if (LogLevel >= 3) {
    return LogLevel - 2;
  }
  else {
    return 0;
  }
}

float bet3_finv(float a1)
{
  float v1 = 0.0;
  if (a1 < 1.0e19 && a1 > -1.0e19)
  {
    if (a1 > 1.0e-19 || a1 < 0.0)
    {
      if (a1 < -1.0e-19 || a1 >= 0.0) {
        return 1.0 / a1;
      }
      else {
        return -1.0e38;
      }
    }
    else
    {
      return 1.0e38;
    }
  }
  return v1;
}

void *ddcalloc(void *a1, unsigned int a2, int a3)
{
  uint64_t v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    uint64_t v7 = a2;
    uint64_t v3 = (void *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      uint64_t v8 = heap_Calloc(a1, a3 * a2, 4);
      *uint64_t v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          uint64_t v9 = 1;
          uint64_t v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

void *ddcalloc_64(void *a1, unsigned int a2, int a3)
{
  uint64_t v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    uint64_t v7 = a2;
    uint64_t v3 = (void *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      uint64_t v8 = heap_Calloc(a1, a3 * a2, 4);
      *uint64_t v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          uint64_t v9 = 1;
          uint64_t v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

void *dd_free(void *result, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

void *dd_free_64(void *result, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

void *ffcalloc(void *a1, unsigned int a2, int a3)
{
  uint64_t v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    uint64_t v7 = a2;
    uint64_t v3 = (void *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      uint64_t v8 = heap_Calloc(a1, a3 * a2, 4);
      *uint64_t v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          uint64_t v9 = 1;
          uint64_t v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

void *ff_free(void *result, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

void *int32_ccalloc(void *a1, unsigned int a2, int a3)
{
  uint64_t v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    uint64_t v7 = a2;
    uint64_t v3 = (void *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      uint64_t v8 = heap_Calloc(a1, a3 * a2, 4);
      *uint64_t v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          uint64_t v9 = 1;
          uint64_t v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

void *int32_free(void *result, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

void *iicalloc(void *a1, unsigned int a2, int a3)
{
  uint64_t v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    uint64_t v7 = a2;
    uint64_t v3 = (void *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      uint64_t v8 = heap_Calloc(a1, a3 * a2, 4);
      *uint64_t v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          uint64_t v9 = 1;
          uint64_t v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

void *ii_free(void *result, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

uint64_t feat_frame_Init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)a3;
  uint64_t v7 = heap_Calloc(*(void **)(*(void *)a3 + 8), 1, 24);
  if (v7
    && (uint64_t v8 = (void *)v7, *(void *)(a3 + 40) = v7, (v9 = heap_Calloc(*(void **)(v6 + 8), 1000000, 4)) != 0))
  {
    *uint64_t v8 = a2;
    v8[1] = a1;
    v8[2] = v9;
    *(_DWORD *)(a3 + 112) = 1000000;
    siren_log_Diag(v6, (uint64_t)"feat frame init done...\n");
    return 0;
  }
  else
  {
    siren_log_Error(v6, (uint64_t)"memory allocation error");
    return 10;
  }
}

uint64_t feat_frame_Process(uint64_t a1)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)a1;
  uint64_t v2 = *(void **)(a1 + 40);
  uint64_t v4 = *v2;
  uint64_t v3 = v2[1];
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(v5 + 56);
  uint64_t v31 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v32 = *(void *)(a1 + 8);
  uint64_t v7 = (char *)v2[2];
  int v8 = *(_DWORD *)(v5 + 24);
  unsigned int v9 = (*(_DWORD *)(*v2 + 12) + *(_DWORD *)(v3 + 12)) * v8;
  if (v9 <= *(_DWORD *)(a1 + 112))
  {
    cstdlib_memset(v7, 0, 4 * ((*(_DWORD *)(*v2 + 12) + *(_DWORD *)(v3 + 12)) * v8));
  }
  else
  {
    uint64_t v11 = heap_Realloc(*(uint64_t **)(v1 + 8), (uint64_t)v7, 4 * ((*(_DWORD *)(*v2 + 12) + *(_DWORD *)(v3 + 12)) * v8));
    if (!v11)
    {
      int v28 = "memory allocation error";
      goto LABEL_23;
    }
    uint64_t v7 = (char *)v11;
    *(void *)(*(void *)(a1 + 40) + 16) = v11;
    *(_DWORD *)(a1 + 112) = v9;
  }
  uint64_t v12 = heap_Calloc(*(void **)(v1 + 8), (*(_DWORD *)(v4 + 12) * v8), 4);
  if (!v12)
  {
    siren_log_Error(v1, (uint64_t)"memory allocation error");
    int v28 = "get nn feature at frame level failed";
LABEL_23:
    siren_log_Error(v1, (uint64_t)v28);
    return 10;
  }
  uint64_t v13 = v12;
  unsigned int v29 = v9;
  uint64_t v30 = v1;
  uint64_t v14 = *(unsigned __int16 *)(v32 + 10);
  if (*(_WORD *)(v32 + 10))
  {
    uint64_t v15 = 0;
    int v16 = 0;
    do
    {
      unsigned int v17 = *(_DWORD *)(v6 + 4 * v15);
      if (v17)
      {
        int v18 = 0;
        int v19 = (float *)(v12 + 4 + 4 * v16);
        v16 += 2 * v17;
        do
        {
          *(v19 - 1) = (float)++v18;
          *int v19 = (float)v17;
          v19 += 2;
        }
        while (v17 != v18);
      }
      ++v15;
    }
    while (v15 != v14);
    unint64_t v20 = 0;
    int v21 = 0;
    unsigned int v22 = 0;
    do
    {
      int v23 = *(_DWORD *)(v6 + 4 * v20);
      if (v23)
      {
        int v24 = (const void *)(v31 + 4 * (*(_DWORD *)(v3 + 12) * v20));
        do
        {
          cstdlib_memcpy(&v7[4 * v21], (const void *)(v13 + 4 * v22), 4 * *(unsigned int *)(v4 + 12));
          int v25 = *(_DWORD *)(v4 + 12);
          int v26 = v25 + v21;
          v22 += v25;
          cstdlib_memcpy(&v7[4 * v26], v24, 4 * *(unsigned int *)(v3 + 12));
          int v21 = *(_DWORD *)(v3 + 12) + v26;
          --v23;
        }
        while (v23);
        LODWORD(v14) = *(unsigned __int16 *)(v32 + 10);
      }
      ++v20;
    }
    while (v20 < v14);
  }
  heap_Free(*(void **)(v30 + 8), v13);
  siren_log_Diag(v30, (uint64_t)"feat frame process done...\n");
  if (log_GetLogLevel(*(void *)(v30 + 32)) >= 3)
  {
    siren_compute_stream_hash(v7, 4 * v29, v33);
    siren_log_Diag(v30, (uint64_t)"FEAT_FRAME_MD5=%s\n");
  }
  return 0;
}

uint64_t feat_frame_Close(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (void *)a1[5];
  *uint64_t v3 = 0;
  v3[1] = 0;
  uint64_t v4 = v3[2];
  if (v4)
  {
    heap_Free(*(void **)(v2 + 8), v4);
    v3[2] = 0;
  }
  heap_Free(*(void **)(v2 + 8), (uint64_t)v3);
  a1[5] = 0;
  siren_log_Diag(v2, (uint64_t)"feat frame close done....\n");
  return 0;
}

uint64_t feat_phone_Init(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)a2;
  uint64_t v5 = heap_Calloc(*(void **)(*(void *)a2 + 8), 1, 16);
  if (v5 && (uint64_t v6 = (void *)v5, *(void *)(a2 + 32) = v5, (v7 = heap_Calloc(*(void **)(v4 + 8), 50000, 4)) != 0))
  {
    *uint64_t v6 = a1 + 7992;
    v6[1] = v7;
    *(_DWORD *)(a2 + 108) = 50000;
    siren_log_Diag(v4, (uint64_t)"feat phone init done....\n");
    return 0;
  }
  else
  {
    siren_log_Error(v4, (uint64_t)"memory allocation error");
    return 10;
  }
}

uint64_t feat_phone_Process(uint64_t a1)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)a1;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v5 = (uint64_t *)*v3;
  uint64_t v4 = (char *)v3[1];
  uint64_t v6 = *(char **)(a1 + 16);
  uint64_t v7 = *(_DWORD *)(*v3 + 12) * *(unsigned __int16 *)(v2 + 10);
  if (v7 <= *(_DWORD *)(a1 + 108))
  {
    __src = *(char **)(a1 + 16);
    unsigned int v30 = *(_DWORD *)(*v3 + 12) * *(unsigned __int16 *)(v2 + 10);
    cstdlib_memset(v4, 0, 4 * v30);
  }
  else
  {
    heap_Free(*(void **)(v1 + 8), (uint64_t)v4);
    uint64_t v8 = heap_Calloc(*(void **)(v1 + 8), v7, 4);
    if (!v8)
    {
      siren_log_Error(v1, (uint64_t)"memory allocation error");
      return 10;
    }
    uint64_t v4 = (char *)v8;
    __src = v6;
    *(void *)(*(void *)(a1 + 32) + 8) = v8;
    unsigned int v30 = v7;
    *(_DWORD *)(a1 + 108) = v7;
  }
  int v9 = *(__int16 *)(v2 + 10);
  if (v9 >= 1)
  {
    unint64_t v10 = 0;
    unsigned __int8 v11 = 0;
    LODWORD(v12) = *((_DWORD *)v5 + 2);
    while ((int)v12 <= 0)
    {
      int64_t v16 = v10 + 1;
LABEL_42:
      unint64_t v10 = v16;
      if (v16 >= (__int16)v9) {
        goto LABEL_43;
      }
    }
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    int v15 = *((_DWORD *)v5 + 3) * v10;
    int64_t v16 = v10 + 1;
    int v32 = v15;
    while (1)
    {
      uint64_t v17 = *v5;
      uint64_t v18 = *(unsigned __int8 *)(*v5 + v13);
      if (*(unsigned __int8 *)(*v5 + v13) > 0xFBu) {
        break;
      }
      if (v18 == 3 || v18 == 5) {
        goto LABEL_32;
      }
      if (v18 == 216)
      {
        uint64_t v22 = v2;
        uint64_t v23 = v1;
        int v24 = (_DWORD *)(v17 + v13);
        if (v24[1] == 1) {
          uint64_t v25 = v24[2];
        }
        else {
          uint64_t v25 = 1;
        }
        cstdlib_memcpy(&v4[4 * v24[3] + 4 * *((_DWORD *)v5 + 3) * (int)v10], __src, 4 * v25);
        __src += 4 * v25;
        uint64_t v1 = v23;
        uint64_t v2 = v22;
        int64_t v16 = v10 + 1;
        int v15 = v32;
        if (*(_DWORD *)(a1 + 24) < ((unint64_t)&__src[-*(void *)(a1 + 16)] >> 2))
        {
          siren_log_Error(v1, (uint64_t)"invalid external features stream");
          return 21;
        }
      }
      else
      {
LABEL_27:
        uint64_t v27 = *(void *)(v2 + 8 * v18 + 16);
        if (v27)
        {
          int v26 = (unsigned __int8 *)(v27 + v10);
LABEL_29:
          unsigned __int8 v11 = *v26;
LABEL_32:
          uint64_t v28 = v17 + v13;
          if (*(_DWORD *)(v17 + v13 + 4) == 1)
          {
            if (*(unsigned __int8 *)(v28 + 8) <= v11) {
              siren_log_Diag(v1, (uint64_t)"phone-level categorical feature extraction out of range: feature_index=%d, feature_value=%d, feature_range=%d.");
            }
            else {
              *(_DWORD *)&v4[4 * v15 + 4 * v11 + 4 * *(_DWORD *)(v17 + v13 + 12)] = 1065353216;
            }
          }
          else
          {
            *(float *)&v4[4 * (*(_DWORD *)(v28 + 12) + v15)] = (float)v11;
          }
        }
      }
      ++v14;
      uint64_t v12 = *((int *)v5 + 2);
      v13 += 16;
      if (v14 >= v12)
      {
        LOWORD(v9) = *(_WORD *)(v2 + 10);
        goto LABEL_42;
      }
    }
    switch(*(unsigned char *)(*v5 + v13))
    {
      case 0xFC:
        if (v10 < 2) {
          goto LABEL_30;
        }
        uint64_t v19 = *(void *)(v2 + 32);
        unint64_t v20 = (v10 - 2);
        goto LABEL_26;
      case 0xFD:
        if (!v10) {
          goto LABEL_31;
        }
        uint64_t v19 = *(void *)(v2 + 32);
        unint64_t v20 = (v10 - 1);
        goto LABEL_26;
      case 0xFE:
        if (v16 < *(__int16 *)(v2 + 10))
        {
          int v26 = (unsigned __int8 *)(*(void *)(v2 + 32) + v16);
          goto LABEL_29;
        }
LABEL_31:
        unsigned __int8 v11 = 0;
        goto LABEL_32;
      case 0xFF:
        unint64_t v20 = v10 + 2;
        if ((uint64_t)(v10 + 2) >= *(__int16 *)(v2 + 10))
        {
LABEL_30:
          unsigned __int8 v11 = -1;
          goto LABEL_32;
        }
        uint64_t v19 = *(void *)(v2 + 32);
LABEL_26:
        int v26 = (unsigned __int8 *)(v19 + v20);
        break;
      default:
        goto LABEL_27;
    }
    goto LABEL_29;
  }
LABEL_43:
  siren_log_Diag(v1, (uint64_t)"feat phone process done....\n");
  if (log_GetLogLevel(*(void *)(v1 + 32)) >= 3)
  {
    siren_compute_stream_hash(v4, 4 * v30, v34);
    siren_log_Diag(v1, (uint64_t)"FEAT_PHONE_MD5=%s\n");
  }
  return 0;
}

uint64_t feat_phone_Close(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (void *)a1[4];
  *uint64_t v3 = 0;
  uint64_t v4 = v3[1];
  if (v4)
  {
    heap_Free(*(void **)(v2 + 8), v4);
    v3[1] = 0;
  }
  heap_Free(*(void **)(v2 + 8), (uint64_t)v3);
  a1[4] = 0;
  siren_log_Diag(v2, (uint64_t)"feat phone close done....\n");
  return 0;
}

uint64_t infer_acoustic_init(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v11 = 0;
  uint64_t v5 = heap_Calloc(*(void **)(v4 + 8), 1, 64);
  if (v5)
  {
    uint64_t v6 = (void *)v5;
    a1[7] = v5;
    *(void *)(v5 + 48) = v4;
    uint64_t v7 = (uint64_t **)(v5 + 56);
    uint64_t v8 = fi_rsc_create((void *)v4, (void *)(v5 + 56));
    if (v8)
    {
      uint64_t v9 = v8;
      siren_log_Error(v4, (uint64_t)"Acoustic Model FI Resource creation failed: %d");
    }
    else
    {
      uint64_t v9 = parse_fi_binary_model(*v7, a2, &v11);
      if (v9)
      {
        siren_log_Error(v4, (uint64_t)"Acoustic Model FI binary model parsing failed: %d");
      }
      else
      {
        *uint64_t v6 = v11;
        siren_log_Diag(v4, (uint64_t)"infer(acoustic) init done.... \n");
      }
    }
  }
  else
  {
    siren_log_Error(v4, (uint64_t)"memory allocation error");
    return 10;
  }
  return v9;
}

uint64_t infer_acoustic_process(uint64_t a1)
{
  return infer_acoustic_process_range(a1, 0, *(unsigned int *)(*(void *)(a1 + 48) + 24));
}

uint64_t infer_acoustic_process_range(uint64_t a1, int a2, uint64_t a3)
{
  _OWORD v77[4] = *(const void **)MEMORY[0x263EF8340];
  uint64_t v5 = *(void *)a1;
  unsigned int v6 = *(_DWORD *)(a1 + 136);
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = *(void **)(a1 + 40);
  uint64_t v9 = v8[2];
  int v10 = *(_DWORD *)(v8[1] + 12);
  int v11 = *(_DWORD *)(*v8 + 12);
  if (v6 < 2)
  {
    uint64_t v76 = 0;
    long long v74 = 0u;
    long long v75 = 0u;
    long long v73 = 0u;
    compstats_ClockInit(&v73);
    compstats_ClockStart((uint64_t)&v73, v39, v40, v41, v42, v43, v44, v45);
    *(void *)(v7 + 8) = v9;
    uint64_t v46 = ((*(_DWORD *)(**(void **)(a1 + 40) + 12)
                        + *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 12))
                       * a3);
    uint64_t v47 = (void *)heap_Calloc(*(void **)(*(void *)(v7 + 48) + 8), v46, 4);
    v77[0] = v47;
    if (v47)
    {
      cstdlib_memcpy(v47, (const void *)(*(void *)(v7 + 8) + 4 * ((v11 + v10) * a2)), 4 * v46);
      uint64_t v52 = fi_net_predict(*(uint64_t ***)v7, v77, a3, (void *)(v7 + 24), v48, v49, v50, v51);
      if (v52)
      {
        uint64_t v53 = v52;
        siren_log_Error(v5, (uint64_t)"Acoustic Model FI inferece failed: %d");
        uint64_t v37 = v53;
        goto LABEL_31;
      }
      siren_log_Diag(v5, (uint64_t)"infer(acoustic) process one sentence done....\n");
      compstats_ClockStop((uint64_t)&v73, v54, v55, v56, v57, v58, v59, v60);
      siren_log_Trace(v5, (uint64_t)"CompStatsReport, infer_acoustic_process_range, start: %u, nFrames: %u, %7.2f msec CPU, %7.2f msec real\n");
      compstats_ClockReset((uint64_t)&v73);
      if (log_GetLogLevel(*(void *)(v5 + 32)) < 3) {
        goto LABEL_30;
      }
      siren_compute_stream_hash(*(char **)(v7 + 24), 4 * *(_DWORD *)(*(void *)v7 + 96) / a3 * a3, (char *)v77);
      int v61 = "INFER_ACOUSTIC_MD5=%s\n";
      goto LABEL_29;
    }
LABEL_21:
    siren_log_Error(v5, (uint64_t)"memory allocation error.");
    uint64_t v37 = 10;
    goto LABEL_31;
  }
  unsigned int v12 = v11 + v10;
  uint64_t v76 = 0;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v73 = 0u;
  compstats_ClockInit(&v73);
  compstats_ClockStart((uint64_t)&v73, v13, v14, v15, v16, v17, v18, v19);
  *(void *)(v7 + 8) = v9;
  unsigned int v20 = a3 / v6;
  unsigned int v21 = a3 % v6;
  unsigned int v22 = v6 - a3 % v6;
  if (a3 % v6) {
    unsigned int v23 = v6 - a3 % v6;
  }
  else {
    unsigned int v23 = 0;
  }
  if (v21) {
    unsigned int v24 = v20 + 1;
  }
  else {
    unsigned int v24 = a3 / v6;
  }
  uint64_t v25 = (char *)heap_Calloc(*(void **)(*(void *)(v7 + 48) + 8), v24 * v12, 4);
  v77[0] = v25;
  if (!v25) {
    goto LABEL_21;
  }
  uint64_t v30 = *(void *)(v7 + 8);
  if (!v30)
  {
    uint64_t v37 = 6;
    siren_log_Error(v5, (uint64_t)"Linguistic features fetch failed: %d");
    goto LABEL_31;
  }
  uint64_t v31 = v25;
  int v32 = (char *)(v30 + 4 * v12 * a2 + 4 * v12 * (v6 - 1));
  if (v6 <= a3)
  {
    uint64_t v71 = v5;
    unsigned int v33 = a3 / v6;
    do
    {
      uint64_t v34 = v32;
      cstdlib_memcpy(v31, v32, 4 * v12);
      v31 += 4 * v12;
      int v32 = &v34[4 * v12 * v6];
      --v33;
    }
    while (v33);
    int v32 = &v34[4 * v12 * v6];
    uint64_t v5 = v71;
    unsigned int v22 = v6 - a3 % v6;
  }
  if (v23) {
    cstdlib_memcpy(v31, &v32[-4 * v23 * v12], 4 * v12);
  }
  uint64_t v35 = fi_net_predict(*(uint64_t ***)v7, v77, v23 + v20, (void *)(v7 + 24), v26, v27, v28, v29);
  if (v35)
  {
    uint64_t v36 = v35;
    siren_log_Error(v5, (uint64_t)"Acoustic Model FI inferece failed: %d");
    uint64_t v37 = v36;
    goto LABEL_31;
  }
  if (v21)
  {
    unsigned int v62 = *(_DWORD *)(*(void *)v7 + 96) / ((v23 + v20) * v6);
    cstdlib_memcpy((void *)(*(void *)(v7 + 24) + 4 * v62 * v20 * v6), (const void *)(*(void *)(v7 + 24) + 4 * v62 * (v20 * v6 + v22)), 4 * v62 * v21);
  }
  siren_log_Diag(v5, (uint64_t)"infer(acoustic) process one sentence done....\n");
  compstats_ClockStop((uint64_t)&v73, v63, v64, v65, v66, v67, v68, v69);
  siren_log_Trace(v5, (uint64_t)"CompStatsReport, infer_acoustic_process_range, start: %u, nFrames: %u, %7.2f msec CPU, %7.2f msec real\n");
  compstats_ClockReset((uint64_t)&v73);
  if (log_GetLogLevel(*(void *)(v5 + 32)) >= 3)
  {
    siren_compute_stream_hash(*(char **)(v7 + 24), 4 * *(_DWORD *)(*(void *)v7 + 96), (char *)v77);
    int v61 = "INFER_ACOUSTIC_MD5=%s";
LABEL_29:
    siren_log_Diag(v5, (uint64_t)v61);
  }
LABEL_30:
  uint64_t v37 = 0;
LABEL_31:
  if (v37) {
    siren_log_Error(v5, (uint64_t)"Acoustic Model FI Predict failed: %d");
  }
  return v37;
}

uint64_t infer_acoustic_seq2seq_process_range_stream(uint64_t *a1, int a2, int a3)
{
  uint64_t v6 = *a1;
  uint64_t v7 = a1[7];
  uint64_t v8 = *(void *)(a1[4] + 8);
  uint64_t v37 = 0;
  memset(v36, 0, sizeof(v36));
  compstats_ClockInit(v36);
  compstats_ClockStart((uint64_t)v36, v9, v10, v11, v12, v13, v14, v15);
  uint64_t v16 = (void *)a1[4];
  uint64_t v17 = *(unsigned int *)(*v16 + 12);
  int v18 = *(unsigned __int16 *)(a1[1] + 10);
  *(void *)(v7 + 16) = v8;
  uint64_t v19 = (char *)v16[1];
  unsigned int v20 = (char *)heap_Calloc(*(void **)(*(void *)(v7 + 48) + 8), (v17 * (a3 + 2)), 4);
  uint64_t v38 = v20;
  if (v20)
  {
    unsigned int v21 = v20;
    cstdlib_memcpy(v20, v19, 4 * v17);
    cstdlib_memcpy(&v21[4 * v17], (const void *)(*(void *)(v7 + 16) + 4 * (v17 * a2)), 4 * (v17 * a3));
    cstdlib_memcpy(&v21[4 * (v17 + v17 * a3)], &v19[4 * ((v18 - 1) * v17)], 4 * v17);
    uint64_t v26 = fi_net_predict(*(uint64_t ***)v7, &v38, (a3 + 2), (void *)(v7 + 24), v22, v23, v24, v25);
    if (v26)
    {
      uint64_t bytes = v26;
      siren_log_Error(v6, (uint64_t)"Acoustic Model FI inferece failed: %d");
    }
    else
    {
      uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)v7 + 92), (_DWORD *)(v7 + 40));
      if (bytes)
      {
        siren_log_Error(v6, (uint64_t)"Get Acoustic Model output shape failed: %d");
      }
      else
      {
        siren_log_Diag(v6, (uint64_t)"infer(acoustic) process one sentence done....\n");
        compstats_ClockStop((uint64_t)v36, v28, v29, v30, v31, v32, v33, v34);
        siren_log_Trace(v6, (uint64_t)"CompStatsReport, infer_acoustic_process_range, start: %u, nFrames: %u, %7.2f msec CPU, %7.2f msec real\n");
        compstats_ClockReset((uint64_t)v36);
      }
    }
  }
  else
  {
    siren_log_Error(v6, (uint64_t)"memory allocation error.");
    return 10;
  }
  return bytes;
}

uint64_t infer_acoustic_seq2seq_process_range_FrameInfer(uint64_t a1, uint64_t *a2, int a3, int a4)
{
  uint64_t v7 = *a2;
  uint64_t v8 = a2[7];
  uint64_t v9 = *(void *)(a2[4] + 8);
  uint64_t v41 = 0;
  memset(v40, 0, sizeof(v40));
  compstats_ClockInit(v40);
  compstats_ClockStart((uint64_t)v40, v10, v11, v12, v13, v14, v15, v16);
  uint64_t v17 = (void *)a2[4];
  uint64_t v18 = *(unsigned int *)(*v17 + 12);
  int v19 = *(unsigned __int16 *)(a2[1] + 10);
  *(void *)(v8 + 16) = v9;
  unsigned int v20 = (char *)v17[1];
  unsigned int v21 = (char *)heap_Calloc(*(void **)(*(void *)(v8 + 48) + 8), (v18 * (a4 + 2)), 4);
  uint64_t v42 = v21;
  if (v21)
  {
    uint64_t v22 = v21;
    cstdlib_memcpy(v21, v20, 4 * v18);
    cstdlib_memcpy(&v22[4 * v18], (const void *)(*(void *)(v8 + 16) + 4 * (v18 * a3)), 4 * (v18 * a4));
    cstdlib_memcpy(&v22[4 * (v18 + v18 * a4)], &v20[4 * ((v19 - 1) * v18)], 4 * v18);
    uint64_t updated = fi_net_update_param(*(void *)v8);
    if (updated)
    {
      uint64_t bytes = updated;
      siren_log_Error(v7, (uint64_t)"Acoustic model speaker_id set failed: %d");
    }
    else
    {
      uint64_t v29 = fi_net_predict(*(uint64_t ***)v8, &v42, (a4 + 2), (void *)(v8 + 24), v24, v25, v26, v27);
      if (v29)
      {
        uint64_t bytes = v29;
        uint64_t v30 = "Acoustic Model FI inferece failed: %d";
        uint64_t v31 = v7;
      }
      else
      {
        uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)v8 + 92), (_DWORD *)(v8 + 40));
        if (!bytes)
        {
          siren_log_Diag(v7, (uint64_t)"infer(acoustic) process one sentence done....\n");
          compstats_ClockStop((uint64_t)v40, v33, v34, v35, v36, v37, v38, v39);
          siren_log_Trace(v7, (uint64_t)"CompStatsReport, infer_acoustic_process_range, start: %u, nFrames: %u, %7.2f msec CPU, %7.2f msec real\n");
          compstats_ClockReset((uint64_t)v40);
          return bytes;
        }
        uint64_t v30 = "Get Acoustic Model output shape failed: %d";
        uint64_t v31 = v7;
      }
      siren_log_Error(v31, (uint64_t)v30);
    }
  }
  else
  {
    siren_log_Error(v7, (uint64_t)"memory allocation error.");
    return 10;
  }
  return bytes;
}

uint64_t infer_acoustic_seq2seq_process_range(uint64_t a1, uint64_t *a2, int a3, unsigned int a4)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  uint64_t v7 = *a2;
  uint64_t v8 = a2[7];
  uint64_t v9 = *(void *)(a2[4] + 8);
  uint64_t v41 = 0;
  memset(v40, 0, sizeof(v40));
  compstats_ClockInit(v40);
  compstats_ClockStart((uint64_t)v40, v10, v11, v12, v13, v14, v15, v16);
  uint64_t v17 = (void *)a2[4];
  uint64_t v18 = *(unsigned int *)(*v17 + 12);
  int v19 = *(unsigned __int16 *)(a2[1] + 10);
  *(void *)(v8 + 16) = v9;
  unsigned int v20 = (char *)v17[1];
  unsigned int v21 = (char *)heap_Calloc(*(void **)(*(void *)(v8 + 48) + 8), v18 * (a4 + 2), 4);
  uint64_t v42 = v21;
  if (!v21)
  {
    siren_log_Error(v7, (uint64_t)"memory allocation error.");
    return 10;
  }
  uint64_t v22 = v21;
  cstdlib_memcpy(v21, v20, 4 * v18);
  cstdlib_memcpy(&v22[4 * v18], (const void *)(*(void *)(v8 + 16) + 4 * (v18 * a3)), 4 * v18 * a4);
  cstdlib_memcpy(&v22[4 * v18 + 4 * v18 * a4], &v20[4 * ((v19 - 1) * v18)], 4 * v18);
  uint64_t updated = fi_net_update_param(*(void *)v8);
  if (updated)
  {
    uint64_t v28 = updated;
    siren_log_Error(v7, (uint64_t)"Acoustic model speakerid set faled: %d");
    return v28;
  }
  uint64_t v29 = fi_net_predict(*(uint64_t ***)v8, &v42, a4 + 2, (void *)(v8 + 32), v24, v25, v26, v27);
  if (v29)
  {
    uint64_t v28 = v29;
    uint64_t v30 = "Acoustic Model FI inferece failed: %d";
LABEL_9:
    siren_log_Error(v7, (uint64_t)v30);
    return v28;
  }
  uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)v8 + 92), (_DWORD *)(v8 + 44));
  if (bytes)
  {
    uint64_t v28 = bytes;
    uint64_t v30 = "Get Acoustic Model output shape failed: %d";
    goto LABEL_9;
  }
  siren_log_Diag(v7, (uint64_t)"infer(acoustic) process one sentence done....\n");
  compstats_ClockStop((uint64_t)v40, v33, v34, v35, v36, v37, v38, v39);
  siren_log_Trace(v7, (uint64_t)"CompStatsReport, infer_acoustic_process_range, start: %u, nFrames: %u, %7.2f msec CPU, %7.2f msec real\n");
  compstats_ClockReset((uint64_t)v40);
  if (log_GetLogLevel(*(void *)(v7 + 32)) >= 3)
  {
    siren_compute_stream_hash(*(char **)(v8 + 32), 4 * *(_DWORD *)(*(void *)v8 + 96) / a4 * a4, v43);
    siren_log_Diag(v7, (uint64_t)"INFER_ACOUSTIC_MD5=%s\n");
  }
  return 0;
}

uint64_t infer_acoustic_end(uint64_t *a1)
{
  uint64_t v2 = (uint64_t *)a1[7];
  uint64_t v3 = *a1;
  if (*v2)
  {
    fi_net_destroy(*v2);
    *uint64_t v2 = 0;
  }
  v2[1] = 0;
  v2[2] = 0;
  uint64_t v4 = (void *)v2[7];
  if (v4)
  {
    fi_rsc_destroy(v4);
    v2[7] = 0;
  }
  heap_Free(*(void **)(v3 + 8), (uint64_t)v2);
  a1[7] = 0;
  siren_log_Diag(v3, (uint64_t)"infer(acoustic) close done....\n");
  return 0;
}

uint64_t infer_acoustic_reset_seed(uint64_t a1)
{
  return 0;
}

uint64_t chunking_Init(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = heap_Calloc(*(void **)(*a1 + 8), 1, 32);
  if (v5)
  {
    *(void *)uint64_t v5 = 0;
    *(_WORD *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(_WORD *)(v5 + 24) = 0;
    a1[9] = v5;
    uint64_t v6 = heap_Calloc(*(void **)(v4 + 8), 1, 56);
    if (v6)
    {
      *(void *)uint64_t v6 = 0;
      *(_WORD *)(v6 + 8) = 0;
      *(_WORD *)(v6 + 48) = 0;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 0;
      *(void *)(v6 + 16) = 0;
      a1[8] = v6;
      uint64_t v7 = heap_Calloc(*(void **)(v4 + 8), 1, 32);
      if (v7)
      {
        *(void *)(v7 + 8) = 0;
        *(_WORD *)(v7 + 24) = 0;
        *(_WORD *)uint64_t v7 = 0;
        a1[11] = v7;
        if (!*(_DWORD *)(a2 + 9184)) {
          return 0;
        }
        uint64_t v8 = heap_Calloc(*(void **)(v4 + 8), 1, 40);
        if (v8)
        {
          uint64_t v9 = v8;
          uint64_t result = 0;
          int v11 = *(_DWORD *)(a2 + 9172);
          *(_DWORD *)uint64_t v9 = 0;
          *(_DWORD *)(v9 + 4) = v11;
          *(void *)(v9 + 32) = 0;
          *(void *)(v9 + 8) = 0;
          *(void *)(v9 + 16) = 0;
          a1[10] = v9;
          return result;
        }
        uint64_t v12 = "sample level chunking memory allocation error";
      }
      else
      {
        uint64_t v12 = "markers chunking memory allocation error";
      }
    }
    else
    {
      uint64_t v12 = "phone level chunking memory allocation error";
    }
  }
  else
  {
    uint64_t v12 = "frame level chunking memory allocation error";
  }
  siren_log_Error(v4, (uint64_t)v12);
  return 10;
}

uint64_t chunking_Process(int32x2_t *a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v4 = *(void *)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  if (!v5)
  {
    siren_log_Error(v4, (uint64_t)"Front end message is empty!");
    return 7;
  }
  uint64_t v10 = *(void *)(a2 + 72);
  int v11 = *(unsigned int **)(a2 + 80);
  uint64_t v12 = *(void *)(a2 + 64);
  int v13 = a1[924].u8[7];
  uint64_t v14 = *(unsigned __int16 *)(v5 + 10);
  *(_WORD *)(v12 + 8) = v14;
  *(_WORD *)(v10 + 8) = v14;
  uint64_t v15 = heap_Calloc(*(void **)(v4 + 8), v14, 1);
  *(void *)uint64_t v12 = v15;
  if (!v15) {
    goto LABEL_39;
  }
  uint64_t v16 = heap_Calloc(*(void **)(v4 + 8), *(unsigned __int16 *)(v10 + 8), 1);
  *(void *)uint64_t v10 = v16;
  if (!v16) {
    goto LABEL_39;
  }
  uint64_t v17 = *(__int16 *)(v5 + 10);
  if (v17 >= 1)
  {
    for (uint64_t i = 0; i < v17; ++i)
    {
      *(unsigned char *)(*(void *)v12 + i) = 1;
      *(unsigned char *)(*(void *)v10 + i) = 1;
      uint64_t v17 = *(__int16 *)(v5 + 10);
    }
    if ((int)v17 >= 1)
    {
      uint64_t v19 = 0;
      while (1)
      {
        if (*(unsigned char *)(*(void *)(v5 + 72) + v19) == 1)
        {
          if (*(unsigned __int8 *)(*(void *)(v5 + 32) + v19) == v13)
          {
            LOBYTE(v17) = 8;
LABEL_14:
            *(unsigned char *)(*(void *)v12 + v19) = v17;
            *(unsigned char *)(*(void *)v10 + v19) = v17;
            LOWORD(v17) = *(_WORD *)(v5 + 10);
            goto LABEL_15;
          }
          unsigned int v20 = (*(unsigned char *)(*(void *)(v5 + 592) + v19) - 1);
          if (v20 <= 3)
          {
            LODWORD(v17) = 0x6040302u >> (8 * v20);
            goto LABEL_14;
          }
        }
LABEL_15:
        if (++v19 >= (__int16)v17)
        {
          uint64_t v17 = (__int16)v17;
          break;
        }
      }
    }
  }
  *(unsigned char *)(v17 + *(void *)v12 - 1) = 10;
  if (a1[1139].i32[1] || a1[1140].i32[0] || a1[1141].i32[0])
  {
    chunking_Do_PhoneChunking((uint64_t)a1, v12, a3, a4);
    uint64_t v21 = heap_Calloc(*(void **)(v4 + 8), *(unsigned __int16 *)(v12 + 48), 4);
    *(void *)(v12 + 16) = v21;
    if (!v21) {
      goto LABEL_39;
    }
    uint64_t v22 = heap_Calloc(*(void **)(v4 + 8), *(unsigned __int16 *)(v12 + 48), 2);
    *(void *)(v12 + 24) = v22;
    if (!v22) {
      goto LABEL_39;
    }
    uint64_t v23 = heap_Calloc(*(void **)(v4 + 8), *(unsigned __int16 *)(v12 + 48), 2);
    *(void *)(v12 + 32) = v23;
    if (!v23) {
      goto LABEL_39;
    }
    uint64_t v24 = heap_Calloc(*(void **)(v4 + 8), *(unsigned __int16 *)(v12 + 48), 2);
    *(void *)(v12 + 40) = v24;
    if (!v24) {
      goto LABEL_39;
    }
    chunking_Do_PhoneChunking((uint64_t)a1, v12, a3, a4);
    unsigned int v25 = 0;
  }
  else
  {
    uint64_t v35 = *(void *)(a2 + 48);
    uint64_t v36 = *(void *)(v35 + 56);
    unsigned int v25 = *(_DWORD *)(v35 + 24);
    uint64_t result = chunking_Do_FrameChunking(v4, (uint64_t)a1, v36, v25, v10);
    if (result) {
      return result;
    }
    uint64_t v37 = heap_Calloc(*(void **)(v4 + 8), *(unsigned __int16 *)(v10 + 24), 4);
    *(void *)(v10 + 16) = v37;
    if (!v37) {
      goto LABEL_39;
    }
    uint64_t result = chunking_Do_FrameChunking(v4, (uint64_t)a1, v36, v25, v10);
    if (result) {
      return result;
    }
  }
  if (!a1[1148].i32[0]) {
    return 0;
  }
  uint64_t v26 = *(void *)(a2 + 80);
  uint64_t v27 = heap_Calloc(*(void **)(v4 + 8), 1, 72);
  if (!v27)
  {
    uint64_t v38 = "sample level chunking memory allocation error";
    goto LABEL_40;
  }
  uint64_t v28 = v27;
  *(void *)uint64_t v27 = v26;
  *(_DWORD *)(v27 + 8) = a1[1147].i32[0];
  unsigned int v29 = a1[1145].u32[1];
  *(_DWORD *)(v27 + 12) = v29;
  *(_DWORD *)(v27 + 24) = a1[1148].i32[1];
  *(int32x2_t *)(v27 + 16) = vrev64_s32(a1[1146]);
  *(_DWORD *)(v27 + 28) = 22050;
  *(_DWORD *)(v27 + 32) = v25;
  *(_DWORD *)(v27 + 36) = 0;
  *(_DWORD *)(v27 + 40) = 0;
  *(float *)(v27 + 48) = (float)v29;
  *(_DWORD *)(v27 + 44) = v25;
  *(_DWORD *)(v27 + 52) = *(_DWORD *)(a2 + 104);
  *(void *)(v27 + 56) = *(void *)(a2 + 96);
  uint64_t result = chunking_Do_SampleChunking_Process(v4, (int **)v27);
  if (result) {
    return result;
  }
  uint64_t v31 = heap_Calloc(*(void **)(v4 + 8), *v11, 4);
  *((void *)v11 + 1) = v31;
  if (v31)
  {
    uint64_t v32 = heap_Calloc(*(void **)(v4 + 8), *v11, 4);
    *((void *)v11 + 2) = v32;
    if (v32)
    {
      uint64_t v33 = heap_Calloc(*(void **)(v4 + 8), *(_DWORD *)(v28 + 20) * *v11, 4);
      *((void *)v11 + 3) = v33;
      if (v33)
      {
        uint64_t v34 = heap_Calloc(*(void **)(v4 + 8), *(_DWORD *)(v28 + 20) * *v11, 4);
        *((void *)v11 + 4) = v34;
        if (v34)
        {
          chunking_Do_SampleChunking_ProcessReset(v4, v28);
          chunking_Do_SampleChunking_Process(v4, (int **)v28);
          heap_Free(*(void **)(v4 + 8), v28);
          return 0;
        }
      }
    }
  }
LABEL_39:
  uint64_t v38 = "memory allocation error";
LABEL_40:
  siren_log_Error(v4, (uint64_t)v38);
  return 10;
}

uint64_t chunking_Do_PhoneChunking(uint64_t result, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v5 = result;
  unsigned int v6 = *(unsigned __int16 *)(a2 + 8);
  if (a3 && a4)
  {
    if (*a4)
    {
      unint64_t v8 = 0;
      int v9 = 0;
      unsigned int v10 = 0;
      int v11 = (const char **)(a3 + 24);
      LOWORD(v12) = 100;
      unsigned int v13 = *(unsigned __int16 *)(a2 + 8);
      do
      {
        int v14 = *((_DWORD *)v11 - 6);
        if (v14 == 31)
        {
          int v12 = *(_DWORD *)v11;
        }
        else if (v14 == 21)
        {
          uint64_t result = cstdlib_strcmp(*v11, "spell");
          if (result)
          {
            uint64_t result = cstdlib_strcmp(*v11, "normal");
            if (!result && v10 <= v13 && v13 != v6) {
              unsigned int v10 = *((_DWORD *)v11 - 3);
            }
          }
          else
          {
            if (v13 == v6) {
              unsigned int v13 = *((_DWORD *)v11 - 3);
            }
            int v9 = 1;
          }
        }
        ++v8;
        v11 += 4;
      }
      while (v8 < *a4);
    }
    else
    {
      unsigned int v10 = 0;
      int v9 = 0;
      LOWORD(v12) = 100;
      unsigned int v13 = *(unsigned __int16 *)(a2 + 8);
    }
    if (v10) {
      BOOL v20 = 0;
    }
    else {
      BOOL v20 = v9 == 1;
    }
    if (v20) {
      unsigned int v21 = v6 - 1;
    }
    else {
      unsigned int v21 = v10;
    }
    if (v6)
    {
      unsigned int v22 = 0;
      unsigned int v16 = 0;
      do
      {
        uint64_t result = phone_chunking_search(v5, v22, a2);
        uint64_t v17 = *(void *)(a2 + 16);
        if (v17) {
          *(_DWORD *)(v17 + 4 * v16) = result;
        }
        uint64_t v23 = *(void *)(a2 + 24);
        if (v23)
        {
          if (result <= v21 && result > v13) {
            __int16 v25 = v12;
          }
          else {
            __int16 v25 = 0;
          }
          *(_WORD *)(v23 + 2 * v16) = v25;
        }
        ++v16;
        unsigned int v22 = result + 1;
      }
      while ((int)result + 1 < v6);
      goto LABEL_49;
    }
    LOWORD(v16) = 0;
    if (!*(void *)(a2 + 16)) {
LABEL_50:
    }
      *(_WORD *)(a2 + 48) = v16;
  }
  else
  {
    if (v6 >= 0x15
      && (float)((float)(*(float *)(result + 9160) * (float)*(unsigned int *)(result + 9164))
                             / (float)*(unsigned int *)(result + 32))
       / *(_DWORD *)(result + 9136) < v6)
    {
      unsigned int v15 = 0;
      unsigned int v16 = 0;
      do
      {
        uint64_t result = phone_chunking_search(v5, v15, a2);
        uint64_t v17 = *(void *)(a2 + 16);
        if (v17) {
          *(_DWORD *)(v17 + 4 * v16) = result;
        }
        uint64_t v18 = *(void *)(a2 + 24);
        if (v18) {
          *(_WORD *)(v18 + 2 * v16) = 0;
        }
        ++v16;
        unsigned int v15 = result + 1;
      }
      while ((int)result + 1 < v6);
LABEL_49:
      if (v17) {
        return result;
      }
      goto LABEL_50;
    }
    uint64_t v19 = *(_DWORD **)(a2 + 16);
    if (v19) {
      *uint64_t v19 = v6 - 1;
    }
    else {
      *(_WORD *)(a2 + 48) = 1;
    }
  }
  return result;
}

uint64_t chunking_Do_FrameChunking(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  unsigned int v7 = (float)((float)(*(float *)(a2 + 9160) * (float)*(unsigned int *)(a2 + 9164))
                           / (float)*(unsigned int *)(a2 + 32));
  if (v7 >= a4 || *(unsigned __int16 *)(a5 + 8) <= 2u)
  {
    unint64_t v8 = *(_DWORD **)(a5 + 16);
    uint64_t result = 0;
    if (v8) {
      *unint64_t v8 = a4 - 1;
    }
    else {
      *(_WORD *)(a5 + 24) = 1;
    }
    return result;
  }
  uint64_t v13 = heap_Calloc(*(void **)(a1 + 8), a4, 1);
  if (!v13)
  {
    siren_log_Error(a1, (uint64_t)"memory allocation error");
    return 10;
  }
  uint64_t v14 = v13;
  int v15 = *(unsigned __int16 *)(a5 + 8);
  if (*(_WORD *)(a5 + 8))
  {
    unint64_t v16 = 0;
    int v17 = 0;
    int v18 = 0;
    do
    {
      v18 += *(_DWORD *)(a3 + 4 * v16);
      unsigned int v19 = *(unsigned __int8 *)(*(void *)a5 + v16);
      unsigned int v20 = v18 - 1;
      if (v16)
      {
        if (v16 != v15 - 1 && v19 >= 5)
        {
          *(unsigned char *)(v13 + v20) = 2;
          unsigned int v19 = *(unsigned __int8 *)(*(void *)a5 + v16);
          if (v19 == 6) {
            v20 += *(_DWORD *)(a3 + 4 * v16 + 4) >> 1;
          }
          else {
            unsigned int v20 = v18 + ~(*(_DWORD *)(a3 + 4 * v16) >> 1);
          }
        }
      }
      *(unsigned char *)(v13 + v20) = v19;
      int v15 = *(unsigned __int16 *)(a5 + 8);
      if (v16 == v15 - 1) {
        int v17 = *(_DWORD *)(a3 + 4 * v16);
      }
      ++v16;
    }
    while (v16 < *(unsigned __int16 *)(a5 + 8));
  }
  else
  {
    int v17 = 0;
  }
  unsigned int v22 = a4 - 1;
  if (a4 == 1)
  {
    LOWORD(v24) = 0;
    if (!*(void *)(a5 + 16)) {
      goto LABEL_59;
    }
    goto LABEL_57;
  }
  unsigned int v23 = 0;
  unsigned int v24 = 0;
  unsigned int v25 = ~v17 + a4;
  uint64_t v26 = *(void *)(a5 + 16);
  float v27 = *(float *)(a2 + 9160);
  do
  {
    unsigned int v28 = v7;
    if (v7 >= v22) {
      goto LABEL_46;
    }
    if (v7 >= a4) {
      unsigned int v29 = a4 - 1;
    }
    else {
      unsigned int v29 = v7;
    }
    unsigned int v30 = ((double)(v7 - v23) * 0.5);
    unsigned int v31 = v7 - v30;
    if (v7 >= v30 && v31 <= v29)
    {
      unsigned __int8 v33 = 0;
      unsigned int v28 = 0;
      unsigned int v34 = v7;
      do
      {
        unsigned int v35 = *(unsigned __int8 *)(v14 + v34);
        BOOL v36 = v33 >= v35;
        if (v33 <= v35) {
          unsigned __int8 v33 = *(unsigned char *)(v14 + v34);
        }
        if (!v36) {
          unsigned int v28 = v34;
        }
        --v34;
      }
      while (v34 >= v31);
      unsigned int v37 = v7;
      do
      {
        unsigned int v38 = *(unsigned __int8 *)(v14 + v37);
        BOOL v39 = v33 >= v38;
        if (v33 <= v38) {
          unsigned __int8 v33 = *(unsigned char *)(v14 + v37);
        }
        if (!v39) {
          unsigned int v28 = v37;
        }
        ++v37;
      }
      while (v37 <= v29);
LABEL_46:
      if (v28 > v23) {
        goto LABEL_48;
      }
    }
    unsigned int v28 = v7;
LABEL_48:
    if (v28 >= v25) {
      unsigned int v28 = a4 - 1;
    }
    if (v26) {
      *(_DWORD *)(v26 + 4 * v24) = v28;
    }
    ++v24;
    unsigned int v40 = v28 - v23 + 1;
    unsigned int v23 = v28 + 1;
    unsigned int v41 = (float)((float)(v28 + 1) + (float)((float)v40 * v27));
    if (v41 >= a4) {
      unsigned int v7 = a4 - 1;
    }
    else {
      unsigned int v7 = v41;
    }
  }
  while (v23 < v22);
  if (v26) {
    goto LABEL_57;
  }
LABEL_59:
  *(_WORD *)(a5 + 24) = v24;
LABEL_57:
  heap_Free(*(void **)(a1 + 8), v14);
  return 0;
}

uint64_t chunking_Do_SampleChunking_Process(uint64_t a1, int **a2)
{
  unsigned int v3 = *((_DWORD *)a2 + 11);
  if (v3)
  {
    uint64_t v4 = a1;
    int v5 = 0;
    while (1)
    {
      unsigned int v6 = *((_DWORD *)a2 + 5);
      int v7 = *((_DWORD *)a2 + 4);
      BOOL v8 = v5 == 0;
      int v9 = *a2;
      if (v7
         + ((float)((float)((float)(*((float *)a2 + 12) * *((float *)a2 + 2)) / 1000.0)
                                * (float)*((unsigned int *)a2 + 7))
          / *((_DWORD *)a2 + 6)
          - 2 * v7)
         * v6 > v3)
      {
        if (v6 >= 2)
        {
          int v10 = 0;
          unsigned __int16 v11 = 0;
          unsigned int v12 = v3 / v6;
          unsigned int v3 = 0;
          while (1)
          {
            uint64_t v13 = *((unsigned int *)a2 + 4);
            unsigned int v14 = *((_DWORD *)a2 + 11);
            uint64_t v15 = *((void *)v9 + 1);
            if (v12 >= v13)
            {
              int v16 = *((_DWORD *)a2 + 11);
            }
            else
            {
              *((_DWORD *)a2 + 11) = 0;
              v3 += v14;
              if (v15)
              {
                BOOL v39 = *a2;
                uint64_t v44 = *((void *)*a2 + 4);
                if (v44)
                {
                  unsigned int v45 = *((_DWORD *)a2 + 5) * *((_DWORD *)a2 + 10);
                  uint64_t v4 = a1;
                  if (v11)
                  {
                    v45 += v10;
                    int v46 = *(_DWORD *)(v44 + 4 * (v45 - 1));
                    int v47 = v46 - v13 + 1;
                  }
                  else
                  {
                    int v47 = 0;
                    int v46 = v13 - 1;
                  }
                  int v49 = v46 + v14;
                  uint64_t v48 = *((void *)v39 + 3);
                  *(_DWORD *)(v48 + 4 * v45) = v47;
                  *(_DWORD *)(v44 + 4 * v45) = v49;
                }
                else
                {
                  uint64_t v48 = *((void *)v39 + 3);
                  uint64_t v4 = a1;
                }
                int v50 = 1;
                int v51 = 1;
                do
                {
                  unsigned int v52 = v50 + *((_DWORD *)a2 + 5) * *((_DWORD *)a2 + 10);
                  *(_DWORD *)(v44 + 4 * v52) = -1;
                  *(_DWORD *)(v48 + 4 * v52) = 0;
                  int v50 = (unsigned __int16)++v51;
                }
                while (v6 > (unsigned __int16)v51);
                uint64_t v40 = *((void *)v39 + 1);
                if (v40)
                {
                  uint64_t result = 0;
LABEL_76:
                  int v41 = *((_DWORD *)a2 + 9);
                  int v42 = v41 - *((_DWORD *)a2 + 4);
LABEL_77:
                  *(_DWORD *)(v40 + 4 * *((unsigned int *)a2 + 10)) = v42;
                  *(_DWORD *)(*((void *)v39 + 2) + 4 * *((unsigned int *)a2 + 10)) = v3 + v41 - 1;
                  *(int **)((char *)a2 + 36) = (int *)vadd_s32(*(int32x2_t *)((char *)a2 + 36), (int32x2_t)(v3 | 0x100000000));
                }
                else
                {
                  uint64_t result = 0;
                }
                goto LABEL_78;
              }
              int v16 = 0;
              unsigned int v12 = v14;
            }
            *((_DWORD *)a2 + 11) = v16 - v12;
            if (v5 || v11)
            {
              if (v15) {
                create_Thread_Chunk_Index(v13, v13, v12, v10, a2);
              }
            }
            else if (v15)
            {
              uint64_t v17 = *((void *)*a2 + 4);
              if (v17)
              {
                unsigned int v18 = *((_DWORD *)a2 + 5) * *((_DWORD *)a2 + 10);
                *(_DWORD *)(*((void *)*a2 + 3) + 4 * v18) = 0;
                *(_DWORD *)(v17 + 4 * v18) = v13 + v12 - 1;
              }
            }
            v3 += v12;
            int v10 = ++v11;
            if (v6 - 1 <= v11)
            {
              int v19 = *((_DWORD *)a2 + 11);
              *((_DWORD *)a2 + 11) = 0;
              v3 += v19;
              uint64_t v4 = a1;
              goto LABEL_46;
            }
          }
        }
        int v10 = 0;
        *((_DWORD *)a2 + 11) = 0;
        if (v5 || v6 != 1)
        {
          int v19 = v3;
LABEL_46:
          if (*((void *)v9 + 1))
          {
            int v38 = **a2;
            create_Thread_Chunk_Index(*((unsigned int *)a2 + 4), *((_DWORD *)a2 + 4), v19, v10, a2);
            *(_DWORD *)(*((void *)*a2 + 4) + 4 * (v38 * v6 - 1)) -= *((_DWORD *)a2 + 4);
          }
        }
        else
        {
          if (*((void *)v9 + 1))
          {
            uint64_t v30 = *((void *)v9 + 4);
            if (v30)
            {
              uint64_t v31 = *((unsigned int *)a2 + 10);
              *(_DWORD *)(*((void *)v9 + 3) + 4 * v31) = 0;
              *(_DWORD *)(v30 + 4 * v31) = v3 + v7 - 1;
            }
          }
          BOOL v8 = 1;
        }
        if (*((_DWORD *)a2 + 11) || !v3)
        {
          siren_log_Error(v4, (uint64_t)"bet6 nnvocoder sample level chunking last sample chunk calculation error.");
          uint64_t result = 15;
        }
        else
        {
          uint64_t result = 0;
        }
        if (*((void *)v9 + 1))
        {
          if (*((_DWORD *)a2 + 10) >= *v9)
          {
            siren_log_Error(v4, (uint64_t)"bet6 nnvocoder sample level chunking last sample chunk calculation error.");
            uint64_t result = 15;
          }
          BOOL v39 = *a2;
          uint64_t v40 = *((void *)*a2 + 1);
          if (v8)
          {
            if (v40)
            {
              int v41 = *((_DWORD *)a2 + 9);
              int v42 = v41;
              goto LABEL_77;
            }
          }
          else if (v40)
          {
            goto LABEL_76;
          }
        }
LABEL_78:
        unsigned int v3 = *((_DWORD *)a2 + 11);
        goto LABEL_79;
      }
      if (v6)
      {
        int v20 = 0;
        unsigned __int16 v21 = 0;
        unsigned int v22 = 0;
        do
        {
          if (v5 || v21)
          {
            float v28 = (float)((float)(*((float *)a2 + 12) * *((float *)a2 + 2)) / 1000.0) * (float)*((unsigned int *)a2 + 7);
            int v29 = *((_DWORD *)a2 + 4);
            unsigned int v24 = v28 / *((_DWORD *)a2 + 6) - 2 * v29;
            if (*((void *)v9 + 1)) {
              create_Thread_Chunk_Index(v9[1], v9[1], v28 / *((_DWORD *)a2 + 6) - 2 * v29, v20, a2);
            }
          }
          else
          {
            float v23 = (float)((float)(*((float *)a2 + 12) * *((float *)a2 + 2)) / 1000.0) * (float)*((unsigned int *)a2 + 7);
            *((_DWORD *)a2 + 16) = 0;
            unsigned int v24 = v23 / *((_DWORD *)a2 + 6) - *((_DWORD *)a2 + 4);
            if (*((void *)v9 + 1))
            {
              uint64_t v25 = *((void *)*a2 + 4);
              if (v25)
              {
                unsigned int v26 = *((_DWORD *)a2 + 5) * *((_DWORD *)a2 + 10);
                int v27 = v24 + v9[1] - 1;
                *(_DWORD *)(*((void *)*a2 + 3) + 4 * v26) = 0;
                *(_DWORD *)(v25 + 4 * v26) = v27;
              }
            }
          }
          *((_DWORD *)a2 + 11) -= v24;
          v22 += v24;
          int v20 = ++v21;
        }
        while (v6 > v21);
      }
      else
      {
        unsigned int v24 = 0;
        unsigned int v22 = 0;
      }
      if (*((void *)v9 + 1))
      {
        if (*((_DWORD *)a2 + 10) >= *v9)
        {
          siren_log_Error(v4, (uint64_t)"bet6 nnvocoder sample level chunking sample chunk calculation error.");
          uint64_t result = 15;
        }
        else
        {
          uint64_t result = 0;
        }
        unsigned __int8 v33 = *a2;
        uint64_t v34 = *((void *)*a2 + 1);
        if (v5)
        {
          if (v34)
          {
            int v35 = v9[1];
            int v36 = *((_DWORD *)a2 + 9);
            int v37 = v36 - v35;
LABEL_62:
            *(_DWORD *)(v34 + 4 * *((unsigned int *)a2 + 10)) = v37;
            *(_DWORD *)(*((void *)v33 + 2) + 4 * *((unsigned int *)a2 + 10)) = v22 + v35 + v36 - 1;
            *(int **)((char *)a2 + 36) = (int *)vadd_s32(*(int32x2_t *)((char *)a2 + 36), (int32x2_t)(v22 | 0x100000000));
          }
        }
        else if (v34)
        {
          int v35 = v9[1];
          int v36 = *((_DWORD *)a2 + 9);
          int v37 = v36;
          goto LABEL_62;
        }
      }
      else
      {
        uint64_t result = 0;
      }
      float v43 = (float)((float)v22 * (float)*((unsigned int *)a2 + 6)) * 1000.0 / (float)*((unsigned int *)a2 + 7);
      *((float *)a2 + 12) = v43;
      unsigned int v3 = *((_DWORD *)a2 + 11);
      if (!v3 || !v24)
      {
        siren_log_Error(v4, (uint64_t)"bet6 nnvocoder sample level chunkign first or in-between sample chunk calculation error.");
        uint64_t result = 15;
        goto LABEL_78;
      }
LABEL_79:
      ++v5;
      if (!v3) {
        goto LABEL_83;
      }
    }
  }
  uint64_t result = 0;
  int v5 = 0;
LABEL_83:
  if (!**a2) {
    **a2 = v5;
  }
  return result;
}

uint64_t chunking_Do_SampleChunking_ProcessReset(uint64_t result, uint64_t a2)
{
  if (!a2) {
    return siren_log_Error(result, (uint64_t)"bet6 nnvocoder sample level chunking ChunkingSampleProcess struct not initalized.");
  }
  *(_DWORD *)(a2 + 36) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  *(float *)(a2 + 48) = (float)*(unsigned int *)(a2 + 12);
  *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 32);
  return result;
}

uint64_t *chunking_Close(uint64_t *result, uint64_t a2)
{
  uint64_t v3 = *result;
  int v5 = (uint64_t *)result[8];
  uint64_t v4 = (uint64_t *)result[9];
  unsigned int v6 = (void *)result[10];
  uint64_t v7 = result[11];
  if (v5)
  {
    uint64_t v8 = v5[2];
    if (v8)
    {
      heap_Free(*(void **)(v3 + 8), v8);
      v5[2] = 0;
    }
    uint64_t v9 = v5[3];
    if (v9)
    {
      heap_Free(*(void **)(v3 + 8), v9);
      v5[3] = 0;
    }
    uint64_t v10 = v5[5];
    if (v10)
    {
      heap_Free(*(void **)(v3 + 8), v10);
      v5[5] = 0;
    }
    uint64_t v11 = v5[4];
    if (v11)
    {
      heap_Free(*(void **)(v3 + 8), v11);
      v5[4] = 0;
    }
    if (*v5)
    {
      heap_Free(*(void **)(v3 + 8), *v5);
      *int v5 = 0;
    }
    uint64_t result = heap_Free(*(void **)(v3 + 8), (uint64_t)v5);
  }
  if (v7)
  {
    uint64_t v12 = *(void *)(v7 + 8);
    if (v12)
    {
      heap_Free(*(void **)(v3 + 8), v12);
      *(void *)(v7 + 8) = 0;
    }
    uint64_t v13 = *(void *)(v7 + 16);
    if (v13)
    {
      heap_Free(*(void **)(v3 + 8), v13);
      *(void *)(v7 + 16) = 0;
    }
    uint64_t result = heap_Free(*(void **)(v3 + 8), v7);
  }
  if (v4)
  {
    uint64_t v14 = v4[2];
    if (v14)
    {
      heap_Free(*(void **)(v3 + 8), v14);
      v4[2] = 0;
    }
    if (*v4)
    {
      heap_Free(*(void **)(v3 + 8), *v4);
      *uint64_t v4 = 0;
    }
    uint64_t result = heap_Free(*(void **)(v3 + 8), (uint64_t)v4);
  }
  if (*(_DWORD *)(a2 + 9184) && v6)
  {
    uint64_t v15 = v6[1];
    if (v15)
    {
      heap_Free(*(void **)(v3 + 8), v15);
      v6[1] = 0;
    }
    uint64_t v16 = v6[2];
    if (v16)
    {
      heap_Free(*(void **)(v3 + 8), v16);
      v6[2] = 0;
    }
    uint64_t v17 = v6[3];
    if (v17)
    {
      heap_Free(*(void **)(v3 + 8), v17);
      v6[3] = 0;
    }
    uint64_t v18 = v6[4];
    if (v18)
    {
      heap_Free(*(void **)(v3 + 8), v18);
      v6[4] = 0;
    }
    int v19 = *(void **)(v3 + 8);
    return heap_Free(v19, (uint64_t)v6);
  }
  return result;
}

uint64_t phone_chunking_search(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a3 + 8) - 1;
  unsigned int v4 = *(_DWORD *)(a1 + 9144) + a2;
  if (v4 >= v3) {
    uint64_t result = v3;
  }
  else {
    uint64_t result = v4;
  }
  if (result > a2)
  {
    uint64_t v6 = 0;
    do
    {
      unsigned int v7 = *(unsigned __int8 *)(*(void *)a3 + a2 + v6);
      if (v7 >= 6)
      {
        BOOL v10 = a2 + v6 > a2 && v7 > 7;
        return a2 - v10 + v6;
      }
      ++v6;
    }
    while (a2 - result + v6);
    uint64_t v8 = result;
    while (*(unsigned __int8 *)(*(void *)a3 + v8) <= 3u)
    {
      uint64_t v8 = (v8 - 1);
      if (v8 <= a2)
      {
        uint64_t v8 = result;
        while (*(unsigned __int8 *)(*(void *)a3 + v8) <= 2u)
        {
          uint64_t v8 = (v8 - 1);
          if (v8 <= a2)
          {
            uint64_t v8 = result;
            while (*(unsigned char *)(*(void *)a3 + v8) != 2)
            {
              uint64_t v8 = (v8 - 1);
              if (v8 <= a2) {
                return result;
              }
            }
            return v8;
          }
        }
        return v8;
      }
    }
    return v8;
  }
  return result;
}

uint64_t create_Thread_Chunk_Index(uint64_t result, int a2, int a3, int a4, _DWORD *a5)
{
  uint64_t v5 = *(void *)(*(void *)a5 + 32);
  if (v5)
  {
    unsigned int v6 = a5[5] * a5[10];
    if (a4)
    {
      v6 += a4;
      int v7 = *(_DWORD *)(v5 + 4 * (v6 - 1));
      int v8 = v7 - (result + a2) + 1;
    }
    else
    {
      int v8 = 0;
      int v7 = a2 + result - 1;
    }
    *(_DWORD *)(*(void *)(*(void *)a5 + 24) + 4 * v6) = v8;
    *(_DWORD *)(v5 + 4 * v6) = v7 + a3;
  }
  return result;
}

uint64_t infer_dur_init(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v17 = 0;
  uint64_t v5 = heap_Calloc(*(void **)(v4 + 8), 1, 88);
  if (!v5)
  {
    BOOL v10 = "memory allocation error";
LABEL_5:
    siren_log_Error(v4, (uint64_t)v10);
    return 10;
  }
  uint64_t v6 = v5;
  a1[6] = v5;
  *(_DWORD *)(v5 + 16) = 100;
  *(void *)(v5 + 72) = v4;
  int v7 = (uint64_t **)(v5 + 80);
  uint64_t v8 = fi_rsc_create((void *)v4, (void *)(v5 + 80));
  if (!v8)
  {
    uint64_t v11 = parse_fi_binary_model(*v7, a2, &v17);
    if (v11)
    {
      uint64_t v9 = v11;
      siren_log_Error(v4, (uint64_t)"Duration Model FI binary model parsing failed: %d");
      return v9;
    }
    uint64_t v13 = v17;
    *(void *)uint64_t v6 = v17;
    LODWORD(v13) = *(_DWORD *)(v13 + 60);
    *(_DWORD *)(v6 + 20) = v13;
    uint64_t v14 = heap_Calloc(*(void **)(*(void *)(v6 + 72) + 8), (100 * v13), 4);
    *(void *)(v6 + 32) = v14;
    if (v14)
    {
      uint64_t v15 = heap_Calloc(*(void **)(*(void *)(v6 + 72) + 8), 100, 4);
      *(void *)(v6 + 8) = v15;
      if (v15)
      {
        uint64_t v16 = heap_Calloc(*(void **)(*(void *)(v6 + 72) + 8), 100, 4);
        *(void *)(v6 + 56) = v16;
        if (v16)
        {
          siren_log_Diag(v4, (uint64_t)"infer(duration) init done....\n");
          return 0;
        }
      }
    }
    BOOL v10 = "memory allocation error.";
    goto LABEL_5;
  }
  uint64_t v9 = v8;
  siren_log_Error(v4, (uint64_t)"Duration Model FI Resource creation failed: %d");
  return v9;
}

uint64_t infer_dur_process(uint64_t a1, uint64_t *a2)
{
  v32[4] = *(const void **)MEMORY[0x263EF8340];
  uint64_t v4 = a2[6];
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  uint64_t v7 = *(unsigned __int16 *)(v6 + 10);
  *(void *)(v4 + 48) = *(void *)(a2[4] + 8);
  unsigned int v8 = *(_DWORD *)(v4 + 16);
  if (v8 < v7)
  {
    *(_DWORD *)(v4 + 16) = v7;
    uint64_t v9 = heap_Realloc(*(uint64_t **)(v5 + 8), *(void *)(v4 + 32), 4 * (*(_DWORD *)(v4 + 20) * v7));
    *(void *)(v4 + 32) = v9;
    if (!v9) {
      goto LABEL_16;
    }
    uint64_t v10 = heap_Realloc(*(uint64_t **)(v5 + 8), *(void *)(v4 + 8), 4 * v7);
    *(void *)(v4 + 8) = v10;
    if (!v10) {
      goto LABEL_16;
    }
    *(void *)(v4 + 56) = heap_Realloc(*(uint64_t **)(v5 + 8), *(void *)(v4 + 56), 4 * v7);
    if (!*(void *)(v4 + 8)) {
      goto LABEL_16;
    }
    unsigned int v8 = *(_DWORD *)(v4 + 16);
  }
  cstdlib_memset(*(void **)(v4 + 32), 0, 4 * *(_DWORD *)(v4 + 20) * v8);
  cstdlib_memset(*(void **)(v4 + 8), 0, 4 * *(unsigned int *)(v4 + 16));
  cstdlib_memset(*(void **)(v4 + 56), 0, 4 * *(unsigned int *)(v4 + 16));
  if (v7)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    do
    {
      if (*(unsigned char *)(*(void *)(v6 + 32) + v11) == 1)
      {
        *(_DWORD *)(*(void *)(v4 + 56) + 4 * v11) = *(unsigned __int16 *)(a1 + 8076);
      }
      else
      {
        cstdlib_memcpy((void *)(*(void *)(v4 + 32) + 4 * (*(_DWORD *)(v4 + 20) * v12)), (const void *)(*(void *)(v4 + 48) + 4 * (*(_DWORD *)(v4 + 20) * v11)), 4 * *(unsigned int *)(v4 + 20));
        *(_DWORD *)(*(void *)(v4 + 8) + 4 * v12) = v11;
        uint64_t v12 = (v12 + 1);
      }
      ++v11;
    }
    while (v7 != v11);
    if (v12)
    {
      uint64_t v13 = *(_DWORD *)(v4 + 20) * *(unsigned __int16 *)(v6 + 10);
      uint64_t v14 = (void *)heap_Calloc(*(void **)(*(void *)(v4 + 72) + 8), v13, 4);
      v32[0] = v14;
      if (v14)
      {
        cstdlib_memcpy(v14, *(const void **)(v4 + 32), 4 * v13);
        uint64_t v19 = fi_net_predict(*(uint64_t ***)v4, v32, v12, (void *)(v4 + 40), v15, v16, v17, v18);
        if (v19)
        {
          uint64_t v20 = v19;
          siren_log_Error(v5, (uint64_t)"Duration Model FI inferece failed: %d");
          return v20;
        }
        unsigned int v22 = *(int **)(v4 + 56);
        uint64_t v28 = *(void *)(v4 + 40);
        uint64_t v29 = *(void *)(v4 + 8);
        uint64_t v30 = v12 - 1;
        do
          v22[*(unsigned int *)(v29 + 4 * v30)] = vcvtps_u32_f32(fmaxf(*(float *)(v28 + 4 * v30), 1.0));
        while ((unint64_t)v30--);
        uint64_t v23 = a2[1];
        *(_DWORD *)(v4 + 24) = 0;
        unsigned __int16 v21 = (_DWORD *)(v4 + 24);
        goto LABEL_19;
      }
LABEL_16:
      siren_log_Error(v5, (uint64_t)"memory allocation error.");
      return 10;
    }
  }
  siren_log_Diag(v5, (uint64_t)"No non-silence phones found in duration inference.");
  *(_DWORD *)(v4 + 24) = 0;
  unsigned __int16 v21 = (_DWORD *)(v4 + 24);
  unsigned int v22 = *(int **)(v4 + 56);
  if (v22)
  {
    uint64_t v23 = a2[1];
LABEL_19:
    LODWORD(v24) = *(__int16 *)(v23 + 10);
    if ((int)v24 >= 1)
    {
      int v25 = 0;
      uint64_t v24 = (unsigned __int16)v24;
      do
      {
        int v26 = *v22++;
        v25 += v26;
        *unsigned __int16 v21 = v25;
        --v24;
      }
      while (v24);
    }
    goto LABEL_24;
  }
  siren_log_Error(v5, (uint64_t)"input duration sequence error....");
LABEL_24:
  siren_log_Diag(v5, (uint64_t)"infer(duration) process one sentence done....\n");
  if (log_GetLogLevel(*(void *)(v5 + 32)) >= 3)
  {
    siren_compute_stream_hash(*(char **)(v4 + 56), 4 * *(unsigned __int16 *)(v6 + 10), (char *)v32);
    siren_log_Diag(v5, (uint64_t)"INFER_DUR_MD5=%s\n");
  }
  return 0;
}

uint64_t infer_dur_end(uint64_t *a1)
{
  uint64_t v2 = (uint64_t *)a1[6];
  uint64_t v3 = *a1;
  uint64_t v4 = v2[1];
  if (v4)
  {
    heap_Free(*(void **)(v3 + 8), v4);
    v2[1] = 0;
  }
  uint64_t v5 = v2[4];
  if (v5)
  {
    heap_Free(*(void **)(v3 + 8), v5);
    v2[4] = 0;
  }
  uint64_t v6 = v2[7];
  if (v6)
  {
    heap_Free(*(void **)(v3 + 8), v6);
    v2[7] = 0;
  }
  if (*v2)
  {
    fi_net_destroy(*v2);
    *uint64_t v2 = 0;
  }
  v2[5] = 0;
  v2[6] = 0;
  uint64_t v7 = (void *)v2[10];
  if (v7)
  {
    fi_rsc_destroy(v7);
    v2[10] = 0;
  }
  heap_Free(*(void **)(v3 + 8), (uint64_t)v2);
  a1[6] = 0;
  siren_log_Diag(v3, (uint64_t)"infer(duration) close done....\n");
  return 0;
}

uint64_t siren_common_synth_Init(uint64_t a1, _DWORD *a2, uint64_t *a3)
{
  uint64_t result = 7;
  if (a1 && a2)
  {
    uint64_t v7 = heap_Calloc(*(void **)(a1 + 8), 1, 144);
    if (v7)
    {
      uint64_t v8 = v7;
      *(void *)uint64_t v7 = 0;
      *(void *)(v7 + 8) = 0;
      *(_WORD *)(v7 + 72) = 100;
      int v9 = a2[4];
      *(_WORD *)(v7 + 44) = 80;
      uint64_t v10 = 274877907 * a2[8] * v9;
      LODWORD(v10) = (v10 >> 38) + ((unint64_t)v10 >> 63);
      *(void *)(v7 + 16) = a1;
      *(void *)(v7 + 24) = a2;
      *(_DWORD *)(v7 + 36) = v10;
      *(_DWORD *)(v7 + 40) = v9;
      uint64_t v11 = heap_Calloc(*(void **)(a1 + 8), (4 * v10), 2);
      *(void *)(v8 + 96) = v11;
      if (v11
        && (uint64_t v12 = heap_Calloc(*(void **)(a1 + 8), *(unsigned int *)(*(void *)(v8 + 24) + 9204), 4),
            (*(void *)(v8 + 112) = v12) != 0))
      {
        *(_DWORD *)(v8 + 104) = 0;
        if (a2[2278])
        {
          *(_DWORD *)(v8 + 36) = a2[2297];
          if (*(_DWORD *)(*(void *)(v8 + 24) + 9168) < 2u) {
            int v13 = new_siren_nn_synth_Init((void *)v8);
          }
          else {
            int v13 = new_siren_nn_mt_synth_Init((void *)v8);
          }
        }
        else
        {
          uint64_t v15 = 274877907 * *(_DWORD *)(*(void *)(v8 + 24) + 32) * *(_DWORD *)(*(void *)(v8 + 24) + 16);
          *(_DWORD *)(v8 + 36) = (v15 >> 38) + ((unint64_t)v15 >> 63);
          int v13 = new_siren_mrcc_synth_Init(v8);
        }
        int v14 = v13;
        if (!v13)
        {
          uint64_t result = 0;
          goto LABEL_16;
        }
      }
      else
      {
        int v14 = 10;
      }
      siren_common_synth_DeInit((uint64_t *)v8);
    }
    else
    {
      int v14 = 10;
    }
    uint64_t v8 = 0;
    uint64_t result = v14 | 0x84E02000;
LABEL_16:
    *a3 = v8;
  }
  return result;
}

uint64_t siren_common_synth_DeInit(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = a1[2];
    uint64_t v3 = a1[12];
    if (v3) {
      heap_Free(*(void **)(v2 + 8), v3);
    }
    uint64_t v4 = a1[14];
    if (v4) {
      heap_Free(*(void **)(v2 + 8), v4);
    }
    uint64_t v5 = a1[3];
    if (*(_DWORD *)(v5 + 9112))
    {
      if (*(_DWORD *)(v5 + 9168) < 2u) {
        uint64_t v6 = new_siren_nn_synth_DeInit((uint64_t)a1);
      }
      else {
        uint64_t v6 = new_siren_nn_mt_synth_DeInit((uint64_t)a1);
      }
      uint64_t v7 = v6;
      uint64_t v8 = *a1;
      if (!*a1) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v7 = new_siren_mrcc_synth_DeInit((uint64_t)a1);
      uint64_t v8 = a1[1];
      if (!v8) {
        goto LABEL_15;
      }
    }
    heap_Free(*(void **)(v2 + 8), v8);
LABEL_15:
    cstdlib_memset(a1, 0, 0x90uLL);
    heap_Free(*(void **)(v2 + 8), (uint64_t)a1);
    return v7;
  }
  return 0;
}

uint64_t siren_common_synth_Reset(uint64_t a1)
{
  if (a1)
  {
    *(_WORD *)(a1 + 72) = 100;
    uint64_t v1 = *(_DWORD **)(a1 + 24);
    *(_DWORD *)(a1 + 40) = v1[4];
    *(_WORD *)(a1 + 44) = 80;
    *(_DWORD *)(a1 + 104) = 0;
    *(void *)(a1 + 48) = 0;
    *(_DWORD *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 88) = 0;
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = 0;
    *(void *)(a1 + 120) = 0;
    if (v1[2278])
    {
      if (v1[2292] < 2u) {
        return new_siren_nn_synth_Reset(a1);
      }
      else {
        return new_siren_nn_mt_synth_Reset(a1);
      }
    }
    else
    {
      return new_siren_mrcc_synth_Reset(a1);
    }
  }
  return a1;
}

uint64_t siren_common_synth_ProcessStart(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int a5, uint64_t a6, double a7, float a8)
{
  unsigned int v10 = *(_DWORD *)(a1 + 48);
  uint64_t v11 = *(_DWORD **)(a1 + 24);
  int v12 = v11[2293];
  unsigned int v13 = v11[2292];
  if (a3)
  {
    *(_DWORD *)(a1 + 88) = 0;
    *(_DWORD *)(a1 + 52) = 0;
    *(_DWORD *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = a2;
    *(_DWORD *)(a1 + 48) = a3;
    *(_DWORD *)(a1 + 32) = a5;
  }
  else
  {
    a3 = *(_DWORD *)(a1 + 48);
  }
  *(void *)(a1 + 80) = a4;
  if (v11[2278])
  {
    if (v13 < 2)
    {
      return new_siren_nn_synth_ProcessStart();
    }
    else if (a3 <= v10 {
           || (LOWORD(a8) = *(_WORD *)(a1 + 72),
    }
               uint64_t v14 = heap_Realloc(*(uint64_t **)(*(void *)(a1 + 16) + 8), *(void *)(a1 + 96), 2* (a3 + 2 * v12 * v13)* (float)((float)((float)LODWORD(a8) / 100.0) * (float)*(unsigned int *)(a1 + 36))), (*(void *)(a1 + 96) = v14) != 0))
    {
      return new_siren_nn_mt_synth_ProcessStart(a1, a6);
    }
    else
    {
      return 10;
    }
  }
  else
  {
    return new_siren_mrcc_synth_ProcessStart(a1);
  }
}

uint64_t siren_common_synth_Process(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = *(_DWORD **)(a1 + 24);
  if (!v3[2278]) {
    return new_siren_mrcc_synth_Process(a1, a2, a3);
  }
  if (v3[2280]) {
    return siren_nn_seq2seq_synth_Process(a1, *(void *)(a1 + 16), a2, a3);
  }
  if (v3[2282]) {
    return siren_nn_parallel_synth_Process(a1, *(void *)(a1 + 16), a2, a3);
  }
  if (v3[2292] < 2u) {
    return new_siren_nn_synth_Process(a1, a2, a3);
  }
  return new_siren_nn_mt_synth_Process(a1);
}

uint64_t siren_common_synth_ProcessEnd(uint64_t a1)
{
  if (*(_DWORD *)(*(void *)(a1 + 24) + 9112)) {
    return 0;
  }
  else {
    return new_siren_mrcc_synth_ProcessEnd(a1);
  }
}

uint64_t siren_common_synth_GetVolumeLevel(uint64_t result)
{
  if (result) {
    return *(unsigned __int16 *)(result + 44);
  }
  return result;
}

uint64_t siren_common_synth_GetRatePct(uint64_t result)
{
  if (result) {
    return *(unsigned __int16 *)(result + 72);
  }
  return result;
}

uint64_t siren_common_synth_GetFrameSamples(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 36);
  }
  return result;
}

uint64_t siren_common_synth_GetCurSampleCount(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 56);
  }
  return result;
}

uint64_t siren_common_synth_GetCurFrameCount(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 52);
  }
  return result;
}

uint64_t siren_common_synth_GetBufSamplesCount(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 32);
  }
  return result;
}

uint64_t siren_common_synth_GetLeftSamplesCount(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 104);
  }
  return result;
}

uint64_t siren_common_synth_GetFramesCount(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 48);
  }
  return result;
}

uint64_t siren_common_synth_GetIsBufferFull(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 88);
  }
  return result;
}

uint64_t siren_common_synth_GetLeftFrames(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 120);
  }
  return result;
}

uint64_t siren_common_synth_GetLeftSamples(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 124);
  }
  return result;
}

uint64_t siren_common_synth_GetUsedLeftFrames(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 128);
  }
  return result;
}

uint64_t siren_common_synth_GetUsedLeftSamples(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 132);
  }
  return result;
}

uint64_t siren_common_synth_GetFeedFrames(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 136);
  }
  return result;
}

uint64_t siren_common_synth_GetFeedSamples(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 140);
  }
  return result;
}

uint64_t siren_common_synth_SetCurSampleCount(uint64_t a1, int a2)
{
  if (!a1) {
    return 2229280786;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 56) = a2;
  return result;
}

uint64_t siren_common_synth_SetCurFrameCount(uint64_t a1, int a2)
{
  if (!a1) {
    return 2229280786;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 52) = a2;
  return result;
}

uint64_t siren_common_synth_SetBufSamplesCount(uint64_t a1, int a2)
{
  if (!a1) {
    return 2229280786;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 32) = a2;
  return result;
}

uint64_t siren_common_synth_SetLeftSamplesCount(uint64_t a1, int a2)
{
  if (!a1) {
    return 2229280786;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 104) = a2;
  return result;
}

uint64_t siren_common_synth_SetFramesCount(uint64_t a1, int a2)
{
  if (!a1) {
    return 2229280786;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 48) = a2;
  return result;
}

uint64_t siren_common_synth_SetIsBufferFull(uint64_t a1, unsigned int a2)
{
  uint64_t result = 2229280786;
  if (a1)
  {
    if (a2 <= 1)
    {
      uint64_t result = 0;
      *(_DWORD *)(a1 + 88) = a2;
    }
  }
  return result;
}

uint64_t siren_common_synth_SetLeftFrames(uint64_t a1, int a2)
{
  if (!a1) {
    return 2229280786;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 120) = a2;
  return result;
}

uint64_t siren_common_synth_SetLeftSamples(uint64_t a1, int a2)
{
  if (!a1) {
    return 2229280786;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 124) = a2;
  return result;
}

uint64_t siren_common_synth_SetUsedLeftFrames(uint64_t a1, int a2)
{
  if (!a1) {
    return 2229280786;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 128) = a2;
  return result;
}

uint64_t siren_common_synth_SetUsedLeftSamples(uint64_t a1, int a2)
{
  if (!a1) {
    return 2229280786;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 132) = a2;
  return result;
}

uint64_t siren_common_synth_SetFeedFrames(uint64_t a1, int a2)
{
  if (!a1) {
    return 2229280786;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 136) = a2;
  return result;
}

uint64_t siren_common_synth_SetFeedSamples(uint64_t a1, int a2)
{
  if (!a1) {
    return 2229280786;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 140) = a2;
  return result;
}

uint64_t siren_common_synth_GetRsrc(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t siren_common_synth_GetNnInfo(uint64_t result)
{
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t siren_common_synth_GetMrccInfo(uint64_t result)
{
  if (result) {
    return *(void *)(result + 8);
  }
  return result;
}

uint64_t siren_common_synth_SetNnInfo(void *a1, uint64_t a2)
{
  uint64_t result = 2229280786;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0;
      *a1 = a2;
    }
  }
  return result;
}

uint64_t siren_common_synth_SetMrccInfo(uint64_t a1, uint64_t a2)
{
  uint64_t result = 2229280786;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0;
      *(void *)(a1 + 8) = a2;
    }
  }
  return result;
}

uint64_t siren_common_synth_GetPcmBuffer(uint64_t result)
{
  if (result) {
    return *(void *)(result + 80);
  }
  return result;
}

uint64_t siren_common_synth_GetLeftPcmBuffer(uint64_t result)
{
  if (result) {
    return *(void *)(result + 96);
  }
  return result;
}

uint64_t siren_common_synth_GetVoice(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

uint64_t siren_common_synth_GetFrames(uint64_t result)
{
  if (result) {
    return *(void *)(result + 64);
  }
  return result;
}

uint64_t siren_common_synth_GetLeftAcousticBuffer(uint64_t result)
{
  if (result) {
    return *(void *)(result + 112);
  }
  return result;
}

uint64_t siren_common_synth_SetRate(uint64_t a1, int a2)
{
  uint64_t result = 2229280786;
  if (a1)
  {
    if ((a2 - 25) <= 0xAF)
    {
      uint64_t result = 0;
      *(_WORD *)(a1 + 72) = a2;
    }
  }
  return result;
}

uint64_t siren_common_synth_SetVolume(uint64_t a1, unsigned int a2)
{
  uint64_t result = 2229280786;
  if (a1)
  {
    if (a2 <= 0x64)
    {
      uint64_t result = 0;
      *(_WORD *)(a1 + 44) = a2;
    }
  }
  return result;
}

uint64_t siren_common_synth_SetPitch(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(*(void *)(a1 + 24) + 9112)) {
    return 2229280786;
  }
  else {
    return new_siren_mrcc_synth_SetPitch(a1, a2);
  }
}

uint64_t synth_bet6_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2229280769;
  }
  uint64_t result = 0;
  *a2 = &ISynth_Bet6;
  return result;
}

uint64_t synth_bet6_ClassOpen(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v5 = 0;
  if (!a3) {
    return 2229280775;
  }
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v5);
  if ((result & 0x80000000) == 0)
  {
    *(void *)a3 = v5;
    *(_DWORD *)(a3 + 8) = 135972;
  }
  return result;
}

uint64_t synth_bet6_ClassClose()
{
  return 0;
}

uint64_t synth_bet6_ObjOpen(uint64_t a1, int a2, _WORD *a3, int a4, uint64_t a5)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v5 = 2229280775;
  memset(v45, 0, sizeof(v45));
  unsigned int v42 = 0;
  long long v40 = xmmword_26D214DE8;
  int v41 = off_26D214DF8;
  if (a5)
  {
    uint64_t inited = InitRsrcFunction(a3, a4, &v44);
    if ((inited & 0x80000000) != 0)
    {
      return inited;
    }
    else
    {
      if ((safeh_HandleCheck(a1, a2, 135972, 416) & 0x80000000) == 0)
      {
        *(void *)a5 = 0;
        *(_DWORD *)(a5 + 8) = 0;
        log_OutText(*(void *)(v44 + 32), (uint64_t)"SYNTH_BET6", 4, 0, (uint64_t)"Entering synth_bet6_ObjOpen", v10, v11, v12, v38);
        unsigned int v13 = (void *)heap_Calloc(*(void **)(v44 + 8), 1, 1184);
        uint64_t v18 = v44;
        if (!v13)
        {
          log_OutPublic(*(void *)(v44 + 32), (uint64_t)"SYNTH_BET6", 73000, 0, v14, v15, v16, v17, v39);
          return 2229280778;
        }
        uint64_t v19 = (uint64_t)v13;
        void *v13 = a1;
        v13[1] = v18;
        uint64_t Object = critsec_ObjOpen(*(void *)(v44 + 16), *(void **)(v44 + 8), v13 + 2);
        if ((Object & 0x80000000) == 0)
        {
          uint64_t Object = objc_GetObject(*(void *)(v44 + 48), (uint64_t)"SYNTHSTREAM", &v43);
          if ((Object & 0x80000000) == 0)
          {
            uint64_t v25 = v44;
            *(void *)(v19 + 56) = *(void *)(v43 + 8);
            betX_CreateRegularBrokerString(v25, 0, (char *)v45, 0x80uLL);
            uint64_t v5 = select_bet6_VoiceOpen(*(void *)v19, *(void *)(v19 + 8), (uint64_t)v45, v19 + 24);
            if ((v5 & 0x80000000) != 0)
            {
LABEL_25:
              log_OutPublic(*(void *)(*(void *)(v19 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v21, v22, v23, v24, "lhError");
LABEL_26:
              *(void *)a5 = v19;
              *(_DWORD *)(a5 + 8) = 135973;
LABEL_27:
              synth_bet6_ObjClose((uint64_t *)v19, *(void *)(a5 + 8));
              *(void *)a5 = 0;
              *(_DWORD *)(a5 + 8) = 0;
LABEL_28:
              log_OutText(*(void *)(v44 + 32), (uint64_t)"SYNTH_BET6", 4, 0, (uint64_t)"synth_bet6_ObjOpen: %x", v34, v35, v36, v5);
              return v5;
            }
            uint64_t SirenVoice = select_bet6_GetSirenVoice((uint64_t *)(v19 + 24));
            *(void *)(v19 + 40) = SirenVoice;
            if (!SirenVoice)
            {
              log_OutPublic(*(void *)(*(void *)(v19 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, 0, v27, v28, v29, v30, v39);
              *(void *)a5 = v19;
              *(_DWORD *)(a5 + 8) = 135973;
              goto LABEL_33;
            }
            *(void *)&long long v40 = v19;
            Listeuint64_t n = synth_bet6_loc_ParamGetListen(v19, "volume", 0, 100, 0x50u, &v40, &v42);
            if ((Listen & 0x80000000) != 0) {
              goto LABEL_31;
            }
            Listeuint64_t n = synth_bet6_loc_ParamGetListen(v19, "rate_baseline", 50, 400, 0x64u, &v40, &v42);
            if ((Listen & 0x80000000) != 0) {
              goto LABEL_31;
            }
            Listeuint64_t n = synth_bet6_loc_ParamGetListen(v19, "pitch_baseline", 50, 200, 0x64u, &v40, &v42);
            if ((Listen & 0x80000000) != 0) {
              goto LABEL_31;
            }
            Listeuint64_t n = synth_bet6_loc_ParamGetListen(v19, "rate", 50, 400, 0x64u, &v40, &v42);
            if ((Listen & 0x80000000) != 0) {
              goto LABEL_31;
            }
            Listeuint64_t n = synth_bet6_loc_ParamGetListen(v19, "pitch", 50, 200, 0x64u, &v40, &v42);
            if ((Listen & 0x80000000) != 0) {
              goto LABEL_31;
            }
            Listeuint64_t n = synth_bet6_loc_ParamGetListen(v19, "audiooutputbufsamples", 1, 0x7FFFFFFF, 0x100u, &v40, &v42);
            if ((Listen & 0x80000000) != 0) {
              goto LABEL_31;
            }
            *(_DWORD *)(v19 + 1036) = v42;
            uint64_t v32 = *(_DWORD **)(v19 + 40);
            uint64_t v33 = 274877907 * v32[8] * v32[4];
            *(_DWORD *)(v19 + 1032) = (v33 >> 38) + ((unint64_t)v33 >> 63);
            if (v32[2282] || v32[2280]) {
              *(_DWORD *)(v19 + 1032) = v32[2297];
            }
            Listeuint64_t n = synth_bet6_loc_ParamGetListen(v19, "waitfactor", 0, 9, 2u, &v40, &v42);
            if ((Listen & 0x80000000) != 0)
            {
LABEL_31:
              uint64_t v5 = Listen;
              goto LABEL_26;
            }
            uint64_t Object = siren_common_synth_Init(*(void *)(v19 + 8), *(_DWORD **)(v19 + 40), (uint64_t *)(v19 + 48));
            if ((Object & 0x80000000) == 0)
            {
              uint64_t v5 = synth_bet6_loc_InitFromParamc(v19);
              *(void *)a5 = v19;
              *(_DWORD *)(a5 + 8) = 135973;
              if ((v5 & 0x80000000) != 0) {
                goto LABEL_27;
              }
LABEL_33:
              if (*(void *)(v19 + 40) && *(void *)(v19 + 48)) {
                goto LABEL_28;
              }
              goto LABEL_27;
            }
          }
        }
        uint64_t v5 = Object;
        goto LABEL_25;
      }
      return 2229280776;
    }
  }
  return v5;
}

uint64_t synth_bet6_ObjClose(uint64_t *a1, int a2)
{
  uint64_t v3 = safeh_HandleCheck((uint64_t)a1, a2, 135973, 1184);
  if ((v3 & 0x80000000) != 0) {
    return 2229280776;
  }
  uint64_t v7 = v3;
  if (a1)
  {
    uint64_t v8 = a1[1];
    log_OutText(*(void *)(v8 + 32), (uint64_t)"SYNTH_BET6", 4, 0, (uint64_t)"Entering synth_bet6_ObjClose", v4, v5, v6, v44);
    uint64_t v9 = *(void *)(v8 + 40);
    uint64_t v46 = a1;
    long long v45 = *(long long *)((char *)&xmmword_26D214DE8 + 8);
    long long v47 = *(long long *)((char *)&xmmword_26D214DE8 + 8);
    int v10 = paramc_ListenerRemove(v9, "volume", (long long *)&v46);
    uint64_t v11 = *(void *)(v8 + 40);
    if (v10 >= 0) {
      int v12 = v7;
    }
    else {
      int v12 = v10;
    }
    uint64_t v46 = a1;
    long long v47 = v45;
    int v13 = paramc_ListenerRemove(v11, "rate", (long long *)&v46);
    uint64_t v14 = *(void *)(v8 + 40);
    if (v13 < 0 && v12 > -1) {
      int v12 = v13;
    }
    uint64_t v46 = a1;
    long long v47 = v45;
    int v16 = paramc_ListenerRemove(v14, "pitch", (long long *)&v46);
    uint64_t v17 = *(void *)(v8 + 40);
    if (v16 < 0 && v12 > -1) {
      int v12 = v16;
    }
    uint64_t v46 = a1;
    long long v47 = v45;
    int v19 = paramc_ListenerRemove(v17, "pitch_baseline", (long long *)&v46);
    uint64_t v20 = *(void *)(v8 + 40);
    if (v19 < 0 && v12 > -1) {
      int v12 = v19;
    }
    uint64_t v46 = a1;
    long long v47 = v45;
    int v22 = paramc_ListenerRemove(v20, "rate_baseline", (long long *)&v46);
    uint64_t v23 = *(void *)(v8 + 40);
    if (v22 < 0 && v12 > -1) {
      int v12 = v22;
    }
    uint64_t v46 = a1;
    long long v47 = v45;
    int v25 = paramc_ListenerRemove(v23, "audiooutputbufsamples", (long long *)&v46);
    uint64_t v26 = *(void *)(v8 + 40);
    if (v25 < 0 && v12 > -1) {
      int v12 = v25;
    }
    uint64_t v46 = a1;
    long long v47 = v45;
    int v28 = paramc_ListenerRemove(v26, "waitfactor", (long long *)&v46);
    if (v28 >= 0 || v12 <= -1) {
      uint64_t v7 = v12;
    }
    else {
      uint64_t v7 = v28;
    }
    uint64_t v30 = (uint64_t *)a1[6];
    if (v30)
    {
      int v31 = siren_common_synth_DeInit(v30);
      if ((int)v7 > -1 && v31 < 0) {
        uint64_t v7 = v31;
      }
      else {
        uint64_t v7 = v7;
      }
    }
    if (a1[5])
    {
      int v33 = select_bet6_VoiceClose(*a1, a1 + 3);
      if ((int)v7 > -1 && v33 < 0) {
        uint64_t v7 = v33;
      }
      else {
        uint64_t v7 = v7;
      }
    }
    if (a1[7])
    {
      int v35 = objc_ReleaseObject(*(void *)(v8 + 48), (uint64_t)"SYNTHSTREAM");
      if ((int)v7 > -1 && v35 < 0) {
        uint64_t v7 = v35;
      }
      else {
        uint64_t v7 = v7;
      }
    }
    uint64_t v37 = a1[2];
    if (v37)
    {
      int v38 = critsec_ObjClose(v37);
      if ((int)v7 > -1 && v38 < 0) {
        uint64_t v7 = v38;
      }
      else {
        uint64_t v7 = v7;
      }
    }
    heap_Free(*(void **)(v8 + 8), (uint64_t)a1);
    log_OutText(*(void *)(v8 + 32), (uint64_t)"SYNTH_BET6", 4, 0, (uint64_t)"Leaving synth_bet6_ObjClose: %x", v40, v41, v42, v7);
  }
  return v7;
}

uint64_t synth_bet6_ObjReopen(uint64_t a1, int a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  *(_OWORD *)long long __s1 = 0u;
  long long v19 = 0u;
  if ((safeh_HandleCheck(a1, a2, 135973, 1184) & 0x80000000) != 0) {
    return 2229280776;
  }
  log_OutText(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 4, 0, (uint64_t)"Entering synth_bet6_ObjReopen", v3, v4, v5, v17);
  LODWORD(v9) = betX_CreateRegularBrokerString(*(void *)(a1 + 8), 0, __s1, 0x80uLL);
  if ((v9 & 0x80000000) == 0
    && *(void *)(a1 + 40)
    && (VoiceBrkString = (const char *)select_bet6_GetVoiceBrkString((uint64_t *)(a1 + 24)),
        cstdlib_strcmp(__s1, VoiceBrkString)))
  {
    int v11 = siren_common_synth_DeInit(*(uint64_t **)(a1 + 48));
    if (v11 < 0) {
      LODWORD(v9) = v11;
    }
    unsigned int v12 = select_bet6_VoiceClose(*(void *)a1, (uint64_t *)(a1 + 24));
    if ((v12 & 0x80000000) != 0
      || (unsigned int v12 = select_bet6_VoiceOpen(*(void *)a1, *(void *)(a1 + 8), (uint64_t)__s1, a1 + 24),
          (v12 & 0x80000000) != 0))
    {
      unsigned int v14 = v12;
    }
    else
    {
      uint64_t SirenVoice = (_DWORD *)select_bet6_GetSirenVoice((uint64_t *)(a1 + 24));
      *(void *)(a1 + 40) = SirenVoice;
      unsigned int v14 = siren_common_synth_Init(*(void *)(a1 + 8), SirenVoice, (uint64_t *)(a1 + 48));
      if ((v14 & 0x80000000) != 0) {
        select_bet6_VoiceClose(*(void *)a1, (uint64_t *)(a1 + 24));
      }
      else {
        LODWORD(v9) = synth_bet6_loc_InitFromParamc(a1);
      }
    }
  }
  else
  {
    unsigned int v14 = 0;
  }
  if (v14) {
    BOOL v15 = (int)v9 <= -1;
  }
  else {
    BOOL v15 = 1;
  }
  if (v15) {
    uint64_t v9 = v9;
  }
  else {
    uint64_t v9 = v14;
  }
  log_OutText(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 4, 0, (uint64_t)"synth_bet6_ObjReopen: %x", v6, v7, v8, v9);
  return v9;
}

uint64_t synth_bet6_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v13 = 0;
  uint64_t v8 = 2229280778;
  if ((safeh_HandleCheck(a1, a2, 135973, 1184) & 0x80000000) != 0) {
    return 2229280776;
  }
  synstrmaux_BuildAudioContentType("audio/L16;rate=",
    *(_DWORD *)(*(void *)(a1 + 40) + 16),
    (char *)(a1 + 984),
    0x30uLL);
  synstrmaux_InitStreamOpener(a1 + 64, *(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6");
  synstrmaux_RegisterInStream((_WORD *)(a1 + 64), (uint64_t)"application/x-realspeak-bet6-speech-frames", 0, a1 + 904);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 64), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
    0,
    a1 + 888);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 64), a1 + 984, a1 + 968);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 64), (uint64_t)"application/x-realspeak-markers-pp;version=4.0", a1 + 952);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 64), (uint64_t)"application/x-realspeak-bet6-sample-chunk", 0, a1 + 920);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 64), (uint64_t)"applcation/x-realspeak-bet6-select-audio", 0, a1 + 936);
  uint64_t v9 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 64), *(void *)(a1 + 56), a3, a4);
  if ((v9 & 0x80000000) != 0) {
    goto LABEL_11;
  }
  uint64_t v10 = heap_Calloc(*(void **)(*(void *)(a1 + 8) + 8), *(unsigned int *)(a1 + 1036), 2);
  *(void *)(a1 + 1128) = v10;
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = heap_Calloc(*(void **)(*(void *)(a1 + 8) + 8), *(unsigned int *)(a1 + 1036), 2);
  *(void *)(a1 + 1136) = v11;
  if (!v11) {
    goto LABEL_12;
  }
  if (*(_DWORD *)(*(void *)(a1 + 40) + 9184)
    && (uint64_t v9 = SampleChunk_alloc(*(void *)(a1 + 8), (uint64_t *)(a1 + 1176)), (v9 & 0x80000000) != 0)
    || (uint64_t v9 = siren_common_synth_Reset(*(void *)(a1 + 48)), (v9 & 0x80000000) != 0))
  {
LABEL_11:
    uint64_t v8 = v9;
    goto LABEL_12;
  }
  uint64_t v8 = synth_bet6_loc_InitFromParamc(a1);
  if ((v8 & 0x80000000) != 0)
  {
LABEL_12:
    synth_bet6_ProcessEnd(a1, a2);
    return v8;
  }
  *(_DWORD *)(a1 + 1120) = 0;
  *(_OWORD *)(a1 + 1060) = 0u;
  *(_OWORD *)(a1 + 1076) = 0u;
  paramc_ParamGetInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"rate", &v13);
  *(float *)(a1 + 1092) = (float)v13 / 100.0;
  paramc_ParamGetInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"pitch", &v13);
  *(float *)(a1 + 1096) = (float)v13 / 100.0;
  paramc_ParamGetInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"volume", &v13);
  *(float *)(a1 + 1100) = (float)v13 / 100.0;
  return v8;
}

uint64_t synth_bet6_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int *a5)
{
  uint64_t v7 = 2229280778;
  if ((safeh_HandleCheck(a1, a2, 135973, 1184) & 0x80000000) != 0) {
    return 2229280776;
  }
  uint64_t v8 = *(_DWORD **)(a1 + 40);
  if (v8[2296])
  {
    uint64_t v171 = 0;
    int v172 = 0;
    uint64_t __dst = 0;
    __src = 0;
    LODWORD(__n) = 0;
    uint64_t v166 = 0;
    uint64_t v167 = 0;
    *a5 = 1;
    unsigned int v9 = *(_DWORD *)(a1 + 1036);
    unsigned int v10 = *(_DWORD *)(a1 + 1032);
    int v11 = v9 / v10 * v10;
    if (!v10) {
      int v11 = *(_DWORD *)(a1 + 1036);
    }
    if (v9 >= v10) {
      int v12 = v11;
    }
    else {
      int v12 = *(_DWORD *)(a1 + 1032);
    }
    uint64_t v7 = (*(uint64_t (**)(void, void, char *, uint64_t *))(*(void *)(a1 + 56) + 144))(*(void *)(a1 + 904), *(void *)(a1 + 912), (char *)&v166 + 4, &v166);
    if ((v7 & 0x80000000) == 0)
    {
      HIDWORD(v166) = HIDWORD(v166) / (4 * (unint64_t)v8[2301]);
      if (!HIDWORD(v166))
      {
        if (v166) {
          end_cur_stream_MT(a1, (const void **)&__src, &__dst, (unsigned int *)&__n, (unsigned int *)&v167 + 1);
        }
        else {
          *a5 = 0;
        }
        if (!siren_common_synth_GetLeftSamples(*(void *)(a1 + 48))) {
          return v7;
        }
      }
      int LeftSamples = siren_common_synth_GetLeftSamples(*(void *)(a1 + 48));
      if (LeftSamples) {
        goto LABEL_54;
      }
      uint64_t v53 = (*(uint64_t (**)(void, void, void **, uint64_t *))(*(void *)(a1 + 56) + 88))(*(void *)(a1 + 904), *(void *)(a1 + 912), &v172, &v167);
      if ((v53 & 0x80000000) != 0) {
        goto LABEL_75;
      }
      uint64_t v70 = (char *)v172 + 4;
      float v71 = (float)*(unsigned int *)v172;
      *(float *)(a1 + 1116) = v71;
      int v172 = v70;
      uint64_t v44 = SampleChunk_init(*(void *)(a1 + 8), *(_DWORD *)(*(void *)(a1 + 40) + 9204), *(_DWORD *)(*(void *)(a1 + 40) + 9168), *(void *)(a1 + 56), *(void *)(a1 + 920), *(void *)(a1 + 928), v71, v167, *(void *)(a1 + 1176));
      if ((v44 & 0x80000000) == 0)
      {
LABEL_54:
        uint64_t v53 = (*(uint64_t (**)(void, void, void **, size_t *))(*(void *)(a1 + 56) + 88))(*(void *)(a1 + 888), *(void *)(a1 + 896), &__src, &__n);
        if ((v53 & 0x80000000) == 0)
        {
          uint64_t v53 = (*(uint64_t (**)(void, void, unsigned int **, void))(*(void *)(a1 + 56) + 112))(*(void *)(a1 + 968), *(void *)(a1 + 976), &v171, (2 * v12));
          if ((v53 & 0x80000000) == 0)
          {
            if (!__n
              || (uint64_t v53 = (*(uint64_t (**)(void, void, void **))(*(void *)(a1 + 56) + 112))(*(void *)(a1 + 952), *(void *)(a1 + 960), &__dst), (v53 & 0x80000000) == 0))
            {
              uint64_t v58 = v171;
              uint64_t v59 = v172;
              unsigned int v61 = HIDWORD(v166);
              unsigned int v60 = v167;
              uint64_t v44 = critsec_Enter(*(void **)(a1 + 16));
              if ((v44 & 0x80000000) == 0)
              {
                if (__dst) {
                  cstdlib_memcpy(__dst, __src, __n);
                }
                unsigned int v163 = v60;
                unsigned int v65 = HIDWORD(v167);
                unsigned int v64 = __n;
                LODWORD(__n) = __n >> 5;
                if (HIDWORD(v167) < v64 >> 5)
                {
                  uint64_t v66 = __dst;
                  do
                  {
                    if (v66[8 * v65 + 3] > *(_DWORD *)(a1 + 1072)) {
                      break;
                    }
                    unsigned int v67 = v66[8 * v65] - 16;
                    if (v67 <= 9 && ((0x305u >> v67) & 1) != 0)
                    {
                      uint64_t v68 = off_26456B0A8[v67];
                      critsec_Leave(*(void **)(a1 + 16));
                      paramc_ParamSetUInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)v68, *((_DWORD *)__dst + 8 * v65 + 6));
                      critsec_Enter(*(void **)(a1 + 16));
                      uint64_t v66 = __dst;
                    }
                    v66[8 * v65 + 3] = *(_DWORD *)(a1 + 1080);
                    v66[8 * HIDWORD(v167) + 4] = *(_DWORD *)(a1 + 1032)
                                               * v66[8 * HIDWORD(v167) + 4]
                                               * *(unsigned __int16 *)(a1 + 1042)
                                               / 0x64;
                    unsigned int v65 = HIDWORD(v167) + 1;
                    HIDWORD(v167) = v65;
                  }
                  while (v65 < __n);
                }
                LODWORD(v7) = siren_common_synth_ProcessStart(*(void *)(a1 + 48), (uint64_t)v59, v61, (uint64_t)v58, v12, *(void *)(a1 + 1176), v62, v63);
                if (v7)
                {
LABEL_69:
                  unsigned int v69 = critsec_Leave(*(void **)(a1 + 16));
                  if ((int)v7 >= 0) {
                    return v69;
                  }
                  else {
                    return v7;
                  }
                }
                int CurSampleCount = 0;
                do
                {
                  LODWORD(v7) = new_siren_nn_mt_synth_Process(*(void *)(a1 + 48));
                  if ((v7 & 0x80000000) != 0) {
                    goto LABEL_69;
                  }
                  *(_DWORD *)(a1 + 1072) += siren_common_synth_GetFeedFrames(*(void *)(a1 + 48));
                  *(_DWORD *)(a1 + 1080) += siren_common_synth_GetCurSampleCount(*(void *)(a1 + 48)) - CurSampleCount;
                  int CurSampleCount = siren_common_synth_GetCurSampleCount(*(void *)(a1 + 48));
                }
                while (siren_common_synth_GetLeftSamples(*(void *)(a1 + 48))
                     && !siren_common_synth_GetIsBufferFull(*(void *)(a1 + 48)));
                if (v7) {
                  goto LABEL_69;
                }
                uint64_t v93 = *(uint64_t (**)(void, void, void))(*(void *)(a1 + 56) + 120);
                int v94 = siren_common_synth_GetCurSampleCount(*(void *)(a1 + 48));
                int v95 = v93(*(void *)(a1 + 968), *(void *)(a1 + 976), (2 * v94));
                if (v95 < 0)
                {
                  int v100 = v95;
                  log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v96, v97, v98, v99, "lhError");
                }
                else
                {
                  int v100 = 0;
                }
                unsigned int v141 = 32 * v65;
                if (v65)
                {
                  int v142 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 56) + 120))(*(void *)(a1 + 952), *(void *)(a1 + 960), v141 & ~(v100 >> 31));
                  if (v142 < 0)
                  {
                    int v147 = v142;
                    log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v143, v144, v145, v146, "lhError");
                    if (v100 >= 0) {
                      int v100 = v147;
                    }
                  }
                }
                if (!LeftSamples
                  && ((*(uint64_t (**)(void, void, void))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 904), *(void *)(a1 + 912), v163) & 0x80000000) != 0)
                {
                  log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v148, v149, v150, v151, "lhError");
                  uint64_t v152 = 0;
                }
                else if (v100 >= 0)
                {
                  uint64_t v152 = v141;
                }
                else
                {
                  uint64_t v152 = 0;
                }
                if (((*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 888), *(void *)(a1 + 896), v152) & 0x80000000) != 0)log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v153, v154, v155, v156, "lhError"); {
                int v157 = siren_common_synth_GetLeftSamples(*(void *)(a1 + 48));
                }
                int v158 = siren_common_synth_SetCurFrameCount(*(void *)(a1 + 48), 0);
                LODWORD(v7) = v158;
                if (v157)
                {
                  if (!v158)
                  {
                    LODWORD(v7) = siren_common_synth_SetCurSampleCount(*(void *)(a1 + 48), 0);
                    if (!v7)
                    {
                      int v159 = 2;
LABEL_204:
                      *a5 = v159;
LABEL_205:
                      LODWORD(v7) = siren_common_synth_ProcessEnd(*(void *)(a1 + 48));
                      goto LABEL_69;
                    }
                  }
                }
                else if (!v158)
                {
                  LODWORD(v7) = siren_common_synth_SetCurSampleCount(*(void *)(a1 + 48), 0);
                  if (!v7)
                  {
                    int v159 = 1;
                    goto LABEL_204;
                  }
                }
                if ((v7 & 0x80000000) != 0) {
                  goto LABEL_69;
                }
                goto LABEL_205;
              }
              return v44;
            }
          }
        }
LABEL_75:
        uint64_t v7 = v53;
        log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v54, v55, v56, v57, "lhError");
        return v7;
      }
      return v44;
    }
    uint64_t v28 = *(void *)(*(void *)(a1 + 8) + 32);
    goto LABEL_20;
  }
  if (v8[2279])
  {
    __src = 0;
    uint64_t v171 = 0;
    LODWORD(__dst) = 0;
    LODWORD(__n) = 0;
    uint64_t v167 = 0;
    float v17 = *(float *)(a1 + 1092);
    HIDWORD(v166) = 0;
    uint64_t v18 = *(unsigned int *)(a1 + 1036);
    *a5 = 1;
    uint64_t v23 = (*(uint64_t (**)(void, void, char *, char *))(*(void *)(a1 + 56) + 144))(*(void *)(a1 + 936), *(void *)(a1 + 944), (char *)&v167 + 4, (char *)&v166 + 4);
    if ((v23 & 0x80000000) == 0)
    {
      if (!HIDWORD(v167) && *(_DWORD *)(a1 + 1064) == *(_DWORD *)(a1 + 1088))
      {
        if (HIDWORD(v166))
        {
          long long v24 = (void **)&v171;
          p_src = &__src;
          p_dst = (unsigned int *)&__dst;
          p_uint64_t n = (unsigned int *)&__n;
LABEL_105:
          end_cur_stream_MT(a1, (const void **)v24, p_src, p_dst, p_n);
          return v23;
        }
        goto LABEL_106;
      }
      uint64_t v40 = (*(uint64_t (**)(void, void, unsigned int **, void **))(*(void *)(a1 + 56) + 88))(*(void *)(a1 + 888), *(void *)(a1 + 896), &v171, &__dst);
      unsigned int v41 = __dst;
      unsigned int v42 = __dst >> 5;
      LODWORD(__dst) = __dst >> 5;
      if ((v40 & 0x80000000) == 0)
      {
        uint64_t v43 = v171;
        if (v41 >= 0x20 && *v171 == 0x4000)
        {
          synth_bet6_ProcessReset((void *)a1);
          unsigned int v42 = __dst;
          uint64_t v43 = v171;
        }
        uint64_t v44 = synth_bet6_loc_cache_markers(a1, v42, v43);
        if ((v44 & 0x80000000) != 0) {
          return v44;
        }
        uint64_t v40 = (*(uint64_t (**)(void, void, uint64_t, uint64_t *))(*(void *)(a1 + 56) + 88))(*(void *)(a1 + 936), *(void *)(a1 + 944), a1 + 1144, &v167);
        if ((v40 & 0x80000000) == 0)
        {
          LODWORD(v167) = v167 >> 1;
          uint64_t v44 = synth_bet6_loc_Postprocess_sonic(a1, *(void *)(a1 + 1144), v167, v167, v171, __dst, 4.0);
          if ((v44 & 0x80000000) != 0) {
            return v44;
          }
          synth_bet6_loc_adjust_markers(a1, __dst, (uint64_t)v171, v17);
          uint64_t v45 = v167;
          uint64_t v46 = *(void *)(a1 + 1152);
          if (v46)
          {
            size_t v47 = 2 * v167;
            uint64_t v48 = *(unsigned int *)(a1 + 1080);
            uint64_t v49 = *(unsigned int *)(a1 + 1104);
            if (v47 > v49 - 2 * v48)
            {
              uint64_t v50 = 2 * v48;
              do
                uint64_t v49 = (2 * v49);
              while (v47 > v49 - v50);
              *(_DWORD *)(a1 + 1104) = v49;
            }
            uint64_t v51 = heap_Realloc(*(uint64_t **)(*(void *)(a1 + 8) + 8), v46, v49);
            if (!v51) {
              return v7;
            }
            *(void *)(a1 + 1152) = v51;
          }
          else
          {
            uint64_t v51 = heap_Calloc(*(void **)(*(void *)(a1 + 8) + 8), v167, 2);
            *(void *)(a1 + 1152) = v51;
            if (!v51) {
              return v7;
            }
            *(_DWORD *)(a1 + 1104) = 2 * v45;
            size_t v47 = 2 * v45;
          }
          cstdlib_memcpy((void *)(v51 + 2 * *(unsigned int *)(a1 + 1080)), *(const void **)(a1 + 1144), v47);
          *(_DWORD *)(a1 + 1080) += v45;
          int v172 = 0;
          uint64_t v101 = (*(uint64_t (**)(void, void, void **, uint64_t))(*(void *)(a1 + 56) + 112))(*(void *)(a1 + 968), *(void *)(a1 + 976), &v172, 2 * v18);
          if ((v101 & 0x80000000) != 0)
          {
            uint64_t v7 = v101;
          }
          else
          {
            unsigned int v102 = *(_DWORD *)(a1 + 1088);
            uint64_t v103 = *(unsigned int *)(a1 + 1064);
            if (v102 <= (int)v103 + (int)v18)
            {
              LODWORD(v18) = v102 - v103;
              cstdlib_memcpy(v172, (const void *)(*(void *)(a1 + 1160) + 2 * v103), 2 * (v102 - v103));
              int v104 = *(_DWORD *)(a1 + 1088);
            }
            else
            {
              cstdlib_memcpy(v172, (const void *)(*(void *)(a1 + 1160) + 2 * v103), 2 * v18);
              int v104 = *(_DWORD *)(a1 + 1064) + v18;
            }
            *(_DWORD *)(a1 + 1064) = v104;
            uint64_t v128 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 56) + 120))(*(void *)(a1 + 968), *(void *)(a1 + 976), (2 * v18));
            if ((v128 & 0x80000000) == 0)
            {
              uint64_t v7 = synth_bet6_loc_write_markers(a1, __n, __src, 0);
              if ((v7 & 0x80000000) == 0)
              {
                uint64_t v129 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 936), *(void *)(a1 + 944), (2 * v167));
                if ((v129 & 0x80000000) != 0)
                {
                  uint64_t v134 = v129;
                  log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v130, v131, v132, v133, "lhError");
                  uint64_t v7 = v134;
                }
                unsigned int v135 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 888), *(void *)(a1 + 896), (32 * __dst));
                if ((v135 & 0x80000000) != 0)
                {
                  unsigned int v160 = v135;
                  log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v136, v137, v138, v139, "lhError");
                  if ((int)v7 >= 0) {
                    uint64_t v7 = v160;
                  }
                  else {
                    uint64_t v7 = v7;
                  }
                  if (*(_DWORD *)(a1 + 1064) == *(_DWORD *)(a1 + 1088)) {
                    int v161 = 1;
                  }
                  else {
                    int v161 = 2;
                  }
                  *a5 = v161;
                  return v7;
                }
                int v140 = *(_DWORD *)(a1 + 1064) == *(_DWORD *)(a1 + 1088) ? 1 : 2;
                *a5 = v140;
                if ((v7 & 0x80000000) == 0) {
                  return siren_common_synth_ProcessEnd(*(void *)(a1 + 48));
                }
              }
              return v7;
            }
            uint64_t v7 = v128;
          }
          uint64_t v28 = *(void *)(*(void *)(a1 + 8) + 32);
LABEL_20:
          log_OutPublic(v28, (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v13, v14, v15, v16, "lhError");
          return v7;
        }
      }
      uint64_t v23 = v40;
    }
    goto LABEL_49;
  }
  if (v8[2280])
  {
    uint64_t v171 = 0;
    int v172 = 0;
    uint64_t __dst = 0;
    __src = 0;
    uint64_t v167 = 0;
    __uint64_t n = 0;
    LODWORD(v166) = 0;
    uint64_t v164 = 0;
    uint64_t v165 = 0;
    float v29 = *(float *)(a1 + 1092);
    *a5 = 1;
    uint64_t v23 = (*(uint64_t (**)(void, void, char *, char *))(*(void *)(a1 + 56) + 144))(*(void *)(a1 + 904), *(void *)(a1 + 912), (char *)&v165 + 4, (char *)&v164 + 4);
    if ((v23 & 0x80000000) == 0)
    {
      if (HIDWORD(v165))
      {
        HIDWORD(v165) = HIDWORD(v165) / (4 * (unint64_t)v8[2301]);
        uint64_t v30 = (*(uint64_t (**)(void, void, void **, uint64_t *))(*(void *)(a1 + 56) + 88))(*(void *)(a1 + 904), *(void *)(a1 + 912), &v172, &v166);
        if ((v30 & 0x80000000) == 0)
        {
          uint64_t v30 = (*(uint64_t (**)(void, void, void **, char *))(*(void *)(a1 + 56) + 88))(*(void *)(a1 + 888), *(void *)(a1 + 896), &__dst, (char *)&v167 + 4);
          if ((v30 & 0x80000000) == 0)
          {
            unsigned int v35 = HIDWORD(v167);
            HIDWORD(v167) >>= 5;
            if (v35 >= 0x20 && *(_DWORD *)__dst == 0x4000) {
              synth_bet6_ProcessReset((void *)a1);
            }
            uint64_t v36 = critsec_Enter(*(void **)(a1 + 16));
            if ((v36 & 0x80000000) == 0)
            {
              (*(void (**)(void, void, uint64_t *))(*(void *)(a1 + 56) + 136))(*(void *)(a1 + 968), *(void *)(a1 + 976), &v164);
              LODWORD(v164) = (v164 >> 1) - *(_DWORD *)(a1 + 1064);
              float v37 = *(float *)v172;
              int v38 = HIDWORD(v165);
              if (*(float *)v172 == 5.0 || v37 == 1.0 || v37 == 2.0)
              {
                if (HIDWORD(v165) >= 2) {
                  int v39 = HIDWORD(v165) - 2;
                }
                else {
                  int v39 = 0;
                }
                int v38 = *(_DWORD *)(a1 + 1032);
              }
              else
              {
                int v39 = *(_DWORD *)(a1 + 1032);
              }
              uint64_t v105 = (v39 * v38);
              HIDWORD(v166) = v105;
              *(_DWORD *)(a1 + 1036) = v105;
              unint64_t v106 = HIDWORD(v167);
              if (HIDWORD(v167))
              {
                uint64_t v107 = 0;
                unint64_t v108 = 0;
                do
                {
                  if (*(_DWORD *)((char *)__dst + v107) == 25)
                  {
                    critsec_Leave(*(void **)(a1 + 16));
                    paramc_ParamSetUInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"waitfactor", *(_DWORD *)((char *)__dst + v107 + 24));
                    *(_WORD *)(a1 + 1056) = *(_DWORD *)((char *)__dst + v107 + 24);
                    critsec_Enter(*(void **)(a1 + 16));
                    unint64_t v106 = HIDWORD(v167);
                  }
                  ++v108;
                  v107 += 32;
                }
                while (v108 < v106);
              }
              double v78 = (unsigned int *)heap_Calloc(*(void **)(*(void *)(a1 + 8) + 8), v105, 2);
              uint64_t v171 = v78;
              if (!v78) {
                goto LABEL_155;
              }
              uint64_t v81 = siren_common_synth_ProcessStart(*(void *)(a1 + 48), (uint64_t)v172, HIDWORD(v165), (uint64_t)v78, v105, 0, v109, v110);
              if ((v81 & 0x80000000) != 0) {
                goto LABEL_154;
              }
              uint64_t v81 = siren_common_synth_Process(*(void *)(a1 + 48), 0, HIDWORD(v165) - 1);
              if ((v81 & 0x80000000) != 0) {
                goto LABEL_154;
              }
              *(_DWORD *)(a1 + 1072) += siren_common_synth_GetCurFrameCount(*(void *)(a1 + 48));
              int v82 = siren_common_synth_GetCurSampleCount(*(void *)(a1 + 48));
              LODWORD(v165) = v82;
              unsigned int v83 = *((_DWORD *)v172 + 1);
              unsigned int v84 = *((_DWORD *)v172 + 2);
              unsigned int v111 = *(_DWORD *)(a1 + 1080);
              unsigned int v86 = *(_DWORD *)(a1 + 1076);
              double v87 = __dst;
              uint64_t v88 = HIDWORD(v167);
              BOOL v89 = v111 >= v86;
              unsigned int v112 = v111 - v86;
              if (v112 == 0 || !v89 || !HIDWORD(v167)) {
                goto LABEL_144;
              }
              uint64_t v113 = (unsigned int *)((char *)__dst + 12);
              do
              {
                if (*v113 >= v86) {
                  *v113 += v112;
                }
                v113 += 8;
                --v88;
              }
              while (v88);
              goto LABEL_143;
            }
            return v36;
          }
        }
        goto LABEL_102;
      }
      goto LABEL_103;
    }
    goto LABEL_49;
  }
  if (v8[2282])
  {
    uint64_t v171 = 0;
    int v172 = 0;
    uint64_t __dst = 0;
    __src = 0;
    uint64_t v167 = 0;
    __uint64_t n = 0;
    LODWORD(v166) = 0;
    uint64_t v164 = 0;
    uint64_t v165 = 0;
    float v29 = *(float *)(a1 + 1092);
    *a5 = 1;
    uint64_t v23 = (*(uint64_t (**)(void, void, char *, char *))(*(void *)(a1 + 56) + 144))(*(void *)(a1 + 904), *(void *)(a1 + 912), (char *)&v165 + 4, (char *)&v164 + 4);
    if ((v23 & 0x80000000) == 0)
    {
      if (HIDWORD(v165))
      {
        HIDWORD(v165) = HIDWORD(v165) / (4 * (unint64_t)v8[2301]);
        uint64_t v30 = (*(uint64_t (**)(void, void, void **, uint64_t *))(*(void *)(a1 + 56) + 88))(*(void *)(a1 + 904), *(void *)(a1 + 912), &v172, &v166);
        if ((v30 & 0x80000000) == 0)
        {
          uint64_t v30 = (*(uint64_t (**)(void, void, void **, char *))(*(void *)(a1 + 56) + 88))(*(void *)(a1 + 888), *(void *)(a1 + 896), &__dst, (char *)&v167 + 4);
          if ((v30 & 0x80000000) == 0)
          {
            unsigned int v73 = HIDWORD(v167);
            HIDWORD(v167) >>= 5;
            if (v73 >= 0x20 && *(_DWORD *)__dst == 0x4000) {
              synth_bet6_ProcessReset((void *)a1);
            }
            uint64_t v36 = critsec_Enter(*(void **)(a1 + 16));
            if ((v36 & 0x80000000) == 0)
            {
              (*(void (**)(void, void, uint64_t *))(*(void *)(a1 + 56) + 136))(*(void *)(a1 + 968), *(void *)(a1 + 976), &v164);
              LODWORD(v164) = (v164 >> 1) - *(_DWORD *)(a1 + 1064);
              float v37 = *(float *)v172;
              uint64_t v74 = (*(_DWORD *)(a1 + 1032) * HIDWORD(v165));
              HIDWORD(v166) = v74;
              *(_DWORD *)(a1 + 1036) = v74;
              unint64_t v75 = HIDWORD(v167);
              if (HIDWORD(v167))
              {
                uint64_t v76 = 0;
                unint64_t v77 = 0;
                do
                {
                  if (*(_DWORD *)((char *)__dst + v76) == 25)
                  {
                    critsec_Leave(*(void **)(a1 + 16));
                    paramc_ParamSetUInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"waitfactor", *(_DWORD *)((char *)__dst + v76 + 24));
                    *(_WORD *)(a1 + 1056) = *(_DWORD *)((char *)__dst + v76 + 24);
                    critsec_Enter(*(void **)(a1 + 16));
                    unint64_t v75 = HIDWORD(v167);
                  }
                  ++v77;
                  v76 += 32;
                }
                while (v77 < v75);
              }
              double v78 = (unsigned int *)heap_Calloc(*(void **)(*(void *)(a1 + 8) + 8), v74, 2);
              uint64_t v171 = v78;
              if (!v78) {
                goto LABEL_155;
              }
              uint64_t v81 = siren_common_synth_ProcessStart(*(void *)(a1 + 48), (uint64_t)v172, HIDWORD(v165), (uint64_t)v78, v74, 0, v79, v80);
              if ((v81 & 0x80000000) != 0) {
                goto LABEL_154;
              }
              uint64_t v81 = siren_common_synth_Process(*(void *)(a1 + 48), 0, HIDWORD(v165) - 1);
              if ((v81 & 0x80000000) != 0) {
                goto LABEL_154;
              }
              *(_DWORD *)(a1 + 1072) += siren_common_synth_GetCurFrameCount(*(void *)(a1 + 48));
              int v82 = siren_common_synth_GetCurSampleCount(*(void *)(a1 + 48));
              LODWORD(v165) = v82;
              unsigned int v83 = *((_DWORD *)v172 + 1);
              unsigned int v84 = *((_DWORD *)v172 + 2);
              unsigned int v85 = *(_DWORD *)(a1 + 1080);
              unsigned int v86 = *(_DWORD *)(a1 + 1076);
              double v87 = __dst;
              uint64_t v88 = HIDWORD(v167);
              BOOL v89 = v85 >= v86;
              unsigned int v90 = v85 - v86;
              if (v90 == 0 || !v89 || !HIDWORD(v167))
              {
LABEL_144:
                *(_DWORD *)(a1 + 1076) = v86 + v82;
                uint64_t inserted = synth_bet6_loc_InsertPause(a1, (uint64_t *)&v171, (uint64_t)v87, v88, (unsigned int *)&v165, (_DWORD *)&v166 + 1, v83, v84, v37);
                if ((inserted & 0x80000000) != 0)
                {
                  uint64_t v7 = inserted;
                  double v78 = v171;
                  goto LABEL_155;
                }
                uint64_t v81 = synth_bet6_loc_cache_markers(a1, HIDWORD(v167), __dst);
                double v78 = v171;
                if ((v81 & 0x80000000) == 0)
                {
                  int v115 = v165;
                  uint64_t v81 = synth_bet6_loc_Postprocess_sonic(a1, (uint64_t)v171, v165, SHIDWORD(v166), (unsigned int *)__dst, HIDWORD(v167), v37);
                  if ((v81 & 0x80000000) == 0)
                  {
                    synth_bet6_loc_adjust_markers(a1, HIDWORD(v167), (uint64_t)__dst, v29);
                    *(_DWORD *)(a1 + 1080) += v115;
                    size_t v116 = 2 * (*(_DWORD *)(a1 + 1088) - *(_DWORD *)(a1 + 1064));
                    uint64_t v117 = (*(uint64_t (**)(void, void, void **, size_t))(*(void *)(a1 + 56) + 112))(*(void *)(a1 + 968), *(void *)(a1 + 976), &__src, v116);
                    if ((v117 & 0x80000000) != 0)
                    {
                      uint64_t v162 = v117;
                      log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v118, v119, v120, v121, "lhError");
                      uint64_t v7 = v162;
                      goto LABEL_155;
                    }
                    cstdlib_memcpy(__src, (const void *)(*(void *)(a1 + 1160) + 2 * *(unsigned int *)(a1 + 1064)), v116);
                    *(_DWORD *)(a1 + 1064) = *(_DWORD *)(a1 + 1088);
                    uint64_t v122 = (*(uint64_t (**)(void, void, size_t))(*(void *)(a1 + 56) + 120))(*(void *)(a1 + 968), *(void *)(a1 + 976), v116);
                    if ((v122 & 0x80000000) != 0) {
                      goto LABEL_201;
                    }
                    uint64_t v81 = synth_bet6_loc_write_markers(a1, 0, 0, v164);
                    if ((v81 & 0x80000000) == 0)
                    {
                      uint64_t v122 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 904), *(void *)(a1 + 912), (4 * HIDWORD(v165) * v8[2301] + 12));
                      if ((v122 & 0x80000000) == 0)
                      {
                        uint64_t v122 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 888), *(void *)(a1 + 896), (32 * HIDWORD(v167)));
                        if ((v122 & 0x80000000) == 0)
                        {
                          uint64_t v7 = siren_common_synth_ProcessEnd(*(void *)(a1 + 48));
                          uint64_t v127 = critsec_Leave(*(void **)(a1 + 16));
                          if ((v7 & 0x80000000) == 0)
                          {
                            uint64_t v23 = v127;
                            goto LABEL_157;
                          }
LABEL_156:
                          uint64_t v23 = v7;
LABEL_157:
                          if (v78) {
                            heap_Free(*(void **)(*(void *)(a1 + 8) + 8), (uint64_t)v78);
                          }
                          return v23;
                        }
                      }
LABEL_201:
                      uint64_t v7 = v122;
                      log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v123, v124, v125, v126, "lhError");
                      goto LABEL_155;
                    }
                  }
                }
LABEL_154:
                uint64_t v7 = v81;
LABEL_155:
                critsec_Leave(*(void **)(a1 + 16));
                goto LABEL_156;
              }
              uint64_t v91 = (unsigned int *)((char *)__dst + 12);
              do
              {
                if (*v91 >= v86) {
                  *v91 += v90;
                }
                v91 += 8;
                --v88;
              }
              while (v88);
LABEL_143:
              LODWORD(v88) = HIDWORD(v167);
              goto LABEL_144;
            }
            return v36;
          }
        }
LABEL_102:
        uint64_t v23 = v30;
        log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v31, v32, v33, v34, "lhError");
        return v23;
      }
LABEL_103:
      if (HIDWORD(v164))
      {
        long long v24 = &__dst;
        p_src = (void **)&__n;
        p_dst = (unsigned int *)&v167 + 1;
        p_uint64_t n = (unsigned int *)&v167;
        goto LABEL_105;
      }
LABEL_106:
      *a5 = 0;
      return v23;
    }
LABEL_49:
    log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v19, v20, v21, v22, "lhError");
    return v23;
  }

  return synth_bet6_Process_ST(a1, a5);
}

uint64_t synth_bet6_ProcessEnd(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 135973, 1184) & 0x80000000) != 0) {
    return 2229280776;
  }
  *(void *)(a1 + 1060) = 0;
  uint64_t v3 = *(void *)(a1 + 1128);
  if (v3)
  {
    heap_Free(*(void **)(*(void *)(a1 + 8) + 8), v3);
    *(void *)(a1 + 1128) = 0;
  }
  uint64_t v4 = *(void *)(a1 + 1136);
  if (v4)
  {
    heap_Free(*(void **)(*(void *)(a1 + 8) + 8), v4);
    *(void *)(a1 + 1136) = 0;
  }
  uint64_t v5 = *(void *)(a1 + 1152);
  if (v5)
  {
    heap_Free(*(void **)(*(void *)(a1 + 8) + 8), v5);
    *(void *)(a1 + 1152) = 0;
    *(_DWORD *)(a1 + 1104) = 0;
  }
  uint64_t v6 = *(void *)(a1 + 1160);
  if (v6)
  {
    heap_Free(*(void **)(*(void *)(a1 + 8) + 8), v6);
    *(void *)(a1 + 1160) = 0;
    *(_DWORD *)(a1 + 1112) = 0;
  }
  uint64_t v7 = *(void *)(a1 + 1168);
  if (v7)
  {
    unint64_t v8 = *(unsigned int *)(a1 + 1084);
    if (v8)
    {
      uint64_t v9 = 0;
      for (unint64_t i = 0; i < v8; ++i)
      {
        uint64_t v11 = *(void *)(a1 + 1168);
        int v12 = *(_DWORD *)(v11 + v9);
        if (v12 == 29 || v12 == 26)
        {
          heap_Free(*(void **)(*(void *)(a1 + 8) + 8), *(void *)(v11 + v9 + 24));
          unint64_t v8 = *(unsigned int *)(a1 + 1084);
        }
        v9 += 32;
      }
      uint64_t v7 = *(void *)(a1 + 1168);
    }
    heap_Free(*(void **)(*(void *)(a1 + 8) + 8), v7);
    *(void *)(a1 + 1168) = 0;
    *(_DWORD *)(a1 + 1108) = 0;
  }
  if (*(_DWORD *)(*(void *)(a1 + 40) + 9184))
  {
    SampleChunk_free(*(void *)(a1 + 8), *(void *)(a1 + 1176));
    *(void *)(a1 + 1176) = 0;
  }
  siren_common_synth_Reset(*(void *)(a1 + 48));
  uint64_t v14 = *(void *)(a1 + 56);

  return synstrmaux_CloseStreams((_WORD *)(a1 + 64), v14);
}

uint64_t synth_bet6_loc_ParamCheckChange(int a1, char *__s1, const char *a3, _DWORD *a4)
{
  if (cstdlib_strcmp(__s1, "audiooutputbufsamples"))
  {
    if (cstdlib_strcmp(__s1, "volume"))
    {
      if (cstdlib_strcmp(__s1, "rate") && cstdlib_strcmp(__s1, "rate_baseline"))
      {
        if (cstdlib_strcmp(__s1, "ratewpm"))
        {
          if (cstdlib_strcmp(__s1, "pitch") && cstdlib_strcmp(__s1, "pitch_baseline"))
          {
            uint64_t result = 0;
          }
          else if (LH_atoi(a3) - 201 >= 0xFFFFFF69)
          {
            uint64_t result = 0;
          }
          else
          {
            uint64_t result = 2229280783;
          }
        }
        else
        {
          uint64_t result = 2229280769;
        }
      }
      else if (LH_atoi(a3) - 401 >= 0xFFFFFEA1)
      {
        uint64_t result = 0;
      }
      else
      {
        uint64_t result = 2229280783;
      }
    }
    else if (LH_atoi(a3) <= 0x64)
    {
      uint64_t result = 0;
    }
    else
    {
      uint64_t result = 2229280783;
    }
  }
  else if ((int)LH_atoi(a3) <= 0)
  {
    uint64_t result = 2229280783;
  }
  else
  {
    uint64_t result = 0;
  }
  *a4 = (int)result >= 0;
  return result;
}

uint64_t synth_bet6_loc_ParamLearnChange(uint64_t a1, char *__s1, const char *a3)
{
  if (cstdlib_strcmp(__s1, "audiooutputbufsamples")
    && cstdlib_strcmp(__s1, "volume")
    && cstdlib_strcmp(__s1, "rate")
    && cstdlib_strcmp(__s1, "rate_baseline")
    && cstdlib_strcmp(__s1, "pitch_baseline")
    && cstdlib_strcmp(__s1, "ratewpm")
    && cstdlib_strcmp(__s1, "pitch")
    && cstdlib_strcmp(__s1, "waitfactor"))
  {
    return 0;
  }
  int v7 = LH_atoi(a3);

  return synth_bet6_loc_ParamSet(a1, __s1, v7);
}

uint64_t synth_bet6_loc_ParamGetListen(uint64_t a1, unsigned char *a2, signed int a3, signed int a4, unsigned int a5, long long *a6, unsigned int *a7)
{
  if (((paramc_ParamGetInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)a2, a7) & 0x80000000) != 0
     || (a5 = a3, (int)*a7 < a3)
     || (a5 = a4, (int)*a7 > a4))
    && (uint64_t v14 = paramc_ParamSetInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)a2, a5),
        *a7 = a5,
        (v14 & 0x80000000) != 0))
  {
    uint64_t v24 = v14;
    log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v15, v16, v17, v18, "lhError");
  }
  else
  {
    uint64_t v19 = *(void *)(*(void *)(a1 + 8) + 40);
    long long v26 = *a6;
    uint64_t v27 = *((void *)a6 + 2);
    uint64_t v24 = paramc_ListenerAdd(v19, a2, &v26);
    if ((v24 & 0x80000000) != 0) {
      log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v20, v21, v22, v23, "lhError");
    }
  }
  return v24;
}

uint64_t synth_bet6_loc_InitFromParamc(uint64_t a1)
{
  int v3 = 0;
  uint64_t result = paramc_ParamGetInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"volume", &v3);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = synth_bet6_loc_ParamSet(a1, "volume", v3);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = paramc_ParamGetInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"rate", &v3);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = synth_bet6_loc_ParamSet(a1, "rate", v3);
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = paramc_ParamGetInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"rate_baseline", &v3);
          if ((result & 0x80000000) == 0)
          {
            uint64_t result = synth_bet6_loc_ParamSet(a1, "rate_baseline", v3);
            if ((result & 0x80000000) == 0)
            {
              uint64_t result = paramc_ParamGetInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"pitch_baseline", &v3);
              if ((result & 0x80000000) == 0)
              {
                uint64_t result = synth_bet6_loc_ParamSet(a1, "pitch_baseline", v3);
                if ((result & 0x80000000) == 0)
                {
                  uint64_t result = paramc_ParamGetInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"pitch", &v3);
                  if ((result & 0x80000000) == 0)
                  {
                    uint64_t result = synth_bet6_loc_ParamSet(a1, "pitch", v3);
                    if ((result & 0x80000000) == 0)
                    {
                      uint64_t result = paramc_ParamGetInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"waitfactor", &v3);
                      if ((result & 0x80000000) == 0) {
                        return synth_bet6_loc_ParamSet(a1, "waitfactor", v3);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t synth_bet6_loc_ParamSet(uint64_t a1, const char *a2, int a3)
{
  if (cstdlib_strcmp(a2, "audiooutputbufsamples"))
  {
    uint64_t v6 = critsec_Enter(*(void **)(a1 + 16));
    if ((v6 & 0x80000000) == 0)
    {
      if (cstdlib_strcmp(a2, "volume"))
      {
        if (cstdlib_strcmp(a2, "rate_baseline"))
        {
          uint64_t v7 = 2229280783;
          if (!cstdlib_strcmp(a2, "rate"))
          {
            uint64_t v8 = MapProsodyValue_Scaling(50, 100, 400, *(_DWORD *)(a1 + 1052), a3);
            if (!v8) {
              goto LABEL_29;
            }
            int v12 = ((int)v8 + 9999) / (int)v8;
            if (((v12 << 16) - 13107201) < 0xFF50FFFF) {
              goto LABEL_29;
            }
            log_OutText(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 3, 0, (uint64_t)"Set rate %d", v9, v10, v11, v8);
            *(_WORD *)(a1 + 1042) = v12;
            siren_common_synth_SetRate(*(void *)(a1 + 48), (unsigned __int16)v12);
            goto LABEL_17;
          }
          if (!cstdlib_strcmp(a2, "ratewpm"))
          {
            uint64_t v7 = 2229280769;
            goto LABEL_29;
          }
          if (cstdlib_strcmp(a2, "pitch_baseline"))
          {
            if (cstdlib_strcmp(a2, "pitch"))
            {
              if (!cstdlib_strcmp(a2, "waitfactor"))
              {
                if (a3 > 9)
                {
LABEL_29:
                  critsec_Leave(*(void **)(a1 + 16));
                  return v7;
                }
                *(_WORD *)(a1 + 1056) = a3;
              }
            }
            else
            {
              uint64_t v15 = MapProsodyValue_Scaling(50, 100, 200, *(_DWORD *)(a1 + 1048), a3);
              if ((v15 - 201) < 0xFFFFFF69) {
                goto LABEL_29;
              }
              unsigned int v20 = v15;
              log_OutText(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 3, 0, (uint64_t)"Set pitch %d (synth %d)", v16, v17, v18, v15);
              *(_DWORD *)(a1 + 1044) = a3;
              siren_common_synth_SetPitch(*(void *)(a1 + 48), v20);
            }
LABEL_17:
            uint64_t v7 = v6;
            goto LABEL_29;
          }
          if ((a3 - 201) < 0xFFFFFF69) {
            goto LABEL_29;
          }
          unsigned int v22 = 0;
          *(_DWORD *)(a1 + 1048) = a3;
          uint64_t v13 = "pitch";
          paramc_ParamGetInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"pitch", &v22);
          uint64_t v14 = v22;
LABEL_24:
          synth_bet6_loc_ParamSet(a1, v13, v14);
          uint64_t v7 = 0;
          goto LABEL_29;
        }
        if ((a3 - 401) >= 0xFFFFFEA1)
        {
          unsigned int v21 = 0;
          *(_DWORD *)(a1 + 1052) = a3;
          uint64_t v13 = "rate";
          paramc_ParamGetInt(*(void *)(*(void *)(a1 + 8) + 40), (uint64_t)"rate", &v21);
          uint64_t v14 = v21;
          goto LABEL_24;
        }
      }
      else if (a3 <= 0x64)
      {
        *(_WORD *)(a1 + 1040) = a3;
        siren_common_synth_SetVolume(*(void *)(a1 + 48), a3);
        goto LABEL_17;
      }
      uint64_t v7 = 2229280783;
      goto LABEL_29;
    }
  }
  else
  {
    if (a3 <= 0) {
      a3 = *(_DWORD *)(a1 + 1036);
    }
    uint64_t v6 = 0;
    *(_DWORD *)(a1 + 1036) = a3;
  }
  return v6;
}

uint64_t synth_bet6_Process_ST(uint64_t a1, int *a2)
{
  uint64_t v90 = 0;
  uint64_t v91 = 0;
  uint64_t __dst = 0;
  __src = 0;
  uint64_t v86 = 0;
  __uint64_t n = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  *a2 = 1;
  unsigned int v5 = *(_DWORD *)(a1 + 1036);
  unsigned int v6 = *(_DWORD *)(a1 + 1032);
  int v7 = v5 / v6 * v6;
  if (!v6) {
    int v7 = *(_DWORD *)(a1 + 1036);
  }
  if (v5 >= v6) {
    int v8 = v7;
  }
  else {
    int v8 = *(_DWORD *)(a1 + 1032);
  }
  uint64_t v13 = (*(uint64_t (**)(void, void, char *, uint64_t *))(*(void *)(a1 + 56) + 144))(*(void *)(a1 + 904), *(void *)(a1 + 912), (char *)&v86 + 4, &v86);
  if ((v13 & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v9, v10, v11, v12, "lhError");
    return v13;
  }
  HIDWORD(v86) = HIDWORD(v86) / (4 * (unint64_t)*(unsigned int *)(v4 + 9204));
  if (!HIDWORD(v86))
  {
    if (!v86)
    {
      *a2 = 0;
      return v13;
    }
    uint64_t v14 = (*(uint64_t (**)(void, void, void **, char *))(*(void *)(a1 + 56) + 88))(*(void *)(a1 + 888), *(void *)(a1 + 896), &__src, (char *)&__n + 4);
    if ((v14 & 0x80000000) == 0)
    {
      if (!HIDWORD(__n)) {
        return synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 64), *(void *)(a1 + 56));
      }
      uint64_t v14 = (*(uint64_t (**)(void, void, void **))(*(void *)(a1 + 56) + 112))(*(void *)(a1 + 952), *(void *)(a1 + 960), &__dst);
      if ((v14 & 0x80000000) == 0)
      {
        cstdlib_memcpy(__dst, __src, HIDWORD(__n));
        unsigned int v22 = HIDWORD(__n);
        HIDWORD(__n) >>= 5;
        if (v22 >= 0x20)
        {
          uint64_t v23 = 0;
          unint64_t v24 = 0;
          int v25 = *(_DWORD *)(a1 + 1080);
          long long v26 = (char *)__dst;
          do
          {
            uint64_t v27 = &v26[v23];
            *((_DWORD *)v27 + 3) = v25;
            *((_DWORD *)v27 + 4) = 0;
            ++v24;
            v23 += 32;
          }
          while (v24 < HIDWORD(__n));
        }
        else
        {
          uint64_t v23 = 0;
        }
        uint64_t v14 = (*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 56) + 120))(*(void *)(a1 + 952), *(void *)(a1 + 960), v23);
        if ((v14 & 0x80000000) == 0)
        {
          uint64_t v14 = (*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 888), *(void *)(a1 + 896), v23);
          if ((v14 & 0x80000000) == 0) {
            return synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 64), *(void *)(a1 + 56));
          }
        }
      }
    }
LABEL_32:
    uint64_t v13 = v14;
    log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v15, v16, v17, v18, "lhError");
    return v13;
  }
  uint64_t v14 = (*(uint64_t (**)(void, void, _DWORD **, size_t *))(*(void *)(a1 + 56) + 88))(*(void *)(a1 + 904), *(void *)(a1 + 912), &v91, &__n);
  if ((v14 & 0x80000000) != 0) {
    goto LABEL_32;
  }
  uint64_t v14 = (*(uint64_t (**)(void, void, void **, char *))(*(void *)(a1 + 56) + 88))(*(void *)(a1 + 888), *(void *)(a1 + 896), &__src, (char *)&__n + 4);
  if ((v14 & 0x80000000) != 0) {
    goto LABEL_32;
  }
  uint64_t v14 = (*(uint64_t (**)(void, void, uint64_t *, void))(*(void *)(a1 + 56) + 112))(*(void *)(a1 + 968), *(void *)(a1 + 976), &v90, (2 * v8));
  if ((v14 & 0x80000000) != 0) {
    goto LABEL_32;
  }
  if (HIDWORD(__n))
  {
    uint64_t v14 = (*(uint64_t (**)(void, void, void **))(*(void *)(a1 + 56) + 112))(*(void *)(a1 + 952), *(void *)(a1 + 960), &__dst);
    if ((v14 & 0x80000000) != 0) {
      goto LABEL_32;
    }
  }
  uint64_t v19 = critsec_Enter(*(void **)(a1 + 16));
  if ((v19 & 0x80000000) != 0) {
    return v19;
  }
  unsigned int v21 = *(_DWORD *)(a1 + 1060);
  unsigned int v84 = v21;
  unsigned int v85 = v21;
  if (__dst)
  {
    cstdlib_memcpy(__dst, __src, HIDWORD(__n));
    unsigned int v21 = *(_DWORD *)(a1 + 1060);
  }
  HIDWORD(__n) >>= 5;
  if (v21)
  {
    LODWORD(v20) = *(_DWORD *)(a1 + 1116);
  }
  else
  {
    float v29 = v91 + 1;
    LODWORD(v20) = *v91;
    *(_DWORD *)(a1 + 1116) = *v91;
    uint64_t v91 = v29;
  }
  float v30 = 3.0;
  if (*(float *)&v20 >= 3.0)
  {
    uint64_t v83 = 0;
    unsigned int v31 = HIDWORD(v86);
LABEL_53:
    int v37 = siren_common_synth_ProcessStart(*(void *)(a1 + 48), (uint64_t)v91, v31, v90, v8, 0, v20, v30);
    LODWORD(v33) = 0;
    int CurSampleCount = 0;
LABEL_54:
    char v44 = 0;
    while ((v37 & 0x80000000) == 0 && (v44 & 1) == 0)
    {
      if (v85 >= HIDWORD(v86) + v84)
      {
        unsigned int v52 = *(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 56) + 120);
        goto LABEL_76;
      }
      uint64_t v45 = (char *)__dst;
      if (__dst && v33 < HIDWORD(__n))
      {
        uint64_t v46 = 32 * v33;
        unint64_t v33 = v33;
        do
        {
          if (*(_DWORD *)&v45[v46 + 12] > *(_DWORD *)(a1 + 1072)) {
            break;
          }
          switch(*(_DWORD *)&v45[v46])
          {
            case 0x10:
              critsec_Leave(*(void **)(a1 + 16));
              uint64_t v47 = *(void *)(*(void *)(a1 + 8) + 40);
              unsigned int v48 = *(_DWORD *)((char *)__dst + v46 + 24);
              uint64_t v49 = "pitch";
              goto LABEL_67;
            case 0x11:
              critsec_Leave(*(void **)(a1 + 16));
              uint64_t v47 = *(void *)(*(void *)(a1 + 8) + 40);
              unsigned int v48 = *(_DWORD *)((char *)__dst + v46 + 24);
              uint64_t v49 = "timbre";
              goto LABEL_67;
            case 0x12:
              critsec_Leave(*(void **)(a1 + 16));
              uint64_t v47 = *(void *)(*(void *)(a1 + 8) + 40);
              unsigned int v48 = *(_DWORD *)((char *)__dst + v46 + 24);
              uint64_t v49 = "rate";
              goto LABEL_67;
            case 0x18:
              critsec_Leave(*(void **)(a1 + 16));
              uint64_t v47 = *(void *)(*(void *)(a1 + 8) + 40);
              unsigned int v48 = *(_DWORD *)((char *)__dst + v46 + 24);
              uint64_t v49 = "volume";
LABEL_67:
              paramc_ParamSetUInt(v47, (uint64_t)v49, v48);
              critsec_Enter(*(void **)(a1 + 16));
              break;
            default:
              break;
          }
          uint64_t v45 = (char *)__dst;
          uint64_t v50 = (char *)__dst + v46;
          *((_DWORD *)v50 + 3) = *(_DWORD *)(a1 + 1080);
          *((_DWORD *)v50 + 4) = *(_DWORD *)(a1 + 1032)
                               * *((_DWORD *)v50 + 4)
                               * *(unsigned __int16 *)(a1 + 1042)
                               / 0x64;
          ++v33;
          if (!v45) {
            break;
          }
          v46 += 32;
        }
        while (v33 < HIDWORD(__n));
      }
      int v37 = siren_common_synth_Process(*(void *)(a1 + 48), v85 - v84, v85 - v84);
      if (v37 < 0) {
        goto LABEL_50;
      }
      int IsBufferFull = siren_common_synth_GetIsBufferFull(*(void *)(a1 + 48));
      char v44 = 1;
      if (!IsBufferFull)
      {
        ++v85;
        ++*(_DWORD *)(a1 + 1072);
        *(_DWORD *)(a1 + 1080) += siren_common_synth_GetCurSampleCount(*(void *)(a1 + 48)) - CurSampleCount;
        int CurSampleCount = siren_common_synth_GetCurSampleCount(*(void *)(a1 + 48));
        goto LABEL_54;
      }
    }
    unsigned int v52 = *(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 56) + 120);
    if (v37 < 0)
    {
      int v38 = 0;
      uint64_t v53 = 0;
      goto LABEL_77;
    }
LABEL_76:
    uint64_t v53 = 2 * siren_common_synth_GetCurSampleCount(*(void *)(a1 + 48));
    int v38 = 1;
LABEL_77:
    int v39 = v52(*(void *)(a1 + 968), *(void *)(a1 + 976), v53);
    goto LABEL_78;
  }
  unsigned int v31 = HIDWORD(v86);
  if (*(float *)&v20 == 1.0 || *(float *)&v20 == 0.0)
  {
    unsigned int v32 = *(_DWORD *)(*(void *)(a1 + 40) + 9156);
    unsigned int v31 = HIDWORD(v86) - v32;
    HIDWORD(v83) = v32;
    if (HIDWORD(v86) < v32)
    {
      LODWORD(v33) = 0;
      LODWORD(v83) = 0;
      goto LABEL_49;
    }
    HIDWORD(v86) -= v32;
  }
  else
  {
    HIDWORD(v83) = 0;
  }
  BOOL v34 = *(float *)&v20 == 1.0;
  float v30 = 2.0;
  if (*(float *)&v20 == 2.0) {
    BOOL v34 = 1;
  }
  if (v21 || !v34)
  {
    LODWORD(v83) = 0;
    goto LABEL_53;
  }
  unsigned int v35 = *(_DWORD *)(*(void *)(a1 + 40) + 9156);
  BOOL v36 = v31 >= v35;
  v31 -= v35;
  LODWORD(v83) = v35;
  if (v36)
  {
    HIDWORD(v86) = v31;
    v91 += *(_DWORD *)(v4 + 9204) * v35;
    goto LABEL_53;
  }
  LODWORD(v33) = 0;
LABEL_49:
  int v37 = -2065686521;
LABEL_50:
  int v38 = 0;
  int v39 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 56) + 120))(*(void *)(a1 + 968), *(void *)(a1 + 976), 0);
LABEL_78:
  if (v39 < 0)
  {
    int v54 = v39;
    log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v40, v41, v42, v43, "lhError");
    if (v38) {
      int v37 = v54;
    }
  }
  int v55 = 32 * v33;
  if (v33
    && (int v56 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 56) + 120))(*(void *)(a1 + 952), *(void *)(a1 + 960), v55 & ~(v37 >> 31)), v56 < 0))
  {
    int v66 = v56;
    log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v57, v58, v59, v60, "lhError");
    int v65 = 0;
    uint64_t v64 = 0;
    if (v37 >= 0) {
      int v37 = v66;
    }
    unsigned int v61 = *(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 56) + 96);
  }
  else
  {
    unsigned int v61 = *(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 56) + 96);
    if (v37 < 0)
    {
      int v65 = 0;
      uint64_t v64 = 0;
    }
    else
    {
      int v62 = HIDWORD(v83);
      if (v85 != HIDWORD(v86) + v84) {
        int v62 = 0;
      }
      int v63 = (v83 - v84 + v85 + v62) * *(_DWORD *)(v4 + 9204);
      if (!*(_DWORD *)(a1 + 1060)) {
        ++v63;
      }
      uint64_t v64 = (4 * v63);
      int v65 = 1;
    }
  }
  int v67 = v61(*(void *)(a1 + 904), *(void *)(a1 + 912), v64);
  if (v67 < 0)
  {
    int v72 = v67;
    log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v68, v69, v70, v71, "lhError");
    if (v65) {
      int v37 = v72;
    }
  }
  int v73 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 888), *(void *)(a1 + 896), v55 & ~(v37 >> 31));
  if (v73 < 0)
  {
    int v78 = v73;
    log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v74, v75, v76, v77, "lhError");
    if (v37 >= 0) {
      int v37 = v78;
    }
  }
  if (v85 == HIDWORD(v86) + v84) {
    unsigned int v79 = 0;
  }
  else {
    unsigned int v79 = v85;
  }
  if (v85 == HIDWORD(v86) + v84) {
    int v80 = 1;
  }
  else {
    int v80 = 2;
  }
  *(_DWORD *)(a1 + 1060) = v79;
  *a2 = v80;
  if ((v37 & 0x80000000) == 0) {
    int v37 = siren_common_synth_ProcessEnd(*(void *)(a1 + 48));
  }
  unsigned int v81 = critsec_Leave(*(void **)(a1 + 16));
  if (v37 >= 0) {
    return v81;
  }
  else {
    return v37;
  }
}

uint64_t end_cur_stream_MT(uint64_t a1, const void **a2, void **a3, unsigned int *a4, unsigned int *a5)
{
  if (*a4)
  {
    if (((*(uint64_t (**)(void, void, const void **))(*(void *)(a1 + 56) + 88))(*(void *)(a1 + 888), *(void *)(a1 + 896), a2) & 0x80000000) != 0|| ((*(uint64_t (**)(void, void, void **, void))(*(void *)(a1 + 56) + 112))(*(void *)(a1 + 952), *(void *)(a1 + 960), a3, *a4) & 0x80000000) != 0)
    {
      return log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v10, v11, v12, v13, "lhError");
    }
    cstdlib_memcpy(*a3, *a2, *a4);
    *a4 >>= 5;
    *a5 = 0;
    if (*a4)
    {
      unsigned int v14 = 0;
      uint64_t v15 = *a3;
      do
      {
        v15[8 * v14 + 3] = *(_DWORD *)(a1 + 1080);
        v15[8 * *a5 + 4] = 0;
        unsigned int v14 = *a5 + 1;
        *a5 = v14;
      }
      while (v14 < *a4);
      uint64_t v16 = 32 * v14;
    }
    else
    {
      uint64_t v16 = 0;
    }
    if (((*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 56) + 120))(*(void *)(a1 + 952), *(void *)(a1 + 960), v16) & 0x80000000) != 0|| ((*(uint64_t (**)(void, void, void))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 888), *(void *)(a1 + 896), 32 * *a5) & 0x80000000) != 0)
    {
      return log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v10, v11, v12, v13, "lhError");
    }
  }
  uint64_t v17 = *(void *)(a1 + 56);

  return synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 64), v17);
}

void *synth_bet6_ProcessReset(void *result)
{
  uint64_t v1 = result;
  *((_DWORD *)result + 272) = 0;
  *(void *)((char *)result + 1068) = 0;
  *(void *)((char *)result + 1076) = 0;
  *(void *)((char *)result + 1060) = 0;
  uint64_t v2 = result[144];
  if (v2)
  {
    uint64_t result = heap_Free(*(void **)(result[1] + 8), v2);
    v1[144] = 0;
    *((_DWORD *)v1 + 276) = 0;
  }
  uint64_t v3 = v1[145];
  if (v3)
  {
    uint64_t result = heap_Free(*(void **)(v1[1] + 8), v3);
    v1[145] = 0;
    *((_DWORD *)v1 + 278) = 0;
  }
  uint64_t v4 = v1[146];
  if (v4)
  {
    unint64_t v5 = *((unsigned int *)v1 + 271);
    if (v5)
    {
      uint64_t v6 = 0;
      for (unint64_t i = 0; i < v5; ++i)
      {
        uint64_t v8 = v1[146];
        int v9 = *(_DWORD *)(v8 + v6);
        if (v9 == 29 || v9 == 26)
        {
          heap_Free(*(void **)(v1[1] + 8), *(void *)(v8 + v6 + 24));
          unint64_t v5 = *((unsigned int *)v1 + 271);
        }
        v6 += 32;
      }
      uint64_t v4 = v1[146];
    }
    uint64_t result = heap_Free(*(void **)(v1[1] + 8), v4);
    v1[146] = 0;
    *((_DWORD *)v1 + 277) = 0;
  }
  *((_DWORD *)v1 + 271) = 0;
  return result;
}

uint64_t synth_bet6_loc_cache_markers(uint64_t a1, unsigned int a2, const void *a3)
{
  uint64_t v6 = 2229280778;
  uint64_t v7 = *(void *)(a1 + 1168);
  if (v7)
  {
    size_t v8 = 32 * a2;
    uint64_t v9 = *(unsigned int *)(a1 + 1084);
    uint64_t v10 = *(unsigned int *)(a1 + 1108);
    if (v8 > v10 - 32 * v9)
    {
      uint64_t v11 = 32 * v9;
      do
        uint64_t v10 = (2 * v10);
      while (v8 > v10 - v11);
      *(_DWORD *)(a1 + 1108) = v10;
    }
    uint64_t v12 = heap_Realloc(*(uint64_t **)(*(void *)(a1 + 8) + 8), v7, v10);
    if (!v12) {
      return v6;
    }
    uint64_t v13 = a2;
    *(void *)(a1 + 1168) = v12;
  }
  else
  {
    uint64_t v13 = a2;
    uint64_t v12 = heap_Calloc(*(void **)(*(void *)(a1 + 8) + 8), a2, 32);
    *(void *)(a1 + 1168) = v12;
    if (!v12) {
      return v6;
    }
    *(_DWORD *)(a1 + 1108) = 32 * a2;
    size_t v8 = 32 * a2;
  }
  cstdlib_memcpy((void *)(v12 + 32 * *(unsigned int *)(a1 + 1084)), a3, v8);
  uint64_t v14 = *(unsigned int *)(a1 + 1084);
  if (a2)
  {
    uint64_t v15 = (const char **)(*(void *)(a1 + 1168) + 32 * v14 + 24);
    do
    {
      int v16 = *((_DWORD *)v15 - 6);
      if (v16 == 29 || v16 == 26)
      {
        uint64_t v18 = *v15;
        uint64_t v19 = *(void **)(*(void *)(a1 + 8) + 8);
        int v20 = cstdlib_strlen(*v15);
        unsigned int v21 = (char *)heap_Calloc(v19, (v20 + 1), 1);
        *uint64_t v15 = v21;
        if (!v21) {
          return v6;
        }
        cstdlib_strcpy(v21, v18);
      }
      v15 += 4;
      --v13;
    }
    while (v13);
    LODWORD(v14) = *(_DWORD *)(a1 + 1084);
  }
  uint64_t v6 = 0;
  *(_DWORD *)(a1 + 1084) = v14 + a2;
  return v6;
}

uint64_t synth_bet6_loc_Postprocess_sonic(uint64_t a1, uint64_t a2, int a3, int a4, unsigned int *a5, unsigned int a6, float a7)
{
  if (!a4) {
    return 0;
  }
  uint64_t v10 = a1;
  uint64_t v11 = 2229280778;
  if (a6)
  {
    unsigned int v13 = 0;
    uint64_t v14 = a6;
    uint64_t v15 = a6;
    int v16 = a5;
    do
    {
      unsigned int v17 = *v16;
      v16 += 8;
      int v18 = (1 << v17) & 0x1050000;
      if (v17 <= 0x18 && v18 != 0) {
        ++v13;
      }
      --v15;
    }
    while (v15);
    if (v13)
    {
      uint64_t v20 = heap_Alloc(*(void *)(*(void *)(a1 + 8) + 8), 12 * v13);
      if (!v20) {
        return v11;
      }
      uint64_t v21 = v20;
      unsigned int v22 = 0;
      int v23 = *(_DWORD *)(v10 + 1080);
      unint64_t v24 = a5 + 3;
      while (1)
      {
        int v25 = *(v24 - 3);
        if (v25 == 16) {
          break;
        }
        if (v25 == 24)
        {
          int v26 = 2;
          goto LABEL_19;
        }
        if (v25 == 18)
        {
          int v26 = 0;
LABEL_19:
          uint64_t v27 = v20 + 12 * v22;
          *(_DWORD *)uint64_t v27 = v26;
          *(_DWORD *)(v27 + 8) = *v24 - v23;
          *(float *)(v27 + 4) = (float)v24[3] / 100.0;
          ++v22;
        }
        v24 += 8;
        if (!--v14)
        {
          uint64_t v10 = a1;
          goto LABEL_25;
        }
      }
      int v26 = 1;
      goto LABEL_19;
    }
  }
  else
  {
    unsigned int v13 = 0;
  }
  uint64_t v21 = 0;
LABEL_25:
  uint64_t v28 = v13 + 1;
  float v29 = (_DWORD *)heap_Alloc(*(void *)(*(void *)(v10 + 8) + 8), 20 * v28);
  uint64_t v34 = (uint64_t)v29;
  if (!v29)
  {
    log_OutPublic(*(void *)(*(void *)(v10 + 8) + 32), (uint64_t)"SYNTH_BET6", 73000, 0, v30, v31, v32, v33, v95);
    char v44 = 0;
    goto LABEL_76;
  }
  int v98 = a4;
  int v96 = a3;
  if (v28)
  {
    uint64_t v35 = 0;
    int v36 = *(_DWORD *)(v10 + 1100);
    int v37 = *(_DWORD *)(v10 + 1096);
    int v38 = *(_DWORD *)(v10 + 1092);
    uint64_t v39 = 12 * v13;
    uint64_t v40 = v29 + 2;
    unsigned int v41 = v13;
    do
    {
      if (v35) {
        *(v40 - 2) = *(_DWORD *)(v21 + v35 - 4);
      }
      else {
        _DWORD *v29 = 0;
      }
      int v42 = a4;
      if (v39 != v35) {
        int v42 = *(_DWORD *)(v21 + v35 + 8);
      }
      *(v40 - 1) = v42;
      v40[1] = v36;
      v40[2] = v38;
      *uint64_t v40 = v37;
      if (v21 && v39 != v35)
      {
        int v43 = *(_DWORD *)(v21 + v35);
        if (v43)
        {
          if (v43 == 2)
          {
            int v36 = *(_DWORD *)(v21 + v35 + 4);
          }
          else if (v43 == 1)
          {
            int v37 = *(_DWORD *)(v21 + v35 + 4);
          }
        }
        else
        {
          int v38 = *(_DWORD *)(v21 + v35 + 4);
        }
      }
      v35 += 12;
      v40 += 5;
    }
    while (12 * v28 != v35);
  }
  else
  {
    unsigned int v41 = -1;
  }
  uint64_t v45 = &v29[5 * v41];
  *(_DWORD *)(v10 + 1092) = v45[4];
  *(void *)(v10 + 1096) = *((void *)v45 + 1);
  char v44 = (_DWORD *)heap_Alloc(*(void *)(*(void *)(v10 + 8) + 8), 4);
  uint64_t v50 = *(void *)(v10 + 8);
  if (!v44)
  {
    log_OutPublic(*(void *)(v50 + 32), (uint64_t)"SYNTH_BET6", 73000, 0, v46, v47, v48, v49, v95);
LABEL_76:
    uint64_t v56 = 0;
    if (!v13) {
      goto LABEL_103;
    }
    goto LABEL_101;
  }
  uint64_t v51 = heap_Alloc(*(void *)(v50 + 8), 2 * (4 * a4));
  uint64_t v56 = v51;
  if (!v51) {
    goto LABEL_95;
  }
  if (!v28)
  {
    uint64_t v58 = 0;
    goto LABEL_79;
  }
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  uint64_t v97 = v34;
  uint64_t v99 = v51;
  do
  {
    uint64_t v59 = (unsigned int *)(v34 + 20 * v57);
    int v105 = v59[1] - *v59;
    if (!v105) {
      goto LABEL_73;
    }
    uint64_t v101 = v57;
    unsigned int v102 = v58;
    *char v44 = 0;
    uint64_t v60 = *v59;
    unsigned int v61 = (float *)(v34 + 20 * v57);
    float v62 = v61[3];
    float v63 = v61[4];
    float v64 = v61[2];
    Streauint64_t m = (uint64_t *)sonicCreateStream(*(void *)(v10 + 8), 22050, 1u);
    uint64_t v70 = *(void *)(v10 + 8);
    if (!Stream || (v71 = heap_Alloc(*(void *)(v70 + 8), 4096), uint64_t v70 = *(void *)(v10 + 8), !v71))
    {
      log_OutPublic(*(void *)(v70 + 32), (uint64_t)"SYNTH_BET6", 73000, 0, v65, v66, v67, v68, v95);
      sonicDestroyStream(*(void **)(v10 + 8), Stream);
      if (!v13) {
        goto LABEL_103;
      }
      goto LABEL_101;
    }
    int v72 = (void *)v71;
    uint64_t v73 = heap_Alloc(*(void *)(v70 + 8), 4096);
    if (!v73)
    {
      log_OutPublic(*(void *)(*(void *)(v10 + 8) + 32), (uint64_t)"SYNTH_BET6", 73000, 0, v74, v75, v76, v77, v95);
      uint64_t v84 = 2229280778;
      goto LABEL_71;
    }
    int v78 = (void *)v73;
    uint64_t v103 = a2 + 2 * v60;
    unsigned int v79 = (char *)(v99 + 2 * v102);
    sonicSetSpeed((uint64_t)Stream, v63);
    sonicSetPitch((uint64_t)Stream, v64);
    sonicSetRate((uint64_t)Stream, 1.0);
    sonicSetVolume((uint64_t)Stream, v62);
    sonicSetChordPitch((uint64_t)Stream, 0);
    sonicSetQuality((uint64_t)Stream, 0);
    int v80 = 0;
    while (v105 > v80)
    {
      signed int v81 = v105 - v80 >= 2048 ? 2048 : v105 - v80;
      cstdlib_memcpy(v78, (const void *)(v103 + 2 * v80), 2 * v81);
      if (!v81) {
        break;
      }
      if (!sonicWriteShortToStream(*(void *)(v10 + 8), (uint64_t)Stream, v78, v81)) {
        goto LABEL_69;
      }
LABEL_63:
      ShortFromStreauint64_t m = sonicReadShortFromStream((uint64_t)Stream, v72, 2048);
      if (ShortFromStream >= 1)
      {
        for (int i = ShortFromStream; i > 0; int i = sonicReadShortFromStream((uint64_t)Stream, v72, 2048))
        {
          *v44 += i;
          cstdlib_memcpy(v79, v72, 2 * i);
          v79 += 2 * i;
        }
      }
      v80 += v81;
      uint64_t v10 = a1;
      if (v81 <= 0)
      {
        uint64_t v84 = 0;
        uint64_t v11 = 2229280778;
        goto LABEL_70;
      }
    }
    if (sonicFlushStream(*(void *)(v10 + 8), (uint64_t)Stream))
    {
      signed int v81 = 0;
      goto LABEL_63;
    }
LABEL_69:
    uint64_t v11 = 2229280778;
    uint64_t v84 = 2229280768;
LABEL_70:
    uint64_t v34 = v97;
    heap_Free(*(void **)(*(void *)(v10 + 8) + 8), (uint64_t)v78);
LABEL_71:
    uint64_t v56 = v99;
    heap_Free(*(void **)(*(void *)(v10 + 8) + 8), (uint64_t)v72);
    sonicDestroyStream(*(void **)(v10 + 8), Stream);
    if ((v84 & 0x80000000) != 0)
    {
      uint64_t v11 = v84;
      if (!v13) {
        goto LABEL_103;
      }
      goto LABEL_101;
    }
    uint64_t v57 = v101;
    uint64_t v58 = *v44 + v102;
    uint64_t v28 = v13 + 1;
LABEL_73:
    ++v57;
  }
  while (v57 != v28);
LABEL_79:
  uint64_t v85 = *(void *)(v10 + 1160);
  if (v85)
  {
    unint64_t v86 = 2 * v58;
    uint64_t v87 = *(unsigned int *)(v10 + 1088);
    uint64_t v88 = *(unsigned int *)(v10 + 1112);
    if (v86 > v88 - 2 * v87)
    {
      uint64_t v89 = 2 * v87;
      do
        uint64_t v88 = (2 * v88);
      while (v86 > v88 - v89);
      *(_DWORD *)(v10 + 1112) = v88;
    }
    uint64_t v90 = heap_Realloc(*(uint64_t **)(*(void *)(v10 + 8) + 8), v85, v88);
    if (v90)
    {
      *(void *)(v10 + 1160) = v90;
      goto LABEL_90;
    }
LABEL_95:
    log_OutPublic(*(void *)(*(void *)(v10 + 8) + 32), (uint64_t)"SYNTH_BET6", 73000, 0, v52, v53, v54, v55, v95);
    if (!v13) {
      goto LABEL_103;
    }
LABEL_101:
    if (v21) {
      heap_Free(*(void **)(*(void *)(v10 + 8) + 8), v21);
    }
    goto LABEL_103;
  }
  uint64_t v90 = heap_Calloc(*(void **)(*(void *)(v10 + 8) + 8), v58, 2);
  *(void *)(v10 + 1160) = v90;
  if (!v90) {
    goto LABEL_95;
  }
  *(_DWORD *)(v10 + 1112) = 2 * v58;
LABEL_90:
  uint64_t v91 = *(unsigned int *)(v10 + 1120);
  if (v58 < v91)
  {
    *(_DWORD *)(v10 + 1120) = v58;
    uint64_t v91 = v58;
  }
  uint64_t v92 = v90 + 2 * *(unsigned int *)(v10 + 1088);
  overlapAdd(v91, 1, v92, v92, v56);
  cstdlib_memcpy((void *)(*(void *)(v10 + 1160) + 2 * *(unsigned int *)(v10 + 1088) + 2 * *(unsigned int *)(v10 + 1120)), (const void *)(v56 + 2 * *(unsigned int *)(v10 + 1120)), 2 * (v58 - *(_DWORD *)(v10 + 1120)));
  if (a7 == 0.0 || a7 == 1.0) {
    unsigned int v93 = (float)((float)(v98 - v96) / *(float *)(v10 + 1092));
  }
  else {
    unsigned int v93 = 0;
  }
  uint64_t v11 = 0;
  *(_DWORD *)(v10 + 1120) = v93;
  *(_DWORD *)(v10 + 1088) += v58 - v93;
  if (v13) {
    goto LABEL_101;
  }
LABEL_103:
  if (v34) {
    heap_Free(*(void **)(*(void *)(v10 + 8) + 8), v34);
  }
  if (v44) {
    heap_Free(*(void **)(*(void *)(v10 + 8) + 8), (uint64_t)v44);
  }
  if (v56) {
    heap_Free(*(void **)(*(void *)(v10 + 8) + 8), v56);
  }
  return v11;
}

uint64_t synth_bet6_loc_adjust_markers(uint64_t result, unsigned int a2, uint64_t a3, float a4)
{
  int v12 = *(_DWORD *)(result + 1080);
  if (a2 && a3)
  {
    uint64_t v6 = result;
    uint64_t v7 = -(uint64_t)a2;
    if (a4 != 1.0) {
      uint64_t result = adjust_markers_pos_by_rate(*(void *)(result + 1168) + 32 * *(unsigned int *)(result + 1084) - 32 * a2, a2, *(_DWORD *)(result + 1064), &v12, a4);
    }
    uint64_t v8 = a2;
    int v9 = -a2;
    uint64_t v10 = 32 * v7 + 32;
    uint64_t v11 = (_DWORD *)(a3 + 16);
    do
    {
      if (*(v11 - 4) == 18) {
        uint64_t result = adjust_markers_pos_by_rate(*(void *)(v6 + 1168) + 32 * *(unsigned int *)(v6 + 1084) + v10, (int)v8 - 1, *(_DWORD *)(*(void *)(v6 + 1168) + 32 * (v9 + *(_DWORD *)(v6 + 1084)) + 12), &v12, (float)*(unsigned int *)(*(void *)(v6 + 1168)+ 32 * (v9 + *(_DWORD *)(v6 + 1084))+ 24)/ 100.0);
      }
      else {
        int v12 = *v11 + *(v11 - 1);
      }
      ++v9;
      v10 += 32;
      v11 += 8;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t synth_bet6_loc_write_markers(uint64_t a1, unsigned int a2, void *a3, int a4)
{
  unsigned int v4 = a2;
  uint64_t __dst = a3;
  uint64_t v6 = *(unsigned int *)(a1 + 1068);
  uint64_t v7 = *(unsigned int *)(a1 + 1084);
  if (v6 < v7)
  {
    unsigned int v8 = *(_DWORD *)(a1 + 1064);
    int v9 = (unsigned int *)(*(void *)(a1 + 1168) + 32 * v6 + 12);
    int v10 = *(_DWORD *)(a1 + 1068);
    while (1)
    {
      unsigned int v11 = *v9;
      v9 += 8;
      if (v11 > v8) {
        break;
      }
      ++v4;
      if (v7 == ++v10)
      {
        unsigned int v4 = v7 + a2 - v6;
        int v10 = *(_DWORD *)(a1 + 1084);
        break;
      }
    }
    if (*(_DWORD *)(a1 + 1088) == v8)
    {
      unsigned int v4 = v4 - v10 + v7;
      int v12 = (unsigned int *)(*(void *)(a1 + 1168) + 32 * v6 + 12);
      uint64_t v13 = v7 - v6;
      do
      {
        unsigned int v14 = *v12;
        if (*v12 >= v8) {
          unsigned int v14 = v8 - 1;
        }
        *int v12 = v14 + a4;
        v12 += 8;
        --v13;
      }
      while (v13);
    }
    if (v4) {
      goto LABEL_12;
    }
LABEL_19:
    uint64_t v19 = 0;
    goto LABEL_20;
  }
  unsigned int v26 = a2 - v6 + v7;
  if (*(_DWORD *)(a1 + 1088) == *(_DWORD *)(a1 + 1064)) {
    unsigned int v4 = v26;
  }
  else {
    unsigned int v4 = a2;
  }
  if (!v4) {
    goto LABEL_19;
  }
LABEL_12:
  uint64_t v19 = (*(uint64_t (**)(void, void, void **, uint64_t))(*(void *)(a1 + 56) + 112))(*(void *)(a1 + 952), *(void *)(a1 + 960), &__dst, 32 * v4);
  if ((v19 & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v15, v16, v17, v18, "lhError");
    return v19;
  }
  cstdlib_memcpy(__dst, (const void *)(*(void *)(a1 + 1168) + 32 * *(unsigned int *)(a1 + 1068)), 32 * v4);
  uint64_t v20 = (*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 56) + 120))(*(void *)(a1 + 952), *(void *)(a1 + 960), 32 * v4);
  if ((v20 & 0x80000000) != 0)
  {
    uint64_t v25 = v20;
    log_OutPublic(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)"SYNTH_BET6", 73001, (uint64_t)"%s%x", v21, v22, v23, v24, "lhError");
    uint64_t v19 = v25;
  }
LABEL_20:
  *(_DWORD *)(a1 + 1068) += v4;
  return v19;
}

uint64_t adjust_markers_pos_by_rate(uint64_t result, unsigned int a2, int a3, _DWORD *a4, float a5)
{
  if (a2)
  {
    uint64_t v5 = a2 - 1;
    uint64_t v6 = (unsigned int *)(result + 16);
    do
    {
      uint64_t v7 = v5;
      int v8 = *(v6 - 1);
      *(v6 - 1) = (float)((float)(v8 - *a4) / a5) + a3;
      *uint64_t v6 = (float)((float)*v6 / a5);
      if (*(v6 - 4) == 18) {
        break;
      }
      --v5;
      v6 += 8;
    }
    while (v7);
  }
  else
  {
    int v8 = 0;
  }
  *a4 = v8;
  return result;
}

uint64_t synth_bet6_loc_InsertPause(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4, unsigned int *a5, _DWORD *a6, unsigned int a7, unsigned int a8, float a9)
{
  uint64_t v15 = *(void *)(a1 + 40);
  if (a4)
  {
    uint64_t v16 = 0;
    uint64_t v17 = (unsigned int *)(a3 + 12);
    while (1)
    {
      if (*(v17 - 3) == 8)
      {
        unsigned int v19 = *(_DWORD *)(v15 + 16) * v17[3];
        if (v19 >= 0x3E8)
        {
          uint64_t result = insert_pause(a1, a2, a3, a4, a5, a6, v19 / 0x3E8, *v17 - *(_DWORD *)(a1 + 1080), *v17, v16, 0);
          if (result) {
            break;
          }
        }
      }
      v17 += 8;
      if (a4 == ++v16) {
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    BOOL v22 = a9 == 5.0 || a9 == 6.0 || a9 == 3.0;
    if (!v22
      || (unsigned int v23 = 200 * *(unsigned __int16 *)(a1 + 1056) * *(_DWORD *)(v15 + 16), v23 < 0x3E8)
      || (uint64_t result = insert_pause(a1, a2, a3, a4, a5, a6, v23 / 0x3E8, *a5, *a5 + *(_DWORD *)(a1 + 1080), a4, 0),
          !result))
    {
      uint64_t result = 2229280783;
      if (a7)
      {
        if (a7 > 0x3E8) {
          return result;
        }
        uint64_t result = insert_pause(a1, a2, a3, a4, a5, a6, *(_DWORD *)(v15 + 16) * a7 / 0x3E8, *a5, *(_DWORD *)(a1 + 1080) + *a5, a4, 1);
        if (!a8 || result) {
          return result;
        }
      }
      else if (!a8)
      {
        return 0;
      }
      uint64_t result = 2229280783;
      if (a8 <= 0x12C) {
        return insert_pause(a1, a2, a3, a4, a5, a6, 0, *a5, *(_DWORD *)(a1 + 1080) + *a5, a4, 1);
      }
    }
  }
  return result;
}

uint64_t insert_pause(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4, _DWORD *a5, _DWORD *a6, unsigned int a7, unsigned int a8, unsigned int a9, unsigned int a10, int a11)
{
  unsigned int v18 = *(_DWORD *)(a1 + 1036);
  for (unsigned int i = *a6 + a7; v18 < i; unsigned int i = *a6 + a7)
  {
    v18 *= 2;
    *(_DWORD *)(a1 + 1036) = v18;
  }
  uint64_t v20 = heap_Realloc(*(uint64_t **)(*(void *)(a1 + 8) + 8), *a2, 2 * v18);
  if (!v20) {
    return 2229280778;
  }
  *a2 = v20;
  if (*a6 <= a8)
  {
    uint64_t v21 = (void *)(v20 + 2 * *a5);
  }
  else
  {
    cstdlib_memmove((void *)(v20 + 2 * a8 + 2 * a7), (const void *)(v20 + 2 * a8), 2 * (*a6 - a8));
    uint64_t v21 = (void *)(*a2 + 2 * a8);
  }
  cstdlib_memset(v21, 0, 2 * a7);
  uint64_t result = 0;
  *a5 += a7;
  *a6 += a7;
  if (a4 && a11 == 1)
  {
    uint64_t v23 = a10;
    uint64_t v24 = a4;
    uint64_t v25 = (unsigned int *)(a3 + 12);
    do
    {
      if (v23)
      {
        if (*v25 >= a9) {
          *v25 += a7;
        }
      }
      --v23;
      v25 += 8;
      --v24;
    }
    while (v24);
    return 0;
  }
  return result;
}

uint64_t new_siren_mrcc_struct_size()
{
  return 312;
}

uint64_t new_siren_mrcc_synth_Init(uint64_t a1)
{
  uint64_t Rsrc = siren_common_synth_GetRsrc(a1);
  uint64_t Voice = siren_common_synth_GetVoice(a1);
  uint64_t v4 = heap_Calloc(*(void **)(Rsrc + 8), 1, 312);
  if (!v4) {
    return 10;
  }
  uint64_t v5 = v4;
  RccSyn__deinit_Synthesis(v4);
  *(void *)(v5 + 272) = 0;
  if (RccSyn__init_Synthesis(Rsrc, v5, (_DWORD *)(Voice + 7688)))
  {
    uint64_t MrccInfo = siren_common_synth_GetMrccInfo(a1);
    if (MrccInfo) {
      RccSyn__deinit_Synthesis(MrccInfo);
    }
  }

  return siren_common_synth_SetMrccInfo(a1, v5);
}

uint64_t new_siren_mrcc_synth_DeInit(uint64_t a1)
{
  uint64_t MrccInfo = siren_common_synth_GetMrccInfo(a1);
  if (MrccInfo) {
    RccSyn__deinit_Synthesis(MrccInfo);
  }
  return 0;
}

uint64_t new_siren_mrcc_synth_Reset(uint64_t a1)
{
  uint64_t Rsrc = siren_common_synth_GetRsrc(a1);
  uint64_t Voice = siren_common_synth_GetVoice(a1);
  uint64_t MrccInfo = siren_common_synth_GetMrccInfo(a1);
  if (MrccInfo
    && (uint64_t v5 = MrccInfo,
        RccSyn__deinit_Synthesis(MrccInfo),
        *(void *)(v5 + 8) = Voice + 7800,
        *(void *)(v5 + 272) = 0,
        (int inited = RccSyn__init_Synthesis(Rsrc, v5, (_DWORD *)(Voice + 7688))) != 0))
  {
    return inited | 0x84E02000;
  }
  else
  {
    return 0;
  }
}

uint64_t new_siren_mrcc_synth_ProcessStart(uint64_t a1)
{
  uint64_t v2 = 2229280778;
  uint64_t MrccInfo = (void *)siren_common_synth_GetMrccInfo(a1);
  uint64_t Voice = siren_common_synth_GetVoice(a1);
  uint64_t Rsrc = siren_common_synth_GetRsrc(a1);
  unsigned int FramesCount = siren_common_synth_GetFramesCount(a1);
  if (!a1) {
    return 2229280775;
  }
  unsigned int v7 = FramesCount;
  if (!FramesCount) {
    return 0;
  }
  uint64_t v8 = heap_Alloc(*(void *)(Rsrc + 8), 4 * FramesCount);
  MrccInfo[36] = v8;
  if (v8)
  {
    uint64_t v9 = heap_Alloc(*(void *)(Rsrc + 8), 4 * v7);
    MrccInfo[37] = v9;
    if (v9)
    {
      uint64_t v10 = heap_Alloc(*(void *)(Rsrc + 8), 4 * (v7 + v7 * *(_DWORD *)(Voice + 24)));
      MrccInfo[38] = v10;
      if (v10) {
        return 0;
      }
    }
    uint64_t v11 = MrccInfo[36];
    if (v11) {
      heap_Free(*(void **)(Rsrc + 8), v11);
    }
  }
  uint64_t v12 = MrccInfo[37];
  if (v12) {
    heap_Free(*(void **)(Rsrc + 8), v12);
  }
  uint64_t v13 = MrccInfo[38];
  if (v13) {
    heap_Free(*(void **)(Rsrc + 8), v13);
  }
  return v2;
}

uint64_t new_siren_mrcc_synth_Process(uint64_t a1, int a2, unsigned int a3)
{
  LODWORD(v4) = a2;
  uint64_t v97 = *MEMORY[0x263EF8340];
  int RatePct = siren_common_synth_GetRatePct(a1);
  int FrameSamples = siren_common_synth_GetFrameSamples(a1);
  unsigned int FramesCount = siren_common_synth_GetFramesCount(a1);
  unsigned int BufSamplesCount = siren_common_synth_GetBufSamplesCount(a1);
  uint64_t LeftSamplesCount = siren_common_synth_GetLeftSamplesCount(a1);
  uint64_t Rsrc = siren_common_synth_GetRsrc(a1);
  LeftAcousticBuffer = (const void *)siren_common_synth_GetLeftAcousticBuffer(a1);
  uint64_t Voice = siren_common_synth_GetVoice(a1);
  uint64_t Frames = siren_common_synth_GetFrames(a1);
  PcmBuffer = (void *)siren_common_synth_GetPcmBuffer(a1);
  LeftPcmBuffer = (const void *)siren_common_synth_GetLeftPcmBuffer(a1);
  uint64_t result = 7;
  if (a3 < v4 || !a1 || FramesCount <= v4 || FramesCount <= a3) {
    return result;
  }
  uint64_t v87 = 0;
  uint64_t v14 = a3 + 1;
  __uint64_t n = 2 * LeftSamplesCount;
  unsigned int v85 = FrameSamples * RatePct / 0x64u;
  unint64_t v4 = v4;
  float v15 = 0.0;
  uint64_t v86 = LeftSamplesCount;
  float v16 = 0.0;
  float v17 = 0.0;
  unsigned int v82 = BufSamplesCount;
  uint64_t v80 = Rsrc;
  uint64_t v81 = LeftSamplesCount;
  uint64_t v78 = v14;
  unsigned int v79 = LeftAcousticBuffer;
  while (LeftSamplesCount)
  {
    if (BufSamplesCount < LeftSamplesCount)
    {
      int Data = 18;
      return Data | 0x84E02000;
    }
    if (cstdlib_memcmp(LeftAcousticBuffer, (const void *)(Frames + 4 * (*(_DWORD *)(Voice + 9204) * v4)), 4 * *(unsigned int *)(Voice + 9204)))
    {
      log_OutText(*(void *)(Rsrc + 32), (uint64_t)"SYNTH_BET6", 1, 0, (uint64_t)"Disregard leftover buffer for current frame (%d samples)", v18, v19, v20, v86);
    }
    else
    {
      cstdlib_memcpy(PcmBuffer, LeftPcmBuffer, __n);
      Curunsigned int FrameCount = siren_common_synth_GetCurFrameCount(a1);
      int Data = siren_common_synth_SetCurFrameCount(a1, CurFrameCount + 1);
      if (Data) {
        return Data | 0x84E02000;
      }
      int CurSampleCount = siren_common_synth_GetCurSampleCount(a1);
      int Data = siren_common_synth_SetCurSampleCount(a1, CurSampleCount + (int)LeftSamplesCount);
      if (Data) {
        return Data | 0x84E02000;
      }
      log_OutText(*(void *)(Rsrc + 32), (uint64_t)"SYNTH_BET6", 3, 0, (uint64_t)"Leftover buffer match current frame (%d samples)", v41, v42, v43, LeftSamplesCount);
    }
    int Data = siren_common_synth_SetLeftSamplesCount(a1, 0);
    if (Data) {
      return Data | 0x84E02000;
    }
LABEL_49:
    if (++v4 == v14) {
      return 0;
    }
  }
  if (siren_common_synth_GetCurSampleCount(a1) + v85 <= BufSamplesCount)
  {
    unsigned int v21 = siren_common_synth_GetFramesCount(a1);
    uint64_t v22 = siren_common_synth_GetVoice(a1);
    uint64_t v23 = siren_common_synth_GetFrames(a1);
    if (v4 < v21)
    {
      uint64_t v24 = v23 + 4 * (*(_DWORD *)(v22 + 9204) * v4);
      int v25 = *(_DWORD *)(v22 + 24);
      float v17 = *(float *)(v24 + 4 * (v25 + 1));
      float v16 = *(float *)(v24 + 4 * (v25 + 2));
      uint64_t v87 = (float *)v24;
      float v15 = *(float *)(v24 + 4 * (v25 + 3));
    }
    uint64_t MrccInfo = siren_common_synth_GetMrccInfo(a1);
    uint64_t v27 = siren_common_synth_GetVoice(a1);
    int v28 = *(_DWORD *)(MrccInfo + 276);
    int v29 = *(_DWORD *)(v27 + 24);
    if (v15 <= 0.5)
    {
      int v31 = 0;
    }
    else
    {
      *(_WORD *)int v96 = 0;
      unsigned int v30 = exp_S7_25_0(2 * vcvts_n_s32_f32(v17, 0x18uLL), v96);
      int v31 = (int)((v30 >> (24 - v96[0])) * *(_DWORD *)(MrccInfo + 280)) / 100;
      unsigned int v32 = exp_S7_25_0(2 * vcvts_n_s32_f32(v16 * 1.25, 0x18uLL), v96);
      uint64_t v33 = *(_DWORD **)(MrccInfo + 8);
      if (!v33) {
        goto LABEL_26;
      }
      signed int v34 = v32 >> ~*(__int16 *)v96;
      if (v34)
      {
        int v35 = v33[1];
        BOOL v36 = __OFSUB__(v34, v35);
        int v37 = v34 - v35;
        if (v37 < 0 != v36)
        {
          LODWORD(v33) = v33[3];
        }
        else if (v33[2] >= v34)
        {
          LODWORD(v33) = v33[3] + *v33 * v37;
        }
        else
        {
          LODWORD(v33) = v33[4];
        }
LABEL_26:
        uint64_t v44 = (v29 + 1);
        uint64_t v45 = *(void *)(MrccInfo + 304);
        if (v28)
        {
          if ((v29 & 0x80000000) == 0)
          {
            uint64_t v46 = (_DWORD *)(v45 + 4 * (v4 * v44));
            uint64_t v47 = v87;
            do
            {
              float v48 = *v47++;
              *v46++ = vcvts_n_s32_f32(v48, 0x18uLL);
              --v44;
            }
            while (v44);
          }
        }
        else if ((v29 & 0x80000000) == 0)
        {
          uint64_t v49 = (unsigned int *)(v45 + 4 * (v4 * v44));
          uint64_t v50 = v87;
          do
          {
            float v51 = *v50++;
            int v52 = vcvts_n_s32_f32(v51, 0x18uLL);
            BOOL v53 = v52 < 0;
            if (v52 < 0) {
              int v52 = -v52;
            }
            unsigned int v54 = v52 + 14506 * (v52 >> 15) + ((14506 * (v52 & 0x7FFFu) + 0x4000) >> 15);
            if (v53) {
              unsigned int v54 = -v54;
            }
            *v49++ = v54;
            --v44;
          }
          while (v44);
        }
        *(_DWORD *)(*(void *)(MrccInfo + 288) + 4 * v4) = v31;
        *(_DWORD *)(*(void *)(MrccInfo + 296) + 4 * v4) = v33;
        __src = 0;
        unsigned int v94 = 0;
        unsigned int v55 = siren_common_synth_GetCurSampleCount(a1);
        unsigned int v89 = siren_common_synth_GetBufSamplesCount(a1);
        int v91 = siren_common_synth_GetRatePct(a1);
        int VolumeLevel = siren_common_synth_GetVolumeLevel(a1);
        uint64_t v56 = siren_common_synth_GetVoice(a1);
        uint64_t v57 = siren_common_synth_GetMrccInfo(a1);
        uint64_t v58 = siren_common_synth_GetPcmBuffer(a1);
        uint64_t v59 = (void *)siren_common_synth_GetLeftAcousticBuffer(a1);
        uint64_t v60 = (void *)siren_common_synth_GetLeftPcmBuffer(a1);
        uint64_t v61 = siren_common_synth_GetFrames(a1);
        uint64_t v88 = siren_common_synth_GetRsrc(a1);
        unsigned int v62 = *(_DWORD *)(v56 + 24) + 1;
        *(void *)(v57 + 88) = 0xFFFFFFFFLL;
        uint64_t v63 = *(void *)(v57 + 288);
        int v64 = *(_DWORD *)(*(void *)(v57 + 296) + 4 * v4);
        *(_DWORD *)(v57 + 72) = 0;
        *(_DWORD *)(v57 + 76) = v64;
        *(_DWORD *)(v57 + 80) = (42949673 * (unint64_t)(v91 << 10)) >> 32;
        *(_DWORD *)(v57 + 68) = *(_DWORD *)(v63 + 4 * v4);
        int Data = MrccInput_AllocateData(v57 + 48, v62);
        if (Data) {
          return Data | 0x84E02000;
        }
        cstdlib_memcpy(*(void **)(v57 + 56), (const void *)(*(void *)(v57 + 304) + 4 * v62 * v4), 4 * v62);
        int Data = RccSyn__SynthesisOneFrame(v57, &v94, &__src);
        if (Data) {
          return Data | 0x84E02000;
        }
        RrInput_Reset(v57 + 160);
        if (v94 + v55 <= v89)
        {
          uint64_t v71 = (void *)(v58 + 2 * v55);
          cstdlib_memcpy(v71, __src, 2 * v94);
          vol_ScaleToLevel((__int16 *)v71, v94, VolumeLevel);
          int v72 = siren_common_synth_GetCurFrameCount(a1);
          int Data = siren_common_synth_SetCurFrameCount(a1, v72 + 1);
          uint64_t v65 = v88;
          if (Data) {
            return Data | 0x84E02000;
          }
          int v73 = siren_common_synth_GetCurSampleCount(a1);
          int Data = siren_common_synth_SetCurSampleCount(a1, v94 + v73);
          if (Data) {
            return Data | 0x84E02000;
          }
        }
        else
        {
          cstdlib_memcpy(v59, (const void *)(v61 + 4 * (*(_DWORD *)(v56 + 9204) * v4)), 4 * *(unsigned int *)(v56 + 9204));
          cstdlib_memcpy(v60, __src, 2 * v94);
          vol_ScaleToLevel((__int16 *)v60, v94, VolumeLevel);
          int Data = siren_common_synth_SetIsBufferFull(a1, 1u);
          if (Data) {
            return Data | 0x84E02000;
          }
          int Data = siren_common_synth_SetLeftSamplesCount(a1, v94);
          if (Data) {
            return Data | 0x84E02000;
          }
          uint64_t v65 = v88;
          uint64_t v66 = *(void *)(v88 + 32);
          uint64_t v67 = siren_common_synth_GetLeftSamplesCount(a1);
          log_OutText(v66, (uint64_t)"SYNTH_BET6", 3, 0, (uint64_t)"New leftover buffer for current frame (%d samples)", v68, v69, v70, v67);
        }
        if (log_GetLogLevel(*(void *)(v65 + 32)) >= 3)
        {
          siren_compute_stream_hash((char *)__src, 2 * v94, v96);
          log_OutText(*(void *)(v65 + 32), (uint64_t)"SYNTH_BET6", 3, 0, (uint64_t)"SYNTH_PCM_BUFFER_MD5=%s", v74, v75, v76, (uint64_t)v96);
        }
        unsigned int BufSamplesCount = v82;
        uint64_t Rsrc = v80;
        uint64_t LeftSamplesCount = v81;
        uint64_t v14 = v78;
        LeftAcousticBuffer = v79;
        if (siren_common_synth_GetIsBufferFull(a1)) {
          return 0;
        }
        goto LABEL_49;
      }
    }
    LODWORD(v33) = 0;
    goto LABEL_26;
  }
  int Data = siren_common_synth_SetIsBufferFull(a1, 1u);
  if (Data) {
    return Data | 0x84E02000;
  }
  return 0;
}

uint64_t new_siren_mrcc_synth_ProcessEnd(uint64_t a1)
{
  uint64_t Rsrc = siren_common_synth_GetRsrc(a1);
  uint64_t MrccInfo = siren_common_synth_GetMrccInfo(a1);
  if (MrccInfo)
  {
    unint64_t v4 = (void *)MrccInfo;
    uint64_t v5 = *(void *)(MrccInfo + 288);
    if (v5)
    {
      heap_Free(*(void **)(Rsrc + 8), v5);
      v4[36] = 0;
    }
    uint64_t v6 = v4[37];
    if (v6)
    {
      heap_Free(*(void **)(Rsrc + 8), v6);
      v4[37] = 0;
    }
    uint64_t v7 = v4[38];
    if (v7)
    {
      heap_Free(*(void **)(Rsrc + 8), v7);
      v4[38] = 0;
    }
  }
  return 0;
}

uint64_t new_siren_mrcc_synth_SetPitch(uint64_t a1, unsigned int a2)
{
  uint64_t MrccInfo = siren_common_synth_GetMrccInfo(a1);
  uint64_t result = 2229280786;
  if (a2 <= 0xC8)
  {
    if (MrccInfo)
    {
      uint64_t result = 0;
      *(_DWORD *)(MrccInfo + 280) = a2;
    }
  }
  return result;
}

uint64_t exp_S7_25_0(int a1, _WORD *a2)
{
  int v2 = a1 >> 10;
  uint64_t result = 0x40000000;
  int v4 = 1;
  for (uint64_t i = 10; i != 32; ++i)
  {
    if (v2)
    {
      uint64_t result = (exp_mantissa_lut_0[i] * (((int)result + 0x4000) >> 15));
      v4 += exp_scale_lut_0[i];
      if ((int)result <= 1073733631)
      {
        uint64_t result = (2 * result);
        --v4;
      }
    }
    v2 >>= 1;
  }
  if ((int)result <= 0x3FFFFFFF)
  {
    do
    {
      uint64_t result = (2 * result);
      LOWORD(v4) = v4 - 1;
    }
    while ((int)result < 0x40000000);
  }
  *a2 = v4;
  return result;
}

uint64_t new_siren_nn_mt_synth_Init(void *a1)
{
  uint64_t Rsrc = siren_common_synth_GetRsrc((uint64_t)a1);
  uint64_t Voice = siren_common_synth_GetVoice((uint64_t)a1);
  uint64_t v4 = *(unsigned int *)(Voice + 9168);
  uint64_t v5 = heap_Calloc(*(void **)(Rsrc + 8), 1, 64);
  if (!v5) {
    return 10;
  }
  uint64_t v6 = v5;
  *(_DWORD *)(v5 + 24) = *(_DWORD *)(Voice + 9188);
  *(_DWORD *)(v5 + 40) = v4;
  uint64_t v7 = heap_Calloc(*(void **)(Rsrc + 8), v4, 8);
  *(void *)(v6 + 16) = v7;
  if (!v7) {
    return 10;
  }
  uint64_t v8 = heap_Calloc(*(void **)(Rsrc + 8), v4, 8);
  if (!v8) {
    return 10;
  }
  uint64_t v9 = v8;
  uint64_t v10 = siren_common_synth_SetLeftFrames((uint64_t)a1, 0);
  if (v10) {
    return v10;
  }
  uint64_t v10 = siren_common_synth_SetUsedLeftFrames((uint64_t)a1, 0);
  if (v10) {
    return v10;
  }
  uint64_t v10 = siren_common_synth_SetLeftSamples((uint64_t)a1, 0);
  if (v10) {
    return v10;
  }
  uint64_t v10 = siren_common_synth_SetUsedLeftSamples((uint64_t)a1, 0);
  if (v10) {
    return v10;
  }
  uint64_t v11 = fi_rsc_create((void *)Rsrc, (void *)v6);
  if (v11)
  {
    uint64_t v10 = v11;
    siren_log_Error(Rsrc, (uint64_t)"NNVocoder Model FI Resource creation failed: %d");
    return v10;
  }
  if (!v4)
  {
LABEL_14:
    *(void *)(v6 + 48) = v9;
    uint64_t v15 = heap_Calloc(*(void **)(Rsrc + 8), 1, 56);
    *(void *)(v6 + 56) = v15;
    if (v15)
    {
      uint64_t v16 = heap_Calloc(*(void **)(Rsrc + 8), 1, 2 * *(unsigned int *)(v6 + 24));
      *(void *)(*(void *)(v6 + 56) + 8) = v16;
      if (v16)
      {
        uint64_t v17 = heap_Calloc(*(void **)(Rsrc + 8), 1, 2 * *(unsigned int *)(v6 + 24));
        **(void **)(v6 + 56) = v17;
        if (v17)
        {
          uint64_t v18 = heap_Calloc(*(void **)(Rsrc + 8), (*(_DWORD *)(Voice + 9200) + 2 * *(_DWORD *)(Voice + 9188) + 110), 4);
          uint64_t v19 = *(void *)(v6 + 56);
          *(void *)(v19 + 16) = v18;
          if (v18)
          {
            int v20 = *(_DWORD *)(Voice + 9188);
            *(void *)(v19 + 40) = *(void *)(Voice + 9192);
            *(_DWORD *)(v19 + 48) = *(_DWORD *)(Voice + 9200);
            *(int32x2_t *)&long long v21 = vrev64_s32(*(int32x2_t *)(Voice + 9168));
            DWORD2(v21) = v20;
            HIDWORD(v21) = v20;
            *(_OWORD *)(v19 + 24) = v21;
            uint64_t v10 = siren_common_synth_SetNnInfo(a1, v6);
            if (v10) {
              new_siren_nn_mt_synth_DeInit((uint64_t)a1);
            }
            return v10;
          }
        }
      }
    }
    return 10;
  }
  uint64_t v12 = 0;
  uint64_t v13 = 8 * v4;
  while (1)
  {
    uint64_t v14 = parse_fi_binary_model(*(uint64_t **)v6, *(void *)(Voice + 8056), (void *)(*(void *)(v6 + 16) + v12));
    if (v14) {
      break;
    }
    v12 += 8;
    if (v13 == v12) {
      goto LABEL_14;
    }
  }
  uint64_t v10 = v14;
  siren_log_Error(Rsrc, (uint64_t)"NNVocoder Model FI binary model parsing failed: %d");
  return v10;
}

uint64_t new_siren_nn_mt_synth_DeInit(uint64_t a1)
{
  uint64_t NnInfo = siren_common_synth_GetNnInfo(a1);
  uint64_t Voice = siren_common_synth_GetVoice(a1);
  uint64_t Rsrc = siren_common_synth_GetRsrc(a1);
  if (!NnInfo) {
    return 7;
  }
  uint64_t v5 = Rsrc;
  uint64_t v6 = *(unsigned int *)(Voice + 9168);
  if (v6)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 8 * v6;
    do
    {
      uint64_t v9 = *(void *)(*(void *)(NnInfo + 16) + v7);
      if (v9) {
        fi_net_destroy(v9);
      }
      v7 += 8;
    }
    while (v8 != v7);
  }
  heap_Free(*(void **)(v5 + 8), *(void *)(NnInfo + 16));
  heap_Free(*(void **)(v5 + 8), *(void *)(NnInfo + 48));
  if (*(void *)NnInfo)
  {
    fi_rsc_destroy(*(void **)NnInfo);
    *(void *)uint64_t NnInfo = 0;
  }
  uint64_t v10 = *(uint64_t **)(NnInfo + 56);
  if (!v10) {
    return 0;
  }
  if (*v10)
  {
    heap_Free(*(void **)(v5 + 8), *v10);
    uint64_t v10 = *(uint64_t **)(NnInfo + 56);
  }
  if (v10[1])
  {
    heap_Free(*(void **)(v5 + 8), v10[1]);
    uint64_t v10 = *(uint64_t **)(NnInfo + 56);
  }
  if (v10[2])
  {
    heap_Free(*(void **)(v5 + 8), v10[2]);
    uint64_t v10 = *(uint64_t **)(NnInfo + 56);
  }
  heap_Free(*(void **)(v5 + 8), (uint64_t)v10);
  uint64_t result = 0;
  *(void *)(NnInfo + 56) = 0;
  return result;
}

uint64_t new_siren_nn_synth_Init(void *a1)
{
  uint64_t Rsrc = siren_common_synth_GetRsrc((uint64_t)a1);
  uint64_t Voice = siren_common_synth_GetVoice((uint64_t)a1);
  uint64_t v10 = 0;
  uint64_t v4 = (void *)heap_Calloc(*(void **)(Rsrc + 8), 1, 64);
  if (!v4)
  {
    uint64_t v7 = 10;
    goto LABEL_8;
  }
  uint64_t v5 = (uint64_t)v4;
  uint64_t v6 = fi_rsc_create((void *)Rsrc, v4);
  if (v6)
  {
    uint64_t v7 = v6;
    siren_log_Error(Rsrc, (uint64_t)"NNVocoder Model FI Resource creation failed: %d");
LABEL_8:
    new_siren_nn_synth_DeInit((uint64_t)a1);
    return v7;
  }
  uint64_t v8 = parse_fi_binary_model(*(uint64_t **)v5, *(void *)(Voice + 8056), &v10);
  if (v8)
  {
    uint64_t v7 = v8;
    siren_log_Error(Rsrc, (uint64_t)"NNVocoder Model FI binary model parsing failed: %d");
    goto LABEL_8;
  }
  *(void *)(v5 + 8) = v10;
  *(_DWORD *)(v5 + 24) = *(_DWORD *)(Voice + 9188);
  uint64_t v7 = siren_common_synth_SetNnInfo(a1, v5);
  if (v7) {
    goto LABEL_8;
  }
  return v7;
}

uint64_t new_siren_nn_synth_DeInit(uint64_t a1)
{
  uint64_t NnInfo = siren_common_synth_GetNnInfo(a1);
  if (NnInfo)
  {
    uint64_t v2 = NnInfo;
    uint64_t v3 = *(void *)(NnInfo + 8);
    if (v3)
    {
      fi_net_destroy(v3);
      *(void *)(v2 + 8) = 0;
    }
    if (*(void *)v2)
    {
      fi_rsc_destroy(*(void **)v2);
      *(void *)uint64_t v2 = 0;
    }
  }
  return 0;
}

uint64_t new_siren_nn_mt_synth_Reset(uint64_t a1)
{
  uint64_t NnInfo = siren_common_synth_GetNnInfo(a1);
  uint64_t v2 = *(unsigned int *)(NnInfo + 40);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = NnInfo;
  uint64_t v4 = 0;
  uint64_t v5 = 8 * v2;
  while (1)
  {
    int v6 = fi_net_reset(*(void *)(*(void *)(v3 + 16) + v4));
    if (v6) {
      break;
    }
    v4 += 8;
    if (v5 == v4) {
      return 0;
    }
  }
  return v6 | 0x84E02000;
}

uint64_t new_siren_nn_synth_Reset(uint64_t a1)
{
  uint64_t NnInfo = siren_common_synth_GetNnInfo(a1);
  int v2 = fi_net_reset(*(void *)(NnInfo + 8));
  if (v2) {
    return v2 | 0x84E02000;
  }
  else {
    return 0;
  }
}

uint64_t new_siren_nn_mt_synth_ProcessStart(uint64_t a1, uint64_t a2)
{
  uint64_t Rsrc = siren_common_synth_GetRsrc(a1);
  uint64_t Voice = siren_common_synth_GetVoice(a1);
  uint64_t NnInfo = siren_common_synth_GetNnInfo(a1);
  unsigned int RatePct = siren_common_synth_GetRatePct(a1);
  *(void *)(NnInfo + 32) = a2;
  float v8 = (float)((float)RatePct / 100.0) * (float)siren_common_synth_GetFrameSamples(a1);
  *(_DWORD *)(NnInfo + 24) = v8;
  uint64_t v9 = *(void *)(NnInfo + 56);
  *(_DWORD *)(v9 + 32) = v8;
  if (*(_DWORD *)(v9 + 36) >= v8) {
    return 0;
  }
  uint64_t v10 = heap_Realloc(*(uint64_t **)(Rsrc + 8), *(void *)(v9 + 8), 2 * v8);
  if (!v10) {
    return 10;
  }
  uint64_t v11 = *(uint64_t **)(NnInfo + 56);
  v11[1] = v10;
  uint64_t v12 = heap_Realloc(*(uint64_t **)(Rsrc + 8), *v11, 2 * *(unsigned int *)(NnInfo + 24));
  if (!v12) {
    return 10;
  }
  uint64_t v13 = *(uint64_t **)(NnInfo + 56);
  uint64_t *v13 = v12;
  uint64_t v14 = heap_Realloc(*(uint64_t **)(Rsrc + 8), v13[2], 4 * (*(_DWORD *)(Voice + 9200) + 2 * *(_DWORD *)(NnInfo + 24) + 110));
  if (!v14) {
    return 10;
  }
  uint64_t v15 = v14;
  uint64_t result = 0;
  *(void *)(*(void *)(NnInfo + 56) + 16) = v15;
  return result;
}

uint64_t new_siren_nn_synth_ProcessStart()
{
  return 0;
}

uint64_t new_siren_nn_mt_synth_Process(uint64_t a1)
{
  uint64_t Voice = siren_common_synth_GetVoice(a1);
  uint64_t PcmBuffer = siren_common_synth_GetPcmBuffer(a1);
  Leftuint64_t PcmBuffer = siren_common_synth_GetLeftPcmBuffer(a1);
  uint64_t Rsrc = siren_common_synth_GetRsrc(a1);
  int v6 = -2065686521;
  if (!PcmBuffer || !LeftPcmBuffer) {
    return v6 | 0x84E02000;
  }
  uint64_t v7 = *(unsigned int *)(Voice + 9168);
  int LeftSamples = siren_common_synth_GetLeftSamples(a1);
  uint64_t NnInfo = siren_common_synth_GetNnInfo(a1);
  if (!LeftSamples)
  {
    uint64_t v149 = Rsrc;
    uint64_t v22 = siren_common_synth_GetVoice(a1);
    uint64_t v23 = siren_common_synth_GetRsrc(a1);
    uint64_t v24 = *(void *)(NnInfo + 32);
    uint64_t Frames = siren_common_synth_GetFrames(a1);
    uint64_t v26 = *(unsigned int *)(v22 + 9168);
    uint64_t v150 = heap_Calloc(*(void **)(v23 + 8), v26, 48);
    if (!v150)
    {
      uint64_t v36 = 0;
      siren_log_Error(v23, (uint64_t)"memory allocation error.");
      int v92 = 10;
      goto LABEL_117;
    }
    if (v26)
    {
      uint64_t v27 = 0;
      v151[0] = 0;
      int v28 = (int *)(v150 + 16);
      while (1)
      {
        ThreadChunkunsigned int Index = SampleChunk_getThreadChunkIndex(v24, v27, (_DWORD *)v151 + 1, v151);
        if (ThreadChunkIndex) {
          break;
        }
        ThreadChunkunsigned int Index = fi_net_update_param(*(void *)(*(void *)(NnInfo + 16) + 8 * v27));
        if (ThreadChunkIndex) {
          break;
        }
        uint64_t v30 = Frames + 4 * (*(_DWORD *)(v22 + 9204) * HIDWORD(v151[0]));
        int v31 = LODWORD(v151[0]) - HIDWORD(v151[0]) + 1;
        *((void *)v28 - 2) = *(void *)(*(void *)(NnInfo + 16) + 8 * v27);
        *((void *)v28 - 1) = v30;
        int *v28 = v31;
        v28 += 12;
        if (v26 == ++v27) {
          goto LABEL_20;
        }
      }
      int v92 = ThreadChunkIndex;
      uint64_t v36 = v150;
LABEL_117:
      if (!v36) {
        goto LABEL_124;
      }
LABEL_118:
      if (v7)
      {
        uint64_t v119 = (uint64_t *)(v150 + 32);
        do
        {
          if (*v119) {
            heap_Free(*(void **)(v149 + 8), *v119);
          }
          v119 += 6;
          --v7;
        }
        while (v7);
      }
      heap_Free(*(void **)(v149 + 8), v150);
      goto LABEL_124;
    }
LABEL_20:
    uint64_t v32 = siren_common_synth_GetNnInfo(a1);
    uint64_t v33 = siren_common_synth_GetVoice(a1);
    uint64_t v34 = siren_common_synth_GetRsrc(a1);
    uint64_t v35 = *(unsigned int *)(v33 + 9168);
    uint64_t v36 = v150;
    if (v35)
    {
      uint64_t v37 = v34;
      uint64_t v38 = 0;
      uint64_t v39 = 8 * v35;
      while (1)
      {
        int v40 = thread_ObjOpen(*(void *)(v37 + 408), *(void **)(v37 + 8), (uint64_t *)(*(void *)(v32 + 48) + v38));
        if (v40) {
          break;
        }
        v38 += 8;
        if (v39 == v38)
        {
          uint64_t v41 = 0;
          uint64_t v42 = "thread start failed.";
          uint64_t v43 = v150;
          while (1)
          {
            int v44 = thread_Start(*(void **)(*(void *)(v32 + 48) + v41));
            if (v44) {
              break;
            }
            v41 += 8;
            v43 += 48;
            if (v39 == v41)
            {
              uint64_t v45 = 0;
              uint64_t v42 = "thread join failed.";
              while (1)
              {
                int v44 = thread_Join(*(void **)(*(void *)(v32 + 48) + v45));
                if (v44) {
                  goto LABEL_95;
                }
                v45 += 8;
                if (v39 == v45)
                {
                  uint64_t v46 = 0;
                  while (1)
                  {
                    uint64_t v47 = *(void *)(*(void *)(v32 + 48) + v46);
                    if (v47)
                    {
                      int v40 = thread_ObjClose(v47);
                      if (v40) {
                        goto LABEL_116;
                      }
                    }
                    v46 += 8;
                    if (v39 == v46) {
                      goto LABEL_34;
                    }
                  }
                }
              }
            }
          }
LABEL_95:
          int v92 = v44;
          siren_log_Error(v37, (uint64_t)v42);
          goto LABEL_117;
        }
      }
LABEL_116:
      int v92 = v40;
      goto LABEL_117;
    }
LABEL_34:
    uint64_t v48 = siren_common_synth_GetVoice(a1);
    uint64_t v49 = siren_common_synth_GetNnInfo(a1);
    uint64_t v50 = *(void *)(v49 + 32);
    uint64_t v51 = siren_common_synth_GetRsrc(a1);
    uint64_t v52 = *(unsigned int *)(v48 + 9168);
    if (v52)
    {
      uint64_t v135 = v51;
      uint64_t v136 = (void *)v49;
      LODWORD(v53) = 0;
      uint64_t v54 = *(unsigned int *)(v49 + 24);
      unsigned int v55 = (int *)(v150 + 16);
      do
      {
        int v56 = *v55;
        v55 += 12;
        if (v56 <= 0) {
          uint64_t v53 = v53;
        }
        else {
          uint64_t v53 = (v53 + 1);
        }
        --v52;
      }
      while (v52);
      HIDWORD(v151[0]) = 0;
      SampleChunk_getEmissionType(v50, (float *)v151 + 1);
      if (v53)
      {
        for (uint64_t i = 0; i != v53; ++i)
        {
          uint64_t v58 = v150 + 48 * i;
          int v60 = *(_DWORD *)(v58 + 16);
          uint64_t v59 = v58 + 16;
          uint64_t v61 = (_WORD *)heap_Calloc(*(void **)(v135 + 8), (v60 + 1), 2 * v54);
          *(void *)(v59 + 8) = v61;
          if (!v61)
          {
            int v92 = 10;
            goto LABEL_118;
          }
          *(void *)(v150 + 48 * i + 32) = v61;
          uint64_t v62 = (*(_DWORD *)v59 * v54);
          if (v62)
          {
            uint64_t v63 = *(float **)(v150 + 48 * i + 40);
            if (!v63)
            {
              int v92 = 7;
              goto LABEL_118;
            }
            do
            {
              float v64 = *v63++;
              *v61++ = (int)v64;
              --v62;
            }
            while (v62);
          }
        }
        uint64_t v65 = 0;
        uint64_t v133 = (v53 - 1);
        while (1)
        {
          float v66 = *((float *)v151 + 1);
          if (*((float *)v151 + 1) == 0.0)
          {
            if (v65) {
              float v66 = 1.0;
            }
            else {
              float v66 = 0.0;
            }
          }
          else if (*((float *)v151 + 1) == 2.0)
          {
            if (v65 == v133) {
              float v66 = 2.0;
            }
            else {
              float v66 = 1.0;
            }
          }
          else if (*((float *)v151 + 1) == 4.0)
          {
            float v66 = v65 == v133 ? 2.0 : 1.0;
            if (!v65) {
              float v66 = 0.0;
            }
          }
          unsigned int v67 = v66;
          if (v66 == 4) {
            goto LABEL_84;
          }
          uint64_t v68 = v136[7];
          int v69 = *(_DWORD *)(v68 + 24);
          uint64_t v70 = *(unsigned int *)(v68 + 32);
          uint64_t v71 = *(void **)(v68 + 8);
          uint64_t __dst = *(void **)v68;
          if (v67 == 2)
          {
            unsigned int v75 = 0;
            uint64_t v76 = v36 + 48 * v65;
            uint64_t v77 = (__int16 *)(*(void *)(v76 + 24) + 2 * (v70 * v69));
            unsigned int v78 = (*(_DWORD *)(v76 + 16) - v69) * v70;
            goto LABEL_68;
          }
          if (v67) {
            break;
          }
          uint64_t v72 = v36 + 48 * v65;
          uint64_t v73 = *(void *)(v72 + 24);
          unsigned int v74 = (*(_DWORD *)(v72 + 16) + ~v69) * v70;
          cstdlib_memcpy(v71, (const void *)(v73 + 2 * v74), 2 * v70);
          *(void *)(v72 + 24) = v73;
          *(_DWORD *)(v72 + 20) = v74;
          *(_DWORD *)(v68 + 36) = *(_DWORD *)(v68 + 32);
LABEL_84:
          if (++v65 == v53) {
            goto LABEL_97;
          }
        }
        uint64_t v79 = v36 + 48 * v65;
        uint64_t v77 = (__int16 *)(*(void *)(v79 + 24) + 2 * (v70 * v69));
        unsigned int v75 = (*(_DWORD *)(v79 + 16) + ~(2 * v69)) * v70;
        unsigned int v78 = v75;
LABEL_68:
        unsigned int v145 = v78;
        uint64_t v147 = *(unsigned int *)(v68 + 36);
        __src = *(void **)(v68 + 8);
        if (v70 >= 0x37)
        {
          unsigned int v139 = v75;
          uint64_t v81 = (uint64_t)v71 + 2 * (*(_DWORD *)(v68 + 36) - 55);
          uint64_t v82 = *(void *)(v68 + 16);
          bet6_synth_Apply_Half_hannWin_Scalar_55(v81, 1);
          bet6_synth_Apply_Half_hannWin_Scalar_55((uint64_t)v77, 0);
          bet6_synth_Convolve_ReverseKernel(v81, 55, (uint64_t)v77, 55, v82);
          uint64_t v83 = 0;
          __int16 v84 = 0;
          signed int v85 = 0x80000000;
          do
          {
            if (*(_DWORD *)(v82 + 216 + 4 * v83) > v85)
            {
              signed int v85 = *(_DWORD *)(v82 + 216 + 4 * v83);
              __int16 v84 = v83;
            }
            ++v83;
          }
          while (v83 != 55);
          unsigned __int16 v80 = 55 - v84;
          unsigned int v86 = (unsigned __int16)(55 - v84);
          if (v86 > 0x37)
          {
            uint64_t v36 = v150;
            unsigned int v75 = v139;
          }
          else
          {
            int v87 = bet6_synth_OverlapAdd((__int16 *)(v81 + 2 * (55 - v80)), v77, v86);
            uint64_t v36 = v150;
            unsigned int v75 = v139;
            if (v87 < 0)
            {
LABEL_83:
              siren_log_Error(v135, (uint64_t)"overlap process failed.");
              goto LABEL_84;
            }
          }
        }
        else
        {
          unsigned __int16 v80 = 0;
        }
        if (v75) {
          cstdlib_memcpy(__dst, &v77[v75], 2 * v70);
        }
        cstdlib_memmove(&v77[v70 - v80], v77, 2 * v145);
        cstdlib_memcpy(v77, __src, 2 * v147);
        if (v75) {
          cstdlib_memcpy(__src, __dst, 2 * v70);
        }
        int v88 = bet6_apply_fir_same_mode((uint64_t)v77, 2 * (int)v70, *(void *)(v68 + 40), *(_DWORD *)(v68 + 48), *(void *)(v68 + 16));
        uint64_t v89 = v36 + 48 * v65;
        *(void *)(v89 + 24) = v77;
        *(_DWORD *)(v89 + 20) = v145 + v147 - v80;
        *(_DWORD *)(v68 + 36) = *(_DWORD *)(v68 + 32);
        if ((v88 & 0x80000000) == 0) {
          goto LABEL_84;
        }
        goto LABEL_83;
      }
    }
    else
    {
      HIDWORD(v151[0]) = 0;
      SampleChunk_getEmissionType(v50, (float *)v151 + 1);
    }
LABEL_97:
    uint64_t v93 = siren_common_synth_GetVoice(a1);
    uint64_t v94 = siren_common_synth_GetNnInfo(a1);
    __srca = (char *)siren_common_synth_GetPcmBuffer(a1);
    uint64_t v95 = siren_common_synth_GetLeftPcmBuffer(a1);
    uint64_t v96 = siren_common_synth_GetRsrc(a1);
    uint64_t v97 = *(unsigned int *)(v93 + 9168);
    if (v97)
    {
      unsigned int v98 = 0;
      uint64_t v99 = (int *)(v150 + 16);
      do
      {
        int v100 = *v99;
        v99 += 12;
        if (v100 > 0) {
          ++v98;
        }
        --v97;
      }
      while (v97);
    }
    else
    {
      unsigned int v98 = 0;
    }
    unsigned int BufSamplesCount = siren_common_synth_GetBufSamplesCount(a1);
    int __dsta = siren_common_synth_GetVolumeLevel(a1);
    if (v98)
    {
      uint64_t v134 = v96;
      uint64_t v101 = 0;
      int v102 = 0;
      int v103 = 0;
      unsigned int v138 = *(_DWORD *)(v94 + 24);
      uint64_t v137 = (char *)v95;
      uint64_t v104 = 1;
      while (1)
      {
        Curunsigned int FrameCount = siren_common_synth_GetCurFrameCount(a1);
        int CurSampleCount = siren_common_synth_GetCurSampleCount(a1);
        int v107 = CurSampleCount;
        uint64_t v108 = v150 + v101;
        uint64_t v109 = *(int *)(v150 + v101 + 20);
        uint64_t v148 = v104;
        if ((int)v109 + CurSampleCount >= BufSamplesCount) {
          break;
        }
        int v110 = v103;
        unsigned int v111 = &__srca[2 * CurSampleCount];
        cstdlib_memcpy(v111, *(const void **)(v108 + 24), 2 * v109);
        int IsBufferFull = vol_ScaleToLevel((__int16 *)v111, *(_DWORD *)(v108 + 20), __dsta);
        if (IsBufferFull) {
          goto LABEL_143;
        }
        int IsBufferFull = siren_common_synth_SetIsBufferFull(a1, 0);
        if (IsBufferFull) {
          goto LABEL_143;
        }
        int v113 = CurFrameCount;
        uint64_t v114 = v150 + v101;
        uint64_t v115 = v101;
        int v116 = v102;
        uint64_t v117 = v115;
        uint64_t v118 = v150 + v115;
        int IsBufferFull = siren_common_synth_SetCurFrameCount(a1, *(_DWORD *)(v150 + v115 + 16) + v113);
        if (IsBufferFull) {
          goto LABEL_143;
        }
        int IsBufferFull = siren_common_synth_SetCurSampleCount(a1, *(_DWORD *)(v114 + 20) + v107);
        if (IsBufferFull) {
          goto LABEL_143;
        }
        int v103 = *(_DWORD *)(v118 + 16) + v110;
        int v102 = *(_DWORD *)(v114 + 20) + v116;
        uint64_t v104 = v148 + 1;
        uint64_t v101 = v117 + 48;
        if (48 * v98 == v117 + 48) {
          goto LABEL_114;
        }
      }
      uint64_t v120 = *(const void **)(v108 + 24);
      if (v120)
      {
        uint64_t v140 = v150 + v101;
        int v132 = v103;
        uint64_t v121 = BufSamplesCount - CurSampleCount;
        uint64_t v122 = &__srca[2 * CurSampleCount];
        cstdlib_memcpy(v122, v120, 2 * v121);
        int v92 = vol_ScaleToLevel((__int16 *)v122, v121, __dsta);
        if (!v92)
        {
          int v92 = siren_common_synth_SetCurFrameCount(a1, v121 / v138 + CurFrameCount);
          if (!v92)
          {
            int v92 = siren_common_synth_SetCurSampleCount(a1, BufSamplesCount);
            if (!v92)
            {
              cstdlib_memcpy(v137, (const void *)(*(void *)(v140 + 24) + 2 * v121), 2 * (*(_DWORD *)(v140 + 20) - v121));
              int v92 = vol_ScaleToLevel((__int16 *)v137, *(_DWORD *)(v140 + 20) - (int)v121, __dsta);
              if (!v92)
              {
                int v123 = *(_DWORD *)(v150 + v101 + 16) - v121 / v138;
                unsigned int v124 = *(_DWORD *)(v140 + 20) - v121;
                if (v148 < v98)
                {
                  uint64_t v125 = (const void **)(v140 + 72);
                  int v126 = v98 - v148;
                  while (1)
                  {
                    cstdlib_memcpy(&v137[2 * v124], *v125, 2 * *((int *)v125 - 1));
                    int IsBufferFull = vol_ScaleToLevel((__int16 *)&v137[2 * v124], *((_DWORD *)v125 - 1), __dsta);
                    if (IsBufferFull) {
                      break;
                    }
                    v123 += *((_DWORD *)v125 - 2);
                    v124 += *((_DWORD *)v125 - 1);
                    v125 += 6;
                    if (!--v126) {
                      goto LABEL_138;
                    }
                  }
LABEL_143:
                  int v92 = IsBufferFull;
                  goto LABEL_118;
                }
LABEL_138:
                int v92 = siren_common_synth_SetIsBufferFull(a1, 1u);
                if (!v92)
                {
                  int v92 = siren_common_synth_SetLeftSamples(a1, v124);
                  if (!v92)
                  {
                    int v92 = siren_common_synth_SetLeftFrames(a1, v123);
                    if (!v92)
                    {
                      int v92 = siren_common_synth_SetUsedLeftFrames(a1, 0);
                      if (!v92)
                      {
                        int v103 = v121 / v138 + v132;
                        v102 += v121;
                        siren_common_synth_SetUsedLeftSamples(a1, 0);
                        uint64_t v127 = *(void *)(v134 + 32);
                        Leftuint64_t Frames = siren_common_synth_GetLeftFrames(a1);
                        log_OutText(v127, (uint64_t)"SYNTH_BET6", 3, 0, (uint64_t)"New leftover buffer for current frame (%d samples)", v129, v130, v131, LeftFrames);
                        goto LABEL_114;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      else
      {
        int v92 = -2065686522;
      }
      goto LABEL_118;
    }
    int v103 = 0;
    int v102 = 0;
LABEL_114:
    int v92 = siren_common_synth_SetFeedFrames(a1, v103);
    uint64_t v36 = v150;
    if (v92) {
      goto LABEL_117;
    }
    int v40 = siren_common_synth_SetFeedFrames(a1, v102);
    goto LABEL_116;
  }
  unsigned int v10 = siren_common_synth_GetCurSampleCount(a1);
  int v11 = siren_common_synth_GetCurFrameCount(a1);
  UsedLeftuint64_t Frames = siren_common_synth_GetUsedLeftFrames(a1);
  int v13 = siren_common_synth_GetLeftFrames(a1);
  Usedint LeftSamples = siren_common_synth_GetUsedLeftSamples(a1);
  unsigned int v15 = *(_DWORD *)(NnInfo + 24);
  int v16 = siren_common_synth_GetLeftSamples(a1);
  unsigned int v17 = siren_common_synth_GetBufSamplesCount(a1);
  uint64_t v18 = siren_common_synth_GetPcmBuffer(a1);
  uint64_t v19 = siren_common_synth_GetLeftPcmBuffer(a1);
  unsigned int v20 = v16 - UsedLeftSamples;
  if (v20 >= v17)
  {
    unsigned int v90 = v17 - v10;
    cstdlib_memcpy((void *)(v18 + 2 * v10), (const void *)(v19 + 2 * UsedLeftSamples), 2 * (v17 - v10));
    int v6 = siren_common_synth_SetCurSampleCount(a1, v17);
    if (!v6)
    {
      int v6 = siren_common_synth_SetCurFrameCount(a1, v90 / v15 + v11);
      if (!v6)
      {
        int v6 = siren_common_synth_SetFeedFrames(a1, v90 / v15);
        if (!v6)
        {
          int v6 = siren_common_synth_SetUsedLeftFrames(a1, v90 / v15 + UsedLeftFrames);
          if (!v6)
          {
            int v6 = siren_common_synth_SetFeedSamples(a1, v90 / v15);
            if (!v6)
            {
              int v6 = siren_common_synth_SetUsedLeftSamples(a1, v90 + UsedLeftSamples);
              if (!v6)
              {
                unsigned int v21 = 1;
                goto LABEL_146;
              }
            }
          }
        }
      }
    }
    return v6 | 0x84E02000;
  }
  cstdlib_memcpy((void *)(v18 + 2 * v10), (const void *)(v19 + 2 * UsedLeftSamples), 2 * v20);
  int v6 = siren_common_synth_SetCurSampleCount(a1, v20 + v10);
  if (v6) {
    return v6 | 0x84E02000;
  }
  int v6 = siren_common_synth_SetCurFrameCount(a1, v11 - UsedLeftFrames + v13);
  if (v6) {
    return v6 | 0x84E02000;
  }
  int v6 = siren_common_synth_SetFeedFrames(a1, v13 - UsedLeftFrames);
  if (v6) {
    return v6 | 0x84E02000;
  }
  int v6 = siren_common_synth_SetFeedSamples(a1, v20);
  if (v6) {
    return v6 | 0x84E02000;
  }
  int v6 = siren_common_synth_SetLeftFrames(a1, 0);
  if (v6) {
    return v6 | 0x84E02000;
  }
  int v6 = siren_common_synth_SetUsedLeftFrames(a1, 0);
  if (v6) {
    return v6 | 0x84E02000;
  }
  int v6 = siren_common_synth_SetLeftSamples(a1, 0);
  if (v6) {
    return v6 | 0x84E02000;
  }
  int v6 = siren_common_synth_SetUsedLeftSamples(a1, 0);
  if (v6) {
    return v6 | 0x84E02000;
  }
  unsigned int v21 = 0;
LABEL_146:
  int v92 = siren_common_synth_SetIsBufferFull(a1, v21);
LABEL_124:
  if (v92) {
    return v92 | 0x84E02000;
  }
  else {
    return 0;
  }
}

uint64_t new_siren_nn_synth_Process(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v74 = *MEMORY[0x263EF8340];
  uint64_t LeftSamplesCount = siren_common_synth_GetLeftSamplesCount(a1);
  unsigned int BufSamplesCount = siren_common_synth_GetBufSamplesCount(a1);
  unsigned int FramesCount = siren_common_synth_GetFramesCount(a1);
  unsigned int RatePct = siren_common_synth_GetRatePct(a1);
  LeftAcousticBuffer = (const void *)siren_common_synth_GetLeftAcousticBuffer(a1);
  uint64_t Frames = siren_common_synth_GetFrames(a1);
  uint64_t Voice = siren_common_synth_GetVoice(a1);
  uint64_t PcmBuffer = (void *)siren_common_synth_GetPcmBuffer(a1);
  Leftuint64_t PcmBuffer = (const void *)siren_common_synth_GetLeftPcmBuffer(a1);
  uint64_t Rsrc = siren_common_synth_GetRsrc(a1);
  unsigned int FrameSamples = siren_common_synth_GetFrameSamples(a1);
  uint64_t result = 7;
  if (a3 >= a2 && a1 && FramesCount > a2 && FramesCount > a3)
  {
    __uint64_t n = 2 * LeftSamplesCount;
    unsigned int v62 = (float)((float)((float)RatePct / 100.0) * (float)FrameSamples);
    uint64_t v63 = LeftSamplesCount;
    unsigned int v55 = a3;
    uint64_t v54 = LeftSamplesCount;
    unsigned int v57 = BufSamplesCount;
    int v56 = LeftAcousticBuffer;
    uint64_t v58 = Voice;
    uint64_t v59 = Frames;
    if (!LeftSamplesCount) {
      goto LABEL_9;
    }
LABEL_6:
    if (BufSamplesCount < LeftSamplesCount)
    {
      int IsBufferFull = 18;
      return IsBufferFull | 0x84E02000;
    }
    if (cstdlib_memcmp(LeftAcousticBuffer, (const void *)(Frames + 4 * *(_DWORD *)(Voice + 9204) * a2), 4 * *(unsigned int *)(Voice + 9204)))
    {
      log_OutText(*(void *)(Rsrc + 32), (uint64_t)"SYNTH_BET6", 1, 0, (uint64_t)"Disregard leftover buffer for current frame (%d samples)", v15, v16, v17, v63);
    }
    else
    {
      cstdlib_memcpy(PcmBuffer, LeftPcmBuffer, __n);
      Curunsigned int FrameCount = siren_common_synth_GetCurFrameCount(a1);
      int IsBufferFull = siren_common_synth_SetCurFrameCount(a1, CurFrameCount + 1);
      if (IsBufferFull) {
        return IsBufferFull | 0x84E02000;
      }
      int CurSampleCount = siren_common_synth_GetCurSampleCount(a1);
      int IsBufferFull = siren_common_synth_SetCurSampleCount(a1, CurSampleCount + (int)LeftSamplesCount);
      if (IsBufferFull) {
        return IsBufferFull | 0x84E02000;
      }
      log_OutText(*(void *)(Rsrc + 32), (uint64_t)"SYNTH_BET6", 3, 0, (uint64_t)"Leftover buffer match current frame (%d samples)", v43, v44, v45, LeftSamplesCount);
    }
    int IsBufferFull = siren_common_synth_SetLeftSamplesCount(a1, 0);
    if (IsBufferFull) {
      return IsBufferFull | 0x84E02000;
    }
    while (a2 != a3)
    {
      ++a2;
      if (LeftSamplesCount) {
        goto LABEL_6;
      }
LABEL_9:
      if (siren_common_synth_GetCurSampleCount(a1) + v62 > BufSamplesCount)
      {
        int IsBufferFull = siren_common_synth_SetIsBufferFull(a1, 1u);
        if (IsBufferFull) {
          return IsBufferFull | 0x84E02000;
        }
        return 0;
      }
      uint64_t v72 = 0;
      siren_common_synth_GetFrameSamples(a1);
      unsigned int v68 = siren_common_synth_GetRatePct(a1);
      unsigned int v18 = siren_common_synth_GetCurSampleCount(a1);
      int v65 = siren_common_synth_GetCurFrameCount(a1);
      unsigned int v19 = siren_common_synth_GetBufSamplesCount(a1);
      uint64_t v64 = siren_common_synth_GetLeftSamplesCount(a1);
      int VolumeLevel = siren_common_synth_GetVolumeLevel(a1);
      uint64_t NnInfo = siren_common_synth_GetNnInfo(a1);
      uint64_t v21 = siren_common_synth_GetFrames(a1);
      uint64_t v22 = siren_common_synth_GetVoice(a1);
      uint64_t v23 = siren_common_synth_GetPcmBuffer(a1);
      uint64_t v24 = (__int16 *)siren_common_synth_GetLeftPcmBuffer(a1);
      uint64_t v67 = siren_common_synth_GetRsrc(a1);
      int v25 = (void *)siren_common_synth_GetLeftAcousticBuffer(a1);
      unsigned int v71 = (float)((float)((float)v68 / 100.0) * (float)*(unsigned int *)(NnInfo + 24));
      int IsBufferFull = fi_net_update_param(*(void *)(NnInfo + 8));
      if (IsBufferFull) {
        return IsBufferFull | 0x84E02000;
      }
      uint64_t v70 = v21 + 4 * *(_DWORD *)(v22 + 9204) * a2;
      int IsBufferFull = fi_net_predict_notfree_input(*(uint64_t ***)(NnInfo + 8), (const void **)&v70, 1, &v72, v27, v28, v29, v30);
      if (IsBufferFull) {
        return IsBufferFull | 0x84E02000;
      }
      unsigned int v31 = v71;
      if (v71 + v18 <= v19)
      {
        uint64_t Frames = v59;
        uint64_t v37 = v67;
        if (v71)
        {
          uint64_t v46 = v72;
          unsigned int v47 = v18;
          uint64_t v48 = v71;
          do
          {
            float v49 = *v46++;
            *(_WORD *)(v23 + 2 * v47++) = (int)v49;
            --v48;
          }
          while (v48);
        }
        vol_ScaleToLevel((__int16 *)(v23 + 2 * v18), v31, VolumeLevel);
        int IsBufferFull = siren_common_synth_SetCurFrameCount(a1, v65 + 1);
        a3 = v55;
        uint64_t LeftSamplesCount = v54;
        uint64_t Voice = v58;
        if (IsBufferFull) {
          return IsBufferFull | 0x84E02000;
        }
        int IsBufferFull = siren_common_synth_SetCurSampleCount(a1, v71 + v18);
        unsigned int BufSamplesCount = v57;
        LeftAcousticBuffer = v56;
        if (IsBufferFull) {
          return IsBufferFull | 0x84E02000;
        }
      }
      else
      {
        cstdlib_memcpy(v25, (const void *)(v21 + 4 * *(_DWORD *)(v22 + 9204) * a2), 4 * *(unsigned int *)(v22 + 9204));
        unsigned int v32 = v71;
        uint64_t Frames = v59;
        if (v71)
        {
          uint64_t v33 = v72;
          uint64_t v34 = v24;
          uint64_t v35 = v71;
          do
          {
            float v36 = *v33++;
            *v34++ = (int)v36;
            --v35;
          }
          while (v35);
        }
        vol_ScaleToLevel(v24, v32, VolumeLevel);
        int IsBufferFull = siren_common_synth_SetIsBufferFull(a1, 1u);
        unsigned int BufSamplesCount = v57;
        LeftAcousticBuffer = v56;
        uint64_t Voice = v58;
        uint64_t v37 = v67;
        if (IsBufferFull) {
          return IsBufferFull | 0x84E02000;
        }
        int IsBufferFull = siren_common_synth_SetLeftSamplesCount(a1, v71);
        if (IsBufferFull) {
          return IsBufferFull | 0x84E02000;
        }
        log_OutText(*(void *)(v67 + 32), (uint64_t)"SYNTH_BET6", 3, 0, (uint64_t)"New leftover buffer for current frame (%d samples)", v38, v39, v40, v64);
        a3 = v55;
        uint64_t LeftSamplesCount = v54;
      }
      if (log_GetLogLevel(*(void *)(v37 + 32)) >= 3)
      {
        siren_compute_stream_hash((char *)v72, 2 * v71, v73);
        log_OutText(*(void *)(v37 + 32), (uint64_t)"SYNTH_BET6", 3, 0, (uint64_t)"SYNTH_PCM_BUFFER_MD5=%s", v50, v51, v52, (uint64_t)v73);
      }
      if (siren_common_synth_GetIsBufferFull(a1)) {
        return 0;
      }
    }
    return 0;
  }
  return result;
}

uint64_t new_siren_nn_mt_synth_ProcessEnd()
{
  return 0;
}

uint64_t siren_nn_seq2seq_synth_Process(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  unsigned int FramesCount = siren_common_synth_GetFramesCount(a1);
  uint64_t Voice = siren_common_synth_GetVoice(a1);
  uint64_t result = 2229280775;
  unsigned int v11 = a4 - a3;
  if (a4 >= a3 && a1 && FramesCount > a3 && FramesCount > a4)
  {
    unsigned int v12 = v11 + 1;
    if (*(_DWORD *)(Voice + 9124))
    {
      uint64_t v82 = 0;
      int FrameSamples = siren_common_synth_GetFrameSamples(a1);
      unsigned int CurSampleCount = siren_common_synth_GetCurSampleCount(a1);
      int v71 = siren_common_synth_GetFrameSamples(a1);
      Curunsigned int FrameCount = siren_common_synth_GetCurFrameCount(a1);
      unsigned int BufSamplesCount = siren_common_synth_GetBufSamplesCount(a1);
      uint64_t NnInfo = siren_common_synth_GetNnInfo(a1);
      uint64_t Frames = (float *)siren_common_synth_GetFrames(a1);
      uint64_t v15 = siren_common_synth_GetVoice(a1);
      uint64_t PcmBuffer = siren_common_synth_GetPcmBuffer(a1);
      float v17 = *Frames;
      uint64_t v81 = &Frames[*(_DWORD *)(v15 + 9204) * a3 + 3];
      if (v17 == 0.0)
      {
        uint64_t v18 = heap_Calloc(*(void **)(a2 + 8), 1, 88);
        if (v18)
        {
          unsigned int v19 = (void **)v18;
          *(_DWORD *)uint64_t v18 = 1;
          *(_DWORD *)(v18 + 4) = (float)(v17 + 0.1);
          *(void *)&long long v20 = 0x8000000080;
          *((void *)&v20 + 1) = 0x8000000080;
          *(_OWORD *)(v18 + 64) = v20;
          *(_DWORD *)(v18 + 80) = 0;
          uint64_t v21 = heap_Alloc(*(void *)(a2 + 8), 512);
          v19[1] = (void *)v21;
          if (!v21) {
            goto LABEL_34;
          }
          v19[2] = (void *)(v21 + 128);
          v19[3] = (void *)(v21 + 256);
          v19[4] = (void *)(v21 + 384);
          uint64_t v22 = heap_Alloc(*(void *)(a2 + 8), 1536);
          v19[5] = (void *)v22;
          if (!v22
            || (uint64_t v23 = heap_Alloc(*(void *)(a2 + 8), 1536), (v19[6] = (void *)v23) == 0)
            || (uint64_t v24 = heap_Alloc(*(void *)(a2 + 8), 160), (v19[7] = (void *)v24) == 0))
          {
LABEL_34:
            int v48 = 10;
LABEL_35:
            uint64_t v49 = (uint64_t)v19[1];
            if (v49) {
              heap_Free(*(void **)(a2 + 8), v49);
            }
            uint64_t v50 = (uint64_t)v19[5];
            if (v50) {
              heap_Free(*(void **)(a2 + 8), v50);
            }
            uint64_t v51 = (uint64_t)v19[6];
            if (v51) {
              heap_Free(*(void **)(a2 + 8), v51);
            }
            uint64_t v52 = (uint64_t)v19[7];
            if (!v52) {
              goto LABEL_59;
            }
            goto LABEL_58;
          }
          cstdlib_memset(v19[1], 0, 0x200uLL);
          cstdlib_memset(v19[5], 0, 0x600uLL);
          cstdlib_memset(v19[6], 0, 0x600uLL);
          cstdlib_memset(v19[7], 0, 0xA0uLL);
          fi_net_update_param(*(void *)(NnInfo + 8));
          if (v12 <= 2) {
            unsigned int v29 = 0;
          }
          else {
            unsigned int v29 = v11 - 1;
          }
          unsigned int v30 = v11 + 1;
          goto LABEL_81;
        }
LABEL_74:
        int v48 = 10;
        goto LABEL_96;
      }
      if (v17 == 1.0 || v17 == 2.0 || v17 == 5.0)
      {
        uint64_t v56 = heap_Calloc(*(void **)(a2 + 8), 1, 88);
        if (!v56) {
          goto LABEL_74;
        }
        unsigned int v19 = (void **)v56;
        *(_DWORD *)uint64_t v56 = 1;
        *(_DWORD *)(v56 + 4) = (float)(v17 + 0.1);
        *(_OWORD *)(v56 + 8) = 0u;
        *(_OWORD *)(v56 + 24) = 0u;
        *(_OWORD *)(v56 + 40) = 0u;
        *(void *)(v56 + 56) = 0;
        fi_net_update_param(*(void *)(NnInfo + 8));
        if (v17 == 1.0)
        {
          if (v12 <= 4) {
            unsigned int v29 = 0;
          }
          else {
            unsigned int v29 = v11 - 3;
          }
          unsigned int v57 = v11 - 1;
        }
        else
        {
          unsigned int v57 = v11 - 1;
          if (v12 <= 2) {
            unsigned int v29 = 0;
          }
          else {
            unsigned int v29 = v11 - 1;
          }
        }
        if (v12 <= 2) {
          unsigned int v30 = 0;
        }
        else {
          unsigned int v30 = v57;
        }
        goto LABEL_81;
      }
      if (v17 == 6.0 || v17 == 4.0 || v17 == 3.0)
      {
        uint64_t v47 = heap_Calloc(*(void **)(a2 + 8), 1, 88);
        if (!v47) {
          goto LABEL_74;
        }
        unsigned int v19 = (void **)v47;
        *(_DWORD *)uint64_t v47 = 0;
        *(_DWORD *)(v47 + 4) = (float)(v17 + 0.1);
        *(_OWORD *)(v47 + 8) = 0u;
        *(_OWORD *)(v47 + 24) = 0u;
        *(_OWORD *)(v47 + 40) = 0u;
        *(void *)(v47 + 56) = 0;
        fi_net_update_param(*(void *)(NnInfo + 8));
        unsigned int v30 = v11 + 1;
        unsigned int v29 = v11 + 1;
LABEL_81:
        int v48 = fi_net_predict_notfree_input(*(uint64_t ***)(NnInfo + 8), (const void **)&v81, v11 + 1, &v82, v25, v26, v27, v28);
        if (!v48)
        {
          uint64_t v61 = v30 * FrameSamples;
          if (v61 + CurSampleCount <= BufSamplesCount)
          {
            if (v61)
            {
              unsigned int v62 = v82;
              unsigned int v63 = CurSampleCount;
              do
              {
                __int16 v64 = *v62++;
                *(_WORD *)(PcmBuffer + 2 * v63++) = v64;
                --v61;
              }
              while (v61);
            }
            int v65 = siren_common_synth_SetCurFrameCount(a1, v29 + CurFrameCount);
            if (v65)
            {
              int v48 = v65;
            }
            else
            {
              int v48 = siren_common_synth_SetCurSampleCount(a1, v29 * v71 + CurSampleCount);
              if (!v48) {
                goto LABEL_59;
              }
            }
          }
          else
          {
            int v48 = 9;
          }
          goto LABEL_35;
        }
LABEL_96:
        if (v48) {
          return v48 | 0x84E02000;
        }
        else {
          return 0;
        }
      }
LABEL_49:
      int v48 = 7;
      goto LABEL_96;
    }
    uint64_t v82 = 0;
    int v78 = siren_common_synth_GetFrameSamples(a1);
    int v72 = siren_common_synth_GetFrameSamples(a1);
    unsigned int v80 = siren_common_synth_GetCurSampleCount(a1);
    int v74 = siren_common_synth_GetCurFrameCount(a1);
    unsigned int v76 = siren_common_synth_GetBufSamplesCount(a1);
    uint64_t v31 = siren_common_synth_GetNnInfo(a1);
    unsigned int v32 = (float *)siren_common_synth_GetFrames(a1);
    uint64_t v33 = siren_common_synth_GetVoice(a1);
    uint64_t v34 = siren_common_synth_GetPcmBuffer(a1);
    float v35 = *v32;
    uint64_t v81 = &v32[*(_DWORD *)(v33 + 9204) * a3 + 3];
    if (v35 == 0.0)
    {
      uint64_t v36 = heap_Alloc(*(void *)(a2 + 8), 48);
      if (!v36) {
        goto LABEL_74;
      }
      unsigned int v19 = (void **)v36;
      *(_DWORD *)uint64_t v36 = 1;
      *(_DWORD *)(v36 + 4) = (float)(v35 + 0.1);
      *(void *)(v36 + 40) = 128;
      uint64_t v37 = heap_Alloc(*(void *)(a2 + 8), 128);
      v19[1] = (void *)v37;
      if (!v37
        || (uint64_t v38 = heap_Alloc(*(void *)(a2 + 8), 1536), (v19[2] = (void *)v38) == 0)
        || (uint64_t v39 = heap_Alloc(*(void *)(a2 + 8), 1536), (v19[3] = (void *)v39) == 0)
        || (uint64_t v40 = heap_Alloc(*(void *)(a2 + 8), 160), (v19[4] = (void *)v40) == 0))
      {
        int v48 = 10;
        goto LABEL_51;
      }
      cstdlib_memset(v19[1], 0, 0x80uLL);
      cstdlib_memset(v19[2], 0, 0x600uLL);
      cstdlib_memset(v19[3], 0, 0x600uLL);
      cstdlib_memset(v19[4], 0, 0xA0uLL);
      fi_net_update_param(*(void *)(v31 + 8));
      if (v12 <= 2) {
        unsigned int v45 = 0;
      }
      else {
        unsigned int v45 = v11 - 1;
      }
      unsigned int v46 = v11 + 1;
    }
    else if (v35 == 1.0 || v35 == 2.0 || v35 == 5.0)
    {
      uint64_t v58 = heap_Alloc(*(void *)(a2 + 8), 48);
      if (!v58) {
        goto LABEL_74;
      }
      unsigned int v19 = (void **)v58;
      *(_DWORD *)uint64_t v58 = 1;
      *(_DWORD *)(v58 + 4) = (float)(v35 + 0.1);
      *(_OWORD *)(v58 + 8) = 0u;
      *(_OWORD *)(v58 + 24) = 0u;
      fi_net_update_param(*(void *)(v31 + 8));
      if (v35 == 1.0)
      {
        if (v12 <= 4) {
          unsigned int v45 = 0;
        }
        else {
          unsigned int v45 = v11 - 3;
        }
        unsigned int v59 = v11 - 1;
      }
      else
      {
        unsigned int v59 = v11 - 1;
        if (v12 <= 2) {
          unsigned int v45 = 0;
        }
        else {
          unsigned int v45 = v11 - 1;
        }
      }
      if (v12 <= 2) {
        unsigned int v46 = 0;
      }
      else {
        unsigned int v46 = v59;
      }
    }
    else
    {
      if (v35 != 6.0 && v35 != 4.0 && v35 != 3.0) {
        goto LABEL_49;
      }
      uint64_t v60 = heap_Alloc(*(void *)(a2 + 8), 48);
      if (!v60) {
        goto LABEL_74;
      }
      unsigned int v19 = (void **)v60;
      *(_DWORD *)uint64_t v60 = 0;
      *(_DWORD *)(v60 + 4) = (float)(v35 + 0.1);
      *(_OWORD *)(v60 + 8) = 0u;
      *(_OWORD *)(v60 + 24) = 0u;
      fi_net_update_param(*(void *)(v31 + 8));
      unsigned int v46 = v11 + 1;
      unsigned int v45 = v11 + 1;
    }
    int v48 = fi_net_predict_notfree_input(*(uint64_t ***)(v31 + 8), (const void **)&v81, v11 + 1, &v82, v41, v42, v43, v44);
    if (v48) {
      goto LABEL_96;
    }
    uint64_t v66 = v46 * v78;
    if (v66 + v80 <= v76)
    {
      if (v66)
      {
        uint64_t v67 = v82;
        unsigned int v68 = v80;
        do
        {
          __int16 v69 = *v67++;
          *(_WORD *)(v34 + 2 * v68++) = v69;
          --v66;
        }
        while (v66);
      }
      int v70 = siren_common_synth_SetCurFrameCount(a1, v45 + v74);
      if (v70)
      {
        int v48 = v70;
      }
      else
      {
        int v48 = siren_common_synth_SetCurSampleCount(a1, v45 * v72 + v80);
        if (!v48) {
          goto LABEL_59;
        }
      }
    }
    else
    {
      int v48 = 9;
    }
LABEL_51:
    uint64_t v53 = (uint64_t)v19[1];
    if (v53) {
      heap_Free(*(void **)(a2 + 8), v53);
    }
    uint64_t v54 = (uint64_t)v19[2];
    if (v54) {
      heap_Free(*(void **)(a2 + 8), v54);
    }
    uint64_t v55 = (uint64_t)v19[3];
    if (v55) {
      heap_Free(*(void **)(a2 + 8), v55);
    }
    uint64_t v52 = (uint64_t)v19[4];
    if (!v52) {
      goto LABEL_59;
    }
LABEL_58:
    heap_Free(*(void **)(a2 + 8), v52);
LABEL_59:
    heap_Free(*(void **)(a2 + 8), (uint64_t)v19);
    goto LABEL_96;
  }
  return result;
}

uint64_t siren_nn_parallel_synth_Process(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  unsigned int FramesCount = siren_common_synth_GetFramesCount(a1);
  uint64_t result = 2229280775;
  unsigned int v10 = a4 - a3;
  if (a4 >= a3 && a1 && FramesCount > a3 && FramesCount > a4)
  {
    uint64_t v41 = 0;
    int FrameSamples = siren_common_synth_GetFrameSamples(a1);
    unsigned int CurSampleCount = siren_common_synth_GetCurSampleCount(a1);
    Curunsigned int FrameCount = siren_common_synth_GetCurFrameCount(a1);
    unsigned int BufSamplesCount = siren_common_synth_GetBufSamplesCount(a1);
    uint64_t NnInfo = siren_common_synth_GetNnInfo(a1);
    uint64_t Frames = (float *)siren_common_synth_GetFrames(a1);
    uint64_t Voice = siren_common_synth_GetVoice(a1);
    uint64_t PcmBuffer = siren_common_synth_GetPcmBuffer(a1);
    unsigned int v16 = v10 + 1;
    float v17 = *Frames;
    uint64_t v40 = &Frames[*(_DWORD *)(Voice + 9204) * a3 + 3];
    if (v17 == 0.0)
    {
      uint64_t v18 = (_DWORD *)heap_Calloc(*(void **)(a2 + 8), 1, 16);
      if (v18)
      {
        uint64_t v19 = (uint64_t)v18;
        *uint64_t v18 = 1;
        v18[1] = (float)(v17 + 0.1);
        uint64_t v20 = heap_Calloc(*(void **)(a2 + 8), 1, 160);
        *(void *)(v19 + 8) = v20;
        if (!v20)
        {
          int v28 = 10;
          goto LABEL_37;
        }
        fi_net_update_param(*(void *)(NnInfo + 8));
        goto LABEL_18;
      }
LABEL_29:
      int v25 = 10;
      return v25 | 0x84E02000;
    }
    if (v17 == 1.0 || v17 == 2.0 || v17 == 5.0)
    {
      uint64_t v26 = heap_Calloc(*(void **)(a2 + 8), 1, 16);
      if (!v26) {
        goto LABEL_29;
      }
      uint64_t v19 = v26;
      *(_DWORD *)uint64_t v26 = 1;
      *(_DWORD *)(v26 + 4) = (float)(v17 + 0.1);
      *(void *)(v26 + 8) = 0;
      fi_net_update_param(*(void *)(NnInfo + 8));
      if (v17 == 1.0)
      {
LABEL_18:
        if (v16 <= 4) {
          unsigned int v27 = 0;
        }
        else {
          unsigned int v27 = v10 - 3;
        }
        goto LABEL_25;
      }
    }
    else
    {
      if (v17 != 6.0 && v17 != 4.0 && v17 != 3.0)
      {
        int v25 = 7;
        return v25 | 0x84E02000;
      }
      uint64_t v29 = heap_Calloc(*(void **)(a2 + 8), 1, 16);
      if (!v29) {
        goto LABEL_29;
      }
      uint64_t v19 = v29;
      *(_DWORD *)uint64_t v29 = 0;
      *(_DWORD *)(v29 + 4) = (float)(v17 + 0.1);
      *(void *)(v29 + 8) = 0;
      fi_net_update_param(*(void *)(NnInfo + 8));
    }
    unsigned int v27 = v10 + 1;
LABEL_25:
    uint64_t v30 = FrameSamples * v16;
    if (v16 < 5)
    {
      unsigned int v31 = CurSampleCount;
      if (CurSampleCount + v30 > BufSamplesCount)
      {
        int v28 = 9;
        goto LABEL_37;
      }
      cstdlib_memset((void *)(PcmBuffer + 2 * CurSampleCount), 0, 2 * FrameSamples * v16);
LABEL_34:
      int v32 = siren_common_synth_SetCurFrameCount(a1, v27 + CurFrameCount);
      if (v32)
      {
        int v28 = v32;
      }
      else
      {
        int v28 = siren_common_synth_SetCurSampleCount(a1, v27 * FrameSamples + v31);
        if (!v28)
        {
LABEL_39:
          heap_Free(*(void **)(a2 + 8), v19);
          if (v28) {
            return v28 | 0x84E02000;
          }
          else {
            return 0;
          }
        }
      }
LABEL_37:
      uint64_t v33 = *(void *)(v19 + 8);
      if (v33) {
        heap_Free(*(void **)(a2 + 8), v33);
      }
      goto LABEL_39;
    }
    int v25 = fi_net_predict_notfree_input(*(uint64_t ***)(NnInfo + 8), (const void **)&v40, v10 + 1, &v41, v21, v22, v23, v24);
    if (!v25)
    {
      unsigned int v31 = CurSampleCount;
      if (CurSampleCount + v30 > BufSamplesCount)
      {
        int v28 = 9;
        goto LABEL_37;
      }
      if (v30)
      {
        uint64_t v34 = v41;
        unsigned int v35 = CurSampleCount;
        do
        {
          __int16 v36 = *v34++;
          *(_WORD *)(PcmBuffer + 2 * v35++) = v36;
          --v30;
        }
        while (v30);
      }
      goto LABEL_34;
    }
    return v25 | 0x84E02000;
  }
  return result;
}

uint64_t thread_infer_func(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int *)(a1 + 16);
  if ((int)v8 < 1) {
    return 0;
  }
  else {
    return fi_net_predict_notfree_input(*(uint64_t ***)a1, (const void **)(a1 + 8), v8, (void *)(a1 + 40), a5, a6, a7, a8);
  }
}

uint64_t SampleChunk_alloc(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = heap_Calloc(*(void **)(a1 + 8), 1, 32);
  if (!v3) {
    return 2229280778;
  }
  uint64_t v4 = v3;
  uint64_t result = 0;
  *a2 = v4;
  return result;
}

uint64_t SampleChunk_free(uint64_t a1, uint64_t a2)
{
  if (a2) {
    heap_Free(*(void **)(a1 + 8), a2);
  }
  return 0;
}

uint64_t SampleChunk_init(uint64_t a1, int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, float a7, uint64_t a8, uint64_t a9)
{
  uint64_t v23 = 0;
  int v22 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, int *))(a4 + 88))(a5, a6, &v23, &v22);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v21 = v23 + 4 * a3;
    *(void *)(a9 + 16) = v23;
    *(void *)(a9 + 24) = v21;
    if (8 * a3 == v22)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 96))(a5, a6);
      if ((result & 0x80000000) == 0)
      {
        *(float *)(a9 + 8) = a7;
        *(_DWORD *)a9 = a2;
        *(_DWORD *)(a9 + 4) = a3;
      }
    }
    else
    {
      log_OutText(*(void *)(a1 + 32), (uint64_t)"SYNTH_BET6", 4, 0, (uint64_t)"Read ThreadChunk start and end index from stream failed!, wanted bytes: %d, but available bytes in stream: %d", v18, v19, v20, 8 * a3);
      return 2229280775;
    }
  }
  return result;
}

uint64_t SampleChunk_deinit()
{
  return 0;
}

BOOL SampleChunk_isDone(int a1)
{
  return a1 == 0;
}

float SampleChunk_getEmissionType(uint64_t a1, float *a2)
{
  if (a1)
  {
    if (a2)
    {
      float result = *(float *)(a1 + 8);
      *a2 = result;
    }
  }
  return result;
}

uint64_t SampleChunk_getThreadChunkIndex(uint64_t a1, unsigned int a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t result = 2229280775;
  if (a1 && a3 && a4 && *(_DWORD *)(a1 + 4) > a2)
  {
    uint64_t result = 0;
    uint64_t v7 = *(void *)(a1 + 16);
    uint64_t v6 = *(void *)(a1 + 24);
    *a3 = *(_DWORD *)(v7 + 4 * a2);
    *a4 = *(_DWORD *)(v6 + 4 * a2);
  }
  return result;
}

uint64_t bet6_synth_Apply_Half_hannWin_Scalar_55(uint64_t a1, int a2)
{
  uint64_t v2 = 0;
  for (uint64_t i = 54; i != -1; --i)
  {
    if (a2) {
      unsigned __int16 v4 = i;
    }
    else {
      unsigned __int16 v4 = v2;
    }
    *(_WORD *)(a1 + 2 * v2) = (int)(float)(bet6_synth_Apply_Half_hannWin_Scalar_55_half_hann_scalars[v4]
                                         * (float)*(__int16 *)(a1 + 2 * v2));
    ++v2;
  }
  return 0;
}

uint64_t bet6_synth_Convolve_Float(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v5 = 7;
  if (a3 && a1 && a2 && a4)
  {
    unsigned int v6 = a2 - 1;
    if (a2 - 1 + a4)
    {
      uint64_t v7 = 0;
      unsigned int v8 = a4 - 1;
      do
      {
        int v9 = 0;
        if (v7 >= v8) {
          uint64_t v10 = v7 - v8;
        }
        else {
          uint64_t v10 = 0;
        }
        if (v7 >= v6) {
          unint64_t v11 = v6;
        }
        else {
          unint64_t v11 = v7;
        }
        if (v10 <= v11)
        {
          int v9 = 0;
          uint64_t v12 = v7 - v10;
          LODWORD(v13) = v7 - v8;
          if (v7 >= v8) {
            unint64_t v13 = v13;
          }
          else {
            unint64_t v13 = 0;
          }
          do
            v9 += (int)(float)(*(float *)(a3 + 4 * v12--) * (float)*(__int16 *)(a1 + 2 * v13));
          while (v13++ < v11);
        }
        if (v9 <= -32768) {
          int v9 = -32768;
        }
        if (v9 >= 0x7FFF) {
          int v9 = 0x7FFF;
        }
        *(_DWORD *)(a5 + 4 * v7++) = v9;
      }
      while (v7 != a2 - 1 + a4);
    }
    return 0;
  }
  return v5;
}

uint64_t bet6_synth_Convolve(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v5 = 7;
  if (a3 && a1 && a2 && a4)
  {
    unsigned int v6 = a2 - 1;
    if (a2 - 1 + a4)
    {
      uint64_t v7 = 0;
      unsigned int v8 = a4 - 1;
      do
      {
        int v9 = 0;
        if (v7 >= v8) {
          uint64_t v10 = v7 - v8;
        }
        else {
          uint64_t v10 = 0;
        }
        if (v7 >= v6) {
          unint64_t v11 = v6;
        }
        else {
          unint64_t v11 = v7;
        }
        if (v10 <= v11)
        {
          int v9 = 0;
          uint64_t v12 = v7 - v10;
          LODWORD(v13) = v7 - v8;
          if (v7 >= v8) {
            unint64_t v13 = v13;
          }
          else {
            unint64_t v13 = 0;
          }
          do
            v9 += *(__int16 *)(a3 + 2 * v12--) * *(__int16 *)(a1 + 2 * v13);
          while (v13++ < v11);
        }
        if (v9 <= -32768) {
          int v9 = -32768;
        }
        if (v9 >= 0x7FFF) {
          int v9 = 0x7FFF;
        }
        *(_DWORD *)(a5 + 4 * v7++) = v9;
      }
      while (v7 != a2 - 1 + a4);
    }
    return 0;
  }
  return v5;
}

uint64_t bet6_synth_Convolve_ReverseKernel(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v5 = 7;
  if (a3 && a1 && a2 && a4)
  {
    unsigned int v6 = a2 - 1;
    if (a2 - 1 + a4)
    {
      uint64_t v7 = 0;
      unsigned int v8 = a4 - 1;
      do
      {
        if (v7 >= v8) {
          int v9 = a4 - 1;
        }
        else {
          int v9 = v7;
        }
        if (v7 >= v8) {
          unsigned int v10 = v7 - v8;
        }
        else {
          unsigned int v10 = 0;
        }
        *(_DWORD *)(a5 + 4 * v7) = 0;
        if (v7 >= v6) {
          unint64_t v11 = v6;
        }
        else {
          unint64_t v11 = v7;
        }
        if (v10 <= v11)
        {
          int v12 = 0;
          unsigned int v13 = v8 - v9;
          LODWORD(v14) = v7 - v8;
          if (v7 >= v8) {
            unint64_t v14 = v14;
          }
          else {
            unint64_t v14 = 0;
          }
          do
            v12 += *(__int16 *)(a3 + 2 * v13++) * *(__int16 *)(a1 + 2 * v14);
          while (v14++ < v11);
          *(_DWORD *)(a5 + 4 * v7) = v12;
        }
        ++v7;
      }
      while (v7 != a2 - 1 + a4);
    }
    return 0;
  }
  return v5;
}

uint64_t bet6_synth_OverlapAdd(__int16 *a1, __int16 *a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    do
    {
      int v4 = *a2++;
      int v5 = *a1 + v4;
      if (v5 >= 0x7FFF) {
        int v5 = 0x7FFF;
      }
      if (v5 <= -32768) {
        LOWORD(v5) = 0x8000;
      }
      *a1++ = v5;
      --v3;
    }
    while (v3);
  }
  return 0;
}

uint64_t bet6_apply_fir_same_mode(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  uint64_t result = bet6_synth_Convolve_Float(a1, a2, a3, a4, a5);
  if (!result && a2)
  {
    int v10 = 0;
    unint64_t v11 = (int *)(a5 + 4 * (unsigned __int16)(a4 >> 1));
    do
    {
      int v12 = *v11++;
      *(_WORD *)(a1 + 2 * (unsigned __int16)v10++) = v12;
    }
    while (a2 > (unsigned __int16)v10);
  }
  return result;
}

uint64_t compquery_GetProductList(uint64_t a1, int a2, char *a3, int *a4)
{
  uint64_t v7 = safeh_HandleCheck(a1, a2, 348, 64);
  if ((v7 & 0x80000000) != 0) {
    return 2303729672;
  }
  uint64_t v11 = v7;
  uint64_t v12 = *(void *)(a1 + 16);
  log_OutText(*(void *)(v12 + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"Get Product List : Begin", v8, v9, v10, v19);
  if (!a4)
  {
    log_OutPublic(*(void *)(v12 + 32), (uint64_t)"COMPQUERY", 23006, 0, v13, v14, v15, v16, v20);
    return 2303729671;
  }
  int v17 = *a4;
  *a4 = 1;
  if (!a3 || !v17) {
    goto LABEL_7;
  }
  __sprintf_chk(a3, 0, 0x40uLL, "Vocalizer v%d.%d", 7, 4);
  uint64_t v11 = strhelper_SafeCpy(a3 + 64, "eng/vocalizer", 0xFFFFFFFFFFFFFFFFLL, 0x20uLL);
  if ((v11 & 0x80000000) == 0)
  {
    sprintf(a3 + 96, "%d.%d.%d", 7, 4, 0);
LABEL_7:
    log_OutText(*(void *)(v12 + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"Get Product List : End (%x, %u)", v14, v15, v16, v11);
  }
  return v11;
}

uint64_t compquery_GetCLMInfo(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char *a5)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  uint64_t v10 = 2303729671;
  uint64_t v47 = 0;
  bzero(v51, 0x800uLL);
  strcpy(v46, "CLMP");
  char v45 = 0;
  __int32 v44 = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  int v41 = 0;
  if ((safeh_HandleCheck(a1, a2, 348, 64) & 0x80000000) != 0) {
    return 2303729672;
  }
  uint64_t v14 = *(void *)(a1 + 16);
  log_OutText(*(void *)(v14 + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"GetCLMInfo : Begin (%s, %s)", v11, v12, v13, a3);
  if (a3 && a4)
  {
    uint64_t v19 = brk_ObjOpen(a3, *(void *)(a1 + 24));
    if ((v19 & 0x80000000) != 0)
    {
      uint64_t v10 = v19;
      log_OutPublic(*(void *)(v14 + 32), (uint64_t)"COMPQUERY", 23008, (uint64_t)"%s%s%s%x", v20, v21, v22, v23, "product");
    }
    else
    {
      uint64_t v24 = strhelper_SafeCpy(v51, "clm", 0xFFFFFFFFFFFFFFFFLL, 0x800uLL);
      if ((v24 & 0x80000000) != 0)
      {
        return v24;
      }
      else
      {
        uint64_t StringZ = ssftriff_reader_ObjOpen(*(_WORD **)a1, *(void *)(a1 + 8), 2, v51, v46, 1031, (uint64_t *)&v43);
        if ((StringZ & 0x80000000) == 0)
        {
          uint64_t v29 = a4 + 64;
          do
          {
            if ((ssftriff_reader_OpenChunk((uint64_t)v43, &v44, (unsigned int *)&v41, &v42) & 0x80000000) != 0) {
              break;
            }
            strcpy(__s, "source_version");
            strcpy(v48, "file_version");
            int v40 = 2048;
            uint64_t StringZ = ssftriff_reader_ReadStringZ((uint64_t)v43, v42, v41, 0, __s1, (unsigned int *)&v40);
            if ((StringZ & 0x80000000) != 0) {
              goto LABEL_28;
            }
            uint64_t v34 = cstdlib_strstr(__s1, "clmcfg");
            unsigned int v35 = v40;
            if (v34 && (v40 & 3) != 0)
            {
              unsigned int v35 = v40 - (v40 | 0xFFFFFFFC);
              int v40 = v35;
            }
            while (v35 < v41)
            {
              __s1[0] = 0;
              int v40 = 2048;
              LODWORD(v10) = ssftriff_reader_ReadStringZ((uint64_t)v43, v42, v41, v35, __s1, (unsigned int *)&v40);
              size_t v36 = cstdlib_strlen(__s);
              if (!cstdlib_strncmp(__s, __s1, v36))
              {
                uint64_t v10 = strhelper_SafeCpy(a5 + 64, __s1, 0xFFFFFFFFFFFFFFFFLL, 0x800uLL);
                if ((v10 & 0x80000000) != 0) {
                  return v10;
                }
                a5[cstdlib_strlen(__s1) + 62] = 0;
              }
              size_t v37 = cstdlib_strlen(v48);
              if (!cstdlib_strncmp(v48, __s1, v37))
              {
                uint64_t v10 = strhelper_SafeCpy(a5, __s1, 0xFFFFFFFFFFFFFFFFLL, 0x40uLL);
                if ((v10 & 0x80000000) != 0) {
                  return v10;
                }
                a5[cstdlib_strlen(__s1) - 1] = 0;
              }
              if (!LH_strnicmp(v29, (uint64_t)__s1, 3uLL))
              {
                uint64_t v24 = strhelper_SafeCpy(a5 + 2112, __s1, 0xFFFFFFFFFFFFFFFFLL, 0x800uLL);
                if ((v24 & 0x80000000) != 0) {
                  return v24;
                }
                a5[cstdlib_strlen(__s1) + 2111] = 0;
                break;
              }
              if ((v10 & 0x80000000) != 0) {
                break;
              }
              v35 += v40;
            }
            uint64_t StringZ = ssftriff_reader_CloseChunk((uint64_t)v43);
            if ((StringZ & 0x80000000) != 0) {
              goto LABEL_28;
            }
          }
          while (!v34);
          uint64_t StringZ = ssftriff_reader_ObjClose(v43, v30, v31, v32, v33, v26, v27, v28);
        }
LABEL_28:
        uint64_t v10 = StringZ;
        if (v47) {
          brk_ObjClose(v47);
        }
        log_OutText(*(void *)(v14 + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"GetCLMInfo : End (%x)", v26, v27, v28, v10);
      }
    }
  }
  else
  {
    log_OutPublic(*(void *)(v14 + 32), (uint64_t)"COMPQUERY", 23013, 0, v15, v16, v17, v18, v39);
  }
  return v10;
}

uint64_t compquery_GetNTSInfo(uint64_t a1, int a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  uint64_t v44 = 0;
  unsigned int v43 = 0;
  uint64_t v9 = 2303729671;
  uint64_t v38 = 0;
  memset(__n, 0, sizeof(__n));
  if ((safeh_HandleCheck(a1, a2, 348, 64) & 0x80000000) != 0) {
    return 2303729672;
  }
  *(_OWORD *)__src = 0u;
  long long v42 = 0u;
  long long __b = 0u;
  long long v40 = 0u;
  uint64_t v13 = *(void *)(a1 + 16);
  log_OutText(*(void *)(v13 + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"GetNTSInfoList : Begin (%s, %s)", v10, v11, v12, a3);
  if (!a3 || !a4)
  {
    log_OutPublic(*(void *)(v13 + 32), (uint64_t)"COMPQUERY", 23013, 0, v14, v15, v16, v17, v34);
    return v9;
  }
  int v36 = 0;
  uint64_t v35 = 0;
  uint64_t v18 = brk_ObjOpen(a3, *(void *)(a1 + 24));
  if ((v18 & 0x80000000) != 0)
  {
    uint64_t v32 = v18;
    log_OutPublic(*(void *)(v13 + 32), (uint64_t)"COMPQUERY", 23008, (uint64_t)"%s%s%s%x", v19, v20, v21, v22, "product");
    return v32;
  }
  cstdlib_memset(&__b, 0, 0x40uLL);
  set_DctBrk((uint64_t)&__b, v44);
  DctRouint64_t m = open_DctRom((uint64_t *)&__b, (uint64_t)"sysdct", &v43);
  if ((DctRom & 0x80000000) != 0
    || (DctRouint64_t m = brk_DataOpenEx(v44, (uint64_t)"sysdct", 1, (uint64_t)&v38), (DctRom & 0x80000000) != 0)
    || (DctRouint64_t m = query_DctRom((uint64_t)&__b, "ntscfg", v43, v38, &__n[3]), (DctRom & 0x80000000) != 0))
  {
    uint64_t v28 = 0;
    goto LABEL_20;
  }
  uint64_t v27 = heap_Calloc(*(void **)(v13 + 8), 1, 144);
  uint64_t v28 = v27;
  if (!v27) {
    goto LABEL_35;
  }
  *(void *)&long long v40 = v27;
  DctRouint64_t m = init_DctRom((uint64_t)&__b, "ntscfg", v43, v38);
  if ((DctRom & 0x80000000) != 0 && (DctRom & 0x1FFF) != 0x14)
  {
LABEL_20:
    uint64_t v9 = DctRom;
    goto LABEL_21;
  }
  MaxOutLeuint64_t n = GetMaxOutLen((uint64_t)&__b);
  GetFieldSeparator((uint64_t)&__b);
  if (MaxOutLen)
  {
    __src[1] = (void *)heap_Calloc(*(void **)(v13 + 8), 1, MaxOutLen + 1);
    if (__src[1])
    {
      __n[2] = 0;
      __n[0] = 0;
      size_t v30 = cstdlib_strlen("nts_");
      DctRouint64_t m = strhelper_SafeCpy(__s, "nts_", v30, 8uLL);
      if ((DctRom & 0x80000000) == 0)
      {
        size_t v31 = cstdlib_strlen((const char *)(a4 + 64));
        DctRouint64_t m = strhelper_SafeCat(__s, (char *)(a4 + 64), v31, 8uLL);
        if ((DctRom & 0x80000000) == 0)
        {
          __n[1] = cstdlib_strlen(__s) - 1;
          uint64_t v35 = 0;
          LOWORD(v36) = 0;
          uint64_t v9 = DctLookup((uint64_t)&__b, (uint64_t)__s, &__n[2], &__n[1], 1, __n, (uint64_t)&v35);
          if (!v9)
          {
            cstdlib_memcpy(a5, __src[1], __n[0]);
            *((unsigned char *)a5 + __n[0]) = 0;
          }
          goto LABEL_21;
        }
      }
      goto LABEL_20;
    }
LABEL_35:
    uint64_t v9 = 2303729674;
  }
LABEL_21:
  if (v44)
  {
    if (__src[1]) {
      heap_Free(*(void **)(v13 + 8), (uint64_t)__src[1]);
    }
    if (v38 && __src[0]) {
      exit_DctRom((uint64_t)&__b, v38);
    }
    if (v28) {
      heap_Free(*(void **)(v13 + 8), v28);
    }
    if (v38) {
      brk_DataClose(v44, v38);
    }
    close_DctRom((uint64_t)&__b);
    brk_ObjClose(v44);
  }
  log_OutText(*(void *)(v13 + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"GetNTSInfoList : End (%x)", v24, v25, v26, v9);
  return v9;
}

uint64_t compquery_GetLanguageList(uint64_t a1, int a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v85 = *MEMORY[0x263EF8340];
  uint64_t v79 = 0;
  uint64_t v80 = 0;
  uint64_t v9 = 2303729674;
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  __src = 0;
  if ((safeh_HandleCheck(a1, a2, 348, 64) & 0x80000000) != 0) {
    return 2303729672;
  }
  long long v83 = 0u;
  memset(v84, 0, 22);
  memset(__b, 0, sizeof(__b));
  uint64_t v14 = *(void **)(a1 + 16);
  if (!a3 || !a5)
  {
    log_OutPublic(v14[4], (uint64_t)"COMPQUERY", 23007, 0, v10, v11, v12, v13, v72);
    return 2303729671;
  }
  uint64_t v81 = 0;
  log_OutText(v14[4], (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"Get Language List : Begin (%s)", v11, v12, v13, a3);
  if (*a5) {
    uint64_t v15 = a4;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v16 = brk_ObjOpen(a3, *(void *)(a1 + 24));
  if ((v16 & 0x80000000) != 0)
  {
    uint64_t v21 = v16;
    log_OutPublic(v14[4], (uint64_t)"COMPQUERY", 23008, (uint64_t)"%s%s%s%x", v17, v18, v19, v20, "product");
    return v21;
  }
  uint64_t v21 = brk_ComponentTableIteratorOpen(v81, (uint64_t)"pipeline/*", (uint64_t)&v80);
  if ((v21 & 0x80000000) != 0)
  {
    brk_ObjClose(v81);
    log_OutPublic(v14[4], (uint64_t)"COMPQUERY", 23009, (uint64_t)"%s%s%s%x", v59, v60, v61, v62, "product");
    return v21;
  }
  uint64_t v22 = (void *)v14[1];
  *(_OWORD *)long long __s1 = xmmword_220786210;
  uint64_t v75 = 0;
  if (!vector_ObjOpen(v22, (long long *)__s1, 4, &v77)) {
    goto LABEL_66;
  }
  uint64_t v23 = "PARAMETERS/*";
  uint64_t v24 = (char *)v84;
  while (2)
  {
    unsigned int v25 = brk_ComponentTableIteratorNext(v80);
    if ((v25 & 0x80000000) != 0)
    {
      unsigned int v63 = v25;
      if (v15 && *a5)
      {
        unsigned int Size = vector_GetSize(v77);
        uint64_t v21 = Size <= *a5 ? v21 : 2303729673;
        unsigned int v65 = Size >= *a5 ? *a5 : Size;
        if (v65)
        {
          unsigned int v66 = 0;
          int v67 = 0;
          do
          {
            vector_GetElemAt(v77, v66, &__src);
            cstdlib_memcpy((void *)(v15 + 86 * (unsigned __int16)v67++), __src, 0x56uLL);
            unsigned int v66 = (unsigned __int16)v67;
          }
          while (v65 > (unsigned __int16)v67);
        }
      }
      *a5 = vector_GetSize(v77);
      vector_ObjClose(v77);
      brk_ComponentTableIteratorClose(v80);
      brk_ObjClose(v81);
      log_OutText(v14[4], (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"Get Language List : End (%x, %u)", v68, v69, v70, v21);
      if ((v63 & 0x1FFF) == 0xA) {
        return v63;
      }
      else {
        return v21;
      }
    }
    cstdlib_memset(__b, 0, 0x56uLL);
    if ((brk_TagIteratorOpen(v14[3], v79, v23, 1, &v78) & 0x80000000) != 0) {
      goto LABEL_33;
    }
    __s = 0;
    __s1[0] = 0;
    while ((brk_TagIteratorNext(v78, (uint64_t)__s1, (uint64_t)&__s) & 0x80000000) == 0)
    {
      if (__s1[0])
      {
        if (cstdlib_strcmp(__s1[0], "language"))
        {
          if (cstdlib_strcmp(__s1[0], "langcode"))
          {
            if (cstdlib_strcmp(__s1[0], "langversion"))
            {
              if (!cstdlib_strcmp(__s1[0], "langid")) {
                v84[10] = (unsigned __int16)LH_atou(__s);
              }
            }
            else
            {
              size_t v37 = cstdlib_strlen(__s);
              uint64_t v27 = __s;
              if (v37 <= 0xB)
              {
                uint64_t v28 = (char *)&v84[4];
                size_t v29 = 12;
                goto LABEL_28;
              }
              cstdlib_strncpy((char *)&v84[4], __s, 0xBuLL);
              HIBYTE(v84[9]) = 0;
              uint64_t v44 = v14[4];
              unsigned int v45 = __s;
              cstdlib_strlen(__s);
              log_OutPublic(v44, (uint64_t)"COMPQUERY", 23014, (uint64_t)"Language version string \"%s\" too long (%lu - max is %lu)", v46, v47, v48, v49, v45);
            }
          }
          else
          {
            size_t v30 = cstdlib_strlen(__s);
            uint64_t v27 = __s;
            if (v30 <= 7)
            {
              uint64_t v28 = v24;
              size_t v29 = 8;
              goto LABEL_28;
            }
            cstdlib_strncpy(v24, __s, 7uLL);
            HIBYTE(v84[3]) = 0;
            uint64_t v38 = v14[4];
            unsigned int v39 = __s;
            cstdlib_strlen(__s);
            log_OutPublic(v38, (uint64_t)"COMPQUERY", 23014, (uint64_t)"Language code \"%s\" too long (%lu - max is %lu)", v40, v41, v42, v43, v39);
          }
        }
        else
        {
          size_t v26 = cstdlib_strlen(__s);
          uint64_t v27 = __s;
          if (v26 > 0x3F)
          {
            cstdlib_strncpy((char *)__b, __s, 0x3FuLL);
            HIBYTE(v83) = 0;
            uint64_t v31 = v14[4];
            unsigned int v32 = __s;
            cstdlib_strlen(__s);
            log_OutPublic(v31, (uint64_t)"COMPQUERY", 23014, (uint64_t)"Language string \"%s\" too long (%lu - max is %lu)", v33, v34, v35, v36, v32);
          }
          else
          {
            uint64_t v28 = (char *)__b;
            size_t v29 = 64;
LABEL_28:
            uint64_t v21 = strhelper_SafeCpy(v28, v27, 0xFFFFFFFFFFFFFFFFLL, v29);
            if ((v21 & 0x80000000) != 0) {
              return v21;
            }
          }
        }
      }
    }
    brk_TagIteratorClose(v78);
    uint64_t v78 = 0;
LABEL_33:
    uint64_t v50 = v77;
    __s1[0] = 0;
    if (v77)
    {
      unsigned int v51 = vector_GetSize(v77);
      if (!v51) {
        goto LABEL_70;
      }
      unsigned int v52 = v51;
      uint64_t v53 = v24;
      uint64_t v54 = v23;
      unsigned int v55 = 1;
      do
      {
        vector_GetElemAt(v50, v55 - 1, __s1);
        int v56 = LH_stricmp((char *)__b, __s1[0]);
        if (v56) {
          BOOL v57 = v55 >= v52;
        }
        else {
          BOOL v57 = 1;
        }
        ++v55;
      }
      while (!v57);
      uint64_t v23 = v54;
      uint64_t v24 = v53;
      if (v56)
      {
LABEL_70:
        if (!vector_Add(v50, __b))
        {
          uint64_t v58 = v77;
          goto LABEL_65;
        }
      }
      continue;
    }
    break;
  }
  uint64_t v58 = 0;
LABEL_65:
  vector_ObjClose(v58);
  brk_ComponentTableIteratorClose(v80);
LABEL_66:
  brk_ObjClose(v81);
  return v9;
}

uint64_t compquery_GetVoiceList(uint64_t a1, int a2, uint64_t a3, char *a4, uint64_t a5, unsigned int *a6)
{
  uint64_t v77 = *MEMORY[0x263EF8340];
  uint64_t v70 = 0;
  uint64_t v71 = 0;
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  uint64_t v11 = 2303729674;
  __src = 0;
  if ((safeh_HandleCheck(a1, a2, 348, 64) & 0x80000000) != 0) {
    return 2303729672;
  }
  uint64_t v76 = 0;
  memset(v75, 0, sizeof(v75));
  memset(v74, 0, sizeof(v74));
  memset(__b, 0, sizeof(__b));
  uint64_t v16 = *(void **)(a1 + 16);
  if (!a3 || !a4 || !a6)
  {
    log_OutPublic(v16[4], (uint64_t)"COMPQUERY", 23013, 0, v12, v13, v14, v15, v58);
    return 2303729671;
  }
  uint64_t v72 = 0;
  log_OutText(v16[4], (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"Get Voice List : Begin (%s, %s)", v13, v14, v15, a3);
  if (*a6) {
    uint64_t v17 = a5;
  }
  else {
    uint64_t v17 = 0;
  }
  uint64_t v18 = brk_ObjOpen(a3, *(void *)(a1 + 24));
  if ((v18 & 0x80000000) != 0)
  {
    uint64_t v23 = v18;
    log_OutPublic(v16[4], (uint64_t)"COMPQUERY", 23008, (uint64_t)"%s%s%s%x", v19, v20, v21, v22, "product");
    return v23;
  }
  uint64_t v23 = brk_ComponentTableIteratorOpen(v72, (uint64_t)"pipeline/*", (uint64_t)&v71);
  if ((v23 & 0x80000000) != 0)
  {
    brk_ObjClose(v72);
    log_OutPublic(v16[4], (uint64_t)"COMPQUERY", 23010, (uint64_t)"%s%s%s%x", v49, v50, v51, v52, "product");
    return v23;
  }
  uint64_t v24 = (void *)v16[1];
  *(_OWORD *)long long __s1 = xmmword_220786228;
  uint64_t v66 = 0;
  if (!vector_ObjOpen(v24, (long long *)__s1, 4, &v68))
  {
    brk_ObjClose(v72);
    return v11;
  }
  uint64_t v60 = a6;
  uint64_t v61 = v17;
  uint64_t v59 = v23;
  if ((brk_ComponentTableIteratorNext(v71) & 0x80000000) != 0) {
    goto LABEL_47;
  }
  uint64_t v62 = v16;
  unsigned int v25 = (char *)v75;
  size_t v26 = "PARAMETERS/*";
  uint64_t v27 = "gender";
  uint64_t v28 = "voiceversion";
  unsigned int v63 = a4;
  do
  {
    cstdlib_memset(__b, 0, 0xC8uLL);
    if ((brk_TagIteratorOpen(v16[3], v70, v26, 1, &v69) & 0x80000000) != 0) {
      goto LABEL_34;
    }
    __int16 v64 = 0;
    __s1[0] = 0;
    while ((brk_TagIteratorNext(v69, (uint64_t)__s1, (uint64_t)&v64) & 0x80000000) == 0)
    {
      if (__s1[0])
      {
        if (!cstdlib_strcmp(__s1[0], "voice"))
        {
          size_t v29 = v64;
          size_t v30 = (char *)__b;
          size_t v31 = 31;
          goto LABEL_31;
        }
        if (!cstdlib_strcmp(__s1[0], "language"))
        {
          size_t v29 = v64;
          size_t v30 = v74;
          goto LABEL_27;
        }
        if (!cstdlib_strcmp(__s1[0], "age"))
        {
LABEL_28:
          size_t v29 = v64;
          size_t v30 = v25;
LABEL_29:
          size_t v31 = 11;
          goto LABEL_31;
        }
        if (cstdlib_strcmp(__s1[0], v27))
        {
          if (!cstdlib_strcmp(__s1[0], "age")) {
            goto LABEL_28;
          }
          if (!cstdlib_strcmp(__s1[0], v28))
          {
            size_t v29 = v64;
            size_t v30 = (char *)&v75[1] + 12;
            goto LABEL_29;
          }
          if (!cstdlib_strcmp(__s1[0], "noclmset"))
          {
            size_t v29 = v64;
            size_t v30 = (char *)&v75[2] + 8;
LABEL_27:
            size_t v31 = 63;
            goto LABEL_31;
          }
        }
        else
        {
          size_t v30 = (char *)v75 + 12;
          size_t v29 = v64;
          size_t v31 = 15;
LABEL_31:
          cstdlib_strncpy(v30, v29, v31);
        }
      }
    }
    brk_TagIteratorClose(v69);
    uint64_t v69 = 0;
LABEL_34:
    if (LH_stricmp(a4, v74)) {
      continue;
    }
    unsigned int v32 = v28;
    uint64_t v33 = v27;
    uint64_t v34 = v68;
    __s1[0] = 0;
    if (!v68)
    {
      uint64_t v56 = 0;
LABEL_69:
      vector_ObjClose(v56);
      brk_ComponentTableIteratorClose(v71);
      brk_ObjClose(v72);
      return 2303729674;
    }
    uint64_t v35 = v26;
    unsigned int Size = vector_GetSize(v68);
    if (Size)
    {
      unsigned int v37 = Size;
      uint64_t v38 = v25;
      unsigned int v39 = 1;
      do
      {
        vector_GetElemAt(v34, v39 - 1, __s1);
        if (LH_stricmp((char *)__b, __s1[0]))
        {
          BOOL v40 = 0;
        }
        else
        {
          BOOL v40 = LH_stricmp(v74, __s1[0] + 32) == 0;
          if (v40) {
            break;
          }
        }
      }
      while (v39++ < v37);
      unsigned int v25 = v38;
      uint64_t v16 = v62;
      a4 = v63;
      if (v40)
      {
        size_t v26 = v35;
        uint64_t v27 = v33;
        uint64_t v28 = v32;
        continue;
      }
    }
    int v42 = vector_Add(v34, __b);
    size_t v26 = v35;
    uint64_t v27 = v33;
    uint64_t v28 = v32;
    if (!v42)
    {
      uint64_t v56 = v68;
      goto LABEL_69;
    }
  }
  while ((brk_ComponentTableIteratorNext(v71) & 0x80000000) == 0);
LABEL_47:
  if (v61)
  {
    uint64_t v44 = v59;
    uint64_t v43 = v60;
    if (*v60)
    {
      unsigned int v45 = vector_GetSize(v68);
      if (v45 <= *v60) {
        uint64_t v44 = v59;
      }
      else {
        uint64_t v44 = 2303729673;
      }
      if (v45 >= *v60) {
        unsigned int v46 = *v60;
      }
      else {
        unsigned int v46 = v45;
      }
      if (v46)
      {
        unsigned int v47 = 0;
        int v48 = 0;
        do
        {
          vector_GetElemAt(v68, v47, &__src);
          cstdlib_memcpy((void *)(v61 + 200 * (unsigned __int16)v48++), __src, 0xC8uLL);
          unsigned int v47 = (unsigned __int16)v48;
        }
        while (v46 > (unsigned __int16)v48);
      }
    }
  }
  else
  {
    uint64_t v44 = v59;
    uint64_t v43 = v60;
  }
  *uint64_t v43 = vector_GetSize(v68);
  vector_ObjClose(v68);
  brk_ComponentTableIteratorClose(v71);
  brk_ObjClose(v72);
  log_OutText(v16[4], (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"Get Voice List : End (%x, %u)", v53, v54, v55, v44);
  return v44;
}

uint64_t compquery_GetDocTypeList(uint64_t a1, int a2, uint64_t a3, char *a4, char *a5, _DWORD *a6)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  unsigned int v45 = 0;
  uint64_t v46 = 0;
  uint64_t v11 = 2303729671;
  uint64_t v44 = 0;
  if ((safeh_HandleCheck(a1, a2, 348, 64) & 0x80000000) != 0) {
    return 2303729672;
  }
  uint64_t v51 = 0;
  long long v50 = 0u;
  memset(v49, 0, sizeof(v49));
  memset(__b, 0, sizeof(__b));
  uint64_t v15 = *(void *)(a1 + 16);
  log_OutText(*(void *)(v15 + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"Get Document List : Begin (%s, %s)", v12, v13, v14, a3);
  if (a3 && a4 && a6)
  {
    uint64_t v47 = 0;
    if (*a6) {
      uint64_t v20 = a5;
    }
    else {
      uint64_t v20 = 0;
    }
    uint64_t v21 = brk_ObjOpen(a3, *(void *)(a1 + 24));
    if ((v21 & 0x80000000) != 0)
    {
      uint64_t v11 = v21;
      log_OutPublic(*(void *)(v15 + 32), (uint64_t)"COMPQUERY", 23008, (uint64_t)"%s%s%s%x", v22, v23, v24, v25, "product");
    }
    else
    {
      uint64_t v11 = brk_ComponentTableIteratorOpen(v47, (uint64_t)"pipeline/*", (uint64_t)&v46);
      if ((v11 & 0x80000000) == 0)
      {
        uint64_t v26 = 0;
        if ((brk_ComponentTableIteratorNext(v46) & 0x80000000) != 0) {
          goto LABEL_44;
        }
        while (1)
        {
          cstdlib_memset(__b, 0, 0xB8uLL);
          uint64_t v27 = strhelper_SafeCpy((char *)__b, "text", 0xFFFFFFFFFFFFFFFFLL, 0x20uLL);
          if ((v27 & 0x80000000) != 0) {
            return v27;
          }
          uint64_t v11 = strhelper_SafeCpy((char *)&v49[4] + 12, "Nuance Communications, Inc.", 0xFFFFFFFFFFFFFFFFLL, 0x40uLL);
          if ((v11 & 0x80000000) != 0) {
            return v11;
          }
          if ((brk_TagIteratorOpen(*(void *)(v15 + 24), v45, "PARAMETERS/*", 1, &v44) & 0x80000000) != 0) {
            goto LABEL_24;
          }
          int v42 = 0;
          long long __s1 = 0;
          while ((brk_TagIteratorNext(v44, (uint64_t)&__s1, (uint64_t)&v42) & 0x80000000) == 0)
          {
            if (__s1)
            {
              if (!cstdlib_strcmp(__s1, "language"))
              {
                uint64_t v28 = v42;
                size_t v29 = (char *)v49;
                size_t v30 = 64;
                goto LABEL_21;
              }
              if (!cstdlib_strcmp(__s1, "langversion"))
              {
                uint64_t v28 = v42;
                size_t v29 = (char *)&v50 + 12;
                size_t v30 = 12;
LABEL_21:
                uint64_t v11 = strhelper_SafeCpy(v29, v28, 0xFFFFFFFFFFFFFFFFLL, v30);
                if ((v11 & 0x80000000) != 0) {
                  return v11;
                }
              }
            }
          }
          brk_TagIteratorClose(v44);
          uint64_t v44 = 0;
LABEL_24:
          if (!LH_stricmp(a4, (char *)v49))
          {
            if (v20)
            {
              size_t v31 = v20;
              uint64_t v32 = v26;
              if (v26)
              {
                uint64_t v26 = v26;
                while (LH_stricmp((char *)__b, v20) || LH_stricmp((char *)v49, v20 + 32))
                {
                  v20 += 184;
                  if (!--v26) {
                    goto LABEL_31;
                  }
                }
                uint64_t v20 = v31;
                uint64_t v26 = v32;
                goto LABEL_37;
              }
LABEL_31:
              if (*a6)
              {
                LODWORD(v26) = v32;
                uint64_t v20 = v31;
                if (v32 >= *a6) {
                  uint64_t v11 = 9;
                }
                else {
                  cstdlib_memcpy(&v31[184 * v32], __b, 0xB8uLL);
                }
              }
              else
              {
                uint64_t v20 = v31;
                LODWORD(v26) = v32;
              }
            }
            uint64_t v26 = (v26 + 1);
          }
LABEL_37:
          if ((brk_ComponentTableIteratorNext(v46) & 0x80000000) != 0)
          {
LABEL_44:
            *a6 = v26;
            brk_ComponentTableIteratorClose(v46);
            brk_ObjClose(v47);
            log_OutText(*(void *)(v15 + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"Get Document List : End (%x, %u)", v37, v38, v39, v11);
            return v11;
          }
        }
      }
      brk_ObjClose(v47);
      log_OutPublic(*(void *)(v15 + 32), (uint64_t)"COMPQUERY", 23011, (uint64_t)"%s%s%s%x", v33, v34, v35, v36, "product");
    }
  }
  else
  {
    log_OutPublic(*(void *)(v15 + 32), (uint64_t)"COMPQUERY", 23014, 0, v16, v17, v18, v19, v41);
  }
  return v11;
}

uint64_t compquery_GetSpeechDBList(uint64_t a1, int a2, uint64_t a3, char *a4, char *a5, char *a6, unsigned int *a7)
{
  uint64_t v61 = *MEMORY[0x263EF8340];
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  uint64_t v54 = 0;
  if ((safeh_HandleCheck(a1, a2, 348, 64) & 0x80000000) != 0) {
    return 2303729672;
  }
  memset(v60, 0, 78);
  memset(v59, 0, sizeof(v59));
  memset(__b, 0, sizeof(__b));
  uint64_t v16 = *(void *)(a1 + 16);
  log_OutText(*(void *)(v16 + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"Get Speech DB List : Begin (%s, %s, %s)", v13, v14, v15, a3);
  if (!a4 || !a3 || !a5 || !a7)
  {
    log_OutPublic(*(void *)(v16 + 32), (uint64_t)"COMPQUERY", 23016, 0, v17, v18, v19, v20, v47);
    return 2303729671;
  }
  uint64_t v57 = 0;
  if (*a7) {
    uint64_t v21 = a6;
  }
  else {
    uint64_t v21 = 0;
  }
  uint64_t v22 = brk_ObjOpen(a3, *(void *)(a1 + 24));
  if ((v22 & 0x80000000) != 0)
  {
    uint64_t v27 = v22;
    log_OutPublic(*(void *)(v16 + 32), (uint64_t)"COMPQUERY", 23008, (uint64_t)"%s%s%s%x", v23, v24, v25, v26, "product");
    return v27;
  }
  uint64_t v27 = brk_ComponentTableIteratorOpen(v57, (uint64_t)"pipeline/*", (uint64_t)&v56);
  if ((v27 & 0x80000000) != 0)
  {
    brk_ObjClose(v57);
    log_OutPublic(*(void *)(v16 + 32), (uint64_t)"COMPQUERY", 23010, (uint64_t)"%s%s%s%x", v37, v38, v39, v40, "product");
    return v27;
  }
  if (v21 && (uint64_t v28 = *a7, v28))
  {
    uint64_t v29 = heap_Calloc(*(void **)(v16 + 8), v28, 176);
    if (!v29) {
      return 2303729674;
    }
  }
  else
  {
    uint64_t v29 = 0;
  }
  if ((brk_ComponentTableIteratorNext(v56) & 0x80000000) == 0)
  {
    unsigned int v30 = 0;
    uint64_t v48 = v29 + 96;
    while (1)
    {
      cstdlib_memset(__b, 0, 0xAEuLL);
      if ((brk_TagIteratorOpen(*(void *)(v16 + 24), v55, "PARAMETERS/*", 1, &v54) & 0x80000000) == 0)
      {
        uint64_t v51 = 0;
        long long __s1 = 0;
        while (1)
        {
          while (1)
          {
            do
            {
              if ((brk_TagIteratorNext(v54, (uint64_t)&__s1, (uint64_t)&v51) & 0x80000000) != 0)
              {
                brk_TagIteratorClose(v54);
                uint64_t v54 = 0;
                goto LABEL_41;
              }
            }
            while (!__s1);
            if (cstdlib_strcmp(__s1, "language")) {
              break;
            }
            size_t v31 = v51;
            uint64_t v32 = (char *)__b;
            size_t v33 = 64;
LABEL_38:
            uint64_t v27 = strhelper_SafeCpy(v32, v31, 0xFFFFFFFFFFFFFFFFLL, v33);
            if ((v27 & 0x80000000) != 0) {
              return v27;
            }
          }
          if (!cstdlib_strcmp(__s1, "voice"))
          {
            size_t v31 = v51;
            uint64_t v32 = v59;
LABEL_37:
            size_t v33 = 32;
            goto LABEL_38;
          }
          if (!cstdlib_strcmp(__s1, "vopversion"))
          {
            uint64_t v32 = (char *)v60;
            size_t v31 = v51;
            size_t v33 = 12;
            goto LABEL_38;
          }
          if (!cstdlib_strcmp(__s1, "voicemodel"))
          {
            size_t v31 = v51;
            uint64_t v32 = (char *)v60 + 12;
            goto LABEL_37;
          }
          if (!cstdlib_strcmp(__s1, "voiceoperatingpoint"))
          {
            size_t v31 = v51;
            uint64_t v32 = (char *)&v60[2] + 12;
            goto LABEL_37;
          }
          if (!cstdlib_strcmp(__s1, "frequencyhz")) {
            WORD6(v60[4]) = LH_atou(v51) / 0x3E8;
          }
        }
      }
LABEL_41:
      __int16 v53 = 0;
      compquery_loc_BrkTagQueryU16(*(void *)(v16 + 24), (uint64_t)v55, &v53);
      if (!LH_stricmp(a4, (char *)__b) && !LH_stricmp(a5, v59)) {
        break;
      }
LABEL_62:
      if ((brk_ComponentTableIteratorNext(v56) & 0x80000000) != 0)
      {
        if (v29)
        {
          uint64_t v41 = v30;
          ssft_qsort(v29, v30, 176, (uint64_t (*)(unint64_t, unint64_t))compare_speechdbinfoprio);
          if (v30)
          {
            int v42 = (char *)v29;
            do
            {
              cstdlib_memcpy(v21, v42, 0xAEuLL);
              v21 += 174;
              v42 += 176;
              --v41;
            }
            while (v41);
          }
LABEL_68:
          heap_Free(*(void **)(v16 + 8), v29);
        }
        goto LABEL_75;
      }
    }
    unsigned int v50 = v30;
    uint64_t v49 = v29;
    if (v29 && v30)
    {
      uint64_t v34 = v30;
      uint64_t v35 = v48;
      while (LH_stricmp((char *)__b, (char *)(v35 - 96))
           || LH_stricmp(v59, (char *)(v35 - 32))
           || LH_stricmp((char *)v60 + 12, (char *)(v35 + 12))
           || LH_stricmp((char *)&v60[2] + 12, (char *)(v35 + 44))
           || LH_stricmp((char *)v60, (char *)v35)
           || WORD6(v60[4]) != *(unsigned __int16 *)(v35 + 76))
      {
        v35 += 176;
        if (!--v34) {
          goto LABEL_53;
        }
      }
      uint64_t v29 = v49;
      unsigned int v30 = v50;
      goto LABEL_62;
    }
LABEL_53:
    if (v21)
    {
      unsigned int v36 = v50;
      if (!*a7)
      {
        uint64_t v29 = v49;
        goto LABEL_61;
      }
      uint64_t v29 = v49;
      if (v50 >= *a7)
      {
        uint64_t v27 = 9;
        goto LABEL_61;
      }
      cstdlib_memcpy((void *)(v49 + 176 * v50), __b, 0xAEuLL);
      *(_WORD *)(v49 + 176 * v50 + 174) = v53;
    }
    else
    {
      uint64_t v29 = v49;
    }
    unsigned int v36 = v50;
LABEL_61:
    unsigned int v30 = v36 + 1;
    goto LABEL_62;
  }
  if (v29)
  {
    ssft_qsort(v29, 0, 176, (uint64_t (*)(unint64_t, unint64_t))compare_speechdbinfoprio);
    unsigned int v30 = 0;
    goto LABEL_68;
  }
  unsigned int v30 = 0;
LABEL_75:
  *a7 = v30;
  brk_ComponentTableIteratorClose(v56);
  brk_ObjClose(v57);
  log_OutText(*(void *)(v16 + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"Get Speech DB List : End (%x, %u)", v43, v44, v45, v27);
  return v27;
}

uint64_t compquery_loc_BrkTagQueryU16(uint64_t a1, uint64_t a2, _WORD *a3)
{
  unsigned int v6 = 0;
  uint64_t result = brk_TagQueryEx(a1, a2, (uint64_t)"PRIORITY", 1, (uint64_t)&v6);
  if ((result & 0x80000000) != 0 || (uint64_t result = (uint64_t)v6) == 0)
  {
    *a3 = 0;
  }
  else
  {
    *a3 = (unsigned __int16)LH_atou(v6);
    return brk_TagRelease(a1, (uint64_t)v6);
  }
  return result;
}

uint64_t compare_speechdbinfoprio(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int16 *)(a2 + 174) - *(unsigned __int16 *)(a1 + 174);
}

uint64_t compquery_FindVoice(uint64_t a1, int a2, uint64_t a3, uint64_t a4, void *a5)
{
  return compquery_RescanIfNeededAndFindVoice(a1, a2, a3, a4, a5, 1);
}

uint64_t compquery_RescanIfNeededAndFindVoice(uint64_t a1, int a2, uint64_t a3, uint64_t a4, void *a5, int a6)
{
  uint64_t Voice = compquery_loc_FindVoice(a1, a2, a3, a4, a5, a6);
  if ((Voice & 0x80000000) != 0)
  {
    uint64_t v21 = 0;
    if ((safeh_HandleCheck(a1, a2, 348, 64) & 0x80000000) != 0)
    {
      return 2303729672;
    }
    else if (*(_DWORD *)(a1 + 40))
    {
      uint64_t v14 = critsec_Enter(*(void **)(a1 + 56));
      if ((v14 & 0x80000000) != 0)
      {
        return v14;
      }
      else
      {
        uint64_t v21 = osspi_time(*(void *)(*(void *)(a1 + 16) + 64), &v21);
        uint64_t v18 = v21 - *(void *)(a1 + 48);
        if (v18 > *(unsigned int *)(a1 + 40))
        {
          log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"Find Voice : Time for a rescan. Delta (%ld) seconds", v15, v16, v17, v18);
          if ((brk_ClassUpdate(*(void *)(a1 + 24)) & 0x80000000) == 0)
          {
            LODWORD(Voice) = compquery_loc_FindVoice(a1, a2, a3, a4, a5, a6);
            *(void *)(a1 + 48) = v21;
          }
        }
        int v19 = critsec_Leave(*(void **)(a1 + 56));
        if ((int)Voice > -1 && v19 < 0) {
          return v19;
        }
        else {
          return Voice;
        }
      }
    }
  }
  return Voice;
}

uint64_t compquery_FindVoiceEx(uint64_t a1, int a2, uint64_t a3, uint64_t a4, void *a5)
{
  return compquery_RescanIfNeededAndFindVoice(a1, a2, a3, a4, a5, 0);
}

uint64_t compquery_GetMatchingVoices(uint64_t a1, int a2, void *a3, void *a4, char *a5, char *a6, size_t a7)
{
  uint64_t v67 = *MEMORY[0x263EF8340];
  PrintableVoiceDescriptiouint64_t n = 2303729671;
  if ((safeh_HandleCheck(a1, a2, 348, 64) & 0x80000000) != 0) {
    return 2303729672;
  }
  if (a5)
  {
    int v61 = 0;
    memset(v60, 0, sizeof(v60));
    memcpy(__dst, *(const void **)(a1 + 16), sizeof(__dst));
    if (a3) {
      __dst[3] = a3;
    }
    if (a4) {
      __dst[5] = a4;
    }
    cstdlib_memcpy(v60, a5, 0x154uLL);
    uint64_t v14 = __dst[4];
    log_OutText((uint64_t)__dst[4], (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"compquery_GetMatchingVoices : Begin", v15, v16, v17, v47);
    *(void *)__int16 v53 = 0;
    uint64_t v54 = 0;
    __int16 v52 = 0;
    if (!a6 || !a7)
    {
LABEL_27:
      log_OutPublic((uint64_t)v14, (uint64_t)"COMPQUERY", 23010, (uint64_t)"%s%x", v18, v19, v20, v21, "lherror");
      goto LABEL_28;
    }
    *a6 = 0;
    if (compquery_loc_IsLanguageIETF((uint64_t)a5))
    {
      uint64_t OldParameters = strhelper_SafeCpy(a5 + 72, a5, 0xFFFFFFFFFFFFFFFFLL, 0x40uLL);
      if ((OldParameters & 0x80000000) != 0) {
        goto LABEL_17;
      }
      cstdlib_memset(a5, 0, 0x40uLL);
    }
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    memset(__b, 0, sizeof(__b));
    memset(v62, 0, sizeof(v62));
    long long v63 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    uint64_t OldParameters = compquery_loc_GetOldParameters((uint64_t)__dst, __b);
    if ((OldParameters & 0x80000000) == 0)
    {
      if (compquery_loc_CompareParameters(a5, (uint64_t)__b))
      {
        PrintableVoiceDescriptiouint64_t n = strhelper_SafeCpy(a6, (char *)v56, 0xFFFFFFFFFFFFFFFFLL, a7);
        if ((PrintableVoiceDescription & 0x80000000) != 0) {
          goto LABEL_28;
        }
LABEL_49:
        if (!*a6)
        {
          PrintableVoiceDescriptiouint64_t n = compquery_GetPrintableVoiceDescription((char *)__b, a5, 0x800uLL);
          if ((PrintableVoiceDescription & 0x80000000) != 0)
          {
            uint64_t v40 = (uint64_t)v14;
            goto LABEL_29;
          }
          log_OutText((uint64_t)v14, (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"Could not find a voice that matches the following description: %s", v24, v25, v26, (uint64_t)__b);
        }
        log_OutText((uint64_t)v14, (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"compquery_GetMatchingVoices : End (%x)", v24, v25, v26, PrintableVoiceDescription);
        return PrintableVoiceDescription;
      }
      unsigned int v50 = __dst[1];
      uint64_t v27 = heap_Calloc(__dst[1], 128, 16);
      if (v27)
      {
        uint64_t v28 = v27;
        PrintableVoiceDescriptiouint64_t n = brk_ComponentTableIteratorOpen((uint64_t)__dst[3], (uint64_t)"pipeline/*", (uint64_t)&v54);
        if ((PrintableVoiceDescription & 0x80000000) != 0)
        {
          log_OutPublic((uint64_t)v14, (uint64_t)"COMPQUERY", 23010, (uint64_t)"%s%x", v29, v30, v31, v32, "lherror");
LABEL_47:
          uint64_t v45 = v50;
        }
        else
        {
          unint64_t v33 = 0;
          while ((brk_ComponentTableIteratorNext(v54) & 0x80000000) == 0)
          {
            compquery_loc_GetParametersFromBrokerString((uint64_t)__dst, *(unsigned char **)v53, v62, &v52);
            if (compquery_loc_CompareParameters(a5, (uint64_t)v62))
            {
              int CurrentScore = compquery_loc_GetCurrentScore((uint64_t)__b, (uint64_t)v62);
              log_OutText((uint64_t)v14, (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"Pipeline %s: score %u", v35, v36, v37, *(uint64_t *)v53);
              uint64_t v38 = strhelper_Strdup((uint64_t)v50, (char *)v63);
              unint64_t v39 = v28 + 16 * v33;
              *(void *)unint64_t v39 = v38;
              *(_WORD *)(v39 + 12) = v52;
              *(_DWORD *)(v39 + 8) = CurrentScore;
              ++v33;
            }
            if (v33 >= 0x80)
            {
              brk_ComponentTableIteratorClose(v54);
              goto LABEL_33;
            }
          }
          brk_ComponentTableIteratorClose(v54);
          if (!v33) {
            goto LABEL_47;
          }
LABEL_33:
          uint64_t v49 = v14;
          ssft_qsort(v28, v33, 16, (uint64_t (*)(unint64_t, unint64_t))compquery_loc_CompareVoiceScores);
          unint64_t v42 = 0;
          do
          {
            if (v42)
            {
              uint64_t v43 = (const char **)v28;
              unint64_t v44 = v42;
              while (cstdlib_strcmp(*v43, *(const char **)(v28 + 16 * v42)))
              {
                v43 += 2;
                if (!--v44)
                {
                  strhelper_SafeCat(a6, ",", 0xFFFFFFFFFFFFFFFFLL, a7);
                  goto LABEL_39;
                }
              }
            }
            else
            {
LABEL_39:
              LODWORD(PrintableVoiceDescription) = strhelper_SafeCat(a6, *(char **)(v28 + 16 * v42), 0xFFFFFFFFFFFFFFFFLL, a7);
            }
            ++v42;
          }
          while (v42 < v33 && (PrintableVoiceDescription & 0x80000000) == 0);
          uint64_t v45 = v50;
          uint64_t v46 = (uint64_t *)v28;
          uint64_t v14 = v49;
          do
          {
            if (*v46) {
              heap_Free(v50, *v46);
            }
            v46 += 2;
            --v33;
          }
          while (v33);
          PrintableVoiceDescriptiouint64_t n = 0;
        }
        heap_Free(v45, v28);
        if ((PrintableVoiceDescription & 0x80000000) != 0) {
          goto LABEL_28;
        }
        goto LABEL_49;
      }
      PrintableVoiceDescriptiouint64_t n = 2303729674;
      goto LABEL_27;
    }
LABEL_17:
    PrintableVoiceDescriptiouint64_t n = OldParameters;
LABEL_28:
    uint64_t v40 = (uint64_t)v14;
LABEL_29:
    log_OutPublic(v40, (uint64_t)"COMPQUERY", 23000, 0, v23, v24, v25, v26, v48);
  }
  return PrintableVoiceDescription;
}

uint64_t compquery_GetPrintableVoiceDescription(char *a1, char *a2, size_t a3)
{
  uint64_t result = strhelper_SafeCpy(a1, "[", 0xFFFFFFFFFFFFFFFFLL, a3);
  if ((result & 0x80000000) == 0)
  {
    if (a2[136])
    {
      if (cstdlib_strlen(a1) >= 2) {
        strhelper_SafeCat(a1, ", ", 0xFFFFFFFFFFFFFFFFLL, a3);
      }
      strhelper_SafeCat(a1, "voice:", 0xFFFFFFFFFFFFFFFFLL, a3);
      strhelper_SafeCat(a1, a2 + 136, 0xFFFFFFFFFFFFFFFFLL, a3);
    }
    if (*a2)
    {
      if (cstdlib_strlen(a1) >= 2) {
        strhelper_SafeCat(a1, ", ", 0xFFFFFFFFFFFFFFFFLL, a3);
      }
      strhelper_SafeCat(a1, "language:", 0xFFFFFFFFFFFFFFFFLL, a3);
      strhelper_SafeCat(a1, a2, 0xFFFFFFFFFFFFFFFFLL, a3);
    }
    if (a2[64])
    {
      if (cstdlib_strlen(a1) >= 2) {
        strhelper_SafeCat(a1, ", ", 0xFFFFFFFFFFFFFFFFLL, a3);
      }
      strhelper_SafeCat(a1, "languageCode:", 0xFFFFFFFFFFFFFFFFLL, a3);
      strhelper_SafeCat(a1, a2 + 64, 0xFFFFFFFFFFFFFFFFLL, a3);
    }
    if (a2[72])
    {
      if (cstdlib_strlen(a1) >= 2) {
        strhelper_SafeCat(a1, ", ", 0xFFFFFFFFFFFFFFFFLL, a3);
      }
      strhelper_SafeCat(a1, "languageIETF:", 0xFFFFFFFFFFFFFFFFLL, a3);
      strhelper_SafeCat(a1, a2 + 72, 0xFFFFFFFFFFFFFFFFLL, a3);
    }
    if (a2[320])
    {
      if (cstdlib_strlen(a1) >= 2) {
        strhelper_SafeCat(a1, ", ", 0xFFFFFFFFFFFFFFFFLL, a3);
      }
      strhelper_SafeCat(a1, "languageGroup:", 0xFFFFFFFFFFFFFFFFLL, a3);
      strhelper_SafeCat(a1, a2 + 320, 0xFFFFFFFFFFFFFFFFLL, a3);
    }
    if (a2[168])
    {
      if (cstdlib_strlen(a1) >= 2) {
        strhelper_SafeCat(a1, ", ", 0xFFFFFFFFFFFFFFFFLL, a3);
      }
      strhelper_SafeCat(a1, "gender:", 0xFFFFFFFFFFFFFFFFLL, a3);
      strhelper_SafeCat(a1, a2 + 168, 0xFFFFFFFFFFFFFFFFLL, a3);
    }
    if (a2[308])
    {
      if (cstdlib_strlen(a1) >= 2) {
        strhelper_SafeCat(a1, ", ", 0xFFFFFFFFFFFFFFFFLL, a3);
      }
      strhelper_SafeCat(a1, "age:", 0xFFFFFFFFFFFFFFFFLL, a3);
      strhelper_SafeCat(a1, a2 + 308, 0xFFFFFFFFFFFFFFFFLL, a3);
    }
    if (a2[188])
    {
      if (cstdlib_strlen(a1) >= 2) {
        strhelper_SafeCat(a1, ", ", 0xFFFFFFFFFFFFFFFFLL, a3);
      }
      strhelper_SafeCat(a1, "voiceModel:", 0xFFFFFFFFFFFFFFFFLL, a3);
      strhelper_SafeCat(a1, a2 + 188, 0xFFFFFFFFFFFFFFFFLL, a3);
    }
    if (a2[220])
    {
      if (cstdlib_strlen(a1) >= 2) {
        strhelper_SafeCat(a1, ", ", 0xFFFFFFFFFFFFFFFFLL, a3);
      }
      strhelper_SafeCat(a1, "voiceOperatingPoint:", 0xFFFFFFFFFFFFFFFFLL, a3);
      strhelper_SafeCat(a1, a2 + 220, 0xFFFFFFFFFFFFFFFFLL, a3);
    }
    if (a2[276])
    {
      if (cstdlib_strlen(a1) >= 2) {
        strhelper_SafeCat(a1, ", ", 0xFFFFFFFFFFFFFFFFLL, a3);
      }
      strhelper_SafeCat(a1, "docType:", 0xFFFFFFFFFFFFFFFFLL, a3);
      strhelper_SafeCat(a1, a2 + 276, 0xFFFFFFFFFFFFFFFFLL, a3);
    }
    if (a2[292])
    {
      uint64_t v7 = a2 + 292;
      if (cstdlib_strlen(a1) >= 2) {
        strhelper_SafeCat(a1, ", ", 0xFFFFFFFFFFFFFFFFLL, a3);
      }
      strhelper_SafeCat(a1, "outputType:", 0xFFFFFFFFFFFFFFFFLL, a3);
      strhelper_SafeCat(a1, v7, 0xFFFFFFFFFFFFFFFFLL, a3);
    }
    return strhelper_SafeCat(a1, "]", 0xFFFFFFFFFFFFFFFFLL, a3);
  }
  return result;
}

uint64_t compquery_GetPipelineName(uint64_t a1, int a2, uint64_t a3, unsigned int a4, char *a5)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  uint64_t v9 = 2303729673;
  unsigned int v10 = safeh_HandleCheck(a1, a2, 348, 64);
  if ((v10 & 0x80000000) != 0) {
    return 2303729672;
  }
  if (!a3) {
    return 2303729671;
  }
  unsigned int v14 = v10;
  uint64_t v15 = *(void *)(a1 + 16);
  log_OutText(*(void *)(v15 + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"GetPipelineName : Begin", v11, v12, v13, v32);
  if (a5) {
    *a5 = 0;
  }
  if (cstdlib_strlen((const char *)(a3 + 220))) {
    size_t v16 = cstdlib_strlen((const char *)(a3 + 220));
  }
  else {
    size_t v16 = 0;
  }
  if (cstdlib_strlen((const char *)(a3 + 328)) && cstdlib_strcmp((const char *)(a3 + 328), "0.0.0")) {
    size_t v17 = cstdlib_strlen((const char *)(a3 + 328));
  }
  else {
    size_t v17 = 0;
  }
  unsigned int v18 = *(_DWORD *)(a3 + 184);
  if (v18 <= 0x3E8) {
    unsigned int v19 = *(_DWORD *)(a3 + 184);
  }
  else {
    unsigned int v19 = v18 / 0x3E8;
  }
  LH_utoa(v19, __s, 0xAu);
  if (a5)
  {
    unsigned int v33 = v14;
    size_t v34 = cstdlib_strlen((const char *)a3);
    size_t v23 = cstdlib_strlen((const char *)(a3 + 136));
    unsigned int v24 = a4;
    uint64_t v25 = v15;
    size_t v26 = cstdlib_strlen(__s);
    size_t v27 = cstdlib_strlen((const char *)(a3 + 276));
    size_t v28 = cstdlib_strlen((const char *)(a3 + 292));
    size_t v29 = v26 + v27;
    uint64_t v15 = v25;
    if (v16 + v17 + v34 + v23 + v29 + v28 + 16 <= v24)
    {
      cstdlib_strcpy(a5, "pipeline/");
      cstdlib_strcat(a5, (const char *)a3);
      cstdlib_strcat(a5, "/");
      cstdlib_strcat(a5, (const char *)(a3 + 136));
      cstdlib_strcat(a5, "/");
      cstdlib_strcat(a5, __s);
      cstdlib_strcat(a5, "/");
      if (v16) {
        uint64_t v30 = (const char *)(a3 + 220);
      }
      else {
        uint64_t v30 = (const char *)(a3 + 188);
      }
      cstdlib_strcat(a5, v30);
      cstdlib_strcat(a5, "/");
      if (v17)
      {
        cstdlib_strcat(a5, (const char *)(a3 + 328));
        cstdlib_strcat(a5, "/");
      }
      cstdlib_strcat(a5, (const char *)(a3 + 276));
      cstdlib_strcat(a5, "/");
      cstdlib_strcat(a5, (const char *)(a3 + 292));
      uint64_t v9 = v33;
    }
  }
  log_OutText(*(void *)(v15 + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"GetPipelineName : End (%x, %s)", v20, v21, v22, v9);
  return v9;
}

uint64_t compquery_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2303729665;
  }
  uint64_t result = 0;
  *a2 = &ICompQuery;
  return result;
}

uint64_t compquery_loc_FindVoice(uint64_t a1, int a2, uint64_t a3, uint64_t a4, void *a5, int a6)
{
  uint64_t v92 = *MEMORY[0x263EF8340];
  PrintableVoiceDescriptiouint64_t n = 2303729677;
  if ((safeh_HandleCheck(a1, a2, 348, 64) & 0x80000000) != 0) {
    return 2303729672;
  }
  if (!a5) {
    return 2303729671;
  }
  int v72 = 0;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  memset(v67, 0, sizeof(v67));
  memset(__b, 0, sizeof(__b));
  memcpy(__dst, *(const void **)(a1 + 16), sizeof(__dst));
  if (a3) {
    __dst[3] = a3;
  }
  if (a4) {
    __dst[5] = a4;
  }
  cstdlib_memcpy(__b, a5, 0x154uLL);
  uint64_t v12 = __dst[4];
  log_OutText(__dst[4], (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"compquery_loc_FindVoice : Begin", v13, v14, v15, v59);
  uint64_t v64 = 0;
  *(void *)long long v63 = 0;
  log_OutText(v12, (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"compquery_loc_MatchVoice", v16, v17, v18, v60);
  if (compquery_loc_IsLanguageIETF((uint64_t)__b))
  {
    uint64_t v19 = strhelper_SafeCpy((char *)v67 + 8, __b, 0xFFFFFFFFFFFFFFFFLL, 0x40uLL);
    if ((v19 & 0x80000000) != 0)
    {
      PrintableVoiceDescriptiouint64_t n = v19;
      goto LABEL_69;
    }
    cstdlib_memset(__b, 0, 0x40uLL);
  }
  long long v91 = 0u;
  long long v90 = 0u;
  long long v89 = 0u;
  long long v88 = 0u;
  long long v87 = 0u;
  long long v86 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v82 = 0u;
  long long v83 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  cstdlib_memset(&v74, 0, 0x60uLL);
  uint64_t OldParameters = compquery_loc_GetOldParameters((uint64_t)__dst, (unsigned int *)&v86);
  if ((OldParameters & 0x80000000) != 0) {
    goto LABEL_57;
  }
  log_OutText(v12, (uint64_t)"COMPQUERY", 3, 0, (uint64_t)"FindVoice: requested %s, %s, %s, %s, %s, %s, %s, %u, %s, %s, %s, %s, %s, %s", v24, v25, v26, (uint64_t)__b);
  uint64_t v30 = (const char *)v86;
  if (!(void)v86) {
    uint64_t v30 = "";
  }
  log_OutText(v12, (uint64_t)"COMPQUERY", 3, 0, (uint64_t)"FindVoice: currently %s, %s, %s, %s, %s, %s, %s, %u, %s, %s", v27, v28, v29, (uint64_t)v30);
  if (compquery_loc_CompareParameters(__b, (uint64_t)&v86))
  {
    long long v76 = v88;
    long long v77 = v89;
    long long v78 = v90;
    long long v79 = v91;
    long long v74 = v86;
    long long v75 = v87;
  }
  else
  {
    uint64_t v46 = brk_ComponentTableIteratorOpen(__dst[3], (uint64_t)"pipeline/*", (uint64_t)&v64);
    if ((v46 & 0x80000000) != 0)
    {
      uint64_t v58 = v46;
      log_OutPublic(v12, (uint64_t)"COMPQUERY", 23010, (uint64_t)"%s%x", v47, v48, v49, v50, "lherror");
      PrintableVoiceDescriptiouint64_t n = v58;
      goto LABEL_58;
    }
    if ((brk_ComponentTableIteratorNext(v64) & 0x80000000) != 0)
    {
      brk_ComponentTableIteratorClose(v64);
      goto LABEL_58;
    }
    int v61 = a6;
    unsigned int v51 = 0;
    unsigned __int16 v52 = 0;
    int v53 = 0;
    unsigned __int16 v65 = 0;
    do
    {
      compquery_loc_GetParametersFromBrokerString((uint64_t)__dst, *(unsigned char **)v63, &v80, &v65);
      if (compquery_loc_CompareParameters(__b, (uint64_t)&v80))
      {
        unsigned int CurrentScore = compquery_loc_GetCurrentScore((uint64_t)&v86, (uint64_t)&v80);
        log_OutText(v12, (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"Pipeline %s: score %u", v55, v56, v57, *(uint64_t *)v63);
        if (v53 && CurrentScore < v51 && v65 <= v52)
        {
          int v53 = 1;
        }
        else if (CurrentScore != v51 || v65 > v52)
        {
          long long v76 = v82;
          long long v77 = v83;
          long long v78 = v84;
          long long v79 = v85;
          long long v74 = v80;
          int v53 = 1;
          unsigned __int16 v52 = v65;
          unsigned int v51 = CurrentScore;
          long long v75 = v81;
        }
      }
    }
    while ((brk_ComponentTableIteratorNext(v64) & 0x80000000) == 0);
    brk_ComponentTableIteratorClose(v64);
    a6 = v61;
    if (!v53) {
      goto LABEL_58;
    }
  }
  uint64_t v31 = (void)v74 ? (char *)v74 : "";
  uint64_t OldParameters = strhelper_SafeCpy(__b, v31, 0xFFFFFFFFFFFFFFFFLL, 0x40uLL);
  if ((OldParameters & 0x80000000) != 0) {
    goto LABEL_57;
  }
  uint64_t v32 = *((void *)&v74 + 1) ? (char *)*((void *)&v74 + 1) : "";
  uint64_t OldParameters = strhelper_SafeCpy((char *)v67, v32, 0xFFFFFFFFFFFFFFFFLL, 8uLL);
  if ((OldParameters & 0x80000000) != 0) {
    goto LABEL_57;
  }
  unsigned int v33 = (void)v75 ? (char *)v75 : "";
  uint64_t OldParameters = strhelper_SafeCpy((char *)v67 + 8, v33, 0xFFFFFFFFFFFFFFFFLL, 0x40uLL);
  if ((OldParameters & 0x80000000) != 0) {
    goto LABEL_57;
  }
  size_t v34 = *((void *)&v75 + 1) ? (char *)*((void *)&v75 + 1) : "";
  uint64_t OldParameters = strhelper_SafeCpy((char *)&v71, v34, 0xFFFFFFFFFFFFFFFFLL, 8uLL);
  if ((OldParameters & 0x80000000) != 0) {
    goto LABEL_57;
  }
  uint64_t v35 = (void)v76 ? (char *)v76 : "";
  uint64_t OldParameters = strhelper_SafeCpy((char *)&v67[4] + 8, v35, 0xFFFFFFFFFFFFFFFFLL, 0x20uLL);
  if ((OldParameters & 0x80000000) != 0) {
    goto LABEL_57;
  }
  uint64_t v36 = *((void *)&v76 + 1) ? (char *)*((void *)&v76 + 1) : "";
  uint64_t OldParameters = strhelper_SafeCpy((char *)&v67[6] + 8, v36, 0xFFFFFFFFFFFFFFFFLL, 0x10uLL);
  if ((OldParameters & 0x80000000) != 0
    || ((void)v77 ? (uint64_t v37 = (char *)v77) : (uint64_t v37 = ""),
        (uint64_t OldParameters = strhelper_SafeCpy((char *)&v70 + 4, v37, 0xFFFFFFFFFFFFFFFFLL, 0xCuLL),
         (OldParameters & 0x80000000) != 0)
     || ((DWORD2(v67[7]) = DWORD2(v77), (void)v78) ? (uint64_t v38 = (char *)v78) : (uint64_t v38 = ""),
         (uint64_t OldParameters = strhelper_SafeCpy((char *)&v67[7] + 12, v38, 0xFFFFFFFFFFFFFFFFLL, 0x20uLL),
          (OldParameters & 0x80000000) != 0)
      || (*((void *)&v78 + 1) ? (unint64_t v39 = (char *)*((void *)&v78 + 1)) : (unint64_t v39 = ""),
          uint64_t OldParameters = strhelper_SafeCpy((char *)&v67[9] + 12, v39, 0xFFFFFFFFFFFFFFFFLL, 0x20uLL),
          (OldParameters & 0x80000000) != 0))))
  {
LABEL_57:
    PrintableVoiceDescriptiouint64_t n = OldParameters;
LABEL_58:
    if (!a6)
    {
      log_OutText(v12, (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"compquery_loc_MatchVoice : End (%x)", v24, v25, v26, PrintableVoiceDescription);
      goto LABEL_69;
    }
    PrintableVoiceDescriptiouint64_t n = compquery_GetPrintableVoiceDescription(v73, __b, 0x800uLL);
    if ((PrintableVoiceDescription & 0x80000000) != 0)
    {
LABEL_69:
      log_OutText(v12, (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"compquery_loc_FindVoice : End (%x)", v20, v21, v22, PrintableVoiceDescription);
      return PrintableVoiceDescription;
    }
    log_OutPublic(v12, (uint64_t)"COMPQUERY", 23004, (uint64_t)"%s%s", v44, v20, v21, v22, "description");
    goto LABEL_61;
  }
  if (*((void *)&v79 + 1)) {
    uint64_t v40 = (char *)*((void *)&v79 + 1);
  }
  else {
    uint64_t v40 = "";
  }
  PrintableVoiceDescriptiouint64_t n = strhelper_SafeCpy((char *)&v71 + 8, v40, 0xFFFFFFFFFFFFFFFFLL, 0xCuLL);
  if ((PrintableVoiceDescription & 0x80000000) != 0) {
    goto LABEL_58;
  }
  log_OutText(v12, (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"Found voice: %s, %s, %s, %s, %s, %s, %s, %u, %s, %s", v24, v25, v26, (uint64_t)__b);
LABEL_61:
  log_OutText(v12, (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"compquery_loc_MatchVoice : End (%x)", v41, v42, v43, PrintableVoiceDescription);
  if (BYTE4(v68)
    || (PrintableVoiceDescriptiouint64_t n = strhelper_SafeCpy((char *)&v68 + 4, "text", 0xFFFFFFFFFFFFFFFFLL, 0x10uLL),
        (PrintableVoiceDescription & 0x80000000) == 0))
  {
    if (BYTE4(v69)
      || (PrintableVoiceDescriptiouint64_t n = strhelper_SafeCpy((char *)&v69 + 4, "pcm", 0xFFFFFFFFFFFFFFFFLL, 0x10uLL),
          (PrintableVoiceDescription & 0x80000000) == 0))
    {
      cstdlib_memcpy(a5, __b, 0x154uLL);
      goto LABEL_69;
    }
  }
  return PrintableVoiceDescription;
}

BOOL compquery_loc_IsLanguageIETF(uint64_t a1)
{
  return cstdlib_strlen((const char *)a1) == 5
      && cstdlib_isalpha(*(unsigned char *)a1)
      && cstdlib_isalpha(*(unsigned char *)(a1 + 1))
      && *(unsigned char *)(a1 + 2) == 45
      && cstdlib_isalpha(*(unsigned char *)(a1 + 3))
      && cstdlib_isalpha(*(unsigned char *)(a1 + 4));
}

uint64_t compquery_loc_GetOldParameters(uint64_t a1, unsigned int *__b)
{
  cstdlib_memset(__b, 0, 0x60uLL);
  uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"language", __b);
  if (!*(void *)(a1 + 40) || (result & 0x80000000) == 0 || (result & 0x1FFF) == 0x14)
  {
    uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"langcode", (void *)__b + 1);
    if (!*(void *)(a1 + 40) || (result & 0x80000000) == 0 || (result & 0x1FFF) == 0x14)
    {
      uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"langietf", (void *)__b + 2);
      if (!*(void *)(a1 + 40) || (result & 0x80000000) == 0 || (result & 0x1FFF) == 0x14)
      {
        uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"langgroup", (void *)__b + 3);
        uint64_t v5 = *(void *)(a1 + 40);
        if (!v5 || (result & 0x80000000) == 0 || (result & 0x1FFF) == 0x14)
        {
          if ((result & 0x80000000) != 0)
          {
            compquery_loc_DeriveLangGroup((uint64_t)__b);
            uint64_t v5 = *(void *)(a1 + 40);
          }
          uint64_t result = paramc_ParamGetStr(v5, (uint64_t)"voice", (void *)__b + 4);
          if (!*(void *)(a1 + 40) || (result & 0x80000000) == 0 || (result & 0x1FFF) == 0x14)
          {
            uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"gender", (void *)__b + 5);
            if (!*(void *)(a1 + 40) || (result & 0x80000000) == 0 || (result & 0x1FFF) == 0x14)
            {
              uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"age", (void *)__b + 6);
              if (!*(void *)(a1 + 40) || (result & 0x80000000) == 0 || (result & 0x1FFF) == 0x14)
              {
                uint64_t result = paramc_ParamGetUInt(*(void *)(a1 + 40), (uint64_t)"frequencyhz", __b + 14);
                if (!*(void *)(a1 + 40) || (result & 0x80000000) == 0 || (result & 0x1FFF) == 0x14)
                {
                  uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"voicemodel", (void *)__b + 8);
                  if (!*(void *)(a1 + 40) || (result & 0x80000000) == 0 || (result & 0x1FFF) == 0x14)
                  {
                    uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"voiceoperatingpoint", (void *)__b + 9);
                    if (!*(void *)(a1 + 40) || (result & 0x80000000) == 0 || (result & 0x1FFF) == 0x14)
                    {
                      LODWORD(result) = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"vopversion", (void *)__b + 11);
                      if ((result & 0x1FFF) == 0x14 || (int)result > -1 || *(void *)(a1 + 40) == 0) {
                        return 0;
                      }
                      else {
                        return result;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t compquery_loc_CompareParameters(char *__s, uint64_t a2)
{
  if (*__s)
  {
    int v4 = *(char **)a2;
    if (!*(void *)a2 || LH_stricmp(__s, v4)) {
      return 0;
    }
  }
  if (__s[64])
  {
    uint64_t v5 = *(char **)(a2 + 8);
    if (!v5 || LH_stricmp(__s + 64, v5)) {
      return 0;
    }
  }
  if (!__s[72]) {
    goto LABEL_22;
  }
  uint64_t v6 = *(void *)(a2 + 16);
  if (!v6) {
    return 0;
  }
  if (cstdlib_strlen(__s + 72) == 2)
  {
    if (!LH_strnicmp((uint64_t)(__s + 72), v6, 2uLL))
    {
      int v7 = *(unsigned __int8 *)(v6 + 2);
      if (!*(unsigned char *)(v6 + 2)) {
        goto LABEL_22;
      }
      goto LABEL_16;
    }
  }
  else if (cstdlib_strlen((const char *)v6) == 2 && !LH_strnicmp((uint64_t)(__s + 72), v6, 2uLL))
  {
    int v7 = *(unsigned __int8 *)(v6 + 1);
    if (!*(unsigned char *)(v6 + 1)) {
      goto LABEL_22;
    }
LABEL_16:
    if (v7 == 45) {
      goto LABEL_22;
    }
  }
  if (LH_stricmp(__s + 72, (char *)v6)
    && (LH_stricmp(__s + 72, "es-us") && LH_stricmp(__s + 72, "es-mx")
     || LH_stricmp((char *)v6, "es-us") && LH_stricmp((char *)v6, "es-mx")))
  {
    return 0;
  }
LABEL_22:
  if (__s[320])
  {
    uint64_t v8 = *(char **)(a2 + 24);
    if (!v8 || LH_stricmp(__s + 320, v8)) {
      return 0;
    }
  }
  if (__s[136])
  {
    uint64_t v9 = *(char **)(a2 + 32);
    if (!v9 || LH_stricmp(__s + 136, v9)) {
      return 0;
    }
  }
  if (__s[168])
  {
    unsigned int v10 = *(char **)(a2 + 40);
    if (!v10 || LH_stricmp(__s + 168, v10)) {
      return 0;
    }
  }
  if (__s[308])
  {
    uint64_t v11 = *(char **)(a2 + 48);
    if (!v11 || LH_stricmp(__s + 308, v11)) {
      return 0;
    }
  }
  int v12 = *((_DWORD *)__s + 46);
  if (v12)
  {
    if (v12 != *(_DWORD *)(a2 + 56)) {
      return 0;
    }
  }
  if (__s[188])
  {
    uint64_t v13 = *(char **)(a2 + 64);
    if (!v13 || LH_stricmp(__s + 188, v13)) {
      return 0;
    }
  }
  if (__s[220])
  {
    uint64_t v14 = *(char **)(a2 + 72);
    if (!v14 || LH_stricmp(__s + 220, v14)) {
      return 0;
    }
  }
  if (__s[328])
  {
    uint64_t v15 = *(char **)(a2 + 88);
    if (!v15 || LH_stricmp(__s + 328, v15)) {
      return 0;
    }
  }
  return 1;
}

uint64_t compquery_loc_GetParametersFromBrokerString(uint64_t a1, unsigned char *a2, void *__b, _WORD *a4)
{
  uint64_t v12 = 0;
  cstdlib_memset(__b, 0, 0x60uLL);
  if ((brk_TagIteratorOpen(*(void *)(a1 + 24), a2, "PARAMETERS/*", 1, &v12) & 0x80000000) == 0)
  {
    unsigned int v10 = 0;
    long long __s1 = 0;
    while ((brk_TagIteratorNext(v12, (uint64_t)&__s1, (uint64_t)&v10) & 0x80000000) == 0)
    {
      if (__s1)
      {
        if (cstdlib_strcmp(__s1, "language"))
        {
          if (cstdlib_strcmp(__s1, "langcode"))
          {
            if (cstdlib_strcmp(__s1, "langietf"))
            {
              if (cstdlib_strcmp(__s1, "langgroup"))
              {
                if (cstdlib_strcmp(__s1, "voice"))
                {
                  if (cstdlib_strcmp(__s1, "gender"))
                  {
                    if (cstdlib_strcmp(__s1, "age"))
                    {
                      if (cstdlib_strcmp(__s1, "frequencyhz"))
                      {
                        if (cstdlib_strcmp(__s1, "voicemodel"))
                        {
                          if (cstdlib_strcmp(__s1, "voiceoperatingpoint"))
                          {
                            if (!cstdlib_strcmp(__s1, "vopversion")) {
                              __b[11] = v10;
                            }
                          }
                          else
                          {
                            __b[9] = v10;
                          }
                        }
                        else
                        {
                          unsigned int __b[8] = v10;
                        }
                      }
                      else
                      {
                        *((_DWORD *)__b + 14) = LH_atou(v10);
                      }
                    }
                    else
                    {
                      __b[6] = v10;
                    }
                  }
                  else
                  {
                    __b[5] = v10;
                  }
                }
                else
                {
                  _OWORD __b[4] = v10;
                }
              }
              else
              {
                _OWORD __b[3] = v10;
              }
            }
            else
            {
              _OWORD __b[2] = v10;
            }
          }
          else
          {
            __b[1] = v10;
          }
        }
        else
        {
          *long long __b = v10;
        }
      }
    }
    uint64_t v8 = (unsigned char *)__b[11];
    if (!v8 || !*v8) {
      __b[11] = "0.0.0";
    }
    brk_TagIteratorClose(v12);
  }
  if (!__b[3]) {
    compquery_loc_DeriveLangGroup((uint64_t)__b);
  }
  *a4 = 0;
  return compquery_loc_BrkTagQueryU16(*(void *)(a1 + 24), (uint64_t)a2, a4);
}

uint64_t compquery_loc_GetCurrentScore(uint64_t a1, uint64_t a2)
{
  int v4 = *(char **)(a1 + 64);
  if (v4 && *v4 && (uint64_t v5 = *(char **)(a2 + 64)) != 0) {
    uint64_t v6 = 4 * (LH_stricmp(v4, v5) == 0);
  }
  else {
    uint64_t v6 = 0;
  }
  int v7 = *(char **)(a1 + 88);
  if (v7)
  {
    if (*v7)
    {
      uint64_t v8 = *(char **)(a2 + 88);
      if (v8)
      {
        if (LH_stricmp(v7, v8)) {
          uint64_t v6 = v6;
        }
        else {
          uint64_t v6 = v6 | 8;
        }
      }
    }
  }
  uint64_t v9 = *(char **)(a1 + 72);
  if (v9)
  {
    if (*v9)
    {
      unsigned int v10 = *(char **)(a2 + 72);
      if (v10)
      {
        if (LH_stricmp(v9, v10)) {
          uint64_t v6 = v6;
        }
        else {
          uint64_t v6 = v6 | 0x10;
        }
      }
    }
  }
  int v11 = *(_DWORD *)(a1 + 56);
  if (v11)
  {
    if (v11 == *(_DWORD *)(a2 + 56)) {
      uint64_t v6 = v6 | 0x20;
    }
    else {
      uint64_t v6 = v6;
    }
  }
  uint64_t v12 = *(char **)(a1 + 48);
  if (v12)
  {
    if (*v12)
    {
      uint64_t v13 = *(char **)(a2 + 48);
      if (v13)
      {
        if (LH_stricmp(v12, v13)) {
          uint64_t v6 = v6;
        }
        else {
          uint64_t v6 = v6 | 0x40;
        }
      }
    }
  }
  uint64_t v14 = *(char **)(a1 + 40);
  if (v14)
  {
    if (*v14)
    {
      uint64_t v15 = *(char **)(a2 + 40);
      if (v15)
      {
        if (LH_stricmp(v14, v15)) {
          uint64_t v6 = v6;
        }
        else {
          uint64_t v6 = v6 | 0x80;
        }
      }
    }
  }
  uint64_t v16 = *(char **)(a1 + 8);
  if (v16)
  {
    if (*v16)
    {
      uint64_t v17 = *(char **)(a2 + 8);
      if (v17)
      {
        if (LH_stricmp(v16, v17)) {
          uint64_t v6 = v6;
        }
        else {
          uint64_t v6 = v6 | 0x100;
        }
      }
    }
  }
  uint64_t v18 = *(char **)(a1 + 16);
  if (v18)
  {
    if (*v18)
    {
      uint64_t v19 = *(char **)(a2 + 16);
      if (v19)
      {
        if (LH_stricmp(v18, v19)) {
          uint64_t v6 = v6;
        }
        else {
          uint64_t v6 = v6 | 0x200;
        }
      }
    }
  }
  uint64_t v20 = *(char **)a1;
  if (*(void *)a1 && *v20 && *(void *)a2)
  {
    if (LH_stricmp(v20, *(char **)a2)) {
      uint64_t v6 = v6;
    }
    else {
      uint64_t v6 = v6 | 0x400;
    }
  }
  uint64_t v21 = *(char **)(a1 + 24);
  if (v21)
  {
    if (*v21)
    {
      uint64_t v22 = *(char **)(a2 + 24);
      if (v22)
      {
        if (LH_stricmp(v21, v22)) {
          uint64_t v6 = v6;
        }
        else {
          uint64_t v6 = v6 | 0x800;
        }
      }
    }
  }
  size_t v23 = *(char **)(a1 + 32);
  if (v23)
  {
    if (*v23)
    {
      uint64_t v24 = *(char **)(a2 + 32);
      if (v24)
      {
        if (LH_stricmp(v23, v24)) {
          return v6;
        }
        else {
          return v6 | 0x1000;
        }
      }
    }
  }
  return v6;
}

const char *compquery_loc_DeriveLangGroup(uint64_t a1)
{
  uint64_t result = *(const char **)(a1 + 8);
  if (result)
  {
    uint64_t result = (const char *)cstdlib_strlen(result);
    if (result == (const char *)3)
    {
      *(void *)(a1 + 24) = a1 + 80;
      *(unsigned char *)(a1 + 80) = cstdlib_tolower(**(unsigned __int8 **)(a1 + 8));
      uint64_t result = (const char *)cstdlib_tolower(*(unsigned __int8 *)(*(void *)(a1 + 8) + 1));
      *(unsigned char *)(a1 + 81) = (_BYTE)result;
      *(_WORD *)(a1 + 82) = 120;
    }
  }
  return result;
}

uint64_t compquery_loc_CompareVoiceScores(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 8);
  int v4 = *(_DWORD *)(a2 + 8);
  uint64_t result = (v4 - v3);
  if (v4 == v3) {
    return *(unsigned __int16 *)(a2 + 12) - *(unsigned __int16 *)(a1 + 12);
  }
  return result;
}

uint64_t compquery_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 2303729670;
  uint64_t v32 = 0;
  if (a5)
  {
    *(void *)a5 = 0;
    *(_DWORD *)(a5 + 8) = 0;
    uint64_t inited = InitRsrcFunction(a3, a4, &v32);
    if ((inited & 0x80000000) == 0)
    {
      log_OutText(*(void *)(v32 + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"COMPQUERY ObjOpen: Begin", v10, v11, v12, v30);
      uint64_t v13 = heap_Calloc(*(void **)(v32 + 8), 1, 64);
      uint64_t v18 = (void *)v13;
      if (v13)
      {
        *(void *)uint64_t v13 = a3;
        *(void *)(v13 + 8) = a4;
        uint64_t v19 = v32;
        *(void *)(v13 + 16) = v32;
        uint64_t v20 = (unsigned int *)(v13 + 40);
        if ((paramc_ParamGetUInt(*(void *)(v19 + 40), (uint64_t)"voice_rescan_interval", (unsigned int *)(v13 + 40)) & 0x80000000) == 0) {
          log_OutText(*(void *)(v32 + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"voice_rescan_interval=%lu", v21, v22, v23, *v20);
        }
        uint64_t Class = critsec_ObjOpen(*(void *)(v32 + 16), *(void **)(v32 + 8), v18 + 7);
        if ((Class & 0x80000000) != 0
          || (uint64_t Class = brk_ObjGetClass(*(void *)(v32 + 24), v18 + 3), (Class & 0x80000000) != 0))
        {
          uint64_t v5 = Class;
        }
        else
        {
          uint64_t v5 = brk_ObjOpen(0, v18[3]);
          if ((v5 & 0x80000000) == 0)
          {
            int v28 = 348;
LABEL_14:
            *(void *)a5 = v18;
            *(_DWORD *)(a5 + 8) = v28;
            log_OutText(*(void *)(v32 + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"COMPQUERY ObjOpen: End (%x)", v25, v26, v27, v5);
            return v5;
          }
        }
      }
      else
      {
        log_OutPublic(*(void *)(v32 + 32), (uint64_t)"COMPQUERY", 23000, 0, v14, v15, v16, v17, v31);
        uint64_t v5 = 2303729674;
      }
      *(void *)a5 = v18;
      *(_DWORD *)(a5 + 8) = 348;
      compquery_ObjClose(v18, *(void *)(a5 + 8));
      uint64_t v18 = 0;
      int v28 = 0;
      goto LABEL_14;
    }
    return inited;
  }
  return v5;
}

uint64_t compquery_ObjClose(void *a1, int a2)
{
  uint64_t v6 = safeh_HandleCheck((uint64_t)a1, a2, 348, 64);
  if ((v6 & 0x80000000) == 0)
  {
    if (a1)
    {
      uint64_t v7 = a1[2];
      log_OutText(*(void *)(v7 + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"COMPQUERY ObjClose : Begin", v3, v4, v5, v17);
      uint64_t v8 = a1[4];
      if (v8)
      {
        int v9 = brk_ObjClose(v8);
        if (v9 >= 0) {
          uint64_t v6 = v6;
        }
        else {
          uint64_t v6 = v9;
        }
      }
      uint64_t v10 = a1[7];
      if (v10)
      {
        int v11 = critsec_ObjClose(v10);
        a1[7] = 0;
        if (v11 >= 0 || (int)v6 <= -1) {
          uint64_t v6 = v6;
        }
        else {
          uint64_t v6 = v11;
        }
      }
      heap_Free(*(void **)(v7 + 8), (uint64_t)a1);
      log_OutText(*(void *)(v7 + 32), (uint64_t)"COMPQUERY", 4, 0, (uint64_t)"COMPQUERY ObjClose : End (%x)", v13, v14, v15, v6);
    }
    else
    {
      return 2303729670;
    }
  }
  return v6;
}

uint64_t compquery_ObjReopen()
{
  return 0;
}

uint64_t lipsyncinfo_GetNbrOfLhp()
{
  return 364;
}

char *lipsyncinfo_GetPhonemeTableByIndex(int a1)
{
  return (char *)&szLHPhonemeTable + 8 * a1;
}

char *lipsyncinfo_GetMouthPosByIndex(int a1)
{
  return (char *)&sMouthPos + 18 * a1;
}

BOOL lipsyncinfo_VerifyLH(uint64_t a1, uint64_t a2)
{
  return !(a1 | a2)
      || (!a1 || a2) && (a1 || !a2) && a1 && a2 && *(unsigned __int8 *)(a1 + 1) == *(unsigned __int8 *)(a2 + 1);
}

size_t lipsyncinfo_HeadsMatch(char *__s, unsigned __int8 *a2)
{
  size_t result = 0;
  if (__s)
  {
    if (a2)
    {
      size_t result = cstdlib_strlen(__s);
      if (result)
      {
        size_t result = cstdlib_strlen((const char *)a2);
        if (result)
        {
          size_t result = 0;
          int v5 = *__s;
          unsigned int v6 = v5 - 33;
          if ((v5 - 33) <= 0x5D && (v5 - 55) <= 0xFFFFFFF8)
          {
            size_t result = 0;
            if ((v6 > 0x3F || ((1 << v6) & 0x9C0004203E005FB1) == 0) && (v5 - 123) >= 4)
            {
              size_t result = 0;
              int v7 = *a2;
              unsigned int v8 = v7 - 33;
              if ((v7 - 33) <= 0x5D && (v7 - 55) <= 0xFFFFFFF8)
              {
                size_t result = 0;
                if ((v8 > 0x3F || ((1 << v8) & 0x9C0004203E005FB1) == 0) && (v7 - 123) >= 4)
                {
                  if (v5 == v7)
                  {
                    int v9 = cstdlib_strchr(__s + 1, 38);
                    uint64_t v10 = v9;
                    if (v9)
                    {
                      if ((int v11 = v9[1], v12 = v11 - 33, (v11 - 33) > 0x5D)
                        || (v11 - 55) > 0xFFFFFFF8
                        || v12 <= 0x3F && ((1 << v12) & 0x9C0004203E005FB1) != 0
                        || (v11 - 123) < 4)
                      {
                        uint64_t v10 = 0;
                      }
                    }
                    uint64_t v13 = cstdlib_strchr((char *)a2 + 1, 38);
                    if (!v13) {
                      return v10 == 0;
                    }
                    int v14 = v13[1];
                    unsigned int v15 = v14 - 33;
                    if ((v14 - 33) > 0x5D
                      || (v14 - 55) > 0xFFFFFFF8
                      || v15 <= 0x3F && ((1 << v15) & 0x9C0004203E005FB1) != 0)
                    {
                      return v10 == 0;
                    }
                    if ((v14 - 123) < 4) {
                      return v10 == 0;
                    }
                    if (v10) {
                      return v10[1] == v14;
                    }
                  }
                  return 0;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t lipsyncinfo_HeadsMatchLooselyDiphtongs(char *__s, unsigned __int8 *a2)
{
  uint64_t result = 0;
  if (__s)
  {
    if (a2)
    {
      uint64_t result = cstdlib_strlen(__s);
      if (result)
      {
        uint64_t result = cstdlib_strlen((const char *)a2);
        if (result)
        {
          uint64_t result = 0;
          int v5 = *__s;
          unsigned int v6 = v5 - 33;
          if ((v5 - 33) <= 0x5D && (v5 - 55) <= 0xFFFFFFF8)
          {
            uint64_t result = 0;
            if ((v6 > 0x3F || ((1 << v6) & 0x9C0004203E005FB1) == 0) && (v5 - 123) >= 4)
            {
              uint64_t result = 0;
              int v7 = *a2;
              unsigned int v8 = v7 - 33;
              if ((v7 - 33) <= 0x5D && (v7 - 55) <= 0xFFFFFFF8)
              {
                uint64_t result = 0;
                if ((v8 > 0x3F || ((1 << v8) & 0x9C0004203E005FB1) == 0) && (v7 - 123) >= 4)
                {
                  if (v5 != v7) {
                    return 0;
                  }
                  uint64_t result = (uint64_t)cstdlib_strchr(__s + 1, 38);
                  if (result)
                  {
                    uint64_t v9 = result;
                    uint64_t result = 0;
                    int v10 = *(unsigned __int8 *)(v9 + 1);
                    unsigned int v11 = v10 - 33;
                    if ((v10 - 33) <= 0x5D && (v10 - 55) <= 0xFFFFFFF8)
                    {
                      uint64_t result = 0;
                      if ((v11 > 0x3F || ((1 << v11) & 0x9C0004203E005FB1) == 0) && (v10 - 123) >= 4)
                      {
                        unsigned int v12 = cstdlib_strchr((char *)a2 + 1, 38);
                        if (!v12) {
                          return 1;
                        }
                        int v13 = v12[1];
                        unsigned int v14 = v13 - 33;
                        if ((v13 - 33) > 0x5D
                          || (v13 - 55) > 0xFFFFFFF8
                          || v14 <= 0x3F && ((1 << v14) & 0x9C0004203E005FB1) != 0)
                        {
                          return 1;
                        }
                        return (v13 - 123) < 4;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t langCodeConverter_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2385518593;
  }
  uint64_t result = 0;
  *a2 = &ILangCodeConverter;
  return result;
}

uint64_t langCodeConverter_ObjOpen(_WORD *a1, int a2, uint64_t a3)
{
  v61[16] = *MEMORY[0x263EF8340];
  uint64_t v3 = 2385518602;
  uint64_t v56 = 0;
  if (!a3) {
    return 2385518598;
  }
  long long v54 = 0u;
  long long v55 = 0u;
  long long v53 = 0u;
  memset(__b, 0, sizeof(__b));
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v56);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  cstdlib_memset(__b, 0, 0x70uLL);
  unsigned int v6 = (BOOL *)heap_Calloc(*(void **)(v56 + 8), 1, 40);
  int v7 = v6;
  if (v6)
  {
    *unsigned int v6 = v56;
    uint64_t v8 = v56;
    v61[0] = 0;
    LODWORD(v60) = 0;
    unsigned int v58 = 0;
    LODWORD(v59) = 1;
    uint64_t Class = brk_ObjGetClass(*(void *)(v56 + 24), v61);
    if ((Class & 0x80000000) != 0) {
      goto LABEL_52;
    }
    uint64_t Class = brk_ObjOpen(0, v61[0]);
    if ((Class & 0x80000000) != 0) {
      goto LABEL_52;
    }
    cstdlib_memset(__b, 0, 0x40uLL);
    set_DctBrk((uint64_t)__b, *((uint64_t *)&v53 + 1));
    uint64_t v10 = open_DctRom((uint64_t *)__b, (uint64_t)"sysdct", &v58);
    if ((v10 & 0x80000000) != 0)
    {
      uint64_t v48 = 41005;
      uint64_t v3 = v10;
    }
    else
    {
      *(void *)&long long v53 = __b;
      uint64_t Class = brk_DataOpenEx(*((uint64_t *)&v53 + 1), (uint64_t)"sysdct", 1, (uint64_t)&v54);
      if ((Class & 0x80000000) != 0) {
        goto LABEL_52;
      }
      uint64_t Class = query_DctRom(v53, "langcode", v58, v54, &v60);
      if ((Class & 0x80000000) != 0) {
        goto LABEL_52;
      }
      if (v60)
      {
        uint64_t v15 = heap_Calloc(*(void **)(v8 + 8), 1, 144);
        uint64_t v16 = v53;
        *(void *)(v53 + 16) = v15;
        if (!v15) {
          goto LABEL_53;
        }
        uint64_t Class = init_DctRom(v16, "langcode", v58, v54);
        if ((Class & 0x80000000) == 0)
        {
          MaxOutLeuint64_t n = GetMaxOutLen(v53);
          *((void *)&v54 + 1) = MaxOutLen;
          if (!MaxOutLen)
          {
            uint64_t v3 = 2385518599;
            goto LABEL_53;
          }
          BYTE8(v55) = GetFieldSeparator(v53);
          uint64_t v18 = heap_Calloc(*(void **)(v8 + 8), 1, *((void *)&v54 + 1) + 1);
          *(void *)(v53 + 40) = v18;
          if (v18)
          {
            for (uint64_t i = 0; ; ++i)
            {
              uint64_t Class = langCodeConverter_loc_RetrieveDictionaryEntry((uint64_t)__b, i, 0, 0, &v59);
              if ((Class & 0x80000000) != 0) {
                break;
              }
              if (!v59)
              {
                *(void *)&long long v55 = i;
                v7[2] = i;
                v7[4] = 5 * i;
                uint64_t v20 = v7 + 3;
                uint64_t v21 = hashtable_ObjOpen(v7 + 3, v56, 5 * i, 0);
                uint64_t v22 = v21;
                if ((v21 & 0x80000000) != 0)
                {
                  uint64_t v3 = v21;
                  goto LABEL_54;
                }
                hashtable_ElementSetDestructor(v7[3], (uint64_t)langCodeConverter_loc_HashFreeElement);
                hashtable_SetStringCompareFunction(v7[3], (uint64_t)langCodeConverter_loc_StringCompare, (uint64_t)v7);
                hashtable_SetStringToHashFunction(v7[3], (uint64_t)langCodeConverter_loc_StringToHash, (uint64_t)v7);
                uint64_t v23 = heap_Calloc(*(void **)(v56 + 8), v7[2], 8);
                v7[1] = v23;
                if (!v23) {
                  goto LABEL_54;
                }
                if (v7[2])
                {
                  unint64_t v27 = 0;
                  while (1)
                  {
                    *(void *)(v7[1] + 8 * v27) = heap_Calloc(*(void **)(v56 + 8), 5, 8);
                    if (!*(void *)(v7[1] + 8 * v27)) {
                      goto LABEL_54;
                    }
                    ++v27;
                    unint64_t v28 = v7[2];
                    if (v27 >= v28)
                    {
                      if (!v28) {
                        break;
                      }
                      uint64_t v29 = 0;
                      while (1)
                      {
                        unsigned int v51 = -1909448694;
                        uint64_t v59 = 0;
                        unsigned int v58 = 1;
                        v57[0] = BYTE8(v55);
                        v57[1] = 0;
                        unsigned int v30 = langCodeConverter_loc_RetrieveDictionaryEntry((uint64_t)__b, v29, v61, 0x80uLL, &v58);
                        if ((v30 & 0x80000000) != 0)
                        {
                          unsigned int v51 = v30;
                          goto LABEL_63;
                        }
                        if (!v58) {
                          break;
                        }
                        unsigned int v31 = langCodeConverter_loc_StrTokAndTrim((uint64_t)v61, v57, &v59);
                        if (!v31)
                        {
LABEL_64:
                          int v49 = -1909448438;
                          goto LABEL_67;
                        }
                        uint64_t v32 = v31;
                        unsigned int v33 = 0;
                        do
                        {
                          if (*v32)
                          {
                            uint64_t v34 = *v7;
                            if (cstdlib_strchr(v32, 124))
                            {
                              uint64_t v60 = 0;
                              uint64_t v35 = strhelper_Strdup(*(void *)(v34 + 8), v32);
                              if (!v35) {
                                goto LABEL_63;
                              }
                              uint64_t v36 = (uint64_t)v35;
                              uint64_t v37 = langCodeConverter_loc_StrTokAndTrim((uint64_t)v35, "|", &v60);
                              if (v37)
                              {
                                uint64_t v38 = v37;
                                char v39 = 0;
                                while (1)
                                {
                                  if (v39)
                                  {
                                    uint64_t v40 = *(void *)(v7[1] + 8 * v29);
                                  }
                                  else
                                  {
                                    *(void *)(*(void *)(v7[1] + 8 * v29) + 8 * v33) = strhelper_Strdup(*(void *)(v34 + 8), v38);
                                    uint64_t v40 = *(void *)(v7[1] + 8 * v29);
                                    if (!*(void *)(v40 + 8 * v33)) {
                                      break;
                                    }
                                  }
                                  uint64_t v41 = heap_Calloc(*(void **)(v34 + 8), 1, 16);
                                  if (!v41) {
                                    break;
                                  }
                                  *(void *)uint64_t v41 = v40;
                                  *(_DWORD *)(v41 + 8) = v33;
                                  hashtable_Set(*v20);
                                  uint64_t v38 = langCodeConverter_loc_StrTokAndTrim(v36, "|", &v60);
                                  char v39 = 1;
                                  if (!v38) {
                                    goto LABEL_40;
                                  }
                                }
                                heap_Free(*(void **)(v34 + 8), v36);
                                goto LABEL_63;
                              }
LABEL_40:
                              heap_Free(*(void **)(v34 + 8), v36);
                            }
                            else
                            {
                              *(void *)(*(void *)(v7[1] + 8 * v29) + 8 * v33) = strhelper_Strdup(*(void *)(v34 + 8), v32);
                              if (!*(void *)(*(void *)(v7[1] + 8 * v29) + 8 * v33)) {
                                goto LABEL_63;
                              }
                              if (cstdlib_strcmp(v32, "*"))
                              {
                                uint64_t v42 = *(void *)(v7[1] + 8 * v29);
                                uint64_t v43 = heap_Calloc(*(void **)(v34 + 8), 1, 16);
                                if (!v43) {
                                  goto LABEL_63;
                                }
                                *(void *)uint64_t v43 = v42;
                                *(_DWORD *)(v43 + 8) = v33;
                                hashtable_Set(*v20);
                              }
                            }
                          }
                          ++v33;
                          uint64_t v32 = langCodeConverter_loc_StrTokAndTrim((uint64_t)v61, v57, &v59);
                        }
                        while (v32);
                        if (v33 != 5) {
                          goto LABEL_64;
                        }
                        uint64_t v22 = 0;
                        if (++v29 >= (unint64_t)v7[2]) {
                          goto LABEL_48;
                        }
                      }
                      int v49 = -1909448684;
LABEL_67:
                      unsigned int v51 = v49;
LABEL_63:
                      uint64_t v3 = v51;
                      goto LABEL_54;
                    }
                  }
                }
LABEL_48:
                log_OutText(*(void *)(*v7 + 32), (uint64_t)"LANGCODECONVERTER", 4, 0, (uint64_t)"%s", v24, v25, v26, (uint64_t)"--- LANGUAGE CODE HASHTABLE BEGIN ---");
                hashtable_Dump((_DWORD *)v7[3], "*** HASH TABLE DUMP ***", (void (*)(void, char *, uint64_t))langCodeConverter_loc_DumpHashTableLine, (uint64_t)"trace", (uint64_t)v7);
                log_OutText(*(void *)(*v7 + 32), (uint64_t)"LANGCODECONVERTER", 4, 0, (uint64_t)"%s", v44, v45, v46, (uint64_t)"--- LANGUAGE CODE HASHTABLE END ---");
                langCodeConverter_loc_CloseLangCodeDictionary(v56, __b);
                if ((v22 & 0x80000000) != 0) {
                  goto LABEL_55;
                }
                *(void *)a3 = v7;
                *(_DWORD *)(a3 + 8) = 239785;
                return v22;
              }
            }
            goto LABEL_52;
          }
LABEL_53:
          langCodeConverter_loc_CloseLangCodeDictionary(v8, __b);
          goto LABEL_54;
        }
LABEL_52:
        uint64_t v3 = Class;
        goto LABEL_53;
      }
      uint64_t v3 = 2385518612;
      uint64_t v48 = 41008;
    }
    log_OutPublic(*(void *)(v8 + 32), (uint64_t)"LANGCODECONVERTER", v48, 0, v11, v12, v13, v14, v50);
    goto LABEL_53;
  }
LABEL_54:
  langCodeConverter_loc_CloseLangCodeDictionary(v56, __b);
  uint64_t v22 = v3;
LABEL_55:
  langCodeConverter_loc_FreeAllData(v7);
  return v22;
}

uint64_t langCodeConverter_ObjClose(void *a1, int a2)
{
  uint64_t v3 = safeh_HandleCheck((uint64_t)a1, a2, 239785, 40);
  if ((v3 & 0x80000000) != 0) {
    return 2385518600;
  }
  uint64_t v4 = v3;
  langCodeConverter_loc_FreeAllData(a1);
  return v4;
}

uint64_t langCodeConverter_getIETF(uint64_t a1, int a2, uint64_t a3, void *a4, _DWORD *a5)
{
  return langCodeConverter_getCode(a1, a2, a3, 1u, a4, a5, 1);
}

uint64_t langCodeConverter_get3letter(uint64_t a1, int a2, uint64_t a3, void *a4, _DWORD *a5)
{
  return langCodeConverter_getCode(a1, a2, a3, 0, a4, a5, 1);
}

uint64_t langCodeConverter_getCode(uint64_t a1, int a2, uint64_t a3, unsigned int a4, void *a5, _DWORD *a6, int a7)
{
  uint64_t v13 = safeh_HandleCheck(a1, a2, 239785, 40);
  if ((v13 & 0x80000000) != 0) {
    return 2385518600;
  }
  uint64_t v14 = v13;
  if (a6) {
    *a6 = 0;
  }
  if (!a3) {
    return 2385518599;
  }
  if (a5) {
    *a5 = a3;
  }
  uint64_t v15 = hashtable_Get(*(void *)(a1 + 24));
  if (v15 && *(void *)v15 && (!a7 || *(_DWORD *)(v15 + 8) <= 1u))
  {
    if (a5) {
      *a5 = *(void *)(*(void *)v15 + 8 * a4);
    }
    if (a6) {
      *a6 = 1;
    }
  }
  return v14;
}

uint64_t langCodeConverter_2to3letter(uint64_t a1, int a2, const char *a3, const char **a4, _DWORD *a5)
{
  uint64_t v9 = 2385518599;
  int v10 = safeh_HandleCheck(a1, a2, 239785, 40);
  if (v10 < 0) {
    uint64_t v11 = 2385518600;
  }
  else {
    uint64_t v11 = v10;
  }
  if (v10 < 0) {
    return 2385518600;
  }
  if (a5) {
    *a5 = 0;
  }
  if (a3 && cstdlib_strlen(a3) == 2)
  {
    if (a4) {
      *a4 = a3;
    }
    if (*(void *)(a1 + 16))
    {
      uint64_t v12 = 0;
      while (1)
      {
        uint64_t v13 = *(void *)(*(void *)(a1 + 8) + 8 * v12);
        uint64_t v14 = *(void *)(v13 + 8);
        if (v14)
        {
          if (cstdlib_strlen(*(const char **)(v13 + 8)) >= 4
            && *(unsigned char *)(v14 + 2) == 45
            && !LH_strnicmp(v14, (uint64_t)a3, 2uLL))
          {
            break;
          }
        }
        if ((unint64_t)++v12 >= *(void *)(a1 + 16)) {
          return v11;
        }
      }
      if (a4) {
        *a4 = **(const char ***)(*(void *)(a1 + 8) + 8 * v12);
      }
      if (a5) {
        *a5 = 1;
      }
    }
    return v11;
  }
  return v9;
}

BOOL langCodeConverter_loc_StringCompare(unsigned __int8 *a1, unsigned __int8 *a2)
{
  while (1)
  {
    int v4 = *a2;
    if (v4 == 95)
    {
      int v4 = 45;
      goto LABEL_5;
    }
    if (!*a2) {
      return *a1 == 0;
    }
    int v4 = (char)v4;
LABEL_5:
    int v5 = *a1;
    if (v5 == 95) {
      LOBYTE(v5) = 45;
    }
    if (v4 == (char)v5)
    {
      BOOL v6 = 1;
    }
    else
    {
      int v7 = cstdlib_isupper(*a2);
      int v8 = (char)*a2;
      if (v7) {
        int v8 = cstdlib_tolower((char)*a2);
      }
      int v9 = cstdlib_isupper(*a1);
      uint64_t v10 = (char)*a1;
      if (v9) {
        LODWORD(v10) = cstdlib_tolower(v10);
      }
      BOOL v6 = v8 == v10;
    }
    ++a1;
    ++a2;
    if (!v6) {
      return 0;
    }
  }
}

unint64_t langCodeConverter_loc_StringToHash(unsigned char *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  if (*a1)
  {
    unint64_t v4 = 0;
    int v5 = a1 + 1;
    do
    {
      if (cstdlib_isupper(v3)) {
        LOBYTE(v3) = cstdlib_tolower(v3);
      }
      if (v3 == 95) {
        uint64_t v6 = 45;
      }
      else {
        uint64_t v6 = v3;
      }
      unint64_t v4 = 31 * v4 + v6;
      unsigned int v7 = *v5++;
      uint64_t v3 = v7;
    }
    while (v7);
  }
  else
  {
    unint64_t v4 = 0;
  }
  return v4 % *(void *)(a2 + 32);
}

const char ***langCodeConverter_loc_DumpHashTableLine(const char ***result, char *a2)
{
  if (*result) {
    return (const char ***)sprintf(a2, "%s,%s,%s,%s,%s", **result, (*result)[1], (*result)[2], (*result)[3], (*result)[4]);
  }
  return result;
}

uint64_t langCodeConverter_loc_CloseLangCodeDictionary(uint64_t result, void *a2)
{
  uint64_t v2 = a2[9];
  if (v2)
  {
    uint64_t v4 = result;
    int v5 = (void *)a2[8];
    if (!v5) {
      goto LABEL_13;
    }
    uint64_t v6 = v5[5];
    if (v6)
    {
      heap_Free(*(void **)(v4 + 8), v6);
      int v5 = (void *)a2[8];
      v5[5] = 0;
    }
    uint64_t v7 = v5[2];
    if (v7)
    {
      if (a2[10] && v5[4])
      {
        exit_DctRom((uint64_t)v5, a2[10]);
        uint64_t v7 = *(void *)(a2[8] + 16);
      }
      heap_Free(*(void **)(v4 + 8), v7);
      int v5 = (void *)a2[8];
      v5[2] = 0;
    }
    uint64_t v8 = a2[10];
    if (v8)
    {
      brk_DataClose(a2[9], v8);
      a2[10] = 0;
      int v5 = (void *)a2[8];
    }
    uint64_t result = close_DctRom((uint64_t)v5);
    uint64_t v2 = a2[9];
    if (v2)
    {
LABEL_13:
      uint64_t result = brk_ObjClose(v2);
      a2[9] = 0;
    }
  }
  return result;
}

void *langCodeConverter_loc_FreeAllData(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v3 = result[2];
      if (v3)
      {
        do
        {
          --v3;
          if (*(void *)(v1[1] + 8 * v3))
          {
            for (uint64_t i = 32; i != -8; i -= 8)
            {
              uint64_t v5 = *(void *)(*(void *)(v1[1] + 8 * v3) + i);
              if (v5) {
                heap_Free(*(void **)(*v1 + 8), v5);
              }
            }
            heap_Free(*(void **)(*v1 + 8), *(void *)(v1[1] + 8 * v3));
          }
        }
        while (v3);
        uint64_t v2 = v1[1];
      }
      heap_Free(*(void **)(*v1 + 8), v2);
    }
    uint64_t v6 = (void *)v1[3];
    if (v6) {
      hashtable_ObjClose(v6);
    }
    uint64_t v7 = *(void **)(*v1 + 8);
    return heap_Free(v7, (uint64_t)v1);
  }
  return result;
}

uint64_t langCodeConverter_loc_RetrieveDictionaryEntry(uint64_t a1, unsigned int a2, void *a3, unint64_t a4, _DWORD *a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  __uint64_t n = 0;
  int v11 = 0;
  uint64_t v10 = 0;
  LH_utoa(a2, __n_6, 0xAu);
  int __n_2 = (unsigned __int16)(cstdlib_strlen(__n_6) - 1);
  if (!a5)
  {
    LODWORD(result) = DctLookup(a1, (uint64_t)__n_6, (unsigned __int16 *)&__n_2 + 1, (__int16 *)&__n_2, 1, &__n, (uint64_t)&v10);
    if (!result) {
      goto LABEL_9;
    }
LABEL_5:
    if ((result & 0x1FFF) == 0x14) {
      return 0;
    }
    else {
      return result;
    }
  }
  *a5 = 0;
  LODWORD(result) = DctLookup(a1, (uint64_t)__n_6, (unsigned __int16 *)&__n_2 + 1, (__int16 *)&__n_2, 1, &__n, (uint64_t)&v10);
  if (result) {
    goto LABEL_5;
  }
  *a5 = 1;
LABEL_9:
  uint64_t result = 0;
  if (a3 && a4)
  {
    if (__n >= a4)
    {
      return 2385518601;
    }
    else
    {
      cstdlib_memcpy(a3, *(const void **)(a1 + 40), __n);
      uint64_t result = 0;
      *((unsigned char *)a3 + (__int16)__n) = 0;
    }
  }
  return result;
}

char *langCodeConverter_loc_StrTokAndTrim(uint64_t a1, char *a2, void *a3)
{
  uint64_t result = strhelper_SafeStrtok(a1, a2, a3);
  if (result)
  {
    uint64_t v4 = (unsigned __int8 *)result;
    do
      unsigned __int8 v5 = *v4++;
    while (cstdlib_isspace(v5));
    uint64_t v6 = v4 - 1;
    size_t v7 = cstdlib_strlen((const char *)v4 - 1);
    if (v7)
    {
      uint64_t v8 = &v4[v7];
      if (cstdlib_isspace(*(v8 - 2)))
      {
        int v9 = v8 - 3;
        do
          v9[1] = 0;
        while (cstdlib_isspace(*v9--));
      }
    }
    if (*v6) {
      return (char *)v6;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t SWIlicenseInit()
{
  return 0;
}

uint64_t SWIlicenseInitEx()
{
  return 0;
}

uint64_t SWIlicenseLock()
{
  return 0;
}

uint64_t SWIlicenseLockMulti(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  if (a4) {
    *a4 = a3;
  }
  return 0;
}

uint64_t SWIlicenseUnlock()
{
  return 0;
}

uint64_t SWIlicenseAllowOption()
{
  return 0;
}

uint64_t SWIlicenseValidate()
{
  return 4;
}

uint64_t SWIlicenseTerminate()
{
  return 0;
}

uint64_t SWIlicenseSetGracePeriod()
{
  return 0;
}

uint64_t SWIlicenseCreateLicenseCache()
{
  return 0;
}

uint64_t SWIlicenseDestroyLicenseCache()
{
  return 0;
}

uint64_t SWIlicenseUseCacheableLicense(int a1)
{
  return (100000 * a1);
}

uint64_t SWIlicenseFreeCacheableLicense()
{
  if (num_lic_used) {
    --num_lic_used;
  }
  return 0;
}

uint64_t SWIlicenseGetNumOfLicensesInUseInCache()
{
  return num_lic_used;
}

uint64_t SWIlicenseValidateCachedLicense()
{
  return 4;
}

uint64_t ssftthrottle_ObjOpen(_WORD *a1, int a2, void *a3)
{
  uint64_t v6 = 0;
  int inited = InitRsrcFunction(a1, a2, &v6);
  uint64_t result = 7;
  if ((inited & 0x80000000) == 0 && v6 && *(void *)(v6 + 8))
  {
    if (a3)
    {
      uint64_t result = 0;
      *a3 = 0;
    }
    else
    {
      return 6;
    }
  }
  return result;
}

uint64_t ssftthrottle_ObjClose()
{
  return 0;
}

uint64_t ssftthrottle_Start()
{
  return 0;
}

uint64_t ssftthrottle_Stop()
{
  return 0;
}

uint64_t ssftthrottle_Audio()
{
  return 0;
}

uint64_t ttseg_ClassOpen(_WORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v103 = 0;
  uint64_t v3 = 2166366215;
  uint64_t v102 = 0;
  uint64_t v98 = 0;
  if (!a3) {
    return v3;
  }
  uint64_t v101 = 0;
  long long __b = 0u;
  long long v100 = 0u;
  *a3 = safeh_GetNullHandle();
  a3[1] = v7;
  uint64_t inited = InitRsrcFunction(a1, a2, &v103);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  log_OutText(*(void *)(v103 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Class Open: Begin", v9, v10, v11, v91);
  uint64_t v12 = heap_Calloc(*(void **)(v103 + 8), 1, 256);
  uint64_t v104 = v12;
  if (!v12)
  {
    log_OutPublic(*(void *)(v103 + 32), (uint64_t)"TTSEG", 16000, 0, v13, v14, v15, v16, v92);
    return 2166366218;
  }
  uint64_t v17 = v12;
  uint64_t v18 = critsec_ObjOpen(*(void *)(v103 + 16), *(void **)(v103 + 8), (uint64_t *)(v12 + 208));
  if ((v18 & 0x80000000) != 0)
  {
    uint64_t v3 = v18;
    log_OutPublic(*(void *)(v103 + 32), (uint64_t)"TTSEG", 16111, (uint64_t)"%s%x", v19, v20, v21, v22, "lherror");
    goto LABEL_91;
  }
  *(void *)uint64_t v17 = a1;
  *(void *)(v17 + 8) = a2;
  LH_itoa(7u, (char *)(v17 + 68), 0xAu);
  cstdlib_strcat((char *)(v17 + 68), ".");
  size_t v23 = cstdlib_strlen((const char *)(v17 + 68));
  LH_itoa(4u, (char *)(v17 + 68 + v23), 0xAu);
  cstdlib_strcat((char *)(v17 + 68), ".");
  size_t v24 = cstdlib_strlen((const char *)(v17 + 68));
  LH_itoa(0, (char *)(v17 + 68 + v24), 0xAu);
  uint64_t v25 = v103;
  uint64_t v26 = *(void *)(v103 + 40);
  if (!v26)
  {
    uint64_t v27 = paramc_ObjOpen(0, (uint64_t)a1, a2, v103 + 40);
    if ((v27 & 0x80000000) != 0)
    {
      uint64_t v3 = v27;
      log_OutPublic(*(void *)(v103 + 32), (uint64_t)"TTSEG", 16021, (uint64_t)"%s%x", v28, v29, v30, v31, "lherror");
      goto LABEL_91;
    }
    *(_DWORD *)(v17 + 64) = 1;
    uint64_t v25 = v103;
    uint64_t v26 = *(void *)(v103 + 40);
  }
  int v107 = 0;
  unsigned int v105 = 0;
  unsigned int v106 = -1;
  BOOL v33 = (int)paramc_ParamGetUInt(v26, (uint64_t)"licensingexplicit", &v105) >= 0 && v105 == 1;
  *(_DWORD *)(v17 + 220) = v33;
  if ((paramc_ParamGetUInt(*(void *)(v25 + 40), (uint64_t)"licensegraceperiod", &v106) & 0x80000000) == 0)
  {
    if ((SWIlicense_inhibited & 1) != 0 || !SWIlicenseSetGracePeriod()) {
      log_OutText(*(void *)(v25 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"License grace period set to %lu", v34, v35, v36, v106);
    }
    else {
      log_OutPublic(*(void *)(v25 + 32), (uint64_t)"TTSEG", 16127, 0, v37, v34, v35, v36, v92);
    }
  }
  if ((paramc_ParamGetUInt(*(void *)(v25 + 40), (uint64_t)"ttslicensingports", (unsigned int *)(v17 + 112)) & 0x80000000) != 0)
  {
    *(_DWORD *)(v17 + 112) = 0x7FFFFFFF;
    *(_DWORD *)(v17 + 120) = 0x7FFFFFFF;
  }
  else
  {
    paramc_ParamGetUInt(*(void *)(v25 + 40), (uint64_t)"ttslicensedynamicports", (unsigned int *)(v17 + 128));
    if (*(_DWORD *)(v17 + 112) + *(_DWORD *)(v17 + 128))
    {
      paramc_ParamGetUInt(*(void *)(v25 + 40), (uint64_t)"ttslicensingportsoverdraftthresh", (unsigned int *)(v17 + 120));
      paramc_ParamGetUInt(*(void *)(v25 + 40), (uint64_t)"dynamiclicenseexpirationtime", (unsigned int *)(v17 + 132));
    }
  }
  paramc_ParamGetUInt(*(void *)(v25 + 40), (uint64_t)"cprlicensingports", (unsigned int *)(v17 + 136));
  paramc_ParamGetUInt(*(void *)(v25 + 40), (uint64_t)"cprlicensedynamicports", (unsigned int *)(v17 + 152));
  if (*(_DWORD *)(v17 + 136) + *(_DWORD *)(v17 + 152))
  {
    paramc_ParamGetUInt(*(void *)(v25 + 40), (uint64_t)"cprlicensingportsoverdraftthresh", (unsigned int *)(v17 + 144));
    paramc_ParamGetUInt(*(void *)(v25 + 40), (uint64_t)"dynamiclicenseexpirationtime", (unsigned int *)(v17 + 156));
  }
  uint64_t v95 = a1;
  uint64_t v96 = a3;
  uint64_t v97 = v17;
  if (ttseg_loc_check_vns(*(void *)(v25 + 40)))
  {
    int v42 = 2;
    *(_DWORD *)(v17 + 160) = 2;
    *(_DWORD *)(v17 + 168) = 2;
  }
  else
  {
    int v42 = 0;
  }
  uint64_t v43 = 0;
  char v44 = 1;
  do
  {
    uint64_t v45 = v97 + 24 * v43;
    int v47 = *(_DWORD *)(v45 + 112);
    uint64_t v46 = (_DWORD *)(v45 + 112);
    int v49 = v46 + 4;
    int v48 = v46[4];
    unsigned int v50 = v48 + v47;
    unsigned int v51 = v46[2];
    if (v47 + v48) {
      BOOL v52 = v51 == 0;
    }
    else {
      BOOL v52 = 0;
    }
    if (v52)
    {
      uint64_t v53 = *(void *)(v25 + 32);
      int v54 = 16107;
      goto LABEL_39;
    }
    if (v51 > v50)
    {
      uint64_t v53 = *(void *)(v25 + 32);
      int v54 = 16109;
LABEL_39:
      log_OutPublic(v53, (uint64_t)"TTSEG", (v43 + v54), 0, v38, v39, v40, v41, v92);
      int v48 = *v49;
      v46[2] = *v49 + *v46;
    }
    if (v48)
    {
      uint64_t v55 = v97 + 24 * v43;
      unsigned int v57 = *(_DWORD *)(v55 + 132);
      uint64_t v56 = (_DWORD *)(v55 + 132);
      if (v57 <= 0x1D)
      {
        log_OutPublic(*(void *)(v25 + 32), (uint64_t)"TTSEG", 16126, (uint64_t)"%s%u%s%s", v38, v39, v40, v41, "min_val");
        *uint64_t v56 = 30;
      }
    }
    v42 += v50;
    int v58 = v44 & 1;
    uint64_t v59 = "CPR";
    if (v44) {
      uint64_t v59 = "TTS";
    }
    log_OutText(*(void *)(v25 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"%s licensing pool size = %lu, max dynamic licenses = %lu, overdraft threshold = %lu", v39, v40, v41, (uint64_t)v59);
    char v44 = 0;
    uint64_t v43 = 1;
  }
  while (v58);
  if (!v42) {
    log_OutPublic(*(void *)(v25 + 32), (uint64_t)"TTSEG", 16105, 0, v38, v39, v40, v41, v92);
  }
  if ((paramc_ParamGetStr(*(void *)(v25 + 40), (uint64_t)"licensingservers", &v107) & 0x80000000) != 0
    || (uint64_t v63 = (uint64_t)v107) == 0
    || !*v107)
  {
    int v107 = "27000@localhost";
    uint64_t v3 = paramc_ParamSetStr(*(void *)(v25 + 40), (uint64_t)"licensingservers", "27000@localhost");
    if ((v3 & 0x80000000) == 0)
    {
      uint64_t v63 = (uint64_t)v107;
      goto LABEL_54;
    }
    goto LABEL_91;
  }
  uint64_t v3 = 0;
LABEL_54:
  log_OutText(*(void *)(v25 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG licensing configuration : servers '%s'", v60, v61, v62, v63);
  paramc_ParamGetStr(*(void *)(v103 + 40), (uint64_t)"licensingservers", &v98);
  if ((SWIlicense_inhibited & 1) == 0 && SWIlicenseInitEx())
  {
    log_OutText(*(void *)(v103 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG SWIlicenseInitEx failed : End", v64, v65, v66, v93);
    goto LABEL_57;
  }
  *(_DWORD *)(v97 + 216) = ttseg_loc_LicensingAcquirePool(v103, v97, 4, 3) >> 31;
  BOOL v73 = (SWIlicense_inhibited & 1) != 0 || SWIlicenseLockMulti(0, 10, 1, 0) == 0;
  *(_DWORD *)(v97 + 228) = v73;
  if (v73) {
    long long v74 = "ON";
  }
  else {
    long long v74 = "OFF";
  }
  log_OutText(*(void *)(v103 + 32), (uint64_t)"TTSEG", 3, 0, (uint64_t)"Unmetered is %s", v70, v71, v72, (uint64_t)v74);
  if ((SWIlicense_inhibited & 1) != 0
    || !SWIlicenseLockMulti(0, 8, 1, 0)
    || (SWIlicense_inhibited & 1) != 0
    || !SWIlicenseLockMulti(0, 9, 1, 0))
  {
    long long v78 = "Found a license feature of type MRCP_PPM";
    int v79 = 2;
  }
  else if (SWIlicense_inhibited)
  {
    long long v78 = "Found a license feature of type MRCP";
    int v79 = 1;
  }
  else
  {
    int v79 = 1;
    if (SWIlicenseLockMulti(0, 6, 1, 0))
    {
      long long v78 = "Found a license feature of type MRCP";
      if ((SWIlicense_inhibited & 1) == 0)
      {
        int v90 = SWIlicenseLockMulti(0, 7, 1, 0);
        int v79 = v90 == 0;
        if (v90) {
          long long v78 = "License feature type is standard";
        }
      }
    }
    else
    {
      long long v78 = "Found a license feature of type MRCP";
    }
  }
  *(_DWORD *)(v97 + 224) = v79;
  log_OutText(*(void *)(v103 + 32), (uint64_t)"TTSEG", 3, 0, (uint64_t)v78, v75, v76, v77, v94);
  uint64_t v80 = ttseg_loc_LicensingAcquirePool(v103, v97, g_SWIlicenseFeatureTTSOpt[*(unsigned int *)(v97 + 224)], 0);
  if ((v80 & 0x80000000) != 0) {
    goto LABEL_90;
  }
  uint64_t v80 = ttseg_loc_LicensingAcquirePool(v103, v97, g_SWIlicenseFeatureCPROpt[*(unsigned int *)(v97 + 224)], 1);
  if ((v80 & 0x80000000) != 0) {
    goto LABEL_90;
  }
  *(void *)(v97 + 164) = 0x200000002;
  if ((langCodeConverter_GetInterface(1u, (void *)(v97 + 88)) & 0x80000000) != 0) {
    goto LABEL_78;
  }
  uint64_t v80 = (**(uint64_t (***)(_WORD *, uint64_t, uint64_t))(v97 + 88))(v95, a2, v97 + 96);
  if ((v80 & 0x80000000) != 0) {
    goto LABEL_90;
  }
  if (!*(void *)(v103 + 48)) {
    goto LABEL_78;
  }
  cstdlib_memset(&__b, 0, 0x28uLL);
  LOBYTE(__b) = 1;
  *((void *)&__b + 1) = *(void *)(v97 + 88);
  long long v100 = *(_OWORD *)(v97 + 96);
  uint64_t v101 = 0;
  uint64_t v81 = objc_RegisterObject(*(void *)(v103 + 48), (uint64_t)"LANGCODECONVERTER", &__b);
  if ((v81 & 0x80000000) != 0)
  {
LABEL_94:
    uint64_t v3 = v81;
    log_OutPublic(*(void *)(v103 + 32), (uint64_t)"TTSEG", 16098, (uint64_t)"%s%x", v82, v83, v84, v85, "lherror");
    goto LABEL_91;
  }
  *(_DWORD *)(v97 + 60) = 1;
LABEL_78:
  uint64_t v86 = v103;
  uint64_t v87 = *(void *)(v103 + 48);
  if (v87)
  {
    if ((objc_GetObject(v87, (uint64_t)"COMPQUERY", &v102) & 0x80000000) == 0)
    {
      uint64_t v88 = v102;
      *(void *)(v97 + 32) = *(void *)(v102 + 8);
      *(_OWORD *)(v97 + 40) = *(_OWORD *)(v88 + 16);
      goto LABEL_81;
    }
    uint64_t v86 = v103;
  }
  uint64_t v80 = brk_InterfaceQueryEx(*(void *)(v86 + 24), (uint64_t)"compquery", 1, 1, v97 + 16, v97 + 32);
  if ((v80 & 0x80000000) != 0
    || (uint64_t v80 = (*(uint64_t (**)(void, void, _WORD *, uint64_t, uint64_t))(*(void *)(v97 + 32) + 32))(*(void *)(v97 + 16), *(void *)(v97 + 24), v95, a2, v97 + 40), (v80 & 0x80000000) != 0))
  {
LABEL_90:
    uint64_t v3 = v80;
    goto LABEL_91;
  }
  if (!*(void *)(v103 + 48)) {
    goto LABEL_81;
  }
  cstdlib_memset(&__b, 0, 0x28uLL);
  LOBYTE(__b) = 1;
  *((void *)&__b + 1) = *(void *)(v97 + 32);
  long long v100 = *(_OWORD *)(v97 + 40);
  uint64_t v101 = 0;
  uint64_t v81 = objc_RegisterObject(*(void *)(v103 + 48), (uint64_t)"COMPQUERY", &__b);
  if ((v81 & 0x80000000) != 0) {
    goto LABEL_94;
  }
  *(_DWORD *)(v97 + 56) = 1;
LABEL_81:
  uint64_t v3 = esc_seq_init(v95, a2, (uint64_t *)(v97 + 232));
  if ((v3 & 0x80000000) != 0)
  {
LABEL_91:
    ttseg_loc_ClassClose(v103, &v104);
    uint64_t v104 = 0;
  }
  else
  {
LABEL_57:
    *uint64_t v96 = v97;
    *((_DWORD *)v96 + 2) = 52653;
  }
  log_OutText(*(void *)(v103 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Class Open : End (%x, %p)", v67, v68, v69, v3);
  return v3;
}

uint64_t ttseg_loc_LicensingAcquirePool(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v19 = 0;
  if (a4 == 2)
  {
    uint64_t result = 0;
    *(void *)(a2 + 164) = 0x200000002;
    return result;
  }
  uint64_t result = 2166366215;
  if (a3 <= 9)
  {
    if (((1 << a3) & 0x141) != 0)
    {
      unsigned int v8 = 0;
    }
    else
    {
      if (((1 << a3) & 0x288) == 0)
      {
        if (a3 != 4) {
          return result;
        }
        if (SWIlicense_inhibited == 1)
        {
          int v19 = 1;
          unsigned int v8 = 3;
          goto LABEL_28;
        }
        int v12 = SWIlicenseLockMulti(0, 4, 1, &v19);
        unsigned int v8 = 3;
        if (v12 == 4) {
          goto LABEL_28;
        }
        goto LABEL_18;
      }
      unsigned int v8 = 1;
    }
    uint64_t v9 = a2 + 24 * v8;
    uint64_t v10 = (int *)(v9 + 112);
    if (*(_DWORD *)(v9 + 128) && (SWIlicense_inhibited & 1) == 0) {
      SWIlicenseCreateLicenseCache();
    }
    int v11 = *v10;
    if (!*v10) {
      return 0;
    }
    if (SWIlicense_inhibited == 1)
    {
      int v19 = *v10;
      *(_DWORD *)(a2 + 24 * v8 + 116) = v11;
LABEL_28:
      ttseg_loc_LicenseLog((uint64_t **)a1, a2, v8, 10);
      return 0;
    }
    int v12 = SWIlicenseLockMulti(0, a3, v11, &v19);
    unsigned int v17 = v19;
    if (v12) {
      int v18 = 0;
    }
    else {
      int v18 = v19;
    }
    *(_DWORD *)(a2 + 24 * v8 + 116) = v18;
    if (!v12)
    {
      if (v17 >= *v10) {
        goto LABEL_28;
      }
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", v8 | 0x3EF6, (uint64_t)"%s%u%s%u", v13, v14, v15, v16, "configuredPorts");
      return 2166373638;
    }
LABEL_18:
    if (v12 == 4) {
      return 2166373639;
    }
    if (!v12) {
      goto LABEL_28;
    }
    return 2166373638;
  }
  return result;
}

uint64_t ttseg_loc_ClassClose(uint64_t a1, uint64_t *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = *a2;
  if (!*a2) {
    return 0;
  }
  *a2 = 0;
  uint64_t v4 = *(void *)(a1 + 48);
  if (!*(_DWORD *)(v2 + 56))
  {
    if (v4 && *(void *)(v2 + 32))
    {
      if ((objc_ReleaseObject(v4, (uint64_t)"COMPQUERY") & 0x80000000) != 0) {
        log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16097, (uint64_t)"%s%x", v11, v12, v13, v14, "lherror");
      }
      *(void *)(v2 + 32) = 0;
      uint64_t v10 = 0;
      *(void *)(v2 + 40) = safeh_GetNullHandle();
      *(void *)(v2 + 48) = v15;
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v5 = objc_UnregisterObject(v4, (uint64_t)"COMPQUERY");
  if ((v5 & 0x80000000) == 0)
  {
LABEL_12:
    uint64_t v10 = 0;
    goto LABEL_13;
  }
  uint64_t v10 = v5;
  log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16096, (uint64_t)"%s%x", v6, v7, v8, v9, "lherror");
LABEL_13:
  uint64_t v16 = *(void *)(v2 + 32);
  if (v16)
  {
    uint64_t v17 = *(void *)(v2 + 40);
    if (v17)
    {
      int v18 = (*(uint64_t (**)(uint64_t, void))(v16 + 40))(v17, *(void *)(v2 + 48));
      if (v18 < 0 && (int)v10 > -1) {
        LODWORD(v10) = v18;
      }
      uint64_t v16 = *(void *)(v2 + 32);
    }
    int v20 = brk_InterfaceRelease(*(void *)(a1 + 24), v16);
    if (v20 >= 0 || (int)v10 <= -1) {
      uint64_t v10 = v10;
    }
    else {
      uint64_t v10 = v20;
    }
  }
  uint64_t v22 = *(void *)(a1 + 48);
  if (v22 && *(void *)(v2 + 88) && *(_DWORD *)(v2 + 60))
  {
    uint64_t v23 = objc_UnregisterObject(v22, (uint64_t)"LANGCODECONVERTER");
    if ((v23 & 0x80000000) != 0)
    {
      uint64_t v28 = v23;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16096, (uint64_t)"%s%x", v24, v25, v26, v27, "lherror");
      uint64_t v10 = v28;
    }
    uint64_t v29 = *(void *)(v2 + 96);
    if (v29)
    {
      int v30 = (*(uint64_t (**)(uint64_t, void))(*(void *)(v2 + 88) + 8))(v29, *(void *)(v2 + 104));
      if (v30 >= 0 || (int)v10 <= -1) {
        uint64_t v10 = v10;
      }
      else {
        uint64_t v10 = v30;
      }
    }
  }
  if ((SWIlicense_inhibited & 1) == 0) {
    SWIlicenseDestroyLicenseCache();
  }
  if (*(_DWORD *)(v2 + 140))
  {
    ttseg_loc_LicenseLog((uint64_t **)a1, v2, 1, 11);
    if ((SWIlicense_inhibited & 1) == 0 && SWIlicenseUnlock())
    {
      uint64_t v10 = 2166373642;
      log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG SWIlicenseUnlock failed", v32, v33, v34, v49);
    }
    *(_DWORD *)(v2 + 140) = 0;
  }
  if ((SWIlicense_inhibited & 1) == 0) {
    SWIlicenseDestroyLicenseCache();
  }
  if (*(_DWORD *)(v2 + 116))
  {
    ttseg_loc_LicenseLog((uint64_t **)a1, v2, 0, 11);
    if ((SWIlicense_inhibited & 1) == 0 && SWIlicenseUnlock())
    {
      uint64_t v10 = 2166373642;
      log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG SWIlicenseUnlock failed", v35, v36, v37, v49);
    }
    *(_DWORD *)(v2 + 116) = 0;
  }
  if (*(_DWORD *)(v2 + 164)) {
    *(_DWORD *)(v2 + 164) = 0;
  }
  if ((SWIlicense_inhibited & 1) == 0 && SWIlicenseTerminate())
  {
    uint64_t v10 = 2166373642;
    log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG SWIlicenseTerminate failed", v38, v39, v40, v49);
  }
  uint64_t v41 = *(void *)(v2 + 208);
  if (v41)
  {
    int v42 = critsec_ObjClose(v41);
    if ((int)v10 > -1 && v42 < 0) {
      uint64_t v10 = v42;
    }
    else {
      uint64_t v10 = v10;
    }
  }
  if (*(_DWORD *)(v2 + 64) == 1)
  {
    int v44 = paramc_ObjClose(*(void *)(a1 + 40));
    if ((int)v10 > -1 && v44 < 0) {
      uint64_t v10 = v44;
    }
    else {
      uint64_t v10 = v10;
    }
  }
  uint64_t v46 = *(void **)(v2 + 232);
  if (v46)
  {
    esc_seq_deinit(*(_WORD **)v2, *(void *)(v2 + 8), v46, *(void *)(v2 + 240));
    *(void *)(v2 + 232) = safeh_GetNullHandle();
    *(void *)(v2 + 240) = v47;
  }
  if ((v10 & 0x80000000) == 0) {
    heap_Free(*(void **)(a1 + 8), v2);
  }
  return v10;
}

uint64_t ttseg_QueryCapability(const char *a1, unsigned char *a2)
{
  uint64_t v2 = 2166366208;
  if (a1 && a2)
  {
    if (!cstdlib_strcmp(a1, "uselect-query-capability")) {
      goto LABEL_20;
    }
    if (!cstdlib_strcmp(a1, "ldb-consistency-check"))
    {
      uint64_t v2 = 0;
      *a2 = 1;
      return v2;
    }
    if (!cstdlib_strcmp(a1, "lightssml"))
    {
      uint64_t v2 = 0;
      *(void *)a2 = "1.0";
      return v2;
    }
    if (!cstdlib_strcmp(a1, "phonetic-ap")
      || !cstdlib_strcmp(a1, "tn-internal-nuance-system-norm")
      || !cstdlib_strcmp(a1, "phonmap-multi-voice-format")
      || !cstdlib_strcmp(a1, "tAP-support-for-bndprm-voice")
      || !cstdlib_strcmp(a1, "voice-operating-point")
      || !cstdlib_strcmp(a1, "ruleset-type_out")
      || !cstdlib_strcmp(a1, "tAP-intra-silunits")
      || !cstdlib_strcmp(a1, "vocal-add-on")
      || !cstdlib_strcmp(a1, "tAP-silence-not-imposed-on-backend")
      || !cstdlib_strcmp(a1, "tAP-silence-not-imposed-on-backend")
      || !cstdlib_strcmp(a1, "bet5-f0dur-tuning")
      || !cstdlib_strcmp(a1, "tn-typed-user-dictionary")
      || !cstdlib_strcmp(a1, "language-of-origin-user-dictionary")
      || !cstdlib_strcmp(a1, "tuning-resources-package-cup"))
    {
LABEL_20:
      uint64_t v2 = 0;
      *(_DWORD *)a2 = 1;
    }
  }
  return v2;
}

uint64_t ttseg_ClassClose(void *a1, int a2)
{
  uint64_t v2 = 2166366216;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  if ((ttseg_loc_CheckClassHandle(a1, a2, &v14, &v15) & 0x80000000) == 0)
  {
    uint64_t v6 = v15;
    log_OutText(*(void *)(v14 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Class Close : Begin (%p)", v3, v4, v5, v15);
    if (*(_DWORD *)(v6 + 248))
    {
      log_OutText(*(void *)(v14 + 32), (uint64_t)"TTSEG", 0, 0, (uint64_t)"TTSEG Class Close fails: %u open instances left", v7, v8, v9, *(unsigned int *)(v6 + 248));
      return 2166366225;
    }
    else
    {
      uint64_t v2 = ttseg_loc_ClassClose(v14, &v15);
      log_OutText(*(void *)(v14 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Class Close : End (%x)", v10, v11, v12, v2);
    }
  }
  return v2;
}

uint64_t ttseg_loc_CheckClassHandle(void *a1, int a2, void *a3, void *a4)
{
  *a4 = 0;
  uint64_t result = safeh_HandleCheck((uint64_t)a1, a2, 52653, 256);
  if ((result & 0x80000000) != 0)
  {
    if ((result & 0x1FFF) == 8) {
      return 2166366216;
    }
    else {
      return result;
    }
  }
  else
  {
    *a4 = a1;
    if (a3)
    {
      uint64_t v8 = (_WORD *)*a1;
      uint64_t v9 = a1[1];
      return InitRsrcFunction(v8, v9, a3);
    }
  }
  return result;
}

uint64_t ttseg_GetTTSLicensePorts(void *a1, int a2, _DWORD *a3)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v4 = ttseg_loc_CheckClassHandle(a1, a2, &v7, &v8);
  uint64_t v5 = 2166366216;
  if ((v4 & 0x80000000) == 0 && v8)
  {
    if (a3) {
      *a3 = *(_DWORD *)(v8 + 116);
    }
    return v4;
  }
  return v5;
}

uint64_t ttseg_ObjOpen(void *a1, int a2, _WORD *a3, uint64_t a4, long long *a5, uint64_t a6, char *a7, long long *a8)
{
  uint64_t v109 = 0;
  uint64_t v110 = 0;
  uint64_t v108 = 0;
  int v107 = 0;
  uint64_t AlternativeEscSeq = 2166366218;
  unsigned int v105 = 0;
  uint64_t v106 = 0;
  long long v104 = 0uLL;
  if ((ttseg_loc_CheckClassHandle(a1, a2, &v110, &v109) & 0x80000000) != 0) {
    return 2166366216;
  }
  if (!a8) {
    return 2166366214;
  }
  uint64_t inited = InitRsrcFunction(a3, a4, &v110);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  if (!*(void *)(v110 + 40)) {
    return 2166366215;
  }
  log_OutText(*(void *)(v110 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Object Open: Begin (%p, %p, %s)", v16, v17, v18, (uint64_t)a5);
  uint64_t v19 = heap_Calloc(*(void **)(v110 + 8), 1, 592);
  unsigned int v111 = (unsigned int *)v19;
  if (!v19)
  {
    log_OutPublic(*(void *)(v110 + 32), (uint64_t)"TTSEG", 16000, 0, v20, v21, v22, v23, v100);
    return AlternativeEscSeq;
  }
  uint64_t v24 = v19;
  *(void *)a8 = v19;
  *((_DWORD *)a8 + 2) = 52652;
  *(void *)uint64_t v19 = a3;
  *(void *)(v19 + 8) = a4;
  *(_OWORD *)(v19 + 16) = *a8;
  uint64_t v25 = v109;
  *(void *)(v19 + 32) = v109;
  long long v26 = *a5;
  long long v27 = a5[1];
  *(_OWORD *)(v19 + 72) = a5[2];
  *(_OWORD *)(v19 + 56) = v27;
  *(_OWORD *)(v19 + 40) = v26;
  *(void *)(v19 + 88) = a6;
  *(_DWORD *)(v19 + 104) = 1;
  *(_DWORD *)(v19 + 192) = 3;
  *(void *)(v19 + 552) = 0;
  uint64_t v28 = critsec_ObjOpen(*(void *)(v110 + 16), *(void **)(v110 + 8), (uint64_t *)(v19 + 96));
  if ((v28 & 0x80000000) != 0)
  {
    uint64_t v39 = v28;
    log_OutPublic(*(void *)(v110 + 32), (uint64_t)"TTSEG", 16024, (uint64_t)"%s%x", v29, v30, v31, v32, "lherror");
    uint64_t AlternativeEscSeq = v39;
    goto LABEL_66;
  }
  uint64_t v33 = *(void **)(v110 + 8);
  uint64_t v34 = (uint64_t *)(v24 + 120);
  long long __b = xmmword_26D214EC8;
  *(uint64_t (**)())&long long v102 = off_26D214ED8[0];
  if (!vector_ObjOpen(v33, &__b, 1, (uint64_t *)(v24 + 120)))
  {
    log_OutPublic(*(void *)(v110 + 32), (uint64_t)"TTSEG", 16000, 0, v35, v36, v37, v38, v100);
    goto LABEL_66;
  }
  if ((objc_GetObject(*(void *)(v110 + 48), (uint64_t)"SYNTHSTREAM", &v108) & 0x80000000) != 0)
  {
    uint64_t Object = pipeline_LoadObject(a3, a4, (uint64_t)"SYNTHSTREAM", "synthstream", *v34, 0);
    if ((Object & 0x80000000) != 0) {
      goto LABEL_26;
    }
    uint64_t v47 = objc_GetObject(*(void *)(v110 + 48), (uint64_t)"SYNTHSTREAM", &v108);
    if ((v47 & 0x80000000) != 0)
    {
      uint64_t AlternativeEscSeq = v47;
      log_OutPublic(*(void *)(v110 + 32), (uint64_t)"TTSEG", 16086, (uint64_t)"%s%x", v48, v49, v50, v51, "lherror");
      goto LABEL_66;
    }
  }
  *(void *)(v24 + 128) = *(void *)(v108 + 8);
  if ((objc_GetObject(*(void *)(v110 + 48), (uint64_t)"LINGDB", &v108) & 0x80000000) == 0) {
    goto LABEL_10;
  }
  uint64_t Object = pipeline_LoadObject(a3, a4, (uint64_t)"LINGDB", "lingdb", *v34, 0);
  if ((Object & 0x80000000) != 0)
  {
LABEL_26:
    uint64_t AlternativeEscSeq = Object;
    goto LABEL_66;
  }
  uint64_t v52 = objc_GetObject(*(void *)(v110 + 48), (uint64_t)"LINGDB", &v108);
  if ((v52 & 0x80000000) != 0)
  {
    uint64_t AlternativeEscSeq = v52;
    log_OutPublic(*(void *)(v110 + 32), (uint64_t)"TTSEG", 16087, (uint64_t)"%s%x", v53, v54, v55, v56, "lherror");
    goto LABEL_66;
  }
LABEL_10:
  *(void *)(v24 + 168) = *(void *)(v108 + 8);
  if (*(void *)(v25 + 88))
  {
    if ((objc_GetObject(*(void *)(v110 + 48), (uint64_t)"LANGCODECONVERTER", &v108) & 0x80000000) != 0)
    {
      uint64_t v103 = 0;
      long long __b = 0u;
      long long v102 = 0u;
      cstdlib_memset(&__b, 0, 0x28uLL);
      LOBYTE(__b) = 1;
      *((void *)&__b + 1) = *(void *)(v25 + 88);
      long long v102 = *(_OWORD *)(v25 + 96);
      uint64_t v57 = objc_RegisterObject(*(void *)(v110 + 48), (uint64_t)"LANGCODECONVERTER", &__b);
      if ((v57 & 0x80000000) != 0) {
        goto LABEL_43;
      }
      *(_DWORD *)(v24 + 176) = 1;
    }
    else
    {
      objc_ReleaseObject(*(void *)(v110 + 48), (uint64_t)"LANGCODECONVERTER");
    }
  }
  if (*(void *)(v25 + 32))
  {
    if ((objc_GetObject(*(void *)(v110 + 48), (uint64_t)"COMPQUERY", &v108) & 0x80000000) != 0)
    {
      uint64_t v103 = 0;
      long long __b = 0u;
      long long v102 = 0u;
      cstdlib_memset(&__b, 0, 0x28uLL);
      LOBYTE(__b) = 1;
      *((void *)&__b + 1) = *(void *)(v25 + 32);
      long long v102 = *(_OWORD *)(v25 + 40);
      uint64_t v57 = objc_RegisterObject(*(void *)(v110 + 48), (uint64_t)"COMPQUERY", &__b);
      if ((v57 & 0x80000000) != 0) {
        goto LABEL_43;
      }
      *(_DWORD *)(v24 + 180) = 1;
    }
    else
    {
      objc_ReleaseObject(*(void *)(v110 + 48), (uint64_t)"COMPQUERY");
    }
  }
  if ((objc_GetObject(*(void *)(v110 + 48), (uint64_t)"TTSEG", &v108) & 0x80000000) != 0)
  {
    uint64_t v103 = 0;
    long long __b = 0u;
    long long v102 = 0u;
    cstdlib_memset(&__b, 0, 0x28uLL);
    LOBYTE(__b) = 3;
    long long v102 = *a8;
    *((void *)&__b + 1) = &ITtsEg;
    uint64_t v57 = objc_RegisterObject(*(void *)(v110 + 48), (uint64_t)"TTSEG", &__b);
    if ((v57 & 0x80000000) == 0)
    {
      *(_DWORD *)(v24 + 184) = 1;
      goto LABEL_38;
    }
LABEL_43:
    uint64_t AlternativeEscSeq = v57;
    log_OutPublic(*(void *)(v110 + 32), (uint64_t)"TTSEG", 16098, (uint64_t)"%s%x", v58, v59, v60, v61, "lherror");
    goto LABEL_66;
  }
  objc_ReleaseObject(*(void *)(v110 + 48), (uint64_t)"TTSEG");
LABEL_38:
  uint64_t UInt = tinystack_Ini(v110, 50, (void *)(v24 + 576));
  uint64_t v67 = v110;
  if ((UInt & 0x80000000) != 0) {
    goto LABEL_63;
  }
  uint64_t v68 = InitLoadedCupList(*(void **)(v110 + 8), (uint64_t *)(v24 + 584));
  if ((v68 & 0x80000000) != 0)
  {
LABEL_64:
    uint64_t AlternativeEscSeq = v68;
    uint64_t v67 = v110;
    goto LABEL_65;
  }
  cstdlib_memset(&v104, 0, 0x18uLL);
  *(void *)&long long v104 = v24;
  *((void *)&v104 + 1) = ttseg_loc_ParamCheckChange;
  unsigned int v105 = ttseg_loc_ParamLearnChange;
  if (log_GetLogLevel(*(void *)(v110 + 32)) >= 4)
  {
    uint64_t v69 = *(void *)(v110 + 40);
    long long __b = v104;
    *(void *)&long long v102 = v105;
    if ((paramc_ListenerAdd(v69, 0, &__b) & 0x80000000) != 0) {
      log_OutPublic(*(void *)(v110 + 32), (uint64_t)"TTSEG", 16025, 0, v70, v71, v72, v73, v100);
    }
    else {
      *(_DWORD *)(v24 + 188) = 1;
    }
  }
  ttseg_loc_ParamSetIfNotSetUInt(*(void *)(v110 + 40), (uint64_t)"pitch", 0x64u);
  ttseg_loc_ParamSetIfNotSetUInt(*(void *)(v110 + 40), (uint64_t)"rate", 0x64u);
  ttseg_loc_ParamSetIfNotSetUInt(*(void *)(v110 + 40), (uint64_t)"volume", 0x50u);
  ttseg_loc_ParamSetIfNotSetUInt(*(void *)(v110 + 40), (uint64_t)"pitch_baseline", 0x64u);
  ttseg_loc_ParamSetIfNotSetUInt(*(void *)(v110 + 40), (uint64_t)"rate_baseline", 0x64u);
  ttseg_loc_ParamSetIfNotSetUInt(*(void *)(v110 + 40), (uint64_t)"timbre_baseline", 0x64u);
  ttseg_loc_ParamSetIfNotSetUInt(*(void *)(v110 + 40), (uint64_t)"volume_baseline", 0x50u);
  ttseg_loc_ParamSetIfNotSetUInt(*(void *)(v110 + 40), (uint64_t)"waitfactor", 2u);
  ttseg_loc_ParamSetIfNotSetUInt(*(void *)(v110 + 40), (uint64_t)"readmode", 1u);
  ttseg_loc_ParamSetIfNotSetUInt(*(void *)(v110 + 40), (uint64_t)"markermode", 0);
  ttseg_loc_ParamSetIfNotSetUInt(*(void *)(v110 + 40), (uint64_t)"infiniteloopdetectlimit", 0x2710u);
  ttseg_loc_ParamSetIfNotSetStr(*(void *)(v110 + 40), (uint64_t)"inputmimetype", byte_2207887FC);
  ttseg_loc_ParamSetIfNotSetUInt(*(void *)(v110 + 40), (uint64_t)"audiooutputbufsamples", 0x1000u);
  ttseg_loc_ParamSetIfNotSetStr(*(void *)(v110 + 40), (uint64_t)"licensingmode", "default");
  ttseg_loc_ParamSetIfNotSetStr(*(void *)(v110 + 40), (uint64_t)"__NUAN_alternative_esc_seq__", byte_2207887FC);
  ttseg_loc_ParamSetIfNotSetStr(*(void *)(v110 + 40), (uint64_t)"companyname", byte_2207887FC);
  ttseg_loc_ParamSetIfNotSetStr(*(void *)(v110 + 40), (uint64_t)"applicationname", byte_2207887FC);
  ttseg_loc_ParamSetIfNotSetStr(*(void *)(v110 + 40), (uint64_t)"is_teng", "no");
  ttseg_loc_ParamSetIfNotSetStr(*(void *)(v110 + 40), (uint64_t)"basicclcprosody", "no");
  ttseg_loc_ParamSetIfNotSetStr(*(void *)(v110 + 40), (uint64_t)"punctmarks", byte_2207887FC);
  ttseg_loc_ParamSetIfNotSetStr(*(void *)(v110 + 40), (uint64_t)"addondct_extended_lookup", "no");
  ttseg_loc_ParamSetIfNotSetUInt(*(void *)(v110 + 40), (uint64_t)"nnpausingoverride", 0);
  LODWORD(__b) = 1;
  paramc_ParamGetUInt(*(void *)(v110 + 40), (uint64_t)"waitfactor", (unsigned int *)&__b);
  paramc_ParamSetUInt(*(void *)(v110 + 40), (uint64_t)"waitfactorbackup", __b);
  long long v74 = v111;
  uint64_t UInt = paramc_ParamGetUInt(*(void *)(v110 + 40), (uint64_t)"infiniteloopdetectlimit", v111 + 28);
  uint64_t v67 = v110;
  if ((UInt & 0x80000000) != 0)
  {
LABEL_63:
    uint64_t AlternativeEscSeq = UInt;
LABEL_65:
    log_OutPublic(*(void *)(v67 + 32), (uint64_t)"TTSEG", 16104, (uint64_t)"%s%x", v63, v64, v65, v66, "lherror");
    goto LABEL_66;
  }
  uint64_t v68 = paramc_ParamGetUInt(*(void *)(v110 + 40), (uint64_t)"markermode", v74 + 27);
  if ((v68 & 0x80000000) != 0) {
    goto LABEL_64;
  }
  if (!v74[47])
  {
    for (uint64_t i = 0; i != 7; ++i)
    {
      uint64_t v76 = TtsEgListenedToParams[i];
      uint64_t v77 = *(void *)(v110 + 40);
      long long __b = v104;
      *(void *)&long long v102 = v105;
      uint64_t v78 = paramc_ListenerAdd(v77, v76, &__b);
      if ((v78 & 0x80000000) != 0)
      {
        uint64_t v83 = v78;
        log_OutPublic(*(void *)(v110 + 32), (uint64_t)"TTSEG", 16025, (uint64_t)"%s%s%s%x", v79, v80, v81, v82, "parameter");
        if ((v83 & 0x1FFF) != 0x14)
        {
          uint64_t AlternativeEscSeq = v83;
          goto LABEL_66;
        }
      }
      else
      {
        v74[47] = 1;
      }
    }
  }
  uint64_t v84 = ssftthrottle_ObjOpen(a3, a4, (void *)v74 + 27);
  if ((v84 & 0x80000000) != 0)
  {
    uint64_t AlternativeEscSeq = v84;
    log_OutPublic(*(void *)(v110 + 32), (uint64_t)"TTSEG", 16029, (uint64_t)"%s%x", v85, v86, v87, v88, "lherror");
    goto LABEL_66;
  }
  uint64_t v89 = v109;
  v74[52] = *(_DWORD *)(v109 + 216);
  uint64_t v103 = 0;
  long long __b = 0u;
  long long v102 = 0u;
  cstdlib_memset(&__b, 0, 0x28uLL);
  LOBYTE(__b) = 1;
  *((void *)&__b + 1) = &ttseg_ObjOpen_ISynthOutputSink;
  long long v102 = *a8;
  uint64_t v103 = 0;
  uint64_t AlternativeEscSeq = objc_RegisterObject(*(void *)(v110 + 48), (uint64_t)"SYNTHOUTPUTSINK", &__b);
  if ((AlternativeEscSeq & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(v110 + 32), (uint64_t)"TTSEG", 16088, (uint64_t)"%s%x", v90, v91, v92, v93, "lherror");
    goto LABEL_66;
  }
  v74[56] = 1;
  if (a7
    && *a7
    && ((AlternativeEscSeq = pipeline_ObjOpen(*(_WORD **)v74, *((void *)v74 + 1), a7, 0, 0xFFFF, *((void *)v74 + 15), (uint64_t **)v74 + 29, &v107), (AlternativeEscSeq & 0x80000000) != 0)|| (uint64_t v94 = *((void *)v74 + 29), *((void *)v74 + 68) = v94, v74[48] = ttseg_loc_LicensingModePipeline(v110, (uint64_t)v74, v94), !*(_DWORD *)(v89 + 220))&& (AlternativeEscSeq = ttseg_loc_LicensingIncreaseInstanceCount(v110, (uint64_t)v74), (AlternativeEscSeq & 0x80000000) != 0))|| (paramc_ParamGetStr(*(void *)(v110 + 40), (uint64_t)"__NUAN_alternative_esc_seq__", &v106) & 0x80000000) == 0&& (AlternativeEscSeq = ttseg_loc_LoadAlternativeEscSeq((uint64_t)v74), (AlternativeEscSeq & 0x80000000) != 0))
  {
LABEL_66:
    ttseg_loc_ObjClose(v110, (_WORD ***)&v111, v40, v41, v42, v43, v44, v45);
    unsigned int v111 = 0;
    *(void *)a8 = 0;
    *((_DWORD *)a8 + 2) = 0;
  }
  else
  {
    uint64_t v95 = (_WORD *)*((void *)v74 + 4);
    critsec_Enter(*((void **)v95 + 26));
    ++*((_DWORD *)v95 + 62);
    critsec_Leave(*((void **)v95 + 26));
  }
  log_OutText(*(void *)(v110 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Object Open: End (%x, %p)", v96, v97, v98, AlternativeEscSeq);
  return AlternativeEscSeq;
}

uint64_t ttseg_loc_ElemCopyPartsString(const char **a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = *a1;
  if (*a1) {
    uint64_t v6 = cstdlib_strlen(*a1) + 1;
  }
  else {
    uint64_t v6 = 1;
  }
  uint64_t result = heap_Alloc(a2, v6);
  *a3 = result;
  if (result)
  {
    if (v5) {
      uint64_t v8 = v5;
    }
    else {
      uint64_t v8 = byte_2207887FC;
    }
    cstdlib_strcpy((char *)result, v8);
    return 1;
  }
  return result;
}

uint64_t *ttseg_loc_ElemFreePartsString(uint64_t *result, void *a2)
{
  if (*result) {
    return heap_Free(a2, *result);
  }
  return result;
}

uint64_t ttseg_GetInterface(int a1, void *a2)
{
  switch(a1)
  {
    case 0:
      goto LABEL_4;
    case 4:
      uint64_t result = 0;
      *a2 = &ITtsEg;
      SWIlicense_inhibited = 1;
      break;
    case 3:
LABEL_4:
      uint64_t result = 0;
      *a2 = &ITtsEg;
      return result;
    default:
      return 2166366209;
  }
  return result;
}

uint64_t InitLoadedCupList(void *a1, uint64_t *a2)
{
  uint64_t v4 = (void *)heap_Calloc(a1, 1, 24);
  uint64_t v5 = (uint64_t)v4;
  if (v4 && (*uint64_t v4 = a1, v4[2] = 64, v6 = heap_Calloc(a1, 1, 1024), (*(void *)(v5 + 8) = v6) != 0))
  {
    uint64_t result = 0;
    *a2 = v5;
  }
  else
  {
    DeinitLoadedCupList(a1, v5);
    return 2166366218;
  }
  return result;
}

uint64_t ttseg_loc_ParamCheckChange(uint64_t a1, const char *a2, unsigned __int8 *a3, int *a4)
{
  uint64_t v11 = 0;
  if (!a3) {
    goto LABEL_7;
  }
  uint64_t result = 0;
  int v7 = 1;
  if (a1 && *a3)
  {
    if ((InitRsrcFunction(*(_WORD **)a1, *(void *)(a1 + 8), &v11) & 0x80000000) != 0)
    {
LABEL_7:
      uint64_t result = 0;
      int v7 = 1;
      goto LABEL_8;
    }
    if (cstdlib_strcmp(a2, "readmode"))
    {
      if (cstdlib_strcmp(a2, "waitfactor")) {
        goto LABEL_7;
      }
      BOOL v10 = cstdlib_atoi(a3) >= 0xA;
    }
    else
    {
      BOOL v10 = cstdlib_atoi(a3) - 1 >= 4;
    }
    int v7 = !v10;
    if (v10) {
      uint64_t result = 2166366223;
    }
    else {
      uint64_t result = 0;
    }
  }
LABEL_8:
  *a4 = v7;
  return result;
}

uint64_t ttseg_loc_ParamLearnChange(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v13 = 0;
  if (!a3) {
    return 0;
  }
  uint64_t result = 0;
  if (a1 && *a3)
  {
    if ((InitRsrcFunction(*(_WORD **)a1, *(void *)(a1 + 8), &v13) & 0x80000000) == 0)
    {
      log_OutText(*(void *)(v13 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Parameter change: %s=%s", v7, v8, v9, (uint64_t)a2);
      if (!cstdlib_strcmp(a2, "infiniteloopdetectlimit"))
      {
        unsigned int v10 = LH_atou(a3);
        uint64_t result = 0;
        *(_DWORD *)(a1 + 112) = v10;
        return result;
      }
      if (!cstdlib_strcmp(a2, "markermode"))
      {
        unsigned int v11 = LH_atou(a3);
        uint64_t result = 0;
        *(_DWORD *)(a1 + 108) = v11;
        return result;
      }
      if (!cstdlib_strcmp(a2, "audiooutputbufsamples"))
      {
        unsigned int v12 = LH_atou(a3);
        uint64_t result = 0;
        *(_DWORD *)(a1 + 432) = v12;
        return result;
      }
      if (!cstdlib_strcmp(a2, "__NUAN_alternative_esc_seq__")) {
        return ttseg_loc_LoadAlternativeEscSeq(a1);
      }
    }
    return 0;
  }
  return result;
}

uint64_t ttseg_loc_ParamSetIfNotSetUInt(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v7 = 0;
  if ((paramc_ParamGetStr(a1, a2, &v7) & 0x80000000) != 0 || !v7) {
    return paramc_ParamSetUInt(a1, a2, a3);
  }
  else {
    return paramc_ParamRelease(a1);
  }
}

uint64_t ttseg_loc_ParamSetIfNotSetStr(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v7 = 0;
  if ((paramc_ParamGetStr(a1, a2, &v7) & 0x80000000) != 0 || !v7) {
    return paramc_ParamSetStr(a1, a2, a3);
  }
  else {
    return paramc_ParamRelease(a1);
  }
}

uint64_t ttseg_loc_ProcessResults(uint64_t a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t result = safeh_HandleCheck(a1, a2, 52652, 592);
  if ((result & 0x80000000) != 0) {
    return 2166366215;
  }
  if (a3 == 2)
  {
    if (*(_DWORD *)(a1 + 420) != 2) {
      uint64_t result = ttseg_loc_ProcessLoop(a1, 1, v10, v11, v12, v13, v14, v15);
    }
  }
  else if (!a3 && !*(void *)(a1 + 424))
  {
    uint64_t result = ttseg_loc_PutOutput(a1, 0, v10, v11, v12, v13, v14, v15);
  }
  if (a3 == 1 || (result & 0x80000000) != 0)
  {
    LODWORD(v16) = 0;
    *a4 = 0;
  }
  else
  {
    uint64_t v16 = *(void *)(a1 + 48);
    if (v16)
    {
      *a4 = *(_DWORD *)(a1 + 432);
      LODWORD(v16) = *(_DWORD *)(a1 + 436);
    }
    else
    {
      *a4 = 4096;
    }
  }
  *a5 = v16;
  return result;
}

uint64_t ttseg_loc_LicensingModePipeline(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  if ((InitRsrcFunction(**(_WORD ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8), &v10) & 0x80000000) == 0
    && ttseg_loc_check_vns(*(void *)(v10 + 40)))
  {
    return 2;
  }
  if (!a3) {
    return 0;
  }
  uint64_t v7 = *(void *)(a2 + 32);
  if (!*(_DWORD *)(v7 + 140) && !*(_DWORD *)(v7 + 152)) {
    return 0;
  }
  int Str = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"voicemodel", &v11);
  uint64_t result = 0;
  if ((Str & 0x80000000) == 0 && v11)
  {
    if (LH_stricmp(v11, "cpr")) {
      return 0;
    }
    if (*(_WORD *)(a3 + 24))
    {
      for (unint64_t i = 0; i < *(unsigned __int16 *)(a3 + 24); ++i)
      {
        uint64_t result = LH_strnicmp(*(void *)(*(void *)(*(void *)(a3 + 16) + 8 * i) + 8), (uint64_t)"uselect/", 8uLL);
        if (!result) {
          break;
        }
        if (!LH_strnicmp(*(void *)(*(void *)(*(void *)(a3 + 16) + 8 * i) + 8), (uint64_t)"select/", 7uLL)&& LH_stricmp(*(char **)(*(void *)(*(void *)(a3 + 16) + 8 * i) + 8), "select/cpr"))
        {
          return 0;
        }
        uint64_t result = 1;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t ttseg_loc_LicensingIncreaseInstanceCount(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 196))
  {
    unsigned int v5 = *(_DWORD *)(a2 + 192);
    uint64_t v2 = critsec_Enter(*(void **)(*(void *)(a2 + 32) + 208));
    if ((v2 & 0x80000000) != 0)
    {
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16112, (uint64_t)"%s%s%s%x", v6, v7, v8, v9, "function");
      return v2;
    }
    if (v5)
    {
      if (v5 != 1)
      {
        if (v5 == 2)
        {
          uint64_t v10 = *(void *)(a2 + 32);
          unsigned int v11 = *(_DWORD *)(v10 + 172);
          if (v11 >= *(_DWORD *)(v10 + 164))
          {
            uint64_t v2 = 2166373638;
            log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16115, (uint64_t)"%s%lu", v6, v7, v8, v9, "licensePorts");
          }
          else
          {
            *(_DWORD *)(v10 + 172) = v11 + 1;
            *(_DWORD *)(a2 + 196) = 1;
          }
        }
        goto LABEL_44;
      }
      uint64_t v12 = *(_DWORD **)(a2 + 32);
      if (v12[37] < v12[35]
        || ((SWIlicense_inhibited & 1) == 0
          ? (NumOfLicensesInUseInCache = SWIlicenseGetNumOfLicensesInUseInCache(), uint64_t v12 = *(_DWORD **)(a2 + 32))
          : (_DWORD *)(unsigned int NumOfLicensesInUseInCache = num_used_SWI_licenses),
            (unsigned int v14 = v12[38], NumOfLicensesInUseInCache < v14)
         || v12[31] >= v12[29]
         && ((SWIlicense_inhibited & 1) == 0
           ? (v25 = SWIlicenseGetNumOfLicensesInUseInCache(), unsigned int v14 = *(_DWORD *)(*(void *)(a2 + 32) + 152))
           : (unsigned int v25 = num_used_SWI_licenses),
             v25 >= v14)))
      {
        unsigned int v5 = 1;
      }
      else
      {
        log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16117, (uint64_t)"%s%lu", v6, v7, v8, v9, "cprLicensePorts");
        ttseg_loc_LicenseLog((uint64_t **)a1, *(void *)(a2 + 32), 1, 7);
        unsigned int v5 = 0;
        *(_DWORD *)(a2 + 192) = 0;
      }
    }
    uint64_t v15 = *(void *)(a2 + 32);
    unsigned int v16 = v5;
    uint64_t v17 = v15 + 24 * v5;
    unsigned int v20 = *(_DWORD *)(v17 + 124);
    uint64_t v18 = (_DWORD *)(v17 + 124);
    unsigned int v19 = v20;
    uint64_t v21 = *(v18 - 2);
    if (v20 < v21)
    {
      *uint64_t v18 = v19 + 1;
      *(_DWORD *)(a2 + 196) = 1;
      log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG License is checked-out: total ports=%lu,  acquired ports=%lu", v7, v8, v9, v21);
      uint64_t v15 = *(void *)(a2 + 32);
      goto LABEL_32;
    }
    if (SWIlicense_inhibited)
    {
      unsigned int v22 = num_used_SWI_licenses;
    }
    else
    {
      unsigned int v22 = SWIlicenseGetNumOfLicensesInUseInCache();
      uint64_t v15 = *(void *)(a2 + 32);
    }
    if (v22 < *(_DWORD *)(v15 + 24 * v5 + 128))
    {
      uint64_t v23 = *(int *)(v15 + 224);
      if (v23 > 2) {
        int v24 = 11;
      }
      else {
        int v24 = *((_DWORD *)*(&off_26456B170 + v23) + v5);
      }
      if (SWIlicense_inhibited == 1)
      {
        ++num_used_SWI_licenses;
        *(void *)(a2 + 200) = (100000 * v24);
LABEL_34:
        *(_DWORD *)(a2 + 196) = 2;
        goto LABEL_35;
      }
      uint64_t v26 = SWIlicenseUseCacheableLicense(v24);
      *(void *)(a2 + 200) = v26;
      uint64_t v15 = *(void *)(a2 + 32);
      if (v26 != 0xFFFFFFFFLL) {
        goto LABEL_34;
      }
    }
LABEL_32:
    if (!*(_DWORD *)(a2 + 196))
    {
      uint64_t v2 = 2166373638;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", v5 + 16115, (uint64_t)"%s%lu", v6, v7, v8, v9, "licensePorts");
      uint64_t v27 = 7;
LABEL_43:
      ttseg_loc_LicenseLog((uint64_t **)a1, *(void *)(a2 + 32), v16, v27);
LABEL_44:
      critsec_Leave(*(void **)(*(void *)(a2 + 32) + 208));
      return v2;
    }
LABEL_35:
    int v28 = *(_DWORD *)(v15 + 24 * v5 + 124);
    if (SWIlicense_inhibited)
    {
      int v29 = num_used_SWI_licenses;
    }
    else
    {
      int v29 = SWIlicenseGetNumOfLicensesInUseInCache();
      uint64_t v15 = *(void *)(a2 + 32);
    }
    if ((v29 + v28) > *(_DWORD *)(v15 + 24 * v16 + 120))
    {
      uint64_t v30 = *(void *)(a1 + 32);
      if ((SWIlicense_inhibited & 1) == 0) {
        SWIlicenseGetNumOfLicensesInUseInCache();
      }
      log_OutPublic(v30, (uint64_t)"TTSEG", v16 + 16113, (uint64_t)"%s%lu%s%lu", v6, v7, v8, v9, "instanceCount");
    }
    uint64_t v27 = 5;
    goto LABEL_43;
  }
  return 2166366225;
}

uint64_t ttseg_loc_LoadAlternativeEscSeq(uint64_t a1)
{
  uint64_t v2 = (uint64_t *)(a1 + 560);
  uint64_t v3 = *(void **)(a1 + 560);
  if (v3)
  {
    esc_seq_deinit(*(_WORD **)a1, *(void *)(a1 + 8), v3, *(void *)(a1 + 568));
    *(void *)(a1 + 560) = safeh_GetNullHandle();
    *(void *)(a1 + 568) = v4;
  }
  unsigned int v5 = *(_WORD **)a1;
  uint64_t v6 = *(void *)(a1 + 8);

  return esc_seq_init(v5, v6, v2);
}

uint64_t ttseg_loc_ObjClose(uint64_t a1, _WORD ***a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    return 0;
  }
  uint64_t v8 = *a2;
  if (!*a2) {
    return 0;
  }
  *a2 = 0;
  uint64_t v10 = (uint64_t)v8[29];
  if (v10)
  {
    int v11 = pipeline_ObjClose(v10, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    uint64_t v12 = v11 & (v11 >> 31);
    v8[29] = 0;
  }
  else
  {
    uint64_t v12 = 0;
  }
  uint64_t v13 = v8[72];
  if (v13) {
    tinystack_Delete(v13);
  }
  uint64_t v14 = (uint64_t)v8[73];
  if (v14) {
    DeinitLoadedCupList(*(void **)(a1 + 8), v14);
  }
  if (v8[21])
  {
    uint64_t v15 = objc_ReleaseObject(*(void *)(a1 + 48), (uint64_t)"LINGDB");
    if ((v15 & 0x80000000) != 0)
    {
      uint64_t v20 = v15;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16083, (uint64_t)"%s%x", v16, v17, v18, v19, "lherror");
      uint64_t v12 = v20;
    }
    v8[21] = 0;
  }
  if (v8[16])
  {
    uint64_t v21 = objc_ReleaseObject(*(void *)(a1 + 48), (uint64_t)"SYNTHSTREAM");
    if ((v21 & 0x80000000) != 0)
    {
      uint64_t v26 = v21;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16085, (uint64_t)"%s%x", v22, v23, v24, v25, "lherror");
      uint64_t v12 = v26;
    }
    v8[16] = 0;
  }
  uint64_t v27 = (uint64_t)v8[15];
  if (v27)
  {
    int v28 = pipeline_UnloadObjects(*v8, (int)v8[1], v27);
    if (v28 >= 0) {
      uint64_t v12 = v12;
    }
    else {
      uint64_t v12 = v28;
    }
    vector_ObjClose((uint64_t)v8[15]);
    v8[15] = 0;
  }
  if (v8[69]) {
    ttseg_loc_RemoveTaInfo((uint64_t)v8);
  }
  if (*((_DWORD *)v8 + 56))
  {
    uint64_t v29 = objc_UnregisterObject(*(void *)(a1 + 48), (uint64_t)"SYNTHOUTPUTSINK");
    if ((v29 & 0x80000000) != 0)
    {
      uint64_t v34 = v29;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16081, (uint64_t)"%s%x", v30, v31, v32, v33, "lherror");
      uint64_t v12 = v34;
    }
    *((_DWORD *)v8 + 56) = 0;
  }
  if (v8[27])
  {
    uint64_t v35 = ssftthrottle_ObjClose();
    if ((v35 & 0x80000000) != 0)
    {
      uint64_t v40 = v35;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16006, (uint64_t)"%s%x", v36, v37, v38, v39, "lherror");
      uint64_t v12 = v40;
    }
    v8[27] = 0;
  }
  if (!*((_DWORD *)v8[4] + 55))
  {
    int v41 = ttseg_loc_LicensingDecreaseInstanceCount(a1, (uint64_t)v8);
    if (v41 >= 0) {
      uint64_t v12 = v12;
    }
    else {
      uint64_t v12 = v41;
    }
  }
  if (*((_DWORD *)v8 + 47) == 1)
  {
    long long __b = 0uLL;
    uint64_t v82 = 0;
    cstdlib_memset(&__b, 0, 0x18uLL);
    *(void *)&long long __b = v8;
    *((void *)&__b + 1) = ttseg_loc_ParamCheckChange;
    uint64_t v82 = ttseg_loc_ParamLearnChange;
    if (log_GetLogLevel(*(void *)(a1 + 32)) <= 3)
    {
      for (uint64_t i = 0; i != 7; ++i)
      {
        uint64_t v49 = TtsEgListenedToParams[i];
        uint64_t v50 = *(void *)(a1 + 40);
        long long v79 = __b;
        uint64_t v80 = v82;
        if ((paramc_ListenerRemove(v50, v49, &v79) & 0x80000000) != 0) {
          log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16008, (uint64_t)"%s%s%s%x", v51, v52, v53, v54, "parameter");
        }
      }
    }
    else
    {
      uint64_t v42 = *(void *)(a1 + 40);
      long long v79 = __b;
      uint64_t v80 = v82;
      int v43 = paramc_ListenerRemove(v42, 0, &v79);
      if (v43 < 0 && (v43 & 0x1FFF) != 0x14) {
        log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16008, (uint64_t)"%s%x", v44, v45, v46, v47, "lherror");
      }
    }
    *((_DWORD *)v8 + 47) = 0;
  }
  uint64_t v55 = v8[70];
  if (v55)
  {
    esc_seq_deinit(*v8, (int)v8[1], v55, (int)v8[71]);
    v8[70] = (_WORD *)safeh_GetNullHandle();
    v8[71] = v56;
  }
  if (*((_DWORD *)v8 + 45))
  {
    uint64_t v57 = objc_UnregisterObject(*(void *)(a1 + 48), (uint64_t)"COMPQUERY");
    if ((v57 & 0x80000000) != 0)
    {
      uint64_t v62 = v57;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16096, (uint64_t)"%s%x", v58, v59, v60, v61, "lherror");
      uint64_t v12 = v62;
    }
  }
  if (*((_DWORD *)v8 + 44))
  {
    uint64_t v63 = objc_UnregisterObject(*(void *)(a1 + 48), (uint64_t)"LANGCODECONVERTER");
    if ((v63 & 0x80000000) != 0)
    {
      uint64_t v68 = v63;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16096, (uint64_t)"%s%x", v64, v65, v66, v67, "lherror");
      uint64_t v12 = v68;
    }
  }
  if (*((_DWORD *)v8 + 46))
  {
    uint64_t v69 = objc_UnregisterObject(*(void *)(a1 + 48), (uint64_t)"TTSEG");
    if ((v69 & 0x80000000) != 0)
    {
      uint64_t v74 = v69;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16096, (uint64_t)"%s%x", v70, v71, v72, v73, "lherror");
      uint64_t v12 = v74;
    }
  }
  uint64_t v75 = (uint64_t)v8[12];
  if (v75)
  {
    int v76 = critsec_ObjClose(v75);
    if ((int)v12 > -1 && v76 < 0) {
      uint64_t v12 = v76;
    }
    else {
      uint64_t v12 = v12;
    }
  }
  heap_Free(*(void **)(a1 + 8), (uint64_t)v8);
  return v12;
}

uint64_t ttseg_ObjClose(uint64_t a1, int a2)
{
  uint64_t v27 = 0;
  int v28 = 0;
  uint64_t v4 = ttseg_loc_BeginFunction(a1, a2, &v27, (uint64_t *)&v28);
  if ((v4 & 0x80000000) != 0) {
    return v4;
  }
  uint64_t v8 = v28;
  log_OutText(*(void *)(v27 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Object Close : Begin (%p)", v5, v6, v7, (uint64_t)v28);
  uint64_t v4 = ttseg_loc_LockFromIdle(v27, (uint64_t)v8, (uint64_t)"ttseg_ObjClose", 2, &v26);
  if ((v4 & 0x80000000) != 0) {
    return v4;
  }
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  ttseg_loc_BeginFunction(a1, a2, &v29, &v30);
  uint64_t v9 = v30;
  uint64_t v10 = *(void *)(v30 + 584);
  unint64_t v11 = *(void *)(v10 + 16);
  if (v11)
  {
    if (!v10) {
      goto LABEL_8;
    }
LABEL_5:
    uint64_t v12 = *(void *)(v10 + 8);
    --v11;
    if (*(void *)(v12 + 16 * v11 + 8) && *(void *)(v12 + 16 * v11)) {
      ttseg_loc_UnloadTuningResourcePackage(a1, a2, v11);
    }
    while (v11)
    {
      uint64_t v10 = *(void *)(v9 + 584);
      if (v10) {
        goto LABEL_5;
      }
LABEL_8:
      --v11;
    }
  }
  uint64_t v14 = v8[4];
  critsec_Enter(*((void **)v14 + 26));
  --*((_DWORD *)v14 + 62);
  critsec_Leave(*((void **)v14 + 26));
  int v21 = ttseg_loc_ObjClose(v27, &v28, v15, v16, v17, v18, v19, v20);
  uint64_t v13 = v21 & (v21 >> 31) & 0x7FFFFFFF;
  log_OutText(*(void *)(v27 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Object Close : End (%x)", v22, v23, v24, v13);
  return v13;
}

uint64_t ttseg_loc_BeginFunction(uint64_t a1, int a2, void *a3, uint64_t *a4)
{
  *a4 = 0;
  LODWORD(result) = safeh_HandleCheck(a1, a2, 52652, 592);
  if ((result & 0x80000000) != 0)
  {
    if ((result & 0x1FFF) == 8) {
      return 2166366216;
    }
    else {
      return result;
    }
  }
  else
  {
    uint64_t result = InitRsrcFunction(*(_WORD **)a1, *(void *)(a1 + 8), a3);
    if ((result & 0x80000000) == 0) {
      *a4 = a1;
    }
  }
  return result;
}

uint64_t ttseg_loc_LockFromIdle(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5)
{
  uint64_t v13 = critsec_Enter(*(void **)(a2 + 96));
  if ((v13 & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16004, (uint64_t)"%s%s%s%x", v9, v10, v11, v12, "function");
  }
  else
  {
    if (*(_DWORD *)(a2 + 104) == 1)
    {
      *a5 = 1;
      *(_DWORD *)(a2 + 104) = a4;
    }
    else
    {
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16003, (uint64_t)"%s%s", v9, v10, v11, v12, "function");
      LODWORD(v13) = -2128601071;
    }
    int v14 = critsec_Leave(*(void **)(a2 + 96));
    if (v14 >= 0 || (int)v13 <= -1) {
      return v13;
    }
    else {
      return v14;
    }
  }
  return v13;
}

uint64_t ttseg_LicenseAllocate(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v17 = 0;
  if (!a3) {
    return 2166366215;
  }
  uint64_t v4 = ttseg_loc_BeginFunction(a1, a2, &v17, &v18);
  if ((v4 & 0x80000000) != 0) {
    return v4;
  }
  uint64_t v8 = 2166373641;
  log_OutText(*(void *)(v17 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG License Allocate : Begin (%s)", v5, v6, v7, a3);
  log_OutPublic(*(void *)(v17 + 32), (uint64_t)"TTSEG", 16033, (uint64_t)"%s%s", v9, v10, v11, v12, "Mode");
  log_OutText(*(void *)(v17 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG License Allocate : End (%x)", v13, v14, v15, 2166373641);
  return v8;
}

uint64_t ttseg_LicenseFree(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v17 = 0;
  if (!a3) {
    return 2166366215;
  }
  uint64_t v4 = ttseg_loc_BeginFunction(a1, a2, &v17, &v18);
  if ((v4 & 0x80000000) != 0) {
    return v4;
  }
  uint64_t v8 = 2166373641;
  log_OutText(*(void *)(v17 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG License Free : Begin (%s)", v5, v6, v7, a3);
  log_OutPublic(*(void *)(v17 + 32), (uint64_t)"TTSEG", 16036, (uint64_t)"%s%s", v9, v10, v11, v12, "Mode");
  log_OutText(*(void *)(v17 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG License Free : End (%x)", v13, v14, v15, 2166373641);
  return v8;
}

uint64_t ttseg_PipelineSetEx(uint64_t a1, int a2, char *a3, int a4)
{
  uint64_t v54 = 0;
  uint64_t v53 = 0;
  int v52 = 0;
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  int v49 = 0;
  uint64_t v6 = ttseg_loc_BeginFunction(a1, a2, &v53, &v54);
  if ((v6 & 0x80000000) != 0) {
    return v6;
  }
  uint64_t v7 = v54;
  *(_DWORD *)(v54 + 240) = a4;
  if (a4 == 2) {
    uint64_t v8 = "yes";
  }
  else {
    uint64_t v8 = "no";
  }
  paramc_ParamSetStr(*(void *)(v53 + 40), (uint64_t)"textanalysison", v8);
  uint64_t v12 = byte_2207887FC;
  if (a3) {
    uint64_t v12 = a3;
  }
  log_OutText(*(void *)(v53 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Pipeline Set : Begin (%s)", v9, v10, v11, (uint64_t)v12);
  uint64_t v20 = ttseg_loc_LockFromIdle(v53, v7, (uint64_t)"ttseg_PipelineSet", 2, &v52);
  if ((v20 & 0x80000000) == 0)
  {
    if (!a3 || !*a3) {
      goto LABEL_28;
    }
    uint64_t v21 = *(void *)(v7 + 232);
    if (!v21 || cstdlib_strcmp(a3, *(const char **)(v21 + 8)))
    {
      uint64_t v22 = paramc_ParamSetRestorePoint(*(void *)(v53 + 40), &v50);
      if ((v22 & 0x80000000) != 0)
      {
        uint64_t v20 = v22;
        log_OutPublic(*(void *)(v53 + 32), (uint64_t)"TTSEG", 16074, (uint64_t)"%s%x", v23, v24, v25, v26, "lherror");
      }
      else
      {
        uint64_t v27 = pipeline_ObjOpen(*(_WORD **)v7, *(void *)(v7 + 8), a3, *(void *)(v7 + 232), 0xFFFF, *(void *)(v7 + 120), &v51, &v49);
        uint64_t v20 = v27;
        if ((v27 & 0x80001FFF) != 0x8000000A)
        {
          if ((v27 & 0x80000000) == 0)
          {
            unsigned int v28 = ttseg_loc_LicensingModePipeline(v53, v7, (uint64_t)v51);
            if (*(_DWORD *)(*(void *)(v7 + 32) + 220) || *(_DWORD *)(v7 + 196))
            {
              if (*(_DWORD *)(v7 + 192) == v28) {
                goto LABEL_26;
              }
              uint64_t v29 = ttseg_loc_LicensingModeSwitch(v53, v7, v28);
            }
            else
            {
              *(_DWORD *)(v7 + 192) = v28;
              uint64_t v29 = ttseg_loc_LicensingIncreaseInstanceCount(v53, v7);
            }
            uint64_t v20 = v29;
            if ((v29 & 0x80000000) == 0)
            {
LABEL_26:
              unsigned int v41 = paramc_ParamCloseRestorePoint(*(void *)(v53 + 40), v50);
              if ((v41 & 0x80000000) != 0)
              {
                unsigned int v47 = v41;
                log_OutPublic(*(void *)(v53 + 32), (uint64_t)"TTSEG", 16076, (uint64_t)"%s%x", v16, v17, v18, v19, "lherror");
                if ((int)v20 >= 0) {
                  uint64_t v20 = v47;
                }
                else {
                  uint64_t v20 = v20;
                }
                uint64_t v50 = 0;
              }
              else
              {
                uint64_t v50 = 0;
                if ((v20 & 0x80000000) == 0)
                {
LABEL_28:
                  uint64_t v42 = *(void *)(v7 + 232);
                  if (v42)
                  {
                    uint64_t v20 = pipeline_ObjClose(v42, v13, v14, v15, v16, v17, v18, v19);
                    if (*(void *)(v7 + 232) == *(void *)(v7 + 544)) {
                      *(void *)(v7 + 544) = 0;
                    }
                  }
                  *(void *)(v7 + 232) = v51;
                  goto LABEL_32;
                }
              }
              uint64_t v48 = *(void *)(v7 + 232);
              if (v48 && v49) {
                pipeline_ObjReopen(v48, v13, v14, v15, v16, v17, v18, v19);
              }
              goto LABEL_32;
            }
            pipeline_ObjClose((uint64_t)v51, v30, v31, v32, v33, v34, v35, v36);
          }
          if ((paramc_ParamRestore(*(void *)(v53 + 40), (uint64_t *)v50) & 0x80000000) != 0) {
            log_OutPublic(*(void *)(v53 + 32), (uint64_t)"TTSEG", 16075, (uint64_t)"%s%x", v37, v38, v39, v40, "lherror");
          }
          goto LABEL_26;
        }
      }
    }
LABEL_32:
    ttseg_loc_Unlock(v53, v7, v52);
    log_OutText(*(void *)(v53 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Pipeline Set : End (%x)", v43, v44, v45, v20);
  }
  return v20;
}

uint64_t ttseg_loc_LicensingModeSwitch(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (!*(_DWORD *)(a2 + 196)) {
    return 2166366225;
  }
  unsigned int v6 = *(_DWORD *)(a2 + 192);
  uint64_t v11 = critsec_Enter(*(void **)(*(void *)(a2 + 32) + 208));
  if ((v11 & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16112, (uint64_t)"%s%s%s%x", v7, v8, v9, v10, "function");
    return v11;
  }
  uint64_t v12 = *(void *)(a2 + 32);
  uint64_t v13 = v12 + 24 * a3;
  unsigned int v16 = *(_DWORD *)(v13 + 124);
  uint64_t v14 = (_DWORD *)(v13 + 124);
  unsigned int v15 = v16;
  if (v16 < *(v14 - 2))
  {
    *uint64_t v14 = v15 + 1;
    int v17 = 1;
LABEL_5:
    if (*(_DWORD *)(a2 + 196) == 1)
    {
      uint64_t v18 = *(void *)(a2 + 32) + 24 * v6;
      int v21 = *(_DWORD *)(v18 + 124);
      uint64_t v19 = (_DWORD *)(v18 + 124);
      int v20 = v21;
      if (v21) {
        *uint64_t v19 = v20 - 1;
      }
    }
    else if (SWIlicense_inhibited == 1)
    {
      if (num_used_SWI_licenses) {
        --num_used_SWI_licenses;
      }
    }
    else
    {
      SWIlicenseFreeCacheableLicense();
    }
    ttseg_loc_LicenseLog((uint64_t **)a1, *(void *)(a2 + 32), v6, 6);
    *(_DWORD *)(a2 + 192) = a3;
    *(_DWORD *)(a2 + 196) = v17;
    uint64_t v30 = *(void *)(a2 + 32);
    int v31 = *(_DWORD *)(v30 + 24 * a3 + 124);
    if (SWIlicense_inhibited)
    {
      int NumOfLicensesInUseInCache = num_used_SWI_licenses;
    }
    else
    {
      int NumOfLicensesInUseInCache = SWIlicenseGetNumOfLicensesInUseInCache();
      uint64_t v30 = *(void *)(a2 + 32);
    }
    if ((NumOfLicensesInUseInCache + v31) > *(_DWORD *)(v30 + 24 * a3 + 120))
    {
      uint64_t v33 = *(void *)(a1 + 32);
      if ((SWIlicense_inhibited & 1) == 0) {
        SWIlicenseGetNumOfLicensesInUseInCache();
      }
      log_OutPublic(v33, (uint64_t)"TTSEG", a3 + 16113, (uint64_t)"%s%lu%s%lu", v26, v27, v28, v29, "instanceCount");
    }
    uint64_t v25 = 5;
    goto LABEL_33;
  }
  if (SWIlicense_inhibited)
  {
    unsigned int v22 = num_used_SWI_licenses;
  }
  else
  {
    unsigned int v22 = SWIlicenseGetNumOfLicensesInUseInCache();
    uint64_t v12 = *(void *)(a2 + 32);
  }
  if (v22 < *(_DWORD *)(v12 + 24 * a3 + 128))
  {
    if ((int)a3 > 3 || (uint64_t v23 = *(int *)(v12 + 224), v23 > 2)) {
      int v24 = 11;
    }
    else {
      int v24 = *((_DWORD *)*(&off_26456B170 + v23) + a3);
    }
    if (SWIlicense_inhibited == 1)
    {
      ++num_used_SWI_licenses;
      if (100000 * v24) {
        goto LABEL_23;
      }
    }
    else if (SWIlicenseUseCacheableLicense(v24))
    {
      goto LABEL_23;
    }
    int v17 = 2;
    goto LABEL_5;
  }
LABEL_23:
  log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", a3 + 16115, (uint64_t)"%s%lu", v7, v8, v9, v10, "licensePorts");
  uint64_t v25 = 7;
  LODWORD(v11) = -2128593658;
LABEL_33:
  ttseg_loc_LicenseLog((uint64_t **)a1, *(void *)(a2 + 32), a3, v25);
  if (v6) {
    uint64_t v11 = v11;
  }
  else {
    uint64_t v11 = 0;
  }
  critsec_Leave(*(void **)(*(void *)(a2 + 32) + 208));
  return v11;
}

uint64_t ttseg_loc_Unlock(uint64_t result, uint64_t a2, int a3)
{
  if (a3)
  {
    uint64_t v5 = result;
    if ((critsec_Enter(*(void **)(a2 + 96)) & 0x80000000) != 0)
    {
      return log_OutPublic(*(void *)(v5 + 32), (uint64_t)"TTSEG", 16004, (uint64_t)"%s%x", v6, v7, v8, v9, "lhError");
    }
    else
    {
      *(_DWORD *)(a2 + 104) = a3;
      uint64_t v10 = *(void **)(a2 + 96);
      return critsec_Leave(v10);
    }
  }
  return result;
}

uint64_t ttseg_PipelineSet(uint64_t a1, int a2, char *a3)
{
  return ttseg_PipelineSetEx(a1, a2, a3, 0);
}

uint64_t ttseg_ResourceLoad(uint64_t a1, uint64_t a2, const char *a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  int v58 = 0;
  uint64_t v14 = 2166366215;
  if (a4)
  {
    if (!a3 || !a7) {
      return v14;
    }
  }
  else if (!a7 || !a3 || !a5 || !a6)
  {
    return v14;
  }
  *(void *)a7 = 0;
  *(_DWORD *)(a7 + 8) = 0;
  uint64_t v15 = ttseg_loc_BeginFunction(a1, a2, &v59, &v60);
  if ((v15 & 0x80000000) != 0) {
    return v15;
  }
  log_OutText(*(void *)(v59 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Resource Load : Begin (%s, %s, %p, %u)", v16, v17, v18, (uint64_t)a3);
  if (a4) {
    log_OutEvent(*(uint64_t ***)(v59 + 32), 12, (uint64_t)"%s%s%s%s", v19, v20, v21, v22, v23, "URI");
  }
  uint64_t v24 = v60;
  uint64_t v15 = critsec_Enter(*(void **)(*(void *)(v60 + 32) + 208));
  if ((v15 & 0x80000000) != 0) {
    return v15;
  }
  if (cstdlib_strcmp(a3, "application/x-vocalizer-resources-package"))
  {
    AddRefCounteduint64_t Object = ttseg_loc_LockFromIdleOrProcessing(v59, v24, (uint64_t)"ttseg_ResourceLoad", &v58);
    if ((AddRefCountedObject & 0x80000000) == 0)
    {
      uint64_t v30 = *(uint64_t **)(v24 + 232);
      if (v30)
      {
        uint64_t v14 = pipeline_ResourceLoad(v30, 0, a3, a4, a5, a6, (uint64_t *)a7);
      }
      else
      {
        log_OutPublic(*(void *)(v59 + 32), (uint64_t)"TTSEG", 16037, 0, v26, v27, v28, v29, v54);
        uint64_t v14 = 2166366225;
      }
      ttseg_loc_Unlock(v59, v24, v58);
      goto LABEL_49;
    }
  }
  else
  {
    uint64_t v63 = 0;
    uint64_t v64 = 0;
    long long v62 = 0uLL;
    AddRefCounteduint64_t Object = 18;
    uint64_t v61 = 0;
    if (!a4) {
      goto LABEL_48;
    }
    if (a5) {
      goto LABEL_48;
    }
    if (a6) {
      goto LABEL_48;
    }
    AddRefCounteduint64_t Object = ttseg_loc_BeginFunction(a1, a2, &v63, &v64);
    if ((AddRefCountedObject & 0x80000000) != 0) {
      goto LABEL_48;
    }
    AddRefCounteduint64_t Object = objc_GetAddRefCountedObject(*(void *)(v63 + 48), (uint64_t)a4, (uint64_t (*)(void, void, uint64_t, _OWORD *, uint64_t))ObjcLoadCup, (void (*)(void, void, _OWORD *))ObjcUnloadCup, 0, &v61);
    if ((AddRefCountedObject & 0x80000000) != 0) {
      goto LABEL_48;
    }
    if (v61 && *(void *)(v61 + 32))
    {
      uint64_t v55 = v64;
      int v31 = *(uint64_t ***)(v64 + 584);
      AddRefCounteduint64_t Object = 2166366215;
      if (v31)
      {
        uint64_t v56 = *(void *)(v61 + 32);
        uint64_t v32 = (uint64_t)v31[1];
        uint64_t v33 = v31[2];
        if (v33)
        {
          uint64_t v34 = 0;
          uint64_t v35 = v31[1];
          while (*v35)
          {
            uint64_t v34 = (uint64_t *)((char *)v34 + 1);
            v35 += 2;
            if (v33 == v34) {
              goto LABEL_30;
            }
          }
        }
        else
        {
LABEL_30:
          uint64_t v36 = heap_Realloc(*v31, v32, 16 * (void)(v33 + 8));
          if (!v36)
          {
            AddRefCounteduint64_t Object = 2166366218;
            goto LABEL_48;
          }
          uint64_t v32 = v36;
          v31[1] = (uint64_t *)v36;
          v31[2] = v33 + 8;
          uint64_t v34 = v33;
        }
        uint64_t v37 = v56;
        *(void *)(v32 + 16 * (void)v34) = v56;
        v31[1][2 * (void)v34 + 1] = heap_Calloc(*v31, *(unsigned int *)(v56 + 24), 16);
        AddRefCounteduint64_t Object = paramc_ParamSetStr(*(void *)(v63 + 40), (uint64_t)"cup_name", *(char **)(v56 + 72));
        if ((AddRefCountedObject & 0x80000000) == 0)
        {
          if (*(_DWORD *)(v56 + 24))
          {
            uint64_t v38 = 0;
            unint64_t v39 = 0;
            while (1)
            {
              unint64_t v57 = v39;
              uint64_t v40 = *(void *)(v37 + 8) + v38;
              uint64_t v41 = *(void *)(v40 + 16);
              uint64_t v42 = *(unsigned int *)(v40 + 24);
              AddRefCounteduint64_t Object = paramc_ParamSetStr(*(void *)(v63 + 40), (uint64_t)"tuning_data_name_in_cup", *(char **)v40);
              if ((AddRefCountedObject & 0x80000000) != 0) {
                break;
              }
              AddRefCounteduint64_t Object = ttseg_ResourceLoad(a1, a2, *(void *)(*(void *)(v37 + 8) + v38 + 8), 0, v41, v42, &v62);
              if ((AddRefCountedObject & 0x80000000) != 0) {
                break;
              }
              AddRefCounteduint64_t Object = paramc_ParamSetStr(*(void *)(v63 + 40), (uint64_t)"tuning_data_name_in_cup", byte_2207887FC);
              if ((AddRefCountedObject & 0x80000000) != 0) {
                break;
              }
              uint64_t v43 = *(void *)(v55 + 584);
              if (v43)
              {
                if (*(void *)(v43 + 16) > (unint64_t)v34)
                {
                  uint64_t v44 = *(void *)(v43 + 8);
                  if (v57 < *(unsigned int *)(*(void *)(v44 + 16 * (void)v34) + 24)) {
                    *(_OWORD *)(*(void *)(v44 + 16 * (void)v34 + 8) + 16 * v57) = v62;
                  }
                }
              }
              unint64_t v39 = v57 + 1;
              uint64_t v37 = v56;
              v38 += 32;
              if (v57 + 1 >= *(unsigned int *)(v56 + 24)) {
                goto LABEL_43;
              }
            }
          }
          else
          {
LABEL_43:
            AddRefCounteduint64_t Object = paramc_ParamSetStr(*(void *)(v63 + 40), (uint64_t)"cup_name", byte_2207887FC);
            if ((AddRefCountedObject & 0x80000000) == 0) {
              *(void *)a7 = v37;
            }
          }
        }
      }
    }
    else
    {
      AddRefCounteduint64_t Object = 2166366215;
    }
  }
LABEL_48:
  uint64_t v14 = AddRefCountedObject;
LABEL_49:
  critsec_Leave(*(void **)(*(void *)(v24 + 32) + 208));
  log_OutText(*(void *)(v59 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Resource Load : End (%x, %p)", v45, v46, v47, v14);
  if (a4 && (v14 & 0x80000000) == 0) {
    log_OutEvent(*(uint64_t ***)(v59 + 32), 13, (uint64_t)"%s%s%s%s", v48, v49, v50, v51, v52, "URI");
  }
  return v14;
}

uint64_t ttseg_loc_LockFromIdleOrProcessing(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v11 = critsec_Enter(*(void **)(a2 + 96));
  if ((v11 & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16004, (uint64_t)"%s%s%s%x", v7, v8, v9, v10, "function");
  }
  else
  {
    int v12 = *(_DWORD *)(a2 + 104);
    if ((v12 - 3) < 4 || v12 == 1)
    {
      *a4 = v12;
      *(_DWORD *)(a2 + 104) = 2;
    }
    else
    {
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16003, (uint64_t)"%s%s", v7, v8, v9, v10, "function");
      LODWORD(v11) = -2128601071;
    }
    int v14 = critsec_Leave(*(void **)(a2 + 96));
    if (v14 >= 0 || (int)v11 <= -1) {
      return v11;
    }
    else {
      return v14;
    }
  }
  return v11;
}

uint64_t ttseg_ResourceUnload(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  int v33 = 0;
  uint64_t v8 = ttseg_loc_BeginFunction(a1, a2, &v34, (uint64_t *)&v35);
  if ((v8 & 0x80000000) == 0)
  {
    log_OutText(*(void *)(v34 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Resource Unload : Begin (%p)", v9, v10, v11, a3);
    int v12 = v35;
    uint64_t v8 = critsec_Enter(*(void **)(v35[4] + 208));
    if ((v8 & 0x80000000) == 0)
    {
      uint64_t v13 = v12[73];
      if (*(void *)(v13 + 16))
      {
        uint64_t v14 = 0;
        unsigned int v15 = 0;
        while (1)
        {
          uint64_t v16 = 16 * v14;
          if (*(void *)(*(void *)(v13 + 8) + 16 * v14))
          {
            uint64_t NullHandle = safeh_GetNullHandle();
            BOOL v19 = safeh_HandlesEqual(a3, a4, NullHandle, v18);
            uint64_t v13 = v12[73];
            if (!v19 && *(void *)(*(void *)(v13 + 8) + v16) == a3) {
              break;
            }
          }
          uint64_t v14 = ++v15;
          if (*(void *)(v13 + 16) <= (unint64_t)v15) {
            goto LABEL_9;
          }
        }
        uint64_t v20 = ttseg_loc_UnloadTuningResourcePackage(a1, a2, v15);
      }
      else
      {
LABEL_9:
        uint64_t v20 = ttseg_loc_LockFromIdleOrProcessing(v34, (uint64_t)v12, (uint64_t)"ttseg_ResourceUnload", &v33);
        if ((v20 & 0x80000000) == 0)
        {
          uint64_t v26 = (uint64_t *)v12[29];
          if (v26)
          {
            uint64_t v27 = pipeline_ResourceUnload(v26, a3, a4, v21, v22, v23, v24, v25);
          }
          else
          {
            log_OutPublic(*(void *)(v34 + 32), (uint64_t)"TTSEG", 16040, 0, v22, v23, v24, v25, v32);
            uint64_t v27 = 2166366225;
          }
          ttseg_loc_Unlock(v34, (uint64_t)v12, v33);
          goto LABEL_17;
        }
      }
      uint64_t v27 = v20;
LABEL_17:
      critsec_Leave(*(void **)(v12[4] + 208));
      log_OutText(*(void *)(v34 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Resource Unload : End (%x)", v28, v29, v30, v27);
      return v27;
    }
  }
  return v8;
}

uint64_t ttseg_loc_UnloadTuningResourcePackage(uint64_t a1, int a2, unint64_t a3)
{
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v4 = ttseg_loc_BeginFunction(a1, a2, &v20, &v21);
  if ((v4 & 0x80000000) != 0) {
    return v4;
  }
  uint64_t v5 = v21;
  uint64_t v6 = *(void *)(v21 + 584);
  if (*(void *)(v6 + 16) <= a3) {
    return 2166366223;
  }
  uint64_t v7 = *(void *)(*(void *)(v6 + 8) + 16 * a3);
  uint64_t v4 = paramc_ParamSetStr(*(void *)(v20 + 40), (uint64_t)"cup_name", *(char **)(v7 + 72));
  if ((v4 & 0x80000000) != 0) {
    return v4;
  }
  if (*(_DWORD *)(v7 + 24))
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    do
    {
      unsigned int v15 = (uint64_t *)(*(void *)(*(void *)(*(void *)(v5 + 584) + 8) + 16 * a3 + 8) + v13);
      uint64_t v4 = pipeline_ResourceUnload(*(uint64_t **)(v5 + 232), *v15, v15[1], v8, v9, v10, v11, v12);
      if ((v4 & 0x80000000) != 0) {
        return v4;
      }
      ++v14;
      v13 += 16;
    }
    while (v14 < *(unsigned int *)(v7 + 24));
  }
  uint64_t v16 = paramc_ParamSetStr(*(void *)(v20 + 40), (uint64_t)"cup_name", byte_2207887FC);
  if ((v16 & 0x80000000) == 0)
  {
    objc_ReleaseObject(*(void *)(v20 + 48), *(void *)(v7 + 64));
    uint64_t v17 = *(void *)(v5 + 584);
    if (v17)
    {
      if (*(void *)(v17 + 16) > a3)
      {
        int v18 = (void *)(*(void *)(v17 + 8) + 16 * a3);
        *int v18 = 0;
        heap_Free(*(void **)v17, v18[1]);
        *(void *)(*(void *)(v17 + 8) + 16 * a3 + 8) = 0;
      }
    }
  }
  return v16;
}

uint64_t ttseg_ResourceEnable(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  int v25 = 0;
  uint64_t v6 = ttseg_loc_BeginFunction(a1, a2, &v26, &v27);
  if ((v6 & 0x80000000) != 0) {
    return v6;
  }
  log_OutText(*(void *)(v26 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Resource Enable : Begin (%p)", v7, v8, v9, a3);
  uint64_t v10 = v27;
  uint64_t v6 = ttseg_loc_LockFromIdle(v26, v27, (uint64_t)"ttseg_ResourceEnable", 2, &v25);
  if ((v6 & 0x80000000) != 0) {
    return v6;
  }
  if (*(void *)(v10 + 232))
  {
    unint64_t v15 = 0;
    uint64_t v16 = 2166366216;
    do
    {
      uint64_t v17 = *(void *)(v10 + 232);
      if (v15 >= *(unsigned __int16 *)(v17 + 24)) {
        break;
      }
      int v18 = *(void **)(*(void *)(v17 + 16) + 8 * v15);
      BOOL v19 = *(uint64_t (**)(void, void, uint64_t, uint64_t))(v18[2] + 80);
      if (v19)
      {
        uint64_t v16 = v19(v18[3], v18[4], a3, a4);
        if ((v16 & 0x80000000) == 0) {
          goto LABEL_13;
        }
      }
      ++v15;
    }
    while ((v16 & 0x1FFF) == 8);
    if ((v16 & 0x80000000) != 0) {
      log_OutPublic(*(void *)(v26 + 32), (uint64_t)"TTSEG", 16067, (uint64_t)"%s%p%s%x", v11, v12, v13, v14, "handle");
    }
  }
  else
  {
    log_OutPublic(*(void *)(v26 + 32), (uint64_t)"TTSEG", 16066, 0, v11, v12, v13, v14, v24);
    uint64_t v16 = 2166366225;
  }
LABEL_13:
  ttseg_loc_Unlock(v26, v10, v25);
  log_OutText(*(void *)(v26 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Resource Enable : End (%x)", v20, v21, v22, v16);
  return v16;
}

uint64_t ttseg_ResourceDisable(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  int v25 = 0;
  uint64_t v6 = ttseg_loc_BeginFunction(a1, a2, &v26, &v27);
  if ((v6 & 0x80000000) != 0) {
    return v6;
  }
  log_OutText(*(void *)(v26 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Resource Disable : Begin (%p)", v7, v8, v9, a3);
  uint64_t v10 = v27;
  uint64_t v6 = ttseg_loc_LockFromIdle(v26, v27, (uint64_t)"ttseg_ResourceDisable", 2, &v25);
  if ((v6 & 0x80000000) != 0) {
    return v6;
  }
  if (*(void *)(v10 + 232))
  {
    unint64_t v15 = 0;
    uint64_t v16 = 2166366216;
    do
    {
      uint64_t v17 = *(void *)(v10 + 232);
      if (v15 >= *(unsigned __int16 *)(v17 + 24)) {
        break;
      }
      int v18 = *(void **)(*(void *)(v17 + 16) + 8 * v15);
      BOOL v19 = *(uint64_t (**)(void, void, uint64_t, uint64_t))(v18[2] + 88);
      if (v19)
      {
        uint64_t v16 = v19(v18[3], v18[4], a3, a4);
        if ((v16 & 0x80000000) == 0) {
          goto LABEL_13;
        }
      }
      ++v15;
    }
    while ((v16 & 0x1FFF) == 8);
    if ((v16 & 0x80000000) != 0) {
      log_OutPublic(*(void *)(v26 + 32), (uint64_t)"TTSEG", 16070, (uint64_t)"%s%p%s%x", v11, v12, v13, v14, "handle");
    }
  }
  else
  {
    log_OutPublic(*(void *)(v26 + 32), (uint64_t)"TTSEG", 16069, 0, v11, v12, v13, v14, v24);
    uint64_t v16 = 2166366225;
  }
LABEL_13:
  ttseg_loc_Unlock(v26, v10, v25);
  log_OutText(*(void *)(v26 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Resource Disable : End (%x)", v20, v21, v22, v16);
  return v16;
}

uint64_t ttseg_Synthesize(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v43 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  int v40 = 0;
  uint64_t v10 = ttseg_loc_BeginFunction(a1, a2, &v41, &v42);
  if ((v10 & 0x80000000) != 0) {
    return v10;
  }
  log_OutText(*(void *)(v41 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Synthesize : Begin", v11, v12, v13, v38);
  uint64_t v14 = v42;
  uint64_t v10 = ttseg_loc_LockFromIdle(v41, v42, (uint64_t)"ttseg_Synthesize", 3, &v40);
  if ((v10 & 0x80000000) != 0) {
    return v10;
  }
  uint64_t v19 = *(void *)(v14 + 232);
  if (v19)
  {
    uint64_t v20 = *(void *)(v19 + 32);
    if (v20)
    {
      compstats_Reset(v20);
      compstats_Start(*(void *)(*(void *)(v14 + 232) + 32), *(void *)(*(void *)(v14 + 232) + 40), 0, v21, v22, v23, v24, v25);
    }
    uint64_t v31 = ttseg_loc_Synthesize(v41, v14, *(uint64_t (**)(uint64_t, unsigned int *, unsigned char *))(v14 + 40), *(void *)(v14 + 88), 0, *(uint64_t (**)(uint64_t, void, void, void))(v14 + 56), *(void *)(v14 + 88), v18, a3, a4, a5, a6, (_DWORD *)&v43 + 1, (unsigned int *)&v43);
    uint64_t v32 = *(void *)(v14 + 232);
    uint64_t v33 = *(void *)(v32 + 32);
    if (v33)
    {
      compstats_Stop(v33, *(void *)(v32 + 40), 0, v26, v27, v28, v29, v30);
      compstats_Log(*(void *)(*(void *)(v14 + 232) + 32), *(void *)(*(void *)(v14 + 232) + 40), *(void *)(v41 + 32), "Synthesis", *(void *)(*(void *)(v14 + 232) + 48), SHIDWORD(v43), v43);
    }
  }
  else
  {
    log_OutPublic(*(void *)(v41 + 32), (uint64_t)"TTSEG", 16043, 0, v15, v16, v17, v18, v39);
    uint64_t v31 = 2166366225;
  }
  ttseg_loc_Unlock(v41, v14, v40);
  log_OutText(*(void *)(v41 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Synthesize : End (%x)", v34, v35, v36, v31);
  return v31;
}

uint64_t ttseg_loc_Synthesize(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, unsigned int *, unsigned char *), uint64_t a4, char *a5, uint64_t (*a6)(uint64_t, void, void, void), uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, _DWORD *a13, unsigned int *a14)
{
  uint64_t result = ttseg_loc_SynthesizeStart(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
  if ((result & 0x80000000) == 0)
  {
    int v22 = ttseg_loc_ProcessLoop(a2, 0, v16, v17, v18, v19, v20, v21);
    LODWORD(result) = ttseg_loc_SynthesizeEnd(a2, a13, a14);
    if ((int)result >= 0 || v22 <= -1) {
      return v22;
    }
    else {
      return result;
    }
  }
  return result;
}

uint64_t ttseg_SynthesizeCooperatively(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _WORD *a7)
{
  uint64_t v59 = 0;
  int v58 = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  uint64_t v12 = ttseg_loc_BeginFunction(a1, a2, &v56, &v57);
  if ((v12 & 0x80000000) == 0)
  {
    log_OutText(*(void *)(v56 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG SynthesizeCooperatively : Begin", v13, v14, v15, v54);
    uint64_t v16 = v57;
    uint64_t v21 = critsec_Enter(*(void **)(v57 + 96));
    if ((v21 & 0x80000000) != 0)
    {
      log_OutPublic(*(void *)(v56 + 32), (uint64_t)"TTSEG", 16004, (uint64_t)"%s%s%s%x", v17, v18, v19, v20, "function");
      goto LABEL_47;
    }
    int v22 = *(_DWORD *)(v16 + 104);
    if ((v22 - 4) >= 3)
    {
      if (v22 == 1)
      {
        if (*(void *)(v16 + 232))
        {
          *(_DWORD *)(v16 + 104) = 4;
          int v22 = 1;
          goto LABEL_12;
        }
        LODWORD(v21) = -2128601071;
        log_OutPublic(*(void *)(v56 + 32), (uint64_t)"TTSEG", 16043, 0, v17, v18, v19, v20, v55);
      }
      else
      {
        LODWORD(v21) = -2128601071;
        log_OutPublic(*(void *)(v56 + 32), (uint64_t)"TTSEG", 16003, (uint64_t)"%s%s", v17, v18, v19, v20, "function");
      }
      int v22 = 0;
    }
LABEL_12:
    int v26 = critsec_Leave(*(void **)(v16 + 96));
    if (v26 >= 0 || (int)v21 <= -1) {
      uint64_t v21 = v21;
    }
    else {
      uint64_t v21 = v26;
    }
    if ((v21 & 0x80000000) != 0) {
      goto LABEL_47;
    }
    if (v22 == 4)
    {
      *a7 = 32;
      *(_DWORD *)(v16 + 420) = 1;
      uint64_t v21 = ttseg_loc_PutOutput(v16, (_DWORD *)&v59 + 1, v27, v28, v29, v23, v24, v25);
      BOOL v41 = 0;
      if ((v21 & 0x80000000) != 0 || HIDWORD(v59))
      {
LABEL_28:
        if ((v21 & 0x80000000) != 0) {
          goto LABEL_38;
        }
LABEL_37:
        if (v41)
        {
LABEL_38:
          *a7 = 2;
          int v44 = ttseg_loc_SynthesizeEnd(v16, &v59, (unsigned int *)&v58);
          if (v44 >= 0 || (int)v21 <= -1) {
            uint64_t v21 = v21;
          }
          else {
            uint64_t v21 = v44;
          }
          uint64_t v51 = *(void *)(v16 + 232);
          uint64_t v52 = *(void *)(v51 + 32);
          if (v52)
          {
            compstats_Stop(v52, *(void *)(v51 + 40), 0, v45, v46, v47, v48, v49);
            compstats_Log(*(void *)(*(void *)(v16 + 232) + 32), *(void *)(*(void *)(v16 + 232) + 40), *(void *)(v56 + 32), "Synthesis", *(void *)(*(void *)(v16 + 232) + 48), v59, v58);
          }
          ttseg_loc_Unlock(v56, v16, 1);
        }
LABEL_47:
        log_OutText(*(void *)(v56 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG SynthesizeCooperatively : End (%x)", v23, v24, v25, v21);
        return v21;
      }
      uint64_t v37 = ttseg_loc_ProcessLoop(v16, 2, v38, v39, v40, v23, v24, v25);
    }
    else
    {
      if (v22 != 1)
      {
        *a7 = 32;
        *(_DWORD *)(v16 + 420) = 1;
        uint64_t v42 = ttseg_loc_PutOutput(v16, (_DWORD *)&v59 + 1, v27, v28, v29, v23, v24, v25);
        uint64_t v21 = v42;
        BOOL v41 = (int)v42 >= 0 && HIDWORD(v59) == 0;
        if ((v42 & 0x80000000) != 0) {
          goto LABEL_38;
        }
        goto LABEL_37;
      }
      *a7 = 32;
      uint64_t v31 = *(void *)(*(void *)(v16 + 232) + 32);
      if (v31)
      {
        compstats_Reset(v31);
        compstats_Start(*(void *)(*(void *)(v16 + 232) + 32), *(void *)(*(void *)(v16 + 232) + 40), 0, v32, v33, v34, v35, v36);
      }
      uint64_t v37 = ttseg_loc_SynthesizeStart(v56, v16, *(uint64_t (**)(uint64_t, unsigned int *, unsigned char *))(v16 + 40), *(void *)(v16 + 88), 0, *(uint64_t (**)(uint64_t, void, void, void))(v16 + 56), *(void *)(v16 + 88), v25, a3, a4, a5, a6);
    }
    uint64_t v21 = v37;
    BOOL v41 = 0;
    goto LABEL_28;
  }
  return v12;
}

uint64_t ttseg_loc_SynthesizeStart(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, unsigned int *, unsigned char *), uint64_t a4, char *a5, uint64_t (*a6)(uint64_t, void, void, void), uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v100 = *MEMORY[0x263EF8340];
  uint64_t v19 = 2166373638;
  int v20 = *(_DWORD *)(a2 + 192);
  if (v20)
  {
    if (v20 == 2) {
      goto LABEL_11;
    }
    if (v20 != 1) {
      return v19;
    }
  }
  int v21 = *(_DWORD *)(a2 + 196);
  if (v21 != 2)
  {
    if (v21 != 1) {
      return v19;
    }
    if (SWIlicense_inhibited) {
      goto LABEL_11;
    }
    int v22 = SWIlicenseValidate();
    goto LABEL_10;
  }
  if ((SWIlicense_inhibited & 1) == 0)
  {
    int v22 = SWIlicenseValidateCachedLicense();
LABEL_10:
    if (v22 != 4) {
      return v19;
    }
  }
LABEL_11:
  uint64_t v23 = *(void *)(a2 + 544);
  cstdlib_memset((void *)(a2 + 248), 0, 0x130uLL);
  *(void *)(a2 + 248) = a1;
  *(void *)(a2 + 344) = a3;
  *(void *)(a2 + 352) = a4;
  *(_DWORD *)(a2 + 392) = 1;
  *(_DWORD *)(a2 + 420) = 0;
  *(void *)(a2 + 544) = v23;
  uint64_t v24 = heap_Calloc(*(void **)(a1 + 8), *(unsigned __int16 *)(*(void *)(a2 + 232) + 24), 4);
  *(void *)(a2 + 408) = v24;
  if (!v24)
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16000, 0, v25, v26, v27, v28, v93);
    return 2166366218;
  }
  *(_WORD *)(a2 + 416) = *(_WORD *)(*(void *)(a2 + 232) + 24);
  if ((paramc_ParamGetUInt(*(void *)(a1 + 40), (uint64_t)"frequencyhz", (unsigned int *)(a2 + 256)) & 0x80000000) != 0)
  {
    *(_DWORD *)(a2 + 260) = 0;
  }
  else
  {
    if ((paramc_ParamGetUInt(*(void *)(a1 + 40), (uint64_t)"audiooutputsamplebits", (unsigned int *)(a2 + 264)) & 0x80000000) != 0) {
      *(_DWORD *)(a2 + 264) = 16;
    }
    if ((paramc_ParamGetUInt(*(void *)(a1 + 40), (uint64_t)"audiosamplerate", (unsigned int *)(a2 + 260)) & 0x80000000) != 0) {
      *(_DWORD *)(a2 + 260) = *(_DWORD *)(a2 + 256);
    }
    if (*(_DWORD *)(a2 + 208))
    {
      uint64_t v29 = ssftthrottle_Start();
      if ((v29 & 0x80000000) != 0)
      {
        uint64_t v19 = v29;
        log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16013, (uint64_t)"%s%x", v30, v31, v32, v33, "lherror");
LABEL_71:
        ttseg_loc_SynthesizeCleanup(a2, 1, 0, 0, v34, v35, v36, v37);
        return v19;
      }
    }
    else
    {
      ssftthrottle_Stop();
    }
  }
  uint64_t v38 = *(void *)(a1 + 40);
  uint64_t v96 = *(uint64_t ***)(a1 + 32);
  *(void *)uint64_t __dst = 0;
  paramc_ParamGetStr(v38, (uint64_t)"language", __dst);
  uint64_t v39 = *(void *)(a1 + 40);
  *(void *)uint64_t __dst = 0;
  paramc_ParamGetStr(v39, (uint64_t)"voice", __dst);
  uint64_t v40 = *(void *)(a1 + 40);
  *(void *)uint64_t __dst = 0;
  paramc_ParamGetStr(v40, (uint64_t)"voicemodel", __dst);
  uint64_t v41 = *(void *)(a1 + 40);
  *(void *)uint64_t __dst = 0;
  paramc_ParamGetStr(v41, (uint64_t)"langversion", __dst);
  uint64_t v42 = *(void *)(a1 + 40);
  *(void *)uint64_t __dst = 0;
  paramc_ParamGetStr(v42, (uint64_t)"voiceversion", __dst);
  uint64_t v43 = *(void *)(a1 + 40);
  *(void *)uint64_t __dst = 0;
  paramc_ParamGetStr(v43, (uint64_t)"vopversion", __dst);
  uint64_t v44 = *(void *)(a1 + 40);
  *(void *)uint64_t __dst = 0;
  paramc_ParamGetStr(v44, (uint64_t)"applicationname", __dst);
  log_OutEvent(v96, 3, (uint64_t)"%s%s%s%s%s%s%s%u%s%s%s%s%s%s%s%s%s%s", v45, v46, v47, v48, v49, "LANG");
  log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 99, 0, (uint64_t)"SYNTHESIZE START", v50, v51, v52, v94);
  if (a9)
  {
    *(void *)(a2 + 272) = a9;
    *(void *)(a2 + 280) = a10;
    uint64_t v53 = a5;
  }
  else
  {
    uint64_t v54 = *(uint64_t (**)(uint64_t))(*(void *)(a2 + 128) + 32);
    uint64_t NullHandle = safeh_GetNullHandle();
    uint64_t v56 = v54(NullHandle);
    uint64_t v53 = a5;
    if ((v56 & 0x80000000) != 0)
    {
      uint64_t v19 = v56;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16014, (uint64_t)"%s%x", v57, v58, v59, v60, "lherror");
      goto LABEL_71;
    }
    *(_DWORD *)(a2 + 288) = 1;
  }
  if (a11)
  {
    *(void *)(a2 + 296) = a11;
    *(void *)(a2 + 304) = a12;
  }
  else
  {
    uint64_t v61 = *(uint64_t (**)(uint64_t))(*(void *)(a2 + 168) + 32);
    uint64_t v62 = safeh_GetNullHandle();
    uint64_t v63 = v61(v62);
    if ((v63 & 0x80000000) != 0)
    {
      uint64_t v19 = v63;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16073, (uint64_t)"%s%x", v64, v65, v66, v67, "lherror");
      goto LABEL_71;
    }
    *(_DWORD *)(a2 + 312) = 1;
  }
  uint64_t v68 = paramc_ParamSetRestorePoint(*(void *)(a1 + 40), (void *)(a2 + 336));
  if ((v68 & 0x80000000) != 0)
  {
    uint64_t v19 = v68;
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16074, (uint64_t)"%s%x", v69, v70, v71, v72, "lherror");
    goto LABEL_71;
  }
  if (v53)
  {
    if (*v53)
    {
      uint64_t v73 = paramc_ParamSetStr(*(void *)(a1 + 40), (uint64_t)"inputmimetype", v53);
      if ((v73 & 0x80000000) != 0)
      {
        uint64_t v19 = v73;
        log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16102, (uint64_t)"%s%x", v74, v75, v76, v77, "lherror");
        goto LABEL_71;
      }
    }
  }
  if (a3)
  {
    __s2 = 0;
    uint64_t v98 = v53;
    cstdlib_strcpy(__dst, "text/plain;charset=");
    if ((!v53 || !*v53)
      && ((paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"inputmimetype", &v98) & 0x80000000) != 0
       || (uint64_t v53 = v98) == 0
       || !*v98))
    {
      if ((paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"nativetypeofchar", &__s2) & 0x80000000) == 0
        && __s2
        && *__s2)
      {
        cstdlib_strcat(__dst, __s2);
        paramc_ParamRelease(*(void *)(a1 + 40));
      }
      else
      {
        log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16015, 0, v78, v79, v80, v81, v95);
        cstdlib_strcpy(__dst, "text/plain;charset=utf-8");
      }
      uint64_t v53 = __dst;
      uint64_t v98 = __dst;
    }
    uint64_t v82 = (*(uint64_t (**)(void, void, uint64_t, char *, void, uint64_t, uint64_t))(*(void *)(a2 + 128)
                                                                                               + 64))(*(void *)(a2 + 272), *(void *)(a2 + 280), 18, v53, 0, 1, a2 + 320);
    if ((v82 & 0x80000000) != 0)
    {
      uint64_t v19 = v82;
      if ((v82 & 0x1FFF) != 2 || *(_DWORD *)(a2 + 288))
      {
        log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16016, (uint64_t)"%s%s%s%x", v83, v84, v85, v86, "contentType");
        goto LABEL_71;
      }
    }
  }
  uint64_t v87 = ttseg_loc_ProcessStart(a2, a6, a7, 0, *(unsigned __int16 *)(*(void *)(a2 + 232) + 24));
  if ((v87 & 0x80000000) != 0) {
    goto LABEL_69;
  }
  uint64_t v88 = ttseg_loc_OpenOutputStreams((void *)a2);
  uint64_t v19 = v88;
  if (!a6 || (v88 & 0x80000000) != 0) {
    goto LABEL_58;
  }
  uint64_t v87 = (*(uint64_t (**)(void, void, void))(*(void *)(a2 + 128) + 56))(*(void *)(a2 + 272), *(void *)(a2 + 280), (unsigned __int16)(*(_WORD *)(*(void *)(a2 + 232) + 24) + 1));
  if ((v87 & 0x80000000) != 0)
  {
LABEL_69:
    uint64_t v19 = v87;
    goto LABEL_71;
  }
  uint64_t v19 = a6(a7, 0, *(void *)(a2 + 272), *(void *)(a2 + 280));
LABEL_58:
  if ((v19 & 0x80000000) != 0) {
    goto LABEL_71;
  }
  if (*(void *)(a2 + 320))
  {
    InputIntoStreauint64_t m = ttseg_loc_GetInputIntoStream(a1, a3, a4, *(void *)(a2 + 128), (uint64_t *)(a2 + 320), *(void *)(*(void *)(a2 + 232) + 32), *(void *)(*(void *)(a2 + 232) + 40), (_DWORD *)(a2 + 440));
    if ((InputIntoStream & 0x1FFF) == 3) {
      uint64_t v19 = 0;
    }
    else {
      uint64_t v19 = InputIntoStream;
    }
  }
  if (*(_DWORD *)(a2 + 240) != 2 && (v19 & 0x80000000) == 0)
  {
    if (!*(void *)(a2 + 360)) {
      return v19;
    }
    uint64_t v19 = ttseg_loc_PutOutput(a2, 0, v89, v90, v34, v35, v36, v37);
  }
  if ((v19 & 0x80000000) != 0) {
    goto LABEL_71;
  }
  return v19;
}

uint64_t ttseg_loc_PutOutput(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a2;
  v133[0] = 0;
  int v132 = 0;
  uint64_t v10 = *(void *)(a1 + 248);
  uint64_t v130 = 0;
  uint64_t v131 = 0;
  if (a2) {
    *a2 = 0;
  }
  if (!*(void *)(a1 + 48) || *(_DWORD *)(a1 + 420) == 2 || *(_DWORD *)(a1 + 240) == 2) {
    return 0;
  }
  uint64_t v12 = (uint64_t *)(a1 + 424);
  if (!*(void *)(a1 + 424))
  {
    log_OutText(*(void *)(v10 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Send TTSEG_OUT_BUFREQ message", a6, a7, a8, v110);
    *(_DWORD *)(a1 + 268) = 1;
    uint64_t v23 = (unsigned int *)(a1 + 432);
    *(void *)(a1 + 432) = 0;
    uint64_t v24 = *(void *)(a1 + 232);
    uint64_t v25 = *(void *)(v24 + 32);
    if (v25) {
      compstats_Start(v25, *(void *)(v24 + 40), *(unsigned __int16 *)(v24 + 24) + 2, v18, v19, v20, v21, v22);
    }
    uint64_t v31 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, void, uint64_t))(a1 + 48))(*(void *)(a1 + 88), 1, a1 + 424, a1 + 432, 0, a1 + 436);
    uint64_t v32 = *(void *)(a1 + 232);
    uint64_t v33 = *(void *)(v32 + 32);
    if (v33)
    {
      uint64_t v34 = v31;
      compstats_Stop(v33, *(void *)(v32 + 40), *(unsigned __int16 *)(v32 + 24) + 2, v26, v27, v28, v29, v30);
      uint64_t v31 = v34;
    }
    if ((v31 & 0x80000000) != 0)
    {
      uint64_t v38 = v31;
      log_OutText(*(void *)(v10 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"User PutOutput returned error %x", v28, v29, v30, v31);
      return v38;
    }
    if (!*v12 || !*v23)
    {
      log_OutText(*(void *)(v10 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Stopping, user PutOutput returned 0 length samples buffer", v28, v29, v30, v111);
      return 2166368263;
    }
    paramc_ParamSetUInt(*(void *)(v10 + 40), (uint64_t)"audiooutputbufsamples", *v23);
    log_OutText(*(void *)(v10 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"User PutOutput returned %p %u %u", v35, v36, v37, *v12);
  }
  uint64_t result = (*(uint64_t (**)(void, void, char *, int *))(*(void *)(a1 + 128) + 144))(*(void *)(a1 + 360), *(void *)(a1 + 368), (char *)v133 + 4, &v132);
  if ((result & 0x80000000) == 0 && HIDWORD(v133[0])) {
    uint64_t result = (*(uint64_t (**)(void, void, uint64_t *, char *))(*(void *)(a1 + 128) + 88))(*(void *)(a1 + 360), *(void *)(a1 + 368), &v131, (char *)v133 + 4);
  }
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = (*(uint64_t (**)(void, void, uint64_t *, void *))(*(void *)(a1 + 128) + 88))(*(void *)(a1 + 376), *(void *)(a1 + 384), &v130, v133);
    LODWORD(v133[0]) >>= 5;
    if ((result & 0x80000000) == 0)
    {
      if (*(_DWORD *)(a1 + 420) == 2)
      {
        uint64_t v16 = 0;
        unsigned int v17 = 0;
LABEL_16:
        if (v16) {
          uint64_t result = (*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 128) + 96))(*(void *)(a1 + 360), *(void *)(a1 + 368), v16);
        }
        if ((result & 0x80000000) == 0)
        {
          if (v17) {
            return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 128) + 96))(*(void *)(a1 + 376), *(void *)(a1 + 384), 32 * v17);
          }
        }
        return result;
      }
      uint64_t v16 = 0;
      unsigned int v17 = 0;
      int v122 = 0;
      int v39 = 0;
      uint64_t v40 = 64;
      uint64_t v114 = v10;
      uint64_t v115 = v8;
      int v123 = (unsigned int *)(a1 + 432);
      int v126 = (unsigned int *)(a1 + 436);
      while (1)
      {
        if (HIDWORD(v133[0]) <= v16 && LODWORD(v133[0]) <= v17) {
          goto LABEL_16;
        }
        unsigned int v42 = (*(_DWORD *)(a1 + 264) * *(_DWORD *)(a1 + 432)) >> 3;
        if (HIDWORD(v133[0]) - (int)v16 < v42) {
          unsigned int v42 = HIDWORD(v133[0]) - v16;
        }
        if (v130) {
          uint64_t v43 = (_DWORD *)(v130 + 32 * v17);
        }
        else {
          uint64_t v43 = 0;
        }
        if (!*(_DWORD *)(a1 + 436))
        {
          unsigned int v44 = 0;
LABEL_50:
          unsigned int v17 = v133[0];
          goto LABEL_106;
        }
        unsigned int v44 = 0;
        if (!*(_DWORD *)(a1 + 108) || !v130 || v17 == LODWORD(v133[0])) {
          goto LABEL_50;
        }
        int v117 = v39;
        int v124 = v42;
        uint64_t v119 = result;
        uint64_t v129 = 0;
        unsigned int v45 = *(_DWORD *)(a1 + 448);
        (*(void (**)(void, void, char *))(*(void *)(a1 + 128) + 136))(*(void *)(a1 + 360), *(void *)(a1 + 368), (char *)&v129 + 4);
        unsigned int v46 = *(_DWORD *)(a1 + 264);
        unsigned int v127 = v16;
        uint64_t v120 = v40;
        if (v46 == 8)
        {
          int v116 = HIDWORD(v129);
          unsigned int v47 = v124 + v16 + HIDWORD(v129);
        }
        else
        {
          int v116 = HIDWORD(v129);
          if (v46 == 16) {
            unsigned int v47 = (v124 + v16 + HIDWORD(v129)) >> 1;
          }
          else {
            unsigned int v47 = 8 * (v124 + (int)v16 + HIDWORD(v129)) / v46;
          }
        }
        unsigned int v48 = *(_DWORD *)(a1 + 108);
        uint64_t v49 = v130;
        unsigned int v121 = v133[0];
        unint64_t v50 = v130 + 32 * LODWORD(v133[0]);
        MarkToDeliver = ttseg_loc_NextMarkToDeliver(v48, v43, v50, &v129);
        if (!MarkToDeliver)
        {
          unsigned int v44 = 0;
          uint64_t v12 = (uint64_t *)(a1 + 424);
          goto LABEL_104;
        }
        unsigned int v113 = v46;
        uint64_t v118 = v49;
        unsigned int v44 = 0;
        unsigned int v52 = *v126;
        int v53 = v132;
        uint64_t v54 = v43;
        while (1)
        {
          unsigned int v55 = MarkToDeliver[3];
          BOOL v56 = !v53 && v55 >= v47;
          BOOL v57 = !v56;
          if (v44 + v129 > v52 || !v57) {
            break;
          }
          ++v44;
          if (v55 > v45) {
            unsigned int v45 = MarkToDeliver[3];
          }
          uint64_t v54 = MarkToDeliver + 8;
          MarkToDeliver = ttseg_loc_NextMarkToDeliver(v48, MarkToDeliver + 8, v50, &v129);
          if (!MarkToDeliver) {
            goto LABEL_79;
          }
        }
        if (v55 >= v47)
        {
LABEL_79:
          uint64_t v10 = v114;
          uint64_t v8 = v115;
          uint64_t v12 = (uint64_t *)(a1 + 424);
          uint64_t v16 = v127;
          goto LABEL_91;
        }
        if (v55 <= v45) {
          unsigned int v55 = v45;
        }
        unsigned int v59 = (v55 * v113) >> 3;
        if (v113 == 16) {
          unsigned int v59 = 2 * v55;
        }
        if (v113 != 8) {
          unsigned int v55 = v59;
        }
        int v60 = v55 + v117 - v116;
        uint64_t v16 = v127;
        if (v60 <= 0)
        {
          if (v129 <= v52)
          {
            int v124 = 0;
          }
          else
          {
            int v124 = v60 & ~(v60 >> 31);
            MarkToDeliver = ttseg_loc_NextMarkToDeliver(v48, v54, v50, 0);
            if (MarkToDeliver)
            {
              if (v52 <= v44) {
                unsigned int v52 = v44;
              }
              uint64_t v10 = v114;
              uint64_t v8 = v115;
              while (v52 != v44)
              {
                ++v44;
                MarkToDeliver = ttseg_loc_NextMarkToDeliver(v48, MarkToDeliver + 8, v50, 0);
                if (!MarkToDeliver) {
                  goto LABEL_90;
                }
              }
              unsigned int v44 = v52;
              goto LABEL_90;
            }
          }
        }
        else
        {
          int v124 = v60;
        }
        uint64_t v10 = v114;
        uint64_t v8 = v115;
LABEL_90:
        uint64_t v12 = (uint64_t *)(a1 + 424);
LABEL_91:
        if (MarkToDeliver) {
          unsigned int v17 = ((unint64_t)MarkToDeliver - v118) >> 5;
        }
        else {
          unsigned int v17 = v121;
        }
        if (v44 > *(_DWORD *)(a1 + 452))
        {
          uint64_t v61 = heap_Realloc(*(uint64_t **)(v10 + 8), *(void *)(a1 + 456), 32 * v44);
          if (!v61)
          {
            log_OutPublic(*(void *)(v10 + 32), (uint64_t)"TTSEG", 16000, 0, v62, v63, v64, v65, v110);
            return 2166366218;
          }
          *(void *)(a1 + 456) = v61;
          *(_DWORD *)(a1 + 452) = v44;
LABEL_98:
          unsigned int v121 = v17;
          uint64_t v66 = 0;
          uint64_t v67 = v44;
          uint64_t v68 = v43;
          do
          {
            uint64_t v69 = ttseg_loc_NextMarkToDeliver(*(_DWORD *)(a1 + 108), v68, v130 + 32 * LODWORD(v133[0]), 0);
            if (!v69) {
              break;
            }
            uint64_t v70 = v69;
            uint64_t v71 = (_OWORD *)(*(void *)(a1 + 456) + v66);
            long long v72 = v69[1];
            *uint64_t v71 = *v69;
            v71[1] = v72;
            uint64_t v73 = *(void *)(a1 + 456) + v66;
            uint64_t v74 = (*(_DWORD *)(v73 + 12) + *(_DWORD *)(a1 + 444));
            *(_DWORD *)(v73 + 12) = v74;
            if (v74 >= *(_DWORD *)(a1 + 448))
            {
              *(_DWORD *)(a1 + 448) = v74;
            }
            else
            {
              log_OutText(*(void *)(v10 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Marker current position is too small: %ul<%ul", v13, v14, v15, v74);
              *(_DWORD *)(v73 + 12) = *(_DWORD *)(a1 + 448);
            }
            uint64_t v68 = v70 + 2;
            v66 += 32;
            --v67;
          }
          while (v67);
LABEL_104:
          uint64_t v16 = v127;
          unsigned int v17 = v121;
          goto LABEL_105;
        }
        if (v44) {
          goto LABEL_98;
        }
LABEL_105:
        uint64_t result = v119;
        uint64_t v40 = v120;
        unsigned int v42 = v124;
LABEL_106:
        if (!(v44 | v42)) {
          goto LABEL_16;
        }
        *(_DWORD *)(a1 + 268) = 1;
        if (v8) {
          *uint64_t v8 = 1;
        }
        *(_DWORD *)(a1 + 400) = 0;
        int v125 = *(_DWORD *)(a1 + 432);
        if (v42)
        {
          unsigned int v75 = v42;
          cstdlib_memcpy((void *)*v12, (const void *)(v131 + v16), v42);
          unsigned int v42 = v75;
          LODWORD(v16) = v75 + v16;
        }
        unsigned int v76 = *(_DWORD *)(a1 + 264);
        if (v76 != 8)
        {
          if (v76 == 16) {
            v42 >>= 1;
          }
          else {
            unsigned int v42 = 8 * v42 / v76;
          }
        }
        *(_DWORD *)(a1 + 432) = v42;
        *(_DWORD *)(a1 + 436) = v44;
        if (*(_DWORD *)(a1 + 392) == 1)
        {
          *(_DWORD *)(a1 + 392) = 0;
          uint64_t v77 = *(void *)(a1 + 232);
          uint64_t v78 = *(void *)(v77 + 32);
          if (v78) {
            compstats_Notify(v78, *(void *)(v77 + 40), 8);
          }
          int v122 = 1;
        }
        if (v130)
        {
          while (v43 != (_DWORD *)(v130 + 32 * LODWORD(v133[0])))
          {
            if (*v43 == 0x4000 && v43[2])
            {
              LODWORD(v40) = 32;
              break;
            }
            v43 += 8;
          }
          if ((unsigned __int16)v40 == 64) {
            unsigned int v79 = 128;
          }
          else {
            unsigned int v79 = v40 | 0x80;
          }
          if (v16 != HIDWORD(v133[0]) || v132 == 0) {
            uint64_t v40 = v40;
          }
          else {
            uint64_t v40 = v79;
          }
        }
        log_OutText(*(void *)(v10 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Send %u message PCM Length: %u Marker No: %u", v13, v14, v15, (unsigned __int16)v40);
        log_OutText(*(void *)(v10 + 32), (uint64_t)"TTSEG", 99, 0, (uint64_t)"PUT OUTPUT %u samples %u markers", v81, v82, v83, *v123);
        if (*v123)
        {
          uint64_t v89 = *(uint64_t ***)(v10 + 32);
          if (v89)
          {
            if (v122 == 1) {
              uint64_t v90 = 8;
            }
            else {
              uint64_t v90 = 9;
            }
            log_OutEvent(v89, v90, (uint64_t)"%s%lu%s%lu", v84, v85, v86, v87, v88, "SAMP");
          }
        }
        if (*(_DWORD *)(a1 + 208)) {
          ssftthrottle_Audio();
        }
        unsigned int v128 = v16;
        uint64_t v91 = v40;
        uint64_t v92 = *(void *)(a1 + 232);
        uint64_t v93 = *(void *)(v92 + 32);
        if (v93) {
          compstats_Start(v93, *(void *)(v92 + 40), *(unsigned __int16 *)(v92 + 24) + 2, v84, v85, v86, v87, v88);
        }
        int v94 = *(_DWORD *)(a1 + 432);
        unsigned int v95 = v12;
        uint64_t v101 = (*(uint64_t (**)(void, void, uint64_t *, unsigned int *, void, unsigned int *))(a1 + 48))(*(void *)(a1 + 88), (unsigned __int16)v91, v12, v123, *(void *)(a1 + 456), v126);
        uint64_t v102 = v101;
        if ((v101 & 0x80000000) == 0 && *(_DWORD *)(a1 + 260))
        {
          HIDWORD(v129) = 0;
          int UInt = paramc_ParamGetUInt(*(void *)(v10 + 40), (uint64_t)"feedback-amount-of-output-msecs-for-this-speakrequest", (unsigned int *)&v129 + 1);
          unsigned int v104 = HIDWORD(v129);
          if ((UInt & 0x80000000) == 0)
          {
            unsigned int v104 = HIDWORD(v129) + (1000 * v94) / *(_DWORD *)(a1 + 260);
            HIDWORD(v129) = v104;
          }
          paramc_ParamSetUInt(*(void *)(v10 + 40), (uint64_t)"feedback-amount-of-output-msecs-for-this-speakrequest", v104);
          uint64_t v101 = v102;
        }
        uint64_t v105 = *(void *)(a1 + 232);
        uint64_t v106 = *(void *)(v105 + 32);
        if (v106)
        {
          compstats_Stop(v106, *(void *)(v105 + 40), *(unsigned __int16 *)(v105 + 24) + 2, v96, v97, v98, v99, v100);
          uint64_t v101 = v102;
        }
        uint64_t v40 = v91;
        if ((v101 & 0x80000000) != 0)
        {
          log_OutText(*(void *)(v10 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"User PutOutput returned error %x", v98, v99, v100, v101);
        }
        else
        {
          uint64_t v107 = *v95;
          if (!*v95 || (unsigned int v108 = *v123) == 0)
          {
            log_OutText(*(void *)(v10 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Stopping, user PutOutput returned 0 length samples buffer", v98, v99, v100, v112);
            uint64_t result = 2166368263;
            goto LABEL_160;
          }
          if (v108 != v125)
          {
            paramc_ParamSetUInt(*(void *)(v10 + 40), (uint64_t)"audiooutputbufsamples", v108);
            uint64_t v107 = *v95;
          }
          log_OutText(*(void *)(v10 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"User PutOutput returned %p %u %u", v98, v99, v100, v107);
        }
        uint64_t result = v102;
LABEL_160:
        uint64_t v12 = v95;
        uint64_t v16 = v128;
        int v109 = *(_DWORD *)(a1 + 420);
        if (v109 == 1)
        {
          int v109 = 2;
          *(_DWORD *)(a1 + 420) = 2;
          *(void *)(a1 + 424) = 0;
        }
        if ((result & 0x80000000) != 0) {
          return result;
        }
        int v39 = -v128;
        if (v109 == 2) {
          goto LABEL_16;
        }
      }
    }
  }
  return result;
}

uint64_t ttseg_loc_ProcessLoop(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Str = 0;
  uint64_t v311 = *MEMORY[0x263EF8340];
  __s2 = (char *)(a1 + 508);
  uint64_t v11 = *(void *)(a1 + 248);
  unint64_t v12 = *(unsigned __int16 *)(a1 + 404);
  v276 = (uint64_t *)(a1 + 320);
  v275 = (_DWORD *)(a1 + 440);
  unsigned int v274 = 1;
  while (1)
  {
    if (*(_DWORD *)(a1 + 104) == 6)
    {
      log_OutText(*(void *)(v11 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Speaking is interrupted", a6, a7, a8, v269);
      uint64_t Str = 2166368263;
      goto LABEL_337;
    }
    unsigned int v13 = *(_DWORD *)(a1 + 400) + 1;
    *(_DWORD *)(a1 + 400) = v13;
    unsigned int v14 = *(_DWORD *)(a1 + 112);
    if (v14) {
      BOOL v15 = v13 > v14;
    }
    else {
      BOOL v15 = 0;
    }
    if (v15)
    {
      log_OutPublic(*(void *)(v11 + 32), (uint64_t)"TTSEG", 16103, (uint64_t)"%s%u", a5, a6, a7, a8, "loops");
      uint64_t Str = 2166368269;
      goto LABEL_337;
    }
    uint64_t v16 = *(unsigned __int16 *)(a1 + 404);
    unsigned int v17 = *(uint64_t **)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v16);
    if (a2 != 1 || v16 != v12) {
      break;
    }
LABEL_38:
    log_OutText(*(void *)(v11 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Process for %s returned %s %x", a6, a7, a8, v17[1]);
    uint64_t v47 = *(void *)(a1 + 408);
    uint64_t v48 = *(unsigned __int16 *)(a1 + 404);
    int v49 = *(_DWORD *)(v47 + 4 * v48);
    if (v49 != 3)
    {
      unint64_t v50 = *(unsigned __int16 *)(a1 + 404);
      if (v49) {
        goto LABEL_57;
      }
      goto LABEL_64;
    }
    if (*(_DWORD *)(a1 + 240) == 2)
    {
      int v49 = 3;
      unint64_t v50 = *(unsigned __int16 *)(a1 + 404);
      goto LABEL_58;
    }
    uint64_t v51 = *(uint64_t **)(a1 + 248);
    v285 = 0;
    __s = 0;
    uint64_t v283 = 0;
    v284 = 0;
    long long v305 = 0u;
    long long v306 = 0u;
    long long v303 = 0u;
    long long v304 = 0u;
    long long v301 = 0u;
    long long v302 = 0u;
    long long v299 = 0u;
    long long v300 = 0u;
    long long v297 = 0u;
    long long v298 = 0u;
    long long v295 = 0u;
    long long v296 = 0u;
    long long v293 = 0u;
    long long v294 = 0u;
    *(_OWORD *)long long __s1 = 0u;
    long long v292 = 0u;
    uint64_t Str = 0;
    if ((paramc_ParamGetStr(v51[5], (uint64_t)"pipelineswitchvoice", &__s) & 0x80000000) != 0 || !__s) {
      goto LABEL_55;
    }
    if (!*__s) {
      goto LABEL_54;
    }
    BOOL v279 = 0;
    if ((paramc_ParamGetStr(v51[5], (uint64_t)"vsvoicetagwithlangunknow", &v284) & 0x80000000) == 0 && v284) {
      BOOL v279 = *v284 != 0;
    }
    if ((paramc_ParamGetStr(v51[5], (uint64_t)"voice", &v285) & 0x80000000) != 0)
    {
LABEL_54:
      uint64_t Str = 0;
      goto LABEL_55;
    }
    uint64_t v52 = cstdlib_strlen(__s) < 0x200 ? 512 : cstdlib_strlen(__s) + 1;
    uint64_t Str = 2166366218;
    unsigned int v55 = (char *)heap_Calloc((void *)v51[1], v52, 1);
    if (!v55)
    {
LABEL_55:
      *(_DWORD *)(*(void *)(a1 + 408) + 4 * *(unsigned __int16 *)(a1 + 404)) = 1;
      goto LABEL_56;
    }
    BOOL v56 = v55;
    cstdlib_strcpy(v55, __s);
    uint64_t v57 = *(void *)(a1 + 576);
    v277 = v285;
    *(void *)&__src[0] = 0;
    uint64_t __dst = v56;
    if (cstdlib_strcmp(v56, "(pop)"))
    {
      if (!cstdlib_strcmp(v56, "(push)"))
      {
        log_OutText(v51[4], (uint64_t)"TTSEG", 3, 0, (uint64_t)"Push current voice %s to voice stack", v58, v59, v60, (uint64_t)v277);
        uint64_t v83 = strhelper_Strdup(v51[1], v277);
        if (v83) {
          uint64_t Str = tinystack_Push(v57, (uint64_t)v83);
        }
        char v84 = 1;
        goto LABEL_237;
      }
      uint64_t Str = 0;
    }
    else
    {
      uint64_t Str = tinystack_Pop(v57, __src);
      if ((Str & 0x80000000) != 0 || !*(void *)&__src[0])
      {
        log_OutText(v51[4], (uint64_t)"TTSEG", 3, 0, (uint64_t)"Bad voice stack status", v61, v62, v63, v269);
        if ((Str & 0x80000000) != 0)
        {
          char v84 = 1;
          goto LABEL_237;
        }
      }
      else
      {
        cstdlib_strcpy(v56, *(const char **)&__src[0]);
        heap_Free((void *)v51[1], *(uint64_t *)&__src[0]);
        log_OutText(v51[4], (uint64_t)"TTSEG", 3, 0, (uint64_t)"Pop voice from voice stack: %s", v64, v65, v66, (uint64_t)v56);
      }
    }
    v278 = v51;
    uint64_t v85 = strhelper_SafeStrtok((uint64_t)v56, ",", &v283);
    if (!v85)
    {
      char v84 = 1;
LABEL_236:
      uint64_t v51 = v278;
      goto LABEL_237;
    }
    uint64_t v89 = v85;
    unint64_t v272 = v12;
    while (1)
    {
      log_OutText(v278[4], (uint64_t)"TTSEG", 3, 0, (uint64_t)"Consider switch to %s", v86, v87, v88, (uint64_t)v89);
      uint64_t v90 = v285;
      uint64_t v91 = *(void **)(a1 + 248);
      memset(__len, 0, sizeof(__len));
      int v309 = 0;
      memset(__src, 0, sizeof(__src));
      if (!v285 || LH_stricmp(v89, v285) | v279)
      {
        if (cstdlib_strlen(v89) - 31 < 0xFFFFFFFFFFFFFFE0)
        {
          uint64_t v96 = 16121;
LABEL_127:
          log_OutPublic(v91[4], (uint64_t)"TTSEG", v96, (uint64_t)"%s%s", v95, v92, v93, v94, "voice");
          uint64_t Str = 0;
          goto LABEL_163;
        }
        if (!*(void *)(*(void *)(a1 + 32) + 32))
        {
          uint64_t v96 = 16122;
          goto LABEL_127;
        }
      }
      log_OutText(v91[4], (uint64_t)"TTSEG", 3, 0, (uint64_t)"Calling the voice switch callback with argument %s", v92, v93, v94, (uint64_t)v89);
      uint64_t v97 = *(uint64_t (**)(void, char *))(a1 + 80);
      if (v97)
      {
        uint64_t v98 = v97(*(void *)(a1 + 88), v89);
        uint64_t Str = v98;
        if ((v98 & 0x80000000) != 0)
        {
          int v103 = v98 & 0x1FFF;
          uint64_t v104 = v91[4];
          if (v103 != 7858)
          {
            log_OutPublic(v104, (uint64_t)"TTSEG", 16000, (uint64_t)"%s%x", v99, v100, v101, v102, "lherror");
LABEL_235:
            char v84 = 1;
            goto LABEL_236;
          }
          log_OutText(v104, (uint64_t)"TTSEG", 0, 0, (uint64_t)"Voice switch to '%s' is not allowed by user callback", v100, v101, v102, (uint64_t)v89);
          goto LABEL_163;
        }
      }
      else
      {
        uint64_t Str = 0;
      }
      if (v90) {
        LODWORD(v90) = LH_stricmp(v89, v90) == 0;
      }
      if (!cstdlib_strcmp(v89, "__NUAN_Normal")) {
        break;
      }
      v307 = 0;
      v287 = 0;
      cstdlib_memset(__src, 0, 0x154uLL);
      paramc_ParamGetUInt(v91[5], (uint64_t)"frequencyhz", (unsigned int *)&__src[11] + 2);
      cstdlib_strcpy((char *)&__src[8] + 8, v89);
      paramc_ParamGetStr(v91[5], (uint64_t)"voicemodel", &v307);
      paramc_ParamGetStr(v91[5], (uint64_t)"voiceoperatingpoint", &v287);
      unsigned int v108 = v287;
      if (v287)
      {
        int v109 = (char *)&__src[13] + 12;
LABEL_132:
        cstdlib_strcpy(v109, v108);
        goto LABEL_133;
      }
      unsigned int v108 = v307;
      if (v307)
      {
        int v109 = (char *)&__src[11] + 12;
        goto LABEL_132;
      }
LABEL_133:
      if (((*(uint64_t (**)(void, void, void, void, _OWORD *))(*(void *)(*(void *)(a1 + 32) + 32)
                                                                                + 112))(*(void *)(*(void *)(a1 + 32) + 40), *(void *)(*(void *)(a1 + 32) + 48), v91[3], v91[5], __src) & 0x80000000) == 0|| (cstdlib_strcpy((char *)&__src[11] + 12, byte_2207887FC), cstdlib_strcpy((char *)&__src[13] + 12, byte_2207887FC), ((*(uint64_t (**)(void, void, void, void, _OWORD *))(*(void *)(*(void *)(a1 + 32)+ 32)+ 96))(*(void *)(*(void *)(a1 + 32) + 40), *(void *)(*(void *)(a1 + 32) + 48), v91[3], v91[5], __src) & 0x80000000) == 0))
      {
        if (((*(uint64_t (**)(void, void, _OWORD *, uint64_t, _OWORD *))(*(void *)(*(void *)(a1 + 32)
                                                                                                 + 32)
                                                                                     + 104))(*(void *)(*(void *)(a1 + 32) + 40), *(void *)(*(void *)(a1 + 32) + 48), __src, 256, __len) & 0x80000000) == 0)
        {
          int v271 = (int)v90;
          LH_stricmp((char *)__len, *(char **)(*(void *)(a1 + 232) + 8));
          uint64_t v270 = *(unsigned __int16 *)(a1 + 404);
          uint64_t v112 = *(const char **)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v270) + 8);
          unsigned int v113 = *(_WORD **)a1;
          uint64_t v114 = *(void *)(a1 + 8);
          v289 = 0;
          v290[0] = 0;
          v288 = 0;
          uint64_t inited = InitRsrcFunction(v113, v114, v290);
          if ((inited & 0x80000000) == 0)
          {
            if (!v112)
            {
              uint64_t Str = inited;
              unint64_t v12 = v272;
              goto LABEL_154;
            }
            uint64_t Str = pipeline_ListPipelineComponentNames(v113, v114, (char *)__len, (uint64_t *)&v289);
            if ((Str & 0x80000000) != 0)
            {
              log_OutText(v290[0][4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Unable to get pipeline components for '%s'", v120, v121, v122, (uint64_t)__len);
              LODWORD(v112) = 0;
              unint64_t v12 = v272;
              goto LABEL_154;
            }
            unint64_t v12 = v272;
            if (v270 >= (unsigned __int16)vector_GetSize((uint64_t)v289))
            {
              log_OutText(v290[0][4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Candidate pipeline '%s' is not compatible: too few components", v123, v124, v125, (uint64_t)__len);
            }
            else if (vector_GetElemAt((uint64_t)v289, v270, &v288))
            {
              if (*v288)
              {
                int v132 = cstdlib_strcmp(v112, *v288);
                uint64_t v133 = v290[0][4];
                if (v132)
                {
                  log_OutText(v133, (uint64_t)"TTSEG", 4, 0, (uint64_t)"Candidate pipeline '%s' is not compatible: different component at index %u", v129, v130, v131, (uint64_t)__len);
                  goto LABEL_153;
                }
                log_OutText(v133, (uint64_t)"TTSEG", 4, 0, (uint64_t)"Candidate pipeline '%s' is compatible", v129, v130, v131, (uint64_t)__len);
                LODWORD(v112) = 1;
LABEL_154:
                if (v289) {
                  vector_ObjClose((uint64_t)v289);
                }
                if ((Str & 0x80000000) != 0)
                {
LABEL_157:
                  if (!v279) {
                    log_OutPublic(v91[4], (uint64_t)"TTSEG", 16123, (uint64_t)"%s%s", v116, v117, v118, v119, "voice");
                  }
                  uint64_t Str = 0;
                }
                if (v112) {
                  goto LABEL_176;
                }
                log_OutText(v91[4], (uint64_t)"TTSEG", 1, 0, (uint64_t)"Destination pipeline '%s' is not compatible with current pipeline '%s': voice switch should not take place", v117, v118, v119, (uint64_t)__len);
                LODWORD(v90) = v271;
                goto LABEL_162;
              }
              log_OutText(v290[0][4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Pipeline component at index %u in pipeline '%s' is NULL", v126, v127, v128, v270);
            }
            else
            {
              log_OutText(v290[0][4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Unable to get component at index %u in pipeline '%s'", v126, v127, v128, v270);
            }
LABEL_153:
            LODWORD(v112) = 0;
            goto LABEL_154;
          }
          LODWORD(v112) = 0;
          unint64_t v12 = v272;
          goto LABEL_157;
        }
      }
      if (!v279) {
        log_OutPublic(v91[4], (uint64_t)"TTSEG", 16123, (uint64_t)"%s%s", v111, v105, v106, v107, "voice");
      }
      uint64_t Str = 0;
LABEL_162:
      if (v90) {
        goto LABEL_177;
      }
LABEL_163:
      uint64_t v89 = strhelper_SafeStrtok((uint64_t)__dst, ",", &v283);
      if (!v89) {
        goto LABEL_235;
      }
    }
    uint64_t v110 = *(void *)(a1 + 544);
    if (!v110) {
      goto LABEL_162;
    }
    cstdlib_strcpy((char *)__len, *(const char **)(v110 + 8));
LABEL_176:
    cstdlib_strcpy(__s1, (const char *)__len);
LABEL_177:
    uint64_t v51 = v278;
    log_OutText(v278[4], (uint64_t)"TTSEG", 3, 0, (uint64_t)"Preparing for a switch to %s", v105, v106, v107, (uint64_t)__s1);
    uint64_t v140 = paramc_ParamSetStr(v278[5], (uint64_t)"pipelineswitchcomponent", *(char **)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * *(unsigned __int16 *)(a1 + 404))+ 8));
    if ((v140 & 0x80000000) != 0
      || (!cstdlib_strcmp(*(const char **)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16)+ 8 * *(unsigned __int16 *)(a1 + 404))+ 8), "voice_switch")? (v145 = "pipelineswitchvspipeline"): (v145 = "pipelineswitchpipeline"), uint64_t v140 = paramc_ParamSetStr(v278[5], (uint64_t)v145, __s1), (v140 & 0x80000000) != 0))
    {
      uint64_t Str = v140;
      log_OutPublic(v278[4], (uint64_t)"TTSEG", 16000, (uint64_t)"%s%x", v141, v142, v143, v144, "lherror");
      char v84 = 0;
    }
    else
    {
      uint64_t Str = ttseg_loc_ProcessEnd(a1, *(unsigned __int16 *)(a1 + 404), (unsigned __int16)(*(_WORD *)(a1 + 404) + 1), 0, v141, v142, v143, v144);
      char v84 = 0;
    }
LABEL_237:
    heap_Free((void *)v51[1], (uint64_t)__dst);
    if ((v84 & 1) != 0 || (Str & 0x80000000) != 0) {
      goto LABEL_55;
    }
LABEL_56:
    uint64_t v47 = *(void *)(a1 + 408);
    unint64_t v50 = *(unsigned __int16 *)(a1 + 404);
    int v49 = *(_DWORD *)(v47 + 4 * v50);
    LODWORD(v48) = *(unsigned __int16 *)(a1 + 404);
    if (!v49) {
      goto LABEL_64;
    }
LABEL_57:
    if (v49 == 4) {
      goto LABEL_254;
    }
LABEL_58:
    int v53 = v48 + 1;
    unsigned int v54 = *(unsigned __int16 *)(*(void *)(a1 + 232) + 24);
    if ((int)v48 + 1 < v54)
    {
      *(_WORD *)(a1 + 404) = v53;
      goto LABEL_254;
    }
    if (v53 == v54 && *(void *)(a1 + 360))
    {
      uint64_t Str = ttseg_loc_PutOutput(a1, 0, v45, v46, a5, a6, a7, a8);
      if ((Str & 0x80000000) != 0) {
        goto LABEL_254;
      }
      uint64_t v47 = *(void *)(a1 + 408);
      unint64_t v50 = *(unsigned __int16 *)(a1 + 404);
      int v49 = *(_DWORD *)(v47 + 4 * v50);
      LODWORD(v48) = *(unsigned __int16 *)(a1 + 404);
    }
LABEL_64:
    if (v48 && (v49 & 0xFFFFFFFE) != 2)
    {
      if (a2 != 1) {
        goto LABEL_257;
      }
LABEL_261:
      if (v50 <= v12)
      {
        if (v12 == (unsigned __int16)v50) {
          goto LABEL_333;
        }
        goto LABEL_267;
      }
LABEL_257:
      while (1)
      {
        *(_WORD *)(a1 + 404) = --v50;
        int v49 = *(_DWORD *)(v47 + 4 * (unsigned __int16)v50);
        if (!(_WORD)v50 || (v49 & 0xFFFFFFFE) == 2) {
          break;
        }
        if (a2 == 1)
        {
          LOWORD(v48) = v50;
          goto LABEL_261;
        }
      }
      LOWORD(v48) = v50;
      unint64_t v50 = (unsigned __int16)v50;
    }
    if (a2 == 1 && v12 == (unsigned __int16)v48)
    {
LABEL_333:
      log_OutText(*(void *)(v11 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Returning to Process for %s", a6, a7, a8, *(void *)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v50) + 8));
      goto LABEL_338;
    }
LABEL_267:
    if (v49 != 3 || *(_DWORD *)(a1 + 240) == 2) {
      goto LABEL_311;
    }
    uint64_t v191 = *(void *)(a1 + 248);
    *(void *)&__len[0] = 0;
    *(void *)long long __s1 = 0;
    v290[0] = 0;
    LODWORD(v289) = 0;
    if ((paramc_ParamGetStr(*(void *)(v191 + 40), (uint64_t)"pipelineswitchpipeline", __s1) & 0x80000000) != 0
      || !*(void *)__s1
      || !**(unsigned char **)__s1)
    {
      uint64_t Str = paramc_ParamGetStr(*(void *)(v191 + 40), (uint64_t)"pipelineswitchvspipeline", __len);
      if ((Str & 0x80000000) != 0 || !*(void *)&__len[0] || !**(unsigned char **)&__len[0]) {
        goto LABEL_310;
      }
      uint64_t v197 = *(void *)(v191 + 8);
      int v198 = cstdlib_strlen(*(const char **)&__len[0]);
      v199 = (char *)heap_Alloc(v197, (v198 + 1));
      if (v199)
      {
        int v195 = v199;
        cstdlib_strcpy(v199, *(const char **)&__len[0]);
        int v196 = "pipelineswitchvspipeline";
        goto LABEL_279;
      }
LABEL_292:
      uint64_t Str = 2166366218;
      goto LABEL_310;
    }
    uint64_t v192 = *(void *)(v191 + 8);
    int v193 = cstdlib_strlen(*(const char **)__s1);
    uint64_t v194 = (char *)heap_Alloc(v192, (v193 + 1));
    if (!v194) {
      goto LABEL_292;
    }
    int v195 = v194;
    cstdlib_strcpy(v194, *(const char **)__s1);
    int v196 = "pipelineswitchpipeline";
LABEL_279:
    paramc_ParamSetStr(*(void *)(v191 + 40), (uint64_t)v196, 0);
    paramc_ParamSetUInt(*(void *)(v191 + 40), (uint64_t)"pipelineswitchexecuting", 1u);
    log_OutText(*(void *)(v191 + 32), (uint64_t)"TTSEG", 3, 0, (uint64_t)"Execute switch to %s", v200, v201, v202, (uint64_t)v195);
    log_OutText(*(void *)(v191 + 32), (uint64_t)"TTSEG", 99, 0, (uint64_t)"PIPELINE SWITCH %s", v203, v204, v205, (uint64_t)v195);
    uint64_t v210 = ttseg_loc_ProcessEnd(a1, (unsigned __int16)(*(_WORD *)(a1 + 404) + 1), *(unsigned __int16 *)(*(void *)(a1 + 232) + 24), 1, v206, v207, v208, v209);
    if ((v210 & 0x80000000) == 0)
    {
      uint64_t v210 = ttseg_loc_CloseOutputStreams(a1, v211, v212, v213, v214, v215, v216, v217);
      if ((v210 & 0x80000000) == 0) {
        uint64_t v210 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 128) + 160))(*(void *)(a1 + 272), *(void *)(a1 + 280), (unsigned __int16)(*(_WORD *)(a1 + 404) + 1));
      }
    }
    uint64_t Str = v210;
    if (!*(void *)(a1 + 544)) {
      *(void *)(a1 + 544) = *(void *)(a1 + 232);
    }
    if ((v210 & 0x80000000) != 0) {
      goto LABEL_309;
    }
    if (!LH_stricmp(v195, *(char **)(*(void *)(a1 + 232) + 8)))
    {
      v234 = *(uint64_t **)(a1 + 232);
      v290[0] = v234;
      goto LABEL_294;
    }
    uint64_t v225 = *(void *)(a1 + 544);
    if (v225 && !LH_stricmp(v195, *(char **)(v225 + 8)))
    {
      v234 = *(uint64_t **)(a1 + 544);
      v290[0] = v234;
      uint64_t v233 = pipeline_ObjReopen((uint64_t)v234, v226, v227, v228, v229, v230, v231, v232);
      if ((v233 & 0x80000000) == 0) {
        goto LABEL_294;
      }
LABEL_306:
      uint64_t Str = v233;
      goto LABEL_309;
    }
    uint64_t v233 = pipeline_ObjOpen(*(_WORD **)a1, *(void *)(a1 + 8), v195, *(void *)(a1 + 232), *(unsigned __int16 *)(a1 + 404), *(void *)(a1 + 120), v290, &v289);
    if ((v233 & 0x80000000) != 0) {
      goto LABEL_306;
    }
    v234 = v290[0];
    if (*(_DWORD *)(a1 + 192) == 1)
    {
      if (ttseg_loc_LicensingModePipeline(v191, a1, (uint64_t)v290[0]))
      {
        v234 = v290[0];
        goto LABEL_294;
      }
      log_OutPublic(*(void *)(v191 + 32), (uint64_t)"TTSEG", 16124, (uint64_t)"%s%s", v221, v222, v223, v224, "pipeline");
      pipeline_ObjClose((uint64_t)v290[0], v254, v255, v256, v257, v258, v259, v260);
      v290[0] = 0;
      uint64_t Str = 2166373638;
    }
    else
    {
LABEL_294:
      uint64_t v235 = *(void *)(a1 + 232);
      if ((uint64_t *)v235 == v234 || v235 == *(void *)(a1 + 544))
      {
        *(void *)(a1 + 232) = v234;
      }
      else
      {
        uint64_t Str = pipeline_ObjClose(v235, v218, v219, v220, v221, v222, v223, v224);
        paramc_ParamSetStr(*(void *)(v191 + 40), (uint64_t)"fedatapackaging", byte_2207887FC);
        v234 = v290[0];
        *(uint64_t **)(a1 + 232) = v290[0];
        if ((Str & 0x80000000) != 0) {
          goto LABEL_309;
        }
      }
      uint64_t v236 = *((unsigned __int16 *)v234 + 12);
      if (v236 > *(unsigned __int16 *)(a1 + 416))
      {
        uint64_t v237 = heap_Realloc(*(uint64_t **)(v191 + 8), *(void *)(a1 + 408), 4 * v236);
        if (!v237)
        {
          uint64_t Str = 2166366218;
          log_OutPublic(*(void *)(v191 + 32), (uint64_t)"TTSEG", 16000, 0, v238, v239, v240, v241, v269);
          goto LABEL_309;
        }
        *(void *)(a1 + 408) = v237;
        *(_WORD *)(a1 + 416) = *((_WORD *)v290[0] + 12);
      }
      uint64_t v242 = *(void *)(v191 + 40);
      int __dsta = *(char **)(v191 + 32);
      *(void *)&__src[0] = 0;
      paramc_ParamGetStr(v242, (uint64_t)"language", __src);
      uint64_t v243 = *(void *)(v191 + 40);
      *(void *)&__src[0] = 0;
      paramc_ParamGetStr(v243, (uint64_t)"voice", __src);
      uint64_t v244 = *(void *)(v191 + 40);
      *(void *)&__src[0] = 0;
      paramc_ParamGetStr(v244, (uint64_t)"voicemodel", __src);
      uint64_t v245 = *(void *)(v191 + 40);
      *(void *)&__src[0] = 0;
      paramc_ParamGetStr(v245, (uint64_t)"langversion", __src);
      uint64_t v246 = *(void *)(v191 + 40);
      *(void *)&__src[0] = 0;
      paramc_ParamGetStr(v246, (uint64_t)"voiceversion", __src);
      uint64_t v247 = *(void *)(v191 + 40);
      *(void *)&__src[0] = 0;
      paramc_ParamGetStr(v247, (uint64_t)"applicationname", __src);
      log_OutEvent((uint64_t **)__dsta, 16, (uint64_t)"%s%s%s%s%s%s%s%u%s%s%s%s%s%s%s%s", v248, v249, v250, v251, v252, "LANG");
      uint64_t v253 = ttseg_loc_ProcessStart(a1, 0, 0, *(unsigned __int16 *)(a1 + 404), *(unsigned __int16 *)(*(void *)(a1 + 232) + 24));
      if ((v253 & 0x80000000) == 0) {
        uint64_t v253 = ttseg_loc_OpenOutputStreams((void *)a1);
      }
      uint64_t Str = v253;
    }
LABEL_309:
    paramc_ParamSetUInt(*(void *)(v191 + 40), (uint64_t)"pipelineswitchexecuting", 0);
    heap_Free(*(void **)(v191 + 8), (uint64_t)v195);
LABEL_310:
    LOWORD(v48) = *(_WORD *)(a1 + 404);
LABEL_311:
    if ((_WORD)v48 || **(_DWORD **)(a1 + 408) == 2) {
      goto LABEL_254;
    }
    uint64_t v261 = *(void *)(a1 + 232);
    if (*(void *)(a1 + 320))
    {
      *(_DWORD *)(a1 + 400) = 0;
      uint64_t Str = ttseg_loc_GetInputIntoStream(v11, *(uint64_t (**)(uint64_t, unsigned int *, unsigned char *))(a1 + 344), *(void *)(a1 + 352), *(void *)(a1 + 128), v276, *(void *)(v261 + 32), *(void *)(v261 + 40), v275);
      if ((Str & 0x1FFF) != 3) {
        goto LABEL_254;
      }
      uint64_t Str = 0;
      uint64_t v261 = *(void *)(a1 + 232);
    }
    uint64_t v262 = *(unsigned __int16 *)(v261 + 24);
    if (!v262)
    {
LABEL_320:
      if (a2 != 2) {
        goto LABEL_337;
      }
      int v265 = critsec_Enter(*(void **)(a1 + 96));
      if ((v265 & 0x80000000) == 0)
      {
        if (*(_DWORD *)(a1 + 104) == 4) {
          *(_DWORD *)(a1 + 104) = 5;
        }
        int v265 = critsec_Leave(*(void **)(a1 + 96));
      }
      if ((int)Str > -1 && v265 < 0) {
        return v265;
      }
      else {
        return Str;
      }
    }
    v263 = *(int **)(a1 + 408);
    while (1)
    {
      int v264 = *v263++;
      if (v264 != 1) {
        break;
      }
      if (!--v262) {
        goto LABEL_320;
      }
    }
LABEL_254:
    if (a2 == 2) {
      return Str;
    }
LABEL_255:
    if ((Str & 0x80000000) != 0) {
      goto LABEL_337;
    }
  }
  *(_DWORD *)(*(void *)(a1 + 408) + 4 * v16) = 0;
  log_OutText(*(void *)(v11 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Calling Process for %s", a6, a7, a8, v17[1]);
  uint64_t v23 = *(void *)(a1 + 232);
  uint64_t v24 = *(void *)(v23 + 32);
  if (v24) {
    compstats_Start(v24, *(void *)(v23 + 40), *(unsigned __int16 *)(a1 + 404) + 2, v18, v19, v20, v21, v22);
  }
  if (*(_DWORD *)(a1 + 240) != 2)
  {
LABEL_20:
    paramc_ParamTraceSetStr();
    uint64_t Str = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t))(v17[2] + 104))(v17[3], v17[4], *(void *)(a1 + 296), *(void *)(a1 + 304), *(void *)(a1 + 408) + 4 * *(unsigned __int16 *)(a1 + 404));
    paramc_ParamTraceSetStr();
    if (*(_DWORD *)(a1 + 240) == 2
      && ttseg_loc_ComponentIsTextParser((const char *)v17[1])
      && !*(_DWORD *)(*(void *)(a1 + 408) + 4 * *(unsigned __int16 *)(a1 + 404)))
    {
      (*(void (**)(void, void))(*(void *)(a1 + 128) + 72))(*(void *)(a1 + 320), *(void *)(a1 + 328));
    }
    uint64_t v39 = *(void *)(a1 + 232);
    uint64_t v40 = *(void *)(v39 + 32);
    if (v40) {
      compstats_Stop(v40, *(void *)(v39 + 40), *(unsigned __int16 *)(a1 + 404) + 2, v38, a5, a6, a7, a8);
    }
    uint64_t v41 = *(uint64_t (**)(void, uint64_t, void, void, uint64_t))(a1 + 64);
    if (v41)
    {
      int v42 = v41(*(void *)(a1 + 88), v17[1], *(void *)(a1 + 296), *(void *)(a1 + 304), *(void *)(a1 + 408) + 4 * *(unsigned __int16 *)(a1 + 404));
      if ((int)Str > -1 && v42 < 0) {
        uint64_t Str = v42;
      }
      else {
        uint64_t Str = Str;
      }
    }
    uint64_t v44 = *(void *)(a1 + 168);
    if (*(void *)(v44 + 200))
    {
      LODWORD(__src[0]) = 0;
      if (((*(uint64_t (**)(void, void, _OWORD *))(v44 + 216))(*(void *)(a1 + 296), *(void *)(a1 + 304), __src) & 0x80000000) == 0)
      {
        if (LODWORD(__src[0])) {
          (*(void (**)(void, void, void, uint64_t, uint64_t))(*(void *)(a1 + 168) + 200))(*(void *)(a1 + 296), *(void *)(a1 + 304), 0, v17[1], 1);
        }
      }
    }
    if ((Str & 0x80000000) != 0)
    {
      if ((Str & 0x1FFF) != 0x807) {
        log_OutPublic(*(void *)(v11 + 32), (uint64_t)"TTSEG", 16018, (uint64_t)"%s%s%s%x", a5, a6, a7, a8, "component");
      }
      goto LABEL_254;
    }
    goto LABEL_38;
  }
  if (cstdlib_strcmp((const char *)v17[1], __s2))
  {
    if (ttseg_loc_ComponentIsTextParser((const char *)v17[1]))
    {
      LODWORD(__len[0]) = 0;
      *(void *)&__src[0] = 0;
      uint64_t v25 = *(void *)(a1 + 248);
      uint64_t v26 = (*(uint64_t (**)(void, void, _OWORD *, _OWORD *))(*(void *)(a1 + 128) + 88))(*(void *)(a1 + 136), *(void *)(a1 + 144), __src, __len);
      if ((v26 & 0x80000000) != 0) {
        goto LABEL_334;
      }
      if (LODWORD(__len[0]))
      {
        uint64_t v30 = *(unsigned int *)(a1 + 504);
        int v31 = v30 + LODWORD(__len[0]);
        *(_DWORD *)(a1 + 504) = v30 + LODWORD(__len[0]);
        uint64_t v32 = heap_Realloc(*(uint64_t **)(*(void *)(a1 + 248) + 8), *(void *)(a1 + 496), (v31 + 1));
        if (!v32)
        {
          uint64_t Str = 2166366218;
          uint64_t v267 = *(void *)(v25 + 32);
LABEL_336:
          log_OutPublic(v267, (uint64_t)"TTSEG", 16000, 0, v33, v34, v35, v36, v269);
          goto LABEL_337;
        }
        *(void *)(a1 + 496) = v32;
        cstdlib_memmove((void *)(v32 + v30), *(const void **)&__src[0], LODWORD(__len[0]));
        uint64_t v37 = LODWORD(__len[0]);
      }
      else
      {
        uint64_t v37 = 0;
      }
      uint64_t v26 = (*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 128) + 96))(*(void *)(a1 + 136), *(void *)(a1 + 144), v37);
      if ((v26 & 0x80000000) != 0)
      {
LABEL_334:
        uint64_t Str = v26;
        log_OutText(*(void *)(*(void *)(a1 + 248) + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Getting translated text returned error %x", v27, v28, v29, v26);
        goto LABEL_337;
      }
    }
    goto LABEL_20;
  }
  LODWORD(v287) = 0;
  v288 = 0;
  *(_OWORD *)long long __s1 = *(_OWORD *)"unknown";
  v307 = (char *)0x6E776F6E6B6E75;
  strcpy((char *)v290, "ins_unknown");
  uint64_t Str = (*(uint64_t (**)(void, void, const char ***, char **))(*(void *)(a1 + 128) + 88))(*(void *)(a1 + 152), *(void *)(a1 + 160), &v288, &v287);
  if ((Str & 0x80000000) != 0 || (unint64_t v70 = v287, !v287))
  {
    log_OutText(*(void *)(*(void *)(a1 + 248) + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Getting markers returned error %x", v67, v68, v69, Str);
LABEL_174:
    if ((Str & 0x80000000) != 0) {
      goto LABEL_337;
    }
LABEL_247:
    unsigned int v188 = *(unsigned __int16 *)(a1 + 540);
    unsigned int v189 = *(unsigned __int16 *)(a1 + 542);
    if (v188 > v189) {
      return 0;
    }
    int v190 = 1;
    do
    {
      if (*(_DWORD *)(*(void *)(a1 + 408) + 4 * (unsigned __int16)v188) != 1) {
        int v190 = 0;
      }
      LOWORD(v188) = v188 + 1;
    }
    while (v189 >= (unsigned __int16)v188);
    if (v190 == 1) {
      return 0;
    }
    *(_WORD *)(a1 + 404) = *(_WORD *)(*(void *)(a1 + 232) + 24) - 2;
    goto LABEL_255;
  }
  unint64_t v71 = (unint64_t)v287 >> 5;
  LODWORD(v287) = v287 >> 5;
  if (v70 < 0x20) {
    goto LABEL_100;
  }
  uint64_t v72 = 0;
  unsigned int v73 = 0;
  unint64_t v74 = 1;
  int v75 = 1;
  while (2)
  {
    unsigned int v76 = v288;
    int v77 = (int)v288[v72];
    if (v77 == 0x4000)
    {
      int v78 = (int)v288[v72 + 1];
      if (LODWORD(v288[v72 + 2]) | v78)
      {
        ++v73;
        *(_DWORD *)(a1 + 480) = v78;
        goto LABEL_83;
      }
    }
    else
    {
LABEL_83:
      if (v77 == 29) {
        ++v73;
      }
      if (v77 == 36 && v75 == 1)
      {
        cstdlib_strcpy(__s1, v76[v72 + 3]);
        if (v74 < v287 && LODWORD(v76[v72 + 4]) == 36)
        {
          uint64_t v80 = &v76[v72];
          if (cstdlib_strlen(v80[7]) >= 4) {
            cstdlib_strcpy(__s1, v80[7]);
          }
        }
        if (!cstdlib_strcmp(__s1, (const char *)v290)) {
          cstdlib_strcpy(__s1, (const char *)&v307);
        }
        int v75 = 0;
      }
    }
    unint64_t v71 = v287;
    v72 += 4;
    if (v74++ < v287) {
      continue;
    }
    break;
  }
  if (v73) {
    goto LABEL_172;
  }
LABEL_100:
  if (!v71)
  {
LABEL_104:
    uint64_t Str = 20;
    log_OutText(*(void *)(*(void *)(a1 + 248) + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"No SYNC marker found for the input text given to vauto_ttsAnalyzeText() %x", v67, v68, v69, 20);
    goto LABEL_247;
  }
  uint64_t v82 = (int *)(v288 + 1);
  while (*(v82 - 2) != 0x4000)
  {
    v82 += 8;
    if (!--v71) {
      goto LABEL_104;
    }
  }
  int v134 = *v82;
  if (v274 == 1)
  {
    v134 += *(v82 - 1);
    *(v82 - 1) = 0;
    *uint64_t v82 = v134;
  }
  *(_DWORD *)(a1 + 480) = v134;
  unsigned int v73 = 1;
LABEL_172:
  *(_DWORD *)(a1 + 484) = v73;
  uint64_t v135 = ttseg_loc_PutOutput_TAI((void *)a1, 0, v274);
  uint64_t v139 = *(void *)(a1 + 248);
  if (v135)
  {
    uint64_t Str = v135;
    log_OutText(*(void *)(v139 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Callback for TA Info Request returned error %x", v136, v137, v138, v135);
    goto LABEL_174;
  }
  uint64_t v146 = heap_Calloc(*(void **)(v139 + 8), v73, 40);
  *(void *)(a1 + 488) = v146;
  if (!v146)
  {
    uint64_t Str = 2166366218;
    uint64_t v267 = *(void *)(*(void *)(a1 + 248) + 32);
    goto LABEL_336;
  }
  unint64_t v273 = v12;
  if (v287)
  {
    unint64_t v147 = 0;
    unsigned int v148 = 0;
    do
    {
      uint64_t v149 = v288;
      uint64_t v150 = &v288[4 * v147];
      int v151 = *(_DWORD *)v150;
      if (*(_DWORD *)v150 == 36)
      {
        cstdlib_strcpy(__s1, v150[3]);
        if (!cstdlib_strcmp(__s1, (const char *)v290)) {
          cstdlib_strcpy(__s1, (const char *)&v307);
        }
      }
      else
      {
        if (v151 != 0x4000) {
          goto LABEL_195;
        }
        uint64_t v152 = &v288[4 * v147];
        if (!*((_DWORD *)v152 + 4) && !*((_DWORD *)v152 + 2)) {
          goto LABEL_209;
        }
      }
      int v151 = *(_DWORD *)v150;
LABEL_195:
      if (v151 == 0x4000 || v151 == 29)
      {
        uint64_t v154 = *(void *)(a1 + 488);
        uint64_t v155 = v154 + 40 * v148;
        if (v151 == 0x4000) {
          int v156 = 1;
        }
        else {
          int v156 = 2;
        }
        *(_DWORD *)uint64_t v155 = v156;
        cstdlib_strcpy((char *)(v155 + 24), __s1);
        int v157 = &v149[4 * v147];
        unsigned int v159 = *((_DWORD *)v157 + 1);
        int v158 = (unsigned int *)v157 + 1;
        *(void *)(v155 + 8) = v159;
        if (*(_DWORD *)v150 == 0x4000)
        {
          unsigned int v160 = (void *)heap_Calloc(*(void **)(*(void *)(a1 + 248) + 8), 1, (*(_DWORD *)(a1 + 480) + 1));
          *(void *)(a1 + 472) = v160;
          if (!v160)
          {
            uint64_t Str = 2166366218;
            log_OutPublic(*(void *)(*(void *)(a1 + 248) + 32), (uint64_t)"TTSEG", 16000, 0, v161, v162, v163, v164, v269);
LABEL_342:
            LOWORD(v12) = v273;
            goto LABEL_337;
          }
          cstdlib_memmove(v160, (const void *)(*(void *)(a1 + 496) + *v158), *(unsigned int *)(a1 + 480));
        }
        uint64_t v165 = *(void *)(a1 + 552);
        do
        {
          uint64_t v166 = (_DWORD *)v165;
          uint64_t v165 = *(void *)(v165 + 168);
        }
        while (v165);
        ++*v166;
        *(void *)(v154 + 40 * v148++ + 16) = v166;
      }
      else
      {
        uint64_t v167 = *(void *)(a1 + 248);
        v289 = 0;
        uint64_t v168 = *(void *)(a1 + 552);
        do
        {
          uint64_t v169 = (char *)v168;
          uint64_t v168 = *(void *)(v168 + 168);
        }
        while (v168);
        switch(v151)
        {
          case 16:
            *((_DWORD *)v169 + 3) = v149[4 * v147 + 3];
            break;
          case 17:
            *((_DWORD *)v169 + 4) = v149[4 * v147 + 3];
            break;
          case 18:
            *((_DWORD *)v169 + 2) = v149[4 * v147 + 3];
            break;
          case 19:
          case 21:
          case 22:
          case 23:
            break;
          case 20:
            *((_DWORD *)v169 + 6) = v149[4 * v147 + 3];
            break;
          case 24:
            *((_DWORD *)v169 + 1) = v149[4 * v147 + 3];
            break;
          case 25:
            *((_DWORD *)v169 + 5) = v149[4 * v147 + 3];
            break;
          default:
            if (v151 == 36)
            {
              paramc_ParamGetStr(*(void *)(v167 + 40), (uint64_t)"hasuserunknowninserted", &v289);
              if (v289 && !cstdlib_strcmp(v289, "yes"))
              {
                uint64_t v174 = v169 + 64;
                unint64_t v175 = v149[4 * v147 + 3];
              }
              else
              {
                uint64_t v174 = v169 + 64;
                unint64_t v175 = byte_2207887FC;
              }
              cstdlib_strcpy(v174, v175);
            }
            else if (v151 == 42)
            {
              cstdlib_strcpy((char *)__src, v149[4 * v147 + 3]);
              uint64_t v170 = cstdlib_strstr((char *)__src, ",");
              if (v170)
              {
                uint64_t v171 = v170;
                int v172 = v170 + 1;
                cstdlib_memset(__len, 0, 0x20uLL);
                cstdlib_strcpy(v169 + 32, v172);
                cstdlib_strncpy((char *)__len, (const char *)__src, v171 - (char *)__src);
                unsigned int v173 = LH_atou((const char *)__len);
              }
              else
              {
                cstdlib_strcpy(v169 + 32, byte_2207887FC);
                unsigned int v173 = 0;
              }
              *((_DWORD *)v169 + 7) = v173;
            }
            break;
        }
        if (*(_DWORD *)v169)
        {
          int v176 = (void *)heap_Alloc(*(void *)(*(void *)(a1 + 248) + 8), 176);
          *((void *)v169 + 21) = v176;
          if (v176)
          {
            uint64_t v181 = v176;
            cstdlib_memmove(v176, v169, 0xA8uLL);
            *(_DWORD *)uint64_t v181 = 0;
            v181[21] = 0;
          }
          else
          {
            log_OutPublic(*(void *)(v167 + 32), (uint64_t)"TTSEG", 16000, 0, v177, v178, v179, v180, v269);
          }
        }
      }
LABEL_209:
      ++v147;
    }
    while (v147 < v287);
  }
  uint64_t v182 = ttseg_loc_PutOutput_TAI((void *)a1, 1, v274);
  if ((v182 & 0x80000000) != 0)
  {
    uint64_t Str = v182;
    log_OutText(*(void *)(*(void *)(a1 + 248) + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Callback for TA Info Data returned error %x", v183, v184, v185, v182);
    goto LABEL_342;
  }
  uint64_t v186 = *(void *)(a1 + 472);
  if (v186)
  {
    heap_Free(*(void **)(*(void *)(a1 + 248) + 8), v186);
    *(void *)(a1 + 472) = 0;
    *(_DWORD *)(a1 + 480) = 0;
  }
  uint64_t v187 = *(void *)(a1 + 488);
  unint64_t v12 = v273;
  if (v187)
  {
    heap_Free(*(void **)(*(void *)(a1 + 248) + 8), v187);
    *(void *)(a1 + 488) = 0;
  }
  uint64_t Str = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 128) + 96))(*(void *)(a1 + 152), *(void *)(a1 + 160), (32 * v287));
  if ((Str & 0x80000000) == 0)
  {
    unsigned int v274 = 0;
    goto LABEL_247;
  }
  log_OutText(*(void *)(*(void *)(a1 + 248) + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Unreading markers returned error %x", a6, a7, a8, Str);
LABEL_337:
  if (a2 == 1) {
LABEL_338:
  }
    *(_WORD *)(a1 + 404) = v12;
  return Str;
}

uint64_t ttseg_loc_SynthesizeEnd(uint64_t a1, _DWORD *a2, unsigned int *a3)
{
  uint64_t v6 = *(void *)(a1 + 248);
  uint64_t v16 = 0;
  *a2 = *(_DWORD *)(a1 + 440);
  unsigned int v7 = *(_DWORD *)(a1 + 444);
  *a3 = v7;
  uint64_t v8 = *(void *)(a1 + 360);
  if (v8)
  {
    int v15 = 0;
    (*(void (**)(uint64_t, void, int *))(*(void *)(a1 + 128) + 136))(v8, *(void *)(a1 + 368), &v15);
    unsigned int v7 = *a3 + (8 * v15) / *(_DWORD *)(a1 + 264);
    *a3 = v7;
  }
  if (v7 > 0x418936) {
    unsigned int v9 = 1000 * (v7 / *(_DWORD *)(a1 + 260));
  }
  else {
    unsigned int v9 = 1000 * v7 / *(_DWORD *)(a1 + 260);
  }
  *a3 = v9;
  paramc_ParamSetStr(*(void *)(v6 + 40), (uint64_t)"component_stop", "yes");
  paramc_ParamSetStr(*(void *)(v6 + 40), (uint64_t)"component_stop_not_reset", "yes");
  if ((objc_GetObject(*(void *)(v6 + 48), (uint64_t)"CHARCOUNT", &v16) & 0x80000000) == 0)
  {
    (*(void (**)(void, void))(v16[1] + 64))(v16[2], v16[3]);
    objc_ReleaseObject(*(void *)(v6 + 48), (uint64_t)"CHARCOUNT");
  }
  return ttseg_loc_SynthesizeCleanup(a1, 0, *a2, *a3, v10, v11, v12, v13);
}

uint64_t ttseg_Speak(uint64_t a1, int a2, char *a3, char *a4)
{
  uint64_t v73 = 0;
  uint64_t v74 = 0;
  uint64_t v72 = 0;
  int v71 = 0;
  uint64_t v69 = 0;
  uint64_t v70 = 0;
  unsigned int v68 = 0;
  uint64_t v6 = ttseg_loc_BeginFunction(a1, a2, &v72, &v73);
  if ((v6 & 0x80000000) != 0) {
    return v6;
  }
  if (a3) {
    uint64_t v10 = a3;
  }
  else {
    uint64_t v10 = byte_2207887FC;
  }
  log_OutText(*(void *)(v72 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Speak : Begin (%s, %s)", v7, v8, v9, (uint64_t)v10);
  uint64_t v11 = v73;
  uint64_t v17 = ttseg_loc_LockFromIdle(v72, v73, (uint64_t)"ttseg_Speak", 3, &v71);
  if ((v17 & 0x80000000) == 0)
  {
    uint64_t v18 = *(void *)(v11 + 232);
    if (v18)
    {
      uint64_t v19 = *(void *)(v18 + 32);
      if (v19)
      {
        compstats_Reset(v19);
        compstats_Start(*(void *)(*(void *)(v11 + 232) + 32), *(void *)(*(void *)(v11 + 232) + 40), 0, v20, v21, v22, v23, v24);
      }
    }
    else
    {
      log_OutPublic(*(void *)(v72 + 32), (uint64_t)"TTSEG", 16043, 0, v13, v14, v15, v16, v63);
      uint64_t v17 = 2166366225;
    }
    if (*(_DWORD *)(*(void *)(v11 + 32) + 220) == 1 && !*(_DWORD *)(v11 + 196)) {
      uint64_t v17 = ttseg_loc_LicensingIncreaseInstanceCount(v72, v11);
    }
    if ((v17 & 0x80000000) == 0)
    {
      if (a3 && *a3)
      {
        uint64_t NullHandle = safeh_GetNullHandle();
        uint64_t v67 = v25;
        uint64_t v64 = safeh_GetNullHandle();
        uint64_t v65 = v26;
        brk_DataOpenEx(*(void *)(v72 + 24), (uint64_t)a3, 0, (uint64_t)&v70);
        if ((brk_DataMapEx(*(void *)(v72 + 24), v70, 0, (uint64_t)&v68, (uint64_t)&v69) & 0x80000000) != 0)
        {
          uint64_t v17 = 2166368256;
          log_OutPublic(*(void *)(v72 + 32), (uint64_t)"TTSEG", 16045, (uint64_t)"%s%s%s%x", v27, v28, v29, v30, "uri");
        }
        else if (v68)
        {
          int v31 = *(uint64_t (**)(uint64_t))(*(void *)(v11 + 128) + 32);
          uint64_t v32 = safeh_GetNullHandle();
          uint64_t v33 = v31(v32);
          if ((v33 & 0x80000000) != 0)
          {
            uint64_t v17 = v33;
            log_OutPublic(*(void *)(v72 + 32), (uint64_t)"TTSEG", 16014, (uint64_t)"%s%x", v34, v35, v36, v37, "lherror");
          }
          else
          {
            uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, char *, void, uint64_t, uint64_t *))(*(void *)(v11 + 128) + 64))(NullHandle, v67, 18, a4, 0, 2, &v64);
            if ((v38 & 0x80000000) != 0)
            {
              uint64_t v17 = v38;
              log_OutPublic(*(void *)(v72 + 32), (uint64_t)"TTSEG", 16016, (uint64_t)"%s%s%s%x", v39, v40, v41, v42, "contentType");
            }
            else
            {
              uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)(v11 + 128) + 104))(v64, v65, v69, v68);
              if ((v17 & 0x80000000) != 0) {
                log_OutPublic(*(void *)(v72 + 32), (uint64_t)"TTSEG", 16125, (uint64_t)"%s%s%s%x", v13, v14, v15, v16, "contentType");
              }
            }
          }
        }
        else
        {
          uint64_t v17 = 2166368256;
          log_OutPublic(*(void *)(v72 + 32), (uint64_t)"TTSEG", 16047, (uint64_t)"%s%s", v27, v28, v29, v30, "uri");
        }
        if (v64) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)(v11 + 128) + 72))(v64, v65);
        }
        if ((v17 & 0x80000000) == 0)
        {
          uint64_t v52 = v72;
          uint64_t v53 = safeh_GetNullHandle();
          uint64_t v17 = ttseg_loc_Synthesize(v52, v11, 0, 0, a4, 0, 0, v55, NullHandle, v67, v53, v54, (_DWORD *)&v74 + 1, (unsigned int *)&v74);
        }
        if (NullHandle) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)(v11 + 128) + 40))(NullHandle, v67);
        }
      }
      else
      {
        uint64_t v43 = v72;
        uint64_t v44 = *(uint64_t (**)(uint64_t, unsigned int *, unsigned char *))(v11 + 40);
        uint64_t v45 = *(void *)(v11 + 88);
        uint64_t v46 = safeh_GetNullHandle();
        uint64_t v48 = v47;
        uint64_t v49 = safeh_GetNullHandle();
        uint64_t v17 = ttseg_loc_Synthesize(v43, v11, v44, v45, a4, 0, 0, v51, v46, v48, v49, v50, (_DWORD *)&v74 + 1, (unsigned int *)&v74);
      }
    }
    if (*(_DWORD *)(*(void *)(v11 + 32) + 220) == 1 && *(_DWORD *)(v11 + 196) == 1)
    {
      int v56 = ttseg_loc_LicensingDecreaseInstanceCount(v72, v11);
      if (v56 >= 0) {
        uint64_t v17 = v17;
      }
      else {
        uint64_t v17 = v56;
      }
    }
    if (v18)
    {
      uint64_t v57 = *(void *)(v11 + 232);
      uint64_t v58 = *(void *)(v57 + 32);
      if (v58)
      {
        compstats_Stop(v58, *(void *)(v57 + 40), 0, v12, v13, v14, v15, v16);
        compstats_Log(*(void *)(*(void *)(v11 + 232) + 32), *(void *)(*(void *)(v11 + 232) + 40), *(void *)(v72 + 32), "Synthesis", *(void *)(*(void *)(v11 + 232) + 48), SHIDWORD(v74), v74);
      }
    }
    ttseg_loc_Unlock(v72, v11, v71);
    log_OutText(*(void *)(v72 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Speak : End (%x)", v59, v60, v61, v17);
    if (v69)
    {
      brk_DataUnmap(*(void *)(v72 + 24), v70, v69);
      uint64_t v69 = 0;
    }
    if (v70) {
      brk_DataClose(*(void *)(v72 + 24), v70);
    }
  }
  return v17;
}

uint64_t ttseg_loc_LicensingDecreaseInstanceCount(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 196)) {
    return 2166366208;
  }
  unsigned int v4 = *(_DWORD *)(a2 + 192);
  uint64_t v9 = critsec_Enter(*(void **)(*(void *)(a2 + 32) + 208));
  if ((v9 & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16112, (uint64_t)"%s%s%s%x", v5, v6, v7, v8, "function");
  }
  else
  {
    if (v4 <= 2)
    {
      if (*(_DWORD *)(a2 + 196) == 1)
      {
        uint64_t v10 = *(void *)(a2 + 32);
        uint64_t v11 = v10 + 24 * v4;
        int v14 = *(_DWORD *)(v11 + 124);
        uint64_t v12 = (_DWORD *)(v11 + 124);
        int v13 = v14;
        if (v14)
        {
          *uint64_t v12 = v13 - 1;
          log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG License is released: total ports=%lu,  acquired ports=%lu", v6, v7, v8, *(unsigned int *)(v10 + 24 * v4 + 116));
        }
      }
      else if (SWIlicense_inhibited == 1)
      {
        if (num_used_SWI_licenses) {
          --num_used_SWI_licenses;
        }
      }
      else
      {
        SWIlicenseFreeCacheableLicense();
      }
      ttseg_loc_LicenseLog((uint64_t **)a1, *(void *)(a2 + 32), v4, 6);
      *(_DWORD *)(a2 + 196) = 0;
    }
    critsec_Leave(*(void **)(*(void *)(a2 + 32) + 208));
  }
  return v9;
}

uint64_t ttseg_Break(uint64_t a1, int a2)
{
  uint64_t v21 = 0;
  uint64_t v20 = 0;
  uint64_t v2 = ttseg_loc_BeginFunction(a1, a2, &v20, &v21);
  if ((v2 & 0x80000000) != 0) {
    return v2;
  }
  log_OutText(*(void *)(v20 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Break : Begin", v3, v4, v5, v18);
  uint64_t v6 = v21;
  uint64_t v11 = critsec_Enter(*(void **)(v21 + 96));
  if ((v11 & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(v20 + 32), (uint64_t)"TTSEG", 16004, (uint64_t)"%s%s%s%x", v7, v8, v9, v10, "function");
  }
  else
  {
    if ((*(_DWORD *)(v6 + 104) - 3) > 1)
    {
      log_OutText(*(void *)(v20 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Break : not speaking", v8, v9, v10, v19);
      LODWORD(v11) = -2128601071;
    }
    else
    {
      *(_DWORD *)(v6 + 104) = 6;
      if (*(void *)(v6 + 216)) {
        ssftthrottle_Stop();
      }
    }
    int v15 = critsec_Leave(*(void **)(v6 + 96));
    if (v15 >= 0 || (int)v11 <= -1) {
      uint64_t v11 = v11;
    }
    else {
      uint64_t v11 = v15;
    }
  }
  log_OutText(*(void *)(v20 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Break : End (%x)", v12, v13, v14, v11);
  return v11;
}

uint64_t ttseg_GetProductList(void *a1, int a2, uint64_t a3, char *a4, int *a5)
{
  uint64_t v20 = 0;
  uint64_t v7 = ttseg_loc_CheckClassHandle(a1, a2, &v20, &v21);
  if ((v7 & 0x80000000) != 0) {
    return 2166366216;
  }
  uint64_t v11 = v7;
  log_OutText(*(void *)(v20 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Product List : Begin", v8, v9, v10, v18);
  if (a5)
  {
    int v16 = *a5;
    *a5 = 1;
    if (a4 && v16)
    {
      __sprintf_chk(a4, 0, 0x40uLL, "Vocalizer v%d.%d", 7, 4);
      cstdlib_strcpy(a4 + 64, "eng/vocalizer");
      sprintf(a4 + 96, "%d.%d.%d", 7, 4, 0);
    }
    log_OutText(*(void *)(v20 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Product List : End (%x, %u)", v13, v14, v15, v11);
  }
  else
  {
    log_OutPublic(*(void *)(v20 + 32), (uint64_t)"TTSEG", 16054, 0, v12, v13, v14, v15, v19);
    return 2166366215;
  }
  return v11;
}

uint64_t ttseg_GetLanguageList(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v9 = 2166366209;
  if ((ttseg_loc_CheckClassHandle(a1, a2, &v19, &v20) & 0x80000000) != 0) {
    return 2166366216;
  }
  uint64_t v13 = a3 + 64;
  log_OutText(*(void *)(v19 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Language List : Begin (%s)", v10, v11, v12, v13);
  uint64_t v17 = v20[4];
  if (v17) {
    uint64_t v9 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t))(v17 + 64))(v20[5], v20[6], v13, a5, a6);
  }
  log_OutText(*(void *)(v19 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Language List : End (%x, %u)", v14, v15, v16, v9);
  return v9;
}

uint64_t ttseg_GetVoiceList(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v11 = 2166366209;
  if ((ttseg_loc_CheckClassHandle(a1, a2, &v21, &v22) & 0x80000000) != 0) {
    return 2166366216;
  }
  uint64_t v15 = a3 + 64;
  log_OutText(*(void *)(v21 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Voice List : Begin (%s, %s)", v12, v13, v14, v15);
  uint64_t v19 = v22[4];
  if (v19) {
    uint64_t v11 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 72))(v22[5], v22[6], v15, a4, a6, a7);
  }
  log_OutText(*(void *)(v21 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Voice List : End (%x, %u)", v16, v17, v18, v11);
  return v11;
}

uint64_t ttseg_GetDocTypeList(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v11 = 2166366209;
  if ((ttseg_loc_CheckClassHandle(a1, a2, &v21, &v22) & 0x80000000) != 0) {
    return 2166366216;
  }
  uint64_t v15 = a3 + 64;
  log_OutText(*(void *)(v21 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Document List : Begin (%s, %s)", v12, v13, v14, v15);
  uint64_t v19 = v22[4];
  if (v19) {
    uint64_t v11 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 80))(v22[5], v22[6], v15, a4, a6, a7);
  }
  log_OutText(*(void *)(v21 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Document List : End (%x, %u)", v16, v17, v18, v11);
  return v11;
}

uint64_t ttseg_GetSpeechDBList(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v13 = 2166366209;
  if ((ttseg_loc_CheckClassHandle(a1, a2, &v23, &v24) & 0x80000000) != 0) {
    return 2166366216;
  }
  uint64_t v17 = a3 + 64;
  log_OutText(*(void *)(v23 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Speech DB List : Begin (%s, %s, %s)", v14, v15, v16, v17);
  uint64_t v21 = v24[4];
  if (v21) {
    uint64_t v13 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v21 + 88))(v24[5], v24[6], v17, a4, a5, a7, a8);
  }
  log_OutText(*(void *)(v23 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Speech DB List : End (%x, %u)", v18, v19, v20, v13);
  return v13;
}

uint64_t ttseg_GetLicenseAppType(void *a1, int a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t result = ttseg_loc_CheckClassHandle(a1, a2, &v7, &v8);
  if ((result & 0x80000000) != 0) {
    return 2166366216;
  }
  if (a3) {
    *a3 = *(_DWORD *)(v8 + 224);
  }
  if (a4) {
    *a4 = *(_DWORD *)(v8 + 228);
  }
  return result;
}

uint64_t ttseg_SetTTSLicensePorts(void *a1, int a2, int a3)
{
  uint64_t v4 = 2166366215;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  if ((ttseg_loc_CheckClassHandle(a1, a2, &v39, &v40) & 0x80000000) != 0) {
    return 2166366216;
  }
  uint64_t v6 = v39;
  uint64_t v5 = v40;
  int v41 = 0;
  uint64_t v11 = critsec_Enter(*(void **)(v40 + 208));
  if ((v11 & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(v6 + 32), (uint64_t)"TTSEG", 16112, (uint64_t)"%s%s%s%x", v7, v8, v9, v10, "function");
    return v11;
  }
  unsigned int v12 = *(_DWORD *)(v5 + 116);
  if (v12 == a3) {
    goto LABEL_18;
  }
  if (v12 > a3)
  {
    ttseg_loc_LicenseLog((uint64_t **)v6, v5, 0, 11);
    if ((SWIlicense_inhibited & 1) == 0 && SWIlicenseUnlock())
    {
      log_OutText(*(void *)(v6 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG SWIlicenseUnlock failed", v13, v14, v15, v37);
      uint64_t v11 = 2166373642;
    }
    *(_DWORD *)(v5 + 116) = 0;
  }
  if (!a3 || (v11 & 0x80000000) != 0) {
    goto LABEL_18;
  }
  int v16 = *(_DWORD *)(v5 + 112);
  int v17 = *(_DWORD *)(v5 + 128);
  if (SWIlicense_inhibited == 1)
  {
    int v41 = a3;
    int v18 = v17;
    int v19 = a3;
    goto LABEL_13;
  }
  if ((SWIlicenseLockMulti(0, g_SWIlicenseFeatureTTSOpt[*(unsigned int *)(v5 + 224)], a3, &v41) & 0xFFFFFFFB) != 0)
  {
    uint64_t v4 = 2166373638;
    *(_DWORD *)(v5 + 116) = 0;
    goto LABEL_19;
  }
  int v19 = v41;
  if (v41 < a3)
  {
    log_OutPublic(*(void *)(v6 + 32), (uint64_t)"TTSEG", 16118, (uint64_t)"%s%u%s%u", v23, v24, v25, v26, "requiredPorts");
    if (!*(_DWORD *)(v5 + 116)) {
      goto LABEL_19;
    }
    ttseg_loc_LicenseLog((uint64_t **)v6, v5, 0, 11);
    if (SWIlicense_inhibited == 1)
    {
      int v27 = *(_DWORD *)(v5 + 116);
LABEL_29:
      int v41 = v27;
LABEL_30:
      ttseg_loc_LicenseLog((uint64_t **)v6, v5, 0, 10);
      if (v41 < *(_DWORD *)(v5 + 116))
      {
        uint64_t v4 = 2166373638;
        log_OutPublic(*(void *)(v6 + 32), (uint64_t)"TTSEG", 16118, (uint64_t)"%s%u%s%u", v28, v29, v30, v31, "requiredPorts");
        ttseg_loc_LicenseLog((uint64_t **)v6, v5, 0, 11);
        if ((SWIlicense_inhibited & 1) == 0) {
          SWIlicenseUnlock();
        }
      }
      goto LABEL_19;
    }
    if (SWIlicenseUnlock())
    {
      uint64_t v35 = *(void *)(v6 + 32);
      uint64_t v36 = "TTSEG SWIlicenseUnlock failed";
    }
    else
    {
      int v27 = *(_DWORD *)(v5 + 116);
      if (SWIlicense_inhibited == 1) {
        goto LABEL_29;
      }
      if ((SWIlicenseLockMulti(0, g_SWIlicenseFeatureTTSOpt[*(unsigned int *)(v5 + 224)], v27, &v41) & 0xFFFFFFFB) == 0) {
        goto LABEL_30;
      }
      uint64_t v35 = *(void *)(v6 + 32);
      uint64_t v36 = "TTSEG SWIlicenseLockMulti failed";
    }
    log_OutText(v35, (uint64_t)"TTSEG", 4, 0, (uint64_t)v36, v32, v33, v34, v38);
    uint64_t v4 = 2166373642;
    goto LABEL_19;
  }
  int v18 = *(_DWORD *)(v5 + 128);
LABEL_13:
  *(_DWORD *)(v5 + 112) = a3;
  *(_DWORD *)(v5 + 116) = v19;
  unsigned int v20 = v18 + a3;
  unsigned int v21 = *(_DWORD *)(v5 + 120);
  if (!v21 || v21 == v17 + v16 || v21 > v20) {
    *(_DWORD *)(v5 + 120) = v20;
  }
  ttseg_loc_LicenseLog((uint64_t **)v6, v5, 0, 10);
LABEL_18:
  uint64_t v4 = v11;
LABEL_19:
  critsec_Leave(*(void **)(v5 + 208));
  return v4;
}

uint64_t ttseg_GetTTSProductVersion(unsigned char *a1, unsigned char *a2, unsigned char *a3)
{
  *a1 = 24;
  *a2 = 8;
  *a3 = 0;
  return 0;
}

uint64_t ttseg_loc_CompileRegex(uint64_t a1, uint64_t a2, int a3, char *a4, uint64_t *a5)
{
  uint64_t v15 = 0;
  int v14 = 0;
  uint64_t v7 = nuance_pcre_compile(a2, a3, a4, 2048, &v15, &v14, 0);
  if (v7)
  {
    uint64_t v12 = v7;
    uint64_t result = 0;
    *a5 = v12;
  }
  else
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16128, (uint64_t)"%s%s%s%s%x", v8, v9, v10, v11, "function");
    return 2166366226;
  }
  return result;
}

uint64_t ttseg_ParseTRConfigFile(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, unsigned __int16 *a6)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  *(void *)&__n[1] = a4;
  __n[0] = a5;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v40 = 0;
  int v41 = 0;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v10 = ttseg_loc_BeginFunction(a1, a2, &v44, &v45);
  if ((v10 & 0x80000000) != 0) {
    return v10;
  }
  if (a3 || (uint64_t v11 = 2166366215, a4) && a5)
  {
    uint64_t v10 = nuance_pcre_ObjOpen(*(_WORD **)v45, *(void *)(v45 + 8), (uint64_t)&v41);
    if ((v10 & 0x80000000) == 0)
    {
      uint64_t v12 = nuance_pcre_Init(v41, v42, 0xAu, 10);
      if ((v12 & 0x80000000) != 0)
      {
        uint64_t v11 = v12;
LABEL_29:
        nuance_pcre_ObjClose((uint64_t)v41, v42);
        return v11;
      }
      uint64_t v13 = ttseg_loc_CompileRegex(v44, (uint64_t)v41, v42, "version=([0-9\\.]+)", &v40);
      if ((v13 & 0x80000000) == 0)
      {
        uint64_t v13 = ttseg_loc_CompileRegex(v44, (uint64_t)v41, v42, "mimetype=\"([a-z-\\+;=/]+)\"", &v39);
        if ((v13 & 0x80000000) == 0)
        {
          uint64_t v13 = ttseg_loc_CompileRegex(v44, (uint64_t)v41, v42, "file=\"([^\"]+)\"", &v38);
          if ((v13 & 0x80000000) == 0)
          {
            if (!a3) {
              goto LABEL_32;
            }
            if (!*(unsigned char *)a3)
            {
              a3 = 0;
              goto LABEL_32;
            }
            uint64_t v13 = brk_DataOpenEx(*(void *)(v44 + 24), a3, 0, (uint64_t)&v43);
            if ((v13 & 0x80000000) == 0)
            {
              a3 = brk_DataMapEx(*(void *)(v44 + 24), v43, 0, (uint64_t)__n, (uint64_t)&__n[1]);
              uint64_t v11 = a3;
              if ((a3 & 0x80000000) != 0) {
                goto LABEL_17;
              }
LABEL_32:
              uint64_t v11 = 2166366218;
              uint64_t v15 = (char *)heap_Calloc(*(void **)(v44 + 8), (__n[0] + 1), 1);
              if (v15)
              {
                int v16 = v15;
                cstdlib_memcpy(v15, *(const void **)&__n[1], __n[0]);
                if (cstdlib_strlen(v16))
                {
                  size_t v21 = 0;
                  int v22 = 0;
                  uint64_t v23 = v40;
                  unsigned int v24 = 1;
                  uint64_t v36 = v38;
                  uint64_t v37 = v39;
                  while (a6[6] <= 0x7Fu)
                  {
                    int v25 = v22 + 1;
                    __s[v22] = v16[v21];
                    if (v22 == 1023) {
                      goto LABEL_51;
                    }
                    size_t v21 = v24;
                    if (v16[v24] == 10 || cstdlib_strlen(v16) == v24)
                    {
                      __s[v25] = 0;
                      int v26 = cstdlib_strlen(__s);
                      if (nuance_pcre_exec(v41, v42, v23, 0, __s, v26, 0, 0, &v47, 256) == 2)
                      {
                        uint64_t v27 = v49 - (uint64_t)v48;
                        if ((int)v27 > 10)
                        {
LABEL_51:
                          uint64_t v35 = 2166366223;
                          goto LABEL_54;
                        }
                        cstdlib_memcpy(a6, &__s[v48], v27);
                        int v25 = 0;
                        *((unsigned char *)a6 + v27 + 1) = 0;
                      }
                      else
                      {
                        int v28 = cstdlib_strlen(__s);
                        if (nuance_pcre_exec(v41, v42, v37, 0, __s, v28, 0, 0, &v47, 256) != 2) {
                          goto LABEL_52;
                        }
                        size_t v29 = (v49 - v48);
                        uint64_t v30 = (void *)heap_Calloc(*(void **)(v44 + 8), (v29 + 1), 1);
                        *(void *)&a6[4 * a6[6] + 8] = v30;
                        if (!v30) {
                          goto LABEL_53;
                        }
                        cstdlib_memcpy(v30, &__s[v48], v29);
                        int v31 = cstdlib_strlen(__s);
                        if (nuance_pcre_exec(v41, v42, v36, 0, __s, v31, 0, 0, &v47, 256) != 2)
                        {
LABEL_52:
                          uint64_t v35 = 2166366228;
                          goto LABEL_54;
                        }
                        size_t v32 = (v49 - v48);
                        uint64_t v33 = (void *)heap_Calloc(*(void **)(v44 + 8), (v32 + 1), 1);
                        *(void *)&a6[4 * a6[6] + 520] = v33;
                        if (!v33)
                        {
LABEL_53:
                          uint64_t v35 = 2166366218;
                          goto LABEL_54;
                        }
                        cstdlib_memcpy(v33, &__s[v48], v32);
                        int v25 = 0;
                        ++a6[6];
                      }
                    }
                    size_t v34 = cstdlib_strlen(v16);
                    ++v24;
                    int v22 = v25;
                    if (v34 <= v21) {
                      break;
                    }
                  }
                }
                if (a6[6] == 128)
                {
                  uint64_t v35 = a3;
                  log_OutPublic(*(void *)(v44 + 32), (uint64_t)"TTSEG", 16129, (uint64_t)"%s%s%s%x", v17, v18, v19, v20, "function");
                }
                else
                {
                  uint64_t v35 = a3;
                }
LABEL_54:
                heap_Free(*(void **)(v44 + 8), (uint64_t)v16);
                uint64_t v11 = v35;
              }
              goto LABEL_17;
            }
          }
        }
      }
      uint64_t v11 = v13;
LABEL_17:
      if (v40) {
        heap_Free(*(void **)(v44 + 8), v40);
      }
      if (v39) {
        heap_Free(*(void **)(v44 + 8), v39);
      }
      if (v38) {
        heap_Free(*(void **)(v44 + 8), v38);
      }
      if (*(void *)&__n[1])
      {
        brk_DataUnmap(*(void *)(v44 + 24), v43, *(uint64_t *)&__n[1]);
        *(void *)&__n[1] = 0;
      }
      if (v43)
      {
        brk_DataClose(*(void *)(v44 + 24), v43);
        uint64_t v43 = 0;
      }
      nuance_pcre_DeInit(v41, v42);
      goto LABEL_29;
    }
    return v10;
  }
  return v11;
}

uint64_t ttseg_ParseTRConfigFileDestroy(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v8 = 0;
  uint64_t v4 = ttseg_loc_BeginFunction(a1, a2, &v8, &v9);
  if ((v4 & 0x80000000) == 0 && *(_WORD *)(a3 + 12))
  {
    unint64_t v5 = 0;
    do
    {
      uint64_t v6 = a3 + 8 * v5;
      heap_Free(*(void **)(v8 + 8), *(void *)(v6 + 1040));
      heap_Free(*(void **)(v8 + 8), *(void *)(v6 + 16));
      ++v5;
    }
    while (v5 < *(unsigned __int16 *)(a3 + 12));
  }
  return v4;
}

BOOL ttseg_loc_check_vns(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v9 = 0;
  if ((paramc_ParamGetStr(a1, (uint64_t)"txm ypy hwb &53(1@+- _={[]?/>.<,", &v9) & 0x80000000) != 0 || !v9)
    return 0;
  cstdlib_memset(__b, 0, 0x64uLL);
  cstdlib_strcpy(__dst, "key");
  uint64_t v1 = v9;
  int v2 = cstdlib_strlen(__dst);
  uint64_t v3 = cstdlib_strlen(v1);
  if (v3)
  {
    unsigned int v4 = 0;
    unint64_t v5 = __b;
    do
    {
      char v6 = *v1++;
      *v5++ = __dst[v4] ^ v6;
      if (v4 < v2 - 1) {
        ++v4;
      }
      else {
        unsigned int v4 = 0;
      }
      --v3;
    }
    while (v3);
  }
  return !LH_stricmp(__b, "4:\x014CS5]@AJGW^CL\x1E\"\x168&9\x17\v\x18\x11\x0E\x1A\x04\x184");
}

uint64_t **ttseg_loc_LicenseLog(uint64_t **result, uint64_t a2, int a3, uint64_t a4)
{
  char v6 = result;
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (a3)
  {
    if (a3 != 1) {
      return result;
    }
    uint64_t v7 = "cpr";
  }
  else
  {
    uint64_t v7 = "tts";
  }
  cstdlib_strcpy(__dst, v7);
  if (!*(_DWORD *)(a2 + 216)) {
    cstdlib_strcat(__dst, ",unthrottled");
  }
  uint64_t v13 = (uint64_t **)v6[4];
  if ((SWIlicense_inhibited & 1) == 0) {
    SWIlicenseGetNumOfLicensesInUseInCache();
  }
  return log_OutEvent(v13, a4, (uint64_t)"%s%u%s%u%s%u%s%s", v8, v9, v10, v11, v12, "LUSED");
}

void *DeinitLoadedCupList(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(void *)(a2 + 8);
    if (v4)
    {
      if (*(void *)(v4 + 8))
      {
        heap_Free(result, *(void *)(v4 + 8));
        uint64_t v4 = *(void *)(a2 + 8);
      }
      heap_Free(v3, v4);
    }
    return heap_Free(v3, a2);
  }
  return result;
}

void *ttseg_loc_RemoveTaInfo(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 248);
  uint64_t v3 = *(void *)(a1 + 552);
  uint64_t v4 = *(void *)(v3 + 168);
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 552);
    do
    {
      do
      {
        uint64_t v6 = v5;
        uint64_t v5 = v4;
        uint64_t v4 = *(void *)(v4 + 168);
      }
      while (v4);
      *(void *)(v6 + 168) = 0;
      heap_Free(*(void **)(v2 + 8), v5);
      uint64_t v4 = *(void *)(v3 + 168);
      uint64_t v5 = v3;
    }
    while (v4);
    uint64_t v3 = *(void *)(a1 + 552);
  }
  uint64_t result = heap_Free(*(void **)(v2 + 8), v3);
  *(void *)(a1 + 552) = 0;
  return result;
}

uint64_t ObjcLoadCup(_WORD *a1, int a2, char *a3, uint64_t a4)
{
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v19);
  if ((inited & 0x80000000) != 0)
  {
    uint64_t v10 = inited;
  }
  else
  {
    uint64_t v9 = brk_RegisterCupAddon(*(void *)(v19 + 24), (uint64_t)a3, (uint64_t)&v18, (uint64_t)&v17);
    if ((v9 & 0x80000000) != 0)
    {
      uint64_t v10 = v9;
      if (v18)
      {
LABEL_12:
        if (v17) {
          brk_UnregisterCupAddon(*(uint64_t **)(v19 + 24), (uint64_t)a3);
        }
      }
    }
    else
    {
      uint64_t v10 = cupreader_open(a1, a2, v18, &v20);
      if ((v10 & 0x80000000) == 0)
      {
        v20[7] = v17;
        uint64_t v11 = (char *)strhelper_Strdup(*(void *)(v19 + 8), a3);
        uint64_t v12 = v20;
        v20[8] = (uint64_t)v11;
        if (v11)
        {
          uint64_t v13 = UriToBrokerString(*(void **)(v19 + 8), v11);
          uint64_t v12 = v20;
          v20[9] = (uint64_t)v13;
          if (v13) {
            uint64_t v10 = v10;
          }
          else {
            uint64_t v10 = 10;
          }
        }
        else
        {
          uint64_t v10 = 10;
        }
        *(void *)(a4 + 32) = v12;
        return v10;
      }
      if (v18) {
        goto LABEL_12;
      }
    }
  }
  int v14 = v20;
  if (v20)
  {
    uint64_t v15 = v20[8];
    if (v15)
    {
      heap_Free(*(void **)(v19 + 8), v15);
      int v14 = v20;
    }
    cupreader_close(a1, a2, (uint64_t)v14);
  }
  return v10;
}

uint64_t ObjcUnloadCup(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v11 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v11);
  if ((inited & 0x80000000) == 0)
  {
    uint64_t v7 = *(void *)(a3 + 32);
    if (v7)
    {
      uint64_t inited = brk_UnregisterCupAddon(*(uint64_t **)(v11 + 24), *(void *)(v7 + 64));
      if ((inited & 0x80000000) == 0)
      {
        uint64_t v8 = *(void *)(v7 + 72);
        if (v8) {
          heap_Free(*(void **)(v11 + 8), v8);
        }
        uint64_t v9 = *(void *)(v7 + 64);
        if (v9) {
          heap_Free(*(void **)(v11 + 8), v9);
        }
        cupreader_close(a1, a2, v7);
      }
    }
  }
  return inited;
}

uint64_t ttseg_loc_ProcessStart(uint64_t a1, uint64_t (*a2)(uint64_t, void, void, void), uint64_t a3, int a4, unsigned int a5)
{
  LODWORD(v6) = a4;
  uint64_t v9 = *(uint64_t **)(a1 + 248);
  uint64_t v10 = (char *)(a1 + 508);
  cstdlib_strcpy((char *)(a1 + 508), byte_2207887FC);
  *(_DWORD *)(a1 + 540) = 0;
  if (log_HasTraceTuningDataSubscriber(v9[4]))
  {
    uint64_t v11 = v9[4];
    uint64_t v12 = (*(uint64_t (**)(void))(*(void *)(a1 + 128) + 152))();
    log_OutTraceTuningDataBinary(v11, 400, 0, 0, v12, 0);
  }
  if (*(_DWORD *)(a1 + 240) == 2)
  {
    uint64_t v13 = *(void *)(a1 + 232);
    if (*(_WORD *)(v13 + 24))
    {
      unint64_t v14 = 0;
      do
      {
        if (ttseg_loc_ComponentIsTextParser(*(const char **)(*(void *)(*(void *)(v13 + 16) + 8 * v14) + 8)))
        {
          *(_WORD *)(a1 + 540) = v14;
          if (cstdlib_strcmp(*(const char **)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v14 + 24) + 8), "fe/fe_lid"))
          {
            __int16 v15 = 2;
          }
          else
          {
            __int16 v15 = 3;
          }
          unsigned __int16 v16 = v14 + v15;
          *(_WORD *)(a1 + 542) = v16;
          cstdlib_strcpy(v10, *(const char **)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v16 + 8) + 8));
        }
        ++v14;
        uint64_t v13 = *(void *)(a1 + 232);
      }
      while (v14 < *(unsigned __int16 *)(v13 + 24));
    }
  }
  if (v6 >= a5)
  {
    uint64_t v35 = 0;
LABEL_30:
    if (*(_DWORD *)(a1 + 240) == 2)
    {
      *(void *)(a1 + 496) = 0;
      *(_DWORD *)(a1 + 504) = 0;
      if (*(void *)(a1 + 552)) {
        ttseg_loc_RemoveTaInfo(a1);
      }
      uint64_t v38 = (void *)heap_Alloc(v9[1], 176);
      *(void *)(a1 + 552) = v38;
      if (v38)
      {
        cstdlib_memset(v38, 0, 0xB0uLL);
        uint64_t v43 = *(void *)(a1 + 552);
        *(int32x2_t *)(v43 + 20) = vdup_n_s32(0x270Fu);
        *(_DWORD *)(v43 + 28) = 0;
        *(_OWORD *)uint64_t v43 = xmmword_220788780;
        *(void *)(v43 + 168) = 0;
      }
      else
      {
        log_OutPublic(v9[4], (uint64_t)"TTSEG", 16000, 0, v39, v40, v41, v42, v45);
        uint64_t v35 = 2166366218;
      }
    }
    paramc_ParamSetUInt(v9[5], (uint64_t)"feedback-amount-of-output-msecs-for-this-speakrequest", 0);
  }
  else
  {
    uint64_t v6 = v6;
    while (1)
    {
      unint64_t v17 = v6 + 1;
      (*(void (**)(void, void, void))(*(void *)(a1 + 128) + 56))(*(void *)(a1 + 272), *(void *)(a1 + 280), (unsigned __int16)(v6 + 1));
      log_OutText(v9[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Calling ProcessStart for %s", v18, v19, v20, *(void *)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v6) + 8));
      uint64_t v26 = *(void *)(a1 + 232);
      uint64_t v27 = *(void *)(v26 + 32);
      if (v27) {
        compstats_Start(v27, *(void *)(v26 + 40), (v6 + 2), v21, v22, v23, v24, v25);
      }
      if (*(_DWORD *)(a1 + 240) == 2)
      {
        if (!cstdlib_strcmp(*(const char **)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v6) + 8), v10))
        {
          uint64_t v28 = (*(uint64_t (**)(void, void, uint64_t, const char *, void, void, uint64_t))(*(void *)(a1 + 128) + 64))(*(void *)(a1 + 272), *(void *)(a1 + 280), 18, "application/x-realspeak-markers-pp;version=4.0",
                  0,
                  0,
                  a1 + 152);
          if ((v28 & 0x80000000) != 0) {
            return v28;
          }
        }
        if (ttseg_loc_ComponentIsTextParser(*(const char **)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16)
                                                                        + 8 * v6)
                                                            + 8)))
        {
          uint64_t v28 = (*(uint64_t (**)(void, void, uint64_t, const char *, void, void, uint64_t))(*(void *)(a1 + 128) + 64))(*(void *)(a1 + 272), *(void *)(a1 + 280), 18, "text/plain;charset=utf-8",
                  0,
                  0,
                  a1 + 136);
          *(_DWORD *)(a1 + 464) = 0;
          if ((v28 & 0x80000000) != 0) {
            return v28;
          }
        }
      }
      size_t v29 = *(void **)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v6);
      uint64_t v35 = (*(uint64_t (**)(void, void, void, void))(v29[2] + 96))(v29[3], v29[4], *(void *)(a1 + 272), *(void *)(a1 + 280));
      uint64_t v36 = *(void *)(a1 + 232);
      uint64_t v37 = *(void *)(v36 + 32);
      if (v37) {
        compstats_Stop(v37, *(void *)(v36 + 40), (v6 + 2), v30, v31, v32, v33, v34);
      }
      if ((v35 & 0x80000000) != 0)
      {
        log_OutPublic(v9[4], (uint64_t)"TTSEG", 16017, (uint64_t)"%s%s%s%x", v31, v32, v33, v34, "component");
        return v35;
      }
      *(_WORD *)(a1 + 396) = v17;
      if (a2) {
        uint64_t v35 = a2(a3, *(void *)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v6) + 8), *(void *)(a1 + 272), *(void *)(a1 + 280));
      }
      if ((v35 & 0x80000000) == 0)
      {
        ++v6;
        if (v17 < a5) {
          continue;
        }
      }
      goto LABEL_30;
    }
  }
  return v35;
}

uint64_t ttseg_loc_OpenOutputStreams(void *a1)
{
  uint64_t v1 = a1[31];
  uint64_t v7 = 0;
  if (!a1[6]) {
    return 0;
  }
  uint64_t v3 = (*(uint64_t (**)(void, void, void))(a1[16] + 56))(a1[34], a1[35], (unsigned __int16)(*(_WORD *)(a1[29] + 24) + 1));
  if ((v3 & 0x80000000) == 0)
  {
    int Str = paramc_ParamGetStr(*(void *)(v1 + 40), (uint64_t)"audiooutputmimetype", &v7);
    uint64_t v5 = v7;
    if ((Str & 0x80000000) == 0 && v7)
    {
      if (*v7
        && ((*(uint64_t (**)(void, void, uint64_t, unsigned char *, void, void, void *))(a1[16] + 64))(a1[34], a1[35], 18, v7, 0, 0, a1 + 45) & 0x80000000) == 0)
      {
        (*(void (**)(void, void, uint64_t, const char *, void, void, void *))(a1[16] + 64))(a1[34], a1[35], 18, "application/x-realspeak-markers-pp;version=4.0",
          0,
          0,
          a1 + 47);
      }
      uint64_t v5 = v7;
    }
    if (v5) {
      paramc_ParamRelease(*(void *)(v1 + 40));
    }
  }
  return v3;
}

uint64_t ttseg_loc_GetInputIntoStream(uint64_t a1, uint64_t (*a2)(uint64_t, unsigned int *, unsigned char *), uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  uint64_t v14 = 2166366215;
  unsigned int v33 = 1024;
  if (a6)
  {
    compstats_Start(a6, a7, 1, a4, (uint64_t)a5, a6, a7, (uint64_t)a8);
    if (!a2) {
      return v14;
    }
    uint64_t v14 = a2(a3, &v33, v34);
    compstats_Stop(a6, a7, 1, v17, v18, v19, v20, v21);
  }
  else
  {
    if (!a2) {
      return v14;
    }
    uint64_t v14 = a2(a3, &v33, v34);
  }
  log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"pfGetInput returned %lu bytes, %x", v22, v23, v24, v33);
  if ((v14 & 0x1FFF) == 5 || (v14 & 0x1FFF) == 3)
  {
LABEL_12:
    (*(void (**)(uint64_t, uint64_t))(a4 + 72))(*a5, a5[1]);
    *a5 = safeh_GetNullHandle();
    a5[1] = v29;
    return v14;
  }
  if ((v14 & 0x1FFF) != 0)
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16011, (uint64_t)"%s%x", v25, v26, v27, v28, "lherror");
    goto LABEL_12;
  }
  if (v33)
  {
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(a4 + 104))(*a5, a5[1], v34);
    *a8 += v33;
  }
  else
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16010, 0, v25, v26, v27, v28, v32);
    (*(void (**)(uint64_t, uint64_t))(a4 + 72))(*a5, a5[1]);
    *a5 = safeh_GetNullHandle();
    a5[1] = v31;
    return 18882563;
  }
  return v14;
}

uint64_t ttseg_loc_SynthesizeCleanup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 248);
  LODWORD(v17) = ttseg_loc_ProcessEnd(a1, 0, *(unsigned __int16 *)(a1 + 396), 1, a5, a6, a7, a8);
  uint64_t v18 = *(void *)(a1 + 320);
  if (v18)
  {
    int v19 = (*(uint64_t (**)(uint64_t, void))(*(void *)(a1 + 128) + 72))(v18, *(void *)(a1 + 328));
    *(void *)(a1 + 320) = safeh_GetNullHandle();
    *(void *)(a1 + 328) = v10;
    if (v19 < 0 && (int)v17 > -1) {
      LODWORD(v17) = v19;
    }
  }
  int v21 = ttseg_loc_CloseOutputStreams(a1, v10, v11, v12, v13, v14, v15, v16);
  if (v21 >= 0 || (int)v17 <= -1) {
    uint64_t v17 = v17;
  }
  else {
    uint64_t v17 = v21;
  }
  if ((v17 & 0x80000000) == 0 || *(_DWORD *)(a1 + 268))
  {
    uint64_t v29 = *(void *)(a1 + 248);
    log_OutText(*(void *)(v29 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Send TTS_OUT_DONE message", v25, v26, v27, v75);
    *(void *)(a1 + 432) = 0;
    if (*(_DWORD *)(a1 + 208)) {
      ssftthrottle_Audio();
    }
    uint64_t v30 = *(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, void, uint64_t))(a1 + 48);
    if (v30)
    {
      uint64_t v31 = *(void *)(a1 + 232);
      uint64_t v32 = *(void *)(v31 + 32);
      if (v32)
      {
        compstats_Start(v32, *(void *)(v31 + 40), *(unsigned __int16 *)(v31 + 24) + 2, v23, v24, v25, v26, v27);
        uint64_t v30 = *(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, void, uint64_t))(a1 + 48);
      }
      uint64_t v38 = v30(*(void *)(a1 + 88), 2, a1 + 424, a1 + 432, 0, a1 + 436);
      uint64_t v39 = *(void *)(a1 + 232);
      uint64_t v40 = *(void *)(v39 + 32);
      if (v40) {
        compstats_Stop(v40, *(void *)(v39 + 40), *(unsigned __int16 *)(v39 + 24) + 2, v33, v34, v35, v36, v37);
      }
      uint64_t v41 = *(void *)(v29 + 32);
      if ((v38 & 0x80000000) != 0) {
        log_OutText(v41, (uint64_t)"TTSEG", 4, 0, (uint64_t)"User PutOutput returned error %x", v35, v36, v37, v38);
      }
      else {
        log_OutText(v41, (uint64_t)"TTSEG", 4, 0, (uint64_t)"User PutOutput returned %p %u %u", v35, v36, v37, *(void *)(a1 + 424));
      }
    }
    else
    {
      LODWORD(v38) = 0;
    }
    if ((int)v38 >= 0 || (int)v17 <= -1) {
      uint64_t v17 = v17;
    }
    else {
      uint64_t v17 = v38;
    }
  }
  uint64_t v43 = *(void *)(a1 + 456);
  if (v43)
  {
    heap_Free(*(void **)(v9 + 8), v43);
    *(void *)(a1 + 456) = 0;
  }
  unsigned int v76 = 0;
  uint64_t v44 = *(void *)(a1 + 544);
  if (v44)
  {
    uint64_t v45 = *(void *)(a1 + 232);
    if (v44 != v45)
    {
      int v46 = pipeline_ObjClose(v45, v43, v22, v23, v24, v25, v26, v27);
      if (v46 >= 0 || (int)v17 <= -1) {
        int v48 = v17;
      }
      else {
        int v48 = v46;
      }
      uint64_t v49 = *(void *)(a1 + 544);
      *(void *)(a1 + 232) = v49;
      paramc_ParamGetStr(*(void *)(*(void *)v49 + 40), (uint64_t)"fedatapackaging", &v76);
      paramc_ParamSetStr(*(void *)(**(void **)(a1 + 232) + 40), (uint64_t)"fedatapackaging", v76);
      int v57 = pipeline_ObjReopen(*(void *)(a1 + 232), v50, v51, v52, v53, v54, v55, v56);
      if (v57 >= 0 || v48 <= -1) {
        uint64_t v17 = v48;
      }
      else {
        uint64_t v17 = v57;
      }
    }
  }
  if (*(_DWORD *)(a1 + 288))
  {
    int v59 = (*(uint64_t (**)(void, void))(*(void *)(a1 + 128) + 40))(*(void *)(a1 + 272), *(void *)(a1 + 280));
    *(_DWORD *)(a1 + 288) = 0;
    if (v59 >= 0 || (int)v17 <= -1) {
      uint64_t v17 = v17;
    }
    else {
      uint64_t v17 = v59;
    }
  }
  if (*(_DWORD *)(a1 + 312))
  {
    int v61 = (*(uint64_t (**)(void, void))(*(void *)(a1 + 168) + 40))(*(void *)(a1 + 296), *(void *)(a1 + 304));
    *(_DWORD *)(a1 + 312) = 0;
    if (v61 >= 0 || (int)v17 <= -1) {
      uint64_t v17 = v17;
    }
    else {
      uint64_t v17 = v61;
    }
  }
  unsigned int v63 = *(uint64_t **)(a1 + 336);
  if (v63)
  {
    unsigned int v64 = paramc_ParamRestore(*(void *)(v9 + 40), v63);
    if ((v64 & 0x80000000) != 0)
    {
      unsigned int v69 = v64;
      log_OutPublic(*(void *)(v9 + 32), (uint64_t)"TTSEG", 16075, (uint64_t)"%s%x", v65, v66, v67, v68, "lherror");
      if ((int)v17 >= 0) {
        uint64_t v17 = v69;
      }
      else {
        uint64_t v17 = v17;
      }
    }
    unsigned int v70 = paramc_ParamCloseRestorePoint(*(void *)(v9 + 40), *(char **)(a1 + 336));
    if ((v70 & 0x80000000) != 0)
    {
      unsigned int v71 = v70;
      log_OutPublic(*(void *)(v9 + 32), (uint64_t)"TTSEG", 16076, (uint64_t)"%s%x", v24, v25, v26, v27, "lherror");
      if ((int)v17 >= 0) {
        uint64_t v17 = v71;
      }
      else {
        uint64_t v17 = v17;
      }
    }
    *(void *)(a1 + 336) = 0;
  }
  uint64_t v72 = *(void *)(a1 + 576);
  uint64_t v77 = 0;
  if (v72)
  {
    while ((tinystack_Pop(v72, &v77) & 0x80000000) == 0)
    {
      if (v77) {
        heap_Free(*(void **)(v9 + 8), v77);
      }
    }
  }
  uint64_t v73 = *(void *)(a1 + 408);
  if (v73)
  {
    heap_Free(*(void **)(v9 + 8), v73);
    *(void *)(a1 + 408) = 0;
  }
  log_OutEvent(*(uint64_t ***)(v9 + 32), 4, (uint64_t)"%s%u%s%u%s%s", v23, v24, v25, v26, v27, "INPT");
  return v17;
}

BOOL ttseg_loc_ComponentIsTextParser(const char *a1)
{
  return !cstdlib_strcmp(a1, "pp/text_parser") || !cstdlib_strcmp(a1, "rby/pp") || cstdlib_strcmp(a1, "teng/pp") == 0;
}

uint64_t ttseg_loc_ProcessEnd(uint64_t a1, unsigned int a2, unsigned int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a1 + 248);
  if (a4) {
    *(_WORD *)(a1 + 396) = a2;
  }
  if (a2 >= a3)
  {
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v12 = a2;
    do
    {
      log_OutText(*(void *)(v10 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Calling ProcessEnd for %s", a6, a7, a8, *(void *)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v12) + 8));
      uint64_t v18 = *(void *)(a1 + 232);
      uint64_t v19 = *(void *)(v18 + 32);
      if (v19) {
        compstats_Start(v19, *(void *)(v18 + 40), (v12 + 2), v13, v14, v15, v16, v17);
      }
      if (*(_DWORD *)(a1 + 240) == 2
        && !cstdlib_strcmp(*(const char **)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v12) + 8), (const char *)(a1 + 508)))
      {
        (*(void (**)(void, void))(*(void *)(a1 + 128) + 72))(*(void *)(a1 + 152), *(void *)(a1 + 160));
      }
      uint64_t v20 = *(void **)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v12);
      unsigned int v23 = (*(uint64_t (**)(void, void))(v20[2] + 112))(v20[3], v20[4]);
      uint64_t v24 = *(void *)(a1 + 232);
      uint64_t v25 = *(void *)(v24 + 32);
      if (v25) {
        compstats_Stop(v25, *(void *)(v24 + 40), (v12 + 2), v21, v22, a6, a7, a8);
      }
      if ((v23 & 0x80000000) != 0)
      {
        log_OutPublic(*(void *)(v10 + 32), (uint64_t)"TTSEG", 16019, (uint64_t)"%s%s%s%x", v22, a6, a7, a8, "component");
        if ((int)v11 >= 0) {
          uint64_t v11 = v23;
        }
        else {
          uint64_t v11 = v11;
        }
      }
      ++v12;
    }
    while (a3 != (unsigned __int16)v12);
  }
  if (log_HasTraceTuningDataSubscriber(*(void *)(v10 + 32)))
  {
    uint64_t v26 = *(void *)(v10 + 32);
    uint64_t v27 = (*(uint64_t (**)(void))(*(void *)(a1 + 128) + 152))();
    log_OutTraceTuningDataBinary(v26, 401, 0, 0, v27, 0);
  }
  if (*(void *)(a1 + 496))
  {
    (*(void (**)(void, void))(*(void *)(a1 + 128) + 72))(*(void *)(a1 + 136), *(void *)(a1 + 144));
    heap_Free(*(void **)(v10 + 8), *(void *)(a1 + 496));
    *(void *)(a1 + 496) = 0;
  }
  return v11;
}

uint64_t ttseg_loc_CloseOutputStreams(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v20 = 0;
  if (*(void *)(a1 + 360))
  {
    int v9 = ttseg_loc_PutOutput(a1, 0, a3, a4, a5, a6, a7, a8);
    int v10 = v9 & (v9 >> 31);
    int v11 = (*(uint64_t (**)(void, void, int *))(*(void *)(a1 + 128) + 136))(*(void *)(a1 + 360), *(void *)(a1 + 368), &v20);
    if (v11 < 0)
    {
      if (v9 >= 0) {
        int v10 = v11;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 444) += (8 * v20) / *(_DWORD *)(a1 + 264);
    }
    LODWORD(v12) = (*(uint64_t (**)(void, void))(*(void *)(a1 + 128) + 72))(*(void *)(a1 + 360), *(void *)(a1 + 368));
    *(void *)(a1 + 360) = safeh_GetNullHandle();
    *(void *)(a1 + 368) = v13;
    if ((int)v12 >= 0 || v10 <= -1) {
      uint64_t v12 = v10;
    }
    else {
      uint64_t v12 = v12;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  uint64_t v15 = *(void *)(a1 + 376);
  if (v15)
  {
    int v16 = (*(uint64_t (**)(uint64_t, void))(*(void *)(a1 + 128) + 72))(v15, *(void *)(a1 + 384));
    *(void *)(a1 + 376) = safeh_GetNullHandle();
    *(void *)(a1 + 384) = v17;
    if (v16 >= 0 || (int)v12 <= -1) {
      return v12;
    }
    else {
      return v16;
    }
  }
  return v12;
}

_DWORD *ttseg_loc_NextMarkToDeliver(unsigned int a1, _DWORD *a2, unint64_t a3, _DWORD *a4)
{
  if (a4) {
    *a4 = 0;
  }
  if ((unint64_t)a2 >= a3) {
    return 0;
  }
  uint64_t result = 0;
  int v6 = (a1 >> 6) & 1;
  int v7 = (a1 >> 3) & 1;
  int v8 = a1 & 1;
  int v9 = (a1 >> 10) & 1;
  int v10 = (a1 >> 7) & 1;
  BOOL v11 = a1 != 0;
  int v12 = (a1 >> 4) & 1;
  int v13 = (a1 >> 8) & 1;
  int v14 = (a1 >> 5) & 1;
  int v15 = (a1 >> 9) & 1;
  int v16 = (a1 >> 1) & 1;
  int v17 = (a1 >> 2) & 1;
  while (2)
  {
    if (!result || a4 && a2[3] <= result[3])
    {
      int v18 = v11;
      switch(*a2)
      {
        case 0:
        case 2:
        case 5:
        case 6:
        case 7:
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xD:
        case 0xE:
        case 0x15:
        case 0x16:
        case 0x1A:
        case 0x1F:
        case 0x20:
        case 0x22:
        case 0x25:
          goto LABEL_29;
        case 1:
          if (!v16) {
            goto LABEL_34;
          }
          goto LABEL_30;
        case 3:
        case 0xF:
        case 0x17:
        case 0x1B:
        case 0x1C:
        case 0x1E:
        case 0x23:
        case 0x27:
          goto LABEL_34;
        case 4:
          if (!v15) {
            goto LABEL_34;
          }
          goto LABEL_30;
        case 8:
          if (!v14) {
            goto LABEL_34;
          }
          goto LABEL_30;
        case 0x10:
        case 0x11:
        case 0x12:
        case 0x13:
        case 0x18:
          if (!v12) {
            goto LABEL_34;
          }
          goto LABEL_30;
        case 0x14:
          if (!v13) {
            goto LABEL_34;
          }
          goto LABEL_30;
        case 0x19:
          if (!v10) {
            goto LABEL_34;
          }
          goto LABEL_30;
        case 0x1D:
          if (!v7) {
            goto LABEL_34;
          }
          goto LABEL_30;
        case 0x21:
        case 0x26:
          if (!v17) {
            goto LABEL_34;
          }
          goto LABEL_30;
        case 0x24:
          int v18 = v6;
          goto LABEL_29;
        case 0x28:
          if (!v9) {
            goto LABEL_34;
          }
          goto LABEL_30;
        default:
          if (*a2 != 0x4000) {
            goto LABEL_34;
          }
          int v18 = v8;
          if (!a2[2]) {
            goto LABEL_34;
          }
LABEL_29:
          if (v18)
          {
LABEL_30:
            if (!result) {
              uint64_t result = a2;
            }
            if (a4) {
              ++*a4;
            }
          }
LABEL_34:
          a2 += 8;
          if ((unint64_t)a2 >= a3) {
            return result;
          }
          continue;
      }
    }
    return result;
  }
}

uint64_t ttseg_loc_PutOutput_TAI(void *a1, int a2, uint64_t a3)
{
  if (!a1[6]) {
    return 0;
  }
  uint64_t v3 = a1[31];
  uint64_t v4 = (uint64_t (*)(void, uint64_t, uint64_t, void *, void *, void, char *))a1[9];
  uint64_t v5 = a1 + 59;
  int v6 = a1 + 60;
  if (a2)
  {
    uint64_t v10 = v4(a1[11], 8, a3, v5, v6, a1[61], (char *)a1 + 484);
    if ((v10 & 0x80000000) != 0) {
      log_OutText(*(void *)(v3 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TA PutOutput (Data send) returned error %x", v7, v8, v9, v10);
    }
  }
  else
  {
    uint64_t v10 = v4(a1[11], 4, a3, v5, v6, 0, (char *)a1 + 484);
    if ((v10 & 0x80000000) != 0) {
      log_OutText(*(void *)(v3 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TA PutOutput (Data req) returned error %x", v11, v12, v13, v10);
    }
  }
  return v10;
}

uint64_t ttseg_validateTaInfo(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  if ((ttseg_loc_BeginFunction(a1, a2, &v6, &v7) & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v4 = *(void *)(v7 + 552);
  while (v4 != a3)
  {
    uint64_t v4 = *(void *)(v4 + 168);
    if (!v4) {
      return 0;
    }
  }
  return 1;
}

uint64_t pipeline_ListPipelineComponentNames(_WORD *a1, int a2, char *a3, uint64_t *a4)
{
  unsigned int v45 = 0;
  uint64_t v5 = 2166366212;
  uint64_t v43 = 0;
  *(void *)uint64_t v44 = 0;
  uint64_t result = 2166366215;
  if (!a3) {
    return result;
  }
  if (!a4) {
    return result;
  }
  uint64_t result = InitRsrcFunction(a1, a2, v44);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  log_OutText(*(void *)(*(void *)v44 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"pipeline_ListPipelineComponentNames: Begin %s", v9, v10, v11, (uint64_t)a3);
  *a4 = 0;
  uint64_t v12 = pipeline_create_name_vector_for_query(*(void **)v44, a3, "COMPONENTS/*", &v43);
  uint64_t v16 = v43;
  if ((v12 & 0x80000000) != 0) {
    goto LABEL_58;
  }
  uint64_t v17 = *(void *)v44;
  int v46 = 0;
  int v48 = "lightssml";
  uint64_t v49 = 0;
  int v47 = "mparser/4sml";
  if (vector_GetElemAt(v43, 0, &v49))
  {
    if (!cstdlib_strcmp(*v49, "xcoder")) {
      vector_AddElemAt(v16, 0, &v48);
    }
    if ((paramc_ParamGetInt(*(void *)(v17 + 40), (uint64_t)"uselightssml", &v46) & 0x80000000) == 0)
    {
      uint64_t v22 = *v49;
      if (v46 == 1)
      {
        if (!cstdlib_strcmp(v22, "mparser/4sml"))
        {
          unsigned int v23 = &v48;
LABEL_16:
          vector_Remove(v16, 0);
          vector_AddElemAt(v16, 0, v23);
        }
      }
      else if (!cstdlib_strcmp(v22, "lightssml"))
      {
        unsigned int v23 = &v47;
        goto LABEL_16;
      }
    }
    uint64_t v12 = hlp_insert_after(*(uint64_t *)v44, v16, "xcoder", "voice_switch", is_not_sink_or_voice_switch);
    if ((v12 & 0x80000000) == 0)
    {
      pipeline_loc_DetermineEngine(*(uint64_t *)v44, v16, (int *)&v45);
      if (v45
        || (uint64_t v12 = hlp_insert_after(*(uint64_t *)v44, v16, "fe/be_adapt", "fe/fe_msp", is_not_sink_or_msp),
            (v12 & 0x80000000) == 0))
      {
        uint64_t v25 = *(void *)v44;
        uint64_t v49 = 0;
        int Size = vector_GetSize(v16);
        if (cstdlib_strstr(a3, "embedded-compact") || cstdlib_strstr(a3, "embedded-pro"))
        {
          uint64_t v27 = "synth/bet3fxd";
          uint64_t v28 = "select/bet3fxd";
        }
        else
        {
          uint64_t v27 = "synth/bet3fxd";
          uint64_t v28 = "select/bet3fxd";
          if (!cstdlib_strstr(a3, "embedded-high") && !cstdlib_strstr(a3, "22/bet3"))
          {
            uint64_t v28 = "select/bet3flt";
            uint64_t v27 = "synth/bet3flt";
          }
        }
        int v47 = v27;
        int v48 = v28;
        if (Size)
        {
          unsigned int v29 = 0;
          while (1)
          {
            if (!vector_GetElemAt(v16, v29, &v49))
            {
              uint64_t v24 = *(void *)(v25 + 32);
              goto LABEL_13;
            }
            if (!cstdlib_strcmp(*v49, "select/bet3"))
            {
              vector_Remove(v16, v29);
              vector_AddElemAt(v16, v29, &v48);
            }
            if (!cstdlib_strcmp(*v49, "synth/bet3")) {
              break;
            }
            if (Size == ++v29) {
              goto LABEL_33;
            }
          }
          vector_Remove(v16, v29);
          vector_AddElemAt(v16, v29, &v47);
        }
LABEL_33:
        unsigned int v30 = v45;
        if (v45 <= 1)
        {
          uint64_t v31 = *(void *)v44;
          int v48 = "audioinserter";
          uint64_t v49 = 0;
          int v32 = vector_GetSize(v16);
          if (v32)
          {
            int v33 = v32;
            unsigned int v34 = 0;
            while (vector_GetElemAt(v16, v34, &v49))
            {
              if (!cstdlib_strcmp(*v49, v48)) {
                goto LABEL_47;
              }
              if (!cstdlib_strcmp(*v49, "audiocvt") || !cstdlib_strcmp(*v49, "phonmap/mrk"))
              {
                vector_AddElemAt(v16, v34, &v48);
                goto LABEL_47;
              }
              if (v33 == ++v34) {
                goto LABEL_47;
              }
            }
            uint64_t v24 = *(void *)(v31 + 32);
            goto LABEL_13;
          }
LABEL_47:
          unsigned int v30 = v45;
        }
        if (v30 == 2) {
          uint64_t v35 = "teng/mrkaligner";
        }
        else {
          uint64_t v35 = "audioinserter";
        }
        uint64_t v12 = hlp_insert_after(*(uint64_t *)v44, v16, v35, "dspeffects", (uint64_t (*)(const char *))is_not_dspeffects);
        if ((v12 & 0x80000000) == 0)
        {
          uint64_t v36 = *(void *)v44;
          uint64_t v49 = 0;
          int v37 = vector_GetSize(v16);
          if (v37)
          {
            int v38 = v37;
            unsigned int v39 = 0;
            while (1)
            {
              if (!vector_GetElemAt(v16, v39, &v49))
              {
                log_OutText(*(void *)(v36 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Unable to remove component '%s'", v40, v41, v42, (uint64_t)"nlu/nluhtmlparser");
                goto LABEL_59;
              }
              if (!cstdlib_strcmp(*v49, "nlu/nluhtmlparser")) {
                break;
              }
              if (v38 == ++v39) {
                goto LABEL_66;
              }
            }
            vector_Remove(v16, v39);
          }
LABEL_66:
          uint64_t v5 = 0;
          *a4 = v16;
          goto LABEL_59;
        }
      }
    }
LABEL_58:
    uint64_t v5 = v12;
    goto LABEL_59;
  }
  uint64_t v24 = *(void *)(v17 + 32);
LABEL_13:
  log_OutPublic(v24, (uint64_t)"TTSEG", 16092, (uint64_t)"%s%s", v18, v19, v20, v21, "pipeline");
LABEL_59:
  log_OutText(*(void *)(*(void *)v44 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"pipeline_ListPipelineComponentNames: End %s", v13, v14, v15, (uint64_t)a3);
  if ((v5 & 0x80000000) != 0)
  {
    if (v16) {
      vector_ObjClose(v16);
    }
  }
  return v5;
}

uint64_t pipeline_create_name_vector_for_query(void *a1, unsigned char *a2, char *__s1, void *a4)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  unsigned int v29 = __dst;
  uint64_t v30 = 0;
  __src = 0;
  __s1a = 0;
  uint64_t v26 = 0;
  BOOL v8 = cstdlib_strcmp(__s1, "OBJECTS/*") == 0;
  uint64_t v13 = brk_TagIteratorOpen(a1[3], a2, __s1, v8, &v30);
  if ((v13 & 0x80000000) != 0)
  {
    log_OutPublic(a1[4], (uint64_t)"TTSEG", 16072, (uint64_t)"%s%s", v9, v10, v11, v12, "pipeline");
LABEL_17:
    if (v26) {
      vector_ObjClose(v26);
    }
    uint64_t v26 = 0;
  }
  else
  {
    uint64_t v14 = (void *)a1[1];
    long long v24 = xmmword_26D214FE8;
    uint64_t v25 = off_26D214FF8;
    if (vector_ObjOpen(v14, &v24, 64, &v26))
    {
      while ((brk_TagIteratorNext(v30, (uint64_t)&__s1a, (uint64_t)&__src) & 0x80000000) == 0)
      {
        if (!__s1a || !cstdlib_strcmp(__s1, "COMPONENTS/*") && cstdlib_strcmp(__s1a, "COMPONENT"))
        {
          uint64_t v13 = 2166366212;
          log_OutPublic(a1[4], (uint64_t)"TTSEG", 16091, (uint64_t)"%s%s%s%s", v19, v20, v21, v22, "pipeline");
          goto LABEL_17;
        }
        if (__src && *__src)
        {
          if (cstdlib_strcmp(__s1, "OBJECTS/*"))
          {
            cstdlib_strcpy(__dst, __src);
          }
          else
          {
            cstdlib_strcpy(__dst, __s1a);
            cstdlib_strcat(__dst, "|");
            cstdlib_strcat(__dst, __src);
          }
          if (vector_Add(v26, &v29)) {
            continue;
          }
        }
        uint64_t v13 = 2166366212;
        log_OutPublic(a1[4], (uint64_t)"TTSEG", 16092, (uint64_t)"%s%s", v19, v20, v21, v22, "pipeline");
        goto LABEL_17;
      }
    }
    else
    {
      log_OutPublic(a1[4], (uint64_t)"TTSEG", 16072, (uint64_t)"%s%s", v15, v16, v17, v18, "pipeline");
    }
  }
  *a4 = v26;
  if (v30) {
    brk_TagIteratorClose(v30);
  }
  return v13;
}

uint64_t pipeline_loc_DetermineEngine(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v14 = 0;
  uint64_t result = vector_GetSize(a2);
  if (!a3)
  {
    while (1)
LABEL_9:
      log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Unable to determine the engine of the pipeline", v7, v8, v9, v13);
  }
  int v10 = result;
  *a3 = 0;
  if (result)
  {
    unsigned int v11 = 0;
    while (1)
    {
      if (!vector_GetElemAt(a2, v11, &v14)) {
        goto LABEL_9;
      }
      uint64_t result = cstdlib_strcmp(*v14, "rby/ling");
      if (!result)
      {
        int v12 = 1;
        goto LABEL_12;
      }
      uint64_t result = cstdlib_strcmp(*v14, "teng/synth");
      if (!result) {
        break;
      }
      if (v10 == ++v11) {
        return result;
      }
    }
    int v12 = 2;
LABEL_12:
    *a3 = v12;
  }
  return result;
}

uint64_t pipeline_ObjOpen(_WORD *a1, uint64_t a2, char *a3, uint64_t a4, int a5, uint64_t a6, uint64_t **a7, _DWORD *a8)
{
  uint64_t v103 = *MEMORY[0x263EF8340];
  int v101 = 0;
  uint64_t v99 = 0;
  __s2 = 0;
  *(void *)uint64_t v97 = 0;
  uint64_t v98 = 0;
  uint64_t v95 = 0;
  uint64_t v96 = 0;
  uint64_t v93 = 0;
  uint64_t v94 = 0;
  uint64_t v92 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, v97);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  *a7 = 0;
  *a8 = 0;
  log_OutText(*(void *)(*(void *)v97 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"pipeline_ObjOpen : Begin %s", v17, v18, v19, (uint64_t)a3);
  *(void *)uint64_t __dst = 0;
  uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"mlset", "");
  if ((v26 & 0x1FFF) == 0xA) {
    goto LABEL_30;
  }
  uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"voiceml", "");
  if ((v26 & 0x1FFF) == 0xA) {
    goto LABEL_30;
  }
  uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"noclmset", "");
  if ((v26 & 0x1FFF) == 0xA) {
    goto LABEL_30;
  }
  uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"shortfragmentforceclm", "");
  if ((v26 & 0x1FFF) == 0xA) {
    goto LABEL_30;
  }
  uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"shortfragmentforceclm_value_pipeline", "");
  if ((v26 & 0x1FFF) == 0xA) {
    goto LABEL_30;
  }
  uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"extclccfg", "");
  if ((v26 & 0x1FFF) == 0xA) {
    goto LABEL_30;
  }
  uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"feextcfgdataprefix", "");
  if ((v26 & 0x1FFF) == 0xA) {
    goto LABEL_30;
  }
  uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"voicecomponentid", "");
  if ((v26 & 0x1FFF) == 0xA) {
    goto LABEL_30;
  }
  uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"engine_support_base_release", "");
  if ((v26 & 0x1FFF) == 0xA) {
    goto LABEL_30;
  }
  uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"engine_support_point_releases", "");
  if ((v26 & 0x1FFF) == 0xA) {
    goto LABEL_30;
  }
  uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"bet7featex_mode", "");
  if ((v26 & 0x1FFF) == 0xA) {
    goto LABEL_30;
  }
  uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"bet7tokenconverter_model", "");
  if ((v26 & 0x1FFF) == 0xA) {
    goto LABEL_30;
  }
  paramc_ParamRemove(*(void *)(*(void *)v97 + 40), (uint64_t)"bet7featex_mode");
  paramc_ParamRemove(*(void *)(*(void *)v97 + 40), (uint64_t)"bet7tokenconverter_model");
  paramc_ParamGetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"lidlanguages", __dst);
  if (!*(void *)__dst)
  {
    uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"lidlanguages", "");
    if ((v26 & 0x1FFF) == 0xA) {
      goto LABEL_30;
    }
  }
  uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"extraesclang", "");
  if ((v26 & 0x1FFF) == 0xA) {
    goto LABEL_30;
  }
  uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"extraesctn", "");
  if ((v26 & 0x1FFF) == 0xA) {
    goto LABEL_30;
  }
  uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"typeofsynthesis", "");
  if ((v26 & 0x1FFF) == 0xA) {
    goto LABEL_30;
  }
  uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"fedatapackaging", "");
  if ((v26 & 0x1FFF) == 0xA) {
    goto LABEL_30;
  }
  uint64_t v26 = paramc_ParamSetUInt(*(void *)(*(void *)v97 + 40), (uint64_t)"prmigexists", 0);
  if ((v26 & 0x1FFF) == 0xA) {
    goto LABEL_30;
  }
  paramc_ParamRemove(*(void *)(*(void *)v97 + 40), (uint64_t)"voiceoperatingpoint");
  paramc_ParamRemove(*(void *)(*(void *)v97 + 40), (uint64_t)"uselectrawdataversion");
  paramc_ParamRemove(*(void *)(*(void *)v97 + 40), (uint64_t)"uselectreductionversion");
  paramc_ParamRemove(*(void *)(*(void *)v97 + 40), (uint64_t)"nnpausingthresholdpercent");
  uint64_t v27 = paramc_ParamSetUInt(*(void *)(*(void *)v97 + 40), (uint64_t)"bet4nodeprunemax", 0);
  if ((v27 & 0x1FFF) != 0xA)
  {
    uint64_t v27 = paramc_ParamSetUInt(*(void *)(*(void *)v97 + 40), (uint64_t)"bet4beamwidth", 0);
    if ((v27 & 0x1FFF) != 0xA)
    {
      uint64_t v27 = paramc_ParamSetUInt(*(void *)(*(void *)v97 + 40), (uint64_t)"bet4nodelimit", 0);
      if ((v27 & 0x1FFF) != 0xA)
      {
        uint64_t v27 = paramc_ParamSetUInt(*(void *)(*(void *)v97 + 40), (uint64_t)"bet4nodeprunemaxunvoiced", 0);
        if ((v27 & 0x1FFF) != 0xA)
        {
          uint64_t v27 = paramc_ParamSetUInt(*(void *)(*(void *)v97 + 40), (uint64_t)"timbre_baseline", 0x64u);
          if ((v27 & 0x1FFF) != 0xA)
          {
            uint64_t v27 = paramc_ParamSetUInt(*(void *)(*(void *)v97 + 40), (uint64_t)"pitch_baseline", 0x64u);
            if ((v27 & 0x1FFF) != 0xA)
            {
              uint64_t v27 = paramc_ParamSetUInt(*(void *)(*(void *)v97 + 40), (uint64_t)"rate_baseline", 0x64u);
              if ((v27 & 0x1FFF) != 0xA)
              {
                uint64_t v27 = paramc_ParamSetUInt(*(void *)(*(void *)v97 + 40), (uint64_t)"volume_baseline", 0x50u);
                if ((v27 & 0x1FFF) != 0xA)
                {
                  paramc_ParamRemove(*(void *)(*(void *)v97 + 40), (uint64_t)"is_teng");
                  paramc_ParamRemove(*(void *)(*(void *)v97 + 40), (uint64_t)"mnceosposition");
                  paramc_ParamRemove(*(void *)(*(void *)v97 + 40), (uint64_t)"basicclcprosody");
                  paramc_ParamRemove(*(void *)(*(void *)v97 + 40), (uint64_t)"punctmarks");
                  paramc_ParamRemove(*(void *)(*(void *)v97 + 40), (uint64_t)"addondct_extended_lookup");
                  paramc_ParamRemove(*(void *)(*(void *)v97 + 40), (uint64_t)"nnpausingoverride");
                  paramc_ParamRemove(*(void *)(*(void *)v97 + 40), (uint64_t)"liddigitmain");
                  uint64_t v91 = heap_Calloc(*(void **)(*(void *)v97 + 8), 1, 56);
                  if (!v91)
                  {
                    uint64_t v26 = 2166366218;
                    log_OutPublic(*(void *)(*(void *)v97 + 32), (uint64_t)"TTSEG", 16000, 0, v31, v32, v33, v34, v90);
                    goto LABEL_30;
                  }
                  *(void *)uint64_t v91 = *(void *)v97;
                  uint64_t v35 = heap_strdup(*(void *)(*(void *)v97 + 8), a3);
                  *(void *)(v91 + 8) = v35;
                  if (v35)
                  {
                    uint64_t Object = pipeline_ListPipelineComponentNames(a1, a2, a3, &v93);
                    if ((Object & 0x80000000) != 0) {
                      goto LABEL_74;
                    }
                    pipeline_loc_DetermineEngine(*(uint64_t *)v97, v93, &v101);
                    unsigned __int16 Size = vector_GetSize(v93);
                    *(_WORD *)(v91 + 24) = Size;
                    uint64_t v42 = heap_Calloc(*(void **)(*(void *)v97 + 8), Size, 8);
                    *(void *)(v91 + 16) = v42;
                    uint64_t v43 = *(void *)v97;
                    if (v42)
                    {
                      uint64_t v95 = heap_Calloc(*(void **)(*(void *)v97 + 8), *(unsigned __int16 *)(v91 + 24), 16);
                      uint64_t v44 = *(void *)(*(void *)v97 + 32);
                      if (v95)
                      {
                        unsigned int LogLevel = log_GetLogLevel(v44);
                        LODWORD(v46) = *(unsigned __int16 *)(v91 + 24);
                        if (LogLevel >= 2)
                        {
                          compstats_ObjOpen(a1, a2, v46 + 3, v91 + 32);
                          compstats_Start(*(void *)(v91 + 32), *(void *)(v91 + 40), 0, v47, v48, v49, v50, v51);
                          uint64_t v46 = *(unsigned __int16 *)(v91 + 24);
                          if (*(void *)(v91 + 32))
                          {
                            uint64_t v52 = heap_Calloc(*(void **)(*(void *)v97 + 8), v46 + 3, 8);
                            *(void *)(v91 + 48) = v52;
                            if (v52)
                            {
                              **(void **)(v91 + 48) = heap_strdup(*(void *)(*(void *)v97 + 8), "Total");
                              *(void *)(*(void *)(v91 + 48) + 8) = heap_strdup(*(void *)(*(void *)v97 + 8), "TTSEG input CB");
                              uint64_t v53 = heap_strdup(*(void *)(*(void *)v97 + 8), "TTSEG output CB");
                              LODWORD(v46) = *(unsigned __int16 *)(v91 + 24);
                              *(void *)(*(void *)(v91 + 48) + 8 * *(unsigned __int16 *)(v91 + 24) + 16) = v53;
                            }
                            else
                            {
                              compstats_ObjClose(*(void *)(v91 + 32), *(void *)(v91 + 40));
                              *(void *)(v91 + 32) = safeh_GetNullHandle();
                              *(void *)(v91 + 40) = v54;
                              LODWORD(v46) = *(unsigned __int16 *)(v91 + 24);
                            }
                          }
                        }
                        if (v46)
                        {
                          uint64_t v55 = 0;
                          while (1)
                          {
                            *(void *)uint64_t __dst = 0;
                            if (!vector_GetElemAt(v93, v55, __dst))
                            {
                              log_OutPublic(*(void *)(*(void *)v97 + 32), (uint64_t)"TTSEG", 16000, 0, v56, v57, v58, v59, v90);
                              uint64_t v26 = 2166366212;
                              goto LABEL_75;
                            }
                            uint64_t v60 = **(char ***)__dst;
                            uint64_t v98 = **(char ***)__dst;
                            if (!a4) {
                              goto LABEL_70;
                            }
                            if ((pipeline_Find(a4, v60, (uint64_t *)&v96) & 0x80000000) != 0) {
                              break;
                            }
                            int v61 = v96;
                            *(void *)(*(void *)(v91 + 16) + 8 * v55) = v96;
                            ++*v61;
                            if (*(void *)(v91 + 32)) {
                              *(void *)(*(void *)(v91 + 48) + 8 * v55 + 16) = heap_strdup(*(void *)(*(void *)v97 + 8), v98);
                            }
LABEL_71:
                            if (++v55 >= (unint64_t)*(unsigned __int16 *)(v91 + 24)) {
                              goto LABEL_72;
                            }
                          }
                          uint64_t v60 = v98;
LABEL_70:
                          uint64_t Object = pipeline_PrepareForOpeningComponent(*(uint64_t **)v97, (unsigned __int16)v55, v60, (void *)v91);
                          if ((Object & 0x80000000) != 0) {
                            goto LABEL_74;
                          }
                          goto LABEL_71;
                        }
LABEL_72:
                        uint64_t Object = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"pipeline", a3);
                        if ((Object & 0x1FFF) == 0xA
                          || (uint64_t Object = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"fedatapackaging", ""), (Object & 0x1FFF) == 0xA))
                        {
LABEL_74:
                          uint64_t v26 = Object;
                          goto LABEL_75;
                        }
                        uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"datapackagename", "");
                        if ((v26 & 0x1FFF) == 0xA) {
                          goto LABEL_75;
                        }
                        if ((brk_TagIteratorOpen(*(void *)(*(void *)v97 + 24), a3, "PARAMETERS/*", 1, &v94) & 0x80000000) == 0)
                        {
                          if ((brk_TagIteratorNext(v94, (uint64_t)&__s2, (uint64_t)&v98) & 0x80000000) == 0)
                          {
                            int v62 = 0;
                            int v63 = 0;
                            while (1)
                            {
                              if (__s2 && *__s2)
                              {
                                if (!cstdlib_strcmp("vopversion", __s2)) {
                                  int v63 = 1;
                                }
                                if (__s2 && *__s2)
                                {
                                  if (!cstdlib_strcmp("waitfactor", __s2))
                                  {
                                    __dst[0] = 1;
                                    if ((paramc_ParamGetUInt(*(void *)(*(void *)v97 + 40), (uint64_t)"waitfactor", __dst) & 0x80000000) == 0)uint64_t v26 = paramc_ParamSetUInt(*(void *)(*(void *)v97 + 40), (uint64_t)"waitfactorpipelinebackup", __dst[0]); {
                                    if ((v26 & 0x1FFF) == 0xA)
                                    }
                                      goto LABEL_75;
                                    int v62 = 1;
                                  }
                                  unsigned int v64 = __s2;
                                  if (__s2)
                                  {
                                    if (*__s2)
                                    {
                                      if (a5 != 0xFFFF)
                                      {
                                        if (!cstdlib_strncmp("audiooutput", __s2, 0xBuLL)) {
                                          goto LABEL_122;
                                        }
                                        unsigned int v64 = __s2;
                                      }
                                      if (!cstdlib_strcmp("extraesclang", v64) || !cstdlib_strcmp("extraesctn", __s2))
                                      {
                                        *(void *)uint64_t __dst = 0;
                                        if ((paramc_ParamGetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"clcpreventhlpactivate", __dst) & 0x80000000) == 0)
                                        {
                                          uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"clcpreventhlpactivate", "yes");
                                          if ((v26 & 0x1FFF) == 0xA) {
                                            goto LABEL_75;
                                          }
                                        }
                                      }
                                      uint64_t v65 = __s2;
                                      if (__s2 && *__s2)
                                      {
                                        if (!cstdlib_strcmp("waitfactor", __s2))
                                        {
                                          __dst[0] = 0;
                                          if ((paramc_ParamGetUInt(*(void *)(*(void *)v97 + 40), (uint64_t)"waitfactorsetbyapi", __dst) & 0x80000000) != 0|| __dst[0] != 1)
                                          {
                                            if (v98) {
                                              unsigned int v69 = v98;
                                            }
                                            else {
                                              unsigned int v69 = "";
                                            }
                                            uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)__s2, v69);
                                          }
                                          int v68 = v26 & 0x1FFF;
LABEL_121:
                                          if (v68 == 10) {
                                            goto LABEL_75;
                                          }
                                          goto LABEL_122;
                                        }
                                        uint64_t v65 = __s2;
                                      }
                                      if (v98) {
                                        uint64_t v66 = v98;
                                      }
                                      else {
                                        uint64_t v66 = "";
                                      }
                                      uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)v65, v66);
                                      if ((v26 & 0x1FFF) == 0xA) {
                                        goto LABEL_75;
                                      }
                                      if (!cstdlib_strcmp("shortfragmentforceclm", __s2))
                                      {
                                        if (v98) {
                                          uint64_t v67 = v98;
                                        }
                                        else {
                                          uint64_t v67 = "";
                                        }
                                        uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"shortfragmentforceclm_value_pipeline", v67);
                                        int v68 = v26 & 0x1FFF;
                                        goto LABEL_121;
                                      }
                                    }
                                  }
                                }
                              }
LABEL_122:
                              if ((brk_TagIteratorNext(v94, (uint64_t)&__s2, (uint64_t)&v98) & 0x80000000) != 0) {
                                goto LABEL_125;
                              }
                            }
                          }
                          int v63 = 0;
                          int v62 = 0;
LABEL_125:
                          uint64_t v26 = vopCheckEngineCompatibility(*(uint64_t *)v97);
                          if ((v26 & 0x80000000) != 0) {
                            goto LABEL_75;
                          }
                          if (!v63) {
                            uint64_t v26 = paramc_ParamSetStr(*(void *)(*(void *)v97 + 40), (uint64_t)"vopversion", "0.0.0");
                          }
                          if ((v26 & 0x1FFF) == 0xA
                            || !v62
                            && (__dst[0] = 1,
                                (paramc_ParamGetUInt(*(void *)(*(void *)v97 + 40), (uint64_t)"waitfactorpipelinebackup", __dst) & 0x80000000) == 0)&& ((uint64_t v26 = paramc_ParamSetUInt(*(void *)(*(void *)v97 + 40), (uint64_t)"waitfactor", __dst[0]), (v26 & 0x1FFF) == 0xA)|| (uint64_t v26 = paramc_ParamSetUInt(*(void *)(*(void *)v97 + 40), (uint64_t)"waitfactorpipelinebackup", __dst[0]), (v26 & 0x1FFF) == 0xA)))
                          {
LABEL_75:
                            uint64_t v28 = (uint64_t *)v91;
                            goto LABEL_31;
                          }
                          brk_TagIteratorClose(v94);
                          uint64_t v94 = 0;
                        }
                        if ((pipeline_create_name_vector_for_query(*(void **)v97, a3, "OBJECTS/*", &v92) & 0x80000000) == 0)
                        {
                          uint64_t v70 = v92;
                          if (!v101)
                          {
                            uint64_t Object = hlp_insert_after(*(uint64_t *)v97, v92, "FE_DCTLKP|fe/fe_dctlkp", "FE_NN|fe/fe_nn", 0);
                            if ((Object & 0x80000000) != 0) {
                              goto LABEL_74;
                            }
                          }
                          uint64_t Object = hlp_insert_after(*(uint64_t *)v97, v70, "INET|inetspi", "CHARCOUNT|charcount", 0);
                          if ((Object & 0x80000000) != 0) {
                            goto LABEL_74;
                          }
                          uint64_t Object = hlp_append(*(uint64_t *)v97, v70);
                          if ((Object & 0x80000000) != 0) {
                            goto LABEL_74;
                          }
                          if (vector_GetSize(v70))
                          {
                            unsigned int v71 = 0;
                            int v72 = 0;
                            uint64_t v26 = 2166366208;
                            do
                            {
                              if (!vector_GetElemAt(v70, v71, &v99)) {
                                goto LABEL_75;
                              }
                              cstdlib_strcpy((char *)__dst, *v99);
                              if (cstdlib_strcmp((const char *)__dst, "INET|inetspi"))
                              {
                                uint64_t v73 = cstdlib_strchr((char *)__dst, 124);
                                uint64_t v98 = v73;
                                if (!v73) {
                                  goto LABEL_75;
                                }
                                *uint64_t v73 = 0;
                                ++v98;
                                __s2 = (char *)__dst;
                                uint64_t Object = pipeline_LoadObject(a1, a2, (uint64_t)__dst, v98, a6, a8);
                                if ((Object & 0x80000000) != 0) {
                                  goto LABEL_74;
                                }
                              }
                              unsigned int v71 = (unsigned __int16)++v72;
                            }
                            while (vector_GetSize(v70) > (unsigned __int16)v72);
                          }
                        }
                        uint64_t Object = pipeline_silently_add_fe_clm_component(*(uint64_t *)v97, v91, &v95);
                        if ((Object & 0x80000000) != 0) {
                          goto LABEL_74;
                        }
                        uint64_t Object = pipeline_disclose_location_of_fe_clm_component(*(uint64_t *)v97, v91);
                        if ((Object & 0x80000000) != 0) {
                          goto LABEL_74;
                        }
                        uint64_t v26 = pipeline_disclose_processing_tnplus(*(uint64_t *)v97, v91);
                        if ((v26 & 0x80000000) != 0) {
                          goto LABEL_75;
                        }
                        unsigned int v74 = *(unsigned __int16 *)(v91 + 24);
                        if (*(_WORD *)(v91 + 24))
                        {
                          unint64_t v75 = 0;
                          unsigned int v76 = (void *)(v95 + 8);
                          while (1)
                          {
                            uint64_t v77 = *(uint64_t **)(*(void *)(v91 + 16) + 8 * v75);
                            if (!v77) {
                              goto LABEL_160;
                            }
                            uint64_t v78 = *(void *)(v91 + 32);
                            if (v78) {
                              compstats_Start(v78, *(void *)(v91 + 40), (v75 + 2), v21, v22, v23, v24, v25);
                            }
                            uint64_t NullHandle = safeh_GetNullHandle();
                            if (safeh_HandlesEqual(v77[3], v77[4], NullHandle, v80)) {
                              break;
                            }
                            if (*(void *)(v77[2] + 48))
                            {
                              log_OutText(*(void *)(*(void *)v97 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Reopen component: %s", v23, v24, v25, v77[1]);
                              *a8 = 1;
                              paramc_ParamTraceSetStr();
                              uint64_t v81 = (*(uint64_t (**)(uint64_t, uint64_t))(v77[2] + 48))(v77[3], v77[4]);
                              goto LABEL_155;
                            }
LABEL_156:
                            uint64_t v82 = *(void *)(v91 + 32);
                            if (v82) {
                              compstats_Stop(v82, *(void *)(v91 + 40), (v75 + 2), v21, v22, v23, v24, v25);
                            }
                            if ((v26 & 0x80000000) != 0)
                            {
                              log_OutPublic(*(void *)(*(void *)v97 + 32), (uint64_t)"TTSEG", 16001, (uint64_t)"%s%s%s%x", v22, v23, v24, v25, "component");
                              goto LABEL_75;
                            }
                            unsigned int v74 = *(unsigned __int16 *)(v91 + 24);
LABEL_160:
                            ++v75;
                            v76 += 2;
                            if (v75 >= v74) {
                              goto LABEL_161;
                            }
                          }
                          log_OutText(*(void *)(*(void *)v97 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Open component: %s", v23, v24, v25, v77[1]);
                          paramc_ParamTraceSetStr();
                          uint64_t v81 = (*(uint64_t (**)(void, void, _WORD *, uint64_t, uint64_t *))(v77[2] + 32))(*(v76 - 1), *v76, a1, a2, v77 + 3);
LABEL_155:
                          uint64_t v26 = v81;
                          paramc_ParamTraceSetStr();
                          goto LABEL_156;
                        }
LABEL_161:
                        uint64_t v83 = brk_TagIteratorOpen(*(void *)(*(void *)v97 + 24), a3, "RESOURCES/*", 1, &v94);
                        uint64_t v26 = v83;
                        if ((v83 & 0x80000000) != 0)
                        {
                          if ((v83 & 0x1FFF) != 0x14 && (v83 & 0x1FFF) != 13) {
                            goto LABEL_75;
                          }
                          uint64_t v26 = 0;
                        }
                        while ((brk_TagIteratorNext(v94, (uint64_t)&__s2, (uint64_t)&v98) & 0x80000000) == 0)
                        {
                          if (__s2 && !cstdlib_strcmp(__s2, "RESOURCE"))
                          {
                            if (v98 && *v98)
                            {
                              log_OutPublic(*(void *)(*(void *)v97 + 32), (uint64_t)"TTSEG", 16095, (uint64_t)"%s%s", v85, v86, v87, v88, "pipeline");
                              uint64_t v26 = 2166366212;
                            }
                            else
                            {
                              log_OutPublic(*(void *)(*(void *)v97 + 32), (uint64_t)"TTSEG", 16094, (uint64_t)"%s%s", v85, v86, v87, v88, "pipeline");
                            }
                          }
                          else
                          {
                            log_OutPublic(*(void *)(*(void *)v97 + 32), (uint64_t)"TTSEG", 16093, (uint64_t)"%s%s%s%s", v85, v86, v87, v88, "pipeline");
                          }
                        }
                        brk_TagIteratorClose(v94);
                        uint64_t v94 = 0;
                        uint64_t v89 = *(void *)(v91 + 32);
                        if (v89 && *(void *)(v91 + 48))
                        {
                          uint64_t v28 = (uint64_t *)v91;
                          compstats_Stop(v89, *(void *)(v91 + 40), 0, v21, v22, v23, v24, v25);
                          compstats_Log(v28[4], v28[5], *(void *)(*(void *)v97 + 32), "Pipeline Open", v28[6], 0, 0);
                          goto LABEL_31;
                        }
                        goto LABEL_75;
                      }
                      uint64_t v26 = 2166366218;
LABEL_59:
                      log_OutPublic(v44, (uint64_t)"TTSEG", 16000, 0, v36, v37, v38, v39, v90);
                      goto LABEL_75;
                    }
                    uint64_t v26 = 2166366218;
                  }
                  else
                  {
                    uint64_t v26 = 2166366218;
                    uint64_t v43 = *(void *)v97;
                  }
                  uint64_t v44 = *(void *)(v43 + 32);
                  goto LABEL_59;
                }
              }
            }
          }
        }
      }
    }
  }
  uint64_t v26 = v27;
LABEL_30:
  uint64_t v28 = 0;
LABEL_31:
  if (v93) {
    vector_ObjClose(v93);
  }
  if (v92) {
    vector_ObjClose(v92);
  }
  if (v94) {
    brk_TagIteratorClose(v94);
  }
  uint64_t v29 = v95;
  if (v95) {
    heap_Free(*(void **)(*(void *)v97 + 8), v95);
  }
  if ((v26 & 0x80000000) != 0)
  {
    if (v28) {
      pipeline_ObjClose((uint64_t)v28, v29, v20, v21, v22, v23, v24, v25);
    }
  }
  else
  {
    *a7 = v28;
  }
  log_OutText(*(void *)(*(void *)v97 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"pipeline_ObjOpen : End (%x)", v23, v24, v25, v26);
  return v26;
}

uint64_t pipeline_Find(uint64_t a1, char *__s2, uint64_t *a3)
{
  uint64_t v3 = 2166366215;
  if (a1 && __s2 && *__s2)
  {
    unint64_t v7 = 0;
    *a3 = 0;
    while (v7 < *(unsigned __int16 *)(a1 + 24))
    {
      if (cstdlib_strcmp(*(const char **)(*(void *)(*(void *)(a1 + 16) + 8 * v7) + 8), __s2))
      {
        uint64_t v8 = *a3;
      }
      else
      {
        uint64_t v8 = *(void *)(*(void *)(a1 + 16) + 8 * v7);
        *a3 = v8;
      }
      ++v7;
      if (v8) {
        return 0;
      }
    }
    return 2166366228;
  }
  return v3;
}

uint64_t pipeline_PrepareForOpeningComponent(uint64_t *a1, unsigned int a2, char *__s, void *a4)
{
  if (a4[4])
  {
    uint64_t v8 = heap_strdup(a1[1], __s);
    uint64_t v9 = a2 + 2;
    *(void *)(a4[6] + 8 * v9) = v8;
    compstats_Start(a4[4], a4[5], v9, v10, v11, v12, v13, v14);
  }
  uint64_t v15 = (_WORD *)heap_Calloc((void *)a1[1], 1, 40);
  if (!v15)
  {
    uint64_t v32 = 2166366218;
    log_OutPublic(a1[4], (uint64_t)"TTSEG", 16000, 0, v16, v17, v18, v19, v36);
    return v32;
  }
  uint64_t v20 = v15;
  *(void *)(a4[2] + 8 * a2) = v15;
  *uint64_t v15 = 1;
  uint64_t v21 = heap_strdup(a1[1], __s);
  v20[1] = v21;
  if (v21)
  {
    v20[3] = safeh_GetNullHandle();
    v20[4] = v26;
    uint64_t v32 = brk_InterfaceQuery(a1[3]);
    if ((v32 & 0x80000000) == 0)
    {
      uint64_t v33 = a4[4];
      if (v33) {
        compstats_Stop(v33, a4[5], a2 + 2, v27, v28, v29, v30, v31);
      }
      return v32;
    }
  }
  else
  {
    uint64_t v32 = 2166366218;
    log_OutPublic(a1[4], (uint64_t)"TTSEG", 16000, 0, v22, v23, v24, v25, v36);
  }
  uint64_t v34 = v20[1];
  if (v34) {
    heap_Free((void *)a1[1], v34);
  }
  heap_Free((void *)a1[1], (uint64_t)v20);
  *(void *)(a4[2] + 8 * a2) = 0;
  return v32;
}

uint64_t vopCheckEngineCompatibility(uint64_t a1)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  uint64_t v24 = 0;
  __s = 0;
  __sprintf_chk(v29, 0, 0x20uLL, "%.2d.%.2d.%d", 24, 8, 0);
  uint64_t v2 = 0;
  if ((paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"engine_support_base_release", &__s) & 0x80000000) == 0 && __s)
  {
    if (cstdlib_strlen(__s))
    {
      LOBYTE(v26) = 0;
      __int16 v28 = 0;
      uint64_t MajorMinorMaintAndSearchNext = versionGetMajorMinorMaintAndSearchNext((unsigned __int8 *)__s, &v26, (unsigned char *)&v28 + 1, &v28, 0);
      if ((MajorMinorMaintAndSearchNext & 0x80000000) != 0)
      {
        uint64_t v2 = MajorMinorMaintAndSearchNext;
        if ((MajorMinorMaintAndSearchNext & 0x1FFF) != 0x19)
        {
          uint64_t v9 = *(void *)(a1 + 32);
          uint64_t v10 = "VOP level compatibility check current engine '%s' against main '%s': failed (format error)";
LABEL_49:
          log_OutText(v9, (uint64_t)"TTSEG", 4, 0, (uint64_t)v10, v4, v5, v6, (uint64_t)v29);
          goto LABEL_50;
        }
      }
      else
      {
        if (v26 < 0x18u
          || v26 == 24 && (HIBYTE(v28) < 8u || HIBYTE(v28) == 8 && !(_BYTE)v28))
        {
          uint64_t v7 = *(void *)(a1 + 32);
          uint64_t v8 = "VOP level compatibility check current engine '%s' against main '%s': passed";
LABEL_39:
          log_OutText(v7, (uint64_t)"TTSEG", 4, 0, (uint64_t)v8, v4, v5, v6, (uint64_t)v29);
          goto LABEL_40;
        }
        uint64_t v2 = 2166366233;
      }
      log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"VOP level compatibility check current engine '%s' against main '%s': did not pass", v4, v5, v6, (uint64_t)v29);
    }
    else
    {
      uint64_t v2 = 0;
    }
  }
  if ((paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"engine_support_point_releases", &v24) & 0x80000000) == 0
    && v24
    && cstdlib_strlen(v24))
  {
    uint64_t v2 = 2166366233;
    uint64_t v15 = (unsigned __int8 *)v24;
    __int16 v28 = 0;
    char v27 = 0;
    uint64_t v26 = 0;
    while (1)
    {
      uint64_t v16 = versionGetMajorMinorMaintAndSearchNext(v15, (unsigned char *)&v28 + 1, &v28, &v27, &v26);
      if ((v16 & 0x80000000) != 0)
      {
        uint64_t v2 = v16;
        goto LABEL_46;
      }
      BOOL v17 = HIBYTE(v28) == 24 && v28 == 8;
      BOOL v18 = v17 && v27 == 0;
      BOOL v19 = v18;
      if (v18) {
        break;
      }
      uint64_t v15 = v26;
      if (!v26) {
        break;
      }
      if (!*v26) {
        goto LABEL_46;
      }
    }
    if (v19)
    {
      uint64_t v7 = *(void *)(a1 + 32);
      uint64_t v8 = "VOP level compatibility check current engine '%s' against point releases '%s': passed";
      goto LABEL_39;
    }
LABEL_46:
    uint64_t v9 = *(void *)(a1 + 32);
    if ((v2 & 0x1FFF) == 0x19) {
      uint64_t v10 = "VOP level compatibility check current engine '%s' against point releases '%s': did not pass";
    }
    else {
      uint64_t v10 = "VOP level compatibility check current engine '%s' against point releases '%s': failed (format error)";
    }
    goto LABEL_49;
  }
  if ((v2 & 0x80000000) != 0)
  {
LABEL_50:
    if ((v2 & 0x1FFF) == 7)
    {
      uint64_t v20 = *(void *)(a1 + 32);
      uint64_t v21 = 82001;
    }
    else
    {
      if ((v2 & 0x1FFF) != 0x19) {
        return v2;
      }
      uint64_t v20 = *(void *)(a1 + 32);
      uint64_t v21 = 82000;
    }
    log_OutPublic(v20, (uint64_t)"TTSEG", v21, 0, v11, v12, v13, v14, v23);
    return v2;
  }
LABEL_40:
  if ((!__s || !*__s) && (!v24 || !*v24)) {
    log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"VOP level compatibility check against current engine : not enabled", v12, v13, v14, v23);
  }
  return 0;
}

uint64_t hlp_insert_after(uint64_t a1, uint64_t a2, const char *a3, char *a4, uint64_t (*a5)(const char *))
{
  uint64_t v16 = 0;
  BOOL v17 = a4;
  uint64_t result = vector_GetSize(a2);
  if (result)
  {
    unsigned int v10 = result;
    unsigned int v11 = 1;
    while (1)
    {
      if (!vector_GetElemAt(a2, v11 - 1, &v16)) {
        goto LABEL_13;
      }
      if (!cstdlib_strcmp(*v16, a3)) {
        break;
      }
      if (v11++ >= v10) {
        return 0;
      }
    }
    if (!vector_GetElemAt(a2, v11, &v16))
    {
LABEL_13:
      log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Unable to insert component '%s'", v12, v13, v14, *v17);
      return 2166366212;
    }
    if (!a5 || (uint64_t result = a5(*v16), result))
    {
      vector_AddElemAt(a2, v11, &v17);
      return 0;
    }
  }
  return result;
}

uint64_t hlp_append(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = "CLMOBJECT|clmobjectinterface";
  if (vector_Add(a2, &v7)) {
    return 0;
  }
  log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Unable to append '%s'", v3, v4, v5, *v7);
  return 2166366212;
}

uint64_t pipeline_LoadObject(_WORD *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v48 = 0;
  uint64_t v49 = a3;
  uint64_t NullHandle = safeh_GetNullHandle();
  uint64_t v47 = v12;
  uint64_t v44 = 0;
  unsigned int v45 = 0;
  long long __b = 0u;
  long long v43 = 0u;
  uint64_t inited = InitRsrcFunction(a1, a2, &v48);
  if ((inited & 0x80000000) == 0)
  {
    if ((objc_GetObject(v48[6], a3, &v45) & 0x80000000) != 0)
    {
      cstdlib_memset(&__b, 0, 0x28uLL);
      if (LH_stricmp(a4, "phonmap")) {
        char v23 = 1;
      }
      else {
        char v23 = 2;
      }
      LOBYTE(__b) = v23;
      uint64_t v24 = brk_InterfaceQuery(v48[3]);
      if ((v24 & 0x80000000) != 0) {
        return v24;
      }
      log_OutText(v48[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Open component: %s", v25, v26, v27, (uint64_t)a4);
      uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, _WORD *, uint64_t, long long *))(*((void *)&__b + 1) + 32))(NullHandle, v47, a1, a2, &v43);
      if ((v28 & 0x80000000) != 0)
      {
        uint64_t inited = v28;
        log_OutPublic(v48[4], (uint64_t)"TTSEG", 16001, (uint64_t)"%s%s%s%x", v29, v30, v31, v32, "component");
        brk_InterfaceRelease(v48[3], *((uint64_t *)&__b + 1));
        return inited;
      }
      uint64_t inited = objc_RegisterObject(v48[6], a3, &__b);
      if ((inited & 0x80000000) != 0)
      {
        log_OutPublic(v48[4], (uint64_t)"TTSEG", 16001, (uint64_t)"%s%s%s%x", v33, v34, v35, v36, "component");
      }
      else
      {
        if (!a5 || vector_Add(a5, &v49)) {
          return inited;
        }
        log_OutPublic(v48[4], (uint64_t)"TTSEG", 16000, 0, v37, v38, v39, v40, v41);
        uint64_t inited = 2166366218;
      }
      (*(void (**)(void, void))(*((void *)&__b + 1) + 40))(v43, *((void *)&v43 + 1));
      brk_InterfaceRelease(v48[3], *((uint64_t *)&__b + 1));
      return inited;
    }
    uint64_t v17 = v45[1];
    if (*(void *)(v17 + 48))
    {
      log_OutText(v48[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Reopen object: %s", v14, v15, v16, a3);
      if (a6) {
        *a6 = 1;
      }
      uint64_t inited = (*(uint64_t (**)(void, void))(v17 + 48))(v45[2], v45[3]);
      if ((inited & 0x80000000) != 0) {
        log_OutPublic(v48[4], (uint64_t)"TTSEG", 16001, (uint64_t)"%s%s%s%x", v18, v19, v20, v21, "component");
      }
    }
    objc_ReleaseObject(v48[6], a3);
  }
  return inited;
}

uint64_t pipeline_silently_add_fe_clm_component(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  long long __s1 = 0;
  uint64_t Str = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"blockautoinsertionfeclm", &__s1);
  if ((Str & 0x80000000) != 0 || (uint64_t v7 = Str, !__s1) || cstdlib_strcmp(__s1, "yes"))
  {
    if (!*(_WORD *)(a2 + 24)) {
      return 0;
    }
    unsigned int v41 = a3;
    uint64_t v42 = a1;
    unint64_t v8 = 0;
    __int16 v9 = -1;
    __int16 v10 = -1;
    __int16 v11 = -1;
    do
    {
      uint64_t v12 = *(void *)(*(void *)(a2 + 16) + 8 * v8);
      if (v12)
      {
        if (cstdlib_strcmp(*(const char **)(v12 + 8), "fe/fe_clm"))
        {
          if (cstdlib_strcmp(*(const char **)(v12 + 8), "fe/fe_global"))
          {
            if (!cstdlib_strcmp(*(const char **)(v12 + 8), "sink")
              || !cstdlib_strcmp(*(const char **)(v12 + 8), "feeder"))
            {
              __int16 v9 = v8;
            }
          }
          else
          {
            __int16 v10 = v8;
          }
        }
        else
        {
          __int16 v11 = v8;
        }
      }
      ++v8;
    }
    while (v8 < *(unsigned __int16 *)(a2 + 24));
    uint64_t v7 = 0;
    if (v9 == -1 && v11 == -1 && v10 != -1)
    {
      unsigned int v45 = 0;
      int v44 = 0;
      uint64_t Object = objc_GetObject(*(void *)(v42 + 48), (uint64_t)"CLMOBJECT", &v45);
      if ((Object & 0x80000000) == 0) {
        uint64_t Object = (*(uint64_t (**)(void, void, int *))(v45[1] + 104))(v45[2], v45[3], &v44);
      }
      uint64_t v7 = Object;
      if (v45) {
        objc_ReleaseObject(*(void *)(v42 + 48), (uint64_t)"CLMOBJECT");
      }
      if ((v7 & 0x80000000) == 0 && v44)
      {
        if (v44 == 2) {
          unsigned __int16 v14 = v10 + 1;
        }
        else {
          unsigned __int16 v14 = v10;
        }
        uint64_t v15 = heap_Realloc(*(uint64_t **)(v42 + 8), *(void *)(a2 + 16), 8 * *(unsigned __int16 *)(a2 + 24) + 8);
        if (!v15) {
          goto LABEL_44;
        }
        *(void *)(a2 + 16) = v15;
        uint64_t v20 = *(unsigned __int16 *)(a2 + 24);
        *(void *)(v15 + 8 * v20) = 0;
        if (*(void *)(a2 + 32))
        {
          uint64_t v21 = heap_Realloc(*(uint64_t **)(v42 + 8), *(void *)(a2 + 48), 8 * v20 + 32);
          if (!v21) {
            goto LABEL_44;
          }
          *(void *)(a2 + 48) = v21;
          uint64_t v20 = *(unsigned __int16 *)(a2 + 24);
          *(void *)(v21 + 8 * v20 + 24) = 0;
        }
        uint64_t v22 = heap_Realloc(*(uint64_t **)(v42 + 8), *v41, 16 * v20 + 16);
        if (v22)
        {
          *unsigned int v41 = v22;
          char v23 = (uint64_t *)(v22 + 16 * *(unsigned __int16 *)(a2 + 24));
          *char v23 = safeh_GetNullHandle();
          v23[1] = v24;
          uint64_t v25 = *(unsigned __int16 *)(a2 + 24);
          *(_WORD *)(a2 + 24) = v25 + 1;
          if (v25 > v14)
          {
            uint64_t v26 = 16 * v25;
            do
            {
              *(void *)(*(void *)(a2 + 16) + 8 * v25) = *(void *)(*(void *)(a2 + 16)
                                                                      + 8 * (v25 - 1));
              *(_OWORD *)(*v41 + v26) = *(_OWORD *)(*v41 + 16 * --v25);
              v26 -= 16;
            }
            while (v14 < (unsigned __int16)v25);
          }
          *(void *)(*(void *)(a2 + 16) + 8 * v14) = 0;
          uint64_t v27 = (uint64_t *)(*v41 + 16 * v14);
          *uint64_t v27 = safeh_GetNullHandle();
          v27[1] = v28;
          uint64_t v34 = *(void *)(a2 + 48);
          if (!v34) {
            return pipeline_PrepareForOpeningComponent((uint64_t *)v42, v14, "fe/fe_clm", (void *)a2);
          }
          int v35 = *(unsigned __int16 *)(a2 + 24) + 2;
          unsigned int v36 = v14 + 2;
          if (v36 < (unsigned __int16)(*(_WORD *)(a2 + 24) + 2))
          {
            int v37 = (unsigned __int16)(*(_WORD *)(a2 + 24) + 2);
            do
            {
              *(void *)(*(void *)(a2 + 48) + 8 * (unsigned __int16)v35--) = *(void *)(*(void *)(a2 + 48)
                                                                                            + 8
                                                                                            * (v37 - 1));
              int v37 = (unsigned __int16)v35;
            }
            while (v36 < (unsigned __int16)v35);
            uint64_t v34 = *(void *)(a2 + 48);
          }
          *(void *)(v34 + 8 * v36) = 0;
          uint64_t inserted = compstats_InsertNewAt(*(void *)(a2 + 32), *(void *)(a2 + 40), v36, v29, v30, v31, v32, v33);
          if ((inserted & 0x80000000) == 0) {
            return pipeline_PrepareForOpeningComponent((uint64_t *)v42, v14, "fe/fe_clm", (void *)a2);
          }
          return inserted;
        }
LABEL_44:
        uint64_t v7 = 2166366218;
        log_OutPublic(*(void *)(v42 + 32), (uint64_t)"TTSEG", 16000, 0, v16, v17, v18, v19, v40);
      }
    }
  }
  return v7;
}

uint64_t pipeline_disclose_location_of_fe_clm_component(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  if (*(_WORD *)(a2 + 24))
  {
    unint64_t v4 = 0;
    int v5 = 0xFFFF;
    unsigned int v6 = 0xFFFF;
    unsigned int v7 = 0xFFFF;
    do
    {
      uint64_t v8 = *(void *)(*(void *)(a2 + 16) + 8 * v4);
      if (v8)
      {
        if (cstdlib_strcmp(*(const char **)(v8 + 8), "fe/fe_clm"))
        {
          if (cstdlib_strcmp(*(const char **)(v8 + 8), "fe/fe_global"))
          {
            if (!cstdlib_strcmp(*(const char **)(v8 + 8), "sink")
              || !cstdlib_strcmp(*(const char **)(v8 + 8), "feeder"))
            {
              int v5 = (unsigned __int16)v4;
            }
          }
          else
          {
            unsigned int v6 = (unsigned __int16)v4;
          }
        }
        else
        {
          unsigned int v7 = (unsigned __int16)v4;
        }
      }
      ++v4;
    }
    while (v4 < *(unsigned __int16 *)(a2 + 24));
    uint64_t v2 = a1;
    if (v5 != 0xFFFF) {
      return 0;
    }
  }
  else
  {
    unsigned int v6 = 0xFFFF;
    unsigned int v7 = 0xFFFF;
  }
  uint64_t result = paramc_ParamSetUInt(*(void *)(v2 + 40), (uint64_t)"fe_clm_component", 0);
  if ((result & 0x80000000) == 0 && v7 != 0xFFFF)
  {
    if (v6 == 0xFFFF)
    {
      uint64_t v10 = *(void *)(v2 + 40);
      unsigned int v11 = 3;
    }
    else
    {
      uint64_t v10 = *(void *)(v2 + 40);
      if (v6 >= v7) {
        unsigned int v11 = 1;
      }
      else {
        unsigned int v11 = 2;
      }
    }
    return paramc_ParamSetUInt(v10, (uint64_t)"fe_clm_component", v11);
  }
  return result;
}

uint64_t pipeline_disclose_processing_tnplus(uint64_t a1, uint64_t a2)
{
  if (!*(_WORD *)(a2 + 24))
  {
    uint64_t v8 = *(void *)(a1 + 40);
LABEL_14:
    __int16 v9 = "no";
    goto LABEL_15;
  }
  unint64_t v4 = 0;
  int v5 = 0;
  int v6 = 0xFFFF;
  do
  {
    uint64_t v7 = *(void *)(*(void *)(a2 + 16) + 8 * v4);
    if (v7)
    {
      if (cstdlib_strcmp(*(const char **)(v7 + 8), "fe/geene_adapt"))
      {
        if (!cstdlib_strcmp(*(const char **)(v7 + 8), "sink") || !cstdlib_strcmp(*(const char **)(v7 + 8), "feeder")) {
          int v6 = (unsigned __int16)v4;
        }
      }
      else
      {
        int v5 = 1;
      }
    }
    ++v4;
  }
  while (v4 < *(unsigned __int16 *)(a2 + 24));
  if (v6 != 0xFFFF) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 40);
  if (!v5) {
    goto LABEL_14;
  }
  __int16 v9 = "yes";
LABEL_15:

  return paramc_ParamSetStr(v8, (uint64_t)"processingtnplus", v9);
}

uint64_t pipeline_ResourceLoad(uint64_t *a1, int a2, const char *a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  int v35 = 0;
  uint64_t v14 = 2166366215;
  *(void *)&long long v34 = safeh_GetNullHandle();
  *((void *)&v34 + 1) = v15;
  if (a1 && a3)
  {
    if (!a4) {
      a4 = "";
    }
    uint64_t v16 = *a1;
    if (a7)
    {
      *a7 = safeh_GetNullHandle();
      a7[1] = v17;
    }
    uint64_t ResourceOwner = pipeline_FindResourceOwner((uint64_t)a1, a3, &v35);
    if ((ResourceOwner & 0x80000000) != 0)
    {
      uint64_t v30 = ResourceOwner;
      log_OutPublic(*(void *)(v16 + 32), (uint64_t)"TTSEG", 16077, (uint64_t)"%s%s%s%s", v19, v20, v21, v22, "uri");
      return v30;
    }
    else
    {
      char v23 = *(uint64_t (**)(void, void, const char *, const char *, uint64_t, uint64_t, long long *))(v35[2] + 64);
      if (v23)
      {
        uint64_t v24 = v23(v35[3], v35[4], a3, a4, a5, a6, &v34);
        uint64_t v29 = v24;
        if ((v24 & 0x80000000) == 0)
        {
          if (a7) {
            *(_OWORD *)a7 = v34;
          }
          return v29;
        }
        if (!a2 || ((uint64_t v14 = 0, v31 = v24 & 0x1FFF, v31 != 19) ? (v32 = v31 == 24) : (v32 = 1), !v32 && v31 != 1036))
        {
          log_OutPublic(*(void *)(v16 + 32), (uint64_t)"TTSEG", 16038, (uint64_t)"%s%s%s%s%s%s%s%x", v25, v26, v27, v28, "component");
          return v29;
        }
      }
      else
      {
        log_OutPublic(*(void *)(v16 + 32), (uint64_t)"TTSEG", 16039, (uint64_t)"%s%s%s%s%s%s", v19, v20, v21, v22, "component");
      }
    }
  }
  return v14;
}

uint64_t pipeline_ObjClose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 2166366214;
  }
  uint64_t v9 = *(void *)a1;
  if (*(void *)(a1 + 16))
  {
    uint64_t v10 = *(void *)(a1 + 32);
    if (v10)
    {
      compstats_Reset(v10);
      compstats_Start(*(void *)(a1 + 32), *(void *)(a1 + 40), 0, v11, v12, v13, v14, v15);
    }
    __int16 v16 = *(_WORD *)(a1 + 24);
    if (v16)
    {
      uint64_t v17 = 0;
      uint64_t v18 = (unsigned __int16)(v16 - 1) + 2;
      unsigned __int16 v19 = v16 - 1;
      do
      {
        uint64_t v20 = v19;
        uint64_t v21 = *(unsigned __int16 **)(*(void *)(a1 + 16) + 8 * v19);
        if (v21)
        {
          int v22 = *v21;
          BOOL v23 = v22 != 0;
          int v24 = v22 - 1;
          if (v24 != 0 && v23)
          {
            *uint64_t v21 = v24;
          }
          else
          {
            uint64_t NullHandle = safeh_GetNullHandle();
            if (!safeh_HandlesEqual(*((void *)v21 + 3), *((void *)v21 + 4), NullHandle, v26))
            {
              log_OutText(*(void *)(v9 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Close component: %s", v27, v28, v29, *(void *)(*(void *)(*(void *)(a1 + 16) + 8 * v19) + 8));
              uint64_t v35 = *(void *)(a1 + 32);
              if (v35) {
                compstats_Start(v35, *(void *)(a1 + 40), v18, v30, v31, v32, v33, v34);
              }
              unsigned int v36 = *(void **)(*(void *)(a1 + 16) + 8 * v19);
              unsigned int v42 = (*(uint64_t (**)(void, void))(v36[2] + 40))(v36[3], v36[4]);
              uint64_t v43 = *(void *)(a1 + 32);
              if (v43) {
                compstats_Stop(v43, *(void *)(a1 + 40), v18, v37, v38, v39, v40, v41);
              }
              if ((v42 & 0x80000000) != 0)
              {
                log_OutPublic(*(void *)(v9 + 32), (uint64_t)"TTSEG", 16002, (uint64_t)"%s%s%s%x", v38, v39, v40, v41, "component");
                if ((int)v17 >= 0) {
                  uint64_t v17 = v42;
                }
                else {
                  uint64_t v17 = v17;
                }
              }
            }
            uint64_t v44 = *(void *)(*(void *)(a1 + 16) + 8 * v19);
            uint64_t v45 = *(void *)(v44 + 16);
            if (v45)
            {
              int v46 = brk_InterfaceRelease(*(void *)(v9 + 24), v45);
              if (v46 >= 0 || (int)v17 <= -1) {
                uint64_t v17 = v17;
              }
              else {
                uint64_t v17 = v46;
              }
              uint64_t v44 = *(void *)(*(void *)(a1 + 16) + 8 * v19);
            }
            heap_Free(*(void **)(v9 + 8), *(void *)(v44 + 8));
            heap_Free(*(void **)(v9 + 8), *(void *)(*(void *)(a1 + 16) + 8 * v19));
          }
        }
        uint64_t v18 = (v18 - 1);
        --v19;
      }
      while (v20);
    }
    else
    {
      uint64_t v17 = 0;
    }
    uint64_t v48 = *(void *)(a1 + 32);
    if (v48)
    {
      compstats_Stop(v48, *(void *)(a1 + 40), 0, a4, a5, a6, a7, a8);
      compstats_Log(*(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(v9 + 32), "Pipeline Close", *(void *)(a1 + 48), 0, 0);
    }
    heap_Free(*(void **)(v9 + 8), *(void *)(a1 + 16));
  }
  else
  {
    uint64_t v17 = 0;
  }
  uint64_t v49 = *(void *)(a1 + 32);
  if (v49) {
    compstats_ObjClose(v49, *(void *)(a1 + 40));
  }
  if (*(void *)(a1 + 48))
  {
    unsigned __int16 v50 = 0;
    do
    {
      uint64_t v51 = *(void *)(*(void *)(a1 + 48) + 8 * v50);
      if (v51) {
        heap_Free(*(void **)(v9 + 8), v51);
      }
      ++v50;
    }
    while (*(unsigned __int16 *)(a1 + 24) + 3 > v50);
    heap_Free(*(void **)(v9 + 8), *(void *)(a1 + 48));
  }
  uint64_t v52 = *(void *)(a1 + 8);
  if (v52) {
    heap_Free(*(void **)(v9 + 8), v52);
  }
  heap_Free(*(void **)(v9 + 8), a1);
  return v17;
}

uint64_t pipeline_ObjReopen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void **)a1;
  uint64_t v10 = *(char **)(a1 + 8);
  __s2 = 0;
  uint64_t v30 = 0;
  uint64_t v28 = 0;
  log_OutText(v9[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"pipeline_ObjReopen : Begin %s", a6, a7, a8, (uint64_t)v10);
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"pipeline", v10);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"mlset", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"voiceml", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"noclmset", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"shortfragmentforceclm", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"shortfragmentforceclm_value_pipeline", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"extclccfg", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"lidlanguages", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"extraesclang", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"extraesctn", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"typeofsynthesis", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"uselearlyemission", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"pmksync", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"feextcfgdataprefix", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"engine_support_base_release", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"engine_support_point_releases", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"bet7featex_mode", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"bet7tokenconverter_model", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  paramc_ParamRemove(v9[5], (uint64_t)"bet7featex_mode");
  paramc_ParamRemove(v9[5], (uint64_t)"bet7tokenconverter_model");
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"fedatapackaging", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"datapackagename", "");
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  paramc_ParamRemove(v9[5], (uint64_t)"voiceoperatingpoint");
  paramc_ParamRemove(v9[5], (uint64_t)"uselectrawdataversion");
  paramc_ParamRemove(v9[5], (uint64_t)"uselectreductionversion");
  paramc_ParamRemove(v9[5], (uint64_t)"nnpausingthresholdpercent");
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"bet4nodeprunemax", 0);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"bet4beamwidth", 0);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"bet4nodelimit", 0);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"bet4nodeprunemaxunvoiced", 0);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"timbre_baseline", 0x64u);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"pitch_baseline", 0x64u);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"rate_baseline", 0x64u);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"volume_baseline", 0x50u);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_87;
  }
  paramc_ParamRemove(v9[5], (uint64_t)"is_teng");
  paramc_ParamRemove(v9[5], (uint64_t)"mnceosposition");
  paramc_ParamRemove(v9[5], (uint64_t)"basicclcprosody");
  paramc_ParamRemove(v9[5], (uint64_t)"punctmarks");
  paramc_ParamRemove(v9[5], (uint64_t)"addondct_extended_lookup");
  paramc_ParamRemove(v9[5], (uint64_t)"nnpausingoverride");
  paramc_ParamRemove(v9[5], (uint64_t)"liddigitmain");
  if ((brk_TagIteratorOpen(v9[3], v10, "PARAMETERS/*", 1, &v30) & 0x80000000) != 0) {
    goto LABEL_76;
  }
  if ((brk_TagIteratorNext(v30, (uint64_t)&__s2, (uint64_t)&v28) & 0x80000000) == 0)
  {
    int v15 = 0;
    while (1)
    {
      if (!__s2 || !*__s2) {
        goto LABEL_67;
      }
      if (!cstdlib_strcmp("waitfactor", __s2))
      {
        LODWORD(v27) = 1;
        if ((paramc_ParamGetUInt(v9[5], (uint64_t)"waitfactor", (unsigned int *)&v27) & 0x80000000) == 0) {
          uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"waitfactorpipelinebackup", v27);
        }
        if ((v14 & 0x1FFF) == 0xA) {
          goto LABEL_87;
        }
        int v15 = 1;
      }
      if (!__s2 || !*__s2 || !cstdlib_strncmp("audiooutput", __s2, 0xBuLL)) {
        goto LABEL_67;
      }
      if (!cstdlib_strcmp("extraesclang", __s2) || !cstdlib_strcmp("extraesctn", __s2))
      {
        uint64_t v27 = 0;
        if ((paramc_ParamGetStr(v9[5], (uint64_t)"clcpreventhlpactivate", &v27) & 0x80000000) == 0)
        {
          uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"clcpreventhlpactivate", "yes");
          if ((v14 & 0x1FFF) == 0xA) {
            goto LABEL_87;
          }
        }
      }
      __int16 v16 = __s2;
      if (__s2 && *__s2)
      {
        if (!cstdlib_strcmp("waitfactor", __s2))
        {
          LODWORD(v27) = 0;
          if ((paramc_ParamGetUInt(v9[5], (uint64_t)"waitfactorsetbyapi", (unsigned int *)&v27) & 0x80000000) != 0
            || v27 != 1)
          {
            if (v28) {
              uint64_t v20 = v28;
            }
            else {
              uint64_t v20 = "";
            }
            uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)__s2, v20);
          }
          int v19 = v14 & 0x1FFF;
          goto LABEL_66;
        }
        __int16 v16 = __s2;
      }
      if (v28) {
        uint64_t v17 = v28;
      }
      else {
        uint64_t v17 = "";
      }
      uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)v16, v17);
      if ((v14 & 0x1FFF) == 0xA) {
        goto LABEL_87;
      }
      if (cstdlib_strcmp("shortfragmentforceclm", __s2)) {
        goto LABEL_67;
      }
      if (v28) {
        uint64_t v18 = v28;
      }
      else {
        uint64_t v18 = "";
      }
      uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"shortfragmentforceclm_value_pipeline", v18);
      int v19 = v14 & 0x1FFF;
LABEL_66:
      if (v19 == 10) {
        goto LABEL_87;
      }
LABEL_67:
      if ((brk_TagIteratorNext(v30, (uint64_t)&__s2, (uint64_t)&v28) & 0x80000000) != 0)
      {
        uint64_t v21 = vopCheckEngineCompatibility((uint64_t)v9);
        if ((v21 & 0x80000000) == 0)
        {
          if (!v15) {
            goto LABEL_72;
          }
LABEL_75:
          brk_TagIteratorClose(v30);
          uint64_t v30 = 0;
LABEL_76:
          uint64_t v21 = hlp_pipeline_objects_reopen(v9, v10);
          if ((v21 & 0x80000000) == 0)
          {
            uint64_t v21 = pipeline_disclose_location_of_fe_clm_component((uint64_t)v9, a1);
            if ((v21 & 0x80000000) == 0)
            {
              uint64_t v14 = pipeline_disclose_processing_tnplus((uint64_t)v9, a1);
              if ((v14 & 0x80000000) == 0)
              {
                unsigned int v22 = *(unsigned __int16 *)(a1 + 24);
                if (*(_WORD *)(a1 + 24))
                {
                  uint64_t v23 = 0;
                  while (1)
                  {
                    int v24 = *(uint64_t **)(*(void *)(a1 + 16) + 8 * v23);
                    if (*(void *)(v24[2] + 48))
                    {
                      log_OutText(v9[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Reopen component: %s", v11, v12, v13, v24[1]);
                      uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(v24[2] + 48))(v24[3], v24[4]);
                      if ((v14 & 0x80000000) != 0)
                      {
                        log_OutPublic(v9[4], (uint64_t)"TTSEG", 16001, (uint64_t)"%s%s%s%x", v25, v11, v12, v13, "component");
                        goto LABEL_87;
                      }
                      unsigned int v22 = *(unsigned __int16 *)(a1 + 24);
                    }
                    if (++v23 >= (unint64_t)v22) {
                      goto LABEL_87;
                    }
                  }
                }
              }
              goto LABEL_87;
            }
          }
        }
LABEL_86:
        uint64_t v14 = v21;
        goto LABEL_87;
      }
    }
  }
  uint64_t v21 = vopCheckEngineCompatibility((uint64_t)v9);
  if ((v21 & 0x80000000) != 0) {
    goto LABEL_86;
  }
LABEL_72:
  LODWORD(v27) = 1;
  if ((paramc_ParamGetUInt(v9[5], (uint64_t)"waitfactorpipelinebackup", (unsigned int *)&v27) & 0x80000000) != 0) {
    goto LABEL_75;
  }
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"waitfactor", v27);
  if ((v14 & 0x1FFF) != 0xA)
  {
    uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"waitfactorpipelinebackup", v27);
    if ((v14 & 0x1FFF) != 0xA) {
      goto LABEL_75;
    }
  }
LABEL_87:
  log_OutText(v9[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"pipeline_ObjReopen : End (%x)", v11, v12, v13, v14);
  return v14;
}

uint64_t hlp_pipeline_objects_reopen(void *a1, unsigned char *a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  int v24 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v4 = pipeline_create_name_vector_for_query(a1, a2, "COMPONENTS/*", &v21);
  uint64_t v5 = v21;
  if ((v4 & 0x80000000) != 0
    || (pipeline_loc_DetermineEngine((uint64_t)a1, v21, &v24),
        uint64_t v4 = pipeline_create_name_vector_for_query(a1, a2, "OBJECTS/*", &v22),
        (v4 & 0x80000000) != 0)
    || (uint64_t v6 = v22, !v24)
    && (uint64_t v4 = hlp_insert_after((uint64_t)a1, v22, "FE_DCTLKP|fe/fe_dctlkp", "FE_NN|fe/fe_nn", 0), (v4 & 0x80000000) != 0)
    || (uint64_t v4 = hlp_insert_after((uint64_t)a1, v6, "INET|inetspi", "CHARCOUNT|charcount", 0), (v4 & 0x80000000) != 0)
    || (uint64_t v4 = hlp_append((uint64_t)a1, v6), (v4 & 0x80000000) != 0))
  {
    uint64_t v9 = v4;
    goto LABEL_19;
  }
  if (!vector_GetSize(v6))
  {
    uint64_t v9 = 0;
    goto LABEL_19;
  }
  unsigned int v7 = 0;
  int v8 = 0;
  uint64_t v9 = 0;
  while (1)
  {
    if (!vector_GetElemAt(v6, v7, &v23))
    {
LABEL_25:
      uint64_t v9 = 2166366208;
      goto LABEL_19;
    }
    cstdlib_strcpy(__dst, *v23);
    if (cstdlib_strcmp(__dst, "INET|inetspi"))
    {
      uint64_t v10 = cstdlib_strchr(__dst, 124);
      if (!v10) {
        goto LABEL_25;
      }
      *uint64_t v10 = 0;
      if ((objc_GetObject(a1[6], (uint64_t)__dst, &v20) & 0x80000000) == 0) {
        break;
      }
    }
LABEL_16:
    unsigned int v7 = (unsigned __int16)++v8;
    if (vector_GetSize(v6) <= (unsigned __int16)v8) {
      goto LABEL_19;
    }
  }
  uint64_t v14 = v20[1];
  if (!*(void *)(v14 + 48)
    || (log_OutText(a1[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Reopen object: %s", v11, v12, v13, (uint64_t)__dst),
        uint64_t v9 = (*(uint64_t (**)(void, void))(v14 + 48))(v20[2], v20[3]),
        (v9 & 0x80000000) == 0))
  {
    objc_ReleaseObject(a1[6], (uint64_t)__dst);
    goto LABEL_16;
  }
  log_OutPublic(a1[4], (uint64_t)"TTSEG", 16001, (uint64_t)"%s%s%s%x", v15, v16, v17, v18, "component");
  objc_ReleaseObject(a1[6], (uint64_t)__dst);
LABEL_19:
  if (v5) {
    vector_ObjClose(v5);
  }
  if (v22) {
    vector_ObjClose(v22);
  }
  return v9;
}

uint64_t pipeline_FindResourceOwner(uint64_t a1, const char *a2, void *a3)
{
  uint64_t v3 = 2166366215;
  if (a1 && a2 && *a2)
  {
    unint64_t v7 = 0;
    *a3 = 0;
    while (v7 < *(unsigned __int16 *)(a1 + 24))
    {
      uint64_t v19 = 0;
      int v8 = *(void **)(*(void *)(a1 + 16) + 8 * v7);
      uint64_t v9 = *(uint64_t (**)(void, void, uint64_t *))(v8[2] + 56);
      if (v9)
      {
        int v10 = v9(v8[3], v8[4], &v19);
        uint64_t v9 = (uint64_t (*)(void, void, uint64_t *))*a3;
        if ((v10 & 0x80000000) == 0)
        {
          if (v19)
          {
            if (v9) {
              return 0;
            }
            unsigned __int16 v11 = 0;
            while (1)
            {
              uint64_t v12 = v11;
              uint64_t v13 = *(const char **)(v19 + 8 * v11);
              if (!v13) {
                break;
              }
              size_t v14 = cstdlib_strlen(v13);
              if (!cstdlib_strncmp(a2, *(const char **)(v19 + 8 * v12), v14)
                && ((int v16 = a2[v14], v16 != 59) ? (v17 = v16 == 0) : (v17 = 1), v17))
              {
                uint64_t v15 = *(uint64_t (**)(void, void, uint64_t *))(*(void *)(a1 + 16) + 8 * v7);
                *a3 = v15;
              }
              else
              {
                uint64_t v15 = (uint64_t (*)(void, void, uint64_t *))*a3;
              }
              unsigned __int16 v11 = v12 + 1;
              if (v15) {
                return 0;
              }
            }
            uint64_t v9 = 0;
          }
        }
      }
      ++v7;
      if (v9) {
        return 0;
      }
    }
    return 2166366228;
  }
  return v3;
}

uint64_t pipeline_ResourceUnload(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 2166366215;
  if (a1)
  {
    unint64_t v12 = 0;
    uint64_t v13 = *a1;
    uint64_t v8 = 2166366216;
    do
    {
      if (v12 >= *((unsigned __int16 *)a1 + 12)) {
        break;
      }
      size_t v14 = *(void **)(a1[2] + 8 * v12);
      uint64_t v15 = *(uint64_t (**)(void, void, uint64_t, uint64_t))(v14[2] + 72);
      if (v15)
      {
        uint64_t v8 = v15(v14[3], v14[4], a2, a3);
        if ((v8 & 0x80000000) == 0) {
          return v8;
        }
      }
      ++v12;
    }
    while ((v8 & 0x1FFF) == 8);
    if ((v8 & 0x80000000) != 0) {
      log_OutPublic(*(void *)(v13 + 32), (uint64_t)"TTSEG", 16041, (uint64_t)"%s%p%s%x", a5, a6, a7, a8, "handle");
    }
  }
  return v8;
}

uint64_t pipeline_UnloadObjects(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v19 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v21);
  if ((inited & 0x80000000) == 0)
  {
    for (int i = 1; i != 3; ++i)
    {
      int Size = vector_GetSize(a3);
      if (Size)
      {
        unsigned int v7 = Size - 1;
        do
        {
          if (!vector_GetElemAt(a3, v7, &v20)) {
            break;
          }
          if ((objc_GetObject(v21[6], *v20, &v19) & 0x80000000) == 0)
          {
            objc_ReleaseObject(v21[6], *v20);
            if (i == 1)
            {
              int v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v19[1] + 40))(v19[2], v19[3]);
              if (v8 < 0)
              {
                int v13 = v8;
                log_OutPublic(v21[4], (uint64_t)"TTSEG", 16100, (uint64_t)"%s%x%s%s", v9, v10, v11, v12, "lherror");
              }
              else
              {
                int v13 = brk_InterfaceRelease(v21[3], v19[1]);
              }
            }
            else
            {
              int v13 = objc_UnregisterObject(v21[6], *v20);
              if (v13 < 0) {
                log_OutPublic(v21[4], (uint64_t)"TTSEG", 16101, (uint64_t)"%s%x%s%s", v14, v15, v16, v17, "lherror");
              }
            }
            if (v13 >= 0) {
              uint64_t inited = inited;
            }
            else {
              uint64_t inited = v13;
            }
          }
          --v7;
        }
        while (v7 != -1);
      }
    }
  }
  return inited;
}

uint64_t pipeline_fill_CopyPartsString(const char **a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = *a1;
  if (*a1) {
    uint64_t v6 = cstdlib_strlen(*a1) + 1;
  }
  else {
    uint64_t v6 = 1;
  }
  uint64_t result = heap_Alloc(a2, v6);
  *a3 = result;
  if (result)
  {
    if (v5) {
      int v8 = v5;
    }
    else {
      int v8 = "";
    }
    cstdlib_strcpy((char *)result, v8);
    return 1;
  }
  return result;
}

uint64_t *pipeline_fill_ElemFreePartsString(uint64_t *result, void *a2)
{
  if (*result) {
    return heap_Free(a2, *result);
  }
  return result;
}

uint64_t is_not_sink_or_voice_switch(const char *a1)
{
  uint64_t result = cstdlib_strcmp(a1, "sink");
  if (result) {
    return cstdlib_strcmp(a1, "voice_switch") != 0;
  }
  return result;
}

uint64_t is_not_sink_or_msp(const char *a1)
{
  uint64_t result = cstdlib_strcmp(a1, "sink");
  if (result) {
    return cstdlib_strcmp(a1, "fe/fe_msp") != 0;
  }
  return result;
}

BOOL is_not_dspeffects(const char *a1)
{
  return cstdlib_strcmp(a1, "dspeffects") != 0;
}

uint64_t versionGetMajorMinorMaintAndSearchNext(unsigned __int8 *a1, unsigned char *a2, unsigned char *a3, unsigned char *a4, unsigned __int8 **a5)
{
  *a4 = 0;
  uint64_t result = 2166366215;
  *a3 = 0;
  *a2 = 0;
  if (a1)
  {
    int v9 = 0;
    __int16 v10 = 0;
    int v11 = 0;
    for (int i = a1; ; ++i)
    {
      unsigned int v13 = *i;
      BOOL v14 = v13 > 0x2C || ((1 << v13) & 0x100100000001) == 0;
      if (!v14 || v9 < 0) {
        break;
      }
      if (v13 - 48 >= 0xA) {
        int v9 = -2128601081;
      }
      else {
        int v9 = 0;
      }
      if (v13 - 48 >= 0xA) {
        int v15 = v11;
      }
      else {
        int v15 = v11 + 1;
      }
      if ((unsigned __int16)(v10 + 1) <= 2u) {
        int v16 = 0;
      }
      else {
        int v16 = -2128601081;
      }
      if (v13 == 46)
      {
        int v9 = v16;
        ++v10;
      }
      else
      {
        int v11 = v15;
      }
    }
    BOOL v17 = v10 == 2 && (unsigned __int16)v11 >= 3u;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
    if (!v17) {
      unsigned int v20 = -2128601081;
    }
    else {
      unsigned int v20 = 0;
    }
    if (v9 >= 0) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = v9;
    }
    _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), StatusReg);
    if (v9 < 0) {
      return v21;
    }
    while (v13 == 44 || v13 == 32)
    {
      unsigned int v22 = *++i;
      unsigned int v13 = v22;
    }
    if (a5)
    {
      *a5 = i;
      goto LABEL_40;
    }
    if (!*i)
    {
LABEL_40:
      *a2 = cstdlib_atoi(a1);
      uint64_t v23 = cstdlib_strchr((char *)a1, 46);
      if (v23)
      {
        int v24 = v23 + 1;
        *a3 = cstdlib_atoi((unsigned __int8 *)v23 + 1);
        uint64_t v25 = cstdlib_strchr(v24, 46);
        if (v25) {
          *a4 = cstdlib_atoi((unsigned __int8 *)v25 + 1);
        }
      }
      return v21;
    }
  }
  return result;
}

uint64_t voice_switch_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2600476673;
  }
  uint64_t result = 0;
  *a2 = &IVScmp;
  return result;
}

uint64_t vscmp_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v5 = 2600476679;
  int v43 = 0;
  if (a5)
  {
    uint64_t inited = InitRsrcFunction(a3, a4, &v45);
    if ((inited & 0x80000000) != 0)
    {
      return inited;
    }
    else
    {
      *(void *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      log_OutText(*(void *)(v45 + 32), (uint64_t)"VOICESWITCHCMP", 4, 0, (uint64_t)"Entering vscmp_ObjOpen", v10, v11, v12, v41);
      unsigned int v13 = (void *)heap_Calloc(*(void **)(v45 + 8), 1, 928);
      uint64_t v18 = v45;
      if (v13)
      {
        uint64_t v19 = v13;
        v13[1] = a4;
        unsigned char v13[2] = v18;
        void *v13 = a3;
        uint64_t Object = objc_GetObject(*(void *)(v45 + 48), (uint64_t)"SYNTHSTREAM", &v44);
        if ((Object & 0x80000000) != 0)
        {
          uint64_t v26 = Object;
          log_OutPublic(*(void *)(v45 + 32), (uint64_t)"VOICESWITCHCMP", 6002, 0, v21, v22, v23, v24, v42);
        }
        else
        {
          v19[8] = *(void *)(v44 + 8);
          if ((objc_GetObject(*(void *)(v45 + 48), (uint64_t)"COMPQUERY", &v44) & 0x80000000) != 0)
          {
            v19[7] = 0;
            v19[5] = safeh_GetNullHandle();
            v19[6] = v31;
          }
          else
          {
            uint64_t v25 = v44;
            v19[7] = *(void *)(v44 + 8);
            *(_OWORD *)(v19 + 5) = *(_OWORD *)(v25 + 16);
          }
          int UInt = paramc_ParamGetUInt(*(void *)(v45 + 40), (uint64_t)"ppmaxpcreframeblocks", (unsigned int *)&v43);
          unsigned __int16 v33 = v43;
          int v34 = paramc_ParamGetUInt(*(void *)(v45 + 40), (uint64_t)"ppnumframesinblock", (unsigned int *)&v43);
          __int16 v35 = v43;
          v19[3] = 0;
          *((_DWORD *)v19 + 8) = 0;
          uint64_t v36 = nuance_pcre_ObjOpen(a3, a4, (uint64_t)(v19 + 3));
          if ((v36 & 0x80000000) != 0)
          {
            uint64_t v26 = v36;
          }
          else
          {
            if (v34 < 0) {
              __int16 v37 = 50;
            }
            else {
              __int16 v37 = v35;
            }
            if (UInt < 0) {
              unsigned __int16 v38 = 50;
            }
            else {
              unsigned __int16 v38 = v33;
            }
            uint64_t v26 = nuance_pcre_Init((void *)v19[3], v19[4], v38, v37);
            if ((v26 & 0x80000000) == 0)
            {
              int v39 = 865;
LABEL_22:
              *(void *)a5 = v19;
              *(_DWORD *)(a5 + 8) = v39;
              log_OutText(*(void *)(v45 + 32), (uint64_t)"VOICESWITCHCMP", 4, 0, (uint64_t)"Leaving ngwcmp_ObjOpen: %x", v28, v29, v30, v26);
              return 0;
            }
          }
        }
        log_OutPublic(*(void *)(v45 + 32), (uint64_t)"VOICESWITCHCMP", 6001, (uint64_t)"%s%x", v27, v28, v29, v30, "lhError");
        *(void *)a5 = v19;
        *(_DWORD *)(a5 + 8) = 865;
        vscmp_ObjClose(v19, *(void *)(a5 + 8));
        uint64_t v19 = 0;
        int v39 = 0;
        goto LABEL_22;
      }
      log_OutPublic(*(void *)(v45 + 32), (uint64_t)"VOICESWITCHCMP", 6000, 0, v14, v15, v16, v17, v42);
      return 2600476682;
    }
  }
  return v5;
}

uint64_t vscmp_ObjClose(void *a1, int a2)
{
  int v3 = safeh_HandleCheck((uint64_t)a1, a2, 865, 928);
  if (v3 < 0) {
    return 2600476680;
  }
  LODWORD(v7) = v3;
  uint64_t v8 = a1[2];
  log_OutText(*(void *)(v8 + 32), (uint64_t)"VOICESWITCHCMP", 4, 0, (uint64_t)"Entering vscmp_ObjClose", v4, v5, v6, v18);
  uint64_t NullHandle = safeh_GetNullHandle();
  if (!safeh_HandlesEqual(a1[3], a1[4], NullHandle, v10))
  {
    int v11 = nuance_pcre_DeInit((void *)a1[3], a1[4]);
    if ((v11 & 0x80000000) == 0) {
      int v11 = nuance_pcre_ObjClose(a1[3], a1[4]);
    }
    LODWORD(v7) = v11;
  }
  if (a1[7]) {
    objc_ReleaseObject(*(void *)(v8 + 48), (uint64_t)"COMPQUERY");
  }
  int v12 = objc_ReleaseObject(*(void *)(v8 + 48), (uint64_t)"SYNTHSTREAM");
  if (v12 >= 0 || (int)v7 <= -1) {
    uint64_t v7 = v7;
  }
  else {
    uint64_t v7 = v12;
  }
  heap_Free(*(void **)(v8 + 8), (uint64_t)a1);
  log_OutText(*(void *)(v8 + 32), (uint64_t)"VOICESWITCHCMP", 4, 0, (uint64_t)"Leaving vscmp_ObjClose: %x", v14, v15, v16, v7);
  return v7;
}

uint64_t vscmp_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if ((safeh_HandleCheck(a1, a2, 865, 928) & 0x80000000) != 0) {
    return 2600476680;
  }
  synstrmaux_InitStreamOpener(a1 + 72, *(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"VOICESWITCHCMP");
  synstrmaux_RegisterInStream((_WORD *)(a1 + 72), (uint64_t)"text/plain;charset=utf-8", 0, a1 + 896);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 72), (uint64_t)"text/plain;charset=utf-8", a1 + 912);
  uint64_t v8 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 72), *(void *)(a1 + 64), a3, a4);
  if ((v8 & 0x80000000) != 0) {
    vscmp_ProcessEnd(a1, a2);
  }
  return v8;
}

uint64_t vscmp_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  __s2[1] = *MEMORY[0x263EF8340];
  __src = 0;
  __uint64_t n = 0;
  uint64_t v7 = 2600476682;
  strcpy(__s, "\x1B");
  __s2[0] = 0x5C313D736F655CLL;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  *a5 = 1;
  if ((safeh_HandleCheck(a1, a2, 865, 928) & 0x80000000) != 0) {
    return 2600476680;
  }
  if (!*(void *)(a1 + 896) || !*(void *)(a1 + 912))
  {
    uint64_t v7 = 0;
    *a5 = 1;
    return v7;
  }
  uint64_t v8 = *(uint64_t **)(a1 + 16);
  uint64_t v9 = v8[1];
  int v10 = cstdlib_strlen(__s);
  int v11 = (char *)heap_Alloc(v9, (v10 + 1));
  if (v11)
  {
    int v12 = v11;
    cstdlib_strcpy(v11, __s);
    int v13 = cstdlib_strlen(v12);
    uint64_t v14 = v8[1];
    int v15 = cstdlib_strlen((const char *)__s2);
    uint64_t v16 = (char *)heap_Alloc(v14, (v13 + v15 + 1));
    if (!v16)
    {
      heap_Free((void *)v8[1], (uint64_t)v12);
      return v7;
    }
    uint64_t v17 = v16;
    cstdlib_strcpy(v16, v12);
    cstdlib_strcat(v17, (const char *)__s2);
    uint64_t v18 = (*(uint64_t (**)(void, void, char *, size_t *))(*(void *)(a1 + 64) + 144))(*(void *)(a1 + 896), *(void *)(a1 + 904), (char *)&__n + 4, &__n);
    if ((v18 & 0x80000000) == 0)
    {
      if (HIDWORD(__n))
      {
        uint64_t v18 = (*(uint64_t (**)(void, void, char **, char *))(*(void *)(a1 + 64) + 88))(*(void *)(a1 + 896), *(void *)(a1 + 904), &__src, (char *)&__n + 4);
        if ((v18 & 0x80000000) == 0)
        {
          uint64_t v19 = (char *)heap_Calloc((void *)v8[1], 1, (HIDWORD(__n) + 1));
          unsigned int v20 = v19;
          if (!v19)
          {
            uint64_t v28 = 0;
            uint64_t v18 = 2600476682;
            goto LABEL_28;
          }
          cstdlib_strncpy(v19, __src, HIDWORD(__n));
          v20[HIDWORD(__n)] = 0;
          unsigned int v21 = HIDWORD(__n);
          if (!HIDWORD(__n))
          {
            uint64_t v28 = 0;
            goto LABEL_73;
          }
          int v53 = 0;
          uint64_t v52 = 0;
          uint64_t v18 = paramc_ParamGet(v8[5], (uint64_t)"fullescvoiceseqdata", &v52, &v53);
          if ((v18 & 0x80000000) == 0)
          {
            unsigned int v50 = v21;
            uint64_t v22 = *v52;
            cstdlib_memset(__b, -1, 0x190uLL);
            signed int v23 = nuance_pcre_exec(*(void **)(a1 + 24), *(void *)(a1 + 32), v22, 0, v20, SHIDWORD(__n), 0, 0xA000u, __b, 100);
            signed int v24 = v23;
            uint64_t v25 = __b[0];
            BOOL v27 = v23 >= 0 && __b[0] == 0;
            if (v23 < 0)
            {
              signed int v30 = v23;
              uint64_t v31 = nuance_pcre_ErrorToLhError(v23);
              if (v31 >> 20 == 2213)
              {
                uint64_t v28 = 0;
                uint64_t v18 = 0;
                int v36 = v31 & 0x1FFF;
                if (v36 != 7778)
                {
                  signed int v24 = v30;
                  if (v36 == 20) {
                    goto LABEL_63;
                  }
                  if (v36 == 10)
                  {
                    uint64_t v37 = v8[4];
                    uint64_t v38 = 11002;
                    int v39 = 0;
                  }
                  else
                  {
                    uint64_t v47 = "lhError";
                    int v39 = "%s%x";
                    uint64_t v37 = v8[4];
                    uint64_t v38 = 11027;
                  }
                  log_OutPublic(v37, (uint64_t)"VOICESWITCHCMP", v38, (uint64_t)v39, v32, v33, v34, v35, v47);
                  uint64_t v18 = 0;
                  uint64_t v28 = 0;
                }
              }
              else
              {
                uint64_t v28 = 0;
                uint64_t v18 = v31;
              }
              signed int v24 = v30;
              goto LABEL_63;
            }
            if (v62 == v61)
            {
              uint64_t v28 = 0;
LABEL_63:
              uint64_t v25 = HIDWORD(__n);
LABEL_64:
              if (v25)
              {
                if (v24 != -12 || __n)
                {
                  uint64_t v46 = (*(uint64_t (**)(void, void, void **, uint64_t))(*(void *)(a1 + 64) + 112))(*(void *)(a1 + 912), *(void *)(a1 + 920), &v55, v25);
                  if ((v46 & 0x80000000) != 0
                    || (cstdlib_memcpy(v55, v20, v25),
                        uint64_t v46 = (*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 64) + 120))(*(void *)(a1 + 912), *(void *)(a1 + 920), v25), (v46 & 0x80000000) != 0))
                  {
                    uint64_t v18 = v46;
                  }
                  else
                  {
                    uint64_t v18 = (*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 64) + 96))(*(void *)(a1 + 896), *(void *)(a1 + 904), v25);
                    if ((v18 & 0x80000000) == 0 && HIDWORD(__n) < v50 && *a5 != 3) {
                      *a5 = 2;
                    }
                  }
                  goto LABEL_28;
                }
                goto LABEL_74;
              }
LABEL_73:
              if (!__n) {
                goto LABEL_74;
              }
LABEL_28:
              heap_Free((void *)v8[1], (uint64_t)v17);
              heap_Free((void *)v8[1], (uint64_t)v12);
              if (v20) {
                heap_Free((void *)v8[1], (uint64_t)v20);
              }
              if (v28) {
                heap_Free((void *)v8[1], (uint64_t)v28);
              }
              return v18;
            }
            if (!v27)
            {
              uint64_t v28 = 0;
              HIDWORD(__n) = __b[0];
              goto LABEL_64;
            }
            uint64_t v49 = v61;
            signed int v48 = v23;
            int v51 = 0;
            HIDWORD(__n) = v62 + 1;
            int v40 = v62;
            uint64_t v41 = (char *)heap_Alloc(v8[1], (v62 + 1));
            uint64_t v28 = v41;
            if (v41)
            {
              cstdlib_memcpy(v41, &v20[v49], (v40 - v49));
              v28[(v40 - v49)] = 0;
              unsigned int v42 = vs_trim_voice(v28);
              if (!cstdlib_strcmp((const char *)v42, "(pop)") || !cstdlib_strcmp((const char *)v42, "(push)"))
              {
                cstdlib_strcpy(__dst, (const char *)v42);
LABEL_51:
                cstdlib_memset(v20, 32, HIDWORD(__n));
                if (!v51) {
                  goto LABEL_58;
                }
                size_t v44 = cstdlib_strlen(__dst);
                if (v44 < HIDWORD(__n))
                {
                  size_t v45 = cstdlib_strlen(__dst);
                  cstdlib_memcpy(v20, __dst, v45);
                }
                if (v51)
                {
                  if ((paramc_ParamGetStr(v8[5], (uint64_t)"voice", &v54) & 0x80000000) == 0 && v54)
                  {
                    paramc_ParamSetStr(v8[5], (uint64_t)"pipelineswitchvoice", v54);
                    uint64_t v18 = paramc_ParamSetStr(v8[5], (uint64_t)"vsvoicetagwithlangunknow", __dst);
                  }
                }
                else
                {
LABEL_58:
                  paramc_ParamSetStr(v8[5], (uint64_t)"pipelineswitchvoice", __dst);
                  uint64_t v18 = paramc_ParamRemove(v8[5], (uint64_t)"vsvoicetagwithlangunknow");
                  *a5 = 3;
                }
                signed int v24 = v48;
                goto LABEL_63;
              }
              uint64_t best_matching_voice = vs_find_best_matching_voice((void *)a1, (char *)v42, __dst, &v51);
              if ((best_matching_voice & 0x80000000) == 0)
              {
                uint64_t v18 = 0;
                goto LABEL_51;
              }
              uint64_t v7 = best_matching_voice;
            }
            uint64_t v18 = v7;
            goto LABEL_28;
          }
LABEL_27:
          uint64_t v28 = 0;
          goto LABEL_28;
        }
      }
      else
      {
        if (!__n)
        {
          unsigned int v20 = 0;
          uint64_t v28 = 0;
LABEL_74:
          *a5 = 0;
          goto LABEL_28;
        }
        uint64_t v18 = synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 72), *(void *)(a1 + 64));
      }
    }
    unsigned int v20 = 0;
    goto LABEL_27;
  }
  return v7;
}

uint64_t vscmp_ProcessEnd(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 865, 928) & 0x80000000) != 0) {
    return 2600476680;
  }
  uint64_t v3 = *(void *)(a1 + 64);

  return synstrmaux_CloseStreams((_WORD *)(a1 + 72), v3);
}

unsigned __int8 *vs_trim_voice(const char *a1)
{
  uint64_t v1 = a1;
  unsigned int v2 = cstdlib_strlen(a1);
  uint64_t v3 = (unsigned __int8 *)&v1[v2];
  uint64_t v4 = v2;
  while (1)
  {
    unsigned int v6 = *--v3;
    unsigned __int8 v5 = v6;
    uint64_t v7 = (1 << v6) & 0x100002600;
    BOOL v8 = v6 > 0x20 || v7 == 0;
    if (v8 && !cstdlib_iscntrl(v5)) {
      break;
    }
    *uint64_t v3 = 0;
    if (v4 == 1) {
      return v3;
    }
  }
  while (1)
  {
    unsigned int v9 = *(unsigned __int8 *)v1;
    BOOL v10 = v9 > 0x20 || ((1 << v9) & 0x100002600) == 0;
    if (v10 && !cstdlib_iscntrl(v9)) {
      break;
    }
    ++v1;
  }
  return (unsigned __int8 *)v1;
}

uint64_t vs_find_best_matching_voice(void *a1, char *__s, char *a3, _DWORD *a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v4 = 2600476681;
  uint64_t v11 = 0;
  if (!a3) {
    return 2600476679;
  }
  *a3 = 0;
  if (__s)
  {
    if (cstdlib_strchr(__s, 58))
    {
      uint64_t v4 = 0;
      if ((paramc_ParamGetStr(*(void *)(a1[2] + 40), (uint64_t)"voice", &v11) & 0x80000000) == 0 && v11)
      {
        int v16 = 0;
        long long v14 = 0u;
        long long v15 = 0u;
        memset(v13, 0, sizeof(v13));
        memset(__b, 0, sizeof(__b));
        cstdlib_memset(__b, 0, 0x154uLL);
        VoiceParamExtract_0(__s, "lang", (char *)v13);
        VoiceParamExtract_0(__s, "gender", (char *)&v13[6] + 8);
        VoiceParamExtract_0(__s, "ietf", (char *)v13 + 8);
        VoiceParamExtract_0(__s, "age", (char *)&v14 + 4);
        VoiceParamExtract_0(__s, "model", (char *)&v13[7] + 12);
        if (cstdlib_strcmp((const char *)v13, "unknown"))
        {
          for (uint64_t i = -1;
                (((*(uint64_t (**)(void, void, void, void, _OWORD *, char *, uint64_t))(a1[7] + 136))(a1[5], a1[6], *(void *)(a1[2] + 24), *(void *)(a1[2] + 40), __b, a3, 512) & 0x80000000) != 0|| !cstdlib_strlen(a3))&& i;
                ++i)
          {
            if (cstdlib_strlen((const char *)v13) == 3)
            {
              cstdlib_strcpy((char *)&v15, (const char *)v13);
              BYTE2(v15) = 120;
              LOBYTE(v13[0]) = 0;
            }
          }
        }
        else
        {
          if (a4) {
            *a4 = 1;
          }
          if (cstdlib_strlen(__s) + 5 <= 0x1FF)
          {
            cstdlib_strcpy(a3, "\x1B\\lang=");
            cstdlib_strcat(a3, "vceunkn");
            if (BYTE8(v13[6]))
            {
              cstdlib_strcat(a3, ",gender:");
              cstdlib_strcat(a3, (const char *)&v13[6] + 8);
            }
            if (BYTE4(v14))
            {
              cstdlib_strcat(a3, ",age:");
              cstdlib_strcat(a3, (const char *)&v14 + 4);
            }
            if (BYTE12(v13[7]))
            {
              cstdlib_strcat(a3, ",model:");
              cstdlib_strcat(a3, (const char *)&v13[7] + 12);
            }
            cstdlib_strcat(a3, "\\"");
          }
        }
        return 0;
      }
    }
    else if (cstdlib_strlen(__s) <= 0x1FF)
    {
      cstdlib_strcpy(a3, __s);
      return 0;
    }
  }
  return v4;
}

size_t VoiceParamExtract_0(const char *a1, const char *a2, char *a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v13 = 0;
  size_t result = cstdlib_strlen(a1);
  if (result <= 0x1FF)
  {
    cstdlib_strcpy(__dst, a1);
    size_t result = (size_t)strhelper_SafeStrtok((uint64_t)__dst, "{}();,", &v13);
    if (result)
    {
      uint64_t v7 = (char *)result;
      while (1)
      {
        BOOL v8 = cstdlib_strchr(v7, 58);
        if (v8)
        {
          unsigned int v9 = v8;
          size_t v10 = cstdlib_strlen(a2);
          size_t result = cstdlib_strncmp(v7, a2, v10);
          if (!result) {
            break;
          }
        }
        size_t result = (size_t)strhelper_SafeStrtok((uint64_t)__dst, "{}();,", &v13);
        uint64_t v7 = (char *)result;
        if (!result) {
          return result;
        }
      }
      int v12 = v9[1];
      uint64_t v11 = v9 + 1;
      if (v12) {
        return (size_t)cstdlib_strcpy(a3, v11);
      }
    }
  }
  return result;
}

uint64_t UnloadTuningResources(void *a1)
{
  uint64_t v2 = a1[1797];
  if (v2)
  {
    uint64_t result = 0;
    uint64_t v4 = &a1[2 * v2 + 1668];
    while (1)
    {
      uint64_t v5 = *(v4 - 1);
      if (v5)
      {
        uint64_t result = (*(uint64_t (**)(void, void, uint64_t, void))(a1[1668] + 80))(a1[1666], a1[1667], v5, *v4);
        if ((result & 0x80000000) != 0) {
          break;
        }
      }
      v4 -= 2;
      if (!--v2) {
        goto LABEL_8;
      }
    }
  }
  else
  {
    uint64_t result = 0;
LABEL_8:
    a1[1797] = 0;
  }
  return result;
}

uint64_t ELQSSMLStartParsing(uint64_t a1, unsigned __int16 *a2, unint64_t a3, int a4, int a5)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni) {
    return 2375032834;
  }
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  *(_OWORD *)uint64_t __dst = 0u;
  long long v26 = 0u;
  ELQSSMLReset(a1);
  if (a5)
  {
    __dst[0] = 0;
  }
  else
  {
    uint64_t result = ELQXMLGetEncodingFromHeader(*(void *)(a1 + 2624), __dst, a2, a3, a4);
    if (result) {
      return result;
    }
    if (__dst[0]) {
      goto LABEL_11;
    }
  }
  Name = TxtEncodingGetName(a4);
  if (!Name || !*Name)
  {
    __sprintf_chk(v24, 0, 0x200uLL, "Invalid or unsupported TextEncoding in parsing XML file");
LABEL_13:
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, (uint64_t)"%s%s", v12, v13, v14, v15, "SSML parser error");
    return 2375032839;
  }
  cstdlib_strcpy(__dst, Name);
LABEL_11:
  if (ELQXMLSetEncoding(*(void *)(a1 + 2624)))
  {
    __sprintf_chk(v24, 0, 0x200uLL, "Unknown XML encoding \"%s\"");
    goto LABEL_13;
  }
  uint64_t result = ELQXMLSetCallbacks(*(void *)(a1 + 2624));
  if (!result)
  {
    uint64_t result = ELQXMLSetNamespaceCallbacks(*(void *)(a1 + 2624));
    if (!result)
    {
      uint64_t result = SetInitialVoiceAndLanguage(a1);
      if (!result)
      {
        *(void *)a1 = 0;
        uint64_t v16 = *(void *)(a1 + 13264);
        uint64_t v19 = *(void *)(v16 + 8);
        uint64_t v18 = (void *)(v16 + 8);
        uint64_t v17 = v19;
        if (v19) {
          heap_Free(***(void ****)(a1 + 13264), v17);
        }
        *uint64_t v18 = 0;
        v18[1] = 0;
        uint64_t v20 = *(void *)(a1 + 13272);
        uint64_t v23 = *(void *)(v20 + 8);
        uint64_t v22 = (void *)(v20 + 8);
        uint64_t v21 = v23;
        if (v23) {
          heap_Free(***(void ****)(a1 + 13272), v21);
        }
        uint64_t result = 0;
        *uint64_t v22 = 0;
        v22[1] = 0;
        *(_DWORD *)(a1 + 2084) = 0;
        *(void *)(a1 + 2096) = 0;
        *(unsigned char *)(a1 + 2104) = 0;
      }
    }
  }
  return result;
}

uint64_t ELQSSMLIni(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  uint64_t v8 = ELQXMLGetControllerFromParser(a3);
  uint64_t v56 = 0;
  uint64_t v9 = heap_Alloc(*(void *)(a1 + 8), 14408);
  if (!v9)
  {
    uint64_t v25 = 2375032842;
LABEL_10:
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"LIGHTSSML", 1923, (uint64_t)"%s%s", v10, v11, v12, v13, "SSML parser error");
    return v25;
  }
  uint64_t v14 = v9;
  *(void *)(v9 + 1552) = ELQSSMLDelete;
  *(void *)(v9 + 13320) = 0;
  uint64_t v15 = v9 + 13228;
  *(void *)(v9 + 12992) = a1;
  uint64_t v16 = (unsigned char *)(v9 + 12968);
  *(_DWORD *)(v9 + 2084) = 0;
  *(void *)(v9 + 2096) = 0;
  *(unsigned char *)(v9 + 2104) = 0;
  *(_OWORD *)(v9 + 2640) = 0u;
  *(_OWORD *)(v9 + 2656) = 0u;
  *(void *)(v9 + 2624) = a3;
  *(_DWORD *)(v9 + 8) = 3;
  *(unsigned char *)(v9 + 13196) = 0;
  *(unsigned char *)(v9 + 13228) = 0;
  *(unsigned char *)(v9 + 13128) = 0;
  *(unsigned char *)(v9 + 13000) = 0;
  cstdlib_strcpy((char *)(v9 + 13164), "normal");
  *(_DWORD *)(v14 + 2616) = 0;
  *(unsigned char *)(v15 + 52) = 0;
  *(_DWORD *)(v14 + 13312) = 0;
  *(_DWORD *)(v14 + 1568) = 100;
  *(void *)(v14 + 1560) = 0x6400000050;
  cstdlib_strcpy((char *)(v14 + 1572), "default");
  *(_DWORD *)(v14 + 2088) = 100;
  uint64_t v17 = *(void *)(v14 + 12992);
  uint64_t v19 = *(void *)(v17 + 8);
  uint64_t v18 = v17 + 8;
  uint64_t v20 = (void *)heap_Alloc(v19, 24);
  if (!v20)
  {
    uint64_t v25 = 2375032842;
    *(void *)(v14 + 13264) = 0;
LABEL_9:
    heap_Free(*(void **)(a1 + 8), v14);
    goto LABEL_10;
  }
  v20[1] = 0;
  v20[2] = 0;
  *uint64_t v20 = v18;
  *(void *)(v14 + 13264) = v20;
  uint64_t v21 = *(void *)(v14 + 12992);
  uint64_t v23 = *(void *)(v21 + 8);
  uint64_t v22 = v21 + 8;
  signed int v24 = (void *)heap_Alloc(v23, 24);
  if (!v24)
  {
    uint64_t v25 = 2375032842;
    *(void *)(v14 + 13272) = 0;
    DynStringDestroy(*(void ***)(v14 + 13264));
    goto LABEL_9;
  }
  v24[1] = 0;
  v24[2] = 0;
  *signed int v24 = v22;
  *(void *)(v14 + 13272) = v24;
  *(void *)(v14 + 2632) = a4;
  *(void *)(v14 + 2704) = 0;
  *(void *)(v14 + 12984) = 0;
  *(void *)(v14 + 2672) = 0;
  *(void *)(v14 + 2688) = 0;
  *(void *)(v14 + 2680) = 0;
  *(_DWORD *)(v14 + 2716) = 4;
  *(void *)(v14 + 2720) = 0;
  if (v8) {
    ELQXMLGetNamespaceSeparator(v8, v16);
  }
  else {
    *uint64_t v16 = 0;
  }
  *(void *)(v14 + 16) = 0;
  *(void *)(v14 + 24) = 0;
  long long v26 = (unsigned char *)(v14 + 2728);
  uint64_t v27 = 10;
  do
  {
    *long long v26 = 0;
    v26[512] = 0;
    v26 += 1024;
    --v27;
  }
  while (v27);
  uint64_t v28 = 0;
  *(void *)(v14 + 2720) = 0;
  *(void *)(v14 + 1552) = ELQSSMLIni;
  long long v29 = "auxiliary";
  while (1)
  {
    if (*(void *)(v14 + 16))
    {
      uint64_t v30 = 0;
      unsigned int v31 = 1;
      while (LH_stricmp(*(char **)(v14 + 24 * v30 + 24), v29))
      {
        uint64_t v30 = v31;
        uint64_t v32 = v14 + 24 * v31;
        uint64_t v34 = *(void *)(v32 + 16);
        long long v33 = (void *)(v32 + 16);
        ++v31;
        if (!v34) {
          goto LABEL_21;
        }
      }
      uint64_t v25 = 2375032839;
      goto LABEL_29;
    }
    LODWORD(v30) = 0;
    unsigned int v31 = 1;
    long long v33 = (void *)(v14 + 16);
LABEL_21:
    uint64_t v35 = *(void *)(*(void *)(v14 + 12992) + 8);
    size_t v36 = cstdlib_strlen(v29);
    long long v37 = (char *)heap_Alloc(v35, v36 + 1);
    *(void *)(v14 + 24 * v30 + 24) = v37;
    if (v37)
    {
      cstdlib_strcpy(v37, v29);
      uint64_t v25 = tinystack_Ini(*(void *)(v14 + 12992), 40, v33);
      uint64_t v38 = v14 + 24 * v31;
      *(void *)(v38 + 16) = 0;
      *(void *)(v38 + 24) = 0;
    }
    else
    {
      *(_DWORD *)(v14 + 2084) = -1919934454;
      cstdlib_strcpy((char *)(v14 + 2104), "Out of Memory");
      ELQXMLGetCurrentLineNumber(*(void *)(v14 + 2624));
      uint64_t v25 = *(unsigned int *)(v14 + 2084);
    }
    if (v25) {
      goto LABEL_29;
    }
    if (++v28 == 19) {
      break;
    }
    long long v29 = ELQSSMLIni_StacksName[v28];
    if (*(uint64_t (**)())(v14 + 1552) != ELQSSMLIni)
    {
      uint64_t v25 = 2375032834;
LABEL_29:
      __sprintf_chk(v57, 0, 0x200uLL, "Unable to handle XML attribute \"%s\". Out of memory.\n", v29);
      log_OutPublic(*(void *)(*(void *)(v14 + 12992) + 32), (uint64_t)"LIGHTSSML", 1441, (uint64_t)"%s%s", v39, v40, v41, v42, "SSML parser error");
      ELQSSMLDelete((void *)v14);
      return v25;
    }
  }
  if (ELQXMLSetUnknownEncodingHandler(*(void *)(v14 + 2624)))
  {
    __sprintf_chk(v57, 0, 0x200uLL, "Unable to set unknown encoding handler");
    log_OutPublic(*(void *)(*(void *)(v14 + 12992) + 32), (uint64_t)"LIGHTSSML", 1441, (uint64_t)"%s%s", v44, v45, v46, v47, "SSML parser error");
    ELQSSMLDelete((void *)v14);
    return 2375032839;
  }
  else
  {
    *(void *)(v14 + 13344) = 0;
    *(void *)(v14 + 13328) = safeh_GetNullHandle();
    *(void *)(v14 + 13336) = v48;
    if ((objc_GetObject(*(void *)(*(void *)(v14 + 12992) + 48), (uint64_t)"TTSEG", &v56) & 0x80000000) != 0)
    {
      log_OutPublic(*(void *)(*(void *)(v14 + 12992) + 32), (uint64_t)"LIGHTSSML", 1441, 0, v49, v50, v51, v52, v55);
    }
    else
    {
      uint64_t v53 = v56;
      *(_OWORD *)(v14 + 13328) = *(_OWORD *)(v56 + 16);
      *(void *)(v14 + 13344) = *(void *)(v53 + 8);
    }
    *(void *)(v14 + 13352) = safeh_GetNullHandle();
    *(void *)(v14 + 13360) = v54;
    *(void *)(v14 + 14376) = 0;
    *(void *)(v14 + 1552) = ELQSSMLIni;
    uint64_t v25 = 0;
    if (a2) {
      *a2 = v14;
    }
  }
  return v25;
}

uint64_t ELQSSMLReset(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(result + 1552) == ELQSSMLIni)
    {
      uint64_t v2 = *(void *)(result + 13264);
      uint64_t v5 = *(void *)(v2 + 8);
      uint64_t v4 = (void *)(v2 + 8);
      uint64_t v3 = v5;
      if (v5) {
        heap_Free(***(void ****)(result + 13264), v3);
      }
      *uint64_t v4 = 0;
      v4[1] = 0;
      uint64_t v6 = *(void *)(v1 + 13272);
      uint64_t v9 = *(void *)(v6 + 8);
      uint64_t v8 = (void *)(v6 + 8);
      uint64_t v7 = v9;
      if (v9) {
        heap_Free(***(void ****)(v1 + 13272), v7);
      }
      *uint64_t v8 = 0;
      v8[1] = 0;
      ELQXMLReset(*(void *)(v1 + 2624));
      uint64_t v10 = *(void *)(v1 + 16);
      if (v10)
      {
        unsigned int v11 = 1;
        do
        {
          tinystack_Reset(v10);
          uint64_t v10 = *(void *)(v1 + 24 * v11++ + 16);
        }
        while (v10);
      }
      unint64_t v12 = *(void *)(v1 + 2720);
      if (v12)
      {
        uint64_t v13 = (unsigned char *)(v1 + 2728);
        unsigned int v14 = 1;
        do
        {
          unsigned char *v13 = 0;
          v13[512] = 0;
          v13 += 1024;
        }
        while (v12 > v14++);
      }
      *(void *)(v1 + 2720) = 0;
      hashtable_ObjClose(*(void **)(v1 + 12984));
      *(void *)(v1 + 12984) = 0;
      *(_DWORD *)(v1 + 1568) = 100;
      *(void *)(v1 + 1560) = 0x6400000050;
      *(_DWORD *)(v1 + 2088) = 100;
      uint64_t v16 = *(void *)(v1 + 2672);
      return ELQMemorySlotReset(v16);
    }
  }
  return result;
}

uint64_t SSMLstartElement(uint64_t result, char *__s, uint64_t *a3)
{
  if (*(_DWORD *)(result + 2084)) {
    return result;
  }
  uint64_t v5 = result;
  if (!*(void *)result)
  {
    *(_DWORD *)(result + 8) = 3;
    if (SSMLstricmpElement(result, __s, "speak"))
    {
      uint64_t result = LH_stricmp(__s, "text");
      if (result)
      {
        *(_DWORD *)(v5 + 2084) = -1919926671;
        cstdlib_strcpy((char *)(v5 + 2104), "Fatal syntax error");
        uint64_t result = ELQXMLGetCurrentLineNumber(*(void *)(v5 + 2624));
        goto LABEL_17;
      }
      int v8 = 2;
    }
    else
    {
      uint64_t result = *a3;
      if (*a3)
      {
        unsigned int v6 = 1;
        do
        {
          if (!LH_stricmp((char *)result, "version"))
          {
            uint64_t v7 = (const char *)a3[v6];
            if (v7)
            {
              if (!cstdlib_strcmp(v7, "1.0")) {
                *(_DWORD *)(v5 + 8) = 0;
              }
            }
          }
          uint64_t result = a3[v6 + 1];
          v6 += 2;
        }
        while (result);
      }
      int v8 = 1;
    }
    *(_DWORD *)(v5 + 8) = v8;
  }
LABEL_17:
  if (*(_DWORD *)(v5 + 8) <= 1u)
  {
    uint64_t result = (uint64_t)SSML10StartConvert(v5, __s, (uint64_t)a3);
    *(_DWORD *)(v5 + 2084) = result;
  }
  ++*(void *)v5;
  return result;
}

uint64_t SSMLendElement(uint64_t result, char *a2)
{
  if (!*(_DWORD *)(result + 2084))
  {
    uint64_t v2 = result;
    if (*(_DWORD *)(result + 8) <= 1u)
    {
      uint64_t result = SSML10EndConvert(result, a2);
      *(_DWORD *)(v2 + 2084) = result;
    }
    --*(void *)v2;
  }
  return result;
}

char *SSMLCharacterDataHandlerStandard(char *result, char *a2, int a3)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  int v36 = *((_DWORD *)result + 679);
  if (!a3) {
    return result;
  }
  uint64_t v3 = (uint64_t)result;
  if (*((_DWORD *)result + 521)) {
    return result;
  }
  size_t v5 = a3;
  unsigned int v6 = (char *)ELQMemorySlotReserve(*((void *(***)(uint64_t, uint64_t, int))result + 334), a3 + 1);
  if (!v6)
  {
    *(_DWORD *)(v3 + 2084) = -1919934454;
    cstdlib_strcpy((char *)(v3 + 2104), "Out of Memory");
    uint64_t v15 = *(void *)(v3 + 2624);
    return (char *)ELQXMLGetCurrentLineNumber(v15);
  }
  uint64_t v7 = v6;
  uint64_t v35 = 0;
  uint64_t v8 = XMLGetStack(v3, "auxiliary");
  if (!v8)
  {
    log_OutPublic(*(void *)(*(void *)(v3 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v9, v10, v11, v12, "SSML parser error");
    *(_DWORD *)(v3 + 2084) = -1919934462;
    cstdlib_strcpy((char *)(v3 + 2104), "SSML Stack unavailable");
    return (char *)ELQXMLGetCurrentLineNumber(*(void *)(v3 + 2624));
  }
  uint64_t v13 = v8;
  uint64_t v37 = 0;
  SSMLViewOnLangFailureFromStack(v3, &v36);
  int v14 = v36;
  if (v36 == 4) {
    int v14 = *(_DWORD *)(v3 + 2716);
  }
  uint64_t result = (char *)tinystack_View(v13, &v35);
  if ((v35 & 8) != 0) {
    return SSMLFallbackStringHandler((char *)v3, a2, v5);
  }
  if ((v35 & 0x10) != 0) {
    return result;
  }
  if ((v35 & 0x4000) == 0)
  {
    if (v14 == 1) {
      return result;
    }
    goto LABEL_19;
  }
  uint64_t v16 = XMLGetStack(v3, "audio");
  tinystack_View(v16, &v37);
  if (v37 == 1) {
    return SSMLFallbackStringHandler((char *)v3, a2, v5);
  }
LABEL_19:
  cstdlib_strncpy(v7, a2, v5);
  v7[v5] = 0;
  if (*(_DWORD *)(v3 + 13312))
  {
    int v17 = *v7;
    if (*v7)
    {
      uint64_t v18 = 0;
      uint64_t v19 = v7;
      do
      {
        if (v17 == 44)
        {
          if (v18)
          {
            if (v7[v18 - 1] - 48 <= 9)
            {
              uint64_t v20 = 1;
              do
                unsigned int v21 = v19[v20++] - 48;
              while (v21 < 0xA);
              int v22 = v20 - 2;
              if (v22)
              {
                if (v22 != 3) {
                  *uint64_t v19 = 46;
                }
              }
            }
          }
        }
        ++v18;
        int v23 = *++v19;
        int v17 = v23;
      }
      while (v23);
    }
  }
  signed int v24 = (char *)(v3 + 13280);
  if (!*(unsigned char *)(v3 + 13280)) {
    return (char *)(*(uint64_t (**)(char *, void))(v3 + 2640))(v7, *(void *)(v3 + 2648));
  }
  uint64_t v38 = 0;
  BOOL v25 = *(unsigned char *)(v3 + 13128) != 101 || *(unsigned char *)(v3 + 13129) != 110 || *(unsigned __int8 *)(v3 + 13130) != 117;
  uint64_t result = strhelper_SafeStrtok((uint64_t)v7, " \t\n", &v38);
  if (result)
  {
    long long v26 = result;
    do
    {
      char v42 = 0;
      v43[0] = 0;
      if (cstdlib_strlen(v26) > 0xC) {
        goto LABEL_56;
      }
      unint64_t v40 = 0;
      unint64_t v41 = 0;
      unint64_t v39 = 0;
      if (!ExtractDate(v24, v26, &v41, &v40, &v39, 0, &v42, 0)) {
        goto LABEL_56;
      }
      unint64_t v27 = v42 == 47 ? 0 : 80;
      if (!ExtractDate(v24, v26, &v41, &v40, &v39, 1, &v42, v27)) {
        goto LABEL_56;
      }
      int v28 = v41;
      if (v41 && v40)
      {
        if (v25) {
          int v29 = v41;
        }
        else {
          int v29 = v40;
        }
        if (v25) {
          int v28 = v40;
        }
        int v30 = __sprintf_chk(v43, 0, 0x20uLL, "%d/%d", v29, v28);
        if (v39) {
          sprintf(&v43[v30], "/%d", v39);
        }
      }
      if (v43[0])
      {
        unsigned int v31 = *(void (**)(char *, uint64_t))(v3 + 2640);
        if (v31)
        {
          uint64_t v32 = *(void *)(v3 + 2648);
          long long v33 = v43;
          goto LABEL_58;
        }
      }
      else
      {
LABEL_56:
        unsigned int v31 = *(void (**)(char *, uint64_t))(v3 + 2640);
        if (v31)
        {
          uint64_t v32 = *(void *)(v3 + 2648);
          long long v33 = v26;
LABEL_58:
          v31(v33, v32);
          uint64_t v34 = *(void (**)(const char *, void))(v3 + 2640);
          if (v34) {
            v34(" ", *(void *)(v3 + 2648));
          }
        }
      }
      uint64_t result = strhelper_SafeStrtok((uint64_t)v7, " \t\n", &v38);
      long long v26 = result;
    }
    while (result);
  }
  return result;
}

char *SSMLStartNamespace(char *result, const char *a2, char *__src)
{
  if ((unint64_t)a2 | (unint64_t)__src)
  {
    uint64_t v3 = result;
    unint64_t v4 = *((void *)result + 340);
    if (v4 <= 9)
    {
      if (a2)
      {
        uint64_t result = cstdlib_strcpy(&result[1024 * v4 + 2728], a2);
        unint64_t v4 = *((void *)v3 + 340);
      }
      if (__src)
      {
        uint64_t result = cstdlib_strcpy(&v3[1024 * v4 + 3240], __src);
        unint64_t v4 = *((void *)v3 + 340);
      }
      *((void *)v3 + 340) = v4 + 1;
    }
  }
  return result;
}

uint64_t SSMLEndNamespace(uint64_t result, char *__s2)
{
  if (__s2)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(result + 2720);
    if (v3)
    {
      uint64_t v5 = 0;
      unint64_t v6 = 0;
      uint64_t v7 = result + 2728;
      do
      {
        uint64_t result = cstdlib_strcmp((const char *)v7, __s2);
        if (!result)
        {
          *(unsigned char *)uint64_t v7 = 0;
          *(unsigned char *)(v7 + 512) = 0;
          ++v5;
        }
        ++v6;
        unint64_t v8 = *(void *)(v2 + 2720);
        v7 += 1024;
      }
      while (v6 < v8);
      uint64_t v3 = v8 - v5;
    }
    *(void *)(v2 + 2720) = v3;
  }
  return result;
}

uint64_t SetInitialVoiceAndLanguage(uint64_t a1)
{
  __src = 0;
  uint64_t Str = paramc_ParamGetStr(*(void *)(*(void *)(a1 + 12992) + 40), (uint64_t)"langcode", &__src);
  if ((Str & 0x80000000) != 0) {
    return Str;
  }
  cstdlib_strcpy((char *)(a1 + 13128), __src);
  uint64_t v3 = paramc_ParamGetStr(*(void *)(*(void *)(a1 + 12992) + 40), (uint64_t)"voice", &__src);
  if ((v3 & 0x80000000) == 0)
  {
    cstdlib_strcpy((char *)(a1 + 13000), __src);
    *(_DWORD *)(a1 + 13160) = 0;
    if (paramc_ParamGetStr(*(void *)(*(void *)(a1 + 12992) + 40), (uint64_t)"processingtnplus", &__src))BOOL v4 = 1; {
    else
    }
      BOOL v4 = __src == 0;
    if (!v4 && !LH_stricmp(__src, "yes")) {
      *(_DWORD *)(a1 + 13160) = 1;
    }
  }
  return v3;
}

uint64_t ELQSSMLParse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v5 = 2375032834;
  if (a1 && *(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) == ELQSSMLIni)
  {
    uint64_t v5 = ELQXMLParse(*(void *)(a1 + 2624));
    memset(v16, 0, sizeof(v16));
    int v15 = 0;
    if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) == ELQSSMLIni)
    {
      uint64_t v8 = *(void *)(a1 + 2096);
      int v15 = v8;
      uint64_t v9 = (const char *)(a1 + 2104);
    }
    else
    {
      LODWORD(v8) = 0;
      uint64_t v9 = 0;
    }
    if (*(_DWORD *)(a1 + 2084))
    {
      if (!a5)
      {
        __sprintf_chk(v17, 0, 0x200uLL, "%s at line %d\n", v9, v8);
LABEL_9:
        log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, (uint64_t)"%s%s", v10, v11, v12, v13, "SSML parser error");
      }
    }
    else if (!ELQXMLGetError(*(void *)(a1 + 2624)) {
           && !(ELQXMLGetErrorString(*(void *)(a1 + 2624), 0, (char *)v16) | a5))
    }
    {
      __sprintf_chk(v17, 0, 0x200uLL, "%s at line %d\n", (const char *)v16, v15);
      goto LABEL_9;
    }
  }
  return v5;
}

uint64_t ELQSSMLGetError(uint64_t a1, void *a2, void *a3)
{
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni) {
    return 2375032834;
  }
  if (a2) {
    *a2 = *(void *)(a1 + 2096);
  }
  if (a3) {
    *a3 = a1 + 2104;
  }
  return *(unsigned int *)(a1 + 2084);
}

void *ELQSSMLDelete(void *result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    uint64_t v2 = (uint64_t (*)())result[194];
    if (v2 == ELQSSMLIni || v2 == ELQSSMLDelete)
    {
      DynStringDestroy((void **)result[1659]);
      DynStringDestroy(*(void ***)(v1 + 13264));
      if (*(uint64_t (**)())(v1 + 1552) == ELQSSMLIni)
      {
        unsigned int v3 = -1;
        do
          ++v3;
        while (*(void *)(v1 + 24 * v3 + 16));
        if (v3)
        {
          unsigned int v4 = v3 - 1;
          do
          {
            uint64_t v5 = v4;
            uint64_t v6 = v1 + 24 * v4;
            tinystack_Delete(*(void **)(v6 + 16));
            heap_Free(*(void **)(*(void *)(v1 + 12992) + 8), *(void *)(v6 + 24));
            --v4;
          }
          while (v5);
        }
        *(void *)(v1 + 16) = 0;
        *(void *)(v1 + 24) = 0;
      }
      hashtable_ObjClose(*(void **)(v1 + 12984));
      uint64_t v7 = *(void *)(v1 + 12992);
      uint64_t v8 = *(void *)(v7 + 48);
      if (v8 && *(void *)(v1 + 13344))
      {
        objc_ReleaseObject(v8, (uint64_t)"TTSEG");
        *(void *)(v1 + 13344) = 0;
        uint64_t v7 = *(void *)(v1 + 12992);
      }
      uint64_t v9 = *(void **)(v7 + 8);
      return heap_Free(v9, v1);
    }
  }
  return result;
}

void *DynStringDestroy(void **a1)
{
  unsigned int v3 = a1 + 1;
  uint64_t v2 = (uint64_t)a1[1];
  if (v2) {
    heap_Free((void *)**a1, v2);
  }
  *unsigned int v3 = 0;
  v3[1] = 0;
  unsigned int v4 = (void *)**a1;

  return heap_Free(v4, (uint64_t)a1);
}

uint64_t ELQSSMLSetBStrictSSMLSyntax(uint64_t a1, int a2)
{
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni) {
    return 2375032834;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 2616) = a2;
  return result;
}

uint64_t ELQSSMLSetParameter(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t result = 2375032839;
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni) {
    return 2375032834;
  }
  if (a3)
  {
    switch(a2)
    {
      case 1:
        uint64_t result = 0;
        *(_DWORD *)(a1 + 1560) = a3;
        break;
      case 2:
        uint64_t result = 0;
        *(_DWORD *)(a1 + 1568) = a3;
        break;
      case 3:
        uint64_t result = 0;
        *(_DWORD *)(a1 + 1564) = a3;
        break;
      case 4:
        uint64_t result = 0;
        *(_DWORD *)(a1 + 2088) = a3;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t ELQSSMLSetOutputFunction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni) {
    return 2375032834;
  }
  uint64_t result = 0;
  *(void *)(a1 + 2640) = a2;
  *(void *)(a1 + 2648) = a3;
  return result;
}

uint64_t ELQSSMLSetTagSequenceOutputFunction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni) {
    return 2375032834;
  }
  uint64_t result = 0;
  *(void *)(a1 + 2656) = a2;
  *(void *)(a1 + 2664) = a3;
  return result;
}

uint64_t ELQSSMLSetMemorySlot(uint64_t a1, uint64_t a2)
{
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni) {
    return 2375032834;
  }
  uint64_t result = 0;
  *(void *)(a1 + 2672) = a2;
  return result;
}

uint64_t ELQSSMLSetVoiceInfo(uint64_t a1, uint64_t a2)
{
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni) {
    return 2375032834;
  }
  uint64_t result = 0;
  *(void *)(a1 + 2680) = a2;
  return result;
}

uint64_t ELQSSMLSetLangCodeConverter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni) {
    return 2375032834;
  }
  uint64_t result = 0;
  *(void *)(a1 + 14384) = a2;
  *(void *)(a1 + 14392) = a3;
  *(void *)(a1 + 14400) = a4;
  return result;
}

uint64_t SSMLstricmpElement(uint64_t a1, char *__s, char *a3)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t result = 0xFFFFFFFFLL;
  if (__s && a3)
  {
    uint64_t v6 = __s;
    long long v51 = 0u;
    memset(v52, 0, sizeof(v52));
    long long v49 = 0u;
    long long v50 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v38 = 0u;
    long long v37 = 0u;
    long long v36 = 0u;
    long long v35 = 0u;
    long long v34 = 0u;
    long long v33 = 0u;
    long long v32 = 0u;
    long long v31 = 0u;
    long long v30 = 0u;
    long long v29 = 0u;
    long long v28 = 0u;
    long long v27 = 0u;
    long long v26 = 0u;
    long long v25 = 0u;
    long long v24 = 0u;
    long long v23 = 0u;
    long long v22 = 0u;
    uint64_t v20 = 0;
    char __dst = 0;
    if (*(unsigned char *)(a1 + 12968))
    {
      if (!cstdlib_strchr(__s, *(char *)(a1 + 12968))) {
        goto LABEL_24;
      }
      char v7 = *(unsigned char *)(a1 + 12968);
    }
    else
    {
      char v7 = 0;
    }
    __sa[0] = v7;
    __sa[1] = 0;
    uint64_t v8 = *(void *(***)(uint64_t, uint64_t, int))(a1 + 2672);
    size_t v9 = cstdlib_strlen(v6);
    uint64_t v10 = ELQMemorySlotSave(v8, v6, v9 + 1);
    if (!v10) {
      goto LABEL_22;
    }
    uint64_t v11 = (uint64_t)v10;
    uint64_t v12 = strhelper_SafeStrtok((uint64_t)v10, __sa, &v20);
    if (!v12) {
      goto LABEL_22;
    }
    if (*(void *)(a1 + 2720))
    {
      uint64_t v13 = v12;
      unint64_t v14 = 0;
      int v15 = (char *)(a1 + 3240);
      while (cstdlib_strcmp(v13, v15)
           && cstdlib_strcmp(v13, "http://www.w3.org/2001/10/synthesis")
           && cstdlib_strcmp(v13, "http://www.w3.org/XML/1998/namespace"))
      {
        ++v14;
        v15 += 1024;
        if (v14 >= *(void *)(a1 + 2720)) {
          goto LABEL_24;
        }
      }
      uint64_t v16 = strhelper_SafeStrtok(v11, __sa, &v20);
      if (v16)
      {
        uint64_t v6 = v16;
        int v17 = "http://www.w3.org/XML/1998/namespace";
        if (LH_stricmp(v15, "http://www.w3.org/XML/1998/namespace"))
        {
          uint64_t v18 = 1u;
          int v17 = "http://www.w3.org/2001/10/synthesis";
          while (LH_stricmp("http://www.w3.org/2001/10/synthesis", v15)
               || LH_stricmp(isValidElementForUri_tagsTable[v18], v6))
          {
            v18 += 2;
            if (v18 == 45) {
              goto LABEL_22;
            }
          }
        }
        *(void *)(a1 + 12976) = v17;
        goto LABEL_24;
      }
LABEL_22:
      char __dst = 0;
      return LH_stricmp(&__dst, a3);
    }
LABEL_24:
    cstdlib_strcpy(&__dst, v6);
    return LH_stricmp(&__dst, a3);
  }
  return result;
}

uint64_t SetSSMLError(uint64_t a1, int a2, char *__src)
{
  *(_DWORD *)(a1 + 2084) = a2;
  cstdlib_strcpy((char *)(a1 + 2104), __src);
  uint64_t v4 = *(void *)(a1 + 2624);

  return ELQXMLGetCurrentLineNumber(v4);
}

char *SSML10StartConvert(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v157 = *MEMORY[0x263EF8340];
  __s[0] = 0;
  if (!SSMLstricmpElement(a1, a2, "speak"))
  {
    *(void *)(a1 + 2688) = 0;
    *(void *)(a1 + 2704) = 0;
    *(_DWORD *)(a1 + 2696) = 0;
    *(_DWORD *)(a1 + 2712) = 0;
    uint64_t v11 = *(char **)a3;
    if (*(void *)a3)
    {
      int v151 = 0;
      unsigned int v12 = 1;
      uint64_t v13 = (char **)a3;
      int v14 = 1;
      int v15 = 1;
      do
      {
        if (!LH_stricmp(v11, "version") && *(void *)(a3 + 8 * v12)) {
          int v14 = 0;
        }
        if (*v13)
        {
          if ((!SSMLstricmp(a1, *v13, "lang") || !SSMLstricmp(a1, *v13, "xml:lang"))
            && *(void *)(a3 + 8 * v12))
          {
            int v15 = 0;
          }
          if (*v13)
          {
            if (!LH_stricmp(*v13, "autolid"))
            {
              uint64_t v16 = *(char **)(a3 + 8 * v12);
              if (v16)
              {
                int v17 = SSMLstricmp(a1, v16, "no");
                uint64_t v18 = "yes";
                if (!v17) {
                  uint64_t v18 = "no";
                }
                int v151 = (char *)v18;
              }
            }
            if (*v13
              && (!SSMLstricmp(a1, *v13, "base") || !SSMLstricmp(a1, *v13, "xml:base")))
            {
              uint64_t v19 = *(char **)(a3 + 8 * v12);
              if (v19)
              {
                UrlSetBaseURI(a1, v19);
                uint64_t v20 = *(void (**)(char *, void))(a1 + 2640);
                if (v20) {
                  v20(__s, *(void *)(a1 + 2648));
                }
              }
            }
          }
        }
        uint64_t v13 = (char **)(a3 + 8 * (v12 + 1));
        uint64_t v11 = *v13;
        v12 += 2;
      }
      while (*v13);
      if (*(_DWORD *)(a1 + 2616))
      {
        if (!v14 || !v15)
        {
          if (v14)
          {
            uint64_t v21 = *(void *)(*(void *)(a1 + 12992) + 32);
            long long v22 = "The \"version\" attribute is required for \"speak\" element";
LABEL_77:
            log_OutPublic(v21, (uint64_t)"LIGHTSSML", 1458, (uint64_t)"%s%s", v6, v7, v8, v9, "SSML parser error");
            goto LABEL_78;
          }
          goto LABEL_74;
        }
LABEL_54:
        uint64_t v21 = *(void *)(*(void *)(a1 + 12992) + 32);
        long long v22 = "The \"version\" attribute and the \"xml:lang\" attribute are required for \"speak\" element";
        goto LABEL_77;
      }
      if (!v14)
      {
LABEL_74:
        if (v15)
        {
          uint64_t v21 = *(void *)(*(void *)(a1 + 12992) + 32);
          if (*(_DWORD *)(a1 + 2616))
          {
            long long v22 = "The \"xml:lang\" attribute is required for \"speak\" element\n";
            goto LABEL_77;
          }
          log_OutText(v21, (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"SSML: Warning: the \"xml:lang\" attribute is required for \"speak\" element\n", v7, v8, v9, v150);
        }
        SSMLSaveOnLangFailureIntoStack(a1, *(_DWORD *)(a1 + 2716));
        uint64_t v54 = *(char **)a3;
        BOOL v55 = *(void *)a3 != 0;
        if (!v15 && !v54)
        {
          uint64_t Str = 0;
LABEL_103:
          UnloadTuningResources((void *)a1);
          return (char *)Str;
        }
        uint64_t Str = 0;
        unsigned int v57 = 1;
        uint64_t v58 = (char **)a3;
        while (1)
        {
          if (v15)
          {
            *(void *)__src = 0;
            uint64_t Str = paramc_ParamGetStr(*(void *)(*(void *)(a1 + 12992) + 40), (uint64_t)"langcode", __src);
            if ((Str & 0x80000000) != 0) {
              goto LABEL_103;
            }
            uint64_t v59 = *(void *)__src;
          }
          else
          {
            if (!v55 || SSMLstricmp(a1, v54, "lang") && SSMLstricmp(a1, *v58, "xml:lang")) {
              goto LABEL_96;
            }
            uint64_t v59 = *(void *)(a3 + 8 * v57);
            if (!v59) {
              goto LABEL_96;
            }
            *(void *)__src = *(void *)(a3 + 8 * v57);
          }
          uint64_t v60 = (const char *)NormalizeLangCode((void *)a1, v59);
          aux_SetActiveLanguage(a1, v60, v151);
          __sprintf_chk(__s, 0, 0x200uLL, "\x1B\\lang=%s\\"", (const char *)(a1 + 13128));
          int v61 = *(void (**)(char *, void))(a1 + 2640);
          if (v61) {
            v61(__s, *(void *)(a1 + 2648));
          }
          if (v15)
          {
LABEL_97:
            int v62 = *(char **)a3;
            if (*(void *)a3)
            {
              unsigned int v63 = 1;
              do
              {
                if (!LH_stricmp(v62, "ssft-domaintype"))
                {
                  cstdlib_strcpy((char *)(a1 + 13228), *(const char **)(a3 + 8 * v63));
                  __sprintf_chk(__s, 0, 0x200uLL, "\x1B\\domain=%s\\"", (const char *)(a1 + 13228));
                  unsigned int v64 = *(void (**)(char *, void))(a1 + 2640);
                  if (v64) {
                    v64(__s, *(void *)(a1 + 2648));
                  }
                }
                int v62 = *(char **)(a3 + 8 * (v63 + 1));
                v63 += 2;
              }
              while (v62);
            }
            goto LABEL_103;
          }
LABEL_96:
          uint64_t v58 = (char **)(a3 + 8 * (v57 + 1));
          uint64_t v54 = *v58;
          BOOL v55 = *v58 != 0;
          v57 += 2;
          if (!*v58) {
            goto LABEL_97;
          }
        }
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 2616)) {
        goto LABEL_54;
      }
      int v151 = 0;
      int v15 = 1;
    }
    log_OutText(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"SSML: Warning: the \"version\" attribute is required for \"speak\" element\n", v7, v8, v9, v150);
    goto LABEL_74;
  }
  if (!SSMLstricmpElement(a1, a2, "meta"))
  {
    uint64_t v152 = 0;
    uint64_t v153 = 0;
    if (CheckTagBond(a1, &v152))
    {
      __sprintf_chk(__src, 0, 0x200uLL, "The \"%s\" element can only contain text", v152);
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v23, v24, v25, v26, "SSML parser error");
LABEL_58:
      *(_DWORD *)(a1 + 2084) = -1919926671;
      long long v32 = (char *)(a1 + 2104);
      long long v33 = __src;
LABEL_59:
      cstdlib_strcpy(v32, v33);
      ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
      ReleaseTagBond(a1);
      return (char *)*(unsigned int *)(a1 + 2084);
    }
    uint64_t v34 = XMLGetStack(a1, "tagOrder");
    if (v34)
    {
      if ((tinystack_View(v34, &v153) & 0x80000000) == 0 && v153 == 13)
      {
        __sprintf_chk(__src, 0, 0x200uLL, "The \"%s\" element can only contain text", v152);
        log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v39, v40, v41, v42, "SSML parser error");
        unsigned __int16 v43 = 8194;
LABEL_167:
        *(_DWORD *)(a1 + 2084) = v43 | 0x8D900000;
        uint64_t v87 = (char *)(a1 + 2104);
        uint64_t v88 = __src;
        goto LABEL_201;
      }
      uint64_t v75 = XMLGetStack(a1, "metadata");
      if (v75)
      {
        uint64_t v76 = v75;
        if ((tinystack_View(v75, &v153) & 0x80000000) == 0) {
          uint64_t v153 = XMLGetCurrentValue(a1);
        }
        if ((tinystack_Push(v76, 17) & 0x80000000) != 0)
        {
          long long v22 = "Out of Memory";
          log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1923, (uint64_t)"%s%s", v77, v78, v79, v80, "SSML parser error");
          unsigned int v134 = -1919934454;
          goto LABEL_200;
        }
        uint64_t v81 = *(char **)a3;
        if (!*(void *)a3) {
          goto LABEL_211;
        }
        int v82 = 0;
        int v83 = 0;
        int v84 = 0;
        uint64_t v85 = 2;
        uint64_t v86 = (char **)a3;
        do
        {
          if (LH_stricmp(v81, "name"))
          {
            if (*v86)
            {
              if (LH_stricmp(*v86, "http-equiv"))
              {
                if (*v86 && !LH_stricmp(*v86, "content")) {
                  int v83 = 1;
                }
              }
              else
              {
                int v84 = 1;
              }
            }
          }
          else
          {
            int v82 = 1;
          }
          uint64_t v86 = (char **)(a3 + 8 * (v85 & 0xFFFFFFFE));
          uint64_t v81 = *v86;
          v85 += 2;
        }
        while (*v86);
        if (v82 && v84)
        {
          log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1462, (uint64_t)"%s%s", v77, v78, v79, v80, "SSML parser error");
          *(_DWORD *)(a1 + 2084) = -1919926671;
          uint64_t v87 = (char *)(a1 + 2104);
          uint64_t v88 = "Out of Memory";
LABEL_201:
          cstdlib_strcpy(v87, v88);
          ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
          return (char *)*(unsigned int *)(a1 + 2084);
        }
        if (v82 | v84)
        {
          if (v83) {
            return 0;
          }
          uint64_t v136 = *(void *)(*(void *)(a1 + 12992) + 32);
        }
        else
        {
LABEL_211:
          uint64_t v136 = *(void *)(*(void *)(a1 + 12992) + 32);
        }
        log_OutPublic(v136, (uint64_t)"LIGHTSSML", 1462, (uint64_t)"%s%s", v77, v78, v79, v80, "SSML parser error");
        uint64_t v137 = "Out of Memory";
        goto LABEL_213;
      }
    }
    goto LABEL_198;
  }
  if (!SSMLstricmpElement(a1, a2, "metadata"))
  {
    uint64_t v152 = 0;
    uint64_t v153 = 0;
    if (CheckTagBond(a1, &v152))
    {
      long long v27 = v152;
LABEL_57:
      __sprintf_chk(__src, 0, 0x200uLL, "The \"%s\" element can only contain text", v27);
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1414, (uint64_t)"%s%s", v28, v29, v30, v31, "SSML parser error");
      goto LABEL_58;
    }
    uint64_t v48 = XMLGetStack(a1, "tagOrder");
    if (!v48)
    {
LABEL_198:
      long long v22 = "SSML Stack unavailable";
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v35, v36, v37, v38, "SSML parser error");
      unsigned __int16 v53 = 8194;
      goto LABEL_199;
    }
    if ((tinystack_View(v48, &v153) & 0x80000000) != 0 || v153 != 13)
    {
      uint64_t v109 = XMLGetStack(a1, "metadata");
      if (v109)
      {
        uint64_t v110 = v109;
        if ((tinystack_View(v109, &v153) & 0x80000000) == 0) {
          uint64_t v153 = XMLGetCurrentValue(a1);
        }
        if ((tinystack_Push(v110, 17) & 0x80000000) == 0) {
          return 0;
        }
        goto LABEL_204;
      }
      goto LABEL_198;
    }
    long long v22 = "\"metadata\" element must occur before all other element";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1414, (uint64_t)"%s%s", v49, v50, v51, v52, "SSML parser error");
LABEL_78:
    unsigned __int16 v53 = 15985;
LABEL_199:
    unsigned int v134 = v53 | 0x8D900000;
LABEL_200:
    *(_DWORD *)(a1 + 2084) = v134;
    uint64_t v87 = (char *)(a1 + 2104);
    uint64_t v88 = (char *)v22;
    goto LABEL_201;
  }
  if (!SSMLstricmpElement(a1, a2, "mark"))
  {
    uint64_t v152 = 0;
    uint64_t v153 = 0;
    if (CheckTagBond(a1, &v153))
    {
      long long v27 = (const char *)v153;
      goto LABEL_57;
    }
    uint64_t v69 = XMLGetStack(a1, "tagOrder");
    if (v69)
    {
      uint64_t v70 = v69;
      if ((tinystack_View(v69, &v152) & 0x80000000) != 0 && (tinystack_Push(v70, 13) & 0x80000000) != 0) {
        goto LABEL_204;
      }
      if (!*(void *)a3 || LH_stricmp(*(char **)a3, "name") || !*(void *)(a3 + 8)) {
        return 0;
      }
      __sprintf_chk(__s, 0, 0x200uLL, "\x1B\\mrk=%s\\"");
      goto LABEL_157;
    }
    goto LABEL_198;
  }
  if (!SSMLstricmpElement(a1, a2, "break"))
  {
    uint64_t v153 = 0;
    __s[0] = 0;
    *(void *)__src = 0;
    __int16 v156 = 0;
    if (CheckTagBond(a1, &v152))
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1446, (uint64_t)"%s%s", v44, v45, v46, v47, "SSML parser error");
LABEL_107:
      *(_DWORD *)(a1 + 2084) = -1919926671;
      long long v32 = (char *)(a1 + 2104);
      long long v33 = "The \"%s\" element can only contain text";
      goto LABEL_59;
    }
    uint64_t v92 = XMLGetStack(a1, "tagOrder");
    if (!v92) {
      goto LABEL_198;
    }
    uint64_t v93 = v92;
    if ((tinystack_View(v92, &v153) & 0x80000000) != 0 && (tinystack_Push(v93, 13) & 0x80000000) != 0) {
      goto LABEL_204;
    }
    uint64_t v94 = *(char **)a3;
    if (*(void *)a3)
    {
      int v95 = 0;
      uint64_t v96 = a3 + 8;
      unint64_t v97 = -1;
      do
      {
        if (!LH_stricmp(v94, "time"))
        {
          if (*(void *)v96)
          {
            uint64_t v98 = *(const char **)v96;
            int v99 = v98[cstdlib_strlen(*(const char **)v96) - 2];
            uint64_t v100 = *(const char **)v96;
            if (v99 == 109)
            {
              size_t v101 = cstdlib_strlen(*(const char **)v96);
              cstdlib_strncpy(__src, v100, v101 - 2);
              unint64_t v97 = (int)LH_atoi(__src);
            }
            else if (v100)
            {
              if (v100[cstdlib_strlen(*(const char **)v96) - 1] == 115
                || (uint64_t v102 = *(const char **)v96, v102[cstdlib_strlen(*(const char **)v96) - 1] == 83))
              {
                uint64_t v103 = *(const char **)v96;
                size_t v104 = cstdlib_strlen(*(const char **)v96);
                cstdlib_strncpy(__src, v103, v104 - 1);
                uint64_t v105 = cstdlib_strrchr(__src, 44);
                if (v105) {
                  char *v105 = 46;
                }
                cstdlib_atof((unsigned __int8 *)__src);
                unint64_t v97 = (unint64_t)(v106 * 1000.0);
              }
            }
          }
          if (v97 != -1)
          {
            __sprintf_chk(__s, 0, 0x200uLL, "\x1B\\pause=%d\\"", v97);
            uint64_t v107 = *(void (**)(char *, void))(a1 + 2640);
            if (v107) {
              v107(__s, *(void *)(a1 + 2648));
            }
          }
          int v95 = 1;
        }
        uint64_t v94 = *(char **)(v96 + 8);
        v96 += 16;
      }
      while (v94);
      if (!v95)
      {
        uint64_t v138 = *(char **)a3;
        if (*(void *)a3)
        {
          uint64_t v139 = (char **)(a3 + 8);
          do
          {
            if (!LH_stricmp(v138, "strength"))
            {
              if (!*v139 || !LH_stricmp(*v139, "medium") || !LH_stricmp(*v139, "weak")) {
                goto LABEL_225;
              }
              if (!LH_stricmp(*v139, "none"))
              {
                __sprintf_chk(__s, 0, 0x200uLL, "\x1B\\eos=0\\"");
                uint64_t v141 = *(void (**)(char *, void))(a1 + 2640);
                if (v141) {
                  v141(__s, *(void *)(a1 + 2648));
                }
                __sprintf_chk(__s, 0, 0x200uLL, "\x1B\\pause=%d\\"");
                goto LABEL_226;
              }
              if (LH_stricmp(*v139, "x-weak"))
              {
                if (LH_stricmp(*v139, "strong") && LH_stricmp(*v139, "x-strong")) {
LABEL_225:
                }
                  __sprintf_chk(__s, 0, 0x200uLL, "\x1B\\pause\\"", v150);
                else {
                  __sprintf_chk(__s, 0, 0x200uLL, "\x1B\\eos=1\\"", v150);
                }
LABEL_226:
                uint64_t v140 = *(void (**)(char *, void))(a1 + 2640);
                if (v140) {
                  v140(__s, *(void *)(a1 + 2648));
                }
                goto LABEL_228;
              }
              cstdlib_strcpy(__s, " ");
            }
LABEL_228:
            uint64_t v138 = v139[1];
            v139 += 2;
          }
          while (v138);
        }
      }
    }
    if (cstdlib_strlen(__s)) {
      return 0;
    }
    __sprintf_chk(__s, 0, 0x200uLL, "\x1B\\pause\\"");
LABEL_157:
    unsigned int v108 = *(void (**)(char *, void))(a1 + 2640);
    if (v108) {
      v108(__s, *(void *)(a1 + 2648));
    }
    return 0;
  }
  if (SSMLstricmpElement(a1, a2, "prosody"))
  {
    if (SSMLstricmpElement(a1, a2, "p"))
    {
      if (SSMLstricmpElement(a1, a2, "s"))
      {
        if (SSMLstricmpElement(a1, a2, "lang"))
        {
          if (!SSMLstricmpElement(a1, a2, "phoneme")) {
            return (char *)SSMLElement_PHONEME_Enter(a1, (char **)a3, (uint64_t)__s);
          }
          if (!SSMLstricmpElement(a1, a2, "voice")) {
            return (char *)SSMLElement_VOICE_Enter(a1, (char **)a3, __s);
          }
          if (!SSMLstricmpElement(a1, a2, "emphasis"))
          {
            return (char *)SSMLElement_EMPHASIS_Enter(a1, (void *)a3);
          }
          if (!SSMLstricmpElement(a1, a2, "sub"))
          {
            return (char *)SSMLElement_SUB_Enter(a1, a3);
          }
          if (!SSMLstricmpElement(a1, a2, "say-as")) {
            return (char *)SSMLElement_SAYAS_Enter(a1, (char **)a3, __s);
          }
          if (!SSMLstricmpElement(a1, a2, "audio")) {
            return (char *)SSMLElement_AUDIO_Enter(a1, (char **)a3, __s);
          }
          if (!SSMLstricmpElement(a1, a2, "style")) {
            return (char *)SSMLElement_STYLE_Enter(a1, (char **)a3, __s);
          }
          if (!SSMLstricmpElement(a1, a2, "prompt")) {
            return SSMLElement_PROMPT_Enter(a1, a3, __s);
          }
          if (!SSMLstricmpElement(a1, a2, "desc")) {
            return (char *)SSMLElement_DESC_Enter(a1, (char **)a3, __s);
          }
          if (!SSMLstricmpElement(a1, a2, "lexicon")) {
            return (char *)SSMLElement_LEXICON_Enter(a1, (char **)a3, (uint64_t)__s);
          }
          return 0;
        }
        uint64_t v89 = a1;
        unsigned int v90 = (char **)a3;
        uint64_t v91 = 2;
      }
      else
      {
        uint64_t v89 = a1;
        unsigned int v90 = (char **)a3;
        uint64_t v91 = 0;
      }
    }
    else
    {
      uint64_t v89 = a1;
      unsigned int v90 = (char **)a3;
      uint64_t v91 = 1;
    }
    return (char *)SSMLElement_Block_Enter(v89, v90, __s, v91);
  }
  uint64_t v153 = 0;
  if (!*(void *)a3)
  {
    __sprintf_chk(__src, 0, 0x200uLL, "At least one attribute must be specified for \"prosody\" element");
LABEL_166:
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1305, (uint64_t)"%s%s", v111, v112, v113, v114, "SSML parser error");
    unsigned __int16 v43 = 15985;
    goto LABEL_167;
  }
  if (CheckTagBond(a1, &v152))
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1305, (uint64_t)"%s%s", v65, v66, v67, v68, "SSML parser error");
    goto LABEL_107;
  }
  uint64_t v115 = XMLGetStack(a1, "tagOrder");
  if (!v115) {
    goto LABEL_198;
  }
  uint64_t v116 = v115;
  if ((tinystack_View(v115, &v153) & 0x80000000) != 0 && (tinystack_Push(v116, 13) & 0x80000000) != 0)
  {
LABEL_204:
    long long v22 = "Too many nested attributes";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, (uint64_t)"%s%s", v71, v72, v73, v74, "SSML parser error");
    unsigned int v134 = -1919933952;
    goto LABEL_200;
  }
  SSMLPushProsodicParameters(a1);
  uint64_t v117 = *(char **)a3;
  if (!*(void *)a3)
  {
LABEL_195:
    uint64_t v122 = XMLGetStack(a1, "auxiliary");
    if (v122)
    {
      if ((tinystack_Push(v122, 0) & 0x80000000) == 0) {
        return 0;
      }
      uint64_t v131 = "Too many nested attributes";
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, (uint64_t)"%s%s", v127, v128, v129, v130, "SSML parser error");
      int v132 = -1919933952;
      uint64_t v133 = a1;
    }
    else
    {
      uint64_t v131 = "SSML Stack unavailable";
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v123, v124, v125, v126, "SSML parser error");
      uint64_t v133 = a1;
      int v132 = -1919934462;
    }
    uint64_t v137 = (char *)v131;
    goto LABEL_214;
  }
  uint64_t v118 = (char **)(a3 + 8);
  while (1)
  {
    if (!LH_stricmp(v117, "rate") && *v118)
    {
      if (!ParseAttribute(a1, *v118, 2))
      {
        __sprintf_chk(__src, 0, 0x200uLL, "Error in prosody element - rate attribute");
        goto LABEL_248;
      }
      goto LABEL_194;
    }
    uint64_t v119 = *(v118 - 1);
    if (!v119) {
      goto LABEL_238;
    }
    if (LH_stricmp(v119, "pitch") || !*v118) {
      break;
    }
    if (!ParseAttribute(a1, *v118, 3))
    {
      __sprintf_chk(__src, 0, 0x200uLL, "Error in prosody element - pitch attribute");
      goto LABEL_251;
    }
LABEL_194:
    uint64_t v117 = v118[1];
    v118 += 2;
    if (!v117) {
      goto LABEL_195;
    }
  }
  uint64_t v120 = *(v118 - 1);
  if (!v120) {
    goto LABEL_238;
  }
  if (LH_stricmp(v120, "timbre") || !*v118)
  {
    uint64_t v121 = *(v118 - 1);
    if (!v121 || LH_stricmp(v121, "volume") || !*v118)
    {
LABEL_238:
      __sprintf_chk(__src, 0, 0x200uLL, "Error in prosody element - unknown or unimplemented attribute");
      goto LABEL_166;
    }
    if (!ParseAttribute(a1, *v118, 1))
    {
      __sprintf_chk(__src, 0, 0x200uLL, "Error in prosody element - volume attribute");
LABEL_248:
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1305, (uint64_t)"%s%s", v142, v143, v144, v145, "SSML parser error");
      goto LABEL_252;
    }
    goto LABEL_194;
  }
  if (ParseAttribute(a1, *v118, 4)) {
    goto LABEL_194;
  }
  __sprintf_chk(__src, 0, 0x200uLL, "Error in prosody element - timbre attribute");
LABEL_251:
  log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1304, (uint64_t)"%s%s", v146, v147, v148, v149, "SSML parser error");
LABEL_252:
  uint64_t v137 = __src;
LABEL_213:
  uint64_t v133 = a1;
  int v132 = -1919926671;
LABEL_214:
  SetSSMLError(v133, v132, v137);
  return (char *)*(unsigned int *)(a1 + 2084);
}

uint64_t SSMLElement_Block_Enter(uint64_t a1, char **a2, char *a3, uint64_t a4)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  int v61 = 0;
  uint64_t v62 = 0;
  unsigned int v60 = *(_DWORD *)(a1 + 2716);
  if (CheckTagBond(a1, &v61))
  {
    __sprintf_chk(__src, 0, 0x200uLL, "The \"%s\" element can only contain text", v61);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, (uint64_t)"%s%s", v8, v9, v10, v11, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    cstdlib_strcpy((char *)(a1 + 2104), __src);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v12 = XMLGetStack(a1, "tagOrder");
  if (!v12)
  {
    unsigned __int16 v43 = "SSML Stack unavailable";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v13, v14, v15, v16, "SSML parser error");
    int v44 = -1919934462;
LABEL_42:
    *(_DWORD *)(a1 + 2084) = v44;
    cstdlib_strcpy((char *)(a1 + 2104), v43);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v17 = v12;
  if ((tinystack_View(v12, &v62) & 0x80000000) != 0 && (tinystack_Push(v17, 13) & 0x80000000) != 0)
  {
    unsigned __int16 v43 = "Too many nested attributes";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, (uint64_t)"%s%s", v18, v19, v20, v21, "SSML parser error");
    int v44 = -1919933952;
    goto LABEL_42;
  }
  unsigned int v57 = a3;
  uint64_t Str = SSMLViewOnLangFailureFromStack(a1, &v60);
  if (!Str)
  {
    unsigned int v23 = v60;
    if (v60 == 4) {
      unsigned int v23 = *(_DWORD *)(a1 + 2716);
    }
    unsigned int v56 = v23;
    *unsigned int v57 = 0;
    uint64_t v24 = *a2;
    if (*a2)
    {
      uint64_t v25 = 0;
      uint64_t v58 = 0;
      __s2 = 0;
      uint64_t v26 = 0;
      int v27 = 0;
      char __dst = (char *)(a1 + 13196);
      BOOL v55 = 0;
      uint64_t v28 = "lang";
      uint64_t v29 = a2;
      do
      {
        if (SSMLstricmp(a1, v24, v28) && SSMLstricmp(a1, *v29, "xml:lang")
          || (uint64_t v30 = *(uint64_t *)((char *)a2 + ((8 * v25) | 8))) == 0)
        {
          if (*v29)
          {
            if (SSMLstricmp(a1, *v29, "onlangfailure")
              || (uint64_t v40 = *(char **)((char *)a2 + ((8 * v25) | 8))) == 0)
            {
              if (*v29)
              {
                if (!LH_stricmp(*v29, "autolid"))
                {
                  uint64_t v37 = *(char **)((char *)a2 + ((8 * v25) | 8));
                  if (v37)
                  {
                    int v38 = SSMLstricmp(a1, v37, "no");
                    uint64_t v39 = "yes";
                    if (!v38) {
                      uint64_t v39 = "no";
                    }
                    BOOL v55 = (char *)v39;
                  }
                }
              }
            }
            else
            {
              unsigned int v56 = SSMLGetLangFailureCode(v40);
            }
          }
        }
        else
        {
          uint64_t v31 = (const char *)NormalizeLangCode((void *)a1, v30);
          long long v32 = *(void *(***)(uint64_t, uint64_t, int))(a1 + 2672);
          size_t v33 = cstdlib_strlen(v31);
          __s2 = (char *)v31;
          uint64_t v58 = ELQMemorySlotSave(v32, v31, v33 + 1);
          uint64_t v64 = 0;
          *(void *)__src = 0;
          paramc_ParamGetStr(*(void *)(*(void *)(a1 + 12992) + 40), (uint64_t)"extraesclang", __src);
          uint64_t Str = paramc_ParamGetStr(*(void *)(*(void *)(a1 + 12992) + 40), (uint64_t)"langcode", &v64);
          if ((Str & 0x80000000) != 0) {
            return Str;
          }
          uint64_t v34 = a4;
          uint64_t v35 = v28;
          for (uint64_t i = 0; i != 3; ++i)
            __s1[i] = ssft_tolower(*(unsigned __int8 *)(v64 + i));
          __s1[3] = 0;
          uint64_t v28 = v35;
          a4 = v34;
          if (cstdlib_strstr(__s1, __s2) || *(void *)__src && cstdlib_strstr(*(char **)__src, __s2))
          {
            int v27 = 1;
            if (Str) {
              return Str;
            }
          }
          else
          {
            int v27 = 0;
            if (Str) {
              return Str;
            }
          }
        }
        if (a4 <= 1)
        {
          if (*v29)
          {
            if (!LH_stricmp(*v29, "ssft-domaintype"))
            {
              uint64_t v41 = *(char **)((char *)a2 + ((8 * v25) | 8));
              if (v41)
              {
                cstdlib_strcpy(__dst, v41);
                sprintf(v57, "\x1B\\domain=%s\\"", __dst);
                uint64_t v42 = *(void (**)(char *, void))(a1 + 2640);
                if (v42) {
                  v42(v57, *(void *)(a1 + 2648));
                }
              }
            }
          }
        }
        ++v26;
        uint64_t v25 = 2 * v26;
        uint64_t v29 = &a2[2 * v26];
        uint64_t v24 = *v29;
      }
      while (*v29);
    }
    else
    {
      int v27 = 0;
      uint64_t v58 = 0;
      __s2 = 0;
      BOOL v55 = 0;
    }
    int v46 = v56;
    unsigned int v60 = v56;
    if (__s2) {
      BOOL v47 = 1;
    }
    else {
      BOOL v47 = a4 == 2;
    }
    unsigned int v48 = 4;
    if (v47)
    {
      uint64_t v49 = v57;
      uint64_t v50 = (uint64_t)v58;
      uint64_t v51 = v55;
      if (!v27)
      {
        if (v56 != 4)
        {
          SSMLSaveOnLangFailureIntoStack(a1, v56);
          if (!v56) {
            SSMLPushVoice(a1);
          }
LABEL_56:
          SSMLPushLanguage(a1);
          if (a4 == 1)
          {
            _OWORD v49[8] = 0;
            uint64_t v52 = "\n\x1B\\para\\"";
          }
          else
          {
            if (a4)
            {
LABEL_62:
              SSMLOnLanguageChange(a1, v50, v51, v46, v49);
              return 0;
            }
            _OWORD v49[8] = 0;
            uint64_t v52 = "\x1B\\eos=1\\"";
          }
          *(void *)uint64_t v49 = *(void *)v52;
          unsigned __int16 v53 = *(void (**)(char *, void))(a1 + 2640);
          if (v53) {
            v53(v49, *(void *)(a1 + 2648));
          }
          goto LABEL_62;
        }
        unsigned int v48 = 3;
      }
    }
    else
    {
      uint64_t v49 = v57;
      uint64_t v50 = (uint64_t)v58;
      uint64_t v51 = v55;
    }
    unsigned int v60 = v48;
    SSMLSaveOnLangFailureIntoStack(a1, v48);
    int v46 = v48;
    goto LABEL_56;
  }
  return Str;
}

uint64_t SSMLElement_PHONEME_Enter(uint64_t a1, char **a2, uint64_t a3)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  int v61 = 0;
  uint64_t v62 = 0;
  if (CheckTagBond(a1, &v61))
  {
    __sprintf_chk(__src, 0, 0x200uLL, "The \"%s\" element can only contain text", v61);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1300, (uint64_t)"%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    cstdlib_strcpy((char *)(a1 + 2104), __src);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t result = NewTagBond(a1, "phoneme");
  if (result) {
    return result;
  }
  uint64_t v11 = XMLGetStack(a1, "tagOrder");
  if (!v11)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v12, v13, v14, v15, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    cstdlib_strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v16 = v11;
  if ((tinystack_View(v11, &v62) & 0x80000000) != 0 && (tinystack_Push(v16, 13) & 0x80000000) != 0)
  {
    uint64_t v52 = *(void *)(*(void *)(a1 + 12992) + 32);
    unsigned __int16 v53 = "Too many nested attributes";
LABEL_73:
    log_OutPublic(v52, (uint64_t)"LIGHTSSML", 1459, (uint64_t)"%s%s", v17, v18, v19, v20, "SSML parser error");
    int v60 = -1919933952;
LABEL_74:
    uint64_t v59 = a1;
LABEL_75:
    uint64_t v58 = (char *)v53;
    goto LABEL_76;
  }
  uint64_t v21 = *a2;
  if (!*a2) {
    goto LABEL_70;
  }
  int v22 = 0;
  unsigned int v23 = 1;
  uint64_t v24 = 4;
  uint64_t v25 = a2;
  do
  {
    if (!LH_stricmp(v21, "orthmode"))
    {
      uint64_t v26 = a2[v23];
      if (v26)
      {
        if (!LH_stricmp(v26, "ignorepunct")) {
          int v22 = 1;
        }
      }
    }
    if (*v25)
    {
      if (!LH_stricmp(*v25, "alphabet"))
      {
        int v27 = a2[v23];
        if (v27)
        {
          if (LH_stricmp(v27, "nt-sampa")
            && LH_stricmp(a2[v23], "nts")
            && LH_stricmp(a2[v23], "x-sampa")
            && LH_stricmp(a2[v23], "x-navteq-sampa"))
          {
            if (LH_stricmp(a2[v23], "sxm-sampa"))
            {
              if (LH_stricmp(a2[v23], "lhp") && LH_stricmp(a2[v23], "x-l&h+"))
              {
                if (LH_stricmp(a2[v23], "pyt") && LH_stricmp(a2[v23], "pinyin"))
                {
                  if (LH_stricmp(a2[v23], "diacritized"))
                  {
                    if (LH_stricmp(a2[v23], "jeita"))
                    {
                      __sprintf_chk(__src, 0, 0x200uLL, "SSML: Unknown or unsupported alphabeth \"%s\"\n", a2[v23]);
                      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1300, (uint64_t)"%s%s", v28, v29, v30, v31, "SSML parser error");
                      uint64_t v24 = 0;
                    }
                    else
                    {
                      uint64_t v24 = 128;
                    }
                  }
                  else
                  {
                    uint64_t v24 = 64;
                  }
                }
                else
                {
                  uint64_t v24 = 32;
                }
              }
              else
              {
                uint64_t v24 = 16;
              }
            }
            else
            {
              uint64_t v24 = 9;
            }
          }
          else
          {
            uint64_t v24 = 4;
          }
        }
      }
    }
    uint64_t v25 = &a2[v23 + 1];
    uint64_t v21 = *v25;
    v23 += 2;
  }
  while (*v25);
  long long v32 = *a2;
  if (!*a2)
  {
LABEL_70:
    __sprintf_chk(__src, 0, 0x200uLL, "\"ph\" attribute is required in \"phoneme\" element");
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, (uint64_t)"%s%s", v54, v55, v56, v57, "SSML parser error");
    uint64_t v58 = __src;
    uint64_t v59 = a1;
    int v60 = -1919926671;
LABEL_76:
    SetSSMLError(v59, v60, v58);
    return *(unsigned int *)(a1 + 2084);
  }
  int v33 = 0;
  uint64_t v34 = 0;
  BOOL v35 = v22 != 0;
  unsigned int v36 = 1;
  do
  {
    if (LH_stricmp(v32, "ph")) {
      goto LABEL_64;
    }
    uint64_t v37 = *(void *)(a1 + 13264);
    int v38 = strhelper_StringAppend(**(uint64_t ***)v37, *(char **)(v37 + 8), a2[v36], 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v37 + 16), 0x80uLL);
    *(void *)(v37 + 8) = v38;
    if (!v38)
    {
      unsigned __int16 v53 = "Out of Memory";
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1923, (uint64_t)"%s%s", v39, v40, v41, v42, "SSML parser error");
      int v60 = -1919934454;
      goto LABEL_74;
    }
    if (v24 > 15)
    {
      if (v24 > 63)
      {
        if (v24 == 64)
        {
          strcpy((char *)a3, "\x1B\\toi=diacritized");
LABEL_57:
          uint64_t v45 = *(void (**)(uint64_t, void))(a1 + 2640);
          if (v45) {
            v45(a3, *(void *)(a1 + 2648));
          }
          goto LABEL_59;
        }
        if (v24 != 128) {
          goto LABEL_59;
        }
        *(_DWORD *)(a3 + 8) = 6386793;
        unsigned __int16 v43 = "\x1B\\toi=jeita";
      }
      else if (v24 == 16)
      {
        *(_WORD *)(a3 + 8) = 112;
        unsigned __int16 v43 = "\x1B\\toi=lhp";
      }
      else
      {
        if (v24 != 32) {
          goto LABEL_59;
        }
        *(_WORD *)(a3 + 8) = 116;
        unsigned __int16 v43 = "\x1B\\toi=pyt";
      }
LABEL_56:
      *(void *)a3 = *(void *)v43;
      goto LABEL_57;
    }
    switch(v24)
    {
      case 0:
        uint64_t v44 = *(void *)(a1 + 13272);
        if (!*(void *)(v44 + 8)) {
          *(void *)(v44 + 8) = strhelper_StringAppend(**(uint64_t ***)v44, 0, "", 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v44 + 16), 0x80uLL);
        }
        break;
      case 4:
      case 8:
        *(_WORD *)(a3 + 8) = 115;
        unsigned __int16 v43 = "\x1B\\toi=nts";
        goto LABEL_56;
      case 9:
        *(_DWORD *)(a3 + 7) = 7564664;
        unsigned __int16 v43 = "\x1B\\toi=sxms";
        goto LABEL_56;
      default:
        break;
    }
LABEL_59:
    uint64_t v46 = XMLGetStack(a1, "phon");
    if (!v46) {
      goto LABEL_71;
    }
    v24 |= v35;
    if ((tinystack_Push(v46, v24) & 0x80000000) != 0) {
      goto LABEL_72;
    }
    uint64_t v51 = XMLGetStack(a1, "auxiliary");
    if (!v51)
    {
LABEL_71:
      unsigned __int16 v53 = "SSML Stack unavailable";
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v47, v48, v49, v50, "SSML parser error");
      uint64_t v59 = a1;
      int v60 = -1919934462;
      goto LABEL_75;
    }
    v34 |= 8uLL;
    if ((tinystack_Push(v51, v34) & 0x80000000) != 0)
    {
LABEL_72:
      uint64_t v52 = *(void *)(*(void *)(a1 + 12992) + 32);
      unsigned __int16 v53 = "Too many nested attributes";
      goto LABEL_73;
    }
    int v33 = 1;
LABEL_64:
    long long v32 = a2[v36 + 1];
    v36 += 2;
  }
  while (v32);
  if (!v33) {
    goto LABEL_70;
  }
  return 0;
}

uint64_t SSMLElement_VOICE_Enter(uint64_t a1, char **a2, char *a3)
{
  uint64_t v114 = *MEMORY[0x263EF8340];
  uint64_t v48 = 0;
  long long v113 = 0u;
  long long v112 = 0u;
  long long v111 = 0u;
  long long v110 = 0u;
  long long v109 = 0u;
  long long v108 = 0u;
  long long v107 = 0u;
  long long v106 = 0u;
  long long v105 = 0u;
  long long v104 = 0u;
  long long v103 = 0u;
  long long v102 = 0u;
  long long v101 = 0u;
  long long v100 = 0u;
  long long v99 = 0u;
  long long v98 = 0u;
  long long v97 = 0u;
  long long v96 = 0u;
  long long v95 = 0u;
  long long v94 = 0u;
  long long v93 = 0u;
  long long v92 = 0u;
  long long v91 = 0u;
  long long v90 = 0u;
  long long v89 = 0u;
  long long v88 = 0u;
  long long v87 = 0u;
  long long v86 = 0u;
  long long v85 = 0u;
  long long v84 = 0u;
  long long v83 = 0u;
  *(_OWORD *)char __dst = 0u;
  long long v81 = 0u;
  long long v80 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  *(_OWORD *)uint64_t v50 = 0u;
  long long v51 = 0u;
  cstdlib_strcpy(__dst, "languages");
  cstdlib_strcpy(v50, "ps");
  if (!*a2)
  {
    __sprintf_chk(__src, 0, 0x200uLL, "At least one attribute must be specified for \"voice\" element");
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1433, (uint64_t)"%s%s", v10, v11, v12, v13, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    uint64_t v14 = (char *)(a1 + 2104);
    uint64_t v15 = __src;
LABEL_46:
    cstdlib_strcpy(v14, v15);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v47 = 0;
  if (CheckTagBond(a1, &v47))
  {
    __sprintf_chk(__src, 0, 0x200uLL, "The \"%s\" element can only contain text", v47);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, (uint64_t)"%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    cstdlib_strcpy((char *)(a1 + 2104), __src);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v16 = XMLGetStack(a1, "tagOrder");
  if (!v16)
  {
    uint64_t v40 = "SSML Stack unavailable";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v17, v18, v19, v20, "SSML parser error");
    int v41 = -1919934462;
LABEL_45:
    *(_DWORD *)(a1 + 2084) = v41;
    uint64_t v14 = (char *)(a1 + 2104);
    uint64_t v15 = (char *)v40;
    goto LABEL_46;
  }
  uint64_t v21 = v16;
  if ((tinystack_View(v16, &v48) & 0x80000000) != 0 && (tinystack_Push(v21, 13) & 0x80000000) != 0)
  {
    uint64_t v40 = "Too many nested attributes";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, (uint64_t)"%s%s", v22, v23, v24, v25, "SSML parser error");
    int v41 = -1919933952;
    goto LABEL_45;
  }
  SSMLPushVoice(a1);
  SSMLPushLanguage(a1);
  SSMLPushProsodicParameters(a1);
  *a3 = 0;
  uint64_t v26 = *a2;
  if (!*a2)
  {
    int v27 = 0;
    uint64_t v37 = 0;
    uint64_t v28 = 0;
    goto LABEL_49;
  }
  int v27 = 0;
  uint64_t v28 = 0;
  uint64_t v46 = 0;
  uint64_t v29 = 0;
  unsigned int v30 = *(_DWORD *)(a1 + 8);
  uint64_t v31 = (const char **)(a2 + 1);
  do
  {
    if (!LH_stricmp(v26, "name") && *v31)
    {
      if (cstdlib_strlen(*v31)) {
        uint64_t v29 = *v31;
      }
      goto LABEL_35;
    }
    if (v30 > 1) {
      goto LABEL_12;
    }
    BOOL v35 = (char *)*(v31 - 1);
    if (!v35) {
      goto LABEL_35;
    }
    if (SSMLstricmp(a1, v35, "lang") && SSMLstricmp(a1, (char *)*(v31 - 1), "xml:lang")
      || !*v31)
    {
      unsigned int v36 = (char *)*(v31 - 1);
      if (!v36) {
        goto LABEL_35;
      }
      if (!SSMLstricmp(a1, v36, "autolid") && *v31)
      {
        SSMLstricmp(a1, (char *)*v31, "no");
        goto LABEL_35;
      }
LABEL_12:
      long long v32 = (char *)*(v31 - 1);
      if (v32)
      {
        if (LH_stricmp(v32, "gender") || !*v31)
        {
          int v33 = (char *)*(v31 - 1);
          if (v33)
          {
            if (LH_stricmp(v33, "age") || !*v31)
            {
              uint64_t v34 = (char *)*(v31 - 1);
              if (v34) {
                LH_stricmp(v34, "variant");
              }
            }
            else
            {
              int v27 = (char *)*v31;
            }
          }
        }
        else
        {
          uint64_t v28 = *v31;
        }
      }
      goto LABEL_35;
    }
    if (cstdlib_strlen(*v31)) {
      uint64_t v46 = *v31;
    }
LABEL_35:
    uint64_t v26 = (char *)v31[1];
    v31 += 2;
  }
  while (v26);
  if (!v27)
  {
    uint64_t v37 = (uint64_t)v46;
    if (!v29) {
      goto LABEL_49;
    }
    goto LABEL_56;
  }
  uint64_t v37 = (uint64_t)v46;
  if (*v27)
  {
    int v38 = cstdlib_atoi((unsigned __int8 *)v27);
    uint64_t v39 = "Adult";
    if (v38 < 18) {
      uint64_t v39 = "Child";
    }
    if (v38 > 0) {
      int v27 = (char *)v39;
    }
  }
  if (v29)
  {
LABEL_56:
    cstdlib_strcpy((char *)(a1 + 13000), v29);
    goto LABEL_64;
  }
LABEL_49:
  if (v28 || v27 || v37)
  {
    cstdlib_strcpy((char *)(a1 + 13000), "(");
    if (v28)
    {
      cstdlib_strcat((char *)(a1 + 13000), "gender:");
      cstdlib_strcat((char *)(a1 + 13000), v28);
      if (v27)
      {
        cstdlib_strcat((char *)(a1 + 13000), ",");
        goto LABEL_59;
      }
LABEL_60:
      if (v37)
      {
        unsigned __int16 v43 = (const char *)NormalizeLangCode((void *)a1, v37);
        cstdlib_strcat((char *)(a1 + 13000), ",");
        goto LABEL_62;
      }
    }
    else
    {
      if (v27)
      {
LABEL_59:
        cstdlib_strcat((char *)(a1 + 13000), "age:");
        cstdlib_strcat((char *)(a1 + 13000), v27);
        goto LABEL_60;
      }
      if (v37)
      {
        unsigned __int16 v43 = (const char *)NormalizeLangCode((void *)a1, v37);
LABEL_62:
        cstdlib_strcat((char *)(a1 + 13000), "lang:");
        cstdlib_strcat((char *)(a1 + 13000), v43);
      }
    }
    cstdlib_strcat((char *)(a1 + 13000), ")");
  }
LABEL_64:
  if (*(unsigned char *)(a1 + 13000))
  {
    sprintf(a3, "\x1B\\voice=%s\\", "(push)"");
    uint64_t v44 = *(void (**)(char *, void))(a1 + 2640);
    if (v44) {
      v44(a3, *(void *)(a1 + 2648));
    }
    sprintf(a3, "\x1B\\voice=%s\\"", (const char *)(a1 + 13000));
    uint64_t v45 = *(void (**)(char *, void))(a1 + 2640);
    if (v45) {
      v45(a3, *(void *)(a1 + 2648));
    }
  }
  return 0;
}

uint64_t SSMLElement_EMPHASIS_Enter(uint64_t a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  if (CheckTagBond(a1, &v22))
  {
    __sprintf_chk(__src, 0, 0x200uLL, "The \"%s\" element can only contain text", v22);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, (uint64_t)"%s%s", v4, v5, v6, v7, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    cstdlib_strcpy((char *)(a1 + 2104), __src);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v8 = XMLGetStack(a1, "tagOrder");
  if (!v8)
  {
    uint64_t v19 = "SSML Stack unavailable";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v9, v10, v11, v12, "SSML parser error");
    int v20 = -1919934462;
LABEL_10:
    *(_DWORD *)(a1 + 2084) = v20;
    cstdlib_strcpy((char *)(a1 + 2104), v19);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v13 = v8;
  if ((tinystack_View(v8, &v23) & 0x80000000) != 0 && (tinystack_Push(v13, 13) & 0x80000000) != 0)
  {
    uint64_t v19 = "Too many nested attributes";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, (uint64_t)"%s%s", v14, v15, v16, v17, "SSML parser error");
    int v20 = -1919933952;
    goto LABEL_10;
  }
  if (*a2 && *(unsigned char *)*a2) {
    uint64_t v18 = (char *)a2[1];
  }
  else {
    uint64_t v18 = "moderate";
  }
  Emphasis2Prosody(a1, v18);
  return 0;
}

uint64_t SSMLElement_SUB_Enter(uint64_t a1, uint64_t a2)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  uint64_t v40 = 0;
  int v41 = 0;
  if (CheckTagBond(a1, &v41))
  {
    __sprintf_chk(__src, 0, 0x200uLL, "The \"%s\" element can only contain text", v41);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, (uint64_t)"%s%s", v4, v5, v6, v7, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    cstdlib_strcpy((char *)(a1 + 2104), __src);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v8 = XMLGetStack(a1, "tagOrder");
  if (!v8)
  {
    uint64_t v24 = "SSML Stack unavailable";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v9, v10, v11, v12, "SSML parser error");
    int v25 = -1919934462;
LABEL_10:
    *(_DWORD *)(a1 + 2084) = v25;
    uint64_t v22 = (char *)(a1 + 2104);
    uint64_t v23 = (char *)v24;
    goto LABEL_11;
  }
  uint64_t v13 = v8;
  if ((tinystack_View(v8, &v40) & 0x80000000) != 0 && (tinystack_Push(v13, 13) & 0x80000000) != 0)
  {
    uint64_t v24 = "Too many nested attributes";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, (uint64_t)"%s%s", v14, v15, v16, v17, "SSML parser error");
    int v25 = -1919933952;
    goto LABEL_10;
  }
  if (!*(void *)a2 || LH_stricmp(*(char **)a2, "alias"))
  {
    __sprintf_chk(__src, 0, 0x200uLL, "\"alias\" attribute is required in \"sub\" element");
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, (uint64_t)"%s%s", v18, v19, v20, v21, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    uint64_t v22 = (char *)(a1 + 2104);
    uint64_t v23 = __src;
LABEL_11:
    cstdlib_strcpy(v22, v23);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  int v27 = *(void (**)(void, void))(a1 + 2640);
  if (v27) {
    v27(*(void *)(a2 + 8), *(void *)(a1 + 2648));
  }
  uint64_t v28 = XMLGetStack(a1, "auxiliary");
  if (v28)
  {
    if ((tinystack_Push(v28, 16) & 0x80000000) == 0) {
      return NewTagBond(a1, "sub");
    }
    uint64_t v37 = "Too many nested attributes";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, (uint64_t)"%s%s", v33, v34, v35, v36, "SSML parser error");
    int v39 = -1919933952;
    uint64_t v38 = a1;
  }
  else
  {
    uint64_t v37 = "SSML Stack unavailable";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v29, v30, v31, v32, "SSML parser error");
    uint64_t v38 = a1;
    int v39 = -1919934462;
  }
  SetSSMLError(v38, v39, v37);
  return *(unsigned int *)(a1 + 2084);
}

uint64_t SSMLElement_SAYAS_Enter(uint64_t a1, char **a2, char *a3)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  uint64_t v28 = 0;
  if (CheckTagBond(a1, &v28))
  {
    __sprintf_chk(__src, 0, 0x200uLL, "The \"%s\" element can only contain text", v28);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, (uint64_t)"%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    cstdlib_strcpy((char *)(a1 + 2104), __src);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v10 = XMLGetStack(a1, "say-as");
  if (!v10)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v11, v12, v13, v14, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    uint64_t v21 = (char *)(a1 + 2104);
    uint64_t v22 = "SSML Stack unavailable";
LABEL_21:
    cstdlib_strcpy(v21, v22);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v15 = v10;
  uint64_t v16 = ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), (const char *)(a1 + 13164), 0);
  if (!v16)
  {
    *(_DWORD *)(a1 + 2084) = -1919934454;
    uint64_t v21 = (char *)(a1 + 2104);
    uint64_t v22 = "Out of Memory";
    goto LABEL_21;
  }
  tinystack_Push(v15, (uint64_t)v16);
  *a3 = 0;
  uint64_t v17 = *a2;
  if (*a2)
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = a2 + 1;
    do
    {
      if (LH_stricmp(v17, "format"))
      {
        if (!LH_stricmp(*(v20 - 1), "interpret-as")) {
          uint64_t v18 = *v20;
        }
      }
      else
      {
        uint64_t v19 = *v20;
      }
      uint64_t v17 = v20[1];
      v20 += 2;
    }
    while (v17);
    if (!v18)
    {
      if (!v19 || LH_stricmp(v19, "slot")) {
        goto LABEL_40;
      }
      strcpy(a3, "\x1B\\slotbegin\\"");
      goto LABEL_39;
    }
    if (LH_stricmp(v18, "rational")
      && LH_stricmp(v18, "real")
      && LH_stricmp(v18, "decimal"))
    {
      if (!LH_stricmp(v18, "date") && v19)
      {
        cstdlib_strncpy((char *)(a1 + 13280), v19, 0x1FuLL);
        *(unsigned char *)(a1 + 13311) = 0;
LABEL_27:
        if (LH_stricmp(v19, "slot"))
        {
LABEL_28:
          uint64_t v24 = 0;
          int v25 = (char **)&qword_26456B388;
          while (LH_stricmp(v18, *(v25 - 1)))
          {
            ++v24;
            v25 += 2;
            if (v24 == 27) {
              goto LABEL_37;
            }
          }
          if (((0x7D09477uLL >> v24) & 1) == 0) {
            uint64_t v18 = *v25;
          }
LABEL_37:
          cstdlib_strcpy((char *)(a1 + 13164), v18);
          sprintf(a3, "\x1B\\tn=%s\\"", (const char *)(a1 + 13164));
          goto LABEL_40;
        }
        sprintf(a3, "\x1B\\slotbegin=%s\\"", v18);
LABEL_39:
        size_t v26 = cstdlib_strlen((const char *)(a1 + 13164));
        cstdlib_memmove((void *)(a1 + 13165), (const void *)(a1 + 13164), v26 + 1);
        *(unsigned char *)(a1 + 13164) = 95;
        goto LABEL_40;
      }
    }
    else if (*(unsigned char *)(a1 + 13128) == 101 && *(unsigned char *)(a1 + 13129) == 110)
    {
      *(_DWORD *)(a1 + 13312) = 1;
    }
    if (!v19) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
LABEL_40:
  int v27 = *(void (**)(char *, void))(a1 + 2640);
  if (v27)
  {
    if (*a3) {
      v27(a3, *(void *)(a1 + 2648));
    }
  }
  return 0;
}

uint64_t SSMLElement_AUDIO_Enter(uint64_t a1, char **a2, char *a3)
{
  uint64_t v76 = *MEMORY[0x263EF8340];
  uint64_t v42 = 0;
  long long v75 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  *(_OWORD *)char __dst = 0u;
  int v41 = 0;
  if (CheckTagBond(a1, &v41))
  {
    __sprintf_chk(__src, 0, 0x200uLL, "The \"%s\" element can only contain text", v41);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, (uint64_t)"%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    cstdlib_strcpy((char *)(a1 + 2104), __src);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t result = NewTagBond(a1, "audio");
  if (!result)
  {
    uint64_t v11 = XMLGetStack(a1, "tagOrder");
    if (v11)
    {
      uint64_t v16 = v11;
      if ((tinystack_View(v11, &v42) & 0x80000000) != 0 && (tinystack_Push(v16, 13) & 0x80000000) != 0) {
        goto LABEL_28;
      }
      uint64_t v21 = *a2;
      if (*a2)
      {
        uint64_t v22 = 0;
        uint64_t v23 = 2;
        do
        {
          if (!LH_stricmp(v21, "src")) {
            uint64_t v22 = v23 - 1;
          }
          uint64_t v21 = a2[v23];
          v23 += 2;
        }
        while (v21);
      }
      else
      {
        uint64_t v22 = 0;
      }
      uint64_t v24 = XMLGetStack(a1, "auxiliary");
      if (v24)
      {
        if ((tinystack_Push(v24, 0x4000) & 0x80000000) == 0)
        {
          uint64_t v25 = XMLGetStack(a1, "audio");
          if (!v25)
          {
            uint64_t v37 = "SSML Stack unavailable";
            log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v26, v27, v28, v29, "SSML parser error");
            uint64_t v39 = a1;
            int v38 = -1919934462;
LABEL_30:
            SetSSMLError(v39, v38, v37);
            return *(unsigned int *)(a1 + 2084);
          }
          uint64_t v30 = v25;
          if (v22)
          {
            uint64_t v31 = *(const char **)(a1 + 13320);
            if (v31)
            {
              size_t v32 = cstdlib_strlen(*(const char **)(a1 + 13320));
              if (cstdlib_strlen(a2[v22]) + v32 > 0x1FE)
              {
                uint64_t v37 = "Unable to retrieve base URI";
                log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, (uint64_t)"%s%s", v33, v34, v35, v36, "SSML parser error");
                int v38 = -1919934460;
LABEL_29:
                uint64_t v39 = a1;
                goto LABEL_30;
              }
            }
            UriCompleteUrl(v31, a2[v22], __dst);
            ELQSubstituteEntitiesUTF8(__dst, 1);
            sprintf(a3, "\x1B\\audio=\"%s\"", __dst);
            uint64_t v40 = *(void (**)(char *, void))(a1 + 2640);
            if (v40) {
              v40(a3, *(void *)(a1 + 2648));
            }
          }
          if ((tinystack_Push(v30, 1) & 0x80000000) == 0) {
            return 0;
          }
        }
LABEL_28:
        uint64_t v37 = "Too many nested attributes";
        log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, (uint64_t)"%s%s", v17, v18, v19, v20, "SSML parser error");
        int v38 = -1919933952;
        goto LABEL_29;
      }
    }
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v12, v13, v14, v15, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    cstdlib_strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  return result;
}

uint64_t SSMLElement_STYLE_Enter(uint64_t a1, char **a2, char *a3)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  if (!*a2)
  {
    __sprintf_chk(__src, 0, 0x200uLL, "At least one attribute must be specified for \"style\" element");
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1305, (uint64_t)"%s%s", v10, v11, v12, v13, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    uint64_t v14 = (char *)(a1 + 2104);
    uint64_t v15 = __src;
LABEL_27:
    cstdlib_strcpy(v14, v15);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  if (CheckTagBond(a1, &v40))
  {
    __sprintf_chk(__src, 0, 0x200uLL, "The \"%s\" element can only contain text", v40);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, (uint64_t)"%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    cstdlib_strcpy((char *)(a1 + 2104), __src);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v16 = XMLGetStack(a1, "tagOrder");
  if (!v16) {
    goto LABEL_23;
  }
  uint64_t v21 = v16;
  if ((tinystack_View(v16, &v41) & 0x80000000) != 0 && (tinystack_Push(v21, 13) & 0x80000000) != 0)
  {
    uint64_t v34 = "Too many nested attributes";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, (uint64_t)"%s%s", v22, v23, v24, v25, "SSML parser error");
    unsigned int v36 = -1919933952;
    goto LABEL_26;
  }
  uint64_t v26 = XMLGetStack(a1, "style");
  if (!v26)
  {
LABEL_23:
    uint64_t v34 = "SSML Stack unavailable";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v17, v18, v19, v20, "SSML parser error");
    unsigned __int16 v35 = 8194;
LABEL_25:
    unsigned int v36 = v35 | 0x8D900000;
LABEL_26:
    *(_DWORD *)(a1 + 2084) = v36;
    uint64_t v14 = (char *)(a1 + 2104);
    uint64_t v15 = (char *)v34;
    goto LABEL_27;
  }
  uint64_t v39 = v26;
  uint64_t v27 = *a2;
  if (!*a2) {
    goto LABEL_24;
  }
  unsigned int v28 = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  int v31 = 0;
  size_t v32 = a2;
  do
  {
    if (LH_stricmp(v27, "name"))
    {
      if (*(_DWORD *)(a1 + 13160) == 1 && !LH_stricmp(*v32, "intensity")) {
        uint64_t v29 = a2[v28 | 1];
      }
    }
    else
    {
      uint64_t v30 = a2[v28 | 1];
    }
    unsigned int v28 = 2 * (unsigned __int16)++v31;
    size_t v32 = &a2[v28];
    uint64_t v27 = *v32;
  }
  while (*v32);
  if (!v30)
  {
LABEL_24:
    uint64_t v34 = "\"style\" element must have a name attribute\n";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, (uint64_t)"%s%s", v17, v18, v19, v20, "SSML parser error");
    unsigned __int16 v35 = 15985;
    goto LABEL_25;
  }
  size_t v33 = cstdlib_strlen(v30);
  if (*(_DWORD *)(a1 + 13160) && v29) {
    v33 += cstdlib_strlen(v29) + 1;
  }
  if (v33 - 512 <= 0xFFFFFFFFFFFFFDFELL)
  {
    *(_DWORD *)(a1 + 2084) = -1919934455;
    uint64_t v14 = (char *)(a1 + 2104);
    uint64_t v15 = "Out of Memory";
    goto LABEL_27;
  }
  int v38 = ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), (const char *)(a1 + 1572), 0);
  if (!v38)
  {
    SetSSMLError(a1, -1919934454, "Out of Memory");
    return *(unsigned int *)(a1 + 2084);
  }
  tinystack_Push(v39, (uint64_t)v38);
  *(unsigned char *)(a1 + 1572) = 0;
  cstdlib_strcat((char *)(a1 + 1572), v30);
  if (*(_DWORD *)(a1 + 13160))
  {
    if (v29)
    {
      cstdlib_strcat((char *)(a1 + 1572), ";");
      cstdlib_strcat((char *)(a1 + 1572), v29);
    }
  }
  return ApplyCurrentStyle(a1, a3);
}

char *SSMLElement_PROMPT_Enter(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  if (CheckTagBond(a1, &v25))
  {
    __sprintf_chk(__src, 0, 0x200uLL, "The \"%s\" element can only contain text", v25);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, (uint64_t)"%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    cstdlib_strcpy((char *)(a1 + 2104), __src);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return (char *)*(unsigned int *)(a1 + 2084);
  }
  uint64_t v10 = XMLGetStack(a1, "tagOrder");
  if (!v10)
  {
    uint64_t v21 = "SSML Stack unavailable";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v11, v12, v13, v14, "SSML parser error");
    int v22 = -1919934462;
LABEL_10:
    *(_DWORD *)(a1 + 2084) = v22;
    cstdlib_strcpy((char *)(a1 + 2104), v21);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return (char *)*(unsigned int *)(a1 + 2084);
  }
  uint64_t v15 = v10;
  if ((tinystack_View(v10, &v24) & 0x80000000) != 0 && (tinystack_Push(v15, 13) & 0x80000000) != 0)
  {
    uint64_t v21 = "Too many nested attributes";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, (uint64_t)"%s%s", v16, v17, v18, v19, "SSML parser error");
    int v22 = -1919933952;
    goto LABEL_10;
  }
  uint64_t result = *(char **)a2;
  if (*(void *)a2)
  {
    if (!LH_stricmp(result, "id") && *(void *)(a2 + 8))
    {
      sprintf(a3, "\x1B\\prompt=%s\\"", *(const char **)(a2 + 8));
      uint64_t v23 = *(void (**)(char *, void))(a1 + 2640);
      if (v23) {
        v23(a3, *(void *)(a1 + 2648));
      }
    }
    return 0;
  }
  return result;
}

uint64_t SSMLElement_DESC_Enter(uint64_t a1, char **a2, char *a3)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  int v6 = *(_DWORD *)(a1 + 2716);
  if (CheckTagBond(a1, &v34))
  {
    __sprintf_chk(__src, 0, 0x200uLL, "The \"%s\" element can only contain text", v34);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, (uint64_t)"%s%s", v7, v8, v9, v10, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    cstdlib_strcpy((char *)(a1 + 2104), __src);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v11 = XMLGetStack(a1, "tagOrder");
  if (!v11)
  {
    int v31 = "SSML Stack unavailable";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v12, v13, v14, v15, "SSML parser error");
    int v32 = -1919934462;
LABEL_28:
    *(_DWORD *)(a1 + 2084) = v32;
    cstdlib_strcpy((char *)(a1 + 2104), v31);
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v16 = v11;
  if ((tinystack_View(v11, &v35) & 0x80000000) != 0 && (tinystack_Push(v16, 13) & 0x80000000) != 0)
  {
    int v31 = "Too many nested attributes";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, (uint64_t)"%s%s", v17, v18, v19, v20, "SSML parser error");
    int v32 = -1919933952;
    goto LABEL_28;
  }
  uint64_t v21 = *a2;
  if (*a2)
  {
    size_t v33 = 0;
    uint64_t v22 = 0;
    unsigned int v23 = 1;
    uint64_t v24 = a2;
    do
    {
      if (LH_stricmp(v21, "onlangfailure") || (uint64_t v25 = a2[v23]) == 0)
      {
        if (*v24)
        {
          if (SSMLstricmp(a1, *v24, "lang") && SSMLstricmp(a1, *v24, "xml:lang")
            || !a2[v23])
          {
            if (*v24)
            {
              if (!LH_stricmp(*v24, "autolid"))
              {
                uint64_t v26 = a2[v23];
                if (v26)
                {
                  int v27 = SSMLstricmp(a1, v26, "no");
                  unsigned int v28 = "yes";
                  if (!v27) {
                    unsigned int v28 = "no";
                  }
                  size_t v33 = (char *)v28;
                }
              }
            }
          }
          else
          {
            uint64_t v22 = (uint64_t)a2[v23];
          }
        }
      }
      else
      {
        int v6 = SSMLGetLangFailureCode(v25);
      }
      uint64_t v24 = &a2[v23 + 1];
      uint64_t v21 = *v24;
      v23 += 2;
    }
    while (*v24);
    if (v6) {
      goto LABEL_24;
    }
    goto LABEL_32;
  }
  uint64_t v22 = 0;
  size_t v33 = 0;
  if (!v6) {
LABEL_32:
  }
    SSMLPushVoice(a1);
LABEL_24:
  SSMLOnLanguageChange(a1, v22, v33, v6, a3);
  uint64_t v29 = *(void (**)(char *, void))(a1 + 2640);
  if (v29) {
    v29(a3, *(void *)(a1 + 2648));
  }
  return 0;
}

uint64_t SSMLElement_LEXICON_Enter(uint64_t a1, char **a2, uint64_t a3)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  *(_OWORD *)char __dst = 0u;
  long long v33 = 0u;
  if (CheckTagBond(a1, &v31))
  {
    *(_DWORD *)(a1 + 2084) = -1919926670;
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v7 = XMLGetStack(a1, "tagOrder");
  if (!v7)
  {
    uint64_t result = 2375032834;
LABEL_11:
    *(_DWORD *)(a1 + 2084) = result;
    return result;
  }
  if ((tinystack_View(v7, &v30) & 0x80000000) == 0 && v30 == 13)
  {
    unsigned __int16 v8 = 15986;
LABEL_10:
    uint64_t result = v8 | 0x8D900000;
    goto LABEL_11;
  }
  if (*(void *)(a1 + 14376) == 63) {
    goto LABEL_9;
  }
  uint64_t v9 = *a2;
  if (!*a2) {
    goto LABEL_39;
  }
  uint64_t v10 = 0;
  __s = 0;
  uint64_t v11 = 0;
  do
  {
    if (!LH_stricmp(v9, "uri")) {
      uint64_t v11 = v10 + 1;
    }
    uint64_t v12 = a2[v10];
    if (v12)
    {
      if (!SSMLstricmp(a1, v12, "base") || !SSMLstricmp(a1, a2[v10], "xml:base"))
      {
        uint64_t v13 = a2[v10 + 1];
        if (v13)
        {
          UrlSetBaseURI(a1, v13);
          uint64_t v14 = *(void (**)(uint64_t, void))(a1 + 2640);
          if (v14) {
            v14(a3, *(void *)(a1 + 2648));
          }
        }
      }
      uint64_t v15 = a2[v10];
      if (v15)
      {
        if (!SSMLstricmp(a1, v15, "type"))
        {
          uint64_t v16 = a2[v10 + 1];
          if (v16)
          {
            uint64_t v17 = *(void (**)(uint64_t, void))(a1 + 2640);
            if (v17) {
              v17(a3, *(void *)(a1 + 2648));
            }
            __s = v16;
          }
        }
      }
    }
    uint64_t v9 = a2[v10 + 2];
    v10 += 2;
  }
  while (v9);
  if (!v11)
  {
LABEL_39:
    uint64_t result = 2375040625;
    goto LABEL_11;
  }
  uint64_t v18 = *(const char **)(a1 + 13320);
  if (v18)
  {
    size_t v19 = cstdlib_strlen(*(const char **)(a1 + 13320));
    if (cstdlib_strlen(a2[v11]) + v19 >= 0x1FF)
    {
LABEL_9:
      unsigned __int16 v8 = 8201;
      goto LABEL_10;
    }
  }
  UriCompleteUrl(v18, a2[v11], __dst);
  ELQSubstituteEntitiesUTF8(__dst, 1);
  if (*(void *)(a1 + 13344))
  {
    uint64_t v24 = __s;
    if (!__s || !cstdlib_strlen(__s)) {
      uint64_t v24 = determineMediaType(__dst);
    }
    if (((*(uint64_t (**)(void, void, char *, char *, void, void, uint64_t))(*(void *)(a1 + 13344)
                                                                                             + 72))(*(void *)(a1 + 13328), *(void *)(a1 + 13336), v24, __dst, 0, 0, a1 + 16 * *(void *)(a1 + 14376) + 13352) & 0x80000000) != 0)
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1448, (uint64_t)"%s%s", v25, v26, v27, v28, "lexicon");
      return 0;
    }
    else
    {
      uint64_t result = 0;
      ++*(void *)(a1 + 14376);
    }
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1448, (uint64_t)"%s%s", v20, v21, v22, v23, "lexicon");
    return 2375032857;
  }
  return result;
}

uint64_t SSMLstricmp(uint64_t a1, char *__s, char *a3)
{
  if (!__s || !a3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = __s;
  uint64_t v5 = cstdlib_strchr(__s, *(char *)(a1 + 12968));
  if (v5)
  {
    int v7 = *v5;
    int v6 = v5 + 1;
    if (v7) {
      uint64_t v4 = v6;
    }
  }

  return LH_stricmp(v4, a3);
}

uint64_t UrlSetBaseURI(uint64_t result, char *__s1)
{
  uint64_t v3 = result;
  uint64_t v4 = *(const char **)(result + 13320);
  if (v4)
  {
    if (__s1)
    {
      uint64_t result = cstdlib_strcmp(__s1, v4);
      if (!result) {
        return result;
      }
      uint64_t v4 = *(const char **)(v3 + 13320);
    }
  }
  else
  {
    if (!__s1 || !*__s1) {
      return result;
    }
    uint64_t v4 = 0;
  }
  uint64_t result = (uint64_t)heap_Free(*(void **)(*(void *)(v3 + 12992) + 8), (uint64_t)v4);
  if (__s1 && *__s1)
  {
    uint64_t v5 = *(void *)(*(void *)(v3 + 12992) + 8);
    size_t v6 = cstdlib_strlen(__s1);
    uint64_t result = heap_Alloc(v5, v6 + 1);
    *(void *)(v3 + 13320) = result;
    if (result)
    {
      return (uint64_t)cstdlib_strcpy((char *)result, __s1);
    }
  }
  else
  {
    *(void *)(v3 + 13320) = 0;
  }
  return result;
}

uint64_t SSMLSaveOnLangFailureIntoStack(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = XMLGetStack(a1, "onlangfailure");
  if (v4)
  {
    uint64_t result = tinystack_Push(v4, a2);
    if ((result & 0x80000000) == 0) {
      return result;
    }
    uint64_t v15 = "Too many nested attributes";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, (uint64_t)"%s%s", v10, v11, v12, v13, "SSML parser error");
    int v14 = -1919933952;
  }
  else
  {
    int v14 = -1919934462;
    uint64_t v15 = "SSML Stack unavailable";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v5, v6, v7, v8, "SSML parser error");
  }
  *(_DWORD *)(a1 + 2084) = v14;
  cstdlib_strcpy((char *)(a1 + 2104), v15);
  uint64_t v16 = *(void *)(a1 + 2624);

  return ELQXMLGetCurrentLineNumber(v16);
}

uint64_t NormalizeLangCode(void *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  int v9 = 1;
  uint64_t v8 = 0;
  uint64_t v3 = a1[1798];
  if (v3
    && ((*(uint64_t (**)(void, void, uint64_t, void, uint64_t *, int *, void))(v3 + 32))(a1[1799], a1[1800], a2, 0, &v8, &v9, 0) & 0x80000000) == 0)
  {
    int v5 = v9;
    if (v9)
    {
      BOOL v6 = 1;
    }
    else
    {
      BOOL v6 = (*(int (**)(void, void, uint64_t, uint64_t *, int *))(a1[1798] + 40))(a1[1799], a1[1800], v2, &v8, &v9) >= 0;
      int v5 = v9;
    }
    if (v6 && v5 != 0) {
      return v8;
    }
  }
  return v2;
}

char *aux_SetActiveLanguage(uint64_t a1, const char *a2, char *a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  BOOL v6 = (char *)(a1 + 13128);
  uint64_t v7 = cstdlib_strchr((char *)(a1 + 13128), 58);
  uint64_t v8 = v7;
  if (a2)
  {
    cstdlib_strcpy(__dst, a2);
    if (!a3)
    {
LABEL_6:
      if (!v8) {
        return cstdlib_strcpy(v6, __dst);
      }
      goto LABEL_11;
    }
  }
  else if (v7)
  {
    cstdlib_strncpy(__dst, v6, v7 - v6);
    __dst[v8 - v6] = 0;
    if (!a3) {
      goto LABEL_6;
    }
  }
  else
  {
    cstdlib_strcpy(__dst, v6);
    if (!a3) {
      return cstdlib_strcpy(v6, __dst);
    }
  }
  if (!SSMLstricmp(a1, a3, "no"))
  {
    uint64_t v8 = ":noautolid";
LABEL_11:
    cstdlib_strcat(__dst, v8);
  }
  return cstdlib_strcpy(v6, __dst);
}

uint64_t XMLGetStack(uint64_t a1, char *a2)
{
  uint64_t result = 0;
  if (a1 && a2)
  {
    if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) == ELQSSMLIni)
    {
      uint64_t v5 = a1 + 16;
      if (*(void *)(a1 + 16))
      {
        if (!LH_stricmp(*(char **)(a1 + 24), a2)) {
          return *(void *)v5;
        }
        unsigned int v6 = 1;
        while (1)
        {
          uint64_t v7 = a1 + 24 * v6;
          uint64_t v8 = *(void *)(v7 + 16);
          uint64_t v5 = v7 + 16;
          if (!v8) {
            break;
          }
          unsigned int v9 = v6;
          int v10 = LH_stricmp(*(char **)(a1 + 24 * v6 + 24), a2);
          unsigned int v6 = v9 + 1;
          if (!v10) {
            return *(void *)v5;
          }
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t CheckTagBond(uint64_t a1, void *a2)
{
  uint64_t result = XMLGetStack(a1, "TagBond");
  if (result)
  {
    uint64_t v4 = 0;
    if ((tinystack_View(result, &v4) & 0x80000000) != 0)
    {
      return 0;
    }
    else
    {
      *a2 = v4;
      return 1;
    }
  }
  return result;
}

void *ReleaseTagBond(uint64_t a1)
{
  uint64_t v3 = 0;
  uint64_t result = (void *)XMLGetStack(a1, "TagBond");
  if (result)
  {
    uint64_t result = (void *)tinystack_Pop((uint64_t)result, &v3);
    if (v3) {
      return heap_Free(*(void **)(*(void *)(a1 + 12992) + 8), v3);
    }
  }
  return result;
}

uint64_t XMLGetCurrentValue(uint64_t a1)
{
  if (!a1) {
    return -1;
  }
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni
    || !*(void *)(a1 + 16))
  {
    return -1;
  }
  uint64_t v3 = 0;
  unsigned int v4 = 1;
  while (LH_stricmp(*(char **)(a1 + 24 * v3 + 24), "metadata"))
  {
    uint64_t v3 = v4;
    if (!*(void *)(a1 + 24 * v4++ + 16)) {
      return -1;
    }
  }
  return *(void *)(a1 + 24 * v3 + 32);
}

uint64_t SSMLPushProsodicParameters(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v2 = XMLGetStack(a1, "volume");
  if (v2)
  {
    uint64_t v3 = v2;
    __sprintf_chk(v10, 0, 0x14uLL, "%d", *(_DWORD *)(a1 + 1560));
    uint64_t result = (uint64_t)ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), v10, 0);
    if (!result) {
      return result;
    }
    tinystack_Push(v3, result);
  }
  uint64_t v5 = XMLGetStack(a1, "pitch");
  if (v5)
  {
    uint64_t v6 = v5;
    __sprintf_chk(v10, 0, 0x14uLL, "%d", *(_DWORD *)(a1 + 1564));
    uint64_t result = (uint64_t)ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), v10, 0);
    if (!result) {
      return result;
    }
    tinystack_Push(v6, result);
  }
  uint64_t v7 = XMLGetStack(a1, "timbre");
  if (v7)
  {
    uint64_t v8 = v7;
    __sprintf_chk(v10, 0, 0x14uLL, "%d", *(_DWORD *)(a1 + 2088));
    uint64_t result = (uint64_t)ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), v10, 0);
    if (!result) {
      return result;
    }
    tinystack_Push(v8, result);
  }
  uint64_t result = XMLGetStack(a1, "speed");
  if (result)
  {
    uint64_t v9 = result;
    __sprintf_chk(v10, 0, 0x14uLL, "%d", *(_DWORD *)(a1 + 1568));
    uint64_t result = (uint64_t)ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), v10, 0);
    if (result) {
      return tinystack_Push(v9, result);
    }
  }
  return result;
}

uint64_t ParseAttribute(uint64_t a1, char *a2, int a3)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  v29[0] = 0;
  if (!*a2) {
    return 0;
  }
  uint64_t v28 = 0;
  switch(a3)
  {
    case 1:
      if (LH_stricmp(a2, "silent"))
      {
        if (LH_stricmp(a2, "x-soft"))
        {
          if (LH_stricmp(a2, "soft"))
          {
            if (!LH_stricmp(a2, "medium"))
            {
LABEL_10:
              int v5 = 80;
              goto LABEL_83;
            }
            if (LH_stricmp(a2, "loud"))
            {
              if (LH_stricmp(a2, "x-loud"))
              {
                if (LH_stricmp(a2, "default")) {
                  goto LABEL_84;
                }
                goto LABEL_10;
              }
              int v5 = 100;
            }
            else
            {
              int v5 = 90;
            }
          }
          else
          {
            int v5 = 53;
          }
        }
        else
        {
          int v5 = 26;
        }
      }
      else
      {
        int v5 = 0;
      }
LABEL_83:
      *(_DWORD *)(a1 + 1560) = v5;
      __sprintf_chk(v29, 0, 0x200uLL, "\x1B\\vol=%d\\"", v5);
LABEL_84:
      if (!v29[0])
      {
        cstdlib_strtod((unsigned __int8 *)a2, &v28);
        float v23 = v22;
        if (*v28 == 37)
        {
          double v24 = (float)(v23 * (float)*(int *)(a1 + 1560)) / 100.0 + (double)*(int *)(a1 + 1560);
          unsigned int v25 = (int)v24 & ~((int)v24 >> 31);
          if (v25 >= 0x64) {
            unsigned int v25 = 100;
          }
        }
        else
        {
          int v26 = (int)v23;
          if ((int)v23 >= 100) {
            int v26 = 100;
          }
          unsigned int v25 = v26 & ~(v26 >> 31);
        }
        *(_DWORD *)(a1 + 1560) = v25;
        __sprintf_chk(v29, 0, 0x200uLL, "\x1B\\vol=%d\\"");
      }
      goto LABEL_92;
    case 2:
      if (LH_stricmp(a2, "x-fast"))
      {
        if (LH_stricmp(a2, "fast"))
        {
          if (!LH_stricmp(a2, "medium"))
          {
LABEL_17:
            int v6 = 100;
            goto LABEL_46;
          }
          if (LH_stricmp(a2, "slow"))
          {
            if (LH_stricmp(a2, "x-slow"))
            {
              if (LH_stricmp(a2, "default")) {
                goto LABEL_47;
              }
              goto LABEL_17;
            }
            int v6 = 50;
          }
          else
          {
            int v6 = 75;
          }
        }
        else
        {
          int v6 = 150;
        }
      }
      else
      {
        int v6 = 200;
      }
LABEL_46:
      *(_DWORD *)(a1 + 1568) = v6;
      __sprintf_chk(v29, 0, 0x200uLL, "\x1B\\rate=%d\\"", v6);
LABEL_47:
      if (v29[0]) {
        goto LABEL_92;
      }
      cstdlib_strtod((unsigned __int8 *)a2, &v28);
      float v10 = v9;
      if (*v28 == 37)
      {
        double v11 = (float)(v10 * (float)*(int *)(a1 + 1568)) / 100.0 + (double)*(int *)(a1 + 1568);
        int v12 = (int)v11 & ~((int)v11 >> 31);
        if (v12 >= 0xC8) {
          int v12 = 200;
        }
        if (v12 <= 0x32) {
          int v12 = 50;
        }
      }
      else
      {
        if (v10 < 0.0) {
          return 0;
        }
        int v12 = (int)(float)(v10 * (float)*(int *)(a1 + 1568));
        if (v12 >= 200) {
          int v12 = 200;
        }
        if (v12 <= 50) {
          int v12 = 50;
        }
      }
      *(_DWORD *)(a1 + 1568) = v12;
      __sprintf_chk(v29, 0, 0x200uLL, "\x1B\\rate=%d\\"");
      goto LABEL_92;
    case 3:
      if (LH_stricmp(a2, "x-high"))
      {
        if (LH_stricmp(a2, "high"))
        {
          if (!LH_stricmp(a2, "medium"))
          {
LABEL_24:
            int v7 = 100;
            goto LABEL_60;
          }
          if (LH_stricmp(a2, "low"))
          {
            if (LH_stricmp(a2, "x-low"))
            {
              if (LH_stricmp(a2, "default")) {
                goto LABEL_61;
              }
              goto LABEL_24;
            }
            int v7 = 70;
          }
          else
          {
            int v7 = 85;
          }
        }
        else
        {
          int v7 = 135;
        }
      }
      else
      {
        int v7 = 160;
      }
LABEL_60:
      *(_DWORD *)(a1 + 1564) = v7;
      __sprintf_chk(v29, 0, 0x200uLL, "\x1B\\pitch=%d\\"", v7);
LABEL_61:
      if (v29[0]) {
        goto LABEL_92;
      }
      cstdlib_strtod((unsigned __int8 *)a2, &v28);
      if (*v28 != 37) {
        return 0;
      }
      float v14 = v13;
      double v15 = (float)(v14 * (float)*(int *)(a1 + 1564)) / 100.0 + (double)*(int *)(a1 + 1564);
      unsigned int v16 = (int)v15 & ~((int)v15 >> 31);
      if (v16 >= 0xC8) {
        unsigned int v16 = 200;
      }
      if (v16 <= 0x32) {
        unsigned int v16 = 50;
      }
      *(_DWORD *)(a1 + 1564) = v16;
      __sprintf_chk(v29, 0, 0x200uLL, "\x1B\\pitch=%d\\"");
      goto LABEL_92;
    case 4:
      if (LH_stricmp(a2, "x-young"))
      {
        if (LH_stricmp(a2, "young"))
        {
          if (!LH_stricmp(a2, "medium"))
          {
LABEL_31:
            int v8 = 100;
            goto LABEL_70;
          }
          if (LH_stricmp(a2, "old"))
          {
            if (LH_stricmp(a2, "x-old"))
            {
              if (LH_stricmp(a2, "default")) {
                goto LABEL_71;
              }
              goto LABEL_31;
            }
            int v8 = 65;
          }
          else
          {
            int v8 = 80;
          }
        }
        else
        {
          int v8 = 120;
        }
      }
      else
      {
        int v8 = 135;
      }
LABEL_70:
      *(_DWORD *)(a1 + 2088) = v8;
      __sprintf_chk(v29, 0, 0x200uLL, "\x1B\\timbre=%d\\"", v8);
LABEL_71:
      if (!v29[0])
      {
        cstdlib_strtod((unsigned __int8 *)a2, &v28);
        float v19 = v18;
        if (*v28 == 37)
        {
          double v20 = (float)(v19 * (float)*(int *)(a1 + 2088)) / 100.0 + (double)*(int *)(a1 + 2088);
          int v21 = (int)v20 & ~((int)v20 >> 31);
          if (v21 >= 0xC8) {
            int v21 = 200;
          }
          if (v21 <= 0x32) {
            int v21 = 50;
          }
        }
        else
        {
          int v21 = (int)v19;
          if ((int)v19 >= 200) {
            int v21 = 200;
          }
          if (v21 <= 50) {
            int v21 = 50;
          }
        }
        *(_DWORD *)(a1 + 2088) = v21;
        __sprintf_chk(v29, 0, 0x200uLL, "\x1B\\timbre=%d\\"");
      }
LABEL_92:
      uint64_t v27 = *(void (**)(char *, void))(a1 + 2640);
      if (v27) {
        v27(v29, *(void *)(a1 + 2648));
      }
      uint64_t result = 1;
      break;
    default:
      return 0;
  }
  return result;
}

uint64_t SSMLViewOnLangFailureFromStack(uint64_t a1, _DWORD *a2)
{
  uint64_t v10 = 0;
  uint64_t v4 = XMLGetStack(a1, "onlangfailure");
  if (v4)
  {
    tinystack_View(v4, &v10);
    uint64_t result = 0;
    *a2 = v10;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v5, v6, v7, v8, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    cstdlib_strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  return result;
}

uint64_t SSMLGetLangFailureCode(char *a1)
{
  uint64_t result = LH_stricmp(a1, "changevoice");
  if (result)
  {
    if (LH_stricmp(a1, "ignoretext"))
    {
      if (LH_stricmp(a1, "ignorelang")) {
        return 3;
      }
      else {
        return 2;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t SSMLPushVoice(uint64_t a1)
{
  uint64_t result = XMLGetStack(a1, "voice");
  if (result)
  {
    uint64_t v3 = result;
    uint64_t result = (uint64_t)ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), (const char *)(a1 + 13000), 0);
    if (result)
    {
      return tinystack_Push(v3, result);
    }
  }
  return result;
}

uint64_t SSMLPushLanguage(uint64_t a1)
{
  uint64_t result = XMLGetStack(a1, "language");
  if (result)
  {
    uint64_t v3 = result;
    uint64_t result = (uint64_t)ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), (const char *)(a1 + 13128), 0);
    if (result)
    {
      return tinystack_Push(v3, result);
    }
  }
  return result;
}

uint64_t SSMLOnLanguageChange(uint64_t result, uint64_t a2, char *a3, int a4, char *a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (a2 | (unint64_t)a3 && a4 != 1)
  {
    uint64_t v8 = result;
    if (a4)
    {
      if (a2) {
        uint64_t v10 = (const char *)NormalizeLangCode((void *)result, a2);
      }
      else {
        uint64_t v10 = 0;
      }
      aux_SetActiveLanguage(v8, v10, a3);
      uint64_t result = sprintf(a5, "\x1B\\lang=%s\\"", (const char *)(v8 + 13128));
      double v11 = *(uint64_t (**)(char *, uint64_t))(v8 + 2640);
      if (v11)
      {
        uint64_t v12 = *(void *)(v8 + 2648);
        return v11(a5, v12);
      }
    }
    else
    {
      if (a2)
      {
        cstdlib_strcpy(__dst, "(");
        cstdlib_strcat(__dst, "lang:");
        cstdlib_strcat(__dst, (const char *)a2);
        cstdlib_strcat(__dst, ")");
        sprintf(a5, "\x1B\\voice=%s\\"", __dst);
        uint64_t result = (uint64_t)aux_SetActiveLanguage(v8, (const char *)a2, a3);
      }
      double v9 = *(uint64_t (**)(char *, void))(v8 + 2640);
      if (v9) {
        return v9(a5, *(void *)(v8 + 2648));
      }
    }
  }
  return result;
}

uint64_t NewTagBond(uint64_t a1, const char *a2)
{
  uint64_t v4 = *(void *)(a1 + 12992);
  uint64_t v5 = XMLGetStack(a1, "TagBond");
  if (v5)
  {
    uint64_t v10 = v5;
    double v11 = (char *)heap_Alloc(*(void *)(v4 + 8), 32);
    if (v11)
    {
      uint64_t v16 = (uint64_t)v11;
      cstdlib_strcpy(v11, a2);
      if ((tinystack_Push(v10, v16) & 0x80000000) == 0) {
        return 0;
      }
    }
    double v18 = "Out of Memory";
    log_OutPublic(*(void *)(v4 + 32), (uint64_t)"LIGHTSSML", 1923, (uint64_t)"%s%s", v12, v13, v14, v15, "SSML parser error");
    int v19 = -1919934454;
  }
  else
  {
    double v18 = "SSML Stack unavailable";
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v6, v7, v8, v9, "SSML parser error");
    int v19 = -1919934462;
  }
  *(_DWORD *)(a1 + 2084) = v19;
  cstdlib_strcpy((char *)(a1 + 2104), v18);
  ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
  return *(unsigned int *)(a1 + 2084);
}

uint64_t Emphasis2Prosody(uint64_t a1, char *a2)
{
  SSMLPushProsodicParameters(a1);
  if (a2 && *a2 && LH_stricmp(a2, "moderate"))
  {
    if (LH_stricmp(a2, "strong"))
    {
      if (LH_stricmp(a2, "reduced"))
      {
        LH_stricmp(a2, "none");
        goto LABEL_11;
      }
      float64x2_t v4 = (float64x2_t)vdupq_n_s64(0x4059000000000000uLL);
      int v5 = (int)((float)((float)*(int *)(a1 + 1560) * -10.0) / 100.0 + (double)*(int *)(a1 + 1560));
      uint64_t v6 = (uint32x2_t *)(a1 + 1564);
      int32x2_t v7 = *(int32x2_t *)(a1 + 1564);
      float32x2_t v8 = vcvt_f32_s32(v7);
      float32x2_t v9 = (float32x2_t)0x41200000C1200000;
    }
    else
    {
      float64x2_t v4 = (float64x2_t)vdupq_n_s64(0x4059000000000000uLL);
      int v5 = (int)((float)((float)*(int *)(a1 + 1560) * 20.0) / 100.0 + (double)*(int *)(a1 + 1560));
      uint64_t v6 = (uint32x2_t *)(a1 + 1564);
      int32x2_t v7 = *(int32x2_t *)(a1 + 1564);
      float32x2_t v8 = vcvt_f32_s32(v7);
      float32x2_t v9 = (float32x2_t)0xC1F0000041A00000;
    }
  }
  else
  {
    float64x2_t v4 = (float64x2_t)vdupq_n_s64(0x4059000000000000uLL);
    int v5 = (int)((float)((float)*(int *)(a1 + 1560) * 15.0) / 100.0 + (double)*(int *)(a1 + 1560));
    uint64_t v6 = (uint32x2_t *)(a1 + 1564);
    int32x2_t v7 = *(int32x2_t *)(a1 + 1564);
    float32x2_t v8 = vcvt_f32_s32(v7);
    float32x2_t v9 = (float32x2_t)0xC1A0000041700000;
  }
  float32x2_t v10 = vmul_f32(v8, v9);
  unsigned int v11 = v5 & ~(v5 >> 31);
  if (v11 >= 0x64) {
    unsigned int v11 = 100;
  }
  *(_DWORD *)(a1 + 1560) = v11;
  v12.i64[0] = v7.i32[0];
  v12.i64[1] = v7.i32[1];
  *uint64_t v6 = vmax_u32(vmin_u32((uint32x2_t)vmax_s32(vmovn_s64(vcvtq_s64_f64(vaddq_f64(vdivq_f64(vcvtq_f64_f32(v10), v4), vcvtq_f64_s64(v12)))), 0), (uint32x2_t)0xC8000000C8), (uint32x2_t)0x3200000032);
LABEL_11:

  return OutProsodyTags(a1);
}

uint64_t OutProsodyTags(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  __sprintf_chk(v7, 0, 0x40uLL, "\x1B\\rate=%d\\"", *(_DWORD *)(a1 + 1568));
  uint64_t v2 = *(void (**)(char *, void))(a1 + 2640);
  if (v2) {
    v2(v7, *(void *)(a1 + 2648));
  }
  __sprintf_chk(v7, 0, 0x40uLL, "\x1B\\pitch=%d\\"", *(_DWORD *)(a1 + 1564));
  uint64_t v3 = *(void (**)(char *, void))(a1 + 2640);
  if (v3) {
    v3(v7, *(void *)(a1 + 2648));
  }
  __sprintf_chk(v7, 0, 0x40uLL, "\x1B\\timbre=%d\\"", *(_DWORD *)(a1 + 2088));
  float64x2_t v4 = *(void (**)(char *, void))(a1 + 2640);
  if (v4) {
    v4(v7, *(void *)(a1 + 2648));
  }
  uint64_t result = __sprintf_chk(v7, 0, 0x40uLL, "\x1B\\vol=%d\\"", *(_DWORD *)(a1 + 1560));
  uint64_t v6 = *(uint64_t (**)(char *, void))(a1 + 2640);
  if (v6) {
    return v6(v7, *(void *)(a1 + 2648));
  }
  return result;
}

uint64_t ApplyCurrentStyle(uint64_t a1, char *a2)
{
  sprintf(a2, "\x1B\\style=%s\\"", (const char *)(a1 + 1572));
  float64x2_t v4 = *(void (**)(char *, void))(a1 + 2640);
  if (v4 && *a2)
  {
    v4(a2, *(void *)(a1 + 2648));
    return 0;
  }
  else
  {
    *(_DWORD *)(a1 + 2084) = -1919934462;
    cstdlib_strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
}

char *determineMediaType(char *__s)
{
  if (__s)
  {
    uint64_t v1 = __s;
    uint64_t v2 = 0;
    while (1)
    {
      size_t v3 = cstdlib_strlen(v1);
      float64x2_t v4 = ExtensionMimeTypeMap[2 * v2];
      if (!v3) {
        size_t v3 = cstdlib_strlen(v1);
      }
      size_t v5 = v3;
      if (v4)
      {
        size_t v6 = cstdlib_strlen(v4);
        int32x2_t v7 = &v1[v5 - v6];
        if (v6 <= v5 && v7 >= v1) {
          break;
        }
      }
LABEL_14:
      if (++v2 == 8) {
        return 0;
      }
    }
    size_t v9 = v6;
    while (cstdlib_strncmp(v7, v4, v9))
    {
      if (--v7 < v1) {
        goto LABEL_14;
      }
    }
    return ExtensionMimeTypeMap[2 * v2 + 1];
  }
  return __s;
}

uint64_t SSML10EndConvert(uint64_t a1, char *a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  if (!SSMLstricmpElement(a1, a2, "prosody")) {
    goto LABEL_18;
  }
  if (!SSMLstricmpElement(a1, a2, "p"))
  {
    uint64_t v5 = a1;
    int v6 = 1;
    return SSMLElement_Block_Exit(v5, v18, v6);
  }
  if (!SSMLstricmpElement(a1, a2, "s"))
  {
    uint64_t v5 = a1;
    int v6 = 0;
    return SSMLElement_Block_Exit(v5, v18, v6);
  }
  if (!SSMLstricmpElement(a1, a2, "lang"))
  {
    uint64_t v5 = a1;
    int v6 = 2;
    return SSMLElement_Block_Exit(v5, v18, v6);
  }
  if (!SSMLstricmpElement(a1, a2, "emphasis"))
  {
LABEL_18:
    SSMLPopProsodicParameters((_DWORD *)a1);
    return 0;
  }
  if (!SSMLstricmpElement(a1, a2, "break")) {
    return 0;
  }
  if (!SSMLstricmpElement(a1, a2, "phoneme"))
  {
    uint64_t v4 = 2375032842;
    uint64_t v9 = *(void *)(a1 + 12992);
    uint64_t v11 = *(void *)(v9 + 8);
    float32x2_t v10 = (uint64_t **)(v9 + 8);
    int64x2_t v12 = (void *)heap_Alloc(v11, 24);
    if (v12)
    {
      uint64_t v13 = v12;
      *int64x2_t v12 = v10;
      v12[1] = 0;
      v12[2] = 0;
      uint64_t v14 = strhelper_StringAppend(*v10, 0, *(char **)(*(void *)(a1 + 13264) + 8), 0xFFFFFFFFFFFFFFFFLL, v12 + 2, 0x80uLL);
      v13[1] = v14;
      if (v14)
      {
        uint64_t v15 = SSMLElement_PHONEME_Exit(a1, v14);
        DynStringDestroy((void **)v13);
        return v15;
      }
    }
    return v4;
  }
  if (SSMLstricmpElement(a1, a2, "sub"))
  {
    if (!SSMLstricmpElement(a1, a2, "say-as")) {
      return SSMLElement_SAYAS_Exit(a1, v18);
    }
    if (!SSMLstricmpElement(a1, a2, "voice"))
    {
      SSMLElement_VOICE_Exit(a1, v18);
      return 0;
    }
    if (!SSMLstricmpElement(a1, a2, "speak")) {
      return SSMLElement_SPEAK_Exit(a1, v18);
    }
    if (SSMLstricmpElement(a1, a2, "audio"))
    {
      if (SSMLstricmpElement(a1, a2, "style"))
      {
        if (!SSMLstricmpElement(a1, a2, "desc"))
        {
          uint64_t v16 = *(void (**)(char *, void))(a1 + 2640);
          if (v16) {
            v16(v18, *(void *)(a1 + 2648));
          }
          return 0;
        }
        if (SSMLstricmpElement(a1, a2, "meta"))
        {
          if (SSMLstricmpElement(a1, a2, "metadata"))
          {
            SSMLstricmpElement(a1, a2, "lexicon");
            return 0;
          }
          uint64_t v17 = a1;
        }
        else
        {
          uint64_t v17 = a1;
        }
        return SSMLElement_META_Exit(v17);
      }
      return SSMLElement_STYLE_Exit(a1, v18);
    }
    return SSMLElement_AUDIO_Exit(a1);
  }
  else
  {
    return SSMLElement_SUB_Exit(a1);
  }
}

uint64_t SSMLElement_Block_Exit(uint64_t a1, char *a2, int a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  int v17 = *(_DWORD *)(a1 + 2716);
  int v6 = (char *)(a1 + 13196);
  if (cstdlib_strlen((const char *)(a1 + 13196)))
  {
    strcpy(a2, "\x1B\\domain\\"");
    int32x2_t v7 = *(void (**)(char *, void))(a1 + 2640);
    if (v7) {
      v7(a2, *(void *)(a1 + 2648));
    }
    cstdlib_strcpy(v6, "");
  }
  uint64_t v8 = SSMLViewOnLangFailureFromStack(a1, &v17);
  if (!v8)
  {
    int v9 = v17;
    if (v17 == 4) {
      int v9 = *(_DWORD *)(a1 + 2716);
    }
    if (a3 == 1)
    {
      a2[8] = 0;
      float32x2_t v10 = "\n\x1B\\para\\"";
    }
    else
    {
      if (a3)
      {
LABEL_14:
        if (!v9)
        {
          uint64_t v15 = XMLGetStack(a1, "voice");
          if (v15)
          {
            __src = 0;
            tinystack_Pop(v15, &__src);
            if (__src)
            {
              cstdlib_strcpy((char *)(a1 + 13000), __src);
              __sprintf_chk(v19, 0, 0x50uLL, "\x1B\\voice=%s\\"", __src);
              uint64_t v16 = *(void (**)(char *, void))(a1 + 2640);
              if (v16) {
                v16(v19, *(void *)(a1 + 2648));
              }
            }
          }
        }
        uint64_t v12 = XMLGetStack(a1, "language");
        if (v12)
        {
          __src = 0;
          tinystack_Pop(v12, &__src);
          if (__src)
          {
            cstdlib_strcpy((char *)(a1 + 13128), __src);
            __sprintf_chk(v19, 0, 0x50uLL, "\x1B\\lang=%s\\"", __src);
            uint64_t v13 = *(void (**)(char *, void))(a1 + 2640);
            if (v13) {
              v13(v19, *(void *)(a1 + 2648));
            }
          }
        }
        uint64_t v8 = SSMLRemoveOnLangFailureFromStack(a1);
        ReleaseTagBond(a1);
        return v8;
      }
      a2[8] = 0;
      float32x2_t v10 = "\x1B\\eos=1\\"";
    }
    *(void *)a2 = *(void *)v10;
    uint64_t v11 = *(void (**)(char *, void))(a1 + 2640);
    if (v11) {
      v11(a2, *(void *)(a1 + 2648));
    }
    goto LABEL_14;
  }
  return v8;
}

uint64_t SSMLElement_PHONEME_Exit(uint64_t a1, char *a2)
{
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v4 = XMLGetStack(a1, "auxiliary");
  if (!v4) {
    goto LABEL_31;
  }
  tinystack_Pop(v4, &v32);
  if ((v32 & 8) != 0)
  {
    uint64_t v11 = XMLGetStack(a1, "phon");
    if (v11)
    {
      tinystack_Pop(v11, &v31);
      BOOL v10 = (v31 & 0xE0) == 0;
      int v9 = v31 & 1;
      goto LABEL_6;
    }
LABEL_31:
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v5, v6, v7, v8, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    cstdlib_strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  int v9 = 0;
  BOOL v10 = 1;
LABEL_6:
  uint64_t v12 = *(void *)(a1 + 13272);
  uint64_t v13 = *(char **)(v12 + 8);
  if (!v13) {
    goto LABEL_20;
  }
  int v14 = cstdlib_strncmp(*(const char **)(v12 + 8), ":\"", 2uLL);
  if (!v14)
  {
    uint64_t v15 = *(void *)(a1 + 13272);
    uint64_t v13 = strhelper_StringAppend(**(uint64_t ***)v15, *(char **)(v15 + 8), "\"", 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v15 + 16), 0x80uLL);
    *(void *)(v15 + 8) = v13;
    if (!v13) {
      goto LABEL_20;
    }
  }
  if (v10 && *v13)
  {
    if (v9)
    {
      if (!v14)
      {
        char v16 = v13[1];
        if (v16)
        {
          int v17 = (unsigned __int8 *)(v13 + 2);
          do
          {
            if (cstdlib_strchr(".:,;?!()", v16)) {
              *(v17 - 1) = 32;
            }
            int v18 = *v17++;
            char v16 = v18;
          }
          while (v18);
        }
      }
    }
    (*(void (**)(char *, void))(a1 + 2640))(v13, *(void *)(a1 + 2648));
  }
  if (!v14)
  {
LABEL_20:
    cstdlib_strcpy(a2, "\\"");
    uint64_t v19 = *(const char **)(*(void *)(a1 + 13264) + 8);
    if (v19) {
      cstdlib_strcat(a2, v19);
    }
    uint64_t v20 = *(void (**)(char *, void))(a1 + 2640);
    if (v20) {
      v20(a2, *(void *)(a1 + 2648));
    }
    cstdlib_strcpy(a2, "\x1B\\toi=orth\\"");
    int v21 = *(void (**)(char *, void))(a1 + 2640);
    if (v21) {
      v21(a2, *(void *)(a1 + 2648));
    }
  }
  uint64_t v22 = *(void *)(a1 + 13264);
  uint64_t v25 = *(void *)(v22 + 8);
  double v24 = (void *)(v22 + 8);
  uint64_t v23 = v25;
  if (v25) {
    heap_Free(***(void ****)(a1 + 13264), v23);
  }
  *double v24 = 0;
  v24[1] = 0;
  uint64_t v26 = *(void *)(a1 + 13272);
  uint64_t v29 = *(void *)(v26 + 8);
  uint64_t v28 = (void *)(v26 + 8);
  uint64_t v27 = v29;
  if (v29) {
    heap_Free(***(void ****)(a1 + 13272), v27);
  }
  void *v28 = 0;
  v28[1] = 0;
  ReleaseTagBond(a1);
  return 0;
}

uint64_t SSMLElement_SUB_Exit(uint64_t a1)
{
  uint64_t v8 = 0;
  ReleaseTagBond(a1);
  uint64_t v2 = XMLGetStack(a1, "auxiliary");
  if (v2)
  {
    tinystack_Pop(v2, &v8);
    return 0;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v3, v4, v5, v6, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    cstdlib_strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
}

uint64_t SSMLElement_SAYAS_Exit(uint64_t a1, char *a2)
{
  *(unsigned char *)(a1 + 13280) = 0;
  *(_DWORD *)(a1 + 13312) = 0;
  uint64_t v4 = XMLGetStack(a1, "say-as");
  if (!v4)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v5, v6, v7, v8, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    cstdlib_strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v9 = v4;
  __src = 0;
  BOOL v10 = (char *)(a1 + 13164);
  uint64_t v11 = cstdlib_strstr((char *)(a1 + 13164), "_");
  tinystack_Pop(v9, &__src);
  if (__src)
  {
    cstdlib_strcpy((char *)(a1 + 13164), __src);
    if (cstdlib_strstr((char *)(a1 + 13164), "_") == v10) {
      ++__src;
    }
    if (v11 != v10)
    {
      sprintf(a2, "\x1B\\tn=%s\\"", __src);
      goto LABEL_10;
    }
LABEL_9:
    strcpy(a2, "\x1B\\slotend\\"");
LABEL_10:
    uint64_t v13 = *(void (**)(char *, void))(a1 + 2640);
    if (v13) {
      v13(a2, *(void *)(a1 + 2648));
    }
    goto LABEL_12;
  }
  if (v11 == v10) {
    goto LABEL_9;
  }
LABEL_12:
  ReleaseTagBond(a1);
  return 0;
}

uint64_t SSMLElement_VOICE_Exit(uint64_t a1, char *a2)
{
  uint64_t result = sprintf(a2, "\x1B\\voice=%s\\", "(pop)"");
  uint64_t v5 = *(uint64_t (**)(char *, uint64_t))(a1 + 2640);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 2648);
    return v5(a2, v6);
  }
  return result;
}

uint64_t SSMLElement_SPEAK_Exit(uint64_t a1, char *a2)
{
  uint64_t v8 = SSMLRemoveOnLangFailureFromStack(a1);
  if (v8)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1297, (uint64_t)"%s%s", v4, v5, v6, v7, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = v8;
    cstdlib_strcpy((char *)(a1 + 2104), "Error retrieving OnLangFailure attribute");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
  }
  else
  {
    if (cstdlib_strlen((const char *)(a1 + 13228)))
    {
      strcpy(a2, "\x1B\\domain\\"");
      uint64_t v9 = *(void (**)(char *, void))(a1 + 2640);
      if (v9) {
        v9(a2, *(void *)(a1 + 2648));
      }
      cstdlib_strcpy((char *)(a1 + 13228), "");
    }
    uint64_t v10 = *(void *)(a1 + 13320);
    if (v10)
    {
      heap_Free(*(void **)(*(void *)(a1 + 12992) + 8), v10);
      *(void *)(a1 + 13320) = 0;
    }
  }
  return v8;
}

uint64_t SSMLElement_AUDIO_Exit(uint64_t a1)
{
  uint64_t v15 = 0;
  uint64_t v2 = XMLGetStack(a1, "audio");
  if (v2 && (tinystack_Pop(v2, &v15), (uint64_t v7 = XMLGetStack(a1, "auxiliary")) != 0))
  {
    tinystack_Pop(v7, &v15);
    uint64_t v8 = *(void *)(a1 + 13272);
    uint64_t v9 = *(char **)(v8 + 8);
    if (v9)
    {
      *(void *)(v8 + 8) = strhelper_StringAppend(**(uint64_t ***)v8, v9, "\"", 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v8 + 16), 0x80uLL);
      uint64_t v8 = *(void *)(a1 + 13272);
      uint64_t v9 = *(char **)(v8 + 8);
    }
    *(void *)(v8 + 8) = strhelper_StringAppend(**(uint64_t ***)v8, v9, "\\"", 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v8 + 16), 0x80uLL);
    (*(void (**)(void, void))(a1 + 2640))(*(void *)(*(void *)(a1 + 13272) + 8), *(void *)(a1 + 2648));
    uint64_t v10 = *(void *)(a1 + 13272);
    uint64_t v13 = *(void *)(v10 + 8);
    uint64_t v12 = (void *)(v10 + 8);
    uint64_t v11 = v13;
    if (v13) {
      heap_Free(***(void ****)(a1 + 13272), v11);
    }
    *uint64_t v12 = 0;
    v12[1] = 0;
    ReleaseTagBond(a1);
    return 0;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v3, v4, v5, v6, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    cstdlib_strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
}

uint64_t SSMLElement_STYLE_Exit(uint64_t a1, char *a2)
{
  __src = 0;
  uint64_t v4 = XMLGetStack(a1, "style");
  if (v4)
  {
    if ((tinystack_Pop(v4, &__src) & 0x80000000) == 0)
    {
      cstdlib_strncpy((char *)(a1 + 1572), __src, 0x200uLL);
      *(unsigned char *)(a1 + 2083) = 0;
      return ApplyCurrentStyle(a1, a2);
    }
    *(_DWORD *)(a1 + 2084) = -1919934460;
    uint64_t v10 = (char *)(a1 + 2104);
    uint64_t v11 = "Out of Memory";
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v5, v6, v7, v8, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    uint64_t v10 = (char *)(a1 + 2104);
    uint64_t v11 = "SSML Stack unavailable";
  }
  cstdlib_strcpy(v10, v11);
  ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
  return *(unsigned int *)(a1 + 2084);
}

uint64_t SSMLElement_META_Exit(uint64_t a1)
{
  uint64_t v8 = 0;
  uint64_t v2 = XMLGetStack(a1, "metadata");
  if (v2)
  {
    tinystack_Pop(v2, &v8);
    return 0;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v3, v4, v5, v6, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    cstdlib_strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
}

uint64_t SSMLPopProsodicParameters(_DWORD *a1)
{
  uint64_t v7 = 0;
  uint64_t v2 = XMLGetStack((uint64_t)a1, "volume");
  if (v2)
  {
    tinystack_Pop(v2, &v7);
    if (v7) {
      a1[390] = cstdlib_atoi(v7);
    }
  }
  uint64_t v3 = XMLGetStack((uint64_t)a1, "speed");
  if (v3)
  {
    tinystack_Pop(v3, &v7);
    if (v7) {
      a1[392] = cstdlib_atoi(v7);
    }
  }
  uint64_t v4 = XMLGetStack((uint64_t)a1, "pitch");
  if (v4)
  {
    tinystack_Pop(v4, &v7);
    if (v7) {
      a1[391] = cstdlib_atoi(v7);
    }
  }
  uint64_t v5 = XMLGetStack((uint64_t)a1, "timbre");
  if (v5)
  {
    tinystack_Pop(v5, &v7);
    if (v7) {
      a1[522] = cstdlib_atoi(v7);
    }
  }
  return OutProsodyTags((uint64_t)a1);
}

uint64_t SSMLRemoveOnLangFailureFromStack(uint64_t a1)
{
  uint64_t v8 = 0;
  uint64_t v2 = XMLGetStack(a1, "onLangFailure");
  if (v2)
  {
    tinystack_Pop(v2, &v8);
    return 0;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, (uint64_t)"%s%s", v3, v4, v5, v6, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    cstdlib_strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
}

char *SSMLFallbackStringHandler(char *result, unsigned char *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v5 = result;
  v10[1] = 0;
  uint64_t v6 = *((void *)result + 1659);
  if (*(void *)(v6 + 8))
  {
    if (!a3) {
      return result;
    }
  }
  else
  {
    uint64_t result = strhelper_StringAppend(**(uint64_t ***)v6, 0, ":\"", 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v6 + 16), 0x80uLL);
    *(void *)(v6 + 8) = result;
    if (!v3) {
      return result;
    }
  }
  do
  {
    int v7 = *a2;
    if (v7 == 92 || v7 == 34)
    {
      v10[0] = 92;
      uint64_t v8 = *((void *)v5 + 1659);
      *(void *)(v8 + 8) = strhelper_StringAppend(**(uint64_t ***)v8, *(char **)(v8 + 8), v10, 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v8 + 16), 0x80uLL);
      LOBYTE(v7) = *a2;
    }
    v10[0] = v7;
    uint64_t v9 = *((void *)v5 + 1659);
    uint64_t result = strhelper_StringAppend(**(uint64_t ***)v9, *(char **)(v9 + 8), v10, 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v9 + 16), 0x80uLL);
    *(void *)(v9 + 8) = result;
    ++a2;
    --v3;
  }
  while (v3);
  return result;
}

uint64_t ExtractDate(char *__s1, char *__s, unint64_t *a3, unint64_t *a4, unint64_t *a5, uint64_t a6, unsigned char *a7, unint64_t a8)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v30 = 0;
  if (!a6)
  {
    if (!a3) {
      return 0;
    }
    *a3 = 0;
    if (!a4) {
      return 0;
    }
    *a4 = 0;
    if (!a5) {
      return 0;
    }
    *a5 = 9999;
    if (cstdlib_strlen(__s) > 0xC) {
      return 0;
    }
    cstdlib_strncpy(__dst, __s, 0xBuLL);
    __dst[11] = 0;
    if (!LH_stricmp(__s1, "mdy"))
    {
      int v18 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v30);
      if (v18)
      {
        *a4 = (int)LH_atoi(v18);
        *a7 = __s[v30 - 1];
      }
      uint64_t v19 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v30);
      if (v19 && __s[v30 - 1] == *a7) {
        *a3 = (int)LH_atoi(v19);
      }
      goto LABEL_43;
    }
    if (LH_stricmp(__s1, "dmy"))
    {
      if (!LH_stricmp(__s1, "ymd"))
      {
        double v24 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v30);
        if (v24)
        {
          *a5 = (int)LH_atoi(v24);
          *a7 = __s[v30 - 1];
        }
        uint64_t v25 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v30);
        if (!v25 || __s[v30 - 1] != *a7) {
          goto LABEL_67;
        }
        goto LABEL_55;
      }
      if (!LH_stricmp(__s1, "ydm"))
      {
        uint64_t v26 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v30);
        if (v26)
        {
          *a5 = (int)LH_atoi(v26);
          *a7 = __s[v30 - 1];
        }
        uint64_t v27 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v30);
        if (!v27 || __s[v30 - 1] != *a7) {
          goto LABEL_63;
        }
        goto LABEL_60;
      }
      if (!LH_stricmp(__s1, "ym"))
      {
        uint64_t v28 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v30);
        if (v28) {
          *a5 = (int)LH_atoi(v28);
        }
        goto LABEL_63;
      }
      if (!LH_stricmp(__s1, "yd"))
      {
        uint64_t v29 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v30);
        if (v29) {
          *a5 = (int)LH_atoi(v29);
        }
        goto LABEL_67;
      }
      if (LH_stricmp(__s1, "my"))
      {
        if (LH_stricmp(__s1, "md"))
        {
          if (LH_stricmp(__s1, "dm"))
          {
            if (LH_stricmp(__s1, "y"))
            {
              if (LH_stricmp(__s1, "m"))
              {
                if (LH_stricmp(__s1, "d")) {
                  return 0;
                }
                *a5 = 0;
LABEL_67:
                uint64_t v22 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v30);
                uint64_t v23 = a3;
                if (!v22) {
                  goto LABEL_45;
                }
                goto LABEL_44;
              }
              *a5 = 0;
LABEL_63:
              uint64_t v22 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v30);
              uint64_t v23 = a4;
              if (!v22) {
                goto LABEL_45;
              }
              goto LABEL_44;
            }
LABEL_43:
            uint64_t v22 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v30);
            uint64_t v23 = a5;
            if (!v22)
            {
LABEL_45:
              if (*a4 - 13 <= 0xFFFFFFFFFFFFFFF3 && cstdlib_strstr(__s1, "m")
                || *a3 - 32 <= 0xFFFFFFFFFFFFFFE0 && cstdlib_strstr(__s1, "d")
                || *a5 > 0x834)
              {
                return 0;
              }
              return __s[v30] == 0;
            }
LABEL_44:
            *uint64_t v23 = (int)LH_atoi(v22);
            goto LABEL_45;
          }
          *a5 = 0;
          uint64_t v27 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v30);
          if (!v27) {
            goto LABEL_63;
          }
LABEL_60:
          *a3 = (int)LH_atoi(v27);
          goto LABEL_63;
        }
        *a5 = 0;
        uint64_t v25 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v30);
        if (!v25) {
          goto LABEL_67;
        }
LABEL_55:
        *a4 = (int)LH_atoi(v25);
        goto LABEL_67;
      }
      int v21 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v30);
      if (!v21) {
        goto LABEL_43;
      }
    }
    else
    {
      uint64_t v20 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v30);
      if (v20)
      {
        *a3 = (int)LH_atoi(v20);
        *a7 = __s[v30 - 1];
      }
      int v21 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v30);
      if (!v21 || __s[v30 - 1] != *a7) {
        goto LABEL_43;
      }
    }
    *a4 = (int)LH_atoi(v21);
    goto LABEL_43;
  }
  unint64_t v12 = *a5;
  if (*a5 < a8 || v12 > 0x63)
  {
    if (v12 <= 0x63F && cstdlib_strstr(__s1, "y")) {
      return 0;
    }
  }
  else
  {
    uint64_t v13 = 1900;
    if (v12 < 0x14) {
      uint64_t v13 = 2000;
    }
    *a5 = v13 + v12;
  }
  if (*a3 < 0x1E) {
    return 1;
  }
  unint64_t v16 = *a4;
  if (*a4 == 2) {
    return 0;
  }
  if (*a3 == 31 && v16 - 4 <= 7) {
    return dword_2207888E4[v16 - 4];
  }
  else {
    return 1;
  }
}

uint64_t lightssml_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2375032833;
  }
  uint64_t result = 0;
  *a2 = &IlightssmlCtrl;
  return result;
}

uint64_t lightssml_ClassOpen(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v23 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v23);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t v5 = 2375032840;
  uint64_t v6 = (void *)heap_Calloc(*(void **)(v23 + 8), 1, 40);
  if (!v6) {
    return 2375032842;
  }
  uint64_t v7 = (uint64_t)v6;
  uint64_t v8 = *(void *)(v23 + 8);
  v6[4] = 0;
  v6[1] = 0;
  uint64_t v9 = v6 + 1;
  *uint64_t v6 = 0;
  uint64_t v10 = v23;
  v6[2] = v8;
  v6[3] = v10;
  int v11 = critsec_ObjOpen(*(void *)(v10 + 16), *(void **)(v10 + 8), v6 + 4);
  uint64_t v16 = v23;
  if (v11 < 0
    || (v17 = ELQXMLIniController(v23, "LTTS7XML", "./", *(void *)(v7 + 32)), *(void *)uint64_t v7 = v17, v16 = v23, !v17))
  {
    uint64_t v19 = 1664;
  }
  else
  {
    uint64_t v18 = VoiceInfoIni(v9, v23);
    if ((v18 & 0x80000000) == 0)
    {
      uint64_t v5 = v18;
      *(void *)a3 = v7;
      *(_DWORD *)(a3 + 8) = 47834;
      return v5;
    }
    uint64_t v5 = 2375040626;
    uint64_t v19 = 1455;
    uint64_t v16 = v23;
  }
  log_OutPublic(*(void *)(v16 + 32), (uint64_t)"LIGHTSSML", v19, 0, v12, v13, v14, v15, v22);
  VoiceInfoDelete(*(uint64_t (***)())(v7 + 8));
  ELQXMLDeleteController(*(uint64_t (***)(uint64_t, const char *, const char *, uint64_t))v7);
  uint64_t v20 = *(void *)(v7 + 32);
  if (v20) {
    critsec_ObjClose(v20);
  }
  heap_Free(*(void **)(v23 + 8), v7);
  return v5;
}

uint64_t lightssml_ClassClose(uint64_t a1, int a2)
{
  uint64_t v3 = safeh_HandleCheck(a1, a2, 47834, 40);
  if ((v3 & 0x80000000) == 0)
  {
    if (a1)
    {
      VoiceInfoDelete(*(uint64_t (***)())(a1 + 8));
      ELQXMLDeleteController(*(uint64_t (***)(uint64_t, const char *, const char *, uint64_t))a1);
      uint64_t v4 = *(void *)(a1 + 32);
      if (v4) {
        critsec_ObjClose(v4);
      }
      heap_Free(*(void **)(a1 + 16), a1);
    }
    else
    {
      return 2375032840;
    }
  }
  return v3;
}

uint64_t lightssml_ObjOpen(void *a1, int a2, _WORD *a3, int a4, uint64_t a5)
{
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v5 = 2375032840;
  if (!a5) {
    return 2375032839;
  }
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  uint64_t inited = InitRsrcFunction(a3, a4, &v39);
  if ((inited & 0x80000000) == 0)
  {
    log_OutText(*(void *)(v39 + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Entering lightssml_ObjOpen", v10, v11, v12, v38);
    uint64_t v13 = safeh_HandleCheck((uint64_t)a1, a2, 47834, 40);
    if ((v13 & 0x80000000) != 0)
    {
      uint64_t v35 = v13;
      log_OutPublic(*(void *)(v39 + 32), (uint64_t)"LIGHTSSML", 1152, 0, v14, v15, v16, v17, v38);
      uint64_t v5 = v35;
    }
    else if (a1)
    {
      uint64_t v18 = heap_Calloc(*(void **)(v39 + 8), 1, 128);
      if (v18)
      {
        uint64_t v22 = v18;
        *(void *)a5 = v18;
        *(_DWORD *)(a5 + 8) = 435;
        if ((objc_GetObject(*(void *)(v39 + 48), (uint64_t)"LANGCODECONVERTER", &v38) & 0x80000000) == 0)
        {
          uint64_t v23 = v38;
          if (*(unsigned char *)v38 != 1 || (uint64_t v24 = *(void *)(v38 + 8)) == 0)
          {
            objc_ReleaseObject(*(void *)(v39 + 48), (uint64_t)"LANGCODECONVERTER");
            uint64_t v31 = v39;
            uint64_t v5 = 2375032845;
            uint64_t v34 = 2574;
LABEL_24:
            log_OutPublic(*(void *)(v31 + 32), (uint64_t)"LIGHTSSML", v34, 0, v26, v27, v28, v29, v38);
            lightssml_ObjClose(*(void *)a5, *(void *)(a5 + 8));
            *(void *)a5 = 0;
            *(_DWORD *)(a5 + 8) = 0;
            goto LABEL_25;
          }
          *(void *)(v22 + 32) = v24;
          *(_OWORD *)(v22 + 40) = *(_OWORD *)(v23 + 16);
        }
        uint64_t Object = objc_GetObject(*(void *)(v39 + 48), (uint64_t)"SYNTHSTREAM", &v38);
        if ((Object & 0x80000000) != 0)
        {
          uint64_t v36 = Object;
          uint64_t v34 = 1154;
          uint64_t v31 = v39;
          uint64_t v5 = v36;
        }
        else
        {
          *(void *)(v22 + 56) = 0;
          *(void *)(v22 + 64) = 0;
          *(void *)(v22 + 72) = 0;
          *(void *)(v22 + 16) = v39;
          *(_DWORD *)(v22 + 80) = 65001;
          *(void *)(v22 + 24) = *(void *)(v38 + 8);
          *(_DWORD *)uint64_t v22 = 0;
          *(void *)(v22 + 8) = a1;
          uint64_t v30 = ELQXMLIniParser(*a1, 0);
          *(void *)(v22 + 64) = v30;
          uint64_t v31 = v39;
          if (v30)
          {
            uint64_t v32 = ELQMemorySlotInit(v39, 1024, 0);
            *(void *)(v22 + 72) = v32;
            uint64_t v31 = v39;
            if (v32)
            {
              int v33 = ELQSSMLIni(v39, (uint64_t *)(v22 + 56), *(void *)(v22 + 64), 0);
              if (!v33)
              {
                ELQSSMLSetMemorySlot(*(void *)(v22 + 56), *(void *)(v22 + 72));
                ELQSSMLSetVoiceInfo(*(void *)(v22 + 56), *(void *)(*(void *)(v22 + 8) + 8));
                ELQSSMLSetLangCodeConverter(*(void *)(v22 + 56), *(void *)(v22 + 32), *(void *)(v22 + 40), *(void *)(v22 + 48));
                uint64_t v5 = 0;
                *(_DWORD *)uint64_t v22 = 1;
                goto LABEL_25;
              }
              uint64_t v5 = v33 | 0x8D902000;
              uint64_t v34 = 1664;
              uint64_t v31 = v39;
            }
            else
            {
              uint64_t v5 = 2375033096;
              uint64_t v34 = 1923;
            }
          }
          else
          {
            uint64_t v34 = 1459;
          }
        }
        goto LABEL_24;
      }
      uint64_t v5 = 2375032842;
    }
    else
    {
      log_OutPublic(*(void *)(v39 + 32), (uint64_t)"LIGHTSSML", 1153, 0, v14, v15, v16, v17, v38);
    }
LABEL_25:
    log_OutText(*(void *)(v39 + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_ObjOpen", v19, v20, v21, v38);
    return v5;
  }
  return inited;
}

uint64_t lightssml_ObjClose(uint64_t a1, int a2)
{
  uint64_t v3 = safeh_HandleCheck(a1, a2, 435, 128);
  uint64_t v7 = 2375032840;
  if ((v3 & 0x80000000) == 0 && a1)
  {
    uint64_t v8 = v3;
    log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Entering lightssml_ObjClose", v4, v5, v6, v15);
    ELQSSMLDelete(*(void **)(a1 + 56));
    ELQXMLDeleteParser(*(void **)(a1 + 64));
    ELQMemorySlotDelete(*(void **)(a1 + 72));
    if (*(void *)(a1 + 24)) {
      objc_ReleaseObject(*(void *)(*(void *)(a1 + 16) + 48), (uint64_t)"SYNTHSTREAM");
    }
    if (*(void *)(a1 + 32)) {
      uint64_t v7 = objc_ReleaseObject(*(void *)(*(void *)(a1 + 16) + 48), (uint64_t)"LANGCODECONVERTER");
    }
    else {
      uint64_t v7 = v8;
    }
    *(_DWORD *)a1 = 0;
    uint64_t v9 = *(void *)(a1 + 16);
    uint64_t v10 = *(void *)(v9 + 32);
    heap_Free(*(void **)(v9 + 8), a1);
    log_OutText(v10, (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_ObjClose", v11, v12, v13, v16);
  }
  return v7;
}

uint64_t lightssml_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 2375032840;
  if ((safeh_HandleCheck(a1, a2, 435, 128) & 0x80000000) == 0)
  {
    log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Entering lightssml_ProcessStart", v8, v9, v10, v27);
    if (*(_DWORD *)a1 == 1)
    {
      *(_DWORD *)a1 = 3;
      cstdlib_memset((void *)(a1 + 88), 0, 0x28uLL);
      uint64_t v15 = 0;
      *(void *)(a1 + 88) = *(void *)(a1 + 24);
      do
      {
        int v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, char *, void, void, uint64_t))(*(void *)(a1 + 24) + 64))(a3, a4, 217, lightssml_ProcessStart_szSSML_INPUT_NAMES[v15], 0, 0, a1 + 96);
        if ((v16 & 0x80000000) == 0) {
          break;
        }
      }
      while (v15++ != 3);
      uint64_t v21 = *(void *)(a1 + 16);
      if (v16 < 0)
      {
        log_OutText(*(void *)(v21 + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_ProcessStart: no SSML to process", v17, v18, v19, v28);
        paramc_ParamSetStr(*(void *)(*(void *)(a1 + 16) + 40), (uint64_t)"rulesetsfrommarkup", "0");
        return 0;
      }
      else
      {
        paramc_ParamSetStr(*(void *)(v21 + 40), (uint64_t)"rulesetsfrommarkup", "1");
        uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, void, uint64_t, uint64_t))(*(void *)(a1 + 24) + 64))(a3, a4, 217, "text/plain;charset=utf-8",
                0,
                1,
                a1 + 112);
        if ((v22 & 0x80000000) != 0)
        {
          return v22;
        }
        else
        {
          uint64_t v7 = ELQSSMLSetOutputFunction(*(void *)(a1 + 56), (uint64_t)StringBuffer_Output, a1);
          if ((v7 & 0x80000000) == 0) {
            log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_ProcessStart", v23, v24, v25, v28);
          }
        }
      }
    }
    else
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 1156, 0, v11, v12, v13, v14, v28);
      return 2375032849;
    }
  }
  return v7;
}

uint64_t lightssml_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  unsigned int v44 = 0;
  strcpy(__s, "<speak>");
  strcpy(v46, "</speak>");
  unsigned int v42 = 0;
  uint64_t v7 = safeh_HandleCheck(a1, a2, 435, 128);
  if ((v7 & 0x80000000) != 0) {
    return 2375032840;
  }
  uint64_t v11 = v7;
  uint64_t v45 = 0;
  long long v43 = 0;
  log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Entering lightssml_Process", v8, v9, v10, v39);
  if ((*(_DWORD *)a1 & 0xFFFFFFFE) != 2)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 1156, 0, v12, v13, v14, v15, v40);
    uint64_t v11 = 2375032849;
    goto LABEL_14;
  }
  *a5 = 2;
  if (!*(void *)(a1 + 96) || !*(void *)(a1 + 112))
  {
    *a5 = 1;
    goto LABEL_16;
  }
  uint64_t v16 = (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 144))();
  if ((v16 & 0x80000000) != 0)
  {
    uint64_t v11 = v16;
    log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 1158, (uint64_t)"%s%x", v17, v18, v19, v20, "lhError");
    return v11;
  }
  uint64_t v11 = (*(uint64_t (**)(void, void, unsigned __int8 **, unsigned int *))(*(void *)(a1 + 24) + 88))(*(void *)(a1 + 96), *(void *)(a1 + 104), &v43, &v44);
  if ((v11 & 0x80000000) == 0)
  {
    unint64_t v21 = v44;
    if (v44)
    {
      uint64_t v45 = 0;
      if (*(_DWORD *)a1 == 3
        && (*(_DWORD *)a1 = 2,
            *(_DWORD *)(a1 + 80) = TxtEncodingDetect(v43, v21, &v45),
            uint64_t v22 = ELQSSMLStartParsing(*(void *)(a1 + 56), 0, 0, 65001, 1),
            (v22 & 0x80000000) != 0))
      {
        uint64_t v11 = v22;
      }
      else
      {
        int v23 = *(_DWORD *)(a1 + 80);
        if (v23 == 65001)
        {
          uint64_t v24 = (char *)&v43[v45];
          size_t v25 = v44 - v45;
        }
        else
        {
          unint64_t v41 = 0;
          TxtEncodingGetOutputBytesRequired((char *)&v43[v45], v44 - v45, v23, v23, &v41);
          uint64_t v29 = TxtEncodingConvert(*(void *)(*(void *)(a1 + 8) + 16), *(_DWORD *)(a1 + 80), 65001, (char *)&v43[v45], v41, 0, 0, 0);
          uint64_t v24 = v29;
          if (v29) {
            size_t v25 = cstdlib_strlen(v29);
          }
          else {
            size_t v25 = 0;
          }
        }
        uint64_t v11 = 2375040625;
        if (v24 && v25)
        {
          if (cstdlib_strstr(v24, "<speak") || cstdlib_strstr(v24, "speak>") || cstdlib_strstr(v24, "<?xml") || !v42)
          {
            uint64_t v30 = *(void *)(a1 + 56);
            uint64_t v31 = v42;
            uint64_t v32 = v24;
            size_t v33 = v25;
            goto LABEL_32;
          }
          uint64_t v36 = *(void *)(a1 + 56);
          size_t v37 = cstdlib_strlen(__s);
          if ((ELQSSMLParse(v36, (uint64_t)__s, v37, 0, 0) & 0x80000000) == 0
            && (ELQSSMLParse(*(void *)(a1 + 56), (uint64_t)v24, v25, 0, 0) & 0x80000000) == 0)
          {
            uint64_t v38 = *(void *)(a1 + 56);
            size_t v33 = cstdlib_strlen(v46);
            uint64_t v31 = v42;
            uint64_t v32 = v46;
            uint64_t v30 = v38;
LABEL_32:
            if ((ELQSSMLParse(v30, (uint64_t)v32, v33, v31, 0) & 0x80000000) == 0)
            {
              if (*(_DWORD *)(a1 + 80) != 65001) {
                heap_Free(*(void **)(*(void *)(a1 + 16) + 8), (uint64_t)v24);
              }
              uint64_t v11 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 24) + 96))(*(void *)(a1 + 96), *(void *)(a1 + 104), v44);
              if ((v11 & 0x80000000) == 0 && v42)
              {
                *a5 = 1;
                uint64_t v34 = *(void *)(a1 + 112);
                if (!v34) {
                  goto LABEL_16;
                }
                uint64_t v11 = (*(uint64_t (**)(uint64_t, void))(*(void *)(a1 + 24) + 72))(v34, *(void *)(a1 + 120));
                *(void *)(a1 + 112) = safeh_GetNullHandle();
                *(void *)(a1 + 120) = v35;
              }
              if ((v11 & 0x80000000) == 0) {
                goto LABEL_16;
              }
            }
          }
        }
      }
LABEL_14:
      *(_DWORD *)a1 = 1;
LABEL_16:
      log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_Process", v13, v14, v15, v40);
      return v11;
    }
    if (v42)
    {
      *a5 = 1;
      uint64_t v27 = *(void *)(a1 + 112);
      if (v27)
      {
        uint64_t v11 = (*(uint64_t (**)(uint64_t, void))(*(void *)(a1 + 24) + 72))(v27, *(void *)(a1 + 120));
        *(void *)(a1 + 112) = safeh_GetNullHandle();
        *(void *)(a1 + 120) = v28;
      }
    }
    else
    {
      *a5 = 0;
    }
  }
  return v11;
}

uint64_t lightssml_ProcessEnd(uint64_t a1, int a2)
{
  uint64_t v3 = 2375032840;
  if ((safeh_HandleCheck(a1, a2, 435, 128) & 0x80000000) == 0)
  {
    log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Entering lightssml_ProcessEnd", v4, v5, v6, v19);
    if ((*(_DWORD *)a1 & 0xFFFFFFFE) == 2)
    {
      *(_DWORD *)a1 = 1;
      uint64_t v3 = UnloadTuningResources(*(void **)(a1 + 56));
      if ((v3 & 0x80000000) == 0)
      {
        uint64_t v14 = *(void *)(a1 + 96);
        if (!v14
          || (uint64_t v3 = (*(uint64_t (**)(uint64_t, void))(*(void *)(a1 + 24) + 72))(v14, *(void *)(a1 + 104)), *(void *)(a1 + 96) = safeh_GetNullHandle(), *(void *)(a1 + 104) = v15, (v3 & 0x80000000) == 0))
        {
          uint64_t v16 = *(void *)(a1 + 112);
          if (v16)
          {
            uint64_t v3 = (*(uint64_t (**)(uint64_t, void))(*(void *)(a1 + 24) + 72))(v16, *(void *)(a1 + 120));
            *(void *)(a1 + 112) = safeh_GetNullHandle();
            *(void *)(a1 + 120) = v17;
          }
        }
      }
    }
    else
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 1156, 0, v7, v8, v9, v10, v20);
      uint64_t v3 = 2375032849;
    }
    log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_ProcessEnd", v11, v12, v13, v20);
  }
  return v3;
}

uint64_t StringBuffer_Output(const char *a1, void *a2)
{
  if (!a1) {
    return 0;
  }
  size_t v4 = cstdlib_strlen(a1);
  if (!v4) {
    return 0;
  }
  char __dst = 0;
  uint64_t v5 = (*(uint64_t (**)(void, void, void **, size_t))(a2[3] + 112))(a2[14], a2[15], &__dst, v4);
  if ((v5 & 0x80000000) != 0) {
    return v5;
  }
  cstdlib_memcpy(__dst, a1, v4);
  uint64_t v6 = (*(uint64_t (**)(void, void, size_t))(a2[3] + 120))(a2[14], a2[15], v4);
  if ((v6 & 0x80000000) == 0 && log_HasTraceTuningDataSubscriber(*(void *)(a2[2] + 32))) {
    log_OutTraceTuningDataBinary(*(void *)(a2[2] + 32), 500, (uint64_t)"", (uint64_t)"text/plain;charset=utf-8",
  }
      (uint64_t)__dst,
      v4);
  return v6;
}

uint64_t ELQEntityGetCode(uint64_t result, int a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  __int16 v6 = 0;
  size_t v5 = 15;
  if (result)
  {
    uint64_t v4 = 0;
    if ((a2 & 0xFFFFFFFE) == 0x4B0)
    {
      TxtEncodingConvert(0, a2, 65001, (char *)result, 0xFuLL, (uint64_t)&__dst, 0x50uLL, &v5);
    }
    else
    {
      cstdlib_strncpy(&__dst, (const char *)result, 0xEuLL);
      v10[12] = 0;
      size_t v5 = cstdlib_strlen(&__dst);
    }
    if (__dst != 38) {
      goto LABEL_15;
    }
    size_t v2 = v5 - 1;
    if (v5 == 1)
    {
      LOWORD(result) = 38;
      return (unsigned __int16)result;
    }
    if (*(&__dst + v2) != 59 || (*(&__dst + v2) = 0, !v8))
    {
LABEL_15:
      LOWORD(result) = 0;
      return (unsigned __int16)result;
    }
    if (v8 == 35)
    {
      if ((v9 & 0xDF) == 0x58)
      {
        if (ELQAsciiHex2num(v10, &v6)) {
          LOWORD(result) = v6;
        }
        else {
          LOWORD(result) = 0;
        }
      }
      else
      {
        LODWORD(result) = UTF8ContainsCharacterFamily((uint64_t)&v9);
        if (result) {
          LOWORD(result) = (unsigned __int16)LH_atoi(&v9);
        }
      }
    }
    else
    {
      uint64_t v3 = &v8;
      LOWORD(v4) = 0;
      uint64_t result = ELQbsearch((uint64_t)&v3, (uint64_t)&EntityList, 0xFDuLL, 16, (uint64_t (*)(uint64_t, uint64_t))EntityCompare);
      if (result) {
        LOWORD(result) = *(_WORD *)(result + 8);
      }
    }
  }
  return (unsigned __int16)result;
}

uint64_t UTF8ContainsCharacterFamily(uint64_t __s)
{
  if (__s)
  {
    uint64_t v1 = __s;
    if (!*(unsigned char *)__s) {
      return 1;
    }
    uint64_t v2 = 0;
    while (1)
    {
      size_t v4 = 0;
      unsigned int v3 = ELQGetWCharFromString((char *)__s, 65001, 0, &v4);
      if (v3)
      {
        if (ELQwisdigit(v3) != 1) {
          return 0;
        }
        v2 += v4;
      }
      else
      {
        ++v2;
      }
      __s = v1 + v2;
      if (!*(unsigned char *)(v1 + v2)) {
        return 1;
      }
    }
  }
  return __s;
}

uint64_t EntityCompare(const char **a1, const char **a2)
{
  return cstdlib_strcmp(*a1, *a2);
}

unsigned __int16 *ELQSubstituteEntitiesUTF16(unsigned __int16 *result, char a2)
{
  if (result)
  {
    unsigned int v3 = result;
    size_t v4 = result;
    while (1)
    {
LABEL_3:
      int v5 = *v3;
      if (v5 == 37)
      {
        if ((a2 & 2) == 0) {
          goto LABEL_12;
        }
        int v8 = v3[1];
        if (!v3[1]) {
          goto LABEL_35;
        }
        int v9 = v3[2];
        if (!v3[2]) {
          goto LABEL_35;
        }
        unsigned int v10 = v8 - 48;
        if ((v8 - 97) >= 6) {
          int v11 = -1;
        }
        else {
          int v11 = v8 - 87;
        }
        if ((v8 - 65) <= 5) {
          int v12 = v8 - 55;
        }
        else {
          int v12 = v11;
        }
        int v13 = v8 - 48;
        if (v10 > 9) {
          int v13 = v12;
        }
        unsigned int v14 = v9 - 48;
        if ((v9 - 97) >= 6) {
          int v15 = -1;
        }
        else {
          int v15 = v9 - 87;
        }
        if ((v9 - 65) <= 5) {
          int v16 = v9 - 55;
        }
        else {
          int v16 = v15;
        }
        int v17 = v9 - 48;
        if (v14 > 9) {
          int v17 = v16;
        }
        if ((v13 & 0x80000000) == 0 && (v17 & 0x80000000) == 0 && (unsigned __int16 v18 = v17 + 16 * v13) != 0)
        {
          *v4++ = v18;
          v3 += 3;
        }
        else
        {
LABEL_35:
          *v4++ = 37;
          ++v3;
        }
      }
      else
      {
        if (!*v3)
        {
          *size_t v4 = 0;
          return result;
        }
        if ((a2 & 1) != 0 && v5 == 38)
        {
          int v6 = 0;
          unsigned int v7 = 0;
          while (1)
          {
            if (!(_WORD)v5)
            {
              ++v3;
              *v4++ = 38;
              goto LABEL_3;
            }
            if ((unsigned __int16)v5 == 59) {
              break;
            }
            LOWORD(v5) = v3[++v7];
            --v6;
          }
          unsigned __int16 v19 = v3[v7 + 1];
          v3[v7 + 1] = 0;
          uint64_t result = (unsigned __int16 *)ELQEntityGetCode((uint64_t)v3, 1200);
          v3[v7 + 1] = v19;
          if (result)
          {
            *v4++ = (unsigned __int16)result;
            v3 += v7 + 1;
          }
          else if (v7)
          {
            do
            {
              unsigned __int16 v20 = *v3++;
              *v4++ = v20;
            }
            while (!__CFADD__(v6++, 1));
          }
        }
        else
        {
LABEL_12:
          ++v3;
          *v4++ = v5;
        }
      }
    }
  }
  return result;
}

unsigned char *ELQSubstituteEntitiesUTF8(unsigned char *result, char a2)
{
  if (result)
  {
    uint64_t v2 = result;
    if (*result)
    {
      size_t v4 = result;
      do
      {
        uint64_t result = (unsigned char *)ELQUtf8GetByteNo(v4);
        if (result <= 1) {
          int v5 = 1;
        }
        else {
          int v5 = (int)result;
        }
        if (result <= 1)
        {
          int v6 = *v4;
          if ((a2 & 2) != 0 && v6 == 37)
          {
            int v7 = v4[1];
            if (!v4[1]) {
              goto LABEL_43;
            }
            int v8 = v4[2];
            if (!v4[2]) {
              goto LABEL_43;
            }
            unsigned int v9 = v7 - 48;
            if ((v7 - 97) >= 6) {
              int v10 = -1;
            }
            else {
              int v10 = v7 - 87;
            }
            if ((v7 - 65) <= 5) {
              int v11 = v7 - 55;
            }
            else {
              int v11 = v10;
            }
            int v12 = v7 - 48;
            if (v9 > 9) {
              int v12 = v11;
            }
            unsigned int v13 = v8 - 48;
            if ((v8 - 97) >= 6) {
              int v14 = -1;
            }
            else {
              int v14 = v8 - 87;
            }
            if ((v8 - 65) <= 5) {
              int v15 = v8 - 55;
            }
            else {
              int v15 = v14;
            }
            int v16 = v8 - 48;
            if (v13 > 9) {
              int v16 = v15;
            }
            if ((v12 & 0x80000000) == 0 && (v16 & 0x80000000) == 0 && (unsigned __int16 v17 = v16 + 16 * v12) != 0)
            {
              uint64_t result = (unsigned char *)TxtEncodingCharUTF16ToUTF8(v17, (uint64_t)&v31);
              char v18 = v31;
              if (v31)
              {
                unsigned __int16 v19 = v32;
                do
                {
                  *v2++ = v18;
                  int v20 = *v19++;
                  char v18 = v20;
                }
                while (v20);
              }
              v4 += 3;
            }
            else
            {
LABEL_43:
              *v2++ = 37;
              ++v4;
            }
            continue;
          }
          if ((a2 & 1) != 0 && v6 == 38)
          {
            int v21 = 0;
            unsigned int v22 = 0;
            char v23 = 38;
            while (1)
            {
              if (!v23)
              {
                ++v4;
                *v2++ = 38;
                goto LABEL_53;
              }
              if (v23 == 59) {
                break;
              }
              char v23 = v4[++v22];
              --v21;
            }
            unsigned __int8 v25 = v4[v22 + 1];
            v4[v22 + 1] = 0;
            uint64_t result = (unsigned char *)ELQEntityGetCode((uint64_t)v4, 65001);
            v4[v22 + 1] = v25;
            if (result)
            {
              uint64_t result = (unsigned char *)TxtEncodingCharUTF16ToUTF8(result, (uint64_t)&v31);
              char v26 = v31;
              if (v31)
              {
                uint64_t v27 = v32;
                do
                {
                  *v2++ = v26;
                  int v28 = *v27++;
                  char v26 = v28;
                }
                while (v28);
              }
              v4 += v22 + 1;
            }
            else if (v22)
            {
              do
              {
                char v29 = *v4++;
                *v2++ = v29;
              }
              while (!__CFADD__(v21++, 1));
            }
            continue;
          }
        }
        do
        {
          char v24 = *v4++;
          *v2++ = v24;
          --v5;
        }
        while (v5);
LABEL_53:
        ;
      }
      while (*v4);
    }
    *uint64_t v2 = 0;
  }
  return result;
}

uint64_t ELQStringCode2Entity(char *a1, unsigned char *a2)
{
  size_t v11 = 0;
  *a2 = 0;
  unsigned int v4 = ELQGetWCharFromString(a1, 65001, 0, &v11);
  uint64_t v5 = 0;
  if (v4)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    do
    {
      int v8 = &a2[v6];
      if (v4 < 0x80)
      {
        *int v8 = v4;
        v8[1] = 0;
        int v9 = 1;
      }
      else
      {
        int v9 = sprintf(&a2[v6], "&#%d;", v4);
        uint64_t v5 = 1;
      }
      v6 += v9;
      v7 += v11;
      unsigned int v4 = ELQGetWCharFromString(&a1[v7], 65001, 0, &v11);
    }
    while (v4);
  }
  return v5;
}

uint64_t ELQEntityParse(int a1, unsigned __int8 *a2, unint64_t a3, char a4, uint64_t *a5, __int16 *a6)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  unsigned int v6 = a1 & 0xFFFFFFFE;
  unint64_t v7 = a3 >> ((a1 & 0xFFFFFFFE) == 1200);
  if (!v7) {
    return 2;
  }
  strcpy(v26, "&");
  if (v6 != 1200)
  {
    int v10 = *a2;
    if ((a4 & 1) == 0 || v10 != 38)
    {
      int v10 = (char)v10;
      goto LABEL_35;
    }
LABEL_8:
    if (v7 != 1)
    {
      unint64_t v11 = 15;
      if (v7 < 0xF) {
        unint64_t v11 = a3 >> ((a1 & 0xFFFFFFFE) == 1200);
      }
      int v12 = &v26[4];
      unint64_t v13 = 1;
      while (1)
      {
        if (v6 == 1200) {
          __int16 v14 = *(_WORD *)&a2[2 * v13];
        }
        else {
          __int16 v14 = (char)a2[v13];
        }
        if (!v14) {
          return 1;
        }
        if ((unsigned __int16)(v14 - 48) >= 0xAu && (unsigned __int16)((v14 & 0xFFDF) - 65) >= 0x1Au)
        {
          BOOL v16 = v13 == 1 && v14 == 35;
          BOOL v17 = !v16;
          if (v14 != 59 && v17) {
            return 1;
          }
        }
        *((_WORD *)v12 - 1) = v14;
        if (v14 == 59) {
          break;
        }
        ++v13;
        v12 += 2;
        if (v13 >= v11)
        {
          if (v13 > 0xE) {
            return 1;
          }
          else {
            return 2;
          }
        }
      }
      *(_WORD *)int v12 = 0;
      int Code = ELQEntityGetCode((uint64_t)v26, 1200);
      if (!Code) {
        return 1;
      }
      if (a6)
      {
        if (Code == 60) {
          __int16 v21 = 8808;
        }
        else {
          __int16 v21 = Code;
        }
        *a6 = v21;
      }
      if (a5)
      {
        uint64_t result = 0;
        uint64_t v22 = v13 + 1;
        goto LABEL_74;
      }
      return 0;
    }
    return 2;
  }
  int v10 = *(unsigned __int16 *)a2;
  if ((a4 & 1) != 0 && v10 == 38) {
    goto LABEL_8;
  }
LABEL_35:
  uint64_t result = 1;
  if ((a4 & 2) == 0 || v10 != 37) {
    return result;
  }
  if (v7 < 2) {
    return 2;
  }
  if (v6 == 1200) {
    unsigned __int16 v19 = *((_WORD *)a2 + 1);
  }
  else {
    unsigned __int16 v19 = (char)a2[1];
  }
  if ((unsigned __int16)(v19 - 48) > 9u)
  {
    if (v19 - 65 > 5)
    {
      if (v19 - 97 > 5) {
        return result;
      }
      int v23 = v19 - 87;
    }
    else
    {
      int v23 = v19 - 55;
    }
  }
  else
  {
    int v23 = v19 - 48;
  }
  if ((v23 & 0x80000000) == 0)
  {
    if (v7 < 3) {
      return 2;
    }
    unsigned __int16 v24 = v6 == 1200 ? *((_WORD *)a2 + 2) : (char)a2[2];
    if ((unsigned __int16)(v24 - 48) > 9u)
    {
      if (v24 - 65 > 5)
      {
        if (v24 - 97 > 5) {
          return result;
        }
        int v25 = v24 - 87;
      }
      else
      {
        int v25 = v24 - 55;
      }
    }
    else
    {
      int v25 = v24 - 48;
    }
    if ((v25 & 0x80000000) == 0)
    {
      if (a6) {
        *a6 = v25 + 16 * v23;
      }
      if (a5)
      {
        uint64_t result = 0;
        uint64_t v22 = 3;
LABEL_74:
        *a5 = v22;
        return result;
      }
      return 0;
    }
  }
  return result;
}

size_t ELQUtf8StrCaseChange(const char *a1, char *a2, uint64_t a3, int a4)
{
  size_t v8 = cstdlib_strlen(a1);
  *a2 = 0;
  if (!v8) {
    return 0;
  }
  size_t v9 = v8;
  size_t v10 = 0;
  size_t v11 = 0;
  size_t v12 = a3 - 1;
  do
  {
    ELQUtf8GetNext((char *)&a1[v11], __s);
    if (!__s[0]) {
      break;
    }
    size_t v13 = cstdlib_strlen(__s);
    ELQUtf8CaseChange((unsigned __int8 *)__s, __s, a4);
    size_t v14 = cstdlib_strlen(__s) + v10;
    if (v14 >= v12) {
      break;
    }
    v11 += v13;
    cstdlib_strcat(a2, __s);
    size_t v10 = v14;
  }
  while (v11 < v9);
  return v10;
}

uint64_t ELQUtf8GetNext(char *a1, unsigned char *a2)
{
  if (!a1) {
    goto LABEL_13;
  }
  unsigned int v2 = *a1;
  if (!*a1)
  {
    int v3 = 0;
    if (!a2) {
      return 0;
    }
    goto LABEL_14;
  }
  if ((v2 & 0x80000000) != 0)
  {
    if (v2 + 62 < 0x1E)
    {
      unsigned int v2 = 2;
      goto LABEL_24;
    }
    if ((v2 & 0xFFFFFFF0) == 0xFFFFFFE0)
    {
      unsigned int v2 = 3;
      goto LABEL_24;
    }
    if ((v2 + 11) > 0xFAu)
    {
      unsigned int v2 = 4;
LABEL_24:
      int v3 = 1;
      if (!a2) {
        return 0;
      }
      goto LABEL_14;
    }
LABEL_13:
    int v3 = 0;
    unsigned int v2 = 0;
    if (!a2) {
      return 0;
    }
    goto LABEL_14;
  }
  int v3 = 1;
  unsigned int v2 = 1;
  if (!a2) {
    return 0;
  }
LABEL_14:
  if (v3)
  {
    if (v2 <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v2;
    }
    uint64_t v6 = v5;
    unint64_t v7 = a2;
    do
    {
      char v8 = *a1++;
      *v7++ = v8;
      --v6;
    }
    while (v6);
  }
  else
  {
    uint64_t v5 = 0;
  }
  a2[v5] = 0;
  return v2;
}

uint64_t ELQUtf8CaseChange(unsigned __int8 *a1, unsigned char *a2, int a3)
{
  uint64_t v4 = 0;
  if (!a1 || !a2) {
    return v4;
  }
  unsigned int v6 = *a1;
  if (a3)
  {
    if (v6 - 97 <= 0x19)
    {
      LOBYTE(v6) = v6 - 32;
LABEL_9:
      *a2 = v6;
      a2[1] = 0;
      return (uint64_t)a2;
    }
  }
  else if (v6 - 65 <= 0x19)
  {
    LOBYTE(v6) = v6 + 32;
    goto LABEL_9;
  }
  if (v6 <= 0x7E) {
    goto LABEL_9;
  }
  uint64_t v8 = TxtEncodingCharUTF8ToUTF16(a1);
  unsigned int v9 = ELQwCaseChange(v8, a3);

  return TxtEncodingCharUTF16ToUTF8(v9, (uint64_t)a2);
}

uint64_t ELQUtf8stricmp(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  while (1)
  {
    uint64_t Next = ELQUtf8GetNext((char *)(a1 + v4), __s);
    unsigned int v6 = (char *)(a2 + v4);
    if (!Next) {
      return *v6 != 0;
    }
    if (!ELQUtf8GetNext(v6, v10)) {
      break;
    }
    v4 += cstdlib_strlen(__s);
    unint64_t v7 = (const char *)ELQUtf8CaseChange((unsigned __int8 *)__s, __s, 0);
    uint64_t v8 = (const char *)ELQUtf8CaseChange(v10, v10, 0);
    uint64_t result = cstdlib_strcmp(v7, v8);
    if (result) {
      return result;
    }
  }
  return 1;
}

uint64_t ELQUtf8GetByteNo(unsigned char *a1)
{
  if (!a1) {
    return 0;
  }
  int v1 = (char)*a1;
  if (!*a1) {
    return 0;
  }
  if ((v1 & 0x80000000) == 0) {
    return 1;
  }
  if ((v1 + 62) < 0x1E) {
    return 2;
  }
  if ((v1 & 0xFFFFFFF0) == 0xFFFFFFE0) {
    return 3;
  }
  if ((v1 + 11) > 0xFAu) {
    return 4;
  }
  else {
    return 0;
  }
}

BOOL ELQUtf8ContainsCharacterFamily(char *__s, unsigned int (*a2)(void), uint64_t a3)
{
  if (!__s) {
    return 0;
  }
  uint64_t v4 = __s;
  if (*__s)
  {
    uint64_t v6 = 0;
    do
    {
      size_t v8 = 0;
      if (ELQGetWCharFromString(__s, 65001, 0, &v8))
      {
        if (a2() != a3) {
          return a3 != 1;
        }
        v6 += v8;
      }
      else
      {
        ++v6;
      }
      __s = &v4[v6];
    }
    while (v4[v6]);
  }
  return a3;
}

char *ELQUtf8Trim(char *__s)
{
  int v1 = __s;
  size_t v8 = 0;
  if (__s && *__s)
  {
    int v2 = ELQGetWCharFromString(__s, 65001, 0, &v8);
    if (v8 && v2)
    {
      do
      {
        if (!ELQwisspace((unsigned __int16)v2)) {
          break;
        }
        v1 += v8;
        int v2 = ELQGetWCharFromString(v1, 65001, 0, &v8);
      }
      while (v8 && v2 != 0);
    }
    int v4 = ELQGetWCharFromString(v1, 65001, 1, &v8);
    if (v8) {
      BOOL v5 = v4 == 0;
    }
    else {
      BOOL v5 = 1;
    }
    if (!v5)
    {
      do
      {
        if (!ELQwisspace((unsigned __int16)v4)) {
          break;
        }
        size_t v7 = cstdlib_strlen(v1);
        v1[v7 - v8] = 0;
        int v4 = ELQGetWCharFromString(v1, 65001, 1, &v8);
        if (!v8) {
          break;
        }
      }
      while (v4);
    }
  }
  return v1;
}

uint64_t ELQUtf8Len(char *__s)
{
  size_t v8 = 0;
  if (!__s) {
    return 0;
  }
  int v1 = __s;
  if (!*__s) {
    return 0;
  }
  int v2 = ELQGetWCharFromString(__s, 65001, 0, &v8);
  uint64_t v3 = 0;
  size_t v4 = v8;
  if (v8 && v2)
  {
    uint64_t v3 = 0;
    do
    {
      ++v3;
      v1 += v4;
      int v5 = ELQGetWCharFromString(v1, 65001, 0, &v8);
      size_t v4 = v8;
      if (v8) {
        BOOL v6 = v5 == 0;
      }
      else {
        BOOL v6 = 1;
      }
    }
    while (!v6);
  }
  return v3;
}

uint64_t ELQwcslen(_WORD *a1)
{
  if (!*a1) {
    return 0;
  }
  uint64_t v1 = 0;
  int v2 = a1 + 1;
  do
    uint64_t result = v1 + 1;
  while (v2[v1++]);
  return result;
}

unsigned __int16 *ELQwcschr(unsigned __int16 *result, int a2)
{
  int v2 = *result;
  if (!*result) {
    return 0;
  }
  while (v2 != a2)
  {
    int v3 = result[1];
    ++result;
    int v2 = v3;
    if (!v3) {
      return 0;
    }
  }
  return result;
}

uint64_t ELQwcsncpy(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  if (a3)
  {
    size_t v5 = 2 * a3 - 2;
    for (uint64_t i = (_WORD *)(a1 + 2); ; ++i)
    {
      int v7 = *a2;
      *(i - 1) = v7;
      if (!v7) {
        break;
      }
      ++a2;
      v5 -= 2;
      if (!--a3) {
        return a1;
      }
    }
    if (a3 != 1) {
      bzero(i, v5);
    }
  }
  return a1;
}

unsigned __int16 *ELQwcsncat(unsigned __int16 *result, uint64_t a2, uint64_t a3)
{
  int v3 = result;
  while (*v3++)
    ;
  for (uint64_t i = 0; ; ++i)
  {
    BOOL v6 = &v3[i];
    if (a3 == i) {
      break;
    }
    int v7 = *(unsigned __int16 *)(a2 + 2 * i);
    *(v6 - 1) = v7;
    if (v7) {
      return result;
    }
  }
  *(v6 - 1) = 0;
  return result;
}

uint64_t ELQwcsncmp(_WORD *a1, unsigned __int16 *a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t v3 = a3 - 1;
  if (a3 != 1)
  {
    uint64_t v4 = 2 * a3 - 2;
    size_t v5 = (_WORD *)((char *)a1 + v4);
    BOOL v6 = (unsigned __int16 *)((char *)a2 + v4);
    while (*a1 && (unsigned __int16)*a1 == *a2)
    {
      ++a1;
      ++a2;
      if (!--v3)
      {
        a1 = v5;
        a2 = v6;
        return (unsigned __int16)*a1 - *a2;
      }
    }
  }
  return (unsigned __int16)*a1 - *a2;
}

uint64_t ELQwcscpy(uint64_t result, _WORD *a2)
{
  LOWORD(v2) = *a2;
  if (*a2)
  {
    uint64_t v3 = 0;
    do
    {
      *(_WORD *)(result + 2 * v3) = v2;
      uint64_t v4 = v3 + 1;
      int v2 = (unsigned __int16)a2[++v3];
    }
    while (v2);
  }
  else
  {
    uint64_t v4 = 0;
  }
  *(_WORD *)(result + 2 * v4) = 0;
  return result;
}

uint64_t ELQwcscat(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result - 2;
  do
  {
    int v3 = *(unsigned __int16 *)(v2 + 2);
    v2 += 2;
  }
  while (v3);
  uint64_t v4 = 0;
  do
  {
    int v5 = *(unsigned __int16 *)(a2 + v4);
    *(_WORD *)(v2 + v4) = v5;
    v4 += 2;
  }
  while (v5);
  return result;
}

uint64_t ELQwcscmp(_WORD *a1, uint64_t a2)
{
  unsigned int v2 = (unsigned __int16)*a1;
  if (*a1)
  {
    uint64_t v3 = 0;
    while (1)
    {
      unsigned int v4 = *(unsigned __int16 *)(a2 + 2 * v3);
      if (!*(_WORD *)(a2 + 2 * v3) || v2 > v4) {
        return 1;
      }
      if (v2 < v4) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v5 = v3 + 1;
      unsigned int v2 = (unsigned __int16)a1[++v3];
      if (!v2) {
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
LABEL_9:
    if (*(_WORD *)(a2 + 2 * v5)) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
}

_WORD *ELQfgetws(_WORD *a1, int a2)
{
  unsigned int v2 = a1;
  int v3 = a2 - 1;
  if (a2 == 1)
  {
    uint64_t v5 = 0;
    unsigned int v4 = v2;
  }
  else
  {
    unsigned int v4 = a1;
    while (1)
    {
      uint64_t v5 = ELQfread();
      if (v5 != 1) {
        break;
      }
      int v6 = ELQIsIntelByteOrder();
      unsigned int v7 = (unsigned __int16)*v4;
      if (!v6)
      {
        unsigned int v7 = __rev16(v7);
        *unsigned int v4 = v7;
      }
      if (v7 == 10)
      {
        *unsigned int v4 = 0;
        return v2;
      }
      ++v4;
      if (!--v3)
      {
        uint64_t v5 = 1;
        break;
      }
    }
  }
  *unsigned int v4 = 0;
  if (!v5) {
    return 0;
  }
  return v2;
}

uint64_t ELQfputws(_WORD *a1)
{
  if (!*a1) {
    return 0;
  }
  uint64_t v2 = 0;
  while (1)
  {
    ELQIsIntelByteOrder();
    if (!ELQfwrite()) {
      break;
    }
    uint64_t result = v2 + 1;
    if (!a1[++v2]) {
      return result;
    }
  }
  return v2;
}

unsigned __int16 *ELQwcsstr(unsigned __int16 *result, _WORD *a2)
{
  if (*a2)
  {
    int v2 = *result;
    if (*result)
    {
      while (1)
      {
        uint64_t v3 = 0;
        while (1)
        {
          int v4 = (unsigned __int16)a2[v3];
          if (!a2[v3] || v2 != v4) {
            break;
          }
          int v2 = result[++v3];
          if (!v2)
          {
            int v4 = (unsigned __int16)a2[v3];
            break;
          }
        }
        if (!v4) {
          break;
        }
        int v6 = result[1];
        ++result;
        int v2 = v6;
        if (!v6) {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

unint64_t ELQwcspbrk(_WORD *a1, _WORD *a2)
{
  int v2 = (unsigned __int16)*a2;
  if (!*a2) {
    return 0;
  }
  int v4 = 0;
  unint64_t result = 0;
  do
  {
    if (*a1)
    {
      int v6 = (unsigned __int16)*a1;
      unsigned int v7 = a1;
      while (v6 != v2)
      {
        int v8 = (unsigned __int16)v7[1];
        ++v7;
        int v6 = v8;
        if (!v8) {
          goto LABEL_7;
        }
      }
    }
    else
    {
LABEL_7:
      unsigned int v7 = 0;
    }
    if (result > (unint64_t)v7 || result == 0) {
      size_t v10 = v7;
    }
    else {
      size_t v10 = (_WORD *)result;
    }
    if (v7) {
      unint64_t result = (unint64_t)v10;
    }
    int v2 = (unsigned __int16)a2[++v4];
  }
  while (a2[v4]);
  return result;
}

uint64_t ELQGetWCharFromString(char *__s, int a2, int a3, size_t *a4)
{
  LOWORD(v6) = (_WORD)__s;
  if (a4) {
    *a4 = 0;
  }
  if (!__s) {
    return (unsigned __int16)v6;
  }
  if (a3)
  {
    if ((a2 - 1200) < 2)
    {
      if (*(_WORD *)__s)
      {
        unsigned int v7 = __s + 2;
        do
        {
          int v8 = *(unsigned __int16 *)v7;
          v7 += 2;
        }
        while (v8);
        unsigned int v9 = *((unsigned __int16 *)v7 - 2);
        unsigned int v10 = bswap32(v9) >> 16;
        if (a2 == 1201) {
          LOWORD(v6) = v10;
        }
        else {
          LOWORD(v6) = v9;
        }
        if (!a4) {
          return (unsigned __int16)v6;
        }
        goto LABEL_31;
      }
LABEL_33:
      LOWORD(v6) = 0;
      return (unsigned __int16)v6;
    }
    if (a2 == 65001)
    {
      uint64_t v11 = 0;
      while (__s[v11++])
        ;
      uint64_t v13 = v11 - 1;
      if (!v13) {
        goto LABEL_33;
      }
      while (v13 >= 2)
      {
        if (__s[--v13] >= -64) {
          goto LABEL_39;
        }
      }
      LODWORD(v13) = 0;
LABEL_39:
      __s += (int)v13;
      goto LABEL_40;
    }
    if (!*__s) {
      goto LABEL_33;
    }
    uint64_t v6 = __s[cstdlib_strlen(__s) - 1];
    goto LABEL_35;
  }
  switch(a2)
  {
    case 1200:
      LOWORD(v6) = *(_WORD *)__s;
      if (!a4 || !*(_WORD *)__s) {
        return (unsigned __int16)v6;
      }
LABEL_31:
      size_t v14 = 2;
      goto LABEL_45;
    case 65001:
      if (!*__s) {
        goto LABEL_33;
      }
LABEL_40:
      ELQUtf8GetNext(__s, __sa);
      __int16 v17 = TxtEncodingCharUTF8ToUTF16((unsigned __int8 *)__sa);
      if (__sa[0])
      {
        LOWORD(v6) = v17;
        if (!a4) {
          return (unsigned __int16)v6;
        }
        size_t v14 = cstdlib_strlen(__sa);
      }
      else
      {
        LOWORD(v6) = 0;
        if (!a4) {
          return (unsigned __int16)v6;
        }
        size_t v14 = 1;
      }
LABEL_45:
      *a4 = v14;
      return (unsigned __int16)v6;
    case 1201:
      LOWORD(v6) = __rev16(*(unsigned __int16 *)__s);
      if (!a4 || !*(_WORD *)__s) {
        return (unsigned __int16)v6;
      }
      goto LABEL_31;
  }
  uint64_t v6 = *__s;
  if (!*__s) {
    return (unsigned __int16)v6;
  }
LABEL_35:
  size_t v14 = 1;
  Map = TxtEncodingGetMap(a2, 1);
  int v16 = TxtEncodingCharToWChar(v6, Map);
  LOWORD(v6) = v16;
  if (a4 && v16) {
    goto LABEL_45;
  }
  return (unsigned __int16)v6;
}

const char *ELQAddWCharToString(uint64_t *a1, int a2, void *(**a3)(uint64_t a1, uint64_t a2, int a3), char *__s, uint64_t a5, size_t *a6)
{
  uint64_t v7 = a5;
  int v8 = __s;
  __sa[0] = 0;
  switch(a2)
  {
    case 1200:
      int v11 = 0;
LABEL_6:
      uint64_t v12 = 2;
      if (!__s) {
        goto LABEL_14;
      }
      goto LABEL_11;
    case 65001:
      TxtEncodingCharUTF16ToUTF8(a5, (uint64_t)__sa);
      LOWORD(v7) = 0;
      int v11 = 1;
      uint64_t v12 = 1;
      if (!v8) {
        goto LABEL_14;
      }
      goto LABEL_11;
    case 1201:
      int v11 = 0;
      LOWORD(v7) = __rev16(a5);
      goto LABEL_6;
  }
  Map = (__int16 *)TxtEncodingGetMap(a2, 0);
  char v14 = TxtEncodingWCharToChar(v7, Map);
  LOWORD(v7) = 0;
  __sa[0] = v14;
  __sa[1] = 0;
  uint64_t v12 = 1;
  int v11 = 1;
  if (!v8) {
    goto LABEL_14;
  }
LABEL_11:
  size_t v15 = *a6;
  if (*a6)
  {
    if (v11)
    {
      size_t v16 = cstdlib_strlen(v8);
      size_t v17 = cstdlib_strlen(__sa);
      size_t v15 = *a6;
    }
    else if (*(_WORD *)v8)
    {
      size_t v16 = 0;
      size_t v17 = 1;
      while (*(unsigned __int16 *)&v8[2 * v16++ + 2])
        ;
    }
    else
    {
      size_t v16 = 0;
      size_t v17 = 1;
    }
    if ((v17 + v16) * v12 >= v15)
    {
      if (a3) {
        uint64_t v20 = (uint64_t)ELQMemorySlotRealloc(a3, v8, v15, v15 + 80);
      }
      else {
        uint64_t v20 = heap_Realloc(a1, (uint64_t)v8, v15 + 80);
      }
      int v8 = (const char *)v20;
      if (!v20) {
        return v8;
      }
      *a6 += 80;
    }
    if (v11)
    {
      cstdlib_strcpy((char *)&v8[v16], __sa);
    }
    else
    {
      __int16 v21 = (char *)&v8[2 * v16];
      *(_WORD *)__int16 v21 = v7;
      *((_WORD *)v21 + 1) = 0;
    }
    return v8;
  }
LABEL_14:
  if (a3) {
    uint64_t v18 = (uint64_t)ELQMemorySlotReserve(a3, 0x50uLL);
  }
  else {
    uint64_t v18 = heap_Alloc((uint64_t)a1, 80);
  }
  int v8 = (const char *)v18;
  if (v18)
  {
    if (v11)
    {
      cstdlib_strcpy((char *)v18, __sa);
    }
    else
    {
      *(_WORD *)uint64_t v18 = v7;
      *(_WORD *)(v18 + 2) = 0;
    }
    *a6 = 80;
  }
  return v8;
}

uint64_t ELQwisdigit(unsigned int a1)
{
  if (a1 - 48 < 0xA) {
    return 1;
  }
  if (a1 < 0xA0) {
    return 0;
  }
  int v2 = 0;
  int v3 = 232;
  do
  {
    int v4 = (v2 + v3) / 2;
    unsigned int v5 = ELQwisdigit_wisdigitList[v4];
    if (v5 <= a1)
    {
      if (v5 >= a1) {
        return v4 != -1;
      }
      int v2 = v4 + 1;
    }
    else
    {
      int v3 = v4 - 1;
    }
  }
  while (v2 <= v3);
  int v4 = -1;
  return v4 != -1;
}

BOOL ELQwisspace(unsigned int a1)
{
  uint64_t v1 = 1;
  if (a1 - 8 >= 6 && a1 != 32)
  {
    if (a1 >= 0xA0)
    {
      int v3 = 0;
      int v4 = 24;
      do
      {
        int v5 = (v3 + v4) / 2;
        unsigned int v6 = (unsigned __int16)ELQwisspace_wisspaceList[v5];
        if (v6 <= a1)
        {
          if (v6 >= a1) {
            return v5 != -1;
          }
          int v3 = v5 + 1;
        }
        else
        {
          int v4 = v5 - 1;
        }
      }
      while (v3 <= v4);
      int v5 = -1;
      return v5 != -1;
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

BOOL ELQwispunct(unsigned int a1)
{
  int v1 = 0;
  int v2 = 475;
  do
  {
    int v3 = (v1 + v2) / 2;
    unsigned int v4 = ELQwispunct_wispunctList[v3];
    if (v4 <= a1)
    {
      if (v4 >= a1) {
        return v3 != -1;
      }
      int v1 = v3 + 1;
    }
    else
    {
      int v2 = v3 - 1;
    }
  }
  while (v1 <= v2);
  int v3 = -1;
  return v3 != -1;
}

BOOL ELQwiscntrl(unsigned int a1)
{
  int v1 = 0;
  int v2 = 96;
  do
  {
    int v3 = (v1 + v2) / 2;
    unsigned int v4 = ELQwiscntrl_wiscntrlList[v3];
    if (v4 <= a1)
    {
      if (v4 >= a1) {
        return v3 != -1;
      }
      int v1 = v3 + 1;
    }
    else
    {
      int v2 = v3 - 1;
    }
  }
  while (v1 <= v2);
  int v3 = -1;
  return v3 != -1;
}

BOOL ELQwisalpha(unsigned int a1)
{
  if ((unsigned __int16)((a1 & 0xFFDF) - 65) < 0x1Au) {
    return 1;
  }
  if (ELQwisspace(a1)) {
    return 0;
  }
  int v3 = 0;
  int v4 = 96;
  while (1)
  {
    int v5 = v3 + v4;
    int v6 = v3 + v4 >= 0 ? v3 + v4 : v5 + 1;
    int v7 = v6 >> 1;
    unsigned int v8 = ELQwiscntrl_wiscntrlList[v7];
    if (v8 <= a1) {
      break;
    }
    int v4 = v7 - 1;
LABEL_12:
    if (v3 > v4) {
      goto LABEL_13;
    }
  }
  if (v8 < a1)
  {
    int v3 = v7 + 1;
    goto LABEL_12;
  }
  if ((v5 + 3) > 1) {
    return 0;
  }
LABEL_13:
  if (ELQwisdigit(a1)) {
    return 0;
  }
  int v9 = 0;
  int v10 = 475;
  while (2)
  {
    int v11 = v9 + v10;
    if (v9 + v10 >= 0) {
      int v12 = v9 + v10;
    }
    else {
      int v12 = v11 + 1;
    }
    int v13 = v12 >> 1;
    unsigned int v14 = ELQwispunct_wispunctList[v13];
    if (v14 > a1)
    {
      int v10 = v13 - 1;
      goto LABEL_22;
    }
    if (v14 < a1)
    {
      int v9 = v13 + 1;
LABEL_22:
      if (v9 > v10) {
        return 1;
      }
      continue;
    }
    break;
  }
  return (v11 + 3) < 2;
}

uint64_t ELQwCaseChange(uint64_t result, int a2)
{
  if (!a2)
  {
    if ((result - 65) <= 0x19)
    {
      LOWORD(result) = result + 32;
      return (unsigned __int16)result;
    }
    if (result < 0x7F) {
      return (unsigned __int16)result;
    }
    int v2 = 872;
    int v3 = Utf16ToLower;
LABEL_10:
    int v4 = 0;
    while (1)
    {
      unsigned int v5 = (unsigned __int16)v3[2 * ((v2 + v4) / 2)];
      if (v5 <= result)
      {
        if (v5 == result)
        {
          LOWORD(result) = v3[2 * ((uint64_t)(v2 + v4 + (v2 + v4 < 0)) >> 1) + 1];
          return (unsigned __int16)result;
        }
        int v4 = (v2 + v4) / 2 + 1;
      }
      else
      {
        int v2 = (v2 + v4) / 2 - 1;
      }
      if (v4 > v2) {
        return (unsigned __int16)result;
      }
    }
  }
  if ((result - 97) > 0x19)
  {
    if (result < 0x7F) {
      return (unsigned __int16)result;
    }
    int v2 = 873;
    int v3 = Utf16ToUpper;
    goto LABEL_10;
  }
  LOWORD(result) = result - 32;
  return (unsigned __int16)result;
}

uint64_t ELQwcsspn(_WORD *a1, unsigned __int16 *a2)
{
  int v2 = (unsigned __int16)*a1;
  if (*a1)
  {
    uint64_t result = 0;
    int v7 = *a2;
    unsigned int v5 = a2 + 1;
    int v6 = v7;
    while (v6)
    {
      unsigned int v8 = v5;
      int v9 = v6;
      while (v9 != v2)
      {
        int v10 = *v8++;
        int v9 = v10;
        if (!v10) {
          return result;
        }
      }
      int v2 = (unsigned __int16)a1[++result];
      if (!a1[result]) {
        return result;
      }
    }
  }
  return 0;
}

uint64_t ELQwcscspn(_WORD *a1, unsigned __int16 *a2)
{
  int v2 = (unsigned __int16)*a1;
  if (!*a1) {
    return 0;
  }
  uint64_t result = 0;
  int v7 = *a2;
  unsigned int v5 = a2 + 1;
  int v6 = v7;
  while (!v6)
  {
LABEL_7:
    int v2 = (unsigned __int16)a1[++result];
    if (!a1[result]) {
      return result;
    }
  }
  unsigned int v8 = v5;
  int v9 = v6;
  while (v9 != v2)
  {
    int v10 = *v8++;
    int v9 = v10;
    if (!v10) {
      goto LABEL_7;
    }
  }
  return result;
}

void *ELQwcsdup(uint64_t a1, _WORD *a2)
{
  if (!a2) {
    return 0;
  }
  if (*a2)
  {
    size_t v3 = 1;
    while (a2[v3++])
      ;
  }
  else
  {
    size_t v3 = 1;
  }
  int v6 = (void *)heap_Alloc(a1, v3 * 2);
  unsigned int v5 = v6;
  if (v6) {
    cstdlib_memcpy(v6, a2, v3 * 2);
  }
  return v5;
}

uint64_t ELQwcsicmp(unsigned __int16 *a1, uint64_t a2)
{
  unsigned __int16 v3 = *a1;
  if (*a1)
  {
    uint64_t v5 = 0;
    int v6 = 0;
    while (1)
    {
      uint64_t v7 = *(unsigned __int16 *)(a2 + 2 * v5);
      if (!*(_WORD *)(a2 + 2 * v5)) {
        return 1;
      }
      int v8 = ELQwCaseChange(v3, 0);
      uint64_t result = v8 - ELQwCaseChange(v7, 0);
      if (result) {
        return result;
      }
      uint64_t v5 = (unsigned __int16)++v6;
      unsigned __int16 v3 = a1[(unsigned __int16)v6];
      if (!v3) {
        goto LABEL_8;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
LABEL_8:
    if (*(_WORD *)(a2 + 2 * v5)) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
}

unsigned __int16 *ELQwtrim(unsigned __int16 *a1, int a2)
{
  int v2 = a1;
  unsigned int v3 = *a1;
  if (*a1)
  {
    while (1)
    {
      unsigned int v5 = bswap32(v3) >> 16;
      if (a2) {
        LOWORD(v3) = v5;
      }
      if (!ELQwisspace((unsigned __int16)v3)) {
        break;
      }
      unsigned int v6 = v2[1];
      ++v2;
      unsigned int v3 = v6;
      if (!v6) {
        return v2;
      }
    }
    uint64_t v7 = 0;
    int v8 = v2;
    do
    {
      ++v7;
      int v9 = v8[1];
      ++v8;
    }
    while (v9);
    if (v7)
    {
      uint64_t v10 = -1;
      do
      {
        if (!*v2) {
          break;
        }
        unsigned int v11 = __rev16(*v2);
        unsigned int v12 = a2 ? v11 : *v2;
        if (!ELQwisspace(v12)) {
          break;
        }
        v8[v10--] = 0;
      }
      while (v7 + v10 != -1);
    }
  }
  return v2;
}

uint64_t ELQIsSentenceTermination(int a1)
{
  uint64_t result = 1;
  if (a1 <= 1747)
  {
    if ((a1 > 0x3F || ((1 << a1) & 0x8C00400200000000) == 0) && a1 != 1563 && a1 != 1567) {
      return 0;
    }
  }
  else
  {
    if (a1 <= 65280)
    {
      if (a1 == 1748) {
        return result;
      }
      int v3 = 12290;
LABEL_13:
      if (a1 == v3) {
        return result;
      }
      return 0;
    }
    if ((a1 - 65281) > 0x1E || ((1 << (a1 - 1)) & 0x46002001) == 0)
    {
      int v3 = 65377;
      goto LABEL_13;
    }
  }
  return result;
}

uint64_t ELQIsPhraseTermination(int a1)
{
  uint64_t result = 1;
  if (a1 <= 1547)
  {
    if (a1 <= 0x2D && ((1 << a1) & 0x330000000000) != 0) {
      return result;
    }
    return 0;
  }
  if (a1 > 65291)
  {
    if (a1 == 65292) {
      return result;
    }
    int v3 = 65380;
  }
  else
  {
    if (a1 == 1548) {
      return result;
    }
    int v3 = 12289;
  }
  if (a1 != v3) {
    return 0;
  }
  return result;
}

char *ELQAsciiHex2num(const char *a1, _WORD *a2)
{
  int v3 = a1;
  size_t v4 = cstdlib_strlen(a1);
  if (v4)
  {
    size_t v5 = v4;
    __int16 v6 = 0;
    do
    {
      if (cstdlib_strchr("ABCDEF", *v3))
      {
        __int16 v7 = -55;
      }
      else if (cstdlib_strchr("abcdef", *v3))
      {
        __int16 v7 = -87;
      }
      else
      {
        uint64_t result = cstdlib_strchr("0987654321", *v3);
        if (!result) {
          return result;
        }
        __int16 v7 = -48;
      }
      __int16 v9 = *v3++;
      __int16 v6 = v7 + 16 * v6 + v9;
      --v5;
    }
    while (v5);
  }
  else
  {
    __int16 v6 = 0;
  }
  *a2 = v6;
  return (char *)1;
}

_WORD *ELQwcstok(uint64_t a1, _WORD *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t result = (_WORD *)(a1 + 2 * *a3);
  int v5 = (unsigned __int16)*result;
  if (!*result) {
    return 0;
  }
  int v6 = (unsigned __int16)*a2;
  __int16 v7 = result;
  while (!v6)
  {
LABEL_7:
    int v10 = (unsigned __int16)v7[1];
    ++v7;
    int v5 = v10;
    *a3 = ++v3;
    if (!v10) {
      return result;
    }
  }
  uint64_t v8 = 1;
  int v9 = v6;
  while (v9 != v5)
  {
    int v9 = (unsigned __int16)a2[v8++];
    if (!v9) {
      goto LABEL_7;
    }
  }
  if (v5)
  {
    do
    {
      int v11 = (unsigned __int16)*a2;
      if (!*a2) {
        break;
      }
      unsigned int v12 = a2 + 1;
      while (v11 != v5)
      {
        int v13 = *v12++;
        int v11 = v13;
        if (!v13) {
          return result;
        }
      }
      *__int16 v7 = 0;
      int v14 = (unsigned __int16)v7[1];
      ++v7;
      int v5 = v14;
      *a3 = ++v3;
    }
    while (v14);
  }
  return result;
}

uint64_t ELQfseek()
{
  return 0;
}

uint64_t ELQftell()
{
  return 0;
}

uint64_t ELQfread()
{
  return 0;
}

uint64_t ELQfwrite()
{
  return 0;
}

uint64_t ELQremove()
{
  return 0;
}

uint64_t ELQfopenDebug()
{
  return 0;
}

uint64_t ELQfcloseDebug()
{
  return 0xFFFFFFFFLL;
}

uint64_t ELQfopen()
{
  return 0;
}

uint64_t ELQfclose()
{
  return 0xFFFFFFFFLL;
}

uint64_t ELQfgets()
{
  return 0;
}

uint64_t ELQfputs()
{
  return 0;
}

uint64_t ELQfgetc()
{
  return 0;
}

uint64_t ELQstdout()
{
  return 0;
}

uint64_t ELQflength()
{
  return 0;
}

uint64_t ELQfprintf()
{
  return 0;
}

uint64_t ELQIsIntelByteOrder()
{
  return 1;
}

void *ELQMemorySlotInit(uint64_t a1, uint64_t a2, int a3)
{
  int v6 = (void *)heap_Alloc(*(void *)(a1 + 8), 72);
  __int16 v7 = v6;
  if (v6)
  {
    v6[1] = a1;
    v6[4] = 0;
    v6[5] = a2;
    v6[3] = 0;
    uint64_t v8 = ReallocBuffers(v6);
    v7[2] = v8;
    *((_DWORD *)v7 + 12) = a3;
    v7[7] = 0;
    v7[8] = 0;
    if (v8) {
      *__int16 v7 = ELQMemorySlotInit;
    }
    else {
      return 0;
    }
  }
  return v7;
}

uint64_t ReallocBuffers(void *a1)
{
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = v2 + 100;
    a1[4] = v3;
    uint64_t v4 = heap_Realloc(*(uint64_t **)(a1[1] + 8), a1[2], 24 * v3);
  }
  else
  {
    a1[4] = 100;
    uint64_t v4 = heap_Alloc(*(void *)(a1[1] + 8), 2400);
  }
  uint64_t v5 = v4;
  a1[2] = v4;
  if (v4)
  {
    unint64_t v6 = a1[4];
    if (v6 >= 0x64)
    {
      __int16 v7 = (void *)(v4 + 24 * v6 - 2400);
      BOOL v8 = v6 - 99 >= v6;
      uint64_t v9 = -99;
      if (!v8) {
        uint64_t v9 = 0;
      }
      bzero(v7, 24 * v9 + 2400);
    }
  }
  return v5;
}

void *ELQMemorySlotDelete(void *result)
{
  if (result)
  {
    int v1 = result;
    if ((void *(*)(uint64_t, uint64_t, int))*result == ELQMemorySlotInit)
    {
      uint64_t v2 = result[4];
      if (v2)
      {
        uint64_t v3 = 24 * v2 - 24;
        do
        {
          --v2;
          heap_Free(*(void **)(v1[1] + 8), *(void *)(v1[2] + v3));
          v3 -= 24;
        }
        while (v2);
      }
      heap_Free(*(void **)(v1[1] + 8), v1[2]);
      void *v1 = 0;
      uint64_t v4 = *(void **)(v1[1] + 8);
      return heap_Free(v4, (uint64_t)v1);
    }
  }
  return result;
}

void *(**ELQMemorySlotSave(void *(**result)(uint64_t a1, uint64_t a2, int a3), const char *__c, size_t __len))(uint64_t a1, uint64_t a2, int a3)
{
  if (!result) {
    return result;
  }
  uint64_t v3 = (uint64_t)result;
  if (*result != ELQMemorySlotInit) {
    return 0;
  }
  size_t v4 = __len;
  if (__c && !__len) {
    size_t v4 = cstdlib_strlen(__c) + 1;
  }
  *(void *)(v3 + 64) += v4;
  if (v4 > *(void *)(v3 + 40))
  {
    unint64_t v6 = *(void *)(v3 + 24);
    goto LABEL_14;
  }
  unint64_t v7 = *(void *)(v3 + 56);
  unint64_t v6 = *(void *)(v3 + 24);
  if (v7 >= v6)
  {
LABEL_14:
    if (v6 >= *(void *)(v3 + 32))
    {
      uint64_t result = (void *(**)(uint64_t, uint64_t, int))ReallocBuffers((void *)v3);
      *(void *)(v3 + 16) = result;
      if (!result) {
        return result;
      }
      size_t v9 = *(void *)(v3 + 40);
      if (v4 > v9) {
        size_t v9 = v4;
      }
      *(void *)(v3 + 40) = v9;
    }
    else
    {
      uint64_t result = *(void *(***)(uint64_t, uint64_t, int))(v3 + 16);
      size_t v9 = *(void *)(v3 + 40);
      if (v4 > v9) {
        size_t v9 = v4;
      }
      *(void *)(v3 + 40) = v9;
      if (!result) {
        return result;
      }
    }
    int v10 = &result[3 * *(void *)(v3 + 24)];
    unint64_t v11 = (v9 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    v10[1] = v11;
    char v10[2] = 0;
    uint64_t result = (void *(**)(uint64_t, uint64_t, int))heap_Alloc(*(void *)(*(void *)(v3 + 8) + 8), v11);
    *int v10 = result;
    if (result)
    {
      uint64_t result = (void *(**)(uint64_t, uint64_t, int))SaveInBuffer(__c, v4, (void *)(*(void *)(v3 + 16)+ 24 * *(void *)(v3 + 24)));
      if (result)
      {
        uint64_t v12 = *(void *)(v3 + 24);
        if (*(_DWORD *)(v3 + 48)) {
          *(void *)(v3 + 56) = v12;
        }
        *(void *)(v3 + 24) = v12 + 1;
      }
    }
    return result;
  }
  uint64_t v8 = 24 * v7;
  while (1)
  {
    uint64_t result = (void *(**)(uint64_t, uint64_t, int))SaveInBuffer(__c, v4, (void *)(*(void *)(v3 + 16) + v8));
    if (result) {
      break;
    }
    ++v7;
    unint64_t v6 = *(void *)(v3 + 24);
    v8 += 24;
    if (v7 >= v6) {
      goto LABEL_14;
    }
  }
  if (*(_DWORD *)(v3 + 48)) {
    *(void *)(v3 + 56) = v7;
  }
  return result;
}

void *SaveInBuffer(const void *__c, size_t __len, void *a3)
{
  size_t v4 = (__len + 3) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v5 = a3[2];
  if (v5 + v4 > a3[1]) {
    return 0;
  }
  unint64_t v6 = (void *)(*a3 + v5);
  if (__c) {
    cstdlib_memcpy(v6, __c, __len);
  }
  else {
    cstdlib_memset(v6, 0, __len);
  }
  a3[2] += v4;
  return v6;
}

void *(**ELQMemorySlotReserve(void *(**a1)(uint64_t a1, uint64_t a2, int a3), size_t __len))(uint64_t a1, uint64_t a2, int a3)
{
  return ELQMemorySlotSave(a1, 0, __len);
}

uint64_t ELQMemorySlotReset(uint64_t result)
{
  if (result && *(void *(**)(uint64_t, uint64_t, int))result == ELQMemorySlotInit)
  {
    uint64_t v1 = *(void *)(result + 32);
    if (v1)
    {
      uint64_t v2 = (void *)(*(void *)(result + 16) + 16);
      do
      {
        *uint64_t v2 = 0;
        v2 += 3;
        --v1;
      }
      while (v1);
    }
    *(void *)(result + 56) = 0;
    *(void *)(result + 64) = 0;
  }
  return result;
}

void *(**ELQMemorySlotRealloc(void *(**a1)(uint64_t a1, uint64_t a2, int a3), const void *a2, size_t a3, size_t __len))(uint64_t a1, uint64_t a2, int a3)
{
  if (!a1 || *a1 != ELQMemorySlotInit) {
    return 0;
  }
  uint64_t v8 = ELQMemorySlotSave(a1, 0, __len);
  size_t v4 = v8;
  if (v8) {
    cstdlib_memcpy(v8, a2, a3);
  }
  return v4;
}

uint64_t ELQMemorySlotGetCurrentlyReservedBytes(uint64_t result)
{
  if (result)
  {
    if (*(void *(**)(uint64_t, uint64_t, int))result == ELQMemorySlotInit) {
      return *(void *)(result + 64);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t ELQbsearch(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t))
{
  if (!a3) {
    return 0;
  }
  unint64_t v7 = a3;
  while (1)
  {
    uint64_t v10 = a2 + (v7 >> 1) * a4;
    int v11 = a5(a1, v10);
    if (!v11) {
      break;
    }
    if (v11 > 0) {
      a2 = v10 + a4;
    }
    unint64_t v12 = v7 - (v11 > 0);
    unint64_t v7 = v12 >> 1;
    if (v12 <= 1) {
      return 0;
    }
  }
  return v10;
}

uint64_t ELQPluginGetProc(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result = 2375032834;
  if (a1)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t, void))(a1 + 88);
    if (v5)
    {
      if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, char *, char *, const char *, uint64_t, uint64_t))a1 == ELQPluginIni)
      {
        uint64_t v7 = v5(a2, *(void *)(a1 + 104));
        uint64_t result = 0;
        *a3 = v7;
      }
    }
  }
  return result;
}

uint64_t ELQPluginIni(uint64_t a1, uint64_t *a2, uint64_t a3, char *a4, char *a5, const char *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v14 = 2375032834;
  size_t v15 = (void *)heap_Alloc(*(void *)(a1 + 8), 120);
  if (!v15) {
    return 2375032842;
  }
  uint64_t v16 = (uint64_t)v15;
  *size_t v15 = 0;
  if (a5) {
    FileFullPath(__dst, a5, a4);
  }
  else {
    cstdlib_strcpy(__dst, a4);
  }
  cstdlib_strcat(__dst, ".so");
  *(void *)(v16 + 88) = 0;
  size_t v17 = (char *(**)(char *))(v16 + 88);
  *(void *)(v16 + 112) = a1;
  *(void *)(v16 + 96) = 0;
  if (!cstdlib_strcmp(a6, "LTTS7XML"))
  {
    *size_t v17 = LTTS7XML;
    goto LABEL_12;
  }
  if (*v17)
  {
LABEL_12:
    *(void *)(v16 + 104) = a8;
    *(void *)uint64_t v16 = ELQPluginIni;
    cstdlib_strcpy((char *)(v16 + 8), a4);
    uint64_t v14 = 0;
    *a2 = v16;
    return v14;
  }
  if (*(uint64_t (**)())v16 == ELQPluginIni)
  {
    *(void *)uint64_t v16 = 0;
    *(void *)(v16 + 96) = 0;
    heap_Free(*(void **)(*(void *)(v16 + 112) + 8), v16);
  }
  heap_Free(*(void **)(a1 + 8), v16);
  return v14;
}

uint64_t ELQPluginLoadUtilSymbols(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = *(uint64_t (**)(const char *, void))(a1 + 88);
  if (!v2) {
    return 0;
  }
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, char *, char *, const char *, uint64_t, uint64_t))a1 != ELQPluginIni) {
    return 0;
  }
  uint64_t v5 = (uint64_t (*)(uint64_t))v2("LoadUtilSymbols", *(void *)(a1 + 104));
  if (!a2 || !v5) {
    return 0;
  }

  return v5(a2);
}

uint64_t ELQPluginGetVersion(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(const char *, void))(result + 88);
    if (v3
      && *(uint64_t (**)(uint64_t, uint64_t *, uint64_t, char *, char *, const char *, uint64_t, uint64_t))result == ELQPluginIni)
    {
      uint64_t result = v3("GetVersion", *(void *)(result + 104));
      if (result) {
        return ((unsigned int (*)(uint64_t))result)(a3) == 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t (**ELQPluginDelete(uint64_t (**result)(uint64_t a1, uint64_t *a2, uint64_t a3, char *a4, char *a5, const char *a6, uint64_t a7, uint64_t a8)))(uint64_t a1, uint64_t *a2, uint64_t a3, char *a4, char *a5, const char *a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    if (*result == ELQPluginIni)
    {
      *uint64_t result = 0;
      result[12] = 0;
      return (uint64_t (**)(uint64_t, uint64_t *, uint64_t, char *, char *, const char *, uint64_t, uint64_t))heap_Free(*((void **)result[14] + 1), (uint64_t)result);
    }
  }
  return result;
}

uint64_t ELQPluginBuiltInFuncTableIni(uint64_t a1, void *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = heap_Alloc(*(void *)(a1 + 8), 120);
  if (!v11) {
    return 2375032842;
  }
  unint64_t v12 = (void *)v11;
  *(void *)(v11 + 112) = a1;
  *(void *)(v11 + 96) = 0;
  *(void *)(v11 + 104) = a6;
  cstdlib_strcpy((char *)(v11 + 8), a4);
  uint64_t result = 0;
  v12[11] = a5;
  *unint64_t v12 = ELQPluginIni;
  *a2 = v12;
  return result;
}

uint64_t (**ELQPluginGetFileName(uint64_t (**result)(uint64_t a1, uint64_t *a2, uint64_t a3, char *a4, char *a5, const char *a6, uint64_t a7, uint64_t a8)))(uint64_t a1, uint64_t *a2, uint64_t a3, char *a4, char *a5, const char *a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v1 = *result++;
    if (v1 != ELQPluginIni) {
      return 0;
    }
  }
  return result;
}

uint64_t ELQPluginGetUserData(uint64_t result)
{
  if (result)
  {
    if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, char *, char *, const char *, uint64_t, uint64_t))result == ELQPluginIni) {
      return *(void *)(result + 104);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t ELQPluginGetFullPathName()
{
  return 0;
}

uint64_t VoiceInfoIni(void *a1, uint64_t a2)
{
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  uint64_t v44 = 0;
  size_t v4 = (void *)heap_Alloc(*(void *)(a2 + 8), 24);
  if (!v4) {
    return 2375032842;
  }
  uint64_t v5 = v4;
  cstdlib_memset(v4, 0, 0x18uLL);
  *a1 = v5;
  v5[2] = a2;
  *uint64_t v5 = VoiceInfoIni;
  uint64_t v6 = hashtable_ObjOpen(v5 + 1, a2, 32, 0);
  if ((v6 & 0x80000000) != 0)
  {
    uint64_t v36 = v6;
LABEL_84:
    VoiceInfoDelete((uint64_t (**)())v5);
    return v36;
  }
  hashtable_ElementSetDestructor(v5[1], (uint64_t)FreeVoiceElement);
  uint64_t v7 = brk_ComponentTableIteratorOpen(*(void *)(a2 + 24), (uint64_t)"pipeline/*", (uint64_t)&v46);
  uint64_t v8 = v7;
  if ((v7 & 0x80000000) != 0)
  {
    uint64_t v36 = v7;
    goto LABEL_84;
  }
  if ((brk_ComponentTableIteratorNext(v46) & 0x80000000) == 0)
  {
    uint64_t v40 = v5;
    unint64_t v41 = v5 + 1;
    do
    {
      uint64_t v8 = brk_TagIteratorOpen(*(void *)(a2 + 24), v45, "PARAMETERS/*", 1, &v44);
      if ((v8 & 0x80000000) == 0)
      {
        unsigned int v42 = 0;
        long long __s1 = 0;
        if ((brk_TagIteratorNext(v44, (uint64_t)&__s1, (uint64_t)&v42) & 0x80000000) == 0)
        {
          size_t v9 = 0;
          uint64_t v10 = 0;
          uint64_t v11 = 0;
          unint64_t v12 = 0;
          do
          {
            if (__s1) {
              BOOL v13 = v42 == 0;
            }
            else {
              BOOL v13 = 1;
            }
            if (!v13 && *v42)
            {
              if (cstdlib_strcmp(__s1, "voice"))
              {
                if (cstdlib_strcmp(__s1, "langcode"))
                {
                  if (cstdlib_strcmp(__s1, "gender"))
                  {
                    if (!cstdlib_strcmp(__s1, "age"))
                    {
                      unsigned int v14 = LH_atoi(v42);
                      size_t v15 = "adult";
                      if (v14 <= 0x11) {
                        size_t v15 = "child";
                      }
                      if (v14) {
                        uint64_t v10 = v15;
                      }
                      else {
                        uint64_t v10 = v42;
                      }
                    }
                  }
                  else
                  {
                    size_t v9 = v42;
                  }
                }
                else
                {
                  uint64_t v11 = v42;
                }
              }
              else
              {
                unint64_t v12 = v42;
              }
            }
          }
          while ((brk_TagIteratorNext(v44, (uint64_t)&__s1, (uint64_t)&v42) & 0x80000000) == 0);
          if (v12 && *v12)
          {
            uint64_t v16 = strhelper_Strdup(*(void *)(a2 + 8), v12);
            if (!v16)
            {
              size_t v37 = *(void **)(a2 + 8);
              uint64_t v38 = 0;
              goto LABEL_83;
            }
            uint64_t v17 = (uint64_t)v16;
            int v18 = *v12;
            if (*v12)
            {
              uint64_t v19 = 0;
              unsigned int v20 = 1;
              do
              {
                if ((v18 - 65) < 0x1A) {
                  LOBYTE(v18) = v18 + 32;
                }
                v16[v19] = v18;
                uint64_t v19 = v20;
                int v18 = v12[v20++];
              }
              while (v18);
            }
            if (!hashtable_Get(*v41))
            {
              __int16 v21 = *(void **)(a2 + 8);
              uint64_t v22 = (uint64_t *)heap_Alloc((uint64_t)v21, 24);
              if (!v22) {
                goto LABEL_82;
              }
              int v23 = v22;
              *uint64_t v22 = 0;
              v22[1] = 0;
              v22[2] = 0;
              if (v11)
              {
                if (*v11) {
                  unsigned __int16 v24 = (char *)v11;
                }
                else {
                  unsigned __int16 v24 = "unknown";
                }
              }
              else
              {
                unsigned __int16 v24 = "unknown";
              }
              int v25 = strhelper_Strdup((uint64_t)v21, v24);
              *int v23 = (uint64_t)v25;
              if (!v25) {
                goto LABEL_81;
              }
              int v26 = *v25;
              if (*v25)
              {
                unsigned int v27 = 1;
                do
                {
                  if ((v26 - 65) < 0x1A) {
                    LOBYTE(v26) = v26 + 32;
                  }
                  *int v25 = v26;
                  int v25 = (unsigned char *)(*v23 + v27);
                  int v26 = *v25;
                  ++v27;
                }
                while (*v25);
              }
              if (v9) {
                int v28 = *v9 ? (char *)v9 : "neutral";
              }
              else {
                int v28 = "neutral";
              }
              char v29 = strhelper_Strdup((uint64_t)v21, v28);
              v23[1] = (uint64_t)v29;
              if (!v29) {
                goto LABEL_81;
              }
              int v30 = *v29;
              if (*v29)
              {
                unsigned int v31 = 1;
                do
                {
                  if ((v30 - 65) < 0x1A) {
                    LOBYTE(v30) = v30 + 32;
                  }
                  unsigned char *v29 = v30;
                  char v29 = (unsigned char *)(v23[1] + v31);
                  int v30 = *v29;
                  ++v31;
                }
                while (*v29);
              }
              if (v10) {
                uint64_t v32 = *v10 ? (char *)v10 : "adult";
              }
              else {
                uint64_t v32 = "adult";
              }
              size_t v33 = strhelper_Strdup((uint64_t)v21, v32);
              v23[2] = (uint64_t)v33;
              if (!v33)
              {
LABEL_81:
                FreeVoiceElement(v21, v23);
LABEL_82:
                size_t v37 = *(void **)(a2 + 8);
                uint64_t v38 = v17;
LABEL_83:
                heap_Free(v37, v38);
                uint64_t v36 = 2375032842;
                uint64_t v5 = v40;
                goto LABEL_84;
              }
              int v34 = *v33;
              if (*v33)
              {
                unsigned int v35 = 1;
                do
                {
                  if ((v34 - 65) < 0x1A) {
                    LOBYTE(v34) = v34 + 32;
                  }
                  *size_t v33 = v34;
                  size_t v33 = (unsigned char *)(v23[2] + v35);
                  int v34 = *v33;
                  ++v35;
                }
                while (*v33);
              }
              hashtable_Set(*v41);
            }
            heap_Free(*(void **)(a2 + 8), v17);
          }
        }
        brk_TagIteratorClose(v44);
        uint64_t v44 = 0;
      }
    }
    while ((brk_ComponentTableIteratorNext(v46) & 0x80000000) == 0);
    brk_ComponentTableIteratorClose(v46);
    uint64_t v36 = v8;
    uint64_t v5 = v40;
    if ((v8 & 0x80000000) == 0) {
      return v8;
    }
    goto LABEL_84;
  }
  brk_ComponentTableIteratorClose(v46);
  return v8;
}

void *FreeVoiceElement(void *a1, uint64_t *a2)
{
  uint64_t v4 = a2[2];
  if (v4) {
    heap_Free(a1, v4);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    heap_Free(a1, v5);
  }
  if (*a2) {
    heap_Free(a1, *a2);
  }

  return heap_Free(a1, (uint64_t)a2);
}

uint64_t (**VoiceInfoDelete(uint64_t (**result)()))()
{
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    if (*result == VoiceInfoIni)
    {
      uint64_t v2 = result[1];
      if (v2) {
        hashtable_ObjClose(v2);
      }
      *(void *)(v1 + 8) = 0;
      uint64_t v3 = *(void **)(*(void *)(v1 + 16) + 8);
      return (uint64_t (**)())heap_Free(v3, v1);
    }
  }
  return result;
}

uint64_t VoiceInfoGetAttribute(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = 0;
  if (a1)
  {
    uint64_t v5 = a2;
    if (a2)
    {
      if (*(uint64_t (**)(void *, uint64_t))a1 == VoiceInfoIni)
      {
        uint64_t v7 = hashtable_Get(*(void *)(a1 + 8));
        if (!v7) {
          return 0;
        }
        switch(a3)
        {
          case 0:
            return v5;
          case 1:
            return *(void *)v7;
          case 2:
            v7 += 8;
            break;
          case 3:
            v7 += 16;
            break;
          default:
            return 0;
        }
        return *(void *)v7;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void *VoiceInfoEnumCreate(uint64_t a1)
{
  if (a1 && *(uint64_t (**)(void *, uint64_t))a1 == VoiceInfoIni) {
    return hashtable_EnumCreate(*(void **)(a1 + 8));
  }
  else {
    return 0;
  }
}

char *LTTS7XML(char *__s1)
{
  if (__s1)
  {
    uint64_t v1 = __s1;
    uint64_t v2 = 0;
    while (cstdlib_strcmp(v1, (&LTTS7XML_FuncTable)[v2]))
    {
      v2 += 2;
      if (v2 == 38) {
        return 0;
      }
    }
    return (&LTTS7XML_FuncTable)[v2 + 1];
  }
  return __s1;
}

uint64_t LoqXMLGetVersion(char *a1)
{
  return 0;
}

uint64_t LoqXMLIniParser(void *a1, uint64_t a2)
{
  uint64_t v2 = 2375032842;
  if (!a1) {
    return 2375032839;
  }
  uint64_t v5 = heap_Alloc(*(void *)(a2 + 8), 536);
  if (v5)
  {
    uint64_t v6 = (void *)v5;
    *(void *)(v5 + 528) = a2;
    v10[1] = builtin_Alloc_0;
    char v10[2] = builtin_Realloc_0;
    uint64_t v7 = *(void *)(a2 + 8);
    v10[3] = builtin_Free_0;
    v10[0] = v7;
    uint64_t MM = crnc3rdprtyrnm_XML_ParserCreate_MM(0, (uint64_t)v10, 0);
    v6[1] = MM;
    if (MM)
    {
      uint64_t v2 = 0;
      *uint64_t v6 = LoqXMLIniParser;
      *a1 = v6;
    }
    else
    {
      heap_Free(*(void **)(a2 + 8), (uint64_t)v6);
    }
  }
  return v2;
}

uint64_t LoqXMLIniParserNS(void *a1, uint64_t a2, char a3)
{
  uint64_t v3 = 2375032842;
  char v12 = a3;
  if (!a1) {
    return 2375032839;
  }
  uint64_t v6 = heap_Alloc(*(void *)(a2 + 8), 536);
  if (v6)
  {
    uint64_t v7 = (void *)v6;
    v11[1] = builtin_Alloc_0;
    v11[2] = builtin_Realloc_0;
    uint64_t v8 = *(void *)(a2 + 8);
    v11[3] = builtin_Free_0;
    v11[0] = v8;
    uint64_t v9 = crnc3rdprtyrnm_XML_ParserCreate_MM("uft-8", (uint64_t)v11, &v12);
    v7[1] = v9;
    if (v9)
    {
      uint64_t v3 = 0;
      *uint64_t v7 = LoqXMLIniParser;
      *a1 = v7;
    }
    else
    {
      heap_Free(*(void **)(a2 + 8), (uint64_t)v7);
    }
  }
  return v3;
}

uint64_t LoqXMLDeleteParser(void *a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if ((uint64_t (*)(void *, uint64_t))*a1 == LoqXMLIniParser)
  {
    crnc3rdprtyrnm_XML_ParserFree(a1[1]);
    *a1 = 0;
    a1[1] = 0;
    heap_Free(*(void **)(a1[66] + 8), (uint64_t)a1);
    return 0;
  }
  return result;
}

uint64_t LoqXMLSetEncoding(uint64_t a1, char *a2)
{
  uint64_t v2 = 2375032839;
  if (a1)
  {
    if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
    {
      cstdlib_strcpy((char *)(a1 + 16), a2);
      if (crnc3rdprtyrnm_XML_SetEncoding(*(void *)(a1 + 8), (unsigned __int8 *)a2)) {
        return 0;
      }
      else {
        return 2375032839;
      }
    }
    else
    {
      return 2375032834;
    }
  }
  return v2;
}

uint64_t LoqXMLGetEncoding(uint64_t a1, char *__dst)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    cstdlib_strcpy(__dst, (const char *)(a1 + 16));
    return 0;
  }
  return result;
}

uint64_t LoqXMLSetCallbacks(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    crnc3rdprtyrnm_XML_SetUserData(*(uint64_t **)(a1 + 8), a5);
    crnc3rdprtyrnm_XML_SetElementHandler(*(void *)(a1 + 8), a2, a3);
    crnc3rdprtyrnm_XML_SetCharacterDataHandler(*(void *)(a1 + 8), a4);
    return 0;
  }
  return result;
}

uint64_t LoqXMLSetUnknownEncodingHandler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    crnc3rdprtyrnm_XML_SetUnknownEncodingHandler(*(void *)(a1 + 8), a2, a3);
    return 0;
  }
  return result;
}

double LoqXMLGetEncodingMap(uint64_t (**a1)(void *a1, uint64_t a2), uint64_t a2, void *a3)
{
  if (a1 && *a1 == LoqXMLIniParser)
  {
    if (a3) {
      *a3 = a2;
    }
    *(void *)(a2 + 1040) = 0;
    double result = 0.0;
    *(_OWORD *)(a2 + 1024) = 0u;
  }
  return result;
}

uint64_t LoqXMLParse(uint64_t a1, const void *a2, unsigned int a3, int a4, _DWORD *a5)
{
  if (a5) {
    *a5 = 0;
  }
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    int v8 = crnc3rdprtyrnm_XML_Parse(*(void *)(a1 + 8), a2, a3, a4);
    if (v8) {
      uint64_t result = 0;
    }
    else {
      uint64_t result = 2375040625;
    }
    if (a5)
    {
      if (v8)
      {
        uint64_t result = 0;
        *a5 = 1;
      }
    }
  }
  return result;
}

uint64_t LoqXMLGetError(uint64_t a1, _DWORD *a2, unsigned int *a3)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    if (a2) {
      *a2 = crnc3rdprtyrnm_XML_GetErrorCode(*(void *)(a1 + 8));
    }
    if (a3)
    {
      unsigned int CurrentLineNumber = crnc3rdprtyrnm_XML_GetCurrentLineNumber(*(void **)(a1 + 8));
      uint64_t result = 0;
      *a3 = CurrentLineNumber;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t LoqXMLGetCurrentLineNumber(uint64_t a1, unsigned int *a2)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    if (a2)
    {
      unsigned int CurrentLineNumber = crnc3rdprtyrnm_XML_GetCurrentLineNumber(*(void **)(a1 + 8));
      uint64_t result = 0;
      *a2 = CurrentLineNumber;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t LoqXMLSetUserData(uint64_t a1, uint64_t a2)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    crnc3rdprtyrnm_XML_SetUserData(*(uint64_t **)(a1 + 8), a2);
    return 0;
  }
  return result;
}

uint64_t LoqXMLGetUserData(uint64_t a1, void *a2)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    uint64_t result = 0;
    if (a2) {
      *a2 = **(void **)(a1 + 8);
    }
  }
  return result;
}

uint64_t LoqXMLReset(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    if (crnc3rdprtyrnm_XML_ParserReset(*(void *)(a1 + 8), 0)) {
      return 0;
    }
    else {
      return 2375040625;
    }
  }
  return result;
}

uint64_t LoqXMLGetByteOffset(uint64_t a1, _DWORD *a2)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    CurrentByteunsigned int Index = crnc3rdprtyrnm_XML_GetCurrentByteIndex(*(void **)(a1 + 8));
    if (a2)
    {
      int v6 = CurrentByteIndex;
      uint64_t result = 0;
      *a2 = v6;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t LoqXMLSetXmlDeclHandler(uint64_t a1, uint64_t a2)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    crnc3rdprtyrnm_XML_SetXmlDeclHandler(*(void *)(a1 + 8), a2);
    return 0;
  }
  return result;
}

uint64_t LoqXMLSetNamespaceCallbacks(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    crnc3rdprtyrnm_XML_SetNamespaceDeclHandler(*(void *)(a1 + 8), a2, a3);
    return 0;
  }
  return result;
}

uint64_t builtin_Alloc_0(uint64_t a1, unsigned int a2)
{
  return heap_Alloc(a1, a2);
}

uint64_t builtin_Realloc_0(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  return heap_Realloc(a1, a2, a3);
}

uint64_t ELQXMLIniController(uint64_t a1, const char *a2, const char *a3, uint64_t a4)
{
  uint64_t v8 = heap_Alloc(*(void *)(a1 + 8), 1216);
  uint64_t v9 = v8;
  if (v8)
  {
    *(void *)(v8 + 1200) = a1;
    *(void *)(v8 + 1208) = a4;
    *(_DWORD *)(v8 + 1196) = 0;
    *(void *)(v8 + 8) = 0;
    *(_OWORD *)(v8 + 1040) = 0u;
    *(_OWORD *)(v8 + 1056) = 0u;
    *(_OWORD *)(v8 + 1072) = 0u;
    *(_OWORD *)(v8 + 1088) = 0u;
    *(void *)(v8 + 1104) = 0;
    *(void *)(v8 + 1120) = 0;
    *(void *)(v8 + 1136) = 0;
    *(void *)(v8 + 1128) = 0;
    *(_OWORD *)(v8 + 1152) = 0u;
    *(_OWORD *)(v8 + 1168) = 0u;
    *(_OWORD *)(v8 + 1177) = 0u;
    cstdlib_strcpy((char *)(v8 + 16), a2);
    cstdlib_strcpy((char *)(v9 + 528), a3);
    *(void *)uint64_t v9 = ELQXMLIniController;
  }
  return v9;
}

uint64_t (**ELQXMLDeleteController(uint64_t (**result)(uint64_t a1, const char *a2, const char *a3, uint64_t a4)))(uint64_t a1, const char *a2, const char *a3, uint64_t a4)
{
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    if (*result == ELQXMLIniController)
    {
      critsec_Enter(result[151]);
      uint64_t v2 = *(uint64_t (***)(uint64_t, uint64_t *, uint64_t, char *, char *, const char *, uint64_t, uint64_t))(v1 + 8);
      if (v2) {
        ELQPluginDelete(v2);
      }
      critsec_Leave(*(void **)(v1 + 1208));
      *(void *)uint64_t v1 = 0;
      uint64_t v3 = *(void **)(*(void *)(v1 + 1200) + 8);
      return (uint64_t (**)(uint64_t, const char *, const char *, uint64_t))heap_Free(v3, v1);
    }
  }
  return result;
}

uint64_t ELQXMLSetNamespaceSeparator(uint64_t a1, char a2)
{
  uint64_t result = 2375032834;
  if (a1)
  {
    if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))a1 == ELQXMLIniController)
    {
      uint64_t result = 0;
      *(unsigned char *)(a1 + 1192) = a2;
    }
  }
  return result;
}

uint64_t ELQXMLGetNamespaceSeparator(uint64_t a1, unsigned char *a2)
{
  uint64_t result = 2375032834;
  if (a1)
  {
    if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))a1 == ELQXMLIniController)
    {
      uint64_t result = 0;
      *a2 = *(unsigned char *)(a1 + 1192);
    }
  }
  return result;
}

uint64_t ELQXMLEnableNamespaceSupport(uint64_t a1, int a2)
{
  uint64_t result = 2375032834;
  if (a1)
  {
    if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))a1 == ELQXMLIniController)
    {
      uint64_t result = 0;
      *(_DWORD *)(a1 + 1196) = a2;
    }
  }
  return result;
}

void *XMLIniParser(uint64_t a1, uint64_t a2)
{
  if (!a1 || *(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))a1 != ELQXMLIniController) {
    return 0;
  }
  int v6 = (void *)heap_Alloc(*(void *)(*(void *)(a1 + 1200) + 8), 32);
  uint64_t v3 = v6;
  if (!v6) {
    return v3;
  }
  *int v6 = 0;
  critsec_Enter(*(void **)(a1 + 1208));
  uint64_t v7 = (uint64_t (***)(uint64_t, uint64_t *, uint64_t, char *, char *, const char *, uint64_t, uint64_t))(a1 + 8);
  if (!*(void *)(a1 + 8))
  {
    if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))a1 != ELQXMLIniController
      || ELQPluginIni(*(void *)(a1 + 1200), (uint64_t *)(a1 + 8), 0, (char *)(a1 + 16), (char *)(a1 + 528), (const char *)(a1 + 16), 0, 0))
    {
      goto LABEL_14;
    }
    ELQPluginLoadUtilSymbols(*(void *)(a1 + 8), *(void *)(a1 + 1184));
    if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLIniParser", (uint64_t *)(a1 + 1040)))
    {
LABEL_13:
      ELQPluginDelete(*v7);
LABEL_14:
      heap_Free(*(void **)(*(void *)(a1 + 1200) + 8), (uint64_t)v3);
      critsec_Leave(*(void **)(a1 + 1208));
      return 0;
    }
    if (*(void *)(a1 + 1040))
    {
      if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLIniParserNS", (uint64_t *)(a1 + 1048))) {
        goto LABEL_13;
      }
      if (*(void *)(a1 + 1048))
      {
        if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLDeleteParser", (uint64_t *)(a1 + 1056))) {
          goto LABEL_13;
        }
        if (*(void *)(a1 + 1056))
        {
          if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLSetEncoding", (uint64_t *)(a1 + 1064))) {
            goto LABEL_13;
          }
          if (*(void *)(a1 + 1064))
          {
            if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLGetEncoding", (uint64_t *)(a1 + 1072)))goto LABEL_13; {
            if (*(void *)(a1 + 1072))
            }
            {
              if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLSetCallbacks", (uint64_t *)(a1 + 1080)))goto LABEL_13; {
              if (*(void *)(a1 + 1080))
              }
              {
                if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLSetNamespaceCallbacks", (uint64_t *)(a1 + 1088)))goto LABEL_13; {
                if (*(void *)(a1 + 1088))
                }
                {
                  if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLGetErrorString", (uint64_t *)(a1 + 1120)))goto LABEL_13; {
                  if (*(void *)(a1 + 1120))
                  }
                  {
                    if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLGetError", (uint64_t *)(a1 + 1104)))goto LABEL_13; {
                    if (*(void *)(a1 + 1104))
                    }
                    {
                      if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLGetCurrentLineNumber", (uint64_t *)(a1 + 1112)))goto LABEL_13; {
                      if (*(void *)(a1 + 1112))
                      }
                      {
                        if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLParse", (uint64_t *)(a1 + 1096)))goto LABEL_13; {
                        if (*(void *)(a1 + 1096))
                        }
                        {
                          if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLSetUEHandler", (uint64_t *)(a1 + 1128)))goto LABEL_13; {
                          if (*(void *)(a1 + 1128))
                          }
                          {
                            if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLGetEncodingMap", (uint64_t *)(a1 + 1136)))goto LABEL_13; {
                            if (*(void *)(a1 + 1136))
                            }
                            {
                              if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLSetUserData", (uint64_t *)(a1 + 1144)))goto LABEL_13; {
                              if (*(void *)(a1 + 1144))
                              }
                              {
                                if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLGetUserData", (uint64_t *)(a1 + 1152)))goto LABEL_13; {
                                if (*(void *)(a1 + 1152))
                                }
                                {
                                  if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLReset", (uint64_t *)(a1 + 1160)))goto LABEL_13; {
                                  if (*(void *)(a1 + 1160))
                                  }
                                  {
                                    if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLGetByteOffset", (uint64_t *)(a1 + 1168)))goto LABEL_13; {
                                    if (*(void *)(a1 + 1168))
                                    }
                                    {
                                      if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLSetXmlDeclHandler", (uint64_t *)(a1 + 1176)))goto LABEL_13; {
                                      if (*(void *)(a1 + 1176))
                                      }
                                        goto LABEL_7;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    ELQPluginDelete(*v7);
  }
LABEL_7:
  v3[2] = a1;
  critsec_Leave(*(void **)(a1 + 1208));
  uint64_t v8 = v3 + 1;
  uint64_t v9 = *(void *)(a1 + 1200);
  if (!*(_DWORD *)(a1 + 1196))
  {
    if ((*(unsigned int (**)(void *, uint64_t))(a1 + 1040))(v8, v9)) {
      goto LABEL_9;
    }
LABEL_16:
    v3[3] = a2;
    *uint64_t v3 = ELQXMLIniParser;
    return v3;
  }
  if (!(*(unsigned int (**)(void *, uint64_t, void))(a1 + 1048))(v8, v9, *(char *)(a1 + 1192)))goto LABEL_16; {
LABEL_9:
  }
  heap_Free(*(void **)(*(void *)(a1 + 1200) + 8), (uint64_t)v3);
  return 0;
}

void *ELQXMLIniParserNS(uint64_t a1, uint64_t a2, char a3)
{
  if (!a1 || *(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))a1 != ELQXMLIniController) {
    return 0;
  }
  *(unsigned char *)(a1 + 1192) = a3;
  *(_DWORD *)(a1 + 1196) = 1;
  return XMLIniParser(a1, a2);
}

void *ELQXMLDeleteParser(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    if ((uint64_t (*)())*result == ELQXMLIniParser)
    {
      uint64_t v2 = result[2];
      if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v2 == ELQXMLIniController)
      {
        (*(void (**)(void))(v2 + 1056))(result[1]);
        uint64_t v2 = v1[2];
      }
      void *v1 = 0;
      uint64_t v3 = *(void **)(*(void *)(v2 + 1200) + 8);
      return heap_Free(v3, (uint64_t)v1);
    }
  }
  return result;
}

uint64_t ELQXMLSetEncoding(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1064))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLGetEncoding(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1072))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLSetCallbacks(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1080))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLSetNamespaceCallbacks(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1088))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLParse(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1096))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLGetCurrentLineNumber(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)())a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1112))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLGetError(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1104))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLGetErrorString(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v3 = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    if (v4)
    {
      if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v4 == ELQXMLIniController)
      {
        int v6 = (const char *)(*(uint64_t (**)(uint64_t))(v4 + 1120))(a2);
        *a3 = 0;
        if (v6)
        {
          cstdlib_strcpy(a3, v6);
          return 0;
        }
        else
        {
          return 2375032839;
        }
      }
    }
  }
  return v3;
}

uint64_t ELQXMLGetEncodingFromHeader(uint64_t a1, unsigned char *a2, unsigned __int16 *a3, unint64_t a4, int a5)
{
  uint64_t v7 = a3;
  uint64_t v40 = *MEMORY[0x263EF8340];
  uint64_t result = 2375032839;
  if ((!a1 || *(uint64_t (**)(void, void))a1 == ELQXMLIniParser) && a2 && a3)
  {
    *a2 = 0;
    if (a4 >= 0xA)
    {
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      unsigned int v12 = 0;
      do
      {
        BOOL v13 = (char *)v7 + v10;
        unsigned int v14 = *((unsigned __int8 *)v7 + v10);
        BOOL v15 = v14 > 0xD;
        int v16 = (1 << v14) & 0x2401;
        if (!v15 && v16 != 0) {
          break;
        }
        size_t v18 = cstdlib_strlen("encoding");
        if (!cstdlib_strncmp(v13, "encoding", v18)) {
          uint64_t v11 = v13;
        }
        uint64_t v10 = v12 + 1;
        if (*v13 == 63 && *((unsigned char *)v7 + v10) == 62)
        {
          if (!v11 || v11 >= v13) {
            break;
          }
          while (1)
          {
            int v28 = *(unsigned __int8 *)v11;
            if (v28 == 34 || v28 == 39) {
              break;
            }
            if (++v11 == (char *)v7 + v12) {
              goto LABEL_17;
            }
          }
          int v30 = (unsigned __int8 *)(v11 + 1);
          if (v11 + 1 >= v13)
          {
            int v37 = 0;
            uint64_t v32 = a2;
          }
          else
          {
            uint64_t v31 = 1;
            uint64_t v32 = a2;
            while (1)
            {
              int v33 = v11[v31];
              if (v33 == 34 || v33 == 39) {
                break;
              }
              a2[(v31++ - 1)] = v33;
              int v30 = (unsigned __int8 *)&v11[v31];
              if (&v11[v31] >= v13) {
                goto LABEL_67;
              }
            }
            int v30 = (unsigned __int8 *)&v11[v31];
LABEL_67:
            int v37 = v31 - 1;
          }
          if (v30 != (unsigned __int8 *)v13)
          {
            v32[v37] = 0;
            break;
          }
          return 2375040625;
        }
        ++v12;
      }
      while (v10 + 9 < a4);
    }
LABEL_17:
    uint64_t result = 0;
    if (a5 != 65001 && !*a2)
    {
      if (a1) {
        uint64_t v19 = *(void *)(*(void *)(*(void *)(a1 + 16) + 1200) + 8);
      }
      else {
        uint64_t v19 = 0;
      }
      TxtEncodingConvert(v19, 65001, 1200, "encoding", 0xFFFFFFFFFFFFFFFFLL, (uint64_t)v39, 0x50uLL, 0);
      unsigned int v20 = 0;
      unint64_t v21 = a4 >> 1;
      BOOL v15 = a4 >> 1 > 9;
      uint64_t v22 = 9;
      if (v15) {
        uint64_t v23 = v21;
      }
      else {
        uint64_t v23 = 9;
      }
      while (1)
      {
        if (v23 == v22) {
          return 0;
        }
        unsigned int v24 = *v7;
        BOOL v15 = v24 > 0xD;
        int v25 = (1 << v24) & 0x2401;
        if (!v15 && v25 != 0) {
          return 0;
        }
        size_t v27 = cstdlib_strlen("encoding");
        if (!ELQwcsncmp(v7, v39, v27)) {
          unsigned int v20 = v7;
        }
        if (*v7 == 63 && v7[1] == 62) {
          break;
        }
        uint64_t result = 0;
        ++v22;
        ++v7;
        if (v22 == 265) {
          return result;
        }
      }
      uint64_t result = 0;
      if (v20)
      {
        while (v20 < v7)
        {
          int v29 = *v20;
          if (v29 == 34 || v29 == 39)
          {
            int v34 = v20 + 1;
            if (v20 + 1 >= v7)
            {
              int v35 = 0;
            }
            else
            {
              int v35 = 0;
              do
              {
                int v36 = *v34;
                if (v36 == 34) {
                  break;
                }
                if (v36 == 39) {
                  break;
                }
                a2[v35++] = v36;
                ++v34;
              }
              while (v34 < v7);
            }
            if (v7 != v34)
            {
              uint64_t result = 0;
              a2[v35] = 0;
              return result;
            }
            return 2375040625;
          }
          uint64_t result = 0;
          ++v20;
        }
      }
    }
  }
  return result;
}

uint64_t ELQXMLSetUnknownEncodingHandler(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)())a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1128))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLGetEncodingMap(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1136))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLUnknownEncodingHandler(uint64_t result, unsigned __int8 *a2, uint64_t a3)
{
  if (result)
  {
    if (*(uint64_t (**)())result == ELQXMLIniParser
      && (uint64_t v3 = *(void *)(result + 16)) != 0
      && (uint64_t v10 = 0, *(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v3 == ELQXMLIniController))
    {
      int v5 = (*(uint64_t (**)(void, uint64_t, uint64_t *))(v3 + 1136))(*(void *)(result + 8), a3, &v10);
      uint64_t result = 0;
      if (a2)
      {
        if (!v5)
        {
          int Id = TxtEncodingGetId(a2);
          uint64_t result = (uint64_t)TxtEncodingGetMap(Id, 1);
          if (result)
          {
            uint64_t v7 = (_DWORD *)result;
            for (uint64_t i = 0; i != 255; ++i)
            {
              int v9 = TxtEncodingCharToWChar(i, v7);
              *(_DWORD *)(v10 + 4 * i) = v9;
              uint64_t result = 1;
            }
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t ELQXMLSetUserData(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1144))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLGetUserData(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1152))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLReset(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1160))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLGetByteOffset(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1168))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

void *ELQXMLValidateBuffer(uint64_t a1, uint64_t a2, int a3, unsigned __int16 *a4, unint64_t a5)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  uint64_t result = XMLIniParser(a1, a2);
  if (result)
  {
    int v9 = result;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    *(_OWORD *)char __dst = 0u;
    long long v17 = 0u;
    unsigned int v15 = 0;
    if (!ELQXMLGetEncodingFromHeader((uint64_t)result, __dst, a4, a5, a3))
    {
      if (!__dst[0])
      {
        Name = TxtEncodingGetName(a3);
        if (!Name || !*Name) {
          goto LABEL_21;
        }
        cstdlib_strcpy(__dst, Name);
      }
      if ((uint64_t (*)(void, void))*v9 == ELQXMLIniParser)
      {
        uint64_t v10 = v9[2];
        if (v10)
        {
          if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v10 == ELQXMLIniController
            && !(*(unsigned int (**)(void, void, void *))(v10 + 1128))(v9[1], ELQXMLUnknownEncodingHandler, v9)&& (uint64_t (*)(void, void))*v9 == ELQXMLIniParser)
          {
            uint64_t v11 = v9[2];
            if (v11)
            {
              if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v11 == ELQXMLIniController
                && !(*(unsigned int (**)(void, char *))(v11 + 1064))(v9[1], __dst)
                && (uint64_t (*)(void, void))*v9 == ELQXMLIniParser)
              {
                uint64_t v12 = v9[2];
                if (v12)
                {
                  if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v12 == ELQXMLIniController)
                  {
                    int v13 = (*(uint64_t (**)(void, unsigned __int16 *, unint64_t, uint64_t, unsigned int *))(v12 + 1096))(v9[1], a4, a5, 1, &v15);
                    ELQXMLDeleteParser(v9);
                    if (v13) {
                      return 0;
                    }
                    else {
                      return (void *)v15;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_21:
    ELQXMLDeleteParser(v9);
    return 0;
  }
  return result;
}

uint64_t ELQXMLSetXmlDeclHandler(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(uint64_t (**)(uint64_t, const char *, const char *, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1176))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLGetControllerFromParser(uint64_t result)
{
  if (result)
  {
    if (*(uint64_t (**)())result == ELQXMLIniParser) {
      return *(void *)(result + 16);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t Wav2PCM(_WORD *a1, uint64_t a2, const char *a3, uint64_t a4, int a5, char *a6, uint64_t *a7, unsigned int *a8)
{
  v77[199] = *MEMORY[0x263EF8340];
  long long v73 = 0;
  uint64_t v74 = 0;
  char v72 = 0;
  unsigned int v70 = 0;
  *(_DWORD *)long long __s1 = 0;
  __src = 0;
  if (!a3) {
    return 2269126663;
  }
  uint64_t result = 2269126663;
  if (a8)
  {
    if (a7)
    {
      if (a6)
      {
        if (a5)
        {
          if (a4)
          {
            if (*a3)
            {
              *a6 = 0;
              *a7 = 0;
              *a8 = 0;
              uint64_t result = InitRsrcFunction(a1, a2, &v74);
              if ((result & 0x80000000) == 0)
              {
                uint64_t result = ssftriff_reader_ObjOpenEx(a1, a2, 4, a3, a4, a5, "WAVE", 0, (uint64_t *)&v73);
                if ((result & 0x80000000) == 0)
                {
                  unsigned int v67 = 0;
                  unsigned int v68 = 0;
                  int v16 = "fmt ";
                  while (1)
                  {
                    unsigned int v17 = ssftriff_reader_OpenChunk((uint64_t)v73, (__int32 *)__s1, &v70, &__src);
                    if ((v17 & 0x80000000) != 0)
                    {
LABEL_35:
                      if ((v17 & 0x1FFF) == 0x14) {
                        uint64_t v54 = 0;
                      }
                      else {
                        uint64_t v54 = v17;
                      }
                      if (!*a6)
                      {
                        log_OutPublic(*(void *)(v74 + 32), (uint64_t)"AUDIOFETCH", 149, (uint64_t)"%s%s", v21, v22, v23, v24, "url");
                        goto LABEL_56;
                      }
                      if (v67 != 1)
                      {
                        if (!v67)
                        {
                          log_OutPublic(*(void *)(v74 + 32), (uint64_t)"AUDIOFETCH", 150, (uint64_t)"%s%s", v21, v22, v23, v24, "url");
                          goto LABEL_56;
                        }
                        log_OutText(*(void *)(v74 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"RIFF WAVE URL %s has %u audio chunks, will be concatenated", v22, v23, v24, (uint64_t)a3);
                      }
                      if (v68)
                      {
                        uint64_t v55 = heap_Alloc(*(void *)(v74 + 8), v68);
                        *a7 = v55;
                        if (!v55)
                        {
                          log_OutPublic(*(void *)(v74 + 32), (uint64_t)"AUDIOFETCH", 151, (uint64_t)"%s%lu", v56, v57, v58, v59, "sizeBytes");
                          uint64_t v65 = 2269126666;
                          goto LABEL_57;
                        }
                        long long v60 = (char *)v55;
                        uint64_t v61 = v67;
                        long long v62 = v77;
                        do
                        {
                          long long v63 = (const void *)*((void *)v62 - 1);
                          unsigned int v64 = *v62;
                          v62 += 4;
                          cstdlib_memcpy(v60, v63, v64);
                          v60 += v64;
                          --v61;
                        }
                        while (v61);
                      }
                      *a8 = v68;
                      uint64_t v65 = v54;
                      goto LABEL_57;
                    }
                    if (cstdlib_strcmp(__s1, v16))
                    {
                      if (cstdlib_strcmp(__s1, "data"))
                      {
                        log_OutText(*(void *)(v74 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Ignoring RIFF WAVE chunk %s in URL %s (%lu bytes)", v29, v30, v31, (uint64_t)__s1);
                      }
                      else
                      {
                        long long v50 = &__s2[16 * v67 + 32];
                        *(void *)long long v50 = __src;
                        unsigned int v51 = v70;
                        *((_DWORD *)v50 + 2) = v70;
                        ++v67;
                        v68 += v51;
                        log_OutText(*(void *)(v74 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"RIFF WAV %s: audio chunk %u, %lu bytes", v29, v30, v31, (uint64_t)a3);
                      }
                      goto LABEL_34;
                    }
                    if (v70 <= 0xF)
                    {
                      log_OutPublic(*(void *)(v74 + 32), (uint64_t)"AUDIOFETCH", 143, (uint64_t)"%s%s", v25, v26, v27, v28, "url");
                      goto LABEL_56;
                    }
                    long long v32 = v16;
                    LOWORD(__dst) = 0;
                    cstdlib_memcpy(&__dst, __src, 2uLL);
                    int v33 = (__int16)__dst;
                    LOWORD(__dst) = 0;
                    cstdlib_memcpy(&__dst, (char *)__src + 2, 2uLL);
                    uint64_t v34 = (__int16)__dst;
                    unsigned int __dst = 0;
                    cstdlib_memcpy(&__dst, (char *)__src + 4, 4uLL);
                    unsigned int v35 = __dst;
                    unsigned int __dst = 0;
                    cstdlib_memcpy(&__dst, (char *)__src + 8, 4uLL);
                    unsigned int v36 = __dst;
                    LOWORD(__dst) = 0;
                    cstdlib_memcpy(&__dst, (char *)__src + 12, 2uLL);
                    int v37 = (__int16)__dst;
                    LOWORD(__dst) = 0;
                    cstdlib_memcpy(&__dst, (char *)__src + 14, 2uLL);
                    unsigned int v38 = (__int16)__dst;
                    log_OutText(*(void *)(v74 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"RIFF WAV %s: format %d, %d channels, %ld HZ, %ld bytes per sec, %d block align, %d bits per sample", v39, v40, v41, (uint64_t)a3);
                    if (v34 != 1)
                    {
                      log_OutPublic(*(void *)(v74 + 32), (uint64_t)"AUDIOFETCH", 144, (uint64_t)"%s%s%s%d", v42, v43, v44, v45, "url");
                      goto LABEL_56;
                    }
                    if (v33 == 7) {
                      break;
                    }
                    if (v33 == 6)
                    {
                      if (v35 != 8000 || v36 != 8000 || v37 != 1 || v38 != 8)
                      {
                        log_OutPublic(*(void *)(v74 + 32), (uint64_t)"AUDIOFETCH", 146, (uint64_t)"%s%s%s%s%s%ld%s%ld%s%d%s%d", v42, v43, v44, v45, "url");
LABEL_56:
                        uint64_t v65 = 2269126660;
LABEL_57:
                        if (v73) {
                          ssftriff_reader_ObjClose(v73, v18, v19, v20, v21, v22, v23, v24);
                        }
                        return v65;
                      }
                      long long v52 = a6;
                      long long v53 = "audio/x-alaw-basic";
                      goto LABEL_33;
                    }
                    if (v33 != 1)
                    {
                      log_OutPublic(*(void *)(v74 + 32), (uint64_t)"AUDIOFETCH", 148, (uint64_t)"%s%s%s%d", v42, v43, v44, v45, "url");
                      goto LABEL_56;
                    }
                    cstdlib_strcpy(a6, "audio/L");
                    LH_itoa(v38, __s2, 0xAu);
                    cstdlib_strcat(a6, __s2);
                    cstdlib_strcat(a6, ";endian=little;rate=");
                    LH_itoa(v35, __s2, 0xAu);
                    cstdlib_strcat(a6, __s2);
                    int v16 = v32;
                    if (v38 != 16)
                    {
                      log_OutPublic(*(void *)(v74 + 32), (uint64_t)"AUDIOFETCH", 145, (uint64_t)"%s%s%s%s%s%d", v46, v47, v48, v49, "url");
                      goto LABEL_56;
                    }
LABEL_34:
                    unsigned int v17 = ssftriff_reader_CloseChunk((uint64_t)v73);
                    if ((v17 & 0x80000000) != 0) {
                      goto LABEL_35;
                    }
                  }
                  if (v35 != 8000 || v36 != 8000 || v37 != 1 || v38 != 8)
                  {
                    log_OutPublic(*(void *)(v74 + 32), (uint64_t)"AUDIOFETCH", 147, (uint64_t)"%s%s%s%s%s%ld%s%ld%s%d%s%d", v42, v43, v44, v45, "url");
                    goto LABEL_56;
                  }
                  long long v52 = a6;
                  long long v53 = "audio/basic";
LABEL_33:
                  cstdlib_strcpy(v52, v53);
                  int v16 = v32;
                  goto LABEL_34;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t Au2PCM(_WORD *a1, int a2, unsigned char *a3, unsigned int *a4, unsigned int a5, char *a6, void *a7, unsigned int *a8, int a9)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  uint64_t v43 = 0;
  if (!a3) {
    return 2269126663;
  }
  uint64_t result = 2269126663;
  if (!a8) {
    return result;
  }
  if (!a7) {
    return result;
  }
  if (!a6) {
    return result;
  }
  if (!a5) {
    return result;
  }
  if (!a4) {
    return result;
  }
  if (!*a3) {
    return result;
  }
  *a6 = 0;
  *a7 = 0;
  *a8 = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v43);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  if (cstdlib_memcmp(a4, ".snd", 4uLL))
  {
    unsigned int v21 = 0;
    if (a9) {
      unsigned int v22 = 27;
    }
    else {
      unsigned int v22 = 1;
    }
    unsigned int v23 = 1;
    unsigned int v24 = 8000;
    unsigned int v25 = a5;
  }
  else
  {
    if (a5 <= 0xBF)
    {
      log_OutPublic(*(void *)(v43 + 32), (uint64_t)"AUDIOFETCH", 101, (uint64_t)"%s%s", v17, v18, v19, v20, "url");
      return 2269126660;
    }
    unsigned int v21 = bswap32(a4[1]);
    unsigned int v25 = bswap32(a4[2]);
    unsigned int v22 = bswap32(a4[3]);
    unsigned int v24 = bswap32(a4[4]);
    unsigned int v23 = bswap32(a4[5]);
  }
  unsigned int v41 = v25;
  unsigned int v42 = v21;
  log_OutText(*(void *)(v43 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Sun Au %s: encoding %u, %u channels, %u HZ, %u data offset, %u data size", v18, v19, v20, (uint64_t)a3);
  if (v23 != 1)
  {
    log_OutPublic(*(void *)(v43 + 32), (uint64_t)"AUDIOFETCH", 102, (uint64_t)"%s%s%s%u", v26, v27, v28, v29, "url");
    return 2269126660;
  }
  switch(v22)
  {
    case 1u:
      if (v24 != 8000)
      {
        log_OutPublic(*(void *)(v43 + 32), (uint64_t)"AUDIOFETCH", 104, (uint64_t)"%s%s%s%s%s%u", v26, v27, v28, v29, "url");
        return 2269126660;
      }
      uint64_t v30 = v43;
      unsigned int v35 = "audio/basic";
      break;
    case 0x1Bu:
      if (v24 != 8000)
      {
        log_OutPublic(*(void *)(v43 + 32), (uint64_t)"AUDIOFETCH", 103, (uint64_t)"%s%s%s%s%s%u", v26, v27, v28, v29, "url");
        return 2269126660;
      }
      uint64_t v30 = v43;
      unsigned int v35 = "audio/x-alaw-basic";
      break;
    case 3u:
      uint64_t v30 = v43;
      cstdlib_strcpy(a6, "audio/L16;endian=big;rate=");
      LH_itoa(v24, __s2, 0xAu);
      cstdlib_strcat(a6, __s2);
      goto LABEL_31;
    default:
      log_OutPublic(*(void *)(v43 + 32), (uint64_t)"AUDIOFETCH", 105, (uint64_t)"%s%s%s%u", v26, v27, v28, v29, "url");
      return 2269126660;
  }
  cstdlib_strcpy(a6, v35);
LABEL_31:
  if (!v41)
  {
    log_OutPublic(*(void *)(v30 + 32), (uint64_t)"AUDIOFETCH", 106, (uint64_t)"%s%s", v31, v32, v33, v34, "url");
    return 2269126660;
  }
  if (v41 + v42 > a5)
  {
    log_OutPublic(*(void *)(v30 + 32), (uint64_t)"AUDIOFETCH", 107, (uint64_t)"%s%s", v31, v32, v33, v34, "url");
    return 2269126660;
  }
  unsigned int v36 = (void *)heap_Alloc(*(void *)(v43 + 8), v41);
  *a7 = v36;
  if (v36)
  {
    cstdlib_memcpy(v36, (char *)a4 + v42, v41);
    uint64_t result = 0;
    *a8 = v41;
  }
  else
  {
    log_OutPublic(*(void *)(v43 + 32), (uint64_t)"AUDIOFETCH", 108, (uint64_t)"%s%lu", v37, v38, v39, v40, "sizeBytes");
    return 2269126666;
  }
  return result;
}

uint64_t audiofetch_LoadAPDB(uint64_t a1, int a2, const char *a3)
{
  uint64_t v22 = 0;
  uint64_t v3 = 2269126663;
  if (a3)
  {
    if (*a3)
    {
      uint64_t v3 = safeh_HandleCheck(a1, a2, 702, 56);
      if ((v3 & 0x80000000) == 0 && !cstdlib_strncmp(a3, "x-vocalizer-speechbase://", 0x19uLL))
      {
        int v6 = a3 + 25;
        long long v25 = 0u;
        long long v26 = 0u;
        long long __b = 0u;
        long long v24 = 0u;
        uint64_t v7 = *(void *)(*(void *)(a1 + 16) + 8);
        int v8 = cstdlib_strlen(v6);
        int v9 = (char *)heap_Alloc(v7, (v8 + 1));
        if (v9)
        {
          uint64_t v14 = (uint64_t)v9;
          cstdlib_strcpy(v9, v6);
          uint64_t v3 = ssftmap_Find(*(void *)(a1 + 48), v14, &v22);
          if ((v3 & 0x80000000) != 0)
          {
            cstdlib_memset(&__b, 0, 0x40uLL);
            long long v24 = *(_OWORD *)a1;
            long long v25 = *(_OWORD *)(a1 + 16);
            LOWORD(__b) = GetEngineFreq(a1);
            *((void *)&__b + 1) = v14;
            uint64_t v15 = ssftmap_Insert(*(void *)(a1 + 48), v14, (uint64_t)&__b);
            if ((v15 & 0x80000000) != 0)
            {
              uint64_t v3 = v15;
              log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 155, (uint64_t)"%s%s", v16, v17, v18, v19, "speechbase");
            }
            else
            {
              uint64_t v3 = ssftmap_Find(*(void *)(a1 + 48), v14, &v22);
            }
          }
          heap_Free(*(void **)(*(void *)(a1 + 16) + 8), v14);
        }
        else
        {
          log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 100, 0, v10, v11, v12, v13, v21);
          return 2269126666;
        }
      }
    }
  }
  return v3;
}

uint64_t GetEngineFreq(uint64_t a1)
{
  unsigned int v4 = 0;
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 40);
  if (!v1 || (paramc_ParamGetUInt(v1, (uint64_t)"frequencyhz", &v4) & 0x80000000) != 0) {
    return 0;
  }
  else {
    return (unsigned __int16)v4;
  }
}

uint64_t audiofetch_ReleaseAPDB(uint64_t a1, int a2, const char *a3)
{
  uint64_t v13 = 0;
  uint64_t v5 = safeh_HandleCheck(a1, a2, 702, 56);
  if ((v5 & 0x80000000) == 0 && !cstdlib_strncmp(a3, "x-vocalizer-speechbase://", 0x19uLL))
  {
    uint64_t v6 = ssftmap_IteratorOpen(*(void *)(a1 + 48), 0, 0, (uint64_t)&v13);
    if ((v6 & 0x80000000) != 0) {
      return v6;
    }
    uint64_t v11 = 0;
    __s2 = 0;
    uint64_t v7 = a3 + 25;
    while (1)
    {
      while (1)
      {
        int v8 = ssftmap_IteratorNext(v13, &__s2, &v11);
        if (v8 < 0)
        {
LABEL_12:
          int v9 = ssftmap_IteratorClose((uint64_t)v13);
          return v9 & (v9 >> 31);
        }
        if (!v8) {
          break;
        }
LABEL_9:
        if (v8 < 0) {
          goto LABEL_12;
        }
      }
      if (cstdlib_strcmp(v7, __s2))
      {
        int v8 = 0;
        goto LABEL_9;
      }
      if ((ssftmap_IteratorRemove(v13) & 0x80000000) != 0) {
        goto LABEL_12;
      }
    }
  }
  return v5;
}

uint64_t audiofetch_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2269126657;
  }
  uint64_t result = 0;
  *a2 = &ITFAudioUri;
  return result;
}

uint64_t audiofetch_ClassOpen(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v5 = 0;
  if (!a3) {
    return 2269126663;
  }
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v5);
  if ((result & 0x80000000) == 0)
  {
    *(void *)a3 = v5;
    *(_DWORD *)(a3 + 8) = 701;
  }
  return result;
}

uint64_t audiofetch_ClassClose()
{
  return 0;
}

uint64_t audiofetch_ObjOpen(uint64_t a1, int a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v34 = 0;
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  uint64_t inited = InitRsrcFunction(a3, a4, &v34);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t v11 = 2269126664;
  if ((safeh_HandleCheck(a1, a2, 701, 416) & 0x80000000) == 0)
  {
    log_OutText(*(void *)(v34 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Entering audiofetch_ObjOpen", v12, v13, v14, v31);
    uint64_t v15 = heap_Calloc(*(void **)(v34 + 8), 1, 56);
    if (v15)
    {
      uint64_t v20 = (void *)v15;
      *(void *)uint64_t v15 = a3;
      *(void *)(v15 + 8) = a4;
      uint64_t v21 = v34;
      *(void *)(v15 + 16) = v34;
      *(void *)(v15 + 24) = a1;
      *(_DWORD *)(v15 + 32) = 1;
      uint64_t v22 = *(void **)(v21 + 8);
      long long v31 = xmmword_26D2152A8;
      long long v32 = *(_OWORD *)&off_26D2152B8;
      uint64_t v33 = off_26D2152C8;
      uint64_t v23 = ssftmap_ObjOpen(v22, 0, &v31, v20 + 5);
      uint64_t v28 = v20[2];
      if ((v23 & 0x80000000) != 0)
      {
        uint64_t v11 = v23;
      }
      else
      {
        uint64_t v29 = *(void **)(v28 + 8);
        long long v31 = xmmword_26D2152D0;
        long long v32 = *(_OWORD *)off_26D2152E0;
        uint64_t v33 = off_26D2152F0;
        uint64_t v11 = ssftmap_ObjOpen(v29, 0, &v31, v20 + 6);
        if ((v11 & 0x80000000) == 0)
        {
          *(void *)a5 = v20;
          *(_DWORD *)(a5 + 8) = 702;
LABEL_12:
          log_OutText(*(void *)(v34 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Exiting audiofetch_ObjOpen", v25, v26, v27, v31);
          return v11;
        }
        uint64_t v28 = v20[2];
      }
      log_OutPublic(*(void *)(v28 + 32), (uint64_t)"AUDIOFETCH", 130, 0, v24, v25, v26, v27, v31);
      *(void *)a5 = v20;
      *(_DWORD *)(a5 + 8) = 702;
      audiofetch_ObjClose(v20, *(void *)(a5 + 8));
      *(void *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      goto LABEL_12;
    }
    log_OutPublic(*(void *)(v34 + 32), (uint64_t)"AUDIOFETCH", 100, 0, v16, v17, v18, v19, v31);
    uint64_t v11 = 2269126666;
    goto LABEL_12;
  }
  return v11;
}

uint64_t audiofetch_ObjClose(void *a1, int a2)
{
  uint64_t v6 = safeh_HandleCheck((uint64_t)a1, a2, 702, 56);
  if ((v6 & 0x80000000) == 0)
  {
    log_OutText(*(void *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Entering audiofetch_ObjClose", v3, v4, v5, v13);
    uint64_t v10 = a1[6];
    if (v10) {
      uint64_t v6 = ssftmap_ObjClose(v10);
    }
    uint64_t v11 = a1[5];
    if (v11) {
      uint64_t v6 = ssftmap_ObjClose(v11);
    }
    log_OutText(*(void *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Exiting audiofetch_ObjClose", v7, v8, v9, v14);
    heap_Free(*(void **)(a1[2] + 8), (uint64_t)a1);
  }
  return v6;
}

uint64_t audiofetch_ObjReopen(uint64_t a1, int a2)
{
  unsigned __int16 v21 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v18 = 0;
  uint64_t v3 = safeh_HandleCheck(a1, a2, 702, 56);
  if ((v3 & 0x80000000) != 0) {
    return v3;
  }
  log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Entering audiofetch_ObjReopen", v4, v5, v6, v18);
  int EngineFreq = GetEngineFreq(a1);
  int v8 = ssftmap_IteratorOpen(*(void *)(a1 + 48), 0, 0, (uint64_t)&v20);
  if ((v8 & 0x80000000) == 0)
  {
    while (1)
    {
      int v12 = ssftmap_IteratorNext(v20, &v19, &v18);
      if (v12 < 0) {
        break;
      }
      int v13 = (*(uint64_t (**)(void, unsigned __int16 *))(*(void *)(v18 + 48) + 88))(*(void *)(v18 + 56), &v21);
      if (v13 < 0 || (int v14 = v13, v21 != EngineFreq))
      {
        int v14 = ssftmap_IteratorRemove(v20);
        if (v14 < 0) {
          goto LABEL_12;
        }
      }
      else if (v13 < 0)
      {
        goto LABEL_12;
      }
    }
    int v14 = v12;
LABEL_12:
    int v8 = ssftmap_IteratorClose((uint64_t)v20);
    if (v8 >= 0 || (v14 & 0x1FFF) != 23) {
      int v8 = v14;
    }
  }
  if ((v8 & 0x1FFF) == 0x17) {
    uint64_t v15 = 0;
  }
  else {
    uint64_t v15 = v8;
  }
  log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Exiting audiofetch_ObjReopen", v9, v10, v11, v18);
  return v15;
}

uint64_t audiofetch_Reset(uint64_t a1, int a2)
{
  unsigned int v5 = 0;
  uint64_t result = safeh_HandleCheck(a1, a2, 702, 56);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 16) + 40);
    if (v4)
    {
      uint64_t result = paramc_ParamGetUInt(v4, (uint64_t)"pipelineswitchexecuting", &v5);
      if ((result & 0x80000000) != 0)
      {
        unsigned int v5 = 0;
      }
      else if (v5 == 1)
      {
        return result;
      }
    }
    uint64_t result = ssftmap_Clear(*(void *)(a1 + 40));
    *(_DWORD *)(a1 + 32) = 1;
  }
  return result;
}

uint64_t audiofetch_Fetch(uint64_t a1, int a2, unsigned char *a3, char *a4, uint64_t a5, uint64_t a6, void *a7)
{
  return fetchAudio(a1, a2, a3, a4, a7, 0);
}

uint64_t audiofetch_Release(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t result = safeh_HandleCheck(a1, a2, 702, 56);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v6 = *(void *)(a1 + 40);
    return ssftmap_Remove(v6, a3);
  }
  return result;
}

uint64_t audiofetch_FetchStreamOpen(void *a1, int a2, uint64_t a3, void *a4, _DWORD *a5, _DWORD *a6, uint64_t a7)
{
  uint64_t v67 = 0;
  *a4 = 0;
  *a5 = 0;
  *(void *)a7 = 0;
  *(_DWORD *)(a7 + 8) = 0;
  uint64_t v13 = safeh_HandleCheck((uint64_t)a1, a2, 702, 56);
  if ((v13 & 0x80000000) != 0) {
    return v13;
  }
  uint64_t v14 = ssftmap_Find(a1[5], a3, &v67);
  if ((v14 & 0x80000000) == 0)
  {
    uint64_t v15 = (void *)heap_Calloc(*(void **)(a1[2] + 8), 1, 96);
    uint64_t v20 = a1[2];
    if (!v15)
    {
      log_OutPublic(*(void *)(v20 + 32), (uint64_t)"AUDIOFETCH", 100, 0, v16, v17, v18, v19, v66);
      return 2269126666;
    }
    unsigned __int16 v21 = v15;
    *uint64_t v15 = v20;
    v15[1] = a1;
    uint64_t v22 = v67;
    v15[2] = v67;
    uint64_t v23 = *(void *)(v22 + 40);
    if (v23)
    {
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void, void))(*(void *)(v22 + 32) + 48))(v23, *(unsigned int *)(v22 + 48), *(unsigned int *)(v22 + 16));
      if ((v14 & 0x80000000) != 0) {
        log_OutPublic(*(void *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 157, (uint64_t)"%s%s%s%x", v24, v25, v26, v27, "uri");
      }
    }
    else
    {
      int v28 = *(_DWORD *)(v22 + 76);
      if (v28 != 3)
      {
        uint64_t v29 = 0;
        while (AudioFetchDecoderIndex[v29] != v28)
        {
          v29 += 6;
          if ((v29 * 4) == 96)
          {
            log_OutPublic(*(void *)(v20 + 32), (uint64_t)"AUDIOFETCH", 162, (uint64_t)"%s%s%s%d", v16, v17, v18, v19, "uri");
            uint64_t v14 = 2269126657;
            goto LABEL_19;
          }
        }
        uint64_t v30 = &AudioFetchDecoderIndex[v29];
        uint64_t v31 = brk_InterfaceQuery(*(void *)(v20 + 24));
        if ((v31 & 0x80000000) != 0)
        {
          uint64_t v14 = v31;
          log_OutPublic(*(void *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 160, (uint64_t)"%s%s%s%s%s%x", v32, v33, v34, v35, "decoder");
        }
        else
        {
          uint64_t v14 = (*(uint64_t (**)(void, void, void, void, void, void, void, void *))(v21[3] + 32))(v30[4], 0, *a1, a1[1], 0, 0, 0, v21 + 4);
          if ((v14 & 0x80000000) != 0) {
            log_OutPublic(*(void *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 161, (uint64_t)"%s%s%s%s%s%x", v36, v37, v38, v39, "decoder");
          }
        }
      }
    }
LABEL_19:
    if (*(_DWORD *)(v67 + 80) != 1)
    {
LABEL_36:
      if ((v14 & 0x80000000) == 0)
      {
        uint64_t v63 = v67;
        *a4 = *(void *)(v67 + 24);
        int v64 = *(_DWORD *)(v63 + 16);
        *a5 = v64;
        if (*(_DWORD *)(v63 + 80) == 1) {
          int v64 = *((_DWORD *)v21 + 22);
        }
        *a6 = v64;
        *(void *)a7 = v21;
        *(_DWORD *)(a7 + 8) = 703;
        return v14;
      }
LABEL_41:
      *(void *)a7 = v21;
      *(_DWORD *)(a7 + 8) = 703;
      audiofetch_FetchStreamClose(v21, *(void *)(a7 + 8), 0);
      *(void *)a7 = 0;
      *(_DWORD *)(a7 + 8) = 0;
      return v14;
    }
    unint64_t v40 = *(unsigned int *)(v67 + 16);
    int v68 = 0;
    uint64_t v41 = v21[2];
    unsigned int v42 = *(unsigned __int16 *)(v41 + 68);
    uint64_t v43 = *(unsigned __int16 *)(v41 + 70);
    unsigned int v44 = v42;
    if (*(_WORD *)(v41 + 70))
    {
      unsigned int v45 = *(unsigned __int16 *)(v41 + 70);
      unsigned int v46 = v42;
      do
      {
        unsigned int v44 = v45;
        unsigned int v45 = v46 % v45;
        unsigned int v46 = v44;
      }
      while (v45);
    }
    uint64_t v47 = (void *)v21[8];
    if (v47)
    {
      spxrsmp_resampler_destroy(v47);
      v21[8] = 0;
      uint64_t v48 = v21[2];
      unsigned int v42 = *(unsigned __int16 *)(v48 + 68);
      uint64_t v43 = *(unsigned __int16 *)(v48 + 70);
    }
    uint64_t v49 = spxrsmp_resampler_init(*v21, 1u, v42, v43, 7u, &v68);
    v21[8] = v49;
    if (!v68 && v49)
    {
      uint64_t v54 = v21[2];
      unsigned int v55 = *(unsigned __int16 *)(v54 + 70) / v44;
      *((_WORD *)v21 + 28) = v55;
      unint64_t v56 = *(unsigned __int16 *)(v54 + 68) / v44;
      *((_WORD *)v21 + 29) = v56;
      *((_DWORD *)v21 + 18) = 1;
      unint64_t v57 = v40 * (unint64_t)v55 / v56 + 16;
      if (v57 <= v40) {
        unint64_t v57 = v40;
      }
      unint64_t v58 = 2 * v57;
      uint64_t v59 = v21[10];
      if (v59)
      {
        long long v60 = v21 + 11;
        if (v21[11] >= v58) {
          goto LABEL_36;
        }
        uint64_t v61 = heap_Realloc(*(uint64_t **)(*(void *)(v21[1] + 16) + 8), v59, v58);
        if (v61)
        {
          v21[10] = v61;
LABEL_35:
          *long long v60 = v58;
          goto LABEL_36;
        }
      }
      else
      {
        uint64_t v62 = heap_Alloc(*(void *)(*(void *)(v21[1] + 16) + 8), v58);
        v21[10] = v62;
        if (v62)
        {
          long long v60 = v21 + 11;
          goto LABEL_35;
        }
      }
    }
    uint64_t v14 = 2269126656;
    v21[8] = 0;
    log_OutPublic(*(void *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 137, (uint64_t)"%s%s%s%hu%s%hu", v50, v51, v52, v53, "uri");
    goto LABEL_41;
  }
  return v14;
}

uint64_t audiofetch_FetchStreamRead(uint64_t a1, int a2, unsigned int a3, uint64_t a4, unsigned int *a5, unsigned int *a6)
{
  unsigned int v51 = a3;
  int v49 = 0;
  *a5 = 0;
  uint64_t v11 = safeh_HandleCheck(a1, a2, 703, 96);
  if ((v11 & 0x80000000) != 0) {
    return v11;
  }
  unsigned int v12 = a3;
  uint64_t v13 = a5;
  uint64_t v14 = (_WORD *)a4;
  if (*(_DWORD *)(a1 + 72) == 1)
  {
    uint64_t v14 = *(_WORD **)(a1 + 80);
    uint64_t v13 = (unsigned int *)&v49;
    unsigned int v12 = *(unsigned __int16 *)(a1 + 58) * a3 / *(unsigned __int16 *)(a1 + 56);
  }
  uint64_t v15 = 2269126663;
  unsigned int v50 = v12;
  if (!a4 || !a3) {
    return 2269126663;
  }
  uint64_t v16 = *(unsigned int *)(a1 + 48);
  uint64_t v17 = *(void *)(a1 + 16);
  unsigned int v18 = *(_DWORD *)(v17 + 16);
  if (v18 <= v16) {
    return 2269126659;
  }
  unsigned int v19 = v18 - v16;
  if (v19 < v12)
  {
    unsigned int v50 = v19;
    unsigned int v12 = v19;
  }
  if (!*(void *)(v17 + 40))
  {
    if (*(void *)(a1 + 24))
    {
      if (v12)
      {
        do
        {
          uint64_t v30 = *(void *)(a1 + 16);
          uint64_t v31 = *(void *)(a1 + 24);
          int v32 = *(unsigned __int16 *)(v30 + 72);
          __int16 v33 = v12 * v32;
          if (v12 * v32 >= 0xFFFF) {
            __int16 v33 = -1;
          }
          LOWORD(v48) = v33;
          if (v12 >> 15) {
            __int16 v34 = -1;
          }
          else {
            __int16 v34 = 2 * v12;
          }
          unsigned __int16 v47 = v34;
          __int16 v46 = 0;
          uint64_t v11 = (*(uint64_t (**)(void, void, void, void, unsigned int *, void, _WORD *, unsigned __int16 *, void, __int16 *, const char *, uint64_t))(v31 + 112))(*(void *)(a1 + 32), *(void *)(a1 + 40), 0, *(void *)(v30 + 56) + (*(_DWORD *)(a1 + 48) * v32), &v48, 0, &v14[*v13], &v47, 0, &v46, v44, v45);
          if ((v11 & 0x80000000) != 0 || !(_WORD)v48)
          {
            unsigned int v44 = "lhError";
            uint64_t v45 = v11;
            log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"AUDIOFETCH", 163, (uint64_t)"%s%s%s%x", v35, v36, v37, v38, "uri");
            unsigned int v12 = v50;
          }
          else
          {
            unsigned int v39 = v47;
            *(_DWORD *)(a1 + 48) += v47 >> 1;
            *v13 += v39 >> 1;
            unsigned int v12 = v50 - (v39 >> 1);
            unsigned int v50 = v12;
          }
        }
        while ((v11 & 0x80000000) == 0 && v12);
        uint64_t v15 = 2269126663;
        if ((v11 & 0x80000000) != 0) {
          return v11;
        }
      }
      *a5 = *v13;
      if (*(_DWORD *)(*(void *)(a1 + 16) + 80) != 1)
      {
        *a6 = *v13;
        return v11;
      }
      uint64_t v40 = *(void *)(a1 + 64);
      uint64_t v41 = v14;
      unsigned int v42 = v13;
    }
    else
    {
      cstdlib_memcpy(v14, (const void *)(*(void *)(v17 + 56) + 2 * v16), 2 * v12);
      *(_DWORD *)(a1 + 48) += v12;
      *a5 = v12;
      if (*(_DWORD *)(*(void *)(a1 + 16) + 80) != 1)
      {
        *a6 = v12;
        return v11;
      }
      uint64_t v40 = *(void *)(a1 + 64);
      unsigned int v42 = &v50;
      uint64_t v41 = v14;
    }
    unsigned int v43 = spxrsmp_resampler_process_int(v40, 0, v41, v42, a4, &v51);
    if (v43 <= 2) {
      uint64_t v15 = dword_22078ABE4[v43];
    }
    *a6 = v51;
    return v15;
  }
  unsigned int v48 = v12;
  if (v12)
  {
    while (1)
    {
      uint64_t v11 = (*(uint64_t (**)(void, unsigned int *, _WORD *))(*(void *)(*(void *)(a1 + 16) + 32) + 72))(*(void *)(*(void *)(a1 + 16) + 40), &v48, &v14[*v13]);
      if ((v11 & 0x80000000) != 0) {
        break;
      }
      unsigned int v24 = v48;
      unsigned int v25 = v50;
      *v13 += v48;
      unsigned int v50 = v25 - v24;
      if (v25 == v24) {
        goto LABEL_13;
      }
    }
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"AUDIOFETCH", 158, (uint64_t)"%s%s%s%x", v20, v21, v22, v23, "uri");
  }
  else
  {
LABEL_13:
    *a5 = *v13;
    if (*(_DWORD *)(*(void *)(a1 + 16) + 80) == 1)
    {
      int v26 = spxrsmp_resampler_process_int(*(void *)(a1 + 64), 0, v14, v13, a4, &v51);
      unsigned int v27 = -2025840623;
      int v28 = -2025840630;
      if (v26 != 1) {
        int v28 = -2025840633;
      }
      if (v26 != 2) {
        unsigned int v27 = v28;
      }
      uint64_t v13 = &v51;
      if (v26) {
        uint64_t v11 = v27;
      }
      else {
        uint64_t v11 = 0;
      }
    }
    *a6 = *v13;
    *(_DWORD *)(a1 + 48) += *a5;
  }
  return v11;
}

uint64_t audiofetch_FetchStreamClose(void *a1, int a2, int a3)
{
  uint64_t v5 = safeh_HandleCheck((uint64_t)a1, a2, 703, 96);
  if ((v5 & 0x80000000) == 0)
  {
    uint64_t v6 = a1[2];
    if (*(void *)(v6 + 40))
    {
      uint64_t v5 = (*(uint64_t (**)(void))(*(void *)(v6 + 32) + 64))();
      if ((v5 & 0x80000000) != 0) {
        log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"AUDIOFETCH", 159, (uint64_t)"%s%s%s%x", v7, v8, v9, v10, "uri");
      }
    }
    uint64_t v11 = a1[3];
    if (v11)
    {
      uint64_t v12 = a1[4];
      if (v12)
      {
        int v13 = (*(uint64_t (**)(uint64_t, void))(v11 + 40))(v12, a1[5]);
        if (v13 < 0)
        {
          int v18 = v13;
          log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"AUDIOFETCH", 164, (uint64_t)"%s%x", v14, v15, v16, v17, "lhError");
          if ((int)v5 >= 0) {
            LODWORD(v5) = v18;
          }
        }
      }
      int v19 = brk_InterfaceRelease(*(void *)(*a1 + 24), a1[3]);
      if (v19 >= 0 || (int)v5 <= -1) {
        uint64_t v5 = v5;
      }
      else {
        uint64_t v5 = v19;
      }
    }
    if (*(_DWORD *)(a1[2] + 80) == 1)
    {
      spxrsmp_resampler_destroy((void *)a1[8]);
      uint64_t v21 = a1[10];
      if (v21) {
        heap_Free(*(void **)(*(void *)(a1[1] + 16) + 8), v21);
      }
      a1[10] = 0;
      a1[11] = 0;
      a1[8] = 0;
      *((_DWORD *)a1 + 18) = 0;
    }
    if (a3)
    {
      int v22 = ssftmap_Remove(*(void *)(a1[1] + 40), *(void *)(a1[2] + 8));
      if (v22 >= 0 || (int)v5 <= -1) {
        uint64_t v5 = v5;
      }
      else {
        uint64_t v5 = v22;
      }
    }
    heap_Free(*(void **)(*a1 + 8), (uint64_t)a1);
  }
  return v5;
}

uint64_t audiofetch_GetAudioURI(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  uint64_t v9 = 0;
  uint64_t result = 2269126663;
  if (a3)
  {
    if (a4)
    {
      uint64_t result = safeh_HandleCheck(a1, a2, 702, 56);
      if ((result & 0x80000000) == 0)
      {
        int v8 = ssftmap_Find(*(void *)(a1 + 40), a3, &v9);
        uint64_t result = 0;
        if ((v8 & 0x80000000) == 0)
        {
          if (v9)
          {
            uint64_t result = 0;
            *a4 = *(void *)(v9 + 24);
          }
        }
      }
    }
  }
  return result;
}

uint64_t audiofetch_FetchSsml(uint64_t a1, int a2, unsigned char *a3, char *a4, uint64_t a5, uint64_t a6, void *a7)
{
  return fetchAudio(a1, a2, a3, a4, a7, 1);
}

uint64_t audiofetch_ElemCopyAudioVarLenBuf(_WORD *a1, uint64_t a2, void *a3)
{
  if (!a1) {
    return 2269126663;
  }
  uint64_t result = 0;
  ++*a1;
  *a3 = a1;
  return result;
}

void *audiofetch_ElemFreeAudioVarLenBuf(void *result, void *a2)
{
  if (result)
  {
    uint64_t v2 = (uint64_t)result;
    unsigned int v3 = *(unsigned __int16 *)result;
    if (v3 < 2)
    {
      uint64_t v5 = result[1];
      if (v5) {
        heap_Free(a2, v5);
      }
      uint64_t v6 = *(void *)(v2 + 24);
      if (v6) {
        heap_Free(a2, v6);
      }
      uint64_t v7 = *(void *)(v2 + 56);
      if (v7) {
        heap_Free(a2, v7);
      }
      return heap_Free(a2, v2);
    }
    else
    {
      *(_WORD *)uint64_t result = v3 - 1;
    }
  }
  return result;
}

uint64_t audiofetch_ElemCopySpeechBase(const void *a1, void *a2, uint64_t *a3)
{
  uint64_t v3 = 2269126663;
  if (a1)
  {
    uint64_t v7 = (void *)heap_Calloc(a2, 1, 64);
    if (v7)
    {
      uint64_t v8 = (uint64_t)v7;
      cstdlib_memcpy(v7, a1, 0x40uLL);
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      uint64_t v9 = brk_InterfaceQuery(*(void *)(*(void *)(v8 + 32) + 24));
      if ((v9 & 0x80000000) != 0)
      {
        uint64_t v3 = v9;
      }
      else
      {
        uint64_t v10 = (*(uint64_t (**)(void, void, void, void, uint64_t))(*(void *)(v8 + 48) + 32))(*(void *)(v8 + 16), *(void *)(v8 + 24), *(void *)(v8 + 40), *(void *)(v8 + 8), v8 + 56);
        if ((v10 & 0x80000000) != 0)
        {
          uint64_t v16 = v10;
          brk_InterfaceRelease(*(void *)(*(void *)(v8 + 32) + 24), *(void *)(v8 + 48));
          *(void *)(v8 + 48) = 0;
          uint64_t v3 = v16;
        }
        else
        {
          __int16 v18 = 0;
          uint64_t v11 = (*(uint64_t (**)(void, __int16 *))(*(void *)(v8 + 48) + 88))(*(void *)(v8 + 56), &v18);
          if ((v11 & 0x80000000) == 0 && v18 == *(_WORD *)v8)
          {
            uint64_t v3 = v11;
LABEL_13:
            *a3 = v8;
            return v3;
          }
          log_OutPublic(*(void *)(*(void *)(v8 + 32) + 32), (uint64_t)"AUDIOFETCH", 134, (uint64_t)"%s%s", v12, v13, v14, v15, "speechbase");
          (*(void (**)(uint64_t))(*(void *)(v8 + 48) + 40))(v8 + 56);
          *(void *)(v8 + 56) = 0;
          brk_InterfaceRelease(*(void *)(*(void *)(v8 + 32) + 24), *(void *)(v8 + 48));
          *(void *)(v8 + 48) = 0;
          uint64_t v3 = 2269126681;
        }
      }
      heap_Free(a2, v8);
      uint64_t v8 = 0;
      goto LABEL_13;
    }
    return 2269126666;
  }
  return v3;
}

void *audiofetch_ElemFreeSpeechBase(void *result, void *a2)
{
  if (result)
  {
    uint64_t v3 = result;
    uint64_t v4 = result[6];
    if (v4)
    {
      uint64_t v5 = result + 7;
      if (v3[7])
      {
        (*(void (**)(void *))(v4 + 40))(v5);
        uint64_t v4 = v3[6];
      }
      brk_InterfaceRelease(*(void *)(v3[4] + 24), v4);
    }
    return heap_Free(a2, (uint64_t)v3);
  }
  return result;
}

uint64_t fetchAudio(uint64_t a1, int a2, unsigned char *a3, char *a4, void *a5, int a6)
{
  uint64_t ThroughCup = 2269126666;
  uint64_t v7 = 2269126663;
  if (!a3) {
    return v7;
  }
  if (!a5) {
    return v7;
  }
  uint64_t v9 = (uint64_t)a3;
  if (!*a3) {
    return v7;
  }
  *a5 = 0;
  uint64_t v13 = safeh_HandleCheck(a1, a2, 702, 56);
  if ((v13 & 0x80000000) != 0) {
    return v13;
  }
  log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Entering audiofetch_Fetch for URI \"%s\"", v14, v15, v16, v9);
  log_OutTraceTuningData(*(uint64_t ***)(*(void *)(a1 + 16) + 32), 311, (uint64_t)"%s%s %s%s %s%s", v17, v18, v19, v20, v21, "BEG");
  if (!cstdlib_strncmp((const char *)v9, "x-vocalizer-speechbase://", 0x19uLL))
  {
    uint64_t v74 = 0;
    long long v72 = 0u;
    long long v73 = 0u;
    long long __b = 0u;
    long long v71 = 0u;
    uint64_t v69 = 0;
    uint64_t v27 = *(void *)(*(void *)(a1 + 16) + 8);
    int v28 = cstdlib_strlen((const char *)(v9 + 25));
    uint64_t v29 = (char *)heap_Alloc(v27, (v28 + 1));
    if (!v29)
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 100, 0, v30, v31, v32, v33, v68);
      goto LABEL_35;
    }
    __int16 v34 = v29;
    cstdlib_strcpy(v29, (const char *)(v9 + 25));
    uint64_t v35 = cstdlib_strchr(v34, 35);
    if (v35)
    {
      uint64_t v40 = v35;
      cstdlib_strtoul((unsigned __int8 *)v35 + 1, &v74, 0xAu);
      *uint64_t v40 = 0;
      uint64_t v7 = ssftmap_Find(*(void *)(a1 + 48), (uint64_t)v34, &v69);
      if ((v7 & 0x80000000) == 0)
      {
LABEL_21:
        if ((v7 & 0x80000000) == 0 && v69 && *(void *)(v69 + 56))
        {
          uint64_t v46 = heap_Calloc(*(void **)(*(void *)(a1 + 16) + 8), 1, 88);
          if (v46)
          {
            uint64_t v51 = v46;
            *(_WORD *)uint64_t v46 = 1;
            uint64_t v52 = v69;
            uint64_t v53 = *(void *)(v69 + 48);
            *(void *)(v46 + 32) = v53;
            *(void *)(v46 + 40) = *(void *)(v52 + 56);
            *(void *)(v46 + 56) = 0;
            uint64_t v54 = (*(uint64_t (**)(void))(v53 + 80))();
            if ((v54 & 0x80000000) != 0)
            {
              uint64_t v67 = v54;
              log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 156, (uint64_t)"%s%s%s%u%s%x", v55, v56, v57, v58, "speechbase");
              uint64_t ThroughCup = v67;
            }
            else
            {
              *(_DWORD *)(v51 + 48) = 0;
              *(_DWORD *)(v51 + 16) = 0;
              uint64_t v59 = strhelper_Strdup(*(void *)(*(void *)(a1 + 16) + 8), (char *)v9);
              *(void *)(v51 + 24) = v59;
              if (v59) {
                uint64_t ThroughCup = AddAudioTask(a1, v51, a5);
              }
            }
            audiofetch_ElemFreeAudioVarLenBuf((void *)v51, *(void **)(*(void *)(a1 + 16) + 8));
            uint64_t v7 = ThroughCup;
          }
          else
          {
            log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 100, 0, v47, v48, v49, v50, v68);
            uint64_t v7 = 2269126666;
          }
        }
        goto LABEL_32;
      }
      cstdlib_memset(&__b, 0, 0x40uLL);
      long long v71 = *(_OWORD *)a1;
      long long v72 = *(_OWORD *)(a1 + 16);
      LOWORD(__b) = GetEngineFreq(a1);
      *((void *)&__b + 1) = v34;
      uint64_t v41 = ssftmap_Insert(*(void *)(a1 + 48), (uint64_t)v34, (uint64_t)&__b);
      if ((v41 & 0x80000000) == 0)
      {
        uint64_t v7 = ssftmap_Find(*(void *)(a1 + 48), (uint64_t)v34, &v69);
        goto LABEL_21;
      }
      uint64_t v7 = v41;
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 155, (uint64_t)"%s%s", v42, v43, v44, v45, "speechbase");
    }
    else
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 154, (uint64_t)"%s%s", v36, v37, v38, v39, "uri");
    }
LABEL_32:
    heap_Free(*(void **)(*(void *)(a1 + 16) + 8), (uint64_t)v34);
    uint64_t ThroughCup = v7;
    goto LABEL_35;
  }
  if (audiofetch_IsURIWithinCup(v9))
  {
    unsigned int v25 = (const char *)strhelper_Strdup(*(void *)(*(void *)(a1 + 16) + 8), (char *)v9);
    if (v25)
    {
      int v26 = &v25[cstdlib_strlen("cup:")];
      while (*v26++)
      {
        if (*(v26 - 1) == 58)
        {
          *((unsigned char *)v26 - 1) = 0;
          break;
        }
      }
      if (*v26) {
        uint64_t v9 = (uint64_t)v26;
      }
      uint64_t ThroughCup = audiofetch_FetchThroughCup(a1, (char *)v9, v25, a5);
    }
    goto LABEL_36;
  }
  if (audiofetch_IsURIWithinCup((BOOL)a4)) {
    uint64_t ThroughBroker = audiofetch_FetchThroughCup(a1, (char *)v9, a4, a5);
  }
  else {
    uint64_t ThroughBroker = audiofetch_FetchThroughBroker(a1, (char *)v9, a4, a5, a6);
  }
  uint64_t ThroughCup = ThroughBroker;
LABEL_35:
  unsigned int v25 = 0;
LABEL_36:
  log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Exiting audiofetch_Fetch for URI \"%s\", %x", v22, v23, v24, v9);
  log_OutTraceTuningData(*(uint64_t ***)(*(void *)(a1 + 16) + 32), 311, (uint64_t)"%s%s %s%u", v61, v62, v63, v64, v65, "END");
  if (v25) {
    heap_Free(*(void **)(*(void *)(a1 + 16) + 8), (uint64_t)v25);
  }
  return ThroughCup;
}

BOOL audiofetch_IsURIWithinCup(BOOL result)
{
  if (result)
  {
    uint64_t v1 = (const char *)result;
    size_t v2 = cstdlib_strlen("cup:");
    return cstdlib_strncmp(v1, "cup:", v2) == 0;
  }
  return result;
}

uint64_t audiofetch_FetchThroughCup(uint64_t a1, char *a2, const char *a3, void *a4)
{
  uint64_t v5 = 0;
  int v26 = 0;
  uint64_t v27 = 0;
  uint64_t v6 = 2269126674;
  unsigned int v25 = 0;
  if (a2 && a3)
  {
    MimeTypeFromURI = (char *)audiofetch_GetMimeTypeFromURI(a2);
    size_t v11 = cstdlib_strlen(a2);
    size_t v12 = cstdlib_strlen(a3);
    uint64_t v5 = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 16) + 8), v11 + v12 + 1);
    if (v5)
    {
      if (audiofetch_IsURIWithinCup((BOOL)a3))
      {
        size_t v13 = cstdlib_strlen("cup:");
        sprintf(v5, "%s:%s", &a3[v13], a2);
        uint64_t v14 = cstdlib_strrchr(v5, 46);
        uint64_t v15 = v14;
        if (v14) {
          *uint64_t v14 = 0;
        }
        uint64_t v16 = brk_DataOpenEx(*(void *)(*(void *)(a1 + 16) + 24), (uint64_t)v5, 0, (uint64_t)&v27);
        if ((v16 & 0x80000000) == 0)
        {
          uint64_t v16 = brk_DataMapEx(*(void *)(*(void *)(a1 + 16) + 24), v27, 0, (uint64_t)&v25, (uint64_t)&v26);
          if ((v16 & 0x80000000) == 0)
          {
            if (!v15)
            {
              size_t v19 = v25;
              if (cstdlib_strlen("OggS") > v19
                || (uint64_t v20 = v26, v21 = cstdlib_strlen("OggS"), cstdlib_strncmp(v20, "OggS", v21)))
              {
                size_t v22 = v25;
                if (cstdlib_strlen("RIFF") <= v22)
                {
                  uint64_t v23 = v26;
                  size_t v24 = cstdlib_strlen("RIFF");
                  if (!cstdlib_strncmp(v23, "RIFF", v24)) {
                    MimeTypeFromURI = "audio/x-wav";
                  }
                }
              }
              else
              {
                MimeTypeFromURI = "audio/ogg";
              }
            }
            uint64_t v16 = audiofetch_PrepareAudioTask((_WORD **)a1, a2, MimeTypeFromURI, (unsigned int *)v26, v25, a4);
          }
        }
        uint64_t v6 = v16;
      }
    }
    else
    {
      uint64_t v6 = 2269126666;
    }
  }
  uint64_t v17 = v27;
  if (v26)
  {
    brk_DataUnmap(*(void *)(*(void *)(a1 + 16) + 24), v27, (uint64_t)v26);
    uint64_t v17 = v27;
  }
  if (v17) {
    brk_DataClose(*(void *)(*(void *)(a1 + 16) + 24), v17);
  }
  if (v5) {
    heap_Free(*(void **)(*(void *)(a1 + 16) + 8), (uint64_t)v5);
  }
  return v6;
}

uint64_t audiofetch_FetchThroughBroker(uint64_t a1, char *a2, char *__s, void *a4, int a5)
{
  uint64_t v44 = 0;
  uint64_t v9 = 2269126666;
  unsigned int v43 = 0;
  uint64_t v42 = 0;
  if (!__s)
  {
    BOOL v12 = a5 != 0;
LABEL_12:
    size_t v16 = cstdlib_strlen(a2);
    uint64_t v17 = *(void *)(*(void *)(a1 + 16) + 8);
    size_t v18 = cstdlib_strlen(a2);
    size_t v19 = (char *)heap_Alloc(v17, v18 + 1);
    unsigned int v25 = v19;
    if (!v19)
    {
      int v26 = 0;
      goto LABEL_25;
    }
    cstdlib_strncpy(v19, a2, v16);
    int v26 = 0;
    v25[v16] = 0;
    goto LABEL_14;
  }
  size_t v11 = cstdlib_strlen(__s);
  BOOL v12 = a5 != 0;
  if (!v11) {
    goto LABEL_12;
  }
  size_t v13 = v11;
  if (!IsThisUrlOrRealPath(__s, v11, 0)) {
    goto LABEL_12;
  }
  while (1)
  {
    int v14 = __s[v13];
    if (v14 == 47) {
      break;
    }
    if (v14 == 92 || &__s[v13] <= __s) {
      break;
    }
    --v13;
  }
  uint64_t v37 = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 16) + 8), v13 + 2);
  int v26 = v37;
  if (!v37)
  {
    unsigned int v25 = 0;
    goto LABEL_25;
  }
  cstdlib_strncpy(v37, __s, v13 + 1);
  v26[v13 + 1] = 0;
  uint64_t v38 = *(void *)(*(void *)(a1 + 16) + 8);
  size_t v39 = cstdlib_strlen(v26);
  size_t v40 = cstdlib_strlen(a2);
  unsigned int v25 = (char *)heap_Alloc(v38, v39 + v40 + 1);
  if (v25)
  {
    UriCompleteUrl(v26, a2, v25);
LABEL_14:
    MimeTypeFromURI = (char *)audiofetch_GetMimeTypeFromURI(v25);
    int v28 = cstdlib_strrchr(v25, 63);
    if (v28) {
      char *v28 = 0;
    }
    uint64_t v34 = a1 + 16;
    log_OutEvent(*(uint64_t ***)(*(void *)(a1 + 16) + 32), 12, (uint64_t)"%s%s", v29, v30, v31, v32, v33, "URI");
    uint64_t v35 = brk_DataOpenEx(*(void *)(*(void *)(a1 + 16) + 24), (uint64_t)v25, v12, (uint64_t)&v42);
    if ((v35 & 0x80000000) == 0)
    {
      uint64_t v35 = brk_DataMapEx(*(void *)(*(void *)v34 + 24), v42, 0, (uint64_t)&v43, (uint64_t)&v44);
      if ((v35 & 0x80000000) == 0)
      {
        uint64_t v9 = audiofetch_PrepareAudioTask((_WORD **)a1, v25, MimeTypeFromURI, v44, v43, a4);
        uint64_t v36 = *(uint64_t ***)(*(void *)(a1 + 16) + 32);
        goto LABEL_26;
      }
    }
    uint64_t v9 = v35;
  }
LABEL_25:
  uint64_t v36 = *(uint64_t ***)(*(void *)(a1 + 16) + 32);
  uint64_t v34 = a1 + 16;
LABEL_26:
  log_OutEvent(v36, 13, (uint64_t)"%s%s%s%s%s%s", v20, v21, v22, v23, v24, "URI");
  if (v44) {
    brk_DataUnmap(*(void *)(*(void *)v34 + 24), v42, (uint64_t)v44);
  }
  if (v42) {
    brk_DataClose(*(void *)(*(void *)v34 + 24), v42);
  }
  if (v25) {
    heap_Free(*(void **)(*(void *)v34 + 8), (uint64_t)v25);
  }
  if (v26) {
    heap_Free(*(void **)(*(void *)v34 + 8), (uint64_t)v26);
  }
  return v9;
}

uint64_t AddAudioTask(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  *a3 = 0;
  uint64_t v6 = *(const char **)(a2 + 24);
  if (v6)
  {
    LODWORD(v6) = cstdlib_strlen(v6);
    uint64_t v7 = *(const char **)(a2 + 24);
    if (v6 >= 0x51)
    {
      v7 += (v6 - 80);
      LODWORD(v6) = cstdlib_strlen(v7);
    }
  }
  else
  {
    uint64_t v7 = "";
  }
  uint64_t v8 = heap_Alloc(*(void *)(*(void *)(a1 + 16) + 8), (v6 + 16));
  *(void *)(a2 + 8) = v8;
  if (v8)
  {
    cstdlib_strcpy(__dst, "__NUAN_");
    LH_utoa(*(_DWORD *)(a1 + 32), __s2, 0xAu);
    cstdlib_strcat(__dst, __s2);
    cstdlib_strcat(__dst, "_");
    cstdlib_strcpy(*(char **)(a2 + 8), __dst);
    if (v7 && *v7)
    {
      uint64_t v13 = *(void *)(a2 + 8);
      size_t v14 = cstdlib_strlen(__dst);
      cstdlib_strcpy((char *)(v13 + v14), v7);
    }
    uint64_t v19 = ssftmap_Insert(*(void *)(a1 + 40), *(void *)(a2 + 8), a2);
    if ((v19 & 0x80000000) != 0)
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 100, 0, v15, v16, v17, v18, v25);
    }
    else
    {
      int v20 = *(_DWORD *)(a1 + 32);
      BOOL v21 = __CFADD__(v20, 1);
      int v22 = v20 + 1;
      if (v21) {
        int v22 = 1;
      }
      *(_DWORD *)(a1 + 32) = v22;
      *a3 = *(void *)(a2 + 8);
      if (*(void *)(a2 + 40)) {
        uint64_t v23 = "Audio insertion %s: from %s, %u offset, %u duration";
      }
      else {
        uint64_t v23 = "Audio insertion %s: from %s, encoding %d, %u samples";
      }
      log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 3, 0, (uint64_t)v23, v16, v17, v18, (uint64_t)__dst);
    }
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 100, 0, v9, v10, v11, v12, v25);
    return 2269126666;
  }
  return v19;
}

const char *audiofetch_GetMimeTypeFromURI(char *a1)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (!a1) {
    return "application/octet-stream";
  }
  size_t ExtensionFromURI = UriGetExtensionFromURI(a1, v8, 0x50uLL);
  if (ExtensionFromURI)
  {
    uint64_t v3 = (char *)ExtensionFromURI;
    uint64_t v4 = 0;
    while (LH_stricmp(v3, audiofetch_GetMimeTypeFromURI_EXT_TO_MIMETYPE_CONVERSION_MAP_T[v4]))
    {
      v4 += 2;
      if (v4 == 22) {
        goto LABEL_6;
      }
    }
    return audiofetch_GetMimeTypeFromURI_EXT_TO_MIMETYPE_CONVERSION_MAP_T[v4 + 1];
  }
  else
  {
LABEL_6:
    size_t v5 = cstdlib_strlen("audio/");
    uint64_t v6 = "application/octet-stream";
    if (!cstdlib_strncmp(a1, "audio/", v5) && cstdlib_strchr(a1, 58)) {
      return "audio/x-wav";
    }
  }
  return v6;
}

uint64_t audiofetch_PrepareAudioTask(_WORD **a1, char *a2, char *__s1, unsigned int *a4, unsigned int a5, void *a6)
{
  uint64_t v67 = *MEMORY[0x263EF8340];
  int v58 = 0;
  int v59 = 0;
  int v57 = 0;
  char v65 = 0;
  long long v63 = 0u;
  long long v64 = 0u;
  *(_OWORD *)__s1a = 0u;
  long long v62 = 0u;
  memset(__n, 0, sizeof(__n));
  if (!ParseAudioMimeType(__s1, &v59, (_WORD *)&v58 + 1, &v58, &v57))
  {
    uint64_t v19 = 2269126660;
    log_OutPublic(*((void *)a1[2] + 4), (uint64_t)"AUDIOFETCH", 133, (uint64_t)"%s%s%s%s", v11, v12, v13, v14, "uri");
    return v19;
  }
  int EngineFreq = GetEngineFreq((uint64_t)a1);
  int v16 = EngineFreq;
  if (v57) {
    BOOL v17 = 1;
  }
  else {
    BOOL v17 = HIWORD(v58) == EngineFreq;
  }
  int v18 = !v17;
  if (!a5 && (v59 - 5) < 5) {
    return 2269126660;
  }
  switch(v59)
  {
    case 1:
      uint64_t v21 = Au2PCM(*a1, (int)a1[1], a2, a4, a5, __s1a, &__n[1], __n, 1);
      goto LABEL_35;
    case 5:
      uint64_t v21 = Wav2PCM(*a1, (uint64_t)a1[1], a2, (uint64_t)a4, a5, __s1a, (uint64_t *)&__n[1], __n);
      goto LABEL_35;
    case 6:
      uint64_t v23 = (void *)*((void *)a1[2] + 1);
      int v60 = 0;
      uint64_t v24 = op_open_memory(v23, (uint64_t)a4, a5, &v60);
      if (!v24 || (unsigned int v25 = v24, v26 = op_pcm_total((uint64_t)v24, -1), v26 < 0))
      {
        uint64_t v28 = 0;
        uint64_t v19 = 2269126660;
        goto LABEL_69;
      }
      uint64_t v27 = (void *)heap_Calloc(v23, 1, (2 * v26 + 44));
      uint64_t v28 = (uint64_t)v27;
      if (!v27) {
        goto LABEL_63;
      }
      uint64_t v55 = (uint64_t)v23;
      cstdlib_memcpy(v27, &audiofetch_Ogg2Wav_WAV_HEADER_TEMPLATE, 0x2CuLL);
      uint64_t v29 = 0;
      uint64_t v30 = (_WORD *)(v28 + 44);
      break;
    case 7:
      uint64_t v21 = Au2PCM(*a1, (int)a1[1], a2, a4, a5, __s1a, &__n[1], __n, 0);
      goto LABEL_35;
    case 8:
      uint64_t v21 = NistSphere2PCM(*a1, (int)a1[1], a2, (char *)a4, a5, __s1a, &__n[1], __n);
      goto LABEL_35;
    case 9:
      uint64_t v21 = NuanceAudio2PCM(*a1, (uint64_t)a1[1], a2, (uint64_t)a4, a5, __s1a, 0x41uLL, (uint64_t *)&__n[1], __n);
LABEL_35:
      uint64_t v19 = v21;
      goto LABEL_36;
    default:
      __n[0] = a5;
      int v22 = (void *)heap_Alloc(*((void *)a1[2] + 1), a5);
      *(void *)&__n[1] = v22;
      if (!v22) {
        return 2269126666;
      }
      cstdlib_memcpy(v22, a4, __n[0]);
      goto LABEL_37;
  }
  while (1)
  {
    do
    {
      int stereo = op_read_stereo((uint64_t)v25, (uint64_t)v66, 11520);
      int v60 = stereo;
    }
    while (stereo == -3);
    if (stereo == -129)
    {
LABEL_63:
      uint64_t v19 = 2269126666;
      goto LABEL_69;
    }
    if (stereo < 0)
    {
      uint64_t v19 = 2269126660;
      goto LABEL_69;
    }
    if (!stereo) {
      break;
    }
    uint64_t v32 = 0;
    do
    {
      if (v32)
      {
        *v30++ = (__int16)(v66[v32] + (v66[v32] >> 15)) >> 1;
        int stereo = v60;
      }
      ++v32;
    }
    while (v32 < 2 * stereo);
    v29 += stereo;
  }
  if (v29 < 1)
  {
    int v53 = 0;
  }
  else
  {
    *(_DWORD *)(v28 + 4) = 2 * v29 + 36;
    *(_WORD *)(v28 + 40) = __PAIR16__((unint64_t)(2 * v29) >> 56, 2 * v29);
    *(unsigned char *)(v28 + 42) = (unint64_t)v29 >> 15;
    *(unsigned char *)(v28 + 43) = (unint64_t)v29 >> 23;
    int v53 = 2 * v29 + 44;
  }
  op_free(v55, v25);
  uint64_t v19 = Wav2PCM(*a1, (uint64_t)a1[1], a2, v28, v53, __s1a, (uint64_t *)&__n[1], __n);
LABEL_69:
  if (v28) {
    heap_Free(*((void **)a1[2] + 1), v28);
  }
LABEL_36:
  if ((v19 & 0x80000000) != 0)
  {
    if (*(void *)&__n[1]) {
      heap_Free(*((void **)a1[2] + 1), *(uint64_t *)&__n[1]);
    }
  }
  else
  {
LABEL_37:
    if (!ParseAudioMimeType(__s1a, &v59, (_WORD *)&v58 + 1, &v58, 0))
    {
      log_OutPublic(*((void *)a1[2] + 4), (uint64_t)"AUDIOFETCH", 136, (uint64_t)"%s%s%s%s", v33, v34, v35, v36, "uri");
      if (*(void *)&__n[1]) {
        heap_Free(*((void **)a1[2] + 1), *(uint64_t *)&__n[1]);
      }
      return 2269126660;
    }
    int v37 = HIWORD(v58);
    uint64_t v38 = heap_Calloc(*((void **)a1[2] + 1), 1, 88);
    if (v38)
    {
      unsigned int v43 = (void *)v38;
      if (v37 == v16) {
        int v44 = v18;
      }
      else {
        int v44 = 1;
      }
      *(_WORD *)uint64_t v38 = 1;
      *(_WORD *)(v38 + 68) = v37;
      *(_WORD *)(v38 + 70) = v16;
      int v45 = v59;
      unsigned int v46 = (unsigned __int16)v58;
      *(_WORD *)(v38 + 72) = v58;
      unsigned int v47 = __n[0];
      *(_DWORD *)(v38 + 64) = __n[0];
      *(_DWORD *)(v38 + 76) = v45;
      *(_DWORD *)(v38 + 80) = v44;
      if (v46)
      {
        if (v46 != 1)
        {
          if (v46 == 2) {
            v47 >>= 1;
          }
          else {
            v47 /= v46;
          }
        }
        *(_DWORD *)(v38 + 16) = v47;
      }
      uint64_t v48 = strhelper_Strdup(*((void *)a1[2] + 1), a2);
      v43[3] = v48;
      if (v48)
      {
        v43[7] = *(void *)&__n[1];
        uint64_t v19 = AddAudioTask((uint64_t)a1, (uint64_t)v43, a6);
      }
      else
      {
        if (*(void *)&__n[1]) {
          heap_Free(*((void **)a1[2] + 1), *(uint64_t *)&__n[1]);
        }
        log_OutPublic(*((void *)a1[2] + 4), (uint64_t)"AUDIOFETCH", 100, 0, v49, v50, v51, v52, v54);
        uint64_t v19 = 2269126666;
      }
      audiofetch_ElemFreeAudioVarLenBuf(v43, *((void **)a1[2] + 1));
    }
    else
    {
      if (*(void *)&__n[1]) {
        heap_Free(*((void **)a1[2] + 1), *(uint64_t *)&__n[1]);
      }
      log_OutPublic(*((void *)a1[2] + 4), (uint64_t)"AUDIOFETCH", 100, 0, v39, v40, v41, v42, v54);
      return 2269126666;
    }
  }
  return v19;
}

BOOL ParseAudioMimeType(char *__s1, int *a2, _WORD *a3, _WORD *a4, _DWORD *a5)
{
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  if (a5) {
    *a5 = 0;
  }
  if (!cstdlib_strcmp(__s1, "audio/wav") || !cstdlib_strcmp(__s1, "audio/x-wav"))
  {
    if (a5)
    {
      *a5 = 1;
      int v14 = 5;
      goto LABEL_27;
    }
    return *a2 != 0;
  }
  if (!cstdlib_strcmp(__s1, "audio/ogg"))
  {
    if (!a5) {
      return *a2 != 0;
    }
    *a5 = 1;
    int v14 = 6;
    goto LABEL_27;
  }
  if (!cstdlib_strcmp(__s1, "audio/x-nist"))
  {
    if (!a5) {
      return *a2 != 0;
    }
    *a5 = 1;
    int v14 = 8;
    goto LABEL_27;
  }
  if (!cstdlib_strcmp(__s1, "audio/x-nuance-audio"))
  {
    if (!a5) {
      return *a2 != 0;
    }
    *a5 = 1;
    int v14 = 9;
    goto LABEL_27;
  }
  if (!cstdlib_strcmp(__s1, "audio/x-alaw-basic"))
  {
    *a2 = 1;
    *a3 = 8000;
    goto LABEL_36;
  }
  if (!cstdlib_strcmp(__s1, "audio/basic"))
  {
    if (a5)
    {
      *a5 = 1;
      int v14 = 7;
      goto LABEL_27;
    }
    *a2 = 2;
    *a3 = 8000;
LABEL_36:
    *a4 = 1;
    return *a2 != 0;
  }
  if (!cstdlib_strncmp(__s1, "audio/L16;", 0xAuLL))
  {
    *a4 = 2;
    uint64_t v10 = cstdlib_strchr(__s1, 59);
    if (!v10) {
      goto LABEL_40;
    }
    uint64_t v11 = v10;
    int v12 = 0;
    int v13 = 1;
    do
    {
      if (cstdlib_strncmp(v11 + 1, "endian=little;", 0xEuLL))
      {
        if (cstdlib_strncmp(v11 + 1, "endian=big;", 0xBuLL))
        {
          if (cstdlib_strncmp(v11 + 1, "rate=", 5uLL))
          {
            if (!cstdlib_strncmp(v11 + 1, "channels=", 9uLL)) {
              int v13 = (unsigned __int16)LH_atou(v11 + 10);
            }
          }
          else
          {
            *a3 = (unsigned __int16)LH_atou(v11 + 6);
          }
        }
        else
        {
          int v12 = 1;
        }
      }
      else
      {
        int v12 = 0;
      }
      uint64_t v11 = cstdlib_strchr(v11 + 1, 59);
    }
    while (v11);
    if (v13 == 1)
    {
      if (v12)
      {
        int v14 = 4;
LABEL_27:
        *a2 = v14;
        return *a2 != 0;
      }
LABEL_40:
      int v14 = 3;
      goto LABEL_27;
    }
  }
  return *a2 != 0;
}

uint64_t NistSphere2PCM(_WORD *a1, int a2, unsigned char *a3, char *a4, unsigned int a5, char *a6, void *a7, _DWORD *a8)
{
  uint64_t v113 = *MEMORY[0x263EF8340];
  uint64_t v102 = 0;
  uint64_t v103 = 0;
  uint64_t v101 = 0;
  int v100 = 0;
  memset(v112, 0, sizeof(v112));
  long long v111 = 0u;
  long long v110 = 0u;
  char v109 = 78;
  memset(v108, 0, sizeof(v108));
  long long v107 = 0u;
  long long v106 = 0u;
  qmemcpy(__s1, "pcm", sizeof(__s1));
  if (!a3) {
    return 2269126663;
  }
  uint64_t v8 = a8;
  uint64_t v9 = 2269126663;
  if (a8)
  {
    if (a7)
    {
      if (a6)
      {
        if (a5)
        {
          if (a4)
          {
            uint64_t v14 = (uint64_t)a3;
            if (*a3)
            {
              *a6 = 0;
              *a7 = 0;
              *a8 = 0;
              uint64_t inited = InitRsrcFunction(a1, a2, &v103);
              if ((inited & 0x80000000) != 0) {
                return inited;
              }
              long long v95 = a7;
              unsigned int __dst = a6;
              int v20 = 0;
              uint64_t v21 = 0;
              unsigned int v97 = a5;
              int v22 = &a4[a5];
              uint64_t v23 = -(uint64_t)a5;
              uint64_t v24 = a4;
              while (1)
              {
                if (v24 >= v22)
                {
LABEL_76:
                  log_OutPublic(*(void *)(v103 + 32), (uint64_t)"AUDIOFETCH", 109, (uint64_t)"%s%s", v16, v17, v18, v19, "url");
                  return 2269126660;
                }
                size_t v25 = 0;
                while (1)
                {
                  int v26 = v24[v25];
                  if (v26 == 10 || v26 == 13) {
                    break;
                  }
                  ++v25;
                  if (!(v23 + v24 - a4 + v25)) {
                    goto LABEL_76;
                  }
                }
                unsigned int v99 = inited;
                uint64_t v28 = &v24[v25];
                if (v20)
                {
                  if (v20 != 2)
                  {
                    if (v24 >= v28)
                    {
                      uint64_t v44 = v23;
                    }
                    else
                    {
                      uint64_t v29 = 0;
                      do
                      {
                        int v30 = v24[v29];
                        if (v30 != 32 && v30 != 9)
                        {
                          uint64_t v44 = v23;
                          v24 += v29;
                          goto LABEL_52;
                        }
                        ++v29;
                      }
                      while (v25 != v29);
                      uint64_t v44 = v23;
                      uint64_t v24 = v28;
                    }
LABEL_52:
                    int v45 = LH_atou(v24);
                    uint64_t v21 = v45;
                    if (!v45 || v45 >= a5)
                    {
                      log_OutPublic(*(void *)(v103 + 32), (uint64_t)"AUDIOFETCH", 111, (uint64_t)"%s%s%s%u", v16, v17, v18, v19, "url");
                      return 2269126660;
                    }
                    int v20 = 2;
                    uint64_t inited = v99;
                    uint64_t v23 = v44;
                    goto LABEL_62;
                  }
                  if (v24 - a4 + v25 >= v21) {
                    goto LABEL_76;
                  }
                  uint64_t v98 = v23;
                  uint64_t v38 = v21;
                  if (buf_token_strcmp("end_head", v24, (uint64_t)v28))
                  {
                    if (!buf_token_strcmp("sample_rate", v24, (uint64_t)v28))
                    {
                      uint64_t v42 = v103;
                      unsigned int v43 = (uint64_t *)((char *)&v102 + 4);
LABEL_59:
                      uint64_t inited = buf_parse_value_int(v42, v14, v24, (unint64_t)v28, v43, v39, v40, v41);
                      goto LABEL_60;
                    }
                    if (!buf_token_strcmp("sample_count", v24, (uint64_t)v28))
                    {
                      uint64_t v42 = v103;
                      unsigned int v43 = &v102;
                      goto LABEL_59;
                    }
                    if (!buf_token_strcmp("sample_sig_bits", v24, (uint64_t)v28))
                    {
                      uint64_t v42 = v103;
                      unsigned int v43 = (uint64_t *)((char *)&v101 + 4);
                      goto LABEL_59;
                    }
                    if (!buf_token_strcmp("sample_n_bytes", v24, (uint64_t)v28))
                    {
                      uint64_t v42 = v103;
                      unsigned int v43 = &v101;
                      goto LABEL_59;
                    }
                    if (!buf_token_strcmp("channel_count", v24, (uint64_t)v28))
                    {
                      uint64_t v42 = v103;
                      unsigned int v43 = (uint64_t *)&v100;
                      goto LABEL_59;
                    }
                    if (!buf_token_strcmp("sample_byte_format", v24, (uint64_t)v28))
                    {
                      uint64_t v50 = v103;
                      uint64_t v51 = &v109;
                      goto LABEL_74;
                    }
                    if (!buf_token_strcmp("sample_coding", v24, (uint64_t)v28))
                    {
                      uint64_t v50 = v103;
                      uint64_t v51 = __s1;
LABEL_74:
                      uint64_t inited = buf_parse_value_str(v50, v14, (unsigned __int8 *)v24, (unint64_t)v28, v51, v17, v18, v19);
LABEL_60:
                      int v20 = 2;
                      uint64_t v21 = v38;
                      goto LABEL_61;
                    }
                    int v20 = 2;
                  }
                  else
                  {
                    int v20 = 3;
                  }
                  uint64_t v21 = v38;
                }
                else
                {
                  uint64_t v98 = v23;
                  uint64_t v94 = v14;
                  uint64_t v32 = v8;
                  uint64_t v33 = v21;
                  size_t v34 = cstdlib_strlen("NIST_1A");
                  if (v34 > v25
                    || (size_t v35 = v34, cstdlib_strncmp("NIST_1A", v24, v34))
                    || ((int v36 = v24[v35], v36 != 10) ? (v37 = v36 == 13) : (v37 = 1), !v37))
                  {
                    log_OutPublic(*(void *)(v103 + 32), (uint64_t)"AUDIOFETCH", 110, (uint64_t)"%s%s", v16, v17, v18, v19, "url");
                    return 2269126660;
                  }
                  int v20 = 1;
                  uint64_t v21 = v33;
                  uint64_t v8 = v32;
                  uint64_t v14 = v94;
                }
                uint64_t inited = v99;
LABEL_61:
                uint64_t v23 = v98;
LABEL_62:
                if ((inited & 0x80000000) != 0) {
                  return inited;
                }
                if (v28 < v22)
                {
                  while (1)
                  {
                    unsigned int v46 = *v28;
                    BOOL v47 = v46 > 0x20;
                    uint64_t v48 = (1 << v46) & 0x100002600;
                    if (v47 || v48 == 0) {
                      break;
                    }
                    if (++v28 >= v22)
                    {
                      uint64_t v28 = v22;
                      break;
                    }
                  }
                }
                uint64_t v24 = v28;
                if (v20 == 3)
                {
                  uint64_t v53 = inited;
                  int v55 = v100;
                  int v54 = v101;
                  int v56 = v102;
                  signed int v57 = HIDWORD(v102);
                  int v58 = (int)v21;
                  log_OutText(*(void *)(v103 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"NIST SPHERE %s: %s %s, %d channels, %d HZ, %d sample sig bits, %d bytes per sample, %u data offset, %d sample count", v17, v18, v19, v14);
                  if (v55 != 1)
                  {
                    log_OutPublic(*(void *)(v103 + 32), (uint64_t)"AUDIOFETCH", 112, (uint64_t)"%s%s%s%d", v59, v60, v61, v62, "url");
                    return 2269126660;
                  }
                  if (v56 < 0)
                  {
                    log_OutPublic(*(void *)(v103 + 32), (uint64_t)"AUDIOFETCH", 119, (uint64_t)"%s%s%s%d", v59, v60, v61, v62, "url");
                    return 2269126660;
                  }
                  if (v54 <= 0)
                  {
                    log_OutPublic(*(void *)(v103 + 32), (uint64_t)"AUDIOFETCH", 120, (uint64_t)"%s%s%s%d", v59, v60, v61, v62, "url");
                    return 2269126660;
                  }
                  if (cstdlib_strcmp(__s1, "ulaw"))
                  {
                    unsigned int v71 = v97;
                    if (cstdlib_strcmp(__s1, "alaw"))
                    {
                      if (cstdlib_strcmp(__s1, "pcm"))
                      {
                        if (cstdlib_strcmp(&v109, "mu-law"))
                        {
                          if (cstdlib_strcmp(&v109, "a-law"))
                          {
                            log_OutPublic(*(void *)(v103 + 32), (uint64_t)"AUDIOFETCH", 115, (uint64_t)"%s%s%s%s%s%d%s%d%s%s", v67, v68, v69, v70, "url");
                            return 2269126660;
                          }
                          BOOL v92 = v57 == 8000 || v57 == 0;
                          if (v92 && v54 == 1)
                          {
                            cstdlib_strcpy(__dst, "audio/x-alaw-basic");
                            goto LABEL_125;
                          }
                          uint64_t v80 = *(void *)(v103 + 32);
LABEL_116:
                          log_OutPublic(v80, (uint64_t)"AUDIOFETCH", 113, (uint64_t)"%s%s%s%s%s%d%s%d", v67, v68, v69, v70, "url");
                          return 2269126660;
                        }
                        BOOL v81 = v57 == 8000 || v57 == 0;
                        if (v81 && v54 == 1)
                        {
                          long long v78 = "audio/basic";
                          long long v77 = __dst;
                          goto LABEL_124;
                        }
LABEL_128:
                        log_OutPublic(*(void *)(v103 + 32), (uint64_t)"AUDIOFETCH", 114, (uint64_t)"%s%s%s%s%s%d%s%d", v63, v64, v65, v66, "url");
                        return 2269126660;
                      }
                      if (v57 >= 1 && v54 == 2)
                      {
                        if (cstdlib_strcmp(&v109, "01"))
                        {
                          if (cstdlib_strcmp(&v109, "10"))
                          {
                            if (cstdlib_strcmp(&v109, "N") && cstdlib_strcmp(&v109, "1")) {
                              goto LABEL_114;
                            }
                            long long v93 = "audio/L16;endian=little;rate=";
                          }
                          else
                          {
                            long long v93 = "audio/L16;endian=big;rate=";
                          }
                          unsigned int v71 = v97;
                        }
                        else
                        {
                          long long v93 = "audio/L16;endian=little;rate=";
                        }
                        cstdlib_strcpy(__dst, v93);
                        LH_itoa(v57, __s2, 0xAu);
                        cstdlib_strcat(__dst, __s2);
LABEL_125:
                        if (!v56)
                        {
                          log_OutPublic(*(void *)(v103 + 32), (uint64_t)"AUDIOFETCH", 116, (uint64_t)"%s%s", v82, v83, v84, v85, "url");
                          return 2269126660;
                        }
                        size_t v86 = (v56 * v54);
                        if ((int)v86 + v58 > v71)
                        {
                          log_OutPublic(*(void *)(v103 + 32), (uint64_t)"AUDIOFETCH", 117, (uint64_t)"%s%s", v82, v83, v84, v85, "url");
                          return 2269126660;
                        }
                        long long v87 = (void *)heap_Alloc(*(void *)(v103 + 8), v86);
                        *long long v95 = v87;
                        if (v87)
                        {
                          cstdlib_memcpy(v87, &a4[v58], v86);
                          *uint64_t v8 = v86;
                          return v53;
                        }
                        else
                        {
                          log_OutPublic(*(void *)(v103 + 32), (uint64_t)"AUDIOFETCH", 118, (uint64_t)"%s%s%s%lu", v88, v89, v90, v91, "url");
                          return 2269126666;
                        }
                      }
                      else
                      {
LABEL_114:
                        uint64_t v9 = 2269126660;
                        log_OutPublic(*(void *)(v103 + 32), (uint64_t)"AUDIOFETCH", 115, (uint64_t)"%s%s%s%s%s%d%s%d%s%s", v72, v73, v74, v75, "url");
                      }
                      return v9;
                    }
                    BOOL v79 = v57 == 8000 || v57 == 0;
                    if (!v79 || v54 != 1)
                    {
                      uint64_t v80 = *(void *)(v103 + 32);
                      goto LABEL_116;
                    }
                    long long v78 = "audio/x-alaw-basic";
                    long long v77 = __dst;
                  }
                  else
                  {
                    BOOL v76 = v57 == 8000 || v57 == 0;
                    unsigned int v71 = v97;
                    long long v77 = __dst;
                    if (!v76 || v54 != 1) {
                      goto LABEL_128;
                    }
                    long long v78 = "audio/basic";
                  }
LABEL_124:
                  cstdlib_strcpy(v77, v78);
                  goto LABEL_125;
                }
              }
            }
          }
        }
      }
    }
  }
  return v9;
}

uint64_t buf_token_strcmp(const char *a1, const char *a2, uint64_t a3)
{
  size_t v6 = cstdlib_strlen(a1);
  if (v6 > a3 - (uint64_t)a2) {
    return 0xFFFFFFFFLL;
  }
  size_t v8 = v6;
  uint64_t result = cstdlib_strncmp(a1, a2, v6);
  if (!result)
  {
    unsigned int v9 = a2[v8];
    BOOL v10 = v9 > 0x20;
    uint64_t v11 = (1 << v9) & 0x100002600;
    return v10 || v11 == 0;
  }
  return result;
}

uint64_t buf_parse_value_int(uint64_t a1, uint64_t a2, const char *a3, unint64_t a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v10 = a3;
  if ((unint64_t)a3 < a4)
  {
    unint64_t v12 = a4 - (void)a3;
    while (1)
    {
      int v13 = *(unsigned __int8 *)v10;
      if (v13 == 9 || v13 == 32) {
        break;
      }
      ++v10;
      if (!--v12)
      {
        BOOL v10 = (const char *)a4;
        break;
      }
    }
  }
  if ((unint64_t)v10 >= a4)
  {
LABEL_15:
    uint64_t v17 = 2269126660;
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"AUDIOFETCH", 121, (uint64_t)"%s%s", (uint64_t)a5, a6, a7, a8, "url");
  }
  else
  {
    unint64_t v14 = a4 - (void)v10;
    while (1)
    {
      int v15 = *(unsigned __int8 *)v10;
      if (v15 != 32 && v15 != 9) {
        break;
      }
      ++v10;
      if (!--v14) {
        goto LABEL_15;
      }
    }
    if (buf_token_strcmp("-i", v10, a4))
    {
      uint64_t v17 = 2269126660;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"AUDIOFETCH", 122, (uint64_t)"%s%s", v20, v21, v22, v23, "url");
    }
    else
    {
      for (uint64_t i = (unsigned __int8 *)(v10 + 2); (unint64_t)i < a4; ++i)
      {
        int v25 = *i;
        if (v25 != 32 && v25 != 9)
        {
          uint64_t v17 = 0;
          *a5 = cstdlib_atoi(i);
          return v17;
        }
      }
      uint64_t v17 = 2269126660;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"AUDIOFETCH", 123, (uint64_t)"%s%s", v20, v21, v22, v23, "url");
    }
  }
  return v17;
}

uint64_t buf_parse_value_str(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((unint64_t)a3 < a4)
  {
    unint64_t v11 = a4 - (void)a3;
    while (1)
    {
      int v12 = *a3;
      if (v12 == 9 || v12 == 32) {
        break;
      }
      ++a3;
      if (!--v11)
      {
        a3 = (unsigned __int8 *)a4;
        break;
      }
    }
  }
  if ((unint64_t)a3 >= a4)
  {
LABEL_12:
    uint64_t v16 = 2269126660;
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"AUDIOFETCH", 124, (uint64_t)"%s%s", (uint64_t)a5, a6, a7, a8, "url");
  }
  else
  {
    unint64_t v13 = a4 - (void)a3;
    unint64_t v14 = a3 + 2;
    while (1)
    {
      int v15 = *(v14 - 2);
      if (v15 != 9 && v15 != 32) {
        break;
      }
      ++v14;
      if (!--v13) {
        goto LABEL_12;
      }
    }
    if (v15 == 45 && *(v14 - 1) == 115 && *v14 - 48 < 0xA)
    {
      int v17 = cstdlib_atoi(v14);
      if (v17 >= 63) {
        int v22 = 63;
      }
      else {
        int v22 = v17;
      }
      if ((unint64_t)v14 < a4)
      {
        while (*v14 - 48 <= 9)
        {
          if ((unint64_t)++v14 >= a4)
          {
            unint64_t v14 = (unsigned __int8 *)a4;
            break;
          }
        }
      }
      if ((unint64_t)v14 < a4)
      {
        unint64_t v23 = a4 - (void)v14;
        while (1)
        {
          int v24 = *v14;
          if (v24 != 32 && v24 != 9) {
            break;
          }
          ++v14;
          if (!--v23)
          {
            unint64_t v14 = (unsigned __int8 *)a4;
            break;
          }
        }
      }
      if ((unint64_t)&v14[v22] <= a4)
      {
        uint64_t v27 = v22;
        cstdlib_strncpy(a5, (const char *)v14, v22);
        uint64_t v16 = 0;
        a5[v27] = 0;
      }
      else
      {
        uint64_t v16 = 2269126660;
        log_OutPublic(*(void *)(a1 + 32), (uint64_t)"AUDIOFETCH", 126, (uint64_t)"%s%s", v18, v19, v20, v21, "url");
      }
    }
    else
    {
      uint64_t v16 = 2269126660;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"AUDIOFETCH", 125, (uint64_t)"%s%s", (uint64_t)a5, a6, a7, a8, "url");
    }
  }
  return v16;
}

uint64_t naudec_New(_WORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = 2269126663;
  if (a3)
  {
    uint64_t v12 = 0;
    uint64_t inited = InitRsrcFunction(a1, a2, &v12);
    if ((inited & 0x80000000) != 0)
    {
      return inited;
    }
    else
    {
      size_t v8 = (void *)heap_Alloc(*(void *)(v12 + 8), 64);
      *a3 = (uint64_t)v8;
      if (v8)
      {
        *size_t v8 = a1;
        v8[1] = a2;
        unsigned int v9 = (_WORD **)*a3;
        *((_OWORD *)v9 + 2) = 0u;
        *((_OWORD *)v9 + 3) = 0u;
        *((_OWORD *)v9 + 1) = 0u;
        uint64_t v10 = nauread_New(*v9, (uint64_t)v9[1], (uint64_t *)v9 + 2);
        if ((v10 & 0x80000000) != 0)
        {
          uint64_t v3 = v10;
LABEL_10:
          naudec_Destroy(a3);
          return v3;
        }
        uint64_t v3 = genidec_New(*v9, (uint64_t)v9[1], v9 + 3);
        if ((v3 & 0x80000000) != 0) {
          goto LABEL_10;
        }
      }
      else
      {
        return 2269126666;
      }
    }
  }
  return v3;
}

uint64_t naudec_Destroy(uint64_t *a1)
{
  uint64_t v1 = 2269126663;
  if (a1)
  {
    uint64_t v3 = *a1;
    if (*a1)
    {
      uint64_t v10 = 0;
      uint64_t inited = InitRsrcFunction(*(_WORD **)v3, *(void *)(v3 + 8), &v10);
      if ((inited & 0x80000000) != 0)
      {
        return inited;
      }
      else
      {
        uint64_t v5 = *a1;
        if (*(void *)(*a1 + 16)) {
          uint64_t v1 = nauread_Destroy((uint64_t *)(*a1 + 16));
        }
        else {
          uint64_t v1 = 0;
        }
        uint64_t v7 = *(void *)(v5 + 24);
        size_t v6 = (uint64_t *)(v5 + 24);
        if (v7)
        {
          unsigned int v8 = genidec_Destroy(v6);
          if ((int)v1 >= 0) {
            uint64_t v1 = v8;
          }
          else {
            uint64_t v1 = v1;
          }
        }
        heap_Free(*(void **)(v10 + 8), *a1);
        *a1 = 0;
      }
    }
  }
  return v1;
}

uint64_t naudec_OpenInputMemory(uint64_t a1, const char *a2, uint64_t a3, int a4)
{
  uint64_t result = 2269126663;
  if (a1)
  {
    if (*(void *)(a1 + 16))
    {
      uint64_t result = nauread_ExtOpen(*(void *)(a1 + 16), "memory", a2, a3, a4);
      if ((result & 0x80000000) == 0)
      {
        uint64_t v6 = *(void *)(a1 + 16);
        return nauread_ReadHeader(v6);
      }
    }
  }
  return result;
}

uint64_t naudec_GetContentType(uint64_t a1, char *a2, size_t a3)
{
  if (a1 && *(void *)(a1 + 24)) {
    return nauread_GetContentType(*(void *)(a1 + 16), a2, a3);
  }
  else {
    return 2269126663;
  }
}

uint64_t naudec_Decode(_WORD **a1, uint64_t *a2, _DWORD *a3)
{
  unsigned __int16 v37 = 0;
  uint64_t v36 = 0;
  uint64_t Info = nauread_GetInfo((uint64_t)a1[2], 0, &v37, 0, &v36);
  if ((Info & 0x80000000) != 0) {
    return Info;
  }
  unint64_t v7 = (unint64_t)v37 >> 3;
  uint64_t v8 = (v36 * v7);
  *a3 = v8;
  size_t v38 = 0;
  *a2 = 0;
  uint64_t Info = InitRsrcFunction(*a1, (int)a1[1], &v38);
  if ((Info & 0x80000000) != 0) {
    return Info;
  }
  uint64_t v9 = 2269126666;
  uint64_t v10 = heap_Alloc(*(void *)(v38 + 8), v8);
  *a2 = v10;
  if (!v10) {
    return v9;
  }
  uint64_t v11 = v10;
  unint64_t v12 = *a3;
  uint64_t Info = nauread_BeginReadData((uint64_t)a1[2]);
  if ((Info & 0x80000000) != 0) {
    return Info;
  }
  int v35 = 0;
  size_t v33 = 0;
  unint64_t v34 = 0;
  int v13 = genidec_RequestSamples(a1[3], 0, 1000, &v35, (uint64_t *)&v34, &v33);
  LODWORD(v14) = v13;
  if (v13 < 0 || v13 == 6 || !v12)
  {
LABEL_27:
    unsigned int Data = nauread_EndReadData((uint64_t)a1[2]);
    if (v14 == 6) {
      return Data;
    }
    else {
      return v14;
    }
  }
  int v15 = 0;
  while (1)
  {
    size_t v16 = v33;
    unint64_t v17 = v34;
    if ((unint64_t)a1[5] >= v33) {
      goto LABEL_13;
    }
    size_t v38 = 0;
    uint64_t inited = InitRsrcFunction(*a1, (int)a1[1], &v38);
    if ((inited & 0x80000000) != 0) {
      break;
    }
    uint64_t v19 = heap_Realloc(*(uint64_t **)(v38 + 8), (uint64_t)a1[4], v16);
    a1[4] = (_WORD *)v19;
    if (!v19) {
      goto LABEL_34;
    }
    a1[5] = (_WORD *)v16;
LABEL_13:
    size_t v38 = 0;
    uint64_t v21 = a1[6];
    size_t v20 = (size_t)a1[7];
    unint64_t v22 = v17 - (void)v21;
    if ((_WORD *)v17 == v21)
    {
      size_t v23 = v16 - v20;
      if (v16 <= v20) {
        goto LABEL_23;
      }
    }
    else
    {
      size_t v24 = (size_t)v21 + v20;
      if ((unint64_t)v21 + v20 <= v17)
      {
        if ((_WORD *)((char *)v21 + v20) != (_WORD *)v17)
        {
          uint64_t v14 = 2269126660;
          goto LABEL_35;
        }
        uint64_t v14 = nauread_ReadData((uint64_t)a1[2], a1[4], v16, &v38);
        a1[6] = (_WORD *)v17;
        size_t v20 = v38;
        goto LABEL_22;
      }
      size_t v25 = v16 + v17;
      cstdlib_memmove(a1[4], (char *)a1[4] + v22, v20 - v22);
      size_t v20 = (size_t)a1[7] - v22;
      a1[6] = (_WORD *)v17;
      a1[7] = (_WORD *)v20;
      size_t v23 = v25 - v24;
      if (v25 == v24) {
        goto LABEL_23;
      }
    }
    uint64_t v14 = nauread_ReadData((uint64_t)a1[2], (char *)a1[4] + v20, v23, &v38);
    size_t v20 = (size_t)a1[7] + v38;
LABEL_22:
    a1[7] = (_WORD *)v20;
    if ((v14 & 0x80000000) != 0) {
      goto LABEL_35;
    }
LABEL_23:
    size_t v38 = v20;
    int v32 = v12 / v7;
    uint64_t v26 = genidec_Decode(a1[3], (uint64_t)a1[4], &v38, v11, (uint64_t)&v32);
    if ((v26 & 0x80000000) != 0)
    {
      uint64_t v14 = v26;
      goto LABEL_35;
    }
    int v27 = v32;
    v15 += v32;
    int v28 = genidec_RequestSamples(a1[3], v15, 1000, &v35, (uint64_t *)&v34, &v33);
    LODWORD(v14) = v28;
    if ((v28 & 0x80000000) == 0 && v28 != 6)
    {
      uint64_t v29 = (v27 * v7);
      v11 += v29;
      v12 -= v29;
      if (v12) {
        continue;
      }
    }
    goto LABEL_27;
  }
  uint64_t v9 = inited;
LABEL_34:
  uint64_t v14 = v9;
LABEL_35:
  nauread_EndReadData((uint64_t)a1[2]);
  return v14;
}

uint64_t NuanceAudio2PCM(_WORD *a1, uint64_t a2, const char *a3, uint64_t a4, int a5, char *a6, size_t a7, uint64_t *a8, _DWORD *a9)
{
  uint64_t v9 = 2269126663;
  if (a3)
  {
    BOOL v15 = !a9 || a8 == 0;
    BOOL v16 = v15 || a6 == 0;
    BOOL v17 = v16 || a5 == 0;
    BOOL v18 = v17 || a4 == 0;
    if (!v18 && *a3 != 0)
    {
      size_t v25 = 0;
      *a6 = 0;
      *a8 = 0;
      *a9 = 0;
      uint64_t v21 = naudec_New(a1, a2, (uint64_t *)&v25);
      if ((v21 & 0x80000000) == 0)
      {
        if ((naudec_OpenInputMemory((uint64_t)v25, a3, a4, a5) & 0x80000000) == 0)
        {
          if (v25)
          {
            if (v25[3])
            {
              if ((nauread_GetContentType((uint64_t)v25[2], a6, a7) & 0x80000000) == 0)
              {
                if (v25)
                {
                  unint64_t v22 = v25[3];
                  if (v22)
                  {
                    if ((nauread_OpenDecoder((uint64_t)v25[2], v22) & 0x80000000) == 0)
                    {
                      naudec_Decode(v25, a8, a9);
                      if (v25)
                      {
                        size_t v23 = v25[3];
                        if (v23) {
                          genidec_Close(v23);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return naudec_Destroy((uint64_t *)&v25);
      }
      return v21;
    }
  }
  return v9;
}

uint64_t genidec_New(_WORD *a1, uint64_t a2, void *a3)
{
  if (!a3) {
    return 2269126663;
  }
  uint64_t v11 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v11);
  if ((inited & 0x80000000) == 0)
  {
    unint64_t v7 = (void *)heap_Alloc(*(void *)(v11 + 8), 40);
    *a3 = v7;
    if (v7)
    {
      *unint64_t v7 = a1;
      v7[1] = a2;
      uint64_t v8 = (void *)*a3;
      v8[2] = 0;
      v8[3] = safeh_GetNullHandle();
      v8[4] = v9;
    }
    else
    {
      return 2269126666;
    }
  }
  return inited;
}

uint64_t genidec_Destroy(uint64_t *a1)
{
  uint64_t inited = 2269126663;
  if (a1)
  {
    uint64_t v3 = *a1;
    if (*a1)
    {
      uint64_t v5 = 0;
      uint64_t inited = InitRsrcFunction(*(_WORD **)v3, *(void *)(v3 + 8), &v5);
      if ((inited & 0x80000000) == 0)
      {
        heap_Free(*(void **)(v5 + 8), *a1);
        *a1 = 0;
      }
    }
  }
  return inited;
}

uint64_t genidec_Open(void *a1, char *__s1, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 2269126676;
  if (!a1) {
    return 2269126663;
  }
  if (a1[2]) {
    return 2269126673;
  }
  if (!cstdlib_strcmp(__s1, "vssq5"))
  {
    if (a3 > 15999)
    {
      if (a3 == 16000) {
        goto LABEL_20;
      }
      int v11 = 22050;
    }
    else
    {
      if (a3 == 8000) {
        goto LABEL_20;
      }
      int v11 = 11025;
    }
    if (a3 != v11) {
      return v5;
    }
    goto LABEL_20;
  }
  if (cstdlib_strcmp(__s1, "rhelp")) {
    return v5;
  }
  if (a3 > 15999)
  {
    if (a3 != 22050 && a3 != 16000) {
      return v5;
    }
  }
  else if (a3 != 8000 && a3 != 11025)
  {
    return v5;
  }
LABEL_20:
  uint64_t v14 = 0;
  uint64_t inited = InitRsrcFunction((_WORD *)*a1, a1[1], &v14);
  if ((inited & 0x80000000) == 0)
  {
    uint64_t inited = brk_InterfaceQuery(*(void *)(v14 + 24));
    if ((inited & 0x80000000) == 0) {
      return (*(uint64_t (**)(void, void, uint64_t, uint64_t, void *))(a1[2] + 32))(*a1, a1[1], a4, a5, a1 + 3);
    }
  }
  return inited;
}

uint64_t genidec_Close(void *a1)
{
  uint64_t result = 2269126663;
  if (a1)
  {
    uint64_t v3 = a1[2];
    if (v3)
    {
      uint64_t v4 = (*(uint64_t (**)(void, void))(v3 + 40))(a1[3], a1[4]);
      a1[2] = 0;
      a1[3] = safeh_GetNullHandle();
      a1[4] = v5;
      return v4;
    }
    else
    {
      return 2269126673;
    }
  }
  return result;
}

uint64_t genidec_RequestSamples(void *a1, int a2, int a3, _DWORD *a4, uint64_t *a5, void *a6)
{
  uint64_t result = 2269126663;
  if (a1 && a4 && a5 && a6)
  {
    uint64_t v11 = a1[2];
    if (v11)
    {
      int v15 = a3;
      int v16 = a2;
      uint64_t v12 = *a5;
      unsigned int v13 = 0;
      unsigned int v14 = v12;
      uint64_t result = (*(uint64_t (**)(void, void, int *, int *, void, unsigned int *, unsigned int *))(v11 + 104))(a1[3], a1[4], &v16, &v15, 0, &v14, &v13);
      *a4 = v15;
      *a5 = v14;
      *a6 = v13;
    }
    else
    {
      return 2269126673;
    }
  }
  return result;
}

uint64_t genidec_Decode(void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = 2269126663;
  if (a1 && a2 && a3 && a4 && a5)
  {
    uint64_t v8 = a1[2];
    if (v8)
    {
      unsigned int v9 = *a3;
      uint64_t result = (*(uint64_t (**)(void, void, uint64_t, unsigned int *, uint64_t))(v8 + 112))(a1[3], a1[4], a2, &v9, a4);
      *a3 = v9;
    }
    else
    {
      return 2269126673;
    }
  }
  return result;
}

uint64_t nauread_New(_WORD *a1, uint64_t a2, uint64_t *a3)
{
  if (!a3) {
    return 2269126663;
  }
  uint64_t v10 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v10);
  if ((inited & 0x80000000) == 0)
  {
    unint64_t v7 = (void *)heap_Alloc(*(void *)(v10 + 8), 96);
    *a3 = (uint64_t)v7;
    if (v7)
    {
      *unint64_t v7 = a1;
      v7[1] = a2;
      uint64_t v8 = *a3;
      *(void *)(v8 + 16) = 0;
      *(_DWORD *)(v8 + 24) = 0;
      *(_WORD *)(v8 + 28) = 0;
      cstdlib_memset((void *)(v8 + 30), 0, 0x20uLL);
      *(_DWORD *)(v8 + 64) = 0;
      *(void *)(v8 + 80) = 0;
      *(void *)(v8 + 88) = 0;
      *(void *)(v8 + 72) = 0;
    }
    else
    {
      return 2269126666;
    }
  }
  return inited;
}

uint64_t nauread_Destroy(uint64_t *a1)
{
  uint64_t v1 = 2269126663;
  if (a1)
  {
    uint64_t v3 = *a1;
    if (*a1)
    {
      uint64_t v13 = 0;
      uint64_t inited = InitRsrcFunction(*(_WORD **)v3, *(void *)(v3 + 8), &v13);
      if ((inited & 0x80000000) != 0)
      {
        return inited;
      }
      else
      {
        uint64_t v1 = nauread_Close(*a1, v5, v6, v7, v8, v9, v10, v11);
        heap_Free(*(void **)(v13 + 8), *a1);
        *a1 = 0;
      }
    }
  }
  return v1;
}

uint64_t nauread_Close(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 2269126663;
  }
  uint64_t result = *(void *)(a1 + 16);
  if (result)
  {
    uint64_t v10 = ssftriff_reader_ObjClose((void *)result, a2, a3, a4, a5, a6, a7, a8);
    *(void *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 28) = 0;
    cstdlib_memset((void *)(a1 + 30), 0, 0x20uLL);
    *(_DWORD *)(a1 + 64) = 0;
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 72) = 0;
    return v10;
  }
  return result;
}

uint64_t nauread_Open(uint64_t a1, const char *a2)
{
  uint64_t result = 2269126663;
  if (a1)
  {
    if (*(void *)(a1 + 16)) {
      return 2269126673;
    }
    else {
      return ssftriff_reader_ObjOpen(*(_WORD **)a1, *(void *)(a1 + 8), 1, a2, "NUAU", 0, (uint64_t *)(a1 + 16));
    }
  }
  return result;
}

uint64_t nauread_ExtOpen(uint64_t a1, char *__s1, const char *a3, uint64_t a4, int a5)
{
  uint64_t result = 2269126663;
  if (a1)
  {
    if (*(void *)(a1 + 16))
    {
      return 2269126673;
    }
    else
    {
      if (cstdlib_strcmp(__s1, "broker"))
      {
        if (cstdlib_strcmp(__s1, "file")) {
          uint64_t v11 = 4 * (cstdlib_strcmp(__s1, "memory") == 0);
        }
        else {
          uint64_t v11 = 1;
        }
      }
      else
      {
        uint64_t v11 = 0;
      }
      return ssftriff_reader_ObjOpenEx(*(_WORD **)a1, *(void *)(a1 + 8), v11, a3, a4, a5, "NUAU", 0, (uint64_t *)(a1 + 16));
    }
  }
  return result;
}

uint64_t nauread_ReadHeader(uint64_t a1)
{
  int v1 = -2025840636;
  if (!a1) {
    return 2269126663;
  }
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3) {
    return 2269126673;
  }
  LODWORD(__src) = 0;
  uint64_t result = ssftriff_reader_FindChunk(v3, "NAUH", 0, (unsigned int *)&__src, 0);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  uint64_t v13 = 0;
  __src = 0;
  int v5 = nauread_OpenChunk(a1, "NAUF", &__src, &v13);
  if (v5 < 0) {
    goto LABEL_21;
  }
  if ((unint64_t)v13 > 5)
  {
    uint64_t v6 = __src;
    *(_DWORD *)(a1 + 24) = *(_DWORD *)__src;
    *(_WORD *)(a1 + 28) = *((_WORD *)v6 + 2);
    int v5 = ssftriff_reader_CloseChunk(*(void *)(a1 + 16));
    if (v5 < 0) {
      goto LABEL_21;
    }
    uint64_t v13 = 0;
    __src = 0;
    int v5 = nauread_OpenChunk(a1, "NAUX", &__src, &v13);
    if (v5 < 0) {
      goto LABEL_21;
    }
    if ((unint64_t)v13 > 3)
    {
      *(void *)(a1 + 80) = *(unsigned int *)__src;
      int v5 = ssftriff_reader_CloseChunk(*(void *)(a1 + 16));
      if (v5 < 0) {
        goto LABEL_21;
      }
      uint64_t v13 = 0;
      __src = 0;
      int v5 = nauread_OpenChunk(a1, "NAUC", &__src, &v13);
      if (v5 < 0) {
        goto LABEL_21;
      }
      if ((unint64_t)v13 < 0x20)
      {
        cstdlib_strcpy((char *)(a1 + 30), __src);
        int v5 = ssftriff_reader_CloseChunk(*(void *)(a1 + 16));
        if (v5 < 0) {
          goto LABEL_21;
        }
        unint64_t v12 = 0;
        uint64_t v13 = 0;
        int v5 = nauread_OpenChunk(a1, "NAUI", &v13, &v12);
        if (v5 < 0) {
          goto LABEL_21;
        }
        unint64_t v7 = v12;
        if (v12 >= 4)
        {
          uint64_t v8 = *v13;
          *(_DWORD *)(a1 + 64) = v8;
          if (v7 >= (v8 + 4))
          {
            __src = 0;
            int inited = InitRsrcFunction(*(_WORD **)a1, *(void *)(a1 + 8), &__src);
            if (inited < 0)
            {
              int v1 = inited;
            }
            else
            {
              uint64_t v10 = *(void *)(a1 + 72);
              if (v10)
              {
                heap_Free(*((void **)__src + 1), v10);
                *(void *)(a1 + 72) = 0;
              }
              uint64_t v11 = (void *)heap_Alloc(*((void *)__src + 1), v8);
              *(void *)(a1 + 72) = v11;
              if (v11)
              {
                cstdlib_memcpy(v11, v13 + 1, *(unsigned int *)(a1 + 64));
                int v5 = ssftriff_reader_CloseChunk(*(void *)(a1 + 16));
LABEL_21:
                int v1 = v5;
                goto LABEL_27;
              }
              int v1 = -2025840630;
            }
          }
        }
      }
    }
  }
  ssftriff_reader_CloseChunk(*(void *)(a1 + 16));
LABEL_27:
  LODWORD(result) = ssftriff_reader_CloseChunk(*(void *)(a1 + 16));
  if (v1 >= 0) {
    return result;
  }
  else {
    return v1;
  }
}

uint64_t nauread_GetContentType(uint64_t a1, char *a2, size_t a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v3 = 2269126665;
  if (!a1) {
    return 2269126663;
  }
  if (!*(void *)(a1 + 16)) {
    return 2269126673;
  }
  if (a3)
  {
    *a2 = 0;
    size_t v7 = cstdlib_strlen("audio/L");
    BOOL v8 = a3 > v7;
    size_t v9 = a3 - v7;
    if (v8)
    {
      if (cstdlib_strcat(a2, "audio/L"))
      {
        LH_itoa(*(unsigned __int16 *)(a1 + 28), __s, 0xAu);
        size_t v10 = cstdlib_strlen(__s);
        BOOL v8 = v9 > v10;
        size_t v11 = v9 - v10;
        if (v8)
        {
          if (cstdlib_strcat(a2, __s))
          {
            size_t v12 = cstdlib_strlen(";endian=little;rate=");
            BOOL v8 = v11 > v12;
            size_t v13 = v11 - v12;
            if (v8)
            {
              if (cstdlib_strcat(a2, ";endian=little;rate="))
              {
                LH_itoa(*(_DWORD *)(a1 + 24), __s, 0xAu);
                if (cstdlib_strlen(__s) < v13)
                {
                  if (cstdlib_strcat(a2, __s)) {
                    return 0;
                  }
                  else {
                    return 2269126665;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v3;
}

uint64_t nauread_GetInfo(uint64_t a1, _DWORD *a2, _WORD *a3, void *a4, void *a5)
{
  uint64_t v5 = 2269126663;
  if (a1)
  {
    if (*(void *)(a1 + 16))
    {
      if (a2) {
        *a2 = *(_DWORD *)(a1 + 24);
      }
      if (a3) {
        *a3 = *(_WORD *)(a1 + 28);
      }
      if (a4) {
        *a4 = a1 + 30;
      }
      uint64_t v5 = 0;
      if (a5) {
        *a5 = *(void *)(a1 + 80);
      }
    }
    else
    {
      return 2269126673;
    }
  }
  return v5;
}

uint64_t nauread_OpenDecoder(uint64_t a1, void *a2)
{
  uint64_t result = 2269126663;
  if (a1)
  {
    if (*(void *)(a1 + 16)) {
      return genidec_Open(a2, (char *)(a1 + 30), *(_DWORD *)(a1 + 24), *(void *)(a1 + 72), *(unsigned int *)(a1 + 64));
    }
    else {
      return 2269126673;
    }
  }
  return result;
}

uint64_t nauread_BeginReadData(uint64_t a1)
{
  uint64_t result = 2269126663;
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      unsigned int v4 = 0;
      uint64_t result = ssftriff_reader_FindChunk(v3, "NAUD", 0, &v4, 0);
      *(void *)(a1 + 88) = v4;
    }
    else
    {
      return 2269126673;
    }
  }
  return result;
}

uint64_t nauread_EndReadData(uint64_t a1)
{
  uint64_t result = 2269126663;
  if (a1)
  {
    if (*(void *)(a1 + 16))
    {
      uint64_t result = ssftriff_reader_CloseChunk(*(void *)(a1 + 16));
      *(void *)(a1 + 88) = 0;
    }
    else
    {
      return 2269126673;
    }
  }
  return result;
}

uint64_t nauread_ReadData(uint64_t a1, void *a2, size_t a3, size_t *a4)
{
  uint64_t v4 = 2269126663;
  if (a4)
  {
    *a4 = 0;
    if (a1)
    {
      uint64_t v7 = *(void *)(a1 + 16);
      if (v7)
      {
        if (*(void *)(a1 + 88) >= a3) {
          size_t v8 = a3;
        }
        else {
          size_t v8 = *(void *)(a1 + 88);
        }
        if (v8)
        {
          __src = 0;
          uint64_t ChunkData = ssftriff_reader_GetChunkData(v7, v8, &__src);
          if ((ChunkData & 0x80000000) != 0)
          {
            return ChunkData;
          }
          else
          {
            uint64_t v4 = ssftriff_reader_Seek(*(void *)(a1 + 16), v8, 1);
            if ((v4 & 0x80000000) == 0)
            {
              cstdlib_memcpy(a2, __src, v8);
              *a4 = v8;
              *(void *)(a1 + 88) -= v8;
            }
          }
        }
        else
        {
          return 6;
        }
      }
      else
      {
        return 2269126673;
      }
    }
  }
  return v4;
}

uint64_t nauread_OpenChunk(uint64_t a1, const char *a2, void *a3, void *a4)
{
  unsigned int v10 = 0;
  char v9 = 0;
  *(_DWORD *)long long __s1 = 0;
  unsigned int v6 = ssftriff_reader_OpenChunk(*(void *)(a1 + 16), (__int32 *)__s1, &v10, a3);
  *a4 = v10;
  if (cstdlib_strcmp(__s1, a2)) {
    return 2269126660;
  }
  else {
    return v6;
  }
}

uint64_t spxrsmp_resampler_init(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, unsigned int a5, int *a6)
{
  return spxrsmp_resampler_init_frac(a1, a2, a3, a4, a3, a4, a5, a6);
}

uint64_t spxrsmp_resampler_init_frac(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, int a5, int a6, unsigned int a7, int *a8)
{
  if (a7 >= 0xB)
  {
    uint64_t v9 = 0;
    if (a8)
    {
      int v10 = 3;
LABEL_21:
      *a8 = v10;
      return v9;
    }
    return v9;
  }
  uint64_t v9 = heap_Calloc(*(void **)(a1 + 8), 136, 1);
  if (!v9)
  {
LABEL_19:
    if (a8)
    {
      int v10 = 1;
      goto LABEL_21;
    }
    return v9;
  }
  BOOL v18 = *(void **)(a1 + 8);
  *(void *)(v9 + 60) = 0;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  *(void *)uint64_t v9 = v18;
  *(_DWORD *)(v9 + 112) = 0;
  *(void *)(v9 + 32) = 0;
  *(void *)(v9 + 96) = 0;
  *(void *)(v9 + 120) = 0;
  *(_DWORD *)(v9 + 52) = 1065353216;
  *(_DWORD *)(v9 + 24) = -1;
  *(_DWORD *)(v9 + 28) = a2;
  *(_DWORD *)(v9 + 40) = 160;
  uint64_t v19 = (int)(4 * a2);
  *(void *)(v9 + 128) = 0x100000001;
  uint64_t v20 = heap_Calloc(v18, v19, 1);
  *(void *)(v9 + 72) = v20;
  if (!v20)
  {
LABEL_18:
    heap_Free(*(void **)(a1 + 8), v9);
    uint64_t v9 = 0;
    goto LABEL_19;
  }
  uint64_t v21 = heap_Calloc(*(void **)v9, v19, 1);
  *(void *)(v9 + 88) = v21;
  unint64_t v22 = *(void **)v9;
  if (!v21)
  {
LABEL_17:
    heap_Free(v22, *(void *)(v9 + 72));
    goto LABEL_18;
  }
  size_t v23 = (_DWORD *)heap_Calloc(v22, v19, 1);
  *(void *)(v9 + 80) = v23;
  if (!v23)
  {
    heap_Free(*(void **)v9, *(void *)(v9 + 88));
    unint64_t v22 = *(void **)v9;
    goto LABEL_17;
  }
  if (a2)
  {
    size_t v24 = *(_DWORD **)(v9 + 72);
    size_t v25 = *(_DWORD **)(v9 + 88);
    uint64_t v26 = a2;
    do
    {
      *v24++ = 0;
      *v25++ = 0;
      *v23++ = 0;
      --v26;
    }
    while (v26);
  }
  if (*(_DWORD *)(v9 + 24) != a7)
  {
    *(_DWORD *)(v9 + 24) = a7;
    if (*(_DWORD *)(v9 + 60)) {
      update_filter((void **)v9);
    }
  }
  spxrsmp_resampler_set_rate_frac(v9, a3, a4, a5, a6);
  update_filter((void **)v9);
  *(_DWORD *)(v9 + 60) = 1;
  if (a8)
  {
    int v10 = 0;
    goto LABEL_21;
  }
  return v9;
}

uint64_t spxrsmp_resampler_set_quality(uint64_t a1, unsigned int a2)
{
  if (a2 > 0xA) {
    return 3;
  }
  if (*(_DWORD *)(a1 + 24) != a2)
  {
    *(_DWORD *)(a1 + 24) = a2;
    if (*(_DWORD *)(a1 + 60)) {
      update_filter((void **)a1);
    }
  }
  return 0;
}

uint64_t spxrsmp_resampler_set_rate_frac(uint64_t a1, unsigned int a2, uint64_t a3, int a4, int a5)
{
  if (*(_DWORD *)(a1 + 8) != a4
    || *(_DWORD *)(a1 + 12) != a5
    || *(_DWORD *)(a1 + 16) != a2
    || *(_DWORD *)(a1 + 20) != a3)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 8) = a4;
    *(_DWORD *)(a1 + 12) = a5;
    *(_DWORD *)(a1 + 16) = a2;
    *(_DWORD *)(a1 + 20) = a3;
    if (a2 >= a3) {
      unsigned int v6 = a3;
    }
    else {
      unsigned int v6 = a2;
    }
    if (v6 >= 2)
    {
      unsigned int v12 = 2;
      do
      {
        if (!(a2 % v12))
        {
          while (1)
          {
            uint64_t v13 = a3 / v12;
            if (a3 % v12) {
              break;
            }
            a2 /= v12;
            *(_DWORD *)(a1 + 16) = a2;
            *(_DWORD *)(a1 + 20) = v13;
            a3 = a3 / v12;
            if (a2 % v12) {
              goto LABEL_21;
            }
          }
        }
        uint64_t v13 = a3;
LABEL_21:
        ++v12;
        if (a2 >= v13) {
          unsigned int v14 = v13;
        }
        else {
          unsigned int v14 = a2;
        }
        a3 = v13;
      }
      while (v12 <= v14);
    }
    if (v5 && *(_DWORD *)(a1 + 28))
    {
      unint64_t v7 = 0;
      uint64_t v8 = *(void *)(a1 + 80);
      do
      {
        unsigned int v9 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(v8 + 4 * v7) / v5;
        *(_DWORD *)(v8 + 4 * v7) = v9;
        unsigned int v10 = *(_DWORD *)(a1 + 20);
        if (v9 >= v10) {
          *(_DWORD *)(v8 + 4 * v7) = v10 - 1;
        }
        ++v7;
      }
      while (v7 < *(unsigned int *)(a1 + 28));
    }
    if (*(_DWORD *)(a1 + 60)) {
      update_filter((void **)a1);
    }
  }
  return 0;
}

void update_filter(void **a1)
{
  unsigned int v2 = *((_DWORD *)a1 + 8);
  int v3 = *((_DWORD *)a1 + 6);
  uint64_t v4 = (unsigned int *)((char *)&quality_map + 24 * v3);
  unsigned int v6 = *v4;
  unsigned int v5 = v4[1];
  *((_DWORD *)a1 + 14) = v5;
  *((_DWORD *)a1 + 8) = v6;
  unsigned int v8 = *((_DWORD *)a1 + 4);
  unsigned int v7 = *((_DWORD *)a1 + 5);
  if (v8 <= v7)
  {
    *((_DWORD *)a1 + 13) = *((_DWORD *)&quality_map + 6 * v3 + 3);
  }
  else
  {
    unsigned int v9 = v8 * v6 / v7 - 1;
    unsigned int v10 = v5 >> (2 * v7 < v8) >> (4 * v7 < v8) >> (8 * v7 < v8) >> (16 * v7 < v8);
    size_t v11 = (float *)((char *)&quality_map + 24 * v3);
    if (v10 <= 1) {
      unsigned int v5 = 1;
    }
    else {
      unsigned int v5 = v5 >> (2 * v7 < v8) >> (4 * v7 < v8) >> (8 * v7 < v8) >> (16 * v7 < v8);
    }
    *((float *)a1 + 13) = (float)(v11[2] * (float)v7) / (float)v8;
    unsigned int v6 = (v9 & 0xFFFFFFF8) + 8;
    *((_DWORD *)a1 + 8) = v6;
    if (4 * v7 < v8
      || (v10 ? (BOOL v12 = 2 * v7 >= v8) : (BOOL v12 = 0),
          v12 ? (BOOL v13 = 8 * v7 >= v8) : (BOOL v13 = 0),
          v13 ? (BOOL v14 = 16 * v7 >= v8) : (BOOL v14 = 0),
          !v14))
    {
      *((_DWORD *)a1 + 14) = v5;
    }
  }
  uint64_t v15 = (uint64_t)a1[13];
  if (v7 > 16 * v5 + 128)
  {
    if (v15)
    {
      unsigned int v16 = v6 * v5 + 8;
      if (*((_DWORD *)a1 + 28) >= v16)
      {
LABEL_27:
        unsigned int v19 = *((_DWORD *)a1 + 14);
        unsigned int v20 = *((_DWORD *)a1 + 8);
        int v21 = v20 * v19 + 4;
        BOOL v18 = resampler_basic_interpolate_single;
        if (v21 >= -3)
        {
          uint64_t v22 = 0;
          float v23 = *((float *)a1 + 13);
          float v24 = (float)v19;
          uint64_t v25 = *((void *)&quality_map + 3 * *((int *)a1 + 6) + 2);
          uint64_t v26 = v21 + 4;
          do
          {
            *(_WORD *)(v15 + 2 * v22) = sinc(v20, v25, v23, (float)((float)(v22 - 4) / v24) - (float)(v20 >> 1));
            ++v22;
            BOOL v18 = resampler_basic_interpolate_single;
          }
          while (v26 != v22);
        }
        goto LABEL_43;
      }
      uint64_t v15 = heap_Realloc(*a1, (uint64_t)a1[13], (int)(2 * v16));
      a1[13] = (void *)v15;
      *((_DWORD *)a1 + 28) = *((_DWORD *)a1 + 14) * *((_DWORD *)a1 + 8) + 8;
    }
    else
    {
      uint64_t v15 = heap_Calloc(*a1, (int)(2 * v5 * v6 + 16), 1);
      a1[13] = (void *)v15;
    }
    BOOL v18 = resampler_basic_interpolate_single;
    if (!v15) {
      goto LABEL_43;
    }
    goto LABEL_27;
  }
  if (!v15)
  {
    uint64_t v15 = heap_Calloc(*a1, (int)(2 * v7 * v6), 1);
    a1[13] = (void *)v15;
LABEL_32:
    BOOL v18 = resampler_basic_direct_single;
    if (!v15) {
      goto LABEL_43;
    }
    goto LABEL_33;
  }
  unsigned int v17 = v6 * v7;
  if (*((_DWORD *)a1 + 28) < v17)
  {
    uint64_t v15 = heap_Realloc(*a1, (uint64_t)a1[13], (int)(2 * v17));
    a1[13] = (void *)v15;
    *((_DWORD *)a1 + 28) = *((_DWORD *)a1 + 5) * *((_DWORD *)a1 + 8);
    goto LABEL_32;
  }
LABEL_33:
  unsigned int v27 = *((_DWORD *)a1 + 5);
  BOOL v18 = resampler_basic_direct_single;
  if (v27)
  {
    unsigned int v80 = v2;
    int v28 = 0;
    unsigned int v29 = 0;
    uint64_t v30 = *((unsigned int *)a1 + 8);
    if ((int)v30 >= 0) {
      int v31 = *((_DWORD *)a1 + 8);
    }
    else {
      int v31 = v30 + 1;
    }
    int v32 = 1 - (v31 >> 1);
    do
    {
      if (v30)
      {
        uint64_t v33 = 0;
        float v34 = *((float *)a1 + 13);
        uint64_t v35 = *((void *)&quality_map + 3 * *((int *)a1 + 6) + 2);
        do
        {
          *(_WORD *)(v15 + 2 * (v28 + v33)) = sinc(v30, v35, v34, (float)(v32 + v33) - (float)((float)v29 / (float)v27));
          ++v33;
        }
        while (v30 != v33);
      }
      ++v29;
      v28 += v30;
      BOOL v18 = resampler_basic_direct_single;
    }
    while (v29 != v27);
    unsigned int v2 = v80;
  }
LABEL_43:
  a1[15] = v18;
  unsigned int v36 = *((_DWORD *)a1 + 4);
  unsigned int v37 = *((_DWORD *)a1 + 5);
  *((_DWORD *)a1 + 11) = v36 / v37;
  *((_DWORD *)a1 + 12) = v36 % v37;
  uint64_t v38 = (uint64_t)a1[12];
  if (!v38)
  {
    int v67 = *((_DWORD *)a1 + 7);
    int v68 = *((_DWORD *)a1 + 8) + *((_DWORD *)a1 + 10) - 1;
    *((_DWORD *)a1 + 9) = v68;
    uint64_t v69 = (void *)heap_Calloc(*a1, 2 * v68 * v67, 1);
LABEL_78:
    a1[12] = v69;
    if (v69)
    {
      unsigned int v71 = *((_DWORD *)a1 + 9) * *((_DWORD *)a1 + 7);
      if (v71)
      {
        bzero(v69, 2 * v71);
      }
    }
    return;
  }
  unsigned int v39 = *((_DWORD *)a1 + 8);
  if (!*((_DWORD *)a1 + 16))
  {
    int v70 = v39 + *((_DWORD *)a1 + 10) - 1;
    *((_DWORD *)a1 + 9) = v70;
    uint64_t v69 = (void *)heap_Realloc(*a1, v38, 2 * v70 * *((_DWORD *)a1 + 7));
    goto LABEL_78;
  }
  if (v39 <= v2)
  {
    if (v39 < v2 && *((_DWORD *)a1 + 7))
    {
      unint64_t v72 = 0;
      uint64_t v73 = a1[11];
      do
      {
        int v74 = *((_DWORD *)v73 + v72);
        unsigned int v75 = (v2 - *((_DWORD *)a1 + 8)) >> 1;
        *((_DWORD *)v73 + v72) = v75;
        int v76 = *((_DWORD *)a1 + 8);
        int v77 = v74 + v75;
        uint64_t v78 = (v77 + v76 - 1);
        if (v77 + v76 != 1)
        {
          unsigned int v79 = *((_DWORD *)a1 + 9) * v72;
          do
          {
            *(_WORD *)(v38 + 2 * v79) = *(_WORD *)(v38 + 2 * (v75 + v79));
            ++v79;
            --v78;
          }
          while (v78);
        }
        *((_DWORD *)v73 + v72++) = v77;
      }
      while (v72 < *((unsigned int *)a1 + 7));
    }
  }
  else
  {
    uint64_t v40 = *((int *)a1 + 9);
    unsigned int v41 = v39 + *((_DWORD *)a1 + 10) - 1;
    if (v41 > v40)
    {
      *((_DWORD *)a1 + 9) = v41;
      uint64_t v38 = heap_Realloc(*a1, v38, (int)(2 * v41 * *((_DWORD *)a1 + 7)));
      a1[12] = (void *)v38;
    }
    uint64_t v42 = (*((_DWORD *)a1 + 7) - 1);
    if ((int)v42 >= 0)
    {
      unsigned int v43 = a1[11];
      unsigned int v44 = v2 - 2;
      uint64_t v45 = v38 + 2 * v40 * v42;
      while (1)
      {
        uint64_t v46 = *((unsigned int *)v43 + v42);
        unsigned int v47 = v2 + 2 * v46;
        if (v38) {
          break;
        }
        *((_DWORD *)v43 + v42) = 0;
        unsigned int v52 = *((_DWORD *)a1 + 8);
        if (v47 < v52) {
          goto LABEL_72;
        }
        *((_DWORD *)v43 + v42) = (v47 - v52) >> 1;
LABEL_73:
        v45 -= 2 * v40;
        if (v42-- <= 0) {
          return;
        }
      }
      if ((int)(v44 + v46) >= 0)
      {
        uint64_t v48 = 2 * (v44 + v46);
        unsigned int v49 = v44 + *((_DWORD *)a1 + 9) * v42 + 2 * v46;
        do
        {
          *(_WORD *)(v38 + 2 * v49) = *(_WORD *)(v45 + v48);
          v48 -= 2;
          --v49;
        }
        while (v48 != -2);
      }
      if (v46)
      {
        unsigned int v50 = *((_DWORD *)a1 + 9) * v42;
        uint64_t v51 = v46;
        do
        {
          *(_WORD *)(v38 + 2 * v50++) = 0;
          --v51;
        }
        while (v51);
      }
      *((_DWORD *)v43 + v42) = 0;
      unsigned int v52 = *((_DWORD *)a1 + 8);
      unsigned int v53 = v47 - v52;
      if (v47 >= v52)
      {
        *((_DWORD *)v43 + v42) = v53 >> 1;
        uint64_t v62 = *((_DWORD *)a1 + 8) + (v53 >> 1) - 1;
        if (*((_DWORD *)a1 + 8) + (v53 >> 1) != 1)
        {
          unsigned int v63 = *((_DWORD *)a1 + 9) * v42;
          do
          {
            *(_WORD *)(v38 + 2 * v63) = *(_WORD *)(v38 + 2 * ((v53 >> 1) + v63));
            ++v63;
            --v62;
          }
          while (v62);
        }
        goto LABEL_73;
      }
      int v54 = 2 * v46;
      unint64_t v55 = v47 - 1;
      if (v47 == 1)
      {
        unsigned int v61 = 0;
      }
      else
      {
        int v56 = *((_DWORD *)a1 + 9) * v42;
        int v57 = v52 + v56;
        unsigned int v58 = v44 + v54 + v56;
        unsigned int v59 = v57 - 2;
        uint64_t v60 = v47 - 1;
        do
        {
          *(_WORD *)(v38 + 2 * v59--) = *(_WORD *)(v38 + 2 * v58--);
          --v60;
        }
        while (v60);
        unsigned int v61 = v47 - 1;
      }
      unint64_t v64 = v52 - 1;
      if (v61 < v64)
      {
        unsigned int v65 = ~v2 + v52 + *((_DWORD *)a1 + 9) * v42 - v54;
        do
        {
          *(_WORD *)(v38 + 2 * v65) = 0;
          ++v55;
          --v65;
        }
        while (v55 < v64);
      }
LABEL_72:
      *((_DWORD *)a1[9] + v42) += (v52 - v47) >> 1;
      goto LABEL_73;
    }
  }
}

void *spxrsmp_resampler_destroy(void *result)
{
  if (result)
  {
    int v1 = (void **)result;
    unsigned int v2 = (void *)*result;
    uint64_t v3 = result[12];
    if (v3) {
      heap_Free((void *)*result, v3);
    }
    uint64_t v4 = (uint64_t)v1[13];
    if (v4) {
      heap_Free(*v1, v4);
    }
    uint64_t v5 = (uint64_t)v1[9];
    if (v5) {
      heap_Free(*v1, v5);
    }
    uint64_t v6 = (uint64_t)v1[11];
    if (v6) {
      heap_Free(*v1, v6);
    }
    uint64_t v7 = (uint64_t)v1[10];
    if (v7) {
      heap_Free(*v1, v7);
    }
    return heap_Free(v2, (uint64_t)v1);
  }
  return result;
}

uint64_t spxrsmp_resampler_process_int(uint64_t a1, unsigned int a2, _WORD *a3, unsigned int *a4, uint64_t a5, unsigned int *a6)
{
  uint64_t v28 = a5;
  uint64_t v6 = *(void *)(a1 + 96);
  if (!v6 || !*(void *)(a1 + 104)) {
    return 1;
  }
  unsigned int v10 = *a4;
  unsigned int v11 = *a6;
  int v13 = *(_DWORD *)(a1 + 32);
  int v12 = *(_DWORD *)(a1 + 36);
  uint64_t v14 = *(int *)(a1 + 128);
  if (!*(_DWORD *)(*(void *)(a1 + 88) + 4 * a2)
    || (v11 -= speex_resampler_magic(a1, a2, &v28, v11), !*(_DWORD *)(*(void *)(a1 + 88) + 4 * a2)))
  {
    if (v10 && v11)
    {
      int v15 = v13 - 1;
      unsigned int v16 = v12 - (v13 - 1);
      uint64_t v17 = v28;
      BOOL v18 = (_WORD *)(v6 + 2 * v12 * a2 + 2 * v15);
      do
      {
        if (v10 >= v16) {
          uint64_t v19 = v16;
        }
        else {
          uint64_t v19 = v10;
        }
        unsigned int v26 = v11;
        unsigned int v27 = v19;
        if (a3)
        {
          if (v19)
          {
            unsigned int v20 = a3;
            int v21 = v18;
            do
            {
              *v21++ = *v20;
              v20 += v14;
              --v19;
            }
            while (v19);
          }
        }
        else if (v19)
        {
          uint64_t v22 = v18;
          do
          {
            *v22++ = 0;
            --v19;
          }
          while (v19);
        }
        speex_resampler_process_native(a1, a2, &v27, v17, &v26);
        v11 -= v26;
        if (a3) {
          a3 += v27 * v14;
        }
        else {
          a3 = 0;
        }
        v10 -= v27;
        if (!v10) {
          break;
        }
        v17 += 2 * *(_DWORD *)(a1 + 132) * v26;
      }
      while (v11);
    }
  }
  uint64_t result = 0;
  *a4 -= v10;
  *a6 -= v11;
  return result;
}

uint64_t speex_resampler_magic(uint64_t a1, unsigned int a2, uint64_t *a3, unsigned int a4)
{
  unsigned int v18 = a4;
  uint64_t v7 = *(void *)(a1 + 96);
  unsigned int v17 = *(_DWORD *)(*(void *)(a1 + 88) + 4 * a2);
  int v8 = *(_DWORD *)(a1 + 32);
  int v9 = *(_DWORD *)(a1 + 36);
  speex_resampler_process_native(a1, a2, &v17, *a3, &v18);
  uint64_t v10 = *(void *)(a1 + 88);
  int v11 = *(_DWORD *)(v10 + 4 * a2);
  uint64_t v13 = v11 - v17;
  BOOL v12 = v11 == v17;
  *(_DWORD *)(v10 + 4 * a2) = v13;
  if (!v12)
  {
    unsigned int v14 = v17;
    unsigned int v15 = v8 - 1;
    do
    {
      *(_WORD *)(v7 + 2 * v9 * a2 + 2 * v15) = *(_WORD *)(v7 + 2 * v9 * a2 + 2 * (v14 + v15));
      ++v15;
      --v13;
    }
    while (v13);
  }
  uint64_t result = v18;
  *a3 += 2 * *(_DWORD *)(a1 + 132) * v18;
  return result;
}

uint64_t speex_resampler_process_native(uint64_t a1, unsigned int a2, unsigned int *a3, uint64_t a4, _DWORD *a5)
{
  int v9 = *(_DWORD *)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 96) + 2 * *(_DWORD *)(a1 + 36) * a2;
  *(_DWORD *)(a1 + 64) = 1;
  uint64_t result = (*(uint64_t (**)(void))(a1 + 120))();
  uint64_t v12 = *(void *)(a1 + 72);
  int v13 = *(_DWORD *)(v12 + 4 * a2);
  if (v13 < (int)*a3) {
    *a3 = v13;
  }
  *a5 = result;
  *(_DWORD *)(v12 + 4 * a2) -= *a3;
  if (v9 >= 2)
  {
    unsigned int v14 = *a3;
    uint64_t v15 = (v9 - 1);
    unsigned int v16 = (_WORD *)v10;
    do
    {
      *v16++ = *(_WORD *)(v10 + 2 * v14++);
      --v15;
    }
    while (v15);
  }
  return result;
}

uint64_t spxrsmp_resampler_process_float(uint64_t a1, unsigned int a2, float *a3, unsigned int *a4, float *a5, unsigned int *a6)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(a1 + 96);
  if (!v6) {
    return 1;
  }
  uint64_t v8 = *(void *)(a1 + 104);
  uint64_t result = 1;
  if (v8)
  {
    uint64_t v36 = *(int *)(a1 + 128);
    int v37 = *(_DWORD *)(a1 + 132);
    unsigned int v10 = *a4;
    unsigned int v11 = *a6;
    int v13 = *(_DWORD *)(a1 + 32);
    int v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 132) = 1;
    if (v10 && v11)
    {
      unsigned int v16 = v12 - v13 + 1;
      uint64_t v17 = v6 + 2 * v12 * a2;
      uint64_t v18 = a2;
      while (1)
      {
        unsigned int v41 = v42;
        unsigned int v19 = v10 >= v16 ? v16 : v10;
        unsigned int v20 = v11 >= 0x400 ? 1024 : v11;
        unsigned int v39 = v20;
        unsigned int v40 = v19;
        if (!*(_DWORD *)(*(void *)(a1 + 88) + 4 * v18)) {
          break;
        }
        int v21 = speex_resampler_magic(a1, a2, (uint64_t *)&v41, v20);
        uint64_t v18 = a2;
        int v22 = v21;
        v39 -= v21;
        v11 -= v21;
        if (!*(_DWORD *)(*(void *)(a1 + 88) + 4 * a2)) {
          goto LABEL_16;
        }
        unsigned int v23 = 0;
        unsigned int v40 = 0;
LABEL_29:
        if (v23 + v22)
        {
          unsigned int v29 = (__int16 *)v42;
          uint64_t v30 = v23 + v22;
          int v31 = a5;
          do
          {
            int v32 = *v29++;
            *int v31 = (float)v32;
            v31 += v37;
            --v30;
          }
          while (v30);
        }
        v10 -= v40;
        v11 -= v23;
        a5 += (v23 + v22) * v37;
        if (a3) {
          a3 += v40 * v36;
        }
        else {
          a3 = 0;
        }
        if (v10) {
          BOOL v33 = v11 == 0;
        }
        else {
          BOOL v33 = 1;
        }
        if (v33) {
          goto LABEL_40;
        }
      }
      int v22 = 0;
LABEL_16:
      uint64_t v24 = v40;
      if (a3)
      {
        if (v40)
        {
          unsigned int v25 = *(_DWORD *)(a1 + 32) - 1;
          unsigned int v26 = a3;
          do
          {
            if (*v26 >= -32767.0)
            {
              float v27 = 32767.0;
              if (*v26 <= 32766.0) {
                float v27 = *v26;
              }
            }
            else
            {
              float v27 = -32768.0;
            }
            *(_WORD *)(v17 + 2 * v25++) = (int)v27;
            v26 += v36;
            --v24;
          }
          while (v24);
        }
      }
      else if (v40)
      {
        unsigned int v28 = *(_DWORD *)(a1 + 32) - 1;
        do
        {
          *(_WORD *)(v17 + 2 * v28++) = 0;
          --v24;
        }
        while (v24);
      }
      speex_resampler_process_native(a1, a2, &v40, (uint64_t)v41, &v39);
      unsigned int v23 = v39;
      uint64_t v18 = a2;
      goto LABEL_29;
    }
LABEL_40:
    uint64_t result = 0;
    *(_DWORD *)(a1 + 132) = v37;
    *a4 -= v10;
    *a6 -= v11;
  }
  return result;
}

uint64_t spxrsmp_resampler_process_interleaved_float(uint64_t a1, float *a2, unsigned int *a3, float *a4, unsigned int *a5)
{
  unsigned int v6 = *a5;
  unsigned int v7 = *a3;
  uint64_t v8 = *(void *)(a1 + 128);
  int v9 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 128) = v9;
  *(_DWORD *)(a1 + 132) = v9;
  if (v9)
  {
    unint64_t v14 = 0;
    uint64_t v15 = a2;
    do
    {
      *a5 = v6;
      *a3 = v7;
      if (a2) {
        unsigned int v16 = v15;
      }
      else {
        unsigned int v16 = 0;
      }
      spxrsmp_resampler_process_float(a1, v14++, v16, a3, a4++, a5);
      ++v15;
    }
    while (v14 < *(unsigned int *)(a1 + 28));
  }
  *(void *)(a1 + 128) = v8;
  return 0;
}

uint64_t spxrsmp_resampler_process_interleaved_int(uint64_t a1, _WORD *a2, unsigned int *a3, uint64_t a4, unsigned int *a5)
{
  unsigned int v6 = *a5;
  unsigned int v7 = *a3;
  uint64_t v8 = *(void *)(a1 + 128);
  int v9 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 128) = v9;
  *(_DWORD *)(a1 + 132) = v9;
  if (v9)
  {
    unint64_t v14 = 0;
    uint64_t v15 = a2;
    do
    {
      *a5 = v6;
      *a3 = v7;
      if (a2) {
        unsigned int v16 = v15;
      }
      else {
        unsigned int v16 = 0;
      }
      spxrsmp_resampler_process_int(a1, v14++, v16, a3, a4, a5);
      a4 += 2;
      ++v15;
    }
    while (v14 < *(unsigned int *)(a1 + 28));
  }
  *(void *)(a1 + 128) = v8;
  return 0;
}

uint64_t spxrsmp_resampler_set_rate(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return 0;
}

uint64_t spxrsmp_resampler_get_rate(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  *a2 = *(_DWORD *)(result + 8);
  *a3 = *(_DWORD *)(result + 12);
  return result;
}

uint64_t spxrsmp_resampler_get_ratio(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  *a2 = *(_DWORD *)(result + 16);
  *a3 = *(_DWORD *)(result + 20);
  return result;
}

uint64_t spxrsmp_resampler_get_quality(uint64_t result, _DWORD *a2)
{
  *a2 = *(_DWORD *)(result + 24);
  return result;
}

uint64_t spxrsmp_resampler_set_input_stride(uint64_t result, int a2)
{
  *(_DWORD *)(result + 128) = a2;
  return result;
}

uint64_t spxrsmp_resampler_get_input_stride(uint64_t result, _DWORD *a2)
{
  *a2 = *(_DWORD *)(result + 128);
  return result;
}

uint64_t spxrsmp_resampler_set_output_stride(uint64_t result, int a2)
{
  *(_DWORD *)(result + 132) = a2;
  return result;
}

uint64_t spxrsmp_resampler_get_output_stride(uint64_t result, _DWORD *a2)
{
  *a2 = *(_DWORD *)(result + 132);
  return result;
}

uint64_t spxrsmp_resampler_get_input_latency(uint64_t a1)
{
  return *(_DWORD *)(a1 + 32) >> 1;
}

uint64_t spxrsmp_resampler_get_output_latency(_DWORD *a1)
{
  return ((a1[8] >> 1) * a1[5] + (a1[4] >> 1)) / a1[4];
}

uint64_t spxrsmp_resampler_skip_zeros(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    unint64_t v1 = 0;
    uint64_t v2 = *(void *)(a1 + 72);
    do
      *(_DWORD *)(v2 + 4 * v1++) = *(_DWORD *)(a1 + 32) >> 1;
    while (v1 < *(unsigned int *)(a1 + 28));
  }
  return 0;
}

uint64_t spxrsmp_resampler_reset_mem(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 96);
  if (!v2) {
    return 1;
  }
  unsigned int v3 = (*(_DWORD *)(a1 + 32) - 1) * *(_DWORD *)(a1 + 28);
  if (v3) {
    bzero(v2, 2 * v3);
  }
  return 0;
}

const char *spxrsmp_resampler_strerror(unsigned int a1)
{
  if (a1 > 4) {
    return "Unknown error. Bad error code or strange version mismatch.";
  }
  else {
    return off_26456C818[a1];
  }
}

uint64_t sinc(int a1, uint64_t a2, float a3, float a4)
{
  double v4 = a4;
  double v5 = fabs(a4);
  if (v5 >= 0.000000999999997)
  {
    if (v5 <= (float)((float)a1 * 0.5))
    {
      long double v11 = a3 * 32768.0 * sin((float)(a3 * a4) * 3.14159265) / ((float)(a3 * a4) * 3.14159265);
      float v12 = (v4 + v4) / (double)a1;
      double v13 = v11 * compute_func(a2, fabsf(v12));
      if (v13 >= -32767.0)
      {
        if (v13 <= 32766.0) {
          int v8 = (int)v13;
        }
        else {
          LOWORD(v8) = 0x7FFF;
        }
      }
      else
      {
        LOWORD(v8) = 0x8000;
      }
    }
    else
    {
      LOWORD(v8) = 0;
    }
  }
  else
  {
    double v6 = a3 * 32768.0;
    double v7 = 32767.0;
    if (v6 <= 32766.0) {
      double v7 = v6;
    }
    int v8 = (int)v7;
    if (v6 < -32767.0) {
      LOWORD(v8) = 0x8000;
    }
  }
  return (__int16)v8;
}

uint64_t resampler_basic_direct_single(uint64_t a1, unsigned int a2, uint64_t a3, int *a4, uint64_t a5, int *a6)
{
  uint64_t v6 = a2;
  uint64_t v7 = *(void *)(a1 + 72);
  uint64_t v8 = *(void *)(a1 + 80);
  int v9 = *(_DWORD *)(v7 + 4 * a2);
  unsigned int v10 = *(_DWORD *)(v8 + 4 * a2);
  int v11 = *a4;
  if (v9 >= *a4)
  {
    uint64_t result = 0;
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v13 = *(int *)(a1 + 32);
    uint64_t v14 = *(void *)(a1 + 104);
    int v15 = *(_DWORD *)(a1 + 44);
    int v16 = *(_DWORD *)(a1 + 48);
    unsigned int v17 = *(_DWORD *)(a1 + 20);
    uint64_t v18 = *(int *)(a1 + 132);
    uint64_t result = *a6 & ~(*a6 >> 31);
    while (v12 != result)
    {
      if ((int)v13 < 1)
      {
        LOWORD(v28) = 0;
      }
      else
      {
        uint64_t v20 = 0;
        int v21 = (int16x4_t *)(v14 + 2 * v10 * v13);
        int v22 = (int16x4_t *)(a3 + 2 * v9);
        int32x4_t v23 = 0uLL;
        do
        {
          int16x4_t v24 = *v21++;
          int16x4_t v25 = v24;
          int16x4_t v26 = *v22++;
          int32x4_t v23 = vmlal_s16(v23, v26, v25);
          v20 += 4;
        }
        while (v20 < v13);
        int v27 = vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v23.i8, 1), v23), vaddq_s32(vdupq_laneq_s32(v23, 2), vdupq_laneq_s32(v23, 3))).u32[0];
        int v28 = (v27 + 0x4000) >> 15;
        if (v28 <= -32767) {
          LOWORD(v28) = -32767;
        }
        if (v27 > 1073725439) {
          LOWORD(v28) = 0x7FFF;
        }
      }
      uint64_t v29 = v12 + 1;
      *(_WORD *)(a5 + 2 * v12 * v18) = v28;
      v9 += v15;
      unsigned int v30 = v10 + v16;
      if (v30 < v17)
      {
        unsigned int v31 = 0;
      }
      else
      {
        ++v9;
        unsigned int v31 = v17;
      }
      unsigned int v10 = v30 - v31;
      uint64_t v12 = v29;
      if (v9 >= v11)
      {
        uint64_t result = v29;
        break;
      }
    }
  }
  *(_DWORD *)(v7 + 4 * v6) = v9;
  *(_DWORD *)(v8 + 4 * v6) = v10;
  return result;
}

uint64_t resampler_basic_interpolate_single(uint64_t a1, unsigned int a2, uint64_t a3, int *a4, uint64_t a5, int *a6)
{
  uint64_t v6 = a2;
  uint64_t v7 = *(void *)(a1 + 72);
  uint64_t v8 = *(void *)(a1 + 80);
  int v9 = *(_DWORD *)(v7 + 4 * a2);
  unsigned int v10 = *(_DWORD *)(v8 + 4 * a2);
  int v11 = *a4;
  if (v9 >= *a4)
  {
    uint64_t v17 = 0;
  }
  else
  {
    uint64_t v46 = *(void *)(a1 + 80);
    uint64_t v47 = *(void *)(a1 + 72);
    uint64_t v48 = a2;
    uint64_t v12 = 0;
    int v13 = *(_DWORD *)(a1 + 44);
    int v14 = *(_DWORD *)(a1 + 48);
    unsigned int v15 = *(_DWORD *)(a1 + 20);
    uint64_t v16 = *(unsigned int *)(a1 + 32);
    uint64_t v17 = *a6 & ~(*a6 >> 31);
    uint64_t v18 = *(int *)(a1 + 132);
    while (v12 != v17)
    {
      int v19 = *(_DWORD *)(a1 + 56);
      if ((int)v16 < 1)
      {
        int v24 = 0;
        int v23 = 0;
        int v22 = 0;
        int v21 = 0;
      }
      else
      {
        uint64_t v20 = 0;
        int v21 = 0;
        int v22 = 0;
        int v23 = 0;
        int v24 = 0;
        uint64_t v25 = *(void *)(a1 + 104);
        uint64_t v26 = v16;
        int v27 = (__int16 *)(a3 + 2 * v9);
        do
        {
          int v28 = *v27++;
          int v29 = v19 * ++v20 - v19 * v10 / v15;
          v24 += *(__int16 *)(v25 + 2 * (v29 + 2)) * v28;
          v23 += *(__int16 *)(v25 + 2 * (v29 + 3)) * v28;
          v22 += *(__int16 *)(v25 + 2 * (v29 + 4)) * v28;
          v21 += *(__int16 *)(v25 + 2 * (v29 + 5)) * v28;
          --v26;
        }
        while (v26);
      }
      int v30 = (int)(((__int16)v15 >> 1) + ((v19 * v10 % v15) << 15)) / (int)v15;
      int v31 = (__int16)v30;
      int v32 = 2 * (__int16)v30;
      int v33 = (v32 * (__int16)v30 + 0x8000) >> 16;
      int v34 = v33 * v32 + 0x8000;
      int v35 = 5461 * (v34 >> 16);
      int v36 = v35 + 2147478188 * (__int16)v30 + 0x4000;
      unsigned int v37 = v30 + ((v33 - (v34 >> 16)) >> 1);
      int v38 = 2147472726 * v31 + (v33 << 14) - v35 + 0x4000;
      if ((_WORD)v37 + (unsigned __int16)(v38 >> 15) + (unsigned __int16)(v36 >> 15)) {
        __int16 v39 = 0x8000;
      }
      else {
        __int16 v39 = 0x7FFF;
      }
      int v40 = (v24 >> 16) * (__int16)(v36 >> 15)
          + (v23 >> 16) * (__int16)v37
          + ((((unsigned __int16)v24 >> 1) * (__int16)(v36 >> 15)) >> 15)
          + (v22 >> 16) * (__int16)(v39 - (v37 + (v38 >> 15) + (v36 >> 15)))
          + ((((unsigned __int16)v23 >> 1) * (__int16)v37) >> 15)
          + (v21 >> 16) * (__int16)(v38 >> 15)
          + ((((unsigned __int16)v22 >> 1)
            * (__int16)(v39 - (v37 + (v38 >> 15) + (v36 >> 15)))) >> 15)
          + ((((unsigned __int16)v21 >> 1) * (__int16)(v38 >> 15)) >> 15);
      int v41 = (v40 + 0x2000) >> 14;
      if (v41 <= -32767) {
        LOWORD(v41) = -32767;
      }
      if (v40 > 536862719) {
        LOWORD(v41) = 0x7FFF;
      }
      uint64_t v42 = v12 + 1;
      *(_WORD *)(a5 + 2 * v12 * v18) = v41;
      unsigned int v43 = v10 + v14;
      if (v10 + v14 < v15) {
        v9 += v13;
      }
      else {
        v9 += v13 + 1;
      }
      if (v43 < v15) {
        unsigned int v44 = 0;
      }
      else {
        unsigned int v44 = v15;
      }
      unsigned int v10 = v43 - v44;
      ++v12;
      if (v9 >= v11)
      {
        uint64_t v17 = v42;
        break;
      }
    }
    uint64_t v7 = v47;
    uint64_t v6 = v48;
    uint64_t v8 = v46;
  }
  *(_DWORD *)(v7 + 4 * v6) = v9;
  *(_DWORD *)(v8 + 4 * v6) = v10;
  return v17;
}

double compute_func(uint64_t a1, float a2)
{
  float v2 = (float)*(int *)(a1 + 8) * a2;
  signed int v3 = vcvtms_s32_f32(v2);
  float v4 = v2 - (float)(int)floorf(v2);
  double v5 = v4;
  float v6 = v4 * v4;
  double v7 = (float)(v4 * (float)(v4 * v4));
  double v8 = v7 * 0.166666667 + v5 * -0.166666667;
  double v9 = v6;
  double v10 = v5 + v9 * 0.5 + v7 * -0.5;
  double v11 = v9 * 0.5 + v5 * -0.333333333 + v7 * -0.166666667;
  uint64_t v12 = (double *)(*(void *)a1 + 8 * v3);
  return v12[1] * (1.0 - v8 - v10 - v11) + v11 * *v12 + v10 * v12[2] + v8 * v12[3];
}

uint64_t audioinserter_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2341478401;
  }
  uint64_t result = 0;
  *a2 = &IAudioInserter;
  return result;
}

uint64_t audioins_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 2341478410;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  if (!a5) {
    return 2341478407;
  }
  uint64_t inited = InitRsrcFunction(a3, a4, &v50);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  log_OutText(*(void *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 4, 0, (uint64_t)"Entering audioins_ObjOpen", v10, v11, v12, v47);
  int v13 = (void *)heap_Calloc(*(void **)(v50 + 8), 1, 1056);
  uint64_t v18 = v50;
  if (v13)
  {
    uint64_t v19 = (uint64_t)v13;
    v13[1] = a4;
    unsigned char v13[2] = v18;
    void *v13 = a3;
    uint64_t Object = objc_GetObject(*(void *)(v50 + 48), (uint64_t)"SYNTHSTREAM", &v49);
    if ((Object & 0x80000000) != 0)
    {
      uint64_t v31 = Object;
      log_OutPublic(*(void *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 2574, 0, v21, v22, v23, v24, v48);
      uint64_t v5 = v31;
      goto LABEL_27;
    }
    *(void *)(v19 + 848) = *(void *)(v49 + 8);
    if ((objc_GetObject(*(void *)(v50 + 48), (uint64_t)"AUDIOFETCHER", &v49) & 0x80000000) == 0)
    {
      uint64_t v29 = v49;
      if (*(unsigned char *)v49 == 1)
      {
        uint64_t v30 = *(void *)(v49 + 8);
        if (v30)
        {
          *(void *)(v19 + 920) = v30;
          *(_OWORD *)(v19 + 928) = *(_OWORD *)(v29 + 16);
LABEL_15:
          uint64_t ParamU32 = audioins_GetParamU32(v19, (uint64_t)"frequencyhz", (unsigned int *)(v19 + 944), 0x1F40u);
          if ((ParamU32 & 0x80000000) != 0
            || (uint64_t ParamU32 = audioins_GetParamU32(v19, (uint64_t)"audiooutputbufsamples", (unsigned int *)(v19 + 948), 0x400u), (ParamU32 & 0x80000000) != 0)|| (uint64_t ParamU32 = audioins_SetDefaultAudioProsodyParameters(v19), (ParamU32 & 0x80000000) != 0))
          {
            uint64_t v5 = ParamU32;
          }
          else
          {
            uint64_t v37 = WSOLA__Create(*(void *)(v19 + 16), *(_WORD *)(v19 + 944));
            *(void *)(v19 + 1032) = v37;
            if (v37)
            {
              WSOLA__Initialise(v37);
              WSOLA__SetTimeScaleFactor(*(_WORD **)(v19 + 1032), 100);
              uint64_t v38 = heap_Alloc(*(void *)(*(void *)(v19 + 1032) + 328), 2048);
              *(void *)(v19 + 1040) = v38;
              if (v38)
              {
                uint64_t v39 = heap_Alloc(*(void *)(*(void *)(v19 + 1032) + 328), 2048);
                *(void *)(v19 + 1048) = v39;
                if (v39)
                {
                  unint64_t v40 = 0;
                  uint64_t v41 = v50;
                  do
                  {
                    uint64_t v42 = *(void *)(v41 + 40);
                    unsigned int v43 = off_26456C840[v40];
                    v51[0] = v19;
                    v51[1] = audioinserter_loc_ParamCheckChange;
                    v51[2] = audioinserter_loc_ParamLearnChange;
                    uint64_t v44 = paramc_ListenerAdd(v42, v43, v51);
                    uint64_t v5 = v44;
                    if (v40 > 4) {
                      break;
                    }
                    ++v40;
                  }
                  while ((v44 & 0x80000000) == 0);
                  if ((v44 & 0x80000000) == 0)
                  {
                    int v45 = 13546;
LABEL_28:
                    *(void *)a5 = v19;
                    *(_DWORD *)(a5 + 8) = v45;
                    log_OutText(*(void *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 4, 0, (uint64_t)"Leaving audioins_ObjOpen: %x", v33, v34, v35, v5);
                    return v5;
                  }
                }
              }
            }
          }
LABEL_27:
          log_OutPublic(*(void *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 2580, (uint64_t)"%s%x", v32, v33, v34, v35, "lhError");
          *(void *)a5 = v19;
          *(_DWORD *)(a5 + 8) = 13546;
          audioins_ObjClose((void *)v19, *(void *)(a5 + 8));
          uint64_t v19 = 0;
          int v45 = 0;
          goto LABEL_28;
        }
      }
      objc_ReleaseObject(*(void *)(v50 + 48), (uint64_t)"AUDIOFETCHER");
    }
    log_OutPublic(*(void *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 2560, 0, v25, v26, v27, v28, v48);
    goto LABEL_15;
  }
  log_OutPublic(*(void *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 2577, 0, v14, v15, v16, v17, v48);
  return v5;
}

uint64_t audioins_ObjClose(void *a1, int a2)
{
  if ((safeh_HandleCheck((uint64_t)a1, a2, 13546, 1056) & 0x80000000) != 0) {
    return 2341478408;
  }
  uint64_t v6 = a1[2];
  log_OutText(*(void *)(v6 + 32), (uint64_t)"AUDIOINSERTER", 4, 0, (uint64_t)"Entering audioins_ObjClose", v3, v4, v5, v21);
  unint64_t v7 = 0;
  do
  {
    uint64_t v8 = *(void *)(v6 + 40);
    double v9 = off_26456C840[v7];
    *(void *)&long long v22 = a1;
    *((void *)&v22 + 1) = audioinserter_loc_ParamCheckChange;
    uint64_t v23 = audioinserter_loc_ParamLearnChange;
    uint64_t v10 = paramc_ListenerRemove(v8, v9, &v22);
    uint64_t v11 = v10;
    if (v7 > 4) {
      break;
    }
    ++v7;
  }
  while ((v10 & 0x80000000) == 0);
  if (a1[106])
  {
    int v12 = objc_ReleaseObject(*(void *)(v6 + 48), (uint64_t)"SYNTHSTREAM");
    if (v12 >= 0 || (int)v11 <= -1) {
      uint64_t v11 = v11;
    }
    else {
      uint64_t v11 = v12;
    }
  }
  if (a1[115])
  {
    int v14 = objc_ReleaseObject(*(void *)(v6 + 48), (uint64_t)"AUDIOFETCHER");
    if (v14 >= 0 || (int)v11 <= -1) {
      uint64_t v11 = v11;
    }
    else {
      uint64_t v11 = v14;
    }
  }
  uint64_t v16 = a1[129];
  if (v16)
  {
    heap_Free(*(void **)(v16 + 328), a1[130]);
    heap_Free(*(void **)(a1[129] + 328), a1[131]);
    WSOLA__Remove(a1 + 129);
    a1[129] = 0;
  }
  heap_Free(*(void **)(v6 + 8), (uint64_t)a1);
  log_OutText(*(void *)(v6 + 32), (uint64_t)"AUDIOINSERTER", 4, 0, (uint64_t)"Leaving audioins_ObjClose: %x", v17, v18, v19, v11);
  return v11;
}

uint64_t audioins_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if ((safeh_HandleCheck(a1, a2, 13546, 1056) & 0x80000000) != 0) {
    return 2341478408;
  }
  synstrmaux_InitStreamOpener(a1 + 24, *(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER");
  *(void *)(a1 + 952) = 0;
  *(_DWORD *)(a1 + 960) = 0;
  uint64_t v7 = audioins_SetDefaultAudioProsodyParameters(a1);
  if ((v7 & 0x80000000) == 0 && *(void *)(a1 + 920))
  {
    if (synstrmaux_BuildAudioContentType("audio/L16;rate=", *(_DWORD *)(a1 + 944), v9, 0x30uLL) <= 0x2F)
    {
      synstrmaux_RegisterInStream((_WORD *)(a1 + 24), (uint64_t)v9, 1, a1 + 856);
      synstrmaux_RegisterInStream((_WORD *)(a1 + 24), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
        0,
        a1 + 888);
      synstrmaux_RegisterOutStream((_WORD *)(a1 + 24), (uint64_t)v9, a1 + 872);
      synstrmaux_RegisterOutStream((_WORD *)(a1 + 24), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
        a1 + 904);
      uint64_t v7 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 24), *(void *)(a1 + 848), a3, a4);
      if ((v7 & 0x80000000) != 0) {
        synstrmaux_CloseStreams((_WORD *)(a1 + 24), *(void *)(a1 + 848));
      }
    }
    else
    {
      return 9;
    }
  }
  return v7;
}

uint64_t audioins_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v95 = 0;
  uint64_t v96 = 0;
  int v94 = 0;
  uint64_t v92 = 0;
  uint64_t v93 = 0;
  uint64_t v7 = safeh_HandleCheck(a1, a2, 13546, 1056);
  if ((v7 & 0x80000000) != 0) {
    return 2341478408;
  }
  *a5 = 1;
  if (!*(void *)(a1 + 920)) {
    return v7;
  }
  if (*(void *)(a1 + 968))
  {
    uint64_t inserted = audioins_InsertAudio(a1);
    if ((inserted & 0x80000000) == 0 && !*(_DWORD *)(a1 + 992)) {
      uint64_t inserted = audioins_InsertAudioEnd(a1);
    }
    *a5 = 2;
    return inserted;
  }
  uint64_t inserted = (*(uint64_t (**)(void, void, char *, uint64_t *))(*(void *)(a1 + 848) + 144))(*(void *)(a1 + 888), *(void *)(a1 + 896), (char *)&v96 + 4, &v95);
  if ((inserted & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2571, (uint64_t)"%s%x", v9, v10, v11, v12, "lhError");
    return inserted;
  }
  if (!HIDWORD(v96))
  {
    uint64_t v34 = *(void *)(a1 + 856);
    if (v34)
    {
      uint64_t inserted = (*(uint64_t (**)(uint64_t, void, char *, int *))(*(void *)(a1 + 848) + 144))(v34, *(void *)(a1 + 864), (char *)&v95 + 4, &v94);
      if ((inserted & 0x80000000) != 0) {
        log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2569, (uint64_t)"%s%x", v35, v36, v37, v38, "lhError");
      }
    }
    else
    {
      HIDWORD(v95) = 0;
      int v94 = 1;
    }
    if ((inserted & 0x80000000) == 0 && v95 && v94)
    {
      uint64_t inserted = synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 24), *(void *)(a1 + 848));
      int v24 = 0;
    }
    else if (HIDWORD(v95))
    {
      int v24 = 1;
    }
    else
    {
      int v24 = 0;
      *a5 = 0;
    }
    goto LABEL_58;
  }
  uint64_t v13 = (*(uint64_t (**)(void, void, uint64_t *, char *))(*(void *)(a1 + 848) + 88))(*(void *)(a1 + 888), *(void *)(a1 + 896), &v93, (char *)&v96 + 4);
  if ((v13 & 0x80000000) != 0)
  {
    uint64_t inserted = v13;
    log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2571, (uint64_t)"%s%x", v14, v15, v16, v17, "lhError");
    return inserted;
  }
  uint64_t inserted = (*(uint64_t (**)(void, void, uint64_t *, void))(*(void *)(a1 + 848) + 112))(*(void *)(a1 + 904), *(void *)(a1 + 912), &v92, HIDWORD(v96));
  if ((inserted & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2570, (uint64_t)"%s%x", v18, v19, v20, v21, "lhError");
    (*(void (**)(void, void, void))(*(void *)(a1 + 848) + 96))(*(void *)(a1 + 888), *(void *)(a1 + 896), 0);
    return inserted;
  }
  unsigned int v22 = HIDWORD(v96);
  HIDWORD(v96) >>= 5;
  if (v22 <= 0x1F)
  {
    LODWORD(v23) = 0;
    int v24 = 1;
LABEL_16:
    uint64_t v25 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 848) + 120))(*(void *)(a1 + 904), *(void *)(a1 + 912), (32 * v23));
    if ((v25 & 0x80000000) != 0)
    {
      uint64_t inserted = v25;
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2570, (uint64_t)"%s%x", v26, v27, v28, v29, "lhError");
      (*(void (**)(void, void, void))(*(void *)(a1 + 848) + 96))(*(void *)(a1 + 888), *(void *)(a1 + 896), 0);
    }
    else
    {
      uint64_t inserted = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 848) + 96))(*(void *)(a1 + 888), *(void *)(a1 + 896), (32 * v23));
      if ((inserted & 0x80000000) != 0) {
        log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2571, (uint64_t)"%s%x", v30, v31, v32, v33, "lhError");
      }
    }
    goto LABEL_54;
  }
  uint64_t v39 = 0;
  uint64_t v41 = v92;
  uint64_t v40 = v93;
  uint64_t v42 = 12;
  while (2)
  {
    uint64_t v23 = v39;
    if (*(_DWORD *)(v40 + v42) != *(_DWORD *)(a1 + 956)) {
      *(_DWORD *)(a1 + 960) = 0;
    }
    uint64_t v43 = v41 + v42;
    long long v44 = *(_OWORD *)(v40 + v42 - 12);
    *(_OWORD *)(v43 + 4) = *(_OWORD *)(v40 + v42 + 4);
    *(_OWORD *)(v43 - 12) = v44;
    int v45 = *(_DWORD *)(v41 + v42) + *(_DWORD *)(a1 + 952);
    *(_DWORD *)uint64_t v43 = v45;
    if (*(_DWORD *)(v41 + v42 - 12) != 33) {
      *(_DWORD *)(v41 + v42) = *(_DWORD *)(a1 + 960) + v45;
    }
    HIDWORD(v46) = *(_DWORD *)(v40 + v42 - 12);
    LODWORD(v46) = HIDWORD(v46) - 8;
    switch((v46 >> 1))
    {
      case 0u:
        *(_DWORD *)(a1 + 956) = *(_DWORD *)(v40 + v42);
        *(_DWORD *)(a1 + 960) += *(_DWORD *)(a1 + 944) * *(_DWORD *)(v40 + v42 + 12) / 0x3E8u;
        goto LABEL_41;
      case 5u:
        *(_DWORD *)(a1 + 1020) = *(_DWORD *)(v40 + v42 + 12);
        *(_DWORD *)(a1 + 1016) = 1;
        goto LABEL_41;
      case 8u:
        *(_DWORD *)(a1 + 1008) = *(_DWORD *)(v40 + v42 + 12);
        *(_DWORD *)(a1 + 1004) = 1;
        goto LABEL_41;
      case 9u:
        uint64_t v62 = *(void *)(a1 + 856);
        if (v62)
        {
          (*(void (**)(uint64_t, void, uint64_t *))(*(void *)(a1 + 848) + 136))(v62, *(void *)(a1 + 864), &v96);
          uint64_t inserted = (*(uint64_t (**)(void, void, char *, int *))(*(void *)(a1 + 848) + 144))(*(void *)(a1 + 856), *(void *)(a1 + 864), (char *)&v95 + 4, &v94);
          unsigned int v63 = v96 >> 1;
          int v64 = HIDWORD(v95) >> 1;
          uint64_t v40 = v93;
        }
        else
        {
          unsigned int v63 = 0;
          int v64 = 0;
          int v94 = 1;
        }
        HIDWORD(v95) = v64;
        LODWORD(v96) = v63;
        uint64_t v65 = (*(_DWORD *)(a1 + 960) + *(_DWORD *)(v40 + v42));
        if ((inserted & 0x80000000) != 0 || !v94 && v64 + v63 <= v65)
        {
          log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 3, 0, (uint64_t)"Insert audio skipped! u32AudioPos=%d, iAudioPos=%d, cAudio = %d, iAudioPos + cAudio = %d", v19, v20, v21, v65);
LABEL_43:
          int v24 = 1;
          if ((inserted & 0x80000000) != 0) {
            goto LABEL_54;
          }
LABEL_44:
          if (v23)
          {
            if (v23 == 1)
            {
              LODWORD(v23) = 1;
            }
            else
            {
              uint64_t v47 = 0;
              int v48 = 0;
              uint64_t v49 = v92;
              while (1)
              {
                do
                {
                  uint64_t v50 = (long long *)(v49 + 32 * v47++);
                  uint64_t v51 = (long long *)(v49 + 32 * v47);
                  int v52 = v48;
                  if (*((_DWORD *)v50 + 3) > *((_DWORD *)v51 + 3))
                  {
                    long long v90 = *v50;
                    long long v53 = v90;
                    long long v91 = v50[1];
                    long long v54 = v91;
                    long long v55 = v51[1];
                    long long *v50 = *v51;
                    v50[1] = v55;
                    *uint64_t v51 = v53;
                    v51[1] = v54;
                    int v52 = 1;
                    int v48 = 1;
                  }
                }
                while (v47 != v23 - 1);
                if (!v52) {
                  break;
                }
                uint64_t v47 = 0;
                int v48 = 0;
              }
            }
          }
          goto LABEL_16;
        }
        log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 3, 0, (uint64_t)"Insert audio NOT skipped! u32AudioPos=%d, iAudioPos=%d, cAudio = %d, iAudioPos + cAudio = %d", v19, v20, v21, v65);
        log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 3, 0, (uint64_t)"Before insert audio, I will write audio: u32AudioPos=%d, iAudioPos=%d, u32AudioPos-iAudioPos=%d (%d Bytes))", v66, v67, v68, v65);
        if (*(void *)(a1 + 856))
        {
          if (v65 > v96)
          {
            uint64_t inserted = (*(uint64_t (**)(void, void))(*(void *)(a1 + 848) + 128))(*(void *)(a1 + 872), *(void *)(a1 + 880));
            if ((inserted & 0x80000000) != 0) {
              log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2578, (uint64_t)"%s%x", v69, v70, v71, v72, "lhError");
            }
          }
        }
        if (v94)
        {
          (*(void (**)(void, void, uint64_t *))(*(void *)(a1 + 848) + 136))(*(void *)(a1 + 872), *(void *)(a1 + 880), &v96);
          unsigned int v76 = v96 >> 1;
          LODWORD(v96) = v96 >> 1;
          if ((inserted & 0x80000000) == 0 && v76 < *(_DWORD *)(v92 + v42))
          {
            *(void *)&long long v90 = 0;
            unsigned int v77 = *(_DWORD *)(v92 + v42) - v76;
            log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 3, 0, (uint64_t)"Insert %u silence samples at %u", v73, v74, v75, v77);
            uint64_t v78 = (*(uint64_t (**)(void, void, long long *, void))(*(void *)(a1 + 848) + 112))(*(void *)(a1 + 872), *(void *)(a1 + 880), &v90, 2 * v77);
            if ((v78 & 0x80000000) == 0) {
              uint64_t v78 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 848) + 120))(*(void *)(a1 + 872), *(void *)(a1 + 880), 2 * v77);
            }
            uint64_t inserted = v78;
          }
        }
        if (log_HasTraceTuningDataSubscriber(*(void *)(*(void *)(a1 + 16) + 32))) {
          log_OutTraceTuningData(*(uint64_t ***)(*(void *)(a1 + 16) + 32), 312, (uint64_t)"%s%s %s%s", v79, v80, v81, v82, v83, "BEG");
        }
        if ((inserted & 0x80000000) != 0) {
          goto LABEL_89;
        }
        uint64_t v84 = audioins_InsertAudioStart((void *)a1, *(char **)(v93 + v42 + 12));
        if ((v84 & 0x80000000) != 0) {
          goto LABEL_88;
        }
        uint64_t inserted = audioins_InsertAudio(a1);
        if ((inserted & 0x80000000) == 0 && !*(_DWORD *)(a1 + 992))
        {
          uint64_t v84 = audioins_InsertAudioEnd(a1);
LABEL_88:
          uint64_t inserted = v84;
        }
LABEL_89:
        LODWORD(v23) = v23 + 1;
        if (log_HasTraceTuningDataSubscriber(*(void *)(*(void *)(a1 + 16) + 32))) {
          log_OutTraceTuningData(*(uint64_t ***)(*(void *)(a1 + 16) + 32), 312, (uint64_t)"%s%u %s%s %s%u", v85, v86, v87, v88, v89, "POSREF");
        }
        int v24 = 0;
        *a5 = 2;
        if ((inserted & 0x80000000) == 0) {
          goto LABEL_44;
        }
LABEL_54:
        if (v23 == HIDWORD(v96) && v95) {
          *a5 = 2;
        }
LABEL_58:
        if ((inserted & 0x80000000) == 0)
        {
          if (v24)
          {
            uint64_t v56 = *(void *)(a1 + 856);
            if (v56)
            {
              uint64_t inserted = (*(uint64_t (**)(void, void, uint64_t, void, uint64_t, char *))(*(void *)(a1 + 848) + 128))(*(void *)(a1 + 872), *(void *)(a1 + 880), v56, *(void *)(a1 + 864), 0xFFFFFFFFLL, (char *)&v95 + 4);
              if ((inserted & 0x80000000) != 0) {
                log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2578, (uint64_t)"%s%x", v57, v58, v59, v60, "lhError");
              }
            }
          }
        }
        return inserted;
      default:
LABEL_41:
        ++v39;
        v42 += 32;
        if (v23 + 1 < (unint64_t)HIDWORD(v96)) {
          continue;
        }
        LODWORD(v23) = v23 + 1;
        goto LABEL_43;
    }
  }
}

uint64_t audioins_ProcessEnd(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 13546, 1056) & 0x80000000) != 0) {
    return 2341478408;
  }
  audioins_InsertAudioEnd(a1);
  WSOLA__Initialise(*(void *)(a1 + 1032));
  uint64_t v3 = synstrmaux_CloseStreams((_WORD *)(a1 + 24), *(void *)(a1 + 848));
  uint64_t v4 = *(void *)(a1 + 920);
  if (v4) {
    (*(void (**)(void, void))(v4 + 56))(*(void *)(a1 + 928), *(void *)(a1 + 936));
  }
  return v3;
}

uint64_t audioins_GetParamU32(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int a4)
{
  uint64_t UInt = paramc_ParamGetUInt(*(void *)(*(void *)(a1 + 16) + 40), a2, a3);
  if ((UInt & 0x80000000) != 0)
  {
    *a3 = a4;
    uint64_t UInt = paramc_ParamSetUInt(*(void *)(*(void *)(a1 + 16) + 40), a2, a4);
    if ((UInt & 0x80000000) != 0) {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2579, (uint64_t)"%s%s%s%x", v9, v10, v11, v12, "parameter");
    }
  }
  return UInt;
}

uint64_t audioins_SetDefaultAudioProsodyParameters(uint64_t a1)
{
  *(void *)(a1 + 1004) = 0;
  *(void *)(a1 + 1016) = 0;
  float v2 = (unsigned int *)(a1 + 1000);
  uint64_t result = audioins_GetParamU32(a1, (uint64_t)"volume", (unsigned int *)(a1 + 1000), 0x50u);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = audioins_GetParamU32(a1, (uint64_t)"audioinsertervolume", v2, *(_DWORD *)(a1 + 1000));
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = audioins_GetParamU32(a1, (uint64_t)"rate", (unsigned int *)(a1 + 1012), 0x64u);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = audioins_GetParamU32(a1, (uint64_t)"audioinserterrate", (unsigned int *)(a1 + 1012), *(_DWORD *)(a1 + 1012));
        if ((result & 0x80000000) == 0)
        {
          unsigned int v4 = 0;
          uint64_t result = audioins_GetParamU32(a1, (uint64_t)"audioinsertervolumeadjust", &v4, 1u);
          *(_DWORD *)(a1 + 1024) = v4 != 0;
          if ((result & 0x80000000) == 0)
          {
            unsigned int v5 = 0;
            uint64_t result = audioins_GetParamU32(a1, (uint64_t)"audioinserterrateadjust", &v5, 1u);
            *(_DWORD *)(a1 + 1028) = v5 != 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t audioinserter_loc_ParamCheckChange(uint64_t a1, char *__s1, unsigned __int8 *a3, _DWORD *a4)
{
  *a4 = 1;
  if (!cstdlib_strcmp(__s1, "frequencyhz"))
  {
    uint64_t result = 2341478417;
    if (!*(void *)(a1 + 856) && !*(void *)(a1 + 872)) {
      return 0;
    }
LABEL_11:
    *a4 = 0;
    return result;
  }
  if (cstdlib_strcmp(__s1, "audioinsertervolume"))
  {
    if (cstdlib_strcmp(__s1, "audioinserterrate") || cstdlib_atoi(a3) - 401 > 0xFFFFFEA0) {
      return 0;
    }
    goto LABEL_10;
  }
  if (cstdlib_atoi(a3) > 0x64)
  {
LABEL_10:
    uint64_t result = 2341478415;
    goto LABEL_11;
  }
  return 0;
}

uint64_t audioinserter_loc_ParamLearnChange(uint64_t a1, char *__s1, unsigned __int8 *a3)
{
  if (cstdlib_strcmp(__s1, "frequencyhz"))
  {
    if (cstdlib_strcmp(__s1, "audiooutputbufsamples"))
    {
      if (cstdlib_strcmp(__s1, "audioinsertervolume"))
      {
        if (cstdlib_strcmp(__s1, "audioinserterrate"))
        {
          if (cstdlib_strcmp(__s1, "audioinsertervolumeadjust"))
          {
            if (cstdlib_strcmp(__s1, "audioinserterrateadjust"))
            {
              return 0;
            }
            else
            {
              int v12 = cstdlib_atoi(a3);
              uint64_t result = 0;
              *(_DWORD *)(a1 + 1028) = v12 != 0;
            }
          }
          else
          {
            int v11 = cstdlib_atoi(a3);
            uint64_t result = 0;
            *(_DWORD *)(a1 + 1024) = v11 != 0;
          }
        }
        else
        {
          int v10 = cstdlib_atoi(a3);
          uint64_t result = 0;
          *(_DWORD *)(a1 + 1012) = v10;
        }
      }
      else
      {
        int v9 = cstdlib_atoi(a3);
        uint64_t result = 0;
        *(_DWORD *)(a1 + 1000) = v9;
      }
    }
    else
    {
      unsigned int v8 = LH_atou((const char *)a3);
      uint64_t result = 0;
      if (!v8) {
        unsigned int v8 = 1024;
      }
      *(_DWORD *)(a1 + 948) = v8;
    }
  }
  else
  {
    uint64_t result = 2341478417;
    if (!*(void *)(a1 + 856) && !*(void *)(a1 + 872))
    {
      unsigned int v7 = LH_atou((const char *)a3);
      uint64_t result = 0;
      *(_DWORD *)(a1 + 944) = v7;
    }
  }
  return result;
}

uint64_t audioins_InsertAudio(uint64_t a1)
{
  unsigned int v27 = 0;
  unsigned int v26 = 0;
  uint64_t v25 = 0;
  unsigned int v24 = 1024;
  unsigned int v2 = *(_DWORD *)(a1 + 948);
  unsigned int v3 = *(_DWORD *)(a1 + 996);
  if (v2 >= v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = v2;
  }
  if (*(_DWORD *)(a1 + 1028))
  {
    uint64_t v5 = 1020;
    if (!*(_DWORD *)(a1 + 1016)) {
      uint64_t v5 = 1012;
    }
    int v6 = *(_DWORD *)(a1 + v5);
    char v7 = v2 >= *(_DWORD *)(a1 + 992);
    if (v4 <= 0x400)
    {
      uint64_t v8 = *(void *)(a1 + 1048);
    }
    else
    {
      uint64_t v8 = heap_Realloc(*(uint64_t **)(*(void *)(a1 + 1032) + 328), *(void *)(a1 + 1048), 2 * v4);
      *(void *)(a1 + 1048) = v8;
    }
    uint64_t v19 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, unsigned int *, unsigned int *))(*(void *)(a1 + 920) + 88))(*(void *)(a1 + 968), *(void *)(a1 + 976), v4, v8, &v27, &v26);
    if ((v19 & 0x80000000) == 0)
    {
      if (*(_DWORD *)(a1 + 1024))
      {
        uint64_t v21 = 1008;
        if (!*(_DWORD *)(a1 + 1004)) {
          uint64_t v21 = 1000;
        }
        vol_ScaleToLevel(*(__int16 **)(a1 + 1048), v26, *(unsigned __int16 *)(a1 + v21));
      }
      WSOLA__rateChange_bet4_approach(*(void *)(a1 + 1032), v7, v6, *(__int16 **)(a1 + 1048), v26, *(_WORD **)(a1 + 1040), (int *)&v24, *(void *)(a1 + 848), *(void *)(a1 + 872), *(void *)(a1 + 880));
      unsigned int v20 = v24;
      goto LABEL_24;
    }
LABEL_27:
    (*(void (**)(void, void, void))(*(void *)(a1 + 848) + 120))(*(void *)(a1 + 872), *(void *)(a1 + 880), 0);
    return v19;
  }
  uint64_t v9 = (*(uint64_t (**)(void, void, __int16 **, void))(*(void *)(a1 + 848) + 112))(*(void *)(a1 + 872), *(void *)(a1 + 880), &v25, (2 * v4));
  if ((v9 & 0x80000000) != 0)
  {
    uint64_t v19 = v9;
    uint64_t v22 = *(void *)(*(void *)(a1 + 16) + 32);
LABEL_29:
    log_OutPublic(v22, (uint64_t)"AUDIOINSERTER", 2578, (uint64_t)"%s%s%s%x", v10, v11, v12, v13, "uri");
    return v19;
  }
  uint64_t v14 = (*(uint64_t (**)(void, void, uint64_t, __int16 *, unsigned int *, unsigned int *))(*(void *)(a1 + 920) + 88))(*(void *)(a1 + 968), *(void *)(a1 + 976), v4, v25, &v27, &v26);
  if ((v14 & 0x80000000) != 0)
  {
    uint64_t v19 = v14;
    goto LABEL_27;
  }
  if (*(_DWORD *)(a1 + 1024))
  {
    uint64_t v18 = 1008;
    if (!*(_DWORD *)(a1 + 1004)) {
      uint64_t v18 = 1000;
    }
    vol_ScaleToLevel(v25, v27, *(unsigned __int16 *)(a1 + v18));
  }
  log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 3, 0, (uint64_t)"Insert %u audio samples for %s", v15, v16, v17, 0);
  uint64_t v19 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 848) + 120))(*(void *)(a1 + 872), *(void *)(a1 + 880), 2 * v26);
  if ((v19 & 0x80000000) != 0)
  {
    uint64_t v22 = *(void *)(*(void *)(a1 + 16) + 32);
    goto LABEL_29;
  }
  unsigned int v20 = v26;
LABEL_24:
  *(_DWORD *)(a1 + 952) += v20;
  *(_DWORD *)(a1 + 992) -= v27;
  return v19;
}

uint64_t audioins_InsertAudioEnd(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 968);
  if (v2)
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)(a1 + 920) + 96))(v2, *(void *)(a1 + 976), 1);
    *(void *)(a1 + 968) = safeh_GetNullHandle();
    *(void *)(a1 + 976) = v4;
  }
  else
  {
    uint64_t v3 = 0;
  }
  *(void *)(a1 + 984) = 0;
  *(_DWORD *)(a1 + 992) = 0;
  return v3;
}

uint64_t audioins_InsertAudioStart(void *a1, char *a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  int v6 = a1 + 123;
  char v7 = a1 + 124;
  uint64_t v8 = (char *)a1 + 996;
  uint64_t v9 = a1 + 121;
  unsigned int v10 = 1;
  uint64_t v11 = a2;
  while (v10 != 2)
  {
LABEL_15:
    uint64_t v4 = (*(uint64_t (**)(void, void, char *, void *, void *, char *, void *))(a1[115] + 80))(a1[116], a1[117], v11, v6, v7, v8, v9);
    if ((v4 & 0x1FFF) != 0x14 || v10++ >= 2) {
      goto LABEL_20;
    }
  }
  size_t v12 = cstdlib_strlen("cup:");
  if (cstdlib_strncmp(v2, "cup:", v12))
  {
    uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t, char *, char *, uint64_t, uint64_t, char **))(a1[115] + 64);
    uint64_t NullHandle = safeh_GetNullHandle();
    uint64_t v16 = v15;
    uint64_t v17 = a1[116];
    uint64_t v18 = a1[117];
    uint64_t v19 = v2;
    unsigned int v20 = 0;
  }
  else
  {
    uint64_t v5 = (char *)strhelper_Strdup(*(void *)(a1[2] + 8), v2);
    if (!v5)
    {
      uint64_t v33 = 2341478410;
      goto LABEL_27;
    }
    uint64_t v25 = &v5[cstdlib_strlen("cup:")];
    while (*v25++)
    {
      if (*(v25 - 1) == 58)
      {
        *(v25 - 1) = 0;
        break;
      }
    }
    unsigned int v26 = v9;
    unsigned int v27 = v8;
    uint64_t v28 = v7;
    uint64_t v29 = v6;
    uint64_t v30 = v5;
    uint64_t v31 = v38;
    if (*v25) {
      uint64_t v31 = v25;
    }
    uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t, char *, char *, uint64_t, uint64_t, char **))(a1[115] + 64);
    uint64_t NullHandle = safeh_GetNullHandle();
    uint64_t v16 = v32;
    uint64_t v17 = a1[116];
    uint64_t v18 = a1[117];
    uint64_t v38 = v31;
    uint64_t v19 = v31;
    uint64_t v5 = v30;
    int v6 = v29;
    char v7 = v28;
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v2 = a2;
    unsigned int v20 = v5;
  }
  uint64_t v33 = v13(v17, v18, v19, v20, NullHandle, v16, &v39);
  if ((v33 & 0x80000000) == 0)
  {
    uint64_t v11 = v39;
    goto LABEL_15;
  }
  if ((v4 & 0x1FFF) == 0x14)
  {
LABEL_20:
    uint64_t v33 = v4;
    if ((v4 & 0x80000000) != 0) {
      goto LABEL_27;
    }
    if (!v5) {
      return v4;
    }
LABEL_22:
    heap_Free(*(void **)(a1[2] + 8), (uint64_t)v5);
    return v4;
  }
LABEL_27:
  log_OutPublic(*(void *)(a1[2] + 32), (uint64_t)"AUDIOINSERTER", 2561, 0, v21, v22, v23, v24, v36);
  uint64_t v4 = v33;
  if (v5) {
    goto LABEL_22;
  }
  return v4;
}

uint64_t vol_ScaleToLevel(__int16 *a1, unsigned int a2, int a3)
{
  if (a3 != 80 && a2)
  {
    int v3 = aVolScaleFactor_0[a3];
    uint64_t v4 = a2;
    do
    {
      int v5 = *a1 * v3;
      unsigned int v6 = v5 >> 15;
      if (v5 < -1073709056) {
        LOWORD(v6) = -32767;
      }
      if (v5 <= 0x3FFFFFFF) {
        __int16 v7 = v6;
      }
      else {
        __int16 v7 = 0x7FFF;
      }
      *a1++ = v7;
      --v4;
    }
    while (v4);
  }
  return 0;
}

uint64_t dsp_interpolatate_init(uint64_t *a1, uint64_t a2, int a3)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  *a1 = 0;
  uint64_t v6 = dsp_malloc(a2, 0x20u);
  if (!v6) {
    return 4294967294;
  }
  uint64_t v7 = v6;
  uint64_t result = 0;
  *(void *)uint64_t v7 = a2;
  *(void *)(v7 + 24) = 0;
  *(_DWORD *)(v7 + 12) = a3;
  *(_DWORD *)(v7 + 16) = 0;
  *a1 = v7;
  return result;
}

uint64_t dsp_interpolatate_deinit(uint64_t *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *a1;
  if (!*a1) {
    return 0;
  }
  *(_DWORD *)(v2 + 16) = 0;
  dsp_free(*(void *)v2);
  uint64_t result = 0;
  *a1 = 0;
  return result;
}

uint64_t dsp_interpolate_set_interpolator(uint64_t result, uint64_t a2)
{
  *(void *)(result + 24) = a2;
  return result;
}

uint64_t dsp_interpolate_set_target_rate(uint64_t result, float a2)
{
  *(float *)(result + 8) = a2;
  return result;
}

uint64_t dsp_interpolate_execute(uint64_t a1)
{
  unint64_t v1 = *(uint64_t (**)(void))(a1 + 24);
  if (v1) {
    return v1();
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t dsp_interpolate_linear(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5, unsigned int *a6)
{
  uint64_t v6 = result;
  int v7 = 0;
  LODWORD(result) = 0;
  int v8 = 0;
  int v9 = *(_DWORD *)(v6 + 12);
  *a6 = 0;
  float v10 = *(float *)(v6 + 16);
  uint64_t v11 = *(unsigned int *)(v6 + 12);
  float v12 = *(float *)(v6 + 8);
  float v13 = v10;
  do
  {
    if (v11)
    {
      int v14 = 0;
      uint64_t v15 = v11;
      do
      {
        float v16 = v10 * (float)*(__int16 *)(a3 + 2 * (v9 + v14));
        float v17 = v16 + (float)((float)(1.0 - v10) * (float)*(__int16 *)(a3 + 2 * (v8 + v14)));
        if (v17 >= -32767.0) {
          float v18 = v16 + (float)((float)(1.0 - v10) * (float)*(__int16 *)(a3 + 2 * (v8 + v14)));
        }
        else {
          float v18 = -32767.0;
        }
        if (v17 <= 32767.0) {
          float v19 = v18;
        }
        else {
          float v19 = 32767.0;
        }
        *(_WORD *)(a2 + 2 * (v7 + v14++)) = (int)v19;
        --v15;
      }
      while (v15);
    }
    uint64_t result = (result + 1);
    float v13 = v13 + v12;
    unsigned int v20 = v13;
    float v10 = v13 - (float)v13;
    BOOL v21 = v13 >= (float)(a4 - 1) || result == a5;
    int v8 = v11 * v20;
    int v9 = v11 * v20 + v11;
    v7 += v11;
  }
  while (!v21 && a4 - 1 > v20);
  *(float *)(v6 + 16) = v10;
  *a6 = v20;
  return result;
}

uint64_t dsp_interpolate_flush(uint64_t a1)
{
  *(_DWORD *)(a1 + 16) = 0;
  return 0;
}

uint64_t dsp_interpolate_reset(uint64_t a1)
{
  *(_DWORD *)(a1 + 16) = 0;
  return 0;
}

uint64_t dsp_tempo_changer_init(uint64_t *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v4 = 0xFFFFFFFFLL;
  if (a1 && (a3 - 3) >= 0xFFFFFFFE)
  {
    *a1 = 0;
    uint64_t v9 = dsp_malloc(a2, 0x60u);
    if (v9)
    {
      uint64_t v10 = v9;
      *(void *)uint64_t v9 = a2;
      *(void *)(v9 + 80) = 0;
      *(_DWORD *)(v9 + 72) = 1;
      *(_DWORD *)(v9 + 8) = a3;
      uint64_t v11 = (void *)(v9 + 16);
      *(_DWORD *)(v9 + 32) = a4;
      uint64_t v12 = signal_fifo_init((uint64_t *)(v9 + 16), a2, a3);
      if (v12)
      {
        uint64_t v4 = v12;
      }
      else
      {
        uint64_t v13 = signal_fifo_init((uint64_t *)(v10 + 24), a2, a3);
        if (v13)
        {
          uint64_t v4 = v13;
          int v14 = v11;
        }
        else
        {
          uint64_t v4 = dsp_tempo_changer_set_target_tempo(v10, 1.0);
          if (!v4)
          {
            *a1 = v10;
            return v4;
          }
          signal_fifo_deinit(v11);
          int v14 = (void *)(v10 + 24);
        }
        signal_fifo_deinit(v14);
      }
      dsp_free(a2);
    }
    else
    {
      return 4294967294;
    }
  }
  return v4;
}

uint64_t dsp_tempo_changer_set_target_tempo(uint64_t a1, float a2)
{
  *(float *)(a1 + 12) = a2;
  *(void *)(a1 + 36) = 0xF00000028;
  int v4 = *(_DWORD *)(a1 + 32);
  unsigned int v5 = 8 * v4 / 0x3E8u;
  *(_DWORD *)(a1 + 52) = 8;
  *(_DWORD *)(a1 + 56) = v5;
  unsigned int v6 = 40 * v4 / 0x3E8u;
  unsigned int v7 = 15 * v4 / 0x3E8u;
  *(_DWORD *)(a1 + 44) = v6;
  *(_DWORD *)(a1 + 48) = v7;
  int v8 = 2 * v5;
  if (v6 < 2 * v5)
  {
    *(_DWORD *)(a1 + 44) = v8;
    unsigned int v6 = 2 * v5;
  }
  if (!*(void *)(a1 + 80))
  {
    uint64_t v9 = (void *)dsp_malloc(*(void *)a1, v8 * *(_DWORD *)(a1 + 8));
    *(void *)(a1 + 80) = v9;
    if (!v9) {
      return 4294967294;
    }
    dsp_memset(v9, 0, (2 * *(_DWORD *)(a1 + 56) * *(_DWORD *)(a1 + 8)));
    *(_DWORD *)(a1 + 72) = 1;
    unsigned int v5 = *(_DWORD *)(a1 + 56);
    unsigned int v6 = *(_DWORD *)(a1 + 44);
    unsigned int v7 = *(_DWORD *)(a1 + 48);
  }
  uint64_t result = 0;
  float v11 = (float)(v6 - v5) * a2;
  *(float *)(a1 + 60) = v11;
  unsigned int v12 = (v11 + 0.5 + (double)v5);
  if (v6 > v12) {
    unsigned int v12 = v6;
  }
  *(_DWORD *)(a1 + 68) = v12 + v7;
  return result;
}

uint64_t dsp_tempo_changer_deinit(void *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = (void *)*a1;
  if (!*a1) {
    return 0;
  }
  signal_fifo_deinit(v2 + 2);
  signal_fifo_deinit(v2 + 3);
  if (v2[10])
  {
    dsp_free(*v2);
    v2[10] = 0;
  }
  dsp_free(*v2);
  uint64_t result = 0;
  *a1 = 0;
  return result;
}

uint64_t dsp_tempo_changer_push_samples(uint64_t a1, const void *a2, unsigned int a3)
{
  uint64_t result = signal_fifo_push_samples(*(void *)(a1 + 16), a2, a3);
  if (!result)
  {
    if (signal_fifo_get_num_unread_samples(*(_DWORD **)(a1 + 16)) <= *(_DWORD *)(a1 + 68))
    {
      return 0;
    }
    else
    {
      return wsola_exec(a1);
    }
  }
  return result;
}

uint64_t wsola_exec(uint64_t a1)
{
  unsigned int v2 = 0;
  do
  {
    if (*(_DWORD *)(a1 + 72))
    {
      *(_DWORD *)(a1 + 72) = 0;
      *(_DWORD *)(a1 + 64) = 0;
      goto LABEL_31;
    }
    uint64_t rd_ptr = signal_fifo_get_rd_ptr(*(void *)(a1 + 16));
    if ((*(_DWORD *)(a1 + 48) - 9) > 0xFFFFFFFA)
    {
      unsigned int v4 = 0;
      unsigned int v5 = 0;
      float v8 = -3.4028e38;
    }
    else
    {
      unsigned int v4 = 0;
      unsigned int v5 = 0;
      unsigned int v6 = 4;
      float v7 = -3.4028e38;
      float v8 = -3.4028e38;
      do
      {
        float v9 = cross_correlation(a1, (__int16 *)(rd_ptr + 2 * *(_DWORD *)(a1 + 8) * v6), *(__int16 **)(a1 + 80));
        if (v9 > v8)
        {
          float v8 = v9;
          unsigned int v5 = v6;
          float v7 = v9;
          unsigned int v4 = v6;
        }
        if (v9 > v7)
        {
          float v7 = v9;
          unsigned int v4 = v6;
        }
        v6 += 8;
      }
      while (v6 < *(_DWORD *)(a1 + 48) - 4);
      if (v5 > 0xFFFFFFFB) {
        goto LABEL_18;
      }
    }
    unsigned int v10 = v5;
    do
    {
      float v11 = cross_correlation(a1, (__int16 *)(rd_ptr + 2 * *(_DWORD *)(a1 + 8) * v10), *(__int16 **)(a1 + 80));
      if (v11 > v8)
      {
        float v8 = v11;
        unsigned int v5 = v10;
      }
      ++v10;
    }
    while (v10 < v5 + 4);
LABEL_18:
    unsigned int v12 = v4 + 4;
    if (v4 <= 0xFFFFFFFB)
    {
      do
      {
        float v13 = cross_correlation(a1, (__int16 *)(rd_ptr + 2 * *(_DWORD *)(a1 + 8) * v4), *(__int16 **)(a1 + 80));
        if (v13 > v8)
        {
          float v8 = v13;
          unsigned int v5 = v4;
        }
        ++v4;
      }
      while (v4 < v12);
    }
    unsigned int v14 = *(_DWORD *)(a1 + 56);
    uint64_t result = signal_fifo_ensure_free_space(*(void *)(a1 + 24), v14);
    if (result) {
      return result;
    }
    uint64_t wr_ptr = signal_fifo_get_wr_ptr(*(void *)(a1 + 24));
    uint64_t v17 = signal_fifo_get_rd_ptr(*(void *)(a1 + 16));
    unsigned int v18 = *(_DWORD *)(a1 + 56);
    if (v18)
    {
      int v19 = 0;
      int v20 = 0;
      float v21 = 1.0 / (float)v14;
      int v22 = *(_DWORD *)(a1 + 8);
      float v23 = 0.0;
      float v24 = 1.0;
      do
      {
        if (v22)
        {
          int v25 = 0;
          uint64_t v26 = *(void *)(a1 + 80);
          do
          {
            *(_WORD *)(wr_ptr + 2 * (v19 + v25)) = (int)(float)((float)(v24
                                                                                      * (float)*(__int16 *)(v26 + 2 * (v19 + v25)))
                                                                              + (float)(v23
                                                                                      * (float)*(__int16 *)(v17 + 2 * v22 * v5 + 2 * (v19 + v25))));
            ++v25;
          }
          while (v22 != v25);
        }
        float v23 = v21 + v23;
        float v24 = v24 - v21;
        ++v20;
        v19 += v22;
      }
      while (v20 != v18);
    }
    uint64_t result = signal_fifo_push_samples_nodata(*(void *)(a1 + 24), v18);
    if (result) {
      return result;
    }
    unsigned int v2 = *(_DWORD *)(a1 + 56) + v5;
LABEL_31:
    uint64_t v27 = signal_fifo_get_rd_ptr(*(void *)(a1 + 16));
    uint64_t result = signal_fifo_push_samples(*(void *)(a1 + 24), (const void *)(v27 + 2 * *(_DWORD *)(a1 + 8) * v2), *(_DWORD *)(a1 + 44) - 2 * *(_DWORD *)(a1 + 56));
    if (result) {
      return result;
    }
    dsp_memcpy(*(void **)(a1 + 80), (const void *)(v27 + 2 * (*(_DWORD *)(a1 + 44) + v2 - 2 * *(_DWORD *)(a1 + 56)) * *(_DWORD *)(a1 + 8)), (2 * *(_DWORD *)(a1 + 8) * *(_DWORD *)(a1 + 56)));
    float v28 = *(float *)(a1 + 60) + *(float *)(a1 + 64);
    *(float *)(a1 + 64) = v28;
    signal_fifo_pop_samples(*(_DWORD **)(a1 + 16), (int)v28);
    *(float *)(a1 + 64) = *(float *)(a1 + 64) - (float)(int)v28;
  }
  while (signal_fifo_get_num_unread_samples(*(_DWORD **)(a1 + 16)) >= *(_DWORD *)(a1 + 68));
  return 0;
}

uint64_t dsp_tempo_push_samples_from_fifo(uint64_t a1, uint64_t a2)
{
  uint64_t result = signal_fifo_move_samples(*(void *)(a1 + 16), a2);
  if ((result & 0x80000000) == 0)
  {
    if (signal_fifo_get_num_unread_samples(*(_DWORD **)(a1 + 16)) <= *(_DWORD *)(a1 + 68))
    {
      return 0;
    }
    else
    {
      return wsola_exec(a1);
    }
  }
  return result;
}

uint64_t dsp_tempo_push_samples_to_fifo(uint64_t a1, uint64_t a2)
{
  return signal_fifo_move_samples(a2, *(void *)(a1 + 24));
}

uint64_t dsp_tempo_changer_get_samples(uint64_t a1, void *a2, unsigned int a3)
{
  return signal_fifo_get_samples(*(void *)(a1 + 24), a2, a3);
}

uint64_t dsp_tempo_get_input_fifo(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t dsp_tempo_get_output_fifo(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t dsp_tempo_flush(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  dsp_memset(v5, 0, 0x20uLL);
  int num_unread_samples = signal_fifo_get_num_unread_samples(*(_DWORD **)(a1 + 24));
  do
    uint64_t v3 = dsp_tempo_changer_push_samples(a1, v5, 0x10u);
  while (!v3 && num_unread_samples == signal_fifo_get_num_unread_samples(*(_DWORD **)(a1 + 24)));
  return v3;
}

uint64_t dsp_tempo_reset(uint64_t a1)
{
  uint64_t result = dsp_tempo_changer_set_target_tempo(a1, 1.0);
  if (!result)
  {
    uint64_t result = signal_fifo_clear(*(void *)(a1 + 16));
    if (!result)
    {
      uint64_t result = signal_fifo_clear(*(void *)(a1 + 24));
      if (!result)
      {
        if (*(void *)(a1 + 80))
        {
          dsp_free(*(void *)a1);
          *(void *)(a1 + 80) = 0;
        }
        uint64_t result = 0;
        *(_DWORD *)(a1 + 72) = 1;
      }
    }
  }
  return result;
}

float cross_correlation(uint64_t a1, __int16 *a2, __int16 *a3)
{
  uint64_t v3 = (*(_DWORD *)(a1 + 56) * *(_DWORD *)(a1 + 8));
  if (!v3) {
    goto LABEL_5;
  }
  float v4 = 0.0;
  unsigned int v5 = a3;
  uint64_t v6 = (*(_DWORD *)(a1 + 56) * *(_DWORD *)(a1 + 8));
  do
  {
    int v7 = *v5++;
    float v4 = v4 + (float)((float)v7 * (float)v7);
    --v6;
  }
  while (v6);
  if (v4 <= 1.1755e-38) {
LABEL_5:
  }
    float v4 = 1.0;
  *(float *)(a1 + 88) = v4;
  float v8 = 0.0;
  if (v3)
  {
    do
    {
      int v9 = *a2++;
      float v10 = (float)v9;
      int v11 = *a3++;
      float v8 = v8 + (float)(v10 * (float)v11);
      --v3;
    }
    while (v3);
  }
  float result = v8 / v4;
  if (result < 0.0) {
    return -result;
  }
  return result;
}

uint64_t rateTrans_init(uint64_t **a1, uint64_t a2, int a3)
{
  uint64_t v3 = 0xFFFFFFFFLL;
  if (a1 && (a3 - 3) >= 0xFFFFFFFE)
  {
    *a1 = 0;
    uint64_t v7 = dsp_malloc(a2, 0x40u);
    if (v7)
    {
      float v8 = (uint64_t *)v7;
      *(void *)uint64_t v7 = a2;
      *(_DWORD *)(v7 + 48) = 1;
      int v9 = (void *)(v7 + 8);
      uint64_t v10 = signal_fifo_init((uint64_t *)(v7 + 8), a2, a3);
      if (v10)
      {
        uint64_t v3 = v10;
      }
      else
      {
        uint64_t v11 = signal_fifo_init(v8 + 2, a2, a3);
        if (v11)
        {
          uint64_t v3 = v11;
          unsigned int v12 = v9;
        }
        else
        {
          uint64_t v13 = signal_fifo_init(v8 + 3, a2, a3);
          if (v13)
          {
            uint64_t v3 = v13;
          }
          else
          {
            uint64_t v14 = dsp_biquad_init(v8 + 4, a2, a3, 1);
            if (v14)
            {
              uint64_t v3 = v14;
            }
            else
            {
              uint64_t v3 = dsp_interpolatate_init(v8 + 5, a2, a3);
              if (!v3)
              {
                dsp_interpolate_set_interpolator(v8[5], (uint64_t)dsp_interpolate_linear);
                *a1 = v8;
                return v3;
              }
              dsp_biquad_deinit(v8 + 4);
            }
            signal_fifo_deinit(v8 + 3);
          }
          signal_fifo_deinit(v9);
          unsigned int v12 = v8 + 2;
        }
        signal_fifo_deinit(v12);
      }
      dsp_free(a2);
    }
    else
    {
      return 4294967294;
    }
  }
  return v3;
}

uint64_t rateTrans_deinit(void *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v2 = (void *)*a1;
  if (!*a1) {
    return 0;
  }
  dsp_interpolatate_deinit(v2 + 5);
  dsp_biquad_deinit(v2 + 4);
  signal_fifo_deinit(v2 + 1);
  signal_fifo_deinit(v2 + 2);
  signal_fifo_deinit(v2 + 3);
  dsp_free(*v2);
  uint64_t result = 0;
  *a1 = 0;
  return result;
}

uint64_t rateTrans_set_rate(uint64_t a1, float a2)
{
  *(float *)(a1 + 52) = a2;
  if (a2 <= 1.0)
  {
    if (a2 < 1.1755e-38) {
      return 0xFFFFFFFFLL;
    }
    float v3 = a2 * 0.5;
  }
  else
  {
    float v3 = 1.0 / (float)(a2 + a2);
  }
  *(float *)(a1 + 56) = v3 * 0.9;
  dsp_interpolate_set_target_rate(*(void *)(a1 + 40), a2);
  uint64_t v5 = *(void *)(a1 + 32);
  float v6 = *(float *)(a1 + 56);

  return dsp_biquad_create_low_pass_filter(v5, v6);
}

uint64_t rateTrans_set_antialias_enable(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 48) = a2;
  return 0;
}

uint64_t rateTrans_push_samples(uint64_t a1, const void *a2, unsigned int a3)
{
  uint64_t result = signal_fifo_push_samples(*(void *)(a1 + 8), a2, a3);
  if (!result)
  {
    return rateTrans_elaborate(a1);
  }
  return result;
}

uint64_t rateTrans_elaborate(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 48))
  {
    uint64_t v3 = *(void *)(a1 + 24);
    float v4 = *(_DWORD **)(a1 + 8);
    goto LABEL_6;
  }
  if (*(float *)(a1 + 52) > 1.0)
  {
    uint64_t result = dsp_biquad_process_fifos(*(void *)(a1 + 32), *(void *)(a1 + 16), *(_DWORD **)(a1 + 8));
    if (result) {
      return result;
    }
    float v4 = *(_DWORD **)(a1 + 16);
    uint64_t v3 = *(void *)(a1 + 24);
LABEL_6:
    uint64_t result = rateTrans_do_trans(a1, v3, v4);
    if (result) {
      return result;
    }
    return 0;
  }
  uint64_t result = rateTrans_do_trans(a1, *(void *)(a1 + 16), *(_DWORD **)(a1 + 8));
  if (!result)
  {
    uint64_t result = dsp_biquad_process_fifos(*(void *)(a1 + 32), *(void *)(a1 + 24), *(_DWORD **)(a1 + 16));
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t rateTrans_push_samples_from_fifo(uint64_t a1, uint64_t a2)
{
  uint64_t result = signal_fifo_move_samples(*(void *)(a1 + 8), a2);
  if ((result & 0x80000000) == 0)
  {
    return rateTrans_elaborate(a1);
  }
  return result;
}

uint64_t rateTrans_push_samples_to_fifo(uint64_t a1, uint64_t a2)
{
  return signal_fifo_move_samples(a2, *(void *)(a1 + 24));
}

uint64_t rateTrans_get_samples(uint64_t a1, void *a2, unsigned int a3)
{
  return signal_fifo_get_samples(*(void *)(a1 + 24), a2, a3);
}

uint64_t rateTrans_get_input_fifo(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t rateTrans_get_output_fifo(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t rateTrans_flush(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  cstdlib_memset(__b, 0, 0x40uLL);
  return rateTrans_push_samples(a1, __b, 0x20u);
}

uint64_t rateTrans_reset(uint64_t a1)
{
  *(_DWORD *)(a1 + 48) = 1;
  uint64_t result = dsp_interpolate_reset(*(void *)(a1 + 40));
  if (!result)
  {
    dsp_biquad_flush(*(void *)(a1 + 32));
    uint64_t result = signal_fifo_clear(*(void *)(a1 + 8));
    if (!result)
    {
      uint64_t result = signal_fifo_clear(*(void *)(a1 + 16));
      if (!result)
      {
        uint64_t v3 = *(void *)(a1 + 24);
        return signal_fifo_clear(v3);
      }
    }
  }
  return result;
}

uint64_t rateTrans_do_trans(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unsigned int num_unread_samples = signal_fifo_get_num_unread_samples(a3);
  if (num_unread_samples < 2) {
    return 0;
  }
  uint64_t v8 = (int)((float)((float)num_unread_samples / *(float *)(a1 + 52)) + 1.0);
  uint64_t result = signal_fifo_ensure_free_space(a2, v8);
  if (!result)
  {
    signal_fifo_get_rd_ptr((uint64_t)a3);
    signal_fifo_get_wr_ptr(a2);
    int v9 = dsp_interpolate_execute(*(void *)(a1 + 40));
    if (v9 <= (int)v8)
    {
      unsigned int v10 = v9;
      signal_fifo_pop_samples(a3, 0);
      return signal_fifo_push_samples_nodata(a2, v10);
    }
    else
    {
      return 4294967293;
    }
  }
  return result;
}

uint64_t dsp_malloc(uint64_t a1, unsigned int a2)
{
  return heap_Alloc(a1, a2);
}

void *dsp_memcpy(void *a1, const void *a2, size_t __n)
{
  return cstdlib_memcpy(a1, a2, __n);
}

void *dsp_memset(void *a1, int a2, size_t __len)
{
  return cstdlib_memset(a1, a2, __len);
}

void *dsp_memmove_samples(void *a1, const void *a2, unsigned int a3)
{
  return cstdlib_memmove(a1, a2, 2 * a3);
}

uint64_t dsp_timbre_init(uint64_t *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v4 = 0xFFFFFFFFLL;
  if (a1 && (a3 - 3) >= 0xFFFFFFFE)
  {
    *a1 = 0;
    int v9 = (void *)dsp_malloc(a2, 0x50u);
    if (v9)
    {
      uint64_t v10 = (uint64_t)v9;
      *int v9 = a2;
      uint64_t v11 = v9 + 7;
      uint64_t v12 = signal_fifo_init(v9 + 7, a2, a3);
      if (v12)
      {
        uint64_t v4 = v12;
      }
      else
      {
        uint64_t v13 = signal_fifo_init((uint64_t *)(v10 + 48), a2, a3);
        if (v13)
        {
          uint64_t v4 = v13;
          uint64_t v14 = v11;
        }
        else
        {
          uint64_t v15 = dsp_tempo_changer_init((uint64_t *)(v10 + 64), a2, a3, a4);
          if (!v15)
          {
            uint64_t v4 = rateTrans_init((uint64_t **)(v10 + 72), a2, a3);
            if (!v4)
            {
              *(_DWORD *)(v10 + 40) = 0;
              dsp_timbre_reset(v10);
              *a1 = v10;
              return v4;
            }
            signal_fifo_deinit(v11);
            signal_fifo_deinit((void *)(v10 + 48));
            dsp_tempo_changer_deinit((void *)(v10 + 64));
            goto LABEL_12;
          }
          uint64_t v4 = v15;
          signal_fifo_deinit(v11);
          uint64_t v14 = (void *)(v10 + 48);
        }
        signal_fifo_deinit(v14);
      }
LABEL_12:
      dsp_free(a2);
      return v4;
    }
    return 4294967294;
  }
  return v4;
}

uint64_t dsp_timbre_reset(uint64_t a1)
{
  uint64_t result = dsp_tempo_reset(*(void *)(a1 + 64));
  if (!result)
  {
    uint64_t result = rateTrans_reset(*(void *)(a1 + 72));
    if (!result)
    {
      *(void *)(a1 + 8) = 0x3F80000000000000;
      *(_DWORD *)(a1 + 20) = 0;
      *(_DWORD *)(a1 + 24) = 0;
      *(_DWORD *)(a1 + 16) = 1065353216;
      *(void *)(a1 + 40) = 0;
      uint64_t result = signal_fifo_clear(*(void *)(a1 + 48));
      if (!result)
      {
        uint64_t result = signal_fifo_clear(*(void *)(a1 + 56));
        if (!result)
        {
          signal_fifo_set_backlog_size(*(void *)(a1 + 48), 0);
          return dsp_timbre_recalculate(a1);
        }
      }
    }
  }
  return result;
}

uint64_t dsp_timbre_deinit(void *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v2 = (void *)*a1;
  if (!*a1) {
    return 0;
  }
  signal_fifo_deinit(v2 + 7);
  signal_fifo_deinit(v2 + 6);
  dsp_tempo_changer_deinit(v2 + 8);
  rateTrans_deinit(v2 + 9);
  dsp_free(*v2);
  uint64_t result = 0;
  *a1 = 0;
  return result;
}

uint64_t dsp_timbre_set_target_timbre(uint64_t a1, float a2)
{
  *(float *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 20) = a2 != 0.0;
  *(_DWORD *)(a1 + 24) = 1;
  return 0;
}

uint64_t dsp_timbre_set_target_rate(uint64_t a1, float a2)
{
  if (a2 < 1.1755e-38) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *(float *)(a1 + 12) = a2;
  *(_DWORD *)(a1 + 20) = a2 != 100.0;
  *(_DWORD *)(a1 + 24) = 1;
  return result;
}

uint64_t dsp_timbre_set_target_resamp(uint64_t a1, float a2)
{
  if (a2 < 1.1755e-38) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *(float *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 24) = 1;
  return result;
}

uint64_t dsp_timbre_push_samples(uint64_t a1, __int16 *a2, int a3)
{
  LODWORD(v3) = a3;
  uint64_t output_fifo = dsp_tempo_get_output_fifo(*(void *)(a1 + 64));
  if (!output_fifo) {
    return 4294967293;
  }
  uint64_t v7 = output_fifo;
  if (v3)
  {
    uint64_t v8 = v3;
    float v9 = 0.0;
    uint64_t v10 = a2;
    do
    {
      int v11 = *v10++;
      float v9 = v9 + (float)v11;
      --v8;
    }
    while (v8);
  }
  else
  {
    float v9 = 0.0;
  }
  *(float *)(a1 + 40) = v9 / (float)v3;
  int v13 = *(_DWORD *)(a1 + 44);
  if (v13 == 3)
  {
    if (!*(_DWORD *)(a1 + 24))
    {
LABEL_20:
      uint64_t result = signal_fifo_push_samples(*(void *)(a1 + 48), a2, v3);
      if (!result)
      {
        uint64_t result = dsp_tempo_push_samples_from_fifo(*(void *)(a1 + 64), *(void *)(a1 + 48));
        if (!result)
        {
          uint64_t result = rateTrans_push_samples_from_fifo(*(void *)(a1 + 72), v7);
          if (!result)
          {
            uint64_t result = rateTrans_push_samples_to_fifo(*(void *)(a1 + 72), *(void *)(a1 + 56));
            if ((result & 0x80000000) == 0) {
              return 0;
            }
          }
        }
      }
      return result;
    }
    *(_DWORD *)(a1 + 24) = 0;
    int v13 = 4;
  }
  else
  {
    if (v13) {
      goto LABEL_16;
    }
    if (!*(_DWORD *)(a1 + 24) || (int v14 = *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 24) = 0, !v14))
    {
LABEL_17:
      uint64_t v15 = *(void *)(a1 + 56);
      float v16 = a2;
      unsigned int v17 = v3;
      goto LABEL_18;
    }
    int v13 = 1;
  }
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 44) = v13;
LABEL_16:
  switch(v13)
  {
    case 0:
      goto LABEL_17;
    case 1:
      signal_fifo_set_backlog_size(*(void *)(a1 + 48), 0);
      uint64_t result = dsp_tempo_push_samples_from_fifo(*(void *)(a1 + 64), *(void *)(a1 + 48));
      if (result) {
        return result;
      }
      uint64_t result = rateTrans_push_samples_from_fifo(*(void *)(a1 + 72), v7);
      if (result) {
        return result;
      }
      uint64_t result = rateTrans_push_samples_to_fifo(*(void *)(a1 + 72), *(void *)(a1 + 56));
      if (result) {
        return result;
      }
      *(_DWORD *)(a1 + 44) = 2;
LABEL_29:
      if (!v3) {
        return 0;
      }
      uint64_t v3 = v3;
      while (2)
      {
        int v18 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 28) = v18 + 1;
        if (*(float *)(a1 + 40) < 3.0 || v18 >= 2047) {
          goto LABEL_50;
        }
        uint64_t result = signal_fifo_push_samples(*(void *)(a1 + 48), a2, 1u);
        if (!result)
        {
          uint64_t result = dsp_tempo_push_samples_from_fifo(*(void *)(a1 + 64), *(void *)(a1 + 48));
          if (!result)
          {
            uint64_t result = rateTrans_push_samples_from_fifo(*(void *)(a1 + 72), v7);
            if (!result)
            {
              uint64_t result = rateTrans_push_samples_to_fifo(*(void *)(a1 + 72), *(void *)(a1 + 56));
              if ((result & 0x80000000) == 0)
              {
                ++a2;
                if (!--v3) {
                  return 0;
                }
                continue;
              }
            }
          }
        }
        return result;
      }
    case 2:
      goto LABEL_29;
    case 3:
      goto LABEL_20;
    case 4:
      if (!v3) {
        return 0;
      }
      uint64_t v3 = v3;
      break;
    default:
      return 0;
  }
  while (1)
  {
    int v19 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 28) = v19 + 1;
    if (*(float *)(a1 + 40) < 3.0 || v19 >= 2047) {
      break;
    }
    uint64_t result = signal_fifo_push_samples(*(void *)(a1 + 48), a2, 1u);
    if (result) {
      return result;
    }
    uint64_t result = dsp_tempo_push_samples_from_fifo(*(void *)(a1 + 64), *(void *)(a1 + 48));
    if (result) {
      return result;
    }
    uint64_t result = rateTrans_push_samples_from_fifo(*(void *)(a1 + 72), v7);
    if (result) {
      return result;
    }
    uint64_t result = rateTrans_push_samples_to_fifo(*(void *)(a1 + 72), *(void *)(a1 + 56));
    if ((result & 0x80000000) != 0) {
      return result;
    }
    ++a2;
    if (!--v3) {
      return 0;
    }
  }
LABEL_50:
  uint64_t result = dsp_timbre_recalculate(a1);
  if (!result)
  {
    *(_DWORD *)(a1 + 44) = 3;
    uint64_t v15 = *(void *)(a1 + 48);
    float v16 = a2;
    unsigned int v17 = v3;
LABEL_18:
    uint64_t result = signal_fifo_push_samples(v15, v16, v17);
    if (result) {
      return result;
    }
    return 0;
  }
  return result;
}

uint64_t dsp_timbre_recalculate(uint64_t a1)
{
  float v2 = 1.1755e-38;
  if ((float)((float)(*(float *)(a1 + 8) / 100.0) + 1.0) >= 1.1755e-38) {
    float v2 = (float)(*(float *)(a1 + 8) / 100.0) + 1.0;
  }
  float v3 = (float)(*(float *)(a1 + 16) + -1.0) + v2;
  *(float *)(a1 + 32) = (float)(*(float *)(a1 + 12) + -1.0) + (float)(1.0 / v2);
  *(float *)(a1 + 36) = v3;
  uint64_t result = rateTrans_set_rate(*(void *)(a1 + 72), v3);
  if (!result)
  {
    uint64_t v5 = *(void *)(a1 + 64);
    float v6 = *(float *)(a1 + 32);
    return dsp_tempo_changer_set_target_tempo(v5, v6);
  }
  return result;
}

uint64_t dsp_timbre_get_samples(uint64_t a1, void *a2, unsigned int a3)
{
  return signal_fifo_get_samples(*(void *)(a1 + 56), a2, a3);
}

uint64_t dsp_timbre_push_samples_from_fifo(void *a1, uint64_t a2)
{
  uint64_t result = dsp_tempo_push_samples_from_fifo(a1[8], a2);
  if (!result)
  {
    uint64_t output_fifo = dsp_tempo_get_output_fifo(a1[8]);
    if (output_fifo)
    {
      uint64_t result = rateTrans_push_samples_from_fifo(a1[9], output_fifo);
      if (!result)
      {
        uint64_t v5 = a1[9];
        uint64_t v6 = a1[7];
        return rateTrans_push_samples_to_fifo(v5, v6);
      }
    }
    else
    {
      return 4294967293;
    }
  }
  return result;
}

uint64_t dsp_timbre_get_output_fifo(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t dsp_timbre_push_samples_to_fifo(uint64_t a1, uint64_t a2)
{
  return signal_fifo_move_samples(a2, *(void *)(a1 + 56));
}

uint64_t dsp_timbre_flush(uint64_t a1)
{
  return 0;
}

uint64_t dsp_timbre_clear()
{
  return 0;
}

uint64_t dspeffects_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2360352769;
  }
  uint64_t result = 0;
  *a2 = &IDspEffects;
  return result;
}

uint64_t dspeffects_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 2360352778;
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  if (!a5) {
    return 2360352775;
  }
  uint64_t inited = InitRsrcFunction(a3, a4, &v51);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  log_OutText(v51[4], (uint64_t)"DSPEFFECTS", 4, 0, (uint64_t)"Entering dspeffects_ObjOpen", v10, v11, v12, v48);
  uint64_t v13 = heap_Calloc((void *)v51[1], 1, 992);
  if (v13)
  {
    uint64_t v18 = v13;
    *(void *)(v13 + 960) = 0x6400000000;
    uint64_t v19 = heap_Alloc(v51[1], 256);
    *(void *)(v18 + 952) = v19;
    int v20 = v51;
    if (v19)
    {
      *(void *)(v18 + 8) = a4;
      *(void *)(v18 + 16) = v20;
      *(void *)uint64_t v18 = a3;
      uint64_t Object = objc_GetObject(v51[6], (uint64_t)"SYNTHSTREAM", &v50);
      if ((Object & 0x80000000) != 0)
      {
        uint64_t v32 = 2574;
        uint64_t v33 = v51;
        uint64_t v5 = Object;
        goto LABEL_22;
      }
      *(void *)(v18 + 848) = *(void *)(v50 + 8);
      if ((objc_GetObject(v51[6], (uint64_t)"AUDIOFETCHER", &v50) & 0x80000000) == 0)
      {
        uint64_t v30 = v50;
        if (*(unsigned char *)v50 == 1)
        {
          uint64_t v31 = *(void *)(v50 + 8);
          if (v31)
          {
            *(void *)(v18 + 920) = v31;
            *(_OWORD *)(v18 + 928) = *(_OWORD *)(v30 + 16);
            goto LABEL_17;
          }
        }
        objc_ReleaseObject(v51[6], (uint64_t)"AUDIOFETCHER");
      }
      log_OutPublic(v51[4], (uint64_t)"DSPEFFECTS", 2560, 0, v26, v27, v28, v29, v49);
LABEL_17:
      uint64_t ParamU32 = dspeffects_GetParamU32(v18, (uint64_t)"frequencyhz", (unsigned int *)(v18 + 980), 0x1F40u);
      if ((ParamU32 & 0x80000000) != 0
        || (uint64_t ParamU32 = dspeffects_GetParamS32(v18, (_DWORD *)(v18 + 976)), (ParamU32 & 0x80000000) != 0))
      {
        uint64_t v5 = ParamU32;
        goto LABEL_24;
      }
      uint64_t v39 = dspeffects_GetParamU32(v18, (uint64_t)"timbre", (unsigned int *)(v18 + 968), 0x64u);
      int v40 = MapProsodyValue_Scaling(50, 100, 200, *(_DWORD *)(v18 + 976), *(_DWORD *)(v18 + 968));
      *(_DWORD *)(v18 + 968) = v40;
      *(_DWORD *)(v18 + 972) = v40;
      if ((v39 & 0x80000000) != 0)
      {
        uint64_t v5 = v39;
        goto LABEL_24;
      }
      int v41 = dsp_timbre_init((uint64_t *)(v18 + 944), v51[1], 1, *(_DWORD *)(v18 + 980));
      uint64_t v33 = v51;
      if (!v41)
      {
        unint64_t v44 = 0;
        do
        {
          uint64_t v45 = v33[5];
          unint64_t v46 = off_26456C870[v44];
          v52[0] = v18;
          v52[1] = dspeffects_loc_ParamCheckChange;
          v52[2] = dspeffects_loc_ParamLearnChange;
          uint64_t v47 = paramc_ListenerAdd(v45, v46, v52);
          uint64_t v5 = v47;
          if (v44 > 1) {
            break;
          }
          ++v44;
        }
        while ((v47 & 0x80000000) == 0);
        if ((v47 & 0x80000000) == 0)
        {
          int v42 = 55546;
          goto LABEL_25;
        }
LABEL_24:
        log_OutPublic(v51[4], (uint64_t)"DSPEFFECTS", 2580, (uint64_t)"%s%x", v35, v36, v37, v38, "lhError");
        *(void *)a5 = v18;
        *(_DWORD *)(a5 + 8) = 55546;
        dspeffects_ObjClose((void *)v18, *(void *)(a5 + 8));
        uint64_t v18 = 0;
        int v42 = 0;
LABEL_25:
        *(void *)a5 = v18;
        *(_DWORD *)(a5 + 8) = v42;
        log_OutText(v51[4], (uint64_t)"DSPEFFECTS", 4, 0, (uint64_t)"Leaving dspeffects_ObjOpen: %x", v36, v37, v38, v5);
        return v5;
      }
      uint64_t v32 = 2577;
LABEL_22:
      log_OutPublic(v33[4], (uint64_t)"DSPEFFECTS", v32, 0, v22, v23, v24, v25, v49);
      goto LABEL_24;
    }
    heap_Free((void *)v51[1], v18);
  }
  log_OutPublic(v51[4], (uint64_t)"DSPEFFECTS", 2577, 0, v14, v15, v16, v17, v49);
  return v5;
}

uint64_t dspeffects_ObjClose(void *a1, int a2)
{
  if ((safeh_HandleCheck((uint64_t)a1, a2, 55546, 992) & 0x80000000) != 0) {
    return 2360352776;
  }
  uint64_t v6 = a1[2];
  log_OutText(*(void *)(v6 + 32), (uint64_t)"DSPEFFECTS", 4, 0, (uint64_t)"Entering dspeffects_ObjClose", v3, v4, v5, v20);
  dsp_timbre_deinit(a1 + 118);
  unint64_t v7 = 0;
  do
  {
    uint64_t v8 = *(void *)(v6 + 40);
    float v9 = off_26456C870[v7];
    *(void *)&long long v21 = a1;
    *((void *)&v21 + 1) = dspeffects_loc_ParamCheckChange;
    uint64_t v22 = dspeffects_loc_ParamLearnChange;
    uint64_t v10 = paramc_ListenerRemove(v8, v9, &v21);
    uint64_t v11 = v10;
    if (v7 > 1) {
      break;
    }
    ++v7;
  }
  while ((v10 & 0x80000000) == 0);
  if (a1[106])
  {
    int v12 = objc_ReleaseObject(*(void *)(v6 + 48), (uint64_t)"SYNTHSTREAM");
    if (v12 >= 0 || (int)v11 <= -1) {
      uint64_t v11 = v11;
    }
    else {
      uint64_t v11 = v12;
    }
  }
  if (a1[115])
  {
    int v14 = objc_ReleaseObject(*(void *)(v6 + 48), (uint64_t)"AUDIOFETCHER");
    if (v14 >= 0 || (int)v11 <= -1) {
      uint64_t v11 = v11;
    }
    else {
      uint64_t v11 = v14;
    }
  }
  heap_Free(*(void **)(v6 + 8), a1[119]);
  heap_Free(*(void **)(v6 + 8), (uint64_t)a1);
  log_OutText(*(void *)(v6 + 32), (uint64_t)"DSPEFFECTS", 4, 0, (uint64_t)"Leaving dspEffects_ObjClose: %x", v16, v17, v18, v11);
  return v11;
}

uint64_t dspeffects_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v7 = 2360352776;
  uint64_t v8 = safeh_HandleCheck(a1, a2, 55546, 992);
  if ((v8 & 0x80000000) == 0)
  {
    uint64_t v9 = v8;
    synstrmaux_InitStreamOpener(a1 + 24, *(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS");
    if (*(void *)(a1 + 920))
    {
      *(_DWORD *)(a1 + 960) = 0;
      if (!dsp_timbre_reset(*(void *)(a1 + 944)))
      {
        uint64_t ParamU32 = dspeffects_GetParamU32(a1, (uint64_t)"frequencyhz", (unsigned int *)(a1 + 980), 0x1F40u);
        if ((ParamU32 & 0x80000000) != 0
          || (uint64_t ParamU32 = dspeffects_GetParamS32(a1, (_DWORD *)(a1 + 976)), (ParamU32 & 0x80000000) != 0))
        {
          uint64_t v7 = ParamU32;
        }
        else
        {
          dspeffects_GetParamU32(a1, (uint64_t)"timbre", (unsigned int *)(a1 + 968), 0x64u);
          int v11 = MapProsodyValue_Scaling(50, 100, 200, *(_DWORD *)(a1 + 976), *(_DWORD *)(a1 + 968));
          *(_DWORD *)(a1 + 968) = v11;
          *(_DWORD *)(a1 + 972) = v11;
          if (synstrmaux_BuildAudioContentType("audio/L16;rate=", *(_DWORD *)(a1 + 980), v13, 0x30uLL) > 0x2F) {
            return 9;
          }
          synstrmaux_RegisterInStream((_WORD *)(a1 + 24), (uint64_t)v13, 1, a1 + 856);
          synstrmaux_RegisterInStream((_WORD *)(a1 + 24), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
            0,
            a1 + 888);
          synstrmaux_RegisterOutStream((_WORD *)(a1 + 24), (uint64_t)v13, a1 + 872);
          synstrmaux_RegisterOutStream((_WORD *)(a1 + 24), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
            a1 + 904);
          uint64_t v7 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 24), *(void *)(a1 + 848), a3, a4);
          dsp_timbre_set_target_timbre(*(void *)(a1 + 944), (float)*(unsigned int *)(a1 + 968) + -100.0);
          *(_DWORD *)(a1 + 984) = 0;
          if ((v7 & 0x80000000) == 0) {
            return v7;
          }
        }
        synstrmaux_CloseStreams((_WORD *)(a1 + 24), *(void *)(a1 + 848));
        return v7;
      }
      return 2360352778;
    }
    else
    {
      return v9;
    }
  }
  return v7;
}

uint64_t dspeffects_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unsigned int v81 = 0;
  uint64_t v80 = 0;
  int v79 = 0;
  uint64_t v7 = safeh_HandleCheck(a1, a2, 55546, 992);
  if ((v7 & 0x80000000) != 0) {
    return 2360352776;
  }
  *(_DWORD *)(a1 + 988) = 1;
  *a5 = 1;
  int v8 = *(_DWORD *)(a1 + 960);
  if (v8 == 2)
  {
    uint64_t result = synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 24), *(void *)(a1 + 848));
    *(_DWORD *)(a1 + 960) = 3;
    return result;
  }
  if (v8 == 1) {
    goto LABEL_6;
  }
  uint64_t v9 = v7;
  if (!v8)
  {
    *(_DWORD *)(a1 + 960) = 1;
LABEL_6:
    if (((*(uint64_t (**)(void, void, char *, uint64_t *))(*(void *)(a1 + 848) + 144))(*(void *)(a1 + 888), *(void *)(a1 + 896), (char *)&v80 + 4, &v80) & 0x80000000) != 0)
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2571, (uint64_t)"%s%x", v10, v11, v12, v13, "lhError");
    }
    else if (((*(uint64_t (**)(void, void, unsigned int *, int *))(*(void *)(a1 + 848) + 144))(*(void *)(a1 + 856), *(void *)(a1 + 864), &v81, &v79) & 0x80000000) != 0)
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2569, (uint64_t)"%s%x", v14, v15, v16, v17, "lhError");
    }
    uint64_t v84 = 0;
    uint64_t v85 = 0;
    uint64_t v83 = 0;
    int v82 = 0;
    uint64_t v9 = (*(uint64_t (**)(void, void, uint64_t *, char *))(*(void *)(a1 + 848) + 88))(*(void *)(a1 + 888), *(void *)(a1 + 896), &v85, (char *)&v83 + 4);
    if ((v9 & 0x80000000) != 0)
    {
      HIDWORD(v83) = 0;
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2571, (uint64_t)"%s%x", v19, v20, v21, v22, "lhError");
    }
    else if (HIDWORD(v83))
    {
      uint64_t v27 = (*(uint64_t (**)(void, void, uint64_t *))(*(void *)(a1 + 848) + 112))(*(void *)(a1 + 904), *(void *)(a1 + 912), &v84);
      if ((v27 & 0x80000000) != 0)
      {
        HIDWORD(v83) = 0;
        log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2570, (uint64_t)"%s%x", v23, v24, v25, v26, "lhError");
      }
      else
      {
        uint64_t v28 = HIDWORD(v83);
        if (HIDWORD(v83) >= 0x20)
        {
          uint64_t v29 = 0;
          unint64_t v30 = (unint64_t)HIDWORD(v83) >> 5;
          do
          {
            uint64_t v31 = (_OWORD *)(v84 + 32 * v29);
            uint64_t v32 = v85 + 32 * v29;
            long long v33 = *(_OWORD *)(v32 + 16);
            *uint64_t v31 = *(_OWORD *)v32;
            v31[1] = v33;
            if (*(_DWORD *)v32 == 17)
            {
              int v34 = MapProsodyValue_Scaling(50, 100, 200, *(_DWORD *)(a1 + 976), *(_DWORD *)(v32 + 24));
              *(_DWORD *)(a1 + 968) = v34;
              uint64_t v35 = v85 + 32 * v29;
              *(_DWORD *)(a1 + 964) = *(_DWORD *)(v35 + 24);
              if (*(_DWORD *)(a1 + 972) != v34)
              {
                unsigned int v36 = *(_DWORD *)(v35 + 12);
                uint64_t v86 = 0;
                uint64_t v87 = 0;
                if (v36)
                {
                  (*(void (**)(void, void, uint64_t *))(*(void *)(a1 + 848) + 136))(*(void *)(a1 + 856), *(void *)(a1 + 864), &v87);
                  uint64_t v37 = (*(uint64_t (**)(void, void, char *, char *))(*(void *)(a1 + 848) + 144))(*(void *)(a1 + 856), *(void *)(a1 + 864), (char *)&v87 + 4, (char *)&v86 + 4);
                  if (v36 > v87 >> 1)
                  {
                    unsigned int v38 = v36 - (v87 >> 1);
                    unsigned int v39 = v36 >= v87 >> 1 ? v36 - (v87 >> 1) : 0;
                    *(_DWORD *)(a1 + 984) -= v39;
                    if (v38)
                    {
                      while (1)
                      {
                        int v40 = v38 >= 0x80 ? 128 : v38;
                        uint64_t v37 = (*(uint64_t (**)(void, void, void, void, uint64_t *))(*(void *)(a1 + 848) + 80))(*(void *)(a1 + 856), *(void *)(a1 + 864), *(void *)(a1 + 952), (2 * v40), &v86);
                        if ((v37 & 0x80000000) != 0) {
                          break;
                        }
                        if (!v86) {
                          goto LABEL_40;
                        }
                        if (dsp_timbre_push_samples(*(void *)(a1 + 944), *(__int16 **)(a1 + 952), v86 >> 1))return 2360352778; {
                        unsigned int v45 = v86;
                        }
                        do
                        {
                          int samples = dsp_timbre_get_samples(*(void *)(a1 + 944), *(void **)(a1 + 952), 0x80u);
                          LODWORD(v86) = samples;
                          if (!samples) {
                            break;
                          }
                          uint64_t v37 = (*(uint64_t (**)(void, void, void, void))(*(void *)(a1 + 848) + 104))(*(void *)(a1 + 872), *(void *)(a1 + 880), *(void *)(a1 + 952), (2 * samples));
                          if ((v37 & 0x80000000) != 0)
                          {
                            log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2578, (uint64_t)"%s%x", v47, v48, v49, v50, "lhError");
                            break;
                          }
                        }
                        while (v86);
                        v38 -= v45 >> 1;
                        if (!v38) {
                          goto LABEL_40;
                        }
                      }
                      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2578, (uint64_t)"%s%x", v41, v42, v43, v44, "lhError");
                    }
                  }
                }
                else
                {
                  uint64_t v37 = 0;
                }
LABEL_40:
                unsigned int v51 = *(_DWORD *)(a1 + 968);
                *(_DWORD *)(a1 + 972) = v51;
                if (dsp_timbre_set_target_timbre(*(void *)(a1 + 944), (float)v51 + -100.0)) {
                  return 2360352778;
                }
                if ((v37 & 0x80000000) != 0) {
                  return v37;
                }
                *(_DWORD *)(a1 + 988) = 0;
                uint64_t v27 = (*(uint64_t (**)(void, void, uint64_t *, int *))(*(void *)(a1 + 848) + 144))(*(void *)(a1 + 856), *(void *)(a1 + 864), &v83, &v82);
                if ((v27 & 0x80000000) != 0) {
                  log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2571, (uint64_t)"%s%x", v52, v53, v54, v55, "lhError");
                }
              }
            }
            ++v29;
          }
          while (v29 != v30);
          uint64_t v28 = HIDWORD(v83);
        }
        (*(void (**)(void, void, uint64_t))(*(void *)(a1 + 848) + 120))(*(void *)(a1 + 904), *(void *)(a1 + 912), v28);
      }
      (*(void (**)(void, void, void))(*(void *)(a1 + 848) + 96))(*(void *)(a1 + 888), *(void *)(a1 + 896), HIDWORD(v83));
      uint64_t v9 = v27;
    }
    unsigned int v56 = *(_DWORD *)(a1 + 968);
    if (*(_DWORD *)(a1 + 972) == v56
      || (*(_DWORD *)(a1 + 972) = v56,
          !dsp_timbre_set_target_timbre(*(void *)(a1 + 944), (float)v56 + -100.0)))
    {
      if ((v9 & 0x80000000) == 0)
      {
        if (((*(uint64_t (**)(void, void, unsigned int *, int *))(*(void *)(a1 + 848) + 144))(*(void *)(a1 + 856), *(void *)(a1 + 864), &v81, &v79) & 0x80000000) != 0)log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2569, (uint64_t)"%s%x", v57, v58, v59, v60, "lhError"); {
        unsigned int v61 = v81;
        }
        if (v81)
        {
          do
          {
            LODWORD(v85) = 0;
            if (v61 >= 0x80) {
              uint64_t v62 = 128;
            }
            else {
              uint64_t v62 = v61;
            }
            uint64_t v9 = (*(uint64_t (**)(void, void, void, uint64_t, uint64_t *))(*(void *)(a1 + 848) + 80))(*(void *)(a1 + 856), *(void *)(a1 + 864), *(void *)(a1 + 952), v62, &v85);
            if ((v9 & 0x80000000) != 0)
            {
              log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2578, (uint64_t)"%s%x", v63, v64, v65, v66, "lhError");
              goto LABEL_81;
            }
            if (dsp_timbre_push_samples(*(void *)(a1 + 944), *(__int16 **)(a1 + 952), v85 >> 1))
            {
              uint64_t v9 = 2360352778;
              goto LABEL_81;
            }
            int v71 = v85;
            if ((int)v85 >= 0) {
              int v72 = v85;
            }
            else {
              int v72 = v85 + 1;
            }
            *(_DWORD *)(a1 + 984) -= v72 >> 1;
            while (1)
            {
              int v73 = dsp_timbre_get_samples(*(void *)(a1 + 944), *(void **)(a1 + 952), 0x80u);
              LODWORD(v85) = v73;
              if (v73 < 1) {
                break;
              }
              *(_DWORD *)(a1 + 988) = 0;
              *(_DWORD *)(a1 + 984) += v73;
              uint64_t v9 = (*(uint64_t (**)(void, void, void, void))(*(void *)(a1 + 848) + 104))(*(void *)(a1 + 872), *(void *)(a1 + 880), *(void *)(a1 + 952), (2 * v73));
              if ((v9 & 0x80000000) != 0)
              {
                log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2578, (uint64_t)"%s%x", v67, v68, v69, v70, "lhError");
                goto LABEL_75;
              }
              if ((int)v85 <= 0) {
                goto LABEL_75;
              }
            }
            if (*(_DWORD *)(a1 + 988)) {
              *a5 = 0;
            }
LABEL_75:
            v61 -= v71;
          }
          while (v61);
          if ((v9 & 0x80000000) == 0) {
            goto LABEL_82;
          }
LABEL_81:
          log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2569, (uint64_t)"%s%x", v67, v68, v69, v70, "lhError");
        }
        else
        {
          uint64_t v9 = 0;
        }
LABEL_82:
        if ((v9 & 0x80000000) == 0 && v80 && v79 && *(_DWORD *)(a1 + 960) == 1)
        {
          uint64_t v9 = 2360352778;
          if (!dsp_timbre_flush(*(void *)(a1 + 944)))
          {
            int v74 = dsp_timbre_get_samples(*(void *)(a1 + 944), *(void **)(a1 + 952), 0x80u);
            if (v74)
            {
              while (1)
              {
                uint64_t v9 = (*(uint64_t (**)(void, void, void, void))(*(void *)(a1 + 848) + 104))(*(void *)(a1 + 872), *(void *)(a1 + 880), *(void *)(a1 + 952), (2 * v74));
                if ((v9 & 0x80000000) != 0) {
                  break;
                }
                int v74 = dsp_timbre_get_samples(*(void *)(a1 + 944), *(void **)(a1 + 952), 0x80u);
                if (!v74) {
                  goto LABEL_95;
                }
              }
              log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2578, (uint64_t)"%s%x", v75, v76, v77, v78, "lhError");
            }
            else
            {
              uint64_t v9 = 0;
LABEL_95:
              *(_DWORD *)(a1 + 960) = 2;
              *a5 = 2;
            }
          }
        }
        else if (!v81)
        {
          *a5 = 0;
        }
      }
    }
    else
    {
      return 2360352778;
    }
  }
  return v9;
}

uint64_t dspeffects_ProcessEnd(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 55546, 992) & 0x80000000) != 0) {
    return 2360352776;
  }
  uint64_t v3 = synstrmaux_CloseStreams((_WORD *)(a1 + 24), *(void *)(a1 + 848));
  uint64_t v4 = *(void *)(a1 + 920);
  if (v4) {
    (*(void (**)(void, void))(v4 + 56))(*(void *)(a1 + 928), *(void *)(a1 + 936));
  }
  return v3;
}

uint64_t dspeffects_GetParamU32(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int a4)
{
  uint64_t UInt = paramc_ParamGetUInt(*(void *)(*(void *)(a1 + 16) + 40), a2, a3);
  if ((UInt & 0x80000000) != 0)
  {
    *a3 = a4;
    uint64_t UInt = paramc_ParamSetUInt(*(void *)(*(void *)(a1 + 16) + 40), a2, a4);
    if ((UInt & 0x80000000) != 0) {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2579, (uint64_t)"%s%s%s%x", v9, v10, v11, v12, "parameter");
    }
  }
  return UInt;
}

uint64_t dspeffects_GetParamS32(uint64_t a1, _DWORD *a2)
{
  uint64_t Int = paramc_ParamGetInt(*(void *)(*(void *)(a1 + 16) + 40), (uint64_t)"timbre_baseline", a2);
  if ((Int & 0x80000000) != 0)
  {
    *a2 = 100;
    uint64_t Int = paramc_ParamSetInt(*(void *)(*(void *)(a1 + 16) + 40), (uint64_t)"timbre_baseline", 0x64u);
    if ((Int & 0x80000000) != 0) {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2579, (uint64_t)"%s%s%s%x", v5, v6, v7, v8, "parameter");
    }
  }
  return Int;
}

uint64_t dspeffects_loc_ParamCheckChange(uint64_t a1, char *__s1, unsigned __int8 *a3, _DWORD *a4)
{
  *a4 = 1;
  if (!cstdlib_strcmp(__s1, "frequencyhz"))
  {
    uint64_t result = 2360352785;
    if (!*(void *)(a1 + 856) && !*(void *)(a1 + 872)) {
      return 0;
    }
LABEL_11:
    *a4 = 0;
    return result;
  }
  if (cstdlib_strcmp(__s1, "timbre"))
  {
    if (cstdlib_strcmp(__s1, "timbre_baseline") || cstdlib_atoi(a3) - 201 > 0xFFFFFF68) {
      return 0;
    }
    goto LABEL_10;
  }
  if (cstdlib_atoi(a3) - 201 < 0xFFFFFF69)
  {
LABEL_10:
    uint64_t result = 2360352783;
    goto LABEL_11;
  }
  return 0;
}

uint64_t dspeffects_loc_ParamLearnChange(uint64_t a1, char *__s1, char *a3)
{
  if (cstdlib_strcmp(__s1, "frequencyhz"))
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = 2360352785;
    if (!*(void *)(a1 + 856) && !*(void *)(a1 + 872))
    {
      uint64_t v6 = 0;
      *(_DWORD *)(a1 + 980) = LH_atou(a3);
    }
  }
  if (!cstdlib_strcmp(__s1, "timbre_baseline"))
  {
    int v7 = LH_atoi(a3);
    *(_DWORD *)(a1 + 976) = v7;
    *(_DWORD *)(a1 + 968) = MapProsodyValue_Scaling(50, 100, 200, v7, *(_DWORD *)(a1 + 964));
  }
  if (!cstdlib_strcmp(__s1, "timbre"))
  {
    *(_DWORD *)(a1 + 964) = cstdlib_atoi((unsigned __int8 *)a3);
    int v8 = *(_DWORD *)(a1 + 976);
    int v9 = cstdlib_atoi((unsigned __int8 *)a3);
    *(_DWORD *)(a1 + 968) = MapProsodyValue_Scaling(50, 100, 200, v8, v9);
  }
  return v6;
}

uint64_t signal_fifo_init(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v3 = 0xFFFFFFFFLL;
  if (a1 && (a3 - 3) >= 0xFFFFFFFE)
  {
    uint64_t v7 = dsp_malloc(a2, 0x28u);
    if (v7)
    {
      uint64_t v8 = v7;
      *(void *)uint64_t v7 = a2;
      *(_DWORD *)(v7 + 8) = a3;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(void *)(v7 + 16) = 0;
      uint64_t v3 = check_minimum_space((void *)v7, 0x800u / (unsigned __int16)a3);
      if (v3) {
        dsp_free(a2);
      }
      else {
        *a1 = v8;
      }
    }
    else
    {
      return 4294967294;
    }
  }
  return v3;
}

uint64_t check_minimum_space(void *a1, unsigned int a2)
{
  int v4 = *((_DWORD *)a1 + 7);
  int v3 = *((_DWORD *)a1 + 8);
  unsigned int v5 = *((_DWORD *)a1 + 6);
  int v6 = v4 - v3;
  unsigned int v7 = v4 - v3 + a2;
  if (v5 >= v7)
  {
    if (v5 - v4 >= a2)
    {
      return 0;
    }
    else
    {
      dsp_memmove_samples((void *)a1[2], (const void *)(a1[2] + 2 * (*((_DWORD *)a1 + 2) * v3)), *((_DWORD *)a1 + 2) * v6);
      uint64_t result = 0;
      *((_DWORD *)a1 + 7) = v6;
      *((_DWORD *)a1 + 8) = 0;
    }
  }
  else
  {
    if (v7 <= v5 + 2048) {
      unsigned int v8 = v5 + 2048;
    }
    else {
      unsigned int v8 = v4 - v3 + a2;
    }
    unsigned int v9 = v5 + 2048 + ((v8 + ~v5) & 0xFFFFF800);
    *((_DWORD *)a1 + 6) = v9;
    uint64_t v10 = (void *)dsp_malloc(*a1, 2 * v9 * *((_DWORD *)a1 + 2));
    if (v10)
    {
      uint64_t v11 = v10;
      uint64_t v12 = a1[2];
      if (v12)
      {
        if (*((_DWORD *)a1 + 6))
        {
          dsp_memcpy(v10, (const void *)(v12 + 2 * (*((_DWORD *)a1 + 2) * *((_DWORD *)a1 + 8))), (2 * v6 * *((_DWORD *)a1 + 2)));
          dsp_free(*a1);
        }
      }
      uint64_t result = 0;
      a1[2] = v11;
      *((_DWORD *)a1 + 7) = v6;
      *((_DWORD *)a1 + 8) = 0;
      *((_DWORD *)a1 + 6) = v9;
    }
    else
    {
      return 4294967294;
    }
  }
  return result;
}

uint64_t signal_fifo_deinit(void *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  float v2 = (void *)*a1;
  if (!*a1) {
    return 0;
  }
  if (v2[2])
  {
    dsp_free(*v2);
    v2[2] = 0;
    *((_DWORD *)v2 + 6) = 0;
  }
  dsp_free(*v2);
  uint64_t result = 0;
  *a1 = 0;
  return result;
}

uint64_t signal_fifo_set_backlog_size(uint64_t result, int a2)
{
  *(_DWORD *)(result + 36) = a2;
  return result;
}

uint64_t signal_fifo_get_rd_ptr(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16) + 2 * (*(_DWORD *)(result + 8) * *(_DWORD *)(result + 32));
  }
  return result;
}

uint64_t signal_fifo_get_num_unread_samples(_DWORD *a1)
{
  unsigned int v1 = a1[9];
  unsigned int v2 = a1[7] - a1[8];
  BOOL v3 = v2 >= v1;
  unsigned int v4 = v2 - v1;
  if (v3) {
    return v4;
  }
  else {
    return 0;
  }
}

uint64_t signal_fifo_get_num_free_samples(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 28));
}

uint64_t signal_fifo_get_wr_ptr(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16) + 2 * (*(_DWORD *)(result + 8) * *(_DWORD *)(result + 28));
  }
  return result;
}

uint64_t signal_fifo_push_samples(uint64_t a1, const void *a2, unsigned int a3)
{
  uint64_t v6 = check_minimum_space((void *)a1, a3);
  if (!v6)
  {
    if (a1)
    {
      int v7 = *(_DWORD *)(a1 + 8);
      unsigned int v8 = (void *)(*(void *)(a1 + 16) + 2 * (v7 * *(_DWORD *)(a1 + 28)));
    }
    else
    {
      unsigned int v8 = 0;
      int v7 = MEMORY[8];
    }
    dsp_memcpy(v8, a2, 2 * a3 * v7);
    *(_DWORD *)(a1 + 28) += a3;
  }
  return v6;
}

uint64_t signal_fifo_push_samples_nodata(uint64_t a1, unsigned int a2)
{
  uint64_t result = check_minimum_space((void *)a1, a2);
  if (!result) {
    *(_DWORD *)(a1 + 28) += a2;
  }
  return result;
}

uint64_t signal_fifo_get_samples(uint64_t a1, void *a2, unsigned int a3)
{
  int v3 = *(_DWORD *)(a1 + 32);
  unsigned int v4 = *(_DWORD *)(a1 + 36);
  unsigned int v5 = *(_DWORD *)(a1 + 28) - v3;
  BOOL v6 = v5 >= v4;
  unsigned int v7 = v5 - v4;
  if (!v6) {
    unsigned int v7 = 0;
  }
  if (v7 >= a3) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = v7;
  }
  if (v8)
  {
    dsp_memcpy(a2, (const void *)(*(void *)(a1 + 16) + 2 * (*(_DWORD *)(a1 + 8) * v3)), (2 * v8 * *(_DWORD *)(a1 + 8)));
    *(_DWORD *)(a1 + 32) += v8;
  }
  return v8;
}

uint64_t signal_fifo_pop_samples(_DWORD *a1, unsigned int a2)
{
  int v3 = a1[8];
  unsigned int v2 = a1[9];
  unsigned int v4 = a1[7] - v3;
  BOOL v5 = v4 >= v2;
  LODWORD(v6) = v4 - v2;
  if (!v5) {
    LODWORD(v6) = 0;
  }
  if (v6 >= a2) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = v6;
  }
  a1[8] = v6 + v3;
  return v6;
}

uint64_t signal_fifo_move_samples(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = (_DWORD *)a2;
  if (a2)
  {
    int v3 = *(_DWORD *)(a2 + 32);
    a2 = *(void *)(a2 + 16) + 2 * (*(_DWORD *)(a2 + 8) * v3);
  }
  else
  {
    int v3 = MEMORY[0x20];
  }
  unsigned int v4 = v2[9];
  unsigned int v5 = v2[7] - v3;
  BOOL v6 = v5 >= v4;
  unsigned int v7 = v5 - v4;
  if (v6) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t result = signal_fifo_push_samples(a1, (const void *)a2, v8);
  if (!result)
  {
    int v11 = v2[8];
    unsigned int v10 = v2[9];
    unsigned int v12 = v2[7] - v11;
    BOOL v6 = v12 >= v10;
    unsigned int v13 = v12 - v10;
    if (!v6) {
      unsigned int v13 = 0;
    }
    if (v13 >= v8) {
      unsigned int v13 = v8;
    }
    v2[8] = v13 + v11;
    return v8;
  }
  return result;
}

uint64_t signal_fifo_clear(uint64_t a1)
{
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  check_minimum_space((void *)a1, 0x800u / *(_DWORD *)(a1 + 8));
  return 0;
}

uint64_t dsp_biquad_init(void *a1, uint64_t a2, int a3, int a4)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (void *)dsp_malloc(a2, 0x38u);
  if (v8)
  {
    unsigned int v9 = v8;
    *a1 = 0;
    *uint64_t v8 = a2;
    uint64_t v10 = dsp_malloc(a2, 4 * a3 * a4);
    v9[5] = v10;
    if (v10)
    {
      uint64_t v11 = dsp_malloc(a2, 4 * a3 * a4);
      v9[6] = v11;
      if (v11)
      {
        uint64_t result = 0;
        *((_DWORD *)v9 + 2) = 0;
        *((_DWORD *)v9 + 3) = a3;
        *((_DWORD *)v9 + 4) = a4;
        *a1 = v9;
        return result;
      }
      dsp_free(a2);
    }
    dsp_free(a2);
  }
  return 4294967294;
}

void *dsp_biquad_deinit(void *result)
{
  if (result)
  {
    unsigned int v1 = (void *)*result;
    if (*result)
    {
      dsp_free(*v1);
      dsp_free(*v1);
      uint64_t v2 = *v1;
      return (void *)dsp_free(v2);
    }
  }
  return result;
}

uint64_t dsp_biquad_create_low_pass_filter(uint64_t a1, float a2)
{
  *(_DWORD *)(a1 + 8) = 1;
  long double v3 = tan((float)(a2 * 3.1416));
  *(float *)&long double v3 = v3;
  __asm { FMOV            V4.2S, #-1.0 }
  _D4.f32[0] = *(float *)&v3 + 1.0;
  float32x2_t v9 = vmla_n_f32(_D4, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v3, 0), *(float *)&v3);
  __asm { FMOV            V2.2S, #1.0 }
  float32x2_t v11 = vdiv_f32(_D2, v9);
  float32x2_t v12 = vadd_f32(v9, v9);
  float32x2_t v13 = (float32x2_t)vdup_lane_s32((int32x2_t)v11, 0);
  float v14 = (float)((float)(1.0 - *(float *)&v3) + (float)(*(float *)&v3 * *(float *)&v3)) * v11.f32[0];
  v11.i32[1] = v12.i32[1];
  v13.f32[0] = *(float *)&v3 * *(float *)&v3;
  float32x2_t v15 = vmul_f32(v11, v13);
  *(_DWORD *)(a1 + 20) = v15.i32[0];
  *(float *)(a1 + 24) = v15.f32[0] + v15.f32[0];
  *(float32x2_t *)(a1 + 28) = v15;
  *(float *)(a1 + 36) = v14;
  uint64_t v16 = (*(_DWORD *)(a1 + 16) * *(_DWORD *)(a1 + 12));
  if (v16)
  {
    uint64_t v17 = *(_DWORD **)(a1 + 40);
    uint64_t v18 = *(_DWORD **)(a1 + 48);
    do
    {
      *v17++ = 0;
      *v18++ = 0;
      --v16;
    }
    while (v16);
  }
  return 0;
}

float dsp_biquad_process(uint64_t a1, unsigned int a2, float a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if (!v3) {
    return 0.0;
  }
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  do
  {
    float v6 = *(float *)(v4 + 4 * a2) + (float)(a3 * *(float *)(a1 + 20));
    *(float *)(v4 + 4 * a2) = (float)(*(float *)(v5 + 4 * a2) + (float)(a3 * *(float *)(a1 + 24)))
                              - (float)(*(float *)(a1 + 32) * v6);
    *(float *)(v5 + 4 * a2++) = (float)(a3 * *(float *)(a1 + 28)) - (float)(*(float *)(a1 + 36) * v6);
    a3 = v6;
    --v3;
  }
  while (v3);
  return v6;
}

uint64_t dsp_biquad_process_fifos(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t num_unread_samples = signal_fifo_get_num_unread_samples(a3);
  uint64_t rd_ptr = signal_fifo_get_rd_ptr((uint64_t)a3);
  signal_fifo_ensure_free_space(a2, num_unread_samples);
  uint64_t wr_ptr = signal_fifo_get_wr_ptr(a2);
  if (num_unread_samples)
  {
    uint64_t v9 = wr_ptr;
    int v10 = 0;
    unint64_t v11 = *(unsigned int *)(a1 + 12);
    do
    {
      if (v11)
      {
        for (unint64_t i = 0; i < v11; ++i)
        {
          float v13 = dsp_biquad_process(a1, i, (float)*(__int16 *)(rd_ptr + 2 * i));
          if (v13 >= -32767.0) {
            float v14 = v13;
          }
          else {
            float v14 = -32767.0;
          }
          if (v13 <= 32767.0) {
            float v15 = v14;
          }
          else {
            float v15 = 32767.0;
          }
          *(_WORD *)(v9 + 2 * i) = (int)v15;
          unint64_t v11 = *(unsigned int *)(a1 + 12);
        }
      }
      rd_ptr += 2 * v11;
      v9 += 2 * v11;
      ++v10;
    }
    while (v10 != num_unread_samples);
  }
  signal_fifo_pop_samples(a3, num_unread_samples);

  return signal_fifo_push_samples_nodata(a2, num_unread_samples);
}

uint64_t dsp_biquad_process_to_fifo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v4 = a4;
  uint64_t result = signal_fifo_ensure_free_space(a2, a4);
  if (!result)
  {
    uint64_t wr_ptr = signal_fifo_get_wr_ptr(a2);
    if (v4)
    {
      uint64_t v10 = wr_ptr;
      int v11 = 0;
      unint64_t v12 = *(unsigned int *)(a1 + 12);
      do
      {
        if (v12)
        {
          for (unint64_t i = 0; i < v12; ++i)
          {
            float v14 = dsp_biquad_process(a1, i, (float)*(__int16 *)(a3 + 2 * i));
            if (v14 >= -32767.0) {
              float v15 = v14;
            }
            else {
              float v15 = -32767.0;
            }
            if (v14 <= 32767.0) {
              float v16 = v15;
            }
            else {
              float v16 = 32767.0;
            }
            *(_WORD *)(v10 + 2 * i) = (int)v16;
            unint64_t v12 = *(unsigned int *)(a1 + 12);
          }
        }
        a3 += 2 * v12;
        v10 += 2 * v12;
        ++v11;
      }
      while (v11 != v4);
    }
    return signal_fifo_push_samples_nodata(a2, v4);
  }
  return result;
}

uint64_t dsp_biquad_flush(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 12);
  if (v1)
  {
    uint64_t v2 = *(_DWORD **)(result + 40);
    uint64_t v3 = *(_DWORD **)(result + 48);
    do
    {
      *v2++ = 0;
      *v3++ = 0;
      --v1;
    }
    while (v1);
  }
  return result;
}

uint64_t smcl16bespi_DecoderOpen(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 != 69890) {
    return 2264932608;
  }
  if (!a8) {
    return 2264932360;
  }
  *(void *)a8 = 43981;
  *(_DWORD *)(a8 + 8) = 65648;
  if (a2) {
    return 2264932359;
  }
  else {
    return 0;
  }
}

uint64_t smcl16bespi_DecoderClose()
{
  return 0;
}

uint64_t smcl16bespi_DecoderProcess(uint64_t a1, uint64_t a2, int a3, uint64_t a4, _WORD *a5, uint64_t a6, uint64_t a7, _WORD *a8)
{
  return smcl16bespi_EncoderProcess(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t smcl16bespi_DecoderResetMemory()
{
  return 0;
}

uint64_t dsmcl16bespi_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2264932353;
  }
  uint64_t result = 0;
  *a2 = &coder_I;
  return result;
}

uint64_t SwapL16ByteOrderbe(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    unsigned int v4 = (char *)(a1 + 1);
    uint64_t v5 = (unsigned char *)(a2 + 1);
    do
    {
      char v6 = *(v4 - 1);
      char v7 = *v4;
      v4 += 2;
      *(v5 - 1) = v7;
      *uint64_t v5 = v6;
      v5 += 2;
      --v3;
    }
    while (v3);
  }
  return 0;
}

uint64_t smcl16bespi_EncoderOpen(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 != 73986) {
    return 2264932608;
  }
  if (!a8) {
    return 2264932360;
  }
  *(void *)a8 = 4660;
  *(_DWORD *)(a8 + 8) = 112;
  if (a2) {
    return 2264932359;
  }
  else {
    return 0;
  }
}

uint64_t smcl16bespi_EncoderClose()
{
  return 0;
}

uint64_t smcl16bespi_EncoderProcess(uint64_t a1, uint64_t a2, int a3, uint64_t a4, _WORD *a5, uint64_t a6, uint64_t a7, _WORD *a8)
{
  if (a8 && a5 && a4 && a7)
  {
    unsigned int v8 = (unsigned __int16)*a5;
    if (*a5)
    {
      if (a3)
      {
        *a5 = 0;
        *a8 = 0;
        return 2264932353;
      }
      if (v8 <= 1)
      {
        *a5 = 0;
        *a8 = 0;
        return 2264932361;
      }
      if (v8 == 0xFFFF)
      {
        LOWORD(v8) = -1;
      }
      else if ((v8 & 1) == 0)
      {
        goto LABEL_20;
      }
      LOWORD(v8) = v8 - 1;
      *a5 = v8;
LABEL_20:
      *a8 = v8;
      SwapL16ByteOrderbe(a4, a7, (unsigned __int16)*a5 >> 1);
      return 0;
    }
  }
  else if (!a5)
  {
    goto LABEL_10;
  }
  *a5 = 0;
LABEL_10:
  uint64_t result = 2264932358;
  if (a8) {
    *a8 = 0;
  }
  return result;
}

uint64_t esmcl16bespi_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2264932353;
  }
  uint64_t result = 0;
  *a2 = &coder_I_0;
  return result;
}

uint64_t smcl16bespi_GetInfo(int a1, int a2, int a3, int a4, int a5, int32x2_t *__b)
{
  uint64_t v9 = 2264932608;
  if (a5 == 1)
  {
    if (a1 != 73986) {
      return v9;
    }
    goto LABEL_6;
  }
  if (a1 == 69890 && a2 == 8000)
  {
LABEL_6:
    if (__b)
    {
      cstdlib_memset(__b, 0, 0x24uLL);
      __b[1].i32[0] = 0;
      if (a3)
      {
        return 2264932359;
      }
      else
      {
        *long long __b = vdup_n_s32(0x1F400u);
        *(int32x2_t *)((char *)&__b[2] + 6) = (int32x2_t)0xFFF80010FFFF0002;
        if (a4)
        {
          return 2264932353;
        }
        else
        {
          uint64_t v9 = 0;
          __b[2].i16[2] = 2;
          *(__int32 *)((char *)&__b[3].i32[1] + 2) = 0;
          *(int32x2_t *)((char *)&__b[1] + 4) = (int32x2_t)0x1F4000000000;
        }
      }
    }
    else
    {
      return 2264932358;
    }
  }
  return v9;
}

uint64_t smcl16lespi_DecoderOpen(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 != 69890) {
    return 2265981184;
  }
  if (!a8) {
    return 2265980936;
  }
  *(void *)a8 = 43981;
  *(_DWORD *)(a8 + 8) = 65649;
  if (a2) {
    return 2265980935;
  }
  else {
    return 0;
  }
}

uint64_t smcl16lespi_DecoderClose()
{
  return 0;
}

uint64_t smcl16lespi_DecoderProcess(int a1, int a2, int a3, void *__src, _WORD *a5, int a6, void *__dst, _WORD *a8)
{
  return smcl16lespi_EncoderProcess(a1, a2, a3, __src, a5, a6, __dst, a8);
}

uint64_t smcl16lespi_DecoderResetMemory()
{
  return 0;
}

uint64_t dsmcl16lespi_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2265980929;
  }
  uint64_t result = 0;
  *a2 = &coder_I_1;
  return result;
}

uint64_t smcl16lespi_GetInfo(int a1, int a2, int a3, int a4, int a5, int32x2_t *__b)
{
  uint64_t v9 = 2265981184;
  if (a5 == 1)
  {
    if (a1 != 73986) {
      return v9;
    }
    goto LABEL_6;
  }
  if (a1 == 69890 && a2 == 8001)
  {
LABEL_6:
    if (__b)
    {
      cstdlib_memset(__b, 0, 0x24uLL);
      __b[1].i32[0] = 0;
      if (a3)
      {
        return 2265980935;
      }
      else
      {
        *long long __b = vdup_n_s32(0x1F400u);
        *(int32x2_t *)((char *)&__b[2] + 6) = (int32x2_t)0xFFF80010FFFF0002;
        if (a4)
        {
          return 2265980929;
        }
        else
        {
          uint64_t v9 = 0;
          __b[2].i16[2] = 2;
          *(__int32 *)((char *)&__b[3].i32[1] + 2) = 0;
          *(int32x2_t *)((char *)&__b[1] + 4) = (int32x2_t)0x1F4100000000;
        }
      }
    }
    else
    {
      return 2265980934;
    }
  }
  return v9;
}

uint64_t smcl16lespi_EncoderOpen(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 != 73986) {
    return 2265981184;
  }
  if (!a8) {
    return 2265980936;
  }
  *(void *)a8 = 4660;
  *(_DWORD *)(a8 + 8) = 113;
  if (a2) {
    return 2265980935;
  }
  else {
    return 0;
  }
}

uint64_t smcl16lespi_EncoderClose()
{
  return 0;
}

uint64_t smcl16lespi_EncoderProcess(int a1, int a2, int a3, void *__src, _WORD *a5, int a6, void *__dst, _WORD *a8)
{
  if (a8 && a5 && __src && __dst)
  {
    unsigned int v8 = (unsigned __int16)*a5;
    if (*a5)
    {
      if (a3)
      {
        *a5 = 0;
        *a8 = 0;
        return 2265980929;
      }
      if (v8 <= 1)
      {
        *a5 = 0;
        *a8 = 0;
        return 2265980937;
      }
      if (v8 == 0xFFFF)
      {
        LOWORD(v8) = -1;
      }
      else if ((v8 & 1) == 0)
      {
        goto LABEL_20;
      }
      LOWORD(v8) = v8 - 1;
      *a5 = v8;
LABEL_20:
      *a8 = v8;
      SwapL16ByteOrderle(__src, __dst, (unsigned __int16)*a5 >> 1);
      return 0;
    }
  }
  else if (!a5)
  {
    goto LABEL_10;
  }
  *a5 = 0;
LABEL_10:
  uint64_t result = 2265980934;
  if (a8) {
    *a8 = 0;
  }
  return result;
}

uint64_t esmcl16lespi_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2265980929;
  }
  uint64_t result = 0;
  *a2 = &coder_I_2;
  return result;
}

uint64_t SwapL16ByteOrderle(void *__src, void *__dst, unsigned int a3)
{
  return 0;
}

uint64_t DICT_Init(uint64_t a1, uint64_t a2, int a3, int a4)
{
  char __src = 0;
  uint64_t v7 = BINTREE_Construct(a2, 0, a3);
  *(void *)a1 = v7;
  if (v7)
  {
    *(void *)(a1 + 8) = CompFunc1;
    *(void *)(a1 + 16) = CompFunc2;
    *(_DWORD *)(a1 + 64) = -1;
    *(void *)(a1 + 72) = a2;
    unsigned int v8 = (unsigned int *)(a1 + 24);
    ARRAY_Init((uint64_t)v8, a2, 1, a4);
    if (ARRAY_Add(v8, &__src) == -1) {
      return err_GenerateErrorResource();
    }
    else {
      return 0;
    }
  }
  else
  {
    return err_GenerateErrorResource();
  }
}

uint64_t CompFunc1(uint64_t a1, int a2, int a3)
{
  return cstdlib_strcmp((const char *)(*(void *)(a1 + 24) + (*(_DWORD *)(a1 + 40) * a2)), (const char *)(*(void *)(a1 + 24) + (*(_DWORD *)(a1 + 40) * a3)));
}

uint64_t CompFunc2(uint64_t a1, char *__s1, int a3)
{
  return cstdlib_strcmp(__s1, (const char *)(*(void *)(a1 + 24) + (*(_DWORD *)(a1 + 40) * a3)));
}

uint64_t DICT_InitData(void *a1, uint64_t a2, int a3, uint64_t a4, unsigned int a5)
{
  *a1 = a2;
  a1[1] = CompFunc1;
  a1[2] = CompFunc2;
  return ARRAY_InitData((uint64_t)(a1 + 3), 1u, a3, a4, a5);
}

uint64_t DICT_Destruct(uint64_t *a1)
{
  uint64_t v1 = (uint64_t)(a1 + 3);
  BINTREE_Destruct(*a1);

  return ARRAY_Flush(v1);
}

uint64_t DICT_Add(uint64_t a1, char *__s, void *a3, int a4, _DWORD *a5)
{
  int __src = a4;
  int v9 = cstdlib_strlen(__s);
  unsigned int v10 = ARRAY_AddBuf((unsigned int *)(a1 + 24), __s, v9 + 1, 1u);
  *a5 = 1;
  if (v10 == -1)
  {
    return err_GenerateErrorResource();
  }
  else
  {
    unsigned int v11 = v10;
    if (ARRAY_AddBuf((unsigned int *)(a1 + 24), &__src, 4, 4u) == -1) {
      return err_GenerateErrorResource();
    }
    if (ARRAY_AddBuf((unsigned int *)(a1 + 24), a3, __src, 1u) == -1) {
      return err_GenerateErrorResource();
    }
    int v12 = BINTREE_Add((uint64_t *)a1, (uint64_t (**)(void, void, void))(a1 + 8), v11);
    if (v12 == -1) {
      return err_GenerateErrorResource();
    }
    int v13 = v12;
    int v21 = 0;
    if (ARRAY_AddBuf((unsigned int *)(a1 + 24), &v21, 4, 4u) == -1)
    {
      return err_GenerateErrorResource();
    }
    else if (v13)
    {
      float v14 = (const char *)(*(void *)(a1 + 32) + (*(_DWORD *)(a1 + 48) * v13));
      size_t v15 = cstdlib_strlen(v14);
      uint64_t result = 0;
      uint64_t v17 = (uint64_t)&v14[v15 + 1];
      uint64_t v18 = 4 - (v17 & 3);
      if ((v17 & 3) == 0) {
        uint64_t v18 = 0;
      }
      uint64_t v19 = *(unsigned int *)(v17 + v18) + v17 + v18 + 4;
      uint64_t v20 = 4 - (v19 & 3);
      if ((v19 & 3) == 0) {
        uint64_t v20 = 0;
      }
      *(_DWORD *)(v19 + v20) = v11;
      *a5 = 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t DICT_Find(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  int v7 = *(_DWORD *)(a1 + 64);
  if (v7 == -1)
  {
    int v7 = BINTREE_Find(*(void *)a1, a1 + 8, a2);
    if (v7) {
      goto LABEL_3;
    }
LABEL_11:
    *a4 = 1;
    return 0;
  }
  if (!v7) {
    goto LABEL_11;
  }
LABEL_3:
  *a4 = 0;
  unsigned int v8 = (const char *)(*(void *)(a1 + 32) + (*(_DWORD *)(a1 + 48) * v7));
  *(void *)a3 = v8;
  size_t v9 = (size_t)&v8[cstdlib_strlen(v8) + 1];
  uint64_t v10 = 4 - (v9 & 3);
  if ((v9 & 3) == 0) {
    uint64_t v10 = 0;
  }
  unsigned int v11 = (unsigned int *)(v9 + v10);
  unsigned int v12 = *v11++;
  int v13 = (char *)v11 + v12;
  *(_DWORD *)(a3 + 16) = v12;
  *(void *)(a3 + 8) = v11;
  if ((v13 & 3) != 0) {
    uint64_t v14 = 4 - (v13 & 3);
  }
  else {
    uint64_t v14 = 0;
  }
  int v15 = *(_DWORD *)&v13[v14];
  *(_DWORD *)(a1 + 64) = v15;
  if (v15)
  {
    *(_DWORD *)(a3 + 20) = 1;
  }
  else
  {
    *(_DWORD *)(a3 + 20) = 0;
    *(_DWORD *)(a1 + 64) = -1;
  }
  return 0;
}

uint64_t DICT_Remove(uint64_t a1, uint64_t a2, _DWORD *a3, int *a4)
{
  *a3 = 0;
  uint64_t v8 = a1 + 8;
  uint64_t result = BINTREE_Find(*(void *)a1, a1 + 8, a2);
  if (result)
  {
    do
    {
      uint64_t v10 = (const char *)(*(void *)(a1 + 32) + (*(_DWORD *)(a1 + 48) * result));
      size_t v11 = (size_t)&v10[cstdlib_strlen(v10) + 1];
      uint64_t v12 = 4 - (v11 & 3);
      if ((v11 & 3) == 0) {
        uint64_t v12 = 0;
      }
      uint64_t v13 = v11 + v12 + *(int *)(v11 + v12) + 4;
      uint64_t v14 = 4 - (v13 & 3);
      if ((v13 & 3) == 0) {
        uint64_t v14 = 0;
      }
      unsigned int v16 = *(_DWORD *)(v13 + v14);
      LODWORD(result) = v16;
      ++*a3;
    }
    while (result);
    uint64_t result = BINTREE_Remove(*(void *)a1, v8, a2, &v16);
    if (result) {
      int v15 = -1;
    }
    else {
      int v15 = v16 == 0;
    }
  }
  else
  {
    int v15 = 1;
  }
  *a4 = v15;
  return result;
}

size_t DICTITT_Current@<X0>(unsigned int *a1@<X0>, uint64_t a2@<X8>)
{
  unsigned int v4 = a1[16];
  if (v4 == -1) {
    unsigned int v4 = *(_DWORD *)BINTREEITT_Current(a1 + 2);
  }
  uint64_t v5 = (const char *)(*(void *)(*(void *)a1 + 32) + *(_DWORD *)(*(void *)a1 + 48) * v4);
  *(void *)a2 = v5;
  size_t result = cstdlib_strlen(v5);
  uint64_t v7 = (uint64_t)&v5[result + 1];
  uint64_t v8 = 4 - (v7 & 3);
  if ((v7 & 3) == 0) {
    uint64_t v8 = 0;
  }
  size_t v9 = (unsigned int *)(v7 + v8);
  unsigned int v11 = *v9++;
  unsigned int v10 = v11;
  uint64_t v12 = (char *)v9 + v11;
  *(void *)(a2 + 8) = v9;
  if ((v12 & 3) != 0) {
    uint64_t v13 = 4 - (v12 & 3);
  }
  else {
    uint64_t v13 = 0;
  }
  int v14 = *(_DWORD *)&v12[v13];
  BOOL v15 = v14 == 0;
  if (!v14) {
    int v14 = -1;
  }
  a1[16] = v14;
  int v16 = !v15;
  *(_DWORD *)(a2 + 16) = v10;
  *(_DWORD *)(a2 + 20) = v16;
  return result;
}

uint64_t DICTITT_Init(uint64_t a1, uint64_t *a2)
{
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 64) = -1;
  return BINTREEITT_Init(a1 + 8, *a2);
}

void *ARRAY_Init(uint64_t a1, uint64_t a2, int a3, int a4)
{
  size_t result = cstdlib_memset((void *)a1, 0, 0x28uLL);
  *(_DWORD *)(a1 + 16) = a4;
  *(_DWORD *)(a1 + 24) = a3;
  *(void *)(a1 + 32) = a2;
  return result;
}

uint64_t ARRAY_InitData(uint64_t a1, unsigned int a2, int a3, uint64_t a4, unsigned int a5)
{
  *(void *)(a1 + 8) = a4;
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 20) = a5 / a2;
  *(_DWORD *)(a1 + 24) = a2;
  *(_DWORD *)a1 = a5 / a2;
  return 0;
}

uint64_t ARRAY_operatorequal(void *__dst, const void **__src)
{
  unsigned int v8 = 0;
  uint64_t v4 = __dst[1];
  if (v4) {
    OOCAllocator_Free(__dst[4], v4);
  }
  cstdlib_memcpy(__dst, __src, 0x28uLL);
  uint64_t v5 = (void *)OOCAllocator_Malloc(__dst[4], (*((_DWORD *)__dst + 6) * *((_DWORD *)__dst + 5)), &v8);
  __dst[1] = v5;
  uint64_t v6 = v8;
  if (!v8)
  {
    cstdlib_memcpy(v5, __src[1], (*((_DWORD *)__dst + 6) * *(_DWORD *)__dst));
    return v8;
  }
  return v6;
}

uint64_t ARRAY_InitCopy(void *__dst, const void **__src)
{
  __dst[1] = 0;
  return ARRAY_operatorequal(__dst, __src);
}

uint64_t ARRAY_Add(unsigned int *a1, void *__src)
{
  int v9 = 0;
  unsigned int v4 = *a1;
  unsigned int v5 = a1[5];
  if (*a1 >= v5)
  {
    unsigned int v7 = a1[4] + v5;
    a1[5] = v7;
    uint64_t v6 = OOCAllocator_Realloc(*((void *)a1 + 4), *((void *)a1 + 1), a1[6] * v7, &v9);
    *((void *)a1 + 1) = v6;
    if (v9) {
      return 0xFFFFFFFFLL;
    }
    unsigned int v4 = *a1;
  }
  else
  {
    uint64_t v6 = *((void *)a1 + 1);
  }
  cstdlib_memcpy((void *)(v6 + a1[6] * v4), __src, a1[6]);
  uint64_t result = *a1;
  *a1 = result + 1;
  return result;
}

uint64_t ARRAY_AddBuf(unsigned int *a1, void *__src, int a3, unsigned int a4)
{
  unsigned int v7 = *a1;
  unsigned int v8 = a1[5];
  unsigned int v9 = a1[6];
  int v17 = 0;
  if (v7 % a4) {
    unsigned int v10 = a4 - v7 % a4;
  }
  else {
    unsigned int v10 = 0;
  }
  uint64_t v11 = v10 + v7;
  unsigned int v12 = v11 + a3;
  if ((int)v11 + a3 <= v8)
  {
    uint64_t v15 = *((void *)a1 + 1);
LABEL_12:
    cstdlib_memcpy((void *)(v15 + v11 * v9), __src, v9 * a3);
    *a1 = v12;
    return v11;
  }
  unsigned int v13 = a1[4] + v8;
  if (v12 <= v13) {
    unsigned int v14 = v13;
  }
  else {
    unsigned int v14 = v11 + a3;
  }
  uint64_t v15 = OOCAllocator_Realloc(*((void *)a1 + 4), *((void *)a1 + 1), v14 * v9, &v17);
  *((void *)a1 + 1) = v15;
  if (!v17)
  {
    a1[5] = v14;
    goto LABEL_12;
  }
  return 0xFFFFFFFFLL;
}

uint64_t ARRAY_Destroy(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)a1 <= a2)
  {
    return err_GenerateErrorArg();
  }
  else
  {
    uint64_t v2 = *(int *)(a1 + 24);
    int v3 = *(_DWORD *)a1 - 1;
    *(_DWORD *)a1 = v3;
    unsigned int v4 = (char *)(*(void *)(a1 + 8) + (int)(v2 * a2));
    cstdlib_memcpy(v4, &v4[v2], v2 * (v3 - a2));
    return 0;
  }
}

uint64_t ARRAY_Flush(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    OOCAllocator_Free(v2, *(void *)(a1 + 8));
  }
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  return 0;
}

uint64_t ARRAY_Find(uint64_t a1, void *__s2)
{
  size_t v2 = *(unsigned int *)(a1 + 24);
  uint64_t v3 = (*(_DWORD *)a1 * v2);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = 0;
  uint64_t v6 = *(char **)(a1 + 8);
  unsigned int v7 = &v6[v3];
  while (cstdlib_memcmp(v6, __s2, v2))
  {
    v6 += v2;
    uint64_t v5 = (v5 + 1);
    if (v6 >= v7) {
      return 0xFFFFFFFFLL;
    }
  }
  return v5;
}

uint64_t ARRAYITT_Init(uint64_t result, uint64_t a2)
{
  *(void *)(result + 16) = a2;
  uint64_t v2 = *(void *)(a2 + 8);
  int v3 = *(_DWORD *)(a2 + 24);
  uint64_t v4 = v2 + (v3 * *(_DWORD *)a2);
  *(void *)uint64_t result = v2;
  *(void *)(result + 8) = v4;
  *(_DWORD *)(result + 24) = v3;
  return result;
}

uint64_t TREENODE_Init(uint64_t result, int a2)
{
  *(unsigned char *)(result + 16) = 0;
  *(_DWORD *)uint64_t result = a2;
  *(_DWORD *)(result + 4) = a2;
  *(void *)(result + 8) = 0;
  return result;
}

uint64_t BINTREE_Construct(uint64_t a1, unsigned int a2, int a3)
{
  int v9 = 0;
  uint64_t v6 = OOCAllocator_Calloc(a1, 1, 24, &v9);
  uint64_t v8 = v6;
  if (v9) {
    return 0;
  }
  *(_DWORD *)(v6 + 12) = a3;
  *(void *)(v6 + 16) = a1;
  if (BINTREE_IncreaseHeap(&v8, a2)) {
    return 0;
  }
  else {
    return v8;
  }
}

uint64_t BINTREE_IncreaseHeap(uint64_t *a1, unsigned int a2)
{
  uint64_t v4 = *a1;
  int v11 = 0;
  unsigned int v5 = *(_DWORD *)v4;
  if (!a2) {
    a2 = *(_DWORD *)(v4 + 12) + v5;
  }
  if (a2 < v5) {
    return 0;
  }
  unsigned int v7 = (unsigned int *)OOCAllocator_Realloc(*(void *)(v4 + 16), v4, 20 * a2 + 24, &v11);
  if (v11) {
    return 1;
  }
  *a1 = (uint64_t)v7;
  uint64_t v8 = v7 + 6;
  unsigned int v9 = *v7;
  unsigned int v10 = *v7 + 1;
  *unsigned int v7 = a2;
  v7[1] = v10;
  if (v10 < a2)
  {
    unsigned int v9 = v10 - 1;
    do
    {
      v8[5 * v9 + 2] = v9 + 2;
      ++v9;
    }
    while (a2 - 1 != v9);
  }
  uint64_t result = 0;
  v8[5 * v9 + 2] = 0;
  return result;
}

uint64_t BINTREE_NewNode(uint64_t *a1, unsigned int a2)
{
  uint64_t v3 = *a1;
  uint64_t v9 = v3;
  if (*(_DWORD *)(v3 + 4)) {
    goto LABEL_2;
  }
  if (!BINTREE_IncreaseHeap(&v9, 0))
  {
    uint64_t v3 = v9;
    *a1 = v9;
LABEL_2:
    unsigned int v6 = *(_DWORD *)(v3 + 4);
    unsigned int v5 = (_DWORD *)(v3 + 4);
    uint64_t result = v6;
    unsigned int v7 = (int32x2_t *)&v5[5 * v6];
    *unsigned int v5 = v7[1].i32[0];
    v7[2].i8[0] = 0;
    *unsigned int v7 = vdup_n_s32(a2);
    v7[1] = 0;
    return result;
  }
  return 0xFFFFFFFFLL;
}

_DWORD *BINTREE_DeleteNode(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 4);
  uint64_t result = (_DWORD *)(a1 + 4);
  result[5 * a2 + 2] = v3;
  *uint64_t result = a2;
  return result;
}

uint64_t BINTREE_Add(uint64_t *a1, uint64_t (**a2)(void, void, void), unsigned int a3)
{
  uint64_t result = BINTREE_NewNode(a1, a3);
  if (result != -1)
  {
    int v7 = result;
    uint64_t v8 = *a1;
    int v9 = *(_DWORD *)(*a1 + 8);
    if (v9)
    {
      int v69 = result;
      unsigned int v70 = a3;
      int v10 = 0;
      int v11 = 0;
      uint64_t v68 = *a1;
      unsigned int v12 = (_DWORD *)(v8 + 4);
      int v13 = *(_DWORD *)(*a1 + 8);
      while (1)
      {
        int v14 = v13;
        int v15 = v13;
        int v16 = &v12[5 * v13];
        unsigned int v18 = v16[1];
        int v17 = v16 + 1;
        uint64_t v19 = v12;
        int v20 = *((unsigned __int8 *)v17 + 12);
        int v21 = (*a2)(a2, v70, v18);
        if (!v21) {
          break;
        }
        if (v20)
        {
          int v9 = v15;
          int v11 = v10;
        }
        uint64_t v22 = &v19[5 * v15];
        uint64_t v23 = v22 + 2;
        uint64_t v24 = v22 + 3;
        if (v21 >= 0) {
          uint64_t v23 = v24;
        }
        int v13 = *v23;
        int v10 = v14;
        unsigned int v12 = v19;
        if (!*v23)
        {
          *uint64_t v23 = v69;
          uint64_t v25 = &v19[5 * v9];
          int v26 = (*a2)(a2, v70, v25[1]);
          uint64_t v27 = (int *)(v25 + 2);
          int v67 = v26;
          if (v26 < 0) {
            int v28 = 1;
          }
          else {
            int v28 = -1;
          }
          uint64_t v65 = v25 + 2;
          uint64_t v66 = v25 + 3;
          if (v26 >= 0) {
            uint64_t v27 = (int *)(v25 + 3);
          }
          int v29 = *v27;
          if (*v27 != v69)
          {
            int v30 = *v27;
            do
            {
              uint64_t v31 = &v19[5 * v30];
              int v32 = (*a2)(a2, v70, v31[1]);
              long long v33 = v31 + 2;
              if (v32 < 0) {
                char v34 = 1;
              }
              else {
                char v34 = -1;
              }
              if (v32 >= 0) {
                long long v33 = v31 + 3;
              }
              *((unsigned char *)v31 + 16) = v34;
              int v30 = *v33;
            }
            while (v30 != v69);
          }
          uint64_t v35 = &v19[5 * v9];
          int v38 = *((char *)v35 + 16);
          unsigned int v36 = (char *)(v35 + 4);
          int v37 = v38;
          if (!v38)
          {
            uint64_t result = 0;
            *unsigned int v36 = v28;
            return result;
          }
          if (!(v28 + v37))
          {
            uint64_t result = 0;
            *unsigned int v36 = 0;
            return result;
          }
          int v40 = &v19[5 * v29];
          int v43 = *((unsigned __int8 *)v40 + 16);
          uint64_t v41 = (char *)(v40 + 4);
          int v42 = v43;
          if ((v67 & 0x80000000) == 0)
          {
            uint64_t v44 = &v19[5 * v29];
            int v47 = v44[2];
            unint64_t v46 = v44 + 2;
            int v45 = v47;
            if (v42 == 255)
            {
              uint64_t v48 = v66;
              goto LABEL_35;
            }
            unsigned int v51 = &v19[5 * v45];
            int v54 = *((char *)v51 + 16);
            uint64_t v52 = (char *)(v51 + 4);
            int v53 = v54;
            *unint64_t v46 = *((_DWORD *)v52 - 1);
            *uint64_t v66 = *((_DWORD *)v52 - 2);
            *((_DWORD *)v52 - 2) = v9;
            *((_DWORD *)v52 - 1) = v29;
            if (v54 != 1)
            {
              if (v53)
              {
                if (v53 == -1)
                {
                  char v55 = 1;
                  goto LABEL_44;
                }
LABEL_51:
                *uint64_t v52 = 0;
                if (v11)
                {
                  uint64_t v60 = &v19[5 * v11];
                  int v62 = v60[2];
                  unsigned int v61 = v60 + 2;
                  if (v9 == v62 || (v63 = &v19[5 * v11], v64 = v63[3], unsigned int v61 = v63 + 3, v9 == v64))
                  {
                    uint64_t result = 0;
                    *unsigned int v61 = v45;
                  }
                  else
                  {
                    return 0;
                  }
                }
                else
                {
                  uint64_t result = 0;
                  *(_DWORD *)(v68 + 8) = v45;
                }
                return result;
              }
LABEL_45:
              *uint64_t v41 = 0;
              goto LABEL_49;
            }
            char v59 = -1;
LABEL_48:
            *uint64_t v41 = v59;
            goto LABEL_49;
          }
          uint64_t v49 = &v19[5 * v29];
          int v50 = v49[3];
          unint64_t v46 = v49 + 3;
          int v45 = v50;
          if (v42 == 1)
          {
            uint64_t v48 = v65;
LABEL_35:
            *uint64_t v48 = v45;
            *unint64_t v46 = v9;
          }
          else
          {
            unsigned int v56 = &v19[5 * v45];
            int v58 = *((char *)v56 + 16);
            uint64_t v52 = (char *)(v56 + 4);
            int v57 = v58;
            *unint64_t v46 = *((_DWORD *)v52 - 2);
            *uint64_t v65 = *((_DWORD *)v52 - 1);
            *((_DWORD *)v52 - 2) = v29;
            *((_DWORD *)v52 - 1) = v9;
            if (v58 == -1)
            {
              char v59 = 1;
              goto LABEL_48;
            }
            if (!v57) {
              goto LABEL_45;
            }
            if (v57 != 1) {
              goto LABEL_51;
            }
            char v55 = -1;
LABEL_44:
            *unsigned int v36 = v55;
            unsigned int v36 = v41;
LABEL_49:
            uint64_t v41 = v52;
            int v29 = v45;
          }
          *unsigned int v36 = 0;
          uint64_t v52 = v41;
          int v45 = v29;
          goto LABEL_51;
        }
      }
      unsigned int v39 = &v19[5 * v15];
      v19[5 * v69 + 2] = *v19;
      *uint64_t v19 = v69;
      uint64_t result = *v17;
      *int v17 = v70;
      if (*v39 == -1) {
        *unsigned int v39 = v70;
      }
    }
    else
    {
      uint64_t result = 0;
      *(_DWORD *)(v8 + 8) = v7;
    }
  }
  return result;
}

uint64_t BINTREE_Remove(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  unsigned int __src = *(_DWORD *)(a1 + 8);
  uint64_t v8 = __src;
  int v93 = 0;
  uint64_t v91 = 0;
  long long v89 = 0u;
  long long v90 = 0u;
  ARRAY_Init((uint64_t)&v89, *(void *)(a1 + 16), 4, 64);
  if (!v8) {
    goto LABEL_19;
  }
  uint64_t v9 = a1 + 4;
  int v10 = (*(uint64_t (**)(uint64_t, uint64_t, void))(a2 + 8))(a2, a3, *(unsigned int *)(a1 + 4 + 20 * v8 + 4));
  if (v10)
  {
    int v11 = v10;
    while (ARRAY_Add((unsigned int *)&v89, &__src) != -1)
    {
      uint64_t v12 = v9 + 20 * v8;
      int v13 = (unsigned int *)(v12 + 12);
      int v14 = (unsigned int *)(v12 + 8);
      if (v11 >= 0) {
        int v15 = v13;
      }
      else {
        int v15 = v14;
      }
      uint64_t v8 = *v15;
      unsigned int __src = v8;
      if (!v8) {
        goto LABEL_19;
      }
      int v11 = (*(uint64_t (**)(uint64_t, uint64_t, void))(a2 + 8))(a2, a3, *(unsigned int *)(v9 + 20 * v8 + 4));
      if (!v11) {
        goto LABEL_12;
      }
    }
    return err_GenerateErrorResource();
  }
  int v15 = (unsigned int *)&v93;
LABEL_12:
  unsigned int v16 = __src;
  if (!__src)
  {
LABEL_19:
    ARRAY_Flush((uint64_t)&v89);
    uint64_t result = 0;
    *a4 = 0;
    return result;
  }
  uint64_t v17 = *(unsigned int *)(v9 + 20 * v8 + 12);
  if (v17)
  {
    uint64_t v18 = 0;
    uint64_t v19 = *(unsigned int *)(v9 + 20 * v8 + 12);
    do
    {
      uint64_t v20 = v18;
      uint64_t v18 = v19;
      uint64_t v21 = v9 + 20 * v19;
      unsigned int v23 = *(_DWORD *)(v21 + 8);
      uint64_t v22 = (_DWORD *)(v21 + 8);
      uint64_t v19 = v23;
    }
    while (v23);
    *uint64_t v22 = *(_DWORD *)(v9 + 20 * v8 + 8);
    if (v20)
    {
      uint64_t v24 = v9 + 20 * v18;
      *(_DWORD *)(v9 + 20 * v20 + 8) = *(_DWORD *)(v24 + 12);
      *(_DWORD *)(v24 + 12) = v17;
    }
    *int v15 = v18;
    *(unsigned char *)(v9 + 20 * v18 + 16) = *(unsigned char *)(v9 + 20 * v8 + 16);
  }
  else
  {
    int v26 = *(_DWORD *)(v9 + 20 * v8 + 8);
    if (v26)
    {
      uint64_t v27 = 0;
      uint64_t v28 = *(unsigned int *)(v9 + 20 * v8 + 8);
      do
      {
        uint64_t v29 = v27;
        uint64_t v27 = v28;
        uint64_t v30 = v9 + 20 * v28;
        unsigned int v32 = *(_DWORD *)(v30 + 12);
        uint64_t v31 = (_DWORD *)(v30 + 12);
        uint64_t v28 = v32;
      }
      while (v32);
      *uint64_t v31 = 0;
      if (v29)
      {
        uint64_t v33 = v9 + 20 * v27;
        *(_DWORD *)(v9 + 20 * v29 + 12) = *(_DWORD *)(v33 + 8);
        *(_DWORD *)(v33 + 8) = v26;
      }
      *(unsigned char *)(v9 + 20 * v27 + 16) = *(unsigned char *)(v9 + 20 * v8 + 16);
    }
    else
    {
      LODWORD(v27) = 0;
    }
    *int v15 = v27;
  }
  if (v15 == (unsigned int *)&v93)
  {
    int v34 = v93;
    *(_DWORD *)(a1 + 8) = v93;
    if (!v34) {
      goto LABEL_115;
    }
    goto LABEL_32;
  }
  if (*(_DWORD *)(a1 + 8))
  {
LABEL_32:
    unsigned int v35 = *v15;
    unsigned int __src = v35;
    if (v35)
    {
      if (ARRAY_Add((unsigned int *)&v89, &__src) == -1) {
        return err_GenerateErrorResource();
      }
      uint64_t v36 = v9 + 20 * v35;
      if (v17)
      {
        unsigned int __src = *(_DWORD *)(v36 + 12);
        if (__src)
        {
          while (ARRAY_Add((unsigned int *)&v89, &__src) != -1)
          {
            unsigned int __src = *(_DWORD *)(v9 + 20 * __src + 8);
            if (!__src) {
              goto LABEL_42;
            }
          }
          return err_GenerateErrorResource();
        }
      }
      else
      {
        unsigned int __src = *(_DWORD *)(v36 + 8);
        if (__src)
        {
          while (ARRAY_Add((unsigned int *)&v89, &__src) != -1)
          {
            unsigned int __src = *(_DWORD *)(v9 + 20 * __src + 12);
            if (!__src) {
              goto LABEL_42;
            }
          }
          return err_GenerateErrorResource();
        }
      }
    }
LABEL_42:
    uint64_t v37 = *(unsigned int *)(*((void *)&v89 + 1) + (DWORD2(v90) * (v89 - 1)));
    ARRAY_Destroy((uint64_t)&v89, v89 - 1);
    uint64_t v38 = 0;
    uint64_t v39 = v9 + 20 * v37;
    do
    {
      if (v38)
      {
        if (*(_DWORD *)(v39 + 8) == v38) {
          goto LABEL_50;
        }
        if (*(_DWORD *)(v39 + 12) == v38)
        {
LABEL_48:
          char v40 = *(unsigned char *)(v39 + 16) + 1;
LABEL_51:
          *(unsigned char *)(v39 + 16) = v40;
        }
      }
      else
      {
        if (*(_DWORD *)(v39 + 8)) {
          goto LABEL_48;
        }
        if (*(_DWORD *)(v39 + 12))
        {
LABEL_50:
          char v40 = *(unsigned char *)(v39 + 16) - 1;
          goto LABEL_51;
        }
        *(unsigned char *)(v39 + 16) = 0;
      }
      uint64_t v41 = 0;
      if (v89)
      {
        uint64_t v42 = v39;
        if (*((void *)&v89 + 1))
        {
          uint64_t v41 = *(unsigned int *)(*((void *)&v89 + 1) + (DWORD2(v90) * (v89 - 1)));
          ARRAY_Destroy((uint64_t)&v89, v89 - 1);
          uint64_t v42 = v9 + 20 * v41;
        }
      }
      else
      {
        uint64_t v42 = v39;
      }
      uint64_t v44 = (unsigned char *)(v39 + 16);
      int v43 = *(unsigned __int8 *)(v39 + 16);
      if (!*(unsigned char *)(v39 + 16))
      {
        BOOL v61 = 1;
        goto LABEL_78;
      }
      if (v43 != 2)
      {
        if (v43 != 254)
        {
          BOOL v61 = 0;
LABEL_78:
          uint64_t v38 = v37;
          if (!v41) {
            goto LABEL_114;
          }
          goto LABEL_108;
        }
        int v45 = 0;
        if (v37)
        {
          uint64_t v46 = v37;
          do
          {
            ++v45;
            uint64_t v47 = v9 + 20 * v46;
            int v48 = *(char *)(v47 + 16);
            uint64_t v49 = (unsigned int *)(v47 + 12);
            int v50 = (unsigned int *)(v47 + 8);
            if (v48 < 0) {
              int v50 = v49;
            }
            uint64_t v46 = *v50;
          }
          while (v46);
        }
        uint64_t v51 = *(unsigned int *)(v39 + 12);
        uint64_t v52 = v9 + 20 * v51;
        int v55 = *(unsigned __int8 *)(v52 + 16);
        int v53 = (unsigned char *)(v52 + 16);
        char v54 = v55;
        unsigned int v56 = v53 - 8;
        uint64_t v38 = *((unsigned int *)v53 - 2);
        if (v55 == 1)
        {
          uint64_t v57 = v9 + 20 * v38;
          int v60 = *(char *)(v57 + 16);
          int v58 = (unsigned char *)(v57 + 16);
          int v59 = v60;
          *unsigned int v56 = *((_DWORD *)v58 - 1);
          *(_DWORD *)(v39 + 12) = *((_DWORD *)v58 - 2);
          *((_DWORD *)v58 - 2) = v37;
          *((_DWORD *)v58 - 1) = v51;
          if (v60 == 1)
          {
            *int v53 = -1;
          }
          else
          {
            if (v59)
            {
              if (v59 == -1)
              {
                *uint64_t v44 = 1;
                goto LABEL_89;
              }
              goto LABEL_90;
            }
            *int v53 = 0;
          }
          int v53 = (unsigned char *)(v39 + 16);
LABEL_89:
          *int v53 = 0;
LABEL_90:
          *int v58 = 0;
        }
        else
        {
          *(_DWORD *)(v39 + 12) = v38;
          *unsigned int v56 = v37;
          *(unsigned char *)(v39 + 16) = ~v54;
          ++*v53;
          uint64_t v38 = v51;
        }
        int v77 = 0;
        if (v38)
        {
          uint64_t v78 = v38;
          do
          {
            ++v77;
            uint64_t v79 = v9 + 20 * v78;
            int v80 = *(char *)(v79 + 16);
            unsigned int v81 = (unsigned int *)(v79 + 12);
            int v82 = (unsigned int *)(v79 + 8);
            if (v80 < 0) {
              int v82 = v81;
            }
            uint64_t v78 = *v82;
          }
          while (v78);
        }
        goto LABEL_107;
      }
      int v45 = 0;
      if (v37)
      {
        uint64_t v62 = v37;
        do
        {
          ++v45;
          uint64_t v63 = v9 + 20 * v62;
          int v64 = *(char *)(v63 + 16);
          uint64_t v65 = (unsigned int *)(v63 + 12);
          uint64_t v66 = (unsigned int *)(v63 + 8);
          if (v64 < 0) {
            uint64_t v66 = v65;
          }
          uint64_t v62 = *v66;
        }
        while (v62);
      }
      uint64_t v67 = *(unsigned int *)(v39 + 8);
      uint64_t v68 = v9 + 20 * v67;
      int v71 = *(unsigned __int8 *)(v68 + 16);
      int v69 = (unsigned char *)(v68 + 16);
      char v70 = v71;
      int v72 = v69 - 4;
      uint64_t v38 = *((unsigned int *)v69 - 1);
      if (v71 != 255)
      {
        *(_DWORD *)(v39 + 8) = v38;
        *int v72 = v37;
        *(unsigned char *)(v39 + 16) = 1 - v70;
        --*v69;
        uint64_t v38 = v67;
        goto LABEL_102;
      }
      uint64_t v73 = v9 + 20 * v38;
      int v76 = *(char *)(v73 + 16);
      int v74 = (unsigned char *)(v73 + 16);
      int v75 = v76;
      *int v72 = *((_DWORD *)v74 - 2);
      *(_DWORD *)(v39 + 8) = *((_DWORD *)v74 - 1);
      *((_DWORD *)v74 - 2) = v67;
      *((_DWORD *)v74 - 1) = v37;
      if (v76 == -1)
      {
        *int v69 = 1;
        goto LABEL_99;
      }
      if (!v75)
      {
        *int v69 = 0;
LABEL_99:
        int v69 = (unsigned char *)(v39 + 16);
LABEL_100:
        *int v69 = 0;
        goto LABEL_101;
      }
      if (v75 == 1)
      {
        *uint64_t v44 = -1;
        goto LABEL_100;
      }
LABEL_101:
      *int v74 = 0;
LABEL_102:
      int v77 = 0;
      if (v38)
      {
        uint64_t v83 = v38;
        do
        {
          ++v77;
          uint64_t v84 = v9 + 20 * v83;
          int v85 = *(char *)(v84 + 16);
          uint64_t v86 = (unsigned int *)(v84 + 12);
          uint64_t v87 = (unsigned int *)(v84 + 8);
          if (v85 < 0) {
            uint64_t v87 = v86;
          }
          uint64_t v83 = *v87;
        }
        while (v83);
      }
LABEL_107:
      BOOL v61 = v45 != v77;
      if (!v41)
      {
LABEL_114:
        *(_DWORD *)(a1 + 8) = v38;
        break;
      }
LABEL_108:
      uint64_t v88 = (_DWORD *)(v42 + 8);
      if (v37 == *(_DWORD *)(v42 + 8) || (uint64_t v88 = (_DWORD *)(v42 + 12), v37 == *(_DWORD *)(v42 + 12))) {
        *uint64_t v88 = v38;
      }
      uint64_t v39 = v42;
      uint64_t v37 = v41;
    }
    while (v61);
  }
LABEL_115:
  ARRAY_Flush((uint64_t)&v89);
  uint64_t result = 0;
  *a4 = v16;
  return result;
}

uint64_t BINTREE_Level(uint64_t result, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = result;
  LODWORD(result) = 0;
  uint64_t v3 = v2 + 4;
  uint64_t v4 = a2;
  do
  {
    uint64_t result = (result + 1);
    uint64_t v5 = v3 + 20 * v4;
    int v6 = *(char *)(v5 + 16);
    int v7 = (unsigned int *)(v5 + 12);
    uint64_t v8 = (unsigned int *)(v5 + 8);
    if (v6 < 0) {
      uint64_t v8 = v7;
    }
    uint64_t v4 = *v8;
  }
  while (v4);
  return result;
}

uint64_t BINTREE_DeleteSubTree(uint64_t result, unsigned int a2)
{
  uint64_t v3 = result;
  uint64_t v4 = (unsigned int *)(result + 4);
  uint64_t v6 = result + 4 + 20 * a2;
  int v8 = *(_DWORD *)(v6 + 8);
  int v7 = (unsigned int *)(v6 + 8);
  if (v8) {
    uint64_t result = BINTREE_DeleteSubTree(result);
  }
  if (v4[5 * a2 + 3]) {
    uint64_t result = BINTREE_DeleteSubTree(v3);
  }
  *int v7 = *v4;
  *uint64_t v4 = a2;
  return result;
}

uint64_t BINTREE_Find(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (!v3) {
    return 0;
  }
  uint64_t v6 = a1 + 4;
  while (1)
  {
    int v7 = (unsigned int *)(v6 + 20 * v3);
    int v8 = (*(uint64_t (**)(uint64_t, uint64_t, void))(a2 + 8))(a2, a3, *v7);
    if (!v8) {
      break;
    }
    uint64_t v9 = v6 + 20 * v3;
    int v10 = (unsigned int *)(v9 + 8);
    int v11 = (unsigned int *)(v9 + 12);
    if (v8 < 0) {
      int v11 = v10;
    }
    uint64_t v3 = *v11;
    if (!v3) {
      return 0;
    }
  }
  return *v7;
}

uint64_t BINTREE_CheckTree(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 8);
  if (!v1) {
    return 1;
  }
  uint64_t v3 = a1 + 4;
  unsigned int v4 = *(_DWORD *)(a1 + 4 + 20 * v1 + 8);
  uint64_t result = BINTREE_CheckTreeNode(a1, v4);
  if (result)
  {
    unsigned int v6 = *(_DWORD *)(v3 + 20 * v1 + 12);
    uint64_t result = BINTREE_CheckTreeNode(a1, v6);
    if (result)
    {
      int v7 = BINTREE_TrueLevel(a1, v4);
      int v8 = v7 - BINTREE_TrueLevel(a1, v6);
      return v8 == *(char *)(v3 + 20 * v1 + 16) && (v8 + 1) < 3;
    }
  }
  return result;
}

uint64_t BINTREE_CheckTreeNode(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 1;
  }
  uint64_t v4 = a1 + 4;
  unsigned int v5 = *(_DWORD *)(a1 + 4 + 20 * a2 + 8);
  uint64_t result = ((uint64_t (*)(void))BINTREE_CheckTreeNode)();
  if (result)
  {
    unsigned int v7 = a2;
    unsigned int v8 = *(_DWORD *)(v4 + 20 * a2 + 12);
    uint64_t result = BINTREE_CheckTreeNode(a1, v8);
    if (result)
    {
      int v9 = BINTREE_TrueLevel(a1, v5);
      int v10 = v9 - BINTREE_TrueLevel(a1, v8);
      return v10 == *(char *)(v4 + 20 * v7 + 16) && (v10 + 1) < 3;
    }
  }
  return result;
}

uint64_t BINTREE_TrueLevel(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v3 = a1 + 20 * a2;
  int v4 = ((uint64_t (*)(void))BINTREE_TrueLevel)();
  int v5 = BINTREE_TrueLevel(a1, *(unsigned int *)(v3 + 16));
  if (v4 <= v5) {
    int v6 = v5;
  }
  else {
    int v6 = v4;
  }
  return (v6 + 1);
}

uint64_t BINTREE_Flush(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 8);
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t result = BINTREE_DeleteSubTree(result, v1);
    *(_DWORD *)(v2 + 8) = 0;
  }
  return result;
}

uint64_t BINTREE_Destruct(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2)
  {
    BINTREE_DeleteSubTree(a1, v2);
    *(_DWORD *)(a1 + 8) = 0;
  }
  uint64_t v3 = *(void *)(a1 + 16);

  return OOCAllocator_Free(v3, a1);
}

uint64_t BINTREEITT_Inc(unsigned int *a1)
{
  uint64_t v3 = a1 + 4;
  unsigned int v2 = a1[4];
  if (v2)
  {
    uint64_t v4 = *((void *)a1 + 1) + 4;
    *a1 = *(_DWORD *)(*((void *)a1 + 3) + a1[10] * (v2 - 1));
    ARRAY_Destroy((uint64_t)(a1 + 4), v2 - 1);
    unsigned int __src = *(_DWORD *)(v4 + 20 * *a1 + 12);
    if (__src)
    {
      while (ARRAY_Add(v3, &__src) != -1)
      {
        unsigned int __src = *(_DWORD *)(v4 + 20 * __src + 8);
        if (!__src) {
          return 0;
        }
      }
      return err_GenerateErrorResource();
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t result = 0;
    *a1 = 0;
  }
  return result;
}

uint64_t BINTREEITT_Current(unsigned int *a1)
{
  return *((void *)a1 + 1) + 20 * *a1 + 4;
}

uint64_t BINTREEITT_ReStart(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(_DWORD *)(a1 + 16) = 0;
  uint64_t v3 = (unsigned int *)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(v2 + 8);
  unsigned int __src = v4;
  if (v4)
  {
    uint64_t v5 = v2 + 4;
    while (1)
    {
      uint64_t v6 = v5 + 20 * v4;
      int v8 = *(_DWORD *)(v6 + 8);
      unsigned int v7 = (unsigned int *)(v6 + 8);
      if (!v8) {
        break;
      }
      if (ARRAY_Add(v3, &__src) == -1) {
        return err_GenerateErrorResource();
      }
      unsigned int v4 = *v7;
      unsigned int __src = *v7;
    }
    *(_DWORD *)a1 = v4;
    unsigned int __src = *(_DWORD *)(v5 + 20 * v4 + 12);
    if (!__src) {
      return 0;
    }
    while (ARRAY_Add(v3, &__src) != -1)
    {
      unsigned int __src = *(_DWORD *)(v5 + 20 * __src + 8);
      if (!__src) {
        return 0;
      }
    }
    return err_GenerateErrorResource();
  }
  else
  {
    uint64_t result = 0;
    *(_DWORD *)a1 = 0;
  }
  return result;
}

uint64_t BINTREEITT_Init(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  ARRAY_Init(a1 + 16, *(void *)(a2 + 16), 4, 64);

  return BINTREEITT_ReStart(a1);
}

void *err_ErrorGetCallback(void *result, void *a2)
{
  *uint64_t result = 0;
  *a2 = 0;
  return result;
}

uint64_t err_GenerateErrorResource()
{
  return 1;
}

uint64_t err_GenerateErrorNotSupported()
{
  return 8;
}

uint64_t err_GenerateErrorInternal()
{
  return 9;
}

uint64_t err_GenerateErrorArg()
{
  return 3;
}

uint64_t err_GenerateErrorArgInterface()
{
  return 3;
}

uint64_t err_GenerateErrorData()
{
  return 4;
}

uint64_t err_GenerateErrorCallback()
{
  return 6;
}

uint64_t err_GenerateErrorLimit()
{
  return 7;
}

uint64_t err_GenerateErrorState()
{
  return 2;
}

uint64_t err_GenerateErrorStateObjName()
{
  return 2;
}

uint64_t err_GenerateErrorStateInUse()
{
  return 2;
}

uint64_t err_GenerateErrorVersion()
{
  return 5;
}

uint64_t err_GenerateErrorVersionString()
{
  return 5;
}

uint64_t err_GenerateErrorInconsistent()
{
  return 10;
}

uint64_t err_GenerateErrorCharacter()
{
  return 3;
}

uint64_t _AbstractComponent_Con(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__AbstractComponent;
    *(void *)(a1 + 8) = &unk_26D2155E0;
    *(_OWORD *)(a1 + 80) = *(_OWORD *)a2;
    *(void *)(a1 + 96) = *(void *)(a2 + 16);
    cstdlib_memcpy((void *)(a1 + 104), (const void *)(a2 + 24), 8uLL);
    *(void *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    long long v13 = a3[1];
    *(_OWORD *)(a1 + 32) = *a3;
    *(_OWORD *)(a1 + 48) = v13;
    *(void *)(a1 + 64) = a4;
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))a3)(a4, 40);
    *(void *)(a1 + 72) = v14;
    if (v14)
    {
      uint64_t result = OOCAllocator_Con(v14, a3, *(void *)(a1 + 64));
      if (result) {
        return result;
      }
      if (a5 | a6)
      {
        *(void *)(a1 + 112) = a5;
        *(void *)(a1 + 120) = a6;
        (*(void (**)(uint64_t))(*(void *)a5 + 40))(a5 - *(void *)(*(void *)a5 + 48));
        (*(void (**)(void))(**(void **)(a1 + 120) + 24))(*(void *)(a1 + 120) - *(void *)(**(void **)(a1 + 120) + 32));
      }
      else
      {
        uint64_t v18 = 0;
        uint64_t result = PNEW_LogDispatcher_Con(*(void *)(a1 + 72), *(void *)(a1 + 72), &v18);
        if (result) {
          return result;
        }
        uint64_t v15 = v18;
        uint64_t v16 = v18 + 24;
        uint64_t v17 = v18 + 32;
        *(void *)(a1 + 112) = v18 + 24;
        *(void *)(a1 + 120) = v17;
        (*(void (**)(uint64_t))(*(void *)(v15 + 24) + 40))(v16 - *(void *)(*(void *)(v15 + 24) + 48));
        (*(void (**)(void))(**(void **)(a1 + 120) + 24))(*(void *)(a1 + 120) - *(void *)(**(void **)(a1 + 120) + 32));
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 32))(v18);
        if (result) {
          return result;
        }
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, const char *, uint64_t))(*(void *)(a1 + 8) + 64))(a1 + 8 - *(void *)(*(void *)(a1 + 8) + 168), "API", a1 + 128);
      if (!result) {
        return PNEW_StreamInfoFactory_Con(*(void *)(a1 + 72), *(void *)(a1 + 72), (void *)(a1 + 136));
      }
      return result;
    }
    return err_GenerateErrorResource();
  }
  return result;
}

uint64_t AbstractComponent_Des(uint64_t a1)
{
  for (uint64_t i = *(void *)(a1 + 24); i; uint64_t i = *(void *)(a1 + 24))
  {
    *(void *)(a1 + 24) = *(void *)(i + 40);
    OOCAllocator_Free(*(void *)(a1 + 72), i);
  }
  if (*(void *)(a1 + 72))
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 72))(*(void *)(a1 + 128) - *(void *)(**(void **)(a1 + 128) + 88));
    if (result) {
      return result;
    }
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 32))(*(void *)(a1 + 112) - *(void *)(**(void **)(a1 + 112) + 48));
    if (result) {
      return result;
    }
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 120) + 16))(*(void *)(a1 + 120) - *(void *)(**(void **)(a1 + 120) + 32));
    if (result) {
      return result;
    }
    uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 72), *(void *)(a1 + 136));
    if (result) {
      return result;
    }
    uint64_t result = OOCAllocator_Des();
    if (result) {
      return result;
    }
    (*(void (**)(void, void))(a1 + 56))(*(void *)(a1 + 64), *(void *)(a1 + 72));
  }

  return Object_Des();
}

uint64_t AbstractComponent_BorrowAllocator(uint64_t a1, void *a2)
{
  *a2 = *(void *)(a1 + 72);
  return 0;
}

uint64_t AbstractComponent_BorrowHeap(uint64_t result, void *a2, void *a3)
{
  *a2 = result + 32;
  *a3 = *(void *)(result + 64);
  return result;
}

uint64_t AbstractComponent_BorrowLogDispatcher(uint64_t a1)
{
  return *(void *)(a1 + 112);
}

uint64_t AbstractComponent_BorrowLogRegister(uint64_t a1)
{
  return *(void *)(a1 + 120);
}

void *AbstractComponent_BorrowVersionInfo(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 80);
  *(void *)(a2 + 16) = *(void *)(a1 + 96);
  return cstdlib_memcpy((void *)(a2 + 24), (const void *)(a1 + 104), 8uLL);
}

uint64_t AbstractComponent_CreateLogger(uint64_t a1, const char *a2, void *a3)
{
  uint64_t v5 = 0;
  uint64_t result = PNEW_Logger_Con(*(void *)(a1 + 72), *(void *)(a1 + 72), a2, *(void *)(a1 + 112), &v5);
  if (!result) {
    *a3 = v5 + 24;
  }
  return result;
}

uint64_t AbstractComponent_CreateStreamInfo(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(*(void *)(a1 + 136) + 8))(*(void *)(a1 + 136) + 8 - *(void *)(*(void *)(*(void *)(a1 + 136) + 8) + 16));
}

uint64_t AbstractComponent_CreateStreamLogger(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, void *a6)
{
  uint64_t v15 = 0;
  uint64_t v11 = a1 + 8;
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 8) + 152))(a1 + 8 - *(void *)(*(void *)(a1 + 8)
                                                                                              + 168));
  uint64_t v14 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v11 + 32))(v11 - *(void *)(*(void *)v11 + 168), &v15);
  if (!result)
  {
    uint64_t result = PNEW_StreamLogger_Con(v15, v15, v12, a2, a3, a4, a5, &v14);
    if (!result) {
      *a6 = v14 + 56;
    }
  }
  return result;
}

uint64_t AbstractComponent_CreateTimeLogger(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  uint64_t v9 = 0;
  uint64_t result = PNEW_NullLog_Con(*(void *)(a1 + 72), &v9);
  if (!result) {
    *a7 = v9 + 56;
  }
  return result;
}

uint64_t AbstractComponent_FindStream(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *a3 = 0;
  if (v3)
  {
    while (*(void *)(v3 + 24) != a2 || *(_DWORD *)(v3 + 32))
    {
      uint64_t v3 = *(void *)(v3 + 40);
      if (!v3) {
        return 0;
      }
    }
    *a3 = *(void *)(v3 + 16);
  }
  return 0;
}

uint64_t AbstractComponent_GetLogger(uint64_t a1)
{
  return *(void *)(a1 + 128);
}

uint64_t AbstractComponent_HasStreamInfoType(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(a1 + 136) + 8) + 8))(*(void *)(a1 + 136)
                                                                                             + 8 - *(void *)(*(void *)(*(void *)(a1 + 136) + 8) + 16));
}

uint64_t AbstractComponent_QueryInterface(uint64_t a1, uint64_t a2, void *a3)
{
  *a3 = 0;
  return 0;
}

uint64_t AbstractComponent_RegisterTerminator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  unsigned int v20 = 0;
  uint64_t v12 = *(void *)(a1 + 24);
  if (v12)
  {
    int v13 = *(_DWORD *)(v12 + 32);
    if (v13)
    {
      int v14 = 0;
      uint64_t v15 = *(void *)(a1 + 24);
LABEL_8:
      if (v13 == 1)
      {
        uint64_t result = 0;
        *(_DWORD *)(v15 + 32) = 0;
        *(void *)uint64_t v15 = a2;
        *(void *)(v15 + 8) = a3;
        *(void *)(v15 + 16) = a4;
        *(void *)(v15 + 24) = a5;
        *a6 = v14;
        return result;
      }
    }
    else
    {
      int v14 = 0;
      uint64_t v16 = *(void *)(a1 + 24);
      while (1)
      {
        uint64_t v15 = *(void *)(v16 + 40);
        if (!v15) {
          break;
        }
        ++v14;
        int v13 = *(_DWORD *)(v15 + 32);
        uint64_t v16 = *(void *)(v16 + 40);
        if (v13) {
          goto LABEL_8;
        }
      }
      uint64_t v15 = v16;
    }
  }
  else
  {
    uint64_t v15 = 0;
    int v14 = 0;
  }
  uint64_t v18 = OOCAllocator_Malloc(*(void *)(a1 + 72), 48, &v20);
  uint64_t result = v20;
  if (!v20)
  {
    *(_DWORD *)(v18 + 32) = 0;
    *(void *)uint64_t v18 = a2;
    *(void *)(v18 + 8) = a3;
    *(void *)(v18 + 16) = a4;
    *(void *)(v18 + 24) = a5;
    *(void *)(v18 + 40) = 0;
    if (v12)
    {
      *(void *)(v15 + 40) = v18;
      int v19 = v14 + 1;
    }
    else
    {
      int v19 = 0;
      *(void *)(a1 + 24) = v18;
    }
    uint64_t result = 0;
    *a6 = v19;
    ++*(_DWORD *)(a1 + 16);
  }
  return result;
}

uint64_t AbstractComponent_Terminate(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (!v1) {
    return 0;
  }
  int v2 = 0;
  do
  {
    if (!*(_DWORD *)(v1 + 32))
    {
      int v3 = *(void *)v1
         ? (*(uint64_t (**)(void))v1)(*(void *)(v1 + 16))
         : (*(unint64_t (**)(void, uint64_t))(v1 + 8))(*(void *)(v1 + 16), 1);
      if (!v2) {
        int v2 = v3;
      }
    }
    uint64_t v1 = *(void *)(v1 + 40);
  }
  while (v1);
  if (!v2) {
    return 0;
  }

  return err_GenerateErrorCallback();
}

uint64_t AbstractComponent_UnregisterTerminator(uint64_t a1, int a2)
{
  for (uint64_t i = *(void *)(a1 + 24); a2; --a2)
    uint64_t i = *(void *)(i + 40);
  *(_DWORD *)(i + 32) = 1;
  return 0;
}

uint64_t _AbstractComponent_BorrowFreeCallbackFn(uint64_t result, void *a2, void *a3)
{
  *a2 = *(void *)(result + 56);
  *a3 = *(void *)(result + 64);
  return result;
}

void *GetAbstractComponentClass()
{
  return &__AbstractComponent;
}

uint64_t VoConObject_Con(void *a1)
{
  uint64_t result = RefCounted_Con((uint64_t)a1, 1);
  if (!result)
  {
    *a1 = &__VoConObject;
    a1[3] = &unk_26D2156C0;
    a1[4] = 0;
    a1[5] = 0;
    a1[6] = 0;
  }
  return result;
}

uint64_t VoConObject_Con2(void *a1, uint64_t a2)
{
  uint64_t result = RefCounted_Con((uint64_t)a1, 1);
  if (!result)
  {
    uint64_t v5 = 0;
    *a1 = &__VoConObject;
    a1[6] = a2;
    a1[3] = &unk_26D2156C0;
    a1[4] = 0;
    uint64_t result = PNEW_NullLogger_Con(a2, &v5);
    if (!result) {
      a1[5] = v5 + 24;
    }
  }
  return result;
}

uint64_t VoConObject_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2
    || (uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 72))(v2 - *(void *)(*(void *)v2 + 88)),
        !result))
  {
    return RefCounted_Des(a1);
  }
  return result;
}

uint64_t VoConObject_GetLogger(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (!v1) {
    return 0;
  }
  (*(void (**)(uint64_t))(*(void *)v1 + 80))(v1 - *(void *)(*(void *)v1 + 88));
  return *(void *)(a1 + 40);
}

uint64_t VoConObject_GetUserData(uint64_t a1, void *a2)
{
  *a2 = *(void *)(a1 + 32);
  return 0;
}

BOOL VoConObject_IsClosable(uint64_t a1)
{
  return (*(unsigned int (**)(uint64_t))(*(void *)a1 + 40))(a1) < 2;
}

uint64_t VoConObject_QueryInterface(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 24;
  if (a2 != 256370412) {
    uint64_t v3 = 0;
  }
  *a3 = v3;
  return 0;
}

uint64_t VoConObject_SetLogger(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  if (!v4
    || (uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 72))(v4 - *(void *)(*(void *)v4 + 88)),
        !result))
  {
    (*(void (**)(uint64_t))(*(void *)a2 + 80))(a2 - *(void *)(*(void *)a2 + 88));
    uint64_t result = 0;
    *(void *)(a1 + 40) = a2;
  }
  return result;
}

uint64_t VoConObject_SetUserData(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = a2;
  return 0;
}

uint64_t PNEW_VoConObject_Con(uint64_t a1, void *a2)
{
  unsigned int v6 = 0;
  uint64_t v4 = (void *)OOCAllocator_Malloc(a1, 56, &v6);
  uint64_t result = v6;
  if (!v6)
  {
    uint64_t result = RefCounted_Con((uint64_t)v4, 1);
    if (result)
    {
      unsigned int v6 = result;
      OOCAllocator_Free(a1, (uint64_t)v4);
      *a2 = 0;
      return v6;
    }
    else
    {
      *uint64_t v4 = &__VoConObject;
      v4[5] = 0;
      v4[6] = 0;
      v4[3] = &unk_26D2156C0;
      v4[4] = 0;
      v4[2] = a1;
      *a2 = v4;
    }
  }
  return result;
}

uint64_t PNEW_VoConObject_Con2(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  unsigned int v6 = (void *)OOCAllocator_Malloc(a1, 56, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = VoConObject_Con2(v6, a2);
    unsigned int v8 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      v6[2] = a1;
      *a3 = v6;
    }
  }
  return result;
}

void *GetVoConObjectClass()
{
  return &__VoConObject;
}

uint64_t BaseStreamInfoFactory_Con(void *a1, uint64_t a2)
{
  uint64_t result = StreamInfoFactory_Con(a1, a2);
  if (!result)
  {
    *a1 = &__BaseStreamInfoFactory;
    a1[1] = &unk_26D215720;
  }
  return result;
}

uint64_t BaseStreamInfoFactory_Create(uint64_t a1, uint64_t a2, void *a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 192))(a2 - *(void *)(*(void *)a2 + 224))
    && (*(unsigned int (**)(uint64_t))(*(void *)a2 + 56))(a2 - *(void *)(*(void *)a2 + 224)) == 638215866)
  {
    uint64_t v7 = 0;
    uint64_t result = PNEW_StringPoolStreamInfo_Con(*(void *)(a1 + 16), *(void *)(a1 + 16), a2, &v7);
    if (result) {
      return result;
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t result = PNEW_StreamInfo_Con(*(void *)(a1 + 16), *(void *)(a1 + 16), a2, &v7);
    if (result) {
      return result;
    }
  }
  *a3 = v7 + 56;
  return result;
}

BOOL BaseStreamInfoFactory_Has(uint64_t a1, uint64_t a2)
{
  return a2 == 638215866;
}

uint64_t PNEW_BaseStreamInfoFactory_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  unsigned int v6 = (void *)OOCAllocator_Malloc(a1, 24, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = StreamInfoFactory_Con(v6, a2);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *unsigned int v6 = &__BaseStreamInfoFactory;
      v6[1] = &unk_26D215720;
      *a3 = v6;
    }
  }
  return result;
}

void *GetBaseStreamInfoFactoryClass()
{
  return &__BaseStreamInfoFactory;
}

uint64_t _Component_Con(void *a1, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return _Component_ConSharedLog(a1, a2, a3, a4, a5, a6, 0, 0);
}

uint64_t _Component_ConSharedLog(void *a1, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = _AbstractComponent_Con((uint64_t)a1, a6, a3, a4, a7, a8);
  if (!result)
  {
    *a1 = &__Component;
    a1[1] = &unk_26D215750;
    a1[18] = a5;
    a1[19] = a2;
    a1[20] = 0;
    uint64_t v12 = *(uint64_t (**)(uint64_t, void *))(*(void *)a2 + 8);
    uint64_t v13 = a2 - *(void *)(*(void *)a2 + 168);
    return v12(v13, a1 + 1);
  }
  return result;
}

uint64_t Component_Des(uint64_t a1)
{
  if (!*(void *)(a1 + 160)
    || (uint64_t v3 = 0,
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)(a1 + 8) + 32))(a1 + 8 - *(void *)(*(void *)(a1 + 8) + 168), &v3), !result)&& (uint64_t result = OOC_PlacementDeleteObject(v3, *(void *)(a1 + 160)), !result))
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 152) + 24))(*(void *)(a1 + 152) - *(void *)(**(void **)(a1 + 152) + 168), a1 + 8);
    if (!result) {
      return AbstractComponent_Des(a1);
    }
  }
  return result;
}

uint64_t Component_GetType(uint64_t a1)
{
  return *(void *)(a1 + 144);
}

uint64_t Component_Init(uint64_t a1, uint64_t (**a2)(uint64_t, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t result = _Component_CheckHeapCallBacks(a2);
  if (!result)
  {
    uint64_t v13 = (void *)(*a2)(a3, 168);
    if (v13)
    {
      int v14 = v13;
      uint64_t result = _Component_ConSharedLog(v13, a1, a2, a3, a4, a5, 0, 0);
      if (!result) {
        *a6 = v14 + 1;
      }
    }
    else
    {
      return err_GenerateErrorResource();
    }
  }
  return result;
}

uint64_t _Component_CheckHeapCallBacks(void *a1)
{
  if (a1 && *a1 && a1[1] && a1[2] && a1[3]) {
    return 0;
  }
  else {
    return err_GenerateErrorArg();
  }
}

uint64_t Component_NotifyInError(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 160);
  if (result)
  {
    uint64_t result = PtrList_NrItems(result);
    if (result)
    {
      unint64_t v3 = 0;
      do
      {
        uint64_t v4 = PtrList_ItemN(*(void *)(a1 + 160), v3);
        (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 + 8) + 128))(a1 + 8 - *(void *)(*(void *)(a1 + 8) + 168), v4);
        ++v3;
        uint64_t result = PtrList_NrItems(*(void *)(a1 + 160));
      }
      while (v3 < result);
    }
  }
  return result;
}

uint64_t Component_QueryInterface(uint64_t a1, uint64_t a2, void *a3)
{
  if (*(void *)(a1 + 144) != a2) {
    return AbstractComponent_QueryInterface(a1, a2, a3);
  }
  *a3 = a1 + 8;
  return 0;
}

uint64_t Component_RegisterComponent(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 152) + 8))(*(void *)(a1 + 152) - *(void *)(**(void **)(a1 + 152) + 168));
  if (!result)
  {
    uint64_t v5 = *(void *)(a1 + 160);
    if (v5) {
      return PtrList_Append(v5, a2);
    }
    uint64_t v6 = 0;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)(a1 + 8) + 32))(a1 + 8 - *(void *)(*(void *)(a1 + 8) + 168), &v6);
    if (!result)
    {
      uint64_t result = PNEW_PtrList_Con(v6, v6, 2u, 2, (uint64_t *)(a1 + 160));
      if (!result)
      {
        uint64_t v5 = *(void *)(a1 + 160);
        return PtrList_Append(v5, a2);
      }
    }
  }
  return result;
}

uint64_t Component_SetComponentInErrorState(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 152) + 128))(*(void *)(a1 + 152) - *(void *)(**(void **)(a1 + 152) + 168));
}

uint64_t Component_Terminate(void *a1)
{
  uint64_t v2 = a1[20];
  if (v2 && PtrList_NrItems(v2))
  {
    return err_GenerateErrorStateInUse();
  }
  else
  {
    uint64_t result = AbstractComponent_Terminate((uint64_t)a1);
    if (!result)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 0;
      _AbstractComponent_BorrowFreeCallbackFn((uint64_t)a1, &v5, &v4);
      uint64_t result = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
      if (!result)
      {
        v5(v4, a1);
        return 0;
      }
    }
  }
  return result;
}

uint64_t Component_UnregisterComponent(uint64_t a1, uint64_t a2)
{
  PtrList_Remove(*(void *)(a1 + 160), a2);
  uint64_t v4 = *(void *)(a1 + 152);
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 24);
  uint64_t v6 = v4 - *(void *)(*(void *)v4 + 168);

  return v5(v6, a2);
}

void *GetComponentClass()
{
  return &__Component;
}

uint64_t VoConGlobals_HasFreeVariables()
{
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  voc_BorrowGlobalVarPtr(&v4, &v5);
  uint64_t v0 = v5;
  if (!v5) {
    return 0;
  }
  uint64_t v1 = v4;
  while (1)
  {
    int v2 = *v1;
    v1 += 4;
    if (!v2) {
      break;
    }
    if (!--v0) {
      return 0;
    }
  }
  return 1;
}

void *VoConGlobals_Reset()
{
  uint64_t v1 = 0;
  uint64_t v2 = 0;
  voc_BorrowGlobalVarPtr(&v1, &v2);
  return cstdlib_memset(v1, 0, 16 * v2);
}

uint64_t VoConGlobals_HasVariable(int a1)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  voc_BorrowGlobalVarPtr(&v6, &v7);
  uint64_t v2 = v7;
  if (!v7) {
    return 0;
  }
  unint64_t v3 = v6;
  while (1)
  {
    int v4 = *v3;
    v3 += 4;
    if (v4 == a1) {
      break;
    }
    if (!--v2) {
      return 0;
    }
  }
  return 1;
}

uint64_t VoConGlobals_SetVariable(int a1, uint64_t a2)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  voc_BorrowGlobalVarPtr(&v8, &v9);
  uint64_t result = VoConGlobals_HasVariable(a1);
  if (result) {
    int v5 = a1;
  }
  else {
    int v5 = 0;
  }
  uint64_t v6 = v9;
  if (v9)
  {
    for (uint64_t i = 0; *(_DWORD *)(v8 + i) != v5; i += 16)
    {
      if (!--v6) {
        return result;
      }
    }
    *(void *)(v8 + i + 8) = a2;
    *(_DWORD *)(v8 + i) = a1;
  }
  return result;
}

void *VoConGlobals_RemoveVariable(int a1)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  uint64_t result = voc_BorrowGlobalVarPtr(&v5, &v6);
  uint64_t v3 = v6;
  if (v6)
  {
    for (uint64_t i = 0; *(_DWORD *)(v5 + i) != a1; i += 16)
    {
      if (!--v3) {
        return result;
      }
    }
    *(void *)(v5 + i + 8) = 0;
    *(_DWORD *)(v5 + i) = 0;
  }
  return result;
}

uint64_t VoConGlobals_GetVariable(int a1)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  voc_BorrowGlobalVarPtr(&v5, &v6);
  uint64_t v2 = v6;
  if (!v6) {
    return 0;
  }
  for (uint64_t i = v5 + 8; *(_DWORD *)(i - 8) != a1; i += 16)
  {
    if (!--v2) {
      return 0;
    }
  }
  return *(void *)i;
}

uint64_t _BaseComponent_Con(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4)
{
  uint64_t result = _AbstractComponent_Con(a1, a2, a3, a4, 0, 0);
  if (!result)
  {
    *(void *)a1 = &__BaseComponent;
    *(void *)(a1 + 8) = &unk_26D215818;
    *(_DWORD *)(a1 + 144) = 0;
    uint64_t result = BaseComponent_RegisterComponent(a1, a1 + 8);
    if (!result)
    {
      uint64_t v6 = 0;
      *(void *)(a1 + 152) = 0;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)(a1 + 8) + 32))(a1 + 8 - *(void *)(*(void *)(a1 + 8) + 168), &v6);
      if (!result) {
        return FSTRegisterBaseFormats(v6, a1);
      }
    }
  }
  return result;
}

uint64_t BaseComponent_RegisterComponent(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = 0;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2 - *(void *)(*(void *)a2 + 168));
  ++*(_DWORD *)(a1 + 144);
  uint64_t result = __BaseComponent_BorrowComponentInfo(v4, &v15);
  if (!result)
  {
    BOOL IsComponentRegistered = BaseComponent_IsComponentRegistered(a2);
    uint64_t v7 = v15;
    if (IsComponentRegistered)
    {
      *(_WORD *)(v15 + 18) = 2;
      return err_GenerateErrorState();
    }
    else
    {
      *(void *)(v15 + 8) = v4;
      uint64_t Variable = VoConGlobals_GetVariable(328991267);
      int v9 = 0;
      uint64_t v10 = Variable + 23;
      do
      {
        __int16 v11 = ++Variable;
        if ((_WORD)Variable) {
          BOOL v12 = (unsigned __int16)Variable == 22725;
        }
        else {
          BOOL v12 = 1;
        }
        if (!v12)
        {
          uint64_t v13 = VoConGlobals_GetVariable(329621357);
          uint64_t v14 = 16;
          while (*(unsigned __int16 *)(v13 + v14) != (unsigned __int16)Variable)
          {
            v14 += 24;
            if (v14 == 496)
            {
              uint64_t v10 = Variable;
              goto LABEL_17;
            }
          }
        }
        ++v9;
      }
      while (v9 != 23);
      __int16 v11 = v10;
LABEL_17:
      VoConGlobals_SetVariable(328991267, v10);
      uint64_t result = 0;
      *(_WORD *)(v7 + 16) = v11;
      *(_WORD *)(v7 + 18) = 1;
      *(void *)uint64_t v7 = a2;
    }
  }
  return result;
}

uint64_t BaseComponent_Terminate(uint64_t a1)
{
  uint64_t v8 = 0;
  int v9 = 0;
  uint64_t v7 = 0;
  uint64_t ErrorState = FSTFormatRegistry_DeleteInstance(a1);
  if (ErrorState) {
    goto LABEL_3;
  }
  _AbstractComponent_BorrowFreeCallbackFn(a1, &v9, &v8);
  uint64_t ErrorState = AbstractComponent_Terminate(a1);
  if (ErrorState) {
    goto LABEL_3;
  }
  if (*(int *)(a1 + 144) > 1)
  {
    uint64_t ErrorState = err_GenerateErrorState();
    if (!ErrorState) {
      return ErrorState;
    }
    goto LABEL_3;
  }
  if ((uint64_t ErrorState = BaseComponent_UnregisterComponent(a1, a1 + 8), ErrorState)
    || (*(_DWORD *)(a1 + 144) = 0, *(void *)(a1 + 152))
    && ((uint64_t ErrorState = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)(a1 + 8) + 32))(a1 + 8 - *(void *)(*(void *)(a1 + 8) + 168), &v7), ErrorState)|| (uint64_t ErrorState = OOC_PlacementDeleteObject(v7, *(void *)(a1 + 152)), ErrorState))|| (uint64_t ErrorState = AbstractComponent_Des(a1), ErrorState))
  {
LABEL_3:
    ComponentInstanceint Id = BaseComponent_GetComponentInstanceId(268501877);
    BaseComponent_SetComponentInstanceInErrorState(ComponentInstanceId);
    return ErrorState;
  }
  if (VoConGlobals_HasVariable(303070103))
  {
    uint64_t Variable = VoConGlobals_GetVariable(303070103);
    v9(v8, Variable);
    VoConGlobals_RemoveVariable(303070103);
  }
  if (VoConGlobals_HasVariable(329621357))
  {
    uint64_t v6 = VoConGlobals_GetVariable(329621357);
    v9(v8, v6);
    VoConGlobals_RemoveVariable(329621357);
  }
  err_ErrorSetCallback(0, 0);
  return 0;
}

uint64_t BaseComponent_BorrowComponent(int a1, void *a2)
{
  uint64_t v5 = 0;
  int ComponentInfoByMagicNbr = __BaseComponent_GetComponentInfoByMagicNbr(a1, &v5);
  if (!ComponentInfoByMagicNbr)
  {
    *a2 = *v5;
    return 0;
  }
  if (ComponentInfoByMagicNbr != 1) {
    return 0;
  }

  return err_GenerateErrorInternal();
}

uint64_t __BaseComponent_GetComponentInfoByMagicNbr(int a1, void *a2)
{
  if (!VoConGlobals_HasVariable(329621357) || !BaseComponent_IsComponentInstanceAlive(a1)) {
    return 1;
  }
  uint64_t Variable = VoConGlobals_GetVariable(329621357);
  uint64_t v5 = 0;
  while (1)
  {
    uint64_t v6 = Variable + v5;
    if (*(unsigned __int16 *)(Variable + v5 + 16) == a1) {
      break;
    }
    v5 += 24;
    if (v5 == 480) {
      return 2;
    }
  }
  uint64_t result = 0;
  *a2 = v6;
  return result;
}

uint64_t BaseComponent_CreateStreamInfo(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(*(void *)(a1 + 152) + 8))(*(void *)(a1 + 152) + 8 - *(void *)(*(void *)(*(void *)(a1 + 152) + 8) + 16));
}

uint64_t BaseComponent_FindStreamInAllComponents(uint64_t a1, void *a2)
{
  uint64_t v9 = 0;
  if (!VoConGlobals_HasVariable(329621357))
  {
    return err_GenerateErrorInternal();
  }
  uint64_t Variable = (_WORD *)VoConGlobals_GetVariable(329621357);
  unint64_t v5 = 0;
  while (Variable[9])
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t *))(**(void **)Variable + 80))(*(void *)Variable - *(void *)(**(void **)Variable + 168), a1, &v9);
    if (result) {
      return result;
    }
    uint64_t v7 = v9;
    if (v9) {
      BOOL v8 = 1;
    }
    else {
      BOOL v8 = v5 >= 0x13;
    }
    if (v8) {
      goto LABEL_17;
    }
LABEL_12:
    ++v5;
    Variable += 12;
  }
  if (v5 <= 0x12) {
    goto LABEL_12;
  }
  uint64_t v7 = 0;
LABEL_17:
  uint64_t result = 0;
  *a2 = v7;
  return result;
}

uint64_t BaseComponent_GetComponentInstanceId(uint64_t a1)
{
  uint64_t v3 = 0;
  if (__BaseComponent_BorrowComponentInfo(a1, &v3) || *(void *)(v3 + 8) != a1) {
    return 0;
  }
  else {
    return *(unsigned __int16 *)(v3 + 16);
  }
}

uint64_t __BaseComponent_BorrowComponentInfo(uint64_t a1, void *a2)
{
  if (VoConGlobals_HasVariable(329621357))
  {
    uint64_t Variable = VoConGlobals_GetVariable(329621357);
    for (uint64_t i = 0; i != 480; i += 24)
    {
      uint64_t v6 = *(void *)(Variable + i + 8);
      if (v6 == a1 || v6 == 0)
      {
        *a2 = Variable + i;
        return 0;
      }
    }
    return err_GenerateErrorLimit();
  }
  else
  {
    return err_GenerateErrorResource();
  }
}

uint64_t BaseComponent_GetType()
{
  return 268501877;
}

uint64_t BaseComponent_HasStreamInfoType(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(a1 + 152) + 8) + 8))(*(void *)(a1 + 152)
                                                                                             + 8 - *(void *)(*(void *)(*(void *)(a1 + 152) + 8) + 16));
}

uint64_t BaseComponent_Init(uint64_t a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4)
{
  uint64_t v14 = 0;
  if (!VoConGlobals_HasVariable(328991267)) {
    VoConGlobals_SetVariable(328991267, 0);
  }
  BOOL v8 = (void *)(*a3)(a4, 480);
  if (!v8)
  {
    uint64_t ErrorResource = err_GenerateErrorResource();
LABEL_10:
    uint64_t v11 = ErrorResource;
    if (!ErrorResource) {
      return v11;
    }
    goto LABEL_13;
  }
  uint64_t v9 = (uint64_t)v8;
  cstdlib_memset(v8, 0, 0x1E0uLL);
  VoConGlobals_SetVariable(329621357, v9);
  uint64_t v10 = (*a3)(a4, 160);
  if (v10 || (uint64_t v11 = err_GenerateErrorResource(), !v11))
  {
    VoConGlobals_SetVariable(303070103, v10);
    uint64_t v11 = _BaseComponent_Con(v10, a1, a3, a4);
    if (!v11)
    {
      *a2 = v10;
      if (!v10) {
        return 0;
      }
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)(v10 + 8) + 32))(v10 + 8 - *(void *)(*(void *)(v10 + 8) + 168), &v14);
      if (!v11)
      {
        uint64_t ErrorResource = PNEW_BaseStreamInfoFactory_Con(v14, v14, (void *)(v10 + 152));
        goto LABEL_10;
      }
    }
  }
LABEL_13:
  if (VoConGlobals_HasVariable(329621357)) {
    VoConGlobals_RemoveVariable(329621357);
  }
  if (VoConGlobals_HasVariable(303070103)) {
    VoConGlobals_RemoveVariable(303070103);
  }
  if (VoConGlobals_HasVariable(2010113315)) {
    VoConGlobals_RemoveVariable(2010113315);
  }
  return v11;
}

uint64_t BaseComponent_IsComponentInstanceAlive(int a1)
{
  uint64_t result = VoConGlobals_HasVariable(329621357);
  if (result)
  {
    uint64_t Variable = VoConGlobals_GetVariable(329621357);
    uint64_t v4 = 0;
    while (*(unsigned __int16 *)(Variable + v4 + 16) != a1)
    {
      v4 += 24;
      if (v4 == 480) {
        return 0;
      }
    }
    return *(_WORD *)(Variable + v4 + 18) != 0;
  }
  return result;
}

uint64_t BaseComponent_IsComponentInstanceInErrorState(int a1)
{
  uint64_t result = VoConGlobals_HasVariable(329621357);
  if (result)
  {
    uint64_t Variable = VoConGlobals_GetVariable(329621357);
    uint64_t v4 = 0;
    while (*(unsigned __int16 *)(Variable + v4 + 16) != a1)
    {
      v4 += 24;
      if (v4 == 480) {
        return 0;
      }
    }
    return *(unsigned __int16 *)(Variable + v4 + 18) == 2;
  }
  return result;
}

BOOL BaseComponent_IsComponentRegistered(uint64_t a1)
{
  uint64_t v4 = 0;
  uint64_t v1 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1 - *(void *)(*(void *)a1 + 168));
  if (__BaseComponent_BorrowComponentInfo(v1, &v4) || *(void *)(v4 + 8) != v1) {
    return 0;
  }
  int v2 = *(unsigned __int16 *)(v4 + 18);
  return v2 == 1 || v2 == 2;
}

uint64_t BaseComponent_IsInitialized()
{
  if (!VoConGlobals_HasVariable(303070103)) {
    return 0;
  }
  ComponentInstanceint Id = BaseComponent_GetComponentInstanceId(268501877);
  if (!ComponentInstanceId) {
    return 0;
  }

  return BaseComponent_IsComponentInstanceAlive(ComponentInstanceId);
}

uint64_t BaseComponent_SetComponentInErrorState(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2 - *(void *)(*(void *)a2 + 168));
  ComponentInstanceint Id = BaseComponent_GetComponentInstanceId(v2);

  return BaseComponent_SetComponentInstanceInErrorState(ComponentInstanceId);
}

uint64_t BaseComponent_SetComponentInstanceInErrorState(int a1)
{
  uint64_t v7 = 0;
  uint64_t result = __BaseComponent_GetComponentInfoByMagicNbr(a1, &v7);
  if (!result)
  {
    uint64_t v2 = (uint64_t *)v7;
    if (*(void *)(v7 + 8) == 268501877)
    {
      uint64_t result = VoConGlobals_HasVariable(329621357);
      if (result)
      {
        uint64_t result = VoConGlobals_GetVariable(329621357);
        for (uint64_t i = 0; i != 480; i += 24)
        {
          if (*(void *)(result + i + 8)) {
            *(_WORD *)(result + i + 18) = 2;
          }
        }
      }
    }
    else if (*(_WORD *)(v7 + 18) != 2)
    {
      *(_WORD *)(v7 + 18) = 2;
      uint64_t v4 = *v2;
      unint64_t v5 = *(uint64_t (**)(uint64_t))(*(void *)v4 + 120);
      uint64_t v6 = v4 - *(void *)(*(void *)v4 + 168);
      return v5(v6);
    }
  }
  return result;
}

uint64_t BaseComponent_UnregisterComponent(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2 - *(void *)(*(void *)a2 + 168));
  --*(_DWORD *)(a1 + 144);
  uint64_t result = __BaseComponent_BorrowComponentInfo(v3, &v6);
  if (!result)
  {
    unint64_t v5 = (void *)v6;
    *(_WORD *)(v6 + 18) = 0;
    *unint64_t v5 = 0;
  }
  return result;
}

void *GetBaseComponentClass()
{
  return &__BaseComponent;
}

uint64_t fstquantize(uint64_t a1, uint64_t a2, uint64_t a3, __int32 a4, __int32 a5, __int32 a6, void *a7)
{
  uint64_t v10 = 0;
  uint64_t result = PNEW_FSTQuantize_Con(a1, a2, a3, a4, a5, a6, &v10);
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 32))(a3);
    if (!result) {
      *a7 = v10;
    }
  }
  return result;
}

uint64_t PNEW_FSTQuantize_Con(uint64_t a1, uint64_t a2, uint64_t a3, __int32 a4, __int32 a5, __int32 a6, int8x8_t **a7)
{
  unsigned int v16 = 0;
  uint64_t v14 = (int8x8_t *)OOCAllocator_Malloc(a1, 104, &v16);
  uint64_t result = v16;
  if (!v16)
  {
    uint64_t result = FSTQuantize_Con(v14, a2, a3, a4, a5, a6);
    unsigned int v16 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v14);
      *a7 = 0;
      return v16;
    }
    else
    {
      v14[2] = (int8x8_t)a1;
      *a7 = v14;
    }
  }
  return result;
}

uint64_t FSTQuantize_Con(int8x8_t *a1, uint64_t a2, uint64_t a3, __int32 a4, __int32 a5, __int32 a6)
{
  uint64_t v12 = _FSTUnaryOperator_Con((uint64_t)a1, a2, a3);
  unsigned int v18 = v12;
  if (!v12)
  {
    *a1 = (int8x8_t)&__FSTQuantize;
    a1[4].i32[0] = 48;
    _FSTUnaryOperator_InheritProperties(a1, a3, 0, 0, 0, 0x3FFFF);
    uint64_t v12 = 0;
    a1[9].i32[0] = a4;
    a1[10] = 0;
    a1[11].i32[1] = a6;
    a1[12].i32[0] = 0;
    a1[11].i32[0] = a5;
    if (a6 != a5)
    {
      a1[12].i32[0] = a6 - a5;
      uint64_t v13 = OOCAllocator_Malloc(a2, 4 * (a4 + 1), &v18);
      a1[10] = (int8x8_t)v13;
      uint64_t v12 = v18;
      if (!v18)
      {
        LODWORD(v14) = a1[9].i32[0];
        if ((v14 & 0x80000000) != 0)
        {
          return 0;
        }
        else
        {
          uint64_t v15 = 0;
          do
          {
            *(_DWORD *)(v13 + 4 * v15) = (a1[12].i32[0] * (int)v15 + a1[11].i32[0] * (int)v14) / (int)v14;
            uint64_t v14 = a1[9].i32[0];
          }
          while (v15++ < v14);
          return v18;
        }
      }
    }
  }
  return v12;
}

uint64_t FSTQuantize_Des(uint64_t a1)
{
  OOCAllocator_Free(*(void *)(a1 + 24), *(void *)(a1 + 80));

  return FSTUnaryOperator_Des(a1);
}

uint64_t FSTQuantize_FetchState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v16 = 0;
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64), a2, a3, &v16);
  if (!result)
  {
    uint64_t v7 = v16;
    if (!v16)
    {
LABEL_18:
      uint64_t result = 0;
      *a4 = v7;
      return result;
    }
    if ((*(_DWORD *)(v16 + 8) & 0x3FFFFFE) == 0)
    {
LABEL_8:
      uint64_t v9 = *(void *)(v7 + 40);
      uint64_t v10 = *(void *)(v7 + 56);
      uint64_t v11 = *(unsigned int *)(v7 + 48);
      uint64_t v12 = v10 + 16 * v11;
      if (v9 != v12)
      {
        uint64_t v13 = v9 + 16 * *(unsigned int *)(v7 + 32);
        do
        {
          if (v9 == v13) {
            uint64_t v14 = v10;
          }
          else {
            uint64_t v14 = v9;
          }
          if (v9 == v13 && !v11) {
            break;
          }
          *(_DWORD *)(v14 + 12) = __FSTQuantize_Quantize(a1, *(unsigned int *)(v14 + 12));
          if ((*(_DWORD *)(v7 + 8) & 0x80000000) != 0) {
            *(_DWORD *)(v7 + 28) = __FSTQuantize_Quantize(a1, *(unsigned int *)(v7 + 28));
          }
          uint64_t v9 = v14 + 16;
        }
        while (v14 + 16 != v12);
      }
      goto LABEL_18;
    }
    uint64_t v15 = 0;
    uint64_t result = FSTStatePool_PopFSTState(*(void *)(a1 + 48), &v15);
    if (!result)
    {
      uint64_t result = FSTState_Copy(v15, v16);
      if (!result)
      {
        int v8 = *(_DWORD *)(v16 + 8);
        *(_DWORD *)(v16 + 8) = v8 - 1;
        if ((v8 & 0x3FFFFFF) == 0) {
          return 9;
        }
        uint64_t v7 = v15;
        uint64_t v16 = v15;
        goto LABEL_8;
      }
    }
  }
  return result;
}

uint64_t __FSTQuantize_Quantize(uint64_t a1, uint64_t a2)
{
  if ((int)a2 >= 1)
  {
    int v2 = *(_DWORD *)(a1 + 88);
    if (v2 != *(_DWORD *)(a1 + 92))
    {
      LODWORD(v3) = *(_DWORD *)(a1 + 72);
      int v4 = 2 * ((int)a2 - v2) * (int)v3 / *(_DWORD *)(a1 + 96);
      if (v4 >= -2)
      {
        if (v4 >= -1) {
          int v5 = v4 + 1;
        }
        else {
          int v5 = v4 + 2;
        }
        int v6 = v5 >> 1;
        if (v6 < (int)v3) {
          LODWORD(v3) = v6;
        }
        uint64_t v3 = (int)v3;
      }
      else
      {
        uint64_t v3 = 0;
      }
      return *(unsigned int *)(*(void *)(a1 + 80) + 4 * v3);
    }
  }
  return a2;
}

uint64_t FSTQuantize_GetFinalStateWeight(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t FinalStateWeight = FSTUnaryOperator_GetFinalStateWeight(a1);
  if (!FinalStateWeight) {
    *a3 = __FSTQuantize_Quantize(a1, 0);
  }
  return FinalStateWeight;
}

uint64_t FSTQuantize_GetMemoryInfo(uint64_t a1)
{
  return FSTUnaryOperator_GetMemoryInfo(a1) + 4 * (*(_DWORD *)(a1 + 72) + 1) + 32;
}

void *GetFSTQuantizeClass()
{
  return &__FSTQuantize;
}

uint64_t FSTStateQueueFifo_Con(uint64_t a1, uint64_t a2)
{
  uint64_t result = Object_Con((void *)a1);
  unsigned int v6 = result;
  if (!result)
  {
    *(void *)a1 = &__FSTStateQueueFifo;
    *(void *)(a1 + 8) = &unk_26D215990;
    *(void *)(a1 + 16) = a2;
    *(_DWORD *)(a1 + 24) = 10;
    uint64_t v5 = OOCAllocator_Malloc(a2, 40, &v6);
    *(void *)(a1 + 32) = v5;
    uint64_t result = v6;
    if (!v6)
    {
      *(void *)(a1 + 40) = v5 + 40;
      *(void *)(a1 + 48) = 0;
    }
  }
  return result;
}

uint64_t FSTStateQueueFifo_Des(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    OOCAllocator_Free(*(void *)(a1 + 16), v1);
  }

  return Object_Des();
}

uint64_t FSTStateQueueFifo_Clear(uint64_t a1)
{
  *(void *)(a1 + 48) = 0;
  return 0;
}

uint64_t FSTStateQueueFifo_Dequeue(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 48) + 1;
  *(_DWORD *)(a1 + 48) = v1;
  if (v1 == ((*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 2)) {
    *(_DWORD *)(a1 + 48) = 0;
  }
  return 0;
}

uint64_t FSTStateQueueFifo_Enqueue(uint64_t a1, int a2)
{
  unsigned int v13 = 0;
  unsigned int v4 = *(_DWORD *)(a1 + 52);
  unsigned int v5 = v4 + 1;
  uint64_t v6 = *(void *)(a1 + 32);
  unint64_t v7 = (unint64_t)(*(void *)(a1 + 40) - v6) >> 2;
  if (v4 + 1 == v7) {
    unsigned int v8 = 0;
  }
  else {
    unsigned int v8 = v4 + 1;
  }
  if (v8 != *(_DWORD *)(a1 + 48)) {
    goto LABEL_18;
  }
  unsigned int v9 = v7 + 1;
  uint64_t v10 = *(unsigned int *)(a1 + 24);
  if ((int)v7 + 1 <= v10)
  {
LABEL_15:
    *(void *)(a1 + 40) = v6 + 4 * v10;
    if (v8)
    {
      cstdlib_memmove((void *)(v6 + 4 * *(unsigned int *)(a1 + 48) + 4 * (v10 - v7)), (const void *)(v6 + 4 * *(unsigned int *)(a1 + 48)), 4 * (v7 - *(_DWORD *)(a1 + 48)));
      unsigned int v4 = *(_DWORD *)(a1 + 52);
      *(_DWORD *)(a1 + 48) += v10 - v7;
      uint64_t v6 = *(void *)(a1 + 32);
      unsigned int v8 = v5;
    }
    else
    {
      unsigned int v4 = *(_DWORD *)(a1 + 52);
      unsigned int v8 = v4 + 1;
    }
LABEL_18:
    *(_DWORD *)(v6 + 4 * v4) = a2;
    *(_DWORD *)(a1 + 52) = v8;
    return v13;
  }
  unsigned int v11 = 2 * v10;
  if (2 * (int)v10 >= (v10 + 1000000)) {
    unsigned int v11 = v10 + 1000000;
  }
  if (v11 > v9) {
    unsigned int v9 = v11;
  }
  if (v9 <= 8) {
    uint64_t v10 = 8;
  }
  else {
    uint64_t v10 = v9;
  }
  uint64_t v6 = OOCAllocator_Realloc(*(void *)(a1 + 16), v6, 4 * v10, &v13);
  *(void *)(a1 + 32) = v6;
  uint64_t result = v13;
  if (!v13)
  {
    *(_DWORD *)(a1 + 24) = v10;
    goto LABEL_15;
  }
  return result;
}

uint64_t FSTStateQueueFifo_Head(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 32) + 4 * *(unsigned int *)(a1 + 48));
}

BOOL FSTStateQueueFifo_IsEmpty(uint64_t a1)
{
  return *(_DWORD *)(a1 + 48) == *(_DWORD *)(a1 + 52);
}

uint64_t FSTStateQueueFifo_Update()
{
  return 0;
}

uint64_t PNEW_FSTStateQueueFifo_Con(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = OOCAllocator_Malloc(a1, 56, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = FSTStateQueueFifo_Con(v6, a2);
    unsigned int v8 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *a3 = v6;
    }
  }
  return result;
}

void *GetFSTStateQueueFifoClass()
{
  return &__FSTStateQueueFifo;
}

uint64_t FSTBuilderBfsContext_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v10 = Object_Con((void *)a1);
  unsigned int v17 = v10;
  if (!v10)
  {
    *(void *)a1 = &__FSTBuilderBfsContext;
    *(void *)(a1 + 16) = a3;
    (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 24) = a4;
    *(_DWORD *)(a1 + 48) = a5;
    unsigned int v11 = (_DWORD *)OOCAllocator_Malloc(a2, 56, &v17);
    *(void *)(a1 + 40) = v11;
    uint64_t v10 = v17;
    if (!v17)
    {
      *unsigned int v11 = 10;
      uint64_t v12 = OOCAllocator_Malloc(a2, 40, &v17);
      unsigned int v13 = *(unsigned int **)(a1 + 40);
      *((void *)v13 + 1) = v12;
      uint64_t v10 = v17;
      if (!v17)
      {
        uint64_t v14 = *v13;
        unint64_t v15 = v12 + 4 * v14;
        *((void *)v13 + 2) = v15;
        if (v14)
        {
          if (v15 <= v12 + 4) {
            unint64_t v15 = v12 + 4;
          }
          memset((void *)v12, 255, ((v15 + ~v12) & 0xFFFFFFFFFFFFFFFCLL) + 4);
        }
        v13[6] = 0;
        *((void *)v13 + 4) = 0;
        *((void *)v13 + 5) = 0;
        v13[12] = -1;
        return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 48))(a3, a1 + 32);
      }
    }
  }
  return v10;
}

uint64_t FSTBuilderBfsContext_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    if (*(void *)(v2 + 8))
    {
      OOCAllocator_Free(*(void *)(a1 + 8), *(void *)(v2 + 8));
      uint64_t v2 = *(void *)(a1 + 40);
    }
    if (*(void *)(v2 + 32))
    {
      OOCAllocator_Free(*(void *)(a1 + 8), *(void *)(v2 + 32));
      uint64_t v2 = *(void *)(a1 + 40);
    }
    OOCAllocator_Free(*(void *)(a1 + 8), v2);
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16));
  if (!result)
  {
    return Object_Des();
  }
  return result;
}

uint64_t FSTBuilderBfsContext_Bfs(uint64_t a1)
{
  unsigned int v89 = 0;
  cstdlib_memset(*(void **)(*(void *)(a1 + 40) + 8), 255, 4 * **(unsigned int **)(a1 + 40));
  uint64_t v2 = *(void *)(a1 + 40);
  *(void *)(v2 + 40) = *(void *)(v2 + 32);
  *(_DWORD *)(v2 + 48) = -1;
  uint64_t v3 = (_DWORD *)OOCAllocator_Malloc(*(void *)(a1 + 8), 400, &v89);
  if (v89) {
    return v89;
  }
  uint64_t v5 = (uint64_t)v3;
  int v6 = *(_DWORD *)(a1 + 32);
  if (v6 == -1)
  {
    unsigned int v14 = 0;
LABEL_40:
    if (v6 == -1)
    {
LABEL_114:
      if (v5) {
        OOCAllocator_Free(*(void *)(a1 + 8), v5);
      }
    }
    else
    {
      unsigned int v36 = 0;
      uint64_t v37 = v5 + 400;
      unsigned int v84 = 100;
      while (1)
      {
        uint64_t v87 = v37;
        uint64_t v88 = 0;
        uint64_t v38 = *(unsigned int *)(v5 + 4 * v36);
        if (v36 + 1 == ((unint64_t)(v37 - v5) >> 2)) {
          unsigned int v36 = 0;
        }
        else {
          ++v36;
        }
        unsigned int v89 = (*(uint64_t (**)(void, uint64_t, uint64_t, _DWORD **))(**(void **)(a1 + 16) + 120))(*(void *)(a1 + 16), v38, 8, &v88);
        if (v89) {
          break;
        }
        if (v88)
        {
          uint64_t v39 = (unsigned int *)*((void *)v88 + 5);
          uint64_t v40 = v88[8];
          uint64_t v41 = *((void *)v88 + 7);
          uint64_t v42 = v88[12];
          unsigned int v89 = _FSTBuilderBfsContext_DiscoverState(a1, v88);
          if (v89) {
            return v89;
          }
          int v85 = (unsigned int *)(v41 + 16 * v42);
          if (v39 != v85)
          {
            uint64_t v86 = &v39[4 * v40];
            do
            {
              if (v39 == v86)
              {
                if (!v88[12]) {
                  break;
                }
                uint64_t v39 = (unsigned int *)*((void *)v88 + 7);
              }
              unsigned int v43 = *v39;
              uint64_t v44 = *(unsigned int **)(a1 + 40);
              int v45 = (char *)*((void *)v44 + 1);
              unint64_t v46 = *((void *)v44 + 2) - (void)v45;
              uint64_t v47 = *v39 % (v46 >> 2);
              int v48 = &v45[4 * v47];
              while (1)
              {
                uint64_t v49 = *(unsigned int *)v48;
                if ((v49 & 0x80000000) != 0) {
                  break;
                }
                int v48 = (char *)(*((void *)v44 + 4) + 8 * v49);
                if (v43 == *((_DWORD *)v48 + 1)) {
                  goto LABEL_104;
                }
              }
              LODWORD(v50) = v44[12];
              if (v50 == -1)
              {
                uint64_t v52 = *((void *)v44 + 4);
                int v55 = (_DWORD *)*((void *)v44 + 5);
                uint64_t v50 = ((unint64_t)v55 - v52) >> 3;
                unsigned int v56 = 2 * (v46 >> 2);
                if (v56 >= v50)
                {
                  unint64_t v61 = ((unint64_t)v55 - v52) >> 3;
                }
                else
                {
                  unsigned int v57 = v56 | 1;
                  uint64_t v58 = *v44;
                  if (v57 <= v58)
                  {
                    uint64_t v50 = 4 * v58;
                  }
                  else
                  {
                    if (v57 <= 8) {
                      unsigned int v59 = 8;
                    }
                    else {
                      unsigned int v59 = v57;
                    }
                    uint64_t v50 = 4 * v59;
                    uint64_t v60 = OOCAllocator_Realloc(*(void *)(a1 + 8), (uint64_t)v45, v50, &v89);
                    uint64_t v44 = *(unsigned int **)(a1 + 40);
                    *((void *)v44 + 1) = v60;
                    if (v89) {
                      return v89;
                    }
                    int v45 = (char *)v60;
                    *uint64_t v44 = v59;
                    v46 &= 0x3FFFFFFFCuLL;
                    *((void *)v44 + 2) = v60 + v46;
                  }
                  unint64_t v62 = (v46 >> 1) & 0xFFFFFFFE | 1;
                  *((void *)v44 + 2) = &v45[4 * v62];
                  cstdlib_memset(v45, 255, v50);
                  uint64_t v44 = *(unsigned int **)(a1 + 40);
                  uint64_t v52 = *((void *)v44 + 4);
                  int v55 = (_DWORD *)*((void *)v44 + 5);
                  unint64_t v61 = ((unint64_t)v55 - v52) >> 3;
                  LODWORD(v50) = v61;
                  if (v61)
                  {
                    uint64_t v63 = 0;
                    int v64 = (_DWORD *)*((void *)v44 + 4);
                    do
                    {
                      if (((*v64 + 1) & 0x40000000) == 0)
                      {
                        if (v89) {
                          return v89;
                        }
                        unint64_t v65 = v64[1]
                            - (v64[1] / v62) * (unint64_t)v62;
                        uint64_t v66 = *((void *)v44 + 1);
                        _DWORD *v64 = *(_DWORD *)(v66 + 4 * v65);
                        *(_DWORD *)(v66 + 4 * v65) = v63;
                      }
                      ++v63;
                      v64 += 2;
                    }
                    while ((((unint64_t)v55 - v52) >> 3) != v63);
                  }
                }
                unsigned int v67 = v50 + 1;
                unsigned int v68 = v44[6];
                if ((int)v50 + 1 > v68)
                {
                  unsigned int v69 = 2 * v68;
                  if (2 * v68 >= v68 + 1000000) {
                    unsigned int v69 = v68 + 1000000;
                  }
                  if (v69 > v67) {
                    unsigned int v67 = v69;
                  }
                  if (v67 <= 8) {
                    unsigned int v70 = 8;
                  }
                  else {
                    unsigned int v70 = v67;
                  }
                  uint64_t v71 = OOCAllocator_Realloc(*(void *)(a1 + 8), v52, 8 * v70, &v89);
                  uint64_t v44 = *(unsigned int **)(a1 + 40);
                  *((void *)v44 + 4) = v71;
                  if (v89) {
                    return v89;
                  }
                  uint64_t v52 = v71;
                  v44[6] = v70;
                  int v55 = (_DWORD *)(v71 + 8 * v61);
                  *((void *)v44 + 5) = v55;
                }
                uint64_t v54 = v87;
                *((void *)v44 + 5) = v55 + 2;
                *int v55 = 0;
                v55[1] = v43;
                int v45 = (char *)*((void *)v44 + 1);
                uint64_t v47 = v43 % ((*((void *)v44 + 2) - (void)v45) >> 2);
                uint64_t v51 = (int)v50;
              }
              else
              {
                uint64_t v51 = (int)v50;
                uint64_t v52 = *((void *)v44 + 4);
                int v53 = (_DWORD *)(v52 + 8 * (int)v50);
                v44[12] = (*v53 & 0xBFFFFFFF) - 1;
                *int v53 = 0;
                v53[1] = v43;
                uint64_t v54 = v87;
              }
              *(_DWORD *)(v52 + 8 * v51) = *(_DWORD *)&v45[4 * v47];
              *(_DWORD *)&v45[4 * v47] = v50;
              unsigned int v72 = v14 + 1;
              unint64_t v73 = (unint64_t)(v54 - v5) >> 2;
              if (v14 + 1 == v73) {
                unsigned int v74 = 0;
              }
              else {
                unsigned int v74 = v14 + 1;
              }
              if (v74 == v36)
              {
                unsigned int v75 = v73 + 1;
                unsigned int v76 = v84;
                if ((int)v73 + 1 <= v84)
                {
                  uint64_t v78 = v84;
                }
                else
                {
                  unsigned int v77 = 2 * v84;
                  if (2 * v84 >= v84 + 1000000) {
                    unsigned int v77 = v84 + 1000000;
                  }
                  if (v77 > v75) {
                    unsigned int v75 = v77;
                  }
                  if (v75 <= 8) {
                    uint64_t v78 = 8;
                  }
                  else {
                    uint64_t v78 = v75;
                  }
                  uint64_t v79 = OOCAllocator_Realloc(*(void *)(a1 + 8), v5, 4 * v78, &v89);
                  if (v89) {
                    return v89;
                  }
                  uint64_t v5 = v79;
                  unsigned int v76 = v78;
                }
                uint64_t v87 = v5 + 4 * v78;
                unsigned int v84 = v76;
                if (v36)
                {
                  size_t v80 = 4 * (v73 - v36);
                  unsigned int v81 = v76 - v73;
                  cstdlib_memmove((void *)(v5 + 4 * v36 + 4 * v81), (const void *)(v5 + 4 * v36), v80);
                  v36 += v81;
                }
              }
              else
              {
                unsigned int v72 = v74;
              }
              *(_DWORD *)(v5 + 4 * v14) = *v39;
              unsigned int v14 = v72;
LABEL_104:
              unsigned int v89 = _FSTBuilderBfsContext_ExploreArc(a1, v38, v39);
              if (v89) {
                return v89;
              }
              v39 += 4;
            }
            while (v39 != v85);
          }
          int v82 = v88[2];
          if ((v82 & 0x3FFFFFF) == 1)
          {
            if ((v82 & 0x8000000) != 0) {
              uint64_t v83 = *((void *)v88 + 2);
            }
            else {
              uint64_t v83 = 0;
            }
            unsigned int v89 = FSTStatePool_PushFSTState(v83, (uint64_t)v88);
            if (v89) {
              return v89;
            }
          }
          else
          {
            v88[2] = v82 - 1;
            if ((v82 & 0x3FFFFFF) == 0) {
              return 9;
            }
            unsigned int v89 = 0;
          }
        }
        uint64_t v37 = v87;
        if (v36 == v14) {
          goto LABEL_114;
        }
      }
    }
  }
  else
  {
    *uint64_t v3 = v6;
    if (v89) {
      return v89;
    }
    unsigned int v7 = *(_DWORD *)(a1 + 32);
    unsigned int v8 = *(unsigned int **)(a1 + 40);
    unsigned int v9 = (_DWORD *)*((void *)v8 + 1);
    unint64_t v10 = *((void *)v8 + 2) - (void)v9;
    uint64_t v11 = v7 % (v10 >> 2);
    uint64_t v12 = &v9[v11];
    while (1)
    {
      uint64_t v13 = *v12;
      if ((v13 & 0x80000000) != 0) {
        break;
      }
      uint64_t v12 = (unsigned int *)(*((void *)v8 + 4) + 8 * v13);
      if (v7 == v12[1]) {
        goto LABEL_39;
      }
    }
    LODWORD(v15) = v8[12];
    if (v15 != -1)
    {
      uint64_t v16 = (int)v15;
      uint64_t v17 = *((void *)v8 + 4);
      unsigned int v18 = (_DWORD *)(v17 + 8 * (int)v15);
      v8[12] = (*v18 & 0xBFFFFFFF) - 1;
      *unsigned int v18 = 0;
      v18[1] = v7;
LABEL_38:
      *(_DWORD *)(v17 + 8 * v16) = v9[v11];
      v9[v11] = v15;
LABEL_39:
      unsigned int v14 = 1;
      goto LABEL_40;
    }
    uint64_t v17 = *((void *)v8 + 4);
    int v19 = (_DWORD *)*((void *)v8 + 5);
    uint64_t v15 = ((unint64_t)v19 - v17) >> 3;
    unsigned int v20 = 2 * (v10 >> 2);
    if (v20 >= v15)
    {
      unint64_t v25 = ((unint64_t)v19 - v17) >> 3;
    }
    else
    {
      unsigned int v21 = v20 | 1;
      uint64_t v22 = *v8;
      if (v21 <= v22)
      {
        uint64_t v15 = 4 * v22;
      }
      else
      {
        if (v21 <= 8) {
          unsigned int v23 = 8;
        }
        else {
          unsigned int v23 = v21;
        }
        uint64_t v15 = 4 * v23;
        uint64_t v24 = OOCAllocator_Realloc(*(void *)(a1 + 8), (uint64_t)v9, v15, &v89);
        unsigned int v8 = *(unsigned int **)(a1 + 40);
        *((void *)v8 + 1) = v24;
        if (v89) {
          return v89;
        }
        unsigned int v9 = (_DWORD *)v24;
        *unsigned int v8 = v23;
        v10 &= 0x3FFFFFFFCuLL;
        *((void *)v8 + 2) = v24 + v10;
      }
      unint64_t v26 = (v10 >> 1) & 0xFFFFFFFE | 1;
      *((void *)v8 + 2) = &v9[v26];
      cstdlib_memset(v9, 255, v15);
      unsigned int v8 = *(unsigned int **)(a1 + 40);
      uint64_t v17 = *((void *)v8 + 4);
      int v19 = (_DWORD *)*((void *)v8 + 5);
      unint64_t v25 = ((unint64_t)v19 - v17) >> 3;
      LODWORD(v15) = v25;
      if (v25)
      {
        uint64_t v27 = 0;
        uint64_t v28 = (_DWORD *)*((void *)v8 + 4);
        do
        {
          if (((*v28 + 1) & 0x40000000) == 0)
          {
            if (v89) {
              return v89;
            }
            unint64_t v29 = v28[1]
                - (v28[1] / v26) * (unint64_t)v26;
            uint64_t v30 = *((void *)v8 + 1);
            _DWORD *v28 = *(_DWORD *)(v30 + 4 * v29);
            *(_DWORD *)(v30 + 4 * v29) = v27;
          }
          ++v27;
          v28 += 2;
        }
        while ((((unint64_t)v19 - v17) >> 3) != v27);
      }
    }
    unsigned int v31 = v15 + 1;
    unsigned int v32 = v8[6];
    if ((int)v15 + 1 <= v32)
    {
LABEL_37:
      *((void *)v8 + 5) = v19 + 2;
      *int v19 = 0;
      v19[1] = v7;
      unsigned int v9 = (_DWORD *)*((void *)v8 + 1);
      uint64_t v11 = v7 % ((*((void *)v8 + 2) - (void)v9) >> 2);
      uint64_t v16 = (int)v15;
      goto LABEL_38;
    }
    unsigned int v33 = 2 * v32;
    if (2 * v32 >= v32 + 1000000) {
      unsigned int v33 = v32 + 1000000;
    }
    if (v33 > v31) {
      unsigned int v31 = v33;
    }
    if (v31 <= 8) {
      unsigned int v34 = 8;
    }
    else {
      unsigned int v34 = v31;
    }
    uint64_t v35 = OOCAllocator_Realloc(*(void *)(a1 + 8), v17, 8 * v34, &v89);
    unsigned int v8 = *(unsigned int **)(a1 + 40);
    *((void *)v8 + 4) = v35;
    if (!v89)
    {
      uint64_t v17 = v35;
      v8[6] = v34;
      int v19 = (_DWORD *)(v35 + 8 * v25);
      *((void *)v8 + 5) = v19;
      goto LABEL_37;
    }
  }
  return v89;
}