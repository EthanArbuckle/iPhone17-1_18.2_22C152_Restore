uint64_t TPSendUDPDataPacket(uint64_t a1, _OWORD *a2, int a3, int a4, int a5, char a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  _DWORD v16[2];
  long long v17;
  long long v18;
  long long v19;
  long long v20;
  long long v21;
  long long v22;
  long long v23;
  long long v24;
  long long v25;
  long long v26;
  long long v27;
  long long v28;
  long long v29;
  long long v30;
  long long v31;
  long long v32;
  long long v33;
  long long v34;
  long long v35;
  long long v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E4F143B8];
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v32 = 0u;
  v31 = 0u;
  v30 = 0u;
  v29 = 0u;
  v28 = 0u;
  v27 = 0u;
  v26 = 0u;
  v25 = 0u;
  v24 = 0u;
  v23 = 0u;
  v22 = 0u;
  v21 = 0u;
  v20 = 0u;
  v19 = 0u;
  v18 = 0u;
  v17 = 0u;
  if (!CheckInHandleDebug()) {
    return 2148466690;
  }
  BYTE4(v17) = a6;
  LODWORD(v26) = 0;
  v16[0] = a7;
  v16[1] = a5;
  LODWORD(v17) = a4;
  BYTE1(v27) = 1;
  v13 = VTP_Send(-1, a2, a3, 0, (uint64_t)v16);
  v14 = 0;
  if (v13 == -1) {
    v14 = *__error() | 0xC00F0000;
  }
  CheckOutHandleDebug();
  return v14;
}

uint64_t TPCreateHandle(uint64_t *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, uint64_t a11)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  pthread_mutex_lock(&g_xTPHandle);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v15 = VRTraceErrorLogLevelToCSTR();
    v16 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316162;
      *(void *)&buf[4] = v15;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "TPCreateHandle";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)v66 = 1913;
      *(_WORD *)&v66[4] = 1024;
      *(_DWORD *)&v66[6] = g_iHandleRefCount;
      *(_WORD *)&v66[10] = 2048;
      *(void *)&v66[12] = g_hActualTPHandle;
      _os_log_impl(&dword_1E1EA4000, v16, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ((((( In TPCreateHandle with g_iHandleRefCount = %d and g_hActualTPHandle = %p)))))", buf, 0x2Cu);
    }
  }
  if (g_iHandleRefCount)
  {
    v17 = (void *)CheckInHandleDebug();
    if (!v17)
    {
      pthread_mutex_unlock(&g_xTPHandle);
      return 2148466690;
    }
    v18 = v17 + 4289;
    if (a3) {
      void *v18 = a3;
    }
    if (a4) {
      v17[4290] = a4;
    }
    if (a5) {
      v17[4292] = a5;
    }
    if (a6) {
      v17[4293] = a6;
    }
    if (a7) {
      v17[4294] = a7;
    }
    if (a8) {
      v17[4295] = a8;
    }
    if (a9)
    {
      v19 = (const void *)v17[4297];
      v17[4297] = a9;
      CFRetain(a9);
      if (v19) {
        CFRelease(v19);
      }
    }
    if (a10) {
      v18[30] = a10;
    }
    if (a11)
    {
      uint64_t v22 = v18[31];
      v21 = v18 + 31;
      uint64_t v20 = v22;
      uint64_t v23 = *(void *)(a11 + 16);
      *(_OWORD *)v21 = *(_OWORD *)a11;
      v24 = (void (*)(void))v21[1];
      v25 = (void (*)(uint64_t))v21[2];
      v21[2] = v23;
      if (v24 && *v21) {
        v24();
      }
      if (v25 && v20) {
        v25(v20);
      }
    }
    *a1 = g_hActualTPHandle;
    ++g_iHandleRefCount;
    CheckOutHandleDebug();
  }
  else
  {
    v29 = (char *)malloc_type_calloc(1uLL, 0x8760uLL, 0x10E0040F635D44DuLL);
    if (!v29)
    {
      uint64_t v28 = 2148466691;
      pthread_mutex_unlock(&g_xTPHandle);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          TPCreateHandle_cold_1();
        }
      }
      return v28;
    }
    v30 = v29;
    v31 = v29 + 34312;
    *(_DWORD *)v29 = a2;
    *((void *)v29 + 1) = 0xFFFFFFFF00000000;
    v52 = (pthread_rwlock_t *)(v29 + 1064);
    pthread_rwlock_init((pthread_rwlock_t *)(v29 + 1064), 0);
    pthread_rwlock_init((pthread_rwlock_t *)(v30 + 1272), 0);
    pthread_mutex_init((pthread_mutex_t *)(v30 + 992), 0);
    pthread_mutex_init((pthread_mutex_t *)(v30 + 1480), 0);
    pthread_mutex_init((pthread_mutex_t *)(v30 + 34584), 0);
    pthread_mutex_init((pthread_mutex_t *)(v30 + 34392), 0);
    v70.__sig = 0xAAAAAAAAAAAAAAAALL;
    *(void *)v70.__opaque = 0xAAAAAAAAAAAAAAAALL;
    if (!pthread_mutexattr_init(&v70))
    {
      for (uint64_t i = 0; i != 0x8000; i += 128)
      {
        pthread_mutexattr_settype(&v70, 2);
        pthread_mutex_init((pthread_mutex_t *)&v30[i + 1560], &v70);
        pthread_cond_init((pthread_cond_t *)&v30[i + 1624], 0);
      }
      pthread_mutexattr_destroy(&v70);
    }
    *((void *)v31 + 2) = 0xFFFFFFFFLL;
    *(void *)v31 = a3;
    *((void *)v31 + 1) = a4;
    *((void *)v31 + 3) = a5;
    *((void *)v31 + 4) = a6;
    *((void *)v31 + 5) = a7;
    *((void *)v31 + 6) = a8;
    *((void *)v31 + 8) = a9;
    if (a9) {
      CFRetain(a9);
    }
    *((_DWORD *)v31 + 18) = VCTestMonitorManager_GetEnableLoopbackInterface();
    if (a10) {
      *((void *)v31 + 30) = a10;
    }
    if (a11)
    {
      uint64_t v33 = *(void *)(a11 + 16);
      *(_OWORD *)(v31 + 248) = *(_OWORD *)a11;
      *((void *)v31 + 33) = v33;
      v34 = (void (*)(void))*((void *)v31 + 32);
      if (v34)
      {
        if (*((void *)v31 + 31)) {
          v34();
        }
      }
    }
    *((void *)v31 + 27) = 0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v35 = VRTraceErrorLogLevelToCSTR();
      v36 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v37 = *a1;
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v35;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "TPCreateHandle";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v66 = 1968;
        *(_WORD *)&v66[4] = 2048;
        *(void *)&v66[6] = a1;
        *(_WORD *)&v66[14] = 2048;
        *(void *)&v66[16] = v37;
        _os_log_impl(&dword_1E1EA4000, v36, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ((((( In TPCreateHandle [A] phTP = %p and *phTP = %ld)))))", buf, 0x30u);
      }
    }
    *a1 = CreateHandle();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v38 = VRTraceErrorLogLevelToCSTR();
      v39 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v40 = *a1;
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v38;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "TPCreateHandle";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v66 = 1972;
        *(_WORD *)&v66[4] = 2048;
        *(void *)&v66[6] = a1;
        *(_WORD *)&v66[14] = 2048;
        *(void *)&v66[16] = v40;
        _os_log_impl(&dword_1E1EA4000, v39, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ((((( In TPCreateHandle [B] phTP = %p and *phTP = %ld)))))", buf, 0x30u);
      }
    }
    if (*a1 == 0xFFFFFFFFLL)
    {
      pthread_rwlock_destroy(v52);
      pthread_rwlock_destroy((pthread_rwlock_t *)(v30 + 1272));
      pthread_mutex_destroy((pthread_mutex_t *)(v30 + 992));
      pthread_mutex_destroy((pthread_mutex_t *)(v30 + 1480));
      pthread_mutex_destroy((pthread_mutex_t *)(v30 + 34584));
      for (uint64_t j = 0; j != 0x8000; j += 128)
      {
        pthread_mutex_destroy((pthread_mutex_t *)&v30[j + 1560]);
        pthread_cond_destroy((pthread_cond_t *)&v30[j + 1624]);
      }
      v49 = (const void *)*((void *)v31 + 8);
      if (v49) {
        CFRelease(v49);
      }
      v50 = (void (*)(void))*((void *)v31 + 33);
      if (v50 && *((void *)v31 + 31)) {
        v50();
      }
      free(v30);
      pthread_mutex_unlock(&g_xTPHandle);
      return 2148466693;
    }
    CustomRootQueue = VCDispatchQueue_GetCustomRootQueue(37);
    *((void *)v31 + 7) = dispatch_queue_create_with_target_V2("com.apple.AVConference.Transport.ICEConnectivityCallbackQueue", 0, CustomRootQueue);
    *(void *)buf = TPSendUDPPacket;
    *(void *)&buf[8] = TPRecvUDPPacketWithTimeout;
    *(void *)&buf[16] = TPConnectedCallback;
    *(void *)v66 = TPCancelRecvUDP;
    *(void *)&v66[8] = TPProcessICENomination;
    *(void *)&v66[16] = 0;
    v67 = TPNewCandidatesCallback;
    v68 = TPShouldNominateICECandidatePair;
    v69 = TPRemoveIPPort;
    int v42 = ICECreateHandleWithCallback();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v43 = VRTraceErrorLogLevelToCSTR();
      v44 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v45 = *a1;
        *(_DWORD *)v57 = 136316162;
        uint64_t v58 = v43;
        __int16 v59 = 2080;
        v60 = "TPCreateHandle";
        __int16 v61 = 1024;
        int v62 = 2006;
        __int16 v63 = 2048;
        *(void *)v64 = a1;
        *(_WORD *)&v64[8] = 2048;
        *(void *)&v64[10] = v45;
        _os_log_impl(&dword_1E1EA4000, v44, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ((((( In TPCreateHandle [C] phTP = %p and *phTP = %ld)))))", v57, 0x30u);
      }
    }
    g_hActualTPHandle = *a1;
    g_iHandleRefCount = 1;
    if (v42 < 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          TPCreateHandle_cold_2();
        }
      }
      TPCloseHandle();
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v46 = VRTraceErrorLogLevelToCSTR();
      v47 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v57 = 136316162;
        uint64_t v58 = v46;
        __int16 v59 = 2080;
        v60 = "TPCreateHandle";
        __int16 v61 = 1024;
        int v62 = 2016;
        __int16 v63 = 1024;
        *(_DWORD *)v64 = g_iHandleRefCount;
        *(_WORD *)&v64[4] = 2048;
        *(void *)&v64[6] = g_hActualTPHandle;
        _os_log_impl(&dword_1E1EA4000, v47, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ((((( In TPCreateHandle AREA 1 with g_iHandleRefCount = %d and g_hActualTPHandle = %p)))))", v57, 0x2Cu);
      }
    }
  }
  pthread_mutex_unlock(&g_xTPHandle);
  if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
    return 0;
  }
  uint64_t v26 = VRTraceErrorLogLevelToCSTR();
  v27 = *MEMORY[0x1E4F47A50];
  uint64_t v28 = 0;
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136316162;
    *(void *)&buf[4] = v26;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "TPCreateHandle";
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)v66 = 2066;
    *(_WORD *)&v66[4] = 1024;
    *(_DWORD *)&v66[6] = g_iHandleRefCount;
    *(_WORD *)&v66[10] = 2048;
    *(void *)&v66[12] = g_hActualTPHandle;
    _os_log_impl(&dword_1E1EA4000, v27, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ((((( Leaving TPCreateHandle successfully with g_iHandleRefCount = %d and g_hActualTPHandle = %p)))))", buf, 0x2Cu);
    return 0;
  }
  return v28;
}

uint64_t TPSendUDPPacket(uint64_t a1, int a2, _OWORD *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v28 = 0;
  long long v26 = 0u;
  long long v27 = 0u;
  uint64_t v14 = 2148466690;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v17 = 0u;
  memset(v16, 0, sizeof(v16));
  if (CheckInHandleDebug())
  {
    LODWORD(v16[0]) = 0;
    DWORD2(v16[0]) = a2;
    BYTE12(v16[0]) = a8;
    *((void *)&v17 + 1) = 0x100000000;
    BYTE9(v18) = 1;
    if (VTP_SendWithSourceDestinationIP(a5, a6, a3, a4, 0, (uint64_t)v16) == -1) {
      uint64_t v14 = 2148466721;
    }
    else {
      uint64_t v14 = 0;
    }
    CheckOutHandleDebug();
  }
  return v14;
}

uint64_t TPRecvUDPPacketWithTimeout(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4, uint64_t a5, uint64_t a6, void *a7, int a8, unsigned int a9)
{
  uint64_t v9 = a9;
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = 2148466710;
  if (a9 > 0xFF) {
    return v10;
  }
  uint64_t v16 = CheckInHandleDebug();
  if (!v16) {
    return 2148466690;
  }
  uint64_t v17 = v16;
  __dst = a3;
  uint64_t v53 = a6;
  v54 = a7;
  double v18 = micro();
  pthread_mutex_lock((pthread_mutex_t *)(v17 + 1560 + ((unint64_t)a9 << 7)));
  uint64_t v19 = 0;
  int v20 = *(unsigned __int16 *)(a5 + 36);
  double v21 = (double)a8 / 1000.0;
  long long v22 = (void *)MEMORY[0x1E4F148B8];
  while (1)
  {
    uint64_t v23 = v17 + (v9 << 7);
    long long v24 = (uint64_t *)(v23 + 1552);
    if (!v20)
    {
      if (*v24)
      {
        uint64_t v10 = v19;
      }
      else
      {
        uint64_t v31 = v17 + (v9 << 7);
        if (*(_DWORD *)(v31 + 1544))
        {
          int v42 = (_DWORD *)(v31 + 1544);
LABEL_57:
          *int v42 = 0;
LABEL_58:
          uint64_t v43 = v17 + (v9 << 7);
          uint64_t v44 = *(void *)(v43 + 1552);
          if (v44)
          {
            uint64_t v45 = (void *)(v43 + 1552);
            size_t v46 = *(int *)(v44 + 2052);
            *a4 = v46;
            memcpy(__dst, (const void *)v44, v46);
            uint64_t v47 = *(void *)(v44 + 2088);
            long long v48 = *(_OWORD *)(v44 + 2072);
            *(_OWORD *)a5 = *(_OWORD *)(v44 + 2056);
            *(_OWORD *)(a5 + 16) = v48;
            *(void *)(a5 + 32) = v47;
            long long v49 = *(_OWORD *)(v44 + 2112);
            long long v50 = *(_OWORD *)(v44 + 2096);
            *(void *)(v53 + 32) = *(void *)(v44 + 2128);
            *(_OWORD *)uint64_t v53 = v50;
            *(_OWORD *)(v53 + 16) = v49;
            if (v54) {
              void *v54 = *(void *)(v44 + 2136);
            }
            *uint64_t v45 = *(void *)(v44 + 2144);
            free((void *)v44);
            uint64_t v19 = 0;
          }
          goto LABEL_62;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(v31 + 1560));
        pthread_mutex_lock((pthread_mutex_t *)(v17 + 1560));
        if (*(void *)(v17 + 1552))
        {
          uint64_t v9 = 0;
        }
        else
        {
          uint64_t v9 = 0;
          if (!*(_DWORD *)(v17 + 1544))
          {
            LODWORD(v19) = -2146500586;
            goto LABEL_35;
          }
          uint64_t v10 = 2148466718;
        }
      }
      int v42 = (_DWORD *)(v17 + (v9 << 7) + 1544);
      uint64_t v19 = v10;
      goto LABEL_57;
    }
    if (*(_DWORD *)(v23 + 1544)) {
      goto LABEL_44;
    }
    uint64_t v25 = *v24;
    if (*v24) {
      break;
    }
LABEL_35:
    double v32 = v21 - (micro() - v18);
    if (v32 < 0.0)
    {
      *(_DWORD *)(v17 + (v9 << 7) + 1544) = 0;
      uint64_t v19 = 2148466711;
      goto LABEL_50;
    }
    v56.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v56.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    convertTimeoutToRelativeTimespec(v32);
    v56.tv_sec = v33;
    v56.tv_nsec = v34;
    uint64_t v35 = v17 + (v9 << 7);
    int v36 = pthread_cond_timedwait_relative_np((pthread_cond_t *)(v35 + 1624), (pthread_mutex_t *)(v35 + 1560), &v56);
    if (v36)
    {
      if (v36 == 60) {
        uint64_t v19 = 2148466711;
      }
      else {
        uint64_t v19 = v36 | 0xC00F0000;
      }
      *(_DWORD *)(v35 + 1544) = 0;
LABEL_50:
      if (v20) {
        goto LABEL_62;
      }
      goto LABEL_58;
    }
    if (*(_DWORD *)(v35 + 1544)) {
      uint64_t v19 = 2148466718;
    }
    else {
      uint64_t v19 = v19;
    }
  }
  int v26 = *(_DWORD *)a5 & 1;
  while ((*(_DWORD *)(v25 + 2056) & 1) != v26)
  {
LABEL_19:
    if (*(_DWORD *)(v25 + 2056)) {
      goto LABEL_22;
    }
    if (!*(_DWORD *)(v25 + 2076)) {
      goto LABEL_27;
    }
LABEL_28:
    long long v24 = (uint64_t *)(v25 + 2144);
    uint64_t v25 = *(void *)(v25 + 2144);
    if (!v25) {
      goto LABEL_35;
    }
  }
  long long v27 = (int *)(v25 + 2076);
  if (!v26)
  {
    int v28 = *v27;
    if (v28 != *(_DWORD *)(a5 + 20))
    {
      if (!v28) {
        goto LABEL_27;
      }
      goto LABEL_28;
    }
    goto LABEL_18;
  }
  if (*(void *)v27 == *(void *)(a5 + 20) && *(void *)(v25 + 2084) == *(void *)(a5 + 28))
  {
LABEL_18:
    if (*(unsigned __int16 *)(v25 + 2092) == *(unsigned __int16 *)(a5 + 36)) {
      goto LABEL_41;
    }
    goto LABEL_19;
  }
LABEL_22:
  if (*(void *)(v25 + 2076) != *v22 || *(void *)(v25 + 2084) != v22[1]) {
    goto LABEL_28;
  }
LABEL_27:
  if (*(unsigned __int16 *)(v25 + 2092) != *(unsigned __int16 *)(a5 + 36)) {
    goto LABEL_28;
  }
LABEL_41:
  size_t v37 = *(int *)(v25 + 2052);
  *a4 = v37;
  memcpy(__dst, (const void *)v25, v37);
  uint64_t v38 = *(void *)(v25 + 2088);
  long long v39 = *(_OWORD *)(v25 + 2072);
  *(_OWORD *)a5 = *(_OWORD *)(v25 + 2056);
  *(_OWORD *)(a5 + 16) = v39;
  *(void *)(a5 + 32) = v38;
  long long v40 = *(_OWORD *)(v25 + 2112);
  long long v41 = *(_OWORD *)(v25 + 2096);
  *(void *)(v53 + 32) = *(void *)(v25 + 2128);
  *(_OWORD *)uint64_t v53 = v41;
  *(_OWORD *)(v53 + 16) = v40;
  if (v54) {
    void *v54 = *(void *)(v25 + 2136);
  }
  *long long v24 = *(void *)(v25 + 2144);
  free((void *)v25);
LABEL_44:
  *(_DWORD *)(v23 + 1544) = 0;
LABEL_62:
  pthread_mutex_unlock((pthread_mutex_t *)(v17 + (v9 << 7) + 1560));
  CheckOutHandleDebug();
  return v19;
}

uint64_t TPConnectedCallback(uint64_t a1, int a2, const void *a3, int *a4, int a5, uint64_t a6, int a7)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = CheckInHandleDebug();
  if (!v14) {
    return 2148466690;
  }
  uint64_t v15 = v14 + 34368;
  if (a4) {
    int v24 = *a4;
  }
  else {
    int v24 = 0;
  }
  uint64_t v25 = a6;
  if (a3)
  {
    uint64_t v17 = malloc_type_calloc(1uLL, 0x140uLL, 0x1020040A6FBA1A4uLL);
    double v18 = v17;
    int v19 = a7;
    if (v17)
    {
      memcpy(v17, a3, 0x140uLL);
      v18[38] = 0;
    }
  }
  else
  {
    int v19 = a7;
    double v18 = 0;
  }
  uint64_t v20 = *(void *)(v15 + 8);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v21 = VRTraceErrorLogLevelToCSTR();
    long long v22 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316162;
      uint64_t v32 = v21;
      __int16 v33 = 2080;
      uint64_t v34 = "TPConnectedCallback";
      __int16 v35 = 1024;
      int v36 = 4500;
      __int16 v37 = 1024;
      int v38 = (int)a3;
      __int16 v39 = 1024;
      int v40 = a5;
      _os_log_impl(&dword_1E1EA4000, v22, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPConnectedCallback: pCCResult == %08X, fUseRelay = %d ...", buf, 0x28u);
    }
  }
  uint64_t v23 = *(NSObject **)v15;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __TPConnectedCallback_block_invoke;
  block[3] = &__block_descriptor_tmp_38;
  block[4] = a1;
  block[5] = v18;
  int v27 = v24;
  int v28 = a5;
  block[6] = v20;
  block[7] = v25;
  int v29 = a2;
  int v30 = v19;
  dispatch_async(v23, block);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPCancelRecvUDP(uint64_t a1, int a2)
{
  uint64_t v3 = CheckInHandleDebug();
  if (!v3) {
    return 2148466690;
  }
  uint64_t v4 = v3 + ((uint64_t)a2 << 7);
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 1560));
  *(_DWORD *)(v4 + 1544) = 1;
  pthread_cond_signal((pthread_cond_t *)(v4 + 1624));
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 1560));
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPProcessICENomination(uint64_t a1, int a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!CheckInHandleDebug()) {
    return 2148466690;
  }
  *(void *)&v26[14] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v25[3] = v7;
  *(_OWORD *)int v26 = v7;
  v25[2] = v7;
  long long v23 = v7;
  long long v24 = v7;
  v25[0] = v7;
  *(void *)((char *)v25 + 14) = 0xAAAAAAAAAAAAAAAALL;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v8 = VRTraceErrorLogLevelToCSTR();
    uint64_t v9 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 136316418;
      uint64_t v12 = v8;
      __int16 v13 = 2080;
      uint64_t v14 = "TPProcessICENomination";
      __int16 v15 = 1024;
      int v16 = 4593;
      __int16 v17 = 1024;
      int v18 = a2;
      __int16 v19 = 2080;
      uint64_t v20 = IPPORTToStringWithSize();
      __int16 v21 = 2080;
      uint64_t v22 = IPPORTToStringWithSize();
      _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPProcessICENomination Callback: callID[%08X] local[%s] dst[%s].", (uint8_t *)&v11, 0x36u);
    }
  }
  VTP_SetRTPSrc(a2, a3, a4);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPNewCandidatesCallback(uint64_t a1, int a2, const void *a3, int a4, __int16 a5)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = CheckInHandleDebug();
  if (!v10) {
    return 2148466690;
  }
  int v11 = (NSObject **)(v10 + 34368);
  uint64_t v12 = *(void *)(v10 + 34376);
  if (a3)
  {
    __int16 v13 = malloc_type_malloc(a4, 0x393E6477uLL);
    uint64_t v14 = v13;
    if (v13) {
      memcpy(v13, a3, a4);
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  int v16 = *v11;
  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 0x40000000;
  v17[2] = __TPNewCandidatesCallback_block_invoke;
  v17[3] = &__block_descriptor_tmp_39;
  v17[4] = a1;
  v17[5] = v12;
  int v18 = a4;
  int v19 = a2;
  v17[6] = v14;
  __int16 v20 = a5;
  dispatch_async(v16, v17);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPShouldNominateICECandidatePair(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = CheckInHandleDebug();
  if (!v15) {
    return 2148466690;
  }
  int v16 = *(NSObject **)(v15 + 34368);
  v18[0] = MEMORY[0x1E4F143A8];
  v18[1] = 0x40000000;
  v18[2] = __TPShouldNominateICECandidatePair_block_invoke;
  v18[3] = &__block_descriptor_tmp_40;
  v18[4] = v15;
  v18[5] = a3;
  int v19 = a2;
  int v20 = a4;
  v18[6] = a5;
  v18[7] = a6;
  v18[8] = a7;
  v18[9] = a8;
  dispatch_sync(v16, v18);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPRemoveIPPort(uint64_t a1, int a2, long long *a3, int a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  v15[2] = 0x4000000000;
  long long v7 = a3[1];
  long long v16 = *a3;
  long long v17 = v7;
  v15[0] = 0;
  v15[1] = v15;
  uint64_t v18 = *((void *)a3 + 4);
  uint64_t v8 = CheckInHandleDebug();
  if (v8)
  {
    uint64_t v9 = *(NSObject **)(v8 + 34368);
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 0x40000000;
    v12[2] = __TPRemoveIPPort_block_invoke;
    v12[3] = &unk_1E6DB7188;
    v12[4] = v15;
    v12[5] = a1;
    int v13 = a2;
    int v14 = a4;
    dispatch_async(v9, v12);
    CheckOutHandleDebug();
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = 2148466690;
  }
  _Block_object_dispose(v15, 8);
  return v10;
}

uint64_t TPCloseHandle()
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v0 = VRTraceErrorLogLevelToCSTR();
    v1 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v32 = 136316162;
      *(void *)&v32[4] = v0;
      __int16 v33 = 2080;
      uint64_t v34 = "TPCloseHandle";
      __int16 v35 = 1024;
      int v36 = 2077;
      __int16 v37 = 1024;
      int v38 = g_iHandleRefCount;
      __int16 v39 = 2048;
      uint64_t v40 = g_hActualTPHandle;
      _os_log_impl(&dword_1E1EA4000, v1, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ((((( In TPCloseHandle with g_iHandleRefCount = %d and g_hActualTPHandle = %p)))))", v32, 0x2Cu);
    }
  }
  pthread_mutex_lock(&g_xTPHandle);
  int v2 = g_iHandleRefCount;
  if (g_iHandleRefCount <= 0)
  {
    uint64_t v28 = 2148466692;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v29 = VRTraceErrorLogLevelToCSTR();
      int v30 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v32 = 136315650;
        *(void *)&v32[4] = v29;
        __int16 v33 = 2080;
        uint64_t v34 = "TPCloseHandle";
        __int16 v35 = 1024;
        int v36 = 2082;
        _os_log_impl(&dword_1E1EA4000, v30, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Unmatched call to TPCreateHandle, TPCloseHandle called with non-positive ref count", v32, 0x1Cu);
      }
    }
  }
  else
  {
    --g_iHandleRefCount;
    if (v2 == 1)
    {
      g_iHandleRefCount = 0;
      uint64_t v3 = CheckInHandleDebug();
      if (!v3)
      {
        uint64_t v28 = 2148466690;
        goto LABEL_52;
      }
      uint64_t v4 = v3;
      v5 = (void *)(v3 + 34328);
      v6 = (pthread_rwlock_t *)(v3 + 1064);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 1064));
      *(_DWORD *)(v4 + 8) = 1;
      int v7 = *(_DWORD *)(v4 + 12);
      if (v7 != -1) {
        VTP_Close(v7);
      }
      *(_DWORD *)(v4 + 12) = -1;
      for (uint64_t i = *(void *)(v4 + 1056); i; uint64_t i = *(void *)(i + 2144))
      {
        ICERemoveOneInterface();
        if (!*(_DWORD *)(i + 2068)) {
          VTP_Close(*(_DWORD *)i);
        }
        uint64_t v9 = *(void *)(i + 2128);
        if (v9 != 0xFFFFFFFFLL)
        {
          if (*(void *)(i + 2136) != 0xFFFFFFFFLL)
          {
            ARPLSessionRelease();
            *(void *)(i + 2136) = 0xFFFFFFFFLL;
            uint64_t v9 = *(void *)(i + 2128);
          }
          DTLS_Cleanup(v9);
          *(void *)(i + 2128) = 0xFFFFFFFFLL;
        }
      }
      pthread_rwlock_unlock(v6);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 1272));
      for (uint64_t j = *(void *)(v4 + 1264); j; uint64_t j = *(void *)(j + 2144))
        ICERemoveOneInterface();
      pthread_rwlock_unlock((pthread_rwlock_t *)(v4 + 1272));
      int v11 = *(_opaque_pthread_t **)(v4 + 24);
      if (v11)
      {
        *(void *)uint64_t v32 = 0xAAAAAAAAAAAAAAAALL;
        pthread_join(v11, (void **)v32);
      }
      for (uint64_t k = 0; k != 0x8000; k += 128)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v4 + k + 1560));
        *(_DWORD *)(v4 + k + 1544) = 1;
        pthread_cond_broadcast((pthread_cond_t *)(v4 + k + 1624));
        pthread_mutex_unlock((pthread_mutex_t *)(v4 + k + 1560));
      }
      CheckOutHandleDebug();
      TPCleanupBaseband(v4);
      int v13 = (const void *)v5[25];
      if (v13) {
        CFRelease(v13);
      }
      ICECloseHandle();
      *(_OWORD *)(v4 + 34336) = 0u;
      *(_OWORD *)(v4 + 34352) = 0u;
      int v14 = (const void *)v5[6];
      if (v14) {
        CFRelease(v14);
      }
      uint64_t v15 = (void (*)(void))v5[31];
      if (v15 && v5[29]) {
        v15();
      }
      long long v16 = v5[5];
      if (v16) {
        dispatch_release(v16);
      }
      pthread_rwlock_wrlock(v6);
      long long v17 = *(void **)(v4 + 1056);
      if (v17)
      {
        do
        {
          uint64_t v18 = (void *)v17[268];
          uint64_t v19 = v17[266];
          if (v19 != 0xFFFFFFFFLL)
          {
            if (v17[267] != 0xFFFFFFFFLL)
            {
              ARPLSessionRelease();
              v17[267] = 0xFFFFFFFFLL;
              uint64_t v19 = v17[266];
            }
            DTLS_Cleanup(v19);
          }
          free(v17);
          long long v17 = v18;
        }
        while (v18);
      }
      pthread_rwlock_unlock(v6);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 1272));
      int v20 = *(void **)(v4 + 1264);
      if (v20)
      {
        do
        {
          uint64_t v21 = (void *)v20[268];
          free(v20);
          int v20 = v21;
        }
        while (v21);
      }
      pthread_rwlock_unlock((pthread_rwlock_t *)(v4 + 1272));
      pthread_mutex_lock((pthread_mutex_t *)(v4 + 1480));
      uint64_t v22 = *(void **)(v4 + 1472);
      if (v22)
      {
        do
        {
          long long v23 = (void *)v22[17];
          free(v22);
          uint64_t v22 = v23;
        }
        while (v23);
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v4 + 1480));
      for (uint64_t m = 0; m != 256; ++m)
      {
        uint64_t v25 = v4 + (m << 7);
        pthread_mutex_lock((pthread_mutex_t *)(v25 + 1560));
        int v26 = *(void **)(v25 + 1552);
        if (v26)
        {
          do
          {
            uint64_t v27 = (void *)v26[268];
            free(v26);
            int v26 = v27;
          }
          while (v27);
        }
        pthread_mutex_unlock((pthread_mutex_t *)(v25 + 1560));
        pthread_mutex_destroy((pthread_mutex_t *)(v25 + 1560));
        pthread_cond_destroy((pthread_cond_t *)(v25 + 1624));
      }
      pthread_rwlock_destroy(v6);
      pthread_rwlock_destroy((pthread_rwlock_t *)(v4 + 1272));
      pthread_mutex_destroy((pthread_mutex_t *)(v4 + 992));
      pthread_mutex_destroy((pthread_mutex_t *)(v4 + 1480));
      pthread_mutex_destroy((pthread_mutex_t *)(v4 + 34584));
      pthread_mutex_destroy((pthread_mutex_t *)(v4 + 34392));
      free((void *)v4);
    }
    uint64_t v28 = 0;
  }
LABEL_52:
  pthread_mutex_unlock(&g_xTPHandle);
  return v28;
}

uint64_t TPCleanupBaseband(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1 + 34456;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v3 = VRTraceErrorLogLevelToCSTR();
    uint64_t v4 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 136315650;
      uint64_t v10 = v3;
      __int16 v11 = 2080;
      uint64_t v12 = "TPCleanupBaseband";
      __int16 v13 = 1024;
      int v14 = 857;
      _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d LET US CLEANUP BASEBAND.", (uint8_t *)&v9, 0x1Cu);
    }
  }
  uint64_t result = TPCleanupBasebandNotifications(a1);
  if (*(_DWORD *)(v2 + 56))
  {
    v6 = (pthread_mutex_t *)(a1 + 34392);
    pthread_mutex_lock(v6);
    if (*(void *)v2)
    {
      if (*(_DWORD *)(v2 + 68))
      {
        if (_CTServerConnectionUnregisterForNotification())
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              TPCleanupBaseband_cold_1();
            }
          }
        }
        else
        {
          *(_DWORD *)(v2 + 68) = 0;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            uint64_t v7 = VRTraceErrorLogLevelToCSTR();
            uint64_t v8 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              int v9 = 136315650;
              uint64_t v10 = v7;
              __int16 v11 = 2080;
              uint64_t v12 = "TPCleanupBaseband";
              __int16 v13 = 1024;
              int v14 = 874;
              _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Deregistered kCTRegistrationDataStatusChangedNotification.", (uint8_t *)&v9, 0x1Cu);
            }
          }
        }
      }
      CFRelease(*(CFTypeRef *)v2);
      *(void *)uint64_t v2 = 0;
    }
    return pthread_mutex_unlock(v6);
  }
  return result;
}

uint64_t TPSetPacketMultiplexMode(uint64_t a1, int a2)
{
  uint64_t v3 = CheckInHandleDebug();
  if (!v3) {
    return 2148466690;
  }
  *(_DWORD *)(v3 + 4) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPSetupOpenFaceTimeSecurity(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = CheckInHandleDebug();
  if (!v5) {
    return 2148466690;
  }
  uint64_t v6 = dtls(a2, a3, v5);
  CheckOutHandleDebug();
  return v6;
}

uint64_t dtls(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v6 = VRTraceErrorLogLevelToCSTR();
    uint64_t v7 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      uint64_t v36 = v6;
      __int16 v37 = 2080;
      int v38 = "dtls";
      __int16 v39 = 1024;
      int v40 = 512;
      __int16 v41 = 1024;
      int v42 = a1;
      _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d DTLS: entering (dwCallID == %08X)...", buf, 0x22u);
    }
  }
  uint64_t v8 = 2149777460;
  if (!a2) {
    goto LABEL_29;
  }
  int v9 = (pthread_rwlock_t *)(a3 + 1064);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a3 + 1064));
  uint64_t v10 = *(void *)(a3 + 1056);
  if (!v10)
  {
LABEL_28:
    pthread_rwlock_unlock(v9);
LABEL_29:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v18 = VRTraceErrorLogLevelToCSTR();
      uint64_t v19 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        uint64_t v36 = v18;
        __int16 v37 = 2080;
        int v38 = "dtls";
        __int16 v39 = 1024;
        int v40 = 620;
        __int16 v41 = 1024;
        int v42 = -2145189836;
        _os_log_impl(&dword_1E1EA4000, v19, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d DTLS: exiting (hResult == %08X)...", buf, 0x22u);
      }
    }
    return v8;
  }
  uint64_t v11 = a3 + 34528;
  uint64_t v12 = (void *)MEMORY[0x1E4F148B8];
  while (1)
  {
    IPPORTToStringWithSize();
    int v13 = *(_DWORD *)(v10 + 2072) & 1;
    if (v13 == (*(_DWORD *)(a2 + 28) & 1)) {
      break;
    }
LABEL_18:
    if (v13) {
      goto LABEL_21;
    }
    if (!*(_DWORD *)(v10 + 2092)) {
      goto LABEL_26;
    }
LABEL_27:
    uint64_t v10 = *(void *)(v10 + 2144);
    if (!v10) {
      goto LABEL_28;
    }
  }
  int v14 = (int *)(v10 + 2092);
  if (!v13)
  {
    int v15 = *v14;
    if (v15 != *(_DWORD *)(a2 + 48))
    {
      if (!v15) {
        goto LABEL_26;
      }
      goto LABEL_27;
    }
    goto LABEL_17;
  }
  if (*(void *)v14 == *(void *)(a2 + 48) && *(void *)(v10 + 2100) == *(void *)(a2 + 56))
  {
LABEL_17:
    if (*(unsigned __int16 *)(v10 + 2108) == *(unsigned __int16 *)(a2 + 64)) {
      goto LABEL_33;
    }
    goto LABEL_18;
  }
LABEL_21:
  if (*(void *)(v10 + 2092) != *v12 || *(void *)(v10 + 2100) != v12[1]) {
    goto LABEL_27;
  }
LABEL_26:
  if (*(unsigned __int16 *)(v10 + 2108) != *(unsigned __int16 *)(a2 + 64)) {
    goto LABEL_27;
  }
LABEL_33:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v21 = VRTraceErrorLogLevelToCSTR();
    uint64_t v22 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v23 = *(_DWORD *)(v10 + 2064);
      *(_DWORD *)buf = 136316162;
      uint64_t v36 = v21;
      __int16 v37 = 2080;
      int v38 = "dtls";
      __int16 v39 = 1024;
      int v40 = 528;
      __int16 v41 = 1024;
      int v42 = v23;
      __int16 v43 = 2080;
      uint64_t v44 = &dtls_ip;
      _os_log_impl(&dword_1E1EA4000, v22, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d DTLS:: (dwCallID == %08X) found clist local IP == %s", buf, 0x2Cu);
    }
  }
  IPPORTToStringWithSize();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v24 = VRTraceErrorLogLevelToCSTR();
    uint64_t v25 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v26 = *(_DWORD *)(v10 + 2120);
      *(_DWORD *)buf = 136316162;
      uint64_t v36 = v24;
      __int16 v37 = 2080;
      int v38 = "dtls";
      __int16 v39 = 1024;
      int v40 = 530;
      __int16 v41 = 1024;
      int v42 = v26;
      __int16 v43 = 2080;
      uint64_t v44 = &dtls_ip;
      _os_log_impl(&dword_1E1EA4000, v25, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d DTLS:: (dwRemoteCallID == %08X) dtls to remote == %s", buf, 0x2Cu);
    }
  }
  pthread_rwlock_unlock(v9);
  uint64_t v27 = (void *)(v10 + 2128);
  uint64_t v28 = *(void *)(v10 + 2128);
  if (!*(void *)v11)
  {
    if (v28 != 0xFFFFFFFFLL)
    {
      VTP_SetDTLS(*(_DWORD *)v10, 0xFFFFFFFFLL);
      if (*(void *)(v10 + 2136) != 0xFFFFFFFFLL)
      {
        ARPLSessionRelease();
        *(void *)(v10 + 2136) = 0xFFFFFFFFLL;
      }
      DTLS_Cleanup(*v27);
      void *v27 = 0xFFFFFFFFLL;
    }
    goto LABEL_29;
  }
  if (v28 != 0xFFFFFFFFLL)
  {
    VTP_SetDTLS(*(_DWORD *)v10, 0xFFFFFFFFLL);
    if (*(void *)(v10 + 2136) != 0xFFFFFFFFLL)
    {
      ARPLSessionRelease();
      *(void *)(v10 + 2136) = 0xFFFFFFFFLL;
    }
    DTLS_Cleanup(*v27);
    void *v27 = 0xFFFFFFFFLL;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v29 = VRTraceErrorLogLevelToCSTR();
    int v30 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      uint64_t v36 = v29;
      __int16 v37 = 2080;
      int v38 = "dtls";
      __int16 v39 = 1024;
      int v40 = 553;
      _os_log_impl(&dword_1E1EA4000, v30, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d DTLS: initialize and perform handshake...", buf, 0x1Cu);
    }
  }
  uint64_t v8 = DTLS_Create((uint64_t *)(v10 + 2128), *(_DWORD *)v10, *(_DWORD *)(v11 + 8) == 1, a1, *(_DWORD *)(v10 + 2120), *(const void **)v11, (const void *)a2);
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if ((v8 & 0x80000000) == 0)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      uint64_t v32 = VRTraceErrorLogLevelToCSTR();
      __int16 v33 = *MEMORY[0x1E4F47A50];
      uint64_t v34 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          uint64_t v36 = v32;
          __int16 v37 = 2080;
          int v38 = "dtls";
          __int16 v39 = 1024;
          int v40 = 564;
          __int16 v41 = 1024;
          int v42 = a1;
          _os_log_impl(&dword_1E1EA4000, v33, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d dtls: ARPLSessionCreate(p2pID == %08X) ...", buf, 0x22u);
        }
      }
      else if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
      {
        dtls_cold_4();
      }
    }
    ARPLSessionCreate();
  }
  if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      dtls_cold_1();
    }
  }
  DTLS_Cleanup(*v27);
  void *v27 = 0xFFFFFFFFLL;
  return v8;
}

uint64_t TPGetLoopbackIP(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = 2148466689;
  uint64_t v4 = CheckInHandleDebug();
  if (v4)
  {
    uint64_t v5 = v4;
    unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v25 = v6;
    long long v26 = v6;
    MakeIPPORT();
    if (a2)
    {
      unsigned int LocalIFIndexForDstIPPort = GetLocalIFIndexForDstIPPort();
      if_indextoname(LocalIFIndexForDstIPPort, (char *)(a2 + 4));
      uint64_t v8 = (pthread_rwlock_t *)(v5 + 1064);
      pthread_rwlock_rdlock((pthread_rwlock_t *)(v5 + 1064));
      uint64_t v9 = *(void *)(v5 + 1056);
      if (v9)
      {
        while (((*(_DWORD *)(v9 + 2072) ^ v25) & 1) != 0
             || strcmp((const char *)(v9 + 2076), (const char *)(a2 + 4)))
        {
          uint64_t v9 = *(void *)(v9 + 2144);
          if (!v9) {
            goto LABEL_7;
          }
        }
        long long v12 = *(_OWORD *)(v9 + 2072);
        long long v13 = *(_OWORD *)(v9 + 2088);
        *(void *)(a2 + 32) = *(void *)(v9 + 2104);
        *(_OWORD *)a2 = v12;
        *(_OWORD *)(a2 + 16) = v13;
        pthread_rwlock_unlock(v8);
        IPPORTToStringWithSize();
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v14 = VRTraceErrorLogLevelToCSTR();
          int v15 = *MEMORY[0x1E4F47A50];
          uint64_t v3 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
LABEL_16:
            CheckOutHandleDebug();
            return v3;
          }
          int v17 = 136315906;
          uint64_t v18 = v14;
          __int16 v19 = 2080;
          int v20 = "TPGetLoopbackIP";
          __int16 v21 = 1024;
          int v22 = 2487;
          __int16 v23 = 2080;
          uint64_t v24 = &TPGetLoopbackIP_ip;
          _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPGetLoopbackIP:: found loopbackIP = %s", (uint8_t *)&v17, 0x26u);
        }
        uint64_t v3 = 0;
        goto LABEL_16;
      }
LABEL_7:
      pthread_rwlock_unlock(v8);
      uint64_t v3 = 2148466710;
    }
    IPPORTToStringWithSize();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v10 = VRTraceErrorLogLevelToCSTR();
      uint64_t v11 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v17 = 136315906;
        uint64_t v18 = v10;
        __int16 v19 = 2080;
        int v20 = "TPGetLoopbackIP";
        __int16 v21 = 1024;
        int v22 = 2491;
        __int16 v23 = 2080;
        uint64_t v24 = &TPGetLoopbackIP_ip_5;
        _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPGetLoopbackIP:: error loopbackIP = %s", (uint8_t *)&v17, 0x26u);
      }
    }
    goto LABEL_16;
  }
  return 2148466690;
}

uint64_t TPListenVirtualInterface(void *a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = 2148466691;
  uint64_t v3 = CheckInHandleDebug();
  if (v3)
  {
    uint64_t v4 = v3;
    if (*(_DWORD *)v3)
    {
      uint64_t v2 = 2148466704;
LABEL_24:
      CheckOutHandleDebug();
      return v2;
    }
    uint64_t v5 = (pthread_rwlock_t *)(v3 + 1064);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 1064));
    BOOL v6 = TransportMapPacketMultiplexModeToVTPMode(*(unsigned int *)(v4 + 4));
    uint64_t v7 = (int *)malloc_type_calloc(1uLL, 0x868uLL, 0x10200406FE3F67FuLL);
    if (v7)
    {
      uint64_t v8 = v7;
      *((unsigned char *)v7 + 4) = 1;
      *((void *)v7 + 258) = 0;
      *((void *)v7 + 266) = 0xFFFFFFFFLL;
      *((void *)v7 + 267) = 0xFFFFFFFFLL;
      int v9 = VTP_SocketForIDS();
      *uint64_t v8 = v9;
      if (v9 != -1)
      {
        VTP_SetSocketMode(v9, v6);
        VTP_SetPktType(*v8, 48142);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
        {
          uint64_t v10 = VRTraceErrorLogLevelToCSTR();
          uint64_t v11 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            int v12 = *v8;
            int v17 = 136315906;
            uint64_t v18 = v10;
            __int16 v19 = 2080;
            int v20 = "CreateSocketForIDS";
            __int16 v21 = 1024;
            int v22 = 2289;
            __int16 v23 = 1024;
            int v24 = v12;
            _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Start listening on IDS interface vfd %d", (uint8_t *)&v17, 0x22u);
          }
        }
        v8[2] = 2048;
        long long v13 = (int **)(v4 + 1056);
        do
        {
          uint64_t v14 = v13;
          int v15 = *v13;
          long long v13 = (int **)(*v13 + 536);
        }
        while (v15);
        *uint64_t v14 = v8;
        pthread_rwlock_unlock((pthread_rwlock_t *)(v4 + 1064));
        uint64_t v2 = TPEnsureRecvProcStarted(a1, v4);
        goto LABEL_24;
      }
      uint64_t v2 = *__error() | 0xC00F0000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          TPListenVirtualInterface_cold_3();
        }
      }
      free(v8);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        TPListenVirtualInterface_cold_2();
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        TPListenVirtualInterface_cold_1();
      }
    }
    pthread_rwlock_unlock(v5);
    goto LABEL_24;
  }
  return 2148466690;
}

uint64_t TPListenOnPhysicalInterface(uint64_t a1, _WORD *a2, int a3, uint64_t a4, const unsigned __int8 *a5)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = 2148466710;
  uint64_t v11 = CheckInHandleDebug();
  if (v11)
  {
    uint64_t v12 = v11;
    if (*(_DWORD *)v11)
    {
      uint64_t v10 = 2148466704;
LABEL_50:
      CheckOutHandleDebug();
      return v10;
    }
    v51 = (int *)0xAAAAAAAAAAAAAAAALL;
    v52 = 0;
    uint64_t v63 = 0;
    uint64_t v64 = 0;
    *(_WORD *)(v11 + 20) = *a2;
    *(_DWORD *)(v11 + 16) = 10;
    TPSetupCTContext(a1, v11, a3);
    if (*(_DWORD *)(v12 + 34384))
    {
      int LocalInterfaceListWithOptionsAndCellInterfaceName = 1;
      v52 = (char *)malloc_type_calloc(1uLL, 0x28uLL, 0x100004053E81896uLL);
      MakeIPPORT();
      unsigned int LocalIFIndexForDstIPPort = GetLocalIFIndexForDstIPPort();
      if_indextoname(LocalIFIndexForDstIPPort, v52 + 4);
    }
    else
    {
      int LocalInterfaceListWithOptionsAndCellInterfaceName = GetLocalInterfaceListWithOptionsAndCellInterfaceName();
      if (!LocalInterfaceListWithOptionsAndCellInterfaceName)
      {
        FreeLocalInterfaceList();
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            TPListenOnPhysicalInterface_cold_1();
          }
        }
        goto LABEL_50;
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v15 = VRTraceErrorLogLevelToCSTR();
      long long v16 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        uint64_t v54 = v15;
        __int16 v55 = 2080;
        timespec v56 = "ListenUDP";
        __int16 v57 = 1024;
        int v58 = 2664;
        __int16 v59 = 1024;
        int v60 = LocalInterfaceListWithOptionsAndCellInterfaceName;
        _os_log_impl(&dword_1E1EA4000, v16, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d %d interfaces found.", buf, 0x22u);
      }
    }
    uint64_t v47 = (pthread_rwlock_t *)(v12 + 1064);
    long long v48 = (void *)a1;
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v12 + 1064));
    if (LocalInterfaceListWithOptionsAndCellInterfaceName < 1)
    {
      int v50 = 0;
LABEL_44:
      pthread_rwlock_unlock(v47);
      FreeLocalInterfaceList();
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v39 = VRTraceErrorLogLevelToCSTR();
        int v40 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          BOOL v41 = *(void *)(v12 + 1056) == 0;
          *(_DWORD *)buf = 136316162;
          uint64_t v54 = v39;
          __int16 v55 = 2080;
          timespec v56 = "ListenUDP";
          __int16 v57 = 1024;
          int v58 = 2727;
          __int16 v59 = 1024;
          int v60 = v50;
          __int16 v61 = 1024;
          BOOL v62 = v41;
          _os_log_impl(&dword_1E1EA4000, v40, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d %d valid interfaces found. (pTP->pCList == NULL) = %d", buf, 0x28u);
        }
      }
      uint64_t v10 = 2148466710;
      if (*(void *)(v12 + 1056))
      {
        uint64_t v42 = TPEnsureRecvProcStarted(v48, v12);
        if ((v42 & 0x80000000) != 0)
        {
          uint64_t v10 = v42;
          FreeLocalInterfaceList();
          pthread_rwlock_wrlock(v47);
          uint64_t v44 = *(void *)(v12 + 1056);
          if (v44)
          {
            do
            {
              VTP_Close(*(_DWORD *)v44);
              uint64_t v45 = *(void *)(v44 + 2144);
              uint64_t v46 = *(void *)(v44 + 2128);
              if (v46 != 0xFFFFFFFFLL)
              {
                if (*(void *)(v44 + 2136) != 0xFFFFFFFFLL)
                {
                  ARPLSessionRelease();
                  *(void *)(v44 + 2136) = 0xFFFFFFFFLL;
                  uint64_t v46 = *(void *)(v44 + 2128);
                }
                DTLS_Cleanup(v46);
              }
              free((void *)v44);
              uint64_t v44 = v45;
            }
            while (v45);
          }
          pthread_rwlock_unlock(v47);
        }
        else
        {
          uint64_t v10 = 0;
        }
      }
      goto LABEL_50;
    }
    uint64_t v17 = 0;
    int v50 = 0;
    uint64_t v18 = (uint64_t *)(v12 + 1056);
    while (1)
    {
      int v19 = (unsigned __int16)*a2;
      int v20 = v52;
      __int16 v21 = &v52[40 * v17];
      *((_WORD *)v21 + 18) = v19;
      uint64_t v22 = *v18;
      if (*v18) {
        break;
      }
LABEL_26:
      BOOL v26 = TransportMapPacketMultiplexModeToVTPMode(*(unsigned int *)(v12 + 4));
      if ((CreateSocketAndBind((long long *)v21, &v51, 0, a5, v26) & 0x80000000) == 0)
      {
        unint64_t v27 = a5;
        uint64_t v28 = v51;
        *a2 = *((_WORD *)v51 + 1054);
        if (a4)
        {
          long long v29 = *(_OWORD *)(v28 + 518);
          long long v30 = *(_OWORD *)(v28 + 522);
          *(void *)(a4 + 32) = *((void *)v28 + 263);
          *(_OWORD *)a4 = v29;
          *(_OWORD *)(a4 + 16) = v30;
        }
        VCTestMonitorManager_GetEnableLoopbackInterface();
        int v31 = ICESetEnableLoopbackInterface();
        if (v31 < 0)
        {
          BOOL v32 = v31;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            uint64_t v49 = VRTraceErrorLogLevelToCSTR();
            __int16 v33 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316162;
              uint64_t v54 = v49;
              __int16 v55 = 2080;
              timespec v56 = "ListenUDP";
              __int16 v57 = 1024;
              int v58 = 2690;
              __int16 v59 = 1024;
              int v60 = 2690;
              __int16 v61 = 1024;
              BOOL v62 = v32;
              _os_log_error_impl(&dword_1E1EA4000, v33, OS_LOG_TYPE_ERROR, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transport.c:%d: ICESetEnableLoopbackInterface failed(%08X)", buf, 0x28u);
            }
          }
        }
        int v34 = ICEAddOneInterface();
        __int16 v35 = (int **)(v12 + 1056);
        if (v34 < 0)
        {
          VTP_Close(*v28);
          uint64_t v38 = *((void *)v28 + 266);
          a5 = v27;
          if (v38 != 0xFFFFFFFFLL)
          {
            if (*((void *)v28 + 267) != 0xFFFFFFFFLL)
            {
              ARPLSessionRelease();
              *((void *)v28 + 267) = 0xFFFFFFFFLL;
              uint64_t v38 = *((void *)v28 + 266);
            }
            DTLS_Cleanup(v38);
          }
          free(v28);
        }
        else
        {
          do
          {
            uint64_t v36 = v35;
            __int16 v37 = *v35;
            __int16 v35 = (int **)(*v35 + 536);
          }
          while (v37);
          NSObject *v36 = v28;
          ++v50;
          a5 = v27;
        }
      }
LABEL_41:
      if (++v17 == LocalInterfaceListWithOptionsAndCellInterfaceName) {
        goto LABEL_44;
      }
    }
    int v23 = *(_DWORD *)v21 & 1;
    int v24 = &v20[40 * v17 + 20];
    while (1)
    {
      if (v23 == (*(_DWORD *)(v22 + 2072) & 1))
      {
        if (v23)
        {
          if (*(void *)v24 == *(void *)(v22 + 2092) && *((void *)v24 + 1) == *(void *)(v22 + 2100))
          {
LABEL_24:
            if (v19 == *(unsigned __int16 *)(v22 + 2108)) {
              goto LABEL_41;
            }
          }
        }
        else if (*(_DWORD *)v24 == *(_DWORD *)(v22 + 2092))
        {
          goto LABEL_24;
        }
      }
      uint64_t v22 = *(void *)(v22 + 2144);
      if (!v22) {
        goto LABEL_26;
      }
    }
  }
  return 2148466690;
}

uint64_t TPStopListen(uint64_t a1, int a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = CheckInHandleDebug();
  if (!v3) {
    return 2148466690;
  }
  uint64_t v4 = v3;
  *(void *)&v38[14] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v37 = v5;
  *(_OWORD *)uint64_t v38 = v5;
  long long v36 = v5;
  BOOL v6 = (pthread_rwlock_t *)(v3 + 1064);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 1064));
  uint64_t v7 = *(void *)(v4 + 1056);
  if (!v7)
  {
    uint64_t v10 = 0;
    goto LABEL_35;
  }
  uint64_t v8 = 0;
  int v9 = "SIP";
  uint64_t v10 = *(void *)(v4 + 1056);
  do
  {
    uint64_t v11 = v7;
    while (!a2)
    {
      if (!*(unsigned char *)(v11 + 4))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v12 = VRTraceErrorLogLevelToCSTR();
          long long v13 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v14 = IPPORTToStringWithSize();
            int v15 = *(_DWORD *)v11;
            *(_DWORD *)buf = 136316418;
            uint64_t v25 = v12;
            __int16 v26 = 2080;
            unint64_t v27 = "TPStopListen";
            __int16 v28 = 1024;
            int v29 = 2859;
            __int16 v30 = 2080;
            uint64_t v31 = v14;
            __int16 v32 = 2080;
            uint64_t v33 = v11 + 2076;
            __int16 v34 = 1024;
            int v35 = v15;
            _os_log_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Stop listening on %s(%s) vfd %d", buf, 0x36u);
          }
        }
        ICERemoveOneInterface();
        if (!*(_DWORD *)(v11 + 2068)) {
          VTP_Close(*(_DWORD *)v11);
        }
        uint64_t v16 = *(void *)(v11 + 2128);
        if (v16 != 0xFFFFFFFFLL)
        {
          if (*(void *)(v11 + 2136) != 0xFFFFFFFFLL)
          {
            ARPLSessionRelease();
            *(void *)(v11 + 2136) = 0xFFFFFFFFLL;
            uint64_t v16 = *(void *)(v11 + 2128);
          }
          DTLS_Cleanup(v16);
        }
        uint64_t v7 = *(void *)(v11 + 2144);
        int v9 = "SIP";
        if (v8) {
          goto LABEL_21;
        }
        goto LABEL_22;
      }
LABEL_9:
      uint64_t v8 = v11;
      uint64_t v11 = *(void *)(v11 + 2144);
      if (!v11) {
        goto LABEL_35;
      }
    }
    if (!*(unsigned char *)(v11 + 4)) {
      goto LABEL_9;
    }
    uint64_t v17 = v9;
    int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (ErrorLogLevelForModule >= 7)
    {
      uint64_t v19 = VRTraceErrorLogLevelToCSTR();
      int v20 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v21 = *(_DWORD *)v11;
        *(_DWORD *)buf = 136315906;
        uint64_t v25 = v19;
        __int16 v26 = 2080;
        unint64_t v27 = "TPStopListen";
        __int16 v28 = 1024;
        int v29 = 2829;
        __int16 v30 = 1024;
        LODWORD(v31) = v21;
        _os_log_impl(&dword_1E1EA4000, v20, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Stop listening on IDS interface vfd %d", buf, 0x22u);
      }
    }
    if (!*(_DWORD *)(v11 + 2068)) {
      VTP_Close(*(_DWORD *)v11);
    }
    uint64_t v7 = *(void *)(v11 + 2144);
    int v9 = v17;
    if (v8) {
LABEL_21:
    }
      *(void *)(v8 + 2144) = v7;
LABEL_22:
    if (v11 == v10) {
      uint64_t v10 = v7;
    }
    free((void *)v11);
  }
  while (v7);
LABEL_35:
  *(void *)(v4 + 1056) = v10;
  int v23 = *(_DWORD *)(v4 + 12);
  if (v23 != -1) {
    VTP_Close(v23);
  }
  *(_DWORD *)(v4 + 12) = -1;
  pthread_rwlock_unlock(v6);
  if ((a2 & 1) == 0) {
    TPCleanupBaseband(v4);
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPSend(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = 2148466728;
  if (!v1) {
    return 2148466689;
  }
  uint64_t v3 = v1;
  uint64_t v4 = (_DWORD *)CheckInHandleDebug();
  if (v4)
  {
    uint64_t v5 = (uint64_t)v4;
    if (*v4)
    {
      uint64_t v2 = 2148466704;
LABEL_101:
      CheckOutHandleDebug();
      return v2;
    }
    BOOL v6 = (void *)(v3 + 716);
    *(void *)&v76[14] = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v75[129] = v7;
    *(_OWORD *)v76 = v7;
    v75[128] = v7;
    memset(v75, 170, 0x800uLL);
    memset(__b, 170, sizeof(__b));
    int v52 = 2048;
    uint64_t v8 = (long long *)(v3 + 696);
    if ((*(_DWORD *)(v3 + 696) & 1) == (*(_DWORD *)(v3 + 816) & 1))
    {
      if (*(_DWORD *)(v3 + 696))
      {
        BOOL v9 = *v6 == *(void *)(v3 + 836) && *(void *)(v3 + 724) == *(void *)(v3 + 844);
        if (!v9) {
          goto LABEL_18;
        }
      }
      else if (*(_DWORD *)(v3 + 716) != *(_DWORD *)(v3 + 836))
      {
        goto LABEL_18;
      }
      if (*(unsigned __int16 *)(v3 + 732) == *(unsigned __int16 *)(v3 + 852) && !*(unsigned char *)(v5 + 34648))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v25 = VRTraceErrorLogLevelToCSTR();
          __int16 v26 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            *(void *)&uint8_t buf[4] = v25;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "SendUDP";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 3071;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = IPPORTToStringWithSize();
            _os_log_impl(&dword_1E1EA4000, v26, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Same Local and Destination IP:Port(%s)", buf, 0x26u);
          }
        }
        goto LABEL_101;
      }
    }
LABEL_18:
    if (!*(void *)(v3 + 552))
    {
      uint64_t v14 = ConstructSipMsg((char *)v75, 0x800uLL, v3);
      if ((v14 & 0x80000000) != 0)
      {
        uint64_t v2 = v14;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            TPSend_cold_1();
          }
        }
        goto LABEL_101;
      }
      ReplaceKeyword((const char *)v75, 2048, "%CLENGTH%", "0", 2);
      int v52 = strlen((const char *)v75);
      goto LABEL_95;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v10 = VRTraceErrorLogLevelToCSTR();
      uint64_t v11 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v12 = *(_DWORD *)(v3 + 564);
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = v10;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "SendUDP";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = 3076;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v12;
        _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d()()()()() SIP BODY IS BINARY? (%d)", buf, 0x22u);
      }
    }
    if (*(_DWORD *)(v3 + 564))
    {
      uint64_t v13 = CompressMsg((uint64_t)__b);
      if ((v13 & 0x80000000) != 0)
      {
        uint64_t v2 = v13;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            TPSend_cold_4();
          }
        }
        goto LABEL_101;
      }
LABEL_95:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v43 = VRTraceErrorLogLevelToCSTR();
        uint64_t v44 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v45 = IPPORTToStringWithSize();
          BOOL v9 = *(void *)(v3 + 552) == 0;
          uint64_t v46 = __b;
          *(_DWORD *)buf = 136316162;
          if (v9) {
            uint64_t v46 = v75;
          }
          *(void *)&uint8_t buf[4] = v43;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "SendUDP";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 3197;
          *(_WORD *)&buf[28] = 2080;
          *(void *)&buf[30] = v45;
          *(_WORD *)&buf[38] = 2080;
          *(void *)&buf[40] = v46;
          _os_log_impl(&dword_1E1EA4000, v44, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Send to %s [%s]", buf, 0x30u);
        }
      }
      memset(buf, 0, 328);
      long long v47 = *(_OWORD *)(v3 + 656);
      *(_OWORD *)&buf[88] = *(_OWORD *)(v3 + 640);
      *(_OWORD *)&buf[104] = v47;
      *(_OWORD *)&buf[120] = *(_OWORD *)(v3 + 672);
      long long v48 = *(_OWORD *)(v3 + 592);
      *(_OWORD *)&unsigned char buf[24] = *(_OWORD *)(v3 + 576);
      *(_OWORD *)&buf[40] = v48;
      long long v49 = *(_OWORD *)(v3 + 624);
      *(_OWORD *)&buf[56] = *(_OWORD *)(v3 + 608);
      *(_DWORD *)&buf[8] = *(_DWORD *)(v3 + 572);
      *(void *)&buf[136] = *(void *)(v3 + 688);
      *(_OWORD *)&buf[72] = v49;
      buf[169] = 1;
      uint64_t v2 = VTP_Send(-1, v75, v52, 0, (uint64_t)buf);
      goto LABEL_101;
    }
    int v15 = *(_DWORD *)(v3 + 4);
    if (v15 == 2)
    {
      if (*(_DWORD *)(v3 + 8) != 6 || *(int *)(v3 + 560) < 1)
      {
LABEL_50:
        uint64_t v24 = CompressMsg((uint64_t)__b);
        if ((v24 & 0x80000000) != 0)
        {
          uint64_t v2 = v24;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              TPSend_cold_2();
            }
          }
          goto LABEL_101;
        }
        goto LABEL_95;
      }
    }
    else if (v15 != 1 || *(_DWORD *)(v3 + 8) != 1)
    {
      goto LABEL_50;
    }
    unint64_t v73 = 0xAAAAAAAAAAAAAAAALL;
    memset(buf, 170, 0xA8CuLL);
    memset(v71, 0, sizeof(v71));
    __strlcpy_chk();
    long long v68 = 0u;
    long long v69 = 0u;
    memset(v70, 0, sizeof(v70));
    long long v66 = 0u;
    memset(v67, 0, sizeof(v67));
    long long v65 = 0u;
    long long v63 = 0u;
    memset(v64, 0, sizeof(v64));
    long long v62 = 0u;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v16 = VRTraceErrorLogLevelToCSTR();
      uint64_t v17 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v53 = 136316162;
        uint64_t v54 = v16;
        __int16 v55 = 2080;
        timespec v56 = "SendUDP";
        __int16 v57 = 1024;
        int v58 = 3102;
        __int16 v59 = 2080;
        *(void *)int v60 = IPPORTToStringWithSize();
        *(_WORD *)&v60[8] = 2080;
        uint64_t v61 = IPPORTToStringWithSize();
        _os_log_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d RTP using %s and %s as hints", v53, 0x30u);
      }
    }
    RTPCreateSockets(*(void *)(v3 + 976), v3 + 696, (int *)(v3 + 776), (int *)&v73, (int *)v71);
    if (v18 < 0)
    {
      long long v19 = *(_OWORD *)(v3 + 712);
      v71[0] = *v8;
      v71[1] = v19;
      *(void *)&v71[2] = *(void *)(v3 + 728);
    }
    v51 = (_DWORD *)(v3 + 776);
    RTPCreateSockets(*(void *)(v3 + 984), v3 + 696, (int *)(v3 + 776), (int *)&v73 + 1, (int *)&v71[2] + 2);
    if (v20 < 0)
    {
      long long v21 = *(_OWORD *)(v3 + 712);
      *(long long *)((char *)&v71[2] + 8) = *v8;
      *(long long *)((char *)&v71[3] + 8) = v21;
      *((void *)&v71[4] + 1) = *(void *)(v3 + 728);
    }
    int v22 = *(_DWORD *)v8 & 1;
    if (v22 == (v71[0] & 1))
    {
      if (v22)
      {
        if (*v6 != *(void *)((char *)&v71[1] + 4) || *(void *)(v3 + 724) != *(void *)((char *)&v71[1] + 12))
        {
          if (v22 != (*v51 & 1)) {
            goto LABEL_78;
          }
          goto LABEL_70;
        }
      }
      else
      {
        int v23 = *(_DWORD *)v6;
        if (*(_DWORD *)v6 != DWORD1(v71[1]))
        {
          if (*(unsigned char *)v51)
          {
LABEL_78:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              uint64_t v31 = VRTraceErrorLogLevelToCSTR();
              __int16 v32 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                int v33 = *(unsigned __int16 *)(v3 + 732);
                *(_DWORD *)uint64_t v53 = 136316162;
                uint64_t v54 = v31;
                __int16 v55 = 2080;
                timespec v56 = "SendUDP";
                __int16 v57 = 1024;
                int v58 = 3130;
                __int16 v59 = 1024;
                *(_DWORD *)int v60 = v33;
                *(_WORD *)&v60[4] = 1024;
                *(_DWORD *)&v60[6] = WORD2(v71[2]);
                _os_log_impl(&dword_1E1EA4000, v32, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Overriding Video RTCP port from %u to %u", v53, 0x28u);
              }
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              uint64_t v34 = VRTraceErrorLogLevelToCSTR();
              int v35 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                int v36 = *(unsigned __int16 *)(v3 + 732);
                *(_DWORD *)uint64_t v53 = 136316162;
                uint64_t v54 = v34;
                __int16 v55 = 2080;
                timespec v56 = "SendUDP";
                __int16 v57 = 1024;
                int v58 = 3132;
                __int16 v59 = 1024;
                *(_DWORD *)int v60 = v36;
                *(_WORD *)&v60[4] = 1024;
                *(_DWORD *)&v60[6] = WORD6(v71[4]);
                _os_log_impl(&dword_1E1EA4000, v35, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Overriding Video RTCP port from %u to %u", v53, 0x28u);
              }
            }
            AddToCListRTP(v5, *(_DWORD *)(v3 + 572), v73, v71, 2);
            AddToCListRTP(v5, *(_DWORD *)(v3 + 572), SHIDWORD(v73), (long long *)((char *)&v71[2] + 8), 4);
            VTP_AddPktType(v73, 4);
            VTP_AddPktType(SHIDWORD(v73), 4);
            ICEGetExtIPPorts();
            VTP_RemovePktType(v73, 4);
            VTP_RemovePktType(SHIDWORD(v73), 4);
            int v37 = *(_DWORD *)(v3 + 572);
            pthread_rwlock_wrlock((pthread_rwlock_t *)(v5 + 1272));
            uint64_t v38 = *(void *)(v5 + 1264);
            if (v38)
            {
              uint64_t v39 = (uint64_t *)(v5 + 1264);
              do
              {
                if (*(_DWORD *)(v38 + 2064) == v37)
                {
                  uint64_t *v39 = *(void *)(v38 + 2144);
                  ICERemoveOneInterface();
                  free((void *)v38);
                }
                else
                {
                  uint64_t v39 = (uint64_t *)(v38 + 2144);
                }
                uint64_t v38 = *v39;
              }
              while (*v39);
            }
            pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1272));
            pthread_rwlock_wrlock((pthread_rwlock_t *)(v5 + 1064));
            int v40 = *(_DWORD *)(v5 + 12);
            *(_DWORD *)(v5 + 12) = -1;
            VTP_Close(v40);
            pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1064));
LABEL_91:
            IPToString();
            if (*(_DWORD *)(v3 + 776)) {
              int v41 = 3559497;
            }
            else {
              int v41 = 3428425;
            }
            *(_DWORD *)(v3 + 944) = v41;
            __sprintf_chk((char *)(v3 + 948), 0, 6uLL, "%d", *(unsigned __int16 *)(v3 + 812));
            __sprintf_chk((char *)(v3 + 960), 0, 6uLL, "%d", *(unsigned __int16 *)(v3 + 812));
            __sprintf_chk((char *)(v3 + 954), 0, 6uLL, "%d", WORD2(v70[0]));
            __sprintf_chk((char *)(v3 + 966), 0, 6uLL, "%d", WORD2(v70[5]));
            ReplaceKeyword((const char *)buf, 2700, "%RTP-IP-AF%", (const char *)(v3 + 944), 4);
            ReplaceKeyword((const char *)buf, 2700, "%RTP-IP%", (const char *)(v3 + 896), 48);
            ReplaceKeyword((const char *)buf, 2700, "%VRTP-PORT%", (const char *)(v3 + 948), 6);
            ReplaceKeyword((const char *)buf, 2700, "%VRTCP-PORT%", (const char *)(v3 + 954), 6);
            ReplaceKeyword((const char *)buf, 2700, "%ARTP-PORT%", (const char *)(v3 + 960), 6);
            ReplaceKeyword((const char *)buf, 2700, "%ARTCP-PORT%", (const char *)(v3 + 966), 6);
            strlen((const char *)buf);
            uint64_t v42 = CompressMsg((uint64_t)__b);
            if ((v42 & 0x80000000) != 0)
            {
              uint64_t v2 = v42;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  TPSend_cold_3();
                }
              }
              goto LABEL_101;
            }
            goto LABEL_95;
          }
          goto LABEL_68;
        }
      }
      if (*(unsigned __int16 *)(v3 + 732) == WORD2(v71[2]))
      {
        long long v28 = *(_OWORD *)(v3 + 792);
        long long v68 = *(_OWORD *)v51;
        long long v69 = v28;
        uint64_t v29 = *(void *)(v3 + 808);
        v70[0] = v29;
        *(_OWORD *)&v70[1] = v68;
        *(_OWORD *)&v70[3] = v28;
        goto LABEL_77;
      }
    }
    if (v22 != (*v51 & 1)) {
      goto LABEL_78;
    }
    if (!v22)
    {
      int v23 = *(_DWORD *)(v3 + 716);
LABEL_68:
      if (v23 != *(_DWORD *)(v3 + 796)) {
        goto LABEL_78;
      }
      goto LABEL_75;
    }
LABEL_70:
    if (*v6 != *(void *)(v3 + 796) || *(void *)(v3 + 724) != *(void *)(v3 + 804)) {
      goto LABEL_78;
    }
LABEL_75:
    if (*(unsigned __int16 *)(v3 + 732) != *(unsigned __int16 *)(v3 + 812)) {
      goto LABEL_78;
    }
    long long v68 = v71[0];
    long long v69 = v71[1];
    v70[0] = *(void *)&v71[2];
    *(_OWORD *)&v70[1] = *(long long *)((char *)&v71[2] + 8);
    *(_OWORD *)&v70[3] = *(long long *)((char *)&v71[3] + 8);
    uint64_t v29 = *((void *)&v71[4] + 1);
LABEL_77:
    v70[5] = v29;
    goto LABEL_91;
  }
  return 2148466690;
}

uint64_t partial apply(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = 2148466689;
  if (a3 && *(_DWORD *)(a3 + 4) == 1)
  {
    uint64_t v7 = *(void *)(a3 + 504);
    if (v7)
    {
      uint64_t v11 = CheckInHandleDebug();
      if (v11)
      {
        uint64_t v12 = v11;
        uint64_t v13 = malloc_type_calloc(1uLL, 0x90uLL, 0x10A00402FEC5419uLL);
        if (v13)
        {
          uint64_t v14 = v13;
          *uint64_t v13 = a2;
          __strlcpy_chk();
          v14[17] = *(_DWORD *)(a3 + 8);
          if (a2 == 1)
          {
            __strlcpy_chk();
            *((_WORD *)v14 + 56) = *(_WORD *)(v7 + 52);
          }
          *((void *)v14 + 15) = a4;
          *((void *)v14 + 16) = a5;
          pthread_mutex_lock((pthread_mutex_t *)(v12 + 1480));
          *((void *)v14 + 17) = *(void *)(v12 + 1472);
          *(void *)(v12 + 1472) = v14;
          pthread_mutex_unlock((pthread_mutex_t *)(v12 + 1480));
          CheckOutHandleDebug();
          return 0;
        }
        else
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              TPAddTransaction_cold_2();
            }
          }
          CheckOutHandleDebug();
          return 2148466691;
        }
      }
      else
      {
        return 2148466690;
      }
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          TPAddTransaction_cold_1();
        }
      }
      return 2148466709;
    }
  }
  return result;
}

uint64_t TPRemoveTransaction(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = CheckInHandleDebug();
  if (!v3) {
    return 2148466690;
  }
  uint64_t v4 = v3;
  uint64_t v5 = (pthread_mutex_t *)(v3 + 1480);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 1480));
  BOOL v6 = *(void **)(v4 + 1472);
  if (v6)
  {
    if (v6[16] == a2)
    {
      uint64_t v8 = (void *)(v4 + 1472);
LABEL_9:
      *uint64_t v8 = v6[17];
      free(v6);
    }
    else
    {
      while (1)
      {
        uint64_t v7 = v6;
        BOOL v6 = (void *)v6[17];
        if (!v6) {
          break;
        }
        if (v6[16] == a2)
        {
          uint64_t v8 = v7 + 17;
          goto LABEL_9;
        }
      }
    }
  }
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPGetType(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = 2148466689;
  if (a2)
  {
    uint64_t v4 = (_DWORD *)CheckInHandleDebug();
    if (v4)
    {
      *a2 = *v4;
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2148466690;
    }
  }
  return v2;
}

uint64_t TPStopHeartbeat(uint64_t a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = CheckInHandleDebug();
  if (!v3) {
    return 2148466690;
  }
  uint64_t v4 = v3;
  *(void *)&v24[14] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v23 = v5;
  *(_OWORD *)uint64_t v24 = v5;
  long long v22 = v5;
  BOOL v6 = (pthread_mutex_t *)(v3 + 992);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 992));
  uint64_t v7 = 0;
  int v8 = *(_DWORD *)a2 & 1;
  while (1)
  {
    uint64_t v9 = v4 + v7;
    if ((*(_DWORD *)(v4 + v7 + 80) & 1) != v8) {
      goto LABEL_14;
    }
    if (v8) {
      break;
    }
    if (*(_DWORD *)(v9 + 100) == *(_DWORD *)(a2 + 20)) {
      goto LABEL_12;
    }
LABEL_14:
    v7 += 96;
    if (v7 == 960) {
      goto LABEL_15;
    }
  }
  if (*(void *)(v9 + 100) != *(void *)(a2 + 20) || *(void *)(v9 + 108) != *(void *)(a2 + 28)) {
    goto LABEL_14;
  }
LABEL_12:
  if (*(unsigned __int16 *)(v4 + v7 + 116) != *(unsigned __int16 *)(a2 + 36) || !*(_DWORD *)(v9 + 32)) {
    goto LABEL_14;
  }
  *(_DWORD *)(v4 + v7 + 32) = 0;
LABEL_15:
  pthread_mutex_unlock(v6);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v11 = VRTraceErrorLogLevelToCSTR();
    uint64_t v12 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v14 = 136315906;
      uint64_t v15 = v11;
      __int16 v16 = 2080;
      uint64_t v17 = "TPStopHeartbeat";
      __int16 v18 = 1024;
      int v19 = 3354;
      __int16 v20 = 2080;
      uint64_t v21 = IPPORTToStringWithSize();
      _os_log_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Stop heartbeat to %s", (uint8_t *)&v14, 0x26u);
    }
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPGetInterfaceStillExists(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v3 = 2148466689;
  if (!a2 || !a3 || !IsIPPORTValid()) {
    return v3;
  }
  uint64_t v6 = CheckInHandleDebug();
  if (!v6) {
    return 2148466690;
  }
  uint64_t v7 = v6;
  int v8 = (pthread_rwlock_t *)(v6 + 1064);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v6 + 1064));
  uint64_t v9 = *(void *)(v7 + 1056);
  if (!v9) {
    goto LABEL_19;
  }
  int v10 = *(_DWORD *)a2 & 1;
  while (1)
  {
    if (v10 != (*(_DWORD *)(v9 + 2072) & 1)) {
      goto LABEL_15;
    }
    if (v10) {
      break;
    }
    if (*(_DWORD *)(a2 + 20) == *(_DWORD *)(v9 + 2092)) {
      goto LABEL_18;
    }
LABEL_15:
    uint64_t v9 = *(void *)(v9 + 2144);
    if (!v9) {
      goto LABEL_19;
    }
  }
  if (*(void *)(a2 + 20) != *(void *)(v9 + 2092) || *(void *)(a2 + 28) != *(void *)(v9 + 2100)) {
    goto LABEL_15;
  }
LABEL_18:
  LODWORD(v9) = 1;
LABEL_19:
  *a3 = v9;
  pthread_rwlock_unlock(v8);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPShouldCheckForExternalCandidate(uint64_t a1)
{
  uint64_t v2 = (pthread_rwlock_t *)(a1 + 1064);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 1064));
  uint64_t v3 = *(void *)(a1 + 1056);
  if (v3)
  {
    while ((*(unsigned char *)(v3 + 2072) & 1) == 0
         && (*(unsigned __int16 *)(v3 + 2094) == 43518 || !strncmp((const char *)(v3 + 2076), "lo", 2uLL)))
    {
      uint64_t v3 = *(void *)(v3 + 2144);
      if (!v3) {
        goto LABEL_6;
      }
    }
    uint64_t v4 = 1;
  }
  else
  {
LABEL_6:
    uint64_t v4 = 0;
  }
  pthread_rwlock_unlock(v2);
  return v4;
}

uint64_t TPGetConnectionData(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const unsigned __int8 *a13)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = CheckInHandleDebug();
  if (!v15) {
    return 2148466690;
  }
  uint64_t v16 = v15;
  if (!a10 || (*(unsigned char *)a10 & 1) != 0) {
    goto LABEL_28;
  }
  uint64_t v17 = (pthread_rwlock_t *)(v15 + 1064);
  uint64_t v18 = v15;
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v15 + 1064));
  uint64_t v29 = v18;
  uint64_t v19 = *(void *)(v18 + 1056);
  if (!v19) {
    goto LABEL_27;
  }
  int v20 = *(_DWORD *)a10 & 1;
  do
  {
    uint64_t v21 = v19;
    if (v20 != (*(_DWORD *)(v19 + 2072) & 1)) {
      goto LABEL_16;
    }
    if (v20)
    {
      uint64_t v22 = *(void *)(v19 + 2100);
      if (*(void *)(a10 + 20) != *(void *)(v21 + 2092) || *(void *)(a10 + 28) != v22) {
        goto LABEL_16;
      }
    }
    else if (*(_DWORD *)(a10 + 20) != *(_DWORD *)(v19 + 2092))
    {
      goto LABEL_16;
    }
    if (*(unsigned __int16 *)(a10 + 36) == *(unsigned __int16 *)(v21 + 2108)) {
      goto LABEL_27;
    }
LABEL_16:
    uint64_t v19 = *(void *)(v21 + 2144);
  }
  while (v19);
  __int16 v30 = (int *)0xAAAAAAAAAAAAAAAALL;
  BOOL v24 = TransportMapPacketMultiplexModeToVTPMode(*(unsigned int *)(v29 + 4));
  if ((CreateSocketAndBind((long long *)a10, &v30, 1, a13, v24) & 0x80000000) != 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        TPGetConnectionData_cold_1();
      }
    }
  }
  else
  {
    uint64_t v25 = v30;
    v30[516] = a3;
    *(void *)(v21 + 2144) = v25;
    __int16 v26 = v25;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    IPPORTToStringWithSize();
    IPPORTToStringWithSize();
    *(_WORD *)(a10 + 76) = *((_WORD *)v26 + 1054);
    if ((ICEAddOneInterfaceWithPriorityHints() & 0x80000000) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        TPGetConnectionData_cold_2();
      }
    }
    v26[528] = *(_DWORD *)(a10 + 80);
  }
LABEL_27:
  pthread_rwlock_unlock(v17);
  uint64_t v16 = v29;
LABEL_28:
  if (a7) {
    TPShouldCheckForExternalCandidate(v16);
  }
  uint64_t v27 = ICEGetCandidates();
  CheckOutHandleDebug();
  return v27;
}

uint64_t TPStartConnectionCheck(double a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = CheckInHandleDebug();
  if (!v11) {
    return 2148466690;
  }
  uint64_t v12 = v11 + 34328;
  if (!_CTServerConnectionCarrierSettingsCopyValue() && !*MEMORY[0x1E4F1CFD0])
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v20 = VRTraceErrorLogLevelToCSTR();
      uint64_t v19 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        uint64_t v22 = v20;
        __int16 v23 = 2080;
        BOOL v24 = "TPStartConnectionCheck";
        __int16 v25 = 1024;
        int v26 = 3564;
        _os_log_impl(&dword_1E1EA4000, v19, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d _CTServerConnectionCarrierSettingsCopyValue return TRUE!", buf, 0x1Cu);
      }
    }
    ICEUpdateServingNetworkInfo();
  }
  ICEUpdateCellTech();
  int v14 = *(const void **)(v12 + 200);
  if (a9) {
    CFTypeRef v15 = CFRetain(a9);
  }
  else {
    CFTypeRef v15 = 0;
  }
  *(void *)(v12 + 200) = v15;
  if (v14) {
    CFRelease(v14);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v16 = VRTraceErrorLogLevelToCSTR();
    uint64_t v17 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      uint64_t v22 = v16;
      __int16 v23 = 2080;
      BOOL v24 = "TPStartConnectionCheck";
      __int16 v25 = 1024;
      int v26 = 3582;
      __int16 v27 = 2048;
      double v28 = a1;
      _os_log_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Setting ice timeout to iceTimeout = %f", buf, 0x26u);
    }
  }
  ICESetTimeout();
  uint64_t v13 = ICEStartConnectivityCheck();
  CheckOutHandleDebug();
  return v13;
}

uint64_t TPDiscardConnectionResult()
{
  if (!CheckInHandleDebug()) {
    return 2148466690;
  }
  uint64_t v0 = ICEDiscardResult();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPDiscardRelayBinding()
{
  if (!CheckInHandleDebug()) {
    return 2148466690;
  }
  uint64_t v0 = ICEDiscardRelayBinding();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPDiscardRelayBindingWithChannelNumber()
{
  if (!CheckInHandleDebug()) {
    return 2148466690;
  }
  uint64_t v0 = ICEDiscardOneRelayBindingWithChannelNumber();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPRemovePreservedPortBindForCallID(uint64_t a1, int a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = CheckInHandleDebug();
  if (!v3) {
    return 2148466690;
  }
  uint64_t v4 = v3;
  uint64_t v13 = (pthread_rwlock_t *)(v3 + 1064);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 1064));
  uint64_t v5 = *(void *)(v4 + 1056);
  if (v5)
  {
    uint64_t v6 = (uint64_t *)(v4 + 1056);
    do
    {
      BOOL v7 = a2 == -1 || *(_DWORD *)(v5 + 2064) == a2;
      if (v7 && (*(_DWORD *)(v5 + 2112) & 9) != 0)
      {
        uint64_t *v6 = *(void *)(v5 + 2144);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v8 = VRTraceErrorLogLevelToCSTR();
          uint64_t v9 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            int v10 = *(_DWORD *)(v5 + 2064);
            *(_DWORD *)buf = 136316162;
            uint64_t v15 = v8;
            __int16 v16 = 2080;
            uint64_t v17 = "RemoveCListForCallID";
            __int16 v18 = 1024;
            int v19 = 3480;
            __int16 v20 = 1024;
            int v21 = a2;
            __int16 v22 = 1024;
            int v23 = v10;
            _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d RemoveCListForCallID for a callid [%d == %d]", buf, 0x28u);
          }
        }
        ICERemoveOneInterface();
        uint64_t v11 = *(void *)(v5 + 2128);
        if (v11 != 0xFFFFFFFFLL)
        {
          if (*(void *)(v5 + 2136) != 0xFFFFFFFFLL)
          {
            ARPLSessionRelease();
            *(void *)(v5 + 2136) = 0xFFFFFFFFLL;
            uint64_t v11 = *(void *)(v5 + 2128);
          }
          DTLS_Cleanup(v11);
        }
        free((void *)v5);
      }
      else
      {
        uint64_t v6 = (uint64_t *)(v5 + 2144);
      }
      uint64_t v5 = *v6;
    }
    while (*v6);
  }
  pthread_rwlock_unlock(v13);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPSetCellConditionChangeHandler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = CheckInHandleDebug();
  if (!v5) {
    return 2148466690;
  }
  *(void *)(v5 + 34496) = a2;
  *(void *)(v5 + 34504) = a3;
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPUpdateInterfaceList(uint64_t a1, uint64_t a2, int *a3, int a4, const unsigned __int8 *a5)
{
  uint64_t v111 = *MEMORY[0x1E4F143B8];
  uint64_t v96 = 0;
  uint64_t v97 = 0;
  uint64_t v8 = 2148466710;
  *(void *)&v107[9] = 0;
  *(void *)&v107[13] = 0;
  uint64_t v9 = CheckInHandleDebug();
  if (!v9) {
    return 2148466690;
  }
  uint64_t v10 = v9;
  v92 = a3;
  *(void *)&v110[14] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v109 = v11;
  *(_OWORD *)v110 = v11;
  uint64_t v12 = v9 + 34328;
  long long v108 = v11;
  v98 = (char *)0xAAAAAAAAAAAAAAAALL;
  TPSetupCTContext(a1, v9, a4);
  if (*(_DWORD *)(v12 + 56))
  {
    int LocalInterfaceListWithOptionsAndCellInterfaceName = 1;
    v98 = (char *)malloc_type_calloc(1uLL, 0x28uLL, 0x100004053E81896uLL);
    MakeIPPORT();
    unsigned int LocalIFIndexForDstIPPort = GetLocalIFIndexForDstIPPort();
    if_indextoname(LocalIFIndexForDstIPPort, v98 + 4);
LABEL_6:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v15 = VRTraceErrorLogLevelToCSTR();
      __int16 v16 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        uint64_t v101 = v15;
        __int16 v102 = 2080;
        v103 = "TPUpdateInterfaceList";
        __int16 v104 = 1024;
        int v105 = 3730;
        __int16 v106 = 1024;
        *(_DWORD *)v107 = LocalInterfaceListWithOptionsAndCellInterfaceName;
        _os_log_impl(&dword_1E1EA4000, v16, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d %d interfaces found.", buf, 0x22u);
      }
    }
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v10 + 1064));
    if (LocalInterfaceListWithOptionsAndCellInterfaceName < 1)
    {
      unsigned int v95 = 0;
      unsigned int v18 = 0;
    }
    else
    {
      uint64_t v17 = 0;
      unsigned int v18 = 0;
      unsigned int v95 = 0;
      int v19 = (uint64_t *)(v10 + 1056);
      uint64_t v94 = LocalInterfaceListWithOptionsAndCellInterfaceName;
      do
      {
        uint64_t v20 = *v19;
        if (*v19)
        {
          int v21 = &v98[40 * v17];
          int v23 = *(_DWORD *)v21;
          __int16 v22 = v21 + 20;
          int v24 = v23 & 1;
          __int16 v25 = (void *)(v10 + 1056);
          do
          {
            if (v24 == (*(_DWORD *)(v20 + 2072) & 1))
            {
              if (v24)
              {
                if (*v22 == *(void *)(v20 + 2092) && v22[1] == *(void *)(v20 + 2100))
                {
LABEL_37:
                  v99 = (int *)v20;
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                  {
                    uint64_t v41 = VRTraceErrorLogLevelToCSTR();
                    long long v42 = *MEMORY[0x1E4F47A50];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v43 = IPPORTToStringWithSize();
                      *(_DWORD *)buf = 136315906;
                      uint64_t v101 = v41;
                      __int16 v102 = 2080;
                      v103 = "TPUpdateInterfaceList";
                      __int16 v104 = 1024;
                      int v105 = 3740;
                      __int16 v106 = 2080;
                      *(void *)v107 = v43;
                      _os_log_impl(&dword_1E1EA4000, v42, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Keep listening on %s", buf, 0x26u);
                    }
                  }
                  if (v98[40 * v17])
                  {
                    VCNAT64ResolverIsBehindNat64((uint64_t)&v98[40 * v17 + 4]);
                    ICEUpdateNAT64FlagForInterface();
                  }
                  *__int16 v25 = *(void *)(v20 + 2144);
                  *(void *)(v20 + 2144) = 0;
                  long long v44 = &v96;
                  do
                  {
                    long long v45 = v44;
                    uint64_t v46 = *v44;
                    long long v44 = (uint64_t *)(*v44 + 2144);
                  }
                  while (v46);
                  *long long v45 = v20;
                  goto LABEL_45;
                }
              }
              else if (*(_DWORD *)v22 == *(_DWORD *)(v20 + 2092))
              {
                goto LABEL_37;
              }
            }
            __int16 v25 = (void *)(v20 + 2144);
            uint64_t v20 = *(void *)(v20 + 2144);
          }
          while (v20);
        }
        v99 = 0;
        HIDWORD(v97) = 1;
        *(_WORD *)&v98[40 * v17 + 36] = *(_WORD *)(v10 + 20);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v27 = VRTraceErrorLogLevelToCSTR();
          double v28 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v29 = IPPORTToStringWithSize();
            *(_DWORD *)buf = 136315906;
            uint64_t v101 = v27;
            __int16 v102 = 2080;
            v103 = "TPUpdateInterfaceList";
            __int16 v104 = 1024;
            int v105 = 3767;
            __int16 v106 = 2080;
            *(void *)v107 = v29;
            _os_log_impl(&dword_1E1EA4000, v28, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Adding [%s] to list", buf, 0x26u);
          }
        }
        __int16 v30 = (long long *)&v98[40 * v17];
        BOOL v31 = TransportMapPacketMultiplexModeToVTPMode(*(unsigned int *)(v10 + 4));
        unsigned int v32 = CreateSocketAndBind(v30, &v99, 0, a5, v31);
        if ((v32 & 0x80000000) != 0)
        {
          unsigned int v18 = v32;
        }
        else
        {
          VCTestMonitorManager_GetEnableLoopbackInterface();
          int v33 = ICESetEnableLoopbackInterface();
          if (v33 < 0)
          {
            int v34 = v33;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              uint64_t v35 = VRTraceErrorLogLevelToCSTR();
              long long v36 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136316162;
                uint64_t v101 = v35;
                __int16 v102 = 2080;
                v103 = "TPUpdateInterfaceList";
                __int16 v104 = 1024;
                int v105 = 3777;
                __int16 v106 = 1024;
                *(_DWORD *)v107 = 3777;
                v107[2] = 1024;
                *(_DWORD *)&v107[3] = v34;
                _os_log_error_impl(&dword_1E1EA4000, v36, OS_LOG_TYPE_ERROR, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transport.c:%d: ICESetEnableLoopbackInterface failed(%08X)", buf, 0x28u);
              }
            }
          }
          long long v37 = v99;
          unsigned int v18 = ICEAddOneInterface();
          if ((v18 & 0x80000000) != 0)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              uint64_t v47 = VRTraceErrorLogLevelToCSTR();
              long long v48 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315906;
                uint64_t v101 = v47;
                __int16 v102 = 2080;
                v103 = "TPUpdateInterfaceList";
                __int16 v104 = 1024;
                int v105 = 3784;
                __int16 v106 = 1024;
                *(_DWORD *)v107 = v18;
                _os_log_impl(&dword_1E1EA4000, v48, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ICEAddOneInterface failed %08x", buf, 0x22u);
              }
            }
            VTP_Close(*v37);
            uint64_t v49 = *((void *)v37 + 266);
            if (v49 != 0xFFFFFFFFLL)
            {
              if (*((void *)v37 + 267) != 0xFFFFFFFFLL)
              {
                ARPLSessionRelease();
                *((void *)v37 + 267) = 0xFFFFFFFFLL;
                uint64_t v49 = *((void *)v37 + 266);
              }
              DTLS_Cleanup(v49);
            }
            free(v37);
          }
          else
          {
            if (v98[40 * v17])
            {
              VCNAT64ResolverIsBehindNat64((uint64_t)(v37 + 519));
              ICEUpdateNAT64FlagForInterface();
            }
            long long v38 = (int **)&v96;
            do
            {
              long long v39 = v38;
              long long v40 = *v38;
              long long v38 = (int **)(*v38 + 536);
            }
            while (v40);
            uint64_t *v39 = v37;
LABEL_45:
            ++v95;
          }
        }
        ++v17;
      }
      while (v17 != v94);
    }
    FreeLocalInterfaceList();
    int v50 = *(int **)(v10 + 1056);
    v99 = v50;
    if (!v50)
    {
      LODWORD(v51) = v95;
      goto LABEL_113;
    }
    uint64_t v51 = v95;
LABEL_59:
    int v52 = v50[518];
    if (nwi_state_copy())
    {
      if (nwi_state_get_ifstate())
      {
        char flags = nwi_ifstate_get_flags();
        char v54 = flags;
        if (v52 & 1) == 0 && (flags)
        {
          nwi_state_release();
LABEL_66:
          timespec v56 = v99;
          int v57 = *((unsigned __int8 *)v99 + 4);
          int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
          if (v57)
          {
            if (ErrorLogLevelForModule >= 7)
            {
              uint64_t v59 = VRTraceErrorLogLevelToCSTR();
              int v60 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                int v61 = *v56;
                *(_DWORD *)buf = 136315906;
                uint64_t v101 = v59;
                __int16 v102 = 2080;
                v103 = "TPUpdateInterfaceList";
                __int16 v104 = 1024;
                int v105 = 3828;
                __int16 v106 = 1024;
                *(_DWORD *)v107 = v61;
                long long v62 = v60;
                long long v63 = "SIP [%s] %s:%d Keep listening on virtual interface (vfd %d)";
                uint32_t v64 = 34;
                goto LABEL_73;
              }
            }
          }
          else if (ErrorLogLevelForModule >= 7)
          {
            uint64_t v65 = VRTraceErrorLogLevelToCSTR();
            long long v66 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              uint64_t v101 = v65;
              __int16 v102 = 2080;
              v103 = "TPUpdateInterfaceList";
              __int16 v104 = 1024;
              int v105 = 3830;
              __int16 v106 = 2080;
              *(void *)v107 = v56 + 519;
              long long v62 = v66;
              long long v63 = "SIP [%s] %s:%d Interface '%s' is not in the routing table but still valid. Keeping it";
              uint32_t v64 = 38;
LABEL_73:
              _os_log_impl(&dword_1E1EA4000, v62, OS_LOG_TYPE_DEFAULT, v63, buf, v64);
            }
          }
          int v50 = (int *)*((void *)v56 + 268);
          *((void *)v56 + 268) = 0;
          v67 = (int **)&v96;
          do
          {
            long long v68 = v67;
            long long v69 = *v67;
            v67 = (int **)(*v67 + 536);
          }
          while (v69);
          *long long v68 = v56;
          uint64_t v51 = (v51 + 1);
          goto LABEL_110;
        }
        nwi_state_release();
        if ((v52 & 1) != 0 && (v54 & 2) != 0) {
          goto LABEL_66;
        }
      }
      else
      {
        nwi_state_release();
      }
    }
    __int16 v55 = v99;
    if (*((unsigned char *)v99 + 4)) {
      goto LABEL_66;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v70 = VRTraceErrorLogLevelToCSTR();
      uint64_t v71 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v72 = IPPORTToStringWithSize();
        *(_DWORD *)buf = 136315906;
        uint64_t v101 = v70;
        __int16 v102 = 2080;
        v103 = "TPUpdateInterfaceList";
        __int16 v104 = 1024;
        int v105 = 3848;
        __int16 v106 = 2080;
        *(void *)v107 = v72;
        _os_log_impl(&dword_1E1EA4000, v71, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Stop listening on %s", buf, 0x26u);
      }
    }
    uint64_t v73 = 0;
    HIDWORD(v97) = 1;
    int v50 = (int *)*((void *)v55 + 268);
    while (1)
    {
      uint64_t v74 = v10 + (v73 << 7);
      v75 = (pthread_mutex_t *)(v74 + 1560);
      pthread_mutex_lock((pthread_mutex_t *)(v74 + 1560));
      uint64_t v76 = *(void *)(v74 + 1552);
      if (v76) {
        break;
      }
LABEL_96:
      pthread_mutex_unlock(v75);
      if (++v73 == 256)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() <= 6)
        {
          v84 = v99;
        }
        else
        {
          uint64_t v80 = v51;
          uint64_t v81 = VRTraceErrorLogLevelToCSTR();
          v82 = *MEMORY[0x1E4F47A50];
          BOOL v83 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
          v84 = v99;
          if (v83)
          {
            int v85 = v99[516];
            *(_DWORD *)buf = 136315906;
            uint64_t v101 = v81;
            __int16 v102 = 2080;
            v103 = "TPUpdateInterfaceList";
            __int16 v104 = 1024;
            int v105 = 3871;
            __int16 v106 = 1024;
            *(_DWORD *)v107 = v85;
            _os_log_impl(&dword_1E1EA4000, v82, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPUpdateInterfaceList: %u", buf, 0x22u);
          }
          uint64_t v51 = v80;
        }
        ICERemoveOneInterface();
        VTP_Close(*v84);
        uint64_t v86 = *((void *)v84 + 266);
        if (v86 != 0xFFFFFFFFLL)
        {
          if (*((void *)v84 + 267) != 0xFFFFFFFFLL)
          {
            ARPLSessionRelease();
            *((void *)v84 + 267) = 0xFFFFFFFFLL;
            uint64_t v86 = *((void *)v84 + 266);
          }
          DTLS_Cleanup(v86);
        }
        free(v84);
LABEL_110:
        v99 = v50;
        if (!v50)
        {
LABEL_113:
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            uint64_t v87 = VRTraceErrorLogLevelToCSTR();
            v88 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              uint64_t v101 = v87;
              __int16 v102 = 2080;
              v103 = "TPUpdateInterfaceList";
              __int16 v104 = 1024;
              int v105 = 3890;
              __int16 v106 = 1024;
              *(_DWORD *)v107 = v51;
              _os_log_impl(&dword_1E1EA4000, v88, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPUpdateInterfaceList:%d valid interfaces found.", buf, 0x22u);
            }
          }
          if (v96) {
            uint64_t v8 = v18;
          }
          else {
            uint64_t v8 = 2148466710;
          }
          *(void *)(v10 + 1056) = v96;
          VTP_Close(*(_DWORD *)(v10 + 12));
          *(_DWORD *)(v10 + 12) = -1;
          pthread_rwlock_unlock((pthread_rwlock_t *)(v10 + 1064));
          if (!HIDWORD(v97)) {
            ICEInterfaceNeedsUpdateExternalMapping();
          }
          CheckOutHandleDebug();
          if ((v8 & 0x80000000) == 0)
          {
            *(_DWORD *)buf = 0;
            uint64_t v8 = TPGetRemoteICEVersion();
            if ((v8 & 0x80000000) != 0)
            {
              int v90 = 0;
            }
            else
            {
              if (HIDWORD(v97)) {
                BOOL v89 = (*(_DWORD *)buf - 1010) >= 0xFFFFFC0F;
              }
              else {
                BOOL v89 = 1;
              }
              int v90 = !v89;
            }
            int *v92 = v90;
          }
          return v8;
        }
        goto LABEL_59;
      }
    }
    uint64_t v77 = (uint64_t *)(v74 + 1552);
    while ((*(_DWORD *)(v76 + 2056) & 1) == (v99[518] & 1))
    {
      v78 = (void *)(v76 + 2076);
      if (*(_DWORD *)(v76 + 2056))
      {
        if (*v78 != *(void *)(v99 + 523) || *(void *)(v76 + 2084) != *(void *)(v99 + 525)) {
          break;
        }
      }
      else if (*(_DWORD *)v78 != v99[523])
      {
        break;
      }
      if (*(unsigned __int16 *)(v76 + 2092) != *((unsigned __int16 *)v99 + 1054)) {
        break;
      }
      *uint64_t v77 = *(void *)(v76 + 2144);
      free((void *)v76);
LABEL_95:
      uint64_t v76 = *v77;
      if (!*v77) {
        goto LABEL_96;
      }
    }
    uint64_t v77 = (uint64_t *)(v76 + 2144);
    goto LABEL_95;
  }
  int LocalInterfaceListWithOptionsAndCellInterfaceName = GetLocalInterfaceListWithOptionsAndCellInterfaceName();
  if (LocalInterfaceListWithOptionsAndCellInterfaceName) {
    goto LABEL_6;
  }
  FreeLocalInterfaceList();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      TPUpdateInterfaceList_cold_1();
    }
  }
  CheckOutHandleDebug();
  return v8;
}

void TPSetupCTContext(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a2 + 34456;
  int v5 = *(_DWORD *)(a2 + 34512);
  if (!(v5 | a3))
  {
    *(_DWORD *)(a2 + 34512) = 1;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v6 = VRTraceErrorLogLevelToCSTR();
      BOOL v7 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        uint64_t v21 = v6;
        __int16 v22 = 2080;
        int v23 = "TPSetupCTContext";
        __int16 v24 = 1024;
        int v25 = 2520;
        _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Device hw model supports FaceTime over cellular network.", buf, 0x1Cu);
      }
    }
    int v5 = *(_DWORD *)(v4 + 56);
  }
  if (v5)
  {
    uint64_t v8 = (pthread_mutex_t *)(a2 + 34392);
    pthread_mutex_lock(v8);
    if (!*(void *)v4)
    {
      dispatch_get_global_queue(0, 0);
      uint64_t v14 = _CTServerConnectionCreateOnTargetQueue();
      *(void *)uint64_t v4 = v14;
      int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (v14)
      {
        if (ErrorLogLevelForModule >= 7)
        {
          uint64_t v16 = VRTraceErrorLogLevelToCSTR();
          uint64_t v17 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            uint64_t v21 = v16;
            __int16 v22 = 2080;
            int v23 = "TPSetupCTContext";
            __int16 v24 = 1024;
            int v25 = 2532;
            _os_log_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d _CTServerConnectionCreateOnTargetQueue succeeded!", buf, 0x1Cu);
          }
        }
        if (!_CTServerConnectionRegisterForNotification())
        {
          *(_DWORD *)(v4 + 68) = 1;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            uint64_t v18 = VRTraceErrorLogLevelToCSTR();
            int v19 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              uint64_t v21 = v18;
              __int16 v22 = 2080;
              int v23 = "TPSetupCTContext";
              __int16 v24 = 1024;
              int v25 = 2536;
              _os_log_impl(&dword_1E1EA4000, v19, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d kCTRegistrationDataStatusChangedNotification registered.", buf, 0x1Cu);
            }
          }
        }
      }
      else if (ErrorLogLevelForModule >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          TPSetupCTContext_cold_1();
        }
      }
    }
    if (!VCCTServiceMonitor_GetSignalStrength() && (int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v9 = VRTraceErrorLogLevelToCSTR();
      uint64_t v10 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v11 = *(_DWORD *)(v4 + 20);
        int v12 = *(_DWORD *)(v4 + 24);
        int v13 = *(_DWORD *)(v4 + 28);
        *(_DWORD *)buf = 136316418;
        uint64_t v21 = v9;
        __int16 v22 = 2080;
        int v23 = "TPSetupCTContext";
        __int16 v24 = 1024;
        int v25 = 2544;
        __int16 v26 = 1024;
        *(_DWORD *)uint64_t v27 = v11;
        *(_WORD *)&v27[4] = 1024;
        *(_DWORD *)&v27[6] = v12;
        __int16 v28 = 1024;
        int v29 = v13;
        _os_log_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Received cellular signal strength. [Strength: %d displayBars: %d maxDisplayBars: %d]", buf, 0x2Eu);
      }
    }
    *(_DWORD *)(v4 + 16) = TPGetLocalCellTech(*(void *)v4);
    VCCTServiceMonitor_CopyConnectionStatusInterfaceName();
    pthread_mutex_unlock(v8);
  }
}

uint64_t CreateSocketAndBind(long long *a1, int **a2, int a3, const unsigned __int8 *a4, int a5)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  socklen_t v54 = -1431655766;
  memset(__str, 170, 6);
  *(void *)&v64[14] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&v10.sa_len = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&v10.sa_data[6] = 0xAAAAAAAAAAAAAAAALL;
  v63[9] = v10;
  *(sockaddr *)uint32_t v64 = v10;
  v63[8] = v10;
  v63[6] = v10;
  v63[7] = v10;
  v63[4] = v10;
  v63[5] = v10;
  v63[2] = v10;
  v63[3] = v10;
  v63[0] = v10;
  v63[1] = v10;
  int v11 = (int *)malloc_type_calloc(1uLL, 0x868uLL, 0x10200406FE3F67FuLL);
  *a2 = v11;
  if (v11)
  {
    *((void *)v11 + 258) = 0;
    *((void *)v11 + 266) = 0xFFFFFFFFLL;
    *((void *)*a2 + 267) = 0xFFFFFFFFLL;
    int v12 = *a2 + 518;
    long long v13 = *a1;
    long long v14 = a1[1];
    *((void *)*a2 + 263) = *((void *)a1 + 4);
    *int v12 = v13;
    v12[1] = v14;
    int v15 = *(_DWORD *)a1;
    if (*(_DWORD *)a1) {
      int v16 = 30;
    }
    else {
      int v16 = 2;
    }
    *(void *)&long long v17 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&buf[16] = v17;
    *(_OWORD *)&buf[32] = v17;
    *(_OWORD *)buf = v17;
    *(void *)&v61[0] = 0xAAAAAAAAAAAAAAAALL;
    memset(&v56.ai_socktype, 0, 40);
    v56.ai_char flags = 5;
    v56.ai_family = v16;
    v56.ai_socktype = 2;
    if (v15)
    {
      if (*(void *)((char *)a1 + 20) != *MEMORY[0x1E4F148B8]
        || *(void *)((char *)a1 + 28) != *(void *)(MEMORY[0x1E4F148B8] + 8))
      {
        goto LABEL_7;
      }
    }
    else if (*((_DWORD *)a1 + 5))
    {
LABEL_7:
      uint64_t v18 = (const char *)IPToString();
      goto LABEL_17;
    }
    uint64_t v18 = 0;
LABEL_17:
    uint64_t v21 = (unsigned __int16 *)a1 + 18;
    snprintf(__str, 6uLL, "%d", *((unsigned __int16 *)a1 + 18));
    int v22 = getaddrinfo(v18, __str, &v56, (addrinfo **)v61);
    if (v22)
    {
      uint64_t v19 = v22 | 0xB00F0000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          CreateSocketAndBind_cold_6();
        }
      }
      goto LABEL_52;
    }
    uint64_t v23 = *(void *)&v61[0];
    if (!*(void *)&v61[0])
    {
      uint64_t v19 = 2148466692;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          CreateSocketAndBind_cold_2();
          uint64_t v19 = 2148466692;
        }
      }
      goto LABEL_52;
    }
    uint64_t v24 = *(void *)&v61[0];
    while (*(_DWORD *)(v24 + 4) != v16)
    {
      uint64_t v24 = *(void *)(v24 + 40);
      if (!v24)
      {
        int v16 = *(_DWORD *)(*(void *)&v61[0] + 4);
        goto LABEL_30;
      }
    }
    uint64_t v23 = v24;
LABEL_30:
    int v25 = VTP_Socket(v16, *(_DWORD *)(v23 + 8), *(_DWORD *)(v23 + 12));
    **a2 = v25;
    if (v25 == -1)
    {
      uint64_t v19 = *__error() | 0xC00F0000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          CreateSocketAndBind_cold_3();
        }
      }
      freeaddrinfo(*(addrinfo **)&v61[0]);
      goto LABEL_52;
    }
    VTP_SetSocketMode(v25, a5);
    int v26 = **a2;
    uint64_t v27 = *(void *)(v23 + 32);
    socklen_t v28 = *(_DWORD *)(v23 + 16);
    if (a3) {
      int v29 = VTP_BindNew(v26, v27, v28);
    }
    else {
      int v29 = VTP_Bind(v26, v27, v28);
    }
    int v30 = v29;
    VTP_DetectNAT64Prefix(**a2, (const char *)*a2 + 2076);
    freeaddrinfo(*(addrinfo **)&v61[0]);
    if (v30 == -1)
    {
      uint64_t v19 = *__error() | 0xC00F0000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v37 = VRTraceErrorLogLevelToCSTR();
        long long v38 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          CreateSocketAndBind_cold_4(v37, v21, v38);
        }
      }
    }
    else
    {
      VTP_SetPktType(**a2, 48142);
      socklen_t v54 = 128;
      if (VTP_Getsockname(**a2, v63, &v54) != -1)
      {
        unint64_t v62 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v31 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v31 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v61[0] = v31;
        v61[1] = v31;
        SAToIPPORT();
        *((_WORD *)*a2 + 1054) = WORD2(v62);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
        {
          uint64_t v32 = VRTraceErrorLogLevelToCSTR();
          int v33 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v34 = IPPORTToStringWithSize();
            uint64_t v35 = (uint64_t)(*a2 + 519);
            int v36 = **a2;
            *(_DWORD *)buf = 136316418;
            *(void *)&uint8_t buf[4] = v32;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "CreateSocketAndBind";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 2432;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = v34;
            *(_WORD *)&buf[38] = 2080;
            *(void *)&buf[40] = v35;
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = v36;
            _os_log_impl(&dword_1E1EA4000, v33, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Start listening on %s(%s) sock %d", buf, 0x36u);
          }
        }
        if (uuid_is_null(a4)) {
          goto LABEL_44;
        }
        *(void *)&buf[46] = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v40 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v40 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&buf[16] = v40;
        *(_OWORD *)&buf[32] = v40;
        *(_OWORD *)buf = v40;
        IPPORTToStringWithSize();
        *(void *)&out[29] = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v41 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v41 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)uuid_string_t out = v41;
        *(_OWORD *)&out[16] = v41;
        uuid_unparse(a4, out);
        int v42 = VTP_Setsockopt(**a2, 0xFFFF, 4360, a4, 0x10u);
        int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (v42 == -1)
        {
          if (ErrorLogLevelForModule < 8) {
            goto LABEL_44;
          }
          uint64_t v49 = VRTraceErrorLogLevelToCSTR();
          int v50 = *MEMORY[0x1E4F47A50];
          uint64_t v51 = *MEMORY[0x1E4F47A50];
          if (!*MEMORY[0x1E4F47A40])
          {
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
            {
              int v53 = *__error();
              v56.ai_char flags = 136316418;
              *(void *)&v56.ai_family = v49;
              LOWORD(v56.ai_protocol) = 2080;
              *(void *)((char *)&v56.ai_protocol + 2) = "CreateSocketAndBind";
              *((_WORD *)&v56.ai_addrlen + 3) = 1024;
              LODWORD(v56.ai_canonname) = 2442;
              WORD2(v56.ai_canonname) = 2080;
              *(char **)((char *)&v56.ai_canonname + 6) = out;
              HIWORD(v56.ai_addr) = 2080;
              v56.ai_next = (addrinfo *)buf;
              __int16 v57 = 1024;
              int v58 = v53;
              _os_log_debug_impl(&dword_1E1EA4000, v50, OS_LOG_TYPE_DEBUG, "SIP [%s] %s:%d CreateSocketAndBind: Unable to set delegatedUUID(%s) for socket %s with error %d)", (uint8_t *)&v56, 0x36u);
            }
            goto LABEL_44;
          }
          if (!os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
          {
LABEL_44:
            uint64_t v19 = 0;
            (*a2)[2] = 2048;
            return v19;
          }
          int v52 = *__error();
          v56.ai_char flags = 136316418;
          *(void *)&v56.ai_family = v49;
          LOWORD(v56.ai_protocol) = 2080;
          *(void *)((char *)&v56.ai_protocol + 2) = "CreateSocketAndBind";
          *((_WORD *)&v56.ai_addrlen + 3) = 1024;
          LODWORD(v56.ai_canonname) = 2442;
          WORD2(v56.ai_canonname) = 2080;
          *(char **)((char *)&v56.ai_canonname + 6) = out;
          HIWORD(v56.ai_addr) = 2080;
          v56.ai_next = (addrinfo *)buf;
          __int16 v57 = 1024;
          int v58 = v52;
          uint64_t v46 = "SIP [%s] %s:%d CreateSocketAndBind: Unable to set delegatedUUID(%s) for socket %s with error %d)";
          uint64_t v47 = v50;
          uint32_t v48 = 54;
        }
        else
        {
          if (ErrorLogLevelForModule < 7) {
            goto LABEL_44;
          }
          uint64_t v44 = VRTraceErrorLogLevelToCSTR();
          long long v45 = *MEMORY[0x1E4F47A50];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_44;
          }
          v56.ai_char flags = 136316162;
          *(void *)&v56.ai_family = v44;
          LOWORD(v56.ai_protocol) = 2080;
          *(void *)((char *)&v56.ai_protocol + 2) = "CreateSocketAndBind";
          *((_WORD *)&v56.ai_addrlen + 3) = 1024;
          LODWORD(v56.ai_canonname) = 2444;
          WORD2(v56.ai_canonname) = 2080;
          *(char **)((char *)&v56.ai_canonname + 6) = out;
          HIWORD(v56.ai_addr) = 2080;
          v56.ai_next = (addrinfo *)buf;
          uint64_t v46 = "SIP [%s] %s:%d CreateSocketAndBind: Set delegatedUUID(%s) for socket %s)";
          uint64_t v47 = v45;
          uint32_t v48 = 48;
        }
        _os_log_impl(&dword_1E1EA4000, v47, OS_LOG_TYPE_DEFAULT, v46, (uint8_t *)&v56, v48);
        goto LABEL_44;
      }
      uint64_t v19 = *__error() | 0xC00F0000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          CreateSocketAndBind_cold_5();
        }
      }
    }
    VTP_Close(**a2);
LABEL_52:
    free(*a2);
    return v19;
  }
  uint64_t v19 = 2148466691;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      CreateSocketAndBind_cold_1();
    }
  }
  return v19;
}

BOOL TransportMapPacketMultiplexModeToVTPMode(BOOL result)
{
  if (!result && result != 2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      TransportMapPacketMultiplexModeToVTPMode_cold_1();
    }
    return 0;
  }
  return result;
}

uint64_t TPGetRemoteICEVersion()
{
  if (!CheckInHandleDebug()) {
    return 2148466690;
  }
  uint64_t v0 = ICEGetRemoteICEVersion();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPStopConnectivityCheck()
{
  if (!CheckInHandleDebug()) {
    return 2148466690;
  }
  uint64_t v0 = ICEStopConnectivityCheck();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPGetNextBestCandidate()
{
  if (!CheckInHandleDebug()) {
    return 2148466690;
  }
  uint64_t BestCandidate = ICEGetNextBestCandidate();
  CheckOutHandleDebug();
  return BestCandidate;
}

uint64_t TPGetRemoteCIDForDstIPPort()
{
  if (!CheckInHandleDebug()) {
    return 2148466690;
  }
  uint64_t v0 = ICEGetRemoteCIDForDstIPPort();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPSetSKEState()
{
  if (!CheckInHandleDebug()) {
    return 2148466690;
  }
  uint64_t v0 = ICESetSKEState();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPSetForceRelay()
{
  if (!CheckInHandleDebug()) {
    return 2148466690;
  }
  ICESetForceRelay();
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPSetForceIPv6()
{
  if (!CheckInHandleDebug()) {
    return 2148466690;
  }
  ICESetForceIPv6();
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPSetReportingAgent()
{
  if (!CheckInHandleDebug()) {
    return 2148466690;
  }
  uint64_t v0 = ICESetReportingAgent();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPSetICETimeout(double a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!CheckInHandleDebug()) {
    return 2148466690;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v2 = VRTraceErrorLogLevelToCSTR();
    uint64_t v3 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136315906;
      uint64_t v7 = v2;
      __int16 v8 = 2080;
      uint64_t v9 = "TPSetICETimeout";
      __int16 v10 = 1024;
      int v11 = 4047;
      __int16 v12 = 2048;
      double v13 = a1;
      _os_log_impl(&dword_1E1EA4000, v3, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Setting ice timeout to %f", (uint8_t *)&v6, 0x26u);
    }
  }
  uint64_t v4 = ICESetTimeout();
  CheckOutHandleDebug();
  return v4;
}

uint64_t TPSetARPLHandler(uint64_t a1, const void *a2)
{
  uint64_t result = CheckInHandleDebug();
  if (result)
  {
    uint64_t v4 = (void **)(result + 34544);
    int v5 = *(const void **)(result + 34544);
    if (v5) {
      _Block_release(v5);
    }
    *uint64_t v4 = _Block_copy(a2);
    return CheckOutHandleDebug();
  }
  return result;
}

uint64_t TPCleanupARPLHandler()
{
  uint64_t result = CheckInHandleDebug();
  if (result)
  {
    uint64_t v1 = (void *)(result + 34544);
    uint64_t v2 = *(const void **)(result + 34544);
    if (v2)
    {
      _Block_release(v2);
      void *v1 = 0;
    }
    return CheckOutHandleDebug();
  }
  return result;
}

uint64_t TPUpdateICERole(uint64_t a1, uint64_t a2, int a3, int a4, const __CFString *a5)
{
  uint64_t v8 = CheckInHandleDebug();
  if (!v8) {
    return 2148466690;
  }
  uint64_t v9 = v8;
  *(_DWORD *)(v8 + 34536) = a3;
  __int16 v10 = (pthread_rwlock_t *)(v8 + 1064);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v8 + 1064));
  uint64_t v11 = *(void *)(v9 + 1056);
  if (v11)
  {
    if (!a4) {
      a5 = 0;
    }
    do
    {
      *(void *)(v11 + 2116) = 0;
      if (!*(_DWORD *)(v11 + 2068))
      {
        VTP_SetSessionID(*(_DWORD *)v11, a5);
        *(_DWORD *)(v11 + 2120) = a4;
        *(_DWORD *)(v11 + 2116) = a3;
      }
      uint64_t v11 = *(void *)(v11 + 2144);
    }
    while (v11);
  }
  pthread_rwlock_unlock(v10);
  uint64_t v12 = ICEUpdateRole();
  CheckOutHandleDebug();
  return v12;
}

uint64_t TPUpdateQoS(uint64_t a1, int a2)
{
  uint64_t v3 = CheckInHandleDebug();
  if (!v3) {
    return 2148466690;
  }
  *(_DWORD *)(v3 + 34516) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPGetConnErrorCode()
{
  if (!CheckInHandleDebug()) {
    return 2148466690;
  }
  uint64_t v0 = ICEGetConnErrorCode();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPSetDataPacketReceivedCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = CheckInHandleDebug();
  if (!v5) {
    return 2148466690;
  }
  int v6 = (void *)(v5 + 34552);
  uint64_t v7 = (pthread_mutex_t *)(v5 + 34584);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 34584));
  void *v6 = a2;
  if (a3)
  {
    uint64_t v10 = v6[1];
    uint64_t v9 = v6 + 1;
    uint64_t v8 = v10;
    uint64_t v11 = *(void *)(a3 + 16);
    *(_OWORD *)uint64_t v9 = *(_OWORD *)a3;
    uint64_t v12 = (void (*)(void))v9[1];
    double v13 = (void (*)(uint64_t))v9[2];
    v9[2] = v11;
    if (v12 && *v9) {
      v12();
    }
    if (v13) {
      BOOL v14 = v8 == 0;
    }
    else {
      BOOL v14 = 1;
    }
    if (!v14) {
      v13(v8);
    }
  }
  pthread_mutex_unlock(v7);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPProcessRemoteInterfaceChangeMessage(uint64_t a1, int a2, int a3, const UInt8 *a4, int a5, int a6)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (CheckInHandleDebug())
  {
    if (!a4)
    {
      uint64_t v17 = 2148859905;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          TPProcessRemoteInterfaceChangeMessage_cold_1();
        }
      }
      goto LABEL_25;
    }
    if (a3 && (CFDataRef v11 = CFDataCreate(0, a4, a5), v12 = ICEConnectionDataContainsCallID(), CFRelease(v11), !v12))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v18 = VRTraceErrorLogLevelToCSTR();
        uint64_t v19 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v25 = 136315650;
          uint64_t v26 = v18;
          __int16 v27 = 2080;
          socklen_t v28 = "needUpdateRemoteCandidateList";
          __int16 v29 = 1024;
          int v30 = 4196;
          _os_log_impl(&dword_1E1EA4000, v19, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d HandoverReport: needUpdateRemoteCandidateList didn't find matched callID", (uint8_t *)&v25, 0x1Cu);
        }
      }
    }
    else
    {
      uint64_t v13 = CheckInHandleDebug();
      if (v13)
      {
        uint64_t v14 = v13;
        int v15 = (pthread_mutex_t *)(v13 + 168);
        pthread_mutex_lock((pthread_mutex_t *)(v13 + 168));
        uint64_t v16 = *(void *)(v14 + 232);
        if (v16)
        {
          while (*(_DWORD *)(v16 + 148) != a2)
          {
            uint64_t v16 = *(void *)(v16 + 912);
            if (!v16) {
              goto LABEL_9;
            }
          }
          int v20 = *(_DWORD *)(v16 + 208);
          pthread_mutex_unlock(v15);
          CheckOutHandleDebug();
          if (v20 < a6)
          {
            uint64_t v21 = ICEAddRemovedRemoteIPPort();
            if ((v21 & 0x80000000) == 0) {
              uint64_t v21 = ICEProcessRemoteInterfaceChange();
            }
            uint64_t v17 = v21;
            goto LABEL_25;
          }
        }
        else
        {
LABEL_9:
          pthread_mutex_unlock(v15);
          CheckOutHandleDebug();
        }
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v22 = VRTraceErrorLogLevelToCSTR();
      uint64_t v23 = *MEMORY[0x1E4F47A50];
      uint64_t v17 = 0;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
LABEL_25:
        CheckOutHandleDebug();
        return v17;
      }
      int v25 = 136315650;
      uint64_t v26 = v22;
      __int16 v27 = 2080;
      socklen_t v28 = "TPProcessRemoteInterfaceChangeMessage";
      __int16 v29 = 1024;
      int v30 = 4236;
      _os_log_impl(&dword_1E1EA4000, v23, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d HandoverReport: TPProcessRemoteInterfaceChangeMessage, remote candidate list already updated", (uint8_t *)&v25, 0x1Cu);
    }
    uint64_t v17 = 0;
    goto LABEL_25;
  }
  return 2148466690;
}

uint64_t TPSetAllowSameSourceDestination(uint64_t a1, char a2)
{
  uint64_t v3 = CheckInHandleDebug();
  if (!v3) {
    return 2148466690;
  }
  *(unsigned char *)(v3 + 34648) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t SendUDPPacketForCList(uint64_t a1, const void *a2, int a3, uint64_t a4, int *a5, int *a6)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  if (*a6 == 5 && !*((unsigned char *)a6 + 12) && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      SendUDPPacketForCList_cold_1();
    }
  }
  memset(v62, 0, 128);
  IPToString();
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  int v12 = (unsigned char *)MEMORY[0x1E4F47A40];
  if (ErrorLogLevelForModule >= 8)
  {
    uint64_t v13 = VRTraceErrorLogLevelToCSTR();
    uint64_t v14 = *MEMORY[0x1E4F47A50];
    int v15 = *MEMORY[0x1E4F47A50];
    if (*v12)
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        int v16 = *(unsigned __int16 *)(a4 + 36);
        *(_DWORD *)buf = 136316162;
        *(void *)&uint8_t buf[4] = v13;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "SendUDPPacketForCList";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = 218;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = v62;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v16;
        _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SendUDPPacketForCList: SENDING PACKET FROM %s:%d", buf, 0x2Cu);
      }
    }
    else if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      int v40 = *(unsigned __int16 *)(a4 + 36);
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = v13;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "SendUDPPacketForCList";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&unsigned char buf[24] = 218;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = v62;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v40;
      _os_log_debug_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEBUG, "SIP [%s] %s:%d SendUDPPacketForCList: SENDING PACKET FROM %s:%d", buf, 0x2Cu);
    }
  }
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v57 = 0u;
  memset(buf, 0, sizeof(buf));
  IPToString();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v17 = VRTraceErrorLogLevelToCSTR();
    uint64_t v18 = *MEMORY[0x1E4F47A50];
    uint64_t v19 = *MEMORY[0x1E4F47A50];
    if (*v12)
    {
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        int v20 = *((unsigned __int16 *)a5 + 18);
        *(_DWORD *)&v51[16] = 136316162;
        *(void *)&v51[20] = v17;
        *(_WORD *)&v51[28] = 2080;
        *(void *)&v51[30] = "SendUDPPacketForCList";
        *(_WORD *)&v51[38] = 1024;
        *(_DWORD *)&v51[40] = 222;
        __int16 v52 = 2080;
        int v53 = buf;
        __int16 v54 = 1024;
        int v55 = v20;
        _os_log_impl(&dword_1E1EA4000, v18, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SendUDPPacketForCList: SENDING PACKET TO %s:%d", &v51[16], 0x2Cu);
      }
    }
    else if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      int v41 = *((unsigned __int16 *)a5 + 18);
      *(_DWORD *)&v51[16] = 136316162;
      *(void *)&v51[20] = v17;
      *(_WORD *)&v51[28] = 2080;
      *(void *)&v51[30] = "SendUDPPacketForCList";
      *(_WORD *)&v51[38] = 1024;
      *(_DWORD *)&v51[40] = 222;
      __int16 v52 = 2080;
      int v53 = buf;
      __int16 v54 = 1024;
      int v55 = v41;
      _os_log_debug_impl(&dword_1E1EA4000, v18, OS_LOG_TYPE_DEBUG, "SIP [%s] %s:%d SendUDPPacketForCList: SENDING PACKET TO %s:%d", &v51[16], 0x2Cu);
    }
  }
  uint64_t v21 = 2148466710;
  if (!a1) {
    return v21;
  }
  int v42 = a2;
  uint64_t v22 = (void *)MEMORY[0x1E4F148B8];
  while (1)
  {
    int v23 = *(_DWORD *)(a1 + 2072) & 1;
    if (v23 == (*(_DWORD *)a4 & 1))
    {
      uint64_t v24 = (void *)(a1 + 2092);
      if (v23)
      {
        if (*v24 != *(void *)(a4 + 20) || *(void *)(a1 + 2100) != *(void *)(a4 + 28))
        {
LABEL_34:
          if (*(void *)(a1 + 2092) != *v22 || *(void *)(a1 + 2100) != v22[1]) {
            goto LABEL_40;
          }
          goto LABEL_39;
        }
      }
      else
      {
        int v25 = *(_DWORD *)v24;
        if (v25 != *(_DWORD *)(a4 + 20))
        {
          if (v25) {
            goto LABEL_40;
          }
          goto LABEL_39;
        }
      }
      if (*(unsigned __int16 *)(a1 + 2108) == *(unsigned __int16 *)(a4 + 36)) {
        break;
      }
    }
    if (v23) {
      goto LABEL_34;
    }
    if (*(_DWORD *)(a1 + 2092)) {
      goto LABEL_40;
    }
LABEL_39:
    if (*(unsigned __int16 *)(a1 + 2108) == *(unsigned __int16 *)(a4 + 36)) {
      break;
    }
LABEL_40:
    if (a6[40]) {
      break;
    }
LABEL_46:
    a1 = *(void *)(a1 + 2144);
    if (!a1) {
      return v21;
    }
  }
  memset(v51, 170, sizeof(v51));
  int v28 = *a5;
  if (!v23 && (v28 & 1) != 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v29 = VRTraceErrorLogLevelToCSTR();
      int v30 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long v45 = 136315650;
        uint64_t v46 = v29;
        __int16 v47 = 2080;
        uint32_t v48 = "SendUDPPacketForCList";
        __int16 v49 = 1024;
        int v50 = 237;
        _os_log_impl(&dword_1E1EA4000, v30, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SendUDPPacketForCList: skip mismatched interface: IPv4", v45, 0x1Cu);
      }
    }
    goto LABEL_46;
  }
  if (v28)
  {
    socklen_t v44 = 28;
    uint64_t v31 = IPPORTToSA6();
  }
  else
  {
    socklen_t v44 = 16;
    uint64_t v31 = IPPORTToSA();
  }
  uint64_t v32 = (sockaddr *)v31;
  int v33 = *(_DWORD *)(a1 + 2120);
  if (v33 && *(_DWORD *)(a1 + 2116))
  {
    int v34 = *a6;
    goto LABEL_55;
  }
  int v34 = *a6;
  if ((*a6 | 4) != 6)
  {
    BOOL v36 = 0;
    *a6 = 0;
    BOOL v35 = 1;
    goto LABEL_58;
  }
LABEL_55:
  BOOL v35 = (v34 & 0xFFFFFFFE) != 4;
  BOOL v36 = (v34 & 0xFFFFFFFE) == 4;
  if ((v34 | 4) != 6) {
LABEL_58:
  }
    a6[1] = v33;
  a6[37] = v36;
  if (v35 || (uint64_t v37 = *(void *)(a1 + 2136), v37 == 0xFFFFFFFFLL)) {
    int v38 = VTP_Sendto(*(_DWORD *)a1, v42, a3, 0, (uint64_t)v32, v44, a6);
  }
  else {
    int v38 = ARPL_Sendto(v37, *(_DWORD *)a1, v42, a3, 0, v32, v44, a6);
  }
  if (v38 == -1) {
    return *__error() | 0xC00F0000;
  }
  else {
    return 0;
  }
}

uint64_t TPEnsureRecvProcStarted(void *a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (pthread_rwlock_t *)(a2 + 1064);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a2 + 1064));
  uint64_t v5 = (uint64_t *)(a2 + 24);
  if (*(void *)(a2 + 24))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      uint64_t v6 = VRTraceErrorLogLevelToCSTR();
      uint64_t v7 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v14 = 136315650;
        uint64_t v15 = v6;
        __int16 v16 = 2080;
        uint64_t v17 = "TPEnsureRecvProcStarted";
        __int16 v18 = 1024;
        int v19 = 2589;
        _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPRecvProc already started", (uint8_t *)&v14, 0x1Cu);
      }
    }
    VTP_Close(*(_DWORD *)(a2 + 12));
    uint64_t v8 = 0;
    *(_DWORD *)(a2 + 12) = -1;
  }
  else
  {
    int v10 = pthread_create((pthread_t *)(a2 + 24), 0, (void *(__cdecl *)(void *))TPRecvProc, a1);
    if (!v10)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        uint64_t v11 = VRTraceErrorLogLevelToCSTR();
        int v12 = *MEMORY[0x1E4F47A50];
        uint64_t v8 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_6;
        }
        uint64_t v13 = *v5;
        int v14 = 136315906;
        uint64_t v15 = v11;
        __int16 v16 = 2080;
        uint64_t v17 = "TPEnsureRecvProcStarted";
        __int16 v18 = 1024;
        int v19 = 2587;
        __int16 v20 = 2048;
        uint64_t v21 = v13;
        _os_log_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPRecvProc(%p) started", (uint8_t *)&v14, 0x26u);
      }
      uint64_t v8 = 0;
      goto LABEL_6;
    }
    uint64_t v8 = v10 | 0xC00F0000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        TPEnsureRecvProcStarted_cold_1();
      }
    }
  }
LABEL_6:
  pthread_rwlock_unlock(v4);
  return v8;
}

uint64_t TPRecvProc(uint64_t a1)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  unint64_t v32 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
  pthread_setname_np("com.apple.avconference.transport.recvproc");
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v2 = VRTraceErrorLogLevelToCSTR();
    uint64_t v3 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = v2;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "TPRecvProc";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&unsigned char buf[24] = 1733;
      _os_log_impl(&dword_1E1EA4000, v3, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Transport(UDP) Thread start...", buf, 0x1Cu);
    }
  }
  uint64_t v4 = CheckInHandleDebug();
  if (!v4) {
    return -2146500606;
  }
  uint64_t v5 = v4;
  double v6 = micro();
  signed int v7 = 0;
LABEL_6:
  double v8 = v6 + 30.0;
  while (1)
  {
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    memset(buf, 0, sizeof(buf));
    pthread_rwlock_rdlock((pthread_rwlock_t *)(v5 + 1064));
    pthread_rwlock_rdlock((pthread_rwlock_t *)(v5 + 1272));
    if (*(_DWORD *)(v5 + 8))
    {
      pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1272));
      pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1064));
      goto LABEL_64;
    }
    if (*(_DWORD *)(v5 + 12) == -1) {
      *(_DWORD *)(v5 + 12) = VTP_Socket(2, 1, 6);
    }
    pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1272));
    unint64_t v9 = *(int *)(v5 + 12);
    if (v9 == -1) {
      break;
    }
    if (__darwin_check_fd_set_overflow(*(_DWORD *)(v5 + 12), buf, 0)) {
      *(_DWORD *)&buf[(v9 >> 3) & 0x1FFFFFFFFFFFFFFCLL] |= 1 << v9;
    }
    int v10 = *(_DWORD *)(v5 + 12);
    for (uint64_t i = *(void *)(v5 + 1056); i; uint64_t i = *(void *)(i + 2144))
    {
      int v12 = *(_DWORD *)i;
      if (__darwin_check_fd_set_overflow(*(_DWORD *)i, buf, 0)) {
        *(_DWORD *)&buf[((unint64_t)v12 >> 3) & 0x1FFFFFFFFFFFFFFCLL] |= 1 << v12;
      }
      if (*(_DWORD *)i > v10) {
        int v10 = *(_DWORD *)i;
      }
    }
    pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1064));
    pthread_rwlock_rdlock((pthread_rwlock_t *)(v5 + 1272));
    for (uint64_t j = *(void *)(v5 + 1264); j; uint64_t j = *(void *)(j + 2144))
    {
      int v14 = *(_DWORD *)j;
      if (__darwin_check_fd_set_overflow(*(_DWORD *)j, buf, 0)) {
        *(_DWORD *)&buf[((unint64_t)v14 >> 3) & 0x1FFFFFFFFFFFFFFCLL] |= 1 << v14;
      }
      if (*(_DWORD *)j > v10) {
        int v10 = *(_DWORD *)j;
      }
    }
    pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1272));
    double v15 = v8 - micro();
    if (v15 <= 0.0)
    {
LABEL_55:
      double v6 = micro();
      SendRelayHB();
      goto LABEL_6;
    }
    unint64_t v32 = (int)v15;
    LODWORD(v33) = (int)((v15 - (double)(int)v15) * 1000000.0);
    uint64_t v16 = (v10 + 1);
    int v17 = VTP_Select(v16, (long long *)buf, 0, 0, (uint64_t)&v32);
    if (v17 == -1)
    {
      if (*__error() != 9)
      {
        signed int v7 = *__error() | 0xC00F0000;
        int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (ErrorLogLevelForModule >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            TPRecvProc_cold_2();
          }
        }
        goto LABEL_64;
      }
    }
    else
    {
      if (!v17) {
        goto LABEL_55;
      }
      pthread_rwlock_rdlock((pthread_rwlock_t *)(v5 + 1064));
      for (uint64_t k = *(void *)(v5 + 1056); k; uint64_t k = *(void *)(k + 2144))
      {
        int v19 = *(_DWORD *)k;
        if (__darwin_check_fd_set_overflow(*(_DWORD *)k, buf, 0))
        {
          if ((*(_DWORD *)&buf[((unint64_t)v19 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v19))
          {
            unint64_t v32 = 0;
            LODWORD(v33) = 0;
            int v20 = *(_DWORD *)k;
            if (__darwin_check_fd_set_overflow(*(_DWORD *)k, buf, 0))
            {
              if ((*(_DWORD *)&buf[((unint64_t)v20 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v20))
              {
                while (1)
                {
                  signed int v21 = RecvMessageUDP(a1, v5, k);
                  if (v21 < 0) {
                    break;
                  }
                  if ((int)VTP_Select(v16, (long long *)buf, 0, 0, (uint64_t)&v32) > 0)
                  {
                    int v22 = *(_DWORD *)k;
                    if (__darwin_check_fd_set_overflow(*(_DWORD *)k, buf, 0))
                    {
                      if ((*(_DWORD *)&buf[((unint64_t)v22 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v22)) {
                        continue;
                      }
                    }
                  }
                  signed int v7 = 0;
                  goto LABEL_41;
                }
                signed int v7 = v21;
              }
            }
          }
        }
LABEL_41:
        ;
      }
      pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1064));
      pthread_rwlock_rdlock((pthread_rwlock_t *)(v5 + 1272));
      for (uint64_t m = *(void *)(v5 + 1264); m; uint64_t m = *(void *)(m + 2144))
      {
        int v24 = *(_DWORD *)m;
        if (__darwin_check_fd_set_overflow(*(_DWORD *)m, buf, 0))
        {
          if ((*(_DWORD *)&buf[((unint64_t)v24 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v24))
          {
            unint64_t v32 = 0;
            LODWORD(v33) = 0;
            int v25 = *(_DWORD *)m;
            if (__darwin_check_fd_set_overflow(*(_DWORD *)m, buf, 0))
            {
              if ((*(_DWORD *)&buf[((unint64_t)v25 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v25))
              {
                while (1)
                {
                  signed int v26 = RecvMessageUDP(a1, v5, m);
                  if (v26 < 0) {
                    break;
                  }
                  if ((int)VTP_Select(v16, (long long *)buf, 0, 0, (uint64_t)&v32) > 0)
                  {
                    int v27 = *(_DWORD *)m;
                    if (__darwin_check_fd_set_overflow(*(_DWORD *)m, buf, 0))
                    {
                      if ((*(_DWORD *)&buf[((unint64_t)v27 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v27)) {
                        continue;
                      }
                    }
                  }
                  signed int v7 = 0;
                  goto LABEL_53;
                }
                signed int v7 = v26;
              }
            }
          }
        }
LABEL_53:
        ;
      }
      pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1272));
    }
  }
  pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1064));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      TPRecvProc_cold_1();
    }
  }
LABEL_64:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v30 = VRTraceErrorLogLevelToCSTR();
    uint64_t v31 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int v34 = 136315906;
      uint64_t v35 = v30;
      __int16 v36 = 2080;
      uint64_t v37 = "TPRecvProc";
      __int16 v38 = 1024;
      int v39 = 1880;
      __int16 v40 = 1024;
      signed int v41 = v7;
      _os_log_impl(&dword_1E1EA4000, v31, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Transport(UDP) Thread end(%08X)...", v34, 0x22u);
    }
  }
  CheckOutHandleDebug();
  return v7;
}

void SendRelayHB()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  int v2 = -1431655766;
  int v3 = -1431655766;
  uint64_t v1 = 0;
  DLFindActiveDialogs(&v3, &v1);
  if (v3 < 1)
  {
    ICERefreshAllRelayBinding();
  }
  else
  {
    for (uint64_t i = 0; i < v3; ++i)
    {
      DLGetCallID(*((void *)v1 + i), &v2);
      ICERefreshRelayBinding();
    }
    if (v1) {
      free(v1);
    }
  }
}

uint64_t RecvMessageUDP(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v116 = *MEMORY[0x1E4F143B8];
  int v90 = 0;
  memset(__b, 170, sizeof(__b));
  if (*(_DWORD *)(a3 + 2120) && *(_DWORD *)(a3 + 2116) && *(void *)(a3 + 2136) != 0xFFFFFFFFLL
    || (VTP_Recvfrom(*(_DWORD *)a3, &v90) & 0x80000000) != 0)
  {
    uint64_t v10 = *__error() | 0xC00F0000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v11 = VRTraceErrorLogLevelToCSTR();
      int v12 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v13 = *(_DWORD *)a3;
        *(_DWORD *)buf = 136316418;
        *(void *)&uint8_t buf[4] = v11;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "RecvMessageUDP";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = 1473;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 1473;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v13;
        *(_WORD *)&buf[40] = 1024;
        *(_DWORD *)&buf[42] = v10;
        _os_log_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transport.c:%d: recvfrom(%d) failed(%08X)", buf, 0x2Eu);
      }
    }
    return v10;
  }
  double v6 = v90;
  if (*((void *)v90 + 65) >= 0x800uLL) {
    size_t v7 = 2048;
  }
  else {
    size_t v7 = *((void *)v90 + 65);
  }
  double v8 = (_DWORD *)(a3 + 12);
  memcpy((void *)(a3 + 12), *((const void **)v90 + 66), v7);
  if (!v7)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
      return 0;
    }
    uint64_t v15 = VRTraceErrorLogLevelToCSTR();
    uint64_t v16 = *MEMORY[0x1E4F47A50];
    uint64_t v10 = 0;
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      return v10;
    }
    int v17 = *(_DWORD *)a3;
    *(_DWORD *)buf = 136316162;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "RecvMessageUDP";
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)&unsigned char buf[24] = 1469;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = 1469;
    *(_WORD *)&buf[34] = 1024;
    *(_DWORD *)&buf[36] = v17;
    __int16 v18 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transport.c"
          ":%d: recvfrom(%d) returned 0: empty message";
LABEL_22:
    int v19 = v16;
    uint32_t v20 = 40;
LABEL_23:
    _os_log_impl(&dword_1E1EA4000, v19, OS_LOG_TYPE_DEFAULT, v18, buf, v20);
    return 0;
  }
  *((_WORD *)v6 + 88) = *(_WORD *)(a3 + 2108);
  *((_DWORD *)v6 + 35) |= *(_DWORD *)(a3 + 2072);
  if (*(_DWORD *)(a3 + 2120) && *(_DWORD *)(a3 + 2116))
  {
    int v9 = *((_DWORD *)v6 + 46);
    goto LABEL_16;
  }
  int v9 = *((_DWORD *)v6 + 46);
  if ((v9 | 4) == 6)
  {
LABEL_16:
    char v14 = 1;
    switch(v9)
    {
      case 0:
        goto LABEL_25;
      case 1:
      case 2:
      case 6:
        goto LABEL_42;
      case 3:
        if (DTLS_IsConnected()) {
          return 0;
        }
        goto LABEL_42;
      case 4:
        if (!v6[196] || !DTLS_IsConnected()) {
          return 0;
        }
        goto LABEL_42;
      case 5:
        if (!v6[196]) {
          goto LABEL_96;
        }
        if (DTLS_IsConnected()) {
          goto LABEL_42;
        }
        if (!v90[196])
        {
LABEL_96:
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            uint64_t v66 = VRTraceErrorLogLevelToCSTR();
            v67 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              *(void *)&uint8_t buf[4] = v66;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = "RecvMessageUDP";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&unsigned char buf[24] = 1536;
              _os_log_impl(&dword_1E1EA4000, v67, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d >>>> SKIPPING INCOMING ARPL PACKET! <!bEncrypted>  (in Transport) <<<<<", buf, 0x1Cu);
            }
          }
        }
        if (DTLS_IsConnected() || (int)VRTraceGetErrorLogLevelForModule() < 7) {
          return 0;
        }
        uint64_t v68 = VRTraceErrorLogLevelToCSTR();
        long long v69 = *MEMORY[0x1E4F47A50];
        uint64_t v10 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
          return v10;
        }
        *(_DWORD *)buf = 136315650;
        *(void *)&uint8_t buf[4] = v68;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "RecvMessageUDP";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = 1539;
        __int16 v18 = "SIP [%s] %s:%d >>>> SKIPPING INCOMING ARPL PACKET! <!DTLS_IsConnected(pCList->hDTLS)>  (in Transport) <<<<<";
        int v19 = v69;
        uint32_t v20 = 28;
        break;
      default:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v22 = VRTraceErrorLogLevelToCSTR();
          int v23 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            int v24 = *((_DWORD *)v90 + 47);
            *(_DWORD *)buf = 136315906;
            *(void *)&uint8_t buf[4] = v22;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "RecvMessageUDP";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 1553;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v24;
            _os_log_impl(&dword_1E1EA4000, v23, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d RecvMessageUDP: ignore unrecognized OFT packet for callID %08X", buf, 0x22u);
          }
        }
        if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
          return 0;
        }
        uint64_t v25 = VRTraceErrorLogLevelToCSTR();
        uint64_t v16 = *MEMORY[0x1E4F47A50];
        uint64_t v10 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
          return v10;
        }
        int v26 = *(_DWORD *)(a3 + 2064);
        int v27 = *(_DWORD *)(a3 + 2120);
        *(_DWORD *)buf = 136316162;
        *(void *)&uint8_t buf[4] = v25;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "RecvMessageUDP";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = 1554;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v26;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v27;
        __int16 v18 = "SIP [%s] %s:%d RecvMessageUDP: localCallID == %08X remoteCallID == %08X";
        goto LABEL_22;
    }
    goto LABEL_23;
  }
  *((_DWORD *)v6 + 46) = 0;
LABEL_25:
  __strncpy_chk();
  __b[v7] = 0;
  signed int v21 = strchr(__b, 10);
  if (v21) {
    char *v21 = 0;
  }
  if (strnstr(__b, "SIP/", v7))
  {
    uint64_t v10 = 0;
    if (*(void *)(a3 + 2128) != 0xFFFFFFFFLL) {
      return v10;
    }
    char v14 = 0;
  }
  else
  {
    char v14 = 1;
  }
LABEL_42:
  if ((*((_DWORD *)v90 + 46) | 4) == 4) {
    *(unsigned char *)(a3 + v7 + 12) = 0;
  }
  uint64_t v109 = 0;
  v110 = &v109;
  uint64_t v111 = 0x4000000000;
  *(void *)&long long v28 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v112 = v28;
  long long v113 = v28;
  unint64_t v114 = 0xAAAAAAAAAAAAAAAALL;
  SAToIPPORT();
  if ((v14 & 1) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v55 = VRTraceErrorLogLevelToCSTR();
      addrinfo v56 = *MEMORY[0x1E4F47A50];
      long long v57 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = v55;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "RecvMessageUDP";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 1567;
          _os_log_impl(&dword_1E1EA4000, v56, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d RecvMessageUDP: pass message SIP", buf, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
      {
        RecvMessageUDP_cold_2();
      }
    }
    *(void *)&long long v106 = 0;
    *((void *)&v106 + 1) = &v106;
    *(void *)v107 = 0x4000000000;
    *(_OWORD *)&v107[8] = *(_OWORD *)(v90 + 140);
    *(_OWORD *)&v107[24] = *(_OWORD *)(v90 + 156);
    uint64_t v108 = *(void *)(v90 + 172);
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x16000000000;
    memcpy(&buf[24], v90 + 184, 0x148uLL);
    uint32_t v64 = malloc_type_malloc(v7 + 1, 0x2449DABBuLL);
    memcpy(v64, v8, v7 + 1);
    *((unsigned char *)v64 + v7) = 0;
    global_queue = dispatch_get_global_queue(2, 0);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = __RecvMessageUDP_block_invoke;
    block[3] = &unk_1E6DB7098;
    block[7] = a1;
    void block[8] = v64;
    int v89 = v7;
    block[4] = buf;
    block[5] = &v106;
    block[6] = &v109;
    dispatch_async(global_queue, block);
    _Block_object_dispose(buf, 8);
    _Block_object_dispose(&v106, 8);
    goto LABEL_93;
  }
  int v29 = *((_DWORD *)v90 + 46);
  if (v7 != 16 || v29 || *v8 != 0x1000000)
  {
    long long v58 = (void *)(a2 + 34544);
    switch(v29)
    {
      case 2:
      case 6:
        long long v59 = (pthread_mutex_t *)(a2 + 34584);
        pthread_mutex_lock((pthread_mutex_t *)(a2 + 34584));
        long long v60 = *(void (**)(uint64_t, _DWORD *, size_t, void, void, void))(a2 + 34552);
        if (!v60)
        {
          __int16 v54 = (pthread_mutex_t *)(a2 + 34584);
          goto LABEL_77;
        }
        uint64_t v62 = *(void *)(a2 + 34560);
        long long v61 = (void (*)(uint64_t))v58[3];
        uint64_t v63 = (void (*)(uint64_t))v58[4];
        if (v61 && v62) {
          v61(v62);
        }
        pthread_mutex_unlock(v59);
        v60(v62, v8, v7, *((unsigned int *)v90 + 47), v90[196], *((unsigned int *)v90 + 46));
        if (v63 && v62) {
          v63(v62);
        }
        goto LABEL_93;
      case 4:
        BOOL v83 = malloc_type_malloc(v7 + 1, 0x6C26E4FBuLL);
        memcpy(v83, v8, v7 + 1);
        v84 = v90;
        memcpy(buf, v90 + 184, 0x148uLL);
        int v85 = dispatch_get_global_queue(2, 0);
        v91[0] = MEMORY[0x1E4F143A8];
        v91[1] = 0x40000000;
        v91[2] = __RecvMessageUDP_block_invoke_11;
        v91[3] = &unk_1E6DB70C0;
        v91[5] = a1;
        v91[6] = v83;
        int v94 = v7;
        memcpy(v92, buf, sizeof(v92));
        v93 = v84;
        v91[4] = &v109;
        dispatch_async(v85, v91);
        goto LABEL_93;
      case 5:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v86 = VRTraceErrorLogLevelToCSTR();
          uint64_t v87 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            *(void *)&uint8_t buf[4] = v86;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "RecvMessageUDP";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 1629;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = v8;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v7;
            _os_log_impl(&dword_1E1EA4000, v87, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d >>>>> Received incoming ARPL data with szMessage=[%s] and length=[%d] <NEED TO DO SOMETHING HERE> (in Transport) <<<<<", buf, 0x2Cu);
          }
        }
        (*(void (**)(void))(*v58 + 16))();
        goto LABEL_93;
      default:
        uint64_t v71 = malloc_type_calloc(1uLL, 0x868uLL, 0x1020040D8EC2E6EuLL);
        if (v71)
        {
          uint64_t v72 = v71;
          __memcpy_chk();
          uint64_t v73 = v110[7];
          long long v74 = *(_OWORD *)(v110 + 5);
          v72[131] = *(_OWORD *)(v110 + 3);
          v72[132] = v74;
          *((void *)v72 + 266) = v73;
          *((_DWORD *)v72 + 513) = v7;
          v75 = v90;
          long long v76 = *(_OWORD *)(v90 + 156);
          long long v77 = *(_OWORD *)(v90 + 140);
          *((void *)v72 + 261) = *(void *)(v90 + 172);
          *(_OWORD *)((char *)v72 + 2056) = v77;
          *(_OWORD *)((char *)v72 + 2072) = v76;
          *((void *)v72 + 267) = *(void *)v75;
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 1544 + ((uint64_t)*((int *)v75 + 46) << 7) + 16));
          uint64_t v78 = *((int *)v90 + 46);
          v79 = (void *)(a2 + 1544 + (v78 << 7) + 8);
          do
          {
            uint64_t v80 = v79;
            uint64_t v81 = *v79;
            v79 = (void *)(*v79 + 2144);
          }
          while (v81);
          *uint64_t v80 = v72;
          uint64_t v82 = a2 + 1544;
          pthread_cond_signal((pthread_cond_t *)(v82 + (v78 << 7) + 80));
          __int16 v54 = (pthread_mutex_t *)(v82 + ((uint64_t)*((int *)v90 + 46) << 7) + 16);
          goto LABEL_77;
        }
        uint64_t v10 = 2148466691;
        VTP_ReleasePacket((void **)&v90);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            RecvMessageUDP_cold_1();
          }
        }
        break;
    }
    goto LABEL_94;
  }
  uint64_t v30 = v110;
  uint64_t v31 = v110 + 3;
  *(void *)&buf[46] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v32 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&buf[16] = v32;
  *(_OWORD *)&uint8_t buf[32] = v32;
  *(_OWORD *)buf = v32;
  *(void *)&v107[30] = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)v107 = v32;
  *(_OWORD *)&v107[16] = v32;
  long long v106 = v32;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v33 = VRTraceErrorLogLevelToCSTR();
    int v34 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v35 = IPPORTToStringWithSize();
      uint64_t v36 = IPPORTToStringWithSize();
      *(_DWORD *)unsigned int v95 = 136316162;
      uint64_t v96 = v33;
      __int16 v97 = 2080;
      v98 = "RecvMessageUDP";
      __int16 v99 = 1024;
      int v100 = 1593;
      __int16 v101 = 2080;
      uint64_t v102 = v35;
      __int16 v103 = 2080;
      uint64_t v104 = v36;
      _os_log_impl(&dword_1E1EA4000, v34, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Updating heartbeat from %s to %s", v95, 0x30u);
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 992));
  uint64_t v37 = 0;
  int v38 = 0;
  int v39 = v90;
  __int16 v40 = v90 + 140;
  int v41 = *((_DWORD *)v90 + 35) & 1;
  uint64_t v42 = -960;
  double v43 = 1.0e10;
  while (1)
  {
    uint64_t v44 = a2 + v42;
    if ((*(_DWORD *)(a2 + v42 + 1000) & 1) != v41) {
      goto LABEL_72;
    }
    long long v45 = (void *)(v44 + 1020);
    if (v41)
    {
      if (*v45 != *((void *)v90 + 20) || *(void *)(v44 + 1028) != *((void *)v90 + 21)) {
        goto LABEL_72;
      }
    }
    else if (*(_DWORD *)v45 != *((_DWORD *)v90 + 40))
    {
      goto LABEL_72;
    }
    if (*(unsigned __int16 *)(a2 + v42 + 1036) != *((unsigned __int16 *)v90 + 88)
      || (*(_DWORD *)(a2 + v42 + 1040) & 1) != (*(_DWORD *)v31 & 1))
    {
      goto LABEL_72;
    }
    long long v47 = (void *)(a2 + v42 + 1060);
    if ((*(_DWORD *)(a2 + v42 + 1040) & 1) == 0) {
      break;
    }
    if (*v47 == *(uint64_t *)((char *)v30 + 44) && *(void *)(a2 + v42 + 1068) == *(uint64_t *)((char *)v30 + 52)) {
      goto LABEL_71;
    }
LABEL_72:
    if (*(double *)(v44 + 1080) < v43)
    {
      int v38 = v37;
      double v43 = *(double *)(v44 + 1080);
    }
    ++v37;
    v42 += 96;
    if (!v42)
    {
      uint64_t v37 = v38;
      uint64_t v49 = a2 + 96 * v38;
      *(_DWORD *)(v49 + 32) = 0;
      long long v50 = *(_OWORD *)v40;
      long long v51 = *((_OWORD *)v40 + 1);
      *(void *)(v49 + 72) = *((void *)v40 + 4);
      *(_OWORD *)(v49 + 56) = v51;
      *(_OWORD *)(v49 + 40) = v50;
      long long v52 = *(_OWORD *)v31;
      long long v53 = *((_OWORD *)v31 + 1);
      *(void *)(v49 + 112) = v31[4];
      *(_OWORD *)(v49 + 80) = v52;
      *(_OWORD *)(v49 + 96) = v53;
      goto LABEL_76;
    }
  }
  if (*(_DWORD *)v47 != *((_DWORD *)v30 + 11)) {
    goto LABEL_72;
  }
LABEL_71:
  if (*(_DWORD *)(a2 + v42 + 996)) {
    goto LABEL_72;
  }
  *(_WORD *)(a2 + v42 + 1076) = *((_WORD *)v30 + 30);
LABEL_76:
  *(void *)(a2 + 96 * v37 + 120) = *v39;
  __int16 v54 = (pthread_mutex_t *)(a2 + 992);
LABEL_77:
  pthread_mutex_unlock(v54);
LABEL_93:
  VTP_ReleasePacket((void **)&v90);
  uint64_t v10 = 0;
LABEL_94:
  _Block_object_dispose(&v109, 8);
  return v10;
}

void __RecvMessageUDP_block_invoke(uint64_t a1)
{
  PassMessage(*(void *)(a1 + 56));
  int v2 = *(void **)(a1 + 64);

  free(v2);
}

void PassMessage(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  int v2 = v1;
  uint64_t v4 = v3;
  double v6 = v5;
  int v8 = v7;
  uint64_t v10 = v9;
  uint64_t v141 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v139 = v11;
  long long v140 = v11;
  *(_OWORD *)__s2 = v11;
  *(void *)((char *)v137 + 14) = 0xAAAAAAAAAAAAAAAALL;
  long long v136 = v11;
  v137[0] = v11;
  long long v135 = v11;
  v120 = (void *)0xAAAAAAAAAAAAAAAALL;
  int v12 = strstr(v9, "\r\n\r\n");
  if (v12)
  {
    v12[2] = 0;
    int v13 = (uint8_t *)(v12 + 4);
    int v14 = v10 - (v12 + 4) + v8;
  }
  else
  {
    int v14 = 0;
    int v13 = (uint8_t *)&v10[strlen(v10)];
  }
  uint64_t v15 = (v8 + 1);
  ReplaceKeyword(v10, v15, "\r\n ", "", 1);
  ReplaceKeyword(v10, v15, "\r\n\t", "", 1);
  if (v14 >= 1)
  {
    uint64_t v16 = 0;
    uint64_t v17 = MEMORY[0x1E4F14390];
    while (1)
    {
      unsigned int v18 = (char)v13[v16];
      if ((v18 & 0x80000000) != 0)
      {
        if (!__maskrune((char)v13[v16], 0x40000uLL) && !__maskrune(v18, 0x4000uLL)) {
          goto LABEL_15;
        }
      }
      else
      {
        int v19 = *(_DWORD *)(v17 + 4 * v18 + 60);
        if ((v19 & 0x40000) == 0 && (v19 & 0x4000) == 0) {
          goto LABEL_15;
        }
      }
      if (v14 == ++v16) {
        goto LABEL_16;
      }
    }
  }
  LODWORD(v16) = 0;
LABEL_15:
  if (v16 == v14)
  {
LABEL_16:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v20 = VRTraceErrorLogLevelToCSTR();
      signed int v21 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316418;
        *(void *)&uint8_t buf[4] = v20;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "PassMessage";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = 1192;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = v10;
        *(_WORD *)&buf[38] = 2080;
        *(void *)&buf[40] = v13;
        *(_WORD *)&uint8_t buf[48] = 2080;
        *(void *)&buf[50] = IPPORTToStringWithSize();
        uint64_t v22 = "SIP [%s] %s:%d [[%s\n%s]] from %s";
        int v23 = v21;
        uint32_t v24 = 58;
LABEL_22:
        _os_log_impl(&dword_1E1EA4000, v23, OS_LOG_TYPE_DEFAULT, v22, buf, v24);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v25 = VRTraceErrorLogLevelToCSTR();
    int v26 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = v25;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "PassMessage";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&unsigned char buf[24] = 1195;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = v10;
      *(_WORD *)&buf[38] = 2080;
      *(void *)&buf[40] = IPPORTToStringWithSize();
      uint64_t v22 = "SIP [%s] %s:%d [[%s\n<binary>]] from %s";
      int v23 = v26;
      uint32_t v24 = 48;
      goto LABEL_22;
    }
  }
  if ((ParseMessage(&v120, v10) & 0x80000000) == 0)
  {
    int v27 = v120;
    if (*((_DWORD *)v120 + 1) == 1 && *((_DWORD *)v120 + 2) == 1 && !*((void *)v120 + 28))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
        goto LABEL_74;
      }
      uint64_t v91 = VRTraceErrorLogLevelToCSTR();
      int v90 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = v91;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "PassMessage";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&unsigned char buf[24] = 1207;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 1207;
      double v43 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transport"
            ".c:%d: INVITE doesn't have Contact header.";
    }
    else
    {
      *((_DWORD *)v120 + 140) = v14;
      if (v6)
      {
        long long v28 = *v6;
        long long v29 = v6[1];
        long long v30 = v6[3];
        v27[38] = v6[2];
        v27[39] = v30;
        v27[36] = v28;
        v27[37] = v29;
        long long v31 = v6[4];
        long long v32 = v6[5];
        long long v33 = v6[6];
        *((void *)v27 + 86) = *((void *)v6 + 14);
        v27[41] = v32;
        v27[42] = v33;
        v27[40] = v31;
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v34 = VRTraceErrorLogLevelToCSTR();
        uint64_t v35 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = v34;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "PassMessage";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 1219;
          _os_log_impl(&dword_1E1EA4000, v35, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d doesn't have valid source destination info", buf, 0x1Cu);
        }
      }
      uint64_t v36 = (char *)v120;
      uint64_t v37 = (int *)*((void *)v120 + 32);
      if (v37)
      {
        int v38 = *v37;
        if (*v37 < 0)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
            goto LABEL_74;
          }
          uint64_t v40 = VRTraceErrorLogLevelToCSTR();
          int v41 = *MEMORY[0x1E4F47A50];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_74;
          }
          int v42 = *v37;
          *(_DWORD *)buf = 136316162;
          *(void *)&uint8_t buf[4] = v40;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "PassMessage";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 1232;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 1232;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v42;
          double v43 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Trans"
                "port.c:%d: CONTENT-LENGTH less than 0 (%d).";
          uint64_t v44 = v41;
          uint32_t v45 = 40;
          goto LABEL_73;
        }
        if (*((void *)v120 + 66) || *((void *)v120 + 30))
        {
          int v39 = *((_DWORD *)v120 + 140);
          if (v38 <= v39)
          {
            *((_DWORD *)v120 + 140) = v38;
          }
          else
          {
            if (v38 - v39 > 15)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
                goto LABEL_74;
              }
              uint64_t v93 = VRTraceErrorLogLevelToCSTR();
              int v94 = *MEMORY[0x1E4F47A50];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_74;
              }
              int v95 = *v37;
              int v96 = *((_DWORD *)v120 + 140);
              *(_DWORD *)buf = 136316418;
              *(void *)&uint8_t buf[4] = v93;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = "PassMessage";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&unsigned char buf[24] = 1254;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = 1254;
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = v95;
              *(_WORD *)&buf[40] = 1024;
              *(_DWORD *)&buf[42] = v96;
              double v43 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/T"
                    "ransport.c:%d: CONTENT-LENGTH incorrect (%d/%d).";
              uint64_t v44 = v94;
              uint32_t v45 = 46;
              goto LABEL_73;
            }
            *uint64_t v37 = v39;
          }
        }
      }
      *(_DWORD *)uint64_t v36 = 3;
      if (*((_DWORD *)v36 + 1) == 1 && *((_DWORD *)v36 + 2) == 1)
      {
        long long v46 = *v4;
        long long v47 = v4[1];
        *((void *)v36 + 91) = *((void *)v4 + 4);
        *(_OWORD *)(v36 + 696) = v46;
        *(_OWORD *)(v36 + 712) = v47;
        long long v48 = *v2;
        long long v49 = v2[1];
        *((void *)v36 + 96) = *((void *)v2 + 4);
        *((_OWORD *)v36 + 46) = v48;
        *((_OWORD *)v36 + 47) = v49;
        long long v50 = *v2;
        long long v51 = v2[1];
        *((void *)v36 + 106) = *((void *)v2 + 4);
        *((_OWORD *)v36 + 51) = v50;
        *((_OWORD *)v36 + 52) = v51;
      }
      else
      {
        uint64_t v119 = 0xAAAAAAAAAAAAAAAALL;
        memset(buf, 170, 0x388uLL);
        uint64_t v52 = *((void *)v4 + 4);
        long long v53 = v4[1];
        *(_OWORD *)(v36 + 696) = *v4;
        *(_OWORD *)(v36 + 712) = v53;
        *((void *)v36 + 91) = v52;
        long long v55 = *v2;
        long long v54 = v2[1];
        *((void *)v36 + 96) = *((void *)v2 + 4);
        *((_OWORD *)v36 + 46) = v55;
        *((_OWORD *)v36 + 47) = v54;
        long long v57 = *v2;
        long long v56 = v2[1];
        *((void *)v36 + 106) = *((void *)v2 + 4);
        *((_OWORD *)v36 + 51) = v57;
        *((_OWORD *)v36 + 52) = v56;
        if ((DLFindWithSipMsgAndLock(&v119, (uint64_t)v36) & 0x80000000) != 0)
        {
          uint64_t v73 = (char *)v120 + 776;
          long long v74 = (char *)v120 + 696;
          *((void *)v120 + 101) = *((void *)v120 + 91);
          long long v75 = v74[1];
          *uint64_t v73 = *v74;
          v73[1] = v75;
        }
        else
        {
          DLGetData(v119, (uint64_t)buf);
          DLUnlock();
          long long v58 = v120;
          long long v59 = (char *)v120 + 696;
          *((void *)v120 + 91) = *(void *)&buf[60];
          long long v60 = *(_OWORD *)&buf[44];
          *long long v59 = *(_OWORD *)&buf[28];
          v59[1] = v60;
          long long v61 = *(_OWORD *)&buf[84];
          v58[46] = *(_OWORD *)&buf[68];
          v58[47] = v61;
          *((void *)v58 + 96) = *(void *)&buf[100];
          *((void *)v58 + 101) = *(void *)&buf[140];
          long long v62 = *(_OWORD *)&buf[124];
          *(_OWORD *)((char *)v58 + 776) = *(_OWORD *)&buf[108];
          *(_OWORD *)((char *)v58 + 792) = v62;
          if (IsIPPORTValid())
          {
            *(void *)&v134[46] = 0xAAAAAAAAAAAAAAAALL;
            *(void *)&long long v63 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v63 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)&v134[32] = v63;
            *(_OWORD *)&v134[16] = v63;
            *(_OWORD *)v134 = v63;
            uint32_t v64 = v120;
            long long v65 = *(_OWORD *)&buf[188];
            long long v66 = *(_OWORD *)&buf[204];
            *((_OWORD *)v120 + 51) = *(_OWORD *)&buf[188];
            v64[52] = v66;
            uint64_t v67 = *(void *)&buf[220];
            *((void *)v64 + 106) = *(void *)&buf[220];
            *(_OWORD *)((char *)v64 + 856) = v65;
            *(_OWORD *)((char *)v64 + 872) = v66;
            *((void *)v64 + 111) = v67;
            *((_DWORD *)v64 + 142) = *(_DWORD *)&buf[24];
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              uint64_t v68 = VRTraceErrorLogLevelToCSTR();
              long long v69 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v70 = IPPORTToStringWithSize();
                int v71 = *((unsigned __int16 *)v120 + 284);
                int v72 = *((unsigned __int16 *)v120 + 285);
                int v122 = 136316418;
                uint64_t v123 = v68;
                __int16 v124 = 2080;
                v125 = "PassMessage";
                __int16 v126 = 1024;
                int v127 = 1295;
                __int16 v128 = 2080;
                uint64_t v129 = v70;
                __int16 v130 = 1024;
                int v131 = v71;
                __int16 v132 = 1024;
                int v133 = v72;
                _os_log_impl(&dword_1E1EA4000, v69, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Use relay external addr [%s], relay %u, channel %x", (uint8_t *)&v122, 0x32u);
              }
            }
          }
        }
      }
      IPToString();
      long long v76 = (unsigned int *)v120;
      uint64_t v77 = *((void *)v120 + 63);
      if (v77 && *(int *)v77 > 0)
      {
        if (!*(unsigned char *)(v77 + 118) && strcmp((const char *)(v77 + 12), __s2))
        {
          IPToString();
          long long v76 = (unsigned int *)v120;
        }
        if (*((void *)v76 + 34))
        {
          if ((int)v76[140] < 1)
          {
LABEL_106:
            uint64_t v108 = CheckInHandleDebug();
            if (v108)
            {
              uint64_t v109 = v108;
              uint64_t v110 = v108 + 34312;
              if (!*((void *)v76 + 63) || (uint64_t v111 = *((void *)v76 + 34)) == 0)
              {
                if (((*(uint64_t (**)(void, unsigned int *))v110)(*(void *)(v108 + 34320), v76) & 0x80000000) != 0
                  && (int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                    PassMessage_cold_4();
                  }
                }
                goto LABEL_149;
              }
              long long v112 = (pthread_mutex_t *)(v108 + 1480);
              pthread_mutex_lock((pthread_mutex_t *)(v108 + 1480));
              if (v76[1] == 1)
              {
                if (v76[2] == 2) {
                  int v113 = 1;
                }
                else {
                  int v113 = v76[2];
                }
                uint64_t v114 = *(void *)(v109 + 1472);
                if (v114)
                {
                  while (*(_DWORD *)v114 != 1
                       || strcmp((const char *)(v77 + 54), (const char *)(v114 + 4))
                       || strcmp((const char *)(v77 + 12), (const char *)(v114 + 72))
                       || *(unsigned __int16 *)(v77 + 52) != *(unsigned __int16 *)(v114 + 112)
                       || *(_DWORD *)(v114 + 68) != v113)
                  {
                    uint64_t v114 = *(void *)(v114 + 136);
                    if (!v114) {
                      goto LABEL_136;
                    }
                  }
                  if (((*(uint64_t (**)(void, unsigned int *))(v114 + 120))(*(void *)(v114 + 128), v76) & 0x80000000) != 0
                    && (int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                      PassMessage_cold_6();
                    }
                  }
LABEL_148:
                  pthread_mutex_unlock(v112);
LABEL_149:
                  CheckOutHandleDebug();
                  return;
                }
              }
              else
              {
                uint64_t v116 = *(void *)(v109 + 1472);
                if (v116)
                {
                  while (*(_DWORD *)v116
                       || strcmp((const char *)(v77 + 54), (const char *)(v116 + 4))
                       || *(_DWORD *)(v111 + 8) != *(_DWORD *)(v116 + 68))
                  {
                    uint64_t v116 = *(void *)(v116 + 136);
                    if (!v116) {
                      goto LABEL_136;
                    }
                  }
                  if (((*(uint64_t (**)(void, unsigned int *))(v116 + 120))(*(void *)(v116 + 128), v76) & 0x80000000) != 0
                    && (int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                      PassMessage_cold_7();
                    }
                  }
                  goto LABEL_148;
                }
              }
LABEL_136:
              pthread_mutex_unlock((pthread_mutex_t *)(v109 + 1480));
              if (((*(uint64_t (**)(void, unsigned int *))v110)(*(void *)(v110 + 8), v76) & 0x80000000) != 0
                && (int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  PassMessage_cold_5();
                }
              }
              goto LABEL_149;
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                PassMessage_cold_3();
              }
            }
            goto LABEL_74;
          }
          uint64_t v78 = (const char *)*((void *)v76 + 33);
          if (v78)
          {
            memset(buf, 170, 0x1518uLL);
            int v122 = 5400;
            v79 = (uint64_t (*)(void, uint8_t *, int *, uint8_t *, void, unsigned int *))*((void *)v76 + 127);
            if (!v79) {
              goto LABEL_97;
            }
            int v80 = v79(v76[252], buf, &v122, v13, v76[140], v76);
            if (v80 < 0)
            {
              int v98 = v80;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                uint64_t v99 = VRTraceErrorLogLevelToCSTR();
                int v100 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
                {
                  int v117 = *((_DWORD *)v120 + 252);
                  int v118 = *((_DWORD *)v120 + 140);
                  *(_DWORD *)v134 = 136316674;
                  *(void *)&v134[4] = v99;
                  *(_WORD *)&v134[12] = 2080;
                  *(void *)&v134[14] = "PassMessage";
                  *(_WORD *)&v134[22] = 1024;
                  *(_DWORD *)&v134[24] = 1340;
                  *(_WORD *)&v134[28] = 1024;
                  *(_DWORD *)&v134[30] = 1340;
                  *(_WORD *)&v134[34] = 1024;
                  *(_DWORD *)&v134[36] = v117;
                  *(_WORD *)&v134[40] = 1024;
                  *(_DWORD *)&v134[42] = v118;
                  *(_WORD *)&v134[46] = 1024;
                  *(_DWORD *)&v134[48] = v98;
                  _os_log_error_impl(&dword_1E1EA4000, v100, OS_LOG_TYPE_ERROR, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transport.c:%d: Decompress failed: %d, %d, (%08X)", v134, 0x34u);
                }
              }
              long long v76 = (unsigned int *)v120;
              *((_DWORD *)v120 + 33) = 1;
              goto LABEL_97;
            }
            buf[v122] = 0;
            int v81 = strcmp(v78, "application/sdp");
            int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
            if (v81)
            {
              if (ErrorLogLevelForModule < 7) {
                goto LABEL_96;
              }
              uint64_t v83 = VRTraceErrorLogLevelToCSTR();
              v84 = *MEMORY[0x1E4F47A50];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_96;
              }
              int v85 = *((_DWORD *)v120 + 140);
              *(_DWORD *)v134 = 136316162;
              *(void *)&v134[4] = v83;
              *(_WORD *)&v134[12] = 2080;
              *(void *)&v134[14] = "PassMessage";
              *(_WORD *)&v134[22] = 1024;
              *(_DWORD *)&v134[24] = 1349;
              *(_WORD *)&v134[28] = 1024;
              *(_DWORD *)&v134[30] = v85;
              *(_WORD *)&v134[34] = 1024;
              *(_DWORD *)&v134[36] = v122;
              uint64_t v86 = "SIP [%s] %s:%d Uncompress binary body from %d to %d";
              uint64_t v87 = v84;
              uint32_t v88 = 40;
            }
            else
            {
              if (ErrorLogLevelForModule < 6) {
                goto LABEL_96;
              }
              uint64_t v101 = VRTraceErrorLogLevelToCSTR();
              uint64_t v102 = *MEMORY[0x1E4F47A50];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_96;
              }
              int v103 = *((_DWORD *)v120 + 140);
              *(_DWORD *)v134 = 136316418;
              *(void *)&v134[4] = v101;
              *(_WORD *)&v134[12] = 2080;
              *(void *)&v134[14] = "PassMessage";
              *(_WORD *)&v134[22] = 1024;
              *(_DWORD *)&v134[24] = 1346;
              *(_WORD *)&v134[28] = 1024;
              *(_DWORD *)&v134[30] = v122;
              *(_WORD *)&v134[34] = 2080;
              *(void *)&v134[36] = buf;
              *(_WORD *)&v134[44] = 1024;
              *(_DWORD *)&v134[46] = v103;
              uint64_t v86 = "SIP [%s] %s:%d Uncompressed SDP(%d): [%s] from size %d";
              uint64_t v87 = v102;
              uint32_t v88 = 50;
            }
            _os_log_impl(&dword_1E1EA4000, v87, OS_LOG_TYPE_DEFAULT, v86, v134, v88);
LABEL_96:
            long long v76 = (unsigned int *)v120;
            *((_DWORD *)v120 + 140) = v122;
            int v13 = buf;
LABEL_97:
            if (strcmp(v78, "application/ske") && v14 >= 1)
            {
              uint64_t v104 = v14;
              int v105 = v13;
              do
              {
                if (*v105 == 240) {
                  *int v105 = 95;
                }
                ++v105;
                --v104;
              }
              while (v104);
              long long v76 = (unsigned int *)v120;
            }
            long long v106 = malloc_type_malloc((int)v76[140] + 1, 0x5C63A61CuLL);
            v107 = (int *)v120;
            *((void *)v120 + 69) = v106;
            if (v106)
            {
              memcpy(v106, v13, v107[140]);
              *(unsigned char *)(*((void *)v120 + 69) + *((int *)v120 + 140)) = 0;
              long long v76 = (unsigned int *)v120;
              goto LABEL_106;
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              uint64_t v115 = VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                PassMessage_cold_2(v115);
              }
            }
LABEL_74:
            FreeSipMsg(v120);
            return;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
            goto LABEL_74;
          }
          uint64_t v97 = VRTraceErrorLogLevelToCSTR();
          int v90 = *MEMORY[0x1E4F47A50];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_74;
          }
          *(_DWORD *)buf = 136315906;
          *(void *)&uint8_t buf[4] = v97;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "PassMessage";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 1327;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 1327;
          double v43 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Trans"
                "port.c:%d: CONTENT-TYPE null when body not empty.";
        }
        else
        {
          if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
            goto LABEL_74;
          }
          uint64_t v92 = VRTraceErrorLogLevelToCSTR();
          int v90 = *MEMORY[0x1E4F47A50];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_74;
          }
          *(_DWORD *)buf = 136315906;
          *(void *)&uint8_t buf[4] = v92;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "PassMessage";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 1316;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 1316;
          double v43 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Trans"
                "port.c:%d: CSeq header missing";
        }
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
          goto LABEL_74;
        }
        uint64_t v89 = VRTraceErrorLogLevelToCSTR();
        int v90 = *MEMORY[0x1E4F47A50];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_74;
        }
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = v89;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "PassMessage";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = 1305;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 1305;
        double v43 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transpo"
              "rt.c:%d: Via header missing or no field value";
      }
    }
    uint64_t v44 = v90;
    uint32_t v45 = 34;
LABEL_73:
    _os_log_impl(&dword_1E1EA4000, v44, OS_LOG_TYPE_DEFAULT, v43, buf, v45);
    goto LABEL_74;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      PassMessage_cold_1();
    }
  }
}

void __RecvMessageUDP_block_invoke_11(uint64_t a1)
{
  PassMessage(*(void *)(a1 + 40));
  int v2 = *(void **)(a1 + 48);

  free(v2);
}

uint64_t CompressMsg(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  uint64_t v5 = v4;
  int v7 = v6;
  int v9 = v8;
  long long v11 = v10;
  int v12 = (void *)v1;
  __str[2] = *MEMORY[0x1E4F143B8];
  __str[0] = 0xAAAAAAAAAAAAAAAALL;
  __str[1] = 0xAAAAAAAAAAAAAAAALL;
  memset(__b, 170, sizeof(__b));
  int __n = 5400;
  int v13 = *(int (**)(void, unsigned char *, int *, const char *, uint64_t, uint64_t))(v3 + 1016);
  if (v13) {
    BOOL v14 = v13(*(unsigned int *)(v3 + 1008), __b, &__n, v7, v5, v3) >= 0;
  }
  else {
    BOOL v14 = 0;
  }
  uint64_t v15 = ConstructSipMsg(v11, *v9, v3);
  if ((v15 & 0x80000000) == 0)
  {
    int v16 = *(_DWORD *)(v3 + 564);
    if (!v14)
    {
      if (!v16)
      {
        snprintf((char *)__str, 0x10uLL, "%d", v5);
        int v31 = strlen(v11);
        ReplaceKeyword(v11, (v31 + 1), "%CLENGTH%", (const char *)__str, 16);
        int v32 = strlen(v11);
        long long v33 = strncat(v11, v7, ~v32 + *v9);
        int v34 = strlen(v33);
        *int v9 = v34;
        memcpy(v12, v11, v34 + 1);
        return v15;
      }
      int v23 = v12;
      uint32_t v24 = v11;
      uint64_t v25 = v9;
      int v26 = v7;
      int v27 = v5;
      goto LABEL_20;
    }
    int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (v16)
    {
      if (ErrorLogLevelForModule < 7) {
        goto LABEL_19;
      }
      uint64_t v18 = VRTraceErrorLogLevelToCSTR();
      int v19 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_19;
      }
      int __n_4 = 136316162;
      uint64_t v37 = v18;
      __int16 v38 = 2080;
      int v39 = "CompressMsg";
      __int16 v40 = 1024;
      int v41 = 3037;
      __int16 v42 = 1024;
      int v43 = v5;
      __int16 v44 = 1024;
      LODWORD(v45) = __n;
      uint64_t v20 = "SIP [%s] %s:%d Compress binary body from %d to %d";
      signed int v21 = v19;
      uint32_t v22 = 40;
    }
    else
    {
      if (ErrorLogLevelForModule < 6) {
        goto LABEL_19;
      }
      uint64_t v28 = VRTraceErrorLogLevelToCSTR();
      long long v29 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_19;
      }
      int __n_4 = 136316418;
      uint64_t v37 = v28;
      __int16 v38 = 2080;
      int v39 = "CompressMsg";
      __int16 v40 = 1024;
      int v41 = 3039;
      __int16 v42 = 1024;
      int v43 = v5;
      __int16 v44 = 2080;
      uint32_t v45 = v7;
      __int16 v46 = 1024;
      int v47 = __n;
      uint64_t v20 = "SIP [%s] %s:%d Compress SDP(%d): [%s] to size %d";
      signed int v21 = v29;
      uint32_t v22 = 50;
    }
    _os_log_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&__n_4, v22);
LABEL_19:
    *(_DWORD *)(v3 + 564) = 1;
    memcpy(*(void **)(v3 + 552), __b, __n);
    int v27 = __n;
    *(_DWORD *)(v3 + 560) = __n;
    int v26 = __b;
    int v23 = v12;
    uint32_t v24 = v11;
    uint64_t v25 = v9;
LABEL_20:
    AppendBinaryBody(v23, v24, v25, v26, v27);
    return v15;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      CompressMsg_cold_1();
    }
  }
  return v15;
}

uint64_t AddToCListRTP(uint64_t a1, int a2, int a3, long long *a4, int a5)
{
  uint64_t v10 = (pthread_rwlock_t *)(a1 + 1272);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 1272));
  long long v11 = (char *)malloc_type_calloc(1uLL, 0x868uLL, 0x10200406FE3F67FuLL);
  if (v11)
  {
    int v12 = v11;
    *(_DWORD *)long long v11 = a3;
    *((void *)v11 + 266) = 0xFFFFFFFFLL;
    *((_DWORD *)v11 + 2) = 2048;
    *((_DWORD *)v11 + 517) = a5;
    *((_DWORD *)v11 + 516) = a2;
    long long v13 = *a4;
    long long v14 = a4[1];
    *((void *)v11 + 263) = *((void *)a4 + 4);
    *(_OWORD *)(v11 + 2072) = v13;
    *(_OWORD *)(v11 + 2088) = v14;
    if ((ICEAddOneInterface() & 0x80000000) != 0)
    {
      free(v12);
    }
    else
    {
      uint64_t v15 = (void *)(a1 + 1264);
      do
      {
        int v16 = v15;
        uint64_t v17 = *v15;
        uint64_t v15 = (void *)(*v15 + 2144);
      }
      while (v17);
      void *v16 = v12;
      pthread_rwlock_unlock(v10);
      uint64_t v10 = (pthread_rwlock_t *)(a1 + 1064);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 1064));
      int v18 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 12) = -1;
      VTP_Close(v18);
    }
  }

  return pthread_rwlock_unlock(v10);
}

void *AppendBinaryBody(void *a1, const char *a2, int *a3, const void *a4, int a5)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  memset(__str, 170, sizeof(__str));
  snprintf(__str, 0x10uLL, "%d", a5);
  int v10 = strlen(a2);
  ReplaceKeyword(a2, (v10 + 1), "%CLENGTH%", __str, 16);
  int v11 = strlen(a2);
  *a3 = v11;
  memcpy(a1, a2, v11);
  strcpy((char *)a1 + *a3, "<Binary>");
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v12 = VRTraceErrorLogLevelToCSTR();
    long long v13 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v14 = *a3;
      *(_DWORD *)buf = 136316162;
      uint64_t v17 = v12;
      __int16 v18 = 2080;
      int v19 = "AppendBinaryBody";
      __int16 v20 = 1024;
      int v21 = 3012;
      __int16 v22 = 1024;
      int v23 = v14;
      __int16 v24 = 1024;
      int v25 = a5;
      _os_log_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d()()()()() TP BINARY BODY (%d + %d)", buf, 0x28u);
    }
  }
  uint64_t result = memcpy((void *)&a2[*a3], a4, a5);
  *a3 += a5;
  return result;
}

uint64_t __TPSetupCTContext_block_invoke(uint64_t a1, const void *a2, const __CFDictionary *a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t result = CheckInHandleDebug();
  if (result)
  {
    uint64_t v7 = result;
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F24080]))
    {
      int valuePtr = -1;
      *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)((char *)v40 + 15) = v8;
      long long v39 = v8;
      v40[0] = v8;
      long long v37 = v8;
      long long v38 = v8;
      long long v35 = v8;
      long long v36 = v8;
      long long v33 = v8;
      long long v34 = v8;
      long long v31 = v8;
      long long v32 = v8;
      long long v29 = v8;
      long long v30 = v8;
      long long v27 = v8;
      long long v28 = v8;
      *(_OWORD *)buffer = v8;
      Value = CFDictionaryGetValue(a3, (const void *)*MEMORY[0x1E4F23FF0]);
      CFNumberRef v10 = (const __CFNumber *)CFDictionaryGetValue(a3, (const void *)*MEMORY[0x1E4F24008]);
      if (v10) {
        CFNumberGetValue(v10, kCFNumberSInt32Type, &valuePtr);
      }
      CFStringRef v11 = (const __CFString *)CFDictionaryGetValue(a3, (const void *)*MEMORY[0x1E4F24018]);
      CFStringRef v12 = v11;
      if (v11) {
        CFStringGetCString(v11, buffer, 255, 0);
      }
      if (Value)
      {
        int v13 = CFEqual(Value, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
        if (v12)
        {
          if (v13 && valuePtr != -1)
          {
            uint64_t v14 = v7 + 34456;
            int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
            int v16 = (os_log_t *)MEMORY[0x1E4F47A50];
            if (ErrorLogLevelForModule >= 7)
            {
              uint64_t v17 = VRTraceErrorLogLevelToCSTR();
              __int16 v18 = *v16;
              if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136316162;
                *(void *)&uint8_t buf[4] = v17;
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = "TPCTServerConnectionCallback";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)int v25 = 460;
                *(_WORD *)&_OWORD v25[4] = 1024;
                *(_DWORD *)&v25[6] = valuePtr;
                *(_WORD *)&v25[10] = 2080;
                *(void *)&v25[12] = buffer;
                _os_log_impl(&dword_1E1EA4000, v18, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Received cellular data status change notification [Context: %d Indicator:%s].", buf, 0x2Cu);
              }
            }
            *(_DWORD *)(v14 + 16) = TPGetLocalCellTech(*(void *)v14);
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              uint64_t v19 = VRTraceErrorLogLevelToCSTR();
              __int16 v20 = *v16;
              if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
              {
                int v21 = *(_DWORD *)(v14 + 16);
                *(_DWORD *)buf = 136315906;
                *(void *)&uint8_t buf[4] = v19;
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = "TPCTServerConnectionCallback";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)int v25 = 462;
                *(_WORD *)&_OWORD v25[4] = 1024;
                *(_DWORD *)&v25[6] = v21;
                _os_log_impl(&dword_1E1EA4000, v20, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d CellTech Changed to %d ", buf, 0x22u);
              }
            }
            global_queue = dispatch_get_global_queue(0, 0);
            *(void *)buf = MEMORY[0x1E4F143A8];
            *(void *)&buf[8] = 0x40000000;
            *(void *)&buf[16] = __TPCellularConditionChangeCallback_block_invoke;
            *(void *)int v25 = &__block_descriptor_tmp_37;
            *(void *)&v25[8] = v5;
            dispatch_async(global_queue, buf);
          }
        }
      }
    }
    return CheckOutHandleDebug();
  }
  return result;
}

uint64_t TPGetLocalCellTech(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    VCCTServiceMonitor_GetRadioAccessTechnology();
    if (!VCCTServiceMonitor_GetDataIndicatorStatus()) {
      VCCTServiceMonitor_GetDataIndicatorStatusOverride();
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v1 = VRTraceErrorLogLevelToCSTR();
      uint64_t v2 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        uint64_t v5 = v1;
        __int16 v6 = 2080;
        uint64_t v7 = "TPGetLocalCellTech";
        __int16 v8 = 1024;
        int v9 = 340;
        __int16 v10 = 1024;
        int v11 = 0;
        _os_log_impl(&dword_1E1EA4000, v2, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Active wireless technology: [%d]", buf, 0x22u);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      TPGetLocalCellTech_cold_1();
    }
  }
  return 0;
}

uint64_t __TPCellularConditionChangeCallback_block_invoke()
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t result = CheckInHandleDebug();
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = (unsigned int *)(result + 34472);
    int LocalInterfaceListWithOptions = GetLocalInterfaceListWithOptions();
    unsigned int v4 = LocalInterfaceListWithOptions;
    if (LocalInterfaceListWithOptions >= 1)
    {
      uint64_t v5 = LocalInterfaceListWithOptions;
      uint64_t v6 = 4;
      do
      {
        unsigned int v4 = (__PAIR64__(v4, strcmp((const char *)v6, "lo0")) - 1) >> 32;
        v6 += 40;
        --v5;
      }
      while (v5);
    }
    FreeLocalInterfaceList();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v7 = VRTraceErrorLogLevelToCSTR();
      __int16 v8 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *((void *)v2 + 3);
        uint64_t v10 = *((void *)v2 + 4);
        *(_DWORD *)buf = 136316418;
        uint64_t v13 = v7;
        __int16 v14 = 2080;
        uint64_t v15 = "TPCellularConditionChangeCallback_block_invoke";
        __int16 v16 = 1024;
        int v17 = 411;
        __int16 v18 = 2048;
        uint64_t v19 = v9;
        __int16 v20 = 2048;
        uint64_t v21 = v10;
        __int16 v22 = 1024;
        unsigned int v23 = v4;
        _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPCellularConditionChangeCallback... %p, %p, iNumValidInterfaces = %d", buf, 0x36u);
      }
    }
    if (*((void *)v2 + 3))
    {
      if (*((void *)v2 + 4))
      {
        unsigned __int16 CellularMTU = GetCellularMTU(v1, 1);
        (*((void (**)(void, void, void))v2 + 3))(*((void *)v2 + 4), *v2, CellularMTU);
      }
    }
    return CheckOutHandleDebug();
  }
  return result;
}

void __TPConnectedCallback_block_invoke(uint64_t a1)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = CheckInHandleDebug();
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v2)
  {
    unsigned int v4 = (os_log_t *)MEMORY[0x1E4F47A50];
    if (ErrorLogLevelForModule >= 7)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      uint64_t v6 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *(void *)(a1 + 40);
        int v8 = *(_DWORD *)(a1 + 64);
        int v9 = *(_DWORD *)(a1 + 68);
        int v46 = 136316418;
        uint64_t v47 = v5;
        __int16 v48 = 2080;
        long long v49 = "TPConnectedCallback_block_invoke";
        __int16 v50 = 1024;
        int v51 = 4511;
        __int16 v52 = 1024;
        *(_DWORD *)long long v53 = v7;
        *(_WORD *)&uint8_t v53[4] = 1024;
        *(_DWORD *)&v53[6] = v8;
        __int16 v54 = 1024;
        int v55 = v9;
        _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPConnectedCallback: theCCResult == %08X, ifDidRecvPacket = %d fUseRelay = %d ...", (uint8_t *)&v46, 0x2Eu);
      }
    }
    if (*(void *)(a1 + 40))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v10 = VRTraceErrorLogLevelToCSTR();
        int v11 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          int v12 = *(_DWORD *)(*(void *)(a1 + 40) + 4);
          int v46 = 136315906;
          uint64_t v47 = v10;
          __int16 v48 = 2080;
          long long v49 = "TPConnectedCallback_block_invoke";
          __int16 v50 = 1024;
          int v51 = 4515;
          __int16 v52 = 1024;
          *(_DWORD *)long long v53 = v12;
          _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPConnectedCallback:: result#%d", (uint8_t *)&v46, 0x22u);
        }
      }
      IPPORTToStringWithSize();
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v13 = VRTraceErrorLogLevelToCSTR();
        __int16 v14 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          int v46 = 136315906;
          uint64_t v47 = v13;
          __int16 v48 = 2080;
          long long v49 = "TPConnectedCallback_block_invoke";
          __int16 v50 = 1024;
          int v51 = 4517;
          __int16 v52 = 2080;
          *(void *)long long v53 = &g_SIPICERetryParams_block_invoke_ip;
          _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPConnectedCallback:: local = %s", (uint8_t *)&v46, 0x26u);
        }
      }
      IPPORTToStringWithSize();
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v15 = VRTraceErrorLogLevelToCSTR();
        __int16 v16 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          int v46 = 136315906;
          uint64_t v47 = v15;
          __int16 v48 = 2080;
          long long v49 = "TPConnectedCallback_block_invoke";
          __int16 v50 = 1024;
          int v51 = 4519;
          __int16 v52 = 2080;
          *(void *)long long v53 = &g_SIPICERetryParams_block_invoke_ip;
          _os_log_impl(&dword_1E1EA4000, v16, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPConnectedCallback:: remote = %s", (uint8_t *)&v46, 0x26u);
        }
      }
      IPPORTToStringWithSize();
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v17 = VRTraceErrorLogLevelToCSTR();
        __int16 v18 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          int v46 = 136315906;
          uint64_t v47 = v17;
          __int16 v48 = 2080;
          long long v49 = "TPConnectedCallback_block_invoke";
          __int16 v50 = 1024;
          int v51 = 4521;
          __int16 v52 = 2080;
          *(void *)long long v53 = &g_SIPICERetryParams_block_invoke_ip;
          _os_log_impl(&dword_1E1EA4000, v18, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPConnectedCallback:: src = %s", (uint8_t *)&v46, 0x26u);
        }
      }
      IPPORTToStringWithSize();
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v19 = VRTraceErrorLogLevelToCSTR();
        __int16 v20 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          int v46 = 136315906;
          uint64_t v47 = v19;
          __int16 v48 = 2080;
          long long v49 = "TPConnectedCallback_block_invoke";
          __int16 v50 = 1024;
          int v51 = 4523;
          __int16 v52 = 2080;
          *(void *)long long v53 = &g_SIPICERetryParams_block_invoke_ip;
          _os_log_impl(&dword_1E1EA4000, v20, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPConnectedCallback:: dst = %s", (uint8_t *)&v46, 0x26u);
        }
      }
      IPPORTToStringWithSize();
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v21 = VRTraceErrorLogLevelToCSTR();
        __int16 v22 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          int v46 = 136315906;
          uint64_t v47 = v21;
          __int16 v48 = 2080;
          long long v49 = "TPConnectedCallback_block_invoke";
          __int16 v50 = 1024;
          int v51 = 4525;
          __int16 v52 = 2080;
          *(void *)long long v53 = &g_SIPICERetryParams_block_invoke_ip;
          _os_log_impl(&dword_1E1EA4000, v22, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPConnectedCallback:: remoteSrc = %s", (uint8_t *)&v46, 0x26u);
        }
      }
      IPPORTToStringWithSize();
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v23 = VRTraceErrorLogLevelToCSTR();
        uint64_t v24 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          int v46 = 136315906;
          uint64_t v47 = v23;
          __int16 v48 = 2080;
          long long v49 = "TPConnectedCallback_block_invoke";
          __int16 v50 = 1024;
          int v51 = 4527;
          __int16 v52 = 2080;
          *(void *)long long v53 = &g_SIPICERetryParams_block_invoke_ip;
          _os_log_impl(&dword_1E1EA4000, v24, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPConnectedCallback:: relay ext = %s", (uint8_t *)&v46, 0x26u);
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v25 = VRTraceErrorLogLevelToCSTR();
        int v26 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v27 = *(void *)(a1 + 40);
          int v28 = *(_DWORD *)(v27 + 20);
          int v29 = *(unsigned __int16 *)(v27 + 24);
          LODWORD(v27) = *(unsigned __int16 *)(v27 + 26);
          int v46 = 136316418;
          uint64_t v47 = v25;
          __int16 v48 = 2080;
          long long v49 = "TPConnectedCallback_block_invoke";
          __int16 v50 = 1024;
          int v51 = 4529;
          __int16 v52 = 1024;
          *(_DWORD *)long long v53 = v28;
          *(_WORD *)&uint8_t v53[4] = 1024;
          *(_DWORD *)&v53[6] = v29;
          __int16 v54 = 1024;
          int v55 = v27;
          _os_log_impl(&dword_1E1EA4000, v26, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPConnectedCallback:: bIfRelay = %d wRelayServType = %d wChannelNumber = %04x", (uint8_t *)&v46, 0x2Eu);
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v30 = VRTraceErrorLogLevelToCSTR();
        long long v31 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v32 = *(void *)(a1 + 40);
          int v33 = *(_DWORD *)(v32 + 280);
          LODWORD(v32) = *(_DWORD *)(v32 + 284);
          int v46 = 136316162;
          uint64_t v47 = v30;
          __int16 v48 = 2080;
          long long v49 = "TPConnectedCallback_block_invoke";
          __int16 v50 = 1024;
          int v51 = 4531;
          __int16 v52 = 1024;
          *(_DWORD *)long long v53 = v33;
          *(_WORD *)&uint8_t v53[4] = 1024;
          *(_DWORD *)&v53[6] = v32;
          _os_log_impl(&dword_1E1EA4000, v31, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPConnectedCallback:: cell_tech (local:%d, remote:%d)", (uint8_t *)&v46, 0x28u);
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v34 = VRTraceErrorLogLevelToCSTR();
        long long v35 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          long long v36 = *(int **)(a1 + 40);
          int v37 = *v36;
          LODWORD(v36) = v36[3];
          int v46 = 136316162;
          uint64_t v47 = v34;
          __int16 v48 = 2080;
          long long v49 = "TPConnectedCallback_block_invoke";
          __int16 v50 = 1024;
          int v51 = 4533;
          __int16 v52 = 1024;
          *(_DWORD *)long long v53 = v37;
          *(_WORD *)&uint8_t v53[4] = 1024;
          *(_DWORD *)&v53[6] = v36;
          _os_log_impl(&dword_1E1EA4000, v35, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPConnectedCallback:: dwCallID = %08X iRemoteCallID = %08X", (uint8_t *)&v46, 0x28u);
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v38 = VRTraceErrorLogLevelToCSTR();
        long long v39 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v40 = *(_DWORD **)(a1 + 40);
          int v41 = v40[73];
          int v42 = v40[74];
          LODWORD(v40) = v40[75];
          int v46 = 136316418;
          uint64_t v47 = v38;
          __int16 v48 = 2080;
          long long v49 = "TPConnectedCallback_block_invoke";
          __int16 v50 = 1024;
          int v51 = 4535;
          __int16 v52 = 1024;
          *(_DWORD *)long long v53 = v41;
          *(_WORD *)&uint8_t v53[4] = 1024;
          *(_DWORD *)&v53[6] = v42;
          __int16 v54 = 1024;
          int v55 = (int)v40;
          _os_log_impl(&dword_1E1EA4000, v39, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPConnectedCallback:: upgrade = %d primary = %d, replace = %d", (uint8_t *)&v46, 0x2Eu);
        }
      }
      uint64_t v43 = *(void *)(a1 + 40);
      *(_WORD *)(v43 + 288) = 0;
      if ((*(unsigned char *)(v43 + 28) & 4) != 0)
      {
        __int16 CellularMTU = GetCellularMTU(v2, 0);
        uint64_t v43 = *(void *)(a1 + 40);
        *(_WORD *)(v43 + 288) = CellularMTU;
      }
    }
    else
    {
      uint64_t v43 = 0;
    }
    uint32_t v45 = *(void (**)(void, void, uint64_t, void, void, void, void))(v2 + 34336);
    if (v45)
    {
      v45(*(void *)(a1 + 48), *(unsigned int *)(a1 + 72), v43, *(unsigned int *)(a1 + 64), *(unsigned int *)(a1 + 68), *(void *)(a1 + 56), *(unsigned int *)(a1 + 76));
      uint64_t v43 = *(void *)(a1 + 40);
    }
    if (v43) {
      free((void *)v43);
    }
    CheckOutHandleDebug();
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      __TPConnectedCallback_block_invoke_cold_1();
    }
  }
}

void __TPNewCandidatesCallback_block_invoke(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = CheckInHandleDebug();
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v2)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      uint64_t v4 = VRTraceErrorLogLevelToCSTR();
      uint64_t v5 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v6 = *(_DWORD *)(a1 + 56);
        int v9 = 136315906;
        uint64_t v10 = v4;
        __int16 v11 = 2080;
        int v12 = "TPNewCandidatesCallback_block_invoke";
        __int16 v13 = 1024;
        int v14 = 4621;
        __int16 v15 = 1024;
        int v16 = v6;
        _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPNewCandidatesCallback: blob size: %d", (uint8_t *)&v9, 0x22u);
      }
    }
    uint64_t v7 = *(void (**)(void, void, void, void, void))(v2 + 34344);
    if (v7) {
      v7(*(void *)(a1 + 40), *(unsigned int *)(a1 + 60), *(void *)(a1 + 48), *(unsigned int *)(a1 + 56), *(unsigned __int16 *)(a1 + 64));
    }
    int v8 = *(void **)(a1 + 48);
    if (v8) {
      free(v8);
    }
    CheckOutHandleDebug();
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      __TPNewCandidatesCallback_block_invoke_cold_1();
    }
  }
}

uint64_t __TPShouldNominateICECandidatePair_block_invoke(uint64_t result)
{
  uint64_t v1 = *(uint64_t (**)(void, void, void, void, void, void, void, void))(*(void *)(result + 32)
                                                                                                + 34352);
  if (v1) {
    return v1(*(void *)(*(void *)(result + 32) + 34376), *(unsigned int *)(result + 80), *(void *)(result + 40), *(unsigned int *)(result + 84), *(void *)(result + 48), *(void *)(result + 56), *(void *)(result + 64), *(void *)(result + 72));
  }
  return result;
}

void __TPRemoveIPPort_block_invoke(uint64_t a1)
{
  uint64_t v2 = CheckInHandleDebug();
  if (v2)
  {
    uint64_t v3 = *(void (**)(void, void, uint64_t, void))(v2 + 34360);
    if (v3) {
      v3(*(void *)(v2 + 34376), *(unsigned int *)(a1 + 48), *(void *)(*(void *)(a1 + 32) + 8) + 24, *(unsigned int *)(a1 + 52));
    }
    CheckOutHandleDebug();
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      __TPRemoveIPPort_block_invoke_cold_1();
    }
  }
}

void OUTLINED_FUNCTION_8_7(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x28u);
}

void VCBasebandCongestionDetector_SetMode(uint64_t a1, int a2)
{
  if (a1)
  {
    *(_DWORD *)(a1 + 12) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v2 = VRTraceErrorLogLevelToCSTR();
    uint64_t v3 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCBasebandCongestionDetector_SetMode_cold_1(v2, v3);
    }
  }
}

BOOL VCRateControlProcessBasebandNotification(void *a1, uint64_t a2)
{
  if (a1) {
    objc_msgSend(a1, "processBasebandNotification:arrivalTime:error:", a2, 0);
  }
  return a1 != 0;
}

uint64_t VCTransportStreamRunLoopVTPCreate(const __CFAllocator *a1, void *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    VCTransportStreamRunLoopGetClassID();
    int v4 = CMDerivedObjectCreate();
    if (v4)
    {
      if (v4 >= 0) {
        int v11 = v4;
      }
      else {
        int v11 = -v4;
      }
      uint64_t v9 = v11 | 0xD0360000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCTransportStreamRunLoopVTPCreate_cold_3();
        }
      }
    }
    else
    {
      DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
      CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E4F1D510]);
      void *DerivedStorage = Mutable;
      if (Mutable)
      {
        DerivedStorage[1] = 0xFFFFFFFF00000000;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v7 = VRTraceErrorLogLevelToCSTR();
          int v8 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            uint64_t v13 = v7;
            __int16 v14 = 2080;
            __int16 v15 = "VCTransportStreamRunLoopVTPCreate";
            __int16 v16 = 1024;
            int v17 = 90;
            __int16 v18 = 2048;
            uint64_t v19 = 0;
            _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [%p]", buf, 0x26u);
          }
        }
        uint64_t v9 = 0;
        *a2 = 0;
      }
      else
      {
        uint64_t v9 = 2151022594;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
          {
            VCTransportStreamRunLoopVTPCreate_cold_2();
            return 2151022594;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v9 = 2151022593;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCTransportStreamRunLoopVTPCreate_cold_1();
      }
    }
  }
  return v9;
}

uint64_t _VCTransportStreamRunLoopVTPFinalize()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(void *)DerivedStorage) {
    CFRelease(*(CFTypeRef *)DerivedStorage);
  }
  uint64_t result = *(unsigned int *)(DerivedStorage + 12);
  if (result != -1)
  {
    return VTP_Close(result);
  }
  return result;
}

uint64_t _VCTransportStreamRunLoopVTPAddTransportStream(uint64_t a1, const void *a2)
{
  if (!a1)
  {
    uint64_t v5 = 2151022593;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCTransportStreamRunLoopVTPAddTransportStream_cold_1();
      }
    }
    return v5;
  }
  if (!a2)
  {
    uint64_t v5 = 2151022593;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCTransportStreamRunLoopVTPAddTransportStream_cold_2();
      }
    }
    return v5;
  }
  if (!VCTransportStreamIsOfKindVTP((uint64_t)a2))
  {
    uint64_t v5 = 2151022593;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCTransportStreamRunLoopVTPAddTransportStream_cold_4();
      }
    }
    return v5;
  }
  uint64_t DerivedStorage = (CFMutableArrayRef *)CMBaseObjectGetDerivedStorage();
  if (FigCFArrayContainsValue())
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
      return 2151022633;
    }
    VRTraceErrorLogLevelToCSTR();
    uint64_t v5 = 2151022633;
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCTransportStreamRunLoopVTPAddTransportStream_cold_3();
    }
    return v5;
  }
  CFArrayAppendValue(*DerivedStorage, a2);

  return _VCTransportStreamRunLoopVTPUpdateFDSet((uint64_t)DerivedStorage);
}

uint64_t _VCTransportStreamRunLoopVTPRemoveTransportStream(uint64_t a1, const void *a2)
{
  if (!a1)
  {
    uint64_t v7 = 2151022593;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCTransportStreamRunLoopVTPRemoveTransportStream_cold_1();
      }
    }
    return v7;
  }
  if (!a2)
  {
    uint64_t v7 = 2151022593;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCTransportStreamRunLoopVTPRemoveTransportStream_cold_2();
      }
    }
    return v7;
  }
  uint64_t DerivedStorage = (CFArrayRef *)CMBaseObjectGetDerivedStorage();
  CFArrayRef v4 = *DerivedStorage;
  v9.length = CFArrayGetCount(*DerivedStorage);
  v9.location = 0;
  CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v4, v9, a2);
  if (FirstIndexOfValue == -1)
  {
    uint64_t v7 = 2151022614;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        _VCTransportStreamRunLoopVTPRemoveTransportStream_cold_3();
        return 2151022614;
      }
    }
    return v7;
  }
  CFArrayRemoveValueAtIndex(*DerivedStorage, FirstIndexOfValue);

  return _VCTransportStreamRunLoopVTPUpdateFDSet((uint64_t)DerivedStorage);
}

uint64_t _VCTransportStreamRunLoopVTPWaitForReceive(uint64_t a1, double a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v3 = 2151022593;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCTransportStreamRunLoopVTPWaitForReceive_cold_1();
      }
    }
    return v3;
  }
  uint64_t v3 = 2151022593;
  if (a2 < 0.0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCTransportStreamRunLoopVTPWaitForReceive_cold_2();
      }
    }
    return v3;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if ((int)CFArrayGetCount(*(CFArrayRef *)DerivedStorage) < 1) {
    return 2151022653;
  }
  if (*(_DWORD *)(DerivedStorage + 12) == -1)
  {
    uint64_t v6 = _VCTransportStreamRunLoopVTPUpdateFDSet(DerivedStorage);
    if ((v6 & 0x80000000) != 0) {
      return v6;
    }
  }
  memmove(__dst, (const void *)(DerivedStorage + 16), 0x80uLL);
  uint64_t v16 = (uint64_t)a2;
  int v18 = -1431655766;
  int v17 = (int)((a2 - (double)(uint64_t)a2) * 1000000.0);
  if (a2 <= 0.0) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = &v16;
  }
  int v8 = VTP_Select((*(_DWORD *)(DerivedStorage + 144) + 1), __dst, 0, 0, (uint64_t)v7);
  if (v8 == -1)
  {
    if (*__error() != 9)
    {
      uint64_t v3 = *__error() | 0xC0360000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCTransportStreamRunLoopVTPWaitForReceive_cold_4();
        }
      }
      return v3;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
      return 2151022622;
    }
    uint64_t v10 = VRTraceErrorLogLevelToCSTR();
    int v11 = *MEMORY[0x1E4F47A50];
    int v12 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      uint64_t v3 = 2151022622;
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        return v3;
      }
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = v10;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "_VCTransportStreamRunLoopVTPWaitForReceive";
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v21) = 177;
      WORD2(v21) = 2048;
      *(void *)((char *)&v21 + 6) = a1;
      uint64_t v13 = " [%s] %s:%d RunLoop %p wait for receive was cancelled";
LABEL_33:
      _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, v13, buf, 0x26u);
      return v3;
    }
    uint64_t v3 = 2151022622;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
      _VCTransportStreamRunLoopVTPWaitForReceive_cold_3();
    }
    return v3;
  }
  if (v8)
  {
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&buf[8] = 0x40000000;
    *(void *)&buf[16] = ___VCTransportStreamRunLoopVTPPerformReceive_block_invoke;
    *(void *)&long long v21 = &__block_descriptor_tmp_2_0;
    *((void *)&v21 + 1) = __dst;
    return _VCTransportStreamRunLoopVTPIterateTransportStreams((CFArrayRef *)DerivedStorage, (uint64_t)buf);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
    return 2151022615;
  }
  uint64_t v14 = VRTraceErrorLogLevelToCSTR();
  int v11 = *MEMORY[0x1E4F47A50];
  __int16 v15 = *MEMORY[0x1E4F47A50];
  if (*MEMORY[0x1E4F47A40])
  {
    uint64_t v3 = 2151022615;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
      return v3;
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = v14;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "_VCTransportStreamRunLoopVTPWaitForReceive";
    *(_WORD *)&buf[22] = 1024;
    LODWORD(v21) = 179;
    WORD2(v21) = 2048;
    *(void *)((char *)&v21 + 6) = a1;
    uint64_t v13 = " [%s] %s:%d RunLoop %p wait for receive timed out";
    goto LABEL_33;
  }
  uint64_t v3 = 2151022615;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
    _VCTransportStreamRunLoopVTPWaitForReceive_cold_5();
  }
  return v3;
}

uint64_t _VCTransportStreamRunLoopVTPCancelWait(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t DerivedStorage = (os_unfair_lock_s *)CMBaseObjectGetDerivedStorage();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v3 = VRTraceErrorLogLevelToCSTR();
      CFArrayRef v4 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v8 = 136315906;
        uint64_t v9 = v3;
        __int16 v10 = 2080;
        int v11 = "_VCTransportStreamRunLoopVTPCancelWait";
        __int16 v12 = 1024;
        int v13 = 196;
        __int16 v14 = 2048;
        uint64_t v15 = a1;
        _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [%p]", (uint8_t *)&v8, 0x26u);
      }
    }
    os_unfair_lock_lock(DerivedStorage + 2);
    int os_unfair_lock_opaque = DerivedStorage[3]._os_unfair_lock_opaque;
    DerivedStorage[3]._int os_unfair_lock_opaque = -1;
    os_unfair_lock_unlock(DerivedStorage + 2);
    if (os_unfair_lock_opaque == -1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      {
        return 2151022653;
      }
      else
      {
        VRTraceErrorLogLevelToCSTR();
        uint64_t v6 = 2151022653;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCTransportStreamRunLoopVTPCancelWait_cold_2();
        }
      }
    }
    else
    {
      VTP_Close(os_unfair_lock_opaque);
      return 0;
    }
  }
  else
  {
    uint64_t v6 = 2151022593;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCTransportStreamRunLoopVTPCancelWait_cold_1();
      }
    }
  }
  return v6;
}

uint64_t _VCTransportStreamRunLoopVTPUpdateFDSet(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = 2151022593;
  uint64_t v10 = 0;
  int v11 = &v10;
  uint64_t v12 = 0x2000000000;
  unsigned int v13 = 0x80000000;
  uint64_t v14 = 0;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x9800000000;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  if (a1)
  {
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    v9[2] = ___VCTransportStreamRunLoopVTPUpdateFDSet_block_invoke;
    v9[3] = &unk_1E6DB71E0;
    v9[4] = &v10;
    v9[5] = &v14;
    uint64_t v3 = _VCTransportStreamRunLoopVTPIterateTransportStreams((CFArrayRef *)a1, (uint64_t)v9);
    if ((v3 & 0x80000000) != 0 && v3 != -2143944639)
    {
      uint64_t v1 = v3;
    }
    else
    {
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 8));
      int v4 = *(_DWORD *)(a1 + 12);
      if (v4 == -1 && (int v4 = VTP_Socket(2, 2, 17), *(_DWORD *)(a1 + 12) = v4, v4 == -1))
      {
        uint64_t v1 = *__error() | 0xC0360000;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VCTransportStreamRunLoopVTPUpdateFDSet_cold_2();
          }
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 8));
      }
      else
      {
        int v5 = *((_DWORD *)v11 + 6);
        if (v5 <= v4) {
          int v5 = v4;
        }
        *((_DWORD *)v11 + 6) = v5;
        int v6 = *(_DWORD *)(a1 + 12);
        uint64_t v7 = v15 + 3;
        if (__darwin_check_fd_set_overflow(v6, v15 + 3, 0)) {
          *(_DWORD *)((char *)v7 + (((unint64_t)v6 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v6;
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 8));
        memmove((void *)(a1 + 16), v15 + 3, 0x80uLL);
        uint64_t v1 = 0;
        *(_DWORD *)(a1 + 144) = *((_DWORD *)v11 + 6);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCTransportStreamRunLoopVTPUpdateFDSet_cold_1();
    }
  }
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v10, 8);
  return v1;
}

uint64_t _VCTransportStreamRunLoopVTPIterateTransportStreams(CFArrayRef *a1, uint64_t a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = 2151022593;
  if (a1)
  {
    int Count = CFArrayGetCount(*a1);
    if (Count < 1)
    {
      return 2151022657;
    }
    else
    {
      CFIndex v6 = 0;
      uint64_t v7 = *MEMORY[0x1E4F1CF80];
      uint64_t v8 = Count;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*a1, v6);
        CFNumberRef number = 0;
        uint64_t CMBaseObject = VCPacketFilterGetCMBaseObject(ValueAtIndex, v10);
        uint64_t v12 = *(void *)(CMBaseObjectGetVTable() + 8);
        uint64_t v13 = v12 ? v12 : 0;
        uint64_t v14 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t, CFNumberRef *))(v13 + 48);
        if (!v14) {
          break;
        }
        uint64_t v2 = v14(CMBaseObject, @"UnderlyingVFD", v7, &number);
        if ((v2 & 0x80000000) != 0) {
          goto LABEL_14;
        }
        if (!number)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              _VCTransportStreamRunLoopVTPIterateTransportStreams_cold_2();
            }
          }
          return v2;
        }
        unsigned int valuePtr = -1;
        CFNumberGetValue(number, kCFNumberIntType, &valuePtr);
        CFRelease(number);
        uint64_t v2 = (*(uint64_t (**)(uint64_t, CFArrayRef *, const void *, void))(a2 + 16))(a2, a1, ValueAtIndex, valuePtr);
        if ((v2 & 0x80000000) == 0 && v8 != ++v6) {
          continue;
        }
        return v2;
      }
      uint64_t v2 = 4294954514;
LABEL_14:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v15 = VRTraceErrorLogLevelToCSTR();
        uint64_t v16 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          unsigned int valuePtr = 136316162;
          uint64_t v20 = v15;
          __int16 v21 = 2080;
          long long v22 = "_VCTransportStreamRunLoopVTPIterateTransportStreams";
          __int16 v23 = 1024;
          int v24 = 279;
          __int16 v25 = 1024;
          int v26 = v2;
          __int16 v27 = 2048;
          int v28 = ValueAtIndex;
          _os_log_error_impl(&dword_1E1EA4000, v16, OS_LOG_TYPE_ERROR, " [%s] %s:%d Could not get VFD %d from tranportStream %p", (uint8_t *)&valuePtr, 0x2Cu);
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCTransportStreamRunLoopVTPIterateTransportStreams_cold_1();
    }
  }
  return v2;
}

double SRTPClearExchangeInfo(uint64_t a1)
{
  if (a1)
  {
    VCMediaKeyIndex_Release((const void **)(a1 + 96));
    *(void *)(a1 + 96) = 0;
    double result = 0.0;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  return result;
}

double SRTPClearKeyDerivationInfo(uint64_t a1)
{
  if (a1)
  {
    VCMediaKeyIndex_Release((const void **)(a1 + 144));
    *(void *)(a1 + 144) = 0;
    double result = 0.0;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)a1 = 0u;
  }
  return result;
}

void HexToByte(unsigned char *a1, int a2, char *__s1, int a4)
{
  uint64_t v7 = a4;
  size_t v8 = strnlen(__s1, a4) >> 1;
  if ((int)v8 >= a2) {
    uint64_t v9 = a2;
  }
  else {
    uint64_t v9 = v8;
  }
  unint64_t v10 = (unint64_t)&a1[a2];
  int v11 = a2 - v8;
  if (a2 > (int)v8)
  {
    uint64_t v12 = &a1[(int)v8];
    if (v10 < (unint64_t)v12 || v12 < a1 || v10 - (unint64_t)v12 < v11)
    {
LABEL_37:
      __break(0x5519u);
      return;
    }
    bzero(v12, v11);
  }
  if ((int)v9 >= 1)
  {
    uint64_t v15 = &__s1[v7];
    uint64_t v16 = v9;
    long long v17 = a1;
    long long v18 = __s1;
    do
    {
      if (v18 > v15) {
        goto LABEL_37;
      }
      if (v18 < __s1) {
        goto LABEL_37;
      }
      BOOL v19 = v7 < 2;
      v7 -= 2;
      if (v19) {
        goto LABEL_37;
      }
      int v20 = *v18;
      int v21 = v18[1];
      if ((v20 - 48) >= 0xA)
      {
        if ((v20 - 65) >= 6)
        {
          if ((v20 - 97) > 5) {
            goto LABEL_32;
          }
          char v22 = -87;
        }
        else
        {
          char v22 = -55;
        }
      }
      else
      {
        char v22 = -48;
      }
      if ((v21 - 48) >= 0xA)
      {
        if ((v21 - 65) >= 6)
        {
          if ((v21 - 97) > 5)
          {
LABEL_32:
            char v24 = 0;
            goto LABEL_33;
          }
          char v23 = -87;
        }
        else
        {
          char v23 = -55;
        }
      }
      else
      {
        char v23 = -48;
      }
      char v24 = v21 + 16 * (v22 + v20) + v23;
LABEL_33:
      if ((unint64_t)v17 >= v10 || v17 < a1) {
        goto LABEL_37;
      }
      *v17++ = v24;
      v18 += 2;
      --v16;
    }
    while (v16);
  }
}

unint64_t ByteToHex(unint64_t result, int a2, unsigned __int8 *a3, int a4)
{
  if (a2 >= 0) {
    int v4 = a2;
  }
  else {
    int v4 = a2 + 1;
  }
  LODWORD(v5) = v4 >> 1;
  if ((int)v5 >= a4) {
    uint64_t v5 = a4;
  }
  else {
    uint64_t v5 = v5;
  }
  unint64_t v6 = result + a2;
  if ((int)v5 >= 1)
  {
    uint64_t v7 = (unsigned char *)(result + 1);
    uint64_t v8 = v5;
    uint64_t v9 = a3;
    while (v9 < &a3[a4] && v9 >= a3)
    {
      unsigned int v10 = *v9;
      BOOL v11 = (unint64_t)(v7 - 1) < v6 && (unint64_t)(v7 - 1) >= result;
      int v12 = v11;
      if (v10 > 0x9F)
      {
        if (!v12) {
          goto LABEL_45;
        }
        int v13 = (v10 >> 4) + 55;
      }
      else
      {
        if (!v12) {
          goto LABEL_45;
        }
        int v13 = (v10 >> 4) | 0x30;
      }
      unsigned int v14 = v10 & 0xF;
      *(v7 - 1) = v13;
      BOOL v16 = (unint64_t)v7 < v6 && (unint64_t)v7 >= result;
      if (v14 > 9)
      {
        if (!v16) {
          goto LABEL_45;
        }
        char v17 = v14 + 55;
      }
      else
      {
        if (!v16) {
          goto LABEL_45;
        }
        char v17 = v14 | 0x30;
      }
      *uint64_t v7 = v17;
      v7 += 2;
      ++v9;
      if (!--v8) {
        goto LABEL_34;
      }
    }
    goto LABEL_45;
  }
LABEL_34:
  uint64_t v18 = (2 * v5);
  int v19 = a2 - v18;
  if (a2 <= (int)v18) {
    return v18;
  }
  unint64_t v20 = result + (int)v18;
  BOOL v11 = v6 >= v20;
  unint64_t v21 = v6 - v20;
  if (v11 && v20 >= result && v21 >= v19)
  {
    bzero((void *)(result + (int)v18), v19);
    return v18;
  }
LABEL_45:
  __break(0x5519u);
  return result;
}

void setTransformPolicyFromCipherSuite(int a1, uint64_t a2, int a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  switch(a1)
  {
    case 0:
      goto LABEL_6;
    case 1:
      *(_OWORD *)a2 = xmmword_1E259FDE0;
      *(void *)(a2 + 16) = 0x1400000002;
      *(_DWORD *)(a2 + 24) = 10;
      uint64_t v5 = 0x1400000001;
      break;
    case 2:
      *(_OWORD *)a2 = xmmword_1E259DB60;
      *(void *)(a2 + 16) = 0;
      *(_DWORD *)(a2 + 24) = 0;
      uint64_t v5 = 0x1400000002;
      break;
    case 3:
      *(_OWORD *)a2 = xmmword_1E259DB60;
      *(void *)(a2 + 16) = 1;
      *(_DWORD *)(a2 + 24) = 4;
      uint64_t v5 = 0x1400000003;
      break;
    case 4:
      *(_OWORD *)a2 = xmmword_1E259DB60;
      *(void *)(a2 + 16) = 0x1400000002;
      *(_DWORD *)(a2 + 24) = 10;
      uint64_t v5 = 0x1400000004;
      break;
    case 5:
      if (a3) {
        int v8 = 32;
      }
      else {
        int v8 = 16;
      }
      *(_DWORD *)a2 = 2;
      *(_DWORD *)(a2 + 4) = v8;
      *(_OWORD *)(a2 + 8) = xmmword_1E259FDD0;
      *(_DWORD *)(a2 + 24) = 0;
      uint64_t v5 = 0x1400000005;
      break;
    case 6:
      *(_OWORD *)a2 = xmmword_1E259FDC0;
      *(void *)(a2 + 16) = 1;
      *(_DWORD *)(a2 + 24) = 4;
      uint64_t v5 = 0x1400000006;
      break;
    case 7:
      *(_OWORD *)a2 = xmmword_1E259FDC0;
      *(void *)(a2 + 16) = 0x1400000002;
      *(_DWORD *)(a2 + 24) = 10;
      uint64_t v5 = 0x1400000007;
      break;
    case 8:
      *(_OWORD *)a2 = xmmword_1E259DB60;
      *(void *)(a2 + 16) = 0x2000000004;
      *(_DWORD *)(a2 + 24) = 10;
      uint64_t v5 = 0x2000000008;
      break;
    case 9:
      *(_OWORD *)a2 = xmmword_1E259DB60;
      *(void *)(a2 + 16) = 0x2000000003;
      *(_DWORD *)(a2 + 24) = 4;
      uint64_t v5 = 0x2000000009;
      break;
    default:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v6 = VRTraceErrorLogLevelToCSTR();
        uint64_t v7 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v9 = 136316162;
          uint64_t v10 = v6;
          __int16 v11 = 2080;
          int v12 = "setTransformPolicyFromCipherSuite";
          __int16 v13 = 1024;
          int v14 = 205;
          __int16 v15 = 1024;
          int v16 = a1;
          __int16 v17 = 1024;
          int v18 = 0;
          _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unknown cipherSuite=%d, defaulting to %d ", (uint8_t *)&v9, 0x28u);
        }
      }
LABEL_6:
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = 0;
      *(_DWORD *)(a2 + 24) = 0;
      *(void *)(a2 + 16) = 0;
      uint64_t v5 = 0x1400000000;
      break;
  }
  *(void *)(a2 + 28) = v5;
}

void SRTPGetROC(uint64_t a1, unsigned int a2, int *a3, int a4)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  unsigned int v8 = *(_DWORD *)(a1 + 408);
  BOOL v9 = v8 > 4;
  int v10 = (1 << v8) & 0x1A;
  if (v9 || v10 == 0)
  {
    int v12 = 0;
  }
  else
  {
    if ((*(unsigned char *)a1 & 4) != 0)
    {
      *a3 = *(_DWORD *)(a1 + 124);
      return;
    }
    int v12 = 1;
  }
  unsigned int v13 = *(unsigned __int16 *)(a1 + 130);
  int v14 = *(_DWORD *)(a1 + 124);
  if (((a2 - v13) & 0x8000) != 0)
  {
    if (a2 > v13)
    {
      if (v14)
      {
        int v18 = v14 - 1;
        if (a4) {
          *(_WORD *)(a1 + 130) = a2;
        }
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            SRTPGetROC_cold_1();
          }
        }
        int v18 = 0;
      }
      if (v12) {
        int v14 = v18 & 0xFFF;
      }
      else {
        int v14 = v18;
      }
      *a3 = v14;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        uint64_t v20 = VRTraceErrorLogLevelToCSTR();
        unint64_t v21 = *MEMORY[0x1E4F47A50];
        char v22 = *MEMORY[0x1E4F47A50];
        if (*MEMORY[0x1E4F47A40])
        {
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            int v23 = *a3;
            int v26 = 136316162;
            uint64_t v27 = v20;
            __int16 v28 = 2080;
            uint64_t v29 = "SRTPGetROC";
            __int16 v30 = 1024;
            int v31 = 461;
            __int16 v32 = 1024;
            int v33 = v23;
            __int16 v34 = 1024;
            unsigned int v35 = a2;
            _os_log_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d PreCalc: use dwROC=%u (wSeq=%u)", (uint8_t *)&v26, 0x28u);
          }
        }
        else if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
        {
          int v25 = *a3;
          int v26 = 136316162;
          uint64_t v27 = v20;
          __int16 v28 = 2080;
          uint64_t v29 = "SRTPGetROC";
          __int16 v30 = 1024;
          int v31 = 461;
          __int16 v32 = 1024;
          int v33 = v25;
          __int16 v34 = 1024;
          unsigned int v35 = a2;
          _os_log_debug_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_DEBUG, " [%s] %s:%d PreCalc: use dwROC=%u (wSeq=%u)", (uint8_t *)&v26, 0x28u);
        }
      }
      goto LABEL_40;
    }
  }
  else
  {
    if (a2 >= v13)
    {
      int v19 = 0;
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        uint64_t v15 = VRTraceErrorLogLevelToCSTR();
        int v16 = *MEMORY[0x1E4F47A50];
        __int16 v17 = *MEMORY[0x1E4F47A50];
        if (*MEMORY[0x1E4F47A40])
        {
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            int v26 = 136316162;
            uint64_t v27 = v15;
            __int16 v28 = 2080;
            uint64_t v29 = "SRTPGetROC";
            __int16 v30 = 1024;
            int v31 = 435;
            __int16 v32 = 1024;
            int v33 = v14;
            __int16 v34 = 1024;
            unsigned int v35 = a2;
            _os_log_impl(&dword_1E1EA4000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d PreCalc: dwROC=%u (wSeq=%u)", (uint8_t *)&v26, 0x28u);
          }
        }
        else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          int v26 = 136316162;
          uint64_t v27 = v15;
          __int16 v28 = 2080;
          uint64_t v29 = "SRTPGetROC";
          __int16 v30 = 1024;
          int v31 = 435;
          __int16 v32 = 1024;
          int v33 = v14;
          __int16 v34 = 1024;
          unsigned int v35 = a2;
          _os_log_debug_impl(&dword_1E1EA4000, v16, OS_LOG_TYPE_DEBUG, " [%s] %s:%d PreCalc: dwROC=%u (wSeq=%u)", (uint8_t *)&v26, 0x28u);
        }
      }
      int v19 = 1;
    }
    int v24 = v19 + v14;
    if (a4) {
      *(_WORD *)(a1 + 130) = a2;
    }
    if (v12) {
      int v14 = v24 & 0xFFF;
    }
    else {
      int v14 = v24;
    }
  }
  *a3 = v14;
LABEL_40:
  if (a4) {
    *(_DWORD *)(a1 + 124) = v14;
  }
}

void SRTPGetSendROC(uint64_t a1, unsigned int a2, int *a3)
{
}

uint64_t SRTPCleanUpEncryption()
{
  uint64_t v0 = CheckInHandleDebug();
  if (!v0) {
    return 2147549186;
  }
  uint64_t v1 = v0;
  SRTPCleanUp(v0 + 7080);
  SRTPCleanUp(v1 + 7520);
  SRTPCleanUp(v1 + 7960);
  SRTPCleanUp(v1 + 8400);
  CheckOutHandleDebug();
  return 0;
}

uint64_t SRTPCleanUp(uint64_t a1)
{
  if (!*(_DWORD *)a1) {
    return 2149711928;
  }
  *(_DWORD *)a1 = 0;
  VCMediaKeyIndex_Release((const void **)(a1 + 352));
  VCMediaKeyIndex_Release((const void **)(a1 + 360));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 288));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 376));
  uint64_t v2 = *(_CCCryptor **)(a1 + 384);
  if (v2)
  {
    CCCryptorRelease(v2);
    *(void *)(a1 + 384) = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 376));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 8));
  pthread_cond_destroy((pthread_cond_t *)(a1 + 72));
  return 0;
}

uint64_t SRTPInitCrypt(uint64_t a1, const void *a2)
{
  int v4 = (os_unfair_lock_s *)(a1 + 376);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 376));
  uint64_t v5 = *(_CCCryptor **)(a1 + 384);
  if (v5)
  {
    CCCryptorRelease(v5);
    *(void *)(a1 + 384) = 0;
  }
  uint64_t v6 = CCCryptorCreateWithMode(0, 4u, 0, 0, 0, a2, *(int *)(a1 + 156), 0, 0, 0, 2u, (CCCryptorRef *)(a1 + 384));
  if (v6)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTPInitCrypt_cold_1();
      }
    }
  }
  os_unfair_lock_unlock(v4);
  return v6;
}

unint64_t SRTPPrepareEncryption()
{
  uint64_t v0 = 2147549186;
  unint64_t result = CheckInHandleDebug();
  if (!result) {
    return v0;
  }
  unint64_t v2 = result;
  if (result == 0xFFFFFFFF) {
    return 2147549190;
  }
  uint64_t v0 = 2149711911;
  if (*(_DWORD *)(result + 7080)
    || *(_DWORD *)(result + 7520)
    || *(_DWORD *)(result + 7960)
    || *(_DWORD *)(result + 8400))
  {
LABEL_10:
    CheckOutHandleDebug();
    return v0;
  }
  if (result < result + 27616)
  {
    *(void *)(result + 7512) = 0;
    *(_OWORD *)(result + 7480) = 0u;
    *(_OWORD *)(result + 7496) = 0u;
    *(_OWORD *)(result + 7448) = 0u;
    *(_OWORD *)(result + 7464) = 0u;
    *(_OWORD *)(result + 7416) = 0u;
    *(_OWORD *)(result + 7432) = 0u;
    *(_OWORD *)(result + 7384) = 0u;
    *(_OWORD *)(result + 7400) = 0u;
    *(_OWORD *)(result + 7352) = 0u;
    *(_OWORD *)(result + 7368) = 0u;
    *(_OWORD *)(result + 7320) = 0u;
    *(_OWORD *)(result + 7336) = 0u;
    *(_OWORD *)(result + 7288) = 0u;
    *(_OWORD *)(result + 7304) = 0u;
    *(_OWORD *)(result + 7256) = 0u;
    *(_OWORD *)(result + 7272) = 0u;
    *(_OWORD *)(result + 7224) = 0u;
    *(_OWORD *)(result + 7240) = 0u;
    *(_OWORD *)(result + 7192) = 0u;
    *(_OWORD *)(result + 7208) = 0u;
    *(_OWORD *)(result + 7160) = 0u;
    *(_OWORD *)(result + 7176) = 0u;
    *(_OWORD *)(result + 7128) = 0u;
    *(_OWORD *)(result + 7144) = 0u;
    *(_OWORD *)(result + 7096) = 0u;
    *(_OWORD *)(result + 7112) = 0u;
    *(_OWORD *)(result + 7080) = 0u;
    *(void *)(result + 7952) = 0;
    *(_OWORD *)(result + 7920) = 0u;
    *(_OWORD *)(result + 7936) = 0u;
    *(_OWORD *)(result + 7888) = 0u;
    *(_OWORD *)(result + 7904) = 0u;
    *(_OWORD *)(result + 7856) = 0u;
    *(_OWORD *)(result + 7872) = 0u;
    *(_OWORD *)(result + 7824) = 0u;
    *(_OWORD *)(result + 7840) = 0u;
    *(_OWORD *)(result + 7792) = 0u;
    *(_OWORD *)(result + 7808) = 0u;
    *(_OWORD *)(result + 7760) = 0u;
    *(_OWORD *)(result + 7776) = 0u;
    *(_OWORD *)(result + 7728) = 0u;
    *(_OWORD *)(result + 7744) = 0u;
    *(_OWORD *)(result + 7696) = 0u;
    *(_OWORD *)(result + 7712) = 0u;
    *(_OWORD *)(result + 7664) = 0u;
    *(_OWORD *)(result + 7680) = 0u;
    *(_OWORD *)(result + 7632) = 0u;
    *(_OWORD *)(result + 7648) = 0u;
    *(_OWORD *)(result + 7600) = 0u;
    *(_OWORD *)(result + 7616) = 0u;
    *(_OWORD *)(result + 7568) = 0u;
    *(_OWORD *)(result + 7584) = 0u;
    *(_OWORD *)(result + 7536) = 0u;
    *(_OWORD *)(result + 7552) = 0u;
    *(_OWORD *)(result + 7520) = 0u;
    *(_DWORD *)(result + 7080) = 1;
    *(_DWORD *)(result + 7200) = *(_DWORD *)(result + 200);
    *(_WORD *)(result + 7210) = *(_WORD *)(result + 192);
    *(_DWORD *)(result + 7520) = 1;
    pthread_mutex_init((pthread_mutex_t *)(result + 7088), 0);
    pthread_cond_init((pthread_cond_t *)(v2 + 7152), 0);
    pthread_mutex_init((pthread_mutex_t *)(v2 + 7528), 0);
    pthread_cond_init((pthread_cond_t *)(v2 + 7592), 0);
    pthread_mutex_init((pthread_mutex_t *)(v2 + 7368), 0);
    pthread_mutex_init((pthread_mutex_t *)(v2 + 7808), 0);
    *(_DWORD *)(v2 + 7456) = 0;
    *(_DWORD *)(v2 + 7896) = 0;
    *(_OWORD *)(v2 + 7960) = 0u;
    *(_OWORD *)(v2 + 7976) = 0u;
    *(_OWORD *)(v2 + 7992) = 0u;
    *(_OWORD *)(v2 + 8008) = 0u;
    *(_OWORD *)(v2 + 8024) = 0u;
    *(_OWORD *)(v2 + 8040) = 0u;
    *(_OWORD *)(v2 + 8056) = 0u;
    *(_OWORD *)(v2 + 8072) = 0u;
    *(_OWORD *)(v2 + 8088) = 0u;
    *(_OWORD *)(v2 + 8104) = 0u;
    *(_OWORD *)(v2 + 8120) = 0u;
    *(_OWORD *)(v2 + 8136) = 0u;
    *(_OWORD *)(v2 + 8152) = 0u;
    *(_OWORD *)(v2 + 8168) = 0u;
    *(_OWORD *)(v2 + 8184) = 0u;
    *(_OWORD *)(v2 + 8200) = 0u;
    *(_OWORD *)(v2 + 8216) = 0u;
    *(_OWORD *)(v2 + 8232) = 0u;
    *(_OWORD *)(v2 + 8248) = 0u;
    *(_OWORD *)(v2 + 8264) = 0u;
    *(_OWORD *)(v2 + 8280) = 0u;
    *(_OWORD *)(v2 + 8296) = 0u;
    *(_OWORD *)(v2 + 8312) = 0u;
    *(_OWORD *)(v2 + 8328) = 0u;
    *(_OWORD *)(v2 + 8344) = 0u;
    *(_OWORD *)(v2 + 8360) = 0u;
    *(_OWORD *)(v2 + 8376) = 0u;
    *(void *)(v2 + 8392) = 0;
    *(void *)(v2 + 8832) = 0;
    *(_OWORD *)(v2 + 8800) = 0u;
    *(_OWORD *)(v2 + 8816) = 0u;
    *(_OWORD *)(v2 + 8768) = 0u;
    *(_OWORD *)(v2 + 8784) = 0u;
    *(_OWORD *)(v2 + 8736) = 0u;
    *(_OWORD *)(v2 + 8752) = 0u;
    *(_OWORD *)(v2 + 8704) = 0u;
    *(_OWORD *)(v2 + 8720) = 0u;
    *(_OWORD *)(v2 + 8672) = 0u;
    *(_OWORD *)(v2 + 8688) = 0u;
    *(_OWORD *)(v2 + 8640) = 0u;
    *(_OWORD *)(v2 + 8656) = 0u;
    *(_OWORD *)(v2 + 8608) = 0u;
    *(_OWORD *)(v2 + 8624) = 0u;
    *(_OWORD *)(v2 + 8576) = 0u;
    *(_OWORD *)(v2 + 8592) = 0u;
    *(_OWORD *)(v2 + 8544) = 0u;
    *(_OWORD *)(v2 + 8560) = 0u;
    *(_OWORD *)(v2 + 8512) = 0u;
    *(_OWORD *)(v2 + 8528) = 0u;
    *(_OWORD *)(v2 + 8480) = 0u;
    *(_OWORD *)(v2 + 8496) = 0u;
    *(_OWORD *)(v2 + 8448) = 0u;
    *(_OWORD *)(v2 + 8464) = 0u;
    *(_OWORD *)(v2 + 8416) = 0u;
    *(_OWORD *)(v2 + 8432) = 0u;
    *(_OWORD *)(v2 + 8400) = 0u;
    *(_DWORD *)(v2 + 7960) = 1;
    *(_DWORD *)(v2 + 8400) = 1;
    *(_DWORD *)(v2 + 8080) = *(_DWORD *)(v2 + 200);
    pthread_mutex_init((pthread_mutex_t *)(v2 + 7968), 0);
    pthread_cond_init((pthread_cond_t *)(v2 + 8032), 0);
    pthread_mutex_init((pthread_mutex_t *)(v2 + 8408), 0);
    pthread_cond_init((pthread_cond_t *)(v2 + 8472), 0);
    pthread_mutex_init((pthread_mutex_t *)(v2 + 8248), 0);
    pthread_mutex_init((pthread_mutex_t *)(v2 + 8688), 0);
    uint64_t v0 = 0;
    *(_DWORD *)(v2 + 8336) = 0;
    *(_DWORD *)(v2 + 8776) = 0;
    goto LABEL_10;
  }
  __break(0x5519u);
  return result;
}

void SRTPUseEncryption(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, unsigned int a6)
{
  v56[2] = *MEMORY[0x1E4F143B8];
  if (a6 >= 3) {
    return;
  }
  __int16 v11 = (_DWORD *)CheckInHandleDebug();
  if (!v11) {
    return;
  }
  int v12 = v11;
  if (v11 == (_DWORD *)0xFFFFFFFFLL) {
    return;
  }
  if (v11[1770] && v11[1880] && v11[1990] && v11[2100])
  {
    unsigned int v13 = v11 + 6904;
    int v54 = -1431655766;
    *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v52 = v14;
    long long v53 = v14;
    int v51 = -1431655766;
    long long v49 = v14;
    long long v50 = v14;
    setTransformPolicyFromCipherSuite(a4, (uint64_t)&v52, a6 == 2);
    setTransformPolicyFromCipherSuite(a5, (uint64_t)&v49, a6 == 2);
    long long v15 = v53;
    *((_OWORD *)v12 + 467) = v52;
    *((_OWORD *)v12 + 468) = v15;
    v12[1876] = v54;
    v12[1877] = a6;
    if (v12 >= v13) {
      goto LABEL_53;
    }
    uint64_t v16 = *(void *)(v12 + 1869);
    *((void *)v12 + 904) = v16;
    uint64_t v17 = (uint64_t)(v12 + 1770);
    uint64_t v18 = (uint64_t)(v12 + 1880);
    v12[1986] = v54;
    uint64_t v19 = (uint64_t)(v12 + 1990);
    uint64_t v20 = (uint64_t)(v12 + 2100);
    long long v21 = v53;
    *(_OWORD *)(v12 + 1978) = v52;
    *(_OWORD *)(v12 + 1982) = v21;
    v12[1987] = a6;
    uint64_t v22 = *(void *)(v12 + 1979);
    *((void *)v12 + 959) = v22;
    long long v23 = v50;
    *((_OWORD *)v12 + 522) = v49;
    long long v24 = v49;
    *((_OWORD *)v12 + 523) = v50;
    int v25 = v51;
    v12[2096] = v51;
    v12[2097] = a6;
    uint64_t v26 = *(void *)(v12 + 2089);
    *((void *)v12 + 1014) = v26;
    v12[2206] = v25;
    *(_OWORD *)(v12 + 2198) = v24;
    *(_OWORD *)(v12 + 2202) = v23;
    v12[2207] = a6;
    uint64_t v27 = *(void *)(v12 + 2199);
    *((void *)v12 + 1069) = v27;
    if (!(a5 | a4))
    {
LABEL_52:
      uint64_t v39 = v19;
      uint64_t v40 = v18;
      SRTPInitializedEncryption(v17, 1);
      SRTPInitializedEncryption(v40, 0);
      SRTPInitializedEncryption(v39, 1);
      SRTPInitializedEncryption(v20, 0);
      CheckOutHandleDebug();
      return;
    }
    if (a2 && a3)
    {
      __int16 v44 = v12 + 1770;
      int v42 = v12 + 1880;
      uint64_t v43 = v12 + 1990;
      int v41 = v12 + 2100;
      uint32_t v45 = (uint64_t *)&v41;
      if ((int)v16 <= (int)v26) {
        size_t v28 = v26;
      }
      else {
        size_t v28 = v16;
      }
      if ((int)v22 <= (int)v27) {
        int64_t v29 = v27;
      }
      else {
        int64_t v29 = v22;
      }
      __int16 v30 = (void *)MEMORY[0x1F4188790](v17);
      __int16 v32 = (char *)&v41 - v31;
      if (v28) {
        __int16 v30 = memset((char *)&v41 - v31, 170, v28);
      }
      __int16 v48 = v32;
      size_t v46 = v28;
      MEMORY[0x1F4188790](v30);
      memset(v56, 170, 14);
      if (v29) {
        memset((char *)&v41 - ((v29 + 15) & 0x1FFFFFFF0), 170, v29);
      }
      uint64_t v47 = (char *)&v41 - ((v29 + 15) & 0x1FFFFFFF0);
      memset(v55, 170, 14);
      int64_t v33 = v46;
      if ((v46 & 0x80000000) != 0) {
        goto LABEL_53;
      }
      HexToByte(v48, v46, (char *)a2, 65);
      HexToByte(v56, 14, (char *)(a2 + 65), 29);
      if ((v29 & 0x80000000) != 0) {
        goto LABEL_53;
      }
      HexToByte(v47, v29, (char *)a3, 65);
      HexToByte(v55, 14, (char *)(a3 + 65), 29);
      if (!a4) {
        goto LABEL_43;
      }
      size_t v34 = v12[1808];
      if ((v34 & 0x80000000) != 0 || (int)v34 > v33) {
        goto LABEL_53;
      }
      if (SRTPUseEncryptionInternal((uint64_t)v44, v48, v34, v56, *(void **)(a2 + 96), 1)) {
        goto LABEL_50;
      }
      size_t v35 = v12[1918];
      if ((v35 & 0x80000000) != 0 || (int)v35 > v29) {
        goto LABEL_53;
      }
      if (!SRTPUseEncryptionInternal((uint64_t)v42, v47, v35, v55, *(void **)(a3 + 96), 1))
      {
LABEL_43:
        if (!a5)
        {
LABEL_51:
          BOOL BoolValueForKey = VCDefaults_GetBoolValueForKey(@"enableEncryptionDebug", 0);
          *((unsigned char *)v12 + 7512) = BoolValueForKey;
          *((unsigned char *)v12 + 7952) = BoolValueForKey;
          uint64_t v20 = (uint64_t)v41;
          uint64_t v19 = (uint64_t)v43;
          uint64_t v18 = (uint64_t)v42;
          uint64_t v17 = (uint64_t)v44;
          goto LABEL_52;
        }
        size_t v36 = v12[2028];
        if ((v36 & 0x80000000) != 0 || (int)v36 > v33)
        {
LABEL_53:
          __break(0x5519u);
          return;
        }
        if (!SRTPUseEncryptionInternal((uint64_t)v43, v48, v36, v56, *(void **)(a2 + 96), 0))
        {
          size_t v37 = v12[2138];
          if ((v37 & 0x80000000) == 0 && (int)v37 <= v29)
          {
            if (SRTPUseEncryptionInternal((uint64_t)v41, v47, v37, v55, *(void **)(a3 + 96), 0)) {
              goto LABEL_50;
            }
            goto LABEL_51;
          }
          goto LABEL_53;
        }
      }
LABEL_50:
      CheckOutHandleDebug();
      return;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTPUseEncryption_cold_2();
      }
    }
    CheckOutHandleDebug();
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTPUseEncryption_cold_1();
      }
    }
    CheckOutHandleDebug();
  }
}

uint64_t SRTPUseEncryptionInternal(uint64_t result, const void *a2, size_t __n, void *a4, void *a5, int a6)
{
  if (__n >= 0x21) {
    goto LABEL_24;
  }
  unsigned int v9 = __n;
  uint64_t v11 = result;
  memcpy((void *)(result + 160), a2, __n);
  uint64_t v12 = *(void *)((char *)a4 + 6);
  *(void *)(v11 + 192) = *a4;
  *(void *)(v11 + 198) = v12;
  pthread_mutex_lock((pthread_mutex_t *)(v11 + 288));
  VCMediaKeyIndex_ReleaseAndCopyNewValue((const void **)(v11 + 352), a5);
  unint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v11 + 288));
  int v13 = *(_DWORD *)(v11 + 428);
  BOOL v14 = a6 == 0;
  if (a6) {
    char v15 = 1;
  }
  else {
    char v15 = 4;
  }
  if (v14) {
    char v16 = 5;
  }
  else {
    char v16 = 2;
  }
  if (v14) {
    char v17 = 3;
  }
  else {
    char v17 = 0;
  }
  if (*(_DWORD *)(v11 + 392))
  {
    unsigned int v18 = *(_DWORD *)(v11 + 400);
    if (v18 > 0x20 || a2 && !v9) {
      goto LABEL_24;
    }
    unint64_t result = (uint64_t)MakeSessionKey(v13 == 2, a2, v9, (uint64_t)a4, v17, (void *)(v11 + 206), v18);
    unsigned int v19 = *(_DWORD *)(v11 + 404);
    if (v19 > 0xE) {
      goto LABEL_24;
    }
    MakeSessionKey(v13 == 2, a2, v9, (uint64_t)a4, v16, (void *)(v11 + 238), v19);
    unint64_t result = SRTPInitCrypt(v11, (const void *)(v11 + 206));
    if ((result & 0x80000000) != 0) {
      return result;
    }
  }
  if (*(_DWORD *)(v11 + 408))
  {
    unsigned int v20 = *(_DWORD *)(v11 + 412);
    if (v20 <= 0x20 && (!a2 || v9))
    {
      MakeSessionKey(v13 == 2, a2, v9, (uint64_t)a4, v15, (void *)(v11 + 252), v20);
      return 0;
    }
LABEL_24:
    __break(0x5519u);
    return result;
  }
  return 0;
}

uint64_t SRTPInitializedEncryption(uint64_t a1, int a2)
{
  int v4 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if (a2) {
    int v5 = 10;
  }
  else {
    int v5 = 12;
  }
  *(_DWORD *)a1 |= v5;
  pthread_cond_broadcast((pthread_cond_t *)(a1 + 72));

  return pthread_mutex_unlock(v4);
}

uint64_t _SRTPUpdateEncryption(uint64_t a1, uint64_t a2)
{
  v16[1] = *(const void **)MEMORY[0x1E4F143B8];
  uint64_t v2 = 2147549186;
  if (a1)
  {
    if (a1 == 0xFFFFFFFFLL) {
      return 2147549190;
    }
    if (*(_DWORD *)(a1 + 7080) && *(_DWORD *)(a1 + 7520) && *(_DWORD *)(a1 + 7960) && *(_DWORD *)(a1 + 8400))
    {
      v16[0] = 0;
      long long v14 = 0u;
      long long v15 = 0u;
      long long v12 = 0u;
      long long v13 = 0u;
      long long v10 = 0u;
      long long v11 = 0u;
      unsigned int v9 = 0;
      memset(v8, 0, sizeof(v8));
      SRTPDeriveMediaKeyInfo(a1 + 7080, (unint64_t)&v10, a2);
      if (!v5)
      {
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 8844));
        if (!*(unsigned char *)(a1 + 8840))
        {
          *(_DWORD *)(a1 + 7640) = *(_DWORD *)(a1 + 4832);
          *(unsigned char *)(a1 + 8840) = 1;
        }
        SRTPDeriveMediaKeyInfo(a1 + 7520, (unint64_t)v8, a2);
        uint64_t v2 = v6;
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 8844));
        if (v2) {
          goto LABEL_25;
        }
        if (!*(_DWORD *)(a1 + 7472) || (uint64_t v5 = SRTPUpdateEncryptionInfo(a1 + 7080, (uint64_t)&v10, 1), !v5))
        {
          if (!*(_DWORD *)(a1 + 7912) || (uint64_t v5 = SRTPUpdateEncryptionInfo(a1 + 7520, (uint64_t)v8, 1), !v5))
          {
            if (!*(_DWORD *)(a1 + 8352) || (uint64_t v5 = SRTPUpdateEncryptionInfo(a1 + 7960, (uint64_t)&v10, 0), !v5))
            {
              if (!*(_DWORD *)(a1 + 8792))
              {
                uint64_t v2 = 0;
                goto LABEL_25;
              }
              uint64_t v5 = SRTPUpdateEncryptionInfo(a1 + 8400, (uint64_t)v8, 0);
            }
          }
        }
      }
      uint64_t v2 = v5;
LABEL_25:
      VCMediaKeyIndex_Release((const void **)(a2 + 144));
      VCMediaKeyIndex_Release(v16);
      v16[0] = 0;
      long long v14 = 0u;
      long long v15 = 0u;
      long long v12 = 0u;
      long long v13 = 0u;
      long long v10 = 0u;
      long long v11 = 0u;
      VCMediaKeyIndex_Release(&v9);
      return v2;
    }
    uint64_t v2 = 2149711928;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _SRTPUpdateEncryption_cold_1();
      }
    }
  }
  return v2;
}

uint64_t SRTPUpdateKeyMaterialForRTPInfo(uint64_t a1, const __CFDictionary *a2)
{
  v15[1] = *(const void **)MEMORY[0x1E4F143B8];
  v15[0] = 0;
  memset(v14, 0, sizeof(v14));
  SRTPGetKeyDerivationCryptoSet((unint64_t)v14, a2);
  if (v3)
  {
    uint64_t v6 = v3;
    _SRTPCancelEncryption(a1);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTPUpdateKeyMaterialForRTPInfo_cold_2();
      }
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v4 = VRTraceErrorLogLevelToCSTR();
      uint64_t v5 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v8 = 136315650;
        uint64_t v9 = v4;
        __int16 v10 = 2080;
        long long v11 = "SRTPUpdateKeyMaterialForRTPInfo";
        __int16 v12 = 1024;
        int v13 = 941;
        _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Configuring Crypto Set", (uint8_t *)&v8, 0x1Cu);
      }
    }
    uint64_t v6 = _SRTPUpdateEncryption(a1, (uint64_t)v14);
    if (v6)
    {
      _SRTPCancelEncryption(a1);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          SRTPUpdateKeyMaterialForRTPInfo_cold_1();
        }
      }
    }
  }
  VCMediaKeyIndex_Release(v15);
  return v6;
}

void SRTPGetKeyDerivationCryptoSet(unint64_t a1, CFDictionaryRef theDict)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    CFDataRef Value = (const __CFData *)CFDictionaryGetValue(theDict, @"SecurityKey");
    CFDataRef v5 = (const __CFData *)CFDictionaryGetValue(theDict, @"SecuritySalt");
    if (Value && v5 != 0)
    {
      CFDataRef v7 = v5;
      int v8 = (void *)CFDictionaryGetValue(theDict, @"SecurityKeyIndex");
      if ((CFDataGetLength(Value) & 0xFFFFFFE0) != 0) {
        unsigned int Length = 32;
      }
      else {
        unsigned int Length = CFDataGetLength(Value);
      }
      CFIndex ErrorLogLevelForModule = CFDataGetLength(v7);
      unsigned int v18 = v8;
      if ((ErrorLogLevelForModule & 0xFFFFFFE0) != 0)
      {
        unsigned int v11 = 32;
      }
      else
      {
        CFIndex ErrorLogLevelForModule = CFDataGetLength(v7);
        unsigned int v11 = ErrorLogLevelForModule;
      }
      if ((int)Length > 32)
      {
        CFIndex ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if ((int)ErrorLogLevelForModule >= 7)
        {
          uint64_t v12 = VRTraceErrorLogLevelToCSTR();
          int v13 = *MEMORY[0x1E4F47A50];
          CFIndex ErrorLogLevelForModule = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
          if (ErrorLogLevelForModule)
          {
            *(_DWORD *)buf = 136316162;
            uint64_t v20 = v12;
            __int16 v21 = 2080;
            uint64_t v22 = "SRTPGetKeyDerivationCryptoSet";
            __int16 v23 = 1024;
            int v24 = 110;
            __int16 v25 = 1024;
            int v26 = 32;
            __int16 v27 = 1024;
            unsigned int v28 = Length;
            _os_log_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Oversize member key length (limit=%d, given=%d)", buf, 0x28u);
          }
        }
      }
      if ((int)v11 >= 33)
      {
        CFIndex ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if ((int)ErrorLogLevelForModule >= 7)
        {
          uint64_t v14 = VRTraceErrorLogLevelToCSTR();
          long long v15 = *MEMORY[0x1E4F47A50];
          CFIndex ErrorLogLevelForModule = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
          if (ErrorLogLevelForModule)
          {
            *(_DWORD *)buf = 136316162;
            uint64_t v20 = v14;
            __int16 v21 = 2080;
            uint64_t v22 = "SRTPGetKeyDerivationCryptoSet";
            __int16 v23 = 1024;
            int v24 = 113;
            __int16 v25 = 1024;
            int v26 = 32;
            __int16 v27 = 1024;
            unsigned int v28 = v11;
            _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Oversize member salt length (limit=%d, given=%d)", buf, 0x28u);
          }
        }
      }
      char v16 = (void *)MEMORY[0x1F4188790](ErrorLogLevelForModule);
      if (Length) {
        char v16 = memset((char *)&v17 - ((Length + 15) & 0x1FFFFFFF0), 170, Length);
      }
      MEMORY[0x1F4188790](v16);
      if (v11) {
        memset((char *)&v17 - ((v11 + 15) & 0x1FFFFFFF0), 170, v11);
      }
      v30.location = 0;
      v30.length = Length;
      CFDataGetBytes(Value, v30, (UInt8 *)&v17 - ((Length + 15) & 0x1FFFFFFF0));
      v31.location = 0;
      v31.length = v11;
      CFDataGetBytes(v7, v31, (UInt8 *)&v17 - ((v11 + 15) & 0x1FFFFFFF0));
      if ((Length & 0x80000000) != 0
        || (*(_DWORD *)(a1 + 68) = ByteToHex(a1, 65, (unsigned __int8 *)&v17 - ((Length + 15) & 0x1FFFFFFF0), Length), (v11 & 0x80000000) != 0))
      {
        __break(0x5519u);
      }
      else
      {
        *(_DWORD *)(a1 + 140) = ByteToHex(a1 + 72, 65, (unsigned __int8 *)&v17 - ((v11 + 15) & 0x1FFFFFFF0), v11);
        VCMediaKeyIndex_ReleaseAndCopyNewValue((const void **)(a1 + 144), v18);
      }
    }
  }
}

void _SRTPCancelEncryption(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a1 && a1 != 0xFFFFFFFFLL)
  {
    if (*(_DWORD *)(a1 + 7080) && *(_DWORD *)(a1 + 7520))
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 7088));
      *(_DWORD *)(a1 + 7084) = 1;
      pthread_cond_broadcast((pthread_cond_t *)(a1 + 7152));
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 7088));
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 7528));
      *(_DWORD *)(a1 + 7524) = 1;
      pthread_cond_broadcast((pthread_cond_t *)(a1 + 7592));
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 7528));
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v2 = VRTraceErrorLogLevelToCSTR();
        uint64_t v3 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v4 = 136315650;
          uint64_t v5 = v2;
          __int16 v6 = 2080;
          CFDataRef v7 = "_SRTPCancelEncryption";
          __int16 v8 = 1024;
          int v9 = 928;
          _os_log_impl(&dword_1E1EA4000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Canceld SRTP encryption", (uint8_t *)&v4, 0x1Cu);
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _SRTPCancelEncryption_cold_1();
      }
    }
  }
}

uint64_t SRTPUpdateKeyMaterial(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v3 = CheckInHandleDebug();
  if (!v3) {
    return 2149711873;
  }
  uint64_t v4 = SRTPUpdateKeyMaterialForRTPInfo(v3, a2);
  CheckOutHandleDebug();
  return v4;
}

uint64_t SRTPUpdateEncryptionInfo(uint64_t a1, uint64_t a2, int a3)
{
  v11[2] = *MEMORY[0x1E4F143B8];
  BOOL isValid = VCMediaKeyIndex_isValid(*(void **)(a2 + 96));
  if (!isValid)
  {
    uint64_t v9 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTPUpdateEncryptionInfo_cold_1();
      }
    }
    return v9;
  }
  size_t v7 = *(unsigned int *)(a1 + 152);
  MEMORY[0x1F4188790](isValid);
  if (v7) {
    memset((char *)&v11[-1] - ((v7 + 15) & 0x1FFFFFFF0), 170, v7);
  }
  uint64_t v10 = 0;
  memset(v11, 170, 14);
  uint64_t result = VCMediaKeyIndex_ReleaseAndCopyNewValue((const void **)&v10, *(void **)(a2 + 96));
  if ((v7 & 0x80000000) == 0)
  {
    HexToByte((unsigned char *)&v11[-1] - ((v7 + 15) & 0x1FFFFFFF0), v7, (char *)a2, 65);
    HexToByte(v11, 14, (char *)(a2 + 65), 29);
    uint64_t v9 = SRTPUseEncryptionInternal(a1, (char *)&v11[-1] - ((v7 + 15) & 0x1FFFFFFF0), v7, v11, v10, a3);
    VCMediaKeyIndex_Release((const void **)&v10);
    return v9;
  }
  __break(0x5519u);
  return result;
}

void SRTPDeriveMediaKeyInfo(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return;
  }
  if (!a3) {
    return;
  }
  unint64_t v4 = *(unsigned int *)(a3 + 68);
  if ((int)v4 > 65 || (int)v4 < 1 || (*(_DWORD *)(a3 + 140) - 66) < 0xFFFFFFBF) {
    return;
  }
  v24[1] = v24;
  size_t v7 = v4 >> 1;
  __int16 v8 = (void *)MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)v24 - v9;
  if (v11 >= 2) {
    __int16 v8 = memset((char *)v24 - v9, 170, v7);
  }
  int v12 = *(_DWORD *)(a3 + 140);
  if (v12 >= 0) {
    int v13 = *(_DWORD *)(a3 + 140);
  }
  else {
    int v13 = v12 + 1;
  }
  size_t v14 = (v13 >> 1);
  MEMORY[0x1F4188790](v8);
  char v16 = (char *)v24 - v15;
  if ((v12 + 1) >= 3) {
    memset(v16, 170, v14);
  }
  unsigned int v17 = *(_DWORD *)(a3 + 68);
  if (v17 >= 0x42 || (HexToByte(v10, v7, (char *)a3, v17), v12 < -1) || (unsigned int v18 = *(_DWORD *)(a3 + 140), v18 > 0x41))
  {
LABEL_29:
    __break(0x5519u);
    return;
  }
  HexToByte(v16, v14, (char *)(a3 + 72), v18);
  int v25 = *(_DWORD *)(a1 + 120);
  int64_t v19 = (*(_DWORD *)(a1 + 152) + 14);
  MEMORY[0x1F4188790](v20);
  __int16 v21 = (char *)v24 - ((v19 + 15) & 0x1FFFFFFF0);
  if (v19) {
    memset((char *)v24 - ((v19 + 15) & 0x1FFFFFFF0), 170, v19);
  }
  if (!CCKeyDerivationHMac())
  {
    int v22 = *(_DWORD *)(a1 + 152);
    if ((v22 & 0x80000000) == 0 && v22 <= v19)
    {
      ByteToHex(a2, 65, (unsigned __int8 *)v24 - ((v19 + 15) & 0x1FFFFFFF0), v22);
      __int16 v23 = (unsigned __int8 *)&v21[*(int *)(a1 + 152)];
      if (&v21[v19] >= (char *)v23 && v21 <= (char *)v23 && v19 - *(int *)(a1 + 152) >= 14)
      {
        ByteToHex(a2 + 65, 29, v23, 14);
        VCMediaKeyIndex_ReleaseAndCopyNewValue((const void **)(a2 + 96), *(void **)(a3 + 144));
        return;
      }
    }
    goto LABEL_29;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      SRTPDeriveMediaKeyInfo_cold_1();
    }
  }
}

uint64_t SRTPEncryptData(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  unsigned int v34 = 0;
  size_t v33 = 0;
  __int16 v36 = 0;
  if (v5 < 0) {
    return 2149711873;
  }
  unsigned int v6 = v5;
  size_t v7 = v4;
  unsigned int v8 = v3;
  int v9 = v2;
  uint64_t v10 = v1;
  if (!g_fReportFirstCounter) {
    goto LABEL_10;
  }
  memset(v37, 170, 17);
  ByteToHex((unint64_t)v37, 17, v4, v5);
  if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
    goto LABEL_10;
  }
  uint64_t v11 = VRTraceErrorLogLevelToCSTR();
  int v12 = *MEMORY[0x1E4F47A50];
  int v13 = *MEMORY[0x1E4F47A50];
  if (!*MEMORY[0x1E4F47A40])
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      SRTPEncryptData_cold_5();
      if (v9) {
        goto LABEL_11;
      }
      goto LABEL_13;
    }
LABEL_10:
    if (v9) {
      goto LABEL_11;
    }
LABEL_13:
    unsigned int v8 = *(_DWORD *)(v10 + 368);
    unsigned int v15 = HIWORD(v8);
    unsigned int v34 = HIWORD(v8);
    goto LABEL_14;
  }
  if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_10;
  }
  *(_DWORD *)buf = 136315906;
  *(void *)&uint8_t buf[4] = v11;
  *(_WORD *)&buf[12] = 2080;
  *(void *)&buf[14] = "SRTPEncryptData";
  *(_WORD *)&buf[22] = 1024;
  *(_DWORD *)&unsigned char buf[24] = 1057;
  *(_WORD *)&buf[28] = 2080;
  *(void *)&buf[30] = v37;
  _os_log_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SRTPEncryptData: In=[%s]", buf, 0x26u);
  if (!v9) {
    goto LABEL_13;
  }
LABEL_11:
  SRTPGetROC(v10, v8, (int *)&v34, 1);
  unsigned int v15 = v34;
LABEL_14:
  unsigned int v16 = *(_DWORD *)(v10 + 120);
  *(void *)&iv[6] = *(void *)(v10 + 244);
  *(void *)iv = *(void *)(v10 + 238);
  *(uint32x2_t *)v17.i8 = vshl_u32((uint32x2_t)vdup_n_s32(v16), (uint32x2_t)0xFFFFFFF0FFFFFFE8);
  *(uint32x2_t *)v18.i8 = vshl_u32((uint32x2_t)vdup_n_s32(v15), (uint32x2_t)0xFFFFFFF0FFFFFFE8);
  v17.i32[2] = v16 >> 8;
  v17.i32[3] = v16;
  v18.i32[2] = v15 >> 8;
  v18.i32[3] = v15;
  *(int8x8_t *)&iv[4] = veor_s8(*(int8x8_t *)&iv[4], vmovn_s16(vuzp1q_s16(v17, v18)));
  iv[13] ^= v8;
  __int16 v36 = 0;
  unsigned int v19 = *(_DWORD *)(v10 + 428);
  if (v19 >= 3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTPEncryptData_cold_4();
      }
    }
    LOBYTE(v20) = 8;
  }
  else
  {
    unint64_t v20 = 0x800080001uLL >> (16 * v19);
  }
  iv[12] ^= (unsigned __int16)v8 >> v20;
  if (g_fReportFirstCounter)
  {
    memset(buf, 170, 0xFA0uLL);
    --g_fReportFirstCounter;
    ByteToHex((unint64_t)buf, 4000, iv, 16);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v21 = VRTraceErrorLogLevelToCSTR();
      int v22 = *MEMORY[0x1E4F47A50];
      __int16 v23 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)size_t v37 = 136316162;
          *(void *)&v37[4] = v21;
          *(_WORD *)&v37[12] = 2080;
          *(void *)&v37[14] = "MakeCounter";
          __int16 v38 = 1024;
          int v39 = 417;
          __int16 v40 = 2080;
          int v41 = buf;
          __int16 v42 = 1024;
          unsigned int v43 = v15;
          _os_log_impl(&dword_1E1EA4000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d   counters: [%s], ROC=%d", v37, 0x2Cu);
        }
      }
      else if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)size_t v37 = 136316162;
        *(void *)&v37[4] = v21;
        *(_WORD *)&v37[12] = 2080;
        *(void *)&v37[14] = "MakeCounter";
        __int16 v38 = 1024;
        int v39 = 417;
        __int16 v40 = 2080;
        int v41 = buf;
        __int16 v42 = 1024;
        unsigned int v43 = v15;
        _os_log_debug_impl(&dword_1E1EA4000, v22, OS_LOG_TYPE_DEBUG, " [%s] %s:%d   counters: [%s], ROC=%d", v37, 0x2Cu);
      }
    }
  }
  if (*(unsigned char *)(v10 + 432))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v24 = VRTraceErrorLogLevelToCSTR();
      int v25 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v26 = VCMediaKeyIndex_Description(*(void **)(v10 + 360));
        *(_DWORD *)buf = 136316418;
        *(void *)&uint8_t buf[4] = v24;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "SRTPEncryptData";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = 1070;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = v26;
        *(_WORD *)&buf[38] = 2048;
        *(void *)&buf[40] = v15;
        *(_WORD *)&uint8_t buf[48] = 1024;
        *(_DWORD *)&buf[50] = (unsigned __int16)v8;
        _os_log_impl(&dword_1E1EA4000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SRTPEncData: MKI=%s, ROC==%08lX, SEQ==%u):", buf, 0x36u);
      }
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 376));
  uint64_t v27 = CCCryptorReset(*(CCCryptorRef *)(v10 + 384), iv);
  if (v27)
  {
    uint64_t v14 = v27;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTPEncryptData_cold_3();
      }
    }
  }
  else
  {
    uint64_t v28 = CCCryptorUpdate(*(CCCryptorRef *)(v10 + 384), v7, v6, v7, v6, &v33);
    if (v28)
    {
      uint64_t v14 = v28;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          SRTPEncryptData_cold_2();
        }
      }
    }
    else
    {
      if (g_fReportFirstCounter)
      {
        memset(v37, 170, 17);
        ByteToHex((unint64_t)v37, 17, v7, v6);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          uint64_t v29 = VRTraceErrorLogLevelToCSTR();
          CFRange v30 = *MEMORY[0x1E4F47A50];
          CFRange v31 = *MEMORY[0x1E4F47A50];
          if (*MEMORY[0x1E4F47A40])
          {
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              *(void *)&uint8_t buf[4] = v29;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = "SRTPEncryptData";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&unsigned char buf[24] = 1084;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = v37;
              _os_log_impl(&dword_1E1EA4000, v30, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SRTPEncryptData: Out=[%s]", buf, 0x26u);
            }
          }
          else if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
          {
            SRTPEncryptData_cold_1();
          }
        }
      }
      uint64_t v14 = 0;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 376));
  return v14;
}

void SRTPEncrypt(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)a1 & 2) == 0 || !*(_DWORD *)(a1 + 392)) {
    return;
  }
  int v7 = *(unsigned __int8 *)(a1 + 432);
  if (!g_fReportFirstCounter)
  {
    if (!*(unsigned char *)(a1 + 432)) {
      goto LABEL_18;
    }
    int v7 = 1;
  }
  if (v7) {
    int v8 = 7;
  }
  else {
    int v8 = 8;
  }
  if (v8 <= (int)VRTraceGetErrorLogLevelForModule())
  {
    uint64_t v9 = VRTraceErrorLogLevelToCSTR();
    if (v7)
    {
      uint64_t v10 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_18;
      }
      goto LABEL_15;
    }
    uint64_t v10 = *MEMORY[0x1E4F47A50];
    uint64_t v11 = *MEMORY[0x1E4F47A50];
    if (!*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        unsigned int v15 = VCMediaKeyIndex_Description(*(void **)(a1 + 352));
        uint64_t v16 = *(unsigned int *)(a1 + 120);
        int v17 = 136316418;
        uint64_t v18 = v9;
        __int16 v19 = 2080;
        unint64_t v20 = "SRTPEncrypt";
        __int16 v21 = 1024;
        int v22 = 1124;
        __int16 v23 = 2080;
        uint64_t v24 = v15;
        __int16 v25 = 2048;
        uint64_t v26 = v16;
        __int16 v27 = 1024;
        int v28 = a2;
        _os_log_debug_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEBUG, " [%s] %s:%d SRTPEnc: MKI=%s, SSRC==%08lX, SEQ==%u):", (uint8_t *)&v17, 0x36u);
      }
      goto LABEL_18;
    }
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
LABEL_15:
      int v12 = VCMediaKeyIndex_Description(*(void **)(a1 + 352));
      uint64_t v13 = *(unsigned int *)(a1 + 120);
      int v17 = 136316418;
      uint64_t v18 = v9;
      __int16 v19 = 2080;
      unint64_t v20 = "SRTPEncrypt";
      __int16 v21 = 1024;
      int v22 = 1124;
      __int16 v23 = 2080;
      uint64_t v24 = v12;
      __int16 v25 = 2048;
      uint64_t v26 = v13;
      __int16 v27 = 1024;
      int v28 = a2;
      _os_log_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SRTPEnc: MKI=%s, SSRC==%08lX, SEQ==%u):", (uint8_t *)&v17, 0x36u);
    }
  }
LABEL_18:
  unint64_t v14 = *(void *)(a1 + 144) + 1;
  *(void *)(a1 + 144) = v14;
  if (v14 < 0x1000000000001)
  {
    if (a4 < 0)
    {
      __break(0x5519u);
    }
    else if (a4)
    {
      SRTPEncryptData(a1);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      SRTPEncrypt_cold_1();
    }
  }
}

uint64_t SRTPDecrypt(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)a1 & 4) == 0) {
    return 2149711928;
  }
  if (!*(_DWORD *)(a1 + 392)) {
    return 0;
  }
  int v8 = *(unsigned __int8 *)(a1 + 432);
  if (!g_fReportFirstCounter)
  {
    if (!*(unsigned char *)(a1 + 432)) {
      goto LABEL_19;
    }
    int v8 = 1;
  }
  if (v8) {
    int v9 = 7;
  }
  else {
    int v9 = 8;
  }
  if (v9 > (int)VRTraceGetErrorLogLevelForModule())
  {
LABEL_19:
    if (a4 < 0) {
      goto LABEL_24;
    }
    goto LABEL_20;
  }
  uint64_t v10 = VRTraceErrorLogLevelToCSTR();
  if (!v8)
  {
    uint64_t v11 = *MEMORY[0x1E4F47A50];
    int v12 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
    }
    else if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v15 = VCMediaKeyIndex_Description(*(void **)(a1 + 352));
      uint64_t v16 = *(unsigned int *)(a1 + 120);
      int v17 = 136316418;
      uint64_t v18 = v10;
      __int16 v19 = 2080;
      unint64_t v20 = "SRTPDecrypt";
      __int16 v21 = 1024;
      int v22 = 1152;
      __int16 v23 = 2080;
      uint64_t v24 = v15;
      __int16 v25 = 2048;
      uint64_t v26 = v16;
      __int16 v27 = 1024;
      int v28 = a2;
      _os_log_debug_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEBUG, " [%s] %s:%d SRTPDec: MKI=%s, SSRC==%08lX, SEQ==%u):", (uint8_t *)&v17, 0x36u);
      if (a4 < 0) {
        goto LABEL_24;
      }
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  uint64_t v11 = *MEMORY[0x1E4F47A50];
  if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_19;
  }
LABEL_16:
  uint64_t v13 = VCMediaKeyIndex_Description(*(void **)(a1 + 352));
  uint64_t v14 = *(unsigned int *)(a1 + 120);
  int v17 = 136316418;
  uint64_t v18 = v10;
  __int16 v19 = 2080;
  unint64_t v20 = "SRTPDecrypt";
  __int16 v21 = 1024;
  int v22 = 1152;
  __int16 v23 = 2080;
  uint64_t v24 = v13;
  __int16 v25 = 2048;
  uint64_t v26 = v14;
  __int16 v27 = 1024;
  int v28 = a2;
  _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SRTPDec: MKI=%s, SSRC==%08lX, SEQ==%u):", (uint8_t *)&v17, 0x36u);
  if (a4 < 0) {
LABEL_24:
  }
    __break(0x5519u);
LABEL_20:
  if (a4) {
    return SRTPEncryptData(a1);
  }
  return 0;
}

uint64_t SRTCPEncrypt(uint64_t result, unint64_t a2, int a3, int a4, _DWORD *a5)
{
  uint64_t v5 = 2149711891;
  if ((*(unsigned char *)result & 2) == 0) {
    return 2149711928;
  }
  uint64_t v7 = result;
  if (!*(_DWORD *)(result + 392))
  {
    uint64_t v5 = 0;
    *a5 = a3;
    return v5;
  }
  int v9 = a3 + 4;
  if (a3 + 4 > a4) {
    return 2149711873;
  }
  unsigned int v10 = *(_DWORD *)(result + 368) + 1;
  *(_DWORD *)(result + 368) = v10;
  if (v10 > 0x7FFFFFFE)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTCPEncrypt_cold_1();
      }
    }
    return v5;
  }
  if ((a4 & 0x80000000) == 0 && (a3 & 0x80000000) == 0)
  {
    uint64_t v12 = a3;
    if (a3)
    {
      uint64_t result = SRTPEncryptData(result);
      uint64_t v5 = result;
      unsigned int v10 = *(_DWORD *)(v7 + 368);
    }
    else
    {
      uint64_t v5 = 0;
    }
    uint64_t v13 = (_DWORD *)(a2 + v12);
    if (a2 + v12 >= a2)
    {
      unint64_t v14 = a2 + a4;
      if ((unint64_t)v13 <= v14 && v14 - (unint64_t)v13 >= 4)
      {
        *uint64_t v13 = bswap32(v10 | 0x80000000);
        *a5 = v9;
        return v5;
      }
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t SRTCPDecrypt(uint64_t result, unint64_t a2, int a3, int *a4)
{
  uint64_t v4 = 2149711880;
  if ((*(unsigned char *)result & 4) == 0) {
    return 2149711928;
  }
  if (!*(_DWORD *)(result + 392))
  {
    uint64_t v4 = 0;
    *a4 = a3;
    return v4;
  }
  if (a3 <= 3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTCPDecrypt_cold_1();
      }
    }
    return v4;
  }
  uint64_t v5 = (a3 - 4);
  unsigned int v6 = (unsigned int *)(a2 + v5);
  if (a2 + a3 < a2 + v5 || (unint64_t)v6 < a2 || (unint64_t)a3 - v5 < 4)
  {
    __break(0x5519u);
  }
  else
  {
    uint64_t v4 = 0;
    unsigned int v7 = bswap32(*v6);
    *(_DWORD *)(result + 368) = v7 & 0x7FFFFFFF;
    *a4 = v5;
    if (a3 == 4 || (v7 & 0x80000000) == 0) {
      return v4;
    }
    return SRTPEncryptData(result);
  }
  return result;
}

uint64_t SRTPCalculateTotalSuffixBytes(uint64_t a1, uint64_t a2, char a3)
{
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTPCalculateTotalSuffixBytes_cold_1();
      }
    }
    return 0xFFFFFFFFLL;
  }
  int v3 = *(_DWORD *)(a1 + 408);
  if (v3 != 1)
  {
    if (v3 == 4)
    {
      int v4 = 10;
    }
    else
    {
      if (v3 != 3)
      {
        int v4 = *(_DWORD *)(a1 + 416);
        if (v4 == -1)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              SRTPCalculateTotalSuffixBytes_cold_2();
            }
          }
          return 0xFFFFFFFFLL;
        }
        BOOL v6 = v3 == 1;
        goto LABEL_11;
      }
      int v4 = 4;
    }
    BOOL v6 = (a3 & 0x7F) == 0;
LABEL_11:
    int v7 = v6;
    int v5 = 4 * v7;
    goto LABEL_15;
  }
  int v4 = 0;
  int v5 = 4;
LABEL_15:
  int v8 = _SRTP_MKISize(a1, a2);
  if (v8 != -1) {
    return (v5 + v4 + v8);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      SRTPCalculateTotalSuffixBytes_cold_3();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t _SRTP_MKISize(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 408);
  if ((v3 - 3) < 2) {
    goto LABEL_2;
  }
  if (v3 != 1) {
    return 0;
  }
  if (VCSecurityKeyHolder_SecurityKeyMode(a2) != 1)
  {
LABEL_2:
    int v4 = (pthread_mutex_t *)(a1 + 288);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 288));
    uint64_t v5 = VCMediaKeyIndex_UniquePrefixSize(*(void *)(a1 + 352));
    pthread_mutex_unlock(v4);
    return v5;
  }
  return 16;
}

uint64_t SRTPAddAuthenticationTag(uint64_t a1, uint64_t a2, unsigned int a3, signed int a4, char *a5, signed int a6, signed int *a7)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v13 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTPAddAuthenticationTag_cold_1();
      }
    }
    return v13;
  }
  if (!a7)
  {
    uint64_t v13 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTPAddAuthenticationTag_cold_2();
      }
    }
    return v13;
  }
  *a7 = a6;
  char v35 = -86;
  uint64_t v13 = 0;
  if ((SRTPIsAuthenticationEnabled(a1, (BOOL *)&v35) & 0x80000000) != 0 || !v35) {
    return v13;
  }
  uint64_t v14 = _SRTP_MKISize(a1, a2);
  if (v14 == -1)
  {
    uint64_t v13 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTPAddAuthenticationTag_cold_3();
      }
    }
    return v13;
  }
  uint64_t v15 = v14;
  unsigned int v16 = *(_DWORD *)(a1 + 408);
  if (v16 - 3 >= 2)
  {
    if (v16 == 1)
    {
      int v17 = 4;
      goto LABEL_15;
    }
    int v17 = 0;
  }
  else
  {
    int v17 = 4 * ((a3 & 0x7F) == 0);
  }
  if (v16 != 1)
  {
    if (v16 == 4)
    {
      signed int v18 = 10;
    }
    else if (v16 == 3)
    {
      signed int v18 = 4;
    }
    else
    {
      signed int v18 = *(_DWORD *)(a1 + 416);
      if (v18 == -1)
      {
        uint64_t v13 = 2149711873;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            SRTPAddAuthenticationTag_cold_4();
          }
        }
        return v13;
      }
    }
    goto LABEL_18;
  }
LABEL_15:
  signed int v18 = 0;
LABEL_18:
  unsigned int v19 = v14 + a6;
  uint64_t v20 = (v14 + a6 + v17 + v18);
  if (v20 > a4)
  {
    uint64_t v13 = 2149711886;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v30 = VRTraceErrorLogLevelToCSTR();
      CFRange v31 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        unsigned int __src = 136316930;
        uint64_t v38 = v30;
        __int16 v39 = 2080;
        __int16 v40 = "SRTPAddAuthenticationTag";
        __int16 v41 = 1024;
        int v42 = 1536;
        __int16 v43 = 1024;
        signed int v44 = a6;
        __int16 v45 = 1024;
        int v46 = v15;
        __int16 v47 = 1024;
        int v48 = v17;
        __int16 v49 = 1024;
        signed int v50 = v18;
        __int16 v51 = 1024;
        signed int v52 = a4;
        _os_log_error_impl(&dword_1E1EA4000, v31, OS_LOG_TYPE_ERROR, " [%s] %s:%d SRTP authentication tag does not fit in packet. dataLength=%d, mkiSize=%d, rocSize=%d, hmacSize=%d,  maxBufferLength=%d", (uint8_t *)&__src, 0x3Au);
        return 2149711886;
      }
    }
  }
  else
  {
    unsigned int v34 = &a5[a4];
    if (v16 > 4 || ((1 << v16) & 0x1A) == 0)
    {
LABEL_50:
      if (!v18) {
        return 0;
      }
      int v28 = &a5[*a7];
      if (v28 <= v34
        && v28 >= a5
        && ((v18 | a4) & 0x80000000) == 0
        && v34 - v28 >= v18
        && a6 <= a4
        && (a6 & 0x80000000) == 0)
      {
        SRTPGenerateAuthenticationTag((_DWORD *)a1, 1, a3, a5, a6, v28, v18);
        uint64_t v13 = 0;
        *a7 += v18;
        return v13;
      }
LABEL_85:
      __break(0x5519u);
    }
    unsigned int __n = v17;
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 288));
    if (VCMediaKeyIndex_isValid(*(void **)(a1 + 352)))
    {
      __int16 v21 = &a5[a6];
      if (v21)
      {
        if (v21 >= v34 || v21 < a5) {
          goto LABEL_85;
        }
        VCMediaKeyIndex_UniquePrefixBytes(*(void *)(a1 + 352), v21, v15);
        if (!VCMediaKeyIndex_isEqual(*(void *)(a1 + 360), *(void *)(a1 + 352))) {
          VCMediaKeyIndex_ReleaseAndCopyNewValue((const void **)(a1 + 360), *(void **)(a1 + 352));
        }
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 288));
        *a7 += v15;
        if (a4 < 0) {
          goto LABEL_85;
        }
        if (a5)
        {
          int v22 = *(_DWORD *)(a1 + 408);
          if (v22 == 1 || (int v23 = 0, (a3 & 0x7F) == 0) && (v22 - 3) <= 1)
          {
            int v36 = 0;
            SRTPGetROC(a1, a3, &v36, 1);
            unsigned int __src = bswap32((16 * (v15 & 0xF)) | (v36 << 8));
            uint64_t v24 = &a5[v19];
            int v23 = __n;
            if (v24 < a5 || v24 > &a5[v20] || v20 - (unint64_t)v19 < __n) {
              goto LABEL_85;
            }
            memcpy(v24, &__src, __n);
          }
        }
        else
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              SRTPAddAuthenticationTag_cold_8();
            }
          }
          int v23 = -1;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          uint64_t v25 = VRTraceErrorLogLevelToCSTR();
          uint64_t v26 = *MEMORY[0x1E4F47A50];
          __int16 v27 = *MEMORY[0x1E4F47A50];
          if (*MEMORY[0x1E4F47A40])
          {
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              unsigned int __src = 136316418;
              uint64_t v38 = v25;
              __int16 v39 = 2080;
              __int16 v40 = "SRTPAddAuthenticationTag";
              __int16 v41 = 1024;
              int v42 = 1548;
              __int16 v43 = 1024;
              signed int v44 = __n;
              __int16 v45 = 1024;
              int v46 = v18;
              __int16 v47 = 1024;
              int v48 = v15;
              _os_log_impl(&dword_1E1EA4000, v26, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d uplink rocSize=%d, hmacSize=%d, mkiSize=%d", (uint8_t *)&__src, 0x2Eu);
            }
          }
          else if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
          {
            unsigned int __src = 136316418;
            uint64_t v38 = v25;
            __int16 v39 = 2080;
            __int16 v40 = "SRTPAddAuthenticationTag";
            __int16 v41 = 1024;
            int v42 = 1548;
            __int16 v43 = 1024;
            signed int v44 = __n;
            __int16 v45 = 1024;
            int v46 = v18;
            __int16 v47 = 1024;
            int v48 = v15;
            _os_log_debug_impl(&dword_1E1EA4000, v26, OS_LOG_TYPE_DEBUG, " [%s] %s:%d uplink rocSize=%d, hmacSize=%d, mkiSize=%d", (uint8_t *)&__src, 0x2Eu);
          }
        }
        if (v23 != -1)
        {
          *a7 += v23;
          goto LABEL_50;
        }
        uint64_t v13 = 2149711873;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            SRTPAddAuthenticationTag_cold_7();
          }
        }
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            SRTPAddAuthenticationTag_cold_6();
          }
        }
        uint64_t v13 = 2149711873;
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 288));
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            SRTPAddAuthenticationTag_cold_5();
          }
        }
      }
    }
    else
    {
      uint64_t v13 = 2149711873;
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 288));
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          SRTPAddAuthenticationTag_cold_9();
        }
      }
    }
  }
  return v13;
}

uint64_t SRTPIsAuthenticationEnabled(uint64_t a1, BOOL *a2)
{
  uint64_t v2 = 2149711876;
  if ((*(unsigned char *)a1 & 8) == 0) {
    return 2149711928;
  }
  int v3 = *(_DWORD *)(a1 + 408);
  *a2 = v3 != 0;
  if (!v3 || *(int *)(a1 + 416) > 0) {
    return 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      SRTPIsAuthenticationEnabled_cold_1();
    }
  }
  return v2;
}

void *SRTPGenerateAuthenticationTag(_DWORD *a1, int a2, unsigned int a3, const void *a4, unsigned int a5, void *a6, unsigned int a7)
{
  unsigned int v18 = a3;
  unsigned int v19 = v17;
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  size_t v13 = a1[106];
  MEMORY[0x1F4188790](a1);
  if (v13) {
    memset(&v17[-((v13 + 15) & 0x1FFFFFFF0)], 170, v13);
  }
  *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v21.ctx[88] = v14;
  *(_OWORD *)&v21.ctx[92] = v14;
  *(_OWORD *)&v21.ctx[80] = v14;
  *(_OWORD *)&v21.ctx[84] = v14;
  *(_OWORD *)&v21.ctx[72] = v14;
  *(_OWORD *)&v21.ctx[76] = v14;
  *(_OWORD *)&v21.ctx[64] = v14;
  *(_OWORD *)&v21.ctx[68] = v14;
  *(_OWORD *)&v21.ctx[56] = v14;
  *(_OWORD *)&v21.ctx[60] = v14;
  *(_OWORD *)&v21.ctx[48] = v14;
  *(_OWORD *)&v21.ctx[52] = v14;
  *(_OWORD *)&v21.ctx[40] = v14;
  *(_OWORD *)&v21.ctx[44] = v14;
  *(_OWORD *)&v21.ctx[32] = v14;
  *(_OWORD *)&v21.ctx[36] = v14;
  *(_OWORD *)&v21.ctx[24] = v14;
  *(_OWORD *)&v21.ctx[28] = v14;
  *(_OWORD *)&v21.ctx[16] = v14;
  *(_OWORD *)&v21.ctx[20] = v14;
  *(_OWORD *)&v21.ctx[8] = v14;
  *(_OWORD *)&v21.ctx[12] = v14;
  unsigned int v15 = a1[102] - 3;
  *(_OWORD *)v21.ctx = v14;
  *(_OWORD *)&v21.ctx[4] = v14;
  CCHmacInit(&v21, 2 * (v15 < 2), a1 + 63, (int)a1[103]);
  CCHmacUpdate(&v21, a4, a5);
  if (a2)
  {
    unsigned int v20 = -1431655766;
    SRTPGetROC((uint64_t)a1, v18, (int *)&v20, 1);
    unsigned int v20 = bswap32(v20);
    CCHmacUpdate(&v21, &v20, 4uLL);
  }
  CCHmacFinal(&v21, &v17[-((v13 + 15) & 0x1FFFFFFF0)]);
  if (v13 < a7) {
    __break(0x5519u);
  }
  return memcpy(a6, &v17[-((v13 + 15) & 0x1FFFFFFF0)], a7);
}

uint64_t SRTPVerifyAuthenticationTag(uint64_t a1, unsigned int a2, char *a3, unsigned int a4, unsigned int *a5, unsigned char *a6)
{
  unsigned int v48 = a2;
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  int64_t v11 = *(unsigned int *)(a1 + 416);
  MEMORY[0x1F4188790](a1);
  if (v11) {
    memset((char *)&v40 - ((v11 + 15) & 0x1FFFFFFF0), 170, v11);
  }
  if (!a3)
  {
    uint64_t v15 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
      goto LABEL_93;
    }
    size_t v37 = a5;
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      SRTPVerifyAuthenticationTag_cold_1();
    }
    goto LABEL_89;
  }
  if (!a6)
  {
    uint64_t v15 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
      goto LABEL_93;
    }
    size_t v37 = a5;
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      SRTPVerifyAuthenticationTag_cold_2();
    }
    goto LABEL_89;
  }
  if (!a5)
  {
    uint64_t v15 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
      goto LABEL_93;
    }
    size_t v37 = 0;
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      SRTPVerifyAuthenticationTag_cold_3();
    }
    goto LABEL_89;
  }
  char v49 = -86;
  int v12 = SRTPIsAuthenticationEnabled(a1, (BOOL *)&v49);
  unsigned int v13 = 0;
  int v14 = v49;
  *a5 = a4;
  uint64_t v15 = 0;
  if (v12 < 0 || !v14) {
    goto LABEL_67;
  }
  unsigned int v16 = *(_DWORD *)(a1 + 408);
  if (v16 == 1)
  {
    uint64_t v15 = 0;
    unsigned int v17 = 4;
    goto LABEL_21;
  }
  if (v16 == 4)
  {
    uint64_t v15 = 10;
    goto LABEL_14;
  }
  if (v16 != 3)
  {
    uint64_t v15 = *(unsigned int *)(a1 + 416);
    if (v15 != -1)
    {
      BOOL v18 = v16 == 1;
      goto LABEL_17;
    }
    uint64_t v15 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
      goto LABEL_93;
    }
    size_t v37 = a5;
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      SRTPVerifyAuthenticationTag_cold_4();
    }
LABEL_89:
    unsigned int v13 = 0;
    goto LABEL_71;
  }
  uint64_t v15 = 4;
LABEL_14:
  BOOL v18 = (v48 & 0x7F) == 0;
LABEL_17:
  int v19 = v18;
  unsigned int v17 = 4 * v19;
LABEL_21:
  unsigned int v13 = v17 + v15;
  uint64_t v20 = a4 - (v17 + v15);
  if (a4 < v17 + v15)
  {
    uint64_t v15 = 2149711880;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      __int16 v39 = a5;
      VRTraceErrorLogLevelToCSTR();
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        unsigned int v13 = 0;
        goto LABEL_99;
      }
      SRTPVerifyAuthenticationTag_cold_5();
      unsigned int v13 = 0;
      goto LABEL_105;
    }
LABEL_93:
    unsigned int v13 = 0;
    goto LABEL_67;
  }
  uint64_t v21 = (int)a4;
  if (v16 > 4 || ((1 << v16) & 0x1A) == 0) {
    goto LABEL_59;
  }
  int v46 = a6;
  if ((a4 & 0x80000000) != 0) {
    goto LABEL_106;
  }
  uint64_t v47 = (int)a4;
  if (v16 != 1)
  {
    unsigned int v22 = v16 - 3;
    if ((v48 & 0x7F) != 0 || v22 > 1)
    {
      if (v22 < 2)
      {
        unsigned int v43 = v17;
        int v25 = 2;
        goto LABEL_35;
      }
      uint64_t v15 = 2149711873;
      if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
        goto LABEL_67;
      }
      size_t v37 = a5;
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTPVerifyAuthenticationTag_cold_10();
      }
LABEL_71:
      a5 = v37;
      goto LABEL_67;
    }
  }
  *(_DWORD *)buf = 0;
  if (&a3[a4] < &a3[v20] || &a3[v20] < a3 || (unint64_t)a4 - v20 < v17) {
    goto LABEL_106;
  }
  unsigned int v43 = v17;
  __memcpy_chk();
  unsigned int v23 = bswap32(*(unsigned int *)buf);
  *(_DWORD *)(a1 + 124) = v23 >> 8;
  int v24 = v23 >> 4;
  if (v24) {
    int v25 = v24;
  }
  else {
    int v25 = 16;
  }
  uint64_t v21 = v47;
LABEL_35:
  unsigned int v26 = v25 + v13;
  if (v25 + v13 > a4)
  {
    uint64_t v15 = 2149711880;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
      goto LABEL_67;
    }
    __int16 v39 = a5;
    VRTraceErrorLogLevelToCSTR();
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      goto LABEL_99;
    }
    SRTPVerifyAuthenticationTag_cold_7();
LABEL_105:
    uint64_t v15 = 2149711880;
    goto LABEL_99;
  }
  unint64_t v27 = (unint64_t)&a3[v21 - v26];
  __int16 v45 = a5;
  unsigned int v44 = v25;
  if (&a3[v21] == (char *)v26)
  {
    LODWORD(v42) = -2145255423;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTPVerifyAuthenticationTag_cold_9();
      }
    }
  }
  else
  {
    if (v27 >= (unint64_t)&a3[v21] || v27 < (unint64_t)a3) {
      goto LABEL_106;
    }
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 288));
    VCMediaKeyIndex_Release((const void **)(a1 + 360));
    id MKIWithBytes = VCMediaKeyIndex_CreateMKIWithBytes(v27, v44);
    *(void *)(a1 + 360) = MKIWithBytes;
    if (!VCMediaKeyIndex_isStartingWithPrefix(*(void *)(a1 + 352), (uint64_t)MKIWithBytes))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        uint64_t v42 = VRTraceErrorLogLevelToCSTR();
        uint64_t v29 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          __int16 v41 = VCMediaKeyIndex_Description(*(void **)(a1 + 352));
          uint64_t v30 = VCMediaKeyIndex_Description(*(void **)(a1 + 360));
          *(_DWORD *)buf = 136316162;
          uint64_t v51 = v42;
          __int16 v52 = 2080;
          uint64_t v53 = "_SRTP_ReadVariableMKI";
          __int16 v54 = 1024;
          int v55 = 1444;
          __int16 v56 = 2080;
          *(void *)long long v57 = v41;
          *(_WORD *)&v57[8] = 2080;
          long long v58 = v30;
          _os_log_impl(&dword_1E1EA4000, v29, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d MKI has changed from '%s' to '%s'", buf, 0x30u);
        }
      }
      *int v46 = 1;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 288));
    LODWORD(v42) = 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
    goto LABEL_56;
  }
  uint64_t v31 = VRTraceErrorLogLevelToCSTR();
  __int16 v32 = *MEMORY[0x1E4F47A50];
  size_t v33 = *MEMORY[0x1E4F47A50];
  if (!*MEMORY[0x1E4F47A40])
  {
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136316418;
      uint64_t v51 = v31;
      __int16 v52 = 2080;
      uint64_t v53 = "SRTPVerifyAuthenticationTag";
      __int16 v54 = 1024;
      int v55 = 1597;
      __int16 v56 = 1024;
      *(_DWORD *)long long v57 = v43;
      *(_WORD *)&uint8_t v57[4] = 1024;
      *(_DWORD *)&v57[6] = v15;
      LOWORD(v58) = 1024;
      *(_DWORD *)((char *)&v58 + 2) = v44;
      _os_log_debug_impl(&dword_1E1EA4000, v32, OS_LOG_TYPE_DEBUG, " [%s] %s:%d downlink rocSize=%d, hmacSize=%d, mkiSize=%d", buf, 0x2Eu);
      if (!v27) {
        goto LABEL_73;
      }
      goto LABEL_57;
    }
    goto LABEL_56;
  }
  if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
LABEL_56:
    if (!v27) {
      goto LABEL_73;
    }
    goto LABEL_57;
  }
  *(_DWORD *)buf = 136316418;
  uint64_t v51 = v31;
  __int16 v52 = 2080;
  uint64_t v53 = "SRTPVerifyAuthenticationTag";
  __int16 v54 = 1024;
  int v55 = 1597;
  __int16 v56 = 1024;
  *(_DWORD *)long long v57 = v43;
  *(_WORD *)&uint8_t v57[4] = 1024;
  *(_DWORD *)&v57[6] = v15;
  LOWORD(v58) = 1024;
  *(_DWORD *)((char *)&v58 + 2) = v44;
  _os_log_impl(&dword_1E1EA4000, v32, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d downlink rocSize=%d, hmacSize=%d, mkiSize=%d", buf, 0x2Eu);
  if (v27)
  {
LABEL_57:
    a5 = v45;
    if (*v46)
    {
      uint64_t v15 = 0;
      unsigned int v13 = v26;
      goto LABEL_67;
    }
    unsigned int v13 = v26;
    uint64_t v21 = v47;
LABEL_59:
    if (!v15) {
      goto LABEL_67;
    }
    unsigned int v34 = &a3[v21];
    if (&a3[v21] >= a3 && (v15 & 0x80000000) == 0 && (int)v15 <= v11)
    {
      unsigned int v35 = a4 - v13;
      if ((int)(a4 - v13) <= (int)a4 && (v35 & 0x80000000) == 0)
      {
        SRTPGenerateAuthenticationTag((_DWORD *)a1, 1, v48, a3, v35, (char *)&v40 - ((v11 + 15) & 0x1FFFFFFF0), v15);
        if (!timingsafe_bcmp(&v34[-v15], (char *)&v40 - ((v11 + 15) & 0x1FFFFFFF0), v15))
        {
          uint64_t v15 = 0;
          goto LABEL_67;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        {
          uint64_t v15 = 2149711929;
          goto LABEL_67;
        }
        __int16 v39 = a5;
        VRTraceErrorLogLevelToCSTR();
        uint64_t v15 = 2149711929;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          SRTPVerifyAuthenticationTag_cold_6();
        }
LABEL_99:
        a5 = v39;
        goto LABEL_67;
      }
    }
LABEL_106:
    __break(0x5519u);
  }
LABEL_73:
  if ((int)VRTraceGetErrorLogLevelForModule() < 3)
  {
    unsigned int v13 = v26;
    a5 = v45;
    uint64_t v15 = v42;
  }
  else
  {
    VRTraceErrorLogLevelToCSTR();
    BOOL v38 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
    uint64_t v15 = v42;
    if (v38) {
      SRTPVerifyAuthenticationTag_cold_8();
    }
    unsigned int v13 = v26;
    a5 = v45;
  }
LABEL_67:
  *a5 -= v13;
  return v15;
}

uint64_t SRTCPAddAuthenticationTag(_DWORD *a1, signed int a2, char *a3, signed int a4, signed int *a5)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  *a5 = a4;
  char v15 = -86;
  uint64_t result = SRTPIsAuthenticationEnabled((uint64_t)a1, (BOOL *)&v15);
  uint64_t v11 = result;
  if ((result & 0x80000000) != 0 || !v15) {
    return v11;
  }
  int64_t v12 = (int)a1[104];
  if ((int)v12 + a4 > a2)
  {
    uint64_t v11 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTCPAddAuthenticationTag_cold_1();
      }
    }
    return v11;
  }
  unsigned int v13 = &a3[a2];
  int v14 = &a3[a4];
  if (v14 <= v13
    && v14 >= a3
    && v13 - v14 >= v12
    && ((v12 | a2) & 0x80000000) == 0
    && a4 <= a2
    && (a4 & 0x80000000) == 0)
  {
    SRTPGenerateAuthenticationTag(a1, 0, 0, a3, a4, v14, v12);
    uint64_t v11 = 0;
    *a5 += a1[104];
    return v11;
  }
  __break(0x5519u);
  return result;
}

uint64_t SRTCPVerifyAuthenticationTag(_DWORD *a1, char *a2, int a3, int *a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  *a4 = a3;
  char v15 = -86;
  uint64_t v8 = SRTPIsAuthenticationEnabled((uint64_t)a1, (BOOL *)&v15);
  uint64_t v9 = v8;
  if ((v8 & 0x80000000) != 0 || !v15) {
    return v9;
  }
  int64_t v10 = a1[104];
  if ((int)v10 > a3)
  {
    uint64_t v9 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTCPVerifyAuthenticationTag_cold_1();
      }
    }
    return v9;
  }
  uint64_t result = MEMORY[0x1F4188790](v8);
  if (v10) {
    uint64_t result = (uint64_t)memset(&v14[-((v10 + 15) & 0x1FFFFFFF0)], 170, v10);
  }
  int64_t v12 = (int)a1[104];
  if (v12 <= v10 && ((v12 | a3) & 0x80000000) == 0 && ((a3 - v12) & 0x80000000) == 0)
  {
    SRTPGenerateAuthenticationTag(a1, 0, 0, a2, a3 - v12, &v14[-((v10 + 15) & 0x1FFFFFFF0)], v12);
    int v13 = a1[104];
    if (!memcmp(&a2[a3 - v13], &v14[-((v10 + 15) & 0x1FFFFFFF0)], v13))
    {
      uint64_t v9 = 0;
      *a4 -= v13;
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    {
      return 2149711929;
    }
    else
    {
      VRTraceErrorLogLevelToCSTR();
      uint64_t v9 = 2149711929;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        SRTCPVerifyAuthenticationTag_cold_2();
      }
    }
    return v9;
  }
  __break(0x5519u);
  return result;
}

uint64_t WaitUseEncryption(uint64_t a1, double *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  v12.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&v12.tv_usec = 0xAAAAAAAAAAAAAAAALL;
  int v4 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if (*(_DWORD *)(a1 + 4))
  {
    uint64_t v5 = 2149711902;
  }
  else
  {
    if ((*(unsigned char *)a1 & 6) != 0)
    {
LABEL_5:
      pthread_mutex_unlock(v4);
      return 0;
    }
    uint64_t v5 = 2149711902;
    while (1)
    {
      gettimeofday(&v12, 0);
      double v7 = (double)v12.tv_sec + (double)v12.tv_usec * 0.000001;
      v11.tv_sec = 0xAAAAAAAAAAAAAAAALL;
      v11.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      convertTimeoutToRelativeTimespec(*a2);
      v11.tv_sec = v8;
      v11.tv_nsec = v9;
      pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 72), v4, &v11);
      gettimeofday(&v12, 0);
      double v10 = (double)v12.tv_sec + (double)v12.tv_usec * 0.000001 - v7;
      if (v10 >= *a2) {
        break;
      }
      if (*(_DWORD *)(a1 + 4)) {
        goto LABEL_3;
      }
      *a2 = *a2 - v10;
      if ((*(unsigned char *)a1 & 6) != 0) {
        goto LABEL_5;
      }
    }
    uint64_t v5 = 2149711876;
  }
LABEL_3:
  *a2 = 0.0;
  pthread_mutex_unlock(v4);
  return v5;
}

uint64_t SRTPCancelEncryption()
{
  uint64_t result = CheckInHandleDebug();
  if (result)
  {
    _SRTPCancelEncryption(result);
    return CheckOutHandleDebug();
  }
  return result;
}

unint64_t SRTPWaitUseEncryption(uint64_t a1, double *a2)
{
  uint64_t v3 = 2147549186;
  unint64_t result = CheckInHandleDebug();
  if (!result) {
    return v3;
  }
  unint64_t v5 = result;
  if (result == 0xFFFFFFFF) {
    return 2147549190;
  }
  uint64_t v3 = 2149711928;
  if (!*(_DWORD *)(result + 7080) || !*(_DWORD *)(result + 7520))
  {
LABEL_9:
    CheckOutHandleDebug();
    return v3;
  }
  if (result < result + 27616)
  {
    uint64_t v3 = WaitUseEncryption(result + 7080, a2);
    if (!v3)
    {
      *a2 = *a2 + 0.1;
      uint64_t v3 = WaitUseEncryption(v5 + 7520, a2);
    }
    goto LABEL_9;
  }
  __break(0x5519u);
  return result;
}

uint64_t SRTPGetFramingOverhead(uint64_t a1, uint64_t *a2)
{
  if (!a2) {
    return 2149711873;
  }
  unint64_t v3 = CheckInHandleDebug();
  if (!v3) {
    return 2147549186;
  }
  uint64_t v4 = 10;
  switch(*(_DWORD *)(v3 + 7500))
  {
    case 1:
    case 4:
    case 7:
      goto LABEL_10;
    case 3:
    case 6:
      if (v3 >= v3 + 27616)
      {
        __break(0x5519u);
        JUMPOUT(0x1E2130688);
      }
      uint64_t v4 = _SRTP_MKISize(v3 + 7080, *(void *)(v3 + 10448)) + 4;
      goto LABEL_10;
    case 8:
      uint64_t v4 = 12;
      goto LABEL_10;
    case 9:
      uint64_t v4 = 6;
LABEL_10:
      *a2 = v4;
      break;
    default:
      break;
  }
  CheckOutHandleDebug();
  return 0;
}

void *MakeSessionKey(uint64_t a1, const void *a2, unsigned int a3, uint64_t a4, char a5, void *a6, unsigned int a7)
{
  int v14 = a1;
  v31[1] = *MEMORY[0x1E4F143B8];
  LODWORD(v7) = vcvtd_n_s64_f64(ceil((double)(int)a7 * 0.0625), 4uLL);
  uint64_t v15 = (v7 + 15) & 0x1FFFFFFF0;
  uint64_t v16 = MEMORY[0x1F4188790](a1);
  unsigned int v17 = (char *)v31 - v15;
  if (v7)
  {
    BOOL v18 = memset((char *)v31 - v15, 170, v7);
    MEMORY[0x1F4188790](v18);
    dataOut = (char *)v31 - v15;
    memset(dataOut, 170, v7);
    v31[0] = 0xAAAAAAAAAAAAAAAALL;
    if ((v7 & 0x80000000) == 0) {
      int v20 = v7;
    }
    else {
      int v20 = v7 + 15;
    }
    if ((int)v7 >= 16)
    {
      unsigned __int8 v21 = 0;
      unsigned int v22 = &v17[v7];
      int v23 = v20 >> 4;
      unint64_t v24 = v7;
      int v25 = v17;
      while (v25 <= (void *)v22)
      {
        if (v17 > (char *)v25) {
          break;
        }
        if (v24 <= 0xD) {
          break;
        }
        *int v25 = *(void *)a4;
        *(void *)((char *)v25 + 6) = *(void *)(a4 + 6);
        unsigned int v26 = (char *)v25 + 14;
        if (v26 >= v22) {
          break;
        }
        if (v26 < v17) {
          break;
        }
        *unsigned int v26 = 0;
        unint64_t v27 = v26 + 1;
        if (v27 >= v22) {
          break;
        }
        if (v27 < v17) {
          break;
        }
        char *v27 = v21;
        int v28 = v27 - 8;
        if (v28 >= v22 || v28 < v17) {
          break;
        }
        *int v28 = *(unsigned char *)(a4 + 7) ^ a5;
        int v25 = v28 + 9;
        ++v21;
        v24 -= 16;
        if (v23 <= v21) {
          goto LABEL_19;
        }
      }
LABEL_24:
      __break(0x5519u);
    }
  }
  else
  {
    MEMORY[0x1F4188790](v16);
    dataOut = (char *)v31 - v15;
    v31[0] = 0xAAAAAAAAAAAAAAAALL;
  }
LABEL_19:
  if (v14) {
    CCOptions v29 = 2;
  }
  else {
    CCOptions v29 = 0;
  }
  CCCrypt(0, 0, v29, a2, a3, 0, v17, (int)v7, dataOut, (int)v7, v31);
  if (v7 < a7) {
    goto LABEL_24;
  }
  return memcpy(a6, dataOut, a7);
}

uint64_t VCCCMessageReadFrom(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    size_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
      {
        Data = (void *)PBReaderReadData();

        id v25 = Data;
        uint64_t v26 = 16;
      }
      else
      {
        if (v17 != 2)
        {
          if (v17 == 1)
          {
            char v18 = 0;
            unsigned int v19 = 0;
            uint64_t v20 = 0;
            while (1)
            {
              uint64_t v21 = *v3;
              unint64_t v22 = *(void *)(a2 + v21);
              if (v22 == -1 || v22 >= *(void *)(a2 + *v4)) {
                break;
              }
              char v23 = *(unsigned char *)(*(void *)(a2 + *v7) + v22);
              *(void *)(a2 + v21) = v22 + 1;
              v20 |= (unint64_t)(v23 & 0x7F) << v18;
              if ((v23 & 0x80) == 0) {
                goto LABEL_34;
              }
              v18 += 7;
              BOOL v14 = v19++ >= 9;
              if (v14)
              {
                uint64_t v20 = 0;
                goto LABEL_36;
              }
            }
            *(unsigned char *)(a2 + *v5) = 1;
LABEL_34:
            if (*(unsigned char *)(a2 + *v5)) {
              uint64_t v20 = 0;
            }
LABEL_36:
            *(void *)(a1 + 8) = v20;
          }
          else
          {
            uint64_t result = PBReaderSkipValueWithTag();
            if (!result) {
              return result;
            }
          }
          continue;
        }
        String = (void *)PBReaderReadString();

        id v25 = String;
        uint64_t v26 = 24;
      }
      *(void *)(a1 + v26) = v25;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t VideoReceiverUtil_CreateTempFile(uint64_t *a1, uint64_t a2, _DWORD *a3, char *a4)
{
  uint64_t result = open(a4, 1538, 420);
  if (result)
  {
    int v8 = result;
    fcntl(result, 48, 0);
    *a3 = v8;
    uint64_t result = FigFileWrapDarwinFileDesc();
    if (a2)
    {
      if (!result)
      {
        uint64_t v9 = *a1;
        uint64_t v10 = *MEMORY[0x1E4F1CF80];
        return MEMORY[0x1F40DC778](v9, v10, a2);
      }
    }
  }
  return result;
}

uint64_t VideoReceiverUtil_CaptureBitstreamFile(OpaqueCMBlockBuffer *a1, int32_t timescale, uint64_t a3, const opaqueCMFormatDescription *a4, int a5)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  CMSampleBufferRef sbuf = (CMSampleBufferRef)0xAAAAAAAAAAAAAAAALL;
  sampleTimingArray.decodeTimeStamp.epoch = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&sampleTimingArray.presentationTimeStamp.timescale = v9;
  *(_OWORD *)&sampleTimingArray.decodeTimeStamp.value = v9;
  *(_OWORD *)&sampleTimingArray.duration.value = v9;
  *(_OWORD *)&sampleTimingArray.duration.epoch = v9;
  if (a5) {
    int v10 = a5;
  }
  else {
    int v10 = 33;
  }
  if (*(_DWORD *)(a3 + 60))
  {
    CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  }
  else
  {
    memset(v46, 170, sizeof(v46));
    gettimeofday((timeval *)v46, &v46[16]);
    time_t v45 = *(void *)v46;
    memset(__b, 170, sizeof(__b));
    memset(v49, 170, sizeof(v49));
    uint64_t v21 = localtime(&v45);
    strftime(v49, 0x3E8uLL, "%m-%d-%Y_%T", v21);
    snprintf(__b, 0x3E8uLL, "/tmp/Capture%s.mov", v49);
    uint64_t TempFile = VideoReceiverUtil_CreateTempFile((uint64_t *)(a3 + 32), a3 + 40, (_DWORD *)(a3 + 64), __b);
    if (TempFile) {
      goto LABEL_50;
    }
    CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t TempFile = FigMovieFormatWriterCreateWithByteStream();
    if (TempFile) {
      goto LABEL_50;
    }
    uint64_t v22 = *(void *)(a3 + 48);
    uint64_t v23 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v23) {
      uint64_t v24 = v23;
    }
    else {
      uint64_t v24 = 0;
    }
    uint64_t v30 = *(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v24 + 8);
    if (!v30) {
      goto LABEL_30;
    }
    uint64_t v26 = v30(v22, 1986618469, 0, a3 + 56);
    if (v26) {
      goto LABEL_31;
    }
  }
  CMTimeMake((CMTime *)__b, v10, timescale);
  *(_OWORD *)&sampleTimingArray.duration.value = *(_OWORD *)__b;
  sampleTimingArray.duration.epoch = *(void *)&__b[16];
  CMTimeMake((CMTime *)__b, *(int *)(a3 + 60), timescale);
  sampleTimingArray.presentationTimeStamp = *(CMTime *)__b;
  sampleTimingArray.decodeTimeStamp = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  size_t sampleSizeArray = CMBlockBufferGetDataLength(a1);
  uint64_t TempFile = CMSampleBufferCreate(v11, a1, 1u, 0, 0, a4, 1, 1, &sampleTimingArray, 1, &sampleSizeArray, &sbuf);
  if (TempFile)
  {
LABEL_50:
    uint64_t v26 = TempFile;
    goto LABEL_31;
  }
  CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(sbuf, 1u);
  if (SampleAttachmentsArray)
  {
    ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
    int v15 = (const void *)*MEMORY[0x1E4F1CFD0];
    CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F1F200], (const void *)*MEMORY[0x1E4F1CFD0]);
    CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F1F1A8], v15);
    CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F1F1C0], v15);
  }
  uint64_t v16 = *(void *)(a3 + 48);
  uint64_t v17 = *(unsigned int *)(a3 + 56);
  CMSampleBufferRef v18 = sbuf;
  uint64_t v19 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v19) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = 0;
  }
  id v25 = *(uint64_t (**)(uint64_t, uint64_t, CMSampleBufferRef))(v20 + 32);
  if (!v25)
  {
    CFRelease(sbuf);
LABEL_30:
    uint64_t v26 = 4294954514;
    goto LABEL_31;
  }
  uint64_t v26 = v25(v16, v17, v18);
  CFRelease(sbuf);
  if (!v26)
  {
    uint64_t v27 = *(void *)(a3 + 48);
    uint64_t v28 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v28) {
      uint64_t v29 = v28;
    }
    else {
      uint64_t v29 = 0;
    }
    uint64_t v31 = *(uint64_t (**)(uint64_t, void))(v29 + 40);
    if (v31)
    {
      uint64_t TempFile = v31(v27, 0);
      if (!TempFile)
      {
        uint64_t v32 = *(void *)(a3 + 48);
        uint64_t v33 = *(void *)(CMBaseObjectGetVTable() + 16);
        if (v33) {
          uint64_t v34 = v33;
        }
        else {
          uint64_t v34 = 0;
        }
        uint64_t v42 = *(uint64_t (**)(uint64_t, void))(v34 + 48);
        if (v42) {
          uint64_t v26 = v42(v32, 0);
        }
        else {
          uint64_t v26 = 4294954514;
        }
        *(_DWORD *)(a3 + 60) += v10;
        return v26;
      }
      goto LABEL_50;
    }
    goto LABEL_30;
  }
LABEL_31:
  if (*(void *)(a3 + 48))
  {
    uint64_t FigBaseObject = FigFormatWriterGetFigBaseObject();
    if (FigBaseObject)
    {
      uint64_t v36 = FigBaseObject;
      uint64_t v37 = *(void *)(CMBaseObjectGetVTable() + 8);
      uint64_t v38 = v37 ? v37 : 0;
      __int16 v39 = *(void (**)(uint64_t))(v38 + 24);
      if (v39) {
        v39(v36);
      }
    }
    CFRelease(*(CFTypeRef *)(a3 + 48));
  }
  uint64_t v40 = *(const void **)(a3 + 40);
  if (v40) {
    CFRelease(v40);
  }
  if (*(void *)(a3 + 32))
  {
    FigFileForkClose();
    int v41 = *(_DWORD *)(a3 + 64);
    if (v41) {
      close(v41);
    }
  }
  return v26;
}

uint64_t FigFormatWriterInvalidate()
{
  uint64_t result = FigFormatWriterGetFigBaseObject();
  if (result)
  {
    uint64_t v1 = result;
    uint64_t VTable = CMBaseObjectGetVTable();
    uint64_t v4 = *(void *)(VTable + 8);
    uint64_t result = VTable + 8;
    uint64_t v3 = v4;
    uint64_t v5 = v4 ? v3 : 0;
    BOOL v6 = *(uint64_t (**)(uint64_t))(v5 + 24);
    if (v6)
    {
      return v6(v1);
    }
  }
  return result;
}

uint64_t VideoReceiverUtil_Capture2vuyFile(void *memoryBlock, int a2, int32_t a3, int32_t a4, int32_t a5, uint64_t a6, int a7)
{
  v47[1] = *(CMSampleBufferRef *)MEMORY[0x1E4F143B8];
  CMVideoFormatDescriptionRef formatDescriptionOut = 0;
  v47[0] = (CMSampleBufferRef)0xAAAAAAAAAAAAAAAALL;
  v45.decodeTimeStamp.epoch = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v45.presentationTimeStamp.timescale = v14;
  *(_OWORD *)&v45.decodeTimeStamp.value = v14;
  *(_OWORD *)&v45.duration.value = v14;
  *(_OWORD *)&v45.duration.epoch = v14;
  if (*(_DWORD *)(a6 + 60))
  {
    CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  }
  else
  {
    uint64_t TempFile = VideoReceiverUtil_CreateTempFile((uint64_t *)(a6 + 32), a6 + 40, (_DWORD *)(a6 + 64), "/var/mobile/Capture_2vuy.mov");
    if (TempFile) {
      goto LABEL_42;
    }
    CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t TempFile = FigMovieFormatWriterCreateWithByteStream();
    if (TempFile) {
      goto LABEL_42;
    }
    uint64_t v25 = *(void *)(a6 + 48);
    uint64_t v26 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v26) {
      uint64_t v27 = v26;
    }
    else {
      uint64_t v27 = 0;
    }
    uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(v27 + 8);
    if (!v32) {
      goto LABEL_28;
    }
    uint64_t TempFile = v32(v25, 1986618469, 0, a6 + 56);
    if (TempFile)
    {
LABEL_42:
      uint64_t v37 = TempFile;
      goto LABEL_29;
    }
  }
  CMBlockBufferRef dataBuffer = 0;
  uint64_t TempFile = CMBlockBufferCreateWithMemoryBlock(v15, memoryBlock, a2, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0], 0, 0, a2, 1u, &dataBuffer);
  if (TempFile) {
    goto LABEL_42;
  }
  CMTimeMake(&v45.duration, a7, a5);
  CMTimeMake(&v43, *(int *)(a6 + 60), a5);
  v45.presentationTimeStamp = v43;
  v45.decodeTimeStamp = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
  size_t sampleSizeArray = a2;
  uint64_t TempFile = CMVideoFormatDescriptionCreate(v15, 0x34323076u, a3, a4, 0, &formatDescriptionOut);
  if (TempFile) {
    goto LABEL_42;
  }
  uint64_t TempFile = CMSampleBufferCreate(v15, dataBuffer, 1u, 0, 0, formatDescriptionOut, 1, 1, &v45, 1, &sampleSizeArray, v47);
  if (TempFile) {
    goto LABEL_42;
  }
  CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(v47[0], 1u);
  if (SampleAttachmentsArray)
  {
    ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
    uint64_t v19 = (const void *)*MEMORY[0x1E4F1CFD0];
    CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F1F200], (const void *)*MEMORY[0x1E4F1CFD0]);
    CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F1F1A8], v19);
    CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F1F1C0], v19);
  }
  uint64_t v20 = *(void *)(a6 + 48);
  uint64_t v21 = *(unsigned int *)(a6 + 56);
  CMSampleBufferRef v22 = v47[0];
  uint64_t v23 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v23) {
    uint64_t v24 = v23;
  }
  else {
    uint64_t v24 = 0;
  }
  uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t, CMSampleBufferRef))(v24 + 32);
  if (!v28) {
    goto LABEL_28;
  }
  uint64_t TempFile = v28(v20, v21, v22);
  if (TempFile) {
    goto LABEL_42;
  }
  uint64_t v29 = *(void *)(a6 + 48);
  uint64_t v30 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v30) {
    uint64_t v31 = v30;
  }
  else {
    uint64_t v31 = 0;
  }
  uint64_t v33 = *(uint64_t (**)(uint64_t, void))(v31 + 40);
  if (v33)
  {
    uint64_t TempFile = v33(v29, 0);
    if (!TempFile)
    {
      uint64_t v34 = *(void *)(a6 + 48);
      uint64_t v35 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v35) {
        uint64_t v36 = v35;
      }
      else {
        uint64_t v36 = 0;
      }
      uint64_t v40 = *(uint64_t (**)(uint64_t, void))(v36 + 48);
      if (v40) {
        uint64_t v37 = v40(v34, 0);
      }
      else {
        uint64_t v37 = 4294954514;
      }
      *(_DWORD *)(a6 + 60) += a7;
      return v37;
    }
    goto LABEL_42;
  }
LABEL_28:
  uint64_t v37 = 4294954514;
LABEL_29:
  if (*(void *)(a6 + 48))
  {
    FigFormatWriterInvalidate();
    CFRelease(*(CFTypeRef *)(a6 + 48));
  }
  uint64_t v38 = *(const void **)(a6 + 40);
  if (v38) {
    CFRelease(v38);
  }
  if (*(void *)(a6 + 32))
  {
    FigFileForkClose();
    int v39 = *(_DWORD *)(a6 + 64);
    if (v39) {
      close(v39);
    }
  }
  return v37;
}

const tm *_VideoReceiverUtil_GenerateTimeString(char *a1, size_t a2)
{
  uint64_t result = 0;
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    time_t v5 = 0xAAAAAAAAAAAAAAAALL;
    setlocale(0, "");
    time(&v5);
    uint64_t result = localtime(&v5);
    if (result) {
      uint64_t result = (const tm *)strftime(a1, a2, "%m%d%g_%H%M%S", result);
    }
    *((unsigned char *)&result->tm_sec + (void)a1) = 0;
  }
  return result;
}

uint64_t _VideoReceiverUtil_Generate2vuyName(char *a1, size_t a2)
{
  v5[3] = *MEMORY[0x1E4F143B8];
  memset(v5, 170, 20);
  _VideoReceiverUtil_GenerateTimeString((char *)v5, 0x14uLL);
  return snprintf(a1, a2, "%s%s-rxSourceYuv.%dx%d.%s.yuv", "/tmp/", (const char *)v5, 1, 2, "2vuy");
}

size_t _VideoReceiverUtil_GenerateBitStreamDumpName(char *a1, size_t a2, const char *a3, const char *a4)
{
  v9[3] = *MEMORY[0x1E4F143B8];
  memset(v9, 170, 20);
  _VideoReceiverUtil_GenerateTimeString((char *)v9, 0x14uLL);
  strlcpy(a1, "/tmp/vcp/", a2);
  strlcat(a1, a3, a2);
  strlcat(a1, (const char *)v9, a2);
  strlcat(a1, a4, a2);
  return strlcat(a1, "-recvBitstream.26l", a2);
}

uint64_t _VideoReceiverUtil_LogRtpMediaPacket(uint64_t result, FILE *a2, int a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v4 = result;
    uint64_t result = fprintf(a2, "RTPMediaPacket header,seqNum,marker,payload,ts,arrival time,data length,total bytes,ext data length,stream index, %d, 0x%x, %d, %u, %f, %ld, %ld, %ld, %d\n", *(unsigned __int16 *)(result + 12), *(_DWORD *)result, *(_DWORD *)(result + 4), *(_DWORD *)(result + 16), *(double *)(result + 32), *(void *)(result + 152), *(void *)(result + 112), *(void *)(result + 128), a3);
    *(void *)&v26[15] = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)uint64_t v26 = v5;
    v25[10] = v5;
    v25[9] = v5;
    v25[8] = v5;
    v25[7] = v5;
    v25[6] = v5;
    v25[5] = v5;
    _OWORD v25[4] = v5;
    v25[3] = v5;
    v25[2] = v5;
    v25[1] = v5;
    v25[0] = v5;
    char v24 = 0;
    if (*(void *)(v4 + 152))
    {
      unint64_t v6 = 0;
      int v7 = 0;
      int v8 = 0;
      do
      {
        memset(v12, 170, 7);
        __sprintf_chk(v12, 0, 7uLL, "0x%02X, ", *(unsigned __int8 *)(*(void *)(v4 + 160) + v6));
        uint64_t result = __strlcat_chk();
        if ((~(_BYTE)v6 & 0x1F) != 0)
        {
          v7 += 6;
        }
        else
        {
          *((unsigned char *)v25 + v7 + 3) = 0;
          uint64_t result = fprintf(a2, "RTPMediaPacket data,sN=%d,\"DumpRow# %d -> [ %s ]\"\n", *(unsigned __int16 *)(v4 + 12), v8, &v24);
          int v7 = 0;
          char v24 = 0;
          ++v8;
        }
        ++v6;
      }
      while (v6 < *(void *)(v4 + 152));
      *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
      if ((v6 & 0x1F) >= 3)
      {
        v23[v7 + 21] = 0;
        uint64_t result = fprintf(a2, "RTPMediaPacket data,sN=%d,\"DumpRow# %d -> [ %s ]\"\n", *(unsigned __int16 *)(v4 + 12), v8, &v24);
        *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
      }
    }
    *(void *)&v23[15] = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)uint64_t v23 = v5;
    long long v22 = v5;
    long long v21 = v5;
    long long v20 = v5;
    long long v19 = v5;
    long long v18 = v5;
    long long v17 = v5;
    long long v16 = v5;
    long long v15 = v5;
    long long v14 = v5;
    long long v13 = v5;
    *(_OWORD *)&v12[1] = v5;
    v12[0] = 0;
    if (*(void *)(v4 + 128))
    {
      unint64_t v9 = 0;
      uint64_t v10 = -2;
      do
      {
        memset(v11, 170, 7);
        __sprintf_chk(v11, 0, 7uLL, "0x%02x, ", *(unsigned __int8 *)(*(void *)(v4 + 136) + v9));
        __strlcat_chk();
        ++v9;
        v10 += 6;
      }
      while (v9 < *(void *)(v4 + 128));
      v12[v10] = 0;
      return fprintf(a2, "RTPMediaPacket extData,sN=%d,\"{ %s }\", \n", *(unsigned __int16 *)(v4 + 12), v12);
    }
  }
  return result;
}

uint64_t VCPacketFilterGetClassID()
{
  if (VCPacketFilterGetClassID_onceToken != -1) {
    dispatch_once(&VCPacketFilterGetClassID_onceToken, &__block_literal_global_45);
  }
  return VCPacketFilterGetClassID_classID;
}

CFStringRef _VCPacketFilterCopyFormattingDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[VCPacketFilter %p]", a1);
}

uint64_t __VCPacketFilterGetClassID_block_invoke()
{
  uint64_t ClassID = CMBaseGetClassID();

  return MEMORY[0x1F40DC658](&VCPacketFilterGetClassID_descriptor, ClassID, 1, &VCPacketFilterGetClassID_classID);
}

void sub_1E213A558(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    JUMPOUT(0x1E213A478);
  }
  _Unwind_Resume(exception_object);
}

void sub_1E213A710(void *a1)
{
}

void sub_1E213A720(_Unwind_Exception *a1)
{
}

void OUTLINED_FUNCTION_9_5(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0x28u);
}

void OUTLINED_FUNCTION_10_8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0x22u);
}

double OUTLINED_FUNCTION_17(float a1)
{
  return a1;
}

_DWORD *_VCFECPacketListEntry_Allocate(OSQueueHead *a1, const void *a2, int a3)
{
  long long v5 = VCMemoryPool_Alloc(a1);
  unint64_t v6 = v5;
  if (v5)
  {
    v5[2] = a3;
    *((void *)v5 + 4) = 0;
    *((void *)v5 + 5) = 0;
    *((void *)v5 + 2) = a2;
    *((void *)v5 + 3) = 0;
    CFRetain(a2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCFECPacketListEntry_Allocate_cold_1();
    }
  }
  return v6;
}

uint64_t VCFECPacketList_AllocateAndPush(OSQueueHead *a1, const void *a2, int a3, uint64_t a4, long long *a5)
{
  int v8 = _VCFECPacketListEntry_Allocate(a1, a2, a3);
  uint64_t v9 = v8;
  if (!v8)
  {
    uint64_t v11 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCFECPacketList_AllocateAndPush_cold_1();
      }
    }
    goto LABEL_12;
  }
  long long v10 = *a5;
  *((void *)v8 + 5) = *((void *)a5 + 2);
  *(_OWORD *)(v8 + 6) = v10;
  if ((VCSingleLinkedListPush(a4, v8) & 1) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    {
      uint64_t v11 = 2150826039;
    }
    else
    {
      VRTraceErrorLogLevelToCSTR();
      uint64_t v11 = 2150826039;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCFECPacketList_AllocateAndPush_cold_2();
      }
    }
LABEL_12:
    VCMemoryPool_Free(a1, v9);
    return v11;
  }
  return 0;
}

uint64_t *VCFECPacketList_Flush(OSQueueHead *a1, uint64_t *a2)
{
  uint64_t result = VCSingleLinkedListPop(a2);
  if (result)
  {
    long long v5 = (CFTypeRef *)result;
    do
    {
      CFRelease(v5[2]);
      VCMemoryPool_Free(a1, v5);
      uint64_t result = VCSingleLinkedListPop(a2);
      long long v5 = (CFTypeRef *)result;
    }
    while (result);
  }
  return result;
}

uint64_t VCFECPacketList_CompareEntries(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a2 + 8);
  BOOL v4 = v2 == v3;
  unsigned int v5 = 2 * (v2 >= v3);
  if (v4) {
    return 1;
  }
  else {
    return v5;
  }
}

const void *symptomReporterCallback(void *a1, CFDictionaryRef theDict)
{
  CFDataRef Value = CFDictionaryGetValue(theDict, @"SymptomReporterCallbackKeySymptomID");
  uint64_t result = CFDictionaryGetValue(theDict, @"SymptomReporterCallbackKeyGroupID");
  if (Value) {
    BOOL v6 = result == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    return (const void *)[a1 sendSymptomToRemote:Value groupID:result];
  }
  return result;
}

uint64_t VCCMDuplicationCallback_0(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return [a1 setDuplicationFlag:a2 withPreferredLocalLinkTypeForDuplication:a3 notifyPeer:a4];
}

void sub_1E213FC54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose((const void *)(v26 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1E213FC98()
{
}

void sub_1E213FCA0()
{
}

uint64_t WRMReportMetricsCallback(void *a1, const char *a2)
{
  return [a1 reportWRMMetrics:a2];
}

uint64_t VCCMWRMStatusUpdateCallback_0(void *a1, const char *a2)
{
  return [a1 sendWRMStatusUpdate:a2];
}

void sub_1E214CF18(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t MediaCallback(int a1, void *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 2148597761;
  }
  int v8 = [a2 callID];
  uint64_t v9 = 0;
  switch(a1)
  {
    case 0:
      uint64_t v10 = *a3;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v11 = VRTraceErrorLogLevelToCSTR();
        unint64_t v12 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v21 = 136316162;
          uint64_t v22 = v11;
          __int16 v23 = 2080;
          char v24 = "MediaCallback";
          __int16 v25 = 1024;
          int v26 = 4712;
          __int16 v27 = 1024;
          int v28 = v8;
          __int16 v29 = 1024;
          int v30 = v10;
          _os_log_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_DEFAULT, "VCCallSession [%s] %s:%d MediaCallback: call (%08X) is not using relay for connection %d", (uint8_t *)&v21, 0x28u);
        }
      }
      [a2 handleMediaReceivedOverPeerToPeerLinkWithConnectionId:v10];
      goto LABEL_18;
    case 1:
      if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
        goto LABEL_18;
      }
      uint64_t v13 = VRTraceErrorLogLevelToCSTR();
      long long v14 = *MEMORY[0x1E4F47A50];
      uint64_t v9 = 0;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v21 = 136315906;
        uint64_t v22 = v13;
        __int16 v23 = 2080;
        char v24 = "MediaCallback";
        __int16 v25 = 1024;
        int v26 = 4718;
        __int16 v27 = 1024;
        int v28 = v8;
        _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, "VCCallSession [%s] %s:%d MediaCallback: call (%08X) is upgraded from relay to P2P, relay will be torn down in handlePrimaryConnChange.", (uint8_t *)&v21, 0x22u);
LABEL_18:
        uint64_t v9 = 0;
      }
      break;
    case 2:
      uint64_t v15 = *a3;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v16 = VRTraceErrorLogLevelToCSTR();
        long long v17 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v21 = 136316162;
          uint64_t v22 = v16;
          __int16 v23 = 2080;
          char v24 = "MediaCallback";
          __int16 v25 = 1024;
          int v26 = 4723;
          __int16 v27 = 1024;
          int v28 = v8;
          __int16 v29 = 1024;
          int v30 = v15;
          _os_log_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEFAULT, "VCCallSession [%s] %s:%d MediaCallback: call (%08X) started with relay for connection %d", (uint8_t *)&v21, 0x28u);
        }
      }
      [a2 handleMediaReceivedOverRelayLinkWithConnectionId:v15];
      goto LABEL_18;
    case 3:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v18 = VRTraceErrorLogLevelToCSTR();
        long long v19 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v21 = 136315906;
          uint64_t v22 = v18;
          __int16 v23 = 2080;
          char v24 = "MediaCallback";
          __int16 v25 = 1024;
          int v26 = 4730;
          __int16 v27 = 1024;
          int v28 = v8;
          _os_log_impl(&dword_1E1EA4000, v19, OS_LOG_TYPE_DEFAULT, "VCCallSession [%s] %s:%d MediaCallback: flush baseband queue for call (%08X).", (uint8_t *)&v21, 0x22u);
        }
      }
      return [a2 flushBasebandQueueWithPayloads:a3 flushCount:a4];
    case 4:
      uint64_t v9 = 2148597776;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          MediaCallback_cold_2();
          return 2148597776;
        }
      }
      return v9;
    case 5:
      return v9;
    default:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          MediaCallback_cold_1();
        }
      }
      return 2148597761;
  }
  return v9;
}

void sub_1E2153730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t VCCallSessionFillMediaControlInfoCallback(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t result = VCMediaControlInfoGeneratorGetType();
  if (!result)
  {
    return [a2 fillMediaControlInfo:a3];
  }
  return result;
}

uint64_t VCCallSessionProcessMediaControlInfoCallback(uint64_t a1, void *a2, uint64_t a3)
{
  BOOL v5 = VCMediaControlInfoGeneratorGetType() == 0;

  return [a2 processMediaControlInfo:a3 isAudio:v5];
}

void sub_1E2160A14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
}

_DWORD *getMaxImageDimensions(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6)
{
  unint64_t v12 = malloc_type_calloc(1uLL, 0x24uLL, 0x10000408AA14F5FuLL);
  uint64_t v13 = v12;
  if (v12)
  {
    *(_OWORD *)unint64_t v12 = xmmword_1E259FF50;
    *((void *)v12 + 2) = 0xF000000000;
    *((void *)v12 + 3) = 0x3F0000000000000FLL;
    v12[8] = a2;
    long long v14 = +[VCVideoRuleCollectionsCamera sharedInstance];
    if (a1 == 1) {
      unsigned __int8 v15 = 1;
    }
    else {
      unsigned __int8 v15 = 2;
    }
    id v16 = objc_alloc(MEMORY[0x1E4F1CA48]);
    if (a2 == 2) {
      uint64_t v17 = -[VCVideoRuleCollections supportedVideoRulesForBitrate:transportType:payload:encodingType:](v14, "supportedVideoRulesForBitrate:transportType:payload:encodingType:", [a5 limitingRule], 1, a4, v15);
    }
    else {
      uint64_t v17 = [(VCVideoRuleCollections *)v14 getVideoRulesForTransport:2 payload:a4 encodingType:v15];
    }
    uint64_t v18 = (void *)[v16 initWithArray:v17];
    long long v19 = v18;
    if (a1 != 1) {
      remove16x9Resolutions(v18);
    }
    if ([+[VCDefaults sharedInstance] forceHWI])
    {
      long long v20 = +[VCDefaults sharedInstance];
      unsigned int v21 = a1 == 1
          ? [(VCDefaults *)v20 forceVideoPayload]
          : [(VCDefaults *)v20 forceRecvVideoPayload];
      if (v21 != 128 && v21 != a4) {
        [v19 removeAllObjects];
      }
    }
    LOBYTE(v23) = 0;
    [a3 getNegotiatedResolutionForPayload:a4 forInterface:a2 withRule:v19 direction:a1 result:v13 remoteSupportsHD:a6 screenSharing:v23];

    if (!v13[5] && !v13[2])
    {
      free(v13);
      return 0;
    }
  }
  return v13;
}

void remove16x9Resolutions(void *a1)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  id v2 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  long long v36 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  uint64_t v3 = [a1 countByEnumeratingWithState:&v36 objects:v35 count:16];
  if (v3)
  {
    uint64_t v5 = v3;
    uint64_t v6 = *(void *)v37;
    int v7 = "VCCallSession";
    *(void *)&long long v4 = 136316418;
    long long v21 = v4;
    uint64_t v22 = a1;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v37 != v6) {
          objc_enumerationMutation(a1);
        }
        uint64_t v9 = *(void **)(*((void *)&v36 + 1) + 8 * i);
        int v10 = (int)(9 * objc_msgSend(v9, "iWidth", v21)) / 16;
        int v12 = v10 + 15;
        BOOL v11 = v10 < -15;
        int v13 = v10 + 30;
        if (!v11) {
          int v13 = v12;
        }
        if ([v9 iHeight] == (v13 & 0xFFFFFFF0))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            uint64_t v14 = VRTraceErrorLogLevelToCSTR();
            unsigned __int8 v15 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              id v16 = v2;
              uint64_t v17 = v7;
              int v18 = [v9 iWidth];
              int v19 = [v9 iHeight];
              [v9 fRate];
              *(_DWORD *)buf = v21;
              uint64_t v24 = v14;
              __int16 v25 = 2080;
              int v26 = "remove16x9Resolutions";
              __int16 v27 = 1024;
              int v28 = 5784;
              __int16 v29 = 1024;
              int v30 = v18;
              int v7 = v17;
              id v2 = v16;
              a1 = v22;
              __int16 v31 = 1024;
              int v32 = v19;
              __int16 v33 = 2048;
              double v34 = v20;
              _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, "VCCallSession [%s] %s:%d Removing resolution %dx%d %f for SDP", buf, 0x32u);
            }
          }
          [v2 addObject:v9];
        }
      }
      uint64_t v5 = [a1 countByEnumeratingWithState:&v36 objects:v35 count:16];
    }
    while (v5);
  }
  [a1 removeObjectsInArray:v2];
}

_DWORD *addWifiInterfaceForImageDimensions(_DWORD *result, int a2, char a3, void *a4)
{
  if (a2 >= 1)
  {
    uint64_t v24 = v11;
    uint64_t v25 = v10;
    uint64_t v26 = v9;
    uint64_t v27 = v8;
    uint64_t v28 = v7;
    uint64_t v29 = v6;
    uint64_t v30 = v5;
    uint64_t v31 = v4;
    uint64_t v32 = v12;
    uint64_t v33 = v13;
    uint64_t v16 = 0;
    uint64_t v17 = result + 5;
    uint64_t v18 = a2;
    while (1)
    {
      uint64_t result = (_DWORD *)objc_msgSend(a4, "objectAtIndexedSubscript:", v16, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33);
      int v19 = result;
      if ((a3 & 1) == 0) {
        break;
      }
      if (result) {
        goto LABEL_5;
      }
LABEL_6:
      ++v16;
      v17 += 9;
      if (v18 == v16) {
        return result;
      }
    }
    int v22 = [result iWidth];
    uint64_t result = (_DWORD *)[v19 iHeight];
    if ((int)result * v22 > 307200 || v19 == 0) {
      goto LABEL_6;
    }
LABEL_5:
    *(v17 - 5) = [v19 iWidth];
    *(v17 - 3) = [v19 iWidth];
    *(v17 - 2) = [v19 iHeight];
    _DWORD *v17 = [v19 iHeight];
    [v19 fRate];
    v17[1] = (int)v20;
    uint64_t result = (_DWORD *)[v19 fPref];
    v17[2] = v21;
    v17[3] = 2;
    goto LABEL_6;
  }
  return result;
}

void **addCellInterfaceForImageDimensions(void **result, int *a2, int a3, void *a4)
{
  uint64_t v6 = result;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  LODWORD(v7) = *a2;
  if (*a2 >= 1)
  {
    uint64_t v8 = 0;
    if (a3 == 100) {
      int v9 = 1;
    }
    else {
      int v9 = 2;
    }
    uint64_t v10 = (int *)((char *)*result + 32);
    do
    {
      *uint64_t v10 = v9;
      v10 += 9;
      ++v8;
      uint64_t v7 = *a2;
    }
    while (v8 < v7);
  }
  if (a3 == 123)
  {
    *uint64_t result = malloc_type_realloc(*result, 36 * ([a4 count] + (int)v7), 0x10000408AA14F5FuLL);
    long long v23 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    uint64_t result = (void **)[a4 countByEnumeratingWithState:&v23 objects:v22 count:16];
    if (result)
    {
      uint64_t v11 = result;
      uint64_t v12 = *(void *)v24;
      do
      {
        uint64_t v13 = 0;
        do
        {
          if (*(void *)v24 != v12) {
            objc_enumerationMutation(a4);
          }
          uint64_t v14 = *(void **)(*((void *)&v23 + 1) + 8 * (void)v13);
          *((_DWORD *)*v6 + 9 * *a2 + 2) = [v14 iWidth];
          int v15 = [v14 iWidth];
          uint64_t v16 = *v6;
          v16[9 * *a2] = v15;
          v16[9 * *a2 + 1] = 0;
          *((_DWORD *)*v6 + 9 * *a2 + 5) = [v14 iHeight];
          int v17 = [v14 iHeight];
          uint64_t v18 = *v6;
          *((_DWORD *)*v6 + 9 * *a2 + 3) = v17;
          v18[9 * *a2 + 4] = 0;
          [v14 fRate];
          *((_DWORD *)*v6 + 9 * *a2 + 6) = (int)v19;
          [v14 fPref];
          uint64_t v20 = (uint64_t)*v6 + 36 * *a2;
          *(_DWORD *)(v20 + 28) = v21;
          *(_DWORD *)(v20 + 32) = 1;
          ++*a2;
          uint64_t v13 = (void **)((char *)v13 + 1);
        }
        while (v11 != v13);
        uint64_t result = (void **)[a4 countByEnumeratingWithState:&v23 objects:v22 count:16];
        uint64_t v11 = result;
      }
      while (result);
    }
  }
  return result;
}

void OUTLINED_FUNCTION_12_4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0x1Cu);
}

uint64_t OUTLINED_FUNCTION_13_6@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)(v2 - 24) = a2;
  return *(void *)a1;
}

void OUTLINED_FUNCTION_16_1(float a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(float *)a3 = a1;
  *(void *)(a3 + 4) = a4;
  *(_WORD *)(a3 + 12) = 2080;
}

uint64_t OUTLINED_FUNCTION_18(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(a2 + 24) = v3;
  *(_WORD *)(a2 + 28) = v2;
  *(void *)(a2 + 30) = result;
  return result;
}

void OUTLINED_FUNCTION_20(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 14) = v2;
  *(_WORD *)(a2 + 22) = 1024;
}

void OUTLINED_FUNCTION_21(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x26u);
}

uint64_t RTPSendUncompressedVideoPacket(uint64_t a1, char a2, int a3, int a4, void *a5, signed int a6, _DWORD *a7, const void *a8, double a9, unsigned __int8 a10, int a11, int a12, unsigned __int8 a13, _DWORD *a14, int a15, uint64_t a16, int a17, uint64_t a18, uint64_t a19, long long *a20,char a21,int a22)
{
  uint64_t v22 = a18;
  if (a7)
  {
    *a7 = 0;
    uint64_t v32 = CheckInHandleDebug();
    if (v32 == 0xFFFFFFFFLL)
    {
      VCMediaControlInfoDispose(a18);
      return 2147549190;
    }
    else if (v32)
    {
      unint64_t v33 = 2147549198;
      if (a6 < 1)
      {
        unint64_t v33 = 2147549199;
      }
      else
      {
        *(_WORD *)(v32 + 16) = *(_WORD *)(v32 + 16) & 0x80FF | ((a2 & 0x7F) << 8);
        unsigned int v34 = (a2 & 0x7F) - 110;
        if (v34 <= 0xF && ((1 << v34) & 0xC001) != 0)
        {
          if (a6 < 0x5B5)
          {
            unint64_t v33 = SendRTP(a1, v32, a3, a4, 0, 0, a5, a6, a9, a7, a8, a10, a11, a12, a13, a14, a15, a16, a17,
                    a18,
                    a19,
                    a20,
                    a21,
                    a22);
            uint64_t v22 = 0;
          }
          else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            uint64_t v35 = VRTraceErrorLogLevelToCSTR();
            long long v36 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              RTPSendUncompressedVideoPacket_cold_1(v35, a6 + 12, v36);
            }
          }
        }
        else
        {
          unint64_t v33 = 2147549199;
        }
      }
      VCMediaControlInfoDispose(v22);
      CheckOutHandleDebug();
    }
    else
    {
      VCMediaControlInfoDispose(a18);
      return 2147549186;
    }
  }
  else
  {
    VCMediaControlInfoDispose(a18);
    return 2147549185;
  }
  return v33;
}

void sub_1E2169C84(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1E216A5D4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1E216DEE8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

double VCRateControlAlgorithmBasePriv_StateEnter(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 1072) == 3)
  {
    double result = *(double *)(a1 + 1128);
    *(double *)(a1 + 1136) = result;
  }
  return result;
}

void VCRateControlAlgorithmBasePriv_StateExit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 1072) == 1)
  {
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Initial Rampup done!", a3, a4, a5, a6, a7, a8, v9);
    if (!*(unsigned char *)(a1 + 1154)) {
      *(unsigned char *)(a1 + 1154) = 1;
    }
  }
}

double VCRateControlAlgorithmBasePriv_CheckPaused(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 1072) != 1)
  {
    BOOL IsPaused = VCRateControlAlgorithm_IsPaused(a1);
    int v4 = *(_DWORD *)(a1 + 1072);
    if (v4) {
      BOOL v5 = !IsPaused;
    }
    else {
      BOOL v5 = 1;
    }
    if (v5)
    {
      if (!v4)
      {
        if (!IsPaused || (double result = *(double *)(a1 + 1128) - *(double *)(a1 + 1064), result > *(double *)(a1 + 688)))
        {
          (*(void (**)(uint64_t))(a1 + 32))(a1);
          *(_DWORD *)(a1 + 1072) = 3;
          (*(void (**)(uint64_t))(a1 + 24))(a1);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            uint64_t v12 = VRTraceErrorLogLevelToCSTR();
            uint64_t v13 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              int v23 = 136315650;
              uint64_t v24 = v12;
              __int16 v25 = 2080;
              long long v26 = "VCRateControlAlgorithmBasePriv_CheckPaused";
              __int16 v27 = 1024;
              int v28 = 110;
              _os_log_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Resume VCRateControl algorithm", (uint8_t *)&v23, 0x1Cu);
            }
          }
          VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Resume rate control algorithm", v6, v7, v8, v9, v10, v11, v23);
          VCRateControlAlgorithm_SetPaused(a1, 0);
        }
      }
    }
    else
    {
      (*(void (**)(uint64_t))(a1 + 32))(a1);
      *(_DWORD *)(a1 + 1072) = 0;
      (*(void (**)(uint64_t))(a1 + 24))(a1);
      int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (ErrorLogLevelForModule >= 7)
      {
        uint64_t v21 = VRTraceErrorLogLevelToCSTR();
        uint64_t v22 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v23 = 136315650;
          uint64_t v24 = v21;
          __int16 v25 = 2080;
          long long v26 = "VCRateControlAlgorithmBasePriv_CheckPaused";
          __int16 v27 = 1024;
          int v28 = 104;
          _os_log_impl(&dword_1E1EA4000, v22, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Pause VCRateControl algorithm", (uint8_t *)&v23, 0x1Cu);
        }
      }
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Pause rate control algorithm", v15, v16, v17, v18, v19, v20, v23);
      double result = *(double *)(a1 + 1128);
      *(double *)(a1 + 1064) = result;
    }
  }
  return result;
}

BOOL VCRateControlAlgorithm_IsPaused(uint64_t a1)
{
  if (a1)
  {
    unsigned __int8 v1 = atomic_load((unsigned __int8 *)(a1 + 1056));
    return v1 & 1;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    VCRateControlAlgorithm_IsPaused_cold_1();
  }
  return 0;
}

uint64_t VCRateControlAlgorithmBasePriv_StateChange(uint64_t result, int a2)
{
  if (*(_DWORD *)(result + 1072) != a2)
  {
    uint64_t v3 = result;
    (*(void (**)(void))(result + 32))();
    *(_DWORD *)(v3 + 1072) = a2;
    int v4 = *(uint64_t (**)(uint64_t))(v3 + 24);
    return v4(v3);
  }
  return result;
}

void VCRateControlAlgorithmBasePriv_LogToDumpFiles(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  v19[1] = *(char **)MEMORY[0x1E4F143B8];
  if (a2)
  {
    v19[0] = 0;
    vasprintf(v19, a2, &a9);
    uint64_t v16 = v19[0];
    if (v19[0])
    {
      uint64_t v17 = *(void *)(a1 + 5144);
      if (v17)
      {
        VRLogfilePrint(v17, "%s\n", v10, v11, v12, v13, v14, v15, (char)v19[0]);
        uint64_t v16 = v19[0];
      }
      uint64_t v18 = *(void *)(a1 + 5152);
      if (v18)
      {
        VRLogfilePrint(v18, "%s\n", v10, v11, v12, v13, v14, v15, (char)v16);
        uint64_t v16 = v19[0];
      }
      free(v16);
    }
  }
}

void VCRateControlAlgorithm_SetPaused(uint64_t a1, unsigned __int8 a2)
{
  if (a1)
  {
    atomic_store(a2, (unsigned __int8 *)(a1 + 1056));
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlAlgorithm_SetPaused_cold_1();
    }
  }
}

void VCRateControlAlgorithm_EnableLogDump(uint64_t a1, uint64_t a2, char a3)
{
  if (a1)
  {
    if (a2) {
      *(void *)(a1 + 5144) = a2;
    }
    *(unsigned char *)(a1 + 5160) = a3;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlAlgorithm_EnableLogDump_cold_1();
    }
  }
}

void VCRateControlAlgorithm_EnableBasebandDump(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    *(void *)(a1 + 5152) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    BOOL v5 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
    {
      int v6 = 136316162;
      uint64_t v7 = v4;
      __int16 v8 = 2080;
      uint64_t v9 = "VCRateControlAlgorithm_EnableBasebandDump";
      __int16 v10 = 1024;
      int v11 = 129;
      __int16 v12 = 2048;
      uint64_t v13 = a1;
      __int16 v14 = 2048;
      uint64_t v15 = a2;
      _os_log_error_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d Invalid parameter. algorithm=%p logBasebandDump=%p", (uint8_t *)&v6, 0x30u);
    }
  }
}

double VCRateControlAlgorithmBasePriv_GetDoubleTimeFromTimestamp(unsigned int a1, unsigned int a2, unsigned int a3)
{
  return (double)a1 / (double)a2 + (double)a3 * 64.0;
}

uint64_t VCRateControlAlgorithmBasePriv_GetTimestampFromMicroTime(double a1)
{
  unint64_t v1 = MicroToNTP(a1);
  return (unsigned __int16)(NTPToMiddle32(v1) >> 6);
}

double VCRateControlAlgorithmBasePriv_CalculateCongestionMetrics(uint64_t a1, double a2, double a3)
{
  *(void *)(a1 + 2864) = *(void *)(a1 + 2912);
  BOOL v4 = VCRateControlUtil_CalculateCongestionMetrics(a1 + 1232, a1 + 40, *(_DWORD *)(a1 + 1072) == 1, a2, a3);
  *(unsigned char *)(a1 + 2880) = v4;
  if (v4)
  {
    *(void *)(a1 + 2896) = *(void *)(a1 + 2848);
    long long v5 = *(_OWORD *)(a1 + 2856);
    *(_OWORD *)(a1 + 2904) = v5;
    if (*(double *)(a1 + 2888) <= 0.0)
    {
      *(unsigned char *)(a1 + 2881) = 0;
LABEL_6:
      *(void *)&long long v5 = *(void *)(a1 + 1128);
      *(void *)(a1 + 2920) = v5;
      return *(double *)&v5;
    }
    *(unsigned char *)(a1 + 2881) = *(double *)&v5 == 0.0;
    if (*(double *)&v5 != 0.0) {
      goto LABEL_6;
    }
  }
  return *(double *)&v5;
}

uint64_t VCRateControlAlgorithmBasePriv_CheckBandwidthOvershoot(uint64_t result, unsigned int a2)
{
  if (a2)
  {
    int v2 = *(_DWORD *)(result + 1084);
    if (v2 >= 52) {
      int v3 = 52;
    }
    else {
      int v3 = *(_DWORD *)(result + 1084);
    }
    int v4 = v3 + 1;
    uint64_t v5 = *(void *)(result + 48);
    double v6 = *(double *)(result + 176);
    unsigned int v7 = ((double)*(unsigned int *)(result + 1104)
                      + (double)(*(_DWORD *)(v5 + 4 * v4) - *(_DWORD *)(result + 1104)) * v6);
    *(unsigned char *)(result + 1225) = v7 > a2;
    if (v7 <= a2) {
      *(void *)(result + 1208) = *(void *)(result + 1128);
    }
    int v8 = *(_DWORD *)(result + 240) + v2;
    if (v8 >= 52) {
      int v8 = 52;
    }
    double v9 = (double)*(unsigned int *)(v5 + 4 * v8)
       + (double)(*(_DWORD *)(v5 + 4 * v8 + 4) - *(_DWORD *)(v5 + 4 * v8)) * v6;
    *(unsigned char *)(result + 1224) = v9 < a2;
    if (v9 >= a2)
    {
      *(void *)(result + 1216) = 0;
    }
    else if (*(double *)(result + 1216) == 0.0)
    {
      *(void *)(result + 1216) = *(void *)(result + 1128);
    }
  }
  else
  {
    *(void *)(result + 1208) = *(void *)(result + 1128);
    *(unsigned char *)(result + 1224) = 0;
  }
  return result;
}

BOOL VCRateControlAlgorithmBasePriv_KeepOvershootingRampDownBandwidth(uint64_t a1)
{
  return *(unsigned char *)(a1 + 410)
      && *(_DWORD *)(a1 + 1200)
      && *(double *)(a1 + 1128) - *(double *)(a1 + 1208) > *(double *)(a1 + 168);
}

BOOL VCRateControlAlgorithmBasePriv_RecentlyGoAboveRampUpBandwidth(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 1072) == 1 && !*(unsigned char *)(a1 + 1154)
    || !*(_DWORD *)(a1 + 1200)
    || !*(unsigned char *)(a1 + 410)
    || VCRateControlMediaController_IsVideoStopped(*(unsigned char **)(a1 + 1048)))
  {
    return 0;
  }
  if (*(unsigned char *)(a1 + 1224)) {
    return *(double *)(a1 + 1128) - *(double *)(a1 + 1216) < *(double *)(a1 + 224);
  }
  return 1;
}

uint64_t VCRateControlAlgorithmBasePriv_UpdateLossEvent(uint64_t result)
{
  if (*(double *)(result + 5104) > 0.0)
  {
    uint64_t v1 = *(unsigned int *)(result + 4976);
    uint64_t v2 = result + 2928 + 32 * v1;
    uint64_t v3 = *(void *)(result + 5024);
    *(void *)uint64_t v2 = *(void *)(result + 1128);
    *(void *)(v2 + 8) = v3;
    int v4 = *(unsigned __int8 *)(result + 5136);
    if (*(unsigned char *)(result + 5136)) {
      uint64_t v5 = *(void *)(result + 5088);
    }
    else {
      uint64_t v5 = 0;
    }
    *(void *)(v2 + 16) = v5;
    double v6 = *(double *)(result + 5024);
    double v7 = *(double *)(result + 5032);
    BOOL v8 = v7 > 0.0;
    if (v6 - v7 <= 0.001) {
      BOOL v8 = 0;
    }
    *(unsigned char *)(v2 + 24) = v8;
    *(_DWORD *)(v2 + 26) = *(_DWORD *)(result + 5012);
    double v9 = v6;
    if (v4)
    {
      double v9 = *(double *)(result + 5088);
      if (v6 >= v9) {
        double v9 = v6;
      }
    }
    double v10 = *(double *)(result + 5048);
    if (v10 != -1.0) {
      double v9 = v9 * 0.03 + v10 * 0.97;
    }
    *(double *)(result + 5048) = v9;
    *(_DWORD *)(result + 4976) = ((_BYTE)v1 + 1) & 0x3F;
    *(double *)(result + 5032) = v6;
  }
  return result;
}

void VCRateControlAlgorithmBasePriv_ResetLossEventBuffer(uint64_t a1)
{
  *(_DWORD *)(a1 + 4976) = 0;
}

void VCRateControlAlgorithmBasePriv_ResetOWRDList(uint64_t a1)
{
}

uint64_t VCRateControlAlgorithmBasePriv_AllowRampUpWithContinuousTargetBitrate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(double *)(a1 + 4992) != 0.0)
  {
    double v8 = *(double *)(a1 + 1096);
    if (*(_DWORD *)(a1 + 1104) != v8)
    {
      int v9 = *(_DWORD *)(a1 + 1084);
      if (v9 + 1 < *(_DWORD *)(a1 + 60)) {
        int v10 = v9 + 1;
      }
      else {
        int v10 = *(_DWORD *)(a1 + 60);
      }
      unsigned int v11 = *(_DWORD *)(*(void *)(a1 + 48) + 4 * v10);
      if (v8 <= (double)v11)
      {
        VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "LossEventRampUp is blocked due to continuousTargetBitrate=%u, currentTargetBitrate=%u, nextTargetBitrate=%u, bandwidthLimit=%u, confidence=%u", a3, a4, a5, a6, a7, a8, v8);
        return 0;
      }
      *(double *)(a1 + 1096) = (double)v11;
    }
  }
  return 1;
}

uint64_t VCRateControlAlgorithmBasePriv_ShouldBlockRampUpDueToLossEventThreshold(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(double *)(a1 + 256) == 0.0 || *(double *)(a1 + 4992) <= 0.0) {
    return 0;
  }
  double v8 = *(double *)(a1 + 5048);
  BOOL v9 = v8 > *(double *)(a1 + 768);
  int v10 = *(_DWORD *)(a1 + 248);
  if (*(_DWORD *)(a1 + 5000) >= v10)
  {
    if (v8 <= *(double *)(a1 + 784))
    {
      if (*(double *)(a1 + 5024) > *(double *)(a1 + 5040)) {
        return 1;
      }
    }
    else
    {
      *(double *)(a1 + 5072) = v8;
      double v11 = v8 * 3.0;
      if (v8 * 3.0 >= *(double *)(a1 + 776)) {
        double v11 = *(double *)(a1 + 776);
      }
      *(double *)(a1 + 5040) = v11;
      *(void *)(a1 + 4992) = 0;
      *(void *)(a1 + 5004) = 0;
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "LossEventRampDown no use and tried ramped down with badTrendCount=%d, nullify lossEventRampDown RTT=%f, avgPLR=%f, previous avgPLR=%f, PLRThreshold=%f", a3, a4, a5, a6, a7, a8, v10);
    }
  }
  return v9;
}

uint64_t VCRateControlAlgorithmBasePriv_ShouldRampDownDueToLossEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = *(_DWORD *)(a1 + 244);
  if (v9 < 1) {
    goto LABEL_8;
  }
  int v10 = 0;
  for (int i = -1; i != -65; --i)
  {
    if (v9 + i == -1) {
      break;
    }
    v10 += *(unsigned __int8 *)(a1 + 2928 + 32 * (((_BYTE)i + *(_DWORD *)(a1 + 4976)) & 0x3F) + 24);
  }
  if (v10 < v9 || *(double *)(a1 + 2896) <= *(double *)(a1 + 272)) {
LABEL_8:
  }
    BOOL v12 = 0;
  else {
    BOOL v12 = *(_DWORD *)(a1 + 1084) >= *(_DWORD *)(a1 + 112);
  }
  double v13 = *(double *)(a1 + 256);
  if (v13 == 0.0
    || (int v14 = *(_DWORD *)(a1 + 5000), v14 >= *(_DWORD *)(a1 + 248))
    || (int v15 = *(_DWORD *)(a1 + 1072), v15 == 5)
    || (double v16 = *(double *)(a1 + 4992), v16 == 0.0)
    && (v15 == 3 || *(double *)(a1 + 1128) - *(double *)(a1 + 1176) < *(double *)(a1 + 472)))
  {
    int v17 = 0;
  }
  else
  {
    int v19 = 0;
    int v20 = 0;
    uint64_t v21 = a1 + 2928;
    int v22 = *(_DWORD *)(a1 + 4976) - 1;
    double v23 = 0.0;
    double v24 = 0.0;
    while (1)
    {
      double v25 = *(double *)(v21 + 32 * (((_BYTE)v22 + (_BYTE)v19) & 0x3F));
      if (!v19) {
        double v24 = *(double *)(v21 + 32 * (v22 & 0x3F));
      }
      if (v25 == 0.0) {
        break;
      }
      if (v24 - v25 > *(double *)(a1 + 264))
      {
        int v30 = -v19;
        if (v30 < 2) {
          break;
        }
        goto LABEL_32;
      }
      uint64_t v26 = v21 + 32 * (((_BYTE)v22 + (_BYTE)v19) & 0x3F);
      double v27 = *(double *)(v26 + 8);
      double v28 = *(double *)(a1 + 5040);
      BOOL v29 = v27 >= 0.95 || v27 <= v28;
      if (!v29 || *(double *)(v26 + 16) > v28) {
        ++v20;
      }
      if (--v19 == -64)
      {
        int v30 = 64;
LABEL_32:
        double v23 = (double)v20 / (double)v30;
        break;
      }
    }
    if (v23 < v13 || *(double *)(a1 + 2896) <= *(double *)(a1 + 272))
    {
      int v17 = 0;
    }
    else
    {
      double v31 = *(double *)(a1 + 5048);
      if (v31 >= *(double *)(a1 + 5040))
      {
        if (v16 == 0.0)
        {
          VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "LossEventRampDown start ramping down with RTT=%f, avgPLR=%f, PLRThreshold=%f, ratio=%f", a3, a4, a5, a6, a7, a8, *(void *)(a1 + 5104));
        }
        else
        {
          BOOL v32 = v31 > *(double *)(a1 + 5056) && v31 > *(double *)(a1 + 784);
          *(_DWORD *)(a1 + 5000) = v14 + (v32 || *(double *)(a1 + 5064) < v31);
          VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "LossEventRampDown doesn't seem to stabilized yet with RTT=%f, avgPLR=%f, previousAvgPLR=%f, PLRThreshold=%f, badTrendCount=%d, PLR trend is going %s, %s improvement", a3, a4, a5, a6, a7, a8, *(void *)(a1 + 5104));
        }
      }
      else
      {
        VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "LossEventRampDown ramping down may be too aggressive with RTT=%f, avgPLR=%f, PLRThreshold=%f", a3, a4, a5, a6, a7, a8, *(void *)(a1 + 5104));
      }
      double v16 = *(double *)(a1 + 4992);
      uint64_t v33 = *(void *)(a1 + 5048);
      if (v16 == 0.0)
      {
        double v16 = *(double *)(a1 + 1128);
        *(double *)(a1 + 4992) = v16;
        *(void *)(a1 + 5064) = v33;
      }
      *(void *)(a1 + 5056) = v33;
      int v17 = 1;
    }
    if (v16 > 0.0)
    {
      double v34 = *(double *)(a1 + 768);
      double v35 = *(double *)(a1 + 5040);
      if (v35 >= *(double *)(a1 + 5048)) {
        double v35 = *(double *)(a1 + 5048);
      }
      if (v34 < v35) {
        double v34 = v35;
      }
      *(double *)(a1 + 5040) = v34;
    }
    if (v17)
    {
      uint64_t v36 = *(int *)(a1 + 112);
      int v37 = *(_DWORD *)(a1 + 1084);
      if (v37 >= (int)v36 && *(_DWORD *)(a1 + 1112) >= *(_DWORD *)(*(void *)(a1 + 48) + 4 * v36))
      {
        if (*(_DWORD *)(a1 + 1088) < v37)
        {
          unsigned int v38 = *(_DWORD *)(a1 + 1104);
          unsigned int v39 = *(_DWORD *)(a1 + 5004);
          if (v39)
          {
            if ((int)(v38 - v39) >= 0) {
              int v40 = v38 - v39;
            }
            else {
              int v40 = v39 - v38;
            }
            double v41 = (double)v39;
            if ((double)v39 * 0.35 <= (double)v40) {
              unsigned int v42 = 0;
            }
            else {
              unsigned int v42 = *(_DWORD *)(a1 + 5008) + 1;
            }
            if (v42 >= 0xA) {
              unsigned int v42 = 10;
            }
            *(_DWORD *)(a1 + 5008) = v42;
            unsigned int v43 = ((double)v38 * 0.5 + v41 * 0.5);
            *(_DWORD *)(a1 + 5004) = v43;
            VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "LossEventRampDown update bandwidth limit=%u, confidence=%u, diff=%d", a3, a4, a5, a6, a7, a8, v43);
          }
          else
          {
            *(_DWORD *)(a1 + 5004) = v38;
            ++*(_DWORD *)(a1 + 5008);
          }
        }
        int v17 = 1;
      }
      else
      {
        bzero((void *)(a1 + 2928), 0x800uLL);
        int v17 = 0;
        *(_DWORD *)(a1 + 4976) = 0;
      }
    }
  }
  return v12 | v17;
}

uint64_t VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampUp(uint64_t result)
{
  *(_DWORD *)(result + 1156) = 0;
  *(void *)(result + 1160) = 0;
  unsigned int v1 = *(_DWORD *)(result + 1104);
  unsigned int v2 = *(_DWORD *)(result + 5004);
  int v3 = v1 - v2;
  if ((int)(v1 - v2) < 0) {
    int v3 = v2 - v1;
  }
  if ((double)v2 * 0.35 > (double)v3 && (unsigned int v4 = *(_DWORD *)(result + 5008)) != 0)
  {
    double v5 = *(double *)(result + 1096);
    double v6 = (double)v3 * 0.16 / v5 / (double)v4;
    double v7 = v6 + 1.0;
    BOOL v8 = v6 < 0.01;
    double v9 = 1.01;
    if (!v8) {
      double v9 = v7;
    }
    double v10 = v5 * v9;
  }
  else
  {
    double v10 = (double)v1;
  }
  *(double *)(result + 1096) = v10;
  return result;
}

double VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampDown(uint64_t a1, double a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 1156) + 1;
  *(_DWORD *)(a1 + 1156) = v2;
  double v3 = *(double *)(a1 + 1160);
  if (v3 == 0.0)
  {
    *(double *)(a1 + 1160) = a2;
  }
  else if (a2 - v3 >= *(double *)(a1 + 184))
  {
    *(_DWORD *)(a1 + 1156) = 0;
    *(void *)(a1 + 1160) = 0;
  }
  else if (v2 >= *(_DWORD *)(a1 + 360))
  {
    *(unsigned char *)(a1 + 1144) = 1;
    *(double *)(a1 + 1168) = a2;
  }
  LODWORD(a2) = *(_DWORD *)(a1 + 1104);
  double result = (double)*(unint64_t *)&a2;
  *(double *)(a1 + 1096) = result;
  return result;
}

void VCRateControlAlgorithm_Configure(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    unsigned int v4 = *(void (**)(void))(a1 + 8);
    v4();
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v5 = VRTraceErrorLogLevelToCSTR();
    double v6 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
    {
      int v7 = 136316162;
      uint64_t v8 = v5;
      __int16 v9 = 2080;
      double v10 = "VCRateControlAlgorithm_Configure";
      __int16 v11 = 1024;
      int v12 = 546;
      __int16 v13 = 2048;
      uint64_t v14 = a1;
      __int16 v15 = 2048;
      uint64_t v16 = a2;
      _os_log_error_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d Invalid parameter. algorithm=%p configuration=%p", (uint8_t *)&v7, 0x30u);
    }
  }
}

uint64_t VCRateControlAlgorithm_DoRateControl(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    unsigned int v4 = *(uint64_t (**)(void))(a1 + 16);
    return v4();
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v6 = VRTraceErrorLogLevelToCSTR();
      int v7 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        int v8 = 136316162;
        uint64_t v9 = v6;
        __int16 v10 = 2080;
        __int16 v11 = "VCRateControlAlgorithm_DoRateControl";
        __int16 v12 = 1024;
        int v13 = 554;
        __int16 v14 = 2048;
        uint64_t v15 = a1;
        __int16 v16 = 2048;
        uint64_t v17 = a2;
        _os_log_error_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d Invalid parameter. algorithm=%p statistics=%p", (uint8_t *)&v8, 0x30u);
      }
    }
    return 0;
  }
}

uint64_t VCCaptionsSegmentBlobReadFrom(uint64_t a1, uint64_t a2)
{
  double v3 = (int *)MEMORY[0x1E4F940E8];
  unsigned int v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    int v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
      {
        String = (void *)PBReaderReadString();

        *(void *)(a1 + 16) = String;
      }
      else if (v17 == 2)
      {
        char v25 = 0;
        unsigned int v26 = 0;
        uint64_t v27 = 0;
        *(unsigned char *)(a1 + 28) |= 2u;
        while (1)
        {
          uint64_t v28 = *v3;
          unint64_t v29 = *(void *)(a2 + v28);
          if (v29 == -1 || v29 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v30 = *(unsigned char *)(*(void *)(a2 + *v7) + v29);
          *(void *)(a2 + v28) = v29 + 1;
          v27 |= (unint64_t)(v30 & 0x7F) << v25;
          if ((v30 & 0x80) == 0) {
            goto LABEL_43;
          }
          v25 += 7;
          BOOL v14 = v26++ >= 9;
          if (v14)
          {
            uint64_t v27 = 0;
            goto LABEL_45;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_43:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v27 = 0;
        }
LABEL_45:
        *(unsigned char *)(a1 + 24) = v27 != 0;
      }
      else if (v17 == 1)
      {
        char v18 = 0;
        unsigned int v19 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 28) |= 1u;
        while (1)
        {
          uint64_t v21 = *v3;
          unint64_t v22 = *(void *)(a2 + v21);
          if (v22 == -1 || v22 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v23 = *(unsigned char *)(*(void *)(a2 + *v7) + v22);
          *(void *)(a2 + v21) = v22 + 1;
          v20 |= (unint64_t)(v23 & 0x7F) << v18;
          if ((v23 & 0x80) == 0) {
            goto LABEL_39;
          }
          v18 += 7;
          BOOL v14 = v19++ >= 9;
          if (v14)
          {
            LODWORD(v20) = 0;
            goto LABEL_41;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_39:
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v20) = 0;
        }
LABEL_41:
        *(_DWORD *)(a1 + 8) = v20;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1E218182C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _VCMediaQueuePacketBundler_BundlePacketsWithNonePolicy(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 32)) >= 1)
  {
    do
    {
      unsigned int v4 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 32));
      __int16 IDSHeaderSizeWithChannelDataFormatArray = VCIDSChannelData_GetIDSHeaderSizeWithChannelDataFormatArray((uint64_t)(v4 + 16), 1u);
      if (v4[293]) {
        __int16 v6 = 48;
      }
      else {
        __int16 v6 = 28;
      }
      if (v4) {
        BOOL v7 = v4 >= v4 + 312;
      }
      else {
        BOOL v7 = 0;
      }
      if (v7) {
        __break(0x5519u);
      }
      if (a2)
      {
        int v8 = (*(uint64_t (**)(uint64_t, unsigned char *, void, void, void))(a2 + 16))(a2, v4, (unsigned __int16)(v6 + IDSHeaderSizeWithChannelDataFormatArray), *((unsigned __int16 *)v4 + 2), 0);
        if (v8)
        {
          int v9 = v8;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            uint64_t v12 = VRTraceErrorLogLevelToCSTR();
            unint64_t v10 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315906;
              uint64_t v14 = v12;
              __int16 v15 = 2080;
              __int16 v16 = "_VCMediaQueuePacketBundler_ReturnProcessedPackets";
              __int16 v17 = 1024;
              int v18 = 76;
              __int16 v19 = 1024;
              int v20 = v9;
              _os_log_error_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_ERROR, " [%s] %s:%d Output Block failed (%d)", buf, 0x22u);
            }
          }
        }
      }
    }
    while (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 32)) > 0);
  }
  return 0;
}

uint64_t _VCMediaQueuePacketBundler_BundlePacketsWithFCFSPolicy(uint64_t a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unsigned __int16 v3 = atomic_load((unsigned int *)(a1 + 20));
  if (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 32)) >= 1)
  {
    unint64_t v4 = 0;
    unint64_t v5 = 0;
    int v6 = 0;
    BOOL v7 = 0;
    BOOL v8 = 0;
    __int16 v9 = 0;
    int v10 = 0;
    int v27 = v3;
    while (1)
    {
      uint64_t v11 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 32));
      if (v4 && v4 >= v5) {
        __break(0x5519u);
      }
      int SizeOfHeaderWithBundledPackets = _VCMediaQueuePacketBundler_GetSizeOfHeaderWithBundledPackets(v4, (uint64_t)v11);
      BOOL v13 = v7 || v11[288] != 0;
      BOOL v14 = v8 || v11[290] != 0;
      if (v13)
      {
        __int16 v15 = v9 + SizeOfHeaderWithBundledPackets;
      }
      else
      {
        v9 += SizeOfHeaderWithBundledPackets;
        char v16 = *((unsigned __int16 *)v11 + 2) + (unsigned __int16)v6 > v27 - SizeOfHeaderWithBundledPackets || v14;
        if ((v16 & 1) == 0 && v10 < 8)
        {
          ++v10;
          if (v4)
          {
            unint64_t v17 = v4;
            do
            {
              unint64_t v18 = v17;
              unint64_t v17 = *(void *)(v17 + 304);
            }
            while (v17);
            *(void *)(v18 + 304) = v11;
            int v19 = v6;
            uint64_t v20 = v4;
            goto LABEL_29;
          }
          int v19 = v6;
          goto LABEL_28;
        }
        __int16 v15 = v9;
      }
      uint64_t v21 = _VCMediaQueuePacketBundler_GetSizeOfHeaderWithBundledPackets(v4, 0);
      int v10 = 0;
      __int16 v9 = 0;
      int v19 = 0;
      uint64_t v20 = (uint64_t)v11;
      if (!a2 || !v4) {
        goto LABEL_29;
      }
      int v22 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, void, void))(a2 + 16))(a2, v4, v21, (unsigned __int16)v6, (__int16)(v15 - v21));
      if (v22)
      {
        int v23 = v22;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          uint64_t v24 = VRTraceErrorLogLevelToCSTR();
          char v25 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            uint64_t v30 = v24;
            __int16 v31 = 2080;
            BOOL v32 = "_VCMediaQueuePacketBundler_ReturnProcessedPackets";
            __int16 v33 = 1024;
            int v34 = 76;
            __int16 v35 = 1024;
            int v36 = v23;
            _os_log_error_impl(&dword_1E1EA4000, v25, OS_LOG_TYPE_ERROR, " [%s] %s:%d Output Block failed (%d)", buf, 0x22u);
          }
        }
      }
      int v10 = 0;
      __int16 v9 = 0;
      int v19 = 0;
LABEL_28:
      uint64_t v20 = (uint64_t)v11;
LABEL_29:
      unint64_t v5 = v20 + 312;
      int v6 = *((unsigned __int16 *)v11 + 2) + v19;
      BOOL v7 = v11[288] != 0;
      BOOL v8 = v11[290] != 0;
      unint64_t v4 = v20;
      if (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 32)) <= 0) {
        goto LABEL_35;
      }
    }
  }
  uint64_t v20 = 0;
LABEL_35:
  _VCMediaQueuePacketBundler_GetSizeOfHeaderWithBundledPackets(v20, 0);
  if (a2)
  {
    if (v20)
    {
      if ((*(unsigned int (**)(void))(a2 + 16))())
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VCMediaQueuePacketBundler_BundlePacketsWithFCFSPolicy_cold_1();
          }
        }
      }
    }
  }
  return 0;
}

uint64_t _VCMediaQueuePacketBundler_GetSizeOfHeaderWithBundledPackets(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  memset(__b, 170, sizeof(__b));
  if (!a1)
  {
    unsigned __int16 v5 = 0;
    int v10 = 0;
    int v11 = 0;
    unsigned __int16 v12 = 0;
    if (!a2) {
      goto LABEL_15;
    }
LABEL_10:
    BOOL v13 = &__b[5 * v5];
    long long v14 = *(_OWORD *)(a2 + 64);
    v13[2] = *(_OWORD *)(a2 + 48);
    v13[3] = v14;
    v13[4] = *(_OWORD *)(a2 + 80);
    long long v15 = *(_OWORD *)(a2 + 32);
    *BOOL v13 = *(_OWORD *)(a2 + 16);
    v13[1] = v15;
LABEL_11:
    ++v5;
    int v11 = *(unsigned __int8 *)(a2 + 293);
    goto LABEL_13;
  }
  BOOL v4 = 0;
  unsigned __int16 v5 = 0;
  do
  {
    if (v5 <= 0xEu)
    {
      int v6 = &__b[5 * v5];
      _OWORD *v6 = *(_OWORD *)(a1 + 16);
      long long v7 = *(_OWORD *)(a1 + 32);
      long long v8 = *(_OWORD *)(a1 + 48);
      long long v9 = *(_OWORD *)(a1 + 80);
      v6[3] = *(_OWORD *)(a1 + 64);
      v6[4] = v9;
      v6[1] = v7;
      v6[2] = v8;
    }
    ++v5;
    int v10 = *(unsigned __int8 *)(a1 + 293) | v4;
    BOOL v4 = v10 != 0;
    a1 = *(void *)(a1 + 304);
  }
  while (a1);
  if (a2)
  {
    if (v5 > 0xEu) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  int v11 = 0;
LABEL_13:
  if (v5 >= 0x10u && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCMediaQueuePacketBundler_GetSizeOfHeaderWithBundledPackets_cold_1();
    }
  }
  unsigned __int16 v12 = v5;
LABEL_15:
  __int16 IDSHeaderSizeWithChannelDataFormatArray = VCIDSChannelData_GetIDSHeaderSizeWithChannelDataFormatArray((uint64_t)__b, v12);
  if (v11 | v10) {
    __int16 v17 = 48;
  }
  else {
    __int16 v17 = 28;
  }
  return (unsigned __int16)(IDSHeaderSizeWithChannelDataFormatArray + v17);
}

uint64_t _VCMediaQueuePacketBundlerClassRegister(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

unint64_t VCMediaQueuePacketBundler_Create(uint64_t a1, void *a2, int a3, int a4)
{
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaQueuePacketBundler_Create_cold_1();
      }
    }
    return 4294954516;
  }
  if (VCMediaQueuePacketBundlerGetTypeID_initOnce != -1) {
    dispatch_once_f(&VCMediaQueuePacketBundlerGetTypeID_initOnce, &VCMediaQueuePacketBundlerGetTypeID_typeID, (dispatch_function_t)_VCMediaQueuePacketBundlerClassRegister);
  }
  unint64_t result = _CFRuntimeCreateInstance();
  if (!result)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaQueuePacketBundler_Create_cold_2();
      }
    }
    return 4294954516;
  }
  long long v8 = (const void *)result;
  *(_DWORD *)(result + 16) = a3;
  *(_DWORD *)(result + 20) = a4;
  *(unsigned char *)(result + 24) = 0;
  if (result >= result + 40)
  {
    __break(0x5519u);
  }
  else
  {
    unint64_t result = CMSimpleQueueCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1000, (CMSimpleQueueRef *)(result + 32));
    if (result)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCMediaQueuePacketBundler_Create_cold_3();
        }
      }
      CFRelease(v8);
      return 0;
    }
    else
    {
      *a2 = v8;
    }
  }
  return result;
}

uint64_t VCMediaQueuePacketBundler_AddPacket(uint64_t a1, void *element)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaQueuePacketBundler_AddPacket_cold_1();
      }
    }
    return 4294954516;
  }
  if (!element)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaQueuePacketBundler_AddPacket_cold_2();
      }
    }
    return 4294954516;
  }
  if (element[38])
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaQueuePacketBundler_AddPacket_cold_4();
      }
    }
    return 4294954516;
  }
  unsigned __int16 v4 = atomic_load((unsigned int *)(a1 + 20));
  unsigned __int8 v5 = atomic_load((unsigned __int8 *)(a1 + 24));
  if ((v5 & 1) == 0)
  {
    int v6 = v4;
    if (v4 < *((unsigned __int16 *)element + 2) && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v8 = VRTraceErrorLogLevelToCSTR();
      long long v9 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        int v10 = *((unsigned __int16 *)element + 2);
        int v11 = 136316162;
        uint64_t v12 = v8;
        __int16 v13 = 2080;
        long long v14 = "VCMediaQueuePacketBundler_AddPacket";
        __int16 v15 = 1024;
        int v16 = 241;
        __int16 v17 = 1024;
        int v18 = v10;
        __int16 v19 = 1024;
        int v20 = v6;
        _os_log_error_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_ERROR, " [%s] %s:%d mediaPacket->dataSizeByte(%u) is bigger than bundler->currentMTUBytes(%u)", (uint8_t *)&v11, 0x28u);
      }
    }
  }
  uint64_t result = CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(a1 + 32), element);
  if (result)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCMediaQueuePacketBundler_AddPacket_cold_3();
    }
    return 0;
  }
  return result;
}

uint64_t VCMediaQueuePacketBundler_SetMTU(unsigned int *a1, unsigned int a2)
{
  if (a1)
  {
    CFRetain(a1);
    atomic_store(a2, a1 + 5);
    CFRelease(a1);
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaQueuePacketBundler_SetMTU_cold_1();
      }
    }
    return 4294954516;
  }
}

uint64_t VCMediaQueuePacketBundler_SetOneToOne(uint64_t a1, unsigned __int8 a2)
{
  if (a1)
  {
    uint64_t result = 0;
    atomic_store(a2, (unsigned __int8 *)(a1 + 24));
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaQueuePacketBundler_SetOneToOne_cold_1();
      }
    }
    return 4294954516;
  }
  return result;
}

uint64_t VCMediaQueuePacketBundler_BundlePackets(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      CFRetain((CFTypeRef)a1);
      unsigned __int8 v4 = atomic_load((unsigned __int8 *)(a1 + 24));
      if (v4) {
        goto LABEL_6;
      }
      int v5 = *(_DWORD *)(a1 + 16);
      if (v5 == 1)
      {
        _VCMediaQueuePacketBundler_BundlePacketsWithFCFSPolicy(a1, a2);
        goto LABEL_7;
      }
      if (!v5) {
LABEL_6:
      }
        _VCMediaQueuePacketBundler_BundlePacketsWithNonePolicy(a1, a2);
LABEL_7:
      CFRelease((CFTypeRef)a1);
      return 0;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaQueuePacketBundler_BundlePackets_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCMediaQueuePacketBundler_BundlePackets_cold_1();
    }
  }
  return 4294954516;
}

void *_VCMediaQueuePacketBundler_Init(void *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void _VCMediaQueuePacketBundler_Finalize(uint64_t a1)
{
  unsigned int v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t _VCTextReceiver_ReceiveProc(void *a1, const char *a2)
{
  return [a1 receiverThreadCallback:a2];
}

void sub_1E2188BE8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t VTPCallback(int a1, void *a2, double *a3, unsigned int *a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v8 = VRTraceErrorLogLevelToCSTR();
    long long v9 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v19 = 136316674;
      uint64_t v20 = v8;
      __int16 v21 = 2080;
      int v22 = "VTPCallback";
      __int16 v23 = 1024;
      int v24 = 925;
      __int16 v25 = 2048;
      double v26 = *(double *)&a2;
      __int16 v27 = 1024;
      int v28 = a1;
      __int16 v29 = 2048;
      uint64_t v30 = a3;
      __int16 v31 = 2048;
      BOOL v32 = a4;
      _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCM:VTPCallback: context (%p) notification (%d) data (%p) optional (%p).", (uint8_t *)&v19, 0x40u);
    }
  }
  id v10 = objc_alloc_init(MEMORY[0x1E4F28B28]);
  if (a1 == 2) {
    goto LABEL_19;
  }
  if (a1 != 1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTPCallback_cold_1();
      }
    }
    goto LABEL_19;
  }
  if (!a3)
  {
LABEL_19:
    uint64_t v17 = 0xFFFFFFFFLL;
    goto LABEL_20;
  }
  double v11 = *a3;
  uint64_t v12 = *a4;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v13 = VRTraceErrorLogLevelToCSTR();
    long long v14 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v19 = 136316162;
      uint64_t v20 = v13;
      __int16 v21 = 2080;
      int v22 = "VTPCallback";
      __int16 v23 = 1024;
      int v24 = 936;
      __int16 v25 = 2048;
      double v26 = v11;
      __int16 v27 = 1024;
      int v28 = v12;
      _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCM: Receive remote-no-remote-packet notification, %f. callID %d", (uint8_t *)&v19, 0x2Cu);
    }
  }
  if (v12)
  {
    id v15 = (id)[a2 conferenceForCallID:v12];
    int v16 = v15;
    if (v15 && [v15 shouldReinitializeCallWithDuration:v12 forCallID:v11]) {
      objc_msgSend(+[AVConferenceXPCServer AVConferenceXPCServerSingleton](AVConferenceXPCServer, "AVConferenceXPCServerSingleton"), "sendMessageAsync:arguments:context:", "conferenceReinitializeCall", 0, v16);
    }
  }
  uint64_t v17 = 0;
LABEL_20:

  return v17;
}

uint64_t SIPCallback(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v35[2] = *MEMORY[0x1E4F143B8];
  id v15 = objc_alloc_init(MEMORY[0x1E4F28B28]);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v16 = VRTraceErrorLogLevelToCSTR();
    uint64_t v17 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316418;
      uint64_t v27 = v16;
      __int16 v28 = 2080;
      __int16 v29 = "SIPCallback";
      __int16 v30 = 1024;
      int v31 = 872;
      __int16 v32 = 2048;
      uint64_t v33 = a2;
      __int16 v34 = 1024;
      LODWORD(v35[0]) = a4;
      WORD2(v35[0]) = 1024;
      *(_DWORD *)((char *)v35 + 6) = a3;
      _os_log_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SIPCallback: %p, dwCallID = %d (%d)", buf, 0x32u);
    }
  }
  if ([a2 isSIPHandleValid:a1])
  {
    if (a4)
    {
      id v18 = (id)[a2 conferenceForCallID:a4];
    }
    else
    {
      if (a3 != 13 || !a5)
      {
LABEL_19:
        id v18 = (id)[a2 activeConference];
        if (!v18)
        {
          uint64_t v19 = 3;
          goto LABEL_21;
        }
LABEL_20:
        uint64_t v19 = [v18 sipCallbackNotification:a3 callID:a4 msgIn:a5 msgOut:a6 optional:a7 confIndex:a8];
LABEL_21:

        return v19;
      }
      id v20 = (id)objc_msgSend(a2, "conferenceForParticipantID:", objc_msgSend(NSString, "stringWithUTF8String:", a5));
      id v18 = v20;
      if (a6 && !v20) {
        id v18 = (id)[a2 conferenceForSourceDestinationInfo:a6];
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v21 = VRTraceErrorLogLevelToCSTR();
        int v22 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          if (v18) {
            __int16 v23 = (const char *)objc_msgSend((id)objc_msgSend(v18, "description"), "UTF8String");
          }
          else {
            __int16 v23 = "<nil>";
          }
          *(_DWORD *)buf = 136316162;
          uint64_t v27 = v21;
          __int16 v28 = 2080;
          __int16 v29 = "SIPCallback";
          __int16 v30 = 1024;
          int v31 = 895;
          __int16 v32 = 2048;
          uint64_t v33 = a2;
          __int16 v34 = 2080;
          v35[0] = v23;
          _os_log_impl(&dword_1E1EA4000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SIPCallback: VCManager %p matched VC %s to get callee callID", buf, 0x30u);
        }
      }
    }
    if (v18) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  [v15 drain];
  return 3;
}

void CellConditionChangeCallback(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v6 = VRTraceErrorLogLevelToCSTR();
    long long v7 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 136315650;
      uint64_t v10 = v6;
      __int16 v11 = 2080;
      uint64_t v12 = "CellConditionChangeCallback";
      __int16 v13 = 1024;
      int v14 = 914;
      _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoConferenceManager: CellConditionChangeCallback", (uint8_t *)&v9, 0x1Cu);
    }
  }
  id v8 = objc_alloc_init(MEMORY[0x1E4F28B28]);
  [a1 broadcastCellTechChange:a2 cellularMaxPktLen:a3];
}

uint64_t VTP_Initialize()
{
  keys[2] = *(void **)MEMORY[0x1E4F143B8];
  pthread_mutex_lock(&g_x_hvtp);
  if (g_hVTP != 0xFFFFFFFFLL)
  {
    pthread_mutex_unlock(&g_x_hvtp);
    uint64_t v0 = __error();
    int v1 = 17;
LABEL_67:
    *uint64_t v0 = v1;
    return 0xFFFFFFFFLL;
  }
  unsigned int v2 = (CFAllocatorRef *)malloc_type_calloc(1uLL, 0x5640uLL, 0x10E0040BCFFB248uLL);
  if (!v2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if (VRTraceIsOSFaultDisabled())
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_Initialize_cold_1();
        }
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
      {
        VTP_Initialize_cold_2();
      }
    }
    goto LABEL_65;
  }
  uint64_t v3 = (uint64_t)v2;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (VCAllocatorFirstCome_Create((const __CFAllocator *)*MEMORY[0x1E4F1CF80], (uint64_t)"VTPBlockBufferHeaderAllocator", v2 + 2753))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if (VRTraceIsOSFaultDisabled())
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_Initialize_cold_23();
        }
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
      {
        VTP_Initialize_cold_24();
      }
    }
    goto LABEL_134;
  }
  if (VCUseFigMemoryPoolForDataBlockBuffer())
  {
    int v5 = CMMemoryPoolCreate(0);
    *(void *)(v3 + 5904) = v5;
    if (!v5)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
      {
        VRTraceErrorLogLevelToCSTR();
        if (VRTraceIsOSFaultDisabled())
        {
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VTP_Initialize_cold_5();
          }
        }
        else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
        {
          VTP_Initialize_cold_6();
        }
      }
      goto LABEL_134;
    }
    CFAllocatorRef Allocator = CMMemoryPoolGetAllocator(v5);
    *(void *)(v3 + 22032) = Allocator;
    if (!Allocator)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
      {
        VRTraceErrorLogLevelToCSTR();
        if (VRTraceIsOSFaultDisabled())
        {
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VTP_Initialize_cold_7();
          }
        }
        else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
        {
          VTP_Initialize_cold_8();
        }
      }
      goto LABEL_134;
    }
    CFRetain(Allocator);
  }
  else
  {
    *(_OWORD *)buf = xmmword_1E25A0000;
    *(_OWORD *)&buf[16] = xmmword_1E25A0010;
    *(void *)&uint8_t buf[32] = 2049;
    if (VCAllocatorMultiQueue_Create(v4, (uint64_t)"VTPBlockBufferDataAllocator", 5u, (unint64_t *)buf, (CFAllocatorRef *)(v3 + 22032)))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
      {
        VRTraceErrorLogLevelToCSTR();
        if (VRTraceIsOSFaultDisabled())
        {
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VTP_Initialize_cold_21();
          }
        }
        else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
        {
          VTP_Initialize_cold_22();
        }
      }
      goto LABEL_134;
    }
  }
  if (VCAllocatorFirstCome_Create(v4, (uint64_t)"VTPPacketRoutingInfoAllocatorName", (CFAllocatorRef *)(v3 + 22048)))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if (VRTraceIsOSFaultDisabled())
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_Initialize_cold_19();
        }
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
      {
        VTP_Initialize_cold_20();
      }
    }
    goto LABEL_134;
  }
  long long v7 = VCMemoryPool_Create(0x218uLL);
  *(void *)(v3 + 22040) = v7;
  if (!v7)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if (VRTraceIsOSFaultDisabled())
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_Initialize_cold_9();
        }
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
      {
        VTP_Initialize_cold_10();
      }
    }
    goto LABEL_134;
  }
  id v8 = VCMemoryPool_Create(0x238uLL);
  *(void *)(v3 + 5872) = v8;
  if (!v8)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if (VRTraceIsOSFaultDisabled())
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_Initialize_cold_11();
        }
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
      {
        VTP_Initialize_cold_12();
      }
    }
LABEL_134:
    _VTP_ReleaseAllocators(v3);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if (VRTraceIsOSFaultDisabled())
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_Initialize_cold_3();
        }
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
      {
        VTP_Initialize_cold_4();
      }
    }
    goto LABEL_64;
  }
  uint64_t v9 = v3 + 21624;
  metadata = nw_ip_create_metadata();
  *(void *)(v3 + 22056) = metadata;
  nw_ip_metadata_set_service_class(metadata, nw_service_class_interactive_voice);
  if (!*(void *)(v3 + 22056))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
      goto LABEL_105;
    }
    uint64_t v36 = VRTraceErrorLogLevelToCSTR();
    uint64_t v37 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_105;
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = v36;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "_VTP_PrepareServiceClassMetadataForNWConnection";
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)&unsigned char buf[24] = 5281;
    unsigned int v38 = " [%s] %s:%d NW connection metadata creation failed for voice";
LABEL_104:
    _os_log_impl(&dword_1E1EA4000, v37, OS_LOG_TYPE_DEFAULT, v38, buf, 0x1Cu);
    goto LABEL_105;
  }
  __int16 v11 = nw_ip_create_metadata();
  *(void *)(v3 + 22064) = v11;
  nw_ip_metadata_set_service_class(v11, nw_service_class_interactive_video);
  if (!*(void *)(v3 + 22064))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
      goto LABEL_105;
    }
    uint64_t v39 = VRTraceErrorLogLevelToCSTR();
    uint64_t v37 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_105;
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = v39;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "_VTP_PrepareServiceClassMetadataForNWConnection";
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)&unsigned char buf[24] = 5285;
    unsigned int v38 = " [%s] %s:%d NW connection metadata creation failed for video";
    goto LABEL_104;
  }
  uint64_t v12 = nw_ip_create_metadata();
  *(void *)(v3 + 22072) = v12;
  nw_ip_metadata_set_service_class(v12, nw_service_class_background);
  if (*(void *)(v3 + 22072)) {
    goto LABEL_20;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    uint64_t v40 = VRTraceErrorLogLevelToCSTR();
    uint64_t v37 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = v40;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "_VTP_PrepareServiceClassMetadataForNWConnection";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&unsigned char buf[24] = 5289;
      unsigned int v38 = " [%s] %s:%d NW connection metadata creation failed for background";
      goto LABEL_104;
    }
  }
LABEL_105:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    uint64_t v41 = VRTraceErrorLogLevelToCSTR();
    unsigned int v42 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = v41;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "VTP_Initialize";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&unsigned char buf[24] = 419;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 419;
      _os_log_impl(&dword_1E1EA4000, v42, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: Failed to create metadata for service class", buf, 0x22u);
    }
  }
LABEL_20:
  *(_DWORD *)(v3 + 16) = 1074937874;
  *(void *)(v3 + 20) = 0xFFFFFFFF00000000;
  *(_DWORD *)(v3 + 5864) = 16;
  *(unsigned char *)(v3 + 21644) = 0;
  *(void *)(v3 + 112) = 0;
  *(void *)(v3 + 120) = 0;
  *(unsigned char *)uint64_t v9 = VCDefaults_GetBoolValueForKey(@"forceDSCPTagging", 0);
  *(_DWORD *)(v3 + 21636) = objc_msgSend(+[GKSConnectivitySettings getStorebagValueForStorebagKey:userDefaultKey:defaultValue:isDoubleType:](GKSConnectivitySettings, "getStorebagValueForStorebagKey:userDefaultKey:defaultValue:isDoubleType:", @"vc-cellular-expiration-time-audio", @"cellularExpirationTimeAudio", &unk_1F3DC4968, 0), "intValue");
  *(_DWORD *)(v3 + 21632) = objc_msgSend(+[GKSConnectivitySettings getStorebagValueForStorebagKey:userDefaultKey:defaultValue:isDoubleType:](GKSConnectivitySettings, "getStorebagValueForStorebagKey:userDefaultKey:defaultValue:isDoubleType:", @"vc-cellular-expiration-time-video", @"cellularExpirationTimeVideo", &unk_1F3DC4980, 0), "intValue");
  __int16 v13 = malloc_type_calloc(1uLL, 0x140uLL, 0x1000040A86A77D5uLL);
  *(void *)(v3 + 5856) = v13;
  if (!v13)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if (VRTraceIsOSFaultDisabled())
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_Initialize_cold_13();
        }
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
      {
        VTP_Initialize_cold_14();
      }
    }
    _VTP_ReleaseAllocators(v3);
LABEL_64:
    free((void *)v3);
LABEL_65:
    pthread_mutex_unlock(&g_x_hvtp);
LABEL_66:
    uint64_t v0 = __error();
    int v1 = 22;
    goto LABEL_67;
  }
  memset((void *)(v3 + 14232), 255, 0x1CE0uLL);
  g_hVTP = CreateHandle();
  pthread_mutex_unlock(&g_x_hvtp);
  if (g_hVTP == 0xFFFFFFFFLL)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Initialize_cold_15();
      }
    }
    free(*(void **)(v3 + 5856));
    _VTP_ReleaseAllocators(v3);
    free((void *)v3);
    goto LABEL_66;
  }
  pthread_mutex_init((pthread_mutex_t *)(v3 + 48), 0);
  pthread_mutex_init((pthread_mutex_t *)(v3 + 4224), 0);
  pthread_mutex_init((pthread_mutex_t *)(v3 + 4288), 0);
  pthread_mutex_init((pthread_mutex_t *)(v3 + 5792), 0);
  pthread_rwlock_init((pthread_rwlock_t *)(v3 + 5376), 0);
  pthread_rwlock_init((pthread_rwlock_t *)(v3 + 5584), 0);
  pthread_rwlock_init((pthread_rwlock_t *)(v3 + 21648), 0);
  int v14 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  *(void *)(v3 + 21848) = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
  [+[VCDatagramChannelManager sharedInstance] setReadHandler:&__block_literal_global_60];
  uint64_t v15 = (void *)*MEMORY[0x1E4F21EB0];
  keys[0] = *(void **)MEMORY[0x1E4F21EA8];
  keys[1] = v15;
  uint64_t v16 = (void *)*MEMORY[0x1E4F1CFC8];
  values[0] = @"com.apple.avconference.vtransport.recvproc";
  values[1] = v16;
  CFDictionaryRef v17 = CFDictionaryCreate(v4, (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], v14);
  id v18 = (uint64_t *)(v3 + 32);
  int v19 = FigThreadCreate();
  if (v17) {
    CFRelease(v17);
  }
  if (v19)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if (VRTraceIsOSFaultDisabled())
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_Initialize_cold_17();
        }
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
      {
        VTP_Initialize_cold_18();
      }
    }
    VTP_Cleanup();
    return 0xFFFFFFFFLL;
  }
  *(void *)(v3 + 5888) = 0xFFFFFFFFLL;
  *(unsigned char *)(v3 + 5896) = 0;
  *(unsigned char *)(v3 + 5897) = [+[VCDefaults sharedInstance] enablePacketLogging];
  *(unsigned char *)(v3 + 21625) = 0;
  CFPropertyListRef v20 = CFPreferencesCopyAppValue(@"DisableWMM", @"com.apple.VideoConference");
  if (v20)
  {
    uint64_t v21 = v20;
    if (CFEqual(v20, (CFTypeRef)*MEMORY[0x1E4F1CFD0])) {
      *(unsigned char *)(v3 + 21625) = 1;
    }
    CFRelease(v21);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v22 = VRTraceErrorLogLevelToCSTR();
    __int16 v23 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v24 = *(unsigned __int8 *)(v3 + 21625);
      *(_DWORD *)buf = 136315906;
      if (v24) {
        __int16 v25 = "disabled";
      }
      else {
        __int16 v25 = "enabled";
      }
      *(void *)&uint8_t buf[4] = v22;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "VTP_Initialize";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&unsigned char buf[24] = 499;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = v25;
      _os_log_impl(&dword_1E1EA4000, v23, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d WMM is=%s.", buf, 0x26u);
    }
  }
  *(_DWORD *)(v3 + 21628) = 0;
  *(double *)(v3 + 22000) = micro();
  Boolean keyExistsAndHasValidFormat = -86;
  AppIntegerCFDataRef Value = CFPreferencesGetAppIntegerValue(@"fttc", @"com.apple.VideoConference", &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat)
  {
    int v27 = AppIntegerValue;
    if (AppIntegerValue > 999 || AppIntegerValue % 100)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_Initialize_cold_16();
        }
      }
    }
    else
    {
      if (AppIntegerValue && *(unsigned char *)(v9 + 1))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v28 = VRTraceErrorLogLevelToCSTR();
          __int16 v29 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            *(void *)&uint8_t buf[4] = v28;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "VTP_Initialize";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 509;
            _os_log_impl(&dword_1E1EA4000, v29, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Override DisableWMM due to FT traffic class is set.", buf, 0x1Cu);
          }
        }
        *(unsigned char *)(v9 + 1) = 0;
      }
      *(_DWORD *)(v9 + 4) = v27;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v30 = VRTraceErrorLogLevelToCSTR();
        int v31 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          *(void *)&uint8_t buf[4] = v30;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "VTP_Initialize";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 513;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v27;
          _os_log_impl(&dword_1E1EA4000, v31, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Force FaceTime traffic class=%d.", buf, 0x22u);
        }
      }
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v33 = VRTraceErrorLogLevelToCSTR();
    __int16 v34 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v35 = *v18;
      *(_DWORD *)buf = 136316418;
      *(void *)&uint8_t buf[4] = v33;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "VTP_Initialize";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&unsigned char buf[24] = 519;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 519;
      *(_WORD *)&buf[34] = 2048;
      *(void *)&buf[36] = v35;
      __int16 v45 = 2048;
      uint64_t v46 = g_hVTP;
      _os_log_impl(&dword_1E1EA4000, v34, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: VTPRecvProc thread=%p started. g_hVTP:[%p]", buf, 0x36u);
    }
  }
  return 0;
}

void _VTP_ReleaseAllocators(uint64_t a1)
{
  VCMemoryPool_Destroy(*(OSQueueHead **)(a1 + 5872));
  *(void *)(a1 + 5872) = 0;
  VCMemoryPool_Destroy(*(OSQueueHead **)(a1 + 22040));
  *(void *)(a1 + 22040) = 0;
  unsigned int v2 = *(const void **)(a1 + 22048);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 22048) = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 22032);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 22032) = 0;
  }
  CFAllocatorRef v4 = *(const void **)(a1 + 22024);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 22024) = 0;
  }
  int v5 = *(OpaqueCMMemoryPool **)(a1 + 5904);
  if (v5)
  {
    CMMemoryPoolInvalidate(v5);
    uint64_t v6 = *(const void **)(a1 + 5904);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(a1 + 5904) = 0;
    }
  }
}

uint64_t VTPRecvProc(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  v101[2] = *MEMORY[0x1E4F143B8];
  v84.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&v84.tv_usec = 0xAAAAAAAAAAAAAAAALL;
  int v83 = 0;
  uint64_t v1 = CheckInHandleDebug();
  if (v1)
  {
    uint64_t v2 = v1;
    uint64_t v3 = (pthread_rwlock_t *)(v1 + 5376);
    memset(&v86, 0, sizeof(v86));
    pthread_rwlock_rdlock((pthread_rwlock_t *)(v1 + 5376));
    if (*(_DWORD *)(v2 + 20))
    {
LABEL_3:
      pthread_rwlock_unlock(v3);
      signed int v4 = 0;
LABEL_4:
      CheckOutHandleDebug();
      return v4;
    }
    while (1)
    {
      int v7 = *(_DWORD *)(v2 + 24);
      if (v7 == -1)
      {
        int v7 = socket(2, 1, 6);
        *(_DWORD *)(v2 + 24) = v7;
        if (v7 == -1)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            uint64_t v72 = VRTraceErrorLogLevelToCSTR();
            uint64_t v73 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315906;
              *(void *)&uint8_t buf[4] = v72;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = "VTPRecvProc";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&unsigned char buf[24] = 4211;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = 4211;
              _os_log_error_impl(&dword_1E1EA4000, v73, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: socket failed. We may run out of file descriptors", buf, 0x22u);
            }
          }
          usleep(0x2710u);
          goto LABEL_159;
        }
      }
      if (__darwin_check_fd_set_overflow(v7, &v86, 0)) {
        *(__int32_t *)((char *)v86.fds_bits + (((unint64_t)v7 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v7;
      }
      int v8 = *(_DWORD *)(v2 + 24);
      for (uint64_t i = *(void *)(v2 + 5576); i; uint64_t i = *(void *)(i + 352))
      {
        unint64_t v10 = *(int *)(i + 20);
        if (v10 <= 0xFFFFFFFD)
        {
          if (__darwin_check_fd_set_overflow(*(_DWORD *)(i + 20), &v86, 0)) {
            *(__int32_t *)((char *)v86.fds_bits + ((v10 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v10;
          }
          if (*(_DWORD *)(i + 20) > v8) {
            int v8 = *(_DWORD *)(i + 20);
          }
        }
      }
      pthread_rwlock_unlock(v3);
      v84.tv_sec = 5;
      v84.tv_usec = 0;
      int v11 = select(v8 + 1, &v86, 0, 0, &v84);
      int v12 = *__error();
      double v13 = micro();
      double v14 = *(double *)(v2 + 22000);
      if (v14 > 0.0 && v13 - v14 > 5.0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v16 = VRTraceErrorLogLevelToCSTR();
          CFDictionaryRef v17 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            int v18 = *(_DWORD *)(v2 + 21992);
            *(_DWORD *)buf = 136315906;
            *(void *)&uint8_t buf[4] = v16;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "_VTP_LogOSChannelInfoWithInterval";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 4146;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v18;
            _os_log_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Triggering osChannelInfoLog [IDS readyToReadCount: %d]", buf, 0x22u);
          }
        }
        *(double *)(v2 + 22000) = v13;
        *(_DWORD *)(v2 + 21992) = 0;
        pthread_rwlock_rdlock(v3);
        for (uint64_t j = *(void *)(v2 + 5576); j; uint64_t j = *(void *)(j + 352))
        {
          if (*(_DWORD *)(j + 20) <= 0xFFFFFFFD && *(_DWORD *)(j + 392) == 4) {
            _VTP_LogOSChannelInfoToIDSDatagramChannel(*(void **)(j + 504));
          }
        }
        pthread_rwlock_unlock(v3);
      }
      if (!v11)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
        {
          uint64_t v20 = VRTraceErrorLogLevelToCSTR();
          uint64_t v21 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            *(void *)&uint8_t buf[4] = v20;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "VTPRecvProc";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 4246;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 4246;
            *(_WORD *)&buf[34] = 1024;
            *(_DWORD *)&buf[36] = v83;
            _os_log_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: Select timeout, VTP has received a total of %d packets", buf, 0x28u);
          }
        }
        bzero(buf, 0x1001uLL);
        pthread_rwlock_rdlock(v3);
        if (*(unsigned char *)(v2 + 40)) {
          int v22 = snprintf((char *)buf, 0x1000uLL, "reset:%d", *(_DWORD *)(v2 + 24));
        }
        else {
          int v22 = 0;
        }
        for (uint64_t k = *(void *)(v2 + 5576); k; uint64_t k = *(void *)(k + 352))
        {
          if (*(_DWORD *)(k + 20) <= 0xFFFFFFFD && *(_DWORD *)(k + 392) == 4) {
            _VTP_LogOSChannelInfoToIDSDatagramChannel(*(void **)(k + 504));
          }
          if (*(unsigned char *)(v2 + 40))
          {
            int v75 = snprintf((char *)&buf[v22], 4096 - v22, ",%d->%d", *(_DWORD *)k, *(_DWORD *)(k + 20));
            if (4096 - v22 <= v75 || v75 <= 0) {
              int v77 = 0;
            }
            else {
              int v77 = v75;
            }
            v22 += v77;
          }
        }
        if (*(unsigned char *)(v2 + 40))
        {
          *(unsigned char *)(v2 + 40) = 0;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
          {
            uint64_t v78 = (void *)VRTraceErrorLogLevelToCSTR();
            v79 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(v100.msg_name) = 136315906;
              *(void **)((char *)&v100.msg_name + 4) = v78;
              *((_WORD *)&v100.msg_namelen + 2) = 2080;
              *(void *)((char *)&v100.msg_namelen + 6) = "_VTP_LogOSChannelInfoWhenSelectTimeout";
              HIWORD(v100.msg_iov) = 1024;
              v100.msg_iovlen = 4177;
              *((_WORD *)&v100.msg_iovlen + 2) = 2080;
              *(void *)((char *)&v100.msg_iovlen + 6) = buf;
              _os_log_impl(&dword_1E1EA4000, v79, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Select timeout with fds:[%s]", (uint8_t *)&v100, 0x26u);
            }
          }
        }
LABEL_159:
        pthread_rwlock_unlock(v3);
        goto LABEL_160;
      }
      if (v11 != -1) {
        break;
      }
      if (v12 != 9)
      {
        signed int v4 = v12 | 0xC0170000;
        int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (ErrorLogLevelForModule >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VTPRecvProc_cold_2();
          }
        }
        goto LABEL_4;
      }
LABEL_160:
      memset(&v86, 0, sizeof(v86));
      pthread_rwlock_rdlock(v3);
      if (*(_DWORD *)(v2 + 20)) {
        goto LABEL_3;
      }
    }
    pthread_rwlock_rdlock(v3);
    uint64_t v23 = *(void *)(v2 + 5576);
    if (!v23)
    {
      int v24 = 0;
LABEL_158:
      VTP_DemuxPacketsToVFDList(v2, v24, &v83);
      goto LABEL_159;
    }
    int v24 = 0;
    while (1)
    {
      unint64_t v25 = *(int *)(v23 + 20);
      if (v25 <= 0xFFFFFFFD
        && __darwin_check_fd_set_overflow(*(_DWORD *)(v23 + 20), &v86, 0)
        && ((*(unsigned int *)((char *)v86.fds_bits + ((v25 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v25) & 1) != 0)
      {
        break;
      }
LABEL_130:
      uint64_t v23 = *(void *)(v23 + 352);
      if (!v23) {
        goto LABEL_158;
      }
    }
    int v85 = (char *)0xAAAAAAAAAAAAAAAALL;
    if (*(_DWORD *)(v23 + 392) == 4)
    {
      double v26 = *(void **)(v23 + 504);
      if (v26)
      {
        [v26 readyToRead];
        ++*(_DWORD *)(v2 + 21992);
        int v85 = *(char **)(v2 + 21856);
        *(void *)(v2 + 21856) = 0;
        *(_DWORD *)(v2 + 21864) = 0;
LABEL_50:
        int v27 = v24;
        if (v24)
        {
          do
          {
            uint64_t v28 = v27;
            int v27 = (unsigned char *)*((void *)v27 + 67);
          }
          while (v27);
          *((void *)v28 + 67) = v85;
        }
        else
        {
          int v24 = v85;
        }
LABEL_128:
        int v68 = *(_DWORD *)(v23 + 20);
        if (__darwin_check_fd_set_overflow(v68, &v86, 0)) {
          *(__int32_t *)((char *)v86.fds_bits + (((unint64_t)v68 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) &= ~(1 << v68);
        }
        goto LABEL_130;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
        goto LABEL_128;
      }
      uint64_t v40 = VRTraceErrorLogLevelToCSTR();
      uint64_t v41 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        goto LABEL_128;
      }
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = v40;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "VTP_RecvAndProcessPacketsFromDatagramChannel";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&unsigned char buf[24] = 5842;
      unsigned int v42 = v41;
      unsigned int v43 = " [%s] %s:%d nil dataChannel, cannot receive packet!";
      uint32_t v44 = 28;
LABEL_88:
      _os_log_error_impl(&dword_1E1EA4000, v42, OS_LOG_TYPE_ERROR, v43, buf, v44);
      goto LABEL_128;
    }
    double v29 = micro();
    if ((_VTP_AllocatePacketWithBufferFreeCallback(v2, 0, 0x801uLL, 0, 0, (CMBlockBufferRef **)&v85) & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
        goto LABEL_128;
      }
      uint64_t v45 = VRTraceErrorLogLevelToCSTR();
      uint64_t v46 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        goto LABEL_128;
      }
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = v45;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "VTP_RecvFromSocket";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&unsigned char buf[24] = 5936;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 5936;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = 568;
      unsigned int v42 = v46;
      unsigned int v43 = " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m"
            ":%d: calloc failed to allocate=%d bytes";
      uint32_t v44 = 40;
      goto LABEL_88;
    }
    if (*(_DWORD *)(v23 + 8) == 2)
    {
      *(void *)&long long v30 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&uint8_t buf[32] = v30;
      *(_OWORD *)&uint8_t buf[48] = v30;
      *(_OWORD *)buf = v30;
      *(_OWORD *)&buf[16] = v30;
      int v31 = v85;
      v101[0] = *((void *)v85 + 70);
      v101[1] = 2048;
      *((_DWORD *)v85 + 44) = 128;
      memset(&v100.msg_namelen, 170, 24);
      v100.msg_name = v31 + 48;
      v100.msg_iov = (iovec *)v101;
      v100.msg_namelen = 128;
      v100.msg_iovlen = 1;
      v100.msg_control = buf;
      *(void *)&v100.msg_controllen = 64;
      ssize_t v32 = recvmsg(*(_DWORD *)(v23 + 20), &v100, 0);
      uint64_t v82 = v24;
      if ((int)v32 <= 0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          uint64_t v69 = VRTraceErrorLogLevelToCSTR();
          uint64_t v70 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            int v71 = *(_DWORD *)(v23 + 20);
            *(_DWORD *)uint64_t v92 = 136315906;
            uint64_t v93 = v69;
            __int16 v94 = 2080;
            int v95 = "_VTP_RecvFromDatagramSocket";
            __int16 v96 = 1024;
            int v97 = 5880;
            __int16 v98 = 1024;
            int v99 = v71;
            _os_log_impl(&dword_1E1EA4000, v70, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d recvmsg failed for socket=%d", v92, 0x22u);
          }
        }
      }
      else
      {
        *((_DWORD *)v31 + 44) = v100.msg_namelen;
        if (*(unsigned char *)(v23 + 368)
          && v31[49] == 30
          && !memcmp(v31 + 56, (const void *)(v23 + 376), *(unsigned int *)(v23 + 372)))
        {
          int v33 = *((_DWORD *)v31 + 17);
          *((_DWORD *)v31 + 44) = 16;
          *((_WORD *)v31 + 24) = 528;
          *((_DWORD *)v31 + 13) = v33;
          *((void *)v31 + 7) = 0;
        }
        if (v100.msg_controllen >= 0xC)
        {
          msg_control = (unsigned int *)v100.msg_control;
          if (v100.msg_control)
          {
            uint64_t v35 = v31 + 28;
            while (1)
            {
              unsigned int v36 = msg_control[1];
              if (!v36) {
                break;
              }
              if (v36 == 41)
              {
                unsigned int v37 = msg_control[2];
                if (v37 == 47) {
                  goto LABEL_75;
                }
                if (v37 == 46)
                {
                  if (msg_control[3] || msg_control[4] || msg_control[5] != -65536) {
                    *uint64_t v35 = *(_OWORD *)(msg_control + 3);
                  }
                  else {
                    *(_DWORD *)uint64_t v35 = bswap32(msg_control[6]);
                  }
                  unsigned int v39 = msg_control[7];
LABEL_79:
                  VTP_IFIndexToName(v2, v39, v31 + 12);
                }
              }
LABEL_80:
              msg_control = (unsigned int *)((char *)msg_control + ((*msg_control + 3) & 0x1FFFFFFFCLL));
              if ((char *)(msg_control + 3) > (char *)v100.msg_control + v100.msg_controllen) {
                goto LABEL_81;
              }
            }
            unsigned int v38 = msg_control[2];
            if (v38 != 24)
            {
              if (v38 != 20)
              {
                if (v38 == 7) {
                  *(_DWORD *)uint64_t v35 = bswap32(msg_control[3]);
                }
                goto LABEL_80;
              }
              unsigned int v39 = *((unsigned __int16 *)msg_control + 7);
              goto LABEL_79;
            }
LABEL_75:
            v31[352] = *((unsigned char *)msg_control + 12);
            goto LABEL_80;
          }
        }
      }
LABEL_81:
      int v24 = v82;
    }
    else
    {
      int v31 = v85;
      ssize_t v32 = recv(*(_DWORD *)(v23 + 20), *((void **)v85 + 70), *((void *)v85 + 69), 0);
    }
    if (v32 == 2048)
    {
      ssize_t v32 = 2048;
      if (v31) {
        goto LABEL_93;
      }
      goto LABEL_123;
    }
    if ((_VTP_ShrinkPacket(v2, (int)v32, (uint64_t)v31) & 0x80000000) != 0)
    {
      ssize_t v32 = 0xFFFFFFFFLL;
    }
    else if ((int)v32 > 0)
    {
      goto LABEL_105;
    }
    _VTP_ReleasePacket(v2, (void **)&v85);
LABEL_105:
    switch(v32)
    {
      case 0x80170003:
        goto LABEL_128;
      case 0xFFFFFFFF:
        uint64_t v59 = v24;
        int v60 = *__error();
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          uint64_t v81 = VRTraceErrorLogLevelToCSTR();
          long long v61 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            long long v62 = "recv";
            if (*(_DWORD *)(v23 + 8) == 2) {
              long long v62 = "recvfrom";
            }
            int v63 = *(_DWORD *)(v23 + 20);
            *(_DWORD *)buf = 136316674;
            *(void *)&uint8_t buf[4] = v81;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "VTP_RecvAndProcessOnePacketFromSocket";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 5788;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 5788;
            *(_WORD *)&buf[34] = 2080;
            *(void *)&buf[36] = v62;
            *(_WORD *)&unsigned char buf[44] = 1024;
            *(_DWORD *)&buf[46] = v63;
            *(_WORD *)&buf[50] = 1024;
            *(_DWORD *)&buf[52] = v60 | 0xC0170000;
            _os_log_impl(&dword_1E1EA4000, v61, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: %s(%d) failed (%08X)", buf, 0x38u);
          }
        }
        int v24 = v59;
        goto LABEL_128;
      case 0:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          uint64_t v55 = VRTraceErrorLogLevelToCSTR();
          __int16 v56 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            long long v57 = "recv";
            if (*(_DWORD *)(v23 + 8) == 2) {
              long long v57 = "recvfrom";
            }
            int v58 = *(_DWORD *)(v23 + 20);
            *(_DWORD *)buf = 136316418;
            *(void *)&uint8_t buf[4] = v55;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "VTP_RecvAndProcessOnePacketFromSocket";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 5783;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 5783;
            *(_WORD *)&buf[34] = 2080;
            *(void *)&buf[36] = v57;
            *(_WORD *)&unsigned char buf[44] = 1024;
            *(_DWORD *)&buf[46] = v58;
            _os_log_impl(&dword_1E1EA4000, v56, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: %s(%d) returned 0: empty message", buf, 0x32u);
          }
        }
        _VTP_ReleasePacket(v2, (void **)&v85);
        goto LABEL_50;
    }
    int v31 = v85;
    if (v85)
    {
LABEL_93:
      *((double *)v31 + 23) = v29;
      memset(&v100, 0, 40);
      SAToIPPORTWithInterfaceIndexToNameCallback();
      unint64_t v91 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v47 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v47 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v89 = v47;
      long long v90 = v47;
      *(_OWORD *)&uint8_t buf[48] = v47;
      long long v88 = v47;
      *(_OWORD *)&buf[16] = v47;
      *(_OWORD *)&uint8_t buf[32] = v47;
      *(_OWORD *)buf = v47;
      VCSDInfoConstructWithIPPorts((uint64_t)(v85 + 8), (uint64_t)&v100, 0, 0, (uint64_t)buf);
      VTP_SetConnectionFlagsForPacket(v2, v23, (uint64_t)v85, (int *)buf);
      if ((VTP_ProcessPacketType(v2, (_DWORD *)v23, *(_DWORD *)(v23 + 20), (uint64_t)v85) & 0x80000000) != 0)
      {
        _VTP_ReleasePacket(v2, (void **)&v85);
        goto LABEL_128;
      }
      unsigned int v48 = v24;
      char v49 = v85;
      int v50 = *(_DWORD *)v85;
      if (*(_DWORD *)v85 == 2)
      {
        long long v51 = *(_OWORD *)&buf[16];
        *(_OWORD *)(v85 + 232) = *(_OWORD *)buf;
        *(_OWORD *)(v49 + 248) = v51;
        long long v52 = v89;
        *(_OWORD *)(v49 + 296) = v88;
        *(_OWORD *)(v49 + 312) = v52;
        *(_OWORD *)(v49 + 328) = v90;
        long long v53 = *(_OWORD *)&buf[48];
        *(_OWORD *)(v49 + 264) = *(_OWORD *)&buf[32];
        *((void *)v49 + 43) = v91;
        *(_OWORD *)(v49 + 280) = v53;
      }
      unsigned int v54 = *((_DWORD *)v49 + 56);
      VTP_UpdateReceivedBytes(*((_DWORD *)v49 + 54), v32, (v50 & 0xF0) != 0, v49[223], (uint64_t)buf, v49[413], v49[408], v49[412] != 0);
      if ((v50 & 0x100) == 0 && v54 != -1) {
        _VTP_HealthPrint(v2, *((void *)v85 + 69), v54, 0, 0);
      }
      int v24 = v48;
      goto LABEL_50;
    }
LABEL_123:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v64 = VRTraceErrorLogLevelToCSTR();
      long long v65 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        long long v66 = "recv";
        if (*(_DWORD *)(v23 + 8) == 2) {
          long long v66 = "recvfrom";
        }
        int v67 = *(_DWORD *)(v23 + 20);
        *(_DWORD *)buf = 136316418;
        *(void *)&uint8_t buf[4] = v64;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "VTP_RecvAndProcessOnePacketFromSocket";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = 5793;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 5793;
        *(_WORD *)&buf[34] = 2080;
        *(void *)&buf[36] = v66;
        *(_WORD *)&unsigned char buf[44] = 1024;
        *(_DWORD *)&buf[46] = v67;
        _os_log_impl(&dword_1E1EA4000, v65, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: %s(%d) error. Empty buffer returned!", buf, 0x32u);
      }
    }
    goto LABEL_128;
  }
  uint64_t v5 = -2145976318;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VTPRecvProc_cold_1();
    }
  }
  return v5;
}

uint64_t VTP_Cleanup()
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  pthread_mutex_lock(&g_x_hvtp);
  uint64_t v0 = CheckInHandleDebug();
  if (v0)
  {
    uint64_t v1 = v0;
    uint64_t v2 = (pthread_rwlock_t *)(v0 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v0 + 5376));
    for (uint64_t i = *(void *)(v1 + 5576); i; uint64_t i = *(void *)(i + 352))
      *(void *)(i + 504) = 0;
    *(_DWORD *)(v1 + 20) = 1;
    int v4 = *(_DWORD *)(v1 + 24);
    if (v4 != -1) {
      close(v4);
    }
    *(_DWORD *)(v1 + 24) = -1;
    pthread_rwlock_unlock(v2);
    if (*(void *)(v1 + 32))
    {
      *(void *)CFDictionaryRef v17 = 0xAAAAAAAAAAAAAAAALL;
      FigThreadJoin();
    }
    int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    uint64_t v6 = (os_log_t *)MEMORY[0x1E4F47A50];
    if (ErrorLogLevelForModule >= 7)
    {
      uint64_t v7 = VRTraceErrorLogLevelToCSTR();
      int v8 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *(void *)(v1 + 32);
        *(_DWORD *)CFDictionaryRef v17 = 136315906;
        *(void *)&v17[4] = v7;
        __int16 v18 = 2080;
        int v19 = "VTP_Cleanup";
        __int16 v20 = 1024;
        int v21 = 561;
        __int16 v22 = 2048;
        uint64_t v23 = v9;
        _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTPRecvProc thread[%p] end...", v17, 0x26u);
      }
    }
    pthread_rwlock_wrlock(v2);
    while (1)
    {
      unint64_t v10 = *(void **)(v1 + 5576);
      if (!v10) {
        break;
      }
      VTP_CloseOneVFDList(v1, *(int **)(v1 + 5576));
      *(void *)(v1 + 5576) = v10[44];
      free(v10);
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v11 = VRTraceErrorLogLevelToCSTR();
      int v12 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)CFDictionaryRef v17 = 136315650;
        *(void *)&v17[4] = v11;
        __int16 v18 = 2080;
        int v19 = "VTP_Cleanup";
        __int16 v20 = 1024;
        int v21 = 572;
        _os_log_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d removed all vfd from the list", v17, 0x1Cu);
      }
    }
    for (uint64_t j = *(void *)(v1 + 21856); j; *(void *)(v1 + 21856) = j)
    {
      uint64_t j = *(void *)(j + 536);
      _VTP_ReleasePacket(v1, (void **)(v1 + 21856));
    }
    while (1)
    {
      double v14 = *(void **)(v1 + 5880);
      if (!v14) {
        break;
      }
      *(void *)(v1 + 5880) = v14[257];
      free(v14);
    }
    pthread_rwlock_unlock(v2);
    CheckOutHandleDebug();
    g_hVTP = 0xFFFFFFFFLL;
    pthread_mutex_unlock(&g_x_hvtp);
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 48));
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 4224));
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 4288));
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 5792));
    pthread_rwlock_destroy(v2);
    pthread_rwlock_destroy((pthread_rwlock_t *)(v1 + 5584));
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v1 + 21648));
    CFRelease(*(CFTypeRef *)(v1 + 21848));
    pthread_rwlock_unlock((pthread_rwlock_t *)(v1 + 21648));
    pthread_rwlock_destroy((pthread_rwlock_t *)(v1 + 21648));
    nw_release(*(void **)(v1 + 22064));
    nw_release(*(void **)(v1 + 22056));
    nw_release(*(void **)(v1 + 22072));
    _VTP_ReleaseAllocators(v1);
    uint64_t v15 = *(void **)(v1 + 5856);
    if (v15) {
      free(v15);
    }
    free((void *)v1);
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Cleanup_cold_1();
      }
    }
    *__error() = 13;
    pthread_mutex_unlock(&g_x_hvtp);
    return 0xFFFFFFFFLL;
  }
}

uint64_t VTP_CloseOneVFDList(uint64_t a1, int *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  VCNAT64ResolverDeregisterAll(a2);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 5584));
  for (uint64_t i = *(void *)(a1 + 5784); i; uint64_t i = *(void *)(i + 152))
  {
    int v5 = *a2;
    uint64_t v6 = *(char **)(i + 128);
    if (__darwin_check_fd_set_overflow(*a2, v6, 0)
      && ((*(_DWORD *)&v6[((unint64_t)v5 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v5) & 1) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(i + 8));
      *(unsigned char *)(i + 121) = 1;
      pthread_cond_signal((pthread_cond_t *)(i + 72));
      pthread_mutex_unlock((pthread_mutex_t *)(i + 8));
    }
  }
  pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 5584));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v7 = VRTraceErrorLogLevelToCSTR();
    int v8 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v9 = *a2;
      unint64_t v10 = "UDP";
      if (a2[3] == 6) {
        unint64_t v10 = "TCP";
      }
      *(_DWORD *)buf = 136316162;
      uint64_t v20 = v7;
      __int16 v21 = 2080;
      __int16 v22 = "VTP_CloseOneVFDList";
      __int16 v23 = 1024;
      int v24 = 1883;
      __int16 v25 = 1024;
      int v26 = v9;
      __int16 v27 = 2080;
      uint64_t v28 = v10;
      _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d vfd=%d protocol=%s closed.", buf, 0x2Cu);
    }
  }
  VTP_ReleaseVFD((pthread_mutex_t *)a1, *a2);
  if (a2[5] <= 0xFFFFFFFD && a2[98] != 4) {
    _VTP_ReleaseSocket(a1, (uint64_t)a2);
  }
  int v11 = a2[98];
  if (v11 == 4)
  {
    *((void *)a2 + 63) = 0;
    if (a2[5] <= 0xFFFFFFFD)
    {
      a2[5] = -1;
      int v13 = *(_DWORD *)(a1 + 24);
      if (v13 != -1)
      {
        close(v13);
        *(_DWORD *)(a1 + 24) = -1;
      }
    }
  }
  else if (v11 == 5)
  {
    int v12 = (void *)*((void *)a2 + 50);
    if (v12)
    {
      nw_release(v12);
      *((void *)a2 + 50) = 0;
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 28));
  double v14 = (void *)*((void *)a2 + 13);
  while (1)
  {
    unint64_t v18 = (unint64_t)v14;
    if (!v14) {
      break;
    }
    double v14 = (void *)v14[67];
    _VTP_ReleasePacket(a1, (void **)&v18);
  }
  *((void *)a2 + 13) = 0;
  *((unsigned char *)a2 + 25) = 1;
  pthread_cond_broadcast((pthread_cond_t *)(a2 + 44));
  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 28));
  uint64_t v15 = (void *)*((void *)a2 + 4);
  if (v15) {
    free(v15);
  }
  uint64_t v16 = (void *)*((void *)a2 + 64);
  if (v16) {
    nw_release(v16);
  }
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 60));
  if (a2[56] >= 1)
  {
    do
      pthread_cond_wait((pthread_cond_t *)(a2 + 76), (pthread_mutex_t *)(a2 + 60));
    while (a2[56] > 0);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 60));
  pthread_mutex_destroy((pthread_mutex_t *)(a2 + 28));
  pthread_cond_destroy((pthread_cond_t *)(a2 + 44));
  pthread_mutex_destroy((pthread_mutex_t *)(a2 + 60));
  return pthread_cond_destroy((pthread_cond_t *)(a2 + 76));
}

void _VTP_ReleasePacket(uint64_t a1, void **a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v3 = *a2;
    if (*a2)
    {
      VCBlockBuffer_Clear((uint64_t)v3 + 544);
      VCMemoryPool_Free(*(OSQueueHead **)(a1 + 5872), v3);
      *a2 = 0;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    uint64_t v5 = VRTraceErrorLogLevelToCSTR();
    uint64_t v6 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315650;
      uint64_t v8 = v5;
      __int16 v9 = 2080;
      unint64_t v10 = "_VTP_ReleasePacket";
      __int16 v11 = 1024;
      int v12 = 699;
      _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Releasing NULL packet reference", (uint8_t *)&v7, 0x1Cu);
    }
  }
}

uint64_t VTP_SetCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = CheckInHandleDebug();
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = (pthread_mutex_t *)(v4 + 48);
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 48));
    *(void *)(v5 + 112) = a1;
    *(void *)(v5 + 120) = a2;
    pthread_mutex_unlock(v6);
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
}

uint64_t VTP_SetSessionID(int a1, const __CFString *a2)
{
  if ((a1 - 1024) <= 0xFFFFFC63)
  {
    uint64_t v2 = __error();
    int v3 = 22;
LABEL_10:
    *uint64_t v2 = v3;
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = (pthread_mutex_t *)CheckInHandleDebug();
  if (!v6)
  {
    uint64_t v2 = __error();
    int v3 = 13;
    goto LABEL_10;
  }
  int v7 = v6;
  uint64_t v8 = v6 + 66;
  pthread_mutex_lock(v6 + 66);
  __int16 v9 = (CFTypeRef *)&v7[106].__opaque[8 * (a1 - 100) + 48];
  if (*v9) {
    CFRelease(*v9);
  }
  CFStringRef Copy = 0;
  if (a2) {
    CFStringRef Copy = CFStringCreateCopy(0, a2);
  }
  *__int16 v9 = Copy;
  pthread_mutex_unlock(v8);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VTP_SetDTLS(int a1, uint64_t a2)
{
  if ((a1 - 1024) > 0xFFFFFC63)
  {
    uint64_t v6 = (pthread_mutex_t *)CheckInHandleDebug();
    if (v6)
    {
      int v7 = v6;
      uint64_t v8 = v6 + 66;
      pthread_mutex_lock(v6 + 66);
      *(void *)&v7[222].__opaque[8 * (a1 - 100) + 16] = a2;
      pthread_mutex_unlock(v8);
      CheckOutHandleDebug();
      return 0;
    }
    uint64_t v2 = __error();
    int v3 = 13;
  }
  else
  {
    uint64_t v2 = __error();
    int v3 = 22;
  }
  *uint64_t v2 = v3;
  return 0xFFFFFFFFLL;
}

uint64_t VTP_Socket(int a1, int a2, int a3)
{
  return VTP_SocketWithRealSocket(a1, a2, a3, -1);
}

uint64_t VTP_SocketWithRealSocket(int a1, int a2, int a3, int a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = CheckInHandleDebug();
  if (v8)
  {
    uint64_t v9 = v8;
    bzero(v12, 0x208uLL);
    v12[1] = a1;
    v12[2] = a2;
    v12[3] = a3;
    v12[5] = a4;
    uint64_t v10 = _VTP_SocketWithRealSocketFromFVDList(v9, (uint64_t)v12);
    CheckOutHandleDebug();
  }
  else
  {
    *__error() = 13;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SocketWithRealSocket_cold_1();
      }
    }
    return 0xFFFFFFFFLL;
  }
  return v10;
}

uint64_t VTP_NWConnectionContext()
{
  if (VTP_NWConnectionContext_once != -1) {
    dispatch_once(&VTP_NWConnectionContext_once, &__block_literal_global_48);
  }
  return VTP_NWConnectionContext_context;
}

uint64_t VTP_NWConnectionQueue()
{
  if (VTP_NWConnectionQueue_once != -1) {
    dispatch_once(&VTP_NWConnectionQueue_once, &__block_literal_global_29);
  }
  return VTP_NWConnectionQueue_queue;
}

uint64_t VTP_CopyPreferredSendQueue(int a1, void *a2)
{
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_CopyPreferredSendQueue_cold_1();
      }
    }
    uint64_t v10 = __error();
    int v11 = 22;
    goto LABEL_17;
  }
  uint64_t v4 = CheckInHandleDebug();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_CopyPreferredSendQueue_cold_2();
      }
    }
    uint64_t v10 = __error();
    int v11 = 13;
LABEL_17:
    *uint64_t v10 = v11;
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = v4;
  uint64_t v6 = (pthread_rwlock_t *)(v4 + 5376);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
  uint64_t v7 = *(void *)(v5 + 5576);
  if (v7)
  {
    while (*(_DWORD *)v7 != a1)
    {
      uint64_t v7 = *(void *)(v7 + 352);
      if (!v7) {
        goto LABEL_6;
      }
    }
    if (*(_DWORD *)(v7 + 392) == 5)
    {
      if (VTP_NWConnectionQueue_once != -1) {
        dispatch_once(&VTP_NWConnectionQueue_once, &__block_literal_global_29);
      }
      uint64_t v13 = VTP_NWConnectionQueue_queue;
      *a2 = VTP_NWConnectionQueue_queue;
      dispatch_retain(v13);
      int v9 = 0;
      uint64_t v8 = 0;
    }
    else
    {
      int v9 = 0;
      uint64_t v8 = 0;
      *a2 = 0;
    }
  }
  else
  {
LABEL_6:
    uint64_t v8 = 0xFFFFFFFFLL;
    int v9 = 1;
  }
  pthread_rwlock_unlock(v6);
  CheckOutHandleDebug();
  if (v9) {
    *__error() = 9;
  }
  return v8;
}

uint64_t VTP_SocketWithNWConnection(unsigned int a1, int a2, NSObject *a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    *__error() = 22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SocketWithNWConnection_cold_1();
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (a2 != 17)
  {
    *__error() = 22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SocketWithNWConnection_cold_6();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = CheckInHandleDebug();
  if (!v5)
  {
    *__error() = 13;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SocketWithNWConnection_cold_2();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = v5;
  uint64_t v7 = (unsigned int *)malloc_type_calloc(1uLL, 0x208uLL, 0x10B204038ABB4E5uLL);
  if (!v7)
  {
    *__error() = 12;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if (VRTraceIsOSFaultDisabled())
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_SocketWithNWConnection_cold_3();
        }
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
      {
        VTP_SocketWithNWConnection_cold_4();
      }
    }
    goto LABEL_33;
  }
  uint64_t v8 = v7;
  unsigned int VFD = VTP_GetVFD((pthread_mutex_t *)v6);
  *uint64_t v8 = VFD;
  if (VFD == -1)
  {
    *__error() = 24;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SocketWithNWConnection_cold_5();
      }
    }
    free(v8);
LABEL_33:
    CheckOutHandleDebug();
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = nw_connection_copy_endpoint(a3);
  v8[1] = nw_endpoint_get_address(v10)->sa_family;
  nw_release(v10);
  v8[2] = a1;
  v8[5] = -1;
  *((unsigned char *)v8 + 24) = 0;
  v8[7] = 0;
  v8[56] = 0;
  *((void *)v8 + 45) = 0xFFFFFFFFLL;
  *(void *)(v8 + 3) = 0x100000011;
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v6 + 5376));
  nw_retain(a3);
  VCSDInfoConstructWithNWConnection((uint64_t)a3, (uint64_t)v24);
  long long v11 = v27;
  *(_OWORD *)(v8 + 114) = v26;
  *(_OWORD *)(v8 + 118) = v11;
  *(_OWORD *)(v8 + 122) = v28;
  *((void *)v8 + 63) = v29;
  long long v12 = *(_OWORD *)&v24[16];
  *(_OWORD *)(v8 + 98) = *(_OWORD *)v24;
  *(_OWORD *)(v8 + 102) = v12;
  long long v13 = v25;
  *(_OWORD *)(v8 + 106) = *(_OWORD *)&v24[32];
  *(_OWORD *)(v8 + 110) = v13;
  double v14 = nw_connection_copy_parameters(a3);
  uint64_t v15 = nw_parameters_copy_local_endpoint(v14);
  if (nw_endpoint_get_address(v15)) {
    SAToIPPORT();
  }
  nw_release(v15);
  nw_release(v14);
  pthread_mutex_init((pthread_mutex_t *)(v8 + 28), 0);
  pthread_cond_init((pthread_cond_t *)(v8 + 44), 0);
  pthread_mutex_init((pthread_mutex_t *)(v8 + 60), 0);
  pthread_cond_init((pthread_cond_t *)(v8 + 76), 0);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v16 = VRTraceErrorLogLevelToCSTR();
    CFDictionaryRef v17 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v18 = *v8;
      unsigned int v19 = v8[5];
      *(_DWORD *)int v24 = 136316162;
      *(void *)&v24[4] = v16;
      *(_WORD *)&v24[12] = 2080;
      *(void *)&v24[14] = "VTP_SocketWithNWConnection";
      *(_WORD *)&unsigned char v24[22] = 1024;
      *(_DWORD *)&v24[24] = 1044;
      *(_WORD *)&v24[28] = 1024;
      *(_DWORD *)&v24[30] = v18;
      *(_WORD *)&v24[34] = 1024;
      *(_DWORD *)&v24[36] = v19;
      _os_log_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d new vfd=%d->fd=%d, and add to list", v24, 0x28u);
    }
  }
  uint64_t v20 = *(void *)(v6 + 5576);
  if (v20)
  {
    do
    {
      uint64_t v21 = v20;
      uint64_t v20 = *(void *)(v20 + 352);
    }
    while (v20);
    __int16 v22 = (void *)(v21 + 352);
  }
  else
  {
    __int16 v22 = (void *)(v6 + 5576);
  }
  *__int16 v22 = v8;
  pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 5376));
  CheckOutHandleDebug();
  return *v8;
}

uint64_t VTP_GetVFD(pthread_mutex_t *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = a1 + 66;
  pthread_mutex_lock(a1 + 66);
  uint64_t v3 = -924;
  uint64_t v4 = a1;
  while (a1[106].__opaque[v3 + 44])
  {
    uint64_t v4 = (pthread_mutex_t *)((char *)v4 + 8);
    if (__CFADD__(v3++, 1))
    {
      pthread_mutex_unlock(v2);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_GetVFD_cold_1();
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  uint64_t v7 = *(const void **)&v4[106].__opaque[48];
  uint64_t v8 = (uint64_t)&a1[92].__opaque[v3 + 16];
  if (v7) {
    CFRelease(v7);
  }
  *(void *)&v4[106].__opaque[48] = 0;
  *(void *)&v4[222].__opaque[16] = 0xFFFFFFFFLL;
  *(unsigned char *)(v8 + 924) = 1;
  pthread_mutex_unlock(v2);
  return (v3 + 1024);
}

uint64_t VTP_DuplicateVFD(int a1)
{
  v12[65] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = 0;
  int v9 = &v8;
  uint64_t v10 = 0x22810000000;
  bzero(v12, 0x208uLL);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = __VTP_DuplicateVFD_block_invoke;
  v7[3] = &unk_1E6DB78B8;
  v7[4] = &v8;
  uint64_t v2 = CheckInHandleDebug();
  uint64_t v3 = v2;
  if (v2)
  {
    VTP_ProcessVFD(v2, a1, 0, (uint64_t)v7);
    if (*((_DWORD *)v9 + 13) == -1)
    {
      *__error() = 9;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_DuplicateVFD_cold_2();
        }
      }
      uint64_t v4 = 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v4 = _VTP_SocketWithRealSocketFromFVDList(v3, (uint64_t)(v9 + 4));
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 5376));
      uint64_t v5 = v3 + 4 * *((int *)v9 + 13);
      --*(_DWORD *)(v5 + 128);
      pthread_rwlock_unlock((pthread_rwlock_t *)(v3 + 5376));
    }
    CheckOutHandleDebug();
  }
  else
  {
    *__error() = 13;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_DuplicateVFD_cold_1();
      }
    }
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  _Block_object_dispose(&v8, 8);
  return v4;
}

void sub_1E219268C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

uint64_t VTP_ProcessVFD(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v7 = (pthread_rwlock_t *)(a1 + 5376);
  uint64_t v8 = (pthread_rwlock_t *)(a1 + 5376);
  if (a3) {
    pthread_rwlock_rdlock(v8);
  }
  else {
    pthread_rwlock_wrlock(v8);
  }
  uint64_t v9 = *(void *)(a1 + 5576);
  if (v9)
  {
    while (*(_DWORD *)v9 != a2)
    {
      uint64_t v9 = *(void *)(v9 + 352);
      if (!v9) {
        goto LABEL_9;
      }
    }
    (*(void (**)(uint64_t, uint64_t))(a4 + 16))(a4, a1);
  }
LABEL_9:

  return pthread_rwlock_unlock(v7);
}

uint64_t _VTP_SocketWithRealSocketFromFVDList(uint64_t a1, uint64_t a2)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    *__error() = 22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if (VRTraceIsOSFaultDisabled())
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VTP_SocketWithRealSocketFromFVDList_cold_1();
        }
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
      {
        _VTP_SocketWithRealSocketFromFVDList_cold_2();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = (unsigned int *)malloc_type_calloc(1uLL, 0x208uLL, 0x10B204038ABB4E5uLL);
  if (!v4)
  {
    *__error() = 12;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if (VRTraceIsOSFaultDisabled())
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VTP_SocketWithRealSocketFromFVDList_cold_3();
        }
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
      {
        _VTP_SocketWithRealSocketFromFVDList_cold_4();
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = v4;
  unsigned int VFD = VTP_GetVFD((pthread_mutex_t *)a1);
  unsigned int *v5 = VFD;
  if (VFD == -1)
  {
    *__error() = 24;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VTP_SocketWithRealSocketFromFVDList_cold_5();
      }
    }
    goto LABEL_27;
  }
  *(void *)(v5 + 1) = *(void *)(a2 + 4);
  v5[3] = *(_DWORD *)(a2 + 12);
  uint64_t v7 = (int *)(v5 + 5);
  *((unsigned char *)v5 + 24) = 0;
  v5[7] = 0;
  v5[56] = 0;
  *((void *)v5 + 45) = 0xFFFFFFFFLL;
  *((void *)v5 + 2) = 0xFFFFFFFF00000001;
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 5376));
  if (*(_DWORD *)(a2 + 12) == 17)
  {
    int v8 = *(_DWORD *)(a2 + 20);
    if (v8 == -1)
    {
      int v11 = socket(*(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 8), 17);
      *uint64_t v7 = v11;
      if (v11 == -1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VTP_SocketWithRealSocketFromFVDList_cold_6();
          }
        }
        pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 5376));
        VTP_ReleaseVFD((pthread_mutex_t *)a1, *v5);
        goto LABEL_27;
      }
      if (v11 >= 1025)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VTP_SocketWithRealSocketFromFVDList_cold_7();
          }
        }
        close(v5[5]);
        pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 5376));
        VTP_ReleaseVFD((pthread_mutex_t *)a1, *v5);
        uint64_t v9 = __error();
        int v10 = 24;
        goto LABEL_17;
      }
      ++*(_DWORD *)(a1 + 4 * v11 + 128);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v19 = VRTraceErrorLogLevelToCSTR();
        uint64_t v20 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v21 = *v7;
          int v22 = *(_DWORD *)(a1 + 4 * v21 + 128);
          *(_DWORD *)buf = 136316162;
          *(void *)&uint8_t buf[4] = v19;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "_VTP_SocketWithRealSocketFromFVDList";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 1108;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v21;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v22;
          _os_log_impl(&dword_1E1EA4000, v20, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d fd=%d increase. RefCount=%d", buf, 0x28u);
        }
      }
    }
    else
    {
      if (v8 >= 1025)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VTP_SocketWithRealSocketFromFVDList_cold_8();
          }
        }
        pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 5376));
        VTP_ReleaseVFD((pthread_mutex_t *)a1, *v5);
        uint64_t v9 = __error();
        int v10 = 9;
LABEL_17:
        *uint64_t v9 = v10;
LABEL_27:
        free(v5);
        return 0xFFFFFFFFLL;
      }
      v5[5] = v8;
      *((unsigned char *)v5 + 24) = 1;
      ++*(_DWORD *)(a1 + 4 * v8 + 128);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v12 = VRTraceErrorLogLevelToCSTR();
        long long v13 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = *v7;
          int v15 = *(_DWORD *)(a1 + 4 * v14 + 128);
          *(_DWORD *)buf = 136316162;
          *(void *)&uint8_t buf[4] = v12;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "_VTP_SocketWithRealSocketFromFVDList";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 1119;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v14;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v15;
          _os_log_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d fd=%d increase. RefCount=%d", buf, 0x28u);
        }
      }
      *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v48 = v16;
      long long v49 = v16;
      long long v46 = v16;
      long long v47 = v16;
      *(_OWORD *)&uint8_t buf[32] = v16;
      long long v45 = v16;
      *(_OWORD *)buf = v16;
      *(_OWORD *)&buf[16] = v16;
      socklen_t v43 = 128;
      getsockname(v5[5], (sockaddr *)buf, &v43);
      SAToIPPORT();
      int v17 = *(_DWORD *)(a1 + 24);
      if (v17 != -1)
      {
        close(v17);
        *(_DWORD *)(a1 + 24) = -1;
      }
    }
  }
  int v42 = 1;
  setsockopt(*v7, 0xFFFF, 4130, &v42, 4u);
  int v41 = 1;
  int v23 = *v7;
  if (*(_DWORD *)(a2 + 4) == 2)
  {
    setsockopt(v23, 0, 7, &v41, 4u);
    int v24 = *v7;
    int v25 = 0;
    int v26 = 20;
  }
  else
  {
    setsockopt(v23, 41, 27, &v41, 4u);
    int v24 = *v7;
    int v25 = 41;
    int v26 = 61;
  }
  setsockopt(v24, v25, v26, &v41, 4u);
  pthread_mutex_init((pthread_mutex_t *)(v5 + 28), 0);
  pthread_cond_init((pthread_cond_t *)(v5 + 44), 0);
  pthread_mutex_init((pthread_mutex_t *)(v5 + 60), 0);
  pthread_cond_init((pthread_cond_t *)(v5 + 76), 0);
  long long v27 = *(_OWORD *)(a2 + 440);
  long long v29 = *(_OWORD *)(a2 + 392);
  long long v28 = *(_OWORD *)(a2 + 408);
  *(_OWORD *)(v5 + 106) = *(_OWORD *)(a2 + 424);
  *(_OWORD *)(v5 + 110) = v27;
  *(_OWORD *)(v5 + 98) = v29;
  *(_OWORD *)(v5 + 102) = v28;
  long long v31 = *(_OWORD *)(a2 + 472);
  long long v30 = *(_OWORD *)(a2 + 488);
  long long v32 = *(_OWORD *)(a2 + 456);
  *((void *)v5 + 63) = *(void *)(a2 + 504);
  *(_OWORD *)(v5 + 118) = v31;
  *(_OWORD *)(v5 + 122) = v30;
  *(_OWORD *)(v5 + 114) = v32;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v33 = VRTraceErrorLogLevelToCSTR();
    __int16 v34 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v35 = *v5;
      unsigned int v36 = v5[5];
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = v33;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "_VTP_SocketWithRealSocketFromFVDList";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&unsigned char buf[24] = 1163;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v35;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = v36;
      _os_log_impl(&dword_1E1EA4000, v34, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d new vfd=%d->fd=%d, and add to list", buf, 0x28u);
    }
  }
  uint64_t v37 = *(void *)(a1 + 5576);
  if (v37)
  {
    do
    {
      uint64_t v38 = v37;
      uint64_t v37 = *(void *)(v37 + 352);
    }
    while (v37);
    unsigned int v39 = (void *)(v38 + 352);
  }
  else
  {
    unsigned int v39 = (void *)(a1 + 5576);
  }
  void *v39 = v5;
  uint64_t v18 = *v5;
  pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 5376));
  return v18;
}

uint64_t VTP_SocketForIDS()
{
  return VTP_SocketForIDSWithFileDescriptor(-2, 0);
}

uint64_t VTP_SocketForIDSWithFileDescriptor(int a1, uint64_t a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = CheckInHandleDebug();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SocketForIDSWithFileDescriptor_cold_1();
      }
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  if (a1 >= 1025)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SocketForIDSWithFileDescriptor_cold_3();
      }
    }
    int v24 = __error();
    uint64_t v6 = 0;
    int v25 = 24;
    goto LABEL_31;
  }
  uint64_t v5 = v4;
  uint64_t v6 = (unsigned int *)malloc_type_calloc(1uLL, 0x208uLL, 0x10B204038ABB4E5uLL);
  if (!v6)
  {
    int v24 = __error();
    int v25 = 12;
LABEL_31:
    *int v24 = v25;
    goto LABEL_32;
  }
  unsigned int VFD = VTP_GetVFD((pthread_mutex_t *)v5);
  unsigned int *v6 = VFD;
  if (VFD == -1)
  {
    *__error() = 24;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SocketForIDSWithFileDescriptor_cold_4();
      }
    }
LABEL_32:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3
      && (VRTraceErrorLogLevelToCSTR(), os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)))
    {
      VTP_SocketForIDSWithFileDescriptor_cold_2();
      if (!v6) {
        goto LABEL_36;
      }
    }
    else if (!v6)
    {
LABEL_36:
      CheckOutHandleDebug();
      return 0xFFFFFFFFLL;
    }
    free(v6);
    goto LABEL_36;
  }
  v6[2] = 2;
  *((unsigned char *)v6 + 24) = 1;
  v6[7] = 0;
  v6[56] = 0;
  *((void *)v6 + 45) = 0xFFFFFFFFLL;
  v6[4] = 1;
  v6[5] = a1;
  if (a2)
  {
    VCSDInfoConstructWithDatagramChannel((uint64_t)[+[VCDatagramChannelManager sharedInstance] datagramChannelWithChannelToken:a2], 0, 0, 0, (uint64_t)v26);
    long long v8 = v29;
    *(_OWORD *)(v6 + 114) = v28;
    *(_OWORD *)(v6 + 118) = v8;
    *(_OWORD *)(v6 + 122) = v30;
    *((void *)v6 + 63) = v31;
    long long v9 = *(_OWORD *)&v26[16];
    *(_OWORD *)(v6 + 98) = *(_OWORD *)v26;
    *(_OWORD *)(v6 + 102) = v9;
    long long v10 = v27;
    *(_OWORD *)(v6 + 106) = *(_OWORD *)&v26[32];
    *(_OWORD *)(v6 + 110) = v10;
  }
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v5 + 5376));
  int v11 = *(_DWORD *)(v5 + 24);
  if (v11 != -1)
  {
    close(v11);
    *(_DWORD *)(v5 + 24) = -1;
  }
  pthread_mutex_init((pthread_mutex_t *)(v6 + 28), 0);
  pthread_cond_init((pthread_cond_t *)(v6 + 44), 0);
  pthread_mutex_init((pthread_mutex_t *)(v6 + 60), 0);
  pthread_cond_init((pthread_cond_t *)(v6 + 76), 0);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v12 = VRTraceErrorLogLevelToCSTR();
    long long v13 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v14 = *v6;
      unsigned int v15 = v6[5];
      *(_DWORD *)int v26 = 136316162;
      *(void *)&v26[4] = v12;
      *(_WORD *)&v26[12] = 2080;
      *(void *)&v26[14] = "VTP_SocketForIDSWithFileDescriptor";
      *(_WORD *)&unsigned char v26[22] = 1024;
      *(_DWORD *)&v26[24] = 1301;
      *(_WORD *)&v26[28] = 1024;
      *(_DWORD *)&v26[30] = v14;
      *(_WORD *)&v26[34] = 1024;
      *(_DWORD *)&v26[36] = v15;
      _os_log_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d new vfd=%d->fd=%d, and add to list", v26, 0x28u);
    }
  }
  uint64_t v16 = *(void *)(v5 + 5576);
  if (v16)
  {
    do
    {
      uint64_t v17 = v16;
      uint64_t v16 = *(void *)(v16 + 352);
    }
    while (v16);
    uint64_t v18 = (void *)(v17 + 352);
  }
  else
  {
    uint64_t v18 = (void *)(v5 + 5576);
  }
  void *v18 = v6;
  if (a1 <= 0xFFFFFFFD)
  {
    *(unsigned char *)(v5 + 40) = 1;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v20 = VRTraceErrorLogLevelToCSTR();
      uint64_t v21 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v22 = *(unsigned __int8 *)(v5 + 40);
        int v23 = *v6;
        *(_DWORD *)int v26 = 136316418;
        *(void *)&v26[4] = v20;
        *(_WORD *)&v26[12] = 2080;
        *(void *)&v26[14] = "VTP_SocketForIDSWithFileDescriptor";
        *(_WORD *)&unsigned char v26[22] = 1024;
        *(_DWORD *)&v26[24] = 1315;
        *(_WORD *)&v26[28] = 1024;
        *(_DWORD *)&v26[30] = v22;
        *(_WORD *)&v26[34] = 1024;
        *(_DWORD *)&v26[36] = v23;
        *(_WORD *)&v26[40] = 1024;
        *(_DWORD *)&v26[42] = a1;
        _os_log_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP set shouldLogFDsAtTimeout=%d with vfd=%d, fileDescriptor=%d", v26, 0x2Eu);
      }
    }
  }
  pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 5376));
  CheckOutHandleDebug();
  return *v6;
}

uint64_t VTP_SetPayloadList(int a1, int a2, const void *a3)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v6 = CheckInHandleDebug();
    if (v6)
    {
      uint64_t v7 = v6;
      long long v8 = (pthread_rwlock_t *)(v6 + 5376);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v6 + 5376));
      long long v9 = *(int **)(v7 + 5576);
      if (!v9)
      {
LABEL_6:
        pthread_rwlock_unlock(v8);
        CheckOutHandleDebug();
        long long v10 = __error();
        uint64_t result = 0;
        *long long v10 = 9;
        return result;
      }
      while (*v9 != a1)
      {
        long long v9 = (int *)*((void *)v9 + 44);
        if (!v9) {
          goto LABEL_6;
        }
      }
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      *(_OWORD *)__s = 0u;
      long long v35 = 0u;
      uint64_t v12 = (int *)malloc_type_calloc(v9[10] + (uint64_t)a2, 4uLL, 0x100004052888210uLL);
      if (v12)
      {
        long long v13 = v12;
        int v14 = v9[10];
        if (v14)
        {
          unsigned int v15 = (const void *)*((void *)v9 + 4);
          if (v15)
          {
            memcpy(v12, v15, 4 * v14);
            free(*((void **)v9 + 4));
            int v14 = v9[10];
          }
        }
        memcpy(&v13[v14], a3, 4 * a2);
        int v16 = v9[10] + a2;
        v9[10] = v16;
        *((void *)v9 + 4) = v13;
        if (v16 >= 1)
        {
          do
          {
            if (strlen(__s) > 0x77) {
              break;
            }
            int v17 = *v13++;
            __sprintf_chk(__s, 0, 0x80uLL, "%s %i,", __s, v17);
          }
          while ((unint64_t)v13 < *((void *)v9 + 4) + 4 * v9[10]);
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v18 = VRTraceErrorLogLevelToCSTR();
          uint64_t v19 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            int v20 = *v9;
            int v21 = v9[10];
            *(_DWORD *)buf = 136316418;
            uint64_t v23 = v18;
            __int16 v24 = 2080;
            int v25 = "VTP_SetPayloadList";
            __int16 v26 = 1024;
            int v27 = 1376;
            __int16 v28 = 1024;
            int v29 = v20;
            __int16 v30 = 1024;
            int v31 = v21;
            __int16 v32 = 2080;
            uint64_t v33 = __s;
            _os_log_impl(&dword_1E1EA4000, v19, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_SetPayloadList for vfd=%d: nPlList=%i payloads=%s", buf, 0x32u);
          }
        }
        pthread_rwlock_unlock(v8);
        CheckOutHandleDebug();
        return 0;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
      {
        VRTraceErrorLogLevelToCSTR();
        if (VRTraceIsOSFaultDisabled())
        {
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VTP_SetPayloadList_cold_2();
          }
        }
        else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
        {
          VTP_SetPayloadList_cold_3();
        }
      }
      pthread_rwlock_unlock(v8);
      *__error() = 12;
      CheckOutHandleDebug();
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_SetPayloadList_cold_1();
        }
      }
      *__error() = 13;
    }
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t VTP_SetSocketMode(int a1, int a2)
{
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SetSocketMode_cold_1();
      }
    }
    long long v10 = __error();
    int v11 = 22;
    goto LABEL_15;
  }
  uint64_t v4 = CheckInHandleDebug();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SetSocketMode_cold_2();
      }
    }
    long long v10 = __error();
    int v11 = 13;
LABEL_15:
    *long long v10 = v11;
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = v4;
  uint64_t v6 = (pthread_rwlock_t *)(v4 + 5376);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
  uint64_t v7 = *(void *)(v5 + 5576);
  if (v7)
  {
    while (*(_DWORD *)v7 != a1)
    {
      uint64_t v7 = *(void *)(v7 + 352);
      if (!v7) {
        goto LABEL_6;
      }
    }
    int v9 = 0;
    uint64_t v8 = 0;
    *(_DWORD *)(v7 + 16) = a2;
  }
  else
  {
LABEL_6:
    uint64_t v8 = 0xFFFFFFFFLL;
    int v9 = 1;
  }
  pthread_rwlock_unlock(v6);
  CheckOutHandleDebug();
  if (v9) {
    *__error() = 9;
  }
  return v8;
}

uint64_t VTP_SetPktType(int a1, int a2)
{
  uint64_t v4 = CheckInHandleDebug();
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = (pthread_rwlock_t *)(v4 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
    uint64_t v7 = *(void *)(v5 + 5576);
    if (v7)
    {
      while (*(_DWORD *)v7 != a1)
      {
        uint64_t v7 = *(void *)(v7 + 352);
        if (!v7) {
          goto LABEL_5;
        }
      }
      int v9 = 0;
      uint64_t v8 = 0;
      *(_DWORD *)(v7 + 28) = a2;
    }
    else
    {
LABEL_5:
      uint64_t v8 = 0xFFFFFFFFLL;
      int v9 = 1;
    }
    pthread_rwlock_unlock(v6);
    CheckOutHandleDebug();
    if (v9) {
      *__error() = 9;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SetPktType_cold_1();
      }
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  return v8;
}

uint64_t VTP_AddPktType(int a1, int a2)
{
  uint64_t v4 = CheckInHandleDebug();
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = (pthread_rwlock_t *)(v4 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
    uint64_t v7 = *(void *)(v5 + 5576);
    if (v7)
    {
      while (*(_DWORD *)v7 != a1)
      {
        uint64_t v7 = *(void *)(v7 + 352);
        if (!v7) {
          goto LABEL_5;
        }
      }
      int v9 = 0;
      uint64_t v8 = 0;
      *(_DWORD *)(v7 + 28) |= a2;
    }
    else
    {
LABEL_5:
      uint64_t v8 = 0xFFFFFFFFLL;
      int v9 = 1;
    }
    pthread_rwlock_unlock(v6);
    CheckOutHandleDebug();
    if (v9) {
      *__error() = 9;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_AddPktType_cold_1();
      }
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  return v8;
}

uint64_t VTP_RemovePktType(int a1, int a2)
{
  uint64_t v4 = CheckInHandleDebug();
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = (pthread_rwlock_t *)(v4 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
    uint64_t v7 = *(void *)(v5 + 5576);
    if (v7)
    {
      while (*(_DWORD *)v7 != a1)
      {
        uint64_t v7 = *(void *)(v7 + 352);
        if (!v7) {
          goto LABEL_5;
        }
      }
      int v9 = 0;
      uint64_t v8 = 0;
      *(_DWORD *)(v7 + 28) &= ~a2;
    }
    else
    {
LABEL_5:
      uint64_t v8 = 0xFFFFFFFFLL;
      int v9 = 1;
    }
    pthread_rwlock_unlock(v6);
    CheckOutHandleDebug();
    if (v9) {
      *__error() = 9;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_RemovePktType_cold_1();
      }
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  return v8;
}

uint64_t VTP_Getsockname(int a1, sockaddr *a2, socklen_t *a3)
{
  uint64_t v6 = CheckInHandleDebug();
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = (pthread_rwlock_t *)(v6 + 5376);
    pthread_rwlock_rdlock((pthread_rwlock_t *)(v6 + 5376));
    uint64_t v9 = *(void *)(v7 + 5576);
    if (v9)
    {
      while (*(_DWORD *)v9 != a1)
      {
        uint64_t v9 = *(void *)(v9 + 352);
        if (!v9) {
          goto LABEL_5;
        }
      }
      if (*(_DWORD *)(v9 + 392) == 5 && (uint64_t v12 = *(NSObject **)(v9 + 400)) != 0)
      {
        long long v13 = nw_connection_copy_endpoint(v12);
        address = nw_endpoint_get_address(v13);
        if (address)
        {
          unsigned int v15 = address;
          memcpy(a2, address, address->sa_len);
          uint64_t v10 = 0;
          *a3 = v15->sa_len;
        }
        else
        {
          uint64_t v10 = 0xFFFFFFFFLL;
        }
        nw_release(v13);
      }
      else
      {
        uint64_t v10 = getsockname(*(_DWORD *)(v9 + 20), a2, a3);
      }
      int v11 = 0;
    }
    else
    {
LABEL_5:
      uint64_t v10 = 0xFFFFFFFFLL;
      int v11 = 1;
    }
    pthread_rwlock_unlock(v8);
    CheckOutHandleDebug();
    if (v11) {
      *__error() = 9;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Getsockname_cold_1();
      }
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  return v10;
}

uint64_t _VTP_SetSSRC(int a1, int a2, uint64_t a3)
{
  uint64_t v6 = CheckInHandleDebug();
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = (pthread_rwlock_t *)(v6 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v6 + 5376));
    uint64_t v9 = *(void *)(v7 + 5576);
    if (v9)
    {
      while (*(_DWORD *)v9 != a1 || (*(unsigned char *)(v9 + 28) & 0xF0) == 0)
      {
        uint64_t v9 = *(void *)(v9 + 352);
        if (!v9) {
          goto LABEL_6;
        }
      }
      int v10 = 0;
      if (a3)
      {
        a3 = 0;
        *(_DWORD *)(v9 + 48) = a2;
        *(unsigned char *)(v9 + 27) = 1;
      }
      else
      {
        *(_DWORD *)(v9 + 44) = a2;
        *(unsigned char *)(v9 + 26) = 1;
      }
    }
    else
    {
LABEL_6:
      a3 = 0xFFFFFFFFLL;
      int v10 = 1;
    }
    pthread_rwlock_unlock(v8);
    CheckOutHandleDebug();
    if (v10) {
      *__error() = 9;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VTP_SetSSRC_cold_1();
      }
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  return a3;
}

uint64_t VTP_SetRemoteSSRC(int a1, int a2)
{
  return _VTP_SetSSRC(a1, a2, 0);
}

uint64_t VTP_SetLocalSSRC(int a1, int a2)
{
  return _VTP_SetSSRC(a1, a2, 1);
}

uint64_t VTP_SetTransportSessionID(int a1, int a2)
{
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SetTransportSessionID_cold_1();
      }
    }
    int v10 = __error();
    int v11 = 22;
    goto LABEL_15;
  }
  uint64_t v4 = CheckInHandleDebug();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SetTransportSessionID_cold_2();
      }
    }
    int v10 = __error();
    int v11 = 13;
LABEL_15:
    *int v10 = v11;
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = v4;
  uint64_t v6 = (pthread_rwlock_t *)(v4 + 5376);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
  uint64_t v7 = *(void *)(v5 + 5576);
  if (v7)
  {
    while (*(_DWORD *)v7 != a1)
    {
      uint64_t v7 = *(void *)(v7 + 352);
      if (!v7) {
        goto LABEL_6;
      }
    }
    int v9 = 0;
    uint64_t v8 = 0;
    *(_DWORD *)(v7 + 56) = a2;
  }
  else
  {
LABEL_6:
    uint64_t v8 = 0xFFFFFFFFLL;
    int v9 = 1;
  }
  pthread_rwlock_unlock(v6);
  CheckOutHandleDebug();
  if (v9) {
    *__error() = 9;
  }
  return v8;
}

uint64_t VTP_SetDSCPTag(int a1, int a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = CheckInHandleDebug();
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (!v4)
  {
    if (ErrorLogLevelForModule >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SetDSCPTag_cold_1();
      }
    }
    uint64_t v10 = 0xFFFFFFFFLL;
    int v12 = 13;
    goto LABEL_20;
  }
  if (ErrorLogLevelForModule >= 7)
  {
    uint64_t v6 = VRTraceErrorLogLevelToCSTR();
    uint64_t v7 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v16 = 136315906;
      uint64_t v17 = v6;
      __int16 v18 = 2080;
      uint64_t v19 = "VTP_SetDSCPTag";
      __int16 v20 = 1024;
      int v21 = 1639;
      __int16 v22 = 1024;
      int v23 = a2;
      _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Set dscp value=%d", (uint8_t *)&v16, 0x22u);
    }
  }
  uint64_t v8 = (pthread_rwlock_t *)(v4 + 5376);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
  uint64_t v9 = *(void *)(v4 + 5576);
  if (v9)
  {
    while (*(_DWORD *)v9 != a1)
    {
      uint64_t v9 = *(void *)(v9 + 352);
      if (!v9) {
        goto LABEL_8;
      }
    }
    long long v13 = *(void **)(v9 + 512);
    if (v13) {
      nw_release(v13);
    }
    nw_protocol_metadata_t metadata = nw_ip_create_metadata();
    *(void *)(v9 + 512) = metadata;
    if (metadata)
    {
      nw_ip_metadata_set_dscp_value();
      int v11 = 0;
      uint64_t v10 = 0;
    }
    else
    {
      int v11 = 0;
      *__error() = 12;
      uint64_t v10 = 0xFFFFFFFFLL;
    }
  }
  else
  {
LABEL_8:
    uint64_t v10 = 0xFFFFFFFFLL;
    int v11 = 1;
  }
  pthread_rwlock_unlock(v8);
  CheckOutHandleDebug();
  if (v11)
  {
    int v12 = 9;
LABEL_20:
    *__error() = v12;
  }
  return v10;
}

uint64_t _VTP_GetNWContentMetaData(int a1, void *a2)
{
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VTP_GetNWContentMetaData_cold_1();
      }
    }
    uint64_t v10 = __error();
    int v11 = 22;
    goto LABEL_15;
  }
  uint64_t v4 = CheckInHandleDebug();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VTP_GetNWContentMetaData_cold_2();
      }
    }
    uint64_t v10 = __error();
    int v11 = 13;
LABEL_15:
    *uint64_t v10 = v11;
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = v4;
  uint64_t v6 = (pthread_rwlock_t *)(v4 + 5376);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v4 + 5376));
  uint64_t v7 = *(void *)(v5 + 5576);
  if (v7)
  {
    while (*(_DWORD *)v7 != a1)
    {
      uint64_t v7 = *(void *)(v7 + 352);
      if (!v7) {
        goto LABEL_6;
      }
    }
    int v9 = 0;
    uint64_t v8 = 0;
    *a2 = *(void *)(v7 + 512);
  }
  else
  {
LABEL_6:
    uint64_t v8 = 0xFFFFFFFFLL;
    int v9 = 1;
  }
  pthread_rwlock_unlock(v6);
  CheckOutHandleDebug();
  if (v9) {
    *__error() = 9;
  }
  return v8;
}

uint64_t VTP_GetTransportSessionID(int a1, _DWORD *a2)
{
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_GetTransportSessionID_cold_1();
      }
    }
    uint64_t v10 = __error();
    int v11 = 22;
    goto LABEL_15;
  }
  uint64_t v4 = CheckInHandleDebug();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_GetTransportSessionID_cold_2();
      }
    }
    uint64_t v10 = __error();
    int v11 = 13;
LABEL_15:
    *uint64_t v10 = v11;
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = v4;
  uint64_t v6 = (pthread_rwlock_t *)(v4 + 5376);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v4 + 5376));
  uint64_t v7 = *(void *)(v5 + 5576);
  if (v7)
  {
    while (*(_DWORD *)v7 != a1)
    {
      uint64_t v7 = *(void *)(v7 + 352);
      if (!v7) {
        goto LABEL_6;
      }
    }
    int v9 = 0;
    uint64_t v8 = 0;
    *a2 = *(_DWORD *)(v7 + 56);
  }
  else
  {
LABEL_6:
    uint64_t v8 = 0xFFFFFFFFLL;
    int v9 = 1;
  }
  pthread_rwlock_unlock(v6);
  CheckOutHandleDebug();
  if (v9) {
    *__error() = 9;
  }
  return v8;
}

uint64_t VTP_Setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  uint64_t v10 = CheckInHandleDebug();
  if (v10)
  {
    uint64_t v11 = v10;
    int v12 = (pthread_rwlock_t *)(v10 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v10 + 5376));
    uint64_t v13 = *(void *)(v11 + 5576);
    if (v13)
    {
      while (*(_DWORD *)v13 != a1)
      {
        uint64_t v13 = *(void *)(v13 + 352);
        if (!v13) {
          goto LABEL_5;
        }
      }
      if (a2 == 258 && a3 == 1 || *(_DWORD *)(v13 + 392) == 5 && *(void *)(v13 + 400))
      {
        int v15 = 0;
        uint64_t v14 = 0;
      }
      else
      {
        uint64_t v14 = setsockopt(*(_DWORD *)(v13 + 20), a2, a3, a4, a5);
        int v15 = 0;
      }
    }
    else
    {
LABEL_5:
      uint64_t v14 = 0xFFFFFFFFLL;
      int v15 = 1;
    }
    pthread_rwlock_unlock(v12);
    CheckOutHandleDebug();
    if (v15) {
      *__error() = 9;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Setsockopt_cold_1();
      }
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  return v14;
}

uint64_t VTP_SetSourceDestinationWithToken(int a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = CheckInHandleDebug();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SetSourceDestinationWithToken_cold_1();
      }
    }
    uint64_t v8 = __error();
    int v9 = 13;
    goto LABEL_10;
  }
  uint64_t v5 = v4;
  uint64_t v6 = (pthread_rwlock_t *)(v4 + 5376);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v4 + 5376));
  uint64_t v7 = *(void *)(v5 + 5576);
  if (!v7)
  {
LABEL_5:
    pthread_rwlock_unlock(v6);
    CheckOutHandleDebug();
    uint64_t v8 = __error();
    int v9 = 9;
LABEL_10:
    *uint64_t v8 = v9;
    return 0xFFFFFFFFLL;
  }
  while (*(_DWORD *)v7 != a1)
  {
    uint64_t v7 = *(void *)(v7 + 352);
    if (!v7) {
      goto LABEL_5;
    }
  }
  VCSDInfoConstructWithDatagramChannel((uint64_t)[+[VCDatagramChannelManager sharedInstance] datagramChannelWithChannelToken:a2], 0, 0, 0, (uint64_t)v14);
  long long v11 = v14[5];
  *(_OWORD *)(v7 + 456) = v14[4];
  *(_OWORD *)(v7 + 472) = v11;
  *(_OWORD *)(v7 + 488) = v14[6];
  *(void *)(v7 + 504) = v15;
  long long v12 = v14[1];
  *(_OWORD *)(v7 + 392) = v14[0];
  *(_OWORD *)(v7 + 408) = v12;
  long long v13 = v14[3];
  *(_OWORD *)(v7 + 424) = v14[2];
  *(_OWORD *)(v7 + 440) = v13;
  pthread_rwlock_unlock(v6);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VTP_SetSourceDestinationWithIPPort(int a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = CheckInHandleDebug();
  if (!v2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SetSourceDestinationWithIPPort_cold_1();
      }
    }
    uint64_t v6 = __error();
    int v7 = 13;
    goto LABEL_10;
  }
  uint64_t v3 = v2;
  uint64_t v4 = (pthread_rwlock_t *)(v2 + 5376);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v2 + 5376));
  uint64_t v5 = *(void *)(v3 + 5576);
  if (!v5)
  {
LABEL_5:
    pthread_rwlock_unlock(v4);
    CheckOutHandleDebug();
    uint64_t v6 = __error();
    int v7 = 9;
LABEL_10:
    int *v6 = v7;
    return 0xFFFFFFFFLL;
  }
  while (*(_DWORD *)v5 != a1)
  {
    uint64_t v5 = *(void *)(v5 + 352);
    if (!v5) {
      goto LABEL_5;
    }
  }
  if (*(_DWORD *)(v5 + 392) != 5 || !*(void *)(v5 + 400))
  {
    unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v15[0] = v9;
    v15[1] = v9;
    SAToIPPORT();
    VCSDInfoConstructWithSocket(*(_DWORD *)(v5 + 20), (uint64_t)v15, (uint64_t)v13);
    long long v10 = v13[5];
    *(_OWORD *)(v5 + 456) = v13[4];
    *(_OWORD *)(v5 + 472) = v10;
    *(_OWORD *)(v5 + 488) = v13[6];
    *(void *)(v5 + 504) = v14;
    long long v11 = v13[1];
    *(_OWORD *)(v5 + 392) = v13[0];
    *(_OWORD *)(v5 + 408) = v11;
    long long v12 = v13[3];
    *(_OWORD *)(v5 + 424) = v13[2];
    *(_OWORD *)(v5 + 440) = v12;
  }
  pthread_rwlock_unlock(v4);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VTP_Close(int a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = CheckInHandleDebug();
  if (!v2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Close_cold_1();
      }
    }
    uint64_t v9 = 0xFFFFFFFFLL;
    int v10 = 13;
    goto LABEL_19;
  }
  uint64_t v3 = v2;
  uint64_t v4 = (pthread_rwlock_t *)(v2 + 5376);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v2 + 5376));
  uint64_t v5 = *(void *)(v3 + 5576);
  if (!v5) {
    goto LABEL_13;
  }
  if (*(_DWORD *)v5 != a1)
  {
    while (1)
    {
      uint64_t v7 = v5;
      uint64_t v5 = *(void *)(v5 + 352);
      if (!v5) {
        break;
      }
      if (*(_DWORD *)v5 == a1)
      {
        uint64_t v6 = (void *)(v7 + 352);
        goto LABEL_8;
      }
    }
LABEL_13:
    int v8 = 1;
    goto LABEL_14;
  }
  uint64_t v6 = (void *)(v3 + 5576);
LABEL_8:
  VTP_CloseOneVFDList(v3, (int *)v5);
  void *v6 = *(void *)(v5 + 352);
  free((void *)v5);
  int v8 = 0;
LABEL_14:
  pthread_rwlock_unlock(v4);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v11 = VRTraceErrorLogLevelToCSTR();
    long long v12 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v14 = 136315906;
      uint64_t v15 = v11;
      __int16 v16 = 2080;
      uint64_t v17 = "VTP_Close";
      __int16 v18 = 1024;
      int v19 = 1966;
      __int16 v20 = 1024;
      int v21 = a1;
      _os_log_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d removed vfd (%d) from the list", (uint8_t *)&v14, 0x22u);
    }
  }
  CheckOutHandleDebug();
  uint64_t v9 = 0;
  if (v8)
  {
    int v10 = 9;
LABEL_19:
    *__error() = v10;
  }
  return v9;
}

uint64_t VTP_Bind(int a1, uint64_t a2, socklen_t a3)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  *(void *)&v51[16] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v50 = v6;
  *(_OWORD *)long long v51 = v6;
  uint64_t v7 = CheckInHandleDebug();
  if (!v7)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Bind_cold_1();
      }
    }
    uint64_t v11 = 0xFFFFFFFFLL;
    int v13 = 13;
    goto LABEL_18;
  }
  uint64_t v8 = v7;
  uint64_t v9 = (pthread_rwlock_t *)(v7 + 5376);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v7 + 5376));
  uint64_t v10 = *(void *)(v8 + 5576);
  if (!v10)
  {
LABEL_5:
    uint64_t v11 = 0xFFFFFFFFLL;
    int v12 = 1;
    goto LABEL_16;
  }
  while (*(_DWORD *)v10 != a1)
  {
    uint64_t v10 = *(void *)(v10 + 352);
    if (!v10) {
      goto LABEL_5;
    }
  }
  if (*(_DWORD *)(v10 + 20) == -1)
  {
    int v14 = __error();
    int v12 = 0;
    int v15 = 9;
    goto LABEL_14;
  }
  if (*(unsigned char *)(v10 + 24) == 1)
  {
    int v14 = __error();
    int v12 = 0;
    int v15 = 22;
LABEL_14:
    *int v14 = v15;
LABEL_15:
    uint64_t v11 = 0xFFFFFFFFLL;
    goto LABEL_16;
  }
  SAToIPPORT();
  int v17 = *(unsigned __int16 *)&v51[20];
  if (*(_DWORD *)(v10 + 16) == 2)
  {
    uint64_t v18 = *(void *)(v8 + 5576);
    if (v18)
    {
      uint64_t v19 = 0;
      while (1)
      {
        if (v10 != v18
          && *(_DWORD *)(v10 + 4) == *(_DWORD *)(v18 + 4)
          && *(_DWORD *)(v10 + 8) == *(_DWORD *)(v18 + 8)
          && *(_DWORD *)(v10 + 12) == *(_DWORD *)(v18 + 12)
          && *(_DWORD *)(v18 + 16) == 2
          && (v50 & 1) == (*(_DWORD *)(v18 + 60) & 1))
        {
          if (v50)
          {
            if (*(void *)&v51[4] == *(void *)(v18 + 80) && *(void *)&v51[12] == *(void *)(v18 + 88))
            {
LABEL_37:
              if (!v19) {
                uint64_t v19 = v18;
              }
              if (*(unsigned __int16 *)&v51[20] == *(unsigned __int16 *)(v18 + 96) && *(unsigned char *)(v18 + 24))
              {
                _VTP_ReleaseSocket(v8, v10);
                uint64_t v37 = *(int *)(v18 + 20);
                *(_DWORD *)(v10 + 20) = v37;
                *(unsigned char *)(v10 + 24) = 1;
                ++*(_DWORD *)(v8 + 4 * v37 + 128);
                if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                {
                  uint64_t v38 = VRTraceErrorLogLevelToCSTR();
                  long long v39 = *MEMORY[0x1E4F47A50];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v40 = *(int *)(v10 + 20);
                    int v41 = *(_DWORD *)(v8 + 4 * v40 + 128);
                    *(_DWORD *)buf = 136316162;
                    *(void *)&uint8_t buf[4] = v38;
                    *(_WORD *)&buf[12] = 2080;
                    *(void *)&buf[14] = "VTP_Bind";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&unsigned char buf[24] = 2022;
                    *(_WORD *)&buf[28] = 1024;
                    *(_DWORD *)&buf[30] = v40;
                    *(_WORD *)&buf[34] = 1024;
                    *(_DWORD *)&buf[36] = v41;
                    _os_log_impl(&dword_1E1EA4000, v39, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d fd[%d] increase. RefCount[%d]", buf, 0x28u);
                  }
                }
                int v12 = 0;
                uint64_t v11 = 0;
                long long v42 = *(_OWORD *)v51;
                *(_OWORD *)(v10 + 60) = v50;
                *(_OWORD *)(v10 + 76) = v42;
                *(void *)(v10 + 92) = *(void *)&v51[16];
                goto LABEL_16;
              }
            }
          }
          else if (*(_DWORD *)&v51[4] == *(_DWORD *)(v18 + 80))
          {
            goto LABEL_37;
          }
        }
        uint64_t v18 = *(void *)(v18 + 352);
        if (!v18)
        {
          if (!v19 || !*(unsigned char *)(v19 + 24)) {
            break;
          }
          uint64_t v21 = v19;
          _VTP_ReleaseSocket(v8, v10);
          uint64_t v22 = *(int *)(v21 + 20);
          *(_DWORD *)(v10 + 20) = v22;
          *(unsigned char *)(v10 + 24) = 1;
          ++*(_DWORD *)(v8 + 4 * v22 + 128);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            uint64_t v23 = VRTraceErrorLogLevelToCSTR();
            uint64_t v24 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v25 = *(int *)(v10 + 20);
              int v26 = *(_DWORD *)(v8 + 4 * v25 + 128);
              *(_DWORD *)buf = 136316162;
              *(void *)&uint8_t buf[4] = v23;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = "VTP_Bind";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&unsigned char buf[24] = 2041;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = v25;
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = v26;
              _os_log_impl(&dword_1E1EA4000, v24, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d fd[%d] increase. RefCount[%d]", buf, 0x28u);
            }
          }
LABEL_69:
          int v12 = 0;
          uint64_t v11 = 0;
          goto LABEL_16;
        }
      }
    }
    *(_WORD *)(a2 + 2) = 4672;
    int v17 = 16402;
  }
  uint64_t v27 = bind(*(_DWORD *)(v10 + 20), (const sockaddr *)a2, a3);
  uint64_t v11 = v27;
  if (*(_DWORD *)(v10 + 16) == 2 && v27 == -1)
  {
    unsigned int v28 = 1;
    do
    {
      *(_WORD *)(a2 + 2) = bswap32(v17 - v28) >> 16;
      uint64_t v29 = bind(*(_DWORD *)(v10 + 20), (const sockaddr *)a2, a3);
      unsigned int v30 = v28 + 1;
    }
    while (v29 == -1 && v28++ < 9);
    uint64_t v11 = v29;
    if (v29 == -1 || v30 == 10)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v33 = VRTraceErrorLogLevelToCSTR();
        __int16 v34 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = v33;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "VTP_Bind";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 2060;
          _os_log_impl(&dword_1E1EA4000, v34, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d All binding tries failed. Trying a random port...\n", buf, 0x1Cu);
        }
      }
      *(_WORD *)(a2 + 2) = 0;
      uint64_t v11 = bind(*(_DWORD *)(v10 + 20), (const sockaddr *)a2, a3);
      if (v11 == -1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VTP_Bind_cold_2();
          }
        }
        int v12 = 0;
        goto LABEL_15;
      }
    }
  }
  if (!v11)
  {
    *(void *)&long long v35 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v35 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v48 = v35;
    long long v49 = v35;
    long long v46 = v35;
    long long v47 = v35;
    *(_OWORD *)&uint8_t buf[32] = v35;
    long long v45 = v35;
    *(_OWORD *)buf = v35;
    *(_OWORD *)&buf[16] = v35;
    socklen_t v43 = 128;
    *(unsigned char *)(v10 + 24) = 1;
    getsockname(*(_DWORD *)(v10 + 20), (sockaddr *)buf, &v43);
    SAToIPPORT();
    int v36 = *(_DWORD *)(v8 + 24);
    if (v36 != -1)
    {
      close(v36);
      *(_DWORD *)(v8 + 24) = -1;
    }
    goto LABEL_69;
  }
  int v12 = 0;
LABEL_16:
  pthread_rwlock_unlock(v9);
  CheckOutHandleDebug();
  if (v12)
  {
    int v13 = 9;
LABEL_18:
    *__error() = v13;
  }
  return v11;
}

void _VTP_ReleaseSocket(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(unsigned int *)(a2 + 20);
  if (v2 <= 0x3FF)
  {
    uint64_t v4 = a1 + 4 * v2;
    int v5 = *(_DWORD *)(v4 + 128);
    *(_DWORD *)(v4 + 128) = v5 - 1;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v6 = VRTraceErrorLogLevelToCSTR();
      uint64_t v7 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v8 = *(_DWORD *)(a2 + 20);
        int v18 = 136316162;
        uint64_t v19 = v6;
        __int16 v20 = 2080;
        uint64_t v21 = "_VTP_ReleaseSocket";
        __int16 v22 = 1024;
        int v23 = 624;
        __int16 v24 = 1024;
        int v25 = v8;
        __int16 v26 = 1024;
        int v27 = v5 - 1;
        _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d fd=%d decrease. RefCount=%d", (uint8_t *)&v18, 0x28u);
      }
    }
    if (v5 <= 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
        goto LABEL_14;
      }
      uint64_t v15 = VRTraceErrorLogLevelToCSTR();
      __int16 v16 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_14;
      }
      int v17 = *(_DWORD *)(a2 + 20);
      int v18 = 136316162;
      uint64_t v19 = v15;
      __int16 v20 = 2080;
      uint64_t v21 = "_VTP_ReleaseSocket";
      __int16 v22 = 1024;
      int v23 = 626;
      __int16 v24 = 1024;
      int v25 = v17;
      __int16 v26 = 1024;
      int v27 = v5 - 1;
      int v12 = " [%s] %s:%d fd=%d over released. RefCount=%d";
      int v13 = v16;
      uint32_t v14 = 40;
    }
    else
    {
      if (v5 != 1) {
        return;
      }
      close(*(_DWORD *)(a2 + 20));
      if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
        goto LABEL_14;
      }
      uint64_t v9 = VRTraceErrorLogLevelToCSTR();
      uint64_t v10 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_14;
      }
      int v11 = *(_DWORD *)(a2 + 20);
      int v18 = 136315906;
      uint64_t v19 = v9;
      __int16 v20 = 2080;
      uint64_t v21 = "_VTP_ReleaseSocket";
      __int16 v22 = 1024;
      int v23 = 630;
      __int16 v24 = 1024;
      int v25 = v11;
      int v12 = " [%s] %s:%d fd=%d closed.";
      int v13 = v10;
      uint32_t v14 = 34;
    }
    _os_log_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v18, v14);
LABEL_14:
    *(_DWORD *)(a2 + 20) = -1;
  }
}

uint64_t VTP_BindNew(int a1, uint64_t a2, socklen_t a3)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = CheckInHandleDebug();
  if (!v6)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_BindNew_cold_1();
      }
    }
    uint64_t v10 = 0xFFFFFFFFLL;
    int v12 = 13;
    goto LABEL_18;
  }
  uint64_t v7 = v6;
  int v8 = (pthread_rwlock_t *)(v6 + 5376);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v6 + 5376));
  uint64_t v9 = *(void *)(v7 + 5576);
  if (!v9)
  {
LABEL_5:
    uint64_t v10 = 0xFFFFFFFFLL;
    int v11 = 1;
    goto LABEL_16;
  }
  while (*(_DWORD *)v9 != a1)
  {
    uint64_t v9 = *(void *)(v9 + 352);
    if (!v9) {
      goto LABEL_5;
    }
  }
  int v13 = *(_DWORD *)(v9 + 20);
  if (v13 == -1)
  {
    uint32_t v14 = __error();
    int v11 = 0;
    int v15 = 9;
    goto LABEL_14;
  }
  if (*(unsigned char *)(v9 + 24) == 1)
  {
    uint32_t v14 = __error();
    int v11 = 0;
    int v15 = 22;
LABEL_14:
    *uint32_t v14 = v15;
LABEL_15:
    uint64_t v10 = 0xFFFFFFFFLL;
    goto LABEL_16;
  }
  int v17 = *(unsigned __int16 *)(a2 + 2);
  if (*(_DWORD *)(v9 + 16) == 2 && v17 == 0)
  {
    *(_WORD *)(a2 + 2) = 4416;
    int v17 = 16401;
  }
  uint64_t v19 = bind(v13, (const sockaddr *)a2, a3);
  uint64_t v10 = v19;
  if (*(_DWORD *)(v9 + 16) == 2 && v19 == -1)
  {
    unsigned int v20 = 1;
    do
    {
      *(_WORD *)(a2 + 2) = bswap32(v17 - v20) >> 16;
      uint64_t v21 = bind(*(_DWORD *)(v9 + 20), (const sockaddr *)a2, a3);
      unsigned int v22 = v20 + 1;
    }
    while (v21 == -1 && v20++ < 9);
    if (v22 == 10 || (uint64_t v10 = v21, v21 == -1))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v24 = VRTraceErrorLogLevelToCSTR();
        int v25 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = v24;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "VTP_BindNew";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 2141;
          _os_log_impl(&dword_1E1EA4000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d All binding tries failed. Trying a random port...\n", buf, 0x1Cu);
        }
      }
      *(_WORD *)(a2 + 2) = 0;
      uint64_t v10 = bind(*(_DWORD *)(v9 + 20), (const sockaddr *)a2, a3);
      if (v10 == -1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VTP_BindNew_cold_2();
          }
        }
        int v11 = 0;
        goto LABEL_15;
      }
    }
  }
  if (v10)
  {
    int v11 = 0;
  }
  else
  {
    *(void *)&long long v26 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v26 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v34 = v26;
    long long v35 = v26;
    long long v32 = v26;
    long long v33 = v26;
    long long v30 = v26;
    long long v31 = v26;
    *(_OWORD *)buf = v26;
    *(_OWORD *)&buf[16] = v26;
    socklen_t v28 = 128;
    *(unsigned char *)(v9 + 24) = 1;
    getsockname(*(_DWORD *)(v9 + 20), (sockaddr *)buf, &v28);
    SAToIPPORT();
    int v27 = *(_DWORD *)(v7 + 24);
    if (v27 != -1)
    {
      close(v27);
      *(_DWORD *)(v7 + 24) = -1;
    }
    int v11 = 0;
    uint64_t v10 = 0;
  }
LABEL_16:
  pthread_rwlock_unlock(v8);
  CheckOutHandleDebug();
  if (v11)
  {
    int v12 = 9;
LABEL_18:
    *__error() = v12;
  }
  return v10;
}

uint64_t VTP_Sendto(int a1, const void *a2, size_t a3, int a4, uint64_t a5, socklen_t a6, int *a7)
{
  uint64_t v150 = *MEMORY[0x1E4F143B8];
  if (!a7)
  {
    *__error() = 22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Sendto_cold_1();
      }
    }
    return -1;
  }
  if (*a7 >= 0x100)
  {
    *__error() = 22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Sendto_cold_2();
      }
    }
    return -1;
  }
  p_opt_inst_meths = &OBJC_PROTOCOL___VCVideoSink.opt_inst_meths;
  uint64_t v15 = CheckInHandleDebug();
  if (!v15)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Sendto_cold_3();
      }
    }
    *__error() = 13;
    return -1;
  }
  uint64_t v16 = v15;
  int v17 = *a7;
  if (*a7 >= 4 && (a7[37] & 3) == 1)
  {
    uint64_t v18 = *(void *)(v15 + 8 * a1 + 13432);
    *(void *)int v133 = a3;
    if ((DTLS_Write(v18, a2, a3, (size_t *)v133, v17) & 0x80000000) != 0)
    {
      *__error() = 22;
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      {
        uint64_t v19 = -1;
      }
      else
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_Sendto_cold_4();
        }
        uint64_t v19 = -1;
      }
    }
    else
    {
      uint64_t v19 = *(void *)v133;
    }
    CheckOutHandleDebug();
    return v19;
  }
  int v131 = (pthread_rwlock_t *)(v15 + 5376);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v15 + 5376));
  int v20 = a7[40];
  *(void *)&v133[32] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v21 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)int v133 = v21;
  *(_OWORD *)&v133[16] = v21;
  __int16 v132 = (atomic_ullong *)v16;
  int v129 = a4;
  if (!v20)
  {
    unint64_t v23 = *(void *)(v16 + 5576);
    if (!v23)
    {
LABEL_49:
      int v26 = 0;
      unint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
      goto LABEL_51;
    }
    while (*(_DWORD *)v23 != a1)
    {
      unint64_t v23 = *(void *)(v23 + 352);
      if (!v23) {
        goto LABEL_49;
      }
    }
    SAToIPPORT();
    unint64_t v22 = *(void *)(v16 + 5880);
    if (!v22)
    {
LABEL_167:
      int v26 = 0;
      unint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
      goto LABEL_52;
    }
    int v78 = *(_DWORD *)(v23 + 60) & 1;
    int v79 = v133[0] & 1;
    while (1)
    {
      if (v78 != (*(_DWORD *)(v22 + 28) & 1)) {
        goto LABEL_153;
      }
      if (v78)
      {
        if (*(void *)(v23 + 80) != *(void *)(v22 + 48) || *(void *)(v23 + 88) != *(void *)(v22 + 56)) {
          goto LABEL_153;
        }
      }
      else if (*(_DWORD *)(v23 + 80) != *(_DWORD *)(v22 + 48))
      {
        goto LABEL_153;
      }
      if (*(unsigned __int16 *)(v23 + 96) != *(unsigned __int16 *)(v22 + 64) || v79 != (*(_DWORD *)(v22 + 148) & 1)) {
        goto LABEL_153;
      }
      if (v133[0])
      {
        if (*(void *)&v133[20] != *(void *)(v22 + 168) || *(void *)&v133[28] != *(void *)(v22 + 176)) {
          goto LABEL_153;
        }
      }
      else if (*(_DWORD *)&v133[20] != *(_DWORD *)(v22 + 168))
      {
        goto LABEL_153;
      }
      if (*(unsigned __int16 *)&v133[36] == *(unsigned __int16 *)(v22 + 184)) {
        goto LABEL_220;
      }
LABEL_153:
      uint64_t v82 = p_opt_inst_meths;
      uint64_t v83 = *(unsigned int *)(v22 + 320);
      if ((int)v83 >= 1)
      {
        uint64_t v84 = 0;
        int v85 = (unsigned __int16 *)(v22 + 512);
        do
        {
          if (v79 == (*((_DWORD *)v85 - 9) & 1))
          {
            if (v133[0])
            {
              if (*(void *)&v133[20] == *((void *)v85 - 2) && *(void *)&v133[28] == *((void *)v85 - 1))
              {
LABEL_164:
                if (*(unsigned __int16 *)&v133[36] == *v85)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                  {
                    uint64_t v121 = VRTraceErrorLogLevelToCSTR();
                    logb = *MEMORY[0x1E4F47A50];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136315906;
                      *(void *)&uint8_t buf[4] = v121;
                      *(_WORD *)&buf[12] = 2080;
                      *(void *)&buf[14] = "FindConnectionResultByKey";
                      *(_WORD *)&buf[22] = 1024;
                      *(_DWORD *)&unsigned char buf[24] = 2529;
                      *(_WORD *)&buf[28] = 1024;
                      *(_DWORD *)&buf[30] = v84;
                      _os_log_impl(&dword_1E1EA4000, logb, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: packet destination matched connection result %d", buf, 0x22u);
                    }
                  }
                  int v26 = v84 + 2;
                  p_opt_inst_meths = v82;
LABEL_48:
                  uint64_t v16 = (uint64_t)v132;
                  goto LABEL_52;
                }
              }
            }
            else if (*(_DWORD *)&v133[20] == *((_DWORD *)v85 - 4))
            {
              goto LABEL_164;
            }
          }
          ++v84;
          v85 += 160;
        }
        while (v83 != v84);
      }
      unint64_t v22 = *(void *)(v22 + 2056);
      p_opt_inst_meths = v82;
      uint64_t v16 = (uint64_t)v132;
      if (!v22) {
        goto LABEL_167;
      }
    }
  }
  unint64_t v22 = *(void *)(v16 + 5880);
  if (!v22)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Sendto_cold_5();
      }
      int v26 = 0;
      unint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
      goto LABEL_47;
    }
    goto LABEL_49;
  }
  unint64_t v23 = *(void *)(v16 + 5576);
  if (!v23)
  {
LABEL_29:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Sendto_cold_6();
      }
      int v26 = 0;
LABEL_47:
      unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
      goto LABEL_48;
    }
    int v26 = 0;
LABEL_51:
    unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
    goto LABEL_52;
  }
  int v24 = *(_DWORD *)(v22 + 356) & 1;
  while (1)
  {
    if ((*(_DWORD *)(v23 + 60) & 1) == v24)
    {
      if (v24)
      {
        if (*(void *)(v23 + 80) != *(void *)(v22 + 376) || *(void *)(v23 + 88) != *(void *)(v22 + 384)) {
          goto LABEL_28;
        }
      }
      else if (*(_DWORD *)(v23 + 80) != *(_DWORD *)(v22 + 376))
      {
        goto LABEL_28;
      }
      if (*(unsigned __int16 *)(v23 + 96) == *(unsigned __int16 *)(v22 + 392)) {
        break;
      }
    }
LABEL_28:
    unint64_t v23 = *(void *)(v23 + 352);
    if (!v23) {
      goto LABEL_29;
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    size_t v124 = a3;
    uint64_t v95 = VRTraceErrorLogLevelToCSTR();
    __int16 v96 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v97 = *(_DWORD *)v23;
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = v95;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "FindConnectionResultByKey";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&unsigned char buf[24] = 2492;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v97;
      _os_log_impl(&dword_1E1EA4000, v96, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP default result key uses vfd(%d) for send.", buf, 0x22u);
    }
    int v26 = 1;
    a3 = v124;
    goto LABEL_48;
  }
LABEL_220:
  int v26 = 1;
LABEL_52:
  if (a7[39])
  {
    unint64_t v28 = *(void *)(v16 + 5576);
    if (v28)
    {
      while (*(_DWORD *)v28 != a1)
      {
        unint64_t v28 = *(void *)(v28 + 352);
        if (!v28) {
          goto LABEL_56;
        }
      }
      int v52 = v26;
      uint64_t v53 = SendOnePacketOnVFDList(v132, (int *)v28, (uint64_t)a2, a3, v129, a5, a6, a7, 0);
      int v26 = v52;
      uint64_t v19 = v53;
      int v29 = 1;
    }
    else
    {
LABEL_56:
      int v29 = 0;
      uint64_t v19 = -1;
    }
    int log = v26;
    if (v26)
    {
      if (v26 == 3)
      {
        unsigned int v54 = *(_DWORD *)(v22 + 676);
        int v55 = v54 & (v54 << 29 >> 31);
        int v56 = (v54 >> 2) & 1;
        goto LABEL_112;
      }
LABEL_111:
      int v56 = 0;
      int v55 = 0;
LABEL_112:
      BOOL v60 = v56 != 0;
      int v61 = v55 != 0;
      if (!v29)
      {
        unint64_t v28 = 0;
        goto LABEL_219;
      }
      BOOL v130 = v55 != 0;
      size_t v123 = a3;
LABEL_114:
      *(void *)&buf[46] = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v62 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v62 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&buf[16] = v62;
      *(_OWORD *)&unsigned char buf[32] = v62;
      *(_OWORD *)buf = v62;
      *(void *)((char *)v148 + 14) = 0xAAAAAAAAAAAAAAAALL;
      v147[1] = v62;
      v148[0] = v62;
      v147[0] = v62;
      unint64_t v146 = 0xAAAAAAAAAAAAAAAALL;
      long long v144 = v62;
      long long v145 = v62;
      SAToIPPORT();
      int v63 = (_DWORD *)(v28 + 60);
      IPPORTToStringWithSize();
      IPPORTToStringWithSize();
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        uint64_t v120 = VRTraceErrorLogLevelToCSTR();
        uint64_t v64 = *MEMORY[0x1E4F47A50];
        long long v65 = *MEMORY[0x1E4F47A50];
        if (*MEMORY[0x1E4F47A40])
        {
          if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
          {
            long long v66 = v64;
            int v67 = *v63 & 4;
            uint64_t v68 = 48;
            if (!v55) {
              uint64_t v68 = 28;
            }
            size_t v69 = v68 + v123;
            atomic_ullong v70 = v132[735];
            if (v70)
            {
              int v71 = *(_DWORD *)(v70 + 320);
              uint64_t v72 = v120;
              if (v71 == 2)
              {
                int v73 = *(_DWORD *)(v70 + 676) & 4;
                int v71 = 2;
              }
              else
              {
                int v73 = -1;
              }
            }
            else
            {
              int v71 = -1;
              int v73 = -1;
              uint64_t v72 = v120;
            }
            *(_DWORD *)int v133 = 136317698;
            *(void *)&v133[4] = v72;
            *(_WORD *)&v133[12] = 2080;
            *(void *)&v133[14] = "VTP_Sendto";
            *(_WORD *)&v133[22] = 1024;
            *(_DWORD *)&v133[24] = 2670;
            *(_WORD *)&v133[28] = 2080;
            *(void *)&v133[30] = v147;
            *(_WORD *)&v133[38] = 1024;
            *(_DWORD *)&v133[40] = v67;
            *(_WORD *)&v133[44] = 2080;
            *(void *)&v133[46] = buf;
            __int16 v134 = 1024;
            int v135 = log;
            __int16 v136 = 1024;
            int v137 = v56;
            __int16 v138 = 2048;
            size_t v139 = v69;
            __int16 v140 = 1024;
            int v141 = v71;
            __int16 v142 = 1024;
            int v143 = v73;
            _os_log_impl(&dword_1E1EA4000, v66, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_Sendto: isICEPacket = 1  mbLocal = %s, mbLocalIsCellular = %d, mbDst = %s, matchedType = %d, shouldCountBytes = %d, length = %lu, numResult = %d, isSecondaryCellular = %d", v133, 0x58u);
          }
        }
        else if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v87 = v64;
          int v88 = *v63 & 4;
          uint64_t v89 = 48;
          if (!v55) {
            uint64_t v89 = 28;
          }
          size_t v90 = v89 + v123;
          atomic_ullong v91 = v132[735];
          if (v91)
          {
            int v92 = *(_DWORD *)(v91 + 320);
            uint64_t v94 = v120;
            if (v92 == 2)
            {
              int v93 = *(_DWORD *)(v91 + 676) & 4;
              int v92 = 2;
            }
            else
            {
              int v93 = -1;
            }
          }
          else
          {
            int v92 = -1;
            int v93 = -1;
            uint64_t v94 = v120;
          }
          *(_DWORD *)int v133 = 136317698;
          *(void *)&v133[4] = v94;
          *(_WORD *)&v133[12] = 2080;
          *(void *)&v133[14] = "VTP_Sendto";
          *(_WORD *)&v133[22] = 1024;
          *(_DWORD *)&v133[24] = 2670;
          *(_WORD *)&v133[28] = 2080;
          *(void *)&v133[30] = v147;
          *(_WORD *)&v133[38] = 1024;
          *(_DWORD *)&v133[40] = v88;
          *(_WORD *)&v133[44] = 2080;
          *(void *)&v133[46] = buf;
          __int16 v134 = 1024;
          int v135 = log;
          __int16 v136 = 1024;
          int v137 = v56;
          __int16 v138 = 2048;
          size_t v139 = v90;
          __int16 v140 = 1024;
          int v141 = v92;
          __int16 v142 = 1024;
          int v143 = v93;
          _os_log_debug_impl(&dword_1E1EA4000, v87, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VTP_Sendto: isICEPacket = 1  mbLocal = %s, mbLocalIsCellular = %d, mbDst = %s, matchedType = %d, shouldCountBytes = %d, length = %lu, numResult = %d, isSecondaryCellular = %d", v133, 0x58u);
        }
      }
      uint64_t v109 = v131;
      int v61 = v130;
      goto LABEL_225;
    }
    atomic_ullong v57 = v132[735];
    if (!v57 || *(_DWORD *)(v57 + 320) != 2) {
      goto LABEL_111;
    }
    char v58 = v29 ^ 1;
    if ((*(_DWORD *)(v57 + 676) & 4) == 0) {
      char v58 = 1;
    }
    if (v58) {
      goto LABEL_111;
    }
    int v59 = *(_DWORD *)(v28 + 60);
    size_t v123 = a3;
    if ((v59 & 1) == (*(_DWORD *)(v57 + 676) & 1))
    {
      if ((v59 & 1) == 0)
      {
        if (*(_DWORD *)(v28 + 80) != *(_DWORD *)(v57 + 696)) {
          goto LABEL_251;
        }
LABEL_249:
        if (*(unsigned __int16 *)(v28 + 96) != *(unsigned __int16 *)(v57 + 712)) {
          goto LABEL_251;
        }
        int v55 = v59 & 1;
        BOOL v60 = 1;
        unint64_t v22 = v132[735];
        unint64_t v23 = v28;
LABEL_252:
        BOOL v130 = v55 != 0;
        int v56 = v60;
        goto LABEL_114;
      }
      if (*(void *)(v28 + 80) == *(void *)(v57 + 696) && *(void *)(v28 + 88) == *(void *)(v57 + 704)) {
        goto LABEL_249;
      }
    }
LABEL_251:
    BOOL v60 = 0;
    int v55 = 0;
    goto LABEL_252;
  }
  *(void *)&long long v30 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v133[16] = v30;
  *(_OWORD *)&v133[32] = v30;
  *(_OWORD *)int v133 = v30;
  unsigned int v31 = v26 - 2;
  if ((v26 - 2) >= 2)
  {
    if (v26)
    {
      if (v26 == 1)
      {
        if (*(int *)(v22 + 320) < 1)
        {
          LOBYTE(v34) = 0;
          char v33 = 0;
          unint64_t v28 = 0;
          uint64_t v19 = -1;
          goto LABEL_217;
        }
        uint64_t v122 = a3;
        uint64_t v32 = 0;
        unint64_t v28 = 0;
        char v33 = 0;
        uint64_t v34 = 0;
        uint64_t v19 = -1;
        int v35 = -1;
        unint64_t v117 = v22;
        while (1)
        {
          unint64_t v36 = v22 + 320 * v32;
          socklen_t v37 = *(_DWORD *)(v22 + 4 * v32 + 1224);
          int v38 = *(_DWORD *)(v36 + 356) & 1;
          if (v38 == (*(_DWORD *)(v23 + 60) & 1))
          {
            long long v39 = (void *)(v22 + 320 * v32 + 376);
            if (v38)
            {
              if (*v39 == *(void *)(v23 + 80) && *(void *)(v22 + 320 * v32 + 384) == *(void *)(v23 + 88))
              {
LABEL_71:
                unint64_t v41 = v23;
                if (*(unsigned __int16 *)(v22 + 320 * v32 + 392) == *(unsigned __int16 *)(v23 + 96)) {
                  goto LABEL_87;
                }
              }
            }
            else if (*(_DWORD *)v39 == *(_DWORD *)(v23 + 80))
            {
              goto LABEL_71;
            }
          }
          unint64_t v41 = v132[697];
          if (!v41)
          {
LABEL_85:
            unint64_t v28 = 0;
            goto LABEL_88;
          }
          unint64_t v42 = v22 + 320 * v32;
          socklen_t v43 = (void *)(v42 + 376);
          uint32_t v44 = (unsigned __int16 *)(v42 + 392);
          while (1)
          {
            if (v38 == (*(_DWORD *)(v41 + 60) & 1))
            {
              if (v38)
              {
                if (*v43 != *(void *)(v41 + 80) || v43[1] != *(void *)(v41 + 88)) {
                  goto LABEL_84;
                }
              }
              else if (*(_DWORD *)v43 != *(_DWORD *)(v41 + 80))
              {
                goto LABEL_84;
              }
              if (*v44 == *(unsigned __int16 *)(v41 + 96)) {
                break;
              }
            }
LABEL_84:
            unint64_t v41 = *(void *)(v41 + 352);
            if (!v41) {
              goto LABEL_85;
            }
          }
          unint64_t v28 = v41;
LABEL_87:
          uint64_t v46 = v22 + (v32 << 7) + 968;
          uint64_t v47 = (uint64_t)a2;
          long long v48 = a2;
          long long v49 = p_opt_inst_meths;
          uint64_t v50 = v34;
          int v35 = SendOnePacketOnVFDList(v132, (int *)v41, v47, v122, v129, v46, v37, a7, v36 + 328);
          uint64_t v34 = v50;
          p_opt_inst_meths = v49;
          a2 = v48;
          unint64_t v22 = v117;
LABEL_88:
          if (v35 != -1)
          {
            uint64_t v19 = v35;
            if (v32)
            {
              int v51 = *(_DWORD *)(v36 + 356);
              uint64_t v34 = (v51 & 4) != 0 ? 1 : v34;
              if ((v51 & 4) != 0) {
                char v33 = v51 & 1;
              }
            }
          }
          if (*(_DWORD *)(v22 + 324))
          {
            if (++v32 < *(int *)(v22 + 320)) {
              continue;
            }
          }
LABEL_217:
          BOOL v60 = v34 & 1;
          int v61 = v33 & 1;
          goto LABEL_219;
        }
      }
      BOOL v60 = 0;
      int v61 = 0;
      unint64_t v28 = 0;
    }
    else
    {
      unint64_t v28 = *(void *)(v16 + 5576);
      if (v28)
      {
        while (*(_DWORD *)v28 != a1)
        {
          unint64_t v28 = *(void *)(v28 + 352);
          if (!v28) {
            goto LABEL_171;
          }
        }
        uint64_t v19 = SendOnePacketOnVFDList(v132, (int *)v28, (uint64_t)a2, a3, v129, a5, a6, a7, 0);
        BOOL v60 = 0;
        int v61 = 0;
LABEL_219:
        uint64_t v109 = v131;
        goto LABEL_225;
      }
LABEL_171:
      BOOL v60 = 0;
      int v61 = 0;
    }
    uint64_t v19 = -1;
    goto LABEL_219;
  }
  int loga = v26;
  unint64_t v74 = v22 + 320 * v31;
  uint64_t v118 = (v26 - 2);
  socklen_t v75 = *(_DWORD *)(v22 + 4 * v31 + 1224);
  long long v76 = (int *)(v74 + 356);
  if ((*(_DWORD *)(v74 + 356) & 1) != (*(_DWORD *)(v23 + 60) & 1)) {
    goto LABEL_196;
  }
  int v77 = (void *)(v22 + 320 * v118 + 376);
  if (*(_DWORD *)(v74 + 356))
  {
    if (*v77 != *(void *)(v23 + 80) || *(void *)(v22 + 320 * v118 + 384) != *(void *)(v23 + 88)) {
      goto LABEL_196;
    }
LABEL_194:
    if (*(unsigned __int16 *)(v22 + 320 * v118 + 392) == *(unsigned __int16 *)(v23 + 96))
    {
      unint64_t v28 = 0;
      unint64_t v99 = v23;
      goto LABEL_238;
    }
    goto LABEL_196;
  }
  if (*(_DWORD *)v77 == *(_DWORD *)(v23 + 80)) {
    goto LABEL_194;
  }
LABEL_196:
  unint64_t v115 = v22 + 320 * v31;
  socklen_t v116 = *(_DWORD *)(v22 + 4 * v31 + 1224);
  size_t v125 = a3;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v100 = VRTraceErrorLogLevelToCSTR();
    uint64_t v101 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v102 = IPToString();
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = v100;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "VTP_Sendto";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&unsigned char buf[24] = 2727;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = v102;
      _os_log_impl(&dword_1E1EA4000, v101, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: matching localIP: %s", buf, 0x26u);
    }
  }
  unint64_t v99 = *(void *)(v16 + 5576);
  if (!v99)
  {
LABEL_215:
    unint64_t v28 = 0;
    uint64_t v19 = -1;
    goto LABEL_239;
  }
  unint64_t v103 = v22 + 320 * v118;
  uint64_t v104 = (void *)(v103 + 376);
  uint64_t v119 = (unsigned __int16 *)(v103 + 392);
  while (1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v105 = VRTraceErrorLogLevelToCSTR();
      long long v106 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v107 = IPToString();
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = v105;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "VTP_Sendto";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = 2730;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = v107;
        _os_log_impl(&dword_1E1EA4000, v106, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: matching vfd, %s", buf, 0x26u);
      }
    }
    if ((*v76 & 1) != (*(_DWORD *)(v99 + 60) & 1)) {
      goto LABEL_214;
    }
    if (*v76)
    {
      if (*v104 != *(void *)(v99 + 80) || v104[1] != *(void *)(v99 + 88)) {
        goto LABEL_214;
      }
    }
    else if (*(_DWORD *)v104 != *(_DWORD *)(v99 + 80))
    {
      goto LABEL_214;
    }
    if (*v119 == *(unsigned __int16 *)(v99 + 96)) {
      break;
    }
LABEL_214:
    unint64_t v99 = *(void *)(v99 + 352);
    if (!v99) {
      goto LABEL_215;
    }
  }
  unint64_t v28 = v99;
  a3 = v125;
  socklen_t v75 = v116;
  unint64_t v74 = v115;
LABEL_238:
  uint64_t v19 = SendOnePacketOnVFDList(v132, (int *)v99, (uint64_t)a2, a3, v129, v22 + (v118 << 7) + 968, v75, a7, v74 + 328);
LABEL_239:
  uint64_t v109 = v131;
  if (loga == 3)
  {
    int v113 = *v76;
    int v61 = *v76 & 1;
    BOOL v60 = (*v76 & 4) != 0;
    if ((v113 & 4) == 0) {
      int v61 = 0;
    }
  }
  else
  {
    BOOL v60 = 0;
    int v61 = 0;
  }
LABEL_225:
  if (v19 >= 1 && v60)
  {
    if (v61) {
      int v110 = 48;
    }
    else {
      int v110 = 28;
    }
    int v111 = *(_DWORD *)(v23 + 28);
    if ((v111 & 0xF0) != 0)
    {
      long long v112 = (atomic_uint *)(v22 + 2044);
      goto LABEL_234;
    }
    if ((v111 & 0xBC0E) != 0)
    {
      long long v112 = (atomic_uint *)(v22 + 2052);
LABEL_234:
      atomic_fetch_add_explicit(v112, v110 + v19, memory_order_relaxed);
    }
  }
  pthread_rwlock_unlock(v109);
  CheckOutHandleDebug();
  if (!v28) {
    *__error() = 9;
  }
  return v19;
}

uint64_t SendOnePacketOnVFDList(atomic_ullong *a1, int *a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, socklen_t a7, int *a8, uint64_t a9)
{
  socklen_t v9 = a7;
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v43.msg_iov = v11;
  *(_OWORD *)&v43.msg_control = v11;
  *(_OWORD *)&v43.msg_name = v11;
  unint64_t v47 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v48 = 0xAAAAAAAAAAAAAAAALL;
  v50[3] = v11;
  v50[4] = v11;
  v50[1] = v11;
  v50[2] = v11;
  unsigned int v12 = a8[1];
  unsigned int v42 = 0;
  memset(v46, 170, 6);
  socklen_t v44 = a7;
  int v45 = -1431655766;
  v49[7] = v11;
  v50[0] = v11;
  v49[5] = v11;
  v49[6] = v11;
  v49[3] = v11;
  v49[4] = v11;
  v49[1] = v11;
  v49[2] = v11;
  BOOL v13 = a9 == 0;
  v49[0] = v11;
  if (!a9)
  {
    if ((int)a4 >= 4 && (*(_WORD *)a3 & 0xC0) == 0x40 && a4 - 4 == bswap32(*(unsigned __int16 *)(a3 + 2)) >> 16)
    {
      a2[58] = *(_DWORD *)a3;
      uint64_t v15 = a2 + 58;
      unsigned int v14 = 4;
      goto LABEL_5;
    }
LABEL_10:
    BOOL v13 = 0;
    unsigned int v14 = 0;
    unsigned int v16 = 0;
    goto LABEL_11;
  }
  if (!*(_DWORD *)(a9 + 20)) {
    goto LABEL_10;
  }
  if (*(_WORD *)(a9 + 24) == 1)
  {
    unsigned int v14 = 0;
    *((_WORD *)a2 + 116) = bswap32(*(unsigned __int16 *)(a9 + 26)) >> 16;
    uint64_t v15 = a2 + 58;
    *((_WORD *)a2 + 117) = bswap32(a4) >> 16;
LABEL_5:
    *(void *)&v50[0] = v15;
    *((void *)&v50[0] + 1) = 4;
    unsigned int v16 = 1;
LABEL_11:
    int v17 = *a8;
    if ((a8[37] & 2) != 0 || (v17 | 4) == 6 && *((unsigned char *)a8 + 12)) {
      char v18 = 32;
    }
    else {
      char v18 = 0;
    }
    uint64_t v19 = (char *)a1 + 21625;
    if (v17 != 6 && v17 != 2)
    {
      if (!v17)
      {
        uint64_t v20 = v16;
        *(void *)&v50[v16] = a3 + v14;
        int v21 = v16 + 1;
        uint64_t v22 = a4 - v14;
LABEL_43:
        *((void *)&v50[v20] + 1) = v22;
        __memcpy_chk();
        if (*((unsigned char *)a2 + 368))
        {
          VTP_AddNAT64PrefixToIPv4Destination((uint64_t)a2, (uint64_t)v49, &v44);
          socklen_t v9 = v44;
        }
        v43.msg_name = v49;
        v43.msg_namelen = v9;
        v43.msg_iov = (iovec *)v50;
        v43.msg_iovlen = v21;
        v43.msg_char flags = 0;
        if (*v19)
        {
          v43.msg_control = 0;
          v43.msg_controllen = 0;
        }
        else
        {
          v43.msg_control = &v47;
          v43.msg_controllen = 16;
          unint64_t v47 = 0xFFFF00000010;
          LODWORD(v48) = 4230;
          int v36 = *(_DWORD *)(v19 + 3);
          if (!v36) {
            int v36 = a5;
          }
          HIDWORD(v48) = v36;
        }
        LODWORD(result) = sendmsg(a2[5], &v43, 0);
        if ((int)result >= 1)
        {
          if (a2[15]) {
            int v37 = 48;
          }
          else {
            int v37 = 28;
          }
          atomic_fetch_add_explicit(a1, v37 + (int)result, memory_order_relaxed);
        }
        return (int)result;
      }
      v18 |= 8u;
    }
    LOBYTE(v46[0]) = v18;
    BYTE1(v46[0]) = v17;
    *(_DWORD *)((char *)v46 + 2) = bswap32(v12);
    unint64_t v23 = &v50[v16];
    int v24 = v16 + 1;
    *unint64_t v23 = v46;
    v23[1] = 6;
    if ((v18 & 8) != 0)
    {
      BOOL v38 = v13;
      long long v39 = (char *)a1 + 21625;
      uint64_t v25 = v14;
      uint64_t v26 = a3;
      uint64_t v27 = a4;
      if ((PrepareOFTMAC((const __CFString *)a1[*a2 + 755], (const void *)(a3 + v14), a4 - v14, &v45) & 0x80000000) != 0)
      {
        v18 ^= 8u;
        LOBYTE(v46[0]) = v18;
      }
      else
      {
        unint64_t v28 = (int **)&v50[v24];
        int v24 = v16 | 2;
        *unint64_t v28 = &v45;
        v28[1] = (int *)4;
      }
      a3 = v26;
      uint64_t v19 = v39;
      a4 = v27;
      BOOL v13 = v38;
    }
    else
    {
      uint64_t v25 = v14;
    }
    uint64_t v30 = a3 + v25;
    unsigned int v31 = &v50[v24];
    uint64_t v32 = a4 - v25;
    uint64_t v20 = (v24 + 1);
    void *v31 = v30;
    v31[1] = v32;
    if (a9)
    {
      if (*(_DWORD *)(a9 + 20)) {
        char v33 = 1;
      }
      else {
        char v33 = v13;
      }
      if (v33) {
        goto LABEL_36;
      }
    }
    else if (v13)
    {
LABEL_36:
      if ((v18 & 8) != 0) {
        int v34 = 14;
      }
      else {
        int v34 = 10;
      }
      *((_WORD *)a2 + 117) = bswap32(v34 + a4 - v14) >> 16;
      int v35 = 1;
      goto LABEL_42;
    }
    int v35 = 0;
LABEL_42:
    PrepareOFTCRC32((uint64_t)v50, v24 + 1, v35, &v42);
    *(void *)&v50[v24 + 1] = &v42;
    int v21 = v24 + 2;
    uint64_t v22 = 4;
    goto LABEL_43;
  }
  *__error() = 22;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      SendOnePacketOnVFDList_cold_1();
    }
  }
  return -1;
}

uint64_t VTP_Send(int a1, _OWORD *a2, size_t a3, unsigned int a4, uint64_t a5)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (!a5)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Send_cold_1();
      }
    }
    socklen_t v9 = __error();
    int v10 = 22;
    goto LABEL_14;
  }
  if (!*(unsigned char *)(a5 + 218))
  {
    uint64_t v8 = 0;
    if (!a2 || !a3) {
      return v8;
    }
  }
  if (*(unsigned char *)(a5 + 313))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Send_cold_5();
      }
    }
    socklen_t v9 = __error();
    int v10 = 81;
LABEL_14:
    *socklen_t v9 = v10;
    return -1;
  }
  BOOL v13 = a4 == 800 || a4 == 700;
  int v47 = *(unsigned __int8 *)(a5 + 205);
  int v48 = v13;
  int v45 = *(unsigned __int8 *)(a5 + 204);
  unsigned int v46 = *(unsigned __int8 *)(a5 + 200);
  uint64_t v14 = CheckInHandleDebug();
  if (!v14)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Send_cold_2();
      }
    }
    socklen_t v9 = __error();
    int v10 = 13;
    goto LABEL_14;
  }
  uint64_t v15 = v14;
  if (a4 == 800 || a4 == 700) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 21976), 1uLL, memory_order_relaxed);
  }
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v14 + 21648));
  int v16 = *(_DWORD *)(a5 + 8);
  unsigned int v50 = a4;
  msghdr v43 = (pthread_rwlock_t *)(v15 + 21648);
  if (v16)
  {
    int v17 = (void *)VTP_getConnectionManagerForCallID(v15, v16);
    int v18 = *(unsigned __int8 *)(a5 + 169);
    if ([v17 isPreWarmStateEnabled]) {
      v18 |= *(unsigned __int8 *)(a5 + 170);
    }
    buf[0] = v18 != 0;
    buf[1] = 1;
    buf[2] = *(unsigned char *)(a5 + 309);
    buf[3] = *(unsigned char *)(a5 + 233);
    uint8_t buf[4] = *(unsigned char *)(a5 + 312);
    PacketRoutingInfoList = VCConnectionManager_CreatePacketRoutingInfoList((uint64_t)v17, buf, *(const __CFAllocator **)(v15 + 22048));
    if (!PacketRoutingInfoList) {
      goto LABEL_30;
    }
    goto LABEL_51;
  }
  if (!*(_DWORD *)(a5 + 24))
  {
    PacketRoutingInfoList = _VTP_CreatePacketRoutingInfoListWithVFD(a1);
    *(void *)buf = 0;
    if (!_VTP_GetNWContentMetaData(a1, buf))
    {
      uint64_t v30 = *(NSObject **)buf;
      if (*(void *)buf)
      {
        *(void *)(a5 + 320) = *(void *)buf;
        switch(a4)
        {
          case 0xC8u:
            nw_service_class_t v31 = nw_service_class_background;
            break;
          case 0x2BCu:
            nw_service_class_t v31 = nw_service_class_interactive_video;
            break;
          case 0x320u:
            nw_service_class_t v31 = nw_service_class_interactive_voice;
            break;
          default:
            goto LABEL_50;
        }
        nw_ip_metadata_set_service_class(v30, v31);
      }
    }
LABEL_50:
    int v17 = 0;
    if (!PacketRoutingInfoList)
    {
LABEL_30:
      *__error() = 22;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        uint64_t v20 = VRTraceErrorLogLevelToCSTR();
        int v21 = *MEMORY[0x1E4F47A50];
        uint64_t v22 = *MEMORY[0x1E4F47A50];
        if (*MEMORY[0x1E4F47A40])
        {
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            *(void *)&uint8_t buf[4] = v20;
            __int16 v53 = 2080;
            unsigned int v54 = "VTP_Send";
            __int16 v55 = 1024;
            int v56 = 3020;
            _os_log_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d infoList is NULL! Dropped packet!", buf, 0x1Cu);
          }
        }
        else if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
        {
          VTP_Send_cold_3();
        }
      }
LABEL_93:
      *(void *)(a5 + 320) = 0;
      pthread_rwlock_unlock(v43);
      uint64_t v8 = -1;
      goto LABEL_87;
    }
    goto LABEL_51;
  }
  unint64_t v23 = (char *)CFAllocatorAllocate(*(CFAllocatorRef *)(v15 + 22048), 136, 0);
  if (!v23)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Send_cold_4();
      }
    }
    goto LABEL_93;
  }
  PacketRoutingInfoList = v23;
  int v17 = 0;
  long long v24 = *(_OWORD *)(a5 + 24);
  long long v25 = *(_OWORD *)(a5 + 40);
  long long v26 = *(_OWORD *)(a5 + 56);
  *(_OWORD *)(v23 + 56) = *(_OWORD *)(a5 + 72);
  *(_OWORD *)(v23 + 40) = v26;
  *(_OWORD *)(v23 + 24) = v25;
  *(_OWORD *)(v23 + 8) = v24;
  long long v27 = *(_OWORD *)(a5 + 88);
  long long v28 = *(_OWORD *)(a5 + 104);
  uint64_t v29 = *(void *)(a5 + 136);
  *(_OWORD *)(v23 + 104) = *(_OWORD *)(a5 + 120);
  *(_OWORD *)(v23 + 88) = v28;
  *(_OWORD *)(v23 + 72) = v27;
  *((void *)v23 + 15) = v29;
  *((void *)v23 + 16) = 0;
LABEL_51:
  int v32 = 0;
  unsigned int v33 = -1;
  uint64_t v8 = -1;
  int v44 = 0;
  uint64_t v34 = -1;
  int v35 = PacketRoutingInfoList;
  do
  {
    if (!*((_DWORD *)v35 + 2)) {
      goto LABEL_77;
    }
    if (v17)
    {
      if (*((unsigned char *)v35 + 30)) {
        BOOL v36 = (*(_DWORD *)(a5 + 164) & 0x10) == 0;
      }
      else {
        BOOL v36 = 1;
      }
      if (v36)
      {
        int v37 = 0;
        if (*((unsigned char *)v35 + 30) && (*(_DWORD *)(a5 + 164) & 0x20) != 0) {
          int v37 = *(_DWORD *)(v15 + 21632);
        }
      }
      else
      {
        int v37 = *(_DWORD *)(v15 + 21636);
      }
      *(_DWORD *)(a5 + 288) = v37;
    }
    if (*(unsigned char *)(a5 + 255)) {
      BOOL v38 = 1;
    }
    else {
      BOOL v38 = *(unsigned char *)v35 != 0;
    }
    *(unsigned char *)(a5 + 255) = v38;
    uint64_t v39 = _VTP_SendWithSourceDestinationInfo(v15, (unsigned int *)v35 + 2, a2, a3, v50, (void *)a5, *(unsigned __int8 *)(v15 + 21624));
    uint64_t v34 = v39;
    if (!v17) {
      goto LABEL_73;
    }
    if (v39 > 0) {
      goto LABEL_68;
    }
    if (v39) {
      goto LABEL_73;
    }
    if (*(unsigned char *)(a5 + 218))
    {
LABEL_68:
      VCConnectionManager_UpdateTransmittedPacketsAndBytes((uint64_t)v17, (uint64_t)(v35 + 1), v39, v48, v47 != 0, v46, v45 != 0);
      if ((v50 == 800 || v50 == 700) && !v44)
      {
        int v44 = 1;
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 21984), 1uLL, memory_order_relaxed);
      }
LABEL_73:
      if (*(unsigned char *)(a5 + 218)) {
        [v17 updateSessionStats:*(unsigned __int16 *)(a5 + 220)];
      }
    }
    unsigned int v33 = v32 != 0;
    if (!v32) {
      int v32 = 1;
    }
LABEL_77:
    int v35 = (void *)v35[16];
    _VTP_HealthPrint(v15, a3, v33, v50, 1);
    int v40 = *__error();
    if (v8 < 0 || v40 != 43) {
      uint64_t v8 = v34;
    }
  }
  while (v35);
  *(void *)(a5 + 320) = 0;
  pthread_rwlock_unlock(v43);
  do
  {
    unsigned int v42 = (void *)PacketRoutingInfoList[16];
    CFAllocatorDeallocate(*(CFAllocatorRef *)(v15 + 22048), PacketRoutingInfoList);
    PacketRoutingInfoList = v42;
  }
  while (v42);
LABEL_87:
  CheckOutHandleDebug();
  return v8;
}

const void *VTP_getConnectionManagerForCallID(uint64_t a1, int a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  int valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  CFDataRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 21848), v3);
  CFRelease(v3);
  return Value;
}

char *_VTP_CreatePacketRoutingInfoListWithVFD(int a1)
{
  uint64_t v2 = CheckInHandleDebug();
  if (v2)
  {
    uint64_t v3 = v2;
    uint64_t v4 = (pthread_rwlock_t *)(v2 + 5376);
    pthread_rwlock_rdlock((pthread_rwlock_t *)(v2 + 5376));
    uint64_t v5 = *(void *)(v3 + 5576);
    if (v5)
    {
      while (*(_DWORD *)v5 != a1)
      {
        uint64_t v5 = *(void *)(v5 + 352);
        if (!v5) {
          goto LABEL_5;
        }
      }
      uint64_t v7 = (char *)CFAllocatorAllocate(*(CFAllocatorRef *)(v3 + 22048), 136, 0);
      if (v7)
      {
        uint64_t v6 = v7;
        long long v8 = *(_OWORD *)(v5 + 392);
        long long v9 = *(_OWORD *)(v5 + 408);
        long long v10 = *(_OWORD *)(v5 + 424);
        *(_OWORD *)(v7 + 56) = *(_OWORD *)(v5 + 440);
        *(_OWORD *)(v7 + 40) = v10;
        *(_OWORD *)(v7 + 24) = v9;
        *(_OWORD *)(v7 + 8) = v8;
        long long v11 = *(_OWORD *)(v5 + 456);
        long long v12 = *(_OWORD *)(v5 + 472);
        uint64_t v13 = *(void *)(v5 + 504);
        *(_OWORD *)(v7 + 104) = *(_OWORD *)(v5 + 488);
        *(_OWORD *)(v7 + 88) = v12;
        *(_OWORD *)(v7 + 72) = v11;
        *((void *)v7 + 15) = v13;
        *((void *)v7 + 16) = 0;
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VTP_CreatePacketRoutingInfoListWithVFD_cold_3();
          }
        }
        uint64_t v6 = 0;
      }
    }
    else
    {
LABEL_5:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VTP_CreatePacketRoutingInfoListWithVFD_cold_2();
        }
      }
      uint64_t v6 = 0;
      *__error() = 6;
    }
    pthread_rwlock_unlock(v4);
    CheckOutHandleDebug();
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VTP_CreatePacketRoutingInfoListWithVFD_cold_1();
      }
    }
    uint64_t v6 = 0;
    *__error() = 13;
  }
  return v6;
}

uint64_t _VTP_SendWithSourceDestinationInfo(uint64_t a1, unsigned int *a2, _OWORD *buffer, size_t size, uint64_t a5, void *a6, int a7)
{
  __dst[41] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    size_t v8 = size;
    if (size >= 0x5C1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v10 = VRTraceErrorLogLevelToCSTR();
        long long v11 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          int v45 = *a2;
          LODWORD(__b[0]) = 136316418;
          *(void *)((char *)__b + 4) = v10;
          WORD6(__b[0]) = 2080;
          *(void *)((char *)__b + 14) = "_VTP_SendWithSourceDestinationInfo";
          WORD3(__b[1]) = 1024;
          DWORD2(__b[1]) = 4933;
          WORD6(__b[1]) = 2048;
          *(void *)((char *)&__b[1] + 14) = v8;
          WORD3(__b[2]) = 1024;
          DWORD2(__b[2]) = a5;
          WORD6(__b[2]) = 1024;
          *(_DWORD *)((char *)&__b[2] + 14) = v45;
          _os_log_error_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_ERROR, " [%s] %s:%d Packet data too big length=%zu trafficFlags=%d mode=%d", (uint8_t *)__b, 0x32u);
        }
      }
      *__error() = 40;
      CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Packet data is too big. length=%zu, trafficFlags=%d, mode=%d, expectedMaxLength=%d", v8, a5, *a2, 1472);
      VCTerminateProcess((uint64_t)v12, @"_VTP_SendWithSourceDestinationInfo", 0);
      if (v12) {
        CFRelease(v12);
      }
      return -1;
    }
    int v17 = buffer;
    switch(*a2)
    {
      case 1u:
        int v19 = *((_DWORD *)a6 + 39);
        uint64_t v20 = CheckInHandleDebug();
        if (v20)
        {
          uint64_t v21 = v20;
          uint64_t v22 = (pthread_rwlock_t *)(v20 + 5376);
          pthread_rwlock_rdlock((pthread_rwlock_t *)(v20 + 5376));
          unint64_t v23 = *(int **)(v21 + 5576);
          if (!v23)
          {
LABEL_30:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                _VTP_SendWithSourceDestinationInfo_cold_4();
              }
            }
            *__error() = 9;
            size_t v8 = -1;
            goto LABEL_34;
          }
          int v24 = a2[2] & 1;
          while (1)
          {
            if ((v23[15] & 1) == v24)
            {
              if (v24)
              {
                if (*((void *)v23 + 10) != *(void *)(a2 + 7) || *((void *)v23 + 11) != *(void *)(a2 + 9)) {
                  goto LABEL_29;
                }
              }
              else if (v23[20] != a2[7])
              {
                goto LABEL_29;
              }
              if (*((unsigned __int16 *)v23 + 48) == *((unsigned __int16 *)a2 + 22))
              {
                memset(__dst, 0, 128);
                if (a2[12])
                {
                  int v85 = 28;
                  IPPORTToSA6();
                }
                else
                {
                  int v85 = 16;
                  IPPORTToSA();
                }
                socklen_t v90 = v85;
                memset(v91, 170, sizeof(v91));
                *(void *)&long long v51 = 0xAAAAAAAAAAAAAAAALL;
                *((void *)&v51 + 1) = 0xAAAAAAAAAAAAAAAALL;
                long long v95 = v51;
                long long v96 = v51;
                long long v93 = v51;
                long long v94 = v51;
                long long v92 = v51;
                unsigned int v52 = *((_DWORD *)a6 + 1);
                unsigned int v88 = 0;
                int v53 = *((_DWORD *)a6 + 39);
                BOOL v54 = v53 != 0;
                if (v53)
                {
                  if ((int)v8 >= 4
                    && (*(_WORD *)v17 & 0xC0) == 0x40
                    && v8 - 4 == bswap32(*((unsigned __int16 *)v17 + 1)) >> 16)
                  {
                    v23[58] = *(_DWORD *)v17;
                    __int16 v55 = v23 + 58;
                    unsigned int v56 = 4;
                    goto LABEL_115;
                  }
LABEL_97:
                  BOOL v54 = 0;
                  unsigned int v56 = 0;
                  unsigned int v57 = 0;
                }
                else
                {
                  if (v19) {
                    goto LABEL_97;
                  }
                  if (!*((unsigned char *)a2 + 88)) {
                    goto LABEL_97;
                  }
                  signed int v69 = *((__int16 *)a2 + 45);
                  if (v69 < 0x4000) {
                    goto LABEL_97;
                  }
                  unsigned int v56 = 0;
                  *((_WORD *)v23 + 116) = bswap32(v69) >> 16;
                  __int16 v55 = v23 + 58;
                  *((_WORD *)v23 + 117) = bswap32(v8) >> 16;
LABEL_115:
                  *(void *)&long long v92 = v55;
                  *((void *)&v92 + 1) = 4;
                  unsigned int v57 = 1;
                }
                int v58 = *(_DWORD *)a6;
                if ((*((unsigned char *)a6 + 148) & 2) != 0 || (v58 | 4) == 6 && *((unsigned char *)a6 + 12)) {
                  char v59 = 32;
                }
                else {
                  char v59 = 0;
                }
                *(void *)&v89.msg_controllen = 0xAAAAAAAAAAAAAAAALL;
                *(_OWORD *)&v89.msg_namelen = v51;
                *(_OWORD *)&v89.msg_iovlen = v51;
                __int16 v86 = -21846;
                unsigned int v87 = -1431655766;
                __b[0] = v51;
                __b[1] = v51;
                __b[2] = v51;
                __b[3] = v51;
                __b[4] = v51;
                __b[5] = v51;
                __b[6] = v51;
                __b[7] = v51;
                if (v58 != 6 && v58 != 2)
                {
                  if (!v58)
                  {
                    BOOL v60 = (char *)v17 + v56;
                    uint64_t v61 = v57;
                    *((void *)&v92 + 2 * v57) = v60;
                    int v62 = v57 + 1;
                    uint64_t v63 = v8 - v56;
                    socklen_t v64 = v85;
                    goto LABEL_129;
                  }
                  v59 |= 8u;
                }
                LOBYTE(v86) = v59;
                HIBYTE(v86) = v58;
                unsigned int v87 = bswap32(v52);
                long long v65 = (__int16 **)(&v92 + v57);
                unsigned int v66 = v57 + 1;
                *long long v65 = &v86;
                v65[1] = (__int16 *)6;
                if ((v59 & 8) != 0)
                {
                  unsigned int v79 = v57 + 1;
                  char v80 = v59;
                  unsigned int v78 = v57;
                  BOOL v82 = v54;
                  uint64_t v67 = v56;
                  unsigned int v81 = v56;
                  if ((PrepareOFTMAC(*(const __CFString **)(v21 + 8 * *v23 + 6040), (char *)v17 + v56, v8 - v56, v91) & 0x80000000) != 0)
                  {
                    unsigned int v56 = v81;
                    char v59 = v80 ^ 8;
                    LOBYTE(v86) = v80 ^ 8;
                    BOOL v54 = v82;
                    unsigned int v66 = v79;
                  }
                  else
                  {
                    char v59 = v80;
                    uint64_t v68 = &v92 + v79;
                    unsigned int v66 = v78 | 2;
                    *(void *)uint64_t v68 = v91;
                    *((void *)v68 + 1) = 4;
                    BOOL v54 = v82;
                    unsigned int v56 = v81;
                  }
                }
                else
                {
                  uint64_t v67 = v56;
                }
                atomic_ullong v70 = (char *)v17 + v67;
                int v71 = &v92 + v66;
                uint64_t v61 = v66 + 1;
                *(void *)int v71 = v70;
                *((void *)v71 + 1) = v8 - v67;
                if (v19)
                {
                  if (v54) {
                    goto LABEL_119;
                  }
LABEL_127:
                  unsigned int v72 = v66;
                  int v74 = 0;
                }
                else
                {
                  if (*((unsigned char *)a2 + 88)) {
                    char v75 = 1;
                  }
                  else {
                    char v75 = v54;
                  }
                  if ((v75 & 1) == 0) {
                    goto LABEL_127;
                  }
LABEL_119:
                  unsigned int v72 = v66;
                  if ((v59 & 8) != 0) {
                    int v73 = 14;
                  }
                  else {
                    int v73 = 10;
                  }
                  *((_WORD *)v23 + 117) = bswap32(v73 + v8 - v56) >> 16;
                  int v74 = 1;
                }
                socklen_t v64 = v85;
                PrepareOFTCRC32((uint64_t)&v92, v66 + 1, v74, &v88);
                *((void *)&v92 + 2 * v61) = &v88;
                int v62 = v72 + 2;
                uint64_t v63 = 4;
LABEL_129:
                *((void *)&v92 + 2 * v61 + 1) = v63;
                __memcpy_chk();
                if (*((unsigned char *)v23 + 368))
                {
                  VTP_AddNAT64PrefixToIPv4Destination((uint64_t)v23, (uint64_t)__b, &v90);
                  socklen_t v64 = v90;
                }
                v89.msg_name = __b;
                v89.msg_namelen = v64;
                v89.msg_iov = (iovec *)&v92;
                v89.msg_iovlen = v62;
                v89.msg_char flags = 0;
                if (*(unsigned char *)(v21 + 21625))
                {
                  v89.msg_control = 0;
                  v89.msg_controllen = 0;
                }
                else
                {
                  v89.msg_control = &v91[1];
                  v89.msg_controllen = 16;
                  *(void *)&v91[1] = 0xFFFF00000010;
                  v91[3] = 4230;
                  if (*(_DWORD *)(v21 + 21628)) {
                    v91[4] = *(_DWORD *)(v21 + 21628);
                  }
                  else {
                    v91[4] = a5;
                  }
                }
                int v76 = sendmsg(v23[5], &v89, 0);
                kdebug_trace();
                if (v76 >= 1)
                {
                  if (v23[15]) {
                    int v77 = 48;
                  }
                  else {
                    int v77 = 28;
                  }
                  atomic_fetch_add_explicit((atomic_ullong *volatile)v21, v77 + v76, memory_order_relaxed);
                }
                size_t v8 = v76;
LABEL_34:
                pthread_rwlock_unlock(v22);
                CheckOutHandleDebug();
                return v8;
              }
            }
LABEL_29:
            unint64_t v23 = (int *)*((void *)v23 + 44);
            if (!v23) {
              goto LABEL_30;
            }
          }
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VTP_SendWithSourceDestinationInfo_cold_3();
          }
        }
        uint64_t v13 = __error();
        int v14 = 13;
        break;
      case 2u:
        return VTP_SendOnePacketWithSocket(a2[2], a2[3], (unsigned char *)a2 + 16, 0, (uint64_t)buffer, size, a5, (uint64_t)a6, a2[14]);
      case 3u:
        return VTP_SendOnePacketWithSocket(a2[2], a2[3], (unsigned char *)a2 + 16, 1, (uint64_t)buffer, size, a5, (uint64_t)a6, a2[14]);
      case 4u:
        memset(__b, 170, sizeof(__b));
        uint64_t v83 = (void *)*((void *)a2 + 14);
        unint64_t v84 = *(void *)(a2 + 3);
        uint64_t v27 = *((unsigned __int16 *)a2 + 10);
        if (*((unsigned char *)a6 + 168) && *((unsigned char *)a6 + 233) && (a2[24] & 1) == 0)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              _VTP_SendWithSourceDestinationInfo_cold_6();
            }
          }
          uint64_t v13 = __error();
          int v14 = 43;
          break;
        }
        unint64_t v38 = HIDWORD(v84);
        int v39 = *(_DWORD *)a6;
        if (!*(_DWORD *)a6)
        {
          int v44 = v83;
          goto LABEL_69;
        }
        unsigned int v40 = bswap32(*((_DWORD *)a6 + 1));
        LODWORD(v89.msg_name) = 0;
        if ((*((unsigned char *)a6 + 148) & 2) != 0) {
          goto LABEL_60;
        }
        if ((v39 | 4) == 6)
        {
          char v41 = *((unsigned char *)a6 + 12);
          if (v41) {
LABEL_60:
          }
            char v41 = 32;
        }
        else
        {
          char v41 = 0;
        }
        __dst[5] = 0xAAAAAAAAAAAAAAAALL;
        __dst[4] = 0xAAAAAAAAAAAAAAAALL;
        LOBYTE(v92) = v41;
        BYTE1(v92) = v39;
        *(_DWORD *)((char *)&v92 + 2) = v40;
        __dst[0] = &v92;
        __dst[1] = 6;
        __dst[2] = v17;
        __dst[3] = v8;
        PrepareOFTCRC32((uint64_t)__dst, 2, 0, (unsigned int *)&v89);
        uint64_t v42 = 0;
        size_t v8 = 0;
        __dst[4] = &v89;
        __dst[5] = 4;
        do
        {
          size_t v43 = __dst[v42 + 1];
          memcpy((char *)__b + v8, (const void *)__dst[v42], v43);
          v8 += v43;
          v42 += 2;
        }
        while (v42 != 6);
        int v17 = __b;
        int v44 = v83;
        LOBYTE(v38) = BYTE4(v84);
LABEL_69:
        if (a7)
        {
          if (a5 == 700)
          {
            LOBYTE(v38) = -120;
          }
          else if (a5 == 800)
          {
            LOBYTE(v38) = -72;
          }
        }
        char v46 = *((unsigned char *)a6 + 310);
        memset(__dst, 0, 120);
        long long v47 = *((_OWORD *)a6 + 13);
        long long v48 = *((_OWORD *)a6 + 15);
        long long v95 = *((_OWORD *)a6 + 14);
        long long v96 = v48;
        long long v49 = *((_OWORD *)a6 + 11);
        long long v93 = *((_OWORD *)a6 + 12);
        long long v94 = v47;
        long long v92 = v49;
        _VTP_UpdateIDSDatagramOptionWithChannelDataFormat((uint64_t)&v92, (uint64_t)__dst, 1);
        uint64_t v50 = *((unsigned int *)a6 + 72);
        if (v50)
        {
          LODWORD(__dst[0]) |= 0x200u;
          __dst[9] = v50;
        }
        if (v44)
        {
          _VTP_ReportIDSOnTheWireBytesLocked(a1, *((_DWORD *)a6 + 2), v8, (uint64_t)__dst, 1);
          objc_msgSend(v44, "writeDatagram:datagramSize:datagramInfo:options:completionHandler:", v17, v8, v84 & 0xFFFFFF0000000000 | ((unint64_t)(v46 | v38) << 32) | (a5 << 16) | (unint64_t)(unsigned __int16)v84, v27, __dst, 0);
          kdebug_trace();
        }
        else
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              _VTP_SendWithSourceDestinationInfo_cold_5();
            }
          }
          return 0;
        }
        return v8;
      case 5u:
        long long v28 = *((void *)a2 + 1);
        if (!v28) {
          return -1;
        }
        uint64_t v29 = dispatch_data_create(buffer, size, 0, 0);
        uint64_t v30 = a6[32];
        uint64_t v31 = a6[33];
        uint64_t v32 = a6[34];
        unsigned int v33 = nw_content_context_create("AVConferenceNWContext");
        uint64_t v34 = v33;
        uint64_t v35 = *((unsigned int *)a6 + 72);
        if (v35) {
          nw_content_context_set_expiration_milliseconds(v33, v35);
        }
        nw_content_context_set_packet_id();
        memcpy(__dst, a6, 0x148uLL);
        BOOL v36 = a6[40];
        if (v36) {
          goto LABEL_88;
        }
        switch(a5)
        {
          case 0xC8:
            uint64_t v37 = 22072;
            break;
          case 0x320:
            uint64_t v37 = 22056;
            break;
          case 0x2BC:
            uint64_t v37 = 22064;
            break;
          default:
            goto LABEL_89;
        }
        BOOL v36 = *(NSObject **)(a1 + v37);
LABEL_88:
        nw_content_context_set_metadata_for_protocol(v34, v36);
LABEL_89:
        *(void *)&__b[0] = MEMORY[0x1E4F143A8];
        *((void *)&__b[0] + 1) = 3221225472;
        *(void *)&__b[1] = ___VTP_SendOnePacketWithNWConnection_block_invoke;
        *((void *)&__b[1] + 1) = &__block_descriptor_384_e31_v16__0__NSObject_OS_nw_error__8ls88l8s376l8;
        *(void *)&__b[2] = v30;
        *((void *)&__b[2] + 1) = v31;
        *(void *)&__b[3] = v32;
        memcpy((char *)&__b[3] + 8, __dst, 0x148uLL);
        nw_connection_send(v28, v29, v34, 1, __b);
        kdebug_trace();
        nw_release(v34);
        dispatch_release(v29);
        return v8;
      default:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VTP_SendWithSourceDestinationInfo_cold_2();
          }
        }
        return -1;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VTP_SendWithSourceDestinationInfo_cold_1();
      }
    }
    uint64_t v13 = __error();
    int v14 = 22;
  }
  *uint64_t v13 = v14;
  return -1;
}

void _VTP_HealthPrint(uint64_t a1, int a2, unsigned int a3, int a4, int a5)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  if (a3 >= 2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VTP_HealthPrint_cold_1();
      }
    }
    return;
  }
  uint64_t v10 = (_DWORD *)(a1 + 21868);
  uint64_t v11 = a1 + 21880;
  double v12 = micro();
  double v13 = v12;
  int v14 = (_DWORD *)(v11 + 16 * a3);
  if (a5)
  {
    int v15 = v14[1] + a2;
    ++*v14;
    v14[1] = v15;
    if (a4)
    {
      if (a4 == 700)
      {
        int v16 = v10 + 18;
      }
      else
      {
        if (a4 != 800) {
          goto LABEL_21;
        }
        int v16 = v10 + 17;
      }
    }
    else
    {
      int v16 = v10 + 16;
    }
    ++*v16;
LABEL_21:
    double v34 = v12 - *(double *)(a1 + 21944);
    if (v34 > 0.0 && v34 > 5.0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        uint64_t v36 = VRTraceErrorLogLevelToCSTR();
        uint64_t v37 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v38 = v10[3];
          int v39 = v10[4];
          int v40 = v10[7];
          int v41 = v10[8];
          int v45 = 136318210;
          int v43 = v10[17];
          int v42 = v10[18];
          int v44 = v10[16];
          uint64_t v46 = v36;
          __int16 v47 = 2080;
          long long v48 = "_VTP_HealthPrint";
          __int16 v49 = 1024;
          int v50 = 2870;
          __int16 v51 = 1024;
          int v52 = v38;
          __int16 v53 = 1024;
          int v54 = v40;
          __int16 v55 = 1024;
          int v56 = v39;
          __int16 v57 = 1024;
          int v58 = v41;
          __int16 v59 = 2048;
          double v60 = v34;
          __int16 v61 = 2048;
          double v62 = (double)(8 * v39) / v34 / 1000.0;
          __int16 v63 = 2048;
          double v64 = (double)(8 * v41) / v34 / 1000.0;
          __int16 v65 = 1024;
          int v66 = v43;
          __int16 v67 = 1024;
          int v68 = v42;
          __int16 v69 = 1024;
          int v70 = v44;
          _os_log_impl(&dword_1E1EA4000, v37, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d @=@ Health: VTransport Health Monitor for VTP Send packet count:[%d %d], byte count:[%d %d], interval:%.3fs, rate:[%.3f %.3fkbps], VO=%u, VI=%u, BE=%u", (uint8_t *)&v45, 0x64u);
        }
      }
      *(double *)(a1 + 21944) = v13;
      *(void *)(a1 + 21880) = 0;
      *(void *)(a1 + 21896) = 0;
      v10[18] = 0;
      *((void *)v10 + 8) = 0;
    }
    return;
  }
  int v17 = v14[3] + a2;
  ++v14[2];
  v14[3] = v17;
  double v18 = v12 - *(double *)(a1 + 21952);
  if (v18 > 0.0 && v18 > 5.0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      uint64_t v20 = VRTraceErrorLogLevelToCSTR();
      uint64_t v21 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v22 = v10[5];
        int v23 = v10[6];
        int v24 = v10[9];
        int v25 = v10[10];
        int v26 = v10[11];
        int v27 = v10[12];
        int v28 = v10[13];
        int v29 = v10[14];
        int v30 = v10[15];
        int v31 = *v10;
        int v45 = 136319490;
        double v32 = *(double *)(a1 + 21872);
        int v33 = v10[37];
        uint64_t v46 = v20;
        __int16 v47 = 2080;
        long long v48 = "_VTP_HealthPrint";
        __int16 v49 = 1024;
        int v50 = 2901;
        __int16 v51 = 1024;
        int v52 = v22;
        __int16 v53 = 1024;
        int v54 = v24;
        __int16 v55 = 1024;
        int v56 = v23;
        __int16 v57 = 1024;
        int v58 = v25;
        __int16 v59 = 2048;
        double v60 = v18;
        __int16 v61 = 2048;
        double v62 = (double)(8 * v23) / v18 / 1000.0;
        __int16 v63 = 2048;
        double v64 = (double)(8 * v25) / v18 / 1000.0;
        __int16 v65 = 1024;
        int v66 = v26;
        __int16 v67 = 1024;
        int v68 = v27;
        __int16 v69 = 1024;
        int v70 = v28;
        __int16 v71 = 1024;
        int v72 = v29;
        __int16 v73 = 1024;
        int v74 = v30;
        __int16 v75 = 1024;
        int v76 = v31;
        __int16 v77 = 2048;
        double v78 = v32 * 1000.0;
        __int16 v79 = 1024;
        int v80 = v33;
        _os_log_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d @=@ Health: VTransport Health Monitor for VTP Recv packet count:[%d %d], byte count:[%d %d], interval:%.3fs, rate:[%.3f %.3f]kbps, demuxPackets:[%u, %u, %u, %u, %u], maxQueueLength:%d, maxQueueDelay:%.2fms statsCount:%d", (uint8_t *)&v45, 0x86u);
      }
    }
    *(double *)(a1 + 21952) = v13;
    *(void *)(a1 + 21888) = 0;
    *(void *)(a1 + 21904) = 0;
    *(_DWORD *)(a1 + 21928) = 0;
    *(void *)(a1 + 21920) = 0;
    *(void *)(a1 + 21912) = 0;
    *(void *)(a1 + 21872) = 0;
    *uint64_t v10 = 0;
  }
}

uint64_t VTP_SendCompoundPacket(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  uint64_t v111 = *MEMORY[0x1E4F143B8];
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SendCompoundPacket_cold_1();
      }
    }
    goto LABEL_86;
  }
  uint64_t v6 = v3;
  if (!v3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SendCompoundPacket_cold_2();
      }
    }
    goto LABEL_86;
  }
  uint64_t v7 = v2;
  if (!v2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SendCompoundPacket_cold_3();
      }
    }
    goto LABEL_86;
  }
  unsigned int v8 = v5;
  if (v5 <= 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SendCompoundPacket_cold_4();
      }
    }
LABEL_86:
    double v64 = __error();
    int v65 = 22;
LABEL_87:
    *double v64 = v65;
    return -1;
  }
  uint64_t v9 = v4;
  int v10 = v1;
  uint64_t v11 = CheckInHandleDebug();
  if (!v11)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SendCompoundPacket_cold_5();
      }
    }
    double v64 = __error();
    int v65 = 13;
    goto LABEL_87;
  }
  uint64_t v12 = v11;
  uint64_t v75 = v7;
  double v13 = (pthread_rwlock_t *)(v11 + 21648);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v11 + 21648));
  int v14 = *(_DWORD *)(v9 + 8);
  int v72 = v13;
  if (!v14)
  {
    *__error() = 22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SendCompoundPacket_cold_6();
      }
    }
    goto LABEL_102;
  }
  int v15 = (void *)VTP_getConnectionManagerForCallID(v12, v14);
  v92[0] = *(unsigned char *)(v9 + 169);
  v92[1] = 0;
  v92[2] = *(unsigned char *)(v9 + 309);
  v92[3] = *(unsigned char *)(v9 + 233);
  uint8_t v92[4] = *(unsigned char *)(v9 + 312);
  PacketRoutingInfoList = VCConnectionManager_CreatePacketRoutingInfoList((uint64_t)v15, v92, *(const __CFAllocator **)(v12 + 22048));
  if (!PacketRoutingInfoList)
  {
    *__error() = 22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v67 = VRTraceErrorLogLevelToCSTR();
      int v68 = *MEMORY[0x1E4F47A50];
      __int16 v69 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          uint64_t v98 = v67;
          __int16 v99 = 2080;
          uint64_t v100 = "VTP_SendCompoundPacket";
          __int16 v101 = 1024;
          int v102 = 3100;
          _os_log_impl(&dword_1E1EA4000, v68, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d infoList is NULL! Dropped packet!", buf, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
      {
        VTP_SendCompoundPacket_cold_7();
      }
    }
LABEL_102:
    pthread_rwlock_unlock(v72);
    uint64_t v24 = -1;
    goto LABEL_82;
  }
  int v17 = PacketRoutingInfoList;
  uint64_t v18 = VCConnectionManager_CopyConnectionForQuality((uint64_t)v15, 1);
  uint64_t v20 = (const void *)v18;
  double v78 = (unsigned __int8 *)(v12 + 21624);
  uint64_t v77 = (v10 << 16);
  uint64_t v85 = v8;
  BOOL v22 = v10 == 800 || v10 == 700;
  int v83 = 0;
  int v84 = v22;
  uint64_t v87 = 328 * v8;
  __int16 v73 = (unsigned __int16 *)(v9 + 220);
  unsigned int v23 = -1;
  uint64_t v24 = -1;
  *(void *)&long long v19 = 136315650;
  long long v70 = v19;
  ptr = v17;
  unsigned int v80 = v8;
  uint64_t v88 = v6;
  int v76 = v10;
  uint64_t v90 = v12;
  int v74 = v15;
  __int16 v79 = (const void *)v18;
  do
  {
    uint64_t v86 = (uint64_t)(v17 + 8);
    if (*((_DWORD *)v17 + 2) != 4) {
      goto LABEL_60;
    }
    if (*(unsigned char *)(v9 + 255)) {
      BOOL v25 = 1;
    }
    else {
      BOOL v25 = *v17 != 0;
    }
    *(unsigned char *)(v9 + 255) = v25;
    int v26 = (void *)*((void *)v17 + 15);
    int v91 = VCConnectionIDS_LinkID((uint64_t)v20);
    if (v8 >= 0x1F)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v27 = VRTraceErrorLogLevelToCSTR();
        int v28 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316162;
          uint64_t v98 = v27;
          __int16 v99 = 2080;
          uint64_t v100 = "_VTP_SendCompoundPacketWithDatagramChannel";
          __int16 v101 = 1024;
          int v102 = 5223;
          __int16 v103 = 1024;
          int v104 = v8;
          __int16 v105 = 1024;
          int v106 = 30;
          int v29 = buf;
          int v30 = v28;
          int v31 = " [%s] %s:%d Datagram count %d is larger than VTP max compound packet datagram count %d";
          uint32_t v32 = 40;
LABEL_66:
          _os_log_error_impl(&dword_1E1EA4000, v30, OS_LOG_TYPE_ERROR, v31, v29, v32);
        }
      }
      goto LABEL_56;
    }
    unint64_t v33 = *(void *)(v17 + 20);
    __int16 v89 = *((_WORD *)v17 + 14);
    unint64_t v34 = HIDWORD(v33);
    int v35 = *v78;
    memset(v110, 0, 300);
    memset(v109, 0, sizeof(v109));
    bzero(buf, 0xE10uLL);
    uint64_t v81 = v26;
    BOOL v82 = v17;
    if (v35)
    {
      if (v10 == 700)
      {
        LOBYTE(v34) = -120;
      }
      else if (v10 == 800)
      {
        LOBYTE(v34) = -72;
      }
    }
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    LODWORD(v24) = 0;
    int v38 = (char)v33;
    int v39 = &v110[8];
    unint64_t v40 = v33 & 0xFFFFFF000000FFFFLL | v77 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v34 << 32);
    int v41 = buf;
    do
    {
      if (*(_DWORD *)(v9 + v36))
      {
        unsigned int v8 = v80;
        int v10 = v76;
        uint64_t v12 = v90;
        uint64_t v20 = v79;
        int v17 = v82;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          uint64_t v55 = VRTraceErrorLogLevelToCSTR();
          int v56 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long v93 = v70;
            *(void *)&v93[4] = v55;
            *(_WORD *)&v93[12] = 2080;
            *(void *)&v93[14] = "_VTP_SendCompoundPacketWithDatagramChannel";
            *(_WORD *)&v93[22] = 1024;
            *(_DWORD *)&v93[24] = 5243;
            int v29 = v93;
            int v30 = v56;
            int v31 = " [%s] %s:%d Cannot not handle open facetime with IDS compound packet";
LABEL_65:
            uint32_t v32 = 28;
            goto LABEL_66;
          }
        }
LABEL_56:
        uint64_t v24 = -1;
        int v59 = v83;
        goto LABEL_57;
      }
      uint64_t v42 = v9;
      uint64_t v43 = v9 + v36;
      if (*(unsigned char *)(v43 + 313))
      {
        int v10 = v76;
        uint64_t v20 = v79;
        int v17 = v82;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          uint64_t v57 = VRTraceErrorLogLevelToCSTR();
          int v58 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long v93 = v70;
            *(void *)&v93[4] = v57;
            *(_WORD *)&v93[12] = 2080;
            *(void *)&v93[14] = "_VTP_SendCompoundPacketWithDatagramChannel";
            *(_WORD *)&v93[22] = 1024;
            *(_DWORD *)&v93[24] = 5247;
            _os_log_error_impl(&dword_1E1EA4000, v58, OS_LOG_TYPE_ERROR, " [%s] %s:%d Un-encrypted/un-authenticated packet detected. Dropping...", v93, 0x1Cu);
          }
        }
        *__error() = 81;
        unsigned int v8 = v80;
        uint64_t v9 = v42;
        uint64_t v12 = v90;
        goto LABEL_56;
      }
      long long v44 = *(_OWORD *)(v43 + 224);
      long long v94 = *(_OWORD *)(v43 + 208);
      long long v95 = v44;
      long long v96 = *(_OWORD *)(v43 + 240);
      long long v45 = *(_OWORD *)(v43 + 192);
      *(_OWORD *)long long v93 = *(_OWORD *)(v43 + 176);
      *(_OWORD *)&v93[16] = v45;
      _VTP_UpdateIDSDatagramOptionWithChannelDataFormat((uint64_t)v93, (uint64_t)v41, v38 == v91);
      kdebug_trace();
      *((void *)v39 - 1) = v40;
      _WORD *v39 = v89;
      v39 += 5;
      v109[v37] = v41;
      uint64_t v46 = *(unsigned int *)(v88 + 4 * v37);
      uint64_t v24 = (v46 + v24);
      _VTP_ReportIDSOnTheWireBytesLocked(v90, *(_DWORD *)(v43 + 8), v46, (uint64_t)v41, 1);
      ++v37;
      v36 += 328;
      v41 += 120;
      uint64_t v9 = v42;
    }
    while (v87 != v36);
    if (!v81)
    {
      unsigned int v8 = v80;
      int v10 = v76;
      uint64_t v12 = v90;
      uint64_t v20 = v79;
      int v17 = v82;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v60 = VRTraceErrorLogLevelToCSTR();
        __int16 v61 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long v93 = v70;
          *(void *)&v93[4] = v60;
          *(_WORD *)&v93[12] = 2080;
          *(void *)&v93[14] = "_VTP_SendCompoundPacketWithDatagramChannel";
          *(_WORD *)&v93[22] = 1024;
          *(_DWORD *)&v93[24] = 5267;
          int v29 = v93;
          int v30 = v61;
          int v31 = " [%s] %s:%d nil datagramChannel passed";
          goto LABEL_65;
        }
      }
      goto LABEL_56;
    }
    unsigned int v8 = v80;
    [v81 writeDatagrams:v75 datagramsSize:v88 datagramsInfo:v110 datagramsCount:v80 options:v109 completionHandler:0];
    uint64_t v20 = v79;
    if (v24 || *(unsigned char *)(v42 + 218))
    {
      uint64_t v47 = 0;
      long long v48 = v73;
      do
      {
        if (v24) {
          uint64_t v49 = *(unsigned int *)(v88 + 4 * v47);
        }
        else {
          uint64_t v49 = 0;
        }
        VCConnectionManager_UpdateTransmittedPacketsAndBytes((uint64_t)v74, v86, v49, v84, *((unsigned char *)v48 - 15) != 0, *((unsigned __int8 *)v48 - 20), *((unsigned char *)v48 - 16) != 0);
        if (*((unsigned char *)v48 - 2))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            uint64_t v50 = VRTraceErrorLogLevelToCSTR();
            __int16 v51 = *MEMORY[0x1E4F47A50];
            int v52 = *MEMORY[0x1E4F47A50];
            if (*MEMORY[0x1E4F47A40])
            {
              if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
              {
                int v53 = *v48;
                *(_DWORD *)buf = 136316418;
                uint64_t v98 = v50;
                __int16 v99 = 2080;
                uint64_t v100 = "VTP_SendCompoundPacket";
                __int16 v101 = 1024;
                int v102 = 3120;
                __int16 v103 = 1024;
                int v104 = 3120;
                __int16 v105 = 1024;
                int v106 = v47;
                __int16 v107 = 1024;
                int v108 = v53;
                _os_log_impl(&dword_1E1EA4000, v51, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: index=%d, statsID = %d", buf, 0x2Eu);
              }
            }
            else if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
            {
              int v54 = *v48;
              *(_DWORD *)buf = 136316418;
              uint64_t v98 = v50;
              __int16 v99 = 2080;
              uint64_t v100 = "VTP_SendCompoundPacket";
              __int16 v101 = 1024;
              int v102 = 3120;
              __int16 v103 = 1024;
              int v104 = 3120;
              __int16 v105 = 1024;
              int v106 = v47;
              __int16 v107 = 1024;
              int v108 = v54;
              _os_log_debug_impl(&dword_1E1EA4000, v51, OS_LOG_TYPE_DEBUG, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: index=%d, statsID = %d", buf, 0x2Eu);
            }
          }
          objc_msgSend(v74, "updateSessionStats:", *v48, v70);
        }
        v48 += 164;
        ++v47;
      }
      while (v85 != v47);
    }
    else
    {
      uint64_t v24 = 0;
    }
    int v10 = v76;
    uint64_t v12 = v90;
    int v59 = v83;
    int v17 = v82;
LABEL_57:
    unsigned int v23 = v59 != 0;
    if (!v59) {
      int v59 = 1;
    }
    int v83 = v59;
LABEL_60:
    int v17 = (unsigned char *)*((void *)v17 + 16);
    _VTP_HealthPrint(v12, v24, v23, v10, 1);
  }
  while (v17);
  if (v20) {
    CFRelease(v20);
  }
  pthread_rwlock_unlock(v72);
  double v62 = ptr;
  do
  {
    __int16 v63 = (void *)v62[16];
    CFAllocatorDeallocate(*(CFAllocatorRef *)(v12 + 22048), v62);
    double v62 = v63;
  }
  while (v63);
LABEL_82:
  CheckOutHandleDebug();
  return v24;
}

void VTP_GetReportingStats(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (atomic_ullong *)CheckInHandleDebug();
    if (v2)
    {
      a1[3] = atomic_fetch_add_explicit(v2 + 2748, 0, memory_order_relaxed);
      a1[2] = atomic_fetch_add_explicit(v2 + 2748, 0, memory_order_relaxed);
      *a1 = atomic_fetch_add_explicit(v2 + 2745, 0, memory_order_relaxed);
      a1[1] = atomic_fetch_add_explicit(v2 + 2746, 0, memory_order_relaxed);
      CheckOutHandleDebug();
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_GetReportingStats_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VTP_GetReportingStats_cold_1();
    }
  }
}

uint64_t VTP_SendWithSourceDestinationIP(uint64_t a1, uint64_t a2, _OWORD *a3, size_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = CheckInHandleDebug();
  if (v12)
  {
    uint64_t v13 = v12;
    unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v22[5] = v14;
    v22[6] = v14;
    v22[3] = v14;
    v22[4] = v14;
    v22[1] = v14;
    v22[2] = v14;
    v22[0] = v14;
    VCSDInfoConstructWithIPPorts(a1, a2, 0, 0, (uint64_t)v22);
    uint64_t v15 = _VTP_SendWithSourceDestinationInfo(v13, (unsigned int *)v22, a3, a4, a5, (void *)a6, 0);
    if (v15 >= 1)
    {
      int v16 = *(_DWORD *)(a6 + 8);
      if (v16)
      {
        uint64_t v17 = CheckInHandleDebug();
        if (v17)
        {
          uint64_t v18 = v17;
          long long v19 = (pthread_rwlock_t *)(v17 + 21648);
          pthread_rwlock_rdlock((pthread_rwlock_t *)(v17 + 21648));
          uint64_t v20 = VTP_getConnectionManagerForCallID(v18, v16);
          VCConnectionManager_UpdateTransmittedPacketsAndBytes((uint64_t)v20, (uint64_t)v22, v15, 0, 0, 0, 0);
          pthread_rwlock_unlock(v19);
          CheckOutHandleDebug();
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VTP_SendWithSourceDestinationIP_cold_2();
          }
        }
      }
    }
    CheckOutHandleDebug();
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SendWithSourceDestinationIP_cold_1();
      }
    }
    *__error() = 13;
    return -1;
  }
  return v15;
}

void VTP_ReleasePacket(void **a1)
{
  if (a1 && *a1)
  {
    uint64_t v2 = CheckInHandleDebug();
    if (v2)
    {
      uint64_t v3 = v2;
      VCBlockBuffer_Clear((uint64_t)*a1 + 512);
      VCMemoryPool_Free(*(OSQueueHead **)(v3 + 22040), *a1);
      *a1 = 0;
      CheckOutHandleDebug();
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_ReleasePacket_cold_1();
      }
    }
  }
}

uint64_t VTP_Recvfrom(int a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = 2148991018;
  if (!a2) {
    return 2148990977;
  }
  unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
  *a2 = 0;
  uint64_t v5 = CheckInHandleDebug();
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = (pthread_rwlock_t *)(v5 + 5376);
    pthread_rwlock_rdlock((pthread_rwlock_t *)(v5 + 5376));
    unsigned int v8 = *(int **)(v6 + 5576);
    if (v8)
    {
      while (*v8 != a1)
      {
        unsigned int v8 = (int *)*((void *)v8 + 44);
        if (!v8) {
          goto LABEL_6;
        }
      }
      pthread_mutex_lock((pthread_mutex_t *)(v8 + 60));
      ++v8[56];
      pthread_mutex_unlock((pthread_mutex_t *)(v8 + 60));
      pthread_rwlock_unlock(v7);
      pthread_mutex_lock((pthread_mutex_t *)(v8 + 28));
      unint64_t v9 = *((void *)v8 + 13);
      if (!v9)
      {
        while (!*((unsigned char *)v8 + 25))
        {
          pthread_cond_wait((pthread_cond_t *)(v8 + 44), (pthread_mutex_t *)(v8 + 28));
          unint64_t v9 = *((void *)v8 + 13);
          if (v9) {
            goto LABEL_17;
          }
        }
        goto LABEL_18;
      }
LABEL_17:
      if (*((unsigned char *)v8 + 25))
      {
LABEL_18:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          uint64_t v10 = VRTraceErrorLogLevelToCSTR();
          uint64_t v11 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            uint64_t v23 = v10;
            __int16 v24 = 2080;
            BOOL v25 = "VTP_Recvfrom";
            __int16 v26 = 1024;
            int v27 = 3522;
            _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_Recvfrom failed due to socket already closed", buf, 0x1Cu);
          }
        }
        *__error() = 9;
        uint64_t v12 = 2148991009;
        goto LABEL_34;
      }
      unint64_t v21 = v9;
      uint64_t v13 = (char *)VCMemoryPool_Alloc(*(OSQueueHead **)(v6 + 22040));
      uint64_t v20 = v13;
      if (!v13)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          uint64_t v17 = VRTraceErrorLogLevelToCSTR();
          uint64_t v18 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            uint64_t v23 = v17;
            __int16 v24 = 2080;
            BOOL v25 = "VTP_Recvfrom";
            __int16 v26 = 1024;
            int v27 = 3529;
            _os_log_impl(&dword_1E1EA4000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_Recvfrom failed to allocate packet info", buf, 0x1Cu);
          }
        }
        *__error() = 9;
        uint64_t v12 = 2148991009;
        goto LABEL_33;
      }
      long long v14 = v13;
      memcpy(v13 + 8, (const void *)(v9 + 48), *(unsigned int *)(v9 + 176));
      *((_DWORD *)v14 + 34) = *(_DWORD *)(v9 + 176);
      *(void *)long long v14 = *(void *)(v9 + 184);
      long long v15 = *(_OWORD *)(v9 + 8);
      long long v16 = *(_OWORD *)(v9 + 24);
      *(void *)(v14 + 172) = *(void *)(v9 + 40);
      *(_OWORD *)(v14 + 156) = v16;
      *(_OWORD *)(v14 + 140) = v15;
      if (*(unsigned char *)(v9 + 223)) {
        *((_DWORD *)v14 + 35) |= 1u;
      }
      memcpy(v14 + 184, (const void *)(v9 + 208), 0x148uLL);
      if (!*(unsigned char *)(v9 + 220) || (*(_DWORD *)(v9 + 208) | 4) == 6)
      {
        VCBlockBuffer_Copy(v9 + 544, (uint64_t)(v14 + 512));
        uint64_t v12 = 0;
LABEL_28:
        *a2 = v14;
LABEL_33:
        *((void *)v8 + 13) = *(void *)(v9 + 536);
        _VTP_ReleasePacket(v6, (void **)&v21);
LABEL_34:
        pthread_mutex_unlock((pthread_mutex_t *)(v8 + 28));
        pthread_mutex_lock((pthread_mutex_t *)(v8 + 60));
        --v8[56];
        pthread_cond_signal((pthread_cond_t *)(v8 + 76));
        pthread_mutex_unlock((pthread_mutex_t *)(v8 + 60));
        CheckOutHandleDebug();
        return v12;
      }
      uint64_t v12 = DTLS_Read(*(void *)(v6 + 8 * *v8 + 13432), *(OpaqueCMBlockBuffer **)(v9 + 544), (CMBlockBufferRef *)v14 + 64, *(const __CFAllocator **)(v6 + 22024), *(const __CFAllocator **)(v6 + 22032));
      if ((v12 & 0x80000000) == 0)
      {
        if (CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(v9 + 544), 0, 0, (size_t *)v14 + 65, (char **)v14 + 66))
        {
          goto LABEL_28;
        }
        uint64_t v12 = 2148990980;
      }
      VTP_ReleasePacket(&v20);
      goto LABEL_33;
    }
LABEL_6:
    pthread_rwlock_unlock(v7);
    CheckOutHandleDebug();
    *__error() = 9;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Recvfrom_cold_2();
      }
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Recvfrom_cold_1();
      }
    }
    *__error() = 13;
    return 2148990978;
  }
  return v2;
}

uint64_t VTP_SetAFRCRecvMode(uint64_t a1, int a2)
{
  uint64_t v4 = CheckInHandleDebug();
  if (v4)
  {
    *(void *)(v4 + 5888) = a1;
    *(unsigned char *)(v4 + 5896) = a2 != 0;
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SetAFRCRecvMode_cold_1();
      }
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
}

uint64_t VTP_SetAFRC(int a1, uint64_t a2)
{
  uint64_t v4 = CheckInHandleDebug();
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = (pthread_rwlock_t *)(v4 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
    uint64_t v7 = *(void *)(v5 + 5576);
    if (v7)
    {
      while (*(_DWORD *)v7 != a1 || (*(unsigned char *)(v7 + 28) & 0xF0) == 0)
      {
        uint64_t v7 = *(void *)(v7 + 352);
        if (!v7) {
          goto LABEL_6;
        }
      }
      int v9 = 0;
      uint64_t v8 = 0;
      *(void *)(v7 + 360) = a2;
    }
    else
    {
LABEL_6:
      uint64_t v8 = 0xFFFFFFFFLL;
      int v9 = 1;
    }
    pthread_rwlock_unlock(v6);
    CheckOutHandleDebug();
    if (v9) {
      *__error() = 9;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SetAFRC_cold_1();
      }
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  return v8;
}

uint64_t VTP_SetAFRCConnectionNumber(int a1)
{
  uint64_t v2 = CheckInHandleDebug();
  if (v2)
  {
    AFRCSetConnectionNumber(*(void *)(v2 + 5888), a1);
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SetAFRCConnectionNumber_cold_1();
      }
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
}

uint64_t VTP_NotifyAFRCRxEstimate(uint64_t a1, char a2, unint64_t a3, int a4, int a5, double a6)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1 == 0xFFFFFFFFLL)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v7 = VRTraceErrorLogLevelToCSTR();
      uint64_t v8 = *MEMORY[0x1E4F47A50];
      if (!*MEMORY[0x1E4F47A40])
      {
        uint64_t v6 = 2;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEBUG)) {
          VTP_NotifyAFRCRxEstimate_cold_1();
        }
        return v6;
      }
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v11 = 136315650;
        uint64_t v12 = v7;
        __int16 v13 = 2080;
        long long v14 = "VTP_NotifyAFRCRxEstimate";
        __int16 v15 = 1024;
        int v16 = 3810;
        _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_NotifyAFRCRxEstimate INVALID_HANDLE", (uint8_t *)&v11, 0x1Cu);
      }
    }
    return 2;
  }
  if ((a2 & 0x10) != 0)
  {
    uint64_t v10 = 0;
  }
  else
  {
    if ((a2 & 0x20) == 0)
    {
      uint64_t v6 = 2148991010;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_NotifyAFRCRxEstimate_cold_2();
        }
      }
      return v6;
    }
    uint64_t v10 = 1;
  }

  return RTPNotifyAFRCRxEstimate(a1, v10, a3, a4, a5, a6);
}

uint64_t VTP_RegisterPacketCallback(_OWORD *a1, uint64_t a2, const void *a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (!a1 || !a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_RegisterPacketCallback_cold_1();
      }
    }
    uint64_t v17 = __error();
    int v18 = 22;
    goto LABEL_23;
  }
  uint64_t v6 = CheckInHandleDebug();
  if (!v6)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_RegisterPacketCallback_cold_2();
      }
    }
    uint64_t v17 = __error();
    int v18 = 13;
LABEL_23:
    int *v17 = v18;
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = v6;
  long long v8 = a1[4];
  long long v9 = a1[6];
  long long v10 = a1[7];
  __s1[5] = a1[5];
  __s1[6] = v9;
  __s1[7] = v10;
  long long v11 = a1[1];
  __s1[0] = *a1;
  __s1[1] = v11;
  long long v12 = a1[3];
  __int16 v13 = (pthread_rwlock_t *)(v6 + 5376);
  __s1[2] = a1[2];
  __s1[3] = v12;
  __s1[4] = v8;
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v6 + 5376));
  for (uint64_t i = *(void *)(v7 + 5576); i; uint64_t i = *(void *)(i + 352))
  {
    int v15 = *(_DWORD *)i;
    if (__darwin_check_fd_set_overflow(*(_DWORD *)i, __s1, 0)) {
      *(_DWORD *)((char *)__s1 + (((unint64_t)v15 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) &= ~(1 << v15);
    }
  }
  if (!memcmp(__s1, &VTP_RegisterPacketCallback_zeros, 0x80uLL))
  {
    uint64_t v23 = 0;
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v7 + 5584));
    AddOneVFDSETList(v7, &v23, (uint64_t)a1, 0, 0, a3, a2);
    pthread_rwlock_unlock((pthread_rwlock_t *)(v7 + 5584));
    if (v23)
    {
      uint64_t v16 = *v23;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        uint64_t v20 = VRTraceErrorLogLevelToCSTR();
        unint64_t v21 = *MEMORY[0x1E4F47A50];
        BOOL v22 = *MEMORY[0x1E4F47A50];
        if (*MEMORY[0x1E4F47A40])
        {
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            uint64_t v25 = v20;
            __int16 v26 = 2080;
            int v27 = "VTP_RegisterPacketCallback";
            __int16 v28 = 1024;
            int v29 = 4307;
            __int16 v30 = 1024;
            int v31 = v16;
            _os_log_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Successfully added new vfd set with id: %d", buf, 0x22u);
          }
        }
        else if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
        {
          VTP_RegisterPacketCallback_cold_4();
        }
      }
      goto LABEL_14;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_RegisterPacketCallback_cold_3();
      }
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_RegisterPacketCallback_cold_5();
      }
    }
    *__error() = 9;
  }
  uint64_t v16 = 0xFFFFFFFFLL;
LABEL_14:
  pthread_rwlock_unlock(v13);
  CheckOutHandleDebug();
  return v16;
}

_DWORD *AddOneVFDSETList(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7)
{
  long long v14 = (char *)malloc_type_calloc(1uLL, 0xB0uLL, 0x10A0040C283F163uLL);
  if (v14)
  {
    int v15 = v14;
    pthread_mutex_init((pthread_mutex_t *)(v14 + 8), 0);
    pthread_cond_init((pthread_cond_t *)(v15 + 72), 0);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 4288));
    uint64_t v16 = 0;
    while (*(unsigned char *)(a1 + 4352 + v16))
    {
      if (++v16 == 1024)
      {
        LODWORD(v16) = -1;
        goto LABEL_11;
      }
    }
    *(unsigned char *)(a1 + v16 + 4352) = 1;
LABEL_11:
    uint64_t result = (_DWORD *)pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4288));
    *(_DWORD *)int v15 = v16;
    *((void *)v15 + 16) = a3;
    *((void *)v15 + 17) = a4;
    *((void *)v15 + 18) = a5;
    if (a6)
    {
      uint64_t result = _Block_copy(a6);
      *((void *)v15 + 20) = result;
      *((void *)v15 + 21) = a7;
    }
    uint64_t v18 = *(void *)(a1 + 5784);
    if (v18)
    {
      do
      {
        uint64_t v19 = v18;
        uint64_t v18 = *(void *)(v18 + 152);
      }
      while (v18);
      uint64_t v20 = (void *)(v19 + 152);
    }
    else
    {
      uint64_t v20 = (void *)(a1 + 5784);
    }
    *uint64_t v20 = v15;
    *a2 = v15;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if (VRTraceIsOSFaultDisabled())
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          AddOneVFDSETList_cold_1();
        }
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
      {
        AddOneVFDSETList_cold_2();
      }
    }
    uint64_t result = __error();
    *uint64_t result = 12;
  }
  return result;
}

void VTP_UnregisterPacketCallback(int a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = CheckInHandleDebug();
  if (v2)
  {
    uint64_t v3 = v2;
    uint64_t v4 = (pthread_rwlock_t *)(v2 + 5376);
    pthread_rwlock_rdlock((pthread_rwlock_t *)(v2 + 5376));
    uint64_t v5 = (pthread_rwlock_t *)(v3 + 5584);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 5584));
    RemoveOneVFDSETList(v3, a1);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      uint64_t v6 = VRTraceErrorLogLevelToCSTR();
      uint64_t v7 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v8 = 136315906;
        uint64_t v9 = v6;
        __int16 v10 = 2080;
        long long v11 = "VTP_UnregisterPacketCallback";
        __int16 v12 = 1024;
        int v13 = 4329;
        __int16 v14 = 1024;
        int v15 = a1;
        _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Successfully removed vfd set with id: %d", (uint8_t *)&v8, 0x22u);
      }
    }
    pthread_rwlock_unlock(v5);
    pthread_rwlock_unlock(v4);
    CheckOutHandleDebug();
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VTP_UnregisterPacketCallback_cold_1();
    }
  }
}

void RemoveOneVFDSETList(uint64_t a1, int a2)
{
  uint64_t v2 = *(_DWORD **)(a1 + 5784);
  if (v2)
  {
    uint64_t v4 = (void *)(a1 + 5784);
    uint64_t v5 = (pthread_mutex_t *)(a1 + 4288);
    uint64_t v6 = (unsigned char *)(a1 + a2 + 4352);
    do
    {
      if (*v2 == a2)
      {
        pthread_mutex_lock(v5);
        unsigned char *v6 = 0;
        pthread_mutex_unlock(v5);
        uint64_t v7 = (const void *)*((void *)v2 + 20);
        if (v7) {
          _Block_release(v7);
        }
        *uint64_t v4 = *((void *)v2 + 19);
        pthread_mutex_destroy((pthread_mutex_t *)(v2 + 2));
        pthread_cond_destroy((pthread_cond_t *)(v2 + 18));
        free(v2);
      }
      else
      {
        uint64_t v4 = v2 + 38;
      }
      uint64_t v2 = (_DWORD *)*v4;
    }
    while (*v4);
  }
}

uint64_t VTP_Select(uint64_t a1, long long *a2, long long *a3, long long *a4, uint64_t a5)
{
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  uint64_t v55 = 0;
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v86 = v9;
  long long v87 = v9;
  long long v84 = v9;
  long long v85 = v9;
  long long v82 = v9;
  long long v83 = v9;
  long long __src = v9;
  long long v81 = v9;
  uint64_t v10 = CheckInHandleDebug();
  if (!v10)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_Select_cold_1();
      }
    }
    int v13 = __error();
    int v14 = 13;
    goto LABEL_26;
  }
  uint64_t v11 = v10;
  if (a5) {
    double v12 = micro() + (double)*(int *)(a5 + 8) / 1000000.0 + (double)*(uint64_t *)a5;
  }
  else {
    double v12 = 0.0;
  }
  long long v86 = 0u;
  long long v87 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v82 = 0u;
  long long v83 = 0u;
  long long __src = 0u;
  long long v81 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  if (a2)
  {
    long long v15 = a2[5];
    long long v84 = a2[4];
    long long v85 = v15;
    long long v16 = a2[7];
    long long v86 = a2[6];
    long long v87 = v16;
    long long v17 = a2[1];
    long long __src = *a2;
    long long v81 = v17;
    long long v18 = a2[3];
    long long v82 = a2[2];
    long long v83 = v18;
  }
  if (a3)
  {
    long long v19 = a3[5];
    long long v76 = a3[4];
    long long v77 = v19;
    long long v20 = a3[7];
    long long v78 = a3[6];
    long long v79 = v20;
    long long v21 = a3[1];
    long long v72 = *a3;
    long long v73 = v21;
    long long v22 = a3[3];
    long long v74 = a3[2];
    long long v75 = v22;
  }
  if (a4)
  {
    long long v23 = a4[5];
    long long v68 = a4[4];
    long long v69 = v23;
    long long v24 = a4[7];
    long long v70 = a4[6];
    long long v71 = v24;
    long long v25 = a4[1];
    long long v64 = *a4;
    long long v65 = v25;
    long long v26 = a4[3];
    long long v66 = a4[2];
    long long v67 = v26;
  }
  long long v63 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long __s1 = 0u;
  if (a2)
  {
    long long v27 = a2[5];
    long long v60 = a2[4];
    long long v61 = v27;
    long long v28 = a2[7];
    long long v62 = a2[6];
    long long v63 = v28;
    long long v29 = a2[1];
    long long __s1 = *a2;
    long long v57 = v29;
    long long v30 = a2[3];
    long long v58 = a2[2];
    long long v59 = v30;
  }
  int v53 = (pthread_rwlock_t *)(v11 + 5376);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v11 + 5376));
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v11 + 5584));
  for (uint64_t i = *(void *)(v11 + 5576); i; uint64_t i = *(void *)(i + 352))
  {
    int v32 = *(_DWORD *)i;
    if (__darwin_check_fd_set_overflow(*(_DWORD *)i, &__s1, 0)) {
      *(_DWORD *)((char *)&__s1 + (((unint64_t)v32 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) &= ~(1 << v32);
    }
    if (!*(void *)(i + 104))
    {
      int v33 = *(_DWORD *)i;
      if (__darwin_check_fd_set_overflow(*(_DWORD *)i, &__src, 0)) {
        *(_DWORD *)((char *)&__src + (((unint64_t)v33 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) &= ~(1 << v33);
      }
    }
  }
  if (memcmp(&__s1, &VTP_Select_zeros, 0x80uLL))
  {
    pthread_rwlock_unlock((pthread_rwlock_t *)(v11 + 5584));
    pthread_rwlock_unlock(v53);
    CheckOutHandleDebug();
    int v13 = __error();
    int v14 = 9;
LABEL_26:
    *int v13 = v14;
    return 0xFFFFFFFFLL;
  }
  if (!memcmp(&__src, &VTP_Select_zeros, 0x80uLL))
  {
    AddOneVFDSETList(v11, &v55, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, 0, 0);
    uint64_t v44 = v55;
    pthread_rwlock_unlock((pthread_rwlock_t *)(v11 + 5584));
    pthread_rwlock_unlock(v53);
    if (!v44)
    {
      CheckOutHandleDebug();
      return 0xFFFFFFFFLL;
    }
    pthread_mutex_lock((pthread_mutex_t *)(v44 + 8));
    if (a5)
    {
      if (!*(unsigned char *)(v44 + 120) && !*(unsigned char *)(v44 + 121))
      {
        while (1)
        {
          double v45 = v12 - micro();
          if (v45 < 0.0) {
            break;
          }
          v54.tv_sec = 0xAAAAAAAAAAAAAAAALL;
          v54.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
          convertTimeoutToRelativeTimespec(v45);
          v54.tv_sec = v46;
          v54.tv_nsec = v47;
          int v48 = pthread_cond_timedwait_relative_np((pthread_cond_t *)(v44 + 72), (pthread_mutex_t *)(v44 + 8), &v54);
          if (v48 == 60 || *(unsigned char *)(v44 + 120) || *(unsigned char *)(v44 + 121)) {
            goto LABEL_51;
          }
        }
        int v48 = 60;
        goto LABEL_51;
      }
    }
    else if (!*(unsigned char *)(v44 + 120) && !*(unsigned char *)(v44 + 121))
    {
      do
        int v48 = pthread_cond_wait((pthread_cond_t *)(v44 + 72), (pthread_mutex_t *)(v44 + 8));
      while (!*(unsigned char *)(v44 + 120) && !*(unsigned char *)(v44 + 121));
LABEL_51:
      pthread_mutex_unlock((pthread_mutex_t *)(v44 + 8));
      int v49 = *(unsigned __int8 *)(v44 + 121);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v11 + 5584));
      RemoveOneVFDSETList(v11, *(_DWORD *)v44);
      pthread_rwlock_unlock((pthread_rwlock_t *)(v11 + 5584));
      if (v48)
      {
        if (v48 == 60)
        {
          uint64_t v34 = 0;
        }
        else
        {
          *__error() = v48;
          uint64_t v34 = 0xFFFFFFFFLL;
        }
      }
      else if (v49)
      {
        *__error() = 9;
        uint64_t v34 = 0xFFFFFFFFLL;
      }
      else
      {
        pthread_rwlock_rdlock(v53);
        uint64_t v50 = *(void *)(v11 + 5576);
        if (v50)
        {
          uint64_t v34 = 0;
          do
          {
            if (a2)
            {
              if (*(void *)(v50 + 104))
              {
                int v51 = *(_DWORD *)v50;
                if (__darwin_check_fd_set_overflow(*(_DWORD *)v50, a2, 0))
                {
                  if ((*(_DWORD *)((char *)a2 + (((unint64_t)v51 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v51))
                  {
                    int v52 = *(_DWORD *)v50;
                    if (__darwin_check_fd_set_overflow(*(_DWORD *)v50, &__src, 0)) {
                      *(_DWORD *)((char *)&__src + (((unint64_t)v52 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v52;
                    }
                    uint64_t v34 = (v34 + 1);
                  }
                }
              }
            }
            uint64_t v50 = *(void *)(v50 + 352);
          }
          while (v50);
        }
        else
        {
          uint64_t v34 = 0;
        }
        pthread_rwlock_unlock(v53);
      }
      goto LABEL_30;
    }
    int v48 = 0;
    goto LABEL_51;
  }
  pthread_rwlock_unlock((pthread_rwlock_t *)(v11 + 5584));
  pthread_rwlock_unlock(v53);
  uint64_t v34 = 1;
LABEL_30:
  if (a2) {
    memmove(a2, &__src, 0x80uLL);
  }
  if (a3)
  {
    long long v35 = v77;
    a3[4] = v76;
    a3[5] = v35;
    long long v36 = v79;
    a3[6] = v78;
    a3[7] = v36;
    long long v37 = v73;
    *a3 = v72;
    a3[1] = v37;
    long long v38 = v75;
    a3[2] = v74;
    a3[3] = v38;
  }
  if (a4)
  {
    long long v39 = v69;
    a4[4] = v68;
    a4[5] = v39;
    long long v40 = v71;
    a4[6] = v70;
    a4[7] = v40;
    long long v41 = v65;
    *a4 = v64;
    a4[1] = v41;
    long long v42 = v67;
    a4[2] = v66;
    a4[3] = v42;
  }
  CheckOutHandleDebug();
  return v34;
}

uint64_t VTP_GetSendRecvStats(uint64_t *a1, uint64_t *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (atomic_ullong *)CheckInHandleDebug();
  if (v4)
  {
    *a1 = atomic_fetch_add_explicit(v4, 0, memory_order_relaxed);
    *a2 = atomic_fetch_add_explicit(v4 + 1, 0, memory_order_relaxed);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      uint64_t v6 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *a1;
        uint64_t v8 = *a2;
        int v10 = 136316162;
        uint64_t v11 = v5;
        __int16 v12 = 2080;
        int v13 = "VTP_GetSendRecvStats";
        __int16 v14 = 1024;
        int v15 = 4487;
        __int16 v16 = 2048;
        uint64_t v17 = v7;
        __int16 v18 = 2048;
        uint64_t v19 = v8;
        _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_GetSendRecvStats %lld/%lld", (uint8_t *)&v10, 0x30u);
      }
    }
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_GetSendRecvStats_cold_1();
      }
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
}

uint64_t VTP_SetCellularUniqueTag(int a1, int a2)
{
  uint64_t v4 = CheckInHandleDebug();
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = (pthread_rwlock_t *)(v4 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
    uint64_t v7 = *(void *)(v5 + 5576);
    if (v7)
    {
      while (*(_DWORD *)v7 != a1 || (*(unsigned char *)(v7 + 29) & 1) == 0)
      {
        uint64_t v7 = *(void *)(v7 + 352);
        if (!v7) {
          goto LABEL_6;
        }
      }
      int v9 = 0;
      uint64_t v8 = 0;
      *(_DWORD *)(v7 + 52) = a2;
    }
    else
    {
LABEL_6:
      uint64_t v8 = 0xFFFFFFFFLL;
      int v9 = 1;
    }
    pthread_rwlock_unlock(v6);
    CheckOutHandleDebug();
    if (v9) {
      *__error() = 9;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SetCellularUniqueTag_cold_1();
      }
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  return v8;
}

void VTP_SetPktTag(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (a2 < 5)
  {
    *(void *)(a1 + 8 * a2 + 256) = a3;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VTP_SetPktTag_cold_1();
    }
  }
}

uint64_t VTP_SetRTPSrc(int a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  *(void *)((char *)v24 + 14) = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23[3] = v5;
  v24[0] = v5;
  v23[2] = v5;
  *(void *)((char *)v23 + 14) = 0xAAAAAAAAAAAAAAAALL;
  __n_4[9] = v5;
  v23[0] = v5;
  __n_4[8] = v5;
  uint64_t v6 = CheckInHandleDebug();
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v6)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      uint64_t v8 = VRTraceErrorLogLevelToCSTR();
      int v9 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(__n_4[0]) = 136316418;
        *(void *)((char *)__n_4 + 4) = v8;
        WORD6(__n_4[0]) = 2080;
        *(void *)((char *)__n_4 + 14) = "VTP_SetRTPSrc";
        WORD3(__n_4[1]) = 1024;
        DWORD2(__n_4[1]) = 4593;
        WORD6(__n_4[1]) = 1024;
        *(_DWORD *)((char *)&__n_4[1] + 14) = a1;
        WORD1(__n_4[2]) = 2080;
        *(void *)((char *)&__n_4[2] + 4) = IPPORTToStringWithSize();
        WORD6(__n_4[2]) = 2080;
        *(void *)((char *)&__n_4[2] + 14) = IPPORTToStringWithSize();
        _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_SetRTPSrc for callID(%08X) local[%s] dst[%s].", (uint8_t *)__n_4, 0x36u);
      }
    }
    int v10 = (pthread_rwlock_t *)(v6 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v6 + 5376));
    uint64_t v11 = *(void *)(v6 + 5880);
    if (!v11) {
      goto LABEL_34;
    }
    while (*(_DWORD *)v11 != a1)
    {
      uint64_t v11 = *(void *)(v11 + 2056);
      if (!v11) {
        goto LABEL_34;
      }
    }
    *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __n_4[6] = v13;
    __n_4[7] = v13;
    __n_4[4] = v13;
    __n_4[5] = v13;
    __n_4[2] = v13;
    __n_4[3] = v13;
    __n_4[0] = v13;
    __n_4[1] = v13;
    if (*a3) {
      IPPORTToSA6();
    }
    else {
      IPPORTToSA();
    }
    uint64_t v14 = *(unsigned int *)(v11 + 2024);
    if ((int)v14 < 1)
    {
      LODWORD(v15) = 0;
    }
    else
    {
      uint64_t v15 = 0;
      __int16 v16 = (char *)(v11 + 1232);
      while (memcmp(v16, __n_4, 0x80uLL))
      {
        ++v15;
        v16 += 128;
        if (v14 == v15) {
          goto LABEL_23;
        }
      }
    }
    if (v15 == v14)
    {
LABEL_23:
      if ((int)v14 >= 5) {
        LODWORD(v14) = 5;
      }
      memmove((void *)(v11 + 1360), (const void *)(v11 + 1232), (uint64_t)(int)v14 << 7);
      memmove((void *)(v11 + 2004), (const void *)(v11 + 2000), 4 * (int)v14);
      memcpy((void *)(v11 + 1232), __n_4, 0x80uLL);
      *(_DWORD *)(v11 + 2000) = 128;
      int v17 = *(_DWORD *)(v11 + 2024);
      if (v17 < 6) {
        *(_DWORD *)(v11 + 2024) = v17 + 1;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() <= 6) {
        goto LABEL_34;
      }
      uint64_t v18 = VRTraceErrorLogLevelToCSTR();
      uint64_t v19 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136315650;
      uint64_t v26 = v18;
      __int16 v27 = 2080;
      long long v28 = "SetVFDSASrc";
      __int16 v29 = 1024;
      int v30 = 4572;
      uint64_t v20 = " [%s] %s:%d VTP added VFDSASrc successfully.";
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
        goto LABEL_34;
      }
      uint64_t v21 = VRTraceErrorLogLevelToCSTR();
      uint64_t v19 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136315650;
      uint64_t v26 = v21;
      __int16 v27 = 2080;
      long long v28 = "SetVFDSASrc";
      __int16 v29 = 1024;
      int v30 = 4574;
      uint64_t v20 = " [%s] %s:%d VTP found duplicate VFDSASrc entry.";
    }
    _os_log_impl(&dword_1E1EA4000, v19, OS_LOG_TYPE_DEFAULT, v20, buf, 0x1Cu);
LABEL_34:
    pthread_rwlock_unlock(v10);
    CheckOutHandleDebug();
    return 0;
  }
  if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VTP_SetRTPSrc_cold_1();
    }
  }
  *__error() = 13;
  return 0xFFFFFFFFLL;
}

uint64_t VTP_SetNetworkLogLevel(uint64_t a1, int a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = CheckInHandleDebug();
  if (!v4)
  {
    uint64_t v11 = __error();
    int v12 = 13;
LABEL_24:
    *uint64_t v11 = v12;
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = v4;
  uint64_t v6 = (pthread_rwlock_t *)(v4 + 5376);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v4 + 5376));
  *(void *)&v33[14] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v32 = v7;
  *(_OWORD *)int v33 = v7;
  long long v31 = v7;
  IPPORTToStringWithSize();
  uint64_t v8 = *(int **)(v5 + 5576);
  if (!v8)
  {
LABEL_15:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SetNetworkLogLevel_cold_2();
      }
    }
    pthread_rwlock_unlock(v6);
LABEL_19:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SetNetworkLogLevel_cold_1();
      }
    }
    CheckOutHandleDebug();
    uint64_t v11 = __error();
    int v12 = 9;
    goto LABEL_24;
  }
  int v9 = *(_DWORD *)a1 & 1;
  while (1)
  {
    if ((v8[15] & 1) == v9)
    {
      if (v9)
      {
        if (*((void *)v8 + 10) != *(void *)(a1 + 20) || *((void *)v8 + 11) != *(void *)(a1 + 28)) {
          goto LABEL_14;
        }
      }
      else if (v8[20] != *(_DWORD *)(a1 + 20))
      {
        goto LABEL_14;
      }
      if (*((unsigned __int16 *)v8 + 48) == *(unsigned __int16 *)(a1 + 36)) {
        break;
      }
    }
LABEL_14:
    uint64_t v8 = (int *)*((void *)v8 + 44);
    if (!v8) {
      goto LABEL_15;
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v15 = VRTraceErrorLogLevelToCSTR();
    __int16 v16 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v17 = *v8;
      *(_DWORD *)buf = 136316162;
      uint64_t v22 = v15;
      __int16 v23 = 2080;
      long long v24 = "FindVFDByLocalIPPort";
      __int16 v25 = 1024;
      int v26 = 2550;
      __int16 v27 = 2080;
      long long v28 = &v31;
      __int16 v29 = 1024;
      int v30 = v17;
      _os_log_impl(&dword_1E1EA4000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Connection result with localIPPort %s uses vfd(%d) for send.", buf, 0x2Cu);
    }
  }
  int v18 = v8[5];
  pthread_rwlock_unlock(v6);
  if (v18 == -1) {
    goto LABEL_19;
  }
  *__error() = 0;
  long long v31 = 0u;
  long long v32 = 0u;
  __strlcpy_chk();
  LODWORD(v32) = a2;
  *(void *)((char *)&v32 + 4) = 0x111010001;
  uint64_t v13 = 0;
  if (ioctl(v18, 0xC020699BuLL, &v31) < 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v19 = VRTraceErrorLogLevelToCSTR();
      uint64_t v20 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SetNetworkLogLevel_cold_3(v19, (uint64_t)&v31, v20);
      }
    }
    uint64_t v13 = 0xFFFFFFFFLL;
  }
  CheckOutHandleDebug();
  return v13;
}

uint64_t VTP_NotifyRemoteNoRemotePacket(int a1, double a2)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  *(double *)uint64_t v8 = a2;
  int v7 = a1;
  uint64_t v2 = CheckInHandleDebug();
  if (v2)
  {
    uint64_t v3 = v2;
    uint64_t v4 = (pthread_mutex_t *)(v2 + 48);
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 48));
    uint64_t v5 = *(void (**)(uint64_t, void, void *, int *))(v3 + 112);
    if (v5)
    {
      v5(1, *(void *)(v3 + 120), v8, &v7);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_NotifyRemoteNoRemotePacket_cold_1();
      }
    }
    pthread_mutex_unlock(v4);
    CheckOutHandleDebug();
  }
  else
  {
    *__error() = 13;
  }
  return 0xFFFFFFFFLL;
}

uint64_t VTP_NotifySendFailed(uint64_t a1)
{
  uint64_t v2 = CheckInHandleDebug();
  if (v2)
  {
    uint64_t v3 = v2;
    uint64_t v4 = (pthread_mutex_t *)(v2 + 48);
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 48));
    uint64_t v5 = *(void (**)(uint64_t, void, uint64_t, void))(v3 + 112);
    if (v5)
    {
      v5(2, *(void *)(v3 + 120), a1, 0);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_NotifySendFailed_cold_2();
      }
    }
    pthread_mutex_unlock(v4);
    CheckOutHandleDebug();
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_NotifySendFailed_cold_1();
      }
    }
    *__error() = 13;
  }
  return 0xFFFFFFFFLL;
}

uint64_t VTP_SetClientRelayVFD(int a1, int a2)
{
  uint64_t v4 = CheckInHandleDebug();
  if (!v4)
  {
    uint64_t v8 = __error();
    int v9 = 13;
    goto LABEL_7;
  }
  uint64_t v5 = v4;
  uint64_t v6 = (pthread_rwlock_t *)(v4 + 5376);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
  uint64_t v7 = *(void *)(v5 + 5880);
  if (!v7)
  {
LABEL_5:
    pthread_rwlock_unlock(v6);
    CheckOutHandleDebug();
    uint64_t v8 = __error();
    int v9 = 22;
LABEL_7:
    *uint64_t v8 = v9;
    return 0xFFFFFFFFLL;
  }
  while (*(_DWORD *)v7 != a1)
  {
    uint64_t v7 = *(void *)(v7 + 2056);
    if (!v7) {
      goto LABEL_5;
    }
  }
  if (a2 == -1)
  {
    uint64_t v10 = 0;
    *(void *)(v7 + 2032) = 0;
  }
  else
  {
    uint64_t v12 = *(void *)(v5 + 5576);
    if (v12)
    {
      while (*(_DWORD *)v12 != a2)
      {
        uint64_t v12 = *(void *)(v12 + 352);
        if (!v12) {
          goto LABEL_16;
        }
      }
      *(void *)(v7 + 2032) = v12;
    }
LABEL_16:
    if (*(void *)(v7 + 2032))
    {
      uint64_t v10 = 0;
    }
    else
    {
      *__error() = 22;
      uint64_t v10 = 0xFFFFFFFFLL;
    }
  }
  pthread_rwlock_unlock(v6);
  CheckOutHandleDebug();
  return v10;
}

uint64_t VTP_DetectNAT64Prefix(int a1, const char *a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    p_opt_inst_meths = &OBJC_PROTOCOL___VCVideoSink.opt_inst_meths;
    uint64_t v5 = CheckInHandleDebug();
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = (pthread_rwlock_t *)(v5 + 5376);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v5 + 5376));
      uint64_t v8 = *(void *)(v6 + 5576);
      if (v8)
      {
        uint64_t v22 = v7;
        do
        {
          if (*(_DWORD *)v8 == a1 && (*(unsigned char *)(v8 + 60) & 1) != 0)
          {
            VCNAT64ResolverRegisterForPrefixUpdate(a2, (uint64_t)VTP_NAT64PrefixResolvedCallback, v8);
            int Prefix = VCNAT64ResolverGetPrefix((uint64_t)a2, (void *)(v8 + 372));
            if (Prefix < 0 || !VCNAT64ResolverIsNonzeroPrefix((_DWORD *)(v8 + 372)))
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
              {
                uint64_t v13 = VRTraceErrorLogLevelToCSTR();
                uint64_t v14 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                {
                  int v15 = *(_DWORD *)v8;
                  __int16 v16 = p_opt_inst_meths;
                  int v17 = *(_DWORD *)(v8 + 60) & 1;
                  unsigned int v18 = VCNAT64ResolverIsNonzeroPrefix((_DWORD *)(v8 + 372));
                  *(_DWORD *)buf = 136316930;
                  uint64_t v24 = v13;
                  __int16 v25 = 2080;
                  int v26 = "VTP_DetectNAT64Prefix";
                  __int16 v27 = 1024;
                  int v28 = 4785;
                  __int16 v29 = 2080;
                  int v30 = a2;
                  __int16 v31 = 1024;
                  int v32 = v15;
                  __int16 v33 = 1024;
                  int v34 = Prefix;
                  __int16 v35 = 1024;
                  int v36 = v17;
                  p_opt_inst_meths = v16;
                  uint64_t v7 = v22;
                  __int16 v37 = 1024;
                  unsigned int v38 = v18;
                  _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Interface %s (VFD %d) ISNOT behind NAT (result %d, local is IPv6 %d, isNoneZero %d)", buf, 0x3Eu);
                }
              }
            }
            else
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
              {
                uint64_t v10 = VRTraceErrorLogLevelToCSTR();
                uint64_t v11 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                {
                  int v12 = *(_DWORD *)v8;
                  *(_DWORD *)buf = 136316162;
                  uint64_t v24 = v10;
                  __int16 v25 = 2080;
                  int v26 = "VTP_DetectNAT64Prefix";
                  __int16 v27 = 1024;
                  int v28 = 4782;
                  __int16 v29 = 2080;
                  int v30 = a2;
                  __int16 v31 = 1024;
                  int v32 = v12;
                  _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Interface %s (VFD %d) IS behind NAT", buf, 0x2Cu);
                }
              }
              *(unsigned char *)(v8 + 368) = 1;
            }
          }
          uint64_t v8 = *(void *)(v8 + 352);
        }
        while (v8);
      }
      pthread_rwlock_unlock(v7);
      CheckOutHandleDebug();
      uint64_t v19 = __error();
      int v20 = 9;
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_DetectNAT64Prefix_cold_1();
        }
      }
      uint64_t v19 = __error();
      int v20 = 13;
    }
  }
  else
  {
    uint64_t v19 = __error();
    int v20 = 22;
  }
  int *v19 = v20;
  return 0xFFFFFFFFLL;
}

void VTP_NAT64PrefixResolvedCallback(int *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)int v28 = 0u;
  memset(v29, 0, sizeof(v29));
  if ((a1[15] & 1) != 0 && VCNAT64ResolverIsNonzeroPrefix(a3))
  {
    *(_OWORD *)(a1 + 93) = *(_OWORD *)a3;
    *((unsigned char *)a1 + 368) = 1;
    v27[0] = 0xAAAAAAAAAAAAAAAALL;
    v27[1] = 0xAAAAAAAAAAAAAAAALL;
    nw_nat64_synthesize_v6();
    inet_ntop(30, v27, v28, 0x2Eu);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v6 = VRTraceErrorLogLevelToCSTR();
      uint64_t v7 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v8 = *a1;
        *(_DWORD *)buf = 136316418;
        uint64_t v17 = v6;
        __int16 v18 = 2080;
        uint64_t v19 = "VTP_NAT64PrefixResolvedCallback";
        __int16 v20 = 1024;
        int v21 = 4868;
        __int16 v22 = 2080;
        *(void *)__int16 v23 = a2;
        *(_WORD *)&v23[8] = 1024;
        int v24 = v8;
        __int16 v25 = 2080;
        int v26 = v28;
        int v9 = " [%s] %s:%d Interface %s (VFD %d) IS behind NAT 64 with prefix: %s";
        uint64_t v10 = v7;
        uint32_t v11 = 54;
LABEL_9:
        _os_log_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEFAULT, v9, buf, v11);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    uint64_t v12 = VRTraceErrorLogLevelToCSTR();
    uint64_t v13 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v14 = VCNAT64ResolverIsNonzeroPrefix(a3);
      int v15 = a1[15] & 1;
      *(_DWORD *)buf = 136316162;
      uint64_t v17 = v12;
      __int16 v18 = 2080;
      uint64_t v19 = "VTP_NAT64PrefixResolvedCallback";
      __int16 v20 = 1024;
      int v21 = 4870;
      __int16 v22 = 1024;
      *(_DWORD *)__int16 v23 = v14;
      *(_WORD *)&_OWORD v23[4] = 1024;
      *(_DWORD *)&v23[6] = v15;
      int v9 = " [%s] %s:%d provided a all zeroed prefix (%d), local is IPv6 (%d)";
      uint64_t v10 = v13;
      uint32_t v11 = 40;
      goto LABEL_9;
    }
  }
}

uint64_t VTP_RegisterConnectionManagerWithCallID(const void *a1, int a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  int valuePtr = a2;
  uint64_t v3 = CheckInHandleDebug();
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = (pthread_rwlock_t *)(v3 + 21648);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 21648));
    CFNumberRef v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v4 + 21848), v6, a1);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      uint64_t v7 = VRTraceErrorLogLevelToCSTR();
      int v8 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        uint64_t v12 = v7;
        __int16 v13 = 2080;
        unsigned int v14 = "VTP_RegisterConnectionManagerWithCallID";
        __int16 v15 = 1024;
        int v16 = 4887;
        __int16 v17 = 2048;
        __int16 v18 = a1;
        __int16 v19 = 1024;
        int v20 = valuePtr;
        _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP registered connectionManager %p with callID %d", buf, 0x2Cu);
      }
    }
    CFRelease(v6);
    pthread_rwlock_unlock(v5);
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_RegisterConnectionManagerWithCallID_cold_1();
      }
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
}

uint64_t VTP_DeregisterConnectionManagerWithCallID(int a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  int valuePtr = a1;
  uint64_t v1 = CheckInHandleDebug();
  if (v1)
  {
    uint64_t v2 = v1;
    uint64_t v3 = (pthread_rwlock_t *)(v1 + 21648);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v1 + 21648));
    CFNumberRef v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v2 + 21848), v4);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      CFNumberRef v6 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v7 = valuePtr;
        CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(v2 + 21848));
        *(_DWORD *)buf = 136316162;
        uint64_t v12 = v5;
        __int16 v13 = 2080;
        unsigned int v14 = "VTP_DeregisterConnectionManagerWithCallID";
        __int16 v15 = 1024;
        int v16 = 4910;
        __int16 v17 = 1024;
        int v18 = v7;
        __int16 v19 = 2048;
        CFIndex v20 = Count;
        _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP de-registered connectionManager with callID %d, remaining items number %ld", buf, 0x2Cu);
      }
    }
    CFRelease(v4);
    pthread_rwlock_unlock(v3);
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_DeregisterConnectionManagerWithCallID_cold_1();
      }
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
}

uint64_t VTP_IncrementTotalBytesSent(unint64_t a1)
{
  uint64_t v2 = (atomic_ullong *)CheckInHandleDebug();
  if (v2)
  {
    atomic_fetch_add_explicit(v2, a1, memory_order_relaxed);
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    uint64_t v3 = 2148990978;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_IncrementTotalBytesSent_cold_1();
      }
    }
  }
  return v3;
}

uint64_t VTP_ScheduleReceiveForNWConnection()
{
  return 1;
}

void sub_1E219D2FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t VTP_GetPktType(int a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = 0;
  int v8 = &v7;
  uint64_t v9 = 0x2020000000;
  int v10 = -1;
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __VTP_GetPktType_block_invoke;
  v6[3] = &unk_1E6DB7908;
  v6[4] = &v7;
  v6[5] = a2;
  uint64_t v3 = CheckInHandleDebug();
  if (v3)
  {
    VTP_ProcessVFD(v3, a1, 1, (uint64_t)v6);
    CheckOutHandleDebug();
    if (*((_DWORD *)v8 + 6) == -1)
    {
      *__error() = 9;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_GetPktType_cold_2();
        }
      }
    }
  }
  else
  {
    *__error() = 13;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_GetPktType_cold_1();
      }
    }
  }
  uint64_t v4 = *((unsigned int *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_1E219D528(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
}

void VTP_ReleaseVFD(pthread_mutex_t *a1, int a2)
{
  if ((a2 - 1024) > 0xFFFFFC63)
  {
    uint64_t v4 = a1 + 66;
    pthread_mutex_lock(a1 + 66);
    uint64_t v5 = (a2 - 100);
    CFNumberRef v6 = &a1->__sig + v5;
    uint64_t v7 = (const void *)v6[855];
    if (v7)
    {
      int v8 = v6 + 855;
      CFRelease(v7);
      *int v8 = 0;
    }
    *(void *)&a1[222].__opaque[8 * v5 + 16] = 0xFFFFFFFFLL;
    a1[92].__opaque[v5 + 16] = 0;
    pthread_mutex_unlock(v4);
  }
  else
  {
    *__error() = 22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_ReleaseVFD_cold_1();
      }
    }
  }
}

uint64_t PrepareOFTMAC(const __CFString *a1, const void *a2, int a3, _DWORD *a4)
{
  macOut[3] = *MEMORY[0x1E4F143B8];
  memset(macOut, 170, 20);
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        PrepareOFTMAC_cold_1();
      }
    }
    return 0xFFFFFFFFLL;
  }
  CFIndex Length = CFStringGetLength(a1);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  if (MaximumSizeForEncoding <= 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        PrepareOFTMAC_cold_2();
      }
    }
    return 0xFFFFFFFFLL;
  }
  size_t v10 = MaximumSizeForEncoding;
  CStringPtr = (char *)CFStringGetCStringPtr(a1, 0x8000100u);
  MEMORY[0x1F4188790](CStringPtr);
  memset((char *)macOut - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), 170, v10);
  if (CStringPtr
    || (CStringPtr = (char *)macOut - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0),
        CFStringGetCString(a1, CStringPtr, v10, 0x8000100u)))
  {
    size_t v12 = strlen(CStringPtr);
    CCHmac(0, CStringPtr, v12, a2, a3, macOut);
    uint64_t result = 0;
    *a4 = macOut[0];
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        PrepareOFTMAC_cold_3();
      }
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

void PrepareOFTCRC32(uint64_t a1, int a2, int a3, unsigned int *a4)
{
  unsigned int v8 = crc32(0, 0, 0);
  if (a1 && a4)
  {
    if (a3 < a2)
    {
      uint64_t v9 = (uInt *)(a1 + 16 * a3 + 8);
      uint64_t v10 = a2 - (uint64_t)a3;
      do
      {
        uint64_t v11 = (const Bytef *)*((void *)v9 - 1);
        uInt v12 = *v9;
        v9 += 4;
        unsigned int v8 = crc32(v8, v11, v12);
        --v10;
      }
      while (v10);
    }
    *a4 = v8;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      PrepareOFTCRC32_cold_1();
    }
  }
}

double VTP_AddNAT64PrefixToIPv4Destination(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  memset(&v6[4], 170, 24);
  if (*(unsigned char *)(a1 + 368))
  {
    if (*(unsigned char *)(a2 + 1) == 2)
    {
      *(_WORD *)CFNumberRef v6 = 7708;
      *(_WORD *)&v6[2] = *(_WORD *)(a2 + 2);
      nw_nat64_synthesize_v6();
      *a3 = 28;
      *(_OWORD *)(a2 + 12) = *(_OWORD *)&v6[12];
      double result = *(double *)v6;
      *(_OWORD *)a2 = *(_OWORD *)v6;
    }
  }
  return result;
}

void VTP_DemuxPacketsToVFDList(uint64_t a1, unsigned char *a2, _DWORD *a3)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  uint64_t v50 = a2;
  if (!a2) {
    return;
  }
  uint64_t v4 = a2;
  CFNumberRef v6 = (_DWORD *)(a1 + 21912);
  int v49 = (unsigned char *)(a1 + 5896);
  do
  {
    uint64_t v7 = v4;
    uint64_t v4 = (void *)v4[67];
    v7[67] = 0;
    if (a3 && *(_DWORD *)v7 != 0x20000) {
      ++*a3;
    }
    unsigned int v8 = *(int **)(a1 + 5576);
    if (!v8)
    {
LABEL_50:
      _VTP_ReleasePacket(a1, (void **)&v50);
      ++v6[4];
      goto LABEL_106;
    }
    int v9 = *(_DWORD *)v7;
    while (1)
    {
      if ((v9 & v8[7]) == 0) {
        goto LABEL_49;
      }
      int v10 = v8[4];
      if (v10 == 2 || (unsigned int v11 = *((_DWORD *)v7 + 58), v11 < 4))
      {
        int v12 = v8[5];
        int v13 = *((_DWORD *)v7 + 1);
      }
      else
      {
        if (v11 != 4)
        {
          if (v11 != 5 || v7[30] != *((void *)v8 + 50)) {
            goto LABEL_16;
          }
          goto LABEL_13;
        }
        int v12 = *((_DWORD *)v7 + 60);
        int v13 = v8[100];
      }
      if (v12 != v13) {
        goto LABEL_16;
      }
LABEL_13:
      if ((v9 & 0x1000) != 0)
      {
        int v51 = v7;
        if (*((unsigned char *)v7 + 220) || *((_DWORD *)v7 + 52) != 3)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            uint64_t v30 = VRTraceErrorLogLevelToCSTR();
            __int16 v31 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              int v32 = *((unsigned __int8 *)v7 + 220);
              BOOL v33 = *((_DWORD *)v7 + 52) != 3;
              *(_DWORD *)buf = 136316162;
              uint64_t v53 = v30;
              __int16 v54 = 2080;
              uint64_t v55 = "VTP_PassHsk";
              __int16 v56 = 1024;
              int v57 = 3973;
              __int16 v58 = 1024;
              int v59 = v32;
              __int16 v60 = 1024;
              BOOL v61 = v33;
              _os_log_impl(&dword_1E1EA4000, v31, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_PassHsk bad packet. encrypted? %d type_check %d", buf, 0x28u);
            }
          }
        }
        else
        {
          DTLS_UpdateHandshake(*(void *)(a1 + 8 * *v8 + 13432), v7[70], *((int *)v7 + 138), *((_DWORD *)v7 + 53));
        }
        int v34 = (void **)&v51;
        goto LABEL_92;
      }
      if ((*(_DWORD *)v7 & 0x301F0) == 0 || v10 == 1)
      {
        VTP_PassPkt(a1, (uint64_t)v8, (int *)v7);
        ++v6[3];
        goto LABEL_106;
      }
LABEL_16:
      if ((*(_DWORD *)v7 & 0x30000) != 0)
      {
        int v14 = v8[14];
        if (v14)
        {
          if (v14 == *((_DWORD *)v7 + 54))
          {
            VTP_PassPkt(a1, (uint64_t)v8, (int *)v7);
            if ((*(_DWORD *)v50 & 0x10000) != 0 || (*(_DWORD *)v50 & 0x20000) != 0 && v50[426]) {
              ++v6[2];
            }
            goto LABEL_106;
          }
        }
      }
      if ((v9 & 0x100) != 0 && *((_DWORD *)v7 + 50) == v8[13])
      {
        VTP_PassPkt(a1, (uint64_t)v8, (int *)v7);
        ++v6[1];
        goto LABEL_106;
      }
      if ((*(_DWORD *)v7 & 0xC0) != 0 && *((unsigned char *)v8 + 27) && v8[12] == *((_DWORD *)v7 + 49))
      {
        VTP_PassPkt(a1, (uint64_t)v8, (int *)v7);
        ++*v6;
        goto LABEL_106;
      }
      if ((*(_DWORD *)v7 & 0xF0) != 0)
      {
        if (*((unsigned char *)v8 + 26))
        {
          int v15 = v8[11];
          if ((!v15 || v15 == *((_DWORD *)v7 + 48)) && (!*((unsigned char *)v7 + 376) || v8[14] == *((_DWORD *)v7 + 54))) {
            break;
          }
        }
      }
LABEL_49:
      unsigned int v8 = (int *)*((void *)v8 + 44);
      if (!v8) {
        goto LABEL_50;
      }
    }
    if (v9 != 48) {
      goto LABEL_52;
    }
    uint64_t v16 = (int *)*((void *)v8 + 4);
    if (!v16) {
      goto LABEL_48;
    }
    int v17 = *(unsigned __int8 *)(v7[70] + 1);
    if ((v17 & 0x7D) == 0x7C) {
      goto LABEL_51;
    }
    uint64_t v18 = v8[10];
    if (*(unsigned __int8 *)(v7[70] + 1) > 0xEDu)
    {
      if (v17 == 238 || v17 == 253) {
        goto LABEL_51;
      }
    }
    else if (v17 == 110 || v17 == 125)
    {
      goto LABEL_51;
    }
    if ((int)v18 < 1)
    {
LABEL_48:
      if (!v15) {
        goto LABEL_49;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v35 = VRTraceErrorLogLevelToCSTR();
        int v36 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          int v46 = *(unsigned __int8 *)(*((void *)v50 + 70) + 1);
          int v47 = v8[11];
          int v48 = *v8;
          *(_DWORD *)buf = 136316418;
          uint64_t v53 = v35;
          __int16 v54 = 2080;
          uint64_t v55 = "VTP_DemuxPacketsToVFDList";
          __int16 v56 = 1024;
          int v57 = 4082;
          __int16 v58 = 1024;
          int v59 = v46;
          __int16 v60 = 1024;
          BOOL v61 = v47;
          __int16 v62 = 1024;
          LODWORD(v63) = v48;
          _os_log_error_impl(&dword_1E1EA4000, v36, OS_LOG_TYPE_ERROR, " [%s] %s:%d VTP received message with mismatched payload=%02X for ssrc=%04X on vfd=%d", buf, 0x2Eu);
        }
      }
      int v34 = (void **)&v50;
LABEL_92:
      _VTP_ReleasePacket(a1, v34);
      goto LABEL_106;
    }
    int v19 = v17 & 0x7F;
    while (1)
    {
      int v20 = *v16++;
      if (v20 == v19) {
        break;
      }
      if (!--v18) {
        goto LABEL_48;
      }
    }
LABEL_51:
    LOBYTE(v9) = 48;
    *(_DWORD *)uint64_t v7 = 48;
LABEL_52:
    int v21 = v9 & 0x30;
    if (*v49) {
      BOOL v22 = v21 == 0;
    }
    else {
      BOOL v22 = 1;
    }
    if (!v22)
    {
      unint64_t v23 = v7[70];
      char v24 = *(unsigned char *)(v23 + 1);
      int v25 = 16;
      if ((v24 & 0x7E) != 0x70)
      {
        unsigned int v26 = v24 & 0x7F;
        if (v26 != 101
          && v26 >= 0x18
          && v26 != 119
          && (v26 - 97) >= 2u
          && (v26 - 121) >= 2u
          && v26 != 111
          && (v24 & 0x7C) != 0x68
          && v26 != 108)
        {
          int v25 = 32;
          if ((v26 - 109) >= 2u
            && (v24 & 0x7E) != 0x7C
            && v26 != 100
            && v26 != 126
            && v26 != 123
            && (v26 - 24) >= 0xBu)
          {
            unsigned __int8 v29 = v24 + 64;
            if (v29 > 0xEu) {
              int v25 = 0;
            }
            else {
              int v25 = dword_1E25A0060[(char)v29];
            }
          }
        }
      }
      int v37 = VTP_NotifyAFRCRxEstimate(*((void *)v8 + 45), v25, v23, *((_DWORD *)v7 + 138), *((unsigned __int8 *)v7 + 223), *((double *)v7 + 23));
      if ((v37 & 0xFFFFFFFD) != 0)
      {
        int v38 = v37;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          uint64_t v39 = VRTraceErrorLogLevelToCSTR();
          long long v40 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            int v41 = *v8;
            uint64_t v42 = *((void *)v8 + 45);
            int v43 = *(_DWORD *)v7;
            uint64_t v44 = v7[69];
            *(_DWORD *)buf = 136317186;
            uint64_t v53 = v39;
            __int16 v54 = 2080;
            uint64_t v55 = "VTP_BandwidthEstimationWithMediaPacket";
            __int16 v56 = 1024;
            int v57 = 3990;
            __int16 v58 = 1024;
            int v59 = v38;
            __int16 v60 = 1024;
            BOOL v61 = v41;
            __int16 v62 = 2048;
            uint64_t v63 = v42;
            __int16 v64 = 1024;
            int v65 = v25;
            __int16 v66 = 1024;
            int v67 = v43;
            __int16 v68 = 1024;
            int v69 = v44;
            _os_log_impl(&dword_1E1EA4000, v40, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d notify AFRC failed (%08X): VFD %d AFRC handle %p  packet type %d/%d packet length: %d", buf, 0x44u);
          }
        }
      }
    }
    double v45 = (int *)v50;
    if (!v8[11]) {
      v8[11] = *((_DWORD *)v50 + 48);
    }
    VTP_PassPkt(a1, (uint64_t)v8, v45);
    ++*v6;
LABEL_106:
    uint64_t v50 = v4;
  }
  while (v4);
}

void _VTP_LogOSChannelInfoToIDSDatagramChannel(void *a1)
{
  if (a1)
  {
    [a1 osChannelInfoLog];
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VTP_LogOSChannelInfoToIDSDatagramChannel_cold_1();
    }
  }
}

char *_VTP_InterfaceIndexToNameCallback(uint64_t a1, unsigned int a2, char *a3)
{
  return a3;
}

uint64_t VTP_SetConnectionFlagsForPacket(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  values[1] = *(void **)MEMORY[0x1E4F143B8];
  char v19 = 0;
  *(_DWORD *)(a3 + 224) = -1;
  unsigned int v8 = (pthread_rwlock_t *)(a1 + 21648);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 21648));
  CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 21848));
  size_t v10 = 8 * Count;
  unint64_t v11 = (8 * Count + 15) & 0xFFFFFFFFFFFFFFF0;
  int v12 = (const void **)&v18[-v11];
  if (MEMORY[0x1F4188790](Count))
  {
    int v13 = memset(&v18[-v11], 170, v10);
    MEMORY[0x1F4188790](v13);
    int v14 = &v18[-v11];
    memset(v14, 170, v10);
    CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 21848), v12, (const void **)v14);
    if (Count >= 1)
    {
      while (1)
      {
        uint64_t v15 = VCConnectionManager_CopyConnection(*v14, (uint64_t)a4, (uint64_t)&v19);
        if (v15) {
          break;
        }
        ++v12;
        ++v14;
        if (!--Count) {
          goto LABEL_8;
        }
      }
      uint64_t v16 = (const void *)v15;
      *(_DWORD *)(a3 + 224) = v19 == 0;
      *(_DWORD *)(a3 + 228) = VCConnection_ConnectionID(v15);
      CFNumberGetValue((CFNumberRef)*v12, kCFNumberIntType, (void *)(a3 + 216));
      *(unsigned char *)(a3 + 223) = VCConnection_IsIPv6((uint64_t)v16);
      *(unsigned char *)(a3 + 221) = VCConnection_IsRelay((uint64_t)v16);
      CFRelease(v16);
    }
  }
  else
  {
    CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 21848), (const void **)&v18[-v11], (const void **)values);
  }
LABEL_8:
  uint64_t result = pthread_rwlock_unlock(v8);
  if (*(_DWORD *)(a3 + 224) == -1)
  {
    if (a2)
    {
      uint64_t result = VCSDInfoIsPacketFromKnownRemote(a2 + 392, a4);
      if ((result & 1) == 0) {
        return result;
      }
    }
    else if ((*a4 & 0xFFFFFFFE) != 4)
    {
      return result;
    }
    *(_DWORD *)(a3 + 224) = 0;
  }
  return result;
}

uint64_t VTP_ProcessPacketType(uint64_t a1, _DWORD *a2, int a3, uint64_t a4)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(unsigned int **)(a4 + 560);
  unint64_t v6 = *(void *)(a4 + 552);
  dataCFIndex Length = v6;
  if (!v6)
  {
    uint64_t v12 = 0;
    *(_DWORD *)a4 = 0;
    return v12;
  }
  if (!a2 || *a2 == -1) {
    CFStringRef v8 = 0;
  }
  else {
    CFStringRef v8 = *(const __CFString **)(a1 + 8 * (*a2 - 100) + 6840);
  }
  int v9 = *(char *)v5;
  if (v9 < 0)
  {
    int v17 = 0;
    if (v8)
    {
      int v18 = v6;
      LOBYTE(v19) = 0;
      unsigned int v20 = 0;
      if ((v9 & 0xC0) != 0x80)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VTP_ProcessPacketType_cold_8();
          }
        }
        goto LABEL_45;
      }
      goto LABEL_30;
    }
LABEL_29:
    int v18 = v6;
    LOBYTE(v19) = 0;
    unsigned int v20 = 0;
    goto LABEL_30;
  }
  int v10 = v6 - 4;
  if ((int)v6 >= 4 && (*(_WORD *)v5 & 0xC0) == 0x40) {
    unsigned int v11 = 4 * (v10 == bswap32(*((unsigned __int16 *)v5 + 1)) >> 16);
  }
  else {
    unsigned int v11 = 0;
  }
  int v13 = &v5[v11 / 4];
  unsigned int v14 = crc32(0, 0, 0);
  if (crc32(v14, (const Bytef *)v13, v6 - v11) != 558161692)
  {
    int v17 = 0;
    if (v8)
    {
      int v18 = v6;
      LOBYTE(v19) = 0;
      unsigned int v20 = 0;
      if (v11)
      {
        if ((*(unsigned char *)v13 & 0xC0) != 0x80)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              VTP_ProcessPacketType_cold_7();
            }
          }
          goto LABEL_45;
        }
        dataCFIndex Length = v6 - v11;
        memmove(v5, &v5[v11 / 4], (int)(v6 - v11));
        int v17 = 0;
        LOBYTE(v19) = 0;
        unsigned int v20 = 0;
        int v18 = v6 - v11;
      }
LABEL_30:
      unsigned int v70 = v20;
      if (v18 >= 4 && *v5 == -272716322)
      {
        *(_DWORD *)(a4 + 200) = bswap32(v5[2]);
        int v21 = 256;
      }
      else
      {
        ProcessRelayData((unsigned __int16 *)v5, &dataLength);
        int v22 = dataLength;
        unint64_t v23 = memchr(v5, 10, dataLength);
        if (v23 && strnstr((const char *)v5, "SIP/", v23 - (unsigned char *)v5))
        {
          int v21 = 2;
        }
        else
        {
          int v24 = *(unsigned __int8 *)v5 >> 6;
          if (v24 == 2)
          {
            if ((*((unsigned char *)v5 + 1) & 0xFE) != 0xC0 && (*((unsigned char *)v5 + 1) + 56) >= 7u) {
              int v21 = 48;
            }
            else {
              int v21 = 192;
            }
          }
          else if (v24 == 1)
          {
            int v21 = 0x10000;
          }
          else
          {
            if (v24)
            {
              uint64_t v12 = 2148991010;
              if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
                return v12;
              }
              uint64_t v38 = VRTraceErrorLogLevelToCSTR();
              uint64_t v39 = *MEMORY[0x1E4F47A50];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
                return v12;
              }
              int v40 = *((unsigned __int8 *)v5 + 1);
              int dataLength_4 = 136316162;
              uint64_t v75 = v38;
              __int16 v76 = 2080;
              long long v77 = "VTP_ProcessPacketType";
              __int16 v78 = 1024;
              int v79 = 6099;
              __int16 v80 = 1024;
              *(_DWORD *)long long v81 = 6099;
              *(_WORD *)&v81[4] = 1024;
              *(_DWORD *)&v81[6] = v40;
              int v41 = " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTra"
                    "nsport.m:%d: VTP_RecvPkt recv bad message=0x%04X";
              uint64_t v42 = v39;
              goto LABEL_85;
            }
            if (v22 == 16) {
              int v21 = 4;
            }
            else {
              int v21 = 8;
            }
          }
        }
      }
LABEL_55:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        uint64_t v26 = VRTraceErrorLogLevelToCSTR();
        __int16 v27 = *MEMORY[0x1E4F47A50];
        int v28 = *MEMORY[0x1E4F47A50];
        if (*MEMORY[0x1E4F47A40])
        {
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            int dataLength_4 = 136315906;
            uint64_t v75 = v26;
            __int16 v76 = 2080;
            long long v77 = "VTP_ProcessPacketType";
            __int16 v78 = 1024;
            int v79 = 6103;
            __int16 v80 = 1024;
            *(_DWORD *)long long v81 = v21;
            _os_log_impl(&dword_1E1EA4000, v27, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d received packet with type=%d", (uint8_t *)&dataLength_4, 0x22u);
          }
        }
        else if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          VTP_ProcessPacketType_cold_5();
        }
      }
      if (dataLength != v6 && (_VTP_ShrinkPacket(a1, dataLength, a4) & 0x80000000) != 0) {
        return 2148990980;
      }
      *(_DWORD *)a4 = v21;
      *(_DWORD *)(a4 + 4) = a3;
      *(_DWORD *)(a4 + 208) = v17;
      *(_DWORD *)(a4 + 212) = v70;
      *(unsigned char *)(a4 + 220) = v19;
      *(_DWORD *)(a4 + 372) = v21;
      if ((v21 & 0x30) != 0)
      {
        *(_DWORD *)(a4 + 192) = bswap32(v5[2]);
        kdebug_trace();
        return 0;
      }
      if ((v21 & 0xC0) == 0) {
        return 0;
      }
      *(_DWORD *)a4 = v21 | 0x40;
      *(_DWORD *)(a4 + 192) = bswap32(v5[1]);
      if (v6 <= 3)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
          return 0;
        }
        uint64_t v61 = VRTraceErrorLogLevelToCSTR();
        int v36 = *MEMORY[0x1E4F47A50];
        uint64_t v12 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
          return v12;
        }
        int dataLength_4 = 136315906;
        uint64_t v75 = v61;
        __int16 v76 = 2080;
        long long v77 = "_VTP_SetRTCPFBMediaSenderSSRC";
        __int16 v78 = 1024;
        int v79 = 3592;
        __int16 v80 = 2048;
        *(void *)long long v81 = v6;
        int v37 = " [%s] %s:%d RTCP packet too small. bufferSize=%zu";
        goto LABEL_153;
      }
      unsigned int v30 = *(unsigned __int16 *)v5;
      if ((v30 >> 8) - 205 > 1) {
        return 0;
      }
      unsigned int v31 = *((unsigned __int16 *)v5 + 1);
      unsigned int v32 = __rev16(v31);
      unint64_t v33 = 4 * v32;
      if (v33 > v6)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
          return 0;
        }
        uint64_t v64 = VRTraceErrorLogLevelToCSTR();
        int v49 = *MEMORY[0x1E4F47A50];
        uint64_t v12 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
          return v12;
        }
        int dataLength_4 = 136316162;
        uint64_t v75 = v64;
        __int16 v76 = 2080;
        long long v77 = "_VTP_SetRTCPFBMediaSenderSSRC";
        __int16 v78 = 1024;
        int v79 = 3596;
        __int16 v80 = 2048;
        *(void *)long long v81 = v6;
        *(_WORD *)&v81[8] = 2048;
        uint64_t v82 = v33;
        int v37 = " [%s] %s:%d RTCP packet too small. bufferSize=%zu rtcpPacketLength=%zu";
      }
      else
      {
        if (!*(unsigned char *)(a4 + 376)) {
          return 0;
        }
        if (!*(unsigned char *)(a4 + 441))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
            return 0;
          }
          uint64_t v65 = VRTraceErrorLogLevelToCSTR();
          __int16 v66 = *MEMORY[0x1E4F47A50];
          uint64_t v12 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
            return v12;
          }
          int dataLength_4 = 136315650;
          uint64_t v75 = v65;
          __int16 v76 = 2080;
          long long v77 = "_VTP_SetRTCPFBMediaSenderSSRC";
          __int16 v78 = 1024;
          int v79 = 3599;
          int v37 = " [%s] %s:%d Packet is not Hop-by-hop encrypted";
          __int16 v62 = v66;
          uint32_t v63 = 28;
LABEL_161:
          _os_log_impl(&dword_1E1EA4000, v62, OS_LOG_TYPE_DEFAULT, v37, (uint8_t *)&dataLength_4, v63);
          return 0;
        }
        if ((v30 & 0xFF00) != 0xCE00) {
          goto LABEL_137;
        }
        int v34 = v30 & 0x1F;
        if (v34 != 15)
        {
          if (v34 == 4)
          {
            if (v31 != 1024)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
                return 0;
              }
              uint64_t v68 = VRTraceErrorLogLevelToCSTR();
              int v36 = *MEMORY[0x1E4F47A50];
              uint64_t v12 = 0;
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
                return v12;
              }
              int dataLength_4 = 136315906;
              uint64_t v75 = v68;
              __int16 v76 = 2080;
              long long v77 = "_VTP_SetRTCPFBMediaSenderSSRC";
              __int16 v78 = 1024;
              int v79 = 3606;
              __int16 v80 = 2048;
              *(void *)long long v81 = v33;
              int v37 = " [%s] %s:%d rtcpPacketLength=%zu not equal to sizeof(RTCP_PSFB_FIR)";
              goto LABEL_153;
            }
            uint64_t v50 = v5 + 3;
            goto LABEL_136;
          }
          if (v34 != 1) {
            goto LABEL_137;
          }
          if (v31 != 512)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
              return 0;
            }
            uint64_t v35 = VRTraceErrorLogLevelToCSTR();
            int v36 = *MEMORY[0x1E4F47A50];
            uint64_t v12 = 0;
            if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
              return v12;
            }
            int dataLength_4 = 136315906;
            uint64_t v75 = v35;
            __int16 v76 = 2080;
            long long v77 = "_VTP_SetRTCPFBMediaSenderSSRC";
            __int16 v78 = 1024;
            int v79 = 3603;
            __int16 v80 = 2048;
            *(void *)long long v81 = v33;
            int v37 = " [%s] %s:%d rtcpPacketLength=%zu not equal to sizeof(RTCP_PSFB_PLI)";
            goto LABEL_153;
          }
LABEL_135:
          uint64_t v50 = v5 + 2;
LABEL_136:
          *(_DWORD *)(a4 + 196) = bswap32(*v50);
LABEL_137:
          if ((*(_WORD *)v5 & 0xFF1F) != 0xCD01) {
            return 0;
          }
          if (v32 < 0x103)
          {
            uint64_t v12 = 0;
            *(_DWORD *)(a4 + 196) = bswap32(v5[2]);
            return v12;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
            return 0;
          }
          uint64_t v67 = VRTraceErrorLogLevelToCSTR();
          int v36 = *MEMORY[0x1E4F47A50];
          uint64_t v12 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
            return v12;
          }
          int dataLength_4 = 136315906;
          uint64_t v75 = v67;
          __int16 v76 = 2080;
          long long v77 = "_VTP_SetRTCPFBMediaSenderSSRC";
          __int16 v78 = 1024;
          int v79 = 3618;
          __int16 v80 = 2048;
          *(void *)long long v81 = v33;
          int v37 = " [%s] %s:%d rtcpPacketLength=%zu is greater than sizeof(RTCP_FMT_RTPFB_GNACK)";
LABEL_153:
          __int16 v62 = v36;
          uint32_t v63 = 38;
          goto LABEL_161;
        }
        unsigned int v47 = v5[3];
        if (v47 == 83886080)
        {
          if (v31 == 1024) {
            goto LABEL_135;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
            return 0;
          }
          uint64_t v69 = VRTraceErrorLogLevelToCSTR();
          int v49 = *MEMORY[0x1E4F47A50];
          uint64_t v12 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
            return v12;
          }
          int dataLength_4 = 136316162;
          uint64_t v75 = v69;
          __int16 v76 = 2080;
          long long v77 = "_VTP_SetRTCPFBMediaSenderSSRC";
          __int16 v78 = 1024;
          int v79 = 3612;
          __int16 v80 = 2048;
          *(void *)long long v81 = v33;
          *(_WORD *)&v81[8] = 2048;
          uint64_t v82 = 16;
          int v37 = " [%s] %s:%d rtcpPacketLength=%zuBytes not equal to sizeof(RTCP_PSFB_LTRACK)=%zuBytes";
        }
        else
        {
          if (v47 != 100663296) {
            goto LABEL_137;
          }
          if (v31 == 1280) {
            goto LABEL_135;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
            return 0;
          }
          uint64_t v48 = VRTraceErrorLogLevelToCSTR();
          int v49 = *MEMORY[0x1E4F47A50];
          uint64_t v12 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
            return v12;
          }
          int dataLength_4 = 136316162;
          uint64_t v75 = v48;
          __int16 v76 = 2080;
          long long v77 = "_VTP_SetRTCPFBMediaSenderSSRC";
          __int16 v78 = 1024;
          int v79 = 3609;
          __int16 v80 = 2048;
          *(void *)long long v81 = v33;
          *(_WORD *)&v81[8] = 2048;
          uint64_t v82 = 20;
          int v37 = " [%s] %s:%d rtcpPacketLength=%zuBytes not equal to sizeof(RTCP_PSFB_LOSSFB)=%zuBytes";
        }
      }
      __int16 v62 = v49;
      uint32_t v63 = 48;
      goto LABEL_161;
    }
    goto LABEL_29;
  }
  unsigned int v15 = v10 - v11;
  if ((int)(v10 - v11) >= 6)
  {
    unsigned int v16 = *(unsigned __int8 *)v13;
    if ((v16 & 0xD0) == 0)
    {
      int v17 = *((unsigned __int8 *)v13 + 1);
      if (v15 > 9 || (v16 & 8) == 0)
      {
        unsigned int v71 = *(unsigned int *)((char *)v13 + 2);
        if ((v16 & 8) != 0)
        {
          if (!IsValidOFTMAC(v8, (uint64_t)&v5[v11 / 4], v15, v17))
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                VTP_ProcessPacketType_cold_6();
              }
            }
            goto LABEL_45;
          }
        }
        else if (((v17 & 0xFE) == 4 || (v17 & 0xFFFFFFFD) == 1) && v8 != 0)
        {
          CFIndex Length = CFStringGetLength(v8);
          if (CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) >= 1)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                VTP_ProcessPacketType_cold_3();
              }
            }
            goto LABEL_45;
          }
        }
        LODWORD(v46) = v11 + 6;
        if ((v16 & 8) != 0) {
          uint64_t v46 = v11 | 0xA;
        }
        else {
          uint64_t v46 = v46;
        }
        int v18 = v10 - v46;
        dataCFIndex Length = v10 - v46;
        memmove(v5, (char *)v5 + v46, v10 - (int)v46);
        unsigned int v20 = bswap32(v71);
        unsigned int v19 = v16 >> 5;
        switch(v17)
        {
          case 0:
            goto LABEL_30;
          case 1:
            if (v16 <= 0x1F)
            {
              unsigned int v70 = v20;
              LOBYTE(v19) = 0;
              *(unsigned char *)(a4 + 221) = ProcessRelayData((unsigned __int16 *)v5, &dataLength);
              int v21 = 1024;
              int v17 = 1;
              goto LABEL_55;
            }
            int v17 = 1;
            LOBYTE(v19) = 1;
            goto LABEL_30;
          case 2:
            unsigned int v70 = v20;
            *(unsigned char *)(a4 + 221) = ProcessRelayData((unsigned __int16 *)v5, &dataLength);
            int v21 = 2048;
            int v17 = 2;
            goto LABEL_55;
          case 3:
            if (v16 <= 0x1F)
            {
              unsigned int v70 = v20;
              LOBYTE(v19) = 0;
              *(unsigned char *)(a4 + 221) = ProcessRelayData((unsigned __int16 *)v5, &dataLength);
              int v21 = 4096;
              int v17 = 3;
              goto LABEL_55;
            }
            LOBYTE(v19) = 1;
            int v17 = 3;
            goto LABEL_30;
          case 4:
            if (v16 < 0x20)
            {
              LOBYTE(v19) = 0;
              int v17 = 4;
              goto LABEL_30;
            }
            unsigned int v70 = v20;
            *(unsigned char *)(a4 + 221) = ProcessRelayData((unsigned __int16 *)v5, &dataLength);
            int v21 = 0x2000;
            int v17 = 4;
            goto LABEL_147;
          case 5:
            unsigned int v70 = v20;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              uint64_t v54 = VRTraceErrorLogLevelToCSTR();
              uint64_t v55 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                int dataLength_4 = 136315650;
                uint64_t v75 = v54;
                __int16 v76 = 2080;
                long long v77 = "VTP_ProcessPacketType";
                __int16 v78 = 1024;
                int v79 = 6015;
                _os_log_impl(&dword_1E1EA4000, v55, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ++++++++++++++++ ARPL packet detected in VTP_RecvPkt(...) ++++++++++++++++", (uint8_t *)&dataLength_4, 0x1Cu);
              }
            }
            int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
            if (v16 < 0x20)
            {
              if (ErrorLogLevelForModule >= 7)
              {
                uint64_t v57 = VRTraceErrorLogLevelToCSTR();
                __int16 v58 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                {
                  int dataLength_4 = 136315650;
                  uint64_t v75 = v57;
                  __int16 v76 = 2080;
                  long long v77 = "VTP_ProcessPacketType";
                  __int16 v78 = 1024;
                  int v79 = 6022;
                  _os_log_impl(&dword_1E1EA4000, v58, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d >>>>> ARPL packetin VTP_RecvPkt(...) is UNENCRYPTED <<<<<", (uint8_t *)&dataLength_4, 0x1Cu);
                }
              }
              LOBYTE(v19) = 0;
              int v17 = 5;
              unsigned int v20 = v70;
              goto LABEL_30;
            }
            if (ErrorLogLevelForModule >= 7)
            {
              uint64_t v59 = VRTraceErrorLogLevelToCSTR();
              __int16 v60 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                int dataLength_4 = 136315650;
                uint64_t v75 = v59;
                __int16 v76 = 2080;
                long long v77 = "VTP_ProcessPacketType";
                __int16 v78 = 1024;
                int v79 = 6017;
                _os_log_impl(&dword_1E1EA4000, v60, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d >>>>> ARPL packetin VTP_RecvPkt(...) is encrypted <<<<<", (uint8_t *)&dataLength_4, 0x1Cu);
              }
            }
            *(unsigned char *)(a4 + 221) = ProcessRelayData((unsigned __int16 *)v5, &dataLength);
            int v21 = 0x2000;
            int v17 = 5;
LABEL_147:
            LOBYTE(v19) = 1;
            goto LABEL_55;
          case 6:
            unsigned int v70 = v20;
            *(unsigned char *)(a4 + 221) = ProcessRelayData((unsigned __int16 *)v5, &dataLength);
            int v21 = 0x8000;
            int v17 = 6;
            goto LABEL_55;
          default:
            uint64_t v12 = 2148991010;
            if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
              return v12;
            }
            uint64_t v51 = VRTraceErrorLogLevelToCSTR();
            int v52 = *MEMORY[0x1E4F47A50];
            uint64_t v53 = *MEMORY[0x1E4F47A50];
            if (!*MEMORY[0x1E4F47A40])
            {
              if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG)) {
                VTP_ProcessPacketType_cold_4();
              }
              return v12;
            }
            if (!os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT)) {
              return v12;
            }
            int dataLength_4 = 136316162;
            uint64_t v75 = v51;
            __int16 v76 = 2080;
            long long v77 = "VTP_ProcessPacketType";
            __int16 v78 = 1024;
            int v79 = 6047;
            __int16 v80 = 1024;
            *(_DWORD *)long long v81 = 6047;
            *(_WORD *)&v81[4] = 1024;
            *(_DWORD *)&v81[6] = v17;
            int v41 = " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTrans"
                  "port.m:%d: unrecognized openfacetime type=%d";
            uint64_t v42 = v52;
            break;
        }
LABEL_85:
        _os_log_impl(&dword_1E1EA4000, v42, OS_LOG_TYPE_DEFAULT, v41, (uint8_t *)&dataLength_4, 0x28u);
        return v12;
      }
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VTP_ProcessPacketType_cold_2();
    }
  }
LABEL_45:
  uint64_t v12 = 2148991010;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VTP_ProcessPacketType_cold_1();
    }
  }
  return v12;
}

int *VTP_UpdateReceivedBytes(int a1, uint64_t a2, int a3, int a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16 = CheckInHandleDebug();
  if (v16)
  {
    uint64_t v17 = v16;
    if (a4) {
      int v18 = 48;
    }
    else {
      int v18 = 28;
    }
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), v18 + (int)a2, memory_order_relaxed);
    if (a1)
    {
      pthread_rwlock_rdlock((pthread_rwlock_t *)(v16 + 21648));
      unsigned int v19 = VTP_getConnectionManagerForCallID(v17, a1);
      VCConnectionManager_UpdateReceivedPacketsAndBytes((uint64_t)v19, a5, a2, a3, a6, a7, a8);
      pthread_rwlock_unlock((pthread_rwlock_t *)(v17 + 21648));
    }
    return (int *)CheckOutHandleDebug();
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_UpdateReceivedBytes_cold_1();
      }
    }
    uint64_t result = __error();
    *uint64_t result = 13;
  }
  return result;
}

uint64_t _VTP_ShrinkPacket(uint64_t a1, size_t dataLength, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  size_t totalLengthOut = 0;
  CMBlockBufferRef blockBufferOut = 0;
  uint64_t v3 = 2148990977;
  dataPointerOut = 0;
  if (!a1) {
    return v3;
  }
  if (!a3) {
    return v3;
  }
  size_t v5 = *(void *)(a3 + 552);
  if (v5 < dataLength) {
    return v3;
  }
  if (v5 == dataLength) {
    return 0;
  }
  if (CMBlockBufferCreateWithBufferReference(*(CFAllocatorRef *)(a1 + 22024), *(CMBlockBufferRef *)(a3 + 544), 0, dataLength, 0, &blockBufferOut))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v8 = VRTraceErrorLogLevelToCSTR();
      int v9 = *MEMORY[0x1E4F47A50];
      int v10 = *MEMORY[0x1E4F47A50];
      if (!*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
          _VTP_ShrinkPacket_cold_2();
        }
        goto LABEL_25;
      }
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        uint64_t v17 = v8;
        __int16 v18 = 2080;
        unsigned int v19 = "_VTP_ShrinkPacket";
        __int16 v20 = 1024;
        int v21 = 776;
LABEL_20:
        _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Failed to retrieve blockBuffer pointer and size", buf, 0x1Cu);
      }
    }
  }
  else
  {
    if (!CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, &totalLengthOut, &dataPointerOut))
    {
      unint64_t v6 = *(const void **)(a3 + 544);
      if (v6) {
        CFRelease(v6);
      }
      uint64_t v3 = 0;
      *(void *)(a3 + 544) = blockBufferOut;
      *(void *)(a3 + 560) = dataPointerOut;
      *(void *)(a3 + 552) = totalLengthOut;
      return v3;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v11 = VRTraceErrorLogLevelToCSTR();
      int v9 = *MEMORY[0x1E4F47A50];
      uint64_t v12 = *MEMORY[0x1E4F47A50];
      if (!*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
          _VTP_ShrinkPacket_cold_1();
        }
        goto LABEL_25;
      }
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        uint64_t v17 = v11;
        __int16 v18 = 2080;
        unsigned int v19 = "_VTP_ShrinkPacket";
        __int16 v20 = 1024;
        int v21 = 779;
        goto LABEL_20;
      }
    }
  }
LABEL_25:
  uint64_t v3 = 2148990980;
  if (blockBufferOut) {
    CFRelease(blockBufferOut);
  }
  return v3;
}

uint64_t _VTP_AllocatePacketWithBufferFreeCallback(uint64_t a1, void *a2, size_t a3, void (__cdecl *a4)(void *, void *, size_t), void *a5, CMBlockBufferRef **a6)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = (CMBlockBufferRef *)VCMemoryPool_Alloc(*(OSQueueHead **)(a1 + 5872));
  __int16 v18 = v12;
  if (!v12)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      unsigned int v15 = (void *(__cdecl *)(void *, size_t))VRTraceErrorLogLevelToCSTR();
      uint64_t v16 = *MEMORY[0x1E4F47A50];
      uint64_t v17 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          customBlockSource.version = 136315650;
          customBlockSource.AllocateBlocuint64_t k = v15;
          LOWORD(customBlockSource.FreeBlock) = 2080;
          *(void (__cdecl **)(void *, void *, size_t))((char *)&customBlockSource.FreeBlock + 2) = (void (__cdecl *)(void *, void *, size_t))"_VTP_AllocatePacketWithBufferFreeCallback";
          WORD1(customBlockSource.refCon) = 1024;
          HIDWORD(customBlockSource.refCon) = 715;
          _os_log_impl(&dword_1E1EA4000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Failed to allocate VTP packet", (uint8_t *)&customBlockSource, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        _VTP_AllocatePacketWithBufferFreeCallback_cold_1();
      }
    }
    goto LABEL_30;
  }
  int v13 = v12;
  if (a3)
  {
    if (a4)
    {
      customBlockSource.version = 0;
      customBlockSource.AllocateBlocuint64_t k = 0;
      customBlockSource.FreeBlocuint64_t k = a4;
      customBlockSource.refCon = a5;
      if (CMBlockBufferCreateWithMemoryBlock(*(CFAllocatorRef *)(a1 + 22024), a2, a3, 0, &customBlockSource, 0, a3, 1u, v12 + 68))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VTP_AllocatePacketWithBufferFreeCallback_cold_5();
          }
        }
LABEL_30:
        _VTP_ReleasePacket(a1, (void **)&v18);
        int v13 = 0;
        uint64_t result = 2148990980;
        goto LABEL_14;
      }
    }
    else
    {
      if (VCBlockBufferUtlities_Create(*(const __CFAllocator **)(a1 + 22024), 0, a3, *(const __CFAllocator **)(a1 + 22032), 0, 0, a3, 1u, v12 + 68))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VTP_AllocatePacketWithBufferFreeCallback_cold_4();
          }
        }
        goto LABEL_30;
      }
      if (a2 && CMBlockBufferReplaceDataBytes(a2, v13[68], 0, a3))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VTP_AllocatePacketWithBufferFreeCallback_cold_3();
          }
        }
        goto LABEL_30;
      }
    }
    if (CMBlockBufferGetDataPointer(v13[68], 0, 0, (size_t *)v13 + 69, (char **)v13 + 70))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VTP_AllocatePacketWithBufferFreeCallback_cold_2();
        }
      }
      goto LABEL_30;
    }
  }
  else
  {
    v12[70] = 0;
    v12[69] = 0;
  }
  uint64_t result = 0;
  *((unsigned char *)v13 + 516) = 1;
LABEL_14:
  *a6 = v13;
  return result;
}

uint64_t VTP_IFIndexToName(uint64_t a1, unsigned int a2, char *a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = (pthread_mutex_t *)(a1 + 5792);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 5792));
  uint64_t v7 = (int *)(a1 + 5864);
  uint64_t v8 = *(unsigned int *)(a1 + 5864);
  if ((int)v8 < 1)
  {
    LODWORD(v9) = 0;
    int v11 = -1;
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = (_OWORD *)(*(void *)(a1 + 5856) + 4);
    int v11 = -1;
    while (1)
    {
      int v12 = *((_DWORD *)v10 - 1);
      if (v12 == a2) {
        break;
      }
      if (v12) {
        int v13 = -1;
      }
      else {
        int v13 = v9;
      }
      if (v11 == -1) {
        int v11 = v13;
      }
      ++v9;
      int v10 = (_OWORD *)((char *)v10 + 20);
      if (v8 == v9) {
        goto LABEL_14;
      }
    }
    *(_OWORD *)a3 = *v10;
    LODWORD(v8) = *v7;
  }
  if (v9 == v8)
  {
LABEL_14:
    if (if_indextoname(a2, a3))
    {
      if (v11 != -1)
      {
        unsigned int v14 = *(char **)(a1 + 5856);
        goto LABEL_17;
      }
      int v11 = *v7;
      int v21 = 2 * *v7;
      *uint64_t v7 = v21;
      if (v21)
      {
        unsigned int v14 = (char *)malloc_type_realloc(*(void **)(a1 + 5856), 20 * v21, 0x1000040A86A77D5uLL);
        if (v14)
        {
          *(void *)(a1 + 5856) = v14;
LABEL_17:
          unsigned int v15 = &v14[20 * v11];
          *(_DWORD *)unsigned int v15 = a2;
          *(_OWORD *)(v15 + 4) = *(_OWORD *)a3;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            uint64_t v16 = VRTraceErrorLogLevelToCSTR();
            uint64_t v17 = *MEMORY[0x1E4F47A50];
            __int16 v18 = *MEMORY[0x1E4F47A50];
            if (*MEMORY[0x1E4F47A40])
            {
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              {
                int v23 = 136316162;
                uint64_t v24 = v16;
                __int16 v25 = 2080;
                uint64_t v26 = "VTP_IFIndexToName";
                __int16 v27 = 1024;
                int v28 = 3736;
                __int16 v29 = 1024;
                unsigned int v30 = a2;
                __int16 v31 = 2080;
                unsigned int v32 = a3;
                _os_log_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_IFIndexToName mapping [if_index:%d if_name:%s]\n", (uint8_t *)&v23, 0x2Cu);
              }
            }
            else if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
            {
              int v23 = 136316162;
              uint64_t v24 = v16;
              __int16 v25 = 2080;
              uint64_t v26 = "VTP_IFIndexToName";
              __int16 v27 = 1024;
              int v28 = 3736;
              __int16 v29 = 1024;
              unsigned int v30 = a2;
              __int16 v31 = 2080;
              unsigned int v32 = a3;
              _os_log_debug_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VTP_IFIndexToName mapping [if_index:%d if_name:%s]\n", (uint8_t *)&v23, 0x2Cu);
            }
          }
          return pthread_mutex_unlock(v6);
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
      {
        VRTraceErrorLogLevelToCSTR();
        if (VRTraceIsOSFaultDisabled())
        {
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VTP_IFIndexToName_cold_2();
          }
        }
        else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
        {
          VTP_IFIndexToName_cold_3();
        }
      }
    }
    else
    {
      __error();
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v19 = VRTraceErrorLogLevelToCSTR();
        uint64_t v20 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VTP_IFIndexToName_cold_1(v19, a2, v20);
        }
      }
    }
  }
  return pthread_mutex_unlock(v6);
}

uint64_t ProcessRelayData(unsigned __int16 *__dst, int *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  int v4 = *a2;
  int v5 = *__dst;
  if ((v5 & 0xC0) == 0)
  {
    if (v5 == 1792)
    {
      memset(__b, 170, sizeof(__b));
      if ((ParseSTUNMessage() & 0x80000000) == 0 && GetSTUNAttr())
      {
        uint64_t STUNAttr = GetSTUNAttr();
        if (STUNAttr)
        {
          size_t v10 = *(unsigned int *)(STUNAttr + 8);
          if ((int)v10 >= 1 && (int)v10 < v4)
          {
            *a2 = v10;
            memcpy(__dst, *(const void **)(STUNAttr + 16), v10);
          }
        }
        FreeSTUNMessage();
        return 1;
      }
      FreeSTUNMessage();
    }
    return 0;
  }
  uint64_t result = 0;
  if (v4 >= 4 && (v5 & 0xC0) == 0x40)
  {
    unsigned int v7 = bswap32(__dst[1]);
    if (v4 - 4 == HIWORD(v7))
    {
      size_t v8 = HIWORD(v7);
      *a2 = v8;
      memmove(__dst, __dst + 2, v8);
      return 1;
    }
    return 0;
  }
  return result;
}

uint64_t IsValidOFTMAC(const __CFString *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    CFIndex Length = CFStringGetLength(a1);
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    if (MaximumSizeForEncoding >= 1)
    {
      size_t v9 = MaximumSizeForEncoding;
      CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
      MEMORY[0x1F4188790](CStringPtr);
      memset(&macOut[-((v9 + 15) & 0xFFFFFFFFFFFFFFF0)], 170, v9);
      if (CStringPtr
        || (uint64_t result = CFStringGetCString(a1, &macOut[-((v9 + 15) & 0xFFFFFFFFFFFFFFF0)], v9, 0x8000100u),
            CStringPtr = &macOut[-((v9 + 15) & 0xFFFFFFFFFFFFFFF0)],
            result))
      {
        memset(macOut, 170, 20);
        size_t v12 = strlen(CStringPtr);
        CCHmac(0, CStringPtr, v12, (const void *)(a2 + 10), a3 - 10, macOut);
        return *(_DWORD *)macOut == *(_DWORD *)(a2 + 6);
      }
      return result;
    }
    return 0;
  }
  if (a4 > 1) {
    return 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v14 = VRTraceErrorLogLevelToCSTR();
    unsigned int v15 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)macOut = 136315906;
      *(void *)&void macOut[4] = v14;
      *(_WORD *)&macOut[12] = 2080;
      *(void *)&macOut[14] = "IsValidOFTMAC";
      __int16 v17 = 1024;
      int v18 = 3349;
      __int16 v19 = 1024;
      int v20 = a4;
      _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Skip OFT MAC validation for packet(%d), sessionID not ready.", macOut, 0x22u);
    }
  }
  return 1;
}

uint64_t VTP_PassPkt(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  unsigned int v32 = (pthread_rwlock_t *)(a1 + 5584);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 5584));
  uint64_t v33 = (pthread_mutex_t *)(a2 + 112);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 112));
  uint64_t v6 = *(void *)(a2 + 104);
  if (v6)
  {
    int v7 = 0;
    unsigned int v8 = -1;
    do
    {
      uint64_t v9 = v6;
      uint64_t v6 = *(void *)(v6 + 536);
      ++v7;
      ++v8;
    }
    while (v6);
    *(void *)(v9 + 536) = a3;
    int v10 = v7 - 1;
    if ((v7 - 1) >= 0x32 && ((50 * (v8 / 0x32)) | 1) == v7)
    {
      memset(v34, 0, 96);
      VCUtil_ConvertStreamIDArrayToString((size_t)(a3 + 96), *((unsigned __int8 *)a3 + 408), v34, 0x60uLL);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v11 = VRTraceErrorLogLevelToCSTR();
        size_t v12 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v13 = *((void *)a3 + 69);
          int v14 = *a3;
          int v15 = *(_DWORD *)a2;
          *(_DWORD *)buf = 136316930;
          *(void *)&uint8_t buf[4] = v11;
          __int16 v44 = 2080;
          double v45 = "VTP_PassPkt";
          __int16 v46 = 1024;
          int v47 = 3923;
          __int16 v48 = 1024;
          int v49 = v10;
          __int16 v50 = 1024;
          int v51 = v13;
          __int16 v52 = 1024;
          int v53 = v14;
          __int16 v54 = 2080;
          uint64_t v55 = v34;
          __int16 v56 = 1024;
          int v57 = v15;
          _os_log_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ###### VTP_PassPkt packet list is growing and not draining!!! count:%d (len=%d type=%04X) streamIDs:%s, vfd:%d ######", buf, 0x3Eu);
        }
      }
    }
  }
  else
  {
    *(void *)(a2 + 104) = a3;
  }
  pthread_cond_signal((pthread_cond_t *)(a2 + 176));
  pthread_mutex_unlock(v33);
  for (uint64_t i = *(int **)(a1 + 5784); i; uint64_t i = (int *)*((void *)i + 19))
  {
    if (*((unsigned char *)i + 121))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        uint64_t v17 = VRTraceErrorLogLevelToCSTR();
        int v18 = *MEMORY[0x1E4F47A50];
        __int16 v19 = *MEMORY[0x1E4F47A50];
        if (*MEMORY[0x1E4F47A40])
        {
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            int v20 = *i;
            *(_DWORD *)int v34 = 136315906;
            *(void *)&uint8_t v34[4] = v17;
            *(_WORD *)&v34[12] = 2080;
            *(void *)&v34[14] = "VTP_PassPkt";
            *(_WORD *)&v34[22] = 1024;
            *(_DWORD *)&v34[24] = 3932;
            *(_WORD *)&v34[28] = 1024;
            *(_DWORD *)&v34[30] = v20;
            _os_log_impl(&dword_1E1EA4000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d receiving packet on a closed handle! id[%d], ignoring....", v34, 0x22u);
          }
        }
        else if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          int v30 = *i;
          *(_DWORD *)int v34 = 136315906;
          *(void *)&uint8_t v34[4] = v17;
          *(_WORD *)&v34[12] = 2080;
          *(void *)&v34[14] = "VTP_PassPkt";
          *(_WORD *)&v34[22] = 1024;
          *(_DWORD *)&v34[24] = 3932;
          *(_WORD *)&v34[28] = 1024;
          *(_DWORD *)&v34[30] = v30;
          _os_log_debug_impl(&dword_1E1EA4000, v18, OS_LOG_TYPE_DEBUG, " [%s] %s:%d receiving packet on a closed handle! id[%d], ignoring....", v34, 0x22u);
        }
      }
    }
    else
    {
      int v21 = *(_DWORD *)a2;
      uint64_t v22 = (char *)*((void *)i + 16);
      if (__darwin_check_fd_set_overflow(*(_DWORD *)a2, v22, 0)
        && ((*(_DWORD *)&v22[((unint64_t)v21 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v21) & 1) != 0)
      {
        pthread_mutex_lock((pthread_mutex_t *)(i + 2));
        if (*((void *)i + 20))
        {
          pthread_mutex_lock(v33);
          while (1)
          {
            uint64_t v23 = *(void *)(a2 + 104);
            *(void *)buf = v23;
            if (!v23) {
              break;
            }
            bzero(v34, 0x218uLL);
            *(void *)int v34 = *(void *)(v23 + 184);
            memcpy(v41, (const void *)(v23 + 208), sizeof(v41));
            long long v24 = *(_OWORD *)(v23 + 8);
            long long v25 = *(_OWORD *)(v23 + 24);
            uint64_t v40 = *(void *)(v23 + 40);
            long long v38 = v24;
            long long v39 = v25;
            long long v26 = *(_OWORD *)(v23 + 64);
            *(_OWORD *)&v34[8] = *(_OWORD *)(v23 + 48);
            *(_OWORD *)&v34[24] = v26;
            long long v27 = *(_OWORD *)(v23 + 128);
            *(_OWORD *)&v34[72] = *(_OWORD *)(v23 + 112);
            *(_OWORD *)&v34[88] = v27;
            long long v28 = *(_OWORD *)(v23 + 160);
            long long v35 = *(_OWORD *)(v23 + 144);
            long long v36 = v28;
            long long v29 = *(_OWORD *)(v23 + 96);
            *(_OWORD *)&v34[40] = *(_OWORD *)(v23 + 80);
            *(_OWORD *)&v34[56] = v29;
            int v37 = *(_DWORD *)(v23 + 176);
            VCBlockBuffer_Copy(v23 + 544, (uint64_t)v42);
            if (*(unsigned char *)(v23 + 223)) {
              LODWORD(v38) = v38 | 1;
            }
            (*(void (**)(void))(*((void *)i + 20) + 16))();
            *(void *)(a2 + 104) = *(void *)(*(void *)buf + 536);
            VCBlockBuffer_Clear((uint64_t)v42);
            if (**(_DWORD **)buf == 48) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 21968), 1uLL, memory_order_relaxed);
            }
            _VTP_ReleasePacket(a1, (void **)buf);
          }
          pthread_mutex_unlock(v33);
        }
        else
        {
          *((unsigned char *)i + 120) = 1;
          pthread_cond_signal((pthread_cond_t *)(i + 18));
        }
        pthread_mutex_unlock((pthread_mutex_t *)(i + 2));
      }
    }
  }
  return pthread_rwlock_unlock(v32);
}

uint64_t VTP_SendOnePacketWithSocket(int a1, int a2, unsigned char *a3, char a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, int a9)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SendOnePacketWithSocket_cold_1();
      }
    }
    int v20 = __error();
    int v21 = 22;
    goto LABEL_13;
  }
  uint64_t v16 = CheckInHandleDebug();
  if (!v16)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VTP_SendOnePacketWithSocket_cold_2();
      }
    }
    int v20 = __error();
    int v21 = 13;
LABEL_13:
    *int v20 = v21;
    return -1;
  }
  uint64_t v17 = v16;
  *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v29.msg_iov = v18;
  *(_OWORD *)&v29.msg_control = v18;
  *(_OWORD *)&v29.msg_name = v18;
  memset(v37, 0, 128);
  if (a4)
  {
    socklen_t v19 = 0;
    v29.msg_name = 0;
  }
  else
  {
    if (*a3)
    {
      int v28 = 28;
      IPPORTToSA6();
    }
    else
    {
      int v28 = 16;
      IPPORTToSA();
    }
    v29.msg_name = v37;
    socklen_t v19 = v28;
  }
  v29.msg_namelen = v19;
  *(void *)&long long v23 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v35 = v23;
  long long v36 = v23;
  long long v33 = v23;
  long long v34 = v23;
  long long v31 = v23;
  long long v32 = v23;
  v30[0] = a5;
  v30[1] = a6;
  v29.msg_iov = (iovec *)v30;
  v29.msg_iovlen = 1;
  v29.msg_char flags = 0;
  if (a2 == 1 || *(unsigned char *)(v17 + 21625))
  {
    v29.msg_control = 0;
    v29.msg_controllen = 0;
  }
  else
  {
    v29.msg_control = &v35;
    v29.msg_controllen = 32;
    *(void *)&long long v35 = 0xFFFF00000010;
    DWORD2(v35) = 4230;
    int v24 = *(_DWORD *)(v17 + 21628);
    if (!v24) {
      int v24 = a7;
    }
    unsigned int v25 = (*(_DWORD *)a3 & 1) == 0;
    HIDWORD(v35) = v24;
    LODWORD(v36) = 16;
    *(int8x8_t *)((char *)&v36 + 4) = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v25), 0x1FuLL)), (int8x8_t)0x300000000, (int8x8_t)0x2400000029);
    HIDWORD(v36) = a9;
  }
  ssize_t v22 = sendmsg(a1, &v29, 0);
  kdebug_trace();
  if (v22 >= 1)
  {
    if (*(_DWORD *)a3) {
      int v26 = 48;
    }
    else {
      int v26 = 28;
    }
    atomic_fetch_add_explicit((atomic_ullong *volatile)v17, v26 + (int)v22, memory_order_relaxed);
  }
  CheckOutHandleDebug();
  return v22;
}

void _VTP_UpdateIDSDatagramOptionWithChannelDataFormat(uint64_t a1, uint64_t a2, int a3)
{
  if (a2)
  {
    uint64_t v3 = *(unsigned __int8 *)(a1 + 24);
    if (*(unsigned char *)(a1 + 24))
    {
      *(_DWORD *)a2 |= 2u;
      int v4 = (_WORD *)(a2 + 20);
      uint64_t v5 = v3;
      uint64_t v6 = (__int16 *)a1;
      do
      {
        __int16 v7 = *v6++;
        *v4++ = v7;
        --v5;
      }
      while (v5);
      *(unsigned char *)(a2 + 19) = v3;
    }
    char v8 = *(unsigned char *)(a1 + 28);
    if (v8)
    {
      *(_DWORD *)a2 |= 8u;
      *(unsigned char *)(a2 + 18) = v8;
    }
    if (*(unsigned char *)(a1 + 29)) {
      *(_DWORD *)a2 |= 4u;
    }
    if (*(unsigned char *)(a1 + 25))
    {
      *(_DWORD *)a2 |= 0x10u;
      *(_WORD *)(a2 + 16) = *(_WORD *)(a1 + 26);
    }
    if (*(unsigned char *)(a1 + 30))
    {
      *(_DWORD *)a2 |= 1u;
      *(void *)(a2 + 8) = *(void *)(a1 + 32);
    }
    char v9 = *(unsigned char *)(a1 + 76);
    if (v9)
    {
      *(_DWORD *)a2 |= 0x10000u;
      *(unsigned char *)(a2 + 112) = v9;
    }
    if (*(unsigned char *)(a1 + 58))
    {
      *(_DWORD *)a2 |= 0x8000u;
      *(void *)(a2 + 88) = *(void *)(a1 + 64);
    }
    if (*(unsigned char *)(a1 + 41)) {
      *(_DWORD *)a2 |= 0x80u;
    }
    if (a3 && *(unsigned char *)(a1 + 42))
    {
      *(_DWORD *)a2 |= 0x40u;
      *(_WORD *)(a2 + 46) = *(_WORD *)(a1 + 44);
    }
    if (*(unsigned char *)(a1 + 56)) {
      *(_DWORD *)a2 |= 0x100u;
    }
    if (*(unsigned char *)(a1 + 57))
    {
      *(_DWORD *)a2 |= 0x400u;
      *(unsigned char *)(a2 + 80) = 1;
    }
    char v10 = *(unsigned char *)(a1 + 79);
    if (v10)
    {
      *(_DWORD *)a2 |= 0x20000u;
      *(unsigned char *)(a2 + 113) = v10;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VTP_UpdateIDSDatagramOptionWithChannelDataFormat_cold_1();
    }
  }
}

void _VTP_ReportIDSOnTheWireBytesLocked(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5)
{
  if (a4)
  {
    if (a2)
    {
      __int16 v7 = VTP_getConnectionManagerForCallID(a1, a2);
      if (v7)
      {
        uint64_t v8 = (uint64_t)v7;
        char v9 = (const void *)VCConnectionManager_CopyPrimaryConnection((uint64_t)v7);
        uint64_t v10 = VCConnection_PerPacketConnectionOverhead((uint64_t)v9);
        if (v9) {
          CFRelease(v9);
        }
        unint64_t v11 = v10 + a3 + IDSEstimateAdditionalOverheadForDatagramOptions();
        if (a5)
        {
          VCConnectionManager_UpdateOnTheWireBytesSentCount(v8, v11);
        }
        else
        {
          VCConnectionManager_UpdateOnTheWireBytesReceivedCount(v8, v11);
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VTP_ReportIDSOnTheWireBytesLocked_cold_2();
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VTP_ReportIDSOnTheWireBytesLocked_cold_1();
    }
  }
}

void _VTP_ProcessPacketForDirectIDSDataPath(uint64_t a1, unsigned char *a2, _DWORD *a3)
{
  v7[1] = *(void **)MEMORY[0x1E4F143B8];
  v7[0] = a3;
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3
      && (VRTraceErrorLogLevelToCSTR(), os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)))
    {
      _VTP_ProcessPacketForDirectIDSDataPath_cold_1();
      if (!a3) {
        return;
      }
    }
    else if (!a3)
    {
      return;
    }
    _VTP_ReleasePacket(a1, v7);
    return;
  }
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 5376));
  int v6 = 1;
  VTP_DemuxPacketsToVFDList(a1, a2, &v6);
  if (a3)
  {
    if (*a3 == 0x20000)
    {
      int v6 = 1;
      VTP_DemuxPacketsToVFDList(a1, a3, &v6);
    }
  }
  pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 5376));
}

void _VTP_ProcessPacketForSharedIDSDataPath(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 21856);
    if (v3)
    {
      int v4 = 0;
      do
      {
        uint64_t v5 = v3;
        uint64_t v3 = *(void *)(v3 + 536);
        ++v4;
      }
      while (v3);
      int v6 = (void *)(v5 + 536);
    }
    else
    {
      int v6 = (void *)(a1 + 21856);
      int v4 = 1;
    }
    void *v6 = a2;
    if (a3)
    {
      if (*a3 == 0x20000)
      {
        *(void *)(a2 + 536) = a3;
        ++v4;
      }
    }
    *(_DWORD *)(a1 + 21864) = v4;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VTP_ProcessPacketForSharedIDSDataPath_cold_1();
    }
  }
}

void OUTLINED_FUNCTION_13_7(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x2Cu);
}

void OUTLINED_FUNCTION_38(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 0x28u);
}

void OUTLINED_FUNCTION_41(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x2Eu);
}

void __VCAVFoundationLoadARKit_block_invoke()
{
  uint64_t v0 = dlopen("/System/Library/Frameworks/ARKit.framework/ARKit", 2);
  VCAVFoundationLoadARKit_frameworkLibrary = (uint64_t)v0;
  if (v0)
  {
    sVC_ARAdjustIntrinsicsForViewportSize = dlsym(v0, "ARAdjustIntrinsicsForViewportSize");
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v1 = VRTraceErrorLogLevelToCSTR();
    uint64_t v2 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      __VCAVFoundationLoadARKit_block_invoke_cold_1(v1, v2);
    }
  }
}

Class __VCAVFoundationGetARImageData_block_invoke()
{
  if (VCAVFoundationLoadARKit_loadPredicate != -1) {
    dispatch_once(&VCAVFoundationLoadARKit_loadPredicate, &__block_literal_global_50);
  }
  Class result = objc_getClass("ARImageData");
  VCAVFoundationGetARImageData_cls = (uint64_t)result;
  return result;
}

Class __VCAVFoundationGetARFaceData_block_invoke()
{
  if (VCAVFoundationLoadARKit_loadPredicate != -1) {
    dispatch_once(&VCAVFoundationLoadARKit_loadPredicate, &__block_literal_global_50);
  }
  Class result = objc_getClass("ARFaceData");
  VCAVFoundationGetARFaceData_cls = (uint64_t)result;
  return result;
}

Class __VCGetARHWFaceDetection_block_invoke()
{
  if (VCAVFoundationLoadARKit_loadPredicate != -1) {
    dispatch_once(&VCAVFoundationLoadARKit_loadPredicate, &__block_literal_global_50);
  }
  Class result = objc_getClass("ARHWFaceDetection");
  VCGetARHWFaceDetection_cls = (uint64_t)result;
  return result;
}

void _VCAVFoundationCapture_ConvertPixelFormat(OpaqueVTPixelTransferSession *a1, __CVPixelBufferPool *a2, CMSampleBufferRef *a3, uint64_t a4)
{
  pixelBufferOut[1] = *(CVPixelBufferRef *)MEMORY[0x1E4F143B8];
  pixelBufferOut[0] = 0;
  ImageBuffer = CMSampleBufferGetImageBuffer(*a3);
  if (CVPixelBufferPoolCreatePixelBuffer((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, pixelBufferOut))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCAVFoundationCapture_ConvertPixelFormat_cold_2();
      }
    }
  }
  else if (VTPixelTransferSessionTransferImage(a1, ImageBuffer, pixelBufferOut[0]))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCAVFoundationCapture_ConvertPixelFormat_cold_1();
      }
    }
  }
  else
  {
    long long v10 = *(_OWORD *)a4;
    uint64_t v11 = *(void *)(a4 + 16);
    CMSampleBufferRef v9 = createSampleBufferWithPixelBuffer(pixelBufferOut[0], &v10);
    CMPropagateAttachments(*a3, v9);
    FigSampleBufferRelease();
    *a3 = v9;
  }
  CVPixelBufferRelease(pixelBufferOut[0]);
}

void sub_1E21A6378(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1E21A649C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1E21A65C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1E21A66E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1E21A6808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1E21A692C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t VCMediaNegotiationBlobReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  __int16 v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      unint64_t v12 = *(void *)(a2 + v11);
      if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
        break;
      }
      char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v14 = v9++ >= 9;
      if (v14)
      {
        unint64_t v10 = 0;
        int v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v15 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0;
        *(unsigned char *)(a1 + 132) |= 0x20u;
        while (1)
        {
          uint64_t v20 = *v3;
          unint64_t v21 = *(void *)(a2 + v20);
          if (v21 == -1 || v21 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v22 = *(unsigned char *)(*(void *)(a2 + *v7) + v21);
          *(void *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0) {
            goto LABEL_100;
          }
          v17 += 7;
          BOOL v14 = v18++ >= 9;
          if (v14)
          {
            uint64_t v19 = 0;
            goto LABEL_102;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_100:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v19 = 0;
        }
LABEL_102:
        BOOL v70 = v19 != 0;
        uint64_t v71 = 128;
        goto LABEL_107;
      case 2u:
        char v24 = 0;
        unsigned int v25 = 0;
        uint64_t v26 = 0;
        *(unsigned char *)(a1 + 132) |= 0x40u;
        while (2)
        {
          uint64_t v27 = *v3;
          unint64_t v28 = *(void *)(a2 + v27);
          if (v28 == -1 || v28 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v29 = *(unsigned char *)(*(void *)(a2 + *v7) + v28);
            *(void *)(a2 + v27) = v28 + 1;
            v26 |= (unint64_t)(v29 & 0x7F) << v24;
            if (v29 < 0)
            {
              v24 += 7;
              BOOL v14 = v25++ >= 9;
              if (v14)
              {
                uint64_t v26 = 0;
                goto LABEL_106;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v26 = 0;
        }
LABEL_106:
        BOOL v70 = v26 != 0;
        uint64_t v71 = 129;
LABEL_107:
        *(unsigned char *)(a1 + v71) = v70;
        goto LABEL_129;
      case 3u:
        int v30 = objc_alloc_init(VCMediaNegotiationBlobAudioSettings);

        *(void *)(a1 + 24) = v30;
        if (PBReaderPlaceMark()
          && (VCMediaNegotiationBlobAudioSettingsReadFrom((uint64_t)v30, a2) & 1) != 0)
        {
          goto LABEL_37;
        }
        return 0;
      case 4u:
        long long v31 = objc_alloc_init(VCMediaNegotiationBlobVideoSettings);

        uint64_t v32 = 120;
        goto LABEL_40;
      case 5u:
        long long v31 = objc_alloc_init(VCMediaNegotiationBlobVideoSettings);

        uint64_t v32 = 104;
LABEL_40:
        *(void *)(a1 + v32) = v31;
        if (!PBReaderPlaceMark()
          || (VCMediaNegotiationBlobVideoSettingsReadFrom((char *)v31, a2) & 1) == 0)
        {
          return 0;
        }
        goto LABEL_37;
      case 6u:
        String = (void *)PBReaderReadString();

        id v34 = String;
        uint64_t v35 = 112;
        goto LABEL_45;
      case 7u:
        long long v36 = (void *)PBReaderReadString();

        id v34 = v36;
        uint64_t v35 = 40;
LABEL_45:
        *(void *)(a1 + v35) = v34;
        goto LABEL_129;
      case 8u:
        char v37 = 0;
        unsigned int v38 = 0;
        uint64_t v39 = 0;
        *(unsigned char *)(a1 + 132) |= 4u;
        while (2)
        {
          uint64_t v40 = *v3;
          unint64_t v41 = *(void *)(a2 + v40);
          if (v41 == -1 || v41 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v42 = *(unsigned char *)(*(void *)(a2 + *v7) + v41);
            *(void *)(a2 + v40) = v41 + 1;
            v39 |= (unint64_t)(v42 & 0x7F) << v37;
            if (v42 < 0)
            {
              v37 += 7;
              BOOL v14 = v38++ >= 9;
              if (v14)
              {
                LODWORD(v39) = 0;
                goto LABEL_111;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v39) = 0;
        }
LABEL_111:
        uint64_t v72 = 48;
        goto LABEL_128;
      case 9u:
        int v43 = objc_alloc_init(VCMediaNegotiationBlobBandwidthSettings);
        [(id)a1 addBandwidthSettings:v43];

        if (!PBReaderPlaceMark() || !VCMediaNegotiationBlobBandwidthSettingsReadFrom((uint64_t)v43, a2)) {
          return 0;
        }
        goto LABEL_37;
      case 0xAu:
        __int16 v44 = objc_alloc_init(VCMediaNegotiationBlobCaptionsSettings);

        *(void *)(a1 + 56) = v44;
        if (!PBReaderPlaceMark()
          || (VCMediaNegotiationBlobCaptionsSettingsReadFrom((uint64_t)v44, a2) & 1) == 0)
        {
          return 0;
        }
        goto LABEL_37;
      case 0xBu:
        double v45 = objc_alloc_init(VCMediaNegotiationBlobMultiwayAudioStream);
        [(id)a1 addMultiwayAudioStreams:v45];

        if (!PBReaderPlaceMark()
          || (VCMediaNegotiationBlobMultiwayAudioStreamReadFrom((uint64_t)v45, a2) & 1) == 0)
        {
          return 0;
        }
        goto LABEL_37;
      case 0xCu:
        __int16 v46 = objc_alloc_init(VCMediaNegotiationBlobMomentsSettings);

        *(void *)(a1 + 80) = v46;
        if (!PBReaderPlaceMark() || !VCMediaNegotiationBlobMomentsSettingsReadFrom((uint64_t)v46, a2)) {
          return 0;
        }
        goto LABEL_37;
      case 0xDu:
        char v47 = 0;
        unsigned int v48 = 0;
        uint64_t v49 = 0;
        *(unsigned char *)(a1 + 132) |= 1u;
        while (2)
        {
          uint64_t v50 = *v3;
          unint64_t v51 = *(void *)(a2 + v50);
          if (v51 == -1 || v51 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v52 = *(unsigned char *)(*(void *)(a2 + *v7) + v51);
            *(void *)(a2 + v50) = v51 + 1;
            v49 |= (unint64_t)(v52 & 0x7F) << v47;
            if (v52 < 0)
            {
              v47 += 7;
              BOOL v14 = v48++ >= 9;
              if (v14)
              {
                uint64_t v49 = 0;
                goto LABEL_115;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v49 = 0;
        }
LABEL_115:
        *(void *)(a1 + 8) = v49;
        goto LABEL_129;
      case 0xEu:
        char v53 = 0;
        unsigned int v54 = 0;
        uint64_t v39 = 0;
        *(unsigned char *)(a1 + 132) |= 8u;
        while (2)
        {
          uint64_t v55 = *v3;
          unint64_t v56 = *(void *)(a2 + v55);
          if (v56 == -1 || v56 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v57 = *(unsigned char *)(*(void *)(a2 + *v7) + v56);
            *(void *)(a2 + v55) = v56 + 1;
            v39 |= (unint64_t)(v57 & 0x7F) << v53;
            if (v57 < 0)
            {
              v53 += 7;
              BOOL v14 = v54++ >= 9;
              if (v14)
              {
                LODWORD(v39) = 0;
                goto LABEL_119;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v39) = 0;
        }
LABEL_119:
        uint64_t v72 = 52;
        goto LABEL_128;
      case 0xFu:
        uint64_t v58 = objc_alloc_init(VCMediaNegotiationBlobMultiwayVideoStream);
        [(id)a1 addMultiwayVideoStream:v58];

        if (!PBReaderPlaceMark() || !VCMediaNegotiationBlobMultiwayVideoStreamReadFrom((uint64_t)v58, a2)) {
          return 0;
        }
        goto LABEL_37;
      case 0x10u:
        char v59 = 0;
        unsigned int v60 = 0;
        uint64_t v39 = 0;
        *(unsigned char *)(a1 + 132) |= 0x10u;
        while (2)
        {
          uint64_t v61 = *v3;
          unint64_t v62 = *(void *)(a2 + v61);
          if (v62 == -1 || v62 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v63 = *(unsigned char *)(*(void *)(a2 + *v7) + v62);
            *(void *)(a2 + v61) = v62 + 1;
            v39 |= (unint64_t)(v63 & 0x7F) << v59;
            if (v63 < 0)
            {
              v59 += 7;
              BOOL v14 = v60++ >= 9;
              if (v14)
              {
                LODWORD(v39) = 0;
                goto LABEL_123;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v39) = 0;
        }
LABEL_123:
        uint64_t v72 = 72;
        goto LABEL_128;
      case 0x11u:
        uint64_t v64 = objc_alloc_init(VCMediaNegotiationFaceTimeSettings);

        *(void *)(a1 + 64) = v64;
        if (PBReaderPlaceMark()
          && (VCMediaNegotiationFaceTimeSettingsReadFrom((uint64_t)v64, a2) & 1) != 0)
        {
LABEL_37:
          PBReaderRecallMark();
LABEL_129:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
        return 0;
      case 0x12u:
        char v65 = 0;
        unsigned int v66 = 0;
        uint64_t v39 = 0;
        *(unsigned char *)(a1 + 132) |= 2u;
        while (2)
        {
          uint64_t v67 = *v3;
          unint64_t v68 = *(void *)(a2 + v67);
          if (v68 == -1 || v68 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v69 = *(unsigned char *)(*(void *)(a2 + *v7) + v68);
            *(void *)(a2 + v67) = v68 + 1;
            v39 |= (unint64_t)(v69 & 0x7F) << v65;
            if (v69 < 0)
            {
              v65 += 7;
              BOOL v14 = v66++ >= 9;
              if (v14)
              {
                LODWORD(v39) = 0;
                goto LABEL_127;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v39) = 0;
        }
LABEL_127:
        uint64_t v72 = 16;
LABEL_128:
        *(_DWORD *)(a1 + v72) = v39;
        goto LABEL_129;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_129;
    }
  }
}

void OUTLINED_FUNCTION_2_5(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x2Eu);
}

void _VCRateControlAlgorithmTelephony_Configure(uint64_t a1, const void *a2, int a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  memcpy((void *)(a1 + 40), a2, 0x3F0uLL);
  ++*(_DWORD *)(a1 + 1116);
  if (a3)
  {
    *(_DWORD *)(a1 + 1072) = 1;
    *(_DWORD *)(a1 + 1084) = *(_DWORD *)(a1 + 56);
  }
  int v5 = *(_DWORD *)(a1 + 1084);
  if (v5 >= *(_DWORD *)(a1 + 60)) {
    int v5 = *(_DWORD *)(a1 + 60);
  }
  if (v5 <= *(_DWORD *)(a1 + 64)) {
    int v5 = *(_DWORD *)(a1 + 64);
  }
  *(_DWORD *)(a1 + 1084) = v5;
  *(_DWORD *)(a1 + 1104) = *(_DWORD *)(*(void *)(a1 + 48) + 4 * *(int *)(a1 + 1084));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v12 = VRTraceErrorLogLevelToCSTR();
    char v13 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v14 = *(_DWORD *)(a1 + 1104);
      uint64_t v15 = *(void *)(a1 + 48);
      int v16 = *(_DWORD *)(v15 + 4 * *(int *)(a1 + 64));
      int v17 = *(_DWORD *)(v15 + 4 * *(int *)(a1 + 60));
      *(_DWORD *)buf = 136316418;
      uint64_t v19 = v12;
      __int16 v20 = 2080;
      unint64_t v21 = "_VCRateControlAlgorithmTelephony_Configure";
      __int16 v22 = 1024;
      int v23 = 82;
      __int16 v24 = 1024;
      int v25 = v14;
      __int16 v26 = 1024;
      int v27 = v16;
      __int16 v28 = 1024;
      int v29 = v17;
      _os_log_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Configuring VCRateControl algorithm with targetBitrate=%d, minBitrate=%d, maxBitrate=%d", buf, 0x2Eu);
    }
  }
  VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Configure with targetBitrate=%d, minBitrate=%d, maxBitrate=%d", v6, v7, v8, v9, v10, v11, *(_DWORD *)(a1 + 1104));
}

BOOL _VCRateControlAlgorithmTelephony_DoRateControl(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a2 != 12)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      _VCRateControlAlgorithmTelephony_DoRateControl_cold_3();
    }
    return 0;
  }
  if (*(unsigned char *)(a2 + 26) != 2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      _VCRateControlAlgorithmTelephony_DoRateControl_cold_2();
    }
    return 0;
  }
  *(_WORD *)(a1 + 5218) = *(_WORD *)(a2 + 98);
  *(unsigned char *)(a1 + 5220) = *(unsigned char *)(a2 + 103);
  *(_DWORD *)(a1 + 5228) = *(void *)(a2 + 72);
  *(_DWORD *)(a1 + 5224) = *(_DWORD *)(a2 + 64);
  *(void *)(a1 + 1128) = *(void *)(a2 + 8);
  unsigned int v9 = *(unsigned __int8 *)(a1 + 5220);
  if (*(_DWORD *)(a1 + 796) > v9)
  {
    *(void *)(a1 + 5232) = *(void *)(a1 + 1128);
    unsigned int v9 = *(unsigned __int8 *)(a1 + 5220);
  }
  if (*(_DWORD *)(a1 + 792) < v9) {
    *(void *)(a1 + 5240) = *(void *)(a1 + 1128);
  }
  switch(*(_DWORD *)(a1 + 1072))
  {
    case 0:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v10 = VRTraceErrorLogLevelToCSTR();
        uint64_t v11 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          uint64_t v35 = v10;
          __int16 v36 = 2080;
          char v37 = "_VCRateControlAlgorithmTelephony_RunRateControlStateTransition";
          __int16 v38 = 1024;
          int v39 = 166;
          _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d VCRateControl is paused", buf, 0x1Cu);
        }
      }
      goto LABEL_39;
    case 1:
      if (*(__int16 *)(a1 + 5218) <= -95) {
        *(_DWORD *)(a1 + 1084) = *(_DWORD *)(a1 + 64);
      }
      int v13 = 3;
      goto LABEL_33;
    case 2:
      double v14 = *(double *)(a1 + 1128);
      if (v14 - *(double *)(a1 + 5232) > *(double *)(a1 + 808))
      {
        *(_DWORD *)(a1 + 1080) |= 1u;
        ++*(_DWORD *)(a1 + 1116);
        int v15 = *(_DWORD *)(a1 + 64);
        if (v15 <= *(_DWORD *)(a1 + 1084) - 1) {
          int v15 = *(_DWORD *)(a1 + 1084) - 1;
        }
LABEL_37:
        *(_DWORD *)(a1 + 1084) = v15;
        goto LABEL_39;
      }
      if (v14 - *(double *)(a1 + 5240) >= *(double *)(a1 + 800))
      {
        ++*(_DWORD *)(a1 + 1116);
        int v18 = *(_DWORD *)(a1 + 1084);
        int v15 = *(_DWORD *)(a1 + 60);
        if (v15 >= v18 + 1) {
          int v15 = v18 + 1;
        }
        goto LABEL_37;
      }
      *(_DWORD *)(a1 + 1076) |= 2u;
LABEL_39:
      *(_DWORD *)(a1 + 1104) = *(_DWORD *)(*(void *)(a1 + 48) + 4 * *(int *)(a1 + 1084));
      if (*(unsigned char *)(a1 + 5160))
      {
        int v19 = *(_DWORD *)(a1 + 1120);
        *(_DWORD *)(a1 + 1120) = v19 + 1;
        if ((v19 & 0xF) == 0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v20 = VRTraceErrorLogLevelToCSTR();
          unint64_t v21 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v23 = *(void *)(a1 + 1128);
            int v24 = *(_DWORD *)(a1 + 1076);
            if (v24) {
              int v25 = 88;
            }
            else {
              int v25 = 79;
            }
            LOBYTE(v22) = *(unsigned char *)(a1 + 5220);
            double v26 = (double)*(__int16 *)(a1 + 5218);
            unsigned int v27 = *(_DWORD *)(a1 + 1104) / 0x3E8u;
            int v28 = *(unsigned __int16 *)(a1 + 1080);
            int v29 = *(_DWORD *)(a1 + 1116);
            unsigned int v30 = *(_DWORD *)(a1 + 5228) / 0x3E8u;
            int v31 = 1000 * *(_DWORD *)(a1 + 5224);
            int v32 = *(_DWORD *)(a1 + 1072);
            *(_DWORD *)buf = 136321538;
            uint64_t v35 = v20;
            __int16 v36 = 2080;
            char v37 = "_VCRateControlAlgorithmTelephony_PrintRateControlInfoToLogDump";
            __int16 v38 = 1024;
            int v39 = 230;
            __int16 v40 = 2048;
            uint64_t v41 = v23;
            __int16 v42 = 1024;
            int v43 = 0;
            __int16 v44 = 2048;
            uint64_t v45 = 0;
            __int16 v46 = 2048;
            uint64_t v47 = 0;
            __int16 v48 = 2048;
            uint64_t v49 = 0;
            __int16 v50 = 2048;
            uint64_t v51 = 0;
            __int16 v52 = 1024;
            int v53 = v25;
            __int16 v54 = 1024;
            int v55 = 0;
            __int16 v56 = 2048;
            double v57 = (double)v22;
            __int16 v58 = 2048;
            double v59 = v26;
            __int16 v60 = 1024;
            int v61 = 0;
            __int16 v62 = 1024;
            int v63 = 0;
            __int16 v64 = 1024;
            int v65 = 0;
            __int16 v66 = 1024;
            unsigned int v67 = v27;
            __int16 v68 = 1024;
            int v69 = (unsigned __int16)v24;
            __int16 v70 = 1024;
            int v71 = v28;
            __int16 v72 = 1024;
            int v73 = v29;
            __int16 v74 = 1024;
            unsigned int v75 = v30;
            __int16 v76 = 1024;
            int v77 = 0;
            __int16 v78 = 1024;
            int v79 = v31;
            __int16 v80 = 1024;
            int v81 = 0;
            __int16 v82 = 1024;
            int v83 = 0;
            __int16 v84 = 1024;
            int v85 = v32;
            _os_log_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d %8.3f/%04X:\t%.4f\t%.4f\t%.4f\t%.4f %c\tRTT:%-4u\tPLR:%4.2f@%.1f\tRRx:%4u\tMBL:%d\t%4u/%4u\t  CS:%04X %04X %u BB: %3u\t%4u\t%3u\t%u\t%u\t UAT \t%d", buf, 0xC2u);
          }
        }
      }
      uint64_t v33 = *(void *)(a1 + 5144);
      if (v33) {
        VRLogfilePrintWithTimestamp(v33, "%8.3f/%04X:\t%.4f\t%.4f\t%.4f\t%.4f %c\tRTT:%-4u\tPLR:%4.2f@%.1f\tRRx:%u\tMBL:%d %u\t%4u/%4u\t %4u:%4u/%4u  %4u:%4u/%4u  CS: %04X %04X %u BB: %3u\t%4u\t%3u\t%u\t%u\t UAT \t%d\n", a3, a4, a5, a6, a7, a8, *(void *)(a1 + 1128));
      }
      *(_DWORD *)(a1 + 1076) = 0;
      *(_DWORD *)(a1 + 1080) = 0;
      BOOL result = 1;
      break;
    case 3:
      *(_DWORD *)(a1 + 1076) |= 1u;
      double v16 = *(double *)(a1 + 1128);
      if (v16 - *(double *)(a1 + 5232) > *(double *)(a1 + 808))
      {
        *(_DWORD *)(a1 + 1080) |= 1u;
        ++*(_DWORD *)(a1 + 1116);
        int v17 = *(_DWORD *)(a1 + 64);
        if (v17 <= *(_DWORD *)(a1 + 1084) - 1) {
          int v17 = *(_DWORD *)(a1 + 1084) - 1;
        }
        *(_DWORD *)(a1 + 1084) = v17;
        double v16 = *(double *)(a1 + 1128);
      }
      if (v16 - *(double *)(a1 + 1136) > *(double *)(a1 + 184))
      {
        int v13 = 2;
LABEL_33:
        VCRateControlAlgorithmBasePriv_StateChange(a1, v13);
      }
      goto LABEL_39;
    default:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCRateControlAlgorithmTelephony_DoRateControl_cold_1();
        }
      }
      goto LABEL_39;
  }
  return result;
}

BOOL VCVideoTransmitterDefault_EnqueueVideoFrame(BOOL result, CMSampleBufferRef sbuf, CMTime *a3, unsigned int a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    uint64_t v4 = result;
    if (*(void *)(result + 160) == 0xFFFFFFFFLL)
    {
      return 0;
    }
    else
    {
      unsigned int v14 = 0;
      Float64 v13 = 0.0;
      uint64_t v8 = *(unsigned int *)(result + 100);
      if (v8)
      {
        unsigned int v9 = (double *)(result + 104);
      }
      else
      {
        unsigned int v9 = &v13;
        VCVideoTransmitterDefault_ComputeTimestamp(result, &v14, &v13, sbuf);
        uint64_t v8 = v14;
      }
      double v10 = *v9;
      CMTime v12 = *a3;
      *(Float64 *)(v4 + 248) = CMTimeGetSeconds(&v12);
      uint64_t v11 = *(void *)(v4 + 160);
      CMTime v12 = *a3;
      return (int)VideoTransmitter_EnqueueBuffer(v11, sbuf, v8, (long long *)&v12.value, 0, a4, v10) >= 0;
    }
  }
  return result;
}

uint64_t VCVideoTransmitterDefault_SetFECRatio(double a1)
{
  return VideoTransmitter_SetFECRatio(a1);
}

uint64_t VCVideoTransmitterDefault_SetMediaQueueSize(uint64_t a1, unsigned int a2)
{
  return VideoTransmitter_SetMediaQueueSize(*(void *)(a1 + 160), a2);
}

void VCVideoTransmitterDefault_ComputeTimestamp(uint64_t a1, _DWORD *a2, Float64 *a3, CMSampleBufferRef sbuf)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  memset(&v16, 170, sizeof(v16));
  CMSampleBufferGetPresentationTimeStamp(&v16, sbuf);
  CMTimeValue value = *(void *)(a1 + 64);
  if (value)
  {
    CMTime lhs = v16;
    CMTime v13 = *(CMTime *)(a1 + 64);
    CMTimeSubtract(&v15, &lhs, &v13);
    CMTimeValue value = v15.value;
    uint64_t v8 = *(void *)&v15.timescale;
    CMTimeEpoch epoch = v15.epoch;
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 72);
    CMTimeEpoch epoch = *(void *)(a1 + 80);
  }
  lhs.CMTimeEpoch epoch = epoch;
  memset(&v15, 170, sizeof(v15));
  int32_t v10 = *(_DWORD *)(a1 + 168);
  lhs.CMTimeValue value = value;
  *(void *)&lhs.timescale = v8;
  CMTimeConvertScale(&v15, &lhs, v10, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
  *(_DWORD *)(a1 + 96) += LODWORD(v15.value);
  long long v11 = *(_OWORD *)&v16.value;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)&v16.value;
  CMTimeEpoch v12 = v16.epoch;
  *(void *)(a1 + 80) = v16.epoch;
  *(_OWORD *)&lhs.CMTimeValue value = v11;
  lhs.CMTimeEpoch epoch = v12;
  *a3 = CMTimeGetSeconds(&lhs);
  *a2 = *(_DWORD *)(a1 + 96);
}

uint64_t VCVideoReceiverFeedbackDelegate_sendLTRAck(uint64_t result, int a2)
{
  if (result) {
    return VideoTransmitter_SendLTRACK(*(void *)(result + 160), a2);
  }
  return result;
}

uint64_t VCVideoReceiverFeedbackDelegate_ackLTRFrame(uint64_t result, int a2)
{
  if (result) {
    return VideoTransmitter_ACKLTRFrame(*(void *)(result + 160), a2);
  }
  return result;
}

uint64_t VCCMSessionStub_AudioSessionCreateCMSession()
{
  return _cmSessionStub();
}

uint64_t VCCMSessionStub_AudioSessionDestroyCMSession()
{
  return off_1EB5E63D0();
}

uint64_t VCCMSessionStub_CMSessionCopyProperty()
{
  return off_1EB5E63D8();
}

uint64_t VCCMSessionStub_CMSessionSetProperty()
{
  return off_1EB5E63E0();
}

uint64_t VCCMSessionStub_CMSessionBeginInterruption()
{
  return off_1EB5E63E8();
}

uint64_t VCCMSessionStub_CMSessionEndInterruption()
{
  return off_1EB5E63F0();
}

uint64_t VCCMSessionStub_CMSessionNotificationBarrier()
{
  return off_1EB5E63F8();
}

uint64_t VCBlockBufferUtlities_Create(const __CFAllocator *a1, void *a2, size_t a3, const __CFAllocator *a4, const CMBlockBufferCustomBlockSource *a5, size_t a6, size_t a7, CMBlockBufferFlags a8, CMBlockBufferRef *blockBufferOut)
{
  if (FigMemoryPoolIsPoolAllocator())
  {
    if (FigMemoryPoolAllocatorCopyMemoryPool())
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCBlockBufferUtlities_Create_cold_3();
        }
      }
    }
    else if (FigMemoryPoolCreateBlockBuffer())
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCBlockBufferUtlities_Create_cold_2();
        }
      }
    }
    return 0;
  }
  else
  {
    uint64_t v17 = CMBlockBufferCreateWithMemoryBlock(a1, a2, a3, a4, a5, a6, a7, a8, blockBufferOut);
    if (v17)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCBlockBufferUtlities_Create_cold_1();
        }
      }
    }
  }
  return v17;
}

char *VCBlockBufferUtilities_CreateAndGetDataPointer(const __CFAllocator *a1, void *a2, size_t a3, const __CFAllocator *a4, const CMBlockBufferCustomBlockSource *a5, size_t a6, size_t a7, CMBlockBufferFlags a8, CMBlockBufferRef *a9)
{
  dataPointerOut[1] = *(char **)MEMORY[0x1E4F143B8];
  dataPointerOut[0] = 0;
  if (VCBlockBufferUtlities_Create(a1, a2, a3, a4, a5, a6, a7, a8, a9))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCBlockBufferUtilities_CreateAndGetDataPointer_cold_2();
      }
    }
  }
  else if (CMBlockBufferGetDataPointer(*a9, 0, 0, 0, dataPointerOut))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCBlockBufferUtilities_CreateAndGetDataPointer_cold_1();
      }
    }
  }
  return dataPointerOut[0];
}

uint64_t symptomReporterCallback_0(void *a1, CFDictionaryRef theDict)
{
  v9[1] = *MEMORY[0x1E4F143B8];
  CFDataRef Value = CFDictionaryGetValue(theDict, @"SymptomReporterCallbackKeySymptomID");
  int v5 = CFDictionaryGetValue(theDict, @"SymptomReporterCallbackKeyGroupID");
  uint64_t v6 = CFDictionaryGetValue(theDict, @"SymptomReporterOptionalKeyParticipantID");
  if (v6)
  {
    v9[0] = v6;
    uint64_t v7 = [MEMORY[0x1E4F1C978] arrayWithObjects:v9 count:1];
  }
  else
  {
    uint64_t v7 = 0;
  }
  return [a1 sendSymptomsToRemoteParticipants:v7 symptom:Value groupID:v5];
}

void _VCSession_ReportingConfigurationCallback(uint64_t a1, char a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a2)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      uint64_t v4 = VRTraceErrorLogLevelToCSTR();
      int v5 = *MEMORY[0x1E4F47A50];
      uint64_t v6 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          int v9 = 136315650;
          uint64_t v10 = v4;
          __int16 v11 = 2080;
          CMTimeEpoch v12 = "_VCSession_ReportingConfigurationCallback";
          __int16 v13 = 1024;
          int v14 = 718;
          _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, "VCSession [%s] %s:%d Reporting is enabled", (uint8_t *)&v9, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        _VCSession_ReportingConfigurationCallback_cold_1();
      }
    }
  }
  else
  {
    if (ErrorLogLevelForModule >= 7)
    {
      uint64_t v7 = VRTraceErrorLogLevelToCSTR();
      uint64_t v8 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v9 = 136315650;
        uint64_t v10 = v7;
        __int16 v11 = 2080;
        CMTimeEpoch v12 = "_VCSession_ReportingConfigurationCallback";
        __int16 v13 = 1024;
        int v14 = 714;
        _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, "VCSession [%s] %s:%d Reporting is disabled.", (uint8_t *)&v9, 0x1Cu);
      }
    }
    reportingSetNWActivityReportingEnabled();
    VCReporting_DisableDataCollection();
  }
}

void VCSession_RemoteScreenAttributesDidChange(uint64_t a1, uint64_t a2)
{
  block[6] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = *(NSObject **)(a1 + 176);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __VCSession_RemoteScreenAttributesDidChange_block_invoke;
    block[3] = &unk_1E6DB3E40;
    block[4] = a2;
    block[5] = a1;
    dispatch_async(v2, block);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCSession_RemoteScreenAttributesDidChange_cold_1();
    }
  }
}

void sub_1E21D1478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t VCAudioRelayIOController_PullAudioSamples(void *a1, uint64_t a2)
{
  v13[2] = *MEMORY[0x1E4F143B8];
  _VCAudioRelayIOController_ProcessEventQueue((uint64_t)a1);
  VCAudioBufferList_ZeroMemory(a2);
  v13[0] = 0xAAAAAAAAAAAAAAAALL;
  v13[1] = 0xAAAAAAAAAAAAAAAALL;
  VCAudioIOControllerIOState_GetControllerTimestamp(a2, (uint64_t)a1, (uint64_t)v13);
  uint64_t v4 = a1[11];
  SampleCFIndex Count = VCAudioBufferList_GetSampleCount(a2);
  VCAudioBufferList_SetSampleCount(v4, SampleCount);
  uint64_t v6 = a1[11];
  double HostTime = VCAudioBufferList_GetHostTime(a2);
  int Timestamp = VCAudioBufferList_GetTimestamp(a2);
  VCAudioBufferList_SetTime(v6, Timestamp, HostTime);
  int v9 = (void *)a1[5];
  if (v9)
  {
    uint64_t v10 = a2;
    do
    {
      uint64_t v11 = v9[1];
      VCAudioBufferList_InvalidateNetworkTimestamp(v10);
      (*(void (**)(void, void *, uint64_t))(v11 + 8))(*(void *)v11, v13, v10);
      if (v10 != a2) {
        VCAudioBufferList_Mix(a2, v10);
      }
      uint64_t v10 = a1[11];
      int v9 = (void *)*v9;
    }
    while (v9);
  }
  return VCAudioLimiter_Process(a1[10], a2);
}

void _VCAudioRelayIOController_ProcessEventQueue(uint64_t a1)
{
  double v2 = 0.0;
  if (VRTraceIsInternalOSInstalled()) {
    double v2 = micro();
  }
  uint64_t v3 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 72));
  if (v3)
  {
    uint64_t v4 = v3;
    int v11 = 0;
    do
    {
      int v12 = *((_DWORD *)v4 + 4);
      if (v12 == 1)
      {
        _VCAudioRelayIOController_UnregisterClientIO(a1, v4);
      }
      else if (!v12)
      {
        _VCAudioRelayIOController_RegisterClientIO(a1, v4);
      }
      uint64_t v4 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 72));
      ++v11;
    }
    while (v4);
  }
  LogProfileTimeOverLimit(v2, 0, (uint64_t)v4, v5, v6, v7, v8, v9, v10, (char)"_VCAudioRelayIOController_ProcessEventQueue");
}

void VCAudioRelayIOController_PushAudioSamples(uint64_t a1, uint64_t a2)
{
  v5[2] = *MEMORY[0x1E4F143B8];
  _VCAudioRelayIOController_ProcessEventQueue(a1);
  v5[0] = 0xAAAAAAAAAAAAAAAALL;
  v5[1] = 0xAAAAAAAAAAAAAAAALL;
  VCAudioIOControllerIOState_GetControllerTimestamp(a2, a1, (uint64_t)v5);
  for (uint64_t i = *(void **)(a1 + 40); i; uint64_t i = (void *)*i)
    (*(void (**)(void, void *, uint64_t))(i[1] + 8))(*(void *)i[1], v5, a2);
}

uint64_t VCAudioRelayIOController_UpdateRemoteCodecInfo(void *a1, const char *a2)
{
  return [a1 didUpdateBasebandCodec:a2];
}

void sub_1E21D20C0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t _VCAudioRelayIOController_CompareControllerEntries(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = *(void *)(a2 + 8);
  BOOL v4 = v2 == v3;
  unsigned int v5 = 2 * (v2 >= v3);
  if (v4) {
    return 1;
  }
  else {
    return v5;
  }
}

void sub_1E21D2654(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void _VCAudioRelayIOController_RegisterClientIO(uint64_t a1, void *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    unsigned int v5 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = a2[1];
      int v7 = 136315906;
      uint64_t v8 = v4;
      __int16 v9 = 2080;
      uint64_t v10 = "_VCAudioRelayIOController_RegisterClientIO";
      __int16 v11 = 1024;
      int v12 = 67;
      __int16 v13 = 2048;
      uint64_t v14 = v6;
      _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Registering clientIO[%p]", (uint8_t *)&v7, 0x26u);
    }
  }
  if ((VCSingleLinkedListPush(a1 + 40, a2) & 1) == 0) {
    free(a2);
  }
}

void _VCAudioRelayIOController_UnregisterClientIO(uint64_t a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    unsigned int v5 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = a2[1];
      int v8 = 136315906;
      uint64_t v9 = v4;
      __int16 v10 = 2080;
      __int16 v11 = "_VCAudioRelayIOController_UnregisterClientIO";
      __int16 v12 = 1024;
      int v13 = 57;
      __int16 v14 = 2048;
      uint64_t v15 = v6;
      _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unregistering clientIO[%p]", (uint8_t *)&v8, 0x26u);
    }
  }
  int v7 = VCSingleLinkedListRemove(a1 + 40, (uint64_t)a2);
  if (v7) {
    free(v7);
  }
  free(a2);
}

uint64_t VCNWConnectionMonitorUtils_GetRATFromNWNotification(uint64_t a1)
{
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCNWConnectionMonitorUtils_GetRATFromNWNotification_cold_1();
    }
    return 0;
  }
  if (*(_DWORD *)(a1 + 4) == 2) {
    return *(unsigned int *)(a1 + 8);
  }
  else {
    return *(unsigned __int8 *)(a1 + 60);
  }
}

uint64_t VCNWConnectionMonitorUtils_GetSignalLevelFromNWNotification(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 4) == 2) {
      return *(__int16 *)(a1 + 14);
    }
    else {
      return *(__int16 *)(a1 + 63);
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCNWConnectionMonitorUtils_GetSignalLevelFromNWNotification_cold_1();
      }
    }
    return 0;
  }
}

void VCNWConnectionMonitorUtils_GetCDRXCycleFromNWNotification(uint64_t a1, _WORD *a2, unsigned char *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a1 && a2 && a3)
  {
    if (*(_DWORD *)(a1 + 4) == 4)
    {
      *a2 = *(_WORD *)(a1 + 10);
      char v6 = *(unsigned char *)(a1 + 8);
    }
    else
    {
      *a2 = *(_WORD *)(a1 + 70);
      char v6 = *(unsigned char *)(a1 + 69);
    }
    *a3 = v6;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v7 = VRTraceErrorLogLevelToCSTR();
    int v8 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
    {
      int v9 = 136316418;
      uint64_t v10 = v7;
      __int16 v11 = 2080;
      __int16 v12 = "VCNWConnectionMonitorUtils_GetCDRXCycleFromNWNotification";
      __int16 v13 = 1024;
      int v14 = 38;
      __int16 v15 = 2048;
      uint64_t v16 = a1;
      __int16 v17 = 2048;
      int v18 = a2;
      __int16 v19 = 2048;
      uint64_t v20 = a3;
      _os_log_error_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid input parameters. notification=%p, cdrxCycle=%p, cdrxState=%p", (uint8_t *)&v9, 0x3Au);
    }
  }
}

void VCNWConnectionMonitorUtils_GetNotificationFromAdvisory(long long *a1, uint64_t a2)
{
  if (a2)
  {
    if (a1)
    {
      *(unsigned char *)(a2 + 1) = *((unsigned char *)a1 + 1);
      *(unsigned char *)a2 = *(unsigned char *)a1;
      *(unsigned char *)(a2 + 2) = *((unsigned char *)a1 + 2);
      if (*((unsigned char *)a1 + 2) == 1)
      {
LABEL_4:
        *(_DWORD *)(a2 + 4) = 0;
        long long v4 = *a1;
        *(_OWORD *)(a2 + 24) = a1[1];
        *(_OWORD *)(a2 + 8) = v4;
        long long v5 = a1[2];
        long long v6 = a1[3];
        long long v7 = a1[4];
        *(_OWORD *)(a2 + 88) = a1[5];
        *(_OWORD *)(a2 + 72) = v7;
        *(_OWORD *)(a2 + 56) = v6;
        *(_OWORD *)(a2 + 40) = v5;
      }
      else
      {
        switch(*((unsigned char *)a1 + 3))
        {
          case 0:
            goto LABEL_4;
          case 1:
            *(_DWORD *)(a2 + 4) = 1;
            *(void *)(a2 + 16) = *((void *)a1 + 1);
            *(_DWORD *)(a2 + 8) = *((unsigned __int8 *)a1 + 52);
            *(_DWORD *)(a2 + 32) = *((_DWORD *)a1 + 10);
            *(_DWORD *)(a2 + 36) = *((_DWORD *)a1 + 11);
            *(void *)(a2 + 24) = *((void *)a1 + 3);
            return;
          case 2:
            *(_DWORD *)(a2 + 4) = 2;
            *(_DWORD *)(a2 + 8) = *((unsigned __int8 *)a1 + 52);
            *(_WORD *)(a2 + 12) = *(_WORD *)((char *)a1 + 53);
            *(_WORD *)(a2 + 14) = *(_WORD *)((char *)a1 + 55);
            *(unsigned char *)(a2 + 16) = *((unsigned char *)a1 + 57);
            *(unsigned char *)(a2 + 18) = *((unsigned char *)a1 + 59);
            *(unsigned char *)(a2 + 17) = *((unsigned char *)a1 + 58);
            return;
          case 3:
            *(_DWORD *)(a2 + 4) = 3;
            char v8 = *((unsigned char *)a1 + 60);
            goto LABEL_14;
          case 4:
            *(_DWORD *)(a2 + 4) = 4;
            *(_WORD *)(a2 + 10) = *((_WORD *)a1 + 31);
            char v8 = *((unsigned char *)a1 + 61);
LABEL_14:
            *(unsigned char *)(a2 + 8) = v8;
            return;
          case 5:
            *(_DWORD *)(a2 + 4) = 5;
            *(_WORD *)(a2 + 12) = *((_WORD *)a1 + 32);
            *(unsigned char *)(a2 + 14) = *((unsigned char *)a1 + 66);
            unsigned int v9 = *((unsigned __int8 *)a1 + 52);
            goto LABEL_24;
          case 6:
            *(_DWORD *)(a2 + 4) = 6;
            int v10 = *((_DWORD *)a1 + 1);
            if (v10 == 0x7FFFFFFF) {
              int v11 = 0x7FFFFFFF;
            }
            else {
              int v11 = 0;
            }
            if (!v10) {
              int v11 = 0;
            }
            if (v10 == 0x80000000) {
              unsigned int v9 = 0x80000000;
            }
            else {
              unsigned int v9 = v11;
            }
LABEL_24:
            *(_DWORD *)(a2 + 8) = v9;
            break;
          default:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                VCNWConnectionMonitorUtils_GetNotificationFromAdvisory_cold_3();
              }
            }
            goto LABEL_4;
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCNWConnectionMonitorUtils_GetNotificationFromAdvisory_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCNWConnectionMonitorUtils_GetNotificationFromAdvisory_cold_1();
    }
  }
}

BOOL VCNWConnectionMonitorUtils_IsBasebandRAT5G(int a1)
{
  return (a1 - 7) < 3;
}

void _VCSystemAudioCaptureSession_audioSink(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    long long v5 = *MEMORY[0x1E4F47A50];
    long long v6 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v18 = 136315906;
        uint64_t v19 = v4;
        __int16 v20 = 2080;
        uint64_t v21 = "_VCSystemAudioCaptureSession_audioSink";
        __int16 v22 = 1024;
        int v23 = 171;
        __int16 v24 = 2048;
        uint64_t v25 = a1;
        _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %p audio sink buffer received", (uint8_t *)&v18, 0x26u);
      }
    }
    else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      _VCSystemAudioCaptureSession_audioSink_cold_1();
    }
  }
  int32_t Count = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 120));
  int32_t v8 = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 128));
  unsigned int v9 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 120));
  if (v9)
  {
    int v10 = v9;
    VCAudioBufferList_Reset((uint64_t)v9);
    Sampleint32_t Count = VCAudioBufferList_GetSampleCount(a2);
    double HostTime = VCAudioBufferList_GetHostTime(a2);
    int Timestamp = VCAudioBufferList_GetTimestamp(a2);
    VCAudioBufferList_SetSampleCount((uint64_t)v10, SampleCount);
    VCAudioBufferList_SetTime((uint64_t)v10, Timestamp, HostTime);
    VCAudioBufferList_ZeroMemory((uint64_t)v10);
    VCAudioBufferList_MixToMono((uint64_t)v10, a2);
    if (CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(a1 + 128), v10))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v14 = VRTraceErrorLogLevelToCSTR();
        __int16 v15 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          int v18 = 136316162;
          uint64_t v19 = v14;
          __int16 v20 = 2080;
          uint64_t v21 = "_VCSystemAudioCaptureSession_audioSink";
          __int16 v22 = 1024;
          int v23 = 188;
          __int16 v24 = 2048;
          uint64_t v25 = a1;
          __int16 v26 = 1024;
          int32_t v27 = v8;
          uint64_t v16 = " [%s] %s:%d %p output queue full with count %d";
LABEL_16:
          _os_log_error_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_ERROR, v16, (uint8_t *)&v18, 0x2Cu);
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v17 = VRTraceErrorLogLevelToCSTR();
    __int16 v15 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
    {
      int v18 = 136316162;
      uint64_t v19 = v17;
      __int16 v20 = 2080;
      uint64_t v21 = "_VCSystemAudioCaptureSession_audioSink";
      __int16 v22 = 1024;
      int v23 = 191;
      __int16 v24 = 2048;
      uint64_t v25 = a1;
      __int16 v26 = 1024;
      int32_t v27 = Count;
      uint64_t v16 = " [%s] %s:%d %p pool queue empty with count %d";
      goto LABEL_16;
    }
  }
}

const void *VCSystemAudioCaptureSession_pullAudioSamples(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 128));
  int32_t Count = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 120));
  int32_t v4 = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 128));
  if (v2)
  {
    if (CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(a1 + 120), v2))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v5 = VRTraceErrorLogLevelToCSTR();
        long long v6 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          int v12 = 136316162;
          uint64_t v13 = v5;
          __int16 v14 = 2080;
          __int16 v15 = "VCSystemAudioCaptureSession_pullAudioSamples";
          __int16 v16 = 1024;
          int v17 = 160;
          __int16 v18 = 2048;
          uint64_t v19 = a1;
          __int16 v20 = 1024;
          int32_t v21 = Count;
          _os_log_error_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d %p pool queue full with count %d", (uint8_t *)&v12, 0x2Cu);
        }
      }
    }
  }
  else
  {
    int32_t v7 = v4;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v8 = VRTraceErrorLogLevelToCSTR();
      unsigned int v9 = *MEMORY[0x1E4F47A50];
      int v10 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          int v12 = 136316162;
          uint64_t v13 = v8;
          __int16 v14 = 2080;
          __int16 v15 = "VCSystemAudioCaptureSession_pullAudioSamples";
          __int16 v16 = 1024;
          int v17 = 164;
          __int16 v18 = 2048;
          uint64_t v19 = a1;
          __int16 v20 = 1024;
          int32_t v21 = v7;
          _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %p output queue empty with count %d", (uint8_t *)&v12, 0x2Cu);
        }
      }
      else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        int v12 = 136316162;
        uint64_t v13 = v8;
        __int16 v14 = 2080;
        __int16 v15 = "VCSystemAudioCaptureSession_pullAudioSamples";
        __int16 v16 = 1024;
        int v17 = 164;
        __int16 v18 = 2048;
        uint64_t v19 = a1;
        __int16 v20 = 1024;
        int32_t v21 = v7;
        _os_log_debug_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEBUG, " [%s] %s:%d %p output queue empty with count %d", (uint8_t *)&v12, 0x2Cu);
      }
    }
  }
  return v2;
}

void VCAudioIOControllerIOState_GetControllerTimestamp(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  int Timestamp = VCAudioBufferList_GetTimestamp(a1);
  Sampleint32_t Count = VCAudioBufferList_GetSampleCount(a1);
  float v8 = *(double *)VCAudioBufferList_GetSampleFormat(a1);
  double HostTime = VCAudioBufferList_GetHostTime(a1);
  double v10 = HostTime;
  if (*(unsigned char *)a2)
  {
    double v11 = HostTime - *(double *)(a2 + 8);
    unsigned int v12 = *(_DWORD *)(a2 + 20);
    unsigned int v13 = v12 + *(_DWORD *)(a2 + 16);
    if (Timestamp == v13)
    {
      unsigned int v14 = v12 * llround(v11 * (float)(v8 / (float)v12));
      unint64_t v15 = *(void *)(a2 + 32);
      if (v14 == v12)
      {
        unint64_t v16 = (unint64_t)((double)v15 + *(double *)(a2 + 24) * 409600.0);
      }
      else
      {
        double v20 = *(double *)(a2 + 24);
        if (v11 >= v20) {
          double v20 = v10 - *(double *)(a2 + 8);
        }
        unint64_t v16 = v15 + (vcvtad_u64_f64(v20 * 409600.0) | 0x4119000000000000);
        VCAudioBufferList_SetHostTimeJumpSize(a1, v10 - *(double *)(a2 + 8));
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          uint64_t v21 = VRTraceErrorLogLevelToCSTR();
          uint64_t v22 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            int v23 = *(_DWORD *)(a2 + 16);
            uint64_t v24 = *(void *)(a2 + 8);
            uint64_t v25 = *(void *)(a2 + 32);
            int v29 = 136318210;
            uint64_t v30 = v21;
            __int16 v31 = 2080;
            int v32 = "VCAudioIOControllerIOState_GetControllerTimestamp";
            __int16 v33 = 1024;
            int v34 = 42;
            __int16 v35 = 2080;
            uint64_t v36 = a2 + 128;
            __int16 v37 = 1024;
            *(_DWORD *)__int16 v38 = Timestamp - v23;
            *(_WORD *)&v38[4] = 1024;
            *(_DWORD *)&v38[6] = v23;
            __int16 v39 = 1024;
            *(_DWORD *)__int16 v40 = Timestamp;
            *(_WORD *)&v40[4] = 2048;
            *(double *)&v40[6] = v11;
            *(_WORD *)&v40[14] = 1024;
            *(_DWORD *)&v40[16] = v14;
            *(_WORD *)uint64_t v41 = 2048;
            *(void *)&v41[2] = v24;
            __int16 v42 = 2048;
            double v43 = v10;
            __int16 v44 = 2048;
            uint64_t v45 = v25;
            __int16 v46 = 2048;
            unint64_t v47 = v16;
            _os_log_impl(&dword_1E1EA4000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %s Real time miss. Timestamp jumped: delta=%u (%u to %u), host time: delta=%f (sampleCount=%d) (%f to %f). lastTimestamp=%llu -> timestamp=%llu", (uint8_t *)&v29, 0x70u);
          }
        }
      }
    }
    else
    {
      if (v11 >= *(double *)(a2 + 24))
      {
        double v19 = v11 * 409600.0;
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          uint64_t v17 = VRTraceErrorLogLevelToCSTR();
          __int16 v18 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
          {
            int v29 = 136316162;
            uint64_t v30 = v17;
            __int16 v31 = 2080;
            int v32 = "VCAudioIOControllerIOState_GetControllerTimestamp";
            __int16 v33 = 1024;
            int v34 = 31;
            __int16 v35 = 2080;
            uint64_t v36 = a2 + 128;
            __int16 v37 = 2048;
            *(double *)__int16 v38 = v11;
            _os_log_error_impl(&dword_1E1EA4000, v18, OS_LOG_TYPE_ERROR, " [%s] %s:%d %s Audio callback called too quickly. Delta:%f", (uint8_t *)&v29, 0x30u);
          }
        }
        double v19 = *(double *)(a2 + 24) * 409600.0;
      }
      unint64_t v16 = *(void *)(a2 + 32) + round(v19);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v26 = VRTraceErrorLogLevelToCSTR();
        int32_t v27 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          uint64_t v28 = *(void *)(a2 + 32);
          int v29 = 136317186;
          uint64_t v30 = v26;
          __int16 v31 = 2080;
          int v32 = "VCAudioIOControllerIOState_GetControllerTimestamp";
          __int16 v33 = 1024;
          int v34 = 36;
          __int16 v35 = 2080;
          uint64_t v36 = a2 + 128;
          __int16 v37 = 1024;
          *(_DWORD *)__int16 v38 = Timestamp;
          *(_WORD *)&v38[4] = 1024;
          *(_DWORD *)&v38[6] = v13;
          __int16 v39 = 2048;
          *(double *)__int16 v40 = v11;
          *(_WORD *)&v40[8] = 2048;
          *(void *)&v40[10] = v28;
          *(_WORD *)&v40[18] = 2048;
          *(void *)uint64_t v41 = v16;
          _os_log_error_impl(&dword_1E1EA4000, v27, OS_LOG_TYPE_ERROR, " [%s] %s:%d %s Unexpected timestamp received: %u, expected:%u hostTimeDelta=%f lastTimestamp=%llu -> timestamp=%llu", (uint8_t *)&v29, 0x50u);
        }
      }
    }
  }
  else
  {
    unint64_t v16 = 0;
  }
  *(_DWORD *)(a2 + 16) = Timestamp;
  *(_DWORD *)(a2 + 20) = SampleCount;
  *(double *)(a2 + 24) = (double)SampleCount / v8;
  *(double *)(a2 + 8) = v10;
  *(void *)(a2 + 32) = v16;
  *(unsigned char *)a2 = 1;
  if (a3)
  {
    *(void *)(a3 + 8) = v16;
    *(_DWORD *)a3 = 409600;
  }
}

unsigned char *VCAudioIOControllerIOState_ResetControllerTime(unsigned char *result)
{
  if (result) {
    *uint64_t result = 0;
  }
  return result;
}

uint64_t VCCCMessageAcknowledgmentReadFrom(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  int32_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    int32_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        char v23 = 0;
        unsigned int v24 = 0;
        uint64_t v25 = 0;
        *(unsigned char *)(a1 + 20) |= 1u;
        while (1)
        {
          uint64_t v26 = *v3;
          unint64_t v27 = *(void *)(a2 + v26);
          if (v27 == -1 || v27 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v28 = *(unsigned char *)(*(void *)(a2 + *v7) + v27);
          *(void *)(a2 + v26) = v27 + 1;
          v25 |= (unint64_t)(v28 & 0x7F) << v23;
          if ((v28 & 0x80) == 0) {
            goto LABEL_41;
          }
          v23 += 7;
          BOOL v14 = v24++ >= 9;
          if (v14)
          {
            LODWORD(v25) = 0;
            goto LABEL_43;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_41:
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v25) = 0;
        }
LABEL_43:
        *(_DWORD *)(a1 + 16) = v25;
      }
      else if ((v10 >> 3) == 1)
      {
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0;
        while (1)
        {
          uint64_t v20 = *v3;
          unint64_t v21 = *(void *)(a2 + v20);
          if (v21 == -1 || v21 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v22 = *(unsigned char *)(*(void *)(a2 + *v7) + v21);
          *(void *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0) {
            goto LABEL_37;
          }
          v17 += 7;
          BOOL v14 = v18++ >= 9;
          if (v14)
          {
            uint64_t v19 = 0;
            goto LABEL_39;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_37:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v19 = 0;
        }
LABEL_39:
        *(void *)(a1 + 8) = v19;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t _VCConnectionIDS_SourceDestinationInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  unsigned __int8 v4 = [*(id *)(a1 + 272) linkID];
  int IsRelay = VCConnection_IsRelay(a1);
  VCSDInfoConstructWithDatagramChannel(*(void *)(a1 + 288), v4, 0, IsRelay, (uint64_t)v10);
  long long v6 = v10[5];
  *(_OWORD *)(a2 + 64) = v10[4];
  *(_OWORD *)(a2 + 80) = v6;
  *(_OWORD *)(a2 + 96) = v10[6];
  *(void *)(a2 + 112) = v11;
  long long v7 = v10[1];
  *(_OWORD *)a2 = v10[0];
  *(_OWORD *)(a2 + 16) = v7;
  long long v8 = v10[3];
  *(_OWORD *)(a2 + 32) = v10[2];
  *(_OWORD *)(a2 + 48) = v8;
  uint64_t result = VCConnection_IsLocalOnCellular(a1);
  *(unsigned char *)(a2 + 22) = result;
  return result;
}

BOOL _VCConnectionIDS_IsLocalOnCellular(uint64_t a1)
{
  int v1 = [*(id *)(a1 + 272) RATType];
  if (v1) {
    BOOL v2 = v1 == 9;
  }
  else {
    BOOL v2 = 1;
  }
  return !v2;
}

BOOL _VCConnectionIDS_IsRemoteOnCellular(uint64_t a1)
{
  int v1 = [*(id *)(a1 + 272) remoteRATType];
  if (v1) {
    BOOL v2 = v1 == 9;
  }
  else {
    BOOL v2 = 1;
  }
  return !v2;
}

BOOL _VCConnectionIDS_IsIPv6(uint64_t a1)
{
  return [*(id *)(a1 + 272) networkType] == 2
      || [*(id *)(a1 + 272) remoteNetworkType] == 2;
}

BOOL _VCConnectionIDS_IsRelay(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 272) connectionType];
  unint64_t v3 = [*(id *)(a1 + 272) remoteConnectionType] - 2;
  return (unint64_t)(v2 - 2) < 4 || v3 < 4;
}

BOOL _VCConnectionIDS_MatchesSourceDestinationInfo(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 280);
  return v4 == VCDatagramChannelIDS_Token(*(void *)(a2 + 112))
      && *(unsigned __int8 *)(a2 + 12) == [*(id *)(a1 + 272) linkID];
}

BOOL _VCConnectionIDS_Equal(uint64_t a1, uint64_t a2)
{
  int v3 = [*(id *)(a1 + 272) linkID];
  return v3 == [*(id *)(a2 + 272) linkID];
}

uint64_t _VCConnectionIDS_LocalCellTech(uint64_t a1)
{
  return *(unsigned int *)(a1 + 300);
}

uint64_t _VCConnectionIDS_SetLocalCellTech(uint64_t a1, int a2)
{
  uint64_t result = VCConnection_IsLocalOnCellular(a1);
  if (result) {
    *(_DWORD *)(a1 + 300) = a2;
  }
  return result;
}

uint64_t _VCConnectionIDS_RemoteCellTech(uint64_t a1)
{
  return *(unsigned int *)(a1 + 304);
}

uint64_t _VCConnectionIDS_SetRemoteCellTech(uint64_t a1, int a2)
{
  uint64_t result = VCConnection_IsRemoteOnCellular(a1);
  if (result) {
    *(_DWORD *)(a1 + 304) = a2;
  }
  return result;
}

CFStringRef _VCConnectionIDS_CopyDescription(uint64_t a1)
{
  if (VCConnection_IsLocalOnCellular(a1))
  {
    uint64_t v2 = "Cell";
  }
  else if (VCConnection_IsLocalOnWiFi(a1))
  {
    uint64_t v2 = "WiFi";
  }
  else
  {
    uint64_t v2 = "Wired";
  }
  uint64_t v36 = v2;
  if (VCConnection_IsRemoteOnCellular(a1))
  {
    int v3 = "Cell";
  }
  else if (VCConnection_IsRemoteOnWiFi(a1))
  {
    int v3 = "WiFi";
  }
  else
  {
    int v3 = "Wired";
  }
  int v34 = v3;
  CFAllocatorRef v35 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  ClassName = object_getClassName((id)a1);
  uint64_t v32 = *(unsigned int *)(a1 + 280);
  int v31 = [*(id *)(a1 + 272) linkID];
  int IsRelay = VCConnection_IsRelay(a1);
  uint64_t v5 = "P2P";
  if (IsRelay) {
    uint64_t v5 = "Relay";
  }
  uint64_t v30 = v5;
  IsIPlong long v6 = VCConnection_IsIPv6(a1);
  long long v7 = "IPv4";
  if (IsIPv6) {
    long long v7 = "IPv6";
  }
  int v29 = v7;
  uint64_t v28 = *(unsigned int *)(a1 + 28);
  uint64_t v27 = *(unsigned int *)(a1 + 316);
  uint64_t v26 = *(unsigned int *)(a1 + 320);
  uint64_t v25 = *(unsigned int *)(a1 + 324);
  uint64_t v24 = *(unsigned int *)(a1 + 328);
  unsigned int IsLocalConstrained = VCConnection_IsLocalConstrained(a1);
  unsigned int IsRemoteConstrained = VCConnection_IsRemoteConstrained(a1);
  unsigned int IsLocalExpensive = VCConnection_IsLocalExpensive(a1);
  unsigned int IsRemoteExpensive = VCConnection_IsRemoteExpensive(a1);
  uint64_t v8 = *(unsigned __int8 *)(a1 + 332);
  uint64_t v9 = *(unsigned __int8 *)(a1 + 333);
  uint64_t v10 = *(unsigned __int8 *)(a1 + 334);
  uint64_t v11 = VCConnection_ReportingIPVersion(a1);
  uint64_t v12 = *(unsigned __int8 *)(a1 + 335);
  uint64_t v13 = *(void *)(a1 + 336);
  uint64_t v14 = *(void *)(a1 + 344);
  uint64_t v15 = [*(id *)(a1 + 272) connectionType];
  unint64_t v16 = [*(id *)(a1 + 272) remoteConnectionType] - 2;
  BOOL v18 = (unint64_t)(v15 - 2) < 4 || v16 < 4;
  return CFStringCreateWithFormat(v35, 0, @"<%s:%p> Token (%d) Link (%d): %s <-> %s (%s, %s), priority %d, uplink bitrate cap (%u), downlink bitrate cap (%u), uplink audio only bitrate cap = (%u), uplink OneToOne bitrate cap = (%u), isLocalConstrained (%d), isRemoteConstrained (%d), isLocalExpensive (%d) isRemoteExpensive (%d) isLocalDelegated (%d) isRemoteDelegated (%d) isVirtualRelayLink (%d) reportingIPVersion(%d) TransportLayerEncryption=%d relayProtocolStackDescrption(%@) channelDataBaseProtocolStackDescription(%@) _isHopByHopEncryptionSupported=%d", ClassName, a1, v32, v31, v36, v34, v30, v29, v28, v27, v26, v25, v24, IsLocalConstrained, IsRemoteConstrained, IsLocalExpensive,
           IsRemoteExpensive,
           v8,
           v9,
           v10,
           v11,
           v12,
           v13,
           v14,
           v18);
}

BOOL _VCConnectionIDS_IsLocalOnWiFiOrWired(uint64_t a1)
{
  int v1 = [*(id *)(a1 + 272) RATType];
  return !v1 || v1 == 9;
}

BOOL _VCConnectionIDS_IsRemoteOnWiFiOrWired(uint64_t a1)
{
  int v1 = [*(id *)(a1 + 272) remoteRATType];
  return !v1 || v1 == 9;
}

BOOL _VCConnectionIDS_IsLocalOnWiFi(uint64_t a1)
{
  return [*(id *)(a1 + 272) RATType] == 0;
}

BOOL _VCConnectionIDS_IsRemoteOnWiFi(uint64_t a1)
{
  return [*(id *)(a1 + 272) remoteRATType] == 0;
}

BOOL _VCConnectionIDS_IsLocalOnWired(uint64_t a1)
{
  return [*(id *)(a1 + 272) RATType] == 9;
}

BOOL _VCConnectionIDS_IsRemoteOnWired(uint64_t a1)
{
  return [*(id *)(a1 + 272) remoteRATType] == 9;
}

uint64_t _VCConnectionIDS_IsOnSameInterfacesWithConnection(void *a1, void *a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (!a2)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      uint64_t v8 = VRTraceErrorLogLevelToCSTR();
      uint64_t v9 = *MEMORY[0x1E4F47A50];
      uint64_t v10 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        uint64_t v11 = 0;
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
          return v11;
        }
        int v26 = 136315650;
        uint64_t v27 = v8;
        __int16 v28 = 2080;
        int v29 = "_VCConnectionIDS_IsOnSameInterfacesWithConnection";
        __int16 v30 = 1024;
        int v31 = 471;
        _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCConnection: connection to check is nil", (uint8_t *)&v26, 0x1Cu);
      }
      else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        _VCConnectionIDS_IsOnSameInterfacesWithConnection_cold_1();
      }
    }
    return 0;
  }
  if (ErrorLogLevelForModule >= 8)
  {
    uint64_t v5 = VRTraceErrorLogLevelToCSTR();
    long long v6 = *MEMORY[0x1E4F47A50];
    long long v7 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        int v26 = 136316162;
        uint64_t v27 = v5;
        __int16 v28 = 2080;
        int v29 = "_VCConnectionIDS_IsOnSameInterfacesWithConnection";
        __int16 v30 = 1024;
        int v31 = 477;
        __int16 v32 = 2080;
        uint64_t v33 = objc_msgSend((id)objc_msgSend(a1, "description"), "UTF8String");
        __int16 v34 = 2080;
        uint64_t v35 = objc_msgSend((id)objc_msgSend(a2, "description"), "UTF8String");
        _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCConnection: isOnSameInterfacesWithConnection: %s vs. %s", (uint8_t *)&v26, 0x30u);
      }
    }
    else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      int v26 = 136316162;
      uint64_t v27 = v5;
      __int16 v28 = 2080;
      int v29 = "_VCConnectionIDS_IsOnSameInterfacesWithConnection";
      __int16 v30 = 1024;
      int v31 = 477;
      __int16 v32 = 2080;
      uint64_t v33 = objc_msgSend((id)objc_msgSend(a1, "description"), "UTF8String");
      __int16 v34 = 2080;
      uint64_t v35 = objc_msgSend((id)objc_msgSend(a2, "description"), "UTF8String");
      _os_log_debug_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCConnection: isOnSameInterfacesWithConnection: %s vs. %s", (uint8_t *)&v26, 0x30u);
    }
  }
  int IsLocalOnWiFiOrWired = VCConnection_IsLocalOnWiFiOrWired((uint64_t)a1);
  if (IsLocalOnWiFiOrWired == VCConnection_IsLocalOnWiFiOrWired((uint64_t)a2)
    && (int IsRemoteOnWiFiOrWired = VCConnection_IsRemoteOnWiFiOrWired((uint64_t)a1),
        IsRemoteOnWiFiOrWired == VCConnection_IsRemoteOnWiFiOrWired((uint64_t)a2)))
  {
    int IsLocalOnWired = VCConnection_IsLocalOnWired((uint64_t)a1);
    if (IsLocalOnWired == VCConnection_IsLocalOnWired((uint64_t)a2))
    {
      int IsRemoteOnWired = VCConnection_IsRemoteOnWired((uint64_t)a1);
      if (IsRemoteOnWired == VCConnection_IsRemoteOnWired((uint64_t)a2))
      {
        uint64_t v11 = 1;
        goto LABEL_34;
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v19 = VRTraceErrorLogLevelToCSTR();
      uint64_t v14 = *MEMORY[0x1E4F47A50];
      uint64_t v20 = *MEMORY[0x1E4F47A50];
      if (!*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG)) {
          _VCConnectionIDS_IsOnSameInterfacesWithConnection_cold_4();
        }
        goto LABEL_33;
      }
      uint64_t v11 = 0;
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_34;
      }
      int v26 = 136315650;
      uint64_t v27 = v19;
      __int16 v28 = 2080;
      int v29 = "_VCConnectionIDS_IsOnSameInterfacesWithConnection";
      __int16 v30 = 1024;
      int v31 = 482;
      unint64_t v16 = " [%s] %s:%d Different wired interface type";
      goto LABEL_23;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v13 = VRTraceErrorLogLevelToCSTR();
    uint64_t v14 = *MEMORY[0x1E4F47A50];
    uint64_t v15 = *MEMORY[0x1E4F47A50];
    if (!*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
        _VCConnectionIDS_IsOnSameInterfacesWithConnection_cold_3();
      }
      goto LABEL_33;
    }
    uint64_t v11 = 0;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_34;
    }
    int v26 = 136315650;
    uint64_t v27 = v13;
    __int16 v28 = 2080;
    int v29 = "_VCConnectionIDS_IsOnSameInterfacesWithConnection";
    __int16 v30 = 1024;
    int v31 = 479;
    unint64_t v16 = " [%s] %s:%d Different non-cell interface type";
LABEL_23:
    _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)&v26, 0x1Cu);
  }
LABEL_33:
  uint64_t v11 = 0;
LABEL_34:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v22 = VRTraceErrorLogLevelToCSTR();
    char v23 = *MEMORY[0x1E4F47A50];
    uint64_t v24 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        int v26 = 136315906;
        uint64_t v27 = v22;
        __int16 v28 = 2080;
        int v29 = "_VCConnectionIDS_IsOnSameInterfacesWithConnection";
        __int16 v30 = 1024;
        int v31 = 485;
        __int16 v32 = 1024;
        LODWORD(v33) = v11;
        _os_log_impl(&dword_1E1EA4000, v23, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCConnection: isOnSameInterfacesWithConnection: %{BOOL}d", (uint8_t *)&v26, 0x22u);
      }
    }
    else if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
    {
      _VCConnectionIDS_IsOnSameInterfacesWithConnection_cold_2();
    }
  }
  return v11;
}

uint64_t _VCConnectionIDS_IsEndToEndLink(uint64_t a1)
{
  *(unsigned char *)(a1 + 334) = [*(id *)(a1 + 272) isVirtualRelayLink];
  if (*(unsigned char *)(a1 + 334)) {
    return 1;
  }
  else {
    return VCConnection_IsRelay(a1) ^ 1;
  }
}

uint64_t _VCConnectionIDS_ConnectionID(uint64_t a1)
{
  return [*(id *)(a1 + 272) linkID];
}

uint64_t _VCConnectionIDS_IsLocalExpensive(uint64_t a1)
{
  return *(_WORD *)(a1 + 8) & 1;
}

uint64_t _VCConnectionIDS_IsLocalConstrained(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 8) >> 1) & 1;
}

uint64_t _VCConnectionIDS_IsRemoteExpensive(uint64_t a1)
{
  return *(_WORD *)(a1 + 10) & 1;
}

uint64_t _VCConnectionIDS_IsRemoteConstrained(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 10) >> 1) & 1;
}

uint64_t _VCConnectionIDS_ReportingIPVersion(uint64_t a1)
{
  char v2 = [*(id *)(a1 + 272) localLinkFlags];
  if ([*(id *)(a1 + 272) networkType] == 2
    || [*(id *)(a1 + 272) remoteNetworkType] == 2)
  {
    BOOL v3 = (v2 & 0x10) == 0;
    unsigned int v4 = 3;
  }
  else
  {
    BOOL v3 = (v2 & 8) == 0;
    unsigned int v4 = 1;
  }
  if (v3) {
    return v4;
  }
  else {
    return v4 + 1;
  }
}

BOOL _VCConnectionIDS_ReportingQRServerConfig(uint64_t a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      long long v6 = *MEMORY[0x1E4F47A50];
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      int v7 = 136316162;
      uint64_t v8 = v5;
      __int16 v9 = 2080;
      uint64_t v10 = "_VCConnectionIDS_ReportingQRServerConfig";
      __int16 v11 = 1024;
      int v12 = 635;
      __int16 v13 = 2112;
      uint64_t v14 = a1;
      __int16 v15 = 2112;
      unint64_t v16 = a2;
      _os_log_error_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d Argument not valid context=%@ and dictionary=%@", (uint8_t *)&v7, 0x30u);
    }
    return 0;
  }
  if ([*(id *)(a1 + 272) qrExperiments])
  {
    objc_msgSend(a2, "addEntriesFromDictionary:", objc_msgSend(*(id *)(a1 + 272), "qrExperiments"));
    return 1;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
    return 0;
  }
  VRTraceErrorLogLevelToCSTR();
  BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
  if (result)
  {
    _VCConnectionIDS_ReportingQRServerConfig_cold_1();
    return 0;
  }
  return result;
}

uint64_t _VCConnectionIDS_ReportingSliceStatus(uint64_t a1, int a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCConnectionIDS_ReportingSliceStatus_cold_1();
      }
    }
    return 0;
  }
  if (!a2)
  {
    if (VCConnection_IsRemoteOnCellular(a1))
    {
      int v7 = *(void **)(a1 + 272);
      if (v7)
      {
        char v5 = [v7 remoteLinkFlags];
        if ((v5 & 0x20) != 0) {
          goto LABEL_6;
        }
        return 1;
      }
      goto LABEL_23;
    }
LABEL_20:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v9 = VRTraceErrorLogLevelToCSTR();
      uint64_t v10 = *MEMORY[0x1E4F47A50];
      BOOL v11 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
      unsigned __int8 v6 = 0;
      if (!v11) {
        return v6;
      }
      int v12 = 136316162;
      uint64_t v13 = v9;
      __int16 v14 = 2080;
      __int16 v15 = "_VCConnectionIDS_ReportingSliceStatus";
      __int16 v16 = 1024;
      int v17 = 655;
      __int16 v18 = 2112;
      uint64_t v19 = a1;
      __int16 v20 = 1024;
      int v21 = a2;
      _os_log_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Connection is not on cellular context=%@ isLocal=%d", (uint8_t *)&v12, 0x2Cu);
    }
    return 0;
  }
  if ((VCConnection_IsLocalOnCellular(a1) & 1) == 0) {
    goto LABEL_20;
  }
  unsigned int v4 = *(void **)(a1 + 272);
  if (!v4)
  {
LABEL_23:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCConnectionIDS_ReportingSliceStatus_cold_2();
      }
    }
    return 0;
  }
  char v5 = [v4 localLinkFlags];
  if ((v5 & 0x20) == 0) {
    return 1;
  }
LABEL_6:
  if (v5 < 0) {
    unsigned __int8 v6 = 4;
  }
  else {
    unsigned __int8 v6 = 3;
  }
  if ((v5 & 0x40) == 0) {
    return 2;
  }
  return v6;
}

BOOL _VCConnectionIDS_IsHopByHopEncryptionSupported(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 272) connectionType];
  unint64_t v3 = [*(id *)(a1 + 272) remoteConnectionType] - 2;
  return (unint64_t)(v2 - 2) < 4 || v3 < 4;
}

BOOL VCConnectionIDSIsCellularRATType(int a1)
{
  if (a1) {
    BOOL v1 = a1 == 9;
  }
  else {
    BOOL v1 = 1;
  }
  return !v1;
}

uint64_t VCConnectionIDSCellTechForRATType(uint64_t result)
{
  unsigned int v1 = result;
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (result >= 8)
  {
    if (result == 1010) {
      return 9;
    }
    if (result == 1009) {
      return 8;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v2 = VRTraceErrorLogLevelToCSTR();
      unint64_t v3 = *MEMORY[0x1E4F47A50];
      BOOL v4 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
      BOOL result = 0;
      if (!v4) {
        return result;
      }
      int v5 = 136315906;
      uint64_t v6 = v2;
      __int16 v7 = 2080;
      uint64_t v8 = "VCConnectionIDSCellTechForRATType";
      __int16 v9 = 1024;
      int v10 = 568;
      __int16 v11 = 2048;
      uint64_t v12 = v1;
      _os_log_impl(&dword_1E1EA4000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unknown IDSDataChannelRATType %lu", (uint8_t *)&v5, 0x26u);
    }
    return 0;
  }
  return result;
}

uint64_t VCConnectionIDS_NetworkOverheadInBytes(uint64_t a1, int a2, int a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (VCConnection_IsIPv6(a1)) {
      int v5 = 48;
    }
    else {
      int v5 = 28;
    }
    if (a3) {
      int v6 = 30;
    }
    else {
      int v6 = 29;
    }
    return ((a2 > 1) | (2 * a2)) + v6 + 8 * (a2 != 0) + v5;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v8 = VRTraceErrorLogLevelToCSTR();
      __int16 v9 = *MEMORY[0x1E4F47A50];
      BOOL v10 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (!v10) {
        return result;
      }
      int v11 = 136315650;
      uint64_t v12 = v8;
      __int16 v13 = 2080;
      __int16 v14 = "VCConnectionIDS_NetworkOverheadInBytes";
      __int16 v15 = 1024;
      int v16 = 337;
      _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v11, 0x1Cu);
    }
    return 0;
  }
}

uint64_t VCConnection_GetWorstCaseNetworkOverhead(int a1, int a2)
{
  if (a2) {
    int v2 = 45;
  }
  else {
    int v2 = 44;
  }
  return ((a1 > 1) | (2 * a1)) + v2 + 56;
}

uint64_t VCConnection_GetFacetimeNetworkOverhead(int a1)
{
  if (a1) {
    return 68;
  }
  else {
    return 48;
  }
}

uint64_t VCConnectionIDS_LinkID(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v2 = VRTraceErrorLogLevelToCSTR();
      unint64_t v3 = *MEMORY[0x1E4F47A50];
      BOOL v4 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
      LOBYTE(result) = 0;
      if (!v4) {
        return result;
      }
      int v5 = 136315650;
      uint64_t v6 = v2;
      __int16 v7 = 2080;
      uint64_t v8 = "VCConnectionIDS_LinkID";
      __int16 v9 = 1024;
      int v10 = 517;
      _os_log_impl(&dword_1E1EA4000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v5, 0x1Cu);
    }
    LOBYTE(result) = 0;
    return result;
  }
  LOBYTE(result) = [*(id *)(a1 + 272) linkID];
  return result;
}

BOOL VCConnectionIDS_MatchesChannelTokenWithSourceDestinationInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    int v4 = *(_DWORD *)(a1 + 280);
    return v4 == VCDatagramChannelIDS_Token(*(void *)(a2 + 112));
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    uint64_t v6 = VRTraceErrorLogLevelToCSTR();
    __int16 v7 = *MEMORY[0x1E4F47A50];
    BOOL v8 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v8) {
      return result;
    }
    int v9 = 136316162;
    uint64_t v10 = v6;
    __int16 v11 = 2080;
    uint64_t v12 = "VCConnectionIDS_MatchesChannelTokenWithSourceDestinationInfo";
    __int16 v13 = 1024;
    int v14 = 539;
    __int16 v15 = 2048;
    uint64_t v16 = a1;
    __int16 v17 = 2048;
    uint64_t v18 = a2;
    _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance=%p or sourceDestinationInfo=%p passed", (uint8_t *)&v9, 0x30u);
  }
  return 0;
}

BOOL VCConnectionIDS_IsQUICPod(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return *(unsigned char *)(a1 + 335) != 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    uint64_t v2 = VRTraceErrorLogLevelToCSTR();
    unint64_t v3 = *MEMORY[0x1E4F47A50];
    BOOL v4 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v4) {
      return result;
    }
    int v5 = 136315650;
    uint64_t v6 = v2;
    __int16 v7 = 2080;
    BOOL v8 = "VCConnectionIDS_IsQUICPod";
    __int16 v9 = 1024;
    int v10 = 624;
    _os_log_impl(&dword_1E1EA4000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil context passed", (uint8_t *)&v5, 0x1Cu);
  }
  return 0;
}

BOOL VCConnectionIDSIsKnownRATType(unsigned int a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a1 >= 0xA && (int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    uint64_t v2 = VRTraceErrorLogLevelToCSTR();
    unint64_t v3 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 136315906;
      uint64_t v6 = v2;
      __int16 v7 = 2080;
      BOOL v8 = "VCConnectionIDSIsKnownRATType";
      __int16 v9 = 1024;
      int v10 = 702;
      __int16 v11 = 2048;
      uint64_t v12 = a1;
      _os_log_impl(&dword_1E1EA4000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unknown IDSDataChannelRATType %lu", (uint8_t *)&v5, 0x26u);
    }
  }
  return a1 < 0xA;
}

const char *VCConnectionIDSRATTypeToStr(int a1)
{
  BOOL result = "Unknown";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      BOOL result = "UMTS";
      break;
    case 2:
      BOOL result = "GSM";
      break;
    case 3:
      BOOL result = "C2K";
      break;
    case 4:
      BOOL result = "C2K1x";
      break;
    case 5:
      BOOL result = "LTE";
      break;
    case 6:
      BOOL result = "HSPA+";
      break;
    case 7:
      BOOL result = "UTRAN";
      break;
    case 8:
      goto LABEL_4;
    case 9:
      BOOL result = "Wired";
      break;
    default:
      if ((a1 - 1009) >= 2) {
        BOOL result = "Invalid";
      }
      else {
LABEL_4:
      }
        BOOL result = "5G";
      break;
  }
  return result;
}

BOOL VCVideoAttributes_IsEqual(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  BOOL result = 0;
  if (a1 && a2)
  {
    BOOL v5 = *(double *)(a1 + 8) == *(double *)(a2 + 8) && *(double *)(a1 + 16) == *(double *)(a2 + 16);
    return v5
        && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24)
        && *(_DWORD *)(a1 + 28) == *(_DWORD *)(a2 + 28)
        && *(unsigned __int8 *)(a1 + 32) == *(unsigned __int8 *)(a2 + 32)
        && *(unsigned __int8 *)(a1 + 72) == *(unsigned __int8 *)(a2 + 72)
        && *(unsigned __int8 *)(a1 + 73) == *(unsigned __int8 *)(a2 + 73)
        && CGRectEqualToRect(*(CGRect *)(a1 + 40), *(CGRect *)(a2 + 40))
        && *(float *)(a1 + 100) == *(float *)(a2 + 100);
  }
  return result;
}

void VCRateControlAlgorithmStabilizedNOWRDPriv_Configure(uint64_t a1, void *__src, int a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (__src)
    {
      memcpy((void *)(a1 + 40), __src, 0x3F0uLL);
      VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable(a1);
      *(unsigned char *)(a1 + 1153) = 0;
      *(unsigned char *)(a1 + 25560) = 0;
      *(unsigned char *)(a1 + 5324) = *((unsigned char *)__src + 368);
      uint64_t v6 = *(void *)(a1 + 25568);
      if (*(_DWORD *)(a1 + 880))
      {
        if (!v6)
        {
          __int16 v7 = objc_alloc_init(VCRateControlSmartBrake);
          *(void *)(a1 + 25568) = v7;
          uint64_t v8 = objc_opt_class();
          if (!v7)
          {
            if (v8 == a1)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  VCRateControlAlgorithmStabilizedNOWRDPriv_Configure_cold_3();
                }
              }
            }
            else
            {
              if (objc_opt_respondsToSelector()) {
                int v10 = (__CFString *)[(id)a1 performSelector:sel_logPrefix];
              }
              else {
                int v10 = &stru_1F3D3E450;
              }
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                uint64_t v20 = VRTraceErrorLogLevelToCSTR();
                int v21 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136316162;
                  uint64_t v38 = v20;
                  __int16 v39 = 2080;
                  __int16 v40 = "_VCRateControlAlgorithmStabilizedNOWRD_InitSmartBrake";
                  __int16 v41 = 1024;
                  int v42 = 256;
                  __int16 v43 = 2112;
                  *(void *)__int16 v44 = v10;
                  *(_WORD *)&v44[8] = 2048;
                  uint64_t v45 = a1;
                  _os_log_error_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d %@(%p) Could not initialize smart brake in rate control algorithm.", buf, 0x30u);
                }
              }
            }
            *(_DWORD *)(a1 + 880) = 0;
            goto LABEL_30;
          }
          if (v8 == a1)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
              goto LABEL_30;
            }
            uint64_t v11 = VRTraceErrorLogLevelToCSTR();
            uint64_t v12 = *MEMORY[0x1E4F47A50];
            if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_30;
            }
            int v13 = *(_DWORD *)(a1 + 880);
            *(_DWORD *)buf = 136315906;
            uint64_t v38 = v11;
            __int16 v39 = 2080;
            __int16 v40 = "_VCRateControlAlgorithmStabilizedNOWRD_InitSmartBrake";
            __int16 v41 = 1024;
            int v42 = 259;
            __int16 v43 = 1024;
            *(_DWORD *)__int16 v44 = v13;
            int v14 = "VCRC [%s] %s:%d Smart brake init with smartBrakeStrategy=%d";
            __int16 v15 = v12;
            uint32_t v16 = 34;
          }
          else
          {
            if (objc_opt_respondsToSelector()) {
              __int16 v9 = (__CFString *)[(id)a1 performSelector:sel_logPrefix];
            }
            else {
              __int16 v9 = &stru_1F3D3E450;
            }
            if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
              goto LABEL_30;
            }
            uint64_t v17 = VRTraceErrorLogLevelToCSTR();
            uint64_t v18 = *MEMORY[0x1E4F47A50];
            if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_30;
            }
            int v19 = *(_DWORD *)(a1 + 880);
            *(_DWORD *)buf = 136316418;
            uint64_t v38 = v17;
            __int16 v39 = 2080;
            __int16 v40 = "_VCRateControlAlgorithmStabilizedNOWRD_InitSmartBrake";
            __int16 v41 = 1024;
            int v42 = 259;
            __int16 v43 = 2112;
            *(void *)__int16 v44 = v9;
            *(_WORD *)&v44[8] = 2048;
            uint64_t v45 = a1;
            __int16 v46 = 1024;
            int v47 = v19;
            int v14 = "VCRC [%s] %s:%d %@(%p) Smart brake init with smartBrakeStrategy=%d";
            __int16 v15 = v18;
            uint32_t v16 = 54;
          }
          _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, v14, buf, v16);
LABEL_30:
          *(_DWORD *)(a1 + 5180) = 0;
          [*(id *)(a1 + 25568) config];
          *(unsigned char *)(a1 + 5204) = v22;
          goto LABEL_31;
        }
      }
      else if (!v6)
      {
LABEL_31:
        *(void *)(a1 + 4992) = 0;
        *(void *)(a1 + 5040) = *(void *)(a1 + 760);
        VCRateControlAlgorithmBasePriv_ResetLossEventBuffer(a1);
        *(_DWORD *)(a1 + 1148) = -1;
        if (a3)
        {
          *(_DWORD *)(a1 + 1072) = 1;
          *(_DWORD *)(a1 + 1084) = *(_DWORD *)(a1 + 56);
        }
        char v23 = 1;
        if (!*(unsigned char *)(a1 + 411))
        {
          *(_DWORD *)(a1 + 5288) = 0;
          *(_DWORD *)(a1 + 5292) = 0;
          *(void *)(a1 + 5296) = 0;
          char v23 = *(unsigned char *)(a1 + 411);
        }
        *(unsigned char *)(a1 + 5312) = v23;
        int v24 = *(_DWORD *)(a1 + 1084);
        if (v24 >= *(_DWORD *)(a1 + 60)) {
          int v24 = *(_DWORD *)(a1 + 60);
        }
        if (v24 <= *(_DWORD *)(a1 + 64)) {
          int v24 = *(_DWORD *)(a1 + 64);
        }
        *(_DWORD *)(a1 + 1084) = v24;
        *(_DWORD *)(a1 + 1104) = *(_DWORD *)(*(void *)(a1 + 48) + 4 * *(int *)(a1 + 1084));
        VCRateControlMediaController_SetMinTargetBitrate(*(void *)(a1 + 1048), *(_DWORD *)(*(void *)(a1 + 48) + 4 * *(int *)(a1 + 64)));
        VCRateControlAlgorithmBasePriv_ResetOWRDList(a1);
        *(_DWORD *)(a1 + 5316) = 0;
        *(_DWORD *)(a1 + 5320) = 0;
        *(unsigned char *)(a1 + 2872) = 1;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v31 = VRTraceErrorLogLevelToCSTR();
          __int16 v32 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            int v33 = *(_DWORD *)(a1 + 1104);
            uint64_t v34 = *(void *)(a1 + 48);
            int v35 = *(_DWORD *)(v34 + 4 * *(int *)(a1 + 64));
            int v36 = *(_DWORD *)(v34 + 4 * *(int *)(a1 + 60));
            *(_DWORD *)buf = 136316418;
            uint64_t v38 = v31;
            __int16 v39 = 2080;
            __int16 v40 = "VCRateControlAlgorithmStabilizedNOWRDPriv_Configure";
            __int16 v41 = 1024;
            int v42 = 239;
            __int16 v43 = 1024;
            *(_DWORD *)__int16 v44 = v33;
            *(_WORD *)&v44[4] = 1024;
            *(_DWORD *)&v44[6] = v35;
            LOWORD(v45) = 1024;
            *(_DWORD *)((char *)&v45 + 2) = v36;
            _os_log_impl(&dword_1E1EA4000, v32, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Configuring VCRateControl algorithm with targetBitrate=%d, minBitrate=%d, maxBitrate=%d", buf, 0x2Eu);
          }
        }
        VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Configure with targetBitrate=%d, minBitrate=%d, maxBitrate=%d", v25, v26, v27, v28, v29, v30, *(_DWORD *)(a1 + 1104));
        return;
      }
      VCRateControlSmartBrake_ResetState(v6);
      goto LABEL_31;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCRateControlAlgorithmStabilizedNOWRDPriv_Configure_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlAlgorithmStabilizedNOWRDPriv_Configure_cold_1();
    }
  }
}

BOOL _VCRateControlAlgorithmStabilizedNOWRD_DoRateControl(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10)
{
  uint64_t v176 = *MEMORY[0x1E4F143B8];
  int v12 = *(_DWORD *)a2;
  if (*(int *)a2 <= 10)
  {
    if (v12 != 1)
    {
      if (v12 == 2)
      {
        BOOL result = VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateInternalStatistics(a1, a2);
        if (!result) {
          return result;
        }
        VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateSmartBrakeOutputWithVCRCStatistics(a1, a2);
        int ShouldRampDown = VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDown(a1);
        int v22 = *(_DWORD *)(a1 + 880);
        if (v22)
        {
          if (VCRateControlSmartBrake_IsOutputEmpty(*(void *)(a1 + 5328), *(_DWORD *)(a1 + 5336)))
          {
            int v22 = 0;
          }
          else
          {
            [*(id *)(a1 + 25568) config];
            unsigned int v27 = (float)((float)*(unsigned int *)(a1 + 5332)
                                      + (float)(v26 * (float)*(unsigned int *)(a1 + 5336)));
            if (*(_DWORD *)(a1 + 1112) >= *(_DWORD *)(a1 + 1104)) {
              unsigned int v28 = *(_DWORD *)(a1 + 1104);
            }
            else {
              unsigned int v28 = *(_DWORD *)(a1 + 1112);
            }
            float v25 = *(float *)(a1 + 5328);
            int v22 = v25 >= COERCE_FLOAT([*(id *)(a1 + 25568) config]) || v28 > v27;
          }
        }
        switch(*(_DWORD *)(a1 + 1072))
        {
          case 0:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              uint64_t v30 = VRTraceErrorLogLevelToCSTR();
              uint64_t v31 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                uint64_t v117 = v30;
                __int16 v118 = 2080;
                uint64_t v119 = "_VCRateControlAlgorithmStabilizedNOWRD_RunRateControlStateTransition";
                __int16 v120 = 1024;
                int v121 = 616;
                _os_log_impl(&dword_1E1EA4000, v31, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d VCRateControl is paused", buf, 0x1Cu);
              }
            }
            goto LABEL_103;
          case 1:
            uint64_t v32 = 28;
            if (!*(unsigned char *)(a1 + 1154)) {
              uint64_t v32 = 32;
            }
            if (v22) {
              goto LABEL_56;
            }
            if (ShouldRampDown)
            {
              *(_DWORD *)(a1 + 1084) = _VCRateControlAlgorithmStabilizedNOWRD_RampDownTier(a1);
              goto LABEL_87;
            }
            int v60 = *(_DWORD *)(a1 + 40 + v32);
            if (VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUp(a1))
            {
              *(_DWORD *)(a1 + 1084) = _VCRateControlAlgorithmStabilizedNOWRD_RampUpTier(a1);
              int v61 = *(_DWORD *)(a1 + 1084);
              if (v61 == *(_DWORD *)(a1 + 60)) {
                goto LABEL_87;
              }
              if (*(unsigned char *)(a1 + 1154))
              {
                if (v61 > *(_DWORD *)(a1 + 448) || v61 >= v60) {
                  goto LABEL_87;
                }
              }
              else if (v61 >= v60)
              {
                goto LABEL_87;
              }
            }
            goto LABEL_103;
          case 2:
            if (v22)
            {
LABEL_56:
              _VCRateControlAlgorithmStabilizedNOWRD_ToggleSmartBrake(a1, v14, v15, v16, v17, v18, v19, v20);
              *(_DWORD *)(a1 + 1084) = _VCRateControlAlgorithmStabilizedNOWRD_SmartBrakeBitrateCongestionTierIndex((unsigned int *)a1, v33);
              uint64_t v34 = a1;
              int v35 = 5;
              goto LABEL_102;
            }
            if (ShouldRampDown)
            {
              *(_DWORD *)(a1 + 1084) = _VCRateControlAlgorithmStabilizedNOWRD_RampDownTier(a1);
              if (_VCRateControlAlgorithmStabilizedNOWRD_IsBitrateOscillating(a1, *(_DWORD *)(a1 + 1084))) {
                int v35 = 4;
              }
              else {
                int v35 = 3;
              }
LABEL_101:
              uint64_t v34 = a1;
              goto LABEL_102;
            }
            if (VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUp(a1))
            {
              *(_DWORD *)(a1 + 1084) = _VCRateControlAlgorithmStabilizedNOWRD_RampUpTier(a1);
              if (VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldFastRampUp(a1)) {
                int v35 = 1;
              }
              else {
                int v35 = 3;
              }
              goto LABEL_101;
            }
            goto LABEL_103;
          case 3:
            *(_DWORD *)(a1 + 1076) |= 1u;
            if (v22)
            {
              _VCRateControlAlgorithmStabilizedNOWRD_ToggleSmartBrake(a1, v14, v15, v16, v17, v18, v19, v20);
              *(_DWORD *)(a1 + 1084) = _VCRateControlAlgorithmStabilizedNOWRD_SmartBrakeBitrateCongestionTierIndex((unsigned int *)a1, v36);
              int v37 = 5;
LABEL_71:
              VCRateControlAlgorithmBasePriv_StateChange(a1, v37);
              goto LABEL_72;
            }
            if (ShouldRampDown)
            {
              *(_DWORD *)(a1 + 1084) = _VCRateControlAlgorithmStabilizedNOWRD_RampDownTier(a1);
              if (_VCRateControlAlgorithmStabilizedNOWRD_IsBitrateOscillating(a1, *(_DWORD *)(a1 + 1084)))
              {
                int v37 = 4;
                goto LABEL_71;
              }
            }
LABEL_72:
            _VCRateControlAlgorithmStabilizedNOWRD_GetRampUpFrozenDuration(a1);
            *(double *)(a1 + 25416) = v51;
            if (*(double *)(a1 + 1128) - *(double *)(a1 + 1136) > v51)
            {
LABEL_78:
              uint64_t v34 = a1;
              int v35 = 2;
LABEL_102:
              VCRateControlAlgorithmBasePriv_StateChange(v34, v35);
            }
LABEL_103:
            *(_DWORD *)(a1 + 1104) = *(_DWORD *)(*(void *)(a1 + 48) + 4 * *(int *)(a1 + 1084));
            VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateVCRateControlHistory(a1);
            uint64_t v63 = *(void *)(a1 + 1048);
            if (v63)
            {
              if (*(unsigned char *)(a1 + 1153)) {
                char v64 = *(double *)(a1 + 1128) - *(double *)(a1 + 5224) > 0.5;
              }
              else {
                char v64 = 0;
              }
              if (*(_DWORD *)(a1 + 1072) == 1) {
                char v65 = v64 ^ 1;
              }
              else {
                char v65 = 0;
              }
              VCRateControlMediaController_SetShouldDisableLargeFrameRequestsWhenInitialRampUp(v63, v65);
              VCRateControlMediaController_SetRateLimitedMaxTimeExceeded(*(void *)(a1 + 1048), v64);
            }
            if (*(unsigned char *)(a1 + 5160))
            {
              int v66 = *(_DWORD *)(a1 + 1120);
              *(_DWORD *)(a1 + 1120) = v66 + 1;
              if ((v66 & 0xF) == 0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                uint64_t v67 = VRTraceErrorLogLevelToCSTR();
                __int16 v68 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v115 = *(void *)(a1 + 1128);
                  int v114 = *(unsigned __int16 *)(a1 + 5218);
                  uint64_t v113 = *(void *)(a1 + 2888);
                  uint64_t v112 = *(void *)(a1 + 2896);
                  uint64_t v111 = *(void *)(a1 + 2904);
                  uint64_t v109 = *(void *)(a1 + 2912);
                  if (*(unsigned char *)(a1 + 5136)) {
                    int v69 = 79;
                  }
                  else {
                    int v69 = 88;
                  }
                  int v108 = v69;
                  int v107 = (int)(*(double *)(a1 + 5104) * 1000.0);
                  double v70 = *(double *)(a1 + 5024) * 100.0;
                  int v106 = *(_DWORD *)(a1 + 1200);
                  double v71 = *(double *)(a1 + 5088) * 100.0;
                  int v105 = *(_DWORD *)(a1 + 5016);
                  unsigned int v104 = *(_DWORD *)(a1 + 1112) / 0x3E8u;
                  int v103 = *(unsigned __int16 *)(a1 + 1076);
                  int v102 = *(unsigned __int16 *)(a1 + 1080);
                  unsigned int v100 = *(_DWORD *)(a1 + 1104) / 0x3E8u;
                  int v101 = *(_DWORD *)(a1 + 1116);
                  unsigned int v72 = *(_DWORD *)(a1 + 5288) / 0x3E8u;
                  int v73 = *(_DWORD *)(a1 + 5292);
                  unsigned int v74 = (*(double *)(a1 + 5296) * 1000.0);
                  unsigned int v75 = VCRateControlMediaController_AudioSendingBitrate(*(void *)(a1 + 1048)) / 0x3E8;
                  int v76 = VCRateControlMediaController_AudioFractionTier(*(void *)(a1 + 1048));
                  if (*(unsigned char *)(a1 + 5220)) {
                    int v77 = "S";
                  }
                  else {
                    int v77 = "U";
                  }
                  if (*(unsigned char *)(a1 + 1153))
                  {
                    __int16 v78 = "<";
                  }
                  else
                  {
                    int v79 = v76;
                    BOOL IsVideoStopped = VCRateControlMediaController_IsVideoStopped(*(unsigned char **)(a1 + 1048));
                    __int16 v78 = "-";
                    BOOL v81 = !IsVideoStopped;
                    int v76 = v79;
                    if (!v81) {
                      __int16 v78 = "_";
                    }
                  }
                  int v82 = *(_DWORD *)(a1 + 1072);
                  double v83 = *(float *)(a1 + 5328);
                  int v84 = *(_DWORD *)(a1 + 5332);
                  *(_DWORD *)buf = 136322562;
                  uint64_t v117 = v67;
                  __int16 v118 = 2080;
                  uint64_t v119 = "_VCRateControlAlgorithmStabilizedNOWRD_PrintRateControlInfoToLogDump";
                  __int16 v120 = 1024;
                  int v121 = 1909;
                  __int16 v122 = 2048;
                  uint64_t v123 = v115;
                  __int16 v124 = 1024;
                  int v125 = v114;
                  __int16 v126 = 2048;
                  uint64_t v127 = v113;
                  __int16 v128 = 2048;
                  uint64_t v129 = v112;
                  __int16 v130 = 2048;
                  uint64_t v131 = v111;
                  __int16 v132 = 2048;
                  uint64_t v133 = v109;
                  __int16 v134 = 1024;
                  int v135 = v108;
                  __int16 v136 = 1024;
                  int v137 = v107;
                  __int16 v138 = 2048;
                  double v139 = v70;
                  __int16 v140 = 2048;
                  double v141 = v71;
                  __int16 v142 = 1024;
                  int v143 = v106;
                  __int16 v144 = 1024;
                  int v145 = v105;
                  __int16 v146 = 1024;
                  unsigned int v147 = v104;
                  __int16 v148 = 1024;
                  unsigned int v149 = v100;
                  __int16 v150 = 1024;
                  int v151 = v103;
                  __int16 v152 = 1024;
                  int v153 = v102;
                  __int16 v154 = 1024;
                  int v155 = v101;
                  __int16 v156 = 1024;
                  unsigned int v157 = v72;
                  __int16 v158 = 1024;
                  int v159 = v73;
                  __int16 v160 = 1024;
                  unsigned int v161 = v74;
                  __int16 v162 = 1024;
                  unsigned int v163 = v75;
                  __int16 v164 = 1024;
                  int v165 = v76;
                  __int16 v166 = 2080;
                  v167 = v77;
                  __int16 v168 = 2080;
                  v169 = v78;
                  __int16 v170 = 1024;
                  int v171 = v82;
                  __int16 v172 = 2048;
                  double v173 = v83;
                  __int16 v174 = 1024;
                  int v175 = v84;
                  _os_log_impl(&dword_1E1EA4000, v68, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d %8.3f/%04X:\t%.4f\t%.4f\t%.4f\t%.4f %c\tRTT:%-4u\tPLR:%4.2f@%.1f\tRRx:%4u\tMBL:%d\t%4u/%4u\t  CS:%04X %04X %u BB: %3u\t%4u\t%3u\t%u\t%u\t UAT %s %s\t%d\t%.3f\t%u", buf, 0xE6u);
                }
              }
            }
            uint64_t v85 = *(void *)(a1 + 5144);
            if (v85)
            {
              uint64_t v86 = *(void *)(a1 + 1128);
              uint64_t v88 = *(unsigned int *)(a1 + 1200);
              uint64_t v89 = *(unsigned int *)(a1 + 5016);
              if (*(unsigned char *)(a1 + 5136)) {
                uint64_t v90 = 79;
              }
              else {
                uint64_t v90 = 88;
              }
              uint64_t v91 = *(unsigned int *)(a1 + 1204);
              unint64_t v92 = *(unsigned int *)(a1 + 1112) / 0x3E8uLL;
              double v87 = *(double *)(a1 + 5248);
              uint64_t v93 = ((v87 + *(double *)(a1 + 5232)) / 1000.0);
              if (!*(unsigned char *)(a1 + 1153))
              {
                uint64_t v110 = *(void *)(a1 + 5144);
                uint64_t v94 = v90;
                uint64_t v95 = *(unsigned int *)(a1 + 1200);
                uint64_t v96 = *(unsigned int *)(a1 + 5016);
                uint64_t v97 = *(unsigned int *)(a1 + 1204);
                unint64_t v98 = *(unsigned int *)(a1 + 1112) / 0x3E8uLL;
                uint64_t v99 = ((v87 + *(double *)(a1 + 5232)) / 1000.0);
                VCRateControlMediaController_IsVideoStopped(*(unsigned char **)(a1 + 1048));
                uint64_t v93 = v99;
                unint64_t v92 = v98;
                uint64_t v91 = v97;
                uint64_t v89 = v96;
                uint64_t v88 = v95;
                uint64_t v90 = v94;
                uint64_t v85 = v110;
              }
              VRLogfilePrintWithTimestamp(v85, "%8.3f/%04X:\t%.4f\t%.4f\t%.4f\t%.4f %c\tRTT:%-4u\tPLR:%4.2f@%.1f\tRRx:%u\tMBL:%d %u\t%4u/%4u\t %4u:%4u/%4u  %4u:%4u/%4u  CS: %05X %05X %u BB: %3u\t%4u\t%3u\t%s UAT %u\t%u\t%s\t%s\t%d\t%d\t%d\t%d\t%.3f\t%.3f\t%u\t%u\n", v90, v88, v89, v91, v92, v93, v86);
            }
            *(_DWORD *)(a1 + 1076) = 0;
            *(_DWORD *)(a1 + 1080) = 0;
            break;
          case 4:
            *(_DWORD *)(a1 + 1076) |= 1u;
            if (v22)
            {
              _VCRateControlAlgorithmStabilizedNOWRD_ToggleSmartBrake(a1, v14, v15, v16, v17, v18, v19, v20);
              int v39 = _VCRateControlAlgorithmStabilizedNOWRD_SmartBrakeBitrateCongestionTierIndex((unsigned int *)a1, v38);
              int v40 = 5;
            }
            else
            {
              if (!ShouldRampDown) {
                goto LABEL_77;
              }
              int v39 = _VCRateControlAlgorithmStabilizedNOWRD_RampDownTier(a1);
              int v40 = 3;
            }
            *(_DWORD *)(a1 + 1084) = v39;
            VCRateControlAlgorithmBasePriv_StateChange(a1, v40);
LABEL_77:
            if (*(double *)(a1 + 1128) - *(double *)(a1 + 1136) > *(double *)(a1 + 25416)) {
              goto LABEL_78;
            }
            goto LABEL_103;
          case 5:
            *(unsigned char *)(a1 + 25608) = *(double *)(a1 + 1128) - *(double *)(a1 + 25600) > 6.0;
            float v41 = *(float *)(a1 + 5328);
            uint64_t v42 = [*(id *)(a1 + 25568) config];
            if (!*(unsigned char *)(a1 + 25608))
            {
              LODWORD(v50) = HIDWORD(v42);
              if (v41 > *((float *)&v42 + 1))
              {
                *(_DWORD *)(a1 + 1084) = _VCRateControlAlgorithmStabilizedNOWRD_SmartBrakeBitrateCongestionTierIndex((unsigned int *)a1, v50);
                goto LABEL_103;
              }
            }
            _VCRateControlAlgorithmStabilizedNOWRD_ToggleSmartBrake(a1, v43, v44, v45, v46, v47, v48, v49);
            unsigned int v52 = *(_DWORD *)(a1 + 5332);
            int v53 = *(_DWORD *)(a1 + 60);
            uint64_t v54 = *(void *)(a1 + 48);
            if (*(_DWORD *)(v54 + 4 * v53) <= v52) {
              goto LABEL_86;
            }
            uint64_t v55 = v53;
            uint64_t v56 = *(int *)(a1 + 64);
            if (v53 >= (int)v56) {
              int v53 = *(_DWORD *)(a1 + 64);
            }
            uint64_t v57 = v54 - 4;
            while (v55 > v56)
            {
              int v58 = v55 - 1;
              unsigned int v59 = *(_DWORD *)(v57 + 4 * v55--);
              if (v59 <= v52)
              {
                int v53 = v58;
                break;
              }
            }
LABEL_86:
            *(_DWORD *)(a1 + 1084) = v53;
LABEL_87:
            uint64_t v34 = a1;
            int v35 = 3;
            goto LABEL_102;
          default:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                _VCRateControlAlgorithmStabilizedNOWRD_DoRateControl_cold_2();
              }
            }
            goto LABEL_103;
        }
        return 1;
      }
      goto LABEL_21;
    }
    if (!*(_DWORD *)(a1 + 1072)) {
      return 0;
    }
    if (!*(void *)(a1 + 1048))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        _VCRateControlAlgorithmStabilizedNOWRD_DoRateControl_cold_3();
      }
      return 0;
    }
    VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateAlgorithmWithBasebandStatistics(a1, a2, a3, a4, a5, a6, a7, a8);
    if (VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDownDueToBaseband(a1))
    {
      *(_DWORD *)(a1 + 1084) = VCRateControlAlgorithmStabilizedNOWRDPriv_RampDownTierDueToBaseband(a1, *(double *)(a1 + 5264));
      VCRateControlAlgorithmBasePriv_StateChange(a1, 3);
    }
    else if (VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUpDueToBaseband((double *)a1))
    {
      *(_DWORD *)(a1 + 5308) = VCRateControlAlgorithmStabilizedNOWRDPriv_BasebandAdditionalTiersForRampUp(a1);
    }
    *(_DWORD *)(a1 + 1104) = *(_DWORD *)(*(void *)(a1 + 48) + 4 * *(int *)(a1 + 1084));
    if (*(unsigned char *)(a1 + 5312)) {
      VCRateControlMediaController_UpdateBasebandSuggestion(*(void *)(a1 + 1048), a2);
    }
    return 1;
  }
  if (v12 != 11)
  {
    if (v12 != 14)
    {
LABEL_21:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        _VCRateControlAlgorithmStabilizedNOWRD_DoRateControl_cold_1();
      }
      return 0;
    }
    if (!*(_DWORD *)(a1 + 1072))
    {
      BOOL result = 0;
      *(_DWORD *)(a1 + 5316) = 0;
      *(_DWORD *)(a1 + 5320) = 0;
      return result;
    }
    unint64_t v23 = *(void *)(a2 + 8);
    *(void *)(a1 + 5344) = v23;
    LODWORD(v23) = *(_DWORD *)(a1 + 5316);
    LODWORD(a10) = *(_DWORD *)(a2 + 40);
    *(_DWORD *)(a1 + 5316) = ((double)*(unint64_t *)&a10 * 0.1 + (double)v23 * 0.9);
    VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateBytesInFlightThreshold(a1);
    if (!*(unsigned char *)(a1 + 5324))
    {
      BOOL result = 0;
      *(unsigned char *)(a1 + 5314) = 1;
      return result;
    }
    if (VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDownDueToLocalRCEvent(a1))
    {
      *(_DWORD *)(a1 + 1084) = VCRateControlAlgorithmStabilizedNOWRDPriv_RampDownTierDueToLocalRCEvent((_DWORD *)a1, *(double *)(a2 + 8));
      VCRateControlAlgorithmBasePriv_StateChange(a1, 3);
    }
    else
    {
      *(unsigned char *)(a1 + 5314) = VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUpDueToLocalRCEvent(a1, v24);
    }
    *(_DWORD *)(a1 + 1104) = *(_DWORD *)(*(void *)(a1 + 48) + 4 * *(int *)(a1 + 1084));
    return 1;
  }

  return VCRateControlAlgorithmStabilizedNOWRDPriv_DoRateControlWithNWStatistics(a1, a2);
}

uint64_t _VCRateControlAlgorithmStabilizedNOWRD_StateEnter(uint64_t result)
{
  uint64_t v1 = result;
  int v2 = *(_DWORD *)(result + 1072);
  switch(v2)
  {
    case 4:
      *(void *)(result + 1136) = *(void *)(result + 1128);
      uint64_t v3 = 488;
      if (*(double *)(result + 1128) - *(double *)(result + 25424) > *(double *)(result + 472)) {
        uint64_t v3 = 480;
      }
      double v4 = *(double *)(result + 40 + v3);
      BOOL result = _VCRateControlAlgorithmStabilizedNOWRD_GetRampUpFrozenDuration(result);
      double v6 = v4 * v5;
      goto LABEL_9;
    case 3:
      *(void *)(result + 1136) = *(void *)(result + 1128);
      BOOL result = _VCRateControlAlgorithmStabilizedNOWRD_GetRampUpFrozenDuration(result);
LABEL_9:
      *(double *)(v1 + 25416) = v6;
      return result;
    case 1:
      *(unsigned char *)(result + 25464) = 0;
      break;
  }
  return result;
}

double _VCRateControlAlgorithmStabilizedNOWRD_StateExit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = *(_DWORD *)(a1 + 1072);
  if (v9 == 4)
  {
    double result = *(double *)(a1 + 1128);
    *(double *)(a1 + 25424) = result;
  }
  else if (v9 == 1)
  {
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Initial Rampup done!", a3, a4, a5, a6, a7, a8, v11);
    if (!*(unsigned char *)(a1 + 1154)) {
      *(unsigned char *)(a1 + 1154) = 1;
    }
  }
  return result;
}

uint64_t VCRateControlAlgorithmStabilizedNOWRDPriv_ResetBytesInFlight(uint64_t result)
{
  if (result)
  {
    *(_DWORD *)(result + 5316) = 0;
    *(_DWORD *)(result + 5320) = 0;
  }
  return result;
}

void VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable(uint64_t a1)
{
  if (a1)
  {
    *(unsigned char *)(a1 + 5220) = 0;
    ++*(_DWORD *)(a1 + 1116);
    *(unsigned char *)(a1 + 1152) = 0;
    if (*(_DWORD *)(a1 + 1072) != 1)
    {
      *(void *)(a1 + 1136) = *(void *)(a1 + 1128);
      *(void *)(a1 + 1208) = *(void *)(a1 + 1128);
    }
    if (*(_DWORD *)(a1 + 536) == 1) {
      *(double *)(a1 + 25440) = micro();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable_cold_1();
    }
  }
}

BOOL VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDownDueToLocalRCEvent(uint64_t a1)
{
  if (a1)
  {
    unsigned int v2 = *(_DWORD *)(a1 + 5320);
    if (v2)
    {
      HIDWORD(v3) = 1069128089;
      if (*(double *)(a1 + 5344) - *(double *)(a1 + 5352) > 0.1)
      {
        LODWORD(v3) = *(_DWORD *)(a1 + 5360);
        if (*(double *)(a1 + 1096) < (double)v3 * 0.5)
        {
          BOOL result = 0;
          *(_DWORD *)(a1 + 5316) = 0;
          return result;
        }
      }
      unsigned int v5 = *(_DWORD *)(a1 + 5316);
      BOOL result = v5 > v2;
      if (v5 > v2)
      {
        *(_DWORD *)(a1 + 1080) |= 0x1000u;
        *(void *)(a1 + 2912) = 0;
        double v6 = (_DWORD *)(a1 + 1148);
LABEL_9:
        _DWORD *v6 = v5 <= v2;
        return result;
      }
      double v6 = (_DWORD *)(a1 + 1148);
      if (*(_DWORD *)(a1 + 1148) != -1) {
        goto LABEL_9;
      }
      return 0;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
      return 0;
    }
    VRTraceErrorLogLevelToCSTR();
    BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
    if (result)
    {
      VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDownDueToLocalRCEvent_cold_2();
      return 0;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
      return 0;
    }
    VRTraceErrorLogLevelToCSTR();
    BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
    if (result)
    {
      VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDownDueToLocalRCEvent_cold_1();
      return 0;
    }
  }
  return result;
}

BOOL VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUpDueToLocalRCEvent(uint64_t a1, double a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUpDueToLocalRCEvent_cold_1();
      }
    }
    return 1;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 5320);
  if (!v3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      double v6 = *MEMORY[0x1E4F47A50];
      __int16 v7 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = 136315906;
          uint64_t v9 = v5;
          __int16 v10 = 2080;
          char v11 = "VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUpDueToLocalRCEvent";
          __int16 v12 = 1024;
          int v13 = 350;
          __int16 v14 = 2048;
          uint64_t v15 = a1;
          _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d _bytesInFlightThreshold is 0 in algorithm=%p", (uint8_t *)&v8, 0x26u);
        }
      }
      else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUpDueToLocalRCEvent_cold_2();
      }
    }
    return 1;
  }
  LODWORD(a2) = *(_DWORD *)(a1 + 5316);
  return (double)v3 * 0.9 > (double)*(unint64_t *)&a2;
}

uint64_t VCRateControlAlgorithmStabilizedNOWRDPriv_RampDownTierDueToLocalRCEvent(_DWORD *a1, double a2)
{
  if (a1)
  {
    VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable((uint64_t)a1);
    VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampDown((uint64_t)a1, a2);
    int v4 = a1[1329] / a1[1330];
    VCRateControlAlgorithmBasePriv_LogToDumpFiles((uint64_t)a1, "BytesInFlight rampDown numberOfTier=%d with bytesInFlight=%u, bytesInFlightThreshold=%u, roundTripTimeMinEnvelope=%f", v5, v6, v7, v8, v9, v10, v4);
    int v11 = a1[16];
    int v12 = a1[271] - v4;
    if (v11 <= v12) {
      return v12;
    }
    else {
      return v11;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCRateControlAlgorithmStabilizedNOWRDPriv_RampDownTierDueToLocalRCEvent_cold_1();
      }
    }
    return 0;
  }
}

void VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateBytesInFlightThreshold(uint64_t a1)
{
  if (a1)
  {
    unsigned int v2 = VCRateControlCongestionLevel_BitrateRange(*(_DWORD *)(a1 + 1104));
    if (*(unsigned char *)(a1 + 5209) && (double v3 = *(double *)(a1 + 40 + 8 * v2 + 928), v3 > 0.0))
    {
      double v4 = *(double *)(a1 + 5112);
      double v5 = v3 * v4;
      if (v5 < 0.15) {
        double v5 = 0.15;
      }
      double v6 = v4 + v5;
      LODWORD(v4) = *(_DWORD *)(a1 + 1200);
      *(_DWORD *)(a1 + 5320) = (v6 * (double)*(unint64_t *)&v4 * 1000.0 * 0.125);
    }
    else
    {
      *(_DWORD *)(a1 + 5320) = 0;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateBytesInFlightThreshold_cold_1();
    }
  }
}

double _VCRateControlAlgorithmStabilizedNOWRD_CongestionLevelThreshold(uint64_t a1, int a2, int a3)
{
  unsigned int v6 = VCRateControlCongestionLevel_BitrateRange(*(_DWORD *)(a1 + 1104));
  double result = 0.0;
  if (a2 == 2)
  {
    if (*(unsigned char *)(a1 + 5209))
    {
      uint64_t v9 = 968;
      if (a3) {
        uint64_t v9 = 928;
      }
      return *(double *)(a1 + v9 + 40 + 8 * v6);
    }
  }
  else if (a2 == 1)
  {
    if (*(unsigned char *)(a1 + 5208))
    {
      uint64_t v8 = 888;
      if (a3) {
        uint64_t v8 = 848;
      }
      return *(double *)(a1 + 40 + v8 + 8 * v6) * *(double *)(a1 + 5112);
    }
    else
    {
      return *(double *)(a1 + 136);
    }
  }
  return result;
}

BOOL VCRateControlAlgorithmStabilizedNOWRDPriv_DoRateControlWithNWStatistics(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCRateControlAlgorithmStabilizedNOWRDPriv_DoRateControlWithNWStatistics_cold_1();
    }
    return 0;
  }
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCRateControlAlgorithmStabilizedNOWRDPriv_DoRateControlWithNWStatistics_cold_2();
    }
    return 0;
  }
  if (!*(_DWORD *)(a1 + 1072)) {
    return 0;
  }
  if (*(_DWORD *)a2 != 11)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCRateControlAlgorithmStabilizedNOWRDPriv_DoRateControlWithNWStatistics_cold_3();
    }
    return 0;
  }
  BOOL v2 = *(unsigned char *)(a2 + 102) == 1 && *(unsigned char *)(a2 + 96) == 1;
  *(unsigned char *)(a1 + 25560) = v2;
  return 1;
}

void VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateAlgorithmWithBasebandStatistics(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2)
    {
      if (*(_DWORD *)a2 == 1)
      {
        *(void *)(a1 + 5264) = *(void *)(a2 + 8);
        *(_DWORD *)(a1 + 5288) = *(_DWORD *)(a2 + 36);
        *(_DWORD *)(a1 + 5292) = *(_DWORD *)(a2 + 28) + *(_DWORD *)(a2 + 24);
        *(void *)(a1 + 5296) = *(void *)(a2 + 64);
        *(void *)(a1 + 5272) = *(void *)(a2 + 80);
        *(void *)(a1 + 5280) = *(void *)(a2 + 88);
        *(unsigned char *)(a1 + 5313) = *(unsigned char *)(a2 + 16);
        unsigned int v10 = *(_DWORD *)(a1 + 5304);
        unsigned int v11 = *(_DWORD *)(a2 + 160);
        if (*(unsigned char *)(a1 + 5312) && v11 == 8) {
          VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Disabling baseband adaptation due to FR2 RATType", a3, a4, a5, a6, a7, a8, v15);
        }
        if (*(unsigned char *)(a1 + 411)) {
          BOOL v12 = v11 == 8;
        }
        else {
          BOOL v12 = 1;
        }
        char v13 = !v12;
        if (v11 != v10 && v11 <= 9 && ((1 << v11) & 0x3A0) != 0 && v10 <= 9 && ((1 << v10) & 0x3A0) != 0) {
          *(void *)(a1 + 25496) = *(void *)(a1 + 5264);
        }
        if (*(double *)(a1 + 5264) - *(double *)(a1 + 25496) < *(double *)(a1 + 664)) {
          char v13 = 0;
        }
        unsigned int v14 = *(_DWORD *)(a1 + 1112);
        if (v14 && (double)*(unsigned int *)(a2 + 40) / (double)v14 > *(double *)(a1 + 672))
        {
          char v13 = *(unsigned char *)(a1 + 5312);
          if (v13)
          {
            VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Disable baseband adaptation due to cross traffic. Average baseband throughput %d is much larger than our actual bitrate %d", a3, a4, a5, a6, a7, a8, *(_DWORD *)(a2 + 40));
            char v13 = 0;
          }
        }
        *(unsigned char *)(a1 + 5312) = v13;
        *(_DWORD *)(a1 + 5304) = *(_DWORD *)(a2 + 160);
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateAlgorithmWithBasebandStatistics_cold_3();
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateAlgorithmWithBasebandStatistics_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateAlgorithmWithBasebandStatistics_cold_1();
    }
  }
}

BOOL VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateInternalStatistics(uint64_t a1, uint64_t a2)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateInternalStatistics_cold_1();
    }
    return 0;
  }
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateInternalStatistics_cold_2();
    }
    return 0;
  }
  double v4 = *(double *)(a2 + 8);
  unsigned int v5 = *(unsigned __int16 *)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 80);
  uint64_t v7 = *(void *)(a2 + 52);
  uint64_t v8 = *(unsigned int *)(a2 + 60);
  *(_DWORD *)(a1 + 25532) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 5016) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 1200) = *(_DWORD *)(a2 + 32);
  *(unsigned char *)(a1 + 5384) = *(_DWORD *)(a2 + 36) != 0;
  *(_WORD *)(a1 + 5218) = *(_DWORD *)(a2 + 68);
  *(_WORD *)(a1 + 5366) = *(_DWORD *)(a2 + 28);
  unsigned int v9 = *(_DWORD *)(a1 + 5128);
  if (v9 <= *(_DWORD *)(a1 + 25532)) {
    unsigned int v9 = *(_DWORD *)(a1 + 25532);
  }
  *(_DWORD *)(a1 + 5128) = v9;
  *(_DWORD *)(a1 + 1112) = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(a1 + 5012) = *(_DWORD *)(a2 + 184);
  *(double *)(a1 + 5352) = v4;
  *(_DWORD *)(a1 + 5360) = *(_DWORD *)(a1 + 1104);
  if (!*(unsigned char *)(a1 + 1155))
  {
    BOOL result = 0;
    *(unsigned char *)(a1 + 1155) = 1;
    *(_WORD *)(a1 + 5364) = v5;
    return result;
  }
  unsigned int v10 = *(unsigned __int16 *)(a1 + 5364);
  if (v5 == v10 || (unsigned __int16)(v5 - v10) >= 0x7FFFu)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v85 = VRTraceErrorLogLevelToCSTR();
      uint64_t v86 = *MEMORY[0x1E4F47A50];
      BOOL v87 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
      BOOL result = 0;
      if (!v87) {
        return result;
      }
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = v85;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateInternalStatistics";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&unsigned char buf[24] = 648;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v5;
      _os_log_impl(&dword_1E1EA4000, v86, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Duplicated feedback or out-of-order feedback messages! timestamp:0x%04X", buf, 0x22u);
    }
    return 0;
  }
  if (v10 > v5) {
    ++*(_DWORD *)(a1 + 5372);
  }
  *(_WORD *)(a1 + 5364) = v5;
  *(double *)(a1 + 1128) = VCRateControlAlgorithmBasePriv_GetDoubleTimeFromTimestamp(v5, 0x400u, *(_DWORD *)(a1 + 5372));
  *(_DWORD *)(a1 + 5368) = VCRateControlAlgorithmBasePriv_GetTimestampFromMicroTime(v4);
  *(void *)(a1 + 2888) = v6;
  *(unsigned char *)(a1 + 5136) = v4 - VCRateControlMediaController_LastVideoRefreshFrameTime(*(void *)(a1 + 1048)) < *(double *)(a1 + 472);
  if (*(double *)(a1 + 25456) == 0.0) {
    *(void *)(a1 + 25456) = *(void *)(a1 + 1128);
  }
  int v11 = *(unsigned __int16 *)(a1 + 25532);
  uint64_t v12 = *(void *)(a2 + 88);
  *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)buf = v13;
  *(_OWORD *)&buf[16] = v13;
  *(_WORD *)buf = *(_WORD *)(a1 + 5218);
  *(void *)&uint8_t buf[4] = v7;
  *(void *)&buf[16] = v8;
  *(_DWORD *)&unsigned char buf[24] = v11;
  *(void *)&unsigned char buf[32] = a1 + 5016;
  uint64_t v90 = a1 + 5080;
  uint64_t v91 = a1 + 5024;
  uint64_t v92 = a1 + 5088;
  uint64_t v14 = *(void *)(a1 + 1048);
  if (v14) {
    VCRateControlMediaController_ComputePacketLoss(v14, (uint64_t)buf);
  }
  else {
    *(void *)(a1 + 5024) = v12;
  }
  if (*(double *)(a1 + 5024) > *(double *)(a1 + 752)) {
    *(void *)(a1 + 25552) = *(void *)(a1 + 1128);
  }
  DoubleTimeFromint Timestamp = *(double *)(a2 + 104);
  if (DoubleTimeFromTimestamp == 0.0)
  {
    unsigned int v16 = *(_DWORD *)(a1 + 5368);
    if (v16 < *(unsigned __int16 *)(a1 + 5218)) {
      *(_DWORD *)(a1 + 5368) = v16 + 0x10000;
    }
    unsigned int v17 = *(unsigned __int16 *)(a1 + 5366);
    if (!*(_WORD *)(a1 + 5366))
    {
      *(_WORD *)(a1 + 5218) = -1;
      goto LABEL_39;
    }
    unsigned int v18 = *(_DWORD *)(a1 + 5368) - *(unsigned __int16 *)(a1 + 5218);
    BOOL v19 = v18 >= v17;
    unsigned int v20 = v18 - v17;
    if (v20 != 0 && v19) {
      unsigned int v21 = v20;
    }
    else {
      unsigned int v21 = 1;
    }
    DoubleTimeFromint Timestamp = VCRateControlAlgorithmBasePriv_GetDoubleTimeFromTimestamp(v21, 0x400u, 0);
  }
  *(double *)(a1 + 5096) = DoubleTimeFromTimestamp;
  double v22 = *(double *)(a1 + 5104);
  if (v22 == 0.0) {
    double v23 = DoubleTimeFromTimestamp;
  }
  else {
    double v23 = DoubleTimeFromTimestamp * 0.1 + v22 * 0.9;
  }
  *(double *)(a1 + 5104) = v23;
  double v24 = *(double *)(a1 + 5112);
  if (v24 == 0.0)
  {
    double v25 = *(double *)(a1 + 5104);
  }
  else
  {
    double v26 = *(double *)(a1 + 25544);
    double v27 = *(double *)(a1 + 5104);
    double v28 = *(double *)(a1 + 504);
    *(double *)(a1 + 25544) = v27;
    if (v27 >= v24 && v26 - v27 <= v28) {
      goto LABEL_34;
    }
    double v25 = DoubleTimeFromTimestamp * dbl_1E25A0150[*(double *)(a1 + 5112) > DoubleTimeFromTimestamp]
        + *(double *)(a1 + 5112) * (1.0 - dbl_1E25A0150[*(double *)(a1 + 5112) > DoubleTimeFromTimestamp]);
  }
  *(double *)(a1 + 5112) = v25;
LABEL_34:
  double v29 = *(double *)(a1 + 5120);
  if (v29 <= *(double *)(a1 + 5104)) {
    double v29 = *(double *)(a1 + 5104);
  }
  *(double *)(a1 + 5120) = v29;
  if (*(double *)(a1 + 5104) > *(double *)(a1 + 744)) {
    *(void *)(a1 + 25552) = *(void *)(a1 + 1128);
  }
LABEL_39:
  VCRateControlAlgorithmBasePriv_CalculateCongestionMetrics(a1, *(double *)(a1 + 2888), *(double *)(a1 + 1128));
  if (*(unsigned char *)(a1 + 2881))
  {
    if (*(double *)(a1 + 25408) != 0.0) {
      goto LABEL_44;
    }
    uint64_t v36 = *(void *)(a1 + 1128);
  }
  else
  {
    uint64_t v36 = 0;
  }
  *(void *)(a1 + 25408) = v36;
LABEL_44:
  uint64_t v37 = *(void *)(a1 + 1048);
  if (v37)
  {
    VCRateControlMediaController_MediaQueueSettings(v37, (double *)(a1 + 5232), (double *)(a1 + 5240), (double *)(a1 + 5248), (double *)(a1 + 5256));
    double v38 = *(double *)(a1 + 5256);
    double v39 = *(double *)(a1 + 5240) + v38;
    *(_DWORD *)(a1 + 1112) = v39;
    int v40 = *(_DWORD *)(a1 + 1084);
    if (v40 <= *(_DWORD *)(a1 + 64)
      || v40 < *(_DWORD *)(a1 + 116)
      || (LODWORD(v39) = *(_DWORD *)(a1 + 1112),
          LODWORD(v38) = *(_DWORD *)(a1 + 1104),
          *(double *)(a1 + 288) * (double)*(unint64_t *)&v38 <= (double)*(unint64_t *)&v39))
    {
      if (*(unsigned char *)(a1 + 1153))
      {
        double v42 = *(double *)(a1 + 5224);
        if (v42 <= 0.0 || *(double *)(a1 + 1128) - v42 <= *(double *)(a1 + 296))
        {
          char v41 = 0;
        }
        else
        {
          VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable(a1);
          VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Sending rate was limited for a long time, stabilizing the bitrate", v43, v44, v45, v46, v47, v48, *(_DWORD *)(a1 + 1116));
          char v41 = 0;
        }
LABEL_58:
        *(unsigned char *)(a1 + 1153) = v41;
      }
    }
    else if (!VCRateControlMediaController_IsAudioOnly(*(void *)(a1 + 1048)) {
           || *(_DWORD *)(a1 + 1084) < *(_DWORD *)(a1 + 120))
    }
    {
      if (!*(unsigned char *)(a1 + 1153)) {
        *(void *)(a1 + 5224) = *(void *)(a1 + 1128);
      }
      char v41 = 1;
      goto LABEL_58;
    }
  }
  double v49 = *(double *)(a1 + 192);
  if (*(unsigned char *)(a1 + 415) && *(double *)(a1 + 4992) == 0.0)
  {
    double v50 = *(double *)(a1 + 5104);
    if (*(double *)(a1 + 456) * v50 < v49) {
      double v49 = *(double *)(a1 + 456) * v50;
    }
    if (*(double *)(a1 + 312) > v49) {
      double v49 = *(double *)(a1 + 312);
    }
  }
  __int16 v51 = *(_WORD *)(a1 + 5218);
  int v52 = *(unsigned __int16 *)(a1 + 5366);
  *(double *)(a1 + 25472) = v49;
  if (*(unsigned char *)(a1 + 5220))
  {
    if (*(_DWORD *)(a1 + 1072) != 1 && *(unsigned char *)(a1 + 25464) && *(double *)(a1 + 1128) - *(double *)(a1 + 25432) > v49) {
      *(unsigned char *)(a1 + 25464) = 0;
    }
  }
  else
  {
    uint64_t v53 = *(void *)(a1 + 1048);
    if (v53)
    {
      *(void *)buf = -1;
      unsigned int v88 = -1431655766;
      VCRateControlMediaController_MediaQueueRateChangeCounter(v53, &v88, buf);
      __int16 TimestampFromMicroTime = VCRateControlAlgorithmBasePriv_GetTimestampFromMicroTime(*(double *)buf);
      int v55 = *(_DWORD *)(a1 + 536);
      if (v55 == 2)
      {
        unsigned int v88 = *(_DWORD *)(a1 + 1116);
        __int16 TimestampFromMicroTime = v51;
      }
      else if (v55 == 1)
      {
        unsigned int v88 = *(_DWORD *)(a1 + 1116);
        __int16 TimestampFromMicroTime = VCRateControlAlgorithmBasePriv_GetTimestampFromMicroTime(*(double *)(a1 + 25440));
      }
      unsigned int v56 = *(_DWORD *)(a1 + 1116);
      if (*(_DWORD *)(a1 + 5376) != v56)
      {
        if (v88 >= v56
          && (*(unsigned char *)(a1 + 1152) = 1, v52)
          && (unsigned __int16)(v51 - TimestampFromMicroTime) <= 0x7FFEu)
        {
          *(void *)(a1 + 25432) = *(void *)(a1 + 1128);
          *(_DWORD *)(a1 + 5380) = 1;
          *(unsigned char *)(a1 + 25504) = 0;
          *(_DWORD *)(a1 + 5376) = *(_DWORD *)(a1 + 1116);
          VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] VCRC rate stabilized (TxTS %u >= %u FB). Collecting VCRC samples...", v30, v31, v32, v33, v34, v35, *(_DWORD *)(a1 + 1116));
        }
        else
        {
          *(_DWORD *)(a1 + 5380) = 0;
        }
      }
    }
    else if (!*(_DWORD *)(a1 + 5380))
    {
      *(void *)(a1 + 25432) = *(void *)(a1 + 1128);
      *(_DWORD *)(a1 + 5380) = 1;
      *(unsigned char *)(a1 + 25504) = 0;
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] VCRC rate stabilized since no mediaController. Collecting VCRC samples...", v30, v31, v32, v33, v34, v35, *(_DWORD *)(a1 + 1116));
    }
    if (*(unsigned char *)(a1 + 5221))
    {
      *(unsigned char *)(a1 + 5220) = 1;
      *(_DWORD *)(a1 + 5380) = 0;
    }
    unsigned int v57 = *(_DWORD *)(a1 + 5380);
    if (v57)
    {
      if (*(double *)(a1 + 1128) - *(double *)(a1 + 25432) >= *(double *)(a1 + 312) && v57 >= *(_DWORD *)(a1 + 348))
      {
        VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Collected %d VCRC samples (TxTS %u)", v30, v31, v32, v33, v34, v35, *(_DWORD *)(a1 + 1116));
        *(unsigned char *)(a1 + 5220) = 1;
        *(_DWORD *)(a1 + 5380) = 0;
      }
      else
      {
        *(_DWORD *)(a1 + 5380) = v57 + 1;
      }
    }
  }
  if (*(unsigned char *)(a1 + 1144)
    && *(unsigned char *)(a1 + 5220)
    && *(double *)(a1 + 1128) - *(double *)(a1 + 25432) > *(double *)(a1 + 304))
  {
    *(unsigned char *)(a1 + 1144) = 0;
  }
  VCRateControlAlgorithmBasePriv_CheckPaused(a1);
  if (*(_DWORD *)(a1 + 1084) <= *(_DWORD *)(a1 + 80) && *(double *)(a1 + 2888) >= *(double *)(a1 + 200))
  {
    *(unsigned char *)(a1 + 5222) = 1;
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Hit the abnormal bad network condition. Start the abnormal bad network adaptation with softMaxTier=%u. RTT=%f, owrd=%f", v58, v59, v60, v61, v62, v63, *(_DWORD *)(*(void *)(a1 + 48) + 4 * *(int *)(a1 + 68)));
  }
  if (*(double *)(a1 + 1128) - *(double *)(a1 + 25552) > 90.0)
  {
    if (*(unsigned char *)(a1 + 5222)) {
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "The abnormal bad network condition is gone. Remove the softMaxTier and current maxTier=%u. RTT=%f, owrd=%f", v58, v59, v60, v61, v62, v63, *(_DWORD *)(*(void *)(a1 + 48) + 4 * *(int *)(a1 + 60)));
    }
    *(unsigned char *)(a1 + 5222) = 0;
  }
  if (*(unsigned char *)(a1 + 410)) {
    VCRateControlAlgorithmBasePriv_CheckBandwidthOvershoot(a1, 1000 * *(_DWORD *)(a1 + 1200));
  }
  else {
    *(_DWORD *)(a1 + 1200) = 0;
  }
  VCRateControlAlgorithmBasePriv_UpdateLossEvent(a1);
  if (*(unsigned char *)(a1 + 428))
  {
    LODWORD(v64) = *(_DWORD *)(*(void *)(a1 + 48) + 4 * *(int *)(a1 + 60));
    unsigned int v65 = ((double)v64 * 0.5);
    double v66 = *(double *)(a1 + 5104);
    if (v66 > *(double *)(a1 + 432))
    {
      for (double i = *(double *)(a1 + 5112) + *(double *)(a1 + 5112); i > 0.0; double i = i + i)
      {
        if (v66 <= i) {
          break;
        }
        unsigned int v65 = ((double)v65 * 0.5);
      }
    }
    *(_DWORD *)(a1 + 25484) = v65;
    BOOL v68 = *(_DWORD *)(a1 + 1104) <= *(_DWORD *)(a1 + 25484);
  }
  else
  {
    BOOL v68 = 0;
  }
  int v69 = 0;
  unsigned __int16 v70 = 0;
  __int16 v71 = 0;
  *(unsigned char *)(a1 + 25480) = v68;
  double v72 = *(double *)(a1 + 864);
  double v73 = *(double *)(a1 + 872);
  if (v73 >= *(double *)(a1 + 856) * *(double *)(a1 + 5104)) {
    double v73 = *(double *)(a1 + 856) * *(double *)(a1 + 5104);
  }
  if (v72 <= v73) {
    double v72 = v73;
  }
  uint64_t v74 = a1 + 2928;
  int v75 = *(_DWORD *)(a1 + 4976) - 1;
  double v76 = 0.0;
  double v77 = 0.0;
  while (1)
  {
    uint64_t v78 = ((_BYTE)v75 + (_BYTE)v69) & 0x3F;
    double v79 = *(double *)(v74 + 32 * v78);
    if (!v69)
    {
      uint64_t v80 = v74 + 32 * v78;
      __int16 v71 = *(_WORD *)(v80 + 28);
      unsigned __int16 v70 = *(_WORD *)(v80 + 26);
      double v76 = *(double *)(v74 + 32 * (((_BYTE)v75 + (_BYTE)v69) & 0x3F));
    }
    if (v79 == 0.0) {
      break;
    }
    if (v76 - v79 <= v72 && v69-- != -63) {
      continue;
    }
    uint64_t v82 = v74 + 32 * v78;
    int v83 = *(unsigned __int16 *)(v82 + 26);
    if (v83 != v70) {
      double v77 = (double)(unsigned __int16)(v71 - *(_WORD *)(v82 + 28)) / (double)(unsigned __int16)(v70 - v83);
    }
    break;
  }
  *(double *)(a1 + 5168) = v77;
  return 1;
}

void VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateVCRateControlHistory(uint64_t a1)
{
  if (a1)
  {
    int v1 = *(_DWORD *)(a1 + 25392);
    if (v1)
    {
      if (v1 <= 499) {
        *(_DWORD *)(a1 + 25392) = v1 + 1;
      }
      *(_DWORD *)(a1 + 25396) = (*(_DWORD *)(a1 + 25396) + 1) % 500;
      uint64_t v2 = a1 + 5392 + 40 * *(int *)(a1 + 25396);
    }
    else
    {
      uint64_t v2 = a1 + 5392;
      *(_DWORD *)(a1 + 25392) = 1;
    }
    *(void *)uint64_t v2 = *(void *)(a1 + 2888);
    *(void *)(v2 + 24) = *(void *)(a1 + 5024);
    *(void *)(v2 + 8) = *(void *)(a1 + 5104);
    *(void *)(v2 + 16) = *(void *)(a1 + 5112);
    *(_DWORD *)(v2 + 32) = *(_DWORD *)(a1 + 1084);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateVCRateControlHistory_cold_1();
    }
  }
}

BOOL VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldFastRampUp(uint64_t a1)
{
  if (a1)
  {
    if ((!*(unsigned char *)(a1 + 5222) || *(_DWORD *)(a1 + 1084) < *(_DWORD *)(a1 + 68))
      && *(unsigned char *)(a1 + 415)
      && *(double *)(a1 + 4992) == 0.0
      && *(unsigned char *)(a1 + 5384))
    {
      int v1 = *(_DWORD *)(a1 + 1084);
      unsigned int v2 = *(_DWORD *)(a1 + 60);
      if ((int)v2 >= *(_DWORD *)(a1 + 464) + v1) {
        unsigned int v2 = *(_DWORD *)(a1 + 464) + v1;
      }
      if (*(_DWORD *)(*(void *)(a1 + 48) + 4 * v2) < (1000 * *(_DWORD *)(a1 + 1200)))
      {
        double v3 = *(double *)(a1 + 1128);
        double v4 = *(double *)(a1 + 472);
        if (v3 - *(double *)(a1 + 25552) > v4 && v1 <= *(_DWORD *)(a1 + 448))
        {
          double v5 = *(double *)(a1 + 304);
          if (v3 - *(double *)(a1 + 1176) > v5 && v3 - *(double *)(a1 + 1184) > v5 && v3 - *(double *)(a1 + 25424) > v4) {
            return 1;
          }
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldFastRampUp_cold_1();
  }
  return 0;
}

uint64_t VCRateControlAlgorithmStabilizedNOWRDPriv_RampDownTierDueToBaseband(uint64_t a1, double a2)
{
  if (a1)
  {
    *(unsigned char *)(a1 + 25504) = 1;
    VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable(a1);
    VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampDown(a1, a2);
    int IsAudioOnly = VCRateControlMediaController_IsAudioOnly(*(void *)(a1 + 1048));
    if (IsAudioOnly
      && *(_DWORD *)(a1 + 1084) < *(_DWORD *)(a1 + 76)
      && (double v11 = *(double *)(a1 + 584), a2 - *(double *)(a1 + 1184) < v11)
      && *(double *)(a1 + 1128) - *(double *)(a1 + 1176) < v11)
    {
      *(unsigned char *)(a1 + 25464) = 0;
      uint64_t v30 = 1084;
    }
    else
    {
      if (!*(unsigned char *)(a1 + 25464) && *(_DWORD *)(a1 + 1072) != 1 || *(_DWORD *)(a1 + 1084) <= *(_DWORD *)(a1 + 1088))
      {
        *(unsigned char *)(a1 + 25464) = 0;
        uint64_t v12 = *(int *)(a1 + 1084);
        uint64_t v13 = *(void *)(a1 + 48);
        unsigned int v14 = *(_DWORD *)(v13 + 4 * v12);
        int v15 = *(_DWORD *)(a1 + 740);
        double v16 = (double)v15;
        if (v15 <= 0) {
          double v16 = 1.0;
        }
        unsigned int v17 = *(_DWORD *)(a1 + 5288);
        if (v14 <= v17) {
          double v18 = (double)v17;
        }
        else {
          double v18 = (double)v14 - (double)(v14 - v17) / v16;
        }
        uint64_t v19 = *(int *)(a1 + 64);
        uint64_t v20 = *(int *)(a1 + 1084);
        while (*(_DWORD *)(v13 + 4 * v20) > v18)
        {
          if (((--v20 > v19) & ~IsAudioOnly) == 0)
          {
            if ((int)v20 <= (int)v19) {
              LODWORD(v20) = *(_DWORD *)(a1 + 64);
            }
            break;
          }
        }
        if ((int)v20 <= (int)v19) {
          uint64_t v21 = v19;
        }
        else {
          uint64_t v21 = v20;
        }
        if ((int)v12 <= (int)v21)
        {
          if (!VCRateControlMediaController_RampDownAudioFraction(*(void *)(a1 + 1048)))
          {
LABEL_27:
            *(_DWORD *)(a1 + 1088) = *(_DWORD *)(a1 + 1084);
            return v21;
          }
          int v22 = *(_DWORD *)(a1 + 1116);
          VCRateControlMediaController_AudioFractionTier(*(void *)(a1 + 1048));
          VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Congestion due to baseband!!! New audio fraction tier down to %u. Video stopped.", v23, v24, v25, v26, v27, v28, v22);
        }
        else
        {
          VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Congestion due to baseband!!! New bitrate down to %u [slow:%f]", v5, v6, v7, v8, v9, v10, *(_DWORD *)(a1 + 1116));
        }
        *(double *)(a1 + 1184) = a2;
        goto LABEL_27;
      }
      *(unsigned char *)(a1 + 25464) = 0;
      uint64_t v30 = 1088;
    }
    return *(unsigned int *)(a1 + v30);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlAlgorithmStabilizedNOWRDPriv_RampDownTierDueToBaseband_cold_1();
    }
  }
  return 0;
}

uint64_t VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUp(uint64_t a1)
{
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUp_cold_1();
      }
    }
    return 1;
  }
  BOOL v2 = *(unsigned char *)(a1 + 5220) != 0;
  if (!*(unsigned char *)(a1 + 5220)) {
    *(_DWORD *)(a1 + 1076) |= 2u;
  }
  if (*(unsigned char *)(a1 + 25464))
  {
    BOOL v2 = 0;
    *(_DWORD *)(a1 + 1076) |= 4u;
  }
  if (*(unsigned char *)(a1 + 1153))
  {
    BOOL v2 = 0;
    *(_DWORD *)(a1 + 1076) |= 8u;
  }
  if (VCRateControlAlgorithmBasePriv_RecentlyGoAboveRampUpBandwidth(a1))
  {
    BOOL v2 = 0;
    *(_DWORD *)(a1 + 1076) |= 0x200u;
  }
  if (!*(unsigned char *)(a1 + 2880))
  {
    BOOL v2 = 0;
    *(_DWORD *)(a1 + 1076) |= 0x100u;
  }
  if (*(unsigned char *)(a1 + 2881))
  {
    BOOL v2 = 0;
    *(_DWORD *)(a1 + 1076) |= 0x80u;
  }
  if (*(double *)(a1 + 2888) > *(double *)(a1 + 200))
  {
    BOOL v2 = 0;
    *(_DWORD *)(a1 + 1076) |= 0x10u;
  }
  if (*(double *)(a1 + 2896) > *(double *)(a1 + 208))
  {
    BOOL v2 = 0;
    *(_DWORD *)(a1 + 1076) |= 0x20u;
  }
  double v3 = *(double *)(a1 + 2912);
  if (v3 > _VCRateControlAlgorithmStabilizedNOWRD_CongestionLevelThreshold(a1, 1, 0))
  {
    BOOL v2 = 0;
    *(_DWORD *)(a1 + 1076) |= 0x40u;
  }
  if (*(unsigned char *)(a1 + 5312) && *(_DWORD *)(a1 + 1072) != 1 && !*(_DWORD *)(a1 + 5308))
  {
    BOOL v2 = 0;
    *(_DWORD *)(a1 + 1076) |= 0x400u;
  }
  int v11 = *(_DWORD *)(a1 + 1084);
  if (v11 >= *(_DWORD *)(a1 + 60))
  {
    BOOL v2 = 0;
    *(_DWORD *)(a1 + 1076) |= 0x1000u;
    int v11 = *(_DWORD *)(a1 + 1084);
  }
  if (v11 >= *(_DWORD *)(a1 + 448))
  {
    char v12 = *(unsigned char *)(a1 + 417);
    if (v12) {
      char v12 = *(unsigned char *)(a1 + 25560) != 0;
    }
    if (*(_DWORD *)(a1 + 1072) == 1)
    {
      if (*(_DWORD *)(a1 + 1200)) {
        goto LABEL_36;
      }
      goto LABEL_35;
    }
    if (*(double *)(a1 + 1128) - *(double *)(a1 + 25552) < *(double *)(a1 + 680)) {
      char v12 = 1;
    }
    if (v12)
    {
LABEL_35:
      BOOL v2 = 0;
      *(_DWORD *)(a1 + 1076) |= 0x4000u;
    }
  }
LABEL_36:
  if (*(unsigned char *)(a1 + 416))
  {
    int v13 = _VCRateControlAlgorithmStabilizedNOWRD_CheckNetworkSaturation(a1, *(double *)(a1 + 5104), *(double *)(a1 + 5112), *(double *)(a1 + 5024), *(double *)(a1 + 2888), v4, v5, v6, v7, v8, v9, v10);
    if (*(int *)(a1 + 496) >= 1)
    {
      int v14 = 0;
      int v15 = 500;
      do
      {
        double v16 = (double *)(a1 + 5392 + 40 * ((v15 + *(_DWORD *)(a1 + 25396)) % 500));
        v13 &= _VCRateControlAlgorithmStabilizedNOWRD_CheckNetworkSaturation(a1, v16[1], v16[2], v16[3], *v16, v4, v5, v6, v7, v8, v9, v10);
        ++v14;
        --v15;
      }
      while (v14 < *(_DWORD *)(a1 + 496));
    }
    if (v13)
    {
      BOOL v2 = 0;
      *(_DWORD *)(a1 + 1076) |= 0x2000u;
    }
  }
  if (VCRateControlAlgorithmBasePriv_ShouldBlockRampUpDueToLossEventThreshold(a1, v4, v5, v6, v7, v8, v9, v10))
  {
    BOOL v2 = 0;
    *(_DWORD *)(a1 + 1076) |= 0x4000u;
  }
  if (*(double *)(a1 + 5168) > 0.0)
  {
    BOOL v2 = 0;
    *(_DWORD *)(a1 + 1076) |= 0x8000u;
  }
  if (*(unsigned char *)(a1 + 5324) && *(_DWORD *)(a1 + 5316) && !*(unsigned char *)(a1 + 5314))
  {
    *(_DWORD *)(a1 + 1076) |= 0x10000u;
  }
  else if (v2)
  {
    *(void *)(a1 + 25456) = *(void *)(a1 + 1128);
    return 1;
  }
  double v18 = *(double *)(a1 + 232);
  if (v18 != 0.0)
  {
    double v19 = *(double *)(a1 + 25456);
    if (v19 != 0.0 && *(double *)(a1 + 1128) - v19 >= v18)
    {
      int v20 = *(_DWORD *)(a1 + 1076);
      if (v20 == 8 || v20 == 2048 || v20 == 1024)
      {
        *(_DWORD *)(a1 + 1076) = 0;
        return 1;
      }
    }
  }
  return 0;
}

uint64_t VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDown(uint64_t a1)
{
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDown_cold_1();
      }
    }
    return 0;
  }
  *(_DWORD *)(a1 + 25468) = *(_DWORD *)(a1 + 352);
  if (!*(unsigned char *)(a1 + 2880)) {
    return 0;
  }
  BOOL v9 = VCRateControlAlgorithmBasePriv_KeepOvershootingRampDownBandwidth(a1);
  if (v9)
  {
    *(_DWORD *)(a1 + 1080) |= 0x10u;
    *(_DWORD *)(a1 + 25468) = 0;
    *(void *)(a1 + 2912) = 0;
  }
  if (!*(unsigned char *)(a1 + 2872))
  {
    double v10 = *(double *)(a1 + 25408);
    if (v10 > 0.0 && *(double *)(a1 + 1128) - v10 > *(double *)(a1 + 160))
    {
      *(_DWORD *)(a1 + 1080) |= 1u;
      *(void *)(a1 + 25408) = 0;
      *(void *)(a1 + 2912) = 0;
      BOOL v9 = 1;
    }
  }
  if (*(unsigned char *)(a1 + 25504)) {
    goto LABEL_47;
  }
  if (*(unsigned char *)(a1 + 25464) || *(_DWORD *)(a1 + 1072) == 1)
  {
    int v11 = *(unsigned __int8 *)(a1 + 1153);
    uint64_t v12 = 88;
    if (!*(unsigned char *)(a1 + 1153)) {
      uint64_t v12 = 104;
    }
    double v13 = *(double *)(a1 + 40 + v12);
    double v14 = *(double *)(a1 + 2896);
    if (v14 > v13 && *(double *)(a1 + 25400) > v13 && *(double *)(a1 + 2904) > 0.0)
    {
      *(double *)(a1 + 25400) = v14;
      if (!v11)
      {
        *(_DWORD *)(a1 + 1080) |= 4u;
        *(void *)(a1 + 2912) = 0;
        BOOL v9 = 1;
        if (*(unsigned char *)(a1 + 25504)) {
          goto LABEL_47;
        }
      }
      goto LABEL_22;
    }
  }
  else
  {
    double v14 = 0.0;
  }
  *(double *)(a1 + 25400) = v14;
LABEL_22:
  double v15 = _VCRateControlAlgorithmStabilizedNOWRD_CongestionLevelThreshold(a1, 1, 1);
  if (*(double *)(a1 + 25400) > *(double *)(a1 + 2896)) {
    goto LABEL_37;
  }
  if ((*(unsigned char *)(a1 + 25464) || *(_DWORD *)(a1 + 1072) == 1) && !*(unsigned char *)(a1 + 1153)) {
    double v15 = *(double *)(a1 + 152);
  }
  if (*(unsigned char *)(a1 + 25480) && !*(unsigned char *)(a1 + 5208))
  {
    if (*(double *)(a1 + 2912) > v15) {
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Possible ramp down suppression with RTT:%.3f, minRTT:%.3f, bitrateThreshold:%u, suppressionFactor:%.3f, NOWRDAcc:%.3f", v3, v4, v5, v6, v7, v8, *(void *)(a1 + 5104));
    }
    double v15 = v15 * *(double *)(a1 + 440);
  }
  double v16 = *(double *)(a1 + 2912);
  if (v16 <= v15 || *(_DWORD *)(a1 + 1084) <= *(_DWORD *)(a1 + 64))
  {
LABEL_37:
    int v17 = 0;
  }
  else
  {
    *(double *)(a1 + 2912) = v16 - v15;
    if (*(double *)(a1 + 2912) < 0.0) {
      *(void *)(a1 + 2912) = 0;
    }
    int v17 = 1;
  }
  if (*(double *)(a1 + 2888) <= 0.0)
  {
    double v18 = *(double *)(a1 + 25448);
  }
  else
  {
    double v18 = *(double *)(a1 + 1128);
    *(double *)(a1 + 25448) = v18;
  }
  if (v18 > 0.0)
  {
    double v19 = *(double *)(a1 + 1128) - v18;
    if (v19 > 1.0)
    {
      *(void *)(a1 + 2912) = 0;
      *(void *)(a1 + 25448) = *(void *)(a1 + 1128);
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "OWRD has been 0 for %f seconds, reset NOWRDAcc", v3, v4, v5, v6, v7, v8, SLOBYTE(v19));
      if ((v17 & 1) == 0) {
        goto LABEL_47;
      }
      goto LABEL_46;
    }
  }
  if (v17)
  {
LABEL_46:
    *(_DWORD *)(a1 + 1080) |= 8u;
    BOOL v9 = 1;
  }
LABEL_47:
  int v20 = *(_DWORD *)(a1 + 108);
  if (v20 >= 1
    && *(_DWORD *)(a1 + 5016) > v20
    && *(_DWORD *)(a1 + 25532)
    && *(_DWORD *)(a1 + 1084) >= *(_DWORD *)(a1 + 112))
  {
    *(_DWORD *)(a1 + 1080) |= 0x100u;
    *(void *)(a1 + 2912) = 0;
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "BurstyLossRampDown RTT=%f, avgPLR=%f, PLRThreshold=%f, threshold=%d", v3, v4, v5, v6, v7, v8, *(void *)(a1 + 5104));
    BOOL v9 = 1;
    *(unsigned char *)(a1 + 5161) = 1;
  }
  if (VCRateControlAlgorithmBasePriv_ShouldRampDownDueToLossEvent(a1, v2, v3, v4, v5, v6, v7, v8))
  {
    *(_DWORD *)(a1 + 1080) |= 0x200u;
    *(void *)(a1 + 4984) = *(void *)(a1 + 1128);
    VCRateControlAlgorithmBasePriv_ResetLossEventBuffer(a1);
    *(void *)(a1 + 2912) = 0;
    BOOL v9 = 1;
  }
  double v21 = *(double *)(a1 + 5168);
  unsigned int v22 = *(_DWORD *)(a1 + 1104);
  unsigned int v23 = *(_DWORD *)(a1 + 848);
  if (v21 > *(double *)(a1 + 832) && v22 >= v23)
  {
    if (*(_DWORD *)(*(void *)(a1 + 48) + 4 * *(int *)(a1 + 60)) == v23) {
      *(_DWORD *)(a1 + 25488) = 1;
    }
  }
  else
  {
    BOOL v25 = v22 > *(_DWORD *)(a1 + 840);
    BOOL v27 = v21 > *(double *)(a1 + 824) && v22 > *(_DWORD *)(a1 + 844);
    if (v21 > *(double *)(a1 + 816) && !v27) {
      BOOL v27 = v25;
    }
    if (!v27) {
      goto LABEL_74;
    }
  }
  *(_DWORD *)(a1 + 1080) |= 0x800u;
  VCRateControlAlgorithmBasePriv_ResetLossEventBuffer(a1);
  *(void *)(a1 + 2912) = 0;
  BOOL v9 = 1;
LABEL_74:
  if (*(double *)(a1 + 5104) > *(double *)(a1 + 160) && *(_DWORD *)(a1 + 1084) > *(_DWORD *)(a1 + 72))
  {
    *(_DWORD *)(a1 + 1080) |= 0x400u;
    *(void *)(a1 + 2912) = 0;
    return 1;
  }
  return v9;
}

void VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateSmartBrakeOutputWithVCRCStatistics(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      float v2 = *(double *)(a1 + 1128);
      *(float *)(a1 + 25576) = v2;
      *(float *)(a1 + 25580) = (float)*(unsigned int *)(a1 + 1112);
      float v3 = *(double *)(a1 + 5104);
      *(float *)(a1 + 25588) = v3;
      float v4 = *(double *)(a1 + 2888);
      *(float *)(a1 + 25584) = v4;
      float v5 = *(double *)(a1 + 5080);
      *(float *)(a1 + 25592) = v5;
      float v6 = *(double *)(a1 + 5088);
      *(float *)(a1 + 25596) = v6;
      if (*(_DWORD *)(a1 + 880))
      {
        uint64_t v7 = a1 + 25576;
        uint64_t v8 = a1 + 5328;
        uint64_t v9 = *(void *)(a1 + 25568);
        VCRateControlSmartBrake_Query(v9, v7, v8);
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateSmartBrakeOutputWithVCRCStatistics_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateSmartBrakeOutputWithVCRCStatistics_cold_1();
    }
  }
}

uint64_t VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDownDueToBaseband(uint64_t a1)
{
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDownDueToBaseband_cold_1();
      }
    }
    return 0;
  }
  if (!*(unsigned char *)(a1 + 5312)) {
    return 0;
  }
  double v2 = *(double *)(a1 + 5264);
  float v3 = *(unsigned char **)(a1 + 1048);
  if (!*(unsigned char *)(a1 + 5313))
  {
    int v6 = VCRateControlMediaController_BasebandFlushCount(*(void *)(a1 + 1048));
    if (v6 > 0)
    {
      char v7 = v6;
      char v8 = [v3 basebandFlushCount];
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Still trying to flush baseband with flush counter %d. No further ramp up/down but possibly decrease audio fraction.", v9, v10, v11, v12, v13, v14, v8);
      if (v2 - VCRateControlMediaController_LastBasebandFlushCountChangeTime((uint64_t)v3) <= 3.0
        || *(double *)(a1 + 5296) >= 0.001)
      {
        goto LABEL_25;
      }
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Flush counter: %d stuck for more than %d seconds. And baseband shows TxRate:%d, TxDelay:%f. Reset the flush counter!", v15, v16, v17, v18, v19, v20, v7);
      VCRateControlMediaController_SetBasebandFlushCount((uint64_t)v3, 0);
LABEL_24:
      VCRateControlMediaController_SetLastBasebandFlushCountChangeTime((uint64_t)v3, v2);
LABEL_25:
      char v21 = [v3 basebandFlushCount];
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Try to ramp down audio fraction with [flushCount:%d, BBAvgRate:%d]", v22, v23, v24, v25, v26, v27, v21);
      VCRateControlMediaController_RampDownAudioFraction((uint64_t)v3);
      uint64_t v4 = 0;
      *(_DWORD *)(a1 + 1080) |= 0x80u;
      return v4;
    }
  }
  if (!*(_DWORD *)(a1 + 5288)) {
    goto LABEL_24;
  }
  if (!*(unsigned char *)(a1 + 1152) || [v3 basebandFlushCount]) {
    goto LABEL_7;
  }
  if (*(unsigned char *)(a1 + 25464) || *(_DWORD *)(a1 + 1072) == 1) {
    double v29 = (double *)(a1 + 552);
  }
  else {
    double v29 = (double *)(a1 + 544);
  }
  double v30 = *v29;
  if (VCRateControlMediaController_IsAudioOnly((uint64_t)v3))
  {
    if (*(double *)(a1 + 5272) > v30 || *(double *)(a1 + 5280) > *(double *)(a1 + 560))
    {
      double v31 = *(double *)(a1 + 5296);
      double v32 = *(double *)(a1 + 568);
      goto LABEL_40;
    }
LABEL_7:
    uint64_t v4 = 0;
    goto LABEL_8;
  }
  double VideoKeyFrameTime = VCRateControlMediaController_LastVideoKeyFrameTime(*(void *)(a1 + 1048));
  if (*(double *)(a1 + 5272) <= v30
    && *(double *)(a1 + 5280) <= *(double *)(a1 + 560)
    && !VCRateControlMediaController_IsVideoStopped(v3))
  {
    goto LABEL_7;
  }
  uint64_t v4 = 0;
  if (*(double *)(a1 + 5296) > *(double *)(a1 + 568) && VideoKeyFrameTime > 0.0)
  {
    double v31 = *(double *)(a1 + 5264) - VideoKeyFrameTime;
    double v32 = 0.5;
LABEL_40:
    if (v31 > v32)
    {
      *(_DWORD *)(a1 + 1080) |= 0x20u;
      *(void *)(a1 + 2912) = 0;
      uint64_t v4 = 1;
      goto LABEL_8;
    }
    goto LABEL_7;
  }
LABEL_8:
  if (([v3 isAudioOnly] & 1) == 0)
  {
    double v5 = VCRateControlMediaController_LastVideoKeyFrameTime(*(void *)(a1 + 1048));
    if ((!*(unsigned char *)(a1 + 736) || v5 > 0.0 && *(double *)(a1 + 5264) - v5 > 0.5)
      && *(double *)(a1 + 5296) > *(double *)(a1 + 576))
    {
      *(_DWORD *)(a1 + 1080) |= 0x40u;
      *(void *)(a1 + 2912) = 0;
      uint64_t v4 = 1;
    }
  }
  if (*(double *)(a1 + 5272) > *(double *)(a1 + 544)) {
    *(void *)(a1 + 25520) = *(void *)(a1 + 5264);
  }
  return v4;
}

uint64_t VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUpDueToBaseband(double *a1)
{
  if (a1)
  {
    if (a1[659] > a1[79] || a1[662] > a1[80] || a1[658] - a1[3190] < a1[81]) {
      return 0;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUpDueToBaseband_cold_1();
    }
  }
  return 1;
}

uint64_t VCRateControlAlgorithmStabilizedNOWRDPriv_BasebandAdditionalTiersForRampUp(uint64_t a1)
{
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCRateControlAlgorithmStabilizedNOWRDPriv_BasebandAdditionalTiersForRampUp_cold_1();
      }
    }
    return 0;
  }
  double v2 = *(unsigned char **)(a1 + 1048);
  if (!*(unsigned char *)(a1 + 5313) && VCRateControlMediaController_BasebandFlushCount(*(void *)(a1 + 1048)))
  {
    *(_DWORD *)(a1 + 1076) |= 0x800u;
    uint64_t v4 = *(void *)(a1 + 5152);
    if (v4)
    {
      char v5 = [v2 basebandFlushCount];
      VRLogfilePrintWithTimestamp(v4, "Still trying to flush baseband with flush counter: %d. Stop ramp-up!\n", v6, v7, v8, v9, v10, v11, v5);
    }
    return 0;
  }
  if (*(_DWORD *)(a1 + 5288))
  {
    if ([v2 isAudioOnly])
    {
      return 1;
    }
    else
    {
      uint64_t v3 = 1;
      if (!VCRateControlMediaController_IsVideoStopped(v2))
      {
        if ([v2 audioFractionTier]) {
          return 1;
        }
        else {
          return 2;
        }
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
    *(_DWORD *)(a1 + 1076) |= 0x800u;
  }
  return v3;
}

void _VCRateControlAlgorithmStabilizedNOWRD_ToggleSmartBrake(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  int v9 = *(_DWORD *)(a1 + 1072);
  if (v9 == 5) {
    uint64_t v10 = "Smart brake disengaged";
  }
  else {
    uint64_t v10 = "Smart brake engaged";
  }
  VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, v10, a3, a4, a5, a6, a7, a8, v21);
  int v11 = *(_DWORD *)(a1 + 880);
  if (v9 == 5)
  {
    if (v11 == 1) {
      VCRateControlMediaController_ResumeVideoBySmartBrake(*(unsigned __int8 **)(a1 + 1048));
    }
    *(double *)(a1 + 5184) = *(double *)(a1 + 1128) - *(double *)(a1 + 25600);
    *(_DWORD *)(a1 + 5192) = *(_DWORD *)(a1 + 5332);
    ++*(_DWORD *)(a1 + 5176);
    if (*(unsigned char *)(a1 + 25608))
    {
      *(_DWORD *)(a1 + 880) = 0;
      if (objc_opt_class() == a1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v14 = VRTraceErrorLogLevelToCSTR();
          uint64_t v15 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            int v21 = 136315650;
            uint64_t v22 = v14;
            __int16 v23 = 2080;
            uint64_t v24 = "_VCRateControlAlgorithmStabilizedNOWRD_ToggleSmartBrake";
            __int16 v25 = 1024;
            int v26 = 1410;
            uint64_t v16 = "VCRC [%s] %s:%d Smart brake disabled due to long engagement time.";
            uint64_t v17 = v15;
            uint32_t v18 = 28;
LABEL_22:
            _os_log_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)&v21, v18);
          }
        }
      }
      else
      {
        if (objc_opt_respondsToSelector()) {
          uint64_t v12 = (__CFString *)[(id)a1 performSelector:sel_logPrefix];
        }
        else {
          uint64_t v12 = &stru_1F3D3E450;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v19 = VRTraceErrorLogLevelToCSTR();
          uint64_t v20 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            int v21 = 136316162;
            uint64_t v22 = v19;
            __int16 v23 = 2080;
            uint64_t v24 = "_VCRateControlAlgorithmStabilizedNOWRD_ToggleSmartBrake";
            __int16 v25 = 1024;
            int v26 = 1410;
            __int16 v27 = 2112;
            uint64_t v28 = v12;
            __int16 v29 = 2048;
            uint64_t v30 = a1;
            uint64_t v16 = "VCRC [%s] %s:%d %@(%p) Smart brake disabled due to long engagement time.";
            uint64_t v17 = v20;
            uint32_t v18 = 48;
            goto LABEL_22;
          }
        }
      }
    }
  }
  else
  {
    if (v11 == 1) {
      VCRateControlMediaController_StopVideoBySmartBrake(*(unsigned __int8 **)(a1 + 1048));
    }
    int v13 = *(_DWORD *)(*(void *)(a1 + 48) + 4 * *(int *)(a1 + 1084));
    *(void *)(a1 + 25600) = *(void *)(a1 + 1128);
    *(_DWORD *)(a1 + 5200) = v13;
    *(_DWORD *)(a1 + 5196) = *(_DWORD *)(a1 + 5332);
  }
}

uint64_t _VCRateControlAlgorithmStabilizedNOWRD_SmartBrakeBitrateCongestionTierIndex(unsigned int *a1, double a2)
{
  double v2 = a1 + 10;
  unsigned int v3 = a1[220];
  if (v3 == 2) {
    return 10;
  }
  if (v3 != 3) {
    return a1[271];
  }
  LODWORD(a2) = a1[1333];
  unsigned int v4 = ((double)*(unint64_t *)&a2 * 0.5);
  uint64_t result = a1[15];
  uint64_t v6 = *((void *)v2 + 1);
  if (*(_DWORD *)(v6 + 4 * (int)result) > v4)
  {
    uint64_t v7 = (int)result;
    uint64_t v8 = (int)v2[6];
    if ((int)result >= (int)v8) {
      uint64_t result = v8;
    }
    else {
      uint64_t result = result;
    }
    uint64_t v9 = v6 - 4;
    while (v7 > v8)
    {
      uint64_t v10 = v7 - 1;
      unsigned int v11 = *(_DWORD *)(v9 + 4 * v7--);
      if (v11 <= v4) {
        return v10;
      }
    }
  }
  return result;
}

uint64_t _VCRateControlAlgorithmStabilizedNOWRD_RampDownTier(uint64_t a1)
{
  VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable(a1);
  VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampDown(a1, *(double *)(a1 + 1128));
  *(unsigned char *)(a1 + 25464) = 0;
  uint64_t v2 = *(unsigned int *)(a1 + 1084);
  if (!*(unsigned char *)(a1 + 418)
    || (int)v2 >= *(_DWORD *)(a1 + 80)
    || *(double *)(a1 + 1128) - *(double *)(a1 + 1176) >= *(double *)(a1 + 592))
  {
    int v3 = v2 - *(_DWORD *)(a1 + 96);
    if (*(_DWORD *)(a1 + 1072) == 1) {
      int v3 = v3 - *(_DWORD *)(a1 + 104) - (v2 == *(_DWORD *)(a1 + 56));
    }
    int v4 = *(_DWORD *)(a1 + 1080);
    if ((v4 & 0x200) != 0 && (*(double *)(a1 + 4992) > 0.0 || *(_DWORD *)(a1 + 1104) > *(_DWORD *)(a1 + 25484))) {
      --v3;
    }
    if ((v4 & 0x800) != 0)
    {
      int v5 = *(_DWORD *)(a1 + 25488);
      if (v5)
      {
        v3 -= v5;
        *(_DWORD *)(a1 + 25488) = 0;
        int v4 = *(_DWORD *)(a1 + 1080);
      }
    }
    if ((v4 & 0x400) != 0 && v3 >= *(_DWORD *)(a1 + 72)) {
      int v3 = *(_DWORD *)(a1 + 72);
    }
    if (*(unsigned char *)(a1 + 418) && v3 < *(_DWORD *)(a1 + 80)) {
      *(_DWORD *)(a1 + 25468) = 0;
    }
    unsigned int v6 = *(_DWORD *)(a1 + 25468);
    if (v6)
    {
      uint64_t v7 = (int *)(*(void *)(a1 + 48) + 4 * v3++);
      do
      {
        int v8 = *v7--;
        --v3;
      }
      while (*(_DWORD *)(a1 + 1104) - v8 < v6);
    }
    if (*(unsigned char *)(a1 + 421))
    {
      unsigned int v9 = *(_DWORD *)(a1 + 1112);
      uint64_t v10 = *(void *)(a1 + 48);
      if (v9 > *(_DWORD *)(v10 + 4 * *(int *)(a1 + 424)) && v3 >= 1)
      {
        while (*(_DWORD *)(v10 + 4 * v3) > v9)
        {
          BOOL v12 = __OFSUB__(v3--, 1);
          if ((v3 < 0) ^ v12 | (v3 == 0))
          {
            int v3 = 0;
            break;
          }
        }
      }
    }
    int v13 = *(_DWORD *)(a1 + 64);
    if (v3 <= v13) {
      uint64_t v2 = v13;
    }
    else {
      uint64_t v2 = v3;
    }
    if (VCRateControlMediaController_IsAudioOnly(*(void *)(a1 + 1048)))
    {
      int v20 = *(_DWORD *)(a1 + 76);
      if ((int)v2 <= v20) {
        uint64_t v2 = v20;
      }
      else {
        uint64_t v2 = v2;
      }
      if (*(_DWORD *)(a1 + 1084) <= (int)v2) {
        goto LABEL_43;
      }
    }
    else if (*(_DWORD *)(a1 + 1084) <= (int)v2)
    {
      VCRateControlMediaController_StopVideoByVCRateControl(*(unsigned __int8 **)(a1 + 1048));
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Congestion!!! Stop video!", v21, v22, v23, v24, v25, v26, v28);
      goto LABEL_43;
    }
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Congestion!!! New bitrate down to %u", v14, v15, v16, v17, v18, v19, *(_DWORD *)(a1 + 1116));
    *(void *)(a1 + 1176) = *(void *)(a1 + 1128);
LABEL_43:
    *(_DWORD *)(a1 + 1088) = *(_DWORD *)(a1 + 1084);
  }
  return v2;
}

uint64_t _VCRateControlAlgorithmStabilizedNOWRD_RampUpTier(uint64_t a1)
{
  VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable(a1);
  VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampUp(a1);
  uint64_t v2 = *(void **)(a1 + 1048);
  if (([v2 isAudioOnly] & 1) == 0
    && [v2 isVideoStoppedByVCRateControl]
    && *(_DWORD *)(a1 + 1084) == *(_DWORD *)(a1 + 64))
  {
    if ([v2 audioFractionTier])
    {
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Ramp Up!!! Ramp up audio fraction first. Video is still stopped!", v10, v11, v12, v13, v14, v15, v51);
      [v2 rampUpAudioFraction];
    }
    else
    {
      VCRateControlMediaController_ResumeVideo((unsigned __int8 *)v2);
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Ramp Up!!! Resume video first!", v44, v45, v46, v47, v48, v49, v51);
    }
    return *(unsigned int *)(a1 + 1084);
  }
  int v16 = VCRateControlAlgorithmBasePriv_AllowRampUpWithContinuousTargetBitrate(a1, v3, v4, v5, v6, v7, v8, v9);
  uint64_t v23 = *(unsigned int *)(a1 + 1084);
  if (!v16) {
    return v23;
  }
  unsigned int v24 = *(_DWORD *)(a1 + 92) + v23;
  if (*(_DWORD *)(a1 + 1072) != 1)
  {
    *(unsigned char *)(a1 + 25464) = 1;
    unsigned int v27 = *(_DWORD *)(a1 + 356);
    if (*(unsigned char *)(a1 + 410))
    {
      if (v27)
      {
        int v28 = *(_DWORD *)(a1 + 1200);
        if (v28)
        {
          uint64_t v29 = *(int *)(a1 + 240);
          if ((int)(v29 + v24) <= 53)
          {
            uint64_t v30 = *(void *)(a1 + 48);
            unsigned int v31 = 1000 * v28;
            double v32 = (int *)(v30 + 4 * (int)v24);
            uint64_t v33 = v29 + (int)v24;
            while (1)
            {
              int v34 = *v32++;
              if (v34 - *(_DWORD *)(a1 + 1104) >= v27 || *(_DWORD *)(v30 + 4 * (int)(v29 + v24)) >= v31) {
                break;
              }
              ++v24;
              if (++v33 >= 54)
              {
                unsigned int v24 = 54 - v29;
                goto LABEL_35;
              }
            }
          }
        }
      }
    }
    else
    {
      if (*(unsigned char *)(a1 + 411)) {
        BOOL v35 = v27 == 0;
      }
      else {
        BOOL v35 = 1;
      }
      if (!v35)
      {
        int v36 = *(_DWORD *)(a1 + 5308);
        int v37 = *(_DWORD *)(a1 + 1104);
        uint64_t v38 = *(void *)(a1 + 48);
        if (*(_DWORD *)(v38 + 4 * (int)v24) - v37 < v27 && v36 >= 1)
        {
          int v40 = (int *)(v38 + 4 * (int)v24 + 4);
          do
          {
            int v41 = *v40++;
            BOOL v42 = v41 - v37 < v27 && v36-- > 1;
            ++v24;
          }
          while (v42);
        }
      }
    }
    goto LABEL_35;
  }
  int v25 = *(_DWORD *)(a1 + 1200);
  if (v25)
  {
    unsigned int v26 = *(_DWORD *)(a1 + 100) + v24;
    if (*(_DWORD *)(*(void *)(a1 + 48) + 4 * (int)v26) >= (1000 * v25)) {
      goto LABEL_35;
    }
  }
  else
  {
    unsigned int v26 = *(_DWORD *)(a1 + 100) + v24;
  }
  unsigned int v24 = v26;
LABEL_35:
  *(_DWORD *)(a1 + 5308) = 0;
  *(_DWORD *)(a1 + 5000) = 0;
  unsigned int v43 = *(_DWORD *)(a1 + 60);
  if ((int)v24 >= (int)v43) {
    uint64_t v23 = v43;
  }
  else {
    uint64_t v23 = v24;
  }
  VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Ramp up bitrate to %u", v17, v18, v19, v20, v21, v22, *(_DWORD *)(a1 + 1116));
  *(_DWORD *)(a1 + 1088) = *(_DWORD *)(a1 + 1084);
  return v23;
}

BOOL _VCRateControlAlgorithmStabilizedNOWRD_IsBitrateOscillating(uint64_t a1, int a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 414)
    && (uint64_t v15 = 0, memset(v14, 0, sizeof(v14)), ++*((_DWORD *)v14 + a2), v2 = *(_DWORD *)(a1 + 25392), v2 >= 2))
  {
    int v3 = *(_DWORD *)(a1 + 25396) + 500;
    int v4 = 1;
    int v5 = *(_DWORD *)(a1 + 512);
    BOOL v6 = 1;
    int v7 = a2;
    int v8 = 1;
    int v9 = 1;
    int v10 = a2;
    do
    {
      int v11 = v10;
      int v10 = *(_DWORD *)(a1 + 5392 + 40 * (v3 % 500) + 32);
      if (v11 != v10)
      {
        int v12 = *((_DWORD *)v14 + v10);
        if (!v12) {
          ++v8;
        }
        *((_DWORD *)v14 + v10) = v12 + 1;
        ++v9;
      }
      if (v10 < v7) {
        int v7 = v10;
      }
      if (v9 > v5 && v8 < *(_DWORD *)(a1 + 516) && v7 == a2) {
        break;
      }
      BOOL v6 = v4 < v2 - 1;
      --v3;
      ++v4;
    }
    while (v2 != v4);
  }
  else
  {
    return 0;
  }
  return v6;
}

uint64_t _VCRateControlAlgorithmStabilizedNOWRD_GetRampUpFrozenDuration(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 1084);
  if (v1 >= *(_DWORD *)(result + 72) || v1 < *(_DWORD *)(result + 68) || !*(unsigned char *)(result + 5222))
  {
    if (*(unsigned char *)(result + 413)) {
      return arc4random_uniform(0xFFFFu);
    }
  }
  return result;
}

uint64_t _VCRateControlAlgorithmStabilizedNOWRD_CheckNetworkSaturation(uint64_t a1, double a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12 = 0;
  if (*(double *)(a1 + 480) * a3 < a2 && a4 > 0.0 && *(double *)(a1 + 488) * a3 < a5)
  {
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Possible network saturation detected with RTT:%f, minRTT:%f, PLR:%f, owrd:%f", a7, a8, a9, a10, a11, a12, SLOBYTE(a2));
    return 1;
  }
  return v12;
}

void VCVirtualAVCaptureInputPort_OnMediaSample(uint64_t a1, const void *a2, uint64_t a3)
{
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 48));
  BOOL v6 = *(void **)(a1 + 40);
  if ([v6 count])
  {
    uint64_t v7 = 0;
    unsigned int v8 = 1;
    do
    {
      VCVirtualAVCaptureConnection_OnMediaSample([v6 objectAtIndexedSubscript:v7], a2, a3);
      uint64_t v7 = v8;
    }
    while ([v6 count] > (unint64_t)v8++);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 48));
}

uint64_t VCMediaNegotiatorMediaType_StreamGroupIDFromMediaType(int a1)
{
  if ((a1 - 1) < 6) {
    return *(unsigned int *)&aRcimemacercsas[4 * (char)(a1 - 1)];
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v3 = VRTraceErrorLogLevelToCSTR();
    int v4 = *MEMORY[0x1E4F47A50];
    uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    VCMediaNegotiatorMediaType_StreamGroupIDFromMediaType_cold_1(v3, a1, v4);
  }
  return 0;
}

uint64_t VCMediaNegotiatorMediaType_MediaTypeFromStreamGroupID(int a1)
{
  if (a1 > 1835623281)
  {
    switch(a1)
    {
      case 1937339233:
        return 4;
      case 1935897189:
        return 3;
      case 1835623282:
        return 1;
    }
  }
  else
  {
    switch(a1)
    {
      case 1650745716:
        return 6;
      case 1667329381:
        return 2;
      case 1718909044:
        return 5;
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v3 = VRTraceErrorLogLevelToCSTR();
    int v4 = *MEMORY[0x1E4F47A50];
    uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    VCMediaNegotiatorMediaType_MediaTypeFromStreamGroupID_cold_1(v3, a1, v4);
  }
  return 0;
}

uint64_t VCMediaNegotiationBlobV2SettingsU1ReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  int v4 = (int *)MEMORY[0x1E4F940E0];
  int v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        uint64_t v23 = objc_alloc_init(VCMediaNegotiationBlobV2StreamGroupEncodeDecodeFeatures);
        [(id)a1 addEncodeDecodeFeatures:v23];

        if (!PBReaderPlaceMark()
          || (VCMediaNegotiationBlobV2StreamGroupEncodeDecodeFeaturesReadFrom((uint64_t)v23, a2) & 1) == 0)
        {
          return 0;
        }
        PBReaderRecallMark();
      }
      else if ((v10 >> 3) == 1)
      {
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0;
        *(unsigned char *)(a1 + 20) |= 1u;
        while (1)
        {
          uint64_t v20 = *v3;
          unint64_t v21 = *(void *)(a2 + v20);
          if (v21 == -1 || v21 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v22 = *(unsigned char *)(*(void *)(a2 + *v7) + v21);
          *(void *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0) {
            goto LABEL_33;
          }
          v17 += 7;
          BOOL v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_35;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_33:
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v19) = 0;
        }
LABEL_35:
        *(_DWORD *)(a1 + 16) = v19;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void _VCMediaRecorderLocal_PushAudioSamples(uint64_t a1, uint64_t a2)
{
  int v4 = (VCAudioBufferList_GetHostTime(a2) * 1000.0);

  VCMediaRecorder_AddLocalAudioSampleBuffer(a1, a2, v4);
}

void _VCSessionParticipantLocal_ProcessAudioSamples(uint64_t a1, unsigned int *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (*(unsigned char *)(a1 + 408))
    {
      if (*(unsigned char *)(a1 + 560) && *(unsigned char *)(a1 + 984))
      {
        char Priority = 0;
        int VoiceActivity = 0;
LABEL_27:
        if (*(unsigned char *)(a1 + 1088)) {
          VCAudioPowerSpectrumSource_PushAudioSamples(*(id **)(a1 + 912), (uint64_t)a2);
        }
        uint64_t v12 = *(void *)(a1 + 520);
        if (v12 && *(unsigned char *)(a1 + 408)) {
          VCAudioCaptionsCoordinator_PushAudioSamples(v12, *(void *)(a1 + 1104), a2);
        }
        pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 592));
        VCMediaRecorder_AddLocalAudioSampleBuffer(*(void *)(a1 + 512), (uint64_t)a2, *(_DWORD *)(a1 + 576));
        *(_DWORD *)(a1 + 576) = VCAudioBufferList_GetTimestamp((uint64_t)a2);
        *(double *)(a1 + 584) = VCAudioBufferList_GetHostTime((uint64_t)a2);
        pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 592));
        if (!*(unsigned char *)(a1 + 408))
        {
          VCAudioBufferList_SetPriority((uint64_t)a2, Priority);
          VCAudioBufferList_SetVoiceActivity((uint64_t)a2, VoiceActivity);
        }
        double HostTime = VCAudioBufferList_GetHostTime((uint64_t)a2);
        if (HostTime - *(double *)(a1 + 1032) > 0.5)
        {
          *(double *)(a1 + 1032) = HostTime;
          uint64_t BoolValueForKeyQuiet = VCDefaults_GetBoolValueForKeyQuiet(@"spatialAudioDisabled", 0);
          if (BoolValueForKeyQuiet != [*(id *)(a1 + 392) spatialAudioDisabled]) {
            [*(id *)(a1 + 392) setSpatialAudioDisabled:BoolValueForKeyQuiet];
          }
        }
        return;
      }
    }
    else if (*(unsigned char *)(a1 + 560))
    {
      char Priority = VCAudioBufferList_GetPriority((uint64_t)a2);
      int VoiceActivity = VCAudioBufferList_GetVoiceActivity((uint64_t)a2);
      int v6 = VCAudioBufferList_GetPriority((uint64_t)a2);
      if (!*(unsigned char *)(a1 + 856)) {
        goto LABEL_19;
      }
      double v7 = micro();
      if (v7 - *(double *)(a1 + 848) > 1.0)
      {
        *(unsigned char *)(a1 + 840) = [+[VCDefaults sharedInstance] forceAudioPriorityValue];
        *(double *)(a1 + 848) = v7;
      }
      int v8 = *(unsigned __int8 *)(a1 + 840);
      if (*(unsigned char *)(a1 + 840))
      {
        VCAudioBufferList_SetPriority((uint64_t)a2, *(unsigned char *)(a1 + 840));
        int v6 = v8;
      }
      else
      {
LABEL_19:
        if (!v6)
        {
          if (*(unsigned char *)(a1 + 1072)) {
            int v6 = VCVoiceDetector_ProcessSampleBuffer(*(void **)(a1 + 880), (uint64_t)a2, *(unsigned char *)(a1 + 372));
          }
          else {
            int v6 = 0;
          }
        }
      }
      if (v6 != *(unsigned __int8 *)(a1 + 792))
      {
        *(unsigned char *)(a1 + 792) = v6;
        *(void *)int v15 = MEMORY[0x1E4F143A8];
        *(void *)&v15[8] = 3221225472;
        *(void *)&v15[16] = __VCSessionParticipantLocal_UpdateAudioPriorityWithSampleBuffer_block_invoke;
        uint64_t v16 = &unk_1E6DB6978;
        uint64_t v17 = a1;
        char v18 = v6;
        [(id)a1 callDelegateWithBlock:v15];
      }
      goto LABEL_27;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v9 = VRTraceErrorLogLevelToCSTR();
      unint64_t v10 = *MEMORY[0x1E4F47A50];
      uint64_t v11 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int v15 = 136315650;
          *(void *)&v15[4] = v9;
          *(_WORD *)&v15[12] = 2080;
          *(void *)&v15[14] = "_VCSessionParticipantLocal_ProcessAudioSamples";
          *(_WORD *)&v15[22] = 1024;
          LODWORD(v16) = 3983;
          _os_log_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d audio no-op no MKM", v15, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        _VCSessionParticipantLocal_ProcessAudioSamples_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCSessionParticipantLocal_ProcessAudioSamples_cold_1();
    }
  }
}

uint64_t VCSessionPartipantLocal_OnVideoFrame(uint64_t a1, opaqueCMSampleBuffer *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  int v7 = *(unsigned __int8 *)(a1 + 560);
  if (*(unsigned char *)(a1 + 408))
  {
    if (!*(unsigned char *)(a1 + 560)) {
      goto LABEL_6;
    }
    int v7 = *(unsigned __int8 *)(a1 + 984);
  }
  if (v7)
  {
    pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 592));
    int v8 = *(_DWORD *)(a1 + 576);
    pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 592));
    VCMediaRecorder_AddLocalVideoSampleBuffer(*(void *)(a1 + 512), a2, *(unsigned char *)(a4 + 16), v8);
    return 1;
  }
LABEL_6:
  if (objc_opt_class() == a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
      return 1;
    }
    uint64_t v10 = VRTraceErrorLogLevelToCSTR();
    uint64_t v11 = *MEMORY[0x1E4F47A50];
    uint64_t v12 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        return 1;
      }
      int v20 = 136315650;
      uint64_t v21 = v10;
      __int16 v22 = 2080;
      uint64_t v23 = "VCSessionPartipantLocal_OnVideoFrame";
      __int16 v24 = 1024;
      int v25 = 3841;
      char v13 = " [%s] %s:%d video no-op no MKM";
      BOOL v14 = v11;
      uint32_t v15 = 28;
LABEL_18:
      _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v20, v15);
      return 1;
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
      VCSessionPartipantLocal_OnVideoFrame_cold_1();
    }
  }
  else
  {
    if (objc_opt_respondsToSelector()) {
      uint64_t v9 = (__CFString *)[(id)a1 performSelector:sel_logPrefix];
    }
    else {
      uint64_t v9 = &stru_1F3D3E450;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v16 = VRTraceErrorLogLevelToCSTR();
      uint64_t v17 = *MEMORY[0x1E4F47A50];
      char v18 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
          return 1;
        }
        int v20 = 136316162;
        uint64_t v21 = v16;
        __int16 v22 = 2080;
        uint64_t v23 = "VCSessionPartipantLocal_OnVideoFrame";
        __int16 v24 = 1024;
        int v25 = 3841;
        __int16 v26 = 2112;
        unsigned int v27 = v9;
        __int16 v28 = 2048;
        uint64_t v29 = a1;
        char v13 = " [%s] %s:%d %@(%p) video no-op no MKM";
        BOOL v14 = v17;
        uint32_t v15 = 48;
        goto LABEL_18;
      }
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        int v20 = 136316162;
        uint64_t v21 = v16;
        __int16 v22 = 2080;
        uint64_t v23 = "VCSessionPartipantLocal_OnVideoFrame";
        __int16 v24 = 1024;
        int v25 = 3841;
        __int16 v26 = 2112;
        unsigned int v27 = v9;
        __int16 v28 = 2048;
        uint64_t v29 = a1;
        _os_log_debug_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEBUG, " [%s] %s:%d %@(%p) video no-op no MKM", (uint8_t *)&v20, 0x30u);
      }
    }
  }
  return 1;
}

char *OUTLINED_FUNCTION_14_1@<X0>(int a1@<W1>, uint64_t a2@<X8>)
{
  *(void *)(v2 - 24) = a2;
  return FourccToCStr(a1);
}

uint64_t OUTLINED_FUNCTION_16_2@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)(v2 - 24) = a2;
  return [a1 streamGroupID];
}

uint64_t VCPerfTimingUtilsSetStartForKeyOnceWithTime(void *a1, uint64_t a2, double a3)
{
  uint64_t result = [a1 hasKey:a2];
  if ((result & 1) == 0)
  {
    return [a1 setStartTime:a2 forKey:a3];
  }
  return result;
}

uint64_t VCPerfTimingUtilsSetStopForKeyOnceWithTime(void *a1, uint64_t a2, double a3)
{
  if (([a1 hasKey:a2] & 1) == 0) {
    [a1 setStartTime:a2 forKey:a3];
  }
  uint64_t result = [a1 isValidTimingForKey:a2];
  if ((result & 1) == 0)
  {
    return [a1 setStopTime:a2 forKey:a3];
  }
  return result;
}

void VCPerfTimingUtilsLog(void *a1, __n128 a2)
{
  uint64_t v3 = 0;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  int v4 = (os_log_t *)MEMORY[0x1E4F47A50];
  a2.n128_u64[0] = 136316162;
  __n128 v8 = a2;
  do
  {
    if (objc_msgSend(a1, "hasKey:", v3, *(_OWORD *)&v8)
      && [a1 isValidTimingForKey:v3]
      && (int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      int v6 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        [a1 timingForKey:v3];
        *(_DWORD *)buf = v8.n128_u32[0];
        uint64_t v10 = v5;
        __int16 v11 = 2080;
        uint64_t v12 = "VCPerfTimingUtilsLog";
        __int16 v13 = 1024;
        int v14 = 43;
        __int16 v15 = 1024;
        int v16 = v3;
        __int16 v17 = 1024;
        int v18 = (int)(v7 * 1000.0);
        _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d sendTimings:Key = %d, CMTimeValue value = %d", buf, 0x28u);
      }
    }
    uint64_t v3 = (v3 + 1);
  }
  while (v3 != 24);
}

void VCPerfTimingUtilsReport(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, __n128 a5)
{
  VCPerfTimingUtilsLog(a1, a5);
  if (a2)
  {
    MEMORY[0x1F4105B00](a2, a3, a1, a4);
  }
}

BOOL VCSilencePredictor_Initialize(uint64_t a1)
{
  if (a1)
  {
    *(_DWORD *)(a1 + 96) = -1;
    *(_DWORD *)(a1 + 24) = -1;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCSilencePredictor_Initialize_cold_1();
    }
  }
  return a1 != 0;
}

void VCSilencePredictor_Reset(uint64_t a1)
{
  if (a1)
  {
    *(_OWORD *)(a1 + 88) = 0u;
    *(void *)(a1 + 152) = 0;
    *(_OWORD *)(a1 + 136) = 0u;
    *(_OWORD *)(a1 + 120) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_DWORD *)(a1 + 96) = -1;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(void *)(a1 + 80) = 0;
    *(_DWORD *)(a1 + 24) = -1;
    *(unsigned char *)a1 = 0;
    *(void *)(a1 + 8) = 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCSilencePredictor_Reset_cold_1();
    }
  }
}

void VCSilencePredictor_AddFrame(unsigned __int8 *a1, int a2, unsigned int a3, int a4)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2 != 104 || !a3) {
      goto LABEL_27;
    }
    uint64_t v5 = a1 + 16;
    uint64_t v6 = 88;
    if (a4) {
      uint64_t v6 = 16;
    }
    else {
      uint64_t v5 = a1 + 88;
    }
    double v7 = 1.85;
    if (a4) {
      double v7 = 1.15;
    }
    unsigned int v8 = *((_DWORD *)v5 + 2);
    unsigned int v9 = *((_DWORD *)v5 + 3);
    if (v8 >= a3) {
      unsigned int v10 = a3;
    }
    else {
      unsigned int v10 = *((_DWORD *)v5 + 2);
    }
    double v11 = (double)v10;
    if (v9 <= a3) {
      unsigned int v12 = a3;
    }
    else {
      unsigned int v12 = *((_DWORD *)v5 + 3);
    }
    double v13 = *(double *)&a1[v6];
    if (!v8) {
      double v11 = (double)a3;
    }
    unsigned int v14 = v11;
    double v15 = v9 ? (double)v12 : (double)a3;
    *((_DWORD *)v5 + 2) = v14;
    *((_DWORD *)v5 + 3) = v15;
    double v16 = v13 == 0.0 ? (double)a3 : v13 * 0.98 + (double)a3 * 0.02;
    *(double *)&a1[v6] = v16;
    unint64_t v17 = *((void *)v5 + 2) + a3;
    *((void *)v5 + 2) = v17;
    unsigned int v18 = *((_DWORD *)v5 + 16) + 1;
    *((_DWORD *)v5 + 16) = v18;
    double v19 = (double)v17 / (double)v18;
    unint64_t v20 = *((void *)v5 + 7) + (unint64_t)(((double)a3 - v19) * ((double)a3 - v19));
    *((void *)v5 + 7) = v20;
    double v21 = sqrt((double)v20 / (double)v18);
    *((double *)v5 + 3) = v19;
    *((double *)v5 + 4) = v21;
    *((double *)v5 + 5) = v19 - v7 * v21;
    *((double *)v5 + 6) = v19 + v7 * v21;
    if (*((_DWORD *)a1 + 38) < 0x32u) {
      goto LABEL_27;
    }
    if (*((_DWORD *)a1 + 20) > 0x31u)
    {
      double v22 = *((double *)a1 + 11);
      double v23 = *((double *)a1 + 2);
      double v24 = v23 * 1.15;
      BOOL v25 = v23 <= *((double *)a1 + 16) && v22 >= *((double *)a1 + 8);
      int v26 = v22 >= v24 && v25;
      if (*a1 != v26 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v27 = VRTraceErrorLogLevelToCSTR();
        __int16 v28 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v29 = *((_DWORD *)a1 + 38);
          uint64_t v30 = *((void *)a1 + 11);
          unsigned int v31 = "OFF";
          uint64_t v32 = *((void *)a1 + 16);
          int v33 = *((_DWORD *)a1 + 20);
          if (v26) {
            unsigned int v31 = "ON";
          }
          uint64_t v34 = *((void *)a1 + 2);
          uint64_t v35 = *((void *)a1 + 8);
          int v36 = 136317954;
          uint64_t v37 = v27;
          __int16 v38 = 2080;
          double v39 = "VCSilencePredictor_AddFrame";
          __int16 v40 = 1024;
          int v41 = 102;
          __int16 v42 = 2080;
          unsigned int v43 = v31;
          __int16 v44 = 1024;
          BOOL v45 = v22 >= v24;
          __int16 v46 = 1024;
          BOOL v47 = v25;
          __int16 v48 = 1024;
          int v49 = v29;
          __int16 v50 = 2048;
          uint64_t v51 = v30;
          __int16 v52 = 2048;
          uint64_t v53 = v32;
          __int16 v54 = 1024;
          int v55 = v33;
          __int16 v56 = 2048;
          uint64_t v57 = v34;
          __int16 v58 = 2048;
          uint64_t v59 = v35;
          _os_log_impl(&dword_1E1EA4000, v28, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Silence prediction=%s. sufficientDeltaBetweenAverages=%d, distributionsAreNotOverlapped=%d, audioFrameCount=%u audioAvgFrameSize=%f audioMinFrameSizeLimit=%f, silenceFrameCount=%u silenceAvgFrameSize=%f silenceMaxFrameSizeLimit=%f,", (uint8_t *)&v36, 0x66u);
        }
      }
      *a1 = v26;
    }
    else
    {
LABEL_27:
      *a1 = 0;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCSilencePredictor_AddFrame_cold_1();
    }
  }
}

BOOL VCSilencePredictor_PredictSilence(uint64_t a1, int a2, unsigned int a3)
{
  if (a1)
  {
    uint64_t v3 = 0;
    if (a2 == 104 && a3 && *(unsigned char *)a1)
    {
      double v4 = *(double *)(a1 + 8);
      if (v4 == 0.0) {
        double v5 = (double)a3;
      }
      else {
        double v5 = (double)a3 * 0.3333 + v4 * 0.6667;
      }
      *(double *)(a1 + 8) = v5;
      return v5 <= *(double *)(a1 + 64) && v5 < *(double *)(a1 + 128);
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCSilencePredictor_PredictSilence_cold_1();
      }
    }
    return 0;
  }
  return v3;
}

uint64_t VCPacketFilterRTCPCreate(uint64_t a1, void *a2)
{
  uint64_t ClassID = VCPacketFilterGetClassID();

  return VCFBOUtils_ObjectCreate(a1, a2, (uint64_t)&kVCPacketFilterRTCPVTable, ClassID, 52);
}

BOOL VCPacketFilterIsOfKindRTCP(uint64_t a1)
{
  return VCFBOUtils_IsKindOfClass(a1, (uint64_t)&kVCPacketFilterRTCPVTable);
}

void _VCPacketFilterRTCPFinalize(uint64_t a1)
{
  if (a1)
  {
    uint64_t DerivedStorage = (const void **)CMBaseObjectGetDerivedStorage();
    if (DerivedStorage)
    {
      uint64_t v2 = DerivedStorage;
      uint64_t v3 = *DerivedStorage;
      if (v3) {
        CFRelease(v3);
      }
      double v4 = v2[1];
      if (v4)
      {
        CFRelease(v4);
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCPacketFilterRTCPFinalize_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCPacketFilterRTCPFinalize_cold_1();
    }
  }
}

uint64_t _VCPacketFilterRTCPCopyProperty(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCPacketFilterRTCPCopyProperty_cold_1();
      }
    }
    return 4294954516;
  }
  if (!a2 || !a4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v13 = VRTraceErrorLogLevelToCSTR();
      unsigned int v14 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        int v16 = 136316162;
        uint64_t v17 = v13;
        __int16 v18 = 2080;
        double v19 = "_VCPacketFilterRTCPCopyProperty";
        __int16 v20 = 1024;
        int v21 = 61;
        __int16 v22 = 2112;
        double v23 = a2;
        __int16 v24 = 2112;
        BOOL v25 = a4;
        _os_log_error_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_ERROR, " [%s] %s:%d Property name '%@' and property value out '%@' must not be NULL", (uint8_t *)&v16, 0x30u);
      }
    }
    return 4294954516;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, @"RTCPRemoteSSRC"))
  {
    double v7 = *(const void **)DerivedStorage;
    if (!*(void *)DerivedStorage)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 6) {
        return 4294954513;
      }
      uint64_t v8 = VRTraceErrorLogLevelToCSTR();
      unsigned int v9 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        return 4294954513;
      }
      int v16 = 136315650;
      uint64_t v17 = v8;
      __int16 v18 = 2080;
      double v19 = "_VCPacketFilterRTCPCopyProperty";
      __int16 v20 = 1024;
      int v21 = 66;
      unsigned int v10 = " [%s] %s:%d kVCPacketFilterRTCPProperty_RemoteSSRC not set";
LABEL_26:
      _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v16, 0x1Cu);
      return 4294954513;
    }
    goto LABEL_11;
  }
  if (CFEqual(a2, @"RTCPLocalSSRC"))
  {
    double v7 = *(const void **)(DerivedStorage + 8);
    if (!v7)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 6) {
        return 4294954513;
      }
      uint64_t v15 = VRTraceErrorLogLevelToCSTR();
      unsigned int v9 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        return 4294954513;
      }
      int v16 = 136315650;
      uint64_t v17 = v15;
      __int16 v18 = 2080;
      double v19 = "_VCPacketFilterRTCPCopyProperty";
      __int16 v20 = 1024;
      int v21 = 70;
      unsigned int v10 = " [%s] %s:%d kVCPacketFilterRTCPProperty_LocalSSRC not set";
      goto LABEL_26;
    }
LABEL_11:
    CFTypeRef v11 = CFRetain(v7);
    uint64_t result = 0;
    *a4 = v11;
    return result;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCPacketFilterRTCPCopyProperty_cold_2();
    }
  }
  return 4294954512;
}

uint64_t _VCPacketFilterRTCPSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCPacketFilterRTCPSetProperty_cold_1();
      }
    }
    return 4294954516;
  }
  if (!a2 || !a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v8 = VRTraceErrorLogLevelToCSTR();
      unsigned int v9 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        int v10 = 136316162;
        uint64_t v11 = v8;
        __int16 v12 = 2080;
        uint64_t v13 = "_VCPacketFilterRTCPSetProperty";
        __int16 v14 = 1024;
        int v15 = 85;
        __int16 v16 = 2112;
        uint64_t v17 = a2;
        __int16 v18 = 2112;
        double v19 = a3;
        _os_log_error_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_ERROR, " [%s] %s:%d Property name '%@' and property value out '%@' must not be NULL", (uint8_t *)&v10, 0x30u);
      }
    }
    return 4294954516;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, @"RTCPRemoteSSRC"))
  {
    uint64_t v6 = *(const void **)DerivedStorage;
    *(void *)uint64_t DerivedStorage = a3;
LABEL_8:
    CFRetain(a3);
    if (v6) {
      CFRelease(v6);
    }
    return 0;
  }
  if (CFEqual(a2, @"RTCPLocalSSRC"))
  {
    uint64_t v6 = *(const void **)(DerivedStorage + 8);
    *(void *)(DerivedStorage + 8) = a3;
    goto LABEL_8;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCPacketFilterRTCPSetProperty_cold_2();
    }
  }
  return 4294954512;
}

uint64_t VCAudioIO_PushAudioSamples(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v6 = (id *)(a1 + 72);
  uint64_t result = memcmp(&_VCAudioIO_EmptyContext, (const void *)(a1 + 72), 0x38uLL);
  if (result && (!*(unsigned char *)(a1 + 8) || *(void *)a1))
  {
    ++*(_DWORD *)(a1 + 68);
    Sampleint32_t Count = VCAudioBufferList_GetSampleCount(*(void *)(a1 + 16));
    if (*(unsigned char *)(a1 + 65) || *(unsigned char *)(a1 + 8) || *(unsigned char *)(a1 + 9) || (unsigned int v9 = (unsigned int *)a3, SampleCount)) {
      unsigned int v9 = *(unsigned int **)(a1 + 16);
    }
    double HostTime = VCAudioBufferList_GetHostTime(a3);
    int Timestamp = VCAudioBufferList_GetTimestamp(a3);
    VCAudioBufferList_GetSampleCount(a3);
    int v12 = _VCAudioIO_ComputeTimestampForControllerTime(a1, a2, HostTime);
    VCAudioBufferList_SetTime(a3, v12, HostTime);
    kdebug_trace();
    if (*(unsigned char *)(a1 + 8))
    {
      VCAudioBufferList_ResampleAppend(a3, (uint64_t)v9, v12, *(OpaqueAudioConverter **)(*(void *)a1 + 88));
    }
    else if (v9 != (unsigned int *)a3)
    {
      VCAudioBufferList_Append((uint64_t)v9, a3, 0);
    }
    if (*(unsigned char *)(a1 + 65)) {
      VCAudioBufferList_ZeroMemory((uint64_t)v9);
    }
    unsigned int v13 = VCAudioBufferList_GetSampleCount((uint64_t)v9);
    unsigned int v14 = *(_DWORD *)(a1 + 12);
    if (v13 >= v14)
    {
      unsigned int v15 = v13;
      if (v13 > v14) {
        VCAudioBufferList_SetSampleCount((uint64_t)v9, v14);
      }
      VCAudioBufferList_GetTimestamp((uint64_t)v9);
      kdebug_trace();
      uint64_t v16 = *(void *)(a1 + 120);
      if (v16) {
        VCCannedAudioInjector_InjectSamples(v16, (uint64_t)v9, *(unsigned __int8 *)(a1 + 65), 0);
      }
      uint64_t v17 = *(void (**)(void, unsigned int *))(a1 + 80);
      if (v17) {
        v17(*(void *)(a1 + 88), v9);
      }
      else {
        [*v6 pushAudioSamples:v9];
      }
      uint64_t v18 = *(void *)(a1 + 104);
      if (v18) {
        VCAudioCaptionsCoordinator_PushAudioSamples(v18, *(void *)(a1 + 96), v9);
      }
      if (v15 > *(_DWORD *)(a1 + 12)) {
        VCAudioBufferList_SetSampleCount((uint64_t)v9, v15);
      }
      if (v9 != (unsigned int *)a3) {
        VCAudioBufferList_Shift((uint64_t)v9, *(_DWORD *)(a1 + 12));
      }
    }
    return VCAudioBufferList_SetTime(a3, Timestamp, HostTime);
  }
  return result;
}

uint64_t _VCAudioIO_ComputeTimestampForControllerTime(uint64_t a1, unint64_t *a2, double a3)
{
  SampleFormat = (double *)VCAudioBufferList_GetSampleFormat(*(void *)(a1 + 16));
  unint64_t v7 = (unint64_t)(*SampleFormat * (double)a2[1]) / *(unsigned int *)a2;
  if (*(unsigned char *)(a1 + 64))
  {
    if (*(unsigned char *)(a1 + 40)) {
      *(_DWORD *)(a1 + 60) = *(_DWORD *)(a1 + 56) - v7 + (*SampleFormat * (a3 - *(double *)(a1 + 48)));
    }
    *(unsigned char *)(a1 + 64) = 0;
  }
  uint64_t result = (*(_DWORD *)(a1 + 60) + v7);
  *(double *)(a1 + 48) = a3;
  *(unsigned char *)(a1 + 40) = 1;
  *(_DWORD *)(a1 + 56) = result;
  return result;
}

void VCAudioIO_PullAudioSamples(uint64_t a1, unint64_t *a2, unsigned int *a3)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (id *)(a1 + 72);
  if (!memcmp(&_VCAudioIO_EmptyContext, (const void *)(a1 + 72), 0x38uLL) || *(unsigned char *)(a1 + 8) && !*(void *)a1)
  {
    VCAudioBufferList_ZeroMemory((uint64_t)a3);
  }
  else
  {
    ++*(_DWORD *)(a1 + 68);
    double HostTime = VCAudioBufferList_GetHostTime((uint64_t)a3);
    int Timestamp = VCAudioBufferList_GetTimestamp((uint64_t)a3);
    int v9 = _VCAudioIO_ComputeTimestampForControllerTime(a1, a2, HostTime);
    if (*(unsigned char *)(a1 + 8)
      || *(unsigned char *)(a1 + 9)
      || VCAudioBufferList_GetSampleCount(*(void *)(a1 + 16)))
    {
      uint64_t v10 = *(void *)(a1 + 16);
      Sampleint32_t Count = (double)VCAudioBufferList_GetSampleCount((uint64_t)a3);
      double v12 = *(double *)VCAudioBufferList_GetSampleFormat(v10) * SampleCount;
      unsigned int v40 = (v12 / *(double *)VCAudioBufferList_GetSampleFormat((uint64_t)a3));
      if (VCAudioBufferList_GetSampleCount(v10) < v40)
      {
        uint64_t v13 = *(void *)(a1 + 16);
        int v14 = VCAudioBufferList_GetSampleCount(v13);
        int v15 = v14 + v9;
        uint64_t v16 = (unsigned int *)v13;
        if (v14) {
          uint64_t v16 = *(unsigned int **)(a1 + 24);
        }
        VCAudioBufferList_SetSampleCount((uint64_t)v16, *(_DWORD *)(a1 + 12));
        VCAudioBufferList_SetTime((uint64_t)v16, v15, HostTime);
        VCAudioBufferList_InvalidateNetworkTimestamp((uint64_t)v16);
        kdebug_trace();
        uint64_t v17 = *(void *)(a1 + 120);
        if (v17) {
          VCCannedAudioInjector_InjectSamples(v17, (uint64_t)v16, *(unsigned __int8 *)(a1 + 65), 0);
        }
        uint64_t v18 = *(void (**)(void, unsigned int *))(a1 + 80);
        if (v18) {
          v18(*(void *)(a1 + 88), v16);
        }
        else {
          [*v6 pullAudioSamples:v16];
        }
        uint64_t v19 = *(void *)(a1 + 104);
        if (v19) {
          VCAudioCaptionsCoordinator_PushAudioSamples(v19, *(void *)(a1 + 96), v16);
        }
        if (v16 != (unsigned int *)v13) {
          VCAudioBufferList_Append(v13, (uint64_t)v16, 0);
        }
      }
      int v37 = Timestamp;
      __int16 v38 = a3;
      uint64_t v36 = v10;
      if (*(unsigned char *)(a1 + 8))
      {
        uint64_t v20 = *(void *)(a1 + 16);
        uint64_t SampleFormat = VCAudioBufferList_GetSampleFormat(v20);
        int SampleCapacity = VCAudioBufferList_GetSampleCapacity((uint64_t)a3);
        int v23 = *(_DWORD *)(VCAudioBufferList_GetSampleFormat((uint64_t)a3) + 16);
        uint64_t AudioBufferList = VCAudioBufferList_GetAudioBufferList((uint64_t)a3);
        BOOL v25 = (unsigned int *)VCAudioBufferList_GetAudioBufferList(v20);
        if (*v25)
        {
          uint64_t v26 = v25;
          uint64_t v27 = 0;
          unint64_t v28 = 0;
          signed int v29 = v23 * SampleCapacity;
          do
          {
            int v41 = v29;
            int v30 = SoundDec_Decode(*(void *)a1, *(const void **)&v26[v27 + 4], *(_DWORD *)(SampleFormat + 16) * v40, *(char **)(AudioBufferList + v27 * 4 + 16), v29, &v41, 0);
            if (v30 < 0)
            {
              int v31 = v30;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                uint64_t v39 = VRTraceErrorLogLevelToCSTR();
                uint64_t v32 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136315906;
                  uint64_t v43 = v39;
                  __int16 v44 = 2080;
                  BOOL v45 = "_VCAudioIO_ConvertSourceSamples";
                  __int16 v46 = 1024;
                  int v47 = 179;
                  __int16 v48 = 1024;
                  int v49 = v31;
                  _os_log_error_impl(&dword_1E1EA4000, v32, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to convert buffer. result=%08x", buf, 0x22u);
                }
              }
            }
            *(_DWORD *)(AudioBufferList + v27 * 4 + 12) = v41;
            ++v28;
            v27 += 4;
          }
          while (v28 < *v26);
        }
      }
      else
      {
        VCAudioBufferList_ReplaceSamples((uint64_t)a3, v10, 0);
      }
      VCAudioBufferList_Shift(v36, v40);
      a3 = v38;
      int Timestamp = v37;
    }
    else
    {
      VCAudioBufferList_SetTime((uint64_t)a3, v9, HostTime);
      kdebug_trace();
      uint64_t v33 = *(void *)(a1 + 120);
      if (v33) {
        VCCannedAudioInjector_InjectSamples(v33, (uint64_t)a3, *(unsigned __int8 *)(a1 + 65), 0);
      }
      uint64_t v34 = *(void (**)(void, unsigned int *))(a1 + 80);
      if (v34) {
        v34(*(void *)(a1 + 88), a3);
      }
      else {
        [*v6 pullAudioSamples:a3];
      }
      uint64_t v35 = *(void *)(a1 + 104);
      if (v35) {
        VCAudioCaptionsCoordinator_PushAudioSamples(v35, *(void *)(a1 + 96), a3);
      }
    }
    VCAudioBufferList_SetTime((uint64_t)a3, Timestamp, HostTime);
  }
}

void sub_1E2209040(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1E220C700(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

void sub_1E220D180(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

uint64_t VCRateControlStatisticsProc(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    long long v12 = unk_1E25A0390;
    long long v13 = xmmword_1E25A03A0;
    memset(v14, 170, 24);
    long long v9 = unk_1E25A0350;
    long long v10 = xmmword_1E25A0360;
    memset(v11, 170, sizeof(v11));
    v8[0] = xmmword_1E25A0300;
    memset(&v8[1], 170, 64);
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v2 = (_DWORD *)(a1 + 60024);
      do
      {
        while (_VCStatisticsCollectorQueue_Dequeue(a1, (uint64_t)v8))
        {
          uint64_t v3 = *(void *)(a1 + 60040);
          if (v3)
          {
            double v4 = *(void (**)(uint64_t, timespec *))(v3 + 16);
            long long v25 = v13;
            long long v26 = v14[0];
            uint64_t v27 = *(void *)&v14[1];
            long long v21 = v10;
            long long v22 = v11[0];
            long long v23 = v11[1];
            long long v24 = v12;
            long long v17 = v8[2];
            long long v18 = v8[3];
            long long v19 = v8[4];
            long long v20 = v9;
            timespec v15 = (timespec)v8[0];
            long long v16 = v8[1];
            v4(v3, &v15);
          }
        }
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 60048));
        double v5 = (pthread_mutex_t *)(a1 + 60048);
        if (*(unsigned char *)(a1 + 16))
        {
          if (*(unsigned char *)(a1 + 17) || *(unsigned char *)(a1 + 60321))
          {
            double v5 = (pthread_mutex_t *)(a1 + 60048);
            if (*v2 == *(_DWORD *)(a1 + 60028))
            {
              pthread_cond_wait((pthread_cond_t *)(a1 + 60160), (pthread_mutex_t *)(a1 + 60048));
              double v5 = (pthread_mutex_t *)(a1 + 60048);
            }
          }
          else
          {
            pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60048));
            uint64_t v6 = 1000000 * *(unsigned int *)(a1 + 60324);
            v15.tv_sec = 0;
            v15.tv_nsec = v6;
            pthread_mutex_lock((pthread_mutex_t *)(a1 + 60208));
            pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 60272), (pthread_mutex_t *)(a1 + 60208), &v15);
            double v5 = (pthread_mutex_t *)(a1 + 60208);
          }
        }
        pthread_mutex_unlock(v5);
      }
      while (*(unsigned char *)(a1 + 16));
    }
  }
  return 0;
}

uint64_t VCStatisticsCollectorQueue_AddStatisticsMessage(uint64_t a1, uint64_t a2)
{
  v67[2] = *MEMORY[0x1E4F143B8];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v51 = VRTraceErrorLogLevelToCSTR();
      __int16 v52 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        uint64_t v59 = v51;
        __int16 v60 = 2080;
        uint64_t v61 = "VCStatisticsCollectorQueue_AddStatisticsMessage";
        __int16 v62 = 1024;
        int v63 = 133;
        __int16 v64 = 2048;
        uint64_t v65 = a1;
        __int16 v66 = 2048;
        v67[0] = a2;
        _os_log_error_impl(&dword_1E1EA4000, v52, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d Invalid parameter. Collector=%p message=%p", buf, 0x30u);
      }
    }
    return 0;
  }
  double v4 = (int *)(a1 + 60024);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 60048));
  int v5 = *(_DWORD *)(a1 + 60028);
  if (*v4 != (v5 + 1) % *(_DWORD *)(a1 + 60032))
  {
LABEL_33:
    uint64_t v38 = a1 + 200 * v5;
    *(_OWORD *)(v38 + 24) = *(_OWORD *)a2;
    long long v39 = *(_OWORD *)(a2 + 16);
    long long v40 = *(_OWORD *)(a2 + 32);
    long long v41 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)(v38 + 88) = *(_OWORD *)(a2 + 64);
    *(_OWORD *)(v38 + 72) = v41;
    *(_OWORD *)(v38 + 56) = v40;
    *(_OWORD *)(v38 + 40) = v39;
    long long v42 = *(_OWORD *)(a2 + 80);
    long long v43 = *(_OWORD *)(a2 + 96);
    long long v44 = *(_OWORD *)(a2 + 112);
    *(_OWORD *)(v38 + 152) = *(_OWORD *)(a2 + 128);
    *(_OWORD *)(v38 + 136) = v44;
    *(_OWORD *)(v38 + 120) = v43;
    *(_OWORD *)(v38 + 104) = v42;
    long long v45 = *(_OWORD *)(a2 + 144);
    long long v46 = *(_OWORD *)(a2 + 160);
    long long v47 = *(_OWORD *)(a2 + 176);
    *(void *)(v38 + 216) = *(void *)(a2 + 192);
    *(_OWORD *)(v38 + 200) = v47;
    *(_OWORD *)(v38 + 184) = v46;
    *(_OWORD *)(v38 + 168) = v45;
    int v48 = *(_DWORD *)(a1 + 60032);
    int v49 = (*(_DWORD *)(a1 + 60028) + 1) % v48;
    *(_DWORD *)(a1 + 60028) = v49;
    if (*(unsigned char *)(a1 + 17) || *(unsigned char *)(a1 + 60321))
    {
      pthread_cond_signal((pthread_cond_t *)(a1 + 60160));
    }
    else if (*(_DWORD *)a2 == 9 || *(_DWORD *)(a1 + 60036) < (v48 & ((v49 - *v4) >> 31)) + v49 - *v4)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 60208));
      pthread_cond_signal((pthread_cond_t *)(a1 + 60272));
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60208));
    }
    uint64_t v50 = 1;
    goto LABEL_37;
  }
  int v6 = 0;
  uint64_t v7 = a1 + 24;
  while (1)
  {
    if (*(unsigned char *)(a1 + 17))
    {
      pthread_cond_wait((pthread_cond_t *)(a1 + 60112), (pthread_mutex_t *)(a1 + 60048));
      goto LABEL_32;
    }
    int v8 = *(_DWORD *)(a1 + 60328);
    *(_DWORD *)(a1 + 60328) = v8 + 1;
    HIDWORD(v9) = -1030792151 * v8;
    LODWORD(v9) = -1030792151 * v8;
    if ((v9 >> 1) <= 0x51EB851 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v10 = VRTraceErrorLogLevelToCSTR();
      uint64_t v11 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v12 = *(_DWORD *)(a1 + 60028) - *v4;
        if (v12 < 0) {
          v12 += *(_DWORD *)(a1 + 60032);
        }
        int v13 = *(_DWORD *)(a1 + 60328);
        *(_DWORD *)buf = 136316418;
        uint64_t v59 = v10;
        __int16 v60 = 2080;
        uint64_t v61 = "_VCStatisticsCollectorQueue_Enqueue";
        __int16 v62 = 1024;
        int v63 = 210;
        __int16 v64 = 2048;
        uint64_t v65 = a1;
        __int16 v66 = 1024;
        LODWORD(v67[0]) = v12;
        WORD2(v67[0]) = 1024;
        *(_DWORD *)((char *)v67 + 6) = v13;
        _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Message queue [%p] full with queueSize=%d, queueFullCount=%u, statistic message ignored!", buf, 0x32u);
      }
    }
    if (v6) {
      break;
    }
    if (*(_DWORD *)(a2 + 4) != 1) {
      goto LABEL_51;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v14 = VRTraceErrorLogLevelToCSTR();
      timespec v15 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v16 = *(_DWORD *)(a1 + 60028) - *v4;
        if (v16 < 0) {
          v16 += *(_DWORD *)(a1 + 60032);
        }
        int v17 = *(_DWORD *)(a1 + 60328);
        *(_DWORD *)buf = 136316418;
        uint64_t v59 = v14;
        __int16 v60 = 2080;
        uint64_t v61 = "_VCStatisticsCollectorQueue_ShouldFlushOldMessages";
        __int16 v62 = 1024;
        int v63 = 189;
        __int16 v64 = 2048;
        uint64_t v65 = a1;
        __int16 v66 = 1024;
        LODWORD(v67[0]) = v16;
        WORD2(v67[0]) = 1024;
        *(_DWORD *)((char *)v67 + 6) = v17;
        _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Message queue [%p] with queueSize=%d, queueFullCount=%u should be flushed", buf, 0x32u);
      }
    }
    int v18 = *v4;
    int v19 = *(_DWORD *)(a1 + 60028);
    if (*v4 != v19)
    {
      int v20 = *v4;
      do
      {
        int v21 = v20;
        if (*(_DWORD *)(v7 + 200 * v20 + 4) == 1)
        {
          uint64_t v22 = v7 + 200 * v20;
          uint64_t v23 = v7 + 200 * v18;
          *(_OWORD *)uint64_t v23 = *(_OWORD *)v22;
          long long v24 = *(_OWORD *)(v22 + 16);
          long long v25 = *(_OWORD *)(v22 + 32);
          long long v26 = *(_OWORD *)(v22 + 64);
          *(_OWORD *)(v23 + 48) = *(_OWORD *)(v22 + 48);
          *(_OWORD *)(v23 + 64) = v26;
          *(_OWORD *)(v23 + 16) = v24;
          *(_OWORD *)(v23 + 32) = v25;
          long long v27 = *(_OWORD *)(v22 + 80);
          long long v28 = *(_OWORD *)(v22 + 96);
          long long v29 = *(_OWORD *)(v22 + 128);
          *(_OWORD *)(v23 + 112) = *(_OWORD *)(v22 + 112);
          *(_OWORD *)(v23 + 128) = v29;
          *(_OWORD *)(v23 + 80) = v27;
          *(_OWORD *)(v23 + 96) = v28;
          long long v30 = *(_OWORD *)(v22 + 144);
          long long v31 = *(_OWORD *)(v22 + 160);
          long long v32 = *(_OWORD *)(v22 + 176);
          *(void *)(v23 + 192) = *(void *)(v22 + 192);
          *(_OWORD *)(v23 + 160) = v31;
          *(_OWORD *)(v23 + 176) = v32;
          *(_OWORD *)(v23 + 144) = v30;
          int v19 = *(_DWORD *)(a1 + 60028);
          int v33 = *(_DWORD *)(a1 + 60032);
          int v18 = (v18 + 1) % v33;
        }
        else
        {
          int v33 = *(_DWORD *)(a1 + 60032);
        }
        int v20 = (v21 + 1) % v33;
      }
      while (v20 != v19);
    }
    *(_DWORD *)(a1 + 60028) = v18;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v34 = VRTraceErrorLogLevelToCSTR();
      uint64_t v35 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v36 = *(_DWORD *)(a1 + 60028) - *v4;
        if (v36 < 0) {
          v36 += *(_DWORD *)(a1 + 60032);
        }
        int v37 = *(_DWORD *)(a1 + 60328);
        *(_DWORD *)buf = 136316418;
        uint64_t v59 = v34;
        __int16 v60 = 2080;
        uint64_t v61 = "_VCStatisticsCollectorQueue_ShouldFlushOldMessages";
        __int16 v62 = 1024;
        int v63 = 191;
        __int16 v64 = 2048;
        uint64_t v65 = a1;
        __int16 v66 = 1024;
        LODWORD(v67[0]) = v36;
        WORD2(v67[0]) = 1024;
        *(_DWORD *)((char *)v67 + 6) = v37;
        _os_log_impl(&dword_1E1EA4000, v35, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Message queue [%p] with queueSize=%d, queueFullCount=%u after low priority messages flushed", buf, 0x32u);
      }
    }
    int v6 = 1;
LABEL_32:
    int v5 = *(_DWORD *)(a1 + 60028);
    if (*v4 != (v5 + 1) % *(_DWORD *)(a1 + 60032)) {
      goto LABEL_33;
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    uint64_t v54 = VRTraceErrorLogLevelToCSTR();
    int v55 = *MEMORY[0x1E4F47A50];
    uint64_t v50 = 0;
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_37;
    }
    int v56 = *(_DWORD *)(a1 + 60028) - *v4;
    if (v56 < 0) {
      v56 += *(_DWORD *)(a1 + 60032);
    }
    int v57 = *(_DWORD *)(a1 + 60328);
    *(_DWORD *)buf = 136316418;
    uint64_t v59 = v54;
    __int16 v60 = 2080;
    uint64_t v61 = "_VCStatisticsCollectorQueue_ShouldFlushOldMessages";
    __int16 v62 = 1024;
    int v63 = 183;
    __int16 v64 = 2048;
    uint64_t v65 = a1;
    __int16 v66 = 1024;
    LODWORD(v67[0]) = v56;
    WORD2(v67[0]) = 1024;
    *(_DWORD *)((char *)v67 + 6) = v57;
    _os_log_impl(&dword_1E1EA4000, v55, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Message queue [%p] is still full with queueSize=%d, queueFullCount=%u after flushing the low priority messages. High priroity statistic message will be ignored!", buf, 0x32u);
  }
LABEL_51:
  uint64_t v50 = 0;
LABEL_37:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60048));
  return v50;
}

void VCStatisticsCollectorQueue_DrainAndProcessAllStatistics(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = (uint64_t *)(a1 + 60040);
    if (*(unsigned char *)(a1 + 60320))
    {
      long long v9 = unk_1E25A0390;
      long long v10 = xmmword_1E25A03A0;
      memset(v11, 170, 24);
      long long v6 = unk_1E25A0350;
      long long v7 = xmmword_1E25A0360;
      memset(v8, 170, sizeof(v8));
      v5[0] = xmmword_1E25A0300;
      memset(&v5[1], 170, 64);
      while (_VCStatisticsCollectorQueue_Dequeue(a1, (uint64_t)v5))
      {
        uint64_t v3 = *v2;
        if (*v2)
        {
          double v4 = *(void (**)(uint64_t, _OWORD *))(v3 + 16);
          v12[10] = v10;
          v12[11] = v11[0];
          uint64_t v13 = *(void *)&v11[1];
          void v12[6] = v7;
          v12[7] = v8[0];
          v12[8] = v8[1];
          v12[9] = v9;
          v12[2] = v5[2];
          v12[3] = v5[3];
          v12[4] = v5[4];
          v12[5] = v6;
          v12[0] = v5[0];
          v12[1] = v5[1];
          v4(v3, v12);
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCStatisticsCollectorQueue_DrainAndProcessAllStatistics_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCStatisticsCollectorQueue_DrainAndProcessAllStatistics_cold_1();
    }
  }
}

BOOL _VCStatisticsCollectorQueue_Dequeue(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      long long v6 = *MEMORY[0x1E4F47A50];
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      int v18 = 136316162;
      uint64_t v19 = v5;
      __int16 v20 = 2080;
      int v21 = "_VCStatisticsCollectorQueue_Dequeue";
      __int16 v22 = 1024;
      int v23 = 250;
      __int16 v24 = 2048;
      uint64_t v25 = a1;
      __int16 v26 = 2048;
      uint64_t v27 = a2;
      _os_log_error_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d Invalid parameter. queue=%p message=%p", (uint8_t *)&v18, 0x30u);
    }
    return 0;
  }
  double v4 = (int *)(a1 + 60024);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 60048));
  if (*v4 == *(_DWORD *)(a1 + 60028))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60048));
    return 0;
  }
  uint64_t v8 = a1 + 200 * *v4;
  *(_OWORD *)a2 = *(_OWORD *)(v8 + 24);
  long long v9 = *(_OWORD *)(v8 + 40);
  long long v10 = *(_OWORD *)(v8 + 56);
  long long v11 = *(_OWORD *)(v8 + 88);
  *(_OWORD *)(a2 + 48) = *(_OWORD *)(v8 + 72);
  *(_OWORD *)(a2 + 64) = v11;
  *(_OWORD *)(a2 + 16) = v9;
  *(_OWORD *)(a2 + 32) = v10;
  long long v12 = *(_OWORD *)(v8 + 104);
  long long v13 = *(_OWORD *)(v8 + 120);
  long long v14 = *(_OWORD *)(v8 + 152);
  *(_OWORD *)(a2 + 112) = *(_OWORD *)(v8 + 136);
  *(_OWORD *)(a2 + 128) = v14;
  *(_OWORD *)(a2 + 80) = v12;
  *(_OWORD *)(a2 + 96) = v13;
  long long v15 = *(_OWORD *)(v8 + 168);
  long long v16 = *(_OWORD *)(v8 + 184);
  long long v17 = *(_OWORD *)(v8 + 200);
  *(void *)(a2 + 192) = *(void *)(v8 + 216);
  *(_OWORD *)(a2 + 160) = v16;
  *(_OWORD *)(a2 + 176) = v17;
  *(_OWORD *)(a2 + 144) = v15;
  *double v4 = (*v4 + 1) % *(_DWORD *)(a1 + 60032);
  if (*(unsigned char *)(a1 + 17)) {
    pthread_cond_signal((pthread_cond_t *)(a1 + 60112));
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60048));
  return 1;
}

void VCStatisticsCollectorQueue_FlushAllStatistics(uint64_t a1)
{
  v2[25] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(_OWORD *)&v2[18] = unk_1E25A0390;
    *(_OWORD *)&v2[20] = xmmword_1E25A03A0;
    memset(&v2[22], 170, 24);
    *(_OWORD *)&v2[10] = unk_1E25A0350;
    *(_OWORD *)&v2[12] = xmmword_1E25A0360;
    memset(&v2[14], 170, 32);
    *(_OWORD *)uint64_t v2 = xmmword_1E25A0300;
    memset(&v2[2], 170, 64);
    while (_VCStatisticsCollectorQueue_Dequeue(a1, (uint64_t)v2))
      ;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCStatisticsCollectorQueue_FlushAllStatistics_cold_1();
    }
  }
}

uint64_t VCTimescalePSOLA_Accelerate(unsigned __int8 *a1, __int16 *a2)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    uint64_t v5 = *MEMORY[0x1E4F47A50];
    long long v6 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = a2[33];
        int v30 = 136315906;
        uint64_t v31 = v4;
        __int16 v32 = 2080;
        int v33 = "VCTimescalePSOLA_Accelerate";
        __int16 v34 = 1024;
        int v35 = 113;
        __int16 v36 = 1024;
        int v37 = v7;
        _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Accelerate buffer  inputBufferLength=%d", (uint8_t *)&v30, 0x22u);
      }
    }
    else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      VCTimescalePSOLA_Accelerate_cold_2(v4, (uint64_t)a2, v5);
    }
  }
  *((_WORD *)a1 + 29) = 0;
  if (a1[92])
  {
    __int16 v8 = VCTimescalePSOLA_CalcFsMult(*((unsigned __int16 *)a1 + 1));
    __int16 v9 = 80 * v8;
    int v10 = (__int16)(80 * v8);
    uint64_t v11 = VCTimescalePSOLA_CheckforSignalCorrelation((__int16 *)a1, a2, v10, 0);
    if ((v11 & 0x80000000) != 0)
    {
      uint64_t v19 = v11;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v28 = VRTraceErrorLogLevelToCSTR();
        long long v29 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCTimescalePSOLA_Accelerate_cold_1(v28, v29);
        }
      }
    }
    else
    {
      VCTimescalePSOLA_SynchronizeChannelCorrelation(a1, (uint64_t)a2, 0, v8);
      if (*((__int16 *)a1 + 19) <= *((__int16 *)a1 + 27) && *((_WORD *)a1 + 11))
      {
        LOWORD(v12) = *((_WORD *)a1 + 3);
        LOWORD(v13) = *((_WORD *)a1 + 2);
        goto LABEL_13;
      }
      int v12 = *((__int16 *)a1 + 3);
      int v13 = *((__int16 *)a1 + 2);
      if (v12 > v13)
      {
LABEL_13:
        if ((__int16)v12 > (__int16)v13 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          uint64_t v14 = VRTraceErrorLogLevelToCSTR();
          long long v15 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            int v16 = *((__int16 *)a1 + 3);
            int v17 = *((__int16 *)a1 + 2);
            int v30 = 136316162;
            uint64_t v31 = v14;
            __int16 v32 = 2080;
            int v33 = "_VCTimescalePSOLA_CheckQualityAndAccelerate";
            __int16 v34 = 1024;
            int v35 = 75;
            __int16 v36 = 1024;
            int v37 = v16;
            __int16 v38 = 1024;
            int v39 = v17;
            _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d REJECTED accelerate (bestIndex %d > psolaMax %d)", (uint8_t *)&v30, 0x28u);
          }
        }
        a2[34] = a2[33];
        if (*a1)
        {
          unint64_t v18 = 0;
          do
          {
            memmove(*(void **)&a2[4 * v18 + 16], *(const void **)&a2[4 * v18], 4 * a2[33]);
            ++v18;
          }
          while (v18 < *a1);
        }
        return 61;
      }
      if (*a1)
      {
        unint64_t v21 = 0;
        float v22 = 1.0 / (float)(v12 + 1);
        do
        {
          int v23 = &a2[4 * v21];
          int v24 = v10 - *((__int16 *)a1 + 3);
          uint64_t v25 = (float *)(*(void *)v23 + 4 * v24);
          __int16 v26 = (float *)(*(void *)v23 + 4 * v9);
          memmove(*((void **)v23 + 4), *(const void **)v23, 4 * (__int16)(v10 - *((_WORD *)a1 + 3)));
          VCTimescalePSOLA_MixVoiceUnvoiceFloatPoint((float *)(*((void *)v23 + 4) + 4 * (__int16)v24), v25, v26, *((__int16 *)a1 + 3), 1.0 - v22, v22);
          memmove((void *)(*((void *)v23 + 4) + 4 * v9), (const void *)(*(void *)v23 + 4 * (*((__int16 *)a1 + 3) + v10)), 4 * (__int16)(a2[33] - (*((_WORD *)a1 + 3) + v9)));
          ++v21;
        }
        while (v21 < *a1);
        LOWORD(v12) = *((_WORD *)a1 + 3);
      }
      uint64_t v19 = 0;
      if ((__int16)v12 >= a2[33]) {
        LOWORD(v12) = a2[33];
      }
      *((_WORD *)a1 + 3) = v12;
      a2[34] = a2[33] - v12;
      *((_DWORD *)a1 + 19) += *((__int16 *)a1 + 3);
    }
  }
  else
  {
    a2[34] = a2[33];
    if (*a1)
    {
      unint64_t v20 = 0;
      do
      {
        memmove(*(void **)&a2[4 * v20 + 16], *(const void **)&a2[4 * v20], 4 * a2[33]);
        ++v20;
      }
      while (v20 < *a1);
    }
    return 0;
  }
  return v19;
}

uint64_t VCFramingOverheadCalculationUtils_PerPacketMediaFramingOverheadWithRTPHandle(uint64_t a1, unsigned int *a2, uint64_t *a3)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  if (!a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v17 = VRTraceErrorLogLevelToCSTR();
      unint64_t v18 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCFramingOverheadCalculationUtils_PerPacketMediaFramingOverheadWithRTPHandle_cold_1(v17, v18);
      }
    }
    return 1;
  }
  uint64_t v6 = RTPGetFramingOverhead(a1, &v25);
  if ((v6 & 0x80000000) != 0)
  {
    uint64_t v13 = v6;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
      return v13;
    }
    uint64_t v19 = VRTraceErrorLogLevelToCSTR();
    unint64_t v20 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      return v13;
    }
    *(_DWORD *)buf = 136316162;
    uint64_t v27 = v19;
    __int16 v28 = 2080;
    long long v29 = "VCFramingOverheadCalculationUtils_PerPacketMediaFramingOverheadWithRTPHandle";
    __int16 v30 = 1024;
    int v31 = 25;
    __int16 v32 = 2048;
    uint64_t v33 = a1;
    __int16 v34 = 1024;
    LODWORD(v35) = v13;
    unint64_t v21 = " [%s] %s:%d Failed to get RTP Framing overhead from rtpHandle=%p result=0x%x";
LABEL_22:
    _os_log_error_impl(&dword_1E1EA4000, v20, OS_LOG_TYPE_ERROR, v21, buf, 0x2Cu);
    return v13;
  }
  uint64_t v7 = v25;
  uint64_t v8 = SRTPGetFramingOverhead(a1, &v24);
  if ((v8 & 0x80000000) != 0)
  {
    uint64_t v13 = v8;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
      return v13;
    }
    uint64_t v22 = VRTraceErrorLogLevelToCSTR();
    unint64_t v20 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      return v13;
    }
    *(_DWORD *)buf = 136316162;
    uint64_t v27 = v22;
    __int16 v28 = 2080;
    long long v29 = "VCFramingOverheadCalculationUtils_PerPacketMediaFramingOverheadWithRTPHandle";
    __int16 v30 = 1024;
    int v31 = 29;
    __int16 v32 = 2048;
    uint64_t v33 = a1;
    __int16 v34 = 1024;
    LODWORD(v35) = v13;
    unint64_t v21 = " [%s] %s:%d Failed to get SRTP Framing overhead from rtpHandle=%p result=0x%x";
    goto LABEL_22;
  }
  uint64_t v9 = v24 + v7;
  VCMediaControlInfoGeneratorGetSerializedSizeWithConfig(a2, &v23);
  *a3 = v9 + v23;
  if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
    return 0;
  }
  uint64_t v10 = VRTraceErrorLogLevelToCSTR();
  uint64_t v11 = *MEMORY[0x1E4F47A50];
  int v12 = *MEMORY[0x1E4F47A50];
  if (!*MEMORY[0x1E4F47A40])
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v16 = *a3;
      *(_DWORD *)buf = 136316674;
      uint64_t v27 = v10;
      __int16 v28 = 2080;
      long long v29 = "VCFramingOverheadCalculationUtils_PerPacketMediaFramingOverheadWithRTPHandle";
      __int16 v30 = 1024;
      int v31 = 37;
      __int16 v32 = 2048;
      uint64_t v33 = v16;
      __int16 v34 = 2048;
      uint64_t v35 = v25;
      __int16 v36 = 2048;
      uint64_t v37 = v24;
      __int16 v38 = 2048;
      uint64_t v39 = v23;
      _os_log_debug_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEBUG, " [%s] %s:%d framingOverhead=%lu rtpFramingOverhead=%lu srtpFramingOverhead=%lu mediaControlInfoOverhead=%lu", buf, 0x44u);
    }
    return 0;
  }
  uint64_t v13 = 0;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = *a3;
    *(_DWORD *)buf = 136316674;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    long long v29 = "VCFramingOverheadCalculationUtils_PerPacketMediaFramingOverheadWithRTPHandle";
    __int16 v30 = 1024;
    int v31 = 37;
    __int16 v32 = 2048;
    uint64_t v33 = v14;
    __int16 v34 = 2048;
    uint64_t v35 = v25;
    __int16 v36 = 2048;
    uint64_t v37 = v24;
    __int16 v38 = 2048;
    uint64_t v39 = v23;
    _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d framingOverhead=%lu rtpFramingOverhead=%lu srtpFramingOverhead=%lu mediaControlInfoOverhead=%lu", buf, 0x44u);
    return 0;
  }
  return v13;
}

uint64_t VCAudioCaptionsBufferInfo_GetBuffer(uint64_t result)
{
  if (result) {
    return *(void *)(result + 48);
  }
  return result;
}

BOOL VCAudioCaptionsBufferInfo_UseSecondaryThread(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 64) != 0;
  }
  return result;
}

void sub_1E221004C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 72), 8);
  _Unwind_Resume(a1);
}

uint64_t VCAudioCaptionsBufferInfoCollection_GetBufferInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x3052000000;
  uint64_t v9 = __Block_byref_object_copy__19;
  uint64_t v10 = __Block_byref_object_dispose__19;
  uint64_t v11 = 0;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __VCAudioCaptionsBufferInfoCollection_GetBufferInfo_block_invoke;
  void v5[3] = &unk_1E6DB7008;
  _OWORD v5[5] = &v6;
  v5[6] = a2;
  void v5[4] = a1;
  dispatch_sync(v2, v5);
  uint64_t v3 = v7[5];
  _Block_object_dispose(&v6, 8);
  return v3;
}

BOOL VCAudioCaptionsBufferInfoCollection_AddBufferInfo(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = [[VCAudioCaptionsBufferInfo alloc] initWithStreamConfig:a2 bufferLength:*(double *)(a1 + 16)];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v14 = 0;
    long long v15 = &v14;
    uint64_t v16 = 0x2020000000;
    char v17 = 0;
    uint64_t v8 = *(NSObject **)(a1 + 24);
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __VCAudioCaptionsBufferInfoCollection_AddBufferInfo_block_invoke;
    void v13[3] = &unk_1E6DB43B0;
    v13[5] = v7;
    v13[6] = &v14;
    v13[4] = a1;
    dispatch_sync(v8, v13);
    if (a3 && *((unsigned char *)v15 + 24)) {
      *a3 = v7;
    }

    BOOL v9 = *((unsigned char *)v15 + 24) != 0;
    _Block_object_dispose(&v14, 8);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v10 = VRTraceErrorLogLevelToCSTR();
      uint64_t v11 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioCaptionsBufferInfoCollection_AddBufferInfo_cold_1(v10, a2, v11);
      }
    }
    return 0;
  }
  return v9;
}

void sub_1E2210534(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
}

uint64_t VCAudioCaptionsBufferInfoCollection_CopyOrderedBufferInfos(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x3052000000;
  uint64_t v8 = __Block_byref_object_copy__19;
  BOOL v9 = __Block_byref_object_dispose__19;
  uint64_t v10 = 0;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __VCAudioCaptionsBufferInfoCollection_CopyOrderedBufferInfos_block_invoke;
  block[3] = &unk_1E6DB4540;
  block[4] = a1;
  block[5] = &v5;
  dispatch_sync(v1, block);
  uint64_t v2 = v6[5];
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t VCAudioCaptionsBufferInfoCollection_PushAudioSamples(uint64_t a1, uint64_t a2, uint64_t a3)
{
  Sampleint32_t Count = VCAudioBufferList_GetSampleCount(a3);
  uint64_t v6 = *(void *)(a2 + 48);
  int v7 = VCAudioBufferList_GetSampleCount(v6);
  int SampleCapacity = VCAudioBufferList_GetSampleCapacity(v6);
  if (SampleCount > SampleCapacity - v7) {
    VCAudioBufferList_Shift(v6, SampleCount - (SampleCapacity - v7));
  }
  VCAudioBufferList_Append(v6, a3, 0);
  char Priority = VCAudioBufferList_GetPriority(a3);
  uint64_t result = VCAudioBufferList_GetSampleCount(a3);
  *(unsigned char *)(a2 + 56) = Priority;
  if (Priority < 0)
  {
    int v12 = 0;
  }
  else
  {
    int v11 = result;
    uint64_t result = [(id)a2 countOfLowPrioritySamples];
    int v12 = result + v11;
  }
  *(_DWORD *)(a2 + 60) = v12;
  return result;
}

uint64_t VCPixelTransferSession_TransferPixelBuffer(uint64_t a1, CVPixelBufferRef pixelBuffer, __CVBuffer *a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!pixelBuffer)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCPixelTransferSession_TransferPixelBuffer_cold_1();
      }
    }
    return 1;
  }
  if (!a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCPixelTransferSession_TransferPixelBuffer_cold_2();
      }
    }
    return 1;
  }
  size_t Width = CVPixelBufferGetWidth(pixelBuffer);
  size_t Height = CVPixelBufferGetHeight(pixelBuffer);
  int v8 = Height;
  if (!Width || !Height)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v11 = VRTraceErrorLogLevelToCSTR();
      int v12 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        int v13 = 136316162;
        uint64_t v14 = v11;
        __int16 v15 = 2080;
        uint64_t v16 = "VCPixelTransferSession_TransferPixelBuffer";
        __int16 v17 = 1024;
        int v18 = 46;
        __int16 v19 = 1024;
        int v20 = Width;
        __int16 v21 = 1024;
        int v22 = v8;
        _os_log_error_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid width (%d) / height (%d)", (uint8_t *)&v13, 0x28u);
      }
    }
    return 1;
  }
  uint64_t v9 = VTPixelTransferSessionTransferImage(*(VTPixelTransferSessionRef *)(a1 + 8), pixelBuffer, a3);
  if (v9)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCPixelTransferSession_TransferPixelBuffer_cold_3();
      }
    }
  }
  return v9;
}

void _VCCaptionsStream_DidReceiveSampleBuffer(uint64_t a1, opaqueCMSampleBuffer *a2, int a3)
{
  v9[1] = *(char **)MEMORY[0x1E4F143B8];
  if (a1)
  {
    VCVideoStream_DidReceiveSampleBuffer(a1, a2, a3);
    DataBuffer = CMSampleBufferGetDataBuffer(a2);
    v9[0] = 0;
    OSStatus DataPointer = CMBlockBufferGetDataPointer(DataBuffer, 0, 0, 0, v9);
    if (v9[0])
    {
      if (DataPointer)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VCCaptionsStream_DidReceiveSampleBuffer_cold_3();
          }
        }
      }
      else
      {
        DataCFIndex Length = CMBlockBufferGetDataLength(DataBuffer);
        int v8 = (void *)[MEMORY[0x1E4F1C9B8] dataWithBytes:v9[0] length:DataLength];
        if (v8)
        {
          VCCaptionsReceiver_ProcessCaptionsData(*(void *)(a1 + 1184), v8);
          return;
        }
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCCaptionsStream_DidReceiveSampleBuffer_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCCaptionsStream_DidReceiveSampleBuffer_cold_1();
    }
  }
}

uint64_t VCAudioEventQueue_Dequeue(int *a1, uint64_t a2)
{
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    if (*a1 == a1[1])
    {
      return 0;
    }
    else
    {
      *(_DWORD *)a2 = a1[4 * *a1 + 2];
      *(void *)(a2 + 8) = *(void *)&a1[4 * *a1 + 4];
      a1[4 * *a1 + 2] = 0;
      *(void *)&a1[4 * *a1 + 4] = 0;
      int v3 = *a1 + 1;
      __dmb(0xBu);
      *a1 = v3 % 100;
      return 1;
    }
  }
  return v2;
}

char *AVCStreamInputID_ConvertToCString(uint64_t a1, char *__str, size_t __size)
{
  if (a1 > 1717854579)
  {
    if ((unint64_t)(a1 - 1986618417) < 4 || a1 == 1718909044) {
      goto LABEL_8;
    }
    uint64_t v5 = 1717854580;
  }
  else
  {
    if ((unint64_t)(a1 - 1684108337) < 5) {
      goto LABEL_8;
    }
    uint64_t v5 = 1650745716;
  }
  if (a1 != v5)
  {
    snprintf(__str, __size, "%ld", a1);
    return __str;
  }
LABEL_8:
  if (__size >= 6)
  {
    uint64_t v6 = FourccToCStr(a1);
    strncpy(__str, v6, __size);
  }
  return __str;
}

uint64_t AVCStreamInputID_ConvertToNSString(uint64_t a1)
{
  v3[3] = *MEMORY[0x1E4F143B8];
  memset(v3, 170, 20);
  uint64_t v1 = NSString;
  AVCStreamInputID_ConvertToCString(a1, (char *)v3, 0x14uLL);
  return [v1 stringWithUTF8String:v3];
}

void sub_1E2211C28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _AVCStreamInput_ComputeStats(uint64_t a1, opaqueCMSampleBuffer *a2, int a3, long long *a4, uint64_t a5)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  ++*(_DWORD *)a5;
  if (a3 != 1835365473) {
    return;
  }
  if ((*((unsigned char *)a4 + 12) & 1) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _AVCStreamInput_ComputeStats_cold_1();
      }
    }
    return;
  }
  uint64_t v8 = a5 + 4;
  if ((*(unsigned char *)(a5 + 16) & 1) == 0)
  {
LABEL_9:
    long long v13 = *a4;
    *(void *)(v8 + 16) = *((void *)a4 + 2);
    *(_OWORD *)uint64_t v8 = v13;
    return;
  }
  *(_OWORD *)&time1.CMTimeValue value = *(_OWORD *)v8;
  time1.CMTimeEpoch epoch = *(void *)(a5 + 20);
  CMTime time2 = *(CMTime *)a4;
  if (CMTimeCompare(&time1, &time2))
  {
    DataBuffer = CMSampleBufferGetDataBuffer(a2);
    memset(&time1, 170, sizeof(time1));
    CMTime time2 = *(CMTime *)a4;
    CMTime v17 = *(CMTime *)v8;
    CMTimeSubtract(&time1, &time2, &v17);
    float v11 = (double)time1.value / (double)time1.timescale;
    float v12 = (double)CMBlockBufferGetDataLength(DataBuffer) * 8.0 / v11;
    VCUtil_ExponentialMovingAverage((float *)(a5 + 28), v12, 10.0);
    goto LABEL_9;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v14 = VRTraceErrorLogLevelToCSTR();
    __int16 v15 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
    {
      CMTime time1 = *(CMTime *)a4;
      Float64 Seconds = CMTimeGetSeconds(&time1);
      LODWORD(time1.value) = 136316418;
      *(CMTimeValue *)((char *)&time1.value + 4) = v14;
      LOWORD(time1.flags) = 2080;
      *(void *)((char *)&time1.flags + 2) = "_AVCStreamInput_ComputeStats";
      HIWORD(time1.epoch) = 1024;
      int v20 = 475;
      __int16 v21 = 2048;
      uint64_t v22 = a1;
      __int16 v23 = 2080;
      uint64_t v24 = a1 + 128;
      __int16 v25 = 2048;
      Float64 v26 = Seconds;
      _os_log_error_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_ERROR, "AVCStreamInput [%s] %s:%d streamInput=%p AVCStreamInputID=%s Buffer timestamp did not increase. time=%f", (uint8_t *)&time1, 0x3Au);
    }
  }
}

AudioComponent VCAudioToolboxAudioComponentMock_FindNext(OpaqueAudioComponent *a1, const AudioComponentDescription *a2)
{
  v5[1] = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if ([+[VCAudioToolboxAudioComponentMock sharedInstance] findNextComponent:a1 description:a2 outComponent:v5])
  {
    return (AudioComponent)v5[0];
  }
  else
  {
    return AudioComponentFindNext(a1, a2);
  }
}

uint64_t VCAudioToolboxAudioComponentMock_InstanceNew(OpaqueAudioComponent *a1, AudioComponentInstance *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = 0;
  if ([+[VCAudioToolboxAudioComponentMock sharedInstance] instanceNew:a1 outInstance:a2 outStatus:&v5])
  {
    return v5;
  }
  else
  {
    return AudioComponentInstanceNew(a1, a2);
  }
}

uint64_t VCAudioToolboxAudioComponentMock_InstanceDispose(OpaqueAudioComponentInstance *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  unsigned int v3 = 0;
  if ([+[VCAudioToolboxAudioComponentMock sharedInstance] instanceDispose:a1 outStatus:&v3])
  {
    return v3;
  }
  else
  {
    return AudioComponentInstanceDispose(a1);
  }
}

uint64_t VCAudioToolboxAudioComponentMock_GetVersion(OpaqueAudioComponent *a1, UInt32 *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = 0;
  if ([+[VCAudioToolboxAudioComponentMock sharedInstance] getVersion:a1 outVersion:a2 outStatus:&v5])
  {
    return v5;
  }
  else
  {
    return AudioComponentGetVersion(a1, a2);
  }
}

uint64_t VCAudioToolboxAudioComponentMock_CopyName(OpaqueAudioComponent *a1, CFStringRef *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = 0;
  if ([+[VCAudioToolboxAudioComponentMock sharedInstance] copyName:a1 outName:a2 outStatus:&v5])
  {
    return v5;
  }
  else
  {
    return AudioComponentCopyName(a1, a2);
  }
}

void VCVideoStreamRateAdaptationFeedbackOnly_SetDidReceiveVideo(uint64_t a1, char a2)
{
  if (a1)
  {
    *(unsigned char *)(a1 + 168) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCVideoStreamRateAdaptationFeedbackOnly_SetDidReceiveVideo_cold_1();
    }
  }
}

uint64_t VCScreenCaptureManager_SharedInstance()
{
  if (VCScreenCaptureManager_SharedInstance_onceToken != -1) {
    dispatch_once(&VCScreenCaptureManager_SharedInstance_onceToken, &__block_literal_global_55);
  }
  if (!VCScreenCaptureManager_SharedInstance__vcScreenCaptureManager && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCScreenCaptureManager_SharedInstance_cold_1();
    }
  }
  return VCScreenCaptureManager_SharedInstance__vcScreenCaptureManager;
}

void VCScreenCaptureManager_ScreenShareDidClearScreen(uint64_t a1, char a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = VCScreenCaptureManager_SharedInstance();
  unsigned int v5 = *(NSObject **)(v4 + 8);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __VCScreenCaptureManager_ScreenShareDidClearScreen_block_invoke;
  v6[3] = &unk_1E6DB45E0;
  v6[4] = v4;
  v6[5] = a1;
  char v7 = a2;
  dispatch_async(v5, v6);
}

uint64_t OUTLINED_FUNCTION_4_15@<X0>(void **a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)(v2 - 24) = a2;
  uint64_t v4 = *a1;
  return [v4 currentAudioPayloadConfig];
}

void OUTLINED_FUNCTION_8_12(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x2Cu);
}

uint64_t VCVideoParamaterSets_DefaultSupportedSets(int a1)
{
  if (a1 == 100) {
    unsigned int v1 = 14;
  }
  else {
    unsigned int v1 = 0;
  }
  if (a1 == 123) {
    unsigned int v1 = 1;
  }
  if (a1 == 126) {
    return 1;
  }
  else {
    return v1;
  }
}

uint64_t VCVideoParameterSets_DefaultSupportedSetsForPayloadAndPixelFormat(int a1, int a2)
{
  if (a1 == 100) {
    int v2 = 14;
  }
  else {
    int v2 = 0;
  }
  if (a1 == 123) {
    int v2 = 1;
  }
  if (a1 == 126) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (a2 == 2016686640) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a2 == 1751411059) {
    return 1;
  }
  else {
    return v4;
  }
}

void VCStreamInput_UpdateReportingStats(uint64_t a1, CMSampleBufferRef sbuf)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  memset(&v8, 170, sizeof(v8));
  CMSampleBufferGetPresentationTimeStamp(&v8, sbuf);
  *(CMTime *)(a1 + 220) = v8;
  atomic_fetch_add((atomic_uint *volatile)(a1 + 268), 1u);
  CMTime v7 = v8;
  double v3 = micro();
  CMTime time = v7;
  double v4 = v3 - CMTimeGetSeconds(&time);
  double v5 = v4 - *(double *)(a1 + 280);
  *(double *)(a1 + 280) = v4;
  double v6 = -v5;
  if (v5 >= 0.0) {
    double v6 = v5;
  }
  *(double *)(a1 + 272) = *(double *)(a1 + 272) + (v6 - *(double *)(a1 + 272)) * 0.0625;
  if ((*(unsigned char *)(a1 + 256) & 1) == 0) {
    *(CMTime *)(a1 + 244) = v8;
  }
}

__n128 VCAudioHALPluginTimestamp::read@<Q0>(VCAudioHALPluginTimestamp *this@<X0>, __n128 *a2@<X8>)
{
  unint64_t v2 = atomic_load(&this->timestampIndex.__a_.__a_value);
  double v3 = (__n128 *)&this->timestamps.__begin_[v2];
  __n128 result = *v3;
  *a2 = *v3;
  a2[1].n128_u64[0] = v3[1].n128_u64[0];
  return result;
}

__n128 VCAudioHALPluginTimestamp::write(VCAudioHALPluginTimestamp *this, tagVCAudioHALPluginTimestampInfo *a2)
{
  unint64_t v2 = atomic_load(&this->timestampIndex.__a_.__a_value);
  unint64_t v3 = (v2 + 1) % this->numberOfSlots;
  __n128 result = *(__n128 *)&a2->sampleTime;
  double v5 = (__n128 *)&this->timestamps.__begin_[v3];
  v5[1].n128_u64[0] = a2->seed;
  __n128 *v5 = result;
  atomic_store(v3, &this->timestampIndex.__a_.__a_value);
  return result;
}

double VCAudioHALPluginTimestamp::reset(VCAudioHALPluginTimestamp *this)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  long long v6 = 0uLL;
  uint64_t v7 = 0;
  std::vector<tagVCAudioHALPluginTimestampInfo>::vector(&v4, this->numberOfSlots, &v6);
  begin = this->timestamps.__begin_;
  if (begin)
  {
    this->timestamps.__end_ = begin;
    operator delete(begin);
  }
  double result = *(double *)&v4;
  *(_OWORD *)&this->timestamps.__begin_ = v4;
  this->timestamps.__end_cap_.__value_ = v5;
  atomic_store(0, &this->timestampIndex.__a_.__a_value);
  return result;
}

void *std::vector<tagVCAudioHALPluginTimestampInfo>::vector(void *a1, unint64_t a2, long long *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<tagVCAudioHALPluginTimestampInfo>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v6 = a1[1];
    uint64_t v7 = v6 + 24 * a2;
    uint64_t v8 = 24 * a2;
    do
    {
      long long v9 = *a3;
      *(void *)(v6 + 16) = *((void *)a3 + 2);
      *(_OWORD *)uint64_t v6 = v9;
      v6 += 24;
      v8 -= 24;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1E2225790(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<tagVCAudioHALPluginTimestampInfo>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::vector<tagVCAudioHALPluginTimestampInfo>::__throw_length_error[abi:ne180100]();
  }
  double result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<tagVCAudioHALPluginTimestampInfo>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void std::vector<tagVCAudioHALPluginTimestampInfo>::__throw_length_error[abi:ne180100]()
{
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<tagVCAudioHALPluginTimestampInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(24 * a2);
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E6DB3158, MEMORY[0x1E4FBA1C8]);
}

void sub_1E22258A8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  double result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D0] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E4FBA350], MEMORY[0x1E4FBA1F8]);
}

void sub_1E222DE30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1E222DFCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _VCAllocatorFirstComeCallback_Release(uint64_t a1)
{
  v1[1] = *(CFAllocatorRef **)MEMORY[0x1E4F143B8];
  v1[0] = (CFAllocatorRef *)a1;
  if (atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 8), 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    _VCAllocatorFirstCome_FinalizeInfo(a1);
    _VCAllocatorMultiQueue_ReleaseInfo(v1);
  }
}

void *_VCAllocatorFirstComeCallback_Alloc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = 0;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a3 + 20), (unsigned int *)&v5, a1, memory_order_relaxed, memory_order_relaxed);
  if (*(int *)(a3 + 20) >= a1)
  {
    uint64_t v8 = OSAtomicDequeue((OSQueueHead *)(a3 + 32), 0);
    if (v8) {
      goto LABEL_14;
    }
    uint64_t v8 = CFAllocatorAllocate(*(CFAllocatorRef *)a3, *(int *)(a3 + 20), 0);
    int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(a3 + 12), 1u, memory_order_relaxed);
    if (add_explicit >= 2000)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v10 = VRTraceErrorLogLevelToCSTR();
        float v11 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v12 = *(_DWORD *)(a3 + 20);
          int v17 = 136316418;
          uint64_t v18 = v10;
          __int16 v19 = 2080;
          int v20 = "_VCAllocatorFirstComeCallback_Alloc";
          __int16 v21 = 1024;
          int v22 = 147;
          __int16 v23 = 2080;
          *(void *)uint64_t v24 = a3 + 48;
          *(_WORD *)&v24[8] = 1024;
          *(_DWORD *)&v24[10] = v12;
          __int16 v25 = 1024;
          int v26 = add_explicit + 1;
          _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d High allocation count for %s allocator. New allocation size:%d count:%d", (uint8_t *)&v17, 0x32u);
        }
      }
      if (!*(unsigned char *)(a3 + 128))
      {
        *(unsigned char *)(a3 + 128) = 1;
        VCUtil_GenerateDiagnostics(0, 0, "Terminating due to high allocation count", 1u);
      }
    }
    if (v8)
    {
LABEL_14:
      double v13 = (double)(int)(atomic_fetch_add_explicit((atomic_uint *volatile)(a3 + 16), 1u, memory_order_relaxed) + 1);
      double v14 = *(double *)(a3 + 120);
      if (v14 > v13) {
        double v13 = v13 * 0.0196078431 + v14 * 0.980392157;
      }
      *(double *)(a3 + 120) = v13;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v6 = VRTraceErrorLogLevelToCSTR();
      uint64_t v7 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        int v16 = *(_DWORD *)(a3 + 20);
        int v17 = 136316162;
        uint64_t v18 = v6;
        __int16 v19 = 2080;
        int v20 = "_VCAllocatorFirstComeCallback_Alloc";
        __int16 v21 = 1024;
        int v22 = 138;
        __int16 v23 = 1024;
        *(_DWORD *)uint64_t v24 = v16;
        *(_WORD *)&v24[4] = 2048;
        *(void *)&v24[6] = a1;
        _os_log_error_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_ERROR, " [%s] %s:%d First come allocator callback received allocation size request that does not match expectations. bufferSize=%d, size=%zu", (uint8_t *)&v17, 0x2Cu);
      }
    }
    return 0;
  }
  return v8;
}

void *_VCAllocatorFirstComeCallback_Realloc(void *result, int a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a4 + 20) <= a2)
  {
    _VCAllocatorFirstComeCallback_Dealloc(result, a4);
    return 0;
  }
  return result;
}

void _VCAllocatorFirstComeCallback_Dealloc(void *__new, uint64_t a2)
{
  atomic_fetch_add_explicit((atomic_uint *volatile)(a2 + 16), 0xFFFFFFFF, memory_order_relaxed);
  if (*(unsigned char *)(a2 + 118) && (double v2 = ceil(*(double *)(a2 + 120)), v2 + v2 < (double)*(int *)(a2 + 12)))
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(a2 + 12), 0xFFFFFFFF, memory_order_relaxed);
    CFAllocatorDeallocate(*(CFAllocatorRef *)a2, __new);
  }
  else
  {
    OSAtomicEnqueue((OSQueueHead *)(a2 + 32), __new, 0);
  }
}

void _VCAllocatorFirstCome_FinalizeInfo(uint64_t a1)
{
  if (a1)
  {
    double v2 = (OSQueueHead *)(a1 + 32);
    unint64_t v3 = OSAtomicDequeue((OSQueueHead *)(a1 + 32), 0);
    if (v3)
    {
      uint64_t v4 = v3;
      do
      {
        CFAllocatorDeallocate(*(CFAllocatorRef *)a1, v4);
        uint64_t v4 = OSAtomicDequeue(v2, 0);
      }
      while (v4);
    }
    if (*(void *)a1) {
      CFRelease(*(CFTypeRef *)a1);
    }
    *(void *)a1 = 0;
  }
}

uint64_t _VCTransportSession_DeactivatedNotificationHandler(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return [a2 handleTransportStreamDeactivated:a4];
}

void sub_1E223AEE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
}

uint64_t VCRemoteVideoManager_DefaultManager()
{
  if (VCRemoteVideoManager_DefaultManager_onceToken != -1) {
    dispatch_once(&VCRemoteVideoManager_DefaultManager_onceToken, &__block_literal_global_59);
  }
  return _vcRemoteVideoManager;
}

void sub_1E223DBBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void VCRemoteVideoManager_DidReceiveFirstRemoteFrameForStreamToken(uint64_t a1, uint64_t a2)
{
  void block[6] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    double v2 = *(NSObject **)(a1 + 24);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __VCRemoteVideoManager_DidReceiveFirstRemoteFrameForStreamToken_block_invoke;
    block[3] = &unk_1E6DB4568;
    block[4] = a1;
    block[5] = a2;
    dispatch_async(v2, block);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRemoteVideoManager_DidReceiveFirstRemoteFrameForStreamToken_cold_1();
    }
  }
}

void _VCRemoteVideoManager_DispatchedDidReceiveFirstRemoteFrameForStreamToken(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t valuePtr = a2;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    int v5 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      uint64_t v11 = v4;
      __int16 v12 = 2080;
      double v13 = "_VCRemoteVideoManager_DispatchedDidReceiveFirstRemoteFrameForStreamToken";
      __int16 v14 = 1024;
      int v15 = 258;
      __int16 v16 = 2048;
      uint64_t v17 = a2;
      _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d streamToken[%ld]", buf, 0x26u);
    }
  }
  CFNumberRef v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberNSIntegerType, &valuePtr);
  objc_msgSend((id)objc_msgSend(*(id *)(a1 + 16), "objectForKeyedSubscript:", v6), "setHasReceivedFirstFrame:", 1);
  uint64_t v7 = *(NSObject **)(a1 + 32);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  _OWORD v8[2] = ___VCRemoteVideoManager_DispatchedDidReceiveFirstRemoteFrameForStreamToken_block_invoke;
  v8[3] = &unk_1E6DB3DC8;
  v8[4] = v6;
  dispatch_async(v7, v8);
  if (v6) {
    CFRelease(v6);
  }
}

void VCRemoteVideoManager_RemoteScreenAttributesDidChange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[7] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    unint64_t v3 = *(NSObject **)(a1 + 24);
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 3221225472;
    v4[2] = __VCRemoteVideoManager_RemoteScreenAttributesDidChange_block_invoke;
    v4[3] = &unk_1E6DB5450;
    v4[4] = a1;
    v4[5] = a2;
    v4[6] = a3;
    dispatch_async(v3, v4);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRemoteVideoManager_RemoteScreenAttributesDidChange_cold_1();
    }
  }
}

void _VCRemoteVideoManager_DispatchedRemoteScreenAttributesDidChange(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t valuePtr = a3;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    uint64_t v6 = VRTraceErrorLogLevelToCSTR();
    uint64_t v7 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      if (a2) {
        uint64_t v8 = (const char *)objc_msgSend((id)objc_msgSend(a2, "description"), "UTF8String");
      }
      else {
        uint64_t v8 = "<nil>";
      }
      *(_DWORD *)buf = 136316162;
      uint64_t v16 = v6;
      __int16 v17 = 2080;
      uint64_t v18 = "_VCRemoteVideoManager_DispatchedRemoteScreenAttributesDidChange";
      __int16 v19 = 1024;
      int v20 = 287;
      __int16 v21 = 2048;
      uint64_t v22 = a3;
      __int16 v23 = 2080;
      uint64_t v24 = v8;
      _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d streamToken[%ld] screenAttributes[%s]", buf, 0x30u);
    }
  }
  CFNumberRef v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberNSIntegerType, &valuePtr);
  objc_msgSend((id)objc_msgSend(*(id *)(a1 + 16), "objectForKeyedSubscript:", v9), "setRemoteScreenAttributes:", a2);
  uint64_t v10 = (void *)[a2 copyEncodedDictionary];
  uint64_t v11 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9E8]), "initWithObjectsAndKeys:", v10, @"conferenceRemoteScreenAttributes", 0);
  __int16 v12 = *(NSObject **)(a1 + 32);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___VCRemoteVideoManager_DispatchedRemoteScreenAttributesDidChange_block_invoke;
  block[3] = &unk_1E6DB3E40;
  block[4] = v11;
  block[5] = v9;
  dispatch_async(v12, block);

  if (v9) {
    CFRelease(v9);
  }
}

void VCRemoteVideoManager_RemoteVideoAttributesDidChange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[7] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    unint64_t v3 = *(NSObject **)(a1 + 24);
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 3221225472;
    v4[2] = __VCRemoteVideoManager_RemoteVideoAttributesDidChange_block_invoke;
    v4[3] = &unk_1E6DB5450;
    v4[4] = a1;
    v4[5] = a2;
    v4[6] = a3;
    dispatch_async(v3, v4);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRemoteVideoManager_RemoteVideoAttributesDidChange_cold_1();
    }
  }
}

void _VCRemoteVideoManager_DispatchedRemoteVideoAttributesDidChange(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t valuePtr = a3;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    uint64_t v6 = VRTraceErrorLogLevelToCSTR();
    uint64_t v7 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      if (a2) {
        uint64_t v8 = (const char *)objc_msgSend((id)objc_msgSend(a2, "description"), "UTF8String");
      }
      else {
        uint64_t v8 = "<nil>";
      }
      *(_DWORD *)buf = 136316162;
      uint64_t v17 = v6;
      __int16 v18 = 2080;
      __int16 v19 = "_VCRemoteVideoManager_DispatchedRemoteVideoAttributesDidChange";
      __int16 v20 = 1024;
      int v21 = 321;
      __int16 v22 = 2048;
      uint64_t v23 = a3;
      __int16 v24 = 2080;
      uint64_t v25 = v8;
      _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d streamToken[%ld] videoAttributes[%s]", buf, 0x30u);
    }
  }
  CFNumberRef v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberNSIntegerType, &valuePtr);
  objc_msgSend((id)objc_msgSend(*(id *)(a1 + 16), "objectForKeyedSubscript:", v9), "setRemoteVideoAttributes:", a2);
  if ([*(id *)(a1 + 8) objectForKeyedSubscript:v9])
  {
    QueueForStreamToken = (void *)_VCRemoteVideoManager_GetQueueForStreamToken(a1, valuePtr, 0);
    VCImageQueue_remoteVideoAttributesChanged(QueueForStreamToken, a2);
  }
  uint64_t v11 = (void *)[a2 copyEncodedDictionary];
  __int16 v12 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9E8]), "initWithObjectsAndKeys:", v11, @"conferenceRemoteVideoAttributes", 0);
  double v13 = *(NSObject **)(a1 + 32);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___VCRemoteVideoManager_DispatchedRemoteVideoAttributesDidChange_block_invoke;
  block[3] = &unk_1E6DB3E40;
  block[4] = v12;
  block[5] = v9;
  dispatch_async(v13, block);

  if (v9) {
    CFRelease(v9);
  }
}

uint64_t _VCRemoteVideoManager_GetQueueForStreamToken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend(*(id *)(a1 + 8), "objectForKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", a2));
  if (!v4) {
    return 0;
  }
  uint64_t result = objc_msgSend(v4, "objectForKeyedSubscript:", objc_msgSend(NSNumber, "numberWithInt:", a3));
  if (!result) {
    return 0;
  }
  return result;
}

void VCCellularAudioTap_ProcessAudioCallback(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    VCAudioPowerSpectrumSource_ProcessAudioSamples(*(void *)(a1 + 16), a2);
    int Timestamp = VCAudioBufferList_GetTimestamp(a2);
    int v5 = *(_DWORD *)(a1 + 8);
    if (v5 == 1)
    {
      VCMediaRecorder_AddRemoteAudioSampleBuffer(*(void *)(a1 + 24), a2, Timestamp);
    }
    else if (!v5)
    {
      VCMediaRecorder_AddLocalAudioSampleBuffer(*(void *)(a1 + 24), a2, Timestamp);
    }
    *(float *)(a1 + 32) = VCAudioBufferList_GetAveragePower(a2);
  }
}

void sub_1E22474EC(_Unwind_Exception *exception_object)
{
}

void networkProc(void *a1)
{
  if (a1)
  {
    [a1 processNetwork];
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      networkProc_cold_1();
    }
  }
}

void sub_1E22476F0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL VCAudioStructs_StreamDescriptionIsEqual(void *__s1, const void *a2)
{
  BOOL result = 0;
  if (__s1)
  {
    if (a2) {
      return memcmp(__s1, a2, 0x28uLL) == 0;
    }
  }
  return result;
}

void VCAudioStructs_PrintFrameFormat(uint64_t a1, uint64_t *a2)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  int v5 = (os_log_t *)MEMORY[0x1E4F47A50];
  if (ErrorLogLevelForModule >= 7)
  {
    uint64_t v6 = VRTraceErrorLogLevelToCSTR();
    uint64_t v7 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      int v19 = 136315906;
      uint64_t v20 = v6;
      __int16 v21 = 2080;
      __int16 v22 = "VCAudioStructs_PrintFrameFormat";
      __int16 v23 = 1024;
      int v24 = 23;
      __int16 v25 = 2080;
      uint64_t v26 = a1;
      _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %s mSampleRate : mFormatID : mFormatFlags : mBytesPerPacket : mFramesPerPacket : mBytesPerFrame : mChannelsPerFrame : mBitsPerChannel : samplesPerFrame ", (uint8_t *)&v19, 0x26u);
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v8 = VRTraceErrorLogLevelToCSTR();
    CFNumberRef v9 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *a2;
      uint64_t v11 = FourccToCStr(*((_DWORD *)a2 + 2));
      int v12 = *((_DWORD *)a2 + 3);
      int v13 = *((_DWORD *)a2 + 4);
      int v14 = *((_DWORD *)a2 + 5);
      int v15 = *((_DWORD *)a2 + 6);
      int v16 = *((_DWORD *)a2 + 7);
      int v17 = *((_DWORD *)a2 + 8);
      int v18 = *((_DWORD *)a2 + 10);
      int v19 = 136318210;
      uint64_t v20 = v8;
      __int16 v21 = 2080;
      __int16 v22 = "VCAudioStructs_PrintFrameFormat";
      __int16 v23 = 1024;
      int v24 = 34;
      __int16 v25 = 2080;
      uint64_t v26 = a1;
      __int16 v27 = 2048;
      uint64_t v28 = v10;
      __int16 v29 = 2080;
      __int16 v30 = v11;
      __int16 v31 = 1024;
      int v32 = v12;
      __int16 v33 = 1024;
      int v34 = v13;
      __int16 v35 = 1024;
      int v36 = v14;
      __int16 v37 = 1024;
      int v38 = v15;
      __int16 v39 = 1024;
      int v40 = v16;
      __int16 v41 = 1024;
      int v42 = v17;
      __int16 v43 = 1024;
      int v44 = v18;
      _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %s %8.0f    : %7s   :  0x%08x  : %8u        : %9u        : %8u       : %9u         : %9u       : %9u       ", (uint8_t *)&v19, 0x64u);
    }
  }
}

uint64_t VCAudioStructs_ClientTimestampForControllerTime(unsigned int *a1, unsigned int a2, double a3)
{
  uint64_t v3 = *((void *)a1 + 4);
  if (v3 - a2 < 0x7FFFFFFF && v3 != a2) {
    v3 += 0xFFFFFFFFLL;
  }
  unint64_t v5 = v3 & 0xFFFFFFFF00000000 | a2;
  *((void *)a1 + 4) = v5;
  uint64_t v6 = *a1;
  unint64_t v7 = v5 * v6 / a1[1];
  if (*((unsigned char *)a1 + 8))
  {
    if (*((unsigned char *)a1 + 9)) {
      a1[7] = a1[6] - v7 + ((a3 - *((double *)a1 + 2)) * (double)v6);
    }
    *((unsigned char *)a1 + 8) = 0;
  }
  uint64_t v8 = a1[7] + v7;
  *((double *)a1 + 2) = a3;
  *((unsigned char *)a1 + 9) = 1;
  a1[6] = v8;
  return v8;
}

uint64_t VCCryptor_GetCipherSuite(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 48);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
    return 0;
  }
  VRTraceErrorLogLevelToCSTR();
  uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
  if (result)
  {
    VCCryptor_GetCipherSuite_cold_1();
    return 0;
  }
  return result;
}

uint64_t VCCryptor_ComposeSFrameHeaderWithCounterAndMKI(unsigned char *a1, void *a2, void *a3, unint64_t a4)
{
  __src[2] = *MEMORY[0x1E4F143B8];
  unsigned int v4 = (71 - __clz(a4)) >> 3;
  if (a4) {
    size_t v5 = v4;
  }
  else {
    size_t v5 = 1;
  }
  if (a1)
  {
    if (a2)
    {
      if (*a2 < v5 + 9)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        {
          return 2151678015;
        }
        else
        {
          VRTraceErrorLogLevelToCSTR();
          uint64_t v9 = 2151678015;
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCCryptor_ComposeSFrameHeaderWithCounterAndMKI_cold_3();
          }
        }
      }
      else if (a3)
      {
        unint64_t v11 = bswap64(a4);
        memcpy(a1 + 9, (char *)__src - v5, v5);
        *a1 = (16 * v5 + 112) & 0x70 | 0xF;
        __src[0] = 0;
        __src[1] = 0;
        VCMediaKeyIndex_FullKeyBytes(a3, (const char *)__src);
        memcpy(a1 + 1, __src, (*a1 & 7) + 1);
        uint64_t v9 = 0;
        *a2 = v5 + 9;
      }
      else
      {
        uint64_t v9 = 2151677953;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCCryptor_ComposeSFrameHeaderWithCounterAndMKI_cold_4();
          }
        }
      }
    }
    else
    {
      uint64_t v9 = 2151677953;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCCryptor_ComposeSFrameHeaderWithCounterAndMKI_cold_2();
        }
      }
    }
  }
  else
  {
    uint64_t v9 = 2151677953;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCCryptor_ComposeSFrameHeaderWithCounterAndMKI_cold_1();
      }
    }
  }
  return v9;
}

uint64_t VCCryptor_ParseSFrameHeader(unsigned __int8 *a1, unint64_t a2, uint64_t a3, void *a4, void *a5, unint64_t *a6)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      if (a4)
      {
        if (a5)
        {
          if (a6)
          {
            int v10 = (char)*a1;
            if (v10 < 0)
            {
              uint64_t v14 = 2151677953;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  VCCryptor_ParseSFrameHeader_cold_6();
                }
              }
            }
            else
            {
              if ((v10 & 8) != 0)
              {
                size_t v11 = (*a1 & 7) + 1;
                unint64_t v12 = v11 + ((unint64_t)*a1 >> 4) + 2;
                if (a3 + v12 + 1 <= a2)
                {
                  v17[0] = 0;
                  memcpy((char *)&v17[1] - v11, a1 + 1, v11);
                  id MKIWithBytes = VCMediaKeyIndex_CreateMKIWithBytes((uint64_t)v17, 8);
                  if (MKIWithBytes)
                  {
                    *a4 = MKIWithBytes;
                    unint64_t v16 = 0;
                    memcpy((char *)&v16 - (((unint64_t)*a1 >> 4) & 7) + 7, &a1[(*a1 & 7) + 2], (((unint64_t)*a1 >> 4) & 7) + 1);
                    uint64_t v14 = 0;
                    *a5 = bswap64(v16);
                    *a6 = v12;
                  }
                  else
                  {
                    uint64_t v14 = 2151677953;
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                        VCCryptor_ParseSFrameHeader_cold_9();
                      }
                    }
                  }
                  return v14;
                }
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  uint64_t v14 = 2151678015;
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                    VCCryptor_ParseSFrameHeader_cold_8();
                  }
                  return v14;
                }
                return 2151678015;
              }
              uint64_t v14 = 2151677953;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  VCCryptor_ParseSFrameHeader_cold_7();
                }
              }
            }
          }
          else
          {
            uint64_t v14 = 2151677953;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                VCCryptor_ParseSFrameHeader_cold_5();
              }
            }
          }
        }
        else
        {
          uint64_t v14 = 2151677953;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              VCCryptor_ParseSFrameHeader_cold_4();
            }
          }
        }
      }
      else
      {
        uint64_t v14 = 2151677953;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCCryptor_ParseSFrameHeader_cold_3();
          }
        }
      }
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
        return 2151678015;
      }
      VRTraceErrorLogLevelToCSTR();
      uint64_t v14 = 2151678015;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCCryptor_ParseSFrameHeader_cold_2();
      }
    }
  }
  else
  {
    uint64_t v14 = 2151677953;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCCryptor_ParseSFrameHeader_cold_1();
      }
    }
  }
  return v14;
}

uint64_t _VCCryptor_ValidateAuthenticationTag(uint64_t a1, char *a2, unint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  int CipherSuite = VCCryptor_GetCipherSuite(a1);
  uint64_t v7 = 4;
  if (CipherSuite == 1) {
    uint64_t v7 = 10;
  }
  if (CipherSuite) {
    size_t v8 = v7;
  }
  else {
    size_t v8 = 0;
  }
  if (a3 <= v8)
  {
    uint64_t v9 = 2151678015;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCCryptor_ValidateAuthenticationTag_cold_1();
      }
    }
  }
  else
  {
    memset(v11, 0, sizeof(v11));
    CCHmac(2u, (const void *)(a1 + 128), 0x20uLL, a2, a3 - v8, v11);
    if (!memcmp(&a2[a3 - v8], v11, v8))
    {
      return 0;
    }
    else
    {
      CCCryptorRelease(*(CCCryptorRef *)(a1 + 8360));
      *(void *)(a1 + 8360) = 0;
      return 2151678022;
    }
  }
  return v9;
}

uint64_t _VCCryptorClassRegister(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t VCCryptor_Create(uint64_t a1, int a2, const void *a3, const void *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (a6)
  {
    if (a4)
    {
      if ((a2 - 3) <= 0xFFFFFFFD)
      {
        uint64_t v17 = 2151677953;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCCryptor_Create_cold_3();
          }
        }
      }
      else if (a3)
      {
        if (VCCryptorGetTypeID_initOnce != -1) {
          dispatch_once_f(&VCCryptorGetTypeID_initOnce, &VCCryptorGetTypeID_typeID, (dispatch_function_t)_VCCryptorClassRegister);
        }
        uint64_t Instance = _CFRuntimeCreateInstance();
        if (Instance)
        {
          uint64_t v12 = Instance;
          bzero((void *)(Instance + 16), 0x20A0uLL);
          *(_DWORD *)(v12 + 48) = a2;
          *(void *)(v12 + 40) = CFRetain(a3);
          *(void *)(v12 + 16) = CFRetain(a4);
          atomic_store(0, (unsigned __int8 *)(v12 + 32));
          *(void *)(v12 + 160) = -1;
          *(unsigned char *)(v12 + 35) = 1;
          if (a5)
          {
            FigCFDictionaryGetBooleanIfPresent();
            *(unsigned char *)(v12 + 35) = 1;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
            {
              uint64_t v13 = VRTraceErrorLogLevelToCSTR();
              uint64_t v14 = *MEMORY[0x1E4F47A50];
              int v15 = *MEMORY[0x1E4F47A50];
              if (*MEMORY[0x1E4F47A40])
              {
                if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
                {
                  int v16 = *(unsigned __int8 *)(v12 + 35);
                  *(_DWORD *)buf = 136316162;
                  uint64_t v21 = v13;
                  __int16 v22 = 2080;
                  __int16 v23 = "VCCryptor_Create";
                  __int16 v24 = 1024;
                  int v25 = 550;
                  __int16 v26 = 2048;
                  uint64_t v27 = v12;
                  __int16 v28 = 1024;
                  int v29 = v16;
                  _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [%p] isReplayProtectionEnabled=%d", buf, 0x2Cu);
                }
              }
              else if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
              {
                int v19 = *(unsigned __int8 *)(v12 + 35);
                *(_DWORD *)buf = 136316162;
                uint64_t v21 = v13;
                __int16 v22 = 2080;
                __int16 v23 = "VCCryptor_Create";
                __int16 v24 = 1024;
                int v25 = 550;
                __int16 v26 = 2048;
                uint64_t v27 = v12;
                __int16 v28 = 1024;
                int v29 = v19;
                _os_log_debug_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEBUG, " [%s] %s:%d [%p] isReplayProtectionEnabled=%d", buf, 0x2Cu);
              }
            }
          }
          uint64_t v17 = 0;
          *a6 = v12;
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        {
          return 2151677955;
        }
        else
        {
          VRTraceErrorLogLevelToCSTR();
          uint64_t v17 = 2151677955;
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCCryptor_Create_cold_5();
          }
        }
      }
      else
      {
        uint64_t v17 = 2151677953;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCCryptor_Create_cold_4();
          }
        }
      }
    }
    else
    {
      uint64_t v17 = 2151677953;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCCryptor_Create_cold_2();
        }
      }
    }
  }
  else
  {
    uint64_t v17 = 2151677953;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCCryptor_Create_cold_1();
      }
    }
  }
  return v17;
}

uint64_t VCCryptor_Encrypt(uint64_t a1, OpaqueCMBlockBuffer *a2, CFTypeRef *a3)
{
  iv[2] = *MEMORY[0x1E4F143B8];
  CMBlockBufferRef theBuffer = 0;
  uint64_t v6 = _VCCryptor_ValidateCryptographyInputParameters(a1, a2, (uint64_t)a3, 1);
  if (v6)
  {
    uint64_t v24 = v6;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCCryptor_Encrypt_cold_11();
      }
    }
    goto LABEL_29;
  }
  if (_VCCryptor_EnsureCryptorIsReady(a1, 0, 0))
  {
    uint64_t v24 = 2151677969;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCCryptor_Encrypt_cold_10();
      }
    }
    goto LABEL_29;
  }
  unint64_t v7 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = v7 + 1;
  iv[0] = 0xAAAAAAAAAAAAAAAALL;
  iv[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = _VCCryptor_DeriveIV(a1, v7, iv);
  if (v8)
  {
    uint64_t v24 = v8;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCCryptor_Encrypt_cold_9();
      }
    }
    goto LABEL_29;
  }
  DataCFIndex Length = CMBlockBufferGetDataLength(a2);
  if (!CMBlockBufferIsRangeContiguous(a2, 0, DataLength))
  {
    uint64_t v24 = 2151678024;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        VCCryptor_Encrypt_cold_1();
        uint64_t v24 = 2151678024;
      }
    }
    goto LABEL_29;
  }
  int CipherSuite = VCCryptor_GetCipherSuite(a1);
  uint64_t v11 = 13;
  if (CipherSuite == 1) {
    uint64_t v11 = 19;
  }
  if (!CipherSuite) {
    uint64_t v11 = 9;
  }
  unint64_t v12 = (71 - __clz(v7)) >> 3;
  if (!v7) {
    unint64_t v12 = 1;
  }
  size_t v13 = DataLength + v11 + v12;
  if (*a3)
  {
    uint64_t v14 = (OpaqueCMBlockBuffer *)CFRetain(*a3);
    CMBlockBufferRef theBuffer = v14;
  }
  else
  {
    uint64_t v15 = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v13, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, v13, 1u, &theBuffer);
    if (v15)
    {
      uint64_t v24 = v15;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCCryptor_Encrypt_cold_8();
        }
      }
      goto LABEL_29;
    }
    uint64_t v14 = theBuffer;
  }
  dataPointerOut = 0;
  uint64_t DataPointer = CMBlockBufferGetDataPointer(v14, 0, 0, 0, &dataPointerOut);
  if (DataPointer)
  {
    uint64_t v24 = DataPointer;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCCryptor_Encrypt_cold_7();
      }
    }
  }
  else
  {
    unint64_t v30 = v13;
    uint64_t v17 = VCCryptor_ComposeSFrameHeaderWithCounterAndMKI(dataPointerOut, &v30, *(void **)(a1 + 24), v7);
    if (v17)
    {
      uint64_t v24 = v17;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCCryptor_Encrypt_cold_6();
        }
      }
    }
    else if (v30 <= 9)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      {
        uint64_t v24 = 2151678015;
      }
      else
      {
        VRTraceErrorLogLevelToCSTR();
        uint64_t v24 = 2151678015;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCCryptor_Encrypt_cold_2();
        }
      }
    }
    else
    {
      uint64_t v18 = CCCryptorReset(*(CCCryptorRef *)(a1 + 8360), iv);
      if (v18)
      {
        uint64_t v24 = v18;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCCryptor_Encrypt_cold_5();
          }
        }
      }
      else
      {
        int v29 = 0;
        uint64_t v19 = CMBlockBufferGetDataPointer(a2, 0, 0, 0, &v29);
        if (v19)
        {
          uint64_t v24 = v19;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              VCCryptor_Encrypt_cold_4();
            }
          }
        }
        else
        {
          size_t dataOutMoved = 0;
          int v20 = VCCryptor_GetCipherSuite(a1);
          uint64_t v21 = 4;
          if (v20 == 1) {
            uint64_t v21 = 10;
          }
          if (v20) {
            size_t v22 = v21;
          }
          else {
            size_t v22 = 0;
          }
          uint64_t v23 = CCCryptorUpdate(*(CCCryptorRef *)(a1 + 8360), v29, DataLength, &dataPointerOut[v30], v13 - v22, &dataOutMoved);
          if (v23)
          {
            uint64_t v24 = v23;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                VCCryptor_Encrypt_cold_3();
              }
            }
          }
          else if (dataOutMoved == DataLength)
          {
            memset(macOut, 0, sizeof(macOut));
            CCHmac(2u, (const void *)(a1 + 128), 0x20uLL, dataPointerOut, dataOutMoved + v30, macOut);
            memcpy(&dataPointerOut[v30 + dataOutMoved], macOut, v22);
            if (!*a3)
            {
              uint64_t v24 = 0;
              *a3 = theBuffer;
              return v24;
            }
            uint64_t v24 = 0;
          }
          else
          {
            uint64_t v24 = 2151678020;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              uint64_t v26 = VRTraceErrorLogLevelToCSTR();
              uint64_t v27 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136316162;
                uint64_t v35 = v26;
                __int16 v36 = 2080;
                __int16 v37 = "VCCryptor_Encrypt";
                __int16 v38 = 1024;
                int v39 = 632;
                __int16 v40 = 2048;
                size_t v41 = DataLength;
                __int16 v42 = 2048;
                size_t v43 = dataOutMoved;
                _os_log_error_impl(&dword_1E1EA4000, v27, OS_LOG_TYPE_ERROR, " [%s] %s:%d Encryptor should have encryped at least '%zu' bytes bu only encryped '%zu' bytes", buf, 0x30u);
                uint64_t v24 = 2151678020;
              }
            }
          }
        }
      }
    }
  }
LABEL_29:
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  return v24;
}

uint64_t _VCCryptor_ValidateCryptographyInputParameters(uint64_t a1, CMBlockBufferRef theBuffer, uint64_t a3, int a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (theBuffer)
    {
      if (a3)
      {
        DataCFIndex Length = CMBlockBufferGetDataLength(theBuffer);
        size_t v7 = DataLength;
        if (a4)
        {
          if (!DataLength)
          {
            uint64_t v8 = 2151677953;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                _VCCryptor_ValidateCryptographyInputParameters_cold_4();
              }
            }
            return v8;
          }
          return 0;
        }
        int CipherSuite = VCCryptor_GetCipherSuite(a1);
        uint64_t v10 = 14;
        if (CipherSuite == 1) {
          uint64_t v10 = 20;
        }
        if (CipherSuite) {
          unint64_t v11 = v10;
        }
        else {
          unint64_t v11 = 10;
        }
        if (v7 > v11) {
          return 0;
        }
        size_t v13 = v7;
        uint64_t v8 = 2151677953;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          unint64_t v16 = v11;
          uint64_t v14 = VRTraceErrorLogLevelToCSTR();
          uint64_t v15 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316162;
            uint64_t v18 = v14;
            __int16 v19 = 2080;
            int v20 = "_VCCryptor_ValidateCryptographyInputParameters";
            __int16 v21 = 1024;
            int v22 = 307;
            __int16 v23 = 2048;
            size_t v24 = v13;
            __int16 v25 = 2048;
            uint64_t v26 = v16 | 1;
            _os_log_error_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_ERROR, " [%s] %s:%d inputBuffer contains incorrect data size '%zu'. Expected at least '%zu' bytes of input data", buf, 0x30u);
          }
        }
      }
      else
      {
        uint64_t v8 = 2151677953;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VCCryptor_ValidateCryptographyInputParameters_cold_3();
          }
        }
      }
    }
    else
    {
      uint64_t v8 = 2151677953;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCCryptor_ValidateCryptographyInputParameters_cold_2();
        }
      }
    }
  }
  else
  {
    uint64_t v8 = 2151677953;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCCryptor_ValidateCryptographyInputParameters_cold_1();
      }
    }
  }
  return v8;
}

uint64_t _VCCryptor_EnsureCryptorIsReady(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  CFArrayRef theArray = 0;
  unsigned __int8 v6 = atomic_exchange((atomic_uchar *volatile)(a1 + 32), 0);
  if (a2)
  {
    int v7 = v6 & 1;
    isStartingWithint Prefix = VCMediaKeyIndex_isStartingWithPrefix(*(void *)(a1 + 24), (uint64_t)a2);
    if (*(void *)(a1 + 8360)) {
      BOOL v9 = !isStartingWithPrefix;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9 || v7 != 0)
    {
      unint64_t v11 = (CCCryptorRef *)(a1 + 8360);
LABEL_17:
      uint64_t v16 = VCSecurityKeyHolder_CopyKeyMaterialForKeyIndex(*(void *)(a1 + 16), a2, (uint64_t *)&theArray);
      if (v16)
      {
        uint64_t v33 = v16;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          uint64_t v37 = VRTraceErrorLogLevelToCSTR();
          __int16 v38 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VCCryptor_EnsureCryptorIsReady_cold_14(v37, a2, v38);
          }
        }
      }
      else if (theArray)
      {
        if (CFArrayGetCount(theArray) < 1)
        {
          uint64_t v33 = 2151677969;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            uint64_t v41 = VRTraceErrorLogLevelToCSTR();
            __int16 v42 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              _VCCryptor_EnsureCryptorIsReady_cold_2(v41, a2, v42);
            }
          }
        }
        else
        {
          CFIndex v17 = 0;
          while (1)
          {
            CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v17);
            CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(ValueAtIndex, @"SecurityLocallyGenerated");
            int v20 = CFBooleanGetValue(Value);
            if (!a2 && !v20) {
              break;
            }
            if (a3)
            {
              CFDictionaryGetValue(ValueAtIndex, @"SecurityKeyIndex");
              if (FigCFArrayContainsValue()) {
                BOOL v21 = 1;
              }
              else {
                BOOL v21 = ValueAtIndex == 0;
              }
              if (!v21)
              {
LABEL_32:
                memset(buffer, 0, 32);
                *(void *)__int16 v52 = 0;
                uint64_t v53 = 0;
                CCCryptorRelease(*v11);
                *unint64_t v11 = 0;
                CFDataRef v22 = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, @"SecurityKey");
                if (v22)
                {
                  CFDataRef v23 = v22;
                  unint64_t Length = CFDataGetLength(v22);
                  CFDataRef v25 = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, @"SecuritySalt");
                  if (v25)
                  {
                    CFDataRef v26 = v25;
                    unint64_t v27 = CFDataGetLength(v25);
                    __int16 v28 = (void *)CFDictionaryGetValue(ValueAtIndex, @"SecurityKeyIndex");
                    if (v28)
                    {
                      int v29 = v28;
                      CFBooleanRef v30 = (const __CFBoolean *)CFDictionaryGetValue(ValueAtIndex, @"SecurityLocallyGenerated");
                      if (v30)
                      {
                        CFBooleanRef BOOLean = v30;
                        if (Length >= 0x20) {
                          unint64_t Length = 32;
                        }
                        if (v27 >= 0x10) {
                          unint64_t v27 = 16;
                        }
                        v55.location = 0;
                        v55.length = Length;
                        CFDataGetBytes(v23, v55, buffer);
                        v56.location = 0;
                        v56.length = v27;
                        CFDataGetBytes(v26, v56, v52);
                        CFDataGetBytePtr(*(CFDataRef *)(a1 + 40));
                        CFDataGetLength(*(CFDataRef *)(a1 + 40));
                        if (CCKeyDerivationHMac())
                        {
                          uint64_t v33 = 2151678023;
                          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                          {
                            VRTraceErrorLogLevelToCSTR();
                            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
                            {
                              _VCCryptor_EnsureCryptorIsReady_cold_12();
                              goto LABEL_98;
                            }
                          }
                        }
                        else if (CCKeyDerivationHMac())
                        {
                          uint64_t v33 = 2151678023;
                          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                          {
                            VRTraceErrorLogLevelToCSTR();
                            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
                            {
                              _VCCryptor_EnsureCryptorIsReady_cold_11();
                              goto LABEL_98;
                            }
                          }
                        }
                        else if (CCKeyDerivationHMac())
                        {
                          uint64_t v33 = 2151678023;
                          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                          {
                            VRTraceErrorLogLevelToCSTR();
                            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
                            {
                              _VCCryptor_EnsureCryptorIsReady_cold_10();
                              goto LABEL_98;
                            }
                          }
                        }
                        else if (CCKeyDerivationHMac())
                        {
                          uint64_t v33 = 2151678023;
                          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                          {
                            VRTraceErrorLogLevelToCSTR();
                            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
                            {
                              _VCCryptor_EnsureCryptorIsReady_cold_9();
                              goto LABEL_98;
                            }
                          }
                        }
                        else
                        {
                          CCOperation v31 = CFBooleanGetValue(BOOLean) == 0;
                          if (!CCCryptorCreateWithMode(v31, 4u, 0, 0, 0, (const void *)(a1 + 96), 0x10uLL, 0, 0, 0, 2u, v11))
                          {
                            VCMediaKeyIndex_ReleaseAndCopyNewValue((const void **)(a1 + 24), v29);
                            uint64_t v33 = 0;
                            *(unsigned char *)(a1 + 34) = 0;
                            goto LABEL_55;
                          }
                          uint64_t v33 = 2151678023;
                          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                          {
                            VRTraceErrorLogLevelToCSTR();
                            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
                            {
                              _VCCryptor_EnsureCryptorIsReady_cold_8();
LABEL_98:
                              uint64_t v33 = 2151678023;
                            }
                          }
                        }
                      }
                      else
                      {
                        uint64_t v33 = 2151677969;
                        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                        {
                          VRTraceErrorLogLevelToCSTR();
                          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                            _VCCryptor_EnsureCryptorIsReady_cold_7();
                          }
                        }
                      }
                    }
                    else
                    {
                      uint64_t v33 = 2151677969;
                      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                      {
                        VRTraceErrorLogLevelToCSTR();
                        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                          _VCCryptor_EnsureCryptorIsReady_cold_6();
                        }
                      }
                    }
                  }
                  else
                  {
                    uint64_t v33 = 2151677969;
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                        _VCCryptor_EnsureCryptorIsReady_cold_5();
                      }
                    }
                  }
                }
                else
                {
                  uint64_t v33 = 2151677969;
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                      _VCCryptor_EnsureCryptorIsReady_cold_4();
                    }
                  }
                }
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                    _VCCryptor_EnsureCryptorIsReady_cold_3();
                  }
                }
                goto LABEL_55;
              }
            }
            else if (ValueAtIndex)
            {
              goto LABEL_32;
            }
            if (++v17 >= CFArrayGetCount(theArray))
            {
              uint64_t v33 = 2151677969;
              int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
              if (ErrorLogLevelForModule >= 3)
              {
                uint64_t v35 = VRTraceErrorLogLevelToCSTR();
                __int16 v36 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buffer = 136316162;
                  *(void *)&buffer[4] = v35;
                  *(_WORD *)&buffer[12] = 2080;
                  *(void *)&buffer[14] = "_VCCryptor_EnsureCryptorIsReady";
                  *(_WORD *)&buffer[22] = 1024;
                  *(_DWORD *)&buffer[24] = 458;
                  *(_WORD *)&buffer[28] = 2112;
                  *(void *)&buffer[30] = theArray;
                  __int16 v50 = 2112;
                  uint64_t v51 = a3;
                  _os_log_error_impl(&dword_1E1EA4000, v36, OS_LOG_TYPE_ERROR, " [%s] %s:%d _VCCryptor_SetupCryptor failed to find key material from '%@' with disableMKI array '%@'", buffer, 0x30u);
                }
              }
              goto LABEL_55;
            }
          }
          uint64_t v33 = 2151677969;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              _VCCryptor_EnsureCryptorIsReady_cold_13();
            }
          }
        }
      }
      else
      {
        uint64_t v33 = 2151677969;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          uint64_t v39 = VRTraceErrorLogLevelToCSTR();
          __int16 v40 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VCCryptor_EnsureCryptorIsReady_cold_1(v39, a2, v40);
          }
        }
      }
      goto LABEL_55;
    }
  }
  else
  {
    int v12 = v6 & 1;
    if (*(void *)(a1 + 8360)) {
      BOOL v13 = v12 == 0;
    }
    else {
      BOOL v13 = 0;
    }
    if (!v13)
    {
      unint64_t v11 = (CCCryptorRef *)(a1 + 8360);
      if (!*(unsigned char *)(a1 + 33))
      {
        uint64_t v14 = *(void *)(a1 + 16);
        v47[0] = MEMORY[0x1E4F143A8];
        v47[1] = 0x40000000;
        CMSampleBufferRef v47[2] = ___VCCryptor_EnsureCryptorIsReady_block_invoke;
        v47[3] = &__block_descriptor_tmp_12;
        v47[4] = a1;
        uint64_t v15 = VCSecurityKeyHolder_RegisterForKeyMaterialChangeNotification(v14, v47);
        if (v15)
        {
          uint64_t v33 = v15;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              _VCCryptor_EnsureCryptorIsReady_cold_16();
            }
          }
          goto LABEL_55;
        }
        *(unsigned char *)(a1 + 33) = 1;
      }
      goto LABEL_17;
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v43 = VRTraceErrorLogLevelToCSTR();
    int v44 = *MEMORY[0x1E4F47A50];
    uint64_t v45 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      uint64_t v33 = 0;
      if (!os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_55;
      }
      *(_DWORD *)buffer = 136315650;
      *(void *)&buffer[4] = v43;
      *(_WORD *)&buffer[12] = 2080;
      *(void *)&buffer[14] = "_VCCryptor_EnsureCryptorIsReady";
      *(_WORD *)&buffer[22] = 1024;
      *(_DWORD *)&buffer[24] = 420;
      _os_log_impl(&dword_1E1EA4000, v44, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Cryptor is valid, nothing to do here", buffer, 0x1Cu);
    }
    else if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
    {
      _VCCryptor_EnsureCryptorIsReady_cold_15();
    }
  }
  uint64_t v33 = 0;
LABEL_55:
  if (theArray) {
    CFRelease(theArray);
  }
  return v33;
}

uint64_t _VCCryptor_DeriveIV(uint64_t a1, unint64_t a2, void *a3)
{
  if (a3)
  {
    uint64_t v3 = 0;
    *a3 = bswap64(a2);
    a3[1] = 0;
    do
    {
      *((unsigned char *)a3 + v3) ^= *(unsigned char *)(a1 + 112 + v3);
      ++v3;
    }
    while (v3 != 16);
    return 0;
  }
  else
  {
    uint64_t v4 = 2151677953;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCCryptor_DeriveIV_cold_1();
      }
    }
  }
  return v4;
}

uint64_t VCCryptor_Decrypt(uint64_t a1, OpaqueCMBlockBuffer *a2, CMBlockBufferRef *a3)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  CMBlockBufferRef theBuffer = 0;
  if (_VCCryptor_ValidateCryptographyInputParameters(a1, a2, (uint64_t)a3, 0))
  {
    uint64_t v18 = 2151677953;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCCryptor_Decrypt_cold_12();
      }
    }
  }
  else
  {
    Dataunint64_t Length = CMBlockBufferGetDataLength(a2);
    if (CMBlockBufferIsRangeContiguous(a2, 0, DataLength))
    {
      dataPointerOut = 0;
      uint64_t DataPointer = CMBlockBufferGetDataPointer(a2, 0, 0, 0, &dataPointerOut);
      if (DataPointer)
      {
        uint64_t v18 = DataPointer;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCCryptor_Decrypt_cold_11();
          }
        }
      }
      else
      {
        unint64_t v45 = 0;
        unint64_t v46 = 0;
        int CipherSuite = VCCryptor_GetCipherSuite(a1);
        uint64_t v9 = 4;
        if (CipherSuite == 1) {
          uint64_t v9 = 10;
        }
        if (CipherSuite) {
          uint64_t v10 = v9;
        }
        else {
          uint64_t v10 = 0;
        }
        uint64_t v11 = VCCryptor_ParseSFrameHeader((unsigned __int8 *)dataPointerOut, DataLength, v10, &cf, &v46, &v45);
        if (v11)
        {
          uint64_t v18 = v11;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              VCCryptor_Decrypt_cold_10();
            }
          }
        }
        else if (cf)
        {
          size_t v12 = v45 + v10;
          if (DataLength >= v45 + v10)
          {
            uint64_t IsReady = _VCCryptor_EnsureCryptorIsReady(a1, (char *)cf, 0);
            if (IsReady)
            {
              uint64_t v18 = IsReady;
              goto LABEL_42;
            }
            CFMutableArrayRef Mutable = 0;
            CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            uint64_t v16 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
            while (1)
            {
              uint64_t v17 = _VCCryptor_ValidateAuthenticationTag(a1, dataPointerOut, DataLength);
              if (v17 != -2143289274) {
                break;
              }
              if (!Mutable) {
                CFMutableArrayRef Mutable = CFArrayCreateMutable(v15, 0, v16);
              }
              CFArrayAppendValue(Mutable, *(const void **)(a1 + 24));
              if (_VCCryptor_EnsureCryptorIsReady(a1, (char *)cf, (uint64_t)Mutable))
              {
                uint64_t v18 = 2151678022;
                goto LABEL_40;
              }
            }
            uint64_t v18 = v17;
            if (v17)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  VCCryptor_Decrypt_cold_3();
                }
              }
              goto LABEL_40;
            }
            unint64_t v19 = v46;
            if (*(unsigned char *)(a1 + 35))
            {
              unint64_t v20 = v46 & 0x3FF;
              unint64_t v21 = *(void *)(a1 + 8352);
              BOOL v22 = v21 >= v46;
              unint64_t v23 = v21 - v46;
              if (v22)
              {
                if (v23 > 0x3FF || *(void *)(a1 + 8 * v20 + 160) == v46)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    uint64_t v24 = VRTraceErrorLogLevelToCSTR();
                    CFDataRef v25 = *MEMORY[0x1E4F47A50];
                    uint64_t v18 = 2151678007;
                    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                      goto LABEL_40;
                    }
                    uint64_t v26 = *(void *)(a1 + 8352);
                    *(_DWORD *)buf = 136316418;
                    uint64_t v52 = v24;
                    __int16 v53 = 2080;
                    uint64_t v54 = "VCCryptor_Decrypt";
                    __int16 v55 = 1024;
                    int v56 = 707;
                    __int16 v57 = 2048;
                    size_t v58 = a1;
                    __int16 v59 = 2048;
                    size_t v60 = v46;
                    __int16 v61 = 2048;
                    uint64_t v62 = v26;
                    unint64_t v27 = " [%s] %s:%d [%p] VCCryptor_CheckReplayWindow detected replay. counter=%llu, maxReceivedCounter=%llu";
                    __int16 v28 = v25;
                    uint32_t v29 = 58;
                    goto LABEL_28;
                  }
                  int v38 = 54;
LABEL_48:
                  uint64_t v18 = v38 | 0x80400001;
                  goto LABEL_40;
                }
              }
              else
              {
                *(void *)(a1 + 8352) = v46;
              }
              *(void *)(a1 + 8 * v20 + 160) = v19;
            }
            iv[0] = 0xAAAAAAAAAAAAAAAALL;
            iv[1] = 0xAAAAAAAAAAAAAAAALL;
            uint64_t v30 = _VCCryptor_DeriveIV(a1, v19, iv);
            if (v30)
            {
              uint64_t v18 = v30;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  VCCryptor_Decrypt_cold_9();
                }
              }
              goto LABEL_40;
            }
            size_t v31 = DataLength - v10 - v45;
            uint64_t v32 = CMBlockBufferCreateWithMemoryBlock(v15, 0, v31, v15, 0, 0, v31, 1u, &theBuffer);
            if (v32)
            {
              uint64_t v18 = v32;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  VCCryptor_Decrypt_cold_8();
                }
              }
              goto LABEL_40;
            }
            int v44 = 0;
            uint64_t v33 = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &v44);
            if (v33)
            {
              uint64_t v18 = v33;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  VCCryptor_Decrypt_cold_7();
                }
              }
              goto LABEL_40;
            }
            uint64_t v34 = CCCryptorReset(*(CCCryptorRef *)(a1 + 8360), iv);
            if (v34)
            {
              uint64_t v18 = v34;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  VCCryptor_Decrypt_cold_6();
                }
              }
              goto LABEL_40;
            }
            size_t dataOutMoved = 0;
            uint64_t v35 = CCCryptorUpdate(*(CCCryptorRef *)(a1 + 8360), &dataPointerOut[v45], v31, v44, v31, &dataOutMoved);
            if (v35)
            {
              uint64_t v18 = v35;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  VCCryptor_Decrypt_cold_5();
                }
              }
              goto LABEL_40;
            }
            if (dataOutMoved == v31)
            {
              if (!*(unsigned char *)(a1 + 34))
              {
                uint64_t v36 = VCSecurityKeyHolder_AssociateKeyIndex(*(void *)(a1 + 16), *(const char **)(a1 + 24));
                if (v36)
                {
                  uint64_t v18 = v36;
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                      VCCryptor_Decrypt_cold_4();
                    }
                  }
                  goto LABEL_40;
                }
                *(unsigned char *)(a1 + 34) = 1;
              }
              uint64_t v18 = 0;
              *a3 = theBuffer;
              CMBlockBufferRef theBuffer = 0;
LABEL_40:
              if (Mutable) {
                CFRelease(Mutable);
              }
              goto LABEL_42;
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              uint64_t v41 = VRTraceErrorLogLevelToCSTR();
              __int16 v42 = *MEMORY[0x1E4F47A50];
              uint64_t v18 = 2151678021;
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                goto LABEL_40;
              }
              *(_DWORD *)buf = 136316162;
              uint64_t v52 = v41;
              __int16 v53 = 2080;
              uint64_t v54 = "VCCryptor_Decrypt";
              __int16 v55 = 1024;
              int v56 = 734;
              __int16 v57 = 2048;
              size_t v58 = v31;
              __int16 v59 = 2048;
              size_t v60 = dataOutMoved;
              unint64_t v27 = " [%s] %s:%d Decrypor should have produced at least '%zu' bytes but only produced '%zu' bytes";
              __int16 v28 = v42;
              uint32_t v29 = 48;
LABEL_28:
              _os_log_error_impl(&dword_1E1EA4000, v28, OS_LOG_TYPE_ERROR, v27, buf, v29);
              goto LABEL_40;
            }
            int v38 = 68;
            goto LABEL_48;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          {
            uint64_t v18 = 2151678015;
          }
          else
          {
            uint64_t v39 = VRTraceErrorLogLevelToCSTR();
            __int16 v40 = *MEMORY[0x1E4F47A50];
            uint64_t v18 = 2151678015;
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316162;
              uint64_t v52 = v39;
              __int16 v53 = 2080;
              uint64_t v54 = "VCCryptor_Decrypt";
              __int16 v55 = 1024;
              int v56 = 681;
              __int16 v57 = 2048;
              size_t v58 = v12;
              __int16 v59 = 2048;
              size_t v60 = DataLength;
              _os_log_error_impl(&dword_1E1EA4000, v40, OS_LOG_TYPE_ERROR, " [%s] %s:%d Size of encrypted SFrame is less than its required overhead. Minimum required size '%zu', actual size '%zu'", buf, 0x30u);
            }
          }
        }
        else
        {
          uint64_t v18 = 2151677953;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              VCCryptor_Decrypt_cold_2();
            }
          }
        }
      }
    }
    else
    {
      uint64_t v18 = 2151678024;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          VCCryptor_Decrypt_cold_1();
          uint64_t v18 = 2151678024;
        }
      }
    }
  }
LABEL_42:
  if (theBuffer) {
    CFRelease(theBuffer);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v18;
}

uint64_t VCCryptor_GetEncryptedBufferSize(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    if (a3)
    {
      unint64_t v5 = *(void *)(a1 + 56);
      int CipherSuite = VCCryptor_GetCipherSuite(a1);
      uint64_t v7 = 0;
      uint64_t v8 = 13;
      if (CipherSuite == 1) {
        uint64_t v8 = 19;
      }
      if (!CipherSuite) {
        uint64_t v8 = 9;
      }
      unint64_t v9 = (71 - __clz(v5)) >> 3;
      if (!v5) {
        unint64_t v9 = 1;
      }
      *a3 = v9 + a2 + v8;
    }
    else
    {
      uint64_t v7 = 2151677953;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCCryptor_GetEncryptedBufferSize_cold_2();
        }
      }
    }
  }
  else
  {
    uint64_t v7 = 2151677953;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCCryptor_GetEncryptedBufferSize_cold_1();
      }
    }
  }
  return v7;
}

void _VCCryptor_Finalize(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 33)) {
    VCSecurityKeyHolder_RegisterForKeyMaterialChangeNotification(*(void *)(a1 + 16), 0);
  }
  double v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 24);
  if (v3) {
    CFRelease(v3);
  }
  CCCryptorRelease(*(CCCryptorRef *)(a1 + 8360));
  uint64_t v4 = *(const void **)(a1 + 40);
  if (v4)
  {
    CFRelease(v4);
  }
}

uint64_t VCMediaNegotiationBlobCaptionsSettingsReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        char v23 = 0;
        unsigned int v24 = 0;
        uint64_t v25 = 0;
        *(unsigned char *)(a1 + 16) |= 1u;
        while (1)
        {
          uint64_t v26 = *v3;
          unint64_t v27 = *(void *)(a2 + v26);
          if (v27 == -1 || v27 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v28 = *(unsigned char *)(*(void *)(a2 + *v7) + v27);
          *(void *)(a2 + v26) = v27 + 1;
          v25 |= (unint64_t)(v28 & 0x7F) << v23;
          if ((v28 & 0x80) == 0) {
            goto LABEL_41;
          }
          v23 += 7;
          BOOL v14 = v24++ >= 9;
          if (v14)
          {
            LODWORD(v25) = 0;
            goto LABEL_43;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_41:
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v25) = 0;
        }
LABEL_43:
        *(_DWORD *)(a1 + 8) = v25;
      }
      else if ((v10 >> 3) == 1)
      {
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0;
        *(unsigned char *)(a1 + 16) |= 2u;
        while (1)
        {
          uint64_t v20 = *v3;
          unint64_t v21 = *(void *)(a2 + v20);
          if (v21 == -1 || v21 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v22 = *(unsigned char *)(*(void *)(a2 + *v7) + v21);
          *(void *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0) {
            goto LABEL_37;
          }
          v17 += 7;
          BOOL v14 = v18++ >= 9;
          if (v14)
          {
            uint64_t v19 = 0;
            goto LABEL_39;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_37:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v19 = 0;
        }
LABEL_39:
        *(unsigned char *)(a1 + 12) = v19 != 0;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t _VCMediaStream_DefaultTransport(uint64_t a1)
{
  if ([*(id *)(a1 + 544) count])
  {
    double v2 = *(void **)(a1 + 544);
    return [v2 objectAtIndexedSubscript:0];
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCMediaStream_DefaultTransport_cold_1();
      }
    }
    return 0;
  }
}

uint64_t VCMediaStream_Lock(uint64_t result)
{
  if (result) {
    return pthread_mutex_lock((pthread_mutex_t *)(result + 176));
  }
  return result;
}

uint64_t VCMediaStream_Unlock(uint64_t result)
{
  if (result) {
    return pthread_mutex_unlock((pthread_mutex_t *)(result + 176));
  }
  return result;
}

uint64_t _VCMediaStream_TransportStreamCreationCallback(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return [a1 createTransportStream:a4 withType:a2 options:a3];
}

void sub_1E224CBC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t VCMediaCallback(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  char v8 = (void *)MEMORY[0x1E4E589F0]();
  if (a2) {
    uint64_t v9 = [a2 handleMediaCallbackNotification:a1 inData:a3 outData:a4];
  }
  else {
    uint64_t v9 = 2148597761;
  }
  return v9;
}

void sub_1E224F310(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v8 - 56), 8);
  _Unwind_Resume(a1);
}

uint64_t _VCMediaStream_WRMReportMetricsCallback(void *a1, const char *a2)
{
  return [a1 reportWRMMetrics:a2];
}

void VCMediaStreamFillMediaControlInfoCallback(uint64_t a1, uint64_t a2, void *a3)
{
  int Type = VCMediaControlInfoGeneratorGetType(a1);
  if (*(void *)(a2 + 640) == a1)
  {
    uint64_t v7 = &OBJC_IVAR___VCMediaStream__feedbackController;
  }
  else
  {
    if (*(void *)(a2 + 648) != a1) {
      return;
    }
    uint64_t v7 = &OBJC_IVAR___VCMediaStream__oneToOneFeedbackController;
  }
  uint64_t v8 = *(void **)(a2 + *v7);
  if (v8) {
    BOOL v9 = Type == 0;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9 && (VCRateControlSetFeedbackControlInfo(v8, a3) & 1) == 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCMediaStreamFillMediaControlInfoCallback_cold_1();
    }
  }
}

void VCMediaStreamProcessMediaControlInfoCallback(uint64_t a1, uint64_t a2, void *a3)
{
  int Type = VCMediaControlInfoGeneratorGetType(a1);
  uint64_t v7 = (void *)[*(id *)(a2 + 544) objectAtIndexedSubscript:0];
  if (*(void *)(a2 + 640) == a1)
  {
    uint64_t v8 = &OBJC_IVAR___VCMediaStream__feedbackController;
  }
  else
  {
    if (*(void *)(a2 + 648) != a1) {
      return;
    }
    uint64_t v8 = &OBJC_IVAR___VCMediaStream__oneToOneFeedbackController;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = *(_DWORD **)(a2 + v9);
  if (v10)
  {
    if (!Type
      && (VCRateControlProcessFeedbackControlInfo(*(void *)(a2 + v9), a3) & 1) == 0
      && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaStreamProcessMediaControlInfoCallback_cold_3();
      }
    }
    if ((VCRateControlProcessProbingControlInfo(v10, a3, Type == 0) & 1) == 0
      && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaStreamProcessMediaControlInfoCallback_cold_2();
      }
    }
    if ((RTPProcessMediaControlInfo([v7 rtpHandle], a3, Type == 0) & 0x80000000) != 0
      && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaStreamProcessMediaControlInfoCallback_cold_1();
      }
    }
  }
}

void sub_1E225273C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
}

void sub_1E2253D90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
}

void sub_1E2254CA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
}

void VCMediaStream_CheckDecryptionTimeoutForMKMRecoveryAgainstTime(uint64_t a1, double a2, double a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (a2 - *(double *)(a1 + 376) > 1.0)
  {
    uint64_t v6 = _VCMediaStream_DefaultTransport(a1);
    double v7 = a2 - *(double *)(a1 + 384);
    if (v7 > VCMediaStreamTransport_DecryptionMKMRecoveryInterval(v6))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v8 = VRTraceErrorLogLevelToCSTR();
        uint64_t v9 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          uint64_t v11 = *(void *)(a1 + 384);
          *(_DWORD *)buf = 136316418;
          uint64_t v14 = v8;
          __int16 v15 = 2080;
          uint64_t v16 = "VCMediaStream_CheckDecryptionTimeoutForMKMRecoveryAgainstTime";
          __int16 v17 = 1024;
          int v18 = 2251;
          __int16 v19 = 2048;
          double v20 = a3;
          __int16 v21 = 2048;
          uint64_t v22 = v11;
          __int16 v23 = 2048;
          double v24 = a2;
          _os_log_error_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_ERROR, "VCMediaStream [%s] %s:%d DecryptionErrorStartTime:%f lastDecryptionMKMRecoveryTime:%f now:%f. Triggering MKM recovery", buf, 0x3Au);
        }
      }
      *(double *)(a1 + 376) = a2;
      *(double *)(a1 + 384) = a2;
      unint64_t v10 = *(NSObject **)(a1 + 168);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __VCMediaStream_CheckDecryptionTimeoutForMKMRecoveryAgainstTime_block_invoke;
      block[3] = &unk_1E6DB3DC8;
      block[4] = a1;
      dispatch_async(v10, block);
    }
  }
}

void VCMediaStream_CheckForDecryptionTimeout(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = _VCMediaStream_DefaultTransport(a1);
    if (VCMediaStreamTransport_DecryptionTimeoutInterval(v2) != 0.0)
    {
      double v3 = micro();
      _VCMediaStream_CheckDecryptionTimeoutAgainstTime(a1, v3, *(double *)(a1 + 392));
      double v4 = *(double *)(a1 + 392);
      VCMediaStream_CheckDecryptionTimeoutForMKMRecoveryAgainstTime(a1, v3, v4);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    uint64_t v5 = VRTraceErrorLogLevelToCSTR();
    uint64_t v6 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315650;
      uint64_t v8 = v5;
      __int16 v9 = 2080;
      unint64_t v10 = "VCMediaStream_CheckForDecryptionTimeout";
      __int16 v11 = 1024;
      int v12 = 2267;
      _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, "VCMediaStream [%s] %s:%d media stream is nil", (uint8_t *)&v7, 0x1Cu);
    }
  }
}

void _VCMediaStream_CheckDecryptionTimeoutAgainstTime(uint64_t a1, double a2, double a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = _VCMediaStream_DefaultTransport(a1);
  double v7 = VCMediaStreamTransport_DecryptionTimeoutInterval(v6);
  if (a2 - *(double *)(a1 + 328) > v7 && a2 - *(double *)(a1 + 376) > 1.0 && a2 - a3 > v7)
  {
    *(double *)(a1 + 376) = a2;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v9 = VRTraceErrorLogLevelToCSTR();
      unint64_t v10 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        uint64_t v14 = v9;
        __int16 v15 = 2080;
        uint64_t v16 = "_VCMediaStream_CheckDecryptionTimeoutAgainstTime";
        __int16 v17 = 1024;
        int v18 = 2230;
        __int16 v19 = 2048;
        double v20 = a3;
        __int16 v21 = 2048;
        double v22 = a2;
        _os_log_error_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_ERROR, "VCMediaStream [%s] %s:%d DecryptionErrorStartTime:%f now:%f. Triggering decryption timeout", buf, 0x30u);
      }
    }
    __int16 v11 = *(NSObject **)(a1 + 168);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = ___VCMediaStream_CheckDecryptionTimeoutAgainstTime_block_invoke;
    block[3] = &unk_1E6DB3DC8;
    block[4] = a1;
    dispatch_async(v11, block);
  }
}

void *VCMediaStream_RTCPPacketsCallback(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 notifyDelegateDidReceiveRTCPPackets:a2];
  }
  return a1;
}

uint64_t VCMediaStream_State(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 408);
  }
  return result;
}

uint64_t OUTLINED_FUNCTION_14_2@<X0>(uint64_t a1@<X8>)
{
  *(void *)(v1 - 40) = a1;
  return objc_opt_class();
}

CFArrayRef VCVideoHardwareDumpCollector_CreateHeadersFromCArray(const char **a1, CFIndex a2)
{
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCVideoHardwareDumpCollector_CreateHeadersFromCArray_cold_1();
      }
    }
    return 0;
  }
  CFIndex v2 = a2;
  double v3 = a1;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, MEMORY[0x1E4F1D510]);
  if (!Mutable)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCVideoHardwareDumpCollector_CreateHeadersFromCArray_cold_2();
      }
    }
    return 0;
  }
  uint64_t v6 = Mutable;
  if (v2)
  {
    while (1)
    {
      CFStringRef v7 = CFStringCreateWithCString(v4, *v3, 0x8000100u);
      if (!v7) {
        break;
      }
      CFStringRef v8 = v7;
      CFArrayAppendValue(v6, v7);
      CFRelease(v8);
      ++v3;
      if (!--v2) {
        goto LABEL_6;
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCVideoHardwareDumpCollector_CreateHeadersFromCArray_cold_3();
      }
    }
    CFArrayRef Copy = 0;
  }
  else
  {
LABEL_6:
    CFArrayRef Copy = CFArrayCreateCopy(v4, v6);
  }
  CFRelease(v6);
  return Copy;
}

void _VCVideoHardwareDumpCollector_DumpFrame(uint64_t a1, const __CFDictionary *a2, CFArrayRef theArray, const void *a4)
{
  unint64_t Count = CFArrayGetCount(theArray);
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count + 1, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    __int16 v11 = Mutable;
    CFArrayAppendValue(Mutable, a4);
    if (Count)
    {
      CFIndex v12 = 0;
      unsigned int v13 = 1;
      do
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v12);
        CFBooleanRef Value = CFDictionaryGetValue(a2, ValueAtIndex);
        if (Value)
        {
          CFStringRef v16 = CFStringCreateWithFormat(v9, 0, @"%@", Value);
          CFArrayAppendValue(v11, v16);
          if (v16) {
            CFRelease(v16);
          }
        }
        else
        {
          CFArrayAppendValue(v11, &stru_1F3D3E450);
        }
        CFIndex v12 = v13;
      }
      while (Count > v13++);
    }
    CFStringRef v18 = CFStringCreateByCombiningStrings(v9, v11, @",");
    VCVideoHardwareDumpWriter_Write(*(void *)(a1 + 56), v18);
    if (v18) {
      CFRelease(v18);
    }
    CFRelease(v11);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCVideoHardwareDumpCollector_DumpFrame_cold_1();
    }
  }
}

void VCVideoHardwareDumpCollector_RecordResizeForEncoder(uint64_t a1, int a2, uint64_t a3, int a4, int a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v5 = *(__CFDictionary **)(a1 + 8);
    if (v5)
    {
      int valuePtr = a2;
      CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFNumberRef v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v5, @"VideoHardwareTestDidResizeFrameForEncodingBuffer", v9);
      CFRelease(v9);
      int valuePtr = a4;
      CFNumberRef v10 = CFNumberCreate(v8, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v5, @"VideoHardwareTestResizedFrameForEncodingBufferWidth", v10);
      CFRelease(v10);
      int valuePtr = a5;
      CFNumberRef v11 = CFNumberCreate(v8, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v5, @"VideoHardwareTestResizedFrameForEncodingBufferHeight", v11);
      CFRelease(v11);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCVideoHardwareDumpCollector_RecordResizeForEncoder_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCVideoHardwareDumpCollector_RecordResizeForEncoder_cold_1();
    }
  }
}

void VCVideoHardwareDumpCollector_RecordEncoderBuffer(uint64_t a1, int a2, int a3, VTSessionRef session, int a5, int a6)
{
  propertyValueOut[1] = *(const void **)MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v6 = *(__CFDictionary **)(a1 + 8);
    if (v6)
    {
      propertyValueOut[0] = 0;
      CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      VTSessionCopyProperty(session, (CFStringRef)*MEMORY[0x1E4F45168], (CFAllocatorRef)*MEMORY[0x1E4F1CF80], propertyValueOut);
      if (propertyValueOut[0])
      {
        CFDictionaryAddValue(v6, @"VideoHardwareTestScalingMode", propertyValueOut[0]);
        if (propertyValueOut[0]) {
          CFRelease(propertyValueOut[0]);
        }
      }
      int valuePtr = a6;
      CFNumberRef v12 = CFNumberCreate(v11, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v6, @"VideoHardwareTestRotationAngle", v12);
      CFRelease(v12);
      int valuePtr = a3;
      CFNumberRef v13 = CFNumberCreate(v11, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v6, @"VideoHardwareTestDidResizeEncodingBuffer", v13);
      CFRelease(v13);
      int valuePtr = a5;
      CFNumberRef v14 = CFNumberCreate(v11, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v6, @"VideoHardwareTestDidRotate", v14);
      CFRelease(v14);
      int valuePtr = a2;
      CFNumberRef v15 = CFNumberCreate(v11, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v6, @"VideoHardwareTestFrameOrientation", v15);
      CFRelease(v15);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCVideoHardwareDumpCollector_RecordEncoderBuffer_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCVideoHardwareDumpCollector_RecordEncoderBuffer_cold_1();
    }
  }
}

void VCVideoHardwareDumpCollector_RecordEncodedFrame(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    double v3 = *(__CFDictionary **)(a1 + 8);
    if (v3)
    {
      if (a2)
      {
        uint64_t v5 = *(__CVBuffer **)(a2 + 88);
        LODWORD(valuePtr) = CVPixelBufferGetWidth(v5);
        CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFNumberRef v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
        CFDictionaryAddValue(v3, @"VideoHardwareTestEncodingBufferWidth", v7);
        CFRelease(v7);
        LODWORD(valuePtr) = CVPixelBufferGetHeight(v5);
        CFNumberRef v8 = CFNumberCreate(v6, kCFNumberIntType, &valuePtr);
        CFDictionaryAddValue(v3, @"VideoHardwareTestEncodingBufferHeight", v8);
        CFRelease(v8);
        double v9 = *(double *)(a2 + 256);
        double v11 = *(double *)(a2 + 264);
        double v10 = *(double *)(a2 + 272);
        float v12 = *(double *)(a2 + 248);
        float valuePtr = v12;
        CFNumberRef v13 = CFNumberCreate(v6, kCFNumberFloat32Type, &valuePtr);
        CFDictionaryAddValue(v3, @"VideoHardwareTestVisibleRectX", v13);
        CFRelease(v13);
        float v14 = v9;
        float valuePtr = v14;
        CFNumberRef v15 = CFNumberCreate(v6, kCFNumberFloat32Type, &valuePtr);
        CFDictionaryAddValue(v3, @"VideoHardwareTestVisibleRectY", v15);
        CFRelease(v15);
        float v16 = v11;
        float valuePtr = v16;
        CFNumberRef v17 = CFNumberCreate(v6, kCFNumberFloat32Type, &valuePtr);
        CFDictionaryAddValue(v3, @"VideoHardwareTestVisibleRectWidth", v17);
        CFRelease(v17);
        float v18 = v10;
        float valuePtr = v18;
        CFNumberRef v19 = CFNumberCreate(v6, kCFNumberFloat32Type, &valuePtr);
        CFDictionaryAddValue(v3, @"VideoHardwareTestVisibleRectHeight", v19);
        CFRelease(v19);
      }
      _VCVideoHardwareDumpCollector_DumpFrame(a1, v3, *(CFArrayRef *)(a1 + 32), @"ENCODE");
      CFDictionaryRemoveAllValues(v3);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCVideoHardwareDumpCollector_RecordEncodedFrame_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCVideoHardwareDumpCollector_RecordEncodedFrame_cold_1();
    }
  }
}

void VCVideoHardwareDumpCollector_RecordDecodedFrame(uint64_t a1, CVPixelBufferRef pixelBuffer, void *a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    CFAllocatorRef v4 = *(__CFDictionary **)(a1 + 16);
    if (v4)
    {
      CFNumberRef v7 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
      if (pixelBuffer)
      {
        LODWORD(valuePtr) = CVPixelBufferGetWidth(pixelBuffer);
        CFAllocatorRef v8 = *v7;
        CFNumberRef v9 = CFNumberCreate(*v7, kCFNumberIntType, &valuePtr);
        CFDictionaryAddValue(v4, @"VideoHardwareTestDecodedFrameWidth", v9);
        CFRelease(v9);
        LODWORD(valuePtr) = CVPixelBufferGetHeight(pixelBuffer);
        CFNumberRef v10 = CFNumberCreate(v8, kCFNumberIntType, &valuePtr);
        CFDictionaryAddValue(v4, @"VideoHardwareTestDecodedFrameHeight", v10);
        CFRelease(v10);
      }
      if (a3)
      {
        [a3 contentsRect];
        double v12 = v11;
        double v14 = v13;
        double v16 = v15;
        *(float *)&double v17 = v17;
        float valuePtr = *(float *)&v17;
        CFAllocatorRef v18 = *v7;
        CFNumberRef v19 = CFNumberCreate(*v7, kCFNumberFloat32Type, &valuePtr);
        CFDictionaryAddValue(v4, @"VideoHardwareTestContentsRectX", v19);
        CFRelease(v19);
        float v20 = v12;
        float valuePtr = v20;
        CFNumberRef v21 = CFNumberCreate(v18, kCFNumberFloat32Type, &valuePtr);
        CFDictionaryAddValue(v4, @"VideoHardwareTestContentsRectY", v21);
        CFRelease(v21);
        float v22 = v14;
        float valuePtr = v22;
        CFNumberRef v23 = CFNumberCreate(v18, kCFNumberFloat32Type, &valuePtr);
        CFDictionaryAddValue(v4, @"VideoHardwareTestContentsRectWidth", v23);
        CFRelease(v23);
        float v24 = v16;
        float valuePtr = v24;
        CFNumberRef v25 = CFNumberCreate(v18, kCFNumberFloat32Type, &valuePtr);
        CFDictionaryAddValue(v4, @"VideoHardwareTestContentsRectHeight", v25);
        CFRelease(v25);
      }
      _VCVideoHardwareDumpCollector_DumpFrame(a1, v4, *(CFArrayRef *)(a1 + 40), @"DECODE");
      CFDictionaryRemoveAllValues(v4);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCVideoHardwareDumpCollector_RecordDecodedFrame_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCVideoHardwareDumpCollector_RecordDecodedFrame_cold_1();
    }
  }
}

void VCVideoHardwareDumpCollector_RecordActiveCaptureDevice(uint64_t a1, void *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    double v3 = *(__CFDictionary **)(a1 + 24);
    if (v3)
    {
      int valuePtr = [a2 isVideoBinned];
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFNumberRef v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v3, @"VideoHardwareTestCaptureFormatIsBinned", v6);
      CFRelease(v6);
      int valuePtr = [a2 isVideoHDRSupported];
      CFNumberRef v7 = CFNumberCreate(v5, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v3, @"VideoHardwareTestCaptureFormatIsHDR", v7);
      CFRelease(v7);
      _VCVideoHardwareDumpCollector_DumpFrame(a1, v3, *(CFArrayRef *)(a1 + 48), @"CAPTURE");
      CFDictionaryRemoveAllValues(v3);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCVideoHardwareDumpCollector_RecordActiveCaptureDevice_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCVideoHardwareDumpCollector_RecordActiveCaptureDevice_cold_1();
    }
  }
}

void *Throttling_MediaQueue_Init(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = 0;
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0x3F947AE147AE147BLL;
  *(unsigned char *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 28;
  *(unsigned char *)(a1 + 56) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 64) = 0x3FF0000000000000;
  uint64_t result = malloc_type_malloc(0x380uLL, 0x100004097079494uLL);
  *(void *)(a1 + 88) = result;
  if (result)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v3 = VRTraceErrorLogLevelToCSTR();
      CFAllocatorRef v4 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v7 = 136315650;
        uint64_t v8 = v3;
        __int16 v9 = 2080;
        CFNumberRef v10 = "RealTimeStats_Init";
        __int16 v11 = 1024;
        int v12 = 351;
        _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  ------ MQ IN/OUT RealTime stats are ENABLED", (uint8_t *)&v7, 0x1Cu);
      }
    }
    uint64_t v5 = *(void *)(a1 + 88);
    double v6 = micro();
    *(_OWORD *)(v5 + 8) = 0u;
    *(_OWORD *)(v5 + 24) = 0u;
    *(_OWORD *)(v5 + 40) = 0u;
    *(_OWORD *)(v5 + 56) = 0u;
    *(_OWORD *)(v5 + 72) = 0u;
    *(_OWORD *)(v5 + 88) = 0u;
    *(_OWORD *)(v5 + 104) = 0u;
    *(_OWORD *)(v5 + 120) = 0u;
    *(_WORD *)(v5 + 144) = 0;
    *(double *)uint64_t v5 = v6;
    *(double *)(v5 + 136) = v6;
    *(void *)(v5 + 148) = 0x100000000;
    *(_DWORD *)(v5 + 156) = 0;
    pthread_mutex_init((pthread_mutex_t *)(v5 + 160), 0);
    *(double *)(v5 + 224) = v6;
    v5 += 224;
    *(_OWORD *)(v5 + 8) = 0u;
    *(_OWORD *)(v5 + 24) = 0u;
    *(_OWORD *)(v5 + 40) = 0u;
    *(_OWORD *)(v5 + 56) = 0u;
    *(_OWORD *)(v5 + 72) = 0u;
    *(_OWORD *)(v5 + 88) = 0u;
    *(_OWORD *)(v5 + 104) = 0u;
    *(_OWORD *)(v5 + 120) = 0u;
    *(_DWORD *)(v5 + 148) = 0;
    *(_WORD *)(v5 + 144) = 0;
    *(double *)(v5 + 136) = v6;
    *(void *)(v5 + 152) = 0;
    pthread_mutex_init((pthread_mutex_t *)(v5 + 160), 0);
    *(_OWORD *)(v5 + 232) = 0u;
    *(_OWORD *)(v5 + 248) = 0u;
    *(_OWORD *)(v5 + 264) = 0u;
    *(_OWORD *)(v5 + 280) = 0u;
    *(_OWORD *)(v5 + 296) = 0u;
    *(_OWORD *)(v5 + 312) = 0u;
    *(_OWORD *)(v5 + 328) = 0u;
    *(_OWORD *)(v5 + 344) = 0u;
    *(_DWORD *)(v5 + 372) = 0;
    *(_WORD *)(v5 + 368) = 0;
    *(double *)(v5 + 224) = v6;
    *(double *)(v5 + 360) = v6;
    *(void *)(v5 + 376) = 1;
    pthread_mutex_init((pthread_mutex_t *)(v5 + 384), 0);
    *(_OWORD *)(v5 + 456) = 0u;
    *(_OWORD *)(v5 + 472) = 0u;
    *(_OWORD *)(v5 + 488) = 0u;
    *(_OWORD *)(v5 + 504) = 0u;
    *(_OWORD *)(v5 + 520) = 0u;
    *(_OWORD *)(v5 + 536) = 0u;
    *(_OWORD *)(v5 + 552) = 0u;
    *(_OWORD *)(v5 + 568) = 0u;
    *(_DWORD *)(v5 + 596) = 0;
    *(_WORD *)(v5 + 592) = 0;
    *(double *)(v5 + 448) = v6;
    *(double *)(v5 + 584) = v6;
    *(void *)(v5 + 600) = 0;
    return (void *)pthread_mutex_init((pthread_mutex_t *)(v5 + 608), 0);
  }
  return result;
}

void Throttling_MediaQueue_Uninit(uint64_t a1, pthread_mutex_t *a2)
{
  pthread_mutex_lock(a2);
  CFAllocatorRef v4 = *(void **)a1;
  if (*(void *)a1)
  {
    do
    {
      uint64_t v5 = (void *)v4[196];
      VCMediaControlInfoDispose(v4[198]);
      free(v4);
      CFAllocatorRef v4 = v5;
    }
    while (v5);
  }
  pthread_mutex_unlock(a2);
  *(void *)a1 = 0;
  uint64_t v6 = *(void *)(a1 + 88);
  if (v6)
  {
    pthread_mutex_destroy((pthread_mutex_t *)(v6 + 160));
    pthread_mutex_destroy((pthread_mutex_t *)(v6 + 384));
    pthread_mutex_destroy((pthread_mutex_t *)(v6 + 608));
    pthread_mutex_destroy((pthread_mutex_t *)(v6 + 832));
    free(*(void **)(a1 + 88));
    *(void *)(a1 + 88) = 0;
  }
}

uint64_t Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, double a5)
{
  uint64_t v9 = a1;
  uint64_t v272 = *MEMORY[0x1E4F143B8];
  uint64_t v253 = a4;
  *(double *)(a4 + 1608) = a5;
  uint64_t v10 = *(void *)(a2 + 88);
  if (v10)
  {
    int v11 = *(_DWORD *)a4 + *(_DWORD *)(a2 + 52);
    uint64_t v12 = 224;
    if (!*(_DWORD *)(a4 + 1516)) {
      uint64_t v12 = 0;
    }
    uint64_t v252 = v12;
    if (*(_DWORD *)(a4 + 1516)) {
      uint64_t v13 = v10 + 224;
    }
    else {
      uint64_t v13 = *(void *)(a2 + 88);
    }
    int v14 = *(_DWORD *)(v13 + 148);
    int v15 = vcvtd_n_s64_f64(a5 - *(double *)(v13 + 136), 6uLL);
    if (v15)
    {
      if (v15 > 15)
      {
        uint64_t v21 = a1;
        if (v15 > 0x1F)
        {
          int v14 = 0;
          unsigned int v18 = 0;
          *(_OWORD *)(v13 + 120) = 0u;
          *(_OWORD *)(v13 + 104) = 0u;
          *(_OWORD *)(v13 + 88) = 0u;
          *(_OWORD *)(v13 + 72) = 0u;
          *(_OWORD *)(v13 + 56) = 0u;
          *(_OWORD *)(v13 + 40) = 0u;
          *(_OWORD *)(v13 + 24) = 0u;
          *(_OWORD *)(v13 + 8) = 0u;
        }
        else
        {
          int v23 = *(unsigned __int16 *)(v13 + 144);
          int v250 = v23 + v15;
          unsigned int v18 = (v23 + v15) & 0x1F;
          uint64_t v24 = ((_BYTE)v23 + 1) & 0x1F;
          if (v18 >= v24)
          {
            CFNumberRef v25 = (void *)(v13 + 4 * v24 + 8);
            uint64_t v26 = (int)(v18 - v24 + 1);
          }
          else
          {
            CFNumberRef v25 = (void *)(v13 + 8);
            bzero((void *)(v13 + 8 + 4 * (((_BYTE)v23 + 1) & 0x1F)), 128 - 4 * (((_BYTE)v23 + 1) & 0x1Fu));
            uint64_t v26 = v18 + 1;
          }
          bzero(v25, 4 * v26);
          unsigned int v27 = (v250 + 1) & 0x1F;
          if (v27 == v24)
          {
            int v14 = 0;
          }
          else
          {
            int v14 = 0;
            do
            {
              v14 += *(_DWORD *)(v13 + 4 * v27 + 8);
              unsigned int v27 = ((_BYTE)v27 + 1) & 0x1F;
            }
            while (v27 != v24);
          }
        }
      }
      else
      {
        char v16 = *(_WORD *)(v13 + 144);
        char v17 = v16 + v15;
        unsigned int v18 = v17 & 0x1F;
        int v19 = (v17 + 1) & 0x1F;
        unsigned int v20 = (v16 + 1) & 0x1F;
        uint64_t v21 = a1;
        while (v20 != v19)
        {
          uint64_t v22 = v13 + 4 * v20;
          v14 -= *(_DWORD *)(v22 + 8);
          *(_DWORD *)(v22 + 8) = 0;
          unsigned int v20 = ((_BYTE)v20 + 1) & 0x1F;
        }
      }
    }
    else
    {
      uint64_t v21 = a1;
      unsigned int v18 = -1;
    }
    int v28 = v14 + v11;
    pthread_mutex_lock((pthread_mutex_t *)(v13 + 160));
    *(_DWORD *)(v13 + 148) = v28;
    if (v18 != -1)
    {
      *(double *)(v13 + 136) = *(double *)(v10 + v252)
                             + (double)vcvtd_n_u64_f64(a5 - *(double *)(v10 + v252), 6uLL) * 0.015625;
      *(_WORD *)(v13 + 144) = v18;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v13 + 160));
    uint64_t v29 = v13 + 4 * *(__int16 *)(v13 + 144);
    *(_DWORD *)(v29 + 8) += v11;
    uint64_t v9 = v21;
  }
  if (_MergedGlobals && (int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v30 = VRTraceErrorLogLevelToCSTR();
    size_t v31 = *MEMORY[0x1E4F47A50];
    uint64_t v32 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        int v33 = *(_DWORD *)(a4 + 1516);
        unsigned int v34 = bswap32(*(_DWORD *)(a4 + 1508));
        unsigned int v35 = bswap32(*(unsigned __int16 *)(a4 + 1506));
        int v36 = *(_DWORD *)a4;
        int v37 = *(unsigned __int8 *)(a4 + 1576);
        double v38 = *(double *)a2;
        int v39 = *(_DWORD *)(a2 + 32);
        *(_DWORD *)buf = 136317698;
        uint64_t v256 = v30;
        __int16 v257 = 2080;
        v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
        __int16 v259 = 1024;
        int v260 = 1040;
        __int16 v261 = 2048;
        *(double *)v262 = a5;
        *(_WORD *)&v262[8] = 1024;
        *(_DWORD *)&v262[10] = v33;
        *(_WORD *)&v262[14] = 1024;
        *(_DWORD *)&v262[16] = v34;
        *(_WORD *)&v262[20] = 1024;
        *(_DWORD *)&v262[22] = HIWORD(v35);
        *(_WORD *)&v262[26] = 1024;
        *(_DWORD *)&v262[28] = v36;
        *(_WORD *)&v262[32] = 1024;
        *(_DWORD *)&v262[34] = v37;
        *(_WORD *)&v262[38] = 2048;
        double v263 = v38;
        __int16 v264 = 1024;
        *(_DWORD *)v265 = v39;
        _os_log_impl(&dword_1E1EA4000, v31, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AddPacket: ^^^^^^ @%.3f MP %d  %d/%d/%d P: %d  pTWL: %p %d", buf, 0x54u);
      }
    }
    else if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
    {
      int v241 = *(_DWORD *)(a4 + 1516);
      unsigned int v242 = bswap32(*(_DWORD *)(a4 + 1508));
      unsigned int v243 = bswap32(*(unsigned __int16 *)(a4 + 1506));
      int v244 = *(_DWORD *)a4;
      int v245 = *(unsigned __int8 *)(a4 + 1576);
      double v246 = *(double *)a2;
      int v247 = *(_DWORD *)(a2 + 32);
      *(_DWORD *)buf = 136317698;
      uint64_t v256 = v30;
      __int16 v257 = 2080;
      v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
      __int16 v259 = 1024;
      int v260 = 1040;
      __int16 v261 = 2048;
      *(double *)v262 = a5;
      *(_WORD *)&v262[8] = 1024;
      *(_DWORD *)&v262[10] = v241;
      *(_WORD *)&v262[14] = 1024;
      *(_DWORD *)&v262[16] = v242;
      *(_WORD *)&v262[20] = 1024;
      *(_DWORD *)&v262[22] = HIWORD(v243);
      *(_WORD *)&v262[26] = 1024;
      *(_DWORD *)&v262[28] = v244;
      *(_WORD *)&v262[32] = 1024;
      *(_DWORD *)&v262[34] = v245;
      *(_WORD *)&v262[38] = 2048;
      double v263 = v246;
      __int16 v264 = 1024;
      *(_DWORD *)v265 = v247;
      _os_log_debug_impl(&dword_1E1EA4000, v31, OS_LOG_TYPE_DEBUG, " [%s] %s:%d AddPacket: ^^^^^^ @%.3f MP %d  %d/%d/%d P: %d  pTWL: %p %d", buf, 0x54u);
    }
  }
  if (!*(_DWORD *)(v253 + 1516))
  {
    float v48 = *(float *)(v253 + 1616);
    if (v48 >= 0.0)
    {
      *(double *)(a2 + 24) = v48 + a5;
    }
    else
    {
      *(double *)(a2 + 24) = *(double *)(a2 + 40) + a5;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v49 = VRTraceErrorLogLevelToCSTR();
        __int16 v50 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          double v51 = *(float *)(v253 + 1616);
          uint64_t v52 = *(void *)(a2 + 40);
          *(_DWORD *)buf = 136316162;
          uint64_t v256 = v49;
          __int16 v257 = 2080;
          v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
          __int16 v259 = 1024;
          int v260 = 1057;
          __int16 v261 = 2048;
          *(double *)v262 = v51;
          *(_WORD *)&v262[8] = 2048;
          *(void *)&v262[10] = v52;
          _os_log_impl(&dword_1E1EA4000, v50, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  *#*#*#*#*#*#*#*# BAD AUD. pkt INTERVAL: %f (avg: %f) ", buf, 0x30u);
        }
      }
    }
    if (*(unsigned char *)(a2 + 8) && (int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v63 = VRTraceErrorLogLevelToCSTR();
      __int16 v64 = *MEMORY[0x1E4F47A50];
      uint64_t v65 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
        {
          double v66 = *(float *)(v253 + 1616);
          uint64_t v67 = *(void *)(a2 + 40);
          *(_DWORD *)buf = 136316162;
          uint64_t v256 = v63;
          __int16 v257 = 2080;
          v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
          __int16 v259 = 1024;
          int v260 = 1062;
          __int16 v261 = 2048;
          *(double *)v262 = v66;
          *(_WORD *)&v262[8] = 2048;
          *(void *)&v262[10] = v67;
          _os_log_impl(&dword_1E1EA4000, v64, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  AUD. pkt INTERVAL: %f (avg: %f) ", buf, 0x30u);
        }
      }
      else if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
      {
        double v237 = *(float *)(v253 + 1616);
        uint64_t v238 = *(void *)(a2 + 40);
        *(_DWORD *)buf = 136316162;
        uint64_t v256 = v63;
        __int16 v257 = 2080;
        v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
        __int16 v259 = 1024;
        int v260 = 1062;
        __int16 v261 = 2048;
        *(double *)v262 = v237;
        *(_WORD *)&v262[8] = 2048;
        *(void *)&v262[10] = v238;
        _os_log_debug_impl(&dword_1E1EA4000, v64, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  AUD. pkt INTERVAL: %f (avg: %f) ", buf, 0x30u);
      }
    }
  }
  uint64_t v40 = v253;
  if (!*(void *)a2)
  {
    uint64_t v44 = 0;
    BOOL v47 = *(unsigned char *)(v253 + 1596) == 0;
    goto LABEL_63;
  }
  if (*(_DWORD *)(v253 + 1516))
  {
    if (*(unsigned char *)(v253 + 1596))
    {
      uint64_t v41 = *a3;
      __int16 v42 = a3;
      if (*a3)
      {
        do
        {
          uint64_t v43 = v41;
          uint64_t v41 = *(void *)(v41 + 1568);
        }
        while (v41);
        __int16 v42 = (uint64_t *)(v43 + 1568);
      }
      v254 = v42;
      uint64_t v44 = ProcessThrottledPktsWithTime((double *)a2, &v254, 0, a5);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v45 = VRTraceErrorLogLevelToCSTR();
        unint64_t v46 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          uint64_t v256 = v45;
          __int16 v257 = 2080;
          v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
          __int16 v259 = 1024;
          int v260 = 1075;
          __int16 v261 = 1024;
          *(_DWORD *)v262 = v44;
          _os_log_impl(&dword_1E1EA4000, v46, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Packet with a shouldScheduleQueuedPackets set. Empty throttling queue! iPktsAddedToPktListCount=%d", buf, 0x22u);
        }
      }
      BOOL v47 = 0;
      uint64_t v40 = v253;
    }
    else
    {
      uint64_t v44 = 0;
      BOOL v47 = 1;
    }
LABEL_63:
    int active = ActiveProbing_ProcessIncomingPacket(v9, v40);
    int v70 = active;
    if (!v47 && !active)
    {
      int v70 = ActiveProbing_FlushPendingPackets(v9, &v253);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v71 = VRTraceErrorLogLevelToCSTR();
        double v72 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          uint64_t v256 = v71;
          __int16 v257 = 2080;
          v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
          __int16 v259 = 1024;
          int v260 = 1086;
          __int16 v261 = 1024;
          *(_DWORD *)v262 = v70;
          _os_log_impl(&dword_1E1EA4000, v72, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Packet with a shouldScheduleQueuedPackets set. Empty waiting queue! iPktsCount=%d", buf, 0x22u);
        }
      }
    }
    if (v70 < 1) {
      goto LABEL_272;
    }
    uint64_t v73 = *a3;
    if (*a3)
    {
      do
      {
        uint64_t v74 = v73;
        uint64_t v73 = *(void *)(v73 + 1568);
      }
      while (v73);
      a3 = (uint64_t *)(v74 + 1568);
    }
    int v251 = v70;
    uint64_t v75 = v253;
    v254 = a3;
    if (!*(unsigned char *)(a2 + 8))
    {
      if (!v253) {
        goto LABEL_270;
      }
      uint64_t v79 = v253;
      do
      {
        while (*(_DWORD *)(v79 + 1516) != 1)
        {
          uint64_t v79 = *(void *)(v79 + 1568);
          if (!v79) {
            goto LABEL_270;
          }
        }
        int v80 = *(_DWORD *)(v79 + 1600);
        uint64_t v79 = *(void *)(v79 + 1568);
        if (v79) {
          BOOL v81 = v80 == 0;
        }
        else {
          BOOL v81 = 0;
        }
      }
      while (v81);
      if (!v80)
      {
LABEL_270:
        *a3 = v253;
        uint64_t v44 = v70;
        goto LABEL_271;
      }
    }
    if (*(void *)a2)
    {
      uint64_t v44 = ProcessThrottledPktsWithTime((double *)a2, &v254, 0, a5);
      double v76 = *(double *)a2;
      if (*(void *)a2)
      {
        do
        {
          double v77 = v76;
          double v76 = *(double *)(*(void *)&v76 + 1568);
        }
        while (v76 != 0.0);
        uint64_t v78 = (uint64_t *)(*(void *)&v77 + 1568);
        if (!v75) {
          goto LABEL_271;
        }
LABEL_90:
        double v82 = 8.0;
        double v83 = 0.1;
        double v84 = 1.0;
        while (1)
        {
          uint64_t v85 = (int *)v75;
          if (!*(unsigned char *)(v75 + 1578) || *(_DWORD *)(v75 + 1516) != 1 || !*(_DWORD *)(v75 + 1600)) {
            goto LABEL_191;
          }
          if (!*(unsigned char *)(a2 + 8))
          {
            uint64_t v92 = (uint64_t *)(v75 + 1568);
            uint64_t v75 = *(void *)(v75 + 1568);
            *((void *)v85 + 196) = 0;
LABEL_198:
            BOOL v173 = 1;
            *(unsigned char *)(a2 + 8) = 1;
            *(void *)(a2 + 16) = *((void *)v85 + 201);
            if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
            {
              uint64_t v177 = VRTraceErrorLogLevelToCSTR();
              v178 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v179 = *(void *)(a2 + 16);
                *(_DWORD *)buf = 136315906;
                uint64_t v256 = v177;
                __int16 v257 = 2080;
                v258 = "SchedulePkt";
                __int16 v259 = 1024;
                int v260 = 474;
                __int16 v261 = 2048;
                *(void *)v262 = v179;
                _os_log_impl(&dword_1E1EA4000, v178, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d \t\t THROTTLING: disabled->enabled   dLastThrottledVideoPktTime init: %f ", buf, 0x26u);
              }
            }
LABEL_201:
            BOOL v176 = 0;
            goto LABEL_202;
          }
          double v86 = *(double *)(a2 + 16);
          if (v86 >= a5) {
            break;
          }
          if (a5 - v86 > 0.0) {
            *(double *)(a2 + 16) = a5;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
            goto LABEL_117;
          }
          uint64_t v87 = VRTraceErrorLogLevelToCSTR();
          unsigned int v88 = *MEMORY[0x1E4F47A50];
          uint64_t v89 = *MEMORY[0x1E4F47A50];
          if (!*MEMORY[0x1E4F47A40])
          {
            if (os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v224 = *(void *)(a2 + 16);
              *(_DWORD *)buf = 136316674;
              uint64_t v256 = v87;
              __int16 v257 = 2080;
              v258 = "CheckIfBoostNeeded";
              __int16 v259 = 1024;
              int v260 = 329;
              __int16 v261 = 2048;
              *(double *)v262 = a5 - v86;
              *(_WORD *)&v262[8] = 2048;
              *(double *)&v262[10] = v86;
              *(_WORD *)&v262[18] = 2048;
              *(double *)&v262[20] = a5;
              *(_WORD *)&v262[28] = 2048;
              *(void *)&v262[30] = v224;
              _os_log_debug_impl(&dword_1E1EA4000, v88, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  VIDEO GAP: %f  last: %f  now: %.3f new: %f ", buf, 0x44u);
            }
            goto LABEL_117;
          }
          int v90 = 0;
          if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v91 = *(void *)(a2 + 16);
            *(_DWORD *)buf = 136316674;
            uint64_t v256 = v87;
            __int16 v257 = 2080;
            v258 = "CheckIfBoostNeeded";
            __int16 v259 = 1024;
            int v260 = 329;
            __int16 v261 = 2048;
            *(double *)v262 = a5 - v86;
            *(_WORD *)&v262[8] = 2048;
            *(double *)&v262[10] = v86;
            *(_WORD *)&v262[18] = 2048;
            *(double *)&v262[20] = a5;
            *(_WORD *)&v262[28] = 2048;
            *(void *)&v262[30] = v91;
            _os_log_impl(&dword_1E1EA4000, v88, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  VIDEO GAP: %f  last: %f  now: %.3f new: %f ", buf, 0x44u);
LABEL_117:
            int v90 = 0;
          }
LABEL_177:
          if (*((unsigned char *)v85 + 1576) && *((unsigned char *)v85 + 1578))
          {
            double v166 = *((double *)v85 + 201);
            if (v166 < v86) {
              double v166 = v86;
            }
            double v167 = a5 - v166;
            if (a5 - v166 > 0.0)
            {
              *(double *)(a2 + 16) = *(double *)(a2 + 16) - v167;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
              {
                uint64_t v168 = VRTraceErrorLogLevelToCSTR();
                v169 = *MEMORY[0x1E4F47A50];
                __int16 v170 = *MEMORY[0x1E4F47A50];
                if (*MEMORY[0x1E4F47A40])
                {
                  if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v171 = *(void *)(a2 + 16);
                    *(_DWORD *)buf = 136316162;
                    uint64_t v256 = v168;
                    __int16 v257 = 2080;
                    v258 = "CheckIfBoostNeeded";
                    __int16 v259 = 1024;
                    int v260 = 405;
                    __int16 v261 = 2048;
                    *(double *)v262 = v167;
                    *(_WORD *)&v262[8] = 2048;
                    *(void *)&v262[10] = v171;
                    _os_log_impl(&dword_1E1EA4000, v169, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  PROBESEQ comp: %f -> new: %f ", buf, 0x30u);
                  }
                }
                else if (os_log_type_enabled(v170, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v226 = *(void *)(a2 + 16);
                  *(_DWORD *)buf = 136316162;
                  uint64_t v256 = v168;
                  __int16 v257 = 2080;
                  v258 = "CheckIfBoostNeeded";
                  __int16 v259 = 1024;
                  int v260 = 405;
                  __int16 v261 = 2048;
                  *(double *)v262 = v167;
                  *(_WORD *)&v262[8] = 2048;
                  *(void *)&v262[10] = v226;
                  _os_log_debug_impl(&dword_1E1EA4000, v169, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  PROBESEQ comp: %f -> new: %f ", buf, 0x30u);
                }
              }
            }
          }
          if (v90 >= 1)
          {
            if (!*(void *)a2)
            {
              uint64_t v78 = (uint64_t *)a2;
              if (_MergedGlobals)
              {
                uint64_t v78 = (uint64_t *)a2;
                if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
                {
                  uint64_t v213 = VRTraceErrorLogLevelToCSTR();
                  v214 = *MEMORY[0x1E4F47A50];
                  v215 = *MEMORY[0x1E4F47A50];
                  if (*MEMORY[0x1E4F47A40])
                  {
                    uint64_t v78 = (uint64_t *)a2;
                    if (os_log_type_enabled(v215, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136315650;
                      uint64_t v256 = v213;
                      __int16 v257 = 2080;
                      v258 = "ScheduleReleasedPkts";
                      __int16 v259 = 1024;
                      int v260 = 792;
                      _os_log_impl(&dword_1E1EA4000, v214, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ScheduleReleasedPkts: Updating last pkt's in pThrottledPktsWaitingList == NULL", buf, 0x1Cu);
                      goto LABEL_250;
                    }
                  }
                  else
                  {
                    uint64_t v78 = (uint64_t *)a2;
                    if (os_log_type_enabled(v215, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136315650;
                      uint64_t v256 = v213;
                      __int16 v257 = 2080;
                      v258 = "ScheduleReleasedPkts";
                      __int16 v259 = 1024;
                      int v260 = 792;
                      _os_log_debug_impl(&dword_1E1EA4000, v214, OS_LOG_TYPE_DEBUG, " [%s] %s:%d ScheduleReleasedPkts: Updating last pkt's in pThrottledPktsWaitingList == NULL", buf, 0x1Cu);
LABEL_250:
                      uint64_t v78 = (uint64_t *)a2;
                    }
                  }
                }
              }
            }
            uint64_t v44 = (v90 + v44);
          }
LABEL_191:
          int v172 = *(unsigned __int8 *)(a2 + 8);
          BOOL v173 = *(unsigned char *)(a2 + 8) == 0;
          int v174 = v85[379];
          uint64_t v92 = (uint64_t *)(v85 + 392);
          uint64_t v75 = *((void *)v85 + 196);
          *((void *)v85 + 196) = 0;
          if (v174 != 1)
          {
            BOOL v176 = 0;
            goto LABEL_224;
          }
          int v175 = v85[400];
          if (v172)
          {
            if (v175)
            {
              if (*((unsigned char *)v85 + 1576))
              {
                BOOL v173 = 0;
                goto LABEL_201;
              }
              BOOL v173 = 0;
              *((void *)v85 + 201) = *(void *)(a2 + 16);
              BOOL v176 = 1;
LABEL_202:
              LODWORD(v69) = v85[400];
              unsigned int v180 = (*(double *)(a2 + 64) * (double)*(unint64_t *)&v69);
              int v181 = *(_DWORD *)(a2 + 52) + *v85;
              v85[400] = v180;
              double v69 = (double)v180;
              double v182 = (double)v181 * v82 / (double)v180;
              *(double *)(a2 + 16) = *(double *)(a2 + 16) + v182;
              if (_MergedGlobals && (int)VRTraceGetErrorLogLevelForModule() >= 8)
              {
                uint64_t v183 = VRTraceErrorLogLevelToCSTR();
                v184 = *MEMORY[0x1E4F47A50];
                v185 = *MEMORY[0x1E4F47A50];
                if (*MEMORY[0x1E4F47A40])
                {
                  if (os_log_type_enabled(v185, OS_LOG_TYPE_DEFAULT))
                  {
                    int v186 = *v85;
                    int v187 = v85[400];
                    uint64_t v188 = *((void *)v85 + 201);
                    uint64_t v189 = *(void *)(a2 + 16);
                    *(_DWORD *)buf = 136316930;
                    uint64_t v256 = v183;
                    __int16 v257 = 2080;
                    v258 = "SchedulePkt";
                    __int16 v259 = 1024;
                    int v260 = 542;
                    __int16 v261 = 1024;
                    *(_DWORD *)v262 = v186;
                    *(_WORD *)&v262[4] = 1024;
                    *(_DWORD *)&v262[6] = v187;
                    *(_WORD *)&v262[10] = 2048;
                    *(double *)&v262[12] = v182;
                    *(_WORD *)&v262[20] = 2048;
                    *(void *)&v262[22] = v188;
                    *(_WORD *)&v262[30] = 2048;
                    *(void *)&v262[32] = v189;
                    _os_log_impl(&dword_1E1EA4000, v184, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d \t\t SCHEDULING: len/rate: %d/%d  take: %f  me: %f  next: %f ", buf, 0x46u);
                  }
                }
                else if (os_log_type_enabled(v185, OS_LOG_TYPE_DEBUG))
                {
                  int v196 = *v85;
                  int v197 = v85[400];
                  uint64_t v198 = *((void *)v85 + 201);
                  uint64_t v199 = *(void *)(a2 + 16);
                  *(_DWORD *)buf = 136316930;
                  uint64_t v256 = v183;
                  __int16 v257 = 2080;
                  v258 = "SchedulePkt";
                  __int16 v259 = 1024;
                  int v260 = 542;
                  __int16 v261 = 1024;
                  *(_DWORD *)v262 = v196;
                  *(_WORD *)&v262[4] = 1024;
                  *(_DWORD *)&v262[6] = v197;
                  *(_WORD *)&v262[10] = 2048;
                  *(double *)&v262[12] = v182;
                  *(_WORD *)&v262[20] = 2048;
                  *(void *)&v262[22] = v198;
                  *(_WORD *)&v262[30] = 2048;
                  *(void *)&v262[32] = v199;
                  _os_log_debug_impl(&dword_1E1EA4000, v184, OS_LOG_TYPE_DEBUG, " [%s] %s:%d \t\t SCHEDULING: len/rate: %d/%d  take: %f  me: %f  next: %f ", buf, 0x46u);
                }
              }
              goto LABEL_220;
            }
            double v190 = *(double *)a2;
            *(unsigned char *)(a2 + 8) = 0;
            int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
            if (v190 == 0.0)
            {
              if (ErrorLogLevelForModule >= 5)
              {
                uint64_t v200 = VRTraceErrorLogLevelToCSTR();
                v201 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315650;
                  uint64_t v256 = v200;
                  __int16 v257 = 2080;
                  v258 = "SchedulePkt";
                  __int16 v259 = 1024;
                  int v260 = 489;
                  v194 = v201;
                  v195 = " [%s] %s:%d \t\t THROTTLING: enabled->disabled  EMPTY THROT QUEUE -> DISABLED";
LABEL_218:
                  _os_log_impl(&dword_1E1EA4000, v194, OS_LOG_TYPE_DEFAULT, v195, buf, 0x1Cu);
                }
              }
            }
            else if (ErrorLogLevelForModule >= 5)
            {
              uint64_t v192 = VRTraceErrorLogLevelToCSTR();
              v193 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                uint64_t v256 = v192;
                __int16 v257 = 2080;
                v258 = "SchedulePkt";
                __int16 v259 = 1024;
                int v260 = 510;
                v194 = v193;
                v195 = " [%s] %s:%d \t\t THROTTLING: enabled->disabled  EDGE ... signalling the caller to FLUSH pending pkts in queue";
                goto LABEL_218;
              }
            }
            BOOL v173 = 0;
            BOOL v176 = 0;
            goto LABEL_220;
          }
          if (v175) {
            goto LABEL_198;
          }
          BOOL v176 = 0;
          BOOL v173 = 1;
LABEL_220:
          if (*((unsigned char *)v85 + 1576)) {
            *(double *)(a2 + 80) = a5;
          }
          if (v176)
          {
            double v69 = *(double *)(a2 + 24);
            BOOL v176 = *((double *)v85 + 201) > v69;
          }
LABEL_224:
          if (!_MergedGlobals || (int)VRTraceGetErrorLogLevelForModule() < 8)
          {
LABEL_234:
            if (!v173) {
              goto LABEL_235;
            }
            goto LABEL_238;
          }
          uint64_t v202 = VRTraceErrorLogLevelToCSTR();
          v203 = *MEMORY[0x1E4F47A50];
          v204 = *MEMORY[0x1E4F47A50];
          if (*MEMORY[0x1E4F47A40])
          {
            if (!os_log_type_enabled(v204, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_234;
            }
            int v205 = v85[379];
            unsigned int v206 = bswap32(v85[377]);
            unsigned int v207 = bswap32(*((unsigned __int16 *)v85 + 753)) >> 16;
            int v208 = *v85;
            int v209 = v85[400];
            double v210 = *((double *)v85 + 201);
            double v211 = *(double *)(a2 + 24);
            if (v210 <= v211) {
              int v212 = 78;
            }
            else {
              int v212 = 87;
            }
            *(_DWORD *)buf = 136318210;
            uint64_t v256 = v202;
            __int16 v257 = 2080;
            v258 = "SchedulePkt";
            __int16 v259 = 1024;
            int v260 = 563;
            __int16 v261 = 1024;
            *(_DWORD *)v262 = v205;
            *(_WORD *)&v262[4] = 1024;
            *(_DWORD *)&v262[6] = v206;
            *(_WORD *)&v262[10] = 1024;
            *(_DWORD *)&v262[12] = v207;
            *(_WORD *)&v262[16] = 1024;
            *(_DWORD *)&v262[18] = v208;
            *(_WORD *)&v262[22] = 1024;
            *(_DWORD *)&v262[24] = v209;
            *(_WORD *)&v262[28] = 2048;
            *(double *)&v262[30] = v210;
            *(_WORD *)&v262[38] = 2048;
            double v263 = a5;
            __int16 v264 = 2048;
            *(double *)v265 = v211;
            *(_WORD *)&v265[8] = 1024;
            *(_DWORD *)&v265[10] = v176;
            *(_WORD *)&v265[14] = 1024;
            *(_DWORD *)&v265[16] = v212;
            _os_log_impl(&dword_1E1EA4000, v203, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  SchedulePkt: %d  %d/%d/%d rate: %d  sched: %f now: %f aud: %f  b: %d mode: %c ", buf, 0x64u);
            if (!v173) {
              goto LABEL_235;
            }
          }
          else
          {
            if (!os_log_type_enabled(v204, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_234;
            }
            int v216 = v85[379];
            unsigned int v217 = bswap32(v85[377]);
            unsigned int v218 = bswap32(*((unsigned __int16 *)v85 + 753)) >> 16;
            int v219 = *v85;
            int v220 = v85[400];
            double v221 = *((double *)v85 + 201);
            double v222 = *(double *)(a2 + 24);
            if (v221 <= v222) {
              int v223 = 78;
            }
            else {
              int v223 = 87;
            }
            *(_DWORD *)buf = 136318210;
            uint64_t v256 = v202;
            __int16 v257 = 2080;
            v258 = "SchedulePkt";
            __int16 v259 = 1024;
            int v260 = 563;
            __int16 v261 = 1024;
            *(_DWORD *)v262 = v216;
            *(_WORD *)&v262[4] = 1024;
            *(_DWORD *)&v262[6] = v217;
            *(_WORD *)&v262[10] = 1024;
            *(_DWORD *)&v262[12] = v218;
            *(_WORD *)&v262[16] = 1024;
            *(_DWORD *)&v262[18] = v219;
            *(_WORD *)&v262[22] = 1024;
            *(_DWORD *)&v262[24] = v220;
            *(_WORD *)&v262[28] = 2048;
            *(double *)&v262[30] = v221;
            *(_WORD *)&v262[38] = 2048;
            double v263 = a5;
            __int16 v264 = 2048;
            *(double *)v265 = v222;
            *(_WORD *)&v265[8] = 1024;
            *(_DWORD *)&v265[10] = v176;
            *(_WORD *)&v265[14] = 1024;
            *(_DWORD *)&v265[16] = v223;
            _os_log_debug_impl(&dword_1E1EA4000, v203, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  SchedulePkt: %d  %d/%d/%d rate: %d  sched: %f now: %f aud: %f  b: %d mode: %c ", buf, 0x64u);
            if (!v173)
            {
LABEL_235:
              if (!*(unsigned char *)(a2 + 8) && *(void *)a2) {
                uint64_t v44 = ProcessThrottledPktsWithTime((double *)a2, &v254, 0, *(double *)(a2 + 16))
              }
                    + v44;
            }
          }
LABEL_238:
          if (v176)
          {
            uint64_t *v78 = (uint64_t)v85;
            ++*(_DWORD *)(a2 + 32);
          }
          else
          {
            uint64_t *v254 = (uint64_t)v85;
            v254 = v92;
            uint64_t v44 = (v44 + 1);
            if (v85[379] == 1)
            {
              *(_DWORD *)(a2 + 72) = *(_DWORD *)(a2 + 52) + *v85;
              *(_DWORD *)(a2 + 76) = v85[400];
            }
            uint64_t v92 = v78;
          }
          uint64_t v78 = v92;
          if (!v75) {
            goto LABEL_271;
          }
        }
        double v93 = v86 - a5 + v86 - a5;
        if (v93 <= v84)
        {
          int v90 = 0;
          *(void *)(a2 + 64) = 0x3FF0000000000000;
          goto LABEL_157;
        }
        double v94 = *(double *)(a2 + 16);
        if (*(void *)a2) {
          double v94 = *(double *)(*(void *)a2 + 1608);
        }
        double v249 = *(double *)(a2 + 64);
        int v95 = *(_DWORD *)(a2 + 72);
        LODWORD(v69) = *(_DWORD *)(a2 + 76);
        double v96 = (double)v95 * v82 / (double)*(unint64_t *)&v69;
        if (v94 - v96 <= a5) {
          double v97 = v94 - v96;
        }
        else {
          double v97 = a5;
        }
        if (a5 - v97 <= 0.0 && (int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          uint64_t v98 = VRTraceErrorLogLevelToCSTR();
          uint64_t v99 = *MEMORY[0x1E4F47A50];
          unsigned int v100 = *MEMORY[0x1E4F47A50];
          if (*MEMORY[0x1E4F47A40])
          {
            if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
            {
              int v101 = *(_DWORD *)(a2 + 76);
              *(_DWORD *)buf = 136317442;
              uint64_t v256 = v98;
              __int16 v257 = 2080;
              v258 = "CalcBoostIncrease";
              __int16 v259 = 1024;
              int v260 = 260;
              __int16 v261 = 2048;
              *(double *)v262 = a5 - v97;
              *(_WORD *)&v262[8] = 2048;
              *(double *)&v262[10] = a5;
              *(_WORD *)&v262[18] = 2048;
              *(double *)&v262[20] = v97;
              *(_WORD *)&v262[28] = 2048;
              *(double *)&v262[30] = v94;
              *(_WORD *)&v262[38] = 2048;
              double v263 = v96;
              __int16 v264 = 1024;
              *(_DWORD *)v265 = v95;
              *(_WORD *)&v265[4] = 1024;
              *(_DWORD *)&v265[6] = v101;
              _os_log_impl(&dword_1E1EA4000, v99, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  dSinceLastPktIssue %f  dNow %f    dBaseTime %f = dFirstPktScheduleTime %f - dDeliveryEstimate %f (%d %d)", buf, 0x5Au);
            }
          }
          else if (os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG))
          {
            int v229 = *(_DWORD *)(a2 + 76);
            *(_DWORD *)buf = 136317442;
            uint64_t v256 = v98;
            __int16 v257 = 2080;
            v258 = "CalcBoostIncrease";
            __int16 v259 = 1024;
            int v260 = 260;
            __int16 v261 = 2048;
            *(double *)v262 = a5 - v97;
            *(_WORD *)&v262[8] = 2048;
            *(double *)&v262[10] = a5;
            *(_WORD *)&v262[18] = 2048;
            *(double *)&v262[20] = v97;
            *(_WORD *)&v262[28] = 2048;
            *(double *)&v262[30] = v94;
            *(_WORD *)&v262[38] = 2048;
            double v263 = v96;
            __int16 v264 = 1024;
            *(_DWORD *)v265 = v95;
            *(_WORD *)&v265[4] = 1024;
            *(_DWORD *)&v265[6] = v229;
            _os_log_debug_impl(&dword_1E1EA4000, v99, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  dSinceLastPktIssue %f  dNow %f    dBaseTime %f = dFirstPktScheduleTime %f - dDeliveryEstimate %f (%d %d)", buf, 0x5Au);
          }
        }
        double v248 = v83;
        double v102 = v93 * v83 + 1.0;
        double v103 = (*(double *)(a2 + 16) - v97) / (a5 - v97 + 0.5);
        if (v103 <= 0.0)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            uint64_t v104 = VRTraceErrorLogLevelToCSTR();
            int v105 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v106 = *(void *)(a2 + 16);
              int v107 = *(_DWORD *)(a2 + 76);
              BOOL v108 = *(void *)a2 != 0;
              *(_DWORD *)buf = 136318466;
              uint64_t v256 = v104;
              __int16 v257 = 2080;
              v258 = "CalcBoostIncrease";
              __int16 v259 = 1024;
              int v260 = 281;
              __int16 v261 = 2048;
              *(double *)v262 = v103;
              *(_WORD *)&v262[8] = 2048;
              *(double *)&v262[10] = v102;
              *(_WORD *)&v262[18] = 2048;
              *(void *)&v262[20] = v106;
              *(_WORD *)&v262[28] = 2048;
              *(double *)&v262[30] = v97;
              *(_WORD *)&v262[38] = 2048;
              double v263 = a5 - v97;
              __int16 v264 = 1024;
              *(_DWORD *)v265 = v95;
              *(_WORD *)&v265[4] = 1024;
              *(_DWORD *)&v265[6] = v107;
              *(_WORD *)&v265[10] = 2048;
              *(double *)&v265[12] = v96;
              __int16 v266 = 2048;
              double v267 = v94;
              __int16 v268 = 1024;
              BOOL v269 = v108;
              __int16 v270 = 2048;
              double v271 = a5;
              _os_log_impl(&dword_1E1EA4000, v105, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d UNEXPECTED!!! CalcBoostIncrease:  SCHEME2: %f  SCHEME1: %f  last: %f base: %f, %f %d %d %f %f %d %f ", buf, 0x7Eu);
            }
          }
          double v84 = 1.0;
          double v103 = v102 + 1.0;
        }
        else
        {
          double v84 = 1.0;
        }
        if (v102 > v103) {
          double v109 = v103;
        }
        else {
          double v109 = v102;
        }
        *(double *)(a2 + 64) = v109;
        double v110 = v109 / v249;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          uint64_t v111 = VRTraceErrorLogLevelToCSTR();
          uint64_t v112 = *MEMORY[0x1E4F47A50];
          uint64_t v113 = *MEMORY[0x1E4F47A50];
          if (*MEMORY[0x1E4F47A40])
          {
            if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136316674;
              if (v102 <= v103) {
                int v114 = 1;
              }
              else {
                int v114 = 2;
              }
              uint64_t v256 = v111;
              __int16 v257 = 2080;
              v258 = "CalcBoostIncrease";
              __int16 v259 = 1024;
              int v260 = 291;
              __int16 v261 = 1024;
              *(_DWORD *)v262 = v114;
              *(_WORD *)&v262[4] = 2048;
              *(double *)&v262[6] = v102;
              *(_WORD *)&v262[14] = 2048;
              *(double *)&v262[16] = v103;
              *(_WORD *)&v262[24] = 2048;
              *(double *)&v262[26] = v110;
              _os_log_impl(&dword_1E1EA4000, v112, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  SCHEME %d:   %f   %f    (INC %f)", buf, 0x40u);
            }
          }
          else if (os_log_type_enabled(v113, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136316674;
            if (v102 <= v103) {
              int v225 = 1;
            }
            else {
              int v225 = 2;
            }
            uint64_t v256 = v111;
            __int16 v257 = 2080;
            v258 = "CalcBoostIncrease";
            __int16 v259 = 1024;
            int v260 = 291;
            __int16 v261 = 1024;
            *(_DWORD *)v262 = v225;
            *(_WORD *)&v262[4] = 2048;
            *(double *)&v262[6] = v102;
            *(_WORD *)&v262[14] = 2048;
            *(double *)&v262[16] = v103;
            *(_WORD *)&v262[24] = 2048;
            *(double *)&v262[26] = v110;
            _os_log_debug_impl(&dword_1E1EA4000, v112, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  SCHEME %d:   %f   %f    (INC %f)", buf, 0x40u);
          }
        }
        if (v110 <= v84) {
          goto LABEL_155;
        }
        double v115 = *(double *)a2;
        if (!*(void *)a2) {
          goto LABEL_155;
        }
        int v116 = 0;
        *(double *)&unint64_t v117 = v110 + -1.0;
        double v118 = v110 / (v110 + -1.0);
        LODWORD(v117) = *(_DWORD *)(a2 + 76);
        unsigned int v119 = (v118 * (double)v117);
        double v120 = (double)*(int *)(a2 + 72) * -8.0 / (double)v119;
        double v121 = v120;
        do
        {
          *(double *)(*(void *)&v115 + 1608) = v120 + *(double *)(*(void *)&v115 + 1608);
          if (_MergedGlobals && (int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            uint64_t v122 = VRTraceErrorLogLevelToCSTR();
            uint64_t v123 = *MEMORY[0x1E4F47A50];
            __int16 v124 = *MEMORY[0x1E4F47A50];
            if (*MEMORY[0x1E4F47A40])
            {
              if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
              {
                int v125 = *(_DWORD *)(*(void *)&v115 + 1516);
                unsigned int v126 = bswap32(*(_DWORD *)(*(void *)&v115 + 1508));
                unsigned int v127 = bswap32(*(unsigned __int16 *)(*(void *)&v115 + 1506)) >> 16;
                int v128 = **(_DWORD **)&v115;
                int v129 = *(unsigned __int8 *)(*(void *)&v115 + 1576);
                double v130 = *(double *)(*(void *)&v115 + 1608);
                *(_DWORD *)buf = 136318210;
                uint64_t v256 = v122;
                __int16 v257 = 2080;
                v258 = "AccelerateThrottlingQueue";
                __int16 v259 = 1024;
                int v260 = 197;
                __int16 v261 = 1024;
                *(_DWORD *)v262 = v125;
                *(_WORD *)&v262[4] = 1024;
                *(_DWORD *)&v262[6] = v126;
                *(_WORD *)&v262[10] = 1024;
                *(_DWORD *)&v262[12] = v127;
                *(_WORD *)&v262[16] = 1024;
                *(_DWORD *)&v262[18] = v128;
                *(_WORD *)&v262[22] = 1024;
                *(_DWORD *)&v262[24] = v129;
                *(_WORD *)&v262[28] = 2048;
                *(double *)&v262[30] = v120;
                *(_WORD *)&v262[38] = 2048;
                double v263 = v121;
                __int16 v264 = 1024;
                *(_DWORD *)v265 = v119;
                *(_WORD *)&v265[4] = 2048;
                *(double *)&v265[6] = v130;
                *(_WORD *)&v265[14] = 1024;
                *(_DWORD *)&v265[16] = v130 <= a5;
                _os_log_impl(&dword_1E1EA4000, v123, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  Accelerating: ^^^^^^ MP %d  %d/%d/%d P: %d  by %.3fs (%.5f %d) to %.3f b: %d ", buf, 0x64u);
              }
            }
            else if (os_log_type_enabled(v124, OS_LOG_TYPE_DEBUG))
            {
              int v132 = *(_DWORD *)(*(void *)&v115 + 1516);
              unsigned int v133 = bswap32(*(_DWORD *)(*(void *)&v115 + 1508));
              unsigned int v134 = bswap32(*(unsigned __int16 *)(*(void *)&v115 + 1506)) >> 16;
              int v135 = **(_DWORD **)&v115;
              int v136 = *(unsigned __int8 *)(*(void *)&v115 + 1576);
              double v137 = *(double *)(*(void *)&v115 + 1608);
              *(_DWORD *)buf = 136318210;
              uint64_t v256 = v122;
              __int16 v257 = 2080;
              v258 = "AccelerateThrottlingQueue";
              __int16 v259 = 1024;
              int v260 = 197;
              __int16 v261 = 1024;
              *(_DWORD *)v262 = v132;
              *(_WORD *)&v262[4] = 1024;
              *(_DWORD *)&v262[6] = v133;
              *(_WORD *)&v262[10] = 1024;
              *(_DWORD *)&v262[12] = v134;
              *(_WORD *)&v262[16] = 1024;
              *(_DWORD *)&v262[18] = v135;
              *(_WORD *)&v262[22] = 1024;
              *(_DWORD *)&v262[24] = v136;
              *(_WORD *)&v262[28] = 2048;
              *(double *)&v262[30] = v120;
              *(_WORD *)&v262[38] = 2048;
              double v263 = v121;
              __int16 v264 = 1024;
              *(_DWORD *)v265 = v119;
              *(_WORD *)&v265[4] = 2048;
              *(double *)&v265[6] = v137;
              *(_WORD *)&v265[14] = 1024;
              *(_DWORD *)&v265[16] = v137 <= a5;
              _os_log_debug_impl(&dword_1E1EA4000, v123, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  Accelerating: ^^^^^^ MP %d  %d/%d/%d P: %d  by %.3fs (%.5f %d) to %.3f b: %d ", buf, 0x64u);
            }
          }
          double v131 = *(double *)(*(void *)&v115 + 1608);
          if (v131 <= a5) {
            ++v116;
          }
          LODWORD(v131) = *(_DWORD *)(*(void *)&v115 + 1600);
          unsigned int v119 = (v118 * (double)*(unint64_t *)&v131);
          double v121 = (double)(*(_DWORD *)(a2 + 52) + **(_DWORD **)&v115) * -8.0 / (double)v119;
          double v120 = v120 + v121;
          double v115 = *(double *)(*(void *)&v115 + 1568);
        }
        while (v115 != 0.0);
        double v138 = *(double *)(a2 + 16);
        *(double *)(a2 + 16) = v120 + v138;
        if (_MergedGlobals && (int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          uint64_t v139 = VRTraceErrorLogLevelToCSTR();
          __int16 v140 = *MEMORY[0x1E4F47A50];
          double v141 = *MEMORY[0x1E4F47A50];
          if (*MEMORY[0x1E4F47A40])
          {
            if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v142 = *(void *)(a2 + 16);
              *(_DWORD *)buf = 136316674;
              uint64_t v256 = v139;
              __int16 v257 = 2080;
              v258 = "AccelerateThrottlingQueue";
              __int16 v259 = 1024;
              int v260 = 218;
              __int16 v261 = 2048;
              *(double *)v262 = v120;
              *(_WORD *)&v262[8] = 2048;
              *(double *)&v262[10] = v138;
              *(_WORD *)&v262[18] = 2048;
              *(void *)&v262[20] = v142;
              *(_WORD *)&v262[28] = 1024;
              *(_DWORD *)&v262[30] = v116;
              _os_log_impl(&dword_1E1EA4000, v140, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AccelerateThrottlingQueue: %.3f from %.3f to %.3f (%d pkts) ", buf, 0x40u);
              if (!v116)
              {
LABEL_155:
                int v90 = 0;
LABEL_156:
                double v82 = 8.0;
                double v83 = v248;
LABEL_157:
                double v143 = *(double *)(a2 + 16);
                int v144 = VRTraceGetErrorLogLevelForModule();
                if (v143 == v86)
                {
                  if (v144 < 8) {
                    goto LABEL_170;
                  }
                  uint64_t v145 = VRTraceErrorLogLevelToCSTR();
                  __int16 v146 = *MEMORY[0x1E4F47A50];
                  unsigned int v147 = *MEMORY[0x1E4F47A50];
                  if (*MEMORY[0x1E4F47A40])
                  {
                    if (os_log_type_enabled(v147, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v148 = *(void *)(a2 + 16);
                      uint64_t v149 = *(void *)(a2 + 64);
                      *(_DWORD *)buf = 136316418;
                      uint64_t v256 = v145;
                      __int16 v257 = 2080;
                      v258 = "CheckIfBoostNeeded";
                      __int16 v259 = 1024;
                      int v260 = 370;
                      __int16 v261 = 2048;
                      *(double *)v262 = a5;
                      *(_WORD *)&v262[8] = 2048;
                      *(void *)&v262[10] = v148;
                      *(_WORD *)&v262[18] = 2048;
                      *(void *)&v262[20] = v149;
                      __int16 v150 = v146;
                      int v151 = " [%s] %s:%d  TOO FAST: now: %.3f last: %f factor: %.3f ";
                      uint32_t v152 = 58;
LABEL_166:
                      _os_log_impl(&dword_1E1EA4000, v150, OS_LOG_TYPE_DEFAULT, v151, buf, v152);
                      goto LABEL_170;
                    }
                    goto LABEL_170;
                  }
                  if (!os_log_type_enabled(v147, OS_LOG_TYPE_DEBUG)) {
                    goto LABEL_170;
                  }
                  uint64_t v158 = *(void *)(a2 + 16);
                  uint64_t v159 = *(void *)(a2 + 64);
                  *(_DWORD *)buf = 136316418;
                  uint64_t v256 = v145;
                  __int16 v257 = 2080;
                  v258 = "CheckIfBoostNeeded";
                  __int16 v259 = 1024;
                  int v260 = 370;
                  __int16 v261 = 2048;
                  *(double *)v262 = a5;
                  *(_WORD *)&v262[8] = 2048;
                  *(void *)&v262[10] = v158;
                  *(_WORD *)&v262[18] = 2048;
                  *(void *)&v262[20] = v159;
                  __int16 v160 = v146;
                  unsigned int v161 = " [%s] %s:%d  TOO FAST: now: %.3f last: %f factor: %.3f ";
                  uint32_t v162 = 58;
                }
                else
                {
                  if (v144 < 8) {
                    goto LABEL_170;
                  }
                  uint64_t v153 = VRTraceErrorLogLevelToCSTR();
                  __int16 v154 = *MEMORY[0x1E4F47A50];
                  int v155 = *MEMORY[0x1E4F47A50];
                  if (*MEMORY[0x1E4F47A40])
                  {
                    if (os_log_type_enabled(v155, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v156 = *(void *)(a2 + 16);
                      uint64_t v157 = *(void *)(a2 + 64);
                      *(_DWORD *)buf = 136316674;
                      uint64_t v256 = v153;
                      __int16 v257 = 2080;
                      v258 = "CheckIfBoostNeeded";
                      __int16 v259 = 1024;
                      int v260 = 374;
                      __int16 v261 = 2048;
                      *(double *)v262 = a5;
                      *(_WORD *)&v262[8] = 2048;
                      *(double *)&v262[10] = v86;
                      *(_WORD *)&v262[18] = 2048;
                      *(void *)&v262[20] = v156;
                      *(_WORD *)&v262[28] = 2048;
                      *(void *)&v262[30] = v157;
                      __int16 v150 = v154;
                      int v151 = " [%s] %s:%d  TOO FAST: now: %.3f last: %f --> updated: %f   factor: %.3f ";
                      uint32_t v152 = 68;
                      goto LABEL_166;
                    }
LABEL_170:
                    if (*(double *)(a2 + 16) < a5 && (int)VRTraceGetErrorLogLevelForModule() >= 8)
                    {
                      uint64_t v163 = VRTraceErrorLogLevelToCSTR();
                      __int16 v164 = *MEMORY[0x1E4F47A50];
                      int v165 = *MEMORY[0x1E4F47A50];
                      if (*MEMORY[0x1E4F47A40])
                      {
                        if (os_log_type_enabled(v165, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)buf = 136315650;
                          uint64_t v256 = v163;
                          __int16 v257 = 2080;
                          v258 = "CheckIfBoostNeeded";
                          __int16 v259 = 1024;
                          int v260 = 378;
                          _os_log_impl(&dword_1E1EA4000, v164, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  TOO MUCH ACCEL!!!!!!!!!!!!!!!!!!", buf, 0x1Cu);
                        }
                      }
                      else if (os_log_type_enabled(v165, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)buf = 136315650;
                        uint64_t v256 = v163;
                        __int16 v257 = 2080;
                        v258 = "CheckIfBoostNeeded";
                        __int16 v259 = 1024;
                        int v260 = 378;
                        _os_log_debug_impl(&dword_1E1EA4000, v164, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  TOO MUCH ACCEL!!!!!!!!!!!!!!!!!!", buf, 0x1Cu);
                      }
                    }
                    goto LABEL_177;
                  }
                  if (!os_log_type_enabled(v155, OS_LOG_TYPE_DEBUG)) {
                    goto LABEL_170;
                  }
                  uint64_t v227 = *(void *)(a2 + 16);
                  uint64_t v228 = *(void *)(a2 + 64);
                  *(_DWORD *)buf = 136316674;
                  uint64_t v256 = v153;
                  __int16 v257 = 2080;
                  v258 = "CheckIfBoostNeeded";
                  __int16 v259 = 1024;
                  int v260 = 374;
                  __int16 v261 = 2048;
                  *(double *)v262 = a5;
                  *(_WORD *)&v262[8] = 2048;
                  *(double *)&v262[10] = v86;
                  *(_WORD *)&v262[18] = 2048;
                  *(void *)&v262[20] = v227;
                  *(_WORD *)&v262[28] = 2048;
                  *(void *)&v262[30] = v228;
                  __int16 v160 = v154;
                  unsigned int v161 = " [%s] %s:%d  TOO FAST: now: %.3f last: %f --> updated: %f   factor: %.3f ";
                  uint32_t v162 = 68;
                }
                _os_log_debug_impl(&dword_1E1EA4000, v160, OS_LOG_TYPE_DEBUG, v161, buf, v162);
                goto LABEL_170;
              }
LABEL_260:
              int v90 = ProcessThrottledPktsWithTime((double *)a2, &v254, 0, a5);
              goto LABEL_156;
            }
          }
          else if (os_log_type_enabled(v141, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v230 = *(void *)(a2 + 16);
            *(_DWORD *)buf = 136316674;
            uint64_t v256 = v139;
            __int16 v257 = 2080;
            v258 = "AccelerateThrottlingQueue";
            __int16 v259 = 1024;
            int v260 = 218;
            __int16 v261 = 2048;
            *(double *)v262 = v120;
            *(_WORD *)&v262[8] = 2048;
            *(double *)&v262[10] = v138;
            *(_WORD *)&v262[18] = 2048;
            *(void *)&v262[20] = v230;
            *(_WORD *)&v262[28] = 1024;
            *(_DWORD *)&v262[30] = v116;
            _os_log_debug_impl(&dword_1E1EA4000, v140, OS_LOG_TYPE_DEBUG, " [%s] %s:%d AccelerateThrottlingQueue: %.3f from %.3f to %.3f (%d pkts) ", buf, 0x40u);
            if (!v116) {
              goto LABEL_155;
            }
            goto LABEL_260;
          }
        }
        if (!v116) {
          goto LABEL_155;
        }
        goto LABEL_260;
      }
    }
    else
    {
      uint64_t v44 = 0;
    }
    uint64_t v78 = (uint64_t *)a2;
    if (!v75)
    {
LABEL_271:
      int v70 = v251;
LABEL_272:
      if (!_MergedGlobals || (int)VRTraceGetErrorLogLevelForModule() < 8) {
        return v44;
      }
      uint64_t v231 = VRTraceErrorLogLevelToCSTR();
      v232 = *MEMORY[0x1E4F47A50];
      v233 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v233, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          uint64_t v256 = v231;
          __int16 v257 = 2080;
          v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
          __int16 v259 = 1024;
          int v260 = 1099;
          __int16 v261 = 1024;
          *(_DWORD *)v262 = v70;
          *(_WORD *)&v262[4] = 1024;
          *(_DWORD *)&v262[6] = v44;
          size_t v60 = " [%s] %s:%d ActiveProbing_ProcessIncomingPacket: %d  ScheduleReleasedPkts: %d ";
          __int16 v61 = v232;
          uint32_t v62 = 40;
          goto LABEL_277;
        }
        return v44;
      }
      if (!os_log_type_enabled(v233, OS_LOG_TYPE_DEBUG)) {
        return v44;
      }
      *(_DWORD *)buf = 136316162;
      uint64_t v256 = v231;
      __int16 v257 = 2080;
      v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
      __int16 v259 = 1024;
      int v260 = 1099;
      __int16 v261 = 1024;
      *(_DWORD *)v262 = v70;
      *(_WORD *)&v262[4] = 1024;
      *(_DWORD *)&v262[6] = v44;
      v234 = " [%s] %s:%d ActiveProbing_ProcessIncomingPacket: %d  ScheduleReleasedPkts: %d ";
      v235 = v232;
      uint32_t v236 = 40;
LABEL_284:
      _os_log_debug_impl(&dword_1E1EA4000, v235, OS_LOG_TYPE_DEBUG, v234, buf, v236);
      return v44;
    }
    goto LABEL_90;
  }
  uint64_t v53 = *a3;
  if (*a3)
  {
    do
    {
      uint64_t v54 = v53;
      uint64_t v53 = *(void *)(v53 + 1568);
    }
    while (v53);
    a3 = (uint64_t *)(v54 + 1568);
  }
  double v55 = *(double *)(a2 + 24);
  *a3 = v253;
  v254 = (uint64_t *)(v40 + 1568);
  uint64_t v44 = ProcessThrottledPktsWithTime((double *)a2, &v254, (int *)v40, v55) + 1;
  if (!_MergedGlobals || (int)VRTraceGetErrorLogLevelForModule() < 8) {
    return v44;
  }
  uint64_t v56 = VRTraceErrorLogLevelToCSTR();
  __int16 v57 = *MEMORY[0x1E4F47A50];
  size_t v58 = *MEMORY[0x1E4F47A50];
  if (!*MEMORY[0x1E4F47A40])
  {
    if (!os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG)) {
      return v44;
    }
    uint64_t v239 = *(void *)(a2 + 40);
    *(_DWORD *)buf = 136316674;
    uint64_t v256 = v56;
    __int16 v257 = 2080;
    v258 = "ProcessThrottledPktsWithNewAudioPkt";
    __int16 v259 = 1024;
    int v260 = 724;
    __int16 v261 = 1024;
    *(_DWORD *)v262 = v44;
    *(_WORD *)&v262[4] = 2048;
    *(double *)&v262[6] = a5;
    *(_WORD *)&v262[14] = 2048;
    *(void *)&v262[16] = v239;
    *(_WORD *)&v262[24] = 2048;
    *(double *)&v262[26] = v55;
    v234 = " [%s] %s:%d ProcessThrottledPktsWithNewAudioPkt: Pkts: %d  now: %f   interval: %f  next_audio: %f ";
    v235 = v57;
    uint32_t v236 = 64;
    goto LABEL_284;
  }
  if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v59 = *(void *)(a2 + 40);
    *(_DWORD *)buf = 136316674;
    uint64_t v256 = v56;
    __int16 v257 = 2080;
    v258 = "ProcessThrottledPktsWithNewAudioPkt";
    __int16 v259 = 1024;
    int v260 = 724;
    __int16 v261 = 1024;
    *(_DWORD *)v262 = v44;
    *(_WORD *)&v262[4] = 2048;
    *(double *)&v262[6] = a5;
    *(_WORD *)&v262[14] = 2048;
    *(void *)&v262[16] = v59;
    *(_WORD *)&v262[24] = 2048;
    *(double *)&v262[26] = v55;
    size_t v60 = " [%s] %s:%d ProcessThrottledPktsWithNewAudioPkt: Pkts: %d  now: %f   interval: %f  next_audio: %f ";
    __int16 v61 = v57;
    uint32_t v62 = 64;
LABEL_277:
    _os_log_impl(&dword_1E1EA4000, v61, OS_LOG_TYPE_DEFAULT, v60, buf, v62);
  }
  return v44;
}

uint64_t ProcessThrottledPktsWithTime(double *a1, void **a2, int *a3, double a4)
{
  uint64_t v100 = *MEMORY[0x1E4F143B8];
  if (a3) {
    BOOL v6 = a4 - a1[10] >= 0.666;
  }
  else {
    BOOL v6 = 0;
  }
  int v7 = *a2;
  double v8 = *a1;
  if (*(void *)a1)
  {
    uint64_t v9 = 0;
    while (1)
    {
      if (*(double *)(*(void *)&v8 + 1608) > a4) {
        goto LABEL_36;
      }
      double v10 = *(double *)(*(void *)&v8 + 1568);
      *(void *)(*(void *)&v8 + 1568) = 0;
      *a1 = v10;
      --*((_DWORD *)a1 + 8);
      *(double *)int v7 = v8;
      *((_DWORD *)a1 + 18) = *((_DWORD *)a1 + 13) + **(_DWORD **)&v8;
      *((_DWORD *)a1 + 19) = *(_DWORD *)(*(void *)&v8 + 1600);
      if (!_MergedGlobals || (int)VRTraceGetErrorLogLevelForModule() < 8) {
        break;
      }
      uint64_t v11 = VRTraceErrorLogLevelToCSTR();
      uint64_t v12 = *MEMORY[0x1E4F47A50];
      uint64_t v13 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          break;
        }
        unsigned int v14 = *(_DWORD *)(*(void *)&v8 + 1516);
        unsigned int v15 = bswap32(*(_DWORD *)(*(void *)&v8 + 1508));
        unsigned int v16 = bswap32(*(unsigned __int16 *)(*(void *)&v8 + 1506));
        unsigned int v17 = **(_DWORD **)&v8;
        unsigned int v18 = *(unsigned __int8 *)(*(void *)&v8 + 1576);
        double v19 = *a1;
        int v20 = *((_DWORD *)a1 + 8);
        uint64_t v21 = *(void *)(*(void *)&v8 + 1608);
        *(_DWORD *)buf = 136317954;
        uint64_t v75 = v11;
        __int16 v76 = 2080;
        double v77 = "ProcessThrottledPktsWithTime";
        __int16 v78 = 1024;
        int v79 = 665;
        __int16 v80 = 1024;
        unsigned int v81 = v14;
        __int16 v82 = 1024;
        unsigned int v83 = v15;
        __int16 v84 = 1024;
        unsigned int v85 = HIWORD(v16);
        __int16 v86 = 1024;
        unsigned int v87 = v17;
        __int16 v88 = 1024;
        unsigned int v89 = v18;
        __int16 v90 = 2048;
        double v91 = v19;
        __int16 v92 = 1024;
        int v93 = v20;
        __int16 v94 = 2048;
        uint64_t v95 = v21;
        __int16 v96 = 2048;
        double v97 = a4;
        _os_log_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ProcessThrottledPktsWithTime: ^^^^^^ MP %d  %d/%d/%d P: %d  pTWL: %p %d  sched: %.3f now: %.3f", buf, 0x5Eu);
        if (!v6) {
          goto LABEL_28;
        }
      }
      else
      {
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
          break;
        }
        unsigned int v45 = *(_DWORD *)(*(void *)&v8 + 1516);
        unsigned int v46 = bswap32(*(_DWORD *)(*(void *)&v8 + 1508));
        unsigned int v47 = bswap32(*(unsigned __int16 *)(*(void *)&v8 + 1506));
        unsigned int v48 = **(_DWORD **)&v8;
        unsigned int v49 = *(unsigned __int8 *)(*(void *)&v8 + 1576);
        double v50 = *a1;
        int v51 = *((_DWORD *)a1 + 8);
        uint64_t v52 = *(void *)(*(void *)&v8 + 1608);
        *(_DWORD *)buf = 136317954;
        uint64_t v75 = v11;
        __int16 v76 = 2080;
        double v77 = "ProcessThrottledPktsWithTime";
        __int16 v78 = 1024;
        int v79 = 665;
        __int16 v80 = 1024;
        unsigned int v81 = v45;
        __int16 v82 = 1024;
        unsigned int v83 = v46;
        __int16 v84 = 1024;
        unsigned int v85 = HIWORD(v47);
        __int16 v86 = 1024;
        unsigned int v87 = v48;
        __int16 v88 = 1024;
        unsigned int v89 = v49;
        __int16 v90 = 2048;
        double v91 = v50;
        __int16 v92 = 1024;
        int v93 = v51;
        __int16 v94 = 2048;
        uint64_t v95 = v52;
        __int16 v96 = 2048;
        double v97 = a4;
        _os_log_debug_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_DEBUG, " [%s] %s:%d ProcessThrottledPktsWithTime: ^^^^^^ MP %d  %d/%d/%d P: %d  pTWL: %p %d  sched: %.3f now: %.3f", buf, 0x5Eu);
        if (!v6) {
          goto LABEL_28;
        }
      }
LABEL_15:
      if (*(unsigned char *)(*(void *)&v8 + 1577))
      {
        unsigned int v22 = bswap32(a3[377]);
        if (!RTPInsertAFRCProbeSeqId(*(int **)&v8, v22, *((unsigned __int8 *)a1 + 56)))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            uint64_t v37 = VRTraceErrorLogLevelToCSTR();
            double v38 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
            {
              unsigned int v39 = bswap32(*(_DWORD *)(*(void *)&v8 + 1508));
              unsigned int v40 = bswap32(*(unsigned __int16 *)(*(void *)&v8 + 1506));
              unsigned int v41 = **(_DWORD **)&v8;
              unsigned int v42 = bswap32(a3[377]);
              unsigned int v43 = bswap32(*((unsigned __int16 *)a3 + 753));
              int v44 = *a3;
              *(_DWORD *)buf = 136317186;
              uint64_t v75 = v37;
              __int16 v76 = 2080;
              double v77 = "TagMPWithOpportunisticBWEProbeSeq";
              __int16 v78 = 1024;
              int v79 = 618;
              __int16 v80 = 1024;
              unsigned int v81 = v39;
              __int16 v82 = 1024;
              unsigned int v83 = HIWORD(v40);
              __int16 v84 = 1024;
              unsigned int v85 = v41;
              __int16 v86 = 1024;
              unsigned int v87 = v42;
              __int16 v88 = 1024;
              unsigned int v89 = HIWORD(v43);
              __int16 v90 = 1024;
              LODWORD(v91) = v44;
              _os_log_error_impl(&dword_1E1EA4000, v38, OS_LOG_TYPE_ERROR, " [%s] %s:%d OpportunisticBWEProbeSeqTagging FAILED for pkt %d/%d/%d and audio pkt %d/%d/%d ", buf, 0x40u);
            }
          }
          goto LABEL_28;
        }
        a1[10] = a4;
        int v23 = *MEMORY[0x1E4F47A38];
        int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (v23 >= 7)
        {
          if (ErrorLogLevelForModule < 7) {
            goto LABEL_28;
          }
          uint64_t v61 = VRTraceErrorLogLevelToCSTR();
          uint32_t v62 = *MEMORY[0x1E4F47A50];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_28;
          }
          unsigned int v63 = *(_DWORD *)(*(void *)&v8 + 1516);
          unsigned int v64 = bswap32(*(_DWORD *)(*(void *)&v8 + 1508));
          unsigned int v65 = bswap32(*(unsigned __int16 *)(*(void *)&v8 + 1506));
          int v66 = **(_DWORD **)&v8;
          unsigned int v67 = *(unsigned __int8 *)(*(void *)&v8 + 1576);
          double v68 = *a1;
          int v69 = *((_DWORD *)a1 + 8);
          uint64_t v70 = *(void *)(*(void *)&v8 + 1608);
          *(_DWORD *)buf = 136318210;
          uint64_t v75 = v61;
          __int16 v76 = 2080;
          double v77 = "TagMPWithOpportunisticBWEProbeSeq";
          __int16 v78 = 1024;
          int v79 = 606;
          __int16 v80 = 1024;
          unsigned int v81 = v63;
          __int16 v82 = 1024;
          unsigned int v83 = v64;
          __int16 v84 = 1024;
          unsigned int v85 = HIWORD(v65);
          __int16 v86 = 1024;
          unsigned int v87 = v66;
          __int16 v88 = 1024;
          unsigned int v89 = v67;
          __int16 v90 = 2048;
          double v91 = v68;
          __int16 v92 = 1024;
          int v93 = v69;
          __int16 v94 = 2048;
          uint64_t v95 = v70;
          __int16 v96 = 2048;
          double v97 = a4;
          __int16 v98 = 1024;
          unsigned int v99 = v22;
          int v36 = v62;
          goto LABEL_22;
        }
        if (ErrorLogLevelForModule > 7)
        {
          uint64_t v25 = VRTraceErrorLogLevelToCSTR();
          uint64_t v26 = *MEMORY[0x1E4F47A50];
          unsigned int v27 = *MEMORY[0x1E4F47A50];
          if (!*MEMORY[0x1E4F47A40])
          {
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
            {
              unsigned int v53 = *(_DWORD *)(*(void *)&v8 + 1516);
              unsigned int v54 = bswap32(*(_DWORD *)(*(void *)&v8 + 1508));
              unsigned int v55 = bswap32(*(unsigned __int16 *)(*(void *)&v8 + 1506));
              int v56 = **(_DWORD **)&v8;
              unsigned int v57 = *(unsigned __int8 *)(*(void *)&v8 + 1576);
              double v58 = *a1;
              int v59 = *((_DWORD *)a1 + 8);
              uint64_t v60 = *(void *)(*(void *)&v8 + 1608);
              *(_DWORD *)buf = 136318210;
              uint64_t v75 = v25;
              __int16 v76 = 2080;
              double v77 = "TagMPWithOpportunisticBWEProbeSeq";
              __int16 v78 = 1024;
              int v79 = 612;
              __int16 v80 = 1024;
              unsigned int v81 = v53;
              __int16 v82 = 1024;
              unsigned int v83 = v54;
              __int16 v84 = 1024;
              unsigned int v85 = HIWORD(v55);
              __int16 v86 = 1024;
              unsigned int v87 = v56;
              __int16 v88 = 1024;
              unsigned int v89 = v57;
              __int16 v90 = 2048;
              double v91 = v58;
              __int16 v92 = 1024;
              int v93 = v59;
              __int16 v94 = 2048;
              uint64_t v95 = v60;
              __int16 v96 = 2048;
              double v97 = a4;
              __int16 v98 = 1024;
              unsigned int v99 = v22;
              _os_log_debug_impl(&dword_1E1EA4000, v26, OS_LOG_TYPE_DEBUG, " [%s] %s:%d OpportunisticBWEProbeSeqTagging: ^^^^^^ MP %d  %d/%d/%d P: %d  pTWL: %p %d  sched: %.3f now: %.3f PROBE_id: %d ", buf, 0x64u);
            }
            goto LABEL_28;
          }
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v28 = *(_DWORD *)(*(void *)&v8 + 1516);
            unsigned int v29 = bswap32(*(_DWORD *)(*(void *)&v8 + 1508));
            unsigned int v30 = bswap32(*(unsigned __int16 *)(*(void *)&v8 + 1506));
            int v31 = **(_DWORD **)&v8;
            unsigned int v32 = *(unsigned __int8 *)(*(void *)&v8 + 1576);
            double v33 = *a1;
            int v34 = *((_DWORD *)a1 + 8);
            uint64_t v35 = *(void *)(*(void *)&v8 + 1608);
            *(_DWORD *)buf = 136318210;
            uint64_t v75 = v25;
            __int16 v76 = 2080;
            double v77 = "TagMPWithOpportunisticBWEProbeSeq";
            __int16 v78 = 1024;
            int v79 = 612;
            __int16 v80 = 1024;
            unsigned int v81 = v28;
            __int16 v82 = 1024;
            unsigned int v83 = v29;
            __int16 v84 = 1024;
            unsigned int v85 = HIWORD(v30);
            __int16 v86 = 1024;
            unsigned int v87 = v31;
            __int16 v88 = 1024;
            unsigned int v89 = v32;
            __int16 v90 = 2048;
            double v91 = v33;
            __int16 v92 = 1024;
            int v93 = v34;
            __int16 v94 = 2048;
            uint64_t v95 = v35;
            __int16 v96 = 2048;
            double v97 = a4;
            __int16 v98 = 1024;
            unsigned int v99 = v22;
            int v36 = v26;
LABEL_22:
            _os_log_impl(&dword_1E1EA4000, v36, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d OpportunisticBWEProbeSeqTagging: ^^^^^^ MP %d  %d/%d/%d P: %d  pTWL: %p %d  sched: %.3f now: %.3f PROBE_id: %d ", buf, 0x64u);
          }
        }
      }
LABEL_28:
      int v7 = (void *)(*(void *)&v8 + 1568);
      uint64_t v9 = (v9 + 1);
      double v8 = v10;
      if (v10 == 0.0) {
        goto LABEL_36;
      }
    }
    if (!v6) {
      goto LABEL_28;
    }
    goto LABEL_15;
  }
  uint64_t v9 = 0;
LABEL_36:
  *a2 = v7;
  return v9;
}

void Throttling_MediaQueue_SetAudioInterval(uint64_t a1, double a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  *(double *)(a1 + 40) = a2;
  CFIndex v2 = (uint64_t *)(a1 + 40);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v3 = VRTraceErrorLogLevelToCSTR();
    CFAllocatorRef v4 = *MEMORY[0x1E4F47A50];
    uint64_t v5 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = *v2;
        int v7 = 136315906;
        uint64_t v8 = v3;
        __int16 v9 = 2080;
        double v10 = "Throttling_MediaQueue_SetAudioInterval";
        __int16 v11 = 1024;
        int v12 = 1114;
        __int16 v13 = 2048;
        uint64_t v14 = v6;
        _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d MediaQueue_Throttling_SetAudioInterval: %f", (uint8_t *)&v7, 0x26u);
      }
    }
    else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      Throttling_MediaQueue_SetAudioInterval_cold_1();
    }
  }
}

void Throttling_MediaQueue_SetIsIPv6(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a1 + 48) = a2;
  if (a2) {
    int v3 = 48;
  }
  else {
    int v3 = 28;
  }
  *(_DWORD *)(a1 + 52) = v3;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    uint64_t v5 = *MEMORY[0x1E4F47A50];
    uint64_t v6 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = 136315906;
        uint64_t v8 = v4;
        __int16 v9 = 2080;
        double v10 = "Throttling_MediaQueue_SetIsIPv6";
        __int16 v11 = 1024;
        int v12 = 1121;
        __int16 v13 = 1024;
        int v14 = a2;
        _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d MediaQueue_Throttling_SetIsIPv6: %d ", (uint8_t *)&v7, 0x22u);
      }
    }
    else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      Throttling_MediaQueue_SetIsIPv6_cold_1(v4, a2, v5);
    }
  }
}

uint64_t Throttling_MediaQueue_FlushThrottlingQueue(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v24 = 0;
  int active = ActiveProbing_FlushPendingPackets(a1, &v24);
  if (*(void *)a2)
  {
    uint64_t v6 = v24;
    if (v24)
    {
      do
      {
        uint64_t v7 = v6;
        uint64_t v6 = *(void *)(v6 + 1568);
      }
      while (v6);
      uint64_t v8 = (uint64_t *)(v7 + 1568);
    }
    else
    {
      uint64_t v8 = &v24;
    }
    *(void *)buf = v8;
    int v9 = ProcessThrottledPktsWithTime((double *)a2, (void **)buf, 0, *(double *)(a2 + 16));
  }
  else
  {
    int v9 = 0;
  }
  uint64_t v10 = *(void *)(a2 + 16);
  *(double *)(a2 + 16) = micro();
  if (*(void *)a2 || *(_DWORD *)(a2 + 32))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v11 = VRTraceErrorLogLevelToCSTR();
      int v12 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        double v13 = *(double *)a2;
        int v14 = *(_DWORD *)(a2 + 32);
        *(_DWORD *)buf = 136316674;
        *(void *)&uint8_t buf[4] = v11;
        __int16 v26 = 2080;
        unsigned int v27 = "Throttling_MediaQueue_FlushThrottlingQueue";
        __int16 v28 = 1024;
        int v29 = 1147;
        __int16 v30 = 2048;
        *(double *)int v31 = v13;
        *(_WORD *)&v31[8] = 1024;
        *(_DWORD *)unsigned int v32 = v14;
        *(_WORD *)&v32[4] = 1024;
        *(_DWORD *)&v32[6] = active;
        __int16 v33 = 1024;
        LODWORD(v34) = v9;
        uint64_t v15 = " [%s] %s:%d \t\t *** Unexpected: Flushing the throttling queue left some MPs %p %d ; flushed (%d %d) AP/Th pkts ";
        unsigned int v16 = v12;
        uint32_t v17 = 56;
LABEL_13:
        _os_log_impl(&dword_1E1EA4000, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    uint64_t v18 = VRTraceErrorLogLevelToCSTR();
    double v19 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = *(void *)(a2 + 16);
      *(_DWORD *)buf = 136316674;
      *(void *)&uint8_t buf[4] = v18;
      __int16 v26 = 2080;
      unsigned int v27 = "Throttling_MediaQueue_FlushThrottlingQueue";
      __int16 v28 = 1024;
      int v29 = 1150;
      __int16 v30 = 1024;
      *(_DWORD *)int v31 = active;
      *(_WORD *)&v31[4] = 1024;
      *(_DWORD *)&v31[6] = v9;
      *(_WORD *)unsigned int v32 = 2048;
      *(void *)&v32[2] = v10;
      __int16 v33 = 2048;
      uint64_t v34 = v20;
      uint64_t v15 = " [%s] %s:%d \t\t *** Flushing the throttling queue removed (%d %d) AP/Th pkts; LastThrottledVideoPktTime: %.3f->%.3f ";
      unsigned int v16 = v19;
      uint32_t v17 = 60;
      goto LABEL_13;
    }
  }
  if (v24)
  {
    uint64_t v21 = *a3;
    if (*a3)
    {
      do
      {
        uint64_t v22 = v21;
        uint64_t v21 = *(void *)(v21 + 1568);
      }
      while (v21);
      a3 = (uint64_t *)(v22 + 1568);
    }
    *a3 = v24;
  }
  return (v9 + active);
}

float Throttling_RTP_SendRTP_SetThrottlingParams(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 1600) = 0;
  if (*(_DWORD *)(a1 + 1516))
  {
    *(_WORD *)(a1 + 1576) = *(_WORD *)(a2 + 2);
    if (*(unsigned char *)a2) {
      *(_DWORD *)(a1 + 1600) = *(_DWORD *)(a2 + 8);
    }
  }
  else
  {
    *(unsigned char *)(a1 + 1576) = 0;
    float result = *(float *)(a2 + 20);
    *(float *)(a1 + 1616) = result;
  }
  return result;
}

uint64_t Throttling_VideoTransmitterUtil_ForceFirstProbePktSize(int a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (a1 < 207 || (int)a2 > 206)
  {
    if ((int)a2 <= 206 && (int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      uint64_t v8 = VRTraceErrorLogLevelToCSTR();
      int v9 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v11 = 136316162;
        uint64_t v12 = v8;
        __int16 v13 = 2080;
        int v14 = "Throttling_VideoTransmitterUtil_ForceFirstProbePktSize";
        __int16 v15 = 1024;
        int v16 = 1220;
        __int16 v17 = 1024;
        int v18 = a1;
        __int16 v19 = 1024;
        int v20 = a2;
        _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d \t\t FORCE_MIN_PKT did NOT take effect: iGobBytes: %d  iPktBytes: %d ", (uint8_t *)&v11, 0x28u);
      }
    }
    return a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() < 8)
  {
    return 207;
  }
  else
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    uint64_t v5 = *MEMORY[0x1E4F47A50];
    uint64_t v6 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      uint64_t v7 = 207;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v11 = 136316418;
        uint64_t v12 = v4;
        __int16 v13 = 2080;
        int v14 = "Throttling_VideoTransmitterUtil_ForceFirstProbePktSize";
        __int16 v15 = 1024;
        int v16 = 1217;
        __int16 v17 = 1024;
        int v18 = a2;
        __int16 v19 = 1024;
        int v20 = 207;
        __int16 v21 = 1024;
        int v22 = a1;
        _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d \t\t FORCE_MIN_PKT org: %d new: %d gob: %d ", (uint8_t *)&v11, 0x2Eu);
      }
    }
    else
    {
      uint64_t v7 = 207;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        int v11 = 136316418;
        uint64_t v12 = v4;
        __int16 v13 = 2080;
        int v14 = "Throttling_VideoTransmitterUtil_ForceFirstProbePktSize";
        __int16 v15 = 1024;
        int v16 = 1217;
        __int16 v17 = 1024;
        int v18 = a2;
        __int16 v19 = 1024;
        int v20 = 207;
        __int16 v21 = 1024;
        int v22 = a1;
        _os_log_debug_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEBUG, " [%s] %s:%d \t\t FORCE_MIN_PKT org: %d new: %d gob: %d ", (uint8_t *)&v11, 0x2Eu);
      }
    }
  }
  return v7;
}

uint64_t Throttling_VideoTransmitter_ForceMinFirstProbePkt(int a1, unsigned int a2)
{
  return a1 & a2;
}

void Throttling_VideoTransmitter_CalcThrottlingRate(int a1, int a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (_MergedGlobals && (int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v14 = VRTraceErrorLogLevelToCSTR();
    __int16 v15 = *MEMORY[0x1E4F47A50];
    int v16 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        int v18 = 136316162;
        uint64_t v19 = v14;
        __int16 v20 = 2080;
        __int16 v21 = "Throttling_VideoTransmitter_CalcThrottlingRate";
        __int16 v22 = 1024;
        int v23 = 1236;
        __int16 v24 = 1024;
        int v25 = a2;
        __int16 v26 = 1024;
        int v27 = a3;
        _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d \n\t\t THROTTLING rate: Tx/Video Rate: %d/%d ", (uint8_t *)&v18, 0x28u);
      }
    }
    else if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      int v18 = 136316162;
      uint64_t v19 = v14;
      __int16 v20 = 2080;
      __int16 v21 = "Throttling_VideoTransmitter_CalcThrottlingRate";
      __int16 v22 = 1024;
      int v23 = 1236;
      __int16 v24 = 1024;
      int v25 = a2;
      __int16 v26 = 1024;
      int v27 = a3;
      _os_log_debug_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEBUG, " [%s] %s:%d \n\t\t THROTTLING rate: Tx/Video Rate: %d/%d ", (uint8_t *)&v18, 0x28u);
    }
  }
  *(unsigned char *)a8 = a1;
  *(unsigned char *)(a8 + 1) = a4;
  *(_DWORD *)(a8 + 4) = a5;
  *(_DWORD *)(a8 + 8) = a3;
  if ((a1 & a4) != 0) {
    int v17 = 1;
  }
  else {
    int v17 = a5;
  }
  *(_WORD *)(a8 + 2) = 0;
  *(_DWORD *)(a8 + 12) = v17;
  *(_DWORD *)(a8 + 16) = 0;
}

void Throttling_VideoTransmitter_SetPerPktProbeSeqState(uint64_t a1, int a2, int a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 1))
  {
    *(unsigned char *)(a1 + 2) = 0;
LABEL_22:
    *(unsigned char *)(a1 + 3) = 0;
    return;
  }
  int v6 = *(_DWORD *)(a1 + 12);
  *(unsigned char *)(a1 + 2) = v6 > a2;
  if (a2)
  {
    if (*(int *)(a1 + 16) <= 206)
    {
      *(unsigned char *)(a1 + 2) = 1;
      *(_DWORD *)(a1 + 12) = v6 + 1;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v7 = VRTraceErrorLogLevelToCSTR();
        uint64_t v8 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v9 = *(_DWORD *)(a1 + 12);
          int v10 = *(_DWORD *)(a1 + 16);
          int v19 = 136316930;
          uint64_t v20 = v7;
          __int16 v21 = 2080;
          __int16 v22 = "Throttling_VideoTransmitter_SetPerPktProbeSeqState";
          __int16 v23 = 1024;
          int v24 = 1306;
          __int16 v25 = 1024;
          int v26 = a2;
          __int16 v27 = 1024;
          int v28 = a3;
          __int16 v29 = 1024;
          int v30 = v9;
          __int16 v31 = 1024;
          int v32 = v10;
          __int16 v33 = 1024;
          int v34 = v10 + a3;
          _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ******** Throttling_VideoTransmitter_SetPerPktProbeSeqState: [%d]: %d  count: %d  iBweSeqLen: %d->%d ", (uint8_t *)&v19, 0x3Au);
        }
      }
    }
    if (*(unsigned char *)(a1 + 2))
    {
      int v11 = 0;
      *(_DWORD *)(a1 + 16) += a3;
      goto LABEL_13;
    }
  }
  else if (v6 > 0)
  {
    int v11 = 0;
    *(_DWORD *)(a1 + 16) = a3;
    goto LABEL_13;
  }
  int v11 = 1;
LABEL_13:
  if (!*(unsigned char *)(a1 + 1)) {
    goto LABEL_22;
  }
  if (a3 <= 206) {
    int v11 = 0;
  }
  *(unsigned char *)(a1 + 3) = v11;
  if (v11 == 1 && g_iBWEstLogLevel >= 6 && (int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v12 = VRTraceErrorLogLevelToCSTR();
    __int16 v13 = *MEMORY[0x1E4F47A50];
    uint64_t v14 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        int v15 = *(unsigned __int8 *)(a1 + 3);
        int v16 = *(unsigned __int8 *)(a1 + 2);
        int v19 = 136316418;
        uint64_t v20 = v12;
        __int16 v21 = 2080;
        __int16 v22 = "Throttling_VideoTransmitter_SetPerPktProbeSeqState";
        __int16 v23 = 1024;
        int v24 = 1327;
        __int16 v25 = 1024;
        int v26 = v15;
        __int16 v27 = 1024;
        int v28 = v16;
        __int16 v29 = 1024;
        int v30 = a3;
        _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  bPotentialPktProbeSeq: %d  bPktProbeSeqEnabled: %d  iPktBytes: %d ", (uint8_t *)&v19, 0x2Eu);
      }
    }
    else if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      int v17 = *(unsigned __int8 *)(a1 + 3);
      int v18 = *(unsigned __int8 *)(a1 + 2);
      int v19 = 136316418;
      uint64_t v20 = v12;
      __int16 v21 = 2080;
      __int16 v22 = "Throttling_VideoTransmitter_SetPerPktProbeSeqState";
      __int16 v23 = 1024;
      int v24 = 1327;
      __int16 v25 = 1024;
      int v26 = v17;
      __int16 v27 = 1024;
      int v28 = v18;
      __int16 v29 = 1024;
      int v30 = a3;
      _os_log_debug_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  bPotentialPktProbeSeq: %d  bPktProbeSeqEnabled: %d  iPktBytes: %d ", (uint8_t *)&v19, 0x2Eu);
    }
  }
}

void Throttling_AFRC_Init(BOOL *a1)
{
  a1[12] = 0;
  *(void *)(a1 + 4) = 0;
  *a1 = 1;
  Throttling_AFRC_GetDefaults(a1);
}

void Throttling_AFRC_GetDefaults(BOOL *a1)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  Boolean keyExistsAndHasValidFormat = 0;
  AppIntegerCFBooleanRef Value = CFPreferencesGetAppIntegerValue(@"Throttling", @"com.apple.VideoConference", &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat) {
    *a1 = AppIntegerValue != 0;
  }
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  uint64_t v4 = (unsigned char *)MEMORY[0x1E4F47A40];
  uint64_t v5 = (NSObject **)MEMORY[0x1E4F47A50];
  if (ErrorLogLevelForModule >= 8)
  {
    uint64_t v6 = VRTraceErrorLogLevelToCSTR();
    uint64_t v7 = *v5;
    uint64_t v8 = *v5;
    if (*v4)
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v9 = *a1;
        *(_DWORD *)buf = 136315906;
        uint64_t v32 = v6;
        __int16 v33 = 2080;
        int v34 = "Throttling_AFRC_GetDefaults";
        __int16 v35 = 1024;
        int v36 = 1480;
        __int16 v37 = 1024;
        int v38 = v9;
        _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Throttling: %d ", buf, 0x22u);
      }
    }
    else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      Throttling_AFRC_GetDefaults_cold_2();
    }
  }
  int v10 = CFPreferencesGetAppIntegerValue(@"HardCodeBWEstRate", @"com.apple.VideoConference", &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat) {
    int v11 = v10;
  }
  else {
    int v11 = 0;
  }
  *((_DWORD *)a1 + 1) = v11;
  int v12 = CFPreferencesGetAppIntegerValue(@"HardCodeTxRate", @"com.apple.VideoConference", &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat) {
    int v13 = v12;
  }
  else {
    int v13 = 0;
  }
  *((_DWORD *)a1 + 2) = v13;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v14 = VRTraceErrorLogLevelToCSTR();
    int v15 = *v5;
    int v16 = *v5;
    if (*v4)
    {
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        int v17 = *((_DWORD *)a1 + 1);
        int v18 = *((_DWORD *)a1 + 2);
        *(_DWORD *)buf = 136316162;
        uint64_t v32 = v14;
        __int16 v33 = 2080;
        int v34 = "Throttling_AFRC_GetDefaults";
        __int16 v35 = 1024;
        int v36 = 1488;
        __int16 v37 = 1024;
        int v38 = v17;
        __int16 v39 = 1024;
        int v40 = v18;
        _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d dwHardCodeBWEstRate: %d \t dwHardCodeTxRate: %d ", buf, 0x28u);
      }
    }
    else if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      int v28 = *((_DWORD *)a1 + 1);
      int v29 = *((_DWORD *)a1 + 2);
      *(_DWORD *)buf = 136316162;
      uint64_t v32 = v14;
      __int16 v33 = 2080;
      int v34 = "Throttling_AFRC_GetDefaults";
      __int16 v35 = 1024;
      int v36 = 1488;
      __int16 v37 = 1024;
      int v38 = v28;
      __int16 v39 = 1024;
      int v40 = v29;
      _os_log_debug_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEBUG, " [%s] %s:%d dwHardCodeBWEstRate: %d \t dwHardCodeTxRate: %d ", buf, 0x28u);
    }
  }
  BOOL v19 = CFPreferencesGetAppIntegerValue(@"ThrottlingSendLog", @"com.apple.VideoConference", &keyExistsAndHasValidFormat) != 0;
  if (keyExistsAndHasValidFormat) {
    BOOL v20 = v19;
  }
  else {
    BOOL v20 = _MergedGlobals != 0;
  }
  _MergedGlobals = v20;
  BOOL v21 = CFPreferencesGetAppIntegerValue(@"ThrottlingRecvLog", @"com.apple.VideoConference", &keyExistsAndHasValidFormat) != 0;
  if (keyExistsAndHasValidFormat) {
    BOOL v22 = v21;
  }
  else {
    BOOL v22 = byte_1EB5E6439 != 0;
  }
  byte_1EB5E6439 = v22;
  BOOL v23 = CFPreferencesGetAppIntegerValue(@"ThrottlingProbeSeqLog", @"com.apple.VideoConference", &keyExistsAndHasValidFormat) != 0;
  if (keyExistsAndHasValidFormat) {
    BOOL v24 = v23;
  }
  else {
    BOOL v24 = g_bThrottlingProbeSeqLog != 0;
  }
  g_bThrottlingProbeSeqLog = v24;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v25 = VRTraceErrorLogLevelToCSTR();
    int v26 = *v5;
    __int16 v27 = *v5;
    if (*v4)
    {
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316418;
        uint64_t v32 = v25;
        __int16 v33 = 2080;
        int v34 = "Throttling_AFRC_GetDefaults";
        __int16 v35 = 1024;
        int v36 = 1500;
        __int16 v37 = 1024;
        int v38 = _MergedGlobals;
        __int16 v39 = 1024;
        int v40 = byte_1EB5E6439;
        __int16 v41 = 1024;
        int v42 = g_bThrottlingProbeSeqLog;
        _os_log_impl(&dword_1E1EA4000, v26, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d g_bThrottlingSendLog: %d  g_bThrottlingRecvLog: %d  g_bThrottlingProbeSeqLog: %d ", buf, 0x2Eu);
      }
    }
    else if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
    {
      Throttling_AFRC_GetDefaults_cold_1(v25, v26);
    }
  }
}

BOOL Throttling_AFRC_IsInThrottlingMode(unsigned char *a1, unsigned int a2)
{
  BOOL v3 = a2 >> 5 < 0xC35 && *a1 != 0;
  a1[12] = v3;
  return v3;
}

uint64_t Throttling_AFRC_OverrideRxEstimate(uint64_t result, _DWORD *a2)
{
  int v2 = *(_DWORD *)(result + 4);
  if (v2) {
    *a2 = v2;
  }
  return result;
}

void sub_1E2261830(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t DTLS_SocketRead(uint64_t a1, void *a2, int64_t *a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  CFDataRef v6 = *(const __CFData **)(a1 + 424);
  CFIndex Length = CFDataGetLength(v6);
  int64_t v8 = *a3;
  if (*a3 > Length)
  {
    memset(__b, 170, sizeof(__b));
    if (*(_DWORD *)(a1 + 352) == 2)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v9 = VRTraceErrorLogLevelToCSTR();
        int v10 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int v15 = 136316162;
          *(void *)&v15[4] = v9;
          *(_WORD *)&v15[12] = 2080;
          *(void *)&v15[14] = "DTLS_SocketRead";
          __int16 v16 = 1024;
          int v17 = 119;
          __int16 v18 = 1024;
          int v19 = v8;
          __int16 v20 = 1024;
          int v21 = Length;
          _os_log_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d DTLS_SocketRead something terrible happened! %d wanted %d have", v15, 0x28u);
        }
      }
    }
    else
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 448));
      uint64_t v11 = *(void *)(a1 + 440);
      if ((v11
         || (*(_OWORD *)int v15 = xmmword_1E25A0540,
             pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 512), (pthread_mutex_t *)(a1 + 448), (const timespec *)v15), (uint64_t v11 = *(void *)(a1 + 440)) != 0))&& *(int *)(v11 + 2052) < 2049)
      {
        __memcpy_chk();
        CFIndex v12 = *(int *)(v11 + 2052);
        *(void *)(a1 + 440) = *(void *)(v11 + 2056);
        free((void *)v11);
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 448));
        if (v12)
        {
          CFDataAppendBytes(v6, __b, v12);
          CFIndex Length = CFDataGetLength(v6);
        }
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 448));
      }
    }
  }
  if (Length >= v8)
  {
    MutableBytePtr = CFDataGetMutableBytePtr(v6);
    memmove(a2, MutableBytePtr, v8);
    v24.location = 0;
    v24.length = v8;
    CFDataDeleteBytes(v6, v24);
    return 0;
  }
  else
  {
    *a3 = 0;
    return 4294957493;
  }
}

uint64_t DTLS_SocketWrite(uint64_t a1, const void *a2, size_t *a3)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  int v6 = *(_DWORD *)(a1 + 12);
  int v7 = *(_DWORD *)(a1 + 52);
  long long v8 = *(_OWORD *)(a1 + 188);
  long long v58 = *(_OWORD *)(a1 + 172);
  long long v59 = v8;
  uint64_t v60 = *(void *)(a1 + 204);
  unint64_t v56 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v57 = 0xAAAAAAAAAAAAAAAALL;
  memset(v55, 170, sizeof(v55));
  unint64_t v54 = 0xAAAAAAAAAAAAAAAALL;
  if (*(_DWORD *)(a1 + 352) == 2) {
    int v9 = v6;
  }
  else {
    int v9 = 3;
  }
  if (*(_DWORD *)(a1 + 352) == 2) {
    int v10 = 3;
  }
  else {
    int v10 = 0;
  }
  if (v7)
  {
    socklen_t v22 = 28;
    uint64_t v11 = IPPORTToSA6();
  }
  else
  {
    socklen_t v22 = 16;
    uint64_t v11 = IPPORTToSA();
  }
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v49 = 0u;
  long long v48 = 0u;
  long long v47 = 0u;
  long long v46 = 0u;
  long long v45 = 0u;
  long long v44 = 0u;
  long long v43 = 0u;
  long long v42 = 0u;
  long long v41 = 0u;
  long long v40 = 0u;
  long long v39 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v34 = 0u;
  int v12 = *(_DWORD *)(a1 + 8);
  v33[0] = v9;
  v33[1] = v12;
  HIDWORD(v42) = v10;
  BYTE1(v44) = 1;
  int v13 = VTP_Sendto(*(_DWORD *)a1, a2, *a3, 0, v11, v22, v33);
  int v14 = v13;
  if (v13 == -1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v18 = VRTraceErrorLogLevelToCSTR();
      int v19 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        DTLS_SocketWrite_cold_1(v18, (uint64_t *)a3, v19);
      }
    }
    size_t v17 = 0;
  }
  else
  {
    if (v13 >= *(_DWORD *)a3)
    {
      uint64_t result = 0;
      size_t v17 = v14;
      goto LABEL_22;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v15 = VRTraceErrorLogLevelToCSTR();
      __int16 v16 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        size_t v21 = *a3;
        *(_DWORD *)buf = 136316162;
        uint64_t v24 = v15;
        __int16 v25 = 2080;
        int v26 = "DTLS_SocketWrite";
        __int16 v27 = 1024;
        int v28 = 190;
        __int16 v29 = 1024;
        int v30 = v14;
        __int16 v31 = 1024;
        int v32 = v21;
        _os_log_error_impl(&dword_1E1EA4000, v16, OS_LOG_TYPE_ERROR, " [%s] %s:%d SECURETRANSPORT WRITE TOO FEW BYTES (%d of %d bytes)...", buf, 0x28u);
      }
    }
    size_t v17 = v14;
  }
  uint64_t result = 4294957493;
LABEL_22:
  *a3 = v17;
  return result;
}

uint64_t DTLS_Create(uint64_t *a1, int a2, char a3, int a4, int a5, const void *a6, const void *a7)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = 2149777411;
  uint64_t v15 = (char *)malloc_type_calloc(1uLL, 0x268uLL, 0x106004055F88EB1uLL);
  if (v15)
  {
    __int16 v16 = v15;
    uint64_t Handle = CreateHandle();
    *a1 = Handle;
    if (Handle == 0xFFFFFFFFLL)
    {
      return 2149777413;
    }
    else
    {
      v33.__sig = 0xAAAAAAAAAAAAAAAALL;
      *(void *)v33.__opaque = 0xAAAAAAAAAAAAAAAALL;
      if (!pthread_mutexattr_init(&v33))
      {
        pthread_mutexattr_settype(&v33, 2);
        pthread_mutex_init((pthread_mutex_t *)(v16 + 360), &v33);
        pthread_mutexattr_destroy(&v33);
      }
      pthread_mutex_init((pthread_mutex_t *)v16 + 7, 0);
      pthread_cond_init((pthread_cond_t *)(v16 + 512), 0);
      CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      *((void *)v16 + 53) = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
      *(_OWORD *)(v16 + 568) = 0u;
      *((void *)v16 + 73) = a6;
      if (a6)
      {
        CFRetain(a6);
        *((void *)v16 + 74) = SecCertificateCreateWithBytes();
        *((void *)v16 + 75) = SecCertificateCreateWithBytes();
        uint64_t v19 = SecCertificateCreateWithBytes();
        *((void *)v16 + 76) = v19;
        values = (void *)*((void *)v16 + 74);
        *(void *)int v26 = *((void *)v16 + 73);
        *(void *)&v26[8] = v19;
        *(void *)&v26[16] = *((void *)v16 + 75);
        *((void *)v16 + 72) = CFArrayCreate(v18, (const void **)&values, 1, 0);
        *((void *)v16 + 71) = CFArrayCreate(v18, (const void **)v26, 3, 0);
      }
      *(_DWORD *)__int16 v16 = a2;
      *((_DWORD *)v16 + 1) = a4;
      v16[16] = a3;
      *((_DWORD *)v16 + 2) = a5;
      *((_DWORD *)v16 + 3) = 0;
      if (a7) {
        memcpy(v16 + 24, a7, 0x140uLL);
      }
      *((void *)v16 + 54) = 20;
      LOBYTE(values) = 0;
      AppIntegerCFBooleanRef Value = CFPreferencesGetAppIntegerValue(@"dtlsHandshakeTimeout", @"com.apple.VideoConference", (Boolean *)&values);
      if ((_BYTE)values)
      {
        CFIndex v21 = AppIntegerValue;
        if ((unint64_t)(AppIntegerValue - 61) >= 0xFFFFFFFFFFFFFFC4)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            uint64_t v22 = VRTraceErrorLogLevelToCSTR();
            uint64_t v23 = *MEMORY[0x1E4F47A50];
            uint64_t v24 = *MEMORY[0x1E4F47A50];
            if (*MEMORY[0x1E4F47A40])
            {
              if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)int v26 = 136316162;
                *(void *)&v26[4] = v22;
                *(_WORD *)&v26[12] = 2080;
                *(void *)&v26[14] = "DTLS_Create";
                *(_WORD *)&unsigned char v26[22] = 1024;
                int v27 = 284;
                __int16 v28 = 1024;
                int v29 = v21;
                __int16 v30 = 1024;
                int v31 = a4;
                _os_log_impl(&dword_1E1EA4000, v23, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d DTLS timeout: set via preferences to %d seconds for call (%d)", v26, 0x28u);
              }
            }
            else if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int v26 = 136316162;
              *(void *)&v26[4] = v22;
              *(_WORD *)&v26[12] = 2080;
              *(void *)&v26[14] = "DTLS_Create";
              *(_WORD *)&unsigned char v26[22] = 1024;
              int v27 = 284;
              __int16 v28 = 1024;
              int v29 = v21;
              __int16 v30 = 1024;
              int v31 = a4;
              _os_log_debug_impl(&dword_1E1EA4000, v23, OS_LOG_TYPE_DEBUG, " [%s] %s:%d DTLS timeout: set via preferences to %d seconds for call (%d)", v26, 0x28u);
            }
          }
          *((void *)v16 + 54) = v21;
        }
      }
      return 0;
    }
  }
  return v14;
}

uint64_t DTLS_Cleanup(int a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = CheckInHandleDebug();
  if (!v2) {
    return 2149777410;
  }
  uint64_t v3 = v2;
  SSLClose(*(SSLContextRef *)(v2 + 344));
  CheckOutHandleDebug();
  _SSLDisposeContext();
  *(void *)(v3 + 344) = 0;
  while (1)
  {
    uint64_t v4 = *(void **)(v3 + 440);
    if (!v4) {
      break;
    }
    *(void *)(v3 + 440) = v4[257];
    free(v4);
  }
  uint64_t v5 = *(const void **)(v3 + 608);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(v3 + 608) = 0;
  }
  int v6 = *(const void **)(v3 + 600);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(v3 + 600) = 0;
  }
  int v7 = *(const void **)(v3 + 592);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(v3 + 592) = 0;
  }
  long long v8 = *(const void **)(v3 + 568);
  if (v8)
  {
    CFRelease(v8);
    *(void *)(v3 + 568) = 0;
  }
  int v9 = *(const void **)(v3 + 576);
  if (v9)
  {
    CFRelease(v9);
    *(void *)(v3 + 576) = 0;
  }
  int v10 = *(const void **)(v3 + 584);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(v3 + 584) = 0;
  }
  uint64_t v11 = *(const void **)(v3 + 560);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(v3 + 560) = 0;
  }
  int v12 = *(const void **)(v3 + 424);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(v3 + 424) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)(v3 + 360));
  pthread_mutex_destroy((pthread_mutex_t *)(v3 + 448));
  pthread_cond_destroy((pthread_cond_t *)(v3 + 512));
  free((void *)v3);
  if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
    return 0;
  }
  uint64_t v13 = VRTraceErrorLogLevelToCSTR();
  uint64_t v14 = *MEMORY[0x1E4F47A50];
  uint64_t v15 = *MEMORY[0x1E4F47A50];
  if (*MEMORY[0x1E4F47A40])
  {
    BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v16)
    {
      int v18 = 136315906;
      uint64_t v19 = v13;
      __int16 v20 = 2080;
      CFIndex v21 = "DTLS_Cleanup";
      __int16 v22 = 1024;
      int v23 = 325;
      __int16 v24 = 1024;
      int v25 = a1;
      _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d DTLS_Cleanup done on handle %d", (uint8_t *)&v18, 0x22u);
      return 0;
    }
  }
  else
  {
    uint64_t result = os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG);
    if (result)
    {
      DTLS_Cleanup_cold_1();
      return 0;
    }
  }
  return result;
}

uint64_t DTLS_Handshake(uint64_t a1, CFErrorRef *a2, uint64_t a3)
{
  *(void *)&v39[5] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = 2149777460;
  uint64_t v6 = CheckInHandleDebug();
  if (v6)
  {
    uint64_t v7 = v6;
    if (a2) {
      *a2 = 0;
    }
    userInfoValues = 0;
    __int16 v30 = (const void *)*MEMORY[0x1E4F1D170];
    long long v8 = (SSLContextRef *)(v6 + 344);
    if (_SSLNewDatagramContext())
    {
      if (a2)
      {
        userInfoValues = @"No datagram context available";
        CFIndex v9 = 1;
        int v10 = 1;
LABEL_14:
        *a2 = CFErrorCreateWithUserInfoKeysAndValues(0, @"DTLS", v9, &v30, (const void *const *)&userInfoValues, 1);
        goto LABEL_35;
      }
      goto LABEL_34;
    }
    if (SSLSetIOFuncs(*v8, (SSLReadFunc)DTLS_SocketRead, (SSLWriteFunc)DTLS_SocketWrite))
    {
      if (a2)
      {
        userInfoValues = @"Could not set I/O functions";
        int v10 = 1;
        CFIndex v9 = 2;
        goto LABEL_14;
      }
      goto LABEL_34;
    }
    if (SSLSetConnection(*(SSLContextRef *)(v7 + 344), (SSLConnectionRef)v7))
    {
      if (a2)
      {
        userInfoValues = @"Could not set connection";
        int v10 = 1;
        CFIndex v9 = 3;
        goto LABEL_14;
      }
      goto LABEL_34;
    }
    if (*(void *)(v7 + 576))
    {
      if (_SSLSetTrustedRoots())
      {
        if (a2)
        {
          userInfoValues = @"Could not set root certificates";
          int v10 = 1;
          CFIndex v9 = 5;
          goto LABEL_14;
        }
        goto LABEL_34;
      }
      CFArrayRef v11 = *(const __CFArray **)(v7 + 568);
      if (v11)
      {
        if (SSLSetCertificate(*v8, v11))
        {
          if (a2)
          {
            userInfoValues = @"Could not set certificate array";
            int v10 = 1;
            CFIndex v9 = 7;
            goto LABEL_14;
          }
          goto LABEL_34;
        }
        if (SSLSetMaxDatagramRecordSize(*v8, 0x4AAuLL))
        {
          if (a2)
          {
            userInfoValues = @"Could not set max datagram record size";
            int v10 = 1;
            CFIndex v9 = 8;
            goto LABEL_14;
          }
          goto LABEL_34;
        }
        if (*(unsigned char *)(v7 + 16) && SSLSetClientSideAuthenticate(*v8, kAlwaysAuthenticate))
        {
          if (a2)
          {
            userInfoValues = @"Could not enable client authentication";
            int v10 = 1;
            CFIndex v9 = 9;
            goto LABEL_14;
          }
LABEL_34:
          int v10 = 1;
          goto LABEL_35;
        }
        int v24 = 100 * *(_DWORD *)(v7 + 432);
        int v25 = (SSLSessionState *)(v7 + 352);
        *(_DWORD *)(v7 + 352) = 1;
        do
        {
          OSStatus v26 = SSLHandshake(*v8);
          int v10 = v26;
          if (v24 < 2) {
            break;
          }
          --v24;
        }
        while (v26 == -9803);
        if (v26 || SSLGetSessionState(*v8, v25))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            uint64_t v27 = VRTraceErrorLogLevelToCSTR();
            __int16 v28 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              SSLSessionState v29 = *v25;
              *(_DWORD *)buf = 136316162;
              uint64_t v33 = v27;
              __int16 v34 = 2080;
              long long v35 = "DTLS_Handshake";
              __int16 v36 = 1024;
              int v37 = 445;
              __int16 v38 = 1024;
              *(_DWORD *)long long v39 = v10;
              v39[2] = 1024;
              *(_DWORD *)&v39[3] = v29;
              _os_log_impl(&dword_1E1EA4000, v28, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SECURETRANSPORT %d %d", buf, 0x28u);
            }
          }
          *int v25 = kSSLAborted;
          if (a2)
          {
            userInfoValues = @"Handshake failed";
            CFIndex v9 = 10;
            goto LABEL_14;
          }
LABEL_35:
          if (a3)
          {
            int v12 = (*(uint64_t (**)(uint64_t, CFErrorRef *, SSLContextRef))(a3 + 16))(a3, a2, *v8);
            if (v12) {
              uint64_t v5 = 0;
            }
            else {
              uint64_t v5 = 2149777460;
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
            {
              uint64_t v13 = VRTraceErrorLogLevelToCSTR();
              uint64_t v14 = *MEMORY[0x1E4F47A50];
              uint64_t v15 = *MEMORY[0x1E4F47A50];
              if (!*MEMORY[0x1E4F47A40])
              {
                if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
                  DTLS_Handshake_cold_2(v13, v12 == 0, v14);
                }
                goto LABEL_55;
              }
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
              {
                BOOL v16 = "OK";
                *(_DWORD *)buf = 136315906;
                uint64_t v33 = v13;
                __int16 v34 = 2080;
                if (!v12) {
                  BOOL v16 = "NO";
                }
                long long v35 = "DTLS_Handshake";
                __int16 v36 = 1024;
                int v37 = 463;
                __int16 v38 = 2080;
                *(void *)long long v39 = v16;
                size_t v17 = " [%s] %s:%d SECURETRANSPORT SETUP %s...";
                int v18 = v14;
                uint32_t v19 = 38;
                goto LABEL_50;
              }
            }
          }
          else if (v10 && (int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            uint64_t v20 = VRTraceErrorLogLevelToCSTR();
            CFIndex v21 = *MEMORY[0x1E4F47A50];
            __int16 v22 = *MEMORY[0x1E4F47A50];
            if (!*MEMORY[0x1E4F47A40])
            {
              if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
                DTLS_Handshake_cold_1(v20);
              }
              goto LABEL_55;
            }
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              uint64_t v33 = v20;
              __int16 v34 = 2080;
              long long v35 = "DTLS_Handshake";
              __int16 v36 = 1024;
              int v37 = 466;
              size_t v17 = " [%s] %s:%d SECURETRANSPORT FAILED...";
              int v18 = v21;
              uint32_t v19 = 28;
LABEL_50:
              _os_log_impl(&dword_1E1EA4000, v18, OS_LOG_TYPE_DEFAULT, v17, buf, v19);
            }
          }
LABEL_55:
          CheckOutHandleDebug();
          return v5;
        }
      }
      else if (a2)
      {
        int v10 = 0;
        userInfoValues = @"No certificate array available";
        CFIndex v9 = 6;
        goto LABEL_14;
      }
    }
    else if (a2)
    {
      int v10 = 0;
      userInfoValues = @"No root certificates available";
      CFIndex v9 = 4;
      goto LABEL_14;
    }
    int v10 = 0;
    goto LABEL_35;
  }
  return 2149777410;
}

uint64_t DTLS_UpdateHandshake(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = 2149777412;
  if (a2)
  {
    uint64_t v7 = CheckInHandleDebug();
    if (v7)
    {
      uint64_t v8 = v7;
      if (*(_DWORD *)(v7 + 4) == a4 && a3 <= 0x800 && *(int *)(v7 + 352) >= 1)
      {
        CFIndex v9 = malloc_type_malloc(0x810uLL, 0x1020040DC7F7759uLL);
        if (v9)
        {
          int v10 = v9;
          __memcpy_chk();
          v10[513] = a3;
          *((void *)v10 + 257) = 0;
          pthread_mutex_lock((pthread_mutex_t *)(v8 + 448));
          uint64_t v11 = *(void *)(v8 + 440);
          if (v11)
          {
            do
            {
              uint64_t v12 = v11;
              uint64_t v11 = *(void *)(v11 + 2056);
            }
            while (v11);
            uint64_t v13 = (void *)(v12 + 2056);
          }
          else
          {
            uint64_t v13 = (void *)(v8 + 440);
          }
          *uint64_t v13 = v10;
          pthread_cond_signal((pthread_cond_t *)(v8 + 512));
          pthread_mutex_unlock((pthread_mutex_t *)(v8 + 448));
          if (*(_DWORD *)(v8 + 352) == 2)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
            {
              uint64_t v16 = VRTraceErrorLogLevelToCSTR();
              size_t v17 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                int v19 = 136315650;
                uint64_t v20 = v16;
                __int16 v21 = 2080;
                __int16 v22 = "DTLS_UpdateHandshake";
                __int16 v23 = 1024;
                int v24 = 514;
                _os_log_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d DTLS_UpdateHandshake:: process late incoming handshake packet...", (uint8_t *)&v19, 0x1Cu);
              }
            }
            *(_DWORD *)(v8 + 352) = 1;
            SSLHandshake(*(SSLContextRef *)(v8 + 344));
            uint64_t v4 = 0;
            *(_DWORD *)(v8 + 352) = 2;
          }
          else
          {
            uint64_t v4 = 0;
          }
        }
        else
        {
          uint64_t v4 = 2149777411;
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v14 = VRTraceErrorLogLevelToCSTR();
        uint64_t v15 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v19 = 136315650;
          uint64_t v20 = v14;
          __int16 v21 = 2080;
          __int16 v22 = "DTLS_UpdateHandshake";
          __int16 v23 = 1024;
          int v24 = 523;
          _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d DTLS_UpdateHandshake invalid incoming handshake packet", (uint8_t *)&v19, 0x1Cu);
        }
      }
      CheckOutHandleDebug();
    }
    else
    {
      return 2149777410;
    }
  }
  return v4;
}

BOOL DTLS_IsConnected()
{
  uint64_t v0 = CheckInHandleDebug();
  if (!v0) {
    return 0;
  }
  BOOL v1 = *(_DWORD *)(v0 + 352) == 2;
  CheckOutHandleDebug();
  return v1;
}

uint64_t DTLS_Read(uint64_t a1, OpaqueCMBlockBuffer *a2, CMBlockBufferRef *a3, const __CFAllocator *a4, const __CFAllocator *a5)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  dataPointerOut = 0;
  size_t totalLengthOut = 0;
  CMBlockBufferRef theBuffer = 0;
  size_t processed = 0;
  if (a3) {
    *a3 = 0;
  }
  uint64_t v9 = 2149777412;
  uint64_t v10 = CheckInHandleDebug();
  if (!v10) {
    return 2149777410;
  }
  uint64_t v11 = v10;
  if (*(_DWORD *)(v10 + 352) == 2)
  {
    uint64_t v12 = (pthread_mutex_t *)(v10 + 360);
    pthread_mutex_lock((pthread_mutex_t *)(v10 + 360));
    OSStatus DataPointer = CMBlockBufferGetDataPointer(a2, 0, 0, &totalLengthOut, &dataPointerOut);
    if (DataPointer)
    {
      OSStatus v17 = DataPointer;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v23 = VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          DTLS_Read_cold_4(v23);
        }
      }
    }
    else
    {
      CFIndex Length = CFDataGetLength(*(CFDataRef *)(v11 + 424));
      if (Length)
      {
        v37.length = Length;
        v37.location = 0;
        CFDataDeleteBytes(*(CFMutableDataRef *)(v11 + 424), v37);
      }
      CFDataAppendBytes(*(CFMutableDataRef *)(v11 + 424), (const UInt8 *)dataPointerOut, totalLengthOut);
      OSStatus v15 = CMBlockBufferCreateWithMemoryBlock(a4, 0, totalLengthOut, a5, 0, 0, totalLengthOut, 1u, &theBuffer);
      if (v15)
      {
        OSStatus v17 = v15;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            DTLS_Read_cold_3();
          }
        }
      }
      else
      {
        OSStatus v16 = CMBlockBufferGetDataPointer(theBuffer, 0, 0, &totalLengthOut, &dataPointerOut);
        if (v16)
        {
          OSStatus v17 = v16;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              DTLS_Read_cold_2();
            }
          }
        }
        else
        {
          OSStatus v17 = SSLRead(*(SSLContextRef *)(v11 + 344), dataPointerOut, totalLengthOut, &processed);
          if (v17)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                DTLS_Read_cold_1();
              }
            }
          }
        }
      }
    }
    pthread_mutex_unlock(v12);
    CheckOutHandleDebug();
    if (a3 && !v17)
    {
      if (processed == totalLengthOut)
      {
        OSStatus v17 = 0;
        *a3 = (CMBlockBufferRef)CFRetain(theBuffer);
      }
      else
      {
        OSStatus v17 = CMBlockBufferCreateWithBufferReference(a4, theBuffer, 0, processed, 0, a3);
      }
    }
    if (theBuffer)
    {
      CFRelease(theBuffer);
      CMBlockBufferRef theBuffer = 0;
    }
    if (v17 < 0 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v20 = VRTraceErrorLogLevelToCSTR();
      __int16 v21 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        uint64_t v29 = v20;
        __int16 v30 = 2080;
        int v31 = "DTLS_Read";
        __int16 v32 = 1024;
        int v33 = 606;
        __int16 v34 = 1024;
        int v35 = v17;
        _os_log_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d DTLS_Read failed with %d", buf, 0x22u);
      }
    }
    if (v17) {
      return 2149777412;
    }
    else {
      return 0;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v18 = VRTraceErrorLogLevelToCSTR();
      int v19 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        uint64_t v29 = v18;
        __int16 v30 = 2080;
        int v31 = "DTLS_Read";
        __int16 v32 = 1024;
        int v33 = 565;
        __int16 v34 = 1024;
        int v35 = -9803;
        _os_log_impl(&dword_1E1EA4000, v19, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d DTLS_Read failed with %d", buf, 0x22u);
      }
    }
    CheckOutHandleDebug();
  }
  return v9;
}

uint64_t DTLS_Write(uint64_t a1, const void *a2, size_t a3, size_t *a4, int a5)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 2149777412;
  uint64_t v10 = CheckInHandleDebug();
  if (!v10) {
    return 2149777410;
  }
  uint64_t v11 = v10;
  if (*(_DWORD *)(v10 + 352) == 2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v10 + 360));
    *(_DWORD *)(v11 + 12) = a5;
    OSStatus v12 = SSLWrite(*(SSLContextRef *)(v11 + 344), a2, a3, a4);
    *(_DWORD *)(v11 + 12) = 0;
    pthread_mutex_unlock((pthread_mutex_t *)(v11 + 360));
    CheckOutHandleDebug();
    if (!v12) {
      return 0;
    }
  }
  else
  {
    CheckOutHandleDebug();
    OSStatus v12 = -9803;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    uint64_t v13 = VRTraceErrorLogLevelToCSTR();
    uint64_t v14 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v16 = 136315906;
      uint64_t v17 = v13;
      __int16 v18 = 2080;
      int v19 = "DTLS_Write";
      __int16 v20 = 1024;
      int v21 = 635;
      __int16 v22 = 1024;
      OSStatus v23 = v12;
      _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d DTLS_Write failed with %d", (uint8_t *)&v16, 0x22u);
    }
  }
  return v9;
}

void HandleWRMEvent(void *a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    uint64_t v5 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int v16 = 136315906;
      *(void *)&v16[4] = v4;
      __int16 v17 = 2080;
      __int16 v18 = "HandleWRMEvent";
      __int16 v19 = 1024;
      int v20 = 56;
      __int16 v21 = 2048;
      __int16 v22 = a2;
      _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d WRMClient(%p): Handling a WRMEvent.", v16, 0x26u);
    }
  }
  int64_t uint64 = xpc_dictionary_get_uint64(a1, "kMessageId");
  if (uint64 > 1305)
  {
    if (uint64 == 1306)
    {
      uint64_t v13 = a2;
      uint64_t v14 = 1;
    }
    else
    {
      if (uint64 != 1307)
      {
LABEL_15:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            HandleWRMEvent_cold_1();
          }
        }
        return;
      }
      uint64_t v13 = a2;
      uint64_t v14 = 0;
    }
    [v13 setPreWarmState:v14];
    xpc_object_t value = xpc_dictionary_get_value(a1, "kMessageArgs");
    uint64_t v10 = a2;
    uint64_t v12 = 1;
LABEL_22:
    [v10 processWRMCoexMetrics:value isAlertedMode:v12];
    return;
  }
  if (uint64 != 1102)
  {
    if (uint64 == 1303)
    {
      xpc_object_t v7 = xpc_dictionary_get_value(a1, "kMessageArgs");
      xpc_object_t v8 = v7;
      if (v7)
      {
        xpc_object_t v9 = xpc_dictionary_get_value(v7, "kWRMApplicationTypeList");
        if (v9) {
          [a2 processNotificationList:v9];
        }
      }
      uint64_t v10 = a2;
      xpc_object_t value = v8;
      uint64_t v12 = 0;
      goto LABEL_22;
    }
    goto LABEL_15;
  }
  xpc_object_t v15 = xpc_dictionary_get_value(a1, "kMessageArgs");
  if (xpc_dictionary_get_value(v15, "kWRMAVConferenceMetricsConfig_PeriodicReportInterval"))
  {
    *(void *)int v16 = xpc_dictionary_get_uint64(v15, "kWRMAVConferenceMetricsConfig_PeriodicReportInterval");
    [a2 setConfiguration:v16];
  }
}

uint64_t VCMaxUDPPayloadSize(int a1, int a2)
{
  if (a2) {
    int v2 = -40;
  }
  else {
    int v2 = -20;
  }
  int v3 = a1 + v2 - 8;
  if (v3 < 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v3;
  }
}

uint64_t VCGetVTPTrafficClassForVCTrafficClass(int a1)
{
  if ((a1 - 1) > 3) {
    return 0xFFFFFFFFLL;
  }
  else {
    return dword_1E25A1190[a1 - 1];
  }
}

uint64_t VCGetVCTrafficClassForVTPTrafficClass(int a1)
{
  if (a1 > 699)
  {
    if (a1 != 700)
    {
      if (a1 == 800) {
        return 4;
      }
      return 0;
    }
    return 3;
  }
  else
  {
    if (a1) {
      return a1 == 200;
    }
    return 2;
  }
}

uint64_t VCCloseSocketIfValid(uint64_t result)
{
  if (result != -1) {
    return close(result);
  }
  return result;
}

uint64_t VCCloseVFDIfValid(uint64_t a1)
{
  if (a1 != -1) {
    return VTP_Close(a1);
  }
  return a1;
}

uint64_t VCGetVCPacketWithVTPPacket(uint64_t a1, uint64_t a2)
{
  VCPacketInitialize(a2);
  CFTypeRef v4 = *(CFTypeRef *)(a1 + 512);
  if (v4) {
    CFTypeRef v4 = CFRetain(v4);
  }
  *(void *)a2 = v4;
  *(unsigned char *)(a2 + 9) = *(unsigned char *)(a1 + 492);
  if (*(unsigned char *)(a1 + 352))
  {
    *(unsigned char *)(a2 + 35) = *(unsigned char *)(a1 + 388);
    uint64_t v5 = *(unsigned __int8 *)(a1 + 384);
    *(unsigned char *)(a2 + 34) = v5;
    memcpy((void *)(a2 + 10), (const void *)(a1 + 360), 2 * v5);
    *(unsigned char *)(a2 + 36) = *(unsigned char *)(a1 + 390);
    *(void *)(a2 + 40) = *(void *)(a1 + 392);
    *(unsigned char *)(a2 + 48) = *(unsigned char *)(a1 + 417);
    *(unsigned char *)(a2 + 137) = *(unsigned char *)(a1 + 436);
  }
  else
  {
    *(_WORD *)(a2 + 34) = 0;
  }
  *(void *)(a2 + 128) = *(void *)a1;
  *(unsigned char *)(a2 + 136) = *(unsigned char *)(a1 + 328);
  *(unsigned char *)(a2 + 138) = *(unsigned char *)(a1 + 495);
  *(void *)(a2 + 88) = *(void *)(a1 + 200);
  uint64_t result = VCIDSChannelData_GetIDSAttributeSizeWithChannelDataFormat(a1 + 360);
  *(void *)(a2 + 104) = result;
  *(unsigned char *)(a2 + 96) = *(unsigned char *)(a1 + 197);
  return result;
}

uint64_t VCCreateVFDForIDS(int a1, int a2, int *a3)
{
  if (a3)
  {
    int v6 = VTP_SocketForIDS();
    if (v6 != -1)
    {
      int v7 = v6;
      if (VTP_SetSocketMode(v6, 2) == -1)
      {
        uint64_t v8 = *__error() | (a2 << 16) | 0xC0000000;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCCreateVFDForIDS_cold_3();
          }
        }
      }
      else
      {
        if (VTP_SetPktType(v7, a1) != -1)
        {
          uint64_t v8 = 0;
          *a3 = v7;
          return v8;
        }
        uint64_t v8 = *__error() | (a2 << 16) | 0xC0000000;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCCreateVFDForIDS_cold_4();
          }
        }
      }
      VTP_Close(v7);
      return v8;
    }
    uint64_t v8 = *__error() | (a2 << 16) | 0xC0000000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCCreateVFDForIDS_cold_2();
      }
    }
  }
  else
  {
    uint64_t v8 = (a2 << 16) | 0xC0000001;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v10 = VRTraceErrorLogLevelToCSTR();
      uint64_t v11 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCCreateVFDForIDS_cold_1(v10, v11);
      }
    }
  }
  return v8;
}

BOOL VCBasebandNotificationParser_ParseNotification(unint64_t a1, unsigned int a2, uint64_t a3, double a4)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  if ((int)a2 < 8)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCBasebandNotificationParser_ParseNotification_cold_1();
    }
    return 0;
  }
  uint64_t v6 = a3;
  *(_DWORD *)a3 = 0;
  uint64_t v7 = a2 & 0xFFFFFFFE;
  if (v7 == 6) {
    goto LABEL_91;
  }
  *(_WORD *)(a3 + 4) = bswap32(*(unsigned __int16 *)(a1 + 6)) >> 16;
  if (v7 == 4) {
    goto LABEL_91;
  }
  unsigned int v9 = bswap32(*(unsigned __int16 *)(a1 + 4)) >> 16;
  if (v9 == 51966)
  {
    if (a2 <= 0xB)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        VCBasebandNotificationParser_ParseNotification_cold_4();
      }
      return 0;
    }
    uint64_t v47 = a2 & 0x7FFFFFFC;
    if (v47 == 8) {
      goto LABEL_91;
    }
    if (*(_DWORD *)(a1 + 8) == 1862270976)
    {
      *(_DWORD *)a3 = 3;
      if (a2 <= 0xF)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
          if (!result) {
            return result;
          }
          VCBasebandNotificationParser_ParseNotification_cold_5();
        }
        return 0;
      }
      if ((a2 & 0xFFFFFFFC | 2) != 0xE)
      {
        unsigned int v48 = *(unsigned __int16 *)(a1 + 14);
        *(_WORD *)(a3 + 16) = bswap32(*(unsigned __int16 *)(a1 + 12)) >> 16;
        *(_WORD *)(a3 + 18) = bswap32(v48) >> 16;
        return 1;
      }
    }
    else
    {
      *(_DWORD *)a3 = 1;
      *(double *)(a3 + 8) = a4;
      if (a2 <= 0x23)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
          if (!result) {
            return result;
          }
          VCBasebandNotificationParser_ParseNotification_cold_6();
        }
        return 0;
      }
      *(_WORD *)(a3 + 16) = *(unsigned __int8 *)(a1 + 12);
      *(unsigned char *)(a3 + 18) = *(unsigned char *)(a1 + 13);
      if (v7 != 14)
      {
        *(_WORD *)(a3 + 20) = bswap32(*(unsigned __int16 *)(a1 + 14)) >> 16;
        *(unsigned char *)(a3 + 22) = *(unsigned char *)(a1 + 16);
        *(unsigned char *)(a3 + 23) = *(unsigned char *)(a1 + 17);
        if (v47 != 20)
        {
          *(_DWORD *)(a3 + 24) = bswap32(*(_DWORD *)(a1 + 20));
          if (v47 != 24)
          {
            *(_DWORD *)(a3 + 28) = bswap32(*(_DWORD *)(a1 + 24));
            if (v47 != 28)
            {
              *(_DWORD *)(a3 + 32) = bswap32(*(_DWORD *)(a1 + 28));
              if (v47 != 32)
              {
                *(_DWORD *)(a3 + 36) = bswap32(*(_DWORD *)(a1 + 32));
                return 1;
              }
            }
          }
        }
      }
    }
LABEL_91:
    __break(0x5519u);
  }
  if (v9 != 57005) {
    return 1;
  }
  *(_DWORD *)a3 = 2;
  *(double *)(a3 + 8) = a4;
  if (a2 <= 0xF)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCBasebandNotificationParser_ParseNotification_cold_2();
    }
    return 0;
  }
  if (v7 == 12) {
    goto LABEL_91;
  }
  *(_WORD *)(a3 + 16) = bswap32(*(unsigned __int16 *)(a1 + 12)) >> 16;
  if (v7 == 14) {
    goto LABEL_91;
  }
  unsigned int v10 = *(unsigned __int16 *)(a1 + 14);
  *(_WORD *)(a3 + 18) = __rev16(v10);
  if (v10 == 0xFFFF) {
    return 1;
  }
  uint64_t v11 = 0;
  unint64_t v12 = a1 + a2;
  uint64_t v13 = a3 + 22;
  uint64_t v14 = (_WORD *)(a3 + 26);
  int v15 = 16;
  uint64_t v54 = a3 + 22;
  do
  {
    int v16 = v15 + 3;
    int v17 = a2 - (v15 + 3);
    if ((int)a2 < v15 + 3) {
      goto LABEL_88;
    }
    unint64_t v18 = a1 + v15;
    if (v18 >= v12) {
      goto LABEL_91;
    }
    if (v18 < a1) {
      goto LABEL_91;
    }
    __int16 v19 = (unsigned char *)(v13 + 1004 * v11);
    int v20 = (unsigned char *)(a1 + v15);
    char v22 = *v20;
    __int16 v21 = (unsigned __int16 *)(v20 + 1);
    unsigned char *v19 = v22;
    if (v12 < (unint64_t)v21 || (unint64_t)v21 < a1 || v12 - (unint64_t)v21 < 2) {
      goto LABEL_91;
    }
    unsigned int v23 = bswap32(*v21);
    unsigned int v24 = HIWORD(v23);
    uint64_t v25 = v13 + 1004 * v11;
    *(_WORD *)(v25 + 2) = HIWORD(v23);
    OSStatus v26 = (_WORD *)(v25 + 2);
    int v27 = v17 >> 1;
    if (v17 >> 1 < (int)HIWORD(v23))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v53 = VRTraceErrorLogLevelToCSTR();
        __int16 v28 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          int v45 = (unsigned __int16)*v26;
          *(_DWORD *)buf = 136316418;
          uint64_t v57 = v53;
          __int16 v58 = 2080;
          long long v59 = "VCBasebandNotificationParser_ParseNotification";
          __int16 v60 = 1024;
          int v61 = 76;
          __int16 v62 = 1024;
          int v63 = 76;
          __int16 v64 = 1024;
          int v65 = v27;
          __int16 v66 = 1024;
          int v67 = v45;
          _os_log_error_impl(&dword_1E1EA4000, v28, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCBasebandNotificationParser.c:%d: Bad ACK, #dropped SN doesn't match(%d != %u).", buf, 0x2Eu);
        }
      }
      *OSStatus v26 = v27;
      LOWORD(v24) = v27;
    }
    if ((unsigned __int16)v24 >= 0x1F5u)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v29 = VRTraceErrorLogLevelToCSTR();
        __int16 v30 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          int v46 = (unsigned __int16)*v26;
          *(_DWORD *)buf = 136316418;
          uint64_t v57 = v29;
          __int16 v58 = 2080;
          long long v59 = "VCBasebandNotificationParser_ParseNotification";
          __int16 v60 = 1024;
          int v61 = 81;
          __int16 v62 = 1024;
          int v63 = 81;
          __int16 v64 = 1024;
          int v65 = v46;
          __int16 v66 = 1024;
          int v67 = 500;
          _os_log_error_impl(&dword_1E1EA4000, v30, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCBasebandNotificationParser.c:%d: Bad ACK, #dropped SN exceeds limit(%d > %d).", buf, 0x2Eu);
        }
      }
      *OSStatus v26 = 500;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v31 = VRTraceErrorLogLevelToCSTR();
      __int16 v32 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v33 = (unsigned __int16)*v26;
        int v34 = *v19;
        *(_DWORD *)buf = 136316162;
        uint64_t v57 = v31;
        __int16 v58 = 2080;
        long long v59 = "VCBasebandNotificationParser_ParseNotification";
        __int16 v60 = 1024;
        int v61 = 85;
        __int16 v62 = 1024;
        int v63 = v33;
        __int16 v64 = 1024;
        int v65 = v34;
        _os_log_impl(&dword_1E1EA4000, v32, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Baseband dropped %u packet(s) for PT %u.", buf, 0x28u);
      }
    }
    if (v16 + 2 * (unsigned __int16)*v26 > (int)a2)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v49 = VRTraceErrorLogLevelToCSTR();
        long long v50 = *MEMORY[0x1E4F47A50];
        BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        int v51 = (unsigned __int16)*v26;
        *(_DWORD *)buf = 136316162;
        uint64_t v57 = v49;
        __int16 v58 = 2080;
        long long v59 = "VCBasebandNotificationParser_ParseNotification";
        __int16 v60 = 1024;
        int v61 = 88;
        __int16 v62 = 1024;
        int v63 = a2;
        __int16 v64 = 1024;
        int v65 = v16 + 2 * v51;
        _os_log_error_impl(&dword_1E1EA4000, v50, OS_LOG_TYPE_ERROR, " [%s] %s:%d Corrupted baseband notification ACK packet. Length[%d] < needed[%d]", buf, 0x28u);
      }
      return 0;
    }
    if (*v26)
    {
      uint64_t v35 = 0;
      uint64_t v13 = v54;
      uint64_t v6 = a3;
      uint64_t v36 = v54 + 1004 * v11;
      unint64_t v37 = v36 + 4;
      unint64_t v38 = v36 + 1004;
      long long v39 = v14;
      while (1)
      {
        long long v40 = (unsigned __int16 *)(a1 + v16);
        BOOL v41 = v12 >= (unint64_t)v40 && (unint64_t)v40 >= a1;
        BOOL v42 = v41 && v12 - (unint64_t)v40 >= 2;
        BOOL v43 = !v42 || (unint64_t)v39 >= v38;
        if (v43 || (unint64_t)v39 < v37) {
          goto LABEL_91;
        }
        *v39++ = bswap32(*v40) >> 16;
        v16 += 2;
        if (++v35 >= (unint64_t)(unsigned __int16)*v26) {
          goto LABEL_60;
        }
      }
    }
    uint64_t v13 = v54;
    uint64_t v6 = a3;
LABEL_60:
    ++v11;
    v14 += 502;
    int v15 = v16;
  }
  while (v11 != 6);
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCBasebandNotificationParser_ParseNotification_cold_3();
    }
  }
  LOWORD(v11) = 6;
LABEL_88:
  *(_WORD *)(v6 + 20) = v11;
  return 1;
}

void *videoRulesForFormatList_0(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  CFTypeRef v4 = objc_opt_new();
  if (v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = (os_log_t *)MEMORY[0x1E4F47A50];
    do
    {
      uint64_t v7 = [VCVideoRule alloc];
      *(float *)&double v8 = (float)*(unsigned int *)(a1 + v5 + 8);
      uint64_t v9 = [(VCVideoRule *)v7 initWithFrameWidth:*(unsigned int *)(a1 + v5) frameHeight:*(unsigned int *)(a1 + v5 + 4) frameRate:a2 payload:v8];
      if (v9)
      {
        unsigned int v10 = (void *)v9;
        [v4 addObject:v9];
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v11 = VRTraceErrorLogLevelToCSTR();
        unint64_t v12 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          uint64_t v15 = v11;
          __int16 v16 = 2080;
          int v17 = "videoRulesForFormatList";
          __int16 v18 = 1024;
          int v19 = 37;
          _os_log_error_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to create video rule for secondary screen !", buf, 0x1Cu);
        }
      }
      v5 += 12;
    }
    while (v5 != 60);
  }
  return v4;
}

void VCTimescaleWSOLAShiftBuffer::VCTimescaleWSOLAShiftBuffer(VCTimescaleWSOLAShiftBuffer *this, unsigned int a2)
{
  *(void *)this = malloc_type_malloc(4 * a2, 0x100004052888210uLL);
  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 100 * a2;
}

void VCTimescaleWSOLAShiftBuffer::~VCTimescaleWSOLAShiftBuffer(void **this)
{
}

uint64_t VCTimescaleWSOLAShiftBuffer::clear(uint64_t this)
{
  *(_DWORD *)(this + 12) = 0;
  return this;
}

uint64_t VCTimescaleWSOLAShiftBuffer::count(VCTimescaleWSOLAShiftBuffer *this)
{
  return *((unsigned int *)this + 3);
}

_DWORD *VCTimescaleWSOLAShiftBuffer::appendSamples(_DWORD *this, float *__src, unsigned int a3)
{
  uint64_t v5 = (uint64_t)this;
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  unsigned int v6 = this[2];
  if (v6 - this[3] < a3)
  {
    unsigned int v7 = 8 * v6;
    if (8 * v6 < this[4])
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v8 = VRTraceErrorLogLevelToCSTR();
        uint64_t v9 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v11 = 136315650;
          uint64_t v12 = v8;
          __int16 v13 = 2080;
          uint64_t v14 = "appendSamples";
          __int16 v15 = 1024;
          int v16 = 52;
          _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCTimescaleWSOLAClass is increasing size of extendedBuffer by 8x.\n", (uint8_t *)&v11, 0x1Cu);
        }
      }
      this = malloc_type_realloc(*(void **)v5, 4 * v7, 0x100004052888210uLL);
      if (this)
      {
        *(void *)uint64_t v5 = this;
        *(_DWORD *)(v5 + 8) = v7;
        unsigned int v6 = v7;
      }
      else
      {
        unsigned int v6 = *(_DWORD *)(v5 + 8);
      }
    }
  }
  uint64_t v10 = *(unsigned int *)(v5 + 12);
  if (v6 - v10 >= a3)
  {
    this = memcpy((void *)(*(void *)v5 + 4 * v10), __src, 4 * a3);
    *(_DWORD *)(v5 + 12) += a3;
  }
  return this;
}

void **VCTimescaleWSOLAShiftBuffer::removeSamples(void **this, unsigned int a2)
{
  if (a2)
  {
    int v3 = this;
    this = (void **)memmove(*this, (char *)*this + 4 * a2, 4 * (*((_DWORD *)this + 3) - a2));
    *((_DWORD *)v3 + 3) -= a2;
  }
  return this;
}

uint64_t VCVideoDecoder_NewVideoDecoder(void *a1, int *a2)
{
  id v3 = +[VCVideoDecoder decoderForStreamToken:*a2 withConfig:a2];
  if (a1) {
    *a1 = [v3 videoPlayerHandle];
  }
  return 0;
}

uint64_t VCVideoDecoder_ReleaseVideoDecoder(int a1)
{
  return 0;
}

uint64_t VCPacketFilterBasebandNotificationCreate(uint64_t a1, void *a2)
{
  uint64_t ClassID = VCPacketFilterGetClassID();

  return VCFBOUtils_ObjectCreate(a1, a2, (uint64_t)&kVCPacketFilterBBNotificationVTable, ClassID, 52);
}

BOOL VCPacketFilterIsOfKindBasebandNotification(uint64_t a1)
{
  return VCFBOUtils_IsKindOfClass(a1, (uint64_t)&kVCPacketFilterBBNotificationVTable);
}

void _VCPacketFilterBBNotificationFinalize(uint64_t a1)
{
  if (a1)
  {
    uint64_t DerivedStorage = (const void **)CMBaseObjectGetDerivedStorage();
    if (DerivedStorage)
    {
      int v2 = *DerivedStorage;
      if (v2)
      {
        CFRelease(v2);
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCPacketFilterBBNotificationFinalize_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCPacketFilterBBNotificationFinalize_cold_1();
    }
  }
}

uint64_t _VCPacketFilterBBNotificationCopyProperty(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCPacketFilterBBNotificationCopyProperty_cold_1();
      }
    }
    return 4294954516;
  }
  if (!a2 || !a4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v11 = VRTraceErrorLogLevelToCSTR();
      uint64_t v12 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        int v13 = 136316162;
        uint64_t v14 = v11;
        __int16 v15 = 2080;
        int v16 = "_VCPacketFilterBBNotificationCopyProperty";
        __int16 v17 = 1024;
        int v18 = 59;
        __int16 v19 = 2112;
        uint64_t v20 = a2;
        __int16 v21 = 2112;
        char v22 = a4;
        _os_log_error_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d Property name '%@' and property value out '%@' must not be NULL", (uint8_t *)&v13, 0x30u);
      }
    }
    return 4294954516;
  }
  uint64_t DerivedStorage = (CFTypeRef *)CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, @"CellularUniqueTag"))
  {
    if (*DerivedStorage)
    {
      CFTypeRef v7 = CFRetain(*DerivedStorage);
      uint64_t result = 0;
      *a4 = v7;
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        uint64_t v9 = VRTraceErrorLogLevelToCSTR();
        uint64_t v10 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v13 = 136315906;
          uint64_t v14 = v9;
          __int16 v15 = 2080;
          int v16 = "_VCPacketFilterBBNotificationCopyProperty";
          __int16 v17 = 1024;
          int v18 = 68;
          __int16 v19 = 2112;
          uint64_t v20 = a2;
          _os_log_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Parameter '%@' is currently not set for packet filter", (uint8_t *)&v13, 0x26u);
        }
      }
      return 4294954513;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCPacketFilterBBNotificationCopyProperty_cold_2();
      }
    }
    return 4294954512;
  }
  return result;
}

uint64_t _VCPacketFilterBBNotificationSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCPacketFilterBBNotificationSetProperty_cold_1();
      }
    }
    return 4294954516;
  }
  if (!a2 || !a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v8 = VRTraceErrorLogLevelToCSTR();
      uint64_t v9 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        int v10 = 136316162;
        uint64_t v11 = v8;
        __int16 v12 = 2080;
        int v13 = "_VCPacketFilterBBNotificationSetProperty";
        __int16 v14 = 1024;
        int v15 = 83;
        __int16 v16 = 2112;
        __int16 v17 = a2;
        __int16 v18 = 2112;
        __int16 v19 = a3;
        _os_log_error_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_ERROR, " [%s] %s:%d Property name '%@' and property value out '%@' must not be NULL", (uint8_t *)&v10, 0x30u);
      }
    }
    return 4294954516;
  }
  uint64_t DerivedStorage = (const void **)CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, @"CellularUniqueTag"))
  {
    unsigned int v6 = *DerivedStorage;
    CFTypeRef *DerivedStorage = a3;
    CFRetain(a3);
    if (v6) {
      CFRelease(v6);
    }
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCPacketFilterBBNotificationSetProperty_cold_2();
      }
    }
    return 4294954512;
  }
}

CVPixelBufferRef VCImageResizingConverter_CreateResizedPixelBuffer(uint64_t a1, __CVBuffer *a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    uint64_t v5 = *MEMORY[0x1E4F47A50];
    unsigned int v6 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        PixelFormatint Type = CVPixelBufferGetPixelFormatType(a2);
        *(_DWORD *)buf = 136316930;
        uint64_t v28 = v4;
        __int16 v29 = 2080;
        __int16 v30 = "VCImageResizingConverter_CreateResizedPixelBuffer";
        __int16 v31 = 1024;
        int v32 = 49;
        __int16 v33 = 2048;
        uint64_t v34 = a1;
        __int16 v35 = 2048;
        uint64_t v36 = a2;
        __int16 v37 = 2080;
        unint64_t v38 = FourccToCStr(PixelFormatType);
        __int16 v39 = 2048;
        size_t Width = CVPixelBufferGetWidth(a2);
        __int16 v41 = 2048;
        size_t Height = CVPixelBufferGetHeight(a2);
        _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d pointer=%p, pixelBuffer=%p, formatType=%s, width=%lu, height=%lu", buf, 0x4Eu);
      }
    }
    else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      OSType v20 = CVPixelBufferGetPixelFormatType(a2);
      *(_DWORD *)buf = 136316930;
      uint64_t v28 = v4;
      __int16 v29 = 2080;
      __int16 v30 = "VCImageResizingConverter_CreateResizedPixelBuffer";
      __int16 v31 = 1024;
      int v32 = 49;
      __int16 v33 = 2048;
      uint64_t v34 = a1;
      __int16 v35 = 2048;
      uint64_t v36 = a2;
      __int16 v37 = 2080;
      unint64_t v38 = FourccToCStr(v20);
      __int16 v39 = 2048;
      size_t Width = CVPixelBufferGetWidth(a2);
      __int16 v41 = 2048;
      size_t Height = CVPixelBufferGetHeight(a2);
      _os_log_debug_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEBUG, " [%s] %s:%d pointer=%p, pixelBuffer=%p, formatType=%s, width=%lu, height=%lu", buf, 0x4Eu);
    }
  }
  CVPixelBufferRef pixelBufferOut = 0;
  if (*(void *)(a1 + 48))
  {
    uint64_t v8 = *(__CVPixelBufferPool **)(a1 + 8);
    if (v8)
    {
      if (CVPixelBufferPoolCreatePixelBuffer((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v8, &pixelBufferOut))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCImageResizingConverter_CreateResizedPixelBuffer_cold_4();
          }
        }
      }
      else
      {
        OSStatus v9 = VTPixelTransferSessionTransferImage(*(VTPixelTransferSessionRef *)(a1 + 48), a2, pixelBufferOut);
        int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (v9)
        {
          if (ErrorLogLevelForModule >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              VCImageResizingConverter_CreateResizedPixelBuffer_cold_3();
            }
          }
        }
        else if (ErrorLogLevelForModule >= 8)
        {
          uint64_t v11 = VRTraceErrorLogLevelToCSTR();
          __int16 v12 = *MEMORY[0x1E4F47A50];
          int v13 = *MEMORY[0x1E4F47A50];
          if (*MEMORY[0x1E4F47A40])
          {
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              CVPixelBufferRef v14 = pixelBufferOut;
              OSType v15 = CVPixelBufferGetPixelFormatType(pixelBufferOut);
              __int16 v16 = FourccToCStr(v15);
              size_t v17 = CVPixelBufferGetWidth(pixelBufferOut);
              size_t v18 = CVPixelBufferGetHeight(pixelBufferOut);
              *(_DWORD *)buf = 136316930;
              uint64_t v28 = v11;
              __int16 v29 = 2080;
              __int16 v30 = "VCImageResizingConverter_CreateResizedPixelBuffer";
              __int16 v31 = 1024;
              int v32 = 60;
              __int16 v33 = 2048;
              uint64_t v34 = a1;
              __int16 v35 = 2048;
              uint64_t v36 = v14;
              __int16 v37 = 2080;
              unint64_t v38 = v16;
              __int16 v39 = 2048;
              size_t Width = v17;
              __int16 v41 = 2048;
              size_t Height = v18;
              _os_log_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d pointer=%p, newPixelBuffer=%p, formatType=%s, width=%lu, height=%lu", buf, 0x4Eu);
            }
          }
          else if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
          {
            CVPixelBufferRef v21 = pixelBufferOut;
            OSType v22 = CVPixelBufferGetPixelFormatType(pixelBufferOut);
            uint64_t v23 = FourccToCStr(v22);
            size_t v24 = CVPixelBufferGetWidth(pixelBufferOut);
            size_t v25 = CVPixelBufferGetHeight(pixelBufferOut);
            *(_DWORD *)buf = 136316930;
            uint64_t v28 = v11;
            __int16 v29 = 2080;
            __int16 v30 = "VCImageResizingConverter_CreateResizedPixelBuffer";
            __int16 v31 = 1024;
            int v32 = 60;
            __int16 v33 = 2048;
            uint64_t v34 = a1;
            __int16 v35 = 2048;
            uint64_t v36 = v21;
            __int16 v37 = 2080;
            unint64_t v38 = v23;
            __int16 v39 = 2048;
            size_t Width = v24;
            __int16 v41 = 2048;
            size_t Height = v25;
            _os_log_debug_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_DEBUG, " [%s] %s:%d pointer=%p, newPixelBuffer=%p, formatType=%s, width=%lu, height=%lu", buf, 0x4Eu);
          }
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCImageResizingConverter_CreateResizedPixelBuffer_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCImageResizingConverter_CreateResizedPixelBuffer_cold_1();
    }
  }
  return pixelBufferOut;
}

CMSampleBufferRef _VCImageResizingConverter_CreateSampleBufferWithNewTiming(CMSampleBufferRef originalSBuf, uint64_t a2)
{
  sampleBufferOut[1] = *(CMSampleBufferRef *)MEMORY[0x1E4F143B8];
  sampleBufferOut[0] = 0;
  if (originalSBuf)
  {
    long long v2 = *(_OWORD *)(MEMORY[0x1E4F1FA70] + 48);
    *(_OWORD *)&v7.presentationTimeStamp.timescale = *(_OWORD *)(MEMORY[0x1E4F1FA70] + 32);
    *(_OWORD *)&v7.decodeTimeStamp.xpc_object_t value = v2;
    CMTimeEpoch v3 = *(void *)(MEMORY[0x1E4F1FA70] + 64);
    long long v4 = *(_OWORD *)(MEMORY[0x1E4F1FA70] + 16);
    *(_OWORD *)&v7.duration.xpc_object_t value = *MEMORY[0x1E4F1FA70];
    *(_OWORD *)&v7.duration.CMTimeEpoch epoch = v4;
    *(_OWORD *)&v7.presentationTimeStamp.xpc_object_t value = *(_OWORD *)a2;
    CMTimeEpoch v5 = *(void *)(a2 + 16);
    v7.decodeTimeStamp.CMTimeEpoch epoch = v3;
    v7.presentationTimeStamp.CMTimeEpoch epoch = v5;
    if (CMSampleBufferCreateCopyWithNewTiming((CFAllocatorRef)*MEMORY[0x1E4F1CF80], originalSBuf, 1, &v7, sampleBufferOut))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCImageResizingConverter_CreateSampleBufferWithNewTiming_cold_2();
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCImageResizingConverter_CreateSampleBufferWithNewTiming_cold_1();
    }
  }
  return sampleBufferOut[0];
}

void *VCMicrophonePreferencesAVAS_BuiltInMicPortDescriptionFromSelectableInputsArray(void *a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMicrophonePreferencesAVAS_BuiltInMicPortDescriptionFromSelectableInputsArray_cold_1();
      }
    }
    return 0;
  }
  uint64_t v2 = *MEMORY[0x1E4F150F0];
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  uint64_t v3 = [a1 countByEnumeratingWithState:&v22 objects:v21 count:16];
  if (!v3)
  {
LABEL_10:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v8 = VRTraceErrorLogLevelToCSTR();
      OSStatus v9 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        int v11 = 136316162;
        uint64_t v12 = v8;
        __int16 v13 = 2080;
        CVPixelBufferRef v14 = "VCMicrophonePreferencesAVAS_BuiltInMicPortDescriptionFromSelectableInputsArray";
        __int16 v15 = 1024;
        int v16 = 32;
        __int16 v17 = 2112;
        uint64_t v18 = v2;
        __int16 v19 = 2112;
        OSType v20 = a1;
        _os_log_error_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_ERROR, " [%s] %s:%d desiredPortType=%@ was not found in selectableInputs=%@", (uint8_t *)&v11, 0x30u);
      }
    }
    return 0;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)v23;
LABEL_4:
  uint64_t v6 = 0;
  while (1)
  {
    if (*(void *)v23 != v5) {
      objc_enumerationMutation(a1);
    }
    CMSampleTimingInfo v7 = *(void **)(*((void *)&v22 + 1) + 8 * v6);
    if (objc_msgSend((id)objc_msgSend(v7, "portType"), "isEqualToString:", v2)) {
      return v7;
    }
    if (v4 == ++v6)
    {
      uint64_t v4 = [a1 countByEnumeratingWithState:&v22 objects:v21 count:16];
      if (v4) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
}

uint64_t VCMicrophonePreferencesAVAS_DataSourcesFromPortDescription(void *a1, void *a2, void *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = a2;
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2 && a3)
    {
      uint64_t v5 = (void *)[a1 dataSources];
      long long v27 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      uint64_t v6 = [v5 countByEnumeratingWithState:&v27 objects:v26 count:16];
      if (v6)
      {
        uint64_t v7 = v6;
        long long v24 = v4;
        long long v25 = v3;
        uint64_t v8 = 0;
        OSStatus v9 = 0;
        uint64_t v10 = *(void *)v28;
        uint64_t v11 = *MEMORY[0x1E4F15098];
        uint64_t v12 = *MEMORY[0x1E4F15090];
LABEL_6:
        uint64_t v13 = 0;
        while (1)
        {
          if (*(void *)v28 != v10) {
            objc_enumerationMutation(v5);
          }
          CVPixelBufferRef v14 = *(void **)(*((void *)&v27 + 1) + 8 * v13);
          __int16 v15 = objc_msgSend(v14, "orientation", v24);
          if ([v15 isEqualToString:v11])
          {
            uint64_t v8 = v14;
          }
          else if ([v15 isEqualToString:v12])
          {
            OSStatus v9 = v14;
          }
          if (v8 && v9 != 0) {
            break;
          }
          if (v7 == ++v13)
          {
            uint64_t v7 = [v5 countByEnumeratingWithState:&v27 objects:v26 count:16];
            if (v7) {
              goto LABEL_6;
            }
            break;
          }
        }
        if (v8) {
          BOOL v17 = v9 == 0;
        }
        else {
          BOOL v17 = 1;
        }
        uint64_t v3 = v25;
        if (!v17)
        {
          *long long v24 = v8;
          id v18 = v9;
          uint64_t result = 1;
LABEL_33:
          *uint64_t v3 = v18;
          return result;
        }
        uint64_t v4 = v24;
      }
      else
      {
        OSStatus v9 = 0;
        uint64_t v8 = 0;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v20 = VRTraceErrorLogLevelToCSTR();
        CVPixelBufferRef v21 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          uint64_t v32 = v20;
          __int16 v33 = 2080;
          uint64_t v34 = "VCMicrophonePreferencesAVAS_DataSourcesFromPortDescription";
          __int16 v35 = 1024;
          int v36 = 60;
          __int16 v37 = 2048;
          unint64_t v38 = v8;
          __int16 v39 = 2048;
          long long v40 = v9;
          _os_log_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Did not find both orientations: front=%p, back=%p", buf, 0x30u);
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v22 = VRTraceErrorLogLevelToCSTR();
      long long v23 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        uint64_t v32 = v22;
        __int16 v33 = 2080;
        uint64_t v34 = "VCMicrophonePreferencesAVAS_DataSourcesFromPortDescription";
        __int16 v35 = 1024;
        int v36 = 40;
        __int16 v37 = 2048;
        unint64_t v38 = v4;
        __int16 v39 = 2048;
        long long v40 = v3;
        _os_log_error_impl(&dword_1E1EA4000, v23, OS_LOG_TYPE_ERROR, " [%s] %s:%d frontDataSource [%p] or backDataSource [%p] == nil", buf, 0x30u);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCMicrophonePreferencesAVAS_DataSourcesFromPortDescription_cold_1();
    }
  }
  if (v4) {
    *uint64_t v4 = 0;
  }
  uint64_t result = 0;
  if (v3)
  {
    id v18 = 0;
    goto LABEL_33;
  }
  return result;
}

id VCMicrophonePreferencesAVAS_InitSelectedInputDictWithPolarPattern(uint64_t a1, void *a2)
{
  v50[2] = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    uint64_t v4 = (void *)[a2 supportedPolarPatterns];
    uint64_t v5 = *MEMORY[0x1E4F150B0];
    v50[0] = *MEMORY[0x1E4F150A8];
    v50[1] = v5;
    uint64_t v6 = objc_msgSend(MEMORY[0x1E4F1CAD0], "setWithArray:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v50, 2));
    long long v46 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    uint64_t v7 = [v4 countByEnumeratingWithState:&v46 objects:v36 count:16];
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)v47;
LABEL_5:
      uint64_t v10 = 0;
      while (1)
      {
        if (*(void *)v47 != v9) {
          objc_enumerationMutation(v4);
        }
        uint64_t v11 = *(void **)(*((void *)&v46 + 1) + 8 * v10);
        if ([v6 containsObject:v11]) {
          break;
        }
        if (v8 == ++v10)
        {
          uint64_t v8 = [v4 countByEnumeratingWithState:&v46 objects:v36 count:16];
          if (v8) {
            goto LABEL_5;
          }
          goto LABEL_11;
        }
      }
      id v14 = v11;
      if (!v14) {
        goto LABEL_16;
      }
      __int16 v15 = v14;
      v22[0] = @"port";
      v22[1] = @"dataSource";
      v23[0] = a1;
      v23[1] = a2;
      v22[2] = @"polarPattern";
      v23[2] = v14;
      int v16 = (void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v23 forKeys:v22 count:3];
    }
    else
    {
LABEL_11:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v12 = VRTraceErrorLogLevelToCSTR();
        uint64_t v13 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316418;
          uint64_t v25 = v12;
          __int16 v26 = 2080;
          long long v27 = "_VCMicrophonePreferencesAVAS_CopyOptimalMicPolarPatternFromDataSource";
          __int16 v28 = 1024;
          int v29 = 94;
          __int16 v30 = 2112;
          __int16 v31 = v6;
          __int16 v32 = 2112;
          __int16 v33 = v4;
          __int16 v34 = 2112;
          __int16 v35 = a2;
          _os_log_error_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_ERROR, " [%s] %s:%d Did not find any desiredPolarPatterns=%@ in supportedPolarPatterns=%@ for dataSource=%@", buf, 0x3Au);
        }
      }
LABEL_16:
      v20[0] = @"port";
      v20[1] = @"dataSource";
      v21[0] = a1;
      v21[1] = a2;
      int v16 = (void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v21 forKeys:v20 count:2];
      __int16 v15 = 0;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v18 = VRTraceErrorLogLevelToCSTR();
      __int16 v19 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int v36 = 136316162;
        uint64_t v37 = v18;
        __int16 v38 = 2080;
        __int16 v39 = "VCMicrophonePreferencesAVAS_InitSelectedInputDictWithPolarPattern";
        __int16 v40 = 1024;
        int v41 = 101;
        __int16 v42 = 2048;
        uint64_t v43 = a1;
        __int16 v44 = 2048;
        int v45 = a2;
        _os_log_error_impl(&dword_1E1EA4000, v19, OS_LOG_TYPE_ERROR, " [%s] %s:%d inPort [%p] or inSource [%p] == nil", v36, 0x30u);
      }
    }
    __int16 v15 = 0;
    int v16 = 0;
  }

  return v16;
}

uint64_t VCMicrophonePreferencesAVAS_ApplyMicrophonePreferences(void *a1, void *a2)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMicrophonePreferencesAVAS_ApplyMicrophonePreferences_cold_1();
      }
    }
    return 0;
  }
  uint64_t v4 = (void *)[a2 objectForKeyedSubscript:@"port"];
  uint64_t v5 = (void *)[a2 objectForKeyedSubscript:@"dataSource"];
  uint64_t v6 = [a2 objectForKeyedSubscript:@"polarPattern"];
  long long v27 = 0;
  BOOL v7 = v6 != 0;
  if (v6)
  {
    uint64_t v8 = v6;
    int v9 = [v5 setPreferredPolarPattern:v6 error:&v27];
    uint64_t v10 = v27;
    int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (!v9 || v10)
    {
      if (ErrorLogLevelForModule < 3) {
        return 0;
      }
      uint64_t v20 = VRTraceErrorLogLevelToCSTR();
      CVPixelBufferRef v21 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      *(_DWORD *)buf = 136317186;
      uint64_t v29 = v20;
      __int16 v30 = 2080;
      __int16 v31 = "VCMicrophonePreferencesAVAS_ApplyMicrophonePreferences";
      __int16 v32 = 1024;
      int v33 = 134;
      __int16 v34 = 2112;
      uint64_t v35 = v8;
      __int16 v36 = 2048;
      uint64_t v37 = v5;
      __int16 v38 = 2112;
      __int16 v39 = v5;
      __int16 v40 = 2048;
      int v41 = a1;
      __int16 v42 = 2112;
      uint64_t v43 = a1;
      __int16 v44 = 2112;
      int v45 = v27;
      uint64_t v22 = " [%s] %s:%d Failed to set selectedPolarPattern=%@ on selectedDataSource=%p [%@] for inAVAudioSession=%p [%@] with error=%@";
      long long v23 = v21;
      uint32_t v24 = 88;
      goto LABEL_26;
    }
    if (ErrorLogLevelForModule >= 7)
    {
      uint64_t v12 = VRTraceErrorLogLevelToCSTR();
      uint64_t v13 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        uint64_t v29 = v12;
        __int16 v30 = 2080;
        __int16 v31 = "VCMicrophonePreferencesAVAS_ApplyMicrophonePreferences";
        __int16 v32 = 1024;
        int v33 = 135;
        __int16 v34 = 2112;
        uint64_t v35 = v8;
        _os_log_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d setPreferredPolarPattern=%@ completed successfully", buf, 0x26u);
      }
    }
  }
  if (!v5) {
    return v7;
  }
  int v14 = [v4 setPreferredDataSource:v5 error:&v27];
  __int16 v15 = v27;
  int v16 = VRTraceGetErrorLogLevelForModule();
  if (!v14 || v15)
  {
    if (v16 < 3) {
      return 0;
    }
    uint64_t v25 = VRTraceErrorLogLevelToCSTR();
    __int16 v26 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)buf = 136317442;
    uint64_t v29 = v25;
    __int16 v30 = 2080;
    __int16 v31 = "VCMicrophonePreferencesAVAS_ApplyMicrophonePreferences";
    __int16 v32 = 1024;
    int v33 = 139;
    __int16 v34 = 2048;
    uint64_t v35 = (uint64_t)v5;
    __int16 v36 = 2112;
    uint64_t v37 = v5;
    __int16 v38 = 2048;
    __int16 v39 = v4;
    __int16 v40 = 2112;
    int v41 = v4;
    __int16 v42 = 2048;
    uint64_t v43 = a1;
    __int16 v44 = 2112;
    int v45 = a1;
    __int16 v46 = 2112;
    long long v47 = v27;
    uint64_t v22 = " [%s] %s:%d Failed to set selectedDataSource=%p [%@] on selectedPort=%p [%@] for inAVAudioSession=%p [%@] with error=%@";
    long long v23 = v26;
    uint32_t v24 = 98;
LABEL_26:
    _os_log_error_impl(&dword_1E1EA4000, v23, OS_LOG_TYPE_ERROR, v22, buf, v24);
    return 0;
  }
  if (v16 >= 7)
  {
    uint64_t v17 = VRTraceErrorLogLevelToCSTR();
    uint64_t v18 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      uint64_t v29 = v17;
      __int16 v30 = 2080;
      __int16 v31 = "VCMicrophonePreferencesAVAS_ApplyMicrophonePreferences";
      __int16 v32 = 1024;
      int v33 = 140;
      __int16 v34 = 2112;
      uint64_t v35 = (uint64_t)v5;
      _os_log_impl(&dword_1E1EA4000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d setPreferredDataSource=%@ completed with successfully", buf, 0x26u);
    }
  }
  return 1;
}

uint64_t VCHardwareSettingsEmbedded_AACELDPacketLossConcealmentAlgorithm()
{
  uint64_t v0 = +[VCHardwareSettingsEmbedded sharedInstance];

  return [(VCHardwareSettingsEmbedded *)v0 audioPacketLossConcealmentAlgorithmAACELD];
}

void __VCLoadAppleCVA_block_invoke()
{
  sVCAppleCVAFrameworkLibrary = (uint64_t)dlopen("/System/Library/PrivateFrameworks/AppleCVA.framework/AppleCVA", 2);
  if (!sVCAppleCVAFrameworkLibrary && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v0 = VRTraceErrorLogLevelToCSTR();
    BOOL v1 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      __VCLoadAppleCVA_block_invoke_cold_1(v0, v1);
    }
  }
}

void __loadAppleCVAFaceTrackingSymbols_block_invoke()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (VCLoadAppleCVA_loadPredicate != -1) {
    dispatch_once(&VCLoadAppleCVA_loadPredicate, &__block_literal_global_65);
  }
  if (sVCAppleCVAFrameworkLibrary)
  {
    if (sVC_CVAFaceTracking_DetectedFacesArray) {
      goto LABEL_5;
    }
    uint64_t v2 = (uint64_t *)dlsym((void *)sVCAppleCVAFrameworkLibrary, "kCVAFaceTracking_DetectedFacesArray");
    if (!v2)
    {
      sVC_CVAFaceTracking_DetectedFacesArray = 0;
      return;
    }
    sVC_CVAFaceTracking_DetectedFacesArray = *v2;
    if (sVC_CVAFaceTracking_DetectedFacesArray)
    {
LABEL_5:
      loadAppleCVAFaceTrackingSymbols_loaded = 1;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v0 = VRTraceErrorLogLevelToCSTR();
        BOOL v1 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v3 = 136315650;
          uint64_t v4 = v0;
          __int16 v5 = 2080;
          uint64_t v6 = "loadAppleCVAFaceTrackingSymbols_block_invoke";
          __int16 v7 = 1024;
          int v8 = 62;
          _os_log_impl(&dword_1E1EA4000, v1, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Loaded AppleCVA FaceTracking symbols", (uint8_t *)&v3, 0x1Cu);
        }
      }
    }
  }
}

uint64_t VCGetCVAFaceTracking_DetectedFacesArray()
{
  if (loadAppleCVAFaceTrackingSymbols_onceToken != -1) {
    dispatch_once(&loadAppleCVAFaceTrackingSymbols_onceToken, &__block_literal_global_4);
  }
  return sVC_CVAFaceTracking_DetectedFacesArray;
}

void __loadAppleCVAViewpointCorrectionSymbols_block_invoke()
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (VCLoadAppleCVA_loadPredicate != -1) {
    dispatch_once(&VCLoadAppleCVA_loadPredicate, &__block_literal_global_65);
  }
  uint64_t v0 = (void *)sVCAppleCVAFrameworkLibrary;
  if (sVCAppleCVAFrameworkLibrary)
  {
    if (!sVC_CVAViewpointCorrection_Image)
    {
      BOOL v1 = (uint64_t *)dlsym((void *)sVCAppleCVAFrameworkLibrary, "kCVAViewpointCorrection_Image");
      if (v1) {
        uint64_t v2 = *v1;
      }
      else {
        uint64_t v2 = 0;
      }
      sVC_CVAViewpointCorrection_Image = v2;
      uint64_t v0 = (void *)sVCAppleCVAFrameworkLibrary;
    }
    if (!sVC_CVAViewpointCorrection_Intrinsics)
    {
      int v3 = (uint64_t *)dlsym(v0, "kCVAViewpointCorrection_Intrinsics");
      if (v3) {
        uint64_t v4 = *v3;
      }
      else {
        uint64_t v4 = 0;
      }
      sVC_CVAViewpointCorrection_Intrinsics = v4;
      uint64_t v0 = (void *)sVCAppleCVAFrameworkLibrary;
    }
    if (!sVC_CVAViewpointCorrection_VirtualCameraExtrinsics)
    {
      __int16 v5 = (uint64_t *)dlsym(v0, "kCVAViewpointCorrection_VirtualCameraExtrinsics");
      if (v5) {
        uint64_t v6 = *v5;
      }
      else {
        uint64_t v6 = 0;
      }
      sVC_CVAViewpointCorrection_VirtualCameraExtrinsics = v6;
      uint64_t v0 = (void *)sVCAppleCVAFrameworkLibrary;
    }
    if (!sVC_CVAViewpointCorrection_StereographicFisheyeStrength)
    {
      __int16 v7 = (uint64_t *)dlsym(v0, "kCVAViewpointCorrection_StereographicFisheyeStrength");
      if (v7) {
        uint64_t v8 = *v7;
      }
      else {
        uint64_t v8 = 0;
      }
      sVC_CVAViewpointCorrection_StereographicFisheyeStrength = v8;
      uint64_t v0 = (void *)sVCAppleCVAFrameworkLibrary;
    }
    if (!sVC_CVAViewpointCorrection_Timestamp)
    {
      uint64_t v9 = (uint64_t *)dlsym(v0, "kCVAViewpointCorrection_Timestamp");
      if (v9) {
        uint64_t v10 = *v9;
      }
      else {
        uint64_t v10 = 0;
      }
      sVC_CVAViewpointCorrection_int Timestamp = v10;
      uint64_t v0 = (void *)sVCAppleCVAFrameworkLibrary;
    }
    if (!sVC_CVAViewpointCorrection_Callback)
    {
      uint64_t v11 = (uint64_t *)dlsym(v0, "kCVAViewpointCorrection_Callback");
      if (v11) {
        uint64_t v12 = *v11;
      }
      else {
        uint64_t v12 = 0;
      }
      sVC_CVAViewpointCorrection_Callbacuint64_t k = v12;
      uint64_t v0 = (void *)sVCAppleCVAFrameworkLibrary;
    }
    if (!sVC_CVAViewpointCorrection_ModificationStatus)
    {
      uint64_t v13 = (uint64_t *)dlsym(v0, "kCVAViewpointCorrection_ModificationStatus");
      if (v13) {
        uint64_t v14 = *v13;
      }
      else {
        uint64_t v14 = 0;
      }
      sVC_CVAViewpointCorrection_ModificationStatus = v14;
      uint64_t v0 = (void *)sVCAppleCVAFrameworkLibrary;
    }
    if (!sVC_CVAViewpointCorrection_EnableCorrection)
    {
      __int16 v15 = (uint64_t *)dlsym(v0, "kCVAViewpointCorrection_EnableCorrection");
      if (v15) {
        uint64_t v16 = *v15;
      }
      else {
        uint64_t v16 = 0;
      }
      sVC_CVAViewpointCorrection_EnableCorrection = v16;
      uint64_t v0 = (void *)sVCAppleCVAFrameworkLibrary;
    }
    sVC_CVAViewpointCorrectionProcessFunc = (uint64_t (*)(void, void))dlsym(v0, "CVAViewpointCorrectionProcess");
    uint64_t v17 = dlsym((void *)sVCAppleCVAFrameworkLibrary, "CVAViewpointCorrectionCreate");
    sVC_CVAViewpointCorrectionCreateFunc = (uint64_t (*)(void, void, void))v17;
    if (sVC_CVAViewpointCorrection_Image)
    {
      if (sVC_CVAViewpointCorrection_Intrinsics)
      {
        if (sVC_CVAViewpointCorrection_VirtualCameraExtrinsics)
        {
          if (sVC_CVAViewpointCorrection_Timestamp)
          {
            if (sVC_CVAViewpointCorrection_Callback)
            {
              if (sVC_CVAViewpointCorrection_EnableCorrection)
              {
                if (sVC_CVAViewpointCorrectionProcessFunc)
                {
                  if (v17)
                  {
                    loadAppleCVAViewpointCorrectionSymbols_loaded = 1;
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                    {
                      uint64_t v18 = VRTraceErrorLogLevelToCSTR();
                      __int16 v19 = *MEMORY[0x1E4F47A50];
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                      {
                        int v20 = 136315650;
                        uint64_t v21 = v18;
                        __int16 v22 = 2080;
                        long long v23 = "loadAppleCVAViewpointCorrectionSymbols_block_invoke";
                        __int16 v24 = 1024;
                        int v25 = 97;
                        _os_log_impl(&dword_1E1EA4000, v19, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Loaded AppleCVA Viewpoint Correction symbols", (uint8_t *)&v20, 0x1Cu);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

uint64_t VCSecurityKeyHolder_CopyKeyManager(uint64_t a1)
{
  if (a1)
  {
    JUMPOUT(0x1E4E56580);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCSecurityKeyHolder_CopyKeyManager_cold_1();
    }
  }
  return 0;
}

uint64_t VCSecurityKeyHolder_SecurityKeyMode(uint64_t a1)
{
  if (a1)
  {
    return *(char *)(a1 + 57);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCSecurityKeyHolder_SecurityKeyMode_cold_1();
      }
    }
    return -1;
  }
}

uint64_t _VCSecurityKeyHolderClassRegister(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t VCSecurityKeyHolder_Create(uint64_t a1, uint64_t a2, int a3, uint64_t a4, char a5, unsigned int a6, uint64_t *a7)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (a7)
  {
    if (a2)
    {
      if ((a3 - 4) <= 0xFFFFFFFC)
      {
        uint64_t v14 = 2151612417;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCSecurityKeyHolder_Create_cold_3();
          }
        }
      }
      else
      {
        char v8 = a6;
        if (a6 >= 3)
        {
          uint64_t v14 = 2151612417;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              VCSecurityKeyHolder_Create_cold_4();
            }
          }
        }
        else
        {
          if (VCSecurityKeyHolderGetTypeID_initOnce != -1) {
            dispatch_once_f(&VCSecurityKeyHolderGetTypeID_initOnce, &VCSecurityKeyHolderGetTypeID_typeID, (dispatch_function_t)_VCSecurityKeyHolderClassRegister);
          }
          uint64_t Instance = _CFRuntimeCreateInstance();
          if (Instance)
          {
            uint64_t v13 = Instance;
            *(_OWORD *)(Instance + 16) = 0u;
            *(_OWORD *)(Instance + 32) = 0u;
            *(_OWORD *)(Instance + 48) = 0u;
            *(_DWORD *)(Instance + 40) = 0;
            *(_DWORD *)(Instance + 16) = a3;
            FigCFWeakReferenceStore();
            *(void *)(v13 + 48) = a4;
            *(unsigned char *)(v13 + 56) = a5;
            *(unsigned char *)(v13 + 57) = v8;
            *a7 = v13;
            uint64_t v14 = 0;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              uint64_t v15 = VRTraceErrorLogLevelToCSTR();
              uint64_t v16 = *MEMORY[0x1E4F47A50];
              uint64_t v14 = 0;
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v17 = *a7;
                int v19 = 136315906;
                uint64_t v20 = v15;
                __int16 v21 = 2080;
                __int16 v22 = "VCSecurityKeyHolder_Create";
                __int16 v23 = 1024;
                int v24 = 170;
                __int16 v25 = 2048;
                uint64_t v26 = v17;
                _os_log_impl(&dword_1E1EA4000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d keyHolder instance '%p' created", (uint8_t *)&v19, 0x26u);
                return 0;
              }
            }
          }
          else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          {
            return 2151612419;
          }
          else
          {
            VRTraceErrorLogLevelToCSTR();
            uint64_t v14 = 2151612419;
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              VCSecurityKeyHolder_Create_cold_5();
            }
          }
        }
      }
    }
    else
    {
      uint64_t v14 = 2151612417;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCSecurityKeyHolder_Create_cold_2();
        }
      }
    }
  }
  else
  {
    uint64_t v14 = 2151612417;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCSecurityKeyHolder_Create_cold_1();
      }
    }
  }
  return v14;
}

uint64_t VCSecurityKeyHolder_CopyKeyMaterialForKeyIndex(uint64_t a1, const char *a2, uint64_t *a3)
{
  if (a1)
  {
    if (a3)
    {
      uint64_t v6 = (void *)MEMORY[0x1E4E56580](a1 + 24);
      if (v6)
      {
        __int16 v7 = v6;
        if (a2)
        {
          if (*(unsigned char *)(a1 + 56)) {
            uint64_t v8 = *(void *)(a1 + 48);
          }
          else {
            uint64_t v8 = 0;
          }
          uint64_t v9 = VCSecurityKeyManager_CopyMKMWithPrefixForParticipant(v6, a2, v8);
        }
        else
        {
          uint64_t v9 = (uint64_t)VCSecurityKeyManager_CopyLatestSendKeyMaterial(v6, *(char *)(a1 + 57));
        }
        *a3 = v9;
        CFRelease(v7);
        return 0;
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      {
        return 2151612477;
      }
      else
      {
        VRTraceErrorLogLevelToCSTR();
        uint64_t v10 = 2151612477;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCSecurityKeyHolder_CopyKeyMaterialForKeyIndex_cold_3();
        }
      }
    }
    else
    {
      uint64_t v10 = 2151612417;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCSecurityKeyHolder_CopyKeyMaterialForKeyIndex_cold_2();
        }
      }
    }
  }
  else
  {
    uint64_t v10 = 2151612417;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCSecurityKeyHolder_CopyKeyMaterialForKeyIndex_cold_1();
      }
    }
  }
  return v10;
}

uint64_t VCSecurityKeyHolder_RegisterForKeyMaterialChangeNotification(uint64_t a1, const void *a2)
{
  if (a1)
  {
    uint64_t v4 = MEMORY[0x1E4E56580](a1 + 24);
    if (v4)
    {
      __int16 v5 = (const void *)v4;
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
      uint64_t v6 = *(const void **)(a1 + 32);
      if (v6)
      {
        _Block_release(v6);
        *(void *)(a1 + 32) = 0;
        if (a2)
        {
          *(void *)(a1 + 32) = _Block_copy(a2);
LABEL_12:
          os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
          CFRelease(v5);
          return 0;
        }
      }
      else if (a2)
      {
        *(void *)(a1 + 32) = _Block_copy(a2);
        int v7 = *(_DWORD *)(a1 + 16);
        if ((v7 | 2) == 3)
        {
          LocalCenter = CFNotificationCenterGetLocalCenter();
          CFNotificationCenterAddObserver(LocalCenter, (const void *)a1, (CFNotificationCallback)_VCSecurityKeyHolder_KeyMaterialCallback, @"VCSecurityKeyManagerNotification_SendKeyMaterialChanged", v5, CFNotificationSuspensionBehaviorDeliverImmediately);
          int v7 = *(_DWORD *)(a1 + 16);
        }
        if ((v7 & 0xFFFFFFFE) == 2)
        {
          uint64_t v9 = CFNotificationCenterGetLocalCenter();
          CFNotificationCenterAddObserver(v9, (const void *)a1, (CFNotificationCallback)_VCSecurityKeyHolder_KeyMaterialCallback, @"VCSecurityKeyManagerNotification_ReceiveKeyMaterialChanged", v5, CFNotificationSuspensionBehaviorDeliverImmediately);
        }
        goto LABEL_12;
      }
      _VCSecurityKeyHolder_UnregisterKeyMaterialNotification(a1);
      goto LABEL_12;
    }
    uint64_t v10 = 2151612432;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        VCSecurityKeyHolder_RegisterForKeyMaterialChangeNotification_cold_2();
        return 2151612432;
      }
    }
  }
  else
  {
    uint64_t v10 = 2151612417;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCSecurityKeyHolder_RegisterForKeyMaterialChangeNotification_cold_1();
      }
    }
  }
  return v10;
}

void _VCSecurityKeyHolder_KeyMaterialCallback(uint64_t a1, uint64_t a2, const __CFString *a3, const void *a4, const void *a5)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v9 = VRTraceErrorLogLevelToCSTR();
    uint64_t v10 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v15 = 136316162;
      uint64_t v16 = v9;
      __int16 v17 = 2080;
      uint64_t v18 = "_VCSecurityKeyHolder_KeyMaterialCallback";
      __int16 v19 = 1024;
      int v20 = 95;
      __int16 v21 = 2048;
      uint64_t v22 = a2;
      __int16 v23 = 2112;
      int v24 = a5;
      _os_log_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received Uplink notification for keyHolder instance '%p' with key material '%@'", (uint8_t *)&v15, 0x30u);
    }
  }
  uint64_t v11 = (const void *)VCSecurityKeyHolder_CopyKeyManager(a2);
  if (v11 == a4)
  {
    if (CFStringCompare(a3, @"VCSecurityKeyManagerNotification_SendKeyMaterialChanged", 0)
      && CFStringCompare(a3, @"VCSecurityKeyManagerNotification_ReceiveKeyMaterialChanged", 0))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCSecurityKeyHolder_KeyMaterialCallback_cold_1();
        }
      }
    }
    else
    {
      os_unfair_lock_lock((os_unfair_lock_t)(a2 + 40));
      uint64_t v14 = *(void *)(a2 + 32);
      if (v14) {
        (*(void (**)(uint64_t, const void *))(v14 + 16))(v14, a5);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 40));
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v12 = VRTraceErrorLogLevelToCSTR();
    uint64_t v13 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
    {
      int v15 = 136316162;
      uint64_t v16 = v12;
      __int16 v17 = 2080;
      uint64_t v18 = "_VCSecurityKeyHolder_KeyMaterialCallback";
      __int16 v19 = 1024;
      int v20 = 112;
      __int16 v21 = 2048;
      uint64_t v22 = (uint64_t)v11;
      __int16 v23 = 2048;
      int v24 = a4;
      _os_log_error_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_ERROR, " [%s] %s:%d Notification from wrong VCSecurityKeyManager instance received: Expected instance '%llu' but got '%llu'", (uint8_t *)&v15, 0x30u);
    }
  }
  if (v11) {
    CFRelease(v11);
  }
}

void _VCSecurityKeyHolder_UnregisterKeyMaterialNotification(uint64_t a1)
{
  uint64_t v2 = (const void *)VCSecurityKeyHolder_CopyKeyManager(a1);
  int v3 = *(_DWORD *)(a1 + 16);
  if ((v3 | 2) == 3)
  {
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterRemoveObserver(LocalCenter, (const void *)a1, @"VCSecurityKeyManagerNotification_SendKeyMaterialChanged", v2);
    int v3 = *(_DWORD *)(a1 + 16);
  }
  if ((v3 & 0xFFFFFFFE) == 2)
  {
    __int16 v5 = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterRemoveObserver(v5, (const void *)a1, @"VCSecurityKeyManagerNotification_ReceiveKeyMaterialChanged", v2);
  }
  uint64_t v6 = *(const void **)(a1 + 32);
  if (v6) {
    _Block_release(v6);
  }
  if (v2)
  {
    CFRelease(v2);
  }
}

uint64_t VCSecurityKeyHolder_AssociateKeyIndex(uint64_t a1, const char *a2)
{
  if (a1)
  {
    if (a2)
    {
      VCSecurityKeyManager_AssociateKeyIndex(*(void **)(a1 + 24), a2, *(void *)(a1 + 48));
      return 0;
    }
    else
    {
      uint64_t v2 = 2151612417;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCSecurityKeyHolder_AssociateKeyIndex_cold_2();
        }
      }
    }
  }
  else
  {
    uint64_t v2 = 2151612417;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCSecurityKeyHolder_AssociateKeyIndex_cold_1();
      }
    }
  }
  return v2;
}

void _VCSecurityKeyHolder_Finalize(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  _VCSecurityKeyHolder_UnregisterKeyMaterialNotification(a1);
  FigCFWeakReferenceStore();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v2 = VRTraceErrorLogLevelToCSTR();
    int v3 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 136315906;
      uint64_t v5 = v2;
      __int16 v6 = 2080;
      int v7 = "_VCSecurityKeyHolder_Finalize";
      __int16 v8 = 1024;
      int v9 = 42;
      __int16 v10 = 2048;
      uint64_t v11 = a1;
      _os_log_impl(&dword_1E1EA4000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d keyHolder instance '%p' finalized", (uint8_t *)&v4, 0x26u);
    }
  }
}

void OUTLINED_FUNCTION_9_8(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x44u);
}

uint64_t _VCDTMFToneGenerator_GenerateNextSample(_DWORD *a1)
{
  int v1 = a1[4];
  int v2 = a1[2];
  int v3 = a1[6];
  unsigned int v4 = ((v3 * a1[1] + 0x2000) >> 14) - a1[5];
  int v5 = (__int16)(((v1 * *a1 + 0x2000) >> 14) - a1[3]);
  a1[3] = v1;
  a1[4] = v5;
  a1[5] = v3;
  a1[6] = (__int16)v4;
  return (__int16)((((23171 * v5 + ((int)(v4 << 16) >> 1) + 0x4000) >> 15) * v2 + 0x2000) >> 14);
}

_DWORD *VCDTMFToneGenerator_Create()
{
  uint64_t result = malloc_type_malloc(0x1CuLL, 0x100004027586B93uLL);
  if (result) {
    result[2] = -1;
  }
  return result;
}

void VCDTMFToneGenerator_Destroy(void **a1)
{
  if (a1)
  {
    int v2 = *a1;
    if (v2) {
      free(v2);
    }
    *a1 = 0;
  }
}

uint64_t VCDTMFToneGenerator_Reinit(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v8 = VRTraceErrorLogLevelToCSTR();
    int v9 = *MEMORY[0x1E4F47A50];
    uint64_t v10 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        int v14 = 136316674;
        uint64_t v15 = v8;
        __int16 v16 = 2080;
        __int16 v17 = "VCDTMFToneGenerator_Reinit";
        __int16 v18 = 1024;
        int v19 = 199;
        __int16 v20 = 2048;
        uint64_t v21 = a1;
        __int16 v22 = 1024;
        unsigned int v23 = a2;
        __int16 v24 = 1024;
        unsigned int v25 = a3;
        __int16 v26 = 1024;
        int v27 = a4;
        _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCDTMFToneGenerator[%p] Initialize event=%d, powerLevel=%d, sampleRate=%d", (uint8_t *)&v14, 0x38u);
      }
    }
    else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      int v14 = 136316674;
      uint64_t v15 = v8;
      __int16 v16 = 2080;
      __int16 v17 = "VCDTMFToneGenerator_Reinit";
      __int16 v18 = 1024;
      int v19 = 199;
      __int16 v20 = 2048;
      uint64_t v21 = a1;
      __int16 v22 = 1024;
      unsigned int v23 = a2;
      __int16 v24 = 1024;
      unsigned int v25 = a3;
      __int16 v26 = 1024;
      int v27 = a4;
      _os_log_debug_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCDTMFToneGenerator[%p] Initialize event=%d, powerLevel=%d, sampleRate=%d", (uint8_t *)&v14, 0x38u);
    }
  }
  if (a2 >= 0x10)
  {
    uint64_t v12 = 2147811332;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCDTMFToneGenerator_Reinit_cold_1();
      }
    }
  }
  else if (a3 >= 0x40)
  {
    uint64_t v12 = 2147811332;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCDTMFToneGenerator_Reinit_cold_2();
      }
    }
  }
  else
  {
    if (a4 <= 23999)
    {
      if (a4 == 8000)
      {
        uint64_t v11 = 0;
        goto LABEL_20;
      }
      if (a4 == 16000)
      {
        uint64_t v11 = 1;
        goto LABEL_20;
      }
    }
    else
    {
      switch(a4)
      {
        case 24000:
          uint64_t v11 = 2;
          goto LABEL_20;
        case 32000:
          uint64_t v11 = 3;
          goto LABEL_20;
        case 48000:
          uint64_t v11 = 4;
LABEL_20:
          uint64_t v12 = 0;
          *(_DWORD *)a1 = VCDTMFToneGeneratorCoefficient1[16 * v11 + a2];
          *(_DWORD *)(a1 + 4) = VCDTMFToneGeneratorCoefficient2[16 * v11 + a2];
          *(_DWORD *)(a1 + 8) = VCDTMFToneGenerator_Amplitude[a3];
          *(void *)(a1 + 12) = VCDTMFToneGeneratorInitValue1[16 * v11 + a2];
          *(void *)(a1 + 20) = VCDTMFToneGeneratorInitValue2[16 * v11 + a2];
          return v12;
      }
    }
    uint64_t v12 = 2147811332;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCDTMFToneGenerator_Reinit_cold_3();
      }
    }
  }
  return v12;
}

uint64_t VCDTMFToneGenerator_GenerateSamples(_DWORD *a1, int a2, _WORD *a3)
{
  LODWORD(v4) = a2;
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  int v6 = a1[2];
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v6 == -1)
  {
    uint64_t v11 = 2147811332;
    if (ErrorLogLevelForModule >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCDTMFToneGenerator_GenerateSamples_cold_1();
      }
    }
  }
  else
  {
    if (ErrorLogLevelForModule >= 8)
    {
      uint64_t v8 = VRTraceErrorLogLevelToCSTR();
      int v9 = *MEMORY[0x1E4F47A50];
      uint64_t v10 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          int v13 = 136316162;
          uint64_t v14 = v8;
          __int16 v15 = 2080;
          __int16 v16 = "VCDTMFToneGenerator_GenerateSamples";
          __int16 v17 = 1024;
          int v18 = 224;
          __int16 v19 = 2048;
          __int16 v20 = a1;
          __int16 v21 = 1024;
          int v22 = v4;
          _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCDTMFToneGenerator[%p] Generate DTMF tone samples, sampleCount=%d", (uint8_t *)&v13, 0x2Cu);
        }
      }
      else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        int v13 = 136316162;
        uint64_t v14 = v8;
        __int16 v15 = 2080;
        __int16 v16 = "VCDTMFToneGenerator_GenerateSamples";
        __int16 v17 = 1024;
        int v18 = 224;
        __int16 v19 = 2048;
        __int16 v20 = a1;
        __int16 v21 = 1024;
        int v22 = v4;
        _os_log_debug_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCDTMFToneGenerator[%p] Generate DTMF tone samples, sampleCount=%d", (uint8_t *)&v13, 0x2Cu);
      }
    }
    if ((int)v4 >= 1)
    {
      uint64_t v4 = v4;
      do
      {
        *a3++ = _VCDTMFToneGenerator_GenerateNextSample(a1);
        --v4;
      }
      while (v4);
    }
    return 0;
  }
  return v11;
}

CFTypeRef _VCConnectionManagerIDS_CopyConnection(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 104));
  uint64_t v6 = VCConnectionManager_CopyPrimaryConnection(a1);
  if (!v6)
  {
    pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 104));
    return 0;
  }
  int v7 = (const void *)v6;
  double v8 = micro();
  if (!VCConnection_MatchesSourceDestinationInfo((uint64_t)v7, a2))
  {
    CFArrayRef v13 = *(const __CFArray **)(a1 + 336);
    if (!v13 || (CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 336)), Count < 1))
    {
LABEL_13:
      int v18 = 0;
      CFTypeRef v9 = 0;
LABEL_21:
      int v12 = 170;
      goto LABEL_22;
    }
    CFIndex v15 = Count;
    CFIndex v16 = 0;
    while (1)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v13, v16);
      if (VCConnection_MatchesSourceDestinationInfo((uint64_t)ValueAtIndex, a2)) {
        break;
      }
      if (v15 == ++v16) {
        goto LABEL_13;
      }
    }
    *a3 = 0;
    if (ValueAtIndex) {
      CFTypeRef v9 = CFRetain(ValueAtIndex);
    }
    else {
      CFTypeRef v9 = 0;
    }
    VCConnection_SourceDestinationInfo((uint64_t)ValueAtIndex, a2);
    *(double *)(a1 + 3576) = v8;
    if (v8 - *(double *)(a1 + 3584) > 1.0)
    {
      int v12 = VCConnection_IsRemoteOnWiFiOrWired((uint64_t)ValueAtIndex) ^ 1;
      *(double *)(a1 + 3584) = v8;
      goto LABEL_19;
    }
LABEL_20:
    int v18 = 0;
    goto LABEL_21;
  }
  *a3 = 1;
  CFTypeRef v9 = CFRetain(v7);
  VCConnection_SourceDestinationInfo((uint64_t)v7, a2);
  double v10 = *(double *)(a1 + 3576);
  if (v10 == 0.0 || v8 - v10 <= 5.0) {
    goto LABEL_20;
  }
  int v12 = 0;
  *(void *)(a1 + 3576) = 0;
LABEL_19:
  int v18 = 1;
LABEL_22:
  CFRelease(v7);
  pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 104));
  if (v18 && !*(unsigned char *)(a1 + 710)) {
    _VCConnectionManagerIDS_SetPreferredRemoteInterfaceForDuplication(a1, v12);
  }
  return v9;
}

void _VCConnectionManagerIDS_UpdateConnectionForDuplication(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  CFTypeRef v2 = VCConnectionSelector_CopyConnectionForDuplication(*(void *)(a1 + 640));
  int v3 = VCDuplicationHandler_DuplicationReason(*(void *)(a1 + 632));
  VCConnectionSelector_UpdateConnectionForDuplication(*(void *)(a1 + 640), v3, *(unsigned __int8 *)(a1 + 749), *(unsigned __int8 *)(a1 + 498), *(unsigned __int8 *)(a1 + 499), *(const __CFArray **)(a1 + 336));
  CFTypeRef v4 = (id)VCConnectionSelector_CopyConnectionForDuplication(*(void *)(a1 + 640));
  if ((VCConnection_Equal((uint64_t)v2, (uint64_t)v4) & 1) == 0)
  {
    int v5 = (const void *)VCConnection_CopyDescription((uint64_t)v4);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v6 = VRTraceErrorLogLevelToCSTR();
      int v7 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        uint64_t v18 = v6;
        __int16 v19 = 2080;
        __int16 v20 = "_VCConnectionManagerIDS_UpdateConnectionForDuplication";
        __int16 v21 = 1024;
        int v22 = 745;
        __int16 v23 = 2112;
        __int16 v24 = v5;
        _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: selected connection %@ for duplication", buf, 0x26u);
      }
    }
    if (v5) {
      CFRelease(v5);
    }
    BOOL IsDuplicationEnabled = VCDuplicationHandler_IsDuplicationEnabled(*(void *)(a1 + 632));
    VCConnectionManager_SetOverlayLinkDetails(a1, (uint64_t)v4, 1, IsDuplicationEnabled);
    if (v4) {
      BOOL v9 = !IsDuplicationEnabled;
    }
    else {
      BOOL v9 = 1;
    }
    if (!v9)
    {
      int IsLocalOnCellular = VCConnection_IsLocalOnCellular((uint64_t)v4);
      VCConnectionManager_UseCellPrimaryInterface(a1, IsLocalOnCellular);
      CFStringRef v11 = VCConnectionManager_CopySuggestedLinkTypeCombo(a1);
      char v12 = VCDuplicationHandler_DuplicationReason(*(void *)(a1 + 632));
      CFArrayRef v13 = *(NSObject **)(a1 + 448);
      v14[0] = MEMORY[0x1E4F143A8];
      v14[1] = 3221225472;
      _OWORD v14[2] = ___VCConnectionManagerIDS_UpdateConnectionForDuplication_block_invoke;
      v14[3] = &unk_1E6DB6E88;
      char v15 = 1;
      v14[4] = a1;
      v14[5] = v4;
      char v16 = v12;
      v14[6] = v11;
      dispatch_async(v13, v14);
    }
  }
  if (v2) {
    CFRelease(v2);
  }
}

void _VCConnectionManagerIDS_SynchronizeParticipantGenerationCounter(uint64_t a1, char a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  CFTypeRef v2 = *(NSObject **)(a1 + 448);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___VCConnectionManagerIDS_SynchronizeParticipantGenerationCounter_block_invoke;
  block[3] = &unk_1E6DB3DF0;
  block[4] = a1;
  char v4 = a2;
  dispatch_async(v2, block);
}

void _VCConnectionManagerIDS_IsSourceOnCellularIPv6(uint64_t a1, uint64_t a2, unsigned char *a3, unsigned char *a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  *a3 = 0;
  *a4 = 0;
  if (*(_DWORD *)a2 == 4)
  {
    CFArrayRef v4 = *(const __CFArray **)(a1 + 336);
    if (v4)
    {
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 336));
      if (Count >= 1)
      {
        CFIndex v9 = Count;
        CFIndex v10 = 0;
        while (1)
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v4, v10);
          if (VCConnectionIDS_LinkID((uint64_t)ValueAtIndex) == *(char *)(a2 + 12)) {
            break;
          }
          if (v9 == ++v10) {
            return;
          }
        }
        if (VCConnection_IsLocalOnCellular((uint64_t)ValueAtIndex)) {
          *a3 = 1;
        }
        if (VCConnection_IsIPv6((uint64_t)ValueAtIndex)) {
          *a4 = 1;
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v12 = VRTraceErrorLogLevelToCSTR();
      CFArrayRef v13 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v14 = 136315650;
        uint64_t v15 = v12;
        __int16 v16 = 2080;
        __int16 v17 = "_VCConnectionManagerIDS_IsSourceOnCellularIPv6";
        __int16 v18 = 1024;
        int v19 = 982;
        _os_log_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil _connectionArray", (uint8_t *)&v14, 0x1Cu);
      }
    }
  }
}

CFTypeRef _VCConnectionManagerIDS_CopyPrimaryConnection(uint64_t a1)
{
  return VCConnectionSelector_CopyPrimaryConnection(*(void *)(a1 + 640));
}

void _VCConnectionManagerIDS_SetPrimaryConnection(uint64_t a1, const void *a2)
{
}

uint64_t _VCConnectionManagerIDS_UpdatePacketAndByteCount(uint64_t a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  uint64_t v12 = (const void *)VCConnectionManager_CopyPrimaryConnection(a1);
  int v13 = VCConnectionIDS_NetworkOverheadInBytes((uint64_t)v12, a4, a5);
  if (v12) {
    CFRelease(v12);
  }
  int v14 = v13 + a3;
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 104));
  uint64_t v15 = &OBJC_IVAR___VCConnectionManagerIDS__receivedPacketCount;
  if (a6) {
    uint64_t v15 = &OBJC_IVAR___VCConnectionManagerIDS__sentPacketCount;
  }
  ++*(_DWORD *)(a1 + *v15 + 4 * a2);
  __int16 v16 = &OBJC_IVAR___VCConnectionManagerIDS__sentByteCount;
  if (!a6) {
    __int16 v16 = &OBJC_IVAR___VCConnectionManagerIDS__receivedByteCount;
  }
  *(_DWORD *)(a1 + *v16 + 4 * a2) = v14 + *(_DWORD *)(a1 + *v16 + 4 * a2) - 20;

  return pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 104));
}

uint64_t _VCConnectionManagerIDS_UpdatePersistentPacketCounts(uint64_t a1, unsigned int a2, uint64_t a3)
{
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 104));
  if (a3)
  {
    ++*(_DWORD *)(a1 + 864 + 4 * a2);
    uint64_t v6 = &OBJC_IVAR___VCConnectionManager__isFirstPacketSentCount;
  }
  else
  {
    ++*(_DWORD *)(a1 + 1888 + 4 * a2);
    uint64_t v6 = &OBJC_IVAR___VCConnectionManager__isFirstPacketReceivedCount;
  }
  uint64_t v7 = *v6;
  if (!*(unsigned char *)(a1 + v7))
  {
    [*(id *)(a1 + 2928) startPeriodicUpdateHistory:a3 withCopyPacketCountCallback:*(void *)(a1 + 2920)];
    uint64_t v7 = *v6;
  }
  *(unsigned char *)(a1 + v7) = 1;

  return pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 104));
}

uint64_t _VCConnectionManagerIDS_AddLinkProbingTelemetry_0(id *a1, void *a2)
{
  uint64_t result = objc_msgSend((id)objc_msgSend(a1[80], "linkPreferenceOrder"), "count");
  if (result)
  {
    uint64_t result = VCConnection_Equal([a1 connectionForDuplication], objc_msgSend(a1[80], "connectionForDuplicationNonProbingVersion"));
    if ((result & 1) == 0)
    {
      uint64_t v5 = objc_msgSend(a1[97], "getProbingResultsForLinkID:", objc_msgSend(NSNumber, "numberWithInt:", VCConnection_ConnectionID(objc_msgSend(a1, "connectionForDuplication"))));
      uint64_t v6 = objc_msgSend(a1[97], "getProbingResultsForLinkID:", objc_msgSend(NSNumber, "numberWithInt:", VCConnection_ConnectionID(objc_msgSend(a1[80], "connectionForDuplicationNonProbingVersion"))));
      if (v5) {
        BOOL v7 = v6 == 0;
      }
      else {
        BOOL v7 = 1;
      }
      if (v7)
      {
        unsigned __int8 v8 = 0;
        double v9 = 0.0;
      }
      else
      {
        CFIndex v10 = (void *)v6;
        objc_msgSend((id)objc_msgSend(v5, "expMovMeanRTT"), "doubleValue");
        double v9 = 0.0;
        if (v11 != 0.0)
        {
          objc_msgSend((id)objc_msgSend(v10, "expMovMeanRTT"), "doubleValue");
          if (v12 != 0.0)
          {
            objc_msgSend((id)objc_msgSend(v10, "expMovMeanRTT"), "doubleValue");
            double v14 = v13;
            objc_msgSend((id)objc_msgSend(v5, "expMovMeanRTT"), "doubleValue");
            double v9 = v14 - v15;
          }
        }
        char v16 = objc_msgSend((id)objc_msgSend(v10, "plrTier"), "unsignedIntValue");
        unsigned __int8 v8 = v16 - objc_msgSend((id)objc_msgSend(v5, "plrTier"), "unsignedIntValue");
      }
      objc_msgSend(a2, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithDouble:", v9), @"lnkPrbRTTMeanDelta");
      uint64_t v17 = [NSNumber numberWithUnsignedChar:v8];
      return [a2 setObject:v17 forKeyedSubscript:@"lnkPrbPLRTierDelta"];
    }
  }
  return result;
}

uint64_t _VCConnectionManagerIDS_SetPreferredRemoteInterfaceForDuplication(uint64_t a1, int a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 104));
  if (*(unsigned __int8 *)(a1 + 499) == a2)
  {
    return pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 104));
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      uint64_t v6 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        BOOL v7 = "Cellular";
        uint64_t v9 = v5;
        int v8 = 136315906;
        double v11 = "_VCConnectionManagerIDS_SetPreferredRemoteInterfaceForDuplication";
        __int16 v10 = 2080;
        if (!a2) {
          BOOL v7 = "WiFi";
        }
        __int16 v12 = 1024;
        int v13 = 610;
        __int16 v14 = 2080;
        double v15 = v7;
        _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: updated preferred remote interface for duplication to %s", (uint8_t *)&v8, 0x26u);
      }
    }
    *(unsigned char *)(a1 + 499) = a2;
    VCConnectionManager_UpdateConnectionForDuplication(a1);
    return pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 104));
  }
}

uint64_t _VCAudioFrameDelayClassRegister(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t VCAudioFrameDelay_Create(const __CFAllocator *a1, long long *a2, uint64_t *a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (a3)
    {
      if (VCAudioFrameDelay_GetTypeID_initOnce != -1) {
        dispatch_once_f(&VCAudioFrameDelay_GetTypeID_initOnce, &VCAudioFrameDelay_GetTypeID_typeID, (dispatch_function_t)_VCAudioFrameDelayClassRegister);
      }
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        uint64_t v7 = Instance;
        *(void *)(Instance + 96) = 0;
        *(_OWORD *)(Instance + 64) = 0u;
        *(_OWORD *)(Instance + 80) = 0u;
        *(_OWORD *)(Instance + 32) = 0u;
        *(_OWORD *)(Instance + 48) = 0u;
        *(_OWORD *)(Instance + 16) = 0u;
        CFTypeRef v8 = (CFTypeRef)*((void *)a2 + 6);
        if (v8) {
          CFTypeRef v8 = CFRetain(v8);
        }
        *(void *)(v7 + 16) = v8;
        long long v9 = *a2;
        long long v10 = a2[1];
        *(_OWORD *)(v7 + 56) = a2[2];
        *(_OWORD *)(v7 + 40) = v10;
        *(_OWORD *)(v7 + 24) = v9;
        CFIndex v11 = *((void *)a2 + 8);
        *(void *)(v7 + 72) = v11;
        *(_DWORD *)(v7 + 88) = *((_DWORD *)a2 + 14);
        __int16 v12 = CFAllocatorAllocate(a1, v11, 0);
        *(void *)(v7 + 80) = v12;
        if (!v12)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              VCAudioFrameDelay_Create_cold_4();
            }
          }
          uint64_t v18 = 0;
LABEL_23:
          CFRelease((CFTypeRef)v7);
          return v18;
        }
        int v13 = *((_DWORD *)a2 + 14);
        if (v13)
        {
          while (1)
          {
            *(void *)__int16 v26 = 0;
            uint64_t DelayFrame = _VCAudioFrameDelay_AllocateDelayFrame(v7, (uint64_t **)v26);
            if ((DelayFrame & 0x80000000) != 0) {
              break;
            }
            _VCAudioFrameDelay_InsertDelayFrame(v7, *(void **)v26, *(uint64_t **)(v7 + 96));
            if (!--v13) {
              goto LABEL_12;
            }
          }
          uint64_t v18 = DelayFrame;
          int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
          uint64_t v25 = (os_log_t *)MEMORY[0x1E4F47A50];
          if (ErrorLogLevelForModule >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled(*v25, OS_LOG_TYPE_ERROR)) {
              VCAudioFrameDelay_Create_cold_6();
            }
          }
          _VCAudioFrameDelay_CleanupDelayFrames((void *)v7);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled(*v25, OS_LOG_TYPE_ERROR)) {
              VCAudioFrameDelay_Create_cold_5();
            }
          }
          goto LABEL_23;
        }
LABEL_12:
        *a3 = v7;
        if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
          return 0;
        }
        uint64_t v15 = VRTraceErrorLogLevelToCSTR();
        uint64_t v16 = *MEMORY[0x1E4F47A50];
        uint64_t v18 = 0;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v19 = *(_DWORD *)(v7 + 92);
          LODWORD(v17) = *(_DWORD *)(v7 + 64);
          double v20 = (double)v19 * (double)v17;
          uint64_t v21 = *a3;
          *(_DWORD *)__int16 v26 = 136316418;
          double v22 = *(double *)(v7 + 24);
          *(void *)&v26[4] = v15;
          __int16 v27 = 2080;
          uint64_t v28 = "VCAudioFrameDelay_Create";
          __int16 v29 = 1024;
          int v30 = 300;
          __int16 v31 = 2048;
          uint64_t v32 = v21;
          __int16 v33 = 1024;
          unsigned int v34 = v19;
          __int16 v35 = 2048;
          double v36 = v20 / v22;
          _os_log_impl(&dword_1E1EA4000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [%p] VCAudioFrameDelay created. frameDelay=%d timeDelay=%f", v26, 0x36u);
          return 0;
        }
      }
      else
      {
        uint64_t v18 = 2152464386;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
          {
            VCAudioFrameDelay_Create_cold_3();
            return 2152464386;
          }
        }
      }
    }
    else
    {
      uint64_t v18 = 2152464385;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCAudioFrameDelay_Create_cold_2();
        }
      }
    }
  }
  else
  {
    uint64_t v18 = 2152464385;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioFrameDelay_Create_cold_1();
      }
    }
  }
  return v18;
}

uint64_t VCAudioFrameDelay_PullAudioSamples(uint64_t result, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (result && a2 && a3)
  {
    uint64_t v7 = result;
    unsigned int v8 = *(_DWORD *)(result + 88);
    unsigned int v9 = *(_DWORD *)(result + 92);
    if (v8 != v9)
    {
      if (v8 <= v9)
      {
        if (v8 < v9)
        {
          __int16 v12 = *(uint64_t **)(result + 96);
          if (v12)
          {
            *(void *)uint64_t v28 = *(void *)(result + 96);
            int v13 = v12;
            do
            {
              __int16 v14 = (uint64_t *)*v13;
              if (*((unsigned char *)v13 + 25))
              {
                _VCAudioFrameDelay_RemoveDelayFrame(v7, v13);
                _VCAudioFrameDelay_DeallocateDelayFrame((const void *)v7, (uint64_t **)v28);
                int v15 = *(_DWORD *)(v7 + 92);
                *(void *)uint64_t v28 = v14;
                if (!v15) {
                  break;
                }
                __int16 v12 = *(uint64_t **)(v7 + 96);
              }
              else
              {
                *(void *)uint64_t v28 = *v13;
              }
              int v13 = v14;
            }
            while (v14 != v12);
          }
          else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              VCAudioFrameDelay_PullAudioSamples_cold_2();
            }
          }
        }
      }
      else
      {
        uint64_t v10 = *(void *)(result + 96);
        if (v10)
        {
          uint64_t v11 = *(void *)(result + 96);
          do
          {
            if (*(unsigned char *)(v11 + 25)) {
              goto LABEL_21;
            }
            uint64_t v11 = *(void *)v11;
          }
          while (v11 != v10);
        }
        else
        {
          uint64_t v11 = 0;
LABEL_21:
          while (1)
          {
            *(void *)uint64_t v28 = 0;
            if ((_VCAudioFrameDelay_AllocateDelayFrame(v7, (uint64_t **)v28) & 0x80000000) != 0) {
              break;
            }
            uint64_t v16 = (uint64_t *)v11;
            if (!v11) {
              uint64_t v16 = *(uint64_t **)(v7 + 96);
            }
            _VCAudioFrameDelay_InsertDelayFrame(v7, *(void **)v28, v16);
            if (*(_DWORD *)(v7 + 92) >= *(_DWORD *)(v7 + 88)) {
              goto LABEL_25;
            }
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              VCAudioFrameDelay_PullAudioSamples_cold_1();
            }
          }
        }
      }
LABEL_25:
      unsigned int v8 = *(_DWORD *)(v7 + 92);
      if (*(_DWORD *)(v7 + 88) == v8)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          uint64_t v17 = VRTraceErrorLogLevelToCSTR();
          uint64_t v18 = *MEMORY[0x1E4F47A50];
          unsigned int v19 = *MEMORY[0x1E4F47A50];
          if (*MEMORY[0x1E4F47A40])
          {
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              int v20 = *(_DWORD *)(v7 + 92);
              *(_DWORD *)uint64_t v28 = 136316162;
              *(void *)&v28[4] = v17;
              __int16 v29 = 2080;
              int v30 = "_VCAudioFrameDelay_PerformAdaptation";
              __int16 v31 = 1024;
              int v32 = 264;
              __int16 v33 = 2048;
              uint64_t v34 = v7;
              __int16 v35 = 1024;
              int v36 = v20;
              _os_log_impl(&dword_1E1EA4000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [%p] Successfully adapted to frame delay=%u", v28, 0x2Cu);
            }
          }
          else if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
          {
            int v27 = *(_DWORD *)(v7 + 92);
            *(_DWORD *)uint64_t v28 = 136316162;
            *(void *)&v28[4] = v17;
            __int16 v29 = 2080;
            int v30 = "_VCAudioFrameDelay_PerformAdaptation";
            __int16 v31 = 1024;
            int v32 = 264;
            __int16 v33 = 2048;
            uint64_t v34 = v7;
            __int16 v35 = 1024;
            int v36 = v27;
            _os_log_debug_impl(&dword_1E1EA4000, v18, OS_LOG_TYPE_DEBUG, " [%s] %s:%d [%p] Successfully adapted to frame delay=%u", v28, 0x2Cu);
          }
        }
        unsigned int v8 = *(_DWORD *)(v7 + 92);
      }
    }
    if (v8)
    {
      uint64_t v21 = *(void *)(v7 + 96);
      *(void *)(v7 + 96) = *(void *)v21;
      VCAudioBufferList_ReplaceSamples(a2, *(void *)(v21 + 16), 0);
      if (*(unsigned char *)(v21 + 24))
      {
        char Priority = VCAudioBufferList_GetPriority(*(void *)(v21 + 16));
        VCAudioBufferList_SetPriority(a2, Priority);
        uint64_t v23 = *(void *)(v21 + 32);
      }
      else
      {
        VCAudioBufferList_SetPriority(a2, 0);
        uint64_t v23 = 0;
      }
      *a3 = v23;
      uint64_t v24 = *(void *)(v21 + 32);
      *(void *)(v21 + 32) = *(void *)(v7 + 80);
      *(void *)(v7 + 80) = v24;
      double HostTime = VCAudioBufferList_GetHostTime(a2);
      int Timestamp = VCAudioBufferList_GetTimestamp(a2);
      VCAudioBufferList_SetTime(*(void *)(v21 + 16), Timestamp, HostTime);
      uint64_t result = (*(uint64_t (**)(uint64_t, void, void, uint64_t))(a4 + 16))(a4, *(void *)(v21 + 16), *(void *)(v21 + 32), v21 + 25);
      *(unsigned char *)(v21 + 24) = 1;
    }
    else
    {
      v28[0] = 0;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, unsigned char *))(a4 + 16))(a4, a2, *(void *)(v7 + 80), v28);
      *a3 = *(void *)(v7 + 80);
    }
  }
  return result;
}

uint64_t VCAudioFrameDelay_UpdateDelay(uint64_t a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(_DWORD *)(a1 + 88) = a2;
    if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
      return 0;
    }
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    uint64_t v5 = *MEMORY[0x1E4F47A50];
    uint64_t v6 = *MEMORY[0x1E4F47A50];
    if (!*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        int v9 = 136316162;
        uint64_t v10 = v4;
        __int16 v11 = 2080;
        __int16 v12 = "VCAudioFrameDelay_UpdateDelay";
        __int16 v13 = 1024;
        int v14 = 348;
        __int16 v15 = 2048;
        uint64_t v16 = a1;
        __int16 v17 = 1024;
        int v18 = a2;
        _os_log_debug_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEBUG, " [%s] %s:%d [%p] Setting audio frame delay=%d", (uint8_t *)&v9, 0x2Cu);
      }
      return 0;
    }
    uint64_t v7 = 0;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 136316162;
      uint64_t v10 = v4;
      __int16 v11 = 2080;
      __int16 v12 = "VCAudioFrameDelay_UpdateDelay";
      __int16 v13 = 1024;
      int v14 = 348;
      __int16 v15 = 2048;
      uint64_t v16 = a1;
      __int16 v17 = 1024;
      int v18 = a2;
      _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [%p] Setting audio frame delay=%d", (uint8_t *)&v9, 0x2Cu);
      return 0;
    }
  }
  else
  {
    uint64_t v7 = 2152464385;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioFrameDelay_UpdateDelay_cold_1();
      }
    }
  }
  return v7;
}

double _VCAudioFrameDelayInit(uint64_t a1)
{
  *(void *)(a1 + 96) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void _VCAudioFrameDelayFinalize(uint64_t a1)
{
  _VCAudioFrameDelay_CleanupDelayFrames((void *)a1);
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFAllocatorDeallocate(v2, *(void **)(a1 + 80));
  *(void *)(a1 + 80) = 0;
}

__CFString *_VCAudioFrameDelayCopyDescription(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, @"[%p]", a1);
  CFStringRef v4 = (const __CFString *)a1[2];
  if (v4) {
    CFStringAppend(Mutable, v4);
  }
  return Mutable;
}

void _VCAudioFrameDelay_CleanupDelayFrames(void *a1)
{
  v3[1] = *(uint64_t **)MEMORY[0x1E4F143B8];
  for (double i = (uint64_t *)a1[12]; i; double i = (uint64_t *)a1[12])
  {
    v3[0] = i;
    _VCAudioFrameDelay_RemoveDelayFrame((uint64_t)a1, i);
    _VCAudioFrameDelay_DeallocateDelayFrame(a1, v3);
  }
}

void _VCAudioFrameDelay_RemoveDelayFrame(uint64_t a1, void *a2)
{
  if (a2)
  {
    CFAllocatorRef v2 = *(void **)(a1 + 96);
    if (v2)
    {
      int v3 = *(void **)(a1 + 96);
      while (v3 != a2)
      {
        int v3 = (void *)*v3;
        if (v3 == v2)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              _VCAudioFrameDelay_RemoveDelayFrame_cold_3();
            }
          }
          return;
        }
      }
      CFStringRef v4 = (void *)*a2;
      if (v2 == a2)
      {
        if (v4 == a2) {
          uint64_t v5 = 0;
        }
        else {
          uint64_t v5 = (void *)*a2;
        }
        *(void *)(a1 + 96) = v5;
      }
      uint64_t v6 = (void *)a2[1];
      void *v6 = v4;
      *(void *)(*a2 + 8) = v6;
      *a2 = a2;
      a2[1] = a2;
      --*(_DWORD *)(a1 + 92);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCAudioFrameDelay_RemoveDelayFrame_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCAudioFrameDelay_RemoveDelayFrame_cold_1();
    }
  }
}

void _VCAudioFrameDelay_DeallocateDelayFrame(const void *a1, uint64_t **a2)
{
  if (a2)
  {
    CFAllocatorRef v2 = *a2;
    if (*a2)
    {
      *a2 = 0;
      CFAllocatorRef v3 = CFGetAllocator(a1);
      CFAllocatorRef v4 = v3;
      uint64_t v5 = (void *)v2[4];
      if (v5)
      {
        CFAllocatorDeallocate(v3, v5);
        v2[4] = 0;
      }
      VCAudioBufferList_Destroy(v2 + 2);
      CFAllocatorDeallocate(v4, v2);
    }
  }
}

uint64_t _VCAudioFrameDelay_AllocateDelayFrame(uint64_t a1, uint64_t **a2)
{
  v10[1] = *(uint64_t **)MEMORY[0x1E4F143B8];
  CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v5 = (uint64_t *)CFAllocatorAllocate(v4, 40, 0);
  v10[0] = v5;
  if (v5)
  {
    uint64_t v6 = v5;
    void v5[2] = 0;
    uint64_t v7 = v5 + 2;
    uint64_t *v5 = (uint64_t)v5;
    v5[1] = (uint64_t)v5;
    *((_WORD *)v5 + 12) = 256;
    unsigned int v8 = CFAllocatorAllocate(v4, *(void *)(a1 + 72), 0);
    v6[4] = (uint64_t)v8;
    if (v8)
    {
      if (VCAudioBufferList_AllocateFrame(a1 + 24, v7))
      {
        VCAudioBufferList_SetSampleCount(v6[2], *(_DWORD *)(a1 + 64));
        uint64_t result = 0;
        *a2 = v6;
        return result;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCAudioFrameDelay_AllocateDelayFrame_cold_3();
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCAudioFrameDelay_AllocateDelayFrame_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCAudioFrameDelay_AllocateDelayFrame_cold_1();
    }
  }
  _VCAudioFrameDelay_DeallocateDelayFrame((const void *)a1, v10);
  return 2152464386;
}

void _VCAudioFrameDelay_InsertDelayFrame(uint64_t a1, void *a2, uint64_t *a3)
{
  if (a2)
  {
    CFAllocatorRef v3 = *(void **)(a1 + 96);
    if (v3)
    {
      CFAllocatorRef v4 = *(void **)(a1 + 96);
      while (v4 != a2)
      {
        CFAllocatorRef v4 = (void *)*v4;
        if (v4 == v3)
        {
          uint64_t v5 = *a3;
          *(void *)(v5 + 8) = a2;
          *a2 = v5;
          *a3 = (uint64_t)a2;
          a2[1] = a3;
          goto LABEL_11;
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCAudioFrameDelay_InsertDelayFrame_cold_2();
        }
      }
    }
    else
    {
      *(void *)(a1 + 96) = a2;
LABEL_11:
      ++*(_DWORD *)(a1 + 92);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCAudioFrameDelay_InsertDelayFrame_cold_1();
    }
  }
}

void sub_1E22809E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t VCMediaStreamSendGroup_UpdateSendSampleRTPTimestamp(uint64_t result, int a2, double a3, double a4)
{
  if (*(unsigned char *)(result + 492))
  {
    uint64_t v7 = result;
    pthread_rwlock_wrlock((pthread_rwlock_t *)(result + 496));
    *(_DWORD *)(v7 + 696) = a2;
    *(double *)(v7 + 704) = a4;
    *(double *)(v7 + 720) = a3;
    *(unsigned char *)(v7 + 712) = 1;
    return pthread_rwlock_unlock((pthread_rwlock_t *)(v7 + 496));
  }
  return result;
}

uint64_t VCMediaStreamSendGroup_ModulateTimestampWithSourceTimestamp(uint64_t a1, double a2, double a3)
{
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 496));
  double v7 = *(double *)(a1 + 720);
  double v8 = *(double *)(a1 + 704);
  LODWORD(v3) = *(_DWORD *)(a1 + 696);
  pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 496));
  return ((double)((double)v3 * a2 / v7) + (a3 - v8) * a2);
}

uint64_t VCSignalErrorAt(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  v17[1] = *(char **)MEMORY[0x1E4F143B8];
  v17[0] = 0;
  vasprintf(v17, a2, &a9);
  uint64_t v10 = v17[0];
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v10)
  {
    if (ErrorLogLevelForModule >= 3)
    {
      uint64_t v12 = VRTraceErrorLogLevelToCSTR();
      __int16 v13 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCSignalErrorAt_cold_2(v12, (uint64_t *)v17, v13);
      }
    }
    free(v17[0]);
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    uint64_t v14 = VRTraceErrorLogLevelToCSTR();
    __int16 v15 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCSignalErrorAt_cold_1(v14, v15);
    }
  }
  return a1;
}

int32x2_t **VCAudioIssueDetector_Create(unsigned int a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  double v8 = 0;
  if (a1 >= 2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioIssueDetector_Create_cold_2();
      }
    }
  }
  else
  {
    CFAllocatorRef v2 = (int32x2_t **)malloc_type_calloc(1uLL, 0x238uLL, 0x10200400ED4710AuLL);
    double v8 = v2;
    if (v2)
    {
      unint64_t v3 = v2;
      CFAllocatorRef v4 = VCAudioIssueDetectorUtil_Create(a1 == 1);
      v3[70] = (int32x2_t *)v4;
      if (v4)
      {
        *(_DWORD *)unint64_t v3 = a1;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v5 = VRTraceErrorLogLevelToCSTR();
          uint64_t v6 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            uint64_t v10 = v5;
            __int16 v11 = 2080;
            uint64_t v12 = "VCAudioIssueDetector_Create";
            __int16 v13 = 1024;
            int v14 = 40;
            __int16 v15 = 2048;
            uint64_t v16 = v3;
            __int16 v17 = 1024;
            unsigned int v18 = a1;
            _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioIssueDetector=%p of type=%d created", buf, 0x2Cu);
          }
        }
        return v3;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCAudioIssueDetector_Create_cold_4();
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioIssueDetector_Create_cold_3();
      }
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioIssueDetector_Create_cold_1();
    }
  }
  VCAudioIssueDetector_Finalize(&v8);
  return v8;
}

void VCAudioIssueDetector_Finalize(int32x2_t ***a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    CFAllocatorRef v2 = *a1;
    if (*a1)
    {
      if (v2[70]) {
        VCAudioIssueDetectorUtil_Finalize(v2 + 70);
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v3 = VRTraceErrorLogLevelToCSTR();
        CFAllocatorRef v4 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v5 = 136315906;
          uint64_t v6 = v3;
          __int16 v7 = 2080;
          double v8 = "VCAudioIssueDetector_Finalize";
          __int16 v9 = 1024;
          int v10 = 57;
          __int16 v11 = 2048;
          uint64_t v12 = v2;
          _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioIssueDetector=%p finalized", (uint8_t *)&v5, 0x26u);
        }
      }
      free(v2);
      *a1 = 0;
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioIssueDetector_Finalize_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioIssueDetector_Finalize_cold_1();
    }
  }
}

void VCAudioIssueDetector_Configure(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      uint64_t v6 = *MEMORY[0x1E4F47A50];
      __int16 v7 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = 136315906;
          uint64_t v9 = v5;
          __int16 v10 = 2080;
          __int16 v11 = "VCAudioIssueDetector_Configure";
          __int16 v12 = 1024;
          int v13 = 66;
          __int16 v14 = 2048;
          uint64_t v15 = a1;
          _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioIssueDetector=%p configured", (uint8_t *)&v8, 0x26u);
        }
      }
      else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        VCAudioIssueDetector_Configure_cold_2();
      }
    }
    VCAudioIssueDetectorUtil_Configure(*(void *)(a1 + 560), a2);
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioIssueDetector_Configure_cold_1();
    }
  }
}

void VCAudioIssueDetector_UpdateConnectionType(uint64_t a1, int a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      uint64_t v6 = *MEMORY[0x1E4F47A50];
      __int16 v7 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = 136315906;
          uint64_t v9 = v5;
          __int16 v10 = 2080;
          __int16 v11 = "VCAudioIssueDetector_UpdateConnectionType";
          __int16 v12 = 1024;
          int v13 = 74;
          __int16 v14 = 2048;
          uint64_t v15 = a1;
          _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioIssueDetector=%p link type updated", (uint8_t *)&v8, 0x26u);
        }
      }
      else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        VCAudioIssueDetector_UpdateConnectionType_cold_2();
      }
    }
    VCAudioIssueDetectorUtil_UpdateRATType(*(void *)(a1 + 560), a2);
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioIssueDetector_UpdateConnectionType_cold_1();
    }
  }
}

void VCAudioIssueDetector_ProcessCellularNetworkNotification(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      uint64_t v6 = *MEMORY[0x1E4F47A50];
      __int16 v7 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = 136315906;
          uint64_t v9 = v5;
          __int16 v10 = 2080;
          __int16 v11 = "VCAudioIssueDetector_ProcessCellularNetworkNotification";
          __int16 v12 = 1024;
          int v13 = 82;
          __int16 v14 = 2048;
          uint64_t v15 = a1;
          _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioIssueDetector=%p NW notification received", (uint8_t *)&v8, 0x26u);
        }
      }
      else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        VCAudioIssueDetector_ProcessCellularNetworkNotification_cold_2();
      }
    }
    VCAudioIssueDetectorUtil_ProcessCellularNetworkNotification(*(void *)(a1 + 560), a2);
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioIssueDetector_ProcessCellularNetworkNotification_cold_1();
    }
  }
}

void VCAudioIssueDetector_Start(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      uint64_t v3 = VRTraceErrorLogLevelToCSTR();
      CFAllocatorRef v4 = *MEMORY[0x1E4F47A50];
      uint64_t v5 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          int v6 = 136315906;
          uint64_t v7 = v3;
          __int16 v8 = 2080;
          uint64_t v9 = "VCAudioIssueDetector_Start";
          __int16 v10 = 1024;
          int v11 = 90;
          __int16 v12 = 2048;
          uint64_t v13 = a1;
          _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioIssueDetector=%p started", (uint8_t *)&v6, 0x26u);
        }
      }
      else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        VCAudioIssueDetector_Start_cold_2();
      }
    }
    VCAudioIssueDetectorUtil_Start(*(int32x2_t **)(a1 + 560));
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioIssueDetector_Start_cold_1();
    }
  }
}

void VCAudioIssueDetector_Stop(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      uint64_t v3 = VRTraceErrorLogLevelToCSTR();
      CFAllocatorRef v4 = *MEMORY[0x1E4F47A50];
      uint64_t v5 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          int v6 = 136315906;
          uint64_t v7 = v3;
          __int16 v8 = 2080;
          uint64_t v9 = "VCAudioIssueDetector_Stop";
          __int16 v10 = 1024;
          int v11 = 98;
          __int16 v12 = 2048;
          uint64_t v13 = a1;
          _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioIssueDetector=%p stopped", (uint8_t *)&v6, 0x26u);
        }
      }
      else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        VCAudioIssueDetector_Stop_cold_2();
      }
    }
    VCAudioIssueDetectorUtil_Stop(*(int32x2_t **)(a1 + 560));
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioIssueDetector_Stop_cold_1();
    }
  }
}

void VCAudioIssueDetector_ProcessFrame(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    CFAllocatorRef v4 = *(int32x2_t **)(a1 + 560);
    VCAudioIssueDetectorUtil_ProcessFrame(v4, a2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v5 = VRTraceErrorLogLevelToCSTR();
    int v6 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
    {
      int v7 = 136316162;
      uint64_t v8 = v5;
      __int16 v9 = 2080;
      __int16 v10 = "VCAudioIssueDetector_ProcessFrame";
      __int16 v11 = 1024;
      int v12 = 121;
      __int16 v13 = 2048;
      uint64_t v14 = a1;
      __int16 v15 = 2048;
      uint64_t v16 = a2;
      _os_log_error_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid parameter issueDetector=%p frameInfo=%p", (uint8_t *)&v7, 0x30u);
    }
  }
}

void VCAudioIssueDetector_ReportRTPTraffic(uint64_t a1)
{
  if (a1)
  {
    *(unsigned char *)(a1 + 556) = 1;
    uint64_t v1 = *(void *)(a1 + 560);
    VCAudioIssueDetectorUtil_RtpPacketIndication(v1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioIssueDetector_ReportRTPTraffic_cold_1();
    }
  }
}

void VCAudioIssueDetector_ReportRTCPTraffic(uint64_t a1)
{
  if (a1)
  {
    *(unsigned char *)(a1 + 557) = 1;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioIssueDetector_ReportRTCPTraffic_cold_1();
    }
  }
}

void VCAudioIssueDetector_GetReportingStats(int *a1, unsigned char *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    if (!*((unsigned char *)a1 + 556))
    {
      *a2 = 1;
      VCAudioIssueDetectorUtil_RtpPacketTimeoutIndication(*((void *)a1 + 70));
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v4 = VRTraceErrorLogLevelToCSTR();
        uint64_t v5 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v6 = *a1;
          int v12 = 136316162;
          uint64_t v13 = v4;
          __int16 v14 = 2080;
          __int16 v15 = "VCAudioIssueDetector_GetReportingStats";
          __int16 v16 = 1024;
          int v17 = 147;
          __int16 v18 = 2048;
          uint64_t v19 = a1;
          __int16 v20 = 1024;
          LODWORD(v21) = v6;
          _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Rtp inactivity detected in audio issue detector=%p, direction=%d", (uint8_t *)&v12, 0x2Cu);
        }
      }
    }
    *((unsigned char *)a1 + 556) = 0;
    if (!*((unsigned char *)a1 + 557))
    {
      a2[1] = 1;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v7 = VRTraceErrorLogLevelToCSTR();
        uint64_t v8 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v9 = *a1;
          int v12 = 136316162;
          uint64_t v13 = v7;
          __int16 v14 = 2080;
          __int16 v15 = "VCAudioIssueDetector_GetReportingStats";
          __int16 v16 = 1024;
          int v17 = 152;
          __int16 v18 = 2048;
          uint64_t v19 = a1;
          __int16 v20 = 1024;
          LODWORD(v21) = v9;
          _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Rtcp inactivity detected in audio issue detector=%p, direction=%d", (uint8_t *)&v12, 0x2Cu);
        }
      }
    }
    *((unsigned char *)a1 + 557) = 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v10 = VRTraceErrorLogLevelToCSTR();
    __int16 v11 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
    {
      int v12 = 136316162;
      uint64_t v13 = v10;
      __int16 v14 = 2080;
      __int16 v15 = "VCAudioIssueDetector_GetReportingStats";
      __int16 v16 = 1024;
      int v17 = 143;
      __int16 v18 = 2048;
      uint64_t v19 = a1;
      __int16 v20 = 2048;
      uint64_t v21 = a2;
      _os_log_error_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid parameter issueDetector=%p reportingStats=%p", (uint8_t *)&v12, 0x30u);
    }
  }
}

void VCAudioIssueDetector_FlushLogEvents(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 560);
    VCAudioIssueDetectorUtil_FlushLogEvents(v1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioIssueDetector_FlushLogEvents_cold_1();
    }
  }
}

uint64_t VCMediaNegotiationBlobV2CameraSettingsU1ReadFrom(unsigned char *a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = &OBJC_IVAR___VCEmulatedNetworkAlgorithmQueueLoss__currentIndexForLossRate;
  uint64_t v8 = &OBJC_IVAR___VCEmulatedNetworkAlgorithmQueueLoss__currentIndexForLossRate;
  int v9 = (int *)MEMORY[0x1E4F940B8];
  uint64_t v10 = &OBJC_IVAR___VCEmulatedNetworkAlgorithmQueueLoss__currentIndexForLossRate;
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v11 = 0;
    unsigned int v12 = 0;
    unint64_t v13 = 0;
    while (1)
    {
      uint64_t v14 = *v3;
      unint64_t v15 = *(void *)(a2 + v14);
      if (v15 == -1 || v15 >= *(void *)(a2 + *v4)) {
        break;
      }
      char v16 = *(unsigned char *)(*(void *)(a2 + *v9) + v15);
      *(void *)(a2 + v14) = v15 + 1;
      v13 |= (unint64_t)(v16 & 0x7F) << v11;
      if ((v16 & 0x80) == 0) {
        goto LABEL_12;
      }
      v11 += 7;
      BOOL v17 = v12++ >= 9;
      if (v17)
      {
        unint64_t v13 = 0;
        int v18 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v18 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v13 = 0;
    }
LABEL_14:
    if (v18 || (v13 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v13 >> 3))
    {
      case 1u:
        char v20 = 0;
        unsigned int v21 = 0;
        uint64_t v22 = 0;
        a1[v7[413]] |= 0x80u;
        while (1)
        {
          uint64_t v23 = *v3;
          unint64_t v24 = *(void *)(a2 + v23);
          if (v24 == -1 || v24 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v25 = *(unsigned char *)(*(void *)(a2 + *v9) + v24);
          *(void *)(a2 + v23) = v24 + 1;
          v22 |= (unint64_t)(v25 & 0x7F) << v20;
          if ((v25 & 0x80) == 0) {
            goto LABEL_81;
          }
          v20 += 7;
          BOOL v17 = v21++ >= 9;
          if (v17)
          {
            LODWORD(v22) = 0;
            goto LABEL_83;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_81:
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v22) = 0;
        }
LABEL_83:
        uint64_t v66 = v8[414];
        goto LABEL_112;
      case 2u:
        int v27 = v7;
        uint64_t v28 = v10;
        __int16 v29 = v8;
        int v30 = objc_alloc_init(VCMediaNegotiationBlobV2VideoPayload);
        [a1 addPayloads:v30];

        if (PBReaderPlaceMark()
          && (VCMediaNegotiationBlobV2VideoPayloadReadFrom((uint64_t)v30, a2) & 1) != 0)
        {
          PBReaderRecallMark();
          uint64_t v8 = v29;
          uint64_t v10 = v28;
          uint64_t v7 = v27;
LABEL_113:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
        return 0;
      case 3u:
        char v31 = 0;
        unsigned int v32 = 0;
        uint64_t v22 = 0;
        a1[v7[413]] |= 2u;
        while (2)
        {
          uint64_t v33 = *v3;
          unint64_t v34 = *(void *)(a2 + v33);
          if (v34 == -1 || v34 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v35 = *(unsigned char *)(*(void *)(a2 + *v9) + v34);
            *(void *)(a2 + v33) = v34 + 1;
            v22 |= (unint64_t)(v35 & 0x7F) << v31;
            if (v35 < 0)
            {
              v31 += 7;
              BOOL v17 = v32++ >= 9;
              if (v17)
              {
                LODWORD(v22) = 0;
                goto LABEL_87;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v22) = 0;
        }
LABEL_87:
        uint64_t v66 = v10[416];
        goto LABEL_112;
      case 4u:
        char v36 = 0;
        unsigned int v37 = 0;
        uint64_t v22 = 0;
        a1[v7[413]] |= 4u;
        while (2)
        {
          uint64_t v38 = *v3;
          unint64_t v39 = *(void *)(a2 + v38);
          if (v39 == -1 || v39 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v40 = *(unsigned char *)(*(void *)(a2 + *v9) + v39);
            *(void *)(a2 + v38) = v39 + 1;
            v22 |= (unint64_t)(v40 & 0x7F) << v36;
            if (v40 < 0)
            {
              v36 += 7;
              BOOL v17 = v37++ >= 9;
              if (v17)
              {
                LODWORD(v22) = 0;
                goto LABEL_91;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v22) = 0;
        }
LABEL_91:
        uint64_t v66 = 16;
        goto LABEL_112;
      case 5u:
        char v41 = 0;
        unsigned int v42 = 0;
        uint64_t v22 = 0;
        a1[v7[413]] |= 0x20u;
        while (2)
        {
          uint64_t v43 = *v3;
          unint64_t v44 = *(void *)(a2 + v43);
          if (v44 == -1 || v44 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v45 = *(unsigned char *)(*(void *)(a2 + *v9) + v44);
            *(void *)(a2 + v43) = v44 + 1;
            v22 |= (unint64_t)(v45 & 0x7F) << v41;
            if (v45 < 0)
            {
              v41 += 7;
              BOOL v17 = v42++ >= 9;
              if (v17)
              {
                LODWORD(v22) = 0;
                goto LABEL_95;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v22) = 0;
        }
LABEL_95:
        uint64_t v66 = 40;
        goto LABEL_112;
      case 6u:
        char v46 = 0;
        unsigned int v47 = 0;
        uint64_t v22 = 0;
        a1[v7[413]] |= 0x40u;
        while (2)
        {
          uint64_t v48 = *v3;
          unint64_t v49 = *(void *)(a2 + v48);
          if (v49 == -1 || v49 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v50 = *(unsigned char *)(*(void *)(a2 + *v9) + v49);
            *(void *)(a2 + v48) = v49 + 1;
            v22 |= (unint64_t)(v50 & 0x7F) << v46;
            if (v50 < 0)
            {
              v46 += 7;
              BOOL v17 = v47++ >= 9;
              if (v17)
              {
                LODWORD(v22) = 0;
                goto LABEL_99;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v22) = 0;
        }
LABEL_99:
        uint64_t v66 = 44;
        goto LABEL_112;
      case 7u:
        char v51 = 0;
        unsigned int v52 = 0;
        uint64_t v22 = 0;
        a1[v7[413]] |= 8u;
        while (2)
        {
          uint64_t v53 = *v3;
          unint64_t v54 = *(void *)(a2 + v53);
          if (v54 == -1 || v54 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v55 = *(unsigned char *)(*(void *)(a2 + *v9) + v54);
            *(void *)(a2 + v53) = v54 + 1;
            v22 |= (unint64_t)(v55 & 0x7F) << v51;
            if (v55 < 0)
            {
              v51 += 7;
              BOOL v17 = v52++ >= 9;
              if (v17)
              {
                LODWORD(v22) = 0;
                goto LABEL_103;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v22) = 0;
        }
LABEL_103:
        uint64_t v66 = 20;
        goto LABEL_112;
      case 8u:
        char v56 = 0;
        unsigned int v57 = 0;
        uint64_t v22 = 0;
        a1[v7[413]] |= 0x10u;
        while (2)
        {
          uint64_t v58 = *v3;
          unint64_t v59 = *(void *)(a2 + v58);
          if (v59 == -1 || v59 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v60 = *(unsigned char *)(*(void *)(a2 + *v9) + v59);
            *(void *)(a2 + v58) = v59 + 1;
            v22 |= (unint64_t)(v60 & 0x7F) << v56;
            if (v60 < 0)
            {
              v56 += 7;
              BOOL v17 = v57++ >= 9;
              if (v17)
              {
                LODWORD(v22) = 0;
                goto LABEL_107;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v22) = 0;
        }
LABEL_107:
        uint64_t v66 = 24;
        goto LABEL_112;
      case 9u:
        char v61 = 0;
        unsigned int v62 = 0;
        uint64_t v22 = 0;
        a1[v7[413]] |= 1u;
        while (2)
        {
          uint64_t v63 = *v3;
          unint64_t v64 = *(void *)(a2 + v63);
          if (v64 == -1 || v64 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v65 = *(unsigned char *)(*(void *)(a2 + *v9) + v64);
            *(void *)(a2 + v63) = v64 + 1;
            v22 |= (unint64_t)(v65 & 0x7F) << v61;
            if (v65 < 0)
            {
              v61 += 7;
              BOOL v17 = v62++ >= 9;
              if (v17)
              {
                LODWORD(v22) = 0;
                goto LABEL_111;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v22) = 0;
        }
LABEL_111:
        uint64_t v66 = 8;
LABEL_112:
        *(_DWORD *)&a1[v66] = v22;
        goto LABEL_113;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_113;
    }
  }
}

uint64_t OUTLINED_FUNCTION_8_14@<X0>(char *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(unsigned int *)&a1[a2];
  return [a1 stateStringForState:v3];
}

uint64_t VCMediaNegotiationBlobVideoPayloadSettingsReadFrom(id *a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      unint64_t v12 = *(void *)(a2 + v11);
      if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
        break;
      }
      char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v14 = v9++ >= 9;
      if (v14)
      {
        unint64_t v10 = 0;
        int v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v15 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0;
        while (1)
        {
          uint64_t v20 = *v3;
          unint64_t v21 = *(void *)(a2 + v20);
          if (v21 == -1 || v21 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v22 = *(unsigned char *)(*(void *)(a2 + *v7) + v21);
          *(void *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0) {
            goto LABEL_40;
          }
          v17 += 7;
          BOOL v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_42;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_40:
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v19) = 0;
        }
LABEL_42:
        uint64_t v31 = 20;
        goto LABEL_47;
      case 2u:
        unint64_t v24 = objc_alloc_init(VCMediaNegotiationBlobVideoRuleCollection);
        [a1 addVideoRuleCollections:v24];

        if (PBReaderPlaceMark() && VCMediaNegotiationBlobVideoRuleCollectionReadFrom((uint64_t)v24, a2))
        {
          PBReaderRecallMark();
LABEL_48:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
        return 0;
      case 3u:
        String = (void *)PBReaderReadString();

        a1[1] = String;
        goto LABEL_48;
      case 4u:
        char v26 = 0;
        unsigned int v27 = 0;
        uint64_t v19 = 0;
        while (2)
        {
          uint64_t v28 = *v3;
          unint64_t v29 = *(void *)(a2 + v28);
          if (v29 == -1 || v29 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v30 = *(unsigned char *)(*(void *)(a2 + *v7) + v29);
            *(void *)(a2 + v28) = v29 + 1;
            v19 |= (unint64_t)(v30 & 0x7F) << v26;
            if (v30 < 0)
            {
              v26 += 7;
              BOOL v14 = v27++ >= 9;
              if (v14)
              {
                LODWORD(v19) = 0;
                goto LABEL_46;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v19) = 0;
        }
LABEL_46:
        uint64_t v31 = 16;
LABEL_47:
        *(_DWORD *)((char *)a1 + v31) = v19;
        goto LABEL_48;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_48;
    }
  }
}

void sub_1E2286BE4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_9_9(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

void OUTLINED_FUNCTION_10_10(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0x26u);
}

void sub_1E2289390(_Unwind_Exception *exception_object)
{
}

uint64_t VCSecurityKeyManager_CopyMKMWithPrefixForParticipant(void *a1, const char *a2, uint64_t a3)
{
  return [a1 copyMKMWithPrefix:a2 forParticipantID:a3];
}

id VCSecurityKeyManager_CopyLatestSendKeyMaterial(void *a1, uint64_t a2)
{
  uint64_t v2 = [a1 latestSendKeyMaterialWithSecurityKeyMode:a2];
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  id v4 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  [v4 addObject:v3];
  return v4;
}

uint64_t VCSecurityKeyManager_AssociateKeyIndex(void *a1, const char *a2, uint64_t a3)
{
  return [a1 associateMKI:a2 withParticipantID:a3];
}

BOOL VCMediaNegotiationBlobV2BandwidthSettingsReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          char v17 = 0;
          unsigned int v18 = 0;
          uint64_t v19 = 0;
          *(unsigned char *)(a1 + 28) |= 1u;
          while (1)
          {
            uint64_t v20 = *v3;
            unint64_t v21 = *(void *)(a2 + v20);
            if (v21 == -1 || v21 >= *(void *)(a2 + *v4))
            {
              unint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap2G;
              goto LABEL_61;
            }
            char v22 = *(unsigned char *)(*(void *)(a2 + *v7) + v21);
            *(void *)(a2 + v20) = v21 + 1;
            v19 |= (unint64_t)(v22 & 0x7F) << v17;
            if ((v22 & 0x80) == 0) {
              break;
            }
            v17 += 7;
            BOOL v23 = v18++ > 8;
            if (v23)
            {
              LODWORD(v19) = 0;
              unint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap2G;
              goto LABEL_64;
            }
          }
          unint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap2G;
          goto LABEL_62;
        case 2u:
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v19 = 0;
          *(unsigned char *)(a1 + 28) |= 2u;
          while (2)
          {
            uint64_t v27 = *v3;
            unint64_t v28 = *(void *)(a2 + v27);
            if (v28 == -1 || v28 >= *(void *)(a2 + *v4))
            {
              unint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap3G;
              goto LABEL_61;
            }
            char v29 = *(unsigned char *)(*(void *)(a2 + *v7) + v28);
            *(void *)(a2 + v27) = v28 + 1;
            v19 |= (unint64_t)(v29 & 0x7F) << v25;
            if (v29 < 0)
            {
              v25 += 7;
              BOOL v23 = v26++ > 8;
              if (v23)
              {
                LODWORD(v19) = 0;
                unint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap3G;
                goto LABEL_64;
              }
              continue;
            }
            break;
          }
          unint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap3G;
          goto LABEL_62;
        case 3u:
          char v30 = 0;
          unsigned int v31 = 0;
          uint64_t v19 = 0;
          *(unsigned char *)(a1 + 28) |= 8u;
          while (2)
          {
            uint64_t v32 = *v3;
            unint64_t v33 = *(void *)(a2 + v32);
            if (v33 == -1 || v33 >= *(void *)(a2 + *v4))
            {
              unint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__capLTE;
              goto LABEL_61;
            }
            char v34 = *(unsigned char *)(*(void *)(a2 + *v7) + v33);
            *(void *)(a2 + v32) = v33 + 1;
            v19 |= (unint64_t)(v34 & 0x7F) << v30;
            if (v34 < 0)
            {
              v30 += 7;
              BOOL v23 = v31++ > 8;
              if (v23)
              {
                LODWORD(v19) = 0;
                unint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__capLTE;
                goto LABEL_64;
              }
              continue;
            }
            break;
          }
          unint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__capLTE;
          goto LABEL_62;
        case 4u:
          char v35 = 0;
          unsigned int v36 = 0;
          uint64_t v19 = 0;
          *(unsigned char *)(a1 + 28) |= 4u;
          while (2)
          {
            uint64_t v37 = *v3;
            unint64_t v38 = *(void *)(a2 + v37);
            if (v38 == -1 || v38 >= *(void *)(a2 + *v4))
            {
              unint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap5G;
              goto LABEL_61;
            }
            char v39 = *(unsigned char *)(*(void *)(a2 + *v7) + v38);
            *(void *)(a2 + v37) = v38 + 1;
            v19 |= (unint64_t)(v39 & 0x7F) << v35;
            if (v39 < 0)
            {
              v35 += 7;
              BOOL v23 = v36++ > 8;
              if (v23)
              {
                LODWORD(v19) = 0;
                unint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap5G;
                goto LABEL_64;
              }
              continue;
            }
            break;
          }
          unint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap5G;
          goto LABEL_62;
        case 5u:
          char v40 = 0;
          unsigned int v41 = 0;
          uint64_t v19 = 0;
          *(unsigned char *)(a1 + 28) |= 0x10u;
          break;
        default:
          if (PBReaderSkipValueWithTag()) {
            continue;
          }
          return 0;
      }
      while (1)
      {
        uint64_t v42 = *v3;
        unint64_t v43 = *(void *)(a2 + v42);
        if (v43 == -1 || v43 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v44 = *(unsigned char *)(*(void *)(a2 + *v7) + v43);
        *(void *)(a2 + v42) = v43 + 1;
        v19 |= (unint64_t)(v44 & 0x7F) << v40;
        if ((v44 & 0x80) == 0)
        {
          unint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__capWifi;
          goto LABEL_62;
        }
        v40 += 7;
        BOOL v23 = v41++ > 8;
        if (v23)
        {
          LODWORD(v19) = 0;
          unint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__capWifi;
          goto LABEL_64;
        }
      }
      unint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__capWifi;
LABEL_61:
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_62:
      if (*(unsigned char *)(a2 + *v5)) {
        LODWORD(v19) = 0;
      }
LABEL_64:
      *(_DWORD *)(a1 + *v24) = v19;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1E2293F54(_Unwind_Exception *a1)
{
}

void sub_1E2295938(_Unwind_Exception *a1)
{
}

void sub_1E229D0AC()
{
}

uint64_t OUTLINED_FUNCTION_12_6@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)(v2 - 24) = a2;
  return a1;
}

BOOL VCVideoCaptureConverter_ProcessFrame(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (!*(unsigned char *)(a1 + 32)
      || (unsigned int v8 = *(_DWORD *)(a1 + 24),
          int v9 = *(_DWORD *)(a1 + 28),
          double v10 = (double)v8 / *(double *)(a1 + 16),
          *(_DWORD *)(a1 + 24) = v8 + 1,
          *(_DWORD *)(a1 + 28) = v10,
          v9 != v10))
    {
      uint64_t v11 = (const void *)MEMORY[0x1E4E56580](a1 + 40);
      unint64_t v12 = *(void (**)(const void *, uint64_t, long long *, uint64_t))(a1 + 48);
      long long v14 = *a3;
      uint64_t v15 = *((void *)a3 + 2);
      v12(v11, a2, &v14, a4);
      if (v11) {
        CFRelease(v11);
      }
    }
  }
  return a1 != 0;
}

void VCConnectionHealthMonitor_UpdateReceiveStats(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  double v2 = micro();
  if (a1)
  {
    double v3 = v2;
    pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 304));
    if (v3 - *(double *)(a1 + 512) > 1.0)
    {
      _VCConnectionHealthMonitor_UpdateStatsHistory((unsigned char *)a1);
      *(unsigned char *)(a1 + 507) = *(unsigned char *)(a1 + 507)
                           + 1
                           - 120 * ((547 * (*(unsigned __int8 *)(a1 + 507) + 1)) >> 16);
      int v4 = *(unsigned __int8 *)(a1 + 520);
      *(unsigned char *)(a1 + 504) = v4;
      *(_WORD *)(a1 + 505) = *(_WORD *)(a1 + 521);
      *(unsigned char *)(a1 + 520) = 0;
      *(_WORD *)(a1 + 521) = 0;
      *(double *)(a1 + 512) = v3;
      if (!*(unsigned char *)(a1 + 288))
      {
        if (*(unsigned char *)(a1 + 536))
        {
          double v5 = *(double *)(a1 + 296);
          if (v4)
          {
            if (v5 != 0.0)
            {
              if (v3 - v5 >= 8.0)
              {
                int v6 = *(NSObject **)(a1 + 280);
                if (v6)
                {
                  *(void *)int v9 = MEMORY[0x1E4F143A8];
                  *(void *)&v9[8] = 3221225472;
                  *(void *)&v9[16] = ___VCConnectionHealthMonitor_checkAndReportSymptomOnRecoveryAfterLongMediaStall_block_invoke;
                  double v10 = &unk_1E6DB3DC8;
                  uint64_t v11 = a1;
                  dispatch_async(v6, v9);
                }
                *(unsigned char *)(a1 + 288) = 1;
              }
              else
              {
                *(void *)(a1 + 296) = 0;
              }
            }
          }
          else if (v5 == 0.0)
          {
            *(double *)(a1 + 296) = v3;
          }
        }
      }
    }
    pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 304));
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    uint64_t v7 = VRTraceErrorLogLevelToCSTR();
    unsigned int v8 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int v9 = 136315650;
      *(void *)&void v9[4] = v7;
      *(_WORD *)&v9[12] = 2080;
      *(void *)&v9[14] = "VCConnectionHealthMonitor_UpdateReceiveStats";
      *(_WORD *)&v9[22] = 1024;
      LODWORD(v10) = 93;
      _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", v9, 0x1Cu);
    }
  }
}

void _VCConnectionHealthMonitor_UpdateStatsHistory(unsigned char *a1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (uint64_t)(a1 + 9);
  unsigned int v2 = a1[507];
  if (a1[9] != v2)
  {
    a1[9] = v2;
    uint64_t v4 = (v2 - 5 * ((858993460 * (unint64_t)v2) >> 32));
    double v5 = a1 + 10;
    a1[v4 + 10] = a1[504];
    int v6 = a1 + 15;
    a1[v4 + 15] = a1[505];
    uint64_t v7 = a1 + 20;
    a1[v4 + 20] = a1[506];
    _VCConnectionHealthMonitor_UpdateRatiosForHistory((uint64_t)(a1 + 9), v2 - 5 * ((858993460 * (unint64_t)v2) >> 32));
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      uint64_t v8 = VRTraceErrorLogLevelToCSTR();
      int v9 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v10 = a1[9];
        int v11 = v6[v4];
        int v12 = v7[v4];
        int v13 = v5[v4];
        int v14 = a1[v4 + 25];
        int v15 = a1[v4 + 30];
        int v16 = 136317442;
        uint64_t v17 = v8;
        __int16 v18 = 2080;
        uint64_t v19 = "_VCConnectionHealthMonitor_UpdateStatsHistory";
        __int16 v20 = 1024;
        int v21 = 238;
        __int16 v22 = 1024;
        int v23 = v4;
        __int16 v24 = 1024;
        int v25 = v10;
        __int16 v26 = 1024;
        int v27 = v11;
        __int16 v28 = 1024;
        int v29 = v12;
        __int16 v30 = 1024;
        int v31 = v13;
        __int16 v32 = 1024;
        int v33 = v14;
        __int16 v34 = 1024;
        int v35 = v15;
        _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: send - last received packet with index %d, %u, bucket [%u %u %u] ratios [%u %u]", (uint8_t *)&v16, 0x46u);
      }
    }
    VCConnectionHealthMonitor_ReportConnectionHealthWithStatsHistory((uint64_t)a1, v1, v4, 0);
  }
}

uint64_t _VCConnectionHealthMonitor_UpdateRatiosForHistory(uint64_t result, int a2)
{
  unsigned int v2 = 0;
  for (uint64_t i = 1; i != 6; ++i)
    v2 += *(unsigned __int8 *)(result + i);
  uint64_t v4 = 0;
  char v5 = 1;
  do
  {
    uint64_t v6 = 0;
    int v7 = 0;
    char v8 = v5;
    do
      v7 += *(unsigned __int8 *)(result + 6 + 5 * v4 + v6++);
    while (v6 != 5);
    if (v2) {
      unsigned int v9 = 100 * v7 / v2;
    }
    else {
      LOBYTE(v9) = 0;
    }
    char v5 = 0;
    *(unsigned char *)(result + a2 + 5 * v4 + 16) = v9;
    uint64_t v4 = 1;
  }
  while ((v8 & 1) != 0);
  return result;
}

void VCConnectionHealthMonitor_ReportConnectionHealthWithStatsHistory(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
      return;
    }
    uint64_t v9 = VRTraceErrorLogLevelToCSTR();
    int v10 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)buf = 136315650;
    uint64_t v17 = v9;
    __int16 v18 = 2080;
    uint64_t v19 = "VCConnectionHealthMonitor_ReportConnectionHealthWithStatsHistory";
    __int16 v20 = 1024;
    int v21 = 253;
    int v11 = " [%s] %s:%d nil instance passed";
LABEL_22:
    _os_log_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEFAULT, v11, buf, 0x1Cu);
    return;
  }
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
      return;
    }
    uint64_t v12 = VRTraceErrorLogLevelToCSTR();
    int v10 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)buf = 136315650;
    uint64_t v17 = v12;
    __int16 v18 = 2080;
    uint64_t v19 = "VCConnectionHealthMonitor_ReportConnectionHealthWithStatsHistory";
    __int16 v20 = 1024;
    int v21 = 254;
    int v11 = " [%s] %s:%d nil statsHistory passed";
    goto LABEL_22;
  }
  char v4 = a4;
  if (*(unsigned char *)(a2 + a3 + 1) || !*(unsigned char *)(a1 + 536))
  {
    if (*(unsigned char *)(a2 + a3 + 6))
    {
      uint64_t v6 = 240;
      if (a4) {
        uint64_t v6 = 9;
      }
      if (VCConnectionHealthMonitor_IsPrimaryConnectionImprovedFromHistory(a1, a2, a3, a1 + v6)) {
        int v7 = 3;
      }
      else {
        int v7 = 0;
      }
    }
    else
    {
      int v7 = 2;
    }
  }
  else
  {
    int v7 = 1;
  }
  char v8 = *(NSObject **)(a1 + 280);
  if (v8)
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __VCConnectionHealthMonitor_ReportConnectionHealthWithStatsHistory_block_invoke;
    void v13[3] = &unk_1E6DB76B0;
    v13[4] = a1;
    int v14 = v7;
    char v15 = v4;
    dispatch_async(v8, v13);
  }
}

BOOL VCConnectionHealthMonitor_IsPrimaryConnectionImprovedFromHistory(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
      return 0;
    }
    uint64_t v15 = VRTraceErrorLogLevelToCSTR();
    int v16 = *MEMORY[0x1E4F47A50];
    BOOL v17 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v17) {
      return result;
    }
    int v23 = 136315650;
    uint64_t v24 = v15;
    __int16 v25 = 2080;
    __int16 v26 = "VCConnectionHealthMonitor_IsPrimaryConnectionImprovedFromHistory";
    __int16 v27 = 1024;
    int v28 = 320;
    __int16 v18 = " [%s] %s:%d nil instance passed";
LABEL_32:
    _os_log_impl(&dword_1E1EA4000, v16, OS_LOG_TYPE_DEFAULT, v18, (uint8_t *)&v23, 0x1Cu);
    return 0;
  }
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
      return 0;
    }
    uint64_t v19 = VRTraceErrorLogLevelToCSTR();
    int v16 = *MEMORY[0x1E4F47A50];
    BOOL v20 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v20) {
      return result;
    }
    int v23 = 136315650;
    uint64_t v24 = v19;
    __int16 v25 = 2080;
    __int16 v26 = "VCConnectionHealthMonitor_IsPrimaryConnectionImprovedFromHistory";
    __int16 v27 = 1024;
    int v28 = 321;
    __int16 v18 = " [%s] %s:%d nil statsHistory passed";
    goto LABEL_32;
  }
  if (!a4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v21 = VRTraceErrorLogLevelToCSTR();
      int v16 = *MEMORY[0x1E4F47A50];
      BOOL v22 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
      BOOL result = 0;
      if (!v22) {
        return result;
      }
      int v23 = 136315650;
      uint64_t v24 = v21;
      __int16 v25 = 2080;
      __int16 v26 = "VCConnectionHealthMonitor_IsPrimaryConnectionImprovedFromHistory";
      __int16 v27 = 1024;
      int v28 = 322;
      __int16 v18 = " [%s] %s:%d nil statsHistory passed";
      goto LABEL_32;
    }
    return 0;
  }
  uint64_t v4 = a2 + 16;
  unsigned __int8 v5 = *(unsigned char *)(a2 + 16 + (a3 + 1) % 5);
  int v6 = a3 + 2;
  do
  {
    unsigned __int8 v7 = *(unsigned char *)(v4 + v6 % 5);
    unsigned int v8 = (v5 - 1);
    BOOL v9 = v8 < v7 && v6++ < a3 + 5;
    unsigned __int8 v5 = v7;
  }
  while (v9);
  if (v8 >= v7 || *(unsigned __int8 *)(v4 + a3) < 0x32u || !*(unsigned char *)(a2 + 6)) {
    return 0;
  }
  uint64_t v10 = 0;
  while (v10 != 4)
  {
    if (!*(unsigned __int8 *)(a2 + 7 + v10++))
    {
      if ((unint64_t)(v10 - 1) < 4) {
        return 0;
      }
      break;
    }
  }
  if (*(unsigned char *)(a1 + 552)) {
    return 1;
  }
  if (!*(unsigned char *)(a4 + 6)) {
    return 0;
  }
  unint64_t v13 = 0;
  do
  {
    unint64_t v14 = v13;
    if (v13 == 4) {
      break;
    }
    ++v13;
  }
  while (*(unsigned char *)(a4 + 7 + v14));
  return v14 > 3;
}

void VCConnectionHealthMonitor_ReceivePacket(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  double v8 = micro();
  if (!a4 || a2)
  {
    pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 304));
    if (*(unsigned char *)(a1 + 536)) {
      BOOL v9 = 1;
    }
    else {
      BOOL v9 = a2 == 0;
    }
    if (!v9)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v10 = VRTraceErrorLogLevelToCSTR();
        int v11 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v18 = 136315650;
          uint64_t v19 = v10;
          __int16 v20 = 2080;
          uint64_t v21 = "VCConnectionHealthMonitor_ReceivePacket";
          __int16 v22 = 1024;
          int v23 = 381;
          _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d First packet received", (uint8_t *)&v18, 0x1Cu);
        }
      }
      *(unsigned char *)(a1 + 536) = 1;
    }
    double v12 = *(double *)(a1 + 544);
    uint64_t v13 = 504;
    if (v8 > *(double *)(a1 + 512) + 1.0 - v12) {
      uint64_t v13 = 520;
    }
    unint64_t v14 = (unsigned char *)(a1 + v13);
    if (a4)
    {
      char v15 = v14[2];
      if (v15)
      {
        uint64_t v16 = a3 & 0x3FF;
        if (*(unsigned __int16 *)(a1 + 560 + 16 * v16) == a3 && v8 - *(double *)(a1 + 560 + 16 * v16 + 8) < v12)
        {
          ++v14[1];
          _OWORD v14[2] = v15 - 1;
        }
      }
    }
    else
    {
      ++*v14;
      if (a2)
      {
        ++v14[1];
      }
      else
      {
        ++v14[2];
        uint64_t v17 = a1 + 16 * (a3 & 0x3FF);
        *(_WORD *)(v17 + 560) = a3;
        *(_DWORD *)(v17 + 562) = 0;
        *(_WORD *)(v17 + 566) = 0;
        *(double *)(v17 + 568) = v8;
      }
    }
    pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 304));
  }
}

uint64_t VCConnectionHealthMonitor_ReceiveServerStats(uint64_t a1, int a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (pthread_rwlock_t *)(a1 + 304);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 304));
  if (*(unsigned char *)(a1 + 536)) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = a2 == 0;
  }
  if (!v5)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v6 = VRTraceErrorLogLevelToCSTR();
      unsigned __int8 v7 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v10 = 136315650;
        uint64_t v11 = v6;
        __int16 v12 = 2080;
        uint64_t v13 = "VCConnectionHealthMonitor_ReceiveServerStats";
        __int16 v14 = 1024;
        int v15 = 402;
        _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d First packet received", (uint8_t *)&v10, 0x1Cu);
      }
    }
    *(unsigned char *)(a1 + 536) = 1;
  }
  ++*(unsigned char *)(a1 + 504);
  uint64_t v8 = 505;
  if (!a2) {
    uint64_t v8 = 506;
  }
  ++*(unsigned char *)(a1 + v8);
  return pthread_rwlock_unlock(v4);
}

char *VCPixelBufferOverlay_updateOverlayWithPixelBuffer(char *result, __CVBuffer *a2)
{
  uint64_t v153 = *MEMORY[0x1E4F143B8];
  if (!result) {
    return result;
  }
  if (!a2) {
    return result;
  }
  double v3 = result;
  BOOL result = (char *)[result currentDetails];
  if (!v120) {
    return result;
  }
  double v4 = micro();
  int Width = CVPixelBufferGetWidth(a2);
  int Height = CVPixelBufferGetHeight(a2);
  uint64_t v7 = *((void *)v3 + 24);
  if (v7) {
    VCOverlaySource_Read(v7);
  }
  uint64_t v8 = *((void *)v3 + 23);
  if (v8) {
    VCOverlaySource_Read(v8);
  }
  uint64_t v9 = *((void *)v3 + 25);
  if (v9) {
    VCOverlaySource_Read(v9);
  }
  LODWORD(valuePtr.a) = Width;
  LODWORD(keys[0]) = Height;
  CFNumberRef Attachment = (const __CFNumber *)CVBufferGetAttachment(a2, @"VraWidth", 0);
  if (Attachment) {
    CFNumberGetValue(Attachment, kCFNumberIntType, &valuePtr);
  }
  CFNumberRef v11 = (const __CFNumber *)CVBufferGetAttachment(a2, @"VraHeight", 0);
  int v12 = Height;
  if (v11)
  {
    CFNumberGetValue(v11, kCFNumberIntType, keys);
    int v12 = (int)keys[0];
  }
  int v119 = Width;
  *((double *)v3 + 40) = (double)SLODWORD(valuePtr.a);
  *((double *)v3 + 41) = (double)v12;
  if (CFStringGetLength(*((CFStringRef *)v3 + 37)) < 1)
  {
    int v14 = 0;
  }
  else
  {
    CFIndex v13 = 0;
    int v14 = 0;
    int v15 = 0;
    do
    {
      int CharacterAtIndex = CFStringGetCharacterAtIndex(*((CFStringRef *)v3 + 37), v13);
      if (v14 <= v15) {
        int v17 = v15;
      }
      else {
        int v17 = v14;
      }
      if (CharacterAtIndex == 10) {
        int v15 = 0;
      }
      else {
        ++v15;
      }
      if (CharacterAtIndex == 10) {
        int v14 = v17;
      }
      ++v13;
    }
    while (CFStringGetLength(*((CFStringRef *)v3 + 37)) > v13);
  }
  if (*((_DWORD *)v3 + 84) != v14 || v4 - *((double *)v3 + 44) > 5.0)
  {
    *((double *)v3 + 44) = v4;
    int v18 = (const void *)*((void *)v3 + 36);
    if (v18) {
      CFRelease(v18);
    }
    double v19 = *((double *)v3 + 34);
    double v20 = *((double *)v3 + 35);
    if (v14 >= 75) {
      int v21 = 75;
    }
    else {
      int v21 = v14;
    }
    double v22 = (double)v21;
    DeviceGray = CGColorSpaceCreateDeviceGray();
    *(_OWORD *)&valuePtr.CGFloat a = xmmword_1E25A18A0;
    CGColorRef v24 = CGColorCreate(DeviceGray, &valuePtr.a);
    float v25 = v19 * v20;
    double v26 = fmin(round(sqrtf(v25) / v22), 32.0);
    if (v26 < 20.0) {
      double v26 = 20.0;
    }
    CTFontRef UIFontForLanguage = CTFontCreateUIFontForLanguage(kCTFontUIFontUserFixedPitch, v26, 0);
    int v28 = (void *)*MEMORY[0x1E4F24740];
    keys[0] = *(void **)MEMORY[0x1E4F243F0];
    keys[1] = v28;
    values[0] = UIFontForLanguage;
    values[1] = v24;
    CFDictionaryRef v29 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v24) {
      CFRelease(v24);
    }
    if (UIFontForLanguage) {
      CFRelease(UIFontForLanguage);
    }
    if (DeviceGray) {
      CFRelease(DeviceGray);
    }
    *((void *)v3 + 36) = v29;
    *((_DWORD *)v3 + 84) = v14;
  }
  __int16 v30 = (double *)(v3 + 320);
  if ((*((double *)v3 + 40) != (double)*((int *)v3 + 77) || *((double *)v3 + 41) != (double)*((int *)v3 + 78))
    && v4 - *((double *)v3 + 43) > 5.0)
  {
    *((double *)v3 + 43) = v4;
    double v31 = *v30;
    double v32 = *((double *)v3 + 41);
    if (*v30 >= v32) {
      double v32 = *v30;
    }
    unsigned int v33 = (int)v32;
    if (((int)v32 - 513) >= 0x200)
    {
      if (v33 - 101 > 0x19B)
      {
        if (v33 < 0x65) {
          int v34 = 1;
        }
        else {
          int v34 = 4;
        }
      }
      else
      {
        int v34 = 2;
      }
    }
    else
    {
      int v34 = 3;
    }
    if (v3[304] != v34)
    {
      v3[304] = v34;
      double v31 = *((double *)v3 + 40);
    }
    *((_DWORD *)v3 + 77) = (int)v31;
    *((_DWORD *)v3 + 78) = (int)*((double *)v3 + 41);
  }
  [v3 currentDetails];
  int v35 = (CGFloat *)MEMORY[0x1E4F1DAB8];
  if (LOBYTE(valuePtr.a))
  {
    double v118 = v4;
    long long v136 = xmmword_1E25A18D0;
    long long v137 = unk_1E25A18E0;
    long long v138 = xmmword_1E25A18F0;
    *(_OWORD *)keys = xmmword_1E25A18B0;
    long long v135 = unk_1E25A18C0;
    [v3 currentDetails];
    LOBYTE(keys[0]) = 0;
    long long v131 = v136;
    long long v132 = v137;
    long long v133 = v138;
    *(_OWORD *)values = *(_OWORD *)keys;
    long long v130 = v135;
    [v3 setCurrentDetails:values];
    int v128 = -1431655766;
    [v3 currentDetails];
    FigCFDictionaryGetIntIfPresent();
    int v36 = CVPixelBufferGetWidth(a2);
    int v37 = CVPixelBufferGetHeight(a2);
    [v3 currentDetails];
    float v38 = v127 * (double)v36;
    float v117 = v38;
    [v3 currentDetails];
    float v39 = v126 * (double)v37;
    float v116 = v39;
    [v3 currentDetails];
    float v40 = v125 * (double)v36;
    [v3 currentDetails];
    float v41 = v124 * (double)v37;
    CGFloat v43 = *v35;
    CGFloat v42 = v35[1];
    CGFloat v45 = v35[2];
    CGFloat v44 = v35[3];
    CGFloat v47 = v35[4];
    CGFloat v46 = v35[5];
    [v3 currentDetails];
    if (v123)
    {
      float v49 = v41 * 0.5;
      v121.CGFloat a = v43;
      v121.CGFloat b = v42;
      v121.c = v45;
      v121.d = v44;
      v121.tx = v47;
      v121.ty = v46;
      CGAffineTransformTranslate(&v122, &v121, v40, v49);
      CGFloat a = v122.a;
      CGFloat b = v122.b;
      long long v53 = *(_OWORD *)&v122.c;
      long long v52 = *(_OWORD *)&v122.tx;
      unint64_t v54 = v3 + 256;
      float v55 = (float)(v40 * 0.5) + v117;
      float v56 = v49 + v116;
    }
    else
    {
      float v48 = v40 * 0.5;
      v121.CGFloat a = v43;
      v121.CGFloat b = v42;
      v121.c = v45;
      v121.d = v44;
      v121.tx = v47;
      v121.ty = v46;
      CGAffineTransformTranslate(&v122, &v121, v48, (float)(v41 * 0.5));
      CGAffineTransform v121 = v122;
      CGAffineTransformRotate(&v122, &v121, 3.14159265);
      CGAffineTransform v121 = v122;
      CGAffineTransformTranslate(&v122, &v121, (float)((float)-v117 - v48), (float)((float)-v116 - (float)(v41 * 0.5)));
      CGFloat a = v122.a;
      CGFloat b = v122.b;
      long long v53 = *(_OWORD *)&v122.c;
      long long v52 = *(_OWORD *)&v122.tx;
      unint64_t v54 = v3 + 256;
      float v56 = (float)(v41 * 0.5) + v116;
      float v55 = v48 + v117;
    }
    *(void *)unint64_t v54 = 0;
    *((void *)v54 + 1) = 0;
    *((double *)v54 + 2) = v55;
    *((double *)v54 + 3) = v56;
    *((CGFloat *)v3 + 26) = a;
    *((CGFloat *)v3 + 27) = b;
    *((_OWORD *)v3 + 14) = v53;
    *((_OWORD *)v3 + 15) = v52;
    double v4 = v118;
  }
  unsigned int v57 = (__CFString *)*((void *)v3 + 37);
  v154.length = CFStringGetLength(v57);
  v154.location = 0;
  CFStringDelete(v57, v154);
  char v58 = v3[304];
  if (v58)
  {
    uint64_t v59 = *((void *)v3 + 24);
    char v60 = &OBJC_IVAR___VCEmulatedNetworkAlgorithmQueueLoss__currentIndexForLossRate;
    if (v59)
    {
      uint64_t v61 = *(void *)(v59 + 48);
      if (v61)
      {
        valuePtr.CGFloat a = *((CGFloat *)v3 + 37);
        LOBYTE(valuePtr.b) = v58;
        *(_DWORD *)((char *)&valuePtr.b + 1) = 0;
        HIDWORD(valuePtr.b) = 0;
        CGFloat v62 = *((double *)v3 + 22);
        valuePtr.c = *(CGFloat *)(v61 + 16);
        valuePtr.d = v62;
        valuePtr.tx = v4;
        uint64_t v63 = *((void *)v3 + 25);
        if (v63)
        {
          uint64_t v64 = *(void *)(v63 + 48);
          if (v64)
          {
            int v65 = *(_DWORD *)(v64 + 8);
            HIDWORD(valuePtr.b) = *(_DWORD *)(v64 + 11);
            *(_DWORD *)((char *)&valuePtr.b + 1) = v65;
          }
        }
        VCOverlaySourceTextHelper_appendHeaderTextToString((uint64_t)&valuePtr);
      }
    }
  }
  else
  {
    char v60 = &OBJC_IVAR___VCEmulatedNetworkAlgorithmQueueLoss__currentIndexForLossRate;
  }
  uint64_t v66 = *((void *)v3 + 24);
  if (v66)
  {
    uint64_t v67 = *(void *)(v66 + 48);
    if (v67)
    {
      long long v149 = xmmword_1E25A19C0;
      long long v150 = unk_1E25A19D0;
      long long v151 = xmmword_1E25A19E0;
      unint64_t v152 = 0xAAAAAAAAFFFFFFFFLL;
      long long v145 = xmmword_1E25A1980;
      long long v146 = unk_1E25A1990;
      long long v147 = xmmword_1E25A19A0;
      long long v148 = unk_1E25A19B0;
      long long v141 = xmmword_1E25A1940;
      long long v142 = unk_1E25A1950;
      long long v143 = xmmword_1E25A1960;
      long long v144 = unk_1E25A1970;
      CGAffineTransform valuePtr = *(CGAffineTransform *)byte_1E25A1900;
      long long v140 = unk_1E25A1930;
      valuePtr.CGFloat a = *((CGFloat *)v3 + 37);
      LOBYTE(valuePtr.b) = v3[304];
      long long v68 = *(_OWORD *)(v67 + 184);
      long long v69 = *(_OWORD *)(v67 + 168);
      long long v70 = *(_OWORD *)(v67 + 152);
      long long v146 = *(_OWORD *)(v67 + 136);
      long long v147 = v70;
      long long v148 = v69;
      long long v149 = v68;
      long long v71 = *(_OWORD *)(v67 + 120);
      long long v72 = *(_OWORD *)(v67 + 104);
      long long v73 = *(_OWORD *)(v67 + 88);
      long long v142 = *(_OWORD *)(v67 + 72);
      long long v143 = v73;
      long long v144 = v72;
      long long v145 = v71;
      long long v74 = *(_OWORD *)(v67 + 56);
      long long v75 = *(_OWORD *)(v67 + 40);
      long long v76 = *(_OWORD *)(v67 + 24);
      *(_OWORD *)&valuePtr.c = *(_OWORD *)(v67 + 8);
      *(_OWORD *)&valuePtr.tx = v76;
      long long v140 = v75;
      long long v141 = v74;
      *(double *)&long long v150 = (double)v119;
      *((double *)&v150 + 1) = (double)Height;
      long long v151 = *((_OWORD *)v3 + 20);
      LODWORD(v152) = *((_DWORD *)v3 + 92);
      VCOverlaySourceTextHelper_appendVideoTextToString((uint64_t)&valuePtr);
    }
  }
  uint64_t v77 = *(void *)&v3[v60[515]];
  if (v77)
  {
    uint64_t v78 = *(void *)(v77 + 48);
    if (v78)
    {
      *(_OWORD *)&valuePtr.CGFloat a = xmmword_1E25A19F8;
      valuePtr.CGFloat a = *((CGFloat *)v3 + 37);
      LOBYTE(valuePtr.b) = v3[304];
      long long v79 = *(_OWORD *)(v78 + 8);
      long long v80 = *(_OWORD *)(v78 + 24);
      long long v81 = *(_OWORD *)(v78 + 40);
      *(void *)&long long v141 = *(void *)(v78 + 56);
      *(_OWORD *)&valuePtr.tx = v80;
      long long v140 = v81;
      *(_OWORD *)&valuePtr.c = v79;
      VCOverlaySourceTextHelper_appendAudioTextToString((uint64_t)&valuePtr);
    }
  }
  int v82 = CVPixelBufferGetWidth(a2);
  int v83 = CVPixelBufferGetHeight(a2);
  int BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a2, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(a2, 0);
  if (!BaseAddressOfPlane)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
      goto LABEL_103;
    }
    uint64_t v102 = VRTraceErrorLogLevelToCSTR();
    double v103 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_103;
    }
    LODWORD(valuePtr.a) = 136315650;
    *(void *)((char *)&valuePtr.a + 4) = v102;
    WORD2(valuePtr.b) = 2080;
    *(void *)((char *)&valuePtr.b + 6) = "_VCPixelBufferOverlay_renderText";
    HIWORD(valuePtr.c) = 1024;
    LODWORD(valuePtr.d) = 225;
    uint64_t v104 = " [%s] %s:%d CVPixelBufferGetBaseAddressOfPlane was NULL";
    goto LABEL_102;
  }
  __int16 v86 = BaseAddressOfPlane;
  unsigned int v87 = CGColorSpaceCreateDeviceGray();
  if (!v87)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
      goto LABEL_103;
    }
    uint64_t v105 = VRTraceErrorLogLevelToCSTR();
    double v103 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_103;
    }
    LODWORD(valuePtr.a) = 136315650;
    *(void *)((char *)&valuePtr.a + 4) = v105;
    WORD2(valuePtr.b) = 2080;
    *(void *)((char *)&valuePtr.b + 6) = "_VCPixelBufferOverlay_renderText";
    HIWORD(valuePtr.c) = 1024;
    LODWORD(valuePtr.d) = 228;
    uint64_t v104 = " [%s] %s:%d CGColorSpaceCreateDeviceGray was NULL";
LABEL_102:
    _os_log_impl(&dword_1E1EA4000, v103, OS_LOG_TYPE_DEFAULT, v104, (uint8_t *)&valuePtr, 0x1Cu);
LABEL_103:
    __int16 v88 = 0;
LABEL_107:
    __int16 v90 = 0;
LABEL_108:
    CFAttributedStringRef v94 = 0;
LABEL_109:
    __int16 v96 = 0;
    unsigned int v99 = 0;
    int v101 = 0;
    goto LABEL_86;
  }
  __int16 v88 = v87;
  unsigned int v89 = CGBitmapContextCreate(v86, v82, v83, 8uLL, BytesPerRowOfPlane, v87, 0);
  if (!v89)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v106 = VRTraceErrorLogLevelToCSTR();
      int v107 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(valuePtr.a) = 136315650;
        *(void *)((char *)&valuePtr.a + 4) = v106;
        WORD2(valuePtr.b) = 2080;
        *(void *)((char *)&valuePtr.b + 6) = "_VCPixelBufferOverlay_renderText";
        HIWORD(valuePtr.c) = 1024;
        LODWORD(valuePtr.d) = 231;
        _os_log_impl(&dword_1E1EA4000, v107, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d CGBitmatContextCreate was NULL", (uint8_t *)&valuePtr, 0x1Cu);
      }
    }
    goto LABEL_107;
  }
  __int16 v90 = v89;
  long long v91 = *((_OWORD *)v3 + 14);
  *(_OWORD *)&valuePtr.CGFloat a = *((_OWORD *)v3 + 13);
  *(_OWORD *)&valuePtr.c = v91;
  *(_OWORD *)&valuePtr.tx = *((_OWORD *)v3 + 15);
  CGContextConcatCTM(v89, &valuePtr);
  long long v92 = *((_OWORD *)v35 + 1);
  *(_OWORD *)&valuePtr.CGFloat a = *(_OWORD *)v35;
  *(_OWORD *)&valuePtr.c = v92;
  *(_OWORD *)&valuePtr.tx = *((_OWORD *)v35 + 2);
  CGContextSetTextMatrix(v90, &valuePtr);
  CFAttributedStringRef v93 = CFAttributedStringCreate(0, *((CFStringRef *)v3 + 37), *((CFDictionaryRef *)v3 + 36));
  if (!v93)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v108 = VRTraceErrorLogLevelToCSTR();
      double v109 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(valuePtr.a) = 136315650;
        *(void *)((char *)&valuePtr.a + 4) = v108;
        WORD2(valuePtr.b) = 2080;
        *(void *)((char *)&valuePtr.b + 6) = "_VCPixelBufferOverlay_renderText";
        HIWORD(valuePtr.c) = 1024;
        LODWORD(valuePtr.d) = 237;
        _os_log_impl(&dword_1E1EA4000, v109, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d CFAttributedStringCreate was NULL", (uint8_t *)&valuePtr, 0x1Cu);
      }
    }
    goto LABEL_108;
  }
  CFAttributedStringRef v94 = v93;
  CTFramesetterRef v95 = CTFramesetterCreateWithAttributedString(v93);
  if (!v95)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v110 = VRTraceErrorLogLevelToCSTR();
      uint64_t v111 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(valuePtr.a) = 136315650;
        *(void *)((char *)&valuePtr.a + 4) = v110;
        WORD2(valuePtr.b) = 2080;
        *(void *)((char *)&valuePtr.b + 6) = "_VCPixelBufferOverlay_renderText";
        HIWORD(valuePtr.c) = 1024;
        LODWORD(valuePtr.d) = 241;
        _os_log_impl(&dword_1E1EA4000, v111, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d CTFramesetterCreateWithAttributedString was NULL", (uint8_t *)&valuePtr, 0x1Cu);
      }
    }
    goto LABEL_109;
  }
  __int16 v96 = v95;
  SRGB = CGColorCreateSRGB(0.0, 0.0, 0.0, 1.0);
  v156.width = 0.0;
  v156.height = 0.0;
  CGContextSetShadowWithColor(v90, v156, 2.0, SRGB);
  CFMutableArrayRef Mutable = CGPathCreateMutable();
  unsigned int v99 = Mutable;
  if (!Mutable)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v112 = VRTraceErrorLogLevelToCSTR();
      uint64_t v113 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(valuePtr.a) = 136315650;
        *(void *)((char *)&valuePtr.a + 4) = v112;
        WORD2(valuePtr.b) = 2080;
        *(void *)((char *)&valuePtr.b + 6) = "_VCPixelBufferOverlay_renderText";
        HIWORD(valuePtr.c) = 1024;
        LODWORD(valuePtr.d) = 249;
        int v114 = " [%s] %s:%d CGPathCreateMutable was NULL";
LABEL_122:
        _os_log_impl(&dword_1E1EA4000, v113, OS_LOG_TYPE_DEFAULT, v114, (uint8_t *)&valuePtr, 0x1Cu);
      }
    }
LABEL_123:
    int v101 = 0;
    if (!SRGB) {
      goto LABEL_86;
    }
    goto LABEL_85;
  }
  CGPathAddRect(Mutable, 0, *((CGRect *)v3 + 8));
  v155.location = 0;
  v155.length = 0;
  Frame = CTFramesetterCreateFrame(v96, v155, v99, 0);
  if (!Frame)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v115 = VRTraceErrorLogLevelToCSTR();
      uint64_t v113 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(valuePtr.a) = 136315650;
        *(void *)((char *)&valuePtr.a + 4) = v115;
        WORD2(valuePtr.b) = 2080;
        *(void *)((char *)&valuePtr.b + 6) = "_VCPixelBufferOverlay_renderText";
        HIWORD(valuePtr.c) = 1024;
        LODWORD(valuePtr.d) = 253;
        int v114 = " [%s] %s:%d CTFramesetterCreateFrame was NULL";
        goto LABEL_122;
      }
    }
    goto LABEL_123;
  }
  int v101 = Frame;
  CTFrameDraw(Frame, v90);
  if (SRGB) {
LABEL_85:
  }
    CFRelease(SRGB);
LABEL_86:
  CGColorSpaceRelease(v88);
  CGContextRelease(v90);
  if (v94) {
    CFRelease(v94);
  }
  if (v96) {
    CFRelease(v96);
  }
  if (v99) {
    CFRelease(v99);
  }
  if (v101) {
    CFRelease(v101);
  }
  return (char *)CVPixelBufferUnlockBaseAddress(a2, 0);
}

BOOL VCPixelBufferOverlay_updateSourceForType(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000;
  unsigned int v2 = *(NSObject **)(a1 + 168);
  char v9 = 1;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  void v5[2] = __VCPixelBufferOverlay_updateSourceForType_block_invoke;
  void v5[3] = &unk_1E6DB7008;
  _OWORD v5[5] = &v6;
  v5[6] = a2;
  void v5[4] = a1;
  dispatch_sync(v2, v5);
  BOOL v3 = *((unsigned char *)v7 + 24) != 0;
  _Block_object_dispose(&v6, 8);
  return v3;
}

char *VCFFTMeter_Create()
{
  uint64_t v0 = (char *)malloc_type_calloc(1uLL, 0x111E0uLL, 0x10E004047CE1534uLL);
  if (v0)
  {
    if (VCAllocatorFirstCome_Create((const __CFAllocator *)*MEMORY[0x1E4F1CF80], (uint64_t)"FFTMeterLERPFilterAllocator", (CFAllocatorRef *)v0 + 8763))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCFFTMeter_Create_cold_3();
        }
      }
    }
    else
    {
      vDSP_hann_window((float *)v0 + 9608, 0xF00uLL, 0);
      *((void *)v0 + 1) = v0 + 23072;
      *((void *)v0 + 2) = v0 + 30752;
      vDSP_DFT_Setup Setup = vDSP_DFT_zrop_CreateSetup(0, 0xF00uLL, vDSP_DFT_FORWARD);
      *(void *)uint64_t v0 = Setup;
      if (Setup)
      {
        unsigned int v2 = (float *)(v0 + 69828);
        *((_DWORD *)v0 + 17523) = 730643660;
        memset_pattern4(v0 + 69152, v0 + 70092, 0xD8uLL);
        uint64_t v3 = 0;
        *((_DWORD *)v0 + 17522) = 965249161;
        uint64x2_t v4 = (uint64x2_t)vdupq_n_s64(0x42uLL);
        int64x2_t v5 = (int64x2_t)xmmword_1E259DC60;
        int64x2_t v6 = vdupq_n_s64(2uLL);
        do
        {
          if (vmovn_s64((int64x2_t)vcgtq_u64(v4, (uint64x2_t)v5)).u8[0]) {
            *(v2 - 1) = (float)((float)(int)v3 * 53.0) / 65.0;
          }
          if (vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x42uLL), *(uint64x2_t *)&v5)).i32[1]) {
            *unsigned int v2 = (float)((float)(v3 + 1) * 53.0) / 65.0;
          }
          v3 += 2;
          int64x2_t v5 = vaddq_s64(v5, v6);
          v2 += 2;
        }
        while (v3 != 66);
        *((void *)v0 + 8762) = 264;
        return v0;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCFFTMeter_Create_cold_2();
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCFFTMeter_Create_cold_1();
    }
  }
  if (*(void *)v0) {
    vDSP_DFT_DestroySetup(*(vDSP_DFT_Setup *)v0);
  }
  free(v0);
  return 0;
}

void VCFFTMeter_Destroy(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v1 = *a1;
    *a1 = 0;
    if (v1)
    {
      if (*(void *)v1) {
        vDSP_DFT_DestroySetup(*(vDSP_DFT_Setup *)v1);
      }
      unsigned int v2 = *(const void **)(v1 + 70104);
      if (v2) {
        CFRelease(v2);
      }
      free((void *)v1);
    }
  }
}

__CFData *VCFFTMeter_Compute(uint64_t a1, uint64_t a2)
{
  CFMutableArrayRef Mutable = 0;
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    uint64_t v5 = a1 + 70096;
    int64x2_t v6 = (_DWORD *)(a1 + 69812);
    unsigned int v29 = -1431655766;
    float AveragePower = VCAudioBufferList_GetAveragePower(a2);
    BufferAtIndex = (const void *)VCAudioBufferList_GetBufferAtIndex(a2, 0, &v29);
    memmove((void *)(a1 + 32), (const void *)(a1 + 32 + 4 * v29), 4 * (3840 - v29));
    char v9 = (void *)(a1 + 32 + 4 * (3840 - v29));
    if (AveragePower <= -70.0) {
      bzero(v9, 4 * v29);
    }
    else {
      memcpy(v9, BufferAtIndex, 4 * v29);
    }
    vDSP_vmul((const float *)(a1 + 32), 1, (const float *)(a1 + 38432), 1, (float *)(a1 + 53792), 1, 0xF00uLL);
    vDSP_ctoz((const DSPComplex *)(a1 + 53792), 2, (const DSPSplitComplex *)(a1 + 8), 1, 0x780uLL);
    vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)a1, *(const float **)(a1 + 8), *(const float **)(a1 + 16), *(float **)(a1 + 8), *(float **)(a1 + 16));
    vDSP_vsmul(*(const float **)(a1 + 8), 1, (const float *)(a1 + 70088), *(float **)(a1 + 8), 1, 0x780uLL);
    vDSP_vsmul(*(const float **)(a1 + 16), 1, (const float *)(a1 + 70088), *(float **)(a1 + 16), 1, 0x780uLL);
    vDSP_zvmags((const DSPSplitComplex *)(a1 + 8), 1, (float *)(a1 + 15392), 1, 0x780uLL);
    unsigned int v10 = 0;
    uint64_t v11 = 0;
    *(_DWORD *)(a1 + 15392) = 0;
    do
    {
      uint64_t v12 = v11 + 1;
      uint64_t v13 = _octave2IndexTable6[v11 + 1];
      float v14 = 1.0e-12;
      if (v13 > v10)
      {
        int v15 = (float *)(a1 + 15392 + 4 * v10);
        float v14 = 1.0e-12;
        uint64_t v16 = v13 - v10;
        do
        {
          float v17 = *v15++;
          float v14 = v14 + v17;
          --v16;
        }
        while (v16);
      }
      *(float *)(a1 + 4 * v11 + 69376) = v14 / (float)(v13 - v10);
      unsigned int v10 = v13;
      ++v11;
    }
    while (v12 != 54);
    float __B = 1.0;
    vDSP_vdbcon((const float *)(a1 + 69376), 1, &__B, (float *)(a1 + 69376), 1, 0x36uLL, 0);
    float __C = 0.13673;
    float v26 = 0.72654;
    vDSP_vasm((const float *)(a1 + 69376), 1, (const float *)(a1 + 69152), 1, &__C, (float *)(a1 + 69152), 1, 0x36uLL);
    vDSP_vsma((const float *)(a1 + 69600), 1, &v26, (const float *)(a1 + 69152), 1, (float *)(a1 + 69600), 1, 0x36uLL);
    long long v18 = *(_OWORD *)(a1 + 69552);
    *(_OWORD *)(a1 + 69312) = *(_OWORD *)(a1 + 69536);
    *(_OWORD *)(a1 + 69328) = v18;
    *(_OWORD *)(a1 + 69344) = *(_OWORD *)(a1 + 69568);
    *(void *)(a1 + 69360) = *(void *)(a1 + 69584);
    long long v19 = *(_OWORD *)(a1 + 69488);
    *(_OWORD *)(a1 + 69248) = *(_OWORD *)(a1 + 69472);
    *(_OWORD *)(a1 + 69264) = v19;
    long long v20 = *(_OWORD *)(a1 + 69520);
    *(_OWORD *)(a1 + 69280) = *(_OWORD *)(a1 + 69504);
    *(_OWORD *)(a1 + 69296) = v20;
    long long v21 = *(_OWORD *)(a1 + 69424);
    *(_OWORD *)(a1 + 69184) = *(_OWORD *)(a1 + 69408);
    *(_OWORD *)(a1 + 69200) = v21;
    long long v22 = *(_OWORD *)(a1 + 69456);
    *(_OWORD *)(a1 + 69216) = *(_OWORD *)(a1 + 69440);
    *(_OWORD *)(a1 + 69232) = v22;
    long long v23 = *(_OWORD *)(a1 + 69392);
    *(_OWORD *)(a1 + 69152) = *(_OWORD *)(a1 + 69376);
    *(_OWORD *)(a1 + 69168) = v23;
    v6[1] = *v6;
    CFMutableArrayRef Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(v5 + 8), *(void *)v5);
    CFDataSetLength(Mutable, *(void *)v5);
    MutableBytePtr = (float *)CFDataGetMutableBytePtr(Mutable);
    vDSP_vlint((const float *)(a1 + 69600), (const float *)(a1 + 69824), 1, MutableBytePtr, 1, 0x42uLL, 0x36uLL);
  }
  return Mutable;
}

__CFString *VCSessionMediaType_Name(uint64_t a1)
{
  if (a1 >= 6) {
    return (__CFString *)objc_msgSend(NSString, "stringWithFormat:", @"Unknown (%d)", a1);
  }
  else {
    return off_1E6DB8638[(int)a1];
  }
}

uint64_t VCSessionMediaType_FromAVCSessionMediaType(uint64_t result)
{
  if (result >= 9) {
    return 0xFFFFFFFFLL;
  }
  else {
    return result;
  }
}

__CFString *_VCMediaStreamTransport_CipherSuiteAsString(uint64_t a1)
{
  if ((a1 + 1) >= 0xB) {
    return (__CFString *)objc_msgSend(NSString, "stringWithFormat:", @"Unknown cipher=%d", a1);
  }
  else {
    return off_1E6DB8668[(int)a1 + 1];
  }
}

double VCMediaStreamTransport_DecryptionTimeoutInterval(uint64_t a1)
{
  if (a1) {
    return VCMediaStreamConfig_DecryptionTimeOutInterval(*(void *)(a1 + 8));
  }
  else {
    return 0.0;
  }
}

uint64_t VCMediaStreamTransport_SetDecryptionTimeoutInterval(uint64_t result, double a2)
{
  if (result) {
    return VCAudioBufferList_SetHostTimeJumpSize(*(void *)(result + 8), a2);
  }
  return result;
}

double VCMediaStreamTransport_DecryptionMKMRecoveryInterval(uint64_t a1)
{
  if (a1) {
    return VCMediaStreamConfig_DecryptionMKMRecoveryInterval(*(void *)(a1 + 8));
  }
  else {
    return 0.0;
  }
}

uint64_t VCPacketFilterRTPCreate(uint64_t a1, void *a2)
{
  uint64_t ClassID = VCPacketFilterGetClassID();

  return VCFBOUtils_ObjectCreate(a1, a2, (uint64_t)&kVCPacketFilterRTPVTable, ClassID, 52);
}

BOOL VCPacketFilterIsOfKindRTP(uint64_t a1)
{
  return VCFBOUtils_IsKindOfClass(a1, (uint64_t)&kVCPacketFilterRTPVTable);
}

void _VCPacketFilterRTPFinalize(uint64_t a1)
{
  if (a1)
  {
    uint64_t DerivedStorage = (const void **)CMBaseObjectGetDerivedStorage();
    if (DerivedStorage)
    {
      unsigned int v2 = DerivedStorage;
      uint64_t v3 = *DerivedStorage;
      if (v3) {
        CFRelease(v3);
      }
      uint64x2_t v4 = v2[1];
      if (v4)
      {
        CFRelease(v4);
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCPacketFilterRTPFinalize_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCPacketFilterRTPFinalize_cold_1();
    }
  }
}

uint64_t _VCPacketFilterRTPCopyProperty(uint64_t a1, const void *a2, uint64_t a3, void *a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCPacketFilterRTPCopyProperty_cold_1();
      }
    }
    return 4294954516;
  }
  if (!a2 || !a4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v13 = VRTraceErrorLogLevelToCSTR();
      float v14 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        int v15 = 136316162;
        uint64_t v16 = v13;
        __int16 v17 = 2080;
        long long v18 = "_VCPacketFilterRTPCopyProperty";
        __int16 v19 = 1024;
        int v20 = 61;
        __int16 v21 = 2112;
        long long v22 = a2;
        __int16 v23 = 2112;
        CGColorRef v24 = a4;
        _os_log_error_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_ERROR, " [%s] %s:%d Property name '%@' and property value out '%@' must not be NULL", (uint8_t *)&v15, 0x30u);
      }
    }
    return 4294954516;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, @"RTPRemoteSSRC"))
  {
    uint64_t v7 = *(const void **)DerivedStorage;
    if (!*(void *)DerivedStorage)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 6) {
        return 4294954513;
      }
      uint64_t v8 = VRTraceErrorLogLevelToCSTR();
      char v9 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        return 4294954513;
      }
      int v15 = 136315906;
      uint64_t v16 = v8;
      __int16 v17 = 2080;
      long long v18 = "_VCPacketFilterRTPCopyProperty";
      __int16 v19 = 1024;
      int v20 = 70;
      __int16 v21 = 2112;
      long long v22 = a2;
LABEL_19:
      _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Parameter '%@' is currently not set for packet filter", (uint8_t *)&v15, 0x26u);
      return 4294954513;
    }
    goto LABEL_11;
  }
  if (CFEqual(a2, @"RTPPayloadList"))
  {
    uint64_t v7 = *(const void **)(DerivedStorage + 8);
    if (!v7)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 6) {
        return 4294954513;
      }
      uint64_t v12 = VRTraceErrorLogLevelToCSTR();
      char v9 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        return 4294954513;
      }
      int v15 = 136315906;
      uint64_t v16 = v12;
      __int16 v17 = 2080;
      long long v18 = "_VCPacketFilterRTPCopyProperty";
      __int16 v19 = 1024;
      int v20 = 78;
      __int16 v21 = 2112;
      long long v22 = a2;
      goto LABEL_19;
    }
LABEL_11:
    CFTypeRef v10 = CFRetain(v7);
    uint64_t result = 0;
    *a4 = v10;
    return result;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCPacketFilterRTPCopyProperty_cold_2();
    }
  }
  return 4294954512;
}

uint64_t _VCPacketFilterRTPSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCPacketFilterRTPSetProperty_cold_1();
      }
    }
    return 4294954516;
  }
  if (!a2 || !a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v10 = VRTraceErrorLogLevelToCSTR();
      uint64_t v11 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        int v12 = 136316162;
        uint64_t v13 = v10;
        __int16 v14 = 2080;
        int v15 = "_VCPacketFilterRTPSetProperty";
        __int16 v16 = 1024;
        int v17 = 93;
        __int16 v18 = 2112;
        __int16 v19 = a2;
        __int16 v20 = 2112;
        __int16 v21 = a3;
        _os_log_error_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_ERROR, " [%s] %s:%d Property name '%@' and property value out '%@' must not be NULL", (uint8_t *)&v12, 0x30u);
      }
    }
    return 4294954516;
  }
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, @"RTPRemoteSSRC"))
  {
    CFArrayRef v6 = *(CFArrayRef *)DerivedStorage;
    *(void *)uint64_t DerivedStorage = a3;
    CFRetain(a3);
    if (!v6) {
      return 0;
    }
LABEL_6:
    CFRelease(v6);
    return 0;
  }
  if (CFEqual(a2, @"RTPPayloadList"))
  {
    CFArrayRef Copy = CFArrayCreateCopy(0, (CFArrayRef)a3);
    CFArrayRef v6 = Copy;
    char v9 = *(const void **)(DerivedStorage + 8);
    *(void *)(DerivedStorage + 8) = Copy;
    if (Copy) {
      CFRetain(Copy);
    }
    if (v9) {
      CFRelease(v9);
    }
    if (!v6) {
      return 0;
    }
    goto LABEL_6;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCPacketFilterRTPSetProperty_cold_2();
    }
  }
  return 4294954512;
}

void _VCXPCConnection_timeoutHandlerFunc(uint64_t a1)
{
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3
    && (VRTraceErrorLogLevelToCSTR(), os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)))
  {
    _VCXPCConnection_timeoutHandlerFunc_cold_1();
    if (!a1) {
      return;
    }
  }
  else if (!a1)
  {
    return;
  }
  uint64_t v2 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (v2)
  {
    uint64_t v3 = (const void *)v2;
    +[VCXPCConnection selfTerminateDueToTimeout:v2];
    CFRelease(v3);
  }
}

void sub_1E22AB2D4(_Unwind_Exception *exception_object)
{
}

void sub_1E22AB430(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1E22AB698(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_2_8(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

void OUTLINED_FUNCTION_11_5(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x3Au);
}

uint64_t VCVideoStreamConfig_StreamType(uint64_t result)
{
  if (result) {
    return *(void *)(result + 416);
  }
  return result;
}

unint64_t Crossfade_Initialize(uint64_t a1, int a2, int a3, char a4)
{
  int v7 = a3 * a2;
  Crossfade_Finalize(a1);
  uint64_t v8 = (float *)malloc_type_malloc(4 * a2, 0x100004052888210uLL);
  char v9 = v8;
  if (v8) {
    uint64_t v10 = &v8[a2];
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = (char *)malloc_type_malloc(4 * a2, 0x100004052888210uLL);
  int v12 = v11;
  if (v11) {
    uint64_t v13 = &v11[4 * a2];
  }
  else {
    uint64_t v13 = 0;
  }
  unint64_t result = (unint64_t)malloc_type_malloc(v7, 0x7ED62481uLL);
  int v15 = (void *)result;
  unint64_t v16 = result + v7;
  if (!result) {
    unint64_t v16 = 0;
  }
  if (v9 && v12 && result)
  {
    if (v9 > v10
      || a2 < 0
      || v10 - v9 < a2
      || v12 > v13
      || a2 > (v13 - v12) >> 2
      || (*(void *)(a1 + 8) = v9,
          *(void *)(a1 + 16) = v12,
          *(_DWORD *)(a1 + 32) = a2,
          BOOL v17 = v16 >= result,
          unint64_t v18 = v16 - result,
          !v17)
      || v18 < v7)
    {
      __break(0x5519u);
    }
    else
    {
      *(void *)a1 = result;
      *(void *)(a1 + 24) = v7;
      if (a2)
      {
        uint64_t v19 = 0;
        do
        {
          long double v20 = cos((double)(int)v19 * 3.14159265 / (double)a2);
          float v21 = sqrt(v20 * -0.5 + 0.5);
          v9[v19] = v21;
          *(float *)&long double v20 = sqrt(v20 * 0.5 + 0.5);
          *(_DWORD *)&v12[4 * v19++] = LODWORD(v20);
        }
        while (a2 != v19);
      }
      unint64_t result = 0;
      *(unsigned char *)(a1 + 36) = a4;
    }
  }
  else
  {
    free(v9);
    free(v12);
    free(v15);
    return 2147549187;
  }
  return result;
}

double Crossfade_Finalize(uint64_t a1)
{
  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 16));
  free(*(void **)a1);
  *(_DWORD *)(a1 + 32) = 0;
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

uint64_t Crossfade_Apply(uint64_t result, const float *__C, unint64_t a3, float *__E, unint64_t a5)
{
  if (!result || !__C || !__E) {
    return 0;
  }
  unint64_t v5 = *(void *)(result + 24);
  if (v5 > a3 || v5 > a5) {
    return 0;
  }
  if (*(unsigned char *)(result + 36))
  {
    uint64_t v7 = 1;
    vDSP_vmma(__E, 1, *(const float **)(result + 8), 1, __C, 1, *(const float **)(result + 16), 1, __E, 1, *(int *)(result + 32));
    return v7;
  }
  uint64_t v8 = *(unsigned int *)(result + 32);
  if ((int)v8 < 1) {
    return 1;
  }
  uint64_t v9 = 0;
  uint64_t v10 = 4 * v8;
  uint64_t v11 = __E;
  int v12 = __C;
  while (v11 < (float *)((char *)__E + a5) && v11 >= __E && v12 < (const float *)((char *)__C + a3) && v12 >= __C)
  {
    int v13 = *(__int16 *)v12;
    int v12 = (const float *)((char *)v12 + 2);
    *(_WORD *)uint64_t v11 = (int)(float)((float)(*(float *)(*(void *)(result + 16) + v9) * (float)v13)
                               + (float)((float)*(__int16 *)v11 * *(float *)(*(void *)(result + 8) + v9)));
    uint64_t v11 = (float *)((char *)v11 + 2);
    v9 += 4;
    uint64_t v7 = 1;
    if (v10 == v9) {
      return v7;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t VCSpatialAudioMetadata_Create(const __CFAllocator *a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t *a5)
{
  if (a5)
  {
    *a5 = 0;
    if (a2)
    {
      uint64_t v8 = a3;
      if (a3) {
        goto LABEL_7;
      }
      if (GetSpatialMetadataSPI_sSpatialMetadataSPIOnce != -1) {
        dispatch_once(&GetSpatialMetadataSPI_sSpatialMetadataSPIOnce, &__block_literal_global_69);
      }
      uint64_t v8 = GetSpatialMetadataSPI_sSpatialMetadataSPI;
      if (GetSpatialMetadataSPI_sSpatialMetadataSPI)
      {
LABEL_7:
        if (VCSpatialAudioMetadata_GetTypeID_initOnce != -1) {
          dispatch_once_f(&VCSpatialAudioMetadata_GetTypeID_initOnce, &VCSpatialAudioMetadata_GetTypeID_typeID, (dispatch_function_t)_VCSpatialAudioMetadataClassRegister);
        }
        uint64_t Instance = _CFRuntimeCreateInstance();
        if (Instance)
        {
          uint64_t v11 = Instance;
          int v12 = malloc_type_calloc(a2, 0x10uLL, 0x102004075F474C6uLL);
          *(void *)(v11 + 104) = v12;
          if (!v12)
          {
            uint64_t v16 = 2151415810;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                VCSpatialAudioMetadata_Create_cold_5();
              }
            }
            goto LABEL_58;
          }
          *(void *)(v11 + 80) = v8;
          int v13 = (void *)(v11 + 88);
          if ((*(unsigned int (**)(uint64_t, uint64_t))(v8 + 8))(v11 + 88, a2))
          {
            uint64_t v16 = 2151415810;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                VCSpatialAudioMetadata_Create_cold_11();
              }
            }
            goto LABEL_58;
          }
          if (!*v13)
          {
            uint64_t v16 = 2151415810;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                VCSpatialAudioMetadata_Create_cold_6();
              }
            }
            goto LABEL_58;
          }
          if ((*(unsigned int (**)(void, uint64_t))(*(void *)(v11 + 80) + 40))(*v13, v11 + 168))
          {
            uint64_t v16 = 2151415812;
            if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
              goto LABEL_58;
            }
            VRTraceErrorLogLevelToCSTR();
            if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              goto LABEL_58;
            }
            VCSpatialAudioMetadata_Create_cold_10();
          }
          else
          {
            if (*(_DWORD *)(v11 + 168))
            {
              if (VCAllocatorFirstCome_Create(a1, (uint64_t)"VCSpatialAudioMetadataAllocator", (CFAllocatorRef *)(v11 + 184)))
              {
                uint64_t v16 = 2151415810;
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                    VCSpatialAudioMetadata_Create_cold_9();
                  }
                }
              }
              else
              {
                if (!VCAllocatorFirstCome_Create(a1, (uint64_t)"VCSpatialAudioMetadataAllocator", (CFAllocatorRef *)(v11 + 176)))
                {
                  pthread_mutex_init((pthread_mutex_t *)(v11 + 16), 0);
                  if (a4) {
                    *(void *)(v11 + 192) = _Block_copy(a4);
                  }
                  *(_DWORD *)(v11 + 100) = a2;
                  uint64_t v14 = *(void *)(v11 + 104);
                  if (a2 != 1)
                  {
                    unint64_t v15 = v14 + 16;
                    do
                    {
                      *(_DWORD *)(v15 + 12) = *(_DWORD *)(v15 - 4) + 1;
                      *(void *)(v15 - 16) = v15;
                      v15 += 16;
                    }
                    while (v15 <= v14 + 16 * (unint64_t)(a2 - 1));
                  }
                  uint64_t v16 = 0;
                  *(void *)(v11 + 112) = v14;
                  *a5 = v11;
                  return v16;
                }
                uint64_t v16 = 2151415810;
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                    VCSpatialAudioMetadata_Create_cold_8();
                  }
                }
              }
LABEL_58:
              CFRelease((CFTypeRef)v11);
              return v16;
            }
            uint64_t v16 = 2151415812;
            if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
              goto LABEL_58;
            }
            VRTraceErrorLogLevelToCSTR();
            if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              goto LABEL_58;
            }
            VCSpatialAudioMetadata_Create_cold_7();
          }
          uint64_t v16 = 2151415812;
          goto LABEL_58;
        }
        uint64_t v16 = 2151415810;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCSpatialAudioMetadata_Create_cold_4();
          }
        }
      }
      else
      {
        uint64_t v16 = 2151415809;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCSpatialAudioMetadata_Create_cold_3();
          }
        }
      }
    }
    else
    {
      uint64_t v16 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCSpatialAudioMetadata_Create_cold_2();
        }
      }
    }
  }
  else
  {
    uint64_t v16 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCSpatialAudioMetadata_Create_cold_1();
      }
    }
  }
  return v16;
}

BOOL VCSpatialAudioMetadata_HasChanged(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 96) != 0;
  }
  return result;
}

uint64_t VCSpatialAudioMetadata_CreateEntry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if (a4)
  {
    *a4 = 0;
    if (a2)
    {
      uint64_t v7 = (pthread_mutex_t *)(a2 + 16);
      pthread_mutex_lock((pthread_mutex_t *)(a2 + 16));
      if (*(void *)(a2 + 112))
      {
        if (VCSpatialAudioMetadataEntry_GetTypeID_initOnce != -1) {
          dispatch_once_f(&VCSpatialAudioMetadataEntry_GetTypeID_initOnce, &VCSpatialAudioMetadataEntry_GetTypeID_typeID, (dispatch_function_t)_VCSpatialAudioMetadataEntryClassRegister);
        }
        uint64_t Instance = (void *)_CFRuntimeCreateInstance();
        if (Instance)
        {
          uint64_t v9 = (uint64_t)Instance;
          uint64_t v10 = *(void *)(a2 + 112);
          *(void *)(a2 + 112) = *(void *)v10;
          *(void *)uint64_t v10 = 0;
          *(unsigned char *)(v10 + 8) = 1;
          Instance[6] = v10;
          Instance[7] = a3;
          Instance[2] = CFRetain((CFTypeRef)a2);
          _VCSpatialAudioMetadata_SetEntryPropertyUInt32(v9, 10, 1);
          uint64_t v11 = 0;
          *a4 = v9;
LABEL_8:
          pthread_mutex_unlock(v7);
          return v11;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          uint64_t v11 = 2151415827;
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCSpatialAudioMetadata_CreateEntry_cold_4();
          }
          goto LABEL_8;
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        uint64_t v11 = 2151415827;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCSpatialAudioMetadata_CreateEntry_cold_3();
        }
        goto LABEL_8;
      }
      uint64_t v11 = 2151415827;
      goto LABEL_8;
    }
    uint64_t v11 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCSpatialAudioMetadata_CreateEntry_cold_2();
      }
    }
  }
  else
  {
    uint64_t v11 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCSpatialAudioMetadata_CreateEntry_cold_1();
      }
    }
  }
  return v11;
}

void _VCSpatialAudioMetadata_SetEntryPropertyUInt32(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = a2;
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  int v9 = a3;
  uint64_t v4 = *(void *)(a1 + 16);
  if ((*(unsigned int (**)(void, uint64_t, void, int *, uint64_t))(*(void *)(v4 + 80) + 32))(*(void *)(v4 + 88), a2, *(unsigned int *)(*(void *)(a1 + 48) + 12), &v9, 4))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      CFArrayRef v6 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        int v7 = v9;
        uint64_t v8 = FourccToCStr(v3);
        *(_DWORD *)buf = 136316418;
        uint64_t v11 = v5;
        __int16 v12 = 2080;
        int v13 = "_VCSpatialAudioMetadata_SetEntryPropertyUInt32";
        __int16 v14 = 1024;
        int v15 = 167;
        __int16 v16 = 1024;
        int v17 = v3;
        __int16 v18 = 1024;
        int v19 = v7;
        __int16 v20 = 2080;
        float v21 = v8;
        _os_log_error_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to set property %d to %u. error=%s", buf, 0x32u);
      }
    }
  }
  else
  {
    *(unsigned char *)(v4 + 96) = 1;
  }
}

uint64_t VCSpatialAudioMetadata_ChannelIndex(uint64_t a1, _DWORD *a2)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v3 + 16));
      if (a2)
      {
        uint64_t v5 = 0;
        *a2 = *(_DWORD *)(*(void *)(a1 + 48) + 12);
      }
      else
      {
        uint64_t v5 = 2151415809;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCSpatialAudioMetadata_ChannelIndex_cold_3();
          }
        }
      }
      pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a1 + 16) + 16));
    }
    else
    {
      uint64_t v5 = 2151415812;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          VCSpatialAudioMetadata_ChannelIndex_cold_2();
          return 2151415812;
        }
      }
    }
  }
  else
  {
    uint64_t v5 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCSpatialAudioMetadata_ChannelIndex_cold_1();
      }
    }
  }
  return v5;
}

uint64_t VCSpatialAudioMetadata_SpatialAudioSourceID(uint64_t a1, void *a2)
{
  if (a2)
  {
    if (a1)
    {
      uint64_t v3 = *(void *)(a1 + 16);
      if (v3)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v3 + 16));
        *a2 = *(void *)(a1 + 56);
        pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a1 + 16) + 16));
        return 0;
      }
      else
      {
        uint64_t v5 = 2151415809;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCSpatialAudioMetadata_SpatialAudioSourceID_cold_3();
          }
        }
      }
    }
    else
    {
      uint64_t v5 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCSpatialAudioMetadata_SpatialAudioSourceID_cold_2();
        }
      }
    }
  }
  else
  {
    uint64_t v5 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCSpatialAudioMetadata_SpatialAudioSourceID_cold_1();
      }
    }
  }
  return v5;
}

uint64_t VCSpatialAudioMetadata_UpdateGlobalInfo(uint64_t a1, long long *a2)
{
  if (a1)
  {
    uint64_t v4 = (pthread_mutex_t *)(a1 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    if (!a2)
    {
      uint64_t v10 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCSpatialAudioMetadata_UpdateGlobalInfo_cold_2();
        }
      }
      goto LABEL_43;
    }
    float v5 = *((float *)a2 + 1);
    if (v5 <= 0.0)
    {
      uint64_t v10 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCSpatialAudioMetadata_UpdateGlobalInfo_cold_3();
        }
      }
      goto LABEL_43;
    }
    if (*((float *)a2 + 2) <= 0.0)
    {
      uint64_t v10 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCSpatialAudioMetadata_UpdateGlobalInfo_cold_4();
        }
      }
      goto LABEL_43;
    }
    if (*((float *)a2 + 3) <= 0.0)
    {
      uint64_t v10 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCSpatialAudioMetadata_UpdateGlobalInfo_cold_5();
        }
      }
      goto LABEL_43;
    }
    if (*((float *)a2 + 4) <= 0.0)
    {
      uint64_t v10 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCSpatialAudioMetadata_UpdateGlobalInfo_cold_6();
        }
      }
      goto LABEL_43;
    }
    CFArrayRef v6 = (int *)(a2 + 2);
    if (*((_DWORD *)a2 + 8) >= 2u)
    {
      uint64_t v10 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCSpatialAudioMetadata_UpdateGlobalInfo_cold_7();
        }
      }
      goto LABEL_43;
    }
    int v7 = (int *)a2 + 7;
    if (*((_DWORD *)a2 + 7))
    {
      uint64_t v10 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCSpatialAudioMetadata_UpdateGlobalInfo_cold_8();
        }
      }
      goto LABEL_43;
    }
    int v8 = *(_DWORD *)a2;
    if ((*(unsigned char *)(a1 + 120) && v8 == *(_DWORD *)(a1 + 124)
       || (_VCSpatialAudioMetadata_SetPropertyUInt32(a1, 0, v8), float v5 = *((float *)a2 + 1), *(unsigned char *)(a1 + 120)))
      && v5 == *(float *)(a1 + 128))
    {
      float v9 = *((float *)a2 + 2);
    }
    else
    {
      _VCSpatialAudioMetadata_SetPropertyFloat32(a1, 4, v5);
      float v9 = *((float *)a2 + 2);
      if (!*(unsigned char *)(a1 + 120)) {
        goto LABEL_20;
      }
    }
    if (v9 == *(float *)(a1 + 132))
    {
      float v11 = *((float *)a2 + 3);
LABEL_23:
      if (v11 == *(float *)(a1 + 136))
      {
        float v12 = *((float *)a2 + 4);
        goto LABEL_27;
      }
LABEL_24:
      _VCSpatialAudioMetadata_SetPropertyFloat32(a1, 6, v11);
      float v12 = *((float *)a2 + 4);
      if (!*(unsigned char *)(a1 + 120))
      {
LABEL_28:
        _VCSpatialAudioMetadata_SetPropertyFloat32(a1, 7, v12);
        if (!*(unsigned char *)(a1 + 120))
        {
          float v13 = *((float *)a2 + 5);
LABEL_32:
          _VCSpatialAudioMetadata_SetPropertyFloat32(a1, 8, v13);
          if (!*(unsigned char *)(a1 + 120))
          {
            float v14 = *((float *)a2 + 6);
            goto LABEL_36;
          }
LABEL_33:
          float v14 = *((float *)a2 + 6);
          if (v14 == *(float *)(a1 + 148))
          {
            int v15 = *v7;
LABEL_37:
            if (v15 == *(_DWORD *)(a1 + 152))
            {
              int v16 = *v6;
LABEL_40:
              if (v16 == *(_DWORD *)(a1 + 156))
              {
LABEL_42:
                uint64_t v10 = 0;
                *(unsigned char *)(a1 + 120) = 1;
                long long v17 = *a2;
                long long v18 = a2[1];
                *(_DWORD *)(a1 + 156) = *((_DWORD *)a2 + 8);
                *(_OWORD *)(a1 + 140) = v18;
                *(_OWORD *)(a1 + 124) = v17;
LABEL_43:
                pthread_mutex_unlock(v4);
                return v10;
              }
LABEL_41:
              _VCSpatialAudioMetadata_SetPropertyUInt32(a1, 2, v16);
              goto LABEL_42;
            }
LABEL_39:
            _VCSpatialAudioMetadata_SetPropertyUInt32(a1, 1, v15);
            int v16 = *v6;
            if (!*(unsigned char *)(a1 + 120)) {
              goto LABEL_41;
            }
            goto LABEL_40;
          }
LABEL_36:
          _VCSpatialAudioMetadata_SetPropertyFloat32(a1, 9, v14);
          int v15 = *v7;
          if (!*(unsigned char *)(a1 + 120)) {
            goto LABEL_39;
          }
          goto LABEL_37;
        }
LABEL_29:
        float v13 = *((float *)a2 + 5);
        if (v13 == *(float *)(a1 + 144)) {
          goto LABEL_33;
        }
        goto LABEL_32;
      }
LABEL_27:
      if (v12 == *(float *)(a1 + 140)) {
        goto LABEL_29;
      }
      goto LABEL_28;
    }
LABEL_20:
    _VCSpatialAudioMetadata_SetPropertyFloat32(a1, 5, v9);
    float v11 = *((float *)a2 + 3);
    if (!*(unsigned char *)(a1 + 120)) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  uint64_t v10 = 2151415809;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCSpatialAudioMetadata_UpdateGlobalInfo_cold_1();
    }
  }
  return v10;
}

void _VCSpatialAudioMetadata_SetPropertyUInt32(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = a2;
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  int v9 = a3;
  if ((*(unsigned int (**)(void, uint64_t, void, int *, uint64_t))(*(void *)(a1 + 80) + 32))(*(void *)(a1 + 88), a2, 0, &v9, 4))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      CFArrayRef v6 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        int v7 = v9;
        int v8 = FourccToCStr(v3);
        *(_DWORD *)buf = 136316418;
        uint64_t v11 = v5;
        __int16 v12 = 2080;
        float v13 = "_VCSpatialAudioMetadata_SetPropertyUInt32";
        __int16 v14 = 1024;
        int v15 = 148;
        __int16 v16 = 1024;
        int v17 = v3;
        __int16 v18 = 1024;
        int v19 = v7;
        __int16 v20 = 2080;
        float v21 = v8;
        _os_log_error_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to set property %d to %u. error=%s", buf, 0x32u);
      }
    }
  }
  else
  {
    *(unsigned char *)(a1 + 96) = 1;
  }
}

void _VCSpatialAudioMetadata_SetPropertyFloat32(uint64_t a1, uint64_t a2, float a3)
{
  int v3 = a2;
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  float v9 = a3;
  if ((*(unsigned int (**)(void, uint64_t, void, float *, uint64_t))(*(void *)(a1 + 80) + 32))(*(void *)(a1 + 88), a2, 0, &v9, 4))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      CFArrayRef v6 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        double v7 = v9;
        int v8 = FourccToCStr(v3);
        *(_DWORD *)buf = 136316418;
        uint64_t v11 = v5;
        __int16 v12 = 2080;
        float v13 = "_VCSpatialAudioMetadata_SetPropertyFloat32";
        __int16 v14 = 1024;
        int v15 = 157;
        __int16 v16 = 1024;
        int v17 = v3;
        __int16 v18 = 2048;
        double v19 = v7;
        __int16 v20 = 2080;
        float v21 = v8;
        _os_log_error_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to set property %d to %f. error=%s", buf, 0x36u);
      }
    }
  }
  else
  {
    *(unsigned char *)(a1 + 96) = 1;
  }
}

uint64_t VCSpatialAudioMetadata_UpdateOrientation(uint64_t a1, unsigned int a2)
{
  if (a1)
  {
    uint64_t v4 = (pthread_mutex_t *)(a1 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    if (a2 >= 4)
    {
      uint64_t v6 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCSpatialAudioMetadata_UpdateOrientation_cold_2();
        }
      }
    }
    else
    {
      unsigned int v5 = a2 + 1;
      if (!*(unsigned char *)(a1 + 160) || v5 != *(_DWORD *)(a1 + 164))
      {
        _VCSpatialAudioMetadata_SetPropertyUInt32(a1, 3, a2 + 1);
        *(_DWORD *)(a1 + 164) = v5;
      }
      uint64_t v6 = 0;
      *(unsigned char *)(a1 + 160) = 1;
    }
    pthread_mutex_unlock(v4);
  }
  else
  {
    uint64_t v6 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCSpatialAudioMetadata_UpdateOrientation_cold_1();
      }
    }
  }
  return v6;
}

uint64_t VCSpatialAudioMetadata_UpdatePositionalInfo(uint64_t a1, long long *a2)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v3 + 16));
      if (a2)
      {
        if (*(float *)(a1 + 24) != *(float *)a2) {
          _VCSpatialAudioMetadata_SetEntryPropertyFloat32(a1, 13, *(float *)a2);
        }
        float v5 = *((float *)a2 + 1);
        if (*(float *)(a1 + 28) != v5) {
          _VCSpatialAudioMetadata_SetEntryPropertyFloat32(a1, 14, v5);
        }
        float v6 = *((float *)a2 + 2);
        if (*(float *)(a1 + 32) != v6) {
          _VCSpatialAudioMetadata_SetEntryPropertyFloat32(a1, 15, v6);
        }
        int v7 = *((_DWORD *)a2 + 3);
        if (*(_DWORD *)(a1 + 36) != v7) {
          _VCSpatialAudioMetadata_SetEntryPropertyUInt32(a1, 16, v7);
        }
        int v8 = *((_DWORD *)a2 + 4);
        if (*(_DWORD *)(a1 + 40) != v8) {
          _VCSpatialAudioMetadata_SetEntryPropertyUInt32(a1, 12, v8);
        }
        int v9 = *((_DWORD *)a2 + 5);
        if (*(_DWORD *)(a1 + 44) != v9) {
          _VCSpatialAudioMetadata_SetEntryPropertyUInt32(a1, 11, v9);
        }
        uint64_t v10 = 0;
        long long v11 = *a2;
        *(void *)(a1 + 40) = *((void *)a2 + 2);
        *(_OWORD *)(a1 + 24) = v11;
      }
      else
      {
        uint64_t v10 = 2151415809;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCSpatialAudioMetadata_UpdatePositionalInfo_cold_3();
          }
        }
      }
      pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a1 + 16) + 16));
    }
    else
    {
      uint64_t v10 = 2151415812;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          VCSpatialAudioMetadata_UpdatePositionalInfo_cold_2();
          return 2151415812;
        }
      }
    }
  }
  else
  {
    uint64_t v10 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCSpatialAudioMetadata_UpdatePositionalInfo_cold_1();
      }
    }
  }
  return v10;
}

void _VCSpatialAudioMetadata_SetEntryPropertyFloat32(uint64_t a1, uint64_t a2, float a3)
{
  int v3 = a2;
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  float v9 = a3;
  uint64_t v4 = *(void *)(a1 + 16);
  if ((*(unsigned int (**)(void, uint64_t, void, float *, uint64_t))(*(void *)(v4 + 80) + 32))(*(void *)(v4 + 88), a2, *(unsigned int *)(*(void *)(a1 + 48) + 12), &v9, 4))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      float v6 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        double v7 = v9;
        int v8 = FourccToCStr(v3);
        *(_DWORD *)buf = 136316418;
        uint64_t v11 = v5;
        __int16 v12 = 2080;
        float v13 = "_VCSpatialAudioMetadata_SetEntryPropertyFloat32";
        __int16 v14 = 1024;
        int v15 = 177;
        __int16 v16 = 1024;
        int v17 = v3;
        __int16 v18 = 2048;
        double v19 = v7;
        __int16 v20 = 2080;
        float v21 = v8;
        _os_log_error_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to set property %d to %f. error=%s", buf, 0x36u);
      }
    }
  }
  else
  {
    *(unsigned char *)(v4 + 96) = 1;
  }
}

uint64_t VCSpatialAudioMetadata_Serialize(uint64_t a1, CMBlockBufferRef *a2)
{
  *(void *)&dataLength[1] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    *a2 = 0;
    if (a1)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
      uint64_t v4 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 184), *(unsigned int *)(a1 + 168), 0);
      dataLength[0] = *(_DWORD *)(a1 + 168);
      if ((*(unsigned int (**)(void, void *, _DWORD *))(*(void *)(a1 + 80) + 48))(*(void *)(a1 + 88), v4, dataLength))
      {
        uint64_t v5 = 2151415812;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
          {
            VCSpatialAudioMetadata_Serialize_cold_4();
            uint64_t v5 = 2151415812;
          }
        }
      }
      else
      {
        if (!CMBlockBufferCreateWithMemoryBlock(*(CFAllocatorRef *)(a1 + 176), v4, *(unsigned int *)(a1 + 168), *(CFAllocatorRef *)(a1 + 184), 0, 0, dataLength[0], 0, a2))
        {
          *(unsigned char *)(a1 + 96) = 0;
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
          return 0;
        }
        uint64_t v5 = 2151415810;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
          {
            VCSpatialAudioMetadata_Serialize_cold_3();
            uint64_t v5 = 2151415810;
          }
        }
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
      if (v4) {
        CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 184), v4);
      }
    }
    else
    {
      uint64_t v5 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCSpatialAudioMetadata_Serialize_cold_2();
        }
      }
    }
  }
  else
  {
    uint64_t v5 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCSpatialAudioMetadata_Serialize_cold_1();
      }
    }
  }
  return v5;
}

uint64_t VCSpatialAudioMetadata_SetNeedsRefresh(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (pthread_mutex_t *)(a1 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    *(unsigned char *)(a1 + 96) = 1;
    pthread_mutex_unlock(v2);
    return 0;
  }
  else
  {
    uint64_t v3 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCSpatialAudioMetadata_SetNeedsRefresh_cold_1();
      }
    }
  }
  return v3;
}

uint64_t _VCSpatialAudioMetadataClassRegister(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t _VCSpatialAudioMetadataEntryClassRegister(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

void *__GetSpatialMetadataSPI_block_invoke()
{
  uint64_t result = dlopen("/System/Library/Frameworks/AudioToolbox.framework/libAudioDSP.dylib", 1);
  if (result)
  {
    uint64_t result = dlsym(result, "gSpatialMetadataSPI");
    GetSpatialMetadataSPI_sSpatialMetadataSPI = (uint64_t)result;
  }
  return result;
}

double _VCSpatialAudioMetadata_Init(uint64_t a1)
{
  *(void *)(a1 + 192) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void _VCSpatialAudioMetadata_Finalize(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(unsigned int *)(a1 + 100);
    if (v2)
    {
      uint64_t v3 = (unsigned __int8 *)(*(void *)(a1 + 104) + 8);
      while (1)
      {
        int v4 = *v3;
        v3 += 16;
        if (v4) {
          break;
        }
        if (!--v2) {
          goto LABEL_6;
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCSpatialAudioMetadata_Finalize_cold_2();
        }
      }
    }
    else
    {
LABEL_6:
      uint64_t v5 = *(const void **)(a1 + 192);
      if (v5)
      {
        _Block_release(v5);
        *(void *)(a1 + 192) = 0;
      }
      if (*(void *)(a1 + 88)) {
        (*(void (**)(void))(*(void *)(a1 + 80) + 16))();
      }
      free(*(void **)(a1 + 104));
      float v6 = *(const void **)(a1 + 176);
      if (v6) {
        CFRelease(v6);
      }
      double v7 = *(const void **)(a1 + 184);
      if (v7) {
        CFRelease(v7);
      }
      pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCSpatialAudioMetadata_Finalize_cold_1();
    }
  }
}

double _VCSpatialAudioMetadataEntry_Init(_OWORD *a1)
{
  double result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void _VCSpatialAudioMetadataEntry_Finalize(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 16);
    if (v2)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v2 + 16));
      uint64_t v3 = *(void *)(a1 + 48);
      if (v3)
      {
        _VCSpatialAudioMetadata_SetEntryPropertyUInt32(a1, 10, 0);
        *(unsigned char *)(v3 + 8) = 0;
        *(void *)uint64_t v3 = *(void *)(v2 + 112);
        *(void *)(v2 + 112) = v3;
        *(unsigned char *)(v2 + 96) = 1;
        uint64_t v4 = *(void *)(v2 + 192);
        if (v4) {
          (*(void (**)(void))(v4 + 16))();
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCSpatialAudioMetadataEntry_Finalize_cold_3();
        }
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v2 + 16));
      CFRelease((CFTypeRef)v2);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCSpatialAudioMetadataEntry_Finalize_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCSpatialAudioMetadataEntry_Finalize_cold_1();
    }
  }
}

uint64_t VCTimescalePSOLA_CheckforSignalCorrelation(__int16 *a1, __int16 *a2, int a3, int a4)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  __int16 v7 = VCTimescalePSOLA_CalcFsMult((unsigned __int16)a1[1]);
  int v58 = a4;
  if (a4 == 1) {
    __int16 v8 = 240;
  }
  else {
    __int16 v8 = 160;
  }
  if (a2[33] < ((v7 * v8) & 0xFFF0))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v9 = VRTraceErrorLogLevelToCSTR();
      uint64_t v10 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v11 = a2[33];
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = v9;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "VCTimescalePSOLA_CheckforSignalCorrelation";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = 380;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v11;
        _os_log_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Not Enough samples to Timescale input bufferLength=%d", buf, 0x22u);
      }
    }
    return 1;
  }
  if (!*(unsigned char *)a1) {
    return 0;
  }
  unint64_t v13 = 0;
  if (a4) {
    __int16 v14 = 239;
  }
  else {
    __int16 v14 = 159;
  }
  __int16 v56 = v14;
  if (a4) {
    __int16 v15 = 110;
  }
  else {
    __int16 v15 = 70;
  }
  __int16 v54 = v15;
  if (a4) {
    uint64_t v16 = 60;
  }
  else {
    uint64_t v16 = 40;
  }
  long long v53 = (__int16 *)&buf[2 * v16];
  if (a4) {
    int v17 = 60;
  }
  else {
    int v17 = 40;
  }
  if (a4) {
    int v18 = 50;
  }
  else {
    int v18 = 30;
  }
  int v51 = v17 - 10;
  int v52 = v18;
  char v50 = (__int16 *)&buf[2 * (v17 - 10)];
  double v19 = "Compress";
  if (a4 == 1) {
    double v19 = "Expand";
  }
  float v49 = v19;
  for (uint64_t i = 3; ; ++i)
  {
    float v21 = &a2[4 * v13];
    uint64_t v22 = *(const void **)v21;
    __int16 v23 = (void *)*((void *)v21 + 4);
    int v24 = a2[33];
    uint64_t v25 = a2[33];
    int v26 = VCTimescalePSOLA_CalcFsMult((unsigned __int16)a1[1]);
    Float32ToNativeInt16_Portable();
    if (v24 >= (__int16)(v26 * v56)) {
      break;
    }
    a2[34] = v24;
    memmove(v23, v22, 4 * v25);
    uint64_t v12 = 1;
LABEL_38:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v38 = VRTraceErrorLogLevelToCSTR();
      float v39 = *MEMORY[0x1E4F47A50];
      float v40 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          int v41 = a1[v13 + 3];
          *(_DWORD *)buf = 136316162;
          *(void *)&uint8_t buf[4] = v38;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "VCTimescalePSOLA_CheckforSignalCorrelation";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 389;
          *(_WORD *)&buf[28] = 2080;
          *(void *)&buf[30] = v49;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&unsigned char buf[40] = v41;
          _os_log_impl(&dword_1E1EA4000, v39, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d mode=%s: pitch period=%d", buf, 0x2Cu);
        }
      }
      else if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
      {
        int v44 = a1[v13 + 3];
        *(_DWORD *)buf = 136316162;
        *(void *)&uint8_t buf[4] = v38;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "VCTimescalePSOLA_CheckforSignalCorrelation";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = 389;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = v49;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&unsigned char buf[40] = v44;
        _os_log_debug_impl(&dword_1E1EA4000, v39, OS_LOG_TYPE_DEBUG, " [%s] %s:%d mode=%s: pitch period=%d", buf, 0x2Cu);
      }
    }
    CGFloat v42 = (unsigned __int8 *)&a1[v13];
    int v43 = *((__int16 *)v42 + 3);
    if (v43 >= a3) {
      int v43 = a3;
    }
    *((_WORD *)v42 + 3) = v43;
    _VCTimescalePSOLA_FinalCorrelationCheck((uint64_t)a1, (int16x4_t *)&a1[a3 - (uint64_t)v43 + 50], (int16x4_t *)&a1[a3 + 50], v58, a2[33], a2[32], v13++);
    if (v13 >= *(unsigned __int8 *)a1) {
      return v12;
    }
  }
  __int16 v59 = -21846;
  *(void *)&long long v27 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)buf = v27;
  *(_OWORD *)&buf[16] = v27;
  *(_OWORD *)&unsigned char buf[32] = v27;
  long long v63 = v27;
  long long v64 = v27;
  long long v65 = v27;
  long long v66 = v27;
  long long v67 = v27;
  long long v68 = v27;
  long long v69 = v27;
  long long v70 = v27;
  long long v71 = v27;
  v72[0] = v27;
  *(_OWORD *)((char *)v72 + 12) = v27;
  v60[0] = v27;
  v60[1] = v27;
  v60[2] = v27;
  v60[3] = v27;
  v60[4] = v27;
  v61[0] = v27;
  *(void *)((char *)v61 + 14) = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v55 = VCTimescalePSOLA_DownSampleTo4kHz((uint64_t)(a1 + 50), v24, (unsigned __int16)a1[1], buf, v54, 1);
  if ((v55 & 0x80000000) == 0)
  {
    *(void *)&long long v28 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)((char *)v82 + 12) = v28;
    long long v81 = v28;
    v82[0] = v28;
    long long v79 = v28;
    long long v80 = v28;
    long long v77 = v28;
    long long v78 = v28;
    long long v75 = v28;
    long long v76 = v28;
    *(_OWORD *)&v73[32] = v28;
    long long v74 = v28;
    *(_OWORD *)long long v73 = v28;
    *(_OWORD *)&v73[16] = v28;
    int v29 = VCTimescalePSOLA_MaxAbsValueW16(a1 + 50, v24);
    __int16 v30 = VCTimescalePSOLA_Normalize((v29 * v29));
    VCTimescalePSOLA_CrossCorrelation(v73, v53, v50, v52, v51, (6 - v30) & ~((__int16)(6 - v30) >> 31), -1);
    uint64_t v31 = VCTimescalePSOLA_MaxAbsValueW32((int *)v73, v52);
    __int16 v32 = VCTimescalePSOLA_Normalize(v31);
    VCTimescalePSOLA_VectorBitShiftW32ToW16((uint64_t)v60, v52, (int *)v73, (__int16)(17 - v32) & ~((__int16)(17 - v32) >> 31));
    unsigned int v33 = (unsigned __int8 *)&a1[v13];
    VCTimescalePSOLA_PeakDetection((uint64_t)v60, v52, 1, v26, &a1[i], &v59);
    *((_WORD *)v33 + 3) += 20 * v26;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v34 = VRTraceErrorLogLevelToCSTR();
      int v35 = *MEMORY[0x1E4F47A50];
      int v36 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          int v37 = *((__int16 *)v33 + 3);
          *(_DWORD *)long long v73 = 136316162;
          *(void *)&v73[4] = v34;
          *(_WORD *)&v73[12] = 2080;
          *(void *)&v73[14] = "_VCTimescalePSOLA_DownSampledCoarseCorrelation";
          *(_WORD *)&v73[22] = 1024;
          *(_DWORD *)&v73[24] = 296;
          *(_WORD *)&v73[28] = 1024;
          *(_DWORD *)&v73[30] = v37;
          *(_WORD *)&v73[34] = 1024;
          *(_DWORD *)&v73[36] = v13;
          _os_log_impl(&dword_1E1EA4000, v35, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d PSOLA Adapt : pitch period=%d channel=%d", v73, 0x28u);
        }
      }
      else if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
      {
        int v45 = *((__int16 *)v33 + 3);
        *(_DWORD *)long long v73 = 136316162;
        *(void *)&v73[4] = v34;
        *(_WORD *)&v73[12] = 2080;
        *(void *)&v73[14] = "_VCTimescalePSOLA_DownSampledCoarseCorrelation";
        *(_WORD *)&v73[22] = 1024;
        *(_DWORD *)&v73[24] = 296;
        *(_WORD *)&v73[28] = 1024;
        *(_DWORD *)&v73[30] = v45;
        *(_WORD *)&v73[34] = 1024;
        *(_DWORD *)&v73[36] = v13;
        _os_log_debug_impl(&dword_1E1EA4000, v35, OS_LOG_TYPE_DEBUG, " [%s] %s:%d PSOLA Adapt : pitch period=%d channel=%d", v73, 0x28u);
      }
    }
    uint64_t v12 = v55;
    goto LABEL_38;
  }
  a2[34] = v24;
  memmove(v23, v22, 4 * v25);
  if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
    return v55;
  }
  uint64_t v46 = VRTraceErrorLogLevelToCSTR();
  CGFloat v47 = *MEMORY[0x1E4F47A50];
  uint64_t v12 = v55;
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
    VCTimescalePSOLA_CheckforSignalCorrelation_cold_1(v46, v47);
  }
  return v12;
}

void _VCTimescalePSOLA_FinalCorrelationCheck(uint64_t a1, int16x4_t *a2, int16x4_t *a3, int a4, int a5, int a6, unsigned int a7)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = a1 + 2 * a7;
  *(_WORD *)(v11 + 22) = 1;
  uint64_t v12 = (_WORD *)(v11 + 22);
  int v13 = VCTimescalePSOLA_MaxAbsValueW16((__int16 *)(a1 + 100), a5);
  __int16 v14 = VCTimescalePSOLA_Normalize((v13 * v13));
  unsigned int v16 = *(__int16 *)(v11 + 6);
  __int16 v15 = (__int16 *)(v11 + 6);
  __int16 v17 = VCTimescalePSOLA_Normalize(v16);
  int v18 = (__int16)(31 - (v14 + v17)) & ~((__int16)(31 - (v14 + v17)) >> 31);
  uint64_t v19 = VCTimescalePSOLA_DotProductWithScale(a2, a2, *v15, (31 - (v14 + v17)) & ~((__int16)(31 - (v14 + v17)) >> 31));
  uint64_t v20 = VCTimescalePSOLA_DotProductWithScale(a3, a3, *v15, v18);
  int v60 = VCTimescalePSOLA_DotProductWithScale(a2, a3, *v15, v18);
  if (*(_WORD *)(a1 + 64) == 1) {
    uint64_t v21 = *(unsigned int *)(a1 + 60);
  }
  else {
    uint64_t v21 = 75000;
  }
  uint64_t v22 = a7;
  __int16 v23 = VCTimescalePSOLA_Normalize(v21);
  char v24 = (16 - v23) & ~((__int16)(16 - v23) >> 31);
  uint64_t v25 = (((int)v20 + (int)v19) >> 4 >> v24);
  int v26 = (__int16)((int)v21 >> v24) * *v15;
  char v27 = 2 * v18;
  if ((int)VCTimescalePSOLA_Normalize(v25) < 2 * v18)
  {
    char v28 = VCTimescalePSOLA_Normalize(v25);
    char v29 = v27 - v28;
    char v27 = v28;
    v26 >>= v29;
  }
  int v30 = v25 << v27;
  if (v30 <= v26)
  {
    uint64_t v47 = v22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v48 = VRTraceErrorLogLevelToCSTR();
      float v49 = *MEMORY[0x1E4F47A50];
      char v50 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
        {
          int v51 = *(__int16 *)(a1 + 2 * v47 + 38);
          int v52 = "Compress";
          *(_DWORD *)buf = 136316418;
          uint64_t v63 = v48;
          __int16 v64 = 2080;
          long long v65 = "_VCTimescalePSOLA_VadCheckForScaling";
          if (a4 == 1) {
            int v52 = "Expand";
          }
          __int16 v66 = 1024;
          int v67 = 210;
          __int16 v68 = 2080;
          long long v69 = v52;
          __int16 v70 = 1024;
          int v71 = v51;
          __int16 v72 = 1024;
          int v73 = v30;
          _os_log_impl(&dword_1E1EA4000, v49, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d mode=%s bestCorrelation=%d VAD=0 energy_Q14=%d", buf, 0x32u);
        }
      }
      else if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
      {
        int v56 = *(__int16 *)(a1 + 2 * v47 + 38);
        unsigned int v57 = "Compress";
        *(_DWORD *)buf = 136316418;
        uint64_t v63 = v48;
        __int16 v64 = 2080;
        long long v65 = "_VCTimescalePSOLA_VadCheckForScaling";
        if (a4 == 1) {
          unsigned int v57 = "Expand";
        }
        __int16 v66 = 1024;
        int v67 = 210;
        __int16 v68 = 2080;
        long long v69 = v57;
        __int16 v70 = 1024;
        int v71 = v56;
        __int16 v72 = 1024;
        int v73 = v30;
        _os_log_debug_impl(&dword_1E1EA4000, v49, OS_LOG_TYPE_DEBUG, " [%s] %s:%d mode=%s bestCorrelation=%d VAD=0 energy_Q14=%d", buf, 0x32u);
      }
    }
    *uint64_t v12 = 0;
    *(_WORD *)(a1 + 2 * v47 + 38) = 0;
    if (a4 == 1)
    {
      int v55 = *v15;
      if (a5 - a6 <= v55) {
        LOWORD(v55) = a5 - a6;
      }
      *__int16 v15 = v55;
    }
  }
  else
  {
    *uint64_t v12 = 1;
    __int16 v31 = VCTimescalePSOLA_Normalize(v19);
    int v32 = (__int16)(16 - v31) & ~((__int16)(16 - v31) >> 31);
    __int16 v33 = VCTimescalePSOLA_Normalize(v20);
    int v34 = (__int16)(16 - v33) & ~((__int16)(16 - v33) >> 31);
    if (((_BYTE)v34 + (_BYTE)v32)) {
      __int16 v35 = v32 + 1;
    }
    else {
      __int16 v35 = v32;
    }
    int v36 = (__int16)((int)v19 >> v35) * (__int16)((int)v20 >> v34);
    int v37 = VCTimescalePSOLA_ShiftW32(v60, (__int16)(14 - ((v34 + v35) >> 1)));
    int v38 = VCTimescalePSOLA_DivW32W16(v37 & ~(v37 >> 31), (int)sqrt((double)v36));
    uint64_t v39 = a1 + 2 * v22;
    if (v38 << 16 <= 0x40000000) {
      __int16 v40 = v38;
    }
    else {
      __int16 v40 = 0x4000;
    }
    *(_WORD *)(v39 + 38) = v40;
    int v41 = (__int16 *)(v39 + 38);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v42 = VRTraceErrorLogLevelToCSTR();
      int v43 = *MEMORY[0x1E4F47A50];
      int v44 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          int v45 = "Compress";
          int v46 = *v41;
          *(_DWORD *)buf = 136316418;
          uint64_t v63 = v42;
          __int16 v64 = 2080;
          if (a4 == 1) {
            int v45 = "Expand";
          }
          long long v65 = "_VCTimescalePSOLA_VadCheckForScaling";
          __int16 v66 = 1024;
          int v67 = 232;
          __int16 v68 = 2080;
          long long v69 = v45;
          __int16 v70 = 1024;
          int v71 = v46;
          __int16 v72 = 1024;
          int v73 = v36;
          _os_log_impl(&dword_1E1EA4000, v43, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d mode=%s: bestCorrelation=%d VAD=1 energy_Q14=%d", buf, 0x32u);
        }
      }
      else if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
      {
        long long v53 = "Compress";
        int v54 = *v41;
        *(_DWORD *)buf = 136316418;
        uint64_t v63 = v42;
        __int16 v64 = 2080;
        if (a4 == 1) {
          long long v53 = "Expand";
        }
        long long v65 = "_VCTimescalePSOLA_VadCheckForScaling";
        __int16 v66 = 1024;
        int v67 = 232;
        __int16 v68 = 2080;
        long long v69 = v53;
        __int16 v70 = 1024;
        int v71 = v54;
        __int16 v72 = 1024;
        int v73 = v36;
        _os_log_debug_impl(&dword_1E1EA4000, v43, OS_LOG_TYPE_DEBUG, " [%s] %s:%d mode=%s: bestCorrelation=%d VAD=1 energy_Q14=%d", buf, 0x32u);
      }
    }
  }
}

void VCTimescalePSOLA_SynchronizeChannelCorrelation(_WORD *a1, uint64_t a2, int a3, __int16 a4)
{
  if (*(unsigned __int8 *)a1 >= 2u)
  {
    int v5 = (unsigned __int16)a1[11];
    if (v5 == 1)
    {
      int v6 = (unsigned __int16)a1[12];
      int v7 = (unsigned __int16)a1[3];
      int v8 = (unsigned __int16)a1[4];
      BOOL v9 = v7 == v8;
      if (v7 == v8 || v6 != 1)
      {
LABEL_7:
        if (!v9) {
          return;
        }
        goto LABEL_12;
      }
      unint64_t v15 = 0;
      if (a3) {
        __int16 v16 = 120;
      }
      else {
        __int16 v16 = 80;
      }
      a1[5] = v8;
      a1[6] = v7;
      uint64_t v17 = (__int16)(v16 * a4);
      int v18 = (int16x4_t *)&a1[v17 + 50];
      do
      {
        Float32ToNativeInt16_Portable();
        uint64_t v19 = &a1[v15];
        int v20 = (__int16)v19[5];
        if (v20 >= (int)v17) {
          int v20 = v17;
        }
        v19[5] = v20;
        _VCTimescalePSOLA_FinalCorrelationCheck((uint64_t)a1, (int16x4_t *)&a1[v17 - v20 + 50], v18, a3, *(__int16 *)(a2 + 66), *(__int16 *)(a2 + 64), (v15++ + 2));
      }
      while (v15 < *(unsigned __int8 *)a1);
      int v21 = (__int16)a1[21];
      int v22 = (__int16)a1[22];
      if (v21 >= v22)
      {
        if ((__int16)a1[20] < v21) {
          LOWORD(v21) = a1[20];
        }
        a1[3] = a1[6];
      }
      else
      {
        int v21 = (__int16)a1[19];
        if (v21 >= v22) {
          LOWORD(v21) = a1[22];
        }
      }
      a1[19] = v21;
    }
    else
    {
      int v11 = (unsigned __int16)a1[3];
      int v12 = (unsigned __int16)a1[4];
      BOOL v9 = v11 == v12;
      if (a1[11])
      {
        if (v11 != v12) {
          return;
        }
        LOWORD(v6) = a1[12];
LABEL_12:
        a1[19] = a1[20];
        if ((__int16)v5 <= (__int16)v6) {
          LOWORD(v5) = v6;
        }
        goto LABEL_14;
      }
      int v6 = (unsigned __int16)a1[12];
      if (v11 == v12 || v6 != 0)
      {
        if (v6 == 1)
        {
          a1[3] = v12;
          a1[19] = a1[20];
          LOWORD(v5) = 1;
LABEL_14:
          a1[11] = v5;
          return;
        }
        goto LABEL_7;
      }
      __int16 v24 = a1[4];
      if ((__int16)v11 > (__int16)v12) {
        __int16 v24 = a1[3];
      }
      a1[3] = v24;
    }
  }
}

uint64_t VCEffects_EffectsMode(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return *(unsigned int *)(a1 + 8);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    uint64_t v2 = VRTraceErrorLogLevelToCSTR();
    uint64_t v3 = *MEMORY[0x1E4F47A50];
    BOOL v4 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v4) {
      return result;
    }
    int v5 = 136315650;
    uint64_t v6 = v2;
    __int16 v7 = 2080;
    int v8 = "VCEffects_EffectsMode";
    __int16 v9 = 1024;
    int v10 = 63;
    _os_log_impl(&dword_1E1EA4000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v5, 0x1Cu);
  }
  return 0;
}

BOOL VCRemoteImageQueue_CreateSenderQueue(uint64_t a1, void *a2)
{
  return VCRemoteImageQueue_CreateSenderQueueWithPoolSize(a1, a2);
}

BOOL VCRemoteImageQueue_CreateSenderQueueWithPoolSize(uint64_t a1, void *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    *a2 = 0;
    uint64_t v3 = malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
    v6[0] = (uint64_t)v3;
    if (!v3)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCRemoteImageQueue_CreateSenderQueueWithPoolSize_cold_2();
        }
      }
      return *a2 != 0;
    }
    BOOL v4 = v3;
    if (FigSharedMemPoolCreate())
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCRemoteImageQueue_CreateSenderQueueWithPoolSize_cold_5();
        }
      }
    }
    else
    {
      int v7 = 0;
      v6[1] = 0x6400000064;
      if (FigRemoteQueueSenderCreate() || !v4[1])
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCRemoteImageQueue_CreateSenderQueueWithPoolSize_cold_3();
          }
        }
      }
      else
      {
        if (!FigRemoteQueueSenderSetMaximumBufferAge())
        {
          *a2 = v4;
          return *a2 != 0;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCRemoteImageQueue_CreateSenderQueueWithPoolSize_cold_4();
          }
        }
      }
    }
    VCRemoteImageQueue_Destroy(v6);
    return *a2 != 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    VCRemoteImageQueue_CreateSenderQueueWithPoolSize_cold_1();
  }
  return 0;
}

void VCRemoteImageQueue_Destroy(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = (CFTypeRef *)*a1;
    if (*a1)
    {
      if (v2[1])
      {
        VCRemoteImageQueue_ReleaseIOSurfaces(*a1);
        CFRelease(v2[1]);
      }
      if (*v2) {
        CFRelease(*v2);
      }
      if (v2[2])
      {
        FigRemoteQueueReceiverUnsetHandler();
        CFRelease(v2[2]);
      }
      *a1 = 0;
      free(v2);
    }
  }
}

BOOL VCRemoteImageQueue_CreateReceiverQueue(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  v11[1] = *MEMORY[0x1E4F143B8];
  if (a1 && a4)
  {
    *a4 = 0;
    int v5 = (char *)malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
    v11[0] = (uint64_t)v5;
    if (!v5)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCRemoteImageQueue_CreateReceiverQueue_cold_1();
        }
      }
      return *a4 != 0;
    }
    uint64_t v6 = v5;
    int v7 = v5 + 16;
    if (FigRemoteQueueReceiverCreateFromXPCObject() || !*v7)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCRemoteImageQueue_CreateReceiverQueue_cold_2();
        }
      }
    }
    else
    {
      uint64_t MessageReceiver = FigRemoteOperationReceiverCreateMessageReceiver();
      if (MessageReceiver)
      {
        __int16 v9 = (const void *)MessageReceiver;
        FigRemoteQueueReceiverSetHandler();
        _Block_release(v9);
        *a4 = v6;
        return *a4 != 0;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCRemoteImageQueue_CreateReceiverQueue_cold_3();
        }
      }
    }
    VCRemoteImageQueue_Destroy(v11);
    return *a4 != 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    VCRemoteImageQueue_CreateReceiverQueue_cold_4();
  }
  return 0;
}

uint64_t VCRemoteImageQueue_SharedMemoryPoolAllocator(void *a1)
{
  if (a1 && *a1) {
    return MEMORY[0x1F410D448](a1[1]);
  }
  else {
    return *MEMORY[0x1E4F1CF80];
  }
}

uint64_t VCRemoteImageQueue_ReleaseIOSurfaces(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a1 && *(void *)(a1 + 8))
  {
    return MEMORY[0x1F410D450]();
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v2 = VRTraceErrorLogLevelToCSTR();
      uint64_t v3 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v5 = 136315906;
        uint64_t v6 = v2;
        __int16 v7 = 2080;
        uint64_t v8 = "VCRemoteImageQueue_ReleaseIOSurfaces";
        __int16 v9 = 1024;
        int v10 = 198;
        __int16 v11 = 2048;
        uint64_t v12 = a1;
        _os_log_impl(&dword_1E1EA4000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Invalid remoteImageQueue=%p", (uint8_t *)&v5, 0x26u);
      }
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t VCRemoteImageQueue_EnqueueFrame(uint64_t a1, unint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a1 || !*(void *)(a1 + 8))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    int v5 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)uint64_t v12 = 136315906;
    *(void *)&v12[4] = v4;
    *(_WORD *)&_OWORD v12[12] = 2080;
    *(void *)&v12[14] = "VCRemoteImageQueue_EnqueueFrame";
    *(_WORD *)&v12[22] = 1024;
    LODWORD(v13) = 152;
    WORD2(v13) = 2048;
    *(void *)((char *)&v13 + 6) = a1;
    uint64_t v6 = " [%s] %s:%d Cannot Enqueue on an invalid remoteImageQueue %p";
    __int16 v7 = v5;
    uint32_t v8 = 38;
    goto LABEL_11;
  }
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v9 = VRTraceErrorLogLevelToCSTR();
    int v10 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)uint64_t v12 = 136315650;
    *(void *)&v12[4] = v9;
    *(_WORD *)&_OWORD v12[12] = 2080;
    *(void *)&v12[14] = "VCRemoteImageQueue_EnqueueFrame";
    *(_WORD *)&v12[22] = 1024;
    LODWORD(v13) = 157;
    uint64_t v6 = " [%s] %s:%d Pixel Buffer was NULL could not enqueue";
    __int16 v7 = v10;
    uint32_t v8 = 28;
LABEL_11:
    _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, v6, v12, v8);
    return 0xFFFFFFFFLL;
  }
  *(_OWORD *)&v12[8] = 0u;
  *(void *)uint64_t v12 = 3;
  uint64_t v14 = 0;
  long long v13 = a2;
  uint64_t v3 = _VCRemoteImageQueue_Enqueue(a1, (int *)v12);
  if (v3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCRemoteImageQueue_EnqueueFrame_cold_1();
      }
    }
  }
  return v3;
}

uint64_t _VCRemoteImageQueue_Enqueue(uint64_t a1, int *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = FigRemoteOperationSenderResetIfFullAndEnqueueOperation();
  if (v4 == -16669)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
    {
      return 4294950627;
    }
    else
    {
      uint64_t v10 = VRTraceErrorLogLevelToCSTR();
      __int16 v11 = *MEMORY[0x1E4F47A50];
      uint64_t v8 = 4294950627;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v12 = *a2;
        *(_DWORD *)buf = 136316418;
        uint64_t v18 = v10;
        __int16 v19 = 2080;
        int v20 = "_VCRemoteImageQueue_Enqueue";
        __int16 v21 = 1024;
        int v22 = 140;
        __int16 v23 = 2048;
        uint64_t v24 = a1;
        __int16 v25 = 1024;
        int v26 = -16669;
        __int16 v27 = 1024;
        int v28 = v12;
        _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d remoteImageQueue=%p err=%d opType=%d Queue is full!", buf, 0x32u);
      }
    }
  }
  else
  {
    int v5 = v4;
    if (v4)
    {
      if (v4 != -16665)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          uint64_t v13 = VRTraceErrorLogLevelToCSTR();
          uint64_t v14 = *MEMORY[0x1E4F47A50];
          uint64_t v8 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
            return v8;
          }
          int v15 = *a2;
          *(_DWORD *)buf = 136316418;
          uint64_t v18 = v13;
          __int16 v19 = 2080;
          int v20 = "_VCRemoteImageQueue_Enqueue";
          __int16 v21 = 1024;
          int v22 = 143;
          __int16 v23 = 2048;
          uint64_t v24 = a1;
          __int16 v25 = 1024;
          int v26 = v5;
          __int16 v27 = 1024;
          int v28 = v15;
          _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d remoteImageQueue=%p err=%d opType=%d Error occurred when enqueuing data", buf, 0x32u);
        }
        return 0;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      {
        return 4294950631;
      }
      else
      {
        uint64_t v6 = VRTraceErrorLogLevelToCSTR();
        __int16 v7 = *MEMORY[0x1E4F47A50];
        uint64_t v8 = 4294950631;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          int v9 = *a2;
          *(_DWORD *)buf = 136316418;
          uint64_t v18 = v6;
          __int16 v19 = 2080;
          int v20 = "_VCRemoteImageQueue_Enqueue";
          __int16 v21 = 1024;
          int v22 = 137;
          __int16 v23 = 2048;
          uint64_t v24 = a1;
          __int16 v25 = 1024;
          int v26 = -16665;
          __int16 v27 = 1024;
          int v28 = v9;
          _os_log_error_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_ERROR, " [%s] %s:%d remoteImageQueue=%p err=%d opType=%d Client terminated the queue", buf, 0x32u);
        }
      }
    }
    else
    {
      return v4;
    }
  }
  return v8;
}

uint64_t VCRemoteImageQueue_EnqueueAttributes(uint64_t a1, unint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!a1 || !*(void *)(a1 + 8))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
      return 4294967294;
    }
    uint64_t v6 = VRTraceErrorLogLevelToCSTR();
    __int16 v7 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      return 4294967294;
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "VCRemoteImageQueue_EnqueueAttributes";
    *(_WORD *)&buf[22] = 1024;
    LODWORD(v23) = 175;
    WORD2(v23) = 2048;
    *(void *)((char *)&v23 + 6) = a1;
    uint64_t v8 = " [%s] %s:%d Cannot Enqueue on an invalid remoteImageQueue %p";
    int v9 = v7;
    uint32_t v10 = 38;
    goto LABEL_11;
  }
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
      return 4294967294;
    }
    uint64_t v11 = VRTraceErrorLogLevelToCSTR();
    int v12 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      return 4294967294;
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = v11;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "VCRemoteImageQueue_EnqueueAttributes";
    *(_WORD *)&buf[22] = 1024;
    LODWORD(v23) = 180;
    uint64_t v8 = " [%s] %s:%d Attributes are NULL could not enqueue";
    int v9 = v12;
    uint32_t v10 = 28;
LABEL_11:
    _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, v8, buf, v10);
    return 4294967294;
  }
  *(_OWORD *)&buf[8] = 0u;
  *(void *)buf = 1;
  uint64_t v24 = 0;
  long long v23 = a2;
  uint64_t v3 = _VCRemoteImageQueue_Enqueue(a1, (int *)buf);
  if (v3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v4 = VRTraceErrorLogLevelToCSTR();
      int v5 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v14 = 136315906;
        uint64_t v15 = v4;
        __int16 v16 = 2080;
        uint64_t v17 = "VCRemoteImageQueue_EnqueueAttributes";
        __int16 v18 = 1024;
        int v19 = 191;
        __int16 v20 = 1024;
        int v21 = v3;
        _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Error occurred when sending the video attributes. err=%d", (uint8_t *)&v14, 0x22u);
      }
    }
  }
  return v3;
}

uint64_t VCRemoteImageQueue_CreateQueueXPCObject(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a1 && *(void *)(a1 + 8))
  {
    FigRemoteQueueSenderCreateXPCObject();
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v3 = VRTraceErrorLogLevelToCSTR();
      uint64_t v4 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        v5[0] = 136315906;
        *(void *)&v5[1] = v3;
        __int16 v6 = 2080;
        __int16 v7 = "VCRemoteImageQueue_CreateQueueXPCObject";
        __int16 v8 = 1024;
        int v9 = 206;
        __int16 v10 = 2048;
        uint64_t v11 = a1;
        _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Cannot get the XPC object on an invalid remoteImageQueue %p", (uint8_t *)v5, 0x26u);
      }
    }
    return 0;
  }
}

void VCAudioDump_LogCompressedAudio(uint64_t a1, void *a2, UInt32 a3, unsigned int *a4, unsigned __int16 *a5, double *a6)
{
  if (a1)
  {
    __int16 v8 = *(_DWORD **)(a1 + 16);
    if (v8)
    {
      if (a2 && *(void *)(a1 + 24))
      {
        if (a4)
        {
          unsigned int v10 = *a4;
        }
        else
        {
          int v11 = *(_DWORD *)(a1 + 4);
          BOOL v12 = v11 == 111 || v11 == 97;
          int v13 = v12 ? 160 : 320;
          unsigned int v10 = v13 + bswap32(v8[3]);
        }
        v8[3] = bswap32(v10);
        if (a3)
        {
          if (a6)
          {
            double v14 = *(double *)(a1 + 32);
            if (v14 == 0.0) {
              unsigned int v15 = 0;
            }
            else {
              unsigned int v15 = bswap32(((*a6 - v14) * 1000000.0));
            }
            v8[1] = v15;
            *(double *)(a1 + 32) = *a6;
            __int16 v8 = *(_DWORD **)(a1 + 16);
          }
          if (a5) {
            unsigned int v16 = *a5;
          }
          else {
            unsigned int v16 = (bswap32(*((unsigned __int16 *)v8 + 5)) >> 16) + 1;
          }
          *((_WORD *)v8 + 5) = bswap32(v16) >> 16;
          *((_WORD *)v8 + 1) = bswap32(a3 + 12) >> 16;
          *(_WORD *)__int16 v8 = bswap32(a3 + 14) >> 16;
          _VCAudioDumpFileWrapper_Update(*(void *)(a1 + 24), v8, 0x14u);
          uint64_t v17 = *(void *)(a1 + 24);
          _VCAudioDumpFileWrapper_Update(v17, a2, a3);
        }
      }
    }
  }
}

void _VCAudioDumpFileWrapper_Update(uint64_t a1, void *a2, UInt32 a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  *(&ioData.mNumberBuffers + 1) = -1431655766;
  ioData.mNumberBuffers = 1;
  ioData.mBuffers[0].mNumberChannels = 1;
  ioData.mBuffers[0].mDataByteSize = a3;
  ioData.mBuffers[0].mDatCGFloat a = a2;
  OSStatus v3 = ExtAudioFileWriteAsync(*(ExtAudioFileRef *)a1, a3 / *(_DWORD *)(a1 + 16), &ioData);
  if (v3)
  {
    OSStatus v4 = v3;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      __int16 v6 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v7 = 136315906;
        uint64_t v8 = v5;
        __int16 v9 = 2080;
        unsigned int v10 = "_VCAudioDumpFileWrapper_Update";
        __int16 v11 = 1024;
        int v12 = 175;
        __int16 v13 = 1024;
        OSStatus v14 = v4;
        _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ExtAudioFileWriteAsync failed with error=%d", (uint8_t *)&v7, 0x22u);
      }
    }
  }
}

void VCAudioDump_LogUnCompressedAudio(uint64_t a1, void *a2, uint64_t a3, UInt32 a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    OSStatus v4 = *(ExtAudioFileRef **)(a1 + 24);
    if (v4)
    {
      if (a2)
      {
        uint64_t v5 = *(void *)(a1 + 24);
        _VCAudioDumpFileWrapper_Update(v5, a2, a4);
      }
      else if (a3)
      {
        uint64_t AudioBufferList = (const AudioBufferList *)VCAudioBufferList_GetAudioBufferList(a3);
        SampleCFIndex Count = VCAudioBufferList_GetSampleCount(a3);
        OSStatus v9 = ExtAudioFileWriteAsync(*v4, SampleCount, AudioBufferList);
        if (v9)
        {
          OSStatus v10 = v9;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            uint64_t v11 = VRTraceErrorLogLevelToCSTR();
            int v12 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              int v13 = 136315906;
              uint64_t v14 = v11;
              __int16 v15 = 2080;
              uint64_t v16 = "_VCAudioDumpFileWrapper_UpdateSamples";
              __int16 v17 = 1024;
              int v18 = 167;
              __int16 v19 = 1024;
              OSStatus v20 = v10;
              _os_log_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ExtAudioFileWriteAsync failed with error=%d", (uint8_t *)&v13, 0x22u);
            }
          }
        }
      }
    }
  }
}

unsigned int *VCAudioDump_Create(unsigned int a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioDump_Create_cold_1();
      }
    }
    return 0;
  }
  if (!*(unsigned char *)a2) {
    return 0;
  }
  OSStatus v4 = (unsigned int *)malloc_type_calloc(1uLL, 0x28uLL, 0x10A0040282E6EF3uLL);
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioDump_Create_cold_2();
      }
    }
    return 0;
  }
  uint64_t v5 = v4;
  __int16 v6 = malloc_type_calloc(1uLL, 0x14uLL, 0x1000040A86A77D5uLL);
  *((void *)v5 + 2) = v6;
  if (!v6)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioDump_Create_cold_3();
      }
    }
    free(v5);
    return 0;
  }
  unsigned int *v5 = a1;
  if (a1 > 4) {
    int v7 = "";
  }
  else {
    int v7 = off_1E6DB87F8[a1];
  }
  int v8 = *(_DWORD *)(a2 + 4);
  unsigned int v9 = 8000;
  if (v8 <= 106)
  {
    if (v8 == 97) {
      goto LABEL_17;
    }
    if (v8 != 98) {
      goto LABEL_16;
    }
LABEL_15:
    unsigned int v9 = 16000;
    goto LABEL_17;
  }
  if (v8 == 107) {
    goto LABEL_15;
  }
  if (v8 != 111)
  {
    if (v8 == 108)
    {
      unsigned int v9 = 32000;
      goto LABEL_17;
    }
LABEL_16:
    unsigned int v9 = 0;
  }
LABEL_17:
  *((_WORD *)v5 + 6) = v9;
  if ((a1 & 0xFFFFFFFB) != 0 || (uint64_t v14 = *(const AudioStreamBasicDescription **)(a2 + 16)) == 0)
  {
    v5[1] = v8;
    if ((v8 - 97) > 1)
    {
      int v10 = 5;
      if ((v8 - 107) <= 4 && ((1 << (v8 - 107)) & 0x13) != 0) {
        int v10 = *(unsigned __int8 *)(a2 + 9);
      }
    }
    else if (*(unsigned char *)(a2 + 8))
    {
      int v10 = 3;
    }
    else
    {
      int v10 = 2;
    }
    void v5[2] = v10;
    uint64_t v11 = "none";
    if (v8 <= 106)
    {
      if (v8 == 97)
      {
        int v12 = "amr_nb_be";
        if (v10 != 2) {
          int v12 = "none";
        }
        int v13 = "amr_nb_oa";
      }
      else
      {
        if (v8 != 98) {
          goto LABEL_53;
        }
        int v12 = "amr_wb_be";
        if (v10 != 2) {
          int v12 = "none";
        }
        int v13 = "amr_wb_oa";
      }
      BOOL v15 = v10 == 3;
    }
    else
    {
      switch(v8)
      {
        case 'k':
          int v12 = "evs_wb_hf";
          if (v10 != 1) {
            int v12 = "none";
          }
          int v13 = "evs_wb_ch";
          break;
        case 'l':
          int v12 = "evs_swb_hf";
          if (v10 != 1) {
            int v12 = "none";
          }
          int v13 = "evs_swb_ch";
          break;
        case 'o':
          int v12 = "evs_nb_hf";
          if (v10 != 1) {
            int v12 = "none";
          }
          int v13 = "evs_nb_ch";
          break;
        default:
          goto LABEL_53;
      }
      BOOL v15 = v10 == 0;
    }
    if (v15) {
      uint64_t v11 = v13;
    }
    else {
      uint64_t v11 = v12;
    }
LABEL_53:
    v23.mSampleRate = (double)v9;
    *(_OWORD *)&v23.mFormatID = xmmword_1E25A1B50;
    *(_OWORD *)&v23.mBytesPerFrame = xmmword_1E25A1B60;
    _VCAudioDump_CreateFile((uint64_t)v5, (uint64_t)v7, (uint64_t)v11, (uint64_t)".rtpdump", &v23);
    uint64_t v16 = *((void *)v5 + 3);
    if (v16) {
      _VCAudioDumpFileWrapper_Update(v16, _rtpDumpHeader, 0x39u);
    }
    goto LABEL_55;
  }
  _VCAudioDump_CreateFile((uint64_t)v5, (uint64_t)v7, (uint64_t)"pcm", (uint64_t)".caf", v14);
LABEL_55:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v17 = VRTraceErrorLogLevelToCSTR();
    int v18 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v19 = *((unsigned __int16 *)v5 + 6);
      unsigned int v20 = v5[1];
      unsigned int v21 = v5[2];
      LODWORD(v23.mSampleRate) = 136316930;
      *(void *)((char *)&v23.mSampleRate + 4) = v17;
      LOWORD(v23.mFormatFlags) = 2080;
      *(void *)((char *)&v23.mFormatFlags + 2) = "VCAudioDump_Create";
      HIWORD(v23.mFramesPerPacket) = 1024;
      v23.mBytesPerFrame = 392;
      LOWORD(v23.mChannelsPerFrame) = 2048;
      *(void *)((char *)&v23.mChannelsPerFrame + 2) = v5;
      HIWORD(v23.mReserved) = 1024;
      unsigned int v24 = a1;
      __int16 v25 = 1024;
      unsigned int v26 = v20;
      __int16 v27 = 1024;
      int v28 = v19;
      __int16 v29 = 1024;
      unsigned int v30 = v21;
      _os_log_impl(&dword_1E1EA4000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio dump file=[%p] created successfully for tap point=%d, payloadType=%d, bandwidth=%d, rtpPayloadFormat=%d", (uint8_t *)&v23, 0x3Eu);
    }
  }
  return v5;
}

void _VCAudioDump_CreateFile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const AudioStreamBasicDescription *a5)
{
  int v7 = (char *)LogDumpUtility_CopyLogFilename(2, a2, 1, a3, a4);
  int v8 = (ExtAudioFileRef *)malloc_type_calloc(1uLL, 0x18uLL, 0x1020040EDCEB4C7uLL);
  if (v8)
  {
    if (!a5)
    {
      a5 = (const AudioStreamBasicDescription *)malloc_type_calloc(1uLL, 0x28uLL, 0x10000400A747E1EuLL);
      Format_Short((uint64_t)a5, 1, 24000);
    }
    *((_DWORD *)v8 + 4) = a5->mBytesPerFrame;
    CFAllocatorRef Default = CFAllocatorGetDefault();
    CFStringRef v10 = CFStringCreateWithCString(Default, v7, 0x8000100u);
    CFURLRef v11 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v10, kCFURLPOSIXPathStyle, 0);
    OSStatus v12 = AudioFileCreateWithURL(v11, 0x63616666u, a5, 1u, v8 + 1);
    if (v10) {
      CFRelease(v10);
    }
    if (v11) {
      CFRelease(v11);
    }
    if (v12)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCAudioDump_CreateFile_cold_3();
        }
      }
LABEL_20:
      free(v8);
      int v8 = 0;
      goto LABEL_21;
    }
    if (ExtAudioFileWrapAudioFileID(v8[1], 1u, v8))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCAudioDump_CreateFile_cold_2();
        }
      }
      goto LABEL_20;
    }
    if (ExtAudioFileWriteAsync(*v8, 0, 0))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCAudioDump_CreateFile_cold_1();
        }
      }
      goto LABEL_20;
    }
  }
LABEL_21:
  *(void *)(a1 + 24) = v8;
  free(v7);
}

void VCAudioDump_Finalize(void **a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = (int *)*a1;
    if (*a1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v3 = VRTraceErrorLogLevelToCSTR();
        OSStatus v4 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v5 = *v2;
          int v8 = 136315906;
          uint64_t v9 = v3;
          __int16 v10 = 2080;
          CFURLRef v11 = "VCAudioDump_Finalize";
          __int16 v12 = 1024;
          int v13 = 407;
          __int16 v14 = 1024;
          int v15 = v5;
          _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio dump finalized for tap point=%d", (uint8_t *)&v8, 0x22u);
        }
      }
      __int16 v6 = (ExtAudioFileRef *)*((void *)v2 + 3);
      if (v6)
      {
        ExtAudioFileDispose(*v6);
        AudioFileClose(v6[1]);
        free(v6);
        *((void *)v2 + 3) = 0;
      }
      int v7 = (void *)*((void *)v2 + 2);
      if (v7) {
        free(v7);
      }
      free(v2);
    }
    *a1 = 0;
  }
}

void sub_1E22BA11C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void VCAudioPlayerDTMF_Initialize(uint64_t a1, uint64_t a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = a1 + 53712;
  unsigned __int8 v3 = *(unsigned char *)(a2 + 48);
  *(unsigned char *)(a1 + 53712) = v3;
  unsigned __int8 v4 = *(unsigned char *)(a2 + 72);
  *(unsigned char *)(a1 + 53732) = v4;
  if (!(v4 | v3)) {
    return;
  }
  unint64_t v7 = a1 + 53792;
  int v8 = *(_DWORD *)(a1 + 52556);
  int v9 = 3 * v8;
  v8 *= 4;
  *(_DWORD *)(a1 + 53716) = v8;
  *(_DWORD *)(a1 + 53720) = v9;
  *(_DWORD *)(a1 + 53724) = v8;
  *(_DWORD *)(a1 + 53728) = *(_DWORD *)(a2 + 52);
  inSourceFormat.mSampleRate = NAN;
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&inSourceFormat.mFormatID = v10;
  *(_OWORD *)&inSourceFormat.mBytesPerFrame = v10;
  v23.mSampleRate = NAN;
  *(_OWORD *)&v23.mBytesPerFrame = v10;
  *(_OWORD *)&v23.mFormatID = v10;
  Format_Short((uint64_t)&inSourceFormat, *(_DWORD *)(*(void *)(a2 + 8) + 28), (int)**(double **)(a2 + 8));
  Format_Float((uint64_t)&v23, *(_DWORD *)(*(void *)(a2 + 8) + 28), (int)**(double **)(a2 + 8));
  if (v2 >= v7)
  {
    __break(0x5519u);
    return;
  }
  uint64_t v11 = (AudioConverterRef *)(v2 + 64);
  AudioConverterNew(&inSourceFormat, &v23, (AudioConverterRef *)(v2 + 64));
  if (*(void *)(v2 + 64))
  {
    *(void *)(v2 + 24) = 0;
    *(void *)(a1 + 53744) = 0;
    *(void *)(a1 + 53752) = 0;
    *(_DWORD *)(a1 + 53760) = 0;
    __int16 v12 = VCDTMFToneGenerator_Create();
    *(void *)(v2 + 56) = v12;
    int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (v12)
    {
      if (ErrorLogLevelForModule >= 7)
      {
        uint64_t v14 = VRTraceErrorLogLevelToCSTR();
        uint64_t v15 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = **(void **)(a2 + 8);
          int v18 = *(_DWORD *)(v2 + 4);
          int v17 = *(_DWORD *)(v2 + 8);
          int v20 = *(_DWORD *)(v2 + 12);
          int v19 = *(_DWORD *)(v2 + 16);
          *(_DWORD *)buf = 136317186;
          uint64_t v26 = v14;
          __int16 v27 = 2080;
          int v28 = "VCAudioPlayerDTMF_Initialize";
          __int16 v29 = 1024;
          int v30 = 63;
          __int16 v31 = 2048;
          unint64_t v32 = v2;
          __int16 v33 = 1024;
          int v34 = v19;
          __int16 v35 = 2048;
          uint64_t v36 = v16;
          __int16 v37 = 1024;
          int v38 = v17;
          __int16 v39 = 1024;
          int v40 = v18;
          __int16 v41 = 1024;
          int v42 = v20;
          _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] Successfully initialized DTMF: dtmfSampleRate=%d, audioSampleRate=%f maxTonePlaybackExtensionDuration=%d minTonePlaybackDuration=%d toneGapDuration=%d", buf, 0x48u);
        }
      }
      return;
    }
    if (ErrorLogLevelForModule >= 3)
    {
      uint64_t v22 = VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioPlayerDTMF_Initialize_cold_2(v22);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v21 = VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioPlayerDTMF_Initialize_cold_1(v21);
    }
  }
  if (*v11)
  {
    AudioConverterDispose(*v11);
    *uint64_t v11 = 0;
  }
}

uint64_t VCAudioPlayerDTMF_Finalize(uint64_t result)
{
  uint64_t v1 = result;
  if (*(unsigned char *)result || *(unsigned char *)(result + 20))
  {
    VCDTMFToneGenerator_Destroy((void **)(result + 56));
    BOOL result = *(void *)(v1 + 64);
    if (result)
    {
      BOOL result = AudioConverterDispose((AudioConverterRef)result);
      *(void *)(v1 + 64) = 0;
    }
  }
  return result;
}

uint64_t VCAudioPlayerDTMF_ShouldProcessDTMF(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = a1 + 53712;
  uint64_t v3 = *(int *)(a1 + 53736);
  if (!*(unsigned char *)(a1 + 53712) && !*(unsigned char *)(a1 + 53732)) {
    return 0;
  }
  unsigned __int8 v4 = (uint64_t *)(a1 + 35568);
  if (!JitterQueue_IsEmpty(*(void *)(a1 + 35568)) && !JitterQueue_IsNextFrameDTMF(*v4)) {
    *(_DWORD *)(v2 + 48) = 0;
  }
  unint64_t v5 = a1 + 53792;
  switch((int)v3)
  {
    case 0:
      if (!JitterQueue_IsNextFrameDTMF(*v4)) {
        goto LABEL_9;
      }
      uint64_t v6 = 1;
      *(_DWORD *)(v2 + 24) = 1;
      goto LABEL_19;
    case 1:
      goto LABEL_15;
    case 2:
      if (!JitterQueue_IsEmpty(*v4)
        && !JitterQueue_IsNextFrameDTMF(*v4)
        && *(_DWORD *)(v2 + 40) > *(unsigned __int16 *)(v2 + 30))
      {
        goto LABEL_17;
      }
      goto LABEL_16;
    case 3:
      if (JitterQueue_IsEmpty(*v4)) {
        goto LABEL_16;
      }
LABEL_15:
      if (JitterQueue_IsNextFrameDTMF(*v4))
      {
LABEL_16:
        uint64_t v6 = 1;
      }
      else
      {
LABEL_17:
        if (v2 >= v5)
        {
          __break(0x5519u);
          JUMPOUT(0x1E22BC344);
        }
        uint64_t v6 = 0;
        *(void *)(v2 + 24) = 0;
        *(_DWORD *)(v2 + 32) = 0;
        *(void *)(v2 + 40) = 0;
        *(_DWORD *)(v2 + 48) = 0;
      }
LABEL_19:
      if (v3 != *(_DWORD *)(v2 + 24) && (int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        uint64_t v7 = VRTraceErrorLogLevelToCSTR();
        int v8 = *MEMORY[0x1E4F47A50];
        int v9 = *MEMORY[0x1E4F47A50];
        if (*MEMORY[0x1E4F47A40])
        {
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            if (v3 > 3) {
              long long v10 = "Invalid";
            }
            else {
              long long v10 = off_1E6DB8848[v3];
            }
            uint64_t v12 = *(int *)(v2 + 24);
            if (v12 > 3) {
              uint64_t v13 = "Invalid";
            }
            else {
              uint64_t v13 = off_1E6DB8848[v12];
            }
            int v17 = 136316418;
            uint64_t v18 = v7;
            __int16 v19 = 2080;
            int v20 = "VCAudioPlayerDTMF_ShouldProcessDTMF";
            __int16 v21 = 1024;
            int v22 = 477;
            __int16 v23 = 2048;
            unint64_t v24 = v2;
            __int16 v25 = 2080;
            uint64_t v26 = v10;
            __int16 v27 = 2080;
            int v28 = v13;
            _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] Transitioning DTMF State currentState=%s ==> newState=%s", (uint8_t *)&v17, 0x3Au);
          }
        }
        else if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          if (v3 > 3) {
            uint64_t v11 = "Invalid";
          }
          else {
            uint64_t v11 = off_1E6DB8848[v3];
          }
          uint64_t v15 = *(int *)(v2 + 24);
          if (v15 > 3) {
            uint64_t v16 = "Invalid";
          }
          else {
            uint64_t v16 = off_1E6DB8848[v15];
          }
          int v17 = 136316418;
          uint64_t v18 = v7;
          __int16 v19 = 2080;
          int v20 = "VCAudioPlayerDTMF_ShouldProcessDTMF";
          __int16 v21 = 1024;
          int v22 = 477;
          __int16 v23 = 2048;
          unint64_t v24 = v2;
          __int16 v25 = 2080;
          uint64_t v26 = v11;
          __int16 v27 = 2080;
          int v28 = v16;
          _os_log_debug_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCAudioPlayerDTMF[%p] Transitioning DTMF State currentState=%s ==> newState=%s", (uint8_t *)&v17, 0x3Au);
        }
      }
      break;
    default:
LABEL_9:
      uint64_t v6 = 0;
      goto LABEL_19;
  }
  return v6;
}

void VCAudioPlayerDTMF_ProcessDTMF(_DWORD *a1, uint64_t a2)
{
  uint64_t v3 = a1 + 13140;
  *(void *)((char *)&v117[2] + 4) = *MEMORY[0x1E4F143B8];
  unsigned __int8 v4 = a1 + 8882;
  unint64_t v5 = a1 + 13428;
  uint64_t v108 = a1 + 13439;
  int v107 = a1 + 13448;
  uint64_t v106 = a1 + 13138;
  do
  {
    while (1)
    {
      JitterQueue_Purge(*((void *)v4 + 5), (uint64_t (*)(void))_VCAudioPlayerDTMF_ShouldPurgeJitterQueue);
      unsigned int v6 = v3[294];
      if (v6 == 3)
      {
        ChannelCFIndex Count = VCAudioBufferList_GetChannelCount(*(void *)a2);
        if (ChannelCount)
        {
          unsigned int v10 = 0;
          while (1)
          {
            memset(buf, 0, sizeof(buf));
            VCAudioBufferList_GetSizedBufferAtIndex(*(void *)a2, v10, 0, buf);
            size_t v11 = (*v3 * *(_DWORD *)(a2 + 8));
            if (*(void *)&buf[8] < v11) {
              break;
            }
            bzero(*(void **)buf, v11);
            if (ChannelCount == ++v10) {
              goto LABEL_13;
            }
          }
LABEL_162:
          __break(0x5519u);
        }
LABEL_13:
        unsigned int v12 = v3[299] + *(_DWORD *)(a2 + 8);
        v3[299] = v12;
        if (v12 >= v3[291])
        {
          v3[294] = 1;
          v3[298] = 0;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
          goto LABEL_45;
        }
        uint64_t v13 = VRTraceErrorLogLevelToCSTR();
        uint64_t v14 = *MEMORY[0x1E4F47A50];
        uint64_t v15 = *MEMORY[0x1E4F47A50];
        if (!*MEMORY[0x1E4F47A40])
        {
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            int v57 = *(_DWORD *)(a2 + 8);
            int v58 = v3[291];
            int v59 = v3[299];
            *(_DWORD *)buf = 136316674;
            *(void *)&uint8_t buf[4] = v13;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "_VCAudioPlayerDTMF_ProcessDTMFStatePlayingGap";
            *(_WORD *)&buf[22] = 1024;
            int v112 = 398;
            __int16 v113 = 2048;
            *(void *)int v114 = v5;
            *(_WORD *)&v114[8] = 1024;
            *(_DWORD *)uint64_t v115 = v57;
            *(_WORD *)&v115[4] = 1024;
            *(_DWORD *)&v115[6] = v58;
            *(_WORD *)&v115[10] = 1024;
            *(_DWORD *)&v115[12] = v59;
            _os_log_debug_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCAudioPlayerDTMF[%p] Playing Gap samplesCount=%d maxToneGapDuration=%d toneGapDurationCount=%d ", buf, 0x38u);
          }
          goto LABEL_45;
        }
        BOOL v8 = 0;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          int v16 = *(_DWORD *)(a2 + 8);
          int v17 = v3[291];
          int v18 = v3[299];
          *(_DWORD *)buf = 136316674;
          *(void *)&uint8_t buf[4] = v13;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "_VCAudioPlayerDTMF_ProcessDTMFStatePlayingGap";
          *(_WORD *)&buf[22] = 1024;
          int v112 = 398;
          __int16 v113 = 2048;
          *(void *)int v114 = v5;
          *(_WORD *)&v114[8] = 1024;
          *(_DWORD *)uint64_t v115 = v16;
          *(_WORD *)&v115[4] = 1024;
          *(_DWORD *)&v115[6] = v17;
          *(_WORD *)&v115[10] = 1024;
          *(_DWORD *)&v115[12] = v18;
          _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] Playing Gap samplesCount=%d maxToneGapDuration=%d toneGapDurationCount=%d ", buf, 0x38u);
LABEL_45:
          BOOL v8 = 0;
          goto LABEL_122;
        }
        goto LABEL_122;
      }
      if (v6 == 2)
      {
        int v110 = -1431655766;
        NextFrameint Timestamp = JitterQueue_GetNextFrameTimestamp(*((void *)v4 + 5), &v110);
        unsigned int v20 = v3[298];
        if (v20 < *((unsigned __int16 *)v3 + 591))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            uint64_t v21 = VRTraceErrorLogLevelToCSTR();
            int v22 = *MEMORY[0x1E4F47A50];
            __int16 v23 = *MEMORY[0x1E4F47A50];
            if (*MEMORY[0x1E4F47A40])
            {
              int v24 = 0;
              if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_109;
              }
              int v25 = v3[298];
              int v26 = *((unsigned __int16 *)v3 + 591);
              *(_DWORD *)buf = 136316418;
              *(void *)&uint8_t buf[4] = v21;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = "_VCAudioPlayerDTMF_GetNextDTMFFrame";
              *(_WORD *)&buf[22] = 1024;
              int v112 = 260;
              __int16 v113 = 2048;
              *(void *)int v114 = v5;
              *(_WORD *)&v114[8] = 1024;
              *(_DWORD *)uint64_t v115 = v25;
              *(_WORD *)&v115[4] = 1024;
              *(_DWORD *)&v115[6] = v26;
              _os_log_impl(&dword_1E1EA4000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] Continue with last event duration, lastEventDurationCount=%d lastEventInfo.duration=%d", buf, 0x32u);
            }
            else if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
            {
              int v40 = v3[298];
              int v41 = *((unsigned __int16 *)v3 + 591);
              *(_DWORD *)buf = 136316418;
              *(void *)&uint8_t buf[4] = v21;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = "_VCAudioPlayerDTMF_GetNextDTMFFrame";
              *(_WORD *)&buf[22] = 1024;
              int v112 = 260;
              __int16 v113 = 2048;
              *(void *)int v114 = v5;
              *(_WORD *)&v114[8] = 1024;
              *(_DWORD *)uint64_t v115 = v40;
              *(_WORD *)&v115[4] = 1024;
              *(_DWORD *)&v115[6] = v41;
              _os_log_debug_impl(&dword_1E1EA4000, v22, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCAudioPlayerDTMF[%p] Continue with last event duration, lastEventDurationCount=%d lastEventInfo.duration=%d", buf, 0x32u);
            }
          }
          goto LABEL_108;
        }
        if (!v20)
        {
LABEL_27:
          unint64_t v27 = JitterQueue_Pop(*((void *)v4 + 5));
          if (v27)
          {
            unint64_t v28 = v27;
            if (*(_DWORD *)(v27 + 1144) == 4)
            {
              unsigned int v29 = *(_DWORD *)(v27 + 16);
              if ((v29 & 0xF0) == 0)
              {
                unsigned int v30 = (unsigned __int16)bswap32(v29);
                if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
                {
                  uint64_t v33 = VRTraceErrorLogLevelToCSTR();
                  int v34 = *MEMORY[0x1E4F47A50];
                  __int16 v35 = *MEMORY[0x1E4F47A50];
                  if (*MEMORY[0x1E4F47A40])
                  {
                    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                    {
                      int v36 = *(_DWORD *)(v28 + 4);
                      int v37 = *(unsigned __int16 *)(v28 + 10);
                      int v38 = *(_DWORD *)(v28 + 12);
                      *(_DWORD *)buf = 136317442;
                      *(void *)&uint8_t buf[4] = v33;
                      *(_WORD *)&unsigned char buf[12] = 2080;
                      *(void *)&buf[14] = "_VCAudioPlayerDTMF_ParseDTMFEventPacket";
                      *(_WORD *)&buf[22] = 1024;
                      int v112 = 174;
                      __int16 v113 = 1024;
                      *(_DWORD *)int v114 = v29;
                      *(_WORD *)&v114[4] = 1024;
                      *(_DWORD *)&v114[6] = (v29 >> 15) & 1;
                      *(_WORD *)uint64_t v115 = 1024;
                      *(_DWORD *)&v115[2] = (v29 >> 8) & 0x3F;
                      *(_WORD *)&v115[6] = 1024;
                      *(_DWORD *)&v115[8] = v30;
                      *(_WORD *)&v115[12] = 1024;
                      *(_DWORD *)&v115[14] = v36;
                      __int16 v116 = 1024;
                      LODWORD(v117[0]) = v37;
                      WORD2(v117[0]) = 1024;
                      *(_DWORD *)((char *)v117 + 6) = v38;
                      _os_log_impl(&dword_1E1EA4000, v34, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Parsed DTMF EventInfo: eventType=%d isEnd=%d volume=%d duration=%d, RTP Header Info: isMarker=%d seqNumber=%d rtpTimeStamp=%d", buf, 0x46u);
                    }
                  }
                  else if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
                  {
                    int v60 = *(_DWORD *)(v28 + 4);
                    int v61 = *(unsigned __int16 *)(v28 + 10);
                    int v62 = *(_DWORD *)(v28 + 12);
                    *(_DWORD *)buf = 136317442;
                    *(void *)&uint8_t buf[4] = v33;
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = "_VCAudioPlayerDTMF_ParseDTMFEventPacket";
                    *(_WORD *)&buf[22] = 1024;
                    int v112 = 174;
                    __int16 v113 = 1024;
                    *(_DWORD *)int v114 = v29;
                    *(_WORD *)&v114[4] = 1024;
                    *(_DWORD *)&v114[6] = (v29 >> 15) & 1;
                    *(_WORD *)uint64_t v115 = 1024;
                    *(_DWORD *)&v115[2] = (v29 >> 8) & 0x3F;
                    *(_WORD *)&v115[6] = 1024;
                    *(_DWORD *)&v115[8] = v30;
                    *(_WORD *)&v115[12] = 1024;
                    *(_DWORD *)&v115[14] = v60;
                    __int16 v116 = 1024;
                    LODWORD(v117[0]) = v61;
                    WORD2(v117[0]) = 1024;
                    *(_DWORD *)((char *)v117 + 6) = v62;
                    _os_log_debug_impl(&dword_1E1EA4000, v34, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Parsed DTMF EventInfo: eventType=%d isEnd=%d volume=%d duration=%d, RTP Header Info: isMarker=%d seqNumber=%d rtpTimeStamp=%d", buf, 0x46u);
                  }
                }
                LODWORD(v31) = *v106;
                LODWORD(v32) = v3[292];
                int v48 = (int)((double)v31 / (double)v32 * (double)v30);
                if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
                {
                  uint64_t v49 = VRTraceErrorLogLevelToCSTR();
                  char v50 = *MEMORY[0x1E4F47A50];
                  int v51 = *MEMORY[0x1E4F47A50];
                  if (*MEMORY[0x1E4F47A40])
                  {
                    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136315906;
                      *(void *)&uint8_t buf[4] = v49;
                      *(_WORD *)&unsigned char buf[12] = 2080;
                      *(void *)&buf[14] = "_VCAudioPlayerDTMF_ProcessNextDTMFFrameForCurrentEvent";
                      *(_WORD *)&buf[22] = 1024;
                      int v112 = 205;
                      __int16 v113 = 1024;
                      *(_DWORD *)int v114 = (unsigned __int16)v48;
                      _os_log_impl(&dword_1E1EA4000, v50, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF Updated DTMF duration=%d", buf, 0x22u);
                      if ((v29 & 0x8000) != 0)
                      {
LABEL_88:
                        unsigned int v53 = (unsigned __int16)v48;
                        if (v3[289] > (unsigned __int16)v48)
                        {
                          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
                          {
                            uint64_t v63 = VRTraceErrorLogLevelToCSTR();
                            __int16 v64 = *MEMORY[0x1E4F47A50];
                            long long v65 = *MEMORY[0x1E4F47A50];
                            if (*MEMORY[0x1E4F47A40])
                            {
                              if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
                              {
                                int v66 = v3[289];
                                *(_DWORD *)buf = 136316418;
                                *(void *)&uint8_t buf[4] = v63;
                                *(_WORD *)&unsigned char buf[12] = 2080;
                                *(void *)&buf[14] = "_VCAudioPlayerDTMF_ProcessNextDTMFFrameForCurrentEvent";
                                *(_WORD *)&buf[22] = 1024;
                                int v112 = 209;
                                __int16 v113 = 2048;
                                *(void *)int v114 = v5;
                                *(_WORD *)&v114[8] = 1024;
                                *(_DWORD *)uint64_t v115 = v53;
                                *(_WORD *)&v115[4] = 1024;
                                *(_DWORD *)&v115[6] = v66;
                                _os_log_impl(&dword_1E1EA4000, v64, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] Reset evenDuration for endFrame oldValue=%d newValue=%d", buf, 0x32u);
                              }
                            }
                            else if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
                            {
                              int v88 = v3[289];
                              *(_DWORD *)buf = 136316418;
                              *(void *)&uint8_t buf[4] = v63;
                              *(_WORD *)&unsigned char buf[12] = 2080;
                              *(void *)&buf[14] = "_VCAudioPlayerDTMF_ProcessNextDTMFFrameForCurrentEvent";
                              *(_WORD *)&buf[22] = 1024;
                              int v112 = 209;
                              __int16 v113 = 2048;
                              *(void *)int v114 = v5;
                              *(_WORD *)&v114[8] = 1024;
                              *(_DWORD *)uint64_t v115 = v53;
                              *(_WORD *)&v115[4] = 1024;
                              *(_DWORD *)&v115[6] = v88;
                              _os_log_debug_impl(&dword_1E1EA4000, v64, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCAudioPlayerDTMF[%p] Reset evenDuration for endFrame oldValue=%d newValue=%d", buf, 0x32u);
                            }
                          }
                          unsigned int v53 = *((unsigned __int16 *)v3 + 578);
                        }
                        unsigned int v52 = v3[298];
                        if (v52 > v53)
                        {
                          v3[294] = 3;
                          v3[299] = 0;
                          int v24 = 1;
                          goto LABEL_109;
                        }
                        goto LABEL_98;
                      }
LABEL_76:
                      unsigned int v52 = v3[298];
                      LOWORD(v53) = v48;
                      if (v52 > (unsigned __int16)v48)
                      {
                        v3[300] = v52 - (unsigned __int16)v48;
                        goto LABEL_106;
                      }
LABEL_98:
                      if (!v52)
                      {
                        JitterQueue_SetLastDecodedDTMFFrameTimestamp(*((void *)v4 + 5), *(_DWORD *)(v28 + 12));
                        int v67 = v29;
                        int v68 = VCDTMFToneGenerator_Reinit(*((void *)v3 + 151), v29, (v29 >> 8) & 0x3F, *v106);
                        if ((v68 & 0x80000000) == 0)
                        {
                          if (*((unsigned char *)v3 + 1172))
                          {
                            long long v69 = (void (*)(void, void))*((void *)v3 + 160);
                            if (v69)
                            {
                              __int16 v70 = &_VCAudioPlayerDTMF_KeysForEvents[v29];
                              if (v70 >= _preferredDecodingFormatMappings || v70 < _VCAudioPlayerDTMF_KeysForEvents) {
                                goto LABEL_162;
                              }
                              v69(*((void *)v3 + 159), *v70);
                            }
                          }
                          int v71 = v3[306] + 1;
                          v3[306] = v71;
                          v3[84] = v71;
                          goto LABEL_106;
                        }
                        int v101 = v68;
                        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                        {
                          uint64_t v102 = VRTraceErrorLogLevelToCSTR();
                          double v103 = *MEMORY[0x1E4F47A50];
                          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)buf = 136316162;
                            *(void *)&uint8_t buf[4] = v102;
                            *(_WORD *)&unsigned char buf[12] = 2080;
                            *(void *)&buf[14] = "_VCAudioPlayerDTMF_ProcessNextDTMFFrameForCurrentEvent";
                            *(_WORD *)&buf[22] = 1024;
                            int v112 = 235;
                            __int16 v113 = 1024;
                            *(_DWORD *)int v114 = v67;
                            *(_WORD *)&v114[4] = 1024;
                            *(_DWORD *)&v114[6] = v101;
                            _os_log_error_impl(&dword_1E1EA4000, v103, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to initialize DTMFToneGenerator, event=%d result=%d", buf, 0x28u);
                          }
                        }
LABEL_108:
                        int v24 = 0;
LABEL_109:
                        if (_VCAudioPlayerDTMF_GenerateSamples((uint64_t)a1, a2))
                        {
                          unsigned int v72 = v3[298];
                          unsigned int v73 = *((unsigned __int16 *)v3 + 591);
                          int v74 = *(_DWORD *)(a2 + 8);
                          if (v72 >= v73) {
                            v3[300] += v74;
                          }
                          unsigned int v75 = v74 + v72;
                          v3[298] = v75;
                          if (v75 >= v73)
                          {
                            if (*((char *)v3 + 1181) < 0)
                            {
                              v3[297] = v3[296];
                              if (v5 >= v107) {
                                goto LABEL_162;
                              }
                              JitterQueue_Purge(*((void *)v4 + 5), (uint64_t (*)(void))_VCAudioPlayerDTMF_ShouldPurgeJitterQueue);
                              if (JitterQueue_IsNextFrameDTMF(*((void *)v4 + 5)))
                              {
                                *uint64_t v108 = 0;
                                int v76 = 3;
                              }
                              else
                              {
                                int v76 = 1;
                              }
                              v3[294] = v76;
                            }
                          }
                          else
                          {
                            if (v5 >= v107) {
                              goto LABEL_162;
                            }
                            JitterQueue_Purge(*((void *)v4 + 5), (uint64_t (*)(void))_VCAudioPlayerDTMF_ShouldPurgeJitterQueue);
                          }
                        }
                        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                        {
                          uint64_t v89 = VRTraceErrorLogLevelToCSTR();
                          __int16 v90 = *MEMORY[0x1E4F47A50];
                          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
                          {
                            int v91 = *((unsigned __int8 *)v3 + 1180);
                            *(_DWORD *)buf = 136315906;
                            *(void *)&uint8_t buf[4] = v89;
                            *(_WORD *)&unsigned char buf[12] = 2080;
                            *(void *)&buf[14] = "_VCAudioPlayerDTMF_ProcessDTMFStatePlayingTone";
                            *(_WORD *)&buf[22] = 1024;
                            int v112 = 353;
                            __int16 v113 = 1024;
                            *(_DWORD *)int v114 = v91;
                            _os_log_error_impl(&dword_1E1EA4000, v90, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to generate DTMF samples for event=%d", buf, 0x22u);
                          }
                        }
                        goto LABEL_121;
                      }
LABEL_106:
                      a1[6] = *(_DWORD *)(v28 + 12);
                      v3[295] = (unsigned __int16)v29 | ((unsigned __int16)v53 << 16);
                      v3[296] = *(_DWORD *)(v28 + 12);
                      if (v28 >= v28 + 1272) {
                        goto LABEL_162;
                      }
                      (*(void (**)(void, unint64_t))(v28 + 1200))(*(void *)(v28 + 1208), v28);
                      goto LABEL_108;
                    }
                  }
                  else if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136315906;
                    *(void *)&uint8_t buf[4] = v49;
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = "_VCAudioPlayerDTMF_ProcessNextDTMFFrameForCurrentEvent";
                    *(_WORD *)&buf[22] = 1024;
                    int v112 = 205;
                    __int16 v113 = 1024;
                    *(_DWORD *)int v114 = (unsigned __int16)v48;
                    _os_log_debug_impl(&dword_1E1EA4000, v50, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCAudioPlayerDTMF Updated DTMF duration=%d", buf, 0x22u);
                    if ((v29 & 0x8000) != 0) {
                      goto LABEL_88;
                    }
                    goto LABEL_76;
                  }
                }
                if ((v29 & 0x8000) != 0) {
                  goto LABEL_88;
                }
                goto LABEL_76;
              }
              if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
                goto LABEL_155;
              }
              uint64_t v97 = VRTraceErrorLogLevelToCSTR();
              __int16 v98 = *MEMORY[0x1E4F47A50];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                goto LABEL_155;
              }
              *(_DWORD *)buf = 136315906;
              *(void *)&uint8_t buf[4] = v97;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = "_VCAudioPlayerDTMF_ParseDTMFEventPacket";
              *(_WORD *)&buf[22] = 1024;
              int v112 = 170;
              __int16 v113 = 1024;
              *(_DWORD *)int v114 = v29;
              CTFramesetterRef v95 = v98;
              __int16 v96 = " [%s] %s:%d Received Invalid DTMF eventType=%d";
            }
            else
            {
              if ((int)VRTraceGetErrorLogLevelForModule() < 3
                || (uint64_t v92 = VRTraceErrorLogLevelToCSTR(),
                    CFAttributedStringRef v93 = *MEMORY[0x1E4F47A50],
                    !os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)))
              {
LABEL_155:
                v3[294] = 1;
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  uint64_t v99 = VRTraceErrorLogLevelToCSTR();
                  uint64_t v100 = *MEMORY[0x1E4F47A50];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136315650;
                    *(void *)&uint8_t buf[4] = v99;
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = "_VCAudioPlayerDTMF_ProcessNextDTMFFrameForCurrentEvent";
                    *(_WORD *)&buf[22] = 1024;
                    int v112 = 200;
                    _os_log_error_impl(&dword_1E1EA4000, v100, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to parse DTMF payload", buf, 0x1Cu);
                  }
                }
                goto LABEL_80;
              }
              int v94 = *(_DWORD *)(v28 + 1144);
              *(_DWORD *)buf = 136315906;
              *(void *)&uint8_t buf[4] = v92;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = "_VCAudioPlayerDTMF_ParseDTMFEventPacket";
              *(_WORD *)&buf[22] = 1024;
              int v112 = 155;
              __int16 v113 = 1024;
              *(_DWORD *)int v114 = v94;
              CTFramesetterRef v95 = v93;
              __int16 v96 = " [%s] %s:%d Invalid DTMF payloadSize=%d";
            }
            _os_log_error_impl(&dword_1E1EA4000, v95, OS_LOG_TYPE_ERROR, v96, buf, 0x22u);
            goto LABEL_155;
          }
LABEL_66:
          v3[294] = 1;
LABEL_80:
          v3[297] = v3[296];
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            uint64_t v54 = VRTraceErrorLogLevelToCSTR();
            int v55 = *MEMORY[0x1E4F47A50];
            int v56 = *MEMORY[0x1E4F47A50];
            if (*MEMORY[0x1E4F47A40])
            {
              if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315906;
                *(void *)&uint8_t buf[4] = v54;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = "_VCAudioPlayerDTMF_ProcessDTMFStatePlayingTone";
                *(_WORD *)&buf[22] = 1024;
                int v112 = 350;
                __int16 v113 = 2048;
                *(void *)int v114 = v5;
                _os_log_impl(&dword_1E1EA4000, v55, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] _VCAudioPlayerDTMF_ProcessDTMFStatePlayingTone Skipped", buf, 0x26u);
              }
            }
            else if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136315906;
              *(void *)&uint8_t buf[4] = v54;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = "_VCAudioPlayerDTMF_ProcessDTMFStatePlayingTone";
              *(_WORD *)&buf[22] = 1024;
              int v112 = 350;
              __int16 v113 = 2048;
              *(void *)int v114 = v5;
              _os_log_debug_impl(&dword_1E1EA4000, v55, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCAudioPlayerDTMF[%p] _VCAudioPlayerDTMF_ProcessDTMFStatePlayingTone Skipped", buf, 0x26u);
            }
          }
          int v24 = 1;
LABEL_121:
          BOOL v8 = v24 != 0;
          goto LABEL_122;
        }
        if (NextFrameTimestamp)
        {
          if (v110 == v3[296]) {
            goto LABEL_27;
          }
          if (JitterQueue_IsEmpty(*((void *)v4 + 5)) || v110 != v3[296]) {
            goto LABEL_52;
          }
        }
        else if (JitterQueue_IsEmpty(*((void *)v4 + 5)))
        {
LABEL_52:
          if (v3[300] == v3[290])
          {
            v3[294] = 3;
            *(void *)uint64_t v108 = 0;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
            {
              uint64_t v42 = VRTraceErrorLogLevelToCSTR();
              uint64_t v43 = *MEMORY[0x1E4F47A50];
              int v44 = *MEMORY[0x1E4F47A50];
              if (*MEMORY[0x1E4F47A40])
              {
                if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315906;
                  *(void *)&uint8_t buf[4] = v42;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = "_VCAudioPlayerDTMF_GetNextDTMFFrame";
                  *(_WORD *)&buf[22] = 1024;
                  int v112 = 274;
                  __int16 v113 = 2048;
                  *(void *)int v114 = v5;
                  _os_log_impl(&dword_1E1EA4000, v43, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] Exiting from Tone extension window", buf, 0x26u);
                }
              }
              else if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136315906;
                *(void *)&uint8_t buf[4] = v42;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = "_VCAudioPlayerDTMF_GetNextDTMFFrame";
                *(_WORD *)&buf[22] = 1024;
                int v112 = 274;
                __int16 v113 = 2048;
                *(void *)int v114 = v5;
                _os_log_debug_impl(&dword_1E1EA4000, v43, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCAudioPlayerDTMF[%p] Exiting from Tone extension window", buf, 0x26u);
              }
            }
            goto LABEL_80;
          }
        }
        if (v3[298] != *((unsigned __int16 *)v3 + 591)
          || JitterQueue_IsNextFrameMarkerSet(*((void *)v4 + 5))
          || *((__int16 *)v3 + 591) != -1)
        {
          goto LABEL_108;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          uint64_t v45 = VRTraceErrorLogLevelToCSTR();
          int v46 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            *(void *)&uint8_t buf[4] = v45;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "_VCAudioPlayerDTMF_GetNextDTMFFrame";
            *(_WORD *)&buf[22] = 1024;
            int v112 = 278;
            __int16 v113 = 2048;
            *(void *)int v114 = v5;
            _os_log_impl(&dword_1E1EA4000, v46, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] Discard the long event", buf, 0x26u);
          }
        }
        unint64_t v47 = JitterQueue_Pop(*((void *)v4 + 5));
        if (v47)
        {
          if (v47 >= v47 + 1272) {
            goto LABEL_162;
          }
          (*(void (**)(void))(v47 + 1200))(*(void *)(v47 + 1208));
        }
        goto LABEL_66;
      }
      if (v6 != 1) {
        goto LABEL_8;
      }
      *(_DWORD *)buf = -1431655766;
      BOOL v7 = JitterQueue_GetNextFrameTimestamp(*((void *)v4 + 5), buf);
      if (!*v108
        && v3[296]
        && (BOOL v39 = v7, JitterQueue_IsNextFrameDTMF(*((void *)v4 + 5)))
        && (JitterQueue_IsNextFrameMarkerSet(*((void *)v4 + 5)) || v39 && *(_DWORD *)buf > v3[296])
        || JitterQueue_IsEmpty(*((void *)v4 + 5)))
      {
        v3[294] = 3;
        v3[299] = 0;
LABEL_8:
        BOOL v8 = 1;
        goto LABEL_122;
      }
      if (!JitterQueue_IsNextFrameDTMF(*((void *)v4 + 5))) {
        goto LABEL_45;
      }
      if (v5 >= v107) {
        goto LABEL_162;
      }
      v3[296] = 0;
      *((void *)v3 + 149) = 0;
      v3[300] = 0;
      BOOL v8 = 1;
      *((void *)v3 + 147) = 2;
LABEL_122:
      if (v6 == v3[294] || (int)VRTraceGetErrorLogLevelForModule() < 8) {
        goto LABEL_135;
      }
      uint64_t v77 = VRTraceErrorLogLevelToCSTR();
      long long v78 = *MEMORY[0x1E4F47A50];
      long long v79 = *MEMORY[0x1E4F47A50];
      if (!*MEMORY[0x1E4F47A40]) {
        break;
      }
      if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
      {
        long long v80 = "Invalid";
        if (v6 <= 3) {
          long long v80 = off_1E6DB8848[v6];
        }
        uint64_t v81 = (int)v3[294];
        int v82 = "Invalid";
        if (v81 <= 3) {
          int v82 = off_1E6DB8848[v81];
        }
        *(_DWORD *)buf = 136316674;
        uint64_t v83 = "NO";
        if (v8) {
          uint64_t v83 = "YES";
        }
        *(void *)&uint8_t buf[4] = v77;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "VCAudioPlayerDTMF_ProcessDTMF";
        *(_WORD *)&buf[22] = 1024;
        int v112 = 505;
        __int16 v113 = 2048;
        *(void *)int v114 = v5;
        *(_WORD *)&v114[8] = 2080;
        *(void *)uint64_t v115 = v80;
        *(_WORD *)&v115[8] = 2080;
        *(void *)&v115[10] = v82;
        __int16 v116 = 2080;
        v117[0] = v83;
        _os_log_impl(&dword_1E1EA4000, v78, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] Transitioning DTMF State currentState=%s ==> newState=%s shouldContinue=%s", buf, 0x44u);
        if (!v8) {
          goto LABEL_161;
        }
      }
      else
      {
LABEL_135:
        if (!v8) {
          goto LABEL_161;
        }
      }
    }
    if (!os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_135;
    }
    __int16 v84 = "Invalid";
    if (v6 <= 3) {
      __int16 v84 = off_1E6DB8848[v6];
    }
    uint64_t v85 = (int)v3[294];
    __int16 v86 = "Invalid";
    if (v85 <= 3) {
      __int16 v86 = off_1E6DB8848[v85];
    }
    *(_DWORD *)buf = 136316674;
    unsigned int v87 = "NO";
    if (v8) {
      unsigned int v87 = "YES";
    }
    *(void *)&uint8_t buf[4] = v77;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "VCAudioPlayerDTMF_ProcessDTMF";
    *(_WORD *)&buf[22] = 1024;
    int v112 = 505;
    __int16 v113 = 2048;
    *(void *)int v114 = v5;
    *(_WORD *)&v114[8] = 2080;
    *(void *)uint64_t v115 = v84;
    *(_WORD *)&v115[8] = 2080;
    *(void *)&v115[10] = v86;
    __int16 v116 = 2080;
    v117[0] = v87;
    _os_log_debug_impl(&dword_1E1EA4000, v78, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCAudioPlayerDTMF[%p] Transitioning DTMF State currentState=%s ==> newState=%s shouldContinue=%s", buf, 0x44u);
  }
  while (v8);
LABEL_161:
  int v104 = *(_DWORD *)(a2 + 8);
  a1[6] += v104;
  *v4 += v104;
  int v105 = a1[43] + v104;
  a1[42] = 0;
  a1[43] = v105;
  a1[77] += v104;
  a1[76] = 0;
}

uint64_t _VCAudioPlayerDTMF_ShouldPurgeJitterQueue(uint64_t a1, uint64_t a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 1196) != 117)
  {
    unsigned int v13 = *(_DWORD *)(a2 + 40);
    unsigned int v14 = *(unsigned __int16 *)(a2 + 30);
    if (v13 >= v14)
    {
      if (v13 != v14)
      {
        int v15 = 0;
        BOOL v8 = 0;
        goto LABEL_20;
      }
      int v15 = 2;
      unsigned int v14 = *(_DWORD *)(a2 + 40);
    }
    else
    {
      int v15 = 1;
    }
    BOOL v8 = *(_DWORD *)(a1 + 12) - (*(_DWORD *)(a2 + 32) + v14) > 0x7FFFFFFE;
LABEL_20:
    if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
      return v8;
    }
    uint64_t v22 = VRTraceErrorLogLevelToCSTR();
    __int16 v23 = *MEMORY[0x1E4F47A50];
    int v24 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        int v25 = *(_DWORD *)(a1 + 1196);
        int v26 = *(_DWORD *)(a1 + 12);
        int v27 = *(_DWORD *)(a2 + 32) + *(unsigned __int16 *)(a2 + 30);
        int v37 = 136317186;
        uint64_t v38 = v22;
        __int16 v39 = 2080;
        int v40 = "_VCAudioPlayerDTMF_ShouldPurgeJitterQueue";
        __int16 v41 = 1024;
        int v42 = 130;
        __int16 v43 = 2048;
        uint64_t v44 = a2;
        __int16 v45 = 1024;
        int v46 = v25;
        __int16 v47 = 1024;
        int v48 = v26;
        __int16 v49 = 1024;
        BOOL v50 = v27;
        __int16 v51 = 1024;
        int v52 = v15;
        __int16 v53 = 1024;
        BOOL v54 = v8;
        unsigned int v10 = " [%s] %s:%d VCAudioPlayerDTMF[%p] Should Purge audioFrames, payloadType=%d frameTimeStamp=%d lastEventMaxT"
              "imeStamp=%d audioFrameCase=%d result=%d";
        size_t v11 = v23;
        uint32_t v12 = 68;
        goto LABEL_24;
      }
      return v8;
    }
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG)) {
      return v8;
    }
    int v28 = *(_DWORD *)(a1 + 1196);
    int v29 = *(_DWORD *)(a1 + 12);
    int v30 = *(_DWORD *)(a2 + 32) + *(unsigned __int16 *)(a2 + 30);
    int v37 = 136317186;
    uint64_t v38 = v22;
    __int16 v39 = 2080;
    int v40 = "_VCAudioPlayerDTMF_ShouldPurgeJitterQueue";
    __int16 v41 = 1024;
    int v42 = 130;
    __int16 v43 = 2048;
    uint64_t v44 = a2;
    __int16 v45 = 1024;
    int v46 = v28;
    __int16 v47 = 1024;
    int v48 = v29;
    __int16 v49 = 1024;
    BOOL v50 = v30;
    __int16 v51 = 1024;
    int v52 = v15;
    __int16 v53 = 1024;
    BOOL v54 = v8;
    unint64_t v31 = " [%s] %s:%d VCAudioPlayerDTMF[%p] Should Purge audioFrames, payloadType=%d frameTimeStamp=%d lastEventMaxTimeS"
          "tamp=%d audioFrameCase=%d result=%d";
    unint64_t v32 = v23;
    uint32_t v33 = 68;
LABEL_33:
    _os_log_debug_impl(&dword_1E1EA4000, v32, OS_LOG_TYPE_DEBUG, v31, (uint8_t *)&v37, v33);
    return v8;
  }
  int v4 = *(_DWORD *)(a1 + 12);
  if (v4 == *(_DWORD *)(a2 + 36))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      unsigned int v6 = *MEMORY[0x1E4F47A50];
      BOOL v7 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        BOOL v8 = 1;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v9 = *(_DWORD *)(a2 + 32);
          int v37 = 136316418;
          uint64_t v38 = v5;
          __int16 v39 = 2080;
          int v40 = "_VCAudioPlayerDTMF_ShouldPurgeJitterQueue";
          __int16 v41 = 1024;
          int v42 = 114;
          __int16 v43 = 2048;
          uint64_t v44 = a2;
          __int16 v45 = 1024;
          int v46 = v9;
          __int16 v47 = 1024;
          int v48 = 1;
          unsigned int v10 = " [%s] %s:%d VCAudioPlayerDTMF[%p] Should Purge re-transmitted end events, eventTimeStamp=%d, result=%d";
          size_t v11 = v6;
          uint32_t v12 = 50;
LABEL_24:
          _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v37, v12);
          return v8;
        }
        return v8;
      }
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
        _VCAudioPlayerDTMF_ShouldPurgeJitterQueue_cold_1(v5, a2, v6);
      }
    }
    return 1;
  }
  if (*(_DWORD *)(a2 + 24) != 3) {
    return 0;
  }
  int v16 = *(_DWORD *)(a2 + 32);
  BOOL v8 = v4 == v16;
  if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
    return v8;
  }
  uint64_t v17 = VRTraceErrorLogLevelToCSTR();
  int v18 = *MEMORY[0x1E4F47A50];
  __int16 v19 = *MEMORY[0x1E4F47A50];
  if (!*MEMORY[0x1E4F47A40])
  {
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG)) {
      return v8;
    }
    int v35 = *(_DWORD *)(a1 + 12);
    int v36 = *(_DWORD *)(a2 + 32);
    int v37 = 136316674;
    uint64_t v38 = v17;
    __int16 v39 = 2080;
    int v40 = "_VCAudioPlayerDTMF_ShouldPurgeJitterQueue";
    __int16 v41 = 1024;
    int v42 = 118;
    __int16 v43 = 2048;
    uint64_t v44 = a2;
    __int16 v45 = 1024;
    int v46 = v35;
    __int16 v47 = 1024;
    int v48 = v36;
    __int16 v49 = 1024;
    BOOL v50 = v4 == v16;
    unint64_t v31 = " [%s] %s:%d VCAudioPlayerDTMF[%p] Should Purge DTMF frame for old event, frameTimeStamp=%d eventTimeStamp=%d, result=%d";
    unint64_t v32 = v18;
    uint32_t v33 = 56;
    goto LABEL_33;
  }
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    int v20 = *(_DWORD *)(a1 + 12);
    int v21 = *(_DWORD *)(a2 + 32);
    int v37 = 136316674;
    uint64_t v38 = v17;
    __int16 v39 = 2080;
    int v40 = "_VCAudioPlayerDTMF_ShouldPurgeJitterQueue";
    __int16 v41 = 1024;
    int v42 = 118;
    __int16 v43 = 2048;
    uint64_t v44 = a2;
    __int16 v45 = 1024;
    int v46 = v20;
    __int16 v47 = 1024;
    int v48 = v21;
    __int16 v49 = 1024;
    BOOL v50 = v4 == v16;
    unsigned int v10 = " [%s] %s:%d VCAudioPlayerDTMF[%p] Should Purge DTMF frame for old event, frameTimeStamp=%d eventTimeStamp=%d, result=%d";
    size_t v11 = v18;
    uint32_t v12 = 56;
    goto LABEL_24;
  }
  return v8;
}

BOOL _VCAudioPlayerDTMF_GenerateSamples(uint64_t a1, uint64_t a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  ChannelCFIndex Count = VCAudioBufferList_GetChannelCount(*(void *)a2);
  unsigned int v5 = ChannelCount;
  if (!(_BYTE)ChannelCount) {
    return 1;
  }
  unsigned int v6 = 0;
  BOOL v7 = 0;
  uint64_t v8 = a1 + 53712;
  int v9 = (unsigned char *)(a1 + 52568);
  while (1)
  {
    uint64_t v10 = *(int *)(a2 + 8);
    MEMORY[0x1F4188790](ChannelCount);
    uint32_t v12 = (char *)&v26 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
    if (v10) {
      memset((char *)&v26 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), 255, v11);
    }
    int v27 = 0;
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    VCAudioBufferList_GetSizedBufferAtIndex(*(void *)a2, v6, 0, &v27);
    if (*v9)
    {
      unsigned int v13 = &v12[4 * v10];
      unsigned int v14 = v12;
    }
    else
    {
      unsigned int v14 = v27;
      unsigned int v13 = &v27[v28];
    }
    if (!*(unsigned char *)v8)
    {
      size_t v16 = 2 * *(int *)(a2 + 8);
      BOOL v15 = v13 >= v14;
      size_t v17 = v13 - v14;
      if (!v15 || v16 > v17) {
LABEL_29:
      }
        __break(0x5519u);
      bzero(v14, v16);
      goto LABEL_20;
    }
    if (v14) {
      BOOL v15 = v14 >= v13;
    }
    else {
      BOOL v15 = 0;
    }
    if (v15) {
      goto LABEL_29;
    }
    ChannelCFIndex Count = VCDTMFToneGenerator_GenerateSamples(*(_DWORD **)(v8 + 56), *(_DWORD *)(a2 + 8), v14);
    if ((ChannelCount & 0x80000000) != 0) {
      break;
    }
LABEL_20:
    if (*v9)
    {
      int v19 = *(_DWORD *)(a2 + 8);
      UInt32 ioOutputDataSize = 4 * v19;
      ChannelCFIndex Count = AudioConverterConvertBuffer(*(AudioConverterRef *)(v8 + 64), 2 * v19, v12, &ioOutputDataSize, v27);
    }
    BOOL v7 = v5 <= ++v6;
    if (v5 == v6) {
      return 1;
    }
  }
  int v21 = ChannelCount;
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (ErrorLogLevelForModule >= 3)
  {
    uint64_t v23 = VRTraceErrorLogLevelToCSTR();
    int v24 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
    {
      int v25 = *(unsigned __int8 *)(v8 + 28);
      UInt32 ioOutputDataSize = 136316418;
      uint64_t v31 = v23;
      __int16 v32 = 2080;
      uint32_t v33 = "_VCAudioPlayerDTMF_GenerateSamples";
      __int16 v34 = 1024;
      int v35 = 329;
      __int16 v36 = 2048;
      uint64_t v37 = v8;
      __int16 v38 = 1024;
      int v39 = v25;
      __int16 v40 = 1024;
      int v41 = v21;
      _os_log_error_impl(&dword_1E1EA4000, v24, OS_LOG_TYPE_ERROR, " [%s] %s:%d VCAudioPlayerDTMF[%p] Failed to generate tone samples, event=%d result=%d", (uint8_t *)&ioOutputDataSize, 0x32u);
    }
  }
  return v7;
}

void VCVideoReceiverSampleBuffer_Destroy(const __CFAllocator ***a1)
{
  if (a1)
  {
    unint64_t v2 = *a1;
    if (*a1)
    {
      CFAllocatorRef v3 = *v2;
      VCBlockBuffer_Clear((uint64_t)(v2 + 19));
      VCBlockBuffer_Clear((uint64_t)(v2 + 22));
      VCBlockBuffer_Clear((uint64_t)(v2 + 16));
      VCBlockBuffer_Clear((uint64_t)(v2 + 25));
      CFAllocatorRef v4 = v2[15];
      if (v4)
      {
        CFRelease(v4);
        v2[15] = 0;
      }
      CFAllocatorRef v5 = v2[13];
      if (v5)
      {
        CFRelease(v5);
        v2[13] = 0;
      }
      CFAllocatorDeallocate(v3, v2);
      if (v3) {
        CFRelease(v3);
      }
      *a1 = 0;
    }
  }
}

uint64_t VCVideoReceiverSampleBuffer_Create(const __CFAllocator *a1, void *a2)
{
  CFAllocatorRef v4 = CFAllocatorAllocate(a1, 232, 0);
  *CFAllocatorRef v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  v4[4] = 0u;
  v4[5] = 0u;
  v4[6] = 0u;
  v4[7] = 0u;
  void v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  v4[11] = 0u;
  v4[12] = 0u;
  v4[13] = 0u;
  *((void *)v4 + 28) = 0;
  if (a1) {
    CFTypeRef v5 = CFRetain(a1);
  }
  else {
    CFTypeRef v5 = 0;
  }
  *(void *)CFAllocatorRef v4 = v5;
  *a2 = v4;
  return 1;
}

void VCVideoReceiverDecodedFrame_Destroy(const __CFAllocator ***a1)
{
  if (a1)
  {
    unint64_t v2 = *a1;
    if (*a1)
    {
      CFAllocatorRef v3 = *v2;
      CFAllocatorRef v4 = v2[2];
      if (v4)
      {
        CFRelease(v4);
        v2[2] = 0;
      }
      CFAllocatorRef v5 = v2[1];
      if (v5)
      {
        CFRelease(v5);
        v2[1] = 0;
      }
      CFAllocatorDeallocate(v3, v2);
      if (v3) {
        CFRelease(v3);
      }
      *a1 = 0;
    }
  }
}

BOOL VCVideoReceiverDecodedFrame_Create(const __CFAllocator *a1, void *a2, const void *a3, __CVBuffer *a4, long long *a5, long long *a6)
{
  uint32_t v12 = CFAllocatorAllocate(a1, 104, 0);
  unsigned int v13 = v12;
  if (v12)
  {
    _OWORD v12[12] = 0;
    *((_OWORD *)v12 + 4) = 0u;
    *((_OWORD *)v12 + 5) = 0u;
    *((_OWORD *)v12 + 2) = 0u;
    *((_OWORD *)v12 + 3) = 0u;
    *(_OWORD *)uint32_t v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    if (a1) {
      CFTypeRef v14 = CFRetain(a1);
    }
    else {
      CFTypeRef v14 = 0;
    }
    *unsigned int v13 = v14;
    v13[2] = a4;
    CVPixelBufferRetain(a4);
    if (a3) {
      CFTypeRef v15 = CFRetain(a3);
    }
    else {
      CFTypeRef v15 = 0;
    }
    v13[1] = v15;
    long long v16 = *a5;
    long long v17 = a5[1];
    long long v18 = a5[2];
    v13[9] = *((void *)a5 + 6);
    *(_OWORD *)(v13 + 7) = v18;
    *(_OWORD *)(v13 + 5) = v17;
    *(_OWORD *)(v13 + 3) = v16;
    long long v19 = *a6;
    v13[12] = *((void *)a6 + 2);
    *((_OWORD *)v13 + 5) = v19;
  }
  BOOL result = v13 != 0;
  *a2 = v13;
  return result;
}

void _VCStreamInputAudio_SampleBufferHandler(uint64_t a1, opaqueCMSampleBuffer *a2)
{
  VCStreamInput_UpdateReportingStats(a1, a2);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 312));
  CFAllocatorRef v4 = *(void (**)(void, opaqueCMSampleBuffer *))(a1 + 296);
  if (v4) {
    v4(*(void *)(a1 + 304), a2);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 312));
}

void VCTerminateProcess_HandleAutoBugCapture(const void *a1)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, @"SymptomReporterOptionalKeyTerminationSource", a1);
  CFDictionarySetValue(Mutable, @"SymptomReporterOptionalIsLocalSideOnly", (const void *)*MEMORY[0x1E4F1CFD0]);
  reportingSymptom();
  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

void VCTerminateProcess(uint64_t a1, const void *a2, uint64_t a3)
{
  *(void *)&v23[1021] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = getpid();
  bzero(v23, 0x3FDuLL);
  memset(buffer, 63, sizeof(buffer));
  proc_name(v6, buffer, 0x400u);
  BOOL v7 = (void *)[NSString stringWithFormat:@"Terminating %s (PID=%d) terminateSource=%@ reason=%@", buffer, v6, a2, a1];
  int Diagnostics = VCUtil_GenerateDiagnostics(1, 1, (const char *)[v7 UTF8String], 7u);
  if (a3) {
    VCTerminateProcess_HandleAutoBugCapture(a2);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 3
    || (uint64_t v9 = VRTraceErrorLogLevelToCSTR(),
        uint64_t v10 = *MEMORY[0x1E4F47A50],
        !os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)))
  {
    if (Diagnostics) {
      return;
    }
    goto LABEL_6;
  }
  size_t v11 = " -- ##### Skipping terminate due to concurrent termination requests";
  *(_DWORD *)buf = 136316162;
  if (!Diagnostics) {
    size_t v11 = "";
  }
  uint64_t v13 = v9;
  __int16 v14 = 2080;
  CFTypeRef v15 = "VCTerminateProcess";
  __int16 v16 = 1024;
  int v17 = 37;
  __int16 v18 = 2112;
  long long v19 = v7;
  __int16 v20 = 2080;
  int v21 = v11;
  _os_log_error_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_ERROR, " [%s] %s:%d ##### %@%s", buf, 0x30u);
  if ((Diagnostics & 1) == 0)
  {
LABEL_6:
    MEMORY[0x720] = 1;
    kill(v6, 11);
  }
}

void VCAudioSessionAVAS_ScheduleNetworkUplinkClockUpdate(uint64_t a1)
{
  v2[5] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v1 = *(NSObject **)(a1 + 176);
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 3221225472;
    v2[2] = __VCAudioSessionAVAS_ScheduleNetworkUplinkClockUpdate_block_invoke;
    v2[3] = &unk_1E6DB3DC8;
    v2[4] = a1;
    dispatch_async(v1, v2);
  }
}

uint64_t VCTimescalePSOLA_PeakDetection(uint64_t result, __int16 a2, int a3, int a4, __int16 *a5, _WORD *a6)
{
  if (a3 >= 1)
  {
    uint64_t v9 = result;
    __int16 v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = (unsigned __int16)a3;
    uint64_t v13 = (unsigned __int16)a3 - 1;
    __int16 v25 = a3 == 1;
    __int16 v23 = 2 * a4;
    do
    {
      a2 += v25;
      BOOL result = VCTimescalePSOLA_MaxIndexW16(v9, (__int16)(a2 - 1));
      *a5 = result;
      int v14 = ((result << 16) + 0x20000) >> 16;
      if (v14 >= (__int16)(a2 - 1)) {
        LOWORD(v14) = a2 - 1;
      }
      if (v13)
      {
        uint64_t v11 = (((result << 16) - 0x20000) >> 16) & ~(((result << 16) - 0x20000) >> 31);
        __int16 v10 = v14;
      }
      int v15 = a2 - 2;
      if ((_WORD)result) {
        BOOL v16 = v15 == (__int16)result;
      }
      else {
        BOOL v16 = 1;
      }
      if (v16)
      {
        __int16 v17 = *(_WORD *)(v9 + 2 * (__int16)result);
        if (v15 != (__int16)result)
        {
          *a6 = v17;
          __int16 v22 = v23 * *a5;
          goto LABEL_21;
        }
        *(_WORD *)(v9 + 2 * (__int16)result + 2) = v17;
        int v18 = *a5;
        int v19 = *(__int16 *)(v9 + 2 * *a5);
        int v20 = *(__int16 *)(v9 + 2 * (v18 + 1));
        if (v19 <= v20)
        {
          *a6 = (v20 + v19) >> 1;
          __int16 v22 = ((2 * *a5) | 1) * a4;
LABEL_21:
          *a5 = v22;
          if (!v13) {
            goto LABEL_17;
          }
LABEL_16:
          BOOL result = (uint64_t)VCTimescalePSOLA_MemSetW16((_WORD *)(v9 + 2 * v11), 0, v10 - (unsigned __int16)v11 + 1);
          goto LABEL_17;
        }
        int v21 = (__int16 *)(v9 + 2 * (v18 - 1));
      }
      else
      {
        int v21 = (__int16 *)(v9 + 2 * (__int16)result - 2);
      }
      BOOL result = (uint64_t)VCTimescalePSOLA_PrblFit(v21, a5, a6, a4);
      if (v13) {
        goto LABEL_16;
      }
LABEL_17:
      --v13;
      ++a6;
      ++a5;
      --v12;
    }
    while (v12);
  }
  return result;
}

__int16 *VCTimescalePSOLA_PrblFit(__int16 *result, _WORD *a2, _WORD *a3, int a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  memset(v24, 170, 26);
  switch(a4)
  {
    case 4:
      CFAllocatorRef v4 = (char *)&v24[1];
      v24[0] = xmmword_1E25A1C60;
      break;
    case 2:
      CFAllocatorRef v4 = (char *)v24 + 8;
      *(void *)&v24[0] = 0xC000800040000;
      break;
    case 1:
      CFAllocatorRef v4 = (char *)v24 + 4;
      LODWORD(v24[0]) = 0x80000;
      break;
    default:
      CFAllocatorRef v4 = (char *)&v24[1] + 8;
      v24[0] = xmmword_1E25A1C70;
      *(void *)&v24[1] = 0xF000D000C000BLL;
      break;
  }
  *(_WORD *)CFAllocatorRef v4 = 16;
  int v5 = *result;
  int v6 = result[1];
  int v7 = result[2];
  int v8 = -3 * v5 + 4 * v6 - v7;
  int v9 = v5 - 2 * v6 + v7;
  int v10 = 120 * v8;
  uint64_t v11 = (unsigned __int16 *)v24 + a4;
  int v12 = VCTimescalePSOLA_PrblCf[3 * *v11];
  int v13 = VCTimescalePSOLA_PrblCf[3 * *(v11 - 1)];
  int v14 = v12 - v13;
  int v15 = v13 + v12;
  int v16 = -v9;
  int v17 = v15 >> 1;
  if (120 * v8 >= -(v9 * (v15 >> 1)))
  {
    if (v10 <= (v17 + (__int16)v14) * v16)
    {
      *a3 = v6;
      __int16 v22 = 2 * a4 * *a2;
    }
    else
    {
      __int16 v19 = v17 + 2 * v14;
      LOWORD(v20) = 1;
      while ((unsigned __int16)v20 != (unsigned __int16)a4 && v10 >= v19 * v16)
      {
        int v20 = (unsigned __int16)v20 + 1;
        v19 += v14;
        if ((v20 & 0x10000) != 0) {
          return result;
        }
      }
      __int16 v23 = &VCTimescalePSOLA_PrblCf[3 * *((unsigned __int16 *)v24 + a4 + (__int16)v20)];
      *a3 = *result + ((v9 * v23[1] + v8 * v23[2]) >> 8);
      __int16 v22 = v20 + 2 * a4 * *a2;
    }
  }
  else
  {
    LOWORD(v18) = 1;
    while ((unsigned __int16)v18 != (unsigned __int16)a4)
    {
      v17 -= v14;
      if (v10 > (__int16)v17 * v16) {
        break;
      }
      int v18 = (unsigned __int16)v18 + 1;
      if ((v18 & 0x10000) != 0) {
        return result;
      }
    }
    int v21 = &VCTimescalePSOLA_PrblCf[3 * *((unsigned __int16 *)v24 + a4 - (__int16)v18)];
    *a3 = *result + ((v9 * v21[1] + v8 * v21[2]) >> 8);
    __int16 v22 = 2 * a4 * *a2 - v18;
  }
  *a2 = v22;
  return result;
}

uint64_t VCAudioSession_InterruptionListenerCallback(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v8 = VRTraceErrorLogLevelToCSTR();
    int v9 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 136315650;
      uint64_t v12 = v8;
      __int16 v13 = 2080;
      int v14 = "VCAudioSession_InterruptionListenerCallback";
      __int16 v15 = 1024;
      int v16 = 447;
      _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received notification that interruption information has changed", (uint8_t *)&v11, 0x1Cu);
    }
  }
  return [a2 handleAudioInterruption:a4 interruptionInfo:a5];
}

uint64_t VCAudioSession_AvailableSampleRateChangeListenerCallback(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v3 = VRTraceErrorLogLevelToCSTR();
    CFAllocatorRef v4 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136315650;
      uint64_t v7 = v3;
      __int16 v8 = 2080;
      int v9 = "VCAudioSession_AvailableSampleRateChangeListenerCallback";
      __int16 v10 = 1024;
      int v11 = 455;
      _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received notification that Sample Rate has changed", (uint8_t *)&v6, 0x1Cu);
    }
  }
  [a2 didAvailableSampleRateChange];
  return [a2 setBlockSizeOnSampleRateChange];
}

uint64_t VCAudioSession_ActiveAudioRouteDidChange(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v7 = VRTraceErrorLogLevelToCSTR();
    __int16 v8 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 136315650;
      uint64_t v11 = v7;
      __int16 v12 = 2080;
      __int16 v13 = "VCAudioSession_ActiveAudioRouteDidChange";
      __int16 v14 = 1024;
      int v15 = 462;
      _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received route notification change", (uint8_t *)&v10, 0x1Cu);
    }
  }
  return [a2 didAudioRouteChangeWithUserInfo:a5];
}

uint64_t VCAudioSessionCMS_SessionReference()
{
  id v0 = +[VCAudioSession sharedVoiceChatInstance];
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }

  return [v0 cmSession];
}

void *receiveProc(void *a1)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  unint64_t v58 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v59 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v2 = (void *)MEMORY[0x1E4E589F0]();
  uint64_t v3 = (void *)[a1 strong];
  unsigned int v4 = [v3 transportSessionID];
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  int v6 = (os_log_t *)MEMORY[0x1E4F47A50];
  if (ErrorLogLevelForModule >= 6)
  {
    uint64_t v7 = VRTraceErrorLogLevelToCSTR();
    __int16 v8 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = v7;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "receiveProc";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&uint8_t buf[24] = 70;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v4;
      _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d control channel starts listening for sessionID='%d'", buf, 0x22u);
    }
  }
  int v9 = [v3 isRunning];
  if (!v9) {
    return a1;
  }
  pthread_setname_np("com.apple.vccontrolchannel.receiveproc");
  double v10 = micro();
  memset(buf, 0, sizeof(buf));
  long long v73 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  uint64_t v11 = (void *)MEMORY[0x1E4E589F0]();
  __int16 v12 = (void *)[a1 strong];
  if (![v12 isRunning])
  {
LABEL_51:
    uint64_t v37 = v11;
LABEL_52:
    goto LABEL_53;
  }
  double v14 = v10 + 30.0;
  p_cache = VCAudioRedBuilder.cache;
  *(void *)&long long v13 = 136315650;
  long long v55 = v13;
  while (1)
  {
    int v16 = objc_msgSend(v12, "vfdMessage", v55);
    int v17 = [v12 vfdCancel];
    if (v16 == -1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 6) {
        goto LABEL_53;
      }
      uint64_t v41 = VRTraceErrorLogLevelToCSTR();
      uint64_t v42 = *v6;
      if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_53;
      }
      *(_DWORD *)int v60 = 136316162;
      uint64_t v61 = v41;
      __int16 v62 = 2080;
      uint64_t v63 = "receiveProc";
      __int16 v64 = 1024;
      int v65 = 93;
      __int16 v66 = 1024;
      unsigned int v67 = -1;
      __int16 v68 = 1024;
      unsigned int v69 = v4;
      __int16 v43 = " [%s] %s:%d receiveProc: vfdMessage='%d', exiting receiveProc for sessionID='%d'";
      goto LABEL_63;
    }
    if (v17 == -1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 6) {
        goto LABEL_53;
      }
      uint64_t v44 = VRTraceErrorLogLevelToCSTR();
      uint64_t v42 = *v6;
      if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_53;
      }
      *(_DWORD *)int v60 = 136316162;
      uint64_t v61 = v44;
      __int16 v62 = 2080;
      uint64_t v63 = "receiveProc";
      __int16 v64 = 1024;
      int v65 = 97;
      __int16 v66 = 1024;
      unsigned int v67 = -1;
      __int16 v68 = 1024;
      unsigned int v69 = v4;
      __int16 v43 = " [%s] %s:%d receiveProc: vfdCancel='%d', exiting receiveProc for sessionID='%d'";
LABEL_63:
      _os_log_impl(&dword_1E1EA4000, v42, OS_LOG_TYPE_DEFAULT, v43, v60, 0x28u);
      goto LABEL_53;
    }
    if (__darwin_check_fd_set_overflow(v17, buf, 0)) {
      *(_DWORD *)&buf[((unint64_t)v17 >> 3) & 0x1FFFFFFFFFFFFFFCLL] |= 1 << v17;
    }
    if (__darwin_check_fd_set_overflow(v16, buf, 0)) {
      *(_DWORD *)&buf[((unint64_t)v16 >> 3) & 0x1FFFFFFFFFFFFFFCLL] |= 1 << v16;
    }
    if (v16 <= v17) {
      int v18 = v17;
    }
    else {
      int v18 = v16;
    }
    double v19 = v14 - micro();
    if (v19 <= 0.0) {
      double v14 = micro() + 30.0;
    }
    unint64_t v58 = (int)v19;
    LODWORD(v59) = (int)((v19 - (double)(int)v19) * 1000000.0);
    int v20 = VTP_Select((v18 + 1), (long long *)buf, 0, 0, (uint64_t)&v58);
    if (!v20)
    {
      double v14 = micro() + 30.0;
      goto LABEL_46;
    }
    if (v20 == -1)
    {
      if (*__error() != 9)
      {
        int v45 = *__error();
        int v46 = VRTraceGetErrorLogLevelForModule();
        if (v46 >= 3)
        {
          uint64_t v47 = VRTraceErrorLogLevelToCSTR();
          os_log_t v48 = *v6;
          if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int v60 = 136316162;
            uint64_t v61 = v47;
            __int16 v62 = 2080;
            uint64_t v63 = "receiveProc";
            __int16 v64 = 1024;
            int v65 = 123;
            __int16 v66 = 1024;
            unsigned int v67 = v45 | 0xC00F0000;
            __int16 v68 = 1024;
            unsigned int v69 = v4;
            __int16 v49 = " [%s] %s:%d select failed(%08X) for sessionID='%d'";
            BOOL v50 = v48;
            uint32_t v51 = 40;
            goto LABEL_70;
          }
        }
        goto LABEL_53;
      }
      goto LABEL_46;
    }
    if (!__darwin_check_fd_set_overflow(v16, buf, 0)
      || ((*(_DWORD *)&buf[((unint64_t)v16 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v16) & 1) == 0)
    {
      goto LABEL_46;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v21 = VRTraceErrorLogLevelToCSTR();
      __int16 v22 = *v6;
      __int16 v23 = *v6;
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int v60 = 136315906;
          uint64_t v61 = v21;
          __int16 v62 = 2080;
          uint64_t v63 = "receiveProc";
          __int16 v64 = 1024;
          int v65 = 132;
          __int16 v66 = 1024;
          unsigned int v67 = v4;
          _os_log_impl(&dword_1E1EA4000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d from sessionID='%d'", v60, 0x22u);
        }
      }
      else if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int v60 = 136315906;
        uint64_t v61 = v21;
        __int16 v62 = 2080;
        uint64_t v63 = "receiveProc";
        __int16 v64 = 1024;
        int v65 = 132;
        __int16 v66 = 1024;
        unsigned int v67 = v4;
        _os_log_debug_impl(&dword_1E1EA4000, v22, OS_LOG_TYPE_DEBUG, " [%s] %s:%d from sessionID='%d'", v60, 0x22u);
      }
    }
    int v57 = 0;
    unsigned int v24 = VTP_Recvfrom(v16, &v57);
    if ((v24 & 0x80000000) != 0) {
      break;
    }
    if (!v57[65])
    {
      VTP_ReleasePacket((void **)&v57);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v33 = VRTraceErrorLogLevelToCSTR();
        __int16 v34 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int v60 = 136316162;
          uint64_t v61 = v33;
          __int16 v62 = 2080;
          uint64_t v63 = "receiveProc";
          __int16 v64 = 1024;
          int v65 = 142;
          __int16 v66 = 1024;
          unsigned int v67 = v16;
          __int16 v68 = 1024;
          unsigned int v69 = v4;
          _os_log_error_impl(&dword_1E1EA4000, v34, OS_LOG_TYPE_ERROR, " [%s] %s:%d VTP_Recvfrom(%d) returned 0: empty message for sessionID='%d'", v60, 0x28u);
        }
      }
      goto LABEL_46;
    }
    unsigned int v25 = v24;
    uint64_t v26 = (void *)MEMORY[0x1E4E589F0]();
    int v27 = (void *)[a1 strong];
    if (![v27 isRunning])
    {
      VTP_ReleasePacket((void **)&v57);
      uint64_t v37 = v26;
      goto LABEL_52;
    }
    [v27 addToReceivedStats:*((unsigned int *)v57 + 130)];
    uint64_t v56 = 0;
    uint64_t v28 = [p_cache + 333 allocPayoadDataFromVTPPacket:v57 + 64 vpktFlags:v57 + 23 channelDataFormat:&v56];
    if (v28)
    {
      uint64_t v29 = (void *)v28;
      [v27 messageReceived:v28 participantInfo:v56];
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v35 = VRTraceErrorLogLevelToCSTR();
      __int16 v36 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int v60 = v55;
        uint64_t v61 = v35;
        __int16 v62 = 2080;
        uint64_t v63 = "receiveProc";
        __int16 v64 = 1024;
        int v65 = 157;
        _os_log_error_impl(&dword_1E1EA4000, v36, OS_LOG_TYPE_ERROR, " [%s] %s:%d Could not parse raw input data", v60, 0x1Cu);
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v30 = VRTraceErrorLogLevelToCSTR();
      uint64_t v31 = *v6;
      __int16 v32 = *v6;
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int v60 = 136316162;
          uint64_t v61 = v30;
          __int16 v62 = 2080;
          uint64_t v63 = "receiveProc";
          __int16 v64 = 1024;
          int v65 = 161;
          __int16 v66 = 1024;
          unsigned int v67 = v4;
          __int16 v68 = 1024;
          unsigned int v69 = v25;
          _os_log_impl(&dword_1E1EA4000, v31, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCControlChannelMultiWay: receiveProc for MW control channel parsed message for sessionID='%d', status='%d", v60, 0x28u);
        }
      }
      else if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int v60 = 136316162;
        uint64_t v61 = v30;
        __int16 v62 = 2080;
        uint64_t v63 = "receiveProc";
        __int16 v64 = 1024;
        int v65 = 161;
        __int16 v66 = 1024;
        unsigned int v67 = v4;
        __int16 v68 = 1024;
        unsigned int v69 = v25;
        _os_log_debug_impl(&dword_1E1EA4000, v31, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCControlChannelMultiWay: receiveProc for MW control channel parsed message for sessionID='%d', status='%d", v60, 0x28u);
      }
    }
    VTP_ReleasePacket((void **)&v57);
    p_cache = (void **)(VCAudioRedBuilder + 16);
LABEL_46:
    long long v76 = 0u;
    long long v77 = 0u;
    long long v74 = 0u;
    long long v75 = 0u;
    long long v73 = 0u;
    memset(buf, 0, sizeof(buf));
    uint64_t v11 = (void *)MEMORY[0x1E4E589F0]();
    __int16 v12 = (void *)[a1 strong];
    if (([v12 isRunning] & 1) == 0) {
      goto LABEL_51;
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v52 = VRTraceErrorLogLevelToCSTR();
    os_log_t v53 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      unsigned int v54 = *__error() | 0xC00F0000;
      *(_DWORD *)int v60 = 136316418;
      uint64_t v61 = v52;
      __int16 v62 = 2080;
      uint64_t v63 = "receiveProc";
      __int16 v64 = 1024;
      int v65 = 137;
      __int16 v66 = 1024;
      unsigned int v67 = v16;
      __int16 v68 = 1024;
      unsigned int v69 = v54;
      __int16 v70 = 1024;
      unsigned int v71 = v4;
      __int16 v49 = " [%s] %s:%d VTP_Recvfrom(%d) failed(%08X) for sessionID='%d'";
      BOOL v50 = v53;
      uint32_t v51 = 46;
LABEL_70:
      _os_log_error_impl(&dword_1E1EA4000, v50, OS_LOG_TYPE_ERROR, v49, v60, v51);
    }
  }
LABEL_53:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    uint64_t v38 = VRTraceErrorLogLevelToCSTR();
    int v39 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int v60 = 136315906;
      uint64_t v61 = v38;
      __int16 v62 = 2080;
      uint64_t v63 = "receiveProc";
      __int16 v64 = 1024;
      int v65 = 167;
      __int16 v66 = 1024;
      unsigned int v67 = v4;
      _os_log_impl(&dword_1E1EA4000, v39, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d control channel receiveProc ended for sessionID='%d'", v60, 0x22u);
    }
  }
  return a1;
}

void sub_1E22D2664(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1E22D280C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1E22D3378(_Unwind_Exception *exception_object)
{
}

void sub_1E22D3A28(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1E22D4E28(_Unwind_Exception *exception_object)
{
}

void sub_1E22D51BC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1E22D5514(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1E22D5D34(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1E22D5F7C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t VCTransportStreamGetClassID()
{
  if (VCTransportStreamGetClassID_onceToken != -1) {
    dispatch_once(&VCTransportStreamGetClassID_onceToken, &__block_literal_global_72);
  }
  return VCTransportStreamGetClassID_classID;
}

CFStringRef _VCTransportStreamCopyFormattingDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[VCTransportStream %p]", a1);
}

uint64_t __VCTransportStreamGetClassID_block_invoke()
{
  uint64_t ClassID = CMBaseGetClassID();

  return MEMORY[0x1F40DC658](&VCTransportStreamGetClassID_descriptor, ClassID, 1, &VCTransportStreamGetClassID_classID);
}

uint64_t VCTransportStreamCommonInitialize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = a3;
  *(_DWORD *)(a1 + 8) = 1;
  *(unsigned char *)(a1 + 12) = 0;
  if (a2)
  {
    FigCFDictionaryGetBooleanIfPresent();
    *(unsigned char *)(a1 + 12) = 0;
  }
  return 0;
}

void VCTransportStreamCommonFinalize(uint64_t *a1)
{
  if (*((_DWORD *)a1 + 2) == 2)
  {
    uint64_t v2 = *a1;
    uint64_t v3 = *(void (**)(uint64_t))(*(void *)(CMBaseObjectGetVTable() + 16) + 64);
    if (v3) {
      v3(v2);
    }
  }
  unsigned int v4 = (const void *)a1[4];
  if (v4) {
    _Block_release(v4);
  }
  int v5 = (const void *)a1[2];
  if (v5) {
    _Block_release(v5);
  }
  int v6 = a1[3];
  if (v6) {
    dispatch_release(v6);
  }
  uint64_t v7 = (const void *)a1[5];
  if (v7)
  {
    CFRelease(v7);
  }
}

uint64_t VCTransportStreamCommonCopyProperty(uint64_t a1, CFTypeRef cf1, uint64_t a3, const void **a4)
{
  if (CFEqual(cf1, @"IsReceiveExternallyScheduled"))
  {
    if (*(unsigned char *)(a1 + 12)) {
      int v6 = (const void **)MEMORY[0x1E4F1CFD0];
    }
    else {
      int v6 = (const void **)MEMORY[0x1E4F1CFC8];
    }
    uint64_t v7 = *v6;
    *a4 = *v6;
    CFRetain(v7);
    return 0;
  }
  else
  {
    uint64_t v8 = 2150760464;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCTransportStreamCommonCopyProperty_cold_1();
      }
    }
  }
  return v8;
}

uint64_t VCTransportStreamCommonSetSendFailedHandler(uint64_t a1, void *aBlock, dispatch_object_t object)
{
  if (aBlock)
  {
    if (*(_DWORD *)(a1 + 8) == 1)
    {
      int v6 = *(NSObject **)(a1 + 24);
      if (v6)
      {
        dispatch_release(v6);
        *(void *)(a1 + 24) = 0;
      }
      if (object)
      {
        dispatch_retain(object);
        *(void *)(a1 + 24) = object;
      }
      uint64_t v7 = *(const void **)(a1 + 16);
      if (v7) {
        _Block_release(v7);
      }
      uint64_t v8 = _Block_copy(aBlock);
      uint64_t v9 = 0;
      *(void *)(a1 + 16) = v8;
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    {
      return 2150760509;
    }
    else
    {
      VRTraceErrorLogLevelToCSTR();
      uint64_t v9 = 2150760509;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCTransportStreamCommonSetSendFailedHandler_cold_2();
      }
    }
  }
  else
  {
    uint64_t v9 = 2150760449;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCTransportStreamCommonSetSendFailedHandler_cold_1();
      }
    }
  }
  return v9;
}

uint64_t VCTransportStreamCommonSetReceivedHandler(uint64_t a1, void *aBlock)
{
  if (aBlock)
  {
    if (*(_DWORD *)(a1 + 8) == 1)
    {
      unsigned int v4 = *(const void **)(a1 + 32);
      if (v4) {
        _Block_release(v4);
      }
      int v5 = _Block_copy(aBlock);
      uint64_t v6 = 0;
      *(void *)(a1 + 32) = v5;
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    {
      return 2150760509;
    }
    else
    {
      VRTraceErrorLogLevelToCSTR();
      uint64_t v6 = 2150760509;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCTransportStreamCommonSetReceivedHandler_cold_2();
      }
    }
  }
  else
  {
    uint64_t v6 = 2150760449;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCTransportStreamCommonSetReceivedHandler_cold_1();
      }
    }
  }
  return v6;
}

void VCBlockBuffer_Copy(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(void *)a2)
    {
      CFRelease(*(CFTypeRef *)a2);
      *(void *)a2 = 0;
    }
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    if (a1)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a1;
      *(void *)(a2 + 16) = v4;
      CFTypeRef v5 = *(CFTypeRef *)a2;
      if (*(void *)a2)
      {
        CFRetain(v5);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v6 = VRTraceErrorLogLevelToCSTR();
    uint64_t v7 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCBlockBuffer_Copy_cold_1(v6, v7);
    }
  }
}

void VCBlockBuffer_Clear(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(const void **)a1;
    if (v2)
    {
      CFRelease(v2);
      *(void *)a1 = 0;
    }
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
}

uint64_t _VCCannedVideoCaptureSource_ProducerThread(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1 + 168;
  uint64_t v3 = (pthread_mutex_t *)(a1 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 264));
  while (!*(unsigned char *)(v2 + 88))
  {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 336));
    int v5 = 0;
    int v6 = *(_DWORD *)(v2 + 408);
    uint64_t v7 = *(void *)(v2 + 400);
    while (1)
    {
      int v8 = v6 + v5 <= 0 ? -(-(v6 + v5) & 0xF) : (v6 + v5) & 0xF;
      if (!*(void *)(v7 + 16 * v8 + 8))
      {
        uint64_t v9 = *(unsigned int *)(v7 + 16 * v8);
        if (v9 != -1) {
          break;
        }
      }
      if (++v5 == 16)
      {
        pthread_mutex_unlock((pthread_mutex_t *)(v2 + 336));
        pthread_cond_wait((pthread_cond_t *)(v2 + 160), v3);
        goto LABEL_11;
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v2 + 336));
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 336));
    int v10 = 0;
    int v11 = *(_DWORD *)(v2 + 408);
    do
    {
      if (v11 + v10 <= 0) {
        int v12 = -(-(v11 + v10) & 0xF);
      }
      else {
        int v12 = (v11 + v10) & 0xF;
      }
      if (*(_DWORD *)(*(void *)(v2 + 400) + 16 * v12) == v9)
      {
        *(void *)(*(void *)(v2 + 400) + 16 * v12 + 8) = [*(id *)(a1 + 592) createPixelBufferForFrameIndex:v9];
        pthread_mutex_unlock((pthread_mutex_t *)(v2 + 336));
        goto LABEL_11;
      }
      ++v10;
    }
    while (v10 != 16);
    pthread_mutex_unlock((pthread_mutex_t *)(v2 + 336));
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      uint64_t v13 = VRTraceErrorLogLevelToCSTR();
      double v14 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        uint64_t v16 = v13;
        __int16 v17 = 2080;
        int v18 = "_VCCannedVideoCaptureSource_WriteToRingBuffer";
        __int16 v19 = 1024;
        int v20 = 298;
        __int16 v21 = 1024;
        int v22 = v9;
        _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d PixelBuffer became obsolete - frame index %d changed?", buf, 0x22u);
      }
    }
LABEL_11:
    ;
  }
  pthread_mutex_unlock(v3);
  return 0;
}

uint64_t _VCCannedVideoCaptureSource_ConsumerThread(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1 + 168;
  queue = *(NSObject **)(a1 + 584);
  uint64_t v3 = (pthread_mutex_t *)(a1 + 392);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 392));
  v50.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&v50.int tv_usec = 0xAAAAAAAAAAAAAAAALL;
  gettimeofday(&v50, 0);
  memset(&v49, 170, sizeof(v49));
  CMClockGetTime(&v49, *(CMClockRef *)(v2 + 72));
  id v4 = +[VCCannedAVSync sharedCannedAVSync];
  VCCannedAVSync_SetBase((uint64_t)v4, (double)v49.value / (double)v49.timescale);
  if (!*(unsigned char *)(v2 + 216))
  {
    int v6 = 0;
    uint64_t v7 = (pthread_cond_t *)(v2 + 288);
    uint64_t v41 = (pthread_mutex_t *)(v2 + 336);
    int v8 = -1;
    uint64_t v39 = v1;
    while (1)
    {
      int v9 = atomic_load((unsigned int *)(v2 + 64));
      if (v9 && v9 != v6) {
        break;
      }
      if (v9) {
        goto LABEL_10;
      }
LABEL_44:
      if (*(unsigned char *)(v2 + 216)) {
        goto LABEL_2;
      }
    }
    setRealTimeConstraints(1.0 / (double)v9);
    int v6 = v9;
LABEL_10:
    memset(v51, 170, 16);
    gettimeofday((timeval *)v51, 0);
    int tv_usec = v50.tv_usec;
    __darwin_time_t tv_sec = v50.tv_sec;
    __darwin_time_t v13 = v50.tv_sec;
    do
    {
      while (1)
      {
        tv_usec += 0xF4240uLL / v9;
        if (tv_usec > 999999)
        {
          __darwin_time_t tv_sec = ++v13;
          tv_usec -= 1000000;
        }
        if (v13 == *(void *)v51) {
          break;
        }
        if (v13 >= *(uint64_t *)v51) {
          goto LABEL_17;
        }
      }
    }
    while (tv_usec < *(int *)&v51[8]);
    __darwin_time_t v13 = *(void *)v51;
LABEL_17:
    v50.__darwin_time_t tv_sec = tv_sec;
    v50.int tv_usec = tv_usec;
    v46.xpc_object_t value = v13;
    *(void *)&v46.timescale = 1000 * tv_usec;
    if (pthread_cond_timedwait(v7, v3, (const timespec *)&v46) == 60)
    {
      int v42 = v6;
      double v48 = NAN;
      int v47 = -1431655766;
      [*(id *)(v1 + 592) getFrameRate:&v48 frameCount:&v47];
      memset(&v46, 170, sizeof(v46));
      CMClockGetTime(&v46, *(CMClockRef *)(v2 + 72));
      unsigned int v14 = vcvtmd_s64_f64(VCCannedAVSync_ClampForTime((uint64_t)+[VCCannedAVSync sharedCannedAVSync], (double)v46.value / (double)v46.timescale)* (double)(int)v48);
      if (v8 != v14)
      {
        int v15 = v47;
        pthread_mutex_lock(v41);
        unsigned int v16 = 0;
        uint64_t v17 = *(void *)(v2 + 400);
        int v18 = *(_DWORD *)(v2 + 408);
        do
        {
          int v19 = v18;
          if (*(_DWORD *)(v17 + 16 * v18) == v14)
          {
            uint64_t v20 = v17 + 16 * v18;
            uint64_t v21 = *(void *)(v20 + 8);
            *(void *)(v20 + 8) = 0;
          }
          else
          {
            uint64_t v21 = 0;
          }
          char v22 = v19 + 1;
          int v24 = -(v19 + 1);
          BOOL v23 = v24 < 0;
          int v25 = v24 & 0xF;
          int v18 = v22 & 0xF;
          if (!v23) {
            int v18 = -v25;
          }
          if (v21) {
            break;
          }
        }
        while (v16++ < 0xF);
        int v27 = v3;
        int v28 = 0;
        *(_DWORD *)(v2 + 408) = v18;
        do
        {
          int v29 = v28 + *(_DWORD *)(v2 + 408);
          int v30 = v29 & 0xF;
          int v31 = -v29;
          BOOL v23 = v31 < 0;
          int v32 = v31 & 0xF;
          if (v23) {
            int v33 = v30;
          }
          else {
            int v33 = -v32;
          }
          int v34 = (int)(v14 + v28 + 1) % v15;
          if (*(_DWORD *)(v17 + 16 * v33) != v34)
          {
            uint64_t v35 = v33;
            __int16 v36 = *(__CVBuffer **)(v17 + 16 * v33 + 8);
            if (v36)
            {
              CVPixelBufferRelease(v36);
              uint64_t v17 = *(void *)(v2 + 400);
              *(void *)(v17 + 16 * v35 + 8) = 0;
            }
            *(_DWORD *)(v17 + 16 * v35) = v34;
          }
          ++v28;
        }
        while (v28 != 16);
        pthread_mutex_unlock(v41);
        pthread_cond_signal((pthread_cond_t *)(v2 + 160));
        uint64_t v3 = v27;
        if (v21)
        {
          block[0] = MEMORY[0x1E4F143A8];
          block[1] = 3221225472;
          uint64_t v1 = v39;
          block[2] = ___VCCannedVideoCaptureSource_ConsumerThread_block_invoke;
          block[3] = &unk_1E6DB8A58;
          block[4] = v39;
          void block[5] = v21;
          CMTime v44 = v46;
          unsigned int v45 = v14;
          dispatch_async(queue, block);
          int v8 = v14;
        }
        else
        {
          uint64_t v1 = v39;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            uint64_t v37 = VRTraceErrorLogLevelToCSTR();
            uint64_t v38 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)uint32_t v51 = 136315906;
              *(void *)&v51[4] = v37;
              *(_WORD *)&v51[12] = 2080;
              *(void *)&v51[14] = "_VCCannedVideoCaptureSource_ConsumerThread";
              __int16 v52 = 1024;
              int v53 = 454;
              __int16 v54 = 1024;
              unsigned int v55 = v14;
              _os_log_error_impl(&dword_1E1EA4000, v38, OS_LOG_TYPE_ERROR, " [%s] %s:%d Pixel buffer for frame %d not available", v51, 0x22u);
            }
          }
          int v8 = v14;
        }
      }
      uint64_t v7 = (pthread_cond_t *)(v2 + 288);
      int v6 = v42;
    }
    goto LABEL_44;
  }
LABEL_2:
  pthread_mutex_unlock(v3);
  dispatch_sync(queue, &__block_literal_global_73);
  dispatch_release(queue);
  return 0;
}

VTSessionRef VCMediaRecorderUtil_AllocTransferSession()
{
  session[1] = *(VTSessionRef *)MEMORY[0x1E4F143B8];
  session[0] = (VTSessionRef)0xAAAAAAAAAAAAAAAALL;
  VTPixelTransferSessionCreate(0, (VTPixelTransferSessionRef *)session);
  VTSessionSetProperty(session[0], (CFStringRef)*MEMORY[0x1E4F45168], (CFTypeRef)*MEMORY[0x1E4F45468]);
  return session[0];
}

CVPixelBufferRef VCMediaRecorderUtil_CreateResizeFrame(__CVBuffer *a1, OpaqueVTPixelTransferSession *a2, CVPixelBufferPoolRef pixelBufferPool)
{
  destinationBuffer[1] = *(CVPixelBufferRef *)MEMORY[0x1E4F143B8];
  destinationBuffer[0] = 0;
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaRecorderUtil_CreateResizeFrame_cold_1();
      }
    }
    goto LABEL_19;
  }
  if (!pixelBufferPool)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaRecorderUtil_CreateResizeFrame_cold_2();
      }
    }
    goto LABEL_19;
  }
  if (CVPixelBufferPoolCreatePixelBuffer((CFAllocatorRef)*MEMORY[0x1E4F1CF80], pixelBufferPool, destinationBuffer))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaRecorderUtil_CreateResizeFrame_cold_4();
      }
    }
    goto LABEL_19;
  }
  if (VTPixelTransferSessionTransferImage(a2, a1, destinationBuffer[0]))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaRecorderUtil_CreateResizeFrame_cold_3();
      }
    }
LABEL_19:
    CVPixelBufferRef v5 = 0;
    goto LABEL_6;
  }
  CVPixelBufferRef v5 = destinationBuffer[0];
  destinationBuffer[0] = 0;
LABEL_6:
  CVPixelBufferRelease(destinationBuffer[0]);
  return v5;
}

uint64_t VCMediaRecorderUtil_SetupBufferPool(__CFString *a1, CVPixelBufferPoolRef *a2, double a3, double a4)
{
  void v17[2] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *MEMORY[0x1E4F2F128];
  v16[0] = *MEMORY[0x1E4F2F0F8];
  v16[1] = v7;
  int v8 = @"AVConference:MediaRecorderUtil";
  if (a1) {
    int v8 = a1;
  }
  v17[0] = MEMORY[0x1E4F1CC38];
  v17[1] = v8;
  uint64_t v9 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v17 forKeys:v16 count:2];
  uint64_t v10 = VCVideoUtil_DefaultCameraCapturePixelFormat();
  v14[0] = *MEMORY[0x1E4F24E10];
  v15[0] = [NSNumber numberWithDouble:a3];
  v14[1] = *MEMORY[0x1E4F24D08];
  v15[1] = [NSNumber numberWithDouble:a4];
  _OWORD v14[2] = *MEMORY[0x1E4F24D70];
  uint64_t v11 = [NSNumber numberWithUnsignedInt:v10];
  v14[3] = *MEMORY[0x1E4F24D20];
  _OWORD v15[2] = v11;
  void v15[3] = v9;
  CFDictionaryRef v12 = (const __CFDictionary *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v15 forKeys:v14 count:4];
  return CVPixelBufferPoolCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v12, a2);
}

__CVPixelBufferPool *VCMediaRecorderUtil_PixelBufferPoolMatchDimensions(__CVPixelBufferPool *result, int a2, int a3)
{
  if (result)
  {
    CFDictionaryRef PixelBufferAttributes = CVPixelBufferPoolGetPixelBufferAttributes(result);
    int v6 = (void *)[(__CFDictionary *)PixelBufferAttributes objectForKeyedSubscript:*MEMORY[0x1E4F24E10]];
    uint64_t v7 = (void *)[(__CFDictionary *)PixelBufferAttributes objectForKeyedSubscript:*MEMORY[0x1E4F24D08]];
    if ([v6 intValue] == a2) {
      return (__CVPixelBufferPool *)([v7 intValue] == a3);
    }
    else {
      return 0;
    }
  }
  return result;
}

const char *VCMediaRecorderUtil_FilePrefixForMediaType(int a1)
{
  if ((a1 - 1) > 4) {
    return "media";
  }
  else {
    return off_1E6DB8A78[(char)(a1 - 1)];
  }
}

CFStringRef VCMediaRecorderUtil_CopyDescriptionForMediaType(const __CFAllocator *a1, unsigned int a2)
{
  if (a2 - 1 > 4) {
    uint64_t v2 = "Unknown";
  }
  else {
    uint64_t v2 = off_1E6DB8AA0[(char)(a2 - 1)];
  }
  return CFStringCreateWithFormat(a1, 0, @"%s(%hhu)", v2, a2);
}

CFStringRef VCMediaRecorderUtil_DescriptionForMediaType(unsigned int a1)
{
  CFStringRef v1 = VCMediaRecorderUtil_CopyDescriptionForMediaType((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a1);
  CFStringRef v2 = v1;
  if (v1) {
    CFAutorelease(v1);
  }
  return v2;
}

uint64_t VCMediaRecorderUtil_PrintMediaURL(uint64_t a1, int a2)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  uint64_t v46 = 0;
  int v4 = VCUtil_BinaryPrefix(+[VCFileUtil sizeOfFile:a1], (double *)&v46);
  CVPixelBufferRef v5 = (void *)[MEMORY[0x1E4F166C8] URLAssetWithURL:a1 options:0];
  int v6 = v5;
  memset(&v45, 170, sizeof(v45));
  if (v5) {
    [v5 duration];
  }
  else {
    memset(&v45, 0, sizeof(v45));
  }
  CMTime time = v45;
  Float64 Seconds = CMTimeGetSeconds(&time);
  int v8 = (void *)[v6 tracks];
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a2 < 1 || ErrorLogLevelForModule < a2) {
    goto LABEL_24;
  }
  uint64_t v10 = VRTraceErrorLogLevelToCSTR();
  if (a2 > 2)
  {
    if (a2 > 4)
    {
      if (a2 > 7)
      {
        if (a2 != 8) {
          goto LABEL_24;
        }
        int v15 = *MEMORY[0x1E4F47A50];
        unsigned int v16 = *MEMORY[0x1E4F47A50];
        if (!*MEMORY[0x1E4F47A40])
        {
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v42 = [v8 count];
            LODWORD(time.value) = 136316930;
            *(CMTimeValue *)((char *)&time.value + 4) = v10;
            LOWORD(time.flags) = 2080;
            *(void *)((char *)&time.flags + 2) = "VCMediaRecorderUtil_PrintMediaURL";
            HIWORD(time.epoch) = 1024;
            int v53 = 142;
            __int16 v54 = 2112;
            uint64_t v55 = a1;
            __int16 v56 = 2048;
            *(void *)int v57 = v42;
            *(_WORD *)&v57[8] = 2048;
            *(void *)&unsigned char v57[10] = v46;
            __int16 v58 = 1024;
            int v59 = v4;
            __int16 v60 = 2048;
            Float64 v61 = Seconds;
            _os_log_debug_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEBUG, " [%s] %s:%d mediaURL=%@ trackCount=%lu fileSize=%.2f%cB fileLength=%f", (uint8_t *)&time, 0x4Au);
          }
          goto LABEL_24;
        }
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_24;
        }
      }
      else
      {
        int v15 = *MEMORY[0x1E4F47A50];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_24;
        }
      }
      uint64_t v17 = [v8 count];
      LODWORD(time.value) = 136316930;
      *(CMTimeValue *)((char *)&time.value + 4) = v10;
      LOWORD(time.flags) = 2080;
      *(void *)((char *)&time.flags + 2) = "VCMediaRecorderUtil_PrintMediaURL";
      HIWORD(time.epoch) = 1024;
      int v53 = 142;
      __int16 v54 = 2112;
      uint64_t v55 = a1;
      __int16 v56 = 2048;
      *(void *)int v57 = v17;
      *(_WORD *)&v57[8] = 2048;
      *(void *)&unsigned char v57[10] = v46;
      __int16 v58 = 1024;
      int v59 = v4;
      __int16 v60 = 2048;
      Float64 v61 = Seconds;
      _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d mediaURL=%@ trackCount=%lu fileSize=%.2f%cB fileLength=%f", (uint8_t *)&time, 0x4Au);
      goto LABEL_24;
    }
    CFDictionaryRef v12 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
    {
LABEL_12:
      uint64_t v13 = [v8 count];
      LODWORD(time.value) = 136316930;
      *(CMTimeValue *)((char *)&time.value + 4) = v10;
      LOWORD(time.flags) = 2080;
      *(void *)((char *)&time.flags + 2) = "VCMediaRecorderUtil_PrintMediaURL";
      HIWORD(time.epoch) = 1024;
      int v53 = 142;
      __int16 v54 = 2112;
      uint64_t v55 = a1;
      __int16 v56 = 2048;
      *(void *)int v57 = v13;
      *(_WORD *)&v57[8] = 2048;
      *(void *)&unsigned char v57[10] = v46;
      __int16 v58 = 1024;
      int v59 = v4;
      __int16 v60 = 2048;
      Float64 v61 = Seconds;
      _os_log_error_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d mediaURL=%@ trackCount=%lu fileSize=%.2f%cB fileLength=%f", (uint8_t *)&time, 0x4Au);
    }
  }
  else
  {
    char IsOSFaultDisabled = VRTraceIsOSFaultDisabled();
    CFDictionaryRef v12 = *MEMORY[0x1E4F47A50];
    if ((IsOSFaultDisabled & 1) == 0)
    {
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_FAULT))
      {
        uint64_t v14 = [v8 count];
        LODWORD(time.value) = 136316930;
        *(CMTimeValue *)((char *)&time.value + 4) = v10;
        LOWORD(time.flags) = 2080;
        *(void *)((char *)&time.flags + 2) = "VCMediaRecorderUtil_PrintMediaURL";
        HIWORD(time.epoch) = 1024;
        int v53 = 142;
        __int16 v54 = 2112;
        uint64_t v55 = a1;
        __int16 v56 = 2048;
        *(void *)int v57 = v14;
        *(_WORD *)&v57[8] = 2048;
        *(void *)&unsigned char v57[10] = v46;
        __int16 v58 = 1024;
        int v59 = v4;
        __int16 v60 = 2048;
        Float64 v61 = Seconds;
        _os_log_fault_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_FAULT, " [%s] %s:%d mediaURL=%@ trackCount=%lu fileSize=%.2f%cB fileLength=%f", (uint8_t *)&time, 0x4Au);
      }
      goto LABEL_24;
    }
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
  }
LABEL_24:
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  uint64_t result = [v8 countByEnumeratingWithState:&v48 objects:v47 count:16];
  if (!result) {
    return result;
  }
  uint64_t v19 = result;
  uint64_t v20 = (os_log_t *)MEMORY[0x1E4F47A50];
  uint64_t v21 = *(void *)v49;
  do
  {
    uint64_t v22 = 0;
    do
    {
      if (*(void *)v49 != v21) {
        objc_enumerationMutation(v8);
      }
      BOOL v23 = *(void **)(*((void *)&v48 + 1) + 8 * v22);
      if (v23)
      {
        [*(id *)(*((void *)&v48 + 1) + 8 * v22) timeRange];
        CMTimeValue v24 = *((void *)&v43 + 1);
        CMTimeEpoch v25 = *((void *)&v44 + 1);
        uint64_t v26 = v44;
      }
      else
      {
        CMTimeEpoch v25 = 0;
        CMTimeValue v24 = 0;
        long long v43 = 0u;
        long long v44 = 0u;
        uint64_t v26 = 0;
      }
      time.xpc_object_t value = v24;
      *(void *)&time.timescale = v26;
      time.CMTimeEpoch epoch = v25;
      Float64 v27 = CMTimeGetSeconds(&time);
      int v28 = VRTraceGetErrorLogLevelForModule();
      if (a2 >= 1 && v28 >= a2)
      {
        uint64_t v29 = VRTraceErrorLogLevelToCSTR();
        if (a2 > 2)
        {
          if (a2 <= 4)
          {
            int v31 = *v20;
            if (!os_log_type_enabled(*v20, OS_LOG_TYPE_ERROR)) {
              goto LABEL_52;
            }
            goto LABEL_40;
          }
          if (a2 <= 7)
          {
            __int16 v36 = *v20;
            if (!os_log_type_enabled(*v20, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_52;
            }
LABEL_49:
            uint64_t v38 = [v23 mediaType];
            int v39 = [v23 trackID];
            LODWORD(time.value) = 136316418;
            *(CMTimeValue *)((char *)&time.value + 4) = v29;
            LOWORD(time.flags) = 2080;
            *(void *)((char *)&time.flags + 2) = "VCMediaRecorderUtil_PrintMediaURL";
            HIWORD(time.epoch) = 1024;
            int v53 = 147;
            __int16 v54 = 2112;
            uint64_t v55 = v38;
            uint64_t v20 = (os_log_t *)MEMORY[0x1E4F47A50];
            __int16 v56 = 1024;
            *(_DWORD *)int v57 = v39;
            *(_WORD *)&uint8_t v57[4] = 2048;
            *(Float64 *)&v57[6] = v27;
            _os_log_impl(&dword_1E1EA4000, v36, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d mediaType=%@ trackID=%d trackLength=%f", (uint8_t *)&time, 0x36u);
            goto LABEL_52;
          }
          if (a2 != 8) {
            goto LABEL_52;
          }
          __int16 v36 = *v20;
          uint64_t v37 = *v20;
          if (*MEMORY[0x1E4F47A40])
          {
            if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_52;
            }
            goto LABEL_49;
          }
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v40 = [v23 mediaType];
            int v41 = [v23 trackID];
            LODWORD(time.value) = 136316418;
            *(CMTimeValue *)((char *)&time.value + 4) = v29;
            LOWORD(time.flags) = 2080;
            *(void *)((char *)&time.flags + 2) = "VCMediaRecorderUtil_PrintMediaURL";
            HIWORD(time.epoch) = 1024;
            int v53 = 147;
            __int16 v54 = 2112;
            uint64_t v55 = v40;
            uint64_t v20 = (os_log_t *)MEMORY[0x1E4F47A50];
            __int16 v56 = 1024;
            *(_DWORD *)int v57 = v41;
            *(_WORD *)&uint8_t v57[4] = 2048;
            *(Float64 *)&v57[6] = v27;
            _os_log_debug_impl(&dword_1E1EA4000, v36, OS_LOG_TYPE_DEBUG, " [%s] %s:%d mediaType=%@ trackID=%d trackLength=%f", (uint8_t *)&time, 0x36u);
          }
        }
        else
        {
          char v30 = VRTraceIsOSFaultDisabled();
          int v31 = *v20;
          if (v30)
          {
            if (!os_log_type_enabled(*v20, OS_LOG_TYPE_ERROR)) {
              goto LABEL_52;
            }
LABEL_40:
            uint64_t v32 = [v23 mediaType];
            int v33 = [v23 trackID];
            LODWORD(time.value) = 136316418;
            *(CMTimeValue *)((char *)&time.value + 4) = v29;
            LOWORD(time.flags) = 2080;
            *(void *)((char *)&time.flags + 2) = "VCMediaRecorderUtil_PrintMediaURL";
            HIWORD(time.epoch) = 1024;
            int v53 = 147;
            __int16 v54 = 2112;
            uint64_t v55 = v32;
            uint64_t v20 = (os_log_t *)MEMORY[0x1E4F47A50];
            __int16 v56 = 1024;
            *(_DWORD *)int v57 = v33;
            *(_WORD *)&uint8_t v57[4] = 2048;
            *(Float64 *)&v57[6] = v27;
            _os_log_error_impl(&dword_1E1EA4000, v31, OS_LOG_TYPE_ERROR, " [%s] %s:%d mediaType=%@ trackID=%d trackLength=%f", (uint8_t *)&time, 0x36u);
            goto LABEL_52;
          }
          if (os_log_type_enabled(*v20, OS_LOG_TYPE_FAULT))
          {
            uint64_t v34 = [v23 mediaType];
            int v35 = [v23 trackID];
            LODWORD(time.value) = 136316418;
            *(CMTimeValue *)((char *)&time.value + 4) = v29;
            LOWORD(time.flags) = 2080;
            *(void *)((char *)&time.flags + 2) = "VCMediaRecorderUtil_PrintMediaURL";
            HIWORD(time.epoch) = 1024;
            int v53 = 147;
            __int16 v54 = 2112;
            uint64_t v55 = v34;
            uint64_t v20 = (os_log_t *)MEMORY[0x1E4F47A50];
            __int16 v56 = 1024;
            *(_DWORD *)int v57 = v35;
            *(_WORD *)&uint8_t v57[4] = 2048;
            *(Float64 *)&v57[6] = v27;
            _os_log_fault_impl(&dword_1E1EA4000, v31, OS_LOG_TYPE_FAULT, " [%s] %s:%d mediaType=%@ trackID=%d trackLength=%f", (uint8_t *)&time, 0x36u);
          }
        }
      }
LABEL_52:
      ++v22;
    }
    while (v19 != v22);
    uint64_t result = [v8 countByEnumeratingWithState:&v48 objects:v47 count:16];
    uint64_t v19 = result;
  }
  while (result);
  return result;
}

void VCVideoStreamReceiveGroup_UpdateSourcePlayoutTime(uint64_t a1, _OWORD *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      if ([(id)a1 isVideoExpected] && (*(void *)(a1 + 432) || *(unsigned char *)(a1 + 448)))
      {
        long long v4 = a2[1];
        *(_OWORD *)uint64_t v10 = *a2;
        *(_OWORD *)&v10[16] = v4;
        ++*(void *)(a1 + 600);
        if (*(unsigned char *)(a1 + 592))
        {
          int32_t v5 = *(_DWORD *)(a1 + 328);
          CMTime v9 = *(CMTime *)a2;
          CMTimeConvertScale((CMTime *)v10, &v9, v5, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
        }
        objc_msgSend((id)objc_msgSend(*(id *)(a1 + 176), "firstObject"), "updateSourcePlayoutTime:", v10);
      }
    }
    else if (objc_opt_class() == a1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCVideoStreamReceiveGroup_UpdateSourcePlayoutTime_cold_2();
        }
      }
    }
    else
    {
      if (objc_opt_respondsToSelector()) {
        int v6 = (__CFString *)[(id)a1 performSelector:sel_logPrefix];
      }
      else {
        int v6 = &stru_1F3D3E450;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v7 = VRTraceErrorLogLevelToCSTR();
        int v8 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t v10 = 136316162;
          *(void *)&v10[4] = v7;
          *(_WORD *)&v10[12] = 2080;
          *(void *)&v10[14] = "VCVideoStreamReceiveGroup_UpdateSourcePlayoutTime";
          *(_WORD *)&v10[22] = 1024;
          *(_DWORD *)&v10[24] = 726;
          *(_WORD *)&v10[28] = 2112;
          *(void *)&v10[30] = v6;
          __int16 v11 = 2048;
          uint64_t v12 = a1;
          _os_log_error_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_ERROR, " [%s] %s:%d %@(%p) Playout time is NULL", v10, 0x30u);
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCVideoStreamReceiveGroup_UpdateSourcePlayoutTime_cold_1();
    }
  }
}

void _VCPacketBundler_CleanupCDRXInfo(void ***a1)
{
  if (a1 && (CFStringRef v2 = *a1) != 0)
  {
    if (v2[10])
    {
      free(v2[10]);
      (*a1)[10] = 0;
      CFStringRef v2 = *a1;
    }
    free(v2);
    *a1 = 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCPacketBundler_CleanupCDRXInfo_cold_1();
    }
  }
}

uint64_t VCPacketBundler_BundleAudio(uint64_t a1, void *a2)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
      return 0;
    }
    uint64_t v27 = VRTraceErrorLogLevelToCSTR();
    int v28 = *MEMORY[0x1E4F47A50];
    uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136316162;
    uint64_t v45 = v27;
    __int16 v46 = 2080;
    int v47 = "VCPacketBundler_BundleAudio";
    __int16 v48 = 1024;
    int v49 = 325;
    __int16 v50 = 2048;
    *(void *)long long v51 = a1;
    *(_WORD *)&v51[8] = 2048;
    __int16 v52 = a2;
    uint64_t v29 = " [%s] %s:%d NULL access: bundler=%p, audioBundleInfo=%p";
    goto LABEL_53;
  }
  if (*(unsigned char *)(a1 + 129))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
      return 0;
    }
    uint64_t v30 = VRTraceErrorLogLevelToCSTR();
    int v31 = *MEMORY[0x1E4F47A50];
    uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v32 = *(unsigned __int8 *)(a1 + 129);
    *(_DWORD *)buf = 136316162;
    uint64_t v45 = v30;
    __int16 v46 = 2080;
    int v47 = "VCPacketBundler_BundleAudio";
    __int16 v48 = 1024;
    int v49 = 326;
    __int16 v50 = 2048;
    *(void *)long long v51 = a1;
    *(_WORD *)&v51[8] = 1024;
    LODWORD(v52) = v32;
    uint64_t v29 = " [%s] %s:%d :bundler=%p buffer is full=%d";
    int v33 = v31;
    uint32_t v34 = 44;
    goto LABEL_54;
  }
  if (*(_DWORD *)(a1 + 108) && *((_DWORD *)a2 + 3) != *(_DWORD *)(a1 + 92))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCPacketBundler_BundleAudio_cold_1();
    }
    return 0;
  }
  int v4 = *(_DWORD *)(a1 + 124);
  switch(v4)
  {
    case 1:
      uint64_t result = [(id)a1 bundleAudioLegacy:*a2 numInputBytes:*((unsigned int *)a2 + 2) payloadType:*((unsigned int *)a2 + 3) timestamp:*((unsigned int *)a2 + 4)];
      if (!result) {
        return result;
      }
      goto LABEL_36;
    case 3:
      uint64_t v6 = *(void *)(a1 + 144);
      if (v6 && *a2)
      {
        uint64_t v7 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(v6 + 80));
        if (v7)
        {
          int v8 = (os_log_t *)MEMORY[0x1E4F47A50];
          do
          {
            if (*(unsigned char *)v7 == 1)
            {
              if (v7[1] == 40) {
                int v9 = 2;
              }
              else {
                int v9 = 1;
              }
            }
            else
            {
              int v9 = 1;
            }
            *(_DWORD *)(a1 + 88) = v9;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              uint64_t v10 = VRTraceErrorLogLevelToCSTR();
              __int16 v11 = *v8;
              if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
              {
                int v12 = *(_DWORD *)(a1 + 88);
                *(_DWORD *)buf = 136315906;
                uint64_t v45 = v10;
                __int16 v46 = 2080;
                int v47 = "_VCPacketBundler_UpdatePacketsPerBundle";
                __int16 v48 = 1024;
                int v49 = 291;
                __int16 v50 = 1024;
                *(_DWORD *)long long v51 = v12;
                _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d After processing CDRX event, packets per bundle=%d", buf, 0x22u);
              }
            }
            uint64_t v7 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(*(void *)(a1 + 144) + 80));
          }
          while (v7);
        }
        uint64_t v13 = *(unsigned int *)(a1 + 100);
        size_t v14 = *((unsigned int *)a2 + 2);
        if ((v14 + v13) <= *(_DWORD *)(a1 + 16))
        {
          int v15 = (void *)(*(void *)(a1 + 8) + v13);
          memcpy(v15, (const void *)*a2, v14);
          int v16 = v15 + *((_DWORD *)a2 + 2);
          uint64_t v17 = *(void *)(a1 + 144);
          unsigned int v18 = *(_DWORD *)(a1 + 108);
          uint64_t v19 = v17 + 20 * v18;
          int v20 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(v19 + 8) = v16 - (v20 + *(_DWORD *)(a1 + 100));
          *(_DWORD *)(a1 + 100) = v16 - v20;
          uint64_t v21 = *(void *)((char *)a2 + 12);
          *(void *)uint64_t v19 = v21;
          *(_DWORD *)(v19 + 12) = *((_DWORD *)a2 + 6);
          char v22 = *((unsigned char *)a2 + 20);
          if (v22) {
            BOOL v23 = *(unsigned char *)(v17 + 40) == 0;
          }
          else {
            BOOL v23 = 0;
          }
          *(unsigned char *)(v17 + 20 * v18 + 16) = v23;
          *(unsigned char *)(v17 + 40) = v22;
          unsigned int v24 = *(_DWORD *)(a1 + 108) + 1;
          *(_DWORD *)(a1 + 108) = v24;
          *(_DWORD *)(a1 + 92) = v21;
          BOOL v25 = v24 >= *(_DWORD *)(a1 + 88) || *((unsigned char *)a2 + 29) != 0;
          *(unsigned char *)(a1 + 129) = v25;
          goto LABEL_36;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
          return 0;
        }
        uint64_t v38 = VRTraceErrorLogLevelToCSTR();
        int v39 = *MEMORY[0x1E4F47A50];
        uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        int v40 = *((_DWORD *)a2 + 2);
        int v41 = *(_DWORD *)(a1 + 16);
        int v42 = *(_DWORD *)(a1 + 100);
        int v43 = *(_DWORD *)(a1 + 108);
        *(_DWORD *)buf = 136316674;
        uint64_t v45 = v38;
        __int16 v46 = 2080;
        int v47 = "_VCPacketBundler_BundleAudioCDRX";
        __int16 v48 = 1024;
        int v49 = 301;
        __int16 v50 = 1024;
        *(_DWORD *)long long v51 = v40;
        *(_WORD *)&v51[4] = 1024;
        *(_DWORD *)&v51[6] = v41;
        LOWORD(v52) = 1024;
        *(_DWORD *)((char *)&v52 + 2) = v42;
        HIWORD(v52) = 1024;
        int v53 = v43;
        uint64_t v29 = " [%s] %s:%d Bundling encountered an error: inputBytes=%u bufferSize=%u encodedBufferSize=%u bundledCount=%u";
        int v33 = v39;
        uint32_t v34 = 52;
LABEL_54:
        _os_log_error_impl(&dword_1E1EA4000, v33, OS_LOG_TYPE_ERROR, v29, buf, v34);
        return 0;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
        return 0;
      }
      uint64_t v35 = VRTraceErrorLogLevelToCSTR();
      int v28 = *MEMORY[0x1E4F47A50];
      uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      uint64_t v36 = *(void *)(a1 + 144);
      uint64_t v37 = (void *)*a2;
      *(_DWORD *)buf = 136316162;
      uint64_t v45 = v35;
      __int16 v46 = 2080;
      int v47 = "_VCPacketBundler_BundleAudioCDRX";
      __int16 v48 = 1024;
      int v49 = 297;
      __int16 v50 = 2048;
      *(void *)long long v51 = v36;
      *(_WORD *)&v51[8] = 2048;
      __int16 v52 = v37;
      uint64_t v29 = " [%s] %s:%d NULL access: bundler->_cdrxBundleInfoRef=[%p], inputBytes=[%p]";
LABEL_53:
      int v33 = v28;
      uint32_t v34 = 48;
      goto LABEL_54;
    case 2:
      if ([(id)a1 bundleAudioRFC3640:*a2 numInputBytes:*((unsigned int *)a2 + 2) payloadType:*((unsigned int *)a2 + 3) timestamp:*((unsigned int *)a2 + 4)])goto LABEL_36; {
      return 0;
      }
  }
  if (([(id)a1 _copyInputBytes:*a2 numInputBytes:*((unsigned int *)a2 + 2) payloadType:*((unsigned int *)a2 + 3) timestamp:*((unsigned int *)a2 + 4)] & 1) == 0)return 0; {
LABEL_36:
  }
  if (*((unsigned char *)a2 + 20)) {
    BOOL v26 = 1;
  }
  else {
    BOOL v26 = *(unsigned char *)(a1 + 112) != 0;
  }
  *(unsigned char *)(a1 + 112) = v26;
  VCAudioPacketBundler_UpdatePriority(a1, *((unsigned __int8 *)a2 + 21));
  *(_DWORD *)(a1 + 156) = *((_DWORD *)a2 + 6);
  return 1;
}

void VCAudioPacketBundler_UpdatePriority(uint64_t a1, unsigned int a2)
{
  if (a1)
  {
    unsigned int v2 = *(unsigned __int8 *)(a1 + 136);
    if (v2 <= a2) {
      LOBYTE(v2) = a2;
    }
    *(unsigned char *)(a1 + 136) = v2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioPacketBundler_UpdatePriority_cold_1();
    }
  }
}

uint64_t VCPacketBundler_ExtractBundledPackets(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (a1) {
    BOOL v5 = a3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  uint64_t v6 = !v5;
  if (!v5)
  {
    int v8 = *(_DWORD *)(a1 + 124);
    if (v8 == 3)
    {
      uint64_t v10 = *(void *)(a1 + 144);
      if (!v10)
      {
        uint64_t v9 = 0;
LABEL_16:
        *(void *)a3 = v9;
        int v11 = *(_DWORD *)(a1 + 124);
        if (v11 == 3)
        {
          uint64_t v13 = *(void *)(a1 + 144);
          if (v13) {
            int v12 = *(_DWORD *)(v13 + 20 * a2 + 8);
          }
          else {
            int v12 = 0;
          }
        }
        else if (v11 == 2)
        {
          int v12 = [(id)a1 encodedBufferSizeForRFC3640];
        }
        else
        {
          int v12 = *(_DWORD *)(a1 + 100);
        }
        *(_DWORD *)(a3 + 8) = v12;
        if (*(_DWORD *)(a1 + 124) == 3)
        {
          size_t v14 = *(_DWORD **)(a1 + 144);
          if (!v14) {
            goto LABEL_28;
          }
          v14 += 5 * a2 + 1;
        }
        else
        {
          size_t v14 = (_DWORD *)(a1 + 96);
        }
        LODWORD(v14) = *v14;
LABEL_28:
        *(_DWORD *)(a3 + 16) = v14;
        if (*(_DWORD *)(a1 + 124) == 3)
        {
          uint64_t v15 = *(void *)(a1 + 144);
          if (!v15) {
            goto LABEL_35;
          }
          LODWORD(v15) = *(unsigned __int8 *)(v15 + 20 * a2 + 16);
        }
        else
        {
          if (*(unsigned char *)(a1 + 113))
          {
            LOBYTE(v15) = 0;
            goto LABEL_35;
          }
          LODWORD(v15) = *(unsigned __int8 *)(a1 + 112);
        }
        LOBYTE(v15) = v15 != 0;
LABEL_35:
        *(unsigned char *)(a3 + 28) = v15;
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(a1 + 92);
        if (*(_DWORD *)(a1 + 124) == 3)
        {
          int v16 = *(_DWORD **)(a1 + 144);
          if (!v16)
          {
LABEL_40:
            *(_DWORD *)(a3 + 24) = v16;
            *(unsigned char *)(a3 + 21) = *(unsigned char *)(a1 + 136);
            return v6;
          }
          v16 += 5 * a2 + 3;
        }
        else
        {
          int v16 = (_DWORD *)(a1 + 156);
        }
        LODWORD(v16) = *v16;
        goto LABEL_40;
      }
      if (a2)
      {
        uint64_t v9 = *(void *)(a1 + 8) + *(unsigned int *)(v10 + 20 * (a2 - 1) + 8);
        goto LABEL_16;
      }
    }
    else if (v8 == 2)
    {
      uint64_t v9 = [(id)a1 encodedBufferForRFC3640];
      goto LABEL_16;
    }
    uint64_t v9 = *(void *)(a1 + 8);
    goto LABEL_16;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v18 = VRTraceErrorLogLevelToCSTR();
    uint64_t v19 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
    {
      int v20 = 136316162;
      uint64_t v21 = v18;
      __int16 v22 = 2080;
      BOOL v23 = "VCPacketBundler_ExtractBundledPackets";
      __int16 v24 = 1024;
      int v25 = 515;
      __int16 v26 = 2048;
      uint64_t v27 = a1;
      __int16 v28 = 2048;
      uint64_t v29 = a3;
      _os_log_error_impl(&dword_1E1EA4000, v19, OS_LOG_TYPE_ERROR, " [%s] %s:%d NULL access: packetBundler=[%p] rtpPacketInfo=[%p]", (uint8_t *)&v20, 0x30u);
    }
  }
  return v6;
}

void VCPacketBundler_StoreAndEnqueueCdrxInfo(uint64_t a1, int a2, int a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (a1 && (uint64_t v4 = *(void *)(a1 + 144)) != 0)
  {
    uint64_t v7 = v4 + 4 * *(unsigned __int8 *)(v4 + 74);
    *(unsigned char *)(v7 + 42) = a2;
    *(_WORD *)(v7 + 44) = a3;
    int v8 = (os_log_t *)MEMORY[0x1E4F47A50];
    while (1)
    {
      uint64_t v9 = *(opaqueCMSimpleQueue **)(v4 + 80);
      while (!v9)
        ;
      uint64_t v10 = *(unsigned __int8 *)(v4 + 74);
      OSStatus v11 = CMSimpleQueueEnqueue(v9, (const void *)(v4 + 4 * v10 + 42));
      if (v11 != -12773) {
        break;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v12 = VRTraceErrorLogLevelToCSTR();
        uint64_t v13 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          uint64_t v20 = v12;
          __int16 v21 = 2080;
          __int16 v22 = "VCPacketBundler_StoreAndEnqueueCdrxInfo";
          __int16 v23 = 1024;
          int v24 = 546;
          _os_log_error_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_ERROR, " [%s] %s:%d Cdrx event queue is Full. Reset Queue and enqueue", buf, 0x1Cu);
        }
      }
      CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(*(void *)(a1 + 144) + 80));
      uint64_t v4 = *(void *)(a1 + 144);
    }
    if (v11)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR)) {
          VCPacketBundler_StoreAndEnqueueCdrxInfo_cold_2();
        }
      }
    }
    else
    {
      *(unsigned char *)(*(void *)(a1 + 144) + 74) = (v10 + 1) & 7;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v14 = VRTraceErrorLogLevelToCSTR();
        uint64_t v15 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          int32_t Count = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(*(void *)(a1 + 144) + 80));
          *(_DWORD *)buf = 136316418;
          uint64_t v20 = v14;
          __int16 v21 = 2080;
          __int16 v22 = "VCPacketBundler_StoreAndEnqueueCdrxInfo";
          __int16 v23 = 1024;
          int v24 = 543;
          __int16 v25 = 1024;
          int v26 = a2;
          __int16 v27 = 1024;
          int v28 = a3;
          __int16 v29 = 1024;
          int32_t v30 = Count;
          _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Cdrx event enqueued: cdrx state=%d, cdrx cycle=%d, enqueued event count=%d", buf, 0x2Eu);
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v17 = VRTraceErrorLogLevelToCSTR();
    uint64_t v18 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCPacketBundler_StoreAndEnqueueCdrxInfo_cold_1(v17, a1, v18);
    }
  }
}

uint64_t _AVCAudioStream_UpdateFrequencyLevel(void *a1, const char *a2, int a3)
{
  uint64_t v4 = *((void *)a1 + 6);
  if (a3) {
    return [a1 vcMediaStream:v4 updateInputFrequencyLevel:a2];
  }
  else {
    return [a1 vcMediaStream:v4 updateOutputFrequencyLevel:a2];
  }
}

void sub_1E22ED624(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1E22F2718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1E22F394C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1E22F56D4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_1E22F750C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 56), 8);
  _Unwind_Resume(a1);
}

uint64_t VCVideoCaptureServer_CopyLocalVideoAttributes(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x3052000000;
  int v8 = __Block_byref_object_copy__31;
  uint64_t v9 = __Block_byref_object_dispose__31;
  uint64_t v10 = 0;
  if (a1)
  {
    uint64_t v1 = *(NSObject **)(a1 + 256);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __VCVideoCaptureServer_CopyLocalVideoAttributes_block_invoke;
    block[3] = &unk_1E6DB4540;
    block[4] = a1;
    void block[5] = &v5;
    dispatch_sync(v1, block);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCVideoCaptureServer_CopyLocalVideoAttributes_cold_1();
    }
  }
  uint64_t v2 = v6[5];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1E22F9434(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
}

void sub_1E22FF514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

uint64_t _VCMockIDSDatagramChannel_ComparePacket(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 1648);
  unint64_t v3 = *(void *)(a2 + 1648);
  BOOL v4 = v2 == v3;
  unsigned int v5 = 2 * (v2 >= v3);
  if (v4) {
    return 1;
  }
  else {
    return v5;
  }
}

uint64_t VCMockIDSDatagramChannelReceiveThread(uint64_t result, uint64_t a2, unsigned char *a3)
{
  unsigned __int8 v4 = atomic_load((unsigned __int8 *)(result + 3322352));
  if ((v4 & 1) == 0)
  {
    unsigned int v5 = (unsigned __int8 *)result;
    do
    {
      uint64_t result = [v5 readyToRead];
      unsigned __int8 v6 = atomic_load(v5 + 3322352);
    }
    while ((v6 & 1) == 0);
  }
  *a3 = 1;
  return result;
}

uint64_t _VCMediaQueueClassRegister(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

void _VCMediaQueue_ReportingEvent(_DWORD *a1, int a2, int a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (a2 <= 192)
  {
    if (a2 == 191)
    {
      int valuePtr = -1431655766;
      unsigned int v11 = atomic_load(a1 + 71);
      int valuePtr = v11;
      CFNumberRef v8 = CFNumberCreate(v6, kCFNumberIntType, &valuePtr);
      uint64_t v9 = @"VCMQPeakBR";
      goto LABEL_10;
    }
    if (a2 == 192)
    {
      int valuePtr = -1431655766;
      unsigned int v10 = atomic_load(a1 + 72);
      int valuePtr = v10;
      CFNumberRef v8 = CFNumberCreate(v6, kCFNumberIntType, &valuePtr);
      uint64_t v9 = @"VCMQMTU";
      goto LABEL_10;
    }
  }
  else
  {
    if ((a2 - 193) < 2)
    {
      int valuePtr = a3;
      CFNumberRef v8 = CFNumberCreate(v6, kCFNumberIntType, &valuePtr);
      uint64_t v9 = @"VCMQStreamID";
LABEL_10:
      CFDictionaryAddValue(Mutable, v9, v8);
      CFRelease(v8);
      goto LABEL_11;
    }
    if (a2 == 321)
    {
      int valuePtr = a1[22];
      CFNumberRef v8 = CFNumberCreate(v6, kCFNumberIntType, &valuePtr);
      uint64_t v9 = @"MQSchP";
      goto LABEL_10;
    }
  }
LABEL_11:
  reportingEventWithAllowedClientType();
  CFRelease(Mutable);
}

uint64_t _VCMediaQueue_GetInternalQueueIndexFromStreamId(uint64_t result, int a2, int a3, int *a4)
{
  if (!a4)
  {
    uint64_t v5 = 2149580801;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCMediaQueue_GetInternalQueueIndexFromStreamId_cold_1();
      }
    }
    return v5;
  }
  int v4 = *(unsigned __int8 *)(result + 128);
  if (a3)
  {
    if (*(unsigned char *)(result + 128))
    {
      uint64_t v5 = 0;
      *a4 = 0;
    }
    else
    {
      uint64_t v5 = 2149580801;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCMediaQueue_GetInternalQueueIndexFromStreamId_cold_2();
        }
      }
    }
    return v5;
  }
  uint64_t v6 = atomic_load((unsigned int *)(result + 760));
  if ((int)v6 <= v4) {
    return 0;
  }
  uint64_t v7 = (_DWORD *)(result + 632 + 4 * *(unsigned __int8 *)(result + 128));
  uint64_t v8 = v6 - *(unsigned __int8 *)(result + 128);
  while ((unint64_t)v7 < result + 760 && (unint64_t)v7 >= result + 632)
  {
    if (*v7 == a2)
    {
      uint64_t v5 = 0;
      *a4 = v4;
      return v5;
    }
    ++v4;
    ++v7;
    if (!--v8) {
      return 0;
    }
  }
  __break(0x5519u);
  return result;
}

void VCMediaQueue_FreeMediaPacket(uint64_t a1, uint64_t a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (!a2) {
      return;
    }
    int v4 = *(_DWORD *)(a2 + 176);
    int v5 = *(_DWORD *)(a2 + 228);
    *(void *)(a2 + 8) = 0;
    unsigned int v22 = -1;
    if (_VCMediaQueue_GetInternalQueueIndexFromStreamId(a1, v5, *(unsigned __int8 *)(a2 + 295), (int *)&v22)|| (v22 & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
        return;
      }
      uint64_t v14 = VRTraceErrorLogLevelToCSTR();
      uint64_t v15 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        return;
      }
      *(_DWORD *)buf = 136316162;
      uint64_t v24 = v14;
      __int16 v25 = 2080;
      int v26 = "VCMediaQueue_FreeMediaPacket";
      __int16 v27 = 1024;
      int v28 = 778;
      __int16 v29 = 1024;
      OSStatus v30 = v4;
      __int16 v31 = 1024;
      int v32 = v5;
      int v16 = "VCMediaQueue [%s] %s:%d Cannot get internal queue index for packet type=%d, mediaQueueStreamId=%u";
      uint64_t v17 = v15;
      uint32_t v18 = 40;
LABEL_27:
      _os_log_error_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_ERROR, v16, buf, v18);
      return;
    }
    unint64_t v6 = *(void *)(a1 + 624);
    unint64_t v7 = v6 + 176 * v22;
    if (v7 >= v6 + 176 * *(unsigned int *)(a1 + 348) || v7 < v6) {
LABEL_28:
    }
      __break(0x5519u);
    if (CMSimpleQueueGetHead(*(CMSimpleQueueRef *)(v6 + 176 * v22 + 8)) != (const void *)a2)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCMediaQueue_FreeMediaPacket_cold_2();
        }
      }
      return;
    }
    unint64_t v9 = *(void *)(a1 + 624);
    unsigned int v10 = (opaqueCMSimpleQueue **)(v9 + 176 * (int)v22);
    if ((unint64_t)v10 >= v9 + 176 * *(unsigned int *)(a1 + 348) || (unint64_t)v10 < v9) {
      goto LABEL_28;
    }
    unsigned int v11 = *v10;
    uint64_t v12 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(v9 + 176 * (int)v22 + 8));
    OSStatus v13 = CMSimpleQueueEnqueue(v11, v12);
    if (v13)
    {
      OSStatus v19 = v13;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v20 = VRTraceErrorLogLevelToCSTR();
        __int16 v21 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316418;
          uint64_t v24 = v20;
          __int16 v25 = 2080;
          int v26 = "VCMediaQueue_FreeMediaPacket";
          __int16 v27 = 1024;
          int v28 = 787;
          __int16 v29 = 1024;
          OSStatus v30 = v19;
          __int16 v31 = 1024;
          int v32 = v4;
          __int16 v33 = 1024;
          int v34 = v5;
          int v16 = "VCMediaQueue [%s] %s:%d Internal queue has error %d when free media packet for packet type=%d, mediaQueueStreamId=%u";
          uint64_t v17 = v21;
          uint32_t v18 = 46;
          goto LABEL_27;
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCMediaQueue_FreeMediaPacket_cold_1();
    }
  }
}

void _VCMediaQueue_FreeMediaPacketList(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v4 = *(void *)(v2 + 304);
      _VCMediaQueue_ReleaseExternalDataBuffer(a1, v2);
      uint64_t v5 = *(void *)(v2 + 184);
      if (v5)
      {
        VCMediaControlInfoDispose(v5);
        *(void *)(v2 + 184) = 0;
      }
      VCMediaQueue_FreeMediaPacket(a1, v2);
      uint64_t v2 = v4;
    }
    while (v4);
  }
}

void _VCMediaQueue_ReleaseExternalDataBuffer(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v4 = *(const void **)(a2 + 8);
    if (v4)
    {
      int v5 = *(unsigned __int8 *)(a1 + 96);
      if (*(unsigned char *)(a2 + 294)) {
        BOOL v6 = v5 == 0;
      }
      else {
        BOOL v6 = 1;
      }
      if (!v6)
      {
        CFRelease(v4);
        *(void *)(a2 + 8) = 0;
        *(unsigned char *)(a2 + 294) = 0;
      }
    }
  }
}

uint64_t _VCMediaQueue_RegisterStream(uint64_t a1, atomic_uint a2, signed int *a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t result = 2149580801;
  if (a3)
  {
    BOOL v6 = (atomic_uint *)(a1 + 760);
    signed int v7 = atomic_load((unsigned int *)(a1 + 760));
    do
    {
      signed int v8 = v7;
      if (v7 >= *(_DWORD *)(a1 + 348)) {
        return 2149580805;
      }
      atomic_compare_exchange_strong(v6, (unsigned int *)&v7, v7 + 1);
    }
    while (v7 != v8);
    unint64_t v9 = (atomic_uint *)(a1 + 632 + 4 * v8);
    if (v9 < v6
      && (unint64_t)v9 >= a1 + 632
      && ((*unint64_t v9 = a2, v10 = *(void *)(a1 + 624),
                     unint64_t v11 = v10 + 176 * v8,
                     v11 < v10 + 176 * *(unsigned int *)(a1 + 348))
        ? (BOOL v12 = v11 >= v10)
        : (BOOL v12 = 0),
          v12))
    {
      *(_DWORD *)(v10 + 176 * v8 + 124) = a2;
      *a3 = v8;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v19 = VRTraceErrorLogLevelToCSTR();
        uint64_t v20 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          uint64_t v22 = v19;
          __int16 v23 = 2080;
          uint64_t v24 = "_VCMediaQueue_RegisterStream";
          __int16 v25 = 1024;
          int v26 = 820;
          __int16 v27 = 1024;
          atomic_uint v28 = a2;
          __int16 v29 = 1024;
          signed int v30 = v8;
          _os_log_impl(&dword_1E1EA4000, v20, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue register mediaQueueStreamId=%u with internal queue index=%d", buf, 0x28u);
        }
      }
      uint64_t result = *(void *)(a1 + 168);
      if (result)
      {
        VRLogfilePrintWithTimestamp(result, "Stream registration with index=%d, mediaQueueStreamId=%u\n", v13, v14, v15, v16, v17, v18, v8);
        return 0;
      }
    }
    else
    {
      __break(0x5519u);
    }
  }
  return result;
}

void _VCMediaQueue_SchedulePackets(uint64_t a1)
{
  double v2 = micro();
  *(double *)(a1 + 312) = v2 + *(double *)(a1 + 24);
  atomic_exchange((atomic_uchar *volatile)(a1 + 280), 0);
  double v3 = *(double *)(a1 + 320);
  if (v3 != 0.0) {
    *(double *)(a1 + 352) = v2 - v3;
  }
  int v4 = *(_DWORD *)(a1 + 88);
  *(double *)(a1 + 320) = v2;
  if ((v4 - 1) >= 2)
  {
    if (v4)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCMediaQueue_SchedulePackets_cold_1();
        }
      }
    }
    else
    {
      _VCMediaQueue_SchedulePacketsWithPolicyNone(a1);
    }
  }
  else
  {
    _VCMediaQueue_SchedulePacketsWithLimitedBudget(a1);
  }
}

uint64_t _VCMediaQueue_SchedulePacketsWithPolicyNone(uint64_t result)
{
  if (*(_DWORD *)(result + 348))
  {
    uint64_t v1 = result;
    unint64_t v2 = 0;
    do
    {
      uint64_t v3 = *(void *)(v1 + 624);
      if (*(_DWORD *)(v3 + 176 * v2 + 24))
      {
        int v4 = *(opaqueCMSimpleQueue **)(v3 + 176 * v2 + 16);
        uint64_t result = CMSimpleQueueGetCount(v4);
        if ((int)result >= 1)
        {
          do
          {
            Head = CMSimpleQueueGetHead(v4);
            uint64_t result = VCMediaQueuePacketBundler_AddPacket(*(void *)(v1 + 136), Head);
            if (result) {
              break;
            }
            CMSimpleQueueDequeue(v4);
            uint64_t result = CMSimpleQueueGetCount(v4);
          }
          while ((int)result > 0);
        }
      }
      ++v2;
    }
    while (v2 < *(unsigned int *)(v1 + 348));
  }
  return result;
}

void _VCMediaQueue_SchedulePacketsWithLimitedBudget(uint64_t a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  _VCMediaQueue_UpdateTotalBudgetForThisInterval(a1);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v2 = VRTraceErrorLogLevelToCSTR();
    uint64_t v3 = *MEMORY[0x1E4F47A50];
    int v4 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = *(_DWORD *)(a1 + 340);
        int v14 = 136315906;
        uint64_t v15 = v2;
        __int16 v16 = 2080;
        uint64_t v17 = "_VCMediaQueue_SchedulePacketsWithLimitedBudget";
        __int16 v18 = 1024;
        int v19 = 875;
        __int16 v20 = 1024;
        int v21 = v5;
        _os_log_impl(&dword_1E1EA4000, v3, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Starting budget in this interval: %d", (uint8_t *)&v14, 0x22u);
      }
    }
    else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      _VCMediaQueue_SchedulePacketsWithLimitedBudget_cold_1();
    }
  }
  int v6 = _VCMediaQueue_ScheduleDirectSendQueuesAndReduceRemainingBudget(a1);
  int v7 = _VCMediaQueue_ScheduleWaitingQueuesAndReduceRemainingBudget(a1) + v6;
  *(unsigned char *)(a1 + 308) = v7 != 0;
  int v8 = _VCMediaQueue_ScheduleThrottlingQueuesAndReduceRemainingBudget(a1) + v7;
  if (v8 && (int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v9 = VRTraceErrorLogLevelToCSTR();
    unint64_t v10 = *MEMORY[0x1E4F47A50];
    unint64_t v11 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = *(_DWORD *)(a1 + 340);
        int v14 = 136316162;
        uint64_t v15 = v9;
        __int16 v16 = 2080;
        uint64_t v17 = "_VCMediaQueue_SchedulePacketsWithLimitedBudget";
        __int16 v18 = 1024;
        int v19 = 884;
        __int16 v20 = 1024;
        int v21 = v8;
        __int16 v22 = 1024;
        int v23 = v12;
        _os_log_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Total byte count scheduled in this interval: %d, remaining budget: %d", (uint8_t *)&v14, 0x28u);
      }
    }
    else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      int v13 = *(_DWORD *)(a1 + 340);
      int v14 = 136316162;
      uint64_t v15 = v9;
      __int16 v16 = 2080;
      uint64_t v17 = "_VCMediaQueue_SchedulePacketsWithLimitedBudget";
      __int16 v18 = 1024;
      int v19 = 884;
      __int16 v20 = 1024;
      int v21 = v8;
      __int16 v22 = 1024;
      int v23 = v13;
      _os_log_debug_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEBUG, "VCMediaQueue [%s] %s:%d Total byte count scheduled in this interval: %d, remaining budget: %d", (uint8_t *)&v14, 0x28u);
    }
  }
  *(_DWORD *)(a1 + 412) += v8;
}

uint64_t _VCMediaQueue_UpdateTotalBudgetForThisInterval(uint64_t result)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)(result + 888));
  if (v1)
  {
    unsigned int v9 = (*(double *)(result + 24) * 50000000.0);
    goto LABEL_20;
  }
  *(double *)(result + 360) = *(double *)(result + 352) * 0.9 + *(double *)(result + 360) * 0.1;
  unsigned int v2 = atomic_load((unsigned int *)(result + 284));
  *(_DWORD *)(result + 392) = v2;
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)(result + 300));
  if (*(unsigned char *)(result + 129) && (v3 & 1) != 0)
  {
    if (!*(_DWORD *)(result + 348)) {
      goto LABEL_11;
    }
    unint64_t v4 = 0;
    char v5 = 0;
    uint64_t v6 = 93;
    do
    {
      v5 |= atomic_exchange((atomic_uchar *volatile)(*(void *)(result + 624) + v6), 0);
      ++v4;
      v6 += 176;
    }
    while (v4 < *(unsigned int *)(result + 348));
    if (v5)
    {
      unint64_t v7 = *(void *)(result + 320);
      double v8 = fmax(*(double *)(result + 376) * 0.5, 1.0);
      *(void *)(result + 384) = v7;
    }
    else
    {
LABEL_11:
      double v11 = *(double *)(result + 384);
      if (v11 != 0.0)
      {
        HIDWORD(v7) = 1078853632;
        if (*(double *)(result + 320) - v11 <= 60.0)
        {
          double v8 = *(double *)(result + 376);
          goto LABEL_15;
        }
      }
      unint64_t v7 = 10.0;
      double v8 = fmin(*(double *)(result + 376) + 0.01, 10.0);
    }
    *(double *)(result + 376) = v8;
LABEL_15:
    LODWORD(v7) = *(_DWORD *)(result + 392);
    unsigned int v10 = (v8 * (double)v7);
    *(_DWORD *)(result + 392) = v10;
    goto LABEL_16;
  }
  unsigned int v10 = *(_DWORD *)(result + 392);
LABEL_16:
  double v12 = *(double *)(result + 360);
  double v13 = *(double *)(result + 368) * v12;
  double v14 = (double)v10;
  if (v13 >= *(double *)(result + 24)) {
    double v13 = *(double *)(result + 24);
  }
  unsigned int v9 = (v13 * v14 * 0.125);
  *(_DWORD *)(result + 332) = v9;
  double v15 = v12 * v14 * 0.125;
  LODWORD(v12) = *(_DWORD *)(result + 340);
  if (v9 >= (v15 + (double)*(unint64_t *)&v12)) {
    unsigned int v9 = (v15 + (double)*(unint64_t *)&v12);
  }
LABEL_20:
  *(_DWORD *)(result + 340) = v9;
  *(_DWORD *)(result + 336) = v9;
  return result;
}

uint64_t _VCMediaQueue_ScheduleDirectSendQueuesAndReduceRemainingBudget(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *(unsigned int *)(a1 + 348);
  if (v2)
  {
    unint64_t v3 = 0;
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(a1 + 624);
      if (*(_DWORD *)(v5 + 176 * v3 + 24) == 1)
      {
        uint64_t v6 = v5 + 176 * v3;
        double v8 = *(opaqueCMSimpleQueue **)(v6 + 16);
        unint64_t v7 = (CMSimpleQueueRef *)(v6 + 16);
        if (CMSimpleQueueGetCount(v8) >= 1)
        {
          uint64_t v9 = v5 + 176 * v3;
          unsigned int v10 = (_DWORD *)(v9 + 80);
          double v11 = (_DWORD *)(v9 + 84);
          while (1)
          {
            Head = CMSimpleQueueGetHead(*v7);
            OSStatus v13 = CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(a1 + 616), Head);
            if (v13) {
              break;
            }
            CMSimpleQueueDequeue(*v7);
            int v14 = Head[67];
            if (*((unsigned char *)Head + 293)) {
              int v15 = 48;
            }
            else {
              int v15 = 28;
            }
            int v16 = v15 + *Head;
            int v17 = *((unsigned __int16 *)Head + 2);
            *(_DWORD *)(a1 + 420) += v14;
            *(_DWORD *)(a1 + 416) += v16 * v14;
            *v10 += v14;
            *double v11 = Head[59];
            uint64_t v4 = (v4 + (v16 + v17) * v14);
            if (CMSimpleQueueGetCount(*v7) <= 0) {
              goto LABEL_15;
            }
          }
          OSStatus v18 = v13;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            uint64_t v19 = VRTraceErrorLogLevelToCSTR();
            __int16 v20 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315906;
              uint64_t v26 = v19;
              __int16 v27 = 2080;
              atomic_uint v28 = "_VCMediaQueue_ScheduleDirectSendQueuesAndReduceRemainingBudget";
              __int16 v29 = 1024;
              int v30 = 991;
              __int16 v31 = 1024;
              OSStatus v32 = v18;
              _os_log_error_impl(&dword_1E1EA4000, v20, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d Failed to enqueue! status: %d", buf, 0x22u);
            }
          }
        }
LABEL_15:
        *(_WORD *)(a1 + 600) |= 1 << v3;
        unint64_t v2 = *(unsigned int *)(a1 + 348);
      }
      ++v3;
    }
    while (v3 < v2);
  }
  else
  {
    uint64_t v4 = 0;
  }
  unsigned int v21 = *(_DWORD *)(a1 + 340);
  BOOL v22 = v21 >= v4;
  int v23 = v21 - v4;
  if (v23 == 0 || !v22)
  {
    int v23 = 0;
    *(_DWORD *)(a1 + 344) += v4;
  }
  *(_DWORD *)(a1 + 340) = v23;
  return v4;
}

uint64_t _VCMediaQueue_ScheduleWaitingQueuesAndReduceRemainingBudget(uint64_t a1)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = 0;
  unsigned int v3 = *(_DWORD *)(a1 + 348) - 1;
  if ((v3 & 0x80000000) == 0)
  {
    do
    {
      unint64_t v4 = *(void *)(a1 + 624);
      unint64_t v5 = v4 + 176 * *(unsigned int *)(a1 + 348);
      unint64_t v6 = v4 + 176 * v3;
      if (v4 > v6 || v6 + 176 > v5) {
LABEL_30:
      }
        __break(0x5519u);
      int v8 = v3;
      if (*(_DWORD *)(v4 + 176 * v3 + 24) == 2)
      {
        unint64_t v9 = v4 + 176 * v3;
        double v11 = *(opaqueCMSimpleQueue **)(v9 + 16);
        unsigned int v10 = (CMSimpleQueueRef *)(v9 + 16);
        if (CMSimpleQueueGetCount(v11) >= 1)
        {
          if (v6) {
            BOOL v12 = v6 >= v5;
          }
          else {
            BOOL v12 = 0;
          }
          int v13 = !v12;
          unint64_t v14 = v4 + 176 * v8;
          int v15 = (_DWORD *)(v14 + 80);
          int v16 = (_DWORD *)(v14 + 84);
          while (1)
          {
            Head = CMSimpleQueueGetHead(*v10);
            int v18 = VCMediaQueuePacketBundler_AddPacket(*(void *)(a1 + 136), Head);
            if (v18) {
              break;
            }
            CMSimpleQueueDequeue(*v10);
            if (!v13) {
              goto LABEL_30;
            }
            int v19 = Head[67];
            if (*((unsigned char *)Head + 293)) {
              int v20 = 48;
            }
            else {
              int v20 = 28;
            }
            int v21 = v20 + *Head;
            int v22 = *((unsigned __int16 *)Head + 2);
            *(_DWORD *)(a1 + 420) += v19;
            *(_DWORD *)(a1 + 416) += v21 * v19;
            *v15 += v19;
            _DWORD *v16 = Head[59];
            uint64_t v2 = (v2 + (v21 + v22) * v19);
            if (CMSimpleQueueGetCount(*v10) <= 0) {
              goto LABEL_25;
            }
          }
          int v23 = v18;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            uint64_t v24 = VRTraceErrorLogLevelToCSTR();
            __int16 v25 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315906;
              uint64_t v30 = v24;
              __int16 v31 = 2080;
              OSStatus v32 = "_VCMediaQueue_ScheduleWaitingQueuesAndReduceRemainingBudget";
              __int16 v33 = 1024;
              int v34 = 1014;
              __int16 v35 = 1024;
              int v36 = v23;
              _os_log_error_impl(&dword_1E1EA4000, v25, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d Failed to add packet to bundler! status=%d", buf, 0x22u);
            }
          }
        }
LABEL_25:
        *(_WORD *)(a1 + 600) |= 1 << v8;
      }
      unsigned int v3 = v8 - 1;
    }
    while (v8 > 0);
  }
  unsigned int v26 = *(_DWORD *)(a1 + 340);
  BOOL v12 = v26 >= v2;
  int v27 = v26 - v2;
  if (v27 == 0 || !v12)
  {
    int v27 = 0;
    *(_DWORD *)(a1 + 344) += v2;
  }
  *(_DWORD *)(a1 + 340) = v27;
  return v2;
}

uint64_t _VCMediaQueue_ScheduleThrottlingQueuesAndReduceRemainingBudget(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 88);
  if (v1 == 2)
  {
    return _VCMediaQueue_ScheduleThrottlingQueuesWithoutWait(a1);
  }
  else if (v1 == 1)
  {
    return _VCMediaQueue_ScheduleThrottlingQueuesWithIDRAndLongestIdleTimeFirst(a1);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCMediaQueue_ScheduleThrottlingQueuesAndReduceRemainingBudget_cold_1();
      }
    }
    return 0;
  }
}

uint64_t _VCMediaQueue_ScheduleThrottlingQueuesWithIDRAndLongestIdleTimeFirst(uint64_t a1)
{
  *(void *)unint64_t v14 = *MEMORY[0x1E4F143B8];
  memset(v13, 0, sizeof(v13));
  if (*(_DWORD *)(a1 + 348))
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    uint64_t v4 = 0;
    unsigned int v5 = 0;
    do
    {
      uint64_t v6 = *(void *)(a1 + 624);
      if (*(_DWORD *)(v6 + v2 + 24) == 3 && CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(v6 + v2 + 16)) >= 1)
      {
        if (atomic_exchange((atomic_uchar *volatile)(v6 + v2 + 92), 0))
        {
          uint64_t v4 = _VCMediaQueue_ScheduleFramesFromThrottlingQueue(a1, v3) + v4;
          *(_WORD *)(a1 + 600) |= 1 << v3;
          *(_WORD *)(a1 + 602) |= 1 << v3;
        }
        else
        {
          unint64_t v7 = (unsigned int *)&v13[v5];
          if (v7 >= v14 || v7 < (unsigned int *)v13) {
            goto LABEL_19;
          }
          uint64_t v8 = *(void *)(v6 + v2 + 32);
          ++v5;
          *unint64_t v7 = v3;
          v7[1] = -1431655766;
          *((void *)v7 + 1) = v8;
        }
      }
      ++v3;
      v2 += 176;
    }
    while (v3 < *(unsigned int *)(a1 + 348));
    uint64_t v9 = v5;
    qsort(v13, v5, 0x10uLL, (int (__cdecl *)(const void *, const void *))_VCMediaQueue_CompareScheduleOrderElementWithScheduleTime);
    if (v5)
    {
      for (uint64_t i = (unsigned int *)v13; i < v14 && i >= (unsigned int *)v13; i += 4)
      {
        unsigned int v11 = *i;
        uint64_t v4 = _VCMediaQueue_ScheduleFramesFromThrottlingQueue(a1, v11) + v4;
        if (!--v9) {
          return v4;
        }
      }
LABEL_19:
      __break(0x5519u);
    }
  }
  else
  {
    qsort(v13, 0, 0x10uLL, (int (__cdecl *)(const void *, const void *))_VCMediaQueue_CompareScheduleOrderElementWithScheduleTime);
    return 0;
  }
  return v4;
}

uint64_t _VCMediaQueue_ScheduleThrottlingQueuesWithoutWait(uint64_t result)
{
  uint64_t v1 = result;
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(result + 888));
  if (v2)
  {
    unsigned int v3 = *(_DWORD *)(result + 348);
    if (v3)
    {
      uint64_t v4 = 0;
      unsigned int v5 = 0;
      uint64_t v6 = 0;
      uint64_t v7 = 176 * v3;
      while (1)
      {
        unint64_t v8 = *(void *)(v1 + 624);
        if (v8 > v8 + v4 || v8 + v4 + 176 > v8 + 176 * *(unsigned int *)(v1 + 348)) {
          break;
        }
        if (*(_DWORD *)(v8 + v4 + 24) == 3)
        {
          uint64_t result = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(v8 + v4 + 16));
          if ((int)result >= 1)
          {
            uint64_t result = _VCMediaQueue_ScheduleFramesFromThrottlingQueue(v1, v5);
            uint64_t v6 = (result + v6);
          }
        }
        ++v5;
        v4 += 176;
        if (v7 == v4) {
          return v6;
        }
      }
      __break(0x5519u);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return _VCMediaQueue_ScheduleThrottlingQueuesWithIDRAndLongestIdleTimeFirst(result);
  }
  return result;
}

uint64_t _VCMediaQueue_ScheduleFramesFromThrottlingQueue(uint64_t a1, unsigned int a2)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  if (!*(_DWORD *)(a1 + 340)) {
    return 0;
  }
  unint64_t v3 = *(void *)(a1 + 624);
  unint64_t v4 = v3 + 176 * *(unsigned int *)(a1 + 348);
  char v48 = a2;
  unint64_t v5 = v3 + 176 * a2;
  unint64_t v47 = v3;
  if (v3 > v5 || v5 + 176 > v4) {
LABEL_63:
  }
    __break(0x5519u);
  unint64_t v8 = v3 + 176 * a2;
  uint64_t v9 = (unint64_t *)(v8 + 104);
  unint64_t v10 = atomic_load((unint64_t *)(v8 + 104));
  unint64_t v50 = v10;
  BOOL v12 = *(opaqueCMSimpleQueue **)(v8 + 16);
  unsigned int v11 = (CMSimpleQueueRef *)(v8 + 16);
  uint64_t v13 = 0;
  if (CMSimpleQueueGetCount(v12) >= 1)
  {
    if (v5) {
      BOOL v14 = v5 >= v4;
    }
    else {
      BOOL v14 = 0;
    }
    int v15 = !v14;
    unint64_t v16 = v47 + 176 * a2;
    long long v51 = (char *)(v16 + 168);
    int v49 = (int *)(v16 + 160);
    uint64_t v45 = (int *)(v16 + 124);
    int v17 = (_DWORD *)(v16 + 80);
    int v18 = (_DWORD *)(v16 + 84);
    BOOL v19 = 1;
    do
    {
      Head = CMSimpleQueueGetHead(*v11);
      if (!v15) {
        goto LABEL_63;
      }
      int v21 = Head;
      unsigned __int8 v22 = atomic_load((unsigned __int8 *)(a1 + 300));
      if ((v22 & 1) == 0)
      {
        BOOL v23 = 0;
        goto LABEL_24;
      }
      if (Head[94])
      {
        if (Head[291])
        {
          char v24 = 1;
LABEL_22:
          char *v51 = v24;
          goto LABEL_23;
        }
        if (Head[292])
        {
          char v24 = 0;
          goto LABEL_22;
        }
      }
LABEL_23:
      BOOL v23 = *v51 != 0;
LABEL_24:
      if (!*(unsigned char *)(a1 + 308))
      {
        if (*(unsigned char *)(a1 + 309)) {
          BOOL v23 = 0;
        }
        if (v23) {
          break;
        }
      }
      if ((!v19 || Head[225] == 0) && !*(_DWORD *)(a1 + 340)) {
        break;
      }
      if (v19) {
        int v25 = Head[292] == 0;
      }
      else {
        int v25 = Head[291];
      }
      BOOL v19 = v25 != 0;
      if (Head && Head >= Head + 312) {
        goto LABEL_63;
      }
      if (VCMediaQueuePacketBundler_AddPacket(*(void *)(a1 + 136), Head))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VCMediaQueue_ScheduleFramesFromThrottlingQueue_cold_1();
          }
        }
        break;
      }
      CMSimpleQueueDequeue(*v11);
      if (v21[289])
      {
        uint64_t v26 = *((unsigned int *)v21 + 59);
        if (v50 == v26)
        {
          if (v21[291])
          {
            int v27 = 1;
LABEL_49:
            int *v49 = v27;
            goto LABEL_50;
          }
          int v28 = v21[292];
          ++*v49;
          if (v28)
          {
            unint64_t v29 = atomic_load(v9);
            while ((v26 - v29) <= 0x7FFFFFFE)
            {
              unint64_t v30 = v29;
              atomic_compare_exchange_strong((atomic_ullong *volatile)v9, &v30, 0xFFFFFFFFFFFFFFFFLL);
              BOOL v31 = v30 == v29;
              unint64_t v29 = v30;
              if (v31)
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                {
                  uint64_t v44 = VRTraceErrorLogLevelToCSTR();
                  OSStatus v32 = *MEMORY[0x1E4F47A50];
                  BOOL v33 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
                  int v27 = 0;
                  if (!v33) {
                    goto LABEL_49;
                  }
                  int v34 = *v45;
                  int v35 = *v49;
                  *(_DWORD *)buf = 136316162;
                  uint64_t v53 = v44;
                  __int16 v54 = 2080;
                  uint64_t v55 = "_VCMediaQueue_ResetLastIDRTimestamp";
                  __int16 v56 = 1024;
                  int v57 = 1185;
                  __int16 v58 = 1024;
                  int v59 = v34;
                  __int16 v60 = 1024;
                  int v61 = v35;
                  _os_log_impl(&dword_1E1EA4000, v32, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d IDR frame sent out. Reset lastIDRTimestamp for mediaQueueStreamId=%u, frameSizeInPackets=%u", buf, 0x28u);
                }
                break;
              }
            }
            int v27 = 0;
            goto LABEL_49;
          }
        }
      }
LABEL_50:
      int v36 = *((_DWORD *)v21 + 67);
      if (v21[293]) {
        int v37 = 48;
      }
      else {
        int v37 = 28;
      }
      int v38 = v37 + *(_DWORD *)v21;
      int v39 = *((unsigned __int16 *)v21 + 2);
      *(_DWORD *)(a1 + 420) += v36;
      *(_DWORD *)(a1 + 416) += v38 * v36;
      *v17 += v36;
      _DWORD *v18 = *((_DWORD *)v21 + 59);
      unsigned int v40 = (v38 + v39) * v36;
      unsigned int v41 = *(_DWORD *)(a1 + 340);
      BOOL v14 = v41 >= v40;
      unsigned int v42 = v41 - v40;
      if (v42 == 0 || !v14)
      {
        unsigned int v42 = 0;
        *(_DWORD *)(a1 + 344) += v40;
      }
      *(_DWORD *)(a1 + 340) = v42;
      uint64_t v13 = v40 + v13;
    }
    while (CMSimpleQueueGetCount(*v11) > 0);
  }
  *(_WORD *)(a1 + 600) |= 1 << v48;
  *(void *)(v47 + 176 * a2 + 32) = *(void *)(a1 + 320);
  return v13;
}

uint64_t _VCMediaQueue_CompareScheduleOrderElementWithScheduleTime(uint64_t a1, uint64_t a2)
{
  return (int)(*(double *)(a1 + 8) - *(double *)(a2 + 8));
}

void _VCMediaQueue_SendAndFreePackets(uint64_t a1)
{
  uint64_t v3 = MEMORY[0x1F4188790](a1);
  uint64_t v5 = v4;
  uint64_t v6 = v3;
  v84[1] = *MEMORY[0x1E4F143B8];
  __int16 v68 = (_DWORD *)(v3 + 25616);
  int v65 = *(_DWORD *)(v4 + 268);
  unsigned __int8 v7 = atomic_load((unsigned __int8 *)(v3 + 300));
  unsigned __int8 v71 = v7;
  double v8 = micro();
  int v66 = *(_DWORD *)(v5 + 176);
  if (v66 == 1) {
    int v9 = 700;
  }
  else {
    int v9 = 800;
  }
  unsigned int v69 = v9;
  unsigned int v70 = *(_DWORD *)(v5 + 264);
  memset(v83, 0, sizeof(v83));
  memset(v80, 0, sizeof(v80));
  unint64_t v10 = v75;
  uint64_t v81 = 0;
  bzero(v75, 0x2670uLL);
  signed int v11 = 0;
  unsigned int v67 = (pthread_mutex_t *)(v6 + 216);
  unint64_t v12 = 1;
  uint64_t v13 = v5;
  while (1)
  {
    while (1)
    {
      unsigned int v14 = *(_DWORD *)(v13 + 268);
      if (v14 >= 2 && *(void *)(v13 + 304))
      {
        int v50 = 0;
        goto LABEL_97;
      }
      if (!*(unsigned char *)(v13 + 58)) {
        break;
      }
      if (*(_WORD *)(v13 + 4)) {
        break;
      }
      uint64_t v19 = *(void *)(v13 + 304);
      if (!v19) {
        break;
      }
      *(unsigned char *)(v19 + 58) = 1;
      *(_WORD *)(v19 + 60) = *(_WORD *)(v13 + 60);
      unint64_t v12 = 1;
      *(unsigned char *)(v6 + 499) = 1;
      uint64_t v13 = v19;
    }
    dataPointerOut = 0;
    size_t lengthAtOffsetOut = 0;
    OSStatus DataPointer = CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(v13 + 8), 0, &lengthAtOffsetOut, 0, &dataPointerOut);
    if (DataPointer)
    {
      LODWORD(v1) = DataPointer;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v16 = VRTraceErrorLogLevelToCSTR();
        unsigned __int8 v2 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          int v21 = *(unsigned __int8 *)(v13 + 58);
          if (*(unsigned char *)(v13 + 58)) {
            int v22 = *(unsigned __int16 *)(v13 + 60);
          }
          else {
            int v22 = 0;
          }
          int v23 = *(_DWORD *)(v13 + 228);
          *(_DWORD *)buf = 136316674;
          *(void *)&uint8_t buf[4] = v16;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "_VCMediaQueue_SendAndFreePackets";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&uint8_t buf[24] = 1433;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v1;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v23;
          *(_WORD *)&unsigned char buf[40] = 1024;
          *(_DWORD *)&buf[42] = v21;
          *(_WORD *)&buf[46] = 1024;
          *(_DWORD *)&uint8_t buf[48] = v22;
          _os_log_error_impl(&dword_1E1EA4000, v2, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d CMBlock error %d when send/free media packet for mediaQueueStreamId=%u, isServerStats=%u, id=%u", buf, 0x34u);
        }
        unint64_t v10 = v75;
      }
      goto LABEL_94;
    }
    if (v11 >= 30) {
      break;
    }
    if (v71)
    {
      int v17 = *(_DWORD *)(v13 + 176);
      if (v17 == 1)
      {
        if (*(unsigned char *)(v13 + 94))
        {
          int v20 = *(void **)(v13 + 184);
          if (v20)
          {
            if (!*(unsigned char *)(v6 + 309))
            {
              *(_DWORD *)buf = bswap32(v68[3]);
              VCMediaControlInfoSetInfo(v20, (const char *)8, (uint64_t)buf, 4);
              *(unsigned char *)(v13 + 296) = 1;
              int v17 = *(_DWORD *)(v13 + 176);
              goto LABEL_29;
            }
          }
        }
        int v18 = *(_DWORD *)(v13 + 268);
      }
      else
      {
        if (!v17)
        {
          v68[3] = *(_DWORD *)(v13 + 236);
          int v18 = *(_DWORD *)(v13 + 268);
LABEL_31:
          if (*(unsigned char *)(v13 + 227)) {
            *v68 += v18;
          }
LABEL_35:
          int v24 = *(unsigned __int16 *)(v13 + 4);
          if (*(unsigned char *)(v13 + 293)) {
            int v25 = 48;
          }
          else {
            int v25 = 28;
          }
          v68[2] += (v25 + v24) * v18;
          uint64_t v26 = *(unsigned int *)(v13 + 244);
          unsigned __int8 v2 = &dataPointerOut[v26];
          if (dataPointerOut > &dataPointerOut[v26]) {
            goto LABEL_146;
          }
          if (v2 > &dataPointerOut[lengthAtOffsetOut]) {
            goto LABEL_146;
          }
          unint64_t v1 = (v24 - v26);
          if (lengthAtOffsetOut - v26 < v1) {
            goto LABEL_146;
          }
          unint64_t v10 = *(void **)(v13 + 184);
          if (v10)
          {
            if (VCMediaControlInfoHasInfo(*(void **)(v13 + 184), 0) && *(unsigned char *)(v6 + 130))
            {
              memset(buf, 0, 40);
              *(_DWORD *)&buf[28] = RTPPackDouble(*(double *)(v13 + 208));
              double v27 = *(double *)(v13 + 216);
              if (v27 == 0.0)
              {
                unsigned int v28 = 0;
              }
              else if (v27 == v8)
              {
                unsigned int v28 = 1;
              }
              else
              {
                unsigned int v28 = vcvtd_n_u64_f64(v8 - v27, 0xAuLL);
              }
              *(_DWORD *)&buf[20] = v28;
              unint64_t v29 = MicroToNTP(v8);
              unint64_t v12 = NTPToMiddle32(v29);
              *(_WORD *)&uint8_t buf[24] = v12 >> 6;
              VCMediaControlInfoSetInfoUnserialized(v10, (const char *)buf, 1);
              _VCMediaQueue_AddInfoToOneToOneTxHistory(v6, v12 >> 6, v8);
              pthread_mutex_lock(v67);
              if (*(unsigned char *)(v6 + 176))
              {
                *(unsigned char *)(v6 + 176) = 0;
                *(double *)(v6 + 200) = v8;
                *(_DWORD *)(v6 + 180) = *(_DWORD *)(v6 + 188);
              }
              if (*(unsigned char *)(v6 + 177))
              {
                *(unsigned char *)(v6 + 177) = 0;
                *(double *)(v6 + 208) = v8;
                *(_DWORD *)(v6 + 184) = *(_DWORD *)(v6 + 192);
                if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                {
                  uint64_t v64 = VRTraceErrorLogLevelToCSTR();
                  unint64_t v12 = *MEMORY[0x1E4F47A50];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                  {
                    int v30 = *(_DWORD *)(v6 + 184);
                    uint64_t v31 = *(void *)(v6 + 208);
                    *(_DWORD *)buf = 136316162;
                    *(void *)&uint8_t buf[4] = v64;
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = "_VCMediaQueue_UpdateStabilizationCounters";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&uint8_t buf[24] = 1334;
                    *(_WORD *)&buf[28] = 1024;
                    *(_DWORD *)&buf[30] = v30;
                    *(_WORD *)&buf[34] = 2048;
                    *(void *)&buf[36] = v31;
                    _os_log_impl(&dword_1E1EA4000, (os_log_t)v12, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Refresh frame counter=%d, time=%.4f", buf, 0x2Cu);
                  }
                }
              }
              pthread_mutex_unlock(v67);
            }
            if (v2 && v24 == v26)
            {
LABEL_146:
              __break(0x5519u);
              goto LABEL_147;
            }
            int v32 = VCMediaControlInfoSerialize((uint64_t)v10);
            if (v32 < 0)
            {
              LODWORD(v1) = v32;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                unsigned __int8 v2 = VRTraceErrorLogLevelToCSTR();
                unint64_t v12 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
                {
LABEL_147:
                  int v63 = *(unsigned __int16 *)(v13 + 248);
                  *(_DWORD *)buf = 136316418;
                  *(void *)&uint8_t buf[4] = v2;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = "_VCMediaQueue_SerializeMediaControlInfoInOneToOneMediaPacket";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&uint8_t buf[24] = 1352;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = v1;
                  *(_WORD *)&buf[34] = 1024;
                  *(_DWORD *)&buf[36] = v63;
                  *(_WORD *)&unsigned char buf[40] = 2048;
                  *(void *)&buf[42] = v10;
                  _os_log_error_impl(&dword_1E1EA4000, (os_log_t)v12, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d Adding extension failed with result=%08X for packet sequenceNum=%u controlInfo=%p", buf, 0x32u);
                }
              }
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  _VCMediaQueue_SendAndFreePackets_cold_7();
                }
              }
              goto LABEL_145;
            }
          }
          else if (!*(unsigned char *)(v6 + 130))
          {
            _VCMediaQueue_AddInfoToOneToOneTxHistory(v6, *(_DWORD *)(v13 + 236) / 0x3E8u, v8);
          }
          unint64_t v10 = v75;
          if (*(unsigned char *)(v13 + 297))
          {
            if (lengthAtOffsetOut < *(unsigned __int16 *)(v13 + 4)) {
              goto LABEL_146;
            }
            if (!*(_DWORD *)(v13 + 244))
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  _VCMediaQueue_SendAndFreePackets_cold_3();
                }
              }
LABEL_142:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  _VCMediaQueue_SendAndFreePackets_cold_2();
                }
              }
LABEL_145:
              int v50 = 0;
              unsigned int v14 = *(_DWORD *)(v13 + 268);
LABEL_97:
              *(_DWORD *)(v6 + 492) += v14;
              int v51 = v66;
              goto LABEL_102;
            }
            BOOL v33 = *(uint64_t (**)(uint64_t, char *))(v13 + 192);
            if (!v33)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  _VCMediaQueue_SendAndFreePackets_cold_4();
                }
              }
              goto LABEL_142;
            }
            uint64_t v34 = *(void *)(v13 + 200);
            if (v34 == 0xFFFFFFFFLL)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  _VCMediaQueue_SendAndFreePackets_cold_5();
                }
              }
              goto LABEL_142;
            }
            if ((v33(v34, dataPointerOut) & 0x80000000) != 0)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  _VCMediaQueue_SendAndFreePackets_cold_6();
                }
              }
              goto LABEL_142;
            }
            *(unsigned char *)(v13 + 297) = 0;
          }
          goto LABEL_68;
        }
LABEL_29:
        int v18 = *(_DWORD *)(v13 + 268);
        if (v17 != 1)
        {
          if (!v17) {
            goto LABEL_31;
          }
          goto LABEL_35;
        }
      }
      if (!*(unsigned char *)(v13 + 226)) {
        v68[1] += v18;
      }
      goto LABEL_35;
    }
LABEL_68:
    unint64_t v1 = (unint64_t)&v75[41 * v11];
    if (v1 >= (unint64_t)v80 || v1 < (unint64_t)v75) {
      goto LABEL_146;
    }
    int v35 = &v75[41 * v11];
    *((_DWORD *)v35 + 2) = *(_DWORD *)(v13 + 232);
    *((unsigned char *)v35 + 168) = 1;
    long long v37 = *(_OWORD *)(v13 + 64);
    long long v36 = *(_OWORD *)(v13 + 80);
    long long v38 = *(_OWORD *)(v13 + 48);
    *((_OWORD *)v35 + 12) = *(_OWORD *)(v13 + 32);
    *((_OWORD *)v35 + 13) = v38;
    *((_OWORD *)v35 + 14) = v37;
    *((_OWORD *)v35 + 15) = v36;
    *((_OWORD *)v35 + 11) = *(_OWORD *)(v13 + 16);
    unint64_t v12 = 1;
    *((unsigned char *)v35 + 205) = 1;
    *((unsigned char *)v35 + 313) = *(unsigned char *)(v13 + 297);
    VTP_SetPktTag((uint64_t)v35, 0, *(unsigned __int16 *)(v13 + 248));
    VTP_SetPktTag((uint64_t)v35, 1u, *(unsigned int *)(v13 + 252));
    VTP_SetPktTag((uint64_t)v35, 2u, *(unsigned int *)(v13 + 236));
    if (*((unsigned char *)v35 + 201))
    {
      *(unsigned char *)(v13 + 296) = 1;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        unsigned __int8 v2 = VRTraceErrorLogLevelToCSTR();
        unint64_t v1 = *MEMORY[0x1E4F47A50];
        int v39 = *MEMORY[0x1E4F47A50];
        if (*MEMORY[0x1E4F47A40])
        {
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            int v40 = *(unsigned __int16 *)(v6 + 604);
            int v41 = *(_DWORD *)(v13 + 228);
            int v42 = *(unsigned __int16 *)(v13 + 4);
            *(_DWORD *)buf = 136316418;
            *(void *)&uint8_t buf[4] = v2;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "_VCMediaQueue_SendAndFreePackets";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&uint8_t buf[24] = 1481;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v40;
            *(_WORD *)&buf[34] = 1024;
            *(_DWORD *)&buf[36] = v41;
            *(_WORD *)&unsigned char buf[40] = 1024;
            *(_DWORD *)&buf[42] = v42;
            _os_log_impl(&dword_1E1EA4000, (os_log_t)v1, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Sending out probingGroupID=%d, mediaQueueStreamId=%u, size=%d", buf, 0x2Eu);
          }
        }
        else if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
        {
          int v47 = *(unsigned __int16 *)(v6 + 604);
          int v48 = *(_DWORD *)(v13 + 228);
          int v49 = *(unsigned __int16 *)(v13 + 4);
          *(_DWORD *)buf = 136316418;
          *(void *)&uint8_t buf[4] = v2;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "_VCMediaQueue_SendAndFreePackets";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&uint8_t buf[24] = 1481;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v47;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v48;
          *(_WORD *)&unsigned char buf[40] = 1024;
          *(_DWORD *)&buf[42] = v49;
          _os_log_debug_impl(&dword_1E1EA4000, (os_log_t)v1, OS_LOG_TYPE_DEBUG, "VCMediaQueue [%s] %s:%d Sending out probingGroupID=%d, mediaQueueStreamId=%u, size=%d", buf, 0x2Eu);
        }
      }
      __int16 v43 = *(_WORD *)(v6 + 604);
      *((_WORD *)v78 + 164 * v11 + 5) = v43;
      if (*(unsigned char *)(v13 + 292)) {
        *(_WORD *)(v6 + 604) = v43 + 1;
      }
    }
    if (dataPointerOut && !lengthAtOffsetOut) {
      goto LABEL_146;
    }
    uint64_t v44 = &v83[v11];
    if (v44 >= v84) {
      goto LABEL_146;
    }
    if (v44 < v83) {
      goto LABEL_146;
    }
    v83[v11] = dataPointerOut;
    uint64_t v45 = (uint64_t *)((char *)v80 + 4 * v11);
    if (v45 >= &v82 || v45 < v80) {
      goto LABEL_146;
    }
    *(_DWORD *)uint64_t v45 = *(unsigned __int16 *)(v13 + 4);
    int v46 = *(_DWORD *)(v13 + 268);
    if (*(unsigned char *)(v13 + 227))
    {
      *(_DWORD *)(v6 + 476) += v46;
      *(_WORD *)(v6 + 496) = *(_WORD *)(v13 + 248);
    }
    else
    {
      *(_DWORD *)(v6 + 480) += v46;
    }
    if (*(unsigned char *)(v13 + 226)) {
      *(_DWORD *)(v6 + 488) += v46;
    }
    if (*(unsigned char *)(v13 + 296)) {
      *(_DWORD *)(v6 + 484) += v46;
    }
    ++v11;
    if (*(unsigned char *)(v13 + 289)) {
      *(unsigned char *)(v6 + 498) = 1;
    }
LABEL_94:
    uint64_t v13 = *(void *)(v13 + 304);
    if (!v13) {
      goto LABEL_101;
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCMediaQueue_SendAndFreePackets_cold_1();
    }
  }
LABEL_101:
  int v51 = v66;
  int v50 = v65;
LABEL_102:
  int v52 = v50;
  if (v51 == 1)
  {
    *(void *)(v6 + 544) += v50;
    uint64_t v53 = (void *)(v6 + 576);
  }
  else
  {
    *(void *)(v6 + 552) += v50;
    uint64_t v53 = (void *)(v6 + 568);
  }
  ++*v53;
  *(void *)(v6 + 560) += v50;
  ++*(void *)(v6 + 584);
  if (v50 >= 1)
  {
    int v54 = 0;
    do
    {
      if (v71)
      {
        if (v11 >= 2 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          uint64_t v57 = VRTraceErrorLogLevelToCSTR();
          __int16 v58 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(void *)&uint8_t buf[4] = v57;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "_VCMediaQueue_SendAndFreePackets";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&uint8_t buf[24] = 1498;
            _os_log_error_impl(&dword_1E1EA4000, v58, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d One to one should not have compound packets", buf, 0x1Cu);
          }
        }
        _VCMediaQueue_RateStats_TrackMediaPacket(*(void *)(v6 + 160), v5, 0, v8);
        unsigned __int8 v59 = atomic_load((unsigned __int8 *)(v6 + 302));
        char v79 = v59 & 1;
        if (*(unsigned char *)(v5 + 227)) {
          int v60 = 16;
        }
        else {
          int v60 = 32;
        }
        int v76 = v60;
        VTP_Send(v70, v83[0], LODWORD(v80[0]), v69, (uint64_t)v75);
        unsigned int v61 = *(_DWORD *)(v5 + 256);
        if (v61 > *(_DWORD *)(v6 + 188))
        {
          *(unsigned char *)(v6 + 176) = 1;
          *(_DWORD *)(v6 + 188) = v61;
        }
        unsigned int v62 = *(_DWORD *)(v5 + 260);
        if (v62 > *(_DWORD *)(v6 + 192))
        {
          *(unsigned char *)(v6 + 177) = 1;
          *(_DWORD *)(v6 + 192) = v62;
        }
      }
      else
      {
        if (v54 && v11 == 1)
        {
          long long v55 = *(_OWORD *)(v5 + 144);
          v78[1] = *(_OWORD *)(v5 + 128);
          v78[2] = v55;
          v78[3] = *(_OWORD *)(v5 + 160);
          long long v56 = *(_OWORD *)(v5 + 112);
          long long v77 = *(_OWORD *)(v5 + 96);
          v78[0] = v56;
        }
        VTP_SendCompoundPacket(v70);
      }
      atomic_fetch_add((atomic_uint *volatile)(v6 + 296), v11);
      ++v54;
    }
    while (v52 != v54);
  }
  _VCMediaQueue_FreeMediaPacketList(v6, v5);
}

void _VCMediaQueue_RateStats_TrackMediaPacket(uint64_t a1, uint64_t a2, int a3, double a4)
{
  if (a1 && a2)
  {
    int v5 = *(unsigned __int16 *)(a2 + 4);
    if (*(unsigned char *)(a2 + 293)) {
      int v6 = 48;
    }
    else {
      int v6 = 28;
    }
    uint64_t v7 = a1 + 672;
    if (a3) {
      uint64_t v7 = a1 + 224;
    }
    uint64_t v8 = a1 + 448;
    if (a3) {
      uint64_t v8 = a1;
    }
    if (*(unsigned char *)(a2 + 227)) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = v7;
    }
    unint64_t v10 = v9 + 136;
    int v11 = *(_DWORD *)(v9 + 148);
    int v12 = vcvtd_n_s64_f64(a4 - *(double *)(v9 + 136), 6uLL);
    if (v12)
    {
      if (v12 > 15)
      {
        if (v12 > 0x1F)
        {
          int v11 = 0;
          unsigned int v15 = 0;
          *(_OWORD *)(v9 + 120) = 0u;
          *(_OWORD *)(v9 + 104) = 0u;
          *(_OWORD *)(v9 + 88) = 0u;
          *(_OWORD *)(v9 + 72) = 0u;
          *(_OWORD *)(v9 + 56) = 0u;
          *(_OWORD *)(v9 + 40) = 0u;
          *(_OWORD *)(v9 + 24) = 0u;
          *(_OWORD *)(v9 + 8) = 0u;
        }
        else
        {
          int v21 = *(unsigned __int16 *)(v9 + 144);
          int v22 = v21 + v12;
          unsigned int v15 = (v21 + v12) & 0x1F;
          uint64_t v23 = ((_BYTE)v21 + 1) & 0x1F;
          if (v15 >= v23)
          {
            double v27 = (void *)(v9 + 8 + 4 * v23);
            size_t v26 = 4 * (int)(v15 - v23 + 1);
            if (v10 < (unint64_t)v27 || v9 + 8 > (unint64_t)v27 || v26 > v10 - (unint64_t)v27) {
              goto LABEL_57;
            }
          }
          else
          {
            int v24 = (void *)(v9 + 8 + 4 * (((_BYTE)v21 + 1) & 0x1F));
            if (v10 < (unint64_t)v24) {
              goto LABEL_57;
            }
            if (v9 + 8 > (unint64_t)v24) {
              goto LABEL_57;
            }
            size_t v25 = (128 - 4 * v23);
            if (v10 - (unint64_t)v24 < v25) {
              goto LABEL_57;
            }
            bzero(v24, v25);
            size_t v26 = 4 * v15 + 4;
            double v27 = (void *)(v9 + 8);
          }
          bzero(v27, v26);
          unsigned int v30 = (v22 + 1) & 0x1F;
          if (v30 != v23)
          {
            int v11 = 0;
            unint64_t v31 = v9 + 8;
            while (1)
            {
              int v32 = (_DWORD *)(v31 + 4 * v30);
              if ((unint64_t)v32 >= v10 || (unint64_t)v32 < v31) {
                goto LABEL_57;
              }
              v11 += *v32;
              unsigned int v30 = ((_BYTE)v30 + 1) & 0x1F;
              if (v30 == v23) {
                goto LABEL_51;
              }
            }
          }
          int v11 = 0;
        }
      }
      else
      {
        char v13 = *(_WORD *)(v9 + 144);
        char v14 = v13 + v12;
        unsigned int v15 = v14 & 0x1F;
        int v16 = (v14 + 1) & 0x1F;
        unsigned int v17 = (v13 + 1) & 0x1F;
        if (v17 != v16)
        {
          unint64_t v18 = v9 + 8;
          do
          {
            uint64_t v19 = (_DWORD *)(v18 + 4 * v17);
            if ((unint64_t)v19 >= v10 || (unint64_t)v19 < v18) {
              goto LABEL_57;
            }
            v11 -= *v19;
            _DWORD *v19 = 0;
            unsigned int v17 = ((_BYTE)v17 + 1) & 0x1F;
          }
          while (v17 != v16);
        }
      }
    }
    else
    {
      unsigned int v15 = -1;
    }
LABEL_51:
    int v34 = v6 + v5;
    int v35 = v11 + v34;
    pthread_mutex_lock((pthread_mutex_t *)(v9 + 160));
    *(_DWORD *)(v9 + 148) = v35;
    if (v15 != -1)
    {
      *(double *)(v9 + 136) = *(double *)v9 + (double)vcvtd_n_u64_f64(a4 - *(double *)v9, 6uLL) * 0.015625;
      *(_WORD *)(v9 + 144) = v15;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v9 + 160));
    long long v36 = (_DWORD *)(v9 + 8 + 4 * *(__int16 *)(v9 + 144));
    if ((unint64_t)v36 < v10 && (unint64_t)v36 >= v9 + 8)
    {
      *v36 += v34;
      return;
    }
LABEL_57:
    __break(0x5519u);
    return;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCMediaQueue_RateStats_TrackMediaPacket_cold_1();
    }
  }
}

uint64_t _VCMediaQueue_PreAllocVCMediaPacketsInFreePool(uint64_t a1, opaqueCMSimpleQueue *a2)
{
  uint64_t v4 = 2149580803;
  int v5 = malloc_type_calloc(1uLL, 0x138uLL, 0x10A0040637F5F0DuLL);
  if (v5)
  {
    int v6 = v5;
    if (*(unsigned char *)(a1 + 96)
      || (CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0x5DCuLL, 0, 0, 0, 0x5DCuLL, 1u, (CMBlockBufferRef *)v5 + 1), v6[1]))
    {
      if (!CMSimpleQueueEnqueue(a2, v6)) {
        return 0;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCMediaQueue_PreAllocVCMediaPacketsInFreePool_cold_2();
        }
      }
      uint64_t v7 = (const void *)v6[1];
      uint64_t v4 = 2149580829;
      if (v7) {
        CFRelease(v7);
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCMediaQueue_PreAllocVCMediaPacketsInFreePool_cold_1();
      }
    }
    free(v6);
  }
  return v4;
}

uint64_t VCMediaQueue_CleanupTxHistory(uint64_t a1)
{
  unsigned __int8 v2 = (pthread_mutex_t *)(a1 + 25552);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 25552));
  bzero((void *)(a1 + 976), 0x6000uLL);
  *(void *)(a1 + 968) = 0;
  pthread_mutex_unlock(v2);
  return 0;
}

uint64_t _VCMediaQueue_CreateInternalQueue(uint64_t a1, uint64_t a2, int32_t a3)
{
  uint64_t v4 = a2;
  int v6 = malloc_type_calloc((int)a2, 0xB0uLL, 0x1020040A2190033uLL);
  if (!v6)
  {
    uint64_t v4 = 2149580803;
LABEL_47:
    if (*(void *)(a1 + 624))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCMediaQueue_CreateInternalQueue_cold_1();
        }
      }
      _VCMediaQueue_DestroyInternalQueues(a1);
      *(void *)(a1 + 624) = 0;
      *(_DWORD *)(a1 + 348) = 0;
    }
    return v4;
  }
  *(void *)(a1 + 624) = v6;
  *(_DWORD *)(a1 + 348) = v4;
  if (!v4) {
    return v4;
  }
  uint64_t v7 = 0;
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  while (1)
  {
    CMSimpleQueueCreate(v8, a3, (CMSimpleQueueRef *)(*(void *)(a1 + 624) + 176 * v7));
    CMSimpleQueueCreate(v8, a3, (CMSimpleQueueRef *)(*(void *)(a1 + 624) + 176 * v7 + 8));
    uint64_t result = CMSimpleQueueCreate(v8, a3, (CMSimpleQueueRef *)(*(void *)(a1 + 624) + 176 * v7 + 16));
    unint64_t v10 = *(void *)(a1 + 624);
    if (v10 + 176 * v7 >= v10 + 176 * *(unsigned int *)(a1 + 348) || v10 + 176 * v7 < v10) {
      break;
    }
    unint64_t v12 = v10 + 176 * v7;
    *(_DWORD *)(v12 + 24) = 0;
    *(void *)(v12 + 136) = 0;
    *(void *)(v12 + 144) = 0;
    *(void *)(v12 + 128) = 0;
    unint64_t v13 = *(void *)(a1 + 624);
    unint64_t v14 = v13 + 176 * v7;
    if (v14 >= v13 + 176 * *(unsigned int *)(a1 + 348) || v14 < v13) {
      break;
    }
    unint64_t v16 = v13 + 176 * v7;
    *(_DWORD *)(v16 + 152) = 0;
    *(unsigned char *)(v16 + 92) = 0;
    unint64_t v17 = *(void *)(a1 + 624);
    unint64_t v18 = v17 + 176 * v7;
    if (v18 >= v17 + 176 * *(unsigned int *)(a1 + 348) || v18 < v17) {
      break;
    }
    *(unsigned char *)(v17 + 176 * v7 + 93) = 0;
    unint64_t v20 = *(void *)(a1 + 624);
    unint64_t v21 = v20 + 176 * v7;
    if (v21 >= v20 + 176 * *(unsigned int *)(a1 + 348)) {
      break;
    }
    if (v21 < v20) {
      break;
    }
    *(unsigned char *)(v20 + 176 * v7 + 96) = 0;
    unint64_t v22 = *(void *)(a1 + 624);
    unint64_t v23 = v22 + 176 * v7;
    if (v23 >= v22 + 176 * *(unsigned int *)(a1 + 348) || v23 < v22) {
      break;
    }
    *(unsigned char *)(v22 + 176 * v7 + 97) = 0;
    int32_t v24 = a3;
    if (a3 >= 1)
    {
      do
      {
        unint64_t v25 = *(void *)(a1 + 624);
        size_t v26 = (opaqueCMSimpleQueue **)(v25 + 176 * v7);
        if ((unint64_t)v26 >= v25 + 176 * *(unsigned int *)(a1 + 348) || (unint64_t)v26 < v25) {
          goto LABEL_56;
        }
        uint64_t result = _VCMediaQueue_PreAllocVCMediaPacketsInFreePool(a1, *v26);
        if (result)
        {
          uint64_t v4 = result;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              _VCMediaQueue_CreateInternalQueue_cold_2();
            }
          }
          goto LABEL_47;
        }
      }
      while (--v24);
    }
    unint64_t v28 = *(void *)(a1 + 624);
    unint64_t v29 = v28 + 176 * v7;
    if (v29 >= v28 + 176 * *(unsigned int *)(a1 + 348) || v29 < v28) {
      break;
    }
    *(unsigned char *)(v28 + 176 * v7 + 94) = 0;
    unint64_t v31 = *(void *)(a1 + 624);
    unint64_t v32 = v31 + 176 * v7;
    if (v32 >= v31 + 176 * *(unsigned int *)(a1 + 348)) {
      break;
    }
    if (v32 < v31) {
      break;
    }
    *(unsigned char *)(v31 + 176 * v7 + 95) = 0;
    unint64_t v33 = *(void *)(a1 + 624);
    unint64_t v34 = v33 + 176 * v7;
    if (v34 >= v33 + 176 * *(unsigned int *)(a1 + 348)) {
      break;
    }
    if (v34 < v33) {
      break;
    }
    *(void *)(v33 + 176 * v7 + 104) = -1;
    unint64_t v35 = *(void *)(a1 + 624);
    unint64_t v36 = v35 + 176 * v7;
    if (v36 >= v35 + 176 * *(unsigned int *)(a1 + 348)) {
      break;
    }
    if (v36 < v35) {
      break;
    }
    *(void *)(v35 + 176 * v7 + 112) = -1;
    unint64_t v37 = *(void *)(a1 + 624);
    unint64_t v38 = v37 + 176 * v7;
    if (v38 >= v37 + 176 * *(unsigned int *)(a1 + 348) || v38 < v37) {
      break;
    }
    *(_DWORD *)(v37 + 176 * v7++ + 120) = 0;
    if (v7 == v4) {
      return 0;
    }
  }
LABEL_56:
  __break(0x5519u);
  return result;
}

void _VCMediaQueue_DestroyInternalQueues(uint64_t a1)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v36 = *(unsigned int *)(a1 + 348);
  unsigned __int8 v2 = *(opaqueCMSimpleQueue ***)(a1 + 624);
  double v3 = 0.0;
  if (VRTraceIsInternalOSInstalled()) {
    double v3 = micro();
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    int v5 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *(unsigned __int8 *)(a1 + 96);
      *(_DWORD *)buf = 136316162;
      uint64_t v38 = v4;
      __int16 v39 = 2080;
      int v40 = "_VCMediaQueue_DestroyInternalQueues";
      __int16 v41 = 1024;
      int v42 = 1616;
      __int16 v43 = 1024;
      OSStatus v44 = v36;
      __int16 v45 = 1024;
      int v46 = v6;
      _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d numberOfInternalQueues=%d mediaQueue->config.useExternalDataBuffer=%d", buf, 0x28u);
    }
  }
  if ((int)v36 >= 1)
  {
    for (uint64_t i = 0; i != v36; ++i)
    {
      CFAllocatorRef v8 = &v2[22 * i];
      if (v8)
      {
        uint64_t v9 = &v2[22 * i];
        int v11 = v9[2];
        unint64_t v10 = v9 + 2;
        if (CMSimpleQueueGetCount(v11) >= 1)
        {
          unint64_t v12 = &v2[22 * i + 1];
          do
          {
            Head = CMSimpleQueueGetHead(*v10);
            CMSimpleQueueDequeue(*v10);
            if (Head == CMSimpleQueueGetHead(*v12))
            {
              uint64_t v20 = Head[23];
              if (v20)
              {
                VCMediaControlInfoDispose(v20);
                Head[23] = 0;
              }
              _VCMediaQueue_ReleaseExternalDataBuffer(a1, (uint64_t)Head);
              unint64_t v21 = *v8;
              unint64_t v22 = CMSimpleQueueDequeue(*v12);
              OSStatus v23 = CMSimpleQueueEnqueue(v21, v22);
              if (!v23) {
                continue;
              }
              OSStatus v24 = v23;
              if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
                continue;
              }
              uint64_t v35 = VRTraceErrorLogLevelToCSTR();
              unint64_t v25 = *MEMORY[0x1E4F47A50];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                continue;
              }
              int v26 = *((_DWORD *)Head + 57);
              *(_DWORD *)buf = 136316162;
              uint64_t v38 = v35;
              __int16 v39 = 2080;
              int v40 = "_VCMediaQueue_FreeInternalQueueMediaPackets";
              __int16 v41 = 1024;
              int v42 = 1654;
              __int16 v43 = 1024;
              OSStatus v44 = v24;
              __int16 v45 = 1024;
              int v46 = v26;
              unint64_t v17 = v25;
              unint64_t v18 = "VCMediaQueue [%s] %s:%d Internal queue has error=%d when free media packet for mediaQueueStreamId=%u"
                    " in _VCMediaQueue_FreeInternalQueueMediaPackets";
              uint32_t v19 = 40;
            }
            else
            {
              if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
                continue;
              }
              uint64_t v14 = VRTraceErrorLogLevelToCSTR();
              unsigned int v15 = *MEMORY[0x1E4F47A50];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                continue;
              }
              OSStatus v16 = *((_DWORD *)Head + 57);
              *(_DWORD *)buf = 136315906;
              uint64_t v38 = v14;
              __int16 v39 = 2080;
              int v40 = "_VCMediaQueue_FreeInternalQueueMediaPackets";
              __int16 v41 = 1024;
              int v42 = 1656;
              __int16 v43 = 1024;
              OSStatus v44 = v16;
              unint64_t v17 = v15;
              unint64_t v18 = "VCMediaQueue [%s] %s:%d Media packets are drained from the busy pool of stream=%u out of order! in _"
                    "VCMediaQueue_FreeInternalQueueMediaPackets";
              uint32_t v19 = 34;
            }
            _os_log_error_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_ERROR, v18, buf, v19);
          }
          while (CMSimpleQueueGetCount(*v10) > 0);
        }
        _VCMediaQueue_DestroyInternalQueuePool(a1, v2[22 * i + 1]);
        _VCMediaQueue_DestroyInternalQueuePool(a1, *v8);
        if (*v10) {
          CFRelease(*v10);
        }
      }
    }
  }
  free(v2);
  LogProfileTimeOverLimit_2(v3, v27, v28, v29, v30, v31, v32, v33, v34, (char)"_VCMediaQueue_DestroyInternalQueues");
}

void _VCMediaQueue_DestroyInternalQueuePool(uint64_t a1, opaqueCMSimpleQueue *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v4 = VRTraceErrorLogLevelToCSTR();
      int v5 = *MEMORY[0x1E4F47A50];
      int v6 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = 136316162;
          uint64_t v11 = v4;
          __int16 v12 = 2080;
          unint64_t v13 = "_VCMediaQueue_DestroyInternalQueuePool";
          __int16 v14 = 1024;
          int v15 = 1597;
          __int16 v16 = 1024;
          int32_t Count = CMSimpleQueueGetCount(a2);
          __int16 v18 = 2048;
          uint32_t v19 = a2;
          _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d count=%d in pool=%p", (uint8_t *)&v10, 0x2Cu);
        }
      }
      else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        _VCMediaQueue_DestroyInternalQueuePool_cold_1(v4, a2, v5);
      }
    }
    if (CMSimpleQueueGetCount(a2) >= 1)
    {
      do
      {
        uint64_t v7 = (char *)CMSimpleQueueDequeue(a2);
        if (v7)
        {
          CFAllocatorRef v8 = v7;
          if (!*(unsigned char *)(a1 + 96))
          {
            uint64_t v9 = (const void *)*((void *)v7 + 1);
            if (v9)
            {
              if (v8 >= v8 + 312) {
                __break(0x5519u);
              }
              CFRelease(v9);
            }
          }
          free(v8);
        }
      }
      while (CMSimpleQueueGetCount(a2) > 0);
    }
    CFRelease(a2);
  }
}

void LogProfileTimeOverLimit_2(double a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (VRTraceIsInternalOSInstalled())
  {
    double v11 = micro() - a1;
    if (v11 > 3.0)
    {
      *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v39 = v12;
      long long v40 = v12;
      long long v37 = v12;
      long long v38 = v12;
      long long v35 = v12;
      long long v36 = v12;
      long long v33 = v12;
      long long v34 = v12;
      long long v31 = v12;
      long long v32 = v12;
      long long v30 = v12;
      long long v28 = v12;
      long long v29 = v12;
      long long v26 = v12;
      long long v27 = v12;
      *(_OWORD *)__str = v12;
      vsnprintf(__str, 0x100uLL, "%s: done destroying numberOfInternalQueues=%d", &a10);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v13 = VRTraceErrorLogLevelToCSTR();
        __int16 v14 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          uint64_t v16 = v13;
          __int16 v17 = 2080;
          __int16 v18 = "_LogProfileTimeLimitHelper";
          __int16 v19 = 1024;
          int v20 = 36;
          __int16 v21 = 2080;
          unint64_t v22 = __str;
          __int16 v23 = 2048;
          double v24 = v11;
          _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %s: Took a long time %fs", buf, 0x30u);
        }
      }
    }
  }
}

void _VCMediaQueue_CheckAndReportSymptomForInternalQueue(uint64_t a1)
{
  double v2 = micro();
  unsigned int v3 = *(_DWORD *)(a1 + 152);
  unint64_t v4 = a1 + 128;
  int v5 = (double *)(a1 + 128 + 8 * (v3 % 3));
  if ((unint64_t)v5 >= a1 + 152 || (unint64_t)v5 < v4)
  {
LABEL_17:
    __break(0x5519u);
    return;
  }
  double *v5 = v2;
  unsigned int v7 = v3 + 1;
  int v8 = *(_DWORD *)(a1 + 156) + 1;
  *(_DWORD *)(a1 + 152) = v7;
  *(_DWORD *)(a1 + 156) = v8;
  if (v7 >= 3)
  {
    uint64_t v9 = (double *)(v4 + 8 * (v7 % 3));
    if ((unint64_t)v9 >= a1 + 152 || (unint64_t)v9 < v4) {
      goto LABEL_17;
    }
    if (v2 - *v9 <= 5.0)
    {
      reportingSymptom();
    }
  }
}

uint64_t _VCMediaQueue_GetGeneralQueueInfo(uint64_t result)
{
  if (*(_DWORD *)(result + 348))
  {
    uint64_t v1 = result;
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    do
    {
      uint64_t v4 = *(void *)(v1 + 624) + v2;
      uint64_t result = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(v4 + 16));
      *(_DWORD *)(v1 + 440) += result;
      double v5 = *(double *)(v1 + 592);
      if (v5 <= *(double *)(v4 + 48)) {
        double v5 = *(double *)(v4 + 48);
      }
      *(double *)(v1 + 592) = v5;
      ++v3;
      v2 += 176;
    }
    while (v3 < *(unsigned int *)(v1 + 348));
  }
  return result;
}

void _VCMediaQueue_ResetStatistics(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 484) = 0;
  *(void *)(a1 + 476) = 0;
  *(void *)(a1 + 492) = 0;
  *(_DWORD *)(a1 + 336) = 0;
  *(_DWORD *)(a1 + 344) = 0;
  *(_DWORD *)(a1 + 600) = 0;
  long long v1 = *(_OWORD *)(a1 + 428);
  *(_OWORD *)(a1 + 444) = *(_OWORD *)(a1 + 412);
  *(_OWORD *)(a1 + 460) = v1;
  *(void *)(a1 + 592) = 0;
  if (*(_DWORD *)(a1 + 348))
  {
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    double v5 = (os_log_t *)MEMORY[0x1E4F47A50];
    do
    {
      uint64_t v6 = *(void *)(a1 + 624);
      if (v6 + v3)
      {
        uint64_t v7 = v6 + v3;
        *(_DWORD *)(v7 + 76) = 0;
        *(_DWORD *)(v7 + 80) = 0;
        *(void *)(v7 + 48) = 0;
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v8 = VRTraceErrorLogLevelToCSTR();
        uint64_t v9 = *v5;
        if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          uint64_t v11 = v8;
          __int16 v12 = 2080;
          uint64_t v13 = "_VCMediaQueue_ResetStatistics";
          __int16 v14 = 1024;
          int v15 = 1868;
          __int16 v16 = 1024;
          int v17 = v4;
          _os_log_error_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d Internal queue with index %d is NULL", buf, 0x22u);
        }
      }
      ++v4;
      v3 += 176;
    }
    while (v4 < *(unsigned int *)(a1 + 348));
  }
}

void _VCMediaQueue_DumpStatisticsToFile(uint64_t a1)
{
  if (*(void *)(a1 + 168))
  {
    _VCMediaQueue_GetGeneralQueueInfo(a1);
    VRLogfilePrintWithTimestamp(*(void *)(a1 + 168), "%1u\t%4.3f\t%u\t%u\t%u/%u/%u/%u\t%08X\t%08X\t%u\t%.3f\t%1u\t%u/%u\t%u/%u\t%5u/%5u\t%.2f\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n", *(unsigned __int8 *)(a1 + 498), *(unsigned __int8 *)(a1 + 499), *(unsigned __int16 *)(a1 + 496), *(unsigned int *)(a1 + 336), *(unsigned int *)(a1 + 340), *(unsigned int *)(a1 + 344), *(_DWORD *)(a1 + 88));
    unint64_t v2 = *(unsigned int *)(a1 + 348);
    if (v2)
    {
      uint64_t v3 = 0;
      uint64_t v4 = 0;
      unint64_t v5 = 0;
      unint64_t v6 = a1 + 632;
      do
      {
        uint64_t v7 = *(void *)(a1 + 624);
        if (v7 + v4 && *(double *)(v7 + v4 + 48) > 0.1)
        {
          CMSimpleQueueGetHead(*(CMSimpleQueueRef *)(v7 + v4 + 16));
          if (v6 + v3 >= a1 + 760 || v6 + v3 < v6)
          {
            __break(0x5519u);
            return;
          }
          VRLogfilePrint(*(void *)(a1 + 168), "[InternalQueue]\t%2u\t%1u\t%d\t%u/%u\t%u\t%u\t%u\t%u\n", v8, v9, v10, v11, v12, v13, v5);
          unint64_t v2 = *(unsigned int *)(a1 + 348);
        }
        ++v5;
        v4 += 176;
        v3 += 4;
      }
      while (v5 < v2);
    }
  }

  _VCMediaQueue_ResetStatistics(a1);
}

void _VCMediaQueue_ReleaseLogDumpFile(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  long long v1 = (FILE ***)(a1 + 168);
  if (*(void *)(a1 + 168))
  {
    *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
    void v9[6] = v2;
    v9[7] = v2;
    void v9[4] = v2;
    v9[5] = v2;
    void v9[2] = v2;
    v9[3] = v2;
    v9[0] = v2;
    v9[1] = v2;
    micro();
    VRLogfileGetTimestamp((char *)v9, 0x80u);
    VRLogfilePrintSync(*v1, "%s\t%8.3f\tEndOfFile\n", v3, v4, v5, v6, v7, v8, (char)v9);
    VRLogfileFree((uint64_t *)v1);
    NSObject *v1 = 0;
  }
}

FILE **_VCMediaQueue_CreateLogDumpFile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10 = VRLogfileAlloc(0, a2, (uint64_t)"VCMediaQueue", (uint64_t)".mqdump", "com.apple.VideoConference.VCMediaQueuelog", 9);
  *(void *)(a1 + 168) = v10;
  VRLogfilePrintSync(v10, "STime\t\tSchedulePolicy\tExpInterval\tPBR\tIBR\tBudgetTuple\tIDRBitmap\tSendBitmap\tPktLeft\tWQSize\tBundlePolicy\tPktCount\tNetworkOverhead\tTotalSize\tPBAFactor\thasIDR\thasServerStats\tAudioSeq\tAudioPkt\tVideoPkt\tProbPkt\tScreenPkt\tFailedPkt\n", v11, v12, v13, v14, v15, v16, v25);
  __int16 v23 = *(FILE ***)(a1 + 168);

  return VRLogfilePrintSync(v23, "[InternalQueue]\tIndex\tType\tStreamId\tQSizeTuple\tOldTS\tIDR\tPktSch\tLastSchTS\tProbingSeq\n", v17, v18, v19, v20, v21, v22, a9);
}

double VCMediaQueue_GetPreSetConfiguration@<D0>(uint64_t a1@<X8>)
{
  *(_OWORD *)(a1 + 64) = xmmword_1E6DB8DA8;
  *(_OWORD *)(a1 + 80) = unk_1E6DB8DB8;
  *(_OWORD *)(a1 + 96) = xmmword_1E6DB8DC8;
  *(void *)(a1 + 112) = 0;
  *(_OWORD *)a1 = xmmword_1E6DB8D68;
  *(_OWORD *)(a1 + 16) = unk_1E6DB8D78;
  double result = 0.5;
  *(_OWORD *)(a1 + 32) = xmmword_1E6DB8D88;
  *(_OWORD *)(a1 + 48) = unk_1E6DB8D98;
  return result;
}

unint64_t VCMediaQueue_Create(unint64_t *a1, unsigned int *a2)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  if (*a2 > 0x20)
  {
    uint64_t v2 = 2149580801;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaQueue_Create_cold_1();
      }
    }
    return v2;
  }
  if (_VCMediaQueueGetTypeID_initOnce != -1) {
    dispatch_once_f(&_VCMediaQueueGetTypeID_initOnce, &_VCMediaQueueGetTypeID_typeID, (dispatch_function_t)_VCMediaQueueClassRegister);
  }
  unint64_t result = _CFRuntimeCreateInstance();
  if (!result)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
      return 2149580803;
    }
    VRTraceErrorLogLevelToCSTR();
    uint64_t v2 = 2149580803;
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCMediaQueue_Create_cold_2();
    }
    return v2;
  }
  unint64_t v6 = result;
  unint64_t v7 = result + 25736;
  unint64_t v8 = result + 16;
  if (result + 16 <= result + 25736 && result < v8)
  {
    bzero((void *)(result + 16), 0x6478uLL);
    long long v10 = *((_OWORD *)a2 + 4);
    long long v11 = *((_OWORD *)a2 + 5);
    long long v12 = *((_OWORD *)a2 + 6);
    *(void *)(v8 + 112) = *((void *)a2 + 14);
    *(_OWORD *)(v8 + 96) = v12;
    long long v13 = *(_OWORD *)a2;
    long long v14 = *((_OWORD *)a2 + 1);
    long long v15 = *((_OWORD *)a2 + 3);
    *(_OWORD *)(v8 + 32) = *((_OWORD *)a2 + 2);
    *(_OWORD *)(v8 + 48) = v15;
    *(_OWORD *)unint64_t v8 = v13;
    *(_OWORD *)(v8 + 16) = v14;
    *(_OWORD *)(v8 + 64) = v10;
    *(_OWORD *)(v8 + 80) = v11;
    unint64_t result = *(void *)(v6 + 120);
    if (result) {
      unint64_t result = (unint64_t)CFRetain((CFTypeRef)result);
    }
    if (v6 < v7)
    {
      uint64_t v16 = *MEMORY[0x1E4F1CF80];
      if (CMSimpleQueueCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 900, (CMSimpleQueueRef *)(v6 + 616)))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        {
          uint64_t v2 = 2149580803;
        }
        else
        {
          VRTraceErrorLogLevelToCSTR();
          uint64_t v2 = 2149580803;
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCMediaQueue_Create_cold_8();
          }
        }
      }
      else
      {
        uint64_t InternalQueue = _VCMediaQueue_CreateInternalQueue(v6, *a2, 3000);
        if (InternalQueue)
        {
          uint64_t v2 = InternalQueue;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              VCMediaQueue_Create_cold_7();
            }
          }
        }
        else
        {
          Boolean keyExistsAndHasValidFormat = 0;
          AppBooleanCFBooleanRef Value = CFPreferencesGetAppBooleanValue(@"disableMQPacketBundling", @"com.apple.VideoConference", &keyExistsAndHasValidFormat);
          if (keyExistsAndHasValidFormat && AppBooleanValue)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              uint64_t v19 = VRTraceErrorLogLevelToCSTR();
              uint64_t v20 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                uint64_t v51 = v19;
                __int16 v52 = 2080;
                uint64_t v53 = "VCMediaQueue_Create";
                __int16 v54 = 1024;
                int v55 = 2011;
                _os_log_impl(&dword_1E1EA4000, v20, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue: Force Disabling Packet Bundling", buf, 0x1Cu);
              }
            }
            int v21 = 0;
            *(_DWORD *)(v6 + 92) = 0;
          }
          else
          {
            int v21 = *(_DWORD *)(v6 + 92);
          }
          unint64_t v22 = VCMediaQueuePacketBundler_Create(v16, (void *)(v6 + 136), v21, 1500);
          if (v22)
          {
            uint64_t v2 = v22;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                VCMediaQueue_Create_cold_6();
              }
            }
          }
          else
          {
            uint64_t v23 = VCRealTimeThread_Initialize(19, (uint64_t)VCMediaQueueSendProc, v6, "com.apple.AVConference.VCMediaQueueSendProc", 3);
            *(void *)(v6 + 768) = v23;
            if (v23)
            {
              *(unsigned char *)(v6 + 280) = 0;
              *(void *)(v6 + 284) = 1000000;
              *(_DWORD *)(v6 + 296) = 0;
              *(_WORD *)(v6 + 300) = 0;
              *(_DWORD *)(v6 + 760) = 0;
              *(unsigned char *)(v6 + 292) = 0;
              *(unsigned char *)(v6 + 764) = 1;
              *(unsigned char *)(v6 + 888) = 0;
              *(_DWORD *)(v6 + 304) = a2[17];
              *(unsigned char *)(v6 + 302) = 0;
              *(void *)(v6 + 376) = 0x3FF0000000000000;
              double v24 = *((double *)a2 + 6);
              if (v24 <= 0.0) {
                double v24 = 2.0;
              }
              *(double *)(v6 + 368) = v24;
              FigCFWeakReferenceStore();
              double v25 = micro();
              double v26 = *((double *)a2 + 1);
              *(double *)(v6 + 312) = v25 + v26;
              *(double *)(v6 + 352) = v26;
              pthread_mutex_init((pthread_mutex_t *)(v6 + 216), 0);
              pthread_mutex_init((pthread_mutex_t *)(v6 + 776), 0);
              pthread_cond_init((pthread_cond_t *)(v6 + 840), 0);
              pthread_cond_init((pthread_cond_t *)(v6 + 896), 0);
              pthread_mutex_init((pthread_mutex_t *)(v6 + 25552), 0);
              pthread_mutex_init((pthread_mutex_t *)(v6 + 25632), 0);
              if (!*((unsigned char *)a2 + 112)
                || (*(_DWORD *)buf = -1,
                    uint64_t v33 = _VCMediaQueue_RegisterStream(v6, 0, (signed int *)buf),
                    !(v33 | *(_DWORD *)buf)))
              {
                if (*((unsigned char *)a2 + 96)) {
                  _VCMediaQueue_CreateLogDumpFile(v6, *((void *)a2 + 11), v27, v28, v29, v30, v31, v32, v48);
                }
                long long v34 = malloc_type_malloc(0x380uLL, 0x100004097079494uLL);
                *(void *)(v6 + 160) = v34;
                int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
                if (v34)
                {
                  if (ErrorLogLevelForModule >= 7)
                  {
                    uint64_t v36 = VRTraceErrorLogLevelToCSTR();
                    long long v37 = *MEMORY[0x1E4F47A50];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136315650;
                      uint64_t v51 = v36;
                      __int16 v52 = 2080;
                      uint64_t v53 = "_VCMediaQueue_RateStats_Init";
                      __int16 v54 = 1024;
                      int v55 = 2429;
                      _os_log_impl(&dword_1E1EA4000, v37, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue IN/OUT RealTime stats are ENABLED", buf, 0x1Cu);
                    }
                  }
                  double v38 = micro();
                  uint64_t v39 = *(void *)(v6 + 160);
                  *(_OWORD *)(v39 + 8) = 0u;
                  *(_OWORD *)(v39 + 24) = 0u;
                  *(_OWORD *)(v39 + 40) = 0u;
                  *(_OWORD *)(v39 + 56) = 0u;
                  *(_OWORD *)(v39 + 72) = 0u;
                  *(_OWORD *)(v39 + 88) = 0u;
                  *(_OWORD *)(v39 + 104) = 0u;
                  *(_OWORD *)(v39 + 120) = 0u;
                  *(_WORD *)(v39 + 144) = 0;
                  *(double *)uint64_t v39 = v38;
                  *(double *)(v39 + 136) = v38;
                  *(void *)(v39 + 148) = 0x100000000;
                  *(_DWORD *)(v39 + 156) = 0;
                  pthread_mutex_init((pthread_mutex_t *)(v39 + 160), 0);
                  uint64_t v40 = *(void *)(v6 + 160);
                  *(double *)(v40 + 224) = v38;
                  v40 += 224;
                  *(_OWORD *)(v40 + 8) = 0u;
                  *(_OWORD *)(v40 + 24) = 0u;
                  *(_OWORD *)(v40 + 40) = 0u;
                  *(_OWORD *)(v40 + 56) = 0u;
                  *(_OWORD *)(v40 + 72) = 0u;
                  *(_OWORD *)(v40 + 88) = 0u;
                  *(_OWORD *)(v40 + 104) = 0u;
                  *(_OWORD *)(v40 + 120) = 0u;
                  *(_DWORD *)(v40 + 148) = 0;
                  *(_WORD *)(v40 + 144) = 0;
                  *(double *)(v40 + 136) = v38;
                  *(void *)(v40 + 152) = 0;
                  pthread_mutex_init((pthread_mutex_t *)(v40 + 160), 0);
                  uint64_t v41 = *(void *)(v6 + 160);
                  *(_OWORD *)(v41 + 456) = 0u;
                  *(_OWORD *)(v41 + 472) = 0u;
                  *(_OWORD *)(v41 + 488) = 0u;
                  *(_OWORD *)(v41 + 504) = 0u;
                  *(_OWORD *)(v41 + 520) = 0u;
                  *(_OWORD *)(v41 + 536) = 0u;
                  *(_OWORD *)(v41 + 552) = 0u;
                  *(_OWORD *)(v41 + 568) = 0u;
                  *(_DWORD *)(v41 + 596) = 0;
                  *(_WORD *)(v41 + 592) = 0;
                  *(double *)(v41 + 448) = v38;
                  *(double *)(v41 + 584) = v38;
                  *(void *)(v41 + 600) = 1;
                  pthread_mutex_init((pthread_mutex_t *)(v41 + 608), 0);
                  uint64_t v42 = *(void *)(v6 + 160);
                  *(_OWORD *)(v42 + 680) = 0u;
                  *(_OWORD *)(v42 + 696) = 0u;
                  *(_OWORD *)(v42 + 712) = 0u;
                  *(_OWORD *)(v42 + 728) = 0u;
                  *(_OWORD *)(v42 + 744) = 0u;
                  *(_OWORD *)(v42 + 760) = 0u;
                  *(_OWORD *)(v42 + 776) = 0u;
                  *(_OWORD *)(v42 + 792) = 0u;
                  *(_DWORD *)(v42 + 820) = 0;
                  *(_WORD *)(v42 + 816) = 0;
                  *(double *)(v42 + 672) = v38;
                  *(double *)(v42 + 808) = v38;
                  *(void *)(v42 + 824) = 0;
                  pthread_mutex_init((pthread_mutex_t *)(v42 + 832), 0);
                }
                else if (ErrorLogLevelForModule >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                    VCMediaQueue_Create_cold_4();
                  }
                }
                reportingRegisterPeriodicTaskWeak();
                if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                {
                  uint64_t v43 = VRTraceErrorLogLevelToCSTR();
                  OSStatus v44 = *MEMORY[0x1E4F47A50];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                  {
                    int v45 = *a2;
                    int v46 = *((unsigned __int8 *)a2 + 112);
                    unsigned int v47 = a2[18];
                    *(_DWORD *)buf = 136316418;
                    uint64_t v51 = v43;
                    __int16 v52 = 2080;
                    uint64_t v53 = "VCMediaQueue_Create";
                    __int16 v54 = 1024;
                    int v55 = 2061;
                    __int16 v56 = 1024;
                    int v57 = v45;
                    __int16 v58 = 1024;
                    int v59 = v46;
                    __int16 v60 = 1024;
                    unsigned int v61 = v47;
                    _os_log_impl(&dword_1E1EA4000, v44, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue created successfully with 1 main queue, %d internal queues isRTXEnabled=%d schedulePolicy=%d", buf, 0x2Eu);
                  }
                }
                uint64_t v2 = 0;
                *a1 = v6;
                return v2;
              }
              uint64_t v2 = v33;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  VCMediaQueue_Create_cold_5();
                }
              }
            }
            else
            {
              uint64_t v2 = 2149580801;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  VCMediaQueue_Create_cold_3();
                }
              }
            }
          }
        }
      }
      CFRelease((CFTypeRef)v6);
      return v2;
    }
  }
  __break(0x5519u);
  return result;
}

void VCMediaQueueSendProc(unint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v124 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = a1 + 25736;
  unsigned __int8 v5 = atomic_load((unsigned __int8 *)(a1 + 764));
  if (v5)
  {
    _VCMediaQueue_FlushPacketsFromQueue(a1);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
    *a3 = 1;
    *(unsigned char *)(a1 + 944) = 1;
    if (v4 <= a1) {
      goto LABEL_131;
    }
    pthread_cond_signal((pthread_cond_t *)(a1 + 896));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 776));
    return;
  }
  if (v4 <= a1) {
    goto LABEL_131;
  }
  int32_t Count = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 616));
  unsigned __int8 v7 = atomic_load((unsigned __int8 *)(a1 + 888));
  if (v7)
  {
    unint64_t v10 = *(unsigned int *)(a1 + 348);
    if (!v10)
    {
      long long v14 = (pthread_mutex_t *)(a1 + 776);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
LABEL_17:
      double v16 = *(double *)(a1 + 312);
      double v17 = v16 - micro();
      if (v17 <= 0.0)
      {
        int v15 = 60;
      }
      else
      {
        convertTimeoutToRelativeTimespec(v17);
        *(void *)uint64_t v115 = v18;
        *(void *)&v115[8] = v19;
        int v15 = pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 840), v14, (const timespec *)v115);
      }
      goto LABEL_20;
    }
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    int32_t v8 = 0;
    do
    {
      uint64_t v13 = *(void *)(a1 + 624) + v11;
      if (!*(unsigned char *)(v13 + 168))
      {
        v8 += CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(v13 + 16));
        unint64_t v10 = *(unsigned int *)(a1 + 348);
      }
      ++v12;
      v11 += 176;
    }
    while (v12 < v10);
  }
  else
  {
    int32_t v8 = Count;
  }
  long long v14 = (pthread_mutex_t *)(a1 + 776);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
  if (!v8) {
    goto LABEL_17;
  }
  int v15 = 0;
LABEL_20:
  pthread_mutex_unlock(v14);
  if (atomic_exchange((atomic_uchar *volatile)(a1 + 292), 0))
  {
    ++*(_DWORD *)(a1 + 328);
    _VCMediaQueue_FlushPacketsFromQueue(a1);
  }
  int v20 = atomic_load((unsigned int *)(a1 + 760));
  if (v20 >= 1)
  {
    uint64_t v21 = 0;
    uint64_t v22 = 176 * v20;
    while (1)
    {
      unint64_t v23 = *(void *)(a1 + 624);
      unint64_t v24 = v23 + 176 * *(unsigned int *)(a1 + 348);
      unint64_t v25 = v23 + v21;
      if (v23 > v23 + v21 || v23 + v21 + 176 > v24) {
        break;
      }
      if (atomic_exchange((atomic_uchar *volatile)(v25 + 94), 0))
      {
        if (v25) {
          BOOL v27 = v25 >= v24;
        }
        else {
          BOOL v27 = 0;
        }
        if (v27) {
          break;
        }
        _VCMediaQueue_FlushInternalQueueBeforeTimestamp(v25, a1, -1);
      }
      v21 += 176;
      if (v22 == v21) {
        goto LABEL_35;
      }
    }
LABEL_131:
    __break(0x5519u);
  }
LABEL_35:
  unsigned int v28 = atomic_load((unsigned int *)(a1 + 760));
  if (v28)
  {
    uint64_t v29 = 0;
    uint64_t v30 = 176 * v28;
    do
    {
      unint64_t v31 = *(void *)(a1 + 624);
      unint64_t v32 = v31 + 176 * *(unsigned int *)(a1 + 348);
      unint64_t v33 = v31 + v29;
      if (v31 > v31 + v29 || v31 + v29 + 176 > v32) {
        goto LABEL_131;
      }
      uint64_t v35 = atomic_exchange((atomic_ullong *volatile)(v33 + 112), 0xFFFFFFFFFFFFFFFFLL);
      if (v35 != -1)
      {
        if (v33) {
          BOOL v36 = v33 >= v32;
        }
        else {
          BOOL v36 = 0;
        }
        if (v36) {
          goto LABEL_131;
        }
        _VCMediaQueue_FlushInternalQueueBeforeTimestamp(v33, a1, v35);
      }
      v29 += 176;
    }
    while (v30 != v29);
  }
  int v106 = v15;
  unint64_t v107 = v4;
  double v37 = micro();
  if (v37 - *(double *)(a1 + 608) > *(double *)(a1 + 56))
  {
    uint64_t v38 = *(unsigned int *)(a1 + 348);
    if (v38)
    {
      uint64_t v39 = 0;
      while (1)
      {
        unint64_t v40 = *(void *)(a1 + 624);
        unint64_t v41 = v40 + 176 * *(unsigned int *)(a1 + 348);
        unint64_t v42 = v40 + 176 * v39;
        if (v40 > v42 || v42 + 176 > v41) {
          goto LABEL_131;
        }
        unint64_t v44 = v40 + 176 * v39;
        int v46 = *(opaqueCMSimpleQueue **)(v44 + 16);
        unint64_t v45 = v44 + 16;
        unsigned int v47 = CMSimpleQueueGetCount(v46);
        unsigned int v48 = v47;
        if (*(_DWORD *)(v45 + 8) && v47 >= 2) {
          break;
        }
LABEL_87:
        unint64_t v74 = v40 + 176 * v39;
        ++*(_DWORD *)(v74 + 72);
        *(_DWORD *)(v74 + 76) = v48;
        if (++v39 == v38) {
          goto LABEL_88;
        }
      }
      Head = CMSimpleQueueGetHead(*(CMSimpleQueueRef *)v45);
      unint64_t v51 = v40 + 176 * v39;
      unsigned __int8 v52 = atomic_load((unsigned __int8 *)(v51 + 96));
      unsigned int v53 = atomic_load((unsigned int *)(v51 + 120));
      unsigned int v54 = *(_DWORD *)(v51 + 88);
      if (v54)
      {
        double v55 = (double)(v53 - Head[59]) / (double)v54;
        if (!v42) {
          goto LABEL_65;
        }
      }
      else
      {
        double v55 = 0.0;
        if (!v42) {
          goto LABEL_65;
        }
      }
      if (v42 >= v41) {
        goto LABEL_131;
      }
LABEL_65:
      int v56 = *(_DWORD *)(v40 + 176 * v39 + 124);
      uint64_t v57 = 40;
      if ((v52 & 1) == 0) {
        uint64_t v57 = 32;
      }
      double v58 = *(double *)(a1 + v57);
      int v59 = v58 <= v55;
      if ((v52 & 1) != 0 && v58 > v55)
      {
        if (!*(unsigned char *)(a1 + 129)) {
          goto LABEL_83;
        }
        unsigned int v60 = (*(double *)(a1 + 48) * 1000.0);
        unsigned int v61 = 1;
        do
          v61 += v60;
        while (v61 < (v55 * 1000.0));
        unint64_t v62 = v40 + 176 * v39;
        int v64 = *(_DWORD *)(v62 + 164);
        int v63 = (unsigned int *)(v62 + 164);
        unsigned int v65 = v61 - v60;
        if (v65 == v64)
        {
LABEL_83:
          unsigned int v70 = (double *)(v40 + 176 * v39);
          double v71 = v70[8];
          double v72 = v55 + v70[7];
          void v70[6] = v55;
          v70[7] = v72;
          if (v71 <= v55) {
            double v73 = v55;
          }
          else {
            double v73 = v71;
          }
          v70[8] = v73;
          goto LABEL_87;
        }
        *int v63 = v65;
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        {
          int v59 = 2;
        }
        else
        {
          uint64_t v66 = VRTraceErrorLogLevelToCSTR();
          unsigned int v67 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v68 = *v63;
            *(_DWORD *)uint64_t v115 = 136316418;
            *(void *)&v115[4] = v66;
            *(_WORD *)&v115[12] = 2080;
            *(void *)&v115[14] = "_VCMediaQueue_CheckQueueThresholdExceededForInternalQueue";
            __int16 v116 = 1024;
            int v117 = 1789;
            __int16 v118 = 1024;
            *(_DWORD *)int v119 = v56;
            *(_WORD *)&v119[4] = 1024;
            *(_DWORD *)&v119[6] = v68;
            *(_WORD *)char v120 = 2048;
            *(double *)&v120[2] = v55;
            _os_log_impl(&dword_1E1EA4000, v67, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue size changes step with mediaQueueStreamId=%u quantizedQueueSize=%dms queueSizeInSecond=%f", v115, 0x32u);
          }
          int v59 = 2;
        }
      }
      if (*(void *)(a1 + 152) && (v59 - 1) <= 1)
      {
        unsigned int v69 = (const void *)MEMORY[0x1E4E56580](a1 + 144);
        (*(void (**)(double))(*(void *)(a1 + 152) + 16))(v55);
        if (v69) {
          CFRelease(v69);
        }
        *(double *)(a1 + 608) = v37;
        _VCMediaQueue_ReportingEvent((_DWORD *)a1, 193, v56);
      }
      goto LABEL_83;
    }
  }
LABEL_88:
  unsigned __int8 v75 = atomic_load((unsigned __int8 *)(a1 + 280));
  if ((v75 & 1) != 0 || v106 == 60)
  {
    *(unsigned char *)(a1 + 309) = v106 == 60;
    _VCMediaQueue_SchedulePackets(a1);
  }
  uint64_t v111 = 0;
  int v112 = &v111;
  uint64_t v113 = 0x2000000000;
  uint64_t v114 = 0;
  v110[0] = 0;
  v110[1] = v110;
  v110[2] = 0x2000000000;
  v110[3] = &v114;
  uint64_t v76 = *(void *)(a1 + 136);
  v109[0] = MEMORY[0x1E4F143A8];
  v109[1] = 0x40000000;
  v109[2] = __VCMediaQueueSendProc_block_invoke;
  v109[3] = &unk_1E6DB8DE8;
  v109[6] = a1;
  v109[7] = v107;
  v109[8] = a1;
  v109[4] = &v111;
  v109[5] = v110;
  VCMediaQueuePacketBundler_BundlePackets(v76, (uint64_t)v109);
  if (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 616)) >= 1)
  {
    double v77 = *(double *)(a1 + 72);
    if (v77 == 0.0)
    {
      _VCMediaQueue_DrainAllPacketsFromMainQueue(a1);
    }
    else
    {
      unsigned int v78 = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 616));
      uint64_t v79 = fmin((*(double *)(a1 + 360) + 1.0) / v77, 4.0);
      unsigned int v108 = v78;
      if (v78 / v79 + 1 > *(_DWORD *)(a1 + 80)) {
        unsigned int v80 = v78 / v79 + 1;
      }
      else {
        unsigned int v80 = *(_DWORD *)(a1 + 80);
      }
      if (v80) {
        BOOL v81 = v79 == 0;
      }
      else {
        BOOL v81 = 1;
      }
      if (v81)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          uint64_t v98 = VRTraceErrorLogLevelToCSTR();
          uint64_t v99 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
          {
            uint64_t v100 = *(void *)(a1 + 72);
            uint64_t v101 = *(void *)(a1 + 360);
            *(_DWORD *)uint64_t v115 = 136316162;
            *(void *)&v115[4] = v98;
            *(_WORD *)&v115[12] = 2080;
            *(void *)&v115[14] = "_VCMediaQueue_PacePacketSendFromMainQueue";
            __int16 v116 = 1024;
            int v117 = 469;
            __int16 v118 = 2048;
            *(void *)int v119 = v100;
            *(_WORD *)&v119[8] = 2048;
            *(void *)char v120 = v101;
            _os_log_error_impl(&dword_1E1EA4000, v99, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d packetSendPacingInterval=%f is set too big compared to the expectedScheduleInterval=%f", v115, 0x30u);
          }
        }
      }
      else
      {
        uint64_t v82 = 0;
        int v83 = 0;
        unint64_t v84 = a1 + 396;
        unint64_t v85 = a1 + 412;
        *(void *)(a1 + 404) = 0;
        *(void *)(a1 + 396) = 0;
        while (1)
        {
          unsigned int v86 = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 616));
          unsigned int v87 = v80;
          if (v86 < v80) {
            break;
          }
          do
          {
            CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 616));
            _VCMediaQueue_SendAndFreePackets(a1);
            ++*(_DWORD *)(a1 + 436);
            --v87;
          }
          while (v87);
          int v88 = (unsigned int *)(v84 + 4 * v82);
          if ((unint64_t)v88 >= v85 || (unint64_t)v88 < v84) {
            goto LABEL_131;
          }
          unsigned int *v88 = v80;
          pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
          if (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 616)) >= 1)
          {
            memset(v115, 170, 16);
            convertTimeoutToRelativeTimespec(v77);
            *(void *)uint64_t v115 = v89;
            *(void *)&v115[8] = v90;
            pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 840), (pthread_mutex_t *)(a1 + 776), (const timespec *)v115);
          }
          v83 += v80;
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 776));
          if (++v82 == v79) {
            goto LABEL_114;
          }
        }
        if (v86)
        {
          int v91 = _VCMediaQueue_DrainAllPacketsFromMainQueue(a1);
          uint64_t v92 = (_DWORD *)(v84 + 4 * v82);
          if ((unint64_t)v92 >= v85 || (unint64_t)v92 < v84) {
            goto LABEL_131;
          }
          v83 += v91;
          _DWORD *v92 = v91;
        }
LABEL_114:
        if (v108 != v83 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          uint64_t v102 = VRTraceErrorLogLevelToCSTR();
          double v103 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v104 = *(void *)(a1 + 360);
            uint64_t v105 = *(void *)(a1 + 72);
            *(_DWORD *)uint64_t v115 = 136316674;
            *(void *)&v115[4] = v102;
            *(_WORD *)&v115[12] = 2080;
            *(void *)&v115[14] = "_VCMediaQueue_PacePacketSendFromMainQueue";
            __int16 v116 = 1024;
            int v117 = 499;
            __int16 v118 = 2048;
            *(void *)int v119 = v104;
            *(_WORD *)&v119[8] = 2048;
            *(void *)char v120 = v105;
            *(_WORD *)&v120[8] = 1024;
            unsigned int v121 = v108;
            __int16 v122 = 1024;
            int v123 = v83;
            _os_log_impl(&dword_1E1EA4000, v103, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Not able to finish sending all packets in expectedScheduleInterval=%f, packetSendPacingInterval=%f, totalPacketCount=%u, packetSent=%u", v115, 0x3Cu);
          }
        }
      }
    }
  }
  _VCMediaQueue_FreeMediaPacketList(a1, v112[3]);
  unsigned __int8 v95 = atomic_load((unsigned __int8 *)(a1 + 888));
  if ((v95 & 1) == 0 || *(unsigned char *)(a1 + 308))
  {
    LODWORD(v93) = *(_DWORD *)(a1 + 344);
    LODWORD(v94) = *(_DWORD *)(a1 + 332);
    if ((double)v94 * 0.1 >= (double)v93)
    {
      *(void *)(a1 + 960) = 0;
    }
    else
    {
      double v96 = *(double *)(a1 + 960);
      double v97 = micro();
      if (v96 == 0.0)
      {
        *(double *)(a1 + 960) = v97;
      }
      else if (v97 - *(double *)(a1 + 960) >= 0.5)
      {
        reportingSymptom();
      }
    }
    _VCMediaQueue_DumpStatisticsToFile(a1);
  }
  _Block_object_dispose(v110, 8);
  _Block_object_dispose(&v111, 8);
}

uint64_t VCMediaQueue_Start(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 2149580801;
  }
  uint64_t result = 0;
  int v3 = 1;
  atomic_compare_exchange_strong((atomic_uchar *volatile)(a1 + 764), (unsigned __int8 *)&v3, 0);
  if (v3 == 1)
  {
    _VCMediaQueue_ReportingEvent((_DWORD *)a1, 321, -1);
    *(_OWORD *)(a1 + 412) = 0u;
    *(_OWORD *)(a1 + 428) = 0u;
    *(_OWORD *)(a1 + 444) = 0u;
    *(_OWORD *)(a1 + 460) = 0u;
    VCRealTimeThread_Start(*(void *)(a1 + 768));
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
    *(unsigned char *)(a1 + 944) = 0;
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 776));
    int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    uint64_t result = 0;
    if (ErrorLogLevelForModule >= 7)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      unint64_t v6 = *MEMORY[0x1E4F47A50];
      BOOL v7 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (v7)
      {
        int v8 = 136315650;
        uint64_t v9 = v5;
        __int16 v10 = 2080;
        uint64_t v11 = "VCMediaQueue_Start";
        __int16 v12 = 1024;
        int v13 = 2089;
        _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueueSendProc thread started", (uint8_t *)&v8, 0x1Cu);
        return 0;
      }
    }
  }
  return result;
}

uint64_t VCMediaQueue_Stop(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 2149580801;
  }
  char v2 = 0;
  uint64_t result = 0;
  atomic_compare_exchange_strong((atomic_uchar *volatile)(a1 + 764), (unsigned __int8 *)&v2, 1u);
  if (!v2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
    pthread_cond_signal((pthread_cond_t *)(a1 + 840));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 776));
    VCMediaQueue_SetAudioStallBasebandFlushState(a1, 0, *(void *)(a1 + 25728));
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
    if (*(unsigned char *)(a1 + 944))
    {
LABEL_6:
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 776));
    }
    else
    {
      while (1)
      {
        memset(v11, 170, 16);
        convertTimeoutToRelativeTimespec(5.0);
        *(void *)uint64_t v11 = v4;
        *(void *)&char v11[8] = v5;
        if (pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 896), (pthread_mutex_t *)(a1 + 776), (const timespec *)v11) == 60)break; {
        if (*(unsigned char *)(a1 + 944))
        }
          goto LABEL_6;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 776));
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v9 = VRTraceErrorLogLevelToCSTR();
        __int16 v10 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t v11 = 136315650;
          *(void *)&v11[4] = v9;
          *(_WORD *)&v11[12] = 2080;
          *(void *)&v11[14] = "VCMediaQueue_Stop";
          __int16 v12 = 1024;
          int v13 = 2114;
          _os_log_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Sendproc thread might not have cleaned residual packets in internal Queues", v11, 0x1Cu);
        }
      }
    }
    VCRealTimeThread_Stop(*(void *)(a1 + 768));
    if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
      return 0;
    }
    uint64_t v6 = VRTraceErrorLogLevelToCSTR();
    BOOL v7 = *MEMORY[0x1E4F47A50];
    BOOL v8 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v8)
    {
      *(_DWORD *)uint64_t v11 = 136315650;
      *(void *)&v11[4] = v6;
      *(_WORD *)&v11[12] = 2080;
      *(void *)&v11[14] = "VCMediaQueue_Stop";
      __int16 v12 = 1024;
      int v13 = 2118;
      _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueueSendProc thread ended", v11, 0x1Cu);
      return 0;
    }
  }
  return result;
}

uint64_t VCMediaQueue_SetAudioStallBasebandFlushState(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    unsigned __int8 v4 = atomic_load((unsigned __int8 *)(a1 + 300));
    if (v4)
    {
      BOOL v8 = (unsigned char *)(a1 + 25696);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 25632));
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v9 = VRTraceErrorLogLevelToCSTR();
        __int16 v10 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v11 = *v8;
          int v13 = 136316418;
          uint64_t v14 = v9;
          __int16 v15 = 2080;
          double v16 = "VCMediaQueue_SetAudioStallBasebandFlushState";
          __int16 v17 = 1024;
          int v18 = 2689;
          __int16 v19 = 1024;
          int v20 = v11;
          __int16 v21 = 1024;
          int v22 = a2;
          __int16 v23 = 2048;
          uint64_t v24 = a3;
          _os_log_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue set audioStallFlushState old=%d to new=%d on rtpHandle=%p", (uint8_t *)&v13, 0x32u);
        }
      }
      *(void *)(a1 + 25728) = a3;
      if (*v8 != a2)
      {
        if (a2)
        {
          *(void *)(a1 + 25712) = 0;
          *(unsigned char *)(a1 + 25697) = 1;
        }
        *BOOL v8 = a2;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 25632));
      return 0;
    }
    else
    {
      uint64_t v5 = 2149580801;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCMediaQueue_SetAudioStallBasebandFlushState_cold_2();
        }
      }
    }
  }
  else
  {
    uint64_t v5 = 2149580801;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaQueue_SetAudioStallBasebandFlushState_cold_1();
      }
    }
  }
  return v5;
}

uint64_t VCMediaQueue_AllocMediaPacket(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = 2149580801;
  if (!a1) {
    return v4;
  }
  unsigned int v22 = -1;
  if (_VCMediaQueue_GetInternalQueueIndexFromStreamId(a1, a2, a3 == 2, (int *)&v22))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaQueue_AllocMediaPacket_cold_4();
      }
    }
    return v4;
  }
  unsigned int v8 = v22;
  if (v22 == -1)
  {
    uint64_t v9 = _VCMediaQueue_RegisterStream(a1, a2, (signed int *)&v22);
    unsigned int v8 = v22;
    if (v9) {
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  if ((v8 & 0x80000000) != 0)
  {
LABEL_31:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaQueue_AllocMediaPacket_cold_1();
      }
    }
    return v9;
  }
  unint64_t v10 = *(void *)(a1 + 624);
  int v11 = (CMSimpleQueueRef *)(v10 + 176 * v8);
  if ((unint64_t)v11 >= v10 + 176 * *(unsigned int *)(a1 + 348) || (unint64_t)v11 < v10) {
LABEL_35:
  }
    __break(0x5519u);
  int v13 = CMSimpleQueueDequeue(*v11);
  *(void *)a4 = v13;
  if (v13)
  {
    *(void *)(a1 + 952) = 0;
    uint64_t v14 = v13[1];
    *((_OWORD *)v13 + 2) = 0u;
    *((_OWORD *)v13 + 3) = 0u;
    *((_OWORD *)v13 + 4) = 0u;
    *((_OWORD *)v13 + 5) = 0u;
    *((_OWORD *)v13 + 6) = 0u;
    *((_OWORD *)v13 + 7) = 0u;
    *((_OWORD *)v13 + 8) = 0u;
    *((_OWORD *)v13 + 9) = 0u;
    *((_OWORD *)v13 + 10) = 0u;
    *((_OWORD *)v13 + 11) = 0u;
    *((_OWORD *)v13 + 12) = 0u;
    *((_OWORD *)v13 + 13) = 0u;
    *((_OWORD *)v13 + 14) = 0u;
    *((_OWORD *)v13 + 15) = 0u;
    *((_OWORD *)v13 + 16) = 0u;
    *((_OWORD *)v13 + 17) = 0u;
    *((_OWORD *)v13 + 18) = 0u;
    v13[38] = 0;
    *(_OWORD *)int v13 = 0u;
    *((_OWORD *)v13 + 1) = 0u;
    *(void *)(*(void *)a4 + 8) = v14;
    unint64_t v15 = *(void *)(a1 + 624);
    unint64_t v16 = v15 + 176 * *(unsigned int *)(a1 + 348);
    __int16 v17 = *(const void **)a4;
    *(_DWORD *)(*(void *)a4 + 228) = a2;
    unint64_t v18 = v15 + 176 * (int)v22;
    if (v18 >= v16 || v18 < v15) {
      goto LABEL_35;
    }
    uint64_t v4 = CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(v15 + 176 * (int)v22 + 8), v17);
    if (v4)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCMediaQueue_AllocMediaPacket_cold_3();
        }
      }
      return 0;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaQueue_AllocMediaPacket_cold_2();
      }
    }
    double v19 = *(double *)(a1 + 952);
    double v20 = micro();
    if (v19 == 0.0)
    {
      *(double *)(a1 + 952) = v20;
      return 2149580803;
    }
    else
    {
      uint64_t v4 = 2149580803;
      if (v20 - *(double *)(a1 + 952) >= 5.0) {
        reportingSymptom();
      }
    }
  }
  return v4;
}

uint64_t VCMediaQueue_AddPacket(uint64_t a1, uint64_t a2)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = 2149580822;
  if (!a1) {
    return 2149580801;
  }
  if (a2)
  {
    uint64_t v5 = 512;
    if (!*(unsigned char *)(a2 + 227)) {
      uint64_t v5 = 504;
    }
    atomic_fetch_add((atomic_ullong *volatile)(a1 + v5), 1uLL);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 520), 1uLL);
  }
  unsigned __int8 v6 = atomic_load((unsigned __int8 *)(a1 + 300));
  int v59 = *(_DWORD *)(a2 + 176);
  int v7 = *(_DWORD *)(a2 + 228);
  int v8 = *(_DWORD *)(a2 + 240);
  unsigned int v61 = -1;
  int v58 = v7;
  if (!_VCMediaQueue_GetInternalQueueIndexFromStreamId(a1, v7, *(unsigned __int8 *)(a2 + 295), (int *)&v61))
  {
    unsigned int v9 = v61;
    if ((v61 & 0x80000000) == 0)
    {
      unsigned __int8 v60 = v6;
      unint64_t v10 = *(void *)(a1 + 624);
      unint64_t v11 = v10 + 176 * *(unsigned int *)(a1 + 348);
      unint64_t v12 = v10 + 176 * v61;
      if (v10 <= v12 && v12 + 176 <= v11)
      {
        unint64_t v14 = v10 + 176 * v61;
        int v16 = *(_DWORD *)(v14 + 24);
        unint64_t v15 = (int *)(v14 + 24);
        if (!v16)
        {
          switch(v59)
          {
            case 0:
            case 3:
              int v17 = 2;
              goto LABEL_17;
            case 1:
              int v17 = 3;
LABEL_17:
              *unint64_t v15 = v17;
              break;
            case 2:
              *unint64_t v15 = 1;
              goto LABEL_19;
            default:
LABEL_19:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  VCMediaQueue_AddPacket_cold_2();
                }
              }
              break;
          }
        }
        if (!*(_DWORD *)(a2 + 268)) {
          *(_DWORD *)(a2 + 268) = 1;
        }
        unint64_t v18 = v10 + 176 * v9;
        int v20 = *(_DWORD *)(v18 + 88);
        double v19 = (_DWORD *)(v18 + 88);
        if (v20) {
          BOOL v21 = 1;
        }
        else {
          BOOL v21 = v8 == 0;
        }
        if (!v21)
        {
          _DWORD *v19 = v8;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            uint64_t v22 = VRTraceErrorLogLevelToCSTR();
            uint64_t v23 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136316418;
              uint64_t v64 = v22;
              __int16 v65 = 2080;
              uint64_t v66 = "VCMediaQueue_AddPacket";
              __int16 v67 = 1024;
              int v68 = 2218;
              __int16 v69 = 1024;
              *(_DWORD *)unsigned int v70 = v8;
              *(_WORD *)&v70[4] = 1024;
              *(_DWORD *)&void v70[6] = v59;
              *(_WORD *)double v71 = 1024;
              *(_DWORD *)&v71[2] = v58;
              _os_log_impl(&dword_1E1EA4000, v23, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Set internalQueue timestampRateHz=%u for packetType=%d, mediaQueueStreamId=%u", buf, 0x2Eu);
            }
          }
        }
        if (*(unsigned char *)(a2 + 289) && *(unsigned char *)(a2 + 292)) {
          atomic_fetch_or((atomic_uchar *volatile)(v10 + 176 * v9 + 92), 1u);
        }
        if (*(unsigned char *)(a2 + 226)) {
          atomic_fetch_or((atomic_uchar *volatile)(v10 + 176 * v9 + 96), 1u);
        }
        if (*(unsigned char *)(a2 + 227))
        {
          atomic_fetch_or((atomic_uchar *volatile)(v10 + 176 * v9 + 97), 1u);
          double v24 = *(double *)(a2 + 272);
          unsigned __int8 v25 = atomic_load((unsigned __int8 *)(a1 + 300));
          if (v25)
          {
            pthread_mutex_lock((pthread_mutex_t *)(a1 + 25632));
            if (*(unsigned char *)(a1 + 25696))
            {
              if (*(unsigned char *)(a1 + 25697))
              {
                *(unsigned char *)(a1 + 25697) = 0;
                *(double *)(a1 + 25704) = v24;
                *(_DWORD *)(a1 + 25716) = *(_DWORD *)(a2 + 236);
                double v26 = v24;
              }
              else
              {
                double v26 = *(double *)(a1 + 25704);
              }
              int v27 = *(unsigned char *)(a2 + 293) ? 48 : 28;
              *(_DWORD *)(a1 + 25712) += *(unsigned __int16 *)(a2 + 4) + v27;
              double v28 = v24 - v26;
              if (v24 - v26 > 1.0)
              {
                if (*(unsigned char *)(a1 + 25698))
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
                  {
                    uint64_t v56 = VRTraceErrorLogLevelToCSTR();
                    uint64_t v29 = *MEMORY[0x1E4F47A50];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v30 = *(void *)(a1 + 25704);
                      *(_DWORD *)buf = 136316162;
                      uint64_t v64 = v56;
                      __int16 v65 = 2080;
                      uint64_t v66 = "_VCMediaQueue_ProcessAudioPacketsForBasebandQueuing";
                      __int16 v67 = 1024;
                      int v68 = 2656;
                      __int16 v69 = 2048;
                      *(double *)unsigned int v70 = v24;
                      *(_WORD *)&v70[8] = 2048;
                      *(void *)double v71 = v30;
                      _os_log_impl(&dword_1E1EA4000, v29, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d UNEXPECTED pending flush not acked yet at time=%f lastFlushTime=%f!", buf, 0x30u);
                    }
                  }
                }
                int v31 = *(_DWORD *)(a1 + 25716);
                int v32 = ((double)(8 * *(_DWORD *)(a1 + 25712)) / v28);
                *(_DWORD *)(a1 + 25712) = 0;
                unsigned __int16 v62 = 0;
                if (RTPFlushBaseband_SpecialMQAudioTS(*(void *)(a1 + 25728), v31 + 1, v32, &v62))
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                      VCMediaQueue_AddPacket_cold_1();
                    }
                  }
                }
                else
                {
                  *(_DWORD *)(a1 + 25720) = v62;
                  *(double *)(a1 + 25704) = v24;
                  *(unsigned char *)(a1 + 25698) = 1;
                  *(_DWORD *)(a1 + 25716) = *(_DWORD *)(a2 + 236);
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
                  {
                    uint64_t v57 = VRTraceErrorLogLevelToCSTR();
                    unint64_t v33 = *MEMORY[0x1E4F47A50];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                    {
                      int v34 = *(_DWORD *)(a2 + 236);
                      int v35 = *(unsigned __int16 *)(a2 + 248);
                      *(_DWORD *)buf = 136316930;
                      uint64_t v64 = v57;
                      __int16 v65 = 2080;
                      uint64_t v66 = "_VCMediaQueue_ProcessAudioPacketsForBasebandQueuing";
                      __int16 v67 = 1024;
                      int v68 = 2671;
                      __int16 v69 = 2048;
                      *(double *)unsigned int v70 = v24;
                      *(_WORD *)&v70[8] = 1024;
                      *(_DWORD *)double v71 = v34;
                      *(_WORD *)&v71[4] = 1024;
                      *(_DWORD *)&v71[6] = v35;
                      __int16 v72 = 1024;
                      int v73 = v32;
                      __int16 v74 = 1024;
                      int v75 = v62;
                      _os_log_impl(&dword_1E1EA4000, v33, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Issued audio flush at time=%f with packet timestamp=%u sequenceNumber=%u with rate=%u transactionID=%u!", buf, 0x3Eu);
                    }
                  }
                }
              }
            }
            pthread_mutex_unlock((pthread_mutex_t *)(a1 + 25632));
          }
        }
        if (!*(unsigned char *)(a2 + 289) || !*(unsigned char *)(a2 + 291)) {
          goto LABEL_65;
        }
        atomic_store(*(unsigned int *)(a2 + 236), (unint64_t *)(v10 + 176 * v9 + 104));
        if (!v12 || v12 < v11)
        {
          unint64_t v36 = v10 + 176 * v9;
          double v38 = *(double *)(v36 + 40);
          double v37 = (void *)(v36 + 40);
          double v39 = v38;
          if (v38 > 0.0) {
            atomic_store(*(double *)(a2 + 272) - v39 < 1.1, (unsigned __int8 *)(v10 + 176 * v9 + 93));
          }
          *double v37 = *(void *)(a2 + 272);
LABEL_65:
          if (v60) {
            _VCMediaQueue_RateStats_TrackMediaPacket(*(void *)(a1 + 160), a2, 1, *(double *)(a2 + 272));
          }
          unsigned __int8 v40 = atomic_load((unsigned __int8 *)(a1 + 301));
          unsigned __int8 v41 = atomic_load((unsigned __int8 *)(a1 + 300));
          unsigned int v42 = atomic_load((unsigned int *)(a1 + 304));
          if (*(_DWORD *)(a1 + 88) == 2
            && (v41 & 1) != 0
            && (v40 & 1) == 0
            && (unsigned int v43 = atomic_load((unsigned int *)(a1 + 284)), v43 > v42))
          {
            BOOL v44 = 0;
            atomic_store(1u, (unsigned __int8 *)(a1 + 888));
            *(unsigned char *)(a2 + 224) = 1;
          }
          else
          {
            atomic_store(0, (unsigned __int8 *)(a1 + 888));
            BOOL v44 = *(unsigned char *)(a2 + 224) == 0;
          }
          if (*(unsigned char *)(a1 + 96))
          {
            if (*(unsigned char *)(a2 + 294))
            {
              unint64_t v45 = *(const void **)(a2 + 8);
              if (v45) {
                CFRetain(v45);
              }
            }
          }
          unsigned int v46 = *(_DWORD *)(a2 + 236);
          OSStatus v47 = CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(v10 + 176 * v9 + 16), (const void *)a2);
          if (v47)
          {
            OSStatus v48 = v47;
            uint64_t v49 = *(void *)(a2 + 184);
            if (v49)
            {
              VCMediaControlInfoDispose(v49);
              *(void *)(a2 + 184) = 0;
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              uint64_t v50 = VRTraceErrorLogLevelToCSTR();
              unint64_t v51 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136316418;
                uint64_t v64 = v50;
                __int16 v65 = 2080;
                uint64_t v66 = "VCMediaQueue_AddPacket";
                __int16 v67 = 1024;
                int v68 = 2257;
                __int16 v69 = 1024;
                *(_DWORD *)unsigned int v70 = v48;
                *(_WORD *)&v70[4] = 1024;
                *(_DWORD *)&void v70[6] = v59;
                *(_WORD *)double v71 = 1024;
                *(_DWORD *)&v71[2] = v58;
                _os_log_error_impl(&dword_1E1EA4000, v51, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d Internal queue has error %d when adding media packet for packet type=%d, mediaQueueStreamId=%u", buf, 0x2Eu);
              }
            }
            if (*(unsigned char *)(a2 + 294))
            {
              unsigned __int8 v52 = *(const void **)(a2 + 8);
              if (v52)
              {
                CFRelease(v52);
                *(void *)(a2 + 8) = 0;
              }
              *(unsigned char *)(a2 + 294) = 0;
            }
            return 2149580830;
          }
          else
          {
            atomic_fetch_add((atomic_ullong *volatile)(a1 + 528), 1uLL);
            atomic_store(v46, (unsigned int *)(v10 + 176 * v9 + 120));
            if (!v44) {
              VCMediaQueue_SchedulePackets(a1);
            }
            return 0;
          }
        }
      }
      __break(0x5519u);
      JUMPOUT(0x1E230E80CLL);
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v54 = VRTraceErrorLogLevelToCSTR();
    double v55 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316162;
      uint64_t v64 = v54;
      __int16 v65 = 2080;
      uint64_t v66 = "VCMediaQueue_AddPacket";
      __int16 v67 = 1024;
      int v68 = 2195;
      __int16 v69 = 1024;
      *(_DWORD *)unsigned int v70 = v59;
      *(_WORD *)&v70[4] = 1024;
      *(_DWORD *)&void v70[6] = v58;
      _os_log_error_impl(&dword_1E1EA4000, v55, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d Cannot get internal queue index for packet type=%d, mediaQueueStreamId=%u", buf, 0x28u);
    }
  }
  return v2;
}

uint64_t VCMediaQueue_SchedulePackets(uint64_t a1)
{
  if (!a1) {
    return 2149580801;
  }
  atomic_fetch_or((atomic_uchar *volatile)(a1 + 280), 1u);
  uint64_t v2 = (pthread_mutex_t *)(a1 + 776);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
  pthread_cond_signal((pthread_cond_t *)(a1 + 840));
  pthread_mutex_unlock(v2);
  return 0;
}

uint64_t VCMediaQueue_FlushAllPackets(uint64_t a1)
{
  if (!a1) {
    return 2149580801;
  }
  atomic_fetch_or((atomic_uchar *volatile)(a1 + 292), 1u);
  uint64_t v2 = (pthread_mutex_t *)(a1 + 776);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
  pthread_cond_signal((pthread_cond_t *)(a1 + 840));
  pthread_mutex_unlock(v2);
  return 0;
}

uint64_t VCMediaQueue_FlushPacketsInStream(uint64_t result, int a2, unsigned __int8 a3)
{
  uint64_t v3 = 2149580822;
  if (!result) {
    return 2149580801;
  }
  uint64_t v4 = result;
  uint64_t v5 = *(unsigned __int8 *)(result + 128);
  uint64_t v6 = atomic_load((unsigned int *)(result + 760));
  if ((int)v6 <= (int)v5)
  {
LABEL_8:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaQueue_FlushPacketsInStream_cold_1();
      }
    }
    return v3;
  }
  uint64_t v7 = -v5;
  uint64_t v8 = -v6;
  unsigned int v9 = (_DWORD *)(result + 632 + 4 * v5);
  while ((unint64_t)v9 < result + 760 && (unint64_t)v9 >= result + 632)
  {
    if (*v9 == a2)
    {
      uint64_t v10 = -v7;
      if ((v10 & 0x80000000) != 0) {
        goto LABEL_8;
      }
      unint64_t v11 = *(void *)(result + 624);
      unint64_t v12 = v11 + 176 * v10;
      if (v11 <= v12 && v12 + 176 <= v11 + 176 * *(unsigned int *)(result + 348))
      {
        unint64_t v14 = v11 + 176 * v10;
        atomic_fetch_or((atomic_uchar *volatile)(v14 + 95), a3);
        atomic_fetch_or((atomic_uchar *volatile)(v14 + 94), 1u);
        pthread_mutex_lock((pthread_mutex_t *)(result + 776));
        pthread_cond_signal((pthread_cond_t *)(v4 + 840));
        pthread_mutex_unlock((pthread_mutex_t *)(v4 + 776));
        return 0;
      }
      break;
    }
    --v7;
    ++v9;
    if (v8 == v7) {
      goto LABEL_8;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t VCMediaQueue_GetTimeRateChanged(uint64_t a1, void *a2, _DWORD *a3)
{
  if (!a1) {
    return 2149580801;
  }
  uint64_t v6 = (pthread_mutex_t *)(a1 + 216);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 216));
  if (a2) {
    *a2 = *(void *)(a1 + 200);
  }
  if (a3) {
    *a3 = *(_DWORD *)(a1 + 180);
  }
  pthread_mutex_unlock(v6);
  return 0;
}

uint64_t VCMediaQueue_GetTimeRefreshFrame(uint64_t a1, void *a2, _DWORD *a3)
{
  if (!a1) {
    return 2149580801;
  }
  uint64_t v6 = (pthread_mutex_t *)(a1 + 216);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 216));
  if (a2) {
    *a2 = *(void *)(a1 + 208);
  }
  if (a3) {
    *a3 = *(_DWORD *)(a1 + 184);
  }
  pthread_mutex_unlock(v6);
  return 0;
}

uint64_t VCMediaQueue_UpdateAudioOnlyRateChange(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    return 2149580801;
  }
  uint64_t v4 = (pthread_mutex_t *)(a1 + 216);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 216));
  if (*(_DWORD *)(a1 + 188) < a2)
  {
    *(unsigned char *)(a1 + 176) = 1;
    *(_DWORD *)(a1 + 188) = a2;
  }
  pthread_mutex_unlock(v4);
  return 0;
}

uint64_t VCMediaQueue_SetPeakBitrate(_DWORD *a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 2149580801;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    uint64_t v5 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315906;
      uint64_t v8 = v4;
      __int16 v9 = 2080;
      uint64_t v10 = "VCMediaQueue_SetPeakBitrate";
      __int16 v11 = 1024;
      int v12 = 2388;
      __int16 v13 = 1024;
      unsigned int v14 = a2;
      _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue set with peak bitrate = %u", (uint8_t *)&v7, 0x22u);
    }
  }
  atomic_store(a2, a1 + 71);
  _VCMediaQueue_ReportingEvent(a1, 191, -1);
  return 0;
}

uint64_t VCMediaQueue_SetMTUBytes(uint64_t a1, unsigned int a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 2149580801;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    uint64_t v5 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 136315906;
      uint64_t v10 = v4;
      __int16 v11 = 2080;
      int v12 = "VCMediaQueue_SetMTUBytes";
      __int16 v13 = 1024;
      int v14 = 2398;
      __int16 v15 = 1024;
      unsigned int v16 = a2;
      _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue set with MTU bytes = %u", (uint8_t *)&v9, 0x22u);
    }
  }
  atomic_store(a2, (unsigned int *)(a1 + 288));
  uint64_t v6 = *(unsigned int **)(a1 + 136);
  unsigned __int16 v7 = atomic_load((unsigned int *)(a1 + 288));
  VCMediaQueuePacketBundler_SetMTU(v6, v7);
  _VCMediaQueue_ReportingEvent((_DWORD *)a1, 192, -1);
  return 0;
}

uint64_t VCMediaQueue_RetrieveAudioVideoRates(uint64_t a1, double *a2, double *a3, double *a4, double *a5)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (a1 && *(void *)(a1 + 160))
  {
    double v10 = micro();
    uint64_t v11 = *(void *)(a1 + 160);
    int v12 = (pthread_mutex_t *)(v11 + 160);
    pthread_mutex_lock((pthread_mutex_t *)(v11 + 160));
    double v13 = *(double *)(v11 + 136);
    int v14 = *(_DWORD *)(v11 + 148);
    pthread_mutex_unlock(v12);
    double v15 = v10 - v13;
    double v16 = 0.0;
    double v17 = 0.0;
    if (v15 <= 0.5) {
      double v17 = (double)(8 * v14) / (v15 + 0.484375);
    }
    *a2 = v17;
    uint64_t v18 = *(void *)(a1 + 160);
    double v19 = (pthread_mutex_t *)(v18 + 384);
    pthread_mutex_lock((pthread_mutex_t *)(v18 + 384));
    double v20 = *(double *)(v18 + 360);
    int v21 = *(_DWORD *)(v18 + 372);
    pthread_mutex_unlock(v19);
    if (v10 - v20 <= 0.5) {
      double v16 = (double)(8 * v21) / (v10 - v20 + 0.484375);
    }
    *a3 = v16;
    uint64_t v22 = *(void *)(a1 + 160);
    uint64_t v23 = (pthread_mutex_t *)(v22 + 608);
    pthread_mutex_lock((pthread_mutex_t *)(v22 + 608));
    double v24 = *(double *)(v22 + 584);
    int v25 = *(_DWORD *)(v22 + 596);
    pthread_mutex_unlock(v23);
    double v26 = v10 - v24;
    double v27 = 0.0;
    double v28 = 0.0;
    if (v26 <= 0.5) {
      double v28 = (double)(8 * v25) / (v26 + 0.484375);
    }
    *a4 = v28;
    uint64_t v29 = *(void *)(a1 + 160);
    uint64_t v30 = (pthread_mutex_t *)(v29 + 832);
    pthread_mutex_lock((pthread_mutex_t *)(v29 + 832));
    double v31 = *(double *)(v29 + 808);
    int v32 = *(_DWORD *)(v29 + 820);
    pthread_mutex_unlock(v30);
    if (v10 - v31 <= 0.5) {
      double v27 = (double)(8 * v32) / (v10 - v31 + 0.484375);
    }
    uint64_t v33 = 0;
    *a5 = v27;
  }
  else
  {
    uint64_t v33 = 2149580801;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v34 = VRTraceErrorLogLevelToCSTR();
      int v35 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        if (a1) {
          uint64_t v37 = *(void *)(a1 + 160);
        }
        else {
          uint64_t v37 = 0;
        }
        int v38 = 136316162;
        uint64_t v39 = v34;
        __int16 v40 = 2080;
        unsigned __int8 v41 = "VCMediaQueue_RetrieveAudioVideoRates";
        __int16 v42 = 1024;
        int v43 = 2461;
        __int16 v44 = 2048;
        uint64_t v45 = a1;
        __int16 v46 = 2048;
        uint64_t v47 = v37;
        _os_log_error_impl(&dword_1E1EA4000, v35, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d mediaQueue or its rateStats cannot be NULL mediaQueue=%p mediaQueue->rateStats=%p", (uint8_t *)&v38, 0x30u);
      }
    }
  }
  return v33;
}

uint64_t VCMediaQueue_SetHighlyBurstyTrafficMode(uint64_t a1, int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 2149580801;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    uint64_t v5 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315906;
      uint64_t v8 = v4;
      __int16 v9 = 2080;
      double v10 = "VCMediaQueue_SetHighlyBurstyTrafficMode";
      __int16 v11 = 1024;
      int v12 = 2477;
      __int16 v13 = 1024;
      int v14 = a2;
      _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue set highlyBurstyTrafficMode=%u", (uint8_t *)&v7, 0x22u);
    }
  }
  uint64_t result = 0;
  atomic_store(a2, (unsigned __int8 *)(a1 + 301));
  return result;
}

uint64_t VCMediaQueue_SetOneToOne(uint64_t a1, int a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 2149580801;
  }
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)(a1 + 300));
  if ((v3 & 1) == 0)
  {
    atomic_store(0, (unint64_t *)(a1 + 512));
    atomic_store(0, (unint64_t *)(a1 + 504));
    atomic_store(0, (unint64_t *)(a1 + 520));
    atomic_store(0, (unint64_t *)(a1 + 528));
    *(_OWORD *)(a1 + 560) = 0u;
    *(_OWORD *)(a1 + 576) = 0u;
    *(_OWORD *)(a1 + 544) = 0u;
  }
  atomic_store(a2, (unsigned __int8 *)(a1 + 300));
  VCMediaQueuePacketBundler_SetOneToOne(*(void *)(a1 + 136), a2);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    uint64_t v5 = *MEMORY[0x1E4F47A50];
    BOOL v6 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v6) {
      return result;
    }
    int v8 = 136315906;
    uint64_t v9 = v4;
    __int16 v10 = 2080;
    __int16 v11 = "VCMediaQueue_SetOneToOne";
    __int16 v12 = 1024;
    int v13 = 2491;
    __int16 v14 = 1024;
    int v15 = a2;
    _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue set oneToOne=%u", (uint8_t *)&v8, 0x22u);
  }
  return 0;
}

uint64_t VCMediaQueue_SetMinBitrateWithoutThrottling(uint64_t a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 2149580801;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    uint64_t v5 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315906;
      uint64_t v8 = v4;
      __int16 v9 = 2080;
      __int16 v10 = "VCMediaQueue_SetMinBitrateWithoutThrottling";
      __int16 v11 = 1024;
      int v12 = 2499;
      __int16 v13 = 1024;
      unsigned int v14 = a2;
      _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue set minBitrateWithoutThrottling=%u", (uint8_t *)&v7, 0x22u);
    }
  }
  uint64_t result = 0;
  atomic_store(a2, (unsigned int *)(a1 + 304));
  return result;
}

uint64_t VCMediaQueue_SetECNEnabled(uint64_t a1, int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 2149580801;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    uint64_t v5 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315906;
      uint64_t v8 = v4;
      __int16 v9 = 2080;
      __int16 v10 = "VCMediaQueue_SetECNEnabled";
      __int16 v11 = 1024;
      int v12 = 2515;
      __int16 v13 = 1024;
      int v14 = a2;
      _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue set ECNEnabled=%u", (uint8_t *)&v7, 0x22u);
    }
  }
  uint64_t result = 0;
  atomic_store(a2, (unsigned __int8 *)(a1 + 302));
  return result;
}

uint64_t VCMediaQueue_SetMediaQueueSizeThresholdExceededBlock(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v3 = 2149580801;
  if (a1)
  {
    if (a3)
    {
      BOOL v6 = *(const void **)(a1 + 152);
      if (v6)
      {
        _Block_release(v6);
        *(void *)(a1 + 152) = 0;
      }
      if (*(void *)(a1 + 144)) {
        FigCFWeakReferenceStore();
      }
      FigCFWeakReferenceStore();
      uint64_t v3 = 0;
      *(void *)(a1 + 152) = _Block_copy(a3);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaQueue_SetMediaQueueSizeThresholdExceededBlock_cold_1();
      }
    }
  }
  return v3;
}

uint64_t VCMediaQueue_ComputeOneToOneStatsWithPacketInfo(uint64_t a1, unsigned __int16 *a2)
{
  void v5[2] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    unsigned __int8 v2 = atomic_load((unsigned __int8 *)(a1 + 300));
    if (v2)
    {
      v5[0] = a1 + 976;
      v5[1] = *(void *)(a1 + 968);
      VCMediaQueueUtil_FindPacketInTxHistory(a2, v5, (pthread_mutex_t *)(a1 + 25552), 1, 1.0, 5.0);
      return 0;
    }
    else
    {
      uint64_t v3 = 2149580830;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          VCMediaQueue_ComputeOneToOneStatsWithPacketInfo_cold_2();
          return 2149580830;
        }
      }
    }
  }
  else
  {
    uint64_t v3 = 2149580801;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaQueue_ComputeOneToOneStatsWithPacketInfo_cold_1();
      }
    }
  }
  return v3;
}

uint64_t VCMediaQueue_TrafficMetricFromMediaQueueTxHistory(uint64_t a1, int a2)
{
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCMediaQueue_TrafficMetricFromMediaQueueTxHistory_cold_1();
      }
    }
    return 0;
  }
  uint64_t v4 = (pthread_mutex_t *)(a1 + 25552);
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 25552));
  int v6 = *(_DWORD *)(a1 + 968);
  if (!v6 || (int v7 = *(_DWORD *)(a1 + 972), v7 < 1))
  {
LABEL_13:
    uint64_t v13 = 0;
LABEL_14:
    pthread_mutex_unlock(v4);
    return v13;
  }
  unsigned int v8 = v6 - 1;
  unint64_t v9 = a1 + 976;
  __int16 v10 = v8;
  while (1)
  {
    unint64_t v11 = v9 + 48 * (v10 & 0x1FF);
    if (v11 >= (unint64_t)v4 || v11 < v9) {
      break;
    }
    if (a2 == 1 && *(_DWORD *)(v9 + 48 * (v10 & 0x1FF) + 12))
    {
      unint64_t v14 = v9 + 48 * v8;
      if (v14 < (unint64_t)v4 && v14 >= v9)
      {
        uint64_t v13 = *(void *)(v9 + 48 * v8 + 24) - *(void *)(v9 + 48 * (v10 & 0x1FF) + 24);
        goto LABEL_14;
      }
      break;
    }
    --v10;
    if (!--v7) {
      goto LABEL_13;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t VCMediaQueue_BasebandFlushAcked(uint64_t a1, int a2, unsigned __int16 *a3, int a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    int v7 = (unsigned __int8 *)(a1 + 25698);
    unsigned int v8 = (pthread_mutex_t *)(a1 + 25632);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 25632));
    if (a2 && a3)
    {
      int v9 = *a3;
      if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
        goto LABEL_11;
      }
      uint64_t v10 = VRTraceErrorLogLevelToCSTR();
      unint64_t v11 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_11;
      }
      int v12 = *v7;
      int v13 = *(_DWORD *)(v7 + 22);
      int v23 = 136316930;
      uint64_t v24 = v10;
      __int16 v25 = 2080;
      double v26 = "VCMediaQueue_BasebandFlushAcked";
      __int16 v27 = 1024;
      int v28 = 2732;
      __int16 v29 = 1024;
      int v30 = v9;
      __int16 v31 = 1024;
      int v32 = a2;
      __int16 v33 = 1024;
      int v34 = v12;
      __int16 v35 = 1024;
      int v36 = a4;
      __int16 v37 = 1024;
      int v38 = v13;
      unint64_t v14 = "VCMediaQueue [%s] %s:%d Receive baseband flush ack for audio pkts starting with seq=%u, numOfPacketDropped=%"
            "u, pendingBasebandFlush=%d, with transactionID=%u, currentTransactionID=%u";
      uint64_t v15 = v11;
      uint32_t v16 = 58;
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 5) {
        goto LABEL_11;
      }
      uint64_t v17 = VRTraceErrorLogLevelToCSTR();
      uint64_t v18 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_11;
      }
      int v19 = *v7;
      int v20 = *(_DWORD *)(v7 + 22);
      int v23 = 136316674;
      uint64_t v24 = v17;
      __int16 v25 = 2080;
      double v26 = "VCMediaQueue_BasebandFlushAcked";
      __int16 v27 = 1024;
      int v28 = 2734;
      __int16 v29 = 1024;
      int v30 = a2;
      __int16 v31 = 1024;
      int v32 = v19;
      __int16 v33 = 1024;
      int v34 = a4;
      __int16 v35 = 1024;
      int v36 = v20;
      unint64_t v14 = "VCMediaQueue [%s] %s:%d Receive baseband flush ack without dropping audio pkts numOfPacketDropped=%u, pendin"
            "gBasebandFlush=%d, with transactionID=%u, currentTransactionID=%u";
      uint64_t v15 = v18;
      uint32_t v16 = 52;
    }
    _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v23, v16);
LABEL_11:
    if (*(_DWORD *)(v7 + 22) == a4) {
      *int v7 = 0;
    }
    pthread_mutex_unlock(v8);
    return 0;
  }
  uint64_t v21 = 2149580801;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCMediaQueue_BasebandFlushAcked_cold_1();
    }
  }
  return v21;
}

uint64_t _VCMediaQueueFinalize(unint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  reportingUnregisterPeriodicTask();
  VCRealTimeThread_Finalize(*(void *)(a1 + 768));
  if ((int)VRTraceGetErrorLogLevelForModule() > 6)
  {
    uint64_t v2 = VRTraceErrorLogLevelToCSTR();
    uint64_t v3 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 136315906;
      uint64_t v12 = v2;
      __int16 v13 = 2080;
      unint64_t v14 = "_VCMediaQueueFinalize";
      __int16 v15 = 1024;
      int v16 = 348;
      __int16 v17 = 2048;
      unint64_t v18 = a1;
      _os_log_impl(&dword_1E1EA4000, v3, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Finalize the media queue:%p", (uint8_t *)&v11, 0x26u);
    }
  }
  uint64_t v4 = *(const void **)(a1 + 136);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 120);
  if (v5) {
    CFRelease(v5);
  }
  int v6 = *(const void **)(a1 + 616);
  if (v6) {
    CFRelease(v6);
  }
  unint64_t v7 = a1 + 25736;
  if (a1 && v7 <= a1) {
    goto LABEL_18;
  }
  _VCMediaQueue_DestroyInternalQueues(a1);
  unsigned int v8 = *(const void **)(a1 + 152);
  if (v8) {
    _Block_release(v8);
  }
  uint64_t v9 = *(void *)(a1 + 160);
  if (v9)
  {
    pthread_mutex_destroy((pthread_mutex_t *)(v9 + 160));
    pthread_mutex_destroy((pthread_mutex_t *)(*(void *)(a1 + 160) + 384));
    pthread_mutex_destroy((pthread_mutex_t *)(*(void *)(a1 + 160) + 608));
    pthread_mutex_destroy((pthread_mutex_t *)(*(void *)(a1 + 160) + 832));
    free(*(void **)(a1 + 160));
    *(void *)(a1 + 160) = 0;
  }
  _VCMediaQueue_ReleaseLogDumpFile(a1);
  if (v7 <= a1) {
LABEL_18:
  }
    __break(0x5519u);
  FigCFWeakReferenceStore();
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 216));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 776));
  pthread_cond_destroy((pthread_cond_t *)(a1 + 840));
  pthread_cond_destroy((pthread_cond_t *)(a1 + 896));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 25552));
  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 25632));
}

uint64_t _VCMediaQueue_AddInfoToOneToOneTxHistory(uint64_t a1, __int16 a2, double a3)
{
  int v6 = (pthread_mutex_t *)(a1 + 25552);
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 25552));
  unsigned int v8 = *(_DWORD *)(a1 + 968);
  uint64_t v9 = (_WORD *)(a1 + 976 + 48 * v8);
  if (a1 + 976 > (unint64_t)v9 || v9 + 24 > (_WORD *)v6)
  {
    __break(0x5519u);
  }
  else
  {
    uint64_t v11 = a1 + 976 + 48 * v8;
    *(_WORD *)(v11 + 2) = a2;
    *(double *)(v11 + 40) = a3;
    *(void *)(v11 + 4) = *(void *)(a1 + 25616);
    uint64_t v12 = *(unsigned int *)(a1 + 25624);
    *uint64_t v9 = 0;
    *(_DWORD *)(v11 + 12) = 0;
    *(_DWORD *)(v11 + 16) = 0;
    *(void *)(v11 + 24) = v12;
    *(void *)(v11 + 32) = 0;
    *(_DWORD *)(a1 + 968) = ((_WORD)v8 + 1) & 0x1FF;
    unsigned int v13 = *(_DWORD *)(a1 + 972);
    if (v13 <= 0x1FF) {
      *(_DWORD *)(a1 + 972) = v13 + 1;
    }
    return pthread_mutex_unlock(v6);
  }
  return result;
}

void _VCMediaQueue_FlushPacketsFromQueue(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 348);
  if (v1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = 176 * v1;
    while (1)
    {
      unint64_t v5 = *(void *)(a1 + 624);
      unint64_t v6 = v5 + v3;
      if (v5 + v3)
      {
        if (v6 < v5 || v6 >= v5 + 176 * *(unsigned int *)(a1 + 348)) {
          break;
        }
      }
      _VCMediaQueue_FlushInternalQueueBeforeTimestamp(v6, a1, -1);
      v3 += 176;
      if (v4 == v3) {
        return;
      }
    }
    __break(0x5519u);
  }
}

uint64_t __VCMediaQueueSendProc_block_invoke(void *a1, void *element, int a3, int a4, int a5)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = a1[6];
  unint64_t v6 = a1[8];
  if (v5 + 25736 > a1[7] || v6 > v5) {
    goto LABEL_28;
  }
  *(_DWORD *)(v5 + 428) += a3;
  unint64_t v9 = a1[6];
  if (v9 + 25736 > a1[7] || v6 > v9) {
    goto LABEL_28;
  }
  *(_DWORD *)(v9 + 424) += a4 + a3;
  unint64_t v11 = a1[6];
  if (v11 + 25736 > a1[7] || v6 > v11) {
    goto LABEL_28;
  }
  *(_DWORD *)(v11 + 432) += a5;
  if (!element) {
    return 4294954516;
  }
  if (*(void *)(*(void *)(a1[4] + 8) + 24))
  {
    uint64_t v14 = 4294954516;
  }
  else
  {
    unint64_t v15 = a1[6];
    if (v15 + 25736 > a1[7] || v6 > v15) {
      goto LABEL_28;
    }
    uint64_t v14 = CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(v15 + 616), element);
    if (!v14) {
      return v14;
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    uint64_t v16 = VRTraceErrorLogLevelToCSTR();
    __int16 v17 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v22 = 136315906;
      uint64_t v23 = v16;
      __int16 v24 = 2080;
      __int16 v25 = "VCMediaQueueSendProc_block_invoke";
      __int16 v26 = 1024;
      int v27 = 545;
      __int16 v28 = 1024;
      int v29 = v14;
      _os_log_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Unable to enqueue onto the main queue. Dropping the packet. status=%d", (uint8_t *)&v22, 0x22u);
    }
  }
  unint64_t v18 = a1[6];
  if (v18 + 25736 > a1[7] || a1[8] > v18) {
LABEL_28:
  }
    __break(0x5519u);
  ++*(_DWORD *)(v18 + 492);
  **(void **)(*(void *)(a1[5] + 8) + 24) = element;
  uint64_t v19 = *(void *)(a1[5] + 8);
  uint64_t v20 = **(void **)(v19 + 24);
  do
  {
    *(void *)(v19 + 24) = v20 + 304;
    uint64_t v19 = *(void *)(a1[5] + 8);
    uint64_t v20 = **(void **)(v19 + 24);
  }
  while (v20);
  return v14;
}

void _VCMediaQueue_FlushInternalQueueBeforeTimestamp(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)((char *)&v61[2] + 6) = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return;
  }
  unsigned __int8 v6 = atomic_exchange((atomic_uchar *volatile)(a1 + 95), 0);
  unint64_t v7 = atomic_load((unint64_t *)(a1 + 104));
  if (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 16)) < 1) {
    return;
  }
  unsigned int v8 = 0;
  do
  {
    Head = CMSimpleQueueGetHead(*(CMSimpleQueueRef *)(a1 + 16));
    uint64_t v10 = (uint64_t)Head;
    if (a3 != -1 && *((unsigned int *)Head + 59) > a3) {
      break;
    }
    if (v6)
    {
      BOOL v11 = !Head[289] || v7 == -1;
      if (!v11 && (*((_DWORD *)Head + 59) - v7) < 0x7FFFFFFF) {
        break;
      }
    }
    CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 16));
    if (*(void *)(v10 + 184))
    {
      unsigned __int8 v12 = atomic_load((unsigned __int8 *)(a2 + 300));
      if (v12)
      {
        dataPointerOut = 0;
        size_t lengthAtOffsetOut = 0;
        OSStatus DataPointer = CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(v10 + 8), 0, &lengthAtOffsetOut, 0, &dataPointerOut);
        if (DataPointer)
        {
          OSStatus v27 = DataPointer;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            uint64_t v45 = VRTraceErrorLogLevelToCSTR();
            __int16 v28 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
            {
              int v29 = v28;
              int v30 = *(unsigned __int8 *)(v10 + 58);
              if (*(unsigned char *)(v10 + 58)) {
                int v31 = *(unsigned __int16 *)(v10 + 60);
              }
              else {
                int v31 = 0;
              }
              int32_t v41 = *(_DWORD *)(v10 + 228);
              *(_DWORD *)buf = 136316674;
              uint64_t v51 = v45;
              __int16 v52 = 2080;
              unsigned int v53 = "_VCMediaQueue_SerializeControlInfoIntoBufferForOneToOne";
              __int16 v54 = 1024;
              int v55 = 1669;
              __int16 v56 = 1024;
              OSStatus v57 = v27;
              __int16 v58 = 1024;
              int32_t v59 = v41;
              __int16 v60 = 1024;
              LODWORD(v61[0]) = v30;
              WORD2(v61[0]) = 1024;
              *(_DWORD *)((char *)v61 + 6) = v31;
              int v36 = "VCMediaQueue [%s] %s:%d CMBlock error=%d when serializing control info, for packet mediaQueueStreamI"
                    "d=%u, isServerStats=%u, statsID=%u";
              uint32_t v37 = 52;
              goto LABEL_43;
            }
          }
        }
        else
        {
          uint64_t v14 = &dataPointerOut[*(unsigned int *)(v10 + 244)];
          if (v14)
          {
            if (v14 < dataPointerOut || v14 >= &dataPointerOut[lengthAtOffsetOut]) {
              __break(0x5519u);
            }
          }
          OSStatus v16 = VCMediaControlInfoSerialize(*(void *)(v10 + 184));
          if (v16 < 0)
          {
            OSStatus v32 = v16;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              uint64_t v46 = VRTraceErrorLogLevelToCSTR();
              __int16 v33 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
              {
                int32_t v34 = *(unsigned __int16 *)(v10 + 248);
                uint64_t v35 = *(void *)(v10 + 184);
                *(_DWORD *)buf = 136316418;
                uint64_t v51 = v46;
                __int16 v52 = 2080;
                unsigned int v53 = "_VCMediaQueue_SerializeControlInfoIntoBufferForOneToOne";
                __int16 v54 = 1024;
                int v55 = 1673;
                __int16 v56 = 1024;
                OSStatus v57 = v32;
                __int16 v58 = 1024;
                int32_t v59 = v34;
                __int16 v60 = 2048;
                v61[0] = v35;
                int v29 = v33;
                int v36 = "VCMediaQueue [%s] %s:%d Adding extension failed when serializing control info, with result=%08X fo"
                      "r packet sequenceNum=%u controlInfo=%p";
                uint32_t v37 = 50;
LABEL_43:
                _os_log_error_impl(&dword_1E1EA4000, v29, OS_LOG_TYPE_ERROR, v36, buf, v37);
              }
            }
          }
        }
      }
    }
    if ((const void *)v10 == CMSimpleQueueGetHead(*(CMSimpleQueueRef *)(a1 + 8)))
    {
      uint64_t v23 = *(opaqueCMSimpleQueue **)a1;
      __int16 v24 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 8));
      OSStatus v25 = CMSimpleQueueEnqueue(v23, v24);
      if (!v25) {
        goto LABEL_27;
      }
      OSStatus v38 = v25;
      if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
        goto LABEL_27;
      }
      uint64_t v47 = VRTraceErrorLogLevelToCSTR();
      uint64_t v39 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      int32_t v40 = *(_DWORD *)(v10 + 228);
      *(_DWORD *)buf = 136316162;
      uint64_t v51 = v47;
      __int16 v52 = 2080;
      unsigned int v53 = "_VCMediaQueue_FlushInternalQueueBeforeTimestamp";
      __int16 v54 = 1024;
      int v55 = 1703;
      __int16 v56 = 1024;
      OSStatus v57 = v38;
      __int16 v58 = 1024;
      int32_t v59 = v40;
      uint64_t v20 = v39;
      uint64_t v21 = "VCMediaQueue [%s] %s:%d Internal queue has error %d when free media packet for mediaQueueStreamId=%u";
      uint32_t v22 = 40;
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
        goto LABEL_27;
      }
      uint64_t v17 = VRTraceErrorLogLevelToCSTR();
      unint64_t v18 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      OSStatus v19 = *(_DWORD *)(v10 + 228);
      *(_DWORD *)buf = 136315906;
      uint64_t v51 = v17;
      __int16 v52 = 2080;
      unsigned int v53 = "_VCMediaQueue_FlushInternalQueueBeforeTimestamp";
      __int16 v54 = 1024;
      int v55 = 1705;
      __int16 v56 = 1024;
      OSStatus v57 = v19;
      uint64_t v20 = v18;
      uint64_t v21 = "VCMediaQueue [%s] %s:%d Media packets are drained from the busy pool of stream=%u out of order!";
      uint32_t v22 = 34;
    }
    _os_log_error_impl(&dword_1E1EA4000, v20, OS_LOG_TYPE_ERROR, v21, buf, v22);
LABEL_27:
    uint64_t v26 = *(void *)(v10 + 184);
    if (v26)
    {
      VCMediaControlInfoDispose(v26);
      *(void *)(v10 + 184) = 0;
    }
    _VCMediaQueue_ReleaseExternalDataBuffer(a2, v10);
    ++v8;
  }
  while (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 16)) > 0);
  *(void *)(a2 + 536) += v8;
  if (v8)
  {
    _VCMediaQueue_ReportingEvent((_DWORD *)a2, 194, *(_DWORD *)(a1 + 124));
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v42 = VRTraceErrorLogLevelToCSTR();
      int v43 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int32_t Count = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 16));
        *(_DWORD *)buf = 136316162;
        uint64_t v51 = v42;
        __int16 v52 = 2080;
        unsigned int v53 = "_VCMediaQueue_FlushInternalQueueBeforeTimestamp";
        __int16 v54 = 1024;
        int v55 = 1715;
        __int16 v56 = 1024;
        OSStatus v57 = v8;
        __int16 v58 = 1024;
        int32_t v59 = Count;
        _os_log_impl(&dword_1E1EA4000, v43, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue internal queue flushed with %u packets, %d remaining", buf, 0x28u);
      }
    }
    _VCMediaQueue_CheckAndReportSymptomForInternalQueue(a1);
  }
}

uint64_t _VCMediaQueue_DrainAllPacketsFromMainQueue(uint64_t a1)
{
  if (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 616)) < 1) {
    return 0;
  }
  LODWORD(v2) = 0;
  do
  {
    CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 616));
    _VCMediaQueue_SendAndFreePackets(a1);
    ++*(_DWORD *)(a1 + 436);
    uint64_t v2 = (v2 + 1);
  }
  while (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 616)) > 0);
  return v2;
}

void sub_1E2310BCC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1E2310E5C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1E2310FBC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t VCVirtualHardwareConfigurations_EmbeddedConfigurationForDevice(void *a1, long long *a2)
{
  uint64_t result = 0;
  if (a1 && VCVirtualHardwareConfiguration_iOSConfigurationsCount)
  {
    uint64_t v5 = 0;
    for (uint64_t i = &VCVirtualHardwareConfiguration_iOSConfigurations;
          ![a1 isEqualToString:*(void *)i];
          i += 3)
    {
      if (++v5 >= (unint64_t)VCVirtualHardwareConfiguration_iOSConfigurationsCount) {
        return 0;
      }
    }
    if (a2)
    {
      long long v7 = *i;
      long long v8 = i[2];
      a2[1] = i[1];
      a2[2] = v8;
      *a2 = v7;
    }
    return 1;
  }
  return result;
}

uint64_t VCVirtualHardwareConfigurations_OSXConfigurationForDevice(void *a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a1 && VCVirtualHardwareConfiguration_OSXConfigurationsCount)
  {
    uint64_t v5 = 0;
    for (uint64_t i = &off_1EADC70D0; ![a1 isEqualToString:*i]; i += 9)
    {
      if (++v5 >= (unint64_t)VCVirtualHardwareConfiguration_OSXConfigurationsCount) {
        return 0;
      }
    }
    if (a2)
    {
      *(_OWORD *)a2 = *(_OWORD *)(i - 1);
      long long v7 = *(_OWORD *)(i + 1);
      long long v8 = *(_OWORD *)(i + 3);
      long long v9 = *(_OWORD *)(i + 5);
      *(void *)(a2 + 64) = i[7];
      *(_OWORD *)(a2 + 32) = v8;
      *(_OWORD *)(a2 + 48) = v9;
      *(_OWORD *)(a2 + 16) = v7;
    }
    return 1;
  }
  return result;
}

uint64_t VCVirtualHardwareConfigurations_DevicePlatform(void *a1)
{
  int v2 = 0;
  if (a1 && VCVirtualHardwareConfiguration_iOSConfigurationsCount)
  {
    unint64_t v3 = 0;
    uint64_t v4 = &VCVirtualHardwareConfiguration_iOSConfigurations;
    do
    {
      int v2 = [a1 isEqualToString:*(void *)v4];
      if (v2) {
        break;
      }
      ++v3;
      v4 += 3;
    }
    while (v3 < VCVirtualHardwareConfiguration_iOSConfigurationsCount);
  }
  if (a1 && VCVirtualHardwareConfiguration_OSXConfigurationsCount)
  {
    unint64_t v5 = 0;
    unsigned __int8 v6 = &off_1EADC70D0;
    while (([a1 isEqualToString:*v6] & 1) == 0)
    {
      ++v5;
      v6 += 9;
      if (v5 >= VCVirtualHardwareConfiguration_OSXConfigurationsCount) {
        goto LABEL_11;
      }
    }
    if (!v2) {
      return v2 ^ 1u;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v10 = VRTraceErrorLogLevelToCSTR();
      BOOL v11 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCVirtualHardwareConfigurations_DevicePlatform_cold_2(v10, v11);
      }
    }
  }
  else
  {
LABEL_11:
    if (v2) {
      return v2 ^ 1u;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v7 = VRTraceErrorLogLevelToCSTR();
      long long v8 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCVirtualHardwareConfigurations_DevicePlatform_cold_1(v7, (uint64_t)a1, v8);
      }
    }
  }
  return 2;
}

void sub_1E2311AD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1E2314FA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void sub_1E231518C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void sub_1E2315384(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void sub_1E231557C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void sub_1E231857C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1E2319C10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 112), 8);
  _Unwind_Resume(a1);
}

uint64_t init_WiFiCopyCurrentNetworkInfoEx(uint64_t a1, uint64_t a2)
{
  if (LoadCoreUtils_loadPredicate != -1) {
    dispatch_once(&LoadCoreUtils_loadPredicate, &__block_literal_global_78);
  }
  uint64_t v4 = (uint64_t (*)())dlsym((void *)LoadCoreUtils_frameworkLibrary, "WiFiCopyCurrentNetworkInfoEx");
  softLink_WiFiCopyCurrentNetworkInfoEx = v4;

  return ((uint64_t (*)(uint64_t, uint64_t))v4)(a1, a2);
}

void __LoadCoreUtils_block_invoke()
{
  LoadCoreUtils_frameworkLibrary = (uint64_t)dlopen("/System/Library/PrivateFrameworks/CoreUtils.framework/CoreUtils", 2);
  if (!LoadCoreUtils_frameworkLibrary) {
    NSLog(&cfstr_FailedToSoftLi.isa);
  }
}

uint64_t init_WiFiManagerCreate(uint64_t a1, uint64_t a2)
{
  if (LoadCoreUtils_loadPredicate != -1) {
    dispatch_once(&LoadCoreUtils_loadPredicate, &__block_literal_global_78);
  }
  uint64_t v4 = (uint64_t (*)())dlsym((void *)LoadCoreUtils_frameworkLibrary, "WiFiManagerCreate");
  softLink_WiFiManagerCreate = v4;

  return ((uint64_t (*)(uint64_t, uint64_t))v4)(a1, a2);
}

uint64_t init_WiFiManagerSetProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (LoadCoreUtils_loadPredicate != -1) {
    dispatch_once(&LoadCoreUtils_loadPredicate, &__block_literal_global_78);
  }
  long long v8 = (uint64_t (*)())dlsym((void *)LoadCoreUtils_frameworkLibrary, "WiFiManagerSetProperty");
  softLink_WiFiManagerSetProperty = v8;

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v8)(a1, a2, a3, a4);
}

uint64_t init_WiFiManagerDoApple80211(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (LoadCoreUtils_loadPredicate != -1) {
    dispatch_once(&LoadCoreUtils_loadPredicate, &__block_literal_global_78);
  }
  uint64_t v10 = (uint64_t (*)())dlsym((void *)LoadCoreUtils_frameworkLibrary, "WiFiManagerDoApple80211");
  softLink_WiFiManagerDoApple80211 = v10;

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v10)(a1, a2, a3, a4, a5);
}

uint64_t initkWiFiManagerPropertyInterfaceName()
{
  if (LoadCoreUtils_loadPredicate != -1) {
    dispatch_once(&LoadCoreUtils_loadPredicate, &__block_literal_global_78);
  }
  uint64_t result = *(void *)dlsym((void *)LoadCoreUtils_frameworkLibrary, "kWiFiManagerPropertyInterfaceName");
  constantkWiFiManagerPropertyInterfaceName = result;
  getkWiFiManagerPropertyInterfaceName = kWiFiManagerPropertyInterfaceNameFunction;
  return result;
}

uint64_t kWiFiManagerPropertyInterfaceNameFunction()
{
  return constantkWiFiManagerPropertyInterfaceName;
}

BOOL VCDuplicationHandler_IsDuplicationEnabled(BOOL result)
{
  if (result) {
    return *(unsigned __int8 *)(result + 8) == 2;
  }
  return result;
}

uint64_t VCDuplicationHandler_HandleDuplicationStateUpdateEvent(unsigned char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  uint64_t v51 = 0;
  if (a1)
  {
    switch((char)a2)
    {
      case 0:
      case 2:
        if (a1[9]) {
          return v51;
        }
        char v5 = a2;
        if ((_BYTE)a2)
        {
          if (a2 != 2) {
            return v51;
          }
        }
        else
        {
          char v5 = 1;
        }
        a1[9] = v5;
        VCDuplicationHandler_EnableDuplication(a1);
        LOBYTE(v51) = 1;
        return v51;
      case 1:
      case 3:
        if (a1[9] - 1 <= 1)
        {
          a1[9] = 0;
          VCDuplicationHandler_DisableDuplication((uint64_t)a1);
          char v6 = 1;
          goto LABEL_110;
        }
        return v51;
      case 4:
        HIDWORD(v51) = 0;
        if (a1[23])
        {
          int v7 = a1[9];
          if ((a2 & 0x100) != 0)
          {
            if (v7 != 4) {
              return v51;
            }
          }
          else if (v7 != 4)
          {
            if (a1[9]) {
              goto LABEL_106;
            }
            a1[9] = 3;
            VCDuplicationHandler_EnableDuplication(a1);
            LOWORD(v51) = 257;
            HIDWORD(v51) = 2;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              uint64_t v8 = VRTraceErrorLogLevelToCSTR();
              long long v9 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                uint64_t v53 = v8;
                __int16 v54 = 2080;
                int v55 = "_VCDuplicationHandler_UpdateDuplicationStateForLocalWRMSuggestingCellularEvent";
                __int16 v56 = 1024;
                int v57 = 179;
                uint64_t v10 = " [%s] %s:%d HandoverReport: start dupe by local media degraded.";
                goto LABEL_122;
              }
            }
            return v51;
          }
          a1[9] = 5;
          VCDuplicationHandler_EnableDuplication(a1);
          BYTE1(v51) = 1;
          HIDWORD(v51) = 2;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            uint64_t v43 = VRTraceErrorLogLevelToCSTR();
            long long v9 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              uint64_t v53 = v43;
              __int16 v54 = 2080;
              int v55 = "_VCDuplicationHandler_UpdateDuplicationStateForLocalWRMSuggestingCellularEvent";
              __int16 v56 = 1024;
              int v57 = 186;
              uint64_t v10 = " [%s] %s:%d HandoverReport: start dupe by both local media degraded and remote duplication.";
              goto LABEL_122;
            }
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v36 = VRTraceErrorLogLevelToCSTR();
          long long v9 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            uint64_t v53 = v36;
            __int16 v54 = 2080;
            int v55 = "_VCDuplicationHandler_UpdateDuplicationStateForLocalWRMSuggestingCellularEvent";
            __int16 v56 = 1024;
            int v57 = 166;
            uint64_t v10 = " [%s] %s:%d HandoverReport: Ignoring iRAT suggestion as directed by storebag settings";
            goto LABEL_122;
          }
        }
        return v51;
      case 5:
        if (a1[23])
        {
          int v11 = a1[9];
          if ((a2 & 0x100) != 0 || a1[9])
          {
            if (v11 == 5)
            {
              a1[9] = 4;
              VCDuplicationHandler_EnableDuplication(a1);
              BYTE1(v51) = 1;
              HIDWORD(v51) = 3;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                uint64_t v48 = VRTraceErrorLogLevelToCSTR();
                long long v9 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315650;
                  uint64_t v53 = v48;
                  __int16 v54 = 2080;
                  int v55 = "_VCDuplicationHandler_UpdateDuplicationStateForLocalWRMSuggestingWiFiEvent";
                  __int16 v56 = 1024;
                  int v57 = 214;
                  uint64_t v10 = " [%s] %s:%d HandoverReport: stop dupe by local media degraded but remain dupe by remote duplication.";
                  goto LABEL_122;
                }
              }
            }
            else if (v11 == 3)
            {
              a1[9] = 0;
              VCDuplicationHandler_DisableDuplication((uint64_t)a1);
              LOWORD(v51) = 257;
              HIDWORD(v51) = 3;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                uint64_t v12 = VRTraceErrorLogLevelToCSTR();
                long long v9 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315650;
                  uint64_t v53 = v12;
                  __int16 v54 = 2080;
                  int v55 = "_VCDuplicationHandler_UpdateDuplicationStateForLocalWRMSuggestingWiFiEvent";
                  __int16 v56 = 1024;
                  int v57 = 207;
                  uint64_t v10 = " [%s] %s:%d HandoverReport: stop dupe by local media degraded.";
                  goto LABEL_122;
                }
              }
            }
            else
            {
LABEL_106:
              _VCDuplicationHandler_ShareLocalInterfacePreferenceWithPeerDuringActiveDuplicationForEvent(a1, a2, a3, (uint64_t)&v51);
            }
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v37 = VRTraceErrorLogLevelToCSTR();
          long long v9 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            uint64_t v53 = v37;
            __int16 v54 = 2080;
            int v55 = "_VCDuplicationHandler_UpdateDuplicationStateForLocalWRMSuggestingWiFiEvent";
            __int16 v56 = 1024;
            int v57 = 194;
            uint64_t v10 = " [%s] %s:%d HandoverReport: Ignoring iRAT suggestion as directed by storebag settings";
            goto LABEL_122;
          }
        }
        return v51;
      case 6:
        int v13 = 1;
        goto LABEL_72;
      case 7:
        _VCDuplicationHandler_StopRemoteDuplicationAndUpdateResult(a1, &v51, 1);
        unsigned int v14 = a1[9];
        BOOL v15 = v14 > 6;
        int v16 = (1 << v14) & 0x46;
        if (v15 || v16 == 0) {
          return v51;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
          return v51;
        }
        uint64_t v18 = VRTraceErrorLogLevelToCSTR();
        OSStatus v19 = *MEMORY[0x1E4F47A50];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
          return v51;
        }
        uint64_t v20 = "WiFi";
        *(_DWORD *)buf = 136315906;
        uint64_t v53 = v18;
        __int16 v54 = 2080;
        int v55 = "_VCDuplicationHandler_UpdateDuplicationStateForRemoteWRMSuggestingWiFiEvent";
        if ((a2 & 0x10000000000) == 0) {
          uint64_t v20 = "Cellular";
        }
        __int16 v56 = 1024;
        int v57 = 224;
        __int16 v58 = 2080;
        int32_t v59 = v20;
        uint64_t v10 = " [%s] %s:%d HandoverReport: remote duplication suggests %s during other type of duplication.";
        uint64_t v21 = v19;
        uint32_t v22 = 38;
        goto LABEL_123;
      case 8:
        a1[10] = 1;
        return v51;
      case 9:
        a1[10] = 0;
        return v51;
      case 10:
        HIDWORD(v51) = 0;
        int v23 = a1[9];
        if ((v23 - 3) > 2) {
          return v51;
        }
        switch(v23)
        {
          case 5:
            BYTE1(v51) = 1;
            HIDWORD(v51) = 3;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              uint64_t v46 = VRTraceErrorLogLevelToCSTR();
              OSStatus v25 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                uint64_t v53 = v46;
                __int16 v54 = 2080;
                int v55 = "_VCDuplicationHandler_UpdateDuplicationStateForTurnOffDuplicationForHandoverEvent";
                __int16 v56 = 1024;
                int v57 = 270;
                uint64_t v26 = " [%s] %s:%d HandoverReport: stop dupe by both local media degraded and remote duplication in handover.";
                goto LABEL_117;
              }
            }
            break;
          case 4:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              uint64_t v47 = VRTraceErrorLogLevelToCSTR();
              OSStatus v25 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                uint64_t v53 = v47;
                __int16 v54 = 2080;
                int v55 = "_VCDuplicationHandler_UpdateDuplicationStateForTurnOffDuplicationForHandoverEvent";
                __int16 v56 = 1024;
                int v57 = 272;
                uint64_t v26 = " [%s] %s:%d HandoverReport: stop dupe by remote media degraded in handover.";
                goto LABEL_117;
              }
            }
            break;
          case 3:
            BYTE1(v51) = 1;
            HIDWORD(v51) = 3;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              uint64_t v24 = VRTraceErrorLogLevelToCSTR();
              OSStatus v25 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                uint64_t v53 = v24;
                __int16 v54 = 2080;
                int v55 = "_VCDuplicationHandler_UpdateDuplicationStateForTurnOffDuplicationForHandoverEvent";
                __int16 v56 = 1024;
                int v57 = 266;
                uint64_t v26 = " [%s] %s:%d HandoverReport: stop dupe by local media degraded in handover.";
LABEL_117:
                _os_log_impl(&dword_1E1EA4000, v25, OS_LOG_TYPE_DEFAULT, v26, buf, 0x1Cu);
              }
            }
            break;
        }
        LOBYTE(v51) = 1;
        a1[9] = 0;
        VCDuplicationHandler_DisableDuplication((uint64_t)a1);
        return v51;
      case 11:
        if (a1[23])
        {
          HIDWORD(v51) = 0;
          if ((a2 & 0x1000000) == 0 && !a1[9])
          {
            if ((a2 & 0x100000000) == 0)
            {
              a1[9] = 3;
              VCDuplicationHandler_EnableDuplication(a1);
              LOWORD(v51) = 257;
              HIDWORD(v51) = 2;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                uint64_t v27 = VRTraceErrorLogLevelToCSTR();
                __int16 v28 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315650;
                  uint64_t v53 = v27;
                  __int16 v54 = 2080;
                  int v55 = "_VCDuplicationHandler_UpdateDuplicationStateForTurnOnDuplicationForHandoverEvent";
                  __int16 v56 = 1024;
                  int v57 = 294;
                  _os_log_impl(&dword_1E1EA4000, v28, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: start dupe by local media degraded in handover.", buf, 0x1Cu);
                }
              }
            }
            if ((a2 & 0x10000000000) == 0)
            {
              a1[9] = 4;
              VCDuplicationHandler_EnableDuplication(a1);
              LOBYTE(v51) = 1;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                uint64_t v29 = VRTraceErrorLogLevelToCSTR();
                long long v9 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315650;
                  uint64_t v53 = v29;
                  __int16 v54 = 2080;
                  int v55 = "_VCDuplicationHandler_UpdateDuplicationStateForTurnOnDuplicationForHandoverEvent";
                  __int16 v56 = 1024;
                  int v57 = 300;
                  uint64_t v10 = " [%s] %s:%d HandoverReport: start dupe by remote media degraded in handover.";
                  goto LABEL_122;
                }
              }
            }
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v38 = VRTraceErrorLogLevelToCSTR();
          long long v9 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            uint64_t v53 = v38;
            __int16 v54 = 2080;
            int v55 = "_VCDuplicationHandler_UpdateDuplicationStateForTurnOnDuplicationForHandoverEvent";
            __int16 v56 = 1024;
            int v57 = 282;
            uint64_t v10 = " [%s] %s:%d HandoverReport: Ignoring iRAT suggestion as directed by storebag settings";
            goto LABEL_122;
          }
        }
        return v51;
      case 12:
        uint64_t v30 = 15;
        if ((a2 & 0x1000000000000) != 0) {
          uint64_t v30 = 11;
        }
        a1[v30] = HIBYTE(a2) & 1;
        LOBYTE(v51) = _VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo(a1, (a2 & 0x1000000000000uLL) >> 48);
        return v51;
      case 13:
        if (!a3)
        {
          uint64_t v39 = 12;
          if ((a3 & 0x100000000) == 0) {
            uint64_t v39 = 13;
          }
          ++a1[v39];
          if ((a3 & 0x10000000000) == 0)
          {
            char v40 = a1[17] + 1;
LABEL_101:
            a1[17] = v40;
            goto LABEL_109;
          }
          char v44 = a1[16] + 1;
          goto LABEL_108;
        }
        if ((a3 & 0x100000000) != 0)
        {
          int v31 = a1 + 12;
          char v32 = a1[12];
          if (!v32) {
            goto LABEL_98;
          }
        }
        else
        {
          int v31 = a1 + 13;
          char v32 = a1[13];
          if (!v32) {
            goto LABEL_98;
          }
        }
        unsigned char *v31 = v32 - 1;
LABEL_98:
        if ((a3 & 0x10000000000) == 0)
        {
          if (!a1[17]) {
            goto LABEL_109;
          }
          char v40 = a1[17] - 1;
          goto LABEL_101;
        }
        if (a1[16])
        {
          char v44 = a1[16] - 1;
LABEL_108:
          a1[16] = v44;
        }
LABEL_109:
        char updated = _VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo(a1, 1);
        char v6 = updated | _VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo(a1, 0);
LABEL_110:
        LOBYTE(v51) = v6;
        break;
      case 14:
        if (a1[9] == 4)
        {
          a1[9] = 7;
          VCDuplicationHandler_EnableDuplication(a1);
          LOWORD(v51) = 256;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            uint64_t v41 = VRTraceErrorLogLevelToCSTR();
            long long v9 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              uint64_t v53 = v41;
              __int16 v54 = 2080;
              int v55 = "_VCDuplicationHandler_UpdateDuplicationStateForMediaHealthUnrecoverable";
              __int16 v56 = 1024;
              int v57 = 366;
              uint64_t v10 = " [%s] %s:%d HandoverReport: start dupe by both local media health unrecoverable and remote duplication.";
              goto LABEL_122;
            }
          }
        }
        else if (!a1[9])
        {
          a1[9] = 6;
          VCDuplicationHandler_EnableDuplication(a1);
          LOWORD(v51) = 257;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            uint64_t v33 = VRTraceErrorLogLevelToCSTR();
            long long v9 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              uint64_t v53 = v33;
              __int16 v54 = 2080;
              int v55 = "_VCDuplicationHandler_UpdateDuplicationStateForMediaHealthUnrecoverable";
              __int16 v56 = 1024;
              int v57 = 359;
              uint64_t v10 = " [%s] %s:%d HandoverReport: start dupe by media health unrecoverable.";
              goto LABEL_122;
            }
          }
        }
        return v51;
      case 15:
        int v34 = a1[9];
        if (v34 == 7)
        {
          a1[9] = 4;
          VCDuplicationHandler_EnableDuplication(a1);
          LOWORD(v51) = 256;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            uint64_t v42 = VRTraceErrorLogLevelToCSTR();
            long long v9 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              uint64_t v53 = v42;
              __int16 v54 = 2080;
              int v55 = "_VCDuplicationHandler_UpdateDuplicationStateForMediaHealthRecovered";
              __int16 v56 = 1024;
              int v57 = 384;
              uint64_t v10 = " [%s] %s:%d HandoverReport: stop dupe by media health recovered but remain dupe by remote duplication.";
              goto LABEL_122;
            }
          }
        }
        else if (v34 == 6)
        {
          a1[9] = 0;
          VCDuplicationHandler_DisableDuplication((uint64_t)a1);
          LOWORD(v51) = 257;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            uint64_t v35 = VRTraceErrorLogLevelToCSTR();
            long long v9 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              uint64_t v53 = v35;
              __int16 v54 = 2080;
              int v55 = "_VCDuplicationHandler_UpdateDuplicationStateForMediaHealthRecovered";
              __int16 v56 = 1024;
              int v57 = 377;
              uint64_t v10 = " [%s] %s:%d HandoverReport: stop dupe by media health recovered.";
              goto LABEL_122;
            }
          }
        }
        return v51;
      case 16:
        int v13 = 0;
LABEL_72:
        _VCDuplicationHandler_UpdateDuplicationStateForRemoteDuplicationChanged(a1, a2, a3, &v51, v13);
        return v51;
      default:
        return v51;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    uint64_t v50 = VRTraceErrorLogLevelToCSTR();
    long long v9 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      uint64_t v53 = v50;
      __int16 v54 = 2080;
      int v55 = "VCDuplicationHandler_HandleDuplicationStateUpdateEvent";
      __int16 v56 = 1024;
      int v57 = 53;
      uint64_t v10 = " [%s] %s:%d nil instance passed";
LABEL_122:
      uint64_t v21 = v9;
      uint32_t v22 = 28;
LABEL_123:
      _os_log_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_DEFAULT, v10, buf, v22);
    }
  }
  return v51;
}

void _VCDuplicationHandler_UpdateDuplicationStateForRemoteDuplicationChanged(unsigned char *a1, uint64_t a2, uint64_t a3, _WORD *a4, int a5)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if ((a2 & 0x10000) == 0)
  {
    _VCDuplicationHandler_StopRemoteDuplicationAndUpdateResult(a1, a4, a5);
    goto LABEL_3;
  }
  int v15 = a1[9];
  if (v15 == 6)
  {
    a1[9] = 7;
    VCDuplicationHandler_EnableDuplication(a1);
    *a4 = 0;
    if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
      goto LABEL_3;
    }
    uint64_t v19 = VRTraceErrorLogLevelToCSTR();
    uint64_t v17 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_3;
    }
    int v21 = 136315650;
    uint64_t v22 = v19;
    __int16 v23 = 2080;
    uint64_t v24 = "_VCDuplicationHandler_UpdateDuplicationStateForRemoteDuplicationChanged";
    __int16 v25 = 1024;
    int v26 = 420;
    uint64_t v18 = " [%s] %s:%d HandoverReport: start dupe by both local media health unrecoverable and remote duplication.";
    goto LABEL_29;
  }
  if (v15 == 3)
  {
    a1[9] = 5;
    if (a5)
    {
      a1[15] = 1;
      *(unsigned char *)a4 = _VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo(a1, 0);
    }
    VCDuplicationHandler_EnableDuplication(a1);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v20 = VRTraceErrorLogLevelToCSTR();
      uint64_t v17 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v21 = 136315650;
        uint64_t v22 = v20;
        __int16 v23 = 2080;
        uint64_t v24 = "_VCDuplicationHandler_UpdateDuplicationStateForRemoteDuplicationChanged";
        __int16 v25 = 1024;
        int v26 = 413;
        uint64_t v18 = " [%s] %s:%d HandoverReport: start dupe by both remote and local media degraded.";
        goto LABEL_29;
      }
    }
  }
  else if (!a1[9])
  {
    a1[9] = 4;
    if (a5)
    {
      a1[15] = 1;
      _VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo(a1, 0);
    }
    VCDuplicationHandler_EnableDuplication(a1);
    *a4 = 1;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v16 = VRTraceErrorLogLevelToCSTR();
      uint64_t v17 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v21 = 136315650;
        uint64_t v22 = v16;
        __int16 v23 = 2080;
        uint64_t v24 = "_VCDuplicationHandler_UpdateDuplicationStateForRemoteDuplicationChanged";
        __int16 v25 = 1024;
        int v26 = 403;
        uint64_t v18 = " [%s] %s:%d HandoverReport: start dupe by remote duplication.";
LABEL_29:
        _os_log_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEFAULT, v18, (uint8_t *)&v21, 0x1Cu);
      }
    }
  }
LABEL_3:
  unsigned int v8 = a1[9];
  BOOL v9 = v8 > 6;
  int v10 = (1 << v8) & 0x46;
  if (!v9 && v10 != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v12 = VRTraceErrorLogLevelToCSTR();
    int v13 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v14 = "WiFi";
      int v21 = 136315906;
      uint64_t v22 = v12;
      __int16 v23 = 2080;
      uint64_t v24 = "_VCDuplicationHandler_UpdateDuplicationStateForRemoteDuplicationChanged";
      if ((a2 & 0x10000000000) == 0) {
        unsigned int v14 = "Cellular";
      }
      __int16 v25 = 1024;
      int v26 = 425;
      __int16 v27 = 2080;
      __int16 v28 = v14;
      _os_log_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: remote duplication suggests %s during other type of duplication.", (uint8_t *)&v21, 0x26u);
    }
  }
}

void VCDuplicationHandler_EnableDuplication(unsigned char *a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a1[21])
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v1 = VRTraceErrorLogLevelToCSTR();
        int v2 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v8 = 136315650;
          uint64_t v9 = v1;
          __int16 v10 = 2080;
          int v11 = "VCDuplicationHandler_EnableDuplication";
          __int16 v12 = 1024;
          int v13 = 112;
          unint64_t v3 = " [%s] %s:%d HandoverReport: Duplication is forcibly disabled using user defaults";
LABEL_15:
          _os_log_impl(&dword_1E1EA4000, v2, OS_LOG_TYPE_DEFAULT, v3, (uint8_t *)&v8, 0x1Cu);
        }
      }
    }
    else if (a1[20])
    {
      if (a1[14] || a1[18])
      {
        a1[8] = 1;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v4 = VRTraceErrorLogLevelToCSTR();
          int v2 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            int v8 = 136315650;
            uint64_t v9 = v4;
            __int16 v10 = 2080;
            int v11 = "VCDuplicationHandler_EnableDuplication";
            __int16 v12 = 1024;
            int v13 = 121;
            unint64_t v3 = " [%s] %s:%d HandoverReport: Duplication state changed to PENDING";
            goto LABEL_15;
          }
        }
      }
      else
      {
        a1[8] = 2;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v6 = VRTraceErrorLogLevelToCSTR();
          int v2 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            int v8 = 136315650;
            uint64_t v9 = v6;
            __int16 v10 = 2080;
            int v11 = "VCDuplicationHandler_EnableDuplication";
            __int16 v12 = 1024;
            int v13 = 124;
            unint64_t v3 = " [%s] %s:%d HandoverReport: Duplication state changed to ON";
            goto LABEL_15;
          }
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      int v2 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v8 = 136315650;
        uint64_t v9 = v5;
        __int16 v10 = 2080;
        int v11 = "VCDuplicationHandler_EnableDuplication";
        __int16 v12 = 1024;
        int v13 = 116;
        unint64_t v3 = " [%s] %s:%d HandoverReport: Duplication cannot be enabled due to WiFi off-channel activity";
        goto LABEL_15;
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    uint64_t v7 = VRTraceErrorLogLevelToCSTR();
    int v2 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 136315650;
      uint64_t v9 = v7;
      __int16 v10 = 2080;
      int v11 = "VCDuplicationHandler_EnableDuplication";
      __int16 v12 = 1024;
      int v13 = 110;
      unint64_t v3 = " [%s] %s:%d nil instance passed";
      goto LABEL_15;
    }
  }
}

void VCDuplicationHandler_DisableDuplication(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(unsigned char *)(a1 + 8) = 0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v1 = VRTraceErrorLogLevelToCSTR();
      int v2 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v3 = 136315650;
        uint64_t v4 = v1;
        __int16 v5 = 2080;
        uint64_t v6 = "VCDuplicationHandler_DisableDuplication";
        __int16 v7 = 1024;
        int v8 = 133;
        _os_log_impl(&dword_1E1EA4000, v2, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: Duplication state changed to OFF", (uint8_t *)&v3, 0x1Cu);
      }
    }
  }
}

uint64_t VCDuplicationHandler_DuplicationReason(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return *(unsigned __int8 *)(a1 + 9);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    uint64_t v2 = VRTraceErrorLogLevelToCSTR();
    int v3 = *MEMORY[0x1E4F47A50];
    BOOL v4 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v4) {
      return result;
    }
    int v5 = 136315650;
    uint64_t v6 = v2;
    __int16 v7 = 2080;
    int v8 = "VCDuplicationHandler_DuplicationReason";
    __int16 v9 = 1024;
    int v10 = 451;
    _os_log_impl(&dword_1E1EA4000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v5, 0x1Cu);
  }
  return 0;
}

uint64_t VCDuplicationHandler_DuplicationReasonForReporting(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (*(unsigned char *)(a1 + 9) != 3 || *(unsigned char *)(a1 + 19) == 0) {
      return *(unsigned __int8 *)(a1 + 9);
    }
    else {
      return 8;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v3 = VRTraceErrorLogLevelToCSTR();
      BOOL v4 = *MEMORY[0x1E4F47A50];
      BOOL v5 = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (!v5) {
        return result;
      }
      int v6 = 136315650;
      uint64_t v7 = v3;
      __int16 v8 = 2080;
      __int16 v9 = "VCDuplicationHandler_DuplicationReasonForReporting";
      __int16 v10 = 1024;
      int v11 = 459;
      _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v6, 0x1Cu);
    }
    return 0;
  }
}

void _VCDuplicationHandler_ShareLocalInterfacePreferenceWithPeerDuringActiveDuplicationForEvent(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = a1[9];
  BOOL v5 = v4 > 6;
  int v6 = (1 << v4) & 0x46;
  if (!v5 && v6 != 0)
  {
    VCDuplicationHandler_EnableDuplication(a1);
    *(unsigned char *)(a4 + 1) = 1;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v10 = VRTraceErrorLogLevelToCSTR();
      int v11 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = "WiFi";
        int v13 = 136315906;
        uint64_t v14 = v10;
        __int16 v15 = 2080;
        uint64_t v16 = "_VCDuplicationHandler_ShareLocalInterfacePreferenceWithPeerDuringActiveDuplicationForEvent";
        if ((a2 & 0x100000000) == 0) {
          uint64_t v12 = "Cellular";
        }
        __int16 v17 = 1024;
        int v18 = 436;
        __int16 v19 = 2080;
        uint64_t v20 = v12;
        _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: local media degraded suggests %s during other type of duplication.", (uint8_t *)&v13, 0x26u);
      }
    }
  }
}

void _VCDuplicationHandler_StopRemoteDuplicationAndUpdateResult(unsigned char *a1, _WORD *a2, int a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  int v5 = a1[9];
  switch(v5)
  {
    case 7:
      a1[9] = 6;
      VCDuplicationHandler_EnableDuplication(a1);
      *a2 = 0;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v10 = VRTraceErrorLogLevelToCSTR();
        __int16 v8 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v12 = 136315650;
          uint64_t v13 = v10;
          __int16 v14 = 2080;
          __int16 v15 = "_VCDuplicationHandler_StopRemoteDuplicationAndUpdateResult";
          __int16 v16 = 1024;
          int v17 = 255;
          __int16 v9 = " [%s] %s:%d HandoverReport: stop dupe by remote duplication but remain dupe by local media health unrecoverable.";
          goto LABEL_19;
        }
      }
      break;
    case 5:
      a1[9] = 3;
      if (a3 && a1[22])
      {
        a1[15] = 0;
        *(unsigned char *)a2 = _VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo(a1, 0);
      }
      VCDuplicationHandler_EnableDuplication(a1);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v11 = VRTraceErrorLogLevelToCSTR();
        __int16 v8 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v12 = 136315650;
          uint64_t v13 = v11;
          __int16 v14 = 2080;
          __int16 v15 = "_VCDuplicationHandler_StopRemoteDuplicationAndUpdateResult";
          __int16 v16 = 1024;
          int v17 = 248;
          __int16 v9 = " [%s] %s:%d HandoverReport: stop dupe by remote duplication but remain dupe by local media degraded.";
          goto LABEL_19;
        }
      }
      break;
    case 4:
      a1[9] = 0;
      *a2 = 1;
      VCDuplicationHandler_DisableDuplication((uint64_t)a1);
      if (a3 && a1[22])
      {
        a1[15] = 0;
        _VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo(a1, 0);
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v7 = VRTraceErrorLogLevelToCSTR();
        __int16 v8 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v12 = 136315650;
          uint64_t v13 = v7;
          __int16 v14 = 2080;
          __int16 v15 = "_VCDuplicationHandler_StopRemoteDuplicationAndUpdateResult";
          __int16 v16 = 1024;
          int v17 = 239;
          __int16 v9 = " [%s] %s:%d HandoverReport: stop dupe by remote duplication.";
LABEL_19:
          _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v12, 0x1Cu);
        }
      }
      break;
  }
}

uint64_t _VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo(unsigned char *a1, int a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = 15;
  if (a2) {
    uint64_t v3 = 11;
  }
  unsigned int v4 = &a1[v3];
  if (!a1[v3] || v4[1] && v4[2])
  {
    if (v4[3])
    {
      uint64_t v5 = 0;
      v4[3] = 0;
      if (a1[8] == 1)
      {
        VCDuplicationHandler_EnableDuplication(a1);
        if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
          goto LABEL_17;
        }
        uint64_t v6 = VRTraceErrorLogLevelToCSTR();
        uint64_t v7 = *MEMORY[0x1E4F47A50];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_17;
        }
        int v17 = 136315650;
        uint64_t v18 = v6;
        __int16 v19 = 2080;
        uint64_t v20 = "_VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo";
        __int16 v21 = 1024;
        int v22 = 344;
        __int16 v8 = " [%s] %s:%d HandoverReport: Enable duplication if it is pending, due to interface alert update";
        goto LABEL_16;
      }
      goto LABEL_19;
    }
LABEL_18:
    uint64_t v5 = 0;
    goto LABEL_19;
  }
  if (v4[3]) {
    goto LABEL_18;
  }
  uint64_t v5 = 1;
  v4[3] = 1;
  if (a1[8] != 2) {
    goto LABEL_18;
  }
  a1[8] = 1;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v9 = VRTraceErrorLogLevelToCSTR();
    uint64_t v7 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
LABEL_17:
      uint64_t v5 = 1;
      goto LABEL_19;
    }
    int v17 = 136315650;
    uint64_t v18 = v9;
    __int16 v19 = 2080;
    uint64_t v20 = "_VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo";
    __int16 v21 = 1024;
    int v22 = 336;
    __int16 v8 = " [%s] %s:%d HandoverReport: Make duplication pending due to interface alert update";
LABEL_16:
    _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v17, 0x1Cu);
    goto LABEL_17;
  }
LABEL_19:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v10 = VRTraceErrorLogLevelToCSTR();
    uint64_t v11 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v12 = *v4;
      int v13 = v4[1];
      int v14 = v4[2];
      int v15 = v4[3];
      int v17 = 136316930;
      uint64_t v18 = v10;
      __int16 v19 = 2080;
      uint64_t v20 = "_VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo";
      __int16 v21 = 1024;
      int v22 = 348;
      __int16 v23 = 1024;
      int v24 = a2;
      __int16 v25 = 1024;
      int v26 = v12;
      __int16 v27 = 1024;
      int v28 = v13;
      __int16 v29 = 1024;
      int v30 = v14;
      __int16 v31 = 1024;
      int v32 = v15;
      _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: updateDuplicationStateWithAlertInfo - isOnLocal: %d isAlertEnabled: %d connectionWiFiCount: %d connectionCellCount: %d isDuplicationDisabledDueToAlert: %d", (uint8_t *)&v17, 0x3Au);
    }
  }
  return v5;
}

void statsReceiveProc(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    bzero(v4, 0x628uLL);
    if (([*(id *)(a1 + 88) receivePacket:v4] & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          statsReceiveProc_cold_2();
        }
      }
      double v2 = *(double *)(a1 + 216);
      double v3 = micro();
      if (v2 == 0.0)
      {
        *(double *)(a1 + 216) = v3;
      }
      else if (v3 - *(double *)(a1 + 216) >= 5.0)
      {
        [(id)a1 reportingAgent];
        reportingSymptom();
      }
      usleep(0x2710u);
    }
    else
    {
      _VCSessionStatsController_HandleRemoteSessionStats(a1, v4);
      *(void *)(a1 + 216) = 0;
    }
    _VCSessionStatsController_HealthPrintForServerStats(a1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      statsReceiveProc_cold_1();
    }
  }
}

void _VCSessionStatsController_TriggerRateControl(uint64_t a1, uint64_t a2, int a3, char a4, double a5, double a6, double a7)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  LODWORD(a6) = *(_DWORD *)(a1 + 144);
  LODWORD(a7) = *(_DWORD *)(a1 + 148);
  int v9 = (int)((double)*(unint64_t *)&a6 + 45.5);
  int v10 = (int)((double)*(unint64_t *)&a7 + 45.5);
  long long v15 = 0u;
  uint64_t v26 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  v14[0] = 5;
  *(double *)&v14[1] = a5;
  BYTE2(v15) = a4;
  BYTE8(v15) = *(unsigned char *)(a2 + 8);
  HIDWORD(v15) = v9;
  AVCStatisticsCollector_SetVCStatistics(*(void *)(a1 + 16), (uint64_t)v14);
  *(_DWORD *)(a1 + 144) = v9;
  ++*(_DWORD *)(a1 + 248);
  if (a3)
  {
    HIDWORD(v15) = v10;
    AVCStatisticsCollector_SetVCStatistics(*(void *)(a1 + 24), (uint64_t)v14);
    *(_DWORD *)(a1 + 148) = v10;
    ++*(_DWORD *)(a1 + 252);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v11 = VRTraceErrorLogLevelToCSTR();
    int v12 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316674;
      int v13 = "NO";
      uint64_t v28 = v11;
      __int16 v29 = 2080;
      int v30 = "_VCSessionStatsController_TriggerRateControl";
      __int16 v31 = 1024;
      if (a3) {
        int v13 = "YES";
      }
      int v32 = 330;
      __int16 v33 = 1024;
      int v34 = v9;
      __int16 v35 = 1024;
      int v36 = v10;
      __int16 v37 = 2080;
      uint64_t v38 = "YES";
      __int16 v39 = 2080;
      char v40 = v13;
      _os_log_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Trigger rate control without serverStats response with uplinkSendTimestamp:0x%04X, downlinkSendTimestamp:0x%04X [uplink:%s, downlink:%s]", buf, 0x3Cu);
    }
  }
}

void _VCSessionStatsController_UpdateRemoteSessionStats(uint64_t a1, uint64_t a2)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  double v4 = micro();
  int v5 = *(unsigned __int16 *)(a2 + 10);
  double v6 = *(double *)a2;
  unsigned int v7 = (unsigned __int16)(*(_WORD *)(a1 + 72) - v5);
  if (v4 - *(double *)a2 > 10.0 || v7 >= 0x80)
  {
    ++*(_DWORD *)(a1 + 240);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v30 = VRTraceErrorLogLevelToCSTR();
      __int16 v31 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v32 = *(_DWORD *)(a1 + 72);
        *(_DWORD *)buf = 136316930;
        *(void *)&uint8_t buf[4] = v30;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "_VCSessionStatsController_IsRemoteSessionStatsTooLate";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&uint8_t buf[24] = 297;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v5;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v32;
        *(_WORD *)&unsigned char buf[40] = 1024;
        *(_DWORD *)&buf[42] = v7;
        *(_WORD *)&buf[46] = 2048;
        *(double *)&uint8_t buf[48] = v4;
        *(_WORD *)&buf[56] = 2048;
        *(double *)&buf[58] = v6;
        _os_log_impl(&dword_1E1EA4000, v31, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Dropping late server stats with Id=%u, currentId=%u, diff=%u, now=%f, responseTime=%f", buf, 0x42u);
      }
    }
  }
  else
  {
    int v8 = v5 & 0x7F;
    double v44 = 0.0;
    uint64_t v45 = 0;
    uint64_t v46 = 0;
    objc_msgSend((id)objc_msgSend(*(id *)(a1 + 80), "statsRecorder"), "getLocalStats:localSessionStats:", v5 & 0x7F, &v44);
    double v9 = *(double *)a2 - v44;
    if (v9 > 10.0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v10 = VRTraceErrorLogLevelToCSTR();
      uint64_t v11 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = v10;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "_VCSessionStatsController_UpdateRemoteSessionStats";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&uint8_t buf[24] = 216;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = (v9 * 1000.0);
        _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Round trip time is greater than 10 seconds [RTT:%dms]", buf, 0x22u);
      }
    }
    double v12 = v4 - *(double *)a2;
    if (v12 > 1.0 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v13 = VRTraceErrorLogLevelToCSTR();
      int v14 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = v13;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "_VCSessionStatsController_UpdateRemoteSessionStats";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&uint8_t buf[24] = 220;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = (v12 * 1000.0);
        _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Local VTP queue time is greater than 1 seconds [qTime:%dms]", buf, 0x22u);
      }
    }
    ++*(_DWORD *)(a1 + 244);
    double v15 = *(double *)(a1 + 280);
    if (v15 < v12) {
      double v15 = v12;
    }
    *(double *)(a1 + 272) = v12 + *(double *)(a1 + 272);
    *(double *)(a1 + 280) = v15;
    int v16 = v45;
    uint64_t v17 = *(unsigned __int8 *)(a2 + 8);
    int v18 = [*(id *)(a1 + 80) getByteCountWithIndex:v45 isOutgoing:1];
    memset(buf, 0, sizeof(buf));
    uint64_t v65 = 0;
    long long v63 = 0u;
    long long v64 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    long long v58 = 0u;
    *(_DWORD *)buf = 5;
    *(void *)&buf[8] = *(void *)a2;
    buf[18] = 1;
    uint8_t buf[24] = v16;
    int v19 = [(id)a1 translateTimestampFromMicro:v44];
    int v20 = *(unsigned __int16 *)(a2 + 12) - *(unsigned __int16 *)(a2 + 14);
    *(_DWORD *)&buf[28] = v19;
    *(_DWORD *)&unsigned char buf[32] = v20;
    unsigned int v21 = *(unsigned __int16 *)(a2 + 20);
    int v22 = *(_DWORD *)(a1 + 140);
    BOOL v23 = (unsigned __int16)(v21 - v22) >= 0x7FFFu || v21 >= (unsigned __int16)*(_DWORD *)(a1 + 140);
    unsigned int v24 = v22 & 0xFFFF0000 | v21;
    if (v23) {
      int v25 = 0;
    }
    else {
      int v25 = 0x10000;
    }
    int v26 = HIDWORD(v46);
    *(_DWORD *)&buf[36] = HIDWORD(v45);
    *(_DWORD *)&unsigned char buf[40] = v25 + v24;
    *(_DWORD *)(a1 + 140) = v25 + v24;
    *(_DWORD *)&buf[56] = *(unsigned __int16 *)(a2 + 16);
    *(double *)&uint8_t buf[64] = v9;
    *(_DWORD *)&unsigned char buf[44] = v18;
    *(_DWORD *)&buf[52] = v26;
    *(_DWORD *)(a1 + 112) = v26;
    *(_DWORD *)(a1 + 144) = v19;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v27 = VRTraceErrorLogLevelToCSTR();
      uint64_t v28 = *MEMORY[0x1E4F47A50];
      __int16 v29 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t v47 = 136316930;
          *(void *)&v47[4] = v27;
          *(_WORD *)&v47[12] = 2080;
          *(void *)&v47[14] = "_VCSessionStatsController_UpdateRemoteSessionStats";
          *(_WORD *)&v47[22] = 1024;
          *(_DWORD *)&v47[24] = 252;
          *(_WORD *)&v47[28] = 1024;
          *(_DWORD *)&v47[30] = v8;
          *(_WORD *)&v47[34] = 1024;
          *(_DWORD *)&v47[36] = v16;
          *(_WORD *)&v47[40] = 2048;
          *(double *)&v47[42] = v44;
          *(_WORD *)&v47[50] = 1024;
          *(_DWORD *)&v47[52] = HIDWORD(v45);
          *(_WORD *)&v47[56] = 1024;
          *(_DWORD *)&v47[58] = HIDWORD(v46);
          _os_log_impl(&dword_1E1EA4000, v28, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d index = %d, sessionStatsLocal: uplinkID = %d, request CMTime time = %f, totalLocalMediaPacketSent = %d, totalServerStatsByteUsed = %d", v47, 0x3Eu);
        }
      }
      else if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)uint64_t v47 = 136316930;
        *(void *)&v47[4] = v27;
        *(_WORD *)&v47[12] = 2080;
        *(void *)&v47[14] = "_VCSessionStatsController_UpdateRemoteSessionStats";
        *(_WORD *)&v47[22] = 1024;
        *(_DWORD *)&v47[24] = 252;
        *(_WORD *)&v47[28] = 1024;
        *(_DWORD *)&v47[30] = v8;
        *(_WORD *)&v47[34] = 1024;
        *(_DWORD *)&v47[36] = v16;
        *(_WORD *)&v47[40] = 2048;
        *(double *)&v47[42] = v44;
        *(_WORD *)&v47[50] = 1024;
        *(_DWORD *)&v47[52] = HIDWORD(v45);
        *(_WORD *)&v47[56] = 1024;
        *(_DWORD *)&v47[58] = HIDWORD(v46);
        _os_log_debug_impl(&dword_1E1EA4000, v28, OS_LOG_TYPE_DEBUG, " [%s] %s:%d index = %d, sessionStatsLocal: uplinkID = %d, request CMTime time = %f, totalLocalMediaPacketSent = %d, totalServerStatsByteUsed = %d", v47, 0x3Eu);
      }
    }
    AVCStatisticsCollector_SetVCStatistics(*(void *)(a1 + 16), (uint64_t)buf);
    __int16 v33 = (const void *)VCConnectionManager_CopyConnectionForQuality(*(void *)(a1 + 80), 1);
    int v34 = [*(id *)(a1 + 80) getPacketCountWithIndex:v17 isOutgoing:0];
    int v35 = [*(id *)(a1 + 80) getByteCountWithIndex:v17 isOutgoing:0];
    *(_DWORD *)(a1 + 116) += objc_msgSend((id)objc_msgSend(*(id *)(a1 + 80), "statsRecorder"), "serverStatsSizeInByteForUplink:connection:", 0, v33);
    if (v33) {
      CFRelease(v33);
    }
    memset(v47, 0, sizeof(v47));
    uint64_t v56 = 0;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v48 = 0u;
    *(_DWORD *)uint64_t v47 = 5;
    *(void *)&v47[8] = *(void *)a2;
    v47[18] = 1;
    v47[24] = v17;
    int v36 = *(unsigned __int16 *)(a2 + 12);
    *(_DWORD *)&v47[28] = v36;
    int v37 = objc_msgSend((id)a1, "translateTimestampFromMicro:");
    unsigned int v38 = *(unsigned __int16 *)(a2 + 18);
    int v39 = *(_DWORD *)(a1 + 136);
    BOOL v40 = (unsigned __int16)(v38 - v39) >= 0x7FFFu || v38 >= (unsigned __int16)*(_DWORD *)(a1 + 136);
    unsigned int v41 = v39 & 0xFFFF0000 | v38;
    if (v40) {
      int v42 = 0;
    }
    else {
      int v42 = 0x10000;
    }
    *(_DWORD *)&v47[32] = v37;
    *(_DWORD *)&v47[36] = v42 + v41;
    *(_DWORD *)(a1 + 136) = v42 + v41;
    *(_DWORD *)&v47[40] = v34;
    *(double *)&long long v48 = v9;
    int v43 = *(_DWORD *)(a1 + 116);
    *(_DWORD *)&v47[48] = v35;
    *(_DWORD *)&v47[52] = v43;
    *(_DWORD *)(a1 + 148) = v36;
    AVCStatisticsCollector_SetVCStatistics(*(void *)(a1 + 24), (uint64_t)v47);
    *(void *)(a1 + 96) = *(void *)a2;
    *(unsigned char *)(a1 + 152) = 1;
  }
}

void _VCSessionStatsController_HandleRemoteSessionStats(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    double v4 = *((double *)a2 + 1);
    *(double *)(a1 + 256) = (v4 - *(double *)(a1 + 264)) * 0.1 + *(double *)(a1 + 256) * 0.9;
    *(double *)(a1 + 264) = v4;
    if (!a2[1538])
    {
      ++*(_DWORD *)(a1 + 224);
      double v16 = *((double *)a2 + 1);
      uint64_t v17 = VCConnectionManager_CopyPrimaryConnection(*(void *)(a1 + 80));
      int v18 = (const void *)v17;
      if (*(unsigned char *)(a1 + 152) && v17)
      {
        if (v16 - *(double *)(a1 + 96) > 0.455 && *(double *)(a1 + 256) < 0.25)
        {
          *(void *)&buf[16] = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)buf = xmmword_1E25A1FE8;
          int v19 = (void *)[*(id *)(a1 + 80) statsRecorder];
          if (v19) {
            [v19 getMostRecentLocalStats];
          }
          else {
            memset(buf, 0, sizeof(buf));
          }
          long long v31 = *(_OWORD *)buf;
          uint64_t v32 = *(void *)&buf[16];
          _VCSessionStatsController_TriggerRateControl(a1, (uint64_t)&v31, 0, 1, v16, v20, v21);
          *(double *)(a1 + 96) = v16;
        }
      }
      else if (!v17)
      {
        return;
      }
      CFRelease(v18);
      return;
    }
    ++*(_DWORD *)(a1 + 228);
    int v5 = (const void *)VCConnectionManager_CopyConnectionForQuality(*(void *)(a1 + 80), 1);
    int v6 = VCConnectionIDS_LinkID((uint64_t)v5);
    if (v5) {
      CFRelease(v5);
    }
    if (*a2 == v6)
    {
      int v7 = *((unsigned __int16 *)a2 + 770);
      if (v7 == *(unsigned __int16 *)(a1 + 130))
      {
        ++*(_DWORD *)(a1 + 232);
        if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
          return;
        }
        int v8 = (unsigned __int16 *)(a2 + 1540);
        uint64_t v9 = VRTraceErrorLogLevelToCSTR();
        uint64_t v10 = *MEMORY[0x1E4F47A50];
        uint64_t v11 = *MEMORY[0x1E4F47A50];
        if (*MEMORY[0x1E4F47A40])
        {
          if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          int v12 = *v8;
          *(_DWORD *)buf = 136315906;
          *(void *)&uint8_t buf[4] = v9;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "_VCSessionStatsController_HandleRemoteSessionStats";
          *(_WORD *)&buf[22] = 1024;
          int v34 = 418;
          __int16 v35 = 1024;
          int v36 = v12;
          uint64_t v13 = " [%s] %s:%d statsID is same as the previous one %u";
          int v14 = v10;
          uint32_t v15 = 34;
LABEL_24:
          _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
          return;
        }
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
          _VCSessionStatsController_HandleRemoteSessionStats_cold_2(v9, v8, v10);
        }
      }
      else
      {
        uint64_t v26 = *((void *)a2 + 1);
        *(_WORD *)(a1 + 130) = v7;
        int v27 = *((_DWORD *)a2 + 385);
        *(void *)buf = v26;
        buf[8] = v6;
        buf[9] = 0;
        *(_DWORD *)&buf[10] = v27;
        *(int16x4_t *)&buf[14] = vtrn1_s16(*(int16x4_t *)(a2 + 1544), (int16x4_t)vext_s8(*(int8x8_t *)(a2 + 1544), *(int8x8_t *)(a2 + 1544), 6uLL));
        *(_WORD *)&buf[22] = 0;
        _VCSessionStatsController_UpdateRemoteSessionStats(a1, (uint64_t)buf);
        if (*(unsigned char *)(a1 + 153))
        {
          double v28 = *((double *)a2 + 1);
          if (v28 - *(double *)(a1 + 168) > *(double *)(a1 + 160))
          {
            __int16 v29 = (void *)MEMORY[0x1E4E56580](a1 + 8);
            [v29 didReceivedSessionStatsAtTime:v28];
            if (v29) {
              CFRelease(v29);
            }
            *(double *)(a1 + 168) = v28;
          }
        }
      }
    }
    else
    {
      ++*(_DWORD *)(a1 + 236);
      if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
        return;
      }
      uint64_t v22 = VRTraceErrorLogLevelToCSTR();
      BOOL v23 = *MEMORY[0x1E4F47A50];
      unsigned int v24 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v25 = *a2;
        *(_DWORD *)buf = 136316162;
        *(void *)&uint8_t buf[4] = v22;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "_VCSessionStatsController_HandleRemoteSessionStats";
        *(_WORD *)&buf[22] = 1024;
        int v34 = 408;
        __int16 v35 = 1024;
        int v36 = v25;
        __int16 v37 = 1024;
        int v38 = v6;
        uint64_t v13 = " [%s] %s:%d Do not update session stats since linkID does not match %d, %d";
        int v14 = v23;
        uint32_t v15 = 40;
        goto LABEL_24;
      }
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        int v30 = *a2;
        *(_DWORD *)buf = 136316162;
        *(void *)&uint8_t buf[4] = v22;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "_VCSessionStatsController_HandleRemoteSessionStats";
        *(_WORD *)&buf[22] = 1024;
        int v34 = 408;
        __int16 v35 = 1024;
        int v36 = v30;
        __int16 v37 = 1024;
        int v38 = v6;
        _os_log_debug_impl(&dword_1E1EA4000, v23, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Do not update session stats since linkID does not match %d, %d", buf, 0x28u);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCSessionStatsController_HandleRemoteSessionStats_cold_1();
    }
  }
}

double _VCSessionStatsController_HealthPrintForServerStats(uint64_t a1)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  double result = micro();
  if (result - *(double *)(a1 + 288) > 5.0)
  {
    *(double *)(a1 + 288) = result;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      uint64_t v3 = VRTraceErrorLogLevelToCSTR();
      double v4 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v5 = *(_DWORD *)(a1 + 72);
        int v6 = *(_DWORD *)(a1 + 228);
        int v7 = *(_DWORD *)(a1 + 224) + v6;
        uint64_t v8 = *(void *)(a1 + 256);
        int v9 = *(_DWORD *)(a1 + 232);
        int v10 = *(_DWORD *)(a1 + 236);
        int v11 = *(_DWORD *)(a1 + 240);
        unsigned int v12 = *(_DWORD *)(a1 + 244);
        int v14 = *(_DWORD *)(a1 + 248);
        int v13 = *(_DWORD *)(a1 + 252);
        if (v12) {
          double v15 = *(double *)(a1 + 272) * 1000.0 / (double)v12;
        }
        else {
          double v15 = 0.0;
        }
        double v16 = *(double *)(a1 + 280) * 1000.0;
        int v17 = 136318722;
        uint64_t v18 = v3;
        __int16 v19 = 2080;
        double v20 = "_VCSessionStatsController_HealthPrintForServerStats";
        __int16 v21 = 1024;
        int v22 = 455;
        __int16 v23 = 1024;
        int v24 = v5;
        __int16 v25 = 1024;
        int v26 = v6;
        __int16 v27 = 1024;
        int v28 = v7;
        __int16 v29 = 2048;
        uint64_t v30 = v8;
        __int16 v31 = 1024;
        unsigned int v32 = v12;
        __int16 v33 = 1024;
        int v34 = v10;
        __int16 v35 = 1024;
        int v36 = v9;
        __int16 v37 = 1024;
        int v38 = v11;
        __int16 v39 = 1024;
        int v40 = v14;
        __int16 v41 = 1024;
        int v42 = v13;
        __int16 v43 = 2048;
        double v44 = v15;
        __int16 v45 = 2048;
        double v46 = v16;
        _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d @=@ Health: VCSessionStatsController Health Monitor for serverStats: total stats request count:%u, total response count:%u, total callback count:%u, avgInterCallbackDuration:%.3f [this interval processed:%u, dropped:%u,%u,%u, triggered:%u,%u, average queue time:%.2fms, max queue time:%.2fms]", (uint8_t *)&v17, 0x70u);
      }
    }
    double result = 0.0;
    *(void *)(a1 + 244) = 0;
    *(_DWORD *)(a1 + 252) = 0;
    *(void *)(a1 + 232) = 0;
    *(void *)(a1 + 272) = 0;
    *(void *)(a1 + 280) = 0;
  }
  return result;
}

uint64_t readSPSAndGetDecoderParams(unsigned int *BytePtr, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9, _DWORD *a10)
{
  int v10 = a8;
  int v11 = a7;
  unsigned int v12 = a6;
  int v13 = a5;
  int Length = a2;
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v61 = v16;
  long long v62 = v16;
  uint64_t v17 = a2;
  unint64_t v18 = a2 - 3;
  if (a2 == 3) {
    goto LABEL_16;
  }
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  CFMutableArrayRef Mutable = 0;
  int v23 = 0;
  while (1)
  {
    if (*((unsigned char *)BytePtr + v21) || *(_WORD *)((char *)BytePtr + v21 + 1) != 768) {
      goto LABEL_9;
    }
    if (!v23) {
      break;
    }
LABEL_8:
    CFIndex v24 = v21 + 2 - v20;
    __int16 v25 = (const UInt8 *)BytePtr + v20;
    int v26 = Mutable;
    CFDataAppendBytes(Mutable, v25, v24);
    CFMutableArrayRef Mutable = v26;
    uint64_t v20 = v21 + 3;
    v21 += 2;
LABEL_9:
    if (++v21 >= v18)
    {
      if (v23 && v17 != v20)
      {
        __int16 v27 = Mutable;
        CFDataAppendBytes(Mutable, (const UInt8 *)BytePtr + v20, v17 - v20);
        CFMutableArrayRef Mutable = v27;
      }
      int v10 = a8;
      unsigned int v12 = a6;
      int v11 = a7;
      int v13 = a5;
      if (Mutable)
      {
        CFDataRef v28 = Mutable;
        BytePtr = (unsigned int *)CFDataGetBytePtr(Mutable);
        *(void *)&long long v61 = BytePtr;
        CFDataRef v29 = v28;
        char v60 = 0;
        int Length = CFDataGetLength(v28);
        goto LABEL_17;
      }
      goto LABEL_16;
    }
  }
  CFMutableArrayRef Mutable = CFDataCreateMutable(0, v17 - 1);
  if (Mutable)
  {
    int v23 = 1;
    goto LABEL_8;
  }
  uint64_t v30 = FigSignalErrorAt3();
  int v10 = a8;
  unsigned int v12 = a6;
  int v11 = a7;
  int v13 = a5;
  if (v30) {
    return v30;
  }
LABEL_16:
  CFDataRef v29 = 0;
  *(void *)&long long v61 = BytePtr;
  char v60 = 1;
LABEL_17:
  DWORD2(v61) = Length;
  memset(__b, 170, sizeof(__b));
  *(void *)&long long v62 = BytePtr;
  DWORD2(v62) = bswap32(*BytePtr);
  BYTE12(v62) = 0;
  bzero(__b, 0x79CuLL);
  int v31 = h264bridge_u_pull((uint64_t)&v61, 1u);
  int v32 = h264bridge_u_pull((uint64_t)&v61, 2u);
  int v33 = h264bridge_u_pull((uint64_t)&v61, 5u);
  if (v31 || v32 <= 0 || v33 != 7) {
    goto LABEL_106;
  }
  __b[0] = h264bridge_u_pull((uint64_t)&v61, 8u);
  __b[2] = h264bridge_u_pull((uint64_t)&v61, 1u);
  __b[3] = h264bridge_u_pull((uint64_t)&v61, 1u);
  __b[4] = h264bridge_u_pull((uint64_t)&v61, 1u);
  __b[5] = h264bridge_u_pull((uint64_t)&v61, 1u);
  h264bridge_u_pull((uint64_t)&v61, 4u);
  __b[1] = h264bridge_u_pull((uint64_t)&v61, 8u);
  __b[9] = h264bridge_ue_pull((uint64_t)&v61);
  unsigned int v34 = LOBYTE(__b[0]) - 100;
  if (v34 > 0x2C || ((1 << v34) & 0x100000400401) == 0)
  {
    LOBYTE(__b[10]) = 1;
    goto LABEL_37;
  }
  LOBYTE(__b[10]) = h264bridge_ue_pull((uint64_t)&v61);
  if ((__b[10] & 0xFE) != 0) {
    goto LABEL_106;
  }
  BYTE2(__b[10]) = h264bridge_ue_pull((uint64_t)&v61);
  if (BYTE2(__b[10])) {
    goto LABEL_106;
  }
  HIBYTE(__b[10]) = h264bridge_ue_pull((uint64_t)&v61);
  if (HIBYTE(__b[10])) {
    goto LABEL_106;
  }
  LOBYTE(__b[11]) = h264bridge_u_pull((uint64_t)&v61, 1u);
  if (LOBYTE(__b[11])) {
    goto LABEL_106;
  }
  BYTE1(__b[11]) = h264bridge_u_pull((uint64_t)&v61, 1u);
  if (BYTE1(__b[11]))
  {
    unint64_t v35 = 0;
    uint64_t v36 = 62;
    do
    {
      char v37 = h264bridge_u_pull((uint64_t)&v61, 1u);
      *((unsigned char *)&__b[11] + v35 + 2) = v37;
      if (v37)
      {
        if (v35 > 5)
        {
          uint64_t v41 = (v35 - 6);
          int v38 = (char *)&__b[16 * v41 + 39] + 2;
          __int16 v39 = (BOOL *)&__b[15] + v41;
          unsigned int v40 = 64;
        }
        else
        {
          if (SDWORD2(v61) < (int)v62 - (int)v61) {
            goto LABEL_106;
          }
          int v38 = (char *)__b + v36;
          __int16 v39 = (BOOL *)&__b[13] + v35 + 2;
          unsigned int v40 = 16;
        }
        scaling_list((uint64_t)&v61, (uint64_t)v38, v40, v39);
      }
      ++v35;
      v36 += 16;
    }
    while (v35 != 8);
  }
LABEL_37:
  if (__b[9] >= 32) {
    goto LABEL_106;
  }
  __b[74] = h264bridge_ue_pull((uint64_t)&v61);
  int v42 = h264bridge_ue_pull((uint64_t)&v61);
  _OWORD __b[75] = v42;
  if (v42 != 1)
  {
    if (!v42)
    {
      __b[76] = h264bridge_ue_pull((uint64_t)&v61);
      __b[485] = 1 << (LOBYTE(__b[76]) + 4);
      *(void *)&__b[79] = 0;
      *(void *)&__b[77] = 0;
    }
    goto LABEL_45;
  }
  __b[77] = h264bridge_u_pull((uint64_t)&v61, 1u);
  __b[78] = h264bridge_se_pull((uint64_t)&v61);
  __b[79] = h264bridge_se_pull((uint64_t)&v61);
  int v43 = h264bridge_ue_pull((uint64_t)&v61);
  __b[80] = v43;
  __b[485] = 0;
  if (v43 > 255)
  {
LABEL_106:
    uint64_t v30 = 4294954582;
    FigSignalErrorAt3();
    goto LABEL_89;
  }
  if (v43 >= 1)
  {
    uint64_t v44 = 0;
    do
      __b[v44++ + 81] = h264bridge_se_pull((uint64_t)&v61);
    while (v44 < __b[80]);
  }
LABEL_45:
  __b[336] = h264bridge_ue_pull((uint64_t)&v61);
  __b[337] = h264bridge_u_pull((uint64_t)&v61, 1u);
  __b[338] = h264bridge_ue_pull((uint64_t)&v61);
  __b[339] = h264bridge_ue_pull((uint64_t)&v61);
  __b[340] = h264bridge_u_pull((uint64_t)&v61, 1u);
  if (__b[340]) {
    int v45 = 0;
  }
  else {
    int v45 = h264bridge_u_pull((uint64_t)&v61, 1u);
  }
  __b[341] = v45;
  __b[342] = h264bridge_u_pull((uint64_t)&v61, 1u);
  __b[343] = h264bridge_u_pull((uint64_t)&v61, 1u);
  if (__b[343])
  {
    __b[344] = h264bridge_ue_pull((uint64_t)&v61);
    __b[345] = h264bridge_ue_pull((uint64_t)&v61);
    __b[346] = h264bridge_ue_pull((uint64_t)&v61);
    __b[347] = h264bridge_ue_pull((uint64_t)&v61);
  }
  __b[348] = h264bridge_u_pull((uint64_t)&v61, 1u);
  if (!__b[348])
  {
LABEL_88:
    uint64_t v30 = 0;
    goto LABEL_89;
  }
  if (SDWORD2(v61) < (int)v62 - (int)v61) {
    goto LABEL_106;
  }
  __b[349] = h264bridge_u_pull((uint64_t)&v61, 1u);
  if (__b[349])
  {
    __b[350] = h264bridge_u_pull((uint64_t)&v61, 8u);
    if (__b[350] == 255)
    {
      __b[351] = h264bridge_u_pull((uint64_t)&v61, 0x10u);
      __b[352] = h264bridge_u_pull((uint64_t)&v61, 0x10u);
    }
  }
  if (SDWORD2(v61) < (int)v62 - (int)v61) {
    goto LABEL_106;
  }
  __b[353] = h264bridge_u_pull((uint64_t)&v61, 1u);
  if (__b[353]) {
    __b[354] = h264bridge_u_pull((uint64_t)&v61, 1u);
  }
  __b[355] = h264bridge_u_pull((uint64_t)&v61, 1u);
  if (__b[355])
  {
    __b[356] = h264bridge_u_pull((uint64_t)&v61, 3u);
    __b[357] = h264bridge_u_pull((uint64_t)&v61, 1u);
    __b[358] = h264bridge_u_pull((uint64_t)&v61, 1u);
    if (__b[358])
    {
      __b[359] = h264bridge_u_pull((uint64_t)&v61, 8u);
      __b[360] = h264bridge_u_pull((uint64_t)&v61, 8u);
      __b[361] = h264bridge_u_pull((uint64_t)&v61, 8u);
    }
  }
  if (SDWORD2(v61) < (int)v62 - (int)v61) {
    goto LABEL_106;
  }
  __b[362] = h264bridge_u_pull((uint64_t)&v61, 1u);
  if (__b[362])
  {
    __b[363] = h264bridge_ue_pull((uint64_t)&v61);
    __b[364] = h264bridge_ue_pull((uint64_t)&v61);
  }
  if (SDWORD2(v61) < (int)v62 - (int)v61) {
    goto LABEL_106;
  }
  __b[365] = h264bridge_u_pull((uint64_t)&v61, 1u);
  if (__b[365])
  {
    __b[366] = h264bridge_u_pulllong((uint64_t)&v61);
    __b[367] = h264bridge_u_pulllong((uint64_t)&v61);
    __b[368] = h264bridge_u_pull((uint64_t)&v61, 1u);
  }
  if (SDWORD2(v61) < (int)v62 - (int)v61) {
    goto LABEL_106;
  }
  __b[369] = h264bridge_u_pull((uint64_t)&v61, 1u);
  if (!__b[369]) {
    goto LABEL_75;
  }
  __b[381] = h264bridge_ue_pull((uint64_t)&v61);
  if (__b[381] >= 32) {
    goto LABEL_122;
  }
  __b[382] = h264bridge_u_pull((uint64_t)&v61, 4u);
  __b[383] = h264bridge_u_pull((uint64_t)&v61, 4u);
  if ((__b[381] & 0x80000000) == 0)
  {
    uint64_t v46 = 0;
    do
    {
      uint64_t v47 = &__b[v46];
      v47[384] = h264bridge_ue_pulllong((uint64_t)&v61);
      v47[416] = h264bridge_ue_pulllong((uint64_t)&v61);
      v47[448] = h264bridge_u_pull((uint64_t)&v61, 1u);
      if (SDWORD2(v61) < (int)v62 - (int)v61) {
        goto LABEL_106;
      }
      BOOL v48 = v46++ < __b[381];
    }
    while (v48);
  }
  __b[480] = h264bridge_u_pull((uint64_t)&v61, 5u);
  __b[481] = h264bridge_u_pull((uint64_t)&v61, 5u);
  __b[482] = h264bridge_u_pull((uint64_t)&v61, 5u);
  __b[483] = h264bridge_u_pull((uint64_t)&v61, 5u);
LABEL_75:
  __b[370] = h264bridge_u_pull((uint64_t)&v61, 1u);
  if (!__b[370])
  {
LABEL_82:
    if (SDWORD2(v61) < (int)v62 - (int)v61) {
      goto LABEL_106;
    }
    if (*(void *)&__b[369]) {
      __b[371] = h264bridge_u_pull((uint64_t)&v61, 1u);
    }
    __b[372] = h264bridge_u_pull((uint64_t)&v61, 1u);
    __b[373] = h264bridge_u_pull((uint64_t)&v61, 1u);
    if (__b[373])
    {
      __b[374] = h264bridge_u_pull((uint64_t)&v61, 1u);
      __b[375] = h264bridge_ue_pull((uint64_t)&v61);
      __b[376] = h264bridge_ue_pull((uint64_t)&v61);
      __b[377] = h264bridge_ue_pull((uint64_t)&v61);
      __b[378] = h264bridge_ue_pull((uint64_t)&v61);
      __b[379] = h264bridge_ue_pull((uint64_t)&v61);
      h264bridge_ue_pull((uint64_t)&v61);
    }
    if (SDWORD2(v61) < (int)v62 - (int)v61) {
      goto LABEL_106;
    }
    goto LABEL_88;
  }
  __b[381] = h264bridge_ue_pull((uint64_t)&v61);
  if (__b[381] < 32)
  {
    __b[382] = h264bridge_u_pull((uint64_t)&v61, 4u);
    __b[383] = h264bridge_u_pull((uint64_t)&v61, 4u);
    if ((__b[381] & 0x80000000) == 0)
    {
      uint64_t v49 = 0;
      do
      {
        long long v50 = &__b[v49];
        v50[384] = h264bridge_ue_pulllong((uint64_t)&v61);
        v50[416] = h264bridge_ue_pulllong((uint64_t)&v61);
        v50[448] = h264bridge_u_pull((uint64_t)&v61, 1u);
        if (SDWORD2(v61) < (int)v62 - (int)v61) {
          goto LABEL_106;
        }
        BOOL v48 = v49++ < __b[381];
      }
      while (v48);
    }
    __b[480] = h264bridge_u_pull((uint64_t)&v61, 5u);
    __b[481] = h264bridge_u_pull((uint64_t)&v61, 5u);
    __b[482] = h264bridge_u_pull((uint64_t)&v61, 5u);
    __b[483] = h264bridge_u_pull((uint64_t)&v61, 5u);
    goto LABEL_82;
  }
LABEL_122:
  uint64_t v30 = FigSignalErrorAt3();
LABEL_89:
  if ((v60 & 1) == 0) {
    CFRelease(v29);
  }
  if (!v30)
  {
    *a3 = __b[338] + 1;
    *a4 = __b[339] + 1;
    int v51 = __b[348];
    if (__b[348] && __b[349])
    {
      if (__b[350] == 255)
      {
        *int v13 = __b[351];
        int v52 = __b[352];
        goto LABEL_98;
      }
      if ((__b[350] - 1) <= 0xC)
      {
        long long v53 = (unsigned __int8 *)&kH264SampleAspectRatioIndicators + 2 * __b[350];
        *int v13 = *v53;
        int v52 = v53[1];
LABEL_98:
        *unsigned int v12 = v52;
      }
    }
    if (v51 && __b[358])
    {
      *int v11 = __b[359];
      *int v10 = __b[360];
      *a9 = __b[361];
    }
    uint64_t v30 = 0;
    if (v51 && __b[355])
    {
      uint64_t v30 = 0;
      *a10 = __b[356];
    }
  }
  return v30;
}

uint64_t readAVCCAndGetDecoderParams(uint64_t a1, unint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9, _DWORD *a10)
{
  if (a2 < 7) {
    return 4294954582;
  }
  if ((*(unsigned char *)(a1 + 5) & 0x1F) != 0)
  {
    BOOL v11 = __OFSUB__(a2, 8);
    BOOL v10 = (int)a2 - 8 < 0;
  }
  else
  {
    BOOL v11 = 0;
    BOOL v10 = 1;
  }
  if (v10 != v11) {
    return 4294954582;
  }
  unsigned int v12 = __rev16(*(unsigned __int16 *)(a1 + 6));
  unsigned int v13 = v12 + 8;
  if (v12 >= 2)
  {
    BOOL v14 = v13 >= a2;
    BOOL v15 = v13 == a2;
  }
  else
  {
    BOOL v14 = 1;
    BOOL v15 = 0;
  }
  if (!v15 && v14) {
    return 4294954582;
  }
  else {
    return readSPSAndGetDecoderParams((unsigned int *)(a1 + 8), v12, a3, a4, a5, a6, a7, a8, a9, a10);
  }
}

uint64_t h264bridge_u_pull(uint64_t a1, unsigned int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 28);
  if (32 - v2 < a2)
  {
    FigSignalErrorAt3();
    return 0;
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 16);
    unint64_t v4 = *(void *)a1 + *(unsigned int *)(a1 + 8);
    uint64_t v5 = (*(_DWORD *)(a1 + 24) >> -(char)a2);
    unsigned int v6 = v2 + a2;
    uint64_t v7 = v6 >> 3;
    char v8 = v6 & 7;
    unint64_t v9 = v3 + v7 + 4;
    char v10 = v8 | (8 * (v7 - (v4 - v3 - 4)));
    BOOL v11 = v9 > v4;
    if (v9 > v4) {
      uint64_t v12 = (v4 - v3 - 4);
    }
    else {
      uint64_t v12 = v7;
    }
    if (v11) {
      char v8 = v10;
    }
    unsigned int v13 = *(_DWORD *)(v3 + v12);
    *(void *)(a1 + 16) = v3 + v12;
    *(_DWORD *)(a1 + 24) = bswap32(v13) << v8;
    *(unsigned char *)(a1 + 28) = v8;
  }
  return v5;
}

uint64_t h264bridge_ue_pull(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 24);
  if (v1 < 0x80000)
  {
    FigSignalErrorAt3();
    return 0;
  }
  else
  {
    uint64_t v2 = *(void *)(a1 + 16);
    unint64_t v3 = *(void *)a1 + *(unsigned int *)(a1 + 8);
    unsigned int v4 = __clz(v1);
    unsigned int v5 = v1 << (v4 + 1) >> -(char)v4;
    if (!v4) {
      unsigned int v5 = 0;
    }
    uint64_t v6 = v5 + ~(-1 << v4);
    unsigned int v7 = *(unsigned __int8 *)(a1 + 28) + 2 * v4 + 1;
    uint64_t v8 = v7 >> 3;
    char v9 = v7 & 7;
    unint64_t v10 = v2 + v8 + 4;
    char v11 = v9 | (8 * (v8 - (v3 - v2 - 4)));
    BOOL v12 = v10 > v3;
    if (v10 > v3) {
      uint64_t v13 = (v3 - v2 - 4);
    }
    else {
      uint64_t v13 = v8;
    }
    if (v12) {
      char v9 = v11;
    }
    unsigned int v14 = *(_DWORD *)(v2 + v13);
    *(void *)(a1 + 16) = v2 + v13;
    *(_DWORD *)(a1 + 24) = bswap32(v14) << v9;
    *(unsigned char *)(a1 + 28) = v9;
  }
  return v6;
}

uint64_t scaling_list(uint64_t result, uint64_t a2, unsigned int a3, BOOL *a4)
{
  if (a3)
  {
    uint64_t v6 = result;
    uint64_t v7 = 0;
    int v8 = 8;
    int v9 = 8;
    uint64_t v10 = a3;
    do
    {
      if (!v8
        || ((double result = h264bridge_se_pull(v6), (int)result + v9 + 256 <= 0)
          ? (int v8 = --(char)(result + v9))
          : (int v8 = (result + v9)),
            *a4 = (v8 | v7) == 0,
            unsigned __int8 v11 = v8,
            !v8))
      {
        int v8 = 0;
        unsigned __int8 v11 = v9;
      }
      *(unsigned char *)(a2 + v7) = v11;
      int v9 = v11;
      ++v7;
    }
    while (v10 != v7);
  }
  return result;
}

uint64_t h264bridge_se_pull(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 24);
  if (v1 < 0x80000)
  {
    FigSignalErrorAt3();
    return 0;
  }
  else
  {
    uint64_t v2 = *(void *)(a1 + 16);
    unint64_t v3 = *(void *)a1 + *(unsigned int *)(a1 + 8);
    unsigned int v4 = __clz(v1);
    unsigned int v5 = v1 << (v4 + 1) >> -(char)v4;
    if (!v4) {
      unsigned int v5 = 0;
    }
    int v6 = 1 << v4;
    unsigned int v7 = *(unsigned __int8 *)(a1 + 28) + 2 * v4 + 1;
    uint64_t v8 = v7 >> 3;
    char v9 = v7 & 7;
    unint64_t v10 = v2 + v8 + 4;
    char v11 = v9 | (8 * (v8 - (v3 - v2 - 4)));
    BOOL v12 = v10 > v3;
    if (v10 > v3) {
      uint64_t v13 = (v3 - v2 - 4);
    }
    else {
      uint64_t v13 = v8;
    }
    if (v12) {
      char v9 = v11;
    }
    uint64_t v14 = v2 + v13;
    unsigned int v15 = bswap32(*(_DWORD *)(v2 + v13)) << v9;
    *(void *)(a1 + 16) = v14;
    uint64_t v16 = ((v5 + v6) >> 1) - ((v5 + v6) >> 1) * 2 * ((v5 + v6) & 1);
    *(_DWORD *)(a1 + 24) = v15;
    *(unsigned char *)(a1 + 28) = v9;
  }
  return v16;
}

uint64_t h264bridge_u_pulllong(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(a1 + 28);
  if ((v1 - 33) > 0xFFFFFFEF) {
    goto LABEL_17;
  }
  uint64_t v2 = *(void *)(a1 + 16);
  unint64_t v3 = *(void *)a1 + *(unsigned int *)(a1 + 8);
  unint64_t v4 = v1 + 16;
  unint64_t v5 = (unint64_t)(v1 + 16) >> 3;
  int v6 = v1 & 7;
  unint64_t v7 = v2 + (v4 >> 3) + 4;
  BOOL v8 = v7 > v3;
  if (v7 > v3) {
    unint64_t v9 = (v3 - v2 - 4);
  }
  else {
    unint64_t v9 = v5;
  }
  if (v8) {
    v6 |= 8 * (v5 - (v3 - v2 - 4));
  }
  if ((v6 - 33) >= 0xFFFFFFF0)
  {
LABEL_17:
    FigSignalErrorAt3();
    return 0;
  }
  else
  {
    int v10 = *(unsigned __int16 *)(a1 + 26) << 16;
    char v11 = (unsigned int *)(v2 + v9);
    unsigned int v12 = bswap32(*v11) << v6 >> 16;
    uint64_t v13 = (v6 + 16) >> 3;
    char v14 = v6 & 7;
    unint64_t v15 = (unint64_t)v11 + v13 + 4;
    char v16 = v14 | (8 * (v13 - (v3 - (_BYTE)v11 - 4)));
    BOOL v17 = v15 > v3;
    if (v15 > v3) {
      uint64_t v18 = (v3 - v11 - 4);
    }
    else {
      uint64_t v18 = v13;
    }
    if (v17) {
      char v14 = v16;
    }
    __int16 v19 = (char *)v11 + v18;
    unsigned int v20 = bswap32(*(unsigned int *)((char *)v11 + v18));
    *(void *)(a1 + 16) = v19;
    unsigned int v21 = v20 << v14;
    uint64_t v22 = v12 | v10;
    *(_DWORD *)(a1 + 24) = v21;
    *(unsigned char *)(a1 + 28) = v14;
  }
  return v22;
}

uint64_t h264bridge_ue_pulllong(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  unint64_t v2 = *(void *)a1 + *(unsigned int *)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a1 + 24);
  uint64_t v4 = *(unsigned __int8 *)(a1 + 28);
  if (v3 < 0x80000)
  {
    if (v4 != 32)
    {
      int v15 = 0;
      unint64_t v16 = v4 + 1;
      unint64_t v17 = (unint64_t)(v4 + 1) >> 3;
      int v18 = v16 & 7;
      BOOL v19 = v1 + (v16 >> 3) + 4 > v2;
      int v20 = v18 | (8 * (v17 - (v2 - v1 - 4)));
      if (v19) {
        unint64_t v17 = (v2 - v1 - 4);
      }
      if (v19) {
        int v18 = v20;
      }
      unsigned int v21 = (unsigned int *)(v1 + v17);
      unsigned int v22 = bswap32(*(_DWORD *)(v1 + v17)) << v18;
      do
      {
        if (v18 == 32) {
          goto LABEL_42;
        }
        unsigned int v23 = v22;
        char v24 = v18 + 1;
        uint64_t v25 = (v18 + 1) >> 3;
        int v26 = v24 & 7;
        unint64_t v27 = (unint64_t)v21 + v25 + 4;
        BOOL v28 = v27 > v2;
        if (v27 > v2) {
          uint64_t v29 = (v2 - v21 - 4);
        }
        else {
          uint64_t v29 = v25;
        }
        if (v28) {
          int v18 = v26 | (8 * (v25 - (v2 - v21 - 4)));
        }
        else {
          int v18 = v26;
        }
        unsigned int v21 = (unsigned int *)((char *)v21 + v29);
        unsigned int v22 = bswap32(*v21) << v18;
        --v15;
      }
      while ((v23 & 0x80000000) == 0);
      unsigned int v30 = -v15;
      if (-v15 >= 0x20) {
        goto LABEL_42;
      }
      if (v30 <= 0x18)
      {
        if (v30 > 32 - v18) {
          goto LABEL_42;
        }
        int v31 = v22 >> v15;
        unsigned int v32 = v18 - v15;
        uint64_t v33 = v32 >> 3;
        char v34 = v32 & 7;
        char v35 = v34 | (8 * (v33 - (v2 - (_BYTE)v21 - 4)));
        if ((unint64_t)v21 + v33 + 4 <= v2)
        {
          char v12 = v34;
        }
        else
        {
          uint64_t v33 = (v2 - v21 - 4);
          char v12 = v35;
        }
        uint64_t v13 = (unsigned int *)((char *)v21 + v33);
        unsigned int v14 = bswap32(*(unsigned int *)((char *)v21 + v33)) << v12;
        goto LABEL_39;
      }
      if (-16 - v15 <= (32 - v18))
      {
        unsigned int v36 = v18 - v15 - 16;
        uint64_t v37 = v36 >> 3;
        int v38 = v36 & 7;
        int v39 = v38 | (8 * (v37 - (v2 - v21 - 4)));
        if ((unint64_t)v21 + v37 + 4 > v2)
        {
          uint64_t v37 = (v2 - v21 - 4);
          int v38 = v39;
        }
        if ((v38 - 33) < 0xFFFFFFF0)
        {
          unsigned int v40 = v22 >> (v15 + 48);
          uint64_t v41 = (unsigned int *)((char *)v21 + v37);
          unsigned int v42 = bswap32(*v41) << v38;
          uint64_t v43 = (v38 + 16) >> 3;
          char v44 = v38 & 7;
          char v45 = v44 | (8 * (v43 - (v2 - (_BYTE)v41 - 4)));
          if ((unint64_t)v41 + v43 + 4 <= v2)
          {
            char v12 = v44;
          }
          else
          {
            uint64_t v43 = (v2 - v41 - 4);
            char v12 = v45;
          }
          uint64_t v13 = (unsigned int *)((char *)v41 + v43);
          unsigned int v14 = bswap32(*v13) << v12;
          int v31 = __PAIR64__(v40, v42) >> 16;
LABEL_39:
          uint64_t v7 = (v31 + ~(-1 << v30));
          goto LABEL_40;
        }
      }
    }
LABEL_42:
    FigSignalErrorAt3();
    return 0;
  }
  unsigned int v5 = __clz(v3);
  unsigned int v6 = v3 << (v5 + 1) >> -(char)v5;
  if (!v5) {
    unsigned int v6 = 0;
  }
  uint64_t v7 = v6 + ~(-1 << v5);
  unsigned int v8 = v4 + 2 * v5 + 1;
  uint64_t v9 = v8 >> 3;
  char v10 = v8 & 7;
  char v11 = v10 | (8 * (v9 - (v2 - v1 - 4)));
  if (v1 + v9 + 4 <= v2)
  {
    char v12 = v10;
  }
  else
  {
    uint64_t v9 = (v2 - v1 - 4);
    char v12 = v11;
  }
  uint64_t v13 = (unsigned int *)(v1 + v9);
  unsigned int v14 = bswap32(*(_DWORD *)(v1 + v9)) << v12;
LABEL_40:
  *(void *)(a1 + 16) = v13;
  *(_DWORD *)(a1 + 24) = v14;
  *(unsigned char *)(a1 + 28) = v12;
  return v7;
}

uint64_t _VCCannedAudioInjector_AudioConverterInput(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    *a2 = 0;
    if (a1)
    {
      if (a3)
      {
        if (a5)
        {
          CFTypeRef v8 = *(CFTypeRef *)a5;
          if (*(void *)a5)
          {
            CFTypeRef v9 = *(CFTypeRef *)(a5 + 32);
            if (v9 != v8)
            {
              *(void *)(a5 + 32) = v8;
              CFRetain(v8);
              if (v9) {
                CFRelease(v9);
              }
            }
            if (*(void *)a5)
            {
              CFRelease(*(CFTypeRef *)a5);
              *(void *)a5 = 0;
            }
            uint64_t v10 = 0;
            unsigned int v11 = *(_DWORD *)(a5 + 56);
            *(void *)(a3 + 16) = *(void *)(a5 + 24);
            unsigned int v12 = *(_DWORD *)(a5 + 20);
            *(_DWORD *)(a3 + 8) = *(_DWORD *)(a5 + 16);
            *(_DWORD *)(a3 + 12) = v12;
            *a2 = v12 / v11;
          }
          else
          {
            return 0;
          }
        }
        else
        {
          uint64_t v10 = 2003329396;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              _VCCannedAudioInjector_AudioConverterInput_cold_4();
            }
          }
        }
      }
      else
      {
        uint64_t v10 = 2003329396;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VCCannedAudioInjector_AudioConverterInput_cold_3();
          }
        }
      }
    }
    else
    {
      uint64_t v10 = 2003329396;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCCannedAudioInjector_AudioConverterInput_cold_2();
        }
      }
    }
  }
  else
  {
    uint64_t v10 = 2003329396;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCCannedAudioInjector_AudioConverterInput_cold_1();
      }
    }
  }
  return v10;
}

void VCCannedAudioInjector_InjectSamples(uint64_t a1, uint64_t a2, int a3, BOOL *a4)
{
  *(void *)&v48[5] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    Sampleint32_t Count = VCAudioBufferList_GetSampleCount(a2);
    int Timestamp = VCAudioBufferList_GetTimestamp(a2);
    double HostTime = VCAudioBufferList_GetHostTime(a2);
    if (a3) {
      char Priority = 1;
    }
    else {
      char Priority = -1;
    }
    if (*(unsigned char *)(a1 + 416))
    {
      unsigned int VoiceProbability = a3 ^ 1;
      int VoiceActivity = a3 ^ 1;
    }
    else
    {
      int VoiceActivity = VCAudioBufferList_GetVoiceActivity(a2);
      char Priority = VCAudioBufferList_GetPriority(a2);
      unsigned int VoiceProbability = VCAudioBufferList_GetVoiceProbability(a2);
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 192));
    if (a2 && SampleCount && HostTime >= 0.0 && *(_DWORD *)(a1 + 168))
    {
      uint64_t v37 = a4;
      VCAudioBufferList_SetSampleCount(a2, 0);
      unsigned int v12 = &OBJC_IVAR___AVCPreviewCALayerHost__preview;
      if (*(unsigned char *)(a1 + 188))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v13 = VRTraceErrorLogLevelToCSTR();
          unsigned int v14 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            uint64_t v42 = v13;
            __int16 v43 = 2080;
            char v44 = "VCCannedAudioInjector_InjectSamples";
            __int16 v45 = 1024;
            int v46 = 667;
            __int16 v47 = 2048;
            *(void *)BOOL v48 = a1;
            _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d instance=%p playback starting, resetting base now!", buf, 0x26u);
          }
        }
        unsigned int v12 = &OBJC_IVAR___AVCPreviewCALayerHost__preview;
        VCCannedAVSync_SetBase(*(void *)(a1 + 288), HostTime);
        *(unsigned char *)(a1 + 188) = 0;
      }
      int v15 = *(_DWORD *)(a1 + 400);
      double v16 = *(double *)(a1 + 248);
      int v17 = vcvtmd_s64_f64(v16 * VCCannedAVSync_ClampForTime(*(void *)(a1 + v12[174]), HostTime));
      int v18 = *(_DWORD *)(a1 + 184);
      int v19 = v17 - v18;
      if (v17 - v18 < 0) {
        int v19 = v18 - v17;
      }
      if (v19 <= (int)v16 / 10)
      {
        if (*(unsigned char *)(a1 + 296)) {
          VCCannedAVSync_AddDrift(*(void *)(a1 + v12[174]), ((double)v17 - (double)v18) / *(double *)(a1 + 248));
        }
      }
      else
      {
        *(_DWORD *)(a1 + 184) = v17 % v15;
      }
      double v20 = *(double *)(a1 + 248);
      int v40 = *(_DWORD *)(a1 + 168);
      while (*(_DWORD *)(a1 + 396) < *(_DWORD *)(a1 + 392))
      {
        if (v15 - *(_DWORD *)(a1 + 184) >= SampleCount) {
          signed int v21 = SampleCount;
        }
        else {
          signed int v21 = v15 - *(_DWORD *)(a1 + 184);
        }
        if (v21 < 0 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          uint64_t v22 = VRTraceErrorLogLevelToCSTR();
          unsigned int v23 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            int v24 = *(_DWORD *)(a1 + 184);
            *(_DWORD *)buf = 136316162;
            uint64_t v42 = v22;
            __int16 v43 = 2080;
            char v44 = "VCCannedAudioInjector_InjectSamples";
            __int16 v45 = 1024;
            int v46 = 689;
            __int16 v47 = 1024;
            *(_DWORD *)BOOL v48 = v15;
            v48[2] = 1024;
            *(_DWORD *)&v48[3] = v24;
            _os_log_impl(&dword_1E1EA4000, v23, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d samplesInLoop=%d, injector->_position=%d", buf, 0x28u);
          }
        }
        unsigned int v25 = *(_DWORD *)(a1 + 184);
        int v26 = v40 - v25;
        if ((int)(v40 - v25) >= v21) {
          int v26 = v21;
        }
        int v27 = v26 & ~(v26 >> 31);
        if (v21 <= v27) {
          int v28 = 0;
        }
        else {
          int v28 = v21 - v27;
        }
        if (a3) {
          int v29 = v26 & ~(v26 >> 31);
        }
        else {
          int v29 = 0;
        }
        if ((a3 & 1) == 0 && v26 >= 1)
        {
          int appended = VCAudioBufferList_AppendSamples(a2, *(void *)(a1 + 384), v25, v27);
          Timestamp += appended;
          double HostTime = HostTime + (double)appended / v20;
        }
        if (v28 + v29)
        {
          int v31 = VCAudioBufferList_AppendSilence(a2, Timestamp, v28 + v29, HostTime);
          Timestamp += v31;
          double HostTime = HostTime + (double)v31 / v20;
        }
        *(_DWORD *)(a1 + 184) = (*(_DWORD *)(a1 + 184) + v21) % v15;
        if (!*(_DWORD *)(a1 + 184)) {
          ++*(_DWORD *)(a1 + 396);
        }
        SampleCount -= v21;
        if (!SampleCount) {
          goto LABEL_53;
        }
      }
      VCAudioBufferList_AppendSilence(a2, Timestamp, SampleCount, HostTime);
LABEL_53:
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 192));
      VCAudioBufferList_SetTime(a2, Timestamp, HostTime);
      VCAudioBufferList_SetVoiceActivity(a2, VoiceActivity);
      VCAudioBufferList_SetVoiceProbability(a2, (double)VoiceProbability);
      VCAudioBufferList_SetPriority(a2, Priority);
      unsigned int v32 = *(_DWORD *)(a1 + 396);
      unsigned int v33 = *(_DWORD *)(a1 + 392);
      if (v37) {
        *uint64_t v37 = v32 >= v33;
      }
      if (*(unsigned char *)(a1 + 189)) {
        BOOL v34 = 0;
      }
      else {
        BOOL v34 = v32 >= v33;
      }
      if (v34)
      {
        *(unsigned char *)(a1 + 189) = 1;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v35 = VRTraceErrorLogLevelToCSTR();
          unsigned int v36 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            uint64_t v42 = v35;
            __int16 v43 = 2080;
            char v44 = "VCCannedAudioInjector_InjectSamples";
            __int16 v45 = 1024;
            int v46 = 731;
            __int16 v47 = 2048;
            *(void *)BOOL v48 = a1;
            _os_log_impl(&dword_1E1EA4000, v36, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d instance=%p playback complete", buf, 0x26u);
          }
        }
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 192));
    }
  }
}

BOOL VCAudioUnit_NewInstance(AudioComponentInstance *a1, OSType a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  inDesc.componentint Type = 1635083896;
  inDesc.componentSubint Type = a2;
  inDesc.componentFlagsMasuint64_t k = 0;
  *(void *)&inDesc.componentManufacturer = 1634758764;
  Next = AudioComponentFindNext(0, &inDesc);
  if (!Next)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v9 = VRTraceErrorLogLevelToCSTR();
      uint64_t v10 = *MEMORY[0x1E4F47A50];
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCAudioUnit_NewInstance_cold_1(v9, v10);
    }
    return 0;
  }
  OSStatus v4 = AudioComponentInstanceNew(Next, a1);
  if (v4)
  {
    int v5 = v4;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v6 = VRTraceErrorLogLevelToCSTR();
      uint64_t v7 = *MEMORY[0x1E4F47A50];
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCAudioUnit_NewInstance_cold_2(v6, v5, v7);
    }
    return 0;
  }
  return 1;
}

double _VCRateControlAlgorithmLowLatencyContinuousTier_Configure(uint64_t a1, const void *a2, int a3)
{
  VCRateControlAlgorithmLowLatencyNOWRDPriv_Configure(a1, a2, a3);
  LODWORD(v4) = *(_DWORD *)(a1 + 1104);
  double result = (double)v4;
  *(double *)(a1 + 1096) = result;
  *(_DWORD *)(a1 + 1108) = vcRateControlTierBitrates[*(int *)(a1 + 1084)];
  return result;
}

BOOL _VCRateControlAlgorithmLowLatencyContinuousTier_DoRateControl(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a2 == 11)
  {
    *(_DWORD *)(a1 + 5256) = *(_DWORD *)(a2 + 80);
    *(_DWORD *)(a1 + 5264) = *(_DWORD *)(a2 + 84);
    unint64_t v15 = *(void *)(a2 + 40);
    if (v15)
    {
      *(_DWORD *)(a1 + 5252) = v15 / *(unsigned int *)(a1 + 5140);
      *(_DWORD *)(a1 + 5236) = *(void *)(a2 + 72);
      LODWORD(a9) = *(_DWORD *)(a2 + 64);
      a10 = 1000.0;
      a9 = (double)*(unint64_t *)&a9 / 1000.0;
      *(double *)(a1 + 5240) = a9;
    }
    if (VCRateControlAlgorithmLowLatencyNOWRDPriv_ShouldRampDownDueToNWConnection(a1, a9, a10, a11, a2, a3, a4, a5, a6, a7, a8))
    {
      if (*(_DWORD *)(a1 + 1072) && *(double *)(a1 + 1128) > 0.0)
      {
        *(_DWORD *)(a1 + 1084) = VCRateControlAlgorithmLowLatencyNOWRDPriv_RampDownTierDueToNWConnection(a1);
        LODWORD(v19) = *(_DWORD *)(*(void *)(a1 + 48) + 4 * *(int *)(a1 + 1084));
        *(double *)(a1 + 1096) = (double)v19;
        VCRateControlAlgorithmBasePriv_StateChange(a1, 6);
      }
    }
    else if (VCRateControlAlgorithmLowLatencyNOWRDPriv_ShouldRampUpDueToNWConnection(a1, v16, v17, v18))
    {
      *(unsigned char *)(a1 + 5260) = 0;
    }
    else
    {
      *(unsigned char *)(a1 + 5260) = 1;
    }
    _VCRateControlAlgorithmLowLatencyContinuousTier_UpdateTargetBitrate(a1, *(double *)(a1 + 1096));
    return 1;
  }
  if (*(_DWORD *)a2 == 2)
  {
    BOOL result = VCRateControlAlgorithmLowLatencyNOWRDPriv_UpdateInternalStatus(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
    if (!result) {
      return result;
    }
    int ShouldRampDown = VCRateControlAlgorithmLowLatencyNOWRDPriv_ShouldRampDown(a1);
    if (ShouldRampDown) {
      int ShouldRampUp = 0;
    }
    else {
      int ShouldRampUp = VCRateControlAlgorithmLowLatencyNOWRDPriv_ShouldRampUp(a1);
    }
    switch(*(_DWORD *)(a1 + 1072))
    {
      case 0:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v20 = VRTraceErrorLogLevelToCSTR();
          signed int v21 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            *(void *)&uint8_t buf[4] = v20;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "_VCRateControlAlgorithmLowLatencyContinuousTier_RunRateControlStateTransition";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&uint8_t buf[24] = 130;
            _os_log_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d VCRateControl is paused", buf, 0x1Cu);
          }
        }
        break;
      case 1:
        if (ShouldRampDown) {
          goto LABEL_30;
        }
        if (ShouldRampUp)
        {
          *(double *)(a1 + 1096) = (double)_VCRateControlAlgorithmLowLatencyContinuousTier_RampUp(a1);
          if (*(_DWORD *)(a1 + 1084) >= *(_DWORD *)(a1 + 60)) {
            goto LABEL_41;
          }
        }
        break;
      case 2:
        if (ShouldRampDown)
        {
LABEL_30:
          *(double *)(a1 + 1096) = (double)_VCRateControlAlgorithmLowLatencyContinuousTier_RampDown(a1);
          uint64_t v22 = a1;
          int v23 = 6;
          goto LABEL_42;
        }
        if (ShouldRampUp)
        {
          unsigned int v24 = _VCRateControlAlgorithmLowLatencyContinuousTier_RampUp(a1);
          goto LABEL_38;
        }
        break;
      case 6:
        if (ShouldRampDown)
        {
          unsigned int v24 = _VCRateControlAlgorithmLowLatencyContinuousTier_RampDown(a1);
LABEL_38:
          *(double *)(a1 + 1096) = (double)v24;
        }
        else if (ShouldRampUp)
        {
          *(double *)(a1 + 1096) = (double)_VCRateControlAlgorithmLowLatencyContinuousTier_RampUp(a1);
LABEL_41:
          uint64_t v22 = a1;
          int v23 = 2;
LABEL_42:
          VCRateControlAlgorithmBasePriv_StateChange(v22, v23);
        }
        break;
      default:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VCRateControlAlgorithmLowLatencyContinuousTier_DoRateControl_cold_2();
          }
        }
        break;
    }
    _VCRateControlAlgorithmLowLatencyContinuousTier_UpdateTargetBitrate(a1, *(double *)(a1 + 1096));
    if (!VCRateControlAlgorithmLowLatencyNOWRDPriv_RampUpBlockedDueToUnstableOnly(a1)) {
      *(void *)(a1 + 5360) = *(void *)(a1 + 1128);
    }
    long long v92 = 0u;
    long long v93 = 0u;
    long long v90 = 0u;
    long long v91 = 0u;
    long long v88 = 0u;
    long long v89 = 0u;
    long long v86 = 0u;
    long long v87 = 0u;
    long long v84 = 0u;
    long long v85 = 0u;
    long long v82 = 0u;
    long long v83 = 0u;
    long long v80 = 0u;
    long long v81 = 0u;
    long long v78 = 0u;
    long long v79 = 0u;
    long long v76 = 0u;
    long long v77 = 0u;
    long long v75 = 0u;
    double v26 = *(double *)(a1 + 1128);
    int v61 = *(unsigned __int16 *)(a1 + 5220);
    long long v73 = 0u;
    long long v74 = 0u;
    double v27 = *(double *)(a1 + 2888);
    double v28 = *(double *)(a1 + 2896);
    long long v71 = 0u;
    long long v72 = 0u;
    double v29 = *(double *)(a1 + 2904);
    double v30 = *(double *)(a1 + 2912);
    memset(buf, 0, sizeof(buf));
    int v60 = (int)(*(double *)(a1 + 5104) * 1000.0);
    if (*(_DWORD *)(a1 + 1076)) {
      uint64_t v31 = 88;
    }
    else {
      uint64_t v31 = 79;
    }
    uint64_t v59 = v31;
    LODWORD(v25) = *(_DWORD *)(a1 + 5224);
    int v58 = *(_DWORD *)(a1 + 1200);
    int v57 = *(_DWORD *)(a1 + 5016);
    double v32 = *(double *)(a1 + 5024) * 100.0;
    double v33 = (double)v25;
    unsigned int v56 = *(_DWORD *)(a1 + 5232) / 0x3E8u;
    unsigned int v55 = *(_DWORD *)(a1 + 5228) / 0x3E8u;
    int v53 = *(unsigned __int16 *)(a1 + 1080);
    unsigned int v54 = *(_DWORD *)(a1 + 1104) / 0x3E8u;
    int v34 = *(_DWORD *)(a1 + 1116);
    int v35 = (unsigned __int16)*(_DWORD *)(a1 + 1076);
    int v36 = *(_DWORD *)(a1 + 5248);
    unsigned int v37 = (*(double *)(a1 + 5240) * 1000.0);
    unsigned int v38 = *(_DWORD *)(a1 + 5236) / 0x3E8u;
    unsigned int v39 = VCRateControlMediaController_AudioSendingBitrate(*(void *)(a1 + 1048)) / 0x3E8;
    int v40 = VCRateControlMediaController_AudioFractionTier(*(void *)(a1 + 1048));
    if (*(unsigned char *)(a1 + 5218)) {
      uint64_t v41 = "S";
    }
    else {
      uint64_t v41 = "U";
    }
    if (*(unsigned char *)(a1 + 1153))
    {
      uint64_t v42 = "<";
    }
    else if (VCRateControlMediaController_IsVideoStopped(*(unsigned char **)(a1 + 1048)))
    {
      uint64_t v42 = "_";
    }
    else
    {
      uint64_t v42 = "-";
    }
    snprintf((char *)buf, 0x190uLL, "%8.3f/%04X:\t%.4f\t%.4f\t%.4f\t%.4f %c\tRTT:%-4u\tPLR:%4.2f@%.1f\tRRx:%u\tMBL:%d %u\t%4u/%4u\t %4u:%4u/%4u  %4u:%4u/%4u  CS: %04X %04X %u BB: %3u\t%4u\t%3u\t%u\t%u\t UAT %s %s\t%d\t%d\t%d\t%d\t%.3f\t%.3f\t%u\t%u\n", v26, v61, v27, v28, v29, v30, v59, v60, v32, v33, v58, v57, v56, v55, v54,
      0,
      0,
      0,
      0,
      0,
      0,
      v35,
      v53,
      v34,
      v38,
      v36,
      v37,
      v39,
      v40,
      v41,
      v42,
      *(_DWORD *)(a1 + 1072),
      *(_DWORD *)(a1 + 5004) / 0x3E8u,
      *(_DWORD *)(a1 + 5008),
      *(_DWORD *)(a1 + 5000),
      *(double *)(a1 + 5384),
      0.0,
      0,
      0);
    if (*(unsigned char *)(a1 + 5160))
    {
      int v49 = *(_DWORD *)(a1 + 1120);
      *(_DWORD *)(a1 + 1120) = v49 + 1;
      if ((v49 & 0xF) == 0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v50 = VRTraceErrorLogLevelToCSTR();
        int v51 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long v62 = 136315906;
          uint64_t v63 = v50;
          __int16 v64 = 2080;
          uint64_t v65 = "_VCRateControlAlgorithmLowLatencyContinuousTier_PrintRateControlInfoToLogDump";
          __int16 v66 = 1024;
          int v67 = 309;
          __int16 v68 = 2080;
          __int16 v69 = buf;
          _os_log_impl(&dword_1E1EA4000, v51, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d %s", v62, 0x26u);
        }
      }
    }
    uint64_t v52 = *(void *)(a1 + 5144);
    if (v52) {
      VRLogfilePrintWithTimestamp(v52, "%s\n", v43, v44, v45, v46, v47, v48, (char)buf);
    }
    VCRateControlAlgorithmLowLatencyNOWRDPriv_ResetRampingStatus(a1);
    return 1;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    _VCRateControlAlgorithmLowLatencyContinuousTier_DoRateControl_cold_1();
  }
  return 0;
}

uint64_t _VCRateControlAlgorithmLowLatencyContinuousTier_UpdateTargetBitrate(uint64_t result, unsigned int a2)
{
  int v2 = *(_DWORD *)(result + 60);
  if ((v2 & 0x80000000) == 0)
  {
    while (vcRateControlTierBitrates[v2] > a2)
    {
      if (v2-- <= 0)
      {
        int v2 = -1;
        break;
      }
    }
  }
  int v4 = *(_DWORD *)(result + 1084);
  int v5 = *(_DWORD *)(result + 64);
  if (v2 > v5) {
    int v5 = v2;
  }
  *(_DWORD *)(result + 1084) = v5;
  if (*(_DWORD *)(result + 1084) < v4) {
    *(void *)(result + 1176) = *(void *)(result + 1128);
  }
  *(_DWORD *)(result + 1088) = v4;
  *(_DWORD *)(result + 1104) = a2;
  *(_DWORD *)(result + 1108) = vcRateControlTierBitrates[*(int *)(result + 1084)];
  return result;
}

uint64_t _VCRateControlAlgorithmLowLatencyContinuousTier_RampDown(uint64_t a1)
{
  VCRateControlAlgorithmLowLatencyNOWRDPriv_SetRateChangeCounter(a1);
  *(unsigned char *)(a1 + 1144) = 1;
  *(void *)(a1 + 1168) = *(void *)(a1 + 1128);
  VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampDown(a1, *(double *)(a1 + 1128));
  double v2 = *(double *)(a1 + 1096);
  double v3 = 1.0;
  if (*(_DWORD *)(a1 + 1072) == 1) {
    double v3 = 2.0;
  }
  long double v4 = v3 * *(double *)(a1 + 616);
  *(long double *)(a1 + 5384) = v4;
  double v11 = v2 / pow(1.159, v4);
  LODWORD(v12) = vcRateControlTierBitrates[*(int *)(a1 + 64)];
  double v13 = (double)v12;
  if (v11 <= v13) {
    double v14 = v13;
  }
  else {
    double v14 = v11;
  }
  VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Congestion!!! New bitrate down exponentially to newTargetBitrate=%f with speedFactor=%f", v5, v6, v7, v8, v9, v10, *(_DWORD *)(a1 + 1116));
  return v14;
}

uint64_t _VCRateControlAlgorithmLowLatencyContinuousTier_RampUp(uint64_t a1)
{
  VCRateControlAlgorithmLowLatencyNOWRDPriv_SetRateChangeCounter(a1);
  VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampUp(a1);
  *(_DWORD *)(a1 + 5000) = 0;
  double v2 = *(double *)(a1 + 1096);
  double v3 = *(double *)(a1 + 1128) - *(double *)(a1 + 5360);
  double v4 = *(double *)(a1 + 624);
  if (v4 <= 0.0) {
    double v4 = 1.0;
  }
  if (*(_DWORD *)(a1 + 1072) == 1) {
    double v5 = 0.1;
  }
  else {
    double v5 = 1.0;
  }
  double v6 = 1.0 / (v5 / v4);
  unsigned int v7 = 1000 * *(_DWORD *)(a1 + 1200);
  double v8 = (double)v7 - v2;
  if (v8 < 0.0) {
    double v8 = -v8;
  }
  double v9 = (double)v7 * 0.1;
  if (v8 < v9) {
    double v6 = v8 / v9;
  }
  double v10 = fmin(fmax(v6, 0.0166666667), 10.0);
  *(double *)(a1 + 5384) = v10;
  double v11 = v2 * pow(1.159, v3 * v10);
  LODWORD(v12) = vcRateControlTierBitrates[*(int *)(a1 + 60)];
  double v13 = (double)v12;
  if (v11 >= v13) {
    return v13;
  }
  return v11;
}

double VCCannedAVSync_SetBase(uint64_t a1, double a2)
{
  double result = a2 - *(double *)(a1 + 16) * floor(*(double *)(a1 + 8) / *(double *)(a1 + 16));
  *(double *)(a1 + 8) = result;
  return result;
}

double VCCannedAVSync_AddDrift(uint64_t a1, double a2)
{
  double result = *(double *)(a1 + 8) + a2 - *(double *)(a1 + 16) * floor((*(double *)(a1 + 8) + a2) / *(double *)(a1 + 16));
  *(double *)(a1 + 8) = result;
  return result;
}

double VCCannedAVSync_ClampForTime(uint64_t a1, double a2)
{
  return a2 - *(double *)(a1 + 8) - *(double *)(a1 + 16) * floor((a2 - *(double *)(a1 + 8)) / *(double *)(a1 + 16));
}

void VCSignalHandler_Initialize()
{
  if (InitializeSignalHandlerBlockRegistry_sInitSignalHandlerBlockRegistryOnce != -1) {
    dispatch_once(&InitializeSignalHandlerBlockRegistry_sInitSignalHandlerBlockRegistryOnce, &__block_literal_global_84);
  }
  if (AVConferenceServer_ProcessIsAvconferenced())
  {
    signal(30, (void (__cdecl *)(int))1);
    id v0 = (const dispatch_source_type_s *)MEMORY[0x1E4F14480];
    gSignalHandlerBlockRegistry1_1 = (uint64_t)dispatch_source_create(MEMORY[0x1E4F14480], 0x1EuLL, 0, (dispatch_queue_t)gSignalHandlerBlockRegistry1_0);
    dispatch_source_set_event_handler_f((dispatch_source_t)gSignalHandlerBlockRegistry1_1, (dispatch_function_t)VCExecuteSignalHandlerBlocks1);
    dispatch_resume((dispatch_object_t)gSignalHandlerBlockRegistry1_1);
    signal(31, (void (__cdecl *)(int))1);
    gSignalHandlerBlockRegistry2_1 = (uint64_t)dispatch_source_create(v0, 0x1FuLL, 0, (dispatch_queue_t)gSignalHandlerBlockRegistry2_0);
    dispatch_source_set_event_handler_f((dispatch_source_t)gSignalHandlerBlockRegistry2_1, (dispatch_function_t)VCExecuteSignalHandlerBlocks2);
    dispatch_resume((dispatch_object_t)gSignalHandlerBlockRegistry2_1);
    signal(15, (void (__cdecl *)(int))1);
    gSignalHandlerBlockRegistry3_1 = (uint64_t)dispatch_source_create(v0, 0xFuLL, 0, (dispatch_queue_t)gSignalHandlerBlockRegistry3_0);
    dispatch_source_set_event_handler_f((dispatch_source_t)gSignalHandlerBlockRegistry3_1, (dispatch_function_t)VCExecuteSignalHandlerBlocks3);
    uint64_t v1 = gSignalHandlerBlockRegistry3_1;
    dispatch_resume(v1);
  }
}

uint64_t VCExecuteSignalHandlerBlocks1()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v0 = VRTraceErrorLogLevelToCSTR();
    uint64_t v1 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v3 = 136315650;
      uint64_t v4 = v0;
      __int16 v5 = 2080;
      double v6 = "VCExecuteSignalHandlerBlocks1";
      __int16 v7 = 1024;
      int v8 = 31;
      _os_log_impl(&dword_1E1EA4000, v1, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCExecuteSignalHandlerBlocks1 USR1", (uint8_t *)&v3, 0x1Cu);
    }
  }
  return VRTraceReset();
}

void VCExecuteSignalHandlerBlocks2()
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v0 = VRTraceErrorLogLevelToCSTR();
    uint64_t v1 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      uint64_t v17 = v0;
      __int16 v18 = 2080;
      unint64_t v19 = "VCExecuteSignalHandlerBlocks2";
      __int16 v20 = 1024;
      int v21 = 36;
      _os_log_impl(&dword_1E1EA4000, v1, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCExecuteSignalHandlerBlocks2 USR2", buf, 0x1Cu);
    }
  }
  double v2 = (void *)CFPreferencesCopyAppValue(@"SignalHandlerCodes", @"com.apple.VideoConference");
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v3 = VRTraceErrorLogLevelToCSTR();
    uint64_t v4 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      uint64_t v17 = v3;
      __int16 v18 = 2080;
      unint64_t v19 = "VCExecuteSignalHandlerBlocks2";
      __int16 v20 = 1024;
      int v21 = 39;
      __int16 v22 = 2112;
      uint64_t v23 = (uint64_t)v2;
      _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d signalHandlerCodes=%@", buf, 0x26u);
    }
  }
  unint64_t v15 = v2;
  if (v2) {
    __int16 v5 = (void *)[v2 componentsSeparatedByString:@";"];
  }
  else {
    __int16 v5 = (void *)[(id)gSignalHandlerBocks allKeys];
  }
  double v6 = v5;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  uint64_t v7 = [v5 countByEnumeratingWithState:&v29 objects:v28 count:16];
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)v30;
    do
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        if (*(void *)v30 != v9) {
          objc_enumerationMutation(v6);
        }
        uint64_t v11 = *(void *)(*((void *)&v29 + 1) + 8 * i);
        uint64_t v12 = [(id)gSignalHandlerBocks objectForKeyedSubscript:v11];
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v13 = VRTraceErrorLogLevelToCSTR();
          double v14 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316418;
            uint64_t v17 = v13;
            __int16 v18 = 2080;
            unint64_t v19 = "VCExecuteSignalHandlerBlocks2";
            __int16 v20 = 1024;
            int v21 = 43;
            __int16 v22 = 2048;
            uint64_t v23 = gSignalHandlerBocks;
            __int16 v24 = 2112;
            uint64_t v25 = v11;
            __int16 v26 = 2048;
            uint64_t v27 = v12;
            _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d gSignalHandlerBocks=%p, code=%@, block=%p", buf, 0x3Au);
          }
        }
        if (v12) {
          (*(void (**)(uint64_t))(v12 + 16))(v12);
        }
      }
      uint64_t v8 = [v6 countByEnumeratingWithState:&v29 objects:v28 count:16];
    }
    while (v8);
  }
}

uint64_t VCExecuteSignalHandlerBlocks3()
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v0 = VRTraceErrorLogLevelToCSTR();
    uint64_t v1 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 136315650;
      uint64_t v5 = v0;
      __int16 v6 = 2080;
      uint64_t v7 = "VCExecuteSignalHandlerBlocks3";
      __int16 v8 = 1024;
      int v9 = 52;
      _os_log_impl(&dword_1E1EA4000, v1, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d avconferenced received SIGTERM, exiting", (uint8_t *)&v4, 0x1Cu);
    }
  }
  pid_t v2 = getpid();
  return kill(v2, 9);
}

uint64_t VCRegisterSignalHandler(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    uint64_t v5 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136316418;
      uint64_t v8 = v4;
      __int16 v9 = 2080;
      uint64_t v10 = "VCRegisterSignalHandler";
      __int16 v11 = 1024;
      int v12 = 88;
      __int16 v13 = 2080;
      double v14 = "VCRegisterSignalHandler";
      __int16 v15 = 2112;
      uint64_t v16 = [NSString stringWithUTF8String:a1];
      __int16 v17 = 2048;
      uint64_t v18 = a2;
      _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %s: code=%@, block=%p", (uint8_t *)&v7, 0x3Au);
    }
  }
  return objc_msgSend((id)gSignalHandlerBocks, "setObject:forKeyedSubscript:", a2, objc_msgSend(NSString, "stringWithUTF8String:", a1));
}

id __InitializeSignalHandlerBlockRegistry_block_invoke()
{
  CustomRootQueue = VCDispatchQueue_GetCustomRootQueue(37);
  gSignalHandlerBlockRegistry1_0 = (uint64_t)dispatch_queue_create_with_target_V2("com.apple.AVConference.VCSignalHandler.registryQueue1", 0, CustomRootQueue);
  gSignalHandlerBlockRegistry2_0 = (uint64_t)dispatch_queue_create_with_target_V2("com.apple.AVConference.VCSignalHandler.registryQueue2", 0, CustomRootQueue);
  gSignalHandlerBlockRegistry3_0 = (uint64_t)dispatch_queue_create_with_target_V2("com.apple.AVConference.VCSignalHandler.registryQueue3", 0, CustomRootQueue);
  id result = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  gSignalHandlerBocks = (uint64_t)result;
  return result;
}

void sub_1E2336D10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
}

uint64_t OUTLINED_FUNCTION_7_11@<X0>(void **a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)(v2 - 24) = a2;
  uint64_t v4 = *a1;
  return [v4 UTF8String];
}

BOOL VCMathUtils_DoubleEqualWithAccuracy(double a1, double a2, double a3)
{
  return vabdd_f64(a1, a2) < a3;
}

uint64_t _VCRateControlSmartBrake_BindEspressoBuffer(void *a1, uint64_t a2, __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  *(void *)(a2 + 160) = 0;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v10 = espresso_buffer_pack_tensor_shape();
  if (!v10)
  {
    *(void *)a2 = a6;
    *(_DWORD *)(a2 + 160) = 65568;
    uint64_t v11 = espresso_network_bind_buffer();
    if (!v11) {
      return v11;
    }
    if (objc_opt_class() != a1)
    {
      if (objc_opt_respondsToSelector()) {
        double v14 = (__CFString *)[a1 performSelector:sel_logPrefix];
      }
      else {
        double v14 = &stru_1F3D3E450;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v23 = VRTraceErrorLogLevelToCSTR();
        __int16 v22 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          int v24 = 136316674;
          uint64_t v25 = v23;
          __int16 v26 = 2080;
          uint64_t v27 = "_VCRateControlSmartBrake_BindEspressoBuffer";
          __int16 v28 = 1024;
          int v29 = 390;
          __int16 v30 = 2112;
          long long v31 = v14;
          __int16 v32 = 2048;
          uint64_t v33 = a1;
          __int16 v34 = 2080;
          int v35 = a3;
          __int16 v36 = 1024;
          int v37 = v11;
          __int16 v17 = " [%s] %s:%d %@(%p) Unable to bind %s espresso buffer returnStatus=%d";
          goto LABEL_25;
        }
      }
      return v11;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
      return v11;
    }
    uint64_t v18 = VRTraceErrorLogLevelToCSTR();
    uint64_t v16 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      return v11;
    }
    int v24 = 136316162;
    uint64_t v25 = v18;
    __int16 v26 = 2080;
    uint64_t v27 = "_VCRateControlSmartBrake_BindEspressoBuffer";
    __int16 v28 = 1024;
    int v29 = 390;
    __int16 v30 = 2080;
    long long v31 = a3;
    __int16 v32 = 1024;
    LODWORD(v33) = v11;
    __int16 v17 = " [%s] %s:%d Unable to bind %s espresso buffer returnStatus=%d";
LABEL_16:
    uint64_t v19 = v16;
    uint32_t v20 = 44;
LABEL_26:
    _os_log_error_impl(&dword_1E1EA4000, v19, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&v24, v20);
    return v11;
  }
  uint64_t v11 = v10;
  if (objc_opt_class() == a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
      return v11;
    }
    uint64_t v15 = VRTraceErrorLogLevelToCSTR();
    uint64_t v16 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      return v11;
    }
    int v24 = 136316162;
    uint64_t v25 = v15;
    __int16 v26 = 2080;
    uint64_t v27 = "_VCRateControlSmartBrake_BindEspressoBuffer";
    __int16 v28 = 1024;
    int v29 = 384;
    __int16 v30 = 2080;
    long long v31 = a3;
    __int16 v32 = 1024;
    LODWORD(v33) = v11;
    __int16 v17 = " [%s] %s:%d Unable to pack espresso tensor shape for %s espresso buffer returnStatus=%d";
    goto LABEL_16;
  }
  if (objc_opt_respondsToSelector()) {
    __int16 v13 = (__CFString *)[a1 performSelector:sel_logPrefix];
  }
  else {
    __int16 v13 = &stru_1F3D3E450;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v21 = VRTraceErrorLogLevelToCSTR();
    __int16 v22 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
    {
      int v24 = 136316674;
      uint64_t v25 = v21;
      __int16 v26 = 2080;
      uint64_t v27 = "_VCRateControlSmartBrake_BindEspressoBuffer";
      __int16 v28 = 1024;
      int v29 = 384;
      __int16 v30 = 2112;
      long long v31 = v13;
      __int16 v32 = 2048;
      uint64_t v33 = a1;
      __int16 v34 = 2080;
      int v35 = a3;
      __int16 v36 = 1024;
      int v37 = v11;
      __int16 v17 = " [%s] %s:%d %@(%p) Unable to pack espresso tensor shape for %s espresso buffer returnStatus=%d";
LABEL_25:
      uint64_t v19 = v22;
      uint32_t v20 = 64;
      goto LABEL_26;
    }
  }
  return v11;
}

void VCRateControlSmartBrake_Query(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  *(_DWORD *)(a3 + 8) = 0;
  *(void *)a3 = 0;
  if (!a1 || *(_DWORD *)(a1 + 2112) != 1) {
    return;
  }
  float v6 = *(float *)a2;
  if (*(float *)(a1 + 172) == 0.0)
  {
    *(float *)(a1 + 168) = v6;
    *(_DWORD *)(a1 + 172) = 1065353216;
    return;
  }
  *(float *)(a1 + 176) = v6 - *(float *)(a1 + 168);
  *(float *)(a1 + 168) = v6;
  *(_DWORD *)(a1 + 180) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 188) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 184) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 192) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 196) = *(_DWORD *)(a2 + 20);
  if (espresso_plan_execute_sync())
  {
    uint64_t error_info = espresso_plan_get_error_info();
    uint64_t v9 = v8;
    if (objc_opt_class() == a1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
        return;
      }
      uint64_t v11 = VRTraceErrorLogLevelToCSTR();
      int v12 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        return;
      }
      int v18 = 136316418;
      uint64_t v19 = v11;
      __int16 v20 = 2080;
      uint64_t v21 = "VCRateControlSmartBrake_Query";
      __int16 v22 = 1024;
      int v23 = 426;
      __int16 v24 = 1024;
      *(_DWORD *)uint64_t v25 = error_info;
      *(_WORD *)&_OWORD v25[4] = 1024;
      *(_DWORD *)&v25[6] = HIDWORD(error_info);
      *(_WORD *)__int16 v26 = 2080;
      *(void *)&v26[2] = v9;
      __int16 v13 = " [%s] %s:%d Error while executing neural network planStatus=%d, returnStatus=%d, description=%s";
      double v14 = v12;
      uint32_t v15 = 50;
    }
    else
    {
      if (objc_opt_respondsToSelector()) {
        uint64_t v10 = (__CFString *)[(id)a1 performSelector:sel_logPrefix];
      }
      else {
        uint64_t v10 = &stru_1F3D3E450;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
        return;
      }
      uint64_t v16 = VRTraceErrorLogLevelToCSTR();
      __int16 v17 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        return;
      }
      int v18 = 136316930;
      uint64_t v19 = v16;
      __int16 v20 = 2080;
      uint64_t v21 = "VCRateControlSmartBrake_Query";
      __int16 v22 = 1024;
      int v23 = 426;
      __int16 v24 = 2112;
      *(void *)uint64_t v25 = v10;
      *(_WORD *)&v25[8] = 2048;
      *(void *)__int16 v26 = a1;
      *(_WORD *)&v26[8] = 1024;
      int v27 = error_info;
      __int16 v28 = 1024;
      int v29 = HIDWORD(error_info);
      __int16 v30 = 2080;
      uint64_t v31 = v9;
      __int16 v13 = " [%s] %s:%d %@(%p) Error while executing neural network planStatus=%d, returnStatus=%d, description=%s";
      double v14 = v17;
      uint32_t v15 = 70;
    }
    _os_log_error_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_ERROR, v13, (uint8_t *)&v18, v15);
    return;
  }
  *(_DWORD *)a3 = *(_DWORD *)(a1 + 200);
  *(uint32x2_t *)(a3 + 4) = vcvt_u32_f32(*(float32x2_t *)(a1 + 204));

  kdebug_trace();
}

BOOL VCRateControlSmartBrake_IsOutputEmpty(uint64_t a1, unsigned int a2)
{
  return (a1 & 0xFFFFFFFF7FFFFFFFLL | a2) == 0;
}

void VCRateControlSmartBrake_ResetState(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 1736))
    {
      unint64_t v1 = 0;
      do
        *(_DWORD *)(*(void *)(a1 + 1728) + 4 * v1++) = 0;
      while (v1 < *(void *)(a1 + 1736));
    }
    *(_DWORD *)(a1 + 172) = 0;
  }
  else if (objc_opt_class())
  {
    if (objc_opt_respondsToSelector()) {
      [0 performSelector:sel_logPrefix];
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCRateControlSmartBrake_ResetState_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlSmartBrake_ResetState_cold_1();
    }
  }
}

int64_t _VCMediaStreamSynchronizer_differenceBetweenRtpTimestamp(int a1, unsigned int a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1;
  int64_t v3 = a1 - (unint64_t)a2;
  if (v3 <= (uint64_t)0xFFFFFFFF80000000)
  {
    v3 += 0x100000000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v5 = a2;
      uint64_t v6 = VRTraceErrorLogLevelToCSTR();
      int v7 = *MEMORY[0x1E4F47A50];
      uint64_t v8 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = 136316418;
          uint64_t v11 = v6;
          __int16 v12 = 2080;
          __int16 v13 = "_VCMediaStreamSynchronizer_differenceBetweenRtpTimestamp";
          __int16 v14 = 1024;
          int v15 = 260;
          __int16 v16 = 2048;
          uint64_t v17 = v2;
          __int16 v18 = 2048;
          uint64_t v19 = v5;
          __int16 v20 = 2048;
          int64_t v21 = v3;
          _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer: wrap around playoutSampleRTP(%lld)-destRTPOfNTP(%lld)=%lld", (uint8_t *)&v10, 0x3Au);
        }
      }
      else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        int v10 = 136316418;
        uint64_t v11 = v6;
        __int16 v12 = 2080;
        __int16 v13 = "_VCMediaStreamSynchronizer_differenceBetweenRtpTimestamp";
        __int16 v14 = 1024;
        int v15 = 260;
        __int16 v16 = 2048;
        uint64_t v17 = v2;
        __int16 v18 = 2048;
        uint64_t v19 = v5;
        __int16 v20 = 2048;
        int64_t v21 = v3;
        _os_log_debug_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEBUG, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer: wrap around playoutSampleRTP(%lld)-destRTPOfNTP(%lld)=%lld", (uint8_t *)&v10, 0x3Au);
      }
    }
  }
  return v3;
}

void VCMediaStreamSynchronizer_updateDestinationNTPTime(uint64_t a1, int a2, double a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      uint64_t v7 = VRTraceErrorLogLevelToCSTR();
      uint64_t v8 = *MEMORY[0x1E4F47A50];
      uint64_t v9 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316418;
          uint64_t v14 = v7;
          __int16 v15 = 2080;
          __int16 v16 = "VCMediaStreamSynchronizer_updateDestinationNTPTime";
          __int16 v17 = 1024;
          int v18 = 120;
          __int16 v19 = 2048;
          uint64_t v20 = a1;
          __int16 v21 = 2048;
          double v22 = a3;
          __int16 v23 = 1024;
          int v24 = a2;
          _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p] Received dest (video) ntpTime=%.6f rtpTimeStamp=%u", buf, 0x36u);
        }
      }
      else if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136316418;
        uint64_t v14 = v7;
        __int16 v15 = 2080;
        __int16 v16 = "VCMediaStreamSynchronizer_updateDestinationNTPTime";
        __int16 v17 = 1024;
        int v18 = 120;
        __int16 v19 = 2048;
        uint64_t v20 = a1;
        __int16 v21 = 2048;
        double v22 = a3;
        __int16 v23 = 1024;
        int v24 = a2;
        _os_log_debug_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEBUG, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p] Received dest (video) ntpTime=%.6f rtpTimeStamp=%u", buf, 0x36u);
      }
    }
    int v10 = *(NSObject **)(a1 + 24);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __VCMediaStreamSynchronizer_updateDestinationNTPTime_block_invoke;
    block[3] = &unk_1E6DB3F58;
    block[4] = a1;
    *(double *)&void block[5] = a3;
    int v12 = a2;
    dispatch_async(v10, block);
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCMediaStreamSynchronizer_updateDestinationNTPTime_cold_1();
    }
  }
}

void VCMediaStreamSynchronizer_scheduleDestinationPlaybackWithRTPTimestamp(uint64_t a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    double v4 = VCMediaStreamSynchronizer_scheduleTimeForDestinationRTPTimestamp(a1, a2);
    VCVideoPlayer_QueueAlarmForDecode(*(void *)(a1 + 32), (uint64_t)_VCMediaStreamSynchronizerAlarmCallback, a1, a2, 0, 0, v4);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      uint64_t v6 = *MEMORY[0x1E4F47A50];
      uint64_t v7 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = 136316418;
          uint64_t v9 = v5;
          __int16 v10 = 2080;
          uint64_t v11 = "VCMediaStreamSynchronizer_scheduleDestinationPlaybackWithRTPTimestamp";
          __int16 v12 = 1024;
          int v13 = 138;
          __int16 v14 = 2048;
          uint64_t v15 = a1;
          __int16 v16 = 1024;
          int v17 = a2;
          __int16 v18 = 2048;
          double v19 = v4;
          _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: Scheduled playout for dest (video) RTPTimestamp=%u scheduleTime=%.6f", (uint8_t *)&v8, 0x36u);
        }
      }
      else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        int v8 = 136316418;
        uint64_t v9 = v5;
        __int16 v10 = 2080;
        uint64_t v11 = "VCMediaStreamSynchronizer_scheduleDestinationPlaybackWithRTPTimestamp";
        __int16 v12 = 1024;
        int v13 = 138;
        __int16 v14 = 2048;
        uint64_t v15 = a1;
        __int16 v16 = 1024;
        int v17 = a2;
        __int16 v18 = 2048;
        double v19 = v4;
        _os_log_debug_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEBUG, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: Scheduled playout for dest (video) RTPTimestamp=%u scheduleTime=%.6f", (uint8_t *)&v8, 0x36u);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCMediaStreamSynchronizer_scheduleDestinationPlaybackWithRTPTimestamp_cold_1();
    }
  }
}

double VCMediaStreamSynchronizer_scheduleTimeForDestinationRTPTimestamp(uint64_t a1, int a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = 0;
  int v8 = (double *)&v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v10 = 0;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  void v5[2] = __VCMediaStreamSynchronizer_scheduleTimeForDestinationRTPTimestamp_block_invoke;
  uint64_t v5[3] = &unk_1E6DB6790;
  int v6 = a2;
  void v5[4] = a1;
  _OWORD v5[5] = &v7;
  dispatch_sync(v2, v5);
  double v3 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v3;
}

void _VCMediaStreamSynchronizerAlarmCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1)
  {
    uint64_t v7 = (os_unfair_lock_s *)(a1 + 116);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 116));
    uint64_t v8 = *(void *)(a1 + 40);
    if (v8) {
      (*(void (**)(uint64_t, void, uint64_t))(v8 + 16))(v8, *(unsigned int *)(a2 + 8), a4);
    }
    os_unfair_lock_unlock(v7);
  }
}

void VCMediaStreamSynchronizer_resetDestinationState(uint64_t a1)
{
  v2[5] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    unint64_t v1 = *(NSObject **)(a1 + 24);
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 3221225472;
    v2[2] = __VCMediaStreamSynchronizer_resetDestinationState_block_invoke;
    v2[3] = &unk_1E6DB3DC8;
    v2[4] = a1;
    dispatch_async(v1, v2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCMediaStreamSynchronizer_resetDestinationState_cold_1();
    }
  }
}

void VCMediaStreamSynchronizer_setDestinationAlarmHandler(uint64_t a1, const void *a2)
{
  if (a1)
  {
    double v4 = (os_unfair_lock_s *)(a1 + 116);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 116));
    _Block_release(*(const void **)(a1 + 40));
    *(void *)(a1 + 40) = _Block_copy(a2);
    os_unfair_lock_unlock(v4);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCMediaStreamSynchronizer_setDestinationAlarmHandler_cold_1();
    }
  }
}

BOOL _VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal(uint64_t a1, int a2, int *a3)
{
  BOOL result = 0;
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  if (!a1 || !a3) {
    return result;
  }
  if (*(_DWORD *)(a1 + 100) == 1 || !*(_DWORD *)(a1 + 64) || !*(_DWORD *)(a1 + 96))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
      return 0;
    }
    uint64_t v19 = VRTraceErrorLogLevelToCSTR();
    uint64_t v20 = *MEMORY[0x1E4F47A50];
    __int16 v21 = *MEMORY[0x1E4F47A50];
    if (!*MEMORY[0x1E4F47A40])
    {
      BOOL result = os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG);
      if (!result) {
        return result;
      }
      _VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal_cold_1();
      return 0;
    }
    BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v22) {
      return result;
    }
    int v38 = 136315906;
    uint64_t v39 = v19;
    __int16 v40 = 2080;
    uint64_t v41 = "_VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal";
    __int16 v42 = 1024;
    int v43 = 283;
    __int16 v44 = 2048;
    uint64_t v45 = a1;
    __int16 v23 = "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: source info not ready";
LABEL_15:
    _os_log_impl(&dword_1E1EA4000, v20, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)&v38, 0x26u);
    return 0;
  }
  int v7 = *(_DWORD *)(a1 + 88);
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (!v7)
  {
    if (ErrorLogLevelForModule < 8) {
      return 0;
    }
    uint64_t v24 = VRTraceErrorLogLevelToCSTR();
    uint64_t v20 = *MEMORY[0x1E4F47A50];
    uint64_t v25 = *MEMORY[0x1E4F47A50];
    if (!*MEMORY[0x1E4F47A40])
    {
      BOOL result = os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG);
      if (!result) {
        return result;
      }
      _VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal_cold_2();
      return 0;
    }
    BOOL v26 = os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v26) {
      return result;
    }
    int v38 = 136315906;
    uint64_t v39 = v24;
    __int16 v40 = 2080;
    uint64_t v41 = "_VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal";
    __int16 v42 = 1024;
    int v43 = 288;
    __int16 v44 = 2048;
    uint64_t v45 = a1;
    __int16 v23 = "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: destination info not ready";
    goto LABEL_15;
  }
  if (ErrorLogLevelForModule >= 8)
  {
    uint64_t v9 = VRTraceErrorLogLevelToCSTR();
    uint64_t v10 = *MEMORY[0x1E4F47A50];
    uint64_t v11 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = *(_DWORD *)(a1 + 96);
        int v13 = *(_DWORD *)(a1 + 64);
        uint64_t v14 = *(void *)(a1 + 48);
        uint64_t v15 = *(void *)(a1 + 56);
        int v16 = *(_DWORD *)(a1 + 88);
        uint64_t v17 = *(void *)(a1 + 72);
        uint64_t v18 = *(void *)(a1 + 80);
        int v38 = 136317954;
        uint64_t v39 = v9;
        __int16 v40 = 2080;
        uint64_t v41 = "_VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal";
        __int16 v42 = 1024;
        int v43 = 292;
        __int16 v44 = 2048;
        uint64_t v45 = a1;
        __int16 v46 = 1024;
        int v47 = v12;
        __int16 v48 = 1024;
        int v49 = v13;
        __int16 v50 = 2048;
        uint64_t v51 = v14;
        __int16 v52 = 1024;
        int v53 = v15;
        __int16 v54 = 1024;
        int v55 = a2;
        __int16 v56 = 1024;
        int v57 = v16;
        __int16 v58 = 2048;
        uint64_t v59 = v17;
        __int16 v60 = 1024;
        int v61 = v18;
        _os_log_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEFAULT, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: lastSrcRTP=%u srcSRRTP=%u srcSRNPT=%.9f srcRate=%d dstRTP=%u dstSrRTP=%u dstSRNTP=%.9f dstRate=%d", (uint8_t *)&v38, 0x5Eu);
      }
    }
    else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      int v31 = *(_DWORD *)(a1 + 96);
      int v32 = *(_DWORD *)(a1 + 64);
      uint64_t v33 = *(void *)(a1 + 48);
      uint64_t v34 = *(void *)(a1 + 56);
      int v35 = *(_DWORD *)(a1 + 88);
      uint64_t v36 = *(void *)(a1 + 72);
      uint64_t v37 = *(void *)(a1 + 80);
      int v38 = 136317954;
      uint64_t v39 = v9;
      __int16 v40 = 2080;
      uint64_t v41 = "_VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal";
      __int16 v42 = 1024;
      int v43 = 292;
      __int16 v44 = 2048;
      uint64_t v45 = a1;
      __int16 v46 = 1024;
      int v47 = v31;
      __int16 v48 = 1024;
      int v49 = v32;
      __int16 v50 = 2048;
      uint64_t v51 = v33;
      __int16 v52 = 1024;
      int v53 = v34;
      __int16 v54 = 1024;
      int v55 = a2;
      __int16 v56 = 1024;
      int v57 = v35;
      __int16 v58 = 2048;
      uint64_t v59 = v36;
      __int16 v60 = 1024;
      int v61 = v37;
      _os_log_debug_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEBUG, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: lastSrcRTP=%u srcSRRTP=%u srcSRNPT=%.9f srcRate=%d dstRTP=%u dstSrRTP=%u dstSRNTP=%.9f dstRate=%d", (uint8_t *)&v38, 0x5Eu);
    }
  }
  int v27 = *(_DWORD *)(a1 + 64)
      + (int)((*(double *)(a1 + 72)
             + (double)_VCMediaStreamSynchronizer_differenceBetweenRtpTimestamp(a2, *(_DWORD *)(a1 + 88))
             / (double)*(uint64_t *)(a1 + 80)
             - *(double *)(a1 + 48))
            * (double)*(uint64_t *)(a1 + 56));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    uint64_t v28 = VRTraceErrorLogLevelToCSTR();
    int v29 = *MEMORY[0x1E4F47A50];
    __int16 v30 = *MEMORY[0x1E4F47A50];
    if (*MEMORY[0x1E4F47A40])
    {
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        int v38 = 136316418;
        uint64_t v39 = v28;
        __int16 v40 = 2080;
        uint64_t v41 = "_VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal";
        __int16 v42 = 1024;
        int v43 = 297;
        __int16 v44 = 2048;
        uint64_t v45 = a1;
        __int16 v46 = 1024;
        int v47 = a2;
        __int16 v48 = 1024;
        int v49 = v27;
        _os_log_impl(&dword_1E1EA4000, v29, OS_LOG_TYPE_DEFAULT, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: DToS: %u->%u", (uint8_t *)&v38, 0x32u);
      }
    }
    else if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      int v38 = 136316418;
      uint64_t v39 = v28;
      __int16 v40 = 2080;
      uint64_t v41 = "_VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal";
      __int16 v42 = 1024;
      int v43 = 297;
      __int16 v44 = 2048;
      uint64_t v45 = a1;
      __int16 v46 = 1024;
      int v47 = a2;
      __int16 v48 = 1024;
      int v49 = v27;
      _os_log_debug_impl(&dword_1E1EA4000, v29, OS_LOG_TYPE_DEBUG, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: DToS: %u->%u", (uint8_t *)&v38, 0x32u);
    }
  }
  *a3 = v27;
  return 1;
}

BOOL VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestamp(uint64_t a1, int a2, _DWORD *a3)
{
  BOOL v3 = 0;
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a1 && a3)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2020000000;
    int v17 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = &v10;
    uint64_t v12 = 0x2020000000;
    char v13 = 0;
    uint64_t v5 = *(NSObject **)(a1 + 24);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestamp_block_invoke;
    block[3] = &unk_1E6DB90A8;
    block[4] = a1;
    void block[5] = &v10;
    int v9 = a2;
    void block[6] = &v14;
    dispatch_sync(v5, block);
    int v6 = *((unsigned __int8 *)v11 + 24);
    if (*((unsigned char *)v11 + 24)) {
      *a3 = *((_DWORD *)v15 + 6);
    }
    BOOL v3 = v6 != 0;
    _Block_object_dispose(&v10, 8);
    _Block_object_dispose(&v14, 8);
  }
  return v3;
}

BOOL VCMediaStreamSynchronizer_destRTPTimestampFromSourceRTPTimestamp(uint64_t a1, int a2, uint64_t a3)
{
  BOOL v3 = 0;
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a1 && a3)
  {
    uint64_t v8 = 0;
    int v9 = &v8;
    uint64_t v10 = 0x2020000000;
    char v11 = 0;
    double v4 = *(NSObject **)(a1 + 24);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __VCMediaStreamSynchronizer_destRTPTimestampFromSourceRTPTimestamp_block_invoke;
    block[3] = &unk_1E6DB5210;
    void block[5] = &v8;
    void block[6] = a3;
    int v7 = a2;
    block[4] = a1;
    dispatch_sync(v4, block);
    BOOL v3 = *((unsigned char *)v9 + 24) != 0;
    _Block_object_dispose(&v8, 8);
  }
  return v3;
}

void VCMediaStreamSynchronizer_setSourcePlayoutTimeUpdatedHandler(uint64_t a1, const void *a2)
{
  if (a1)
  {
    double v4 = (os_unfair_lock_s *)(a1 + 112);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
    _Block_release(*(const void **)(a1 + 104));
    *(void *)(a1 + 104) = _Block_copy(a2);
    os_unfair_lock_unlock(v4);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCMediaStreamSynchronizer_setSourcePlayoutTimeUpdatedHandler_cold_1();
    }
  }
}

void VCMediaStreamSyncSourceDelegate_updateSourceState(uint64_t a1, int a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = *(NSObject **)(a1 + 24);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __VCMediaStreamSyncSourceDelegate_updateSourceState_block_invoke;
    block[3] = &unk_1E6DB3F08;
    int v4 = a2;
    block[4] = a1;
    dispatch_async(v2, block);
  }
}

void VCMediaStreamSyncSourceDelegate_resetSourceState(uint64_t a1)
{
  v2[5] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (!*(_DWORD *)(a1 + 100))
    {
      unint64_t v1 = *(NSObject **)(a1 + 24);
      v2[0] = MEMORY[0x1E4F143A8];
      v2[1] = 3221225472;
      v2[2] = __VCMediaStreamSyncSourceDelegate_resetSourceState_block_invoke;
      v2[3] = &unk_1E6DB3DC8;
      v2[4] = a1;
      dispatch_async(v1, v2);
    }
  }
}

void VCMediaStreamSyncSourceDelegate_updateSourcePlayoutSampleRTPTimestamp(uint64_t a1, int a2, double a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v6 = VRTraceErrorLogLevelToCSTR();
      int v7 = *MEMORY[0x1E4F47A50];
      uint64_t v8 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316418;
          *(void *)&uint8_t buf[4] = v6;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "VCMediaStreamSyncSourceDelegate_updateSourcePlayoutSampleRTPTimestamp";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)BOOL v22 = 362;
          *(_WORD *)&v22[4] = 2048;
          *(void *)&v22[6] = a1;
          *(_WORD *)&v22[14] = 2048;
          *(double *)&v22[16] = a3;
          LOWORD(v23) = 1024;
          *(_DWORD *)((char *)&v23 + 2) = a2;
          _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: Received source (audio) frame. systemTime=%.6f playoutSampleRTPTimestamp=%u", buf, 0x36u);
        }
      }
      else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136316418;
        *(void *)&uint8_t buf[4] = v6;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "VCMediaStreamSyncSourceDelegate_updateSourcePlayoutSampleRTPTimestamp";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)BOOL v22 = 362;
        *(_WORD *)&v22[4] = 2048;
        *(void *)&v22[6] = a1;
        *(_WORD *)&v22[14] = 2048;
        *(double *)&v22[16] = a3;
        LOWORD(v23) = 1024;
        *(_DWORD *)((char *)&v23 + 2) = a2;
        _os_log_debug_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEBUG, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: Received source (audio) frame. systemTime=%.6f playoutSampleRTPTimestamp=%u", buf, 0x36u);
      }
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
    uint64_t v9 = *(void *)(a1 + 104);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
    if (v9)
    {
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x3810000000;
      *(_OWORD *)&v22[8] = *MEMORY[0x1E4F1F9F8];
      uint64_t v10 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
      *(void *)BOOL v22 = "";
      uint64_t v23 = v10;
      char v11 = *(NSObject **)(a1 + 24);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __VCMediaStreamSyncSourceDelegate_updateSourcePlayoutSampleRTPTimestamp_block_invoke;
      block[3] = &unk_1E6DB90D0;
      block[4] = a1;
      void block[5] = buf;
      int v20 = a2;
      *(double *)&void block[6] = a3;
      dispatch_sync(v11, block);
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
      uint64_t v12 = *(void *)(a1 + 104);
      if (v12)
      {
        uint64_t v17 = *(void *)(*(void *)&buf[8] + 48);
        long long v16 = *(_OWORD *)(*(void *)&buf[8] + 32);
        double v18 = a3;
        (*(void (**)(uint64_t, long long *))(v12 + 16))(v12, &v16);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
      _Block_object_dispose(buf, 8);
    }
    else
    {
      char v13 = *(NSObject **)(a1 + 24);
      v14[0] = MEMORY[0x1E4F143A8];
      v14[1] = 3221225472;
      void v14[2] = __VCMediaStreamSyncSourceDelegate_updateSourcePlayoutSampleRTPTimestamp_block_invoke_2;
      v14[3] = &unk_1E6DB3F58;
      unsigned int v14[4] = a1;
      int v15 = a2;
      *(double *)&v14[5] = a3;
      dispatch_async(v13, v14);
    }
  }
}

void sub_1E234152C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

CMTime *_VCMediaStreamSynchronizer_updateSourcePlayoutSampleRTPTimestampInternal@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, CMTime *a3@<X8>, double a4@<D0>)
{
  unsigned int v7 = *(_DWORD *)(a1 + 96);
  BOOL v8 = a2 >= v7;
  unsigned int v9 = a2 - v7;
  int v10 = *(_DWORD *)(a1 + 16);
  if (!v8 && v9 <= 0x7FFFFFFE) {
    *(_DWORD *)(a1 + 16) = ++v10;
  }
  *(_DWORD *)(a1 + 96) = a2;
  *(double *)(a1 + 8) = a4;
  VCVideoPlayer_CallAlarms(*(void *)(a1 + 32), a4, ((double)a2 + (double)v10 * 4294967300.0) / (double)*(uint64_t *)(a1 + 56));
  int64_t v12 = a2 | ((unint64_t)*(unsigned int *)(a1 + 16) << 32);
  int32_t v13 = [(id)a1 sourceSampleRate];

  return CMTimeMake(a3, v12, v13);
}

void VCMediaStreamSyncSourceDelegate_updateSourceNTPTimeWithRTPTimeStamp(uint64_t a1, int a2, double a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v6 = VRTraceErrorLogLevelToCSTR();
      unsigned int v7 = *MEMORY[0x1E4F47A50];
      BOOL v8 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316418;
          uint64_t v13 = v6;
          __int16 v14 = 2080;
          int v15 = "VCMediaStreamSyncSourceDelegate_updateSourceNTPTimeWithRTPTimeStamp";
          __int16 v16 = 1024;
          int v17 = 392;
          __int16 v18 = 2048;
          uint64_t v19 = a1;
          __int16 v20 = 2048;
          double v21 = a3;
          __int16 v22 = 1024;
          int v23 = a2;
          _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p] Received source (audio) ntpTime=%.6f rtpTimeStamp=%u", buf, 0x36u);
        }
      }
      else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136316418;
        uint64_t v13 = v6;
        __int16 v14 = 2080;
        int v15 = "VCMediaStreamSyncSourceDelegate_updateSourceNTPTimeWithRTPTimeStamp";
        __int16 v16 = 1024;
        int v17 = 392;
        __int16 v18 = 2048;
        uint64_t v19 = a1;
        __int16 v20 = 2048;
        double v21 = a3;
        __int16 v22 = 1024;
        int v23 = a2;
        _os_log_debug_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEBUG, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p] Received source (audio) ntpTime=%.6f rtpTimeStamp=%u", buf, 0x36u);
      }
    }
    unsigned int v9 = *(NSObject **)(a1 + 24);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __VCMediaStreamSyncSourceDelegate_updateSourceNTPTimeWithRTPTimeStamp_block_invoke;
    block[3] = &unk_1E6DB3F58;
    block[4] = a1;
    *(double *)&void block[5] = a3;
    int v11 = a2;
    dispatch_async(v9, block);
  }
}

size_t VCBoundsSafety_IndexableToNulTerminated(char *__s1, size_t a2)
{
  uint64_t v2 = __s1;
  if (!__s1) {
    return (size_t)v2;
  }
  size_t result = strnlen(__s1, a2);
  if (result == a2) {
    return 0;
  }
  uint64_t v5 = &v2[result];
  if (&v2[result] >= v2 && v5 + 1 >= v5 && v5 + 1 <= &v2[a2] && !*v5) {
    return (size_t)v2;
  }
  __break(0x5519u);
  return result;
}

void _VCBoundsSafety_ReleaseAssignAndRetain(const void **a1, CFTypeRef cf)
{
  if (a1)
  {
    int v4 = *a1;
    if (v4) {
      CFRelease(v4);
    }
    if (cf) {
      CFRetain(cf);
    }
    *a1 = cf;
  }
}

void *VCBoundsSafety_AllocatorAllocate(const __CFAllocator *a1, CFIndex a2, CFOptionFlags a3)
{
  return CFAllocatorAllocate(a1, a2, a3);
}

uint64_t VCPacketInitialize(uint64_t a1)
{
  if (!a1) {
    return 2150957057;
  }
  uint64_t result = 0;
  *(void *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

uint64_t VCPacketInvalidate(uint64_t *a1)
{
  uint64_t result = 2150957057;
  if (a1)
  {
    if (a1[20])
    {
      return 2150957118;
    }
    else
    {
      uint64_t result = *a1;
      if (*a1)
      {
        CFRelease((CFTypeRef)result);
        uint64_t result = 0;
        *a1 = 0;
      }
    }
  }
  return result;
}

uint64_t VCRealTimeThread_Initialize(int a1, uint64_t a2, uint64_t a3, const char *a4, int a5)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!a2 || !a3 || !a4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v12 = VRTraceErrorLogLevelToCSTR();
      uint64_t v13 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        int v15 = 136316418;
        uint64_t v16 = v12;
        __int16 v17 = 2080;
        __int16 v18 = "VCRealTimeThread_Initialize";
        __int16 v19 = 1024;
        int v20 = 63;
        __int16 v21 = 2048;
        uint64_t v22 = a2;
        __int16 v23 = 2048;
        uint64_t v24 = a3;
        __int16 v25 = 2048;
        BOOL v26 = a4;
        _os_log_error_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_ERROR, " [%s] %s:%d called with invalid parameter: routine=%p context=%p identifier=%p", (uint8_t *)&v15, 0x3Au);
      }
    }
    return 0;
  }
  int v10 = malloc_type_calloc(1uLL, 0xB0uLL, 0x10A0040640140D7uLL);
  if (!v10)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCRealTimeThread_Initialize_cold_1();
      }
    }
    return 0;
  }
  uint64_t v11 = (uint64_t)v10;
  *(void *)int v10 = 0;
  *((void *)v10 + 10) = a2;
  *((void *)v10 + 11) = a3;
  *((_DWORD *)v10 + 42) = a1;
  *((_DWORD *)v10 + 43) = a5;
  *((_DWORD *)v10 + 26) = -1;
  strncpy((char *)v10 + 108, a4, 0x3CuLL);
  pthread_mutex_init((pthread_mutex_t *)(v11 + 8), 0);
  *(void *)(v11 + 72) = dispatch_semaphore_create(0);
  if ((VCRealTimeThread_ChangeState(v11, 1) & 1) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCRealTimeThread_Initialize_cold_2();
      }
    }
    dispatch_release(*(dispatch_object_t *)(v11 + 72));
    pthread_mutex_destroy((pthread_mutex_t *)(v11 + 8));
    free((void *)v11);
    return 0;
  }
  return v11;
}

uint64_t VCRealTimeThread_ChangeState(uint64_t a1, int a2)
{
  values[2] = *(void **)MEMORY[0x1E4F143B8];
  int v4 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  switch(*(_DWORD *)a1)
  {
    case 0:
      if (!a2 || a2 == 3) {
        goto LABEL_38;
      }
      if (a2 != 1) {
        goto LABEL_27;
      }
      CFStringRef v5 = CFStringCreateWithFormat(0, 0, @"%s", a1 + 108);
      uint64_t v6 = *MEMORY[0x1E4F21EB0];
      *(void *)keys = *MEMORY[0x1E4F21EA8];
      *(void *)&keys[8] = v6;
      unsigned int v7 = (void *)*MEMORY[0x1E4F1CFC8];
      values[0] = (void *)v5;
      values[1] = v7;
      if (*(_DWORD *)(a1 + 172)) {
        CFIndex v8 = 2;
      }
      else {
        CFIndex v8 = 1;
      }
      CFDictionaryRef v9 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)values, v8, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      int v10 = FigThreadCreate();
      if (v10
        && (int)VRTraceGetErrorLogLevelForModule() >= 3
        && (VRTraceErrorLogLevelToCSTR(), os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)))
      {
        VCRealTimeThread_ChangeState_cold_1();
        if (!v9)
        {
LABEL_13:
          if (v5) {
            CFRelease(v5);
          }
          if (v10) {
            goto LABEL_27;
          }
          goto LABEL_38;
        }
      }
      else if (!v9)
      {
        goto LABEL_13;
      }
      CFRelease(v9);
      goto LABEL_13;
    case 1:
      switch(a2)
      {
        case 1:
          goto LABEL_38;
        case 2:
          int v15 = VTP_Socket(2, 1, 0);
          *(_DWORD *)(a1 + 104) = v15;
          if (v15 != -1) {
            goto LABEL_37;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              VCRealTimeThread_ChangeState_cold_2();
            }
          }
          if (*(_DWORD *)(a1 + 104) != -1)
          {
LABEL_37:
            *(_DWORD *)(a1 + 4) |= 2u;
            dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 72));
LABEL_38:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              uint64_t v16 = VRTraceErrorLogLevelToCSTR();
              __int16 v17 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                int v18 = *(_DWORD *)a1;
                *(_DWORD *)keys = 136316162;
                *(void *)&keys[4] = v16;
                *(_WORD *)&keys[12] = 2080;
                *(void *)&keys[14] = "VCRealTimeThread_ChangeState";
                __int16 v22 = 1024;
                int v23 = 313;
                __int16 v24 = 1024;
                int v25 = v18;
                __int16 v26 = 1024;
                int v27 = a2;
                _os_log_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Successful thread state transition: %d -> %d", keys, 0x28u);
              }
            }
            *(_DWORD *)a1 = a2;
            uint64_t v14 = 1;
            goto LABEL_42;
          }
          break;
        case 3:
LABEL_31:
          VCRealTimeThread_InternalStop(a1);
          goto LABEL_38;
      }
LABEL_27:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v12 = VRTraceErrorLogLevelToCSTR();
        uint64_t v13 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          int v20 = *(_DWORD *)a1;
          *(_DWORD *)keys = 136316162;
          *(void *)&keys[4] = v12;
          *(_WORD *)&keys[12] = 2080;
          *(void *)&keys[14] = "VCRealTimeThread_ChangeState";
          __int16 v22 = 1024;
          int v23 = 316;
          __int16 v24 = 1024;
          int v25 = v20;
          __int16 v26 = 1024;
          int v27 = a2;
          _os_log_error_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_ERROR, " [%s] %s:%d Thread state transition failed: %d -> %d", keys, 0x28u);
        }
      }
      uint64_t v14 = 0;
LABEL_42:
      pthread_mutex_unlock(v4);
      return v14;
    case 2:
      if (a2 == 3) {
        goto LABEL_31;
      }
      if (a2 == 2) {
        goto LABEL_38;
      }
      if (a2 != 1) {
        goto LABEL_27;
      }
      *(_DWORD *)(a1 + 4) |= 1u;
      int v11 = *(_DWORD *)(a1 + 104);
      if (v11 != -1)
      {
        VTP_Close(v11);
        *(_DWORD *)(a1 + 104) = -1;
      }
      goto LABEL_38;
    case 3:
      if (a2 != 3) {
        goto LABEL_27;
      }
      goto LABEL_38;
    default:
      goto LABEL_27;
  }
}

void VCRealTimeThread_Finalize(uint64_t a1)
{
  if (a1)
  {
    VCRealTimeThread_ChangeState(a1, 3);
    if (*(void *)(a1 + 96))
    {
      FigThreadJoin();
      *(void *)(a1 + 96) = 0;
    }
    dispatch_release(*(dispatch_object_t *)(a1 + 72));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 8));
    free((void *)a1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRealTimeThread_Finalize_cold_1();
    }
  }
}

uint64_t VCRealTimeThread_Start(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      uint64_t v3 = VRTraceErrorLogLevelToCSTR();
      int v4 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v6 = 136315906;
        uint64_t v7 = v3;
        __int16 v8 = 2080;
        CFDictionaryRef v9 = "VCRealTimeThread_Start";
        __int16 v10 = 1024;
        int v11 = 120;
        __int16 v12 = 2080;
        uint64_t v13 = a1 + 108;
        _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ### VCRealTimeThread_Start(%s) called!", (uint8_t *)&v6, 0x26u);
      }
    }
    return VCRealTimeThread_ChangeState(a1, 2);
  }
  else
  {
    if (ErrorLogLevelForModule >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCRealTimeThread_Start_cold_1();
    }
    return 0;
  }
}

uint64_t VCRealTimeThread_Stop(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      uint64_t v3 = VRTraceErrorLogLevelToCSTR();
      int v4 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v6 = 136315906;
        uint64_t v7 = v3;
        __int16 v8 = 2080;
        CFDictionaryRef v9 = "VCRealTimeThread_Stop";
        __int16 v10 = 1024;
        int v11 = 130;
        __int16 v12 = 2080;
        uint64_t v13 = a1 + 108;
        _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ### VCRealTimeThread_Stop(%s) called!", (uint8_t *)&v6, 0x26u);
      }
    }
    return VCRealTimeThread_ChangeState(a1, 1);
  }
  else
  {
    if (ErrorLogLevelForModule >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCRealTimeThread_Stop_cold_1();
    }
    return 0;
  }
}

uint64_t VCRealTimeThread_InternalStop(uint64_t a1)
{
  *(_DWORD *)(a1 + 4) |= 4u;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 72));
  uint64_t result = *(unsigned int *)(a1 + 104);
  if (result != -1)
  {
    uint64_t result = VTP_Close(result);
    *(_DWORD *)(a1 + 104) = -1;
  }
  return result;
}

uint64_t VCRealTimeThread_ThreadProc(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  int v3 = *(_DWORD *)(a1 + 4);
  pthread_mutex_unlock(v2);
  uint64_t v4 = a1 + 108;
  pthread_setname_np((const char *)(a1 + 108));
  if ((*(unsigned char *)(a1 + 172) & 2) != 0)
  {
    if (proc_setthread_cpupercent())
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCRealTimeThread_ThreadProc_cold_1();
        }
      }
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v5 = VRTraceErrorLogLevelToCSTR();
    int v6 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      uint64_t v22 = v5;
      __int16 v23 = 2080;
      __int16 v24 = "VCRealTimeThread_ThreadProc";
      __int16 v25 = 1024;
      int v26 = 178;
      __int16 v27 = 2080;
      uint64_t v28 = a1 + 108;
      _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ### VCRealTimeThread_ThreadProc(%s) start!", buf, 0x26u);
    }
  }
  int v20 = -1;
  if ((v3 & 4) == 0)
  {
    uint64_t v7 = (os_log_t *)MEMORY[0x1E4F47A50];
    do
    {
      while ((*(unsigned char *)(a1 + 4) & 6) == 0)
        dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 72), 0xFFFFFFFFFFFFFFFFLL);
      int v20 = *(_DWORD *)(a1 + 104);
      pthread_mutex_lock(v2);
      int v8 = *(_DWORD *)(a1 + 4);
      LOBYTE(v9) = v8 & 0xFD;
      *(_DWORD *)(a1 + 4) = v8 & 0xFFFFFFFD;
      pthread_mutex_unlock(v2);
      if (v20 == -1)
      {
        pthread_mutex_lock(v2);
        *(_DWORD *)(a1 + 4) &= ~1u;
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v10 = VRTraceErrorLogLevelToCSTR();
          int v11 = *v7;
          if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            uint64_t v22 = v10;
            __int16 v23 = 2080;
            __int16 v24 = "VCRealTimeThread_ThreadProc";
            __int16 v25 = 1024;
            int v26 = 194;
            __int16 v27 = 2080;
            uint64_t v28 = a1 + 108;
            _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ### VCRealTimeThread_ThreadProc(%s) running!", buf, 0x26u);
          }
        }
        char v19 = 0;
        if ((v8 & 5) == 0)
        {
          do
          {
            (*(void (**)(void, int *, char *))(a1 + 80))(*(void *)(a1 + 88), &v20, &v19);
            pthread_mutex_lock(v2);
            int v12 = *(_DWORD *)(a1 + 4);
            pthread_mutex_unlock(v2);
          }
          while ((v12 & 5) == 0 && v19 == 0);
          if (v19) {
            VCRealTimeThread_ChangeState(a1, 1);
          }
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v14 = VRTraceErrorLogLevelToCSTR();
          int v15 = *v7;
          if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            uint64_t v22 = v14;
            __int16 v23 = 2080;
            __int16 v24 = "VCRealTimeThread_ThreadProc";
            __int16 v25 = 1024;
            int v26 = 205;
            __int16 v27 = 2080;
            uint64_t v28 = a1 + 108;
            _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ### VCRealTimeThread_ThreadProc(%s) pausing!", buf, 0x26u);
          }
        }
        pthread_mutex_lock(v2);
        unsigned int v9 = *(_DWORD *)(a1 + 4) & 0xFFFFFFFE;
        *(_DWORD *)(a1 + 4) = v9;
      }
      pthread_mutex_unlock(v2);
    }
    while ((v9 & 4) == 0);
  }
  pthread_mutex_lock(v2);
  *(_DWORD *)(a1 + 4) &= ~4u;
  pthread_mutex_unlock(v2);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v16 = VRTraceErrorLogLevelToCSTR();
    __int16 v17 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      uint64_t v22 = v16;
      __int16 v23 = 2080;
      __int16 v24 = "VCRealTimeThread_ThreadProc";
      __int16 v25 = 1024;
      int v26 = 210;
      __int16 v27 = 2080;
      uint64_t v28 = v4;
      _os_log_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ### VCRealTimeThread_ThreadProc(%s) stop!", buf, 0x26u);
    }
  }
  return 0;
}

uint64_t VCCCMessageWrapperReadFrom(uint64_t a1, uint64_t a2)
{
  int v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 2)
      {
        [(id)a1 clearOneofValuesForContent];
        *(unsigned char *)(a1 + 32) |= 1u;
        *(_DWORD *)(a1 + 16) = 2;
        __int16 v24 = objc_alloc_init(VCCCMessageAcknowledgment);

        *(void *)(a1 + 8) = v24;
        if (!PBReaderPlaceMark() || (VCCCMessageAcknowledgmentReadFrom((uint64_t)v24, a2) & 1) == 0) {
          return 0;
        }
      }
      else
      {
        if (v17 != 1)
        {
          if (v17)
          {
            uint64_t result = PBReaderSkipValueWithTag();
            if (!result) {
              return result;
            }
          }
          else
          {
            unsigned int v18 = 0;
            while (1)
            {
              uint64_t v19 = *v3;
              unint64_t v20 = *(void *)(a2 + v19);
              if (v20 == -1 || v20 >= *(void *)(a2 + *v4)) {
                break;
              }
              unint64_t v21 = v20 + 1;
              int v22 = *(char *)(*(void *)(a2 + *v7) + v20);
              *(void *)(a2 + v19) = v21;
              if (v22 < 0 && v18++ <= 8) {
                continue;
              }
              goto LABEL_37;
            }
            *(unsigned char *)(a2 + *v5) = 1;
          }
          continue;
        }
        [(id)a1 clearOneofValuesForContent];
        *(unsigned char *)(a1 + 32) |= 1u;
        *(_DWORD *)(a1 + 16) = 1;
        __int16 v25 = objc_alloc_init(VCCCMessage);

        *(void *)(a1 + 24) = v25;
        if (!PBReaderPlaceMark() || (VCCCMessageReadFrom((uint64_t)v25, a2) & 1) == 0) {
          return 0;
        }
      }
      PBReaderRecallMark();
LABEL_37:
      ;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void *VCStreamInputUtil_EncodeFormatDescription(const opaqueCMFormatDescription *a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  if (!v2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCStreamInputUtil_EncodeFormatDescription_cold_1();
      }
    }
    return 0;
  }
  int v3 = v2;
  if (!_VCStreamInputUtil_AddFormatDescription(v2, a1))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCStreamInputUtil_EncodeFormatDescription_cold_2();
      }
    }
    xpc_release(v3);
    return 0;
  }
  return v3;
}

BOOL _VCStreamInputUtil_AddFormatDescription(void *a1, CMFormatDescriptionRef desc)
{
  Mediaint Type = CMFormatDescriptionGetMediaType(desc);
  if (!_VCStreamInputUtil_AddUint32Value(a1, "VCStreamInputMediaType", MediaType))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v15 = VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      _VCStreamInputUtil_AddFormatDescription_cold_8(v15, MediaType);
    }
    return 0;
  }
  MediaSubint Type = CMFormatDescriptionGetMediaSubType(desc);
  if (!_VCStreamInputUtil_AddUint32Value(a1, "VCStreamInputMediaSubtype", MediaSubType))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v16 = VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      _VCStreamInputUtil_AddFormatDescription_cold_7(v16, MediaType);
    }
    return 0;
  }
  if (MediaType == 1835365473) {
    return 1;
  }
  if (MediaType == 1936684398)
  {
    StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(desc);
    if (StreamBasicDescription)
    {
      xpc_object_t v12 = xpc_data_create(StreamBasicDescription, 0x28uLL);
      if (v12)
      {
        unsigned int v9 = v12;
        unint64_t v10 = "VCStreamInputFormatASBD";
        goto LABEL_14;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        _VCStreamInputUtil_AddFormatDescription_cold_6();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      _VCStreamInputUtil_AddFormatDescription_cold_5();
    }
    return 0;
  }
  if (MediaType != 1986618469)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v14 = VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      _VCStreamInputUtil_AddFormatDescription_cold_1(v14, MediaType);
    }
    return 0;
  }
  CMVideoDimensions Dimensions = CMVideoFormatDescriptionGetDimensions(desc);
  int32_t height = Dimensions.height;
  if (!_VCStreamInputUtil_AddUint32Value(a1, "VCStreamInputPixelBufferWidth", Dimensions.width))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      _VCStreamInputUtil_AddFormatDescription_cold_4();
    }
    return 0;
  }
  if (!_VCStreamInputUtil_AddUint32Value(a1, "VCStreamInputPixelBufferHeight", height))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      _VCStreamInputUtil_AddFormatDescription_cold_3();
    }
    return 0;
  }
  if (!CMFormatDescriptionGetExtensions(desc)) {
    return 1;
  }
  uint64_t v8 = _CFXPCCreateXPCObjectFromCFObject();
  if (v8)
  {
    unsigned int v9 = (void *)v8;
    unint64_t v10 = "VCStreamInputFormatExtensions";
LABEL_14:
    xpc_dictionary_set_value(a1, v10, v9);
    xpc_release(v9);
    return 1;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
    return 0;
  }
  VRTraceErrorLogLevelToCSTR();
  BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
  if (result)
  {
    _VCStreamInputUtil_AddFormatDescription_cold_2();
    return 0;
  }
  return result;
}

void *VCStreamInputUtil_EncodeSampleBuffer(opaqueCMSampleBuffer *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  FormatDescription = CMSampleBufferGetFormatDescription(a1);
  Mediaint Type = CMFormatDescriptionGetMediaType(FormatDescription);
  uint64_t v4 = 0;
  if (MediaType > 1952807027)
  {
    if (MediaType == 1952807028) {
      goto LABEL_22;
    }
    if (MediaType != 1986618469) {
      return v4;
    }
    ImageBuffer = CMSampleBufferGetImageBuffer(a1);
    timingInfoOut.decodeTimeStamp.CMTimeEpoch epoch = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&timingInfoOut.presentationTimeStamp.timescale = v7;
    *(_OWORD *)&timingInfoOut.decodeTimeStamp.xpc_object_t value = v7;
    *(_OWORD *)&timingInfoOut.duration.xpc_object_t value = v7;
    *(_OWORD *)&timingInfoOut.duration.CMTimeEpoch epoch = v7;
    CMSampleBufferGetSampleTimingInfo(a1, 0, &timingInfoOut);
    CMFormatDescriptionRef v8 = CMSampleBufferGetFormatDescription(a1);
    CMTime presentationTimeStamp = timingInfoOut.presentationTimeStamp;
    if (ImageBuffer)
    {
      unsigned int v9 = v8;
      xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
      if (v10)
      {
        uint64_t v4 = v10;
        IOSurface = CVPixelBufferGetIOSurface(ImageBuffer);
        if (IOSurface)
        {
          xpc_object_t XPCObject = IOSurfaceCreateXPCObject(IOSurface);
          if (XPCObject)
          {
            char v13 = XPCObject;
            xpc_dictionary_set_value(v4, "VCStreamInputPixelBuffer", XPCObject);
            CMTime v18 = presentationTimeStamp;
            if (_VCStreamInputUtil_AddTime(v4, &v18))
            {
              if (_VCStreamInputUtil_AddFormatDescription(v4, v9))
              {
LABEL_17:
                CFRelease(v13);
                BOOL v14 = _VCStreamInputUtil_EncodeSampleBufferAttachments(a1, v4);
                if (!v4 || v14) {
                  return v4;
                }
                goto LABEL_19;
              }
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  VCStreamInputUtil_EncodeSampleBuffer_cold_5();
                }
              }
            }
            else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                VCStreamInputUtil_EncodeSampleBuffer_cold_6();
              }
            }
            CFRelease(v4);
            uint64_t v4 = 0;
            goto LABEL_17;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              VCStreamInputUtil_EncodeSampleBuffer_cold_4();
            }
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCStreamInputUtil_EncodeSampleBuffer_cold_3();
          }
        }
        CFRelease(v4);
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCStreamInputUtil_EncodeSampleBuffer_cold_2();
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCStreamInputUtil_EncodeSampleBuffer_cold_1();
      }
    }
    _VCStreamInputUtil_EncodeSampleBufferAttachments(a1, 0);
    return 0;
  }
  if (MediaType != 1835365473)
  {
    if (MediaType == 1936684398)
    {
      uint64_t v4 = _VCStreamInputUtil_EncodeDataSampleBuffer(a1);
      if (!v4)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCStreamInputUtil_EncodeSampleBuffer_cold_7();
          }
        }
        goto LABEL_19;
      }
      int NumSamples = CMSampleBufferGetNumSamples(a1);
      if (!_VCStreamInputUtil_AddUint32Value(v4, "VCStreamInputFormatSampleCount", NumSamples))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCStreamInputUtil_EncodeSampleBuffer_cold_8();
          }
        }
LABEL_19:
        xpc_release(v4);
        return 0;
      }
    }
    return v4;
  }
LABEL_22:

  return _VCStreamInputUtil_EncodeDataSampleBuffer(a1);
}

void *_VCStreamInputUtil_EncodeDataSampleBuffer(opaqueCMSampleBuffer *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  DataBuffer = CMSampleBufferGetDataBuffer(a1);
  if (!DataBuffer)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_EncodeDataSampleBuffer_cold_1();
      }
    }
    return 0;
  }
  int v3 = DataBuffer;
  Dataint Length = CMBlockBufferGetDataLength(DataBuffer);
  if (!DataLength)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_EncodeDataSampleBuffer_cold_2();
      }
    }
    return 0;
  }
  size_t v5 = DataLength;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  long long v7 = (UInt8 *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], DataLength, 0);
  if (!v7)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_EncodeDataSampleBuffer_cold_3();
      }
    }
    return 0;
  }
  CMFormatDescriptionRef v8 = v7;
  if (CMBlockBufferCopyDataBytes(v3, 0, v5, v7))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_EncodeDataSampleBuffer_cold_10();
      }
    }
    return 0;
  }
  CFDataRef v9 = CFDataCreateWithBytesNoCopy(v6, v8, v5, v6);
  if (!v9)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_EncodeDataSampleBuffer_cold_4();
      }
    }
    return 0;
  }
  CFDataRef v10 = v9;
  CMFormatDescriptionRef FormatDescription = CMSampleBufferGetFormatDescription(a1);
  if (!FormatDescription)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_EncodeDataSampleBuffer_cold_5();
      }
    }
    goto LABEL_37;
  }
  xpc_object_t v12 = FormatDescription;
  xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
  if (!v13)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_EncodeDataSampleBuffer_cold_6();
      }
    }
LABEL_37:
    BOOL v14 = 0;
    goto LABEL_38;
  }
  BOOL v14 = v13;
  memset(&v20, 170, sizeof(v20));
  CMSampleBufferGetPresentationTimeStamp(&v20, a1);
  CMTime v19 = v20;
  if (_VCStreamInputUtil_AddTime(v14, &v19))
  {
    if (_VCStreamInputUtil_AddFormatDescription(v14, v12))
    {
      uint64_t v15 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      if (v15)
      {
        uint64_t v16 = v15;
        xpc_dictionary_set_value(v14, "VCStreamInputBufferData", v15);
        BOOL v17 = !_VCStreamInputUtil_EncodeSampleBufferAttachments(a1, v14);
        CFRelease(v10);
        xpc_release(v16);
        if (!v17) {
          return v14;
        }
        goto LABEL_12;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCStreamInputUtil_EncodeDataSampleBuffer_cold_7();
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_EncodeDataSampleBuffer_cold_8();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      _VCStreamInputUtil_EncodeDataSampleBuffer_cold_9();
    }
  }
LABEL_38:
  CFRelease(v10);
LABEL_12:
  if (v14)
  {
    xpc_release(v14);
    return 0;
  }
  return v14;
}

CMAudioFormatDescriptionRef VCStreamInputUtil_DecodeFormatDescription(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  int v10 = -1431655766;
  if (!_VCStreamInputUtil_ReadUint32Value(a1, "VCStreamInputMediaType", &v10))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCStreamInputUtil_DecodeFormatDescription_cold_10();
      }
    }
    return 0;
  }
  if (v10 == 1835365473)
  {
    mediaSubint Type = -1431655766;
    buffer.mSampleRate = 0.0;
    if (!_VCStreamInputUtil_ReadUint32Value(a1, "VCStreamInputMediaSubtype", &mediaSubType))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCStreamInputUtil_DecodeFormatDescription_cold_8();
        }
      }
      return *(CMAudioFormatDescriptionRef *)&buffer.mSampleRate;
    }
    if (xpc_dictionary_get_value(a1, "VCStreamInputFormatExtensions"))
    {
      CFDictionaryRef v2 = (const __CFDictionary *)_CFXPCCreateCFObjectFromXPCObject();
      if (!v2)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCStreamInputUtil_DecodeFormatDescription_cold_7();
          }
        }
        return *(CMAudioFormatDescriptionRef *)&buffer.mSampleRate;
      }
    }
    else
    {
      CFDictionaryRef v2 = 0;
    }
    if (CMFormatDescriptionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0x6D657461u, mediaSubType, v2, (CMFormatDescriptionRef *)&buffer))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCStreamInputUtil_DecodeFormatDescription_cold_6();
        }
      }
    }
    goto LABEL_30;
  }
  if (v10 != 1936684398)
  {
    if (v10 == 1986618469)
    {
      mediaSubint Type = -1431655766;
      LODWORD(formatDescriptionOut) = -1431655766;
      codecint Type = -1431655766;
      buffer.mSampleRate = 0.0;
      if (!_VCStreamInputUtil_ReadUint32Value(a1, "VCStreamInputMediaSubtype", &codecType))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCStreamInputUtil_DecodeFormatDescription_cold_5();
          }
        }
        return *(CMAudioFormatDescriptionRef *)&buffer.mSampleRate;
      }
      if (!_VCStreamInputUtil_ReadUint32Value(a1, "VCStreamInputPixelBufferWidth", &mediaSubType))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCStreamInputUtil_DecodeFormatDescription_cold_4();
          }
        }
        return *(CMAudioFormatDescriptionRef *)&buffer.mSampleRate;
      }
      if (!_VCStreamInputUtil_ReadUint32Value(a1, "VCStreamInputPixelBufferHeight", &formatDescriptionOut))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCStreamInputUtil_DecodeFormatDescription_cold_3();
          }
        }
        return *(CMAudioFormatDescriptionRef *)&buffer.mSampleRate;
      }
      if (xpc_dictionary_get_value(a1, "VCStreamInputFormatExtensions"))
      {
        CFDictionaryRef v2 = (const __CFDictionary *)_CFXPCCreateCFObjectFromXPCObject();
        if (!v2)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              VCStreamInputUtil_DecodeFormatDescription_cold_2();
            }
          }
          return *(CMAudioFormatDescriptionRef *)&buffer.mSampleRate;
        }
      }
      else
      {
        CFDictionaryRef v2 = 0;
      }
      if (CMVideoFormatDescriptionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], codecType, mediaSubType, (int32_t)formatDescriptionOut, v2, (CMVideoFormatDescriptionRef *)&buffer))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            VCStreamInputUtil_DecodeFormatDescription_cold_1();
          }
        }
      }
LABEL_30:
      if (v2) {
        CFRelease(v2);
      }
      return *(CMAudioFormatDescriptionRef *)&buffer.mSampleRate;
    }
    return 0;
  }
  CMAudioFormatDescriptionRef formatDescriptionOut = 0;
  xpc_object_t value = xpc_dictionary_get_value(a1, "VCStreamInputFormatASBD");
  if (value)
  {
    buffer.mSampleRate = NAN;
    *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&buffer.mFormatID = v4;
    *(_OWORD *)&buffer.mBytesPerFrame = v4;
    if (xpc_data_get_bytes(value, &buffer, 0, 0x28uLL) == 40)
    {
      OSStatus v5 = CMAudioFormatDescriptionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &buffer, 0, 0, 0, 0, 0, &formatDescriptionOut);
      if (v5)
      {
        OSStatus v7 = v5;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v8 = VRTraceErrorLogLevelToCSTR();
          CFDataRef v9 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            mediaSubint Type = 136315906;
            uint64_t v15 = v8;
            __int16 v16 = 2080;
            BOOL v17 = "_VCStreamInputUtil_DecodeAudioFormat";
            __int16 v18 = 1024;
            int v19 = 397;
            __int16 v20 = 1024;
            OSStatus v21 = v7;
            _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Failed to create format description from XPC dictionary. status=%d", (uint8_t *)&mediaSubType, 0x22u);
          }
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCStreamInputUtil_DecodeFormatDescription_cold_9();
      }
    }
  }
  return formatDescriptionOut;
}

BOOL _VCStreamInputUtil_ReadUint32Value(void *a1, const char *a2, void *a3)
{
  if (!xpc_dictionary_get_value(a1, a2))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      _VCStreamInputUtil_ReadUint32Value_cold_1();
    }
    return 0;
  }
  CFNumberRef v4 = (const __CFNumber *)_CFXPCCreateCFObjectFromXPCObject();
  if (v4)
  {
    CFNumberRef v5 = v4;
    CFNumberGetValue(v4, kCFNumberSInt32Type, a3);
    CFRelease(v5);
    return 1;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
    return 0;
  }
  VRTraceErrorLogLevelToCSTR();
  BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
  if (result)
  {
    _VCStreamInputUtil_ReadUint32Value_cold_2();
    return 0;
  }
  return result;
}

CMSampleBufferRef VCStreamInputUtil_DecodeSampleBuffer(void *a1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  int v25 = 0;
  if (!_VCStreamInputUtil_ReadUint32Value(a1, "VCStreamInputMediaType", &v25))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCStreamInputUtil_DecodeSampleBuffer_cold_6();
      }
    }
    return 0;
  }
  if (v25 > 1952807027)
  {
    if (v25 == 1952807028) {
      return (CMSampleBufferRef)_VCStreamInputUtil_DecodeDataSampleBuffer(a1, 1);
    }
    if (v25 != 1986618469) {
      goto LABEL_26;
    }
    CMSampleBufferRef sampleBufferOut = 0;
    *(void *)CVPixelBufferRef pixelBufferOut = 0;
    xpc_object_t value = xpc_dictionary_get_value(a1, "VCStreamInputPixelBuffer");
    CFNumberRef v4 = IOSurfaceLookupFromXPCObject(value);
    if (!v4) {
      goto LABEL_56;
    }
    CFNumberRef v5 = v4;
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CVReturn v7 = CVPixelBufferCreateWithIOSurface((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, 0, (CVPixelBufferRef *)pixelBufferOut);
    if (v7)
    {
      CVReturn v8 = v7;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v9 = VRTraceErrorLogLevelToCSTR();
        int v10 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.duration.value) = 136315906;
          *(CMTimeValue *)((char *)&buf.duration.value + 4) = v9;
          LOWORD(buf.duration.flags) = 2080;
          *(void *)((char *)&buf.duration.flags + 2) = "_VCStreamInputUtil_DecodePixelBuffer";
          HIWORD(buf.duration.epoch) = 1024;
          LODWORD(buf.presentationTimeStamp.value) = 321;
          WORD2(buf.presentationTimeStamp.value) = 1024;
          *(_DWORD *)((char *)&buf.presentationTimeStamp.value + 6) = v8;
          _os_log_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Could not recreate pixel buffer from surface: %d", (uint8_t *)&buf, 0x22u);
        }
      }
    }
    CFRelease(v5);
    uint64_t v11 = *(__CVBuffer **)pixelBufferOut;
    if (*(void *)pixelBufferOut)
    {
      CMAudioFormatDescriptionRef v12 = VCStreamInputUtil_DecodeFormatDescription(a1);
      if (v12)
      {
        xpc_object_t v13 = v12;
        buf.decodeTimeStamp.CMTimeEpoch epoch = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&buf.decodeTimeStamp.xpc_object_t value = v14;
        *(_OWORD *)&buf.duration.CMTimeEpoch epoch = v14;
        *(_OWORD *)&buf.presentationTimeStamp.timescale = v14;
        *(_OWORD *)&buf.duration.xpc_object_t value = v14;
        memset(&v26, 170, sizeof(v26));
        if (_VCStreamInputUtil_DecodeTime(a1, &v26))
        {
          buf.CMTime presentationTimeStamp = v26;
          OSStatus v15 = CMSampleBufferCreateForImageBuffer(v6, v11, 1u, 0, 0, v13, &buf, &sampleBufferOut);
          if (!v15)
          {
            CFDictionaryRef v16 = (const __CFDictionary *)_VCStreamInputUtil_DecodeSampleBufferAttachments(a1);
            if (v16) {
              CMSetAttachments(sampleBufferOut, v16, 1u);
            }
            goto LABEL_23;
          }
          OSStatus v22 = v15;
          if ((int)VRTraceGetErrorLogLevelForModule() < 7
            || (uint64_t v23 = VRTraceErrorLogLevelToCSTR(),
                __int16 v24 = *MEMORY[0x1E4F47A50],
                !os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)))
          {
LABEL_53:
            CFDictionaryRef v16 = 0;
LABEL_23:
            CVPixelBufferRelease(v11);
            CFRelease(v13);
            if (v16) {
              CFRelease(v16);
            }
            return sampleBufferOut;
          }
          *(_DWORD *)CVPixelBufferRef pixelBufferOut = 136315906;
          *(void *)&pixelBufferOut[4] = v23;
          __int16 v29 = 2080;
          __int16 v30 = "_VCStreamInputUtil_DecodeVideoSampleBuffer";
          __int16 v31 = 1024;
          int v32 = 469;
          __int16 v33 = 1024;
          OSStatus v34 = v22;
          int v19 = " [%s] %s:%d Could not recreate sample buffer from xpcDictionary. status=%d";
          __int16 v20 = v24;
          uint32_t v21 = 34;
        }
        else
        {
          if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
            goto LABEL_53;
          }
          uint64_t v17 = VRTraceErrorLogLevelToCSTR();
          __int16 v18 = *MEMORY[0x1E4F47A50];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_53;
          }
          *(_DWORD *)CVPixelBufferRef pixelBufferOut = 136315650;
          *(void *)&pixelBufferOut[4] = v17;
          __int16 v29 = 2080;
          __int16 v30 = "_VCStreamInputUtil_DecodeVideoSampleBuffer";
          __int16 v31 = 1024;
          int v32 = 465;
          int v19 = " [%s] %s:%d Failed to retrieve the time";
          __int16 v20 = v18;
          uint32_t v21 = 28;
        }
        _os_log_impl(&dword_1E1EA4000, v20, OS_LOG_TYPE_DEFAULT, v19, pixelBufferOut, v21);
        goto LABEL_53;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCStreamInputUtil_DecodeSampleBuffer_cold_3();
        }
      }
    }
    else
    {
LABEL_56:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCStreamInputUtil_DecodeSampleBuffer_cold_2();
        }
      }
      uint64_t v11 = 0;
    }
    CVPixelBufferRelease(v11);
    return sampleBufferOut;
  }
  if (v25 == 1835365473) {
    return (CMSampleBufferRef)_VCStreamInputUtil_DecodeDataSampleBuffer(a1, 1);
  }
  if (v25 != 1936684398)
  {
LABEL_26:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCStreamInputUtil_DecodeSampleBuffer_cold_1();
      }
    }
    return 0;
  }
  LODWORD(buf.duration.value) = -1431655766;
  if (!_VCStreamInputUtil_ReadUint32Value(a1, "VCStreamInputFormatSampleCount", &buf))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCStreamInputUtil_DecodeSampleBuffer_cold_5();
      }
    }
    return 0;
  }
  CMSampleBufferRef result = (CMSampleBufferRef)_VCStreamInputUtil_DecodeDataSampleBuffer(a1, LODWORD(buf.duration.value));
  if (!result)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCStreamInputUtil_DecodeSampleBuffer_cold_4();
      }
    }
    return 0;
  }
  return result;
}

CMAttachmentBearerRef _VCStreamInputUtil_DecodeDataSampleBuffer(void *a1, CMItemCount a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  CMAttachmentBearerRef target = 0;
  *(void *)CMBlockBufferRef blockBufferOut = 0;
  if (!xpc_dictionary_get_value(a1, "VCStreamInputBufferData"))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_DecodeDataSampleBuffer_cold_2();
      }
    }
    goto LABEL_22;
  }
  CFDataRef v4 = (const __CFData *)_CFXPCCreateCFObjectFromXPCObject();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_DecodeDataSampleBuffer_cold_3();
      }
    }
    goto LABEL_22;
  }
  CFDataRef v5 = v4;
  CFIndex Length = CFDataGetLength(v4);
  CVReturn v7 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (Length <= 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_DecodeDataSampleBuffer_cold_6();
      }
    }
  }
  else
  {
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v9 = (UInt8 *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Length, 0);
    if (v9)
    {
      int v10 = v9;
      v33.length = CFDataGetLength(v5);
      v33.location = 0;
      CFDataGetBytes(v5, v33, v10);
      if (CMBlockBufferCreateWithMemoryBlock(v8, v10, Length, v8, 0, 0, Length, 0, (CMBlockBufferRef *)blockBufferOut))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _VCStreamInputUtil_DecodeDataSampleBuffer_cold_8();
          }
        }
        CFAllocatorDeallocate(v8, v10);
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_DecodeDataSampleBuffer_cold_7();
      }
    }
  }
  CFRelease(v5);
  uint64_t v11 = *(OpaqueCMBlockBuffer **)blockBufferOut;
  if (!*(void *)blockBufferOut)
  {
LABEL_22:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_DecodeDataSampleBuffer_cold_1();
      }
    }
    return target;
  }
  CMAudioFormatDescriptionRef v12 = VCStreamInputUtil_DecodeFormatDescription(a1);
  if (!v12)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_DecodeDataSampleBuffer_cold_4();
      }
    }
    uint64_t v17 = v11;
    goto LABEL_14;
  }
  xpc_object_t v13 = v12;
  memset(&v23, 170, sizeof(v23));
  if (!_VCStreamInputUtil_DecodeTime(a1, &v23))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_DecodeDataSampleBuffer_cold_5();
      }
    }
    goto LABEL_45;
  }
  *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&sampleTimingArray.decodeTimeStamp.xpc_object_t value = v14;
  *(_OWORD *)&sampleTimingArray.duration.xpc_object_t value = v14;
  sampleTimingArray.duration.CMTimeEpoch epoch = 0xAAAAAAAAAAAAAAAALL;
  sampleTimingArray.CMTime presentationTimeStamp = v23;
  sampleTimingArray.decodeTimeStamp.CMTimeEpoch epoch = 0xAAAAAAAAAAAAAAAALL;
  OSStatus v15 = CMSampleBufferCreate(*v7, v11, 1u, 0, 0, v13, a2, 1, &sampleTimingArray, 0, 0, (CMSampleBufferRef *)&target);
  if (v15)
  {
    OSStatus v19 = v15;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v20 = VRTraceErrorLogLevelToCSTR();
      uint32_t v21 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)CMBlockBufferRef blockBufferOut = 136315906;
        *(void *)&blockBufferOut[4] = v20;
        __int16 v26 = 2080;
        __int16 v27 = "_VCStreamInputUtil_DecodeDataSampleBuffer";
        __int16 v28 = 1024;
        int v29 = 502;
        __int16 v30 = 1024;
        OSStatus v31 = v19;
        _os_log_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Could not recreate sample buffer from xpcDictionary: %d", blockBufferOut, 0x22u);
      }
    }
LABEL_45:
    CFDictionaryRef v16 = 0;
    goto LABEL_12;
  }
  CFDictionaryRef v16 = (const __CFDictionary *)_VCStreamInputUtil_DecodeSampleBufferAttachments(a1);
  if (v16) {
    CMSetAttachments(target, v16, 1u);
  }
LABEL_12:
  CFRelease(v11);
  CFRelease(v13);
  if (v16)
  {
    uint64_t v17 = v16;
LABEL_14:
    CFRelease(v17);
  }
  return target;
}

BOOL _VCStreamInputUtil_AddUint32Value(void *a1, const char *a2, int a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  int valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  if (v5)
  {
    CFNumberRef v6 = v5;
    CVReturn v7 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    BOOL v8 = v7 != 0;
    if (v7)
    {
      uint64_t v9 = v7;
      xpc_dictionary_set_value(a1, a2, v7);
      xpc_release(v9);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_AddUint32Value_cold_2();
      }
    }
    CFRelease(v6);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_AddUint32Value_cold_1();
      }
    }
    return 0;
  }
  return v8;
}

BOOL _VCStreamInputUtil_EncodeSampleBufferAttachments(CMAttachmentBearerRef target, void *a2)
{
  BOOL v3 = 1;
  CFDictionaryRef v4 = CMCopyDictionaryOfAttachments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], target, 1u);
  if (v4)
  {
    CFDictionaryRef v5 = v4;
    CFNumberRef v6 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    BOOL v3 = v6 != 0;
    if (v6)
    {
      CVReturn v7 = v6;
      xpc_dictionary_set_value(a2, "VCStreamInputSampleBufferAttachments", v6);
      xpc_release(v7);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_EncodeSampleBufferAttachments_cold_1();
      }
    }
    CFRelease(v5);
  }
  return v3;
}

BOOL _VCStreamInputUtil_AddTime(void *a1, CMTime *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CMTime v10 = *a2;
  CFDictionaryRef v4 = CMTimeCopyAsDictionary(&v10, v3);
  if (v4)
  {
    CFDictionaryRef v5 = v4;
    CFNumberRef v6 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    BOOL v7 = v6 != 0;
    if (v6)
    {
      BOOL v8 = v6;
      xpc_dictionary_set_value(a1, "VCStreamInputPresentationTime", v6);
      xpc_release(v8);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_AddTime_cold_2();
      }
    }
    CFRelease(v5);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCStreamInputUtil_AddTime_cold_1();
      }
    }
    return 0;
  }
  return v7;
}

BOOL _VCStreamInputUtil_DecodeTime(void *a1, CMTime *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  xpc_dictionary_get_value(a1, "VCStreamInputPresentationTime");
  CFDictionaryRef v3 = (const __CFDictionary *)_CFXPCCreateCFObjectFromXPCObject();
  CFDictionaryRef v4 = v3;
  if (v3)
  {
    CMTimeMakeFromDictionary(&v8, v3);
    *a2 = v8;
    CFRelease(v4);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v5 = VRTraceErrorLogLevelToCSTR();
    CFNumberRef v6 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v8.value) = 136315650;
      *(CMTimeValue *)((char *)&v8.value + 4) = v5;
      LOWORD(v8.flags) = 2080;
      *(void *)((char *)&v8.flags + 2) = "_VCStreamInputUtil_DecodeTime";
      HIWORD(v8.epoch) = 1024;
      int v9 = 333;
      _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Could not retrieve the time information", (uint8_t *)&v8, 0x1Cu);
    }
  }
  return v4 != 0;
}

uint64_t _VCStreamInputUtil_DecodeSampleBufferAttachments(void *a1)
{
  uint64_t result = (uint64_t)xpc_dictionary_get_value(a1, "VCStreamInputSampleBufferAttachments");
  if (result)
  {
    uint64_t result = _CFXPCCreateCFObjectFromXPCObject();
    if (!result)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCStreamInputUtil_DecodeSampleBufferAttachments_cold_1();
        }
      }
      return 0;
    }
  }
  return result;
}

void _VCRateControlBandwidthEstimator_UpdateQualificationParameters(uint64_t a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  int v2 = *(_DWORD *)(a1 + 396);
  if ((*(_DWORD *)(a1 + 392) - 5) > 1)
  {
    switch(v2)
    {
      case 3:
        uint64_t v5 = 0x415312D000000000;
        break;
      case 5:
        uint64_t v5 = 0x416312D000000000;
        break;
      case 8:
      case 9:
        if (*(_DWORD *)(a1 + 432) == 105566000) {
          uint64_t v5 = 0x41992B3CC0000000;
        }
        else {
          uint64_t v5 = 0x418C9C3800000000;
        }
        break;
      default:
        uint64_t v5 = 0x4158CBA800000000;
        break;
    }
    *(void *)(a1 + 360) = v5;
    *(void *)(a1 + 352) = 0x3F80624DD2F1A9FCLL;
    if (*(unsigned char *)(a1 + 404)) {
      int v3 = 0;
    }
    else {
      int v3 = 3;
    }
  }
  else
  {
    int v3 = 0;
    if (v2 == 3) {
      int v4 = 800000;
    }
    else {
      int v4 = 400000;
    }
    *(double *)(a1 + 360) = (double)v4;
    *(void *)(a1 + 352) = 0x3F60624DD2F1A9FCLL;
  }
  *(_DWORD *)(a1 + 368) = v3;
  *(_DWORD *)(a1 + 344) = 1;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v6 = VRTraceErrorLogLevelToCSTR();
    BOOL v7 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v8 = *(_DWORD *)(a1 + 392);
      int v9 = *(_DWORD *)(a1 + 396);
      uint64_t v11 = *(void *)(a1 + 352);
      uint64_t v10 = *(void *)(a1 + 360);
      int v12 = *(_DWORD *)(a1 + 368);
      int v13 = *(_DWORD *)(a1 + 344);
      int v14 = 136317186;
      uint64_t v15 = v6;
      __int16 v16 = 2080;
      uint64_t v17 = "_VCRateControlBandwidthEstimator_UpdateQualificationParameters";
      __int16 v18 = 1024;
      int v19 = 319;
      __int16 v20 = 1024;
      int v21 = v8;
      __int16 v22 = 1024;
      int v23 = v9;
      __int16 v24 = 2048;
      uint64_t v25 = v10;
      __int16 v26 = 2048;
      uint64_t v27 = v11;
      __int16 v28 = 1024;
      int v29 = v12;
      __int16 v30 = 1024;
      int v31 = v13;
      _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Bandwidth Estimation: Update bandwidth estimator qualification parameters with RAT=%d, mode=%d. [maxBW:%f, minWin:%f, maxOverRange:%d, minPacketCount:%d]", (uint8_t *)&v14, 0x48u);
    }
  }
}

void VCRateControlBandwidthEstimator_SetRadioAccessTechnology(uint64_t a1, int a2)
{
  if (a1)
  {
    *(_DWORD *)(a1 + 392) = a2;
    _VCRateControlBandwidthEstimator_UpdateQualificationParameters(a1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlBandwidthEstimator_SetRadioAccessTechnology_cold_1();
    }
  }
}

void VCRateControlBandwidthEstimator_SetEstimatedBandwidth(uint64_t a1, double a2)
{
  if (a1)
  {
    *(double *)(a1 + 376) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlBandwidthEstimator_SetEstimatedBandwidth_cold_1();
    }
  }
}

void VCRateControlBandwidthEstimator_SetFastSuddenBandwidthDetectionEnabled(uint64_t a1, char a2)
{
  if (a1)
  {
    *(unsigned char *)(a1 + 404) = a2;
    _VCRateControlBandwidthEstimator_UpdateQualificationParameters(a1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlBandwidthEstimator_SetFastSuddenBandwidthDetectionEnabled_cold_1();
    }
  }
}

void VCRateControlBandwidthEstimator_CalculateBandwidthEstimation(uint64_t a1, int a2, unsigned int a3, int a4, int a5, double a6)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (*(unsigned char *)(a1 + 52))
    {
      if (!a4) {
        goto LABEL_18;
      }
    }
    else
    {
      *(_WORD *)(a1 + 52) = 1;
      int v11 = a5 - 1;
      if (!a4) {
        int v11 = a2;
      }
      *(_DWORD *)(a1 + 60) = v11;
      *(double *)(a1 + 64) = a6;
      *(void *)(a1 + 72) = 0;
      if (!a4) {
        goto LABEL_18;
      }
    }
    if (*(_DWORD *)(a1 + 60) == a5)
    {
      if (*(double *)(a1 + 16) <= a6) {
        double v12 = a6;
      }
      else {
        double v12 = *(double *)(a1 + 16);
      }
      int32x2_t v13 = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)(a3 | 0x100000000));
      *(int32x2_t *)(a1 + 8) = v13;
      *(double *)(a1 + 16) = v12;
      if (!a5)
      {
        unsigned int v14 = 0;
        unsigned int v15 = 0;
        double v16 = 0.0;
        double v17 = 0.0;
        goto LABEL_36;
      }
      if (v13.i32[0]) {
        goto LABEL_43;
      }
      unsigned int v14 = 0;
      unsigned int v15 = 0;
      double v16 = 0.0;
      double v17 = 0.0;
      goto LABEL_29;
    }
LABEL_18:
    unsigned int v14 = *(_DWORD *)(a1 + 8);
    if (v14 <= *(_DWORD *)(a1 + 416))
    {
      unsigned int v15 = 0;
      unsigned int v14 = 0;
      double v17 = 0.0;
      double v16 = 0.0;
    }
    else
    {
      unsigned int v15 = *(_DWORD *)(a1 + 12);
      double v16 = *(double *)(a1 + 16) - *(double *)(a1 + 24);
      double v17 = (double)(8 * v14) / v16;
    }
    int v18 = a5;
    if ((a4 & 1) == 0)
    {
      double v19 = *(double *)(a1 + 32);
      BOOL v20 = v19 <= 0.0 || v19 <= a6;
      int v18 = a2;
      if (!v20)
      {
        int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (ErrorLogLevelForModule >= 7)
        {
          uint64_t v23 = VRTraceErrorLogLevelToCSTR();
          __int16 v24 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            int v26 = *(_DWORD *)(a1 + 40);
            int v25 = *(_DWORD *)(a1 + 44);
            *(_DWORD *)CMSampleTimingInfo buf = 136316162;
            uint64_t v36 = v23;
            __int16 v37 = 2080;
            int v38 = "VCRateControlBandwidthEstimator_CalculateBandwidthEstimation";
            __int16 v39 = 1024;
            int v40 = 229;
            __int16 v41 = 1024;
            int v42 = v25;
            __int16 v43 = 1024;
            int v44 = v26;
            _os_log_impl(&dword_1E1EA4000, v24, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Probing sequence head is late, early probing sequence packet number: %d, bytes:%d", buf, 0x28u);
          }
        }
        *(void *)(a1 + 8) = *(void *)(a1 + 40);
        *(_DWORD *)(a1 + 60) = a2;
        *(double *)(a1 + 24) = a6;
        *(_DWORD *)(a1 + 48) = a3;
        *(void *)(a1 + 16) = 0;
        if (a5)
        {
LABEL_37:
          if (v17 > 0.0)
          {
            *(double *)(a1 + 384) = v17;
            if (*(double *)(a1 + 376) != 0.0)
            {
              double v27 = 0.0;
              if (*(_DWORD *)(a1 + 344) > v15 || *(_DWORD *)(a1 + 416) > v14) {
                goto LABEL_42;
              }
              if (*(double *)(a1 + 352) <= v16)
              {
                *(_DWORD *)(a1 + 320) = 0;
              }
              else
              {
                unsigned int v34 = *(_DWORD *)(a1 + 320) + 1;
                *(_DWORD *)(a1 + 320) = v34;
                if (v34 < *(_DWORD *)(a1 + 368)) {
                  goto LABEL_42;
                }
              }
            }
            double v27 = v17;
LABEL_42:
            _VCRateControlBandwidthEstimator_UpdateBandwidthEstimation(a1, v27, a6);
            VRLogfilePrintWithTimestamp(*(void *)(a1 + 424), "Bandwidth Estimation: ArrivalTime:%.4f, timestamp:%u, BWD:%.2f, state:%d, divergeCount:%d, prob_seq:[duration:%.4f, size:%d, count:%d], EstimatedBandwidth:%.2f\n", v28, v29, v30, v31, v32, v33, SLOBYTE(a6));
          }
LABEL_43:
          *(_DWORD *)(a1 + 56) = a2;
          return;
        }
LABEL_36:
        *(void *)(a1 + 32) = 0;
        *(void *)(a1 + 40) = 0;
        goto LABEL_37;
      }
    }
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 60) = v18;
    *(double *)(a1 + 24) = a6;
    *(_DWORD *)(a1 + 48) = a3;
    if (!a5) {
      goto LABEL_36;
    }
    if ((a4 & 1) == 0) {
      goto LABEL_37;
    }
LABEL_29:
    int32x2_t v21 = vadd_s32(*(int32x2_t *)(a1 + 40), (int32x2_t)(a3 | 0x100000000));
    *(double *)(a1 + 32) = a6;
    *(int32x2_t *)(a1 + 40) = v21;
    goto LABEL_37;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlBandwidthEstimator_CalculateBandwidthEstimation_cold_1();
    }
  }
}

double _VCRateControlBandwidthEstimator_UpdateBandwidthEstimation(uint64_t a1, double a2, double a3)
{
  double v3 = a2;
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (a2 <= 0.0)
  {
    int v11 = 6;
    goto LABEL_9;
  }
  double v6 = *(double *)(a1 + 360);
  if (v6 <= v3) {
    double v3 = *(double *)(a1 + 360);
  }
  unsigned int v7 = *(_DWORD *)(a1 + 392) - 5;
  if (v7 > 1 || *(unsigned char *)(a1 + 53))
  {
    [*(id *)(a1 + 336) setMargin:200000];
    [*(id *)(a1 + 336) setMinSamplesCount:3];
    [*(id *)(a1 + 336) setMinMarginRequired:0];
    [*(id *)(a1 + 336) setDurationThresholdUpward:0.0];
    [*(id *)(a1 + 336) setDurationThresholdDownward:0.0];
    int v8 = *(_DWORD *)(a1 + 392);
    if ((v8 - 5) >= 2)
    {
      if (v8 != 1) {
        goto LABEL_14;
      }
      [*(id *)(a1 + 336) setMinSamplesCount:4];
      double v10 = 4.0;
      double v9 = 4.0;
    }
    else
    {
      [*(id *)(a1 + 336) setMinSamplesCount:6];
      [*(id *)(a1 + 336) setMinMarginRequired:100000];
      double v9 = 7.0;
      double v10 = 10.0;
    }
    [*(id *)(a1 + 336) setDurationThresholdUpward:v10];
    [*(id *)(a1 + 336) setDurationThresholdDownward:v9];
LABEL_14:
    [*(id *)(a1 + 336) percentage];
    double v14 = 1.0 - v13;
    double v15 = *(double *)(a1 + 376);
    BOOL v16 = v14 * v15 >= v3 || v15 - v3 > (double)(int)[*(id *)(a1 + 336) margin];
    [*(id *)(a1 + 336) percentage];
    double v18 = v17 + 1.0;
    double v19 = *(double *)(a1 + 376);
    if (v18 * v19 <= v3)
    {
      BOOL v20 = 1;
      if (!v16) {
        goto LABEL_22;
      }
    }
    else
    {
      BOOL v20 = v3 - v19 > (double)(int)[*(id *)(a1 + 336) margin];
      double v19 = *(double *)(a1 + 376);
      if (!v16)
      {
LABEL_22:
        if (v20)
        {
          BOOL v21 = v3 - v19 > (double)(int)[*(id *)(a1 + 336) minMarginRequired];
          double v19 = *(double *)(a1 + 376);
        }
        else
        {
          BOOL v21 = 0;
        }
        if (v19 == 0.0)
        {
          double v22 = 100000.0;
          if (v3 >= 100000.0) {
            double v22 = v3;
          }
          *(double *)(a1 + 376) = v22;
          *(_DWORD *)(a1 + 400) = 0;
          unsigned int IntValueForKey = VCDefaults_GetIntValueForKey(@"forcedInitialBandwidthEstimation", 0);
          if (IntValueForKey)
          {
            unsigned int v24 = IntValueForKey;
            *(double *)(a1 + 376) = (double)IntValueForKey;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              uint64_t v25 = VRTraceErrorLogLevelToCSTR();
              int v26 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                int v46 = 136315906;
                uint64_t v47 = v25;
                __int16 v48 = 2080;
                int v49 = "_VCRateControlBandwidthEstimator_UpdateBandwidthEstimation";
                __int16 v50 = 1024;
                int v51 = 368;
                __int16 v52 = 1024;
                unsigned int v53 = v24;
                _os_log_impl(&dword_1E1EA4000, v26, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Forced initial bandwidth estimation:%d by default", (uint8_t *)&v46, 0x22u);
              }
            }
          }
          return v3;
        }
        if (!v21 && !v16)
        {
          if (v7 > 1)
          {
            double v39 = v3 * 0.1;
            double v40 = 0.9;
          }
          else
          {
            uint64_t v36 = *(unsigned int *)(a1 + 76);
            if ((int)v36 >= 1)
            {
              __int16 v37 = (double *)(a1 + 80);
              do
              {
                double v38 = *v37++;
                double v19 = v38 * 0.05 + v19 * 0.95;
                *(double *)(a1 + 376) = v19;
                --v36;
              }
              while (v36);
            }
            *(_DWORD *)(a1 + 76) = 0;
            double v39 = v3 * 0.075;
            double v40 = 0.925;
          }
          *(double *)(a1 + 376) = v39 + v19 * v40;
          *(_DWORD *)(a1 + 72) = 0;
          *(void *)(a1 + 328) = 0;
          int v11 = 1;
          goto LABEL_9;
        }
        if (v7 <= 1)
        {
          uint64_t v27 = *(int *)(a1 + 76);
          if ((int)v27 <= 29)
          {
            *(double *)(a1 + 8 * v27 + 80) = v3;
            *(_DWORD *)(a1 + 76) = v27 + 1;
          }
        }
        BOOL v28 = 0;
        unsigned int v29 = *(_DWORD *)(a1 + 392);
        if (v29 <= 6 && ((1 << v29) & 0x62) != 0)
        {
          double v30 = a3 - *(double *)(a1 + 64);
          uint64_t v31 = *(void **)(a1 + 336);
          if ((*(_DWORD *)(a1 + 72) & 0x80000000) != 0) {
            [v31 durationThresholdDownward];
          }
          else {
            [v31 durationThresholdUpward];
          }
          BOOL v28 = v30 < v32;
        }
        int v41 = *(_DWORD *)(a1 + 72);
        if (v16)
        {
          if (v41 < 0)
          {
            --v41;
            int v42 = 3;
          }
          else
          {
            *(void *)(a1 + 328) = 0;
            *(double *)(a1 + 64) = a3;
            int v42 = 3;
            int v41 = -1;
          }
        }
        else
        {
          if (!v21)
          {
LABEL_64:
            *(double *)(a1 + 328) = v3 + *(double *)(a1 + 328);
            if (v41 >= 0) {
              int v43 = v41;
            }
            else {
              int v43 = -v41;
            }
            int v44 = v43 < (int)[*(id *)(a1 + 336) minSamplesCount] || v28;
            if (v44 == 1
              && (!*(unsigned char *)(a1 + 404)
               || v43 < (int)[*(id *)(a1 + 336) minSamplesCountFastBandwidthEstimation]))
            {
              return v3;
            }
            double v45 = *(double *)(a1 + 328) / (double)v43;
            if (v7 <= 1 && (*(_DWORD *)(a1 + 72) & 0x80000000) == 0) {
              double v45 = v45 * 0.9 + *(double *)(a1 + 376) * 0.1;
            }
            *(double *)(a1 + 376) = v45;
            *(_DWORD *)(a1 + 72) = 0;
            *(void *)(a1 + 328) = 0;
            int v11 = 4;
LABEL_9:
            *(_DWORD *)(a1 + 400) = v11;
            return v3;
          }
          if (v41 <= 0)
          {
            *(void *)(a1 + 328) = 0;
            *(double *)(a1 + 64) = a3;
            int v42 = 2;
            int v41 = 1;
          }
          else
          {
            ++v41;
            int v42 = 2;
          }
        }
        *(_DWORD *)(a1 + 72) = v41;
        *(_DWORD *)(a1 + 400) = v42;
        goto LABEL_64;
      }
    }
    BOOL v16 = v19 - v3 > (double)(int)[*(id *)(a1 + 336) minMarginRequired];
    double v19 = *(double *)(a1 + 376);
    goto LABEL_22;
  }
  double v33 = v6 * 0.5;
  if (v33 > v3) {
    double v33 = v3;
  }
  int v34 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 72) = v34 + 1;
  double v35 = v33 + *(double *)(a1 + 328);
  *(double *)(a1 + 328) = v35;
  if (v34 > 8 || a3 - *(double *)(a1 + 64) >= 7.0)
  {
    *(unsigned char *)(a1 + 53) = 1;
    *(double *)(a1 + 376) = v35 / (double)(v34 + 1);
    *(void *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 72) = 0;
  }
  *(_DWORD *)(a1 + 400) = 0;
  return v3;
}

void VCRateControlBandwidthEstimator_CalculateBandwidthEstimationForBandwidthSample(uint64_t a1, double a2, double a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2 > 0.0)
    {
      *(double *)(a1 + 384) = a2;
      double updated = _VCRateControlBandwidthEstimator_UpdateBandwidthEstimation(a1, a2, a3);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        uint64_t v6 = VRTraceErrorLogLevelToCSTR();
        unsigned int v7 = *MEMORY[0x1E4F47A50];
        int v8 = *MEMORY[0x1E4F47A50];
        if (*MEMORY[0x1E4F47A40])
        {
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            int v9 = *(_DWORD *)(a1 + 400);
            int v10 = *(_DWORD *)(a1 + 72);
            uint64_t v11 = *(void *)(a1 + 376);
            int v15 = 136316930;
            uint64_t v16 = v6;
            __int16 v17 = 2080;
            double v18 = "VCRateControlBandwidthEstimator_CalculateBandwidthEstimationForBandwidthSample";
            __int16 v19 = 1024;
            int v20 = 278;
            __int16 v21 = 2048;
            double v22 = updated;
            __int16 v23 = 2048;
            double v24 = a3;
            __int16 v25 = 1024;
            int v26 = v9;
            __int16 v27 = 1024;
            int v28 = v10;
            __int16 v29 = 2048;
            uint64_t v30 = v11;
            _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Bandwidth Estimation(BWD:%.2f): ArrivalTime:%.4f, state:%d, divergeCount:%d, EstimatedBandwidth:%.2f", (uint8_t *)&v15, 0x46u);
          }
        }
        else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          int v12 = *(_DWORD *)(a1 + 400);
          int v13 = *(_DWORD *)(a1 + 72);
          uint64_t v14 = *(void *)(a1 + 376);
          int v15 = 136316930;
          uint64_t v16 = v6;
          __int16 v17 = 2080;
          double v18 = "VCRateControlBandwidthEstimator_CalculateBandwidthEstimationForBandwidthSample";
          __int16 v19 = 1024;
          int v20 = 278;
          __int16 v21 = 2048;
          double v22 = updated;
          __int16 v23 = 2048;
          double v24 = a3;
          __int16 v25 = 1024;
          int v26 = v12;
          __int16 v27 = 1024;
          int v28 = v13;
          __int16 v29 = 2048;
          uint64_t v30 = v14;
          _os_log_debug_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEBUG, "VCRC [%s] %s:%d Bandwidth Estimation(BWD:%.2f): ArrivalTime:%.4f, state:%d, divergeCount:%d, EstimatedBandwidth:%.2f", (uint8_t *)&v15, 0x46u);
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlBandwidthEstimator_CalculateBandwidthEstimationForBandwidthSample_cold_1();
    }
  }
}

uint64_t VCRateControlBandwidthEstimatorMap_BandwidthEstimator(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCRateControlBandwidthEstimatorMap_BandwidthEstimator_cold_1();
      }
    }
    return 0;
  }
  uint64_t v5 = *(VCRateControlBandwidthEstimator **)(a1 + 56);
  if (v5) {
    BOOL v6 = (*(_DWORD *)(a1 + 16) - 6) >= 0xFFFFFFFE;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    return (uint64_t)v5;
  }
  int v7 = a2;
  int v8 = *(_DWORD *)(a1 + 8);
  if (v8 == 2)
  {
    uint64_t v5 = 0;
    if ((a3 ^ 1 | a4) != 1 || *(_DWORD *)(a1 + 48) != a2) {
      return (uint64_t)v5;
    }
    goto LABEL_23;
  }
  if (v8 != 1)
  {
    if (!v8 && a3)
    {
      *(_DWORD *)(a1 + 8) = 1;
      *(_DWORD *)(a1 + 48) = a2;
    }
    goto LABEL_24;
  }
  if (*(_DWORD *)(a1 + 48) != a2)
  {
    uint64_t v5 = 0;
    *(_DWORD *)(a1 + 8) = 2;
    return (uint64_t)v5;
  }
  if (!a3 || a4) {
LABEL_23:
  }
    *(_DWORD *)(a1 + 8) = 0;
LABEL_24:
  uint64_t v10 = [NSNumber numberWithUnsignedInt:a2];
  if (![*(id *)(a1 + 40) objectForKeyedSubscript:v10])
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v12 = VRTraceErrorLogLevelToCSTR();
      int v13 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v14 = 136315906;
        uint64_t v15 = v12;
        __int16 v16 = 2080;
        __int16 v17 = "VCRateControlBandwidthEstimatorMap_BandwidthEstimator";
        __int16 v18 = 1024;
        int v19 = 597;
        __int16 v20 = 1024;
        int v21 = v7;
        _os_log_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Create bandwidth estimator for estimator id: %d", (uint8_t *)&v14, 0x22u);
      }
    }
    uint64_t v5 = objc_alloc_init(VCRateControlBandwidthEstimator);
    [(VCRateControlBandwidthEstimator *)v5 setMode:*(unsigned int *)(a1 + 16)];
    [(VCRateControlBandwidthEstimator *)v5 setMaxBitrateForBandwidthEstimator:*(unsigned int *)(a1 + 12)];
    VCRateControlBandwidthEstimator_SetRadioAccessTechnology((uint64_t)v5, *(_DWORD *)(a1 + 20));
    VCRateControlBandwidthEstimator_SetFastSuddenBandwidthDetectionEnabled((uint64_t)v5, *(unsigned char *)(a1 + 68));
    [(VCRateControlBandwidthEstimator *)v5 setServerBag:*(void *)(a1 + 72)];
    if (*(void *)(a1 + 80)) {
      -[VCRateControlBandwidthEstimator enableBWELogDump:](v5, "enableBWELogDump:");
    }
    [*(id *)(a1 + 40) setObject:v5 forKeyedSubscript:v10];
    if (!*(void *)(a1 + 56)) {
      *(void *)(a1 + 56) = v5;
    }

    return (uint64_t)v5;
  }
  uint64_t v11 = *(void **)(a1 + 40);

  return [v11 objectForKeyedSubscript:v10];
}

void VCRateControlBandwidthEstimatorMap_DeregisterBandwidthEstimator(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      uint64_t v5 = VRTraceErrorLogLevelToCSTR();
      BOOL v6 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v7 = 136315906;
        uint64_t v8 = v5;
        __int16 v9 = 2080;
        uint64_t v10 = "VCRateControlBandwidthEstimatorMap_DeregisterBandwidthEstimator";
        __int16 v11 = 1024;
        int v12 = 620;
        __int16 v13 = 1024;
        int v14 = a2;
        _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Remove bandwidth estimator for estimator id: %d", (uint8_t *)&v7, 0x22u);
      }
    }
    if (*(_DWORD *)(a1 + 48) == a2) {
      *(_DWORD *)(a1 + 8) = 0;
    }
    objc_msgSend(*(id *)(a1 + 40), "removeObjectForKey:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", a2));
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlBandwidthEstimatorMap_DeregisterBandwidthEstimator_cold_1();
    }
  }
}

void VCRateControlBandwidthEstimatorMap_EstimatedBandwidthWithArrivalTime(uint64_t a1, double a2)
{
  void v6[6] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    double v3 = *(void **)(a1 + 56);
    if (v3) {
      BOOL v4 = (*(_DWORD *)(a1 + 16) - 6) > 0xFFFFFFFD;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4)
    {
      *(void *)(a1 + 24) = 0;
      uint64_t v5 = *(void **)(a1 + 40);
      v6[0] = MEMORY[0x1E4F143A8];
      v6[1] = 3221225472;
      uint64_t v6[2] = __VCRateControlBandwidthEstimatorMap_EstimatedBandwidthWithArrivalTime_block_invoke;
      v6[3] = &unk_1E6DB9138;
      *(double *)&v6[5] = a2;
      v6[4] = a1;
      [v5 enumerateKeysAndObjectsUsingBlock:v6];
    }
    else
    {
      [v3 estimatedBandwidth];
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlBandwidthEstimatorMap_EstimatedBandwidthWithArrivalTime_cold_1();
    }
  }
}

void VCRateControlBandwidthEstimatorMap_EstimatedBandwidthUncappedWithArrivalTime(uint64_t a1, double a2)
{
  void v6[6] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    double v3 = *(void **)(a1 + 56);
    if (v3) {
      BOOL v4 = (*(_DWORD *)(a1 + 16) - 6) > 0xFFFFFFFD;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4)
    {
      *(void *)(a1 + 32) = 0;
      uint64_t v5 = *(void **)(a1 + 40);
      v6[0] = MEMORY[0x1E4F143A8];
      v6[1] = 3221225472;
      uint64_t v6[2] = __VCRateControlBandwidthEstimatorMap_EstimatedBandwidthUncappedWithArrivalTime_block_invoke;
      v6[3] = &unk_1E6DB9138;
      *(double *)&v6[5] = a2;
      v6[4] = a1;
      [v5 enumerateKeysAndObjectsUsingBlock:v6];
    }
    else
    {
      [v3 estimatedBandwidthUncapped];
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlBandwidthEstimatorMap_EstimatedBandwidthUncappedWithArrivalTime_cold_1();
    }
  }
}

void VCRateControlBandwidthEstimatorMap_SetEstimatedBandwidth(uint64_t a1, double a2)
{
  _OWORD v5[5] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(double *)(a1 + 24) = a2;
    if (*(void *)(a1 + 56)) {
      BOOL v2 = (*(_DWORD *)(a1 + 16) - 6) > 0xFFFFFFFD;
    }
    else {
      BOOL v2 = 1;
    }
    if (v2)
    {
      double v3 = *(void **)(a1 + 40);
      v5[0] = MEMORY[0x1E4F143A8];
      v5[1] = 3221225472;
      void v5[2] = __VCRateControlBandwidthEstimatorMap_SetEstimatedBandwidth_block_invoke;
      uint64_t v5[3] = &__block_descriptor_40_e58_v32__0__NSNumber_8__VCRateControlBandwidthEstimator_16_B24l;
      *(double *)&void v5[4] = a2;
      [v3 enumerateKeysAndObjectsUsingBlock:v5];
    }
    else
    {
      BOOL v4 = *(void **)(a1 + 56);
      objc_msgSend(v4, "setEstimatedBandwidth:");
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlBandwidthEstimatorMap_SetEstimatedBandwidth_cold_1();
    }
  }
}

void VCRateControlBandwidthEstimatorMap_SetRadioAccessTechnology(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(_DWORD *)(a1 + 20) = a2;
    if (*(void *)(a1 + 56)) {
      BOOL v2 = (*(_DWORD *)(a1 + 16) - 6) > 0xFFFFFFFD;
    }
    else {
      BOOL v2 = 1;
    }
    if (v2)
    {
      double v3 = *(void **)(a1 + 40);
      v5[0] = MEMORY[0x1E4F143A8];
      v5[1] = 3221225472;
      void v5[2] = __VCRateControlBandwidthEstimatorMap_SetRadioAccessTechnology_block_invoke;
      uint64_t v5[3] = &__block_descriptor_36_e58_v32__0__NSNumber_8__VCRateControlBandwidthEstimator_16_B24l;
      int v6 = a2;
      [v3 enumerateKeysAndObjectsUsingBlock:v5];
    }
    else
    {
      BOOL v4 = *(void **)(a1 + 56);
      [v4 setRadioAccessTechnology:a2];
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlBandwidthEstimatorMap_SetRadioAccessTechnology_cold_1();
    }
  }
}

void VCRateControlBandwidthEstimatorMap_SetFastSuddenBandwidthDetectionEnabled(uint64_t a1, char a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(unsigned char *)(a1 + 68) = a2;
    if (*(void *)(a1 + 56)) {
      BOOL v2 = (*(_DWORD *)(a1 + 16) - 6) > 0xFFFFFFFD;
    }
    else {
      BOOL v2 = 1;
    }
    if (v2)
    {
      double v3 = *(void **)(a1 + 40);
      v5[0] = MEMORY[0x1E4F143A8];
      v5[1] = 3221225472;
      void v5[2] = __VCRateControlBandwidthEstimatorMap_SetFastSuddenBandwidthDetectionEnabled_block_invoke;
      uint64_t v5[3] = &__block_descriptor_33_e58_v32__0__NSNumber_8__VCRateControlBandwidthEstimator_16_B24l;
      char v6 = a2;
      [v3 enumerateKeysAndObjectsUsingBlock:v5];
    }
    else
    {
      uint64_t v4 = *(void *)(a1 + 56);
      VCRateControlBandwidthEstimator_SetFastSuddenBandwidthDetectionEnabled(v4, a2);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlBandwidthEstimatorMap_SetFastSuddenBandwidthDetectionEnabled_cold_1();
    }
  }
}

void VCRateControlBandwidthEstimatorMap_EnableBWELogDump(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    *(void *)(a1 + 80) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCRateControlBandwidthEstimatorMap_EnableBWELogDump_cold_1();
    }
  }
}

void sub_1E234F080(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t VCMediaNegotiationBlobV2StreamGroupPayloadReadFrom(uint64_t a1, uint64_t a2)
{
  double v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = &OBJC_IVAR___AVCPreviewCALayerHost__preview;
    uint64_t v8 = &OBJC_IVAR___AVCPreviewCALayerHost__preview;
    __int16 v9 = (int *)MEMORY[0x1E4F940B8];
    uint64_t v10 = &OBJC_IVAR___AVCPreviewCALayerHost__preview;
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v11 = 0;
      unsigned int v12 = 0;
      unint64_t v13 = 0;
      while (1)
      {
        uint64_t v14 = *v3;
        unint64_t v15 = *(void *)(a2 + v14);
        if (v15 == -1 || v15 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v16 = *(unsigned char *)(*(void *)(a2 + *v9) + v15);
        *(void *)(a2 + v14) = v15 + 1;
        v13 |= (unint64_t)(v16 & 0x7F) << v11;
        if ((v16 & 0x80) == 0) {
          goto LABEL_12;
        }
        v11 += 7;
        BOOL v17 = v12++ >= 9;
        if (v17)
        {
          unint64_t v13 = 0;
          int v18 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v18 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v13 = 0;
      }
LABEL_14:
      if (v18 || (v13 & 7) == 4) {
        break;
      }
      switch((v13 >> 3))
      {
        case 1u:
          char v20 = 0;
          unsigned int v21 = 0;
          uint64_t v22 = 0;
          *(_WORD *)(a1 + v7[371]) |= 2u;
          while (1)
          {
            uint64_t v23 = *v3;
            unint64_t v24 = *(void *)(a2 + v23);
            if (v24 == -1 || v24 >= *(void *)(a2 + *v4)) {
              break;
            }
            char v25 = *(unsigned char *)(*(void *)(a2 + *v9) + v24);
            *(void *)(a2 + v23) = v24 + 1;
            v22 |= (unint64_t)(v25 & 0x7F) << v20;
            if ((v25 & 0x80) == 0) {
              goto LABEL_86;
            }
            v20 += 7;
            BOOL v17 = v21++ >= 9;
            if (v17)
            {
              LODWORD(v22) = 0;
              goto LABEL_88;
            }
          }
          *(unsigned char *)(a2 + *v5) = 1;
LABEL_86:
          if (*(unsigned char *)(a2 + *v5)) {
            LODWORD(v22) = 0;
          }
LABEL_88:
          uint64_t v72 = v8[372];
          goto LABEL_121;
        case 2u:
          char v27 = 0;
          unsigned int v28 = 0;
          uint64_t v22 = 0;
          *(_WORD *)(a1 + v7[371]) |= 0x80u;
          while (2)
          {
            uint64_t v29 = *v3;
            unint64_t v30 = *(void *)(a2 + v29);
            if (v30 == -1 || v30 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v31 = *(unsigned char *)(*(void *)(a2 + *v9) + v30);
              *(void *)(a2 + v29) = v30 + 1;
              v22 |= (unint64_t)(v31 & 0x7F) << v27;
              if (v31 < 0)
              {
                v27 += 7;
                BOOL v17 = v28++ >= 9;
                if (v17)
                {
                  LODWORD(v22) = 0;
                  goto LABEL_92;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            LODWORD(v22) = 0;
          }
LABEL_92:
          uint64_t v72 = v10[373];
          goto LABEL_121;
        case 3u:
          char v32 = 0;
          unsigned int v33 = 0;
          uint64_t v22 = 0;
          *(_WORD *)(a1 + v7[371]) |= 0x10u;
          while (2)
          {
            uint64_t v34 = *v3;
            unint64_t v35 = *(void *)(a2 + v34);
            if (v35 == -1 || v35 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v36 = *(unsigned char *)(*(void *)(a2 + *v9) + v35);
              *(void *)(a2 + v34) = v35 + 1;
              v22 |= (unint64_t)(v36 & 0x7F) << v32;
              if (v36 < 0)
              {
                v32 += 7;
                BOOL v17 = v33++ >= 9;
                if (v17)
                {
                  LODWORD(v22) = 0;
                  goto LABEL_96;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            LODWORD(v22) = 0;
          }
LABEL_96:
          uint64_t v72 = 24;
          goto LABEL_121;
        case 4u:
          char v37 = 0;
          unsigned int v38 = 0;
          uint64_t v22 = 0;
          *(_WORD *)(a1 + v7[371]) |= 0x40u;
          while (2)
          {
            uint64_t v39 = *v3;
            unint64_t v40 = *(void *)(a2 + v39);
            if (v40 == -1 || v40 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v41 = *(unsigned char *)(*(void *)(a2 + *v9) + v40);
              *(void *)(a2 + v39) = v40 + 1;
              v22 |= (unint64_t)(v41 & 0x7F) << v37;
              if (v41 < 0)
              {
                v37 += 7;
                BOOL v17 = v38++ >= 9;
                if (v17)
                {
                  LODWORD(v22) = 0;
                  goto LABEL_100;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            LODWORD(v22) = 0;
          }
LABEL_100:
          uint64_t v72 = 44;
          goto LABEL_121;
        case 5u:
          char v42 = 0;
          unsigned int v43 = 0;
          uint64_t v22 = 0;
          *(_WORD *)(a1 + v7[371]) |= 8u;
          while (2)
          {
            uint64_t v44 = *v3;
            unint64_t v45 = *(void *)(a2 + v44);
            if (v45 == -1 || v45 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v46 = *(unsigned char *)(*(void *)(a2 + *v9) + v45);
              *(void *)(a2 + v44) = v45 + 1;
              v22 |= (unint64_t)(v46 & 0x7F) << v42;
              if (v46 < 0)
              {
                v42 += 7;
                BOOL v17 = v43++ >= 9;
                if (v17)
                {
                  LODWORD(v22) = 0;
                  goto LABEL_104;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            LODWORD(v22) = 0;
          }
LABEL_104:
          uint64_t v72 = 20;
          goto LABEL_121;
        case 6u:
          char v47 = 0;
          unsigned int v48 = 0;
          uint64_t v22 = 0;
          *(_WORD *)(a1 + v7[371]) |= 0x20u;
          while (2)
          {
            uint64_t v49 = *v3;
            unint64_t v50 = *(void *)(a2 + v49);
            if (v50 == -1 || v50 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v51 = *(unsigned char *)(*(void *)(a2 + *v9) + v50);
              *(void *)(a2 + v49) = v50 + 1;
              v22 |= (unint64_t)(v51 & 0x7F) << v47;
              if (v51 < 0)
              {
                v47 += 7;
                BOOL v17 = v48++ >= 9;
                if (v17)
                {
                  LODWORD(v22) = 0;
                  goto LABEL_108;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            LODWORD(v22) = 0;
          }
LABEL_108:
          uint64_t v72 = 40;
          goto LABEL_121;
        case 7u:
          char v52 = 0;
          unsigned int v53 = 0;
          uint64_t v22 = 0;
          *(_WORD *)(a1 + v7[371]) |= 0x100u;
          while (2)
          {
            uint64_t v54 = *v3;
            unint64_t v55 = *(void *)(a2 + v54);
            if (v55 == -1 || v55 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v56 = *(unsigned char *)(*(void *)(a2 + *v9) + v55);
              *(void *)(a2 + v54) = v55 + 1;
              v22 |= (unint64_t)(v56 & 0x7F) << v52;
              if (v56 < 0)
              {
                v52 += 7;
                BOOL v17 = v53++ >= 9;
                if (v17)
                {
                  LODWORD(v22) = 0;
                  goto LABEL_112;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            LODWORD(v22) = 0;
          }
LABEL_112:
          uint64_t v72 = 52;
          goto LABEL_121;
        case 8u:
          char v57 = 0;
          unsigned int v58 = 0;
          uint64_t v22 = 0;
          *(_WORD *)(a1 + v7[371]) |= 1u;
          while (2)
          {
            uint64_t v59 = *v3;
            unint64_t v60 = *(void *)(a2 + v59);
            if (v60 == -1 || v60 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v61 = *(unsigned char *)(*(void *)(a2 + *v9) + v60);
              *(void *)(a2 + v59) = v60 + 1;
              v22 |= (unint64_t)(v61 & 0x7F) << v57;
              if (v61 < 0)
              {
                v57 += 7;
                BOOL v17 = v58++ >= 9;
                if (v17)
                {
                  LODWORD(v22) = 0;
                  goto LABEL_116;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            LODWORD(v22) = 0;
          }
LABEL_116:
          uint64_t v72 = 8;
          goto LABEL_121;
        case 9u:
          uint64_t v62 = v7;
          uint64_t v63 = v10;
          __int16 v64 = v8;
          DatCGFloat a = (void *)PBReaderReadData();

          id v66 = Data;
          uint64_t v8 = v64;
          uint64_t v10 = v63;
          uint64_t v7 = v62;
          *(void *)(a1 + 32) = v66;
          continue;
        case 0xAu:
          char v67 = 0;
          unsigned int v68 = 0;
          uint64_t v22 = 0;
          *(_WORD *)(a1 + v7[371]) |= 4u;
          break;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v69 = *v3;
        unint64_t v70 = *(void *)(a2 + v69);
        if (v70 == -1 || v70 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v71 = *(unsigned char *)(*(void *)(a2 + *v9) + v70);
        *(void *)(a2 + v69) = v70 + 1;
        v22 |= (unint64_t)(v71 & 0x7F) << v67;
        if ((v71 & 0x80) == 0) {
          goto LABEL_118;
        }
        v67 += 7;
        BOOL v17 = v68++ >= 9;
        if (v17)
        {
          LODWORD(v22) = 0;
          goto LABEL_120;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_118:
      if (*(unsigned char *)(a2 + *v5)) {
        LODWORD(v22) = 0;
      }
LABEL_120:
      uint64_t v72 = 16;
LABEL_121:
      *(_DWORD *)(a1 + v72) = v22;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t _VCFECHeader_WriteToBuffer_V0(uint64_t a1, unsigned char *a2, unint64_t a3, uint64_t *a4)
{
  if ((*(unsigned char *)a1 & 3) != 0)
  {
    uint64_t v15 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCFECHeader_WriteToBuffer_V0_cold_4();
      }
    }
    goto LABEL_17;
  }
  if (a3 <= 3)
  {
    uint64_t v15 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCFECHeader_WriteToBuffer_V0_cold_1();
      }
    }
    goto LABEL_17;
  }
  char v5 = *a2 | (*(unsigned char *)a1 << 6);
  *a2 = v5;
  char v6 = (2 * *(unsigned char *)a1) & 0x38 | v5;
  *a2 = v6;
  *a2 = v6 | *(unsigned char *)(a1 + 1) & 7;
  char v7 = ~(*(unsigned __int16 *)(a1 + 2) >> 5) & 0x80 | a2[1];
  a2[1] = v7;
  a2[1] = v7 | *(unsigned char *)(a1 + 2) & 0x7F;
  char v8 = *(unsigned char *)(a1 + 2) & 0x80 | a2[2];
  a2[2] = v8;
  char v9 = (*(unsigned __int16 *)(a1 + 2) >> 5) & 0x38 | v8;
  a2[2] = v9;
  a2[2] = *(unsigned char *)(a1 + 5) & 7 | v9;
  a2[3] = *(unsigned char *)(a1 + 4);
  if ((*(_WORD *)(a1 + 2) & 0x1000) != 0)
  {
    if (a3 <= 4)
    {
      uint64_t v15 = 2150825985;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCFECHeader_WriteToBuffer_V0_cold_2();
        }
      }
    }
    else
    {
      a2[4] = *(unsigned char *)(a1 + 7);
      a2[5] = *(unsigned char *)(a1 + 6);
      if (!*(_WORD *)(a1 + 6))
      {
        uint64_t v10 = 6;
        goto LABEL_12;
      }
      uint64_t v11 = 0;
      unint64_t v12 = 0;
      uint64_t v13 = a1 + 8;
      while (v11 + 8 <= a3)
      {
        uint64_t v14 = &a2[v11];
        void v14[6] = *(unsigned char *)(v13 + v11 + 1);
        void v14[7] = *(unsigned char *)(v13 + v11);
        ++v12;
        v11 += 2;
        if (v12 >= *(unsigned __int16 *)(a1 + 6))
        {
          uint64_t v10 = v11 + 6;
          goto LABEL_12;
        }
      }
      uint64_t v15 = 2150825985;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _VCFECHeader_WriteToBuffer_V0_cold_3();
        }
      }
    }
LABEL_17:
    uint64_t v16 = 0;
    goto LABEL_13;
  }
  uint64_t v10 = 4;
LABEL_12:
  uint64_t v15 = 0;
  uint64_t v16 = (v10 & 2) + v10;
LABEL_13:
  *a4 = v16;
  return v15;
}

uint64_t _VCFECHeader_WriteToBuffer_V1(uint64_t a1, unsigned char *a2, unint64_t a3, uint64_t *a4)
{
  if ((*(unsigned char *)a1 & 3) != 1)
  {
    uint64_t v12 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCFECHeader_WriteToBuffer_V1_cold_3();
      }
    }
    goto LABEL_18;
  }
  if (a3 <= 3)
  {
    uint64_t v12 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCFECHeader_WriteToBuffer_V1_cold_1();
      }
    }
    goto LABEL_18;
  }
  char v5 = *a2 | (*(unsigned char *)a1 << 6);
  *a2 = v5;
  char v6 = (2 * *(unsigned char *)a1) & 0x38 | v5;
  *a2 = v6;
  *a2 = (*(unsigned char *)(a1 + 1) >> 1) & 7 | v6;
  char v7 = a2[1] | (*(unsigned char *)(a1 + 1) << 7);
  a2[1] = v7;
  char v8 = ~(*(unsigned __int16 *)(a1 + 2) >> 6) & 0x40 | v7;
  a2[1] = v8;
  a2[1] = v8 | (*(unsigned char *)(a1 + 2) >> 1) & 0x3F;
  char v9 = a2[2] | (*(unsigned char *)(a1 + 2) << 7);
  a2[2] = v9;
  char v10 = (*(unsigned char *)(a1 + 2) >> 1) & 0x40 | v9;
  a2[2] = v10;
  char v11 = (*(unsigned __int16 *)(a1 + 2) >> 6) & 0x3C | v10;
  a2[2] = v11;
  a2[2] = *(unsigned char *)(a1 + 5) & 3 | v11;
  a2[3] |= *(unsigned char *)(a1 + 4);
  if ((*(_WORD *)(a1 + 2) & 0x1000) == 0)
  {
    uint64_t v12 = 0;
    uint64_t v13 = 4;
    goto LABEL_8;
  }
  if (a3 <= 7)
  {
    uint64_t v12 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCFECHeader_WriteToBuffer_V1_cold_2();
      }
    }
LABEL_18:
    uint64_t v13 = 0;
    goto LABEL_8;
  }
  uint64_t v12 = 0;
  a2[4] = BYTE1(*(_DWORD *)(a1 + 6));
  a2[5] = *(_DWORD *)(a1 + 6);
  a2[6] = *(unsigned char *)(a1 + 9);
  a2[7] = *(_WORD *)(a1 + 8);
  uint64_t v13 = 8;
  if ((*(_WORD *)(a1 + 2) & 0x1000) == 0) {
    uint64_t v13 = 4;
  }
LABEL_8:
  *a4 = v13;
  return v12;
}

uint64_t VCFECHeader_WriteToBuffer(unsigned __int8 *a1, unsigned char *a2, size_t a3, uint64_t *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCFECHeader_WriteToBuffer_cold_1();
      }
    }
    goto LABEL_23;
  }
  if (!a4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCFECHeader_WriteToBuffer_cold_2();
      }
    }
LABEL_23:
    *a4 = 0;
    return 2150825985;
  }
  bzero(a2, a3);
  int v8 = *a1;
  if ((v8 & 3) == 1)
  {
    long long v11 = *(_OWORD *)a1;
    uint64_t v12 = *((void *)a1 + 2);
    int v9 = _VCFECHeader_WriteToBuffer_V1((uint64_t)&v11, a2, a3, a4);
  }
  else
  {
    if (v8 << 30 >> 30)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        VCFECHeader_WriteToBuffer_cold_3();
      }
      return 0;
    }
    long long v11 = *(_OWORD *)a1;
    uint64_t v12 = *((void *)a1 + 2);
    int v9 = _VCFECHeader_WriteToBuffer_V0((uint64_t)&v11, a2, a3, a4);
  }
  if ((v9 & 0x80000000) == 0) {
    return 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCFECHeader_WriteToBuffer_cold_4();
    }
  }
  return 21;
}

BOOL VCMediaNegotiationBlobV2MicrophoneSettingsU1ReadFrom(uint64_t a1, uint64_t a2)
{
  double v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  char v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    char v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
      {
        char v26 = 0;
        unsigned int v27 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 20) |= 1u;
        while (1)
        {
          uint64_t v28 = *v3;
          unint64_t v29 = *(void *)(a2 + v28);
          if (v29 == -1 || v29 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v30 = *(unsigned char *)(*(void *)(a2 + *v7) + v29);
          *(void *)(a2 + v28) = v29 + 1;
          v20 |= (unint64_t)(v30 & 0x7F) << v26;
          if ((v30 & 0x80) == 0)
          {
            char v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__cipherSuites;
            goto LABEL_48;
          }
          v26 += 7;
          BOOL v24 = v27++ > 8;
          if (v24)
          {
            LODWORD(v20) = 0;
            char v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__cipherSuites;
            goto LABEL_50;
          }
        }
        char v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__cipherSuites;
LABEL_47:
        *(unsigned char *)(a2 + *v5) = 1;
        goto LABEL_48;
      }
      if (v17 == 2) {
        break;
      }
      if (v17 == 1)
      {
        char v18 = 0;
        unsigned int v19 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 20) |= 4u;
        while (1)
        {
          uint64_t v21 = *v3;
          unint64_t v22 = *(void *)(a2 + v21);
          if (v22 == -1 || v22 >= *(void *)(a2 + *v4))
          {
            char v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__rtpSSRC;
            goto LABEL_47;
          }
          char v23 = *(unsigned char *)(*(void *)(a2 + *v7) + v22);
          *(void *)(a2 + v21) = v22 + 1;
          v20 |= (unint64_t)(v23 & 0x7F) << v18;
          if ((v23 & 0x80) == 0) {
            break;
          }
          v18 += 7;
          BOOL v24 = v19++ > 8;
          if (v24)
          {
            LODWORD(v20) = 0;
            char v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__rtpSSRC;
            goto LABEL_50;
          }
        }
        char v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__rtpSSRC;
        goto LABEL_48;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_51:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    char v31 = 0;
    unsigned int v32 = 0;
    uint64_t v20 = 0;
    *(unsigned char *)(a1 + 20) |= 2u;
    while (1)
    {
      uint64_t v33 = *v3;
      unint64_t v34 = *(void *)(a2 + v33);
      if (v34 == -1 || v34 >= *(void *)(a2 + *v4))
      {
        char v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__payloads;
        goto LABEL_47;
      }
      char v35 = *(unsigned char *)(*(void *)(a2 + *v7) + v34);
      *(void *)(a2 + v33) = v34 + 1;
      v20 |= (unint64_t)(v35 & 0x7F) << v31;
      if ((v35 & 0x80) == 0) {
        break;
      }
      v31 += 7;
      BOOL v24 = v32++ > 8;
      if (v24)
      {
        LODWORD(v20) = 0;
        char v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__payloads;
        goto LABEL_50;
      }
    }
    char v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__payloads;
LABEL_48:
    if (*(unsigned char *)(a2 + *v5)) {
      LODWORD(v20) = 0;
    }
LABEL_50:
    *(_DWORD *)(a1 + *v25) = v20;
    goto LABEL_51;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t VCTimescalePSOLA_PreEmptiveExpand(unsigned __int8 *a1, __int16 *a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (a1[92])
  {
    __int16 v4 = VCTimescalePSOLA_CalcFsMult(*((unsigned __int16 *)a1 + 1));
    int v5 = (__int16)(120 * v4);
    *((_WORD *)a1 + 29) = 0;
    uint64_t v6 = VCTimescalePSOLA_CheckforSignalCorrelation((__int16 *)a1, a2, v5, 1);
    if ((v6 & 0x80000000) != 0)
    {
      uint64_t v12 = v6;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v22 = VRTraceErrorLogLevelToCSTR();
        char v23 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCTimescalePSOLA_PreEmptiveExpand_cold_1(v22, v23);
        }
      }
    }
    else
    {
      if (a2[32] > v5 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v7 = VRTraceErrorLogLevelToCSTR();
        char v8 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v9 = a2[32];
          int v24 = 136316162;
          uint64_t v25 = v7;
          __int16 v26 = 2080;
          unsigned int v27 = "VCTimescalePSOLA_PreEmptiveExpand";
          __int16 v28 = 1024;
          int v29 = 150;
          __int16 v30 = 1024;
          int v31 = v9;
          __int16 v32 = 1024;
          int v33 = (__int16)(120 * v4);
          _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Expand: WARN TOO MANY PLAYED OUT DATA %d > 15 ms %d", (uint8_t *)&v24, 0x28u);
        }
      }
      VCTimescalePSOLA_SynchronizeChannelCorrelation(a1, (uint64_t)a2, 1, v4);
      if (*((__int16 *)a1 + 19) <= *((__int16 *)a1 + 27) || (int v10 = a2[32], v10 > v5))
      {
        if (*((_WORD *)a1 + 11))
        {
          a2[34] = a2[33];
          if (*a1)
          {
            unint64_t v11 = 0;
            do
            {
              memmove(*(void **)&a2[4 * v11 + 16], *(const void **)&a2[4 * v11], 4 * a2[33]);
              ++v11;
            }
            while (v11 < *a1);
          }
          return 61;
        }
        LOWORD(v10) = a2[32];
      }
      if ((__int16)v10 <= v5) {
        __int16 v14 = 120 * v4;
      }
      else {
        __int16 v14 = v10;
      }
      int v15 = *((__int16 *)a1 + 3);
      if (*a1)
      {
        unint64_t v16 = 0;
        float v17 = 1.0 / (float)(v15 + 1);
        do
        {
          char v18 = &a2[4 * v16];
          unsigned int v19 = (float *)(*(void *)v18 + 4 * (v14 - *((__int16 *)a1 + 3)));
          uint64_t v20 = (float *)(*(void *)v18 + 4 * v14);
          memmove(*((void **)v18 + 4), *(const void **)v18, 4 * v14);
          VCTimescalePSOLA_MixVoiceUnvoiceFloatPoint((float *)(*((void *)v18 + 4) + 4 * v14), v20, v19, *((__int16 *)a1 + 3), 1.0 - v17, v17);
          memmove((void *)(*((void *)v18 + 4) + 4 * (*((__int16 *)a1 + 3) + v14)), (const void *)(*(void *)v18 + 4 * v14), 4 * (__int16)(a2[33] - v14));
          ++v16;
        }
        while (v16 < *a1);
        LOWORD(v15) = *((_WORD *)a1 + 3);
      }
      uint64_t v12 = 0;
      a2[34] = a2[33] + v15;
      *((_DWORD *)a1 + 18) += *((__int16 *)a1 + 3);
    }
  }
  else
  {
    a2[34] = a2[33];
    if (*a1)
    {
      unint64_t v13 = 0;
      do
      {
        memmove(*(void **)&a2[4 * v13 + 16], *(const void **)&a2[4 * v13], 4 * a2[33]);
        ++v13;
      }
      while (v13 < *a1);
    }
    return 0;
  }
  return v12;
}

CFAllocatorRef VCAudioBufferAllocatorCreate(const __CFAllocator *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioBufferAllocatorCreate_cold_1();
      }
    }
    return 0;
  }
  if (!a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioBufferAllocatorCreate_cold_2();
      }
    }
    return 0;
  }
  CFAllocatorContext v13 = *(CFAllocatorContext *)byte_1F3D3E3A8;
  unint64_t v4 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioBufferAllocatorCreate_cold_4();
      }
    }
    goto LABEL_25;
  }
  unint64_t v5 = (v4 + 16) * a3 + 40;
  if (v5 <= v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v11 = VRTraceErrorLogLevelToCSTR();
      uint64_t v12 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 136316162;
        uint64_t v15 = v11;
        __int16 v16 = 2080;
        float v17 = "VCAudioBufferAllocatorCreateContext";
        __int16 v18 = 1024;
        int v19 = 45;
        __int16 v20 = 2048;
        unint64_t v21 = v4;
        __int16 v22 = 2048;
        unint64_t v23 = v5;
        _os_log_error_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to compute the size. Requested buffer size=%zu allocator size=%zu!", buf, 0x30u);
      }
    }
    goto LABEL_25;
  }
  uint64_t v7 = CFAllocatorAllocate(a1, (v4 + 16) * a3 + 40, 0);
  if (!v7)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioBufferAllocatorCreate_cold_5();
      }
    }
LABEL_25:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioBufferAllocatorCreate_cold_3();
      }
    }
    return 0;
  }
  char v8 = v7;
  bzero(v7, (v4 + 16) * a3 + 40);
  v8[4] = a3;
  *((void *)v8 + 1) = v4;
  if (a1) {
    CFAllocatorRef Default = a1;
  }
  else {
    CFAllocatorRef Default = CFAllocatorGetDefault();
  }
  *(void *)char v8 = CFRetain(Default);
  *((void *)v8 + 3) = v5;
  v13.info = v8;
  return CFAllocatorCreate(a1, &v13);
}

void VCAudioBufferAllocatorFreeContext(CFAllocatorRef *ptr)
{
  if (ptr)
  {
    CFAllocatorRef v1 = *ptr;
    CFAllocatorDeallocate(*ptr, ptr);
    CFRelease(v1);
  }
}

void *VCAudioBufferAllocatorAlloc(uint64_t a1, CFOptionFlags a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  CFIndex v5 = (a1 + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 == *(void *)(a3 + 8) && !*(unsigned char *)(a3 + 32) && *(_DWORD *)(a3 + 16))
  {
    int v9 = 0;
    int v10 = (atomic_uint *)(a3 + 40);
    while (1)
    {
      int v11 = 0;
      atomic_compare_exchange_strong_explicit(v10, (unsigned int *)&v11, 1u, memory_order_relaxed, memory_order_relaxed);
      uint64_t result = v10 + 2;
      uint64_t v12 = (atomic_uint *)((char *)v10 + *(void *)(a3 + 8) + 8);
      if (!v11) {
        break;
      }
      int v10 = v12 + 2;
      if (++v9 >= *(_DWORD *)(a3 + 16)) {
        goto LABEL_3;
      }
    }
    *uint64_t v12 = -524416118;
  }
  else
  {
LABEL_3:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      uint64_t v6 = VRTraceErrorLogLevelToCSTR();
      uint64_t v7 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v13 = 136315650;
        uint64_t v14 = v6;
        __int16 v15 = 2080;
        __int16 v16 = "VCAudioBufferAllocatorAlloc";
        __int16 v17 = 1024;
        int v18 = 115;
        _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Insufficient number of audio buffers!", (uint8_t *)&v13, 0x1Cu);
      }
    }
    return CFAllocatorAllocate(*(CFAllocatorRef *)a3, v5, a2);
  }
  return result;
}

void *VCAudioBufferAllocatorRealloc(unint64_t ptr, CFIndex newsize, CFOptionFlags hint, unint64_t a4)
{
  CFIndex v5 = (void *)ptr;
  if (ptr <= a4 || a4 + *(void *)(a4 + 24) <= ptr)
  {
    CFAllocatorRef v8 = *(const __CFAllocator **)a4;
    return CFAllocatorReallocate(v8, v5, newsize, hint);
  }
  else
  {
    if (*(void *)(a4 + 8) < newsize)
    {
      uint64_t v6 = CFAllocatorAllocate(*(CFAllocatorRef *)a4, newsize, hint);
      memcpy(v6, v5, *(void *)(a4 + 8));
      VCAudioBufferAllocatorCleanupBuffer(a4, (uint64_t)v5);
      return v6;
    }
    return v5;
  }
}

void VCAudioBufferAllocatorDealloc(void *ptr, unint64_t a2)
{
  if ((unint64_t)ptr <= a2 || a2 + *(void *)(a2 + 24) <= (unint64_t)ptr) {
    CFAllocatorDeallocate(*(CFAllocatorRef *)a2, ptr);
  }
  else {
    VCAudioBufferAllocatorCleanupBuffer(a2, (uint64_t)ptr);
  }
}

void VCAudioBufferAllocatorCleanupBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (*(_DWORD *)(a2 + v3) != -524416118)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioBufferAllocatorCleanupBuffer_cold_1();
      }
    }
    *(unsigned char *)(a1 + 32) = 1;
  }
  *(_DWORD *)(a2 + v3) = -524416118;
  atomic_fetch_and_explicit((atomic_uint *volatile)(a2 - 8), 0, memory_order_relaxed);
}

uint64_t _VCFECFeedbackAnalyzerClassRegister(uint64_t *a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t _VCFECFeedbackAnalyzer_Configure(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  *(_OWORD *)(a1 + 16) = *a2;
  unint64_t v4 = (int *)(a2 + 1);
  int v3 = *((_DWORD *)a2 + 4);
  *(_DWORD *)(a1 + 32) = v3;
  *(_OWORD *)(a1 + 40) = *(long long *)((char *)a2 + 24);
  if (*(double *)&v2 <= 0.0 || *(double *)&v2 > 1.0)
  {
    uint64_t v6 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v9 = VRTraceErrorLogLevelToCSTR();
      int v10 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCFECFeedbackAnalyzer_Configure_cold_1(v9, (double *)a2, v10);
      }
    }
  }
  else if ((v3 - 15001) <= 0xFFFFC567)
  {
    uint64_t v6 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v11 = VRTraceErrorLogLevelToCSTR();
      uint64_t v12 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _VCFECFeedbackAnalyzer_Configure_cold_2(v11, v4, v12);
      }
    }
  }
  else
  {
    return 0;
  }
  return v6;
}

uint64_t VCFECFeedbackAnalyzer_Create(uint64_t a1, uint64_t *a2, long long *a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (a3)
    {
      if (VCFECFeedbackAnalyzerGetTypeID_initOnce != -1) {
        dispatch_once_f(&VCFECFeedbackAnalyzerGetTypeID_initOnce, &VCFECFeedbackAnalyzerGetTypeID_typeID, (dispatch_function_t)_VCFECFeedbackAnalyzerClassRegister);
      }
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        uint64_t v6 = Instance;
        bzero((void *)(Instance + 200), 0x1180uLL);
        BOOL BoolValueForKey = VCDefaults_GetBoolValueForKey(@"isFECFeedbackAnalyzerDumpEnabled", 1);
        *(unsigned char *)(v6 + 56) = BoolValueForKey;
        if (BoolValueForKey)
        {
          uint32_t v8 = arc4random();
          *(_DWORD *)(v6 + 60) = v8;
          memset(v21, 170, 12);
          __sprintf_chk(v21, 0, 0xCuLL, "%010u", v8);
          uint64_t v9 = LogDump_OpenLog((uint64_t)v21, (uint64_t)"com.apple.VideoConference.VCFECFeedbackAnalyzer", (uint64_t)".fecdump", (char)"", 9, (char)"");
          *(void *)(v6 + 64) = v9;
          VRLogfilePrintSync(v9, "Time\tTimeMicro\tFrameSizeInPackets\tlostPackets\n", v10, v11, v12, v13, v14, v15, v20);
        }
        if (_VCFECFeedbackAnalyzer_Configure(v6, a3))
        {
          uint64_t v17 = 2150825985;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              VCFECFeedbackAnalyzer_Create_cold_5();
            }
          }
        }
        else
        {
          __int16 v16 = malloc_type_calloc(*(int *)(v6 + 32), 0x10uLL, 0x1000040D9A13B51uLL);
          *(void *)(v6 + 88) = v16;
          if (v16)
          {
            uint64_t v17 = 0;
            *a2 = v6;
            return v17;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          {
            uint64_t v17 = 2150825987;
          }
          else
          {
            VRTraceErrorLogLevelToCSTR();
            uint64_t v17 = 2150825987;
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              VCFECFeedbackAnalyzer_Create_cold_4();
            }
          }
        }
        uint64_t v19 = *(void **)(v6 + 88);
        if (v19) {
          free(v19);
        }
        CFRelease((CFTypeRef)v6);
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      {
        return 2150825987;
      }
      else
      {
        VRTraceErrorLogLevelToCSTR();
        uint64_t v17 = 2150825987;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCFECFeedbackAnalyzer_Create_cold_3();
        }
      }
    }
    else
    {
      uint64_t v17 = 2150825985;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCFECFeedbackAnalyzer_Create_cold_2();
        }
      }
    }
  }
  else
  {
    uint64_t v17 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCFECFeedbackAnalyzer_Create_cold_1();
      }
    }
  }
  return v17;
}

uint64_t VCFECFeedbackAnalyzer_ProcessFeedback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    int v6 = WORD1(a3);
    if (WORD1(a3) >= 0x1Fu) {
      unsigned int v7 = 31;
    }
    else {
      unsigned int v7 = WORD1(a3);
    }
    unsigned int v8 = (unsigned __int16)a3;
    if ((unsigned __int16)a3 >= 0x20u) {
      unsigned int v7 = (int)(float)((float)(32.0 / (float)(unsigned __int16)a3) * (float)WORD1(a3));
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v15 = VRTraceErrorLogLevelToCSTR();
      __int16 v16 = *MEMORY[0x1E4F47A50];
      uint64_t v17 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          float v18 = *(double *)&a2;
          int v19 = *(__int16 *)(a1 + 84);
          float v20 = *(double *)&a2 - *(double *)(a1 + 96);
          *(_DWORD *)CMSampleTimingInfo buf = 136316930;
          *(void *)&uint8_t buf[4] = v15;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "_VCFECFeedbackAnalyzer_RegisterFeedback";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 195;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v8;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v6;
          *(_WORD *)&unsigned char buf[40] = 2048;
          *(double *)&buf[42] = v18;
          *(_WORD *)&buf[50] = 2048;
          *(double *)&buf[52] = v20;
          *(_WORD *)&buf[60] = 1024;
          *(_DWORD *)&buf[62] = v19;
          _os_log_impl(&dword_1E1EA4000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d New feedback arrived fecFeedback.sizeInPackets=%d fecFeedback.lostPackets=%d time=%f timeDelta=%f bufferIndex=%d", buf, 0x42u);
        }
      }
      else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        float v42 = *(double *)&a2;
        int v43 = *(__int16 *)(a1 + 84);
        float v44 = *(double *)&a2 - *(double *)(a1 + 96);
        *(_DWORD *)CMSampleTimingInfo buf = 136316930;
        *(void *)&uint8_t buf[4] = v15;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "_VCFECFeedbackAnalyzer_RegisterFeedback";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = 195;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v8;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v6;
        *(_WORD *)&unsigned char buf[40] = 2048;
        *(double *)&buf[42] = v42;
        *(_WORD *)&buf[50] = 2048;
        *(double *)&buf[52] = v44;
        *(_WORD *)&buf[60] = 1024;
        *(_DWORD *)&buf[62] = v43;
        _os_log_debug_impl(&dword_1E1EA4000, v16, OS_LOG_TYPE_DEBUG, " [%s] %s:%d New feedback arrived fecFeedback.sizeInPackets=%d fecFeedback.lostPackets=%d time=%f timeDelta=%f bufferIndex=%d", buf, 0x42u);
      }
    }
    if (v7 >= 0x1F) {
      __int16 v21 = 31;
    }
    else {
      __int16 v21 = v7;
    }
    if (v8 >= 0x1F) {
      __int16 v22 = 31;
    }
    else {
      __int16 v22 = v8;
    }
    uint64_t v23 = *(void *)(a1 + 88) + 16 * *(__int16 *)(a1 + 84);
    *(double *)uint64_t v23 = *(double *)&a2;
    *(_WORD *)(v23 + 8) = v22;
    *(_WORD *)(v23 + 10) = v21;
    int v24 = *(_DWORD *)(a1 + 32);
    *(_WORD *)(a1 + 84) = (*(__int16 *)(a1 + 84) + 1) % v24;
    int v25 = *(__int16 *)(a1 + 82);
    if (v25 + 1 < v24) {
      __int16 v26 = v25 + 1;
    }
    else {
      __int16 v26 = v24;
    }
    *(_WORD *)(a1 + 82) = v26;
    *(double *)(a1 + 96) = *(double *)&a2;
    *(void *)(a1 + 104) = a3;
    if (*(unsigned char *)(a1 + 56))
    {
      if (*(unsigned char *)(a1 + 80))
      {
        double v27 = micro();
        if (v27 - *(double *)(a1 + 72) >= 1.0)
        {
          *(double *)(a1 + 72) = v27;
          memcpy(buf, "histogram", 0x1F4uLL);
          uint64_t v28 = 0;
          uint64_t v29 = a1 + 200;
          do
          {
            __sprintf_chk((char *)buf, 0, 0x1F4uLL, "{\"histogram\":\t{\"size\": %2d,\t\"bins\":{", v28);
            for (uint64_t i = 0; i != 32; ++i)
            {
              if (i) {
                int v31 = ",";
              }
              else {
                int v31 = "";
              }
              __sprintf_chk((char *)buf, 0, 0x1F4uLL, "%s%s\t\"%d\":%2.3f", (const char *)buf, v31, i, *(float *)(v29 + 4 * i));
            }
            VRLogfilePrintWithTimestamp(*(void *)(a1 + 64), "%s}}}\n", v32, v33, v34, v35, v36, v37, (char)buf);
            ++v28;
            v29 += 140;
          }
          while (v28 != 32);
        }
      }
      else
      {
        float v38 = *(double *)&a2;
        double v39 = v38;
        VRLogfilePrintWithTimestamp(*(void *)(a1 + 64), "%5.6f\t%d\t%d\n", v9, v10, v11, v12, v13, v14, SLOBYTE(v39));
      }
    }
    return 0;
  }
  else
  {
    uint64_t v40 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCFECFeedbackAnalyzer_ProcessFeedback_cold_1();
      }
    }
  }
  return v40;
}

uint64_t VCFECFeedbackAnalyzer_GetFECLevelVector(uint64_t a1, uint64_t a2)
{
  uint64_t v118 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      uint64_t v4 = -4480;
      do
      {
        CFIndex v5 = (_OWORD *)(a1 + 200 + v4);
        v5[287] = 0uLL;
        v5[286] = 0uLL;
        v5[285] = 0uLL;
        v5[284] = 0uLL;
        v5[283] = 0uLL;
        v5[282] = 0uLL;
        v5[281] = 0uLL;
        v5[280] = 0uLL;
        v4 += 140;
      }
      while (v4);
      int v6 = *(__int16 *)(a1 + 82);
      if (v6 < 1)
      {
        int v9 = 0;
        double v16 = 0.0;
        double v22 = 0.0;
      }
      else
      {
        unsigned int v7 = 0;
        unsigned int v8 = 0;
        int v9 = 0;
        int v10 = *(_DWORD *)(a1 + 32);
        uint64_t v11 = *(void *)(a1 + 88);
        double v12 = *(double *)(a1 + 24);
        int v13 = v10 + *(__int16 *)(a1 + 84);
        LOWORD(v14) = 1;
        do
        {
          int v15 = (v13 - (__int16)v14) % v10;
          double v16 = NAN - *(double *)(v11 + 16 * (__int16)v15);
          if (v16 > v12) {
            break;
          }
          uint64_t v17 = v11 + 16 * (__int16)v15;
          int v18 = *(unsigned __int16 *)(v17 + 8);
          uint64_t v19 = a1 + 140 * *(unsigned __int16 *)(v17 + 8);
          unsigned int v20 = *(unsigned __int16 *)(v17 + 10);
          *(float *)(v19 + 4 * v20 + 200) = *(float *)(v19 + 4 * v20 + 200) + 1.0;
          double v21 = *(double *)(a1 + 40);
          if (v16 > v21) {
            int v18 = 0;
          }
          v8 += v18;
          if (v16 > v21) {
            unsigned int v20 = 0;
          }
          v7 += v20;
          int v14 = (__int16)(v14 + 1);
          ++v9;
        }
        while (v14 <= v6);
        double v22 = 0.0;
        if (v16 > 2.0 && v8 != 0) {
          double v22 = (float)((float)((float)v7 * 100.0) / (float)v8);
        }
      }
      *(double *)(a1 + 112) = v22;
      _VCRedundancyControlAlgorithmVideo_ApplyEnveloppe((double *)(a1 + 120), v22);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        uint64_t v24 = VRTraceErrorLogLevelToCSTR();
        int v25 = *MEMORY[0x1E4F47A50];
        __int16 v26 = *MEMORY[0x1E4F47A50];
        if (*MEMORY[0x1E4F47A40])
        {
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            float v27 = v16;
            float v28 = *(double *)(a1 + 112);
            *(_DWORD *)CMSampleTimingInfo buf = 136316418;
            *(void *)&uint8_t buf[4] = v24;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "_VCFECFeedbackAnalyzer_PopulateHistogram";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 247;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v9;
            *(_WORD *)&buf[34] = 2048;
            *(double *)&buf[36] = v27;
            *(_WORD *)&unsigned char buf[44] = 2048;
            *(double *)&buf[46] = v28;
            _os_log_impl(&dword_1E1EA4000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Histogram has been populated countItems=%d currentTimeDelta=%f _lastComputedVPLR=%2.2f", buf, 0x36u);
          }
        }
        else if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          float v112 = v16;
          float v113 = *(double *)(a1 + 112);
          *(_DWORD *)CMSampleTimingInfo buf = 136316418;
          *(void *)&uint8_t buf[4] = v24;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "_VCFECFeedbackAnalyzer_PopulateHistogram";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 247;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v9;
          *(_WORD *)&buf[34] = 2048;
          *(double *)&buf[36] = v112;
          *(_WORD *)&unsigned char buf[44] = 2048;
          *(double *)&buf[46] = v113;
          _os_log_debug_impl(&dword_1E1EA4000, v25, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Histogram has been populated countItems=%d currentTimeDelta=%f _lastComputedVPLR=%2.2f", buf, 0x36u);
        }
      }
      *(_DWORD *)(a1 + 196) = 0;
      uint64_t v29 = a1 + 344;
      float v30 = 0.0;
      for (uint64_t i = 1; i != 32; ++i)
      {
        uint64_t v32 = 0;
        uint64_t v33 = a1 + 140 * i;
        *(_DWORD *)(v33 + 328) = 0;
        float v34 = 0.0;
        do
        {
          float v34 = v34 + *(float *)(v29 + v32);
          *(float *)(v33 + 328) = v34;
          float v30 = v30 + *(float *)(v29 + v32);
          v32 += 4;
        }
        while (v32 != 124);
        if (v34 == 0.0)
        {
          uint64_t v35 = a1 + 140 * i;
          *(_WORD *)(v35 + 336) = 0;
          *(_WORD *)(v35 + 332) = 0;
        }
        else
        {
          uint64_t v36 = 0;
          float v37 = *(double *)(a1 + 16) * v34;
          uint64_t v38 = a1 + 140 * i;
          double v39 = (_WORD *)(v38 + 336);
          uint64_t v40 = (_WORD *)(v38 + 332);
          float v41 = 0.0;
          do
          {
            if (v36 == 31) {
              break;
            }
            float v42 = *(float *)(v29 + 4 * v36);
            __int16 v43 = v36++ + 2;
            float v41 = v41 + v42;
            _WORD *v39 = v36;
            *uint64_t v40 = v43;
          }
          while (v41 < v37);
        }
        v29 += 140;
      }
      unsigned __int16 v44 = 0;
      *(float *)(a1 + 196) = v30;
      unint64_t v45 = (float *)(a1 + 892);
      unsigned __int16 v46 = 1;
      for (uint64_t j = 4; j != 32; ++j)
      {
        unsigned int v48 = *(unsigned __int16 *)v45;
        if (v48 <= v44)
        {
          if (v48 == 1 || v48 < v44 || *(double *)(a1 + 48) > (float)(*(v45 - 1) / v30))
          {
            unsigned int v49 = vcvtps_s32_f32((float)((float)v44 / (float)v46) * (float)(unsigned __int16)j);
            if (v48 <= v49) {
              LOWORD(v48) = v49;
            }
            *(_WORD *)unint64_t v45 = v48;
          }
        }
        else
        {
          unsigned __int16 v46 = j;
          unsigned __int16 v44 = *(_WORD *)v45;
        }
        v45 += 35;
      }
      unsigned __int16 v50 = 0;
      uint64_t v51 = -4340;
      do
      {
        unsigned __int16 v52 = v50;
        if (v50 >= *(unsigned __int16 *)(a1 + 472 + v51 + 4340)) {
          unsigned __int16 v52 = *(_WORD *)(a1 + 472 + v51 + 4340);
        }
        if (!v50) {
          unsigned __int16 v52 = *(_WORD *)(a1 + 472 + v51 + 4340);
        }
        if (*(_WORD *)(a1 + 472 + v51 + 4340)) {
          unsigned __int16 v50 = v52;
        }
        v51 += 140;
      }
      while (v51);
      uint64_t v53 = a1 + 472;
      uint64_t v54 = -4340;
      do
      {
        if (*(unsigned __int16 *)(v53 + v54 + 4340) >= v50) {
          break;
        }
        *(_WORD *)(v53 + v54 + 4340) = v50;
        v54 += 140;
      }
      while (v54);
      int v55 = 0;
      char v56 = 1;
      uint64_t v57 = -4340;
      do
      {
        if (*(_WORD *)(a1 + v57 + 4812)) {
          ++v55;
        }
        v56 &= *(unsigned __int16 *)(a1 + v57 + 4814) == *(unsigned __int16 *)(a1 + v57 + 4812);
        v57 += 140;
      }
      while (v57);
      if ((v56 & 1) == 0)
      {
        uint64_t v58 = 0;
        uint64_t v59 = (_WORD *)(a1 + 474);
        for (uint64_t k = 1; k != 32; ++k)
        {
          __int16 v61 = *(v59 - 1);
          if (!v55 || *(v59 - 1))
          {
            uint64_t v62 = (unsigned char *)(a1 + 2 * v58 + 4682);
            *uint64_t v62 = k;
            v62[1] = v61;
            ++v58;
          }
          *uint64_t v59 = v61;
          v59 += 70;
        }
        *(_WORD *)(a1 + 4680) = v58;
        *(unsigned char *)(a1 + 81) = 1;
      }
      if (*(unsigned char *)(a1 + 56))
      {
        if (*(unsigned char *)(a1 + 80))
        {
          memset(buf, 0, 500);
          __sprintf_chk((char *)buf, 0, 0x1F4uLL, "{\"measuredLoss\"\t:{");
          uint64_t v63 = (unsigned __int16 *)(a1 + 476);
          for (unint64_t m = 1; m != 32; ++m)
          {
            if (m <= 1) {
              uint64_t v65 = "";
            }
            else {
              uint64_t v65 = ",";
            }
            int v66 = *v63;
            v63 += 70;
            __sprintf_chk((char *)buf, 0, 0x1F4uLL, "%s%s\"%d\":%2d\t", (const char *)buf, v65, m, v66);
          }
          VRLogfilePrintWithTimestamp(*(void *)(a1 + 64), "%s}}\n", v67, v68, v69, v70, v71, v72, (char)buf);
          unsigned int RedundancyLevelFromPLR = _VCRedundancyControlAlgorithmVideo_GetRedundancyLevelFromPLR(*(double *)(a1 + 120));
          uint64_t v74 = FECUtil_FECPercentageToLevelofProtection(RedundancyLevelFromPLR);
          int v75 = FECUtil_ParityGroupTransmissionCountForFECLevel(v74);
          *(_WORD *)(a1 + 128) = 32;
          long long v76 = (unsigned char *)(a1 + 133);
          for (uint64_t n = 1; n != 32; ++n)
          {
            char RealNumParity = FECUtil_GetRealNumParity(n, v74);
            *(v76 - 1) = n;
            *long long v76 = RealNumParity * v75;
            v76 += 2;
          }
          __sprintf_chk((char *)buf, 0, 0x1F4uLL, "{\"vector\"\t:{");
          long long v79 = (unsigned __int16 *)(a1 + 472);
          for (iuint64_t i = 1; ii != 32; ++ii)
          {
            int v81 = *v79;
            v79 += 70;
            int v82 = v75 * v81;
            if (ii <= 1) {
              long long v83 = "";
            }
            else {
              long long v83 = ",";
            }
            __sprintf_chk((char *)buf, 0, 0x1F4uLL, "%s%s\"%d\":%2d\t", (const char *)buf, v83, ii, v82);
          }
          VRLogfilePrintWithTimestamp(*(void *)(a1 + 64), "%s}}\n", v84, v85, v86, v87, v88, v89, (char)buf);
          __sprintf_chk((char *)buf, 0, 0x1F4uLL, "{\"vectorPLR\"\t:{");
          long long v90 = (unsigned __int8 *)(a1 + 133);
          for (juint64_t j = 1; jj != 32; ++jj)
          {
            if (jj <= 1) {
              long long v92 = "";
            }
            else {
              long long v92 = ",";
            }
            int v93 = *v90;
            v90 += 2;
            __sprintf_chk((char *)buf, 0, 0x1F4uLL, "%s%s\"%d\":%2d\t", (const char *)buf, v92, jj, v93);
          }
          VRLogfilePrintWithTimestamp(*(void *)(a1 + 64), "%s}}\n", v94, v95, v96, v97, v98, v99, (char)buf);
        }
        else if (*(unsigned char *)(a1 + 81))
        {
          memset(&buf[6], 0, 494);
          uint64_t v100 = -4340;
          qmemcpy(buf, "-\t-\t-\t", 6);
          do
          {
            __sprintf_chk((char *)buf, 0, 0x1F4uLL, "%s%d\t", (const char *)buf, *(unsigned __int16 *)(a1 + 474 + v100 + 4340));
            v100 += 140;
          }
          while (v100);
          __sprintf_chk((char *)buf, 0, 0x1F4uLL, "%s\t", (const char *)buf);
          VRLogfilePrintWithTimestamp(*(void *)(a1 + 64), "%s\n", v101, v102, v103, v104, v105, v106, (char)buf);
        }
      }
      if (*(unsigned char *)(a1 + 81))
      {
        uint64_t v107 = 0;
        *(_OWORD *)a2 = *(_OWORD *)(a1 + 4680);
        long long v108 = *(_OWORD *)(a1 + 4696);
        long long v109 = *(_OWORD *)(a1 + 4712);
        long long v110 = *(_OWORD *)(a1 + 4728);
        *(_WORD *)(a2 + 64) = *(_WORD *)(a1 + 4744);
        *(_OWORD *)(a2 + 32) = v109;
        *(_OWORD *)(a2 + 48) = v110;
        *(_OWORD *)(a2 + 16) = v108;
        *(unsigned char *)(a1 + 81) = 0;
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      {
        return 2150826001;
      }
      else
      {
        uint64_t v114 = VRTraceErrorLogLevelToCSTR();
        uint64_t v115 = *MEMORY[0x1E4F47A50];
        __int16 v116 = *MEMORY[0x1E4F47A50];
        if (*MEMORY[0x1E4F47A40])
        {
          uint64_t v107 = 2150826001;
          if (os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)CMSampleTimingInfo buf = 136315650;
            *(void *)&uint8_t buf[4] = v114;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "VCFECFeedbackAnalyzer_GetFECLevelVector";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 478;
            _os_log_impl(&dword_1E1EA4000, v115, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d output not ready", buf, 0x1Cu);
          }
        }
        else
        {
          uint64_t v107 = 2150826001;
          if (os_log_type_enabled(v116, OS_LOG_TYPE_DEBUG)) {
            VCFECFeedbackAnalyzer_GetFECLevelVector_cold_3();
          }
        }
      }
    }
    else
    {
      uint64_t v107 = 2150825985;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCFECFeedbackAnalyzer_GetFECLevelVector_cold_2();
        }
      }
    }
  }
  else
  {
    uint64_t v107 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCFECFeedbackAnalyzer_GetFECLevelVector_cold_1();
      }
    }
  }
  return v107;
}

double VCFECFeedbackAnalyzer_GetVPLR(uint64_t a1)
{
  if (a1) {
    return *(double *)(a1 + 112);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCFECFeedbackAnalyzer_GetVPLR_cold_1();
    }
  }
  return NAN;
}

uint64_t VCFECFeedbackAnalyzer_CleanHistory(uint64_t a1)
{
  if (a1)
  {
    bzero(*(void **)(a1 + 88), 16 * *(int *)(a1 + 32));
    *(_DWORD *)(a1 + 82) = 0;
    uint64_t v2 = -4340;
    do
    {
      *(_WORD *)(a1 + 472 + v2 + 4340) = 0;
      v2 += 140;
    }
    while (v2);
    return 0;
  }
  else
  {
    uint64_t v3 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCFECFeedbackAnalyzer_CleanHistory_cold_1();
      }
    }
  }
  return v3;
}

void _VCFECFeedbackAnalyzer_Init(uint64_t a1)
{
}

void _VCFECFeedbackAnalyzer_Finalize(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (v2)
  {
    LogDump_CloseLog(v2);
    *(void *)(a1 + 64) = 0;
  }
  uint64_t v3 = *(void **)(a1 + 88);
  if (v3)
  {
    free(v3);
  }
}

uint64_t CannedVideoCapture_OnVideoFrame(uint64_t a1, __CVBuffer *a2, uint64_t a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  int v6 = *(pthread_mutex_t **)(a1 + 144);
  pthread_mutex_lock(v6);
  if (v6[1].__opaque[0])
  {
    long long v9 = *(_OWORD *)a3;
    uint64_t v10 = *(void *)(a3 + 16);
    CMSampleBufferRef v7 = createSampleBufferWithPixelBuffer(a2, &v9);
    long long v9 = *(_OWORD *)a3;
    uint64_t v10 = *(void *)(a3 + 16);
    VCVideoCapture_DistributeVideoFrame(a1, (uint64_t)v7, &v9, (uint64_t)&v6[1].__opaque[4]);
    FigSampleBufferRelease();
  }
  return pthread_mutex_unlock(v6);
}

uint64_t VCVideoTransmitter_SetAudioSampleTime(uint64_t result, int a2, double a3)
{
  if (result)
  {
    *(double *)(result + 104) = a3;
    *(_DWORD *)(result + 100) = a2;
  }
  return result;
}

uint64_t VCVideoTransmitter_SetMediaQueueSize(uint64_t result)
{
  if (result)
  {
    CFAllocatorRef v1 = *(uint64_t (**)(void))(result + 144);
    if (v1) {
      return v1();
    }
  }
  return result;
}

uint64_t VCVideoTransmitter_SetFECRatio(uint64_t result)
{
  if (result)
  {
    CFAllocatorRef v1 = *(uint64_t (**)(void))(result + 128);
    if (v1) {
      return v1();
    }
  }
  return result;
}

uint64_t VCVideoTransmitter_EnqueueVideoFrame(uint64_t result, uint64_t a2, long long *a3, uint64_t a4)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t, long long *, uint64_t))(result + 136);
    if (v4)
    {
      long long v5 = *a3;
      uint64_t v6 = *((void *)a3 + 2);
      return v4(result, a2, &v5, a4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t VCClientRelayVTPReceiveProc(void *a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  while (([a1 stopVTPReceiveThread] & 1) == 0 && (objc_msgSend(a1, "relayVTPPacket") & 1) != 0)
    ;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v2 = VRTraceErrorLogLevelToCSTR();
    uint64_t v3 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 136315650;
      uint64_t v6 = v2;
      __int16 v7 = 2080;
      unsigned int v8 = "VCClientRelayVTPReceiveProc";
      __int16 v9 = 1024;
      int v10 = 315;
      _os_log_impl(&dword_1E1EA4000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCCR - VCClientRelayVTPReceiveProc stop!", (uint8_t *)&v5, 0x1Cu);
    }
  }
  return 0;
}

void OUTLINED_FUNCTION_9_12(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x2Eu);
}

uint64_t RTPProcessHEVCFragmentationHeader(unsigned __int8 *a1, int a2, unsigned int *a3, int *a4, _WORD *a5, unsigned char *a6, int a7, int *a8)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (a2 > 0)
  {
    int v9 = (*a1 >> 1) & 0x3F;
    if (a8) {
      *a8 = v9;
    }
    if (v9 == 49)
    {
      if (a7) {
        unsigned int v10 = 5;
      }
      else {
        unsigned int v10 = 3;
      }
      if (v10 > a2)
      {
        uint64_t v11 = 2147549199;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            RTPProcessHEVCFragmentationHeader_cold_2();
          }
        }
        return v11;
      }
      unsigned int v13 = a1[2];
      if (a3) {
        *a3 = v13 >> 7;
      }
      if (a4) {
        *a4 = (v13 >> 6) & 1;
      }
      if (a7)
      {
        uint64_t v12 = 3;
        goto LABEL_28;
      }
    }
    else
    {
      if (a3) {
        *a3 = 1;
      }
      if (a4) {
        *a4 = 1;
      }
      if (a7 && v9 != 38)
      {
        uint64_t v12 = 2;
LABEL_28:
        *a5 = bswap32(*(unsigned __int16 *)&a1[v12]) >> 16;
        *a6 = 1;
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v14 = VRTraceErrorLogLevelToCSTR();
      int v15 = *MEMORY[0x1E4F47A50];
      double v16 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        uint64_t v11 = 0;
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
          return v11;
        }
        int v17 = (unsigned __int16)*a5;
        int v19 = 136315906;
        uint64_t v20 = v14;
        __int16 v21 = 2080;
        double v22 = "RTPProcessHEVCFragmentationHeader";
        __int16 v23 = 1024;
        int v24 = 103;
        __int16 v25 = 1024;
        int v26 = v17;
        _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received decoding order is %hu", (uint8_t *)&v19, 0x22u);
      }
      else if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        RTPProcessHEVCFragmentationHeader_cold_3();
      }
    }
    return 0;
  }
  uint64_t v11 = 2147549199;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      RTPProcessHEVCFragmentationHeader_cold_1();
    }
  }
  return v11;
}

uint64_t RTPProcessHEVCPacket(int a1, unsigned char *a2, BOOL *a3, _WORD *a4, unsigned char *a5, int a6, const __CFAllocator *a7, const __CFAllocator *a8, uint64_t a9, CMBlockBufferRef theBuffer)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = 2147549199;
  CMBlockBufferRef targetBBuf = 0;
  unint64_t v11 = *(void *)(a9 + 8);
  if ((int)v11 < 1) {
    return v10;
  }
  int v15 = *(unsigned __int8 **)(a9 + 16);
  int v16 = (*v15 >> 1) & 0x3F;
  if (v16 != 49)
  {
    int v50 = (*v15 >> 1) & 0x3F;
    uint64_t v51 = a4;
    if (v16 == 48)
    {
      if (v11 > 1)
      {
        *a2 = 1;
        *a3 = 1;
        int v17 = v11 - 2;
        if (v17)
        {
          int v18 = (unsigned __int8 *)(*(void *)(a9 + 16) + 2);
          uint64_t v19 = 2;
          char v20 = 1;
          while (1)
          {
            if (v20)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 8) {
                VideoUtil_PrintBuffer(v18, (uint64_t)"Rx Aggregation Packet", v17);
              }
              if (a6)
              {
                if (v17 <= 1)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
                    goto LABEL_93;
                  }
                  VRTraceErrorLogLevelToCSTR();
                  uint64_t v10 = 2147549199;
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                    RTPProcessHEVCPacket_cold_8();
                  }
                  goto LABEL_69;
                }
                _WORD *v51 = bswap32(*(unsigned __int16 *)(*(void *)(a9 + 16) + 2)) >> 16;
                *a5 = 1;
                v18 += 2;
                v19 += 2;
                v17 -= 2;
              }
            }
            if (v17 <= 1) {
              break;
            }
            unsigned int v22 = *(unsigned __int16 *)v18;
            __int16 v21 = v18 + 2;
            unsigned int v23 = bswap32(v22);
            size_t v24 = HIWORD(v23);
            int v25 = v17 - 2;
            if ((v17 - 2) < HIWORD(v23))
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                uint64_t v10 = 2147549199;
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  RTPProcessHEVCPacket_cold_10();
                }
                goto LABEL_69;
              }
LABEL_93:
              uint64_t v10 = 2147549199;
              goto LABEL_69;
            }
            CMBlockBufferRef targetBBuf = 0;
            OSStatus DataPointer = VCBlockBufferUtilities_CreateAndGetDataPointer(a7, 0, 4uLL, a8, 0, 0, 4uLL, 1u, &targetBBuf);
            if (!DataPointer)
            {
              uint64_t v10 = 2147549187;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  RTPProcessHEVCPacket_cold_11();
                }
              }
              goto LABEL_69;
            }
            *(_DWORD *)OSStatus DataPointer = bswap32(v24);
            if (CMBlockBufferAppendBufferReference(theBuffer, targetBBuf, 0, 4uLL, 0))
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  RTPProcessHEVCPacket_cold_13();
                }
              }
              goto LABEL_68;
            }
            if (CMBlockBufferAppendBufferReference(theBuffer, *(CMBlockBufferRef *)a9, v19 + 2, v24, 0))
            {
              uint64_t v10 = 2147549187;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  RTPProcessHEVCPacket_cold_12();
                }
              }
              goto LABEL_69;
            }
            if (targetBBuf)
            {
              CFRelease(targetBBuf);
              CMBlockBufferRef targetBBuf = 0;
            }
            char v20 = 0;
            v19 += 2 + v24;
            int v18 = &v21[v24];
            int v17 = v25 - v24;
            if (v25 <= (int)v24) {
              goto LABEL_61;
            }
          }
          if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
            goto LABEL_93;
          }
          VRTraceErrorLogLevelToCSTR();
          uint64_t v10 = 2147549199;
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            RTPProcessHEVCPacket_cold_9();
          }
          goto LABEL_69;
        }
LABEL_61:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          uint64_t v42 = VRTraceErrorLogLevelToCSTR();
          __int16 v43 = *MEMORY[0x1E4F47A50];
          unsigned __int16 v44 = *MEMORY[0x1E4F47A50];
          if (*MEMORY[0x1E4F47A40])
          {
            BOOL v45 = os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT);
            uint64_t v10 = 0;
            int v46 = (int)v51;
            if (!v45) {
              goto LABEL_69;
            }
            if (v51) {
              int v46 = (unsigned __int16)*v51;
            }
            *(_DWORD *)CMSampleTimingInfo buf = 136316418;
            uint64_t v56 = v42;
            __int16 v57 = 2080;
            uint64_t v58 = "RTPProcessHEVCPacket";
            __int16 v59 = 1024;
            int v60 = 326;
            __int16 v61 = 1024;
            int v62 = v50;
            __int16 v63 = 1024;
            int v64 = v46;
            __int16 v65 = 1024;
            int v66 = a6;
            _os_log_impl(&dword_1E1EA4000, v43, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received packet with NAL unit type %d, decoding order %u, shouldProcessDecodingOrder %d", buf, 0x2Eu);
          }
          else
          {
            BOOL v47 = os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG);
            int v48 = (int)v51;
            if (v47)
            {
              if (v51) {
                int v48 = (unsigned __int16)*v51;
              }
              *(_DWORD *)CMSampleTimingInfo buf = 136316418;
              uint64_t v56 = v42;
              __int16 v57 = 2080;
              uint64_t v58 = "RTPProcessHEVCPacket";
              __int16 v59 = 1024;
              int v60 = 326;
              __int16 v61 = 1024;
              int v62 = v50;
              __int16 v63 = 1024;
              int v64 = v48;
              __int16 v65 = 1024;
              int v66 = a6;
              _os_log_debug_impl(&dword_1E1EA4000, v43, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Received packet with NAL unit type %d, decoding order %u, shouldProcessDecodingOrder %d", buf, 0x2Eu);
            }
          }
        }
LABEL_68:
        uint64_t v10 = 0;
        goto LABEL_69;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          RTPProcessHEVCPacket_cold_7();
        }
      }
    }
    else
    {
      if (v11 <= 1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            RTPProcessHEVCPacket_cold_1();
          }
        }
        goto LABEL_69;
      }
      *a2 = 1;
      *a3 = 1;
      if (a6)
      {
        if (v11 <= 3)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              RTPProcessHEVCPacket_cold_2();
            }
          }
          goto LABEL_69;
        }
        *a4 = bswap32(*(unsigned __int16 *)(*(void *)(a9 + 16) + 2)) >> 16;
        *a5 = 1;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          uint64_t v28 = VRTraceErrorLogLevelToCSTR();
          uint64_t v29 = *MEMORY[0x1E4F47A50];
          float v30 = *MEMORY[0x1E4F47A50];
          if (*MEMORY[0x1E4F47A40])
          {
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              int v31 = (unsigned __int16)*a4;
              *(_DWORD *)CMSampleTimingInfo buf = 136315906;
              uint64_t v56 = v28;
              __int16 v57 = 2080;
              uint64_t v58 = "RTPProcessHEVCPacket";
              __int16 v59 = 1024;
              int v60 = 304;
              __int16 v61 = 1024;
              int v62 = v31;
              _os_log_impl(&dword_1E1EA4000, v29, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received decoding order is %hu", buf, 0x22u);
            }
          }
          else if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          {
            RTPProcessHEVCPacket_cold_6();
          }
        }
        size_t v38 = 4;
      }
      else
      {
        size_t v38 = 2;
      }
      uint64_t v40 = VCBlockBufferUtilities_CreateAndGetDataPointer(a7, 0, 6uLL, a8, 0, 0, 6uLL, 1u, &targetBBuf);
      if (v40)
      {
        if (a6) {
          int v41 = -2;
        }
        else {
          int v41 = 0;
        }
        *(_DWORD *)uint64_t v40 = bswap32(*(_DWORD *)(a9 + 8) + v41);
        v40[4] = **(unsigned char **)(a9 + 16);
        v40[5] = *(unsigned char *)(*(void *)(a9 + 16) + 1);
        if (CMBlockBufferAppendBufferReference(theBuffer, targetBBuf, 0, 6uLL, 0))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              RTPProcessHEVCPacket_cold_5();
            }
          }
          goto LABEL_68;
        }
        if (!CMBlockBufferAppendBufferReference(theBuffer, *(CMBlockBufferRef *)a9, v38, *(void *)(a9 + 8) - v38, 0)) {
          goto LABEL_61;
        }
        uint64_t v10 = 2147549187;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            RTPProcessHEVCPacket_cold_4();
          }
        }
      }
      else
      {
        uint64_t v10 = 2147549187;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            RTPProcessHEVCPacket_cold_3();
          }
        }
      }
    }
LABEL_69:
    if (targetBBuf) {
      CFRelease(targetBBuf);
    }
    return v10;
  }
  unint64_t v27 = 3;
  if (a6) {
    unint64_t v27 = 5;
  }
  if (v11 >= v27)
  {
    int v50 = 49;
    unsigned __int8 v32 = v15[2];
    *a2 = v32 >> 7;
    *a3 = (v32 & 0x40) != 0;
    if (*a2)
    {
      uint64_t v33 = VCBlockBufferUtilities_CreateAndGetDataPointer(a7, 0, 6uLL, a8, 0, 0, 6uLL, 1u, &targetBBuf);
      if (!v33)
      {
        uint64_t v10 = 2147549187;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            RTPProcessHEVCPacket_cold_17();
          }
        }
        goto LABEL_69;
      }
      *(_DWORD *)uint64_t v33 = bswap32(*(_DWORD *)(a9 + 8) - 1);
      v33[4] = **(unsigned char **)(a9 + 16) & 0x81 | (2 * (v32 & 0x3F));
      v33[5] = *(unsigned char *)(*(void *)(a9 + 16) + 1);
      if (CMBlockBufferAppendBufferReference(theBuffer, targetBBuf, 0, 6uLL, 0))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            RTPProcessHEVCPacket_cold_18();
          }
        }
        goto LABEL_68;
      }
    }
    uint64_t v51 = a4;
    if (a6)
    {
      *a4 = bswap32(*(unsigned __int16 *)(*(void *)(a9 + 16) + 3)) >> 16;
      *a5 = 1;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        uint64_t v34 = VRTraceErrorLogLevelToCSTR();
        uint64_t v35 = *MEMORY[0x1E4F47A50];
        uint64_t v36 = *MEMORY[0x1E4F47A50];
        if (*MEMORY[0x1E4F47A40])
        {
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
          {
            int v37 = (unsigned __int16)*a4;
            *(_DWORD *)CMSampleTimingInfo buf = 136315906;
            uint64_t v56 = v34;
            __int16 v57 = 2080;
            uint64_t v58 = "RTPProcessHEVCPacket";
            __int16 v59 = 1024;
            int v60 = 273;
            __int16 v61 = 1024;
            int v62 = v37;
            _os_log_impl(&dword_1E1EA4000, v35, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received decoding order is %hu", buf, 0x22u);
          }
        }
        else if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
        {
          RTPProcessHEVCPacket_cold_16();
        }
      }
      size_t v39 = 5;
    }
    else
    {
      size_t v39 = 3;
    }
    if (!CMBlockBufferAppendBufferReference(theBuffer, *(CMBlockBufferRef *)a9, v39, *(void *)(a9 + 8) - v39, 0)) {
      goto LABEL_61;
    }
    uint64_t v10 = 2147549187;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        RTPProcessHEVCPacket_cold_15();
      }
    }
    goto LABEL_69;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      RTPProcessHEVCPacket_cold_14();
    }
  }
  return v10;
}

uint64_t VCAudioToolbox_AudioComponentFindNext()
{
  return _audioComponentStub();
}

uint64_t VCAudioToolbox_AudioComponentInstanceNew()
{
  return off_1EB5E6330();
}

uint64_t VCAudioToolbox_AudioComponentInstanceDispose()
{
  return off_1EB5E6338();
}

uint64_t VCAudioToolbox_AudioComponentCopyName()
{
  return off_1EB5E6348();
}

uint64_t VCAudioBufferList_Allocate(long long *a1, int a2, void *a3)
{
  if (!a2 || !a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCAudioBufferList_Allocate_cold_1();
    }
    return 0;
  }
  *a3 = 0;
  unsigned int v6 = *((_DWORD *)a1 + 7);
  int v7 = *((_DWORD *)a1 + 3);
  int v8 = *((_DWORD *)a1 + 4);
  if ((v7 & 0x20) != 0) {
    uint64_t v9 = v6;
  }
  else {
    uint64_t v9 = 1;
  }
  if ((v7 & 0x20) != 0) {
    int v10 = 1;
  }
  else {
    int v10 = *((_DWORD *)a1 + 7);
  }
  uint64_t v11 = 16 * (v9 - 1) + 184;
  int v12 = v11 + v6 * a2 * v8;
  unsigned int v13 = (char *)malloc_type_calloc(1uLL, v11 + v6 * a2 * v8, 0xEC3E06ACuLL);
  if (v13)
  {
    *(_DWORD *)unsigned int v13 = v12;
    long long v14 = *a1;
    long long v15 = a1[1];
    *((void *)v13 + 5) = *((void *)a1 + 4);
    *(_OWORD *)(v13 + 24) = v15;
    *(_OWORD *)(v13 + 8) = v14;
    uint64_t v16 = (*((_DWORD *)a1 + 4) * a2);
    *((_DWORD *)v13 + 22) = a2;
    *((_DWORD *)v13 + 23) = v16;
    if ((*((unsigned char *)a1 + 12) & 0x20) != 0) {
      int v17 = *((_DWORD *)a1 + 7);
    }
    else {
      int v17 = 1;
    }
    *((_DWORD *)v13 + 21) = v17;
    v13[96] = 0;
    *((int64x2_t *)v13 + 8) = vdupq_n_s64(0x7FF8000000000000uLL);
    v13[73] = 0;
    if (v9)
    {
      uint64_t v19 = &v13[v11];
      int v20 = *((_DWORD *)v13 + 40);
      __int16 v21 = (char **)(v13 + 176);
      do
      {
        unsigned __int8 *v21 = v19;
        ++v20;
        v19 += v16;
        *((_DWORD *)v21 - 2) = v10;
        *((_DWORD *)v21 - 1) = v16;
        v21 += 2;
        --v9;
      }
      while (v9);
      *((_DWORD *)v13 + 40) = v20;
    }
    *a3 = v13;
    return 1;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioBufferList_Allocate_cold_2();
      }
    }
    return *a3 != 0;
  }
}

void VCAudioBufferList_Destroy(uint64_t *a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a1 && (uint64_t v1 = *a1) != 0)
  {
    *a1 = 0;
    if (*(unsigned char *)(v1 + 144))
    {
      CFAllocatorRef v2 = *(const __CFAllocator **)(v1 + 152);
      CFAllocatorDeallocate(v2, (void *)v1);
      if (v2)
      {
        CFRelease(v2);
      }
    }
    else
    {
      free((void *)v1);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v3 = VRTraceErrorLogLevelToCSTR();
    uint64_t v4 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 136315650;
      uint64_t v6 = v3;
      __int16 v7 = 2080;
      int v8 = "VCAudioBufferList_Destroy";
      __int16 v9 = 1024;
      int v10 = 178;
      _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Nothing to do. The audio buffer list is already NULL", (uint8_t *)&v5, 0x1Cu);
    }
  }
}

uint64_t VCAudioBufferList_AllocateFrame(uint64_t a1, void *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  int v3 = *(_DWORD *)(a1 + 40);
  long long v4 = *(_OWORD *)(a1 + 16);
  v6[0] = *(_OWORD *)a1;
  v6[1] = v4;
  uint64_t v7 = *(void *)(a1 + 32);
  return VCAudioBufferList_Allocate(v6, v3, a2);
}

void VCAudioBufferList_ZeroMemory(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 160))
    {
      unint64_t v2 = 0;
      int v3 = (void **)(a1 + 176);
      do
      {
        bzero(*v3, *((unsigned int *)v3 - 1));
        ++v2;
        v3 += 2;
      }
      while (v2 < *(unsigned int *)(a1 + 160));
    }
    *(unsigned char *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 76) = 0;
    *(unsigned char *)(a1 + 64) = 1;
    *(_DWORD *)(a1 + 68) = -1024458752;
    *(void *)(a1 + 128) = 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_ZeroMemory_cold_1();
    }
  }
}

void VCAudioBufferList_InvalidateStats(uint64_t a1)
{
  if (a1)
  {
    *(unsigned char *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 76) = 0;
    *(unsigned char *)(a1 + 64) = 1;
    *(_DWORD *)(a1 + 68) = -1024458752;
    *(void *)(a1 + 128) = 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_InvalidateStats_cold_1();
    }
  }
}

BOOL VCAudioBufferList_ApplyGain(uint64_t a1, float a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  float __B = a2;
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCAudioBufferList_ApplyGain_cold_1();
    }
    return 0;
  }
  if ((*(unsigned char *)(a1 + 20) & 0x20) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCAudioBufferList_ApplyGain_cold_2();
    }
    return 0;
  }
  if (*(_DWORD *)(a1 + 160))
  {
    unint64_t v4 = 0;
    int v5 = (float **)(a1 + 176);
    do
    {
      uint64_t v6 = *v5;
      if (*(unsigned char *)(a1 + 20))
      {
        vDSP_vsmul(v6, 1, &__B, *v5, 1, *(unsigned int *)(a1 + 80));
      }
      else
      {
        float v7 = __B * 32768.0;
        if (__B <= 0.0)
        {
          int v8 = (int)(float)((float)(__B * 32768.0) + -0.5);
          if (v7 < -32768.0) {
            LOWORD(v8) = 0x8000;
          }
        }
        else
        {
          int v8 = (int)(float)((float)(__B * 32768.0) + 0.5);
          if (v7 > 32767.0) {
            LOWORD(v8) = 0x7FFF;
          }
        }
        VSMUL_Q15_Portable((__int16 *)v6, (__int16)v8, *v5, *(_DWORD *)(a1 + 80));
      }
      ++v4;
      v5 += 2;
    }
    while (v4 < *(unsigned int *)(a1 + 160));
  }
  return 1;
}

BOOL VCAudioBufferList_Mix(uint64_t a1, uint64_t a2)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCAudioBufferList_Mix_cold_3();
    }
    return 0;
  }
  if (memcmp((const void *)(a1 + 8), (const void *)(a2 + 8), 0x28uLL))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCAudioBufferList_Mix_cold_2();
    }
    return 0;
  }
  int v5 = *(_DWORD *)(a1 + 20);
  if ((v5 & 0x20) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCAudioBufferList_Mix_cold_1();
    }
    return 0;
  }
  int v6 = *(_DWORD *)(a1 + 80);
  if (v6 == *(_DWORD *)(a2 + 80))
  {
    if (v6)
    {
      int v7 = *(_DWORD *)(a1 + 160);
      if (v5)
      {
        if (v7)
        {
          unint64_t v19 = 0;
          int v20 = (float **)(a1 + 176);
          __int16 v21 = (const float **)(a2 + 176);
          do
          {
            vDSP_Length v22 = (unint64_t)*((unsigned int *)v20 - 1) >> 2;
            size_t v24 = *v20;
            v20 += 2;
            unsigned int v23 = v24;
            int v25 = *v21;
            v21 += 2;
            vDSP_vadd(v23, 1, v25, 1, v23, 1, v22);
            ++v19;
          }
          while (v19 < *(unsigned int *)(a1 + 160));
        }
      }
      else if (v7)
      {
        unint64_t v8 = 0;
        __int16 v9 = (void *)(a1 + 176);
        uint64_t v10 = (__int16 **)(a2 + 176);
        do
        {
          int v11 = *((_DWORD *)v9 - 1) >> 1;
          unsigned int v13 = (__int16 *)*v9;
          v9 += 2;
          int v12 = v13;
          long long v14 = *v10;
          v10 += 2;
          VADD_Q15_Portable(v12, v14, v12, v11);
          ++v8;
        }
        while (v8 < *(unsigned int *)(a1 + 160));
      }
      unsigned int v26 = *(unsigned __int8 *)(a1 + 96);
      if (v26 != 255)
      {
        unsigned int v27 = *(unsigned __int8 *)(a2 + 96);
        char v28 = v26 <= v27 ? *(unsigned char *)(a2 + 96) : *(unsigned char *)(a1 + 96);
        BOOL v29 = !*(unsigned char *)(a2 + 96) || v26 == 0;
        LOBYTE(v26) = v29 ? 0 : v28;
        if (v27 == 255) {
          LOBYTE(v26) = -1;
        }
      }
      *(unsigned char *)(a1 + 96) = v26;
      double v30 = *(double *)(a1 + 128);
      if (v30 <= *(double *)(a2 + 128)) {
        double v30 = *(double *)(a2 + 128);
      }
      *(double *)(a1 + 128) = v30;
      char v31 = *(unsigned char *)(a2 + 73);
      if (v31) {
        char v31 = *(unsigned char *)(a1 + 73) != 0;
      }
      *(unsigned char *)(a1 + 73) = v31;
      *(unsigned char *)(a1 + 64) = 0;
      unsigned int v32 = *(_DWORD *)(a2 + 76);
      if (v32)
      {
        unsigned int v33 = *(_DWORD *)(a1 + 76);
        int v34 = *(unsigned __int8 *)(a1 + 72);
        if (v33)
        {
          if (v32 >= v33) {
            unsigned int v35 = *(_DWORD *)(a1 + 76);
          }
          else {
            unsigned int v35 = *(_DWORD *)(a2 + 76);
          }
          if (!*(unsigned char *)(a2 + 72)) {
            unsigned int v35 = 0;
          }
          if (v32 <= v33) {
            unsigned int v32 = *(_DWORD *)(a1 + 76);
          }
          if (*(unsigned char *)(a2 + 72)) {
            unsigned int v32 = 0;
          }
          BOOL v36 = v34 == 0;
          if (*(unsigned char *)(a1 + 72)) {
            char v37 = 1;
          }
          else {
            char v37 = *(unsigned char *)(a2 + 72);
          }
          if (!v36) {
            unsigned int v32 = v35;
          }
          *(unsigned char *)(a1 + 72) = v37;
          *(_DWORD *)(a1 + 76) = v32;
          return 1;
        }
        if (*(unsigned char *)(a1 + 72)) {
          unsigned int v32 = 0;
        }
        *(_DWORD *)(a1 + 76) = v32;
        if (v34) {
          char v40 = 1;
        }
        else {
          char v40 = *(unsigned char *)(a2 + 72) != 0;
        }
      }
      else
      {
        char v38 = *(unsigned char *)(a2 + 72);
        if (v38) {
          int v39 = 0;
        }
        else {
          int v39 = *(_DWORD *)(a1 + 76);
        }
        *(_DWORD *)(a1 + 76) = v39;
        char v40 = *(unsigned char *)(a1 + 72) | v38;
      }
      *(unsigned char *)(a1 + 72) = v40;
    }
    return 1;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v15 = VRTraceErrorLogLevelToCSTR();
    uint64_t v16 = *MEMORY[0x1E4F47A50];
    BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v17 = *(_DWORD *)(a2 + 80);
    int v18 = *(_DWORD *)(a1 + 80);
    int v41 = 136316162;
    uint64_t v42 = v15;
    __int16 v43 = 2080;
    unsigned __int16 v44 = "VCAudioBufferList_Mix";
    __int16 v45 = 1024;
    int v46 = 274;
    __int16 v47 = 1024;
    int v48 = v17;
    __int16 v49 = 1024;
    int v50 = v18;
    _os_log_error_impl(&dword_1E1EA4000, v16, OS_LOG_TYPE_ERROR, " [%s] %s:%d Sample count mismatch: source=%u dest=%u don't match", (uint8_t *)&v41, 0x28u);
  }
  return 0;
}

BOOL VCAudioBufferList_MixToMono(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCAudioBufferList_MixToMono_cold_4();
    }
    return 0;
  }
  if ((*(unsigned char *)(a2 + 20) & 0x20) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCAudioBufferList_MixToMono_cold_1();
    }
    return 0;
  }
  if ((*(unsigned char *)(a1 + 20) & 1) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCAudioBufferList_MixToMono_cold_2();
    }
    return 0;
  }
  vDSP_Length v5 = *(int *)(a1 + 80);
  if (v5 != *(_DWORD *)(a2 + 80))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v12 = VRTraceErrorLogLevelToCSTR();
      unsigned int v13 = *MEMORY[0x1E4F47A50];
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      int v14 = *(_DWORD *)(a2 + 80);
      int v15 = *(_DWORD *)(a1 + 80);
      float v18 = 4.8154e-34;
      uint64_t v19 = v12;
      __int16 v20 = 2080;
      __int16 v21 = "VCAudioBufferList_MixToMono";
      __int16 v22 = 1024;
      int v23 = 319;
      __int16 v24 = 1024;
      int v25 = v14;
      __int16 v26 = 1024;
      int v27 = v15;
      _os_log_error_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_ERROR, " [%s] %s:%d Sample count sourceMultiChannelBufferList=%u and destMonoBufferList=%u don't match", (uint8_t *)&v18, 0x28u);
    }
    return 0;
  }
  int v7 = (unsigned int *)(a2 + 160);
  unsigned int v6 = *(_DWORD *)(a2 + 160);
  if (!v6)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v16 = VRTraceErrorLogLevelToCSTR();
      int v17 = *MEMORY[0x1E4F47A50];
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCAudioBufferList_MixToMono_cold_3(v16, (uint64_t)v7, v17);
    }
    return 0;
  }
  unint64_t v8 = 0;
  float v18 = 1.0 / (float)v6;
  __int16 v9 = (const float **)(a2 + 176);
  do
  {
    uint64_t v10 = *v9;
    v9 += 2;
    vDSP_vadd(*(const float **)(a1 + 176), 1, v10, 1, *(float **)(a1 + 176), 1, v5);
    ++v8;
  }
  while (v8 < *v7);
  vDSP_vsmul(*(const float **)(a1 + 176), 1, &v18, *(float **)(a1 + 176), 1, v5);
  char v11 = *(unsigned char *)(a1 + 73);
  if (v11) {
    char v11 = *(unsigned char *)(a2 + 73) != 0;
  }
  *(unsigned char *)(a1 + 73) = v11;
  return 1;
}

uint64_t VCAudioBufferList_AppendSamples(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioBufferList_AppendSamples_cold_2();
      }
    }
    return 0;
  }
  LODWORD(v5) = a4;
  unint64_t v8 = (uint64_t *)(a1 + 8);
  __int16 v9 = (uint64_t *)(a2 + 8);
  if (memcmp((const void *)(a1 + 8), (const void *)(a2 + 8), 0x28uLL))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v10 = VRTraceErrorLogLevelToCSTR();
      char v11 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        uint64_t v12 = *v9;
        uint64_t v13 = *v8;
        int v27 = 136316162;
        uint64_t v28 = v10;
        __int16 v29 = 2080;
        double v30 = "VCAudioBufferList_AppendSamples";
        __int16 v31 = 1024;
        int v32 = 346;
        __int16 v33 = 2048;
        uint64_t v34 = v12;
        __int16 v35 = 2048;
        uint64_t v36 = v13;
        _os_log_error_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_ERROR, " [%s] %s:%d Formats don't match: source=%f dest=%f", (uint8_t *)&v27, 0x30u);
      }
    }
    return 0;
  }
  unsigned int v15 = *(_DWORD *)(a2 + 80) - a3;
  unsigned int v16 = *(_DWORD *)(a1 + 80);
  if (v15 >= *(_DWORD *)(a1 + 88) - v16) {
    unsigned int v15 = *(_DWORD *)(a1 + 88) - v16;
  }
  if (v15 >= v5) {
    uint64_t v5 = v5;
  }
  else {
    uint64_t v5 = v15;
  }
  if (v5)
  {
    *(double *)(a1 + 56) = (double)a3 / *(double *)(a2 + 8) + *(double *)(a2 + 56) - (double)v16 / *(double *)(a1 + 8);
    *(_DWORD *)(a1 + 48) = a3 - v16 + *(_DWORD *)(a2 + 48);
    if (*(_DWORD *)(a1 + 160))
    {
      unint64_t v17 = 0;
      float v18 = (uint64_t *)(a1 + 176);
      uint64_t v19 = (uint64_t *)(a2 + 176);
      do
      {
        uint64_t v20 = *v18;
        v18 += 2;
        int v21 = *(_DWORD *)(a1 + 24);
        __int16 v22 = (void *)(v20 + (v21 * *(_DWORD *)(a1 + 80)));
        uint64_t v23 = *v19;
        v19 += 2;
        memcpy(v22, (const void *)(v23 + *(_DWORD *)(a2 + 24) * a3), (v21 * v5));
        ++v17;
      }
      while (v17 < *(unsigned int *)(a1 + 160));
    }
    _VCAudioBufferList_ComputeVoiceActivityAppend(a1, a2, a3);
    VCAudioBufferList_SetSampleCount(a1, *(_DWORD *)(a1 + 80) + v5);
    *(unsigned char *)(a1 + 64) = 0;
    *(unsigned char *)(a1 + 96) = *(unsigned char *)(a2 + 96);
    *(void *)(a1 + 128) = *(void *)(a2 + 128);
    *(unsigned char *)(a1 + 73) = *(unsigned char *)(a2 + 73);
    if (v5 < *(_DWORD *)(a2 + 80) && (int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v24 = VRTraceErrorLogLevelToCSTR();
      int v25 = *MEMORY[0x1E4F47A50];
      __int16 v26 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          int v27 = 136315650;
          uint64_t v28 = v24;
          __int16 v29 = 2080;
          double v30 = "VCAudioBufferList_AppendSamples";
          __int16 v31 = 1024;
          int v32 = 378;
          _os_log_impl(&dword_1E1EA4000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unable to append all the source samples!", (uint8_t *)&v27, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
      {
        VCAudioBufferList_AppendSamples_cold_1();
      }
    }
  }
  return v5;
}

uint64_t _VCAudioBufferList_ComputeVoiceActivityAppend(uint64_t result, uint64_t a2, unsigned int a3)
{
  unsigned int v3 = *(_DWORD *)(a2 + 76);
  int v4 = *(_DWORD *)(result + 80);
  if (*(_DWORD *)(a2 + 80) - a3 >= *(_DWORD *)(result + 88) - v4) {
    unsigned int v5 = *(_DWORD *)(result + 88) - v4;
  }
  else {
    unsigned int v5 = *(_DWORD *)(a2 + 80) - a3;
  }
  if (v3 >= a3) {
    unsigned int v6 = v3 - a3;
  }
  else {
    unsigned int v6 = 0;
  }
  int v7 = *(unsigned __int8 *)(a2 + 72);
  if (v3 > a3 && v6 < v5)
  {
    if (*(unsigned char *)(a2 + 72))
    {
      if (*(_DWORD *)(result + 76))
      {
        if (*(unsigned char *)(result + 72)) {
          int v4 = *(_DWORD *)(result + 76);
        }
        else {
          int v4 = 0;
        }
      }
      else
      {
        v4 += v6;
        if (*(unsigned char *)(result + 72)) {
          int v4 = 0;
        }
      }
    }
    else
    {
      v4 += v6;
    }
LABEL_32:
    *(_DWORD *)(result + 76) = v4;
    *(unsigned char *)(result + 72) = v7;
    return result;
  }
  BOOL v11 = v7 == 0;
  int v7 = v7 != 0;
  int v9 = v11;
  if (v3 > a3) {
    int v7 = v9;
  }
  int v10 = *(unsigned __int8 *)(result + 72);
  if (v10 != v7)
  {
    if (*(_DWORD *)(result + 76)) {
      BOOL v11 = v10 == 0;
    }
    else {
      BOOL v11 = 0;
    }
    if (v11) {
      int v4 = 0;
    }
    goto LABEL_32;
  }
  return result;
}

uint64_t VCAudioBufferList_SetSampleCount(uint64_t result, unsigned int a2)
{
  if (result)
  {
    unsigned int v2 = *(_DWORD *)(result + 88);
    if (v2 >= a2) {
      unsigned int v2 = a2;
    }
    char v3 = *(unsigned char *)(result + 64);
    if (v3) {
      char v3 = *(_DWORD *)(result + 80) == v2;
    }
    *(unsigned char *)(result + 64) = v3;
    *(_DWORD *)(result + 80) = v2;
    uint64_t v4 = *(unsigned int *)(result + 160);
    if (v4)
    {
      int v5 = *(_DWORD *)(result + 24) * v2;
      unsigned int v6 = (int *)(result + 172);
      do
      {
        int *v6 = v5;
        v6 += 4;
        --v4;
      }
      while (v4);
    }
  }
  return result;
}

uint64_t VCAudioBufferList_Append(uint64_t a1, uint64_t a2, unsigned int a3)
{
  return VCAudioBufferList_AppendSamples(a1, a2, a3, -1);
}

uint64_t VCAudioBufferList_AppendSilence(uint64_t a1, int a2, unsigned int a3, double a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    int v6 = *(_DWORD *)(a1 + 80);
    unsigned int v7 = *(_DWORD *)(a1 + 88) - v6;
    if (v7 >= a3) {
      uint64_t v8 = a3;
    }
    else {
      uint64_t v8 = v7;
    }
    if (v8)
    {
      if (!v6)
      {
        *(double *)(a1 + 56) = a4;
        *(_DWORD *)(a1 + 48) = a2;
        *(_WORD *)(a1 + 72) = 0;
        *(_DWORD *)(a1 + 76) = 0;
        *(unsigned char *)(a1 + 96) = 1;
        *(void *)(a1 + 128) = 0;
      }
      if (*(_DWORD *)(a1 + 160))
      {
        unint64_t v9 = 0;
        int v10 = (uint64_t *)(a1 + 176);
        do
        {
          uint64_t v11 = *v10;
          v10 += 2;
          bzero((void *)(v11 + (*(_DWORD *)(a1 + 24) * *(_DWORD *)(a1 + 80))), (*(_DWORD *)(a1 + 24) * v8));
          ++v9;
        }
        while (v9 < *(unsigned int *)(a1 + 160));
        int v6 = *(_DWORD *)(a1 + 80);
      }
      VCAudioBufferList_SetSampleCount(a1, v6 + v8);
      *(unsigned char *)(a1 + 64) = 0;
      if (v7 < a3 && (int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        uint64_t v12 = VRTraceErrorLogLevelToCSTR();
        uint64_t v13 = *MEMORY[0x1E4F47A50];
        int v14 = *MEMORY[0x1E4F47A50];
        if (*MEMORY[0x1E4F47A40])
        {
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            int v16 = 136315650;
            uint64_t v17 = v12;
            __int16 v18 = 2080;
            uint64_t v19 = "VCAudioBufferList_AppendSilence";
            __int16 v20 = 1024;
            int v21 = 418;
            _os_log_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unable to append all the source samples!", (uint8_t *)&v16, 0x1Cu);
          }
        }
        else if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          VCAudioBufferList_AppendSilence_cold_2();
        }
      }
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioBufferList_AppendSilence_cold_1();
      }
    }
    return 0;
  }
  return v8;
}

BOOL VCAudioBufferList_ReplaceSamples(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCAudioBufferList_ReplaceSamples_cold_1();
    }
    return 0;
  }
  int v6 = (uint64_t *)(a1 + 8);
  unsigned int v7 = (uint64_t *)(a2 + 8);
  if (memcmp((const void *)(a1 + 8), (const void *)(a2 + 8), 0x28uLL))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v8 = VRTraceErrorLogLevelToCSTR();
      unint64_t v9 = *MEMORY[0x1E4F47A50];
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      uint64_t v11 = *v7;
      uint64_t v12 = *v6;
      int v22 = 136316162;
      uint64_t v23 = v8;
      __int16 v24 = 2080;
      int v25 = "VCAudioBufferList_ReplaceSamples";
      __int16 v26 = 1024;
      int v27 = 430;
      __int16 v28 = 2048;
      uint64_t v29 = v11;
      __int16 v30 = 2048;
      uint64_t v31 = v12;
      _os_log_error_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_ERROR, " [%s] %s:%d Formats don't match: source=%f dest=%f", (uint8_t *)&v22, 0x30u);
    }
    return 0;
  }
  unsigned int v13 = *(_DWORD *)(a2 + 80);
  BOOL v14 = v13 >= a3;
  unsigned int v15 = v13 - a3;
  if (!v14 || *(_DWORD *)(a1 + 80) > v15) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 160))
  {
    unint64_t v16 = 0;
    uint64_t v17 = (void **)(a1 + 176);
    __int16 v18 = (uint64_t *)(a2 + 176);
    do
    {
      __int16 v20 = *v17;
      v17 += 2;
      uint64_t v19 = v20;
      uint64_t v21 = *v18;
      v18 += 2;
      memcpy(v19, (const void *)(v21 + *(_DWORD *)(a2 + 24) * a3), (*(_DWORD *)(a1 + 24) * *(_DWORD *)(a1 + 80)));
      ++v16;
    }
    while (v16 < *(unsigned int *)(a1 + 160));
  }
  _VCAudioBufferList_ComputeVoiceActivityAppend(a1, a2, a3);
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 96) = *(unsigned char *)(a2 + 96);
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  *(unsigned char *)(a1 + 73) = *(unsigned char *)(a2 + 73);
  return 1;
}

uint64_t VCAudioBufferList_Shift(uint64_t a1, unsigned int a2)
{
  if (a1)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 80);
    if (v3 >= a2) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = v3;
    }
    unsigned int v5 = v3 - v4;
    if (v3 > a2 && *(_DWORD *)(a1 + 160))
    {
      unint64_t v6 = 0;
      unsigned int v7 = (void **)(a1 + 176);
      do
      {
        uint64_t v8 = (char *)*v7;
        v7 += 2;
        memmove(v8, &v8[(*(_DWORD *)(a1 + 24) * v4)], *(_DWORD *)(a1 + 24) * v5);
        ++v6;
      }
      while (v6 < *(unsigned int *)(a1 + 160));
      unsigned int v5 = *(_DWORD *)(a1 + 80) - v4;
    }
    *(_DWORD *)(a1 + 48) += v4;
    *(double *)(a1 + 56) = *(double *)(a1 + 56) + (double)v4 / *(double *)(a1 + 8);
    VCAudioBufferList_SetSampleCount(a1, v5);
    *(unsigned char *)(a1 + 64) = 0;
    unsigned int v9 = *(_DWORD *)(a1 + 76);
    int v10 = *(_DWORD *)(a1 + 80);
    BOOL v11 = v9 >= v4;
    int v12 = v9 - v4;
    if (!v11) {
      int v12 = 0;
    }
    *(_DWORD *)(a1 + 76) = v12;
    if (!v10) {
      *(_WORD *)(a1 + 72) = 0;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioBufferList_Shift_cold_1();
      }
    }
    return 0;
  }
  return v4;
}

BOOL VCAudioBufferList_Convert(uint64_t a1, uint64_t a2, AudioConverterRef inAudioConverter)
{
  v19[1] = *MEMORY[0x1E4F143B8];
  v19[0] = a1;
  if (a1 && a2)
  {
    char v5 = *(unsigned char *)(a1 + 96);
    *(_DWORD *)(a2 + 80) = *(_DWORD *)(a2 + 88);
    *(unsigned char *)(a2 + 96) = v5;
    *(void *)(a2 + 128) = *(void *)(a1 + 128);
    OSStatus v6 = AudioConverterFillComplexBuffer(inAudioConverter, (AudioConverterComplexInputDataProc)VCAudioBufferListConverterCallback, v19, (UInt32 *)(a2 + 80), (AudioBufferList *)(a2 + 160), 0);
    BOOL v8 = v6 == 0;
    if (v6)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          VCAudioBufferList_Convert_cold_1();
        }
      }
      LODWORD(v9) = *(_DWORD *)(a2 + 88);
      double v11 = (double)v9;
      LODWORD(v10) = *(_DWORD *)(a1 + 80);
      double v12 = *(double *)(a2 + 8) * (double)v10 / *(double *)(a1 + 8);
      if (v12 <= v11) {
        double v11 = v12;
      }
      *(_DWORD *)(a2 + 80) = v11;
      if (*(_DWORD *)(a2 + 160))
      {
        unint64_t v13 = 0;
        BOOL v14 = (void **)(a2 + 176);
        do
        {
          size_t v15 = (*(_DWORD *)(a2 + 24) * *(_DWORD *)(a2 + 80));
          *((_DWORD *)v14 - 1) = v15;
          unint64_t v16 = *v14;
          v14 += 2;
          bzero(v16, v15);
          ++v13;
        }
        while (v13 < *(unsigned int *)(a2 + 160));
      }
      *(_DWORD *)(a2 + 76) = 0;
      *(unsigned char *)(a2 + 72) = 0;
      char v17 = 1;
    }
    else
    {
      *(_DWORD *)(a2 + 68) = *(_DWORD *)(a1 + 68);
      LODWORD(v7) = *(_DWORD *)(a1 + 76);
      *(_DWORD *)(a2 + 76) = (*(double *)(a2 + 8) * (double)v7 / *(double *)(a1 + 8));
      *(unsigned char *)(a2 + 72) = *(unsigned char *)(a1 + 72);
      char v17 = *(unsigned char *)(a1 + 96);
    }
    *(unsigned char *)(a2 + 96) = v17;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioBufferList_Convert_cold_2();
      }
    }
    return 0;
  }
  return v8;
}

uint64_t VCAudioBufferListConverterCallback(uint64_t a1, int *a2, unsigned int *a3, uint64_t a4, void *a5)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (a1 && a2 && a3 && a5)
  {
    BOOL v8 = (_DWORD *)*a5;
    if (*a5)
    {
      if (v8[40] == *a3)
      {
        uint64_t v9 = (v8[43] / v8[6]);
        if (v9 < *a2 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          uint64_t v10 = VRTraceErrorLogLevelToCSTR();
          double v11 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
          {
            int v21 = *a2;
            int v22 = 136316162;
            uint64_t v23 = v10;
            __int16 v24 = 2080;
            int v25 = "VCAudioBufferListConverterCallback";
            __int16 v26 = 1024;
            int v27 = 517;
            __int16 v28 = 1024;
            int v29 = v21;
            __int16 v30 = 2048;
            uint64_t v31 = v9;
            _os_log_error_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_ERROR, " [%s] %s:%d Insufficent input samples: needed = %d, available = %lu", (uint8_t *)&v22, 0x2Cu);
          }
        }
        *a2 = v9;
        uint64_t v12 = *a3;
        if (v12)
        {
          unint64_t v13 = v8 + 44;
          BOOL v14 = a3 + 4;
          do
          {
            *BOOL v14 = *v13;
            *(v14 - 1) = *(v13 - 1);
            v13 += 2;
            v14 += 2;
            --v12;
          }
          while (v12);
        }
        uint64_t v15 = 0;
        *a5 = 0;
      }
      else
      {
        uint64_t v15 = 2003329396;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          uint64_t v16 = VRTraceErrorLogLevelToCSTR();
          char v17 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
          {
            int v19 = v8[40];
            int v20 = *a3;
            int v22 = 136316162;
            uint64_t v23 = v16;
            __int16 v24 = 2080;
            int v25 = "VCAudioBufferListConverterCallback";
            __int16 v26 = 1024;
            int v27 = 510;
            __int16 v28 = 1024;
            int v29 = v19;
            __int16 v30 = 1024;
            LODWORD(v31) = v20;
            _os_log_error_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_ERROR, " [%s] %s:%d Number of buffers in sample buffer and io data do not match. inAudioBuffer=%d, ioData=%d.", (uint8_t *)&v22, 0x28u);
          }
        }
      }
    }
    else
    {
      *a2 = 0;
      return 4294967201;
    }
  }
  else
  {
    uint64_t v15 = 2003329396;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioBufferListConverterCallback_cold_1();
      }
    }
  }
  return v15;
}

uint64_t VCAudioBufferList_GetSampleFormat(uint64_t a1)
{
  if (a1) {
    return a1 + 8;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_GetSampleFormat_cold_1();
    }
  }
  return 0;
}

uint64_t VCAudioBufferList_GetAudioBufferList(uint64_t a1)
{
  if (a1) {
    return a1 + 160;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_GetAudioBufferList_cold_1();
    }
  }
  return 0;
}

uint64_t VCAudioBufferList_GetBufferAtIndex(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  v4[3] = *MEMORY[0x1E4F143B8];
  memset(v4, 0, 24);
  if (VCAudioBufferList_GetSizedBufferAtIndex(a1, a2, a3, v4)) {
    return v4[0];
  }
  else {
    return 0;
  }
}

BOOL VCAudioBufferList_GetSizedBufferAtIndex(uint64_t a1, unsigned int a2, _DWORD *a3, void *a4)
{
  if (a1 && *(_DWORD *)(a1 + 160) > a2)
  {
    if (a3) {
      *a3 = *(_DWORD *)(a1 + 80);
    }
    uint64_t v4 = a1 + 16 * a2;
    uint64_t v5 = *(void *)(v4 + 176);
    uint64_t v6 = *(unsigned int *)(v4 + 172);
    *a4 = v5;
    a4[1] = v6;
    a4[2] = v6;
    return 1;
  }
  else
  {
    if (a3) {
      *a3 = 0;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      VCAudioBufferList_GetSizedBufferAtIndex_cold_1();
    }
    return 0;
  }
}

void VCAudioBufferList_Reset(uint64_t a1)
{
  if (a1)
  {
    if ((*(unsigned char *)(a1 + 20) & 0x20) != 0) {
      int v2 = 1;
    }
    else {
      int v2 = *(_DWORD *)(a1 + 36);
    }
    int v3 = *(_DWORD *)(a1 + 160);
    *(unsigned char *)(a1 + 64) = 0;
    VCAudioBufferList_SetSampleCount(a1, 0);
    *(_WORD *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 76) = 0;
    *(unsigned char *)(a1 + 96) = 0;
    uint64_t v4 = MEMORY[0x1E4F1F9F8];
    *(_OWORD *)(a1 + 100) = *MEMORY[0x1E4F1F9F8];
    *(void *)(a1 + 116) = *(void *)(v4 + 16);
    *(int64x2_t *)(a1 + 128) = vdupq_n_s64(0x7FF8000000000000uLL);
    uint64_t v5 = *(unsigned int *)(a1 + 160);
    if (v5)
    {
      uint64_t v6 = a1 + 16 * (v3 - 1) + 184;
      uint64_t v7 = *(unsigned int *)(a1 + 92);
      BOOL v8 = (uint64_t *)(a1 + 176);
      do
      {
        *BOOL v8 = v6;
        v6 += v7;
        *((_DWORD *)v8 - 2) = v2;
        *((_DWORD *)v8 - 1) = v7;
        v8 += 2;
        --v5;
      }
      while (v5);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_Reset_cold_1();
    }
  }
}

void VCAudioBufferList_ResetDataPointers(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if ((*(unsigned char *)(a1 + 20) & 0x20) != 0) {
      int v2 = *(_DWORD *)(a1 + 36);
    }
    else {
      int v2 = 1;
    }
    LODWORD(v3) = *(_DWORD *)(a1 + 160);
    if (v3 != v2)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v4 = VRTraceErrorLogLevelToCSTR();
        uint64_t v5 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v6 = *(_DWORD *)(a1 + 160);
          int v7 = *(_DWORD *)(a1 + 36);
          int v11 = 136316162;
          uint64_t v12 = v4;
          __int16 v13 = 2080;
          BOOL v14 = "VCAudioBufferList_ResetDataPointers";
          __int16 v15 = 1024;
          int v16 = 651;
          __int16 v17 = 1024;
          int v18 = v6;
          __int16 v19 = 1024;
          int v20 = v7;
          _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Number of buffers is incorrect. mNumberBuffers=%u mChannelsPerFrame=%u.", (uint8_t *)&v11, 0x28u);
        }
      }
      LODWORD(v3) = *(_DWORD *)(a1 + 160);
    }
    if (v3)
    {
      uint64_t v8 = a1 + 16 * (v3 - 1) + 184;
      uint64_t v9 = *(unsigned int *)(a1 + 92);
      uint64_t v3 = v3;
      uint64_t v10 = (uint64_t *)(a1 + 176);
      do
      {
        *uint64_t v10 = v8;
        v10 += 2;
        v8 += v9;
        --v3;
      }
      while (v3);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_ResetDataPointers_cold_1();
    }
  }
}

uint64_t VCAudioBufferList_ResampleAppend(uint64_t a1, uint64_t a2, int a3, OpaqueAudioConverter *a4)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    MEMORY[0x1F4188790](a1);
    uint64_t v10 = (uint8_t *)&v46;
    uint64_t v8 = 1;
    goto LABEL_5;
  }
  uint64_t v8 = *(unsigned int *)(a2 + 160);
  MEMORY[0x1F4188790](a1);
  uint64_t v10 = &buf[-((v9 + 15) & 0xFFFFFFFF0)];
  if (v8)
  {
LABEL_5:
    memset(v10, 170, 8 * v8);
    goto LABEL_6;
  }
  uint64_t v8 = 0;
LABEL_6:
  bzero(v10, 8 * v8);
  if (!a1 || !a2 || !a4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
      goto LABEL_53;
    }
    uint64_t v38 = VRTraceErrorLogLevelToCSTR();
    int v39 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      goto LABEL_53;
    }
    *(_DWORD *)CMSampleTimingInfo buf = 136316418;
    uint64_t v48 = v38;
    __int16 v49 = 2080;
    int v50 = "VCAudioBufferList_ResampleAppend";
    __int16 v51 = 1024;
    int v52 = 695;
    __int16 v53 = 2048;
    *(void *)uint64_t v54 = a2;
    *(_WORD *)&v54[8] = 2048;
    uint64_t v55 = a1;
    __int16 v56 = 2048;
    __int16 v57 = a4;
    char v40 = " [%s] %s:%d Invalid input parameter. inSampleBuffer=%p outSampleBuffer=%p converter=%p";
    int v41 = v39;
    uint32_t v42 = 58;
LABEL_49:
    _os_log_error_impl(&dword_1E1EA4000, v41, OS_LOG_TYPE_ERROR, v40, buf, v42);
    goto LABEL_53;
  }
  int v12 = *(_DWORD *)(a2 + 80);
  LODWORD(v11) = *(_DWORD *)(a1 + 80);
  unsigned int v13 = (*(double *)(a2 + 8) * (double)v11 / *(double *)(a1 + 8));
  unsigned int v14 = v12 + v13;
  unsigned int v15 = *(_DWORD *)(a2 + 88);
  if (v12 + v13 > v15)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3) {
      goto LABEL_53;
    }
    uint64_t v43 = VRTraceErrorLogLevelToCSTR();
    unsigned __int16 v44 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      goto LABEL_53;
    }
    int v45 = *(_DWORD *)(a2 + 88);
    *(_DWORD *)CMSampleTimingInfo buf = 136316162;
    uint64_t v48 = v43;
    __int16 v49 = 2080;
    int v50 = "VCAudioBufferList_ResampleAppend";
    __int16 v51 = 1024;
    int v52 = 700;
    __int16 v53 = 1024;
    *(_DWORD *)uint64_t v54 = v14;
    *(_WORD *)&v54[4] = 1024;
    *(_DWORD *)&v54[6] = v45;
    char v40 = " [%s] %s:%d Unable to resample. Needed capacity=%d capacity=%d";
    int v41 = v44;
    uint32_t v42 = 40;
    goto LABEL_49;
  }
  if (*(_DWORD *)(a1 + 84) == *(_DWORD *)(a2 + 84))
  {
    *(_DWORD *)(a2 + 88) = v15 - v12;
    uint64_t v16 = *(unsigned int *)(a2 + 160);
    if (v16)
    {
      int v17 = *(_DWORD *)(a2 + 24);
      uint64_t v18 = (v17 * v12);
      int v19 = v17 * v13;
      int v20 = (void *)(a2 + 176);
      uint64_t v21 = v10;
      do
      {
        uint64_t v22 = *v20;
        *(void *)uint64_t v21 = *v20;
        v21 += 8;
        *int v20 = v22 + v18;
        *((_DWORD *)v20 - 1) = v19;
        v20 += 2;
        --v16;
      }
      while (v16);
    }
    if (VCAudioBufferList_Convert(a1, a2, a4))
    {
      *(_DWORD *)(a2 + 88) = v15;
      uint64_t v23 = *(unsigned int *)(a2 + 160);
      if (v23)
      {
        __int16 v24 = (void *)(a2 + 176);
        do
        {
          uint64_t v25 = *(void *)v10;
          v10 += 8;
          *__int16 v24 = v25;
          v24 += 2;
          --v23;
        }
        while (v23);
      }
      if (v12)
      {
        *(unsigned char *)(a2 + 64) = 0;
        unsigned int v26 = *(unsigned __int8 *)(a2 + 96);
        if (v26 != 255)
        {
          unsigned int v27 = *(unsigned __int8 *)(a1 + 96);
          char v28 = v26 <= v27 ? *(unsigned char *)(a1 + 96) : *(unsigned char *)(a2 + 96);
          BOOL v29 = !*(unsigned char *)(a1 + 96) || v26 == 0;
          LOBYTE(v26) = v29 ? 0 : v28;
          if (v27 == 255) {
            LOBYTE(v26) = -1;
          }
        }
        *(unsigned char *)(a2 + 96) = v26;
        double v30 = *(double *)(a2 + 128);
        if (v30 <= *(double *)(a1 + 128)) {
          double v30 = *(double *)(a1 + 128);
        }
        *(double *)(a2 + 128) = v30;
        char v31 = *(unsigned char *)(a1 + 73);
        if (v31) {
          char v31 = *(unsigned char *)(a2 + 73) != 0;
        }
      }
      else
      {
        *(unsigned char *)(a2 + 64) = *(unsigned char *)(a1 + 64);
        *(_DWORD *)(a2 + 68) = *(_DWORD *)(a1 + 68);
        *(void *)(a2 + 56) = *(void *)(a1 + 56);
        *(_DWORD *)(a2 + 48) = a3;
        *(unsigned char *)(a2 + 96) = *(unsigned char *)(a1 + 96);
        *(void *)(a2 + 128) = *(void *)(a1 + 128);
        char v31 = *(unsigned char *)(a1 + 73);
      }
      *(unsigned char *)(a2 + 73) = v31;
      uint64_t v34 = 1;
      goto LABEL_41;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioBufferList_ResampleAppend_cold_1();
      }
    }
LABEL_53:
    uint64_t v34 = 0;
    unsigned int v14 = 0;
LABEL_41:
    VCAudioBufferList_SetSampleCount(a2, v14);
    return v34;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v32 = VRTraceErrorLogLevelToCSTR();
    __int16 v33 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
    {
      int v36 = *(_DWORD *)(a1 + 84);
      int v37 = *(_DWORD *)(a2 + 84);
      *(_DWORD *)CMSampleTimingInfo buf = 136316162;
      uint64_t v48 = v32;
      __int16 v49 = 2080;
      int v50 = "VCAudioBufferList_ResampleAppend";
      __int16 v51 = 1024;
      int v52 = 703;
      __int16 v53 = 1024;
      *(_DWORD *)uint64_t v54 = v36;
      *(_WORD *)&v54[4] = 1024;
      *(_DWORD *)&v54[6] = v37;
      _os_log_error_impl(&dword_1E1EA4000, v33, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid channel count. inSampleBuffer=%d outSampleBuffer=%d", buf, 0x28u);
    }
  }
  return 0;
}

void VCAudioBufferList_InvalidateAveragePower(uint64_t a1)
{
  if (a1)
  {
    *(unsigned char *)(a1 + 64) = 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_InvalidateAveragePower_cold_1();
    }
  }
}

uint64_t VCAudioBufferList_SetTime(uint64_t result, int a2, double a3)
{
  if (result)
  {
    *(double *)(result + 56) = a3;
    *(_DWORD *)(result + 48) = a2;
  }
  return result;
}

uint64_t VCAudioBufferList_GetTimestamp(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 48);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_GetTimestamp_cold_1();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t VCAudioBufferList_SetTimestamp(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 48) = a2;
  }
  return result;
}

void VCAudioBufferList_GetAudioTimestamp(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  if (a1)
  {
    double v2 = *(double *)(a1 + 56);
    *(void *)(a2 + 8) = (unint64_t)v2;
    LODWORD(v2) = *(_DWORD *)(a1 + 48);
    *(double *)a2 = (double)*(unint64_t *)&v2;
    *(_DWORD *)(a2 + 56) = 3;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_GetAudioTimestamp_cold_1();
    }
  }
}

uint64_t VCAudioBufferList_SetHostTimeJumpSize(uint64_t result, double a2)
{
  if (result) {
    *(double *)(result + 136) = a2;
  }
  return result;
}

double VCAudioBufferList_GetHostTimeJumpSize(uint64_t a1)
{
  if (a1) {
    return *(double *)(a1 + 136);
  }
  double v1 = 0.0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_GetHostTimeJumpSize_cold_1();
    }
  }
  return v1;
}

double VCAudioBufferList_GetHostTime(uint64_t a1)
{
  if (a1) {
    return *(double *)(a1 + 56);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_GetHostTime_cold_1();
    }
  }
  return NAN;
}

uint64_t VCAudioBufferList_GetVoiceActivity(uint64_t a1)
{
  if (a1)
  {
    return *(unsigned char *)(a1 + 72) || *(_DWORD *)(a1 + 76) != 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioBufferList_GetVoiceActivity_cold_1();
      }
    }
    return 0xFFFFFFFFLL;
  }
}

void VCAudioBufferList_SetVoiceActivity(uint64_t a1, int a2)
{
  if (a1)
  {
    *(unsigned char *)(a1 + 72) = a2 != 0;
    *(_DWORD *)(a1 + 76) = 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_SetVoiceActivity_cold_1();
    }
  }
}

uint64_t VCAudioBufferList_GetSampleCount(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 80);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    VCAudioBufferList_GetSampleCount_cold_1();
  }
  return 0;
}

uint64_t VCAudioBufferList_GetSampleCapacity(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 88);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    VCAudioBufferList_GetSampleCapacity_cold_1();
  }
  return 0;
}

uint64_t VCAudioBufferList_GetChannelCount(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 84);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    uint64_t result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    VCAudioBufferList_GetChannelCount_cold_1();
  }
  return 0;
}

void VCAudioBufferList_SetSilenceInQueue(uint64_t a1, char a2)
{
  if (a1)
  {
    *(unsigned char *)(a1 + 73) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_SetSilenceInQueue_cold_1();
    }
  }
}

BOOL VCAudioBufferList_IsSilenceInQueue(uint64_t a1)
{
  if (a1) {
    return *(unsigned char *)(a1 + 73) != 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    BOOL result = os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    VCAudioBufferList_IsSilenceInQueue_cold_1();
  }
  return 0;
}

float VCAudioBufferList_GetAveragePower(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (*(unsigned char *)(a1 + 64)) {
      return *(float *)(a1 + 68);
    }
    if (*(unsigned char *)(a1 + 20))
    {
      float __C = NAN;
      vDSP_rmsqv(*(const float **)(a1 + 176), 1, &__C, (*(_DWORD *)(a1 + 172) / *(_DWORD *)(a1 + 24)));
      double v2 = log10(__C) * 20.0;
      if (v2 <= -120.0) {
        double v2 = -120.0;
      }
      float v3 = v2;
      *(float *)(a1 + 68) = v3;
      *(unsigned char *)(a1 + 64) = 1;
      return *(float *)(a1 + 68);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_GetAveragePower_cold_1();
    }
  }
  return NAN;
}

void VCAudioBufferList_SetAveragePower(uint64_t a1, float a2)
{
  if (a1)
  {
    *(unsigned char *)(a1 + 64) = 1;
    *(float *)(a1 + 68) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_SetAveragePower_cold_1();
    }
  }
}

uint64_t VCAudioBufferList_GetSerializedSize(unsigned int *a1)
{
  if (a1) {
    return *a1;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_GetSerializedSize_cold_1();
    }
  }
  return 0;
}

CFAllocatorRef VCAudioBufferList_CreateSampleBufferAllocator()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v1 = 0;
  v2[2] = xmmword_1E25A2268;
  v2[3] = unk_1E25A2278;
  v2[4] = xmmword_1E25A2288;
  v2[0] = xmmword_1E25A2248;
  v2[1] = unk_1E25A2258;
  VCAllocatorMultiQueue_Create((const __CFAllocator *)*MEMORY[0x1E4F1CF80], (uint64_t)"VCAudioBufferListSampleBufferAllocator", 0xAu, (unint64_t *)v2, &v1);
  return v1;
}

CMSampleBufferRef VCAudioBufferList_CreateSampleBufferWithFormat(uint64_t a1, const opaqueCMFormatDescription *a2, const __CFAllocator *a3)
{
  return VCAudioBufferList_CreateSampleBufferWithFormatWithAllocator(a1, a2, a3, a3);
}

CMSampleBufferRef VCAudioBufferList_CreateSampleBufferWithFormatWithAllocator(uint64_t a1, const opaqueCMFormatDescription *a2, const __CFAllocator *a3, const __CFAllocator *a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  CMSampleBufferRef sbuf = 0;
  memset(&v21, 170, sizeof(v21));
  CMTimeMakeWithSeconds(&v21, *(Float64 *)(a1 + 56), (int)*(double *)(a1 + 8));
  CMItemCount v8 = *(unsigned int *)(a1 + 80);
  CMTime presentationTimeStamp = v21;
  OSStatus v9 = CMAudioSampleBufferCreateWithPacketDescriptions(a3, 0, 0, 0, 0, a2, v8, &presentationTimeStamp, 0, &sbuf);
  if (v9)
  {
    OSStatus v13 = v9;
    if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
      goto LABEL_12;
    }
    uint64_t v14 = VRTraceErrorLogLevelToCSTR();
    unsigned int v15 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_12;
    }
    LODWORD(presentationTimeStamp.value) = 136315906;
    *(CMTimeValue *)((char *)&presentationTimeStamp.value + 4) = v14;
    LOWORD(presentationTimeStamp.flags) = 2080;
    *(void *)((char *)&presentationTimeStamp.flags + 2) = "VCAudioBufferList_CreateSampleBufferWithFormatWithAllocator";
    HIWORD(presentationTimeStamp.epoch) = 1024;
    int v24 = 922;
    __int16 v25 = 1024;
    OSStatus v26 = v13;
    uint64_t v16 = " [%s] %s:%d Failed to create the CMSampleBuffer description: %d";
    int v17 = v15;
    goto LABEL_11;
  }
  OSStatus v10 = CMSampleBufferSetDataBufferFromAudioBufferList(sbuf, a3, a4, 0, (const AudioBufferList *)(a1 + 160));
  if (!v10)
  {
    CMSampleBufferRef v11 = sbuf;
    CMTime presentationTimeStamp = v21;
    CMSampleBufferSetOutputPresentationTimeStamp(sbuf, &presentationTimeStamp);
    return v11;
  }
  OSStatus v18 = v10;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v19 = VRTraceErrorLogLevelToCSTR();
    int v20 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(presentationTimeStamp.value) = 136315906;
      *(CMTimeValue *)((char *)&presentationTimeStamp.value + 4) = v19;
      LOWORD(presentationTimeStamp.flags) = 2080;
      *(void *)((char *)&presentationTimeStamp.flags + 2) = "VCAudioBufferList_CreateSampleBufferWithFormatWithAllocator";
      HIWORD(presentationTimeStamp.epoch) = 1024;
      int v24 = 925;
      __int16 v25 = 1024;
      OSStatus v26 = v18;
      uint64_t v16 = " [%s] %s:%d Failed to create the CMSampleBuffer: %d";
      int v17 = v20;
LABEL_11:
      _os_log_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)&presentationTimeStamp, 0x22u);
    }
  }
LABEL_12:
  if (sbuf) {
    CFRelease(sbuf);
  }
  return 0;
}

CMSampleBufferRef VCAudioBufferList_CreateSampleBufferAllocateWithAllocator(uint64_t a1, CFAllocatorRef allocator, const __CFAllocator *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CMAudioFormatDescriptionRef formatDescriptionOut = 0;
  if (CMAudioFormatDescriptionCreate(allocator, (const AudioStreamBasicDescription *)(a1 + 8), 0, 0, 0, 0, 0, &formatDescriptionOut))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v8 = VRTraceErrorLogLevelToCSTR();
      OSStatus v9 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 136315650;
        uint64_t v12 = v8;
        __int16 v13 = 2080;
        uint64_t v14 = "VCAudioBufferList_CreateSampleBufferAllocateWithAllocator";
        __int16 v15 = 1024;
        int v16 = 946;
        _os_log_impl(&dword_1E1EA4000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Failed to create format description for audio buffer", buf, 0x1Cu);
      }
    }
    SampleBufferWithFormatWithCFAllocatorRef Allocator = 0;
  }
  else
  {
    SampleBufferWithFormatWithCFAllocatorRef Allocator = VCAudioBufferList_CreateSampleBufferWithFormatWithAllocator(a1, formatDescriptionOut, allocator, a3);
  }
  if (formatDescriptionOut) {
    CFRelease(formatDescriptionOut);
  }
  return SampleBufferWithFormatWithAllocator;
}

uint64_t VCAudioBufferList_GetPriority(uint64_t a1)
{
  if (a1) {
    return *(unsigned __int8 *)(a1 + 96);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_GetPriority_cold_1();
    }
  }
  return 1;
}

void VCAudioBufferList_SetPriority(uint64_t a1, char a2)
{
  if (a1)
  {
    *(unsigned char *)(a1 + 96) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_SetPriority_cold_1();
    }
  }
}

void VCAudioBufferList_InvalidateNetworkTimestamp(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = MEMORY[0x1E4F1F9F8];
    *(_OWORD *)(a1 + 100) = *MEMORY[0x1E4F1F9F8];
    *(void *)(a1 + 116) = *(void *)(v1 + 16);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_InvalidateNetworkTimestamp_cold_1();
    }
  }
}

void VCAudioBufferList_SetNetworkTimestamp(uint64_t a1, long long *a2)
{
  if (a1 && a2)
  {
    long long v2 = *a2;
    *(void *)(a1 + 116) = *((void *)a2 + 2);
    *(_OWORD *)(a1 + 100) = v2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_SetNetworkTimestamp_cold_1();
    }
  }
}

void VCAudioBufferList_GetNetworkTimestamp(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (a1)
  {
    *(_OWORD *)a2 = *(_OWORD *)(a1 + 100);
    uint64_t v3 = *(void *)(a1 + 116);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioBufferList_GetNetworkTimestamp_cold_1();
      }
    }
    uint64_t v4 = MEMORY[0x1E4F1F9F8];
    *(_OWORD *)a2 = *MEMORY[0x1E4F1F9F8];
    uint64_t v3 = *(void *)(v4 + 16);
  }
  *(void *)(a2 + 16) = v3;
}

double VCAudioBufferList_GetVoiceProbability(uint64_t a1)
{
  if (a1) {
    return *(double *)(a1 + 128);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_GetVoiceProbability_cold_1();
    }
  }
  return NAN;
}

void VCAudioBufferList_SetVoiceProbability(uint64_t a1, double a2)
{
  if (a1)
  {
    *(double *)(a1 + 128) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCAudioBufferList_SetVoiceProbability_cold_1();
    }
  }
}

BOOL VCAudioBufferList_CopySampleBuffer(unsigned int *a1, CFAllocatorRef allocator, void *a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
      return 0;
    }
    uint64_t v20 = VRTraceErrorLogLevelToCSTR();
    CMTime v21 = *MEMORY[0x1E4F47A50];
    uint64_t v22 = *MEMORY[0x1E4F47A50];
    if (!*MEMORY[0x1E4F47A40])
    {
      BOOL result = os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG);
      if (!result) {
        return result;
      }
      VCAudioBufferList_CopySampleBuffer_cold_1();
      return 0;
    }
    BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v23) {
      return result;
    }
    int v31 = 136315650;
    uint64_t v32 = v20;
    __int16 v33 = 2080;
    uint64_t v34 = "VCAudioBufferList_CopySampleBuffer";
    __int16 v35 = 1024;
    int v36 = 1090;
    int v24 = " [%s] %s:%d Invalid sample buffer";
    goto LABEL_27;
  }
  if (!a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 8) {
      return 0;
    }
    uint64_t v25 = VRTraceErrorLogLevelToCSTR();
    CMTime v21 = *MEMORY[0x1E4F47A50];
    OSStatus v26 = *MEMORY[0x1E4F47A50];
    if (!*MEMORY[0x1E4F47A40])
    {
      BOOL result = os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG);
      if (!result) {
        return result;
      }
      VCAudioBufferList_CopySampleBuffer_cold_2();
      return 0;
    }
    BOOL v27 = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v27) {
      return result;
    }
    int v31 = 136315650;
    uint64_t v32 = v25;
    __int16 v33 = 2080;
    uint64_t v34 = "VCAudioBufferList_CopySampleBuffer";
    __int16 v35 = 1024;
    int v36 = 1091;
    int v24 = " [%s] %s:%d Invalid output sample buffer";
LABEL_27:
    _os_log_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_DEFAULT, v24, (uint8_t *)&v31, 0x1Cu);
    return 0;
  }
  *a3 = 0;
  uint64_t v6 = a1[40];
  size_t v7 = 16 * (v6 - 1) + 184;
  CFIndex v8 = v7;
  if (v6)
  {
    OSStatus v9 = a1 + 43;
    CFIndex v8 = 16 * (v6 - 1) + 184;
    do
    {
      unsigned int v10 = *v9;
      v9 += 4;
      v8 += v10;
      --v6;
    }
    while (v6);
  }
  CMSampleBufferRef v11 = (char *)CFAllocatorAllocate(allocator, v8, 0);
  if (!v11)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      uint64_t v28 = VRTraceErrorLogLevelToCSTR();
      CMTime v21 = *MEMORY[0x1E4F47A50];
      BOOL v29 = *MEMORY[0x1E4F47A50];
      if (*MEMORY[0x1E4F47A40])
      {
        BOOL v30 = os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT);
        BOOL result = 0;
        if (!v30) {
          return result;
        }
        int v31 = 136315650;
        uint64_t v32 = v28;
        __int16 v33 = 2080;
        uint64_t v34 = "VCAudioBufferList_CopySampleBuffer";
        __int16 v35 = 1024;
        int v36 = 1103;
        int v24 = " [%s] %s:%d Failed to allocate the output sample buffer";
        goto LABEL_27;
      }
      BOOL result = os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG);
      if (!result) {
        return result;
      }
      VCAudioBufferList_CopySampleBuffer_cold_3();
    }
    return 0;
  }
  uint64_t v12 = v11;
  memcpy(v11, a1, v7);
  if (a1[40])
  {
    unint64_t v13 = 0;
    uint64_t v14 = &v12[v7];
    __int16 v15 = v12 + 176;
    int v16 = a1 + 43;
    do
    {
      *__int16 v15 = v14;
      v15 += 2;
      memcpy(v14, *(const void **)(v16 + 1), *v16);
      unsigned int v17 = *v16;
      v16 += 4;
      v14 += v17;
      ++v13;
    }
    while (v13 < a1[40]);
  }
  v12[144] = 1;
  if (allocator) {
    CFTypeRef v18 = CFRetain(allocator);
  }
  else {
    CFTypeRef v18 = 0;
  }
  *((void *)v12 + 19) = v18;
  *a3 = v12;
  return 1;
}

uint64_t VCNetworkAgentCell_AddCellularAssertion()
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (_VCNetworkAgentCell_SharedInstance_onceToken != -1) {
    dispatch_once(&_VCNetworkAgentCell_SharedInstance_onceToken, &__block_literal_global_86);
  }
  uint64_t v0 = _VCNetworkAgentCell_SharedInstance_sharedInstance;
  VCObject_Lock(_VCNetworkAgentCell_SharedInstance_sharedInstance);
  if (!*(_DWORD *)(v0 + 188)
    && ([*(id *)(v0 + 192) addNetworkAgentToInterfaceNamed:*(void *)(v0 + 200)] & 1) == 0
    && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      VCNetworkAgentCell_AddCellularAssertion_cold_1();
    }
  }
  ++*(_DWORD *)(v0 + 188);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    uint64_t v1 = VRTraceErrorLogLevelToCSTR();
    long long v2 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v3 = *(_DWORD *)(v0 + 188);
      uint64_t v4 = "Overwrite cellular as network status bar icon";
      if (v3 != 1) {
        uint64_t v4 = "";
      }
      int v6 = 136316418;
      uint64_t v7 = v1;
      __int16 v8 = 2080;
      OSStatus v9 = "VCNetworkAgentCell_AddCellularAssertion";
      __int16 v10 = 1024;
      int v11 = 130;
      __int16 v12 = 2048;
      uint64_t v13 = v0;
      __int16 v14 = 2080;
      __int16 v15 = v4;
      __int16 v16 = 1024;
      int v17 = v3;
      _os_log_impl(&dword_1E1EA4000, v2, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d instance=%p %s refcount = %d", (uint8_t *)&v6, 0x36u);
    }
  }
  return VCObject_Unlock(v0);
}

uint64_t VCNetworkAgentCell_RemoveCellularAssertion()
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (_VCNetworkAgentCell_SharedInstance_onceToken != -1) {
    dispatch_once(&_VCNetworkAgentCell_SharedInstance_onceToken, &__block_literal_global_86);
  }
  uint64_t v0 = _VCNetworkAgentCell_SharedInstance_sharedInstance;
  VCObject_Lock(_VCNetworkAgentCell_SharedInstance_sharedInstance);
  int v1 = *(_DWORD *)(v0 + 188);
  BOOL v2 = __OFSUB__(v1, 1);
  int v3 = v1 - 1;
  if (v3 < 0 == v2)
  {
    *(_DWORD *)(v0 + 188) = v3;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v4 = VRTraceErrorLogLevelToCSTR();
      uint64_t v5 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v6 = *(_DWORD *)(v0 + 188);
        int v12 = 136315906;
        uint64_t v13 = v4;
        __int16 v14 = 2080;
        __int16 v15 = "VCNetworkAgentCell_RemoveCellularAssertion";
        __int16 v16 = 1024;
        int v17 = 142;
        __int16 v18 = 1024;
        LODWORD(v19) = v6;
        _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCNetworkAgentCell network status refcount is '%d'", (uint8_t *)&v12, 0x22u);
      }
    }
    if (!*(_DWORD *)(v0 + 188)
      && ([*(id *)(v0 + 192) removeNetworkAgentFromInterfaceNamed:*(void *)(v0 + 200)] & 1) == 0
      && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCNetworkAgentCell_RemoveCellularAssertion_cold_1();
      }
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    uint64_t v7 = VRTraceErrorLogLevelToCSTR();
    __int16 v8 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      int v9 = *(_DWORD *)(v0 + 188);
      __int16 v10 = "Remove overwrite cellular as network status bar icon";
      if (v9) {
        __int16 v10 = "";
      }
      int v12 = 136316418;
      uint64_t v13 = v7;
      __int16 v14 = 2080;
      __int16 v15 = "VCNetworkAgentCell_RemoveCellularAssertion";
      __int16 v16 = 1024;
      int v17 = 151;
      __int16 v18 = 2048;
      uint64_t v19 = v0;
      __int16 v20 = 2080;
      CMTime v21 = v10;
      __int16 v22 = 1024;
      int v23 = v9;
      _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d instance=%p %s refcount = %d", (uint8_t *)&v12, 0x36u);
    }
  }
  return VCObject_Unlock(v0);
}

BOOL VCNetworkAgentCell_CellularAssertionActive()
{
  if (_VCNetworkAgentCell_SharedInstance_onceToken != -1) {
    dispatch_once(&_VCNetworkAgentCell_SharedInstance_onceToken, &__block_literal_global_86);
  }
  return *(_DWORD *)(_VCNetworkAgentCell_SharedInstance_sharedInstance + 188) > 0;
}

BOOL VCMediaNegotiationBlobVideoRuleCollectionReadFrom(uint64_t a1, uint64_t a2)
{
  int v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          char v17 = 0;
          unsigned int v18 = 0;
          uint64_t v19 = 0;
          while (1)
          {
            uint64_t v20 = *v3;
            unint64_t v21 = *(void *)(a2 + v20);
            if (v21 == -1 || v21 >= *(void *)(a2 + *v4))
            {
              uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__transport;
              goto LABEL_69;
            }
            char v22 = *(unsigned char *)(*(void *)(a2 + *v7) + v21);
            *(void *)(a2 + v20) = v21 + 1;
            v19 |= (unint64_t)(v22 & 0x7F) << v17;
            if ((v22 & 0x80) == 0) {
              break;
            }
            v17 += 7;
            BOOL v23 = v18++ > 8;
            if (v23)
            {
              LODWORD(v19) = 0;
              uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__transport;
              goto LABEL_72;
            }
          }
          uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__transport;
          goto LABEL_70;
        case 2u:
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v19 = 0;
          while (2)
          {
            uint64_t v27 = *v3;
            unint64_t v28 = *(void *)(a2 + v27);
            if (v28 == -1 || v28 >= *(void *)(a2 + *v4))
            {
              uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__operation;
              goto LABEL_69;
            }
            char v29 = *(unsigned char *)(*(void *)(a2 + *v7) + v28);
            *(void *)(a2 + v27) = v28 + 1;
            v19 |= (unint64_t)(v29 & 0x7F) << v25;
            if (v29 < 0)
            {
              v25 += 7;
              BOOL v23 = v26++ > 8;
              if (v23)
              {
                LODWORD(v19) = 0;
                uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__operation;
                goto LABEL_72;
              }
              continue;
            }
            break;
          }
          uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__operation;
          goto LABEL_70;
        case 3u:
          char v30 = 0;
          unsigned int v31 = 0;
          uint64_t v19 = 0;
          while (2)
          {
            uint64_t v32 = *v3;
            unint64_t v33 = *(void *)(a2 + v32);
            if (v33 == -1 || v33 >= *(void *)(a2 + *v4))
            {
              uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__formats;
              goto LABEL_69;
            }
            char v34 = *(unsigned char *)(*(void *)(a2 + *v7) + v33);
            *(void *)(a2 + v32) = v33 + 1;
            v19 |= (unint64_t)(v34 & 0x7F) << v30;
            if (v34 < 0)
            {
              v30 += 7;
              BOOL v23 = v31++ > 8;
              if (v23)
              {
                LODWORD(v19) = 0;
                uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__formats;
                goto LABEL_72;
              }
              continue;
            }
            break;
          }
          uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__formats;
          goto LABEL_70;
        case 4u:
          char v35 = 0;
          unsigned int v36 = 0;
          uint64_t v19 = 0;
          *(unsigned char *)(a1 + 32) |= 2u;
          while (2)
          {
            uint64_t v37 = *v3;
            unint64_t v38 = *(void *)(a2 + v37);
            if (v38 == -1 || v38 >= *(void *)(a2 + *v4))
            {
              uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__preferredFormat;
              goto LABEL_69;
            }
            char v39 = *(unsigned char *)(*(void *)(a2 + *v7) + v38);
            *(void *)(a2 + v37) = v38 + 1;
            v19 |= (unint64_t)(v39 & 0x7F) << v35;
            if (v39 < 0)
            {
              v35 += 7;
              BOOL v23 = v36++ > 8;
              if (v23)
              {
                LODWORD(v19) = 0;
                uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__preferredFormat;
                goto LABEL_72;
              }
              continue;
            }
            break;
          }
          uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__preferredFormat;
          goto LABEL_70;
        case 5u:
          char v40 = 0;
          unsigned int v41 = 0;
          uint64_t v19 = 0;
          *(unsigned char *)(a1 + 32) |= 1u;
          while (2)
          {
            uint64_t v42 = *v3;
            unint64_t v43 = *(void *)(a2 + v42);
            if (v43 == -1 || v43 >= *(void *)(a2 + *v4))
            {
              uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__formatsExt1;
              goto LABEL_69;
            }
            char v44 = *(unsigned char *)(*(void *)(a2 + *v7) + v43);
            *(void *)(a2 + v42) = v43 + 1;
            v19 |= (unint64_t)(v44 & 0x7F) << v40;
            if (v44 < 0)
            {
              v40 += 7;
              BOOL v23 = v41++ > 8;
              if (v23)
              {
                LODWORD(v19) = 0;
                uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__formatsExt1;
                goto LABEL_72;
              }
              continue;
            }
            break;
          }
          uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__formatsExt1;
          goto LABEL_70;
        case 6u:
          char v45 = 0;
          unsigned int v46 = 0;
          uint64_t v19 = 0;
          *(unsigned char *)(a1 + 32) |= 4u;
          break;
        default:
          if (PBReaderSkipValueWithTag()) {
            continue;
          }
          return 0;
      }
      while (1)
      {
        uint64_t v47 = *v3;
        unint64_t v48 = *(void *)(a2 + v47);
        if (v48 == -1 || v48 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v49 = *(unsigned char *)(*(void *)(a2 + *v7) + v48);
        *(void *)(a2 + v47) = v48 + 1;
        v19 |= (unint64_t)(v49 & 0x7F) << v45;
        if ((v49 & 0x80) == 0)
        {
          uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__preferredFormatExt1;
          goto LABEL_70;
        }
        v45 += 7;
        BOOL v23 = v46++ > 8;
        if (v23)
        {
          LODWORD(v19) = 0;
          uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__preferredFormatExt1;
          goto LABEL_72;
        }
      }
      uint64_t v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__preferredFormatExt1;
LABEL_69:
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_70:
      if (*(unsigned char *)(a2 + *v5)) {
        LODWORD(v19) = 0;
      }
LABEL_72:
      *(_DWORD *)(a1 + *v24) = v19;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void *iPhoneWiFiScreenEncodingRules(uint64_t a1, uint64_t a2, double a3, double a4)
{
  if (a1 == 1)
  {
    unsigned int v5 = 1;
    int v6 = &g_AirplayWifiEncodingFormat1136x640VXE;
  }
  else if (a3 == 1136.0 && a4 == 640.0)
  {
    unsigned int v5 = 1;
    int v6 = &g_AirplayWifiEncodingFormat1136x640AVE;
  }
  else if (a3 == 1334.0 && a4 == 750.0)
  {
    unsigned int v5 = 2;
    int v6 = &g_AirplayWifiEncodingFormat1334x750AVE;
  }
  else
  {
    int v6 = &g_AirplayWifiEncodingFormat1920x1080AVE;
    if (a3 == 1920.0 && a4 == 1080.0)
    {
      unsigned int v5 = 3;
    }
    else if (a3 == 2436.0 && a4 == 1125.0)
    {
      unsigned int v5 = 4;
      int v6 = &g_AirplayWifiEncodingFormat2436x1125AVE;
    }
    else if (a3 == 2688.0 && a4 == 1242.0)
    {
      unsigned int v5 = 4;
      int v6 = &g_AirplayWifiEncodingFormat2436x1125AVE;
    }
    else if (a3 == 1792.0 && a4 == 828.0)
    {
      int v6 = &g_AirplayWifiEncodingFormat2436x1125AVE;
      unsigned int v5 = 4;
    }
    else
    {
      unsigned int v5 = 3;
    }
  }
  return videoRulesForFormatList_1((uint64_t)v6, v5, a2);
}

void *iPhoneWiFiScreenDecodingRules(uint64_t a1, double a2, double a3)
{
  if (a2 == 1136.0 && a3 == 640.0)
  {
    unsigned int v5 = 4;
    int v6 = &g_AirplayWifiDecodingFormat1136x640;
  }
  else if (a2 == 1334.0 && a3 == 750.0)
  {
    unsigned int v5 = 6;
    int v6 = &g_AirplayWifiDecodingFormat1334x750;
  }
  else
  {
    int v6 = &g_AirplayWifiDecodingFormat1920x1080;
    if (a2 == 1920.0 && a3 == 1080.0)
    {
      unsigned int v5 = 8;
    }
    else if (a2 == 2436.0 && a3 == 1125.0)
    {
      unsigned int v5 = 10;
      int v6 = &g_AirplayWifiDecodingFormat2436x1125;
    }
    else
    {
      unsigned int v5 = 10;
      if (a2 == 2688.0 && a3 == 1242.0)
      {
        int v6 = &g_AirplayWifiDecodingFormat2436x1125;
      }
      else if (a2 == 1792.0 && a3 == 828.0)
      {
        int v6 = &g_AirplayWifiDecodingFormat2436x1125;
        unsigned int v5 = 10;
      }
      else
      {
        unsigned int v5 = 8;
      }
    }
  }
  return videoRulesForFormatList_1((uint64_t)v6, v5, a1);
}

void *videoRulesForFormatList_1(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  int v6 = objc_opt_new();
  if (v6)
  {
    uint64_t v7 = a2;
    char v8 = (unsigned int *)(a1 + 8);
    unsigned int v9 = (os_log_t *)MEMORY[0x1E4F47A50];
    do
    {
      unint64_t v10 = [VCVideoRule alloc];
      *(float *)&double v11 = (float)*v8;
      uint64_t v12 = [(VCVideoRule *)v10 initWithFrameWidth:*(v8 - 2) frameHeight:*(v8 - 1) frameRate:a3 payload:v11];
      if (v12)
      {
        char v13 = (void *)v12;
        [v6 addObject:v12];
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v14 = VRTraceErrorLogLevelToCSTR();
        int v15 = *v9;
        if (os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 136315650;
          uint64_t v18 = v14;
          __int16 v19 = 2080;
          uint64_t v20 = "videoRulesForFormatList";
          __int16 v21 = 1024;
          int v22 = 90;
          _os_log_error_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to create video rule for Airplay screen !", buf, 0x1Cu);
        }
      }
      v8 += 3;
      --v7;
    }
    while (v7);
  }
  return v6;
}

uint64_t VCCoreAudio_AudioUnitMock_SetProperty(OpaqueAudioComponentInstance *a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6)
{
  UInt32 v6 = a6;
  AudioUnitElement v8 = a4;
  AudioUnitScope v9 = a3;
  AudioUnitPropertyID v10 = a2;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v13 = 0;
  if ([+[VCCoreAudio_AudioUnitMock sharedInstance] setProperty:a1 inID:a2 inScope:a3 inElement:a4 inData:a5 inDataSize:a6 outStatus:&v13])
  {
    return v13;
  }
  else
  {
    return AudioUnitSetProperty(a1, v10, v9, v8, a5, v6);
  }
}

uint64_t VCCoreAudio_AudioUnitMock_GetProperty(OpaqueAudioComponentInstance *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, UInt32 *a6)
{
  AudioUnitElement v8 = a4;
  AudioUnitScope v9 = a3;
  AudioUnitPropertyID v10 = a2;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v13 = 0;
  if ([+[VCCoreAudio_AudioUnitMock sharedInstance] getProperty:a1 inID:a2 inScope:a3 inElement:a4 outData:a5 ioDataSize:a6 outStatus:&v13])
  {
    return v13;
  }
  else
  {
    return AudioUnitGetProperty(a1, v10, v9, v8, a5, a6);
  }
}

uint64_t VCCoreAudio_AudioUnitMock_Render(OpaqueAudioComponentInstance *a1, AudioUnitRenderActionFlags *a2, const AudioTimeStamp *a3, uint64_t a4, uint64_t a5, AudioBufferList *a6)
{
  UInt32 v7 = a5;
  UInt32 v8 = a4;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v13 = 0;
  if ([+[VCCoreAudio_AudioUnitMock sharedInstance] render:a1 ioActionFlags:a2 inTimeStamp:a3 inOutputBusNumber:a4 inNumberFrames:a5 ioData:a6 outStatus:&v13])
  {
    return v13;
  }
  else
  {
    return AudioUnitRender(a1, a2, a3, v8, v7, a6);
  }
}

uint64_t VCCoreAudio_AudioUnitMock_ComplexRender(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  unsigned int v11 = 0;
  if ([+[VCCoreAudio_AudioUnitMock sharedInstance] complexRender:a1 ioActionFlags:a2 inTimeStamp:a3 inOutputBusNumber:a4 inNumberOfPackets:a5 outNumberOfPackets:a6 outPacketDescriptions:a7 ioData:a8 outMetadata:a9 outMetadataByteSize:a10 outStatus:&v11])
  {
    return v11;
  }
  else
  {
    return AudioUnitComplexRender();
  }
}

uint64_t VCCoreAudio_AudioUnitMock_Initialize(OpaqueAudioComponentInstance *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  unsigned int v3 = 0;
  if ([+[VCCoreAudio_AudioUnitMock sharedInstance] initialize:a1 outStatus:&v3])
  {
    return v3;
  }
  else
  {
    return AudioUnitInitialize(a1);
  }
}

uint64_t VCCoreAudio_AudioUnitMock_Uninitialize(OpaqueAudioComponentInstance *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  unsigned int v3 = 0;
  if ([+[VCCoreAudio_AudioUnitMock sharedInstance] uninitialize:a1 outStatus:&v3])
  {
    return v3;
  }
  else
  {
    return AudioUnitUninitialize(a1);
  }
}

uint64_t VCCoreAudio_AudioUnitMock_OutputUnitStart(OpaqueAudioComponentInstance *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  unsigned int v3 = 0;
  if ([+[VCCoreAudio_AudioUnitMock sharedInstance] outputUnitStart:a1 outStatus:&v3])
  {
    return v3;
  }
  else
  {
    return AudioOutputUnitStart(a1);
  }
}

uint64_t VCCoreAudio_AudioUnitMock_OutputUnitStop(OpaqueAudioComponentInstance *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  unsigned int v3 = 0;
  if ([+[VCCoreAudio_AudioUnitMock sharedInstance] outputUnitStop:a1 outStatus:&v3])
  {
    return v3;
  }
  else
  {
    return AudioOutputUnitStop(a1);
  }
}

uint64_t VCCoreAudio_AudioUnitMock_SetParameter(OpaqueAudioComponentInstance *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, AudioUnitParameterValue a6)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  unsigned int v15 = 0;
  uint64_t v12 = +[VCCoreAudio_AudioUnitMock sharedInstance];
  *(AudioUnitParameterValue *)&double v13 = a6;
  if ([(VCCoreAudio_AudioUnitMock *)v12 audioUnit:a1 setParameter:a2 scope:a3 element:a4 value:a5 bufferOffsetInFrames:&v15 outStatus:v13])
  {
    return v15;
  }
  else
  {
    return AudioUnitSetParameter(a1, a2, a3, a4, a6, a5);
  }
}

void VCAudioUnitMockMicThreadProc(unsigned char *a1, uint64_t a2, unsigned char *a3)
{
  if (a1[192])
  {
    a1[192] = 0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        VCAudioUnitMockMicThreadProc_cold_1();
      }
    }
    *a3 = 1;
  }
  else
  {
    [a1 runAudioCallback];
    usleep(0x4E20u);
  }
}

uint64_t AUIOCreateHandle(uint64_t *a1, uint64_t a2)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = 2149253121;
  int v52 = (uint64_t (*)(unsigned int *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *))0xAAAAAAAAAAAAAAAALL;
  unint64_t v53 = 0xAAAAAAAAAAAAAAAALL;
  memset(v51, 170, 20);
  int v3 = *(unsigned __int8 *)(a2 + 138);
  BOOL v4 = v3 == 1;
  if (a1)
  {
    BOOL v6 = *(void *)(a2 + 56) || v3 == 1;
    if (v6 && *(void *)(a2 + 128))
    {
      UInt32 v8 = malloc_type_calloc(1uLL, 0x290uLL, 0x10B0040920F3ACEuLL);
      if (v8)
      {
        uint64_t v9 = (uint64_t)v8;
        v8[76] = *(void *)(a2 + 144);
        if (+[VCHardwareSettings deviceClass] != 4
          || +[VCHardwareSettings builtinMicCount])
        {
          BOOL v4 = *(void *)(a2 + 120) != 0;
        }
        *(unsigned char *)(v9 + 235) = v4;
        if (VCDefaults_GetBoolValueForKey(@"forceEnableAudioMockInputPathForAppleTV", 0))
        {
          *(unsigned char *)(v9 + 235) = *(void *)(a2 + 120) != 0;
          [+[VCAudioToolboxAudioComponentMock sharedInstance] start];
          [+[VCCoreAudio_AudioUnitMock sharedInstance] start];
        }
        *(_OWORD *)uint64_t v9 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(v9 + 16) = *(_OWORD *)(a2 + 112);
        *(void *)(v9 + 32) = *(void *)(a2 + 128);
        *(unsigned char *)(v9 + 464) = *(unsigned char *)(a2 + 136);
        *(_WORD *)(v9 + 576) = *(_WORD *)(a2 + 137);
        *(unsigned char *)(v9 + 578) = objc_msgSend(+[VCTestMonitorManager sharedManager](VCTestMonitorManager, "sharedManager"), "toneInjectionEnabled");
        id v10 = +[VCDefaults copyStringValueForKey:@"audioCannedReplay"];
        *(void *)(v9 + 584) = v10;
        if (!v10) {
          *(void *)(v9 + 584) = +[VCDefaults copyStringValueForKey:@"cannedReplay"];
        }
        int v54 = -1431655766;
        +[VCDefaults getDoubleValueForKey:@"audioCannedReplayLoopLength" defaultValue:0.0];
        *(void *)(v9 + 592) = v11;
        +[VCDefaults getDoubleValueForKey:@"audioCannedReplayStartTime" defaultValue:-1.0];
        *(void *)(v9 + 600) = v12;
        *(void *)(v9 + 632) = *(void *)(a2 + 168);
        *(_OWORD *)(v9 + 616) = *(_OWORD *)(a2 + 152);
        mach_timebase_info info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
        mach_timebase_info(&info);
        LODWORD(v14) = info.denom;
        LODWORD(v13) = info.numer;
        *(double *)(v9 + 440) = (double)v13 * 0.000000001 / (double)v14;
        LODWORD(v51[0]) = 1635086197;
        if ((*(unsigned char *)(a2 + 138) - 1) > 3u) {
          int v15 = 0;
        }
        else {
          int v15 = dword_1E25A2430[(char)(*(unsigned char *)(a2 + 138) - 1)];
        }
        HIDWORD(v51[0]) = v15;
        v51[1] = 1634758764;
        LODWORD(v51[2]) = 0;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v16 = VRTraceErrorLogLevelToCSTR();
          char v17 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)CMSampleTimingInfo buf = 136316162;
            *(void *)&uint8_t buf[4] = v16;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "AUIOCreateHandle";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 989;
            *(_WORD *)&buf[28] = 2048;
            *(void *)&buf[30] = v9;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&unsigned char buf[40] = HIDWORD(v51[0]);
            _os_log_impl(&dword_1E1EA4000, v17, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p finding next audio component with subtype=%u", buf, 0x2Cu);
          }
        }
        uint64_t Next = VCAudioToolbox_AudioComponentFindNext();
        *(void *)(v9 + 40) = Next;
        int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (!Next)
        {
          uint64_t v27 = 2149253142;
          if (ErrorLogLevelForModule >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
            {
              AUIOCreateHandle_cold_1();
              uint64_t v27 = 2149253142;
            }
          }
          goto LABEL_42;
        }
        if (ErrorLogLevelForModule >= 7)
        {
          uint64_t v20 = VRTraceErrorLogLevelToCSTR();
          __int16 v21 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v22 = *(void *)(v9 + 40);
            *(_DWORD *)CMSampleTimingInfo buf = 136315906;
            *(void *)&uint8_t buf[4] = v20;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "AUIOCreateHandle";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 991;
            *(_WORD *)&buf[28] = 2048;
            *(void *)&buf[30] = v22;
            _os_log_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d Found component=%p", buf, 0x26u);
          }
        }
        long long v76 = 0u;
        long long v77 = 0u;
        long long v74 = 0u;
        long long v75 = 0u;
        long long v72 = 0u;
        long long v73 = 0u;
        long long v70 = 0u;
        long long v71 = 0u;
        long long v68 = 0u;
        long long v69 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        long long v65 = 0u;
        memset(buf, 0, sizeof(buf));
        int v23 = VCAudioToolbox_AudioComponentCopyName();
        if (v23)
        {
          int v24 = v23;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            uint64_t v25 = VRTraceErrorLogLevelToCSTR();
            unsigned int v26 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)uint64_t v55 = 136316162;
              uint64_t v56 = v25;
              __int16 v57 = 2080;
              uint64_t v58 = "AUIOCreateHandle";
              __int16 v59 = 1024;
              int v60 = 998;
              __int16 v61 = 1024;
              *(_DWORD *)int v62 = 998;
              *(_WORD *)&uint8_t v62[4] = 1024;
              *(_DWORD *)&v62[6] = v24;
              _os_log_impl(&dword_1E1EA4000, v26, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/AUIO/AUIO.mm:%d: AudioComponentCopyName() returned error %d", v55, 0x28u);
            }
          }
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          uint64_t v28 = VRTraceErrorLogLevelToCSTR();
          char v29 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint64_t v55 = 136315906;
            uint64_t v56 = v28;
            __int16 v57 = 2080;
            uint64_t v58 = "AUIOCreateHandle";
            __int16 v59 = 1024;
            int v60 = 1001;
            __int16 v61 = 1024;
            *(_DWORD *)int v62 = 1001;
            _os_log_impl(&dword_1E1EA4000, v29, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/AUIO/AUIO.mm:%d: AudioComponentCopyName() gave a NULL name!", v55, 0x22u);
          }
        }
        int v30 = VCAudioToolbox_AudioComponentInstanceNew();
        if (v30)
        {
          uint64_t v27 = v30 | 0xA01B0000;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              AUIOCreateHandle_cold_5();
            }
          }
          goto LABEL_42;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v32 = VRTraceErrorLogLevelToCSTR();
          unint64_t v33 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v34 = *(void *)(v9 + 48);
            *(_DWORD *)uint64_t v55 = 136316162;
            uint64_t v56 = v32;
            __int16 v57 = 2080;
            uint64_t v58 = "AUIOCreateHandle";
            __int16 v59 = 1024;
            int v60 = 1016;
            __int16 v61 = 2048;
            *(void *)int v62 = v9;
            *(_WORD *)&v62[8] = 2048;
            uint64_t v63 = v34;
            _os_log_impl(&dword_1E1EA4000, v33, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p AudioComponentInstanceNew succeeded, unit=%p", v55, 0x30u);
          }
        }
        if (*(unsigned char *)(v9 + 235))
        {
          int v54 = 1;
          int v35 = VCAudioUnit_AudioUnitSetProperty();
          if (v35)
          {
            uint64_t v27 = v35 | 0xA01B0000;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                AUIOCreateHandle_cold_4();
              }
            }
            goto LABEL_42;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            uint64_t v36 = VRTraceErrorLogLevelToCSTR();
            uint64_t v37 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)CMSampleTimingInfo buf = 136315906;
              *(void *)&uint8_t buf[4] = v36;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = "AUIOCreateHandle";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&unsigned char buf[24] = 1034;
              *(_WORD *)&buf[28] = 2048;
              *(void *)&buf[30] = v9;
              _os_log_impl(&dword_1E1EA4000, v37, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAudioOutputUnitProperty_EnableIO kAudioUnitScope_Input succeeded", buf, 0x26u);
            }
          }
        }
        if (*(unsigned char *)(v9 + 577) != 1)
        {
          int v54 = 1;
          int v41 = VCAudioUnit_AudioUnitSetProperty();
          if (v41)
          {
            uint64_t v27 = v41 | 0xA01B0000;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                AUIOCreateHandle_cold_3();
              }
            }
            goto LABEL_42;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            uint64_t v42 = VRTraceErrorLogLevelToCSTR();
            unint64_t v43 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)CMSampleTimingInfo buf = 136315906;
              *(void *)&uint8_t buf[4] = v42;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = "AUIOCreateHandle";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&unsigned char buf[24] = 1047;
              *(_WORD *)&buf[28] = 2048;
              *(void *)&buf[30] = v9;
              _os_log_impl(&dword_1E1EA4000, v43, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAudioOutputUnitProperty_EnableIO kAudioUnitScope_Output succeeded", buf, 0x26u);
            }
          }
        }
        _AUIOLoadDynamicDuckerVolumeOverride(v9);
        _AUIOLoadDynamicDuckerHALLevelOverride(v9);
        uint64_t Handle = CreateHandle();
        if (Handle == 0xFFFFFFFFLL)
        {
          uint64_t v27 = 2149253125;
LABEL_42:
          if (*(void *)(v9 + 48)) {
            VCAudioToolbox_AudioComponentInstanceDispose();
          }
          free((void *)v9);
          return v27;
        }
        uint64_t v39 = Handle;
        if (*(unsigned char *)(v9 + 235))
        {
          int v52 = _AUIOMicProc;
          unint64_t v53 = v9;
          int v40 = VCAudioUnit_AudioUnitSetProperty();
          if (v40)
          {
            uint64_t v27 = v40 | 0xA01B0000;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                AUIOCreateHandle_cold_2();
              }
            }
            goto LABEL_85;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            uint64_t v44 = VRTraceErrorLogLevelToCSTR();
            char v45 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)CMSampleTimingInfo buf = 136315906;
              *(void *)&uint8_t buf[4] = v44;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = "AUIOCreateHandle";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&unsigned char buf[24] = 1072;
              *(_WORD *)&buf[28] = 2048;
              *(void *)&buf[30] = v9;
              _os_log_impl(&dword_1E1EA4000, v45, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAudioOutputUnitProperty_SetInputCallback kAudioUnitScope_Global succeeded", buf, 0x26u);
            }
          }
        }
        if (*(unsigned char *)(v9 + 577) == 1)
        {
          uint64_t v46 = AUIOSetupSystemAudioTap(v9, *(unsigned int *)(a2 + 92), *(double *)(a2 + 64));
          if ((v46 & 0x80000000) != 0)
          {
            uint64_t v27 = v46;
LABEL_85:
            CheckOutHandleDebug();
            goto LABEL_42;
          }
        }
        else
        {
          uint64_t v47 = AUIOSetupRendererCallback(v9, &v52);
          if ((v47 & 0x80000000) != 0)
          {
            uint64_t v27 = v47;
            goto LABEL_85;
          }
        }
        pthread_mutex_init((pthread_mutex_t *)(v9 + 264), 0);
        *(_DWORD *)(v9 + 392) = 0;
        *(void *)(v9 + 328) = 0;
        *(_WORD *)(v9 + 232) = 0;
        *(_DWORD *)(v9 + 352) = 0;
        *(unsigned char *)(v9 + 528) = 0;
        *(void *)(v9 + 456) = 0x7FEFFFFFFFFFFFFFLL;
        *a1 = v39;
        uint64_t v27 = 0;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v48 = VRTraceErrorLogLevelToCSTR();
          char v49 = *MEMORY[0x1E4F47A50];
          uint64_t v27 = 0;
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)CMSampleTimingInfo buf = 136315650;
            *(void *)&uint8_t buf[4] = v48;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "AUIOCreateHandle";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 1113;
            _os_log_impl(&dword_1E1EA4000, v49, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d Successfully created the AUIO", buf, 0x1Cu);
            return 0;
          }
        }
        return v27;
      }
      return 2149253123;
    }
  }
  return v2;
}

void _AUIOLoadDynamicDuckerVolumeOverride(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a1 + 648) = 2143289344;
  float DoubleValueForKey = VCDefaults_GetDoubleValueForKey(@"forcedDynamicDuckerVolume", NAN);
  if (DoubleValueForKey >= 0.0 && DoubleValueForKey <= 1.0)
  {
    *(float *)(a1 + 648) = DoubleValueForKey;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v6 = VRTraceErrorLogLevelToCSTR();
      UInt32 v7 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v8 = 136316162;
        uint64_t v9 = v6;
        __int16 v10 = 2080;
        uint64_t v11 = "_AUIOLoadDynamicDuckerVolumeOverride";
        __int16 v12 = 1024;
        int v13 = 2320;
        __int16 v14 = 2048;
        uint64_t v15 = a1;
        __int16 v16 = 2048;
        double v17 = DoubleValueForKey;
        _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p Found dynamic ducker volume override. Volume=%f", (uint8_t *)&v8, 0x30u);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v4 = VRTraceErrorLogLevelToCSTR();
    unsigned int v5 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
    {
      int v8 = 136316162;
      uint64_t v9 = v4;
      __int16 v10 = 2080;
      uint64_t v11 = "_AUIOLoadDynamicDuckerVolumeOverride";
      __int16 v12 = 1024;
      int v13 = 2316;
      __int16 v14 = 2048;
      uint64_t v15 = a1;
      __int16 v16 = 2048;
      double v17 = DoubleValueForKey;
      _os_log_error_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d AUIO=%p Invalid dynamic ducker volume provided. Volume=%f", (uint8_t *)&v8, 0x30u);
    }
  }
}

void _AUIOLoadDynamicDuckerHALLevelOverride(uint64_t a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 577) == 4)
  {
    int IntValueForKey = VCDefaults_GetIntValueForKey(@"forcedDynamicDuckerHALLevel", 0);
    if (IntValueForKey)
    {
      int v2 = VCAudioUnit_AudioUnitSetProperty();
      int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (v2)
      {
        if (ErrorLogLevelForModule >= 5)
        {
          uint64_t v4 = VRTraceErrorLogLevelToCSTR();
          unsigned int v5 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)CMSampleTimingInfo buf = 136316418;
            uint64_t v13 = v4;
            __int16 v14 = 2080;
            uint64_t v15 = "_AUIOLoadDynamicDuckerHALLevelOverride";
            __int16 v16 = 1024;
            int v17 = 2339;
            __int16 v18 = 2048;
            uint64_t v19 = a1;
            __int16 v20 = 2080;
            __int16 v21 = FourccToCStr(v2);
            __int16 v22 = 1024;
            int v23 = v2;
            uint64_t v6 = "AUIO [%s] %s:%d AUIO=%p Failed to set dynamic ducker level. err='%s' (%d)";
            UInt32 v7 = v5;
            uint32_t v8 = 54;
LABEL_10:
            _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, v6, buf, v8);
          }
        }
      }
      else if (ErrorLogLevelForModule >= 7)
      {
        uint64_t v9 = VRTraceErrorLogLevelToCSTR();
        __int16 v10 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 136316162;
          uint64_t v13 = v9;
          __int16 v14 = 2080;
          uint64_t v15 = "_AUIOLoadDynamicDuckerHALLevelOverride";
          __int16 v16 = 1024;
          int v17 = 2337;
          __int16 v18 = 2048;
          uint64_t v19 = a1;
          __int16 v20 = 1024;
          LODWORD(v21) = IntValueForKey;
          uint64_t v6 = "AUIO [%s] %s:%d AUIO=%p Successfully set dynamic ducker level=%d";
          UInt32 v7 = v10;
          uint32_t v8 = 44;
          goto LABEL_10;
        }
      }
    }
  }
}

uint64_t _AUIOMicProc(unsigned int *a1, unsigned int *a2, const AudioTimeStamp *a3, unsigned int a4, unsigned int a5, AudioBufferList *a6)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _AUIOMicProc();
      }
    }
    return 0;
  }
  double v9 = *((double *)a1 + 55) * (double)a3->mHostTime;
  kdebug_trace();
  ++*((void *)a1 + 62);
  VCAudioBufferList_Reset(*((void *)a1 + 30));
  uint64_t AudioBufferList = VCAudioBufferList_GetAudioBufferList(*((void *)a1 + 30));
  uint64_t v59 = (uint64_t)&v59;
  size_t v11 = a1[112];
  MEMORY[0x1F4188790](AudioBufferList);
  __int16 v12 = (_DWORD *)((char *)&v59 - ((v11 + 15) & 0x1FFFFFFF0));
  if (v11) {
    memset((char *)&v59 - ((v11 + 15) & 0x1FFFFFFF0), 170, v11);
  }
  unsigned int v61 = v11;
  if (VCAudioBufferList_GetSampleCapacity(*((void *)a1 + 30)) < a5
    && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    uint64_t v13 = VRTraceErrorLogLevelToCSTR();
    __int16 v14 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
    {
      int SampleCapacity = VCAudioBufferList_GetSampleCapacity(*((void *)a1 + 30));
      *(_DWORD *)CMSampleTimingInfo buf = 136316162;
      uint64_t v63 = v13;
      __int16 v64 = 2080;
      long long v65 = "_AUIOMicProc";
      __int16 v66 = 1024;
      int v67 = 463;
      __int16 v68 = 1024;
      *(_DWORD *)long long v69 = a5;
      *(_WORD *)&v69[4] = 1024;
      *(_DWORD *)&v69[6] = SampleCapacity;
      _os_log_error_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d Frame size changed with inNumberFrames=%d being greater than sample buffer size=%d", buf, 0x28u);
    }
  }
  if (VCAudioBufferList_GetSampleCapacity(*((void *)a1 + 30)) <= a5) {
    a5 = VCAudioBufferList_GetSampleCapacity(*((void *)a1 + 30));
  }
  unsigned int v60 = a5;
  VCAudioBufferList_SetSampleCount(*((void *)a1 + 30), a5);
  if (*((unsigned char *)a1 + 576)) {
    goto LABEL_11;
  }
  int v16 = *((unsigned __int8 *)a1 + 577);
  if (v16 == 2) {
    goto LABEL_100;
  }
  if (v16 == 1) {
    goto LABEL_11;
  }
  if (!*((unsigned char *)a1 + 577))
  {
LABEL_100:
    if (*((unsigned char *)a1 + 235)) {
      goto LABEL_20;
    }
LABEL_11:
    uint64_t v15 = VCAudioUnit_AudioUnitRender();
    unsigned int v61 = 0;
    goto LABEL_21;
  }
LABEL_20:
  uint64_t v15 = VCAudioUnit_AudioUnitComplexRender();
LABEL_21:
  kdebug_trace();
  if (v15)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _AUIOMicProc();
      }
    }
    ++*((void *)a1 + 63);
    (*((void (**)(void, uint64_t))a1 + 4))(*((void *)a1 + 2), 2149253127);
  }
  else
  {
    unsigned int v17 = v61;
    if (v61 > a1[112])
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        uint64_t v18 = VRTraceErrorLogLevelToCSTR();
        uint64_t v19 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          unsigned int v54 = a1[112];
          *(_DWORD *)CMSampleTimingInfo buf = 136316162;
          uint64_t v63 = v18;
          __int16 v64 = 2080;
          long long v65 = "_AUIOMicProc";
          __int16 v66 = 1024;
          int v67 = 492;
          __int16 v68 = 1024;
          *(_DWORD *)long long v69 = v54;
          *(_WORD *)&v69[4] = 1024;
          *(_DWORD *)&v69[6] = v61;
          _os_log_error_impl(&dword_1E1EA4000, v19, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d STACK OVERFLOW: Please file a radar. MetaData buffer is too small (%d). Required:%d", buf, 0x28u);
        }
      }
      unsigned int v17 = v61;
    }
    uint64_t v20 = *((void *)a1 + 30);
    if (v17)
    {
      if (v17 >= 8)
      {
        BOOL v21 = 0;
        uint64_t v24 = (float *)(v12 + 2);
        float v22 = 0.0;
        unint64_t v25 = (unint64_t)v12 + v17;
        while (1)
        {
          uint64_t v26 = v12[1];
          uint64_t v27 = (_DWORD *)((char *)v24 + v26);
          if ((unint64_t)v24 + v26 > v25) {
            break;
          }
          if (*v12 == 1886348386)
          {
            if (v26 == 4) {
              float v22 = *v24;
            }
          }
          else if (*v12 == 1935762482 && v26 == 4)
          {
            BOOL v21 = *(_DWORD *)v24 == 0;
          }
          uint64_t v24 = (float *)(v27 + 2);
          __int16 v12 = v27;
          if ((unint64_t)(v27 + 2) > v25) {
            goto LABEL_51;
          }
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            _AUIOMicProc();
          }
        }
      }
      else
      {
        BOOL v21 = 0;
        float v22 = 0.0;
      }
LABEL_51:
      a1[98] = v21;
      *((float *)a1 + 87) = v22;
      *((void *)a1 + 64) += v21;
      VCAudioBufferList_SetAveragePower(v20, v22);
      float AveragePower = *((float *)a1 + 87);
    }
    else
    {
      float AveragePower = VCAudioBufferList_GetAveragePower(*((void *)a1 + 30));
      *((float *)a1 + 87) = AveragePower;
    }
    float v29 = *((float *)a1 + 88) * 0.9 + AveragePower * 0.1;
    *((float *)a1 + 88) = v29;
    if (a1[83]) {
      a1[87] = -1024458752;
    }
    if (*((void *)a1 + 64))
    {
      int v30 = a1[98];
    }
    else
    {
      int v30 = 1;
      a1[98] = 1;
    }
    VCAudioBufferList_SetVoiceActivity(v20, v30);
    double v31 = 0.0;
    IsInternalOSInstalled = (const char *)VRTraceIsInternalOSInstalled();
    if (IsInternalOSInstalled) {
      double v31 = micro();
    }
    if (*((unsigned char *)a1 + 234))
    {
      if (LogProfileTimeOverLimitCompare(*((double *)a1 + 65), v31, v33, IsInternalOSInstalled, *(void *)&v31, *((void *)a1 + 65), v31 - *((double *)a1 + 65)))
      {
        if (a1[98])
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            uint64_t v34 = VRTraceErrorLogLevelToCSTR();
            int v35 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)CMSampleTimingInfo buf = 136315906;
              uint64_t v63 = v34;
              __int16 v64 = 2080;
              long long v65 = "_AUIOMicProcDetectDelayedSamples";
              __int16 v66 = 1024;
              int v67 = 432;
              __int16 v68 = 2048;
              *(void *)long long v69 = a1;
              _os_log_impl(&dword_1E1EA4000, v35, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p received first non-silence audio frame", buf, 0x26u);
            }
          }
        }
        else
        {
          *((unsigned char *)a1 + 528) = 0;
        }
      }
      else if (!*((unsigned char *)a1 + 528) && a1[98])
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v36 = VRTraceErrorLogLevelToCSTR();
          uint64_t v37 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)CMSampleTimingInfo buf = 136315906;
            uint64_t v63 = v36;
            __int16 v64 = 2080;
            long long v65 = "_AUIOMicProcDetectDelayedSamples";
            __int16 v66 = 1024;
            int v67 = 435;
            __int16 v68 = 2048;
            *(void *)long long v69 = a1;
            _os_log_impl(&dword_1E1EA4000, v37, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p received first non-silence audio frame", buf, 0x26u);
          }
        }
        *((unsigned char *)a1 + 528) = 1;
      }
      *((double *)a1 + 65) = v31;
      uint64_t mSampleTime = (uint64_t)a3->mSampleTime;
      VCAudioBufferList_SetTime(*((void *)a1 + 30), mSampleTime, v9);
      if ((a3->mSampleTime == 0.0 || a1[104] == mSampleTime || a1[103] > mSampleTime)
        && (int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v39 = VRTraceErrorLogLevelToCSTR();
        int v40 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v41 = mSampleTime - a1[103];
          Float64 v42 = a3->mSampleTime;
          uint64_t v43 = (uint64_t)a3->mSampleTime;
          mdouble HostTime = a3->mHostTime;
          *(_DWORD *)CMSampleTimingInfo buf = 136317186;
          uint64_t v63 = v39;
          __int16 v64 = 2080;
          long long v65 = "_AUIOLogAbnormalTimestamps";
          __int16 v66 = 1024;
          int v67 = 254;
          __int16 v68 = 1024;
          *(_DWORD *)long long v69 = v41;
          *(_WORD *)&v69[4] = 2048;
          *(Float64 *)&v69[6] = v42;
          __int16 v70 = 2048;
          *(void *)long long v71 = v43;
          *(_WORD *)&v71[8] = 1024;
          *(_DWORD *)long long v72 = mSampleTime;
          *(_WORD *)&v72[4] = 2048;
          *(void *)&v72[6] = mHostTime;
          *(_WORD *)&v72[14] = 2048;
          *(double *)&v72[16] = v9;
          _os_log_impl(&dword_1E1EA4000, v40, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d inSampleTime - pAUIO->numBufferedMicSamples = %d, inTimeStamp = %f, converted %lld, inSampleTime %u, HostTime %lld %f", buf, 0x50u);
        }
      }
      unsigned int v45 = a1[104];
      if (v45)
      {
        int v46 = a1[108];
        if (v46)
        {
          if (vabdd_f64(a3->mSampleTime, (double)v45) > 2 * a5)
          {
            a1[108] = (int)((double)v46 - (a3->mSampleTime - (double)v45));
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              uint64_t v47 = VRTraceErrorLogLevelToCSTR();
              uint64_t v48 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
              {
                unsigned int v55 = a1[108];
                unsigned int v56 = a1[104];
                int v57 = (int)a3->mSampleTime;
                uint64_t v58 = *((void *)a1 + 53);
                *(_DWORD *)CMSampleTimingInfo buf = 136317186;
                uint64_t v63 = v47;
                __int16 v64 = 2080;
                long long v65 = "_AUIOMicProc";
                __int16 v66 = 1024;
                int v67 = 524;
                __int16 v68 = 2048;
                *(void *)long long v69 = a1;
                *(_WORD *)&v69[8] = 1024;
                *(_DWORD *)&v69[10] = v55;
                __int16 v70 = 1024;
                *(_DWORD *)long long v71 = v56;
                *(_WORD *)&v71[4] = 1024;
                *(_DWORD *)&v71[6] = v57;
                *(_WORD *)long long v72 = 2048;
                *(void *)&_OWORD v72[2] = v58;
                *(_WORD *)&v72[10] = 2048;
                *(double *)&v72[12] = v9;
                _os_log_error_impl(&dword_1E1EA4000, v48, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d AUIO=%p Modifying timestamp delta to timeStampDelta=%d because mic also jumped latestMicTimeStamp=%d to latestMicTimeStamp=%d, hostTime jumped latestMicHostTime=%f to inHostTime=%f", buf, 0x4Cu);
              }
            }
          }
        }
      }
      a1[104] = mSampleTime;
      *((double *)a1 + 53) = v9;
      if (a1[134] + a1[133] != a1[135]
        && vabdd_f64(a3->mSampleTime, (double)mSampleTime) > (double)(int)(4 * a5))
      {
        ++a1[136];
      }
      kdebug_trace();
      char v49 = (const void *)*((void *)a1 + 30);
      if (*((unsigned char *)a1 + 464))
      {
        if (!PacketThread_SendSampleBuffer(*((void *)a1 + 59), v49)) {
          (*((void (**)(void, uint64_t))a1 + 4))(*((void *)a1 + 2), 2149253137);
        }
      }
      else
      {
        _AUIOSendMicSamples((uint64_t)a1, (uint64_t)v49);
      }
      ++*((void *)a1 + 63);
      int v50 = LogProfileTimeOverLimit(v31, 0.00600000005, "IOProc: shenanigans mic proc");
      unsigned int v51 = a1[133];
      if (v50) {
        a1[133] = ++v51;
      }
      uint64_t v15 = 0;
      a1[135] = a1[134] + v51;
    }
    else
    {
      ++*((void *)a1 + 63);
      if (LogProfileTimeOverLimit(v31, 0.00600000005, "IOProc: shenanigans mic proc")) {
        ++a1[133];
      }
      (*((void (**)(void, uint64_t))a1 + 4))(*((void *)a1 + 2), 2149253137);
      return 0;
    }
  }
  return v15;
}

uint64_t AUIOSetupSystemAudioTap(uint64_t a1, uint64_t a2, double a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)[objc_alloc(MEMORY[0x1E4F153A0]) initWithCommonFormat:1 sampleRate:a2 channels:0 interleaved:a3];
  unsigned int v5 = (void *)[objc_alloc(MEMORY[0x1E4F189F8]) initSystemTapWithFormat:v4];
  if (!v5)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
      goto LABEL_20;
    }
    uint64_t v13 = VRTraceErrorLogLevelToCSTR();
    __int16 v14 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_20;
    }
    int v16 = 136315906;
    uint64_t v17 = v13;
    __int16 v18 = 2080;
    uint64_t v19 = "AUIOSetupSystemAudioTap";
    __int16 v20 = 1024;
    int v21 = 876;
    __int16 v22 = 2048;
    uint64_t v23 = a1;
    goto LABEL_19;
  }
  uint64_t v6 = [objc_alloc(MEMORY[0x1E4F189F0]) initWithTapDescription:v5];
  if (!v6)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
      goto LABEL_20;
    }
    uint64_t v15 = VRTraceErrorLogLevelToCSTR();
    __int16 v14 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_20;
    }
    int v16 = 136315906;
    uint64_t v17 = v15;
    __int16 v18 = 2080;
    uint64_t v19 = "AUIOSetupSystemAudioTap";
    __int16 v20 = 1024;
    int v21 = 878;
    __int16 v22 = 2048;
    uint64_t v23 = a1;
LABEL_19:
    _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p failed to allocate the audio tap", (uint8_t *)&v16, 0x26u);
LABEL_20:

    uint64_t v9 = 2149253123;
    goto LABEL_12;
  }
  UInt32 v7 = (void *)v6;
  int v8 = VCAudioUnit_AudioUnitSetProperty();
  if (v8)
  {
    uint64_t v9 = v8 | 0xA01B0000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        AUIOSetupSystemAudioTap();
      }
    }
    goto LABEL_11;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 7) {
    goto LABEL_10;
  }
  uint64_t v10 = VRTraceErrorLogLevelToCSTR();
  size_t v11 = *MEMORY[0x1E4F47A50];
  uint64_t v9 = 0;
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
  {
    int v16 = 136315906;
    uint64_t v17 = v10;
    __int16 v18 = 2080;
    uint64_t v19 = "AUIOSetupSystemAudioTap";
    __int16 v20 = 1024;
    int v21 = 886;
    __int16 v22 = 2048;
    uint64_t v23 = a1;
    _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAudioOutputUnitProperty_AudioTapObject kAudioUnitScope_Global succeeded", (uint8_t *)&v16, 0x26u);
LABEL_10:
    uint64_t v9 = 0;
  }
LABEL_11:

LABEL_12:
  return v9;
}

uint64_t AUIOSetupRendererCallback(uint64_t a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  int v3 = _AUIOSpkrProc;
  if (!*(unsigned char *)(a1 + 464)) {
    int v3 = _AUIOSpkrProcGKS;
  }
  *a2 = v3;
  a2[1] = a1;
  int v4 = VCAudioUnit_AudioUnitSetProperty();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v6 = VRTraceErrorLogLevelToCSTR();
      UInt32 v7 = *MEMORY[0x1E4F47A50];
      uint64_t v5 = 0;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        return v5;
      }
      int v9 = 136315906;
      uint64_t v10 = v6;
      __int16 v11 = 2080;
      __int16 v12 = "AUIOSetupRendererCallback";
      __int16 v13 = 1024;
      int v14 = 914;
      __int16 v15 = 2048;
      uint64_t v16 = a1;
      _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAudioUnitProperty_SetRenderCallback kAudioUnitScope_Global succeeded", (uint8_t *)&v9, 0x26u);
    }
    return 0;
  }
  uint64_t v5 = v4 | 0xA01B0000;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
      AUIOSetupRendererCallback();
    }
  }
  return v5;
}

uint64_t AUIOCloseHandle()
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = CheckInHandleDebug();
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  int v2 = (os_log_t *)MEMORY[0x1E4F47A50];
  if (ErrorLogLevelForModule >= 7)
  {
    uint64_t v3 = VRTraceErrorLogLevelToCSTR();
    int v4 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = 136315906;
      uint64_t v19 = v3;
      __int16 v20 = 2080;
      int v21 = "AUIOCloseHandle";
      __int16 v22 = 1024;
      int v23 = 1131;
      __int16 v24 = 2048;
      uint64_t v25 = v0;
      _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d Destroying AUIO=%p", (uint8_t *)&v18, 0x26u);
    }
  }
  if (!v0) {
    return 2149253122;
  }
  CheckOutHandleDebug();
  VCAudioToolbox_AudioComponentInstanceDispose();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v5 = VRTraceErrorLogLevelToCSTR();
    uint64_t v6 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(v0 + 48);
      int v18 = 136316162;
      uint64_t v19 = v5;
      __int16 v20 = 2080;
      int v21 = "AUIOCloseHandle";
      __int16 v22 = 1024;
      int v23 = 1161;
      __int16 v24 = 2048;
      uint64_t v25 = v0;
      __int16 v26 = 2048;
      uint64_t v27 = v7;
      _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d Disposed AUIO=%p unit=%p", (uint8_t *)&v18, 0x30u);
    }
  }
  pthread_mutex_destroy((pthread_mutex_t *)(v0 + 264));
  int v8 = *(void **)(v0 + 400);
  if (v8) {
    free(v8);
  }
  VCAudioBufferList_Destroy((uint64_t *)(v0 + 248));
  VCAudioBufferList_Destroy((uint64_t *)(v0 + 240));
  uint64_t v9 = *(void *)(v0 + 336);
  if (v9) {
    MEMORY[0x1E4E57980](v9, 0x1000C407AA769CALL);
  }
  uint64_t v10 = *(void *)(v0 + 360);
  if (v10) {
    MEMORY[0x1E4E57980](v10, 0x1000C407AA769CALL);
  }
  __int16 v11 = *(int **)(v0 + 472);
  if (v11) {
    PacketThread_Destroy(v11);
  }
  __int16 v12 = *(NSObject **)(v0 + 568);
  if (v12)
  {
    dispatch_source_cancel(v12);
    __int16 v13 = *(NSObject **)(v0 + 568);
    if (v13)
    {
      dispatch_release(v13);
      *(void *)(v0 + 568) = 0;
    }
  }

  *(void *)(v0 + 480) = 0;
  if (VCDefaults_GetBoolValueForKey(@"forceEnableAudioMockInputPathForAppleTV", 0))
  {
    [+[VCAudioToolboxAudioComponentMock sharedInstance] stop];
    [+[VCCoreAudio_AudioUnitMock sharedInstance] stop];
  }

  free((void *)v0);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    uint64_t v14 = VRTraceErrorLogLevelToCSTR();
    __int16 v15 = *v2;
    BOOL v16 = os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v16) {
      return result;
    }
    int v18 = 136315650;
    uint64_t v19 = v14;
    __int16 v20 = 2080;
    int v21 = "AUIOCloseHandle";
    __int16 v22 = 1024;
    int v23 = 1200;
    _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO Closed Handle.", (uint8_t *)&v18, 0x1Cu);
  }
  return 0;
}

uint64_t AUIOSuspend(uint64_t a1, int a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = 2149253142;
  uint64_t v4 = CheckInHandleDebug();
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = (pthread_mutex_t *)(v4 + 264);
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 264));
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v7 = VRTraceErrorLogLevelToCSTR();
      int v8 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v21 = 136315906;
        uint64_t v22 = v7;
        __int16 v23 = 2080;
        __int16 v24 = "AUIOSuspend";
        __int16 v25 = 1024;
        int v26 = 1675;
        __int16 v27 = 2048;
        uint64_t v28 = v5;
        _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p Stopping the audio unit.", (uint8_t *)&v21, 0x26u);
      }
    }
    if (!*(void *)(v5 + 48))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          AUIOSuspend_cold_1();
        }
      }
      goto LABEL_34;
    }
    if (*(unsigned char *)(v5 + 233))
    {
      int v9 = VCAudioUnit_AudioOutputUnitStop();
      if (v9)
      {
        int v10 = v9;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            AUIOSuspend_cold_3();
          }
        }
        uint64_t v3 = v10 | 0xA01B0000;
        goto LABEL_34;
      }
      uint64_t v14 = *(int **)(v5 + 472);
      if (v14)
      {
        PacketThread_Destroy(v14);
        *(void *)(v5 + 472) = 0;
      }
      *(unsigned char *)(v5 + 233) = 0;
      if (!a2)
      {
LABEL_30:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v17 = VRTraceErrorLogLevelToCSTR();
          int v18 = *MEMORY[0x1E4F47A50];
          uint64_t v3 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
LABEL_34:
            pthread_mutex_unlock(v6);
            CheckOutHandleDebug();
            return v3;
          }
          uint64_t v19 = *(void *)(v5 + 48);
          int v21 = 136316162;
          uint64_t v22 = v17;
          __int16 v23 = 2080;
          __int16 v24 = "AUIOSuspend";
          __int16 v25 = 1024;
          int v26 = 1704;
          __int16 v27 = 2048;
          uint64_t v28 = v5;
          __int16 v29 = 2048;
          uint64_t v30 = v19;
          _os_log_impl(&dword_1E1EA4000, v18, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p unit=%p uninitialized", (uint8_t *)&v21, 0x30u);
        }
        uint64_t v3 = 0;
        goto LABEL_34;
      }
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v11 = VRTraceErrorLogLevelToCSTR();
        __int16 v12 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v13 = *(void *)(v5 + 48);
          int v21 = 136316162;
          uint64_t v22 = v11;
          __int16 v23 = 2080;
          __int16 v24 = "AUIOSuspend";
          __int16 v25 = 1024;
          int v26 = 1692;
          __int16 v27 = 2048;
          uint64_t v28 = v5;
          __int16 v29 = 2048;
          uint64_t v30 = v13;
          _os_log_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p unit=%p stopped", (uint8_t *)&v21, 0x30u);
        }
      }
      if (!a2) {
        goto LABEL_30;
      }
    }
    if (*(unsigned char *)(v5 + 232))
    {
      int v15 = VCAudioUnit_AudioUnitUninitialize();
      if (v15)
      {
        int v16 = v15;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            AUIOSuspend_cold_2();
          }
        }
        uint64_t v3 = v16 | 0xA01B0000;
      }
      else
      {
        uint64_t v3 = 0;
        *(unsigned char *)(v5 + 232) = 0;
      }
      goto LABEL_34;
    }
    goto LABEL_30;
  }
  return 2149253122;
}

uint64_t AUIOResume()
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = 2149253122;
  uint64_t v1 = CheckInHandleDebug();
  if (v1)
  {
    uint64_t v2 = v1;
    uint64_t v3 = (pthread_mutex_t *)(v1 + 264);
    pthread_mutex_lock((pthread_mutex_t *)(v1 + 264));
    if (*(unsigned char *)(v2 + 232))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v4 = VRTraceErrorLogLevelToCSTR();
        uint64_t v5 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v6 = *(unsigned __int8 *)(v2 + 233);
          int v14 = 136316162;
          uint64_t v15 = v4;
          __int16 v16 = 2080;
          uint64_t v17 = "AUIOResume";
          __int16 v18 = 1024;
          int v19 = 1725;
          __int16 v20 = 2048;
          uint64_t v21 = v2;
          __int16 v22 = 1024;
          int v23 = v6;
          _os_log_impl(&dword_1E1EA4000, v5, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p AUIO resume pAUIO->audioUnitIsStarted=%d", (uint8_t *)&v14, 0x2Cu);
        }
      }
      if (*(unsigned char *)(v2 + 233))
      {
        uint64_t v0 = 0;
      }
      else
      {
        uint64_t v8 = _AUIOStartPacketThread(v2);
        if ((v8 & 0x80000000) != 0)
        {
          uint64_t v0 = v8;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
              AUIOResume_cold_1();
            }
          }
        }
        else
        {
          *(void *)(v2 + 456) = 0x7FEFFFFFFFFFFFFFLL;
          int v9 = VCAudioUnit_AudioOutputUnitStart();
          int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
          if (v9)
          {
            if (ErrorLogLevelForModule >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                AUIOResume_cold_2();
              }
            }
            uint64_t v0 = v9 | 0xA01B0000;
            uint64_t v11 = *(int **)(v2 + 472);
            if (v11)
            {
              PacketThread_Destroy(v11);
              *(void *)(v2 + 472) = 0;
            }
          }
          else
          {
            if (ErrorLogLevelForModule >= 7)
            {
              uint64_t v12 = VRTraceErrorLogLevelToCSTR();
              uint64_t v13 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                int v14 = 136315906;
                uint64_t v15 = v12;
                __int16 v16 = 2080;
                uint64_t v17 = "AUIOResume";
                __int16 v18 = 1024;
                int v19 = 1739;
                __int16 v20 = 1024;
                LODWORD(v21) = 1739;
                _os_log_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/AUIO/AUIO.mm:%d: AudioOutputUnitStart completed", (uint8_t *)&v14, 0x22u);
              }
            }
            uint64_t v0 = 0;
            *(unsigned char *)(v2 + 233) = 1;
          }
        }
      }
    }
    else
    {
      uint64_t v0 = 2149253176;
    }
    pthread_mutex_unlock(v3);
    CheckOutHandleDebug();
  }
  return v0;
}

uint64_t _AUIOStartPacketThread(uint64_t a1)
{
  v6[5] = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 464)) {
    return 0;
  }
  if (*(void *)(a1 + 472))
  {
    uint64_t v2 = 2149253121;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        _AUIOStartPacketThread();
      }
    }
  }
  else
  {
    int SerializedSize = VCAudioBufferList_GetSerializedSize(*(unsigned int **)(a1 + 240));
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    long long v6[2] = ___ZL22_AUIOStartPacketThreadP7tagAUIO_block_invoke;
    v6[3] = &__block_descriptor_40_e15_v28__0_v8_16I24l;
    v6[4] = a1;
    uint64_t v4 = PacketThread_Create(SerializedSize, 0, 0x10u, 19, (uint64_t)"com.apple.AVConference.auio", v6);
    uint64_t v2 = 0;
    *(void *)(a1 + 472) = v4;
    if (!v4)
    {
      uint64_t v2 = 2149253121;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          _AUIOStartPacketThread();
        }
      }
    }
  }
  return v2;
}

uint64_t AUIOSetupFormats(double a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, int a6, int a7, int a8, unsigned int a9)
{
  uint64_t v172 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = 2149253123;
  uint64_t v18 = CheckInHandleDebug();
  if (v18)
  {
    uint64_t v19 = v18;
    unsigned int v153 = a9;
    int v154 = a6;
    __int16 v20 = (pthread_mutex_t *)(v18 + 264);
    pthread_mutex_lock((pthread_mutex_t *)(v18 + 264));
    int v158 = a8;
    int v159 = a7;
    Boolean keyExistsAndHasValidFormat = 0;
    int v155 = [*(id *)(v19 + 608) audioSessionId];
    long long v22 = *(_OWORD *)(a3 + 16);
    long long v21 = *(_OWORD *)(a3 + 32);
    *(_OWORD *)(v19 + 136) = *(_OWORD *)a3;
    *(_OWORD *)(v19 + 152) = v22;
    *(_OWORD *)(v19 + 168) = v21;
    if (a4)
    {
      long long v23 = *a4;
      long long v24 = a4[1];
      *(_OWORD *)(v19 + 216) = a4[2];
      *(_OWORD *)(v19 + 200) = v24;
      *(_OWORD *)(v19 + 184) = v23;
    }
    int v157 = -1431655766;
    if (*(unsigned char *)(v19 + 235))
    {
      uint64_t v152 = a5;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v25 = VRTraceErrorLogLevelToCSTR();
        int v26 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 136316162;
          *(void *)&uint8_t buf[4] = v25;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "AUIOSetupMic";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 1227;
          *(_WORD *)&buf[28] = 2048;
          *(void *)&buf[30] = v19;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&unsigned char buf[40] = 0;
          _os_log_impl(&dword_1E1EA4000, v26, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p Setting up mic reinitialize=%d", buf, 0x2Cu);
        }
      }
      uint64_t v27 = *(void *)(v19 + 240);
      long long v28 = *(_OWORD *)(v19 + 152);
      *(_OWORD *)(v19 + 96) = *(_OWORD *)(v19 + 136);
      *(_OWORD *)(v19 + 112) = v28;
      *(void *)(v19 + 128) = *(void *)(v19 + 168);
      if (v27) {
        VCAudioBufferList_Destroy((uint64_t *)(v19 + 240));
      }
      long long v29 = *(_OWORD *)(v19 + 112);
      *(_OWORD *)__int16 v160 = *(_OWORD *)(v19 + 96);
      long long v161 = v29;
      uint64_t v162 = *(void *)(v19 + 128);
      if ((VCAudioBufferList_Allocate((long long *)v160, 5 * *(_DWORD *)(v19 + 176), (void *)(v19 + 240)) & 1) == 0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            AUIOSetupFormats_cold_11();
          }
        }
        goto LABEL_189;
      }
      uint64_t v151 = a3;
      int v30 = *(_DWORD *)(v19 + 256);
      int v31 = *(_DWORD *)(v19 + 408);
      uint64_t v32 = *(void **)(v19 + 400);
      int v33 = 5 * *(_DWORD *)(v19 + 176);
      *(_DWORD *)(v19 + 256) = v33;
      size_t v34 = (*(_DWORD *)(v19 + 120) * v33);
      *(_DWORD *)(v19 + 408) = v34;
      *(void *)(v19 + 400) = malloc_type_realloc(v32, v34, 0x8F1BCF97uLL);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v35 = VRTraceErrorLogLevelToCSTR();
        uint64_t v36 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          int v37 = *(_DWORD *)(v19 + 256);
          int v38 = *(_DWORD *)(v19 + 408);
          uint64_t v39 = *(void *)(v19 + 400);
          int v40 = *(_DWORD *)(v19 + 412);
          *(_DWORD *)CMSampleTimingInfo buf = 136317698;
          *(void *)&uint8_t buf[4] = v35;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "_AUIOReallocBufferedMicSamples";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 1214;
          *(_WORD *)&buf[28] = 2048;
          *(void *)&buf[30] = v19;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&unsigned char buf[40] = v30;
          *(_WORD *)&unsigned char buf[44] = 1024;
          *(_DWORD *)&buf[46] = v37;
          *(_WORD *)&buf[50] = 1024;
          *(_DWORD *)&buf[52] = v31;
          __int16 v164 = 1024;
          int v165 = v38;
          __int16 v166 = 2048;
          double v167 = v32;
          __int16 v168 = 2048;
          uint64_t v169 = v39;
          __int16 v170 = 1024;
          int v171 = v40;
          _os_log_impl(&dword_1E1EA4000, v36, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p Reallocated the buffered mic sample buffer. prevMaxSampleSize=%d maxSampleSize=%d prevMaxByteSize=%u maxByteSize=%u prevBufferedMicSamples=0x%lx bufferedMicSamples=%p sampleCount=%d", buf, 0x58u);
        }
      }
      if (!*(void *)(v19 + 400))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            AUIOSetupFormats_cold_10();
          }
        }
        goto LABEL_189;
      }
      FileUtil_PrintBasicDesc((uint64_t)"MicOutFmt:", (uint64_t *)(v19 + 96));
      int v41 = VCAudioUnit_AudioUnitSetProperty();
      int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (v41)
      {
        if (ErrorLogLevelForModule >= 3)
        {
          uint64_t v43 = VRTraceErrorLogLevelToCSTR();
          uint64_t v44 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)CMSampleTimingInfo buf = 136316162;
            *(void *)&uint8_t buf[4] = v43;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "AUIOSetupMic";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 1272;
            *(_WORD *)&buf[28] = 2048;
            *(void *)&buf[30] = v19;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&unsigned char buf[40] = v41;
            _os_log_error_impl(&dword_1E1EA4000, v44, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d AUIO=%p AudioUnitSetProperty(MicOut) StreamFormat failed(%d)", buf, 0x2Cu);
          }
        }
        uint64_t v17 = v41 | 0xA01B0000;
        goto LABEL_189;
      }
      if (ErrorLogLevelForModule >= 7)
      {
        uint64_t v45 = VRTraceErrorLogLevelToCSTR();
        int v46 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 136315906;
          *(void *)&uint8_t buf[4] = v45;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "AUIOSetupMic";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 1275;
          *(_WORD *)&buf[28] = 2048;
          *(void *)&buf[30] = v19;
          _os_log_impl(&dword_1E1EA4000, v46, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAudioUnitProperty_StreamFormat kAudioUnitScope_Output set succeeded", buf, 0x26u);
        }
      }
      a5 = v152;
    }
    if (*(unsigned char *)(v19 + 577) != 1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v53 = VRTraceErrorLogLevelToCSTR();
        unsigned int v54 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 136316162;
          *(void *)&uint8_t buf[4] = v53;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "AUIOSetupSpeaker";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 1291;
          *(_WORD *)&buf[28] = 2048;
          *(void *)&buf[30] = v19;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&unsigned char buf[40] = 0;
          _os_log_impl(&dword_1E1EA4000, v54, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p Setting up speaker reinitialize=%d", buf, 0x2Cu);
        }
      }
      uint64_t v55 = *(void *)(v19 + 248);
      long long v56 = *(_OWORD *)(v19 + 200);
      *(_OWORD *)(v19 + 56) = *(_OWORD *)(v19 + 184);
      *(_OWORD *)(v19 + 72) = v56;
      *(void *)(v19 + 88) = *(void *)(v19 + 216);
      if (v55) {
        VCAudioBufferList_Destroy((uint64_t *)(v19 + 248));
      }
      long long v57 = *(_OWORD *)(v19 + 72);
      *(_OWORD *)__int16 v160 = *(_OWORD *)(v19 + 56);
      long long v161 = v57;
      uint64_t v162 = *(void *)(v19 + 88);
      if ((VCAudioBufferList_Allocate((long long *)v160, *(_DWORD *)(v19 + 224), (void *)(v19 + 248)) & 1) == 0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            AUIOSetupFormats_cold_9();
          }
        }
        goto LABEL_189;
      }
      FileUtil_PrintBasicDesc((uint64_t)"SpkrIn:", (uint64_t *)(v19 + 56));
      int v58 = VCAudioUnit_AudioUnitSetProperty();
      int v59 = VRTraceGetErrorLogLevelForModule();
      if (v58)
      {
        if (v59 >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            AUIOSetupFormats_cold_8();
          }
        }
        goto LABEL_140;
      }
      if (v59 >= 7)
      {
        uint64_t v60 = VRTraceErrorLogLevelToCSTR();
        unsigned int v61 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 136315906;
          *(void *)&uint8_t buf[4] = v60;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "AUIOSetupSpeaker";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 1339;
          *(_WORD *)&buf[28] = 2048;
          *(void *)&buf[30] = v19;
          _os_log_impl(&dword_1E1EA4000, v61, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAudioUnitProperty_StreamFormat kAudioUnitScope_Input set succeeded", buf, 0x26u);
        }
      }
    }
    if (!*(unsigned char *)(v19 + 576) && *(unsigned char *)(v19 + 577) != 1)
    {
      int v157 = VCAudioUnit_AudioUnitSetProperty();
      int v47 = VRTraceGetErrorLogLevelForModule();
      if (v157)
      {
        if (v47 >= 5)
        {
          uint64_t v48 = VRTraceErrorLogLevelToCSTR();
          char v49 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)CMSampleTimingInfo buf = 136316674;
            *(void *)&uint8_t buf[4] = v48;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 1496;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v155;
            *(_WORD *)&buf[34] = 1024;
            *(_DWORD *)&buf[36] = v157;
            *(_WORD *)&unsigned char buf[40] = 1040;
            *(_DWORD *)&buf[42] = 4;
            *(_WORD *)&buf[46] = 2080;
            *(void *)&uint8_t buf[48] = &v157;
            int v50 = "AUIO [%s] %s:%d AudioUnitSetProperty failed to set property kAudioOutputUnitProperty_AudioSessionID %d %d %.4s";
            unsigned int v51 = v49;
            uint32_t v52 = 56;
LABEL_57:
            _os_log_impl(&dword_1E1EA4000, v51, OS_LOG_TYPE_DEFAULT, v50, buf, v52);
          }
        }
      }
      else if (v47 >= 7)
      {
        uint64_t v62 = VRTraceErrorLogLevelToCSTR();
        uint64_t v63 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v64 = *(void *)(v19 + 48);
          *(_DWORD *)CMSampleTimingInfo buf = 136316162;
          *(void *)&uint8_t buf[4] = v62;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 1498;
          *(_WORD *)&buf[28] = 2048;
          *(void *)&buf[30] = v64;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&unsigned char buf[40] = v155;
          int v50 = "AUIO [%s] %s:%d Setting id of audio unit %p to %d";
          unsigned int v51 = v63;
          uint32_t v52 = 44;
          goto LABEL_57;
        }
      }
    }
    if (!*(unsigned char *)(v19 + 235)) {
      goto LABEL_79;
    }
    if (*(unsigned char *)(v19 + 576))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        uint64_t v66 = VRTraceErrorLogLevelToCSTR();
        int v67 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 136315906;
          *(void *)&uint8_t buf[4] = v66;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 1551;
          *(_WORD *)&buf[28] = 2048;
          *(void *)&buf[30] = v19;
          _os_log_impl(&dword_1E1EA4000, v67, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p setting up AudioInput and using BasebandIO", buf, 0x26u);
        }
      }
      LODWORD(v65) = *(_DWORD *)(a3 + 40);
      float v68 = (double)v65 / *(double *)a3;
      *(float *)__int16 v160 = v68;
      int v69 = VCAudioUnit_AudioUnitSetProperty();
      int v157 = v69;
      int v70 = VRTraceGetErrorLogLevelForModule();
      if (v69)
      {
        if (v70 >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            AUIOSetupFormats_cold_7();
          }
        }
LABEL_102:
        uint64_t v17 = v157 | 0xA01B0000;
LABEL_189:
        pthread_mutex_unlock(v20);
        CheckOutHandleDebug();
        return v17;
      }
      if (v70 >= 7)
      {
        uint64_t v75 = VRTraceErrorLogLevelToCSTR();
        long long v76 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 136315906;
          *(void *)&uint8_t buf[4] = v75;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 1558;
          *(_WORD *)&buf[28] = 2048;
          *(void *)&buf[30] = v19;
          long long v77 = "AUIO [%s] %s:%d AUIO=%p kAudioOutputUnitProperty_IOBufferDuration kAudioUnitScope_Global succeeded";
LABEL_78:
          _os_log_impl(&dword_1E1EA4000, v76, OS_LOG_TYPE_DEFAULT, v77, buf, 0x26u);
          goto LABEL_79;
        }
      }
      goto LABEL_79;
    }
    if (*(unsigned char *)(v19 + 577) == 1) {
      goto LABEL_79;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      uint64_t v71 = VRTraceErrorLogLevelToCSTR();
      long long v72 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 136315906;
        *(void *)&uint8_t buf[4] = v71;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = 1504;
        *(_WORD *)&buf[28] = 2048;
        *(void *)&buf[30] = v19;
        _os_log_impl(&dword_1E1EA4000, v72, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p setting up AudioInput but not using BasebandIO", buf, 0x26u);
      }
    }
    *(_DWORD *)__int16 v160 = 1;
    int v73 = VCAudioUnit_AudioUnitSetProperty();
    int v157 = v73;
    int v74 = VRTraceGetErrorLogLevelForModule();
    if (v73)
    {
      if (v74 >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
          AUIOSetupFormats_cold_6();
        }
      }
      goto LABEL_139;
    }
    if (v74 >= 7)
    {
      uint64_t v117 = VRTraceErrorLogLevelToCSTR();
      uint64_t v118 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 136315906;
        *(void *)&uint8_t buf[4] = v117;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = 1513;
        *(_WORD *)&buf[28] = 2048;
        *(void *)&buf[30] = v19;
        _os_log_impl(&dword_1E1EA4000, v118, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAUVoiceIOProperty_RequestMetadata kAudioUnitScope_Global succeeded", buf, 0x26u);
      }
    }
    int v119 = VCAudioUnit_AudioUnitSetProperty();
    int v157 = v119;
    int v120 = VRTraceGetErrorLogLevelForModule();
    if (v119)
    {
      if (v120 < 3) {
        goto LABEL_139;
      }
      uint64_t v121 = VRTraceErrorLogLevelToCSTR();
      __int16 v122 = *MEMORY[0x1E4F47A50];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        goto LABEL_139;
      }
      *(_DWORD *)CMSampleTimingInfo buf = 136316674;
      *(void *)&uint8_t buf[4] = v121;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&unsigned char buf[24] = 1519;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v159;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = v157;
      *(_WORD *)&unsigned char buf[40] = 1040;
      *(_DWORD *)&buf[42] = 4;
      *(_WORD *)&buf[46] = 2080;
      *(void *)&uint8_t buf[48] = &v157;
      long long v149 = "AUIO [%s] %s:%d AudioUnitSetProperty failed to set property kAUVoiceIOProperty_OperationMode %d %d %.4s";
    }
    else
    {
      if (v120 >= 7)
      {
        uint64_t v123 = VRTraceErrorLogLevelToCSTR();
        uint64_t v124 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 136315906;
          *(void *)&uint8_t buf[4] = v123;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = 1522;
          *(_WORD *)&buf[28] = 2048;
          *(void *)&buf[30] = v19;
          _os_log_impl(&dword_1E1EA4000, v124, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAUVoiceIOProperty_OperationMode kAudioUnitScope_Global succeeded", buf, 0x26u);
        }
      }
      int v125 = VCAudioUnit_AudioUnitSetProperty();
      int v157 = v125;
      if (v125 == -10876 || !v125 || v125 == 561406316)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v126 = VRTraceErrorLogLevelToCSTR();
          double v127 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)CMSampleTimingInfo buf = 136315906;
            *(void *)&uint8_t buf[4] = v126;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = 1530;
            *(_WORD *)&buf[28] = 2048;
            *(void *)&buf[30] = v19;
            _os_log_impl(&dword_1E1EA4000, v127, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAUVoiceIOProperty_EnableSpatialChat kAudioUnitScope_Global succeeded", buf, 0x26u);
          }
        }
        AppBooleanCFBooleanRef Value = CFPreferencesGetAppBooleanValue(@"forceMute", @"com.apple.VideoConference", &keyExistsAndHasValidFormat);
        if (!keyExistsAndHasValidFormat || !AppBooleanValue) {
          goto LABEL_79;
        }
        *(void *)(v19 + 328) = 0x100000001;
        int v58 = VCAudioUnit_AudioUnitSetProperty();
        int v129 = VRTraceGetErrorLogLevelForModule();
        if (!v58)
        {
          if (v129 >= 7)
          {
            uint64_t v150 = VRTraceErrorLogLevelToCSTR();
            long long v76 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)CMSampleTimingInfo buf = 136315906;
              *(void *)&uint8_t buf[4] = v150;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&unsigned char buf[24] = 1544;
              *(_WORD *)&buf[28] = 2048;
              *(void *)&buf[30] = v19;
              long long v77 = "AUIO [%s] %s:%d AUIO=%p kAUVoiceIOProperty_MuteOutput kAudioUnitScope_Global succeeded";
              goto LABEL_78;
            }
          }
LABEL_79:
          BOOL v78 = [+[VCDefaults sharedInstance] audioRecordingEnabled];
          if (v154 && v78)
          {
            if (!*(unsigned char *)(v19 + 235))
            {
LABEL_92:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                uint64_t v88 = VRTraceErrorLogLevelToCSTR();
                uint64_t v89 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)CMSampleTimingInfo buf = 136315906;
                  *(void *)&uint8_t buf[4] = v88;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&unsigned char buf[24] = 1618;
                  *(_WORD *)&buf[28] = 2048;
                  *(void *)&buf[30] = v19;
                  _os_log_impl(&dword_1E1EA4000, v89, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p Trying to setup AUIO", buf, 0x26u);
                }
              }
              int v90 = VCAudioUnit_AudioUnitInitialize();
              int v157 = v90;
              int v91 = VRTraceGetErrorLogLevelForModule();
              if (v90)
              {
                if (v91 >= 5)
                {
                  uint64_t v92 = VRTraceErrorLogLevelToCSTR();
                  int v93 = *MEMORY[0x1E4F47A50];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                  {
                    int v94 = v157;
                    uint64_t v95 = FourccToCStr(v157);
                    *(_DWORD *)CMSampleTimingInfo buf = 136316418;
                    *(void *)&uint8_t buf[4] = v92;
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&unsigned char buf[24] = 1621;
                    *(_WORD *)&buf[28] = 1024;
                    *(_DWORD *)&buf[30] = v94;
                    *(_WORD *)&buf[34] = 2080;
                    *(void *)&buf[36] = v95;
                    *(_WORD *)&unsigned char buf[44] = 1024;
                    *(_DWORD *)&buf[46] = 0;
                    _os_log_impl(&dword_1E1EA4000, v93, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AudioUnitInitialize failed. err=%d (%s) attempt %d", buf, 0x32u);
                  }
                }
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  uint64_t v96 = VRTraceErrorLogLevelToCSTR();
                  uint64_t v97 = *MEMORY[0x1E4F47A50];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                    AUIOSetupFormats_cold_4(v96, &v157, v97);
                  }
                }
                goto LABEL_102;
              }
              if (v91 >= 7)
              {
                uint64_t v98 = VRTraceErrorLogLevelToCSTR();
                uint64_t v99 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)CMSampleTimingInfo buf = 136315650;
                  *(void *)&uint8_t buf[4] = v98;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&unsigned char buf[24] = 1629;
                  _os_log_impl(&dword_1E1EA4000, v99, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AudioUnitInitialize succeeded", buf, 0x1Cu);
                }
              }
              *(unsigned char *)(v19 + 232) = 1;
              if (!a5 || *(unsigned char *)(v19 + 576)) {
                goto LABEL_108;
              }
              int v102 = *(unsigned __int8 *)(v19 + 577);
              if (v102 == 2) {
                goto LABEL_119;
              }
              if (v102 == 1) {
                goto LABEL_108;
              }
              if (!*(unsigned char *)(v19 + 577))
              {
LABEL_119:
                if (!*(unsigned char *)(v19 + 235)) {
                  goto LABEL_163;
                }
              }
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                uint64_t v103 = VRTraceErrorLogLevelToCSTR();
                uint64_t v104 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)CMSampleTimingInfo buf = 136316162;
                  *(void *)&uint8_t buf[4] = v103;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&unsigned char buf[24] = 1637;
                  *(_WORD *)&buf[28] = 2048;
                  *(void *)&buf[30] = v19;
                  *(_WORD *)&buf[38] = 2080;
                  *(void *)&unsigned char buf[40] = a5 + 64;
                  _os_log_impl(&dword_1E1EA4000, v104, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p VoiceIO Remote OS Versiouint64_t n = %s", buf, 0x30u);
                }
              }
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                uint64_t v105 = VRTraceErrorLogLevelToCSTR();
                uint64_t v106 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)CMSampleTimingInfo buf = 136316162;
                  *(void *)&uint8_t buf[4] = v105;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&unsigned char buf[24] = 1638;
                  *(_WORD *)&buf[28] = 2048;
                  *(void *)&buf[30] = v19;
                  *(_WORD *)&buf[38] = 2080;
                  *(void *)&unsigned char buf[40] = a5;
                  _os_log_impl(&dword_1E1EA4000, v106, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p VoiceIO Remote HW Model = %s", buf, 0x30u);
                }
              }
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                uint64_t v107 = VRTraceErrorLogLevelToCSTR();
                long long v108 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                {
                  int v109 = *(_DWORD *)(a5 + 128);
                  *(_DWORD *)CMSampleTimingInfo buf = 136316162;
                  *(void *)&uint8_t buf[4] = v107;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&unsigned char buf[24] = 1639;
                  *(_WORD *)&buf[28] = 2048;
                  *(void *)&buf[30] = v19;
                  *(_WORD *)&buf[38] = 1024;
                  *(_DWORD *)&unsigned char buf[40] = v109;
                  _os_log_impl(&dword_1E1EA4000, v108, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p VoiceIO Remote AU Versiouint64_t n = %u", buf, 0x2Cu);
                }
              }
              int v110 = VCAudioUnit_AudioUnitSetProperty();
              int v157 = v110;
              int v111 = VRTraceGetErrorLogLevelForModule();
              if (v110)
              {
                if (v111 >= 5)
                {
                  uint64_t v112 = VRTraceErrorLogLevelToCSTR();
                  float v113 = *MEMORY[0x1E4F47A50];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)CMSampleTimingInfo buf = 136316162;
                    *(void *)&uint8_t buf[4] = v112;
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&unsigned char buf[24] = 1647;
                    *(_WORD *)&buf[28] = 1024;
                    *(_DWORD *)&buf[30] = v157;
                    *(_WORD *)&buf[34] = 1024;
                    *(_DWORD *)&buf[36] = v157;
                    uint64_t v114 = "AUIO [%s] %s:%d AudioUnitSetProperty failed to set property FarEndVersionInfo with error %08x %d";
                    uint64_t v115 = v113;
                    uint32_t v116 = 40;
LABEL_159:
                    _os_log_impl(&dword_1E1EA4000, v115, OS_LOG_TYPE_DEFAULT, v114, buf, v116);
                  }
                }
              }
              else if (v111 >= 7)
              {
                uint64_t v130 = VRTraceErrorLogLevelToCSTR();
                long long v131 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)CMSampleTimingInfo buf = 136315906;
                  *(void *)&uint8_t buf[4] = v130;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&unsigned char buf[24] = 1649;
                  *(_WORD *)&buf[28] = 2048;
                  *(void *)&buf[30] = v19;
                  uint64_t v114 = "AUIO [%s] %s:%d AUIO=%p kAUVoiceIOProperty_FarEndVersionInfo kAudioUnitScope_Global succeeded";
                  uint64_t v115 = v131;
                  uint32_t v116 = 38;
                  goto LABEL_159;
                }
              }
LABEL_108:
              if (*(unsigned char *)(v19 + 235) && !*(unsigned char *)(v19 + 576) && *(unsigned char *)(v19 + 577) != 1)
              {
                *(_DWORD *)__int16 v160 = 4;
                int Property = VCAudioUnit_AudioUnitGetProperty();
                int v101 = VRTraceGetErrorLogLevelForModule();
                if (Property)
                {
                  if (v101 >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                      AUIOSetupFormats_cold_3();
                    }
                  }
                  *(_DWORD *)(v19 + 448) = 128;
                }
                else if (v101 >= 7)
                {
                  uint64_t v132 = VRTraceErrorLogLevelToCSTR();
                  long long v133 = *MEMORY[0x1E4F47A50];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)CMSampleTimingInfo buf = 136315906;
                    *(void *)&uint8_t buf[4] = v132;
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = "_AUIOPostinitialization";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&unsigned char buf[24] = 1828;
                    *(_WORD *)&buf[28] = 2048;
                    *(void *)&buf[30] = v19;
                    _os_log_impl(&dword_1E1EA4000, v133, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAUVoiceIOProperty_MaximumMetadataByteSize kAudioUnitScope_Output get succeeded", buf, 0x26u);
                  }
                }
              }
LABEL_163:

              *(void *)(v19 + 480) = 0;
              unsigned int v134 = *(void **)(v19 + 584);
              if (v134 && [v134 length])
              {
                BOOL v135 = 1;
              }
              else
              {
                if (!*(unsigned char *)(v19 + 578)) {
                  goto LABEL_203;
                }
                BOOL v135 = 0;
              }
              *(unsigned char *)(v19 + 488) = VCDefaults_GetBoolValueForKey(@"forceCannedAudioVoiceActive", v135);
              long long v136 = objc_alloc_init(VCCannedAudioInjectorConfig);
              if (v136)
              {
                long long v137 = v136;
                long long v138 = *(_OWORD *)(a3 + 16);
                *(_OWORD *)CMSampleTimingInfo buf = *(_OWORD *)a3;
                *(_OWORD *)&buf[16] = v138;
                *(void *)&uint8_t buf[32] = *(void *)(a3 + 32);
                [(VCCannedAudioInjectorConfig *)v136 setAudioFormat:buf];
                if (*(unsigned char *)(v19 + 578)) {
                  BOOL v139 = 1;
                }
                else {
                  BOOL v139 = *(unsigned char *)(v19 + 488) != 0;
                }
                [(VCCannedAudioInjectorConfig *)v137 setForceVoiceActive:v139];
                if (*(unsigned char *)(v19 + 578))
                {
                  [(VCCannedAudioInjectorConfig *)v137 setSineWaveFrequencyHz:2000];
                  [(VCCannedAudioInjectorConfig *)v137 setSineWaveAmplitude:0.05];
                  [(VCCannedAudioInjectorConfig *)v137 setStartHostTime:0.0];
                  double v140 = 1.0;
                }
                else
                {
                  v160[0] = 0;
                  int v141 = CFPreferencesGetAppBooleanValue(@"cannedReplayFromBeginning", @"com.apple.VideoConference", v160);
                  [(VCCannedAudioInjectorConfig *)v137 setPath:*(void *)(v19 + 584)];
                  if (v141 || *(double *)(v19 + 600) < 0.0)
                  {
                    if (v141) {
                      BOOL v142 = v160[0] == 0;
                    }
                    else {
                      BOOL v142 = 1;
                    }
                    uint64_t v143 = !v142;
                    [(VCCannedAudioInjectorConfig *)v137 setFromBeginning:v143];
LABEL_184:
                    long long v144 = [[VCCannedAudioInjector alloc] initWithConfig:v137];
                    *(void *)(v19 + 480) = v144;
                    if (!v144 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                        AUIOSetupFormats_cold_2();
                      }
                    }
LABEL_185:

                    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                    {
                      uint64_t v145 = VRTraceErrorLogLevelToCSTR();
                      long long v146 = *MEMORY[0x1E4F47A50];
                      uint64_t v17 = 0;
                      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_189;
                      }
                      *(_DWORD *)CMSampleTimingInfo buf = 136315906;
                      *(void *)&uint8_t buf[4] = v145;
                      *(_WORD *)&unsigned char buf[12] = 2080;
                      *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                      *(_WORD *)&buf[22] = 1024;
                      *(_DWORD *)&unsigned char buf[24] = 1659;
                      *(_WORD *)&buf[28] = 2048;
                      *(void *)&buf[30] = v19;
                      _os_log_impl(&dword_1E1EA4000, v146, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d succeeded AUIO=%p", buf, 0x26u);
                    }
                    uint64_t v17 = 0;
                    goto LABEL_189;
                  }
                  -[VCCannedAudioInjectorConfig setStartHostTime:](v137, "setStartHostTime:");
                  double v140 = *(double *)(v19 + 592);
                }
                [(VCCannedAudioInjectorConfig *)v137 setLoopLength:v140];
                goto LABEL_184;
              }
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
                  AUIOSetupFormats_cold_1();
                }
              }
LABEL_203:
              long long v137 = 0;
              goto LABEL_185;
            }
            *(_DWORD *)__int16 v160 = v154;
            int v79 = VCAudioUnit_AudioUnitSetProperty();
            int v157 = v79;
            int v80 = VRTraceGetErrorLogLevelForModule();
            if (v79)
            {
              if (v80 >= 5)
              {
                uint64_t v81 = VRTraceErrorLogLevelToCSTR();
                int v82 = *MEMORY[0x1E4F47A50];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)CMSampleTimingInfo buf = 136316162;
                  *(void *)&uint8_t buf[4] = v81;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&unsigned char buf[24] = 1600;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = v157;
                  *(_WORD *)&buf[34] = 1024;
                  *(_DWORD *)&buf[36] = v157;
                  long long v83 = "AUIO [%s] %s:%d AudioUnitSetProperty failed to set property kAUVoiceIOProperty_EnableRecording w"
                        "ith error %08x %d";
                  uint64_t v84 = v82;
                  uint32_t v85 = 40;
LABEL_89:
                  _os_log_impl(&dword_1E1EA4000, v84, OS_LOG_TYPE_DEFAULT, v83, buf, v85);
                }
              }
            }
            else if (v80 >= 5)
            {
              uint64_t v86 = VRTraceErrorLogLevelToCSTR();
              uint64_t v87 = *MEMORY[0x1E4F47A50];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)CMSampleTimingInfo buf = 136315650;
                *(void *)&uint8_t buf[4] = v86;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&unsigned char buf[24] = 1602;
                long long v83 = "AUIO [%s] %s:%d allowAudioRecording and kAUVoiceIOProperty_EnableRecording set to YES";
                uint64_t v84 = v87;
                uint32_t v85 = 28;
                goto LABEL_89;
              }
            }
          }
          if (*(unsigned char *)(v19 + 235)) {
            _AUIOSetRemoteCodecProperties(v19, v153, a1);
          }
          goto LABEL_92;
        }
        if (v129 >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
            AUIOSetupFormats_cold_5();
          }
        }
LABEL_140:
        uint64_t v17 = v58 | 0xA01B0000;
        goto LABEL_189;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 3
        || (uint64_t v148 = VRTraceErrorLogLevelToCSTR(),
            __int16 v122 = *MEMORY[0x1E4F47A50],
            !os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)))
      {
LABEL_139:
        int v58 = v157;
        goto LABEL_140;
      }
      *(_DWORD *)CMSampleTimingInfo buf = 136316674;
      *(void *)&uint8_t buf[4] = v148;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&unsigned char buf[24] = 1527;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v158;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = v157;
      *(_WORD *)&unsigned char buf[40] = 1040;
      *(_DWORD *)&buf[42] = 4;
      *(_WORD *)&buf[46] = 2080;
      *(void *)&uint8_t buf[48] = &v157;
      long long v149 = "AUIO [%s] %s:%d AudioUnitSetProperty failed to set property kAUVoiceIOProperty_EnableSpatialChat %d %d %.4s";
    }
    _os_log_error_impl(&dword_1E1EA4000, v122, OS_LOG_TYPE_ERROR, v149, buf, 0x38u);
    goto LABEL_139;
  }
  return 2149253122;
}

uint64_t AUIOReceiverIsReady()
{
  uint64_t v0 = CheckInHandleDebug();
  if (!v0) {
    return 2149253122;
  }
  *(unsigned char *)(v0 + 234) = 1;
  PacketThread_ReceiverIsReady(*(void *)(v0 + 472));
  CheckOutHandleDebug();
  return 0;
}

void _AUIOHealthPrintCallback(tagHANDLE *a1)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = CheckInHandleDebug();
  if (v1)
  {
    uint64_t v2 = v1;
    __n128 v22 = 0uLL;
    uint64_t v23 = 0;
    if (*(unsigned char *)(v1 + 464))
    {
      pthread_mutex_lock((pthread_mutex_t *)(v1 + 264));
      PacketThread_Statistics(*(__n128 **)(v2 + 472), &v22);
      pthread_mutex_unlock((pthread_mutex_t *)(v2 + 264));
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      uint64_t v3 = VRTraceErrorLogLevelToCSTR();
      uint64_t v4 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        int v5 = *(unsigned __int8 *)(v2 + 234);
        uint64_t v6 = *(void *)(v2 + 496);
        uint64_t v7 = *(void *)(v2 + 504);
        uint64_t v8 = *(void *)(v2 + 512);
        uint64_t v9 = *(void *)(v2 + 552);
        uint64_t v10 = *(void *)(v2 + 560);
        double v11 = *(float *)(v2 + 348);
        double v12 = *(float *)(v2 + 352);
        double v13 = *(float *)(v2 + 372);
        int v14 = *(_DWORD *)(v2 + 416);
        uint64_t v15 = *(void *)(v2 + 424);
        int v16 = *(_DWORD *)(v2 + 532);
        int v17 = *(_DWORD *)(v2 + 536);
        int v18 = *(_DWORD *)(v2 + 544);
        int v19 = *(unsigned __int8 *)(v2 + 464);
        *(_DWORD *)CMSampleTimingInfo buf = 136321282;
        uint64_t v25 = v3;
        __int16 v26 = 2080;
        uint64_t v27 = "_AUIOHealthPrintCallback";
        __int16 v28 = 1024;
        int v29 = 1929;
        __int16 v30 = 2048;
        uint64_t v31 = v2;
        __int16 v32 = 2048;
        uint64_t v33 = v6;
        __int16 v34 = 1024;
        int v35 = v5;
        __int16 v36 = 2048;
        uint64_t v37 = v7;
        __int16 v38 = 2048;
        uint64_t v39 = v22.n128_u32[0];
        __int16 v40 = 2048;
        uint64_t v41 = v8;
        __int16 v42 = 2048;
        uint64_t v43 = v9;
        __int16 v44 = 2048;
        uint64_t v45 = v10;
        __int16 v46 = 2048;
        double v47 = v11;
        __int16 v48 = 2048;
        double v49 = v12;
        __int16 v50 = 2048;
        double v51 = v13;
        __int16 v52 = 1024;
        int v53 = v14;
        __int16 v54 = 2048;
        uint64_t v55 = v15;
        __int16 v56 = 1024;
        int v57 = v16;
        __int16 v58 = 1024;
        int v59 = v17;
        __int16 v60 = 1024;
        int v61 = v18;
        __int16 v62 = 2048;
        uint64_t v63 = v22.n128_u32[1];
        __int16 v64 = 2048;
        uint64_t v65 = v23;
        __int16 v66 = 2048;
        uint64_t v67 = v22.n128_u32[2];
        __int16 v68 = 2048;
        uint64_t v69 = v22.n128_u32[3];
        __int16 v70 = 2048;
        uint64_t v71 = HIDWORD(v23);
        __int16 v72 = 1024;
        int v73 = v19;
        _os_log_impl(&dword_1E1EA4000, v4, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d @=@ Health: AudioIO (%p) micProcsCalled=%ld, ready=%d, micProcsReturned=%ld, packetsSent=%ld, voiceActivityCount=%ld, speakerProcsCalled=%ld, speakerProcsReturned=%ld, averageInputPower=%f, inputPowerMovingAverage=%f, averageOutputPower=%f, latestMicTimeStamp=%u, latestMicHostTime=%f, micShenanigans=%d, speakerShenanigans=%d, swapCount=%d packetsStored=%ld packetsDropped=[%ld, %ld, %ld, %ld] internalThreading=%d", buf, 0xE0u);
      }
    }
    CheckOutHandleDebug();
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    uint64_t v20 = VRTraceErrorLogLevelToCSTR();
    long long v21 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)CMSampleTimingInfo buf = 136315650;
      uint64_t v25 = v20;
      __int16 v26 = 2080;
      uint64_t v27 = "_AUIOHealthPrintCallback";
      __int16 v28 = 1024;
      int v29 = 1897;
      _os_log_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d IO Proc health monitor called with invalid HANDLE", buf, 0x1Cu);
    }
  }
}

uint64_t AUIOStart(uint64_t a1)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = 2149253122;
  uint64_t v3 = CheckInHandleDebug();
  if (v3)
  {
    uint64_t v4 = v3;
    int v5 = (pthread_mutex_t *)(v3 + 264);
    pthread_mutex_lock((pthread_mutex_t *)(v3 + 264));
    if (*(unsigned char *)(v4 + 232))
    {
      if (!*(unsigned char *)(v4 + 233))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v6 = VRTraceErrorLogLevelToCSTR();
          uint64_t v7 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)CMSampleTimingInfo buf = 136315906;
            uint64_t v25 = v6;
            __int16 v26 = 2080;
            uint64_t v27 = "AUIOStart";
            __int16 v28 = 1024;
            int v29 = 1948;
            __int16 v30 = 2048;
            *(void *)uint64_t v31 = v4;
            _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p AUIO Starting...", buf, 0x26u);
          }
        }
        *(_DWORD *)(v4 + 416) = 0;
        *(void *)(v4 + 424) = 0;
        *(void *)(v4 + 520) = 0x7FF8000000000000;
        *(unsigned char *)(v4 + 528) = 0;
        *(void *)(v4 + 456) = 0x7FEFFFFFFFFFFFFFLL;
        uint64_t v8 = _AUIOStartPacketThread(v4);
        if ((v8 & 0x80000000) != 0)
        {
          uint64_t v2 = v8;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            uint64_t v17 = VRTraceErrorLogLevelToCSTR();
            int v18 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)CMSampleTimingInfo buf = 136316418;
              uint64_t v25 = v17;
              __int16 v26 = 2080;
              uint64_t v27 = "AUIOStart";
              __int16 v28 = 1024;
              int v29 = 1958;
              __int16 v30 = 1024;
              *(_DWORD *)uint64_t v31 = 1958;
              *(_WORD *)&v31[4] = 2048;
              *(void *)&v31[6] = v4;
              __int16 v32 = 1024;
              int v33 = v2;
              _os_log_error_impl(&dword_1E1EA4000, v18, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/AUIO/AUIO.mm:%d: AUIO=%p Failed to start the packet thread result=%x", buf, 0x32u);
            }
          }
          goto LABEL_15;
        }
        int v9 = VCAudioUnit_AudioOutputUnitStart();
        if (v9)
        {
          int v19 = v9;
          uint64_t v2 = v9 | 0xA01B0000;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            uint64_t v20 = VRTraceErrorLogLevelToCSTR();
            long long v21 = *MEMORY[0x1E4F47A50];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)CMSampleTimingInfo buf = 136316418;
              uint64_t v25 = v20;
              __int16 v26 = 2080;
              uint64_t v27 = "AUIOStart";
              __int16 v28 = 1024;
              int v29 = 1961;
              __int16 v30 = 1024;
              *(_DWORD *)uint64_t v31 = 1961;
              *(_WORD *)&v31[4] = 2048;
              *(void *)&v31[6] = v4;
              __int16 v32 = 1024;
              int v33 = v19;
              _os_log_error_impl(&dword_1E1EA4000, v21, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/AUIO/AUIO.mm:%d: AUIO=%p ERROR AudioOutputUnitStart returned %d", buf, 0x32u);
            }
          }
          __n128 v22 = *(int **)(v4 + 472);
          if (v22)
          {
            PacketThread_Destroy(v22);
            *(void *)(v4 + 472) = 0;
          }
          goto LABEL_15;
        }
        *(unsigned char *)(v4 + 233) = 1;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          uint64_t v10 = VRTraceErrorLogLevelToCSTR();
          double v11 = *MEMORY[0x1E4F47A50];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)CMSampleTimingInfo buf = 136316162;
            uint64_t v25 = v10;
            __int16 v26 = 2080;
            uint64_t v27 = "AUIOStart";
            __int16 v28 = 1024;
            int v29 = 1964;
            __int16 v30 = 1024;
            *(_DWORD *)uint64_t v31 = 1964;
            *(_WORD *)&v31[4] = 2048;
            *(void *)&v31[6] = v4;
            _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/AUIO/AUIO.mm:%d: AUIO=%p AudioOutputUnitStart() completed", buf, 0x2Cu);
          }
        }
        global_queue = dispatch_get_global_queue(0, 0);
        dispatch_source_t v13 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, global_queue);
        *(void *)(v4 + 568) = v13;
        if (v13)
        {
          int v14 = v13;
          dispatch_time_t v15 = dispatch_walltime(0, 0);
          dispatch_source_set_timer(v14, v15, 0x12A05F200uLL, 0x23C34600uLL);
          handler[0] = MEMORY[0x1E4F143A8];
          handler[1] = 3221225472;
          handler[2] = __AUIOStart_block_invoke;
          handler[3] = &__block_descriptor_40_e5_v8__0l;
          handler[4] = a1;
          dispatch_source_set_event_handler(*(dispatch_source_t *)(v4 + 568), handler);
          dispatch_source_set_cancel_handler(*(dispatch_source_t *)(v4 + 568), handler);
          dispatch_resume(*(dispatch_object_t *)(v4 + 568));
        }
      }
      uint64_t v2 = 0;
    }
    else
    {
      uint64_t v2 = 2149253176;
    }
LABEL_15:
    pthread_mutex_unlock(v5);
    CheckOutHandleDebug();
  }
  return v2;
}

void __AUIOStart_block_invoke(uint64_t a1)
{
}

uint64_t AUIOStop()
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = 2149253122;
  uint64_t v1 = CheckInHandleDebug();
  if (v1)
  {
    uint64_t v2 = v1;
    uint64_t v3 = (pthread_mutex_t *)(v1 + 264);
    pthread_mutex_lock((pthread_mutex_t *)(v1 + 264));
    int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    int v5 = (os_log_t *)MEMORY[0x1E4F47A50];
    if (ErrorLogLevelForModule >= 7)
    {
      uint64_t v6 = VRTraceErrorLogLevelToCSTR();
      uint64_t v7 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        int v16 = 136315906;
        uint64_t v17 = v6;
        __int16 v18 = 2080;
        int v19 = "AUIOStop";
        __int16 v20 = 1024;
        int v21 = 2002;
        __int16 v22 = 2048;
        uint64_t v23 = v2;
        _os_log_impl(&dword_1E1EA4000, v7, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p Stopping the audio unit.", (uint8_t *)&v16, 0x26u);
      }
    }
    if (*(unsigned char *)(v2 + 232))
    {
      if (*(void *)(v2 + 48) && *(unsigned char *)(v2 + 233))
      {
        VCAudioUnit_AudioOutputUnitStop();
        *(unsigned char *)(v2 + 233) = 0;
      }
      uint64_t v8 = *(NSObject **)(v2 + 568);
      if (v8)
      {
        dispatch_source_cancel(v8);
        int v9 = *(NSObject **)(v2 + 568);
        if (v9)
        {
          dispatch_release(v9);
          *(void *)(v2 + 568) = 0;
        }
      }
      uint64_t v10 = *(int **)(v2 + 472);
      if (v10)
      {
        PacketThread_Destroy(v10);
        uint64_t v0 = 0;
        *(void *)(v2 + 472) = 0;
      }
      else
      {
        uint64_t v0 = 0;
      }
    }
    else
    {
      uint64_t v0 = 2149253176;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() > 6)
    {
      uint64_t v11 = VRTraceErrorLogLevelToCSTR();
      double v12 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        int v16 = 136315906;
        uint64_t v17 = v11;
        __int16 v18 = 2080;
        int v19 = "AUIOStop";
        __int16 v20 = 1024;
        int v21 = 2021;
        __int16 v22 = 2048;
        uint64_t v23 = v2;
        _os_log_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p Stopped the audio unit.", (uint8_t *)&v16, 0x26u);
      }
    }
    pthread_mutex_unlock(v3);
    CheckOutHandleDebug();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      uint64_t v13 = VRTraceErrorLogLevelToCSTR();
      int v14 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        int v16 = 136315650;
        uint64_t v17 = v13;
        __int16 v18 = 2080;
        int v19 = "AUIOStop";
        __int16 v20 = 1024;
        int v21 = 2025;
        _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO Stop!", (uint8_t *)&v16, 0x1Cu);
      }
    }
  }
  return v0;
}

uint64_t AUIOSetInputMeterEnabled(uint64_t a1, int a2)
{
  uint64_t v3 = CheckInHandleDebug();
  if (!v3) {
    return 2149253122;
  }
  uint64_t v4 = v3;
  int v5 = (pthread_mutex_t *)(v3 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 264));
  if (a2)
  {
    if (!*(_DWORD *)(v4 + 344))
    {
      *(_DWORD *)(v4 + 344) = a2;
      operator new();
    }
  }
  else
  {
    uint64_t v7 = *(void *)(v4 + 336);
    if (v7)
    {
      *(_DWORD *)(v4 + 344) = 0;
      MEMORY[0x1E4E57980](v7, 0x1000C407AA769CALL);
      *(void *)(v4 + 336) = 0;
    }
  }
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

void sub_1E237A974(_Unwind_Exception *a1)
{
  MEMORY[0x1E4E57980](v1, 0x1000C407AA769CALL);
  _Unwind_Resume(a1);
}

uint64_t AUIOSetOutputMeterEnabled(uint64_t a1, int a2)
{
  uint64_t v3 = CheckInHandleDebug();
  if (!v3) {
    return 2149253122;
  }
  uint64_t v4 = v3;
  int v5 = (pthread_mutex_t *)(v3 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 264));
  *(_DWORD *)(v4 + 368) = a2;
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AUIOSetMute(uint64_t a1, int a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = CheckInHandleDebug();
  if (!v3) {
    return 2149253122;
  }
  uint64_t v4 = v3;
  int v5 = (pthread_mutex_t *)(v3 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 264));
  if (*(_DWORD *)(v4 + 328) || *(unsigned char *)(v4 + 576)) {
    goto LABEL_4;
  }
  int v8 = *(unsigned __int8 *)(v4 + 577);
  if (v8 == 2) {
    goto LABEL_11;
  }
  if (v8 == 1) {
    goto LABEL_4;
  }
  if (!*(unsigned char *)(v4 + 577))
  {
LABEL_11:
    if (!*(unsigned char *)(v4 + 235)) {
      goto LABEL_4;
    }
  }
  *(_DWORD *)(v4 + 332) = a2;
  int v15 = a2;
  int v9 = VCAudioUnit_AudioUnitSetProperty();
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v9)
  {
    if (ErrorLogLevelForModule >= 3)
    {
      uint64_t v11 = VRTraceErrorLogLevelToCSTR();
      double v12 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 136316418;
        uint64_t v17 = v11;
        __int16 v18 = 2080;
        int v19 = "AUIOSetMute";
        __int16 v20 = 1024;
        int v21 = 2123;
        __int16 v22 = 1024;
        int v23 = v15;
        __int16 v24 = 1024;
        int v25 = v9;
        __int16 v26 = 1024;
        int v27 = v9;
        _os_log_error_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d AudioUnitSetProperty failed to set property kAUVoiceIOProperty_MuteOutput to %u with error %08x %d", buf, 0x2Eu);
      }
    }
    uint64_t v6 = v9 | 0xA01B0000;
    goto LABEL_5;
  }
  if (ErrorLogLevelForModule >= 5)
  {
    uint64_t v13 = VRTraceErrorLogLevelToCSTR();
    int v14 = *MEMORY[0x1E4F47A50];
    uint64_t v6 = 0;
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_5;
    }
    *(_DWORD *)CMSampleTimingInfo buf = 136315906;
    uint64_t v17 = v13;
    __int16 v18 = 2080;
    int v19 = "AUIOSetMute";
    __int16 v20 = 1024;
    int v21 = 2126;
    __int16 v22 = 1024;
    int v23 = v15;
    _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d Changed mute to %u", buf, 0x22u);
  }
LABEL_4:
  uint64_t v6 = 0;
LABEL_5:
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return v6;
}

uint64_t AUIOSetVoiceMixingMedia(uint64_t a1, int a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = CheckInHandleDebug();
  if (!v3) {
    return 2149253122;
  }
  uint64_t v4 = v3;
  int v5 = (pthread_mutex_t *)(v3 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 264));
  if (!*(unsigned char *)(v4 + 576) && *(unsigned char *)(v4 + 577) != 1)
  {
    int v14 = a2;
    int v8 = VCAudioUnit_AudioUnitSetProperty();
    int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (v8)
    {
      if (ErrorLogLevelForModule >= 3)
      {
        uint64_t v10 = VRTraceErrorLogLevelToCSTR();
        uint64_t v11 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 136316418;
          uint64_t v16 = v10;
          __int16 v17 = 2080;
          __int16 v18 = "AUIOSetVoiceMixingMedia";
          __int16 v19 = 1024;
          int v20 = 2156;
          __int16 v21 = 1024;
          int v22 = v14;
          __int16 v23 = 1024;
          int v24 = v8;
          __int16 v25 = 1024;
          int v26 = v8;
          _os_log_error_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d AudioUnitSetProperty failed to set property kAUVoiceIOProperty_EnableMediaChat to %u with error %08x %d", buf, 0x2Eu);
        }
      }
      uint64_t v6 = v8 | 0xA01B0000;
      goto LABEL_5;
    }
    if (ErrorLogLevelForModule >= 7)
    {
      uint64_t v12 = VRTraceErrorLogLevelToCSTR();
      uint64_t v13 = *MEMORY[0x1E4F47A50];
      uint64_t v6 = 0;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_5;
      }
      *(_DWORD *)CMSampleTimingInfo buf = 136315906;
      uint64_t v16 = v12;
      __int16 v17 = 2080;
      __int16 v18 = "AUIOSetVoiceMixingMedia";
      __int16 v19 = 1024;
      int v20 = 2159;
      __int16 v21 = 1024;
      int v22 = v14;
      _os_log_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d Changed kAUVoiceIOProperty_EnableMediaChat to %u", buf, 0x22u);
    }
  }
  uint64_t v6 = 0;
LABEL_5:
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return v6;
}

uint64_t AUIOSetMediaPlaybackOnExternalDevice(uint64_t a1, int a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = CheckInHandleDebug();
  if (!v3) {
    return 2149253122;
  }
  uint64_t v4 = v3;
  int v5 = (pthread_mutex_t *)(v3 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 264));
  if (!*(unsigned char *)(v4 + 576) && *(unsigned char *)(v4 + 577) != 1)
  {
    int v14 = a2;
    int v8 = VCAudioUnit_AudioUnitSetProperty();
    int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (v8)
    {
      if (ErrorLogLevelForModule >= 3)
      {
        uint64_t v10 = VRTraceErrorLogLevelToCSTR();
        uint64_t v11 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 136316418;
          uint64_t v16 = v10;
          __int16 v17 = 2080;
          __int16 v18 = "AUIOSetMediaPlaybackOnExternalDevice";
          __int16 v19 = 1024;
          int v20 = 2183;
          __int16 v21 = 1024;
          int v22 = v14;
          __int16 v23 = 1024;
          int v24 = v8;
          __int16 v25 = 2080;
          int v26 = FourccToCStr(v8);
          _os_log_error_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d AudioUnitSetProperty failed to set property kAUVoiceIOProperty_MediaPlaybackOnExternalDevice to value=%u with error=%08x (fourcc=%s)", buf, 0x32u);
        }
      }
      uint64_t v6 = v8 | 0xA01B0000;
      goto LABEL_5;
    }
    if (ErrorLogLevelForModule >= 7)
    {
      uint64_t v12 = VRTraceErrorLogLevelToCSTR();
      uint64_t v13 = *MEMORY[0x1E4F47A50];
      uint64_t v6 = 0;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_5;
      }
      *(_DWORD *)CMSampleTimingInfo buf = 136315906;
      uint64_t v16 = v12;
      __int16 v17 = 2080;
      __int16 v18 = "AUIOSetMediaPlaybackOnExternalDevice";
      __int16 v19 = 1024;
      int v20 = 2181;
      __int16 v21 = 1024;
      int v22 = v14;
      _os_log_impl(&dword_1E1EA4000, v13, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d Changed kAUVoiceIOProperty_MediaPlaybackOnExternalDevice to value=%u", buf, 0x22u);
    }
  }
  uint64_t v6 = 0;
LABEL_5:
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return v6;
}

uint64_t AUIOGetAUNumber(UInt32 *a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = 2149253121;
  if (a1)
  {
    *(_OWORD *)&v5.componentint Type = xmmword_1E25A2420;
    v5.componentFlagsMasuint64_t k = 0;
    uint64_t Next = AudioComponentFindNext(0, &v5);
    if (Next) {
      return AudioComponentGetVersion(Next, a1);
    }
    else {
      return 2149253142;
    }
  }
  return v1;
}

uint64_t AUIOSetRemoteCodecInfo(double a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5 = CheckInHandleDebug();
  if (!v5) {
    return 2149253122;
  }
  uint64_t v6 = v5;
  uint64_t v7 = (pthread_mutex_t *)(v5 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 264));
  _AUIOSetRemoteCodecProperties(v6, a3, a1);
  pthread_mutex_unlock(v7);
  CheckOutHandleDebug();
  return 0;
}

void _AUIOSetRemoteCodecProperties(uint64_t a1, unsigned int a2, double a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 576) && *(unsigned char *)(a1 + 577) != 1)
  {
    unsigned int v3 = VCAudioUnit_AudioUnitSetProperty();
    int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (v3)
    {
      if (ErrorLogLevelForModule >= 3)
      {
        uint64_t v5 = VRTraceErrorLogLevelToCSTR();
        uint64_t v6 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 136316162;
          uint64_t v18 = v5;
          __int16 v19 = 2080;
          int v20 = "_AUIOSetRemoteCodecProperties";
          __int16 v21 = 1024;
          int v22 = 2235;
          __int16 v23 = 1024;
          unsigned int v24 = v3;
          __int16 v25 = 1024;
          unsigned int v26 = a2;
          _os_log_error_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d kAUVoiceIOProperty_PrimaryCodecType failed(%d) codecType(%d)", buf, 0x28u);
        }
      }
    }
    else if (ErrorLogLevelForModule >= 7)
    {
      uint64_t v7 = VRTraceErrorLogLevelToCSTR();
      int v8 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 136315906;
        uint64_t v18 = v7;
        __int16 v19 = 2080;
        int v20 = "_AUIOSetRemoteCodecProperties";
        __int16 v21 = 1024;
        int v22 = 2238;
        __int16 v23 = 1024;
        unsigned int v24 = a2;
        _os_log_impl(&dword_1E1EA4000, v8, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d kAUVoiceIOProperty_PrimaryCodecType succeeded codecType(%d)", buf, 0x22u);
      }
    }
    unsigned int v9 = VCAudioUnit_AudioUnitSetProperty();
    int v10 = VRTraceGetErrorLogLevelForModule();
    if (v9)
    {
      if (v10 >= 3)
      {
        uint64_t v11 = VRTraceErrorLogLevelToCSTR();
        uint64_t v12 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 136316162;
          uint64_t v18 = v11;
          __int16 v19 = 2080;
          int v20 = "_AUIOSetRemoteCodecProperties";
          __int16 v21 = 1024;
          int v22 = 2243;
          __int16 v23 = 1024;
          unsigned int v24 = v9;
          __int16 v25 = 1024;
          unsigned int v26 = a3;
          _os_log_error_impl(&dword_1E1EA4000, v12, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d kAUVoiceIOProperty_PrimaryCodecSampleRate failed(%d) sampleRate(%d)", buf, 0x28u);
        }
      }
    }
    else if (v10 >= 7)
    {
      uint64_t v13 = VRTraceErrorLogLevelToCSTR();
      int v14 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 136315906;
        uint64_t v18 = v13;
        __int16 v19 = 2080;
        int v20 = "_AUIOSetRemoteCodecProperties";
        __int16 v21 = 1024;
        int v22 = 2246;
        __int16 v23 = 1024;
        unsigned int v24 = a3;
        _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d kAUVoiceIOProperty_PrimaryCodecSampleRate succeded: sampleRate(%d)", buf, 0x22u);
      }
    }
  }
}

uint64_t AUIOSetSpatialMetadata()
{
  uint64_t v0 = CheckInHandleDebug();
  if (!v0) {
    return 2149253122;
  }
  uint64_t v1 = (pthread_mutex_t *)(v0 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v0 + 264));
  int v2 = VCAudioUnit_AudioUnitSetProperty();
  if (v2)
  {
    uint64_t v3 = v2 | 0xA01B0000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        AUIOSetSpatialMetadata_cold_1();
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  pthread_mutex_unlock(v1);
  CheckOutHandleDebug();
  return v3;
}

uint64_t AUIORegisterMutedTalkerNotificationEventListener(uint64_t a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  char v3 = _os_feature_enabled_impl();
  int ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if ((v3 & 1) == 0)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      uint64_t v13 = VRTraceErrorLogLevelToCSTR();
      int v14 = *MEMORY[0x1E4F47A50];
      uint64_t v15 = 0;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
        return v15;
      }
      *(_DWORD *)CMSampleTimingInfo buf = 136315650;
      uint64_t v20 = v13;
      __int16 v21 = 2080;
      int v22 = "AUIORegisterMutedTalkerNotificationEventListener";
      __int16 v23 = 1024;
      int v24 = 2279;
      _os_log_impl(&dword_1E1EA4000, v14, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d MutedTalker feature disabled", buf, 0x1Cu);
    }
    return 0;
  }
  if (ErrorLogLevelForModule >= 6)
  {
    uint64_t v5 = VRTraceErrorLogLevelToCSTR();
    uint64_t v6 = *MEMORY[0x1E4F47A50];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)CMSampleTimingInfo buf = 136315650;
      uint64_t v20 = v5;
      __int16 v21 = 2080;
      int v22 = "AUIORegisterMutedTalkerNotificationEventListener";
      __int16 v23 = 1024;
      int v24 = 2282;
      _os_log_impl(&dword_1E1EA4000, v6, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d MutedTalker feature enabled", buf, 0x1Cu);
    }
  }
  uint64_t v7 = CheckInHandleDebug();
  if (!v7) {
    return 2149253122;
  }
  int v8 = (pthread_mutex_t *)(v7 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 264));
  int v9 = VRTraceGetErrorLogLevelForModule();
  if (a2)
  {
    if (v9 < 7) {
      goto LABEL_19;
    }
    uint64_t v10 = VRTraceErrorLogLevelToCSTR();
    uint64_t v11 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_19;
    }
    *(_DWORD *)CMSampleTimingInfo buf = 136315650;
    uint64_t v20 = v10;
    __int16 v21 = 2080;
    int v22 = "AUIORegisterMutedTalkerNotificationEventListener";
    __int16 v23 = 1024;
    int v24 = 2291;
    uint64_t v12 = "AUIO [%s] %s:%d Registering mutedTalker feature";
  }
  else
  {
    if (v9 < 7) {
      goto LABEL_19;
    }
    uint64_t v16 = VRTraceErrorLogLevelToCSTR();
    uint64_t v11 = *MEMORY[0x1E4F47A50];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_19;
    }
    *(_DWORD *)CMSampleTimingInfo buf = 136315650;
    uint64_t v20 = v16;
    __int16 v21 = 2080;
    int v22 = "AUIORegisterMutedTalkerNotificationEventListener";
    __int16 v23 = 1024;
    int v24 = 2293;
    uint64_t v12 = "AUIO [%s] %s:%d Unregistering mutedTalker feature";
  }
  _os_log_impl(&dword_1E1EA4000, v11, OS_LOG_TYPE_DEFAULT, v12, buf, 0x1Cu);
LABEL_19:
  int v17 = VCAudioUnit_AudioUnitSetProperty();
  if (v17)
  {
    uint64_t v15 = v17 | 0xA01B0000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        AUIORegisterMutedTalkerNotificationEventListener_cold_1();
      }
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  pthread_mutex_unlock(v8);
  CheckOutHandleDebug();
  return v15;
}

uint64_t AUIOSetDynamicDuckerVolume()
{
  uint64_t v0 = CheckInHandleDebug();
  if (!v0) {
    return 2149253122;
  }
  uint64_t v1 = (pthread_mutex_t *)(v0 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v0 + 264));
  int v2 = VCAudioUnit_AudioUnitSetParameter();
  if (v2)
  {
    uint64_t v3 = v2 | 0xA01B0000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR)) {
        AUIOSetDynamicDuckerVolume_cold_1();
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  pthread_mutex_unlock(v1);
  CheckOutHandleDebug();
  return v3;
}

uint64_t LogProfileTimeOverLimit(double a1, double a2, const char *a3, ...)
{
  va_start(va, a3);
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t result = VRTraceIsInternalOSInstalled();
  if (result)
  {
    double v7 = micro() - a1;
    if (v7 <= a2)
    {
      return 0;
    }
    else
    {
      *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v35 = v8;
      long long v36 = v8;
      long long v33 = v8;
      long long v34 = v8;
      long long v31 = v8;
      long long v32 = v8;
      long long v29 = v8;
      long long v30 = v8;
      long long v27 = v8;
      long long v28 = v8;
      long long v26 = v8;
      long long v24 = v8;
      long long v25 = v8;
      long long v22 = v8;
      long long v23 = v8;
      *(_OWORD *)__str = v8;
      vsnprintf(__str, 0x100uLL, a3, va);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v9 = VRTraceErrorLogLevelToCSTR();
        uint64_t v10 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 136316162;
          uint64_t v12 = v9;
          __int16 v13 = 2080;
          int v14 = "_LogProfileTimeLimitHelper";
          __int16 v15 = 1024;
          int v16 = 36;
          __int16 v17 = 2080;
          uint64_t v18 = __str;
          __int16 v19 = 2048;
          double v20 = v7;
          _os_log_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d %s: Took a long time %fs", buf, 0x30u);
        }
      }
      return 1;
    }
  }
  return result;
}

void _AUIOSendMicSamples(uint64_t a1, uint64_t a2)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  int Timestamp = VCAudioBufferList_GetTimestamp(a2);
  Sampleint32_t Count = VCAudioBufferList_GetSampleCount(a2);
  uint64_t SampleFormat = VCAudioBufferList_GetSampleFormat(a2);
  double v7 = *(const void **)(VCAudioBufferList_GetAudioBufferList(a2) + 16);
  int v8 = *(_DWORD *)(a1 + 412);
  int v9 = Timestamp - v8;
  if (v7 && (uint64_t v10 = *(void *)(a1 + 400)) != 0)
  {
    size_t v11 = (*(_DWORD *)(SampleFormat + 24) * SampleCount);
    unsigned int v12 = *(_DWORD *)(a1 + 160) * v8;
    unsigned int v13 = *(_DWORD *)(a1 + 408);
    unsigned int v14 = v12 + v11 - v13;
    if (v12 + v11 > v13)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v35 = VRTraceErrorLogLevelToCSTR();
        __int16 v15 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = *(void *)(a1 + 400);
          int v17 = *(_DWORD *)(a1 + 256);
          int v18 = *(_DWORD *)(a1 + 408);
          int v19 = *(_DWORD *)(a1 + 412);
          *(_DWORD *)CMSampleTimingInfo buf = 136317698;
          uint64_t v37 = v35;
          __int16 v38 = 2080;
          uint64_t v39 = "_AUIOBufferMicSamples";
          __int16 v40 = 1024;
          int v41 = 288;
          __int16 v42 = 2048;
          uint64_t v43 = a1;
          __int16 v44 = 2048;
          uint64_t v45 = v16;
          __int16 v46 = 1024;
          *(_DWORD *)double v47 = v17;
          *(_WORD *)&v47[4] = 1024;
          *(_DWORD *)&v47[6] = v18;
          LOWORD(v48) = 1024;
          *(_DWORD *)((char *)&v48 + 2) = v19;
          HIWORD(v48) = 1024;
          int v49 = SampleCount;
          __int16 v50 = 1024;
          int v51 = v11;
          __int16 v52 = 1024;
          unsigned int v53 = v14;
          _os_log_impl(&dword_1E1EA4000, v15, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p bufferedMicSamples=%p is too full, dropping older samples to fit this. maxSampleSize=%d maxByteSize=%u curSampleCount=%u appendSampleCount=%u appendBytes=%u sizeNeeded=%u", buf, 0x54u);
        }
      }
      memmove(*(void **)(a1 + 400), (const void *)(*(void *)(a1 + 400) + v14), *(_DWORD *)(a1 + 408) - v14);
      v12 -= v14;
      int v20 = v14 / *(_DWORD *)(SampleFormat + 24);
      *(_DWORD *)(a1 + 412) -= v20;
      v9 += v20;
      uint64_t v10 = *(void *)(a1 + 400);
    }
    memcpy((void *)(v10 + v12), v7, v11);
    int v21 = *(_DWORD *)(a1 + 412) + SampleCount;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      uint64_t v22 = VRTraceErrorLogLevelToCSTR();
      long long v23 = *MEMORY[0x1E4F47A50];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_ERROR))
      {
        uint64_t v34 = *(void *)(a1 + 400);
        *(_DWORD *)CMSampleTimingInfo buf = 136316674;
        uint64_t v37 = v22;
        __int16 v38 = 2080;
        uint64_t v39 = "_AUIOBufferMicSamples";
        __int16 v40 = 1024;
        int v41 = 268;
        __int16 v42 = 2048;
        uint64_t v43 = a1;
        __int16 v44 = 2048;
        uint64_t v45 = a2;
        __int16 v46 = 2048;
        *(void *)double v47 = v7;
        *(_WORD *)&v47[8] = 2048;
        uint64_t v48 = v34;
        _os_log_error_impl(&dword_1E1EA4000, v23, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d AUIO=%p sampleBuffer=%p buffer=%p bufferedMicSamples=%p", buf, 0x44u);
      }
    }
    int v21 = 0;
  }
  *(_DWORD *)(a1 + 412) = v21;
  signed int v24 = *(_DWORD *)(a1 + 176);
  int v25 = *(_DWORD *)(a1 + 160);
  int v26 = *(_DWORD *)(a1 + 164);
  double HostTime = VCAudioBufferList_GetHostTime(a2);
  if (*(_DWORD *)(a1 + 412) >= v24)
  {
    double v28 = HostTime;
    int v29 = v26 * v25;
    uint64_t v30 = (v29 * v24);
    do
    {
      uint64_t AudioBufferList = VCAudioBufferList_GetAudioBufferList(a2);
      *(void *)(AudioBufferList + 16) = *(void *)(a1 + 400);
      *(_DWORD *)(AudioBufferList + 12) = v30;
      VCAudioBufferList_InvalidateAveragePower(a2);
      VCAudioBufferList_SetTime(a2, v9, v28);
      VCAudioBufferList_SetSampleCount(a2, v24);
      uint64_t v32 = *(void *)(a1 + 480);
      if (v32) {
        VCCannedAudioInjector_InjectSamples(v32, a2, *(_DWORD *)(a1 + 332) != 0, 0);
      }
      else {
        VCAudioBufferList_SetVoiceActivity(a2, *(_DWORD *)(a1 + 392));
      }
      (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(a1 + 16), a2);
      VCAudioBufferList_Reset(a2);
      memmove(*(void **)(a1 + 400), (const void *)(*(void *)(a1 + 400) + v30), (v29 * (*(_DWORD *)(a1 + 412) - v24)));
      signed int v33 = *(_DWORD *)(a1 + 412) - v24;
      *(_DWORD *)(a1 + 412) = v33;
      v9 += v24;
      double v28 = v28 + (double)v24 / *(double *)(a1 + 136);
    }
    while (v33 >= v24);
  }
}

uint64_t LogProfileTimeOverLimitCompare(double a1, double a2, double a3, const char *a4, ...)
{
  va_start(va, a4);
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t result = VRTraceIsInternalOSInstalled();
  if (result)
  {
    double v7 = a2 - a1;
    if (v7 <= 0.1)
    {
      return 0;
    }
    else
    {
      *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v35 = v8;
      long long v36 = v8;
      long long v33 = v8;
      long long v34 = v8;
      long long v31 = v8;
      long long v32 = v8;
      long long v29 = v8;
      long long v30 = v8;
      long long v27 = v8;
      long long v28 = v8;
      long long v26 = v8;
      long long v24 = v8;
      long long v25 = v8;
      long long v22 = v8;
      long long v23 = v8;
      *(_OWORD *)__str = v8;
      vsnprintf(__str, 0x100uLL, "AUIO last mic sample delayed. currentTime=%f previousTime=%f delta=%f", va);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        uint64_t v9 = VRTraceErrorLogLevelToCSTR();
        uint64_t v10 = *MEMORY[0x1E4F47A50];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F47A50], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 136316162;
          uint64_t v12 = v9;
          __int16 v13 = 2080;
          unsigned int v14 = "_LogProfileTimeLimitHelper";
          __int16 v15 = 1024;
          int v16 = 36;
          __int16 v17 = 2080;
          int v18 = __str;
          __int16 v19 = 2048;
          double v20 = v7;
          _os_log_impl(&dword_1E1EA4000, v10, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d %s: Took a long time %fs", buf, 0x30u);
        }
      }
      return 1;
    }
  }
  return result;
}