uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  long long v10;
  long long v11;
  long long v12;
  _OWORD v14[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v14[0] = v10;
  v14[1] = v11;
  v14[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v14);
  RB::Fill::Color::mix(v8 + 104, a3 + 104, 3, *(float *)(a2 + 16));
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  *(float *)(v8 + 96) = *(float *)(v8 + 96)
                      + (float)((float)(*(float *)(a3 + 96) - *(float *)(v8 + 96)) * *(float *)(a2 + 16));
  *(void *)(v8 + 72) = 0x100000001000000;
  *(int32x2_t *)(v8 + 80) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272)) {
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RBStrokeRef::prepare_encode(a1 + 8, (uint64_t)(a1 + 7), (uint64_t *)a2);
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::encode(void *a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RBStrokeRef>>(this, 1, (uint64_t)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::Color>(this, 2, (RB::Fill::Color *)(a1 + 13));
  v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::print(const RB::AffineTransform **a1, std::string *this)
{
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill5ColorEEEJRS0_RKS7_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 120 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0x78uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 120;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::GenericItem1(v15, _S0, a2, a3, a4, *a5, *a7, 0);
  void *result = &unk_26C4E97A0;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(size_t *a1, uint64_t a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v10 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v10 + 112 > a1[3]) {
    uint64_t v10 = RB::Heap::alloc_slow(a1, 0x70uLL, 7);
  }
  else {
    a1[2] = v10 + 112;
  }
  int v11 = *a4;
  char v12 = *a5;
  uint64_t v13 = *a6;
  *(void *)(v10 + 16) = 0;
  *(void *)(v10 + 24) = 0;
  *(_DWORD *)(v10 + 40) = 0;
  *(void *)(v10 + 32) = 0;
  *(unsigned char *)(v10 + 44) = v12;
  *(unsigned char *)(v10 + 45) = 0;
  *(void *)uint64_t v10 = &unk_26C4E8D18;
  *(void *)(v10 + 48) = v13;
  *(void *)(v10 + 56) = &unk_26C4EDD28;
  *(void *)(v10 + 64) = *(id *)(a3 + 8);
  long long v14 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(v10 + 72) = v14;
  *(unsigned char *)(v10 + 88) = *(unsigned char *)(a3 + 32);
  *(_WORD *)(v10 + 89) = *(_WORD *)(a3 + 33);
  *(unsigned char *)(v10 + 91) = *(unsigned char *)(a3 + 35);
  *(unsigned char *)(v10 + 92) = *(unsigned char *)(a3 + 36);
  LODWORD(v14) = *(_DWORD *)(a3 + 40);
  *(_DWORD *)(v10 + 96) = v14;
  *(_DWORD *)(v10 + 104) = v11;
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::update_bounds(v10, *(double *)&v14, v15);
  return v10;
}

void sub_2141740FC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 56) = v2;

  _Unwind_Resume(a1);
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill8GradientEEEJRS7_RKS9_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(size_t *a1, uint64_t a2, long long *a3, uint64_t *a4, __int16 *a5, _WORD *a6)
{
  unint64_t v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 168 > a1[3]) {
    unint64_t v11 = RB::Heap::alloc_slow(a1, 0xA8uLL, 7);
  }
  else {
    a1[2] = v11 + 168;
  }
  uint64_t v12 = *a4;
  __int16 v13 = *a5;
  char v14 = *a6;
  *(void *)(v11 + 16) = 0;
  *(void *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(void *)(v11 + 32) = 0;
  *(_WORD *)(v11 + 44) = v13;
  *(_WORD *)(v11 + 46) = v14 & 0x3F;
  *(void *)unint64_t v11 = &unk_26C4EB288;
  *(void *)(v11 + 48) = v12;
  *(void *)(v11 + 56) = &unk_26C4EDD28;
  *(void *)(v11 + 64) = *(id *)(a2 + 8);
  long long v15 = *(_OWORD *)(a2 + 28);
  *(_OWORD *)(v11 + 72) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v11 + 84) = v15;
  long long v16 = *a3;
  long long v17 = a3[1];
  long long v18 = a3[2];
  *(_OWORD *)(v11 + 152) = a3[3];
  *(_OWORD *)(v11 + 136) = v18;
  *(_OWORD *)(v11 + 120) = v17;
  *(_OWORD *)(v11 + 104) = v16;
  *(void *)unint64_t v11 = &unk_26C4E9AE8;
  return v11;
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::~GenericItem(uint64_t a1)
{
  *(void *)a1 = &unk_26C4EB288;
  *(void *)(a1 + 56) = &unk_26C4EDD28;

  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::~GenericItem(uint64_t a1)
{
  *(void *)a1 = &unk_26C4EB288;
  *(void *)(a1 + 56) = &unk_26C4EDD28;

  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::type_id()
{
  return 8404993;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::copy(__n128 *a1, uint64_t a2, char a3)
{
  unsigned __int16 v4 = a1[2].n128_u16[7];
  if (*(unsigned char *)(a2 + 272)) {
    BOOL v5 = (a3 & 2 | v4 & 0x1000) == 0;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    __int16 v6 = 4096;
  }
  else {
    __int16 v6 = 0;
  }
  v7 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  int v10 = v4 & 0x3F;
  v8 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill8GradientEEEJRS0_RKS7_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v7, v7, (uint64_t)&a1[3].n128_i64[1], &a1[6].n128_i64[1], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v10);
  __n128 result = a1[1];
  v8[1] = result;
  v8[2].n128_u64[0] = a1[2].n128_u64[0];
  v8[2].n128_u32[2] = a1[2].n128_u32[2];
  v8[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800 | v6;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::atom_position(uint64_t a1, double a2, int32x4_t a3)
{
  float32x2_t v3 = RB::Coverage::Stroke<RBStrokeRef>::bounds((void *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2, a3);
  return vmla_f32(v3, (float32x2_t)0x3F0000003F000000, v4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::make_clip(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, float a5)
{
  float v24 = 0.0;
  unsigned int v25 = a3;
  if (RB::Fill::Gradient::get_alpha((RB::Fill::Gradient *)(a1 + 104), &v24))
  {
    unint64_t v11 = (size_t *)(*(void *)(a2 + 8) + 16);
    _H0 = *(_WORD *)(a1 + 44);
    __asm { FCVT            S0, H0 }
    float v23 = _S0 * (float)(a5 * v24);
    uint64_t v18 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v11, (uint64_t)v11, a1 + 56, (int *)&v23, &v25, (uint64_t *)(a1 + 48));
    uint64_t v19 = a4[5];
    size_t v20 = v19 + 1;
    if (a4[6] < (unint64_t)(v19 + 1))
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v20);
      uint64_t v19 = a4[5];
      size_t v20 = v19 + 1;
    }
    v21 = (void *)a4[4];
    if (!v21) {
      v21 = a4;
    }
    v21[v19] = v18;
    a4[5] = v20;
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
  else
  {
    v10.n128_f32[0] = a5;
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, v10);
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 160);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::bounds(uint64_t a1, double a2, int32x4_t a3)
{
  return RB::Coverage::Stroke<RBStrokeRef>::bounds((void *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2, a3);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::min_scale(uint64_t a1)
{
  float result = 0.0;
  if (!*(unsigned char *)(a1 + 88) && *(unsigned char *)(a1 + 92) == 1) {
    return 1.0;
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

void **RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::prepare(void **result, uint64_t **a2)
{
  if (*((unsigned char *)result + 88) == 1) {
    return (void **)RBStrokeRef::prepare(result + 8, a2);
  }
  return result;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::render(uint64_t a1, double a2, uint64_t a3, uint64_t ***a4, int a5, int a6)
{
  uint64_t v9 = *(void *)(a1 + 48);
  v10.i64[0] = SLODWORD(a2);
  v10.i64[1] = SHIDWORD(a2);
  long long v11 = *(_OWORD *)(v9 + 16);
  _Q0 = vaddq_f64(*(float64x2_t *)(v9 + 32), vcvtq_f64_s64(v10));
  v20[0] = *(_OWORD *)v9;
  v20[1] = v11;
  v20[2] = _Q0;
  uint64_t v13 = a1 + 56;
  char v14 = (uint64_t (**)(void, void *, __n128, __n128))(a1 + 104);
  LOWORD(_Q0.f64[0]) = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  RB::Coverage::Stroke<RBStrokeRef>::get_info((uint64_t *)(a1 + 56), a4, (uint64_t)v21);
  RB::render_stroke((uint64_t)a4, (uint64_t (**)(void, void *, __n128, __n128))v20, v13, (uint64_t)v21, v14, a5, a6, _S8);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::render(uint64_t a1, uint64_t a2)
{
  float32x2_t v4 = *(float64x2_t **)(a1 + 48);
  BOOL v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v23, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v23[0].f64[0], *(int32x2_t *)&v23[0].f64[1]))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v23, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RBStrokeRef::clip(a1 + 64);
  v23[0] = (float64x2_t)xmmword_2142181C0;
  v23[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  float32x2_t v16 = RB::Coverage::Stroke<RBStrokeRef>::bounds((void *)(a1 + 56), v23, 1.0, (int32x4_t)xmmword_2142181D0);
  RB::Bounds::Bounds(v26, v16, v17);
  RB::Fill::Gradient::fill(a1 + 104, (RB::CGContext *)a2, *(double *)v26, *(double *)&v26[1], v18, v19, v20, v21, v22);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 104), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  float result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
  if (result == 8404993)
  {
    float result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      float result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        if (*(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a4 + 88)
          && *(unsigned __int8 *)(a1 + 89) == *(unsigned __int8 *)(a4 + 89)
          && *(unsigned __int8 *)(a1 + 90) == *(unsigned __int8 *)(a4 + 90)
          && *(unsigned __int8 *)(a1 + 91) == *(unsigned __int8 *)(a4 + 91)
          && *(unsigned __int8 *)(a1 + 92) == *(unsigned __int8 *)(a4 + 92)
          && *(float *)(a1 + 96) == *(float *)(a4 + 96))
        {
          float result = (unint64_t *)RBStrokeRef::can_mix((void *)(a1 + 64), (void *)(a4 + 64));
          if ((_BYTE)result)
          {
            unsigned __int8 v13 = result;
            unsigned __int8 can_mix = RB::Fill::Gradient::can_mix((uint64_t *)(a1 + 104), a4 + 104, v12);
            return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v13, can_mix);
          }
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v15[0] = v10;
  v15[1] = v11;
  v15[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v15);
  LODWORD(v13) = *(_DWORD *)(a2 + 16);
  RB::Fill::Gradient::mix((RB::Fill::Gradient *)(v8 + 104), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Gradient *)(a3 + 104), v13, (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16));
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  *(float *)(v8 + 96) = *(float *)(v8 + 96)
                      + (float)((float)(*(float *)(a3 + 96) - *(float *)(v8 + 96)) * *(float *)(a2 + 16));
  *(void *)(v8 + 72) = 0x100000001000000;
  *(int32x2_t *)(v8 + 80) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272)) {
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RBStrokeRef::prepare_encode(a1 + 8, (uint64_t)(a1 + 7), (uint64_t *)a2);
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::encode(void *a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RBStrokeRef>>(this, 1, (uint64_t)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::Gradient>(this, 2, (RB::Fill::Gradient *)(a1 + 13));
  float32x2_t v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::print(const RB::AffineTransform **a1, std::string *this)
{
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill8GradientEEEJRS0_RKS7_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 168 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0xA8uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 168;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  float result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  void *result = &unk_26C4E9AE8;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::GenericItem1(uint64_t a1, RB::Heap *a2, uint64_t a3, uint64_t *a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(void *)a1 = &unk_26C4EB288;
  *(void *)(a1 + 48) = a5;
  *(void *)(a1 + 56) = &unk_26C4EDD28;
  *(void *)(a1 + 64) = *(id *)(a3 + 8);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a3 + 16);
  *(unsigned char *)(a1 + 88) = *(unsigned char *)(a3 + 32);
  *(_WORD *)(a1 + 89) = *(_WORD *)(a3 + 33);
  *(unsigned char *)(a1 + 91) = *(unsigned char *)(a3 + 35);
  *(unsigned char *)(a1 + 92) = *(unsigned char *)(a3 + 36);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a3 + 40);
  RB::Fill::Gradient::Gradient((uint64_t *)(a1 + 104), a4, a7, a2);
  return a1;
}

void sub_214174E14(_Unwind_Exception *a1)
{
  *(void *)(v1 + 56) = v2;

  _Unwind_Resume(a1);
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16 = *((void *)this + 3);
  uint64_t v17 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 168 > v16) {
    uint64_t v17 = RB::Heap::alloc_slow((size_t *)this, 0xA8uLL, 7);
  }
  else {
    *((void *)this + 2) = v17 + 168;
  }
  float result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  void *result = &unk_26C4E9AE8;
  return result;
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16 = *((void *)this + 3);
  uint64_t v17 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 152 > v16) {
    uint64_t v17 = RB::Heap::alloc_slow((size_t *)this, 0x98uLL, 7);
  }
  else {
    *((void *)this + 2) = v17 + 152;
  }
  float result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  void *result = &unk_26C4E7620;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::GenericItem1(uint64_t a1, RB::Heap *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F | 0x4000;
  *(void *)a1 = &unk_26C4E7BD8;
  *(void *)(a1 + 48) = a5;
  *(void *)(a1 + 56) = &unk_26C4EDD28;
  *(void *)(a1 + 64) = *(id *)(a3 + 8);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a3 + 16);
  *(unsigned char *)(a1 + 88) = *(unsigned char *)(a3 + 32);
  *(_WORD *)(a1 + 89) = *(_WORD *)(a3 + 33);
  *(unsigned char *)(a1 + 91) = *(unsigned char *)(a3 + 35);
  *(unsigned char *)(a1 + 92) = *(unsigned char *)(a3 + 36);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a3 + 40);
  RB::Fill::MeshGradient::MeshGradient(a1 + 104, a4, a7, a2);
  return a1;
}

void sub_2141750A0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 56) = v2;

  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::~GenericItem(uint64_t a1)
{
  *(void *)a1 = &unk_26C4E7BD8;
  uint64_t v2 = *(atomic_uint **)(a1 + 112);
  if (v2 && atomic_fetch_add_explicit(v2 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  *(void *)(a1 + 56) = &unk_26C4EDD28;

  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::~GenericItem(uint64_t a1)
{
  *(void *)a1 = &unk_26C4E7BD8;
  uint64_t v2 = *(atomic_uint **)(a1 + 112);
  if (v2 && atomic_fetch_add_explicit(v2 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  *(void *)(a1 + 56) = &unk_26C4EDD28;

  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::type_id()
{
  return 20987905;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::copy(__n128 *a1, uint64_t a2, char a3)
{
  unsigned __int16 v4 = a1[2].n128_u16[7];
  if (*(unsigned char *)(a2 + 272)) {
    BOOL v5 = (a3 & 2 | v4 & 0x1000) == 0;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    __int16 v6 = 4096;
  }
  else {
    __int16 v6 = 0;
  }
  v7 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  int v10 = v4 & 0x3F;
  uint64_t v8 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill12MeshGradientEEEJRS0_RKS7_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v7, v7, (uint64_t)&a1[3].n128_i64[1], (uint64_t)&a1[6].n128_i64[1], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v10);
  __n128 result = a1[1];
  v8[1] = result;
  v8[2].n128_u64[0] = a1[2].n128_u64[0];
  v8[2].n128_u32[2] = a1[2].n128_u32[2];
  v8[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800 | v6;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::atom_position(uint64_t a1, double a2, int32x4_t a3)
{
  float32x2_t v3 = RB::Coverage::Stroke<RBStrokeRef>::bounds((void *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2, a3);
  return vmla_f32(v3, (float32x2_t)0x3F0000003F000000, v4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::can_make_clip()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::make_clip(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, float a5)
{
  float v24 = 0.0;
  unsigned int v25 = a3;
  if (RB::Fill::MeshGradient::get_alpha((RB::Fill::MeshGradient *)(a1 + 104), &v24))
  {
    long long v11 = (size_t *)(*(void *)(a2 + 8) + 16);
    _H0 = *(_WORD *)(a1 + 44);
    __asm { FCVT            S0, H0 }
    float v23 = _S0 * (float)(a5 * v24);
    uint64_t v18 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v11, (uint64_t)v11, a1 + 56, (int *)&v23, &v25, (uint64_t *)(a1 + 48));
    uint64_t v19 = a4[5];
    size_t v20 = v19 + 1;
    if (a4[6] < (unint64_t)(v19 + 1))
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v20);
      uint64_t v19 = a4[5];
      size_t v20 = v19 + 1;
    }
    int8x16_t v21 = (void *)a4[4];
    if (!v21) {
      int8x16_t v21 = a4;
    }
    v21[v19] = v18;
    a4[5] = v20;
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
  else
  {
    v10.n128_f32[0] = a5;
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, v10);
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 144);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::bounds(uint64_t a1, double a2, int32x4_t a3)
{
  return RB::Coverage::Stroke<RBStrokeRef>::bounds((void *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2, a3);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::min_scale(uint64_t a1)
{
  float result = 0.0;
  if (!*(unsigned char *)(a1 + 88) && *(unsigned char *)(a1 + 92) == 1) {
    return 1.0;
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

void **RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::prepare(void **result, uint64_t **a2)
{
  if (*((unsigned char *)result + 88) == 1) {
    return (void **)RBStrokeRef::prepare(result + 8, a2);
  }
  return result;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::render(uint64_t a1, double a2, uint64_t a3, uint64_t ***a4, char a5, int a6)
{
  uint64_t v9 = *(void *)(a1 + 48);
  v10.i64[0] = SLODWORD(a2);
  v10.i64[1] = SHIDWORD(a2);
  long long v11 = *(_OWORD *)(v9 + 16);
  _Q0 = vaddq_f64(*(float64x2_t *)(v9 + 32), vcvtq_f64_s64(v10));
  v20[0] = *(_OWORD *)v9;
  v20[1] = v11;
  v20[2] = _Q0;
  uint64_t v13 = a1 + 56;
  unint64_t v14 = (uint64_t (**)(void, void *, __n128, __n128))(a1 + 104);
  LOWORD(_Q0.f64[0]) = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  RB::Coverage::Stroke<RBStrokeRef>::get_info((uint64_t *)(a1 + 56), a4, (uint64_t)v21);
  RB::render_stroke(a4, (uint64_t (**)(void, void *, __n128, __n128))v20, v13, (uint64_t)v21, v14, a5, a6, _S8);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::render(int32x2_t *a1, uint64_t a2)
{
  float32x2_t v4 = (float64x2_t *)a1[6];
  BOOL v5 = (float32x2_t *)a1[3];
  _H0 = a1[5].i16[2];
  __asm { FCVT            S8, H0 }
  unsigned int v11 = a1[5].i16[3] & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(int32x2_t *, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v18, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v18[0].f64[0], *(int32x2_t *)&v18[0].f64[1]))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v18, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RBStrokeRef::clip(&a1[8]);
  v18[0] = (float64x2_t)xmmword_2142181C0;
  v18[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  float32x2_t v16 = RB::Coverage::Stroke<RBStrokeRef>::bounds(&a1[7], v18, 1.0, (int32x4_t)xmmword_2142181D0);
  RB::Bounds::Bounds(v21, v16, v17);
  RB::Fill::MeshGradient::fill(a1 + 13, (int8x8_t *)a2, v21[0], v21[1]);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 104), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  float result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
  if (result == 20987905)
  {
    float result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      float result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        if (*(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a4 + 88)
          && *(unsigned __int8 *)(a1 + 89) == *(unsigned __int8 *)(a4 + 89)
          && *(unsigned __int8 *)(a1 + 90) == *(unsigned __int8 *)(a4 + 90)
          && *(unsigned __int8 *)(a1 + 91) == *(unsigned __int8 *)(a4 + 91)
          && *(unsigned __int8 *)(a1 + 92) == *(unsigned __int8 *)(a4 + 92)
          && *(float *)(a1 + 96) == *(float *)(a4 + 96))
        {
          float result = (unint64_t *)RBStrokeRef::can_mix((void *)(a1 + 64), (void *)(a4 + 64));
          if ((_BYTE)result)
          {
            unsigned __int8 v13 = result;
            unsigned __int8 can_mix = RB::Fill::MeshGradient::can_mix((RB::Fill::MeshGradient *)(a1 + 104), (const RB::Fill::MeshGradient *)(a4 + 104), v12);
            return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v13, can_mix);
          }
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v15[0] = v10;
  v15[1] = v11;
  v15[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v15);
  LODWORD(v13) = *(_DWORD *)(a2 + 16);
  RB::Fill::MeshGradient::mix((RB::Fill::MeshGradient *)(v8 + 104), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::MeshGradient *)(a3 + 104), v13, (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16));
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  *(float *)(v8 + 96) = *(float *)(v8 + 96)
                      + (float)((float)(*(float *)(a3 + 96) - *(float *)(v8 + 96)) * *(float *)(a2 + 16));
  *(void *)(v8 + 72) = 0x100000001000000;
  *(int32x2_t *)(v8 + 80) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272)) {
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RBStrokeRef::prepare_encode(a1 + 8, (uint64_t)(a1 + 7), (uint64_t *)a2);
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::encode(void *a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RBStrokeRef>>(this, 1, (uint64_t)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::MeshGradient>(this, 2, (RB::Fill::MeshGradient *)(a1 + 13));
  float32x2_t v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::print(const RB::AffineTransform **a1, std::string *this)
{
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill12MeshGradientEEEJRS0_RKS7_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 152 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0x98uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 152;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  float result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  void *result = &unk_26C4E7620;
  return result;
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16 = *((void *)this + 3);
  uint64_t v17 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 200 > v16) {
    uint64_t v17 = RB::Heap::alloc_slow((size_t *)this, 0xC8uLL, 7);
  }
  else {
    *((void *)this + 2) = v17 + 200;
  }
  float result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  void *result = &unk_26C4E98B8;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(uint64_t a1, RB::Heap *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(void *)a1 = &unk_26C4EB058;
  *(void *)(a1 + 48) = a5;
  *(void *)(a1 + 56) = &unk_26C4EDD28;
  *(void *)(a1 + 64) = *(id *)(a3 + 8);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a3 + 16);
  *(unsigned char *)(a1 + 88) = *(unsigned char *)(a3 + 32);
  *(_WORD *)(a1 + 89) = *(_WORD *)(a3 + 33);
  *(unsigned char *)(a1 + 91) = *(unsigned char *)(a3 + 35);
  *(unsigned char *)(a1 + 92) = *(unsigned char *)(a3 + 36);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a3 + 40);
  RB::ImageTexture::ImageTexture((RB::ImageTexture *)(a1 + 104), a4, a2);
  long long v18 = *((_OWORD *)a4 + 2);
  long long v19 = *((_OWORD *)a4 + 3);
  long long v20 = *((_OWORD *)a4 + 4);
  *(_OWORD *)(a1 + 184) = *((_OWORD *)a4 + 5);
  *(_OWORD *)(a1 + 120) = *((_OWORD *)a4 + 1);
  *(_OWORD *)(a1 + 168) = v20;
  *(_OWORD *)(a1 + 152) = v19;
  *(_OWORD *)(a1 + 136) = v18;
  if (!*(unsigned char *)(a1 + 197)) {
    *(_WORD *)(a1 + 196) = a7;
  }
  return a1;
}

void sub_214175E10(_Unwind_Exception *a1)
{
  *(void *)(v1 + 56) = v2;

  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::~GenericItem(uint64_t a1)
{
  *(void *)a1 = &unk_26C4EB058;
  *(void *)(a1 + 56) = &unk_26C4EDD28;

  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::~GenericItem(uint64_t a1)
{
  *(void *)a1 = &unk_26C4EB058;
  *(void *)(a1 + 56) = &unk_26C4EDD28;

  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::type_id()
{
  return 12599297;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::copy(__n128 *a1, uint64_t a2, char a3)
{
  unsigned __int16 v4 = a1[2].n128_u16[7];
  if (*(unsigned char *)(a2 + 272)) {
    BOOL v5 = (a3 & 2 | v4 & 0x1000) == 0;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    __int16 v6 = 4096;
  }
  else {
    __int16 v6 = 0;
  }
  v7 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  int v10 = v4 & 0x3F;
  uint64_t v8 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS7_RKSB_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v7, v7, (uint64_t)&a1[3].n128_i64[1], (const RB::ImageTexture *)&a1[6].n128_i8[8], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v10);
  __n128 result = a1[1];
  v8[1] = result;
  v8[2].n128_u64[0] = a1[2].n128_u64[0];
  v8[2].n128_u32[2] = a1[2].n128_u32[2];
  v8[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800 | v6;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::atom_position(uint64_t a1, double a2, int32x4_t a3)
{
  float32x2_t v3 = RB::Coverage::Stroke<RBStrokeRef>::bounds((void *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2, a3);
  return vmla_f32(v3, (float32x2_t)0x3F0000003F000000, v4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::make_clip(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, __n128 a5)
{
  unsigned int v20 = a3;
  if (*(unsigned char *)(a1 + 116))
  {
    v7 = (size_t *)(*(void *)(a2 + 8) + 16);
    _H1 = *(_WORD *)(a1 + 44);
    __asm { FCVT            S1, H1 }
    float v19 = _S1 * a5.n128_f32[0];
    uint64_t v14 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v7, (uint64_t)v7, a1 + 56, (int *)&v19, &v20, (uint64_t *)(a1 + 48));
    uint64_t v15 = a4[5];
    size_t v16 = v15 + 1;
    if (a4[6] < (unint64_t)(v15 + 1))
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v16);
      uint64_t v15 = a4[5];
      size_t v16 = v15 + 1;
    }
    uint64_t v17 = (void *)a4[4];
    if (!v17) {
      uint64_t v17 = a4;
    }
    v17[v15] = v14;
    a4[5] = v16;
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
  else
  {
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::can_append_color_matrix(int a1, float16x4_t *a2, char a3, __int16 a4)
{
  return RB::Fill::ImageData::can_append_color_matrix(a1 + 120, a2, a3, a4);
}

float16x4_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::append_color_matrix(uint64_t a1, RB::ColorMatrix *a2, int a3)
{
  return RB::Fill::ImageData::append_color_matrix(a1 + 120, a2, a3);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 117);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::bounds(uint64_t a1, double a2, int32x4_t a3)
{
  return RB::Coverage::Stroke<RBStrokeRef>::bounds((void *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::min_scale(uint64_t a1)
{
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::prepare(uint64_t a1, uint64_t **a2)
{
  if (*(unsigned char *)(a1 + 88) == 1) {
    RBStrokeRef::prepare((void **)(a1 + 64), a2);
  }
  float32x2_t v4 = *(float64x2_t **)(a1 + 48);
  return RB::ImageTexture::prepare(a1 + 104, a2, (const RB::Fill::ImageData *)(a1 + 120), v4, 0);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  int v10 = *(float64x2_t **)(a1 + 48);
  v11.i64[0] = SLODWORD(a2);
  v11.i64[1] = SHIDWORD(a2);
  float64x2_t v12 = v10[1];
  _Q0 = vaddq_f64(v10[2], vcvtq_f64_s64(v11));
  v21[0] = *v10;
  v21[1] = v12;
  int32x2_t v21[2] = _Q0;
  uint64_t v14 = a1 + 56;
  uint64_t v15 = a1 + 104;
  LOWORD(_Q0.f64[0]) = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  RB::Coverage::Stroke<RBStrokeRef>::get_info((uint64_t *)(a1 + 56), (uint64_t ***)a4, (uint64_t)v24);
  RB::Fill::Image<RB::ImageTexture>::set_image(v15, (uint64_t)&v23, (uint64_t ***)a4, v21, _S8);
  RB::render_stroke(a4, v21, v14, (uint64_t)v24, &v22, a1 + 120, a5, a6);
  *(_DWORD *)(a4 + 232) = 0;
  *(unsigned char *)(a4 + 236) = 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::render(uint64_t a1, uint64_t a2)
{
  float32x2_t v4 = *(float64x2_t **)(a1 + 48);
  BOOL v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v20, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) == v5)
  {
    if (RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v20[0].f64[0], *(int32x2_t *)&v20[0].f64[1]))
    {
      int v14 = 1;
      if (*(float64x2_t **)(a2 + 80) == v4 && *(float *)(a2 + 132) == _S8 && *(_DWORD *)(a2 + 136) == v11) {
        goto LABEL_11;
      }
    }
    else
    {
      int v14 = 0;
    }
  }
  RB::CGContext::update_state_slow(a2, v4, v5, v11, v20, v14, _S8);
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RBStrokeRef::clip(a1 + 64);
  v20[0] = (float64x2_t)xmmword_2142181C0;
  v20[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  float32x2_t v16 = RB::Coverage::Stroke<RBStrokeRef>::bounds((void *)(a1 + 56), v20, 1.0, (int32x4_t)xmmword_2142181D0);
  RB::Bounds::Bounds((int32x2_t *)&v23, v16, v17);
  uint16x4_t v18 = v23;
  float v19 = (RB *)RB::ImageTexture::cg_image((RB::ImageTexture *)(a1 + 104));
  if (v19) {
    RB::Fill::ImageData::fill((void *)(a1 + 120), a2, v19, v18);
  }
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::ImageData::matches((RB::Fill::ImageData *)(a1 + 120), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3, uint32x4_t a4)
{
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  __n128 result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
  if (result == 12599297)
  {
    __n128 result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      __n128 result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        if (*(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a4 + 88)
          && *(unsigned __int8 *)(a1 + 89) == *(unsigned __int8 *)(a4 + 89)
          && *(unsigned __int8 *)(a1 + 90) == *(unsigned __int8 *)(a4 + 90)
          && *(unsigned __int8 *)(a1 + 91) == *(unsigned __int8 *)(a4 + 91)
          && *(unsigned __int8 *)(a1 + 92) == *(unsigned __int8 *)(a4 + 92)
          && *(float *)(a1 + 96) == *(float *)(a4 + 96))
        {
          __n128 result = (unint64_t *)RBStrokeRef::can_mix((void *)(a1 + 64), (void *)(a4 + 64));
          if ((_BYTE)result)
          {
            unsigned __int8 v12 = result;
            unsigned __int8 can_mix = RB::ImageTexture::can_mix((RB::ImageTexture *)(a1 + 104), (const RB::ImageTexture *)(a4 + 104));
            if (can_mix)
            {
              unsigned __int8 v14 = can_mix;
              unsigned int v15 = RB::Fill::ImageData::can_mix((float32x2_t *)(a1 + 120), (float32x2_t *)(a4 + 120));
              if (v15 >= v14) {
                unsigned __int8 v16 = v14;
              }
              else {
                unsigned __int8 v16 = v15;
              }
            }
            else
            {
              unsigned __int8 v16 = 0;
            }
            return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v12, v16);
          }
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v14[0] = v10;
  v14[1] = v11;
  v14[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v14);
  RB::Fill::ImageData::mix((float32x4_t *)(v8 + 120), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (float32x4_t *)(a3 + 120), *(float *)(a2 + 16));
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  *(float *)(v8 + 96) = *(float *)(v8 + 96)
                      + (float)((float)(*(float *)(a3 + 96) - *(float *)(v8 + 96)) * *(float *)(a2 + 16));
  *(void *)(v8 + 72) = 0x100000001000000;
  *(int32x2_t *)(v8 + 80) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272)) {
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::prepare_encode(uint64_t a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode((uint64_t *)a1, a2);
  RBStrokeRef::prepare_encode((uint64_t *)(a1 + 64), a1 + 56, (uint64_t *)a2);
  return RB::ImageTexture::prepare_encode((uint64_t **)(a1 + 104), a2);
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::encode(RB::DisplayList::Item *a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RBStrokeRef>>(this, 1, (uint64_t)a1 + 56);
  RB::Encoder::typed_message_field<RB::Fill::Image<RB::ImageTexture>>(this, 2, (uint64_t)a1 + 104);
  float32x2_t v4 = (float64x2_t *)*((void *)a1 + 6);
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode(a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::print(const RB::AffineTransform **a1, std::string *this)
{
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS7_RKSB_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 200 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0xC8uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 200;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  void *result = &unk_26C4E98B8;
  return result;
}

void *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 320 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0x140uLL, 15);
  }
  else {
    *((void *)this + 2) = v15 + 320;
  }
  __n128 result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::GenericItem1(v15, *a6, a2, a3, a4, *a5, *a7);
  void *result = &unk_26C4E99D0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::GenericItem1(uint64_t a1, float _S0, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a7 & 0x3F;
  *(void *)a1 = &unk_26C4EB170;
  *(void *)(a1 + 48) = a6;
  *(void *)(a1 + 56) = &unk_26C4EDD28;
  *(void *)(a1 + 64) = *(id *)(a4 + 8);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a4 + 16);
  *(unsigned char *)(a1 + 88) = *(unsigned char *)(a4 + 32);
  *(_WORD *)(a1 + 89) = *(_WORD *)(a4 + 33);
  *(unsigned char *)(a1 + 91) = *(unsigned char *)(a4 + 35);
  *(unsigned char *)(a1 + 92) = *(unsigned char *)(a4 + 36);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a4 + 40);
  RB::Fill::Custom::Custom((RB::CustomShader::Closure *)(a1 + 112), a5);
  return a1;
}

void sub_214176BA4(_Unwind_Exception *a1)
{
  *(void *)(v1 + 56) = v2;

  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::~GenericItem(uint64_t a1)
{
  *(void *)a1 = &unk_26C4EB170;
  uint64_t v2 = (const void **)(a1 + 120);
  float32x2_t v3 = *(const void ***)(a1 + 216);
  if (v3) {
    float32x2_t v4 = v3;
  }
  else {
    float32x2_t v4 = v2;
  }
  if (*(void *)(a1 + 224))
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < *(void *)(a1 + 224));
    float32x2_t v3 = *(const void ***)(a1 + 216);
  }
  if (v3) {
    free(v3);
  }
  __int16 v6 = *(atomic_uint **)(a1 + 112);
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  *(void *)(a1 + 56) = &unk_26C4EDD28;

  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::~GenericItem(uint64_t a1)
{
  *(void *)a1 = &unk_26C4EB170;
  uint64_t v2 = (const void **)(a1 + 120);
  float32x2_t v3 = *(const void ***)(a1 + 216);
  if (v3) {
    float32x2_t v4 = v3;
  }
  else {
    float32x2_t v4 = v2;
  }
  if (*(void *)(a1 + 224))
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < *(void *)(a1 + 224));
    float32x2_t v3 = *(const void ***)(a1 + 216);
  }
  if (v3) {
    free(v3);
  }
  __int16 v6 = *(atomic_uint **)(a1 + 112);
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  *(void *)(a1 + 56) = &unk_26C4EDD28;

  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::type_id()
{
  return 16793601;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::copy(__n128 *a1, uint64_t a2, char a3)
{
  unsigned __int16 v4 = a1[2].n128_u16[7];
  if (*(unsigned char *)(a2 + 272)) {
    BOOL v5 = (a3 & 2 | v4 & 0x1000) == 0;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    __int16 v6 = 4096;
  }
  else {
    __int16 v6 = 0;
  }
  v7 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
  int v10 = v4 & 0x3F;
  uint64_t v8 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill6CustomEEEJRS0_RKS7_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v7, (uint64_t)v7, (uint64_t)&a1[3].n128_i64[1], (uint64_t)&a1[7], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v10);
  __n128 result = a1[1];
  v8[1] = result;
  v8[2].n128_u64[0] = a1[2].n128_u64[0];
  v8[2].n128_u32[2] = a1[2].n128_u32[2];
  v8[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800 | v6;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::atom_position(uint64_t a1, double a2, int32x4_t a3)
{
  float32x2_t v3 = RB::Coverage::Stroke<RBStrokeRef>::bounds((void *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2, a3);
  return vmla_f32(v3, (float32x2_t)0x3F0000003F000000, v4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::can_append_color_matrix()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::required_depth()
{
  return 0;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::bounds(uint64_t a1, double a2, int32x4_t a3)
{
  return RB::Coverage::Stroke<RBStrokeRef>::bounds((void *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2, a3);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::min_scale(uint64_t a1)
{
  float result = 0.0;
  if (!*(unsigned char *)(a1 + 88) && *(unsigned char *)(a1 + 92) == 1) {
    return 1.0;
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::has_no_effect(uint64_t a1)
{
  __asm { FCMP            H0, #0 }
  if (_ZF) {
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  }
  else {
    return 0;
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::prepare(uint64_t a1, uint64_t **a2)
{
  if (*(unsigned char *)(a1 + 88) == 1) {
    RBStrokeRef::prepare((void **)(a1 + 64), a2);
  }
  float32x2_t v4 = *(const RB::AffineTransform **)(a1 + 48);
  return RB::Fill::Custom::prepare((RB::Fill::Custom *)(a1 + 112), (const RB::RenderParams *)a2, v4);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::render(uint64_t a1, double a2, uint64_t a3, uint64_t ***a4, int a5, int a6)
{
  uint64_t v9 = *(void *)(a1 + 48);
  v10.i64[0] = SLODWORD(a2);
  v10.i64[1] = SHIDWORD(a2);
  long long v11 = *(_OWORD *)(v9 + 16);
  _Q0 = vaddq_f64(*(float64x2_t *)(v9 + 32), vcvtq_f64_s64(v10));
  v20[0] = *(_OWORD *)v9;
  v20[1] = v11;
  float64x2_t v20[2] = _Q0;
  uint64_t v13 = a1 + 56;
  unint64_t v14 = (RB::Fill::Custom *)(a1 + 112);
  LOWORD(_Q0.f64[0]) = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  RB::Coverage::Stroke<RBStrokeRef>::get_info((uint64_t *)(a1 + 56), a4, (uint64_t)v21);
  RB::render_stroke((uint64_t **)a4, (uint64_t (**)(void, void *, __n128, __n128))v20, v13, (uint64_t)v21, v14, a5, a6, _S8);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::render(uint64_t a1, uint64_t a2)
{
  float32x2_t v4 = *(float64x2_t **)(a1 + 48);
  BOOL v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  unsigned int v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&float32x2_t v12 = (*(double (**)(uint64_t, void))(*(void *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v18, v12, v13);
  int v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v18[0].f64[0], *(int32x2_t *)&v18[0].f64[1]))
  {
    int v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v18, v14, _S8);
    goto LABEL_11;
  }
  int v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4) {
    goto LABEL_10;
  }
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11) {
    goto LABEL_10;
  }
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RBStrokeRef::clip(a1 + 64);
  v18[0] = (float64x2_t)xmmword_2142181C0;
  v18[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  float32x2_t v16 = RB::Coverage::Stroke<RBStrokeRef>::bounds((void *)(a1 + 56), v18, 1.0, (int32x4_t)xmmword_2142181D0);
  RB::Bounds::Bounds(&v21, v16, v17);
  RBStrokeRef::clip(a1 + 112);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 112), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  float result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
  if (result == 16793601)
  {
    float result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      float result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      int v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        if (*(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a4 + 88)
          && *(unsigned __int8 *)(a1 + 89) == *(unsigned __int8 *)(a4 + 89)
          && *(unsigned __int8 *)(a1 + 90) == *(unsigned __int8 *)(a4 + 90)
          && *(unsigned __int8 *)(a1 + 91) == *(unsigned __int8 *)(a4 + 91)
          && *(unsigned __int8 *)(a1 + 92) == *(unsigned __int8 *)(a4 + 92)
          && *(float *)(a1 + 96) == *(float *)(a4 + 96))
        {
          float result = (unint64_t *)RBStrokeRef::can_mix((void *)(a1 + 64), (void *)(a4 + 64));
          if ((_BYTE)result)
          {
            unsigned __int8 v12 = result;
            unsigned __int8 can_mix = RB::Fill::Custom::can_mix((RB::Fill::Custom *)(a1 + 112), (const RB::Fill::Custom *)(a4 + 112));
            return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v12, can_mix);
          }
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(CGAffineTransform **, void, void, void, uint64_t))&(*a1)[1].a)(a1, *(void *)&a4->f64[0], *(unsigned int *)(*(void *)(a2 + 8) + 12), **(void **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v14[0] = v10;
  v14[1] = v11;
  v14[2] = v12;
  *(void *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v14);
  RB::Fill::Custom::mix((RB::Fill::Custom *)(v8 + 112), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Custom *)(a3 + 112), *(float *)(a2 + 16), (RB::Heap *)(*(void *)(*(void *)&a4->f64[0] + 8) + 16));
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  *(float *)(v8 + 96) = *(float *)(v8 + 96)
                      + (float)((float)(*(float *)(a3 + 96) - *(float *)(v8 + 96)) * *(float *)(a2 + 16));
  *(void *)(v8 + 72) = 0x100000001000000;
  *(int32x2_t *)(v8 + 80) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(unsigned char *)(*(void *)&a4->f64[0] + 272)) {
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  RBStrokeRef::prepare_encode(a1 + 8, (uint64_t)(a1 + 7), (uint64_t *)a2);
  return RB::Fill::Custom::prepare_encode((RB::Fill::Custom *)(a1 + 14), a2);
}

void *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::encode(void *a1, RB::ProtobufEncoder *this)
{
  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RBStrokeRef>>(this, 1, (uint64_t)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::Custom>(this, 2, (RB::Fill::Custom *)(a1 + 14));
  float32x2_t v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::print(const RB::AffineTransform **a1, std::string *this)
{
}

void *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill6CustomEEEJRS0_RKS7_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 320 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0x140uLL, 15);
  }
  else {
    *((void *)this + 2) = v15 + 320;
  }
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  float result = (void *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::GenericItem1(v15, _S0, a2, a3, a4, *a5, *a7);
  void *result = &unk_26C4E99D0;
  return result;
}

__n128 RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>,RB::GeometryStyle::Rotation>(RB::Heap *this, __n128 *a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 72 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 72;
  }
  *(void *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4ECB30;
  __n128 result = *a2;
  *(__n128 *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::~GeometryMatrixStyle()
{
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::type_id()
{
  return 4102;
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::copy(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>,RB::GeometryStyle::Rotation>((RB::Heap *)(*(void *)(a2 + 8) + 16), (__n128 *)(a1 + 56)).n128_u64[0];
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  *((void *)a4 + 2) = *(void *)(a1 + 32);
  v11[0] = (float64x2_t)xmmword_2142181C0;
  v11[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  RB::GeometryStyle::Rotation::set_affine_transform((RB::GeometryStyle::Rotation *)(a1 + 56), v11);
  return RB::DisplayList::Builder::affine_style_draw(a2, a3, a4, a5, v11, *(const RB::AffineTransform **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::bounds(float64x2_t **a1, const RB::DisplayList::Style *a2, const RB::DisplayList::Item *a3)
{
  v8[0] = (float64x2_t)xmmword_2142181C0;
  v8[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  RB::GeometryStyle::Rotation::set_affine_transform((RB::GeometryStyle::Rotation *)(a1 + 7), v8);
  return RB::DisplayList::affine_style_bounds(a1, a2, a3, v8, v6);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::map_roi(uint64_t a1, RB::DisplayList *a2, float64x2_t *a3)
{
  v7[0] = (float64x2_t)xmmword_2142181C0;
  v7[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  RB::GeometryStyle::Rotation::set_affine_transform((RB::GeometryStyle::Rotation *)(a1 + 56), v7);
  RB::DisplayList::affine_style_roi(a2, a3, v7, *(int8x16_t **)(a1 + 16), v6);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3
    && *(double *)(a1 + 56) == *(double *)(a3 + 56)
    && (uint32x2_t v3 = (uint32x2_t)vceq_f32(*(float32x2_t *)(a1 + 64), *(float32x2_t *)(a3 + 64)),
        (vpmin_u32(v3, v3).u32[0] & 0x80000000) != 0))
  {
    return 4;
  }
  else
  {
    return 1;
  }
}

float32x2_t *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 v6 = RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>,RB::GeometryStyle::Rotation>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), (__n128 *)(a1 + 56));
  uint64_t v8 = v7;
  uint64_t v9 = v7 + 7;
  if (a3) {
    uint64_t v10 = (const RB::GeometryStyle::Rotation *)(a3 + 56);
  }
  else {
    uint64_t v10 = 0;
  }
  v6.n128_u32[0] = *(_DWORD *)(a2 + 16);
  RB::GeometryStyle::Rotation::mix(v9, v10, v6.n128_f64[0]);
  return v8;
}

void *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::encode(void *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x6AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::GeometryStyle::Rotation::encode((RB::GeometryStyle::Rotation *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "geometry");
  RB::GeometryStyle::Rotation::print((RB::GeometryStyle::Rotation *)(a1 + 7), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

__n128 RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>,RB::GeometryStyle::Scale>(RB::Heap *this, __n128 *a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 72 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 72;
  }
  *(void *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4ECAA8;
  __n128 result = *a2;
  *(__n128 *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::~GeometryMatrixStyle()
{
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::type_id()
{
  return 8198;
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::copy(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>,RB::GeometryStyle::Scale>((RB::Heap *)(*(void *)(a2 + 8) + 16), (__n128 *)(a1 + 56)).n128_u64[0];
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  *((void *)a4 + 2) = *(void *)(a1 + 32);
  v11[0] = (float64x2_t)xmmword_2142181C0;
  v11[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  RB::GeometryStyle::Scale::set_affine_transform((float32x2_t *)(a1 + 56), v11);
  return RB::DisplayList::Builder::affine_style_draw(a2, a3, a4, a5, v11, *(const RB::AffineTransform **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::bounds(uint64_t a1, const RB::DisplayList::Style *a2, const RB::DisplayList::Item *a3)
{
  v8[0] = (float64x2_t)xmmword_2142181C0;
  v8[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  RB::GeometryStyle::Scale::set_affine_transform((float32x2_t *)(a1 + 56), v8);
  return RB::DisplayList::affine_style_bounds((float64x2_t **)a1, a2, a3, v8, v6);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::map_roi(uint64_t a1, RB::DisplayList *a2, float64x2_t *a3)
{
  v7[0] = (float64x2_t)xmmword_2142181C0;
  v7[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  RB::GeometryStyle::Scale::set_affine_transform((float32x2_t *)(a1 + 56), v7);
  RB::DisplayList::affine_style_roi(a2, a3, v7, *(int8x16_t **)(a1 + 16), v6);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::can_mix(float32x2_t *a1, uint64_t a2, float32x2_t *a3)
{
  if (a3
    && (uint32x2_t v3 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(a1[8], a3[8]), (int8x8_t)vceq_f32(a1[7], a3[7])),
        (vpmin_u32(v3, v3).u32[0] & 0x80000000) != 0))
  {
    return 4;
  }
  else
  {
    return 1;
  }
}

float32x2_t *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::mix(uint64_t a1, uint64_t a2, float32x2_t *a3, uint64_t a4)
{
  RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>,RB::GeometryStyle::Scale>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), (__n128 *)(a1 + 56));
  v7 = v6;
  uint64_t v8 = v6 + 7;
  if (a3) {
    uint64_t v9 = a3 + 7;
  }
  else {
    uint64_t v9 = 0;
  }
  RB::GeometryStyle::Scale::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

void *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::encode(void *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x6AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::GeometryStyle::Scale::encode((RB::GeometryStyle::Scale *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "geometry");
  RB::GeometryStyle::Scale::print((RB::GeometryStyle::Scale *)(a1 + 7), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

double RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>,RB::GeometryStyle::Translation>(RB::Heap *this, void *a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 64;
  }
  *(void *)(v5 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4E8600;
  *(void *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::~GeometryMatrixStyle()
{
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::type_id()
{
  return 16390;
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>,RB::GeometryStyle::Translation>((RB::Heap *)(*(void *)(a2 + 8) + 16), (void *)(a1 + 56));
}

RB::DisplayList::Builder *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  *((void *)a4 + 2) = *(void *)(a1 + 32);
  v11[0] = (float64x2_t)xmmword_2142181C0;
  v11[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  RB::GeometryStyle::Translation::set_affine_transform((float32x2_t *)(a1 + 56), (RB::AffineTransform *)v11);
  return RB::DisplayList::Builder::affine_style_draw(a2, a3, a4, a5, v11, *(const RB::AffineTransform **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::bounds(uint64_t a1, const RB::DisplayList::Style *a2, const RB::DisplayList::Item *a3)
{
  v8[0] = (float64x2_t)xmmword_2142181C0;
  v8[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  RB::GeometryStyle::Translation::set_affine_transform((float32x2_t *)(a1 + 56), (RB::AffineTransform *)v8);
  return RB::DisplayList::affine_style_bounds((float64x2_t **)a1, a2, a3, v8, v6);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::map_roi(uint64_t a1, RB::DisplayList *a2, float64x2_t *a3)
{
  v7[0] = (float64x2_t)xmmword_2142181C0;
  v7[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  RB::GeometryStyle::Translation::set_affine_transform((float32x2_t *)(a1 + 56), (RB::AffineTransform *)v7);
  RB::DisplayList::affine_style_roi(a2, a3, v7, *(int8x16_t **)(a1 + 16), v6);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::can_mix(float32x2_t *a1, uint64_t a2, float32x2_t *a3)
{
  if (a3 && (uint32x2_t v3 = (uint32x2_t)vceq_f32(a1[7], a3[7]), (vpmin_u32(v3, v3).u32[0] & 0x80000000) != 0)) {
    return 4;
  }
  else {
    return 1;
  }
}

float32x2_t *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::mix(uint64_t a1, uint64_t a2, float32x2_t *a3, uint64_t a4)
{
  RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>,RB::GeometryStyle::Translation>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), (void *)(a1 + 56));
  v7 = v6;
  uint64_t v8 = v6 + 7;
  if (a3) {
    uint64_t v9 = a3 + 7;
  }
  else {
    uint64_t v9 = 0;
  }
  RB::GeometryStyle::Translation::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

void *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::encode(void *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x6AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x22uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::GeometryStyle::Translation::encode((RB::GeometryStyle::Translation *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "geometry");
  RB::GeometryStyle::Translation::print((RB::GeometryStyle::Translation *)(a1 + 7), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

__n128 RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>,RB::GeometryStyle::Rotation3D>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 128 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x80uLL, 15);
  }
  else {
    *((void *)this + 2) = v5 + 128;
  }
  *(void *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4ECA20;
  __n128 result = *(__n128 *)a2;
  long long v7 = *(_OWORD *)(a2 + 16);
  long long v8 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v5 + 96) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 112) = v8;
  *(__n128 *)(v5 + 64) = result;
  *(_OWORD *)(v5 + 80) = v7;
  return result;
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::~GeometryMatrixStyle()
{
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::type_id()
{
  return 12294;
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::copy(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>,RB::GeometryStyle::Rotation3D>((RB::Heap *)(*(void *)(a2 + 8) + 16), a1 + 64).n128_u64[0];
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::draw(uint64_t a1, size_t **a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  *((void *)a4 + 2) = *(void *)(a1 + 32);
  int v12 = 1065353216;
  v11[0] = (float32x4_t)xmmword_214218320;
  v11[1] = (float32x4_t)xmmword_214218320;
  RB::GeometryStyle::Rotation3D::set_projection_matrix((RB::GeometryStyle::Rotation3D *)(a1 + 64), v11);
  return RB::DisplayList::Builder::projection_style_draw(a2, a3, a4, a5, (const RB::ProjectionMatrix *)v11, *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::bounds(float64x2_t **a1, const RB::DisplayList::Style *a2, const RB::DisplayList::Item *a3)
{
  int v9 = 1065353216;
  v8[0] = (float32x4_t)xmmword_214218320;
  v8[1] = (float32x4_t)xmmword_214218320;
  RB::GeometryStyle::Rotation3D::set_projection_matrix((RB::GeometryStyle::Rotation3D *)(a1 + 8), v8);
  return RB::DisplayList::projection_style_bounds(a1, a2, a3, (uint64_t)v8, v6);
}

float32x2_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::map_roi(uint64_t a1, float32x2_t *a2, float64x2_t *a3)
{
  int v9 = 1065353216;
  v8[0] = (float32x4_t)xmmword_214218320;
  v8[1] = (float32x4_t)xmmword_214218320;
  RB::GeometryStyle::Rotation3D::set_projection_matrix((RB::GeometryStyle::Rotation3D *)(a1 + 64), v8);
  return RB::DisplayList::projection_style_roi(a2, a3, (RB::AffineTransform *)v8, *(float64x2_t **)(a1 + 16), v6);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && RB::GeometryStyle::Rotation3D::operator==(a1 + 64, a3 + 64)) {
    return 4;
  }
  if (a3) {
    __n128 v6 = (const RB::GeometryStyle::Rotation3D *)(a3 + 64);
  }
  else {
    __n128 v6 = 0;
  }
  return RB::GeometryStyle::Rotation3D::can_mix((RB::GeometryStyle::Rotation3D *)(a1 + 64), v6);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::mix(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4)
{
  __n128 v6 = RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>,RB::GeometryStyle::Rotation3D>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), a1 + 64);
  uint64_t v8 = v7;
  int v9 = (RB::GeometryStyle::Rotation3D *)(v7 + 64);
  if (a3) {
    uint64_t v10 = a3 + 4;
  }
  else {
    uint64_t v10 = 0;
  }
  v6.n128_u32[0] = *(_DWORD *)(a2 + 16);
  RB::GeometryStyle::Rotation3D::mix(v9, v10, v6.n128_f64[0]);
  return v8;
}

void *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::encode(float32x4_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x6AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::GeometryStyle::Rotation3D::encode(a1 + 4, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "geometry");
  RB::GeometryStyle::Rotation3D::print((RB::GeometryStyle::Rotation3D *)(a1 + 8), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

__n128 RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>,RB::GeometryStyle::Affine>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 112 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x70uLL, 15);
  }
  else {
    *((void *)this + 2) = v5 + 112;
  }
  *(void *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4E8688;
  __n128 result = *(__n128 *)a2;
  long long v7 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 80) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v5 + 96) = v7;
  *(__n128 *)(v5 + 64) = result;
  return result;
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::~GeometryMatrixStyle()
{
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::type_id()
{
  return 20486;
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::copy(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>,RB::GeometryStyle::Affine>((RB::Heap *)(*(void *)(a2 + 8) + 16), a1 + 64).n128_u64[0];
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::draw(uint64_t a1, RB::DisplayList::Builder *this, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  *((void *)a4 + 2) = *(void *)(a1 + 32);
  float64x2_t v5 = *(float64x2_t *)(a1 + 80);
  v7[0] = *(float64x2_t *)(a1 + 64);
  v7[1] = v5;
  float64x2_t v7[2] = *(float64x2_t *)(a1 + 96);
  return RB::DisplayList::Builder::affine_style_draw(this, a3, a4, a5, v7, *(const RB::AffineTransform **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::bounds(uint64_t a1, const RB::DisplayList::Style *a2, const RB::DisplayList::Item *a3, uint64_t a4, const RB::AffineTransform *a5)
{
  float64x2_t v5 = *(float64x2_t *)(a1 + 80);
  v7[0] = *(float64x2_t *)(a1 + 64);
  v7[1] = v5;
  float64x2_t v7[2] = *(float64x2_t *)(a1 + 96);
  return RB::DisplayList::affine_style_bounds((float64x2_t **)a1, a2, a3, v7, a5);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::map_roi(uint64_t a1, RB::DisplayList *this, float64x2_t *a3, uint64_t a4, const RB::AffineTransform *a5)
{
  float64x2_t v5 = *(float64x2_t *)(a1 + 80);
  v6[0] = *(float64x2_t *)(a1 + 64);
  v6[1] = v5;
  v6[2] = *(float64x2_t *)(a1 + 96);
  RB::DisplayList::affine_style_roi(this, a3, v6, *(int8x16_t **)(a1 + 16), a5);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::can_mix(float64x2_t *a1, uint64_t a2, float64x2_t *a3)
{
  if (a3)
  {
    int64x2_t v3 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a1[5], a3[5]), (int8x16_t)vceqq_f64(a1[4], a3[4])), (int8x16_t)vceqq_f64(a1[6], a3[6]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v3, 1), (int8x16_t)v3).u64[0] & 0x8000000000000000) != 0) {
      return 4;
    }
  }
  unint64_t v4 = (RB *)&a1[4];
  if (a3) {
    float64x2_t v5 = (const RB::AffineTransform *)&a3[4];
  }
  else {
    float64x2_t v5 = 0;
  }
  return RB::GeometryStyle::Affine::can_mix(v4, v5, (const RB::AffineTransform *)a3);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>,RB::GeometryStyle::Affine>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), a1 + 64);
  uint64_t v8 = v7;
  int v9 = (CGAffineTransform *)(v7 + 64);
  if (a3) {
    uint64_t v10 = a3 + 64;
  }
  else {
    uint64_t v10 = 0;
  }
  RB::GeometryStyle::Affine::mix(v9, v10, v6, *(float *)(a2 + 16));
  return v8;
}

void *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::encode(void *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x6AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x2AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::GeometryStyle::Affine::encode((RB::GeometryStyle::Affine *)(a1 + 8), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "geometry");
  RB::GeometryStyle::Affine::print((RB::GeometryStyle::Affine *)(a1 + 8), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

__n128 RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 96 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x60uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 96;
  }
  *(void *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4E8A50;
  __n128 result = *(__n128 *)a2;
  *(_OWORD *)(v5 + 68) = *(_OWORD *)(a2 + 12);
  *(__n128 *)(v5 + 56) = result;
  uint64_t v7 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  *(void *)(v5 + 88) = v7;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::MeshGradient>(long long **a1, uint64_t a2)
{
  int64x2_t v3 = *a1;
  unint64_t result = *((void *)*a1 + 7);
  if (!result)
  {
    unint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(size_t **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)v3 + 1, (int *)v3 + 4, (__int16 *)v3 + 10, (__int16 *)v3 + 12);
    int64x2_t v3 = *a1;
    *((void *)*a1 + 7) = result;
  }
  if (*((unsigned char *)v3 + 48)) {
    *(_WORD *)(result + 46) |= 0x1000u;
  }
  return result;
}

void *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::Image<RB::ImageTexture>>(long long **a1, RB::ImageTexture *a2)
{
  int64x2_t v3 = *a1;
  unint64_t result = (void *)*((void *)*a1 + 7);
  if (!result)
  {
    unint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)v3 + 1, (float *)v3 + 4, (_DWORD *)v3 + 5, (__int16 *)v3 + 12);
    int64x2_t v3 = *a1;
    *((void *)*a1 + 7) = result;
  }
  if (*((unsigned char *)v3 + 48)) {
    *((_WORD *)result + 23) |= 0x1000u;
  }
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::Custom>(long long **a1, uint64_t a2)
{
  int64x2_t v3 = *a1;
  unint64_t result = *((void *)*a1 + 7);
  if (!result)
  {
    unint64_t result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(size_t **)v3, *(void *)v3, a1[1], a2, (uint64_t *)v3 + 1, (int *)v3 + 4, (_WORD *)v3 + 10);
    int64x2_t v3 = *a1;
    *((void *)*a1 + 7) = result;
  }
  if (*((unsigned char *)v3 + 48)) {
    *(_WORD *)(result + 46) |= 0x1000u;
  }
  return result;
}

double RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Distance>,RB::Filter::Distance>(RB::Heap *this, uint64_t *a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 72 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 72;
  }
  *(void *)(v5 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4EEEA0;
  uint64_t v7 = *a2;
  *(_DWORD *)(v5 + 64) = *((_DWORD *)a2 + 2);
  *(void *)(v5 + 56) = v7;
  return result;
}

void RB::DisplayList::FilterStyle<RB::Filter::Distance>::~FilterStyle()
{
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::Distance>::type_id()
{
  return 24578;
}

double RB::DisplayList::FilterStyle<RB::Filter::Distance>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Distance>,RB::Filter::Distance const&,RB::DisplayList::Builder &>((RB::Heap *)(*(void *)(a2 + 8) + 16), a1 + 56);
}

RB::DisplayList::Item *RB::DisplayList::FilterStyle<RB::Filter::Distance>::draw(void *a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  uint64_t v10 = (float64x2_t *)a1[2];
  long long v11 = (const RB::DisplayList::ClipNode *)a1[3];
  RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::Distance>,RB::Filter::Distance const&,RB::DisplayList::Builder &>((RB::Heap *)(*((void *)a2 + 1) + 16), (uint64_t)(a1 + 7));
  double result = RB::DisplayList::Builder::apply_filter_(a2, a4, v12, v10, v11);
  if (result)
  {
    *((void *)result + 2) = a1[4];
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

double RB::DisplayList::FilterStyle<RB::Filter::Distance>::bounds(uint64_t a1, const RB::DisplayList::Item *a2, uint64_t a3)
{
  v16[0] = RB::DisplayList::Style::next_bounds((RB::DisplayList::Style *)a1, a2, a3);
  v16[1] = v4;
  v13[0] = (float64x2_t)xmmword_2142181C0;
  v13[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  RB::Rect::move(v16, v13, *(float64x2_t **)(a1 + 16));
  RB::Filter::Distance::dod((RB::Filter::Distance *)(a1 + 56), v16, v5, v6);
  RB::Rect::move_identity(v16, v13);
  uint64_t v11 = *(void *)(a1 + 24);
  if (v11) {
    RB::Rect::intersect(v16, *(double *)(v11 + 16), *(float32x2_t *)(v11 + 24), v7, v8, v9, v10);
  }
  return *(double *)v16;
}

int32x2_t RB::DisplayList::FilterStyle<RB::Filter::Distance>::map_roi(uint64_t a1, float32x2_t *this, float64x2_t *a3)
{
  float32x2_t v4 = (RB::Filter::Distance *)(a1 + 56);
  RB::Rect::move(this, a3, *(float64x2_t **)(a1 + 16));
  return RB::Filter::Distance::dod(v4, this, v5, v6);
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::Distance>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1 + 56;
  if (a3) {
    uint64_t v4 = a3 + 56;
  }
  else {
    uint64_t v4 = 0;
  }
  return RB::Filter::Distance::can_mix(v3, a2, v4);
}

float32x2_t *RB::DisplayList::FilterStyle<RB::Filter::Distance>::mix(uint64_t a1, uint64_t a2, float32x2_t *a3, uint64_t a4)
{
  RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Distance>,RB::Filter::Distance const&,RB::DisplayList::Builder &>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), a1 + 56);
  double v7 = v6;
  double v8 = v6 + 7;
  if (a3) {
    double v9 = a3 + 7;
  }
  else {
    double v9 = 0;
  }
  RB::Filter::Distance::mix(v8, a2, v9);
  return v7;
}

void *RB::DisplayList::FilterStyle<RB::Filter::Distance>::encode(uint64_t a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode((void *)a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Filter::Distance::encode((int *)(a1 + 56), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::FilterStyle<RB::Filter::Distance>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "filter");
  RB::Filter::Distance::print((RB::Filter::Distance *)(a1 + 7), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

double RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Distance>,RB::Filter::Distance const&,RB::DisplayList::Builder &>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 72 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 72;
  }
  *(void *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4EEEA0;
  double result = *(double *)a2;
  *(void *)(v5 + 56) = *(void *)a2;
  *(_DWORD *)(v5 + 64) = *(_DWORD *)(a2 + 8);
  return result;
}

double RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::Distance>,RB::Filter::Distance const&,RB::DisplayList::Builder &>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 48 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 48;
  }
  *(void *)(v5 + 16) = 0;
  *(void *)(v5 + 24) = 0;
  *(void *)unint64_t v5 = &unk_26C4EEF28;
  double result = *(double *)a2;
  *(void *)(v5 + 32) = *(void *)a2;
  *(_DWORD *)(v5 + 40) = *(_DWORD *)(a2 + 8);
  return result;
}

void RB::DisplayList::GenericFilter<RB::Filter::Distance>::~GenericFilter()
{
}

double RB::DisplayList::GenericFilter<RB::Filter::Distance>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::Distance>,RB::Filter::Distance const&,RB::DisplayList::Builder &>((RB::Heap *)(*(void *)(a2 + 8) + 16), a1 + 32);
}

float RB::DisplayList::GenericFilter<RB::Filter::Distance>::apply_transform(uint64_t a1, float64x2_t *a2)
{
  return RB::Filter::Distance::apply_transform((float *)(a1 + 32), a2);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Distance>::append()
{
  return 0;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Distance>::filter_data()
{
  return 6;
}

int32x2_t RB::DisplayList::GenericFilter<RB::Filter::Distance>::roi(uint64_t a1, float32x2_t *a2, int32x2_t a3, int32x4_t a4)
{
  return RB::Filter::Distance::dod((RB::Filter::Distance *)(a1 + 32), a2, a3, a4);
}

int32x2_t RB::DisplayList::GenericFilter<RB::Filter::Distance>::dod(uint64_t a1, float32x2_t *a2, int32x2_t a3, int32x4_t a4)
{
  return RB::Filter::Distance::dod((RB::Filter::Distance *)(a1 + 32), a2, a3, a4);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Distance>::commutes_with_clip()
{
  return 0;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Distance>::required_depth(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Distance>::can_discard_color()
{
  return 0;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Distance>::can_render_inline()
{
  return 0;
}

void RB::DisplayList::GenericFilter<RB::Filter::Distance>::render()
{
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Distance>::render(uint64_t a1)
{
  return RBStrokeRef::clip(a1 + 32);
}

void RB::DisplayList::GenericFilter<RB::Filter::Distance>::print(uint64_t a1, std::string *a2)
{
}

__n128 RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 104 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x68uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 104;
  }
  *(void *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4E89C8;
  __n128 result = *(__n128 *)a2;
  long long v7 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v5 + 88) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 72) = v7;
  *(__n128 *)(v5 + 56) = result;
  return result;
}

void RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>::~FilterStyle()
{
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>::type_id()
{
  return 4098;
}

double RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>::copy(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix>((RB::Heap *)(*(void *)(a2 + 8) + 16), a1 + 56).n128_u64[0];
  return result;
}

RB::DisplayList::Item *RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>::draw(float16x4_t *a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  if ((RB::ColorMatrix::is_identity(a1 + 8) & 1) != 0
    || (int32x4_t v10 = (float64x2_t *)a1[2],
        uint64_t v11 = (const RB::DisplayList::ClipNode *)a1[3],
        RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix const&,RB::DisplayList::Builder &>((RB::Heap *)(*((void *)a2 + 1) + 16), (uint64_t)&a1[7]), double result = RB::DisplayList::Builder::apply_filter_(a2, a4, v12, v10, v11), (a4 = result) != 0))
  {
    *((float16x4_t *)a4 + 2) = a1[4];
    return RB::DisplayList::Builder::draw(a2, a4, a3, a5);
  }
  return result;
}

double RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>::bounds(RB::DisplayList::Style *a1, const RB::DisplayList::Item *a2, uint64_t a3)
{
  v14[0] = RB::DisplayList::Style::next_bounds(a1, a2, a3);
  v14[1] = v4;
  v11[0] = (float64x2_t)xmmword_2142181C0;
  v11[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  RB::Rect::move_identity(v14, v11);
  uint64_t v9 = *((void *)a1 + 3);
  if (v9) {
    RB::Rect::intersect(v14, *(double *)(v9 + 16), *(float32x2_t *)(v9 + 24), v5, v6, v7, v8);
  }
  return *(double *)v14;
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>::can_mix(float16x4_t *a1, RB::DisplayList::Interpolator::Contents *a2, float16x4_t *a3)
{
  uint64_t v3 = a1 + 7;
  if (a3) {
    float32x2_t v4 = a3 + 7;
  }
  else {
    float32x2_t v4 = 0;
  }
  return RB::Filter::ColorMatrix::can_mix(v3, a2, v4);
}

float16x4_t *RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>::mix(uint64_t a1, const RB::DisplayList::Interpolator::State *a2, uint64_t a3, const RB::DisplayList::CachedTransform *a4)
{
  RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), a1 + 56);
  int32x4_t v8 = v7;
  uint64_t v9 = v7 + 7;
  if (a3) {
    int32x4_t v10 = (const RB::Filter::ColorMatrix *)(a3 + 56);
  }
  else {
    int32x4_t v10 = 0;
  }
  RB::Filter::ColorMatrix::mix(v9, a2, v10, a4);
  return v8;
}

void *RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>::encode(void *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Filter::ColorMatrix::encode((RB::Filter::ColorMatrix *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "filter");
  RB::Filter::ColorMatrix::print((float16x4_t *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

__n128 RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix const&,RB::DisplayList::Builder &>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 80 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x50uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 80;
  }
  *(void *)(v5 + 16) = 0;
  *(void *)(v5 + 24) = 0;
  *(void *)unint64_t v5 = &unk_26C4EBEA0;
  __n128 result = *(__n128 *)a2;
  long long v7 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 48) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v5 + 64) = v7;
  *(__n128 *)(v5 + 32) = result;
  return result;
}

void RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::~GenericFilter()
{
}

double RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::copy(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix const&,RB::DisplayList::Builder &>((RB::Heap *)(*(void *)(a2 + 8) + 16), a1 + 32).n128_u64[0];
  return result;
}

BOOL RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::append(uint64_t a1, int a2, float16x4_t *a3)
{
  return RB::Filter::ColorMatrix::append(a1 + 32, a2, a3);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::filter_data()
{
  return 1;
}

int32x2_t RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::dod(uint64_t a1, int32x2_t *a2)
{
  return RB::Filter::ColorMatrix::dod((RB::Filter::ColorMatrix *)(a1 + 32), a2);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::commutes_with_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::required_depth(uint64_t a1, uint64_t a2)
{
  return a2;
}

BOOL RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::can_discard_color(uint64_t a1, BOOL *a2)
{
  return RB::Filter::ColorMatrix::can_discard_color((RB::Filter::ColorMatrix *)(a1 + 32), a2);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::can_render_inline()
{
  return 1;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::render(float16x4_t *a1, uint64_t a2, MTLPixelFormat a3)
{
  return RB::Filter::ColorMatrix::render(a1 + 4, a2, a3);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::render(float16x4_t *a1, RB::_anonymous_namespace_ **a2)
{
  return RB::Filter::ColorMatrix::render(a1 + 4, a2);
}

void RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::print(float16x4_t *a1, std::string *a2)
{
}

__n128 RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>,RB::ColorStyle::ColorMultiply>(RB::Heap *this, __n128 *a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 72 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 72;
  }
  *(void *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4EC668;
  __n128 result = *a2;
  *(__n128 *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::~ColorFilterStyle()
{
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::type_id()
{
  return 4101;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::copy(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>,RB::ColorStyle::ColorMultiply>((RB::Heap *)(*(void *)(a2 + 8) + 16), (__n128 *)(a1 + 56)).n128_u64[0];
  return result;
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5, uint16x4_t a6, int8x8_t a7)
{
  RB::ColorStyle::ColorMultiply::set_color_matrix((RB::ColorStyle::ColorMultiply *)(a1 + 56), (RB::ColorMatrix *)v13, a6, a7);
  double result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v13, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((void *)result + 2) = *(void *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 56), a2) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && RB::ColorStyle::ColorMultiply::operator==(a1 + 56, a3 + 56)) {
    return 4;
  }
  else {
    return 2;
  }
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>,RB::ColorStyle::ColorMultiply>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), (__n128 *)(a1 + 56));
  uint64_t v7 = v6;
  int32x4_t v8 = (RB::ColorStyle::ColorMultiply *)(v6 + 56);
  if (a3) {
    uint64_t v9 = (const RB::ColorStyle::ColorMultiply *)(a3 + 56);
  }
  else {
    uint64_t v9 = 0;
  }
  RB::ColorStyle::ColorMultiply::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

void *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::encode(void *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::ColorMultiply::encode((RB::ColorStyle::ColorMultiply *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::ColorMultiply::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

BOOL RB::ColorStyle::ColorMultiply::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 == *(_DWORD *)a2
    && (*(unsigned char *)(a1 + 13) ? (BOOL v2 = *(unsigned char *)(a2 + 13) == 0) : (BOOL v2 = 1),
        (v2 || *(unsigned __int8 *)(a1 + 12) == *(unsigned __int8 *)(a2 + 12))
     && *(short float *)(a1 + 4) == *(short float *)(a2 + 4)
     && *(short float *)(a1 + 6) == *(short float *)(a2 + 6)
     && *(short float *)(a1 + 8) == *(short float *)(a2 + 8)))
  {
    return *(short float *)(a1 + 10) == *(short float *)(a2 + 10);
  }
  else
  {
    return 0;
  }
}

__n128 RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>,RB::ColorStyle::AlphaMultiply>(RB::Heap *this, __n128 *a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 72 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 72;
  }
  *(void *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4EC5E0;
  __n128 result = *a2;
  *(__n128 *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::~ColorFilterStyle()
{
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::type_id()
{
  return 8197;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::copy(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>,RB::ColorStyle::AlphaMultiply>((RB::Heap *)(*(void *)(a2 + 8) + 16), (__n128 *)(a1 + 56)).n128_u64[0];
  return result;
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5, uint16x4_t a6, int8x8_t a7)
{
  RB::ColorStyle::AlphaMultiply::set_color_matrix((RB::ColorStyle::AlphaMultiply *)(a1 + 56), v13, a6, a7);
  double result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v13, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((void *)result + 2) = *(void *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::ColorStyle::AlphaMultiply::matches((RB::ColorStyle::AlphaMultiply *)(a1 + 56), a2, a3) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  if (RB::ColorStyle::ColorMultiply::operator==(a1 + 56, a3 + 56)) {
    return 4;
  }
  return 2;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>,RB::ColorStyle::AlphaMultiply>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), (__n128 *)(a1 + 56));
  uint64_t v7 = v6;
  int32x4_t v8 = (RB::ColorStyle::AlphaMultiply *)(v6 + 56);
  if (a3) {
    uint64_t v9 = (const RB::ColorStyle::AlphaMultiply *)(a3 + 56);
  }
  else {
    uint64_t v9 = 0;
  }
  RB::ColorStyle::AlphaMultiply::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

void *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::encode(void *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::ColorMultiply::encode((RB::ColorStyle::ColorMultiply *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::AlphaMultiply::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>,RB::ColorStyle::HueRotation>(RB::Heap *this, void *a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 64;
  }
  *(void *)(v5 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4EC558;
  *(void *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::~ColorFilterStyle()
{
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::type_id()
{
  return 12293;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>,RB::ColorStyle::HueRotation>((RB::Heap *)(*(void *)(a2 + 8) + 16), (void *)(a1 + 56));
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  RB::ColorMatrix::set_hue_rotate(v11, *(float *)(a1 + 60));
  double result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v11, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((void *)result + 2) = *(void *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 56), a2) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && *(_DWORD *)(a1 + 56) == *(_DWORD *)(a3 + 56) && *(float *)(a1 + 60) == *(float *)(a3 + 60)) {
    return 4;
  }
  else {
    return 2;
  }
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>,RB::ColorStyle::HueRotation>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), (void *)(a1 + 56));
  uint64_t v7 = v6;
  uint64_t v8 = v6 + 56;
  if (a3) {
    uint64_t v9 = a3 + 56;
  }
  else {
    uint64_t v9 = 0;
  }
  RB::ColorStyle::HueRotation::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

void *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::encode(void *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::HueRotation::encode((RB::ColorStyle::HueRotation *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::HueRotation::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>,RB::ColorStyle::Saturation>(RB::Heap *this, void *a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 64;
  }
  *(void *)(v5 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4EC448;
  *(void *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::~ColorFilterStyle()
{
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::type_id()
{
  return 16389;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>,RB::ColorStyle::Saturation>((RB::Heap *)(*(void *)(a2 + 8) + 16), (void *)(a1 + 56));
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5, double a6, double a7, double a8, double a9, double a10, float32x4_t a11, float32x4_t a12)
{
  RB::ColorMatrix::set_saturate(v18, *(float *)(a1 + 60), a7, a8, a9, a10, a11, a12);
  double result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v18, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((void *)result + 2) = *(void *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 56), a2) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && *(_DWORD *)(a1 + 56) == *(_DWORD *)(a3 + 56) && *(float *)(a1 + 60) == *(float *)(a3 + 60)) {
    return 4;
  }
  else {
    return 2;
  }
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>,RB::ColorStyle::Saturation>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), (void *)(a1 + 56));
  uint64_t v7 = v6;
  uint64_t v8 = v6 + 56;
  if (a3) {
    uint64_t v9 = a3 + 56;
  }
  else {
    uint64_t v9 = 0;
  }
  RB::ColorStyle::Saturation::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

void *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::encode(void *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x22uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::Saturation::encode((RB::ColorStyle::Saturation *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::Saturation::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>,RB::ColorStyle::Brightness>(RB::Heap *this, void *a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 64;
  }
  *(void *)(v5 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4EC3C0;
  *(void *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::~ColorFilterStyle()
{
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::type_id()
{
  return 20485;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>,RB::ColorStyle::Brightness>((RB::Heap *)(*(void *)(a2 + 8) + 16), (void *)(a1 + 56));
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5, int16x4_t a6)
{
  a6.i32[0] = *(_DWORD *)(a1 + 60);
  RB::ColorMatrix::set_brightness(v12, a6);
  double result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v12, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((void *)result + 2) = *(void *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 56), a2) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && *(_DWORD *)(a1 + 56) == *(_DWORD *)(a3 + 56) && *(float *)(a1 + 60) == *(float *)(a3 + 60)) {
    return 4;
  }
  else {
    return 2;
  }
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>,RB::ColorStyle::Brightness>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), (void *)(a1 + 56));
  uint64_t v7 = v6;
  uint64_t v8 = v6 + 56;
  if (a3) {
    uint64_t v9 = a3 + 56;
  }
  else {
    uint64_t v9 = 0;
  }
  RB::ColorStyle::HueRotation::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

void *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::encode(void *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x2AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::Saturation::encode((RB::ColorStyle::Saturation *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::Brightness::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>,RB::ColorStyle::Contrast>(RB::Heap *this, void *a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 64;
  }
  *(void *)(v5 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4EC800;
  *(void *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::~ColorFilterStyle()
{
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::type_id()
{
  return 24581;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>,RB::ColorStyle::Contrast>((RB::Heap *)(*(void *)(a2 + 8) + 16), (void *)(a1 + 56));
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  RB::ColorMatrix::set_contrast(v11, *(float *)(a1 + 60));
  double result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v11, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((void *)result + 2) = *(void *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 56), a2) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && *(_DWORD *)(a1 + 56) == *(_DWORD *)(a3 + 56) && *(float *)(a1 + 60) == *(float *)(a3 + 60)) {
    return 4;
  }
  else {
    return 2;
  }
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>,RB::ColorStyle::Contrast>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), (void *)(a1 + 56));
  uint64_t v7 = v6;
  uint64_t v8 = v6 + 56;
  if (a3) {
    uint64_t v9 = a3 + 56;
  }
  else {
    uint64_t v9 = 0;
  }
  RB::ColorStyle::Saturation::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

void *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::encode(void *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::Saturation::encode((RB::ColorStyle::Saturation *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::Contrast::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>,RB::ColorStyle::LuminanceToAlpha>(RB::Heap *this, _DWORD *a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 64;
  }
  *(void *)(v5 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4EC778;
  *(_DWORD *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::~ColorFilterStyle()
{
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::type_id()
{
  return 28677;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>,RB::ColorStyle::LuminanceToAlpha>((RB::Heap *)(*(void *)(a2 + 8) + 16), (_DWORD *)(a1 + 56));
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  RB::ColorMatrix::set_luminance_to_alpha((RB::ColorMatrix *)v11);
  double result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v11, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((void *)result + 2) = *(void *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 56), a2) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 56) == *(_DWORD *)(a3 + 56)) {
    return 4;
  }
  return 2;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>,RB::ColorStyle::LuminanceToAlpha>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), (_DWORD *)(a1 + 56));
}

void *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::encode(void *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x3AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::LuminanceToAlpha::encode((RB::ColorStyle::LuminanceToAlpha *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::LuminanceToAlpha::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>,RB::ColorStyle::ColorInvert>(RB::Heap *this, void *a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 64;
  }
  *(void *)(v5 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4EC4D0;
  *(void *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::~ColorFilterStyle()
{
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::type_id()
{
  return 36869;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>,RB::ColorStyle::ColorInvert>((RB::Heap *)(*(void *)(a2 + 8) + 16), (void *)(a1 + 56));
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5, double a6)
{
  LODWORD(a6) = *(_DWORD *)(a1 + 60);
  RB::ColorMatrix::set_color_invert(v12, a6);
  double result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v12, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((void *)result + 2) = *(void *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 56), a2) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && *(_DWORD *)(a1 + 56) == *(_DWORD *)(a3 + 56) && *(float *)(a1 + 60) == *(float *)(a3 + 60)) {
    return 4;
  }
  else {
    return 2;
  }
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>,RB::ColorStyle::ColorInvert>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), (void *)(a1 + 56));
  uint64_t v7 = v6;
  uint64_t v8 = v6 + 56;
  if (a3) {
    uint64_t v9 = a3 + 56;
  }
  else {
    uint64_t v9 = 0;
  }
  RB::ColorStyle::HueRotation::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

void *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::encode(void *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x4AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::HueRotation::encode((RB::ColorStyle::HueRotation *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::ColorInvert::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

__n128 RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>,RB::ColorStyle::ColorMonochrome>(RB::Heap *this, __n128 *a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 80 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x50uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 80;
  }
  *(void *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4EC6F0;
  __n128 result = *a2;
  *(void *)(v5 + 72) = a2[1].n128_u64[0];
  *(__n128 *)(v5 + 56) = result;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::~ColorFilterStyle()
{
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::type_id()
{
  return 32773;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::copy(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>,RB::ColorStyle::ColorMonochrome>((RB::Heap *)(*(void *)(a2 + 8) + 16), (__n128 *)(a1 + 56)).n128_u64[0];
  return result;
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5, uint16x4_t a6, int8x8_t a7)
{
  RB::ColorStyle::ColorMonochrome::set_color_matrix((RB::ColorStyle::ColorMonochrome *)(a1 + 56), (RB::ColorMatrix *)v13, a6, a7);
  double result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v13, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((void *)result + 2) = *(void *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 56), a2) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && RB::ColorStyle::ColorMonochrome::operator==(a1 + 56, a3 + 56)) {
    return 4;
  }
  else {
    return 2;
  }
}

float32x2_t *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::mix(uint64_t a1, uint64_t a2, float32x2_t *a3, uint64_t a4)
{
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>,RB::ColorStyle::ColorMonochrome>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), (__n128 *)(a1 + 56));
  uint64_t v7 = v6;
  uint64_t v8 = v6 + 7;
  if (a3) {
    uint64_t v9 = a3 + 7;
  }
  else {
    uint64_t v9 = 0;
  }
  RB::ColorStyle::ColorMonochrome::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

void *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::encode(void *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x42uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::ColorMonochrome::encode((RB::ColorStyle::ColorMonochrome *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::ColorMonochrome::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

BOOL RB::ColorStyle::ColorMonochrome::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 == *(_DWORD *)a2
    && (*(unsigned char *)(a1 + 13) ? (BOOL v2 = *(unsigned char *)(a2 + 13) == 0) : (BOOL v2 = 1),
        (v2 || *(unsigned __int8 *)(a1 + 12) == *(unsigned __int8 *)(a2 + 12))
     && *(short float *)(a1 + 4) == *(short float *)(a2 + 4)
     && *(short float *)(a1 + 6) == *(short float *)(a2 + 6)
     && *(short float *)(a1 + 8) == *(short float *)(a2 + 8)
     && *(short float *)(a1 + 10) == *(short float *)(a2 + 10)
     && *(float *)(a1 + 16) == *(float *)(a2 + 16)))
  {
    return *(float *)(a1 + 20) == *(float *)(a2 + 20);
  }
  else
  {
    return 0;
  }
}

__n128 RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 112 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x70uLL, 15);
  }
  else {
    *((void *)this + 2) = v5 + 112;
  }
  *(void *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4E8AD8;
  __n128 result = *(__n128 *)a2;
  long long v7 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 80) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v5 + 96) = v7;
  *(__n128 *)(v5 + 64) = result;
  return result;
}

void RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>::~FilterStyle()
{
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>::type_id()
{
  return 8194;
}

double RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>::copy(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve const&,RB::DisplayList::Builder &>((RB::Heap *)(*(void *)(a2 + 8) + 16), a1 + 64).n128_u64[0];
  return result;
}

RB::DisplayList::Item *RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>::draw(void *a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  int32x4_t v10 = (float64x2_t *)a1[2];
  uint64_t v11 = (const RB::DisplayList::ClipNode *)a1[3];
  RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve const&,RB::DisplayList::Builder &>((RB::Heap *)(*((void *)a2 + 1) + 16), (uint64_t)(a1 + 8));
  double result = RB::DisplayList::Builder::apply_filter_(a2, a4, v12, v10, v11);
  if (result)
  {
    *((void *)result + 2) = a1[4];
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

double RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>::bounds(RB::DisplayList::Style *a1, const RB::DisplayList::Item *a2, uint64_t a3)
{
  v14[0] = RB::DisplayList::Style::next_bounds(a1, a2, a3);
  v14[1] = v4;
  v11[0] = (float64x2_t)xmmword_2142181C0;
  v11[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  RB::Rect::move_identity(v14, v11);
  uint64_t v9 = *((void *)a1 + 3);
  if (v9) {
    RB::Rect::intersect(v14, *(double *)(v9 + 16), *(float32x2_t *)(v9 + 24), v5, v6, v7, v8);
  }
  return *(double *)v14;
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>::can_mix(float32x4_t *a1, RB::DisplayList::Interpolator::Contents *a2, float32x4_t *a3)
{
  uint64_t v3 = a1 + 4;
  if (a3) {
    float32x2_t v4 = a3 + 4;
  }
  else {
    float32x2_t v4 = 0;
  }
  return RB::Filter::LuminanceCurve::can_mix(v3, a2, v4);
}

float32x4_t *RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>::mix(uint64_t a1, const RB::DisplayList::Interpolator::State *a2, float32x4_t *a3, const RB::DisplayList::CachedTransform *a4)
{
  RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve const&,RB::DisplayList::Builder &>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), a1 + 64);
  int32x4_t v8 = v7;
  uint64_t v9 = v7 + 4;
  if (a3) {
    int32x4_t v10 = a3 + 4;
  }
  else {
    int32x4_t v10 = 0;
  }
  RB::Filter::LuminanceCurve::mix(v9, a2, v10, a4);
  return v8;
}

void *RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>::encode(float32x4_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Filter::LuminanceCurve::encode(a1 + 4, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "filter");
  RB::Filter::LuminanceCurve::print((RB::Filter::LuminanceCurve *)(a1 + 8), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

__n128 RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve const&,RB::DisplayList::Builder &>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 112 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x70uLL, 15);
  }
  else {
    *((void *)this + 2) = v5 + 112;
  }
  *(void *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4E8AD8;
  __n128 result = *(__n128 *)a2;
  long long v7 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v5 + 90) = *(_OWORD *)(a2 + 26);
  *(__n128 *)(v5 + 64) = result;
  *(_OWORD *)(v5 + 80) = v7;
  return result;
}

__n128 RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve const&,RB::DisplayList::Builder &>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 80 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x50uLL, 15);
  }
  else {
    *((void *)this + 2) = v5 + 80;
  }
  *(void *)(v5 + 16) = 0;
  *(void *)(v5 + 24) = 0;
  *(void *)unint64_t v5 = &unk_26C4EBFC0;
  __n128 result = *(__n128 *)a2;
  long long v7 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v5 + 58) = *(_OWORD *)(a2 + 26);
  *(__n128 *)(v5 + 32) = result;
  *(_OWORD *)(v5 + 48) = v7;
  return result;
}

void RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::~GenericFilter()
{
}

double RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::copy(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve const&,RB::DisplayList::Builder &>((RB::Heap *)(*(void *)(a2 + 8) + 16), a1 + 32).n128_u64[0];
  return result;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::append()
{
  return 0;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::filter_data()
{
  return 2;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::commutes_with_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::required_depth(float16x4_t *a1)
{
  return RB::Fill::Color::required_depth(a1 + 8);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::can_discard_color(uint64_t a1, BOOL *a2)
{
  return RB::Filter::LuminanceCurve::can_discard_color((RB::Filter::LuminanceCurve *)(a1 + 32), a2);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::can_render_inline()
{
  return 1;
}

int32x2_t *RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::render(int32x2_t *a1, uint64_t a2, MTLPixelFormat a3)
{
  return RB::Filter::LuminanceCurve::render(a1 + 4, a2, a3);
}

void RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::render(uint64_t a1, uint64_t a2)
{
}

void RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::print(uint64_t a1, std::string *a2)
{
}

__n128 RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>,RB::Filter::RGBACurves>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 144 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x90uLL, 15);
  }
  else {
    *((void *)this + 2) = v5 + 144;
  }
  *(void *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4E8460;
  *(_OWORD *)(v5 + 64) = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  long long v7 = *(_OWORD *)(a2 + 32);
  long long v8 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v5 + 112) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v5 + 128) = v8;
  *(__n128 *)(v5 + 80) = result;
  *(_OWORD *)(v5 + 96) = v7;
  return result;
}

void RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>::~FilterStyle()
{
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>::type_id()
{
  return 12290;
}

double RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>::copy(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>,RB::Filter::RGBACurves>((RB::Heap *)(*(void *)(a2 + 8) + 16), a1 + 64).n128_u64[0];
  return result;
}

RB::DisplayList::Item *RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>::draw(void *a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  int32x4_t v10 = (float64x2_t *)a1[2];
  uint64_t v11 = (const RB::DisplayList::ClipNode *)a1[3];
  RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>,RB::Filter::RGBACurves const&,RB::DisplayList::Builder &>((RB::Heap *)(*((void *)a2 + 1) + 16), (uint64_t)(a1 + 8));
  double result = RB::DisplayList::Builder::apply_filter_(a2, a4, v12, v10, v11);
  if (result)
  {
    *((void *)result + 2) = a1[4];
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

double RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>::bounds(RB::DisplayList::Style *a1, const RB::DisplayList::Item *a2, uint64_t a3)
{
  v14[0] = RB::DisplayList::Style::next_bounds(a1, a2, a3);
  v14[1] = v4;
  v11[0] = (float64x2_t)xmmword_2142181C0;
  v11[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  RB::Rect::move_identity(v14, v11);
  uint64_t v9 = *((void *)a1 + 3);
  if (v9) {
    RB::Rect::intersect(v14, *(double *)(v9 + 16), *(float32x2_t *)(v9 + 24), v5, v6, v7, v8);
  }
  return *(double *)v14;
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>::can_mix(float32x4_t *a1, uint64_t a2, float32x4_t *a3)
{
  uint64_t v3 = a1 + 4;
  if (a3) {
    float32x2_t v4 = a3 + 4;
  }
  else {
    float32x2_t v4 = 0;
  }
  return RB::Filter::RGBACurves::can_mix(v3, a2, v4);
}

float32x4_t *RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>::mix(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4)
{
  RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>,RB::Filter::RGBACurves>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), a1 + 64);
  double v7 = v6;
  int32x4_t v8 = v6 + 4;
  if (a3) {
    uint64_t v9 = a3 + 4;
  }
  else {
    uint64_t v9 = 0;
  }
  RB::Filter::RGBACurves::mix(v8, a2, v9);
  return v7;
}

void *RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>::encode(float32x4_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x2AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Filter::RGBACurves::encode(a1 + 4, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "filter");
  RB::Filter::RGBACurves::print((RB::Filter::RGBACurves *)(a1 + 8), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

__n128 RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>,RB::Filter::RGBACurves const&,RB::DisplayList::Builder &>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 112 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x70uLL, 15);
  }
  else {
    *((void *)this + 2) = v5 + 112;
  }
  *(void *)(v5 + 16) = 0;
  *(void *)(v5 + 24) = 0;
  *(void *)unint64_t v5 = &unk_26C4E84E8;
  *(_OWORD *)(v5 + 32) = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  long long v7 = *(_OWORD *)(a2 + 32);
  long long v8 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v5 + 80) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v5 + 96) = v8;
  *(__n128 *)(v5 + 48) = result;
  *(_OWORD *)(v5 + 64) = v7;
  return result;
}

void RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::~GenericFilter()
{
}

double RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::copy(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>,RB::Filter::RGBACurves const&,RB::DisplayList::Builder &>((RB::Heap *)(*(void *)(a2 + 8) + 16), a1 + 32).n128_u64[0];
  return result;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::append()
{
  return 0;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::filter_data()
{
  return 3;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::commutes_with_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::required_depth(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::can_discard_color()
{
  return 1;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::can_render_inline()
{
  return 1;
}

int32x2_t *RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::render(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return RB::Filter::RGBACurves::render((_DWORD *)(a1 + 32), a2, a3);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::render(uint64_t a1, uint64_t a2)
{
  return RB::Filter::RGBACurves::render(a1 + 32, a2);
}

void RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::print(uint64_t a1, std::string *a2)
{
}

uint64_t RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Custom>,RB::Filter::Custom>(size_t *a1, uint64_t a2)
{
  uint64_t v3 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 272 > a1[3]) {
    uint64_t v3 = RB::Heap::alloc_slow(a1, 0x110uLL, 15);
  }
  else {
    a1[2] = v3 + 272;
  }
  return RB::DisplayList::FilterStyle<RB::Filter::Custom>::FilterStyle<RB::Filter::Custom>(v3, a2);
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::Custom>::FilterStyle<RB::Filter::Custom>(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)a1 = &unk_26C4E8B60;
  *(_DWORD *)(a1 + 64) = *(_DWORD *)a2;
  *(void *)(a1 + 72) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 4;
  uint64_t v4 = *(void *)(a2 + 120);
  *(void *)(a1 + 176) = *(void *)(a2 + 112);
  *(void *)(a1 + 184) = v4;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 120) = 0;
  uint64_t v5 = *(void *)(a1 + 192);
  *(void *)(a1 + 192) = *(void *)(a2 + 128);
  *(void *)(a2 + 128) = v5;
  RB::vector<RB::CustomShader::Value,4ul,unsigned long>::swap_inline((long long *)(a1 + 80), (long long *)(a2 + 16));
  long long v6 = *(_OWORD *)(a2 + 144);
  long long v7 = *(_OWORD *)(a2 + 160);
  long long v8 = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(a1 + 240) = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(a1 + 256) = v8;
  *(_OWORD *)(a1 + 208) = v6;
  *(_OWORD *)(a1 + 224) = v7;
  return a1;
}

void sub_21417B980(_Unwind_Exception *a1)
{
  long long v6 = *(void **)(v1 + 176);
  if (v6) {
    uint64_t v3 = *(const void ***)(v1 + 176);
  }
  if (*(void *)(v1 + 184))
  {
    unint64_t v7 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v3);
      ++v7;
      v3 += 3;
    }
    while (v7 < *(void *)(v1 + 184));
    long long v6 = *v4;
  }
  RB::DisplayList::FilterStyle<RB::Filter::Custom>::FilterStyle<RB::Filter::Custom>(v2, v6);
  _Unwind_Resume(a1);
}

void *RB::DisplayList::FilterStyle<RB::Filter::Custom>::~FilterStyle(void *a1)
{
  BOOL v2 = (const void **)(a1 + 10);
  uint64_t v3 = (const void **)a1[22];
  if (v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = v2;
  }
  if (a1[23])
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[23]);
    uint64_t v3 = (const void **)a1[22];
  }
  if (v3) {
    free(v3);
  }
  long long v6 = (atomic_uint *)a1[9];
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  return a1;
}

void RB::DisplayList::FilterStyle<RB::Filter::Custom>::~FilterStyle(void *a1)
{
  BOOL v2 = (const void **)(a1 + 10);
  uint64_t v3 = (const void **)a1[22];
  if (v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = v2;
  }
  if (a1[23])
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[23]);
    uint64_t v3 = (const void **)a1[22];
  }
  if (v3) {
    free(v3);
  }
  long long v6 = (atomic_uint *)a1[9];
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::Custom>::type_id()
{
  return 16386;
}

unint64_t RB::DisplayList::FilterStyle<RB::Filter::Custom>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Custom>,RB::Filter::Custom const&,RB::DisplayList::Builder &>((size_t *)(*(void *)(a2 + 8) + 16), a1 + 64);
}

RB::DisplayList::Item *RB::DisplayList::FilterStyle<RB::Filter::Custom>::draw(void *a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  int32x4_t v10 = (float64x2_t *)a1[2];
  uint64_t v11 = (const RB::DisplayList::ClipNode *)a1[3];
  uint64_t v12 = (RB::DisplayList::LayerFilter *)RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::Custom>,RB::Filter::Custom const&,RB::DisplayList::Builder &>((size_t *)(*((void *)a2 + 1) + 16), (uint64_t)(a1 + 8));
  double result = RB::DisplayList::Builder::apply_filter_(a2, a4, v12, v10, v11);
  if (result)
  {
    *((void *)result + 2) = a1[4];
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

double RB::DisplayList::FilterStyle<RB::Filter::Custom>::bounds(RB::DisplayList::Style *a1, const RB::DisplayList::Item *a2, uint64_t a3)
{
  v14[0] = RB::DisplayList::Style::next_bounds(a1, a2, a3);
  v14[1] = v4;
  v11[0] = (float64x2_t)xmmword_2142181C0;
  v11[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  RB::Rect::move_identity(v14, v11);
  uint64_t v9 = *((void *)a1 + 3);
  if (v9) {
    RB::Rect::intersect(v14, *(double *)(v9 + 16), *(float32x2_t *)(v9 + 24), v5, v6, v7, v8);
  }
  return *(double *)v14;
}

BOOL RB::DisplayList::FilterStyle<RB::Filter::Custom>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = (_DWORD *)(a1 + 64);
  if (a3) {
    uint64_t v4 = a3 + 64;
  }
  else {
    uint64_t v4 = 0;
  }
  return RB::Filter::Custom::can_mix(v3, a2, v4);
}

unint64_t RB::DisplayList::FilterStyle<RB::Filter::Custom>::mix(uint64_t a1, const RB::DisplayList::Interpolator::State *a2, uint64_t a3, const RB::DisplayList::CachedTransform *a4)
{
  unint64_t v7 = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Custom>,RB::Filter::Custom const&,RB::DisplayList::Builder &>((size_t *)(*(void *)(*(void *)a4 + 8) + 16), a1 + 64);
  if (a3) {
    int32x4_t v8 = (const RB::Filter::Custom *)(a3 + 64);
  }
  else {
    int32x4_t v8 = 0;
  }
  RB::Filter::Custom::mix((RB::Filter::Custom *)(v7 + 64), a2, v8, a4);
  return v7;
}

uint64_t *RB::DisplayList::FilterStyle<RB::Filter::Custom>::prepare_encode(uint64_t a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::prepare_encode((RB::DisplayList::Style *)a1, a2);
  return RB::Filter::Custom::prepare_encode((RB::Filter::Custom *)(a1 + 64), a2);
}

void *RB::DisplayList::FilterStyle<RB::Filter::Custom>::encode(void *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x22uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Filter::Custom::encode((RB::Filter::Custom *)(a1 + 8), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::FilterStyle<RB::Filter::Custom>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "filter");
  RB::Filter::Custom::print((float32x2_t *)(a1 + 64), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

long long *RB::vector<RB::CustomShader::Value,4ul,unsigned long>::swap_inline(long long *result, long long *a2)
{
  uint64_t v2 = *((void *)a2 + 12);
  uint64_t v3 = *((void *)result + 12);
  if (v2) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    long long v11 = a2[2];
    long long v12 = a2[3];
    long long v13 = a2[4];
    long long v14 = a2[5];
    long long v9 = *a2;
    long long v10 = a2[1];
    long long v5 = result[1];
    *a2 = *result;
    a2[1] = v5;
    long long v6 = result[5];
    long long v8 = result[2];
    long long v7 = result[3];
    a2[4] = result[4];
    a2[5] = v6;
    a2[2] = v8;
    a2[3] = v7;
    result[4] = v13;
    result[5] = v14;
    result[2] = v11;
    result[3] = v12;
    RB::DisplayList::Item *result = v9;
    result[1] = v10;
    if (v3)
    {
      if (v2) {
        return result;
      }
    }
    else
    {
      *((void *)result + 12) = 0;
      if (v2) {
        return result;
      }
    }
    *((void *)a2 + 12) = 0;
  }
  return result;
}

unint64_t RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Custom>,RB::Filter::Custom const&,RB::DisplayList::Builder &>(size_t *a1, uint64_t a2)
{
  unint64_t v3 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 272 > a1[3]) {
    unint64_t v3 = RB::Heap::alloc_slow(a1, 0x110uLL, 15);
  }
  else {
    a1[2] = v3 + 272;
  }
  *(void *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4E8B60;
  *(_DWORD *)(v3 + 64) = *(_DWORD *)a2;
  RB::CustomShader::Closure::Closure((RB::CustomShader::Closure *)(v3 + 72), (const RB::CustomShader::Closure *)(a2 + 8));
  long long v4 = *(_OWORD *)(a2 + 144);
  long long v5 = *(_OWORD *)(a2 + 160);
  long long v6 = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(v3 + 240) = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(v3 + 256) = v6;
  *(_OWORD *)(v3 + 208) = v4;
  *(_OWORD *)(v3 + 224) = v5;
  return v3;
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::Custom>,RB::Filter::Custom const&,RB::DisplayList::Builder &>(size_t *a1, uint64_t a2)
{
  unint64_t v3 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 240 > a1[3]) {
    unint64_t v3 = RB::Heap::alloc_slow(a1, 0xF0uLL, 15);
  }
  else {
    a1[2] = v3 + 240;
  }
  *(void *)(v3 + 16) = 0;
  *(void *)(v3 + 24) = 0;
  *(void *)unint64_t v3 = &unk_26C4EC050;
  *(_DWORD *)(v3 + 32) = *(_DWORD *)a2;
  RB::CustomShader::Closure::Closure((RB::CustomShader::Closure *)(v3 + 40), (const RB::CustomShader::Closure *)(a2 + 8));
  long long v4 = *(_OWORD *)(a2 + 144);
  long long v5 = *(_OWORD *)(a2 + 160);
  long long v6 = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(v3 + 208) = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(v3 + 224) = v6;
  *(_OWORD *)(v3 + 176) = v4;
  *(_OWORD *)(v3 + 192) = v5;
  return v3;
}

void *RB::DisplayList::GenericFilter<RB::Filter::Custom>::~GenericFilter(void *a1)
{
  uint64_t v2 = (const void **)(a1 + 6);
  unint64_t v3 = (const void **)a1[18];
  if (v3) {
    long long v4 = v3;
  }
  else {
    long long v4 = v2;
  }
  if (a1[19])
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[19]);
    unint64_t v3 = (const void **)a1[18];
  }
  if (v3) {
    free(v3);
  }
  long long v6 = (atomic_uint *)a1[5];
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  return a1;
}

void RB::DisplayList::GenericFilter<RB::Filter::Custom>::~GenericFilter(void *a1)
{
  uint64_t v2 = (const void **)(a1 + 6);
  unint64_t v3 = (const void **)a1[18];
  if (v3) {
    long long v4 = v3;
  }
  else {
    long long v4 = v2;
  }
  if (a1[19])
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[19]);
    unint64_t v3 = (const void **)a1[18];
  }
  if (v3) {
    free(v3);
  }
  long long v6 = (atomic_uint *)a1[5];
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  JUMPOUT(0x21669AC10);
}

unint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::Custom>,RB::Filter::Custom const&,RB::DisplayList::Builder &>((size_t *)(*(void *)(a2 + 8) + 16), a1 + 32);
}

void RB::DisplayList::GenericFilter<RB::Filter::Custom>::apply_transform(uint64_t a1, float64x2_t *a2)
{
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::append()
{
  return 0;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::filter_data()
{
  return 4;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::dod(uint64_t a1)
{
  return RBStrokeRef::clip(a1 + 32);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::commutes_with_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::required_depth(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::can_discard_color()
{
  return 0;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::can_render_inline()
{
  return 1;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::prepare(uint64_t a1, uint64_t **a2)
{
  return RB::Filter::Custom::prepare(a1 + 32, a2);
}

Function *RB::DisplayList::GenericFilter<RB::Filter::Custom>::render(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  return RB::Filter::Custom::render(a1 + 32, a4, a2, a3);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::render(uint64_t a1)
{
  return RBStrokeRef::clip(a1 + 32);
}

void RB::DisplayList::GenericFilter<RB::Filter::Custom>::print(float32x2_t *a1, std::string *a2)
{
}

void RB::ObjcEncoderDelegate::encode_message_f<NSData * RB::ObjcEncoderDelegate::encode_message<RB::DisplayList::Contents>(RB::DisplayList::Contents const&)::{lambda(RB::DisplayList::Contents&)#1},NSData * RB::ObjcEncoderDelegate::encode_message<RB::DisplayList::Contents>(RB::DisplayList::Contents const&)::{lambda(RB::DisplayList::Contents&)#2}>(id *a1, RB::DisplayList::Contents **a2, RB::DisplayList::Contents **a3)
{
  RB::ObjcEncoderDelegate::font_set(a1, &v15);
  uint64_t v6 = v15;
  *(_OWORD *)long long v7 = 0u;
  *(_OWORD *)long long v8 = 0u;
  long long v9 = 0u;
  char v10 = 0;
  long long v11 = a1;
  if (v15) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v15 + 8), 1u, memory_order_relaxed);
  }
  uint64_t v12 = v6;
  uint64_t v13 = 0;
  RB::UntypedTable::UntypedTable((uint64_t)v14, 0, 0, 0, 0, 0);
  v14[20] = atomic_fetch_add_explicit(RB::Encoder::_last_encoder_id, 1u, memory_order_relaxed) + 1;
  v14[21] = 0;
  RB::DisplayList::Contents::prepare_encode(*a2, (RB::Encoder *)v7);
  RB::Encoder::prepare_fonts((RB::Encoder *)v7);
  RB::DisplayList::Contents::encode(*a3, (void (****)(CFDataRef *__return_ptr))v7);
  operator new();
}

void sub_21417C468(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a25) {
    RB::ObjcEncoderDelegate::encode_message_f<NSData * RB::ObjcEncoderDelegate::encode_message<RB::DisplayList::Contents>(RB::DisplayList::Contents const&)::{lambda(RB::DisplayList::Contents&)#1},NSData * RB::ObjcEncoderDelegate::encode_message<RB::DisplayList::Contents>(RB::DisplayList::Contents const&)::{lambda(RB::DisplayList::Contents&)#2}>(a25);
  }
  if (a20) {
    free(a20);
  }
  if (a17) {
    free(a17);
  }
  v27 = *(atomic_uint **)(v25 - 40);
  if (v27)
  {
    if (atomic_fetch_add_explicit(v27 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v27 + 8))(v27);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN2RB19ObjcEncoderDelegate16encode_message_fIZNS0_14encode_messageINS_11DisplayList8ContentsEEEP6NSDataRKT_EUlRS7_E_ZNS2_IS4_EES6_S9_EUlSA_E0_EES6_S9_RKT0__block_invoke(uint64_t result)
{
  uint64_t v1 = *(void ***)(result + 32);
  if (v1)
  {
    if (*v1) {
      free(*v1);
    }
    JUMPOUT(0x21669AC10);
  }
  return result;
}

uint64_t OUTLINED_FUNCTION_0(uint64_t result)
{
  return result;
}

uint64_t OUTLINED_FUNCTION_2(uint64_t a1)
{
  return *(void *)a1;
}

void RB::Path::Renderer::resolve(int32x2_t **a1, MTLPixelFormat a2, int a3)
{
  uint64_t v123 = *MEMORY[0x263EF8340];
  uint64_t v6 = ***(void ***)*a1;
  long long v7 = RB::pixel_format_traits(*(void *)&(*a1)[11], a2);
  unint64_t v9 = (unint64_t)a1[2];
  if (is_mul_ok(v9, 0x28uLL))
  {
    v112 = (void (***)(void, int32x2_t **, uint64_t, double, double))a2;
    uint64_t v10 = *((unsigned __int16 *)v7 + 2);
    uint64_t v11 = *v7;
    unint64_t v12 = 40 * v9;
    if (40 * v9 > 0x1000)
    {
      v116 = (long long *)malloc_type_malloc(40 * v9, 0x1A2214C2uLL);
      if (!v116)
      {
        v116 = 0;
LABEL_110:
        free(v116);
        return;
      }
      unint64_t v9 = (unint64_t)a1[2];
    }
    else
    {
      MEMORY[0x270FA5388](v7, v8);
      v116 = (long long *)((char *)&v111 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
      bzero(v116, 40 * v9);
    }
    long long v121 = 0uLL;
    unint64_t v113 = v12;
    if (v9)
    {
      unint64_t v17 = 0;
      float32x2_t v18 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
      uint64_t v19 = 4;
      uint64_t v20 = v116;
      do
      {
        int32x2_t v21 = a1[3];
        *(int32x2_t *)v14.i8 = v21[v19 - 1];
        int32x2_t v22 = (int32x2_t)RB::operator*((float64x2_t *)&v21[v19], (float32x2_t)v21[v19 - 2], v14);
        float32x2_t v26 = (float32x2_t)v22;
        float32x2_t v27 = *(float32x2_t *)v23.i8;
        if (*((unsigned char *)a1 + 9) == 3)
        {
          uint32x2_t v28 = (uint32x2_t)vcgtz_f32(*(float32x2_t *)v23.i8);
          int32x2_t v22 = (int32x2_t)vpmin_u32(v28, v28);
          if (v22.i32[0] < 0)
          {
            v22.i32[0] = *((_DWORD *)a1 + 3);
            *(int32x2_t *)v23.i8 = vcgt_f32(v18, *(float32x2_t *)v23.i8);
            int8x8_t v29 = (int8x8_t)vcltzq_s32(v23).u64[0];
            float32x2_t v26 = (float32x2_t)vbsl_s8(v29, (int8x8_t)vsub_f32(v26, (float32x2_t)vdup_lane_s32(v22, 0)), (int8x8_t)v26);
            float32x2_t v27 = (float32x2_t)vbsl_s8(v29, (int8x8_t)vmla_n_f32(v27, (float32x2_t)0x4000000040000000, *(float *)v22.i32), (int8x8_t)v27);
          }
        }
        v22.i32[0] = 0;
        int32x2_t v30 = (*a1)[21];
        uint32x2_t v31 = (uint32x2_t)vceq_s32(v30, (int32x2_t)0x8000000080000000);
        int8x8_t v32 = (int8x8_t)vdup_lane_s32(vcgt_s32(v22, (int32x2_t)vpmin_u32(v31, v31)), 0);
        float32x2_t v33 = (float32x2_t)vbsl_s8(v32, (int8x8_t)v18, (int8x8_t)vcvt_f32_s32(v30));
        int8x8_t v34 = (int8x8_t)vcvt_f32_s32((*a1)[20]);
        float32x2_t v35 = (float32x2_t)vbsl_s8(v32, (int8x8_t)0x100000001000000, v34);
        v122[0] = v35;
        v122[1] = v33;
        if (a3)
        {
          RB::Rect::intersect(v122, *(double *)&v26, v27, *(double *)&v34, 7.29112205e-304, v24, v25);
          float32x2_t v33 = v122[1];
          float32x2_t v35 = v122[0];
        }
        RB::Bounds::Bounds((int32x2_t *)v120, v35, v33);
        *uint64_t v20 = *(_OWORD *)v120[0].f32;
        if (v17) {
          RB::Bounds::Union((int32x2_t *)&v121, *(int32x2_t *)v20, *(int32x2_t *)((char *)v20 + 8));
        }
        else {
          long long v121 = *v116;
        }
        float64x2_t v119 = *(float64x2_t *)v21[v19].i8;
        float64x2_t v118 = *(float64x2_t *)v21[v19 + 2].i8;
        float64x2_t v117 = *(float64x2_t *)v21[v19 + 4].i8;
        v36 = (RB::RenderFrame ***)*a1;
        int32x2_t v37 = (*a1)[14];
        __int32 v38 = (*a1)[15].i32[0];
        float32x2_t v39 = (float32x2_t)v21[v19 - 2];
        float32x2_t v40 = (float32x2_t)v21[v19 - 1];
        if (*((unsigned __int8 *)a1 + 9) < 2u)
        {
          float v45 = 0.0;
        }
        else
        {
          float v41 = *((float *)a1 + 3);
          float32x2_t v42 = (float32x2_t)COERCE_UNSIGNED_INT(RB::AffineTransform::scale((float64x2_t *)&v21[v19]));
          float32x2_t v43 = vrecpe_f32(v42);
          float32x2_t v44 = vmul_f32(vrecps_f32((float32x2_t)v42.u32[0], v43), v43);
          float v45 = v41 * vmul_f32(v44, vrecps_f32((float32x2_t)v42.u32[0], v44)).f32[0];
          v36 = (RB::RenderFrame ***)*a1;
        }
        RB::RenderFrame::alloc_buffer_region(**v36, (RB::Device *)0x34, 4uLL, 0, v120);
        float32x2_t v46 = v120[0];
        if (v120[0])
        {
          v14.i64[1] = *(void *)&v118.f64[1];
          *(float32x2_t *)v14.i8 = vcvt_f32_f64(v118);
          double v15 = COERCE_DOUBLE(vcvt_f32_f64(v117));
          int32x2_t v16 = (int32x2_t)vadd_f32(v27, v26);
          v47 = (float32x2_t *)(*(void *)(*(void *)v120 + 56) + *(void *)&v120[1]);
          float32x2_t *v47 = vcvt_f32_f64(v119);
          v47[1] = *(float32x2_t *)v14.i8;
          *(double *)&v47[2] = v15;
          v47[3] = (float32x2_t)v37;
          v47[4] = vmla_f32(v39, (float32x2_t)0x3F0000003F000000, v40);
          v47[5].i32[0] = v38;
          v47[5].i32[1] = v16.i32[0];
          v47[6].f32[0] = v45;
          float32x2_t v46 = v120[0];
          long long v13 = *(_OWORD *)v120[1].f32;
        }
        else
        {
          long long v13 = 0uLL;
        }
        *((float32x2_t *)v20 + 2) = v46;
        *(long long *)((char *)v20 + 24) = v13;
        ++v17;
        v48 = a1[2];
        v19 += 10;
        uint64_t v20 = (long long *)((char *)v20 + 40);
      }
      while (v17 < (unint64_t)v48);
      unint64_t v12 = v113;
      if ((a3 & 1) == 0) {
        goto LABEL_27;
      }
    }
    else
    {
      v48 = 0;
      if ((a3 & 1) == 0) {
        goto LABEL_27;
      }
    }
    v14.i64[0] = 0x100000001;
    uint32x2_t v49 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v121 + 8));
    *(uint32x2_t *)&long long v13 = vpmax_u32(v49, v49);
    if ((v13 & 0x80000000) != 0) {
      goto LABEL_109;
    }
LABEL_27:
    uint64_t v114 = v11 | (v10 << 32);
    unsigned int v50 = *((unsigned __int8 *)a1 + 9);
    int v115 = a3;
    if (v50 - 2 >= 2)
    {
      v51 = (RB::Buffer **)v116;
      if (!v50)
      {
LABEL_29:
        if ((v114 & 0x4000000000) == 0
          || (*(int32x2_t *)&long long v13 = vmul_lane_s32(*(int32x2_t *)((char *)&v121 + 8), *(int32x2_t *)((char *)&v121 + 8), 1), (int)v13 < 0x4000))
        {
          int v52 = 1;
          if (!v48) {
            goto LABEL_65;
          }
LABEL_35:
          LODWORD(v119.f64[0]) = 0;
          unint64_t v53 = 0;
          int v54 = v115 ^ 1;
          if ((v114 & 0x4000000000) == 0) {
            int v54 = 1;
          }
          LODWORD(v118.f64[0]) = v54;
          *(void *)&v117.f64[0] = v6 + 80;
          do
          {
            v55 = (int32x2_t *)&v51[5 * v53];
            uint32x2_t v56 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v55[1]);
            *(uint32x2_t *)&long long v13 = vpmax_u32(v56, v56);
            if ((v13 & 0x80000000) == 0)
            {
              v57 = *a1;
              v57[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)*a1, v51[5 * v53 + 2]);
              *(int32x2_t *)&long long v13 = vmovn_s64(*(int64x2_t *)&v51[5 * v53 + 3]);
              *(int32x2_t *)((char *)&v57[23] + 4) = (int32x2_t)v13;
              v58 = a1[3];
              if (v58[10 * v53])
              {
                uint64_t v59 = 0;
                unint64_t v60 = 0;
                do
                {
                  int32x2_t v61 = v58[10 * v53 + 1];
                  uint64_t v62 = *(void *)&v61 + v59;
                  if (*(_DWORD *)(*(void *)&v61 + v59 + 24))
                  {
                    v63 = (RB::RenderFrame ***)*a1;
                    *((_DWORD *)v63 + 49) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)*a1, *(RB::Buffer **)(*(void *)&v61 + v59));
                    v63[25] = (RB::RenderFrame **)vmovn_s64(*(int64x2_t *)(*(void *)&v61 + v59 + 8));
                    if (v52 == 1)
                    {
                      v67 = *a1;
                      if ((*a1)[17].i32[0] == 2) {
                        uint64_t v68 = 131097;
                      }
                      else {
                        uint64_t v68 = 25;
                      }
                      uint64_t v69 = *(unsigned __int8 *)(*(void *)&v61 + v59 + 28);
                      if ((LOBYTE(v118.f64[0]) & 1) == 0)
                      {
                        v67[22].i8[0] = 1;
                        LODWORD(v119.f64[0]) = 1;
                        v67[22].i32[1] = 1;
                      }
                      RB::RenderPass::draw_indexed_primitives(v67, (const char *)(v68 | (v69 << 6) | 0xB00000000), 4, ***(void ***)v67 + 80, 0, *(unsigned int *)(v62 + 24), *v55, v55[1]);
                    }
                    else if (v52)
                    {
                      v70 = *a1;
                      if ((*a1)[17].i32[0] == 2) {
                        int v71 = 131095;
                      }
                      else {
                        int v71 = 23;
                      }
                      v72 = (const char *)(v71 | (*(unsigned __int8 *)(*(void *)&v61 + v59 + 28) << 6));
                      v70[22].i8[0] = 1;
                      v70[22].i32[1] = 1;
                      RB::RenderPass::draw_primitives(v70, v72, 1, 0, 2uLL, *(unsigned int *)(v62 + 24), *v55, v55[1]);
                      uint64_t v73 = v72 & 0x23FC0;
                      v74 = *a1;
                      v74[22].i8[0] = 7;
                      v74[22].i32[1] = 2;
                      RB::RenderPass::draw_indexed_primitives(v74, (const char *)(v73 | 0xB00000018), 4, *(uint64_t *)&v117.f64[0], 3, *(unsigned int *)(v62 + 24), *v55, v55[1]);
                      v75 = *a1;
                      v75[22].i8[0] = 7;
                      v75[22].i32[1] = 3;
                      RB::RenderPass::draw_indexed_primitives(v75, (const char *)(v73 | 0xB00000019), 4, ***(void ***)v75 + 80, 0, *(unsigned int *)(v62 + 24), *v55, v55[1]);
                      LODWORD(v119.f64[0]) = 1;
                    }
                    else
                    {
                      v64 = *a1;
                      uint64_t v65 = 131096;
                      if ((*a1)[17].i32[0] != 2) {
                        uint64_t v65 = 24;
                      }
                      uint64_t v66 = *(unsigned __int8 *)(*(void *)&v61 + v59 + 28);
                      if ((LOBYTE(v118.f64[0]) & 1) == 0)
                      {
                        v64[22].i8[0] = 1;
                        LODWORD(v119.f64[0]) = 1;
                        v64[22].i32[1] = 1;
                      }
                      RB::RenderPass::draw_indexed_primitives(v64, (const char *)(v65 | (v66 << 6) | 0xB00000000), 4, *(uint64_t *)&v117.f64[0], 3, *(unsigned int *)(v62 + 24), *v55, v55[1]);
                    }
                    v63[25] = 0;
                    *((_DWORD *)v63 + 49) = 0;
                    v58 = a1[3];
                  }
                  ++v60;
                  v59 += 32;
                }
                while (v60 < *(void *)&v58[10 * v53]);
              }
            }
            ++v53;
            v51 = (RB::Buffer **)v116;
          }
          while (v53 < (unint64_t)a1[2]);
          unsigned int v50 = *((unsigned __int8 *)a1 + 9);
          unint64_t v12 = v113;
          goto LABEL_66;
        }
        int v52 = 2;
        if (v48) {
          goto LABEL_35;
        }
LABEL_65:
        LODWORD(v119.f64[0]) = 0;
LABEL_66:
        int v76 = v115;
        if (v50 <= 1 || (LODWORD(v13) = *((_DWORD *)a1 + 3), *(float *)&v13 <= 0.0))
        {
          uint64_t v86 = 1;
        }
        else
        {
          LODWORD(v13) = 0;
          if (*((unsigned char *)a1 + 8) == 1) {
            uint64_t v77 = 192;
          }
          else {
            uint64_t v77 = 64;
          }
          uint64_t v78 = v50 == 3;
          if ((*a1)[17].i32[0] == 2) {
            uint64_t v79 = 131098;
          }
          else {
            uint64_t v79 = 26;
          }
          uint32x2_t v80 = (uint32x2_t)vceq_s32(*(int32x2_t *)((char *)&v121 + 8), (int32x2_t)0x8000000080000000);
          int8x8_t v81 = (int8x8_t)vdup_lane_s32(vcgt_s32(*(int32x2_t *)&v13, (int32x2_t)vpmin_u32(v80, v80)), 0);
          RB::Coverage::set_plane(v120, (float32x2_t *)*a1, (float32x2_t)vbsl_s8(v81, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v121)), COERCE_DOUBLE(vbsl_s8(v81, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(*(int32x2_t *)((char *)&v121 + 8)))));
          v82 = (RB::RenderFrame ***)*a1;
          RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)*a1, (RB::Device *)0x1C, 4uLL, 0, v122);
          v83 = (RB::Buffer *)v122[0];
          if (v122[0])
          {
            v84 = (_OWORD *)(*(void *)(*(void *)v122 + 56) + *(void *)&v122[1]);
            long long v85 = *(_OWORD *)v120[0].f32;
            *(_OWORD *)((char *)v84 + 12) = *(_OWORD *)&v120[1].i32[1];
            _OWORD *v84 = v85;
          }
          else
          {
            memset(v122, 0, 24);
          }
          *((_DWORD *)v82 + 46) = RB::RenderFrame::buffer_id(**v82, v83);
          *(RB::RenderFrame ***)((char *)v82 + 188) = (RB::RenderFrame **)vmovn_s64(*(int64x2_t *)v122[1].f32);
          RB::RenderPass::draw_indexed_primitives(*a1, (const char *)(v77 | (v78 << 9) | v79), 4, ***(void ***)*a1 + 80, 0, 1uLL, *(int32x2_t *)&v121, *(int32x2_t *)((char *)&v121 + 8));
          if (a1[2])
          {
            unint64_t v87 = 0;
            unsigned int v88 = vcvtps_s32_f32(*((float *)a1 + 3));
            int v89 = v76 ^ 1;
            if ((v114 & 0x4000000000) == 0) {
              int v89 = 1;
            }
            LODWORD(v118.f64[0]) = v89;
            LODWORD(v117.f64[0]) = -v88;
            v90 = (RB::Buffer **)v116;
            do
            {
              v91 = &v90[5 * v87];
              uint32x2_t v92 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v91[1]);
              *(uint32x2_t *)&long long v13 = vpmax_u32(v92, v92);
              if ((v13 & 0x80000000) == 0)
              {
                v93 = (RB::RenderFrame ***)*a1;
                *((_DWORD *)v93 + 46) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)*a1, v90[5 * v87 + 2]);
                *(int32x2_t *)&long long v13 = vmovn_s64(*(int64x2_t *)&v90[5 * v87 + 3]);
                *(RB::RenderFrame ***)((char *)v93 + 188) = (RB::RenderFrame **)v13;
                v94 = a1[3];
                if (v94[10 * v87])
                {
                  uint64_t v95 = 0;
                  unint64_t v96 = 0;
                  do
                  {
                    int32x2_t v97 = v94[10 * v87 + 1];
                    uint64_t v98 = *(void *)&v97 + v95;
                    if (*(_DWORD *)(*(void *)&v97 + v95 + 24))
                    {
                      v99 = (RB::RenderFrame ***)*a1;
                      *((_DWORD *)v99 + 49) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)*a1, *(RB::Buffer **)(*(void *)&v97 + v95));
                      v99[25] = (RB::RenderFrame **)vmovn_s64(*(int64x2_t *)(*(void *)&v97 + v95 + 8));
                      v103 = (RB::RenderFrame ***)*a1;
                      if ((*a1)[17].i32[0] == 2) {
                        uint64_t v104 = 131099;
                      }
                      else {
                        uint64_t v104 = 27;
                      }
                      uint64_t v105 = *(unsigned __int8 *)(*(void *)&v97 + v95 + 28);
                      if ((LOBYTE(v118.f64[0]) & 1) == 0)
                      {
                        *((unsigned char *)v103 + 176) = 5;
                        *((_DWORD *)v103 + 45) = 0;
                        LODWORD(v119.f64[0]) = 1;
                      }
                      long long v106 = *(_OWORD *)v91;
                      *(_OWORD *)v122[0].f32 = *(_OWORD *)v91;
                      if (*((unsigned char *)a1 + 9) != 3)
                      {
                        RB::Bounds::inset((int32x2_t *)v122, LODWORD(v117.f64[0]), LODWORD(v117.f64[0]), *(double *)&v106, v100, v101, v102);
                        v103 = (RB::RenderFrame ***)*a1;
                      }
                      RB::RenderPass::draw_indexed_primitives((int32x2_t *)v103, (const char *)(v104 | (v105 << 6) | 0x1000000000), 4, *(void *)**v103 + 80, 0, *(unsigned int *)(v98 + 24), (int32x2_t)v122[0], (int32x2_t)v122[1]);
                      v99[25] = 0;
                      *((_DWORD *)v99 + 49) = 0;
                      v94 = a1[3];
                    }
                    ++v96;
                    v95 += 32;
                  }
                  while (v96 < *(void *)&v94[10 * v87]);
                }
              }
              ++v87;
              v90 = (RB::Buffer **)v116;
              int v76 = v115;
            }
            while (v87 < (unint64_t)a1[2]);
          }
          uint64_t v86 = 0;
          unint64_t v12 = v113;
        }
        if ((v114 & 0x4000000000) != 0)
        {
          if ((v76 | LODWORD(v119.f64[0])))
          {
            v107 = (RB::RenderFrame ***)*a1;
            if (v76) {
              char v108 = 6;
            }
            else {
              char v108 = 2;
            }
            *((unsigned char *)v107 + 176) = v108;
            *((_DWORD *)v107 + 45) = 0;
          }
          RB::Bounds::inset((int32x2_t *)&v121, 0xFFFFFFFF, 0xFFFFFFFF, *(double *)&v13, *(double *)v14.i64, v15, v16);
        }
        if (*((unsigned char *)a1 + 9) == 3) {
          uint64_t v109 = 8 * (*((float *)a1 + 3) > 0.0);
        }
        else {
          uint64_t v109 = 0;
        }
        (**v112)(v112, a1, v86 | (2 * (*((unsigned char *)a1 + 8) == 1)) | v109, *(double *)&v121, *((double *)&v121 + 1));
        if ((v114 & 0x4000000000) != 0)
        {
          v110 = (RB::RenderFrame ***)*a1;
          *((unsigned char *)v110 + 176) = 0;
          *((_DWORD *)v110 + 45) = 0;
        }
LABEL_109:
        if (v12 <= 0x1000) {
          return;
        }
        goto LABEL_110;
      }
    }
    else
    {
      LODWORD(v13) = *((_DWORD *)a1 + 3);
      v51 = (RB::Buffer **)v116;
      if (*(float *)&v13 <= 0.0) {
        goto LABEL_29;
      }
    }
    int v52 = 0;
    if (v48) {
      goto LABEL_35;
    }
    goto LABEL_65;
  }
}

void sub_21417D0A8(_Unwind_Exception *exception_object)
{
  if (v1 > 0x1000) {
    free(*(void **)(v2 - 296));
  }
  _Unwind_Resume(exception_object);
}

void RB::Path::Renderer::render_coverage(int32x2_t **a1, int a2, float a3)
{
  unint64_t v5 = &unk_26C4EE8C8;
  float v6 = a3;
  int v7 = a2;
  BOOL may_discard_shape = RB::may_discard_shape(a2);
  RB::Path::Renderer::resolve(a1, (MTLPixelFormat)&v5, may_discard_shape);
}

void RB::Path::Renderer::render(int32x2_t **a1, uint64_t a2, char a3, int a4)
{
  v6[0] = &unk_26C4EE8E0;
  v6[1] = a2;
  char v7 = a3;
  int v8 = a4;
  BOOL may_discard_shape = RB::may_discard_shape(a4);
  RB::Path::Renderer::resolve(a1, (MTLPixelFormat)v6, may_discard_shape);
}

{
  BOOL may_discard_shape;
  void v6[2];
  char v7;
  int v8;

  v6[0] = &unk_26C4EE928;
  v6[1] = a2;
  char v7 = a3;
  int v8 = a4;
  BOOL may_discard_shape = RB::may_discard_shape(a4);
  RB::Path::Renderer::resolve(a1, (MTLPixelFormat)v6, may_discard_shape);
}

void RB::Path::Renderer::render(int32x2_t **a1, uint64_t a2, uint64_t a3, char a4, int a5, float a6)
{
  v8[0] = &unk_26C4EE910;
  v8[1] = a2;
  float32x4_t v8[2] = a3;
  char v9 = a4;
  float v10 = a6;
  int v11 = a5;
  BOOL may_discard_shape = RB::may_discard_shape(a5);
  RB::Path::Renderer::resolve(a1, (MTLPixelFormat)v8, may_discard_shape);
}

{
  void v6[3];
  char v7;
  float v8;
  int v9;

  v6[0] = &unk_26C4E8380;
  v6[1] = a2;
  void v6[2] = a3;
  char v7 = a4;
  int v8 = a6;
  char v9 = a5;
  RB::Path::Renderer::resolve(a1, (MTLPixelFormat)v6, 1);
}

{
  BOOL may_discard_shape;
  void v8[3];
  char v9;
  float v10;
  int v11;

  v8[0] = &unk_26C4EE8F8;
  v8[1] = a2;
  float32x4_t v8[2] = a3;
  char v9 = a4;
  float v10 = a6;
  int v11 = a5;
  BOOL may_discard_shape = RB::may_discard_shape(a5);
  RB::Path::Renderer::resolve(a1, (MTLPixelFormat)v8, may_discard_shape);
}

float32x2_t *RB::Path::ImmediateRenderer::ImmediateRenderer(float32x2_t *this, int32x2_t *a2, float64x2_t *a3, const RB::Coverage::Path *a4)
{
  int v8 = (RB::Path::Accumulator *)&this[1];
  uint64_t v9 = **(void **)a2;
  float v10 = RB::bezier_flatness((RB *)*((unsigned __int8 *)a4 + 29));
  v11.i32[0] = 0;
  int32x2_t v12 = a2[21];
  uint32x2_t v13 = (uint32x2_t)vceq_s32(v12, (int32x2_t)0x8000000080000000);
  int8x8_t v14 = (int8x8_t)vdup_lane_s32(vcgt_s32(v11, (int32x2_t)vpmin_u32(v13, v13)), 0);
  float32x2_t v15 = (float32x2_t)vbsl_s8(v14, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v12));
  float32x2_t v16 = (float32x2_t)vbsl_s8(v14, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a2[20]));
  if (*((unsigned __int8 *)a4 + 29) >= 2u)
  {
    uint32x2_t v17 = (uint32x2_t)vcgtz_f32(v15);
    if ((vpmin_u32(v17, v17).u32[0] & 0x80000000) != 0)
    {
      if (*((float *)a4 + 6) >= 0.0) {
        float v18 = *((float *)a4 + 6);
      }
      else {
        float v18 = 0.0;
      }
      *(float *)v19.i32 = v18 * RB::AffineTransform::scale(a3);
      *(int32x2_t *)v20.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v15);
      v20.i64[0] = vcltzq_s32(v20).u64[0];
      float32x2_t v16 = (float32x2_t)vbsl_s8(*(int8x8_t *)v20.i8, (int8x8_t)vsub_f32(v16, (float32x2_t)vdup_lane_s32(v19, 0)), (int8x8_t)v16);
      float32x2_t v15 = (float32x2_t)vbsl_s8(*(int8x8_t *)v20.i8, (int8x8_t)vmla_n_f32(v15, (float32x2_t)0x4000000040000000, *(float *)v19.i32), (int8x8_t)v15);
    }
  }
  RB::Path::Accumulator::Accumulator((uint64_t)v8, v9, (uint64_t *)a4, a3, v10, v16, v15);
  if (this[36].i8[0]) {
    RB::Path::Accumulator::commit_buffer(v8);
  }
  int32x2_t v22 = (float32x2_t *)this[33];
  this[40] = (float32x2_t)v22;
  if (v22)
  {
    if (this[36].i8[0]) {
      RB::Path::Accumulator::commit_buffer(v8);
    }
    int32x2_t v22 = this + 16;
    if (this[32]) {
      int32x2_t v22 = (float32x2_t *)this[32];
    }
  }
  this[41] = (float32x2_t)v22;
  uint32x2_t v23 = (uint32x2_t)vcgt_f32(this[9], this[8]);
  unsigned __int32 v24 = vpmin_u32(v23, v23).u32[0];
  float32x2_t v25 = 0;
  double v26 = 0.0;
  if ((v24 & 0x80000000) != 0)
  {
    *(float32x2_t *)v21.i8 = this[9];
    double v26 = RB::Rect::from_bounds(this[8], v21);
  }
  *(double *)&this[42] = v26;
  this[43] = v25;
  *(_OWORD *)this[44].f32 = xmmword_2142181C0;
  *(_OWORD *)this[46].f32 = xmmword_2142181D0;
  this[48] = 0;
  this[49] = 0;
  __int8 v27 = *((unsigned char *)a4 + 28);
  __int8 v28 = *((unsigned char *)a4 + 29);
  float v29 = 0.0;
  if ((v28 & 0xFE) == 2)
  {
    float v30 = *((float *)a4 + 6);
    float v29 = RB::AffineTransform::scale(a3) * v30;
  }
  this[50] = (float32x2_t)a2;
  this[51].i8[0] = v27;
  this[51].i8[1] = v28;
  this[51].f32[1] = v29;
  this[52] = (float32x2_t)1;
  this[53] = (float32x2_t)&this[40];
  return this;
}

void sub_21417D594(_Unwind_Exception *a1)
{
  RB::Path::Accumulator::~Accumulator(v1);
  _Unwind_Resume(a1);
}

int32x2_t *RB::Path::Renderer::render_coverage(float,RB::BlendMode)::Paint::fill(uint64_t a1, float32x2_t **a2, __int16 a3, int32x2_t a4, int32x2_t a5)
{
  int32x2_t v7 = a4;
  a4.i32[0] = 0;
  uint64_t v9 = *a2;
  uint32x2_t v10 = (uint32x2_t)vceq_s32(a5, (int32x2_t)0x8000000080000000);
  int8x8_t v11 = (int8x8_t)vdup_lane_s32(vcgt_s32(a4, (int32x2_t)vpmin_u32(v10, v10)), 0);
  RB::Coverage::set_plane((float32x2_t *)&v22, *a2, (float32x2_t)vbsl_s8(v11, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v7)), COERCE_DOUBLE(vbsl_s8(v11, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a5))));
  _S0 = *(_DWORD *)(a1 + 8);
  __asm { FCVT            H0, S0 }
  WORD6(v23) = _S0;
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v9, (RB::Device *)0x20, 4uLL, 0, &v24);
  uint32x2_t v17 = v24;
  if (v24)
  {
    float v18 = (_OWORD *)(*((void *)v24 + 7) + v25.i64[0]);
    long long v19 = v23;
    *float v18 = v22;
    v18[1] = v19;
  }
  else
  {
    unsigned __int32 v24 = 0;
    int64x2_t v25 = 0uLL;
  }
  v9[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v9, v17);
  *(int32x2_t *)((char *)&v9[23] + 4) = vmovn_s64(v25);
  uint64_t v20 = 17;
  if (v9[17].i32[0] == 2) {
    uint64_t v20 = 131089;
  }
  return RB::RenderPass::draw_indexed_primitives((int32x2_t *)v9, (const char *)(v20 & 0xFFFFFFFFFFFF003FLL | ((unint64_t)(a3 & 0x3FF) << 6) | ((unint64_t)(*(_DWORD *)(a1 + 12) & 0x3F) << 32)), 4, ***(void ***)v9 + 80, 0, 1uLL, v7, a5);
}

int32x2_t *RB::Path::Renderer::render(RB::Fill::Color const&,BOOL,RB::BlendMode)::Paint::fill(uint64_t a1, float32x2_t **a2, __int16 a3, int32x2_t a4, int32x2_t a5)
{
  int32x2_t v7 = a4;
  a4.i32[0] = 0;
  uint64_t v9 = *a2;
  uint32x2_t v10 = (uint32x2_t)vceq_s32(a5, (int32x2_t)0x8000000080000000);
  int8x8_t v11 = (int8x8_t)vdup_lane_s32(vcgt_s32(a4, (int32x2_t)vpmin_u32(v10, v10)), 0);
  *(float *)&double v12 = RB::Coverage::set_plane((float32x2_t *)&v19, *a2, (float32x2_t)vbsl_s8(v11, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v7)), COERCE_DOUBLE(vbsl_s8(v11, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a5))));
  *(float16x4_t *)&v20[12] = RB::Fill::Color::prepare(*(void *)(a1 + 8), v9[15].u8[4], v12);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v9, (RB::Device *)0x24, 4uLL, 0, &v21);
  uint32x2_t v13 = v21;
  if (v21)
  {
    uint64_t v14 = *((void *)v21 + 7) + v22.i64[0];
    long long v15 = v19;
    long long v16 = *(_OWORD *)v20;
    *(_DWORD *)(v14 + 32) = *(_DWORD *)&v20[16];
    *(_OWORD *)uint64_t v14 = v15;
    *(_OWORD *)(v14 + 16) = v16;
  }
  else
  {
    int32x4_t v21 = 0;
    int64x2_t v22 = 0uLL;
  }
  v9[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v9, v13);
  *(int32x2_t *)((char *)&v9[23] + 4) = vmovn_s64(v22);
  uint64_t v17 = 18;
  if (v9[17].i32[0] == 2) {
    uint64_t v17 = 131090;
  }
  return RB::RenderPass::draw_indexed_primitives((int32x2_t *)v9, (const char *)(v17 & 0xFFFFFFFFFFFF003FLL | ((unint64_t)(a3 & 0x3FF) << 6) | ((unint64_t)*(unsigned __int8 *)(a1 + 16) << 16) | ((unint64_t)(*(_DWORD *)(a1 + 20) & 0x3F) << 32)), 4, ***(void ***)v9 + 80, 0, 1uLL, v7, a5);
}

int32x2_t *RB::Path::Renderer::render(RB::Fill::Gradient const&,RB::AffineTransform const&,BOOL,float,RB::BlendMode)::Paint::fill(uint64_t a1, float32x2_t **a2, __int16 a3, int32x2_t a4, int32x2_t a5)
{
  int32x2_t v7 = a4;
  a4.i32[0] = 0;
  uint64_t v9 = *a2;
  uint32x2_t v10 = (uint32x2_t)vceq_s32(a5, (int32x2_t)0x8000000080000000);
  int8x8_t v11 = (int8x8_t)vdup_lane_s32(vcgt_s32(a4, (int32x2_t)vpmin_u32(v10, v10)), 0);
  RB::Coverage::set_plane((float32x2_t *)&v22, *a2, (float32x2_t)vbsl_s8(v11, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v7)), COERCE_DOUBLE(vbsl_s8(v11, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a5))));
  LODWORD(v12) = *(_DWORD *)(a1 + 28);
  RB::Fill::Gradient::set_gradient(*(float32x2_t **)(a1 + 8), (uint64_t)v23 + 12, (uint64_t)v9, *(float64x2_t **)(a1 + 16), v12);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v9, (RB::Device *)0x54, 4uLL, 0, &v25);
  uint32x2_t v13 = v25;
  if (v25)
  {
    uint64_t v14 = *((void *)v25 + 7) + v26.i64[0];
    long long v15 = v22;
    *(_OWORD *)(v14 + 16) = v23[0];
    long long v16 = v23[3];
    long long v17 = v23[2];
    long long v18 = v23[1];
    *(_DWORD *)(v14 + 80) = v24;
    *(_OWORD *)(v14 + 48) = v17;
    *(_OWORD *)(v14 + 64) = v16;
    *(_OWORD *)(v14 + 32) = v18;
    *(_OWORD *)uint64_t v14 = v15;
  }
  else
  {
    int64x2_t v25 = 0;
    int64x2_t v26 = 0uLL;
  }
  v9[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v9, v13);
  *(int32x2_t *)((char *)&v9[23] + 4) = vmovn_s64(v26);
  if (v9[17].i32[0] == 2) {
    int v19 = 131091;
  }
  else {
    int v19 = 19;
  }
  int64x2_t v25 = (RB::Buffer *)(v19 & 0xFFFF003F | ((a3 & 0x3FF) << 6));
  RB::Fill::Gradient::set_fill_state(*(void *)(a1 + 8), (int *)&v25, (uint64_t)v9, *(float *)(a1 + 28));
  unsigned int v20 = HIDWORD(v25) & 0xFFFFFFC0 | *(_DWORD *)(a1 + 32) & 0x3F;
  LODWORD(v25) = v25 & 0xFFFEFFFF | (*(unsigned __int8 *)(a1 + 24) << 16);
  HIDWORD(v25) = v20;
  double result = RB::RenderPass::draw_indexed_primitives((int32x2_t *)v9, (const char *)v25, 4, ***(void ***)v9 + 80, 0, 1uLL, v7, a5);
  v9[28] = 0;
  v9[27].i32[1] = 0;
  return result;
}

void RB::Path::Renderer::render(RB::Fill::MeshGradient const&,RB::AffineTransform const&,BOOL,float,RB::BlendMode)::Paint::fill(uint64_t a1, RB::RenderPass **a2, __int16 a3, int32x2_t a4, int32x2_t a5)
{
  v5[0] = a4;
  v5[1] = a5;
  RB::render_mesh_gradient(*a2, *(float64x2_t **)(a1 + 16), *(RB::Fill::MeshGradient **)(a1 + 8), a3, *(unsigned __int8 *)(a1 + 24), *(_DWORD *)(a1 + 32), v5, *(float *)(a1 + 28));
}

int32x2_t *RB::Path::Renderer::render(RB::Shader::Globals<RB::Shader::PlaneGlobals,RB::Shader::ImageGlobals> &,BOOL,RB::BlendMode)::Paint::fill(uint64_t a1, float32x2_t **a2, __int16 a3, int32x2_t a4, int32x2_t a5)
{
  int32x2_t v7 = a4;
  a4.i32[0] = 0;
  uint64_t v9 = *a2;
  uint32x2_t v10 = (uint32x2_t)vceq_s32(a5, (int32x2_t)0x8000000080000000);
  int8x8_t v11 = (int8x8_t)vdup_lane_s32(vcgt_s32(a4, (int32x2_t)vpmin_u32(v10, v10)), 0);
  RB::Coverage::set_plane(*(float32x2_t **)(a1 + 8), *a2, (float32x2_t)vbsl_s8(v11, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v7)), COERCE_DOUBLE(vbsl_s8(v11, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a5))));
  double v12 = *(long long **)(a1 + 8);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v9, (RB::Device *)0x70, 4uLL, 0, &v23);
  uint32x2_t v13 = v23;
  if (v23)
  {
    uint64_t v14 = (_OWORD *)(*((void *)v23 + 7) + v24.i64[0]);
    long long v15 = v12[2];
    long long v16 = *v12;
    v14[1] = v12[1];
    float32x2_t v14[2] = v15;
    long long v17 = v12[6];
    long long v19 = v12[3];
    long long v18 = v12[4];
    v14[5] = v12[5];
    v14[6] = v17;
    _OWORD v14[3] = v19;
    v14[4] = v18;
    *uint64_t v14 = v16;
  }
  else
  {
    long long v23 = 0;
    int64x2_t v24 = 0uLL;
  }
  v9[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v9, v13);
  *(int32x2_t *)((char *)&v9[23] + 4) = vmovn_s64(v24);
  if (v9[17].i32[0] == 2) {
    int v20 = 131093;
  }
  else {
    int v20 = 21;
  }
  long long v23 = (RB::Buffer *)(v20 & 0xFFFF003F | (unint64_t)((unsigned __int16)(a3 & 0x3FF) << 6));
  RB::RenderState::set_image((int *)&v23, *(void *)(a1 + 8) + 28, v9[15].u8[4]);
  unsigned int v21 = HIDWORD(v23) & 0xFFFFFFC0 | *(_DWORD *)(a1 + 20) & 0x3F;
  LODWORD(v23) = v23 & 0xFFFEFFFF | (*(unsigned __int8 *)(a1 + 16) << 16);
  HIDWORD(v23) = v21;
  return RB::RenderPass::draw_indexed_primitives((int32x2_t *)v9, (const char *)v23, 4, ***(void ***)v9 + 80, 0, 1uLL, v7, a5);
}

void RB::Path::Renderer::render(RB::Fill::Custom const&,RB::AffineTransform const&,BOOL,float,RB::BlendMode)::Paint::fill(uint64_t a1, uint64_t ***a2, __int16 a3, int32x2_t a4, int32x2_t a5)
{
  uint64_t v9 = *a2;
  uint32x2_t v10 = RB::Fill::Custom::function(*(RB::Fill::Custom **)(a1 + 8), *a2);
  if (v10)
  {
    int8x8_t v11 = (Function *)v10;
    RB::RenderFrame::alloc_buffer_region((RB::RenderFrame *)**v9, (RB::Device *)(*((unsigned int *)v10 + 20) + 56), 4uLL, 0, &v19);
    if (v19)
    {
      v12.i32[0] = 0;
      uint64_t v13 = *((void *)v19 + 7) + v20.i64[0];
      uint32x2_t v14 = (uint32x2_t)vceq_s32(a5, (int32x2_t)0x8000000080000000);
      int8x8_t v15 = (int8x8_t)vdup_lane_s32(vcgt_s32(v12, (int32x2_t)vpmin_u32(v14, v14)), 0);
      RB::Coverage::set_plane((float32x2_t *)v13, (float32x2_t *)v9, (float32x2_t)vbsl_s8(v15, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a4)), COERCE_DOUBLE(vbsl_s8(v15, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a5))));
      if (RB::Fill::Custom::set_custom(*(void *)(a1 + 8), (float32x2_t *)(v13 + 28), (uint64_t)v11, v13 + 56, (uint64_t)v9, *(float64x2_t **)(a1 + 16), *(float *)(a1 + 28)))
      {
        *((_DWORD *)v9 + 46) = RB::RenderFrame::buffer_id((RB::RenderFrame *)**v9, v19);
        *(uint64_t **)((char *)v9 + 188) = (uint64_t *)vmovn_s64(v20);
        if (*((_DWORD *)v9 + 34) == 2) {
          int v16 = 131094;
        }
        else {
          int v16 = 22;
        }
        long long v18 = (const char *)(v16 & 0xFFFF003F | ((a3 & 0x3FF) << 6));
        RB::Fill::Custom::set_fill_state(*(RB::Fill::Custom **)(a1 + 8), (RB::RenderState *)&v18, v11, (unint64_t **)v9);
        unsigned int v17 = HIDWORD(v18) & 0xFFFFFFC0 | *(_DWORD *)(a1 + 32) & 0x3F;
        LODWORD(v18) = v18 & 0xFFFEFFFF | (*(unsigned __int8 *)(a1 + 24) << 16);
        HIDWORD(v18) = v17;
        RB::RenderPass::draw_indexed_primitives((int32x2_t *)v9, v18, 4, *(void *)**v9 + 80, 0, 1uLL, a4, a5);
        RB::Fill::Custom::reset_custom(*(RB::Fill::Custom **)(a1 + 8), (RB::RenderPass *)v9);
      }
    }
  }
}

uint64_t RB::FontMixer::shared(RB::FontMixer *this)
{
  {
    operator new();
  }
  return RB::FontMixer::shared(void)::shared;
}

void sub_21417DE28(_Unwind_Exception *a1)
{
}

char *RB::FontMixer::get_info(RB::FontMixer *this, CGFont *a2, CGFont *a3)
{
  unsigned int Identifier = CGFontGetIdentifier();
  uint64_t v7 = CGFontGetIdentifier();
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  unint64_t v10 = ~((uint64_t)(int)(v7 ^ Identifier) << 32) + (int)(v7 ^ Identifier);
  unint64_t v11 = (v10 ^ (v10 >> 22)) + ~((v10 ^ (v10 >> 22)) << 13);
  unint64_t v12 = (9 * (v11 ^ (v11 >> 8))) ^ ((9 * (v11 ^ (v11 >> 8))) >> 15);
  unint64_t v13 = (v12 + ~(v12 << 27)) ^ ((v12 + ~(v12 << 27)) >> 31);
  uint64_t v14 = 4 * (v13 & 7);
  int8x8_t v15 = (char *)this + 16;
  unint64_t v16 = (v13 & 7) << 7;
  signed int v17 = 0x80000000;
  do
  {
    int v18 = *(_DWORD *)&v15[128 * (v13 & 7)];
    if (v18 == Identifier && *(_DWORD *)&v15[v16 + 4] == v7
      || v18 == v7 && *(_DWORD *)&v15[v16 + 4] == Identifier)
    {
      int v27 = *((_DWORD *)this + 1) + 1;
      *((_DWORD *)this + 1) = v27;
      long long v22 = &v15[128 * (v13 & 7)];
      *((_DWORD *)v22 + 2) = v27;
      return v22;
    }
    int v19 = *((_DWORD *)this + 1);
    if (v19 - *((_DWORD *)v15 + 2) > v17)
    {
      signed int v17 = v19 - *((_DWORD *)v15 + 2);
      uint64_t v9 = v8;
    }
    ++v8;
    v15 += 32;
  }
  while (v8 != 4);
  uint64_t v20 = v9 + v14;
  unsigned int v21 = (char *)this + 32 * v9 + 32 * v14;
  *((void *)v21 + 2) = Identifier | (unint64_t)(v7 << 32);
  long long v22 = v21 + 16;
  *((_DWORD *)this + 1) = v19 + 1;
  *((_DWORD *)v22 + 2) = v19 + 1;
  long long v23 = v22 + 13;
  *((_WORD *)v22 + 6) = 0;
  id v24 = +[RBDecodedFontMetadata fontMetadata:]((uint64_t)RBDecodedFontMetadata, a2);
  if (v24)
  {
    int64x2_t v25 = (const void *)-[RBDecodedFontMetadata fontUID]((uint64_t)v24);
    if (v25) {
      int64x2_t v26 = CFRetain(v25);
    }
    else {
      int64x2_t v26 = 0;
    }
    *long long v23 = 1;
  }
  else
  {
    int64x2_t v26 = (const void *)CGFontCopyName();
  }
  id v28 = +[RBDecodedFontMetadata fontMetadata:]((uint64_t)RBDecodedFontMetadata, a3);
  if (v28)
  {
    float v29 = (const void *)-[RBDecodedFontMetadata fontUID]((uint64_t)v28);
    if (v29) {
      float v30 = CFRetain(v29);
    }
    else {
      float v30 = 0;
    }
    *long long v23 = 1;
    if (v26) {
      goto LABEL_24;
    }
  }
  else
  {
    float v30 = (const void *)CGFontCopyName();
    if (v26)
    {
LABEL_24:
      if (v30)
      {
        if (CFEqual(v26, v30))
        {
          v22[12] = 1;
          *((void *)this + 4 * v20 + 5) = CGFontGetVariationAxes();
        }
        CFRelease(v30);
      }
      uint32x2_t v31 = v26;
      goto LABEL_29;
    }
  }
  if (v30)
  {
    uint32x2_t v31 = v30;
LABEL_29:
    CFRelease(v31);
  }
  return v22;
}

void sub_21417E088(_Unwind_Exception *a1)
{
  CFRelease(v1);
  CFRelease(v2);
  _Unwind_Resume(a1);
}

uint64_t RB::FontMixer::can_mix(os_unfair_lock_s *a1, CGFont *a2, CGFont *a3, uint64_t *a4)
{
  if (a2 == a3) {
    return 1;
  }
  BOOL v5 = 0;
  if (a2 && a3)
  {
    os_unfair_lock_lock(a1);
    info = RB::FontMixer::get_info((RB::FontMixer *)a1, a2, a3);
    unint64_t v10 = info;
    if (a4 && info[13])
    {
      id v11 = +[RBDecodedFontMetadata fontMetadata:]((uint64_t)RBDecodedFontMetadata, a2);
      *a4 = -[RBDecodedFontMetadata glyphMap]((uint64_t)v11);
      id v12 = +[RBDecodedFontMetadata fontMetadata:]((uint64_t)RBDecodedFontMetadata, a3);
      a4[1] = -[RBDecodedFontMetadata glyphMap]((uint64_t)v12);
    }
    BOOL v5 = v10[12] != 0;
    os_unfair_lock_unlock(a1);
  }
  return v5;
}

void sub_21417E170(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void RB::FontMixer::mix(os_unfair_lock_s *this@<X0>, CGFont *cf@<X1>, CGFont *a3@<X2>, uint32_t a4@<S0>, void *a5@<X8>)
{
  uint64_t v61 = *MEMORY[0x263EF8340];
  if (cf != a3 && *(float *)&a4 != 0.0)
  {
    if (!cf || !a3)
    {
      *a5 = 0;
      return;
    }
    os_unfair_lock_lock(this);
    info = RB::FontMixer::get_info((RB::FontMixer *)this, cf, a3);
    id v11 = info;
    if (!info[12]) {
      goto LABEL_64;
    }
    if (*(float *)&a4 == 1.0 && !info[13])
    {
      CFRetain(a3);
      *a5 = a3;
LABEL_67:
      os_unfair_lock_unlock(this);
      return;
    }
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    int v14 = *(_DWORD *)info;
    int v15 = *((_DWORD *)info + 1);
    unint64_t v16 = this + 265;
    signed int v17 = 0x80000000;
    while (1)
    {
      if ((uint32_t os_unfair_lock_opaque = v16[-3]._os_unfair_lock_opaque, os_unfair_lock_opaque == v14)
        && v16[-2]._os_unfair_lock_opaque == v15
        || os_unfair_lock_opaque == v15 && v16[-2]._os_unfair_lock_opaque == v14)
      {
        if (*(float *)&v16[-1]._os_unfair_lock_opaque == *(float *)&a4) {
          break;
        }
      }
      uint32_t v19 = this[2]._os_unfair_lock_opaque;
      float v20 = *(float *)&v16->_os_unfair_lock_opaque;
      v16 += 6;
      signed int v21 = v19 - LODWORD(v20);
      if ((int)(v19 - LODWORD(v20)) > v17) {
        uint64_t v12 = v13;
      }
      if (v21 > v17) {
        signed int v17 = v21;
      }
      if (++v13 == 4)
      {
        long long v22 = &this[6 * v12];
        long long v23 = *(const void **)&v22[260]._os_unfair_lock_opaque;
        if (v23)
        {
          CFRelease(v23);
          uint32_t v19 = this[2]._os_unfair_lock_opaque;
        }
        id v24 = (CFTypeRef *)&v22[260];
        *(void *)&v22[260]._uint32_t os_unfair_lock_opaque = 0;
        int64x2_t v25 = &this[6 * v12];
        *(void *)&v25[262]._uint32_t os_unfair_lock_opaque = *(void *)v11;
        v25[264]._uint32_t os_unfair_lock_opaque = a4;
        this[2]._uint32_t os_unfair_lock_opaque = v19 + 1;
        v25[265]._uint32_t os_unfair_lock_opaque = v19 + 1;
        if (*((void *)v11 + 2))
        {
          uint64_t v59 = 0;
          unint64_t v60 = 0;
          uint64_t Variations = CGFontGetVariations();
          uint64_t v27 = CGFontGetVariations();
          unint64_t v29 = *((void *)v11 + 2);
          if (v29 >> 60) {
            goto LABEL_56;
          }
          uint64_t v30 = v27;
          size_t v31 = 16 * v29;
          if (16 * v29 <= 0x1000)
          {
            MEMORY[0x270FA5388](v27, v28);
            int8x8_t v32 = (char *)&v58 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0);
            bzero(v32, v31);
            goto LABEL_36;
          }
          int8x8_t v32 = (char *)malloc_type_malloc(16 * v29, 0x16ADB4B9uLL);
          if (!v32) {
            goto LABEL_55;
          }
LABEL_36:
          uint64_t v40 = *((void *)v11 + 2);
          if (v40)
          {
            uint64_t v41 = 0;
            uint64_t v42 = *((void *)v11 + 3);
            uint64_t v44 = v59;
            float32x2_t v43 = v60;
            while (1)
            {
              uint64_t v45 = v42 + 40 * v41;
              int v46 = *(_DWORD *)(v45 + 8);
              double v47 = *(double *)(v45 + 32);
              double v48 = v47;
              if (v43) {
                break;
              }
LABEL_43:
              if (v44) {
                goto LABEL_46;
              }
LABEL_51:
              unint64_t v53 = &v32[16 * v41];
              *(_DWORD *)unint64_t v53 = v46;
              *((double *)v53 + 1) = v48 + (v47 - v48) * *(float *)&a4;
              if (++v41 == v40) {
                goto LABEL_52;
              }
            }
            uint32x2_t v49 = v43;
            unsigned int v50 = (double *)(Variations + 8);
            while (*((_DWORD *)v50 - 2) != v46)
            {
              v50 += 2;
              if (!--v49)
              {
                double v48 = v47;
                goto LABEL_43;
              }
            }
            double v48 = *v50;
            if (!v44) {
              goto LABEL_51;
            }
LABEL_46:
            uint64_t v51 = v44;
            int v52 = (double *)(v30 + 8);
            while (*((_DWORD *)v52 - 2) != v46)
            {
              v52 += 2;
              if (!--v51) {
                goto LABEL_51;
              }
            }
            double v47 = *v52;
            goto LABEL_51;
          }
LABEL_52:
          CFTypeRef v54 = (CFTypeRef)CGFontCreateWithVariations();
          if (*v24) {
            CFRelease(*v24);
          }
          *id v24 = v54;
          if (v31 > 0x1000)
          {
LABEL_55:
            free(v32);
LABEL_56:
            CFTypeRef v54 = *v24;
          }
          if (v54) {
            goto LABEL_70;
          }
        }
        CFTypeRef v54 = CFRetain(cf);
        *id v24 = v54;
        if (v54)
        {
LABEL_70:
          CFTypeRef v55 = CFRetain(v54);
          v36 = v55;
          if (v55)
          {
            CFRetain(v55);
            CFTypeRef v56 = CFRetain(v36);
            v57 = v56;
            if (v56)
            {
              float32x2_t v39 = (char *)CFRetain(v56);
              unint64_t v60 = v39;
              CFRelease(v57);
              if (v39)
              {
                *a5 = CFRetain(v39);
                CFRelease(v39);
LABEL_63:
                CFRelease(v39);
LABEL_66:
                CFRelease(v36);
                goto LABEL_67;
              }
            }
LABEL_65:
            *a5 = 0;
            goto LABEL_66;
          }
        }
        goto LABEL_64;
      }
    }
    int v33 = this[2]._os_unfair_lock_opaque + 1;
    this[2]._uint32_t os_unfair_lock_opaque = v33;
    v16->_uint32_t os_unfair_lock_opaque = v33;
    int8x8_t v34 = *(const void **)&v16[-5]._os_unfair_lock_opaque;
    if (v34)
    {
      CFTypeRef v35 = CFRetain(v34);
      v36 = v35;
      if (v35)
      {
        CFRetain(v35);
        CFTypeRef v37 = CFRetain(v36);
        __int32 v38 = v37;
        if (v37)
        {
          float32x2_t v39 = (char *)CFRetain(v37);
          unint64_t v60 = v39;
          CFRelease(v38);
          if (v39)
          {
            *a5 = CFRetain(v39);
            CFRelease(v39);
            goto LABEL_63;
          }
        }
        goto LABEL_65;
      }
    }
LABEL_64:
    *a5 = 0;
    goto LABEL_67;
  }
  if (cf) {
    CFRetain(cf);
  }
  *a5 = cf;
}

void sub_21417E5BC(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

CFTypeRef *RB::cf_ptr<RB::cf_ptr<CGFont *>>::~cf_ptr(CFTypeRef *a1)
{
  CFTypeRef v2 = *a1;
  if (v2)
  {
    CFRelease(v2);
    if (*a1) {
      CFRelease(*a1);
    }
  }
  return a1;
}

void sub_21417E68C(_Unwind_Exception *exception_object)
{
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL RB::FontMixer::GlyphEquality::operator()(const __CFDictionary **a1, void *key, void *a3)
{
  unsigned int v3 = a3;
  unsigned __int16 v4 = (unsigned __int16)key;
  CFDictionaryRef v6 = *a1;
  if (v6)
  {
    value = 0;
    if (CFDictionaryGetValueIfPresent(v6, (const void *)key, (const void **)&value)) {
      unsigned __int16 v4 = (unsigned __int16)value;
    }
  }
  CFDictionaryRef v7 = a1[1];
  if (v7)
  {
    value = 0;
    if (CFDictionaryGetValueIfPresent(v7, (const void *)v3, (const void **)&value)) {
      LOWORD(v3) = (_WORD)value;
    }
  }
  return v4 == (unsigned __int16)v3;
}

void RB::Symbol::Presentation::apply_interpolations(RB::Symbol::Presentation *this)
{
  uint64_t v156 = *MEMORY[0x263EF8340];
  uint64_t v1 = *((unsigned int *)this + 212);
  if (v1 >= 2)
  {
    CFTypeRef v2 = this;
    unsigned int v3 = (char *)this + 8;
    id v150 = 0;
    uint64_t v120 = (uint64_t)this + 2032;
    uint64_t v4 = (v1 - 1);
    v122 = (char *)this + 8;
    uint64_t v123 = this;
    while (1)
    {
      uint64_t v5 = v1 - 1;
      CFDictionaryRef v6 = (char *)*((void *)v2 + 105);
      if (!v6) {
        CFDictionaryRef v6 = v3;
      }
      uint64_t v135 = (v1 - 1);
      v136 = v6;
      v132 = &v6[416 * v5];
      uint64_t v7 = *((void *)v132 + 49);
      if (!v7) {
        goto LABEL_158;
      }
      unsigned int v8 = *((_DWORD *)v2 + 212);
      if (v1 + 1 != v8)
      {
        if (v8 > v5)
        {
          float v16 = *(float *)v7;
          if (*(float *)v7 < 0.0) {
            float v16 = 0.0;
          }
          if (v16 > 1.0) {
            float v16 = 1.0;
          }
          uint64_t v17 = v4;
          do
          {
            if (v17 == v135) {
              float v18 = v16;
            }
            else {
              float v18 = 1.0 - v16;
            }
            uint32_t v19 = &v136[416 * v17];
            float v20 = v19 + 16;
            if (*((void *)v19 + 47)) {
              float v20 = (char *)*((void *)v19 + 47);
            }
            uint64_t v21 = *((unsigned int *)v19 + 96);
            if (v21)
            {
              uint64_t v22 = 120 * v21;
              long long v23 = (float *)(v20 + 32);
              do
              {
                *long long v23 = *v23 * v18;
                v23 += 30;
                v22 -= 120;
              }
              while (v22);
            }
            ++v17;
          }
          while (v8 != v17);
        }
        goto LABEL_157;
      }
      unint64_t v9 = (unint64_t)&v136[416 * v1];
      int v10 = *(unsigned __int8 *)(v7 + 8);
      uint64_t v127 = v1 - 1;
      if (v10
        && (this = *(RB::Symbol::Presentation **)(*(void *)v9 + 16)) != 0
        && *(void *)(*(void *)v132 + 16)
        && (((*(unsigned __int16 *)(*(void *)v132 + 88) | (*(unsigned __int8 *)(*(void *)v132 + 90) << 16)) ^ (*(unsigned __int16 *)(*(void *)v9 + 88) | (*(unsigned __int8 *)(*(void *)v9 + 90) << 16))) & 0x200FF) == 0)
      {
        this = (RB::Symbol::Presentation *)-[RB::Symbol::Presentation canBeInterpolatedWith:](this, "canBeInterpolatedWith:");
        int v128 = (int)this;
      }
      else
      {
        int v128 = 0;
      }
      id v11 = &v136[416 * v1];
      uint64_t v12 = v11 + 16;
      unint64_t v129 = v9;
      v130 = v11 + 384;
      LODWORD(v11) = *((_DWORD *)v11 + 96);
      uint64_t v13 = &v136[416 * v135];
      v133 = v13 + 16;
      v134 = v12;
      v131 = (unsigned int *)(v13 + 384);
      unint64_t v14 = (*((_DWORD *)v13 + 96) + v11);
      uint64_t v149 = 0;
      uint64_t v126 = v4;
      if (v14 <= 0x200) {
        break;
      }
      v147 = malloc_type_malloc(8 * v14, 0xD3FAFDCuLL);
      char v148 = 1;
      if (v147) {
        goto LABEL_32;
      }
      int v15 = 0;
LABEL_86:
      float v72 = *(float *)v7;
      if (*(float *)v7 < 0.0) {
        float v72 = 0.0;
      }
      v154 = 0;
      uint64_t v155 = 0x300000000;
      if (v72 <= 1.0) {
        float v73 = v72;
      }
      else {
        float v73 = 1.0;
      }
      v137 = v2;
      unint64_t v138 = v129;
      v139 = v132;
      uint64_t v140 = v7;
      v141 = &v151;
      v142 = (char *)&v146 + 4;
      v143 = &v146;
      char v144 = v128;
      v145 = &v150;
      uint64_t v146 = 0;
      if (v149)
      {
        v74 = &v15[2 * v149];
        v75 = &v136[416 * v1 + 376];
        int v76 = &v136[416 * v135 + 376];
        do
        {
          if (*((unsigned char *)v15 + 4)) {
            unsigned int v77 = *v15;
          }
          else {
            unsigned int v77 = -1;
          }
          if (*((unsigned char *)v15 + 4)) {
            unsigned int v78 = -1;
          }
          else {
            unsigned int v78 = *v15;
          }
          while (1)
          {
            unsigned int v79 = v146;
            unsigned int v80 = HIDWORD(v146);
            if (HIDWORD(v146) >= v77 || v146 >= v78) {
              break;
            }
            RB::Symbol::Presentation::apply_interpolations(void)::$_4::operator()((uint64_t *)&v137);
          }
          if (*((unsigned char *)v15 + 4))
          {
            ++HIDWORD(v146);
            if (*(void *)v75) {
              v82 = *(void **)v75;
            }
            else {
              v82 = v134;
            }
          }
          else
          {
            LODWORD(v146) = v146 + 1;
            if (*(void *)v76) {
              v82 = *(void **)v76;
            }
            else {
              v82 = v133;
            }
            unsigned int v80 = v79;
          }
          unsigned int v83 = v155;
          if (HIDWORD(v155) < (v155 + 1))
          {
            RB::vector<RB::Symbol::Presentation::Layer,3ul,unsigned int>::reserve_slow(&v151, v155 + 1);
            unsigned int v83 = v155;
          }
          v84 = &v82[15 * v80];
          long long v85 = (void ***)v154;
          if (!v154) {
            long long v85 = &v151;
          }
          uint64_t v86 = &v85[15 * v83];
          long long v87 = *(_OWORD *)v84;
          long long v88 = *((_OWORD *)v84 + 1);
          long long v89 = *((_OWORD *)v84 + 3);
          *((_OWORD *)v86 + 2) = *((_OWORD *)v84 + 2);
          *((_OWORD *)v86 + 3) = v89;
          *(_OWORD *)uint64_t v86 = v87;
          *((_OWORD *)v86 + 1) = v88;
          long long v90 = *((_OWORD *)v84 + 4);
          long long v91 = *((_OWORD *)v84 + 5);
          long long v92 = *((_OWORD *)v84 + 6);
          v86[14] = (void **)v84[14];
          *((_OWORD *)v86 + 5) = v91;
          *((_OWORD *)v86 + 6) = v92;
          *((_OWORD *)v86 + 4) = v90;
          unsigned int v93 = v155;
          LODWORD(v155) = v155 + 1;
          if (*((unsigned char *)v15 + 5))
          {
            v94 = (void ***)v154;
            if (!v154) {
              v94 = &v151;
            }
            if (*((unsigned char *)v15 + 4)) {
              float v95 = 1.0 - v73;
            }
            else {
              float v95 = v73;
            }
            *(float *)&v94[15 * v93 + 4] = *(float *)&v94[15 * v93 + 4] * v95;
          }
          v15 += 2;
        }
        while (v15 != v74);
      }
      unsigned int v3 = v122;
      CFTypeRef v2 = v123;
      int v96 = v135;
      uint64_t v98 = v130;
      int32x2_t v97 = v131;
      while (1)
      {
        unsigned int v99 = *v97;
        if (HIDWORD(v146) >= *v98 || v146 >= v99) {
          break;
        }
        RB::Symbol::Presentation::apply_interpolations(void)::$_4::operator()((uint64_t *)&v137);
      }
      double v101 = &v136[416 * v96];
      int32x2_t v102 = (RB::Symbol::Presentation *)*((void *)v101 + 47);
      *((void *)v101 + 47) = v154;
      v154 = v102;
      *int32x2_t v97 = v155;
      LODWORD(v155) = v99;
      int v103 = *((_DWORD *)v101 + 97);
      *((_DWORD *)v101 + 97) = HIDWORD(v155);
      HIDWORD(v155) = v103;
      RB::vector<RB::Symbol::Presentation::Layer,3ul,unsigned int>::swap_inline(v133, &v151);
      uint64_t v104 = (char *)*((void *)v2 + 105);
      if (!v104) {
        uint64_t v104 = v3;
      }
      uint64_t v105 = &v104[416 * v96];
      long long v106 = (atomic_uint **)(v105 + 416);
      v107 = (atomic_uint *)*((void *)v105 + 52);
      uint64_t v4 = v126;
      if (v107)
      {
        unsigned int v108 = *((_DWORD *)v2 + 510);
        unsigned int v109 = v108 + 1;
        if (*((_DWORD *)v2 + 511) < v108 + 1)
        {
          RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::reserve_slow(v120, v109);
          unsigned int v108 = *((_DWORD *)v2 + 510);
          v107 = *v106;
          unsigned int v109 = v108 + 1;
        }
        *(void *)(*((void *)v2 + 254) + 8 * v108) = v107;
        *long long v106 = 0;
        *((_DWORD *)v2 + 510) = v109;
      }
      uint64_t v110 = *((void *)v105 + 53);
      if (v110)
      {
        unsigned int v111 = *((_DWORD *)v2 + 510);
        unsigned int v112 = v111 + 1;
        if (*((_DWORD *)v2 + 511) < v111 + 1)
        {
          RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::reserve_slow(v120, v112);
          unsigned int v111 = *((_DWORD *)v2 + 510);
          uint64_t v110 = *((void *)v105 + 53);
          unsigned int v112 = v111 + 1;
        }
        *(void *)(*((void *)v2 + 254) + 8 * v111) = v110;
        *((void *)v105 + 53) = 0;
        *((_DWORD *)v2 + 510) = v112;
      }
      if (*((void *)v2 + 105)) {
        unint64_t v113 = (char *)*((void *)v2 + 105);
      }
      else {
        unint64_t v113 = v3;
      }
      v106[49] = 0;
      uint64_t v114 = v106[47];
      if (v114) {
        free(v114);
      }
      uint64_t v115 = 0x4EC4EC4EC4EC4EC5 * (((char *)v106 - v113) >> 5);
      v116 = *(atomic_uint **)&v113[32 * (((char *)v106 - v113) >> 5) + 8];
      if (v116 && atomic_fetch_add_explicit(v116 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v116 + 8))(v116);
      }
      float64x2_t v117 = *v106;
      uint64_t v5 = v127;
      if (*v106 && atomic_fetch_add_explicit(v117 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v117 + 8))(v117);
      }
      uint64_t v118 = (*((_DWORD *)v2 + 212) - 1);
      *((_DWORD *)v2 + 212) = v118;
      uint64_t v119 = v118 - v115;
      if (v119) {
        memmove(v106, v106 + 52, 416 * v119);
      }
      this = v154;
      if (v154) {
        free(v154);
      }
      if (v148) {
        free(v147);
      }
LABEL_157:
      *((void *)v132 + 49) = 0;
      v136[416 * v135 + 410] = 1;
LABEL_158:
      --v4;
      uint64_t v1 = v5;
      if (!v5)
      {

        return;
      }
    }
    MEMORY[0x270FA5388](this, 8 * v14);
    int64x2_t v25 = (char *)&v120 - ((v24 + 15) & 0xFFFFFFFF0);
    bzero(v25, v24);
    v147 = v25;
    char v148 = 0;
LABEL_32:
    v151 = &v147;
    v152 = (unint64_t *)&v149;
    unint64_t v153 = v14;
    unsigned int v26 = *v130;
    unsigned int v27 = *v131;
    if (*(void *)&v136[416 * v1 + 376]) {
      uint64_t v28 = *(uint64_t **)&v136[416 * v1 + 376];
    }
    else {
      uint64_t v28 = v134;
    }
    if (*(void *)&v136[416 * v135 + 376]) {
      unint64_t v29 = *(uint64_t **)&v136[416 * v135 + 376];
    }
    else {
      unint64_t v29 = v133;
    }
    int v30 = *(unsigned __int8 *)(v7 + 16);
    uint64_t v124 = v1;
    v125 = v28;
    if (v30)
    {
      if (v26)
      {
        unsigned int v31 = 0;
        while (RB::Symbol::Glyph::Layer::contains(*v28, *(_DWORD *)(v7 + 12)))
        {
          unint64_t v32 = *v152;
          if (*v152 < v153)
          {
            int v33 = v151;
            unint64_t *v152 = v32 + 1;
            uint64_t v34 = (uint64_t)*v33 + 8 * v32;
            *(_DWORD *)uint64_t v34 = v31;
            *(_WORD *)(v34 + 4) = 1;
          }
          if (v26 == ++v31)
          {
            unsigned int v35 = 0;
            unsigned int v31 = v26;
            goto LABEL_52;
          }
        }
        long long v121 = v29;
        CFTypeRef v37 = v28;
        unsigned int v35 = v26 - v31;
        unsigned int v38 = v26 - 1;
        do
        {
          if (!RB::Symbol::Glyph::Layer::contains(v37[15 * v38], *(_DWORD *)(v7 + 12))) {
            break;
          }
          --v38;
          --v35;
        }
        while (v35);
        unint64_t v29 = v121;
      }
      else
      {
        unsigned int v35 = 0;
        unsigned int v31 = 0;
      }
LABEL_52:
      unsigned int v36 = 0;
      if (v27)
      {
        while (RB::Symbol::Glyph::Layer::contains(*v29, *(_DWORD *)(v7 + 12)))
        {
          unint64_t v39 = *v152;
          if (*v152 < v153)
          {
            uint64_t v40 = v151;
            unint64_t *v152 = v39 + 1;
            uint64_t v41 = (uint64_t)*v40 + 8 * v39;
            *(_DWORD *)uint64_t v41 = v36;
            *(_WORD *)(v41 + 4) = 0;
          }
          if (v27 == ++v36)
          {
            unsigned int v36 = v27;
            unsigned int v26 = v35;
            unsigned int v27 = 0;
            goto LABEL_62;
          }
        }
        unsigned int v42 = v27 - 1;
        v27 -= v36;
        do
        {
          if (!RB::Symbol::Glyph::Layer::contains(v29[15 * v42], *(_DWORD *)(v7 + 12))) {
            break;
          }
          --v42;
          --v27;
        }
        while (v27);
      }
      unsigned int v26 = v35;
LABEL_62:
      CFTypeRef v2 = v123;
    }
    else
    {
      unsigned int v36 = 0;
      unsigned int v31 = 0;
    }
    v137 = &v151;
    unint64_t v138 = __PAIR64__(v36, v31);
    BOOL v43 = RB::lcs_diff<RB::Symbol::Presentation::Layer,RB::Symbol::Presentation::apply_interpolations(void)::$_2,RB::Symbol::Presentation::apply_interpolations(void)::$_3>(v26, v125, v27, (uint64_t)v29, (uint64_t *)&v137);
    uint64_t v44 = v130;
    uint64_t v45 = v131;
    if (!v43)
    {
      if (v26)
      {
        double v47 = v151;
        int v46 = v152;
        unint64_t v48 = *v152;
        unsigned int v49 = v31;
        unsigned int v50 = v26;
        do
        {
          if (v48 < v153)
          {
            unint64_t v51 = v48 + 1;
            *int v46 = v48 + 1;
            uint64_t v52 = (uint64_t)*v47 + 8 * v48;
            *(_DWORD *)uint64_t v52 = v49;
            *(_WORD *)(v52 + 4) = 257;
            unint64_t v48 = v51;
          }
          ++v49;
          --v50;
        }
        while (v50);
      }
      if (v27)
      {
        CFTypeRef v54 = v151;
        unint64_t v53 = v152;
        unint64_t v55 = *v152;
        unsigned int v56 = v36;
        unsigned int v57 = v27;
        do
        {
          if (v55 < v153)
          {
            unint64_t v58 = v55 + 1;
            *unint64_t v53 = v55 + 1;
            uint64_t v59 = (uint64_t)*v54 + 8 * v55;
            *(_DWORD *)uint64_t v59 = v56;
            *(_WORD *)(v59 + 4) = 256;
            unint64_t v55 = v58;
          }
          ++v56;
          --v57;
        }
        while (v57);
      }
    }
    if (*(unsigned char *)(v7 + 16))
    {
      unsigned int v60 = v31 + v26;
      unsigned int v61 = *v44;
      if (v31 + v26 < *v44)
      {
        v63 = v151;
        uint64_t v62 = v152;
        unint64_t v64 = *v152;
        do
        {
          if (v64 < v153)
          {
            *uint64_t v62 = v64 + 1;
            uint64_t v65 = (uint64_t)*v63 + 8 * v64;
            *(_DWORD *)uint64_t v65 = v60;
            *(_WORD *)(v65 + 4) = 1;
            unsigned int v61 = *v44;
            ++v64;
          }
          ++v60;
        }
        while (v60 < v61);
      }
      unsigned int v66 = v27 + v36;
      unsigned int v67 = *v45;
      if (v27 + v36 < *v45)
      {
        uint64_t v69 = v151;
        uint64_t v68 = v152;
        unint64_t v70 = *v152;
        do
        {
          if (v70 < v153)
          {
            *uint64_t v68 = v70 + 1;
            uint64_t v71 = (uint64_t)*v69 + 8 * v70;
            *(_DWORD *)uint64_t v71 = v66;
            *(_WORD *)(v71 + 4) = 0;
            unsigned int v67 = *v45;
            ++v70;
          }
          ++v66;
        }
        while (v66 < v67);
      }
    }
    int v15 = (unsigned int *)v147;
    uint64_t v1 = v124;
    goto LABEL_86;
  }
}

void sub_21417F0E0(_Unwind_Exception *a1)
{
  unsigned int v3 = *(void **)(v1 + 608);
  if (v3) {
    free(v3);
  }
  if (*(unsigned char *)(v1 + 224)) {
    free(*(void **)(v1 + 216));
  }

  _Unwind_Resume(a1);
}

void RB::Symbol::Presentation::print(RB::Symbol::Presentation *this, std::string *a2, os_unfair_lock_t lock, char a4)
{
  if (a4)
  {
    locka = 0;
  }
  else
  {
    os_unfair_lock_lock(lock);
    locka = lock;
  }
  RB::SexpString::push(a2, "symbol-presentation");
  RB::SexpString::printf(a2, 0, "(time %.4f)", *(double *)&lock[10]._os_unfair_lock_opaque);
  float v6 = *((float *)this + 230);
  if (v6 != 0.0) {
    RB::SexpString::printf(a2, 0, "(max-velocity %d)", (int)(float)(v6 + 0.5));
  }
  float64x2_t v7 = *((float64x2_t *)this + 54);
  float64x2_t v8 = *((float64x2_t *)this + 56);
  int64x2_t v9 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(*((float64x2_t *)this + 55), (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(v7, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v8));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v9, 1), (int8x16_t)v9).u64[0] & 0x8000000000000000) == 0) {
    RB::SexpString::printf(a2, 0, "(transform %g %g %g %g %.2f %.2f)", v7.f64[0], v7.f64[1], *((double *)this + 110), *((double *)this + 111), v8.f64[0], v8.f64[1]);
  }
  if (*(void *)&lock[6]._os_unfair_lock_opaque)
  {
    RB::SexpString::push(a2, "animations");
    uint64_t v10 = *(void *)&lock[6]._os_unfair_lock_opaque;
    if (v10)
    {
      uint64_t v11 = *(void *)&lock[4]._os_unfair_lock_opaque;
      uint64_t v12 = v11 + 88 * v10;
      while (1)
      {
        uint64_t v13 = *(unsigned int *)(v11 + 4);
        unint64_t v14 = "unknown";
        if (v13 <= 0xB) {
          unint64_t v14 = off_2641F8920[v13];
        }
        RB::SexpString::push(a2, v14);
        RB::SexpString::printf(a2, 0, "(id %u)", *(_DWORD *)v11);
        if ((*(void *)(v11 + 48) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL) {
          RB::SexpString::printf(a2, 0, "(begin %.4f)", *(double *)(v11 + 48));
        }
        float v15 = *(float *)(v11 + 24);
        if (v15 != 1.0) {
          RB::SexpString::printf(a2, 0, "(speed %g)", v15);
        }
        int v16 = *(_DWORD *)(v11 + 12);
        if ((v16 & 0x800) != 0)
        {
          RB::SexpString::printf(a2, 0, "(repeat %g)", *(float *)(v11 + 28));
          int v16 = *(_DWORD *)(v11 + 12);
        }
        if ((v16 & 0xF000B010) != 0) {
          break;
        }
LABEL_30:
        float32x2_t v21 = *(float32x2_t *)(v11 + 40);
        uint32x2_t v22 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(v21));
        if ((vpmax_u32(v22, v22).u32[0] & 0x80000000) != 0) {
          RB::SexpString::printf(a2, 0, "(axis (%g . %g))", v21.f32[0], v21.f32[1]);
        }
        long long v23 = (uint64_t *)*((void *)this + 253);
        if (v23)
        {
          uint64_t v24 = v23[1];
          if (v24)
          {
            uint64_t v25 = *v23;
            uint64_t v26 = *v23 + 24 * v24;
            do
            {
              if (*(_DWORD *)v25 == *(_DWORD *)v11)
              {
                RB::SexpString::push(a2, "keyframes");
                int v27 = *(_DWORD *)(v25 + 4);
                if (v27)
                {
                  if (v27 == 1) {
                    uint64_t v28 = "from";
                  }
                  else {
                    uint64_t v28 = "to";
                  }
                  RB::SexpString::printf(a2, 0, "(symbol %s)", v28);
                }
                uint64_t v29 = *(void *)(v25 + 8);
                if (!v29) {
                  uint64_t v29 = RB::Symbol::KeyframeStorage::commit(*(RB::Symbol::KeyframeStorage **)(v25 + 16));
                }
                for (char i = *(unsigned char *)v29; (i & 0xF) != 0; char i = v31)
                {
                  RB::Symbol::Keyframes::print((int *)v29, a2, *(_DWORD *)(v25 + 4), *(void *)(v25 + 16));
                  char v31 = *(unsigned char *)(v29 + 16);
                  v29 += 16;
                }
                RB::SexpString::pop(a2);
              }
              v25 += 24;
            }
            while (v25 != v26);
          }
        }
        RB::SexpString::pop(a2);
        v11 += 88;
        if (v11 == v12) {
          goto LABEL_49;
        }
      }
      RB::SexpString::push(a2, "flags");
      uint64_t v17 = -28;
      float v18 = &dword_2641F8688;
      while (1)
      {
        if ((*(v18 - 2) >> *(_DWORD *)(v11 + 4)))
        {
          int v19 = *v18;
          if ((unint64_t)(v17 + 3) <= 0xFFFFFFFFFFFFFFEDLL)
          {
            if ((*(_DWORD *)(v11 + 12) & v19) == 0) {
              goto LABEL_27;
            }
LABEL_26:
            RB::SexpString::print(a2, 0, *((const char **)v18 + 1));
            goto LABEL_27;
          }
          if ((*(_DWORD *)(v11 + 12) & *(v18 - 1)) == v19) {
            goto LABEL_26;
          }
        }
LABEL_27:
        v18 += 6;
        if (__CFADD__(v17++, 1))
        {
          RB::SexpString::pop(a2);
          goto LABEL_30;
        }
      }
    }
LABEL_49:
    RB::SexpString::pop(a2);
  }
  if (*((_DWORD *)this + 212))
  {
    RB::SexpString::push(a2, "symbols");
    uint64_t v32 = *((unsigned int *)this + 212);
    __asm { FMOV            V12.2S, #1.0 }
    while (v32)
    {
      --v32;
      if (*((void *)this + 105)) {
        CFTypeRef v37 = (char *)*((void *)this + 105);
      }
      else {
        CFTypeRef v37 = (char *)this + 8;
      }
      unsigned int v38 = (RB::Symbol::Model **)&v37[416 * v32];
      uint64_t v39 = RB::Symbol::Model::glyph_info(*v38);
      RB::SexpString::push(a2, (const char *)objc_msgSend((id)objc_msgSend(*((id *)*v38 + 2), "name"), "UTF8String"));
      [*((id *)*v38 + 2) pointSize];
      RB::SexpString::printf(a2, 0, "(size %g)", v40);
      uint64_t v41 = *(unsigned int *)(v39 + 24);
      unsigned int v42 = "unknown";
      if (v41 <= 5) {
        unsigned int v42 = off_2641F8980[v41];
      }
      RB::SexpString::printf(a2, 0, "(mode %s)", v42);
      if (*((_DWORD *)*v38 + 20) != -1) {
        RB::SexpString::printf(a2, 0, "(value-index %d)", *((_DWORD *)*v38 + 20));
      }
      RB::SexpString::printf(a2, 0, "(alignment-rect %.2f %.2f %.2f %.2f)", COERCE_FLOAT(*(void *)(v39 + 72)), COERCE_FLOAT(HIDWORD(*(void *)(v39 + 72))), COERCE_FLOAT(*(void *)(v39 + 80)), COERCE_FLOAT(HIDWORD(*(void *)(v39 + 80))));
      BOOL v43 = *v38;
      float32x2_t v44 = *(float32x2_t *)((char *)*v38 + 48);
      uint32x2_t v45 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(v44));
      if ((vpmax_u32(v45, v45).u32[0] & 0x80000000) != 0)
      {
        RB::SexpString::printf(a2, 0, "(position %.2f %.2f)", v44.f32[0], v44.f32[1]);
        BOOL v43 = *v38;
      }
      float32x2_t v46 = *(float32x2_t *)((char *)v43 + 40);
      uint32x2_t v47 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v46, (float32x2_t)0x3F0000003F000000));
      if ((vpmax_u32(v47, v47).u32[0] & 0x80000000) != 0) {
        RB::SexpString::printf(a2, 0, "(anchor-point %.2f %.2f)", v46.f32[0], v46.f32[1]);
      }
      unint64_t v48 = &v37[416 * v32];
      if (*((_DWORD *)v48 + 96))
      {
        RB::SexpString::push(a2, "layers");
        if (*(void *)&v37[416 * v32 + 376]) {
          unsigned int v49 = *(RB::Symbol::Glyph::Sublayers ****)&v37[416 * v32 + 376];
        }
        else {
          unsigned int v49 = (RB::Symbol::Glyph::Sublayers ***)(v48 + 16);
        }
        unsigned int v50 = *((_DWORD *)v48 + 96);
        if (v50)
        {
          unint64_t v51 = &v49[15 * v50];
          do
          {
            unint64_t v52 = ((unint64_t)*((unsigned int *)*v49 + 21) >> 8) & 0xF;
            unint64_t v53 = "unknown";
            if (v52 <= 0xC) {
              unint64_t v53 = off_2641F89B0[v52];
            }
            CFTypeRef v54 = (RB::Symbol::GlyphCache *)RB::SexpString::push(a2, v53);
            unint64_t v55 = *v49;
            if (*((_DWORD *)*v49 + 12))
            {
              uint64_t v56 = RB::Symbol::GlyphCache::shared(v54);
              memset(__p, 0, 41);
              if ((*v49)[5]) {
                unsigned int v57 = (unsigned int *)(*v49)[5];
              }
              else {
                unsigned int v57 = (unsigned int *)(*v49 + 3);
              }
              uint64_t v58 = *((unsigned int *)*v49 + 12);
              if (v58)
              {
                uint64_t v59 = (os_unfair_lock_s *)v56;
                uint64_t v60 = 4 * v58;
                do
                {
                  unsigned int v61 = (const char *)objc_msgSend((id)RB::Symbol::GlyphCache::tag(v59, *v57), "UTF8String");
                  RB::SexpString::print(__p, 0, v61);
                  ++v57;
                  v60 -= 4;
                }
                while (v60);
                uint64_t v62 = __p;
                if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  uint64_t v62 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
                }
              }
              else
              {
                uint64_t v62 = __p;
              }
              RB::SexpString::printf(a2, 0, "(tags %s)", (const char *)v62);
              if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__p[0].__r_.__value_.__l.__data_);
              }
              unint64_t v55 = *v49;
            }
            if ((*((_DWORD *)v55 + 21) & 0xF00) == 0x900)
            {
              RB::SexpString::printf(a2, 0, "(color \"%s\")", (const char *)[(RB::Symbol::Glyph::Sublayers *)v55[1] UTF8String]);
              unint64_t v55 = *v49;
            }
            int v63 = *((_DWORD *)v55 + 17);
            if (v63) {
              RB::SexpString::printf(a2, 0, "(timing-group %u)", v63);
            }
            float v64 = *((float *)v49 + 5);
            if (v64 != -32768.0) {
              RB::SexpString::printf(a2, 0, "(draw-color %.2g %.2g %.2g %.2f)", *((float *)v49 + 2), *((float *)v49 + 3), *((float *)v49 + 4), v64);
            }
            float v65 = *((float *)v49 + 6);
            if (v65 != 1.0) {
              RB::SexpString::printf(a2, 0, "(draw-alpha %.2g)", v65);
            }
            if ((*((unsigned char *)*v49 + 86) & 0x40) != 0)
            {
              float v66 = *((float *)*v49 + 18) <= 0.0 ? *((float *)v49 + 8) * *((float *)v49 + 7) : *((float *)v49 + 8);
              if (v66 != 0.0) {
                RB::SexpString::printf(a2, 0, "(clip-alpha %.2g)", v66);
              }
            }
            float v67 = *((float *)v49 + 9);
            if (v67 != 1.0) {
              RB::SexpString::printf(a2, 0, "(scale %.2f)", v67);
            }
            float v68 = *((float *)v49 + 10);
            if (v68 != 1.0) {
              RB::SexpString::printf(a2, 0, "(badge-scale %.2f)", v68);
            }
            float v69 = *((float *)v49 + 11);
            if (v69 != 0.0) {
              RB::SexpString::printf(a2, 0, "(symbol-rotation %.2f deg)", (float)(v69 * 180.0) * 0.318309886);
            }
            float v70 = *((float *)v49 + 12);
            if (v70 != 0.0) {
              RB::SexpString::printf(a2, 0, "(layer-rotation %.2f deg)", (float)(v70 * 180.0) * 0.318309886);
            }
            float32x2_t v71 = (float32x2_t)v49[12];
            uint32x2_t v72 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v71, _D12));
            if ((vpmax_u32(v72, v72).u32[0] & 0x80000000) != 0) {
              RB::SexpString::printf(a2, 0, "(size-scale %.2f %.2f)", v71.f32[0], v71.f32[1]);
            }
            float32x2_t v73 = (float32x2_t)v49[8];
            uint32x2_t v74 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(v73));
            if ((vpmax_u32(v74, v74).u32[0] & 0x80000000) != 0) {
              RB::SexpString::printf(a2, 0, "(translation %g %g)", v73.f32[0], v73.f32[1]);
            }
            float v75 = *((float *)v49 + 13);
            if (v75 != 1.0) {
              RB::SexpString::printf(a2, 0, "(stroke-length %g)", v75);
            }
            if ((*((_DWORD *)*v49 + 21) & 0xC0000) == 0x80000) {
              RB::Symbol::Glyph::Sublayers::print(**v49, a2);
            }
            RB::SexpString::pop(a2);
            v49 += 15;
          }
          while (v49 != v51);
        }
        RB::SexpString::pop(a2);
      }
      int v76 = &v37[416 * v32];
      if (*((void *)v76 + 50))
      {
        RB::SexpString::push(a2, "merged-layers");
        unsigned int v77 = (void *)*((void *)v76 + 50);
        uint64_t v78 = v77[1];
        if (v78)
        {
          unsigned int v79 = (_DWORD *)*v77;
          uint64_t v80 = *v77 + 8 * v78;
          do
          {
            RB::SexpString::printf(a2, 0, "(%d . %d)", *v79, v79[1]);
            v79 += 2;
          }
          while (v79 != (_DWORD *)v80);
        }
        RB::SexpString::pop(a2);
      }
      RB::SexpString::pop(a2);
    }
    RB::SexpString::pop(a2);
  }
  RB::SexpString::pop(a2);
  if ((a4 & 1) == 0) {
    os_unfair_lock_unlock(locka);
  }
}

void sub_21417FB6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_unfair_lock_t lock, int a16, char a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if ((a17 & 1) == 0) {
    os_unfair_lock_unlock(lock);
  }
  _Unwind_Resume(exception_object);
}

void RB::Symbol::KeyframeStorage::~KeyframeStorage(RB::Symbol::KeyframeStorage *this)
{
  CFTypeRef v2 = (void *)*((void *)this + 226);
  if (v2) {
    free(v2);
  }
  unsigned int v3 = (void *)*((void *)this + 96);
  if (v3) {
    free(v3);
  }
}

uint64_t RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::~vector(uint64_t a1)
{
  CFTypeRef v2 = *(void **)a1;
  unint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3)
  {
    for (unint64_t i = 0; i < v3; ++i)
    {
      uint64_t v5 = (RB::Symbol::Glyph::Layer *)v2[i];
      v2[i] = 0;
      if (v5)
      {
        RB::Symbol::Glyph::Layer::~Layer(v5);
        unint64_t v3 = *(unsigned int *)(a1 + 8);
      }
    }
    CFTypeRef v2 = *(void **)a1;
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

uint64_t RB::vector<RB::path_ptr,0ul,unsigned int>::~vector(uint64_t a1)
{
  CFTypeRef v2 = *(uint64_t **)a1;
  if (*(_DWORD *)(a1 + 8))
  {
    unint64_t v3 = 0;
    uint64_t v4 = v2 + 1;
    do
    {
      RBPathRelease(*(v4 - 1), *v4);
      ++v3;
      v4 += 2;
    }
    while (v3 < *(unsigned int *)(a1 + 8));
    CFTypeRef v2 = *(uint64_t **)a1;
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

uint64_t RB::vector<RB::refcounted_ptr<RB::Symbol::Model const>,0ul,unsigned int>::~vector(uint64_t a1)
{
  CFTypeRef v2 = *(void **)a1;
  if (*(_DWORD *)(a1 + 8))
  {
    unint64_t v3 = 0;
    do
    {
      uint64_t v4 = (atomic_uint *)v2[v3];
      if (v4 && atomic_fetch_add_explicit(v4 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v4 + 8))(v4);
      }
      ++v3;
    }
    while (v3 < *(unsigned int *)(a1 + 8));
    CFTypeRef v2 = *(void **)a1;
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

char *RB::vector<RB::Symbol::Presentation::Symbol,2ul,unsigned int>::~vector(char *a1)
{
  CFTypeRef v2 = (char *)*((void *)a1 + 104);
  if (v2) {
    unint64_t v3 = v2;
  }
  else {
    unint64_t v3 = a1;
  }
  if (*((_DWORD *)a1 + 210))
  {
    unint64_t v4 = 0;
    do
    {
      *((void *)v3 + 49) = 0;
      uint64_t v5 = (void *)*((void *)v3 + 47);
      if (v5) {
        free(v5);
      }
      float v6 = (atomic_uint *)*((void *)v3 + 1);
      if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
      }
      float64x2_t v7 = *(atomic_uint **)v3;
      if (*(void *)v3 && atomic_fetch_add_explicit(v7 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v7 + 8))(v7);
      }
      ++v4;
      v3 += 416;
    }
    while (v4 < *((unsigned int *)a1 + 210));
    CFTypeRef v2 = (char *)*((void *)a1 + 104);
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

double RB::Symbol::Presentation::bounding_rect(RB::Symbol::Presentation *this, double a2, double a3, double a4, int32x4_t a5)
{
  v19[0] = 0;
  v19[1] = 0;
  if (*((void *)this + 105)) {
    uint64_t v5 = (char *)*((void *)this + 105);
  }
  else {
    uint64_t v5 = (char *)this + 8;
  }
  int v6 = *((_DWORD *)this + 212);
  if (!v6) {
    return 0.0;
  }
  float64x2_t v8 = &v5[416 * v6];
  do
  {
    if (*((void *)v5 + 47)) {
      int64x2_t v9 = (float32x2_t *)*((void *)v5 + 47);
    }
    else {
      int64x2_t v9 = (float32x2_t *)(v5 + 16);
    }
    uint64_t v10 = *((unsigned int *)v5 + 96);
    if (v10)
    {
      uint64_t v11 = 120 * v10;
      do
      {
        LODWORD(a4) = v9[4].i32[0];
        *(float *)&a3 = v9[3].f32[0] * *(float *)&a4;
        *(float *)&a2 = *(float *)&a3 * *(float *)(*(void *)v9 + 72);
        if (*(float *)&a2 > 0.0)
        {
          RB::Symbol::Presentation::Layer::bounding_rect(v9, this, (RB::Symbol::Model **)v5, a2, a3, a4, a5);
          RB::Rect::Union(v19, v12, v13, v14, v15, v16, v17);
        }
        v9 += 15;
        v11 -= 120;
      }
      while (v11);
    }
    v5 += 416;
  }
  while (v5 != v8);
  return *(double *)v19;
}

void RB::Symbol::Presentation::Layer::bounding_rect(float32x2_t *this, const RB::Symbol::Presentation *a2, RB::Symbol::Model **a3, double a4, double a5, double a6, int32x4_t a7)
{
  if (!*((unsigned char *)a3 + 410)
    && (LODWORD(a4) = this[5].i32[1], *(float *)&a4 == 0.0)
    && (LODWORD(a4) = this[6].i32[0], *(float *)&a4 == 0.0))
  {
    uint64_t v16 = *(void *)(RB::Symbol::Model::glyph_info(*a3) + 80);
    v17.f64[0] = RB::Symbol::Presentation::Layer::transform(this, (uint64_t)a2);
    float64x2_t v19 = v17;
    int32x4_t v20 = v15;
    long long v21 = v18;
    float32x2_t v14 = 0;
    v15.i64[0] = v16;
  }
  else
  {
    int8x8_t v9 = RB::Symbol::Glyph::Layer::content_bounds(*(float32x2_t ***)this, a4, a5, a6, a7);
    uint64_t v11 = v10;
    v12.f64[0] = RB::Symbol::Presentation::Layer::transform(this, (uint64_t)a2);
    float64x2_t v19 = v12;
    int32x4_t v20 = v15;
    long long v21 = v13;
    float32x2_t v14 = (float32x2_t)v9;
    v15.i64[0] = v11;
  }
  RB::operator*(&v19, v14, v15);
}

BOOL RB::lcs_diff<RB::Symbol::Presentation::Layer,RB::Symbol::Presentation::apply_interpolations(void)::$_2,RB::Symbol::Presentation::apply_interpolations(void)::$_3>(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v6 = a4;
  uint64_t v7 = a3;
  uint64_t v9 = a1;
  uint64_t v92 = *MEMORY[0x263EF8340];
  if (a1 >= a3) {
    uint64_t v10 = a3;
  }
  else {
    uint64_t v10 = a1;
  }
  if (v10 < 1)
  {
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v11 = 0;
    float64x2_t v12 = a2;
    uint64_t v13 = a4;
    while (1)
    {
      uint64_t v14 = *v12;
      unsigned int v15 = *(_DWORD *)(*v12 + 84);
      int v16 = (v15 >> 8) & 0xF;
      unsigned int v17 = *(_DWORD *)(*(void *)v13 + 84);
      if (v16 != ((v17 >> 8) & 0xF) || ((v17 ^ v15) & 0x400000) != 0) {
        break;
      }
      if (v16 == 9)
      {
        a1 = [*(id *)(v14 + 8) isEqualToString:*(void *)(*(void *)v13 + 8)];
        if (!a1) {
          break;
        }
        uint64_t v14 = *v12;
        unsigned int v15 = *(_DWORD *)(*v12 + 84);
      }
      if ((v15 & 0xF00) == 0xC00 && *(void *)(v14 + 16) != *(void *)(*(void *)v13 + 16)) {
        break;
      }
      ++v11;
      v13 += 120;
      v12 += 15;
      if (v10 == v11)
      {
        uint64_t v11 = v10;
        break;
      }
    }
  }
  if (v11 < v7 && v11 < v9)
  {
    uint64_t v18 = (uint64_t)&a2[15 * v9 - 15];
    uint64_t v19 = v6 + 120 * v7 - 120;
    do
    {
      uint64_t v20 = *(void *)v18;
      unsigned int v21 = *(_DWORD *)(*(void *)v18 + 84);
      int v22 = (v21 >> 8) & 0xF;
      unsigned int v23 = *(_DWORD *)(*(void *)v19 + 84);
      if (v22 != ((v23 >> 8) & 0xF) || ((v23 ^ v21) & 0x400000) != 0) {
        break;
      }
      if (v22 == 9)
      {
        a1 = [*(id *)(v20 + 8) isEqualToString:*(void *)(*(void *)v19 + 8)];
        if (!a1) {
          break;
        }
        uint64_t v20 = *(void *)v18;
        unsigned int v21 = *(_DWORD *)(*(void *)v18 + 84);
      }
      if ((v21 & 0xF00) == 0xC00 && *(void *)(v20 + 16) != *(void *)(*(void *)v19 + 16)) {
        break;
      }
      --v9;
      if (v11 >= --v7) {
        break;
      }
      v18 -= 120;
      v19 -= 120;
    }
    while (v11 < v9);
  }
  long long v85 = a2;
  if (v9 + v7 >= 32) {
    uint64_t v24 = 32;
  }
  else {
    uint64_t v24 = v9 + v7;
  }
  if (v11 == v9) {
    uint64_t v25 = v9 + 1;
  }
  else {
    uint64_t v25 = v9 - 1;
  }
  if (v11 == v7) {
    uint64_t v26 = v9 - 1;
  }
  else {
    uint64_t v26 = v9 + 1;
  }
  if (v11 == v7 && v11 == v9)
  {
    LOBYTE(v27) = 1;
    return v27;
  }
  if (v24 < 1 || (v9 <= v7 ? (uint64_t v28 = v7) : (uint64_t v28 = v9), v28 >= 0x8000 || (((unint64_t)v28 >> 60) & 7) != 0))
  {
    LOBYTE(v27) = 0;
    return v27;
  }
  uint64_t v84 = v26;
  unint64_t v74 = (16 * v28) | 8;
  if (v74 <= 0x1000)
  {
    uint64_t v77 = v24;
    MEMORY[0x270FA5388](a1, a2);
    char v31 = (char *)&v71 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0);
    size_t v32 = v30;
    bzero(v31, v30);
    MEMORY[0x270FA5388](v33, v34);
    uint64_t v86 = v31;
    bzero(v31, v32);
    int v73 = 0;
    uint64_t v35 = v84;
    goto LABEL_53;
  }
  size_t v36 = (16 * v28) | 8;
  char v31 = (char *)malloc_type_malloc(v36, 0x5560CE4DuLL);
  uint64_t v86 = malloc_type_malloc(v36, 0x14FC10C4uLL);
  uint64_t v35 = v84;
  if (v31)
  {
    int v73 = 1;
    if (v86)
    {
      uint64_t v77 = v24;
LABEL_53:
      uint32x2_t v72 = a5;
      long long v87 = v31;
      RB::Heap::Heap((RB::Heap *)v88, v91, 1024, 0);
      *(void *)&v31[8 * v9] = v11;
      v86[v9] = 0;
      uint64_t v76 = -v9;
      BOOL v27 = 1;
      uint64_t v37 = 1;
      uint64_t v80 = v6;
      while (1)
      {
        uint64_t v78 = v37;
        if (v25 <= v35) {
          break;
        }
        uint64_t v38 = v25;
LABEL_56:
        uint64_t v25 = v38 - 1;
        ++v35;
        uint64_t v37 = v78 + 1;
        BOOL v27 = v78 < v77;
        if (v78 == v77)
        {
LABEL_108:
          RB::Heap::~Heap((RB::Heap *)v88);
          char v31 = v87;
          int v70 = v73;
          if (v74 <= 0x1000) {
            goto LABEL_114;
          }
          goto LABEL_113;
        }
      }
      BOOL v75 = v27;
      uint64_t v82 = v37 + v9;
      uint64_t v83 = v9 - v37;
      uint64_t v79 = v37 + v9 - 1;
      uint64_t v81 = v9 - v37 + 1;
      uint64_t v39 = v76 + v25;
      uint64_t v38 = v25;
      while (1)
      {
        unint64_t v40 = (v89 + 7) & 0xFFFFFFFFFFFFFFF8;
        if (v40 + 32 > v90) {
          unint64_t v40 = RB::Heap::alloc_slow(v88, 0x20uLL, 7);
        }
        else {
          unint64_t v89 = v40 + 32;
        }
        if (v25 == v83) {
          break;
        }
        if (v25 == v82)
        {
          int v44 = 0;
          uint64_t v41 = v79;
          uint64_t v43 = *(void *)&v87[8 * v79];
        }
        else
        {
          uint64_t v41 = v25 + 1;
          uint64_t v42 = *(void *)&v87[8 * v25 + 8];
          uint64_t v43 = *(void *)&v87[8 * v25 - 8];
          if (v42 >= v43) {
            goto LABEL_63;
          }
          int v44 = 0;
          uint64_t v41 = v25 - 1;
        }
LABEL_68:
        uint32x2_t v45 = v86;
        *(void *)unint64_t v40 = v86[v41];
        *(_DWORD *)(v40 + 8) = v44;
        uint64_t v46 = v25 - v9 + v43;
        *(void *)(v40 + 16) = v43 - 1;
        *(void *)(v40 + 24) = v46 - 1;
        v45[v25] = v40;
        if (v43 < v9 && v46 < v7)
        {
          uint64_t v84 = v35;
          uint64_t v48 = v6 + 120 * (v43 + v39);
          unsigned int v49 = &v85[15 * v43];
          while (1)
          {
            uint64_t v50 = *v49;
            unsigned int v51 = *(_DWORD *)(*v49 + 84);
            int v52 = (v51 >> 8) & 0xF;
            unsigned int v53 = *(_DWORD *)(*(void *)v48 + 84);
            if (v52 != ((v53 >> 8) & 0xF) || ((v53 ^ v51) & 0x400000) != 0) {
              break;
            }
            if (v52 == 9)
            {
              if (![*(id *)(v50 + 8) isEqualToString:*(void *)(*(void *)v48 + 8)]) {
                break;
              }
              uint64_t v50 = *v49;
              unsigned int v51 = *(_DWORD *)(*v49 + 84);
            }
            if (((v51 & 0xF00) != 0xC00 || *(void *)(v50 + 16) == *(void *)(*(void *)v48 + 16)) && ++v43 < v9)
            {
              ++v46;
              v48 += 120;
              v49 += 15;
              if (v43 + v39 < v7) {
                continue;
              }
            }
            uint64_t v46 = v39 + v43;
            break;
          }
          uint64_t v6 = v80;
          uint64_t v35 = v84;
        }
        *(void *)&v87[8 * v25] = v43;
        if (v43 == v9 && v46 == v7)
        {
          unint64_t v55 = (void *)v86[v25];
          if (v55)
          {
            uint64_t v56 = 0;
            LOBYTE(v27) = v75;
            do
            {
              unsigned int v57 = v55;
              unint64_t v55 = (void *)*v55;
              void *v57 = v56;
              uint64_t v56 = v57;
            }
            while (v55);
            uint64_t v58 = v72;
            uint64_t v59 = *v72;
            uint64_t v60 = *(unint64_t **)(*v72 + 8);
            unint64_t v61 = *v60;
            do
            {
              if (v61 < *(void *)(v59 + 16))
              {
                BOOL v62 = *((_DWORD *)v57 + 2) == 1;
                if (*((_DWORD *)v57 + 2) == 1) {
                  uint64_t v63 = 2;
                }
                else {
                  uint64_t v63 = 3;
                }
                int v64 = v57[v63];
                float v65 = v58 + 1;
                if (*((_DWORD *)v57 + 2) != 1) {
                  float v65 = (_DWORD *)v58 + 3;
                }
                int v66 = *v65 + v64;
                float v67 = *(void **)v59;
                unint64_t v68 = v61 + 1;
                *uint64_t v60 = v61 + 1;
                uint64_t v69 = *v67 + 8 * v61;
                *(_DWORD *)uint64_t v69 = v66;
                *(unsigned char *)(v69 + 4) = v62;
                *(unsigned char *)(v69 + 5) = 1;
                unint64_t v61 = v68;
              }
              unsigned int v57 = (void *)*v57;
            }
            while (v57);
          }
          else
          {
            LOBYTE(v27) = v75;
          }
          goto LABEL_108;
        }
        uint64_t v54 = v25 + 2;
        if (v43 == v9) {
          uint64_t v38 = v25 + 2;
        }
        if (v46 == v7) {
          uint64_t v35 = v25 - 2;
        }
        v39 += 2;
        v25 += 2;
        if (v54 > v35) {
          goto LABEL_56;
        }
      }
      uint64_t v41 = v81;
      uint64_t v42 = *(void *)&v87[8 * v81];
LABEL_63:
      uint64_t v43 = v42 + 1;
      int v44 = 1;
      goto LABEL_68;
    }
    LOBYTE(v27) = 0;
    uint64_t v86 = 0;
  }
  else
  {
    LOBYTE(v27) = 0;
  }
  int v70 = 1;
LABEL_113:
  free(v86);
LABEL_114:
  if (v70) {
    free(v31);
  }
  return v27;
}

void sub_2141806E0(_Unwind_Exception *a1)
{
  RB::Heap::~Heap((RB::Heap *)(v1 + 136));
  if (*(void *)(v1 + 24) > 0x1000uLL)
  {
    free(*(void **)(v1 + 120));
    free(*(void **)(v1 + 128));
  }
  _Unwind_Resume(a1);
}

float32x2_t RB::Symbol::Presentation::apply_interpolations(void)::$_4::operator()(uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v4 = v2 + 16;
  unsigned int v5 = *(_DWORD *)a1[5];
  uint64_t v6 = *(void *)(v2 + 376);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = v4;
  }
  uint64_t v8 = a1[2];
  uint64_t v9 = v8 + 16;
  unsigned int v10 = *(_DWORD *)a1[6];
  uint64_t v11 = *(void *)(v8 + 376);
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = v9;
  }
  v13.f64[0] = RB::Symbol::Presentation::Layer::transform((float32x2_t *)(v7 + 120 * v5), 0);
  v51[0] = v13;
  v51[1] = v14;
  v51[2] = v15;
  v16.f64[0] = RB::Symbol::Presentation::Layer::transform((float32x2_t *)(v12 + 120 * v10), 0);
  v50[0] = v16;
  v50[1] = v17;
  v50[2] = v18;
  RB::Heap::emplace<RB::Symbol::Glyph::Layer>((RB::Heap *)(v3 + 944));
  uint64_t v20 = v19;
  unsigned int v21 = *(_DWORD *)(v3 + 2072);
  unsigned int v22 = v21 + 1;
  if (*(_DWORD *)(v3 + 2076) < v21 + 1)
  {
    RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::reserve_slow(v3 + 2064, v22);
    unsigned int v21 = *(_DWORD *)(v3 + 2072);
    unsigned int v22 = v21 + 1;
  }
  *(void *)(*(void *)(v3 + 2064) + 8 * v21) = v20;
  *(_DWORD *)(v3 + 2072) = v22;
  char v49 = 0;
  RB::Symbol::Glyph::Layer::mix_layers(v20, *(void *)(v7 + 120 * v5), *(void *)(v12 + 120 * v10), v51, v50, (RB::Symbol::Presentation *)v3, *((unsigned char *)a1 + 56), (id *)a1[8], *(float *)a1[3], &v49);
  uint64_t v23 = a1[4];
  unsigned int v24 = *(_DWORD *)(v23 + 368);
  if (*(_DWORD *)(v23 + 372) < v24 + 1)
  {
    RB::vector<RB::Symbol::Presentation::Layer,3ul,unsigned int>::reserve_slow((void *)a1[4], v24 + 1);
    unsigned int v24 = *(_DWORD *)(v23 + 368);
  }
  uint64_t v25 = *(void *)(v23 + 360);
  if (!v25) {
    uint64_t v25 = v23;
  }
  uint64_t v26 = v25 + 120 * v24;
  *(void *)uint64_t v26 = v20;
  *(_OWORD *)(v26 + 8) = RBColorNull;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v26 + 24) = _Q0;
  *(_OWORD *)(v26 + 40) = xmmword_214219A20;
  *(_OWORD *)(v26 + 64) = 0u;
  *(_OWORD *)(v26 + 80) = 0u;
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)(v26 + 96) = _Q0;
  *(void *)(v26 + 104) = 0;
  *(void *)(v26 + 112) = 0;
  ++*(_DWORD *)(v23 + 368);
  uint64_t v32 = a1[4];
  if (*(void *)(v32 + 360)) {
    uint64_t v33 = *(void *)(v32 + 360);
  }
  else {
    uint64_t v33 = a1[4];
  }
  unsigned int v34 = *(_DWORD *)(v32 + 368) - 1;
  float v35 = *(float *)a1[3];
  float v36 = *(float *)(v12 + 120 * v10 + 20);
  if (*(float *)(v7 + 120 * v5 + 20) == -32768.0 && v36 == -32768.0)
  {
    float32x4_t v37 = (float32x4_t)RBColorNull;
  }
  else
  {
    uint64_t v38 = v12 + 120 * v10;
    float16x4_t v54 = vcvt_f16_f32(*(float32x4_t *)(v7 + 120 * v5 + 8));
    __int16 v55 = 257;
    v39.i64[0] = *(void *)(v38 + 8);
    v39.i32[2] = *(_DWORD *)(v38 + 16);
    v39.f32[3] = v36;
    float16x4_t v52 = vcvt_f16_f32(v39);
    __int16 v53 = 257;
    if (RB::Fill::Color::can_mix((RB::Fill::Color *)&v54, (const RB::Fill::Color *)&v52))
    {
      RB::Fill::Color::mix((uint64_t)&v54, (uint64_t)&v52, 3, v35);
    }
    else
    {
      float16x4_t v54 = v52;
      __int16 v55 = v53;
    }
    float32x4_t v37 = vcvtq_f32_f16(v54);
  }
  *(float32x4_t *)(v33 + 120 * v34 + 8) = v37;
  unint64_t v40 = (float32x2_t *)(v7 + 120 * v5);
  uint64_t v41 = (float32x2_t *)(v12 + 120 * v10);
  float v42 = *(float *)a1[3];
  uint64_t v43 = (float32x2_t *)(v33 + 120 * v34);
  v43[3] = vmla_n_f32(v40[3], vsub_f32(v41[3], v40[3]), v42);
  v43[4].f32[0] = v40[4].f32[0] + (float)((float)(v41[4].f32[0] - v40[4].f32[0]) * v42);
  v43[7] = vmla_n_f32(v40[7], vsub_f32(v41[7], v40[7]), v42);
  v43[9] = vmla_n_f32(v40[9], vsub_f32(v41[9], v40[9]), *(float *)a1[3]);
  v43[10] = vmla_n_f32(v40[10], vsub_f32(v41[10], v40[10]), *(float *)a1[3]);
  v43[11] = vmla_n_f32(v40[11], vsub_f32(v41[11], v40[11]), *(float *)a1[3]);
  if (!v49)
  {
    uint64_t v44 = v7 + 120 * v5;
    uint64_t v45 = v12 + 120 * v10;
    uint64_t v46 = v33 + 120 * v34;
    *(float32x2_t *)(v46 + 64) = vmla_n_f32(*(float32x2_t *)(v44 + 64), vsub_f32(*(float32x2_t *)(v45 + 64), *(float32x2_t *)(v44 + 64)), *(float *)a1[3]);
    float v47 = *(float *)a1[3];
    *(float32x2_t *)(v46 + 36) = vmla_n_f32(*(float32x2_t *)(v44 + 36), vsub_f32(*(float32x2_t *)(v45 + 36), *(float32x2_t *)(v44 + 36)), v47);
    *(float *)(v46 + 44) = *(float *)(v44 + 44) + (float)((float)(*(float *)(v45 + 44) - *(float *)(v44 + 44)) * v47);
    *(float32x2_t *)(v46 + 96) = vmla_n_f32(*(float32x2_t *)(v44 + 96), vsub_f32(*(float32x2_t *)(v45 + 96), *(float32x2_t *)(v44 + 96)), v47);
    *(float *)(v46 + 112) = *(float *)(v44 + 112)
                          + (float)(*(float *)a1[3] * (float)(*(float *)(v45 + 112) - *(float *)(v44 + 112)));
  }
  float32x2_t result = vmaxnm_f32(*(float32x2_t *)(v7 + 120 * v5 + 104), *(float32x2_t *)(v12 + 120 * v10 + 104));
  *(float32x2_t *)(v33 + 120 * v34 + 104) = result;
  ++*(_DWORD *)a1[5];
  ++*(_DWORD *)a1[6];
  return result;
}

float32x2_t RB::Symbol::Presentation::Layer::add_velocity(float32x2_t *a1, double a2)
{
  float32x2_t result = vmaxnm_f32((float32x2_t)(*(void *)&a2 & 0x7FFFFFFF7FFFFFFFLL), a1[13]);
  a1[13] = result;
  return result;
}

float32x2_t RB::Symbol::Presentation::Layer::add_scale_velocity(float32x2_t *this, float a2)
{
  float32x2_t result = vadd_f32(this[13], vabs_f32(vmul_n_f32(this[9], a2)));
  this[13] = result;
  return result;
}

__n128 __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = 0;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 88);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t RB::Symbol::Presentation::Layer::append_path(float32x2_t *this, RB::Path::Storage *a2, const RB::Symbol::Presentation *a3)
{
  v5.f64[0] = RB::Symbol::Presentation::Layer::transform(this, (uint64_t)a3);
  uint64_t v6 = (uint64_t *)*this;
  double v7 = *(float *)(*(void *)this + 56);
  float64x2_t v16 = vmulq_n_f64(v5, v7);
  float64x2_t v17 = vmulq_n_f64(v8, v7);
  float64x2_t v18 = v9;
  int64x2_t v10 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v17, (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(v16, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v9));
  unint64_t v11 = vandq_s8((int8x16_t)vdupq_laneq_s64(v10, 1), (int8x16_t)v10).u64[0];
  if ((v11 & 0x8000000000000000) == 0)
  {
    RB::Path::Storage::append_element(a2, (const char *)0x11, 0, (int *)&v16);
    uint64_t v6 = (uint64_t *)*this;
  }
  v12.i32[0] = 0;
  v12.i32[1] = this[6].i32[1];
  uint64_t appended = RB::Symbol::Glyph::Layer::append_path(v6, a2, v12);
  uint64_t v14 = appended;
  if ((v11 & 0x8000000000000000) == 0 && appended) {
    RB::Path::Storage::append_element(a2, (const char *)0x10, 0, 0);
  }
  return v14;
}

void *RB::Symbol::Presentation::record_keyframes(void *result, int *a2, int a3, void *a4, RB::Symbol::KeyframeStorage *this)
{
  float64x2_t v5 = (void *)result[253];
  if (v5)
  {
    int64x2_t v10 = result;
    uint64_t v11 = v5[1];
    if (v5[2] < (unint64_t)(v11 + 1))
    {
      __n128 result = RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow(result[253], v11 + 1);
      uint64_t v11 = v5[1];
    }
    float32x2_t v12 = (void *)(*v5 + 24 * v11);
    *float32x2_t v12 = 0;
    v12[1] = 0;
    v12[2] = 0;
    ++v5[1];
    int v13 = *a2;
    uint64_t v14 = (uint64_t *)v10[253];
    uint64_t v15 = *v14;
    uint64_t v16 = v14[1] - 1;
    float64x2_t v17 = (_DWORD *)(v15 + 24 * v16);
    *float64x2_t v17 = v13;
    v17[1] = a3;
    if (*((_DWORD *)this + 454))
    {
      __n128 result = (void *)RB::Symbol::KeyframeStorage::commit(this);
      float64x2_t v18 = (uint64_t *)v10[253];
      uint64_t v15 = *v18;
      if (result == a4) {
        operator new();
      }
      uint64_t v16 = v18[1] - 1;
    }
    *(void *)(v15 + 24 * v16 + 8) = a4;
  }
  return result;
}

void sub_214180DA8(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x1020C400F1BD0D8);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Presentation::take_path(RB::Symbol::Presentation *this, const path_ptr *a2)
{
  unsigned int v4 = *((_DWORD *)this + 514);
  if (*((_DWORD *)this + 515) < v4 + 1)
  {
    RB::vector<RBColor,0ul,unsigned int>::reserve_slow((uint64_t)this + 2048, v4 + 1);
    unsigned int v4 = *((_DWORD *)this + 514);
  }
  float64x2_t v5 = (void *)(*((void *)this + 256) + 16 * v4);
  uint64_t result = RBPathRetain((uint64_t)a2->_p.info, (uint64_t)a2->_p.callbacks);
  *float64x2_t v5 = result;
  v5[1] = v7;
  ++*((_DWORD *)this + 514);
  return result;
}

uint64_t RB::Symbol::Presentation::take_path(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  unsigned int v4 = *(_DWORD *)(a1 + 2056);
  unsigned int v5 = v4 + 1;
  if (*(_DWORD *)(a1 + 2060) < v4 + 1)
  {
    RB::vector<RBColor,0ul,unsigned int>::reserve_slow(a1 + 2048, v5);
    unsigned int v4 = *(_DWORD *)(a1 + 2056);
    unsigned int v5 = v4 + 1;
  }
  uint64_t v6 = (void *)(*(void *)(a1 + 2048) + 16 * v4);
  *uint64_t v6 = v3;
  v6[1] = &RB::Path::Object::callbacks;
  *(_DWORD *)(a1 + 2056) = v5;
  return *(void *)(*(void *)(a1 + 2048) + 16 * v4);
}

void RB::Symbol::ResolvedColor::update(uint64_t a1, float a2, float a3, float a4, float a5)
{
  if (*(float *)a1 != a2 || *(float *)(a1 + 4) != a3 || *(float *)(a1 + 8) != a4 || *(float *)(a1 + 12) != a5) {
    RB::Symbol::ResolvedColor::commit_update(a1, a2, a3, a4, a5);
  }
}

CGColorRef RB::Symbol::ResolvedColor::operator CGColor *(uint64_t a1)
{
  CGColorRef v1 = *(CGColorRef *)(a1 + 40);
  if (!v1)
  {
    CGColorRef v1 = RBColorCopyCGColor(1u, *(float *)a1, *(float *)(a1 + 4), *(float *)(a1 + 8), *(float *)(a1 + 12));
    uint64_t v3 = *(const void **)(a1 + 40);
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 40) = v1;
  }
  return v1;
}

double RB::Heap::emplace<RB::Symbol::Glyph::Layer>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 88 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x58uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 88;
  }
  *(void *)(v3 + 40) = 0;
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = 0;
  *(void *)&double result = 0x400000000;
  *(void *)(v3 + 48) = 0x400000000;
  *(void *)(v3 + 56) = 1065353216;
  *(void *)(v3 + 64) = 2139095040;
  *(void *)(v3 + 72) = 1065353216;
  unsigned int v5 = *(_DWORD *)(v3 + 84) & 0xFE000000 | 0x311A00;
  *(_DWORD *)(v3 + 80) = -1;
  *(_DWORD *)(v3 + 84) = v5;
  return result;
}

RB::Symbol::KeyframeStorage *RB::Symbol::KeyframeStorage::KeyframeStorage(RB::Symbol::KeyframeStorage *this, const RB::Symbol::KeyframeStorage *a2)
{
  *((void *)this + 96) = 0;
  *((void *)this + 97) = 0x4000000000;
  if (*((void *)a2 + 96)) {
    unsigned int v4 = (const RB::Symbol::KeyframeStorage *)*((void *)a2 + 96);
  }
  else {
    unsigned int v4 = a2;
  }
  unsigned int v5 = *((_DWORD *)a2 + 194);
  unsigned int v6 = v5;
  if (v5 >= 0x41)
  {
    RB::vector<RB::Symbol::Keyframes::Value,64ul,unsigned int>::reserve_slow(this, v5);
    uint64_t v7 = (RB::Symbol::KeyframeStorage *)*((void *)this + 96);
    unsigned int v8 = *((_DWORD *)this + 194);
  }
  else
  {
    if (!v5)
    {
      int v11 = 0;
      goto LABEL_13;
    }
    uint64_t v7 = 0;
    unsigned int v8 = 0;
  }
  if (!v7) {
    uint64_t v7 = this;
  }
  float64x2_t v9 = (char *)v7 + 12 * v8;
  do
  {
    uint64_t v10 = *(void *)v4;
    *((_DWORD *)v9 + 2) = *((_DWORD *)v4 + 2);
    *(void *)float64x2_t v9 = v10;
    v9 += 12;
    unsigned int v4 = (const RB::Symbol::KeyframeStorage *)((char *)v4 + 12);
    --v6;
  }
  while (v6);
  int v11 = *((_DWORD *)this + 194);
LABEL_13:
  *((_DWORD *)this + 194) = v11 + v5;
  *((void *)this + 226) = 0;
  *((void *)this + 227) = 0x4000000000;
  if (*((void *)a2 + 226)) {
    float32x2_t v12 = (long long *)*((void *)a2 + 226);
  }
  else {
    float32x2_t v12 = (long long *)((char *)a2 + 784);
  }
  unsigned int v13 = *((_DWORD *)a2 + 454);
  if (v13 >= 0x41)
  {
    RB::vector<RB::Symbol::Keyframes,64ul,unsigned int>::reserve_slow((char *)this + 784, *((_DWORD *)a2 + 454));
    uint64_t v14 = (char *)*((void *)this + 226);
    uint64_t v15 = *((unsigned int *)this + 454);
  }
  else
  {
    if (!v13)
    {
      int v19 = 0;
      goto LABEL_25;
    }
    uint64_t v14 = 0;
    uint64_t v15 = 0;
  }
  if (!v14) {
    uint64_t v14 = (char *)this + 784;
  }
  uint64_t v16 = &v14[16 * v15];
  unsigned int v17 = v13;
  do
  {
    long long v18 = *v12++;
    *(_OWORD *)uint64_t v16 = v18;
    v16 += 16;
    --v17;
  }
  while (v17);
  int v19 = *((_DWORD *)this + 454);
LABEL_25:
  *((_DWORD *)this + 454) = v19 + v13;
  *((unsigned char *)this + 1824) = *((unsigned char *)a2 + 1824);
  return this;
}

void sub_214181104(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)(v1 + 1808);
  if (v3) {
    free(v3);
  }
  unsigned int v4 = *(void **)(v1 + 768);
  if (v4) {
    free(v4);
  }
  _Unwind_Resume(exception_object);
}

void *RB::vector<RB::Symbol::Keyframes::Value,64ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 195) + (*((_DWORD *)__dst + 195) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 195) + (*((_DWORD *)__dst + 195) >> 1);
  }
  double result = RB::details::realloc_vector<unsigned int,12ul>(*((void **)__dst + 96), __dst, 0x40u, (_DWORD *)__dst + 195, v3);
  *((void *)__dst + 96) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,12ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  uint64_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 12 * a5);
      free(v7);
      float32x2_t v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(12 * a5);
    unint64_t v9 = v8 / 0xC;
    if (*a4 != (v8 / 0xC))
    {
      uint64_t v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      float32x2_t v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 12 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

void *RB::vector<RB::Symbol::Keyframes,64ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 259) + (*((_DWORD *)__dst + 259) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 259) + (*((_DWORD *)__dst + 259) >> 1);
  }
  double result = RB::details::realloc_vector<unsigned int,16ul>(*((void **)__dst + 128), __dst, 0x40u, (_DWORD *)__dst + 259, v3);
  *((void *)__dst + 128) = result;
  return result;
}

void std::default_delete<RB::vector<RB::Symbol::Presentation::KeyframeInfo,0ul,unsigned long>>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unsigned int v3 = *(uint64_t **)a2;
    unint64_t v4 = *(void *)(a2 + 8);
    if (v4)
    {
      unint64_t v5 = 0;
      unsigned int v6 = v3 + 2;
      do
      {
        uint64_t v7 = *v6;
        *unsigned int v6 = 0;
        if (v7)
        {
          std::default_delete<RB::Symbol::KeyframeStorage>::operator()[abi:nn180100]((uint64_t)v6, v7);
          unint64_t v4 = *(void *)(a2 + 8);
        }
        ++v5;
        v6 += 3;
      }
      while (v5 < v4);
      unsigned int v3 = *(uint64_t **)a2;
    }
    if (v3) {
      free(v3);
    }
    JUMPOUT(0x21669AC10);
  }
}

void *RB::vector<RB::Symbol::Presentation::Symbol,2ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 211) + (*((_DWORD *)__dst + 211) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 211) + (*((_DWORD *)__dst + 211) >> 1);
  }
  double result = RB::details::realloc_vector<unsigned int,416ul>(*((void **)__dst + 104), __dst, 2u, (_DWORD *)__dst + 211, v3);
  *((void *)__dst + 104) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,416ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  uint64_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 416 * a5);
      free(v7);
      float32x2_t v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(416 * a5);
    unint64_t v9 = v8 / 0x1A0;
    if (*a4 != (v8 / 0x1A0))
    {
      uint64_t v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      float32x2_t v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 416 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

void *RB::vector<RB::Symbol::Presentation::Layer,3ul,unsigned int>::swap_inline(void *result, void *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v2 = a2[45];
  uint64_t v3 = result[45];
  if (v2) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    unsigned int v6 = result;
    memcpy(v7, a2, sizeof(v7));
    memcpy(a2, v6, 0x168uLL);
    double result = memcpy(v6, v7, 0x168uLL);
    if (v3)
    {
      if (v2) {
        return result;
      }
    }
    else
    {
      v6[45] = 0;
      if (v2) {
        return result;
      }
    }
    a2[45] = 0;
  }
  return result;
}

void std::default_delete<RB::Symbol::KeyframeStorage>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void **)(a2 + 1808);
    if (v3) {
      free(v3);
    }
    BOOL v4 = *(void **)(a2 + 768);
    if (v4) {
      free(v4);
    }
    JUMPOUT(0x21669AC10);
  }
}

uint64_t RB::CustomShader::Library::Library(uint64_t a1, int a2, void *a3)
{
  *(_DWORD *)(a1 + 8) = 1;
  *(void *)a1 = &unk_26C4ED010;
  *(void *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 24) = a2;
  RB::Heap::Heap((RB::Heap *)(a1 + 40), (char *)(a1 + 80), 512, 0);
  RB::UntypedTable::UntypedTable(a1 + 592, (unint64_t (*)(RB *, const void *))RB::CustomShader::Library::Library(RB::CustomShader::Library::Type,objc_object *)::$_0::__invoke, (BOOL (*)(RB *, RB *, const void *))RB::CustomShader::Library::Library(RB::CustomShader::Library::Type,objc_object *)::$_1::__invoke, 0, (void (*)(void *))RB::CustomShader::Library::Library(RB::CustomShader::Library::Type,objc_object *)::$_2::__invoke, (RB::Heap *)(a1 + 40));
  *(void *)(a1 + 688) = 0;
  *(void *)(a1 + 696) = 0x100000000;
  *(_OWORD *)(a1 + 704) = 0u;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  *(_DWORD *)(a1 + 28) = ++RB::CustomShader::Library::_last_id;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
  return a1;
}

void sub_214181690(_Unwind_Exception *a1)
{
  RB::Heap::~Heap(v2);

  _Unwind_Resume(a1);
}

uint64_t RB::vector<std::pair<unsigned int,RB::objc_ptr<void({block_pointer})(NSError *)>>,0ul,unsigned int>::~vector(uint64_t a1)
{
  uint64_t v2 = *(void ***)a1;
  if (*(_DWORD *)(a1 + 8))
  {
    unint64_t v3 = 0;
    BOOL v4 = v2 + 1;
    do
    {
      unint64_t v5 = *v4;
      v4 += 2;

      ++v3;
    }
    while (v3 < *(unsigned int *)(a1 + 8));
    uint64_t v2 = *(void ***)a1;
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

void RB::CustomShader::Library::~Library(RB::CustomShader::Library *this)
{
  *(void *)this = &unk_26C4ED010;
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 32);
  os_unfair_lock_lock((os_unfair_lock_t)this + 8);
  unint64_t v3 = (char *)this + 672;
  if (*((void *)this + 86)) {
    unint64_t v3 = (char *)*((void *)this + 86);
  }
  uint64_t v4 = *((unsigned int *)this + 174);
  if (v4)
  {
    uint64_t v5 = 16 * v4;
    unsigned int v6 = (void (**)(RB::CustomShader::Library *, void))(v3 + 8);
    do
    {
      (*v6)(this, *(v6 - 1));
      v6 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  os_unfair_lock_unlock(v2);
  uint64_t v7 = (void **)*((void *)this + 88);
  if (*((_DWORD *)this + 178))
  {
    unint64_t v8 = 0;
    unint64_t v9 = v7 + 1;
    do
    {
      uint64_t v10 = *v9;
      v9 += 2;

      ++v8;
    }
    while (v8 < *((unsigned int *)this + 178));
    uint64_t v7 = (void **)*((void *)this + 88);
  }
  if (v7) {
    free(v7);
  }
  int v11 = (void *)*((void *)this + 86);
  if (v11) {
    free(v11);
  }
  RB::UntypedTable::~UntypedTable((RB::CustomShader::Library *)((char *)this + 592));
  RB::Heap::~Heap((RB::CustomShader::Library *)((char *)this + 40));
}

{
  uint64_t vars8;

  RB::CustomShader::Library::~Library(this);
  JUMPOUT(0x21669AC10);
}

void sub_21418180C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v2);
  RB::vector<std::pair<unsigned int,RB::objc_ptr<void({block_pointer})(NSError *)>>,0ul,unsigned int>::~vector(v1 + 704);
  uint64_t v4 = *(void **)(v1 + 688);
  if (v4) {
    free(v4);
  }
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)(v1 + 592));
  RB::Heap::~Heap((RB::Heap *)(v1 + 40));

  _Unwind_Resume(a1);
}

void RB::CustomShader::Library::finalize(RB::CustomShader::Library *this)
{
  global_queue = dispatch_get_global_queue(0, 0);
  dispatch_async_f(global_queue, this, (dispatch_function_t)RB::CustomShader::Library::finalize(void)::$_0::__invoke);
}

void RB::CustomShader::Library::intern_function(os_unfair_lock_s *this@<X0>, NSString *a2@<X1>, uint64_t **a3@<X8>)
{
  unsigned int v6 = this + 8;
  os_unfair_lock_lock(this + 8);
  uint64_t v7 = RB::UntypedTable::lookup((RB::UntypedTable *)&this[148], (uint64_t *)a2, 0);
  if (!v7) {
    operator new();
  }
  if (!*((unsigned char *)v7 + 36))
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v7[2] + 8), 1u, memory_order_relaxed);
    *((unsigned char *)v7 + 36) = 1;
  }
  atomic_fetch_add_explicit((atomic_uint *volatile)v7 + 2, 1u, memory_order_relaxed);
  *a3 = v7;
  os_unfair_lock_unlock(v6);
}

void sub_214181A0C(_Unwind_Exception *a1)
{
  if (atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 0xFFFFFFFF, memory_order_release) == 1) {
    RB::CustomShader::Library::intern_function(v2);
  }
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void RB::CustomShader::Library::add_observer(os_unfair_lock_s *this, void *a2, void (*a3)(RB::CustomShader::Library *, void *))
{
  unsigned int v6 = this + 8;
  os_unfair_lock_lock(this + 8);
  uint32_t os_unfair_lock_opaque = this[174]._os_unfair_lock_opaque;
  unsigned int v8 = os_unfair_lock_opaque + 1;
  if (this[175]._os_unfair_lock_opaque < os_unfair_lock_opaque + 1)
  {
    RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,1ul,unsigned int>::reserve_slow(&this[168], v8);
    uint32_t os_unfair_lock_opaque = this[174]._os_unfair_lock_opaque;
    unsigned int v8 = os_unfair_lock_opaque + 1;
  }
  unint64_t v9 = *(os_unfair_lock_s **)&this[172]._os_unfair_lock_opaque;
  if (!v9) {
    unint64_t v9 = this + 168;
  }
  uint64_t v10 = (char *)&v9[4 * os_unfair_lock_opaque];
  *(void *)uint64_t v10 = a2;
  *((void *)v10 + 1) = a3;
  this[174]._uint32_t os_unfair_lock_opaque = v8;
  os_unfair_lock_unlock(v6);
}

void sub_214181B08(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void RB::CustomShader::Library::remove_observer(os_unfair_lock_s *this, void *a2)
{
  uint64_t v4 = this + 8;
  os_unfair_lock_lock(this + 8);
  uint64_t v5 = this + 168;
  if (*(void *)&this[172]._os_unfair_lock_opaque) {
    uint64_t v5 = *(os_unfair_lock_s **)&this[172]._os_unfair_lock_opaque;
  }
  uint64_t os_unfair_lock_opaque = this[174]._os_unfair_lock_opaque;
  if (os_unfair_lock_opaque)
  {
    uint64_t v7 = v5 + 2;
    uint64_t v8 = 16 * os_unfair_lock_opaque;
    while (*(void **)&v7[-2]._os_unfair_lock_opaque != a2)
    {
      v7 += 4;
      v8 -= 16;
      if (!v8) {
        goto LABEL_9;
      }
    }
    uint32_t v9 = os_unfair_lock_opaque - 1;
    uint64_t v10 = (char *)&v5[4 * v9];
    *(void *)&v7[-2]._uint64_t os_unfair_lock_opaque = *(void *)v10;
    *(void *)uint64_t v10 = a2;
    uint64_t v11 = *(void *)&v7->_os_unfair_lock_opaque;
    *(void *)&v7->_uint64_t os_unfair_lock_opaque = *((void *)v10 + 1);
    *((void *)v10 + 1) = v11;
    this[174]._uint64_t os_unfair_lock_opaque = v9;
  }
LABEL_9:
  os_unfair_lock_unlock(v4);
}

uint64_t RB::CustomShader::Library::add_error_handler(uint64_t a1, void *a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  uint64_t v5 = ++RB::CustomShader::Library::_last_id;
  uint64_t v6 = [a2 copy];
  unsigned int v7 = *(_DWORD *)(a1 + 712);
  unsigned int v8 = v7 + 1;
  if (*(_DWORD *)(a1 + 716) < v7 + 1)
  {
    RB::vector<RBColor,0ul,unsigned int>::reserve_slow(a1 + 704, v8);
    unsigned int v7 = *(_DWORD *)(a1 + 712);
    unsigned int v8 = v7 + 1;
  }
  uint64_t v9 = *(void *)(a1 + 704) + 16 * v7;
  *(_DWORD *)uint64_t v9 = v5;
  *(void *)(v9 + 8) = v6;
  *(_DWORD *)(a1 + 712) = v8;
  os_unfair_lock_unlock(v4);
  return v5;
}

void sub_214181C68(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void RB::CustomShader::Library::remove_error_handler(os_unfair_lock_s *this, int a2)
{
  uint64_t v4 = this + 8;
  os_unfair_lock_lock(this + 8);
  uint32_t os_unfair_lock_opaque = this[178]._os_unfair_lock_opaque;
  if (os_unfair_lock_opaque)
  {
    uint64_t v6 = *(void *)&this[176]._os_unfair_lock_opaque;
    unsigned int v7 = (void *)(v6 + 8);
    uint32_t v8 = this[178]._os_unfair_lock_opaque;
    while (*((_DWORD *)v7 - 2) != a2)
    {
      v7 += 2;
      if (!--v8) {
        goto LABEL_7;
      }
    }
    uint64_t v9 = v6 + 16 * (os_unfair_lock_opaque - 1);
    *((_DWORD *)v7 - 2) = *(_DWORD *)v9;
    *(_DWORD *)uint64_t v9 = a2;
    uint64_t v10 = *v7;
    void *v7 = *(void *)(v9 + 8);
    *(void *)(v9 + 8) = v10;
    unsigned int v11 = this[178]._os_unfair_lock_opaque - 1;
    this[178]._uint32_t os_unfair_lock_opaque = v11;
  }
LABEL_7:
  os_unfair_lock_unlock(v4);
}

BOOL RB::CustomShader::Library::call_error_handler(os_unfair_lock_s *this, NSError *a2)
{
  if (!a2) {
    return 1;
  }
  unint64_t v3 = this + 8;
  os_unfair_lock_lock(this + 8);
  uint32_t os_unfair_lock_opaque = this[178]._os_unfair_lock_opaque;
  BOOL v5 = os_unfair_lock_opaque != 0;
  if (os_unfair_lock_opaque) {
    operator new();
  }
  os_unfair_lock_unlock(v3);
  return v5;
}

void sub_214181E94(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void RB::CustomShader::Library::log_error(os_unfair_lock_s *this, NSError *a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  BOOL v3 = RB::CustomShader::Library::call_error_handler(this, a2);
  if (!v3)
  {
    uint64_t v4 = RB::error_log((RB *)v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      uint64_t v6 = [(NSError *)a2 localizedDescription];
      _os_log_impl(&dword_2140F5000, v4, OS_LOG_TYPE_DEFAULT, "custom shader: %@", (uint8_t *)&v5, 0xCu);
    }
  }
}

uint64_t *RB::CustomShader::Library::prepare_encode(uint64_t *this, RB::Encoder *a2)
{
  uint64_t v3 = *((void *)a2 + 7);
  if (v3)
  {
    if ((*((unsigned char *)a2 + 164) & 1) == 0)
    {
      uint64_t v4 = (size_t *)this;
      CFDataRef theData = 0;
      this = RB::UntypedTable::lookup((RB::Encoder *)((char *)a2 + 80), this, (void **)&theData);
      if (theData != (CFDataRef)v4)
      {
        int v5 = (size_t *)*((void *)a2 + 9);
        *((void *)a2 + 9) = (char *)v5 + 1;
        RB::UntypedTable::insert((size_t **)a2 + 10, v4, v5);
        RB::ProtobufEncoder::encode_varint(a2, 0x7AuLL);
        RB::ProtobufEncoder::begin_length_delimited(a2);
        if (v5)
        {
          RB::ProtobufEncoder::encode_varint(a2, 8uLL);
          RB::ProtobufEncoder::encode_varint(a2, (unint64_t)v5);
        }
        RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
        RB::ProtobufEncoder::begin_length_delimited(a2);
        uint64_t v6 = -[RBShaderLibrary initWithLibrary:]([RBShaderLibrary alloc], (atomic_uint *)v4);
        (*(void (**)(CFDataRef *__return_ptr, uint64_t, void *))(*(void *)v3 + 40))(&theData, v3, v6);
        if (theData)
        {
          BytePtr = CFDataGetBytePtr(theData);
          CFIndex Length = CFDataGetLength(theData);
          if (Length)
          {
            RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
            RB::ProtobufEncoder::encode_data(a2, BytePtr, Length);
          }
          if (theData) {
            CFRelease(theData);
          }
        }
        else
        {
          *((unsigned char *)a2 + 48) = 1;
        }

        RB::ProtobufEncoder::end_length_delimited(a2);
        return RB::ProtobufEncoder::end_length_delimited(a2);
      }
    }
  }
  else
  {
    *((unsigned char *)a2 + 48) = 1;
  }
  return this;
}

void sub_2141820F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  _Unwind_Resume(a1);
}

CFTypeRef RB::CustomShader::Library::decode(RB::CustomShader::Library *this, RB::Decoder *a2)
{
  uint64_t v2 = *((void *)this + 9);
  if (!v2) {
    return 0;
  }
  uint64_t field = RB::ProtobufDecoder::next_field(this);
  if (!field) {
    return 0;
  }
  uint64_t v5 = field;
  CFTypeRef v6 = 0;
  do
  {
    if ((v5 & 0x7FFFFFFF8) == 8)
    {
      uint64_t v7 = RB::ProtobufDecoder::data_field(this, v5);
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)v2 + 24))(&cf, v2, v7, v8);
      CFTypeRef v9 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        RB::ObjectTable::adopt((RB::CustomShader::Library *)((char *)this + 184), v9);
        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef v6 = v9;
      }
    }
    else
    {
      RB::ProtobufDecoder::skip_field(this, v5);
    }
    uint64_t v5 = RB::ProtobufDecoder::next_field(this);
  }
  while (v5);
  return v6;
}

void sub_214182210(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

size_t *RB::CustomShader::Library::decode(RB::ProtobufDecoder *this, char a2)
{
  if ((a2 & 7) != 2) {
    goto LABEL_12;
  }
  RB::ProtobufDecoder::begin_message(this);
  uint64_t field = RB::ProtobufDecoder::next_field(this);
  if (!field)
  {
    unint64_t v5 = 0;
    unint64_t v6 = 0;
    goto LABEL_14;
  }
  unint64_t v4 = field;
  unint64_t v5 = 0;
  unint64_t v6 = 0;
  do
  {
    if ((v4 >> 3) == 2)
    {
      long long v13 = *(_OWORD *)this;
      RB::ProtobufDecoder::skip_field(this, v4);
      unint64_t v6 = v4;
    }
    else if ((v4 >> 3) == 1)
    {
      unint64_t v5 = RB::ProtobufDecoder::uint_field((uint64_t **)this, v4);
    }
    else
    {
      RB::ProtobufDecoder::skip_field(this, v4);
    }
    unint64_t v4 = RB::ProtobufDecoder::next_field(this);
  }
  while (v4);
  if (!(v5 >> 61))
  {
LABEL_14:
    v15[0] = 0;
    uint64_t v7 = (size_t *)RB::UntypedTable::lookup((RB::ProtobufDecoder *)((char *)this + 80), (uint64_t *)(v5 | 0xC000000000000000), v15);
    if ((void *)(v5 | 0xC000000000000000) == v15[0]) {
      goto LABEL_22;
    }
    long long v8 = v13;
    if (!v6)
    {
      RB::Decoder::saved_shared_field((uint64_t)this, 6, v5, (uint64_t)v15);
      LOBYTE(v6) = v16;
      if (!v16)
      {
LABEL_21:
        RB::UntypedTable::insert((size_t **)this + 10, (size_t *)(v5 | 0xC000000000000000), v7);
LABEL_22:
        RB::ProtobufDecoder::end_message((uint64_t)this);
        if (v7) {
          return v7;
        }
        goto LABEL_12;
      }
      long long v8 = *(_OWORD *)v15;
    }
    long long v9 = *(_OWORD *)this;
    *(_OWORD *)this = v8;
    if ((v6 & 7) == 2)
    {
      long long v14 = v9;
      RB::ProtobufDecoder::begin_message(this);
      CFTypeRef v11 = RB::CustomShader::Library::decode(this, v10);
      uint64_t v7 = (size_t *)-[RBDecodedFontMetadata fontUID]((uint64_t)v11);
      RB::ProtobufDecoder::end_message((uint64_t)this);
      long long v9 = v14;
    }
    else
    {
      *((unsigned char *)this + 56) = 1;
    }
    *(_OWORD *)this = v9;
    goto LABEL_21;
  }
  RB::ProtobufDecoder::end_message((uint64_t)this);
LABEL_12:
  uint64_t v7 = 0;
  *((unsigned char *)this + 56) = 1;
  *(void *)this = *((void *)this + 1);
  return v7;
}

void RB::CustomShader::Function::~Function(id *this)
{
  *this = &unk_26C4ED040;
}

{
  uint64_t vars8;

  *this = &unk_26C4ED040;

  JUMPOUT(0x21669AC10);
}

void RB::CustomShader::Function::finalize(RB::CustomShader::Function *this)
{
  uint64_t v2 = (os_unfair_lock_s *)(*((void *)this + 2) + 32);
  os_unfair_lock_lock(v2);
  int v3 = *((unsigned __int8 *)this + 36);
  *((unsigned char *)this + 36) = 0;
  os_unfair_lock_unlock(v2);
  if (v3)
  {
    unint64_t v4 = (atomic_uint *)*((void *)this + 2);
    if (atomic_fetch_add_explicit(v4 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      unint64_t v5 = *(void (**)(void))(*(void *)v4 + 8);
      v5();
    }
  }
}

uint64_t *RB::CustomShader::Function::function(uint64_t a1, uint64_t a2, unsigned int a3, void *a4)
{
  double result = RB::Device::function_library(*(RB::Device **)a2, *(RB::CustomShader::Library **)(a1 + 16));
  if (result)
  {
    *(uint64_t *)((char *)result + 20) = *(void *)(a2 + 84);
    return (uint64_t *)RB::FunctionLibrary::function((uint64_t)result, a1, a3, a4);
  }
  return result;
}

void *RB::CustomShader::Function::encode(RB::CustomShader::Function *this, RB::Encoder *a2)
{
  RB::Encoder::shared_field_f(a2, 1, *((uint64_t **)this + 2));
  unint64_t v4 = (const char *)[*((id *)this + 3) UTF8String];
  double result = (void *)strlen(v4);
  if (result)
  {
    unint64_t v6 = (unint64_t)result;
    RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
    return RB::ProtobufEncoder::encode_data(a2, v4, v6);
  }
  return result;
}

void RB::CustomShader::Function::decode(RB::ProtobufDecoder *this@<X0>, char a2@<W1>, uint64_t **a3@<X8>)
{
  if ((a2 & 7) == 2)
  {
    RB::ProtobufDecoder::begin_message(this);
    unint64_t field = RB::ProtobufDecoder::next_field(this);
    unint64_t v6 = 0;
    if (field)
    {
      uint64_t v7 = 0;
      do
      {
        if ((field >> 3) == 2)
        {
          uint64_t v9 = RB::ProtobufDecoder::data_field(this, field);
          long long v8 = (NSString *)[[NSString alloc] initWithBytes:v9 length:v10 encoding:4];
        }
        else
        {
          if ((field >> 3) == 1) {
            unint64_t v6 = RB::CustomShader::Library::decode(this, field);
          }
          else {
            RB::ProtobufDecoder::skip_field(this, field);
          }
          long long v8 = v7;
        }
        unint64_t field = RB::ProtobufDecoder::next_field(this);
        uint64_t v7 = v8;
      }
      while (field);
    }
    else
    {
      long long v8 = 0;
    }
    RB::ProtobufDecoder::end_message((uint64_t)this);
    if (v6 && [(NSString *)v8 length])
    {
      RB::CustomShader::Library::intern_function((os_unfair_lock_s *)v6, v8, a3);
      goto LABEL_18;
    }
  }
  else
  {
    long long v8 = 0;
    *((unsigned char *)this + 56) = 1;
    *(void *)this = *((void *)this + 1);
  }
  *a3 = 0;
LABEL_18:
}

void sub_214182788(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL RB::CustomShader::Closure::operator==(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  if (*a1 != *a2)
  {
    BOOL v4 = !v2 || v3 == 0;
    if (v4 || *(_DWORD *)(v2 + 32) != *(_DWORD *)(v3 + 32)) {
      return 0;
    }
  }
  uint64_t v5 = a1[14];
  if (v5 != a2[14]) {
    return 0;
  }
  if (a1[13]) {
    unint64_t v6 = (RB::CustomShader::Value *)a1[13];
  }
  else {
    unint64_t v6 = (RB::CustomShader::Value *)(a1 + 1);
  }
  if (!v5) {
    return 1;
  }
  if (a2[13]) {
    uint64_t v7 = a2[13];
  }
  else {
    uint64_t v7 = (uint64_t)(a2 + 1);
  }
  uint64_t v8 = 24 * v5 - 24;
  do
  {
    BOOL result = RB::CustomShader::Value::operator==(v6, v7);
    if (!result) {
      break;
    }
    unint64_t v6 = (RB::CustomShader::Value *)((char *)v6 + 24);
    v7 += 24;
    uint64_t v10 = v8;
    v8 -= 24;
  }
  while (v10);
  return result;
}

void RB::CustomShader::Closure::ensure_arg(RB::CustomShader::Closure *this, unint64_t a2)
{
  _OWORD v14[3] = *(const void **)MEMORY[0x263EF8340];
  unint64_t v2 = *((void *)this + 14);
  if (v2 <= a2)
  {
    uint64_t v5 = (char *)this + 8;
    unint64_t v6 = a2 + 1;
    v14[0] = (const void *)0x401010000000000;
    if (v2 >= a2 + 1)
    {
      uint64_t v10 = (char *)*((void *)this + 13);
      if (!v10) {
        uint64_t v10 = v5;
      }
      if (v6 < v2)
      {
        CFTypeRef v11 = (const void **)&v10[24 * a2 + 24];
        unint64_t v12 = a2 + 1;
        do
        {
          RB::CustomShader::Value::reset_data(v11);
          ++v12;
          v11 += 3;
        }
        while (v12 < *((void *)this + 14));
      }
    }
    else
    {
      if (*((void *)this + 15) < v6)
      {
        long long v13 = v5;
        RB::vector<RB::CustomShader::Value,4ul,unsigned long>::reserve_slow(v5, a2 + 1);
        unint64_t v2 = *((void *)this + 14);
        uint64_t v5 = v13;
      }
      uint64_t v7 = (char *)*((void *)this + 13);
      if (!v7) {
        uint64_t v7 = v5;
      }
      if (v2 < v6)
      {
        uint64_t v8 = a2 - v2 + 1;
        uint64_t v9 = (RB::CustomShader::Value *)&v7[24 * v2];
        do
        {
          uint64_t v9 = (RB::CustomShader::Value *)((char *)RB::CustomShader::Value::Value(v9, (const RB::CustomShader::Value *)v14)+ 24);
          --v8;
        }
        while (v8);
      }
    }
    *((void *)this + 14) = v6;
    RB::CustomShader::Value::reset_data(v14);
  }
}

void sub_2141829A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t RB::CustomShader::Closure::prepare(uint64_t this, uint64_t **a2)
{
  uint64_t v2 = this + 8;
  uint64_t v3 = *(void *)(this + 112);
  if (*(void *)(this + 104)) {
    uint64_t v2 = *(void *)(this + 104);
  }
  if (v3)
  {
    uint64_t v5 = 24 * v3;
    uint64_t v6 = v2 + 8;
    __asm { FMOV            V8.2S, #1.0 }
    do
    {
      int v12 = *(unsigned __int8 *)(v6 - 4);
      if ((v12 - 9) >= 0xFFFFFFFE)
      {
        uint64_t v16 = 0;
        v17[0] = 0;
        v17[1] = _D8;
        v17[2] = 0;
        v17[3] = 0;
        int v20 = 1065353216;
        long long v18 = xmmword_214218320;
        long long v19 = xmmword_214218320;
        uint64_t v21 = 0x3C003C003C003C00;
        __int16 v22 = 0;
        if (v12 == 8) {
          __int16 v13 = 768;
        }
        else {
          __int16 v13 = 256;
        }
        __int16 v23 = v13;
        v14[0] = (float64x2_t)xmmword_2142181C0;
        v14[1] = (float64x2_t)xmmword_2142181D0;
        uint64_t v15 = 0;
        this = RB::ImageTexture::prepare(v6, a2, (const RB::Fill::ImageData *)v17, v14, 1);
      }
      v6 += 24;
      v5 -= 24;
    }
    while (v5);
  }
  return this;
}

uint64_t RB::CustomShader::Value::image(RB::CustomShader::Value *this)
{
  if (*((unsigned __int8 *)this + 4) - 7 >= 2) {
    return 0;
  }
  else {
    return (uint64_t)this + 8;
  }
}

uint64_t RB::CustomShader::Closure::marshal_args(void *a1, uint64_t a2, uint64_t a3, _OWORD *a4, uint64_t a5, uint64_t a6, void *a7)
{
  uint64_t v7 = a1;
  v79[1] = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a3 + 64);
  uint64_t v9 = a1[14];
  if (v8 == v9)
  {
    uint64_t v60 = *(void *)(a3 + 64);
    uint64_t v76 = 0x401010000000000;
    if (a4)
    {
      *(_OWORD *)float v65 = *a4;
      RB::CustomShader::Value::set_bytes((uint64_t)&v76, 4u, 1uLL, v65);
      uint64_t v60 = *(void *)(a3 + 64);
    }
    uint64_t v56 = a6;
    uint64_t v57 = a2;
    __int16 v13 = v7 + 1;
    uint64_t v71 = 0;
    uint64_t v72 = 0;
    unint64_t v73 = 0;
    *a7 = 0;
    uint64_t v14 = v60;
    if (v60)
    {
      uint64_t v15 = 0;
      uint64_t v58 = 0;
      uint64_t v16 = 0;
      uint64_t v17 = a3;
      uint64_t v18 = 4;
      __asm { FMOV            V8.2S, #1.0 }
      while (1)
      {
        if (*(void *)(v17 + 56)) {
          uint64_t v24 = *(void *)(v17 + 56);
        }
        else {
          uint64_t v24 = a3 + 24;
        }
        uint64_t v25 = (void *)v7[13];
        if (!v25) {
          uint64_t v25 = v13;
        }
        uint64_t v26 = (char *)v25 + v18;
        int v27 = *((unsigned __int8 *)v25 + v18);
        if (v27 == 6) {
          uint64_t v28 = (unsigned int *)&v76;
        }
        else {
          uint64_t v28 = (unsigned int *)((char *)v25 + v18 - 4);
        }
        unint64_t v29 = *(unsigned int *)(v24 + 4 * v16);
        int v30 = *(_DWORD *)(v24 + 4 * v16) & 0x3F;
        if (v30 == 4)
        {
          if (v27 == 6) {
            uint64_t v26 = (char *)&v76 + 4;
          }
          if (*v26 - 7 > 1) {
            goto LABEL_54;
          }
          if (!*a7)
          {
            char v31 = (void *)((char *)v25 + v18 + 4);
            uint64_t v32 = (CGImage **)(v27 == 6 ? &v77 : v31);
            *(void *)float v65 = 0;
            *(void *)&v65[8] = _D8;
            *(_OWORD *)&v65[16] = 0uLL;
            int v68 = 1065353216;
            long long v66 = xmmword_214218320;
            long long v67 = xmmword_214218320;
            uint64_t v69 = 0x3C003C003C003C00;
            int v70 = 0x1000000;
            __int16 v33 = *v26 == 8 ? 768 : 256;
            HIWORD(v70) = v33;
            unsigned int v34 = *(id ****)v57;
            v62[0] = (float64x2_t)xmmword_2142181C0;
            v62[1] = (float64x2_t)xmmword_2142181D0;
            uint64_t v63 = 0;
            uint64_t v64 = 0;
            uint64_t v35 = RB::ImageTexture::texture(v32, (uint64_t **)v34, (const RB::Fill::ImageData *)v65, v62, 1);
            *a7 = v35;
            uint64_t v17 = a3;
            if (!v35) {
              *a7 = RB::Device::invalid_texture(***(id ****)v57);
            }
          }
        }
        else
        {
          float v36 = a7;
          float32x4_t v37 = v7;
          uint64_t v38 = (float16x4_t *)(a5 + ((v29 >> 6) & 0x3FFFFFC));
          if ((v29 & 0x40) != 0)
          {
            if ((RB::CustomShader::Value::prepare_array(v28, v30, (uint64_t)v65) & 1) == 0) {
              goto LABEL_53;
            }
            unint64_t v40 = (v58 + 15);
            if ((v40 >> 31)) {
              goto LABEL_55;
            }
            uint64_t v41 = v40 & 0xFFFFFFF0;
            v38->i32[0] = v40 & 0xFFFFFFF0;
            uint64_t v42 = v72;
            if (v73 < v72 + 1)
            {
              RB::vector<RB::CustomShader::Closure::marshal_args(RB::RenderPass &,RB::Function &,RB::Rect const*,unsigned char *,RB::BufferRegion &,RB::Texture *&)::PendingArg,0ul,unsigned long>::reserve_slow((uint64_t)&v71, v72 + 1);
              uint64_t v42 = v72;
            }
            uint64_t v43 = &v71[48 * v42];
            *(void *)uint64_t v43 = v16;
            *((void *)v43 + 1) = v41;
            *((_OWORD *)v43 + 1) = *(_OWORD *)v65;
            *((_OWORD *)v43 + 2) = *(_OWORD *)&v65[16];
            ++v72;
            _CF = __CFADD__(v41, *(void *)&v65[24]);
            uint64_t v44 = (RB::Device *)(v41 + *(void *)&v65[24]);
            uint64_t v17 = a3;
            if (_CF) {
              goto LABEL_55;
            }
            if ((*(unsigned char *)(v24 + 4 * v16) & 0x80) != 0)
            {
              if (*(void *)&v65[8] >> 31)
              {
LABEL_53:
                uint64_t v7 = v37;
LABEL_54:
                unsigned int v51 = (void *)MEMORY[0x263F087E8];
                uint64_t v74 = *MEMORY[0x263F08320];
                float16x4_t v52 = NSString;
                uint64_t v53 = *(void *)(*v7 + 24);
                float16x4_t v54 = RB::CustomShader::Value::description((RB::CustomShader::Value *)v28);
                uint64_t v75 = [v52 stringWithFormat:@"Invalid shader argument: %@, #%d: %@, expected %@", v53, v16, v54, RB::Function::Param::description((RB::Function::Param *)(v24 - v15))];
                RB::CustomShader::Library::log_error(*(os_unfair_lock_s **)(*v7 + 16), (NSError *)objc_msgSend(v51, "errorWithDomain:code:userInfo:", @"com.apple.RenderBox.RBShaderError", 3, objc_msgSend(NSDictionary, "dictionaryWithObjects:forKeys:count:", &v75, &v74, 1)));
LABEL_55:
                uint64_t v46 = 0;
LABEL_56:
                uint64_t v48 = v71;
                if (v71) {
                  goto LABEL_57;
                }
                goto LABEL_58;
              }
              v38->i32[1] = *(_DWORD *)&v65[8];
            }
            uint64_t v58 = v44;
            uint64_t v7 = v37;
            a7 = v36;
            uint64_t v14 = v60;
          }
          else
          {
            char v39 = RB::CustomShader::Value::convert((uint64_t)v28, v30, v38, *(unsigned __int8 *)(v57 + 124));
            uint64_t v7 = v37;
            a7 = v36;
            uint64_t v14 = v60;
            if ((v39 & 1) == 0) {
              goto LABEL_54;
            }
          }
        }
        ++v16;
        v18 += 24;
        v15 -= 4;
        if (v14 == v16) {
          goto LABEL_44;
        }
      }
    }
    uint64_t v58 = 0;
LABEL_44:
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v57, v58, 4uLL, 0, v65);
    uint64_t v47 = *(void *)v65;
    *(void *)uint64_t v56 = *(void *)v65;
    *(_OWORD *)(v56 + 8) = *(_OWORD *)&v65[8];
    if (!v47) {
      goto LABEL_55;
    }
    uint64_t v48 = v71;
    if (v72)
    {
      char v49 = &v71[48 * v72];
      do
      {
        uint64_t v50 = (void *)v7[13];
        if (!v50) {
          uint64_t v50 = v13;
        }
        RB::CustomShader::Value::convert((uint64_t)&v50[3 * *(void *)v48], v48[16], *((void *)v48 + 4), (float16x4_t *)(*(void *)(*(void *)v56 + 56) + *(void *)(v56 + 8) + *((void *)v48 + 1)), *(unsigned __int8 *)(v57 + 124));
        v48 += 48;
      }
      while (v48 != v49);
      uint64_t v46 = 1;
      goto LABEL_56;
    }
    uint64_t v46 = 1;
    if (v71) {
LABEL_57:
    }
      free(v48);
LABEL_58:
    RB::CustomShader::Value::reset_data((const void **)&v76);
  }
  else
  {
    uint64_t v45 = (void *)MEMORY[0x263F087E8];
    uint64_t v78 = *MEMORY[0x263F08320];
    v79[0] = [NSString stringWithFormat:@"Invalid number of shader arguments: %@: %d, expected %d", *(void *)(*a1 + 24), v9, v8];
    RB::CustomShader::Library::log_error(*(os_unfair_lock_s **)(*v7 + 16), (NSError *)objc_msgSend(v45, "errorWithDomain:code:userInfo:", @"com.apple.RenderBox.RBShaderError", 4, objc_msgSend(NSDictionary, "dictionaryWithObjects:forKeys:count:", v79, &v78, 1)));
    return 0;
  }
  return v46;
}

void sub_214183070(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void **)(v1 - 192);
  if (v3) {
    free(v3);
  }
  RB::CustomShader::Value::reset_data((const void **)(v1 - 152));
  _Unwind_Resume(a1);
}

void RB::CustomShader::Value::set_bytes(uint64_t a1, unsigned int a2, unint64_t a3, const UInt8 *a4)
{
  RB::CustomShader::Value::reset_data((const void **)a1);
  if (!HIDWORD(a3))
  {
    *(_DWORD *)a1 = a3;
    *(unsigned char *)(a1 + 4) = a2;
    if (a2 - 7 > 1)
    {
      size_t v10 = *((unsigned __int8 *)&RB::CustomShader::Value::bytes_per_element + a2) * a3;
      if (v10 > 0x10)
      {
        *(unsigned char *)(a1 + 7) &= ~4u;
        *(void *)(a1 + 8) = CFDataCreate(0, a4, v10);
      }
      else
      {
        memcpy((void *)(a1 + 8), a4, v10);
      }
    }
    else
    {
      uint64_t v8 = (const void *)*((void *)a4 + 1);
      if (v8)
      {
        CFRetain(v8);
        uint64_t v9 = (const void *)*((void *)a4 + 1);
      }
      else
      {
        uint64_t v9 = 0;
      }
      CFTypeRef v11 = (CGImage *)*(unsigned int *)a4;
      RB::ImageTexture::ImageTexture((RB::ImageTexture *)(a1 + 8), v11, v9);
    }
  }
}

uint64_t RB::CustomShader::Value::convert(uint64_t a1, int a2, float16x4_t *__dst, int a4)
{
  if (*(_DWORD *)a1 != 1) {
    return 0;
  }
  uint64_t v4 = 0;
  switch(*(unsigned char *)(a1 + 4))
  {
    case 1:
      if (a2 != 5) {
        return 0;
      }
      goto LABEL_15;
    case 2:
      if (a2 != 6) {
        return 0;
      }
      char v6 = *(unsigned char *)(a1 + 7);
      BytePtr = (CFDataRef *)(a1 + 8);
      if ((v6 & 4) == 0) {
        BytePtr = (CFDataRef *)CFDataGetBytePtr(*BytePtr);
      }
      CFDataRef v8 = *BytePtr;
      goto LABEL_13;
    case 3:
      if (a2 != 7) {
        return 0;
      }
      char v9 = *(unsigned char *)(a1 + 7);
      size_t v10 = (const UInt8 *)(a1 + 8);
      if ((v9 & 4) == 0) {
        size_t v10 = CFDataGetBytePtr(*(CFDataRef *)v10);
      }
      CFDataRef v8 = *(CFDataRef *)v10;
      __dst[1].i32[0] = *((_DWORD *)v10 + 2);
LABEL_13:
      *__dst = (float16x4_t)v8;
      goto LABEL_22;
    case 4:
      if (a2 != 8) {
        return 0;
      }
      char v13 = *(unsigned char *)(a1 + 7);
      uint64_t v14 = (CFDataRef *)(a1 + 8);
      if ((v13 & 4) == 0) {
        uint64_t v14 = (CFDataRef *)CFDataGetBytePtr(*v14);
      }
      *(_OWORD *)__dst->i8 = *(_OWORD *)v14;
      goto LABEL_22;
    case 5:
      if (a2 != 2) {
        return 0;
      }
      uint64_t v4 = 1;
      RB::CustomShader::Value::convert(a1, 3, 1uLL, __dst, a4);
      return v4;
    case 9:
      if (a2 != 1) {
        return 0;
      }
LABEL_15:
      char v11 = *(unsigned char *)(a1 + 7);
      int v12 = (CFDataRef *)(a1 + 8);
      if ((v11 & 4) == 0) {
        int v12 = (CFDataRef *)CFDataGetBytePtr(*v12);
      }
      __dst->i32[0] = *(_DWORD *)v12;
LABEL_22:
      uint64_t v4 = 1;
      break;
    default:
      return v4;
  }
  return v4;
}

uint64_t RB::CustomShader::Value::prepare_array(unsigned int *a1, int a2, uint64_t a3)
{
  uint64_t result = 0;
  switch(*((unsigned char *)a1 + 4))
  {
    case 0:
      if (a2) {
        return 0;
      }
      *(unsigned char *)a3 = 0;
      uint64_t v5 = *a1;
      *(void *)(a3 + 8) = v5;
      *(void *)(a3 + 16) = v5;
      goto LABEL_17;
    case 1:
      if (a2 != 5) {
        return 0;
      }
      uint64_t v6 = *a1;
      uint64_t v7 = v6;
      goto LABEL_12;
    case 2:
      if (a2 != 6) {
        return 0;
      }
      uint64_t v6 = *a1;
      uint64_t v7 = 2 * v6;
      goto LABEL_12;
    case 3:
      if (a2 != 7) {
        return 0;
      }
      uint64_t v6 = *a1;
      uint64_t v7 = 3 * v6;
      goto LABEL_12;
    case 4:
      if (a2 != 8) {
        return 0;
      }
      uint64_t v6 = *a1;
      uint64_t v7 = 4 * v6;
LABEL_12:
      uint64_t result = 1;
      *(unsigned char *)a3 = 1;
      *(void *)(a3 + 8) = v6;
      *(void *)(a3 + 16) = v7;
      *(void *)(a3 + 24) = 4 * v7;
      return result;
    case 5:
      if (a2 != 2) {
        return 0;
      }
      *(unsigned char *)a3 = 3;
      uint64_t v8 = *a1;
      *(void *)(a3 + 8) = v8;
      *(void *)(a3 + 16) = v8;
      uint64_t v5 = 8 * v8;
      goto LABEL_17;
    case 9:
      if (a2 != 1) {
        return 0;
      }
      uint64_t v9 = *a1;
      *(unsigned char *)a3 = 2;
      *(void *)(a3 + 8) = v9;
      *(void *)(a3 + 16) = v9;
      uint64_t v5 = 4 * v9;
LABEL_17:
      *(void *)(a3 + 24) = v5;
      return 1;
    default:
      return result;
  }
}

__CFString *RB::CustomShader::Value::description(RB::CustomShader::Value *this)
{
  unint64_t v1 = *((unsigned __int8 *)this + 4);
  if (v1 > 7) {
    return @"Unknown";
  }
  uint64_t v2 = RB::CustomShader::Value::description(void)const::names[v1];
  uint64_t v3 = *(unsigned int *)this;
  uint64_t v4 = NSString;
  if (v3 != 1) {
    return (__CFString *)objc_msgSend(NSString, "stringWithFormat:", @"%s[%u]", v2, v3);
  }
  return (__CFString *)[v4 stringWithUTF8String:v2];
}

uint64_t RB::CustomShader::Value::convert(uint64_t a1, int a2, size_t __n, float16x4_t *__dst, int a5)
{
  BytePtr = (CFDataRef *)(a1 + 8);
  if ((*(unsigned char *)(a1 + 7) & 4) == 0) {
    BytePtr = (CFDataRef *)CFDataGetBytePtr(*BytePtr);
  }
  if ((a2 - 1) < 2)
  {
    __n *= 4;
  }
  else if (a2)
  {
    if (a2 == 3 && __n)
    {
      do
      {
        __int16 v11 = *(_WORD *)(a1 + 5);
        float32x4_t v12 = *(float32x4_t *)BytePtr;
        BytePtr += 2;
        double v14 = COERCE_DOUBLE(vcvt_f16_f32(v12));
        __int16 v15 = v11;
        *__dst++ = RB::Fill::Color::prepare((uint64_t)&v14, a5, v14);
        --__n;
      }
      while (__n);
    }
    return 1;
  }
  switch(__n)
  {
    case 1uLL:
      __dst->i8[0] = *(unsigned char *)BytePtr;
      break;
    case 2uLL:
      __dst->i16[0] = *(_WORD *)BytePtr;
      break;
    case 3uLL:
    case 5uLL:
    case 6uLL:
    case 7uLL:
      goto LABEL_14;
    case 4uLL:
      __dst->i32[0] = *(_DWORD *)BytePtr;
      break;
    case 8uLL:
      *__dst = (float16x4_t)*BytePtr;
      break;
    default:
      if (__n == 16) {
        *(_OWORD *)__dst->i8 = *(_OWORD *)BytePtr;
      }
      else {
LABEL_14:
      }
        memcpy(__dst, BytePtr, __n);
      break;
  }
  return 1;
}

uint64_t RB::CustomShader::Closure::marshal_layer_arg(uint64_t a1, uint64_t a2, uint64_t a3, int a4, float64x2_t *a5, float32x2_t *a6)
{
  uint64_t v6 = (float32x2_t *)(a3 + (4 * a4));
  *uint64_t v6 = vcvt_f32_f64(*a5);
  v6[1] = vcvt_f32_f64(a5[1]);
  void v6[2] = vcvt_f32_f64(a5[2]);
  float64x2_t v6[3] = *a6;
  v6[4] = vadd_f32(a6[1], *a6);
  return 1;
}

BOOL RB::CustomShader::Closure::can_mix(RB::CustomShader::Closure *this, const Closure *a2)
{
  return *(_DWORD *)(*(void *)this + 32) == *((_DWORD *)a2->function._p + 8);
}

void RB::CustomShader::Closure::mix(RB::CustomShader::Closure *this, const RB::CustomShader::Closure *a2, float a3)
{
  unint64_t v3 = *((void *)this + 14);
  if (*((void *)a2 + 14) < v3) {
    unint64_t v3 = *((void *)a2 + 14);
  }
  if (v3)
  {
    unint64_t v7 = 0;
    int v27 = (char *)a2 + 8;
    uint64_t v8 = (char *)this + 8;
    do
    {
      if (*((void *)this + 13)) {
        uint64_t v9 = (char *)*((void *)this + 13);
      }
      else {
        uint64_t v9 = v8;
      }
      size_t v10 = &v9[24 * v7];
      if (*((void *)a2 + 13)) {
        __int16 v11 = (char *)*((void *)a2 + 13);
      }
      else {
        __int16 v11 = v27;
      }
      int v12 = v10[4];
      if (v10[4]) {
        BOOL v13 = v12 == v11[24 * v7 + 4];
      }
      else {
        BOOL v13 = 0;
      }
      if (v13 && *(_DWORD *)v10 == *(_DWORD *)&v11[24 * v7])
      {
        BytePtr = (CFDataRef *)&RB::CustomShader::Value::data_ptr(void)const::null_image;
        if ((v12 - 7) >= 2)
        {
          __int16 v15 = &v11[24 * v7];
          BytePtr = (CFDataRef *)(v15 + 8);
          if ((v15[7] & 4) == 0) {
            BytePtr = (CFDataRef *)CFDataGetBytePtr(*BytePtr);
          }
        }
        if ((v9[24 * v7 + 7] & 4) != 0) {
          uint64_t v16 = (UInt8 *)&v9[24 * v7 + 8];
        }
        else {
          uint64_t v16 = RB::CustomShader::Value::mutable_data_ptr((RB::CustomShader::Value *)&v9[24 * v7]);
        }
        int v17 = v10[4];
        if ((v17 - 1) >= 4)
        {
          if (v17 == 5 && *(_DWORD *)v10)
          {
            unint64_t v21 = 0;
            __int16 v22 = &v9[24 * v7 + 5];
            __int16 v23 = &v11[24 * v7 + 5];
            do
            {
              __int16 v24 = *(_WORD *)v22;
              float16x4_t v30 = vcvt_f16_f32(*(float32x4_t *)&v16[16 * v21]);
              __int16 v31 = v24;
              __int16 v25 = *(_WORD *)v23;
              float16x4_t v28 = vcvt_f16_f32(*(float32x4_t *)&BytePtr[2 * v21]);
              __int16 v29 = v25;
              RB::Fill::Color::mix((uint64_t)&v30, (uint64_t)&v28, 3, a3);
              *(float32x4_t *)&v16[16 * v21] = vcvtq_f32_f16(v30);
              if (!v21) {
                *(_WORD *)__int16 v22 = v31;
              }
              ++v21;
            }
            while (v21 < *(unsigned int *)v10);
          }
        }
        else
        {
          unsigned int v18 = *(_DWORD *)v10;
          if (v17 == 2) {
            unsigned int v18 = 2 * *(_DWORD *)v10;
          }
          if (v17 == 3) {
            unsigned int v18 = 3 * *(_DWORD *)v10;
          }
          if (v17 == 4) {
            uint64_t v19 = (4 * *(_DWORD *)v10);
          }
          else {
            uint64_t v19 = v18;
          }
          if (v19)
          {
            do
            {
              float v20 = *(float *)BytePtr;
              BytePtr = (CFDataRef *)((char *)BytePtr + 4);
              *(float *)uint64_t v16 = *(float *)v16 + (float)((float)(v20 - *(float *)v16) * a3);
              v16 += 4;
              --v19;
            }
            while (v19);
          }
        }
      }
      ++v7;
      unint64_t v26 = *((void *)this + 14);
      if (*((void *)a2 + 14) < v26) {
        unint64_t v26 = *((void *)a2 + 14);
      }
    }
    while (v7 < v26);
  }
}

CFDataRef *RB::CustomShader::Value::data_ptr(RB::CustomShader::Value *this)
{
  if (*((unsigned __int8 *)this + 4) - 7 < 2) {
    return (CFDataRef *)&RB::CustomShader::Value::data_ptr(void)const::null_image;
  }
  char v2 = *((unsigned char *)this + 7);
  uint64_t result = (CFDataRef *)((char *)this + 8);
  if ((v2 & 4) == 0) {
    return (CFDataRef *)CFDataGetBytePtr(*result);
  }
  return result;
}

UInt8 *RB::CustomShader::Value::mutable_data_ptr(RB::CustomShader::Value *this)
{
  if (*((unsigned __int8 *)this + 4) - 7 < 2) {
    return 0;
  }
  unint64_t v1 = (CFDataRef *)((char *)this + 8);
  if ((*((unsigned char *)this + 7) & 4) != 0) {
    return (UInt8 *)v1;
  }
  CFMutableDataRef MutableCopy = CFDataCreateMutableCopy(0, 0, *v1);
  if (!MutableCopy) {
    return 0;
  }
  unint64_t v3 = MutableCopy;
  CFRelease(*v1);
  *unint64_t v1 = v3;
  return CFDataGetMutableBytePtr(v3);
}

uint64_t *RB::CustomShader::Closure::prepare_encode(RB::CustomShader::Closure *this, RB::Encoder *a2)
{
  uint64_t result = RB::CustomShader::Library::prepare_encode(*(uint64_t **)(*(void *)this + 16), a2);
  uint64_t v5 = (char *)this + 8;
  uint64_t v6 = *((void *)this + 14);
  if (*((void *)this + 13)) {
    uint64_t v5 = (char *)*((void *)this + 13);
  }
  if (v6)
  {
    uint64_t v7 = 24 * v6;
    uint64_t v8 = v5 + 8;
    do
    {
      if (*(v8 - 4) - 7 <= 1) {
        uint64_t result = RB::Encoder::prepare_image((uint64_t *)a2, *((unsigned int *)v8 + 2), *(uint64_t **)v8);
      }
      v8 += 24;
      v7 -= 24;
    }
    while (v7);
  }
  return result;
}

RB::CustomShader::Function **RB::CustomShader::Closure::encode(RB::CustomShader::Function **this, RB::Encoder *a2)
{
  unint64_t v3 = this;
  uint64_t v4 = *this;
  if (*this)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::CustomShader::Function::encode(v4, a2);
    this = (RB::CustomShader::Function **)RB::ProtobufEncoder::end_length_delimited(a2);
  }
  uint64_t v5 = v3[14];
  if (v3[13]) {
    uint64_t v6 = v3[13];
  }
  else {
    uint64_t v6 = (RB::CustomShader::Function *)(v3 + 1);
  }
  if (v5)
  {
    uint64_t v7 = 24 * (void)v5;
    do
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::CustomShader::Value::encode(v6, a2);
      this = (RB::CustomShader::Function **)RB::ProtobufEncoder::end_length_delimited(a2);
      uint64_t v6 = (RB::CustomShader::Function *)((char *)v6 + 24);
      v7 -= 24;
    }
    while (v7);
  }
  return this;
}

unint64_t RB::CustomShader::Closure::decode(RB::CustomShader::Closure *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      if ((v5 >> 3) == 2)
      {
        uint64_t v7 = *((void *)this + 14);
        if (*((void *)this + 15) < (unint64_t)(v7 + 1))
        {
          RB::vector<RB::CustomShader::Value,4ul,unsigned long>::reserve_slow((char *)this + 8, v7 + 1);
          uint64_t v7 = *((void *)this + 14);
        }
        uint64_t v8 = (char *)*((void *)this + 13);
        if (!v8) {
          uint64_t v8 = (char *)this + 8;
        }
        uint64_t v9 = &v8[24 * v7];
        *(_DWORD *)uint64_t v9 = 0;
        *((_WORD *)v9 + 2) = 256;
        v9[6] = 1;
        v9[7] = v9[7] & 0xF8 | 4;
        uint64_t v10 = *((void *)this + 14);
        *((void *)this + 14) = v10 + 1;
        if ((v5 & 7) == 2)
        {
          __int16 v11 = (char *)*((void *)this + 13);
          if (!v11) {
            __int16 v11 = (char *)this + 8;
          }
          int v12 = (RB::CustomShader::Value *)&v11[24 * v10];
          RB::ProtobufDecoder::begin_message(a2);
          RB::CustomShader::Value::decode(v12, a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
        }
      }
      else if ((v5 >> 3) == 1)
      {
        RB::CustomShader::Function::decode(a2, v5, &v13);
        uint64_t v6 = *(void *)this;
        *(void *)this = v13;
        BOOL v13 = (uint64_t *)v6;
        if (v6 && atomic_fetch_add_explicit((atomic_uint *volatile)(v6 + 8), 0xFFFFFFFF, memory_order_release) == 1)
        {
          __dmb(9u);
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v5);
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  if (!*(void *)this)
  {
    *((unsigned char *)a2 + 56) = 1;
    *(void *)a2 = *((void *)a2 + 1);
  }
  return result;
}

void RB::CustomShader::Value::reset_data(const void **this)
{
  if ((*((unsigned char *)this + 7) & 4) != 0)
  {
    if (*((unsigned __int8 *)this + 4) - 7 <= 1) {
      RB::RetainedImageTexture::~RetainedImageTexture(this + 1);
    }
  }
  else
  {
    CFRelease(this[1]);
    *((unsigned char *)this + 7) |= 4u;
  }
  *(_DWORD *)this = 0;
  *((unsigned char *)this + 4) = 0;
}

unint64_t RB::CustomShader::Value::set_data(uint64_t a1, int a2, const __CFData *a3)
{
  RB::CustomShader::Value::reset_data((const void **)a1);
  unint64_t result = CFDataGetLength(a3);
  unint64_t v7 = HIDWORD(result);
  if (!HIDWORD(result))
  {
    size_t v8 = result;
    switch(a2)
    {
      case 0:
        LODWORD(v7) = result;
        goto LABEL_8;
      case 1:
      case 9:
        unint64_t v7 = result >> 2;
        goto LABEL_8;
      case 2:
        unint64_t v7 = result >> 3;
        goto LABEL_8;
      case 3:
        LODWORD(v7) = result / 0xC;
        goto LABEL_8;
      case 4:
      case 5:
        unint64_t v7 = result >> 4;
        goto LABEL_8;
      case 7:
      case 8:
        return result;
      default:
LABEL_8:
        *(_DWORD *)a1 = v7;
        *(unsigned char *)(a1 + 4) = a2;
        if (result > 0x10)
        {
          *(unsigned char *)(a1 + 7) &= ~4u;
          unint64_t result = (unint64_t)CFDataCreateCopy(0, a3);
          *(void *)(a1 + 8) = result;
        }
        else
        {
          BytePtr = CFDataGetBytePtr(a3);
          unint64_t result = (unint64_t)memcpy((void *)(a1 + 8), BytePtr, v8);
        }
        break;
    }
  }
  return result;
}

RB::CustomShader::Value *RB::CustomShader::Value::Value(RB::CustomShader::Value *this, const RB::CustomShader::Value *a2)
{
  *(_DWORD *)this = *(_DWORD *)a2;
  int v3 = *((unsigned __int8 *)a2 + 4);
  *((unsigned char *)this + 4) = v3;
  *(_WORD *)((char *)this + 5) = *(_WORD *)((char *)a2 + 5);
  char v4 = *((unsigned char *)this + 7) & 0xFE | *((unsigned char *)a2 + 7) & 1;
  *((unsigned char *)this + 7) = v4;
  char v5 = v4 & 0xFD | *((unsigned char *)a2 + 7) & 2;
  *((unsigned char *)this + 7) = v5;
  int v6 = *((unsigned char *)a2 + 7) & 4;
  *((unsigned char *)this + 7) = v5 & 0xFB | v6;
  unint64_t v7 = (_OWORD *)((char *)this + 8);
  if ((v3 - 7) > 1)
  {
    size_t v8 = (CFTypeRef *)((char *)a2 + 8);
    if (v6) {
      _OWORD *v7 = *(_OWORD *)v8;
    }
    else {
      *(void *)unint64_t v7 = CFRetain(*v8);
    }
  }
  else
  {
    RB::RetainedImageTexture::RetainedImageTexture((RB::CustomShader::Value *)((char *)this + 8), (const RB::CustomShader::Value *)((char *)a2 + 8));
  }
  return this;
}

BOOL RB::CustomShader::Value::operator==(RB::CustomShader::Value *this, uint64_t a2)
{
  int v2 = *((unsigned __int8 *)this + 4);
  if (v2 != *(unsigned __int8 *)(a2 + 4) || *(_DWORD *)this != *(_DWORD *)a2) {
    return 0;
  }
  int v5 = *(unsigned __int8 *)(a2 + 6);
  if (*((unsigned char *)this + 6)) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if ((*((unsigned char *)this + 6) != 0) != (v5 != 0)) {
      return 0;
    }
  }
  else if (*((unsigned __int8 *)this + 5) != *(unsigned __int8 *)(a2 + 5))
  {
    return 0;
  }
  if (((*(unsigned char *)(a2 + 7) ^ *((unsigned char *)this + 7)) & 3) != 0) {
    return 0;
  }
  if ((v2 - 7) > 1)
  {
    uint64_t v9 = RB::CustomShader::Value::data_ptr(this);
    uint64_t v10 = RB::CustomShader::Value::data_ptr((RB::CustomShader::Value *)a2);
    return memcmp(v9, v10, *(_DWORD *)this* *((unsigned __int8 *)&RB::CustomShader::Value::bytes_per_element+ *((unsigned __int8 *)this + 4))) == 0;
  }
  else
  {
    if (*((void *)this + 1) != *(void *)(a2 + 8)) {
      return 0;
    }
    return *((_DWORD *)this + 4) == *(_DWORD *)(a2 + 16);
  }
}

void *RB::CustomShader::Value::encode(void *this, RB::Encoder *a2)
{
  uint64_t v3 = (uint64_t)this;
  unint64_t v4 = *(unsigned int *)this;
  if (v4 != 1)
  {
    RB::ProtobufEncoder::encode_varint(a2, 8uLL);
    this = RB::ProtobufEncoder::encode_varint(a2, v4);
  }
  unint64_t v5 = *(unsigned __int8 *)(v3 + 4);
  if (v5 == 1)
  {
    unsigned int v6 = 1u;
  }
  else
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x10uLL);
    this = RB::ProtobufEncoder::encode_varint(a2, v5);
    unsigned int v6 = *(unsigned __int8 *)(v3 + 4);
    if (v6 - 7 <= 1)
    {
      this = RB::Encoder::image_field(a2, 6, *(_DWORD *)(v3 + 16), *(uint64_t **)(v3 + 8));
      goto LABEL_13;
    }
  }
  if ((*(unsigned char *)(v3 + 7) & 4) != 0)
  {
    unint64_t v12 = *(_DWORD *)v3 * *((unsigned __int8 *)&RB::CustomShader::Value::bytes_per_element + v6);
    if (v12)
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
      uint64_t v9 = a2;
      uint64_t v10 = (const UInt8 *)(v3 + 8);
      unint64_t v11 = v12;
      goto LABEL_12;
    }
  }
  else
  {
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(v3 + 8));
    this = (void *)CFDataGetLength(*(CFDataRef *)(v3 + 8));
    if (this)
    {
      size_t v8 = this;
      RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
      uint64_t v9 = a2;
      uint64_t v10 = BytePtr;
      unint64_t v11 = (unint64_t)v8;
LABEL_12:
      this = RB::ProtobufEncoder::encode_data(v9, v10, v11);
    }
  }
LABEL_13:
  if (*(unsigned char *)(v3 + 4) == 5 && *(unsigned char *)(v3 + 6))
  {
    int v13 = rb_color_space(*(unsigned __int8 *)(v3 + 5) | 0x100u);
    RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
    this = RB::ProtobufEncoder::encode_varint(a2, v13);
  }
  if (*(unsigned char *)(v3 + 7))
  {
    if ((*(unsigned char *)(v3 + 7) & 2) != 0) {
      unint64_t v14 = 2;
    }
    else {
      unint64_t v14 = 1;
    }
    RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
    return RB::ProtobufEncoder::encode_varint(a2, v14);
  }
  return this;
}

void RB::CustomShader::Value::decode(RB::CustomShader::Value *this, RB::Decoder *a2)
{
  uint64_t v4 = 0;
  unint64_t v5 = 0;
  CFTypeRef v6 = 0;
  unsigned int v7 = 0;
  unint64_t v8 = 1;
  unint64_t v9 = 1;
  while (1)
  {
    unint64_t v10 = v9;
    unint64_t field = RB::ProtobufDecoder::next_field(a2);
    if (!field) {
      break;
    }
    switch((field >> 3))
    {
      case 1u:
        unint64_t v8 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, field);
        unint64_t v9 = v10;
        continue;
      case 2u:
        unint64_t v9 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, field);
        if (v9 > 9)
        {
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
          goto LABEL_18;
        }
        continue;
      case 3u:
        unint64_t v5 = (const UInt8 *)RB::ProtobufDecoder::data_field(a2, field);
        uint64_t v4 = v12;
        goto LABEL_18;
      case 4u:
        unsigned int v13 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, field);
        unsigned __int16 v14 = rb_color_space(v13);
        unsigned __int8 v15 = v14;
        unsigned int v16 = v14;
        unint64_t v9 = v10;
        if (v16 < 0x100) {
          continue;
        }
        *(_WORD *)((char *)this + 5) = v15 | 0x100;
LABEL_18:
        unint64_t v9 = v10;
        break;
      case 5u:
        uint64_t v17 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, field);
        *((unsigned char *)this + 7) = (v17 != 0) | (2 * (v17 == 2)) | *((unsigned char *)this + 7) & 0xFC;
        goto LABEL_18;
      case 6u:
        unsigned int v7 = RB::Decoder::image_field(a2, field);
        uint64_t v19 = v18;
        if (v6 != v18)
        {
          if (v6) {
            CFRelease(v6);
          }
          if (v19) {
            CFTypeRef v6 = CFRetain(v19);
          }
          else {
            CFTypeRef v6 = 0;
          }
        }
        goto LABEL_18;
      default:
        RB::ProtobufDecoder::skip_field(a2, field);
        unint64_t v9 = v10;
        continue;
    }
  }
  if ((v10 - 7) <= 1u)
  {
    v20[1] = v6;
    v20[0] = v7;
    RB::CustomShader::Value::set_bytes((uint64_t)this, v10, 1uLL, (const UInt8 *)v20);
    goto LABEL_24;
  }
  if (is_mul_ok(v8, *((unsigned __int8 *)&RB::CustomShader::Value::bytes_per_element + v10))
    && v4 == v8 * *((unsigned __int8 *)&RB::CustomShader::Value::bytes_per_element + v10))
  {
    RB::CustomShader::Value::set_bytes((uint64_t)this, v10, v8, v5);
LABEL_24:
    if (!v6) {
      return;
    }
    goto LABEL_25;
  }
  *((unsigned char *)a2 + 56) = 1;
  *(void *)a2 = *((void *)a2 + 1);
  if (!v6) {
    return;
  }
LABEL_25:
  CFRelease(v6);
}

void sub_214184378(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

atomic_uint *RB::Refcount<RB::CustomShader::Library,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

atomic_uint *RB::Refcount<RB::CustomShader::Function,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::CustomShader::Library::Library(RB::CustomShader::Library::Type,objc_object *)::$_1::__invoke(void *a1, const char *a2)
{
  return [a1 isEqualToString:a2];
}

uint64_t RB::CustomShader::Library::Library(RB::CustomShader::Library::Type,objc_object *)::$_2::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t RB::CustomShader::Library::finalize(void)::$_0::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void RB::CustomShader::Library::call_error_handler(NSError *)const::$_0::__invoke(uint64_t a1)
{
  int v2 = (uint64_t *)(a1 + 8);
  uint64_t v3 = *(uint64_t **)(a1 + 72);
  if (v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = v2;
  }
  uint64_t v5 = *(unsigned int *)(a1 + 80);
  if (v5)
  {
    uint64_t v6 = 8 * v5;
    do
    {
      uint64_t v7 = *v4++;
      (*(void (**)(void))(v7 + 16))();
      v6 -= 8;
    }
    while (v6);
    uint64_t v3 = *(uint64_t **)(a1 + 72);
    if (v3) {
      int v2 = *(uint64_t **)(a1 + 72);
    }
    if (*(_DWORD *)(a1 + 80))
    {
      unint64_t v8 = 0;
      do

      while (v8 < *(unsigned int *)(a1 + 80));
      uint64_t v3 = *(uint64_t **)(a1 + 72);
    }
  }
  if (v3) {
    free(v3);
  }

  JUMPOUT(0x21669AC10);
}

void *RB::vector<RB::objc_ptr<void({block_pointer})(NSError *)>,8ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 19) + (*((_DWORD *)__dst + 19) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 19) + (*((_DWORD *)__dst + 19) >> 1);
  }
  unint64_t result = RB::details::realloc_vector<unsigned int,8ul>(*((void **)__dst + 8), __dst, 8u, (_DWORD *)__dst + 19, v3);
  *((void *)__dst + 8) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,8ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  uint64_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 8 * a5);
      free(v7);
      uint64_t v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(8 * a5);
    size_t v9 = v8 >> 3;
    if (*a4 != (v8 >> 3))
    {
      unint64_t v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      uint64_t v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 8 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

void *RB::vector<RB::CustomShader::Closure::marshal_args(RB::RenderPass &,RB::Function &,RB::Rect const*,unsigned char *,RB::BufferRegion &,RB::Texture *&)::PendingArg,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  unint64_t result = RB::details::realloc_vector<unsigned long,48ul>(*(void **)a1, (unint64_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,48ul>(void *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(48 * a3);
    unint64_t v6 = v5 / 0x30;
    if (v5 / 0x30 != *a2)
    {
      uint64_t v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      uint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void RB::ImageProvider::submit_all(RB::ImageProvider *this)
{
  os_unfair_lock_lock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
  uint64_t v1 = RB::ImageProvider::_pending_image_providers;
  if (RB::ImageProvider::_pending_image_providers)
  {
    int v2 = *(void **)RB::ImageProvider::_pending_image_providers;
    unint64_t v3 = *(void *)(RB::ImageProvider::_pending_image_providers + 8);
    uint64_t v7 = *(void **)RB::ImageProvider::_pending_image_providers;
    *(void *)RB::ImageProvider::_pending_image_providers = 0;
    unint64_t v8 = v3;
    *(void *)(v1 + 8) = 0;
    *(void *)(v1 + 16) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        RB::ImageProvider::wait_phase(v2[i], 2);
      unint64_t v5 = 0;
      do
      {
        unint64_t v6 = (atomic_uint *)v2[v5];
        if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
        {
          __dmb(9u);
          (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
        }
        ++v5;
      }
      while (v5 < v8);
      int v2 = v7;
    }
    if (v2)
    {
      free(v2);
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
  }
}

void sub_2141848B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  RB::vector<RB::refcounted_ptr<RB::ImageProvider>,0ul,unsigned long>::~vector((uint64_t)va);
  _Unwind_Resume(a1);
}

void RB::ImageProvider::wait_phase(uint64_t a1, int a2)
{
  v4.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 104);
  v4.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 104));
  RB::ImageProvider::start_rendering_locked((RB::ImageProvider *)a1);
  if (*(_DWORD *)(a1 + 216) >= a2) {
    goto LABEL_4;
  }
  do
    std::condition_variable::wait((std::condition_variable *)(a1 + 168), &v4);
  while (*(_DWORD *)(a1 + 216) < a2);
  if (v4.__owns_) {
LABEL_4:
  }
    std::mutex::unlock(v4.__m_);
}

void sub_214184958(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::vector<RB::refcounted_ptr<RB::ImageProvider>,0ul,unsigned long>::~vector(uint64_t a1)
{
  int v2 = *(void **)a1;
  if (*(void *)(a1 + 8))
  {
    unint64_t v3 = 0;
    do
    {
      std::unique_lock<std::mutex> v4 = (atomic_uint *)v2[v3];
      if (v4 && atomic_fetch_add_explicit(v4 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v4 + 8))(v4);
      }
      ++v3;
    }
    while (v3 < *(void *)(a1 + 8));
    int v2 = *(void **)a1;
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

uint64_t RB::ImageProvider::ImageProvider(uint64_t a1, id a2, void *a3, uint64_t a4, char a5, char a6, unsigned __int8 a7, int a8, double a9, float a10, float a11, float a12, float a13, float a14)
{
  *(_DWORD *)(a1 + 8) = 1;
  *(void *)a1 = &unk_26C4ED100;
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = a3;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(double *)(a1 + 56) = a9;
  *(float *)(a1 + 64) = a10;
  *(float *)(a1 + 68) = a11;
  *(float *)(a1 + 72) = a12;
  *(float *)(a1 + 76) = a13;
  *(float *)(a1 + 80) = a14;
  *(void *)(a1 + 88) = a4;
  *(unsigned char *)(a1 + 96) = a5;
  *(unsigned char *)(a1 + 97) = a6;
  if (a8) {
    __int16 v27 = 256;
  }
  else {
    __int16 v27 = 0;
  }
  __int16 v28 = v27 & 0xFF00 | a7 | *(_WORD *)(a1 + 98) & 0xFC00;
  *(_WORD *)(a1 + 98) = v28;
  *(void *)(a1 + 104) = 850045863;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 1018212795;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 204) = 0u;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 224) = 0;
  if (a4 <= 80)
  {
    switch(a4)
    {
      case 'F':
        goto LABEL_12;
      case 'G':
LABEL_15:
        uint64_t v30 = 71;
LABEL_16:
        *(void *)(a1 + 88) = v30;
        int v31 = 4;
        if (a2) {
          return a1;
        }
        goto LABEL_20;
      case 'P':
LABEL_12:
        uint64_t v30 = 70;
        goto LABEL_16;
    }
LABEL_18:
    *(void *)(a1 + 88) = 115;
    goto LABEL_19;
  }
  char v29 = a4 - 7;
  if ((unint64_t)(a4 - 2147483655) > 5)
  {
    if (a4 == 81) {
      goto LABEL_15;
    }
    goto LABEL_18;
  }
  if (((1 << v29) & 5) != 0)
  {
    uint64_t v30 = 2147483657;
    goto LABEL_16;
  }
  if (((1 << v29) & 0xA) != 0)
  {
    uint64_t v30 = 2147483658;
    goto LABEL_16;
  }
LABEL_19:
  *(_WORD *)(a1 + 98) = v28 | 0x200;
  int v31 = 8;
  if (a2) {
    return a1;
  }
LABEL_20:
  uint64_t v32 = v31 * (uint64_t)SLODWORD(a9);
  uint64_t v33 = v32 << 31 >> 31;
  *(_DWORD *)(a1 + 244) = v32;
  if (v33 != v32 || v33 < 0) {
    goto LABEL_31;
  }
  unsigned int v34 = HIDWORD(a9);
  unsigned int v35 = (v32 & 0xFFFFFFC0) + 64;
  BOOL v36 = a9 < 0.0;
  if (a9 < 0.0) {
    unsigned int v34 = -HIDWORD(a9);
  }
  unint64_t v37 = v34 * (unint64_t)v35;
  int v38 = a9 >= 0.0 ? v37 : -(int)v37;
  if (!v37) {
    BOOL v36 = 0;
  }
  *(_DWORD *)(a1 + 240) = v38;
  *(_DWORD *)(a1 + 244) = v35;
  if ((v37 & 0xFFFFFFFF00000000) != 0 || v36) {
LABEL_31:
  }
    *(void *)(a1 + 240) = 0;
  return a1;
}

void sub_214184C68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void RB::ImageProvider::~ImageProvider(RB::ImageProvider *this)
{
  *(void *)this = &unk_26C4ED100;
  if (*((void *)this + 28))
  {
    int v2 = (os_unfair_lock_s *)RB::SurfacePool::shared(this);
    RB::SurfacePool::dealloc(v2, *((RB::Surface **)this + 28), 0);
  }
  unint64_t v3 = (void *)*((void *)this + 29);
  if (v3) {
    munmap(v3, *((unsigned int *)this + 60));
  }
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 168));
  std::mutex::~mutex((std::mutex *)((char *)this + 104));
  std::unique_lock<std::mutex> v4 = (const void *)*((void *)this + 6);
  if (v4) {
    CFRelease(v4);
  }
}

{
  uint64_t vars8;

  RB::ImageProvider::~ImageProvider(this);
  JUMPOUT(0x21669AC10);
}

void sub_214184D24(_Unwind_Exception *a1)
{
  std::condition_variable::~condition_variable((std::condition_variable *)(v1 + 168));
  std::mutex::~mutex((std::mutex *)(v1 + 104));
  unint64_t v3 = *(const void **)(v1 + 48);
  if (v3) {
    CFRelease(v3);
  }

  _Unwind_Resume(a1);
}

void RB::ImageProvider::make_cgimage(RB::ImageProvider *this@<X0>, void *a2@<X8>)
{
  std::unique_lock<std::mutex> v4 = (const void *)*((void *)this + 6);
  if (v4)
  {
    *a2 = CFRetain(v4);
  }
  else if (*((void *)this + 2))
  {
    *(_OWORD *)&callbacks.version = xmmword_26C4EEFA8;
    *(_OWORD *)&callbacks.releaseBytePointer = *(_OWORD *)&off_26C4EEFB8;
    unint64_t v5 = objc_opt_new();
    unint64_t v6 = v5;
    uint64_t v7 = (void *)MEMORY[0x263F00378];
    if ((*((_WORD *)this + 49) & 0x100) != 0) {
      uint64_t v7 = (void *)MEMORY[0x263F00370];
    }
    [v5 setObject:MEMORY[0x263EFFA88] forKeyedSubscript:*v7];
    unint64_t v8 = (RB *)*((unsigned __int8 *)this + 96);
    unint64_t v10 = RB::pixel_format_traits(*((void *)this + 11), v9);
    RB::cg_color_space(v8, ((*v10 | ((unint64_t)*((unsigned __int16 *)v10 + 2) << 32)) & 0xA00000000) != 0);
    atomic_fetch_add_explicit((atomic_uint *volatile)this + 2, 1u, memory_order_relaxed);
    unint64_t v11 = (const void *)CGImageProviderCreate();
    if (v11)
    {
      *a2 = CGImageCreateWithImageProvider();
      CFRelease(v11);
    }
    else
    {
      ((void (*)(RB::ImageProvider *))callbacks.getBytesAtPosition)(this);
      *a2 = 0;
    }
  }
  else
  {
    CGDataProviderDirectCallbacks callbacks = *(CGDataProviderDirectCallbacks *)byte_26C4EEFC8;
    atomic_fetch_add_explicit((atomic_uint *volatile)this + 2, 1u, memory_order_relaxed);
    CGDataProviderRef v12 = CGDataProviderCreateDirect(this, *((unsigned int *)this + 60), &callbacks);
    if (v12)
    {
      unsigned __int16 v14 = v12;
      __int16 v15 = *((_WORD *)this + 49);
      uint64_t v24 = *((void *)this + 7);
      size_t v16 = *((unsigned int *)this + 61);
      uint64_t v17 = (RB *)*((unsigned __int8 *)this + 96);
      CFTypeRef v18 = RB::pixel_format_traits(*((void *)this + 11), v13);
      uint64_t v19 = RB::cg_color_space(v17, ((*v18 | ((unint64_t)*((unsigned __int16 *)v18 + 2) << 32)) & 0xA00000000) != 0);
      if ((v15 & 0x200) != 0) {
        size_t v20 = 16;
      }
      else {
        size_t v20 = 8;
      }
      if ((*((_WORD *)this + 49) & 0x100) != 0) {
        int v21 = 4357;
      }
      else {
        int v21 = 4353;
      }
      if ((*((_WORD *)this + 49) & 0x100) != 0) {
        int v22 = 6;
      }
      else {
        int v22 = 2;
      }
      if ((*((_WORD *)this + 49) & 0x200) != 0) {
        CGBitmapInfo v23 = v21;
      }
      else {
        CGBitmapInfo v23 = v22;
      }
      *a2 = CGImageCreate((int)v24, SHIDWORD(v24), v20, 4 * v20, v16, v19, v23, v14, 0, 1, kCGRenderingIntentDefault);
      CFRelease(v14);
    }
    else
    {
      ((void (*)(atomic_uint *))callbacks.releaseInfo)((atomic_uint *)this);
      *a2 = 0;
    }
  }
}

void sub_21418500C(_Unwind_Exception *exception_object)
{
}

uint64_t RB::ImageProvider::make_cgimage(void)::$_0::__invoke(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  return RB::ImageProvider::copy_image_block_set(a1, a2, (uint64_t)a3, a4, a3);
}

atomic_uint *RB::ImageProvider::make_cgimage(void)::$_2::__invoke(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::ImageProvider::make_cgimage(void)::$_3::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 232);
}

atomic_uint *RB::ImageProvider::make_cgimage(void)::$_4::__invoke(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void RB::ImageProvider::start_rendering(RB::ImageProvider *this)
{
  int v2 = (std::mutex *)((char *)this + 104);
  std::mutex::lock((std::mutex *)((char *)this + 104));
  RB::ImageProvider::start_rendering_locked(this);
  std::mutex::unlock(v2);
}

void sub_214185150(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void RB::ImageProvider::start_rendering_locked(RB::ImageProvider *this)
{
  if (*((int *)this + 54) > 0) {
    return;
  }
  *((_DWORD *)this + 54) = 1;
  std::condition_variable::notify_all((std::condition_variable *)((char *)this + 168));
  if (!*((unsigned char *)this + 98)
    || (vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vceqq_f32(*(float32x4_t *)((char *)this + 68), (float32x4_t)RBColorClear)), 0xFuLL))) & 1) != 0)
  {
    int v2 = objc_msgSend(*((id *)this + 3), "_rb_contents");
    if (v2)
    {
      unint64_t v3 = (CFTypeRef *)((char *)this + 48);
      RB::DisplayList::Contents::get_cgimage(v2, (const void **)this + 6, *((double *)this + 7));
      std::unique_lock<std::mutex> v4 = (CGImage *)*((void *)this + 6);
      if (v4)
      {
        if (CGImageGetWidth(v4) == (int)*((void *)this + 7)
          && CGImageGetHeight(*((CGImageRef *)this + 6)) == *((_DWORD *)this + 15))
        {
          RB::ImageProvider::set_phase((uint64_t)this, 3);
          return;
        }
        if (*v3) {
          CFRelease(*v3);
        }
        *unint64_t v3 = 0;
      }
    }
  }
  RB::ImageProvider::add_to_pending((atomic_uint *)this);
  unint64_t v5 = (void *)*((void *)this + 2);
  if (v5)
  {
    unint64_t v6 = [v5 queue];
  }
  else
  {
    {
      uint64_t v7 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
    }
  }
  atomic_fetch_add_explicit((atomic_uint *volatile)this + 2, 1u, memory_order_relaxed);
  dispatch_async_f(v6, this, (dispatch_function_t)RB::ImageProvider::start_rendering_locked(void)::$_0::__invoke);
}

BOOL RB::ImageProvider::set_phase(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 216);
  if (v3 < a2)
  {
    *(_DWORD *)(a1 + 216) = a2;
    std::condition_variable::notify_all((std::condition_variable *)(a1 + 168));
    if (a2 == 3)
    {
      if (*(void *)(a1 + 32))
      {
        unint64_t v5 = *(NSObject **)(a1 + 40);
        if (v5)
        {
          atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 8), 1u, memory_order_relaxed);
          block[0] = MEMORY[0x263EF8330];
          block[1] = 3321888768;
          block[2] = ___ZN2RB13ImageProvider9set_phaseENS0_5PhaseE_block_invoke;
          block[3] = &__block_descriptor_40_e8_32c46_ZTSN2RB14refcounted_ptrINS_13ImageProviderEEE_e5_v8__0l;
          atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 8), 1u, memory_order_relaxed);
          uint64_t v9 = a1;
          dispatch_async(v5, block);
          uint64_t v6 = v9;
          if (v9 && atomic_fetch_add_explicit((atomic_uint *volatile)(v9 + 8), 0xFFFFFFFF, memory_order_release) == 1)
          {
            __dmb(9u);
            (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
          }
          if (atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 8), 0xFFFFFFFF, memory_order_release) == 1)
          {
            __dmb(9u);
            (*(void (**)(uint64_t))(*(void *)a1 + 8))(a1);
          }
        }
      }
    }
  }
  return v3 < a2;
}

void RB::ImageProvider::add_to_pending(atomic_uint *this)
{
  if (*((void *)this + 2))
  {
    os_unfair_lock_lock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
    int v2 = (void *)RB::ImageProvider::_pending_image_providers;
    if (!RB::ImageProvider::_pending_image_providers) {
      operator new();
    }
    atomic_fetch_add_explicit(this + 2, 1u, memory_order_relaxed);
    uint64_t v3 = v2[1];
    unint64_t v4 = v3 + 1;
    if (v2[2] < (unint64_t)(v3 + 1))
    {
      RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)v2, v4);
      uint64_t v3 = v2[1];
      unint64_t v4 = v3 + 1;
    }
    *(void *)(*v2 + 8 * v3) = this;
    v2[1] = v4;
    os_unfair_lock_unlock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
  }
}

void sub_21418552C(_Unwind_Exception *a1)
{
  if (atomic_fetch_add_explicit((atomic_uint *volatile)(v1 + 8), 0xFFFFFFFF, memory_order_release) == 1) {
    RB::ImageProvider::add_to_pending(v1);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
  _Unwind_Resume(a1);
}

void RB::ImageProvider::render_device(RB::ImageProvider *this)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  if (*((void *)this + 28))
  {
    int v2 = (RB::Device *)-[RBDecodedFontMetadata fontUID](*((void *)this + 2));
    RB::RenderFrame::RenderFrame((RB::RenderFrame *)v23, v2, 0, 1u);
    uint64_t v3 = (RB *)*((void *)this + 11);
    double v4 = *((double *)this + 7);
    float v5 = *((float *)this + 16);
    char v6 = *((unsigned char *)this + 96);
    char v7 = *((unsigned char *)this + 97);
    char v9 = RB::pixel_format_required_depth(v3, v8);
    unint64_t v11 = RB::pixel_format_traits(*((void *)this + 11), v10);
    RB::RenderParams::RenderParams((uint64_t)&v20, (uint64_t)v23, (uint64_t)v3, v6, v7, v9, (v11[1] & 2) != 0, v4, v5);
    v22 |= 4u;
    v19[0] = MEMORY[0x263EF8330];
    v19[1] = 3221225472;
    float32x2_t v19[2] = ___ZN2RB13ImageProvider13render_deviceEv_block_invoke;
    v19[3] = &__block_descriptor_40_e19____MTLTexture__8__0l;
    v19[4] = this;
    CGDataProviderRef v12 = (const RB::DisplayList::Contents *)objc_msgSend(*((id *)this + 3), "_rb_contents");
    if (v12)
    {
      v13.i64[0] = *(void *)((char *)this + 68);
      v13.i32[2] = *((_DWORD *)this + 19);
      v13.i32[3] = 1.0;
      RB::DisplayList::render(v12, &v20, (uint64_t)v19, *((char *)this + 98), 0, 0, v21, (__n128)vmulq_n_f32(v13, *((float *)this + 20)));
      if ((*(unsigned char *)(v23[0] + 292) & 2) != 0)
      {
        id v14 = (id)*((void *)this + 3);
        if (v24 != v14)
        {

          id v24 = v14;
        }
      }
    }
    atomic_fetch_add_explicit((atomic_uint *volatile)this + 2, 1u, memory_order_relaxed);
    v17[0] = MEMORY[0x263EF8330];
    v17[1] = 3321888768;
    v17[2] = ___ZN2RB13ImageProvider13render_deviceEv_block_invoke_2;
    v17[3] = &__block_descriptor_40_e8_32c46_ZTSN2RB14refcounted_ptrINS_13ImageProviderEEE_e5_v8__0l;
    atomic_fetch_add_explicit((atomic_uint *volatile)this + 2, 1u, memory_order_relaxed);
    CFTypeRef v18 = this;
    RB::RenderFrame::add_continuation((uint64_t)v23, 0, v17);
    __int16 v15 = v18;
    if (v18 && atomic_fetch_add_explicit((atomic_uint *volatile)v18 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(RB::ImageProvider *))(*(void *)v15 + 8))(v15);
    }
    if (atomic_fetch_add_explicit((atomic_uint *volatile)this + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(RB::ImageProvider *))(*(void *)this + 8))(this);
    }
    RB::RenderFrame::~RenderFrame((RB::RenderFrame *)v23);
  }
  RBXMLRecorderMarkFrame(*((const void **)this + 2), *((void **)this + 3), *((unsigned __int8 *)this + 96), (double)(int)*((void *)this + 7), (double)(int)HIDWORD(*((void *)this + 7)));
  std::mutex::lock((std::mutex *)((char *)this + 104));
  if (*((void *)this + 28)) {
    int v16 = 2;
  }
  else {
    int v16 = 3;
  }
  RB::ImageProvider::set_phase((uint64_t)this, v16);
  std::mutex::unlock((std::mutex *)((char *)this + 104));
  RB::ImageProvider::remove_from_pending(this);
}

void sub_214185864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  RB::RenderFrame::~RenderFrame((RB::RenderFrame *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN2RB13ImageProvider13render_deviceEv_block_invoke(uint64_t a1, MTLPixelFormat a2)
{
  return RB::Surface::texture(*(RB::Surface **)(*(void *)(a1 + 32) + 224), a2);
}

void ___ZN2RB13ImageProvider13render_deviceEv_block_invoke_2(uint64_t a1)
{
  int v2 = (std::mutex *)(*(void *)(a1 + 32) + 104);
  std::mutex::lock(v2);
  RB::ImageProvider::set_phase(*(void *)(a1 + 32), 3);
  std::mutex::unlock(v2);
}

void sub_21418594C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c46_ZTSN2RB14refcounted_ptrINS_13ImageProviderEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  *(void *)(result + 32) = v2;
  return result;
}

atomic_uint *__destroy_helper_block_e8_32c46_ZTSN2RB14refcounted_ptrINS_13ImageProviderEEE(uint64_t a1)
{
  unint64_t result = *(atomic_uint **)(a1 + 32);
  if (result)
  {
    if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
    }
  }
  return result;
}

void RB::ImageProvider::remove_from_pending(RB::ImageProvider *this)
{
  if (*((void *)this + 2))
  {
    os_unfair_lock_lock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
    if (RB::ImageProvider::_pending_image_providers
      && (uint64_t v2 = *(void *)(RB::ImageProvider::_pending_image_providers + 8)) != 0)
    {
      uint64_t v3 = *(void *)(RB::ImageProvider::_pending_image_providers + 8);
      double v4 = *(RB::ImageProvider ***)RB::ImageProvider::_pending_image_providers;
      while (*v4 != this)
      {
        ++v4;
        if (!--v3) {
          goto LABEL_7;
        }
      }
      uint64_t v5 = *(void *)RB::ImageProvider::_pending_image_providers + 8 * v2;
      CGImage *v4 = *(RB::ImageProvider **)(v5 - 8);
      *(void *)(v5 - 8) = this;
      uint64_t v6 = *(void *)RB::ImageProvider::_pending_image_providers
         + 8 * *(void *)(RB::ImageProvider::_pending_image_providers + 8);
      char v7 = *(atomic_uint **)(v6 - 8);
      *(void *)(v6 - 8) = 0;
      uint64_t v8 = *(void *)RB::ImageProvider::_pending_image_providers;
      uint64_t v9 = *(void *)(RB::ImageProvider::_pending_image_providers + 8) - 1;
      *(void *)(RB::ImageProvider::_pending_image_providers + 8) = v9;
      MTLPixelFormat v10 = *(atomic_uint **)(v8 + 8 * v9);
      if (v10 && atomic_fetch_add_explicit(v10 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v10 + 8))(v10);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
      if (v7 && atomic_fetch_add_explicit(v7 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        unint64_t v11 = *(void (**)(atomic_uint *))(*(void *)v7 + 8);
        v11(v7);
      }
    }
    else
    {
LABEL_7:
      os_unfair_lock_unlock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
    }
  }
}

void RB::ImageProvider::render_bitmap(RB::ImageProvider *this)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  uint64_t v2 = mmap(0, *((unsigned int *)this + 60), 3, 4098, -1, 0);
  if (v2 != (void *)-1)
  {
    double v4 = v2;
    *((void *)this + 29) = v2;
    uint64_t v5 = *((void *)this + 7);
    size_t v6 = (int)v5;
    size_t v7 = (*((_WORD *)this + 49) & 0x200) != 0 ? 16 : 8;
    size_t v8 = SHIDWORD(v5);
    size_t v9 = *((unsigned int *)this + 61);
    MTLPixelFormat v10 = (RB *)*((unsigned __int8 *)this + 96);
    unint64_t v11 = RB::pixel_format_traits(*((void *)this + 11), v3);
    CGDataProviderRef v12 = RB::cg_color_space(v10, ((*v11 | ((unint64_t)*((unsigned __int16 *)v11 + 2) << 32)) & 0xA00000000) != 0);
    int v13 = (*((_WORD *)this + 49) & 0x100) != 0 ? 4357 : 4353;
    int v14 = (*((_WORD *)this + 49) & 0x100) != 0 ? 6 : 2;
    uint32_t v15 = (*((_WORD *)this + 49) & 0x200) != 0 ? v13 : v14;
    int v16 = CGBitmapContextCreate(v4, v6, v8, v7, v9, v12, v15);
    if (v16)
    {
      uint64_t v17 = v16;
      CGFloat v18 = (double)*((int *)this + 15);
      transform.b = 0.0;
      transform.c = 0.0;
      transform.a = 1.0;
      *(_OWORD *)&transform.d = xmmword_214219A10;
      transform.ty = v18;
      CGContextConcatCTM(v16, &transform);
      uint64_t v19 = (const float *)((char *)this + 64);
      *(float32x2_t *)&double v20 = vld1_dup_f32(v19);
      RB::CGContext::CGContext(c, v17, *((unsigned __int8 *)this + 96), v20);
      if (*((unsigned char *)this + 98) == 2)
      {
        _S3 = *((_DWORD *)this + 17);
        _S2 = *((_DWORD *)this + 18);
        _S1 = *((_DWORD *)this + 19);
        _D0.i32[0] = *((_DWORD *)this + 20);
        int v25 = *((unsigned __int8 *)this + 97);
        __asm
        {
          FCVT            H0, S0
          FCVT            H1, S1
          FCVT            H2, S2
          FCVT            H3, S3
        }
        *(short float *)unsigned int v35 = _H3;
        *(short float *)&v35[1] = _H2;
        *(short float *)&v35[2] = _H1;
        v35[3] = _D0.i16[0];
        v35[4] = v25 | 0x100;
        if (v43 && v42 != v25 || v38 != _H3 || v39 != _H2 || v40 != _H1 || v41 != *(short float *)_D0.i16) {
          RB::CGContext::set_fill_color_slow((RB::CGContext *)c, (const RB::Fill::Color *)v35, _D0);
        }
        CGContextFillRect(c[0], *MEMORY[0x263F00190]);
      }
      uint64_t v33 = (RB::DisplayList *)objc_msgSend(*((id *)this + 3), "_rb_contents");
      if (v33) {
        RB::DisplayList::render(v33, (const RB::DisplayList::Contents *)c, 0, v34);
      }
      mprotect(v4, *((unsigned int *)this + 60), 1);
      RB::CGContext::~CGContext((RB::CGContext *)c);
      CFRelease(v17);
    }
  }
  std::mutex::lock((std::mutex *)((char *)this + 104));
  RB::ImageProvider::set_phase((uint64_t)this, 3);
  std::mutex::unlock((std::mutex *)((char *)this + 104));
  RB::ImageProvider::remove_from_pending(this);
}

void sub_214185DB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  RB::CGContext::~CGContext((RB::CGContext *)va);
  CFRelease(v9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN2RB13ImageProvider9set_phaseENS0_5PhaseE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 32) + 16))();
}

uint64_t RB::ImageProvider::copy_image_block_set(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  kern_return_t v21;
  uint64_t result;
  void *BaseAddress;
  uint64_t v24;
  void (*v25)(uint64_t, void);
  long long v26;
  long long v27;
  long long v28;
  long long v29;
  unsigned char v30[128];
  uint64_t v31;

  int v31 = *MEMORY[0x263EF8340];
  if (a5)
  {
    __int16 v28 = 0u;
    char v29 = 0u;
    unint64_t v26 = 0u;
    __int16 v27 = 0u;
    uint64_t v8 = [a5 countByEnumeratingWithState:&v26 objects:v30 count:16];
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)v27;
      uint64_t v11 = *MEMORY[0x263F00348];
      uint64_t v12 = *MEMORY[0x263F00360];
      int v13 = (const void *)*MEMORY[0x263F00338];
      id v24 = a2;
LABEL_4:
      uint64_t v14 = 0;
      while (1)
      {
        if (*(void *)v27 != v10) {
          objc_enumerationMutation(a5);
        }
        uint32_t v15 = *(void **)(*((void *)&v26 + 1) + 8 * v14);
        if (objc_msgSend(v15, "isEqualToString:", v11, v24)) {
          return 0;
        }
        if ([v15 isEqualToString:v12]) {
          return 0;
        }
        if ([v15 isEqualToString:v12]) {
          return 0;
        }
        if ([v15 isEqualToString:v13])
        {
          CFDictionaryGetValue((CFDictionaryRef)a5, v13);
          int v16 = (RB *)*(unsigned __int8 *)(a1 + 96);
          CGFloat v18 = RB::pixel_format_traits(*(void *)(a1 + 88), v17);
          RB::cg_color_space(v16, ((*v18 | ((unint64_t)*((unsigned __int16 *)v18 + 2) << 32)) & 0xA00000000) != 0);
          if (!CGColorSpaceEqualToColorSpace()) {
            return 0;
          }
        }
        if (v9 == ++v14)
        {
          uint64_t v9 = [a5 countByEnumeratingWithState:&v26 objects:v30 count:16];
          if (v9) {
            goto LABEL_4;
          }
          break;
        }
      }
    }
  }
  int v25 = (void (*)(uint64_t, void))*((void *)&xmmword_26C4EEFF0 + 1);
  RB::ImageProvider::wait_phase(a1, 3);
  uint64_t v19 = *(void *)(a1 + 224);
  if (v19)
  {
    double v20 = *(__IOSurface **)(v19 + 48);
    int32x2_t v21 = IOSurfaceLock(v20, 1u, 0);
    unint64_t result = 0;
    if (v21) {
      return result;
    }
    BaseAddress = IOSurfaceGetBaseAddress(v20);
    IOSurfaceGetBytesPerRow(v20);
    if (!BaseAddress) {
      return 0;
    }
  }
  else if (!*(void *)(a1 + 232))
  {
    return 0;
  }
  atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 8), 1u, memory_order_relaxed);
  if (CGImageBlockCreate())
  {
    unint64_t result = CGImageBlockSetCreate();
    if (result) {
      return result;
    }
    CGImageBlockRelease();
  }
  else
  {
    v25(a1, 0);
  }
  return 0;
}

uint64_t RB::ImageProvider::copy_image_block_set(CGImageProvider *,CGRect const&,CGSize const&,__CFDictionary const*)::$_0::__invoke(uint64_t result)
{
  uint64_t v1 = (atomic_uint *)result;
  uint64_t v2 = *(void *)(result + 224);
  if (v2) {
    unint64_t result = IOSurfaceUnlock(*(IOSurfaceRef *)(v2 + 48), 1u, 0);
  }
  if (atomic_fetch_add_explicit(v1 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    MTLPixelFormat v3 = *(uint64_t (**)(atomic_uint *))(*(void *)v1 + 8);
    return v3(v1);
  }
  return result;
}

uint64_t RB::ImageProvider::copy_iosurface(RB::ImageProvider *this, const __CFDictionary *a2)
{
  RB::ImageProvider::wait_phase((uint64_t)this, 2);
  uint64_t v3 = *((void *)this + 28);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(v3 + 48);
  if (v4) {
    CFRetain(*(CFTypeRef *)(v3 + 48));
  }
  return v4;
}

atomic_uint *RB::Refcount<RB::ImageProvider,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::Refcount<RB::ImageProvider,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void RB::ImageProvider::start_rendering_locked(void)::$_0::__invoke(RB::ImageProvider *this)
{
  if (*((void *)this + 2))
  {
    uint64_t v2 = (os_unfair_lock_s *)RB::SurfacePool::shared(this);
    uint64_t v3 = -[RBDecodedFontMetadata fontUID](*((void *)this + 2));
    *((void *)this + 28) = RB::SurfacePool::alloc(v2, v3, *((void *)this + 11), *((unsigned __int8 *)this + 96), 2, 0, *(int32x2_t *)((char *)this + 56), 0);
    RB::ImageProvider::render_device(this);
  }
  else
  {
    RB::ImageProvider::render_bitmap(this);
  }
  if (atomic_fetch_add_explicit((atomic_uint *volatile)this + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    uint64_t v4 = *(void (**)(RB::ImageProvider *))(*(void *)this + 8);
    v4(this);
  }
}

void sub_2141862EC(_Unwind_Exception *exception_object)
{
  if (atomic_fetch_add_explicit((atomic_uint *volatile)(v1 + 8), 0xFFFFFFFF, memory_order_release) == 1) {
    RB::ImageProvider::add_to_pending(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::Path::FlattenedConsumer::push_back(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, 1);
}

uint64_t RB::Path::FlattenedConsumer::push_back(uint64_t a1, __n128 a2, float32x2_t a3, float32x2_t a4)
{
  float32x2_t v5 = vadd_f32(a3, a3);
  float32x2_t v6 = (float32x2_t)vdup_n_s32(0x3EAAAAABu);
  return (*(uint64_t (**)(__n128, double, double))(*(void *)a1 + 40))(a2, COERCE_DOUBLE(vmul_f32(vadd_f32(v5, (float32x2_t)a2.n128_u64[0]), v6)), COERCE_DOUBLE(vmul_f32(vadd_f32(v5, a4), v6)));
}

uint64_t RB::Path::Flattener::Flattener(uint64_t a1, void (***a2)(void), float a3, float32x2_t a4, float32x2_t a5)
{
  int32x2_t v6 = vdup_n_s32(0x7F800000u);
  *(float32x2_t *)(a1 + 32) = vadd_f32(a5, a4);
  *(int32x2_t *)(a1 + 40) = v6;
  *(void *)(a1 + 48) = 0x7F0000007FLL;
  *(int32x2_t *)(a1 + 56) = v6;
  *(void *)(a1 + 64) = 0x7F0000007FLL;
  float32x2_t v8 = vrecpe_f32((float32x2_t)LODWORD(a3));
  float32x2_t v9 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(a3), v8), v8);
  *(void *)a1 = &unk_26C4EDAA0;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 88) = 0;
  *(float32x2_t *)(a1 + 16) = vmul_n_f32((float32x2_t)0x3F0000003F400000, vmul_f32(v9, vrecps_f32((float32x2_t)LODWORD(a3), v9)).f32[0]);
  *(double *)(a1 + 24) = *(double *)&a4;
  (**a2)(a2);
  return a1;
}

uint64_t RB::Path::Flattener::push_cropped(uint64_t a1, double a2, float32x2_t a3)
{
  if (*(unsigned char *)(a1 + 88))
  {
    uint32x2_t v6 = (uint32x2_t)vorr_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(a1 + 24), vmaxnm_f32(*(float32x2_t *)(a1 + 96), a3)), (int8x8_t)vcgt_f32(vminnm_f32(*(float32x2_t *)(a1 + 96), a3), *(float32x2_t *)(a1 + 32)));
    if ((vpmax_u32(v6, v6).u32[0] & 0x80000000) != 0)
    {
      if ((*(unsigned int (**)(void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8))) {
        a2 = *(double *)(a1 + 96);
      }
    }
  }
  uint64_t result = (*(uint64_t (**)(void, double, double))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), a2, *(double *)&a3);
  *(unsigned char *)(a1 + 88) = 1;
  *(double *)(a1 + 96) = a2;
  return result;
}

uint64_t RB::Path::Flattener::closepath(float32x2_t *this)
{
  float32x2_t v2 = this[9];
  uint32x2_t v3 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v2, this[10]));
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) != 0) {
    RB::Path::Flattener::lineto((uint64_t)this, vcvtq_f64_f32(v2));
  }
  float32x2_t v4 = this[7];
  float32x2_t v5 = this[8];
  uint32x2_t v6 = (uint32x2_t)vorr_s8((int8x8_t)vcgt_f32(this[3], v5), (int8x8_t)vcgt_f32(v4, this[4]));
  if ((vpmax_u32(v6, v6).u32[0] & 0x80000000) != 0)
  {
    if ((*(uint64_t (**)(void))(**(void **)&this[1] + 8))(*(void *)&this[1])) {
      goto LABEL_7;
    }
    float32x2_t v4 = this[7];
    float32x2_t v5 = this[8];
  }
  float32x2_t v7 = this[6];
  this[5] = vminnm_f32(this[5], v4);
  this[6] = vmaxnm_f32(v7, v5);
LABEL_7:
  this[7] = (float32x2_t)vdup_n_s32(0x7F800000u);
  this[8] = (float32x2_t)0x7F0000007FLL;
  this[11].i8[0] = 0;
  float32x2_t v8 = ***(uint64_t (****)(void))&this[1];
  return v8();
}

uint64_t RB::Path::Flattener::lineto(uint64_t result, float64x2_t a2)
{
  double v3 = *(double *)(result + 80);
  float32x2_t v4 = vcvt_f32_f64(a2);
  *(float32x2_t *)(result + 80) = v4;
  uint32x2_t v5 = (uint32x2_t)vceq_f32(*(float32x2_t *)&v3, v4);
  if ((vpmin_u32(v5, v5).u32[0] & 0x80000000) == 0)
  {
    uint64_t v6 = result;
    float32x2_t v7 = vminnm_f32(*(float32x2_t *)&v3, v4);
    float32x2_t v8 = vmaxnm_f32(*(float32x2_t *)&v3, v4);
    float32x2_t v9 = vmaxnm_f32(*(float32x2_t *)(result + 64), v8);
    *(float32x2_t *)(result + 56) = vminnm_f32(*(float32x2_t *)(result + 56), v7);
    *(float32x2_t *)(result + 64) = v9;
    uint32x2_t v10 = (uint32x2_t)vorr_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(result + 24), v8), (int8x8_t)vcgt_f32(v7, *(float32x2_t *)(result + 32)));
    if ((vpmax_u32(v10, v10).u32[0] & 0x80000000) != 0)
    {
      return RB::Path::Flattener::push_cropped(result, v3, v4);
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(result + 8) + 24))(*(void *)(result + 8));
      *(unsigned char *)(v6 + 88) = 0;
    }
  }
  return result;
}

uint64_t RB::Path::Flattener::moveto(uint64_t a1, float64x2_t a2)
{
  RB::Path::Flattener::closepath((float32x2_t *)a1);
  float32x2_t v3 = vcvt_f32_f64(a2);
  *(float32x2_t *)(a1 + 72) = v3;
  *(float32x2_t *)(a1 + 80) = v3;
  *(unsigned char *)(a1 + 88) = 0;
  float32x2_t v4 = ***(uint64_t (****)(void))(a1 + 8);
  return v4();
}

void RB::Path::Flattener::quadto(uint64_t a1, float64x2_t a2, float64x2_t a3, double a4, int32x4_t a5, int8x16_t a6)
{
  double v7 = *(double *)(a1 + 80);
  float32x2_t v8 = vcvt_f32_f64(a2);
  float32x2_t v9 = vcvt_f32_f64(a3);
  *(float32x2_t *)(a1 + 80) = v9;
  float32x2_t v10 = vminnm_f32(vminnm_f32(*(float32x2_t *)&v7, v8), v9);
  float32x2_t v11 = vmaxnm_f32(vmaxnm_f32(*(float32x2_t *)&v7, v8), v9);
  uint32x2_t v12 = (uint32x2_t)vorr_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(a1 + 24), v11), (int8x8_t)vcgt_f32(v10, *(float32x2_t *)(a1 + 32)));
  if ((vpmax_u32(v12, v12).u32[0] & 0x80000000) != 0)
  {
    float32x2_t v23 = vmaxnm_f32(*(float32x2_t *)(a1 + 64), v11);
    *(float32x2_t *)(a1 + 56) = vminnm_f32(*(float32x2_t *)(a1 + 56), v10);
    *(float32x2_t *)(a1 + 64) = v23;
    RB::Path::Flattener::push_cropped(a1, v7, v9);
  }
  else
  {
    double v13 = COERCE_DOUBLE(vminnm_f32(*(float32x2_t *)&v7, v9));
    float32x2_t v14 = vmaxnm_f32(*(float32x2_t *)&v7, v9);
    *(int32x2_t *)a5.i8 = vcge_f32(v14, v8);
    uint32x2_t v15 = (uint32x2_t)vand_s8(*(int8x8_t *)a5.i8, (int8x8_t)vcge_f32(v8, *(float32x2_t *)&v13));
    if ((vpmin_u32(v15, v15).u32[0] & 0x80000000) == 0) {
      double v13 = RB::Path::quadratic_bounds_slow(*(float32x2_t *)&v7, v8, v9, a5, a6);
    }
    float32x2_t v16 = *(float32x2_t *)(a1 + 64);
    *(float32x2_t *)(a1 + 56) = vminnm_f32(*(float32x2_t *)(a1 + 56), *(float32x2_t *)&v13);
    *(float32x2_t *)(a1 + 64) = vmaxnm_f32(v16, v14);
    float32x2_t v17 = vabs_f32(vadd_f32(vsub_f32(v9, vadd_f32(v8, v8)), *(float32x2_t *)&v7));
    float v18 = ceilf(sqrtf(*(float *)(a1 + 20) * sqrtf(vaddv_f32(vmul_f32(v17, v17)))));
    if (v18 >= 0.0 && ((LODWORD(v18) & 0x7FFFFFFFu) - 0x800000) >> 24 <= 0x7E || LODWORD(v18) == 0)
    {
      if (v18 >= 1.0)
      {
        if (v18 > 1024.0) {
          float v18 = 1024.0;
        }
        uint64_t v22 = (int)v18;
      }
      else
      {
        uint32x2_t v21 = (uint32x2_t)vceq_f32(*(float32x2_t *)&v7, v9);
        if ((vpmin_u32(v21, v21).u32[0] & 0x80000000) != 0) {
          return;
        }
        uint64_t v22 = 1;
      }
      (*(void (**)(void, uint64_t, double, double, double))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), v22, v7, *(double *)&v8, *(double *)&v9);
      *(unsigned char *)(a1 + 88) = 0;
    }
  }
}

void RB::Path::Flattener::cubeto(uint64_t a1, float64x2_t a2, float64x2_t a3, float64x2_t a4, double a5, int32x4_t a6, int32x4_t a7, int32x4_t a8, int32x4_t a9)
{
  double v10 = *(double *)(a1 + 80);
  float32x2_t v11 = vcvt_f32_f64(a2);
  float32x2_t v12 = vcvt_f32_f64(a3);
  float32x2_t v13 = vcvt_f32_f64(a4);
  *(float32x2_t *)(a1 + 80) = v13;
  double v14 = COERCE_DOUBLE(vminnm_f32(*(float32x2_t *)&v10, v13));
  float32x2_t v15 = vmaxnm_f32(*(float32x2_t *)&v10, v13);
  *(float32x2_t *)a8.i8 = vminnm_f32(v11, v12);
  *(float32x2_t *)a9.i8 = vmaxnm_f32(v11, v12);
  float32x2_t v16 = vminnm_f32(*(float32x2_t *)&v14, *(float32x2_t *)a8.i8);
  float32x2_t v17 = vmaxnm_f32(v15, *(float32x2_t *)a9.i8);
  float32x2_t v19 = *(float32x2_t *)(a1 + 24);
  float32x2_t v18 = *(float32x2_t *)(a1 + 32);
  uint32x2_t v20 = (uint32x2_t)vorr_s8((int8x8_t)vcgt_f32(v19, v17), (int8x8_t)vcgt_f32(v16, v18));
  if ((vpmax_u32(v20, v20).u32[0] & 0x80000000) != 0)
  {
    float32x2_t v30 = vmaxnm_f32(*(float32x2_t *)(a1 + 64), v17);
    *(float32x2_t *)(a1 + 56) = vminnm_f32(*(float32x2_t *)(a1 + 56), v16);
    *(float32x2_t *)(a1 + 64) = v30;
LABEL_17:
    RB::Path::Flattener::push_cropped(a1, v10, v13);
    return;
  }
  *(int32x2_t *)a7.i8 = vcge_f32(v15, *(float32x2_t *)a9.i8);
  uint32x2_t v21 = (uint32x2_t)vand_s8(*(int8x8_t *)a7.i8, (int8x8_t)vcge_f32(*(float32x2_t *)a8.i8, *(float32x2_t *)&v14));
  *(uint32x2_t *)a6.i8 = vpmin_u32(v21, v21);
  if ((a6.i32[0] & 0x80000000) == 0)
  {
    double v14 = RB::Path::cubic_bounds_slow(*(float32x2_t *)&v10, v11, v12, v13, a6, a7, a8, a9);
    float32x2_t v19 = *(float32x2_t *)(a1 + 24);
    float32x2_t v18 = *(float32x2_t *)(a1 + 32);
  }
  float32x2_t v22 = vmaxnm_f32(*(float32x2_t *)(a1 + 64), v15);
  *(float32x2_t *)(a1 + 56) = vminnm_f32(*(float32x2_t *)(a1 + 56), *(float32x2_t *)&v14);
  *(float32x2_t *)(a1 + 64) = v22;
  uint32x2_t v23 = (uint32x2_t)vorr_s8((int8x8_t)vcgt_f32(v19, v15), (int8x8_t)vcgt_f32(*(float32x2_t *)&v14, v18));
  if ((vpmax_u32(v23, v23).u32[0] & 0x80000000) != 0) {
    goto LABEL_17;
  }
  float32x2_t v24 = vmaxnm_f32(vabs_f32(vadd_f32(vsub_f32(v12, vadd_f32(v11, v11)), *(float32x2_t *)&v10)), vabs_f32(vadd_f32(vsub_f32(v11, vadd_f32(v12, v12)), v13)));
  float v25 = ceilf(sqrtf(sqrtf(vaddv_f32(vmul_f32(v24, v24))) * *(float *)(a1 + 16)));
  if (v25 >= 0.0 && ((LODWORD(v25) & 0x7FFFFFFFu) - 0x800000) >> 24 <= 0x7E || LODWORD(v25) == 0)
  {
    if (v25 >= 1.0)
    {
      if (v25 > 1024.0) {
        float v25 = 1024.0;
      }
      uint64_t v29 = (int)v25;
    }
    else
    {
      uint32x2_t v28 = (uint32x2_t)vceq_f32(*(float32x2_t *)&v10, v13);
      if ((vpmin_u32(v28, v28).u32[0] & 0x80000000) != 0) {
        return;
      }
      uint64_t v29 = 1;
    }
    (*(void (**)(void, uint64_t, double, double, double, double))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), v29, v10, *(double *)&v11, *(double *)&v12, *(double *)&v13);
    *(unsigned char *)(a1 + 88) = 0;
  }
}

RB::DisplayList::Transform::Term *RB::DisplayList::Transform::Term::Term(RB::DisplayList::Transform::Term *this, const RB::DisplayList::Transform::Term *a2)
{
  int v4 = *(_DWORD *)a2;
  *(_DWORD *)this = *(_DWORD *)a2;
  uint32x2_t v5 = (_OWORD *)((char *)this + 8);
  switch(v4)
  {
    case 3:
      CFTypeRef v7 = (CFTypeRef)*((void *)a2 + 1);
      if (v7) {
        CFTypeRef v7 = CFRetain(v7);
      }
      *((void *)this + 1) = v7;
      *((void *)this + 2) = *((void *)a2 + 2);
      break;
    case 2:
      long long v8 = *(_OWORD *)((char *)a2 + 8);
      *((_DWORD *)this + 6) = *((_DWORD *)a2 + 6);
      *uint32x2_t v5 = v8;
      break;
    case 1:
      uint64_t v6 = *((void *)a2 + 1);
      *((_WORD *)this + 8) = *((_WORD *)a2 + 8);
      *(void *)uint32x2_t v5 = v6;
      break;
  }
  return this;
}

_DWORD *RB::DisplayList::Transform::add_color_to(_DWORD *this, const RB::Fill::Color *a2)
{
  float32x2_t v3 = this;
  int v4 = this[10];
  if (this[11] < (v4 + 1))
  {
    this = RB::vector<RB::DisplayList::Transform::Term,1ul,unsigned int>::reserve_slow(this, v4 + 1);
    int v4 = v3[10];
  }
  uint32x2_t v5 = (_DWORD *)*((void *)v3 + 4);
  if (!v5) {
    uint32x2_t v5 = v3;
  }
  uint64_t v6 = &v5[8 * v4];
  *uint64_t v6 = 1;
  uint64_t v7 = *(void *)a2;
  *((_WORD *)v6 + 8) = *((_WORD *)a2 + 4);
  *((void *)v6 + 1) = v7;
  ++v3[10];
  return this;
}

_DWORD *RB::DisplayList::Transform::add_font_mix_to(_DWORD *this, CFTypeRef cf, float a3, int a4)
{
  uint64_t v7 = this;
  int v8 = this[10];
  if (this[11] < (v8 + 1))
  {
    this = RB::vector<RB::DisplayList::Transform::Term,1ul,unsigned int>::reserve_slow(this, v8 + 1);
    int v8 = v7[10];
  }
  float32x2_t v9 = (_DWORD *)*((void *)v7 + 4);
  if (!v9) {
    float32x2_t v9 = v7;
  }
  double v10 = &v9[8 * v8];
  *double v10 = 3;
  *((void *)v10 + 1) = 0;
  *((void *)v10 + 2) = 0;
  if (cf)
  {
    this = CFRetain(cf);
    *((void *)v10 + 1) = this;
  }
  *((float *)v10 + 4) = a3;
  v10[5] = a4;
  ++v7[10];
  return this;
}

uint64_t RB::DisplayList::Transform::Term::can_mix(CGFont **this, CGFont **a2)
{
  int v2 = *(_DWORD *)this;
  if (*(_DWORD *)this != *(_DWORD *)a2) {
    return 0;
  }
  switch(v2)
  {
    case 3:
      if (*((_DWORD *)this + 5) == *((_DWORD *)a2 + 5))
      {
        double v10 = (os_unfair_lock_s *)RB::FontMixer::shared((RB::FontMixer *)this);
        return RB::FontMixer::can_mix(v10, this[1], a2[1], 0);
      }
      return 0;
    case 2:
      unsigned int can_mix = RB::Fill::Color::can_mix((RB::Fill::Color *)(this + 1), (const RB::Fill::Color *)(a2 + 1));
      unsigned int v9 = RB::Fill::Color::can_mix((RB::Fill::Color *)((char *)this + 18), (const RB::Fill::Color *)((char *)a2 + 18));
      if (v9 >= can_mix) {
        return can_mix;
      }
      else {
        return v9;
      }
    case 1:
      uint32x2_t v5 = (RB::Fill::Color *)(this + 1);
      uint64_t v6 = (const RB::Fill::Color *)(a2 + 1);
      return RB::Fill::Color::can_mix(v5, v6);
    default:
      return 4;
  }
}

void RB::DisplayList::Transform::Term::mix(CGFont **this, CGFont **a2, float a3)
{
  int v6 = *(_DWORD *)this;
  if (*(_DWORD *)this == 3)
  {
    unsigned int v9 = (os_unfair_lock_s *)RB::FontMixer::shared((RB::FontMixer *)this);
    RB::FontMixer::mix(v9, this[1], a2[1], LODWORD(a3), &v11);
    double v10 = this[1];
    this[1] = v11;
    float32x2_t v11 = v10;
    if (v10) {
      CFRelease(v10);
    }
    *((float *)this + 4) = *((float *)this + 4) + (float)((float)(*((float *)a2 + 4) - *((float *)this + 4)) * a3);
  }
  else
  {
    if (v6 == 2)
    {
      RB::Fill::Color::mix((uint64_t)(this + 1), (uint64_t)(a2 + 1), 0, a3);
      uint64_t v7 = (char *)this + 18;
      int v8 = (char *)a2 + 18;
    }
    else
    {
      if (v6 != 1) {
        return;
      }
      uint64_t v7 = (char *)(this + 1);
      int v8 = (char *)(a2 + 1);
    }
    RB::Fill::Color::mix((uint64_t)v7, (uint64_t)v8, 0, a3);
  }
}

uint64_t RB::DisplayList::Transform::can_mix(RB::DisplayList::Transform *this, const RB::DisplayList::Transform *a2)
{
  uint64_t v2 = *((unsigned int *)this + 10);
  if (v2 != *((_DWORD *)a2 + 10)) {
    return 0;
  }
  if (!v2) {
    return 4;
  }
  uint64_t v5 = 0;
  uint64_t v6 = 32 * v2;
  LOBYTE(v7) = 4;
  do
  {
    int v8 = (RB::DisplayList::Transform *)*((void *)this + 4);
    if (!v8) {
      int v8 = this;
    }
    unsigned int v9 = (CGFont **)((char *)v8 + v5);
    double v10 = (const RB::DisplayList::Transform *)*((void *)a2 + 4);
    if (!v10) {
      double v10 = a2;
    }
    unsigned int can_mix = RB::DisplayList::Transform::Term::can_mix(v9, (CGFont **)((char *)v10 + v5));
    if (can_mix >= v7) {
      uint64_t v7 = v7;
    }
    else {
      uint64_t v7 = can_mix;
    }
    if (!v7) {
      break;
    }
    v5 += 32;
  }
  while (v6 != v5);
  return v7;
}

void RB::DisplayList::Transform::mix(RB::DisplayList::Transform *this, const RB::DisplayList::Transform *a2, float a3)
{
  uint64_t v3 = *((unsigned int *)this + 10);
  if (v3)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 32 * v3;
    do
    {
      unsigned int v9 = (RB::DisplayList::Transform *)*((void *)this + 4);
      if (!v9) {
        unsigned int v9 = this;
      }
      double v10 = (CGFont **)((char *)v9 + v7);
      float32x2_t v11 = (const RB::DisplayList::Transform *)*((void *)a2 + 4);
      if (!v11) {
        float32x2_t v11 = a2;
      }
      RB::DisplayList::Transform::Term::mix(v10, (CGFont **)((char *)v11 + v7), a3);
      v7 += 32;
    }
    while (v8 != v7);
  }
}

uint64_t RB::DisplayList::Transform::xml_elements(uint64_t this, RB::XML::Document *a2)
{
  if (*(void *)(this + 32)) {
    uint64_t v2 = *(void *)(this + 32);
  }
  else {
    uint64_t v2 = this;
  }
  uint64_t v3 = *(unsigned int *)(this + 40);
  if (v3)
  {
    uint64_t v4 = v2 + 20;
    uint64_t v5 = 32 * v3;
    do
    {
      int v6 = *(_DWORD *)(v4 - 20);
      switch(v6)
      {
        case 3:
          RB::XML::Document::push(a2, "mix-fonts");
        case 2:
          RB::XML::Document::push(a2, "color");
        case 1:
          RB::XML::Document::push(a2, "color");
      }
      v4 += 32;
      v5 -= 32;
    }
    while (v5);
  }
  return this;
}

void sub_2141872D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void RB::XML::Element::set<RB::XML::Value::Color>()
{
}

void RB::XML::Element::set<RB::XML::Value::ConstantString>()
{
}

uint64_t RB::DisplayList::LayerItem::apply_transform(RB::DisplayList::LayerItem *this, const Transform *a2, RB::DisplayList::Contents *a3)
{
  return RB::DisplayList::Layer::apply_transform(*((void *)this + 6), a2, a3);
}

int *RB::DisplayList::Transform::encode(int *this, RB::Encoder *a2)
{
  if (*((void *)this + 4)) {
    uint64_t v2 = (int *)*((void *)this + 4);
  }
  else {
    uint64_t v2 = this;
  }
  uint64_t v3 = this[10];
  if (v3)
  {
    uint64_t v5 = 32 * v3;
    do
    {
      RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::DisplayList::Transform::Term::encode(v2, a2);
      this = (int *)RB::ProtobufEncoder::end_length_delimited(a2);
      v2 += 8;
      v5 -= 32;
    }
    while (v5);
  }
  return this;
}

uint64_t RB::DisplayList::Transform::decode(RB::DisplayList::Transform *this, RB::Decoder *a2)
{
  if (*((void *)this + 4)) {
    uint64_t v4 = (RB::DisplayList::Transform *)*((void *)this + 4);
  }
  else {
    uint64_t v4 = this;
  }
  uint64_t v5 = *((unsigned int *)this + 10);
  if (v5)
  {
    int v6 = (CFTypeRef *)((char *)v4 + 8);
    uint64_t v7 = 32 * v5;
    do
    {
      if (*((_DWORD *)v6 - 2) == 3 && *v6) {
        CFRelease(*v6);
      }
      v6 += 4;
      v7 -= 32;
    }
    while (v7);
  }
  *((_DWORD *)this + 10) = 0;
  uint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    uint64_t v9 = result;
    do
    {
      if ((v9 & 0x7FFFFFFF8) == 8)
      {
        unsigned int v10 = *((_DWORD *)this + 10);
        unsigned int v11 = v10 + 1;
        if (*((_DWORD *)this + 11) < v10 + 1)
        {
          RB::vector<RB::DisplayList::Transform::Term,1ul,unsigned int>::reserve_slow(this, v11);
          unsigned int v10 = *((_DWORD *)this + 10);
          unsigned int v11 = v10 + 1;
        }
        float32x2_t v12 = (RB::DisplayList::Transform *)*((void *)this + 4);
        if (!v12) {
          float32x2_t v12 = this;
        }
        float32x2_t v13 = (RB::DisplayList::Transform *)((char *)v12 + 32 * v10);
        *(_DWORD *)float32x2_t v13 = 0;
        *((_DWORD *)this + 10) = v11;
        if ((v9 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          RB::DisplayList::Transform::Term::decode(v13, a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v9);
      }
      uint64_t result = RB::ProtobufDecoder::next_field(a2);
      uint64_t v9 = result;
    }
    while (result);
  }
  return result;
}

int *RB::DisplayList::Transform::Term::encode(int *this, RB::Encoder *a2)
{
  uint64_t v3 = this;
  int v4 = *this;
  if (*this == 3)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x22uLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Encoder::cgfont_field(a2, 1, *((CGFont **)v3 + 1));
    int v5 = v3[4];
    if (*(float *)&v5 != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x15uLL);
      RB::ProtobufEncoder::encode_fixed32(a2, v5);
    }
    unint64_t v6 = v3[5];
    if (v6)
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
      RB::ProtobufEncoder::encode_varint(a2, v6);
    }
  }
  else if (v4 == 2)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Fill::Color::encode((RB::Fill::Color *)(v3 + 2), a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
    RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Fill::Color::encode((RB::Fill::Color *)((char *)v3 + 18), a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  else
  {
    if (v4 != 1) {
      return this;
    }
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Fill::Color::encode((RB::Fill::Color *)(v3 + 2), a2);
  }
  return (int *)RB::ProtobufEncoder::end_length_delimited(a2);
}

unint64_t RB::DisplayList::Transform::Term::decode(RB::DisplayList::Transform::Term *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    unint64_t v6 = (CFTypeRef *)((char *)this + 8);
    while (1)
    {
      unint64_t v7 = v5 >> 3;
      if ((v5 >> 3) == 4)
      {
        if (*(_DWORD *)this == 3 && *v6) {
          CFRelease(*v6);
        }
        *(_DWORD *)this = 3;
        *unint64_t v6 = 0;
        *((void *)this + 2) = 0;
        if ((v5 & 7) != 2)
        {
LABEL_53:
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
          goto LABEL_51;
        }
        RB::ProtobufDecoder::begin_message(a2);
        uint64_t field = RB::ProtobufDecoder::next_field(a2);
        if (field)
        {
          unint64_t v9 = field;
          do
          {
            unint64_t v10 = v9 >> 3;
            if ((v9 >> 3) == 3)
            {
              *((_DWORD *)this + 5) = RB::ProtobufDecoder::uint_field((uint64_t **)a2, v9);
            }
            else if (v10 == 2)
            {
              *((float *)this + 4) = RB::ProtobufDecoder::float_field(a2, v9);
            }
            else if (v10 == 1)
            {
              unsigned int v11 = RB::Decoder::cgfont_field(a2, v9);
              CFTypeRef v12 = *v6;
              if (*v6 != v11)
              {
                if (v12) {
                  CFRelease(v12);
                }
                if (v11) {
                  CFTypeRef v13 = CFRetain(v11);
                }
                else {
                  CFTypeRef v13 = 0;
                }
                *unint64_t v6 = v13;
              }
            }
            else
            {
              RB::ProtobufDecoder::skip_field(a2, v9);
            }
            unint64_t v9 = RB::ProtobufDecoder::next_field(a2);
          }
          while (v9);
        }
        goto LABEL_49;
      }
      if (v7 == 2) {
        break;
      }
      if (v7 != 1)
      {
        RB::ProtobufDecoder::skip_field(a2, v5);
        goto LABEL_51;
      }
      if (*(_DWORD *)this == 3)
      {
        if (*v6) {
          CFRelease(*v6);
        }
      }
      *(_DWORD *)this = 1;
      if ((v5 & 7) != 2) {
        goto LABEL_53;
      }
      RB::ProtobufDecoder::begin_message(a2);
      RB::Fill::Color::decode((uint64_t)this + 8, a2);
LABEL_49:
      RB::ProtobufDecoder::end_message((uint64_t)a2);
LABEL_51:
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
      if (!result) {
        return result;
      }
    }
    if (*(_DWORD *)this == 3 && *v6) {
      CFRelease(*v6);
    }
    *(_DWORD *)this = 2;
    if ((v5 & 7) != 2) {
      goto LABEL_53;
    }
    RB::ProtobufDecoder::begin_message(a2);
    *((void *)this + 1) = 0x3C00000000000000;
    *((_WORD *)this + 8) = 0;
    *(void *)((char *)this + 18) = 0x3C00000000000000;
    *((_WORD *)this + 13) = 0;
    uint64_t v14 = RB::ProtobufDecoder::next_field(a2);
    if (!v14) {
      goto LABEL_49;
    }
    unint64_t v15 = v14;
    while (1)
    {
      if ((v15 >> 3) == 2)
      {
        if ((v15 & 7) != 2)
        {
LABEL_48:
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
          goto LABEL_46;
        }
        RB::ProtobufDecoder::begin_message(a2);
        float32x2_t v16 = (char *)this + 18;
      }
      else
      {
        if ((v15 >> 3) != 1)
        {
          RB::ProtobufDecoder::skip_field(a2, v15);
          goto LABEL_46;
        }
        if ((v15 & 7) != 2) {
          goto LABEL_48;
        }
        RB::ProtobufDecoder::begin_message(a2);
        float32x2_t v16 = (char *)this + 8;
      }
      RB::Fill::Color::decode((uint64_t)v16, a2);
      RB::ProtobufDecoder::end_message((uint64_t)a2);
LABEL_46:
      unint64_t v15 = RB::ProtobufDecoder::next_field(a2);
      if (!v15) {
        goto LABEL_49;
      }
    }
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Color,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_214187A94(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Color *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Color>,std::allocator<RB::XML::Value::Color>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Color *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Color>,std::allocator<RB::XML::Value::Color>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::ConstantString,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_214187B84(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::ConstantString *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::ConstantString>,std::allocator<RB::XML::Value::ConstantString>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::ConstantString *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::ConstantString>,std::allocator<RB::XML::Value::ConstantString>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::Stroke::stroke_points(void *a1, uint64_t (***a2)(void), float64x2_t a3)
{
  v5[0] = a2;
  v5[1] = vcvt_f32_f64(a3);
  int32x2_t v5[2] = 0x3F80000000000000;
  [a1 applyFunction:_ZZN2RB6Stroke13stroke_pointsEPU18objcproto8RBStroke11objc_objectDv2_dRNS0_12PathConsumerINS0_5PointEEEEN3__08__invokeEmPK15RBStrokeElementPKfPv info:v5];
  return (**a2)(a2);
}

uint64_t RB::Stroke::stroke_particles(void *a1, uint64_t (***a2)(void), float64x2_t a3)
{
  v10[0] = a2;
  __asm { FMOV            V1.2S, #1.0 }
  v10[1] = vcvt_f32_f64(a3);
  v10[2] = _D1;
  v10[3] = 1065353216;
  v10[4] = 0;
  v10[5] = 0;
  v10[6] = 1065353216;
  [a1 applyFunction:_ZZN2RB6Stroke16stroke_particlesEPU18objcproto8RBStroke11objc_objectDv2_dRNS0_12PathConsumerINS0_8ParticleEEEEN3__08__invokeEmPK15RBStrokeElementPKfPv info:v10];
  return (**a2)(a2);
}

uint64_t _ZZN2RB6Stroke13stroke_pointsEPU18objcproto8RBStroke11objc_objectDv2_dRNS0_12PathConsumerINS0_5PointEEEEN3__08__invokeEmPK15RBStrokeElementPKfPv(uint64_t result, unsigned __int8 *a2, float32x2_t *a3, float32x2_t *a4)
{
  if (result)
  {
    uint64_t v7 = result;
    uint64_t v8 = (float *)&a4[2];
    do
    {
      unsigned int v10 = *a2++;
      uint64_t v9 = v10;
      if (v10 > 0xF) {
        uint64_t v11 = 0;
      }
      else {
        uint64_t v11 = RB::Stroke::element_args(RBStrokeElement)::elts[v9];
      }
      switch((int)v9)
      {
        case 0:
          uint64_t result = (*(uint64_t (**)(float32x2_t, float *, double))(**(void **)a4 + 16))(*a4, v8, COERCE_DOUBLE(vadd_f32(*a3, a4[1])));
          break;
        case 1:
          uint64_t result = (*(uint64_t (**)(float32x2_t, float *, double))(**(void **)a4 + 24))(*a4, v8, COERCE_DOUBLE(vadd_f32(*a3, a4[1])));
          break;
        case 2:
          uint64_t result = (*(uint64_t (**)(float32x2_t, float *, double, double))(**(void **)a4 + 32))(*a4, v8, COERCE_DOUBLE(vadd_f32(*a3, a4[1])), COERCE_DOUBLE(vadd_f32(a3[1], a4[1])));
          break;
        case 3:
          uint64_t result = (*(uint64_t (**)(float32x2_t, float *, double, double, double))(**(void **)a4 + 40))(*a4, v8, COERCE_DOUBLE(vadd_f32(*a3, a4[1])), COERCE_DOUBLE(vadd_f32(a3[1], a4[1])), COERCE_DOUBLE(vadd_f32(a3[2], a4[1])));
          break;
        case 4:
          uint64_t result = (*(uint64_t (**)(void))(**(void **)a4 + 8))();
          break;
        case 5:
          float *v8 = fmaxf(a3->f32[0] * 0.5, 0.0);
          break;
        case 14:
          a4[2].i32[1] = a3->i32[0];
          break;
        default:
          break;
      }
      a3 = (float32x2_t *)((char *)a3 + 4 * v11);
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t _ZZN2RB6Stroke16stroke_particlesEPU18objcproto8RBStroke11objc_objectDv2_dRNS0_12PathConsumerINS0_8ParticleEEEEN3__08__invokeEmPK15RBStrokeElementPKfPv(uint64_t result, unsigned __int8 *a2, float32x2_t *a3, float32x2_t *a4)
{
  if (result)
  {
    uint64_t v7 = result;
    uint64_t v8 = a4 + 2;
    do
    {
      unsigned int v10 = *a2++;
      uint64_t v9 = v10;
      if (v10 > 0xF) {
        uint64_t v11 = 0;
      }
      else {
        uint64_t v11 = RB::Stroke::element_args(RBStrokeElement)::elts[v9];
      }
      switch((int)v9)
      {
        case 0:
          uint64_t result = (*(uint64_t (**)(float32x2_t, float32x2_t *, double))(**(void **)a4 + 16))(*a4, v8, COERCE_DOUBLE(vadd_f32(*a3, a4[1])));
          break;
        case 1:
          uint64_t result = (*(uint64_t (**)(float32x2_t, float32x2_t *, double))(**(void **)a4 + 24))(*a4, v8, COERCE_DOUBLE(vadd_f32(*a3, a4[1])));
          break;
        case 2:
          uint64_t result = (*(uint64_t (**)(float32x2_t, float32x2_t *, double, double))(**(void **)a4 + 32))(*a4, v8, COERCE_DOUBLE(vadd_f32(*a3, a4[1])), COERCE_DOUBLE(vadd_f32(a3[1], a4[1])));
          break;
        case 3:
          uint64_t result = (*(uint64_t (**)(float32x2_t, float32x2_t *, double, double, double))(**(void **)a4 + 40))(*a4, v8, COERCE_DOUBLE(vadd_f32(*a3, a4[1])), COERCE_DOUBLE(vadd_f32(a3[1], a4[1])), COERCE_DOUBLE(vadd_f32(a3[2], a4[1])));
          break;
        case 4:
          uint64_t result = (*(uint64_t (**)(void))(**(void **)a4 + 8))();
          break;
        case 6:
          v8->i32[0] = a3->i32[0];
          break;
        case 7:
          a4[2].i32[1] = a3->i32[0];
          break;
        case 8:
          a4[3].i32[0] = a3->i32[0];
          break;
        case 9:
          a4[3].i32[1] = a3->i32[0];
          break;
        case 10:
          a4[4].i32[0] = a3->i32[0];
          break;
        case 11:
          a4[4].i32[1] = a3->i32[0];
          break;
        case 12:
          a4[5].i32[0] = a3->i32[0];
          break;
        case 13:
          a4[5].i32[1] = a3->i32[0];
          break;
        case 14:
          a4[6].i32[0] = a3->i32[0];
          break;
        case 15:
          a4[6].i32[1] = a3->i32[0];
          break;
        default:
          break;
      }
      a3 = (float32x2_t *)((char *)a3 + 4 * v11);
      --v7;
    }
    while (v7);
  }
  return result;
}

void sub_2141882EC(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x1081C40A869C1B6);
  _Unwind_Resume(a1);
}

void sub_2141883A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2141886A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)va);
  _Unwind_Resume(a1);
}

void sub_214188A24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11, uint64_t a12, id a13, id a14, id a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22,id a23,id a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,id a31)
{
  if (a25) {
    -[RBDrawable renderWithFlags:items:count:displayList:](a25);
  }

  if (v31)
  {
    if (atomic_fetch_add_explicit(v31 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v31 + 8))(v31);
    }
  }

  _Unwind_Resume(a1);
}

void sub_214188F5C(_Unwind_Exception *a1, int a2)
{
  uint64_t v6 = v2[7];
  if (v6)
  {
    -[RBDrawable renderDisplayList:sourceRect:destinationOffset:flags:](v6, (uint64_t)a1, a2, (uint64_t)(v2 + 20));
    a1 = (_Unwind_Exception *)v2[20];
  }
  RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)(v2 + 22));
  RB::vector<RB::refcounted_ptr<RB::DisplayList::Contents>,8ul,unsigned int>::~vector(v4 - 224);
  if (v2[3] > 0x1000uLL) {
    free(v3);
  }
  _Unwind_Resume(a1);
}

uint64_t RB::vector<RB::refcounted_ptr<RB::DisplayList::Contents>,8ul,unsigned int>::~vector(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 64);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = (void *)a1;
  }
  if (*(_DWORD *)(a1 + 72))
  {
    unint64_t v4 = 0;
    do
    {
      unint64_t v5 = (atomic_uint *)v3[v4];
      if (v5 && atomic_fetch_add_explicit(v5 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v5 + 8))(v5);
      }
      ++v4;
    }
    while (v4 < *(unsigned int *)(a1 + 72));
    uint64_t v2 = *(void **)(a1 + 64);
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

void sub_21418935C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a28, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
}

id __copy_helper_block_e8_56c66_ZTSN2RB8objc_ptrIPU29objcproto18RBDrawableDelegate11objc_objectEE(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 56);
  *(void *)(a1 + 56) = result;
  return result;
}

void __destroy_helper_block_e8_56c66_ZTSN2RB8objc_ptrIPU29objcproto18RBDrawableDelegate11objc_objectEE(uint64_t a1)
{
}

id __copy_helper_block_e8_48c58_ZTSN2RB8objc_ptrIPU21objcproto10MTLTexture11objc_objectEE56c66_ZTSN2RB8objc_ptrIPU29objcproto18RBDrawableDelegate11objc_objectEE64c30_ZTSN2RB8objc_ptrIP8RBDeviceEE72c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE120c55_ZTSN2RB8objc_ptrIPU18objcproto8MTLEvent11objc_objectEE(void *a1, uint64_t a2)
{
  a1[6] = *(id *)(a2 + 48);
  a1[7] = *(id *)(a2 + 56);
  a1[8] = *(id *)(a2 + 64);
  uint64_t v4 = *(void *)(a2 + 72);
  if (v4) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
  }
  a1[9] = v4;
  id result = *(id *)(a2 + 120);
  a1[15] = result;
  return result;
}

void sub_21418950C(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 72);
  if (v3) {
    __copy_helper_block_e8_48c58_ZTSN2RB8objc_ptrIPU21objcproto10MTLTexture11objc_objectEE56c66_ZTSN2RB8objc_ptrIPU29objcproto18RBDrawableDelegate11objc_objectEE64c30_ZTSN2RB8objc_ptrIP8RBDeviceEE72c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE120c55_ZTSN2RB8objc_ptrIPU18objcproto8MTLEvent11objc_objectEE_cold_1(v3);
  }

  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_48c58_ZTSN2RB8objc_ptrIPU21objcproto10MTLTexture11objc_objectEE56c66_ZTSN2RB8objc_ptrIPU29objcproto18RBDrawableDelegate11objc_objectEE64c30_ZTSN2RB8objc_ptrIP8RBDeviceEE72c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE120c55_ZTSN2RB8objc_ptrIPU18objcproto8MTLEvent11objc_objectEE(uint64_t a1)
{
  uint64_t v2 = *(atomic_uint **)(a1 + 72);
  if (v2 && atomic_fetch_add_explicit(v2 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }

  uint64_t v3 = *(void **)(a1 + 48);
}

void sub_2141898AC(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_214189950(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_1_0()
{
}

RB::FunctionLibrary *RB::FunctionLibrary::FunctionLibrary(RB::FunctionLibrary *this, id *a2, const RB::CustomShader::Library *a3)
{
  float32x2_t v19[2] = *MEMORY[0x263EF8340];
  *(void *)this = a2;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = *((unsigned int *)a3 + 7);
  *((_DWORD *)this + 6) = 0;
  RB::UntypedTable::UntypedTable((uint64_t)this + 32, 0, 0, 0, (void (*)(void *))RB::FunctionLibrary::FunctionLibrary(RB::Device &,RB::CustomShader::Library const&)::$_0::__invoke, 0);
  *((unsigned char *)this + 112) = 0;
  id v17 = 0;
  switch(*((_DWORD *)a3 + 6))
  {
    case 0:
      id v6 = (id)[a2[3] newDefaultLibraryWithBundle:*((void *)a3 + 2) error:&v17];

      goto LABEL_5;
    case 1:
      id v6 = (id)[a2[3] newLibraryWithURL:*((void *)a3 + 2) error:&v17];

      goto LABEL_5;
    case 2:
      id v9 = *((id *)a3 + 2);
      unsigned int v10 = (const void *)[v9 bytes];
      size_t v11 = [v9 length];
      destructor[0] = MEMORY[0x263EF8330];
      destructor[1] = 3221225472;
      destructor[2] = ___ZN2RB15FunctionLibraryC2ERNS_6DeviceERKNS_12CustomShader7LibraryE_block_invoke;
      destructor[3] = &unk_2641F8AA8;
      destructor[4] = v9;
      uint64_t v7 = dispatch_data_create(v10, v11, MEMORY[0x263EF83A0], destructor);
      uint64_t v8 = [a2[3] newLibraryWithData:v7 error:&v17];

      goto LABEL_7;
    case 3:
      id v6 = (id)*((void *)a3 + 2);
      if ((id)[v6 device] != a2[3]) {
        goto LABEL_9;
      }
      id v15 = (id)*((void *)this + 1);
      if (v15 != v6)
      {

        id v6 = v6;
LABEL_5:
        *((void *)this + 1) = v6;
      }
      goto LABEL_10;
    case 4:
      uint64_t v7 = objc_opt_new();
      [v7 appendString:@"#include <metal_stdlib>\n\nnamespace RB {\n  struct Layer {\n    metal::texture2d<half> tex;\n    float2 info[5];\n    half4 sample(float2 p) const {\n      p = metal::fma(p.x, info[0], metal::fma(p.y, info[1], info[2]));\n      p = metal::clamp(p, info[3], info[4]);\n      return tex.sample(metal::sampler(metal::filter::linear), p);\n    }\n  };\n}\n\n#line 0\n"];
      [v7 appendString:*((void *)a3 + 2)];
      uint64_t v8 = [a2[3] newLibraryWithSource:v7 options:0 error:&v17];

LABEL_7:
      *((void *)this + 1) = v8;

      goto LABEL_9;
    default:
LABEL_9:
      id v6 = (id)*((void *)this + 1);
LABEL_10:
      if (!v6)
      {
        if (v17)
        {
          v18[0] = *MEMORY[0x263F08320];
          uint64_t v12 = [v17 localizedDescription];
          v18[1] = *MEMORY[0x263F08608];
          v19[0] = v12;
          v19[1] = v17;
          uint64_t v13 = [NSDictionary dictionaryWithObjects:v19 forKeys:v18 count:2];
        }
        else
        {
          uint64_t v13 = 0;
        }
        RB::CustomShader::Library::log_error((os_unfair_lock_s *)a3, (NSError *)[MEMORY[0x263F087E8] errorWithDomain:@"com.apple.RenderBox.RBShaderError" code:0 userInfo:v13]);
      }
      return this;
  }
}

void sub_214189E4C(_Unwind_Exception *a1)
{
  RB::UntypedTable::~UntypedTable(v2);

  _Unwind_Resume(a1);
}

void ___ZN2RB15FunctionLibraryC2ERNS_6DeviceERKNS_12CustomShader7LibraryE_block_invoke(uint64_t a1)
{
}

size_t *RB::FunctionLibrary::function(uint64_t a1, uint64_t a2, unsigned int a3, void *a4)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  if (!*(void *)(a1 + 8) || *(_DWORD *)(a1 + 16) != *(_DWORD *)(*(void *)(a2 + 16) + 28)) {
    return 0;
  }
  uint64_t v8 = (uint64_t *)(a3 | (8 * *(_DWORD *)(a2 + 32)));
  id v9 = (size_t **)(a1 + 32);
  v23[0] = 0;
  unsigned int v10 = RB::UntypedTable::lookup((RB::UntypedTable *)(a1 + 32), v8, v23);
  size_t v11 = (size_t *)v10;
  if (!v23[0])
  {
    double v12 = RB::current_time_seconds((RB *)v10);
    float32x2_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 8;
    long long v27 = xmmword_214219AB0;
    float32x2_t v22 = 0;
    uint64_t v13 = *(RB::Device **)a1;
    uint64_t v14 = *(void **)(a1 + 8);
    id v15 = (void *)*((void *)v13 + 3);
    float32x2_t v16 = (void *)RB::Device::library(v13);
    id v17 = v21;
    if (!v21 && v22) {
      RB::CustomShader::Library::log_error(*(os_unfair_lock_s **)(a2 + 16), v22);
    }
    if ([v17 newFunctionWithName:@"custom_fn"]) {
      operator new();
    }
    if (v11)
    {
      float32x2_t v19 = (RB *)RB::verbose_mode(0);
      if (v19)
      {
        double v20 = RB::current_time_seconds(v19);
        printf("built stitched function %s (%.2f ms)\n", (const char *)[*(id *)(a2 + 24) UTF8String], (v20 - v12) * 1000.0);
        fflush((FILE *)*MEMORY[0x263EF8358]);
      }
    }
    RB::UntypedTable::insert(v9, (size_t *)v8, v11);

    if (v24) {
      free(v24);
    }
  }
  return v11;
}

void sub_21418A174(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  if (*v20) {
    free(*v20);
  }

  MEMORY[0x21669AC10](v19, 0x10A0C408BE17B63);
  if (a19) {
    free(a19);
  }
  _Unwind_Resume(a1);
}

void RB::anonymous namespace'::make_stitched_library(uint64_t a1@<X0>, unsigned int a2@<W1>, void *a3@<X2>, void *a4@<X3>, void *a5@<X4>, void *a6@<X5>, uint64_t a7@<X6>, void *a8@<X7>, uint64_t *a9@<X8>)
{
  uint64_t v125 = *MEMORY[0x263EF8340];
  uint64_t v15 = [a5 newFunctionWithName:*(void *)(a1 + 24)];
  float32x2_t v16 = (void *)v15;
  if (v15)
  {
    unsigned int v93 = a8;
    v94 = a9;
    uint64_t v105 = (void *)v15;
    unsigned int v99 = a2;
    if (a2 == 3) {
      int v17 = 6;
    }
    else {
      int v17 = 2;
    }
    *(_DWORD *)a7 = v17;
    uint64_t v18 = a3[1];
    if (v18)
    {
      uint64_t v19 = (char *)(*a3 + 7);
      for (uint64_t i = 24 * v18; i; i -= 24)
      {
        switch(*(v19 - 3))
        {
          case 1:
            int v21 = 0;
            unsigned int v22 = 5u;
            break;
          case 2:
            int v21 = 0;
            unsigned int v22 = 6u;
            break;
          case 3:
            int v21 = 0;
            unsigned int v22 = 7u;
            break;
          case 4:
          case 6:
            int v21 = 0;
            unsigned int v22 = 8u;
            break;
          case 5:
            int v21 = 0;
            unsigned int v22 = 2u;
            break;
          case 7:
          case 8:
            unsigned int v22 = 4u;
            int v21 = 1;
            break;
          case 9:
            int v21 = 0;
            unsigned int v22 = 1u;
            break;
          default:
            int v21 = 0;
            unsigned int v22 = 0;
            break;
        }
        unsigned int v23 = *(_DWORD *)(a7 + 64) + 3;
        *(_DWORD *)(a7 + 64) = v23 & 0xFFFFFFFC;
        char v24 = *v19;
        uint64_t v25 = *(void *)(a7 + 48);
        if (*(void *)(a7 + 56) < (unint64_t)(v25 + 1))
        {
          RB::vector<RB::Function::Param,8ul,unsigned long>::reserve_slow((void *)(a7 + 8), v25 + 1);
          uint64_t v25 = *(void *)(a7 + 48);
        }
        uint64_t v26 = *(void *)(a7 + 40);
        if (!v26) {
          uint64_t v26 = a7 + 8;
        }
        *(_DWORD *)(v26 + 4 * v25) = ((v24 << 7) | 0x40) & (v24 << 6) & 0xC0 | (v23 >> 2 << 8) | v22;
        uint64_t v27 = *(void *)(a7 + 48) + 1;
        *(void *)(a7 + 48) = v27;
        if (*v19)
        {
          int v29 = *(_DWORD *)(a7 + 64);
          *(_DWORD *)(a7 + 64) = v29 + 4;
          if ((*v19 & 2) == 0) {
            goto LABEL_25;
          }
          int v28 = v29 + 8;
        }
        else
        {
          int v28 = *(_DWORD *)(a7 + 64) + RB::Function::Param::size_values[v22];
        }
        *(_DWORD *)(a7 + 64) = v28;
LABEL_25:
        if (v21)
        {
          if ((*(_DWORD *)(a7 + 68) & 0x80000000) == 0)
          {
            float32x2_t v16 = v105;
            if (a8)
            {
              uint64_t v81 = (void *)MEMORY[0x263F087E8];
              uint64_t v118 = *MEMORY[0x263F08320];
              uint64_t v119 = [NSString stringWithFormat:@"Only one texture argument is allowed: %@", *(void *)(a1 + 24)];
              *a8 = objc_msgSend(v81, "errorWithDomain:code:userInfo:", @"com.apple.RenderBox.RBShaderError", 3, objc_msgSend(NSDictionary, "dictionaryWithObjects:forKeys:count:", &v119, &v118, 1));
            }
            uint64_t *v94 = 0;
            goto LABEL_99;
          }
          *(_DWORD *)(a7 + 68) = v27 - 1;
        }
        v19 += 24;
      }
    }
    if (v99 - 2 <= 2)
    {
      unsigned int v30 = *(_DWORD *)(a7 + 64) + 3;
      *(_DWORD *)(a7 + 72) = v30 >> 2;
      *(_DWORD *)(a7 + 64) = (v30 & 0xFFFFFFFC) + 40;
      if (v99 == 4)
      {
        unsigned int v31 = (v30 & 0xFFFFFFFC) + 43;
        *(_DWORD *)(a7 + 76) = v31 >> 2;
        *(_DWORD *)(a7 + 64) = (v31 & 0xFFFFFFFC) + 40;
      }
    }
    id v110 = (id)objc_opt_new();
    id v101 = (id)objc_opt_new();
    uint64_t v32 = objc_opt_new();
    id v109 = (id)objc_opt_new();
    id v107 = (id)[objc_alloc(MEMORY[0x263F128E0]) initWithArgumentIndex:0];
    id v102 = (id)[objc_alloc(MEMORY[0x263F128E0]) initWithArgumentIndex:1];
    id v96 = (id)[objc_alloc(MEMORY[0x263F128E0]) initWithArgumentIndex:2];
    id v103 = (id)[objc_alloc(MEMORY[0x263F128E0]) initWithArgumentIndex:3];
    id v95 = (id)[objc_alloc(MEMORY[0x263F128E0]) initWithArgumentIndex:4];
    id v108 = (id)[objc_alloc(MEMORY[0x263F128E0]) initWithArgumentIndex:5];
    id v106 = (id)[objc_alloc(MEMORY[0x263F128E0]) initWithArgumentIndex:6];
    if ((RB::disable_workaround((RB *)"stitched-inputs", v33) & 1) == 0)
    {
      id v34 = objc_alloc(MEMORY[0x263F128D0]);
      v117[0] = v107;
      v117[1] = v102;
      v117[2] = v96;
      v117[3] = v103;
      v117[4] = v95;
      uint64_t v35 = [MEMORY[0x263EFF8C0] arrayWithObjects:v117 count:5];
      BOOL v36 = (void *)[v34 initWithName:@"__RB::XXX" arguments:v35 controlDependencies:MEMORY[0x263EFFA68]];
      [v101 addObject:v36];
      [v32 addObject:v36];
    }
    [v110 addObject:v103];
    if (v99 == 4 || v99 == 2)
    {
      id v38 = v123;
      [v110 addObject:v123];
      if (v99 == 4)
      {
        short float v39 = (void *)v122[0];
        [v110 addObject:v122[0]];
      }
    }
    else if (v99 == 1)
    {
      [v110 addObject:v95];
    }
    uint64_t v40 = *(void *)(a7 + 48);
    if (*(void *)(a7 + 40)) {
      short float v41 = *(unsigned int **)(a7 + 40);
    }
    else {
      short float v41 = (unsigned int *)(a7 + 8);
    }
    if (v40)
    {
      uint64_t v42 = 4 * v40;
      uint64_t v43 = MEMORY[0x263EFFA68];
      do
      {
        unsigned int v44 = *v41;
        unsigned int v45 = *v41 & 0x3F;
        if (v45 == 4)
        {
          [v110 addObject:v107];
        }
        else
        {
          unsigned int v46 = v44 >> 8;
          if ((v44 & 0x40) != 0)
          {
            id v52 = objc_alloc(MEMORY[0x263F128D0]);
            uint64_t v53 = v113;
            id v123 = v108;
            uint64_t v124 = (uint64_t)v113;
            float16x4_t v54 = objc_msgSend(v52, "initWithName:arguments:controlDependencies:", fn, objc_msgSend(MEMORY[0x263EFF8C0], "arrayWithObjects:count:", &v123, 2), v43);
            [v32 addObject:v54];
            __int16 v55 = @"__RB::Ainvalid";
            if (v45 != 3)
            {
              __int16 v55 = @"__RB::Avoid";
            }
            id v56 = objc_alloc(MEMORY[0x263F128D0]);
            v122[0] = (uint64_t)v106;
            v122[1] = (uint64_t)v54;
            uint64_t v50 = objc_msgSend(v56, "initWithName:arguments:controlDependencies:", v55, objc_msgSend(MEMORY[0x263EFF8C0], "arrayWithObjects:count:", v122, 2), v43);
            [v32 addObject:v50];

            [v110 addObject:v50];
            if ((*v41 & 0x80) != 0)
            {
              id v58 = objc_alloc(MEMORY[0x263F128D0]);
              uint64_t v59 = (void *)v122[0];
              id v123 = v108;
              uint64_t v124 = v122[0];
              uint64_t v60 = objc_msgSend(v58, "initWithName:arguments:controlDependencies:", v57, objc_msgSend(MEMORY[0x263EFF8C0], "arrayWithObjects:count:", &v123, 2), v43);
              [v32 addObject:v60];

              [v110 addObject:v60];
            }
          }
          else
          {
            id v48 = objc_alloc(MEMORY[0x263F128D0]);
            char v49 = (void *)v122[0];
            id v123 = v108;
            uint64_t v124 = v122[0];
            uint64_t v50 = objc_msgSend(v48, "initWithName:arguments:controlDependencies:", v47, objc_msgSend(MEMORY[0x263EFF8C0], "arrayWithObjects:count:", &v123, 2), v43);
            [v32 addObject:v50];

            [v110 addObject:v50];
          }
        }
        ++v41;
        v42 -= 4;
      }
      while (v42);
    }
    unint64_t v61 = (void *)[objc_alloc(MEMORY[0x263F128D0]) initWithName:*(void *)(a1 + 24) arguments:v110 controlDependencies:v101];
    if (v99 == 3)
    {
      [v32 addObject:v61];
      id v62 = objc_alloc(MEMORY[0x263F128D0]);
      id v63 = v123;
      v116[0] = v123;
      v116[1] = v61;
      uint64_t v64 = [MEMORY[0x263EFF8C0] arrayWithObjects:v116 count:2];
      uint64_t v65 = [v62 initWithName:@"__RB::Slayer" arguments:v64 controlDependencies:MEMORY[0x263EFFA68]];

      unint64_t v61 = (void *)v65;
    }
    long long v66 = objc_opt_new();
    id v67 = objc_alloc(MEMORY[0x263F128D8]);
    uint64_t v115 = v66;
    int v68 = objc_msgSend(v67, "initWithFunctionName:nodes:outputNode:attributes:", @"custom_fn", v32, v61, objc_msgSend(MEMORY[0x263EFF8C0], "arrayWithObjects:count:", &v115, 1));
    uint64_t v69 = objc_opt_new();
    [v69 addObject:v105];
    v111[0] = MEMORY[0x263EF8330];
    v111[1] = 3321888768;
    v111[2] = ___ZN2RB12_GLOBAL__N_121make_stitched_libraryERKNS_12CustomShader8FunctionENS1_4TypeERKNSt3__14spanIKNS1_5ValueELm18446744073709551615EEEPU19objcproto9MTLDevice11objc_objectPU21objcproto10MTLLibrary11objc_objectSG_RNS0_12FunctionInfoEPP7NSError_block_invoke;
    v111[3] = &__block_descriptor_40_e8_32c37_ZTSN2RB8objc_ptrIP14NSMutableArrayEE_e15_v32__0_8_16_B24l;
    id v112 = v69;
    [v109 enumerateKeysAndObjectsUsingBlock:v111];
    int v70 = objc_opt_new();
    uint64_t v114 = v68;
    objc_msgSend(v70, "setFunctionGraphs:", objc_msgSend(MEMORY[0x263EFF8C0], "arrayWithObjects:count:", &v114, 1));
    [v70 setFunctions:v69];
    id v123 = 0;
    uint64_t v71 = [a4 newLibraryWithStitchedDescriptor:v70 error:&v123];
    if (!v71)
    {
      if (v93)
      {
        unint64_t v90 = v69;
        long long v91 = v68;
        uint64_t v92 = v66;
        uint64_t v98 = v61;
        id v72 = objc_alloc_init(MEMORY[0x263F089D8]);
        unint64_t v73 = (void *)[v105 returnType];
        uint64_t v74 = v73;
        if (!v73) {
          goto LABEL_70;
        }
        if (v99 >= 3)
        {
          if (v99 == 3)
          {
            if ([v73 dataType] == 4)
            {
LABEL_70:
              uint64_t v76 = (NSMutableString *)[v105 arguments];
              uint64_t v77 = v76;
              if (!v76)
              {
LABEL_91:
                if (v123 && ![v72 length]) {
                  objc_msgSend(v72, "appendString:", objc_msgSend(v123, "localizedDescription"));
                }
                else {
                  [v72 appendString:@"unknown error"];
                }
                long long v87 = objc_opt_new();
                uint64_t v88 = [NSString stringWithFormat:@"Function stitching failed: %@.\n%@", *(void *)(a1 + 24), v72];
                [v87 setObject:v88 forKey:*MEMORY[0x263F08320]];
                if (v123) {
                  [v87 setObject:v123 forKey:*MEMORY[0x263F08608]];
                }
                *unsigned int v93 = [MEMORY[0x263F087E8] errorWithDomain:@"com.apple.RenderBox.RBShaderError" code:2 userInfo:v87];

                uint64_t v71 = 0;
                unint64_t v61 = v98;
                int v68 = v91;
                long long v66 = v92;
                uint64_t v69 = v90;
                goto LABEL_98;
              }
              unint64_t v89 = [(NSMutableString *)v76 count];
              LODWORD(v122[0]) = 6;
              if (v99 == 4)
              {
                LODWORD(v122[0]) = 3;
                uint64_t v80 = 2;
              }
              else
              {
                uint64_t v80 = 1;
                if (v99 != 2)
                {
                  if (v99 == 1)
                  {
                    LODWORD(v122[0]) = 2;
                    uint64_t v80 = 2;
                  }
                  goto LABEL_81;
                }
              }
              LODWORD(v122[0]) = 3;
LABEL_81:
              uint64_t v82 = *(void *)(a7 + 48);
              if (*(void *)(a7 + 40)) {
                uint64_t v83 = *(int **)(a7 + 40);
              }
              else {
                uint64_t v83 = (int *)(a7 + 8);
              }
              double v100 = (NSArray *)v80;
              uint64_t v84 = (NSArray *)v80;
              if (v82)
              {
                uint64_t v85 = 4 * v82;
                uint64_t v86 = v100;
                do
                {
                  uint64_t v84 = (NSArray *)((char *)&v86->super.isa + 1);
                  if ((~*v83 & 0xC0) == 0)
                  {
                    LODWORD(v122[0]) = 1;
                    uint64_t v84 = (NSArray *)((char *)&v86->super.isa + 2);
                  }
                  ++v83;
                  uint64_t v86 = v84;
                  v85 -= 4;
                }
                while (v85);
              }
              if ((unint64_t)v84 < v89) {
                [v72 appendFormat:@"Too few function arguments: expected %d, received %d.\n", v89 - (void)v100, *(void *)(a7 + 48)];
              }
              goto LABEL_91;
            }
            uint64_t v75 = @"Expected float2 result, has %@.\n";
LABEL_69:
            objc_msgSend(v72, "appendFormat:", v75, objc_msgSend(v74, "description"));
            goto LABEL_70;
          }
          if (v99 != 4) {
            goto LABEL_70;
          }
        }
        if ([v73 dataType] == 19) {
          goto LABEL_70;
        }
        uint64_t v75 = @"Expected half4 result, has %@.\n";
        goto LABEL_69;
      }
      uint64_t v71 = 0;
    }
LABEL_98:
    uint64_t *v94 = v71;

    float32x2_t v16 = v105;
    goto LABEL_99;
  }
  if (a8)
  {
    unint64_t v37 = (void *)MEMORY[0x263F087E8];
    uint64_t v120 = *MEMORY[0x263F08320];
    uint64_t v121 = [NSString stringWithFormat:@"Unknown Metal function: %@", *(void *)(a1 + 24)];
    *a8 = objc_msgSend(v37, "errorWithDomain:code:userInfo:", @"com.apple.RenderBox.RBShaderError", 1, objc_msgSend(NSDictionary, "dictionaryWithObjects:forKeys:count:", &v121, &v120, 1));
  }
  *a9 = 0;
LABEL_99:
}

void sub_21418AFDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12, id a13, id a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18, id a19, id a20,uint64_t a21,id a22,id a23,id a24,uint64_t a25,id a26,id a27,id a28,id a29,id a30,id a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,id a36,uint64_t a37)
{
  _Unwind_Resume(a1);
}

uint64_t RB::FunctionLibrary::prune_caches(RB::FunctionLibrary *this, int a2)
{
  int v3 = a2;
  return RB::UntypedTable::remove_if ((uint64_t)this + 32, (BOOL (*)(const void *, const void *, void *))RB::Table<unsigned long,RB::Function *>::remove_if<RB::FunctionLibrary::prune_caches::$_0>(RB::FunctionLibrary::prune_caches::$_0)::{lambda(void const*,void const*,void *)#1}::__invoke, &v3);
}

uint64_t RB::Function::Param::description(RB::Function::Param *this)
{
  int v1 = *(_DWORD *)this;
  if ((*(_DWORD *)this & 0x3Fu) > 8) {
    uint64_t v2 = "unknown";
  }
  else {
  if ((v1 & 0x40) != 0) {
    int v3 = " pointer";
  }
  else {
    int v3 = "";
  }
  return objc_msgSend(NSString, "stringWithFormat:", @"%s%s", v2, v3);
}

BOOL RB::FunctionLibrary::compile_shader(uint64_t a1, uint64_t *a2, unsigned int a3, void *a4)
{
  v60[1] = *MEMORY[0x263EF8340];
  uint64_t v5 = *a2;
  if (*a2)
  {
    int v9 = a3 | (8 * *(_DWORD *)(v5 + 32));
    uint64_t v46 = 0;
    uint64_t v47 = &v46;
    uint64_t v48 = 0x3812000000;
    char v49 = __Block_byref_object_copy__2;
    uint64_t v50 = __Block_byref_object_dispose__2;
    id v52 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = &v39;
    uint64_t v41 = 0x3812000000;
    uint64_t v42 = __Block_byref_object_copy__2;
    uint64_t v43 = __Block_byref_object_dispose__2;
    id v45 = 0;
    uint64_t v32 = 0;
    uint64_t v33 = &v32;
    uint64_t v34 = 0x3812000000;
    uint64_t v35 = __Block_byref_object_copy__18;
    BOOL v36 = __Block_byref_object_dispose__19;
    id v38 = 0;
    uint64_t v28 = 0;
    int v29 = &v28;
    uint64_t v30 = 0x2020000000;
    char v31 = 0;
    unsigned int v10 = *(NSObject **)(a1 + 32);
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = ___ZN2RB15FunctionLibrary14compile_shaderERNS_6DeviceERKNS_12CustomShader7ClosureENS3_4TypeEPP7NSError_block_invoke;
    block[3] = &unk_2641F8AD0;
    block[8] = a1;
    block[9] = v5;
    void block[4] = &v28;
    block[5] = &v46;
    int v27 = v9;
    block[6] = &v39;
    block[7] = &v32;
    dispatch_sync(v10, block);
    if (v33[6])
    {
      BOOL v11 = 1;
    }
    else
    {
      v53[0] = 0;
      v53[1] = v53;
      v53[2] = 0x8012000000;
      v53[3] = __Block_byref_object_copy__21;
      v53[4] = __Block_byref_object_dispose__22;
      v53[5] = &unk_21422DE11;
      __int16 v55 = 0;
      uint64_t v56 = 0;
      uint64_t v57 = 8;
      long long v58 = xmmword_214219AB0;
      double v12 = a2 + 1;
      uint64_t v13 = a2[14];
      if (a2[13]) {
        double v12 = (void *)a2[13];
      }
      v24[0] = v12;
      v24[1] = v13;
      uint64_t v14 = v25;
      if (v25)
      {
        uint64_t v15 = objc_opt_new();
        [v15 setName:@"custom_fn"];
        if (*((unsigned char *)v29 + 24)) {
          objc_msgSend(v15, "setOptions:", objc_msgSend(v15, "options") | 1);
        }
        float32x2_t v16 = v33;
        uint64_t v17 = [v14 newFunctionWithDescriptor:v15 error:a4];

        v16[6] = v17;
        uint64_t v18 = (void *)v33[6];
        BOOL v11 = v18 != 0;
        if (v18)
        {
          [v18 setLabel:*(void *)(*a2 + 24)];
          uint64_t v19 = *(NSObject **)(a1 + 32);
          v21[0] = MEMORY[0x263EF8330];
          v21[1] = 3221225472;
          int32x2_t v21[2] = ___ZN2RB15FunctionLibrary14compile_shaderERNS_6DeviceERKNS_12CustomShader7ClosureENS3_4TypeEPP7NSError_block_invoke_25;
          float64x2_t v21[3] = &unk_2641F8AF8;
          v21[7] = a1;
          v21[8] = v5;
          int v22 = v9;
          unsigned int v23 = a3;
          v21[4] = &v32;
          v21[5] = v53;
          v21[6] = &v28;
          dispatch_sync(v19, v21);
        }
      }
      else
      {
        BOOL v11 = 0;
      }

      _Block_object_dispose(v53, 8);
      if (v55) {
        free(v55);
      }
    }
    _Block_object_dispose(&v28, 8);
    _Block_object_dispose(&v32, 8);

    _Block_object_dispose(&v39, 8);
    _Block_object_dispose(&v46, 8);
  }
  else if (a4)
  {
    uint64_t v59 = *MEMORY[0x263F08320];
    v60[0] = @"No function name";
    BOOL v11 = 0;
    *a4 = objc_msgSend(MEMORY[0x263F087E8], "errorWithDomain:code:userInfo:", @"com.apple.RenderBox.RBShaderError", 1, objc_msgSend(NSDictionary, "dictionaryWithObjects:forKeys:count:", v60, &v59, 1));
  }
  else
  {
    return 0;
  }
  return v11;
}

void sub_21418B7A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,id a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,id a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,id a57)
{
  _Block_object_dispose((const void *)(v58 - 248), 8);
  uint64_t v60 = *(void **)(v58 - 160);
  if (v60) {
    free(v60);
  }
  _Block_object_dispose(&a33, 8);
  _Block_object_dispose(&a37, 8);

  _Block_object_dispose(&a44, 8);
  _Block_object_dispose(&a51, 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__2(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
}

uint64_t __Block_byref_object_copy__18(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__19(uint64_t a1)
{
}

uint64_t *___ZN2RB15FunctionLibrary14compile_shaderERNS_6DeviceERKNS_12CustomShader7ClosureENS3_4TypeEPP7NSError_block_invoke(uint64_t a1)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = RB::Device::should_compile_binary_functions(*(RB::Device **)(a1 + 64));
  id result = RB::Device::function_library(*(RB::Device **)(a1 + 64), *(RB::CustomShader::Library **)(*(void *)(a1 + 72) + 16));
  if (result)
  {
    int v3 = result;
    *((unsigned char *)result + 112) = 1;
    uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v5 = (void *)result[1];
    id v6 = *(void **)(v4 + 48);
    if (v6 != v5)
    {

      *(void *)(v4 + 48) = v5;
    }
    uint64_t v7 = (void *)RB::Device::library(*(RB::Device **)(a1 + 64));
    uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 8);
    int v9 = *(void **)(v8 + 48);
    if (v9 != v7)
    {

      *(void *)(v8 + 48) = v7;
    }
    id result = RB::UntypedTable::lookup((RB::UntypedTable *)(v3 + 4), (uint64_t *)*(unsigned int *)(a1 + 80), 0);
    if (result)
    {
      unsigned int v10 = result;
      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) || *((unsigned char *)result + 104))
      {
        BOOL v11 = (uint64_t *)result[1];
        uint64_t v12 = *(void *)(*(void *)(a1 + 56) + 8);
        id result = *(uint64_t **)(v12 + 48);
        if (result != v11)
        {

          id result = v11;
          *(void *)(v12 + 48) = result;
        }
      }
      *((unsigned char *)v10 + 105) = 1;
    }
  }
  return result;
}

__n128 __Block_byref_object_copy__21(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 48);
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 48) = v4;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 8;
  uint64_t v5 = *(void *)(a2 + 96);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(void *)(a1 + 96) = v5;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  uint64_t v6 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = v6;
  RB::vector<RB::Rect,2ul,unsigned int>::swap_inline((long long *)(a1 + 56), (long long *)(a2 + 56));
  __n128 result = *(__n128 *)(a2 + 112);
  *(__n128 *)(a1 + 112) = result;
  return result;
}

void sub_21418B9E8(_Unwind_Exception *exception_object)
{
  if (*v1) {
    free(*v1);
  }
  _Unwind_Resume(exception_object);
}

void __Block_byref_object_dispose__22(uint64_t a1)
{
  int v1 = *(void **)(a1 + 88);
  if (v1) {
    free(v1);
  }
}

uint64_t *___ZN2RB15FunctionLibrary14compile_shaderERNS_6DeviceERKNS_12CustomShader7ClosureENS3_4TypeEPP7NSError_block_invoke_25(uint64_t a1)
{
  __n128 result = RB::Device::function_library(*(RB::Device **)(a1 + 56), *(RB::CustomShader::Library **)(*(void *)(a1 + 64) + 16));
  if (result)
  {
    int v3 = result;
    __n128 result = RB::UntypedTable::lookup((RB::UntypedTable *)(result + 4), (uint64_t *)*(unsigned int *)(a1 + 72), 0);
    if (!result) {
      operator new();
    }
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v5 = result[1];
    result[1] = *(void *)(v4 + 48);
    *(void *)(v4 + 48) = v5;
    *((unsigned char *)result + 104) = *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    *((unsigned char *)v3 + 112) = 1;
    *((unsigned char *)result + 105) = 1;
  }
  return result;
}

void sub_21418BBC0(_Unwind_Exception *a1)
{
  if (*v2) {
    free(*v2);
  }

  MEMORY[0x21669AC10](v1, 0x10A0C408BE17B63);
  _Unwind_Resume(a1);
}

uint64_t RB::FunctionLibrary::FunctionLibrary(RB::Device &,RB::CustomShader::Library const&)::$_0::__invoke(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void **)(result + 56);
    if (v2) {
      free(v2);
    }

    JUMPOUT(0x21669AC10);
  }
  return result;
}

void RB::anonymous namespace'::custom_function(void *a1, void *a2, void *a3)
{
  if (![a3 objectForKeyedSubscript:a2])
  {
    uint64_t v6 = (void *)[a1 newFunctionWithName:a2];
    if (!v6)
    {
      uint64_t v7 = [a2 UTF8String];
      RB::precondition_failure((RB *)"invalid custom function: %s", v8, v7);
    }
    [a3 setObject:v6 forKeyedSubscript:a2];
  }
}

void sub_21418BD08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void RB::anonymous namespace'::param_load_layer(void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, unsigned int a5@<W4>, uint64_t a6@<X5>, uint64_t *a7@<X8>)
{
  _OWORD v20[3] = *MEMORY[0x263EF8340];
  uint64_t v14 = objc_opt_new();
  id v15 = objc_alloc(MEMORY[0x263F128D0]);
  float32x2_t v16 = v19;
  v20[0] = a4;
  v20[1] = v19;
  void v20[2] = a6;
  uint64_t v17 = [MEMORY[0x263EFF8C0] arrayWithObjects:v20 count:3];
  uint64_t v18 = [v15 initWithName:fn arguments:v17 controlDependencies:MEMORY[0x263EFFA68]];
  *a7 = v18;
  [a2 addObject:v18];
}

void sub_21418BE38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN2RB12_GLOBAL__N_121make_stitched_libraryERKNS_12CustomShader8FunctionENS1_4TypeERKNSt3__14spanIKNS1_5ValueELm18446744073709551615EEEPU19objcproto9MTLDevice11objc_objectPU21objcproto10MTLLibrary11objc_objectSG_RNS0_12FunctionInfoEPP7NSError_block_invoke(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "addObject:");
}

id __copy_helper_block_e8_32c37_ZTSN2RB8objc_ptrIP14NSMutableArrayEE(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_e8_32c37_ZTSN2RB8objc_ptrIP14NSMutableArrayEE(uint64_t a1)
{
}

void *RB::vector<RB::Function::Param,8ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 6) + (*((void *)__dst + 6) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 6) + (*((void *)__dst + 6) >> 1);
  }
  id result = RB::details::realloc_vector<unsigned long,4ul>(*((void **)__dst + 4), __dst, 8uLL, (size_t *)__dst + 6, v3);
  *((void *)__dst + 4) = result;
  return result;
}

void RB::anonymous namespace'::constant_node(void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, unsigned int a4@<W3>, uint64_t *a5@<X8>)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  {
  }
  uint64_t v28 = 0;
  size_t v29 = 0;
  unint64_t v30 = 8;
  if (!a4)
  {
    size_t v14 = 0;
    uint64_t v8 = 0;
LABEL_16:
    if (!v8) {
      uint64_t v8 = __dst;
    }
    *(_DWORD *)&v8[4 * v14] = 0;
    uint64_t v13 = v14 + 1;
    size_t v29 = v14 + 1;
LABEL_20:
    *a5 = 0;
    if (!v13) {
      goto LABEL_28;
    }
    goto LABEL_21;
  }
  uint64_t v8 = 0;
  size_t v9 = 0;
  do
  {
    size_t v10 = v9 + 1;
    if (v30 < v9 + 1)
    {
      RB::vector<RB::Function::Param,8ul,unsigned long>::reserve_slow(__dst, v10);
      uint64_t v8 = v28;
      size_t v9 = v29;
      size_t v10 = v29 + 1;
    }
    if (v8) {
      BOOL v11 = v8;
    }
    else {
      BOOL v11 = __dst;
    }
    *(_DWORD *)&v11[4 * v9] = a4 & 7;
    size_t v29 = v10;
    size_t v9 = v10;
    BOOL v12 = a4 >= 8;
    a4 >>= 3;
  }
  while (v12);
  if (!v10)
  {
    if (v30)
    {
      size_t v14 = 0;
    }
    else
    {
      RB::vector<RB::Function::Param,8ul,unsigned long>::reserve_slow(__dst, 1uLL);
      uint64_t v8 = v28;
      size_t v14 = v29;
    }
    goto LABEL_16;
  }
  if (v10 != 1)
  {
    uint64_t v13 = v29;
    goto LABEL_20;
  }
  *a5 = 0;
  uint64_t v13 = 1;
LABEL_21:
  id v15 = 0;
  uint64_t v16 = v13 - 1;
  uint64_t v17 = MEMORY[0x263EFFA68];
  do
  {
    uint64_t v18 = v28;
    if (!v28) {
      uint64_t v18 = __dst;
    }
    uint64_t v19 = *(unsigned int *)&v18[4 * v16];
    id v20 = objc_alloc(MEMORY[0x263F128D0]);
    [a2 addObject:v21];
    if (v15)
    {
      id v22 = objc_alloc(MEMORY[0x263F128D0]);
      v26[0] = v15;
      v26[1] = v21;
      uint64_t v23 = objc_msgSend(v22, "initWithName:arguments:controlDependencies:", @"__RB::Cx", objc_msgSend(MEMORY[0x263EFF8C0], "arrayWithObjects:count:", v26, 2), v17);

      *a5 = v23;
      [a2 addObject:v23];
      id v15 = (void *)v23;
    }
    else
    {

      *a5 = (uint64_t)v21;
      id v15 = v21;
      int v21 = 0;
    }

    --v16;
  }
  while (v16 != -1);
LABEL_28:
  if (v28) {
    free(v28);
  }
}

void sub_21418C230(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
}

void *RB::anonymous namespace'::param_load_fn(void *a1, void *a2, unsigned int a3)
{
  {
    unsigned int v8 = a3;
    a3 = v8;
    if (v7)
    {
      a3 = v8;
    }
  }
  return v5;
}

void sub_21418C38C(_Unwind_Exception *a1)
{
}

void RB::anonymous namespace'::diagnose_parameter_error(RB::_anonymous_namespace_ *this, NSMutableString *a2, NSArray *a3, int *a4, const RB::Function::Param *a5)
{
  uint64_t v54 = this;
  if ([(NSMutableString *)a2 count] <= (unint64_t)a3)
  {
    int v28 = *a4;
    if ((*a4 & 0x3Fu) > 8) {
      size_t v29 = "unknown";
    }
    else {
    if ((v28 & 0x40) != 0) {
      unint64_t v30 = " pointer";
    }
    else {
      unint64_t v30 = "";
    }
    -[RB::_anonymous_namespace_ appendFormat:](this, "appendFormat:", @"Missing parameter at index %d: %@.\n", a3, objc_msgSend(NSString, "stringWithFormat:", @"%s%s", v29, v30));
  }
  else
  {
    size_t v9 = objc_msgSend((id)-[NSMutableString objectAtIndexedSubscript:](a2, "objectAtIndexedSubscript:", a3), "dataTypeDescription");
    if (!v9) {
      return;
    }
    size_t v10 = v9;
    BOOL v11 = (RB::_anonymous_namespace_ *)[v9 dataType];
    v53[0] = &v54;
    v53[1] = a3;
    if (v11 == (RB::_anonymous_namespace_ *)1)
    {
      if ((*(unsigned char *)a4 & 0x40) != 0) {
      uint64_t v31 = (void *)[v10 members];
      }
      if ([v31 count] != 2
        || (id v38 = (void *)[v31 objectAtIndexedSubscript:0],
            uint64_t v39 = (void *)[v31 objectAtIndexedSubscript:1],
            [v38 dataType] != 58)
        || [v39 dataType] != 2
        || (uint64_t v40 = (void *)[v38 textureReferenceType],
            uint64_t v41 = (void *)[v39 arrayType],
            [v40 textureDataType] != 16)
        || [v40 textureType] != 2
        || [v40 access]
        || ([v40 isDepthTexture] & 1) != 0
        || [v41 elementType] != 137
        || [v41 arrayLength] != 5
        || (*a4 & 0x3F) == 3)
      {
        uint64_t v42 = "unsupported struct type";
LABEL_44:
        return;
      }
      if ((*a4 & 0x3Fu) > 8) {
        unsigned int v51 = "unknown";
      }
      else {
    }
      }
    else
    {
      char v18 = (char)v11;
      if (v11 == (RB::_anonymous_namespace_ *)60)
      {
        if ((*(unsigned char *)a4 & 0x40) == 0) {
        if ((v19 & 0xFF00000000) != 0)
        }
        {
          int v26 = v19;
          if ((*a4 & 0x3F) != v19)
          {
            if (v19 > 8) {
              int v27 = "unknown";
            }
            else {
          }
            }
          if ([v10 alignment] > (unint64_t)RB::Function::Param::alignment_values[v26]) {
          if ([v10 access])
          }
          {
            uint64_t v42 = "pointer access must be read-only";
            goto LABEL_44;
          }
        }
      }
      else
      {
        if ((v43 & 0xFF00000000) == 0)
        {
          return;
        }
        if ((*a4 & 0x3F) != v43)
        {
          if (v43 > 8) {
            unsigned int v44 = "unknown";
          }
          else {
          char v52 = (char)v44;
          }
          uint64_t v42 = "invalid type, %s, expected %s";
          goto LABEL_44;
        }
      }
    }
  }
}

void RB::anonymous namespace'::diagnose_parameter_error(NSMutableString *,NSArray *,unsigned long,RB::Function::Param const&)::$_0::operator()(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  v10[0] = 0;
  v10[1] = &a9;
  vasprintf(v10, a2, &a9);
  if (v10[0])
  {
    objc_msgSend(**(id **)a1, "appendFormat:", @"Parameter at index %d: %s.\n", *(void *)(a1 + 8), v10[0]);
    free(v10[0]);
  }
}

uint64_t RB::anonymous namespace'::param_type(RB::_anonymous_namespace_ *this, MTLDataType a2)
{
  if ((uint64_t)this <= 18)
  {
    switch((unint64_t)this)
    {
      case 3uLL:
        uint64_t v2 = 0x100000000;
        uint64_t v3 = 5;
        break;
      case 4uLL:
        uint64_t v2 = 0x100000000;
        uint64_t v3 = 6;
        break;
      case 5uLL:
        uint64_t v2 = 0x100000000;
        uint64_t v3 = 7;
        break;
      case 6uLL:
        uint64_t v2 = 0x100000000;
        uint64_t v3 = 8;
        break;
      default:
        goto LABEL_18;
    }
    return v3 | v2;
  }
  if ((uint64_t)this <= 57)
  {
    if (this == (RB::_anonymous_namespace_ *)19)
    {
      uint64_t v2 = 0x100000000;
      uint64_t v3 = 2;
      return v3 | v2;
    }
    if (this == (RB::_anonymous_namespace_ *)29)
    {
      uint64_t v2 = 0x100000000;
      uint64_t v3 = 1;
      return v3 | v2;
    }
LABEL_18:
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    return v3 | v2;
  }
  if (this == (RB::_anonymous_namespace_ *)58)
  {
    uint64_t v2 = 0x100000000;
    uint64_t v3 = 4;
    return v3 | v2;
  }
  if (this != (RB::_anonymous_namespace_ *)61) {
    goto LABEL_18;
  }
  uint64_t v3 = 0;
  uint64_t v2 = 0x100000000;
  if (!a2) {
    uint64_t v2 = 0;
  }
  return v3 | v2;
}

BOOL RB::Table<unsigned long,RB::Function *>::remove_if<RB::FunctionLibrary::prune_caches(unsigned int)::$_0>(RB::FunctionLibrary::prune_caches(unsigned int)::$_0)::{lambda(void const*,void const*,void *)#1}::__invoke(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  return a2 && !*(unsigned char *)(a2 + 105) && *(_DWORD *)(a2 + 96) <= *a3;
}

void RB::Coverage::Path::map(uint64_t a1, void (***a2)(void), float64x2_t *a3)
{
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4 != &empty_path_callbacks)
  {
    uint64_t v6 = *(float64x2_t **)(a1 + 16);
    if (v6)
    {
      v7.f64[0] = RB::operator*(v6, a3);
      v11[0] = v7;
      v11[1] = v8;
      float64x2_t v11[2] = v9;
      RBPathMap(*(CGPathRef *)a1, *(void **)(a1 + 8), a2, v11);
    }
    else
    {
      size_t v10 = *(const CGPath **)a1;
      RBPathMap(v10, v4, a2, a3);
    }
  }
}

float RB::Coverage::Path::min_scale(RB::Coverage::Path *this, const RB::AffineTransform *a2)
{
  float result = 0.0;
  if (*((unsigned char *)this + 29) == 1) {
    return 1.0;
  }
  return result;
}

uint64_t RB::Coverage::Path::can_mix(float64x2_t **this, const RB::DisplayList::Interpolator::Op *a2, float64x2_t **a3)
{
  if (*((unsigned __int8 *)this + 28) != *((unsigned __int8 *)a3 + 28)
    || *((unsigned __int8 *)this + 29) != *((unsigned __int8 *)a3 + 29))
  {
    return 0;
  }
  unsigned __int8 can_mix = RB::can_mix(this[2], a3[2], (const RB::AffineTransform *)a3);
  if (can_mix)
  {
    unsigned __int8 v6 = can_mix;
    unsigned int CanMix = RBPathCanMix(*(RBPath *)this, *(RBPath *)a3);
    if (CanMix >= v6) {
      uint64_t result = v6;
    }
    else {
      uint64_t result = CanMix;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  if (*((float *)this + 6) != *((float *)a3 + 6))
  {
    if (result >= 2) {
      return 2;
    }
    else {
      return result;
    }
  }
  return result;
}

float RB::Coverage::Path::mix(RBPath *this, const RB::DisplayList::Interpolator::State *a2, RBPath *a3, float64x2_t *a4, float64x2_t *a5, float64x2_t *a6, RB::Heap *a7)
{
  uint64_t v14 = (const RB::AffineTransform ***)&this[1];
  info = (float64x2_t *)this[1].info;
  if (info)
  {
    v15.f64[0] = RB::operator*(a4, info);
    float64x2_t v39 = v15;
    float64x2_t v40 = v16;
    float64x2_t v41 = v17;
  }
  else
  {
    float64x2_t v18 = a4[1];
    float64x2_t v39 = *a4;
    float64x2_t v40 = v18;
    float64x2_t v41 = a4[2];
  }
  uint64_t v19 = (float64x2_t *)a3[1].info;
  if (v19)
  {
    v20.f64[0] = RB::operator*(a5, v19);
    float64x2_t v36 = v20;
    float64x2_t v37 = v21;
    float64x2_t v38 = v22;
    uint64_t v23 = (const RB::AffineTransform **)a3[1].info;
  }
  else
  {
    uint64_t v23 = 0;
    float64x2_t v24 = a5[1];
    float64x2_t v36 = *a5;
    float64x2_t v37 = v24;
    float64x2_t v20 = a5[2];
    float64x2_t v38 = v20;
  }
  LODWORD(v20.f64[0]) = *((_DWORD *)a2 + 4);
  RB::mix(a7, v14, v23, (const RB::AffineTransform *)a4, v20.f64[0]);
  if (*v14)
  {
    v25.f64[0] = RB::operator*(a6, (float64x2_t *)*v14);
    float64x2_t v33 = v25;
    float64x2_t v34 = v26;
    float64x2_t v35 = v27;
  }
  else
  {
    float64x2_t v28 = a6[1];
    float64x2_t v33 = *a6;
    float64x2_t v34 = v28;
    float64x2_t v35 = a6[2];
  }
  RBPathMix(*this, *a3, *((float *)a2 + 4), &v39, &v36, &v33, &v32);
  uint64_t v29 = (uint64_t)this->info;
  uint64_t callbacks = (uint64_t)this->callbacks;
  *this = v32;
  v32.info = (void *)v29;
  v32.uint64_t callbacks = (RBPathCallbacks *)callbacks;
  RBPathRelease(v29, callbacks);
  float result = *(float *)&this[1].callbacks
         + (float)((float)(*(float *)&a3[1].callbacks - *(float *)&this[1].callbacks) * *((float *)a2 + 4));
  *(float *)&this[1].uint64_t callbacks = result;
  return result;
}

void RB::Coverage::Path::clip(RB::Coverage::Path *this, CGContextRef *a2)
{
  float64x2_t v4 = 0uLL;
  memset(&v16, 0, sizeof(v16));
  uint64_t v5 = (float64x2_t *)*((void *)this + 2);
  float64x2_t v6 = (float64x2_t)xmmword_2142181D0;
  float64x2_t v7 = (float64x2_t)xmmword_2142181C0;
  if (v5)
  {
    float64x2_t v7 = *v5;
    float64x2_t v6 = v5[1];
    float64x2_t v4 = v5[2];
  }
  int64x2_t v8 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v6, (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqzq_f64(v4)), (int8x16_t)vceqq_f64(v7, (float64x2_t)xmmword_2142181C0));
  unint64_t v9 = vandq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), (int8x16_t)v8).u64[0];
  if ((v9 & 0x8000000000000000) == 0)
  {
    *(float64x2_t *)&v15.c = v6;
    *(float64x2_t *)&v15.tx = v4;
    *(float64x2_t *)&v15.a = v7;
    CGContextGetCTM(&v16, *a2);
    size_t v10 = *a2;
    CGAffineTransform transform = v15;
    CGContextConcatCTM(v10, &transform);
  }
  int v11 = rb_clip_mode(*((unsigned __int8 *)this + 29));
  if (*((unsigned __int8 *)a2 + 140) != v11) {
    RB::CGContext::set_aliasing_mode_slow((uint64_t)a2, v11);
  }
  CGContextBeginPath(*a2);
  uint64_t v12 = RBPathCopyCGPath(*(const CGPath **)this, *((void *)this + 1));
  if (v12)
  {
    uint64_t v13 = v12;
    CGContextAddPath(*a2, v12);
    CFRelease(v13);
  }
  uint64_t v14 = *a2;
  if (*((unsigned char *)this + 28))
  {
    CGContextEOClip(v14);
    if ((v9 & 0x8000000000000000) != 0) {
      return;
    }
  }
  else
  {
    CGContextClip(v14);
    if ((v9 & 0x8000000000000000) != 0) {
      return;
    }
  }
  CGAffineTransform transform = v16;
  CGContextSetCTM();
}

void sub_21418CC80(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void *RB::Coverage::Path::encode(RBPath *this, RB::Encoder *a2)
{
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RBPathEncode(*this, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  info = (float64x2_t *)this[1].info;
  if (info)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(info[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*info, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(info[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::AffineTransform::encode(info->f64, a2);
      RB::ProtobufEncoder::end_length_delimited(a2);
    }
  }
  if (BYTE4(this[1].callbacks) == 1)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
    RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  unint64_t v6 = BYTE5(this[1].callbacks);
  RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
  float result = RB::ProtobufEncoder::encode_varint(a2, v6);
  int callbacks = (int)this[1].callbacks;
  if (*(float *)&callbacks != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x2DuLL);
    return RB::ProtobufEncoder::encode_fixed32(a2, callbacks);
  }
  return result;
}

unint64_t RB::Coverage::Path::decode(RB::Coverage::Path *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            RBPathDecode(a2);
          }
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
          break;
        case 2u:
          RB::Decoder::affine_transform_field((size_t **)a2, v5);
          *((void *)this + 2) = v6;
          break;
        case 3u:
          *((unsigned char *)this + 28) = RB::ProtobufDecoder::BOOL_field(a2, v5);
          break;
        case 4u:
          unint64_t v7 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, v5);
          if (v7 <= 3) {
            *((unsigned char *)this + 29) = v7;
          }
          break;
        case 5u:
          *((float *)this + 6) = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        default:
          RB::ProtobufDecoder::skip_field(a2, v5);
          break;
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::Coverage::Path::attributes(RB::Coverage::Path *this, RB::XML::Element *a2)
{
}

void sub_21418D04C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

uint64_t *RB::DisplayList::Contents::prepare_encode(RB::DisplayList::Contents *this, RB::Encoder *a2)
{
  return RB::DisplayList::Layer::prepare_encode((uint64_t *)this + 40, a2);
}

uint64_t *RB::DisplayList::Layer::prepare_encode(uint64_t *this, RB::Encoder *a2)
{
  uint64_t v3 = this;
  float64x2_t v4 = (void *)*this;
  if (*this)
  {
    do
    {
      this = (uint64_t *)(*(uint64_t (**)(void *, RB::Encoder *))(*v4 + 240))(v4, a2);
      float64x2_t v4 = (void *)v4[1];
    }
    while (v4);
  }
  for (uint64_t i = (RB::DisplayList::LayerFilter *)v3[2]; i; uint64_t i = (RB::DisplayList::LayerFilter *)*((void *)i + 1))
    this = RB::DisplayList::LayerFilter::prepare_encode(i, a2);
  return this;
}

void RB::DisplayList::Contents::encode(RB::DisplayList::Contents *this, void (****a2)(CFDataRef *__return_ptr))
{
  void (***v5)(CFDataRef *__return_ptr);
  const UInt8 *BytePtr;
  CFIndex Length;
  CFDataRef theData;

  float64x2_t v4 = RB::Encoder::local_namespace(this);
  RB::ProtobufEncoder::uuid_field((RB::ProtobufEncoder *)a2, 4, (const UUID *)v4);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::DisplayList::Layer::encode((void **)this + 40, (RB::Encoder *)a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  unint64_t v5 = a2[7];
  if (v5)
  {
    (**v5)(&theData);
    if (theData)
    {
      BytePtr = CFDataGetBytePtr(theData);
      CFIndex Length = CFDataGetLength(theData);
      if (Length)
      {
        RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
        RB::ProtobufEncoder::encode_data((RB::ProtobufEncoder *)a2, BytePtr, Length);
      }
      if (theData) {
        CFRelease(theData);
      }
    }
  }
  if (!*((unsigned char *)this + 400))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
    RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
}

void sub_21418D1F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

unint64_t RB::DisplayList::Contents::decode(RB::DisplayList::Contents *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            RB::DisplayList::Layer::decode((RB::DisplayList::Contents *)((char *)this + 320), (RB::Heap **)a2);
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
            *((unsigned char *)a2 + 56) = 1;
            *(void *)a2 = *((void *)a2 + 1);
          }
          break;
        case 2u:
          goto LABEL_10;
        case 3u:
          uint64_t v6 = (void (***)(void, uint64_t, uint64_t))*((void *)a2 + 9);
          if (!v6) {
            goto LABEL_10;
          }
          uint64_t v7 = RB::ProtobufDecoder::data_field(a2, v5);
          (**v6)(v6, v7, v8);
          break;
        case 4u:
          RB::ProtobufDecoder::uuid_field(a2, v5, (_OWORD *)a2 + 13);
          break;
        case 5u:
          *((unsigned char *)this + 400) = RB::ProtobufDecoder::uint_field((uint64_t **)a2, v5) == 0;
          break;
        default:
          if ((v5 >> 3) == 15) {
            RB::Decoder::push_shared((char *)a2, v5);
          }
          else {
LABEL_10:
          }
            RB::ProtobufDecoder::skip_field(a2, v5);
          break;
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

uint64_t *RB::DisplayList::LayerFilter::prepare_encode(RB::DisplayList::LayerFilter *this, RB::Encoder *a2)
{
  unint64_t result = (uint64_t *)(*(uint64_t (**)(RB::DisplayList::LayerFilter *))(*(void *)this + 40))(this);
  if (result == 4)
  {
    return RB::Filter::Custom::prepare_encode(v4, a2);
  }
  else if (result == 5)
  {
    return (uint64_t *)RB::Filter::GaussianBlur::prepare_encode((uint64_t)v4);
  }
  return result;
}

void **RB::DisplayList::Layer::encode(void **this, RB::Encoder *a2)
{
  uint64_t v3 = this;
  for (uint64_t i = *this; i; uint64_t i = (void *)i[1])
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    (*(void (**)(void *, RB::Encoder *))(*i + 248))(i, a2);
    this = (void **)RB::ProtobufEncoder::end_length_delimited(a2);
  }
  for (j = (RB::DisplayList::LayerFilter *)v3[2]; j; j = (RB::DisplayList::LayerFilter *)*((void *)j + 1))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::DisplayList::LayerFilter::encode(j, a2);
    this = (void **)RB::ProtobufEncoder::end_length_delimited(a2);
  }
  if (*((unsigned char *)v3 + 64))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    int v6 = *((unsigned __int8 *)v3 + 64);
    if (v6 == 2)
    {
      int v8 = (*(uint64_t (**)(void *))(*v3[3] + 152))(v3[3]);
      unint64_t v9 = v3[3];
      RB::ProtobufEncoder::encode_varint(a2, (8 * v8) | 2);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      (*(void (**)(void *, RB::Encoder *))(*v9 + 168))(v9, a2);
    }
    else
    {
      if (v6 != 1)
      {
LABEL_11:
        this = (void **)RB::ProtobufEncoder::end_length_delimited(a2);
        goto LABEL_12;
      }
      uint64_t v7 = v3[3];
      RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::ProjectionMatrix::encode(v7, a2);
    }
    RB::ProtobufEncoder::end_length_delimited(a2);
    goto LABEL_11;
  }
LABEL_12:
  int v10 = *((int *)v3 + 12);
  if (*(float *)&v10 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x25uLL);
    this = (void **)RB::ProtobufEncoder::encode_fixed32(a2, v10);
  }
  int v11 = *((_DWORD *)v3 + 15);
  if (v11)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
    this = (void **)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    int v11 = *((_DWORD *)v3 + 15);
    if ((v11 & 2) == 0)
    {
LABEL_16:
      if ((v11 & 4) == 0) {
        goto LABEL_17;
      }
      goto LABEL_24;
    }
  }
  else if ((v11 & 2) == 0)
  {
    goto LABEL_16;
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x30uLL);
  this = (void **)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  int v11 = *((_DWORD *)v3 + 15);
  if ((v11 & 4) == 0)
  {
LABEL_17:
    if ((v11 & 8) == 0) {
      goto LABEL_18;
    }
    goto LABEL_25;
  }
LABEL_24:
  RB::ProtobufEncoder::encode_varint(a2, 0x38uLL);
  this = (void **)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  int v11 = *((_DWORD *)v3 + 15);
  if ((v11 & 8) == 0)
  {
LABEL_18:
    if ((v11 & 0x40) == 0) {
      goto LABEL_19;
    }
    goto LABEL_26;
  }
LABEL_25:
  RB::ProtobufEncoder::encode_varint(a2, 0x40uLL);
  this = (void **)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  int v11 = *((_DWORD *)v3 + 15);
  if ((v11 & 0x40) == 0)
  {
LABEL_19:
    if ((v11 & 0x200) == 0) {
      goto LABEL_20;
    }
LABEL_27:
    RB::ProtobufEncoder::encode_varint(a2, 0x50uLL);
    this = (void **)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    if ((*((_DWORD *)v3 + 15) & 0x800) == 0) {
      return this;
    }
    goto LABEL_28;
  }
LABEL_26:
  RB::ProtobufEncoder::encode_varint(a2, 0x48uLL);
  this = (void **)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  int v11 = *((_DWORD *)v3 + 15);
  if ((v11 & 0x200) != 0) {
    goto LABEL_27;
  }
LABEL_20:
  if ((v11 & 0x800) == 0) {
    return this;
  }
LABEL_28:
  RB::ProtobufEncoder::encode_varint(a2, 0x58uLL);
  return (void **)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
}

unint64_t RB::DisplayList::Layer::decode(RB::DisplayList::Layer *this, RB::Heap **a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          if ((v5 & 7) != 2) {
            goto LABEL_60;
          }
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          uint64_t v7 = (RB::DisplayList::Item *)RB::DisplayList::Item::decode((size_t **)a2, v6);
          if (v7) {
            RB::DisplayList::Layer::append_item(this, v7);
          }
          goto LABEL_36;
        case 2u:
          if ((v5 & 7) != 2) {
            goto LABEL_60;
          }
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          uint64_t v9 = RB::DisplayList::LayerFilter::decode(a2, v8);
          if (v9) {
            RB::DisplayList::Layer::append_filter((uint64_t)this, v9);
          }
          goto LABEL_36;
        case 3u:
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
            uint64_t field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
            if (field)
            {
              unint64_t v11 = field;
              do
              {
                switch((v11 >> 3))
                {
                  case 1u:
                    RB::Heap::emplace<RB::ProjectionMatrix>(a2[8]);
                    uint64_t v13 = v12;
                    if ((v11 & 7) == 2)
                    {
                      RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
                      RB::ProjectionMatrix::decode(v13, (RB::ProtobufDecoder *)a2);
                      RB::ProtobufDecoder::end_message((uint64_t)a2);
                    }
                    else
                    {
                      *((unsigned char *)a2 + 56) = 1;
                      *a2 = a2[1];
                    }
                    *((unsigned char *)this + 64) = 1;
                    goto LABEL_24;
                  case 2u:
                    RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>>(a2[8]);
                    uint64_t v13 = v14;
                    if ((v11 & 7) != 2) {
                      goto LABEL_33;
                    }
                    RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
                    RB::AlphaThresholdEffect::decode((RB::AlphaThresholdEffect *)(v13 + 16), (RB::Decoder *)a2);
                    goto LABEL_22;
                  case 3u:
                    RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>>(a2[8]);
                    uint64_t v13 = v15;
                    if ((v11 & 7) == 2)
                    {
                      RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
                      RB::AlphaGradientEffect::decode((RB::AlphaGradientEffect *)(v13 + 16), (RB::Decoder *)a2);
LABEL_22:
                      RB::ProtobufDecoder::end_message((uint64_t)a2);
                    }
                    else
                    {
LABEL_33:
                      *((unsigned char *)a2 + 56) = 1;
                      *a2 = a2[1];
                    }
                    *((unsigned char *)this + 64) = 2;
LABEL_24:
                    *((void *)this + 3) = v13;
                    break;
                  case 4u:
                    CGAffineTransform v16 = a2[9];
                    if (!v16) {
                      goto LABEL_30;
                    }
                    uint64_t v17 = (*(uint64_t (**)(RB::Heap *))(*(void *)v16 + 32))(v16);
                    if (!v17) {
                      goto LABEL_30;
                    }
                    uint64_t v18 = v17;
                    RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::CustomEffect>>(a2[8]);
                    uint64_t v20 = v19;
                    if ((v11 & 7) == 2)
                    {
                      RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
                      RB::CustomEffect::decode((RB::DisplayList::Layer **)(v20 + 16), (size_t **)a2);
                      RB::ProtobufDecoder::end_message((uint64_t)a2);
                    }
                    else
                    {
                      *((unsigned char *)a2 + 56) = 1;
                      *a2 = a2[1];
                    }
                    *((unsigned char *)this + 64) = 2;
                    *((void *)this + 3) = v20;
                    *(void *)(v20 + 8) = *(void *)(v18 + 312);
                    *(void *)(v18 + 312) = v20;
                    break;
                  default:
LABEL_30:
                    RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, v11);
                    break;
                }
                unint64_t v11 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
              }
              while (v11);
            }
LABEL_36:
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
LABEL_60:
            *((unsigned char *)a2 + 56) = 1;
            *a2 = a2[1];
          }
          break;
        case 4u:
          *((float *)this + 12) = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a2, v5);
          break;
        case 5u:
          int v21 = *((_DWORD *)this + 15) | RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v5);
          goto LABEL_57;
        case 6u:
          if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v5)) {
            int v22 = 2;
          }
          else {
            int v22 = 0;
          }
          goto LABEL_56;
        case 7u:
          BOOL v23 = RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v5) == 0;
          int v22 = 4;
          goto LABEL_44;
        case 8u:
          BOOL v23 = RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v5) == 0;
          int v22 = 8;
LABEL_44:
          if (v23) {
            int v22 = 0;
          }
          goto LABEL_56;
        case 9u:
          if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v5)) {
            int v22 = 64;
          }
          else {
            int v22 = 0;
          }
          goto LABEL_56;
        case 0xAu:
          if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v5)) {
            int v22 = 512;
          }
          else {
            int v22 = 0;
          }
          goto LABEL_56;
        case 0xBu:
          if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v5)) {
            int v22 = 2048;
          }
          else {
            int v22 = 0;
          }
LABEL_56:
          int v21 = *((_DWORD *)this + 15) | v22;
LABEL_57:
          *((_DWORD *)this + 15) = v21;
          break;
        default:
          RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, v5);
          break;
      }
      unint64_t result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

uint64_t *RB::DisplayList::Item::prepare_encode(uint64_t *this, RB::Encoder *a2)
{
  uint64_t v3 = (uint64_t)this;
  float64x2_t v4 = (void *)this[3];
  if (v4)
  {
    do
    {
      unint64_t v5 = v4[1] & 0xFFFFFFFFFFFFFFFELL;
      if (v5) {
        (*(void (**)(unint64_t, RB::Encoder *))(*(void *)v5 + 112))(v5, a2);
      }
      float64x2_t v4 = (void *)*v4;
    }
    while (v4);
    uint64_t v9 = *(void **)(v3 + 24);
    this = RB::Encoder::prepare_shared_f<void RB::Encoder::prepare_shared<RB::DisplayList::ClipNode>(RB::Encoder::SharedType,RB::DisplayList::ClipNode const&)::{lambda(RB::DisplayList::ClipNode&)#1}>((uint64_t *)a2, 4, (uint64_t *)v9, (void **)&v9);
  }
  int v6 = *(void **)(v3 + 16);
  if (v6)
  {
    do
    {
      this = (uint64_t *)(*(uint64_t (**)(void *, RB::Encoder *))(*v6 + 96))(v6, a2);
      int v6 = (void *)v6[4];
    }
    while (v6);
    if ((*((unsigned char *)a2 + 164) & 1) == 0)
    {
      uint64_t v7 = *(uint64_t **)(v3 + 16);
      uint64_t v9 = 0;
      this = RB::UntypedTable::lookup((RB::Encoder *)((char *)a2 + 80), v7, &v9);
      if (v9 != v7)
      {
        int v8 = (size_t *)*((void *)a2 + 9);
        *((void *)a2 + 9) = (char *)v8 + 1;
        RB::UntypedTable::insert((size_t **)a2 + 10, (size_t *)v7, v8);
        RB::ProtobufEncoder::encode_varint(a2, 0x7AuLL);
        RB::ProtobufEncoder::begin_length_delimited(a2);
        if (v8)
        {
          RB::ProtobufEncoder::encode_varint(a2, 8uLL);
          RB::ProtobufEncoder::encode_varint(a2, (unint64_t)v8);
        }
        RB::ProtobufEncoder::encode_varint(a2, 0x2AuLL);
        RB::ProtobufEncoder::begin_length_delimited(a2);
        for (; v7; uint64_t v7 = (uint64_t *)v7[4])
        {
          RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
          RB::ProtobufEncoder::begin_length_delimited(a2);
          (*(void (**)(uint64_t *, RB::Encoder *))(*v7 + 104))(v7, a2);
          RB::ProtobufEncoder::end_length_delimited(a2);
        }
        RB::ProtobufEncoder::end_length_delimited(a2);
        return RB::ProtobufEncoder::end_length_delimited(a2);
      }
    }
  }
  return this;
}

unint64_t RB::DisplayList::ClipNode::prepare_encode(unint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = (void *)result;
    do
    {
      unint64_t result = v3[1] & 0xFFFFFFFFFFFFFFFELL;
      if (result) {
        unint64_t result = (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)result + 112))(result, a2);
      }
      uint64_t v3 = (void *)*v3;
    }
    while (v3);
  }
  return result;
}

void *RB::DisplayList::Item::encode(RB::DisplayList::Item *this, RB::Encoder *a2)
{
  _H0 = *((short float *)this + 22);
  if (_H0 != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
  {
    __asm { FCVT            S8, H0 }
    RB::ProtobufEncoder::encode_varint(a2, 0x25uLL);
    RB::ProtobufEncoder::encode_fixed32(a2, _S8);
  }
  unint64_t result = (void *)rb_blend_mode(*((_WORD *)this + 23) & 0x3F);
  if (result)
  {
    int v11 = (int)result;
    RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
    unint64_t result = RB::ProtobufEncoder::encode_varint(a2, v11);
  }
  uint64_t v12 = (uint64_t *)*((void *)this + 3);
  if (v12) {
    unint64_t result = RB::Encoder::shared_field_f(a2, 6, v12);
  }
  if (*((void *)this + 4) || *((_DWORD *)this + 10))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x3AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::DisplayList::encode_metadata(a2, *((RB::Encoder **)this + 4), (const RB::DisplayList::Metadata *)*((unsigned int *)this + 10), 0);
    unint64_t result = RB::ProtobufEncoder::end_length_delimited(a2);
  }
  uint64_t v13 = (uint64_t *)*((void *)this + 2);
  if (v13)
  {
    return RB::Encoder::shared_field_f(a2, 8, v13);
  }
  return result;
}

void (***RB::DisplayList::Item::decode(size_t **this, RB::Decoder *a2))(void)
{
  uint64_t v3 = 0;
  float64x2_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v47 = *MEMORY[0x263EF8340];
  memset(v44, 0, sizeof(v44));
  int v6 = (RB::UntypedTable *)(this + 10);
  _S8 = 1.0;
  char v8 = 2;
  while (1)
  {
    uint64_t v9 = v3;
    unint64_t field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
    uint64_t v11 = field;
    if (!field) {
      break;
    }
    switch((field >> 3))
    {
      case 1u:
        uint64_t v12 = RB::AffineTransform::identity((RB::AffineTransform *)field);
        v46.type = 0;
        v45.type = 0;
        if ((v11 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          unint64_t v17 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
          if (!v17)
          {
LABEL_52:
            RB::ProtobufDecoder::end_message((uint64_t)this);
            goto LABEL_53;
          }
          while (2)
          {
            unint64_t v18 = v17 >> 3;
            if ((v17 >> 3) == 3)
            {
              RB::Decoder::affine_transform_field(this, v17);
              uint64_t v12 = v19;
            }
            else if (v18 == 2)
            {
              if ((v17 & 7) != 2) {
                goto LABEL_18;
              }
              RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
              RBFillData::decode(&v45, (RB::Heap **)this);
LABEL_14:
              RB::ProtobufDecoder::end_message((uint64_t)this);
            }
            else if (v18 == 1)
            {
              if ((v17 & 7) == 2)
              {
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RBShapeData::decode(&v46, (RB::Decoder *)this);
                goto LABEL_14;
              }
LABEL_18:
              *((unsigned char *)this + 56) = 1;
              *this = this[1];
            }
            else
            {
              RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v17);
            }
            unint64_t v17 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
            if (!v17) {
              goto LABEL_52;
            }
            continue;
          }
        }
        *((unsigned char *)this + 56) = 1;
        *this = this[1];
LABEL_53:
        v38[0] = this[8];
        v38[1] = v12;
        v38[2] = 0x23F800000;
        __int16 v39 = 0;
        float64x2_t v40 = &v45;
        uint64_t v41 = 0;
        char v42 = 0;
        uint64_t v43 = 0;
        RBShapeData::apply<RB::DisplayList::ItemFactory>((float32x2_t *)&v46, (uint64_t)v38, v13, v14, v15, v16);
        uint64_t v3 = v43;
        if (v9) {
          (**v9)(v9);
        }
        RBFillData::~RBFillData(&v45);
        RBShapeData::~RBShapeData(&v46);
        break;
      case 2u:
        v46.type = 1;
        LODWORD(v38[0]) = 2;
        *(void *)&v45.type = 0;
        RB::Heap::emplace<RB::DisplayList::LayerItem,int,RB::BlendMode,decltype(nullptr)>(this[8], &v46.type, (int *)v38);
        uint64_t v3 = v20;
        if ((v11 & 7) != 2) {
          goto LABEL_60;
        }
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        RB::DisplayList::LayerItem::decode((RB::DisplayList::LayerItem *)v3, this);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        goto LABEL_24;
      case 3u:
        RB::Heap::emplace<RB::DisplayList::BackdropColorMatrixItem>((RB::Heap *)this[8]);
        uint64_t v3 = v21;
        if ((v11 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::DisplayList::BackdropColorMatrixItem::decode((RB::DisplayList::BackdropColorMatrixItem *)v3, this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
LABEL_24:
          if (v9)
          {
LABEL_25:
            (**v9)(v9);
            continue;
          }
        }
        else
        {
LABEL_60:
          *((unsigned char *)this + 56) = 1;
          *this = this[1];
          if (v9) {
            goto LABEL_25;
          }
        }
        continue;
      case 4u:
        _S8 = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)this, field);
        continue;
      case 5u:
        unsigned int v22 = RB::ProtobufDecoder::uint_field((uint64_t **)this, field);
        char v8 = rb_blend_mode(v22);
        continue;
      case 6u:
        uint64_t v5 = RB::Decoder::shared_field_f<RB::DisplayList::ClipNode,RB::DisplayList::ClipNode const* RB::Decoder::shared_field<RB::DisplayList::ClipNode>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType)::{lambda(RB::DisplayList::ClipNode&)#1}>((RB::ProtobufDecoder *)this, field, 4, (uint64_t)&v45);
        continue;
      case 7u:
        BOOL v23 = this[9];
        if (v23 && (float64x2_t v24 = (size_t *)(*(uint64_t (**)(size_t *))(*v23 + 32))(v23)) != 0)
        {
          if ((v11 & 7) != 2) {
            goto LABEL_59;
          }
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::DisplayList::decode_metadata((RB::DisplayList *)this, v24, (RB::DisplayList::Contents *)&v44[4], (const RB::DisplayList::Metadata **)v44, v25);
          RB::ProtobufDecoder::end_message((uint64_t)this);
          uint64_t v3 = v9;
        }
        else
        {
          RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v11);
          uint64_t v3 = v9;
        }
        continue;
      case 8u:
        if ((field & 7) != 2) {
          goto LABEL_58;
        }
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        unint64_t v26 = 0;
        unint64_t v27 = 0;
        unint64_t v28 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
        if (v28)
        {
          do
          {
            if ((v28 >> 3) == 2)
            {
              long long v37 = *(_OWORD *)this;
              RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v28);
              unint64_t v27 = v28;
            }
            else if ((v28 >> 3) == 1)
            {
              unint64_t v26 = RB::ProtobufDecoder::uint_field((uint64_t **)this, v28);
            }
            else
            {
              RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v28);
            }
            unint64_t v28 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
          }
          while (v28);
          if (v26 >> 61)
          {
            RB::ProtobufDecoder::end_message((uint64_t)this);
            goto LABEL_58;
          }
        }
        *(void *)&v45.type = 0;
        float64x2_t v4 = RB::UntypedTable::lookup(v6, (uint64_t *)(v26 | 0xA000000000000000), (void **)&v45);
        long long v29 = v37;
        if ((v26 | 0xA000000000000000) == *(void *)&v45.type) {
          goto LABEL_50;
        }
        if (v27) {
          goto LABEL_46;
        }
        RB::Decoder::saved_shared_field((uint64_t)this, 5, v26, (uint64_t)&v45);
        LOBYTE(v27) = v45.data[12];
        if (*(void *)&v45.data[12])
        {
          long long v29 = *(_OWORD *)&v45.type;
LABEL_46:
          long long v37 = *(_OWORD *)this;
          *(_OWORD *)this = v29;
          if ((v27 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
            float64x2_t v4 = (uint64_t *)RB::DisplayList::decode_style_list((RB::DisplayList *)this, v30);
            RB::ProtobufDecoder::end_message((uint64_t)this);
          }
          else
          {
            *((unsigned char *)this + 56) = 1;
          }
          *(_OWORD *)this = v37;
        }
        RB::UntypedTable::insert((size_t **)v6, (size_t *)(v26 | 0xA000000000000000), (size_t *)v4);
LABEL_50:
        RB::ProtobufDecoder::end_message((uint64_t)this);
        uint64_t v3 = v9;
        if (v4) {
          continue;
        }
LABEL_58:
        float64x2_t v4 = 0;
LABEL_59:
        *((unsigned char *)this + 56) = 1;
        *this = this[1];
        uint64_t v3 = v9;
        continue;
      default:
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, field);
        continue;
    }
  }
  if (v3 && !*((unsigned char *)this + 56) && *this <= this[1])
  {
    __asm { FCVT            H0, S8 }
    *((_WORD *)v3 + 22) = _H0;
    *((_WORD *)v3 + 23) = *((_WORD *)v3 + 23) & 0xFFC0 | v8 & 0x3F;
    v3[2] = (void (**)(void))v4;
    v3[3] = (void (**)(void))v5;
    v3[4] = *(void (***)(void))&v44[4];
    *((_DWORD *)v3 + 10) = *(_DWORD *)v44;
  }
  return v3;
}

void sub_21418E3E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, RBFillData *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  RBFillData::~RBFillData((RBFillData *)&a21);
  RBShapeData::~RBShapeData((RBShapeData *)(v22 - 224));
  if (v21) {
    (**v21)(v21);
  }
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::decode_style_list(RB::DisplayList *this, RB::Decoder *a2)
{
  uint64_t result = *((void *)this + 9);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, RB::Decoder *))(*(void *)result + 32))(result, a2);
    if (result)
    {
      uint64_t v4 = result;
      uint64_t v10 = 0;
      uint64_t field = RB::ProtobufDecoder::next_field(this);
      if (field)
      {
        uint64_t v6 = field;
        uint64_t v7 = (RB::DisplayList::AnimationStyle **)&v10;
        do
        {
          if ((v6 & 0x7FFFFFFF8) == 8)
          {
            if ((v6 & 7) == 2)
            {
              RB::ProtobufDecoder::begin_message(this);
              uint64_t v9 = RB::DisplayList::Style::decode((RB::Heap **)this, v8);
              if (v9)
              {
                *((void *)v9 + 1) = *(void *)(v4 + 312);
                *(void *)(v4 + 312) = v9;
                uint64_t *v7 = v9;
                uint64_t v7 = (RB::DisplayList::AnimationStyle **)((char *)v9 + 32);
              }
              RB::ProtobufDecoder::end_message((uint64_t)this);
            }
            else
            {
              *((unsigned char *)this + 56) = 1;
              *(void *)this = *((void *)this + 1);
            }
          }
          else
          {
            RB::ProtobufDecoder::skip_field(this, v6);
          }
          uint64_t v6 = RB::ProtobufDecoder::next_field(this);
        }
        while (v6);
      }
      else
      {
        uint64_t v7 = (RB::DisplayList::AnimationStyle **)&v10;
      }
      uint64_t *v7 = 0;
      return v10;
    }
  }
  return result;
}

uint64_t *RB::DisplayList::LayerItem::prepare_encode(RB::DisplayList::LayerItem *this, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode((uint64_t *)this, a2);
  uint64_t result = (uint64_t *)*((void *)this + 6);
  if (result)
  {
    return RB::DisplayList::Layer::prepare_encode(result, a2);
  }
  return result;
}

void *RB::DisplayList::LayerItem::encode(RB::DisplayList::LayerItem *this, RB::Encoder *a2)
{
  RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  uint64_t v4 = (void **)*((void *)this + 6);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::DisplayList::Layer::encode(v4, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::DisplayList::Item::encode(this, a2);
}

uint64_t RB::DisplayList::LayerItem::decode(RB::DisplayList::LayerItem *this, size_t **a2)
{
  uint64_t result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
  if (result)
  {
    uint64_t v5 = result;
    do
    {
      if ((v5 & 0x7FFFFFFF8) == 8)
      {
        int v6 = *((_DWORD *)a2 + 56) + 1;
        *((_DWORD *)a2 + 56) = v6;
        int v11 = 0;
        int v12 = v6;
        uint64_t v7 = RB::Heap::emplace<RB::DisplayList::Layer,unsigned int,int>(a2[8], &v12, &v11);
        char v8 = (RB::DisplayList::Layer *)*((void *)this + 6);
        *((void *)this + 6) = v7;
        if (v8) {
          RB::DisplayList::Layer::~Layer(v8);
        }
        if ((v5 & 7) == 2)
        {
          uint64_t v9 = (RB::DisplayList::Layer *)*((void *)this + 6);
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          RB::DisplayList::Layer::decode(v9, (RB::Decoder *)a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *a2 = a2[1];
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, v5);
      }
      uint64_t result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
      uint64_t v5 = result;
    }
    while (result);
  }
  uint64_t v10 = *((void *)this + 6);
  if (v10)
  {
    if (*(unsigned char *)(v10 + 60)) {
      *((_WORD *)this + 23) |= 0x400u;
    }
  }
  else
  {
    *((unsigned char *)a2 + 56) = 1;
    *a2 = a2[1];
  }
  return result;
}

void *RB::DisplayList::BackdropColorMatrixItem::encode(RB::DisplayList::BackdropColorMatrixItem *this, RB::Encoder *a2)
{
  RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  uint64_t v4 = (RB::Filter::ColorMatrix *)*((void *)this + 6);
  if (v4)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Filter::ColorMatrix::encode(v4, a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::DisplayList::Item::encode(this, a2);
}

uint64_t RB::DisplayList::BackdropColorMatrixItem::decode(RB::DisplayList::BackdropColorMatrixItem *this, size_t **a2)
{
  uint64_t result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
  if (result)
  {
    uint64_t v5 = result;
    do
    {
      if ((v5 & 0x7FFFFFFF8) == 8)
      {
        int v6 = (RB::Filter::ColorMatrix *)RB::Heap::emplace<RB::Filter::ColorMatrix>(a2[8]);
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          RB::Filter::ColorMatrix::decode(v6, (RB::Decoder *)a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *a2 = a2[1];
        }
        *((void *)this + 6) = v6;
      }
      else
      {
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, v5);
      }
      uint64_t result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
      uint64_t v5 = result;
    }
    while (result);
  }
  if (!*((void *)this + 6))
  {
    *((unsigned char *)a2 + 56) = 1;
    *a2 = a2[1];
  }
  return result;
}

void *RB::DisplayList::LayerFilter::encode(RB::DisplayList::LayerFilter *this, RB::Encoder *a2)
{
  uint64_t result = (void *)(*(uint64_t (**)(RB::DisplayList::LayerFilter *))(*(void *)this + 40))(this);
  uint64_t v5 = v4;
  switch((int)result)
  {
    case 1:
      RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::Filter::ColorMatrix::encode(v5, a2);
      goto LABEL_8;
    case 2:
      RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::Filter::LuminanceCurve::encode((float32x4_t *)v5, a2);
      goto LABEL_8;
    case 3:
      RB::ProtobufEncoder::encode_varint(a2, 0x2AuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::Filter::RGBACurves::encode((float32x4_t *)v5, a2);
      goto LABEL_8;
    case 4:
      RB::ProtobufEncoder::encode_varint(a2, 0x22uLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::Filter::Custom::encode(v5, a2);
      goto LABEL_8;
    case 5:
      RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::Filter::GaussianBlur::encode((int *)v5, a2);
      goto LABEL_8;
    case 6:
      RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::Filter::Distance::encode((int *)v5, a2);
LABEL_8:
      uint64_t result = RB::ProtobufEncoder::end_length_delimited(a2);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t RB::DisplayList::LayerFilter::decode(RB::Heap **this, RB::Decoder *a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
  if (!field) {
    return 0;
  }
  unint64_t v4 = field;
  uint64_t v5 = 0;
  do
  {
    switch((v4 >> 3))
    {
      case 1u:
        v15.n128_u32[0] = 0;
        RB::ColorMatrix::set_identity((RB::ColorMatrix *)&v15.n128_i8[8]);
        if ((v4 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::Filter::ColorMatrix::decode((RB::Filter::ColorMatrix *)&v15, (RB::Decoder *)this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((unsigned char *)this + 56) = 1;
          *this = this[1];
        }
        RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix const&,RB::DisplayList::Builder &>(this[8], (uint64_t)&v15);
        goto LABEL_35;
      case 2u:
        v15.n128_u32[0] = 0;
        v16[0] = 0;
        v16[1] = 0;
        *(void *)((char *)&v16[1] + 6) = 0;
        *(_DWORD *)((char *)&v16[2] + 6) = 15360;
        if ((v4 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::Filter::LuminanceCurve::decode(&v15, (RB::Decoder *)this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((unsigned char *)this + 56) = 1;
          *this = this[1];
        }
        RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve>(this[8], (uint64_t)&v15);
        goto LABEL_35;
      case 3u:
        v15.n128_u32[0] = 0;
        float32x2_t v16[2] = 0;
        v15.n128_u64[1] = 0;
        v16[0] = 0;
        LODWORD(v16[1]) = 0;
        if ((v4 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::Filter::GaussianBlur::decode((RB::Filter::GaussianBlur *)&v15, (RB::Decoder *)this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((unsigned char *)this + 56) = 1;
          *this = this[1];
        }
        __n128 v7 = RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur>(this[8], (uint64_t)&v15);
        uint64_t v5 = v8;
        uint64_t v9 = (void (***)(void, __n128))v16[2];
        float32x2_t v16[2] = 0;
        if (v9) {
          (**v9)(v9, v7);
        }
        break;
      case 4u:
        v15.n128_u32[0] = 0;
        uint64_t v19 = 0;
        unint64_t v20 = 0;
        v15.n128_u64[1] = 0;
        uint64_t v21 = 4;
        long long v22 = xmmword_2142181C0;
        long long v23 = xmmword_2142181D0;
        long long v24 = 0u;
        long long v25 = 0u;
        if ((v4 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::Filter::Custom::decode(&v15, (RB::Decoder *)this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((unsigned char *)this + 56) = 1;
          *this = this[1];
        }
        uint64_t v5 = RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::Custom>,RB::Filter::Custom>((size_t *)this[8], (uint64_t)&v15);
        uint64_t v10 = v19;
        if (v19) {
          int v11 = (const void **)v19;
        }
        else {
          int v11 = (const void **)v16;
        }
        if (v20)
        {
          for (unint64_t i = 0; i < v20; ++i)
          {
            RB::CustomShader::Value::reset_data(v11);
            v11 += 3;
          }
          uint64_t v10 = v19;
        }
        if (v10) {
          free(v10);
        }
        unint64_t v13 = v15.n128_u64[1];
        if (v15.n128_u64[1]
          && atomic_fetch_add_explicit((atomic_uint *volatile)(v15.n128_u64[1] + 8), 0xFFFFFFFF, memory_order_release) == 1)
        {
          __dmb(9u);
          (*(void (**)(unint64_t))(*(void *)v13 + 8))(v13);
        }
        break;
      case 5u:
        v15.n128_u32[0] = 0;
        memset(v16, 0, sizeof(v16));
        long long v17 = 0u;
        long long v18 = 0u;
        if ((v4 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::Filter::RGBACurves::decode(&v15, (RB::Decoder *)this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((unsigned char *)this + 56) = 1;
          *this = this[1];
        }
        RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>,RB::Filter::RGBACurves const&,RB::DisplayList::Builder &>(this[8], (uint64_t)&v15);
        goto LABEL_35;
      case 6u:
        v15.n128_u64[0] = 0x3F80000000000000;
        v15.n128_u32[2] = 0;
        if ((v4 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::Filter::Distance::decode((uint64_t)&v15, (RB::ProtobufDecoder *)this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((unsigned char *)this + 56) = 1;
          *this = this[1];
        }
        uint64_t v6 = RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::Distance>,RB::Filter::Distance>(this[8], (uint64_t *)&v15);
LABEL_35:
        uint64_t v5 = v6;
        break;
      default:
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v4);
        break;
    }
    unint64_t v4 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
  }
  while (v4);
  return v5;
}

void sub_21418EE74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  RB::Filter::Custom::~Custom((RB::Filter::Custom *)va);
  _Unwind_Resume(a1);
}

void *RB::DisplayList::Clip::encode(void *this, RB::Encoder *a2)
{
  uint64_t v3 = (uint64_t)this;
  if (*((unsigned char *)this + 44) == 1)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
    this = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  if (*(void *)(v3 + 32) || *(_DWORD *)(v3 + 40))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x2AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::DisplayList::encode_metadata(a2, *(RB::Encoder **)(v3 + 32), (const RB::DisplayList::Metadata *)*(unsigned int *)(v3 + 40), 0);
    return RB::ProtobufEncoder::end_length_delimited(a2);
  }
  return this;
}

uint64_t RB::DisplayList::Clip::decode(RB::Heap **this, RB::Decoder *a2)
{
  uint64_t v3 = 0;
  char v4 = 0;
  uint64_t v27 = *MEMORY[0x263EF8340];
  memset(v25, 0, sizeof(v25));
  while (1)
  {
    uint64_t v5 = (void (***)(void))v3;
    unint64_t field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
    uint64_t v8 = field;
    if (!field) {
      break;
    }
    switch((field >> 3))
    {
      case 1u:
        uint64_t v9 = RB::AffineTransform::identity((RB::AffineTransform *)field);
        v26.type = 0;
        if ((v8 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          unint64_t v11 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
          for (i = 1.0; v11; unint64_t v11 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this))
          {
            unint64_t v13 = v11 >> 3;
            if ((v11 >> 3) == 3)
            {
              float i = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)this, v11);
            }
            else if (v13 == 2)
            {
              RB::Decoder::affine_transform_field((size_t **)this, v11);
              uint64_t v9 = v14;
            }
            else if (v13 == 1)
            {
              if ((v11 & 7) == 2)
              {
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RBShapeData::decode(&v26, (RB::Decoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
              }
              else
              {
                *((unsigned char *)this + 56) = 1;
                *this = this[1];
              }
            }
            else
            {
              RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v11);
            }
          }
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((unsigned char *)this + 56) = 1;
          *this = this[1];
          float i = 1.0;
        }
        uint64_t v19 = this[8];
        float v20 = i;
        int v21 = 0;
        long long v22 = v9;
        char v23 = 0;
        uint64_t v24 = 0;
        RBShapeData::apply<RB::DisplayList::ClipFactory>((uint64_t)&v26, (uint64_t)&v19, v10);
        uint64_t v3 = v24;
        if (v5) {
          (**v5)(v5);
        }
        RBShapeData::~RBShapeData(&v26);
        continue;
      case 2u:
        *(void *)&v26.type = 0;
        uint64_t v3 = RB::Heap::emplace<RB::DisplayList::LayerClip,decltype(nullptr)>(this[8], v7);
        if ((v8 & 7) != 2) {
          goto LABEL_35;
        }
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        RB::DisplayList::LayerClip::decode((float32x2_t *)v3, (size_t **)this);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        goto LABEL_22;
      case 3u:
        *(void *)&v26.type = 0;
        uint64_t v3 = RB::Heap::emplace<RB::DisplayList::ItemClip,decltype(nullptr)>(this[8], v7);
        if ((v8 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::DisplayList::ItemClip::decode((RB::DisplayList::ItemClip *)v3, (RB::Decoder *)this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
LABEL_22:
          if (v5)
          {
LABEL_23:
            (**v5)(v5);
            continue;
          }
        }
        else
        {
LABEL_35:
          *((unsigned char *)this + 56) = 1;
          *this = this[1];
          if (v5) {
            goto LABEL_23;
          }
        }
        break;
      case 4u:
        char v4 = RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)this, field);
        continue;
      case 5u:
        __n128 v15 = this[9];
        if (v15 && (int32x4_t v16 = (size_t *)(*(uint64_t (**)(RB::Heap *))(*(void *)v15 + 32))(v15)) != 0)
        {
          if ((v8 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
            RB::DisplayList::decode_metadata((RB::DisplayList *)this, v16, (RB::DisplayList::Contents *)&v25[4], (const RB::DisplayList::Metadata **)v25, v17);
            RB::ProtobufDecoder::end_message((uint64_t)this);
          }
          else
          {
            *((unsigned char *)this + 56) = 1;
            *this = this[1];
          }
          uint64_t v3 = (uint64_t)v5;
        }
        else
        {
          RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v8);
          uint64_t v3 = (uint64_t)v5;
        }
        continue;
      default:
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, field);
        continue;
    }
  }
  if (v3)
  {
    if (v4)
    {
      *(unsigned char *)(v3 + 44) = 1;
      *(void *)(v3 + 16) = 0x100000001000000;
      *(int32x2_t *)(v3 + 24) = vdup_n_s32(0x7F7FFFFFu);
      *(void *)(v3 + 32) = *(void *)&v25[4];
      *(_DWORD *)(v3 + 40) = *(_DWORD *)v25;
    }
  }
  else
  {
    *((unsigned char *)this + 56) = 1;
    *this = this[1];
  }
  return v3;
}

void sub_21418F33C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, RBShapeData *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  RBShapeData::~RBShapeData((RBShapeData *)&a17);
  if (v17) {
    (**v17)(v17);
  }
  _Unwind_Resume(a1);
}

uint64_t *RB::DisplayList::LayerClip::prepare_encode(RB::DisplayList::LayerClip *this, RB::Encoder *a2)
{
  uint64_t result = (uint64_t *)*((void *)this + 6);
  if (result) {
    return RB::DisplayList::Layer::prepare_encode(result, a2);
  }
  return result;
}

void *RB::DisplayList::LayerClip::encode(RB::DisplayList::LayerClip *this, RB::Encoder *a2)
{
  RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  char v4 = (void **)*((void *)this + 6);
  if (v4)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::DisplayList::Layer::encode(v4, a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  int v5 = *((int *)this + 14);
  if (*(float *)&v5 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x15uLL);
    RB::ProtobufEncoder::encode_fixed32(a2, v5);
  }
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::DisplayList::Clip::encode(this, a2);
}

void RB::DisplayList::LayerClip::decode(float32x2_t *this, size_t **a2)
{
  uint64_t field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
  if (field)
  {
    unint64_t v7 = field;
    do
    {
      if ((v7 >> 3) == 2)
      {
        this[7].f32[0] = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a2, v7);
      }
      else if ((v7 >> 3) == 1)
      {
        int v8 = *((_DWORD *)a2 + 56) + 1;
        *((_DWORD *)a2 + 56) = v8;
        int v14 = 0;
        int v15 = v8;
        uint64_t v9 = RB::Heap::emplace<RB::DisplayList::Layer,unsigned int,int>(a2[8], &v15, &v14);
        int8x16_t v10 = (RB::DisplayList::Layer *)this[6];
        this[6] = (float32x2_t)v9;
        if (v10) {
          RB::DisplayList::Layer::~Layer(v10);
        }
        if ((v7 & 7) == 2)
        {
          unint64_t v11 = (RB::DisplayList::Layer *)this[6];
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          RB::DisplayList::Layer::decode(v11, (RB::Decoder *)a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *a2 = a2[1];
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, v7);
      }
      unint64_t v7 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
    }
    while (v7);
  }
  int v12 = (RB::DisplayList::Layer *)this[6];
  if (v12)
  {
    this[2] = RB::DisplayList::Layer::bounds(v12, v5, v6);
    this[3] = v13;
  }
  else
  {
    *((unsigned char *)a2 + 56) = 1;
    *a2 = a2[1];
  }
}

uint64_t RB::DisplayList::ItemClip::prepare_encode(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 48);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 240))();
  }
  return result;
}

void *RB::DisplayList::ItemClip::encode(RB::DisplayList::ItemClip *this, RB::Encoder *a2)
{
  RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  uint64_t v4 = *((void *)this + 6);
  if (v4)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    (*(void (**)(uint64_t, RB::Encoder *))(*(void *)v4 + 248))(v4, a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::DisplayList::Clip::encode(this, a2);
}

void RB::DisplayList::ItemClip::decode(RB::DisplayList::ItemClip *this, RB::Decoder *a2)
{
  uint64_t field = RB::ProtobufDecoder::next_field(a2);
  if (field)
  {
    uint64_t v5 = field;
    do
    {
      if ((v5 & 0x7FFFFFFF8) == 8)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          uint64_t v7 = RB::DisplayList::Item::decode(a2, v6);
          int v8 = (void (***)(void))*((void *)this + 6);
          *((void *)this + 6) = v7;
          if (v8) {
            (**v8)(v8);
          }
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v5);
      }
      uint64_t v5 = RB::ProtobufDecoder::next_field(a2);
    }
    while (v5);
  }
  uint64_t v9 = *((void *)this + 6);
  if (v9)
  {
    *((double *)this + 2) = (*(double (**)(uint64_t, void))(*(void *)v9 + 144))(v9, 0);
    *((void *)this + 3) = v10;
  }
  else
  {
    *((unsigned char *)a2 + 56) = 1;
    *(void *)a2 = *((void *)a2 + 1);
  }
}

void *RB::DisplayList::ClipNode::encode(void *this, RB::Encoder *a2)
{
  if (this)
  {
    uint64_t v3 = this;
    do
    {
      unint64_t v4 = v3[1] & 0xFFFFFFFFFFFFFFFELL;
      if (v4)
      {
        RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
        RB::ProtobufEncoder::begin_length_delimited(a2);
        (*(void (**)(unint64_t, RB::Encoder *))(*(void *)v4 + 120))(v4, a2);
        this = RB::ProtobufEncoder::end_length_delimited(a2);
      }
      uint64_t v3 = (void *)*v3;
    }
    while (v3);
  }
  return this;
}

void RB::DisplayList::ClipNode::decode(RB::DisplayList::ClipNode *this, size_t **a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  float v20 = 0;
  size_t v21 = 0;
  unint64_t v22 = 8;
  while (1)
  {
    uint64_t field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
    if (!field) {
      break;
    }
    if ((field & 0x7FFFFFFF8) == 8
      && (uint64_t v5 = a2[9]) != 0
      && (uint64_t v6 = (*(uint64_t (**)(size_t *))(*v5 + 32))(v5)) != 0)
    {
      if ((field & 7) == 2)
      {
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
        uint64_t v8 = RB::DisplayList::Clip::decode((RB::Heap **)a2, v7);
        if (v8)
        {
          size_t v9 = v21;
          size_t v10 = v21 + 1;
          if (v22 < v21 + 1)
          {
            RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(__dst, v10);
            size_t v9 = v21;
            size_t v10 = v21 + 1;
          }
          unint64_t v11 = v20;
          if (!v20) {
            unint64_t v11 = __dst;
          }
          *(void *)&v11[8 * v9] = v8;
          size_t v21 = v10;
          *(void *)(v8 + 8) = *(void *)(v6 + 312);
          *(void *)(v6 + 312) = v8;
        }
        RB::ProtobufDecoder::end_message((uint64_t)a2);
      }
      else
      {
        *((unsigned char *)a2 + 56) = 1;
        *a2 = a2[1];
      }
    }
    else
    {
      RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, field);
    }
  }
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  if (v21)
  {
    long long v18 = 0;
    size_t v12 = v21 - 1;
    if (v21 != 1)
    {
      uint64_t v13 = 8 * v21 - 8;
      do
      {
        int v14 = v20;
        if (!v20) {
          int v14 = __dst;
        }
        long long v18 = (const RB::DisplayList::ClipNode *)RB::Heap::emplace<RB::DisplayList::ClipNode,RB::DisplayList::Clip const*&,RB::DisplayList::ClipNode*&>(a2[8], (const RB::DisplayList::Clip **)&v14[v13], &v18);
        v13 -= 8;
        --v12;
      }
      while (v12);
    }
    int v15 = (const RB::DisplayList::Clip **)v20;
    if (!v20) {
      int v15 = (const RB::DisplayList::Clip **)__dst;
    }
    RB::DisplayList::ClipNode::ClipNode((RB::DisplayList::ClipNode *)v17, *v15, v18);
    long long v16 = v17[1];
    *(_OWORD *)this = v17[0];
    *((_OWORD *)this + 1) = v16;
  }
  else
  {
    *((unsigned char *)a2 + 56) = 1;
    *a2 = a2[1];
  }
  if (v20) {
    free(v20);
  }
}

void sub_21418FA50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23)
{
  if (a23) {
    free(a23);
  }
  _Unwind_Resume(exception_object);
}

RB::Encoder *RB::DisplayList::encode_metadata(RB::Encoder *this, RB::Encoder *a2, const RB::DisplayList::Metadata *a3, char a4)
{
  uint64_t v6 = this;
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (a3)
  {
    unsigned int v7 = a3;
    uuid_clear((unsigned __int8 *)&v17);
    unsigned int v16 = v7;
    if (a2)
    {
      uint64_t v8 = RB::DisplayList::Metadata::identity_ns((uint64_t *)a2);
      if (v8) {
        long long v17 = *(_OWORD *)v8;
      }
    }
    RB::ProtobufEncoder::encode_varint(v6, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(v6);
    RB::Identity::encode(&v16, v6);
    this = (RB::Encoder *)RB::ProtobufEncoder::end_length_delimited(v6);
  }
  if (a2 && (a4 & 1) == 0)
  {
    size_t v9 = RB::DisplayList::Metadata::transition((uint64_t *)a2);
    if (v9)
    {
      size_t v10 = (RB::Transition *)v9;
      RB::ProtobufEncoder::encode_varint(v6, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(v6);
      RB::Transition::encode(v10, v6);
      RB::ProtobufEncoder::end_length_delimited(v6);
    }
    unint64_t v11 = RB::DisplayList::Metadata::numeric_value((uint64_t *)a2);
    if (v11)
    {
      int v12 = *(_DWORD *)v11;
      RB::ProtobufEncoder::encode_varint(v6, 0x1DuLL);
      RB::ProtobufEncoder::encode_fixed32(v6, v12);
    }
    uint64_t v13 = RB::DisplayList::Metadata::text_identity((uint64_t *)a2);
    if (v13)
    {
      int v14 = (RB::TextIdentity *)v13;
      RB::ProtobufEncoder::encode_varint(v6, 0x22uLL);
      RB::ProtobufEncoder::begin_length_delimited(v6);
      RB::TextIdentity::encode(v14, v6);
      RB::ProtobufEncoder::end_length_delimited(v6);
    }
    this = (RB::Encoder *)RB::DisplayList::Metadata::animation_layer((uint64_t *)a2);
    if (this)
    {
      int v15 = this;
      RB::ProtobufEncoder::encode_varint(v6, 0x2AuLL);
      RB::ProtobufEncoder::begin_length_delimited(v6);
      RB::AnimationLayer::encode(v15, v6);
      return (RB::Encoder *)RB::ProtobufEncoder::end_length_delimited(v6);
    }
  }
  return this;
}

uint64_t RB::DisplayList::decode_metadata(RB::DisplayList *this, size_t *a2, RB::DisplayList::Contents *a3, const RB::DisplayList::Metadata **a4, unsigned int *a5)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  int v19 = 0;
  uuid_clear(v20);
  uint64_t v18 = 0;
  LOBYTE(v16) = 0;
  char v17 = 0;
  float v9 = NAN;
  while (1)
  {
    unint64_t field = RB::ProtobufDecoder::next_field(this);
    if (!field) {
      break;
    }
    switch((field >> 3))
    {
      case 1u:
        if ((field & 7) != 2) {
          goto LABEL_16;
        }
        RB::ProtobufDecoder::begin_message(this);
        RB::Identity::decode((uint64_t)&v19, this);
        goto LABEL_10;
      case 2u:
        operator new();
      case 3u:
        float v9 = RB::ProtobufDecoder::float_field(this, field);
        continue;
      case 4u:
        if ((field & 7) != 2) {
          goto LABEL_16;
        }
        RB::ProtobufDecoder::begin_message(this);
        uint64_t v18 = RB::TextIdentity::decode((size_t **)this, v11);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        continue;
      case 5u:
        if (!v17) {
          char v17 = 1;
        }
        uint64_t v16 = 0x100000000;
        if ((field & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(this);
          RB::AnimationLayer::decode(&v16, this);
LABEL_10:
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
LABEL_16:
          *((unsigned char *)this + 56) = 1;
          *(void *)this = *((void *)this + 1);
        }
        break;
      default:
        RB::ProtobufDecoder::skip_field(this, field);
        continue;
    }
  }
  *(_DWORD *)a4 = v19;
  *(float *)&int v15 = v9;
  RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)2>,RB::DisplayList::Metadata const*&,float>((RB::Heap *)(a2 + 2), a3, (float *)&v15);
  *(void *)a3 = v12;
  if (v18) {
    *(void *)a3 = RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)3>,RB::DisplayList::Metadata const*&,RB::TextIdentity const*&>((RB::Heap *)(a2 + 2), a3, (uint64_t *)&v18);
  }
  if (v17) {
    *(void *)a3 = RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)4>,RB::DisplayList::Metadata const*&,RB::AnimationLayer &>((RB::Heap *)(a2 + 2), a3, &v16);
  }
  uint64_t result = uuid_is_null(v20);
  if (!result)
  {
    int v15 = v20;
    int v14 = RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)0>,RB::DisplayList::Metadata const*&,RB::UUID *>(a2 + 2, a3, (uint64_t *)&v15);
    uint64_t result = RB::DisplayList::Contents::intern_uuid((RB::DisplayList::Contents *)a2, (const UUID *)v14[1]);
    v14[1] = result;
    *(void *)a3 = v14;
  }
  return result;
}

void sub_214190004(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    if (atomic_fetch_add_explicit(v1 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v1 + 8))(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

double RB::Heap::emplace<RB::ProjectionMatrix>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if (v3 + 36 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x24uLL, 3);
  }
  else {
    *((void *)this + 2) = v3 + 36;
  }
  *(_DWORD *)(v3 + 32) = 1065353216;
  *(void *)&double result = 1065353216;
  *(_OWORD *)unint64_t v3 = xmmword_214218320;
  *(_OWORD *)(v3 + 16) = xmmword_214218320;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 48 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 48;
  }
  *(void *)unint64_t v3 = &unk_26C4EBDE0;
  double result = 0.0078125;
  *(void *)(v3 + 16) = 0x3F80000000000000;
  *(void *)(v3 + 24) = 0x3C00000000000000;
  *(_WORD *)(v3 + 32) = 0;
  *(unsigned char *)(v3 + 40) = 1;
  return result;
}

void RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::~GenericEffect()
{
}

void RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::copy(__n128 *a1, uint64_t a2)
{
  RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> const&,RB::DisplayList::Contents &>((RB::Heap *)(*(void *)(a2 + 8) + 16), a1);
  *(unsigned char *)(v2 + 40) = 0;
}

int32x2_t *RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::dod(int32x2_t *a1, int32x2_t *a2)
{
  return RB::AlphaThresholdEffect::dod(a1 + 2, a2);
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::can_discard_color()
{
  return 1;
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::can_append_color_matrix()
{
  return 1;
}

__n128 *RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::append_color_matrix(__n128 *a1, float16x4_t *a2, int a3, __int16 a4, uint64_t a5, uint16x4_t a6)
{
  float v9 = a1;
  if (a1[2].n128_u8[8])
  {
    a6 = (uint16x4_t)RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> const&,RB::DisplayList::Contents &>((RB::Heap *)(*(void *)(a5 + 8) + 16), a1).n128_u64[0];
    float v9 = v10;
    v10[2].n128_u8[8] = 0;
  }
  RB::Fill::Color::append_color_matrix((short float *)&v9[1].n128_u16[4], a2, a3, a4, a6);
  return v9;
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::AlphaThresholdEffect::matches((RB::AlphaThresholdEffect *)(a1 + 16), a2, a3);
}

__n128 *RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::apply_transform(__n128 *a1, RB::DisplayList::Contents *a2, RB::DisplayList::Transform *a3, __n128 a4)
{
  uint64_t v6 = a1;
  if (a1[2].n128_u8[8])
  {
    a4 = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> const&,RB::DisplayList::Contents &>((RB::DisplayList::Contents *)((char *)a2 + 16), a1);
    uint64_t v6 = v7;
    v7[2].n128_u8[8] = 0;
  }
  RB::AlphaThresholdEffect::apply_transform((RB::AlphaThresholdEffect *)&v6[1], a2, a3, (uint32x4_t)a4);
  return v6;
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::required_depth(float16x4_t *a1)
{
  return RB::Fill::Color::required_depth(a1 + 3);
}

BOOL RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::needs_zero_alpha(uint64_t a1)
{
  return COERCE_FLOAT(*(void *)(a1 + 16)) <= 0.0;
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::splits_parent()
{
  return 0;
}

int32x2_t *RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::render(int32x2_t *a1, uint64_t a2, uint64_t a3, float32x2_t *a4, uint64_t a5, int a6, float64x2_t *a7, float32x2_t *a8, double a9, float a10, char a11, __int16 a12, char a13)
{
  return RB::AlphaThresholdEffect::render(a1 + 2, a9, a10, a2, a3, a4, a5, a6, a7, a8, a11, a12, a13);
}

size_t RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::render(int32x2_t *a1, CGContextRef *a2, uint16x4_t a3)
{
  return RB::AlphaThresholdEffect::render(a1 + 2, a2, a3);
}

void RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::print(uint64_t a1, std::string *a2)
{
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::field()
{
  return 2;
}

void *RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::encode(uint64_t a1, RB::Encoder *a2)
{
  return RB::AlphaThresholdEffect::encode((RB::AlphaThresholdEffect *)(a1 + 16), a2);
}

__n128 RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> const&,RB::DisplayList::Contents &>(RB::Heap *this, __n128 *a2)
{
  unint64_t v4 = *((void *)this + 3);
  uint64_t v5 = (__n128 *)((*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)v5[3].n128_u64 > v4) {
    uint64_t v5 = (__n128 *)RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 3;
  }
  v5->n128_u64[0] = (unint64_t)&unk_26C4EBDE0;
  __n128 result = a2[1];
  v5[2].n128_u16[0] = a2[2].n128_u16[0];
  v5[1] = result;
  v5[2].n128_u8[8] = 1;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 88 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x58uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 88;
  }
  *(void *)unint64_t v3 = &unk_26C4EBD20;
  double result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(void *)(v3 + 63) = 0;
  *(_WORD *)(v3 + 71) = 1;
  *(unsigned char *)(v3 + 80) = 1;
  return result;
}

void RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::~GenericEffect()
{
}

unint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t result = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::DisplayList::GenericEffect<RB::AlphaGradientEffect> const&,RB::DisplayList::Contents &>((size_t *)(*(void *)(a2 + 8) + 16), a1, *(void *)(a2 + 8));
  *(unsigned char *)(result + 80) = 0;
  return result;
}

int32x2_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::dod(uint64_t a1, int32x2_t *a2, double a3, double a4, double a5, double a6, float a7)
{
  return RB::AlphaGradientEffect::dod((RB::AlphaGradientEffect *)(a1 + 16), a2, a3, a4, a5, a6, a7);
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::can_discard_color()
{
  return 1;
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::can_append_color_matrix()
{
  return 1;
}

unint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4, uint64_t a5)
{
  unint64_t v8 = a1;
  if (*(unsigned char *)(a1 + 80))
  {
    unint64_t v8 = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::DisplayList::GenericEffect<RB::AlphaGradientEffect> const&,RB::DisplayList::Contents &>((size_t *)(*(void *)(a5 + 8) + 16), a1, *(void *)(a5 + 8));
    *(unsigned char *)(v8 + 80) = 0;
  }
  RB::Fill::Gradient::append_color_matrix(v8 + 16, a2, a3, a4);
  return v8;
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 16), a2);
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 72);
}

BOOL RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::needs_zero_alpha(uint64_t a1, double a2, double a3, double a4, double a5, float a6)
{
  return RB::Fill::Gradient::sample_alpha((RB::Fill::Gradient *)(a1 + 16), 0.0, a3, a4, a5, a6) > 0.0;
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::splits_parent()
{
  return 0;
}

RB::Fill::Gradient *RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::render(uint64_t a1, uint64_t a2, uint64_t a3, float32x2_t *a4, uint64_t a5, int a6, float64x2_t *a7, float32x2_t *a8, double a9, double a10, double a11, double a12, float a13, char a14, __int16 a15, char a16)
{
  return RB::AlphaGradientEffect::render((RB::Fill::Gradient *)(a1 + 16), a9, a10, a11, a12, a13, a2, a3, a4, a5, a6, a7, a8, a14, a15, a16);
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::render(uint64_t a1, RB::CGContext *a2)
{
  return RB::AlphaGradientEffect::render((RB::AlphaGradientEffect *)(a1 + 16), a2);
}

void RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::print(uint64_t a1, RB::SexpString *a2)
{
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::field()
{
  return 3;
}

void *RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::encode(uint64_t a1, RB::Encoder *a2)
{
  return RB::AlphaGradientEffect::encode((RB::AlphaGradientEffect *)(a1 + 16), a2);
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::DisplayList::GenericEffect<RB::AlphaGradientEffect> const&,RB::DisplayList::Contents &>(size_t *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 88 > a1[3]) {
    unint64_t v5 = RB::Heap::alloc_slow(a1, 0x58uLL, 7);
  }
  else {
    a1[2] = v5 + 88;
  }
  *(void *)unint64_t v5 = &unk_26C4EBD20;
  RB::AlphaGradientEffect::AlphaGradientEffect((uint64_t *)(v5 + 16), (uint64_t *)(a2 + 16), a3);
  *(unsigned char *)(v5 + 80) = 1;
  return v5;
}

double RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::CustomEffect>>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 272 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x110uLL, 15);
  }
  else {
    *((void *)this + 2) = v3 + 272;
  }
  *(void *)unint64_t v3 = &unk_26C4EBC60;
  *(void *)(v3 + 16) = 0;
  *(void *)(v3 + 120) = 0;
  *(void *)(v3 + 128) = 0;
  *(void *)(v3 + 136) = 4;
  *(void *)(v3 + 144) = 0;
  *(void *)(v3 + 152) = 0;
  *(void *)(v3 + 160) = 0;
  *(_OWORD *)(v3 + 176) = xmmword_2142181C0;
  *(_OWORD *)(v3 + 192) = xmmword_2142181D0;
  double result = 0.0;
  *(_OWORD *)(v3 + 208) = 0u;
  *(_OWORD *)(v3 + 224) = 0u;
  *(_DWORD *)(v3 + 240) = 0;
  *(unsigned char *)(v3 + 256) = 1;
  return result;
}

void *RB::DisplayList::GenericEffect<RB::CustomEffect>::~GenericEffect(void *a1)
{
  unint64_t v2 = (RB::DisplayList::Layer *)a1[18];
  a1[18] = 0;
  if (v2) {
    RB::DisplayList::Layer::~Layer(v2);
  }
  unint64_t v3 = (void *)a1[15];
  if (v3) {
    unint64_t v4 = (const void **)a1[15];
  }
  else {
    unint64_t v4 = (const void **)(a1 + 3);
  }
  if (a1[16])
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[16]);
    unint64_t v3 = (void *)a1[15];
  }
  if (v3) {
    free(v3);
  }
  uint64_t v6 = (atomic_uint *)a1[2];
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  return a1;
}

void RB::DisplayList::GenericEffect<RB::CustomEffect>::~GenericEffect(void *a1)
{
  unint64_t v2 = (RB::DisplayList::Layer *)a1[18];
  a1[18] = 0;
  if (v2) {
    RB::DisplayList::Layer::~Layer(v2);
  }
  unint64_t v3 = (void *)a1[15];
  if (v3) {
    unint64_t v4 = (const void **)a1[15];
  }
  else {
    unint64_t v4 = (const void **)(a1 + 3);
  }
  if (a1[16])
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[16]);
    unint64_t v3 = (void *)a1[15];
  }
  if (v3) {
    free(v3);
  }
  uint64_t v6 = (atomic_uint *)a1[2];
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  JUMPOUT(0x21669AC10);
}

unint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t result = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::CustomEffect>,RB::DisplayList::GenericEffect<RB::CustomEffect> const&,RB::DisplayList::Contents &>((size_t *)(*(void *)(a2 + 8) + 16), a1, *(RB::DisplayList::Contents **)(a2 + 8));
  *(unsigned char *)(result + 256) = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)(result + 8) = *(void *)(v4 + 312);
  *(void *)(v4 + 312) = result;
  return result;
}

unint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::apply_transform(uint64_t a1, float64x2_t *a2)
{
  unint64_t v3 = a1;
  if (*(unsigned char *)(a1 + 256))
  {
    uint64_t v4 = *(size_t **)(*(void *)&a2->f64[0] + 8);
    unint64_t v3 = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::CustomEffect>,RB::DisplayList::GenericEffect<RB::CustomEffect> const&,RB::DisplayList::Contents &>(v4 + 2, a1, (RB::DisplayList::Contents *)v4);
    *(unsigned char *)(v3 + 256) = 0;
    *(void *)(v3 + 8) = v4[39];
    v4[39] = v3;
  }
  RB::CustomEffect::apply_transform((RB::CustomEffect *)(v3 + 16), a2);
  return v3;
}

float32x2_t RB::DisplayList::GenericEffect<RB::CustomEffect>::roi(uint64_t a1, float32x2_t *a2, double a3, double a4, double a5, int32x4_t a6)
{
  return RB::CustomEffect::roi((RB::CustomEffect *)(a1 + 16), a2, a3, a4, a5, a6);
}

void RB::DisplayList::GenericEffect<RB::CustomEffect>::dod(uint64_t a1, float32x2_t *a2, double a3, int32x4_t a4, double a5, int32x4_t a6)
{
}

BOOL RB::DisplayList::GenericEffect<RB::CustomEffect>::can_discard_color(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 240) & 3) == 2;
}

uint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::can_append_color_matrix()
{
  return 0;
}

uint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 16), a2);
}

uint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::required_depth(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::needs_zero_alpha()
{
  return 0;
}

RB::RenderTask *RB::DisplayList::GenericEffect<RB::CustomEffect>::add_tasks(uint64_t a1, MTLPixelFormat a2, __n128 *a3, double a4, double a5)
{
  return RB::CustomEffect::add_tasks(a1 + 16, a2, a3, a4, a5);
}

uint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::splits_parent(float32x2_t *a1, int32x2_t *a2, const RB::BoundsAccumulator *a3, double a4, int32x4_t a5)
{
  return RB::CustomEffect::splits_parent(a1 + 2, a2, a3, a4, a5);
}

uint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::prepare(uint64_t a1, uint64_t **a2)
{
  return RB::CustomEffect::prepare(a1 + 16, a2);
}

int32x2_t *RB::DisplayList::GenericEffect<RB::CustomEffect>::render(uint64_t a1, uint64_t a2, uint64_t **a3, long long *a4, RB::Texture *a5, uint64_t a6, float64x2_t *a7, float32x2_t *a8, int32x2_t a9, float a10, char a11, __int16 a12, char a13)
{
  return RB::CustomEffect::render(a1 + 16, a2, a3, a4, a5, a9, a10, a6, a7, a8, a11, a12, a13);
}

uint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::render(uint64_t a1)
{
  return RBStrokeRef::clip(a1 + 16);
}

void RB::DisplayList::GenericEffect<RB::CustomEffect>::print(uint64_t a1, std::string *a2)
{
}

uint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::field()
{
  return 4;
}

uint64_t *RB::DisplayList::GenericEffect<RB::CustomEffect>::prepare_encode(uint64_t a1, RB::Encoder *a2)
{
  return RB::CustomEffect::prepare_encode((uint64_t **)(a1 + 16), a2);
}

void *RB::DisplayList::GenericEffect<RB::CustomEffect>::encode(uint64_t a1, RB::Encoder *a2)
{
  return RB::CustomEffect::encode((RB::CustomEffect *)(a1 + 16), a2);
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::CustomEffect>,RB::DisplayList::GenericEffect<RB::CustomEffect> const&,RB::DisplayList::Contents &>(size_t *a1, uint64_t a2, RB::DisplayList::Contents *a3)
{
  unint64_t v5 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 272 > a1[3]) {
    unint64_t v5 = RB::Heap::alloc_slow(a1, 0x110uLL, 15);
  }
  else {
    a1[2] = v5 + 272;
  }
  *(void *)unint64_t v5 = &unk_26C4EBC60;
  RB::CustomEffect::CustomEffect((RB::CustomEffect *)(v5 + 16), (const RB::CustomEffect *)(a2 + 16), a3);
  *(unsigned char *)(v5 + 256) = 1;
  return v5;
}

uint64_t *RB::Encoder::prepare_shared_f<void RB::Encoder::prepare_shared<RB::DisplayList::ClipNode>(RB::Encoder::SharedType,RB::DisplayList::ClipNode const&)::{lambda(RB::DisplayList::ClipNode&)#1}>(uint64_t *result, uint64_t a2, uint64_t *a3, void **a4)
{
  if ((*((unsigned char *)result + 164) & 1) == 0)
  {
    unsigned int v7 = result;
    unint64_t v8 = (size_t **)(result + 10);
    size_t v10 = 0;
    unint64_t result = RB::UntypedTable::lookup((RB::UntypedTable *)(result + 10), a3, &v10);
    if (v10 != a3)
    {
      float v9 = (size_t *)v7[9];
      v7[9] = (uint64_t)v9 + 1;
      RB::UntypedTable::insert(v8, (size_t *)a3, v9);
      RB::ProtobufEncoder::encode_varint(v7, 0x7AuLL);
      RB::ProtobufEncoder::begin_length_delimited(v7);
      if (v9)
      {
        RB::ProtobufEncoder::encode_varint(v7, 8uLL);
        RB::ProtobufEncoder::encode_varint(v7, (unint64_t)v9);
      }
      RB::ProtobufEncoder::encode_varint(v7, (8 * a2) | 2);
      RB::ProtobufEncoder::begin_length_delimited(v7);
      RB::DisplayList::ClipNode::encode(*a4, (RB::Encoder *)v7);
      RB::ProtobufEncoder::end_length_delimited(v7);
      return RB::ProtobufEncoder::end_length_delimited(v7);
    }
  }
  return result;
}

double RB::Heap::emplace<RB::DisplayList::LayerItem,int,RB::BlendMode,decltype(nullptr)>(size_t *a1, int *a2, int *a3)
{
  uint64_t v5 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 56 > a1[3]) {
    uint64_t v5 = RB::Heap::alloc_slow(a1, 0x38uLL, 7);
  }
  else {
    a1[2] = v5 + 56;
  }
  float v6 = (float)*a2;
  int v7 = *a3;
  *(void *)&double result = RB::DisplayList::LayerItem::LayerItem(v5, v7, 0, v6);
  return result;
}

double RB::Heap::emplace<RB::DisplayList::BackdropColorMatrixItem>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  uint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 56 > v2) {
    uint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x38uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 56;
  }
  *(void *)&double result = RB::DisplayList::BackdropColorMatrixItem::BackdropColorMatrixItem(v3, 0, 2, 1.0);
  return result;
}

uint64_t RB::Decoder::shared_field_f<RB::DisplayList::ClipNode,RB::DisplayList::ClipNode const* RB::Decoder::shared_field<RB::DisplayList::ClipNode>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType)::{lambda(RB::DisplayList::ClipNode&)#1}>(RB::ProtobufDecoder *this, char a2, uint64_t a3, uint64_t a4)
{
  v6[0] = a3;
  v6[1] = a4;
  void v6[2] = &v7;
  uint64_t v7 = 0;
  if ((a2 & 7) != 2
    || (RB::ProtobufDecoder::begin_message(this),
        RB::Decoder::shared_field_f<RB::DisplayList::ClipNode,RB::DisplayList::ClipNode const* RB::Decoder::shared_field<RB::DisplayList::ClipNode>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType)::{lambda(RB::DisplayList::ClipNode&)#1}>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType,RB::DisplayList::ClipNode const* RB::Decoder::shared_field<RB::DisplayList::ClipNode>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType)::{lambda(RB::DisplayList::ClipNode&)#1} const&)::{lambda(RB::DisplayList::ClipNode&)#1}::operator()<RB::Decoder>((uint64_t)v6, (size_t **)this), RB::ProtobufDecoder::end_message((uint64_t)this), (uint64_t result = v7) == 0))
  {
    uint64_t result = 0;
    *((unsigned char *)this + 56) = 1;
    *(void *)this = *((void *)this + 1);
  }
  return result;
}

uint64_t *RB::Decoder::shared_field_f<RB::DisplayList::ClipNode,RB::DisplayList::ClipNode const* RB::Decoder::shared_field<RB::DisplayList::ClipNode>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType)::{lambda(RB::DisplayList::ClipNode&)#1}>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType,RB::DisplayList::ClipNode const* RB::Decoder::shared_field<RB::DisplayList::ClipNode>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType)::{lambda(RB::DisplayList::ClipNode&)#1} const&)::{lambda(RB::DisplayList::ClipNode&)#1}::operator()<RB::Decoder>(uint64_t a1, size_t **this)
{
  uint64_t field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
  if (!field)
  {
    unint64_t v6 = 0;
    unint64_t v7 = 0;
    goto LABEL_12;
  }
  unint64_t v5 = field;
  unint64_t v6 = 0;
  unint64_t v7 = 0;
  do
  {
    if ((v5 >> 3) == 2)
    {
      long long v15 = *(_OWORD *)this;
      RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v5);
      unint64_t v7 = v5;
    }
    else if ((v5 >> 3) == 1)
    {
      unint64_t v6 = RB::ProtobufDecoder::uint_field((uint64_t **)this, v5);
    }
    else
    {
      RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v5);
    }
    uint64_t result = (uint64_t *)RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
    unint64_t v5 = (unint64_t)result;
  }
  while (result);
  if (!(v6 >> 61))
  {
LABEL_12:
    float v9 = (uint64_t *)(v6 | (*(void *)a1 << 61));
    v17[0] = 0;
    uint64_t result = RB::UntypedTable::lookup((RB::UntypedTable *)(this + 10), v9, v17);
    size_t v10 = (uint64_t *)v17[0];
    **(void **)(a1 + 16) = result;
    if (v9 == v10) {
      return result;
    }
    long long v11 = v15;
    if (!v7)
    {
      RB::Decoder::saved_shared_field((uint64_t)this, *(void *)a1, v6, (uint64_t)v17);
      LOBYTE(v7) = v18;
      if (!v18) {
        return (uint64_t *)RB::UntypedTable::insert(this + 10, (size_t *)v9, **(size_t ***)(a1 + 16));
      }
      long long v11 = *(_OWORD *)v17;
    }
    uint64_t v12 = *(RB::DisplayList::ClipNode ***)(a1 + 16);
    long long v13 = *(_OWORD *)this;
    *(_OWORD *)this = v11;
    if ((v7 & 7) == 2)
    {
      long long v16 = v13;
      RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
      int v14 = (RB::DisplayList::ClipNode *)RB::Heap::emplace<RB::DisplayList::ClipNode>(this[8]);
      RB::DisplayList::ClipNode::decode(v14, this);
      *uint64_t v12 = v14;
      RB::ProtobufDecoder::end_message((uint64_t)this);
      long long v13 = v16;
    }
    else
    {
      *((unsigned char *)this + 56) = 1;
    }
    *(_OWORD *)this = v13;
    return (uint64_t *)RB::UntypedTable::insert(this + 10, (size_t *)v9, **(size_t ***)(a1 + 16));
  }
  return result;
}

_OWORD *RB::Heap::emplace<RB::DisplayList::ClipNode>(size_t *a1)
{
  uint64_t v1 = (_OWORD *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(v1 + 2) > a1[3]) {
    uint64_t v1 = (_OWORD *)RB::Heap::alloc_slow(a1, 0x20uLL, 7);
  }
  else {
    a1[2] = (size_t)(v1 + 2);
  }
  *uint64_t v1 = 0u;
  v1[1] = 0u;
  return v1;
}

_DWORD *RB::Heap::emplace<RB::Filter::ColorMatrix>(size_t *a1)
{
  uint64_t v1 = (_DWORD *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(v1 + 12) > a1[3]) {
    uint64_t v1 = (_DWORD *)RB::Heap::alloc_slow(a1, 0x30uLL, 7);
  }
  else {
    a1[2] = (size_t)(v1 + 12);
  }
  *uint64_t v1 = 0;
  RB::ColorMatrix::set_identity((RB::ColorMatrix *)(v1 + 2));
  return v1;
}

__n128 RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 80 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x50uLL, 15);
  }
  else {
    *((void *)this + 2) = v5 + 80;
  }
  *(void *)(v5 + 16) = 0;
  *(void *)(v5 + 24) = 0;
  *(void *)unint64_t v5 = &unk_26C4EBFC0;
  __n128 result = *(__n128 *)a2;
  long long v7 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 48) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v5 + 64) = v7;
  *(__n128 *)(v5 + 32) = result;
  return result;
}

__n128 RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 72 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 72;
  }
  *(void *)(v5 + 16) = 0;
  *(void *)(v5 + 24) = 0;
  *(void *)unint64_t v5 = &unk_26C4EBF30;
  __n128 result = *(__n128 *)a2;
  *(_OWORD *)(v5 + 44) = *(_OWORD *)(a2 + 12);
  *(__n128 *)(v5 + 32) = result;
  uint64_t v7 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  *(void *)(v5 + 64) = v7;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::Custom>,RB::Filter::Custom>(size_t *a1, uint64_t a2)
{
  uint64_t v3 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 240 > a1[3]) {
    uint64_t v3 = RB::Heap::alloc_slow(a1, 0xF0uLL, 15);
  }
  else {
    a1[2] = v3 + 240;
  }
  return RB::DisplayList::GenericFilter<RB::Filter::Custom>::GenericFilter(v3, a2);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::GenericFilter(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = &unk_26C4EC050;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)a2;
  *(void *)(a1 + 40) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 4;
  uint64_t v4 = *(void *)(a2 + 120);
  *(void *)(a1 + 144) = *(void *)(a2 + 112);
  *(void *)(a1 + 152) = v4;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 120) = 0;
  uint64_t v5 = *(void *)(a1 + 160);
  *(void *)(a1 + 160) = *(void *)(a2 + 128);
  *(void *)(a2 + 128) = v5;
  RB::vector<RB::CustomShader::Value,4ul,unsigned long>::swap_inline((long long *)(a1 + 48), (long long *)(a2 + 16));
  long long v6 = *(_OWORD *)(a2 + 144);
  long long v7 = *(_OWORD *)(a2 + 160);
  long long v8 = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(a1 + 208) = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(a1 + 224) = v8;
  *(_OWORD *)(a1 + 176) = v6;
  *(_OWORD *)(a1 + 192) = v7;
  return a1;
}

void sub_2141910EC(_Unwind_Exception *a1)
{
  long long v6 = *(void **)(v1 + 144);
  if (v6) {
    uint64_t v3 = *(const void ***)(v1 + 144);
  }
  if (*(void *)(v1 + 152))
  {
    unint64_t v7 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v3);
      ++v7;
      v3 += 3;
    }
    while (v7 < *(void *)(v1 + 152));
    long long v6 = *v4;
  }
  RB::DisplayList::GenericFilter<RB::Filter::Custom>::GenericFilter(v2, v6);
  _Unwind_Resume(a1);
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::Distance>,RB::Filter::Distance>(RB::Heap *this, uint64_t *a2)
{
  unint64_t v4 = *((void *)this + 3);
  uint64_t result = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (result + 48 > v4) {
    uint64_t result = RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 7);
  }
  else {
    *((void *)this + 2) = result + 48;
  }
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)uint64_t result = &unk_26C4EEF28;
  uint64_t v6 = *a2;
  *(_DWORD *)(result + 40) = *((_DWORD *)a2 + 2);
  *(void *)(result + 32) = v6;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::LayerClip,decltype(nullptr)>(RB::Heap *this, __n128 a2)
{
  unint64_t v3 = *((void *)this + 3);
  unint64_t v4 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v4 + 64 > v3) {
    unint64_t v4 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  }
  else {
    *((void *)this + 2) = v4 + 64;
  }
  a2.n128_u32[0] = 1.0;
  return RB::DisplayList::LayerClip::LayerClip(v4, 0, 0, a2);
}

uint64_t RB::Heap::emplace<RB::DisplayList::ItemClip,decltype(nullptr)>(RB::Heap *this, __n128 a2)
{
  unint64_t v3 = *((void *)this + 3);
  unint64_t v4 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v4 + 56 > v3) {
    unint64_t v4 = RB::Heap::alloc_slow((size_t *)this, 0x38uLL, 7);
  }
  else {
    *((void *)this + 2) = v4 + 56;
  }
  a2.n128_u32[0] = 1.0;
  return RB::DisplayList::ItemClip::ItemClip(v4, 0, 0, a2);
}

float RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)2>,RB::DisplayList::Metadata const*&,float>(RB::Heap *this, void *a2, float *a3)
{
  unint64_t v6 = *((void *)this + 3);
  unint64_t v7 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v7 + 16 > v6) {
    unint64_t v7 = RB::Heap::alloc_slow((size_t *)this, 0x10uLL, 7);
  }
  else {
    *((void *)this + 2) = v7 + 16;
  }
  *(void *)unint64_t v7 = *a2 | 2;
  float result = *a3;
  *(float *)(v7 + 8) = *a3;
  return result;
}

void *RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)3>,RB::DisplayList::Metadata const*&,RB::TextIdentity const*&>(RB::Heap *this, void *a2, uint64_t *a3)
{
  unint64_t v6 = *((void *)this + 3);
  float result = (void *)((*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > v6) {
    float result = (void *)RB::Heap::alloc_slow((size_t *)this, 0x10uLL, 7);
  }
  else {
    *((void *)this + 2) = result + 2;
  }
  uint64_t v8 = *a3;
  void *result = *a2 | 3;
  result[1] = v8;
  return result;
}

void *RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)1>,RB::DisplayList::Metadata const*&,RB::Transition *&>(RB::Heap *this, void *a2, uint64_t *a3)
{
  unint64_t v6 = *((void *)this + 3);
  float result = (void *)((*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > v6) {
    float result = (void *)RB::Heap::alloc_slow((size_t *)this, 0x10uLL, 7);
  }
  else {
    *((void *)this + 2) = result + 2;
  }
  uint64_t v8 = *a3;
  void *result = *a2 | 1;
  result[1] = v8;
  return result;
}

void *RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)0>,RB::DisplayList::Metadata const*&,RB::UUID *>(size_t *a1, void *a2, uint64_t *a3)
{
  uint64_t v5 = (void *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(v5 + 2) > a1[3]) {
    uint64_t v5 = (void *)RB::Heap::alloc_slow(a1, 0x10uLL, 7);
  }
  else {
    a1[2] = (size_t)(v5 + 2);
  }
  uint64_t v6 = *a3;
  *uint64_t v5 = *a2;
  v5[1] = v6;
  return v5;
}

uint64_t RB::Path::Mapper::quadto(uint64_t a1, float64x2_t a2, float64x2_t a3)
{
  *(float64x2_t *)(a1 + 336) = a3;
  *(unsigned char *)(a1 + 368) = 0;
  unint64_t v3 = *(float64x2_t **)(a1 + 320);
  if (v3)
  {
    float64x2_t v4 = v3[1];
    a2 = vmlaq_laneq_f64(vmlaq_n_f64(v3[2], *v3, a2.f64[0]), v4, a2, 1);
    a3 = vmlaq_laneq_f64(vmlaq_n_f64(v3[2], *v3, a3.f64[0]), v4, a3, 1);
  }
  return (*(uint64_t (**)(__n128, __n128))(**(void **)(a1 + 312) + 32))((__n128)a2, (__n128)a3);
}

uint64_t RB::Path::Mapper::StackItem::endpath(RB::Path::Mapper::StackItem *this)
{
  return (***((uint64_t (****)(void))this + 2))(*((void *)this + 2));
}

uint64_t RB::Path::Mapper::StackItem::closepath(uint64_t this)
{
  if (!*(unsigned char *)(this + 64))
  {
    uint64_t v1 = this;
    *(_OWORD *)(this + 32) = *(_OWORD *)(this + 48);
    this = (*(uint64_t (**)(void))(**(void **)(this + 16) + 8))(*(void *)(this + 16));
    *(unsigned char *)(v1 + 64) = 1;
  }
  return this;
}

uint64_t RB::Path::Mapper::StackItem::moveto(uint64_t a1, __n128 a2)
{
  *(__n128 *)(a1 + 32) = a2;
  *(unsigned char *)(a1 + 64) = 0;
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))();
}

uint64_t RB::Path::Mapper::StackItem::lineto(uint64_t a1, __n128 a2)
{
  *(__n128 *)(a1 + 32) = a2;
  *(unsigned char *)(a1 + 64) = 0;
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 24))();
}

uint64_t RB::Path::Mapper::StackItem::quadto(uint64_t a1, double a2, __n128 a3)
{
  *(__n128 *)(a1 + 32) = a3;
  *(unsigned char *)(a1 + 64) = 0;
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 32))();
}

uint64_t RB::Path::Mapper::StackItem::cubeto(uint64_t a1, double a2, double a3, __n128 a4)
{
  *(__n128 *)(a1 + 32) = a4;
  *(unsigned char *)(a1 + 64) = 0;
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 40))();
}

uint64_t RB::Path::Mapper::elt_quadto(uint64_t a1, float64x2_t *a2, float64x2_t a3, float64x2_t a4)
{
  if (a2)
  {
    float64x2_t v4 = a2[1];
    a4 = vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, a4.f64[0]), v4, a4, 1);
    a3 = vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, a3.f64[0]), v4, a3, 1);
  }
  uint64_t v5 = *(void *)(a1 + 328);
  if (!v5) {
    return RB::Path::Mapper::quadto(a1, a3, a4);
  }
  *(float64x2_t *)(v5 + 32) = a4;
  *(unsigned char *)(v5 + 64) = 0;
  return (*(uint64_t (**)(void))(**(void **)(v5 + 16) + 32))();
}

uint64_t RB::Path::Mapper::add_rect(__n128 *this, CGRect a2, float64x2_t *a3, int a4)
{
  CGFloat y = a2.origin.y;
  CGFloat height = a2.size.height;
  float64x2_t v8 = vaddq_f64((float64x2_t)a2.origin, (float64x2_t)a2.size);
  float64x2_t v9 = vminnmq_f64((float64x2_t)a2.origin, v8);
  float64x2_t v10 = vmaxnmq_f64((float64x2_t)a2.origin, v8);
  float64x2_t v16 = v9;
  float64x2_t v17 = v10;
  if (a4)
  {
    RB::Path::Mapper::elt_moveto(this, a3, v9);
    v11.f64[0] = v17.f64[0];
    v11.f64[1] = v16.f64[1];
    RB::Path::Mapper::elt_lineto(this, a3, v11);
    RB::Path::Mapper::elt_lineto(this, a3, v17);
    v12.f64[0] = v16.f64[0];
    float64_t v13 = v17.f64[1];
  }
  else
  {
    v10.f64[1] = vmuld_lane_f64(0.5, vaddq_f64(v10, v9), 1);
    RB::Path::Mapper::elt_moveto(this, a3, v10);
    RB::Path::Mapper::elt_lineto(this, a3, v17);
    v14.f64[0] = v16.f64[0];
    v14.f64[1] = v17.f64[1];
    RB::Path::Mapper::elt_lineto(this, a3, v14);
    RB::Path::Mapper::elt_lineto(this, a3, v16);
    float64_t v13 = v16.f64[1];
    v12.f64[0] = v17.f64[0];
  }
  v12.f64[1] = v13;
  RB::Path::Mapper::elt_lineto(this, a3, v12);
  return RB::Path::Mapper::elt_closepath((uint64_t)this);
}

uint64_t RB::Path::Mapper::add_arc(__n128 *a1, int a2, CGAffineTransform *a3, float64x2_t a4, double a5, double a6, double a7)
{
  unint64_t v7 = a1[20].n128_u64[1];
  if (v7) {
    float64x2_t v8 = (__n128 *)(v7 + 64);
  }
  else {
    float64x2_t v8 = a1 + 23;
  }
  if (v8->n128_u8[0])
  {
    double v9 = a7 + -6.28318531;
    if (a6 == 0.0 && a7 >= 6.28318531 && v9 < 0.00001 && a2 != 0)
    {
      double v11 = a5 + a5;
      a4.f64[0] = a4.f64[0] - a5;
      double v12 = a4.f64[1] - a5;
      double v13 = v11;
      int v14 = 1;
      return RB::Path::Mapper::add_ellipse(a1, *(CGRect *)a4.f64, v14, a3);
    }
    if (a6 == 0.0 && fabs(v9) < 0.00000999999975 && a2 == 0)
    {
      double v11 = a5 + a5;
      a4.f64[0] = a4.f64[0] - a5;
      double v12 = a4.f64[1] - a5;
      double v13 = v11;
      int v14 = 0;
      return RB::Path::Mapper::add_ellipse(a1, *(CGRect *)a4.f64, v14, a3);
    }
  }
  if (a2)
  {
    if (a6 < a7) {
      a6 = a6 + ceil((a7 - a6) * 0.159154943) * 6.28318531;
    }
  }
  else if (a7 < a6)
  {
    a7 = a7 + ceil((a6 - a7) * 0.159154943) * 6.28318531;
  }
  return RB::Path::Mapper::add_relative_arc(a1, (float64x2_t *)a3, a4, a5, a6, a7 - a6);
}

uint64_t RB::Path::Mapper::add_arc_to_point(__n128 *a1, int8x16_t *a2, float64x2_t a3, float64x2_t a4, double a5)
{
  float64x2_t v6 = a4;
  unint64_t v8 = a1[20].n128_u64[1];
  if (v8) {
    double v9 = (__n128 *)(v8 + 32);
  }
  else {
    double v9 = a1 + 21;
  }
  float64x2_t v10 = *(float64x2_t *)v9;
  if (a2)
  {
    int8x16_t v33 = a2[1];
    int8x16_t v34 = *a2;
    int8x16_t v35 = a2[2];
    int8x16_t v46 = *a2;
    int8x16_t v47 = v33;
    int8x16_t v48 = v35;
    float64x2_t v44 = v10;
    float64x2_t v38 = a3;
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v46)) {
      unint64_t v11 = -1;
    }
    else {
      unint64_t v11 = 0;
    }
    int8x16_t v12 = (int8x16_t)vdupq_n_s64(v11);
    float64x2_t v6 = a4;
    float64x2_t v10 = vmlaq_laneq_f64(vmlaq_n_f64((float64x2_t)vbslq_s8(v12, v48, v35), (float64x2_t)vbslq_s8(v12, v46, v34), v44.f64[0]), (float64x2_t)vbslq_s8(v12, v47, v33), v44, 1);
    a3 = v38;
  }
  float64x2_t v13 = vsubq_f64(a3, v10);
  int8x16_t v14 = (int8x16_t)vceqzq_f64(v13);
  float64x2_t v45 = v10;
  float64x2_t v15 = vsubq_f64(v6, v10);
  long long v36 = xmmword_2142181D0;
  double v16 = 0.0;
  if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v14), 1), v14).u64[0] & 0x8000000000000000) != 0)
  {
    float64x2_t v39 = v13;
    float64x2_t v42 = v15;
    double v19 = atan2(v13.f64[1], v13.f64[0]);
    double v18 = v19;
    if (v19 == 0.0)
    {
      int v17 = 0;
      float64x2_t v13 = v39;
      float64x2_t v15 = v42;
    }
    else
    {
      __double2 v21 = __sincos_stret(v19);
      v20.f64[0] = v21.__cosval;
      v20.f64[1] = -v21.__sinval;
      long long v36 = (__int128)v21;
      float64x2_t v22 = vmlaq_n_f64(vmulq_laneq_f64((float64x2_t)v21, v42, 1), v20, v42.f64[0]);
      int v17 = 1;
      float64x2_t v13 = vmlaq_n_f64(vmulq_laneq_f64((float64x2_t)v21, v39, 1), v20, v39.f64[0]);
      float64x2_t v15 = v22;
    }
  }
  else
  {
    int v17 = 0;
    a5 = 0.0;
    double v18 = 0.0;
  }
  float64x2_t v40 = v13;
  float64x2_t v43 = v15;
  int8x16_t v23 = (int8x16_t)vceqq_f64(v13, v15);
  if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v23), 1), v23).u64[0] & 0x8000000000000000) != 0)
  {
    float64x2_t v24 = vsubq_f64(v15, v13);
    double v16 = 3.14159265 - fabs(atan2(v24.f64[1], v24.f64[0]));
  }
  __double2 v25 = __sincos_stret(v16 * 0.5);
  double v26 = 0.0;
  double v27 = 0.0;
  double v28 = 0.0;
  float64x2_t v29 = v40;
  if (v25.__sinval == 0.0)
  {
    if (v17)
    {
LABEL_18:
      float64x2_t v30 = (float64x2_t)v36;
      float64x2_t v31 = vmulq_n_f64((float64x2_t)vextq_s8((int8x16_t)v30, (int8x16_t)v30, 8uLL), v29.f64[0]);
      v30.f64[0] = -*(double *)&v36;
      double v27 = v27 + v18;
      double v28 = v28 + v18;
      float64x2_t v29 = vmlaq_laneq_f64(v31, v30, v29, 1);
    }
  }
  else
  {
    double v26 = a5;
    v29.f64[0] = v40.f64[0] - fabs(v25.__cosval / v25.__sinval) * a5;
    if (vmovn_s64(vcgtq_f64(v43, v40)).i32[1])
    {
      v29.f64[1] = a5;
      double v28 = 1.57079633 - v16;
      double v27 = -1.57079633;
    }
    else
    {
      v29.f64[1] = -a5;
      double v28 = v16 + -1.57079633;
      double v27 = 1.57079633;
    }
    if (v17) {
      goto LABEL_18;
    }
  }
  return RB::Path::Mapper::add_arc(a1, vmovn_s64((int64x2_t)vmvnq_s8((int8x16_t)vcgtq_f64(v43, v40))).i32[1] & 1, (CGAffineTransform *)a2, vaddq_f64(v29, v45), v26, v27, v28);
}

void RB::Path::Mapper::push_offset(RB::Path::Mapper *this, double a2)
{
}

void RB::Path::Mapper::push_stroke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(void *)(a2 + 8)) {
      operator new();
    }
  }
  operator new();
}

void RB::Path::Mapper::push_BOOLean()
{
}

void RB::Path::Mapper::push_clip_stroke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    rb_line_cap(*(_DWORD *)(a2 + 4));
  }
  operator new();
}

void RB::Path::Mapper::push_dilate_glyph()
{
}

void *RB::Path::DasherStroker::DasherStroker(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, float a7, float a8, float a9)
{
  *a1 = &unk_26C4E8208;
  float64x2_t v13 = a1 + 1;
  uint64_t v14 = MEMORY[0x263F000D0];
  CG::stroker::stroker(a1 + 1, MEMORY[0x263F000D0], a3, a4, a2, 0.0, a7, a8);
  CG::dasher::dasher(a1 + 32, v14, a6, a5, v13, a9);
  return a1;
}

uint64_t RB::Path::DasherStroker::endpath(RB::Path::DasherStroker *this)
{
  return CG::dasher::endpath((RB::Path::DasherStroker *)((char *)this + 256));
}

double RB::Path::DasherStroker::closepath(RB::Path::DasherStroker *this)
{
  *(void *)&double result = CG::dasher::closepath((RB::Path::DasherStroker *)((char *)this + 256)).n128_u64[0];
  return result;
}

double RB::Path::DasherStroker::moveto(uint64_t a1, __n128 a2)
{
  *(void *)&double result = CG::dasher::moveto(a1 + 256, a2).n128_u64[0];
  return result;
}

double RB::Path::DasherStroker::lineto(uint64_t a1, float64x2_t a2)
{
  *(void *)&double result = CG::dasher::lineto(a1 + 256, a2).n128_u64[0];
  return result;
}

double RB::Path::DasherStroker::quadto(const Point *a1, __n128 a2, __n128 a3)
{
  return CG::dasher::quadto(a1 + 64, a2, a3);
}

double RB::Path::DasherStroker::cubeto(const Point *a1, __n128 a2, __n128 a3, __n128 a4)
{
  return CG::dasher::cubeto(a1 + 64, a2, a3, a4);
}

_DWORD *RB::RenderTask::set_parent(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = a2;
  double result = *(_DWORD **)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = result;
  if (result != (_DWORD *)a1)
  {
    if (result)
    {
      int v5 = result[2] - 1;
      result[2] = v5;
      if (!v5) {
        double result = (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(void *)result + 8))(result);
      }
    }
    ++*(_DWORD *)(a1 + 8);
    *(void *)(a2 + 32) = a1;
  }
  return result;
}

double RB::RenderTask::set_continuation(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 73) |= 1u;
  float64x2_t v4 = *(_DWORD **)(a2 + 24);
  if (v4 != (_DWORD *)a1)
  {
    if (v4)
    {
      int v5 = v4[2] - 1;
      v4[2] = v5;
      if (!v5) {
        (*(void (**)(_DWORD *))(*(void *)v4 + 8))(v4);
      }
    }
    ++*(_DWORD *)(a1 + 8);
    *(void *)(a2 + 24) = a1;
  }
  unint64_t v7 = *(_DWORD **)(a1 + 88);
  if (v7)
  {
    unint64_t v8 = *(_DWORD **)(a2 + 88);
    if (v8 != v7)
    {
      if (!v8
        || (int v9 = v8[2] - 1, (v8[2] = v9) != 0)
        || ((*(void (**)(_DWORD *))(*(void *)v8 + 8))(v8), (unint64_t v7 = *(_DWORD **)(a1 + 88)) != 0))
      {
        ++v7[2];
      }
      *(void *)(a2 + 88) = v7;
    }
    double result = *(double *)(a1 + 64);
    *(double *)(a2 + 64) = result;
  }
  return result;
}

uint64_t RB::RenderTask::bytes(RB::RenderTask *this, MTLPixelFormat a2)
{
  signed __int32 v2 = vmul_lane_s32(*(int32x2_t *)((char *)this + 56), *(int32x2_t *)((char *)this + 56), 1).u32[0];
  return *((unsigned __int8 *)RB::pixel_format_traits(*((void *)this + 10), a2) + 6) * (uint64_t)v2;
}

void RB::RenderTask::print(RB::RenderTask *this, std::string *a2)
{
  RB::SexpString::push(a2, "task");
  int v4 = HIDWORD(*((void *)this + 7));
  int v5 = *((void *)this + 7);
  int v6 = *((_DWORD *)this + 3);
  unint64_t v8 = RB::pixel_format_name(*((RB **)this + 10), v7);
  int v9 = RB::color_space_name(*((unsigned __int8 *)this + 72));
  RB::SexpString::printf(a2, 0, "%p [%d %d] @%u %s %s", this, v5, v4, v6, v8, v9);
  if (*((void *)this + 11))
  {
    RB::SexpString::push(a2, "texture");
    RB::SexpString::printf(a2, 0, "%p (offset %d %d)", *((const void **)this + 11), *((void *)this + 8), HIDWORD(*((void *)this + 8)));
    RB::SexpString::pop(a2);
  }
  if (*((void *)this + 4))
  {
    RB::SexpString::push(a2, "children");
    for (float i = (RB::RenderTask *)*((void *)this + 4); i; float i = (RB::RenderTask *)*((void *)i + 5))
      RB::RenderTask::print(i, (RB::SexpString *)a2);
    RB::SexpString::pop(a2);
  }
  if (*((void *)this + 3))
  {
    RB::SexpString::push(a2, "continuation-of");
    RB::RenderTask::print(*((RB::RenderTask **)this + 3), (RB::SexpString *)a2);
    RB::SexpString::pop(a2);
  }
  RB::SexpString::pop(a2);
}

void RB::Filter::RenderGroup::~RenderGroup(RB::Filter::RenderGroup *this)
{
  signed __int32 v2 = (uint64_t *)*((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  if (v3)
  {
    unint64_t v4 = 0;
    int v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      *int v5 = 0;
      if (v6)
      {
        (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        unint64_t v3 = *((void *)this + 2);
      }
      ++v4;
      v5 += 7;
    }
    while (v4 < v3);
    signed __int32 v2 = (uint64_t *)*((void *)this + 1);
  }
  if (v2) {
    free(v2);
  }
}

void *RB::vector<RB::RenderTask *,32ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 67) + (*((_DWORD *)__dst + 67) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 67) + (*((_DWORD *)__dst + 67) >> 1);
  }
  double result = RB::details::realloc_vector<unsigned int,8ul>(*((void **)__dst + 32), __dst, 0x20u, (_DWORD *)__dst + 67, v3);
  *((void *)__dst + 32) = result;
  return result;
}

void RBFillData::~RBFillData(RBFillData *this)
{
  RBFillData::apply<RB::DestroyAny>(&this->type, (uint64_t)&v2);
  this->type = 0;
}

unint64_t RBFillData::decode(RBFillData *this, RB::Heap **a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
  if (result)
  {
    unint64_t v5 = result;
    uint64_t v6 = &this->data[12];
    __asm { FMOV            V9.2S, #1.0 }
    while (2)
    {
      switch((v5 >> 3))
      {
        case 1u:
          RBFillData::apply<RB::DestroyAny>(&this->type, (uint64_t)&v16);
          *(void *)&this->data[12] = 0x3C00000000000000;
          *(_WORD *)&this->data[20] = 0;
          this->type = 1;
          if ((v5 & 7) != 2) {
            goto LABEL_18;
          }
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          RB::Fill::Color::decode((uint64_t)&this->data[12], (RB::ProtobufDecoder *)a2);
          goto LABEL_15;
        case 2u:
          RBFillData::apply<RB::DestroyAny>(&this->type, (uint64_t)&v16);
          *(void *)&this->data[59] = 0;
          *(_OWORD *)&this->data[28] = 0u;
          *(_OWORD *)&this->data[44] = 0u;
          *(_OWORD *)uint64_t v6 = 0u;
          *(_WORD *)&this->data[67] = 1;
          this->type = 2;
          if ((v5 & 7) != 2) {
            goto LABEL_18;
          }
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          RB::Fill::Gradient::decode((RB::Fill::Gradient *)&this->data[12], a2);
          goto LABEL_15;
        case 3u:
          RB::ImageTexture::ImageTexture((RB::ImageTexture *)v13, 0, 0);
          int8x16_t v12 = a2[8];
          RBFillData::apply<RB::DestroyAny>(&this->type, (uint64_t)&v16);
          this->type = 0;
          RB::ImageTexture::ImageTexture((RB::ImageTexture *)&this->data[12], (const RB::ImageTexture *)v13, v12);
          *(void *)&this->data[28] = 0;
          *(void *)&this->data[36] = _D9;
          *(void *)&this->data[44] = 0;
          *(void *)&this->data[52] = 0;
          *(_OWORD *)&this->data[60] = xmmword_214218320;
          *(_OWORD *)&this->data[76] = xmmword_214218320;
          *(_DWORD *)&this->data[92] = 1065353216;
          *(void *)&this->data[96] = 0x3C003C003C003C00;
          *(_DWORD *)&this->data[104] = 0x1000000;
          this->type = 4;
          if ((v5 & 7) != 2) {
            goto LABEL_18;
          }
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          RB::Fill::ImageData::decode((RB::Fill::ImageData *)&this->data[28], (RB::Decoder *)a2, (uint64_t)&v16);
          long long v14 = v16;
          uint64_t v15 = v17;
          RB::ImageTexture::decode((uint64_t)&this->data[12], (RB::ProtobufDecoder *)a2, (uint64_t)&v14);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
          goto LABEL_16;
        case 4u:
          RBFillData::apply<RB::DestroyAny>(&this->type, (uint64_t)&v16);
          *(void *)&this->data[12] = 0;
          *(void *)&this->data[116] = 0;
          *(void *)&this->data[124] = 0;
          *(void *)&this->data[132] = 4;
          *(_OWORD *)&this->data[140] = xmmword_2142181C0;
          *(_OWORD *)&this->data[156] = xmmword_2142181D0;
          *(_OWORD *)&this->data[172] = 0u;
          *(_OWORD *)&this->data[188] = 0u;
          *(_DWORD *)&this->data[204] = 0;
          this->type = 5;
          if ((v5 & 7) != 2) {
            goto LABEL_18;
          }
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          RB::Fill::Custom::decode((RB::Fill::Custom *)&this->data[12], (RB::Decoder *)a2);
          goto LABEL_15;
        case 5u:
          RBFillData::apply<RB::DestroyAny>(&this->type, (uint64_t)&v16);
          *(_WORD *)&this->data[44] = 0;
          *(_OWORD *)uint64_t v6 = 0u;
          *(_OWORD *)&this->data[28] = 0u;
          *(_DWORD *)&this->data[46] = 15360;
          this->data[50] = 0;
          this->data[51] = this->data[51] & 0xE0 | 0x10;
          this->data[52] = 0;
          this->type = 3;
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
            RB::Fill::MeshGradient::decode((RB::Fill::MeshGradient *)&this->data[12], a2);
LABEL_15:
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
LABEL_18:
            *((unsigned char *)a2 + 56) = 1;
            *a2 = a2[1];
          }
LABEL_16:
          unint64_t result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
          unint64_t v5 = result;
          if (!result) {
            return result;
          }
          continue;
        default:
          RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, v5);
          goto LABEL_16;
      }
    }
  }
  return result;
}

atomic_uint *RB::DestroyAny::operator()<RB::Fill::Custom>(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(void **)(a2 + 104);
  if (v3) {
    unint64_t v4 = *(const void ***)(a2 + 104);
  }
  else {
    unint64_t v4 = (const void **)(a2 + 8);
  }
  if (*(void *)(a2 + 112))
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < *(void *)(a2 + 112));
    unsigned int v3 = *(void **)(a2 + 104);
  }
  if (v3) {
    free(v3);
  }
  unint64_t result = *(atomic_uint **)a2;
  if (*(void *)a2 && atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    MTLPixelFormat v7 = *(uint64_t (**)(void))(*(void *)result + 8);
    return (atomic_uint *)v7();
  }
  return result;
}

int32x2_t *RB::Bounds::Union(int32x2_t *result, int32x2_t a2, int32x2_t a3)
{
  uint32x2_t v3 = (uint32x2_t)vceqz_s32(a3);
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) == 0)
  {
    int32x2_t v4 = result[1];
    uint32x2_t v5 = (uint32x2_t)vceqz_s32(v4);
    if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) != 0)
    {
      atomic_uint *result = a2;
    }
    else
    {
      int32x2_t v6 = vmin_s32(*result, a2);
      int32x2_t v7 = vmax_s32(vadd_s32(*result, v4), vadd_s32(a3, a2));
      atomic_uint *result = v6;
      a3 = vsub_s32(v7, v6);
    }
    result[1] = a3;
  }
  return result;
}

BOOL RB::Bounds::inset(int32x2_t *this, unsigned int a2, unsigned int a3, double a4, double a5, double a6, int32x2_t a7)
{
  int32x2_t v7 = this[1];
  uint32x2_t v8 = (uint32x2_t)vceq_s32(v7, (int32x2_t)0x8000000080000000);
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) != 0) {
    return 1;
  }
  int32x2_t v9 = vsub_s32(v7, vadd_s32((int32x2_t)__PAIR64__(a3, a2), (int32x2_t)__PAIR64__(a3, a2)));
  uint32x2_t v10 = (uint32x2_t)vcltz_s32(v9);
  int32x2_t v11 = (int32x2_t)vpmax_u32(v10, v10);
  a7.i32[0] = -1;
  __int32 v12 = v11.i32[0];
  int8x8_t v13 = (int8x8_t)vdup_lane_s32(vcgt_s32(v11, a7), 0);
  BOOL v14 = v12 >= 0;
  *this = vadd_s32(*this, (int32x2_t)vbsl_s8(v13, (int8x8_t)__PAIR64__(a3, a2), (int8x8_t)vshr_n_s32(v9, 1uLL)));
  this[1] = (int32x2_t)vand_s8((int8x8_t)v9, v13);
  return v14;
}

double RB::BoundsAccumulator::reset(RB::BoundsAccumulator *this)
{
  double result = 0.0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

int *RB::BoundsAccumulator::add(int *this, int32x2_t *a2)
{
  int32x2_t v2 = a2[1];
  uint32x2_t v3 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v2);
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) != 0) {
    return this;
  }
  unsigned __int32 v4 = vmul_lane_s32(v2, v2, 1).u32[0];
  int v5 = *this;
  unsigned int v6 = this[1];
  int32x2_t v7 = this + 2;
  uint64_t v8 = 0xFFFFFFFFLL;
  uint64_t v9 = v6;
  do
  {
    if (v9 == v5) {
      goto LABEL_40;
    }
    int v10 = v5 + ((((int)v9 - 1) * (int)v9) >> 1);
    if ((int)v9 < v5) {
      int v10 = v9 + (((v5 - 1) * v5) >> 1);
    }
    int32x2_t v11 = &v7[4 * v9];
    __int32 v12 = &this[v10 + 18];
    int v14 = *v11;
    int v13 = v11[1];
    int v15 = v13 - *v11;
    uint64_t v16 = v9;
    if (v15 < 1) {
      goto LABEL_21;
    }
    int v17 = HIDWORD(*(unint64_t *)a2);
    int32x2_t v18 = vadd_s32(a2[1], *a2);
    int v19 = (int)*a2;
    int v21 = v11[2];
    int v20 = v11[3];
    if (v14 >= v19) {
      int v22 = (int)*a2;
    }
    else {
      int v22 = v14;
    }
    if (v13 <= v18.i32[0]) {
      int v23 = v18.i32[0];
    }
    else {
      int v23 = v13;
    }
    int v24 = v23 - v22;
    if (v21 >= v17) {
      int v25 = HIDWORD(*(unint64_t *)a2);
    }
    else {
      int v25 = v21;
    }
    if (v20 <= v18.i32[1]) {
      int v26 = v18.i32[1];
    }
    else {
      int v26 = v20;
    }
    int v27 = (v26 - v25) * v24 - (v4 + (v20 - v21) * v15);
    if (!v27)
    {
      uint64_t v16 = v8;
LABEL_21:
      *__int32 v12 = 0;
      uint64_t v8 = v16;
      goto LABEL_40;
    }
    if (v20 >= v18.i32[1]) {
      int v20 = v18.i32[1];
    }
    if (v21 > v17) {
      int v17 = v21;
    }
    int v28 = v20 - v17;
    if (v13 >= v18.i32[0]) {
      int v13 = v18.i32[0];
    }
    if (v14 <= v19) {
      int v14 = (int)*a2;
    }
    int v29 = v13 - v14;
    int v30 = v28 * v29;
    if (v28 <= 0 || v29 <= 0) {
      int v32 = 0;
    }
    else {
      int v32 = v28 * v29;
    }
    int v33 = v32 + v27;
    *__int32 v12 = v33;
    if (v33) {
      BOOL v34 = 0;
    }
    else {
      BOOL v34 = v30 == v4;
    }
    if (v34)
    {
      this[1] = v9;
      return this;
    }
LABEL_40:
    if (v9 == 3) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = (v9 + 1);
    }
  }
  while (v9 != v6);
  if ((int)v8 >= 1)
  {
    int8x16_t v35 = &v7[4 * v5];
    *int8x16_t v35 = *a2;
    v35[1] = *(void *)&a2[1] + *(void *)a2;
    v35[2] = a2->i32[1];
    v35[3] = a2[1].i32[1] + a2->i32[1];
    *this = v8;
    this[1] = v5;
    return this;
  }
  int v36 = v5 == 0;
  int v37 = 0x40000000;
  uint64_t v38 = 1;
  int v39 = v5;
  do
  {
    uint64_t v40 = 0;
    do
    {
      if (this[((((int)v38 - 1) * (int)v38) >> 1) + 18 + v40] < v37)
      {
        int v36 = v40;
        int v37 = this[((((int)v38 - 1) * (int)v38) >> 1) + 18 + v40];
        int v39 = v38;
      }
      ++v40;
    }
    while (v38 != v40);
    ++v38;
  }
  while (v38 != 4);
  int v41 = HIDWORD(*(unint64_t *)a2);
  int32x2_t v42 = vadd_s32(a2[1], *a2);
  int v43 = (int)*a2;
  __int32 v44 = v42.i32[1];
  __int32 v45 = v42.i32[0];
  if (v36 == v5)
  {
    int v36 = v39;
    goto LABEL_55;
  }
  if (v39 == v5)
  {
LABEL_55:
    int v39 = v5;
  }
  else
  {
    int8x16_t v46 = &v7[4 * v5];
    *int8x16_t v46 = v43;
    v46[1] = v42.i32[0];
    v46[2] = v41;
    v46[3] = v42.i32[1];
    int8x16_t v47 = &v7[4 * v39];
    int v43 = *v47;
    __int32 v45 = v47[1];
    int v41 = v47[2];
    __int32 v44 = v47[3];
    *(void *)int8x16_t v47 = 0;
    *((void *)v47 + 1) = 0;
  }
  int8x16_t v48 = &v7[4 * v36];
  *this = v39;
  int v49 = *v48;
  __int32 v50 = v48[1];
  if (*v48 > v43)
  {
    int *v48 = v43;
    int v49 = v43;
  }
  int v51 = v48[2];
  if (v50 < v45)
  {
    v48[1] = v45;
    __int32 v50 = v45;
  }
  __int32 v52 = v48[3];
  if (v51 > v41)
  {
    v48[2] = v41;
    int v51 = v41;
  }
  this[1] = v36;
  if (v52 < v44)
  {
    v48[3] = v44;
    __int32 v52 = v44;
  }
  uint64_t v53 = 0;
  uint64_t v54 = this + 3;
  do
  {
    if (v36 != v53)
    {
      int v55 = v36 + ((((int)v53 - 1) * (int)v53) >> 1);
      if (v53 < v36) {
        int v55 = (((v36 - 1) * v36) >> 1) + v53;
      }
      int v56 = *(v54 - 1);
      __int32 v57 = *v54;
      int v58 = *v54 - v56;
      if (v58 < 1)
      {
        int v72 = 0;
      }
      else
      {
        int v59 = v54[1];
        __int32 v60 = v54[2];
        if (v56 >= v49) {
          int v61 = v49;
        }
        else {
          int v61 = *(v54 - 1);
        }
        if (v57 <= v50) {
          __int32 v62 = v50;
        }
        else {
          __int32 v62 = *v54;
        }
        int v63 = v62 - v61;
        if (v59 >= v51) {
          int v64 = v51;
        }
        else {
          int v64 = v54[1];
        }
        if (v60 <= v52) {
          __int32 v65 = v52;
        }
        else {
          __int32 v65 = v54[2];
        }
        int v66 = (v52 - v51) * (v50 - v49) + (v60 - v59) * v58;
        int v67 = (v65 - v64) * v63;
        if (v60 >= v52) {
          __int32 v60 = v52;
        }
        if (v59 <= v51) {
          int v59 = v51;
        }
        int v68 = v60 - v59;
        if (v57 >= v50) {
          __int32 v57 = v50;
        }
        if (v56 <= v49) {
          int v56 = v49;
        }
        int v69 = v57 - v56;
        if (v68 <= 0 || v69 <= 0) {
          int v71 = 0;
        }
        else {
          int v71 = v68 * v69;
        }
        int v72 = v67 - v66 + v71;
        if (v67 == v66) {
          int v72 = 0;
        }
      }
      this[v55 + 18] = v72;
    }
    ++v53;
    v54 += 4;
  }
  while (v53 != 4);
  return this;
}

BOOL RB::BoundsAccumulator::intersects(RB::BoundsAccumulator *this, int32x2_t *a2, double a3, double a4, double a5, double a6, double a7, int32x2_t a8)
{
  unint64_t v8 = 0;
  int32x2_t v9 = a2[1];
  uint32x2_t v10 = (uint32x2_t)vceqz_s32(v9);
  int32x2_t v11 = vadd_s32(v9, *a2);
  __int32 v12 = (int32x2_t *)((char *)this + 16);
  BOOL v13 = 1;
  unsigned __int32 v14 = vpmax_u32(v10, v10).u32[0];
  do
  {
    int32x2_t v15 = vsub_s32(vdup_lane_s32(*v12, 1), *v12);
    if (v12[-1].i32[1] - v12[-1].i32[0] >= 1 && v15.i32[0] >= 1 && (v14 & 0x80000000) == 0)
    {
      a8.i32[0] = v12[-1].i32[1] - v12[-1].i32[0];
      int32x2_t v17 = vzip1_s32(a8, v15);
      uint32x2_t v18 = (uint32x2_t)vceqz_s32(v17);
      a8 = (int32x2_t)vpmax_u32(v18, v18);
      if ((a8.i32[0] & 0x80000000) == 0)
      {
        a8.i32[0] = v12[-1].i32[0];
        int32x2_t v19 = vzip1_s32(a8, *v12);
        a8 = vmax_s32(v19, *a2);
        uint32x2_t v20 = (uint32x2_t)vcge_s32(a8, vmin_s32(vadd_s32(v17, v19), v11));
        if ((vpmax_u32(v20, v20).u32[0] & 0x80000000) == 0) {
          break;
        }
      }
    }
    BOOL v13 = v8 < 3;
    v12 += 2;
    ++v8;
  }
  while (v8 != 4);
  return v13;
}

void sub_214194290(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v2);

  _Unwind_Resume(a1);
}

void sub_21419444C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_214195714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, os_unfair_lock_s *lock, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, CFTypeRef cf, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  RB::Symbol::Presentation::~Presentation((RB::Symbol::Presentation *)&a65);
  os_unfair_lock_unlock(lock);
  _Unwind_Resume(a1);
}

void sub_214195944(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

_anonymous_namespace_::Updater *anonymous namespace'::Updater::Updater(_anonymous_namespace_::Updater *this, RBSymbolLayer *a2, RB::Symbol::Animator *a3)
{
  *(void *)this = a2;
  int v5 = (_anonymous_namespace_::Updater *)((char *)this + 16);
  RB::Symbol::Presentation::Presentation((char *)this + 16, a3, 0, 0, 255, 0, (__n128)0);
  long long v6 = 0uLL;
  long long v7 = 0uLL;
  long long v8 = 0uLL;
  if (a2)
  {
    long long v6 = *((_OWORD *)a2 + 6);
    *(void *)&long long v8 = *((void *)a2 + 10);
    *((void *)&v7 + 1) = *((void *)a2 + 11);
  }
  *((_OWORD *)this + 131) = v8;
  *((_OWORD *)this + 132) = v7;
  *((_OWORD *)this + 133) = v6;
  [(RBSymbolLayer *)a2 contentsScale];
  *((double *)this + 272) = v9;
  double v13 = RB::Symbol::Presentation::bounding_rect(v5, v9, v10, v11, v12);
  uint64_t v15 = v14;
  v24[1] = (float64x2_t)v16;
  void v24[2] = v17;
  v16.i64[0] = v15;
  float32x2_t v25 = RB::operator*(v24, *(float32x2_t *)&v13, v16);
  uint64_t v26 = v18.i64[0];
  float v19 = *((double *)this + 272);
  RB::Rect::round_outwards_by_scale(&v25, v19, v18);
  float32x2_t v20 = (float32x2_t)v26;
  *((float64x2_t *)this + 134) = vcvtq_f64_f32(v25);
  *((float64x2_t *)this + 135) = vcvtq_f64_f32(v20);
  uint32x2_t v21 = (uint32x2_t)vclez_f32(v20);
  BOOL v22 = (vpmax_u32(v21, v21).u32[0] & 0x80000000) != 0 || *((double *)this + 272) == 0.0 || *((_DWORD *)this + 216) == 0;
  *((unsigned char *)this + 2184) = v22;
  return this;
}

void sub_214195A90(_Unwind_Exception *a1)
{
  RB::Symbol::Presentation::~Presentation(v1);
  _Unwind_Resume(a1);
}

void sub_214195D34(_Unwind_Exception *a1)
{
  RB::Symbol::Presentation::~Presentation(v1);
  _Unwind_Resume(a1);
}

__n128 anonymous namespace'::Updater::drawing_transform(RB::Symbol::Model **this, CALayer *a2)
{
  if (a2 && ![(CALayer *)a2 contentsAreFlipped]) {
    return *((__n128 *)this + 131);
  }
  else {
    return *((__n128 *)this + 131);
  }
}

void sub_21419606C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2141961F8(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN12_GLOBAL__N_17Updater13update_mergedEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [**(id **)(a1 + 32) resolveStyle:a2 colorName:a3];
}

void ___ZN12_GLOBAL__N_17Updater13update_mergedEv_block_invoke_2(void *a1, uint64_t a2)
{
  uint32x2_t v3 = (RB::Symbol::Model **)a1[6];
  State = (RB::DisplayList::State *)RBDisplayListGetState(a2);
  v7[1] = v5;
  float64x2_t v7[2] = v6;
  RBDrawingStateConcatCTM((uint64_t)State, (uint64_t)v7);
  RB::Symbol::Presentation::draw((uint64_t)(v3 + 2), State, a1[5]);
}

uint64_t color_symbols(void)
{
  {
    unsigned int v2 = (unsigned __int16)RB::debug_BOOL((RB *)"RB_COLOR_SYMBOLS", v1);
    if (v2 <= 0x100) {
      LOBYTE(v2) = 0;
    }
    color_symbols(void)::flag = v2 != 0;
  }
  return color_symbols(void)::flag;
}

void sub_214196344(_Unwind_Exception *a1)
{
}

char *RB::vector<anonymous namespace'::Updater::update_shape_layers(BOOL)::Group,2ul,unsigned long>::~vector(char *a1)
{
  unsigned int v2 = (char *)*((void *)a1 + 104);
  if (v2) {
    uint32x2_t v3 = v2;
  }
  else {
    uint32x2_t v3 = a1;
  }
  if (*((void *)a1 + 105))
  {
    unint64_t v4 = 0;
    do
    {
      long long v5 = &v3[416 * v4];
      long long v6 = (void *)*((void *)v5 + 48);
      unint64_t v7 = *((void *)v5 + 49);
      if (v6) {
        long long v8 = (char *)*((void *)v5 + 48);
      }
      else {
        long long v8 = &v3[416 * v4];
      }
      if (v7)
      {
        unint64_t v9 = 0;
        double v10 = (CFTypeRef *)(v8 + 16);
        do
        {
          if (*v10)
          {
            CFRelease(*v10);
            unint64_t v7 = *((void *)v5 + 49);
          }
          ++v9;
          v10 += 12;
        }
        while (v9 < v7);
        long long v6 = (void *)*((void *)v5 + 48);
      }
      if (v6) {
        free(v6);
      }
      ++v4;
    }
    while (v4 < *((void *)a1 + 105));
    unsigned int v2 = (char *)*((void *)a1 + 104);
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

void *RB::vector<anonymous namespace'::Updater::update_shape_layers(BOOL)::Group,2ul,unsigned long>::reserve_slow(void *__dst, unint64_t a2)
{
  if (*((void *)__dst + 106) + (*((void *)__dst + 106) >> 1) <= a2) {
    unint64_t v3 = a2;
  }
  else {
    unint64_t v3 = *((void *)__dst + 106) + (*((void *)__dst + 106) >> 1);
  }
  double result = RB::details::realloc_vector<unsigned long,416ul>(*((void **)__dst + 104), __dst, 2uLL, (unint64_t *)__dst + 106, v3);
  *((void *)__dst + 104) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,416ul>(void *__src, void *__dst, unint64_t a3, unint64_t *a4, unint64_t a5)
{
  unint64_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      unint64_t v9 = a3;
      memcpy(__dst, __src, 416 * a5);
      free(v7);
      int32x4_t v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(416 * a5);
    unint64_t v9 = v8 / 0x1A0;
    if (v8 / 0x1A0 != *a4)
    {
      double v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      int32x4_t v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 416 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

void *RB::vector<anonymous namespace'::Updater::update_shape_layers(BOOL)::LayerPath,4ul,unsigned long>::reserve_slow(void *__dst, unint64_t a2)
{
  if (*((void *)__dst + 50) + (*((void *)__dst + 50) >> 1) <= a2) {
    unint64_t v3 = a2;
  }
  else {
    unint64_t v3 = *((void *)__dst + 50) + (*((void *)__dst + 50) >> 1);
  }
  double result = RB::details::realloc_vector<unsigned long,96ul>(*((void **)__dst + 48), __dst, 4uLL, (unint64_t *)__dst + 50, v3);
  *((void *)__dst + 48) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,96ul>(void *__src, void *__dst, unint64_t a3, unint64_t *a4, unint64_t a5)
{
  unint64_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      unint64_t v9 = a3;
      memcpy(__dst, __src, 96 * a5);
      free(v7);
      int32x4_t v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(96 * a5);
    unint64_t v9 = v8 / 0x60;
    if (v8 / 0x60 != *a4)
    {
      double v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      int32x4_t v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 96 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t RB::DisplayList::Item::clip_affects_blurred_bounds(RB::DisplayList::Item *this, float a2)
{
  if (!*((void *)this + 3)) {
    return 0;
  }
  double v4 = (*(double (**)(RB::DisplayList::Item *, void))(*(void *)this + 144))(this, 0);
  double v7 = v4;
  double v8 = v5;
  *(float *)&double v4 = -ceilf(a2 * 2.8);
  RB::Rect::inset((float32x2_t *)&v7, *(float32x2_t *)&v4, *(float32_t *)&v4);
  return RB::DisplayList::ClipNode::contains(*((void **)this + 3), v7, v8) ^ 1;
}

uint64_t RB::DisplayList::Item::may_mix(RB::DisplayList::Item *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Item *a3, const RB::DisplayList::Style *a4)
{
  if (((*((_WORD *)a3 + 23) ^ *((_WORD *)this + 23)) & 0x3F) != 0) {
    return 0;
  }
  unsigned __int8 can_mix = RB::DisplayList::can_mix(a2, *((RB::DisplayList::Interpolator::Contents **)this + 2), *((void *)a3 + 2), a4);
  if (can_mix)
  {
    unsigned __int8 v9 = can_mix;
    unsigned int v10 = RB::DisplayList::can_mix((uint64_t)a2, *((float32x2_t **)this + 3), *((float32x2_t **)a3 + 3), (uint64_t)this, (uint64_t)a3);
    if (v10 >= v9) {
      uint64_t result = v9;
    }
    else {
      uint64_t result = v10;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  if (*((short float *)this + 22) != *((short float *)a3 + 22))
  {
    if (result >= 2) {
      return 2;
    }
    else {
      return result;
    }
  }
  return result;
}

uint64_t RB::DisplayList::Item::make_clip(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, __n128 a5)
{
  unsigned __int32 v14 = a5.n128_u32[0];
  unsigned int v13 = a3;
  long long v6 = (size_t *)(*(void *)(a2 + 8) + 16);
  uint64_t v12 = a1;
  uint64_t result = RB::Heap::emplace<RB::DisplayList::ItemClip,RB::DisplayList::Item *,float &,RB::ClipMode &>(v6, &v12, &v14, &v13, a5);
  uint64_t v8 = result;
  uint64_t v9 = a4[5];
  size_t v10 = v9 + 1;
  if (a4[6] < (unint64_t)(v9 + 1))
  {
    uint64_t result = (uint64_t)RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v10);
    uint64_t v9 = a4[5];
    size_t v10 = v9 + 1;
  }
  double v11 = (void *)a4[4];
  if (!v11) {
    double v11 = a4;
  }
  v11[v9] = v8;
  a4[5] = v10;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::ItemClip,RB::DisplayList::Item *,float &,RB::ClipMode &>(size_t *a1, uint64_t *a2, unsigned __int32 *a3, unsigned int *a4, __n128 a5)
{
  unint64_t v8 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v8 + 56 > a1[3]) {
    unint64_t v8 = RB::Heap::alloc_slow(a1, 0x38uLL, 7);
  }
  else {
    a1[2] = v8 + 56;
  }
  uint64_t v9 = *a2;
  a5.n128_u32[0] = *a3;
  uint64_t v10 = *a4;
  return RB::DisplayList::ItemClip::ItemClip(v8, v9, v10, a5);
}

RB::DisplayList::Item *RB::DisplayList::Item::project(RB::DisplayList::Item *this, RB::DisplayList::Builder *a2, const RB::Path::Projection *a3, float64x2_t *a4)
{
  v50[14] = *MEMORY[0x263EF8340];
  int v37 = a3;
  uint64_t v38 = a2;
  int v39 = a4;
  float64x2_t v8 = a4[1];
  float64x2_t v46 = *a4;
  float64x2_t v47 = v8;
  float64x2_t v48 = a4[2];
  if (RB::AffineTransform::invert((RB::AffineTransform *)&v46)) {
    uint64_t v9 = &v46;
  }
  else {
    uint64_t v9 = a4;
  }
  float64x2_t v10 = v9[1];
  float64x2_t v11 = v9[2];
  float64x2_t v40 = *v9;
  float64x2_t v41 = v10;
  float64x2_t v42 = v11;
  if ((*((_DWORD *)a3 + 12) & 0x1E) == 2
    || (int v12 = (*(uint64_t (**)(RB::DisplayList::Item *))(*(void *)this + 40))(this),
        (v12 + 1) <= 2))
  {
    *(double *)&float32x2_t v13 = (*(double (**)(RB::DisplayList::Item *, void))(*(void *)this + 144))(this, 0);
    float64x2_t v15 = vcvtq_f64_f32(vmla_f32(v13, (float32x2_t)0x3F0000003F000000, v14));
    long long v43 = xmmword_2142181C0;
    long long v44 = xmmword_2142181D0;
    long long v45 = 0uLL;
    if (RB::Path::Projection::project((uint64_t)v37, (uint64_t)&v43, vcvtq_f64_f32(vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(v42, v40, v15.f64[0]), v41, v15, 1)))))
    {
      v16.f64[0] = RB::operator*(&v40, (float64x2_t *)&v43);
      float64x2_t v46 = v16;
      float64x2_t v47 = v17;
      float64x2_t v48 = v18;
      *(double *)&long long v19 = RB::operator*(&v46, v39);
      long long v43 = v19;
      long long v44 = v20;
      long long v45 = v21;
      RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v46, (uint64_t)v38, &v43, 0, 0, 0);
      (*(void (**)(RB::DisplayList::Item *, float64x2_t *, uint64_t))(*(void *)this + 32))(this, &v46, 1);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v50);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v49);
      RB::Heap::~Heap((RB::Heap *)&v46.f64[1]);
    }
  }
  else
  {
    uint64_t v22 = 0;
    uint64_t v36 = 0;
    int v23 = &v36;
    do
    {
      uint64_t v24 = (*(uint64_t (**)(RB::DisplayList::Item *, RB::DisplayList::Builder *, uint64_t, uint64_t, void))(*(void *)this + 48))(this, a2, v22, 1, 0);
      float32x2_t v25 = (uint64_t *)v24;
      if (v24)
      {
        *(double *)&float32x2_t v26 = (*(double (**)(uint64_t, void))(*(void *)v24 + 144))(v24, 0);
        float64x2_t v28 = vcvtq_f64_f32(vmla_f32(v26, (float32x2_t)0x3F0000003F000000, v27));
        long long v43 = xmmword_2142181C0;
        long long v44 = xmmword_2142181D0;
        long long v45 = 0uLL;
        if (RB::Path::Projection::project((uint64_t)v37, (uint64_t)&v43, vcvtq_f64_f32(vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(v42, v40, v28.f64[0]), v41, v28, 1)))))
        {
          v29.f64[0] = RB::operator*(&v40, (float64x2_t *)&v43);
          float64x2_t v46 = v29;
          float64x2_t v47 = v30;
          float64x2_t v48 = v31;
          *(double *)&long long v32 = RB::operator*(&v46, v39);
          long long v43 = v32;
          long long v44 = v33;
          long long v45 = v34;
          RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v46, (uint64_t)v38, &v43, 0, 0, 0);
          (*(void (**)(uint64_t *, float64x2_t *, uint64_t))(*v25 + 32))(v25, &v46, 1);
          RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v50);
          RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v49);
          RB::Heap::~Heap((RB::Heap *)&v46.f64[1]);
        }
        *int v23 = (uint64_t)v25;
        int v23 = v25 + 1;
      }
      uint64_t v22 = (v22 + 1);
    }
    while (v12 != v22);
    *int v23 = 0;
    (**(void (***)(RB::DisplayList::Item *))this)(this);
    return (RB::DisplayList::Item *)v36;
  }
  return this;
}

void sub_214196CB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, RB::Heap *a10)
{
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)(v10 + 1368));
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)(v10 + 1288));
  RB::Heap::~Heap((RB::Heap *)(v10 | 8));
  _Unwind_Resume(a1);
}

void RB::DisplayList::Item::print(RB::DisplayList::Item *this, std::string *a2)
{
  if ((*((_WORD *)this + 23) & 0x800) != 0) {
    RB::SexpString::print(a2, 0, "disable-mix");
  }
  _H0 = *((short float *)this + 22);
  if (_H0 != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
  {
    __asm { FCVT            D0, H0 }
    RB::SexpString::printf(a2, 0, "(alpha %g)", _D0);
  }
  unsigned int v10 = *((_WORD *)this + 23) & 0x3F;
  if (v10 != 2)
  {
    float64x2_t v11 = RB::blend_name(v10);
    RB::SexpString::printf(a2, 0, "(blend %s)", v11);
  }
  if (*((_DWORD *)this + 10)) {
    RB::SexpString::printf(a2, 0, "(identifier %u)", *((_DWORD *)this + 10));
  }
  int v12 = (uint64_t *)*((void *)this + 4);
  if (v12 && RB::DisplayList::Metadata::numeric_value(v12))
  {
    float32x2_t v13 = RB::DisplayList::Metadata::numeric_value(*((uint64_t **)this + 4));
    RB::SexpString::printf(a2, 0, "(numeric-value %g)", *(float *)v13);
  }
  if (*((void *)this + 2))
  {
    RB::SexpString::push(a2, "styles");
    for (float i = (void *)*((void *)this + 2); i; float i = (void *)i[4])
      (*(void (**)(void *, std::string *))(*i + 112))(i, a2);
    RB::SexpString::pop(a2);
    a2[1].__r_.__value_.__s.__data_[16] = 1;
  }
  float64x2_t v15 = (void *)*((void *)this + 3);
  if (v15)
  {
    do
    {
      (*(void (**)(unint64_t, std::string *))(*(void *)(v15[1] & 0xFFFFFFFFFFFFFFFELL) + 128))(v15[1] & 0xFFFFFFFFFFFFFFFELL, a2);
      float64x2_t v15 = (void *)*v15;
    }
    while (v15);
    a2[1].__r_.__value_.__s.__data_[16] = 1;
  }
  float64x2_t v16 = (uint64_t *)*((void *)this + 4);
  if (v16)
  {
    if (RB::DisplayList::Metadata::transition(v16))
    {
      float64x2_t v17 = RB::DisplayList::Metadata::transition(*((uint64_t **)this + 4));
      RB::Transition::print((RB::Transition *)v17, a2);
      a2[1].__r_.__value_.__s.__data_[16] = 1;
    }
    float64x2_t v18 = (uint64_t *)*((void *)this + 4);
    if (v18)
    {
      if (RB::DisplayList::Metadata::text_identity(v18))
      {
        long long v19 = RB::DisplayList::Metadata::text_identity(*((uint64_t **)this + 4));
        RB::TextIdentity::print((RB::TextIdentity *)v19, a2);
        a2[1].__r_.__value_.__s.__data_[16] = 1;
      }
    }
  }
}

uint64_t RB::DisplayList::LayerItem::disable_subpixel_quantization(uint64_t this, float64x2_t *a2)
{
  float64x2_t v2 = a2[1];
  float64x2_t v7 = *a2;
  float64x2_t v8 = v2;
  float64x2_t v9 = a2[2];
  uint64_t v3 = *(void *)(this + 48);
  float v4 = *(float *)(v3 + 48);
  if (v4 != 0.0)
  {
    double v5 = v4;
    float64x2_t v7 = vmulq_n_f64(v7, v5);
    float64x2_t v8 = vmulq_n_f64(v8, v5);
    float64x2_t v9 = vmulq_n_f64(v9, v5);
  }
  long long v6 = *(void **)v3;
  if (*(void *)v3)
  {
    do
    {
      this = (*(uint64_t (**)(void *, float64x2_t *))(*v6 + 128))(v6, &v7);
      long long v6 = (void *)v6[1];
    }
    while (v6);
  }
  return this;
}

uint64_t RB::DisplayList::LayerItem::can_append_color_matrix(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 a4)
{
  unsigned int v4 = a3;
  uint64_t v5 = *(void *)(a1 + 48);
  if (*(unsigned char *)(v5 + 64) == 2)
  {
    long long v6 = *(uint64_t (**)(void))(**(void **)(v5 + 24) + 56);
    return v6();
  }
  int v8 = a4;
  int v9 = HIBYTE(a4);
  unsigned int v10 = *(void **)(v5 + 16);
  if (v10)
  {
    if (!v10[1] && (*(unsigned int (**)(void))(*v10 + 40))(*(void *)(v5 + 16)) == 1)
    {
      if ((*v11 & 3) == 0 || v9 == 0) {
        return ((*v11 & 4) == 0) ^ v4;
      }
      unsigned int v13 = ((*v11 & 2) << 7) | (*v11 >> 1) & 1;
      if (*v11) {
        unsigned int v13 = 256;
      }
      if (v13 >= 0x100 && (v13 & 1) == v8) {
        return ((*v11 & 4) == 0) ^ v4;
      }
    }
    return 0;
  }
  int v15 = *(_DWORD *)(v5 + 60);
  if (v15) {
    return 0;
  }
  if ((v15 & 6) != 0 && HIBYTE(a4) != 0)
  {
    unsigned int v17 = (v15 & 2) != 0 ? 256 : ((*(_DWORD *)(v5 + 60) & 4) << 6) | (*(_DWORD *)(v5 + 60) >> 2) & 1;
    if (v17 < 0x100 || (v17 & 1) != a4) {
      return 0;
    }
  }
  return RB::DisplayList::Builder::can_lower_color_matrix((uint64_t *)v5, a2, a3, a4, 1);
}

__int16 RB::DisplayList::LayerItem::append_color_matrix@<H0>(uint64_t a1@<X0>, float16x4_t *a2@<X1>, uint64_t a3@<X2>, unsigned __int16 a4@<W3>, uint64_t a5@<X4>)
{
  uint64_t v8 = *(void *)(a1 + 48);
  if (*(unsigned char *)(v8 + 64) == 2)
  {
    *(void *)(*(void *)(a1 + 48) + 24) = (*(uint64_t (**)(void, float16x4_t *, uint64_t, void))(**(void **)(v8 + 24) + 64))(*(void *)(v8 + 24), a2, a3, a4);
  }
  else
  {
    uint64_t v10 = *(void *)(v8 + 16);
    if (v10)
    {
      RB::operator*(a2, (float16x4_t *)(v10 + 40), (float16x4_t *)v20);
      __int16 result = v20[0];
      long long v11 = v20[1];
      *(_OWORD *)(v10 + 40) = v20[0];
      *(_OWORD *)(v10 + 56) = v11;
      *(void *)(v10 + 72) = v21;
    }
    else
    {
      float v12 = RB::DisplayList::Builder::lower_color_matrix(a5, (void **)v8, (uint64_t)a2, a3, a4, 1);
      _H1 = *(_WORD *)(a1 + 44);
      __asm { FCVT            S1, H1 }
      _S0 = v12 * _S1;
      __asm { FCVT            H0, S0 }
      *(_WORD *)(a1 + 44) = result;
    }
  }
  return result;
}

double RB::DisplayList::LayerItem::min_scale(RB::DisplayList::LayerItem *this)
{
  uint64_t v1 = (RB::DisplayList::Layer *)*((void *)this + 6);
  if (!v1) {
    return 0.0;
  }
  RB::DisplayList::Layer::min_scale(v1);
  return result;
}

uint64_t RB::DisplayList::LayerItem::make_clip(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, __n128 _Q0)
{
  v35[185] = *MEMORY[0x263EF8340];
  unsigned int v34 = a3;
  uint64_t result = *(void *)(a1 + 48);
  if (!result) {
    return result;
  }
  float v8 = _Q0.n128_f32[0];
  if (*(unsigned char *)(a2 + 272))
  {
    if (!*(unsigned char *)(result + 64) && !*(void *)(result + 16))
    {
      int v10 = *(_DWORD *)(result + 60);
      if ((v10 & 0x2001) == 0 && (v10 & 6) == 0 && *(float *)(result + 48) == 0.0)
      {
        long long v20 = *(void **)result;
        if (*(void *)result)
        {
          if (!v20[1])
          {
            int v22 = (*(uint64_t (**)(void))(*v20 + 80))(*(void *)result);
            uint64_t result = *(void *)(a1 + 48);
            if (v22)
            {
              int v23 = *(void **)result;
              __int16 v24 = *(_WORD *)(*(void *)result + 46);
              _ZF = (v24 & 0x3F) == 0x18 || (v24 & 0x3F) == 2;
              if (_ZF && (v8 == 1.0 || !v23[3]))
              {
                if (a3)
                {
                  if ((*(_WORD *)(*(void *)result + 46) & 0x2000) != 0 || v23[3]) {
                    goto LABEL_6;
                  }
                }
                else
                {
                  if ((*(_WORD *)(*(void *)result + 46) & 0x2000) != 0) {
                    goto LABEL_6;
                  }
                  if (v23[3])
                  {
                    v31[0] = xmmword_2142181C0;
                    v31[1] = xmmword_2142181D0;
                    uint64_t v32 = 0;
                    uint64_t v33 = 0;
                    RB::DisplayList::CachedTransform::CachedTransform((uint64_t)v35, a2, v31, 0, 0, 0);
                    for (float i = *(void **)(**(void **)(a1 + 48) + 24); i; float i = (void *)*i)
                    {
                      float32x2_t v27 = (void *)(*(uint64_t (**)(unint64_t, uint64_t *, void, void))(*(void *)(i[1] & 0xFFFFFFFFFFFFFFFELL) + 24))(i[1] & 0xFFFFFFFFFFFFFFFELL, v35, 0, 0);
                      if (v27)
                      {
                        size_t v28 = a4[5];
                        do
                        {
                          size_t v29 = v28 + 1;
                          if (a4[6] < v28 + 1)
                          {
                            RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v29);
                            size_t v28 = a4[5];
                            size_t v29 = v28 + 1;
                          }
                          float64x2_t v30 = (void *)a4[4];
                          if (!v30) {
                            float64x2_t v30 = a4;
                          }
                          v30[v28] = v27[1];
                          a4[5] = v29;
                          float32x2_t v27 = (void *)*v27;
                          size_t v28 = v29;
                        }
                        while (v27);
                      }
                    }
                    RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)v35);
                    int v23 = **(void ***)(a1 + 48);
                  }
                }
                uint64_t result = (*(uint64_t (**)(void *, uint64_t, uint64_t, void *, float))(*v23 + 88))(v23, a2, a3, a4, v8);
                **(void **)(a1 + 48) = 0;
                return result;
              }
            }
          }
        }
      }
    }
LABEL_6:
    int v11 = *(unsigned __int8 *)(a2 + 272);
    float v12 = (size_t *)(*(void *)(a2 + 8) + 16);
    if (v11)
    {
      RB::DisplayList::Layer::discard_color(result);
      uint64_t result = *(void *)(a1 + 48);
    }
    goto LABEL_9;
  }
  float v12 = (size_t *)(*(void *)(a2 + 8) + 16);
LABEL_9:
  *(void *)(a1 + 48) = 0;
  v35[0] = result;
  _Q0.n128_u16[0] = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  _Q0.n128_f32[0] = _Q0.n128_f32[0] * v8;
  LODWORD(v31[0]) = _Q0.n128_u32[0];
  uint64_t result = RB::Heap::emplace<RB::DisplayList::LayerClip,RB::DisplayList::Layer *&,float &,RB::ClipMode const&>(v12, v35, (unsigned __int32 *)v31, &v34, _Q0);
  uint64_t v16 = result;
  uint64_t v17 = a4[5];
  size_t v18 = v17 + 1;
  if (a4[6] < (unint64_t)(v17 + 1))
  {
    uint64_t result = (uint64_t)RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v18);
    uint64_t v17 = a4[5];
    size_t v18 = v17 + 1;
  }
  long long v19 = (void *)a4[4];
  if (!v19) {
    long long v19 = a4;
  }
  v19[v17] = v16;
  a4[5] = v18;
  return result;
}

void sub_214197530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::LayerItem::project(uint64_t a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v5 = *(void *)(a1 + 48);
  float v6 = *(float *)(v5 + 48);
  if (v6 == 0.0) {
    float v6 = 1.0;
  }
  double v7 = v6;
  float64x2_t v8 = vmulq_n_f64(*a4, v7);
  float64x2_t v9 = vmulq_n_f64(a4[1], v7);
  float64x2_t v10 = vmulq_n_f64(a4[2], v7);
  v19[0] = v8;
  v19[1] = v9;
  float32x2_t v19[2] = v10;
  int v11 = *(uint64_t **)v5;
  if (*(void *)v5)
  {
    do
    {
      float32x2_t v14 = v11;
      int v11 = (uint64_t *)v11[1];
      uint64_t v15 = *v14;
      v14[1] = 0;
      uint64_t v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, _OWORD *))(v15 + 232))(v14, a2, a3, v19);
      *(void *)uint64_t v5 = v16;
      do
      {
        uint64_t v17 = v16;
        uint64_t v16 = *(void *)(v16 + 8);
      }
      while (v16);
      uint64_t v5 = v17 + 8;
    }
    while (v11);
  }
  *(void *)uint64_t v5 = 0;
  return a1;
}

void RB::DisplayList::LayerItem::print(RB::DisplayList::Layer **this, std::string *a2)
{
  RB::SexpString::push(a2, "draw-layer");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)this, a2);
  RB::DisplayList::Layer::print(this[6], a2);
  RB::SexpString::pop(a2);
}

__int16 RB::DisplayList::BackdropColorMatrixItem::BackdropColorMatrixItem@<H0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, float _S0@<S0>)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = result;
  *(_WORD *)(a1 + 46) = a3 & 0x3F | 0x400;
  *(void *)a1 = &unk_26C4ECC80;
  *(void *)(a1 + 48) = a2;
  return result;
}

__n128 RB::DisplayList::BackdropColorMatrixItem::copy(__n128 *this, RB::DisplayList::Builder *a2)
{
  uint64_t v3 = (RB::Heap *)(*((void *)a2 + 1) + 16);
  int v6 = this[2].n128_u16[7] & 0x3F;
  _ZN2RB4Heap7emplaceINS_11DisplayList23BackdropColorMatrixItemEJRKPKNS_6Filter11ColorMatrixERKDF16_RKNS_9BlendModeEEEEPT_DpOT0_(v3, (uint64_t *)&this[3], &this[2].n128_i16[6], (__int16 *)&v6);
  __n128 result = this[1];
  v5[1] = result;
  v5[2].n128_u64[0] = this[2].n128_u64[0];
  v5[2].n128_u32[2] = this[2].n128_u32[2];
  return result;
}

__int16 _ZN2RB4Heap7emplaceINS_11DisplayList23BackdropColorMatrixItemEJRKPKNS_6Filter11ColorMatrixERKDF16_RKNS_9BlendModeEEEEPT_DpOT0_@<H0>(RB::Heap *this@<X0>, uint64_t *a2@<X1>, __int16 *a3@<X2>, __int16 *a4@<X3>)
{
  unint64_t v8 = *((void *)this + 3);
  unint64_t v9 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v9 + 56 > v8) {
    unint64_t v9 = RB::Heap::alloc_slow((size_t *)this, 0x38uLL, 7);
  }
  else {
    *((void *)this + 2) = v9 + 56;
  }
  uint64_t v10 = *a2;
  __int16 result = *a3;
  __int16 v12 = *a4;
  *(void *)(v9 + 16) = 0;
  *(void *)(v9 + 24) = 0;
  *(_DWORD *)(v9 + 40) = 0;
  *(void *)(v9 + 32) = 0;
  *(_WORD *)(v9 + 44) = result;
  *(_WORD *)(v9 + 46) = v12 & 0x3F | 0x400;
  *(void *)unint64_t v9 = &unk_26C4ECC80;
  *(void *)(v9 + 48) = v10;
  return result;
}

void RB::DisplayList::BackdropColorMatrixItem::print(float16x4_t **this, std::string *a2)
{
  RB::SexpString::push(a2, "backdrop-color-matrix");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)this, a2);
  unsigned int v4 = this[6];
  if (v4) {
    RB::Filter::ColorMatrix::print(v4, a2);
  }
  RB::SexpString::pop(a2);
}

float32x2_t RB::DisplayList::CustomItem::bounds(RB::DisplayList::CustomItem *this, double a2, int32x4_t a3)
{
  a3.i64[0] = *((void *)this + 9);
  return RB::operator*(*((float64x2_t **)this + 7), *(float32x2_t *)((char *)this + 64), a3);
}

uint64_t RB::DisplayList::CustomItem::CustomItem(uint64_t a1, void *a2, int a3, uint64_t a4, _OWORD *a5, char a6, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F | 0x2000;
  *(void *)a1 = &unk_26C4E8870;
  *(void *)(a1 + 48) = [a2 copy];
  *(void *)(a1 + 56) = a4;
  *(_OWORD *)(a1 + 64) = *a5;
  *(_DWORD *)(a1 + 80) = a3;
  return a1;
}

__n128 RB::DisplayList::CustomItem::copy(__n128 *this, RB::DisplayList::Builder *a2)
{
  uint64_t v3 = (size_t *)(*((void *)a2 + 1) + 16);
  unint64_t v7 = this[3].n128_u64[0];
  int v6 = this[2].n128_u16[7] & 0x3F;
  unsigned int v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList10CustomItemEJU13block_pointerFvP18RBMetalRenderStateERKjRKPKNS_15AffineTransformERKNS_4RectERKDF16_RKNS_9BlendModeEEEEPT_DpOT0_(v3, (void **)&v7, (int *)&this[5], &this[3].n128_i64[1], (__n128 *)this[4].n128_u64, &this[2].n128_i16[6], (__int16 *)&v6);
  __n128 result = this[1];
  v4[1] = result;
  v4[2].n128_u64[0] = this[2].n128_u64[0];
  v4[2].n128_u32[2] = this[2].n128_u32[2];
  v4[2].n128_u16[7] |= this[2].n128_u16[7] & 0x5800;
  return result;
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList10CustomItemEJU13block_pointerFvP18RBMetalRenderStateERKjRKPKNS_15AffineTransformERKNS_4RectERKDF16_RKNS_9BlendModeEEEEPT_DpOT0_(size_t *a1, void **a2, int *a3, uint64_t *a4, _OWORD *a5, __int16 *a6, __int16 *a7)
{
  unint64_t v13 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v13 + 88 > a1[3]) {
    unint64_t v13 = RB::Heap::alloc_slow(a1, 0x58uLL, 7);
  }
  else {
    a1[2] = v13 + 88;
  }
  float32x2_t v14 = *a2;
  int v15 = *a3;
  uint64_t v16 = *a4;
  __int16 v17 = *a6;
  __int16 v18 = *a7;
  *(void *)(v13 + 16) = 0;
  *(void *)(v13 + 24) = 0;
  *(_DWORD *)(v13 + 40) = 0;
  *(void *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 44) = v17;
  *(_WORD *)(v13 + 46) = v18 & 0x3F | 0x2000;
  *(void *)unint64_t v13 = &unk_26C4E8870;
  *(void *)(v13 + 48) = [v14 copy];
  *(void *)(v13 + 56) = v16;
  *(_OWORD *)(v13 + 64) = *a5;
  *(_DWORD *)(v13 + 80) = v15;
  return v13;
}

const RB::AffineTransform *RB::DisplayList::CustomItem::apply_transform(const RB::AffineTransform **this, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)this, a2, a3);
  __n128 result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, this[7]);
  this[7] = result;
  return result;
}

void RB::DisplayList::CustomItem::print(const RB::AffineTransform **this, std::string *a2)
{
  RB::SexpString::push(a2, "draw-custom");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)this, a2);
  RB::SexpString::printf(a2, 0, "(rect %g %g %g %g)", COERCE_FLOAT(this[8]), COERCE_FLOAT((unint64_t)this[8] >> 32), COERCE_FLOAT(this[9]), COERCE_FLOAT((unint64_t)this[9] >> 32));
  RB::SexpString::print_ctm(a2, this[7]);
  RB::SexpString::pop(a2);
}

uint64_t RB::DisplayList::Item::atom_position(RB::DisplayList::Item *this)
{
  return 0;
}

uint64_t RB::DisplayList::Item::can_make_clip(RB::DisplayList::Item *this)
{
  return 1;
}

uint64_t RB::DisplayList::Item::can_append_color_matrix()
{
  return 0;
}

uint64_t RB::DisplayList::Item::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::Item::required_depth(RB::DisplayList::Item *this)
{
  return 0;
}

uint64_t RB::DisplayList::LayerItem::type_id(RB::DisplayList::LayerItem *this)
{
  return 0;
}

void RB::DisplayList::BackdropColorMatrixItem::~BackdropColorMatrixItem(RB::DisplayList::BackdropColorMatrixItem *this)
{
}

uint64_t RB::DisplayList::BackdropColorMatrixItem::type_id(RB::DisplayList::BackdropColorMatrixItem *this)
{
  return 2;
}

double RB::DisplayList::BackdropColorMatrixItem::bounds(RB::DisplayList::BackdropColorMatrixItem *this)
{
  return -5.48612406e303;
}

float RB::DisplayList::BackdropColorMatrixItem::min_scale(RB::DisplayList::BackdropColorMatrixItem *this)
{
  return 1.0;
}

void RB::DisplayList::CustomItem::~CustomItem(id *this)
{
}

{
  uint64_t vars8;

  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::CustomItem::type_id(RB::DisplayList::CustomItem *this)
{
  return 3;
}

float RB::DisplayList::CustomItem::min_scale(RB::DisplayList::CustomItem *this)
{
  return 1.0;
}

_DWORD *RB::Refcount<RB::Resource,unsigned int>::release(_DWORD *result)
{
  int v1 = result[2] - 1;
  result[2] = v1;
  if (!v1) {
    return (_DWORD *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::Refcount<RB::Resource,unsigned int>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void RB::Resource::~Resource(RB::Resource *this)
{
  *(void *)this = &unk_26C4EDD98;
  float64x2_t v2 = (_DWORD *)*((void *)this + 3);
  if (v2)
  {
    int v3 = v2[2] - 1;
    v2[2] = v3;
    if (!v3) {
      (*(void (**)(_DWORD *))(*(void *)v2 + 8))(v2);
    }
  }
}

{
  _DWORD *v2;
  int v3;
  uint64_t vars8;

  *(void *)this = &unk_26C4EDD98;
  float64x2_t v2 = (_DWORD *)*((void *)this + 3);
  if (v2)
  {
    int v3 = v2[2] - 1;
    v2[2] = v3;
    if (!v3) {
      (*(void (**)(_DWORD *))(*(void *)v2 + 8))(v2);
    }
  }

  JUMPOUT(0x21669AC10);
}

{
  _DWORD *v2;
  int v3;

  *(void *)this = &unk_26C4EDD98;
  float64x2_t v2 = (_DWORD *)*((void *)this + 3);
  if (v2)
  {
    int v3 = v2[2] - 1;
    v2[2] = v3;
    if (!v3) {
      (*(void (**)(_DWORD *))(*(void *)v2 + 8))(v2);
    }
  }
}

void RB::render_glyphs_coverage(uint64_t a1, float64x2_t *a2, float32x2_t *a3, int a4, float a5)
{
  unint64_t v9 = &unk_26C4EE880;
  float v10 = a5;
  int v11 = a4;
  BOOL may_discard_shape = RB::may_discard_shape(a4);
}

void RB::render_glyphs(uint64_t a1, float64x2_t *a2, float32x2_t *a3, float32x2_t *this, char a5, int a6, float a7)
{
  v16[0] = &unk_26C4EE7C0;
  v16[1] = this;
  float32x2_t v16[2] = a2;
  char v17 = a5;
  float v18 = a7;
  int v19 = a6;
  if (a7 == 1.0) {
    char is_opaque = RB::Fill::Gradient::is_opaque(this);
  }
  else {
    char is_opaque = 0;
  }
  if (a3[2].i32[0] < 2u)
  {
    char v14 = 0;
  }
  else
  {
    BOOL v13 = a6 != 2 && a6 != 24;
    if (a3[6].i8[5] & 1 | ((is_opaque & 1) == 0)) {
      char v14 = 1;
    }
    else {
      char v14 = v13;
    }
  }
  BOOL may_discard_shape = RB::may_discard_shape(a6);
}

void RB::render_glyphs(uint64_t a1, float64x2_t *a2, float32x2_t *this, uint64_t a4, char a5, int a6, float a7)
{
  v7[0] = &unk_26C4E8338;
  v7[1] = a4;
  float64x2_t v7[2] = a2;
  char v8 = a5;
  float v9 = a7;
  int v10 = a6;
}

void RB::render_glyphs(uint64_t a1, float64x2_t *a2, float32x2_t *a3, uint64_t a4, uint64_t a5, char a6, int a7)
{
  v15[0] = &unk_26C4EE7F0;
  v15[1] = a4;
  v15[2] = a5;
  char v16 = a6;
  int v17 = a7;
  if (a3[2].i32[0] < 2u)
  {
    char v13 = 0;
  }
  else
  {
    BOOL v11 = a7 != 2 && a7 != 24;
    char v12 = (a3[6].i8[5] & 1) != 0 || v11;
    if (*(unsigned char *)(a4 + 81)) {
      char v13 = v12;
    }
    else {
      char v13 = 1;
    }
  }
  BOOL may_discard_shape = RB::may_discard_shape(a7);
}

void RB::render_glyphs(uint64_t a1, float64x2_t *a2, float32x2_t *a3, uint64_t a4, char a5, int a6, float a7)
{
  v12[0] = &unk_26C4EE790;
  v12[1] = a4;
  v12[2] = a2;
  char v13 = a5;
  float v14 = a7;
  int v15 = a6;
  char v10 = a3[2].i32[0] > 1u;
  BOOL may_discard_shape = RB::may_discard_shape(a6);
}

void RB::anonymous namespace'::render_glyph_paths(uint64_t a1, RB::Device ****a2, float64x2_t *this, float32x2_t *a4, int a5, char a6)
{
  uint64_t v61 = a1;
  uint64_t v80 = *MEMORY[0x263EF8340];
  int v11 = a4[6].u8[4];
  float v12 = 0.0;
  if (v11 == 1)
  {
    int v13 = 0;
  }
  else if (a4[6].i8[4])
  {
    float v14 = a4[6].f32[0];
    a6 = 0;
    float v12 = RB::AffineTransform::scale(this) * v14;
    int v13 = 2;
  }
  else
  {
    int v13 = 0;
    int v11 = (a4[2].i8[4] & 1) == 0;
  }
  uint64_t v15 = RB::Device::glyph_path_cache(***a2);
  uint64_t v17 = v15;
  float32x2_t v18 = 0;
  if (a5) {
    float32x2_t v18 = RB::GlyphPathCache::glyph_dilation(a4, this, v16);
  }
  unint64_t v19 = a4[2].u32[0];
  if ((a6 & 1) == 0)
  {
    if (!a4[2].i32[0]) {
      return;
    }
    unint64_t v23 = 0;
    while (1)
    {
      float64x2_t v24 = this[1];
      float64x2_t v65 = this[2];
      float64x2_t v25 = *this;
      float64x2_t v26 = *this;
      v64[1] = this[1];
      v64[0] = v25;
      float32x2_t v27 = *a4;
      float32x2_t v28 = a4[1];
      float64x2_t v65 = vmlaq_n_f64(vmlaq_n_f64(v65, v24, COERCE_FLOAT(HIDWORD(*(void *)(*(void *)&v28 + 8 * v23)))), v26, COERCE_FLOAT(*(void *)(*(void *)&v28 + 8 * v23)));
      size_t v29 = RB::GlyphPathCache::lookup_glyph(v17, v27.i32[0], *(unsigned __int16 *)(*(void *)&v28 + 8 * v19 + 2 * v23), v64, v18, (uint64_t)*a2, v13);
      if (v29[7])
      {
        RB::RenderFrame::cached_region((uint64_t)**a2, 2u, *((_DWORD *)v29 + 19), (uint64_t)&v62);
        double v30 = v62;
        if (v62 != 0.0) {
          goto LABEL_19;
        }
        RB::RenderFrame::alloc_buffer_region((RB::RenderFrame *)**a2, (RB::Device *)(32 * v29[7]), 4uLL, 0, v72);
        double v62 = *(double *)v72;
        float64x2_t v63 = *(float64x2_t *)&v72[8];
        if (*(void *)v72) {
          break;
        }
      }
LABEL_20:
      ++v23;
      unint64_t v19 = a4[2].u32[0];
      if (v23 >= v19) {
        return;
      }
    }
    uint64_t v31 = v29[7];
    if (v31) {
      memmove((void *)(*(void *)(*(void *)v72 + 56) + *(void *)&v72[8]), (const void *)v29[6], 32 * v31);
    }
    RB::RenderFrame::set_cached_region((uint64_t)**a2, 2u, *((_DWORD *)v29 + 19), (uint64_t)&v62);
    double v30 = v62;
LABEL_19:
    int v32 = *((_DWORD *)v29 + 18);
    uint64_t v33 = v29[4];
    uint64_t v34 = v29[5];
    float64_t v76 = v30;
    float64x2_t v77 = v63;
    int v78 = v32;
    char v79 = 4;
    *(void *)int v72 = 1;
    *(void *)&v72[8] = &v76;
    *(void *)&v72[16] = v33;
    *(void *)&v72[24] = v34;
    float64x2_t v73 = v64[0];
    float64x2_t v74 = v64[1];
    float64x2_t v75 = v65;
    int v66 = a2;
    char v67 = 0;
    char v68 = v11;
    float v69 = v12;
    uint64_t v70 = 1;
    int v71 = v72;
    (*(void (**)(uint64_t, RB::Device *****))(*(void *)v61 + 24))(v61, &v66);
    goto LABEL_20;
  }
  if (v19 <= 0x33)
  {
    MEMORY[0x270FA5388](v15, 80 * v19);
    __int32 v60 = (char *)&v56 - ((v20 + 15) & 0xFFFFFFFFF0);
    bzero(v60, v20);
    uint64_t v22 = 32 * v19;
LABEL_23:
    MEMORY[0x270FA5388](v21, v22);
    int v59 = (char *)&v56 - ((v36 + 15) & 0x3FFFFFFFF0);
    bzero(v59, v36);
    int v58 = 1;
    goto LABEL_25;
  }
  uint64_t v21 = (char *)malloc_type_malloc(80 * v19, 0xDB92CD52uLL);
  __int32 v60 = v21;
  uint64_t v35 = a4[2].u32[0];
  uint64_t v22 = 32 * v35;
  if (v35 < 0x81) {
    goto LABEL_23;
  }
  int v59 = (char *)malloc_type_malloc(32 * v35, 0xE9AE4D03uLL);
  int v58 = 0;
LABEL_25:
  if (!v60) {
    goto LABEL_39;
  }
  if (!v59) {
    goto LABEL_39;
  }
  unint64_t v37 = a4[2].u32[0];
  if (!v37) {
    goto LABEL_39;
  }
  int v57 = v11;
  uint64_t v38 = 0;
  unint64_t v39 = 0;
  int v40 = v13 | 1;
  do
  {
    float64x2_t v41 = this[1];
    float64x2_t v73 = this[2];
    float64x2_t v42 = this[1];
    *(float64x2_t *)int v72 = *this;
    *(float64x2_t *)&v72[16] = v42;
    float32x2_t v43 = *a4;
    float32x2_t v44 = a4[1];
    float64x2_t v73 = vmlaq_n_f64(vmlaq_n_f64(v73, v41, COERCE_FLOAT(HIDWORD(*(void *)(*(void *)&v44 + 8 * v39)))), *(float64x2_t *)v72, COERCE_FLOAT(*(void *)(*(void *)&v44 + 8 * v39)));
    long long v45 = RB::GlyphPathCache::lookup_glyph(v17, v43.i32[0], *(unsigned __int16 *)(*(void *)&v44 + 8 * v37 + 2 * v39), (float64x2_t *)v72, v18, (uint64_t)*a2, v40);
    if (!v45[7]) {
      goto LABEL_36;
    }
    RB::RenderFrame::cached_region((uint64_t)**a2, 2u, *((_DWORD *)v45 + 19), (uint64_t)v64);
    float64_t v46 = v64[0].f64[0];
    if (!*(void *)&v64[0].f64[0])
    {
      RB::RenderFrame::alloc_buffer_region((RB::RenderFrame *)**a2, (RB::Device *)(32 * v45[7]), 4uLL, 0, &v76);
      v64[0].f64[0] = v76;
      *(float64x2_t *)((char *)v64 + 8) = v77;
      if (v76 == 0.0) {
        goto LABEL_36;
      }
      uint64_t v47 = v45[7];
      if (v47) {
        memmove((void *)(*(void *)(*(void *)&v76 + 56) + *(void *)&v77.f64[0]), (const void *)v45[6], 32 * v47);
      }
      RB::RenderFrame::set_cached_region((uint64_t)**a2, 2u, *((_DWORD *)v45 + 19), (uint64_t)v64);
      float64_t v46 = v64[0].f64[0];
    }
    int v48 = *((_DWORD *)v45 + 18);
    long long v49 = *(_OWORD *)v72;
    long long v50 = *(_OWORD *)&v72[16];
    float64x2_t v51 = v73;
    uint64_t v52 = v45[4];
    uint64_t v53 = v45[5];
    uint64_t v54 = &v60[80 * v38];
    *(void *)uint64_t v54 = 1;
    int v55 = &v59[32 * v38];
    *(float64_t *)int v55 = v46;
    *(float64x2_t *)(v55 + 8) = *(float64x2_t *)((char *)v64 + 8);
    *((_DWORD *)v55 + 6) = v48;
    v55[28] = 4;
    *((void *)v54 + 1) = v55;
    *((void *)v54 + 2) = v52;
    *((void *)v54 + 3) = v53;
    *((_OWORD *)v54 + 2) = v49;
    *((_OWORD *)v54 + 3) = v50;
    *((float64x2_t *)v54 + 4) = v51;
    ++v38;
LABEL_36:
    ++v39;
    unint64_t v37 = a4[2].u32[0];
  }
  while (v39 < v37);
  if (v38)
  {
    *(void *)int v72 = a2;
    v72[8] = 0;
    v72[9] = v57;
    *(float *)&v72[12] = v12;
    *(void *)&v72[16] = v38;
    *(void *)&v72[24] = v60;
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v61 + 24))(v61, v72);
  }
LABEL_39:
  if ((v58 & 1) == 0) {
    free(v59);
  }
  if (v19 >= 0x34) {
    free(v60);
  }
}

void sub_21419873C(_Unwind_Exception *exception_object)
{
  if ((*(_DWORD *)(v2 - 372) & 1) == 0) {
    free(*(void **)(v2 - 368));
  }
  if (v1 >= 0x34) {
    free(*(void **)(v2 - 360));
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::anonymous namespace'::GlyphRenderer::supports_draw_masks(RB::_anonymous_namespace_::GlyphRenderer *this)
{
  return 1;
}

int32x2_t *RB::render_glyphs_coverage(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,float,RB::BlendMode)::Renderer::draw_masks(uint64_t a1, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5, int32x2_t a6, int32x2_t a7)
{
  v8[0] = a6;
  v8[1] = a7;
  return RB::render_masks_coverage(a2, v8, a3, a4, a5, *(_DWORD *)(a1 + 12), *(float *)(a1 + 8));
}

int32x2_t *RB::render_glyphs_coverage(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,float,RB::BlendMode)::Renderer::draw_mask(uint64_t a1, uint64_t a2, float32x2_t a3, double a4)
{
  RB::Coverage::set_plane((float32x2_t *)&v20, (float32x2_t *)a2, a3, a4);
  _S0 = *(_DWORD *)(a1 + 8);
  __asm { FCVT            H0, S0 }
  WORD6(v21) = _S0;
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x20, 4uLL, 0, &v22);
  int v13 = v22;
  if (v22)
  {
    float v14 = (_OWORD *)(*((void *)v22 + 7) + v23.i64[0]);
    long long v15 = v21;
    *float v14 = v20;
    v14[1] = v15;
  }
  else
  {
    uint64_t v22 = 0;
    int64x2_t v23 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v13);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v23);
  uint64_t v16 = 17;
  if (*(_DWORD *)(a2 + 136) == 2) {
    uint64_t v16 = 131089;
  }
  uint64_t v17 = (const char *)(v16 | ((unint64_t)(*(_DWORD *)(a1 + 12) & 0x3F) << 32));
  RB::Bounds::Bounds(v19, a3, *(float32x2_t *)&a4);
  return RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, v17, 4, ***(void ***)a2 + 80, 0, 1uLL, v19[0], v19[1]);
}

void RB::render_glyphs_coverage(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,float,RB::BlendMode)::Renderer::draw_path(uint64_t a1, int32x2_t **a2)
{
}

int32x2_t *RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Color const&,BOOL,RB::BlendMode)::Renderer::draw_masks(uint64_t a1, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5, int32x2_t a6, int32x2_t a7)
{
  v8[0] = a6;
  v8[1] = a7;
  return RB::render_masks(a2, v8, a3, a4, a5, *(void *)(a1 + 8), *(unsigned __int8 *)(a1 + 16), *(_DWORD *)(a1 + 20));
}

void RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Color const&,BOOL,RB::BlendMode)::Renderer::draw_path(uint64_t a1, int32x2_t **a2)
{
}

int32x2_t *RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Gradient const&,BOOL,float,RB::BlendMode)::Renderer::draw_masks(uint64_t a1, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5, int32x2_t a6, int32x2_t a7)
{
  v8[0] = a6;
  v8[1] = a7;
  a6.i32[0] = *(_DWORD *)(a1 + 28);
  return RB::render_masks(a2, v8, a3, a4, a5, *(float64x2_t **)(a1 + 16), *(float32x2_t **)(a1 + 8), *(unsigned __int8 *)(a1 + 24), *(double *)&a6, *(_DWORD *)(a1 + 32));
}

int32x2_t *RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Gradient const&,BOOL,float,RB::BlendMode)::Renderer::draw_mask(uint64_t a1, uint64_t a2, float32x2_t a3, double a4)
{
  RB::Coverage::set_plane((float32x2_t *)&v20, (float32x2_t *)a2, a3, a4);
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  RB::Fill::Gradient::set_gradient(*(float32x2_t **)(a1 + 8), (uint64_t)v21 + 12, a2, *(float64x2_t **)(a1 + 16), v8);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x54, 4uLL, 0, &v23);
  float v9 = v23;
  if (v23)
  {
    uint64_t v10 = *((void *)v23 + 7) + v24.i64[0];
    long long v11 = v20;
    *(_OWORD *)(v10 + 16) = v21[0];
    long long v12 = v21[3];
    long long v13 = v21[2];
    long long v14 = v21[1];
    *(_DWORD *)(v10 + 80) = v22;
    *(_OWORD *)(v10 + 48) = v13;
    *(_OWORD *)(v10 + 64) = v12;
    *(_OWORD *)(v10 + 32) = v14;
    *(_OWORD *)uint64_t v10 = v11;
  }
  else
  {
    int64x2_t v23 = 0;
    int64x2_t v24 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v9);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v24);
  if (*(_DWORD *)(a2 + 136) == 2) {
    unsigned int v15 = 131091;
  }
  else {
    unsigned int v15 = 19;
  }
  int64x2_t v23 = (RB::Buffer *)v15;
  RB::Fill::Gradient::set_fill_state(*(void *)(a1 + 8), (int *)&v23, a2, *(float *)(a1 + 28));
  unsigned int v16 = HIDWORD(v23) & 0xFFFFFFC0 | *(_DWORD *)(a1 + 32) & 0x3F;
  LODWORD(v23) = v23 & 0xFFFEFFFF | (*(unsigned __int8 *)(a1 + 24) << 16);
  HIDWORD(v23) = v16;
  uint64_t v17 = (const char *)v23;
  RB::Bounds::Bounds(v19, a3, *(float32x2_t *)&a4);
  __n128 result = RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, v17, 4, ***(void ***)a2 + 80, 0, 1uLL, v19[0], v19[1]);
  *(void *)(a2 + 224) = 0;
  *(_DWORD *)(a2 + 220) = 0;
  return result;
}

void RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Gradient const&,BOOL,float,RB::BlendMode)::Renderer::draw_path(uint64_t a1, int32x2_t **a2)
{
}

void RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::MeshGradient const&,BOOL,float,RB::BlendMode)::Renderer::draw_masks()
{
}

void RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::MeshGradient const&,BOOL,float,RB::BlendMode)::Renderer::draw_mask(uint64_t a1, RB::RenderPass *a2, float32x2_t a3, float32x2_t a4)
{
  int v6 = *(RB::Fill::MeshGradient **)(a1 + 8);
  uint64_t v5 = *(float64x2_t **)(a1 + 16);
  int v7 = *(unsigned __int8 *)(a1 + 24);
  float v8 = *(float *)(a1 + 28);
  int v9 = *(_DWORD *)(a1 + 32);
  RB::Bounds::Bounds(v10, a3, a4);
  RB::render_mesh_gradient(a2, v5, v6, 0, v7, v9, v10, v8);
}

void RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::MeshGradient const&,BOOL,float,RB::BlendMode)::Renderer::draw_path(uint64_t a1, int32x2_t **a2)
{
}

int32x2_t *RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Shader::ImageGlobals &,RB::Fill::ImageData const&,BOOL,RB::BlendMode)::Renderer::draw_masks(uint64_t a1, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5, int32x2_t a6, int32x2_t a7)
{
  v15[0] = a6;
  v15[1] = a7;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)(a1 + 16);
  long long v9 = *(_OWORD *)(v8 + 16);
  *(_OWORD *)&v14[7] = *(_OWORD *)v8;
  *(_OWORD *)&v14[11] = v9;
  long long v11 = *(_OWORD *)(v8 + 48);
  long long v10 = *(_OWORD *)(v8 + 64);
  long long v12 = *(_OWORD *)(v8 + 32);
  LODWORD(v8) = *(_DWORD *)(v8 + 80);
  *(_OWORD *)&v14[15] = v12;
  v14[27] = v8;
  *(_OWORD *)&v14[23] = v10;
  *(_OWORD *)&v14[19] = v11;
  return RB::render_masks(a2, v15, a3, a4, a5, (long long *)v14, v7, *(unsigned __int8 *)(a1 + 24), *(_DWORD *)(a1 + 28));
}

int32x2_t *RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Shader::ImageGlobals &,RB::Fill::ImageData const&,BOOL,RB::BlendMode)::Renderer::draw_mask(uint64_t a1, uint64_t a2, float32x2_t a3, double a4)
{
  uint64_t v8 = *(void *)(a1 + 8);
  long long v9 = *(_OWORD *)(v8 + 16);
  *(_OWORD *)&v26[12] = *(_OWORD *)v8;
  *(_OWORD *)&v26[28] = v9;
  long long v11 = *(_OWORD *)(v8 + 48);
  long long v10 = *(_OWORD *)(v8 + 64);
  int v12 = *(_DWORD *)(v8 + 80);
  *(_OWORD *)&v26[44] = *(_OWORD *)(v8 + 32);
  *(_DWORD *)&v26[92] = v12;
  *(_OWORD *)&v26[76] = v10;
  *(_OWORD *)&v26[60] = v11;
  RB::Coverage::set_plane((float32x2_t *)&v25, (float32x2_t *)a2, a3, a4);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x70, 4uLL, 0, &v27);
  long long v13 = v27;
  if (v27)
  {
    long long v14 = (_OWORD *)(*((void *)v27 + 7) + v28.i64[0]);
    long long v15 = *(_OWORD *)&v26[16];
    long long v16 = v25;
    v14[1] = *(_OWORD *)v26;
    float64x2_t v14[2] = v15;
    long long v17 = *(_OWORD *)&v26[80];
    long long v18 = *(_OWORD *)&v26[48];
    long long v19 = *(_OWORD *)&v26[32];
    v14[5] = *(_OWORD *)&v26[64];
    v14[6] = v17;
    _OWORD v14[3] = v19;
    v14[4] = v18;
    *long long v14 = v16;
  }
  else
  {
    float32x2_t v27 = 0;
    int64x2_t v28 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v13);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v28);
  if (*(_DWORD *)(a2 + 136) == 2) {
    unsigned int v20 = 131093;
  }
  else {
    unsigned int v20 = 21;
  }
  float32x2_t v27 = (RB::Buffer *)v20;
  RB::RenderState::set_image((int *)&v27, (uint64_t)&v26[12], *(unsigned __int8 *)(a2 + 124));
  unsigned int v21 = HIDWORD(v27) & 0xFFFFFFC0 | *(_DWORD *)(a1 + 28) & 0x3F;
  LODWORD(v27) = v27 & 0xFFFEFFFF | (*(unsigned __int8 *)(a1 + 24) << 16);
  HIDWORD(v27) = v21;
  int v22 = (const char *)v27;
  RB::Bounds::Bounds(v24, a3, *(float32x2_t *)&a4);
  return RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, v22, 4, ***(void ***)a2 + 80, 0, 1uLL, v24[0], v24[1]);
}

__n128 RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Shader::ImageGlobals &,RB::Fill::ImageData const&,BOOL,RB::BlendMode)::Renderer::draw_path(uint64_t a1, int32x2_t **a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  long long v3 = *(_OWORD *)(v2 + 16);
  *(_OWORD *)&v8[28] = *(_OWORD *)v2;
  long long v9 = v3;
  long long v5 = *(_OWORD *)(v2 + 48);
  long long v4 = *(_OWORD *)(v2 + 64);
  int v6 = *(_DWORD *)(v2 + 80);
  long long v10 = *(_OWORD *)(v2 + 32);
  int v13 = v6;
  long long v12 = v4;
  long long v11 = v5;
  RB::Path::Renderer::render(a2, (uint64_t)v8, *(unsigned char *)(a1 + 24), *(_DWORD *)(a1 + 28));
  return result;
}

uint64_t RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Custom const&,BOOL,float,RB::BlendMode)::Renderer::supports_draw_masks()
{
  return 0;
}

void RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Custom const&,BOOL,float,RB::BlendMode)::Renderer::draw_masks()
{
}

void RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Custom const&,BOOL,float,RB::BlendMode)::Renderer::draw_mask(uint64_t a1, uint64_t a2, float32x2_t a3, double a4)
{
  uint64_t v8 = RB::Fill::Custom::function(*(RB::Fill::Custom **)(a1 + 8), (uint64_t **)a2);
  if (v8)
  {
    long long v9 = (Function *)v8;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)(*((unsigned int *)v8 + 20) + 56), 4uLL, 0, &v16);
    if (v16)
    {
      uint64_t v10 = *((void *)v16 + 7) + v17.i64[0];
      RB::Coverage::set_plane((float32x2_t *)v10, (float32x2_t *)a2, a3, a4);
      if (RB::Fill::Custom::set_custom(*(void *)(a1 + 8), (float32x2_t *)(v10 + 28), (uint64_t)v9, v10 + 56, a2, *(float64x2_t **)(a1 + 16), *(float *)(a1 + 28)))
      {
        *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v16);
        *(int32x2_t *)(a2 + 188) = vmovn_s64(v17);
        if (*(_DWORD *)(a2 + 136) == 2) {
          unsigned int v11 = 131094;
        }
        else {
          unsigned int v11 = 22;
        }
        long long v15 = (const char *)v11;
        RB::Fill::Custom::set_fill_state(*(RB::Fill::Custom **)(a1 + 8), (RB::RenderState *)&v15, v9, (unint64_t **)a2);
        unsigned int v12 = HIDWORD(v15) & 0xFFFFFFC0 | *(_DWORD *)(a1 + 32) & 0x3F;
        LODWORD(v15) = v15 & 0xFFFEFFFF | (*(unsigned __int8 *)(a1 + 24) << 16);
        HIDWORD(v15) = v12;
        int v13 = v15;
        RB::Bounds::Bounds(v14, a3, *(float32x2_t *)&a4);
        RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, v13, 4, ***(void ***)a2 + 80, 0, 1uLL, v14[0], v14[1]);
        RB::Fill::Custom::reset_custom(*(RB::Fill::Custom **)(a1 + 8), (RB::RenderPass *)a2);
      }
    }
  }
}

void RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Custom const&,BOOL,float,RB::BlendMode)::Renderer::draw_path(uint64_t a1, int32x2_t **a2)
{
}

int32x2_t *RB::AlphaThresholdEffect::dod(int32x2_t *this, int32x2_t *a2)
{
  if (vcgt_f32((float32x2_t)vdup_lane_s32(*this, 1), (float32x2_t)*this).u8[0])
  {
    if (COERCE_FLOAT(*this) > 0.0)
    {
      *a2 = (int32x2_t)0x100000001000000;
      a2[1] = vdup_n_s32(0x7F7FFFFFu);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  return this;
}

uint64_t RB::AlphaThresholdEffect::matches(RB::AlphaThresholdEffect *this, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::DisplayList::Predicate::matches_color(a2, (RB::AlphaThresholdEffect *)((char *)this + 8), a3);
}

void RB::AlphaThresholdEffect::apply_transform(RB::AlphaThresholdEffect *this, RB::DisplayList::Contents *a2, const RB::DisplayList::Transform *a3, uint32x4_t a4)
{
}

uint64_t RB::AlphaThresholdEffect::can_mix(float32x2_t *this, float32x2_t *a2)
{
  LODWORD(result) = RB::Fill::Color::can_mix((RB::Fill::Color *)&this[1], (const RB::Fill::Color *)&a2[1]);
  unsigned int v5 = result;
  uint32x2_t v6 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(*this, *a2));
  int v7 = vpmax_u32(v6, v6).u32[0];
  if ((result & 0xFE) != 0) {
    unsigned int v5 = 2;
  }
  if (v7 >= 0) {
    return result;
  }
  else {
    return v5;
  }
}

void RB::AlphaThresholdEffect::mix(float32x2_t *this, float32x2_t *a2, float a3)
{
  *this = vmla_n_f32(*this, vsub_f32(*a2, *this), a3);
  RB::Fill::Color::mix((uint64_t)&this[1], (uint64_t)&a2[1], 0, a3);
}

int32x2_t *RB::AlphaThresholdEffect::render(int32x2_t *result, double a2, float a3, uint64_t a4, uint64_t a5, float32x2_t *a6, uint64_t a7, int a8, float64x2_t *a9, float32x2_t *a10, char a11, __int16 a12, char a13)
{
  if (a7)
  {
    _S8 = a3;
    long long v19 = result;
    if (COERCE_FLOAT(*result) <= 0.0)
    {
      int32x2_t v20 = *(int32x2_t *)(a5 + 160);
      int32x2_t v21 = *(int32x2_t *)(a5 + 168);
      int32x2_t v46 = v20;
      int32x2_t v47 = v21;
    }
    else
    {
      int32x2_t v20 = (int32x2_t)RB::Bounds::Bounds(&v46, *a6, a6[1]);
    }
    int v40 = *(__int32 *)((char *)v19[1].i32 + 2);
    __int16 v42 = v19[2].i16[0];
    *(int32x2_t *)_Q0.f32 = *v19;
    _Q0.i64[0] = vmovl_u16((uint16x4_t)vcvt_f16_f32(_Q0)).u64[0];
    WORD6(v44) = _Q0.i16[0];
    __asm { FCVT            H0, S8 }
    __int16 v39 = v19[1].i16[0];
    *(short float *)_Q0.i16 = *(short float *)&v19[1].i16[3] * *(short float *)_Q0.i16;
    __int16 v41 = _Q0.i16[0];
    HIWORD(v44) = _Q0.i16[2];
    *(float16x4_t *)((char *)&v44 + 4) = RB::Fill::Color::prepare((uint64_t)&v39, *(unsigned __int8 *)(a5 + 124), *(double *)_Q0.i64);
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a5, (RB::Device *)0x58, 4uLL, 0, &v48);
    float32x2_t v27 = v48;
    if (v48)
    {
      uint64_t v28 = *((void *)v48 + 7) + v49.i64[0];
      long long v29 = v43[0];
      *(_OWORD *)(v28 + 16) = v43[1];
      long long v31 = v43[3];
      long long v30 = v44;
      long long v32 = v43[2];
      *(void *)(v28 + 80) = v45;
      *(_OWORD *)(v28 + 48) = v31;
      *(_OWORD *)(v28 + 64) = v30;
      *(_OWORD *)(v28 + 32) = v32;
      *(_OWORD *)uint64_t v28 = v29;
    }
    else
    {
      int v48 = 0;
      int64x2_t v49 = 0uLL;
    }
    *(_DWORD *)(a5 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a5, v27);
    *(int32x2_t *)(a5 + 188) = vmovn_s64(v49);
    uint64_t v33 = (uint64_t)*v19;
    uint64_t v34 = COERCE_FLOAT(*v19) > 0.0;
    uint64_t v35 = *((float *)&v33 + 1) < 1.0;
    if (*(_DWORD *)(a5 + 136) == 2) {
      uint64_t v36 = 131109;
    }
    else {
      uint64_t v36 = 37;
    }
    if (a11) {
      uint64_t v37 = 0x10000;
    }
    else {
      uint64_t v37 = 0;
    }
    if (a8) {
      char v38 = 2;
    }
    else {
      char v38 = 1;
    }
    *(_DWORD *)(a5 + 232) = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)a5, a7);
    *(unsigned char *)(a5 + 236) = v38;
    uint64_t result = RB::RenderPass::draw_indexed_primitives((int32x2_t *)a5, (const char *)(v37 | ((unint64_t)(a13 & 0x3F) << 32) | v36 | (v35 << 8) | (v34 << 7)), 4, ***(void ***)a5 + 80, 0, 1uLL, v46, v47);
    *(_DWORD *)(a5 + 232) = 0;
    *(unsigned char *)(a5 + 236) = 0;
  }
  return result;
}

void sub_2141992C0(_Unwind_Exception *a1)
{
  *(_DWORD *)(v1 + 232) = 0;
  *(unsigned char *)(v1 + 236) = 0;
  _Unwind_Resume(a1);
}

float32x2_t RB::anonymous namespace'::set_alpha_effect(float32x2_t *a1, uint64_t a2, int32x2_t *a3, float64x2_t *a4, float32x2_t *a5, int32x2_t a6)
{
  a6.i32[0] = 0;
  int32x2_t v10 = a3[1];
  uint32x2_t v11 = (uint32x2_t)vceq_s32(v10, (int32x2_t)0x8000000080000000);
  int8x8_t v12 = (int8x8_t)vdup_lane_s32(vcgt_s32(a6, (int32x2_t)vpmin_u32(v11, v11)), 0);
  RB::Coverage::set_plane((float32x2_t *)a2, a1, (float32x2_t)vbsl_s8(v12, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*a3)), COERCE_DOUBLE(vbsl_s8(v12, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v10))));
  float64x2_t v13 = a4[1];
  v27[0] = *a4;
  v27[1] = v13;
  v27[2] = a4[2];
  if (RB::AffineTransform::invert((RB::AffineTransform *)v27)) {
    long long v14 = (float64x2_t *)v27;
  }
  else {
    long long v14 = a4;
  }
  float64x2_t v15 = v14[1];
  float32x2_t v16 = a1[13];
  v17.i64[0] = v16.i32[0];
  v17.i64[1] = v16.i32[1];
  __asm { FMOV            V4.2D, #0.5 }
  float64x2_t v23 = vmulq_f64(vcvtq_f64_s64(v17), _Q4);
  float64x2_t v24 = vmulq_n_f64(*v14, v23.f64[0]);
  float64x2_t v25 = vmlaq_laneq_f64(vaddq_f64(v24, v14[2]), v15, v23, 1);
  *(float32x2_t *)(a2 + 28) = vcvt_f32_f64(v24);
  *(float32x2_t *)(a2 + 36) = vcvt_f32_f64(vmulq_n_f64(v15, -v23.f64[1]));
  *(float32x2_t *)(a2 + 44) = vcvt_f32_f64(v25);
  *(float32x2_t *)(a2 + 52) = *a5;
  float32x2_t result = vadd_f32(a5[1], *a5);
  *(float32x2_t *)(a2 + 60) = result;
  return result;
}

size_t RB::AlphaThresholdEffect::render(int32x2_t *this, CGContextRef *a2, uint16x4_t a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  int v5 = *((unsigned __int8 *)a2 + 8);
  *(int32x2_t *)v26[0].i8 = this[1];
  v26[0].i16[4] = this[2].i16[0];
  RB::Fill::Color::convert((uint64_t)v26, v5, a3);
  uint64_t v6 = 0;
  v7.i16[3] = 15360;
  v7.i32[0] = v26[0].i32[0];
  v7.i16[2] = v26[0].i16[2];
  __asm { FMOV            V2.4S, #1.0 }
  v13.i64[0] = 0x3F0000003F000000;
  v13.i64[1] = 0x3F0000003F000000;
  int8x16_t v14 = (int8x16_t)vcvtq_u32_f32(vmlaq_f32(v13, (float32x4_t)vdupq_n_s32(0x437F0000u), vminnmq_f32(vmaxnmq_f32(vcvtq_f32_f16(vmul_f16((float16x4_t)vdup_n_s16(v26[0].u16[3]), v7)), (float32x4_t)0), _Q2)));
  int v15 = v14.i32[2] | (v14.i32[0] << 16);
  v14.i32[0] = vextq_s8(v14, v14, 8uLL).i32[1];
  *(uint32x2_t *)v14.i8 = vshl_u32(*(uint32x2_t *)v14.i8, (uint32x2_t)0x800000018);
  unsigned int v16 = v15 | v14.i32[0] | v14.i32[1];
  float32x4_t v17 = (float32x4_t)vdupq_lane_s32(*this, 0);
  float32x4_t v18 = (float32x4_t)vdupq_lane_s32(*this, 1);
  int8x16_t v19 = (int8x16_t)vdupq_n_s32(v16);
  int64x2_t v20 = (int64x2_t)xmmword_214219C30;
  int64x2_t v21 = (int64x2_t)xmmword_214219C40;
  float32x4_t v22 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  int64x2_t v23 = vdupq_n_s64(4uLL);
  do
  {
    float32x4_t v24 = vmulq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vcvtq_f64_u64((uint64x2_t)v21)), vcvtq_f64_u64((uint64x2_t)v20)), v22);
    v26[v6] = (int16x8_t)vbicq_s8(v19, vorrq_s8((int8x16_t)vcgtq_f32(v17, v24), (int8x16_t)vcgtq_f32(v24, v18)));
    int64x2_t v20 = vaddq_s64(v20, v23);
    int64x2_t v21 = vaddq_s64(v21, v23);
    ++v6;
  }
  while (v6 != 64);
  return RB::CGContext::apply_alpha_lut(a2, v26);
}

void *RB::AlphaThresholdEffect::encode(RB::AlphaThresholdEffect *this, RB::Encoder *a2)
{
  if (COERCE_FLOAT(*(void *)this) == 0.0)
  {
    int v4 = HIDWORD(*(void *)this);
  }
  else
  {
    int v6 = *(void *)this;
    RB::ProtobufEncoder::encode_varint(a2, 0xDuLL);
    RB::ProtobufEncoder::encode_fixed32(a2, v6);
    int v4 = *((int *)this + 1);
  }
  if (*(float *)&v4 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x15uLL);
    RB::ProtobufEncoder::encode_fixed32(a2, v4);
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Fill::Color::encode((RB::AlphaThresholdEffect *)((char *)this + 8), a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

unint64_t RB::AlphaThresholdEffect::decode(RB::AlphaThresholdEffect *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      unint64_t v6 = v5 >> 3;
      if ((v5 >> 3) == 3)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          RB::Fill::Color::decode((uint64_t)this + 8, a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
        }
      }
      else if (v6 == 2)
      {
        *((float *)this + 1) = RB::ProtobufDecoder::float_field(a2, v5);
      }
      else if (v6 == 1)
      {
        *(float *)this = RB::ProtobufDecoder::float_field(a2, v5);
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v5);
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::AlphaThresholdEffect::print(RB::AlphaThresholdEffect *this, std::string *a2)
{
  RB::SexpString::push(a2, "alpha-threshold");
  RB::SexpString::printf(a2, 1, "(alpha [%g %g])", COERCE_FLOAT(*(void *)this), COERCE_FLOAT(HIDWORD(*(void *)this)));
  RB::Fill::Color::print((RB::AlphaThresholdEffect *)((char *)this + 8), a2);
  RB::SexpString::pop(a2);
}

uint64_t *RB::AlphaGradientEffect::AlphaGradientEffect(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return RB::Fill::Gradient::Gradient(a1, a2, 0, (RB::Heap *)(a3 + 16));
}

int32x2_t RB::AlphaGradientEffect::dod(RB::AlphaGradientEffect *this, int32x2_t *a2, double a3, double a4, double a5, double a6, float a7)
{
  *(float *)result.i32 = RB::Fill::Gradient::sample_alpha(this, 0.0, a4, a5, a6, a7);
  if (*(float *)result.i32 > 0.0)
  {
    int32x2_t result = vdup_n_s32(0x7F7FFFFFu);
    *a2 = (int32x2_t)0x100000001000000;
    a2[1] = result;
  }
  return result;
}

uint64_t RB::AlphaGradientEffect::matches(RB::AlphaGradientEffect *this, const RB::DisplayList::Predicate *a2)
{
  return RB::DisplayList::Predicate::matches_non_color(a2);
}

RB::Fill::Gradient *RB::AlphaGradientEffect::render(RB::Fill::Gradient *result, double a2, double a3, double a4, double a5, float a6, uint64_t a7, uint64_t a8, float32x2_t *a9, uint64_t a10, int a11, float64x2_t *a12, float32x2_t *a13, char a14, __int16 a15, char a16)
{
  if (a10)
  {
    float v16 = *(float *)&a3;
    uint64_t v23 = (uint64_t)result;
    if (RB::Fill::Gradient::sample_alpha(result, 0.0, a3, a4, a5, a6) <= 0.0)
    {
      float32x2_t v24 = RB::Bounds::Bounds(&v39, *a9, a9[1]);
    }
    else
    {
      float32x2_t v24 = *(float32x2_t *)(a8 + 160);
      int32x2_t v25 = *(int32x2_t *)(a8 + 168);
      int32x2_t v39 = (int32x2_t)v24;
      int32x2_t v40 = v25;
    }
    *(float *)&double v26 = v16;
    RB::Fill::Gradient::set_gradient_color(v23, (float16x4_t *)((char *)&v37 + 4), a8, v26);
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a8, (RB::Device *)0x58, 4uLL, 0, &v41);
    uint64_t v27 = v41;
    if (v41)
    {
      uint64_t v28 = *((void *)v41 + 7) + v42.i64[0];
      long long v29 = v36[0];
      *(_OWORD *)(v28 + 16) = v36[1];
      long long v31 = v36[3];
      long long v30 = v37;
      long long v32 = v36[2];
      *(void *)(v28 + 80) = v38;
      *(_OWORD *)(v28 + 48) = v31;
      *(_OWORD *)(v28 + 64) = v30;
      *(_OWORD *)(v28 + 32) = v32;
      *(_OWORD *)uint64_t v28 = v29;
    }
    else
    {
      __int16 v41 = 0;
      int64x2_t v42 = 0uLL;
    }
    *(_DWORD *)(a8 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a8, v27);
    *(int32x2_t *)(a8 + 188) = vmovn_s64(v42);
    if (*(_DWORD *)(a8 + 136) == 2) {
      int v33 = 131109;
    }
    else {
      int v33 = 37;
    }
    if (a14) {
      int v34 = 65600;
    }
    else {
      int v34 = 64;
    }
    LODWORD(v41) = v34 | v33;
    HIDWORD(v41) = a16 & 0x3F;
    RB::Fill::Gradient::set_fill_state(v23, (int *)&v41, a8, v16);
    if (a11) {
      char v35 = 2;
    }
    else {
      char v35 = 1;
    }
    *(_DWORD *)(a8 + 232) = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)a8, a10);
    *(unsigned char *)(a8 + 236) = v35;
    int32x2_t result = (RB::Fill::Gradient *)RB::RenderPass::draw_indexed_primitives((int32x2_t *)a8, (const char *)v41, 4, ***(void ***)a8 + 80, 0, 1uLL, v39, v40);
    *(void *)(a8 + 228) = 0;
    *(void *)(a8 + 220) = 0;
    *(unsigned char *)(a8 + 236) = 0;
  }
  return result;
}

void sub_2141999D0(_Unwind_Exception *a1)
{
  *(_DWORD *)(v1 + 232) = 0;
  *(unsigned char *)(v1 + 236) = 0;
  _Unwind_Resume(a1);
}

void *RB::AlphaGradientEffect::encode(RB::AlphaGradientEffect *this, RB::Encoder *a2)
{
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Fill::Gradient::encode(this, a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

uint64_t RB::AlphaGradientEffect::decode(RB::AlphaGradientEffect *this, RB::Decoder *a2)
{
  uint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    uint64_t v5 = result;
    do
    {
      if ((v5 & 0x7FFFFFFF8) == 8)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          RB::Fill::Gradient::decode(this, (RB::Heap **)a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v5);
      }
      uint64_t result = RB::ProtobufDecoder::next_field(a2);
      uint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::AlphaGradientEffect::print(RB::AlphaGradientEffect *this, RB::SexpString *a2)
{
}

void sub_214199BFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11)
{
  int v13 = v11[2] - 1;
  float64x2_t v11[2] = v13;
  if (!v13) {
    (*(void (**)(_DWORD *))(*(void *)v11 + 8))(v11);
  }
  _Unwind_Resume(exception_object);
}

void RB::XML::Element::set<RB::XML::Value::Gradient>()
{
}

void sub_214199D8C(_Unwind_Exception *a1)
{
  if (*v2) {
    free(*v2);
  }
  MEMORY[0x21669AC10](v1, 0x10A1C4050C3A8F3);
  _Unwind_Resume(a1);
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Gradient,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_214199E24(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Gradient *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Gradient>,std::allocator<RB::XML::Value::Gradient>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Gradient *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Gradient>,std::allocator<RB::XML::Value::Gradient>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void *RB::vector<RB::Fill::Gradient::Stop,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned long,16ul>(*(void **)a1, (size_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,16ul>(void *a1, size_t *a2, uint64_t a3)
{
  int v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(16 * a3);
    size_t v6 = v5 >> 4;
    if (v5 >> 4 != *a2)
    {
      float16x4_t v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      int v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t rb_alpha_blend_mode(unsigned int a1)
{
  if (a1 > 3) {
    return 12;
  }
  else {
    return rb_alpha_blend_mode(RBAlphaBlendMode)::table[a1];
  }
}

uint64_t rb_alpha_blend_mode(int a1)
{
  if (a1 == 11) {
    int v1 = 2;
  }
  else {
    int v1 = 0;
  }
  if (a1 == 15) {
    unsigned int v2 = 3;
  }
  else {
    unsigned int v2 = v1;
  }
  if (a1) {
    return v2;
  }
  else {
    return 1;
  }
}

uint64_t cg_line_cap(unsigned int a1)
{
  if (a1 > 6) {
    return 0;
  }
  else {
    return dword_214219DEC[(char)a1];
  }
}

uint64_t rb_transition_method(int a1)
{
  if ((a1 - 1) >= 8) {
    char v1 = 0;
  }
  else {
    char v1 = 0x408070605030201uLL >> (8 * (a1 - 1));
  }
  return v1 & 0xF;
}

uint64_t rb_transition_method(Method a1)
{
  if (((_BYTE)a1 - 1) > 7u) {
    return 0;
  }
  else {
    return dword_214219E54[(char)((_BYTE)a1 - 1)];
  }
}

unint64_t rb_shader_type(unsigned int a1)
{
  if (a1 >= 5) {
    uint64_t v1 = 0;
  }
  else {
    uint64_t v1 = a1;
  }
  return v1 | ((unint64_t)(a1 < 5) << 32);
}

uint64_t *RBGetCachedImageTexture(uint64_t **a1, CGImage *a2, const RB::Fill::ImageData *a3, float64x2_t *a4, char a5)
{
  uint64_t v9 = **a1;
  unsigned int Identifier = CGImageGetIdentifier();
  uint64_t result = RB::Device::texture_cache(v9, 0, Identifier);
  if (result)
  {
    uint64_t v12 = (uint64_t)result;
    entrCGFloat y = RB::TextureCache::find_entry(v12, (unsigned __int8 *)&v15);
    if ((entry & 0x80000000) != 0)
    {
      return 0;
    }
    else
    {
      uint64_t v14 = v12 + 32;
      if (*(void *)(v12 + 48)) {
        uint64_t v14 = *(void *)(v12 + 48);
      }
      return *(uint64_t **)(v14 + 16 * entry + 8);
    }
  }
  return result;
}

uint64_t anonymous namespace'::texture_cache_params(uint64_t a1, uint64_t a2, float64x2_t *a3, char a4, int32x2_t a5)
{
  int32x2_t v8 = a5;
  int v9 = *(unsigned __int8 *)(a1 + 29);
  int v10 = RB::Fill::ImageData::image_filter_uses_mipmaps(a2, a3, a5);
  int v11 = v10;
  unsigned __int8 v12 = 0;
  unsigned int v13 = *(unsigned __int16 *)(a2 + 78);
  BOOL v14 = *(_WORD *)(a2 + 78) == 4 || a3 == 0;
  if (!v14 && (v10 & 1) == 0)
  {
    unsigned int v15 = (v13 >> 8) & 0xF;
    BOOL v16 = v15 > 8;
    int v17 = (1 << v15) & 0x124;
    if (v16 || v17 == 0) {
      goto LABEL_11;
    }
    float64x2_t v19 = vcvtq_f64_f32(*(float32x2_t *)(a2 + 44));
    float64x2_t v20 = vcvtq_f64_f32(*(float32x2_t *)(a2 + 56));
    v34[0] = vcvtq_f64_f32(*(float32x2_t *)(a2 + 32));
    v34[1] = v19;
    v34[2] = v20;
    *(double *)&long long v21 = RB::operator*(v34, a3);
    *(_OWORD *)char v35 = v21;
    long long v36 = v22;
    long long v37 = v23;
    float v24 = vaddv_f32(vdiv_f32((float32x2_t)RB::AffineTransform::scale2((float64x2_t *)v35), vcvt_f32_s32(v8))) * 0.5;
    if (v24 > 0.5)
    {
LABEL_11:
      unsigned __int8 v12 = 0;
    }
    else
    {
      v35[0] = 0;
      frexpf(v24, v35);
      unsigned __int8 v12 = 0;
      uint32x2_t v30 = (uint32x2_t)vcgt_s32(v8, (int32x2_t)0x1000000010);
      if ((vpmin_u32(v30, v30).u32[0] & 0x80000000) != 0 && v35[0] < 0)
      {
        unsigned __int8 v12 = 0;
        int v31 = v35[0] + 1;
        do
        {
          int v32 = v31;
          ++v12;
          uint32x2_t v33 = (uint32x2_t)vcgt_s32(v8, (int32x2_t)0x2100000021);
          if ((vpmin_u32(v33, v33).u32[0] & 0x80000000) == 0) {
            break;
          }
          int32x2_t v8 = vshr_n_s32(v8, 1uLL);
          ++v31;
        }
        while (v32);
      }
    }
  }
  if (v11) {
    int v25 = 2;
  }
  else {
    int v25 = 0;
  }
  int v26 = ((v13 & 0xF00) != 0) & (v13 >> 14);
  int v27 = (8 * (a4 & 1)) | v25 | v26;
  int v28 = v9 & 0xFE;
  if (!v26) {
    int v28 = v9;
  }
  return v28 | (v27 << 24) | (v12 << 16) | 0x100u;
}

uint64_t RBMakeCachedImageTexture(uint64_t **a1, CGImage *a2, const RB::Fill::ImageData *a3, float64x2_t *a4, char a5)
{
  uint64_t v10 = **a1;
  unsigned int Identifier = CGImageGetIdentifier();
  unsigned __int8 v12 = (int32x2_t *)RB::Device::texture_cache(v10, 0, Identifier);
  if (!v12)
  {
    CGImageGetWidth(a2);
    CGImageGetHeight(a2);
    if (!CGImageIsMask(a2)) {
      CGImageGetAlphaInfo(a2);
    }
    operator new();
  }
  return RB::TextureCache::prepare(v12, *a1, a2, (unsigned __int8 *)&v14);
}

void sub_21419A4D8(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A0C400DFC61FBLL);
  _Unwind_Resume(a1);
}

uint64_t RBInvalidateCachedImage(RB::Device *a1, CGImage *a2)
{
  unsigned int Identifier = CGImageGetIdentifier();
  return RB::Device::set_texture_cache((uint64_t)a1, 0, Identifier, 0);
}

uint64_t *RBGetCachedIOSurfaceTexture(uint64_t **a1, IOSurfaceRef buffer, const RB::Fill::ImageData *a3, float64x2_t *a4, char a5)
{
  uint64_t v9 = **a1;
  IOSurfaceID ID = IOSurfaceGetID(buffer);
  uint64_t result = RB::Device::texture_cache(v9, 1, ID);
  if (result)
  {
    uint64_t v12 = (uint64_t)result;
    entrCGFloat y = RB::TextureCache::find_entry(v12, (unsigned __int8 *)&v15);
    if ((entry & 0x80000000) != 0)
    {
      return 0;
    }
    else
    {
      uint64_t v14 = v12 + 32;
      if (*(void *)(v12 + 48)) {
        uint64_t v14 = *(void *)(v12 + 48);
      }
      return *(uint64_t **)(v14 + 16 * entry + 8);
    }
  }
  return result;
}

uint64_t RBMakeCachedIOSurfaceTexture(uint64_t **a1, IOSurfaceRef buffer, const RB::Fill::ImageData *a3, float64x2_t *a4, char a5)
{
  uint64_t v10 = **a1;
  IOSurfaceID ID = IOSurfaceGetID(buffer);
  uint64_t v12 = (int32x2_t *)RB::Device::texture_cache(v10, 1, ID);
  if (!v12)
  {
    IOSurfaceGetWidth(buffer);
    IOSurfaceGetHeight(buffer);
    operator new();
  }
  return RB::TextureCache::prepare(v12, *a1, buffer, (unsigned __int8 *)&v14);
}

void sub_21419A728(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A0C400DFC61FBLL);
  _Unwind_Resume(a1);
}

uint64_t RBInvalidateCachedIOSurface(RB::Device *a1, IOSurfaceRef buffer)
{
  IOSurfaceID ID = IOSurfaceGetID(buffer);
  return RB::Device::set_texture_cache((uint64_t)a1, 1, ID, 0);
}

uint64_t *RBGetCachedMTLTexture(uint64_t **a1, id object, uint64_t a3, float64x2_t *a4, char a5)
{
  uint64_t v9 = **a1;
  if (!AssociatedObject) {
    return 0;
  }
  uint64_t result = RB::Device::texture_cache(v9, 2, AssociatedObject);
  if (!result) {
    return result;
  }
  uint64_t v12 = (uint64_t)result;
  entrCGFloat y = RB::TextureCache::find_entry(v12, (unsigned __int8 *)&v15);
  if ((entry & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v14 = v12 + 32;
  if (*(void *)(v12 + 48)) {
    uint64_t v14 = *(void *)(v12 + 48);
  }
  return *(uint64_t **)(v14 + 16 * entry + 8);
}

uint64_t RBMakeCachedMTLTexture(uint64_t *a1, id object, uint64_t a3, float64x2_t *a4, char a5)
{
  uint64_t v10 = *(void *)*a1;
  if (!v11)
  {
    uint64_t v14 = *(void *)(v10 + 24);
    uint64_t result = [object device];
    if (v14 != result) {
      return result;
    }
    uint64_t result = [object textureType];
    if (result != 2) {
      return result;
    }
  }
  uint64_t v12 = RB::Device::texture_cache(v10, 2, v11);
  if (!v12) {
    operator new();
  }
  return RB::TextureCache::prepare((uint64_t)v12, *a1, object, (unsigned __int8 *)&v15);
}

void sub_21419A9E8(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A0C400DFC61FBLL);
  _Unwind_Resume(a1);
}

id RBInvalidateCachedMTLTexture(uint64_t a1, id object)
{
  if (result)
  {
    return (id)RB::Device::set_texture_cache(a1, 2, result, 0);
  }
  return result;
}

void RBUpdateIOSurfaceCodingProxy(id *a1, uint64_t a2)
{
  if (*MEMORY[0x263F15730]) {
    int v4 = @"LKCGImageCodingProxy";
  }
  else {
    int v4 = @"CAIOSurfaceCodingProxy";
  }
  Class v5 = NSClassFromString(&v4->isa);
  if (v5)
  {
    size_t v6 = v5;
    if (*a1)
    {
      char isKindOfClass = objc_opt_isKindOfClass();
      id v8 = *a1;
      if (isKindOfClass)
      {
        if (v8) {
          return;
        }
      }
      else
      {

        *a1 = 0;
      }
    }
    if ([(objc_class *)v6 instancesRespondToSelector:sel_initWithObject_])
    {
      uint64_t v9 = [[v6 alloc] initWithObject:a2];

      *a1 = (id)v9;
    }
  }
}

BOOL RBProjectVersion(int a1, int a2, int a3)
{
  {
    int v10 = a1;
    int v8 = a2;
    int v9 = a3;
    a2 = v8;
    a3 = v9;
    int v6 = v5;
    a1 = v10;
    if (v6)
    {
      RBProjectVersion::versions = RBProjectVersion::$_0::operator()();
      dword_267807050 = v7;
      a1 = v10;
      a2 = v8;
      a3 = v9;
    }
  }
  if ((int)RBProjectVersion::versions >= a1) {
    char v3 = 1;
  }
  else {
    char v3 = -1;
  }
  if (RBProjectVersion::versions == a1)
  {
    char v3 = SHIDWORD(RBProjectVersion::versions) >= a2 ? 1 : -1;
    if (HIDWORD(RBProjectVersion::versions) == a2)
    {
      char v3 = -1;
      if (dword_267807050 >= a3) {
        char v3 = 1;
      }
      if (dword_267807050 == a3) {
        char v3 = 0;
      }
    }
  }
  return (v3 & 0x80) == 0;
}

uint64_t RBProjectVersion::$_0::operator()()
{
  __endptr = 0;
  unsigned int v0 = strtol("6.2.15", &__endptr, 10);
  uint64_t v1 = 0;
  if (*__endptr == 46)
  {
    uint64_t v1 = strtol(__endptr + 1, &__endptr, 10) << 32;
    if (*__endptr == 46) {
      strtol(__endptr + 1, &__endptr, 10);
    }
  }
  return v1 | v0;
}

float RB::BezierTiming::Fn::solve(RB::BezierTiming::Fn *this, float a2, float a3)
{
  double v3 = a2;
  float v5 = *((float *)this + 1);
  float v4 = *((float *)this + 2);
  double v6 = v4;
  double v7 = v5;
  double v8 = *(float *)this;
  double v9 = a3;
  int v10 = 8;
  double v11 = a2;
  do
  {
    double v12 = -(v3 - (v8 + (v7 + v11 * v6) * v11) * v11);
    if (fabs(v12) < v9) {
      return v11;
    }
    double v13 = v8 + ((float)(v5 + v5) + v11 * (float)(v4 * 3.0)) * v11;
    if (fabs(v13) < 0.000001) {
      break;
    }
    double v11 = v11 - v12 / v13;
    --v10;
  }
  while (v10);
  float v14 = 0.0;
  if (a2 >= 0.0)
  {
    float v14 = 1.0;
    if (a2 <= 1.0)
    {
      double v15 = 0.0;
      double v16 = 1.0;
      int v17 = -1025;
      double v18 = v3;
      do
      {
        if (__CFADD__(v17++, 1)) {
          break;
        }
        double v20 = -(v3 - (v8 + (v7 + v18 * v6) * v18) * v18);
        if (fabs(v20) < v9) {
          break;
        }
        if (v20 >= 0.0) {
          double v16 = v18;
        }
        else {
          double v15 = v18;
        }
        double v18 = v15 + (v16 - v15) * 0.5;
      }
      while (v15 < v16);
      return v18;
    }
  }
  return v14;
}

float RB::BezierTiming::eval(RB::BezierTiming *this, float a2)
{
  float v3 = RB::BezierTiming::Fn::solve(this, a2, 0.001);
  return (*((float *)this + 3) + (*((float *)this + 4) + *((float *)this + 5) * v3) * v3) * v3;
}

float RB::BezierTiming::derivative(RB::BezierTiming *this, float a2)
{
  float v3 = RB::BezierTiming::Fn::solve(this, a2, 0.001);
  return *((float *)this + 3)
       + ((float)(*((float *)this + 4) + *((float *)this + 4)) + (float)(*((float *)this + 5) * 3.0) * v3) * v3;
}

float RB::BezierTiming::eval_with_derivative(RB::BezierTiming *this, float a2)
{
  float v3 = RB::BezierTiming::Fn::solve(this, a2, 0.001);
  return (*((float *)this + 3) + (*((float *)this + 4) + *((float *)this + 5) * v3) * v3) * v3;
}

float RB::SpringTiming::eval(RB::SpringTiming *this, float a2)
{
  float v3 = -a2;
  if (*((float *)this + 1) >= 1.0)
  {
    float v6 = *((float *)this + 3) + (float)(*((float *)this + 4) * a2);
    float v5 = expf(*(float *)this * v3) * v6;
  }
  else
  {
    __float2 v4 = __sincosf_stret(*((float *)this + 2) * a2);
    float v5 = (float)((float)(*((float *)this + 3) * v4.__cosval) + (float)(*((float *)this + 4) * v4.__sinval))
       * expf((float)(*((float *)this + 1) * v3) * *(float *)this);
  }
  return 1.0 - v5;
}

float RB::SpringTiming::derivative(RB::SpringTiming *this, float a2)
{
  if (*((float *)this + 1) >= 1.0)
  {
    float v9 = *(float *)this;
    float v7 = expf(-(float)(a2 * *(float *)this));
    float v8 = (float)(*((float *)this + 3) * v9) + (float)(*((float *)this + 4) * (float)((float)(v9 * a2) + -1.0));
  }
  else
  {
    __float2 v4 = __sincosf_stret(*((float *)this + 2) * a2);
    float v6 = *(float *)this;
    float v5 = *((float *)this + 1);
    float v7 = expf((float)-(float)(a2 * v5) * *(float *)this);
    float v8 = (float)((float)-(float)((float)(*((float *)this + 4) * *((float *)this + 2))
                               - (float)((float)(v6 * v5) * *((float *)this + 3)))
               * v4.__cosval)
       + (float)((float)((float)(*((float *)this + 2) * *((float *)this + 3))
                       + (float)((float)(v6 * v5) * *((float *)this + 4)))
               * v4.__sinval);
  }
  return v8 * v7;
}

unint64_t RB::Animation::size(uint64_t a1, unint64_t a2)
{
  unint64_t result = 0;
  while (result < a2)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 4 * result);
    if (v4 == 18)
    {
      result += (2 * *(_DWORD *)(a1 + 4 * result + 4) + 3);
      return result;
    }
    result += RB::Animation::_term_args[v4] + 1;
    if ((v4 - 15) <= 0xFFFFFFFB) {
      return result;
    }
  }
  return result;
}

uint64_t RB::Animation::hash(unsigned int *a1, uint64_t a2)
{
  for (uint64_t result = 2166136261; a2; --a2)
  {
    unsigned int v4 = *a1++;
    uint64_t result = (16777619 * result) ^ v4;
  }
  return result;
}

BOOL RB::Animation::equal(_DWORD *a1, unint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (a2 != a4) {
    return 0;
  }
  if (!a2) {
    return 1;
  }
  if (*a1 != *a3) {
    return 0;
  }
  uint64_t v4 = 1;
  do
  {
    unint64_t v5 = v4;
    if (a2 == v4) {
      break;
    }
    int v6 = a1[v4];
    int v7 = a3[v4++];
  }
  while (v6 == v7);
  return v5 >= a2;
}

float RB::Animation::active_duration(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = 0;
    float v3 = 0.0;
    float v4 = 1.0;
    while (2)
    {
      unint64_t v5 = (float *)(a1 + 4 * v2);
      uint64_t v6 = *(unsigned int *)v5;
      switch((int)v6)
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 8:
        case 9:
        case 10:
        case 15:
        case 16:
        case 17:
          float v9 = v5[1];
          goto LABEL_17;
        case 5:
          float v13 = v5[1];
          float v14 = 1.5;
          goto LABEL_15;
        case 6:
          float v13 = v5[1];
          float v14 = 1.65;
          goto LABEL_15;
        case 7:
          float v13 = v5[1];
          float v14 = 2.075;
LABEL_15:
          float v9 = v13 * v14;
          goto LABEL_17;
        case 11:
          float v4 = v5[1] * v4;
          goto LABEL_6;
        case 12:
          float32x2_t v7 = vrecpe_f32((float32x2_t)LODWORD(v4));
          float32x2_t v8 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v4), v7), v7);
          float v3 = vmlas_n_f32(v3, v5[1], vmul_f32(v8, vrecps_f32((float32x2_t)LODWORD(v4), v8)).f32[0]);
          goto LABEL_6;
        case 13:
        case 14:
          float v18 = v4;
          float v10 = v5[1] * RB::Animation::active_duration(v5 + 2, a2 - v2 - 2);
          float32x2_t v11 = vrecpe_f32((float32x2_t)LODWORD(v18));
          float32x2_t v12 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v18), v11), v11);
          LODWORD(v9) = vmul_f32(v12, vrecps_f32((float32x2_t)LODWORD(v18), v12)).u32[0];
          return v3 + (float)(v10 * v9);
        case 18:
          float v9 = v5[2];
          goto LABEL_17;
        default:
LABEL_6:
          v2 += RB::Animation::_term_args[v6] + 1;
          if (v2 >= a2) {
            goto LABEL_9;
          }
          continue;
      }
    }
  }
  float v4 = 1.0;
  float v3 = 0.0;
LABEL_9:
  float v9 = 0.0;
LABEL_17:
  float32x2_t v15 = vrecpe_f32((float32x2_t)LODWORD(v4));
  float32x2_t v16 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v4), v15), v15);
  LODWORD(v10) = vmul_f32(v16, vrecps_f32((float32x2_t)LODWORD(v4), v16)).u32[0];
  return v3 + (float)(v10 * v9);
}

uint64_t RB::Animation::prepare(uint64_t result, unint64_t a2, uint64_t a3)
{
  if (a2)
  {
    unint64_t v3 = 0;
    while (2)
    {
      uint64_t v4 = *(unsigned int *)(result + 4 * v3);
      switch((int)v4)
      {
        case 0:
        case 1:
        case 15:
        case 16:
        case 17:
        case 18:
          return result;
        case 2:
          unint64_t v14 = 0x3EF5C294BF3D70A6;
          goto LABEL_13;
        case 3:
          *(void *)a3 = 0x3FDEB852BF3D70A4;
          float v15 = 3.0;
          float v12 = -2.0;
          float v9 = 0.0;
          uint64_t v16 = 5;
          uint64_t v17 = 4;
          uint64_t v18 = 3;
          uint64_t v19 = 2;
          float v13 = 0.0;
          goto LABEL_23;
        case 4:
          unint64_t v14 = 0xBF47AE143F051EB8;
LABEL_13:
          *(void *)a3 = v14;
          float v13 = 0.0;
          float v15 = 3.0;
          float v12 = -2.0;
          uint64_t v16 = 5;
          uint64_t v17 = 4;
          uint64_t v18 = 3;
          float v9 = 1.26;
          goto LABEL_19;
        case 5:
          *(_DWORD *)a3 = 1065354305;
          float v15 = 1.0;
          float v12 = 0.0;
          uint64_t v16 = 4;
          uint64_t v17 = 3;
          uint64_t v18 = 2;
          float v9 = 15.708;
          uint64_t v19 = 1;
          float v13 = 15.708;
          goto LABEL_23;
        case 6:
          *(_DWORD *)a3 = 1061157876;
          float v15 = 1.0;
          float v13 = 1.1337;
          uint64_t v16 = 4;
          uint64_t v17 = 3;
          float v12 = 10.391;
          goto LABEL_17;
        case 7:
          *(_DWORD *)a3 = 1057798793;
          float v15 = 1.0;
          float v13 = 0.65807;
          uint64_t v16 = 4;
          uint64_t v17 = 3;
          float v12 = 13.122;
LABEL_17:
          uint64_t v18 = 2;
          float v9 = 15.708;
          goto LABEL_22;
        case 8:
          double v20 = (float *)(result + 4 * v3);
          float v21 = v20[2];
          float v22 = v20[3];
          float v9 = v21 * 3.0;
          float v23 = (float)(v20[4] - v21) * 3.0;
          float v24 = v23 - v9;
          float v25 = 1.0 - v23;
          float v13 = v22 * 3.0;
          float v26 = (float)(v20[5] - v22) * 3.0;
          float v15 = v26 - v13;
          float v12 = 1.0 - v26;
          *(float *)a3 = v25;
          *(float *)(a3 + 4) = v24;
          uint64_t v16 = 5;
          uint64_t v17 = 4;
          uint64_t v18 = 3;
LABEL_19:
          uint64_t v19 = 2;
          goto LABEL_23;
        case 9:
        case 10:
          unint64_t v5 = (float *)(result + 4 * v3);
          float v6 = v5[2];
          float v7 = v5[3];
          float v8 = 0.0;
          if (v4 == 10) {
            float v8 = v5[5];
          }
          float v9 = sqrtf(v7 / v6);
          float v10 = sqrtf(v7 * v6);
          float v11 = v5[4] / (float)(v10 + v10);
          if (v11 >= 1.0)
          {
            float v13 = v9 - v8;
            float v12 = 0.0;
          }
          else
          {
            float v12 = sqrtf(-(float)((float)(v11 * v11) + -1.0)) * v9;
            float v13 = (float)-(float)(v8 - (float)(v11 * v9)) / v12;
          }
          *(float *)a3 = v11;
          float v15 = 1.0;
          uint64_t v16 = 4;
          uint64_t v17 = 3;
          uint64_t v18 = 2;
LABEL_22:
          uint64_t v19 = 1;
LABEL_23:
          *(float *)(a3 + 4 * v19) = v9;
          *(float *)(a3 + 4 * v18) = v12;
          *(float *)(a3 + 4 * v17) = v15;
          *(float *)(a3 + 4 * v16) = v13;
          break;
        default:
          v3 += RB::Animation::_term_args[v4] + 1;
          if (v3 < a2) {
            continue;
          }
          break;
      }
      break;
    }
  }
  return result;
}

void RB::Animation::eval(uint64_t a1, unint64_t a2, int32x2_t *a3, double a4, double a5)
{
  float v5 = *(float *)&a4;
  if (a2)
  {
    unint64_t v9 = 0;
    unint64_t v10 = a2 - 2;
    while (2)
    {
      float v11 = (float *)(a1 + 4 * v9);
      uint64_t v12 = *(unsigned int *)v11;
      switch((int)v12)
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 8:
        case 15:
        case 16:
        case 17:
          *(float *)&a4 = v11[1];
          float32x2_t v17 = vrecpe_f32(*(float32x2_t *)&a4);
          float32x2_t v18 = vmul_f32(vrecps_f32(*(float32x2_t *)&a4, v17), v17);
          *(float *)&a4 = v5 * vmul_f32(v18, vrecps_f32(*(float32x2_t *)&a4, v18)).f32[0];
          if (*(float *)&a4 < 0.0) {
            *(float *)&a4 = 0.0;
          }
          if (*(float *)&a4 > 1.0) {
            *(float *)&a4 = 1.0;
          }
          switch((int)v12)
          {
            case 0:
            case 1:
            case 15:
            case 16:
            case 17:
              return;
            case 2:
            case 3:
            case 4:
            case 8:
              int32x2_t v19 = *a3;
              __int32 v20 = a3[1].i32[1];
              *(_DWORD *)uint32x2_t v33 = a3[1].i32[0];
              __int32 v34 = v20;
              *(int32x2_t *)&long long v21 = vrev64_s32(v19);
              *((int32x2_t *)&v21 + 1) = vrev64_s32(a3[2]);
              *(_OWORD *)&v33[4] = v21;
              RB::BezierTiming::Fn::solve((RB::BezierTiming::Fn *)v33, *(float *)&a4, 0.001);
              break;
            default:
              abort();
          }
          return;
        case 5:
        case 6:
        case 7:
          *(float *)&a5 = v11[1];
          float32x2_t v22 = vrecpe_f32(*(float32x2_t *)&a5);
          float32x2_t v23 = vmul_f32(vrecps_f32(*(float32x2_t *)&a5, v22), v22);
          float v5 = (float)(v5 * 0.4) * vmul_f32(v23, vrecps_f32(*(float32x2_t *)&a5, v23)).f32[0];
          goto LABEL_20;
        case 9:
        case 10:
LABEL_20:
          *(void *)&long long v24 = vrev64q_s32(*(int32x4_t *)a3->i8).u64[0];
          *((int32x2_t *)&v24 + 1) = a3[1];
          *(_OWORD *)uint32x2_t v33 = v24;
          *(_DWORD *)&v33[16] = a3[2].i32[0];
          RB::SpringTiming::eval((RB::SpringTiming *)v33, fmaxf(v5, 0.0));
          return;
        case 11:
          float v5 = v11[1] * v5;
          goto LABEL_11;
        case 12:
          float v5 = fmaxf(v5 - v11[1], 0.0);
          goto LABEL_11;
        case 13:
        case 14:
          *(float *)&a4 = RB::Animation::active_duration((uint64_t)(v11 + 2), v10 - v9);
          float32x2_t v13 = vrecpe_f32((float32x2_t)LODWORD(a4));
          float32x2_t v14 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(a4), v13), v13);
          a5 = COERCE_DOUBLE(vmul_f32(v14, vrecps_f32((float32x2_t)LODWORD(a4), v14)));
          *(float *)&a5 = floorf(v5 * *(float *)&a5);
          float v5 = v5 - (float)(*(float *)&a5 * *(float *)&a4);
          if v12 == 14 && ((int)*(float *)&a5)
          {
            float v15 = *(float *)&a4 - v5;
            float v16 = *(float *)&a4 + -0.00001;
            if (v16 >= v15) {
              float v5 = v15;
            }
            else {
              float v5 = v16;
            }
          }
          goto LABEL_11;
        case 18:
          *(float *)&a4 = v11[2];
          float32x2_t v25 = vrecpe_f32(*(float32x2_t *)&a4);
          float32x2_t v26 = vmul_f32(vrecps_f32(*(float32x2_t *)&a4, v25), v25);
          *(float *)&a4 = v5 * vmul_f32(v26, vrecps_f32(*(float32x2_t *)&a4, v26)).f32[0];
          if (*(float *)&a4 < 0.0) {
            *(float *)&a4 = 0.0;
          }
          if (*(float *)&a4 > 1.0) {
            *(float *)&a4 = 1.0;
          }
          if (*((_DWORD *)v11 + 1) >= 2u)
          {
            int v27 = (unsigned int *)(v11 + 3);
            unint64_t v28 = *((unsigned int *)v11 + 1);
            do
            {
              unint64_t v29 = v28 >> 1;
              uint32x2_t v30 = (float *)&v27[2 * (v28 >> 1)];
              float v32 = *v30;
              int v31 = v30 + 2;
              v28 += ~(v28 >> 1);
              if (v32 < *(float *)&a4) {
                int v27 = (unsigned int *)v31;
              }
              else {
                unint64_t v28 = v29;
              }
            }
            while (v28);
          }
          return;
        default:
LABEL_11:
          v9 += RB::Animation::_term_args[v12] + 1;
          if (v9 >= a2) {
            return;
          }
          continue;
      }
    }
  }
}

void RB::Animation::speed(uint64_t a1, unint64_t a2, int32x2_t *a3, double a4, double a5)
{
  if (a2)
  {
    float v8 = *(float *)&a4;
    unint64_t v9 = 0;
    unint64_t v10 = a2 - 2;
    float v11 = 1.0;
    while (2)
    {
      uint64_t v12 = (float *)(a1 + 4 * v9);
      uint64_t v13 = *(unsigned int *)v12;
      switch((int)v13)
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 8:
        case 15:
        case 16:
        case 17:
          *(float *)&a4 = v12[1];
          float32x2_t v19 = vrecpe_f32(*(float32x2_t *)&a4);
          float32x2_t v20 = vmul_f32(vrecps_f32(*(float32x2_t *)&a4, v19), v19);
          *(float *)&a4 = v8 * vmul_f32(v20, vrecps_f32(*(float32x2_t *)&a4, v20)).f32[0];
          if (*(float *)&a4 < 0.0) {
            *(float *)&a4 = 0.0;
          }
          if (*(float *)&a4 > 1.0) {
            *(float *)&a4 = 1.0;
          }
          switch((int)v13)
          {
            case 0:
            case 1:
            case 15:
            case 16:
            case 17:
              return;
            case 2:
            case 3:
            case 4:
            case 8:
              int32x2_t v21 = *a3;
              __int32 v22 = a3[1].i32[1];
              *(_DWORD *)long long v37 = a3[1].i32[0];
              __int32 v38 = v22;
              *(int32x2_t *)&long long v23 = vrev64_s32(v21);
              *((int32x2_t *)&v23 + 1) = vrev64_s32(a3[2]);
              *(_OWORD *)&v37[4] = v23;
              RB::BezierTiming::derivative((RB::BezierTiming *)v37, *(float *)&a4);
              break;
            default:
              abort();
          }
          return;
        case 5:
        case 6:
        case 7:
          *(float *)&a5 = v12[1];
          float32x2_t v24 = vrecpe_f32(*(float32x2_t *)&a5);
          float32x2_t v25 = vmul_f32(vrecps_f32(*(float32x2_t *)&a5, v24), v24);
          float v8 = (float)(v8 * 0.4) * vmul_f32(v25, vrecps_f32(*(float32x2_t *)&a5, v25)).f32[0];
          goto LABEL_20;
        case 9:
        case 10:
LABEL_20:
          *(void *)&long long v26 = vrev64q_s32(*(int32x4_t *)a3->i8).u64[0];
          *((int32x2_t *)&v26 + 1) = a3[1];
          *(_OWORD *)long long v37 = v26;
          *(_DWORD *)&v37[16] = a3[2].i32[0];
          fabsf(RB::SpringTiming::derivative((RB::SpringTiming *)v37, fmaxf(v8, 0.0)) * v11);
          return;
        case 11:
          float v18 = v12[1];
          float v8 = v18 * v8;
          float v11 = v18 * v11;
          goto LABEL_11;
        case 12:
          float v8 = fmaxf(v8 - v12[1], 0.0);
          goto LABEL_11;
        case 13:
        case 14:
          *(float *)&a4 = RB::Animation::active_duration((uint64_t)(v12 + 2), v10 - v9);
          float32x2_t v14 = vrecpe_f32((float32x2_t)LODWORD(a4));
          float32x2_t v15 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(a4), v14), v14);
          a5 = COERCE_DOUBLE(vmul_f32(v15, vrecps_f32((float32x2_t)LODWORD(a4), v15)));
          *(float *)&a5 = floorf(v8 * *(float *)&a5);
          float v8 = v8 - (float)(*(float *)&a5 * *(float *)&a4);
          if v13 == 14 && ((int)*(float *)&a5)
          {
            float v16 = *(float *)&a4 - v8;
            float v17 = *(float *)&a4 + -0.00001;
            if (v17 >= v16) {
              float v8 = v16;
            }
            else {
              float v8 = v17;
            }
          }
          goto LABEL_11;
        case 18:
          *(float *)&a4 = v12[2];
          float32x2_t v27 = vrecpe_f32(*(float32x2_t *)&a4);
          float32x2_t v28 = vmul_f32(vrecps_f32(*(float32x2_t *)&a4, v27), v27);
          float v29 = v8 * vmul_f32(v28, vrecps_f32(*(float32x2_t *)&a4, v28)).f32[0];
          if (v29 < 0.0) {
            float v29 = 0.0;
          }
          if (v29 > 1.0) {
            float v29 = 1.0;
          }
          unint64_t v30 = *((unsigned int *)v12 + 1);
          if (v30 >= 2)
          {
            int v31 = (unsigned int *)(v12 + 3);
            unint64_t v32 = v30;
            do
            {
              unint64_t v33 = v32 >> 1;
              __int32 v34 = (float *)&v31[2 * (v32 >> 1)];
              float v36 = *v34;
              char v35 = v34 + 2;
              v32 += ~(v32 >> 1);
              if (v36 < v29) {
                int v31 = (unsigned int *)v35;
              }
              else {
                unint64_t v32 = v33;
              }
            }
            while (v32);
          }
          return;
        default:
LABEL_11:
          v9 += RB::Animation::_term_args[v13] + 1;
          if (v9 >= a2) {
            return;
          }
          continue;
      }
    }
  }
}

BOOL RB::Animation::operator==(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 24)) {
    unint64_t v2 = *(_DWORD **)(a1 + 24);
  }
  else {
    unint64_t v2 = (_DWORD *)a1;
  }
  unint64_t v3 = *(unsigned int *)(a1 + 32);
  uint64_t v4 = *(_DWORD **)(a2 + 24);
  if (!v4) {
    uint64_t v4 = (_DWORD *)a2;
  }
  if (v3 != *(_DWORD *)(a2 + 32)) {
    return 0;
  }
  if (!v3) {
    return 1;
  }
  if (*v2 != *v4) {
    return 0;
  }
  uint64_t v5 = 1;
  do
  {
    unint64_t v6 = v5;
    if (v3 == v5) {
      break;
    }
    int v7 = v2[v5];
    int v8 = v4[v5++];
  }
  while (v7 == v8);
  return v6 >= v3;
}

uint64_t RB::Animation::hash(RB::Animation *this)
{
  uint64_t result = 2166136261;
  uint64_t v3 = *((unsigned int *)this + 8);
  if (v3)
  {
    if (*((void *)this + 3)) {
      this = (RB::Animation *)*((void *)this + 3);
    }
    do
    {
      unsigned int v4 = *(_DWORD *)this;
      this = (RB::Animation *)((char *)this + 4);
      uint64_t result = (16777619 * result) ^ v4;
      --v3;
    }
    while (v3);
  }
  return result;
}

void *RB::Animation::encode(void *this, RB::Encoder *a2)
{
  if (*((_DWORD *)this + 8))
  {
    uint64_t v3 = (uint64_t)this;
    unsigned int v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(v3 + 24);
      if (!v5) {
        uint64_t v5 = v3;
      }
      unint64_t v6 = (unsigned int *)(v5 + 4 * v4);
      RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      unint64_t v7 = *v6;
      RB::ProtobufEncoder::encode_varint(a2, 8uLL);
      RB::ProtobufEncoder::encode_varint(a2, v7);
      unint64_t v9 = v6 + 1;
      uint64_t v8 = *v6;
      if (v8 == 18)
      {
        unint64_t v10 = *v9;
        if (v10)
        {
          RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
          RB::ProtobufEncoder::encode_varint(a2, v10);
          unsigned int v11 = (2 * *v9) | 1;
        }
        else
        {
          unsigned int v11 = 1;
        }
        uint64_t v12 = v6 + 2;
      }
      else
      {
        unsigned int v11 = RB::Animation::_term_args[v8];
        uint64_t v12 = v6 + 1;
      }
      RB::ProtobufEncoder::packed_fixed32_field(a2, 2, v12, v11);
      this = RB::ProtobufEncoder::end_length_delimited(a2);
      uint64_t v13 = *v6;
      if (v13 == 18) {
        int v14 = 2 * *v9 + 2;
      }
      else {
        int v14 = RB::Animation::_term_args[v13];
      }
      v4 += v14 + 1;
    }
    while (v4 < *(_DWORD *)(v3 + 32));
  }
  return this;
}

uint64_t RB::Animation::decode(RB::Animation *this, RB::Decoder *a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    uint64_t v5 = result;
    do
    {
      if ((v5 & 0x7FFFFFFF8) == 8)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          int v6 = 0;
          uint64_t v7 = 0;
          LODWORD(v8) = 0;
          float32x2_t v28 = 0;
          size_t v29 = 0;
          unint64_t v30 = 8;
          while (1)
          {
            unint64_t field = RB::ProtobufDecoder::next_field(a2);
            if (!field) {
              break;
            }
            unint64_t v10 = field >> 3;
            if ((field >> 3) == 2)
            {
              float v11 = RB::ProtobufDecoder::float_field(a2, field);
              size_t v12 = v29;
              size_t v13 = v29 + 1;
              if (v30 < v29 + 1)
              {
                RB::vector<RB::Function::Param,8ul,unsigned long>::reserve_slow(v27, v13);
                size_t v12 = v29;
                size_t v13 = v29 + 1;
              }
              int v14 = v28;
              if (!v28) {
                int v14 = v27;
              }
              *(float *)&v14[4 * v12] = v11;
              size_t v29 = v13;
            }
            else if (v10 == 3)
            {
              int v6 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, field);
            }
            else if (v10 == 1)
            {
              unint64_t v15 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, field);
              unint64_t v16 = v15 | 0x100000000;
              if (v15 > 0x12) {
                unint64_t v16 = 0;
              }
              uint64_t v7 = v16;
              unint64_t v8 = HIDWORD(v16);
            }
            else
            {
              RB::ProtobufDecoder::skip_field(a2, field);
            }
          }
          if (v8)
          {
            if (v7 == 18) {
              int v17 = (2 * v6) | 1;
            }
            else {
              int v17 = RB::Animation::_term_args[v7];
            }
            if (v29 == v17)
            {
              unsigned int v18 = *((_DWORD *)this + 8);
              if (*((_DWORD *)this + 9) < v18 + 1)
              {
                RB::vector<RB::Animation::TermOrArg,6ul,unsigned int>::reserve_slow(this, v18 + 1);
                unsigned int v18 = *((_DWORD *)this + 8);
              }
              float32x2_t v19 = (RB::Animation *)*((void *)this + 3);
              if (!v19) {
                float32x2_t v19 = this;
              }
              *((_DWORD *)v19 + v18) = v7;
              int v20 = *((_DWORD *)this + 8);
              unsigned int v21 = v20 + 1;
              *((_DWORD *)this + 8) = v20 + 1;
              if (v7 == 18)
              {
                if (*((_DWORD *)this + 9) < (v20 + 2))
                {
                  RB::vector<RB::Animation::TermOrArg,6ul,unsigned int>::reserve_slow(this, v20 + 2);
                  unsigned int v21 = *((_DWORD *)this + 8);
                }
                __int32 v22 = (RB::Animation *)*((void *)this + 3);
                if (!v22) {
                  __int32 v22 = this;
                }
                *((_DWORD *)v22 + v21) = v6;
                unsigned int v21 = *((_DWORD *)this + 8) + 1;
                *((_DWORD *)this + 8) = v21;
              }
              if (v28) {
                long long v23 = (int *)v28;
              }
              else {
                long long v23 = (int *)v27;
              }
              if (v29)
              {
                uint64_t v24 = 4 * v29;
                do
                {
                  int v25 = *v23;
                  if (*((_DWORD *)this + 9) < v21 + 1)
                  {
                    RB::vector<RB::Animation::TermOrArg,6ul,unsigned int>::reserve_slow(this, v21 + 1);
                    unsigned int v21 = *((_DWORD *)this + 8);
                  }
                  long long v26 = (RB::Animation *)*((void *)this + 3);
                  if (!v26) {
                    long long v26 = this;
                  }
                  *((_DWORD *)v26 + v21) = v25;
                  unsigned int v21 = *((_DWORD *)this + 8) + 1;
                  *((_DWORD *)this + 8) = v21;
                  ++v23;
                  v24 -= 4;
                }
                while (v24);
              }
            }
            else
            {
              *((unsigned char *)a2 + 56) = 1;
              *(void *)a2 = *((void *)a2 + 1);
            }
          }
          if (v28) {
            free(v28);
          }
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v5);
      }
      uint64_t result = RB::ProtobufDecoder::next_field(a2);
      uint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void sub_21419C2E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  if (a13) {
    free(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::Animation::xml_elements(uint64_t this, RB::XML::Document *a2)
{
  if (*(_DWORD *)(this + 32))
  {
    unsigned int v3 = 0;
    while (2)
    {
      uint64_t v4 = *(void *)(this + 24);
      if (!v4) {
        uint64_t v4 = this;
      }
      uint64_t v5 = (unsigned int *)(v4 + 4 * v3);
      uint64_t v6 = *v5;
      uint64_t v7 = "linear";
      switch((int)v6)
      {
        case 0:
          goto LABEL_21;
        case 1:
          uint64_t v7 = "smoothstep";
          goto LABEL_21;
        case 2:
          uint64_t v7 = "ease-in";
          goto LABEL_21;
        case 3:
          uint64_t v7 = "ease-out";
          goto LABEL_21;
        case 4:
          uint64_t v7 = "ease-in-ease-out";
          goto LABEL_21;
        case 5:
          uint64_t v7 = "spring-0";
          goto LABEL_21;
        case 6:
          uint64_t v7 = "spring-1";
          goto LABEL_21;
        case 7:
          uint64_t v7 = "spring-2";
          goto LABEL_21;
        case 8:
          RB::XML::Document::push(a2, "bezier");
        case 9:
        case 10:
          RB::XML::Document::push(a2, "spring");
        case 11:
          RB::XML::Document::push(a2, "speed");
        case 12:
          unint64_t v8 = a2;
          uint64_t v7 = "delay";
          goto LABEL_22;
        case 13:
        case 14:
          RB::XML::Document::push(a2, "repeat");
        case 15:
          uint64_t v7 = "circular-ease-in";
          goto LABEL_21;
        case 16:
          uint64_t v7 = "circular-ease-out";
          goto LABEL_21;
        case 17:
          uint64_t v7 = "circular-ease-in-ease-out";
LABEL_21:
          unint64_t v8 = a2;
LABEL_22:
          RB::XML::Document::push(v8, v7);
        case 18:
          RB::XML::Document::push(a2, "sampled-function");
        default:
          if (v6 == 18) {
            int v9 = 2 * v5[1] + 2;
          }
          else {
            int v9 = RB::Animation::_term_args[v6];
          }
          v3 += v9 + 1;
          if (v3 >= *(_DWORD *)(this + 32)) {
            return this;
          }
          continue;
      }
    }
  }
  return this;
}

void sub_21419C900(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  if (a10) {
    free(a10);
  }
  _Unwind_Resume(exception_object);
}

void *RB::vector<RB::Animation::TermOrArg,6ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 9) + (*((_DWORD *)__dst + 9) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 9) + (*((_DWORD *)__dst + 9) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned int,4ul>(*((void **)__dst + 3), __dst, 6u, (_DWORD *)__dst + 9, v3);
  *((void *)__dst + 3) = result;
  return result;
}

double RB::Path::quadratic_bounds_slow(float32x2_t a1, float32x2_t a2, float32x2_t a3, int32x4_t a4, int8x16_t a5)
{
  *(float32x2_t *)a5.i8 = vsub_f32(a1, a3);
  *(int32x2_t *)a4.i8 = vceqz_f32(*(float32x2_t *)a5.i8);
  if ((vpmin_u32(*(uint32x2_t *)a4.i8, *(uint32x2_t *)a4.i8).u32[0] & 0x80000000) != 0)
  {
    float32x2_t v14 = vminnm_f32(a1, a3);
  }
  else
  {
    float32x2_t v5 = vrecpe_f32(*(float32x2_t *)a5.i8);
    float32x2_t v6 = vmul_f32(vrecps_f32(*(float32x2_t *)a5.i8, v5), v5);
    *(float32x2_t *)a5.i8 = vmul_f32(vrecps_f32(*(float32x2_t *)a5.i8, v6), vmul_f32(vsub_f32(a1, a2), v6));
    __asm { FMOV            V5.4S, #-1.0 }
    int8x16_t v11 = vbslq_s8((int8x16_t)vcltzq_s32(a4), (int8x16_t)_Q5, a5);
    *(int32x2_t *)_Q5.i8 = vdup_n_s32(0x358637BDu);
    *(int32x2_t *)a5.i8 = vcgt_f32(*(float32x2_t *)_Q5.i8, *(float32x2_t *)v11.i8);
    v12.i64[0] = 0x4000000040000000;
    v12.i64[1] = 0x4000000040000000;
    float32x2_t v13 = (float32x2_t)vbslq_s8((int8x16_t)vcltzq_s32((int32x4_t)a5), v12, v11).u64[0];
    float32x2_t v14 = vminnm_f32(a1, a3);
    *(int8x8_t *)_Q5.i8 = vand_s8((int8x8_t)vcgt_f32(v13, *(float32x2_t *)_Q5.i8), (int8x8_t)vcgt_f32((float32x2_t)vdup_n_s32(0x3F7FFFEFu), v13));
    if ((vpmax_u32(*(uint32x2_t *)_Q5.i8, *(uint32x2_t *)_Q5.i8).u32[0] & 0x80000000) != 0)
    {
      __asm { FMOV            V7.2S, #1.0 }
      float32x2_t v17 = vsub_f32(_D7, v13);
      float32x2_t v14 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(_Q5), (int8x8_t)vminnm_f32(v14, vmla_f32(vmul_f32(vmul_f32(v13, v13), a3), v17, vmla_f32(vmul_f32(a2, vadd_f32(v13, v13)), a1, v17))), (int8x8_t)v14);
    }
  }
  return *(double *)&v14;
}

float32x2_t RB::Path::BoundingRect::quadto(float32x2_t *a1, float64x2_t a2, float64x2_t a3, double a4, int32x4_t a5, int8x16_t a6)
{
  float32x2_t v7 = vcvt_f32_f64(a2);
  float32x2_t v8 = vcvt_f32_f64(a3);
  *(float32x2_t *)a5.i8 = a1[3];
  double v9 = COERCE_DOUBLE(vminnm_f32(*(float32x2_t *)a5.i8, v8));
  float32x2_t v10 = vmaxnm_f32(*(float32x2_t *)a5.i8, v8);
  uint32x2_t v11 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v10, v7), (int8x8_t)vcge_f32(v7, *(float32x2_t *)&v9));
  *(uint32x2_t *)a6.i8 = vpmin_u32(v11, v11);
  if ((a6.i32[0] & 0x80000000) == 0) {
    double v9 = RB::Path::quadratic_bounds_slow(a1[3], v7, v8, a5, a6);
  }
  float32x2_t result = vminnm_f32(a1[1], *(float32x2_t *)&v9);
  float32x2_t v13 = vmaxnm_f32(a1[2], v10);
  a1[1] = result;
  a1[2] = v13;
  a1[3] = v8;
  return result;
}

BOOL RB::ProjectionMatrix::invert(RB::ProjectionMatrix *this)
{
  float v2 = *((float *)this + 2);
  float v3 = *((float *)this + 5);
  if (v2 == 0.0 && v3 == 0.0 && *((float *)this + 8) == 1.0)
  {
    float64x2_t v4 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 12));
    float64x2_t v5 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 24));
    float64x2_t v35 = vcvtq_f64_f32(*(float32x2_t *)this);
    float64x2_t v36 = v4;
    float64x2_t v37 = v5;
    BOOL result = RB::AffineTransform::invert((RB::AffineTransform *)&v35);
    if (result)
    {
      float64x2_t v7 = v36;
      *(float32x2_t *)this = vcvt_f32_f64(v35);
      *((_DWORD *)this + 2) = 0;
      *(float32x2_t *)((char *)this + 12) = vcvt_f32_f64(v7);
      *((_DWORD *)this + 5) = 0;
      *((float32x2_t *)this + 3) = vcvt_f32_f64(v37);
      *((_DWORD *)this + 8) = 1065353216;
    }
  }
  else
  {
    double v8 = *((float *)this + 4);
    double v9 = v3;
    double v10 = *((float *)this + 7);
    double v11 = *((float *)this + 8);
    double v12 = -(v10 * v3 - v11 * v8);
    double v13 = *((float *)this + 3);
    double v14 = *((float *)this + 6);
    double v15 = -(v14 * v3 - v13 * v11);
    double v16 = -(v14 * v8 - v13 * v10);
    double v17 = *((float *)this + 1);
    double v18 = v2;
    double v19 = *(float *)this;
    double v20 = v16 * v18 - (v15 * v17 - v12 * v19);
    if (v20 == 0.0)
    {
      return 0;
    }
    else
    {
      double v21 = -(v17 * v13 - v19 * v8);
      double v22 = -(v19 * v9 - v13 * v18);
      double v23 = -(v8 * v18 - v17 * v9);
      double v24 = -(v19 * v10 - v17 * v14);
      double v25 = -(v14 * v18 - v19 * v11);
      float v26 = 1.0 / v20 * v12;
      float v27 = -(v17 * v11 - v10 * v18) * (1.0 / v20);
      *(float *)this = v26;
      *((float *)this + 1) = v27;
      float v28 = 1.0 / v20 * v23;
      float v29 = -(1.0 / v20 * v15);
      *((float *)this + 2) = v28;
      *((float *)this + 3) = v29;
      float v30 = 1.0 / v20 * v25;
      float v31 = v22 * (1.0 / v20);
      *((float *)this + 4) = v30;
      *((float *)this + 5) = v31;
      float v32 = 1.0 / v20 * v16;
      float v33 = v24 * (1.0 / v20);
      *((float *)this + 6) = v32;
      *((float *)this + 7) = v33;
      float v34 = 1.0 / v20 * v21;
      *((float *)this + 8) = v34;
      return 1;
    }
  }
  return result;
}

float32_t RB::operator*@<S0>(uint64_t a1@<X0>, uint64_t a2@<X1>, float32x4_t *a3@<X8>, int8x16_t a4@<Q3>, int32x4_t a5@<Q4>, int32x4_t a6@<Q7>)
{
  v8.i64[0] = *(void *)(a1 + 4);
  a5.i32[0] = *(_DWORD *)(a1 + 12);
  float32x2_t v9 = *(float32x2_t *)(a1 + 28);
  float v10 = *(float *)(a1 + 24);
  v7.i32[0] = *(_DWORD *)(a2 + 12);
  v6.i32[0] = *(_DWORD *)(a2 + 16);
  a6.i64[0] = *(void *)a2;
  float32x2_t v11 = *(float32x2_t *)(a2 + 28);
  a4.i64[0] = *(void *)(a2 + 20);
  *(int32x2_t *)v12.f32 = vrev64_s32(*(int32x2_t *)v8.f32);
  v12.i32[2] = v12.i32[0];
  v12.i32[3] = *(_DWORD *)(a1 + 16);
  v13.i32[0] = vdup_lane_s32(*(int32x2_t *)a4.i8, 1).u32[0];
  v13.i32[1] = v6.i32[0];
  v13.i64[1] = __PAIR64__(v7.u32[0], v11.u32[1]);
  v8.i32[2] = v8.i32[0];
  v8.i32[3] = *(_DWORD *)(a1 + 20);
  *(int32x2_t *)v14.f32 = vzip1_s32(v7, (int32x2_t)v11);
  v14.i64[1] = a4.i64[0];
  float32x4_t v15 = vmulq_f32(v8, v14);
  int32x4_t v16 = *(int32x4_t *)a1;
  v16.i32[1] = a5.i32[0];
  float32x4_t v17 = (float32x4_t)vzip1q_s32(v16, v16);
  v17.i32[2] = *(_OWORD *)a1;
  v18.i64[0] = *(void *)a2;
  v18.i32[2] = *(_DWORD *)(a2 + 8);
  v18.i32[3] = *(void *)a2;
  float32x4_t v19 = vmlaq_f32(vmlaq_f32(v15, v13, v12), v18, v17);
  *(float32x2_t *)v18.f32 = v11;
  v18.i64[1] = __PAIR64__(v11.u32[0], v7.u32[0]);
  v20.i32[0] = *(_DWORD *)(a1 + 20);
  *(float32x2_t *)&v20.u32[2] = v9;
  v20.i32[1] = v20.i32[0];
  float32x4_t v21 = vmulq_f32(v18, v20);
  float32x4_t v22 = (float32x4_t)vextq_s8(vextq_s8(v6, v6, 4uLL), a4, 0xCuLL);
  v22.i32[3] = v22.i32[0];
  v20.i32[0] = v12.i32[3];
  *(int32x2_t *)&v20.u32[2] = vrev64_s32((int32x2_t)v9);
  v20.i32[1] = v12.i32[3];
  int32x4_t v23 = vuzp2q_s32(a6, vzip1q_s32(a6, a6));
  float32x4_t v24 = (float32x4_t)v23;
  v24.i32[1] = *(_DWORD *)(a2 + 8);
  v24.i32[3] = v23.i32[0];
  *(float *)&a5.i32[1] = v10;
  *a3 = v19;
  a3[1] = vmlaq_f32(vmlaq_f32(v21, v20, v22), (float32x4_t)vzip1q_s32(a5, a5), v24);
  float32_t result = vmla_f32((float32x2_t)vdup_lane_s32((int32x2_t)vmul_f32(v11, v9), 1), v9, *(float32x2_t *)a4.i8).f32[0]
         + (float)(v24.f32[1] * v10);
  a3[2].f32[0] = result;
  return result;
}

float32x2_t RB::operator*@<D0>(float64x2_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  double v3 = *(float *)a2;
  float64x2_t v5 = *a1;
  float64x2_t v4 = a1[1];
  _Q5 = a1[2];
  double v7 = *(float *)(a2 + 20);
  float32x4_t v8 = *(float32x4_t *)(a2 + 4);
  float64x2_t v9 = vcvtq_f64_f32(*(float32x2_t *)v8.f32);
  _Q6 = vcvt_hight_f64_f32(v8);
  float v11 = vmlad_n_f64(vmuld_lane_f64(_Q6.f64[0], *a1, 1), v3, a1->f64[0]);
  *(float *)a3 = v11;
  __asm { FMLA            D3, D6, V5.D[1] }
  float64x2_t v17 = vmulq_f64((float64x2_t)vzip1q_s64((int64x2_t)v4, (int64x2_t)v5), v9);
  *(void *)&v18.f64[0] = vdupq_laneq_s64((int64x2_t)_Q6, 1).u64[0];
  v18.f64[1] = v7;
  float64x2_t v19 = vmlaq_laneq_f64(vcvtq_f64_f32(*(float32x2_t *)(a2 + 28)), v18, _Q5, 1);
  v18.f64[0] = v9.f64[1];
  float64x2_t v20 = vmlaq_n_f64(v19, v9, _Q5.f64[0]);
  v9.f64[1] = v7;
  double v21 = vmlad_n_f64(_D3, v3, _Q5.f64[0]);
  float64x2_t v22 = vmulq_f64((float64x2_t)vzip2q_s64((int64x2_t)v4, (int64x2_t)v5), _Q6);
  _Q6.f64[0] = v3;
  *(float *)&double v3 = v21;
  v23.f64[1] = v17.f64[1];
  v23.f64[0] = v22.f64[1];
  v22.f64[1] = v17.f64[0];
  *(float32x4_t *)(a3 + 4) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(v23, v9, v5)), vmlaq_f64(v22, _Q6, v4));
  *(float *)v4.f64 = vmlad_n_f64(vmuld_lane_f64(v7, v4, 1), v18.f64[0], v4.f64[0]);
  *(_DWORD *)(a3 + 20) = LODWORD(v4.f64[0]);
  *(_DWORD *)(a3 + 24) = LODWORD(v3);
  float32x2_t result = vcvt_f32_f64(v20);
  *(float32x2_t *)(a3 + 28) = result;
  return result;
}

float RB::operator*@<S0>(float *a1@<X0>, float64x2_t *a2@<X1>, uint64_t a3@<X8>)
{
  float result = a1[2];
  float64x2_t v5 = a2[1];
  float64x2_t v4 = a2[2];
  float64x2_t v6 = *a2;
  float v7 = a1[5];
  double v8 = a1[4];
  double v9 = a1[3];
  float v10 = a1[8];
  double v11 = a1[7];
  double v12 = a1[6];
  *(float32x2_t *)a3 = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v4, result), v5, a1[1]), *a2, *a1));
  *(float32x2_t *)(a3 + 12) = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v4, v7), v5, v8), v6, v9));
  *(float32x2_t *)(a3 + 24) = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v4, v10), v5, v11), v6, v12));
  *(float *)(a3 + 8) = result;
  *(float *)(a3 + 20) = v7;
  *(float *)(a3 + 32) = v10;
  return result;
}

uint64_t RB::operator*=(uint64_t a1, uint64_t a2, double a3, double a4, double a5, int8x16_t a6, int32x4_t a7, double a8, double a9, int32x4_t a10)
{
  RB::operator*(a1, a2, v13, a6, a7, a10);
  float32x4_t v11 = v13[1];
  *(float32x4_t *)a1 = v13[0];
  *(float32x4_t *)(a1 + 16) = v11;
  *(_DWORD *)(a1 + 32) = v14;
  return a1;
}

float RB::ProjectionMatrix::translate(RB::ProjectionMatrix *this, float a2, float a3)
{
  *((float32x2_t *)this + 3) = vmla_n_f32(vmla_n_f32(*(float32x2_t *)((char *)this + 24), *(float32x2_t *)((char *)this + 12), a3), *(float32x2_t *)this, a2);
  float result = (float)(*((float *)this + 8) + (float)(*((float *)this + 5) * a3)) + (float)(*((float *)this + 2) * a2);
  *((float *)this + 8) = result;
  return result;
}

__n64 RB::ProjectionMatrix::translate_right(RB::ProjectionMatrix *this, __n64 result, float a3)
{
  result.n64_f32[1] = a3;
  *(float32x2_t *)this = vmla_n_f32(*(float32x2_t *)this, (float32x2_t)result.n64_u64[0], *((float *)this + 2));
  *(float32x2_t *)((char *)this + 12) = vmla_n_f32(*(float32x2_t *)((char *)this + 12), (float32x2_t)result.n64_u64[0], *((float *)this + 5));
  *((float32x2_t *)this + 3) = vmla_n_f32(*(float32x2_t *)((char *)this + 24), (float32x2_t)result.n64_u64[0], *((float *)this + 8));
  return result;
}

float32x2_t RB::operator*(uint64_t a1, double _D0, int32x4_t _Q1)
{
  _S5 = *(float *)(a1 + 20);
  if (*(float *)(a1 + 8) == 0.0 && (_S5 == 0.0 ? (_ZF = *(float *)(a1 + 32) == 1.0) : (_ZF = 0), _ZF))
  {
    float64x2_t v5 = vcvtq_f64_f32(*(float32x2_t *)(a1 + 12));
    float64x2_t v6 = vcvtq_f64_f32(*(float32x2_t *)(a1 + 24));
    v41[0] = vcvtq_f64_f32(*(float32x2_t *)a1);
    v41[1] = v5;
    v41[2] = v6;
    return RB::operator*(v41, *(float32x2_t *)&_D0, _Q1);
  }
  else
  {
    __asm { FMLA            S7, S5, V0.S[1] }
    float v12 = 1.0;
    float v13 = 1.0;
    if (_S7 != 1.0)
    {
      if (_S7 <= 0.0)
      {
        float v13 = INFINITY;
      }
      else
      {
        float v14 = _S7;
        float32x2_t v15 = vrecpe_f32((float32x2_t)LODWORD(_S7));
        float32x2_t v16 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v14), v15), v15);
        LODWORD(v13) = vmul_f32(v16, vrecps_f32((float32x2_t)LODWORD(v14), v16)).u32[0];
      }
    }
    _D7 = vadd_f32((float32x2_t)_Q1.u32[0], *(float32x2_t *)&_D0);
    __asm { FMLA            S16, S5, V7.S[1] }
    if (_S16 != 1.0)
    {
      if (_S16 <= 0.0)
      {
        float v12 = INFINITY;
      }
      else
      {
        float v19 = _S16;
        float32x2_t v20 = vrecpe_f32((float32x2_t)LODWORD(_S16));
        float32x2_t v21 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v19), v20), v20);
        LODWORD(v12) = vmul_f32(v21, vrecps_f32((float32x2_t)LODWORD(v19), v21)).u32[0];
      }
    }
    _D17 = vadd_f32(*(float32x2_t *)_Q1.i8, *(float32x2_t *)&_D0);
    __asm { FMLA            S18, S5, V17.S[1] }
    float v24 = 1.0;
    float v25 = 1.0;
    if (_S18 != 1.0)
    {
      if (_S18 <= 0.0)
      {
        float v25 = INFINITY;
      }
      else
      {
        float v26 = _S18;
        float32x2_t v27 = vrecpe_f32((float32x2_t)LODWORD(_S18));
        float32x2_t v28 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v26), v27), v27);
        LODWORD(v25) = vmul_f32(v28, vrecps_f32((float32x2_t)LODWORD(v26), v28)).u32[0];
      }
    }
    float32x2_t v29 = *(float32x2_t *)a1;
    float32x2_t v30 = *(float32x2_t *)(a1 + 12);
    float32x2_t v31 = *(float32x2_t *)(a1 + 24);
    _Q1.i32[0] = 0;
    *(float32x2_t *)_Q1.i8 = vadd_f32(*(float32x2_t *)_Q1.i8, *(float32x2_t *)&_D0);
    __asm { FMLA            S3, S5, V1.S[1] }
    if (_S3 != 1.0)
    {
      if (_S3 <= 0.0)
      {
        float v24 = INFINITY;
      }
      else
      {
        float v33 = _S3;
        float32x2_t v34 = vrecpe_f32((float32x2_t)LODWORD(_S3));
        float32x2_t v35 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v33), v34), v34);
        LODWORD(v24) = vmul_f32(v35, vrecps_f32((float32x2_t)LODWORD(v33), v35)).u32[0];
      }
    }
    float32x2_t v36 = vmul_n_f32(vmla_lane_f32(vmla_n_f32(v31, v29, _D17.f32[0]), v30, _D17, 1), v25);
    float32x2_t v37 = vmul_n_f32(vmla_lane_f32(vmla_n_f32(v31, v29, _D7.f32[0]), v30, _D7, 1), v12);
    float32x2_t v38 = vmul_n_f32(vmla_lane_f32(vmla_n_f32(v31, v29, *(float *)&_D0), v30, *(float32x2_t *)&_D0, 1), v13);
    float32x2_t v39 = vmul_n_f32(vmla_lane_f32(vmla_n_f32(v31, v29, *(float *)_Q1.i32), v30, *(float32x2_t *)_Q1.i8, 1), v24);
    float32x2_t v40 = vminnm_f32(vminnm_f32(v38, v37), vminnm_f32(v36, v39));
    *(float32x2_t *)_Q1.i8 = vmaxnm_f32(vmaxnm_f32(v38, v37), vmaxnm_f32(v36, v39));
    *(double *)&float32x2_t result = RB::Rect::from_bounds(v40, _Q1);
  }
  return result;
}

uint64_t RB::unapply(float32x2_t *a1, float *a2)
{
  _S0 = a2[2];
  float v3 = a2[3];
  _D1 = *a1;
  float v5 = a2[1];
  __asm { FMLA            S6, S0, V1.S[1] }
  float v12 = a2[4];
  float v11 = a2[5];
  float v13 = vmuls_lane_f32(v11, *a1, 1);
  float v14 = vmlas_n_f32(_S6 * v3, -(float)((float)(v12 * _S0) - (float)(v11 * v5)), COERCE_FLOAT(*a1))
      + (float)((float)(v12 - v13) * *a2);
  if (v14 == 0.0) {
    return 0;
  }
  float v16 = a2[7];
  float v15 = a2[8];
  float v17 = a2[6];
  float v18 = -(float)((float)(v16 * v11) - (float)(v15 * v12));
  float v19 = v17 * (float)(v13 - v12);
  float v20 = v16 - (float)(v15 * _D1.f32[1]);
  float v21 = -(float)((float)(v20 * *a2)
               - (float)((float)((float)-(float)((float)(v15 * v5) - (float)(v16 * _S0)) * _D1.f32[0])
                       - (float)(v17 * _S6)));
  _D1.f32[0] = (float)((float)(v19 + (float)(v18 * _D1.f32[0])) + (float)(v20 * v3)) / v14;
  if ((float)((float)(v15 + (float)((float)(v21 / v14) * v11)) + (float)(_D1.f32[0] * _S0)) <= 0.0) {
    return 0;
  }
  _D1.f32[1] = v21 / v14;
  *a1 = _D1;
  return 1;
}

BOOL RB::unapply(float32x2_t *this, RB::Rect *a2, const RB::ProjectionMatrix *a3)
{
  if (*((float *)a2 + 2) == 0.0 && (*((float *)a2 + 5) == 0.0 ? (BOOL v4 = *((float *)a2 + 8) == 1.0) : (BOOL v4 = 0), v4))
  {
    float64x2_t v5 = vcvtq_f64_f32(*(float32x2_t *)((char *)a2 + 12));
    float64x2_t v6 = vcvtq_f64_f32(*(float32x2_t *)((char *)a2 + 24));
    v23[0] = vcvtq_f64_f32(*(float32x2_t *)a2);
    v23[1] = v5;
    float64x2_t v23[2] = v6;
    BOOL v7 = RB::AffineTransform::invert((RB::AffineTransform *)v23);
    if (v7)
    {
      *(float32x2_t *)v8.i8 = this[1];
      *(float32x2_t *)&double v9 = RB::operator*(v23, *this, v8);
LABEL_16:
      *(double *)this = v9;
      this[1] = v10;
    }
  }
  else
  {
    long long v11 = *((_OWORD *)a2 + 1);
    v20[0] = *(_OWORD *)a2;
    v20[1] = v11;
    int v21 = *((_DWORD *)a2 + 8);
    v23[0].f64[0] = *(float64_t *)this;
    float32x2_t v12 = *(float32x2_t *)&v23[0].f64[0];
    BOOL v22 = (RB::unapply((float32x2_t *)v23, (float *)v20) & 1) == 0;
    float32x2_t v13 = *(float32x2_t *)&v23[0].f64[0];
    float32x2_t v19 = this[1];
    *(float32x2_t *)&v23[0].f64[0] = vadd_f32((float32x2_t)v19.u32[0], v12);
    if ((RB::unapply((float32x2_t *)v23, (float *)v20) & 1) == 0) {
      BOOL v22 = 1;
    }
    float32x2_t v14 = *(float32x2_t *)&v23[0].f64[0];
    *(float32x2_t *)&v23[0].f64[0] = vadd_f32(v12, v19);
    if ((RB::unapply((float32x2_t *)v23, (float *)v20) & 1) == 0) {
      BOOL v22 = 1;
    }
    float32x2_t v15 = *(float32x2_t *)&v23[0].f64[0];
    v16.i32[1] = v19.i32[1];
    v16.i32[0] = 0;
    *(float32x2_t *)&v23[0].f64[0] = vadd_f32(v16, v12);
    if ((RB::unapply((float32x2_t *)v23, (float *)v20) & 1) == 0) {
      BOOL v22 = 1;
    }
    *(float32x2_t *)v17.i8 = vmaxnm_f32(vmaxnm_f32(v13, v14), vmaxnm_f32(v15, *(float32x2_t *)&v23[0].f64[0]));
    double v9 = RB::Rect::from_bounds(vminnm_f32(vminnm_f32(v13, v14), vminnm_f32(v15, *(float32x2_t *)&v23[0].f64[0])), v17);
    BOOL v7 = !v22;
    if (!v22) {
      goto LABEL_16;
    }
  }
  return v7;
}

float32_t RB::ProjectionMatrix::mix(float32x4_t *this, float32x4_t *a2, float a3)
{
  float32x4_t v3 = this[1];
  *this = vmlaq_n_f32(*this, vsubq_f32(*a2, *this), a3);
  this[1] = vmlaq_n_f32(v3, vsubq_f32(a2[1], v3), a3);
  float32_t result = this[2].f32[0] + (float)((float)(a2[2].f32[0] - this[2].f32[0]) * a3);
  this[2].f32[0] = result;
  return result;
}

void *RB::ProjectionMatrix::encode(void *this, RB::Encoder *a2)
{
  float32x4_t v3 = this;
  uint64_t v4 = 0;
  v7[0] = 1065353216;
  unint64_t v5 = 13;
  do
  {
    int v6 = *(int *)((char *)v3 + v4 * 4);
    if (*(float *)&v6 != *(float *)&v7[v4])
    {
      RB::ProtobufEncoder::encode_varint(a2, v5);
      this = RB::ProtobufEncoder::encode_fixed32(a2, v6);
    }
    ++v4;
    v5 += 8;
  }
  while (v4 != 9);
  return this;
}

unint64_t RB::ProjectionMatrix::decode(uint64_t a1, RB::ProtobufDecoder *this)
{
  unint64_t result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      if ((v5 >> 3) - 1 > 8) {
        RB::ProtobufDecoder::skip_field(this, v5);
      }
      else {
        *(float *)(a1 + 4 * ((v5 >> 3) - RBPathRetain(*(void *)this, *((void *)this + 1)) = RB::ProtobufDecoder::float_field(this, v5);
      }
      unint64_t result = RB::ProtobufDecoder::next_field(this);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

intptr_t RB::Drawable::finish(intptr_t this)
{
  if (*(void *)(this + 16))
  {
    intptr_t v1 = this;
    if (*(_DWORD *)(this + 12))
    {
      unint64_t v2 = 0;
      do
      {
        this = dispatch_semaphore_wait(*(dispatch_semaphore_t *)(v1 + 16), 0xFFFFFFFFFFFFFFFFLL);
        ++v2;
        unint64_t v3 = *(unsigned int *)(v1 + 12);
      }
      while (v2 < v3);
      if (v3)
      {
        unint64_t v4 = 0;
        do
        {
          this = dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v1 + 16));
          ++v4;
        }
        while (v4 < *(unsigned int *)(v1 + 12));
      }
    }
  }
  return this;
}

NSObject *RB::Drawable::cancel_frame(RB::Drawable *this)
{
  unint64_t result = *((void *)this + 2);
  if (result) {
    return dispatch_semaphore_signal(result);
  }
  return result;
}

void RB::Drawable::statistics(os_unfair_lock_s *this@<X0>, void *a2@<X8>)
{
  unint64_t v4 = this + 8;
  os_unfair_lock_lock(this + 8);
  memcpy(a2, &this[10], 0x120uLL);
  os_unfair_lock_unlock(v4);
}

uint64_t RB::Drawable::Statistics::dictionary(RB::Drawable::Statistics *this)
{
  uint64_t v189 = *MEMORY[0x263EF8340];
  *(_OWORD *)v187 = 0u;
  unint64_t v188 = 64;
  long long v184 = 0u;
  unint64_t v185 = 64;
  uint64_t v2 = RBDrawableStatisticsFramesSubmitted;
  uint64_t v3 = [NSNumber numberWithUnsignedLong:*((void *)this + 2)];
  __dst[0] = v2;
  v187[1] = (void *)1;
  v183[0] = v3;
  *((void *)&v184 + 1) = 1;
  uint64_t v4 = RBDrawableStatisticsFramesRendered;
  uint64_t v5 = [NSNumber numberWithUnsignedLong:*((void *)this + 3)];
  __dst[1] = v4;
  v187[1] = (void *)2;
  v183[1] = v5;
  *((void *)&v184 + 1) = 2;
  uint64_t v6 = *(void *)this;
  if (*(void *)this)
  {
    uint64_t v7 = RBDrawableStatisticsMinSubmitTime;
    uint64_t v8 = [NSNumber numberWithDouble:*((double *)this + 12)];
    double v9 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      double v9 = v187[1];
    }
    float32x2_t v10 = v187[0];
    if (!v187[0]) {
      float32x2_t v10 = __dst;
    }
    v10[(void)v9] = v7;
    ++v187[1];
    uint64_t v11 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v11 = *((void *)&v184 + 1);
    }
    float32x2_t v12 = (void *)v184;
    if (!(void)v184) {
      float32x2_t v12 = v183;
    }
    v12[v11] = v8;
    ++*((void *)&v184 + 1);
    uint64_t v13 = RBDrawableStatisticsMaxSubmitTime;
    uint64_t v14 = [NSNumber numberWithDouble:*((double *)this + 20)];
    float32x2_t v15 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      float32x2_t v15 = v187[1];
    }
    float32x2_t v16 = v187[0];
    if (!v187[0]) {
      float32x2_t v16 = __dst;
    }
    v16[(void)v15] = v13;
    ++v187[1];
    uint64_t v17 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v17 = *((void *)&v184 + 1);
    }
    float v18 = (void *)v184;
    if (!(void)v184) {
      float v18 = v183;
    }
    v18[v17] = v14;
    ++*((void *)&v184 + 1);
    uint64_t v19 = RBDrawableStatisticsTotalSubmitTime;
    uint64_t v20 = [NSNumber numberWithDouble:*((double *)this + 4)];
    int v21 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      int v21 = v187[1];
    }
    BOOL v22 = v187[0];
    if (!v187[0]) {
      BOOL v22 = __dst;
    }
    v22[(void)v21] = v19;
    ++v187[1];
    uint64_t v23 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v23 = *((void *)&v184 + 1);
    }
    float v24 = (void *)v184;
    if (!(void)v184) {
      float v24 = v183;
    }
    v24[v23] = v20;
    ++*((void *)&v184 + 1);
    uint64_t v25 = RBDrawableStatisticsEMASubmitTime;
    uint64_t v26 = [NSNumber numberWithDouble:*((double *)this + 28)];
    float32x2_t v27 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      float32x2_t v27 = v187[1];
    }
    float32x2_t v28 = v187[0];
    if (!v187[0]) {
      float32x2_t v28 = __dst;
    }
    v28[(void)v27] = v25;
    ++v187[1];
    uint64_t v29 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v29 = *((void *)&v184 + 1);
    }
    float32x2_t v30 = (void *)v184;
    if (!(void)v184) {
      float32x2_t v30 = v183;
    }
    v30[v29] = v26;
    ++*((void *)&v184 + 1);
    uint64_t v6 = *(void *)this;
  }
  if ((v6 & 2) != 0)
  {
    uint64_t v31 = RBDrawableStatisticsMinRenderTime;
    uint64_t v32 = [NSNumber numberWithDouble:*((double *)this + 13)];
    float v33 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      float v33 = v187[1];
    }
    float32x2_t v34 = v187[0];
    if (!v187[0]) {
      float32x2_t v34 = __dst;
    }
    v34[(void)v33] = v31;
    ++v187[1];
    uint64_t v35 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v35 = *((void *)&v184 + 1);
    }
    float32x2_t v36 = (void *)v184;
    if (!(void)v184) {
      float32x2_t v36 = v183;
    }
    v36[v35] = v32;
    ++*((void *)&v184 + 1);
    uint64_t v37 = RBDrawableStatisticsMaxRenderTime;
    uint64_t v38 = [NSNumber numberWithDouble:*((double *)this + 21)];
    float32x2_t v39 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      float32x2_t v39 = v187[1];
    }
    float32x2_t v40 = v187[0];
    if (!v187[0]) {
      float32x2_t v40 = __dst;
    }
    v40[(void)v39] = v37;
    ++v187[1];
    uint64_t v41 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v41 = *((void *)&v184 + 1);
    }
    int64x2_t v42 = (void *)v184;
    if (!(void)v184) {
      int64x2_t v42 = v183;
    }
    v42[v41] = v38;
    ++*((void *)&v184 + 1);
    uint64_t v43 = RBDrawableStatisticsTotalRenderTime;
    uint64_t v44 = [NSNumber numberWithDouble:*((double *)this + 5)];
    uint64_t v45 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      uint64_t v45 = v187[1];
    }
    int32x2_t v46 = v187[0];
    if (!v187[0]) {
      int32x2_t v46 = __dst;
    }
    v46[(void)v45] = v43;
    ++v187[1];
    uint64_t v47 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v47 = *((void *)&v184 + 1);
    }
    int v48 = (void *)v184;
    if (!(void)v184) {
      int v48 = v183;
    }
    v48[v47] = v44;
    ++*((void *)&v184 + 1);
    uint64_t v49 = RBDrawableStatisticsEMARenderTime;
    uint64_t v50 = [NSNumber numberWithDouble:*((double *)this + 29)];
    float64x2_t v51 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      float64x2_t v51 = v187[1];
    }
    uint64_t v52 = v187[0];
    if (!v187[0]) {
      uint64_t v52 = __dst;
    }
    v52[(void)v51] = v49;
    ++v187[1];
    uint64_t v53 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v53 = *((void *)&v184 + 1);
    }
    uint64_t v54 = (void *)v184;
    if (!(void)v184) {
      uint64_t v54 = v183;
    }
    v54[v53] = v50;
    ++*((void *)&v184 + 1);
    uint64_t v6 = *(void *)this;
  }
  if ((v6 & 4) != 0)
  {
    uint64_t v55 = RBDrawableStatisticsMinCostEstimate;
    uint64_t v56 = [NSNumber numberWithDouble:*((double *)this + 14)];
    int v57 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      int v57 = v187[1];
    }
    int v58 = v187[0];
    if (!v187[0]) {
      int v58 = __dst;
    }
    v58[(void)v57] = v55;
    ++v187[1];
    uint64_t v59 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v59 = *((void *)&v184 + 1);
    }
    __int32 v60 = (void *)v184;
    if (!(void)v184) {
      __int32 v60 = v183;
    }
    v60[v59] = v56;
    ++*((void *)&v184 + 1);
    uint64_t v61 = RBDrawableStatisticsMaxCostEstimate;
    uint64_t v62 = [NSNumber numberWithDouble:*((double *)this + 22)];
    float64x2_t v63 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      float64x2_t v63 = v187[1];
    }
    int v64 = v187[0];
    if (!v187[0]) {
      int v64 = __dst;
    }
    v64[(void)v63] = v61;
    ++v187[1];
    uint64_t v65 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v65 = *((void *)&v184 + 1);
    }
    int v66 = (void *)v184;
    if (!(void)v184) {
      int v66 = v183;
    }
    v66[v65] = v62;
    ++*((void *)&v184 + 1);
    uint64_t v67 = RBDrawableStatisticsTotalCostEstimate;
    uint64_t v68 = [NSNumber numberWithDouble:*((double *)this + 6)];
    float v69 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      float v69 = v187[1];
    }
    uint64_t v70 = v187[0];
    if (!v187[0]) {
      uint64_t v70 = __dst;
    }
    v70[(void)v69] = v67;
    ++v187[1];
    uint64_t v71 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v71 = *((void *)&v184 + 1);
    }
    int v72 = (void *)v184;
    if (!(void)v184) {
      int v72 = v183;
    }
    v72[v71] = v68;
    ++*((void *)&v184 + 1);
    uint64_t v73 = RBDrawableStatisticsEMACostEstimate;
    uint64_t v74 = [NSNumber numberWithDouble:*((double *)this + 30)];
    float64x2_t v75 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      float64x2_t v75 = v187[1];
    }
    float64_t v76 = v187[0];
    if (!v187[0]) {
      float64_t v76 = __dst;
    }
    v76[(void)v75] = v73;
    ++v187[1];
    uint64_t v77 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v77 = *((void *)&v184 + 1);
    }
    int v78 = (void *)v184;
    if (!(void)v184) {
      int v78 = v183;
    }
    v78[v77] = v74;
    ++*((void *)&v184 + 1);
    uint64_t v6 = *(void *)this;
  }
  if ((v6 & 8) != 0)
  {
    uint64_t v79 = [NSNumber numberWithDouble:*((double *)this + 15)];
    uint64_t v80 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      uint64_t v80 = v187[1];
    }
    uint64_t v81 = v187[0];
    if (!v187[0]) {
      uint64_t v81 = __dst;
    }
    v81[(void)v80] = @"min_triangles";
    ++v187[1];
    uint64_t v82 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v82 = *((void *)&v184 + 1);
    }
    uint64_t v83 = (void *)v184;
    if (!(void)v184) {
      uint64_t v83 = v183;
    }
    v83[v82] = v79;
    ++*((void *)&v184 + 1);
    uint64_t v84 = [NSNumber numberWithDouble:*((double *)this + 23)];
    uint64_t v85 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      uint64_t v85 = v187[1];
    }
    uint64_t v86 = v187[0];
    if (!v187[0]) {
      uint64_t v86 = __dst;
    }
    v86[(void)v85] = @"max_triangles";
    ++v187[1];
    uint64_t v87 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v87 = *((void *)&v184 + 1);
    }
    uint64_t v88 = (void *)v184;
    if (!(void)v184) {
      uint64_t v88 = v183;
    }
    v88[v87] = v84;
    ++*((void *)&v184 + 1);
    uint64_t v89 = [NSNumber numberWithDouble:*((double *)this + 7)];
    unint64_t v90 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      unint64_t v90 = v187[1];
    }
    long long v91 = v187[0];
    if (!v187[0]) {
      long long v91 = __dst;
    }
    v91[(void)v90] = @"total_triangles";
    ++v187[1];
    uint64_t v92 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v92 = *((void *)&v184 + 1);
    }
    unsigned int v93 = (void *)v184;
    if (!(void)v184) {
      unsigned int v93 = v183;
    }
    v93[v92] = v89;
    ++*((void *)&v184 + 1);
    uint64_t v94 = [NSNumber numberWithDouble:*((double *)this + 31)];
    id v95 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      id v95 = v187[1];
    }
    id v96 = v187[0];
    if (!v187[0]) {
      id v96 = __dst;
    }
    v96[(void)v95] = @"ema_triangles";
    ++v187[1];
    uint64_t v97 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v97 = *((void *)&v184 + 1);
    }
    uint64_t v98 = (void *)v184;
    if (!(void)v184) {
      uint64_t v98 = v183;
    }
    v98[v97] = v94;
    ++*((void *)&v184 + 1);
    uint64_t v99 = [NSNumber numberWithDouble:*((double *)this + 16)];
    double v100 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      double v100 = v187[1];
    }
    id v101 = v187[0];
    if (!v187[0]) {
      id v101 = __dst;
    }
    v101[(void)v100] = @"min_texture_bytes";
    ++v187[1];
    uint64_t v102 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v102 = *((void *)&v184 + 1);
    }
    id v103 = (void *)v184;
    if (!(void)v184) {
      id v103 = v183;
    }
    v103[v102] = v99;
    ++*((void *)&v184 + 1);
    uint64_t v104 = [NSNumber numberWithDouble:*((double *)this + 24)];
    uint64_t v105 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      uint64_t v105 = v187[1];
    }
    id v106 = v187[0];
    if (!v187[0]) {
      id v106 = __dst;
    }
    v106[(void)v105] = @"max_texture_bytes";
    ++v187[1];
    uint64_t v107 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v107 = *((void *)&v184 + 1);
    }
    id v108 = (void *)v184;
    if (!(void)v184) {
      id v108 = v183;
    }
    v108[v107] = v104;
    ++*((void *)&v184 + 1);
    uint64_t v109 = [NSNumber numberWithDouble:*((double *)this + 8)];
    id v110 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      id v110 = v187[1];
    }
    unsigned int v111 = v187[0];
    if (!v187[0]) {
      unsigned int v111 = __dst;
    }
    v111[(void)v110] = @"total_texture_bytes";
    ++v187[1];
    uint64_t v112 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v112 = *((void *)&v184 + 1);
    }
    unint64_t v113 = (void *)v184;
    if (!(void)v184) {
      unint64_t v113 = v183;
    }
    v113[v112] = v109;
    ++*((void *)&v184 + 1);
    uint64_t v114 = [NSNumber numberWithDouble:*((double *)this + 32)];
    uint64_t v115 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      uint64_t v115 = v187[1];
    }
    v116 = v187[0];
    if (!v187[0]) {
      v116 = __dst;
    }
    v116[(void)v115] = @"ema_texture_bytes";
    ++v187[1];
    uint64_t v117 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v117 = *((void *)&v184 + 1);
    }
    uint64_t v118 = (void *)v184;
    if (!(void)v184) {
      uint64_t v118 = v183;
    }
    v118[v117] = v114;
    ++*((void *)&v184 + 1);
    uint64_t v119 = [NSNumber numberWithDouble:*((double *)this + 17)];
    uint64_t v120 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      uint64_t v120 = v187[1];
    }
    uint64_t v121 = v187[0];
    if (!v187[0]) {
      uint64_t v121 = __dst;
    }
    v121[(void)v120] = @"min_buffer_bytes";
    ++v187[1];
    uint64_t v122 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v122 = *((void *)&v184 + 1);
    }
    id v123 = (void *)v184;
    if (!(void)v184) {
      id v123 = v183;
    }
    v123[v122] = v119;
    ++*((void *)&v184 + 1);
    uint64_t v124 = [NSNumber numberWithDouble:*((double *)this + 25)];
    uint64_t v125 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      uint64_t v125 = v187[1];
    }
    uint64_t v126 = v187[0];
    if (!v187[0]) {
      uint64_t v126 = __dst;
    }
    v126[(void)v125] = @"max_buffer_bytes";
    ++v187[1];
    uint64_t v127 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v127 = *((void *)&v184 + 1);
    }
    int v128 = (void *)v184;
    if (!(void)v184) {
      int v128 = v183;
    }
    v128[v127] = v124;
    ++*((void *)&v184 + 1);
    uint64_t v129 = [NSNumber numberWithDouble:*((double *)this + 9)];
    v130 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v130 = v187[1];
    }
    v131 = v187[0];
    if (!v187[0]) {
      v131 = __dst;
    }
    v131[(void)v130] = @"total_buffer_bytes";
    ++v187[1];
    uint64_t v132 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v132 = *((void *)&v184 + 1);
    }
    v133 = (void *)v184;
    if (!(void)v184) {
      v133 = v183;
    }
    v133[v132] = v129;
    ++*((void *)&v184 + 1);
    uint64_t v134 = [NSNumber numberWithDouble:*((double *)this + 33)];
    uint64_t v135 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      uint64_t v135 = v187[1];
    }
    v136 = v187[0];
    if (!v187[0]) {
      v136 = __dst;
    }
    v136[(void)v135] = @"ema_buffer_bytes";
    ++v187[1];
    uint64_t v137 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v137 = *((void *)&v184 + 1);
    }
    unint64_t v138 = (void *)v184;
    if (!(void)v184) {
      unint64_t v138 = v183;
    }
    v138[v137] = v134;
    ++*((void *)&v184 + 1);
    uint64_t v139 = [NSNumber numberWithDouble:*((double *)this + 18)];
    uint64_t v140 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      uint64_t v140 = v187[1];
    }
    v141 = v187[0];
    if (!v187[0]) {
      v141 = __dst;
    }
    v141[(void)v140] = @"min_fill_rate";
    ++v187[1];
    uint64_t v142 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v142 = *((void *)&v184 + 1);
    }
    v143 = (void *)v184;
    if (!(void)v184) {
      v143 = v183;
    }
    v143[v142] = v139;
    ++*((void *)&v184 + 1);
    uint64_t v144 = [NSNumber numberWithDouble:*((double *)this + 26)];
    v145 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v145 = v187[1];
    }
    uint64_t v146 = v187[0];
    if (!v187[0]) {
      uint64_t v146 = __dst;
    }
    v146[(void)v145] = @"max_fill_rate";
    ++v187[1];
    uint64_t v147 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v147 = *((void *)&v184 + 1);
    }
    char v148 = (void *)v184;
    if (!(void)v184) {
      char v148 = v183;
    }
    v148[v147] = v144;
    ++*((void *)&v184 + 1);
    uint64_t v149 = [NSNumber numberWithDouble:*((double *)this + 10)];
    id v150 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      id v150 = v187[1];
    }
    v151 = v187[0];
    if (!v187[0]) {
      v151 = __dst;
    }
    v151[(void)v150] = @"total_fill_rate";
    ++v187[1];
    uint64_t v152 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v152 = *((void *)&v184 + 1);
    }
    unint64_t v153 = (void *)v184;
    if (!(void)v184) {
      unint64_t v153 = v183;
    }
    v153[v152] = v149;
    ++*((void *)&v184 + 1);
    uint64_t v154 = [NSNumber numberWithDouble:*((double *)this + 34)];
    uint64_t v155 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      uint64_t v155 = v187[1];
    }
    uint64_t v156 = v187[0];
    if (!v187[0]) {
      uint64_t v156 = __dst;
    }
    v156[(void)v155] = @"ema_fill_rate";
    ++v187[1];
    uint64_t v157 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v157 = *((void *)&v184 + 1);
    }
    v158 = (void *)v184;
    if (!(void)v184) {
      v158 = v183;
    }
    v158[v157] = v154;
    ++*((void *)&v184 + 1);
    uint64_t v159 = [NSNumber numberWithDouble:*((double *)this + 19)];
    v160 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v160 = v187[1];
    }
    v161 = v187[0];
    if (!v187[0]) {
      v161 = __dst;
    }
    v161[(void)v160] = @"min_render_passes";
    ++v187[1];
    uint64_t v162 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v162 = *((void *)&v184 + 1);
    }
    v163 = (void *)v184;
    if (!(void)v184) {
      v163 = v183;
    }
    v163[v162] = v159;
    ++*((void *)&v184 + 1);
    uint64_t v164 = [NSNumber numberWithDouble:*((double *)this + 27)];
    v165 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v165 = v187[1];
    }
    v166 = v187[0];
    if (!v187[0]) {
      v166 = __dst;
    }
    v166[(void)v165] = @"max_render_passes";
    ++v187[1];
    uint64_t v167 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v167 = *((void *)&v184 + 1);
    }
    v168 = (void *)v184;
    if (!(void)v184) {
      v168 = v183;
    }
    v168[v167] = v164;
    ++*((void *)&v184 + 1);
    uint64_t v169 = [NSNumber numberWithDouble:*((double *)this + 11)];
    v170 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v170 = v187[1];
    }
    v171 = v187[0];
    if (!v187[0]) {
      v171 = __dst;
    }
    v171[(void)v170] = @"total_render_passes";
    ++v187[1];
    uint64_t v172 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v172 = *((void *)&v184 + 1);
    }
    v173 = (void *)v184;
    if (!(void)v184) {
      v173 = v183;
    }
    v173[v172] = v169;
    ++*((void *)&v184 + 1);
    uint64_t v174 = [NSNumber numberWithDouble:*((double *)this + 35)];
    v175 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v175 = v187[1];
    }
    v176 = v187[0];
    if (!v187[0]) {
      v176 = __dst;
    }
    v176[(void)v175] = @"ema_render_passes";
    ++v187[1];
    uint64_t v177 = *((void *)&v184 + 1);
    if (v185 < *((void *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((void *)&v184 + 1) + 1);
      uint64_t v177 = *((void *)&v184 + 1);
    }
    v178 = (void *)v184;
    if (!(void)v184) {
      v178 = v183;
    }
    v178[v177] = v174;
    ++*((void *)&v184 + 1);
  }
  if ((void)v184) {
    v179 = (void *)v184;
  }
  else {
    v179 = v183;
  }
  if (v187[0]) {
    v180 = v187[0];
  }
  else {
    v180 = __dst;
  }
  uint64_t v181 = objc_msgSend(NSDictionary, "dictionaryWithObjects:forKeys:count:", v179, v180);
  if ((void)v184) {
    free((void *)v184);
  }
  if (v187[0]) {
    free(v187[0]);
  }
  return v181;
}

void sub_21419EC58(_Unwind_Exception *a1)
{
  if (STACK[0x208]) {
    free((void *)STACK[0x208]);
  }
  if (STACK[0x420]) {
    free((void *)STACK[0x420]);
  }
  _Unwind_Resume(a1);
}

atomic_uint *RB::Refcount<RB::Drawable,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::Refcount<RB::Drawable,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void RB::Drawable::~Drawable(id *this)
{
  *this = &unk_26C4EDD68;
}

{
  uint64_t vars8;

  *this = &unk_26C4EDD68;

  JUMPOUT(0x21669AC10);
}

void *RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 66) + (*((void *)__dst + 66) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 66) + (*((void *)__dst + 66) >> 1);
  }
  unint64_t result = RB::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 64), __dst, 0x40uLL, (size_t *)__dst + 66, v3);
  *((void *)__dst + 64) = result;
  return result;
}

uint64_t CG::dasher::dasher(uint64_t a1, uint64_t a2, uint64_t *a3, size_t a4, uint64_t a5, double a6)
{
  size_t v6 = a4;
  uint64_t v50 = *MEMORY[0x263EF8340];
  *(void *)a1 = &unk_26C4E7330;
  *(void *)(a1 + 8) = a5;
  uint64_t v11 = (double *)(a1 + 16);
  *(void *)(a1 + 48) = 0;
  float32x2_t v12 = (double **)(a1 + 48);
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 4;
  unint64_t v13 = 8 * a4;
  if (a4 && v13 >= 0x21)
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow((void *)(a1 + 16), a4);
    uint64_t v14 = *(double **)(a1 + 48);
    *(void *)(a1 + 56) = v6;
  }
  else
  {
    uint64_t v14 = 0;
    *(void *)(a1 + 56) = a4;
    if (!a4)
    {
      char v18 = 1;
      goto LABEL_11;
    }
  }
  if (v14) {
    float32x2_t v15 = v14;
  }
  else {
    float32x2_t v15 = v11;
  }
  unint64_t v16 = v13;
  do
  {
    uint64_t v17 = *a3++;
    *(void *)v15++ = v17;
    v16 -= 8;
  }
  while (v16);
  char v18 = 0;
LABEL_11:
  double v19 = *(double *)a2;
  float64x2_t v20 = *(float64x2_t *)(a2 + 8);
  float64x2_t v21 = vnegq_f64(v20);
  v20.f64[0] = *(float64_t *)(a2 + 24);
  float64x2_t v22 = vmulq_f64(v20, *(float64x2_t *)a2);
  v22.f64[0] = vsubq_f64(v22, (float64x2_t)vdupq_laneq_s64((int64x2_t)v22, 1)).f64[0];
  *(double *)(a1 + 72) = *(double *)(a2 + 24) / v22.f64[0];
  *(float64x2_t *)(a1 + 80) = vdivq_f64(v21, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v22.f64[0], 0));
  *(double *)(a1 + 96) = v19 / v22.f64[0];
  *(unsigned char *)(a1 + 104) = 1;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  if (v14) {
    uint64_t v23 = v14;
  }
  else {
    uint64_t v23 = v11;
  }
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  if ((v18 & 1) == 0)
  {
    float v24 = v23;
    do
    {
      *float v24 = fabs(*v24);
      ++v24;
      v13 -= 8;
    }
    while (v13);
  }
  if (v6)
  {
    uint64_t v47 = 0;
    size_t v48 = 0;
    uint64_t v49 = 4;
    if (v6 >= 5)
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(v46, v6);
      uint64_t v25 = (uint64_t *)v47;
      size_t v26 = v48;
    }
    else
    {
      uint64_t v25 = 0;
      size_t v26 = 0;
    }
    if (v25) {
      float32x2_t v27 = v25;
    }
    else {
      float32x2_t v27 = (uint64_t *)v46;
    }
    float32x2_t v28 = &v27[v26];
    size_t v29 = v6;
    do
    {
      uint64_t v30 = *(void *)v23++;
      *v28++ = v30;
      --v29;
    }
    while (v29);
    size_t v31 = v26 + v6;
    size_t v48 = v31;
    unint64_t v32 = *(void *)(a1 + 56);
    if (*(void *)(a1 + 64) < v32 + v31)
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(v11, v32 + v31);
      unint64_t v43 = *(void *)(a1 + 56);
      if (*(void *)(a1 + 48)) {
        float v33 = *(double **)(a1 + 48);
      }
      else {
        float v33 = v11;
      }
      BOOL v44 = v43 > v32;
      unint64_t v45 = v43 - v32;
      if (v44) {
        memmove(&v33[v32 + v31], &v33[v32], 8 * v45);
      }
    }
    else if (*v12)
    {
      float v33 = *v12;
    }
    else
    {
      float v33 = v11;
    }
    if (v31)
    {
      uint64_t v34 = 8 * v31;
      uint64_t v35 = &v33[v32];
      do
      {
        uint64_t v36 = *v27++;
        *(void *)v35++ = v36;
        v34 -= 8;
      }
      while (v34);
    }
    size_t v6 = *(void *)(a1 + 56) + 1;
    *(void *)(a1 + 56) = v6;
    if (v47)
    {
      free(v47);
      size_t v6 = *(void *)(a1 + 56);
    }
    uint64_t v14 = *v12;
  }
  if (!v14) {
    uint64_t v14 = v11;
  }
  if (!v6) {
    goto LABEL_41;
  }
  uint64_t v37 = 0;
  double v38 = 0.0;
  do
    double v38 = v14[v37++] + v38;
  while (v6 != v37);
  if (v38 >= 2.22044605e-16)
  {
    while (a6 < 0.0)
      a6 = a6 + v38;
    *(void *)(a1 + 112) = 0;
    *(unsigned char *)(a1 + 104) = 1;
    double v39 = *v14;
    if (a6 >= *v14)
    {
      unint64_t v40 = 0;
      int v41 = 1;
      do
      {
        if (a6 == 0.0 && v39 == 0.0) {
          break;
        }
        a6 = a6 - v39;
        v41 ^= 1u;
        *(unsigned char *)(a1 + 104) = v41;
        if (v40 < v6 - 1) {
          ++v40;
        }
        else {
          unint64_t v40 = 0;
        }
        *(void *)(a1 + 112) = v40;
        double v39 = v14[v40];
      }
      while (a6 >= v39);
    }
    *(double *)(a1 + 120) = v39 - a6;
  }
  else
  {
LABEL_41:
    *(void *)(a1 + 56) = 0;
  }
  return a1;
}

__n128 CG::dasher::moveto(uint64_t a1, __n128 a2)
{
  *(__n128 *)(a1 + 128) = a2;
  *(void *)(a1 + 152) = *(void *)(a1 + 112);
  *(unsigned char *)(a1 + 144) = *(unsigned char *)(a1 + 104);
  *(unsigned char *)(a1 + 184) = 1;
  *(void *)(a1 + 160) = *(void *)(a1 + 120);
  __n128 result = *(__n128 *)(a1 + 128);
  *(__n128 *)(a1 + 168) = result;
  return result;
}

__n128 CG::dasher::lineto(uint64_t a1, float64x2_t a2)
{
  v5[0] = *(float64x2_t *)(a1 + 168);
  v5[1] = a2;
  CG::dasher::dash_path_element<CG::LineSegment>(a1, v5);
  __n128 result = (__n128)a2;
  *(float64x2_t *)(a1 + 168) = a2;
  return result;
}

uint64_t CG::dasher::dash_path_element<CG::LineSegment>(uint64_t result, float64x2_t *a2)
{
  float64x2_t v2 = vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)(result + 88), a2[1].f64[1] - a2->f64[1]), *(float64x2_t *)(result + 72), a2[1].f64[0] - a2->f64[0]);
  double v3 = sqrt(vaddvq_f64(vmulq_f64(v2, v2)));
  if (v3 != 0.0)
  {
    uint64_t v5 = result;
    double v6 = *(double *)(result + 160);
    if (v3 <= v6)
    {
      if (*(unsigned char *)(result + 144))
      {
        __n128 result = CG::dasher::add_path_dash_segment<CG::LineSegment>(result, a2, 0.0, v3);
        *(unsigned char *)(v5 + 184) = 0;
        double v6 = *(double *)(v5 + 160);
      }
      double v15 = v6 - v3;
      goto LABEL_20;
    }
    double v7 = 0.0;
    int v8 = *(unsigned __int8 *)(result + 144);
    double v9 = *(double *)(result + 160);
    do
    {
      if (v8)
      {
        __n128 result = CG::dasher::add_path_dash_segment<CG::LineSegment>(v5, a2, v7, v9);
        double v6 = *(double *)(v5 + 160);
        int v8 = *(unsigned __int8 *)(v5 + 144);
      }
      uint64_t v10 = *(void *)(v5 + 152);
      uint64_t v11 = *(void *)(v5 + 48);
      uint64_t v12 = *(void *)(v5 + 56) - 1;
      double v7 = v6 + v7;
      v8 ^= 1u;
      *(unsigned char *)(v5 + 144) = v8;
      if (v10 == v12) {
        uint64_t v13 = 0;
      }
      else {
        uint64_t v13 = v10 + 1;
      }
      *(void *)(v5 + 152) = v13;
      if (v11) {
        uint64_t v14 = v11;
      }
      else {
        uint64_t v14 = v5 + 16;
      }
      double v6 = *(double *)(v14 + 8 * v13);
      *(double *)(v5 + 160) = v6;
      *(unsigned char *)(v5 + 184) = 1;
      double v9 = v6 + v7;
    }
    while (v6 + v7 < v3);
    if (v7 < v3)
    {
      if (*(unsigned char *)(v5 + 144))
      {
        __n128 result = CG::dasher::add_path_dash_segment<CG::LineSegment>(v5, a2, v7, v3);
        *(unsigned char *)(v5 + 184) = 0;
        double v6 = *(double *)(v5 + 160);
      }
      double v15 = v7 - v3 + v6;
LABEL_20:
      *(double *)(v5 + 160) = v15;
    }
  }
  return result;
}

double CG::dasher::quadto(const Point *a1, __n128 a2, __n128 a3)
{
  *(__n128 *)&v6[0].v = a3;
  *(__n128 *)&v7[0].v = a2;
  CG::Quadratic::Quadratic((CG::Quadratic *)v5, a1 + 42, v7, v6);
  CG::dasher::dash_path_element<CG::Quadratic>((uint64_t)a1, (CG::Quadratic *)v5);
  double result = *(double *)&v6[0].v;
  *(_OWORD *)&a1[42].v = *(_OWORD *)&v6[0].v;
  return result;
}

uint64_t CG::dasher::dash_path_element<CG::Quadratic>(uint64_t a1, CG::Quadratic *a2)
{
  long long v4 = *((_OWORD *)a2 + 1);
  long long v23 = *(_OWORD *)a2;
  long long v24 = v4;
  long long v5 = *((_OWORD *)a2 + 3);
  long long v25 = *((_OWORD *)a2 + 2);
  long long v26 = v5;
  long long v27 = *((_OWORD *)a2 + 4);
  double v6 = *(double *)(a1 + 72);
  double v7 = *(double *)(a1 + 80);
  double v8 = *(double *)(a1 + 88);
  double v9 = *(double *)(a1 + 96);
  *(double *)&v32[0].v = v6 * *(double *)&v23 + v8 * *((double *)&v23 + 1);
  double v33 = v7 * *(double *)&v23 + v9 * *((double *)&v23 + 1);
  *(double *)&v30[0].v = *(double *)&v24 * v6 + *((double *)&v24 + 1) * v8;
  double v31 = *(double *)&v24 * v7 + *((double *)&v24 + 1) * v9;
  *(double *)&v28[0].v = *(double *)&v25 * v6 + *((double *)&v25 + 1) * v8;
  double v29 = *(double *)&v25 * v7 + *((double *)&v25 + 1) * v9;
  CG::Quadratic::Quadratic((CG::Quadratic *)&v23, v32, v30, v28);
  uint64_t result = (uint64_t)CG::Quadratic::length((double *)&v23, 0);
  if (v11 != 0.0)
  {
    double v12 = v11;
    double v13 = *(double *)(a1 + 160);
    if (v12 <= v13)
    {
      if (*(unsigned char *)(a1 + 144))
      {
        uint64_t result = CG::dasher::add_path_dash_segment<CG::Quadratic>(a1, a2, 0.0, v12);
        *(unsigned char *)(a1 + 184) = 0;
        double v13 = *(double *)(a1 + 160);
      }
      double v22 = v13 - v12;
      goto LABEL_20;
    }
    double v14 = 0.0;
    int v15 = *(unsigned __int8 *)(a1 + 144);
    double v16 = *(double *)(a1 + 160);
    do
    {
      if (v15)
      {
        uint64_t result = CG::dasher::add_path_dash_segment<CG::Quadratic>(a1, a2, v14, v16);
        double v13 = *(double *)(a1 + 160);
        int v15 = *(unsigned __int8 *)(a1 + 144);
      }
      uint64_t v17 = *(void *)(a1 + 152);
      uint64_t v18 = *(void *)(a1 + 48);
      uint64_t v19 = *(void *)(a1 + 56) - 1;
      double v14 = v13 + v14;
      v15 ^= 1u;
      *(unsigned char *)(a1 + 144) = v15;
      if (v17 == v19) {
        uint64_t v20 = 0;
      }
      else {
        uint64_t v20 = v17 + 1;
      }
      *(void *)(a1 + 152) = v20;
      if (v18) {
        uint64_t v21 = v18;
      }
      else {
        uint64_t v21 = a1 + 16;
      }
      double v13 = *(double *)(v21 + 8 * v20);
      *(double *)(a1 + 160) = v13;
      *(unsigned char *)(a1 + 184) = 1;
      double v16 = v13 + v14;
    }
    while (v13 + v14 < v12);
    if (v14 < v12)
    {
      if (*(unsigned char *)(a1 + 144))
      {
        uint64_t result = CG::dasher::add_path_dash_segment<CG::Quadratic>(a1, a2, v14, v12);
        *(unsigned char *)(a1 + 184) = 0;
        double v13 = *(double *)(a1 + 160);
      }
      double v22 = v14 - v12 + v13;
LABEL_20:
      *(double *)(a1 + 160) = v22;
    }
  }
  return result;
}

double CG::dasher::cubeto(const Point *a1, __n128 a2, __n128 a3, __n128 a4)
{
  *(__n128 *)&v8[0].v = a3;
  *(__n128 *)&v9[0].v = a2;
  *(__n128 *)&v7[0].v = a4;
  CG::Cubic::Cubic((CG::Cubic *)v6, a1 + 42, v9, v8, v7);
  CG::dasher::dash_path_element<CG::Cubic>((uint64_t)a1, (uint64_t)v6);
  double result = *(double *)&v7[0].v;
  *(_OWORD *)&a1[42].v = *(_OWORD *)&v7[0].v;
  return result;
}

void CG::dasher::dash_path_element<CG::Cubic>(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 80);
  long long v26 = *(_OWORD *)(a2 + 64);
  long long v27 = v4;
  long long v28 = *(_OWORD *)(a2 + 96);
  float64x2_t v5 = *(float64x2_t *)(a2 + 16);
  v23[0] = *(float64x2_t *)a2;
  v23[1] = v5;
  long long v6 = *(_OWORD *)(a2 + 48);
  long long v24 = *(_OWORD *)(a2 + 32);
  long long v25 = v6;
  double v7 = *(double *)(a1 + 72);
  double v8 = *(double *)(a1 + 80);
  double v9 = *(double *)(a1 + 88);
  double v10 = *(double *)(a1 + 96);
  *(double *)&v35[0].v = v7 * v23[0].f64[0] + v9 * v23[0].f64[1];
  double v36 = v8 * v23[0].f64[0] + v10 * v23[0].f64[1];
  *(double *)&v33[0].v = v5.f64[0] * v7 + v5.f64[1] * v9;
  double v34 = v5.f64[0] * v8 + v5.f64[1] * v10;
  *(double *)&v31[0].v = *(double *)&v24 * v7 + *((double *)&v24 + 1) * v9;
  double v32 = *(double *)&v24 * v8 + *((double *)&v24 + 1) * v10;
  *(double *)&v29[0].v = *(double *)&v6 * v7 + *((double *)&v6 + 1) * v9;
  double v30 = *(double *)&v6 * v8 + *((double *)&v6 + 1) * v10;
  CG::Cubic::Cubic((CG::Cubic *)v23, v35, v33, v31, v29);
  double v11 = CG::Cubic::length(v23, 0.5);
  if (v11 != 0.0)
  {
    double v12 = v11;
    double v13 = *(double *)(a1 + 160);
    if (v12 <= v13)
    {
      if (*(unsigned char *)(a1 + 144))
      {
        CG::dasher::add_path_dash_segment<CG::Cubic>(a1, a2, 0.0, v12);
        *(unsigned char *)(a1 + 184) = 0;
        double v13 = *(double *)(a1 + 160);
      }
      double v22 = v13 - v12;
      goto LABEL_20;
    }
    double v14 = 0.0;
    int v15 = *(unsigned __int8 *)(a1 + 144);
    double v16 = *(double *)(a1 + 160);
    do
    {
      if (v15)
      {
        CG::dasher::add_path_dash_segment<CG::Cubic>(a1, a2, v14, v16);
        double v13 = *(double *)(a1 + 160);
        int v15 = *(unsigned __int8 *)(a1 + 144);
      }
      uint64_t v17 = *(void *)(a1 + 152);
      uint64_t v18 = *(void *)(a1 + 48);
      uint64_t v19 = *(void *)(a1 + 56) - 1;
      double v14 = v13 + v14;
      v15 ^= 1u;
      *(unsigned char *)(a1 + 144) = v15;
      if (v17 == v19) {
        uint64_t v20 = 0;
      }
      else {
        uint64_t v20 = v17 + 1;
      }
      *(void *)(a1 + 152) = v20;
      if (v18) {
        uint64_t v21 = v18;
      }
      else {
        uint64_t v21 = a1 + 16;
      }
      double v13 = *(double *)(v21 + 8 * v20);
      *(double *)(a1 + 160) = v13;
      *(unsigned char *)(a1 + 184) = 1;
      double v16 = v13 + v14;
    }
    while (v13 + v14 < v12);
    if (v14 < v12)
    {
      if (*(unsigned char *)(a1 + 144))
      {
        CG::dasher::add_path_dash_segment<CG::Cubic>(a1, a2, v14, v12);
        *(unsigned char *)(a1 + 184) = 0;
        double v13 = *(double *)(a1 + 160);
      }
      double v22 = v14 - v12 + v13;
LABEL_20:
      *(double *)(a1 + 160) = v22;
    }
  }
}

__n128 CG::dasher::closepath(CG::dasher *this)
{
  float64x2_t v2 = *((float64x2_t *)this + 8);
  v4[0] = *(float64x2_t *)((char *)this + 168);
  v4[1] = v2;
  CG::dasher::dash_path_element<CG::LineSegment>((uint64_t)this, v4);
  *((void *)this + 19) = *((void *)this + 14);
  *((unsigned char *)this + 144) = *((unsigned char *)this + 104);
  *((unsigned char *)this + 184) = 1;
  *((void *)this + 20) = *((void *)this + 15);
  __n128 result = *((__n128 *)this + 8);
  *(__n128 *)((char *)this + 168) = result;
  return result;
}

uint64_t CG::dasher::endpath(CG::dasher *this)
{
  return (***((uint64_t (****)(void))this + 1))(*((void *)this + 1));
}

uint64_t CG::dasher::add_path_dash_segment<CG::LineSegment>(uint64_t a1, float64x2_t *a2, double a3, double a4)
{
  double v8 = a2->f64[1];
  double v9 = a2[1].f64[0];
  double v10 = a2[1].f64[1];
  double v11 = *(double *)(a1 + 72);
  double v12 = *(double *)(a1 + 80);
  double v13 = *(double *)(a1 + 88);
  double v14 = *(double *)(a1 + 96);
  double v15 = v12 * a2->f64[0] + v14 * v8;
  v28.f64[0] = v11 * a2->f64[0] + v13 * v8;
  v28.f64[1] = v15;
  double v29 = v11 * v9 + v13 * v10;
  double v30 = v12 * v9 + v14 * v10;
  double v16 = CG::LineSegment::index(&v28, a3);
  CG::LineSegment::split(a2, v16, (uint64_t)&v28);
  if (*(unsigned char *)(a1 + 184)) {
    (*(void (**)(void, __n128))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), (__n128)v31);
  }
  if (a3 == a4)
  {
    float64x2_t v17 = vsubq_f64(v32, v31);
    if (v17.f64[0] != 0.0 || v17.f64[1] != 0.0) {
      float64x2_t v17 = vdivq_f64(v17, (float64x2_t)vdupq_lane_s64(COERCE__INT64(sqrt(vaddvq_f64(vmulq_f64(v17, v17)))), 0));
    }
    __n128 v18 = (__n128)vmlaq_f64(v31, (float64x2_t)vdupq_n_s64(0x3EF0000000000000uLL), v17);
    uint64_t v19 = *(void *)(a1 + 8);
  }
  else
  {
    double v20 = *(double *)(a1 + 72);
    double v21 = *(double *)(a1 + 80);
    double v22 = *(double *)(a1 + 88);
    double v23 = *(double *)(a1 + 96);
    v26.f64[0] = v20 * v31.f64[0] + v22 * v31.f64[1];
    v26.f64[1] = v21 * v31.f64[0] + v23 * v31.f64[1];
    v27.n128_f64[0] = v20 * v32.f64[0] + v22 * v32.f64[1];
    v27.n128_f64[1] = v21 * v32.f64[0] + v23 * v32.f64[1];
    double v24 = CG::LineSegment::index(&v26, a4 - a3);
    CG::LineSegment::split(&v31, v24, (uint64_t)&v26);
    uint64_t v19 = *(void *)(a1 + 8);
    __n128 v18 = v27;
  }
  return (*(uint64_t (**)(uint64_t, __n128))(*(void *)v19 + 24))(v19, v18);
}

uint64_t CG::dasher::add_path_dash_segment<CG::Quadratic>(uint64_t a1, CG::Quadratic *a2, double a3, double a4)
{
  long long v8 = *((_OWORD *)a2 + 1);
  long long v35 = *(_OWORD *)a2;
  long long v36 = v8;
  long long v9 = *((_OWORD *)a2 + 3);
  long long v37 = *((_OWORD *)a2 + 2);
  long long v38 = v9;
  long long v39 = *((_OWORD *)a2 + 4);
  double v10 = *(double *)(a1 + 72);
  double v11 = *(double *)(a1 + 80);
  double v12 = *(double *)(a1 + 88);
  double v13 = *(double *)(a1 + 96);
  v30.f64[0] = v10 * *(double *)&v35 + v12 * *((double *)&v35 + 1);
  v30.f64[1] = v11 * *(double *)&v35 + v13 * *((double *)&v35 + 1);
  *(double *)&v49[0].v = *(double *)&v36 * v10 + *((double *)&v36 + 1) * v12;
  double v50 = *(double *)&v36 * v11 + *((double *)&v36 + 1) * v13;
  *(double *)&v47[0].v = *(double *)&v37 * v10 + *((double *)&v37 + 1) * v12;
  double v48 = *(double *)&v37 * v11 + *((double *)&v37 + 1) * v13;
  CG::Quadratic::Quadratic((CG::Quadratic *)&v35, (const Point *)&v30, v49, v47);
  CG::Quadratic::index((double *)&v35, a3);
  CG::Quadratic::split(a2, v14, (uint64_t)&v35);
  if (*(unsigned char *)(a1 + 184))
  {
    v15.n128_f64[0] = CG::Quadratic::start_point((CG::Quadratic *)&v40);
    v15.n128_u64[1] = v16;
    (*(void (**)(void, __n128))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), v15);
  }
  if (a3 == a4)
  {
    double v17 = CG::Quadratic::derivative(&v40, 0.0);
    double v19 = v17;
    double v20 = v18;
    if (v17 != 0.0 || v18 != 0.0)
    {
      double v21 = sqrt(v17 * v17 + v18 * v18);
      double v19 = v19 / v21;
      double v20 = v18 / v21;
    }
    v22.n128_f64[0] = CG::Quadratic::start_point((CG::Quadratic *)&v40) + v19 * 0.0000152587891;
    v22.n128_f64[1] = v23 + v20 * 0.0000152587891;
    return (*(uint64_t (**)(void, __n128))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), v22);
  }
  else
  {
    float64x2_t v30 = v40;
    __n128 v31 = v41;
    __n128 v32 = v42;
    long long v33 = v43;
    long long v34 = v44;
    double v25 = *(double *)(a1 + 72);
    double v26 = *(double *)(a1 + 80);
    double v27 = *(double *)(a1 + 88);
    double v28 = *(double *)(a1 + 96);
    *(double *)&v49[0].v = v25 * v40.f64[0] + v27 * v40.f64[1];
    double v50 = v26 * v40.f64[0] + v28 * v40.f64[1];
    *(double *)&v47[0].v = v41.n128_f64[0] * v25 + v41.n128_f64[1] * v27;
    double v48 = v41.n128_f64[0] * v26 + v41.n128_f64[1] * v28;
    *(double *)&v45[0].v = v42.n128_f64[0] * v25 + v42.n128_f64[1] * v27;
    double v46 = v42.n128_f64[0] * v26 + v42.n128_f64[1] * v28;
    CG::Quadratic::Quadratic((CG::Quadratic *)&v30, v49, v47, v45);
    CG::Quadratic::index(v30.f64, a4 - a3);
    CG::Quadratic::split((CG::Quadratic *)&v40, v29, (uint64_t)&v30);
    return (*(uint64_t (**)(void, __n128, __n128))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), v31, v32);
  }
}

uint64_t CG::dasher::add_path_dash_segment<CG::Cubic>(uint64_t a1, uint64_t a2, double a3, double a4)
{
  long long v8 = *(_OWORD *)(a2 + 80);
  long long v35 = *(_OWORD *)(a2 + 64);
  long long v36 = v8;
  long long v37 = *(_OWORD *)(a2 + 96);
  float64x2_t v9 = *(float64x2_t *)(a2 + 16);
  v32[0] = *(float64x2_t *)a2;
  v32[1] = v9;
  long long v10 = *(_OWORD *)(a2 + 48);
  long long v33 = *(_OWORD *)(a2 + 32);
  long long v34 = v10;
  double v11 = *(double *)(a1 + 72);
  double v12 = *(double *)(a1 + 80);
  double v13 = *(double *)(a1 + 88);
  double v14 = *(double *)(a1 + 96);
  v25.f64[0] = v11 * v32[0].f64[0] + v13 * v32[0].f64[1];
  v25.f64[1] = v12 * v32[0].f64[0] + v14 * v32[0].f64[1];
  *(double *)&v51[0].v = v9.f64[0] * v11 + v9.f64[1] * v13;
  double v52 = v9.f64[0] * v12 + v9.f64[1] * v14;
  *(double *)&v49[0].v = *(double *)&v33 * v11 + *((double *)&v33 + 1) * v13;
  double v50 = *(double *)&v33 * v12 + *((double *)&v33 + 1) * v14;
  *(double *)&v47[0].v = *(double *)&v10 * v11 + *((double *)&v10 + 1) * v13;
  double v48 = *(double *)&v10 * v12 + *((double *)&v10 + 1) * v14;
  CG::Cubic::Cubic((CG::Cubic *)v32, (const Point *)&v25, v51, v49, v47);
  double v15 = CG::Cubic::index(v32, a3, 0.5);
  CG::Cubic::split((float64x2_t *)a2, v15, v32);
  if (*(unsigned char *)(a1 + 184)) {
    (*(void (**)(void, __n128))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), (__n128)v38);
  }
  if (a3 == a4)
  {
    double v16 = CG::Cubic::derivative((CG::Cubic *)&v38, 0.0);
    v18.f64[0] = v16;
    v18.f64[1] = v17;
    if (v16 != 0.0 || v17 != 0.0) {
      float64x2_t v18 = vdivq_f64(v18, (float64x2_t)vdupq_lane_s64(COERCE__INT64(sqrt(v16 * v16 + v17 * v17)), 0));
    }
    return (*(uint64_t (**)(void, __n128))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), (__n128)vmlaq_f64(v38, (float64x2_t)vdupq_n_s64(0x3EF0000000000000uLL), v18));
  }
  else
  {
    long long v29 = v42;
    long long v30 = v43;
    long long v31 = v44;
    float64x2_t v25 = v38;
    __n128 v26 = v39;
    __n128 v27 = v40;
    __n128 v28 = v41;
    double v20 = *(double *)(a1 + 72);
    double v21 = *(double *)(a1 + 80);
    double v22 = *(double *)(a1 + 88);
    double v23 = *(double *)(a1 + 96);
    *(double *)&v51[0].v = v20 * v38.f64[0] + v22 * v38.f64[1];
    double v52 = v21 * v38.f64[0] + v23 * v38.f64[1];
    *(double *)&v49[0].v = v39.n128_f64[0] * v20 + v39.n128_f64[1] * v22;
    double v50 = v39.n128_f64[0] * v21 + v39.n128_f64[1] * v23;
    *(double *)&v47[0].v = v40.n128_f64[0] * v20 + v40.n128_f64[1] * v22;
    double v48 = v40.n128_f64[0] * v21 + v40.n128_f64[1] * v23;
    *(double *)&v45[0].v = v41.n128_f64[0] * v20 + v41.n128_f64[1] * v22;
    double v46 = v41.n128_f64[0] * v21 + v41.n128_f64[1] * v23;
    CG::Cubic::Cubic((CG::Cubic *)&v25, v51, v49, v47, v45);
    double v24 = CG::Cubic::index(&v25, a4 - a3, 0.5);
    CG::Cubic::split(&v38, v24, &v25);
    return (*(uint64_t (**)(void, __n128, __n128, __n128))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), v26, v27, v28);
  }
}

void RBXMLRecorderInstall()
{
  RB::XMLRecorder::installed = 1;
}

void *RBXMLRecorderStart()
{
  if (!RB::XMLRecorder::installed) {
    return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)"Set RB_XML_RECORDER=1 in environment to enable recording.\n", 58);
  }
  if (!RB::XMLRecorder::enabled) {
    RB::XMLRecorder::enabled = 1;
  }
  return result;
}

void RBXMLRecorderStop()
{
  if (RB::XMLRecorder::enabled) {
    RB::XMLRecorder::enabled = 0;
  }
}

uint64_t std::ostringstream::basic_ostringstream[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C340] + 64;
  *(void *)(a1 + 112) = MEMORY[0x263F8C340] + 64;
  uint64_t v3 = *(void *)(MEMORY[0x263F8C2C8] + 16);
  uint64_t v4 = *(void *)(MEMORY[0x263F8C2C8] + 8);
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - 24)) = v3;
  float64x2_t v5 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v5, (void *)(a1 + 8));
  uint64_t v6 = MEMORY[0x263F8C340] + 24;
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  *(void *)a1 = v6;
  *(void *)(a1 + 112) = v2;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 8) = MEMORY[0x263F8C318] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_2141A0024(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x21669ABE0](v1);
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C2C8];
  uint64_t v3 = *MEMORY[0x263F8C2C8];
  *(void *)a1 = *MEMORY[0x263F8C2C8];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 8) = MEMORY[0x263F8C318] + 16;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x21669ABE0](a1 + 112);
  return a1;
}

uint64_t RBXMLRecorderExportCGImage(CGImage *a1)
{
  if (RB::XMLRecorder::image_names)
  {
    uint64_t v2 = (void *)MEMORY[0x21669B110]();
    uint64_t v3 = [NSNumber numberWithUnsignedInt:CGImageGetIdentifier()];
    uint64_t v4 = [(id)RB::XMLRecorder::image_names objectForKeyedSubscript:v3];
    if (v4)
    {
LABEL_15:
      return v4;
    }
    uint64_t v4 = [(id)RB::XMLRecorder::resource_path stringByAppendingPathComponent:objc_msgSend(NSString, "stringWithFormat:", @"image-%@.png", v3)];
    if (![(id)RB::XMLRecorder::image_names count])
    {
      float64x2_t v5 = (void *)[MEMORY[0x263F08850] defaultManager];
      [v5 createDirectoryAtPath:RB::XMLRecorder::resource_path withIntermediateDirectories:0 attributes:0 error:0];
    }
    uint64_t v6 = CGDataConsumerCreateWithURL((CFURLRef)[NSURL fileURLWithPath:v4]);
    if (v6)
    {
      double v7 = v6;
      long long v8 = CGImageDestinationCreateWithDataConsumer(v6, @"public.png", 1uLL, 0);
      float64x2_t v9 = v8;
      if (v8)
      {
        CGImageDestinationAddImage(v8, a1, 0);
        BOOL v10 = CGImageDestinationFinalize(v9);
      }
      else
      {
        BOOL v10 = 0;
      }
      CGDataConsumerRelease(v7);
      if (v9)
      {
        CFRelease(v9);
        if (v10)
        {
LABEL_12:
          [(id)RB::XMLRecorder::image_names setObject:v4 forKeyedSubscript:v3];
          goto LABEL_15;
        }
      }
      else if (v10)
      {
        goto LABEL_12;
      }
    }
    uint64_t v4 = 0;
    goto LABEL_15;
  }
  return 0;
}

void sub_2141A02D8(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

id RBDisplayListContentsXMLDescription(void *a1)
{
  return RBDisplayListContentsXMLDescription2(a1, 0, *MEMORY[0x263F001B0], *(double *)(MEMORY[0x263F001B0] + 8));
}

id RBDisplayListContentsXMLDescription2(void *a1, uint64_t a2, double a3, double a4)
{
  id v8 = (id)objc_msgSend(a1, "_rb_xml_document");
  if (v8)
  {
    if (objc_opt_respondsToSelector())
    {
      unsigned __int16 v9 = rb_color_space([a1 defaultColorSpace]);
      if ((v9 & 1) == 0 && v9 > 0xFFu) {
        a2 = a2 | 0x80000000;
      }
      else {
        a2 = a2;
      }
    }
    std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)&v17);
    RB::XML::Document::print((uint64_t)v8, &v17, a2, a3, a4);
    std::stringbuf::str[abi:nn180100]<std::allocator<char>>((uint64_t)v18, __p);
    id v11 = [NSString alloc];
    if ((v16 & 0x80u) == 0) {
      double v12 = __p;
    }
    else {
      double v12 = (void **)__p[0];
    }
    if ((v16 & 0x80u) == 0) {
      unint64_t v13 = v16;
    }
    else {
      unint64_t v13 = (unint64_t)__p[1];
    }
    id v8 = (id)[v11 initWithBytes:v12 length:v13 encoding:4];
    if ((char)v16 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v17 = *MEMORY[0x263F8C2C8];
    *(void *)((char *)&v18[-1] + *(void *)(v17 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
    v18[0] = MEMORY[0x263F8C318] + 16;
    if (v19 < 0) {
      operator delete((void *)v18[8]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    MEMORY[0x21669ABE0](&v20);
  }
  return v8;
}

void sub_2141A04F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

RB::XML::Element **RBDisplayListContentsXMLDictionary(void *a1, uint64_t a2)
{
  __n128 result = (RB::XML::Element **)objc_msgSend(a1, "_rb_xml_document");
  if (result)
  {
    float64x2_t v5 = result;
    if (objc_opt_respondsToSelector())
    {
      unsigned __int16 v6 = rb_color_space([a1 defaultColorSpace]);
      if ((v6 & 1) == 0 && v6 > 0xFFu) {
        a2 = a2 | 0x80000000;
      }
      else {
        a2 = a2;
      }
    }
    id v8 = (void *)MEMORY[0x21669B110]();
    unsigned __int16 v9 = RB::XML::Document::dictionary(v5, a2);
    return (RB::XML::Element **)v9;
  }
  return result;
}

void *std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x21669AAD0](v13, a1);
  if (v13[0])
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      BOOL v10 = std::locale::use_facet(&v14, MEMORY[0x263F8C108]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x21669AAE0](v13);
  return a1;
}

void sub_2141A071C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
}

uint64_t std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      int64_t v12 = 0;
    }
    else {
      int64_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if (v12 >= 1)
    {
      std::string::basic_string[abi:nn180100](__p, v12, __c);
      unint64_t v13 = v18 >= 0 ? __p : (void **)__p[0];
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v6 + 96))(v6, v13, v12);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      if (v14 != v12) {
        return 0;
      }
    }
    uint64_t v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v15) == v15) {
      *(void *)(a5 + 24) = 0;
    }
    else {
      return 0;
    }
  }
  return v6;
}

void sub_2141A08B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::string::basic_string[abi:nn180100](void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

uint64_t std::stringbuf::str[abi:nn180100]<std::allocator<char>>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = std::stringbuf::view[abi:nn180100](a1);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  float64x2_t v5 = (const void *)result;
  size_t v6 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    int v9 = operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
  }
  else
  {
    *((unsigned char *)a2 + 23) = v4;
    if (!v4) {
      goto LABEL_9;
    }
  }
  uint64_t result = (uint64_t)memmove(a2, v5, v6);
LABEL_9:
  *((unsigned char *)a2 + v6) = 0;
  return result;
}

uint64_t std::stringbuf::view[abi:nn180100](uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 96);
  if ((v1 & 0x10) != 0)
  {
    unint64_t v3 = *(void *)(a1 + 48);
    if (*(void *)(a1 + 88) < v3) {
      *(void *)(a1 + 88) = v3;
    }
    return *(void *)(a1 + 40);
  }
  else if ((v1 & 8) != 0)
  {
    return *(void *)(a1 + 16);
  }
  else
  {
    return 0;
  }
}

float RB::Filter::Distance::apply_transform(float *a1, float64x2_t *a2)
{
  float result = *a1 * RB::AffineTransform::scale(a2 + 68);
  *a1 = result;
  return result;
}

uint64_t RB::Filter::Distance::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a3 + 8)) {
    return 0;
  }
  if (*(float *)a1 == *(float *)a3 && *(float *)(a1 + 4) == *(float *)(a3 + 4)) {
    return 4;
  }
  return 2;
}

double RB::Filter::Distance::mix(float32x2_t *a1, uint64_t a2, float32x2_t *a3)
{
  if (a3)
  {
    double result = *(double *)(a2 + 16);
    *a1 = vmla_n_f32(*a1, vsub_f32(*a3, *a1), *(float *)&result);
  }
  return result;
}

int32x2_t RB::Filter::Distance::dod(RB::Filter::Distance *this, float32x2_t *a2, int32x2_t result, int32x4_t a4)
{
  result.i32[0] = *(_DWORD *)this;
  if (*(float *)this > 0.0)
  {
    float32x2_t v4 = a2[1];
    *(int32x2_t *)a4.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v4);
    int8x8_t v5 = (int8x8_t)vsub_f32(*a2, (float32x2_t)vdup_lane_s32(result, 0));
    int8x16_t v6 = (int8x16_t)vcltzq_s32(a4);
    int8x8_t v7 = (int8x8_t)vmvnq_s8(v6).u64[0];
    double result = (int32x2_t)vorr_s8(vand_s8((int8x8_t)vmla_n_f32(v4, (float32x2_t)0x4000000040000000, *(float *)result.i32), *(int8x8_t *)v6.i8), vand_s8((int8x8_t)v4, v7));
    *(int8x8_t *)v6.i8 = vorr_s8(vand_s8(v5, *(int8x8_t *)v6.i8), vand_s8((int8x8_t)*a2, v7));
    v6.u64[1] = (unint64_t)result;
    *(int8x16_t *)a2->f32 = v6;
  }
  return result;
}

void RB::Filter::Distance::render()
{
}

int *RB::Filter::Distance::encode(int *this, RB::Encoder *a2)
{
  unint64_t v3 = this;
  int v4 = *this;
  if (*(float *)this != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xDuLL);
    this = (int *)RB::ProtobufEncoder::encode_fixed32(a2, v4);
  }
  int v5 = v3[1];
  if (*(float *)&v5 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x15uLL);
    this = (int *)RB::ProtobufEncoder::encode_fixed32(a2, v5);
  }
  if (v3[2])
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
    return (int *)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  return this;
}

unint64_t RB::Filter::Distance::decode(uint64_t a1, RB::ProtobufDecoder *this)
{
  unint64_t result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      unint64_t v6 = v5 >> 3;
      if ((v5 >> 3) == 3)
      {
        *(_DWORD *)(a1 + 8) &= ~1u;
        *(_DWORD *)(a1 + 8) |= RB::ProtobufDecoder::BOOL_field(this, v5);
      }
      else if (v6 == 2)
      {
        *(float *)(a1 + 4) = fabsf(RB::ProtobufDecoder::float_field(this, v5));
      }
      else if (v6 == 1)
      {
        *(float *)a1 = fabsf(RB::ProtobufDecoder::float_field(this, v5));
      }
      else
      {
        RB::ProtobufDecoder::skip_field(this, v5);
      }
      unint64_t result = RB::ProtobufDecoder::next_field(this);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::Filter::Distance::print(RB::Filter::Distance *this, std::string *a2)
{
  RB::SexpString::push(a2, "distance");
  if (*(float *)this != 0.0) {
    RB::SexpString::printf(a2, 0, "(max-distance %g)", *(float *)this);
  }
  float v4 = *((float *)this + 1);
  if (v4 != 1.0) {
    RB::SexpString::printf(a2, 0, "(scale %g)", v4);
  }
  if (*((unsigned char *)this + 8)) {
    RB::SexpString::print(a2, 0, "half-float");
  }
  RB::SexpString::pop(a2);
}

void RB::Filter::anonymous namespace'::DistanceRenderer::~DistanceRenderer(RB::Filter::_anonymous_namespace_::DistanceRenderer *this)
{
}

uint64_t RB::Filter::anonymous namespace'::DistanceRenderer::render(uint64_t a1, uint64_t a2, unsigned __int8 a3, uint64_t a4, int32x2_t a5, int32x2_t a6)
{
  RB::Coverage::set_plane((float32x2_t *)&v31, a2, a5);
  *(float32x2_t *)&v32[12] = vcvt_f32_s32(vsub_s32(a6, a5));
  *(float32x2_t *)&v32[20] = vadd_f32(vcvt_f32_s32(a6), (float32x2_t)0x3F0000003F000000);
  *(_OWORD *)&v32[28] = (unint64_t)vadd_f32(vcvt_f32_s32(vadd_s32(*(int32x2_t *)(a1 + 16), a6)), (float32x2_t)0xBF000000BF000000);
  if (*(_DWORD *)(a2 + 136) == 2) {
    int v12 = 131104;
  }
  else {
    int v12 = 32;
  }
  int v13 = *(_DWORD *)(a1 + 36);
  if (v13 == 2)
  {
    _S0 = *(float *)(a1 + 24) / *(float *)(a1 + 28);
    __asm { FCVT            H0, S0 }
    *(_WORD *)&v32[40] = LOWORD(_S0);
    int v14 = 3;
  }
  else if (v13 == 1)
  {
    *(_DWORD *)&v32[36] = *(_DWORD *)(a1 + 32);
    _S1 = 0.5 / *(float *)(a1 + 24);
    __asm { FCVT            H3, S1 }
    *(_WORD *)&v32[40] = _H3;
    _S1 = _S1 * *(float *)&v32[36];
    __asm { FCVT            H1, S1 }
    *(_WORD *)&v32[42] = LOWORD(_S1);
    float v23 = *(float *)&v32[36] * 0.5;
    *(float *)(a1 + 32) = *(float *)&v32[36] * 0.5;
    if (v23 > 0.75) {
      goto LABEL_12;
    }
    int v14 = 2;
  }
  else
  {
    if (v13) {
      goto LABEL_12;
    }
    *(_DWORD *)&v32[36] = 1065353216;
    int v14 = 1;
  }
  *(_DWORD *)(a1 + 36) = v14;
LABEL_12:
  double v24 = (const char *)(v12 | (v13 << 20));
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x3C, 4uLL, 0, &v33);
  float64x2_t v25 = v33;
  if (v33)
  {
    __n128 v26 = (_OWORD *)(*((void *)v33 + 7) + v34.i64[0]);
    long long v27 = v31;
    long long v28 = *(_OWORD *)v32;
    long long v29 = *(_OWORD *)&v32[16];
    *(_OWORD *)((char *)v26 + 44) = *(_OWORD *)&v32[28];
    v26[1] = v28;
    void v26[2] = v29;
    *__n128 v26 = v27;
  }
  else
  {
    long long v33 = 0;
    int64x2_t v34 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v25);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v34);
  *(_DWORD *)(a2 + 232) = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)a2, a4);
  *(unsigned char *)(a2 + 236) = 0;
  RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, v24, 4, ***(void ***)a2 + 80, 0, 1uLL, (int32x2_t)0xC0000001C0000001, (int32x2_t)0x7FFFFFFF7FFFFFFFLL);
  uint64_t result = a3 & (*(_DWORD *)(a1 + 36) == 3);
  *(_DWORD *)(a2 + 232) = 0;
  *(unsigned char *)(a2 + 236) = 0;
  return result;
}

void sub_2141A10B0(_Unwind_Exception *a1)
{
  *(_DWORD *)(v1 + 232) = 0;
  *(unsigned char *)(v1 + 236) = 0;
  _Unwind_Resume(a1);
}

uint64_t RB::Coverage::Primitive::set_rendering_mode(uint64_t result, char a2)
{
  *(unsigned char *)(result + 45) = a2;
  if ((a2 & 0xFE) == 2) {
    *(unsigned char *)(result + 46) &= ~4u;
  }
  return result;
}

void *RB::Coverage::Primitive::encode(float32x4_t *this, RB::Encoder *a2)
{
  unint64_t v4 = this[2].u8[12];
  if (v4 == 2
    || (RB::ProtobufEncoder::encode_varint(a2, 8uLL),
        uint64_t result = RB::ProtobufEncoder::encode_varint(a2, v4),
        int v6 = this[2].u8[12],
        (v6 - 2) < 7))
  {
    RB::ProtobufEncoder::float4_field(a2, 2, *this);
    v7.i8[0] = this[2].i8[12];
    v8.i32[0] = 4;
    float32x4_t v9 = (float32x4_t)vbslq_s8(vdupq_lane_s8((int8x8_t)*(_OWORD *)&vceqq_s8(v7, v8), 0), (int8x16_t)vmulq_f32(this[1], (float32x4_t)vdupq_n_s32(0x3F48C8C9u)), (int8x16_t)this[1]);
    if ((vminvq_u32((uint32x4_t)vceqq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 0))) & 0x80000000) != 0)
    {
      if (v9.f32[0] != 0.0)
      {
        int v16 = v9.i32[0];
        RB::ProtobufEncoder::encode_varint(a2, 0x1DuLL);
        RB::ProtobufEncoder::encode_fixed32(a2, v16);
      }
    }
    else
    {
      RB::ProtobufEncoder::float4_field(a2, 4, v9);
    }
    int v10 = this[2].i32[0];
    if (*(float *)&v10 != 1.0)
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x2DuLL);
      RB::ProtobufEncoder::encode_fixed32(a2, v10);
    }
    int v11 = this[2].i32[1];
    if (*(float *)&v11 != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x35uLL);
      RB::ProtobufEncoder::encode_fixed32(a2, v11);
    }
    if ((this[2].i8[14] & 4) != 0)
    {
      int v13 = this[2].i32[2];
      RB::ProtobufEncoder::encode_varint(a2, 0x3DuLL);
    }
    else
    {
      float v12 = this[2].f32[2];
      if (v12 == 0.0)
      {
LABEL_16:
        unint64_t v14 = this[2].u8[13];
        RB::ProtobufEncoder::encode_varint(a2, 0x40uLL);
        uint64_t result = RB::ProtobufEncoder::encode_varint(a2, v14);
        __int8 v15 = this[2].i8[14];
        if (v15)
        {
          RB::ProtobufEncoder::encode_varint(a2, 0x48uLL);
          uint64_t result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
          __int8 v15 = this[2].i8[14];
        }
        if ((v15 & 2) != 0)
        {
          RB::ProtobufEncoder::encode_varint(a2, 0x50uLL);
          return RB::ProtobufEncoder::encode_varint(a2, 1uLL);
        }
        return result;
      }
      RB::ProtobufEncoder::encode_varint(a2, 0x5DuLL);
      int v13 = LODWORD(v12);
    }
    RB::ProtobufEncoder::encode_fixed32(a2, v13);
    goto LABEL_16;
  }
  if ((v6 - 9) < 3) {
    abort();
  }
  return result;
}

unint64_t RB::Coverage::Primitive::decode(float32x4_t *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          unint64_t v6 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, v5);
          if (v6 <= 8) {
            this[2].i8[12] = v6;
          }
          break;
        case 2u:
          *(__n128 *)this = RB::ProtobufDecoder::float4_field(a2, v5);
          break;
        case 3u:
          *(float *)v7.i32 = RB::ProtobufDecoder::float_field(a2, v5);
          __n128 v8 = (__n128)vdupq_lane_s32(v7, 0);
          goto LABEL_9;
        case 4u:
          __n128 v8 = RB::ProtobufDecoder::float4_field(a2, v5);
LABEL_9:
          this[1] = (float32x4_t)v8;
          break;
        case 5u:
          this[2].f32[0] = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        case 6u:
          this[2].f32[1] = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        case 7u:
          this[2].i8[14] |= 4u;
          goto LABEL_13;
        case 8u:
          unint64_t v9 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, v5);
          if (v9 <= 3) {
            this[2].i8[13] = v9;
          }
          break;
        case 9u:
          __int8 v10 = this[2].i8[14] & 0xFE | RB::ProtobufDecoder::BOOL_field(a2, v5);
          goto LABEL_21;
        case 0xAu:
          if (RB::ProtobufDecoder::BOOL_field(a2, v5)) {
            char v11 = 2;
          }
          else {
            char v11 = 0;
          }
          __int8 v10 = this[2].i8[14] & 0xFD | v11;
LABEL_21:
          this[2].i8[14] = v10;
          break;
        case 0xBu:
LABEL_13:
          this[2].f32[2] = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        default:
          RB::ProtobufDecoder::skip_field(a2, v5);
          break;
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  int v12 = this[2].u8[12];
  if (v12 == 4) {
    this[1] = vmulq_f32(this[1], (float32x4_t)vdupq_n_s32(0x3FA33333u));
  }
  __int8 v13 = this[2].i8[14];
  if (v13)
  {
    if (v12)
    {
      if (v12 != 1) {
        return result;
      }
      char v14 = 0;
    }
    else
    {
      char v14 = 1;
    }
    this[2].i8[12] = v14;
    this[2].i8[14] = v13 & 0xFE;
  }
  return result;
}

void RB::Coverage::Primitive::attributes(float32x4_t *this, RB::XML::Element *a2, double a3, double a4, int8x16_t a5)
{
  switch(this[2].i8[12])
  {
    case 0:
    case 1:
      goto LABEL_23;
    case 2:
      goto LABEL_13;
    case 3:
      float32x4_t v11 = this[1];
      int8x16_t v12 = vmvnq_s8((int8x16_t)vceqzq_f32(v11));
      v12.i32[0] = vmaxvq_u32((uint32x4_t)v12);
      if (v12.i32[0] < 0)
      {
        v12.i8[0] = this[2].i8[12];
        a5.i32[0] = 4;
        float32x4_t v13 = (float32x4_t)vbslq_s8(vdupq_lane_s8((int8x8_t)*(_OWORD *)&vceqq_s8(v12, a5), 0), (int8x16_t)vmulq_f32(v11, (float32x4_t)vdupq_n_s32(0x3F48C8C9u)), (int8x16_t)v11);
        if ((vminvq_u32((uint32x4_t)vceqq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 0))) & 0x80000000) == 0) {
          RB::XML::Element::set<RB::XML::Value::Vec4>();
        }
        if (this[2].f32[0] == 1.0) {
          RB::XML::Element::set<RB::XML::Value::Float>();
        }
        __asm { FMOV            V2.2S, #1.0 }
        RB::XML::Element::set<RB::XML::Value::Vec2>();
      }
LABEL_13:
      __asm { FMOV            V2.2S, #1.0 }
      break;
    case 4:
      RB::XML::Element::set<RB::XML::Value::ConstantString>();
    case 5:
      if (this[2].f32[0] == 1.0) {
        RB::XML::Element::set<RB::XML::Value::Vec2>();
      }
      __asm { FMOV            V3.2S, #1.0 }
      break;
    case 6:
    case 7:
    case 8:
      __asm { FMOV            V2.2S, #1.0 }
      RB::XML::Element::set<RB::XML::Value::Vec4>();
    case 9:
    case 0xA:
    case 0xB:
      abort();
    default:
      if (this[2].f32[1] > 0.0) {
        RB::XML::Element::set<RB::XML::Value::Float>();
      }
      if ((this[2].i8[14] & 4) != 0) {
        RB::XML::Element::set<RB::XML::Value::Float>();
      }
      RB::XML::Element::set_rendering_mode((uint64_t)a2, this[2].u8[13]);
      if (this[2].i8[14]) {
        RB::XML::Element::set<RB::XML::Value::Bool>();
      }
      if ((this[2].i8[14] & 2) != 0) {
LABEL_23:
      }
        RB::XML::Element::set<RB::XML::Value::Bool>();
      return;
  }
  RB::XML::Element::set<RB::XML::Value::Vec4>();
}

void RB::XML::Element::set<RB::XML::Value::Vec4>()
{
}

BOOL RB::Coverage::Primitive::append_blur(RB::Coverage::Primitive *this, float a2, float64x2_t *a3, float64x2_t *a4)
{
    return 0;
  char v8 = *((unsigned char *)this + 44);
  long long v9 = *((_OWORD *)this + 1);
  BOOL result = 1;
  switch(v8)
  {
    case 0:
    case 1:
      return result;
    case 2:
    case 3:
    case 4:
    case 6:
    case 7:
    case 8:
      return 0;
    case 5:
      if (*((float *)this + 8) != 1.0) {
        return 0;
      }
      float v11 = *(float *)&v9 + *(float *)&v9;
      float v20 = *((float *)this + 9);
      if (v20 > 0.0 && v11 >= v20) {
        float v11 = *((float *)this + 9);
      }
LABEL_7:
      if (a4 == a3) {
        goto LABEL_13;
      }
      long long v21 = *((_OWORD *)this + 1);
      float64x2_t v12 = a3[1];
      float64x2_t v23 = *a3;
      float64x2_t v24 = v12;
      float64x2_t v25 = a3[2];
      if (RB::AffineTransform::invert((RB::AffineTransform *)&v23)) {
        float32x4_t v13 = &v23;
      }
      else {
        float32x4_t v13 = a3;
      }
      float64x2_t v14 = v13[1];
      float64x2_t v15 = v13[2];
      float64x2_t v23 = *v13;
      float64x2_t v24 = v14;
      float64x2_t v25 = v15;
      v16.f64[0] = RB::operator*(a4, &v23);
      v22[0] = v16;
      v22[1] = v17;
      v22[2] = v18;
      BOOL result = RB::AffineTransform::is_uniform(v22);
      if (!result) {
        return result;
      }
      a2 = RB::AffineTransform::scale(v22) * a2;
      long long v9 = v21;
LABEL_13:
      char v19 = *((unsigned char *)this + 46);
      if ((v19 & 4) != 0) {
        a2 = sqrtf((float)(a2 * a2) + (float)(*((float *)this + 10) * *((float *)this + 10)));
      }
      if (v11 < (float)(a2 * 2.8)) {
        return 0;
      }
      *((unsigned char *)this + 44) = v8;
      *((_OWORD *)this + 1) = v9;
      *((float *)this + 10) = a2;
      *((unsigned char *)this + 46) = v19 | 4;
      BOOL result = 1;
      break;
    case 9:
    case 10:
    case 11:
      abort();
    default:
      float v11 = 0.0;
      goto LABEL_7;
  }
  return result;
}

uint64_t RB::Coverage::anonymous namespace'::exact_blur(RB::Coverage::_anonymous_namespace_ *this)
{
  {
    unsigned int v3 = (unsigned __int16)RB::debug_BOOL((RB *)"RB_EXACT_BLUR", v2);
    if (v3 <= 0x100) {
      LOBYTE(v3) = 0;
    }
  }
}

void sub_2141A1D9C(_Unwind_Exception *a1)
{
}

uint64_t RB::Coverage::Primitive::make_shadow(RB::Coverage::Primitive *this, float64x2_t *a2, float a3, float *a4, int a5, RB::Coverage::Primitive *a6)
{
    return 0;
  float v13 = 0.0;
  if (a3 < 0.0) {
    a3 = 0.0;
  }
  float v14 = RB::AffineTransform::scale(a2) * a3;
  switch(*((unsigned char *)this + 44))
  {
    case 0:
    case 1:
      long long v19 = *(_OWORD *)this;
      long long v20 = *((_OWORD *)this + 1);
      *(_OWORD *)((char *)a6 + 31) = *(_OWORD *)((char *)this + 31);
      *(_OWORD *)a6 = v19;
      *((_OWORD *)a6 + 1) = v20;
      goto LABEL_16;
    case 2:
      if (*((float *)this + 9) > 0.0) {
        return 0;
      }
      long long v22 = *(_OWORD *)this;
      long long v23 = *((_OWORD *)this + 1);
      *(_OWORD *)((char *)a6 + 31) = *(_OWORD *)((char *)this + 31);
      *(_OWORD *)a6 = v22;
      *((_OWORD *)a6 + 1) = v23;
      *((unsigned char *)a6 + 44) = 3;
      *(void *)&long long v22 = *((void *)this + 1);
      float v13 = fminf(*(float *)&v22, *((float *)&v22 + 1));
      *(float *)&long long v22 = sqrtf((float)(v14 + v14) * (float)(v14 + v14));
      float32x4_t v17 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v22, 0);
      goto LABEL_9;
    case 3:
    case 4:
      if (*((float *)this + 8) != 1.0 || *((float *)this + 9) > 0.0) {
        return 0;
      }
      long long v21 = *(_OWORD *)this;
      long long v16 = *((_OWORD *)this + 1);
      *(_OWORD *)((char *)a6 + 31) = *(_OWORD *)((char *)this + 31);
      *(_OWORD *)a6 = v21;
      *((_OWORD *)a6 + 1) = v16;
      float v13 = fminf(COERCE_FLOAT(*((void *)this + 1)), COERCE_FLOAT(HIDWORD(*((void *)this + 1))));
LABEL_8:
      *(float *)&long long v16 = (float)(v14 + v14) * (float)(v14 + v14);
      float32x4_t v17 = vsqrtq_f32(vmlaq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v16, 0), *((float32x4_t *)a6 + 1), *((float32x4_t *)a6 + 1)));
LABEL_9:
      *((float32x4_t *)a6 + 1) = v17;
      break;
    case 5:
      if (*((float *)this + 8) != 1.0) {
        return 0;
      }
      long long v24 = *(_OWORD *)this;
      long long v25 = *((_OWORD *)this + 1);
      *(_OWORD *)((char *)a6 + 31) = *(_OWORD *)((char *)this + 31);
      *(_OWORD *)a6 = v24;
      *((_OWORD *)a6 + 1) = v25;
      float v26 = *((float *)this + 9);
      if ((float)(*((float *)this + 4) + *((float *)this + 4)) >= v26) {
        float v27 = *((float *)this + 9);
      }
      else {
        float v27 = *((float *)this + 4) + *((float *)this + 4);
      }
      if (v26 > 0.0) {
        float v13 = v27;
      }
      else {
        float v13 = *((float *)this + 4) + *((float *)this + 4);
      }
      break;
    case 6:
    case 7:
    case 8:
      long long v15 = *(_OWORD *)this;
      long long v16 = *((_OWORD *)this + 1);
      *(_OWORD *)((char *)a6 + 31) = *(_OWORD *)((char *)this + 31);
      *(_OWORD *)a6 = v15;
      *((_OWORD *)a6 + 1) = v16;
      float v13 = *((float *)this + 9);
      goto LABEL_8;
    case 9:
    case 0xA:
    case 0xB:
      abort();
    default:
      break;
  }
  if ((*((unsigned char *)this + 46) & 4) != 0)
  {
    float v14 = sqrtf((float)(v14 * v14) + (float)(*((float *)a6 + 10) * *((float *)a6 + 10)));
    *((float *)a6 + 10) = v14;
  }
  else
  {
    *((float *)a6 + 10) = v14;
    *((unsigned char *)a6 + 46) |= 4u;
  }
  float v18 = v14 + v14;
  if (v13 < v18) {
    *a4 = (float)(*a4 * v13) / v18;
  }
LABEL_16:
  if (a5)
  {
    if (*((unsigned char *)a6 + 44))
    {
      if (*((unsigned char *)a6 + 44) == 1) {
        *((unsigned char *)a6 + 44) = 0;
      }
      else {
        *((unsigned char *)a6 + 46) ^= 1u;
      }
    }
    else
    {
      *((unsigned char *)a6 + 44) = 1;
    }
  }
  *((unsigned char *)a6 + 46) |= 2u;
  return 1;
}

uint64_t RB::Coverage::Primitive::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned __int8 *)(a1 + 45) != *(unsigned __int8 *)(a3 + 45)
    || ((*(unsigned char *)(a3 + 46) ^ *(unsigned char *)(a1 + 46)) & 3) != 0)
  {
    return 0;
  }
  unsigned int v4 = *(unsigned __int8 *)(a1 + 44);
  unsigned int v5 = *(unsigned __int8 *)(a3 + 44);
  if (v4 != v5)
  {
    int v7 = v5 >= v4 ? *(unsigned __int8 *)(a1 + 44) : *(unsigned __int8 *)(a3 + 44);
    if (v7 != 2) {
      return 0;
    }
    if (v4 <= v5) {
      unsigned int v4 = *(unsigned __int8 *)(a3 + 44);
    }
    if (v4 - 3 > 1) {
      return 0;
    }
  }
  uint32x2_t v6 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(*(float32x2_t *)(a1 + 8), *(float32x2_t *)(a3 + 8)), (int8x8_t)vceq_f32(*(float32x2_t *)a1, *(float32x2_t *)a3));
  if ((vpmin_u32(v6, v6).u32[0] & 0x80000000) == 0 || *(float *)(a1 + 32) != *(float *)(a3 + 32)) {
    return 1;
  }
  if ((vminvq_u32((uint32x4_t)vceqq_f32(*(float32x4_t *)(a1 + 16), *(float32x4_t *)(a3 + 16))) & 0x80000000) != 0
    && *(float *)(a1 + 36) == *(float *)(a3 + 36)
    && *(float *)(a1 + 40) == *(float *)(a3 + 40))
  {
    return 4;
  }
  return 2;
}

void RB::Coverage::Primitive::mix(uint64_t a1, uint64_t a2, uint64_t a3, double a4, int32x4_t a5)
{
  a5.i32[0] = *(_DWORD *)(a1 + 32);
  float v8 = *(float *)(a3 + 32);
  float v9 = *(float *)(a2 + 16);
  float v27 = *(float *)a5.i32 + (float)((float)(v8 - *(float *)a5.i32) * v9);
  float32x2_t v10 = *(float32x2_t *)(a1 + 8);
  if (*(float *)a5.i32 == v8)
  {
    *(float32x2_t *)a5.i8 = vadd_f32(v10, *(float32x2_t *)a1);
    *(float32x2_t *)a5.i8 = vmla_n_f32(*(float32x2_t *)a5.i8, vadd_f32(vsub_f32(*(float32x2_t *)a3, *(float32x2_t *)a5.i8), *(float32x2_t *)(a3 + 8)), v9);
    double v11 = RB::Rect::from_bounds(vmla_n_f32(*(float32x2_t *)a1, vsub_f32(*(float32x2_t *)a3, *(float32x2_t *)a1), v9), a5);
  }
  else
  {
    __asm { FMOV            V5.2S, #1.0 }
    float32x2_t v18 = (float32x2_t)__PAIR64__(_D5.u32[1], a5.u32[0]);
    *(float32x2_t *)a5.i8 = vmul_f32(*(float32x2_t *)a1, (float32x2_t)__PAIR64__(_D5.u32[1], a5.u32[0]));
    _D5.i32[0] = *(_DWORD *)(a3 + 32);
    float32x2_t v19 = vmul_f32(*(float32x2_t *)a3, _D5);
    float32x2_t v20 = vmla_n_f32(*(float32x2_t *)a5.i8, vsub_f32(v19, *(float32x2_t *)a5.i8), v9);
    *(float32x2_t *)a5.i8 = vmla_f32(*(float32x2_t *)a5.i8, v18, v10);
    *(float32x2_t *)a5.i8 = vmla_n_f32(*(float32x2_t *)a5.i8, vmla_f32(vsub_f32(v19, *(float32x2_t *)a5.i8), _D5, *(float32x2_t *)(a3 + 8)), v9);
    double v21 = RB::Rect::from_bounds(v20, a5);
    float32x2_t v22 = vrecpe_f32((float32x2_t)LODWORD(v27));
    float32x2_t v23 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v27), v22), v22);
    v24.i32[0] = vmul_f32(v23, vrecps_f32((float32x2_t)LODWORD(v27), v23)).u32[0];
    v24.i32[1] = 1.0;
    double v11 = COERCE_DOUBLE(vmul_f32(v24, *(float32x2_t *)&v21));
    float32x2_t v12 = vmul_f32(v24, v25);
  }
  *(double *)a1 = v11;
  *(float32x2_t *)(a1 + 8) = v12;
  *(float *)(a1 + 32) = v27;
  *(float32x4_t *)(a1 + 16) = vmlaq_n_f32(*(float32x4_t *)(a1 + 16), vsubq_f32(*(float32x4_t *)(a3 + 16), *(float32x4_t *)(a1 + 16)), COERCE_FLOAT(*(_OWORD *)(a2 + 16)));
  *(float32x2_t *)(a1 + 36) = vmla_n_f32(*(float32x2_t *)(a1 + 36), vsub_f32(*(float32x2_t *)(a3 + 36), *(float32x2_t *)(a1 + 36)), COERCE_FLOAT(*(void *)(a2 + 16)));
  unsigned int v26 = *(unsigned __int8 *)(a1 + 44);
  if (v26 <= *(unsigned __int8 *)(a3 + 44)) {
    LOBYTE(v26) = *(unsigned char *)(a3 + 44);
  }
  *(unsigned char *)(a1 + 44) = v26;
}

float RB::Coverage::set_plane(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  float result = *(float *)(a2 + 68);
  *(float *)(a1 + 24) = result;
  return result;
}

void RB::Coverage::Primitive::make_image_mask(float32x2_t *this@<X0>, RB::CGContext *a2@<X1>, CGImageRef *a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  CGRect ClipBoundingBox = CGContextGetClipBoundingBox((CGContextRef)*(void *)a2);
  CGFloat y = ClipBoundingBox.origin.y;
  CGFloat height = ClipBoundingBox.size.height;
  *(float32x2_t *)&long long v37 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.origin);
  *((float32x2_t *)&v37 + 1) = vcvt_f32_f64((float64x2_t)ClipBoundingBox.size);
  *(_OWORD *)c = xmmword_2142181C0;
  long long v39 = xmmword_2142181D0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  *(float32x2_t *)&double v8 = RB::Coverage::Primitive::bounds(this, (float64x2_t *)c, (int8x16_t)xmmword_2142181C0, (int32x4_t)xmmword_2142181D0, (int8x16_t)ClipBoundingBox.size, *(int32x4_t *)&ClipBoundingBox.size.height);
  RB::Rect::intersect((float32x2_t *)&v37, v8, v9, v10, v11, v12, v13);
  uint32x2_t v14 = (uint32x2_t)vclez_f32(*(float32x2_t *)((char *)&v37 + 8));
  if ((vpmax_u32(v14, v14).u32[0] & 0x80000000) != 0) {
    goto LABEL_11;
  }
  float v15 = 0.0;
  if ((this[5].i8[6] & 4) != 0)
  {
    if (this[5].f32[0] >= 0.0) {
      float v15 = this[5].f32[0];
    }
    else {
      float v15 = 0.0;
    }
  }
  float v33 = fminf(3.5 / v15, 1.0);
  RB::CGContext::begin_bitmap((int8x8_t *)a2, (float32x2_t *)&v37, 1, 0, (int8x8_t)vmul_n_f32(*(float32x2_t *)((char *)a2 + 16), v33), 1u, (CGContext **)&cf);
  if (!cf)
  {
LABEL_11:
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  else
  {
    __asm { FMOV            V0.2S, #1.0 }
    RB::CGContext::CGContext(c, cf, *((unsigned __int8 *)a2 + 8), _D0);
    int v21 = rb_clip_mode(this[5].u8[5]);
    if (v42 != v21) {
      RB::CGContext::set_aliasing_mode_slow((uint64_t)c, v21);
    }
    RB::Coverage::Primitive::add_path(this, c, v22, v23, v24, v25, v26, v27);
    float v29 = this[4].f32[1];
    if (v29 == 0.0)
    {
      CGContextFillPath(c[0]);
    }
    else
    {
      CGContextStrokePath(c[0]);
    }
    char v30 = 2 * (this[5].i8[6] & 1);
    CFTypeRef v35 = 0;
    RB::CGContext::apply_blur((uint64_t)c, v30, &v35, v33 * v15);
    if (v33 < 0.9)
    {
      int32x2_t v31 = (int32x2_t)RB::CGContext::begin_bitmap((int8x8_t *)a2, (float32x2_t *)&v37, 1, 0, 0, 0, &v34);
      if (v34)
      {
        *(float *)v31.i32 = 1.0 / v33;
        RB::CGContext::apply_scale(c, v34, COERCE_DOUBLE(vdup_lane_s32(v31, 0)));
        __n128 v32 = (CGContext *)cf;
        CFTypeRef cf = v34;
        int64x2_t v34 = v32;
        if (v32) {
          CFRelease(v32);
        }
      }
    }
    *a3 = CGBitmapContextCreateImage((CGContextRef)cf);
    *(_OWORD *)(a3 + 1) = v37;
    if (v35) {
      CFRelease(v35);
    }
    RB::CGContext::~CGContext((RB::CGContext *)c);
    if (cf) {
      CFRelease(cf);
    }
  }
}

void sub_2141A24D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf, CFTypeRef a13, CFTypeRef a14, uint64_t a15, uint64_t a16, char a17)
{
  if (cf) {
    CFRelease(cf);
  }
  if (a13) {
    CFRelease(a13);
  }
  RB::CGContext::~CGContext((RB::CGContext *)&a17);
  if (a14) {
    CFRelease(a14);
  }
  _Unwind_Resume(a1);
}

void RB::Coverage::anonymous namespace'::set_stroke(CGContextRef *this, RB::CGContext *a2, CGFloat a3)
{
  CGContextSetLineWidth(*this, a3);
  CGContextSetLineJoin(*this, kCGLineJoinMiter);
  CGContextSetLineDash(*this, 0.0, 0, 0);
  unsigned int v4 = *this;
  CGContextSetMiterLimit(v4, 10.0);
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Vec4,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2141A2630(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Vec4 *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Vec4>,std::allocator<RB::XML::Value::Vec4>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Vec4 *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Vec4>,std::allocator<RB::XML::Value::Vec4>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

float64x2_t CG::stroker::stroker(uint64_t a1, float64x2_t *a2, int a3, int a4, uint64_t a5, double a6, double a7, double a8)
{
  *(void *)a1 = &unk_26C4E73B0;
  *(double *)(a1 + 40) = a7;
  *(_DWORD *)(a1 + 48) = a3;
  *(_DWORD *)(a1 + 52) = a4;
  *(double *)(a1 + 56) = a8;
  *(double *)(a1 + 64) = a6;
  *(void *)(a1 + 80) = a5;
  *(_DWORD *)(a1 + 88) = 0;
  double v8 = a6 * 0.1;
  if (a6 * 0.1 < 0.001) {
    double v8 = 0.001;
  }
  if (a6 <= 0.0) {
    double v9 = 0.1;
  }
  else {
    double v9 = v8;
  }
  double v10 = a7 * 0.5;
  float64x2_t v11 = a2[1];
  float64x2_t v12 = vmulq_n_f64(*a2, v10);
  *(void *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(double *)(a1 + 72) = v9;
  *(float64x2_t *)(a1 + 8) = v12;
  float64x2_t result = vmulq_n_f64(v11, v10);
  *(float64x2_t *)(a1 + 24) = result;
  return result;
}

__n128 CG::stroker::moveto(__n128 *this, __n128 a2)
{
  if (this[5].n128_u32[2] - 3 <= 1)
  {
    __n128 v4 = a2;
    CG::stroker::end_contour((uint64_t)this);
    a2 = v4;
  }
  this[5].n128_u32[2] = 2;
  this[12] = a2;
  __n128 result = this[12];
  this[9] = result;
  this[6] = result;
  return result;
}

uint64_t CG::stroker::end_contour(uint64_t this)
{
  uint64_t v1 = this;
  int v2 = *(_DWORD *)(this + 88);
  if (v2 == 4)
  {
    CG::stroker::add_cap(this, (float64x2_t *)(this + 144), this + 176, 1);
    CG::stroker::unroll_path(v1);
    float64x2_t v4 = vnegq_f64(*(float64x2_t *)(v1 + 128));
    CG::stroker::add_cap(v1, (float64x2_t *)(v1 + 96), (uint64_t)&v4, 0);
    unsigned int v3 = *(uint64_t (**)(void))(**(void **)(v1 + 80) + 8);
    return v3();
  }
  else if (v2 == 3)
  {
    float64x2_t v4 = vsubq_f64(*(float64x2_t *)(this + 192), *(float64x2_t *)(this + 96));
    return CG::stroker::add_point(this, (float64x2_t *)(this + 96), (uint64_t)&v4);
  }
  return this;
}

__n128 CG::stroker::lineto(__n128 *a1, __n128 result)
{
  __int32 v2 = a1[5].n128_i32[2];
  if (v2)
  {
    if (v2 == 1) {
      a1[5].n128_u32[2] = 2;
    }
    a1[12] = result;
    unsigned int v3 = a1 + 12;
    float64x2_t v4 = a1 + 9;
    if (CG::stroker::add_line_segment((CG::stroker *)a1, (float64x2_t *)&a1[9], (const Point *)&a1[12]))
    {
      __n128 result = *v3;
      __n128 *v4 = *v3;
    }
  }
  return result;
}

BOOL CG::stroker::add_line_segment(CG::stroker *this, float64x2_t *a2, const Point *a3)
{
  float64x2_t v4 = vsubq_f64(*(float64x2_t *)&a3->v, *a2);
  float64x2_t v27 = v4;
  double v5 = vaddvq_f64(vmulq_f64(v4, v4));
  if (v5 <= 0.00000001)
  {
    if (*((_DWORD *)this + 22) == 2) {
      *((_DWORD *)this + 22) = 3;
    }
  }
  else
  {
    float64x2_t v8 = *(float64x2_t *)((char *)this + 8);
    float64x2_t v9 = *(float64x2_t *)((char *)this + 24);
    float64x2_t v10 = vmulq_f64((float64x2_t)vextq_s8((int8x16_t)v9, (int8x16_t)v9, 8uLL), v8);
    if (vsubq_f64(v10, (float64x2_t)vdupq_laneq_s64((int64x2_t)v10, 1)).f64[0] >= 0.0)
    {
      v13.f64[0] = *((float64_t *)this + 3);
      v13.f64[1] = *((float64_t *)this + 2);
      float64x2_t v12 = vnegq_f64(v13);
      float64x2_t v11 = (float64x2_t)vextq_s8((int8x16_t)v9, (int8x16_t)v8, 8uLL);
    }
    else
    {
      float64x2_t v11 = vnegq_f64((float64x2_t)vextq_s8((int8x16_t)v9, (int8x16_t)v8, 8uLL));
      v12.f64[0] = *((float64_t *)this + 3);
      v12.f64[1] = *((float64_t *)this + 2);
    }
    float64x2_t v14 = vmlaq_f64(vmulq_f64((float64x2_t)vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL), v12), v4, v11);
    if (v14.f64[0] != 0.0 || v14.f64[1] != 0.0) {
      float64x2_t v14 = vdivq_f64(v14, (float64x2_t)vdupq_lane_s64(COERCE__INT64(sqrt(vaddvq_f64(vmulq_f64(v14, v14)))), 0));
    }
    float64x2_t v26 = v14;
    float64x2_t v15 = vmlaq_n_f64(vnegq_f64(vmulq_laneq_f64(v8, v14, 1)), v9, v14.f64[0]);
    long long v16 = (float64x2_t *)((char *)this + 160);
    float64x2_t v23 = v15;
    if (*((_DWORD *)this + 22) == 4)
    {
      CG::stroker::add_join(this, a2, v27.f64, v26.f64);
      *long long v16 = v27;
      *((float64x2_t *)this + 11) = v26;
    }
    else
    {
      *((_DWORD *)this + 22) = 4;
      float64x2_t v18 = v26;
      float64x2_t v17 = v27;
      *long long v16 = v27;
      *((float64x2_t *)this + 11) = v18;
      *((float64x2_t *)this + 7) = v17;
      *((float64x2_t *)this + 8) = v18;
      (*(void (**)(void, __n128))(**((void **)this + 10) + 16))(*((void *)this + 10), (__n128)vaddq_f64(*a2, v15));
    }
    double v19 = a2->f64[1] - v23.f64[1];
    *(double *)&v24[0].v = a2->f64[0] - v23.f64[0];
    double v25 = v19;
    CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, v24);
    v20.n128_f64[0] = *(double *)&a3->v + v23.f64[0];
    v20.n128_f64[1] = *(double *)&a3[2].v + v23.f64[1];
    (*(void (**)(void, __n128))(**((void **)this + 10) + 24))(*((void *)this + 10), v20);
    double v21 = *(double *)&a3[2].v - v23.f64[1];
    *((double *)this + 26) = *(double *)&a3->v - v23.f64[0];
    *((double *)this + 27) = v21;
  }
  return v5 > 0.00000001;
}

float64x2_t CG::stroker::quadto(Point *a1, float64x2_t result, float64x2_t a3)
{
  Point v3 = a1[22];
  if (v3)
  {
    if (v3 == 1) {
      a1[22] = (Point)2;
    }
    *(float64x2_t *)&a1[48].v = a3;
    double v5 = (float64x2_t *)&a1[48];
    float64x2_t v6 = (float64x2_t)vdupq_n_s64(0x3FD5555555555555uLL);
    float64x2_t v7 = vmlaq_f64(result, v6, vsubq_f64(*(float64x2_t *)&a1[36].v, result));
    *(float64x2_t *)&v9[0].v = vmlaq_f64(result, v6, vsubq_f64(a3, result));
    *(float64x2_t *)&v10[0].v = v7;
    CG::Cubic::Cubic((CG::Cubic *)v8, a1 + 36, v10, v9, a1 + 48);
    if (CG::stroker::add_cubic_segment((CG::stroker *)a1, v8))
    {
      __n128 result = *v5;
      *(float64x2_t *)&a1[36].v = *v5;
    }
  }
  return result;
}

uint64_t CG::stroker::add_cubic_segment(CG::stroker *this, float64x2_t *a2)
{
  double v4 = a2[1].f64[0];
  double v5 = a2[1].f64[1];
  if ((v4 - a2->f64[0]) * (v4 - a2->f64[0]) + (v5 - a2->f64[1]) * (v5 - a2->f64[1]) <= 0.00000001
    && (double v6 = a2[2].f64[0], v7 = a2[2].f64[1], (v6 - v4) * (v6 - v4) + (v7 - v5) * (v7 - v5) <= 0.00000001)
    && (a2[3].f64[0] - v6) * (a2[3].f64[0] - v6) + (a2[3].f64[1] - v7) * (a2[3].f64[1] - v7) <= 0.00000001)
  {
    if (*((_DWORD *)this + 22) == 2)
    {
      uint64_t result = 0;
      *((_DWORD *)this + 22) = 3;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v8.f64[0] = CG::Cubic::derivative((CG::Cubic *)a2, 0.0);
    *(float64_t *)&long long v40 = v8.f64[0];
    *((float64_t *)&v40 + 1) = v9;
    float64x2_t v10 = *(float64x2_t *)((char *)this + 8);
    float64x2_t v11 = *(float64x2_t *)((char *)this + 24);
    float64x2_t v12 = vmulq_f64((float64x2_t)vextq_s8((int8x16_t)v11, (int8x16_t)v11, 8uLL), v10);
    if (vsubq_f64(v12, (float64x2_t)vdupq_laneq_s64((int64x2_t)v12, 1)).f64[0] >= 0.0)
    {
      v15.f64[0] = *((float64_t *)this + 3);
      v15.f64[1] = *((float64_t *)this + 2);
      float64x2_t v14 = vnegq_f64(v15);
      float64x2_t v13 = (float64x2_t)vextq_s8((int8x16_t)v11, (int8x16_t)v10, 8uLL);
    }
    else
    {
      float64x2_t v13 = vnegq_f64((float64x2_t)vextq_s8((int8x16_t)v11, (int8x16_t)v10, 8uLL));
      v14.f64[0] = *((float64_t *)this + 3);
      v14.f64[1] = *((float64_t *)this + 2);
    }
    v8.f64[1] = v9;
    float64x2_t v16 = vmlaq_f64(vmulq_f64((float64x2_t)vextq_s8((int8x16_t)v8, (int8x16_t)v8, 8uLL), v14), v8, v13);
    if (v16.f64[0] != 0.0 || v16.f64[1] != 0.0) {
      float64x2_t v16 = vdivq_f64(v16, (float64x2_t)vdupq_lane_s64(COERCE__INT64(sqrt(vaddvq_f64(vmulq_f64(v16, v16)))), 0));
    }
    float64x2_t v39 = v16;
    if (*((_DWORD *)this + 22) == 4)
    {
      v37[0] = *a2;
      CG::stroker::add_join(this, v37, (double *)&v40, v39.f64);
    }
    else
    {
      *((_DWORD *)this + 22) = 4;
      float64x2_t v17 = v39;
      *((_OWORD *)this + 7) = v40;
      *((float64x2_t *)this + 8) = v17;
      (*(void (**)(void, __n128))(**((void **)this + 10) + 16))(*((void *)this + 10), (__n128)vaddq_f64(vmlaq_n_f64(vnegq_f64(vmulq_laneq_f64(v10, v16, 1)), v11, v16.f64[0]), *a2));
    }
    double v18 = CG::Cubic::derivative((CG::Cubic *)a2, 1.0);
    *((double *)this + 20) = v18;
    *((double *)this + 21) = v19;
    double v20 = *((double *)this + 1);
    double v21 = *((double *)this + 2);
    double v22 = *((double *)this + 3);
    double v23 = *((double *)this + 4);
    if (-(v22 * v21 - v23 * v20) >= 0.0)
    {
      double v21 = -v21;
      double v22 = -v22;
    }
    else
    {
      double v23 = -v23;
      double v20 = -v20;
    }
    double v24 = v23 * v18 + v19 * v22;
    double v25 = v21 * v18 + v19 * v20;
    if (v24 != 0.0 || v25 != 0.0)
    {
      double v26 = sqrt(v24 * v24 + v25 * v25);
      double v24 = v24 / v26;
      double v25 = v25 / v26;
    }
    *((double *)this + 22) = v24;
    *((double *)this + 23) = v25;
    double v27 = a2[1].f64[0];
    if (((a2[2].f64[0] - a2[3].f64[0]) * (a2[2].f64[1] - a2[1].f64[1])
        + (a2[3].f64[1] - a2[2].f64[1]) * (a2[2].f64[0] - v27))
       * ((a2[2].f64[0] - v27) * (a2->f64[1] - a2[1].f64[1]) + (a2[2].f64[1] - a2[1].f64[1]) * (v27 - a2->f64[0])) > 0.0
      || (double v28 = CG::Cubic::inflection_points_classic((CG::Cubic *)a2), v30 = v28, v31 = v29, v28 == -1.0) && v29 == -1.0)
    {
      __n128 v32 = this;
      float v33 = a2;
    }
    else
    {
      CG::Cubic::split(a2, v28, v37);
      CG::stroker::path_stroke_round_cube(this, v37);
      if (v31 == -1.0)
      {
        float v33 = v38;
      }
      else
      {
        CG::Cubic::split(v38, (v31 - v30) / (1.0 - v30), v35);
        CG::stroker::path_stroke_round_cube(this, v35);
        float v33 = (float64x2_t *)&v36;
      }
      __n128 v32 = this;
    }
    CG::stroker::path_stroke_round_cube(v32, v33);
    return 1;
  }
  return result;
}

__n128 CG::stroker::cubeto(uint64_t a1, __n128 result, __n128 a3, __n128 a4)
{
  int v4 = *(_DWORD *)(a1 + 88);
  if (v4)
  {
    if (v4 == 1) {
      *(_DWORD *)(a1 + 88) = 2;
    }
    *(__n128 *)&v8[0].v = a3;
    *(__n128 *)&v9[0].v = result;
    *(__n128 *)(a1 + 192) = a4;
    double v6 = (__n128 *)(a1 + 192);
    CG::Cubic::Cubic((CG::Cubic *)v7, (const Point *)(a1 + 144), v9, v8, (const Point *)(a1 + 192));
    if (CG::stroker::add_cubic_segment((CG::stroker *)a1, v7))
    {
      uint64_t result = *v6;
      *(__n128 *)(a1 + 144) = *v6;
    }
  }
  return result;
}

__n128 CG::stroker::closepath(CG::stroker *this)
{
  unsigned int v1 = *((_DWORD *)this + 22);
  if (v1 >= 2)
  {
    if (v1 == 4)
    {
      CG::stroker::add_line_segment(this, (float64x2_t *)this + 9, (const Point *)this + 24);
      *((_OWORD *)this + 9) = *((_OWORD *)this + 6);
      CG::stroker::add_join(this, (float64x2_t *)this + 6, (double *)this + 14, (double *)this + 16);
      (*(void (**)(void))(**((void **)this + 10) + 8))(*((void *)this + 10));
      (*(void (**)(void, __n128))(**((void **)this + 10) + 16))(*((void *)this + 10), *((__n128 *)this + 13));
      CG::stroker::unroll_path((uint64_t)this);
      (*(void (**)(void))(**((void **)this + 10) + 8))(*((void *)this + 10));
    }
    else
    {
      Point v3 = (_OWORD *)((char *)this + 96);
      float64x2_t v5 = vsubq_f64(*((float64x2_t *)this + 12), *((float64x2_t *)this + 6));
      CG::stroker::add_point((uint64_t)this, (float64x2_t *)this + 6, (uint64_t)&v5);
      *((_OWORD *)this + 9) = *v3;
    }
    *((_DWORD *)this + 22) = 1;
    __n128 result = *((__n128 *)this + 6);
    *((__n128 *)this + 12) = result;
  }
  return result;
}

uint64_t CG::stroker::add_join(CG::stroker *a1, float64x2_t *a2, double *a3, double *a4)
{
  int v4 = *((_DWORD *)a1 + 13);
  if (v4)
  {
    if (v4 == 1)
    {
      return CG::stroker::add_round_join(a1, a2, a3, a4);
    }
    else
    {
      if (v4 != 2) {
        abort();
      }
      return CG::stroker::add_bevel_join((uint64_t)a1, a2, a3, a4);
    }
  }
  else
  {
    return CG::stroker::add_miter_join(a1, a2, a3, a4);
  }
}

uint64_t CG::stroker::unroll_path(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(void *)(this + 232);
  for (uint64_t i = v2 - 1; i >= 0; --i)
  {
    uint64_t v4 = *(void *)(v1 + 224);
    int v5 = *(_DWORD *)(v4 + 24 * i);
    if (v5 == 3)
    {
      uint64_t v6 = v4 + 24 * i;
      uint64_t i = v2 - 3;
      this = (*(uint64_t (**)(void, __n128, __n128, __n128))(**(void **)(v1 + 80) + 40))(*(void *)(v1 + 80), *(__n128 *)(v4 + 24 * v2 - 64), *(__n128 *)(v4 + 24 * v2 - 40), *(__n128 *)(v6 + 8));
    }
    else if (v5 == 1)
    {
      this = (*(uint64_t (**)(void, __n128))(**(void **)(v1 + 80) + 24))(*(void *)(v1 + 80), *(__n128 *)(v4 + 24 * i + 8));
    }
    uint64_t v2 = i;
  }
  *(void *)(v1 + 232) = 0;
  return this;
}

uint64_t CG::stroker::add_point(uint64_t result, float64x2_t *a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(result + 48);
  if (v3 <= 6 && ((1 << v3) & 0x69) != 0) {
    return result;
  }
  unsigned int v6 = *(double *)a3 == 0.0;
  if (*(double *)(a3 + 8) != 0.0) {
    unsigned int v6 = 0;
  }
  int32x2_t v7 = vdup_n_s32(v6);
  v8.i64[0] = v7.u32[0];
  v8.i64[1] = v7.u32[1];
  __asm { FMOV            V2.2D, #1.0 }
  float64x2_t v13 = (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v8, 0x3FuLL)), _Q2, *(int8x16_t *)a3);
  float64x2_t v14 = *(float64x2_t *)(result + 8);
  float64x2_t v15 = *(float64x2_t *)(result + 24);
  float64x2_t v16 = vmulq_f64((float64x2_t)vextq_s8((int8x16_t)v15, (int8x16_t)v15, 8uLL), v14);
  if (vsubq_f64(v16, (float64x2_t)vdupq_laneq_s64((int64x2_t)v16, 1)).f64[0] >= 0.0)
  {
    v19.f64[0] = *(float64_t *)(result + 24);
    v19.f64[1] = *(float64_t *)(result + 16);
    float64x2_t v18 = vnegq_f64(v19);
    float64x2_t v17 = (float64x2_t)vextq_s8((int8x16_t)v15, (int8x16_t)v14, 8uLL);
  }
  else
  {
    float64x2_t v17 = vnegq_f64((float64x2_t)vextq_s8((int8x16_t)v15, (int8x16_t)v14, 8uLL));
    v18.f64[0] = *(float64_t *)(result + 24);
    v18.f64[1] = *(float64_t *)(result + 16);
  }
  float64x2_t v20 = vmlaq_f64(vmulq_f64(v18, (float64x2_t)vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL)), v13, v17);
  if (v20.f64[0] != 0.0 || v20.f64[1] != 0.0) {
    float64x2_t v20 = vdivq_f64(v20, (float64x2_t)vdupq_lane_s64(COERCE__INT64(sqrt(vaddvq_f64(vmulq_f64(v20, v20)))), 0));
  }
  float64x2_t v21 = vmlaq_n_f64(vnegq_f64(vmulq_laneq_f64(v14, v20, 1)), v15, v20.f64[0]);
  float64x2_t v22 = vmlaq_laneq_f64(vmulq_n_f64(v14, v20.f64[0]), v15, v20, 1);
  float64x2_t v33 = v22;
  float64x2_t v32 = v21;
  switch(v3)
  {
    case 4u:
      uint64_t v23 = result + 80;
      (*(void (**)(void, __n128))(**(void **)(result + 80) + 16))(*(void *)(result + 80), (__n128)vaddq_f64(*a2, v21));
      (*(void (**)(__n128))(**(void **)v23 + 24))((__n128)vaddq_f64(*a2, v33));
      float64x2_t v25 = *a2;
      float64x2_t v26 = v32;
      break;
    case 2u:
      uint64_t v23 = result + 80;
      (*(void (**)(void, __n128))(**(void **)(result + 80) + 16))(*(void *)(result + 80), (__n128)vaddq_f64(vsubq_f64(v21, v22), *a2));
      float64x2_t v31 = vaddq_f64(v33, v32);
      (*(void (**)(__n128))(**(void **)v23 + 24))((__n128)vaddq_f64(v31, *a2));
      (*(void (**)(__n128))(**(void **)v23 + 24))((__n128)vaddq_f64(vsubq_f64(v33, v32), *a2));
      float64x2_t v25 = *a2;
      float64x2_t v26 = v31;
      break;
    case 1u:
      uint64_t v23 = result + 80;
      (*(void (**)(void, __n128))(**(void **)(result + 80) + 16))(*(void *)(result + 80), (__n128)vaddq_f64(*a2, v21));
      float64x2_t v24 = (float64x2_t)vdupq_n_s64(0x3FE1AC5111534A22uLL);
      float64x2_t v29 = vmulq_f64(v33, v24);
      float64x2_t v28 = vaddq_f64(v29, v32);
      float64x2_t v30 = vmulq_f64(v32, v24);
      (*(void (**)(__n128, __n128))(**(void **)v23 + 40))((__n128)vaddq_f64(v28, *a2), (__n128)vaddq_f64(vaddq_f64(*a2, v33), v30));
      (*(void (**)(__n128, __n128))(**(void **)v23 + 40))((__n128)vaddq_f64(vsubq_f64(v33, v30), *a2), (__n128)vaddq_f64(vsubq_f64(*a2, v32), v29));
      (*(void (**)(__n128, __n128))(**(void **)v23 + 40))((__n128)vsubq_f64(*a2, v28), (__n128)vsubq_f64(vsubq_f64(*a2, v33), v30));
      (*(void (**)(__n128, __n128))(**(void **)v23 + 40))((__n128)vaddq_f64(vsubq_f64(v30, v33), *a2), (__n128)vsubq_f64(vaddq_f64(*a2, v32), v29));
      goto LABEL_21;
    default:
      abort();
  }
  (*(void (**)(__n128))(**(void **)v23 + 24))((__n128)vsubq_f64(v25, v26));
LABEL_21:
  double v27 = *(uint64_t (**)(void))(**(void **)v23 + 8);
  return v27();
}

uint64_t CG::stroker::endpath(CG::stroker *this)
{
  if ((*((_DWORD *)this + 22) - 3) <= 1) {
    CG::stroker::end_contour((uint64_t)this);
  }
  uint64_t v2 = (uint64_t (*)(void))***((void ***)this + 10);
  return v2();
}

uint64_t CG::stroker::add_cap(uint64_t a1, float64x2_t *a2, uint64_t a3, char a4)
{
  uint64_t v6 = *(void *)(a3 + 8);
  float64x2_t v7 = *(float64x2_t *)(a1 + 8);
  float64x2_t v8 = *(float64x2_t *)(a1 + 24);
  float64x2_t v9 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v7, *(double *)&v6)), v8, *(double *)a3);
  int v10 = *(_DWORD *)(a1 + 48);
  if (v10 && vaddvq_f64(vmulq_f64(v9, v9)) > 0.0025)
  {
    float64x2_t v11 = vmlaq_f64(vmulq_n_f64(v7, *(double *)a3), v8, (float64x2_t)vdupq_lane_s64(v6, 0));
    float64x2_t v24 = v9;
    switch(v10)
    {
      case 1:
        float64x2_t v12 = (float64x2_t)vdupq_n_s64(0x3FE1AC5111534A22uLL);
        float64x2_t v20 = vmulq_f64(v9, v12);
        float64x2_t v21 = vmulq_f64(v11, v12);
        float64x2_t v22 = v11;
        (*(void (**)(void, __n128, __n128))(**(void **)(a1 + 80) + 40))(*(void *)(a1 + 80), (__n128)vaddq_f64(v21, vaddq_f64(v9, *a2)), (__n128)vaddq_f64(vaddq_f64(*a2, v11), v20));
        __n128 v13 = (__n128)vaddq_f64(vsubq_f64(v22, v20), *a2);
        __n128 v14 = (__n128)vaddq_f64(vsubq_f64(*a2, v24), v21);
        float64x2_t v15 = *(uint64_t (**)(__n128, __n128))(**(void **)(a1 + 80) + 40);
        return v15(v13, v14);
      case 2:
        float64x2_t v23 = v11;
        (*(void (**)(__n128))(**(void **)(a1 + 80) + 24))((__n128)vaddq_f64(vaddq_f64(v11, v9), *a2));
        goto LABEL_11;
      case 3:
        goto LABEL_13;
      case 4:
        goto LABEL_10;
      case 5:
        if ((a4 & 1) == 0) {
          goto LABEL_10;
        }
        goto LABEL_13;
      case 6:
        if (a4)
        {
LABEL_10:
          float64x2_t v23 = v11;
          (*(void (**)(void, __n128))(**(void **)(a1 + 80) + 24))(*(void *)(a1 + 80), (__n128)vaddq_f64(vaddq_f64(v11, v9), *a2));
          (*(void (**)(__n128))(**(void **)(a1 + 80) + 24))(*(__n128 *)a2);
LABEL_11:
          __n128 v18 = (__n128)vaddq_f64(vsubq_f64(v23, v24), *a2);
        }
        else
        {
LABEL_13:
          __n128 v18 = (__n128)vaddq_f64(*a2, v11);
        }
        (*(void (**)(void, __n128))(**(void **)(a1 + 80) + 24))(*(void *)(a1 + 80), v18);
        __n128 v17 = (__n128)vsubq_f64(*a2, v24);
        break;
      default:
        abort();
    }
  }
  else
  {
    __n128 v17 = (__n128)vsubq_f64(*a2, v9);
  }
  float64x2_t v19 = *(uint64_t (**)(__n128))(**(void **)(a1 + 80) + 24);
  return v19(v17);
}

uint64_t CG::stroker::add_bevel_join(uint64_t result, float64x2_t *a2, double *a3, double *a4)
{
  float64x2_t v4 = *(float64x2_t *)(result + 24);
  float64x2_t v5 = *(float64x2_t *)(result + 8);
  float64x2_t v6 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v5, *(double *)(result + 184))), v4, *(double *)(result + 176));
  float64x2_t v7 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v5, a4[1])), v4, *a4);
  float64x2_t v8 = vsubq_f64(v6, v7);
  if (vaddvq_f64(vmulq_f64(v8, v8)) >= *(double *)(result + 72) * *(double *)(result + 72))
  {
    uint64_t v12 = result;
    *(float64x2_t *)(result + 208) = vsubq_f64(*a2, v7);
    float64x2_t v22 = v7;
    *(float64x2_t *)&v23[0].v = vsubq_f64(*a2, v6);
    float64x2_t v21 = v6;
    CG::stroker::push_opposite_element((CG::stroker *)result, kCGPathElementAddLineToPoint, v23);
    float64x2_t v13 = vmulq_f64(v21, v21);
    float64x2_t v14 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v13.f64[0], 0);
    v13.f64[0] = *(double *)(v12 + 168) * *(double *)(v12 + 168);
    v14.f64[0] = *(double *)(v12 + 160) * *(double *)(v12 + 160);
    float64x2_t v15 = vsqrtq_f64(vaddq_f64(v13, v14));
    if ((vmovn_s64(vcgtq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v15, 1), v15)).u8[0] & 1) != 0
      || (float64x2_t v16 = vmulq_f64(v22, v22),
          float64x2_t v17 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v16.f64[0], 0),
          v16.f64[0] = a3[1] * a3[1],
          v17.f64[0] = *a3 * *a3,
          float64x2_t v18 = vsqrtq_f64(vaddq_f64(v16, v17)),
          (vmovn_s64(vcgtq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v18, 1), v18)).u8[0] & 1) != 0))
    {
      if (-(*a4 * *(double *)(v12 + 184) - a4[1] * *(double *)(v12 + 176)) >= 0.0) {
        (*(void (**)(void, __n128))(**(void **)(v12 + 80) + 24))(*(void *)(v12 + 80), *(__n128 *)a2);
      }
      else {
        CG::stroker::push_opposite_element((CG::stroker *)v12, kCGPathElementAddLineToPoint, (const Point *)a2);
      }
    }
    __n128 v19 = (__n128)vaddq_f64(*a2, v22);
    float64x2_t v20 = *(uint64_t (**)(__n128))(**(void **)(v12 + 80) + 24);
    return v20(v19);
  }
  return result;
}

__n128 CG::stroker::push_opposite_element(CG::stroker *this, CGPathElementType a2, const Point *a3)
{
  *(_OWORD *)&Point v8[4] = *(_OWORD *)&a3->v;
  uint64_t v5 = *((void *)this + 29);
  if (*((void *)this + 30) < (unint64_t)(v5 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)this + 224, v5 + 1);
    uint64_t v5 = *((void *)this + 29);
  }
  uint64_t v6 = *((void *)this + 28) + 24 * v5;
  *(_DWORD *)uint64_t v6 = a2;
  __n128 result = *(__n128 *)v8;
  *(_OWORD *)(v6 + 4) = *(_OWORD *)v8;
  *(_DWORD *)(v6 + 20) = *(_DWORD *)&v8[16];
  ++*((void *)this + 29);
  return result;
}

uint64_t CG::stroker::add_miter_join(CG::stroker *this, float64x2_t *a2, double *a3, double *a4)
{
  double v9 = *((double *)this + 22);
  double v8 = *((double *)this + 23);
  float64x2_t v10 = *(float64x2_t *)((char *)this + 24);
  float64x2_t v11 = *(float64x2_t *)((char *)this + 8);
  float64x2_t v12 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v11, v8)), v10, v9);
  float64x2_t v13 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v11, a4[1])), v10, *a4);
  float64x2_t v14 = vsubq_f64(v12, v13);
  if (vaddvq_f64(vmulq_f64(v14, v14)) >= 0.05)
  {
    *((float64x2_t *)this + 13) = vsubq_f64(*a2, v13);
    if (*((double *)this + 7) * *((double *)this + 7) * (*a4 * v9 + 1.0 + a4[1] * v8) >= 2.0)
    {
      float64x2_t v38 = v12;
      float64x2_t v39 = v13;
      *(float64x2_t *)&v42[0].v = vsubq_f64(*a2, v12);
      CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, v42);
      if (-(*a4 * *((double *)this + 23) - a4[1] * *((double *)this + 22)) >= 0.0)
      {
        float64x2_t v29 = *a2;
        long long v30 = *((_OWORD *)this + 10);
        *(float64x2_t *)&v42[0].v = vsubq_f64(*a2, v38);
        long long v43 = v30;
        long long v31 = *(_OWORD *)a3;
        float64x2_t v40 = vsubq_f64(v29, v39);
        long long v41 = v31;
        CG::intersection((double *)&v42[0].v, v40.f64, (uint64_t)v44);
        if (v44[0]) {
          CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, (const Point *)&v45);
        }
        float64x2_t v32 = vmulq_f64(v38, v38);
        float64x2_t v33 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v32.f64[0], 0);
        v32.f64[0] = *((double *)this + 21) * *((double *)this + 21);
        v33.f64[0] = *((double *)this + 20) * *((double *)this + 20);
        float64x2_t v34 = vsqrtq_f64(vaddq_f64(v32, v33));
        if ((vmovn_s64(vcgtq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v34, 1), v34)).u8[0] & 1) == 0)
        {
          float64x2_t v35 = vmulq_f64(v39, v39);
          float64x2_t v36 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v35.f64[0], 0);
          v35.f64[0] = a3[1] * a3[1];
          v36.f64[0] = *a3 * *a3;
          float64x2_t v37 = vsqrtq_f64(vaddq_f64(v35, v36));
          if ((vmovn_s64(vcgtq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v37, 1), v37)).u8[0] & 1) == 0) {
            return (*(uint64_t (**)(void, __n128))(**((void **)this + 10) + 24))(*((void *)this + 10), (__n128)vaddq_f64(*a2, v39));
          }
        }
        uint64_t v27 = *((void *)this + 10);
        __n128 v28 = *(__n128 *)a2;
      }
      else
      {
        float64x2_t v17 = v38;
        float64x2_t v16 = v39;
        float64x2_t v18 = vmulq_f64(v17, v17);
        float64x2_t v19 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v18.f64[0], 0);
        v18.f64[0] = *((double *)this + 21) * *((double *)this + 21);
        v19.f64[0] = *((double *)this + 20) * *((double *)this + 20);
        float64x2_t v20 = vsqrtq_f64(vaddq_f64(v18, v19));
        if ((vmovn_s64(vcgtq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v20, 1), v20)).u8[0] & 1) != 0
          || (float64x2_t v21 = vmulq_f64(v39, v39),
              float64x2_t v22 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v21.f64[0], 0),
              v21.f64[0] = a3[1] * a3[1],
              v22.f64[0] = *a3 * *a3,
              float64x2_t v23 = vsqrtq_f64(vaddq_f64(v21, v22)),
              (vmovn_s64(vcgtq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v23, 1), v23)).u8[0] & 1) != 0))
        {
          CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, (const Point *)a2);
          float64x2_t v17 = v38;
          float64x2_t v16 = v39;
        }
        float64x2_t v24 = *a2;
        long long v25 = *((_OWORD *)this + 10);
        *(float64x2_t *)&v42[0].v = vaddq_f64(*a2, v17);
        long long v43 = v25;
        long long v26 = *(_OWORD *)a3;
        float64x2_t v40 = vaddq_f64(v24, v16);
        long long v41 = v26;
        CG::intersection((double *)&v42[0].v, v40.f64, (uint64_t)v44);
        if (!v44[0]) {
          return (*(uint64_t (**)(void, __n128))(**((void **)this + 10) + 24))(*((void *)this + 10), (__n128)vaddq_f64(*a2, v39));
        }
        uint64_t v27 = *((void *)this + 10);
        __n128 v28 = v45;
      }
      (*(void (**)(uint64_t, __n128))(*(void *)v27 + 24))(v27, v28);
      return (*(uint64_t (**)(void, __n128))(**((void **)this + 10) + 24))(*((void *)this + 10), (__n128)vaddq_f64(*a2, v39));
    }
  }
  return CG::stroker::add_bevel_join((uint64_t)this, a2, a3, a4);
}

uint64_t CG::stroker::add_round_join(CG::stroker *this, float64x2_t *a2, double *a3, double *a4)
{
  double v8 = *((double *)this + 22);
  double v7 = *((double *)this + 23);
  float64x2_t v9 = *(float64x2_t *)((char *)this + 24);
  float64x2_t v10 = *(float64x2_t *)((char *)this + 8);
  float64x2_t v11 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v10, v7)), v9, v8);
  float64x2_t v12 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v10, a4[1])), v9, *a4);
  float64x2_t v13 = vsubq_f64(v11, v12);
  if (vaddvq_f64(vmulq_f64(v13, v13)) >= 0.05)
  {
    *((float64x2_t *)this + 13) = vsubq_f64(*a2, v12);
    double v15 = *a4;
    double v16 = a4[1];
    double v17 = *a4 + v8;
    double v18 = v16 + v7;
    double v19 = sqrt(v17 * v17 + v18 * v18);
    if (v19 >= 0.001)
    {
      double v21 = 2.66666667 / v19;
      if (vabdd_f64(v7, v16) <= vabdd_f64(v8, v15)) {
        double v20 = (1.33333333 - v21) * v18 / (v8 - v15);
      }
      else {
        double v20 = (v21 + -1.33333333) * v17 / (v7 - v16);
      }
    }
    else
    {
      double v20 = -1.33333333;
    }
    float64x2_t v22 = vmlaq_n_f64(vmulq_n_f64(v10, -(v7 - v20 * v8)), v9, v8 + v20 * v7);
    float64x2_t v23 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v10, v16 + v20 * v15)), v9, v15 - v20 * v16);
    float64x2_t v46 = v22;
    float64x2_t v47 = v12;
    float64x2_t v48 = v11;
    if (-(v15 * v7 - v16 * v8) >= 0.0 || v19 < 0.001)
    {
      *(float64x2_t *)&v49[0].v = vsubq_f64(*a2, v23);
      CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v49);
      *(float64x2_t *)&v49[0].v = vsubq_f64(*a2, v46);
      CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v49);
      *(float64x2_t *)&v49[0].v = vsubq_f64(*a2, v48);
      CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v49);
      float64x2_t v37 = vmulq_f64(v48, v48);
      float64x2_t v38 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v37.f64[0], 0);
      v37.f64[0] = *((double *)this + 21) * *((double *)this + 21);
      v38.f64[0] = *((double *)this + 20) * *((double *)this + 20);
      float64x2_t v39 = vsqrtq_f64(vaddq_f64(v37, v38));
      if ((vmovn_s64(vcgtq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v39, 1), v39)).u8[0] & 1) != 0
        || (float64x2_t v40 = vmulq_f64(v47, v47),
            float64x2_t v41 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v40.f64[0], 0),
            v40.f64[0] = a3[1] * a3[1],
            v41.f64[0] = *a3 * *a3,
            float64x2_t v42 = vsqrtq_f64(vaddq_f64(v40, v41)),
            (vmovn_s64(vcgtq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v42, 1), v42)).u8[0] & 1) != 0))
      {
        (*(void (**)(void, __n128))(**((void **)this + 10) + 24))(*((void *)this + 10), *(__n128 *)a2);
      }
      __n128 v43 = (__n128)vaddq_f64(*a2, v47);
      long long v44 = *(uint64_t (**)(__n128))(**((void **)this + 10) + 24);
      return v44(v43);
    }
    else
    {
      float64x2_t v45 = v23;
      _D8 = v11.f64[1];
      float64_t v25 = a2->f64[1] - v11.f64[1];
      *(double *)&v49[0].v = a2->f64[0] - v11.f64[0];
      *(float64_t *)&v49[2].v = v25;
      CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, v49);
      _V2.D[1] = v48.f64[1];
      __asm { FMLA            D1, D8, V2.D[1] }
      if (sqrt(*((double *)this + 20) * *((double *)this + 20) + *((double *)this + 21) * *((double *)this + 21)) < sqrt(_D1)
        || sqrt(*a3 * *a3 + a3[1] * a3[1]) < sqrt(vaddvq_f64(vmulq_f64(v47, v47))))
      {
        CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, (const Point *)a2);
      }
      double v32 = a2->f64[1];
      v33.n128_f64[0] = a2->f64[0] + v46.f64[0];
      v34.n128_f64[0] = a2->f64[0] + v45.f64[0];
      v35.n128_f64[0] = a2->f64[0] + v47.f64[0];
      float64x2_t v36 = *(uint64_t (**)(__n128, __n128, __n128))(**((void **)this + 10) + 40);
      v33.n128_f64[1] = v32 + v46.f64[1];
      v34.n128_f64[1] = v32 + v45.f64[1];
      v35.n128_f64[1] = v32 + v47.f64[1];
      return v36(v33, v34, v35);
    }
  }
  else
  {
    return CG::stroker::add_bevel_join((uint64_t)this, a2, a3, a4);
  }
}

double CG::stroker::offset_normal(double *a1, CG::Cubic *this, double *a3, double a4)
{
  double v6 = CG::Cubic::derivative(this, a4);
  if (a3)
  {
    *a3 = v6;
    a3[1] = v7;
  }
  double v8 = a1[1];
  double v9 = a1[2];
  double v11 = a1[3];
  double v10 = a1[4];
  if (-(v11 * v9 - v10 * v8) >= 0.0)
  {
    double v14 = -v9;
    double v15 = -v11;
    double v12 = a1[4];
    double v13 = a1[1];
  }
  else
  {
    double v12 = -v10;
    double v13 = -v8;
    double v14 = a1[2];
    double v15 = a1[3];
  }
  double v16 = v12 * v6 + v15 * v7;
  double v17 = v14 * v6 + v13 * v7;
  double v18 = -v17;
  if (v17 != 0.0 || v16 != 0.0)
  {
    double v19 = sqrt(v16 * v16 + v17 * v17);
    double v18 = v18 / v19;
    double v16 = v16 / v19;
  }
  return v18 * v8 + v16 * v11;
}

void CG::stroker::path_stroke_round_cube_offset(CG::stroker *this, float64x2_t *a2, int a3, int a4)
{
  double v7 = a2[3].f64[0];
  double v8 = a2[3].f64[1];
  double v9 = a2->f64[0];
  double v10 = a2->f64[1];
  if ((v7 - a2->f64[0]) * (v7 - a2->f64[0]) + (v8 - v10) * (v8 - v10) <= 0.00000001)
  {
    v45.n128_f64[0] = CG::stroker::offset_normal((double *)this, (CG::Cubic *)a2, 0, 1.0) + v7;
    v45.n128_f64[1] = v40 + v8;
    if (a4 < 0)
    {
      CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, (const Point *)&v45);
      double v41 = a2->f64[0];
      double v42 = a2->f64[1];
      *((double *)this + 26) = CG::stroker::offset_normal((double *)this, (CG::Cubic *)a2, 0, 0.0) + v41;
      *((double *)this + 27) = v43 + v42;
    }
    else
    {
      (*(void (**)(void, __n128))(**((void **)this + 10) + 24))(*((void *)this + 10), v45);
    }
  }
  else
  {
    long long v70 = 0uLL;
    double v12 = CG::stroker::offset_normal((double *)this, (CG::Cubic *)a2, (double *)&v70, 0.0) + v9;
    double v14 = v13 + v10;
    *(double *)&v69[0].v = v12;
    *(double *)&v69[2].v = v13 + v10;
    long long v68 = 0uLL;
    double v15 = a2[3].f64[0];
    double v16 = a2[3].f64[1];
    double v17 = CG::stroker::offset_normal((double *)this, (CG::Cubic *)a2, (double *)&v68, 1.0) + v15;
    double v19 = v18 + v16;
    *(double *)&v67[0].v = v17;
    *(double *)&v67[2].v = v18 + v16;
    long long v66 = 0uLL;
    double v20 = CG::Cubic::evaluate(a2, 0.5);
    double v22 = v21;
    double v23 = CG::stroker::offset_normal((double *)this, (CG::Cubic *)a2, (double *)&v66, 0.5) + v20;
    double v25 = v24 + v22;
    v65.f64[0] = v23 + -(v12 + v17 - v23 * 2.0) * 0.166666667;
    v65.f64[1] = v24 + v22 + -(v14 + v19 - (v24 + v22) * 2.0) * 0.166666667;
    __n128 v45 = *(__n128 *)&v69[0].v;
    long long v46 = v70;
    float64x2_t v50 = v65;
    long long v51 = v66;
    CG::intersection(v45.n128_f64, v50.f64, (uint64_t)v63);
    if (v63[0]) {
      long long v26 = (float64x2_t *)&v64;
    }
    else {
      long long v26 = &v65;
    }
    *(float64x2_t *)&v62[0].v = *v26;
    __n128 v45 = *(__n128 *)&v67[0].v;
    long long v46 = v68;
    float64x2_t v50 = v65;
    long long v51 = v66;
    CG::intersection(v45.n128_f64, v50.f64, (uint64_t)v60);
    if (v60[0]) {
      uint64_t v27 = (float64x2_t *)&v61;
    }
    else {
      uint64_t v27 = &v65;
    }
    *(float64x2_t *)&v59[0].v = *v27;
    BOOL v28 = __OFSUB__(a3, 1);
    int v29 = a3 - 1;
    if (v29 < 0 != v28)
    {
LABEL_32:
      if (a4 < 0)
      {
        CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v62);
        CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v59);
        CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v67);
        *((_OWORD *)this + 13) = *(_OWORD *)&v69[0].v;
      }
      else
      {
        (*(void (**)(void, __n128, __n128, __n128))(**((void **)this + 10) + 40))(*((void *)this + 10), *(__n128 *)&v62[0].v, *(__n128 *)&v59[0].v, *(__n128 *)&v67[0].v);
      }
    }
    else
    {
      CG::Cubic::Cubic((CG::Cubic *)&v50, v69, v62, v59, v67);
      uint64_t v30 = 0;
      while (1)
      {
        double v31 = *(double *)&CG::stroker::path_stroke_round_cube_offset(CG::Cubic const&,int,int)::samples[v30];
        double v32 = v25;
        double v33 = v23;
        if (v30 * 8)
        {
          double v34 = CG::Cubic::evaluate(a2, *(double *)&CG::stroker::path_stroke_round_cube_offset(CG::Cubic const&,int,int)::samples[v30]);
          double v36 = v35;
          double v33 = CG::stroker::offset_normal((double *)this, (CG::Cubic *)a2, 0, v31) + v34;
          double v32 = v37 + v36;
        }
        *(double *)&v48[0].v = v33;
        double v49 = v32;
        BOOL v38 = (*(void *)&v33 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000
           && (*(void *)&v32 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
        BOOL v39 = v38;
        if ((*(void *)&v50.f64[0] & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (*(void *)&v50.f64[1] & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && ((unint64_t)v51 & 0x7FFFFFFFFFFFFFFFLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (*((void *)&v51 + 1) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (v52 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (v53 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (v54 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (v55 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (v56 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (v57 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && v39
          && (v58 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (CG::Cubic::is_near(&v50, v48, v31, *((double *)this + 9)) & 1) == 0)
        {
          break;
        }
        if (++v30 == 5) {
          goto LABEL_32;
        }
      }
      CG::Cubic::split(a2, 0.5, (float64x2_t *)&v45);
      if (a4 < 0)
      {
        CG::stroker::path_stroke_round_cube_offset(this, (const CG::Cubic *)v47, v29, a4);
        long long v44 = (const CG::Cubic *)&v45;
      }
      else
      {
        CG::stroker::path_stroke_round_cube_offset(this, (const CG::Cubic *)&v45, v29, a4);
        long long v44 = (const CG::Cubic *)v47;
      }
      CG::stroker::path_stroke_round_cube_offset(this, v44, v29, a4);
    }
  }
}

double CG::stroker::path_stroke_round_cube_chord(CG::stroker *this, const CG::Cubic *a2)
{
  double v4 = *(double *)a2;
  double v5 = *((double *)a2 + 1);
  v14[0] = v4 - CG::stroker::offset_normal((double *)this, a2, 0, 0.0);
  v14[1] = v5 - v6;
  CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, (const Point *)v14);
  double v7 = *((double *)a2 + 6);
  double v8 = *((double *)a2 + 7);
  double v9 = CG::stroker::offset_normal((double *)this, a2, 0, 1.0);
  double v11 = v10;
  v12.n128_f64[0] = v9 + v7;
  v12.n128_f64[1] = v10 + v8;
  (*(void (**)(void, __n128))(**((void **)this + 10) + 24))(*((void *)this + 10), v12);
  double result = v7 - v9;
  *((double *)this + 26) = v7 - v9;
  *((double *)this + 27) = v8 - v11;
  return result;
}

void CG::stroker::path_stroke_round_cube(CG::stroker *this, float64x2_t *a2)
{
  double v4 = (const Point *)&a2[1];
  double v5 = a2[1].f64[0];
  double v6 = a2[1].f64[1];
  double v7 = (const Point *)&a2[2];
  double v8 = a2[2].f64[0];
  double v9 = a2[2].f64[1];
  double v10 = (const Point *)&a2[3];
  double v11 = v5 - a2->f64[0];
  double v12 = v6 - a2->f64[1];
  double v13 = v8 - v5;
  double v14 = v9 - v6;
  double v15 = a2[3].f64[0] - v8;
  if (v13 * v11 + (v9 - v6) * v12 >= 0.0 && v15 * v13 + (a2[3].f64[1] - v9) * v14 >= 0.0)
  {
    CG::stroker::path_stroke_round_cube_offset(this, a2, 4, 1);
    CG::Cubic::Cubic((CG::Cubic *)&v16, v10, v7, v4, (const Point *)a2);
    CG::stroker::path_stroke_round_cube_offset(this, &v16, 4, -1);
  }
  else if (v11 * v11 + v12 * v12 <= 0.00000001 {
         && v13 * v13 + v14 * v14 <= 0.00000001
  }
         && v15 * v15 + (a2[3].f64[1] - v9) * (a2[3].f64[1] - v9) <= 0.00000001)
  {
    CG::stroker::path_stroke_round_cube_chord(this, (const CG::Cubic *)a2);
  }
  else
  {
    CG::Cubic::split(a2, 0.5, &v16);
    if (a2->f64[0] != v16.f64[0]
      || a2->f64[1] != v16.f64[1]
      || *(double *)&v4->v != v17
      || a2[1].f64[1] != v18
      || *(double *)&v7->v != v19
      || a2[2].f64[1] != v20
      || *(double *)&v10->v != v21
      || a2[3].f64[1] != v22)
    {
      CG::stroker::path_stroke_round_cube(this, (const CG::Cubic *)&v16);
      if (a2->f64[0] != v23[0]
        || a2->f64[1] != v23[1]
        || *(double *)&v4->v != v23[2]
        || a2[1].f64[1] != v23[3]
        || *(double *)&v7->v != v23[4]
        || a2[2].f64[1] != v23[5]
        || *(double *)&v10->v != v23[6]
        || a2[3].f64[1] != v23[7])
      {
        CG::stroker::path_stroke_round_cube(this, (const CG::Cubic *)v23);
      }
    }
  }
}

int8x16_t RB::Fill::Gradient::concat(RB::Fill::Gradient *this, float64x2_t *a2, RB::Heap *a3)
{
  int8x16_t result = vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a2[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*a2, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(a2[2]));
  result.i64[0] = vandq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)result, 1), result).u64[0];
  if ((result.i64[0] & 0x8000000000000000) == 0)
  {
    double v5 = (float64x2_t *)*((void *)this + 2);
    if (v5)
    {
      *(double *)result.i64 = RB::operator*(a2, v5);
      uint64_t v6 = *((void *)this + 2);
      *(int8x16_t *)uint64_t v6 = result;
      *(_OWORD *)(v6 + 16) = v7;
      *(_OWORD *)(v6 + 32) = v8;
    }
    else
    {
      unint64_t v9 = (*((void *)a3 + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
      if (v9 + 48 > *((void *)a3 + 3))
      {
        double v11 = (const RB::AffineTransform *)a2;
        unint64_t v9 = RB::Heap::alloc_slow((size_t *)a3, 0x30uLL, 15);
        a2 = (float64x2_t *)v11;
      }
      else
      {
        *((void *)a3 + 2) = v9 + 48;
      }
      int8x16_t result = *(int8x16_t *)a2;
      float64x2_t v10 = a2[2];
      *(float64x2_t *)(v9 + 16) = a2[1];
      *(float64x2_t *)(v9 + 32) = v10;
      *(int8x16_t *)unint64_t v9 = result;
      *((void *)this + 2) = v9;
    }
  }
  return result;
}

void RB::Fill::Gradient::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
  int v6 = HIBYTE(a4);
  *(unsigned char *)(a1 + 55) = 1;
  if (*(void *)a1)
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      uint16x4_t v10 = *(uint16x4_t *)(*(void *)(a1 + 8) + v8);
      __int16 v11 = *(_WORD *)(a1 + 53);
      uint16x4_t v14 = v10;
      __int16 v15 = v11;
      if (v6) {
        RB::Fill::Color::convert((uint64_t)&v14, a4, v10);
      }
      RB::operator*=((uint64_t)&v14, a2);
      *(uint16x4_t *)(*(void *)(a1 + 8) + v8) = v14;
      BOOL v13 = *(short float *)&v14.i16[3] == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) && *(unsigned char *)(a1 + 55) != 0;
      *(unsigned char *)(a1 + 55) = v13;
      ++v9;
      v8 += 16;
    }
    while (v9 < *(void *)a1);
  }
  if (v6) {
    *(_WORD *)(a1 + 53) = a4;
  }
}

uint64_t RB::Fill::Gradient::can_mix(uint64_t *a1, uint64_t a2, const RB::AffineTransform *a3)
{
  if (*((unsigned __int8 *)a1 + 52) != *(unsigned __int8 *)(a2 + 52)
    || ((*(_DWORD *)(a2 + 48) ^ *((_DWORD *)a1 + 12)) & 0xFC7) != 0)
  {
    return 0;
  }
  uint64_t result = RB::can_mix((float64x2_t *)a1[2], *(float64x2_t **)(a2 + 16), a3);
  if (result >= 4u)
  {
    uint64_t v6 = *a1;
    if (*a1 != *(void *)a2) {
      return 2 * ((a1[6] & 0xF00u) - 256 > 0x1FF);
    }
    uint32x2_t v7 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32((float32x2_t)a1[4], *(float32x2_t *)(a2 + 32)), (int8x8_t)vceq_f32((float32x2_t)a1[3], *(float32x2_t *)(a2 + 24)));
    if ((vpmin_u32(v7, v7).u32[0] & 0x80000000) != 0 && *((float *)a1 + 10) == *(float *)(a2 + 40))
    {
      BOOL v8 = *((float *)a1 + 11) == *(float *)(a2 + 44);
      if (v6)
      {
LABEL_13:
        uint64_t v9 = 0;
        uint64_t v10 = *(void *)(a2 + 8);
        do
        {
          BOOL v8 = v8
            && (uint64_t v11 = a1[1],
                (vminv_u16((uint16x4_t)vceq_f16(*(float16x4_t *)(v11 + v9), *(float16x4_t *)(v10 + v9))) & 0x8000) != 0)
            && (uint64_t v12 = v11 + v9, *(float *)(v12 + 8) == *(float *)(v10 + v9 + 8))
            && *(_DWORD *)(v12 + 12) == *(_DWORD *)(v10 + v9 + 12);
          v9 += 16;
          --v6;
        }
        while (v6);
      }
    }
    else
    {
      BOOL v8 = 0;
      if (v6) {
        goto LABEL_13;
      }
    }
    if (v8) {
      return 4;
    }
    else {
      return 2;
    }
  }
  return result;
}

void RB::Fill::Gradient::mix(RB::Fill::Gradient *this, const RB::DisplayList::Interpolator::Op *a2, const RB::Fill::Gradient *a3, double a4, RB::Heap *a5)
{
  if ((*(void *)a2 & 0xELL) == 2) {
    RB::Fill::Gradient::mix(this, a3, a4, a5);
  }
}

void RB::Fill::Gradient::mix(RB::Fill::Gradient *this, const RB::Fill::Gradient *a2, double a3, RB::Heap *a4)
{
  uint64_t v107 = *MEMORY[0x263EF8340];
  float32x2_t v7 = *(float32x2_t *)((char *)this + 32);
  *((float32x2_t *)this + 3) = vmla_n_f32(*(float32x2_t *)((char *)this + 24), vsub_f32(*(float32x2_t *)((char *)a2 + 24), *(float32x2_t *)((char *)this + 24)), *(float *)&a3);
  *((float32x2_t *)this + 4) = vmla_n_f32(v7, vsub_f32(*(float32x2_t *)((char *)a2 + 32), v7), *(float *)&a3);
  *((float32x2_t *)this + 5) = vmla_n_f32(*(float32x2_t *)((char *)this + 40), vsub_f32(*(float32x2_t *)((char *)a2 + 40), *(float32x2_t *)((char *)this + 40)), *(float *)&a3);
  BOOL v8 = (CGAffineTransform *)*((void *)this + 2);
  if (v8)
  {
    uint64_t v9 = (float64x2_t *)*((void *)a2 + 2);
    if (v9)
    {
      RB::mix(v8, v9, a4, *(float *)&a3);
      uint64_t v10 = (_OWORD *)*((void *)this + 2);
      *uint64_t v10 = v11;
      v10[1] = v12;
      int32x2_t v10[2] = v13;
    }
  }
  float32x2_t v14 = *(float32x2_t *)this;
  unint64_t v15 = *(void *)a2;
  if (*(void *)this == *(void *)a2)
  {
    *((unsigned char *)this + 55) = 1;
    if (v14)
    {
      uint64_t v16 = 0;
      unint64_t v17 = 0;
      float32x2_t v18 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0);
      float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3B808081u);
      int8x8_t v20 = (int8x8_t)vdup_n_s32(0x437F8000u);
      __asm { FMOV            V15.2S, #1.0 }
      float32x2_t v25 = (float32x2_t)vdup_n_s32(0x437F0000u);
      do
      {
        uint64_t v26 = *((void *)this + 1);
        uint64_t v27 = *((void *)a2 + 1);
        __int16 v28 = *(_WORD *)((char *)this + 53);
        uint64_t __dst = *(void *)(v26 + v16);
        __int16 v103 = v28;
        __int16 v29 = *(_WORD *)((char *)a2 + 53);
        uint64_t v100 = *(void *)(v27 + v16);
        __int16 v101 = v29;
        RB::Fill::Color::mix((uint64_t)&__dst, (uint64_t)&v100, 0, *(float *)&a3);
        *(void *)(v26 + v16) = __dst;
        BOOL v31 = *((short float *)&__dst + 3) == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) && *((unsigned char *)this + 55) != 0;
        *((unsigned char *)this + 55) = v31;
        int v32 = *((_DWORD *)this + 12);
        if (((*((_DWORD *)a2 + 12) | v32) & 0x10000) != 0) {
          *(float *)(v26 + v16 + 8) = *(float *)(v26 + v16 + 8)
        }
                                    + (float)((float)(*(float *)(v27 + v16 + 8) - *(float *)(v26 + v16 + 8))
                                            * *(float *)&a3);
        int v33 = v32 & 0xF00;
        if (v33 == 512)
        {
          v34.i32[0] = *(unsigned __int8 *)(v26 + v16 + 12);
          v34.i32[1] = *(unsigned __int8 *)(v26 + v16 + 13);
          float32x2_t v35 = vmul_f32(vcvt_f32_u32(v34), v19);
          v36.i32[0] = *(unsigned __int8 *)(v27 + v16 + 12);
          v36.i32[1] = *(unsigned __int8 *)(v27 + v16 + 13);
          int32x2_t v37 = (int32x2_t)vmla_f32(v35, v18, vmla_f32(vneg_f32(v35), v19, vcvt_f32_u32(v36)));
          v36.i32[0] = *(unsigned __int8 *)(v26 + v16 + 14);
          v36.i32[1] = *(unsigned __int8 *)(v26 + v16 + 15);
          v38.i32[0] = *(unsigned __int8 *)(v27 + v16 + 14);
          v38.i32[1] = *(unsigned __int8 *)(v27 + v16 + 15);
          float32x2_t v39 = vmul_f32(vcvt_f32_u32(v36), v19);
          int32x2_t v40 = (int32x2_t)vmla_f32(v39, v18, vmla_f32(vneg_f32(v39), v19, vcvt_f32_u32(v38)));
          if (*(float *)v37.i32 >= 0.0) {
            float v41 = *(float *)v37.i32;
          }
          else {
            float v41 = 0.0;
          }
          if (v41 <= 1.0) {
            float v42 = (float)(v41 * 255.0) + 0.5;
          }
          else {
            float v42 = 255.5;
          }
          if (*(float *)v40.i32 >= 0.0) {
            float v43 = *(float *)v40.i32;
          }
          else {
            float v43 = 0.0;
          }
          float v44 = (float)(v43 * 255.0) + 0.5;
          if (v43 > 1.0) {
            float v44 = 255.5;
          }
          float32x2_t v45 = (float32x2_t)vzip2_s32(v40, v37);
          float32x2_t v46 = (float32x2_t)vbic_s8((int8x8_t)v45, (int8x8_t)vcltz_f32(v45));
          uint32x2_t v47 = vshl_u32((uint32x2_t)vcvt_s32_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v46, _D15), v20, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v25, v46))), (uint32x2_t)0x800000018);
          *(_DWORD *)(v26 + v16 + 12) = v47.i32[0] | ((int)v44 << 16) | (int)v42 | v47.i32[1];
        }
        else if (v33 == 256)
        {
          *(float *)(v26 + v16 + 12) = *(float *)(v26 + v16 + 12)
                                     + (float)((float)(*(float *)(v27 + v16 + 12) - *(float *)(v26 + v16 + 12))
                                             * *(float *)&a3);
        }
        ++v17;
        v16 += 16;
      }
      while (v17 < *(void *)this);
    }
    *((_DWORD *)this + 12) |= *((_DWORD *)a2 + 12) & 0x10000;
    return;
  }
  uint64_t v104 = 0;
  float32x2_t v105 = 0;
  unint64_t v106 = 16;
  if (!(*(void *)&v14 | v15))
  {
    float32x2_t v86 = 0;
    char v52 = 1;
    goto LABEL_70;
  }
  long long v91 = (size_t *)a4;
  unint64_t v48 = 0;
  unint64_t v49 = 0;
  unsigned int v92 = 0x3010200u >> ((*((_DWORD *)this + 12) >> 3) & 0x18);
  BOOL v50 = v15 != 0;
  BOOL v51 = *(void *)&v14 != 0;
  char v52 = 1;
  do
  {
    if (v51)
    {
      float v53 = *(float *)(*((void *)this + 1) + 16 * v48 + 8);
      if (!v50) {
        goto LABEL_36;
      }
    }
    else
    {
      float v53 = INFINITY;
      if (!v50)
      {
LABEL_36:
        float v54 = INFINITY;
        goto LABEL_39;
      }
    }
    float v54 = *(float *)(*((void *)a2 + 1) + 16 * v49 + 8);
LABEL_39:
    uint64_t v96 = 0x3C00000000000000;
    __int16 v97 = 0;
    uint64_t v94 = 0x3C00000000000000;
    __int16 v95 = 0;
    if (v53 != v54)
    {
      if (v53 < v54)
      {
        __int16 v57 = *(_WORD *)((char *)this + 53);
        uint64_t v96 = *(void *)(*((void *)this + 1) + 16 * v48);
        __int16 v97 = v57;
        if (v49)
        {
          uint64_t v58 = *((void *)a2 + 1);
          if (*(void *)a2 > v49)
          {
            uint64_t v59 = v58 + 16 * v49;
            float v60 = *(float *)(v59 - 8);
            float v61 = *(float *)(v59 + 8);
            uint64_t v62 = *(void *)(v59 - 16);
            __int16 v63 = *(_WORD *)((char *)a2 + 53);
            uint64_t v100 = v62;
            __int16 v101 = v63;
            if (v60 != v61)
            {
              uint64_t v98 = *(void *)(v58 + 16 * v49);
              __int16 v99 = v63;
              float v64 = v53 - v60;
              *(float *)&unsigned int v65 = v61 - v60;
              float32x2_t v66 = vrecpe_f32((float32x2_t)v65);
              float32x2_t v67 = vmul_f32(vrecps_f32((float32x2_t)v65, v66), v66);
              RB::Fill::Color::mix((uint64_t)&v100, (uint64_t)&v98, v92, v64 * vmul_f32(v67, vrecps_f32((float32x2_t)v65, v67)).f32[0]);
              __int16 v63 = v101;
            }
            goto LABEL_54;
          }
          uint64_t v78 = *(void *)(v58 + 16 * *(void *)a2 - 16);
        }
        else
        {
          uint64_t v78 = **((void **)a2 + 1);
        }
        __int16 v63 = *(_WORD *)((char *)a2 + 53);
        uint64_t v100 = v78;
LABEL_54:
        uint64_t v94 = v100;
        __int16 v95 = v63;
        ++v48;
        goto LABEL_58;
      }
      if (v48)
      {
        uint64_t v68 = *((void *)this + 1);
        if (*(void *)this > v48)
        {
          uint64_t v69 = v68 + 16 * v48;
          float v70 = *(float *)(v69 - 8);
          float v71 = *(float *)(v69 + 8);
          uint64_t v72 = *(void *)(v69 - 16);
          __int16 v73 = *(_WORD *)((char *)this + 53);
          uint64_t v100 = v72;
          __int16 v101 = v73;
          if (v70 != v71)
          {
            uint64_t v98 = *(void *)(v68 + 16 * v48);
            __int16 v99 = v73;
            float v74 = v54 - v70;
            *(float *)&unsigned int v75 = v71 - v70;
            float32x2_t v76 = vrecpe_f32((float32x2_t)v75);
            float32x2_t v77 = vmul_f32(vrecps_f32((float32x2_t)v75, v76), v76);
            RB::Fill::Color::mix((uint64_t)&v100, (uint64_t)&v98, v92, v74 * vmul_f32(v77, vrecps_f32((float32x2_t)v75, v77)).f32[0]);
            __int16 v73 = v101;
          }
          goto LABEL_57;
        }
        uint64_t v79 = *(void *)(v68 + 16 * *(void *)this - 16);
      }
      else
      {
        uint64_t v79 = **((void **)this + 1);
      }
      __int16 v73 = *(_WORD *)((char *)this + 53);
      uint64_t v100 = v79;
LABEL_57:
      uint64_t v96 = v100;
      __int16 v97 = v73;
      __int16 v80 = *(_WORD *)((char *)a2 + 53);
      uint64_t v94 = *(void *)(*((void *)a2 + 1) + 16 * v49);
      __int16 v95 = v80;
      ++v49;
      float v53 = v54;
      goto LABEL_58;
    }
    __int16 v55 = *(_WORD *)((char *)this + 53);
    uint64_t v96 = *(void *)(*((void *)this + 1) + 16 * v48);
    __int16 v97 = v55;
    __int16 v56 = *(_WORD *)((char *)a2 + 53);
    uint64_t v94 = *(void *)(*((void *)a2 + 1) + 16 * v49);
    __int16 v95 = v56;
    ++v48;
    ++v49;
LABEL_58:
    RB::Fill::Color::mix((uint64_t)&v96, (uint64_t)&v94, 0, *(float *)&a3);
    BOOL v81 = *((short float *)&v96 + 3) == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0));
    float32x2_t v82 = v105;
    unint64_t v83 = *(void *)&v105 + 1;
    if (*(void *)&v105 != -1 && v106 < v83) {
      RB::vector<RB::Fill::Gradient::Stop,16ul,unsigned long>::reserve_slow(&__dst, *(void *)&v105 + 1);
    }
    v52 &= v81;
    float32x2_t v105 = (float32x2_t)v83;
    p_dst = (uint64_t *)v104;
    if (!v104) {
      p_dst = &__dst;
    }
    uint64_t v85 = &p_dst[2 * *(void *)&v82];
    *uint64_t v85 = v96;
    *((float *)v85 + 2) = v53;
    *((_DWORD *)v85 + 3) = 1056964608;
    BOOL v50 = v49 < v15;
    BOOL v51 = v48 < *(void *)&v14;
  }
  while (v48 < *(void *)&v14 || v49 < v15);
  float32x2_t v86 = v105;
  if (*(void *)&v105 <= *(void *)this)
  {
LABEL_70:
    *(float32x2_t *)this = v86;
    goto LABEL_71;
  }
  *(float32x2_t *)this = v105;
  unint64_t v87 = (v91[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v88 = v87 + 16 * *(void *)&v86;
  if (v88 > v91[3])
  {
    unint64_t v87 = RB::Heap::alloc_slow(v91, 16 * *(void *)&v86, 7);
    float32x2_t v86 = *(float32x2_t *)this;
  }
  else
  {
    v91[2] = v88;
  }
  *((void *)this + 1) = v87;
LABEL_71:
  uint64_t v89 = v104;
  if (v86)
  {
    if (v104) {
      unint64_t v90 = (uint64_t *)v104;
    }
    else {
      unint64_t v90 = &__dst;
    }
    memmove(*((void **)this + 1), v90, 16 * *(void *)&v86);
    uint64_t v89 = v104;
  }
  *((_DWORD *)this + 12) |= 0x10000u;
  *((unsigned char *)this + 55) = v52;
  if (v89) {
    free(v89);
  }
}

void sub_2141A5664(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54)
{
  if (a54) {
    free(a54);
  }
  _Unwind_Resume(exception_object);
}

BOOL RB::Fill::Gradient::get_alpha(RB::Fill::Gradient *this, float *a2)
{
  unint64_t v2 = *(void *)this;
  if (*(void *)this)
  {
    BOOL v3 = 0;
    uint64_t v4 = 0;
    float v5 = *a2;
    uint64_t v6 = (__int16 *)(*((void *)this + 1) + 6);
    char v7 = 1;
    do
    {
      _H1 = *v6;
      __asm { FCVT            S1, H1 }
      if (v7)
      {
        *a2 = _S1;
        float v5 = _S1;
      }
      else if (v5 != _S1)
      {
        return v3;
      }
      char v7 = 0;
      BOOL v3 = ++v4 >= v2;
      v6 += 8;
    }
    while (v2 != v4);
  }
  else
  {
    return 1;
  }
  return v3;
}

float RB::Fill::Gradient::interpolation_factor(uint64_t a1, uint64_t a2, uint64_t a3, float a4, double a5, double a6, double a7, float a8)
{
  float v8 = *(float *)(a2 + 8);
  float v9 = a4 - v8;
  *(float *)&unsigned int v10 = *(float *)(a3 + 8) - v8;
  float32x2_t v11 = vrecpe_f32((float32x2_t)v10);
  float32x2_t v12 = vrecps_f32((float32x2_t)v10, v11);
  float32x2_t v13 = vmul_f32(v12, v11);
  float32x2_t v14 = vrecps_f32((float32x2_t)v10, v13);
  float v15 = vmul_f32(v13, v14).f32[0];
  float result = v9 * v15;
  if ((*(_DWORD *)(a1 + 48) & 0xF00) == 0x200)
  {
    LOBYTE(v15) = *(unsigned char *)(a2 + 12);
    float v20 = (float)LODWORD(v15);
    v14.i8[0] = *(unsigned char *)(a2 + 13);
    float v21 = (float)v14.u32[0];
    v12.i8[0] = *(unsigned char *)(a2 + 14);
    LOBYTE(a8) = *(unsigned char *)(a2 + 15);
    float v22 = v20 * 0.011765;
    float v23 = (float)((float)v12.u32[0] - v20) * 0.011765;
    *(float *)float32x2_t v25 = v22;
    *(float *)&v25[1] = v23 - v22;
    *(float *)&v25[2] = 1.0 - v23;
    *(float *)&v25[3] = v21 * 0.011765;
    float v24 = (float)((float)LODWORD(a8) - v21) * 0.011765;
    *(float *)&v25[4] = v24 - (float)(v21 * 0.011765);
    *(float *)&v25[5] = 1.0 - v24;
    return RB::BezierTiming::eval((RB::BezierTiming *)v25, result);
  }
  else if ((*(_DWORD *)(a1 + 48) & 0xF00) == 0x100)
  {
    float v17 = *(float *)(a2 + 12);
    if (v17 != 0.5)
    {
      float v18 = fmaxf(result, 0.0);
      if (v17 >= 1.0) {
        float v19 = 65536.0;
      }
      else {
        float v19 = -0.69315 / logf(*(float *)(a2 + 12));
      }
      return powf(v18, v19);
    }
  }
  return result;
}

unint64_t RB::Fill::Gradient::sample(RB::Fill::Gradient *this, float a2, double a3, double a4, double a5, float a6)
{
  uint64_t v6 = *(void *)this;
  if (*(void *)this)
  {
    uint64_t v8 = 0;
    uint64_t v9 = v6 - 1;
    uint64_t v10 = *((void *)this + 1);
    while (--v6)
    {
      float32x2_t v11 = (unsigned __int16 *)(v10 + v8);
      if (*(float *)(v10 + v8 + 8) >= a2) {
        goto LABEL_9;
      }
      v8 += 16;
      LODWORD(a3) = *((_DWORD *)v11 + 6);
      if (*(float *)&a3 > a2)
      {
        float v12 = RB::Fill::Gradient::interpolation_factor((uint64_t)this, v10 + v8 - 16, v10 + v8, a2, a3, a4, a5, a6);
        float32x2_t v13 = (uint64_t *)(*((void *)this + 1) + v8);
        uint64_t v20 = *(v13 - 2);
        __int16 v21 = 0;
        uint64_t v18 = *v13;
        __int16 v19 = 0;
        RB::Fill::Color::mix((uint64_t)&v20, (uint64_t)&v18, (0x3010200u >> ((*((_DWORD *)this + 12) >> 3) & 0x18)) & 3, v12);
        LODWORD(v6) = (unsigned __int16)v20;
        unsigned int v14 = WORD1(v20);
        uint64_t v15 = WORD2(v20);
        uint64_t v16 = HIWORD(v20);
        return (v15 << 32) | (v16 << 48) | ((unint64_t)v14 << 16) | v6;
      }
    }
    float32x2_t v11 = (unsigned __int16 *)(v10 + 16 * v9);
LABEL_9:
    LODWORD(v6) = *v11;
    unsigned int v14 = v11[1];
    uint64_t v15 = v11[2];
    uint64_t v16 = v11[3];
  }
  else
  {
    unsigned int v14 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
  }
  return (v15 << 32) | (v16 << 48) | ((unint64_t)v14 << 16) | v6;
}

float RB::Fill::Gradient::sample_alpha(RB::Fill::Gradient *this, float a2, double a3, double a4, double a5, float a6)
{
  uint64_t v6 = *(void *)this;
  if (!*(void *)this) {
    return 0.0;
  }
  uint64_t v8 = 0;
  uint64_t v9 = v6 - 1;
  uint64_t v10 = *((void *)this + 1);
  while (1)
  {
    if (!--v6)
    {
      _H0 = *(_WORD *)(v10 + 16 * v9 + 6);
      goto LABEL_10;
    }
    uint64_t v11 = v10 + v8;
    if (*(float *)(v10 + v8 + 8) >= a2) {
      break;
    }
    v8 += 16;
    LODWORD(a3) = *(_DWORD *)(v11 + 24);
    if (*(float *)&a3 > a2)
    {
      float v12 = RB::Fill::Gradient::interpolation_factor((uint64_t)this, v10 + v8 - 16, v10 + v8, a2, a3, a4, a5, a6);
      uint64_t v13 = *((void *)this + 1) + v8;
      _H1 = *(_WORD *)(v13 - 10);
      _H2 = *(_WORD *)(v13 + 6);
      __asm
      {
        FCVT            S1, H1
        FCVT            S2, H2
      }
      return _S1 + (float)((float)(_S2 - _S1) * v12);
    }
  }
  _H0 = *(_WORD *)(v11 + 6);
LABEL_10:
  __asm { FCVT            S0, H0 }
  return result;
}

uint64_t RB::Fill::Gradient::is_opaque(float32x2_t *this)
{
  if (!this[6].i8[7]) {
    return 0;
  }
  if (this[6].i8[4] != 1) {
    return 1;
  }
  uint32x2_t v1 = (uint32x2_t)vceq_f32(this[3], this[4]);
  return vpmin_u32(v1, v1).u32[0] >> 31;
}

float32x2_t RB::Fill::Gradient::set_gradient(float32x2_t *a1, uint64_t a2, uint64_t a3, float64x2_t *a4, double a5)
{
  RB::Fill::Gradient::set_gradient_color((uint64_t)a1, (float16x4_t *)(a2 + 36), a3, a5);
  return RB::Fill::Gradient::set_gradient_geometry(a1, (float32x2_t *)a2, a4, a3);
}

void RB::Fill::Gradient::set_gradient_color(uint64_t a1, float16x4_t *a2, uint64_t a3, double _D0)
{
  uint64_t v107 = *MEMORY[0x263EF8340];
  int v6 = *(unsigned __int8 *)(a3 + 124);
  if (*(unsigned char *)(a1 + 54)) {
    __int16 v7 = *(unsigned __int8 *)(a1 + 53);
  }
  else {
    __int16 v7 = *(unsigned __int8 *)(a3 + 124);
  }
  unsigned int v8 = *(_DWORD *)(a1 + 48);
  int v9 = v8 & 0xC0;
  switch(v9)
  {
    case 64:
      char v11 = 0;
LABEL_12:
      int v10 = v6 & 0xFE;
      goto LABEL_13;
    case 192:
      char v11 = 1;
      goto LABEL_12;
    case 128:
      int v10 = v6 | 1;
      break;
    default:
      int v10 = *(unsigned __int8 *)(a3 + 124);
      break;
  }
  char v11 = 0;
LABEL_13:
  uint64_t v96 = (RB::RenderFrame ***)a3;
  float v102 = *(float *)&_D0;
  unsigned __int8 v103 = v10;
  char v104 = v11;
  uint64_t v12 = *(void *)a1;
  uint64_t v13 = *(float **)(a1 + 8);
  if ((v8 & 0xF00) == 0x200 && (unint64_t)v12 >= 2)
  {
    if (v18 >> 60) {
      return;
    }
    unint64_t v19 = v18;
    if (16 * v18 <= 0x1000)
    {
      MEMORY[0x270FA5388](v18, 16 * v18);
      uint64_t v16 = (float *)&v93[-((v21 + 15) & 0xFFFFFFFFFFFFFFF0)];
      bzero(v16, v21);
      int v94 = 0;
    }
    else
    {
      uint64_t v16 = (float *)malloc_type_malloc(16 * v18, 0xE11EEA50uLL);
      if (!v16) {
        goto LABEL_106;
      }
      int v94 = 1;
    }
    unsigned int v8 = v8 & 0xFFFEF0FF | 0x10100;
    uint64_t v15 = (unsigned char *)(a1 + 52);
    if (*(unsigned char *)(a1 + 52) != 4)
    {
      __int16 v95 = a2;
      uint64_t v12 = v19;
      __int16 v7 = v10;
      uint64_t v13 = v16;
      int v20 = v94;
      goto LABEL_45;
    }
    *(float *)&_D0 = RB::Fill::Gradient::angular_location_function((RB::Fill::Gradient *)a1);
    if (!v19)
    {
      uint64_t v12 = 0;
      __int16 v7 = v10;
      goto LABEL_39;
    }
    uint64_t v12 = v19;
    __int16 v7 = v10;
LABEL_35:
    uint64_t v22 = 2;
    uint64_t v23 = v12;
    int v20 = v94;
    do
    {
      v16[v22] = v17 + (float)(v16[v22] * *(float *)&_D0);
      v22 += 4;
      --v23;
    }
    while (v23);
    goto LABEL_40;
  }
  uint64_t v15 = (unsigned char *)(a1 + 52);
  if (*(unsigned char *)(a1 + 52) != 4)
  {
    __int16 v95 = a2;
    uint64_t v16 = 0;
    int v20 = 0;
    goto LABEL_45;
  }
  if ((unint64_t)v12 >> 60) {
    return;
  }
  if ((unint64_t)(16 * v12) <= 0x1000)
  {
    MEMORY[0x270FA5388](a1, a2);
    uint64_t v16 = (float *)&v93[-((16 * v12 + 15) & 0xFFFFFFFFFFFFFFF0)];
    bzero(v16, 16 * v12);
    int v94 = 0;
    if (!v12) {
      goto LABEL_22;
    }
    goto LABEL_34;
  }
  uint64_t v16 = (float *)malloc_type_malloc(16 * v12, 0xAFA685DAuLL);
  if (!v16)
  {
LABEL_106:
    free(v16);
    return;
  }
  int v94 = 1;
  if (v12)
  {
LABEL_34:
    memmove(v16, v13, 16 * v12);
    *(float *)&_D0 = RB::Fill::Gradient::angular_location_function((RB::Fill::Gradient *)a1);
    goto LABEL_35;
  }
LABEL_22:
  *(float *)&_D0 = RB::Fill::Gradient::angular_location_function((RB::Fill::Gradient *)a1);
LABEL_39:
  int v20 = v94;
LABEL_40:
  __int16 v95 = a2;
  if ((v8 & 0xF00) == 0x100)
  {
    uint64_t v24 = v12 - 1;
    if (v12 != 1)
    {
      uint64_t v25 = 0;
      float v26 = v16[2];
      do
      {
        float v27 = v16[v25 + 6];
        v16[v25 + 3] = (float)((float)(v17 - v26)
                             + (float)((float)(v16[v25 + 3]
                                             + (float)((float)(*(float *)(*(void *)(a1 + 8) + v25 * 4 + 8)
                                                             - v16[v25 + 3])
                                                     * *(float *)(*(void *)(a1 + 8) + v25 * 4 + 24)))
                                     * *(float *)&_D0))
                     / (float)(v27 - v26);
        v25 += 4;
        float v26 = v27;
        --v24;
      }
      while (v24);
    }
  }
  v8 |= 0x10000u;
  uint64_t v13 = v16;
LABEL_45:
  int v28 = v8 & 0xF00;
  unint64_t v29 = v12 - 1;
  unint64_t v30 = 3;
  if (v28 == 1024)
  {
    unint64_t v31 = v12 - 1;
  }
  else
  {
    unint64_t v30 = 6;
    unint64_t v31 = v12;
  }
  v99[0] = (uint64_t)&v102;
  v99[1] = v31;
  v99[2] = (uint64_t)v13;
  char v100 = v7;
  unsigned int v101 = v8;
  if (*(void *)a1 != 2
    || (*(_DWORD *)(a1 + 48) & 0x10000) != 0
    || *v15 == 4
    || (((*(_DWORD *)(a1 + 48) & 0xF00) - 512) & 0xFFFFFDFF) == 0)
  {
    if ((v8 & 0x10000) != 0)
    {
      uint64_t v54 = 16;
      if (v28 == 1024) {
        uint64_t v54 = 36;
      }
      if (v31 <= v30) {
        unint64_t v31 = v30;
      }
      RB::RenderFrame::alloc_buffer_region(**v96, (RB::Device *)(v31 * v54), 2uLL, 0, &v97);
      if (v97)
      {
        uint64_t v56 = *((void *)v97 + 7);
        if (v28 == 1024)
        {
          uint64_t v57 = v56 + v98.i64[0];
          if (v12 - 2 >= 0)
          {
            float v58 = v13[4 * v29 + 2];
            uint64_t v59 = (_WORD *)(v98.i64[0] + 36 * v12 + v56 - 72);
            float v60 = &v13[4 * v12 - 6];
            uint64_t v61 = v12 - 1;
            do
            {
              float v62 = *v60;
              v60 -= 4;
              float v63 = v62;
              _S2 = 1.0 / (float)(v58 - v62);
              if ((LODWORD(_S2) & 0x7FFFFFFFu) >= 0x7F800000) {
                _S2 = 65504.0;
              }
              _S4 = -(float)(v63 * _S2);
              __asm { FCVT            H2, S2 }
              *uint64_t v59 = _H2;
              __asm { FCVT            H2, S4 }
              v59[1] = _H2;
              v59 -= 18;
              float v58 = v63;
              --v61;
            }
            while (v61);
          }
          RB::Fill::Gradient::set_gradient_color(RB::Shader::GradientGlobals::Color &,float,RB::RenderPass &)const::$_1::operator()(v99, (float16x4_t *)(v57 + 4), 36, 0);
        }
        else if ((v29 & 0x8000000000000000) == 0)
        {
          __int16 v77 = v7 | 0x100;
          uint64_t v78 = &v13[4 * v12 - 2];
          uint64_t v79 = (uint16x4_t *)(v98.i64[0] + 16 * v12 + v56 - 8);
          float v80 = 1.0;
          do
          {
            float v81 = v80;
            float v80 = *v78;
            _S0 = 1.0 / (float)(v81 - *v78);
            if ((LODWORD(_S0) & 0x7FFFFFFFu) >= 0x7F800000) {
              _S0 = 65504.0;
            }
            _S1 = -(float)(v80 * _S0);
            __asm { FCVT            H0, S0 }
            v79[-1].i16[0] = _H0;
            __asm { FCVT            H0, S1 }
            v79[-1].i16[1] = _H0;
            _D0.i32[0] = 1.0;
            if (v28 == 256)
            {
              float v86 = v78[1];
              if (v86 >= 1.0) {
                _D0.i32[0] = 1199570944;
              }
              else {
                *(float *)_D0.i32 = -0.69315 / logf(v86);
              }
            }
            __asm { FCVT            H0, S0 }
            v79[-1].i16[2] = _D0.i16[0];
            __int16 v87 = *((_WORD *)v78 - 1);
            v105.i32[0] = *(__int32 *)(v78 - 2);
            v105.i16[2] = *((_WORD *)v78 - 2);
            __int16 v106 = v77;
            _H1 = v87;
            __asm { FCVT            S1, H1 }
            *(float *)_D0.i32 = v102 * _S1;
            __asm { FCVT            H0, S0 }
            v105.i16[3] = _D0.i16[0];
            RB::Fill::Color::convert((uint64_t)&v105, v103, _D0);
            if (v104) {
              RB::Fill::Color::convert_to_oklab((RB::Fill::Color *)&v105);
            }
            v90.i32[0] = v105.i32[0];
            v90.i16[2] = v105.i16[2];
            v90.i16[3] = COERCE_UNSIGNED_INT(1.0);
            _D0 = (uint16x4_t)vmul_n_f16(v90, *(short float *)&v105.i16[3]);
            *uint64_t v79 = _D0;
            v79 -= 2;
            --v12;
            v78 -= 4;
          }
          while (v12 > 0);
        }
        long long v91 = (int32x2_t *)v96;
        v91[27].i32[1] = RB::RenderFrame::buffer_id(**v96, v97);
        v91[28] = vmovn_s64(v98);
      }
    }
    else
    {
      uint64_t v47 = 4;
      if (v28 == 256) {
        uint64_t v47 = 5;
      }
      if (v28 == 1024) {
        uint64_t v48 = 16;
      }
      else {
        uint64_t v48 = v47;
      }
      unint64_t v49 = v96;
      RB::RenderFrame::alloc_buffer_region(**v96, (RB::Device *)(2 * v48 * v31 + 2 * v48), 2uLL, 0, &v97);
      if (v97)
      {
        if (v28 == 1024)
        {
          float16x4_t v105 = 0;
          BOOL v51 = (float16x4_t *)(*((void *)v97 + 7) + v98.i64[0]);
          RB::Fill::Gradient::set_gradient_color(RB::Shader::GradientGlobals::Color &,float,RB::RenderPass &)const::$_1::operator()(v99, v51, 32, &v105);
          char v52 = &v51[4 * v29];
          *char v52 = v105;
          v52[2] = 0;
          v52[3] = 0;
          v52[1] = 0;
          float v53 = v95;
        }
        else
        {
          int v94 = v20;
          uint64_t v68 = (char *)(*((void *)v97 + 7) + v98.i64[0]);
          if (v12)
          {
            __int16 v69 = v7 | 0x100;
            float v70 = (char *)v13 + 6;
            do
            {
              __int16 v71 = *(_WORD *)v70;
              v105.i32[0] = *(_DWORD *)(v70 - 6);
              v105.i16[2] = *((_WORD *)v70 - 1);
              __int16 v106 = v69;
              _H1 = v71;
              __asm { FCVT            S1, H1 }
              *(float *)_D0.i32 = v102 * _S1;
              __asm { FCVT            H0, S0 }
              v105.i16[3] = _D0.i16[0];
              RB::Fill::Color::convert((uint64_t)&v105, v103, _D0);
              if (v104) {
                RB::Fill::Color::convert_to_oklab((RB::Fill::Color *)&v105);
              }
              v74.i32[0] = v105.i32[0];
              v74.i16[2] = v105.i16[2];
              v74.i16[3] = COERCE_UNSIGNED_INT(1.0);
              _D0 = (uint16x4_t)vmul_n_f16(v74, *(short float *)&v105.i16[3]);
              *(uint16x4_t *)uint64_t v68 = _D0;
              if (v28 == 256)
              {
                float v75 = *(float *)(v70 + 6);
                if (v75 >= 1.0) {
                  _D0.i32[0] = 1199570944;
                }
                else {
                  *(float *)_D0.i32 = -0.69315 / logf(v75);
                }
                __asm { FCVT            H0, S0 }
                *((_WORD *)v68 + 4) = _H0;
              }
              v70 += 16;
              v68 += 2 * v48;
              --v12;
            }
            while (v12);
          }
          memcpy(v68, &v68[-2 * v48], 2 * v48);
          float v53 = v95;
          unint64_t v49 = v96;
          int v20 = v94;
        }
        __int16 v95 = v53;
        *(short float *)v53[2].i16 = (short float)v29;
        *((_DWORD *)v49 + 55) = RB::RenderFrame::buffer_id(**v49, v97);
        v49[28] = (RB::RenderFrame **)vmovn_s64(v98);
      }
    }
    unsigned int v92 = v95;
  }
  else
  {
    uint64_t v32 = *((unsigned __int16 *)v13 + 3);
    __int16 v97 = (RB::Buffer *)(*(unsigned int *)v13 | ((unint64_t)*((unsigned __int16 *)v13 + 2) << 32) | (v32 << 48));
    v98.i16[0] = v7 | 0x100;
    _H1 = v32;
    __asm { FCVT            S1, H1 }
    *(float *)&_D0 = v102 * _S1;
    __asm { FCVT            H0, S0 }
    HIWORD(v97) = LOWORD(_D0);
    RB::Fill::Color::convert((uint64_t)&v97, v103, *(uint16x4_t *)&_D0);
    if (v104) {
      RB::Fill::Color::convert_to_oklab((RB::Fill::Color *)&v97);
    }
    v38.i32[0] = (int)v97;
    v38.i16[2] = WORD2(v97);
    v38.i16[3] = COERCE_UNSIGNED_INT(1.0);
    _D0 = (uint16x4_t)vmul_n_f16(v38, *((short float *)&v97 + 3));
    *__int16 v95 = (float16x4_t)_D0;
    uint64_t v40 = *((unsigned __int16 *)v13 + 11);
    __int16 v97 = (RB::Buffer *)(*((unsigned int *)v13 + 4) | ((unint64_t)*((unsigned __int16 *)v13 + 10) << 32) | (v40 << 48));
    v98.i16[0] = v7 | 0x100;
    _H1 = v40;
    __asm { FCVT            S1, H1 }
    *(float *)_D0.i32 = v102 * _S1;
    __asm { FCVT            H0, S0 }
    HIWORD(v97) = _D0.i16[0];
    RB::Fill::Color::convert((uint64_t)&v97, v103, _D0);
    if (v104) {
      RB::Fill::Color::convert_to_oklab((RB::Fill::Color *)&v97);
    }
    v43.i32[0] = (int)v97;
    _H0 = COERCE_UNSIGNED_INT(1.0);
    v43.i16[2] = WORD2(v97);
    v43.i16[3] = COERCE_UNSIGNED_INT(1.0);
    v95[1] = vmul_n_f16(v43, *((short float *)&v97 + 3));
    if (v28 == 256)
    {
      float v45 = v13[3];
      if (v45 >= 1.0)
      {
        _H0 = 31744;
      }
      else
      {
        _S0 = -0.69315 / logf(v45);
        __asm { FCVT            H0, S0 }
      }
    }
    unsigned int v92 = v95;
    v95[2].i16[0] = _H0;
  }
  v92[2].i16[1] = v29;
  if (v20) {
    goto LABEL_106;
  }
}

void sub_2141A6370(_Unwind_Exception *exception_object)
{
  *(_DWORD *)(v3 - 220) = v2;
  if (*(_DWORD *)(v3 - 220)) {
    free(v1);
  }
  _Unwind_Resume(exception_object);
}

float32x2_t RB::Fill::Gradient::set_gradient_geometry(float32x2_t *a1, float32x2_t *a2, float64x2_t *a3, uint64_t a4)
{
  float64x2_t v7 = a3[1];
  float64x2_t v87 = *a3;
  float64x2_t v88 = v7;
  float64x2_t v89 = a3[2];
  unsigned int v8 = (float64x2_t *)a1[2];
  if (v8)
  {
    v9.f64[0] = RB::operator*(v8, &v87);
    float64x2_t v87 = v9;
    float64x2_t v88 = v10;
    float64x2_t v89 = v11;
  }
  RB::AffineTransform::invert((RB::AffineTransform *)&v87);
  switch(a1[6].i8[4])
  {
    case 0:
      float32x2_t v16 = a1[3];
      float32x2_t v17 = vsub_f32(a1[4], v16);
      int32x2_t v18 = (int32x2_t)vmul_f32(v17, v17);
      v18.i32[0] = vadd_f32((float32x2_t)v18, (float32x2_t)vdup_lane_s32(v18, 1)).u32[0];
      float32x2_t v19 = vrsqrte_f32((float32x2_t)v18.u32[0]);
      float32x2_t v20 = vmul_f32(vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v19, v19)), v19);
      *(float *)v18.i32 = vmul_f32(v20, vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v20, v20))).f32[0];
      float32x2_t v21 = vmul_n_f32(v17, *(float *)v18.i32);
      float64x2_t v89 = vsubq_f64(v89, vcvtq_f64_f32(v16));
      *(double *)&uint64_t v22 = vmuls_lane_f32(-*(float *)v18.i32, v21, 1);
      int8x16_t v23 = (int8x16_t)vcvtq_f64_f32(vmul_n_f32(v21, *(float *)v18.i32));
      int8x16_t v24 = vextq_s8(v23, v23, 8uLL);
      v23.i64[1] = v22;
      float64x2_t v83 = (float64x2_t)v23;
      int8x16_t v84 = v24;
      uint64_t v85 = 0;
      uint64_t v86 = 0;
      v25.f64[0] = RB::operator*(&v87, &v83);
      float64x2_t v87 = v25;
      float64x2_t v88 = v26;
      float64x2_t v89 = v27;
      break;
    case 1:
      float32x2_t v28 = a1[3];
      *(float32x2_t *)v12.i8 = a1[4];
      uint32x2_t v29 = (uint32x2_t)vceq_f32(v28, *(float32x2_t *)v12.i8);
      if ((vpmin_u32(v29, v29).u32[0] & 0x80000000) != 0)
      {
        float64x2_t v89 = vsubq_f64(v89, vcvtq_f64_f32(v28));
        float v37 = a1[5].f32[0];
        float v38 = a1[5].f32[1];
        *(float *)v12.i32 = v37 - v38;
        v13.i64[0] = 0x3C0000003C000000;
        v39.i64[0] = 0x8000000080000000;
        v39.i64[1] = 0x8000000080000000;
        unsigned __int32 v40 = vbslq_s8(v39, v13, v12).u32[0];
        if (vabds_f32(v37, v38) >= 0.0078125) {
          float v41 = v37 - v38;
        }
        else {
          float v41 = *(float *)&v40;
        }
        float v36 = v37 / v41;
        a2[3].f32[0] = -1.0 / v41;
        goto LABEL_16;
      }
      float v30 = a1[5].f32[1];
      if (v30 == 0.0)
      {
        float32x2_t v31 = a1[3];
        float32x2_t v28 = a1[4];
        float v32 = a1[5].f32[1];
      }
      else
      {
        float v32 = a1[5].f32[0];
        float32x2_t v31 = a1[4];
      }
      float v42 = fabsf(v32);
      uint64_t v43 = 11;
      if (v30 == 0.0) {
        uint64_t v43 = 10;
      }
      float v44 = fabsf(a1->f32[v43]);
      *(float *)v14.i32 = v42 - v44;
      v15.i64[0] = 0x3C0000003C000000;
      v45.i64[0] = 0x8000000080000000;
      v45.i64[1] = 0x8000000080000000;
      LODWORD(v46) = vbslq_s8(v45, v15, v14).u32[0];
      if (vabds_f32(v42, v44) < 0.0078125) {
        *(float *)v14.i32 = v46;
      }
      float v47 = v42 / *(float *)v14.i32;
      float32x2_t v48 = vmla_n_f32(v28, vsub_f32(v31, v28), v42 / *(float *)v14.i32);
      uint32x2_t v49 = (uint32x2_t)vceq_f32(v48, v31);
      if ((vpmin_u32(v49, v49).u32[0] & 0x80000000) == 0)
      {
        float32x2_t v50 = vsub_f32(v31, v48);
        int32x2_t v51 = (int32x2_t)vmul_f32(v50, v50);
        v51.i32[0] = vadd_f32((float32x2_t)v51, (float32x2_t)vdup_lane_s32(v51, 1)).u32[0];
        float32x2_t v52 = vrsqrte_f32((float32x2_t)v51.u32[0]);
        float32x2_t v53 = vmul_f32(vrsqrts_f32((float32x2_t)v51.u32[0], vmul_f32(v52, v52)), v52);
        *(float *)v51.i32 = vmul_f32(v53, vrsqrts_f32((float32x2_t)v51.u32[0], vmul_f32(v53, v53))).f32[0];
        float32x2_t v54 = vmul_n_f32(v50, *(float *)v51.i32);
        *(double *)&uint64_t v55 = vmuls_lane_f32(-*(float *)v51.i32, v54, 1);
        int8x16_t v56 = (int8x16_t)vcvtq_f64_f32(vmul_n_f32(v54, *(float *)v51.i32));
        int8x16_t v57 = vextq_s8(v56, v56, 8uLL);
        v56.i64[1] = v55;
        float64x2_t v89 = vsubq_f64(v89, vcvtq_f64_f32(v48));
        float64x2_t v83 = (float64x2_t)v56;
        int8x16_t v84 = v57;
        float v81 = v44 * *(float *)v51.i32;
        float v82 = v47;
        uint64_t v85 = 0;
        uint64_t v86 = 0;
        v58.f64[0] = RB::operator*(&v87, &v83);
        float v47 = v82;
        float v44 = 1.0;
        *(float *)v61.i32 = (float)(v81 * v81) + -1.0;
        float v62 = fabsf(*(float *)v61.i32);
        _NF = v62 < 0.0001;
        float32x2_t v64 = (float32x2_t)__PAIR64__(COERCE_UNSIGNED_INT(sqrtf(v62)), LODWORD(v81));
        float v65 = vabds_f32(1.0, v82);
        double v66 = COERCE_DOUBLE(vdiv_f32(vmul_n_f32(v64, v65), (float32x2_t)vdup_lane_s32(v61, 0)));
        *(float *)v67.i32 = v65 * 0.5;
        double v68 = COERCE_DOUBLE(vdup_lane_s32(v67, 0));
        if (_NF) {
          double v66 = v68;
        }
        else {
          float v44 = v81;
        }
        float64x2_t v69 = vcvtq_f64_f32(*(float32x2_t *)&v66);
        float64x2_t v87 = vmulq_f64(v58, v69);
        float64x2_t v88 = vmulq_f64(v59, v69);
        float64x2_t v89 = vmulq_f64(v60, v69);
      }
      a2[3].f32[0] = v47;
      a2[3].f32[1] = v44;
      float v70 = 0.0;
      if (v30 == 0.0) {
        float v70 = 1.0;
      }
      a2[4].f32[0] = v70;
      break;
    case 2:
      float v33 = a1[5].f32[0];
      goto LABEL_13;
    case 4:
      float v34 = a1[5].f32[0];
      float v33 = a1[5].f32[1];
      float v35 = vabds_f32(v33, v34);
      if (v35 <= 6.2832)
      {
        if (v33 >= v34) {
          float v33 = a1[5].f32[0];
        }
        float v33 = (float)(v33 + -3.1416) + (float)(v35 * 0.5);
      }
LABEL_13:
      float64x2_t v89 = vsubq_f64(v89, vcvtq_f64_f32(a1[3]));
      float v36 = v33 + (float)(floorf(v33 * 0.15915) * -6.2832);
      if (v36 > 3.1416) {
        float v36 = v36 + -6.2832;
      }
      a2[3].f32[0] = v36 * -0.15915;
LABEL_16:
      a2[3].f32[1] = v36;
      break;
    default:
      break;
  }
  uint64_t v71 = *(void *)(a4 + 104);
  v72.i64[0] = (int)v71;
  v72.i64[1] = SHIDWORD(v71);
  __asm { FMOV            V1.2D, #0.5 }
  float64x2_t v77 = vmulq_f64(vcvtq_f64_s64(v72), _Q1);
  float64x2_t v78 = vmulq_n_f64(v87, v77.f64[0]);
  float64x2_t v79 = vmlaq_laneq_f64(vaddq_f64(v78, v89), v88, v77, 1);
  *(float32x2_t *)&v77.f64[0] = vcvt_f32_f64(v78);
  *(float32x2_t *)&v78.f64[0] = vcvt_f32_f64(vmulq_n_f64(v88, -v77.f64[1]));
  *a2 = *(float32x2_t *)&v77.f64[0];
  a2[1] = *(float32x2_t *)&v78.f64[0];
  float32x2_t result = vcvt_f32_f64(v79);
  a2[2] = result;
  return result;
}

uint64_t RB::Fill::anonymous namespace'::count_subdivided_cubic_stops(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result - 1;
  if (result != 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = (unsigned __int8 *)(a2 + 14);
    float32x2_t v5 = (float32x2_t)vdup_n_s32(0x3B808081u);
    __asm { FMOV            V1.2S, #1.0 }
    do
    {
      v11.i32[0] = *(v4 - 2);
      v11.i32[1] = *(v4 - 1);
      v12.i32[0] = *v4;
      v12.i32[1] = v4[1];
      uint32x2_t v13 = (uint32x2_t)vorn_s8(vmvn_s8((int8x8_t)vceq_f32(vmul_f32(vcvt_f32_u32(v12), v5), _D1)), (int8x8_t)vceqz_f32(vmul_f32(vcvt_f32_u32(v11), v5)));
      if (vpmax_u32(v13, v13).i32[0] >= 0) {
        ++v3;
      }
      else {
        v3 += 4;
      }
      v4 += 16;
      --v2;
    }
    while (v2);
    return v3 + 1;
  }
  return result;
}

void RB::Fill::anonymous namespace'::subdivide_cubic_stops(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4, int a5)
{
  if (a1)
  {
    unint64_t v8 = 0;
    uint64_t v9 = 0;
    unint64_t v10 = a1 - 1;
    __int16 v46 = a4 | 0x100;
    float32x2_t v11 = (float32x2_t)vdup_n_s32(0x3B808081u);
    __asm { FMOV            V8.2S, #1.0 }
    do
    {
      float32x2_t v17 = (uint64_t *)(a2 + 16 * v8);
      if (v8 < v10
        && (v18.i32[0] = *((unsigned __int8 *)v17 + 12),
            v18.i32[1] = *((unsigned __int8 *)v17 + 13),
            float32x2_t v19 = vmul_f32(vcvt_f32_u32(v18), v11),
            v18.i32[0] = *((unsigned __int8 *)v17 + 14),
            v18.i32[1] = *((unsigned __int8 *)v17 + 15),
            uint32x2_t v20 = (uint32x2_t)vorn_s8(vmvn_s8((int8x8_t)vceq_f32(vmul_f32(vcvt_f32_u32(v18), v11), _D8)), (int8x8_t)vceqz_f32(v19)), (vpmax_u32(v20, v20).u32[0] & 0x80000000) != 0))
      {
        _ZN2RB13CubicIteratorIDv2_fEC1ES1_S1_S1_S1_i(&v59, 8);
        uint64_t v57 = *v17;
        __int16 v58 = v46;
        unint64_t v23 = v8 + 1;
        uint64_t v24 = a2 + 16 * (v8 + 1);
        uint16x4_t v55 = *(uint16x4_t *)v24;
        __int16 v56 = v46;
        RB::Fill::Color::convert((uint64_t)&v57, a5, v55);
        RB::Fill::Color::convert((uint64_t)&v55, a5, v25);
        uint64_t v28 = 0;
        float v29 = *(float *)(a2 + 16 * v8 + 8);
        float v30 = *(float *)(v24 + 8) - v29;
        float v31 = vmlas_n_f32(v29, v30, v59.f32[0]);
        uint64_t v22 = v9 + 4;
        uint64_t v32 = a3 + 16 * v9;
        do
        {
          float v33 = v59.f32[1];
          *(float32x2_t *)&long long v26 = v60;
          float32x2_t v52 = vadd_f32(v60, v59);
          long long v49 = v26;
          float v50 = v59.f32[0];
          *(float32x2_t *)&long long v26 = vadd_f32(v61, v60);
          float32x2_t v34 = vadd_f32(v62, v61);
          *(float32x2_t *)&long long v27 = vadd_f32(*(float32x2_t *)&v26, v52);
          long long v51 = v27;
          long long v48 = v26;
          float32x2_t v59 = (float32x2_t)v27;
          float32x2_t v60 = vadd_f32(v34, *(float32x2_t *)&v26);
          float32x2_t v61 = vadd_f32(v34, v62);
          uint64_t v53 = v57;
          __int16 v54 = v58;
          float v35 = v33;
          RB::Fill::Color::mix((uint64_t)&v53, (uint64_t)&v55, 0, v33);
          *((void *)&v27 + 1) = *((void *)&v51 + 1);
          uint64_t v36 = v32 + v28;
          *(void *)uint64_t v36 = v53;
          *(float *)(v36 + 8) = v31;
          float v37 = (float)(*((float *)&v51 + 1) - v35) * 0.5;
          if ((float)(v37 + v35) >= v52.f32[1])
          {
            float32x2_t v41 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(*((float *)&v51 + 1) - v52.f32[1]));
            float32x2_t v42 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(*((float *)&v51 + 1) - v52.f32[1]), v41), v41);
            *((void *)&v26 + 1) = *((void *)&v48 + 1);
            float v40 = vmlas_n_f32(v52.f32[0], (float)((float)(v37 + v35) - v52.f32[1]) * *(float *)&v48, vmul_f32(v42, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(*((float *)&v51 + 1) - v52.f32[1]), v42)).f32[0]);
          }
          else
          {
            float32x2_t v38 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(v52.f32[1] - v35));
            float32x2_t v39 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v52.f32[1] - v35), v38), v38);
            *((void *)&v26 + 1) = *((void *)&v49 + 1);
            float v40 = vmlas_n_f32(v50, v37 * *(float *)&v49, vmul_f32(v39, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v52.f32[1] - v35), v39)).f32[0]);
          }
          float v43 = v29 + (float)(*(float *)&v51 * v30);
          float32x2_t v44 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(v43 - v31));
          float32x2_t v45 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v43 - v31), v44), v44);
          *(float *)(v32 + v28 + 12) = (float)((float)(v29 - v31) + (float)(v40 * v30))
                                     * vmul_f32(v45, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v43 - v31), v45)).f32[0];
          v28 += 16;
          float v31 = v43;
        }
        while (v28 != 64);
      }
      else
      {
        uint64_t v21 = a3 + 16 * v9;
        *(_OWORD *)uint64_t v21 = *(_OWORD *)v17;
        *(_DWORD *)(v21 + 12) = 1056964608;
        uint64_t v22 = v9 + 1;
        unint64_t v23 = v8 + 1;
      }
      unint64_t v8 = v23;
      uint64_t v9 = v22;
    }
    while (v23 != a1);
  }
}

float RB::Fill::Gradient::angular_location_function(RB::Fill::Gradient *this)
{
  float v2 = *((float *)this + 10);
  float v1 = *((float *)this + 11);
  double v3 = vabds_f32(v1, v2);
  if (v3 <= 6.28318531)
  {
    double v6 = v3 * 0.0795774715;
    double v4 = 0.5 - v6;
    float v5 = v6 + 0.5;
  }
  else
  {
    double v4 = v3 * -0.159154943 + 1.0;
    float v5 = 1.0;
  }
  float v7 = v4;
  BOOL v8 = v2 <= v1;
  if (v2 <= v1) {
    float v9 = v7;
  }
  else {
    float v9 = 1.0 - v7;
  }
  if (v8) {
    float v10 = v5;
  }
  else {
    float v10 = 1.0 - v5;
  }
  return v10 - v9;
}

void RB::Fill::Gradient::set_gradient_color(RB::Shader::GradientGlobals::Color &,float,RB::RenderPass &)const::$_1::operator()(uint64_t *a1, float16x4_t *a2, uint64_t a3, float16x4_t *a4)
{
  double v6 = a2;
  unint64_t v8 = a1[1];
  if (v8)
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    float32x2_t v11 = a2;
    do
    {
      uint64_t v12 = *a1;
      _D0 = *(uint16x4_t *)(a1[2] + v9);
      __int16 v14 = *((unsigned __int8 *)a1 + 24) | 0x100;
      *(uint16x4_t *)v43[0].f32 = _D0;
      v43[0].i16[4] = v14;
      _H1 = _D0.i16[3];
      __asm { FCVT            S1, H1 }
      *(float *)_D0.i32 = *(float *)v12 * _S1;
      __asm { FCVT            H0, S0 }
      v43[0].i16[3] = _D0.i16[0];
      RB::Fill::Color::convert((uint64_t)v43, *(unsigned __int8 *)(v12 + 4), _D0);
      if (*(unsigned char *)(v12 + 5)) {
        RB::Fill::Color::convert_to_oklab((RB::Fill::Color *)v43);
      }
      v21.i32[0] = v43[0].i32[0];
      v21.i16[2] = v43[0].i16[2];
      v21.i16[3] = COERCE_UNSIGNED_INT(1.0);
      *float32x2_t v11 = vmul_n_f16(v21, *(short float *)&v43[0].i16[3]);
      ++v10;
      unint64_t v8 = a1[1];
      v9 += 16;
      float32x2_t v11 = (float16x4_t *)((char *)v11 + a3);
    }
    while (v10 < v8);
  }
  uint64_t v22 = *a1;
  _D0 = *(uint16x4_t *)(a1[2] + 16 * v8);
  __int16 v24 = *((unsigned __int8 *)a1 + 24) | 0x100;
  *(uint16x4_t *)v43[0].f32 = _D0;
  v43[0].i16[4] = v24;
  _H1 = _D0.i16[3];
  __asm { FCVT            S1, H1 }
  *(float *)_D0.i32 = *(float *)v22 * _S1;
  __asm { FCVT            H0, S0 }
  v43[0].i16[3] = _D0.i16[0];
  RB::Fill::Color::convert((uint64_t)v43, *(unsigned __int8 *)(v22 + 4), _D0);
  if (*(unsigned char *)(v22 + 5)) {
    RB::Fill::Color::convert_to_oklab((RB::Fill::Color *)v43);
  }
  v29.i32[0] = v43[0].i32[0];
  v29.i16[2] = v43[0].i16[2];
  v29.i16[3] = COERCE_UNSIGNED_INT(1.0);
  float16x4_t v30 = vmul_n_f16(v29, *(short float *)&v43[0].i16[3]);
  unint64_t v31 = a1[1];
  if (v31)
  {
    unint64_t v32 = 0;
    v27.i32[0] = 2;
    v28.i32[0] = *((_DWORD *)a1 + 7) & 7;
    int8x8_t v33 = (int8x8_t)vdup_lane_s32(vceq_s32(v28, v27), 0);
    do
    {
      unint64_t v34 = v32 + 1;
      int8x8_t v35 = (int8x8_t)v30;
      if (v32 + 1 < v31) {
        int8x8_t v35 = *(int8x8_t *)((char *)v6 + a3);
      }
      float16x4_t v36 = *v6;
      if (v32) {
        double v37 = *(double *)((char *)v6 - a3);
      }
      else {
        double v37 = COERCE_DOUBLE(vbsl_s8(v33, v35, (int8x8_t)v36));
      }
      v43[0] = v38;
      v43[1] = v39;
      v43[2] = v40;
      v43[3] = v41;
      v42[0] = v6;
      v42[1] = v6 + 1;
      v42[2] = v6 + 2;
      v42[3] = v6 + 3;
      _ZNSt3__127__memberwise_forward_assignB8nn180100INS_5tupleIJRN2RB12packed_half4ES4_S4_S4_EEENS1_IJDv4_fS6_S6_S6_EEEJS6_S6_S6_S6_EJLm0ELm1ELm2ELm3EEEEvRT_OT0_NS_13__tuple_typesIJDpT1_EEENS_15__tuple_indicesIJXspT2_EEEE(v42, v43);
      unint64_t v31 = a1[1];
      double v6 = (float16x4_t *)((char *)v6 + a3);
      unint64_t v32 = v34;
    }
    while (v34 < v31);
  }
  if (a4) {
    *a4 = v30;
  }
}

uint64_t RB::Fill::Gradient::set_fill_state(uint64_t a1, int *a2, uint64_t a3, float a4)
{
  unint64_t v8 = *(void *)a1;
  unsigned int v9 = *(unsigned __int8 *)(a1 + 52);
  int v10 = *(_DWORD *)(a1 + 48);
  if ((v10 & 0xF00) == 0x200 && v8 >= 2)
  {
    unsigned int v12 = v10 & 0xFFFEF0FF | 0x10100;
  }
  else
  {
    unsigned int v12 = *(_DWORD *)(a1 + 48);
    uint64_t result = *(void *)a1;
  }
  int v14 = v12 | 0x10000;
  if (v9 == 4)
  {
    unsigned int v15 = 2;
  }
  else
  {
    int v14 = v12;
    unsigned int v15 = v9;
  }
  if ((v14 & 4) != 0) {
    unsigned int v16 = v14 & 0xFFFFFFF8 | 3;
  }
  else {
    unsigned int v16 = v14;
  }
  int v17 = v16 & 0xF00;
  uint64_t v18 = (v16 & 7) + 4 * v15;
  if (v15 == 1)
  {
    uint32x2_t v19 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)(a1 + 24), *(float32x2_t *)(a1 + 32)));
    if (vpmax_u32(v19, v19).i32[0] < 0) {
      v18 += 12;
    }
  }
  unint64_t v20 = 6;
  if (v17 == 1024) {
    unint64_t v20 = 3;
  }
  if (v9 == 4 || v8 != 2 || (v10 & 0x10000) != 0 || (((v10 & 0xF00) - 512) & 0xFFFFFD00) == 0)
  {
    if (result - (unint64_t)(v17 == 1024) <= v20) {
      int v22 = 128;
    }
    else {
      int v22 = 256;
    }
    if ((v16 & 0x10000) != 0) {
      int v21 = v22;
    }
    else {
      int v21 = 384;
    }
  }
  else
  {
    int v21 = 0;
  }
  int v23 = ((v17 == 1024) << 9) | ((v17 == 256) << 10) | v21 | (8 * (dword_214219FE0[v18] & 0xF));
  int v24 = v10 & 0xC0;
  if (v24 == 64) {
    goto LABEL_34;
  }
  if (v24 == 192)
  {
    LOWORD(v23) = v23 | 4;
LABEL_34:
    __int16 v25 = *(unsigned char *)(a3 + 124) & 1;
    goto LABEL_35;
  }
  if (v24 != 128) {
    goto LABEL_36;
  }
  __int16 v25 = (*(unsigned char *)(a3 + 124) & 1) == 0;
LABEL_35:
  LOWORD(v23) = v23 | v25;
LABEL_36:
  if (v23)
  {
    if (a4 == 1.0)
    {
      __int16 v26 = *(unsigned __int8 *)(a1 + 55);
      if (!*(unsigned char *)(a1 + 55))
      {
LABEL_43:
        LOWORD(v23) = v26 | v23 & 0xFFFD;
        goto LABEL_44;
      }
      if (v9 != 1
        || (uint32x2_t v27 = (uint32x2_t)vceq_f32(*(float32x2_t *)(a1 + 24), *(float32x2_t *)(a1 + 32)),
            (vpmin_u32(v27, v27).u32[0] & 0x80000000) != 0))
      {
        __int16 v26 = 2;
        goto LABEL_43;
      }
    }
    __int16 v26 = 0;
    goto LABEL_43;
  }
LABEL_44:
  *a2 = *a2 & 0xFFFFF | ((unsigned __int16)v23 << 20);
  return result;
}

uint64_t RB::Fill::anonymous namespace'::subdivide_smooth_stops(unint64_t a1, uint16x4_t *a2, uint64_t a3, __int16 a4, int a5, __int32 a6)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  if (a1 >> 61) {
    return 0;
  }
  size_t v13 = 8 * a1;
  if (8 * a1 > 0x1000)
  {
    int v14 = (char *)malloc_type_malloc(8 * a1, 0xE282AA43uLL);
    if (!v14)
    {
      uint64_t v6 = 0;
      goto LABEL_27;
    }
  }
  else
  {
    MEMORY[0x270FA5388](a1, a2);
    int v14 = (char *)&v42 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v14, v13);
  }
  if (!a1) {
    return 1;
  }
  size_t v42 = v13;
  uint64_t v15 = 0;
  __int16 v16 = a4 | 0x100;
  int v17 = a2;
  do
  {
    uint16x4_t v43 = *v17;
    __int16 v44 = v16;
    RB::Fill::Color::convert((uint64_t)&v43, a5, v43);
    v19.i32[0] = v43.i32[0];
    v19.i16[2] = v43.i16[2];
    v19.i16[3] = COERCE_UNSIGNED_INT(1.0);
    int32x2_t v20 = (int32x2_t)vmul_n_f16(v19, *(short float *)&v43.i16[3]);
    *(int32x2_t *)&v14[8 * v15++] = v20;
    v17 += 2;
  }
  while (a1 != v15);
  uint64_t v21 = 0;
  unint64_t v22 = 0;
  v20.i32[0] = 2;
  v18.i32[0] = a6;
  int8x8_t v23 = (int8x8_t)vdup_lane_s32(vceq_s32(v18, v20), 0);
  unint64_t v24 = v42;
  do
  {
    __int16 v25 = &a2[2 * v22];
    if (v22 >= a1 - 1)
    {
      unint64_t v27 = v22 + 1;
LABEL_15:
      uint64_t v31 = a3 + 16 * v21;
      *(_OWORD *)uint64_t v31 = *(_OWORD *)v25->i8;
      *(_DWORD *)(v31 + 12) = 1056964608;
      ++v21;
      goto LABEL_22;
    }
    float v26 = *(float *)v25[1].i32;
    unint64_t v27 = v22 + 1;
    float v28 = *(float *)a2[2 * v22 + 3].i32;
    if (v28 <= v26) {
      goto LABEL_15;
    }
    float16x4_t v29 = *(float16x4_t *)&v14[8 * v22];
    if (v22) {
      double v30 = *(double *)&v14[8 * v22 - 8];
    }
    else {
      double v30 = COERCE_DOUBLE(vbsl_s8(v23, *(int8x8_t *)&v14[8 * v27], (int8x8_t)v29));
    }
    uint64_t v36 = 0;
    float v37 = 0.0;
    float32x4_t v38 = (float *)(a3 + 12 + 16 * v21);
    do
    {
      float32x4_t v39 = vmlaq_n_f32(v32, vmlaq_n_f32(v33, vmlaq_n_f32(v34, v35, v37), v37), v37);
      if (v39.f32[3] != 0.0)
      {
        *(float32x2_t *)v40.f32 = vmul_n_f32(*(float32x2_t *)v39.f32, 1.0 / v39.f32[3]);
        v40.i64[1] = __PAIR64__(v39.u32[3], COERCE_UNSIGNED_INT(vmuls_lane_f32(1.0 / v39.f32[3], v39, 2)));
        float32x4_t v39 = v40;
      }
      *(float16x4_t *)(v38 - 3) = vcvt_f16_f32(v39);
      *(v38 - 1) = v26 + (float)(v37 * (float)(v28 - v26));
      *float32x4_t v38 = 0.5;
      v38 += 4;
      float v37 = v37 + 0.066667;
      --v36;
    }
    while (v36 != -16);
    v21 += 16;
LABEL_22:
    unint64_t v22 = v27;
  }
  while (v27 != a1);
  uint64_t v6 = 1;
  if (v24 <= 0x1000) {
    return v6;
  }
LABEL_27:
  free(v14);
  return v6;
}

void sub_2141A72AC(_Unwind_Exception *exception_object)
{
  if (*(void *)(v2 - 160) > 0x1000uLL) {
    free(v1);
  }
  _Unwind_Resume(exception_object);
}

void RB::Fill::anonymous namespace'::subdivide_stop<RB::Fill::Gradient::fill(RB::CGContext &,RB::Bounds)::$_0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unint64_t a5, double a6, float a7)
{
  float v9 = *(float *)&a6;
  float v11 = a7 - *(float *)&a6;
  if (v11 > 0.0624 && a5 <= 7 && (LODWORD(v11) & 0x7FFFFFFFu) < 0x7F800000)
  {
    unint64_t v16 = a5;
    uint64_t v19 = *(void *)a1;
    __int16 v20 = *(_WORD *)(a1 + 8);
    RB::Fill::Color::mix((uint64_t)&v19, a2, a3, 0.5);
  }
  else
  {
    uint64_t v14 = *(void *)a1;
    __int16 v15 = *(_WORD *)(a1 + 8);
    *(float *)&a6 = v9;
    RB::Fill::Gradient::fill(RB::CGContext &,RB::Bounds)const::$_0::operator()(a4, v14, v15, a6);
  }
}

size_t RB::Fill::Gradient::map_alpha(RB::Fill::Gradient *this, CGContextRef *a2, double a3, double a4, double a5, double a6, float a7)
{
  unint64_t v9 = 0;
  uint64_t v29 = *MEMORY[0x263EF8340];
  __asm { FMOV            V1.4S, #1.0 }
  float32x4_t v24 = (float32x4_t)vdupq_n_s32(0x437F0000u);
  float32x4_t v25 = _Q1;
  do
  {
    unint64_t v15 = RB::Fill::Gradient::sample(this, (float)v9 * 0.0039216, *(double *)_Q1.i64, a5, a6, a7);
    int v16 = *((unsigned __int8 *)a2 + 8);
    unint64_t v26 = v15;
    __int16 v27 = v17;
    RB::Fill::Color::convert((uint64_t)&v26, v16, v18);
    v19.i16[3] = 15360;
    v19.i32[0] = v26;
    v19.i16[2] = WORD2(v26);
    uint64_t v20 = 0x3F0000003F000000;
    _Q1.i64[1] = 0x3F0000003F000000;
    int8x16_t v21 = (int8x16_t)vcvtq_u32_f32(vmlaq_f32(_Q1, v24, vminnmq_f32(vmaxnmq_f32(vcvtq_f32_f16(vmul_f16((float16x4_t)vdup_n_s16(HIWORD(v26)), v19)), (float32x4_t)0), v25)));
    _Q1.i64[0] = vextq_s8(v21, v21, 8uLL).u64[0];
    a5 = COERCE_DOUBLE(__PAIR64__(v21.u32[1], _Q1.u32[1]));
    __int32 v22 = v21.i32[0];
    *(uint32x2_t *)v21.i8 = vshl_u32((uint32x2_t)__PAIR64__(v21.u32[1], _Q1.u32[1]), (uint32x2_t)0x800000018);
    v28.i32[v9++] = v21.i32[2] | (v22 << 16) | v21.i32[0] | v21.i32[1];
  }
  while (v9 != 256);
  return RB::CGContext::apply_alpha_lut(a2, &v28);
}

void *RB::Fill::Gradient::encode(RB::Fill::Gradient *this, RB::Encoder *a2)
{
  double v3 = this;
  uint64_t v43 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)this;
  if (!(*(void *)this >> 61))
  {
    size_t v5 = 8 * v4;
    if ((unint64_t)(8 * v4) > 0x1000)
    {
      uint64_t v6 = (char *)malloc_type_malloc(8 * v4, 0xB7EEEFC2uLL);
      if (!v6)
      {
LABEL_11:
        free(v6);
        goto LABEL_12;
      }
    }
    else
    {
      MEMORY[0x270FA5388](this, a2);
      uint64_t v6 = (char *)&v42 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v6, v5);
    }
    if (*(void *)v3)
    {
      uint64_t v7 = 0;
      unint64_t v8 = 0;
      do
      {
        *(void *)&v6[8 * v8++] = *(void *)(*((void *)v3 + 1) + v7);
        uint64_t v9 = *(void *)v3;
        v7 += 16;
      }
      while (v8 < *(void *)v3);
    }
    else
    {
      uint64_t v9 = 0;
    }
    this = (RB::Fill::Gradient *)RB::ProtobufEncoder::packed_fixed64_field(a2, 1, (const unint64_t *)v6, v9);
    if (v5 > 0x1000) {
      goto LABEL_11;
    }
  }
LABEL_12:
  if (*((unsigned char *)v3 + 50))
  {
    uint64_t v10 = *(void *)v3;
    if (!(*(void *)v3 >> 62))
    {
      size_t v11 = 4 * v10;
      if ((unint64_t)(4 * v10) > 0x1000)
      {
        unsigned int v12 = (char *)malloc_type_malloc(4 * v10, 0x1ABD5735uLL);
        if (!v12)
        {
LABEL_21:
          free(v12);
          goto LABEL_22;
        }
      }
      else
      {
        MEMORY[0x270FA5388](this, a2);
        unsigned int v12 = (char *)&v42 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
        bzero(v12, v11);
      }
      uint64_t v13 = *(void *)v3;
      if (*(void *)v3)
      {
        uint64_t v14 = (int *)(*((void *)v3 + 1) + 8);
        unint64_t v15 = v12;
        uint64_t v16 = *(void *)v3;
        do
        {
          int v17 = *v14;
          v14 += 4;
          *v15++ = v17;
          --v16;
        }
        while (v16);
      }
      this = (RB::Fill::Gradient *)RB::ProtobufEncoder::packed_fixed32_field(a2, 2, (const unsigned int *)v12, v13);
      if (v11 > 0x1000) {
        goto LABEL_21;
      }
    }
  }
LABEL_22:
  if ((*((_DWORD *)v3 + 12) & 0xF00) != 0x100)
  {
    if ((*((_DWORD *)v3 + 12) & 0xF00) == 0x200 && *(void *)v3 != 1)
    {
      unint64_t v18 = 0;
      uint64_t v19 = 12;
      int32x4_t v20 = vdupq_n_s32(0x3B808081u);
      float32x4_t v42 = (float32x4_t)v20;
      do
      {
        v20.i32[0] = *(_DWORD *)(*((void *)v3 + 1) + v19);
        RB::ProtobufEncoder::float4_field(a2, 15, vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v20.i8))), v42));
        ++v18;
        v19 += 16;
      }
      while (v18 < *(void *)v3 - 1);
    }
    goto LABEL_37;
  }
  unint64_t v21 = *(void *)v3 - 1;
  if (v21 >> 62) {
    goto LABEL_37;
  }
  size_t v22 = 4 * v21;
  if (4 * v21 > 0x1000)
  {
    int8x8_t v23 = (char *)malloc_type_malloc(4 * v21, 0xD7EBFA4FuLL);
    if (!v23)
    {
LABEL_36:
      free(v23);
      goto LABEL_37;
    }
  }
  else
  {
    MEMORY[0x270FA5388](this, a2);
    int8x8_t v23 = (char *)&v42 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v23, v22);
  }
  uint64_t v24 = *(void *)v3 - 1;
  if (*(void *)v3 != 1)
  {
    float32x4_t v25 = (float *)(*((void *)v3 + 1) + 12);
    unint64_t v26 = (float *)v23;
    uint64_t v27 = *(void *)v3 - 1;
    do
    {
      float v28 = *v25;
      v25 += 4;
      *v26++ = 1.0 - v28;
      --v27;
    }
    while (v27);
  }
  RB::ProtobufEncoder::packed_fixed32_field(a2, 3, (const unsigned int *)v23, v24);
  if (v22 > 0x1000) {
    goto LABEL_36;
  }
LABEL_37:
  unint64_t v29 = *((unsigned __int8 *)v3 + 52);
  if (*((unsigned char *)v3 + 52))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
    RB::ProtobufEncoder::encode_varint(a2, v29);
  }
  int v30 = *((_DWORD *)v3 + 12);
  unint64_t v31 = v30 & 7;
  if ((v30 & 7) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
    RB::ProtobufEncoder::encode_varint(a2, v31);
  }
  int v32 = rb_color_space(*(_WORD *)((char *)v3 + 53));
  if (v32 != 1)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x30uLL);
    RB::ProtobufEncoder::encode_varint(a2, v32);
  }
  uint64_t result = RB::ProtobufEncoder::float2_field(a2, 7, *((double *)v3 + 3));
  if (*((unsigned char *)v3 + 52) == 1)
  {
    double v34 = *((double *)v3 + 4);
    uint32x2_t v35 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)((char *)v3 + 24), *(float32x2_t *)&v34));
    if ((vpmax_u32(v35, v35).u32[0] & 0x80000000) == 0) {
      goto LABEL_48;
    }
  }
  else
  {
    double v34 = *((double *)v3 + 4);
  }
  uint64_t result = RB::ProtobufEncoder::float2_field(a2, 8, v34);
LABEL_48:
  int v36 = *((int *)v3 + 10);
  if (*(float *)&v36 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x4DuLL);
    uint64_t result = RB::ProtobufEncoder::encode_fixed32(a2, v36);
  }
  int v37 = *((int *)v3 + 11);
  if (*(float *)&v37 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x55uLL);
    uint64_t result = RB::ProtobufEncoder::encode_fixed32(a2, v37);
  }
  float32x4_t v38 = (float64x2_t *)*((void *)v3 + 2);
  if (v38)
  {
    int64x2_t v39 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v38[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v38, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v38[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v39, 1), (int8x16_t)v39).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x5AuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::AffineTransform::encode(v38->f64, a2);
      uint64_t result = RB::ProtobufEncoder::end_length_delimited(a2);
    }
  }
  int v40 = *((_DWORD *)v3 + 12) & 0xC0;
  switch(v40)
  {
    case 64:
      unint64_t v41 = 96;
      break;
    case 192:
      unint64_t v41 = 112;
      break;
    case 128:
      unint64_t v41 = 104;
      break;
    default:
      goto LABEL_62;
  }
  RB::ProtobufEncoder::encode_varint(a2, v41);
  uint64_t result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
LABEL_62:
  if ((*((_DWORD *)v3 + 12) & 0xF00) == 0x400)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x80uLL);
    return RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  return result;
}

void sub_2141A7A58(_Unwind_Exception *exception_object)
{
  if (v2 > 0x1000) {
    free(v1);
  }
  _Unwind_Resume(exception_object);
}

void RB::Fill::Gradient::decode(RB::Fill::Gradient *this, RB::Heap **a2)
{
  char v4 = 0;
  uint64_t v100 = *MEMORY[0x263EF8340];
  __int16 v97 = 0;
  unint64_t v98 = 0;
  unint64_t v99 = 16;
  unsigned int v93 = 0;
  size_t v94 = 0;
  unint64_t v95 = 16;
  float64x2_t v89 = 0;
  size_t v90 = 0;
  unint64_t v91 = 16;
  uint64_t v85 = 0;
  uint64_t v86 = 0;
  unint64_t v87 = 16;
  *(_WORD *)((char *)this + 53) = 257;
  int8x8_t v5 = (int8x8_t)vdup_n_s32(0x437F8000u);
  __asm { FMOV            V14.2S, #1.0 }
  float32x2_t v10 = (float32x2_t)vdup_n_s32(0x437F0000u);
  while (1)
  {
    unint64_t field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
    if (!field) {
      break;
    }
    switch((field >> 3))
    {
      case 1u:
        double v13 = RB::ProtobufDecoder::color_field((unint64_t *)a2, field);
        unint64_t v14 = v98;
        if (v99 < v98 + 1)
        {
          _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(__dst, v98 + 1);
          unint64_t v14 = v98;
        }
        unint64_t v15 = v97;
        if (!v97) {
          unint64_t v15 = __dst;
        }
        *(double *)&v15[8 * v14] = v13;
        ++v98;
        continue;
      case 2u:
        float v32 = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a2, field);
        size_t v33 = v94;
        size_t v34 = v94 + 1;
        if (v95 < v94 + 1)
        {
          RB::vector<float,16ul,unsigned long>::reserve_slow(v92, v34);
          size_t v33 = v94;
          size_t v34 = v94 + 1;
        }
        uint32x2_t v35 = v93;
        if (!v93) {
          uint32x2_t v35 = v92;
        }
        *(float *)&v35[4 * v33] = v32;
        size_t v94 = v34;
        continue;
      case 3u:
        float v27 = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a2, field);
        size_t v28 = v90;
        size_t v29 = v90 + 1;
        if (v91 < v90 + 1)
        {
          RB::vector<float,16ul,unsigned long>::reserve_slow(v88, v29);
          size_t v28 = v90;
          size_t v29 = v90 + 1;
        }
        int v30 = v89;
        if (!v89) {
          int v30 = v88;
        }
        *(float *)&v30[4 * v28] = 1.0 - v27;
        size_t v90 = v29;
        continue;
      case 4u:
        unint64_t v31 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, field);
        if (v31 <= 4) {
          *((unsigned char *)this + 52) = v31;
        }
        continue;
      case 5u:
        *((_DWORD *)this + 12) |= RB::ProtobufDecoder::uint_field((uint64_t **)a2, field) & 7;
        continue;
      case 6u:
        unsigned int v36 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, field);
        *(_WORD *)((char *)this + 53) = rb_color_space(v36);
        continue;
      case 7u:
        *((void *)this + 3) = RB::ProtobufDecoder::float2_field((RB::ProtobufDecoder *)a2, field, v12).n128_u64[0];
        continue;
      case 8u:
        *((void *)this + 4) = RB::ProtobufDecoder::float2_field((RB::ProtobufDecoder *)a2, field, v12).n128_u64[0];
        char v4 = 1;
        continue;
      case 9u:
        *((float *)this + 10) = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a2, field);
        continue;
      case 0xAu:
        *((float *)this + 11) = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a2, field);
        continue;
      case 0xBu:
        v81[0] = (float64x2_t)xmmword_2142181C0;
        v81[1] = (float64x2_t)xmmword_2142181D0;
        uint64_t v82 = 0;
        uint64_t v83 = 0;
        if ((field & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          RB::AffineTransform::decode((RB::AffineTransform *)v81, (RB::ProtobufDecoder *)a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *a2 = a2[1];
        }
        RB::Fill::Gradient::concat(this, v81, a2[8]);
        continue;
      case 0xCu:
        *((_DWORD *)this + 12) &= 0xFFFFFF3F;
        if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, field)) {
          int v26 = 64;
        }
        else {
          int v26 = 0;
        }
        goto LABEL_53;
      case 0xDu:
        *((_DWORD *)this + 12) &= 0xFFFFFF3F;
        if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, field)) {
          int v26 = 128;
        }
        else {
          int v26 = 0;
        }
        goto LABEL_53;
      case 0xEu:
        *((_DWORD *)this + 12) &= 0xFFFFFF3F;
        if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, field)) {
          int v26 = 192;
        }
        else {
          int v26 = 0;
        }
LABEL_53:
        *((_DWORD *)this + 12) |= v26;
        break;
      case 0xFu:
        __n128 v16 = RB::ProtobufDecoder::float4_field((RB::ProtobufDecoder *)a2, field);
        int8x16_t v17 = (int8x16_t)v16;
        if (v16.n128_f32[0] >= 0.0) {
          float v18 = v16.n128_f32[0];
        }
        else {
          float v18 = 0.0;
        }
        if (v18 <= 1.0) {
          float v19 = (float)(v18 * 255.0) + 0.5;
        }
        else {
          float v19 = 255.5;
        }
        if (v16.n128_f32[2] >= 0.0) {
          float v20 = v16.n128_f32[2];
        }
        else {
          float v20 = 0.0;
        }
        if (v20 <= 1.0) {
          float v21 = (float)(v20 * 255.0) + 0.5;
        }
        else {
          float v21 = 255.5;
        }
        uint64_t v22 = v86;
        if (v87 < v86 + 1)
        {
          int8x16_t v80 = v17;
          RB::vector<float,16ul,unsigned long>::reserve_slow(v84, v86 + 1);
          uint64_t v22 = v86;
          int8x16_t v17 = v80;
        }
        v17.i32[0] = vextq_s8(v17, v17, 8uLL).i32[1];
        float32x2_t v23 = (float32x2_t)vbic_s8(*(int8x8_t *)v17.i8, (int8x8_t)vcltz_f32(*(float32x2_t *)v17.i8));
        uint32x2_t v24 = vshl_u32((uint32x2_t)vcvt_s32_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v23, _D14), v5, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v10, v23))), (uint32x2_t)0x800000018);
        float32x4_t v25 = v85;
        if (!v85) {
          float32x4_t v25 = v84;
        }
        *(_DWORD *)&v25[4 * v22] = v24.i32[0] | ((int)v21 << 16) | (int)v19 | v24.i32[1];
        ++v86;
        break;
      case 0x10u:
        *((_DWORD *)this + 12) &= 0xFFFFF0FF;
        if (RB::ProtobufDecoder::uint_field((uint64_t **)a2, field) == 1) {
          *((_DWORD *)this + 12) |= 0x400u;
        }
        break;
      default:
        continue;
    }
  }
  unint64_t v37 = v98;
  if (v98 < 2) {
    goto LABEL_63;
  }
  size_t v38 = v94;
  if (v94)
  {
    if (v94 != v98) {
      goto LABEL_63;
    }
  }
  size_t v39 = v90;
  if (v90)
  {
    if (v90 != v98 - 1 || v86) {
      goto LABEL_63;
    }
    goto LABEL_80;
  }
  if (!v86)
  {
LABEL_80:
    int v40 = 1;
    goto LABEL_81;
  }
  if (v86 != v98 - 1)
  {
LABEL_63:
    *((unsigned char *)a2 + 56) = 1;
    *a2 = a2[1];
    goto LABEL_64;
  }
  int v40 = 0;
LABEL_81:
  if (!((*((unsigned char *)this + 52) != 1) | v4 & 1)) {
    *((void *)this + 4) = *((void *)this + 3);
  }
  unint64_t v41 = 0;
  *(void *)this = v37;
  float32x4_t v42 = v97;
  if (!v97) {
    float32x4_t v42 = __dst;
  }
  uint64_t v43 = v93;
  if (!v93) {
    uint64_t v43 = v92;
  }
  __int16 v44 = v89;
  if (!v89) {
    __int16 v44 = v88;
  }
  uint64_t v45 = v85;
  if (!v85) {
    uint64_t v45 = v84;
  }
  float v46 = -INFINITY;
  float v47 = INFINITY;
  char v48 = 1;
  *((unsigned char *)this + 55) = 1;
  float v49 = 1.0 / (float)(v37 - 1);
  do
  {
    float32x4_t v50 = vcvtq_f32_f16(*(float16x4_t *)&v42[8 * v41]);
    v48 &= v50.f32[3] == 1.0;
    *((unsigned char *)this + 55) = v48;
    float v51 = fminf(fminf(v50.f32[0], v50.f32[2]), v50.f32[1]);
    if (v51 < v47) {
      float v47 = v51;
    }
    float v52 = fmaxf(fmaxf(v50.f32[0], v50.f32[2]), v50.f32[1]);
    if (v46 < v52) {
      float v46 = v52;
    }
    if (v38)
    {
      int v53 = *((_DWORD *)this + 12);
      if ((v53 & 0x10000) == 0 && fabsf(*(float *)&v43[4 * v41] - (float)(v49 * (float)v41)) > 0.001) {
        *((_DWORD *)this + 12) = v53 | 0x10000;
      }
    }
    if (v39)
    {
      _CF = (*((_DWORD *)this + 12) & 0xF00) == 0x100 || v41 + 1 >= v37;
      if (!_CF && fabsf(*(float *)&v44[4 * v41] + (float)((float)(-0.5 - (float)v41) * v49)) > 0.001) {
        *((_DWORD *)this + 12) = *((_DWORD *)this + 12) & 0xFFFFF0FF | 0x100;
      }
    }
    if (v40)
    {
      uint16x4_t v55 = (RB *)(v41 + 1);
    }
    else
    {
      uint16x4_t v55 = (RB *)(v41 + 1);
      if ((*((_DWORD *)this + 12) & 0xF00) != 0x200 && (unint64_t)v55 < v37)
      {
        if (v45[4 * v41]
          || (uint64_t v57 = &v45[4 * v41], v57[1])
          || v57[2] != 255
          || v45[4 * v41 + 3] != 255)
        {
          *((_DWORD *)this + 12) = *((_DWORD *)this + 12) & 0xFFFFF0FF | 0x200;
        }
      }
    }
    unint64_t v41 = (unint64_t)v55;
  }
  while (v55 != (RB *)v37);
  *((unsigned char *)this + 56) = RB::required_color_depth(v55, v47, v46);
  __int16 v58 = a2[8];
  uint64_t v59 = *(void *)this;
  unint64_t v60 = (*((void *)v58 + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v61 = v60 + 16 * *(void *)this;
  if (v61 > *((void *)v58 + 3))
  {
    unint64_t v60 = RB::Heap::alloc_slow((size_t *)a2[8], 16 * v59, 7);
    uint64_t v59 = *(void *)this;
  }
  else
  {
    *((void *)v58 + 2) = v61;
  }
  *((void *)this + 1) = v60;
  if (v59)
  {
    uint64_t v62 = 0;
    unint64_t v63 = 0;
    do
    {
      float32x2_t v64 = v97;
      if (!v97) {
        float32x2_t v64 = __dst;
      }
      *(void *)(*((void *)this + 1) + v62) = *(void *)&v64[8 * v63];
      int v65 = *((_DWORD *)this + 12);
      if ((v65 & 0x10000) != 0)
      {
        float v70 = v93;
        if (!v93) {
          float v70 = v92;
        }
        float v69 = *(float *)&v70[4 * v63];
      }
      else
      {
        uint64_t v66 = *(void *)this - 1;
        float32x2_t v67 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(unint64_t)v66));
        float32x2_t v68 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(unint64_t)v66), v67), v67);
        float v69 = (float)v63
            * vmul_f32(v68, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(unint64_t)v66), v68)).f32[0];
      }
      uint64_t v71 = *((void *)this + 1);
      *(float *)(v71 + v62 + 8) = v69;
      int v72 = v65 & 0xF00;
      if (v72 == 512)
      {
        if (v63 >= *(void *)this - 1)
        {
          __int16 v77 = 0;
          LOBYTE(v76) = 0;
          unsigned int v78 = 16711680;
          unsigned int v79 = -16777216;
        }
        else
        {
          float v75 = v85;
          if (!v85) {
            float v75 = v84;
          }
          int v76 = *(_DWORD *)&v75[4 * v63];
          __int16 v77 = v76 & 0xFF00;
          unsigned int v78 = v76 & 0xFFFF0000;
          unsigned int v79 = v76 & 0xFF000000;
        }
        *(_DWORD *)(v71 + v62 + 12) = v78 & 0xFF0000 | v79 | v77 & 0xFF00 | v76;
      }
      else if (v72 == 256)
      {
        float v73 = 0.5;
        if (v63 < *(void *)this - 1)
        {
          float16x4_t v74 = v89;
          if (!v89) {
            float16x4_t v74 = v88;
          }
          float v73 = *(float *)&v74[4 * v63];
        }
        *(float *)(v71 + v62 + 12) = v73;
      }
      ++v63;
      v62 += 16;
    }
    while (v63 < *(void *)this);
  }
LABEL_64:
  if (v85) {
    free(v85);
  }
  if (v89) {
    free(v89);
  }
  if (v93) {
    free(v93);
  }
  if (v97) {
    free(v97);
  }
}

void sub_2141A830C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a29) {
    free(a29);
  }
  if (a40) {
    free(a40);
  }
  if (a51) {
    free(a51);
  }
  if (a70) {
    free(a70);
  }
  _Unwind_Resume(a1);
}

void RB::Fill::Gradient::attributes(float32x2_t *this, RB::XML::Element *a2)
{
  switch(this[6].i8[4])
  {
    case 0:
      float32x2_t v2 = this[3];
      unint64_t v15 = &unk_26C4ED4D8;
      *(float64x2_t *)__n128 v16 = vcvtq_f64_f32(v2);
      RB::XML::Element::set<RB::XML::Value::Vec2>();
    case 1:
      float32x2_t v3 = this[3];
      unint64_t v15 = &unk_26C4ED4D8;
      *(float64x2_t *)__n128 v16 = vcvtq_f64_f32(v3);
      RB::XML::Element::set<RB::XML::Value::Vec2>();
    case 2:
      float32x2_t v4 = this[3];
      unint64_t v15 = &unk_26C4ED4D8;
      *(float64x2_t *)__n128 v16 = vcvtq_f64_f32(v4);
      RB::XML::Element::set<RB::XML::Value::Vec2>();
    case 4:
      float32x2_t v5 = this[3];
      unint64_t v15 = &unk_26C4ED4D8;
      *(float64x2_t *)__n128 v16 = vcvtq_f64_f32(v5);
      RB::XML::Element::set<RB::XML::Value::Vec2>();
    default:
      uint64_t v6 = (float64x2_t *)this[2];
      if (v6)
      {
        float64x2_t v7 = *v6;
        float64x2_t v8 = v6[1];
        float64x2_t v9 = v6[2];
        int64x2_t v10 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v8, (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v6, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v9));
        if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v10, 1), (int8x16_t)v10).u64[0] & 0x8000000000000000) == 0)
        {
          unint64_t v15 = &unk_26C4ED320;
          *(float64x2_t *)__n128 v16 = v7;
          float64x2_t v17 = v8;
          float64x2_t v18 = v9;
          RB::XML::Element::set<RB::XML::Value::AffineMatrix>();
        }
      }
      __int32 v11 = this[6].i32[0];
      unsigned int v12 = (v11 & 7) - 1;
      if (v12 <= 2)
      {
        double v13 = off_2641F8BD0[v12];
        unint64_t v15 = &unk_26C4ED370;
        v16[0] = v13;
        RB::XML::Element::set<RB::XML::Value::ConstantString>();
      }
      if ((v11 & 0xF00) == 0x400)
      {
        unint64_t v15 = &unk_26C4ED370;
        v16[0] = "smooth";
        RB::XML::Element::set<RB::XML::Value::ConstantString>();
      }
      if (this[6].i8[6])
      {
        int v14 = rb_color_space(this[6].u8[5] | 0x100u);
        unint64_t v15 = &unk_26C4E8130;
        LODWORD(v16[0]) = v14;
        RB::XML::Element::set<RB::XML::Value::ColorSpace>();
      }
      RB::XML::Value::Gradient::Gradient((RB::XML::Value::Gradient *)&v15, (const RB::Fill::Gradient *)this);
      RB::XML::Element::set<RB::XML::Value::Gradient>();
  }
}

void sub_2141A88B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11)
{
  if (a11) {
    free(a11);
  }
  _Unwind_Resume(exception_object);
}

void RB::XML::Element::set<RB::XML::Value::AffineMatrix>()
{
}

void RB::XML::Element::set<RB::XML::Value::ColorSpace>()
{
}

uint64_t _ZN2RB13CubicIteratorIDv2_fEC2ES1_S1_S1_S1_i(uint64_t result, int a2, float32x2_t a3, float32x2_t a4, float32x2_t a5, float32x2_t a6)
{
  __asm { FMOV            V5.2S, #3.0 }
  float32x2_t v11 = vmul_f32(vsub_f32(a4, a3), _D5);
  float32x2_t v12 = vmla_f32(vneg_f32(v11), _D5, vsub_f32(a5, a4));
  float32x2_t v13 = vsub_f32(a6, vadd_f32(vadd_f32(v11, a3), v12));
  float v14 = 1.0 / (float)a2;
  float v15 = (float)(v14 * v14) * v14;
  __asm { FMOV            V7.2S, #6.0 }
  float32x2_t v17 = vmul_n_f32(vmul_f32(v13, _D7), v15);
  *(float32x2_t *)(result + 24) = v17;
  float32x2_t v18 = vmul_n_f32(v12, v14 * v14);
  *(double *)uint64_t result = *(double *)&a3;
  *(float32x2_t *)(result + 8) = vmla_n_f32(vmla_n_f32(v18, v11, v14), v13, v15);
  *(float32x2_t *)(result + 16) = vmla_f32(v17, (float32x2_t)0x4000000040000000, v18);
  return result;
}

double RB::Fill::anonymous namespace'::smooth_color_coefficients(double a1, float16x4_t a2)
{
  __asm { FMOV            V7.4S, #3.0 }
  *(void *)&double result = vcvtq_f32_f16(a2).u64[0];
  return result;
}

float16x4_t _ZNSt3__127__memberwise_forward_assignB8nn180100INS_5tupleIJRN2RB12packed_half4ES4_S4_S4_EEENS1_IJDv4_fS6_S6_S6_EEEJS6_S6_S6_S6_EJLm0ELm1ELm2ELm3EEEEvRT_OT0_NS_13__tuple_typesIJDpT1_EEENS_15__tuple_indicesIJXspT2_EEEE(float16x4_t **a1, float32x4_t *a2)
{
  float32x2_t v2 = a1[1];
  **a1 = vcvt_f16_f32(*a2);
  *float32x2_t v2 = vcvt_f16_f32(a2[1]);
  float32x2_t v3 = a1[3];
  *a1[2] = vcvt_f16_f32(a2[2]);
  float16x4_t result = vcvt_f16_f32(a2[3]);
  *float32x2_t v3 = result;
  return result;
}

void *RB::vector<RB::Fill::Gradient::Stop,16ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 34) + (*((void *)__dst + 34) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 34) + (*((void *)__dst + 34) >> 1);
  }
  float16x4_t result = RB::details::realloc_vector<unsigned long,16ul>(*((void **)__dst + 32), __dst, 0x10uLL, (size_t *)__dst + 34, v3);
  *((void *)__dst + 32) = result;
  return result;
}

void *_ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(void *__dst, size_t a2)
{
  if (*((void *)__dst + 18) + (*((void *)__dst + 18) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 18) + (*((void *)__dst + 18) >> 1);
  }
  float16x4_t result = RB::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 16), __dst, 0x10uLL, (size_t *)__dst + 18, v3);
  *((void *)__dst + 16) = result;
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::AffineMatrix,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2141A8CD0(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::AffineMatrix *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::AffineMatrix>,std::allocator<RB::XML::Value::AffineMatrix>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::AffineMatrix *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::AffineMatrix>,std::allocator<RB::XML::Value::AffineMatrix>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::ColorSpace,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2141A8DC0(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::ColorSpace *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::ColorSpace>,std::allocator<RB::XML::Value::ColorSpace>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::ColorSpace *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::ColorSpace>,std::allocator<RB::XML::Value::ColorSpace>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::TextureCache::find_entry(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 56);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  float32x2_t v5 = (unsigned __int16 *)(a1 + 32);
  uint64_t v6 = *(unsigned __int16 **)(a1 + 48);
  if (!v6) {
    uint64_t v6 = v5;
  }
  int v7 = a2[3];
  while (1)
  {
    if (*((unsigned __int8 *)v6 + 2) == a2[2])
    {
      int v8 = *((unsigned __int8 *)v6 + 3);
      if (((v7 ^ v8) & 4) == 0 && ((v8 & 2) != 0 || (v7 & 2) == 0))
      {
        if ((v7 & 8) != 0)
        {
          LOBYTE(v9) = *(unsigned char *)(*((void *)v6 + 1) + 80);
        }
        else
        {
          unsigned int v9 = *v6;
          if (v9 < 0x100) {
            return result;
          }
        }
        if (!a2[1] || *a2 == v9) {
          break;
        }
      }
    }
    v6 += 8;
    if (v2 == ++result) {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t RB::TextureCache::use_entry(RB::TextureCache *this, unsigned int a2)
{
  size_t v3 = (char *)this + 32;
  float32x2_t v4 = (char *)*((void *)this + 6);
  if (!v4) {
    float32x2_t v4 = (char *)this + 32;
  }
  uint64_t v5 = a2;
  uint64_t v6 = *(void *)&v4[16 * a2 + 8];
  if (*(unsigned char *)(v6 + 77))
  {
    uint64_t v14 = *(void *)(v6 + 24);
    if ((*(unsigned char *)(v14 + 77) & 2) != 0) {
      uint64_t v14 = *(void *)(v14 + 24);
    }
    if (*(unsigned char *)(v14 + 44)) {
      goto LABEL_18;
    }
  }
  else
  {
    int v7 = *(id **)&v4[16 * a2 + 8];
    if ((*(unsigned char *)(v6 + 77) & 2) != 0) {
      int v7 = *(id **)(v6 + 24);
    }
    int v8 = RB::Resource::set_volatile(v7, 0);
    if (v8)
    {
      if (v8 == 1)
      {
        unsigned int v9 = (char *)*((void *)this + 6);
        if (!v9) {
          unsigned int v9 = v3;
        }
        int64x2_t v10 = &v9[16 * v5 + 8];
        int v11 = *((_DWORD *)this + 20);
        unsigned int v12 = v11 + 1;
        if (*((_DWORD *)this + 21) < (v11 + 1))
        {
          float32x4_t v25 = v10;
          RB::vector<RB::refcounted_ptr<RB::Texture>,1ul,unsigned int>::reserve_slow((char *)this + 64, v12);
          int64x2_t v10 = v25;
          int v11 = *((_DWORD *)this + 20);
          unsigned int v12 = v11 + 1;
        }
        float32x2_t v13 = (char *)*((void *)this + 9);
        if (!v13) {
          float32x2_t v13 = (char *)this + 64;
        }
        *(void *)&v13[8 * v11] = *(void *)v10;
        *(void *)int64x2_t v10 = 0;
        *((_DWORD *)this + 20) = v12;
      }
LABEL_18:
      float v15 = (char *)*((void *)this + 6);
      if (!v15) {
        float v15 = v3;
      }
      __n128 v16 = &v15[16 * v5];
      float32x2_t v17 = &v15[16 * (*((_DWORD *)this + 14) - 1)];
      int v18 = *(_DWORD *)v16;
      *(_DWORD *)__n128 v16 = *(_DWORD *)v17;
      *(_DWORD *)float32x2_t v17 = v18;
      uint64_t v19 = *((void *)v16 + 1);
      *((void *)v16 + 1) = *((void *)v17 + 1);
      *((void *)v17 + 1) = v19;
      unsigned int v20 = *((_DWORD *)this + 14) - 1;
      *((_DWORD *)this + 14) = v20;
      float v21 = (char *)*((void *)this + 6);
      if (!v21) {
        float v21 = v3;
      }
      uint64_t v22 = *(_DWORD **)&v21[16 * v20 + 8];
      if (v22)
      {
        int v23 = v22[2] - 1;
        v22[2] = v23;
        if (!v23) {
          (*(void (**)(_DWORD *))(*(void *)v22 + 8))(v22);
        }
      }
      return 0;
    }
  }
  return v6;
}

uint64_t RB::TextureCache::take_available@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, int a3@<W2>, __int8 a4@<W3>, int a5@<W4>, int a6@<W5>, int a7@<W6>, int32x2_t **a8@<X8>, int32x2_t a9@<D0>)
{
  int v9 = *(_DWORD *)(result + 80);
  if (v9)
  {
    int64x2_t v10 = *(int32x2_t ***)(result + 72);
    if (!v10) {
      int64x2_t v10 = (int32x2_t **)(result + 64);
    }
    uint64_t v11 = *(unsigned int *)(result + 80);
    unsigned int v12 = v10;
    while (1)
    {
      float32x2_t v13 = *v12;
      uint32x2_t v14 = (uint32x2_t)vceq_s32((*v12)[8], a9);
      if ((vpmin_u32(v14, v14).u32[0] & 0x80000000) != 0
        && *(void *)&v13[7] == a2
        && v13[9].u8[4] == a3
        && v13[9].u8[6] == a5
        && v13[9].u8[7] == a6
        && ((v13[9].i8[5] & 2) == 0) != a7)
      {
        break;
      }
      ++v12;
      if (!--v11) {
        goto LABEL_12;
      }
    }
    v13[10].i8[0] = a4;
    *a8 = v13;
    *unsigned int v12 = 0;
    unsigned int v15 = v9 - 1;
    *unsigned int v12 = v10[v9 - 1];
    v10[v9 - 1] = 0;
    *(_DWORD *)(result + 80) = v9 - 1;
    uint64_t v16 = *(void *)(result + 72);
    if (!v16) {
      uint64_t v16 = result + 64;
    }
    uint64_t result = *(void *)(v16 + 8 * v15);
    if (result)
    {
      int v17 = *(_DWORD *)(result + 8) - 1;
      *(_DWORD *)(result + 8) = v17;
      if (!v17) {
        return (*(uint64_t (**)(void))(*(void *)result + 8))();
      }
    }
  }
  else
  {
LABEL_12:
    *a8 = 0;
  }
  return result;
}

uint64_t RB::TextureCache::prepare(int32x2_t *a1, uint64_t *a2, CGImage *a3, unsigned __int8 *a4)
{
  space[6] = *(CGColorSpaceRef *)MEMORY[0x263EF8340];
  if (RB::TextureCache::prepare_from_cache((uint64_t)a1, (uint64_t)a2, a4)) {
    return 1;
  }
  unsigned int Width = CGImageGetWidth(a3);
  int32x2_t v88 = (int32x2_t)__PAIR64__(CGImageGetHeight(a3), Width);
  ColorSpace = CGImageGetColorSpace(a3);
  CGBitmapInfo BitmapInfo = CGImageGetBitmapInfo(a3);
  v12.n128_u64[0] = (unint64_t)vceq_s32(v88, a1[1]);
  if ((vpmin_u32((uint32x2_t)v12.n128_u64[0], (uint32x2_t)v12.n128_u64[0]).u32[0] & 0x80000000) != 0)
  {
    CGBitmapInfo v42 = BitmapInfo;
    PropertCGFloat y = (__IOSurface *)CGImageGetProperty();
    if (Property)
    {
      __int16 v44 = Property;
      CFTypeID v45 = CFGetTypeID(Property);
      if (v45 == IOSurfaceGetTypeID()
        && (RB::TextureCache::prepare_from_iosurface(a1, a2, v44, a4, ColorSpace, v42 | 0x100000000) & 1) != 0)
      {
        return 1;
      }
    }
    if (CGImageGetImageProvider())
    {
      float v46 = (__IOSurface *)a1[3];
      if (v46) {
        goto LABEL_56;
      }
      float v46 = (__IOSurface *)CGImageProviderCopyIOSurface();
      float v47 = (const void *)a1[3];
      if (v47) {
        CFRelease(v47);
      }
      a1[3] = (int32x2_t)v46;
      if (v46)
      {
LABEL_56:
        if (RB::TextureCache::prepare_from_iosurface(a1, a2, v46, a4, ColorSpace, v42 | 0x100000000)) {
          return 1;
        }
      }
      uint64_t v48 = CGImageProviderCopyImageTextureData();
      if (v48)
      {
        float v49 = (const void *)v48;
        char v50 = RB::TextureCache::prepare_from_texture_data(a1, (uint64_t)a2, v48, a4, ColorSpace, v42 | 0x100000000);
        CFRelease(v49);
        if (v50) {
          return 1;
        }
      }
    }
  }
  int32x2_t v13 = vshl_s32(a1[1], vneg_s32(vdup_n_s32(a4[2])));
  unsigned int v14 = *(_DWORD *)a4;
  if ((*(_DWORD *)a4 & 0xFF00) != 0) {
    unsigned int v15 = *(_DWORD *)a4;
  }
  else {
    LOBYTE(v15) = 1;
  }
  __int8 v87 = v15;
  if (a1[2].i8[0])
  {
    LOBYTE(v86) = 0;
    unint64_t v18 = 1;
    char v19 = 1;
  }
  else
  {
    unsigned int v86 = v14 >> 8;
    if (CGColorSpaceUsesExtendedRange(ColorSpace)) {
      goto LABEL_10;
    }
    size_t BitsPerComponent = CGImageGetBitsPerComponent(a3);
    BOOL IsWideGamutRGB = CGColorSpaceIsWideGamutRGB(ColorSpace);
    if (BitsPerComponent > 8) {
      goto LABEL_10;
    }
    if (IsWideGamutRGB)
    {
      if ((a4[3] & 8) != 0)
      {
LABEL_10:
        unint64_t v18 = 115;
        char v19 = v87;
        goto LABEL_12;
      }
      char v19 = 3;
      LOBYTE(v86) = 0;
      __int8 v87 = 2;
      unint64_t v18 = 81;
    }
    else
    {
      if (v87) {
        unint64_t v18 = 80;
      }
      else {
        unint64_t v18 = 81;
      }
      char v19 = 1;
    }
  }
LABEL_12:
  v12.n128_u64[0] = (unint64_t)vmax_s32(v13, (int32x2_t)0x100000001);
  memset(data, 0, sizeof(data));
  uint64_t v20 = *a2;
  *(void *)unint64_t v91 = 0;
  unsigned __int8 v21 = a4[3];
  __n128 v89 = v12;
  if ((v21 & 2) != 0) {
    int v22 = RB::max_mipmap_levels((int32x2_t)v12.n128_u64[0]);
  }
  else {
    int v22 = 1;
  }
  RB::TextureCache::take_available((uint64_t)a1, v18, v22, v87, 0, 0, (v21 & 2) == 0, (int32x2_t **)&v90, (int32x2_t)v89.n128_u64[0]);
  if ((v21 & 2) != 0)
  {
    uint64_t v39 = 0;
  }
  else
  {
    int v24 = [*(id *)(v20 + 24) minimumLinearTextureAlignmentForPixelFormat:v18];
    uint64_t v8 = 0;
    unsigned int v26 = *((unsigned __int8 *)RB::pixel_format_traits(v18, v25) + 6);
    BOOL v27 = v89.n128_i32[0] < 0;
    if (v89.n128_i32[0] >= 0) {
      unsigned int v28 = v89.n128_u32[0];
    }
    else {
      unsigned int v28 = -v89.n128_u32[0];
    }
    unint64_t v29 = v26 * (unint64_t)v28;
    if (!v29) {
      BOOL v27 = 0;
    }
    if ((v29 & 0xFFFFFFFF00000000) != 0) {
      goto LABEL_113;
    }
    uint64_t v85 = v20;
    if (v27) {
      goto LABEL_113;
    }
    uint64_t v8 = 0;
    if (v89.n128_i32[0] >= 0) {
      int v30 = v29;
    }
    else {
      int v30 = -(int)v29;
    }
    unint64_t v31 = (void *)((v24 + v30 - 1) & -v24);
    unsigned int v32 = v89.n128_u32[1];
    if (v89.n128_i32[1] < 0) {
      unsigned int v32 = -v89.n128_u32[1];
    }
    int8x16_t v84 = v31;
    unint64_t v33 = v32 * (unint64_t)v31;
    unint64_t v34 = v89.n128_i32[1] >= 0 ? v33 : -(int)v33;
    BOOL v35 = (v33 & 0xFFFFFFFF00000000) != 0;
    BOOL v36 = v33 && v89.n128_i32[1] < 0;
    if (v35 || v36) {
      goto LABEL_113;
    }
    unint64_t v37 = v90;
    if (v90 && (*((unsigned char *)v90 + 77) & 2) != 0)
    {
      RB::refcounted_ptr<RB::Buffer>::operator=((_DWORD **)v91, *((_DWORD **)v90 + 3));
    }
    else
    {
      if ([*(id *)(v85 + 24) newBufferWithLength:v34 options:0]) {
        operator new();
      }
      size_t v90 = 0;
      if (v37)
      {
        int v38 = *((_DWORD *)v37 + 2) - 1;
        *((_DWORD *)v37 + 2) = v38;
        if (!v38) {
          (*(void (**)(RB::Texture *))(*(void *)v37 + 8))(v37);
        }
      }
    }
    if (*(void *)v91)
    {
      data[0] = *(void **)(*(void *)v91 + 56);
      data[3] = v84;
      v57.i64[0] = v89.n128_i32[0];
      v57.i64[1] = v89.n128_i32[1];
      *(int8x16_t *)&data[1] = vextq_s8(v57, v57, 8uLL);
      uint64_t v39 = 512;
    }
    else
    {
      uint64_t v39 = 0;
    }
    uint64_t v20 = v85;
  }
  if (a1[2].i8[0])
  {
    float v51 = CGBitmapContextCreate(data[0], v89.n128_i32[0], v89.n128_i32[1], 8uLL, (size_t)data[3], 0, 7u);
    int v53 = v51;
    if (!v51) {
      RB::precondition_failure((RB *)"CGContext creation failure", v52);
    }
    CGContextSetBlendMode(v51, kCGBlendModeCopy);
    CGContextSetRGBFillColor(v53, 1.0, 1.0, 1.0, 1.0);
    v94.origin.x = 0.0;
    v94.origin.CGFloat y = 0.0;
    v94.size.width = (double)v89.n128_i32[0];
    v94.size.CGFloat height = (double)v89.n128_i32[1];
    CGContextClipToMask(v53, v94, a3);
    v95.origin.x = 0.0;
    v95.origin.CGFloat y = 0.0;
    __int16 v54 = v53;
    v95.size.width = (double)v89.n128_i32[0];
    v95.size.CGFloat height = (double)v89.n128_i32[1];
    CGContextFillRect(v53, v95);
  }
  else
  {
    memset(space, 0, 40);
    switch(v19)
    {
      case 0:
        __int16 v56 = (unsigned __int16 *)RB::pixel_format_traits(v18, v23);
        if ((((unint64_t)v56[2] << 32) & 0xA00000000) != 0) {
          unint64_t v41 = (CGColorSpace *)RB::extended_linear_srgb_colorspace((RB *)v56);
        }
        else {
          unint64_t v41 = (CGColorSpace *)RB::linear_srgb_colorspace((RB *)v56);
        }
        goto LABEL_81;
      case 1:
        uint16x4_t v55 = (unsigned __int16 *)RB::pixel_format_traits(v18, v23);
        if ((((unint64_t)v55[2] << 32) & 0xA00000000) != 0) {
          unint64_t v41 = (CGColorSpace *)RB::extended_srgb_colorspace((RB *)v55);
        }
        else {
          unint64_t v41 = (CGColorSpace *)RB::srgb_colorspace((RB *)v55);
        }
        goto LABEL_81;
      case 2:
      case 3:
        int v40 = (unsigned __int16 *)RB::pixel_format_traits(v18, v23);
        if ((((unint64_t)v40[2] << 32) & 0xA00000000) != 0) {
          unint64_t v41 = (CGColorSpace *)RB::extended_display_p3_colorspace((RB *)v40);
        }
        else {
          unint64_t v41 = (CGColorSpace *)RB::display_p3_colorspace((RB *)v40);
        }
LABEL_81:
        space[1] = v41;
        goto LABEL_82;
      case 4:
      case 5:
        goto LABEL_134;
      default:
LABEL_82:
        LODWORD(space[4]) = 0;
        if (v18 - 80 >= 2)
        {
          if (v18 != 115) {
LABEL_134:
          }
            abort();
          uint64_t v58 = 0x4000000010;
          int v59 = 4353;
        }
        else
        {
          uint64_t v58 = 0x2000000008;
          int v59 = 8194;
        }
        space[0] = (CGColorSpaceRef)v58;
        LODWORD(space[2]) = v59;
        uint32x2_t v60 = (uint32x2_t)vceq_s32((int32x2_t)v89.n128_u64[0], v88);
        if ((vpmin_u32(v60, v60).u32[0] & 0x80000000) != 0
          && (unsigned int Type = CGColorSpaceGetType(), Type <= 6)
          && ((1 << Type) & 0x5B) != 0
          && !MEMORY[0x21669B590](data, space, 0, a3, v39))
        {
          float32x2_t v64 = 0;
        }
        else
        {
          uint64_t v62 = CGBitmapContextCreate(data[0], v89.n128_i32[0], v89.n128_i32[1], LODWORD(space[0]), (size_t)data[3], space[1], (uint32_t)space[2]);
          float32x2_t v64 = v62;
          if (!v62) {
            RB::precondition_failure((RB *)"CGContext creation failure", v63);
          }
          CGContextSetBlendMode(v62, kCGBlendModeCopy);
          CGContextSetRGBFillColor(v64, 1.0, 1.0, 1.0, 1.0);
          v96.size.width = (double)v89.n128_i32[0];
          v96.size.CGFloat height = (double)v89.n128_i32[1];
          v96.origin.x = 0.0;
          v96.origin.CGFloat y = 0.0;
          CGContextDrawImage(v64, v96, a3);
        }
        __int16 v54 = v64;
        break;
    }
  }
  if (!*(void *)v91 && v54)
  {
    data[0] = CGBitmapContextGetData(v54);
    data[3] = (void *)CGBitmapContextGetBytesPerRow(v54);
    v65.i64[0] = v89.n128_i32[0];
    v65.i64[1] = v89.n128_i32[1];
    *(int8x16_t *)&data[1] = vextq_s8(v65, v65, 8uLL);
  }
  if (data[0])
  {
    unsigned int v66 = HIBYTE(v14);
    CGColorSpaceRef v67 = v90;
    int v68 = v91[0];
    if (v90)
    {
      if (*(void *)v91) {
        goto LABEL_105;
      }
LABEL_103:
      RB::Texture::replace(v67, v68, data[0], (uint64_t)data[3]);
      if (!v54) {
        free(data[0]);
      }
LABEL_105:
      float v69 = v90;
      if (*((unsigned __int8 *)v90 + 76) >= 2u) {
        RB::RenderFrame::invalidate_mipmaps(a2, v90);
      }
      unsigned __int32 v70 = a1[7].u32[0];
      if (a1[7].i32[1] < v70 + 1)
      {
        RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,1ul,unsigned int>::reserve_slow(&a1[4], v70 + 1);
        unsigned __int32 v70 = a1[7].u32[0];
      }
      uint64_t v71 = (int32x2_t *)a1[6];
      if (!v71) {
        uint64_t v71 = a1 + 4;
      }
      int v72 = &v71[2 * v70];
      v72->i32[0] = v14 & 0xFF0000 | (v66 << 24) | (v86 << 8) | v14;
      v72[1] = (int32x2_t)v69;
      size_t v90 = 0;
      ++a1[7].i32[0];
      uint64_t v8 = RB::TextureCache::prepare_from_cache((uint64_t)a1, (uint64_t)a2, a4);
      if (!v54) {
        goto LABEL_113;
      }
      goto LABEL_112;
    }
    if (*(void *)v91)
    {
      RB::Texture::alloc(v20, *(uint64_t *)v91, v18, (uint64_t)data[3], 0, 0, space, (int32x2_t)v89.n128_u64[0]);
      CGColorSpaceRef v67 = space[0];
      size_t v90 = space[0];
      v66 &= ~2u;
      if (space[0]) {
        goto LABEL_102;
      }
    }
    else
    {
      if ((a4[3] & 2) != 0) {
        unsigned int v78 = 0x7FFFFFFF;
      }
      else {
        unsigned int v78 = 1;
      }
      RB::Texture::alloc(v20, v18, v78, 0, 0, space, v89);
      CGColorSpaceRef v67 = space[0];
      size_t v90 = space[0];
      if (space[0])
      {
LABEL_102:
        int v68 = v91[0];
        if (*(void *)v91) {
          goto LABEL_105;
        }
        goto LABEL_103;
      }
    }
    unsigned int v79 = RB::error_log(v67);
    if (os_log_type_enabled(v79, OS_LOG_TYPE_FAULT))
    {
      float v81 = RB::pixel_format_name((RB *)v18, v80);
      unsigned __int8 v82 = a4[3];
      LODWORD(space[0]) = 136315906;
      if ((v82 & 2) != 0) {
        uint64_t v83 = " mipmapped";
      }
      else {
        uint64_t v83 = "";
      }
      *(CGColorSpaceRef *)((char *)space + 4) = (CGColorSpaceRef)v81;
      WORD2(space[1]) = 1024;
      *(_DWORD *)((char *)&space[1] + 6) = v89.n128_u32[0];
      WORD1(space[2]) = 1024;
      HIDWORD(space[2]) = v89.n128_u32[1];
      LOWORD(space[3]) = 2080;
      *(CGColorSpaceRef *)((char *)&space[3] + 2) = (CGColorSpaceRef)v83;
      _os_log_fault_impl(&dword_2140F5000, v79, OS_LOG_TYPE_FAULT, "unable to create image texture: %s, [%d, %d]%s", (uint8_t *)space, 0x22u);
    }
  }
  uint64_t v8 = 0;
  if (v54) {
LABEL_112:
  }
    CFRelease(v54);
LABEL_113:
  float v73 = v90;
  if (v90)
  {
    int v74 = *((_DWORD *)v90 + 2) - 1;
    *((_DWORD *)v90 + 2) = v74;
    if (!v74) {
      (*(void (**)(RB::Texture *))(*(void *)v73 + 8))(v73);
    }
  }
  uint64_t v75 = *(void *)v91;
  if (*(void *)v91)
  {
    int v76 = *(_DWORD *)(*(void *)v91 + 8) - 1;
    *(_DWORD *)(*(void *)v91 + 8) = v76;
    if (!v76) {
      (*(void (**)(uint64_t))(*(void *)v75 + 8))(v75);
    }
  }
  return v8;
}

void sub_2141A9B9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, _DWORD *a19, _DWORD *a20)
{
  if (a19)
  {
    int v21 = a19[2] - 1;
    a19[2] = v21;
    if (!v21) {
      (*(void (**)(_DWORD *))(*(void *)a19 + 8))(a19);
    }
  }
  if (a20)
  {
    int v22 = a20[2] - 1;
    a20[2] = v22;
    if (!v22) {
      (*(void (**)(_DWORD *))(*(void *)a20 + 8))(a20);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::TextureCache::prepare_from_cache(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  size_t v3 = a3;
  float32x2_t v4 = (uint64_t *)a2;
  uint64_t v5 = a1;
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 88);
  entrCGFloat y = RB::TextureCache::find_entry(a1, a3);
  if ((entry & 0x80000000) == 0 && RB::TextureCache::use_entry((RB::TextureCache *)v5, entry)) {
    return 1;
  }
  uint64_t v8 = *(unsigned int *)(v5 + 56);
  if (!v8)
  {
LABEL_34:
    unsigned __int8 v39 = v3[2];
    if (!v39) {
      return 0;
    }
    while (1)
    {
      unsigned int v40 = *(_DWORD *)v3;
      __int16 v53 = *(_DWORD *)v3;
      unsigned __int8 v54 = --v39;
      char v55 = HIBYTE(v40) & 0xFD;
      unsigned int v41 = RB::TextureCache::find_entry(v5, (unsigned __int8 *)&v53);
      if ((v41 & 0x80000000) == 0)
      {
        uint64_t v42 = RB::TextureCache::use_entry((RB::TextureCache *)v5, v41);
        if (v42) {
          break;
        }
      }
      if (!v39) {
        return 0;
      }
    }
    return RB::TextureCache::prepare_from_base_level((int32x2_t *)v5, v4, (unsigned int *)v3, v42, v39);
  }
  uint64_t v9 = 0;
  unsigned int v10 = 0;
  uint64_t v11 = (unsigned __int8 *)(v5 + 32);
  uint64_t v12 = 16 * v8;
  uint64_t v47 = 16 * v8;
  uint64_t v48 = v4;
  char v50 = (unsigned __int8 *)(v5 + 32);
  float v51 = v3;
  uint64_t v49 = v5;
  while (1)
  {
    int32x2_t v13 = *(unsigned __int8 **)(v5 + 48);
    if (!v13) {
      int32x2_t v13 = v11;
    }
    if (v13[v9 + 2] != v3[2]) {
      goto LABEL_33;
    }
    unsigned int v14 = (int32x2_t *)RB::TextureCache::use_entry((RB::TextureCache *)v5, v10);
    if (!v14) {
      goto LABEL_33;
    }
    MTLPixelFormat v15 = (MTLPixelFormat)v14;
    uint64_t v16 = *(unsigned __int8 **)(v5 + 48);
    if (!v16) {
      uint64_t v16 = v11;
    }
    int v17 = v16[v9 + 1];
    if (v3[1]) {
      BOOL v18 = v17 == 0;
    }
    else {
      BOOL v18 = 1;
    }
    char v19 = v14 + 10;
    if (!v18) {
      char v19 = (int32x2_t *)v3;
    }
    __int8 v20 = v19->i8[0];
    if (v3[3]) {
      __int8 v21 = v20 & 0xFE;
    }
    else {
      __int8 v21 = v20;
    }
    uint64_t v22 = (uint64_t)v14[7];
    int32x2_t v23 = v14[8];
    if ((v3[3] & 2) != 0) {
      int v24 = RB::max_mipmap_levels(v14[8]);
    }
    else {
      int v24 = 1;
    }
    unsigned __int8 v25 = v21;
    char v26 = v21;
    RB::TextureCache::take_available(v5, v22, v24, v21, 1, 0, 0, &v56, v23);
    unsigned __int8 v28 = v3[3];
    unint64_t v29 = *(unsigned __int8 **)(v5 + 48);
    if (!v29) {
      unint64_t v29 = v11;
    }
    unsigned int v30 = v29[v9 + 3];
    unint64_t v31 = *(RB **)(v15 + 56);
    double v32 = *(double *)(v15 + 64);
    float32x2_t v4 = v48;
    char v33 = RB::pixel_format_required_depth(v31, v27);
    BOOL v35 = RB::pixel_format_traits(*(void *)(v15 + 56), v34);
    RB::RenderParams::RenderParams((uint64_t)&v53, (uint64_t)v48, (uint64_t)v31, v26, v26, v33, ((*v35 | ((unint64_t)*((unsigned __int16 *)v35 + 2) << 32)) & 0xA00000000) != 0, v32, 1.0);
    BOOL v36 = v56;
    RB::RenderFrame::copy_texture(v48, v15, v25, (v30 >> 1) & 2 | ((v28 & 2) != 0), (uint64_t)&v53, v56, &v52);
    size_t v3 = v51;
    uint64_t v5 = v49;
    uint64_t v11 = v50;
    if (!v52)
    {
LABEL_28:
      if (v36) {
        goto LABEL_29;
      }
      goto LABEL_32;
    }
    if (v52 != v15) {
      break;
    }
    int v37 = *(_DWORD *)(v15 + 8) - 1;
    *(_DWORD *)(v15 + 8) = v37;
    if (v37) {
      goto LABEL_28;
    }
    (*(void (**)(MTLPixelFormat))(*(void *)v15 + 8))(v15);
    if (v36)
    {
LABEL_29:
      int v38 = v36[1].i32[0] - 1;
      v36[1].i32[0] = v38;
      if (!v38) {
        (*(void (**)(int32x2_t *))(*(void *)v36 + 8))(v36);
      }
    }
LABEL_32:
    uint64_t v12 = v47;
LABEL_33:
    v9 += 16;
    ++v10;
    if (v12 == v9) {
      goto LABEL_34;
    }
  }
  unsigned int v43 = *(_DWORD *)(v49 + 56);
  if (*(_DWORD *)(v49 + 60) < v43 + 1)
  {
    RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,1ul,unsigned int>::reserve_slow(v50, v43 + 1);
    uint64_t v5 = v49;
    uint64_t v11 = v50;
    unsigned int v43 = *(_DWORD *)(v49 + 56);
    size_t v3 = v51;
  }
  __int16 v44 = *(unsigned __int8 **)(v5 + 48);
  if (!v44) {
    __int16 v44 = v11;
  }
  CFTypeID v45 = &v44[16 * v43];
  *(_DWORD *)CFTypeID v45 = *(_DWORD *)v3;
  *((void *)v45 + 1) = v52;
  ++*(_DWORD *)(v5 + 56);
  if (v36)
  {
    int v46 = v36[1].i32[0] - 1;
    v36[1].i32[0] = v46;
    if (!v46) {
      (*(void (**)(int32x2_t *))(*(void *)v36 + 8))(v36);
    }
  }
  return 1;
}

void sub_2141AA054(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, _DWORD *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,_Unwind_Exception *a21)
{
  uint64_t v22 = exception_object;
  if (a15)
  {
    RB::TextureCache::prepare_from_cache(a15, (uint64_t)exception_object, a2, (uint64_t)&a21);
    uint64_t v22 = a21;
  }
  if (v21)
  {
    int v23 = v21[2] - 1;
    int32x2_t v21[2] = v23;
    if (!v23) {
      (*(void (**)(_DWORD *))(*(void *)v21 + 8))(v21);
    }
  }
  _Unwind_Resume(v22);
}

uint64_t RB::TextureCache::prepare_from_iosurface(int32x2_t *a1, uint64_t *a2, IOSurfaceRef buffer, unsigned __int8 *a4, RB *a5, uint64_t a6)
{
  uint64_t v12 = (RB *)IOSurfaceCopyValue(buffer, (CFStringRef)*MEMORY[0x263F0EDA0]);
  int32x2_t v13 = v12;
  if (v12)
  {
    CFTypeID v14 = CFGetTypeID(v12);
    if (v14 == CFStringGetTypeID())
    {
      unsigned __int16 v16 = RB::color_space_from_cg_name(v13, v15);
      if (v16 >= 0x100u)
      {
        BOOL v21 = 0;
        LODWORD(a5) = 6;
LABEL_41:
        CFRelease(v13);
        goto LABEL_42;
      }
    }
    int v17 = CGColorSpaceCreateWithPropertyList(v13);
    char v19 = v17;
    if (v17)
    {
      __int16 v20 = RB::color_space_from_cg(v17, v18);
      if ((v20 & 0xFF00) != 0) {
        LODWORD(a5) = 6;
      }
      else {
        LODWORD(a5) = 1;
      }
      if ((v20 & 0xFF00) != 0) {
        LOBYTE(v16) = v20;
      }
      else {
        LOBYTE(v16) = 1;
      }
      CFRelease(v19);
      BOOL v21 = 0;
      goto LABEL_41;
    }
  }
  int v54 = 0;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v47 = 0u;
  uint64_t v55 = 116;
  BOOL v21 = IOSurfaceGetBulkAttachments() == 0;
  if (!v21 || BYTE11(v50) == 0 || BYTE12(v50) == 0)
  {
    if (a5)
    {
      __int16 v25 = RB::color_space_from_cg(a5, v22);
      if ((v25 & 0xFF00) != 0) {
        LOBYTE(v16) = v25;
      }
      else {
        LOBYTE(v16) = 1;
      }
      if ((v25 & 0xFF00) != 0) {
        LODWORD(a5) = 6;
      }
      else {
        LODWORD(a5) = 1;
      }
      if (v13) {
        goto LABEL_41;
      }
      goto LABEL_42;
    }
    LOBYTE(v16) = 1;
  }
  else
  {
    LOBYTE(v16) = 1;
    if (BYTE11(v50) - 1 < 2)
    {
LABEL_32:
      if (BYTE12(v50) - 1 >= 2 && BYTE12(v50) != 13)
      {
        if (BYTE12(v50) != 8)
        {
          LODWORD(a5) = 1;
          if (!v13) {
            goto LABEL_42;
          }
          goto LABEL_41;
        }
        LOBYTE(v16) = v16 & 2;
      }
      LODWORD(a5) = 6;
      if (!v13) {
        goto LABEL_42;
      }
      goto LABEL_41;
    }
    LODWORD(a5) = 1;
    if (BYTE11(v50) == 12)
    {
      LOBYTE(v16) = 3;
      goto LABEL_32;
    }
  }
  if (v13) {
    goto LABEL_41;
  }
LABEL_42:
  if (a5 != 6 && a5) {
    return 0;
  }
  int v26 = 0;
  int v27 = a1[2].i32[0] & 1;
  if (!v27 && (v16 & 1) != 0) {
    int v26 = (a4[3] & 1) != 0 || !a4[1] || *a4 != v16;
  }
  unsigned int v28 = *(unsigned __int8 *)(*a2 + 283);
  if (v28 > 2) {
    v26 |= 6u;
  }
  if (v28 > 1) {
    v26 |= 0x40u;
  }
  if (*(unsigned char *)(*a2 + 286)) {
    v26 |= 8u;
  }
  unsigned int v29 = v26 | (16 * v27);
  int v30 = v29 | 0x20;
  if (((1 << (a6 & 0x1F)) & 0x61) == 0) {
    int v30 = v29;
  }
  if ((a6 & 0x1Fu) <= 6) {
    unsigned int v31 = v30;
  }
  else {
    unsigned int v31 = v29;
  }
  __int16 v46 = 0;
  if ((a6 & 0xFF00000000) != 0) {
    MTLPixelFormat v32 = (unint64_t)v31;
  }
  else {
    MTLPixelFormat v32 = (unint64_t)v29;
  }
  unsigned __int8 v45 = 0;
  OSType PixelFormat = IOSurfaceGetPixelFormat(buffer);
  uint64_t result = RB::pixel_format_from_four_cc(PixelFormat, v32, (unsigned char *)&v46 + 1, &v46, (char *)&v45);
  if (result)
  {
    uint64_t v35 = result;
    if (!HIBYTE(v46) && !v21)
    {
      int v54 = 0;
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v47 = 0u;
      uint64_t v55 = 116;
      IOSurfaceGetBulkAttachments();
    }
    uint64_t v36 = *a2;
    int32x2_t v37 = a1[1];
    if ((v35 & 0x80000000) != 0)
    {
      uint64_t result = RB::Device::valid_texture_size_nonnative(v36, v35, v37);
      if (!result) {
        return result;
      }
      int32x2_t v37 = a1[1];
    }
    else
    {
      int v38 = (const float *)(v36 + 288);
      int32x2_t v39 = (int32x2_t)vld1_dup_f32(v38);
      uint32x2_t v40 = (uint32x2_t)vand_s8((int8x8_t)vcge_s32(v39, v37), (int8x8_t)vcgtz_s32(v37));
      if ((vpmin_u32(v40, v40).u32[0] & 0x80000000) == 0) {
        return 0;
      }
    }
    unsigned int v41 = (void *)[MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:v35 width:v37.i32[0] height:v37.i32[1] mipmapped:0];
    unsigned int v43 = RB::pixel_format_traits(v35, v42);
    if (((*v43 | ((unint64_t)*((unsigned __int16 *)v43 + 2) << 32)) & 0x40000000000) != 0) {
      uint64_t v44 = 17;
    }
    else {
      uint64_t v44 = 1;
    }
    [v41 setUsage:v44];
    if (v45) {
      RB::Texture::set_swizzle(v41, (const char *)v45);
    }
    uint64_t result = [*(id *)(*a2 + 24) newTextureWithDescriptor:v41 iosurface:buffer plane:0];
    if (result) {
      operator new();
    }
  }
  return result;
}

void sub_2141AA558(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A1C401006C202);
  _Unwind_Resume(a1);
}

uint64_t RB::TextureCache::prepare_from_texture_data(int32x2_t *a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, RB *a5, uint64_t a6)
{
  unint64_t PixelFormat = CGImageTextureDataGetPixelFormat();
  int32x2_t v13 = RB::pixel_format_traits(PixelFormat, v12);
  uint64_t v14 = 0;
  if (PixelFormat != *v13) {
    return v14;
  }
  CFStringRef v15 = v13;
  if (*(unsigned __int8 *)(*(void *)a2 + 283) < *((unsigned __int8 *)v13 + 8)
    || *((unsigned char *)v13 + 9) != 0)
  {
    return 0;
  }
  ColorSpace = (RB *)CGImageTextureDataGetColorSpace();
  if (!ColorSpace) {
    ColorSpace = a5;
  }
  if (ColorSpace)
  {
    unsigned __int16 v19 = RB::color_space_from_cg(ColorSpace, v18);
    if (v19 < 0x100u) {
      return 0;
    }
    unsigned __int8 v20 = v19;
    if ((v19 & 1) == 0)
    {
      BOOL v21 = a4 + 3;
      goto LABEL_21;
    }
  }
  else
  {
    unsigned __int8 v20 = 1;
  }
  if (((*v15 | ((unint64_t)*((unsigned __int16 *)v15 + 2) << 32)) & 0x1000000000) != 0)
  {
    unint64_t PixelFormat = v15[6];
    if (!v15[6]) {
      return 0;
    }
  }
  BOOL v21 = a4 + 3;
  if ((a4[3] & 1) != 0 || !a4[1] || *a4 != v20)
  {
    uint64_t v22 = RB::pixel_format_traits(PixelFormat, (MTLPixelFormat)v18);
    if (*(unsigned int *)((char *)v22 + 18)) {
      unint64_t PixelFormat = *(unsigned int *)((char *)v22 + 18);
    }
  }
LABEL_21:
  CGImageTextureDataGetSize();
  if (v25 != (double)(int)*(void *)&a1[1] || v24 != (double)(int)HIDWORD(*(void *)&a1[1])) {
    return 0;
  }
  if ((*v21 & 2) != 0)
  {
    unint64_t NumberOfMipmaps = CGImageTextureDataGetNumberOfMipmaps();
    if (!NumberOfMipmaps) {
      return 0;
    }
    unsigned int v28 = NumberOfMipmaps;
    if (NumberOfMipmaps > RB::max_mipmap_levels(a1[1])) {
      return 0;
    }
  }
  else
  {
    unsigned int v28 = 1;
  }
  unsigned __int8 v45 = a1;
  if ((a6 & 0xFF00000000) != 0)
  {
    if ((a6 & 0x1Fu) > 6)
    {
      int v32 = 0;
      goto LABEL_41;
    }
    int v30 = 1 << (a6 & 0x1F);
    if ((v30 & 0x61) == 0)
    {
      int v32 = 0;
      if ((v30 & 0x18) != 0) {
        int v32 = 0x4000000;
      }
      goto LABEL_41;
    }
    unsigned int v31 = RB::pixel_format_traits(PixelFormat, v23);
    if (((*v31 | ((unint64_t)*((unsigned __int16 *)v31 + 2) << 32)) & 0x100000000) != 0)
    {
      if (*(unsigned char *)(*(void *)a2 + 286))
      {
        int v32 = 0;
        goto LABEL_41;
      }
      return 0;
    }
  }
  int v32 = 0;
LABEL_41:
  uint64_t v33 = v28;
  if (v28 == 1) {
    CGImageTextureDataSupportsTiledLayout();
  }
  uint64_t v50 = 0;
  long long v51 = &v50;
  uint64_t v52 = 0x3812000000;
  long long v53 = __Block_byref_object_copy__3;
  int v54 = __Block_byref_object_dispose__3;
  uint64_t v55 = &unk_21422DE11;
  uint64_t v56 = 0;
  uint64_t v46 = 0;
  long long v47 = &v46;
  uint64_t v48 = 0x2020000000;
  uint64_t v49 = 0;
  if (!v28) {
    goto LABEL_53;
  }
  uint64_t v44 = a4;
  uint64_t v34 = 0;
  do
  {
    CGImageTextureDataGetDataWithBlock();
    ++v34;
  }
  while (v33 != v34);
  uint64_t v35 = v51;
  uint64_t v36 = v51[6];
  if (v36 && v47[3] == v33)
  {
    int v37 = *(unsigned __int8 *)(v36 + 76) > 1u;
    uint64_t v38 = (uint64_t)v45;
    __int32 v39 = v45[7].i32[0];
    if (v45[7].i32[1] < (v39 + 1))
    {
      RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,1ul,unsigned int>::reserve_slow(&v45[4], v39 + 1);
      uint64_t v38 = (uint64_t)v45;
      __int32 v39 = v45[7].i32[0];
    }
    uint32x2_t v40 = *(int32x2_t **)(v38 + 48);
    if (!v40) {
      uint32x2_t v40 = v45 + 4;
    }
    unsigned int v41 = &v40[2 * v39];
    v41->i32[0] = v32 | (v37 << 25);
    v41[1] = (int32x2_t)v35[6];
    v35[6] = 0;
    ++*(_DWORD *)(v38 + 56);
    uint64_t v14 = RB::TextureCache::prepare_from_cache(v38, a2, v44);
  }
  else
  {
LABEL_53:
    uint64_t v14 = 0;
  }
  _Block_object_dispose(&v46, 8);
  _Block_object_dispose(&v50, 8);
  uint64_t v42 = v56;
  if (v56)
  {
    int v43 = *(_DWORD *)(v56 + 8) - 1;
    *(_DWORD *)(v56 + 8) = v43;
    if (!v43) {
      (*(void (**)(uint64_t))(*(void *)v42 + 8))(v42);
    }
  }
  return v14;
}

void sub_2141AAA0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  uint64_t v36 = a35;
  if (a35)
  {
    int v37 = *(_DWORD *)(a35 + 8) - 1;
    *(_DWORD *)(a35 + 8) = v37;
    if (!v37) {
      (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
    }
  }
  _Unwind_Resume(a1);
}

_DWORD **RB::refcounted_ptr<RB::Buffer>::operator=(_DWORD **a1, _DWORD *a2)
{
  size_t v3 = *a1;
  if (v3 != a2)
  {
    if (v3)
    {
      int v5 = v3[2] - 1;
      v3[2] = v5;
      if (!v5) {
        (*(void (**)(_DWORD *))(*(void *)v3 + 8))(v3);
      }
    }
    if (a2) {
      ++a2[2];
    }
    *a1 = a2;
  }
  return a1;
}

uint64_t RB::TextureCache::prepare(int32x2_t *a1, uint64_t *a2, __IOSurface *a3, unsigned __int8 *a4)
{
  if (RB::TextureCache::prepare_from_cache((uint64_t)a1, (uint64_t)a2, a4)) {
    return 1;
  }
  return RB::TextureCache::prepare_from_iosurface(a1, a2, a3, a4, 0, 0);
}

uint64_t RB::TextureCache::prepare(uint64_t a1, uint64_t a2, void *a3, unsigned __int8 *a4)
{
  if ((RB::TextureCache::prepare_from_cache(a1, a2, a4) & 1) == 0)
  {
    unint64_t v6 = [a3 pixelFormat];
    RB::pixel_format_traits(v6, v7);
    operator new();
  }
  return 1;
}

void sub_2141AACB4(_Unwind_Exception *exception_object)
{
  int v3 = *(_DWORD *)(v1 + 8) - 1;
  *(_DWORD *)(v1 + 8) = v3;
  if (!v3) {
    RB::TextureCache::prepare(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t __Block_byref_object_copy__3(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  return result;
}

_DWORD *__Block_byref_object_dispose__3(uint64_t a1)
{
  uint64_t result = *(_DWORD **)(a1 + 48);
  if (result)
  {
    int v2 = result[2] - 1;
    result[2] = v2;
    if (!v2) {
      return (_DWORD *)(*(uint64_t (**)(void))(*(void *)result + 8))();
    }
  }
  return result;
}

int32x2_t *___ZN2RB12TextureCache25prepare_from_texture_dataERNS_11RenderFrameEP18CGImageTextureDataRKNS0_6ParamsEP12CGColorSpaceNSt3__18optionalIjEE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, __n128 a7)
{
  uint64_t result = *(int32x2_t **)(a1 + 48);
  unsigned int v9 = *(_DWORD *)(a1 + 80);
  a7.n128_u64[0] = (unint64_t)vmax_s32(vshl_s32(result[1], vneg_s32(vdup_n_s32(v9))), (int32x2_t)0x100000001);
  if (a7.n128_i32[0] == a2 && a7.n128_i32[1] == a3)
  {
    MTLPixelFormat v12 = *(RB::Texture **)(*(void *)(*(void *)(a1 + 32) + 8) + 48);
    if ((*(unsigned char *)(a1 + 84) & 2) != 0)
    {
      if (v12) {
        BOOL v19 = 0;
      }
      else {
        BOOL v19 = v9 == 0;
      }
      if (v19)
      {
        v29[0] = MEMORY[0x263EF8330];
        v29[1] = 3221225472;
        Point v29[2] = ___ZN2RB12TextureCache25prepare_from_texture_dataERNS_11RenderFrameEP18CGImageTextureDataRKNS0_6ParamsEP12CGColorSpaceNSt3__18optionalIjEE_block_invoke_2;
        v29[3] = &__block_descriptor_40_e12_v24__0_v8Q16l;
        uint64_t v22 = *(void *)(a1 + 64);
        v29[4] = *(void *)(a1 + 56);
        MTLPixelFormat v23 = (void *)[MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:v22 width:a2 height:a3 mipmapped:*(_DWORD *)(a1 + 88) > 1u];
        [v23 setMipmapLevelCount:*(unsigned int *)(a1 + 88)];
        double v25 = RB::pixel_format_traits(*(void *)(a1 + 64), v24);
        if (((*v25 | ((unint64_t)*((unsigned __int16 *)v25 + 2) << 32)) & 0x40000000000) != 0) {
          uint64_t v26 = 17;
        }
        else {
          uint64_t v26 = 1;
        }
        [v23 setUsage:v26];
        [v23 setStorageMode:0];
        if (*(unsigned char *)(a1 + 92)) {
          RB::Texture::set_swizzle(v23, (const char *)*(unsigned __int8 *)(a1 + 92));
        }
        uint64_t result = (int32x2_t *)[*(id *)(**(void **)(a1 + 72) + 24) newTextureWithBytesNoCopy:a5 length:a6 descriptor:v23 deallocator:v29];
        if (result) {
          operator new();
        }
      }
    }
    else
    {
      if (v12) {
        goto LABEL_16;
      }
      __n128 v27 = a7;
      RB::TextureCache::take_available((uint64_t)result, *(void *)(a1 + 64), *(_DWORD *)(a1 + 88), *(unsigned char *)(a1 + 93), 0, *(unsigned __int8 *)(a1 + 92), 0, &v28, (int32x2_t)a7.n128_u64[0]);
      uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 8);
      CFStringRef v15 = *(_DWORD **)(v14 + 48);
      *(void *)(v14 + 48) = v28;
      if (v15)
      {
        int v16 = v15[2] - 1;
        int32x2_t v15[2] = v16;
        if (!v16) {
          (*(void (**)(_DWORD *))(*(void *)v15 + 8))(v15);
        }
      }
      MTLPixelFormat v12 = *(RB::Texture **)(*(void *)(*(void *)(a1 + 32) + 8) + 48);
      if (v12) {
        goto LABEL_16;
      }
      RB::Texture::alloc(**(void **)(a1 + 72), *(void *)(a1 + 64), *(_DWORD *)(a1 + 88), 0, *(unsigned __int8 *)(a1 + 92), &v28, v27);
      uint64_t v17 = *(void *)(*(void *)(a1 + 32) + 8);
      uint64_t result = *(int32x2_t **)(v17 + 48);
      *(void *)(v17 + 48) = v28;
      unsigned int v28 = result;
      if (result)
      {
        int v18 = result[1].i32[0] - 1;
        result[1].i32[0] = v18;
        if (!v18) {
          uint64_t result = (int32x2_t *)(*(uint64_t (**)(int32x2_t *))(*(void *)result + 8))(result);
        }
      }
      MTLPixelFormat v12 = *(RB::Texture **)(*(void *)(*(void *)(a1 + 32) + 8) + 48);
      if (v12)
      {
LABEL_16:
        uint64_t result = (int32x2_t *)RB::Texture::replace(v12, *(_DWORD *)(a1 + 80), a5, a4);
        ++*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      }
    }
  }
  return result;
}

void sub_2141AB070(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A1C401006C202);
  _Unwind_Resume(a1);
}

uint64_t ___ZN2RB12TextureCache25prepare_from_texture_dataERNS_11RenderFrameEP18CGImageTextureDataRKNS0_6ParamsEP12CGColorSpaceNSt3__18optionalIjEE_block_invoke_2(uint64_t a1)
{
  return MEMORY[0x270EE6940](*(void *)(a1 + 32));
}

uint64_t RB::TextureCache::prepare_from_base_level(int32x2_t *a1, uint64_t *a2, unsigned int *a3, uint64_t a4, unsigned int a5)
{
  unint64_t v6 = (int32x2_t *)a4;
  unsigned int v8 = *a3;
  int v9 = *a3 & 0xFF00;
  if (v9) {
    unsigned __int8 v10 = *a3;
  }
  else {
    unsigned __int8 v10 = 1;
  }
  int v11 = *(unsigned __int8 *)(a4 + 80);
  int v12 = *(unsigned __int8 *)(a4 + 79);
  unint64_t v13 = *(void *)(a4 + 56);
  uint64_t v14 = RB::pixel_format_traits(v13, (MTLPixelFormat)a2);
  unint64_t v15 = v14[8];
  if (!v14[8]) {
    unint64_t v15 = v13;
  }
  unint64_t v16 = HIDWORD(*((void *)v14 + 3));
  if (!v16) {
    unint64_t v16 = v13;
  }
  if (v12) {
    unint64_t v16 = v15;
  }
  unint64_t v58 = v16;
  unsigned int v17 = HIWORD(v8);
  uint64_t v18 = 1;
  if (a5 < BYTE2(v8))
  {
    unsigned int v55 = v8 & 0xFD000000;
    if (v11 == v10) {
      int v19 = v9;
    }
    else {
      int v19 = 0;
    }
    __asm
    {
      FMOV            V11.2S, #1.0
      FMOV            V12.2S, #-1.0
      FMOV            V15.2S, #4.0
    }
    int v54 = v19 | v8;
    while (1)
    {
      unsigned int v27 = a5 + 1;
      char v28 = v27 >= v17 ? 1 : 2;
      LOBYTE(a5) = v28 + a5;
      int32x2_t v29 = vmax_s32(vshl_s32(a1[1], vneg_s32(vdup_n_s32(a5))), (int32x2_t)0x100000001);
      __int8 v30 = v6[10].i8[0];
      RB::TextureCache::take_available((uint64_t)a1, v58, 1, v30, 1, 0, 0, &v71, v29);
      uint64_t v33 = v71;
      if (!v71)
      {
        v32.n128_u64[0] = (unint64_t)v29;
        RB::Texture::alloc(*a2, v58, 1u, 1, 0, v62, v32);
        uint64_t v33 = (int32x2_t *)v62[0];
        if (!*(void *)v62) {
          break;
        }
      }
      uint64_t v34 = (RB *)v33[7];
      char v35 = RB::pixel_format_required_depth(v34, v31);
      int v37 = RB::pixel_format_traits(*(void *)&v33[7], v36);
      RB::RenderParams::RenderParams((uint64_t)v70, (uint64_t)a2, (uint64_t)v34, v30, v30, v35, ((*v37 | ((unint64_t)*((unsigned __int16 *)v37 + 2) << 32)) & 0xA00000000) != 0, *(double *)&v29, 1.0);
      RB::RenderPass::RenderPass(v62, v70, v33, 0, 0, 0);
      RB::RenderPass::set_label((id *)v62, &cfstr_RbImageDownsam.isa);
      if (v63 == 2) {
        uint64_t v39 = 131103;
      }
      else {
        uint64_t v39 = 31;
      }
      RB::Coverage::set_plane((float32x2_t *)&v59, (uint64_t)v62, v38);
      if (v27 >= v17)
      {
        uint64_t v40 = 0x4000000040000000;
      }
      else
      {
        v39 |= 0x100000uLL;
        *(void *)&v60[44] = 0x3F800000BF800000;
        *(void *)&v60[52] = _D11;
        *(void *)&v60[60] = _D12;
        *(void *)&v60[68] = 0xBF8000003F800000;
        uint64_t v40 = _D15;
        uint64_t v61 = 0x3400340034003400;
      }
      *(_OWORD *)&v60[12] = (unint64_t)v40;
      *(void *)&v60[28] = 0;
      *(float32x2_t *)&v60[36] = vcvt_f32_s32(v6[8]);
      RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v62, (RB::Device *)0x68, 4uLL, 0, &v72);
      unsigned int v41 = v72;
      if (v72)
      {
        uint64_t v42 = *((void *)v72 + 7) + v73.i64[0];
        long long v43 = *(_OWORD *)&v60[16];
        long long v44 = v59;
        *(_OWORD *)(v42 + 16) = *(_OWORD *)v60;
        *(_OWORD *)(v42 + 32) = v43;
        long long v45 = *(_OWORD *)&v60[64];
        long long v46 = *(_OWORD *)&v60[48];
        long long v47 = *(_OWORD *)&v60[32];
        *(void *)(v42 + 96) = v61;
        *(_OWORD *)(v42 + 64) = v46;
        *(_OWORD *)(v42 + 80) = v45;
        *(_OWORD *)(v42 + 48) = v47;
        *(_OWORD *)uint64_t v42 = v44;
      }
      else
      {
        int v72 = 0;
        int64x2_t v73 = 0uLL;
      }
      int v66 = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v62, v41);
      int32x2_t v67 = vmovn_s64(v73);
      int v68 = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)v62, (uint64_t)v6);
      char v69 = 2;
      RB::RenderPass::draw_indexed_primitives(v62, (const char *)v39, 4, ***(void ***)v62 + 80, 0, 1uLL, v64, v65);
      int v68 = 0;
      char v69 = 0;
      RB::RenderPass::~RenderPass((RB::RenderPass *)v62);
      unsigned __int32 v48 = a1[7].u32[0];
      if (a1[7].i32[1] < v48 + 1)
      {
        RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,1ul,unsigned int>::reserve_slow(&a1[4], v48 + 1);
        unsigned __int32 v48 = a1[7].u32[0];
      }
      uint64_t v49 = (int32x2_t *)a1[6];
      if (!v49) {
        uint64_t v49 = a1 + 4;
      }
      uint64_t v50 = &v49[2 * v48];
      v50->i32[0] = v55 | (a5 << 16) | v54;
      v50[1] = (int32x2_t)v33;
      uint64_t v51 = a1[7].u32[0];
      a1[7].i32[0] = v51 + 1;
      uint64_t v52 = (int32x2_t *)a1[6];
      if (!v52) {
        uint64_t v52 = a1 + 4;
      }
      unint64_t v6 = (int32x2_t *)v52[2 * v51 + 1];
      unsigned int v17 = *((unsigned __int8 *)a3 + 2);
      if (v17 <= a5) {
        return 1;
      }
    }
    return 0;
  }
  return v18;
}

void sub_2141AB4A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,int a58,char a59)
{
  int v61 = v59[2] - 1;
  v59[2] = v61;
  if (!v61) {
    (*(void (**)(_DWORD *))(*(void *)v59 + 8))(v59);
  }
  _Unwind_Resume(exception_object);
}

BOOL RB::TextureCache::prune_caches(RB::TextureCache *this, int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  uint64_t v7 = *(void *)this;
  unsigned int v8 = *((_DWORD *)this + 14);
  if (v8)
  {
    unsigned int v12 = 0;
    do
    {
      if (*((void *)this + 6)) {
        unint64_t v13 = (char *)*((void *)this + 6);
      }
      else {
        unint64_t v13 = (char *)this + 32;
      }
      uint64_t v14 = &v13[16 * v12];
      uint64_t v15 = *((void *)v14 + 1);
      if (*(_DWORD *)(v15 + 32) - a2 <= 0)
      {
        if (!v7 || (unsigned int v16 = *(_DWORD *)(v15 + 36), v16 <= a4))
        {
LABEL_15:
          unsigned int v17 = &v13[16 * v8 - 16];
          int v18 = *(_DWORD *)v14;
          *(_DWORD *)uint64_t v14 = *(_DWORD *)v17;
          *(_DWORD *)unsigned int v17 = v18;
          *((void *)v14 + 1) = *((void *)v17 + 1);
          *((void *)v17 + 1) = v15;
          unsigned int v19 = *((_DWORD *)this + 14) - 1;
          *((_DWORD *)this + 14) = v19;
          unsigned __int8 v20 = (char *)*((void *)this + 6);
          if (!v20) {
            unsigned __int8 v20 = (char *)this + 32;
          }
          BOOL v21 = *(_DWORD **)&v20[16 * v19 + 8];
          if (v21)
          {
            int v22 = v21[2] - 1;
            int32x2_t v21[2] = v22;
            if (!v22) {
              (*(void (**)(_DWORD *))(*(void *)v21 + 8))(v21);
            }
          }
          goto LABEL_8;
        }
        if ((*(unsigned char *)(v15 + 77) & 1) != 0 || *(unsigned char *)(v15 + 78) == 6)
        {
          if (v16 <= a3) {
            goto LABEL_15;
          }
        }
        else
        {
          if ((*(unsigned char *)(v15 + 77) & 2) != 0) {
            uint64_t v15 = *(void *)(v15 + 24);
          }
          if (v16 <= a5 && *(unsigned char *)(v15 + 44) == 0) {
            RB::Resource::set_volatile((id *)v15, 1);
          }
        }
      }
      ++v12;
LABEL_8:
      unsigned int v8 = *((_DWORD *)this + 14);
    }
    while (v12 < v8);
  }
  MTLPixelFormat v24 = (const void *)*((void *)this + 3);
  if (v24 && (!v7 || *((_DWORD *)this + 5) <= a3 - 210))
  {
    CFRelease(v24);
    *((void *)this + 3) = 0;
  }
  if (*((void *)this + 9)) {
    double v25 = (_DWORD **)*((void *)this + 9);
  }
  else {
    double v25 = (_DWORD **)((char *)this + 64);
  }
  uint64_t v26 = *((unsigned int *)this + 20);
  if (v26)
  {
    uint64_t v27 = 8 * v26;
    do
    {
      char v28 = *v25;
      if (*v25)
      {
        int v29 = v28[2] - 1;
        Point v28[2] = v29;
        if (!v29) {
          (*(void (**)(_DWORD *))(*(void *)v28 + 8))(v28);
        }
      }
      ++v25;
      v27 -= 8;
    }
    while (v27);
  }
  BOOL result = 0;
  *((_DWORD *)this + 20) = 0;
  if (!*((_DWORD *)this + 14)) {
    return *((void *)this + 3) == 0;
  }
  return result;
}

void *RB::vector<RB::refcounted_ptr<RB::Texture>,1ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 5) + (*((_DWORD *)__dst + 5) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 5) + (*((_DWORD *)__dst + 5) >> 1);
  }
  BOOL result = RB::details::realloc_vector<unsigned int,8ul>(*((void **)__dst + 1), __dst, 1u, (_DWORD *)__dst + 5, v3);
  *((void *)__dst + 1) = result;
  return result;
}

RB::Symbol::Animation::Timing *RB::Symbol::Animation::Timing::Timing(RB::Symbol::Animation::Timing *this, const RB::Animation *a2)
{
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0x600000000;
  if (*((void *)a2 + 3)) {
    unsigned int v3 = (const RB::Animation *)*((void *)a2 + 3);
  }
  else {
    unsigned int v3 = a2;
  }
  unsigned int v4 = *((_DWORD *)a2 + 8);
  unsigned int v5 = v4;
  if (v4 >= 7)
  {
    RB::vector<RB::Animation::TermOrArg,6ul,unsigned int>::reserve_slow(this, v4);
    unint64_t v6 = (RB::Symbol::Animation::Timing *)*((void *)this + 3);
    uint64_t v7 = *((unsigned int *)this + 8);
  }
  else
  {
    unint64_t v6 = 0;
    if (!v4)
    {
      int v10 = 0;
      goto LABEL_13;
    }
    uint64_t v7 = 0;
  }
  if (!v6) {
    unint64_t v6 = this;
  }
  unsigned int v8 = (_DWORD *)((char *)v6 + 4 * v7);
  do
  {
    int v9 = *(_DWORD *)v3;
    unsigned int v3 = (const RB::Animation *)((char *)v3 + 4);
    *v8++ = v9;
    --v5;
  }
  while (v5);
  int v10 = *((_DWORD *)this + 8);
  unint64_t v6 = (RB::Symbol::Animation::Timing *)*((void *)this + 3);
LABEL_13:
  unint64_t v11 = v10 + v4;
  *((_DWORD *)this + 8) = v11;
  if (v6) {
    unsigned int v12 = v6;
  }
  else {
    unsigned int v12 = this;
  }
  *((float *)this + 10) = RB::Animation::active_duration((uint64_t)v12, v11);
  if (*((void *)this + 3)) {
    unint64_t v13 = (RB::Symbol::Animation::Timing *)*((void *)this + 3);
  }
  else {
    unint64_t v13 = this;
  }
  RB::Animation::prepare((uint64_t)v13, *((unsigned int *)this + 8), (uint64_t)this + 44);
  return this;
}

void sub_2141AB848(_Unwind_Exception *exception_object)
{
  unsigned int v3 = *(void **)(v1 + 24);
  if (v3) {
    free(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::Symbol::Animation::Animation(uint64_t result, uint64_t a2, int a3, uint64_t a4, float a5)
{
  *(_DWORD *)BOOL result = atomic_fetch_add_explicit(RB::Symbol::Animation::next_unique_id, 1u, memory_order_relaxed);
  *(_DWORD *)(result + 4) = a3;
  *(float *)(result + 8) = a5;
  *(void *)(result + 12) = *(void *)a4;
  *(_DWORD *)(result + 20) = *(_DWORD *)(a4 + 8);
  *(_DWORD *)(result + 24) = *(_DWORD *)(a4 + 20);
  *(void *)(result + 28) = *(void *)(a4 + 12);
  *(_DWORD *)(result + 36) = 0;
  *(void *)(result + 40) = *(void *)(a4 + 24);
  *(int64x2_t *)(result + 48) = vdupq_n_s64(0x7FF0000000000000uLL);
  *(void *)(result + 64) = 0;
  *(void *)(result + 72) = 0;
  atomic_fetch_add_explicit((atomic_uint *volatile)(a2 + 8), 1u, memory_order_relaxed);
  *(void *)(result + 80) = a2;
  if (*(float *)(result + 28) > 1.0) {
    *(_DWORD *)(result + 12) |= 0x800u;
  }
  return result;
}

void RB::Symbol::Animation::cancel(RB::Symbol::Animation *this, float32x2_t a2, const RB::Symbol::Model *a3)
{
  int v3 = *((_DWORD *)this + 3);
  if ((v3 & 0x1000) == 0)
  {
    if ((v3 & 0xC00) != 0)
    {
      double v5 = *(double *)&a2;
      a2.i32[0] = *((_DWORD *)this + 6);
      float32x2_t v6 = vrecpe_f32(a2);
      float32x2_t v7 = vmul_f32(vrecps_f32(a2, v6), v6);
      float v19 = vmul_f32(v7, vrecps_f32(a2, v7)).f32[0];
      float v9 = RB::Symbol::Animation::local_duration(this, a3) * v19;
      float v10 = 0.0;
      if (*((float *)this + 7) > 1.0) {
        float v10 = *((float *)this + 8);
      }
      float v11 = v10 + v9;
      double v12 = v5 - *((double *)this + 6);
      int v3 = *((_DWORD *)this + 3);
      if ((v3 & 0x200) != 0)
      {
        float v18 = v11;
        float v13 = RB::Symbol::Animation::intro_duration(this, v8);
        float v11 = v18;
        double v12 = v12 - (float)(v13 * v19);
      }
      float v14 = v11;
      float32x2_t v15 = vrecpe_f32((float32x2_t)LODWORD(v11));
      float32x2_t v16 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v14), v15), v15);
      float v17 = ceil(v12 * vmul_f32(v16, vrecps_f32((float32x2_t)LODWORD(v14), v16)).f32[0]);
      *((float *)this + 7) = v17;
    }
    *((_DWORD *)this + 3) = v3 | 0x1000;
  }
}

float RB::Symbol::Animation::local_duration(RB::Symbol::Animation *this, const RB::Symbol::Model *a2)
{
  uint64_t v3 = *((void *)this + 9);
  if (v3 && (*((unsigned char *)this + 12) & 0x80) != 0) {
    return *(float *)(v3 + 40);
  }
  float result = 0.0;
  switch(*((_DWORD *)this + 1))
  {
    case 0:
    case 7:
      float result = 0.33333;
      break;
    case 1:
      unsigned int v5 = *(_DWORD *)(RB::Symbol::Model::glyph_info(a2) + 396);
      unsigned int v6 = *((_DWORD *)this + 3);
      unsigned int v7 = ((v6 >> 28) & 1) + v5;
      switch((v6 >> 30) ^ 2)
      {
        case 1u:
          float result = 1.3333;
          if (v7 != 3) {
            float result = 2.5;
          }
          if (v7 < 3) {
            return 0.66667;
          }
          return result;
        case 2u:
          float v16 = fmaxf((float)v5, 1.0);
          float v9 = (float)(v16 * 0.33333) + 0.66667;
          BOOL v10 = v16 <= 3.0;
          float result = 1.6667;
          goto LABEL_31;
        case 3u:
          float v17 = fmaxf((float)v5, 1.0);
          float v9 = (float)(v17 * 0.66667) + 0.33333;
          BOOL v10 = v17 <= 3.0;
          float result = 2.3333;
          goto LABEL_31;
        default:
          if ((v6 & 0x40) != 0)
          {
            if (v5 > 3)
            {
              *(float *)&unsigned int v18 = (float)((float)((float)v5 * 0.083333) + 0.33333)
                             + (float)((float)(2 * v5 - 8) * 0.016667);
              float32x2_t v19 = vrecpe_f32((float32x2_t)v18);
              float32x2_t v20 = vmul_f32(vrecps_f32((float32x2_t)v18, v19), v19);
              float result = (float)((float)v5 * 0.11111) * vmul_f32(v20, vrecps_f32((float32x2_t)v18, v20)).f32[0];
            }
            else
            {
              float result = (float)v5 * 0.33333;
            }
          }
          else
          {
            float v8 = fmaxf((float)v7, 1.0);
            float v9 = (float)(v8 * 0.33333) + 0.33333;
            BOOL v10 = v8 <= 3.0;
            float result = 1.3333;
LABEL_31:
            if (v10) {
              float result = v9;
            }
          }
          break;
      }
      break;
    case 2:
      if (*((int *)this + 3) < 0) {
        int v11 = 1;
      }
      else {
        int v11 = 2;
      }
      float result = (float)v11;
      break;
    case 3:
      BOOL v12 = (*((unsigned char *)this + 12) & 0x20) == 0;
      float v13 = (float *)&unk_21421A058;
      goto LABEL_23;
    case 4:
    case 5:
      float result = 0.25;
      break;
    case 6:
      unsigned int v14 = *((_DWORD *)this + 3);
      unsigned int v15 = ((v14 & 0xE000000) - 0x2000000) >> 25;
      float result = 1.0;
      if (v15 - 2 >= 3)
      {
        if (v15)
        {
          if (v15 == 1)
          {
            float result = 0.7;
          }
          else
          {
            float result = 0.5;
            if (v14 >> 30 == 3) {
              float result = 0.25;
            }
          }
        }
        else
        {
          float result = 0.66667;
        }
      }
      break;
    case 9:
      float result = 0.16667;
      break;
    case 0xA:
      BOOL v12 = (*((unsigned char *)this + 12) & 0x20) == 0;
      float v13 = (float *)&unk_21421A050;
LABEL_23:
      float result = v13[v12];
      break;
    case 0xB:
      float result = 2.0;
      break;
    case 0xC:
      float result = 3.0;
      break;
    default:
      return result;
  }
  return result;
}

float RB::Symbol::Animation::intro_duration(RB::Symbol::Animation *this, const RB::Symbol::Model *a2)
{
  int v2 = *((_DWORD *)this + 1);
  if (v2 <= 9)
  {
    if (v2 == 1) {
      return 0.33333;
    }
    if (v2 == 3)
    {
      BOOL v3 = (*((unsigned char *)this + 12) & 0x20) == 0;
      float result = 0.43333;
      goto LABEL_11;
    }
    return 0.0;
  }
  if (v2 == 10)
  {
    BOOL v3 = (*((unsigned char *)this + 12) & 0x20) == 0;
    float result = 0.33333;
  }
  else
  {
    if (v2 != 11) {
      return 0.0;
    }
    BOOL v3 = (*((unsigned char *)this + 12) & 0x20) == 0;
    float result = 2.5;
  }
LABEL_11:
  if (v3) {
    return 0.0;
  }
  return result;
}

void RB::Symbol::Animation::send_completion(RB::Symbol::Animation *this, char a2)
{
  int v2 = (void *)*((void *)this + 8);
  if (v2)
  {
    *((void *)this + 8) = 0;
    int v4 = *(_DWORD *)this;
    v5[0] = MEMORY[0x263EF8330];
    v5[1] = 3321888768;
    float64x2_t v5[2] = ___ZN2RB6Symbol9Animation15send_completionEb_block_invoke;
    void v5[3] = &__block_descriptor_45_e8_32c41_ZTSN2RB8objc_ptrIU13block_pointerFvbjEEE_e5_v8__0l;
    id v6 = v2;
    char v8 = a2;
    int v7 = v4;
    dispatch_async(MEMORY[0x263EF83A0], v5);
  }
}

void sub_2141ABE14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN2RB6Symbol9Animation15send_completionEb_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 44), *(unsigned int *)(a1 + 40));
}

id __copy_helper_block_e8_32c41_ZTSN2RB8objc_ptrIU13block_pointerFvbjEEE(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_e8_32c41_ZTSN2RB8objc_ptrIU13block_pointerFvbjEEE(uint64_t a1)
{
}

double RB::Symbol::Animation::begin_time_after(RB::Symbol::Animation *this, double a2, const RB::Symbol::Model *a3, double a4, double a5)
{
  if ((*((void *)this + 6) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    return INFINITY;
  }
  LODWORD(a5) = *((_DWORD *)this + 6);
  float32x2_t v7 = vrecpe_f32(*(float32x2_t *)&a5);
  float32x2_t v8 = vmul_f32(vrecps_f32(*(float32x2_t *)&a5, v7), v7);
  LODWORD(a5) = vmul_f32(v8, vrecps_f32(*(float32x2_t *)&a5, v8)).u32[0];
  float v15 = *(float *)&a5;
  double v9 = a2 - *((double *)this + 6);
  if ((*((unsigned char *)this + 13) & 2) != 0) {
    double v9 = v9 - (float)(RB::Symbol::Animation::intro_duration(this, a3) * *(float *)&a5);
  }
  float v11 = RB::Symbol::Animation::local_duration(this, a3) * v15;
  float v12 = 0.0;
  if (*((float *)this + 7) > 1.0) {
    float v12 = *((float *)this + 8);
  }
  double v13 = *((double *)this + 6) + ceil(v9 / (float)(v12 + v11)) * (float)(v12 + v11);
  if ((*((unsigned char *)this + 13) & 4) != 0) {
    return v13 + (float)(RB::Symbol::Animation::outro_duration(this, v10) * v15);
  }
  return v13;
}

float RB::Symbol::Animation::outro_duration(RB::Symbol::Animation *this, const RB::Symbol::Model *a2)
{
  int v2 = *((_DWORD *)this + 1);
  if (v2 <= 9)
  {
    if (v2 == 1) {
      return 0.33333;
    }
    if (v2 == 3)
    {
      BOOL v3 = (*((unsigned char *)this + 12) & 0x20) == 0;
      float result = 0.26667;
      goto LABEL_11;
    }
    return 0.0;
  }
  if (v2 == 10)
  {
    BOOL v3 = (*((unsigned char *)this + 12) & 0x20) == 0;
    float result = 0.41667;
  }
  else
  {
    if (v2 != 11) {
      return 0.0;
    }
    BOOL v3 = (*((unsigned char *)this + 12) & 0x20) == 0;
    float result = 2.5;
  }
LABEL_11:
  if (v3) {
    return 0.0;
  }
  return result;
}

double RB::Symbol::Animation::end_time(RB::Symbol::Animation *this, const RB::Symbol::Model *a2, float32x2_t a3)
{
  if ((*((void *)this + 6) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (*((_DWORD *)this + 7) & 0x7FFFFFFFu) > 0x7F7FFFFF)
  {
    return INFINITY;
  }
  a3.i32[0] = *((_DWORD *)this + 6);
  float32x2_t v5 = vrecpe_f32(a3);
  float32x2_t v6 = vmul_f32(vrecps_f32(a3, v5), v5);
  float v20 = vmul_f32(v6, vrecps_f32(a3, v6)).f32[0];
  double v8 = *((double *)this + 6)
     + (float)((float)((float)(*((float *)this + 7) * RB::Symbol::Animation::local_duration(this, a2)) * v20)
             + (float)(fmaxf(*((float *)this + 7) + -1.0, 0.0) * *((float *)this + 8)));
  int v9 = *((_DWORD *)this + 3);
  if ((v9 & 0x40) != 0)
  {
    uint64_t v11 = RB::Symbol::Model::glyph_info(a2);
    if (*(void *)(v11 + 376)) {
      float v12 = *(const RB::Symbol::Glyph::Layer **)(v11 + 376);
    }
    else {
      float v12 = (const RB::Symbol::Glyph::Layer *)(v11 + 112);
    }
    unsigned int v13 = *(_DWORD *)(v11 + 384);
    if (v13)
    {
      uint64_t v14 = 88 * v13;
      float v15 = 0.0;
      do
      {
        float v16 = RB::Symbol::Animation::layer_delay(this, a2, v12);
        if (v15 < v16) {
          float v15 = v16;
        }
        float v12 = (const RB::Symbol::Glyph::Layer *)((char *)v12 + 88);
        v14 -= 88;
      }
      while (v14);
      double v17 = v15;
    }
    else
    {
      double v17 = 0.0;
    }
    double v8 = v8 + v17;
    int v9 = *((_DWORD *)this + 3);
    if ((v9 & 0x200) == 0)
    {
LABEL_5:
      if ((v9 & 0x400) == 0) {
        goto LABEL_6;
      }
LABEL_22:
      double v8 = v8 + (float)(RB::Symbol::Animation::outro_duration(this, v7) * v20);
      if ((v9 & 0x80) != 0) {
        return v8;
      }
      goto LABEL_23;
    }
  }
  else if ((v9 & 0x200) == 0)
  {
    goto LABEL_5;
  }
  double v8 = v8 + (float)(RB::Symbol::Animation::intro_duration(this, v7) * v20);
  if ((v9 & 0x400) != 0) {
    goto LABEL_22;
  }
LABEL_6:
  if ((v9 & 0x80) != 0) {
    return v8;
  }
LABEL_23:
  uint64_t v18 = *((void *)this + 9);
  if (v18)
  {
    double v19 = *(float *)(v18 + 40);
    if (v8 < *((double *)this + 6) + v19) {
      return *((double *)this + 6) + v19;
    }
  }
  return v8;
}

float RB::Symbol::Animation::layer_delay(RB::Symbol::Animation *this, const RB::Symbol::Model *a2, const RB::Symbol::Glyph::Layer *a3)
{
  int v4 = *((_DWORD *)this + 1);
  if (v4 == 10 || v4 == 3)
  {
    unsigned int v7 = *(_DWORD *)(RB::Symbol::Model::glyph_info(a2) + 400);
    if (v7 >= 5)
    {
      *(float *)&unsigned int v12 = (float)v7 + -1.0;
      float32x2_t v13 = vrecpe_f32((float32x2_t)v12);
      float32x2_t v14 = vmul_f32(vrecps_f32((float32x2_t)v12, v13), v13);
      float v8 = 0.15 * vmul_f32(v14, vrecps_f32((float32x2_t)v12, v14)).f32[0];
    }
    else
    {
      float v8 = 0.05;
    }
    unsigned int v15 = *((_DWORD *)a3 + 17);
    if (*((_DWORD *)this + 1) == 3)
    {
      unsigned int v16 = v7 + ~v15;
      if (*((int *)this + 3) < 0) {
        unsigned int v15 = v16;
      }
    }
    float v11 = (float)v15;
  }
  else
  {
    float result = 0.0;
    if (v4 != 1) {
      return result;
    }
    unsigned int v10 = *(_DWORD *)(RB::Symbol::Model::glyph_info(a2) + 396);
    if (v10 > 3)
    {
      *(float *)&unsigned int v17 = (float)((float)((float)v10 * 0.083333) + 0.33333) + (float)((float)(2 * v10 - 8) * 0.016667);
      float32x2_t v18 = vrecpe_f32((float32x2_t)v17);
      float32x2_t v19 = vmul_f32(vrecps_f32((float32x2_t)v17, v18), v18);
      return (float)(0.11111 * (float)*((unsigned int *)a3 + 20))
           * vmul_f32(v19, vrecps_f32((float32x2_t)v17, v19)).f32[0];
    }
    float v8 = (float)*((unsigned int *)a3 + 20);
    float v11 = 0.33333;
  }
  return v8 * v11;
}

RB::Symbol::Model *RB::Symbol::Animation::style_mask(RB::Symbol::Animation *this)
{
  float result = (RB::Symbol::Model *)*((void *)this + 10);
  if (result) {
    return (RB::Symbol::Model *)*(unsigned int *)(RB::Symbol::Model::glyph_info(result) + 392);
  }
  return result;
}

uint64_t RB::Symbol::Animation::will_apply(uint64_t this, double a2)
{
  if (*(double *)(this + 56) != a2)
  {
    unsigned int v2 = *(_DWORD *)(this + 36);
    if (v2 >= 2)
    {
      if (v2 != 2) {
        return this;
      }
      if ((*(unsigned char *)(this + 13) & 0x40) == 0 && a2 - *(double *)(this + 48) > 0.0333333333) {
        *(double *)(this + 48) = a2 + -0.0333333333;
      }
      int v3 = 3;
    }
    else
    {
      if ((*(unsigned char *)(this + 13) & 0x40) == 0) {
        *(double *)(this + 48) = a2;
      }
      if (v2) {
        int v3 = 2;
      }
      else {
        int v3 = 1;
      }
    }
    *(_DWORD *)(this + 36) = v3;
  }
  return this;
}

void RB::Symbol::Animation::apply(RB::Symbol::Animation *this, double a2, const RB::Symbol::Model *a3, const RB::Symbol::Animator *a4, RB::Symbol::Presentation *a5, RB::Symbol::KeyframeStorage *a6)
{
  unsigned int v7 = a5;
  float v8 = a3;
  float v11 = a2 - *((double *)this + 6);
  int v12 = *((_DWORD *)a5 + 233);
  if (v12 == 2)
  {
    if (*((void *)a5 + 105)) {
      MTLPixelFormat v23 = (char *)*((void *)a5 + 105);
    }
    else {
      MTLPixelFormat v23 = (char *)a5 + 8;
    }
    int v24 = *((_DWORD *)a5 + 212);
    if (!v24) {
      goto LABEL_135;
    }
    double v25 = a6;
    int v128 = &v23[416 * v24];
    double v26 = INFINITY;
    __asm { FMOV            V0.2S, #1.0 }
    unsigned int v119 = HIDWORD(_D0);
    int32x2_t v120 = vdup_n_s32(0x3E99999Au);
    while (*(_DWORD *)(*(void *)v23 + 84) - *(_DWORD *)(*((void *)this + 10) + 84) < 0)
    {
LABEL_121:
      v23 += 416;
      if (v23 == v128) {
        goto LABEL_136;
      }
    }
    uint64_t v31 = RB::Symbol::Model::glyph_info(*(RB::Symbol::Model **)v23);
    int v32 = 0;
    int v33 = *(_DWORD *)(v31 + 396);
    int v139 = 0;
    int v140 = v33;
    LOBYTE(v33) = *(unsigned char *)(v31 + 404);
    unsigned __int8 v141 = v33 & 1;
    BOOL v142 = (v33 & 2) != 0;
    uint64_t v34 = *((void *)this + 10);
    int v35 = *(unsigned __int16 *)(v34 + 88) | (*(unsigned __int8 *)(v34 + 90) << 16);
    int v36 = *((unsigned __int16 *)v8 + 44) | (*((unsigned __int8 *)v8 + 90) << 16);
    unsigned int v127 = *(_DWORD *)(v31 + 24);
    uint64_t v137 = v127;
    uint64_t v138 = *(unsigned int *)(v31 + 400);
    int32x2_t v143 = vshr_n_s32(vshr_n_s32(vshl_n_s32(vshl_n_s32((int32x2_t)__PAIR64__(v36, v35), 8uLL), 8uLL), 8uLL), 0x10uLL);
    uint64_t v129 = v23;
    if (*((_DWORD *)this + 1) == 6)
    {
      if (*(void *)v23 == v34)
      {
        int v32 = 1;
      }
      else
      {
        if (*(const RB::Symbol::Model **)v23 != v8)
        {
LABEL_120:
          MTLPixelFormat v23 = v129;
          unsigned int v7 = a5;
          float v8 = a3;
          goto LABEL_121;
        }
        int v32 = 2;
      }
      HIDWORD(v137) = v32;
      HIDWORD(v138) = *(_DWORD *)(RB::Symbol::Model::glyph_info((RB::Symbol::Model *)v34) + 400);
      int v139 = *(_DWORD *)(RB::Symbol::Model::glyph_info(v8) + 400);
    }
    if ((*((unsigned char *)this + 12) & 0x40) != 0)
    {
      uint64_t v40 = 0;
    }
    else
    {
      LODWORD(v37) = RB::Symbol::Animation::local_time(this, v11, v8, 0, (uint64_t)v134).u32[0];
      float v6 = *(float *)v134;
      float v38 = v135;
      uint64_t v39 = (unsigned int *)RB::Symbol::Animation::keyframes((uint64_t)this, &v137, v25, v136, v8, v37);
      if (!v39) {
        goto LABEL_136;
      }
      uint64_t v40 = v39;
      RB::Symbol::Presentation::record_keyframes(v7, (int *)this, v32, v39, v25);
      if (*((double *)this + 6) + v38 < v26) {
        double v26 = *((double *)this + 6) + v38;
      }
    }
    if (*((void *)v23 + 47)) {
      unsigned int v41 = (char *)*((void *)v23 + 47);
    }
    else {
      unsigned int v41 = v23 + 16;
    }
    int v42 = *((_DWORD *)v23 + 96);
    if (v42)
    {
      uint64_t v121 = v23 + 16;
      long long v43 = &v41[120 * v42];
      while (1)
      {
        if (((*((_DWORD *)v41 + 29) >> *((_DWORD *)this + 1)) & 1) == 0)
        {
          if ((*((unsigned char *)this + 12) & 0x40) == 0) {
            goto LABEL_49;
          }
          LODWORD(v44) = RB::Symbol::Animation::local_time(this, v11, a3, *(const RB::Symbol::Glyph::Layer **)v41, (uint64_t)v134).u32[0];
          float v6 = *(float *)v134;
          float v45 = v135;
          uint64_t v40 = (unsigned int *)RB::Symbol::Animation::keyframes((uint64_t)this, &v137, v25, v136, a3, v44);
          if (v40) {
            break;
          }
        }
LABEL_119:
        v41 += 120;
        if (v41 == v43) {
          goto LABEL_120;
        }
      }
      RB::Symbol::Presentation::record_keyframes(a5, (int *)this, v32, v40, v25);
      if (*((double *)this + 6) + v45 < v26) {
        double v26 = *((double *)this + 6) + v45;
      }
LABEL_49:
      unsigned int v46 = *v40;
      int v47 = *v40 & 0xF;
      if (v47)
      {
        int v131 = v141;
        unsigned __int32 v48 = v40;
        do
        {
          int v49 = *(_DWORD *)(*(void *)v41 + 68);
          int v50 = *(_DWORD *)(*(void *)v41 + 80);
          unsigned int v51 = *(_DWORD *)(*(void *)v41 + 84);
          int v52 = RB::Symbol::Animation::layer_flagged((uint64_t)this, *(void *)v41, v47);
          if (*((void *)v48 + 1))
          {
            int v54 = (v46 >> 4) & 7;
            if (!v54 || v54 == v32)
            {
              int v55 = (v46 >> 7) & 3;
              if (!v55 || v55 == ((v51 >> 20) & 3))
              {
                int v56 = (v46 >> 10) & 0x7FF;
                if (v56 == 2047 || v56 == v49)
                {
                  int v57 = v46 >> 21;
                  if (v46 >> 21 == 2047) {
                    goto LABEL_62;
                  }
                  if (v46 < 0x200000) {
                    int v57 = -1;
                  }
                  if (v57 == v50)
                  {
LABEL_62:
                    if (((v52 ^ 1) & (v46 >> 9) & 1) == 0)
                    {
                      float v58 = RB::Symbol::Keyframes::eval((RB::Symbol::Keyframes *)v48, v6, a6, v53);
                      *(float *)v60.i32 = v58;
                      switch(*v48 & 0xF)
                      {
                        case 1u:
                          *((float *)v41 + 6) = *((float *)v41 + 6) * v58;
                          break;
                        case 2u:
                          int v61 = *((unsigned __int16 *)a3 + 44);
                          int v62 = v61 << 8;
                          int v63 = (__int16)v61 << 8;
                          float v64 = 1.25;
                          if ((v62 & 0xFF0000) == 0) {
                            float v64 = 1.0;
                          }
                          if (v63 < 0) {
                            float v64 = 0.5;
                          }
                          float v65 = v64 * *(float *)v60.i32;
                          goto LABEL_75;
                        case 3u:
                          int v66 = *((unsigned __int16 *)a3 + 44);
                          int v67 = v66 << 8;
                          int v68 = (__int16)v66 << 8;
                          float v69 = 1.25;
                          if ((v67 & 0xFF0000) == 0) {
                            float v69 = 1.0;
                          }
                          if (v68 < 0) {
                            float v69 = 0.5;
                          }
                          float v70 = *((float *)v41 + 9);
                          float v64 = v69 - v70;
                          float v65 = v70 + (float)(v64 * *(float *)v60.i32);
LABEL_75:
                          *((float *)v41 + 9) = v65;
                          RB::Symbol::Presentation::Layer::add_scale_velocity((float32x2_t *)v41, v64 * v59);
                          break;
                        case 4u:
                          float v122 = v58;
                          RB::Symbol::Presentation::Layer::add_scale_velocity((float32x2_t *)v41, v59);
                          *((float *)v41 + 10) = v122;
                          break;
                        case 5u:
                          int32x2_t v71 = *(int32x2_t *)((char *)this + 40);
                          *((float32x2_t *)v41 + 8) = vmla_n_f32(*(float32x2_t *)(v41 + 64), (float32x2_t)v71, *(float *)v60.i32);
                          *(float *)v71.i32 = v59 * *(float *)v60.i32;
                          RB::Symbol::Presentation::Layer::add_velocity((float32x2_t *)v41, COERCE_DOUBLE(vdup_lane_s32(v71, 0)));
                          break;
                        case 6u:
                          *((float *)v41 + 11) = *((float *)v41 + 11) + v58;
                          goto LABEL_80;
                        case 7u:
                          *((float *)v41 + 12) = *((float *)v41 + 12) + v58;
LABEL_80:
                          RBStrokeRef::clip(v41);
                          break;
                        case 8u:
                          *((float *)v41 + 6) = v58;
                          *((float *)v41 + 7) = v58;
                          break;
                        case 9u:
                          float32x2_t v72 = (float32x2_t)vdup_lane_s32(v60, 0);
                          float32x2_t v73 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v72, *(float32x2_t *)(v41 + 24)), (int8x8_t)v72, *(int8x8_t *)(v41 + 24));
                          goto LABEL_116;
                        case 0xAu:
                          int32x2_t v74 = 0;
                          if ((*((_DWORD *)this + 3) & 0x20000000) == 0)
                          {
                            *(float *)v74.i32 = 0.3;
                            if (v127 == 3)
                            {
                              __int32 v123 = v60.i32[0];
                              *(float *)v74.i32 = RB::Symbol::Model::alpha(a3, 2uLL, 0.3);
                              v60.i32[0] = v123;
                            }
                          }
                          *((float32x2_t *)v41 + 3) = vmla_n_f32(*(float32x2_t *)(v41 + 24), vsub_f32((float32x2_t)vdup_lane_s32(v74, 0), *(float32x2_t *)(v41 + 24)), *(float *)v60.i32);
                          break;
                        case 0xBu:
                          unsigned int v75 = *((_DWORD *)a3 + 20);
                          unsigned int v76 = *(_DWORD *)(*(void *)v41 + 80);
                          if ((v76 | v75) == 0xFFFFFFFF)
                          {
                            float v125 = v58;
                            uint64_t v86 = RB::Symbol::Model::glyph_info(a3);
                            if (v86 != RB::Symbol::Model::glyph_info(*(RB::Symbol::Model **)v129)) {
                              break;
                            }
                            __int8 v87 = (char *)*((void *)v129 + 47);
                            if (!v87) {
                              __int8 v87 = v121;
                            }
                            unsigned int v88 = -286331153 * ((unint64_t)(v41 - v87) >> 3);
                            uint64_t v89 = RB::Symbol::Model::glyph_info(a3);
                            uint64_t v91 = v89 + 112;
                            if (*(void *)(v89 + 376)) {
                              uint64_t v91 = *(void *)(v89 + 376);
                            }
                            float v92 = RB::Symbol::Model::alpha(a3, *(unsigned __int8 *)(v91 + 88 * v88 + 84), v90);
                            *(float *)v60.i32 = v125;
                            float32x2_t v77 = (float32x2_t)__PAIR64__(v119, LODWORD(v92));
                          }
                          else
                          {
                            if (v75 >= v76)
                            {
                              unsigned int v78 = a3;
                              unint64_t v79 = 0;
                            }
                            else
                            {
                              float32x2_t v77 = (float32x2_t)v120;
                              if (v127 != 3) {
                                goto LABEL_115;
                              }
                              unsigned int v78 = a3;
                              unint64_t v79 = 2;
                            }
                            float v126 = v58;
                            *(float *)v93.i32 = RB::Symbol::Model::alpha(v78, v79, v58);
                            *(float *)v60.i32 = v126;
                            float32x2_t v77 = (float32x2_t)vdup_lane_s32(v93, 0);
                          }
LABEL_115:
                          float32x2_t v73 = vmla_n_f32(*(float32x2_t *)(v41 + 24), vsub_f32(v77, *(float32x2_t *)(v41 + 24)), *(float *)v60.i32);
LABEL_116:
                          *((float32x2_t *)v41 + 3) = v73;
                          break;
                        case 0xCu:
                          if (*((float *)v41 + 6) > 0.0)
                          {
                            float v80 = 0.3;
                            if (!v131)
                            {
                              float v80 = 0.3;
                              if ((*((unsigned char *)this + 12) & 0x10) != 0)
                              {
                                float v80 = 0.3;
                                if (v127 == 3)
                                {
                                  unsigned int v81 = *(unsigned __int8 *)(*(void *)v41 + 84);
                                  if (v81 <= 1) {
                                    unint64_t v82 = v81 + 1;
                                  }
                                  else {
                                    unint64_t v82 = v81 - 1;
                                  }
                                  __int32 v124 = v60.i32[0];
                                  float v83 = RB::Symbol::Model::alpha(a3, v82, 0.3);
                                  float v84 = RB::Symbol::Model::alpha(a3, *(unsigned __int8 *)(*(void *)v41 + 84), v83);
                                  v60.i32[0] = v124;
                                  float v80 = v83 / v84;
                                }
                              }
                            }
                            *((float *)v41 + 6) = (float)(v80 + (float)((float)(1.0 - v80) * *(float *)v60.i32))
                                                * *((float *)v41 + 6);
                          }
                          float v85 = *((float *)v41 + 7);
                          if (v85 > 0.0 && !v141 && (*((unsigned char *)this + 12) & 0x10) != 0) {
                            *((float *)v41 + 7) = v85 * (float)((float)(*(float *)v60.i32 * 0.7) + 0.3);
                          }
                          break;
                        case 0xDu:
                          *((float *)v41 + 6) = *((float *)v41 + 6) * v58;
                          if (v58 <= 0.0) {
                            *((_DWORD *)v41 + 7) = 0;
                          }
                          break;
                        case 0xEu:
                          *((float *)v41 + 13) = v58;
                          break;
                        default:
                          break;
                      }
                    }
                  }
                }
              }
            }
          }
          unsigned int v94 = v48[4];
          v48 += 4;
          unsigned int v46 = v94;
          int v47 = v94 & 0xF;
        }
        while ((v94 & 0xF) != 0);
      }
      *((_DWORD *)v41 + 29) |= *((_DWORD *)this + 5);
      double v25 = a6;
      goto LABEL_119;
    }
    goto LABEL_120;
  }
  if (v12 == 1)
  {
    CGRect v95 = (char *)a5 + 8;
    if (*((void *)a5 + 105)) {
      CGRect v95 = (char *)*((void *)a5 + 105);
    }
    unsigned int v96 = *((_DWORD *)a5 + 212);
    if (v96)
    {
      uint64_t v97 = 416 * v96;
      do
      {
        uint64_t v98 = *((void *)this + 10);
        if (*(_DWORD *)(*(void *)v95 + 84) - *(_DWORD *)(v98 + 84) >= 0)
        {
          int v99 = *((_DWORD *)this + 1);
          if (v99)
          {
            if (v99 == 4 && !v95[409])
            {
              char v100 = *(unsigned char *)(v98 + 89);
              v95[409] = 1;
              v95[408] = v100;
            }
          }
          else if (!*((void *)v95 + 1))
          {
            atomic_fetch_add_explicit((atomic_uint *volatile)(v98 + 8), 1u, memory_order_relaxed);
            *((void *)v95 + 1) = v98;
          }
        }
        v95 += 416;
        v97 -= 416;
      }
      while (v97);
    }
    goto LABEL_135;
  }
  if (v12
    || (uint64_t v13 = *((void *)this + 10)) == 0
    || ((*(unsigned __int16 *)(v13 + 88) | (*(unsigned __int8 *)(v13 + 90) << 16)) & 0x10000) != 0
    || (*(_WORD *)(v13 + 88) != 0xFF ? (_ZF = *(void *)(v13 + 16) == 0) : (_ZF = 1), _ZF))
  {
LABEL_135:
    double v26 = INFINITY;
LABEL_136:
    if (v26 - a2 < 0.00416666667)
    {
      float v101 = 0.05;
      v102.i32[1] = 0;
      if (*((_DWORD *)this + 1) >= 3u) {
        float v101 = 0.0;
      }
      v102.i32[0] = *((_DWORD *)this + 6);
      float32x2_t v103 = vrecpe_f32(v102);
      float32x2_t v104 = vmul_f32(vrecps_f32(v102, v103), v103);
      double v26 = (float)(v101 * vmul_f32(v104, vrecps_f32(v102, v104)).f32[0]) + a2;
    }
    double v105 = *((double *)v7 + 114);
    if (v105 > v26) {
      double v105 = v26;
    }
    *((double *)v7 + 114) = v105;
    return;
  }
  if (*((void *)a5 + 105)) {
    unsigned int v15 = (char *)*((void *)a5 + 105);
  }
  else {
    unsigned int v15 = (char *)a5 + 8;
  }
  unsigned int v16 = *((_DWORD *)a5 + 212);
  if (!v16)
  {
LABEL_17:
    int v18 = *((_DWORD *)this + 1);
    if (v18 == 7)
    {
      if (v16)
      {
        uint64_t v106 = RB::Heap::emplace<RB::Symbol::Presentation::Interpolant>((RB::Symbol::Presentation *)((char *)a5 + 944));
        uint64_t v137 = 0;
        uint64_t v138 = 0;
        int v139 = 0;
        float32x2_t v108 = RB::Symbol::Animation::local_time(this, v11, v8, 0, (uint64_t)&v137);
        __int32 v107 = v138;
        v108.f32[0] = *(float *)&v138 * *(float *)&v137;
        *(float *)uint64_t v106 = *(float *)&v138 * *(float *)&v137;
        *(_DWORD *)(v106 + 4) = v107;
        int v109 = *((_DWORD *)this + 3);
        if (!*((void *)this + 9) || (v109 & 0x80) == 0)
        {
          v110.i32[0] = vdup_lane_s32((int32x2_t)v108, 0).u32[0];
          v110.i32[1] = v107;
          *(float32x2_t *)uint64_t v106 = vmul_f32(vmul_n_f32(v110, v108.f32[0]), vmla_n_f32((float32x2_t)0x40C0000040400000, (float32x2_t)0xC0C00000C0000000, v108.f32[0]));
        }
        *(unsigned char *)(v106 + 8) = v109 >= 0;
        if (*((void *)v7 + 105)) {
          unsigned int v111 = (char *)*((void *)v7 + 105);
        }
        else {
          unsigned int v111 = (char *)v7 + 8;
        }
        unsigned int v16 = *((_DWORD *)v7 + 212);
        *(void *)&v111[416 * v16 - 24] = v106;
        *((unsigned char *)v7 + 928) = 1;
      }
      double v26 = a2;
      goto LABEL_169;
    }
    if (v18 == 6)
    {
      RB::Symbol::Animation::infer_replace_subtype(this, (const RB::Symbol::Model *)v13, v8);
      int v19 = *((_DWORD *)this + 3) & 0xE000000;
      unsigned int v20 = (v19 - 0x2000000) >> 25;
      if (v20 - 2 < 3)
      {
        int v21 = 2;
        float v22 = 1.0;
LABEL_158:
        uint64_t v112 = RB::Heap::emplace<RB::Symbol::Presentation::Interpolant>((RB::Symbol::Presentation *)((char *)v7 + 944));
        uint64_t v137 = 0;
        uint64_t v138 = 0;
        int v139 = 0;
        RB::Symbol::Animation::local_time(this, v11, v8, 0, (uint64_t)&v137);
        int v113 = v138;
        float v114 = (float)(*(float *)&v137 * v22) * *(float *)&v138;
        if (v114 < 0.0) {
          float v114 = 0.0;
        }
        if (v114 > 1.0) {
          float v114 = 1.0;
        }
        *(float *)uint64_t v112 = v114;
        *(_DWORD *)(v112 + 4) = v113;
        *(unsigned char *)(v112 + 8) = 0;
        if (!*(unsigned char *)(v112 + 16)) {
          *(unsigned char *)(v112 + 16) = 1;
        }
        *(_DWORD *)(v112 + 12) = v21;
        if (*((void *)v7 + 105)) {
          uint64_t v115 = (char *)*((void *)v7 + 105);
        }
        else {
          uint64_t v115 = (char *)v7 + 8;
        }
        unsigned int v16 = *((_DWORD *)v7 + 212);
        *(void *)&v115[416 * v16 - 24] = v112;
        *((unsigned char *)v7 + 928) = 1;
        goto LABEL_168;
      }
      if (v20 < 2)
      {
        if (v19 == 0x2000000) {
          float v22 = 2.0;
        }
        else {
          float v22 = *(float *)"333@";
        }
        int v21 = 1;
        goto LABEL_158;
      }
      unsigned int v16 = *((_DWORD *)v7 + 212);
    }
LABEL_168:
    double v26 = INFINITY;
LABEL_169:
    uint64_t v116 = *((void *)this + 10);
    if (*((_DWORD *)v7 + 213) < v16 + 1)
    {
      RB::vector<RB::Symbol::Presentation::Symbol,2ul,unsigned int>::reserve_slow((char *)v7 + 8, v16 + 1);
      unsigned int v16 = *((_DWORD *)v7 + 212);
    }
    uint64_t v117 = (char *)*((void *)v7 + 105);
    if (!v117) {
      uint64_t v117 = (char *)v7 + 8;
    }
    uint64_t v118 = &v117[416 * v16];
    atomic_fetch_add_explicit((atomic_uint *volatile)(v116 + 8), 1u, memory_order_relaxed);
    *(void *)uint64_t v118 = v116;
    *((void *)v118 + 1) = 0;
    *((void *)v118 + 47) = 0;
    *((void *)v118 + 48) = 0x300000000;
    *((void *)v118 + 49) = 0;
    *((void *)v118 + 50) = 0;
    *(_DWORD *)(v118 + 407) = 0;
    ++*((_DWORD *)v7 + 212);
    goto LABEL_136;
  }
  uint64_t v17 = 416 * v16;
  while (*(_DWORD *)(v13 + 84) != *(_DWORD *)(*(void *)v15 + 84))
  {
    v15 += 416;
    v17 -= 416;
    if (!v17) {
      goto LABEL_17;
    }
  }
  *((_DWORD *)this + 3) |= 0x8000u;
}

void RB::Symbol::Animation::infer_replace_subtype(RB::Symbol::Animation *this, const RB::Symbol::Model *a2, const RB::Symbol::Model *a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  *((_DWORD *)this + 3) &= 0xF1FFFFFF;
  uint64_t v5 = RB::Symbol::Model::glyph_info(a2);
  uint64_t v6 = RB::Symbol::Model::glyph_info(a3);
  if (*(_DWORD *)(v5 + 24) != *(_DWORD *)(v6 + 24)) {
    return;
  }
  unsigned int v7 = (_DWORD *)v6;
  if (*(float *)(v5 + 32) != *(float *)(v6 + 32)) {
    return;
  }
  if (*(float *)(v5 + 36) != *(float *)(v6 + 36)) {
    return;
  }
  if (*(float *)(v5 + 40) != *(float *)(v6 + 40)) {
    return;
  }
  unsigned int v8 = *(unsigned __int8 *)(v6 + 404) | *(unsigned __int8 *)(v5 + 404);
  unsigned int v9 = (v8 >> 2) & 3;
  if (!v9) {
    return;
  }
  int v10 = *((_DWORD *)this + 3);
  if ((v8 & 4) != 0 && (v10 & 0x20000000) != 0)
  {
    double v26 = 0;
    uint64_t v27 = 0x400000000;
    MTLPixelFormat v23 = 0;
    uint64_t v24 = 0x400000000;
    unsigned int v20 = 0;
    uint64_t v21 = 0x400000000;
    uint64_t v17 = 0;
    uint64_t v18 = 0x400000000;
    RB::Symbol::Animation::infer_replace_subtype(RB::Symbol::Model const&,RB::Symbol::Model const&)::$_1::operator()((_DWORD *)v5, v22, v25, 1u);
    RB::Symbol::Animation::infer_replace_subtype(RB::Symbol::Model const&,RB::Symbol::Model const&)::$_1::operator()(v7, v16, v19, 1u);
    if (v23) {
      float v11 = v23;
    }
    else {
      float v11 = v22;
    }
    RB::Symbol::tags_subtract(v25, (uint64_t)v11, v24);
    if (v17) {
      int v12 = v17;
    }
    else {
      int v12 = v16;
    }
    RB::Symbol::tags_subtract(v19, (uint64_t)v12, v18);
    if (v27 && RB::vector<RB::Symbol::Tag,4ul,unsigned int>::operator==((uint64_t)v25, (uint64_t)v19))
    {
      if (v24)
      {
        if (!v18)
        {
          int v13 = 0x4000000;
LABEL_48:
          *((_DWORD *)this + 3) |= v13;
          goto LABEL_49;
        }
      }
      else if (v18)
      {
        int v13 = 0x2000000;
        goto LABEL_48;
      }
    }
    if (v17) {
      free(v17);
    }
    if (v20) {
      free(v20);
    }
    if (v23) {
      free(v23);
    }
    if (v26) {
      free(v26);
    }
    int v10 = *((_DWORD *)this + 3);
  }
  if (v9 < 2 || (v10 & 0x10000000) == 0) {
    return;
  }
  double v26 = 0;
  uint64_t v27 = 0x400000000;
  MTLPixelFormat v23 = 0;
  uint64_t v24 = 0x400000000;
  unsigned int v20 = 0;
  uint64_t v21 = 0x400000000;
  uint64_t v17 = 0;
  uint64_t v18 = 0x400000000;
  RB::Symbol::Animation::infer_replace_subtype(RB::Symbol::Model const&,RB::Symbol::Model const&)::$_1::operator()((_DWORD *)v5, v22, v25, 2u);
  RB::Symbol::Animation::infer_replace_subtype(RB::Symbol::Model const&,RB::Symbol::Model const&)::$_1::operator()(v7, v16, v19, 2u);
  if (v23) {
    float32x2_t v14 = v23;
  }
  else {
    float32x2_t v14 = v22;
  }
  RB::Symbol::tags_subtract(v25, (uint64_t)v14, v24);
  if (v17) {
    unsigned int v15 = v17;
  }
  else {
    unsigned int v15 = v16;
  }
  RB::Symbol::tags_subtract(v19, (uint64_t)v15, v18);
  if (!v27 || !RB::vector<RB::Symbol::Tag,4ul,unsigned int>::operator==((uint64_t)v25, (uint64_t)v19)) {
    goto LABEL_49;
  }
  if (v24)
  {
    if (!v18)
    {
      int v13 = 0x8000000;
      goto LABEL_48;
    }
    if (!RB::vector<RB::Symbol::Tag,4ul,unsigned int>::operator==((uint64_t)v22, (uint64_t)v16))
    {
      int v13 = 167772160;
      goto LABEL_48;
    }
  }
  else if (v18)
  {
    int v13 = 100663296;
    goto LABEL_48;
  }
LABEL_49:
  if (v17) {
    free(v17);
  }
  if (v20) {
    free(v20);
  }
  if (v23) {
    free(v23);
  }
  if (v26) {
    free(v26);
  }
}

void sub_2141AD1BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  if (a12) {
    free(a12);
  }
  if (a16) {
    free(a16);
  }
  if (a20) {
    free(a20);
  }
  float v22 = *(void **)(v20 - 56);
  if (v22) {
    free(v22);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::Heap::emplace<RB::Symbol::Presentation::Interpolant>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  uint64_t result = (*((void *)this + 2) + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if (result + 20 > v2) {
    uint64_t result = RB::Heap::alloc_slow((size_t *)this, 0x14uLL, 3);
  }
  else {
    *((void *)this + 2) = result + 20;
  }
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 4) = 1065353216;
  *(unsigned char *)(result + 8) = 1;
  *(unsigned char *)(result + 16) = 0;
  return result;
}

float32x2_t RB::Symbol::Animation::local_time@<D0>(RB::Symbol::Animation *this@<X0>, float a2@<S0>, const RB::Symbol::Model *a3@<X1>, const RB::Symbol::Glyph::Layer *a4@<X2>, uint64_t a5@<X8>)
{
  float v7 = a2;
  int v10 = *((_DWORD *)this + 3);
  if ((~v10 & 0x10040) == 0)
  {
    float v7 = a2 - RB::Symbol::Animation::layer_delay(this, a3, a4);
    int v10 = *((_DWORD *)this + 3);
  }
  if (v7 >= 0.0001) {
    float v11 = v7;
  }
  else {
    float v11 = 0.0001;
  }
  float v12 = *((float *)this + 6);
  float v13 = v11 * v12;
  if ((v10 & 0x200) != 0)
  {
    float v15 = RB::Symbol::Animation::intro_duration(this, a3);
    float v16 = v15;
    if (v13 < v15)
    {
      int v17 = 0;
      float v18 = 0.0;
      goto LABEL_38;
    }
    float v19 = v13 - v15;
    if ((v10 & 0x10040) == 0x40) {
      float v19 = v19 - RB::Symbol::Animation::layer_delay(this, a3, a4);
    }
    float v14 = fmaxf(v19, 0.0001);
  }
  else
  {
    float v14 = v11 * v12;
  }
  *(float *)&double v21 = RB::Symbol::Animation::local_duration(this, a3);
  float v16 = *(float *)&v21;
  int v22 = *((_DWORD *)this + 3);
  if ((v22 & 0x400) != 0
    && (float v13 = v14
            - (float)((float)(*(float *)&v21 + (float)(*((float *)this + 6) * *((float *)this + 8)))
                    * *((float *)this + 7)),
        v13 > 0.0))
  {
    float v23 = RB::Symbol::Animation::outro_duration(this, v20);
    float v16 = v23;
    if (v13 >= v23) {
      float v13 = v23;
    }
    float v18 = 0.0;
    int v17 = 2;
  }
  else
  {
    float v18 = 0.0;
    float v13 = v14;
    if ((v22 & 0x800) != 0)
    {
      float v24 = *((float *)this + 7);
      *(float *)&unsigned int v25 = *(float *)&v21 + (float)(*((float *)this + 6) * *((float *)this + 8));
      float32x2_t v26 = vrecpe_f32((float32x2_t)v25);
      float32x2_t v27 = vmul_f32(vrecps_f32((float32x2_t)v25, v26), v26);
      float v28 = v14 * vmul_f32(v27, vrecps_f32((float32x2_t)v25, v27)).f32[0];
      if (v24 >= v28) {
        float v24 = v28;
      }
      float v18 = floorf(v24);
      float v13 = (float)(v28 - v18) * (float)(*(float *)&v21 + (float)(*((float *)this + 6) * *((float *)this + 8)));
    }
    if ((v22 & 0x80) != 0)
    {
      uint64_t v29 = *((void *)this + 9);
      if (v29)
      {
        *(float *)&double v21 = v13 * *(float *)&v21;
        HIDWORD(v30) = 0;
        if ((float)(v13 * v16) < 0.0) {
          *(float *)&double v21 = 0.0;
        }
        LODWORD(v30) = 1.0;
        if (*(float *)&v21 > 1.0) {
          *(float *)&double v21 = 1.0;
        }
        if (*(void *)(v29 + 24)) {
          uint64_t v31 = *(void *)(v29 + 24);
        }
        else {
          uint64_t v31 = *((void *)this + 9);
        }
        float v41 = v16;
        RB::Animation::eval(v31, *(unsigned int *)(v29 + 32), (int32x2_t *)(v29 + 44), v21, v30);
        float v16 = v41;
        float v13 = v32;
      }
    }
    if (v13 >= v16)
    {
      if ((*((unsigned char *)this + 13) & 8) != 0)
      {
        float v33 = *((float *)this + 8);
        if (v33 > 0.0)
        {
          float32x2_t v34 = (float32x2_t)*((unsigned int *)this + 6);
          float32x2_t v35 = vrecpe_f32(v34);
          float32x2_t v36 = vmul_f32(vrecps_f32((float32x2_t)v34.u32[0], v35), v35);
          float v11 = (float)((float)((float)(v16 + v14) - v13) + (float)(*((float *)this + 6) * v33))
              * vmul_f32(v36, vrecps_f32((float32x2_t)v34.u32[0], v36)).f32[0];
        }
      }
      int v17 = 1;
      float v13 = v16;
    }
    else
    {
      int v17 = 1;
    }
  }
LABEL_38:
  float v37 = 0.0;
  if (v13 >= 0.0) {
    float v37 = v13;
  }
  if (v37 > v16) {
    float v37 = v16;
  }
  *(float *)a5 = v37;
  *(float *)(a5 + 4) = v18;
  float32x2_t v38 = vrecpe_f32((float32x2_t)LODWORD(v16));
  float32x2_t v39 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v16), v38), v38);
  float32x2_t result = vmul_f32(v39, vrecps_f32((float32x2_t)LODWORD(v16), v39));
  *(_DWORD *)(a5 + 8) = result.i32[0];
  *(float *)(a5 + 12) = v11;
  *(_DWORD *)(a5 + 16) = v17;
  return result;
}

void *RB::Symbol::Animation::keyframes(uint64_t a1, _DWORD *a2, RB::Symbol::KeyframeStorage *this, int a4, RB::Symbol::Model *a5, float a6)
{
  uint64_t v6 = 0;
  int v7 = *(_DWORD *)(a1 + 4);
  switch(v7)
  {
    case 0:
      return &RB::Symbol::Animation::variable_value_keyframes(void)const::keyframes;
    case 1:
      if (a4 != 1) {
        return (void *)RB::Symbol::Animation::vc_intro_outro_keyframes(a1, (int)a2, this, a4);
      }
      switch((*(_DWORD *)(a1 + 12) >> 30) ^ 2)
      {
        case 1:
          float32x2_t result = (void *)RB::Symbol::Animation::vc_sequential_bounce_keyframes(a1, a2, this, a5, a6);
          break;
        case 2:
          float32x2_t result = (void *)RB::Symbol::Animation::vc_cumulative_keyframes(a1, a2, this, a5, a6);
          break;
        case 3:
          float32x2_t result = (void *)RB::Symbol::Animation::vc_cumulative_bounce_keyframes(a1, a2, this, a5, a6);
          break;
        default:
          float32x2_t result = (void *)RB::Symbol::Animation::vc_sequential_keyframes(a1, a2, this, a5, a6);
          break;
      }
      return result;
    case 2:
      return (void *)RB::Symbol::Animation::pulse_keyframes(a1, (uint64_t)a2, this);
    case 3:
      return (void *)RB::Symbol::Animation::bounce_keyframes(a1, (uint64_t)a2, this, a4);
    case 4:
      return (void *)RB::Symbol::Animation::scale_keyframes(a1, a2, this);
    case 5:
    case 9:
      return (void *)RB::Symbol::Animation::appear_disappear_keyframes(a1, (_DWORD *)(v7 == 5), (uint64_t)a2, this);
    case 6:
      int v9 = *(_DWORD *)(a1 + 12) & 0xE000000;
      unsigned int v10 = (v9 - 0x2000000) >> 25;
      if (v10 - 2 >= 3)
      {
        if (v10 > 1) {
          return (void *)RB::Symbol::Animation::replace_keyframes(a1, a2, this);
        }
        float v12 = &RB::Symbol::Animation::replace_slash_keyframes(RB::Symbol::Animation::KeyframesArgs const&,RB::Symbol::KeyframeStorage &)const::remove_keyframes;
        if (v9 != 0x4000000) {
          float v12 = 0;
        }
        if (v9 == 0x2000000) {
          return &RB::Symbol::Animation::replace_slash_keyframes(RB::Symbol::Animation::KeyframesArgs const&,RB::Symbol::KeyframeStorage &)const::add_keyframes;
        }
        else {
          return v12;
        }
      }
      else if (v9 == 100663296)
      {
        return &RB::Symbol::Animation::replace_badge_keyframes(RB::Symbol::Animation::KeyframesArgs const&,RB::Symbol::KeyframeStorage &)const::add_keyframes;
      }
      else
      {
        float v11 = &RB::Symbol::Animation::replace_badge_keyframes(RB::Symbol::Animation::KeyframesArgs const&,RB::Symbol::KeyframeStorage &)const::remove_keyframes;
        if (v9 != 0x8000000) {
          float v11 = 0;
        }
        if (v9 == 167772160) {
          return &RB::Symbol::Animation::replace_badge_keyframes(RB::Symbol::Animation::KeyframesArgs const&,RB::Symbol::KeyframeStorage &)const::move_keyframes;
        }
        else {
          return v11;
        }
      }
    case 10:
      return (void *)RB::Symbol::Animation::wiggle_keyframes(a1, (uint64_t)a2, this, a4, a5);
    case 11:
      return (void *)RB::Symbol::Animation::rotate_keyframes(a1, (uint64_t)a2, this, a4);
    case 12:
      return (void *)RB::Symbol::Animation::breathe_keyframes(a1, (uint64_t)a2, this);
    default:
      return (void *)v6;
  }
}

uint64_t RB::Symbol::Animation::layer_flagged(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = *(_DWORD *)(a1 + 4);
  if (v3 != 12)
  {
    if (v3 == 11)
    {
      if ((a3 & 0xFFFFFFFE) == 6) {
        return *(unsigned char *)(a2 + 87) & 1;
      }
      return 1;
    }
    if (v3 != 2) {
      return 1;
    }
  }
  if (a3 != 12) {
    return 1;
  }
  if (*(float *)(a2 + 72) > 0.0) {
    return *(unsigned __int8 *)(a2 + 86) >> 7;
  }
  else {
    return 0;
  }
}

uint64_t RB::Symbol::Animation::description@<X0>(uint64_t result@<X0>, int a2@<W1>, int a3@<W2>, char a4@<W3>, uint64_t a5@<X8>)
{
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  *(void *)(a5 + 12) = 1065353216;
  *(void *)(a5 + 24) = 0;
  *(_DWORD *)(a5 + 20) = 1065353216;
  switch((int)result)
  {
    case 0:
      int v5 = 262;
      goto LABEL_19;
    case 1:
      int v6 = ~a3 & 0x604 | a2;
      *(_DWORD *)a5 = v6;
      unsigned int v7 = a2 & 0xC0000000;
      if ((a2 & 0xC0000000) == 0x40000000 || !v7) {
        goto LABEL_28;
      }
      if (v7 != 0x80000000) {
        return result;
      }
      if (a2 & 0x10000000) == 0 || (a4)
      {
LABEL_28:
        int v12 = 1051372203;
LABEL_29:
        *(_DWORD *)(a5 + 16) = v12;
      }
      else
      {
        int v8 = v6 | 0x40;
LABEL_20:
        *(_DWORD *)a5 = v8;
      }
      return result;
    case 2:
      *(_DWORD *)a5 = ~a3 & 0x14 | a2;
      *(_DWORD *)(a5 + 4) = 4100;
      *(_DWORD *)(a5 + 12) = 1077936128;
      return result;
    case 3:
      int v11 = ~a3 & 0x14 | a2;
      *(_DWORD *)a5 = v11;
      *(_DWORD *)(a5 + 4) = 4104;
      if ((a2 & 0x20) == 0) {
        return result;
      }
      goto LABEL_23;
    case 4:
      int v5 = 22;
      goto LABEL_19;
    case 5:
    case 9:
      int v5 = 1073741845;
      goto LABEL_19;
    case 6:
      int v5 = 1879048213;
      goto LABEL_19;
    case 7:
      int v5 = 129;
LABEL_19:
      int v8 = v5 & ~a3 | a2;
      goto LABEL_20;
    case 10:
      *(void *)(a5 + 24) = 1065353216;
      int v11 = ~a3 & 0x14 | a2;
      *(_DWORD *)a5 = v11;
      *(_DWORD *)(a5 + 4) = 1024;
      if ((a2 & 0x20) == 0) {
        goto LABEL_22;
      }
LABEL_23:
      if ((v11 & 0x10) != 0) {
        int v13 = 67136;
      }
      else {
        int v13 = 1536;
      }
      int v10 = v13 | v11;
      goto LABEL_27;
    case 11:
      int v9 = ~a3 & 0x14 | a2;
      *(_DWORD *)a5 = v9;
      *(_DWORD *)(a5 + 4) = 2048;
      if ((a2 & 0x20) != 0)
      {
        int v10 = v9 | 0x600;
LABEL_27:
        *(_DWORD *)a5 = v10;
        int v12 = 2143289344;
      }
      else
      {
LABEL_22:
        int v12 = 1065353216;
      }
      goto LABEL_29;
    case 12:
      *(_DWORD *)a5 = ~a3 & 0x14 | a2;
      *(_DWORD *)(a5 + 4) = 4108;
      return result;
    default:
      return result;
  }
}

uint64_t RB::Symbol::Animation::pulse_keyframes(uint64_t a1, uint64_t a2, RB::Symbol::KeyframeStorage *this)
{
  if (*(unsigned char *)(a2 + 24))
  {
    RB::Symbol::KeyframeStorage::clear((uint64_t)this);
    unsigned int v5 = -1012;
  }
  else
  {
    int v6 = *(_DWORD *)(a1 + 12);
    RB::Symbol::KeyframeStorage::clear((uint64_t)this);
    if ((v6 & 0x10) != 0) {
      unsigned int v5 = -500;
    }
    else {
      unsigned int v5 = -1012;
    }
  }
  v9.n128_u64[0] = v5;
  v9.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
  RB::Symbol::KeyframeStorage::push_keyframes(this, &v9);
  if (*(int *)(a1 + 12) < 0) {
    float v7 = 0.5;
  }
  else {
    float v7 = 1.0;
  }
  RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, v7);
  RB::Symbol::KeyframeStorage::push_value(this, 1, 0.0, v7);
  RB::Symbol::KeyframeStorage::push_value(this, 1.0);
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::breathe_keyframes(uint64_t a1, uint64_t a2, RB::Symbol::KeyframeStorage *this)
{
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  int v6 = *(_DWORD *)(a1 + 12);
  unsigned int v7 = *(_DWORD *)(a2 + 8);
  if ((v6 & 0x10) == 0) {
    unsigned int v7 = 1;
  }
  if (v7 >= 2)
  {
    if ((float)(0.25 / (float)(v7 - 1)) <= 0.16667) {
      float v8 = 0.25 / (float)(v7 - 1);
    }
    else {
      float v8 = 0.16667;
    }
  }
  else
  {
    float v8 = 0.0;
    if (!v7) {
      return RB::Symbol::KeyframeStorage::commit(this);
    }
  }
  unsigned int v9 = 0;
  unsigned int v10 = 0;
  unsigned int v11 = v7 - 1;
  do
  {
    float v12 = 3.0 - (float)((float)(v8 * (float)v10) + (float)(v8 * (float)v11));
    if ((*(_DWORD *)(a1 + 12) & 0x80000000) != 0)
    {
      float v15 = v12 * 0.5;
      unsigned int v13 = v9;
    }
    else
    {
      unsigned int v13 = v10 << 10;
      unsigned int v14 = (v9 + (((*(unsigned char *)(a2 + 24) & 1) == 0) << 9)) | 0xFFE0000C;
      if ((v6 & 0x10) == 0) {
        unsigned int v14 = -1012;
      }
      v18.n128_u32[0] = v14;
      v18.n128_f32[1] = v8 * (float)v10;
      v18.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v18);
      float v15 = v12 * 0.5;
      RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, v15);
      RB::Symbol::KeyframeStorage::push_value(this, 1, 0.0, v15);
      RB::Symbol::KeyframeStorage::push_value(this, 1.0);
    }
    unsigned int v16 = v13 | 0xFFE00202;
    if ((v6 & 0x10) == 0) {
      unsigned int v16 = -1022;
    }
    v18.n128_u32[0] = v16;
    v18.n128_f32[1] = v8 * (float)v10;
    v18.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v18);
    RB::Symbol::KeyframeStorage::push_value(this, 2, 1.0, v15);
    RB::Symbol::KeyframeStorage::push_value(this, 2, 1.2, v15);
    RB::Symbol::KeyframeStorage::push_value(this, 1.0);
    v9 += 1024;
    --v11;
    ++v10;
  }
  while (v11 != -1);
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::vc_intro_outro_keyframes(int a1, int a2, RB::Symbol::KeyframeStorage *this, int a4)
{
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  uint64_t v6 = (2 * *((unsigned int *)this + 194)) | 1;
  v10.n128_u64[0] = 4294966282;
  v10.n128_u64[1] = v6;
  RB::Symbol::KeyframeStorage::push_keyframes(this, &v10);
  if (a4) {
    float v7 = 1.0;
  }
  else {
    float v7 = 0.0;
  }
  if (a4) {
    float v8 = 0.0;
  }
  else {
    float v8 = 1.0;
  }
  RB::Symbol::KeyframeStorage::push_value(this, 1, v7, 0.33333);
  RB::Symbol::KeyframeStorage::push_value(this, v8);
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::vc_cumulative_keyframes(uint64_t a1, _DWORD *a2, RB::Symbol::KeyframeStorage *this, RB::Symbol::Model *a4, float a5)
{
  unsigned int v6 = a2[5];
  float v7 = 0.0;
  if ((*(unsigned char *)(a1 + 15) & 0x20) == 0)
  {
    if (*a2 == 3) {
      float v7 = RB::Symbol::Model::alpha(a4, 2uLL, a5);
    }
    else {
      float v7 = 0.3;
    }
  }
  int v8 = 4193288;
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  unsigned int v9 = v6 - 1;
  if (v6 > 1)
  {
    if (v6 == 2) {
      float v11 = 0.66667;
    }
    else {
      float v11 = 1.0;
    }
    float v12 = 0.33333;
    if (v6 >= 4)
    {
      float32x2_t v13 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v9));
      float32x2_t v14 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v9), v13), v13);
      float v12 = (float)(v11 + -0.33333) * vmul_f32(v14, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v9), v14)).f32[0];
    }
    unsigned int v15 = 0;
    do
    {
      *(float *)&unsigned int v16 = v12 * (float)v15;
      float v17 = v11 - *(float *)&v16;
      ++v15;
      v19.n128_u64[0] = __PAIR64__(v16, v8);
      v19.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v19);
      RB::Symbol::KeyframeStorage::push_value(this, 1, v7, 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, 0, 1.0, v17);
      RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, v7);
      v8 += 0x200000;
    }
    while (v6 != v15);
  }
  else
  {
    if (v6) {
      unsigned int v10 = 4193288;
    }
    else {
      unsigned int v10 = -1023;
    }
    v19.n128_u64[0] = v10;
    v19.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v19);
    RB::Symbol::KeyframeStorage::push_value(this, 1, v7, 0.33333);
    RB::Symbol::KeyframeStorage::push_value(this, 0, 1.0, 0.33333);
    RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, 0.33333);
    RB::Symbol::KeyframeStorage::push_value(this, v7);
  }
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::vc_cumulative_bounce_keyframes(uint64_t a1, _DWORD *a2, RB::Symbol::KeyframeStorage *this, RB::Symbol::Model *a4, float a5)
{
  unsigned int v6 = a2[5];
  float v7 = 0.0;
  if ((*(unsigned char *)(a1 + 15) & 0x20) == 0)
  {
    if (*a2 == 3) {
      float v7 = RB::Symbol::Model::alpha(a4, 2uLL, a5);
    }
    else {
      float v7 = 0.3;
    }
  }
  unsigned __int32 v8 = 4193288;
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  unsigned int v9 = v6 - 1;
  if (v6 > 1)
  {
    float v11 = 0.33333;
    if (v6 >= 4)
    {
      float32x2_t v12 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v9));
      float32x2_t v13 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v9), v12), v12);
      float v11 = 0.66667 * vmul_f32(v13, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v9), v13)).f32[0];
    }
    unsigned int v14 = 0;
    int v15 = -1;
    do
    {
      unsigned int v16 = v14 + 1;
      v18.n128_u32[0] = v8;
      v18.n128_f32[1] = v11 * (float)v14;
      v18.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v18);
      RB::Symbol::KeyframeStorage::push_value(this, 1, v7, 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, 0, 1.0, (float)((float)(v11 + v11) * (float)(v6 + v15)) + 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, v7);
      v8 += 0x200000;
      --v15;
      unsigned int v14 = v16;
    }
    while (v6 != v16);
  }
  else
  {
    if (v6) {
      unsigned int v10 = 4193288;
    }
    else {
      unsigned int v10 = -1023;
    }
    v18.n128_u64[0] = v10;
    v18.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v18);
    RB::Symbol::KeyframeStorage::push_value(this, 1, v7, 0.33333);
    RB::Symbol::KeyframeStorage::push_value(this, 0, 1.0, 0.33333);
    RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, 0.33333);
    RB::Symbol::KeyframeStorage::push_value(this, v7);
  }
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::vc_sequential_keyframes(uint64_t a1, _DWORD *a2, RB::Symbol::KeyframeStorage *this, RB::Symbol::Model *a4, float a5)
{
  int v8 = *(_DWORD *)(a1 + 12);
  float v9 = 0.0;
  if ((v8 & 0x20000000) == 0)
  {
    if (*a2 == 3)
    {
      float v9 = RB::Symbol::Model::alpha(a4, 2uLL, a5);
      int v8 = *(_DWORD *)(a1 + 12);
    }
    else
    {
      float v9 = 0.3;
    }
  }
  unsigned int v10 = a2[5];
  int v11 = v8 & 0x10000040;
  if ((v8 & 0x10000040) == 0x10000000) {
    unsigned int v12 = v10 + 1;
  }
  else {
    unsigned int v12 = v10;
  }
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  if (v12 > 3)
  {
    float v22 = (float)((float)(2 * v12 - 8) * 0.016667) + 0.33333;
    *(float *)&unsigned int v23 = v22 + (float)((float)v12 * 0.083333);
    float32x2_t v24 = vrecpe_f32((float32x2_t)v23);
    float32x2_t v25 = vmul_f32(vrecps_f32((float32x2_t)v23, v24), v24);
    v25.f32[0] = vmul_f32(v25, vrecps_f32((float32x2_t)v23, v25)).f32[0];
    float v16 = 0.11111 * v25.f32[0];
    float v26 = (float)(v22 * 1.3333) * v25.f32[0];
    if ((*(unsigned char *)(a1 + 12) & 0x40) != 0)
    {
      uint64_t v34 = (2 * *((unsigned int *)this + 194)) | 1;
      v36.n128_u64[0] = 4294966280;
      v36.n128_u64[1] = v34;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v36);
    }
    else
    {
      unsigned int v27 = 0;
      unsigned int v28 = v12 - 1;
      do
      {
        if (v28 == v27) {
          int v29 = 2096137;
        }
        else {
          int v29 = 2096136;
        }
        if (v28 == v27) {
          int v30 = 1;
        }
        else {
          int v30 = v27 + 1;
        }
        unsigned int v31 = v27 + 1;
        if (v11 == 0x10000000)
        {
          int v32 = v30;
        }
        else
        {
          int v29 = 2096136;
          int v32 = v27 + 1;
        }
        v36.n128_u32[0] = v29 | (v32 << 21);
        v36.n128_f32[1] = v16 * (float)v27;
        v36.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
        RB::Symbol::KeyframeStorage::push_keyframes(this, &v36);
        unsigned int v27 = v31;
      }
      while (v31 != v12);
    }
  }
  else
  {
    if ((*(unsigned char *)(a1 + 12) & 0x40) != 0)
    {
      uint64_t v33 = (2 * *((unsigned int *)this + 194)) | 1;
      v36.n128_u64[0] = 4294966280;
      v36.n128_u64[1] = v33;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v36);
      float v16 = 0.33333;
    }
    else
    {
      unsigned int v13 = 0;
      unsigned int v14 = v12 - 1;
      if (v12 <= 1) {
        int v15 = 1;
      }
      else {
        int v15 = v12;
      }
      float v16 = 0.33333;
      do
      {
        if (v12)
        {
          if (v14 == v13) {
            int v17 = 2096137;
          }
          else {
            int v17 = 2096136;
          }
          if (v14 == v13) {
            int v18 = 1;
          }
          else {
            int v18 = v13 + 1;
          }
          unsigned int v19 = v13 + 1;
          if (v11 == 0x10000000) {
            int v20 = v17;
          }
          else {
            int v20 = 2096136;
          }
          if (v11 == 0x10000000) {
            int v21 = v18;
          }
          else {
            int v21 = v13 + 1;
          }
        }
        else
        {
          unsigned int v19 = v13 + 1;
          int v21 = 2047;
          int v20 = 2096129;
        }
        v36.n128_u32[0] = v20 | (v21 << 21);
        v36.n128_f32[1] = (float)v13 * 0.33333;
        v36.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
        RB::Symbol::KeyframeStorage::push_keyframes(this, &v36);
        unsigned int v13 = v19;
      }
      while (v19 != v15);
    }
    float v26 = 0.33333;
  }
  RB::Symbol::KeyframeStorage::push_value(this, 1, v9, v16);
  RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, v26);
  RB::Symbol::KeyframeStorage::push_value(this, v9);
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::vc_sequential_bounce_keyframes(uint64_t a1, _DWORD *a2, RB::Symbol::KeyframeStorage *this, RB::Symbol::Model *a4, float a5)
{
  unsigned int v7 = *(_DWORD *)(a1 + 12);
  float v8 = 0.0;
  if ((v7 & 0x20000000) == 0)
  {
    if (*a2 == 3)
    {
      float v8 = RB::Symbol::Model::alpha(a4, 2uLL, a5);
      unsigned int v7 = *(_DWORD *)(a1 + 12);
    }
    else
    {
      float v8 = 0.3;
    }
  }
  int v10 = a2[5];
  int v11 = (v7 >> 28) & 1;
  unsigned int v12 = v11 + v10;
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  unsigned int v13 = v12 - 2;
  if (v12 <= 2)
  {
    int v14 = 0;
    unsigned int v15 = v12 - 1;
    do
    {
      int v16 = v14;
      if (v12)
      {
        if (v11)
        {
          if (v15 == v14) {
            unsigned int v17 = 2096137;
          }
          else {
            unsigned int v17 = 2096136;
          }
          ++v14;
          if (v15 == v16) {
            int v18 = 1;
          }
          else {
            int v18 = v16 + 1;
          }
        }
        else
        {
          ++v14;
          unsigned int v17 = 2096136;
          int v18 = v16 + 1;
        }
      }
      else
      {
        ++v14;
        int v18 = 2047;
        unsigned int v17 = 2096129;
      }
      v46.n128_u64[0] = v17 | (unint64_t)(v18 << 21);
      v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
      if (v16) {
        float v19 = v8;
      }
      else {
        float v19 = 1.0;
      }
      if (v16) {
        float v20 = 1.0;
      }
      else {
        float v20 = v8;
      }
      RB::Symbol::KeyframeStorage::push_value(this, 1, v19, 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, 1, v20, 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, v19);
    }
    while (v12 && !v16);
    return RB::Symbol::KeyframeStorage::commit(this);
  }
  if (v12 == 3)
  {
    int v21 = 0;
    while (1)
    {
      if (v11)
      {
        int v22 = v21 == 2 ? 2096137 : 2096136;
        int v23 = v21 == 2 ? 1 : v21 + 1;
      }
      else
      {
        int v23 = v21 + 1;
        int v22 = 2096136;
      }
      v46.n128_u32[0] = v22 | (v23 << 21);
      float v24 = v21 == 2 ? 0.33333 : 0.0;
      v46.n128_f32[1] = v24;
      v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
      if (v21 == 1) {
        break;
      }
      if (v21)
      {
        RB::Symbol::KeyframeStorage::push_value(this, 1, v8, 0.33333);
        float v26 = 1.0;
        goto LABEL_44;
      }
      float v25 = 1.0;
      RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, 0, v8, 0.66667);
      float v26 = v8;
LABEL_45:
      RB::Symbol::KeyframeStorage::push_value(this, 1, v26, 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, v25);
      if (++v21 == 3) {
        return RB::Symbol::KeyframeStorage::commit(this);
      }
    }
    RB::Symbol::KeyframeStorage::push_value(this, 1, v8, 0.33333);
    float v26 = 1.0;
    RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, 0.33333);
    RB::Symbol::KeyframeStorage::push_value(this, 1, v8, 0.33333);
LABEL_44:
    float v25 = v8;
    goto LABEL_45;
  }
  unsigned int v27 = 0;
  float v28 = (float)((float)(2 * v12 - 8) * 0.016667) + 0.33333;
  *(float *)&unsigned int v29 = (float)(v28 + (float)((float)v13 * 0.083333)) + (float)(v28 + (float)((float)v13 * 0.083333));
  float32x2_t v30 = vrecpe_f32((float32x2_t)v29);
  float32x2_t v31 = vmul_f32(vrecps_f32((float32x2_t)v29, v30), v30);
  v31.f32[0] = vmul_f32(v31, vrecps_f32((float32x2_t)v29, v31)).f32[0];
  float v32 = 0.20833 * v31.f32[0];
  float v33 = (float)(v28 * 2.5) * v31.f32[0];
  unsigned int v34 = v12 - 1;
  float v35 = 0.41667 * v31.f32[0];
  float v45 = v33 - (float)(0.20833 * v31.f32[0]);
  do
  {
    if (v11)
    {
      if (v13 == -1) {
        int v36 = 2096137;
      }
      else {
        int v36 = 2096136;
      }
      if (v13 == -1) {
        int v37 = 1;
      }
      else {
        int v37 = v27 + 1;
      }
    }
    else
    {
      int v37 = v27 + 1;
      int v36 = 2096136;
    }
    v46.n128_u32[0] = v36 | (v37 << 21);
    float v38 = (float)v27 + -1.0;
    if (v38 < 0.0) {
      float v38 = 0.0;
    }
    v46.n128_f32[1] = v38 * v32;
    v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
    if (v27)
    {
      RB::Symbol::KeyframeStorage::push_value(this, 1, v8, v32);
      float v39 = 1.0;
      uint64_t v40 = this;
      if (v27 >= v34)
      {
        float v41 = v45;
        int v42 = 0;
      }
      else
      {
        RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, v33);
        RB::Symbol::KeyframeStorage::push_value(this, 0, v8, v35 * (float)v13);
        uint64_t v40 = this;
        float v39 = v8;
        float v41 = v32;
        int v42 = 1;
      }
      RB::Symbol::KeyframeStorage::push_value(v40, v42, v39, v41);
      RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, v33);
      float v43 = v8;
    }
    else
    {
      float v43 = 1.0;
      RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, v33);
      RB::Symbol::KeyframeStorage::push_value(this, 0, v8, v35 * (float)v13);
      RB::Symbol::KeyframeStorage::push_value(this, 1, v8, v32);
    }
    RB::Symbol::KeyframeStorage::push_value(this, v43);
    ++v27;
    --v13;
  }
  while (v13 != -2);
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::bounce_keyframes(uint64_t a1, uint64_t a2, RB::Symbol::KeyframeStorage *this, int a4)
{
  int v8 = *(_DWORD *)(a1 + 12);
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  if ((v8 & 0x20) != 0)
  {
    uint64_t v22 = (2 * *((unsigned int *)this + 194)) | 1;
    v28.n128_u64[0] = 4294966274;
    v28.n128_u64[1] = v22;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v28);
    float v23 = flt_21421A090[v8 >= 0];
    if (a4 == 2)
    {
      RB::Symbol::KeyframeStorage::push_value(this, 5, v23, 0.26667);
      float v23 = 1.0;
    }
    else
    {
      float v24 = flt_21421A088[v8 >= 0];
      if (a4 == 1)
      {
        float v26 = this;
        float v25 = flt_21421A090[v8 >= 0];
      }
      else
      {
        if (a4) {
          return RB::Symbol::KeyframeStorage::commit(this);
        }
        float v25 = 1.0;
        float v26 = this;
      }
      RB::Symbol::KeyframeStorage::push_value(v26, 3, v25, 0.21667);
      RB::Symbol::KeyframeStorage::push_value(this, 4, v24, 0.21667);
    }
    RB::Symbol::KeyframeStorage::push_value(this, v23);
    return RB::Symbol::KeyframeStorage::commit(this);
  }
  int v9 = *(_DWORD *)(a1 + 12);
  if ((v9 & 0x10) != 0) {
    unsigned int v10 = *(_DWORD *)(a2 + 8);
  }
  else {
    unsigned int v10 = 1;
  }
  float v11 = (float)(v10 - 1);
  float v12 = 0.0;
  if (v10 >= 2)
  {
    float v12 = 0.15 / v11;
    if ((float)(0.15 / v11) > 0.05) {
      float v12 = 0.05;
    }
  }
  BOOL v13 = v8 >= 0;
  float v14 = v12 * v11;
  if (v8 < 0) {
    float v15 = -v12;
  }
  else {
    float v15 = v12;
  }
  if (v8 < 0) {
    float v16 = v14;
  }
  else {
    float v16 = 0.0;
  }
  if (v8 < 0) {
    float v17 = 0.75;
  }
  else {
    float v17 = 1.25;
  }
  if (v10)
  {
    int v18 = 0;
    unsigned int v19 = 0;
    float v20 = flt_21421A098[v13];
    do
    {
      unsigned int v21 = v18 | 0xFFE00002;
      if ((v9 & 0x10) == 0) {
        unsigned int v21 = -1022;
      }
      v28.n128_u32[0] = v21;
      v28.n128_f32[1] = v16 + (float)(v15 * (float)v19);
      v28.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v28);
      RB::Symbol::KeyframeStorage::push_value(this, 3, 1.0, 0.21667);
      RB::Symbol::KeyframeStorage::push_value(this, 4, v17, 0.21667);
      RB::Symbol::KeyframeStorage::push_value(this, 5, v20, 0.26667 - (float)(v16 + (float)(v15 * (float)v19)));
      RB::Symbol::KeyframeStorage::push_value(this, 1.0);
      ++v19;
      v18 += 1024;
    }
    while (v10 != v19);
  }
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::wiggle_keyframes(uint64_t a1, uint64_t a2, RB::Symbol::KeyframeStorage *this, int a4, RB::Symbol::Model *a5)
{
  int v8 = *(_DWORD *)(a1 + 12);
  if ((v8 & 0x10) != 0) {
    unsigned int v9 = *(_DWORD *)(a2 + 8);
  }
  else {
    unsigned int v9 = 1;
  }
  if ((v8 & 0x10) != 0) {
    int v10 = 7;
  }
  else {
    int v10 = 6;
  }
  if (v8 < 0) {
    unsigned int v11 = v10;
  }
  else {
    unsigned int v11 = 5;
  }
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  if ((v8 & 0x20) != 0)
  {
    v37.n128_u64[0] = v11 | 0xFFFFFC00;
    v37.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v37);
    if (v8 < 0)
    {
      float v20 = 0.087266;
      float v19 = -0.087266;
    }
    else
    {
      float v18 = *(float *)(RB::Symbol::Model::glyph_info(a5) + 32);
      float v19 = v18 * -0.025;
      float v20 = v18 * 0.025;
    }
    if ((v8 & 0x40000000) != 0) {
      float v28 = -v19;
    }
    else {
      float v28 = v19;
    }
    if ((v8 & 0x40000000) != 0) {
      float v29 = -v20;
    }
    else {
      float v29 = v20;
    }
    if (a4 == 2)
    {
      RB::Symbol::KeyframeStorage::push_value(this, 8, 0.0, 0.083333);
      RB::Symbol::KeyframeStorage::push_value(this, 7, v29, 0.16667);
      float v32 = this;
      float v33 = v28;
      float v34 = 0.16667;
      int v35 = 7;
    }
    else
    {
      if (a4 == 1)
      {
        float32x2_t v30 = this;
        int v31 = 8;
      }
      else
      {
        if (a4) {
          return RB::Symbol::KeyframeStorage::commit(this);
        }
        float32x2_t v30 = this;
        int v31 = 7;
      }
      RB::Symbol::KeyframeStorage::push_value(v30, v31, 0.0, 0.083333);
      RB::Symbol::KeyframeStorage::push_value(this, 7, v29, 0.16667);
      float v32 = this;
      float v33 = v28;
      float v34 = 0.083333;
      int v35 = 9;
    }
    RB::Symbol::KeyframeStorage::push_value(v32, v35, v33, v34);
    RB::Symbol::KeyframeStorage::push_value(this, 0.0);
    return RB::Symbol::KeyframeStorage::commit(this);
  }
  float v12 = 0.0;
  if (v9 >= 2)
  {
    if ((float)(0.15 / (float)(v9 - 1)) <= 0.05) {
      float v12 = 0.15 / (float)(v9 - 1);
    }
    else {
      float v12 = 0.05;
    }
  }
  if (v8 < 0)
  {
    float v17 = -0.087266;
    float v16 = 0.10472;
    float v15 = -0.13963;
    float v14 = 0.17453;
  }
  else
  {
    float v13 = *(float *)(RB::Symbol::Model::glyph_info(a5) + 32);
    float v14 = v13 * 0.06;
    float v15 = v13 * -0.04;
    float v16 = v13 * 0.03;
    float v17 = v13 * -0.025;
  }
  if ((v8 & 0x40000000) != 0) {
    float v21 = -v14;
  }
  else {
    float v21 = v14;
  }
  if ((v8 & 0x40000000) != 0) {
    float v22 = -v15;
  }
  else {
    float v22 = v15;
  }
  if ((v8 & 0x40000000) != 0) {
    float v23 = -v16;
  }
  else {
    float v23 = v16;
  }
  if ((v8 & 0x40000000) != 0) {
    float v24 = -v17;
  }
  else {
    float v24 = v17;
  }
  if (v9)
  {
    int v25 = 0;
    for (unsigned int i = 0; i != v9; ++i)
    {
      if ((v8 & 0x10) != 0) {
        int v27 = v25;
      }
      else {
        int v27 = 2096128;
      }
      v37.n128_u32[0] = v11 | v27 | 0xFFE00000;
      v37.n128_f32[1] = v12 * (float)i;
      v37.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v37);
      RB::Symbol::KeyframeStorage::push_value(this, 6, 0.0, 0.167);
      RB::Symbol::KeyframeStorage::push_value(this, 7, v21, 0.167);
      RB::Symbol::KeyframeStorage::push_value(this, 7, v22, 0.167);
      RB::Symbol::KeyframeStorage::push_value(this, 7, v23, 0.167);
      RB::Symbol::KeyframeStorage::push_value(this, 7, v24, 0.267 - (float)(v12 * (float)i));
      RB::Symbol::KeyframeStorage::push_value(this, 0.0);
      v25 += 1024;
    }
  }
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::rotate_keyframes(uint64_t a1, uint64_t a2, RB::Symbol::KeyframeStorage *this, int a4)
{
  int v6 = *(_DWORD *)(a1 + 12);
  int v7 = 6;
  if (*(unsigned char *)(a2 + 25))
  {
    LOBYTE(v8) = 0;
    unsigned int v9 = 1;
  }
  else
  {
    unsigned int v8 = (*(_DWORD *)(a1 + 12) & 0x10u) >> 4;
    if ((v6 & 0x10) != 0) {
      int v7 = 7;
    }
    else {
      int v7 = 6;
    }
    if ((v6 & 0x10) != 0) {
      unsigned int v9 = *(_DWORD *)(a2 + 8);
    }
    else {
      unsigned int v9 = 1;
    }
  }
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  if (v6 >= 0) {
    int v10 = 2;
  }
  else {
    int v10 = -2;
  }
  float v11 = (float)v10 * 3.1416;
  if ((v6 & 0x20) != 0)
  {
    if (!a4 && v9 >= 2)
    {
      unsigned int v14 = 0;
      if ((float)(0.25 / (float)(v9 - 1)) <= 0.083333) {
        float v15 = 0.25 / (float)(v9 - 1);
      }
      else {
        float v15 = 0.083333;
      }
      float v16 = (float)v10 * 0.52971;
      int v17 = 512;
      do
      {
        if (v8) {
          int v18 = v17;
        }
        else {
          int v18 = 2096128;
        }
        v27.n128_u32[0] = v7 | v18 | 0xFFE00000;
        v27.n128_f32[1] = v15 * (float)v14;
        v27.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
        RB::Symbol::KeyframeStorage::push_keyframes(this, &v27);
        RB::Symbol::KeyframeStorage::push_value(this, 11, 0.0, 0.66667);
        RB::Symbol::KeyframeStorage::push_value(this, 12, v16, 1.8333 - (float)(v15 * (float)v14));
        RB::Symbol::KeyframeStorage::push_value(this, v11);
        ++v14;
        v17 += 1024;
      }
      while (v9 != v14);
      return RB::Symbol::KeyframeStorage::commit(this);
    }
    if (v8) {
      __int16 v19 = 512;
    }
    else {
      __int16 v19 = 0;
    }
    v27.n128_u64[0] = (unsigned __int16)(v7 | v19) | 0xFFFFFC00;
    v27.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v27);
    if (a4 == 2)
    {
      float v20 = 2.5;
      float v21 = this;
      int v22 = 13;
    }
    else if (a4 == 1)
    {
      float v20 = 2.0;
      float v21 = this;
      int v22 = 12;
    }
    else
    {
      if (a4)
      {
LABEL_49:
        RB::Symbol::KeyframeStorage::push_value(this, v11);
        return RB::Symbol::KeyframeStorage::commit(this);
      }
      float v20 = 2.5;
      float v21 = this;
      int v22 = 11;
    }
    RB::Symbol::KeyframeStorage::push_value(v21, v22, 0.0, v20);
    goto LABEL_49;
  }
  if (v9 >= 2)
  {
    if (v9 == 2)
    {
      float v12 = 0.13333;
      float v13 = 1.8667;
    }
    else
    {
      if ((float)(0.26667 / (float)(v9 - 1)) <= 0.13333) {
        float v12 = 0.26667 / (float)(v9 - 1);
      }
      else {
        float v12 = 0.13333;
      }
      float v13 = 1.7333;
    }
  }
  else
  {
    if (!v9) {
      return RB::Symbol::KeyframeStorage::commit(this);
    }
    float v12 = 0.0;
    float v13 = 2.0;
  }
  unsigned int v23 = 0;
  int v24 = 512;
  do
  {
    if (v8) {
      int v25 = v24;
    }
    else {
      int v25 = 2096128;
    }
    v27.n128_u32[0] = v7 | v25 | 0xFFE00000;
    v27.n128_f32[1] = v12 * (float)v23;
    v27.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v27);
    RB::Symbol::KeyframeStorage::push_value(this, 10, 0.0, v13);
    RB::Symbol::KeyframeStorage::push_value(this, v11);
    ++v23;
    v24 += 1024;
  }
  while (v9 != v23);
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::scale_keyframes(uint64_t a1, _DWORD *a2, RB::Symbol::KeyframeStorage *this)
{
  int v4 = a2[7];
  int v5 = a2[8];
  if (v4 >= v5)
  {
    if (v4 <= v5) {
      return 0;
    }
    if (v4 > 0) {
      unsigned int v6 = 2;
    }
    else {
      unsigned int v6 = 3;
    }
  }
  else
  {
    unsigned int v6 = v5 > 0;
  }
  int v7 = *(_DWORD *)(a1 + 12);
  if ((v7 & 0x10) != 0) {
    unsigned int v8 = a2[2];
  }
  else {
    unsigned int v8 = 1;
  }
  float v9 = 0.0;
  if (v8 >= 2)
  {
    float v9 = 0.15 / (float)(v8 - 1);
    if (v9 > 0.05) {
      float v9 = 0.05;
    }
  }
  if (v6 <= 1) {
    float v10 = 0.0;
  }
  else {
    float v10 = -v9;
  }
  if (v6 <= 1) {
    float v11 = 0.0;
  }
  else {
    float v11 = v9 * (float)(v8 - 1);
  }
  if (v6 <= 1) {
    float v12 = v9;
  }
  else {
    float v12 = 0.0;
  }
  if (v6 <= 1) {
    float v13 = -(float)((float)(v9 * (float)(v8 - 1)) + -0.25);
  }
  else {
    float v13 = 0.25;
  }
  if (v6 == 3) {
    int v14 = 39;
  }
  else {
    int v14 = 1;
  }
  if (v6) {
    int v15 = v14;
  }
  else {
    int v15 = 38;
  }
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  if (v8)
  {
    int v16 = 0;
    for (unsigned int i = 0; i != v8; ++i)
    {
      unsigned int v18 = v16 | 0xFFE00003;
      if ((v7 & 0x10) == 0) {
        unsigned int v18 = -1021;
      }
      v20.n128_u32[0] = v18;
      v20.n128_f32[1] = v11 + (float)(v10 * (float)i);
      v20.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v20);
      RB::Symbol::KeyframeStorage::push_value(this, v15, 0.0, (float)(v13 + (float)(v12 * (float)i)) - (float)(v11 + (float)(v10 * (float)i)));
      RB::Symbol::KeyframeStorage::push_value(this, 1.0);
      v16 += 1024;
    }
  }
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::appear_disappear_keyframes(uint64_t a1, _DWORD *a2, uint64_t a3, RB::Symbol::KeyframeStorage *this)
{
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  RB::Symbol::Animation::make_appear_disappear_keyframes(a2, *(_DWORD *)(a1 + 12), a3, this);
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::replace_keyframes(uint64_t a1, _DWORD *a2, RB::Symbol::KeyframeStorage *this)
{
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  RB::Symbol::Animation::make_replace_keyframes(*(_DWORD *)(a1 + 12), a2, this);
  return RB::Symbol::KeyframeStorage::commit(this);
}

_DWORD *RB::Symbol::Animation::make_appear_disappear_keyframes(_DWORD *result, int a2, uint64_t a3, RB::Symbol::KeyframeStorage *this)
{
  char v6 = a2;
  unsigned int v7 = a2 & 0xC0000000;
  if ((a2 & 0x10) != 0) {
    unsigned int v8 = *(_DWORD *)(a3 + 8);
  }
  else {
    unsigned int v8 = 1;
  }
  if (result) {
    float v9 = 0.25;
  }
  else {
    float v9 = 0.16667;
  }
  unsigned int v10 = v8 - 1;
  if (v8 > 1)
  {
    float v12 = 0.05;
    if (!result) {
      float v12 = 0.033333;
    }
    float v13 = 0.15;
    if (!result) {
      float v13 = 0.1;
    }
    float v11 = (float)v10;
    float v14 = v13 / (float)v10;
    if (v12 >= v14) {
      float v12 = v14;
    }
  }
  else
  {
    float v11 = (float)v10;
    float v12 = 0.0;
  }
  unsigned int v15 = (v7 == 0x80000000) ^ result;
  float v16 = v12 * v11;
  if (v15) {
    float v17 = v12;
  }
  else {
    float v17 = -v12;
  }
  if (v15) {
    float v18 = 0.0;
  }
  else {
    float v18 = v16;
  }
  if (v8)
  {
    int v19 = 0;
    unsigned int v20 = 0;
    float v21 = 1.25;
    if (v7 != 0x80000000) {
      float v21 = 1.0;
    }
    if (v7 == 0x40000000) {
      float v22 = 0.75;
    }
    else {
      float v22 = v21;
    }
    float v23 = (float)(result ^ 1);
    float v24 = (float)result;
    if (result) {
      float v25 = v22;
    }
    else {
      float v25 = 1.0;
    }
    if (result) {
      int v26 = 15;
    }
    else {
      int v26 = 16;
    }
    if (result) {
      float v27 = 1.0;
    }
    else {
      float v27 = v22;
    }
    float v30 = v27;
    float v31 = v25;
    do
    {
      float v28 = v18 + (float)(v17 * (float)v20);
      if ((v6 & 0x10) != 0) {
        int v29 = v19 & 0x1FFC00;
      }
      else {
        int v29 = 2096128;
      }
      v32.n128_u32[0] = v29 & 0xFFFFFF8F | (16 * (*(_DWORD *)(a3 + 4) & 7)) | 0xFFE0000D;
      v32.n128_f32[1] = v18 + (float)(v17 * (float)v20);
      v32.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v32);
      RB::Symbol::KeyframeStorage::push_value(this, 14, v23, v9 - v28);
      float32x2_t result = RB::Symbol::KeyframeStorage::push_value(this, v24);
      if (v22 != 1.0)
      {
        v32.n128_u32[0] = v29 | 0xFFE00002 | (16 * (*(_DWORD *)(a3 + 4) & 7));
        v32.n128_f32[1] = v18 + (float)(v17 * (float)v20);
        v32.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
        RB::Symbol::KeyframeStorage::push_keyframes(this, &v32);
        RB::Symbol::KeyframeStorage::push_value(this, v26, v31, v9 - v28);
        float32x2_t result = RB::Symbol::KeyframeStorage::push_value(this, v30);
      }
      ++v20;
      v19 += 1024;
    }
    while (v8 != v20);
  }
  return result;
}

_DWORD *RB::Symbol::Animation::infer_replace_subtype(RB::Symbol::Model const&,RB::Symbol::Model const&)::$_1::operator()(_DWORD *result, _DWORD *a2, _DWORD *a3, unsigned int a4)
{
  if (*((void *)result + 47)) {
    uint64_t v4 = *((void *)result + 47);
  }
  else {
    uint64_t v4 = (uint64_t)(result + 28);
  }
  unsigned int v5 = result[96];
  if (v5)
  {
    uint64_t v8 = v4 + 88 * v5;
    do
    {
      if (RB::Symbol::Glyph::Layer::contains(v4, a4)) {
        unsigned int v10 = a2;
      }
      else {
        unsigned int v10 = a3;
      }
      if (*(void *)(v4 + 40)) {
        uint64_t v11 = *(void *)(v4 + 40);
      }
      else {
        uint64_t v11 = v4 + 24;
      }
      float32x2_t result = RB::Symbol::tags_merge(v10, v11, *(unsigned int *)(v4 + 48), a4);
      v4 += 88;
    }
    while (v4 != v8);
  }
  return result;
}

BOOL RB::vector<RB::Symbol::Tag,4ul,unsigned int>::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2 != *(_DWORD *)(a2 + 24)) {
    return 0;
  }
  if (*(void *)(a1 + 16)) {
    a1 = *(void *)(a1 + 16);
  }
  if (*(void *)(a2 + 16)) {
    a2 = *(void *)(a2 + 16);
  }
  return memcmp((const void *)a1, (const void *)a2, 4 * v2) == 0;
}

void RB::Symbol::Animation::make_replace_keyframes(int a1, _DWORD *a2, RB::Symbol::KeyframeStorage *this)
{
  char v5 = a1;
  unsigned int v6 = a1 & 0xC0000000;
  if (a2[1] == 2) {
    goto LABEL_42;
  }
  if (v6 == -1073741824)
  {
    uint64_t v8 = (2 * *((unsigned int *)this + 194)) | 1;
    v46.n128_u64[0] = 4294966301;
    v46.n128_u64[1] = v8;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
    goto LABEL_6;
  }
  if (!v6)
  {
    uint64_t v7 = (2 * *((unsigned int *)this + 194)) | 1;
    v46.n128_u64[0] = 4294966301;
    v46.n128_u64[1] = v7;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
    RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, 0.166);
    RB::Symbol::KeyframeStorage::push_value(this, 0, 0.2, 0.0);
LABEL_6:
    RB::Symbol::KeyframeStorage::push_value(this, 0.0);
    goto LABEL_41;
  }
  if ((a1 & 0x10) != 0) {
    unsigned int v9 = a2[3];
  }
  else {
    unsigned int v9 = 1;
  }
  float v10 = 0.0;
  if (v9 >= 2)
  {
    float v10 = 0.15 / (float)(v9 - 1);
    if (v10 > 0.05) {
      float v10 = 0.05;
    }
  }
  float v11 = (float)(v9 - 1);
  float v12 = -(float)((float)(v10 * v11) + -0.25);
  float v13 = v10 * v11;
  if (v6 == 0x40000000) {
    int v14 = 17;
  }
  else {
    int v14 = 19;
  }
  if (v6 == 0x40000000) {
    float v15 = 0.5;
  }
  else {
    float v15 = 1.25;
  }
  if (v6 == 0x40000000) {
    float v16 = -v10;
  }
  else {
    float v16 = 0.0;
  }
  if (v6 == 0x40000000) {
    float v17 = v13;
  }
  else {
    float v17 = 0.0;
  }
  if (v6 == 0x40000000) {
    float v18 = 0.0;
  }
  else {
    float v18 = v10;
  }
  if (v6 == 0x40000000) {
    float v19 = 0.25;
  }
  else {
    float v19 = v12;
  }
  if (v9)
  {
    int v20 = 0;
    for (unsigned int i = 0; i != v9; ++i)
    {
      float v22 = (float)(v19 + (float)(v18 * (float)i)) - (float)(v17 + (float)(v16 * (float)i));
      if ((v5 & 0x10) != 0) {
        int v23 = v20 & 0x1FFC00;
      }
      else {
        int v23 = 2096128;
      }
      v46.n128_u32[0] = v23 | 0xFFE00012;
      v46.n128_f32[1] = v17 + (float)(v16 * (float)i);
      v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
      RB::Symbol::KeyframeStorage::push_value(this, v14, 1.0, v22);
      RB::Symbol::KeyframeStorage::push_value(this, v15);
      if (v6 == 0x80000000)
      {
        v46.n128_u32[0] = v23 | 0xFFE0001D;
        v46.n128_f32[1] = v17 + (float)(v16 * (float)i);
        v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
        RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
        RB::Symbol::KeyframeStorage::push_value(this, 19, 1.0, v22);
        RB::Symbol::KeyframeStorage::push_value(this, 0.0);
      }
      v20 += 1024;
    }
  }
  if (v6 == 0x40000000)
  {
    v46.n128_u64[0] = 0x3E800000FFFFFC1DLL;
    v46.n128_u64[1] = (unint64_t)&RB::Symbol::Animation::make_replace_keyframes(unsigned int,RB::Symbol::Animation::KeyframesArgs const&,RB::Symbol::KeyframeStorage &)::alpha_values;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
  }
LABEL_41:
  if (a2[1] == 1) {
    return;
  }
LABEL_42:
  if (v6 != -1073741824)
  {
    if (!v6)
    {
      uint64_t v24 = (2 * *((unsigned int *)this + 194)) | 1;
      v46.n128_u64[0] = 0x3E29FBE7FFFFFC2DLL;
      v46.n128_u64[1] = v24;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
      RB::Symbol::KeyframeStorage::push_value(this, 0, 0.0, 0.0);
      RB::Symbol::KeyframeStorage::push_value(this, 1, 0.2, 0.166);
      RB::Symbol::KeyframeStorage::push_value(this, 1.0);
      return;
    }
    if (v6 == 0x40000000) {
      float v28 = 0.25;
    }
    else {
      float v28 = 0.167;
    }
    if ((v5 & 0x10) != 0) {
      unsigned int v29 = a2[4];
    }
    else {
      unsigned int v29 = 1;
    }
    float v30 = 0.0;
    float v31 = 0.0;
    if (v29 >= 2)
    {
      float v31 = 0.15 / (float)(v29 - 1);
      if (v31 > 0.05) {
        float v31 = 0.05;
      }
    }
    if (v6 == 0x40000000)
    {
      float v32 = -(float)((float)(v31 * (float)(v29 - 1)) + -0.25);
      float v33 = 0.0;
      float v34 = 0.5;
      int v35 = 18;
      float v30 = v31;
      if (!v29)
      {
LABEL_80:
        if (v6 == 0x40000000)
        {
          v46.n128_u64[0] = 0x3E800000FFFFFC2DLL;
          v46.n128_u64[1] = (unint64_t)&RB::Symbol::Animation::make_replace_keyframes(unsigned int,RB::Symbol::Animation::KeyframesArgs const&,RB::Symbol::KeyframeStorage &)::alpha_values;
          RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
        }
        return;
      }
    }
    else
    {
      int v35 = 20;
      float v32 = 0.333;
      float v34 = 0.4;
      float v33 = v31;
      if (!v29) {
        goto LABEL_80;
      }
    }
    int v40 = 0;
    for (unsigned int j = 0; j != v29; ++j)
    {
      float v42 = v33 * (float)j;
      float v43 = (float)(v32 + (float)(v30 * (float)j)) - v42;
      if ((v5 & 0x10) != 0) {
        int v44 = v40 & 0x1FFC00;
      }
      else {
        int v44 = 2096128;
      }
      v46.n128_u32[0] = v44 | 0xFFE00022;
      float v45 = v42 + v28;
      v46.n128_f32[1] = v42 + v28;
      v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
      RB::Symbol::KeyframeStorage::push_value(this, v35, v34, v43);
      RB::Symbol::KeyframeStorage::push_value(this, 1.0);
      if (v6 == 0x80000000)
      {
        v46.n128_u32[0] = v44 | 0xFFE0002D;
        v46.n128_f32[1] = v45;
        v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
        RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
        RB::Symbol::KeyframeStorage::push_value(this, 20, 0.0, v43);
        RB::Symbol::KeyframeStorage::push_value(this, 1.0);
      }
      v40 += 1024;
    }
    goto LABEL_80;
  }
  if ((v5 & 0x10) != 0) {
    unsigned int v25 = a2[4];
  }
  else {
    unsigned int v25 = 1;
  }
  float v26 = (float)(v25 - 1);
  if (v25 >= 2)
  {
    if ((float)(0.15 / v26) <= 0.05) {
      float v27 = 0.15 / v26;
    }
    else {
      float v27 = 0.05;
    }
  }
  else
  {
    float v27 = 0.0;
    if (!v25) {
      return;
    }
  }
  int v36 = 0;
  unsigned int v37 = 0;
  float v38 = -(float)((float)(v27 * v26) + -0.25);
  do
  {
    if ((v5 & 0x10) != 0) {
      int v39 = v36 & 0x1FFC00;
    }
    else {
      int v39 = 2096128;
    }
    v46.n128_u64[0] = v39 & 0xFFFFFF8F | (16 * (a2[1] & 7)) | 0xFFE00002;
    v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
    RB::Symbol::KeyframeStorage::push_value(this, 21, 0.5, v38 + (float)(v27 * (float)v37));
    RB::Symbol::KeyframeStorage::push_value(this, 1.0);
    v46.n128_u64[0] = v39 & 0xFFFFFF8F | (16 * (a2[1] & 7)) | 0xFFE0000DLL;
    v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
    RB::Symbol::KeyframeStorage::push_value(this, 22, 0.0, v38 + (float)(v27 * (float)v37));
    RB::Symbol::KeyframeStorage::push_value(this, 1.0);
    ++v37;
    v36 += 1024;
  }
  while (v25 != v37);
}

float RB::Symbol::Animation::eval_appear_disappear(_DWORD *a1, int a2, _DWORD *a3, float a4)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  uint64_t v19 = 255;
  int v20 = a3[1];
  int v22 = 0;
  int v23 = 0;
  v21[0] = 0;
  *(void *)((char *)v21 + 6) = 0;
  unsigned int v25 = 0;
  uint64_t v26 = 0x4000000000;
  float v27 = 0;
  uint64_t v28 = 0x4000000000;
  char v29 = 0;
  RB::Symbol::Animation::make_appear_disappear_keyframes(a1, a2, (uint64_t)&v19, (RB::Symbol::KeyframeStorage *)v24);
  unsigned int v6 = (RB::Symbol::Keyframes *)RB::Symbol::KeyframeStorage::commit((RB::Symbol::KeyframeStorage *)v24);
  uint64_t v8 = v6;
  if (a4 >= 0.0001) {
    float v9 = a4;
  }
  else {
    float v9 = 0.0001;
  }
  unsigned int v10 = *(_DWORD *)v6;
  if ((*(_DWORD *)v6 & 0xF) != 0)
  {
    float v11 = 1.0;
    float v12 = 1.0;
    do
    {
      if ((v10 & 0x1F0) == 0 && *((void *)v8 + 1))
      {
        int v13 = (v10 >> 10) & 0x7FF;
        BOOL v14 = v13 == 2047 || v13 == *a3;
        BOOL v15 = v14;
        if (!((v10 + 0x200000) >> 22) && v15)
        {
          float v16 = RB::Symbol::Keyframes::eval(v8, v9, (const RB::Symbol::KeyframeStorage *)v24, v7);
          if ((*(_DWORD *)v8 & 0xF) == 0xD) {
            *(float *)&double v7 = v16;
          }
          else {
            *(float *)&double v7 = v12;
          }
          if ((*(_DWORD *)v8 & 0xF) == 2) {
            float v11 = v16;
          }
          else {
            float v12 = *(float *)&v7;
          }
        }
      }
      unsigned int v17 = *((_DWORD *)v8 + 4);
      uint64_t v8 = (RB::Symbol::Keyframes *)((char *)v8 + 16);
      unsigned int v10 = v17;
    }
    while ((v17 & 0xF) != 0);
  }
  else
  {
    float v11 = 1.0;
  }
  if (v27) {
    free(v27);
  }
  if (v25) {
    free(v25);
  }
  return v11;
}

void sub_2141AFE20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  RB::Symbol::KeyframeStorage::~KeyframeStorage((RB::Symbol::KeyframeStorage *)va);
  _Unwind_Resume(a1);
}

float RB::Symbol::Animation::eval_replace(int a1, int a2, _DWORD *a3, float a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  v22[0] = 255;
  v22[1] = a1;
  int v7 = a3[1];
  v22[2] = 1;
  float64x2_t v22[3] = v7;
  _DWORD v22[4] = v7;
  v22[5] = 0;
  __int16 v23 = 0;
  uint64_t v24 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0x4000000000;
  uint64_t v28 = 0;
  uint64_t v29 = 0x4000000000;
  char v30 = 0;
  RB::Symbol::Animation::make_replace_keyframes(a2, v22, (RB::Symbol::KeyframeStorage *)v25);
  uint64_t v8 = (RB::Symbol::Keyframes *)RB::Symbol::KeyframeStorage::commit((RB::Symbol::KeyframeStorage *)v25);
  unsigned int v10 = v8;
  if (a4 >= 0.0001) {
    float v11 = a4;
  }
  else {
    float v11 = 0.0001;
  }
  unsigned int v12 = *(_DWORD *)v8;
  if ((*(_DWORD *)v8 & 0xF) != 0)
  {
    float v13 = 1.0;
    float v14 = 1.0;
    do
    {
      if (*((void *)v10 + 1))
      {
        BOOL v15 = ((v12 >> 4) & 7) == a1 || ((v12 >> 4) & 7) == 0;
        if ((v12 & 0x180) == 0 && v15)
        {
          int v16 = (v12 >> 10) & 0x7FF;
          BOOL v17 = v16 == 2047 || v16 == *a3;
          BOOL v18 = v17;
          if (!((v12 + 0x200000) >> 22) && v18)
          {
            float v19 = RB::Symbol::Keyframes::eval(v10, v11, (const RB::Symbol::KeyframeStorage *)v25, v9);
            if ((*(_DWORD *)v10 & 0xF) == 0xD) {
              *(float *)&double v9 = v19;
            }
            else {
              *(float *)&double v9 = v14;
            }
            if ((*(_DWORD *)v10 & 0xF) == 2) {
              float v13 = v19;
            }
            else {
              float v14 = *(float *)&v9;
            }
          }
        }
      }
      unsigned int v20 = *((_DWORD *)v10 + 4);
      unsigned int v10 = (RB::Symbol::Keyframes *)((char *)v10 + 16);
      unsigned int v12 = v20;
    }
    while ((v20 & 0xF) != 0);
  }
  else
  {
    float v13 = 1.0;
  }
  if (v28) {
    free(v28);
  }
  if (v26) {
    free(v26);
  }
  return v13;
}

void sub_2141AFFEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  RB::Symbol::KeyframeStorage::~KeyframeStorage((RB::Symbol::KeyframeStorage *)va);
  _Unwind_Resume(a1);
}

void RB::anonymous namespace'::defaults_key(RB::_anonymous_namespace_ *this@<X0>, CFStringRef *a2@<X8>)
{
  v13[1] = *MEMORY[0x263EF8340];
  size_t v5 = strlen((const char *)this);
  size_t v6 = v5;
  if (v5 > 0x1000)
  {
    int v7 = (char *)malloc_type_malloc(v5, 0xFAE9C67AuLL);
    if (!v7)
    {
      *a2 = 0;
LABEL_20:
      free(v7);
      return;
    }
  }
  else
  {
    MEMORY[0x270FA5388]();
    int v7 = (char *)v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v7, v6);
  }
  char v8 = *(unsigned char *)this;
  if (*(unsigned char *)this)
  {
    double v9 = (unsigned __int8 *)this + 1;
    char v10 = 1;
    float v11 = v7;
    while (1)
    {
      if ((v8 - 65) >= 0x1A)
      {
        if (v8 == 95)
        {
          char v10 = 0;
          goto LABEL_12;
        }
      }
      else if ((v10 & 1) == 0)
      {
        if (*(v9 - 2) != 95) {
          v8 += 32;
        }
        v10 &= *(v9 - 2) == 95;
      }
      *v11++ = v8;
LABEL_12:
      int v12 = *v9++;
      char v8 = v12;
      if (!v12) {
        goto LABEL_17;
      }
    }
  }
  float v11 = v7;
LABEL_17:
  *a2 = CFStringCreateWithBytes(0, (const UInt8 *)v7, v11 - v7, 0x8000100u, 1u);
  if (v6 > 0x1000) {
    goto LABEL_20;
  }
}

uint64_t RB::Config::BOOL_value(const __CFString *this, const void *a2)
{
  uint64_t v2 = RB::Config::int_value(this, a2);
  if (v2) {
    BOOL v3 = (v2 & 0xFF00000000) != 0;
  }
  else {
    BOOL v3 = 0;
  }
  return v3 | (((v2 & 0xFF00000000) != 0) << 8);
}

void RB::render_stroke_coverage(uint64_t a1, float64x2_t *a2, uint64_t a3, uint64_t a4, int a5, float a6)
{
  uint64_t v10 = 17;
  if (*(_DWORD *)(a1 + 136) == 2) {
    uint64_t v10 = 131089;
  }
  v12[0] = (uint64_t (**)(void, void *, __n128, __n128))&unk_26C4EE8B0;
  v12[1] = (uint64_t (**)(void, void *, __n128, __n128))(v10 | ((unint64_t)(a5 & 0x3F) << 32));
  float v13 = a6;
  BOOL may_discard_shape = RB::may_discard_shape(a5);
}

void RB::anonymous namespace'::draw_stroke(void *a1, uint64_t a2, uint64_t a3, uint64_t (***a4)(void, void *, __n128, __n128), float64x2_t *a5, int a6)
{
  uint64_t v116 = *MEMORY[0x263EF8340];
  float64x2_t v11 = a5[1];
  int8x16_t v89 = *(int8x16_t *)a5;
  float64x2_t v90 = v11;
  float64x2_t v91 = 0uLL;
  float64x2_t v83 = a5[2];
  int8x16_t v84 = v89;
  *(int8x16_t *)float v92 = v89;
  *(float64x2_t *)&v92[16] = v11;
  float64x2_t v93 = 0uLL;
  BOOL v12 = RB::AffineTransform::invert((RB::AffineTransform *)v92);
  float v13 = &v90;
  float v14 = &v91;
  int8x16_t v82 = *(int8x16_t *)v92;
  if (v12) {
    unint64_t v15 = -1;
  }
  else {
    unint64_t v15 = 0;
  }
  if (v12) {
    float v13 = (float64x2_t *)&v92[16];
  }
  float64x2_t v81 = *v13;
  if (v12) {
    float v14 = &v93;
  }
  float64x2_t v85 = *v14;
  float v74 = RB::AffineTransform::scale((float64x2_t *)&v89);
  BOOL v17 = RB::pixel_format_traits(a1[11], v16);
  unint64_t v18 = *v17 | ((unint64_t)*((unsigned __int16 *)v17 + 2) << 32);
  if ((v18 & 0x4000000000) != 0 && a6)
  {
    *((unsigned char *)a1 + 176) = 1;
    *((_DWORD *)a1 + 45) = 1;
  }
  float v19 = *(int32x2_t **)(a3 + 32);
  if (v19)
  {
    unint64_t v20 = *(void *)(a3 + 24);
    float32x2_t v21 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v20));
    float32x2_t v22 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v20), v21), v21);
    float32x2_t v23 = vmul_f32(v22, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v20), v22));
    float32x2_t v24 = vcvt_f32_s32(v19[8]);
    __int32 v80 = v23.i32[0];
    v23.i32[0] = vmul_f32(v23, v24).u32[0];
    v23.i32[1] = v24.i32[1];
    float32x2_t v25 = vmul_n_f32(v23, COERCE_FLOAT(*(void *)(a3 + 20)));
  }
  else
  {
    __int32 v80 = 0;
    float32x2_t v25 = 0;
  }
  float32x2_t v77 = (float32x2_t)a1[14];
  float64x2_t v78 = (float64x2_t)v89;
  float64x2_t v79 = v90;
  float64x2_t v76 = v91;
  __int32 v26 = *((_DWORD *)a1 + 30);
  RB::RenderFrame::alloc_buffer_region(*(RB::RenderFrame **)*a1, (RB::Device *)0x2C, 4uLL, 0, v92);
  uint64_t v27 = *(RB::Buffer **)v92;
  if (*(void *)v92)
  {
    v28.i32[0] = v77.i32[0];
    v28.i32[1] = vneg_f32(v77).i32[1];
    float32x2_t v29 = vmul_f32(v28, vcvt_f32_f64(v78));
    float32x2_t v30 = vmul_f32(v28, vcvt_f32_f64(v79));
    float32x2_t v31 = vmla_f32((float32x2_t)0x3F800000BF800000, vcvt_f32_f64(v76), v28);
    double v32 = vpmaxq_f64(vabsq_f64(v78));
    double v33 = vpmaxq_f64((float64x2_t)vandq_s8((int8x16_t)v79, (int8x16_t)vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL)));
    if (v32 >= v33) {
      double v33 = v32;
    }
    float v34 = (float32x2_t *)(*(void *)(*(void *)v92 + 56) + *(void *)&v92[8]);
    *float v34 = v29;
    v34[1] = v30;
    v34[2] = v31;
    float64x2_t v34[3] = v25;
    float32_t v35 = 1.0 / v33;
    v34[4].i32[0] = v26;
    v34[4].i32[1] = v80;
    v34[5].f32[0] = v35;
  }
  else
  {
    memset(v92, 0, 24);
  }
  int v36 = RB::RenderFrame::buffer_id(*(RB::RenderFrame **)*a1, v27);
  __n128 v37 = (__n128)vmlaq_laneq_f64(vmlaq_n_f64(v85, (float64x2_t)vbslq_s8((int8x16_t)vdupq_n_s64(v15), v82, v84), v83.f64[0]), v81, v83, 1);
  *((_DWORD *)a1 + 46) = v36;
  v38.n128_u64[1] = *(void *)&v92[16];
  *(int32x2_t *)((char *)a1 + 188) = vmovn_s64(*(int64x2_t *)&v92[8]);
  if (*((_DWORD *)a1 + 34) == 2) {
    int v39 = 131111;
  }
  else {
    int v39 = 39;
  }
  int v40 = ((*(unsigned char *)(a3 + 4) & 7 | (8 * (*(unsigned char *)(a3 + 5) & 3))) << 6) | ((*(unsigned char *)(a3 + 12) == 1) << 11) | v39;
  int v41 = *(_DWORD *)(a3 + 8) & 0x3F;
  double v42 = 0.0;
  if (*(_DWORD *)a3 == 1)
  {
    uint64_t v57 = *(void *)(a3 + 32);
    float32x2_t v43 = 0;
    if (v57)
    {
      __n128 v87 = v37;
      *((_DWORD *)a1 + 58) = RB::RenderFrame::texture_id(*(RB::RenderFrame **)*a1, v57);
      *((unsigned char *)a1 + 236) = 0;
      uint64_t v58 = *(void *)(a3 + 32);
      if (v58)
      {
        unint64_t v59 = *(void *)(a3 + 24);
        float32x2_t v60 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v59));
        float32x2_t v61 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v59), v60), v60);
        float v62 = (float)(*(float *)(a3 + 20) * 0.5)
            * fmaxf((float)(int)*(void *)(v58 + 64)* vmul_f32(v61, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v59), v61)).f32[0], (float)(int)HIDWORD(*(void *)(v58 + 64)));
      }
      else
      {
        float v62 = 0.0;
      }
      *(void *)&v92[16] = a1;
      *(_DWORD *)&v92[24] = v40 & 0x23FC0 | 0x10;
      *(_DWORD *)&v92[28] = v41;
      float64x2_t v93 = (float64x2_t)v89;
      float64x2_t v94 = v90;
      float64x2_t v95 = v91;
      int32x2_t v63 = RB::AffineTransform::scale2((float64x2_t *)&v89);
      v64.i32[0] = 0;
      int32x2_t v96 = v63;
      char v97 = 0;
      float32x2_t v98 = (float32x2_t)vdup_n_s32(0x7F800000u);
      float32x2_t v99 = (float32x2_t)0x7F0000007FLL;
      long long v100 = 0u;
      long long v101 = 0u;
      uint64_t v102 = 0;
      *(void *)float v92 = &unk_26C4ED0E8;
      float v103 = v62;
      int32x2_t v65 = (int32x2_t)a1[21];
      uint32x2_t v66 = (uint32x2_t)vceq_s32(v65, (int32x2_t)0x8000000080000000);
      int8x8_t v67 = (int8x8_t)vdup_lane_s32(vcgt_s32(v64, (int32x2_t)vpmin_u32(v66, v66)), 0);
      (*(void (**)(uint64_t, unsigned char *, void, int8x16_t *, __n128, double, double))(*(void *)a2 + 8))(a2, v92, *a1, &v89, v87, COERCE_DOUBLE(vbsl_s8(v67, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)a1[20]))), COERCE_DOUBLE(vbsl_s8(v67, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v65))));
      *(float32x2_t *)v68.i8 = v99;
      uint32x2_t v69 = (uint32x2_t)vcgt_f32(v99, v98);
      double v42 = 0.0;
      if ((vpmin_u32(v69, v69).u32[0] & 0x80000000) != 0)
      {
        double v42 = RB::Rect::from_bounds(v98, v68);
        float32x2_t v43 = v70;
      }
      *((_DWORD *)a1 + 58) = 0;
      *((unsigned char *)a1 + 236) = 0;
    }
  }
  else
  {
    float32x2_t v43 = 0;
    if (!*(_DWORD *)a3)
    {
      __n128 v86 = v37;
      float v44 = *(float *)(a3 + 16);
      *(void *)&v92[16] = a1;
      *(_DWORD *)&v92[24] = v40 & 0x23FC0 | 0xE;
      *(_DWORD *)&v92[28] = v41;
      float64x2_t v93 = (float64x2_t)v89;
      float64x2_t v94 = v90;
      float64x2_t v95 = v91;
      int32x2_t v45 = RB::AffineTransform::scale2((float64x2_t *)&v89);
      v46.i32[0] = 0;
      v47.n128_u64[1] = v75;
      float32x2_t v48 = vrecpe_f32((float32x2_t)LODWORD(v74));
      float32x2_t v49 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v74), v48), v48);
      int32x2_t v96 = v45;
      char v97 = 0;
      float32x2_t v98 = (float32x2_t)vdup_n_s32(0x7F800000u);
      float32x2_t v99 = (float32x2_t)0x7F0000007FLL;
      long long v100 = 0u;
      long long v101 = 0u;
      uint64_t v102 = 0;
      *(void *)float v92 = &unk_26C4ED070;
      float v103 = vmul_f32(v49, vrecps_f32((float32x2_t)LODWORD(v74), v49)).f32[0] * 0.01;
      float v104 = fmaxf(v44, 1.0);
      float32x2_t v105 = vmul_f32((float32x2_t)v45, (float32x2_t)vdup_n_s32(0x3FB504F3u));
      char v106 = 0;
      long long v107 = xmmword_21421A340;
      uint64_t v108 = 0x3F80000000000000;
      uint64_t v110 = 0;
      uint64_t v111 = 0;
      uint64_t v109 = 0;
      long long v112 = xmmword_21421A340;
      __int16 v113 = 0;
      uint64_t v114 = 0x3F80000000000000;
      unsigned __int8 v115 = 0;
      int32x2_t v50 = (int32x2_t)a1[21];
      uint32x2_t v51 = (uint32x2_t)vceq_s32(v50, (int32x2_t)0x8000000080000000);
      int8x8_t v52 = (int8x8_t)vdup_lane_s32(vcgt_s32(v46, (int32x2_t)vpmin_u32(v51, v51)), 0);
      v53.n128_u64[0] = (unint64_t)vbsl_s8(v52, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)a1[20]));
      v47.n128_u64[0] = (unint64_t)vbsl_s8(v52, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v50));
      (**(void (***)(uint64_t, unsigned char *, void, float64x2_t *, __n128, __n128, __n128))a2)(a2, v92, *a1, (float64x2_t *)&v89, v86, v53, v47);
      *(float32x2_t *)v54.i8 = v99;
      uint32x2_t v55 = (uint32x2_t)vcgt_f32(v99, v98);
      double v42 = 0.0;
      if ((vpmin_u32(v55, v55).u32[0] & 0x80000000) != 0)
      {
        double v42 = RB::Rect::from_bounds(v98, v54);
        float32x2_t v43 = v56;
      }
      if (*((void *)&v100 + 1))
      {
        RB::RenderFrame::commit_buffer_region_size(***(void ***)&v92[16], (uint64_t)&v100 + 8, v102);
        if ((void)v100) {
      }
        }
    }
  }
  if (a6)
  {
    uint32x2_t v71 = (uint32x2_t)vcgtz_f32(v43);
    if ((vpmin_u32(v71, v71).u32[0] & 0x80000000) == 0) {
      goto LABEL_44;
    }
    uint64_t v72 = a1[21];
    *(void *)float v92 = a1[20];
    *(void *)&v92[8] = v72;
    if ((v18 & 0x4000000000) != 0)
    {
      *((unsigned char *)a1 + 176) = 6;
      *((_DWORD *)a1 + 45) = 0;
    }
    RB::Bounds::Bounds(v88, *(float32x2_t *)&v42, v43);
    RB::Bounds::intersect((int32x2_t *)v92, v88[0], v88[1]);
    v38.n128_u64[0] = *(void *)v92;
    v37.n128_u64[0] = *(void *)&v92[8];
  }
  else
  {
    v38.n128_u64[0] = a1[20];
    v37.n128_u64[0] = a1[21];
    *(void *)float v92 = v38.n128_u64[0];
    *(void *)&v92[8] = v37.n128_u64[0];
  }
  float32x2_t v73 = (const char *)(**a4)(a4, a1, v38, v37);
  if ((v73 & 0x3F) != 0x27) {
    RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, v73, 4, **(void **)*a1 + 80, 0, 1uLL, *(int32x2_t *)v92, *(int32x2_t *)&v92[8]);
  }
LABEL_44:
  if ((v18 & 0x4000000000) != 0)
  {
    *((unsigned char *)a1 + 176) = 0;
    *((_DWORD *)a1 + 45) = 0;
  }
}

void sub_2141B0990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  *(_DWORD *)(v39 + 232) = 0;
  *(unsigned char *)(v39 + 236) = 0;
  _Unwind_Resume(a1);
}

void RB::render_stroke(uint64_t a1, float64x2_t *a2, uint64_t a3, uint64_t a4, uint64_t (**a5)(void, void *, __n128, __n128), int a6, int a7)
{
  uint64_t v11 = 18;
  if (*(_DWORD *)(a1 + 136) == 2) {
    uint64_t v11 = 131090;
  }
  uint64_t v12 = 0x10000;
  if (!a6) {
    uint64_t v12 = 0;
  }
  v14[0] = (uint64_t (**)(void, void *, __n128, __n128))&unk_26C4EE820;
  v14[1] = (uint64_t (**)(void, void *, __n128, __n128))(v12 | v11 | ((unint64_t)(a7 & 0x3F) << 32));
  double v14[2] = a5;
  BOOL may_discard_shape = RB::may_discard_shape(a7);
}

void RB::render_stroke(uint64_t a1, uint64_t (**a2)(void, void *, __n128, __n128), uint64_t a3, uint64_t a4, uint64_t (**a5)(void, void *, __n128, __n128), int a6, int a7, float a8)
{
  if (*(_DWORD *)(a1 + 136) == 2) {
    unsigned int v16 = 131091;
  }
  else {
    unsigned int v16 = 19;
  }
  int8x8_t v21 = (int8x8_t)v16;
  RB::Fill::Gradient::set_fill_state((uint64_t)a5, (int *)&v21, a1, a8);
  if (a6) {
    int v17 = 0x10000;
  }
  else {
    int v17 = 0;
  }
  int8x8_t v21 = vorr_s8(vand_s8(v21, (int8x8_t)0xFFFFFFC0FFFEFFFFLL), (int8x8_t)__PAIR64__(a7 & 0x3F, v17));
  v19[0] = (uint64_t (**)(void, void *, __n128, __n128))&unk_26C4EE850;
  v19[1] = (uint64_t (**)(void, void *, __n128, __n128))v21;
  int32x2_t v19[2] = a2;
  _OWORD v19[3] = a5;
  float v20 = a8;
  BOOL may_discard_shape = RB::may_discard_shape(a7);
  *(void *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 220) = 0;
}

void RB::render_stroke(void *a1, uint64_t (**a2)(void, void *, __n128, __n128), uint64_t a3, uint64_t a4, uint64_t (**a5)(void, void *, __n128, __n128), char a6, int a7, float a8)
{
  v8[0] = (uint64_t (**)(void, void *, __n128, __n128))&unk_26C4E8368;
  v8[1] = a2;
  int32x2_t v8[2] = a5;
  char v9 = a6;
  float v10 = a8;
  int v11 = a7;
}

void RB::render_stroke(uint64_t a1, float64x2_t *a2, uint64_t a3, uint64_t a4, uint64_t (**a5)(void, void *, __n128, __n128), uint64_t a6, int a7, int a8)
{
  if (*(_DWORD *)(a1 + 136) == 2) {
    unsigned int v15 = 131093;
  }
  else {
    unsigned int v15 = 21;
  }
  int8x8_t v19 = (int8x8_t)v15;
  RB::RenderState::set_image((int *)&v19, (uint64_t)a5 + 44, *(unsigned __int8 *)(a1 + 124));
  if (a7) {
    int v16 = 0x10000;
  }
  else {
    int v16 = 0;
  }
  int8x8_t v19 = vorr_s8(vand_s8(v19, (int8x8_t)0xFFFFFFC0FFFEFFFFLL), (int8x8_t)__PAIR64__(a8 & 0x3F, v16));
  v18[0] = (uint64_t (**)(void, void *, __n128, __n128))&unk_26C4EE868;
  v18[1] = (uint64_t (**)(void, void *, __n128, __n128))v19;
  void v18[2] = a5;
  BOOL may_discard_shape = RB::may_discard_shape(a8);
}

void RB::render_stroke(uint64_t **a1, uint64_t (**a2)(void, void *, __n128, __n128), uint64_t a3, uint64_t a4, RB::Fill::Custom *this, int a6, int a7, float a8)
{
  int v16 = RB::Fill::Custom::function(this, a1);
  if (v16)
  {
    int v17 = v16;
    if (*((_DWORD *)a1 + 34) == 2) {
      unsigned int v18 = 131094;
    }
    else {
      unsigned int v18 = 22;
    }
    int8x8_t v23 = (int8x8_t)v18;
    RB::Fill::Custom::set_fill_state(this, (RB::RenderState *)&v23, (Function *)v16, (unint64_t **)a1);
    if (a6) {
      int v19 = 0x10000;
    }
    else {
      int v19 = 0;
    }
    int8x8_t v23 = vorr_s8(vand_s8(v23, (int8x8_t)0xFFFFFFC0FFFEFFFFLL), (int8x8_t)__PAIR64__(a7 & 0x3F, v19));
    v21[0] = (uint64_t (**)(void, void *, __n128, __n128))&unk_26C4EE838;
    v21[1] = (uint64_t (**)(void, void *, __n128, __n128))v23;
    void v21[2] = a2;
    float64x2_t v21[3] = (uint64_t (**)(void, void *, __n128, __n128))this;
    _OWORD v21[4] = (uint64_t (**)(void, void *, __n128, __n128))v17;
    float v22 = a8;
    BOOL may_discard_shape = RB::may_discard_shape(a7);
    RB::Fill::Custom::reset_custom(this, (RB::RenderPass *)a1);
  }
}

void RB::anonymous namespace'::StrokeLines::~StrokeLines(RB::_anonymous_namespace_::StrokeLines *this)
{
  if (*((void *)this + 15))
  {
    RB::RenderFrame::commit_buffer_region_size(***((void ***)this + 2), (uint64_t)this + 120, *((void *)this + 18));
    unint64_t v2 = *((void *)this + 14);
    if (v2)
    {
      *((void *)this + 14) = 0;
      *((unsigned char *)this + 288) = 0;
    }
    *(_OWORD *)((char *)this + 120) = 0u;
    *(_OWORD *)((char *)this + 136) = 0u;
  }
}

double RB::anonymous namespace'::StrokeLines::closepath(uint64_t a1, int a2)
{
}

void RB::anonymous namespace'::StrokeLines::moveto(uint64_t a1, void *a2, double a3)
{
  *(double *)(a1 + 168) = a3;
  *(void *)(a1 + 200) = *a2;
  *(unsigned char *)(a1 + 176) = 1;
  *(unsigned char *)(a1 + 249) = 0;
}

void RB::anonymous namespace'::StrokeLines::lineto(uint64_t a1, float *a2, int a3, double a4)
{
  if (*(unsigned char *)(a1 + 176))
  {
    *(void *)(a1 + 184) = *(void *)(a1 + 144) - 16;
    *(unsigned char *)(a1 + 176) = 0;
    if (!*(unsigned char *)(a1 + 249) && (*(_DWORD *)(a1 + 24) & 0x1C0) == 0x80)
    {
      float32x2_t v8 = *(float32x2_t *)(a1 + 272);
      int32x2_t v9 = (int32x2_t)vmul_f32(v8, v8);
      v9.i32[0] = vadd_f32((float32x2_t)v9, (float32x2_t)vdup_lane_s32(v9, 1)).u32[0];
      float32x2_t v10 = vrsqrte_f32((float32x2_t)v9.u32[0]);
      float32x2_t v11 = vmul_f32(vrsqrts_f32((float32x2_t)v9.u32[0], vmul_f32(v10, v10)), v10);
      int32x2_t v12 = (int32x2_t)vmul_n_f32(v8, vmul_f32(v11, vrsqrts_f32((float32x2_t)v9.u32[0], vmul_f32(v11, v11))).f32[0]);
      float32x2_t v13 = vsub_f32(*(float32x2_t *)&a4, *(float32x2_t *)(a1 + 168));
      int32x2_t v14 = (int32x2_t)vmul_f32(v13, v13);
      unsigned __int32 v15 = vadd_f32((float32x2_t)v14, (float32x2_t)vdup_lane_s32(v14, 1)).u32[0];
      float32x2_t v16 = vrsqrte_f32((float32x2_t)v15);
      int32x2_t v17 = (int32x2_t)vmul_f32(vrsqrts_f32((float32x2_t)v15, vmul_f32(v16, v16)), v16);
      float32x2_t v18 = vmul_n_f32(v13, vmul_f32((float32x2_t)v17, vrsqrts_f32((float32x2_t)v15, vmul_f32((float32x2_t)v17, (float32x2_t)v17))).f32[0]);
      float v19 = *(float *)(a1 + 200);
      *(float *)v17.i32 = -*(float *)&v12.i32[1];
      int32x2_t v20 = (int32x2_t)vmul_f32(v18, (float32x2_t)vzip1_s32(v17, v12));
      int32x2_t v21 = (int32x2_t)vmul_f32(v18, (float32x2_t)v12);
      float32x2_t v22 = vadd_f32((float32x2_t)vzip1_s32(v20, v21), (float32x2_t)vzip2_s32(v20, v21));
      float v23 = (float)(v19 * v22.f32[0]) / v22.f32[1];
      if ((LODWORD(v23) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
      {
        float v24 = sqrtf(vaddv_f32((float32x2_t)v14));
        float v25 = fabsf(v23);
        if (v25 > *(float *)(a1 + 152) && v25 < v24)
        {
          *(_WORD *)(*(void *)(*(void *)(a1 + 120) + 56) + *(void *)(a1 + 128) + *(void *)(a1 + 144) - 2) = -2;
          *(unsigned char *)(a1 + 288) = 1;
          float v27 = v24;
          float32x2_t v28 = vrecpe_f32((float32x2_t)LODWORD(v24));
          float32x2_t v29 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v27), v28), v28);
          float v30 = v25 * vmul_f32(v29, vrecps_f32((float32x2_t)LODWORD(v27), v29)).f32[0];
        }
      }
    }
  }
  if (*(unsigned char *)(a1 + 249))
  {
    *(unsigned char *)(a1 + 249) = 0;
  }
  float v31 = *a2;
  float v32 = a2[1];
}

uint64_t RB::anonymous namespace'::StrokeLines::skipto(uint64_t result, void *a2, double a3)
{
  *(unsigned char *)(result + 176) = 0;
  *(unsigned char *)(result + 249) = 1;
  *(double *)(result + 256) = a3;
  *(void *)(result + 264) = *a2;
  return result;
}

uint64_t RB::anonymous namespace'::StrokeLines::tangent(uint64_t result, int a2, double a3)
{
  if (a2 == 1)
  {
    *(double *)(result + 280) = a3;
  }
  else if (!a2)
  {
    *(double *)(result + 272) = a3;
  }
  return result;
}

double RB::anonymous namespace'::StrokeLines::finish_subpath(uint64_t a1, int a2, int a3)
{
  uint64_t v4 = *(void *)(a1 + 120);
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 192);
    if (v5)
    {
      if (v5 == 2)
      {
        if ((*(_DWORD *)(a1 + 24) & 0x1C0) == 0x80) {
          goto LABEL_11;
        }
        int v7 = (void *)(*(void *)(v4 + 56) + *(void *)(a1 + 128) + *(void *)(a1 + 144));
        uint64_t v8 = *(v7 - 1) & 0xFFFFFFFFFFFFLL | 0x1000000000000;
        void *v7 = *(v7 - 2);
        uint64_t v9 = 1;
      }
      else
      {
        if (v5 != 1) {
          goto LABEL_11;
        }
        uint64_t v6 = *(void *)(a1 + 144);
        if ((*(_WORD *)(a1 + 24) & 0x1C0) != 0)
        {
          *(void *)(a1 + 144) = v6 - 16;
          --*(void *)(a1 + 112);
          *(void *)(a1 + 192) = 0;
          goto LABEL_41;
        }
        float32x2_t v10 = (void *)(*(void *)(v4 + 56) + *(void *)(a1 + 128) + v6);
        uint64_t v11 = *(v10 - 2);
        uint64_t v8 = *(v10 - 1) & 0xFFFFFFFFFFFFLL | 0x1000000000000;
        *float32x2_t v10 = v11;
        v10[1] = v8;
        uint64_t v12 = *(void *)(a1 + 144) + 16;
        *(void *)(a1 + 144) = v12;
        int v7 = (void *)(*(void *)(*(void *)(a1 + 120) + 56) + *(void *)(a1 + 128) + v12);
        void *v7 = v11;
        uint64_t v9 = 2;
      }
      v7[1] = v8;
      *(void *)(a1 + 144) += 16;
      *(void *)(a1 + 112) += v9;
      *(void *)(a1 + 192) += v9;
LABEL_11:
      uint64_t v13 = *(void *)(a1 + 144);
      uint64_t v14 = *(void *)(*(void *)(a1 + 120) + 56) + *(void *)(a1 + 128);
      uint64_t v15 = v14 + v13;
      if (a2)
      {
        uint64_t v16 = *(void *)(a1 + 208);
        uint64_t v17 = 232;
        if (!v16) {
          uint64_t v17 = 184;
        }
        if ((*(void *)(a1 + v17) & 0x8000000000000000) == 0)
        {
          float32x2_t v18 = (_OWORD *)(v15 - 32);
          if (v16)
          {
            uint64_t v14 = *(void *)(v16 + 56);
            uint64_t v19 = *(void *)(a1 + 216) + *(void *)(a1 + 232);
          }
          else
          {
            uint64_t v19 = *(void *)(a1 + 184);
          }
          uint64_t v52 = v14 + v19;
          if (*(__int16 *)(v52 + 30) == -2)
          {
            long long v53 = *(_OWORD *)(v52 + 16);
            *(_OWORD *)(v52 + 16) = *(_OWORD *)v52;
            *(_OWORD *)(v52 + 32) = v53;
            *(_WORD *)(v52 + 14) = -1;
            v52 += 16;
          }
          *(_OWORD *)uint64_t v52 = *v18;
          __int16 v51 = -1;
          *(_WORD *)(v52 + 14) = -1;
          *(_WORD *)(v52 + 30) = a3;
          BOOL v55 = a3 != 1 || *(unsigned char *)(a1 + 288) != 0;
          *(unsigned char *)(a1 + 288) = v55;
          float32x2_t v48 = *(float32x2_t *)(v52 + 32);
          float32x2_t v49 = (__int32 *)(v52 + 40);
          int32x2_t v50 = (__int16 *)(v52 + 44);
          uint64_t v13 = *(void *)(a1 + 144);
          goto LABEL_40;
        }
        *(_WORD *)(v15 - 2) = 1;
      }
      else
      {
        *(_WORD *)(v15 - 2) = 1;
        if (!*(unsigned char *)(a1 + 249) && (*(_DWORD *)(a1 + 24) & 0x1C0) == 0x80)
        {
          float32x2_t v20 = *(float32x2_t *)(a1 + 280);
          int32x2_t v21 = (int32x2_t)vmul_f32(v20, v20);
          v21.i32[0] = vadd_f32((float32x2_t)v21, (float32x2_t)vdup_lane_s32(v21, 1)).u32[0];
          float32x2_t v22 = vrsqrte_f32((float32x2_t)v21.u32[0]);
          float32x2_t v23 = vmul_f32(vrsqrts_f32((float32x2_t)v21.u32[0], vmul_f32(v22, v22)), v22);
          int32x2_t v24 = (int32x2_t)vmul_n_f32(v20, vmul_f32(v23, vrsqrts_f32((float32x2_t)v21.u32[0], vmul_f32(v23, v23))).f32[0]);
          float32x2_t v25 = *(float32x2_t *)(v15 - 16);
          float32x2_t v26 = vsub_f32(v25, *(float32x2_t *)(v15 - 32));
          int32x2_t v27 = (int32x2_t)vmul_f32(v26, v26);
          unsigned __int32 v28 = vadd_f32((float32x2_t)v27, (float32x2_t)vdup_lane_s32(v27, 1)).u32[0];
          float32x2_t v29 = vrsqrte_f32((float32x2_t)v28);
          int32x2_t v30 = (int32x2_t)vmul_f32(vrsqrts_f32((float32x2_t)v28, vmul_f32(v29, v29)), v29);
          float32x2_t v31 = vmul_n_f32(v26, vmul_f32((float32x2_t)v30, vrsqrts_f32((float32x2_t)v28, vmul_f32((float32x2_t)v30, (float32x2_t)v30))).f32[0]);
          *(float *)v30.i32 = -*(float *)&v24.i32[1];
          int32x2_t v32 = (int32x2_t)vmul_f32(v31, (float32x2_t)vzip1_s32(v30, v24));
          int32x2_t v33 = (int32x2_t)vmul_f32(v31, (float32x2_t)v24);
          float32x2_t v34 = vadd_f32((float32x2_t)vzip1_s32(v32, v33), (float32x2_t)vzip2_s32(v32, v33));
          float v35 = (float)(*(float *)(a1 + 200) * v34.f32[0]) / v34.f32[1];
          if (COERCE_UNSIGNED_INT(fabs(v35)) <= 0x7F7FFFFF)
          {
            float v36 = sqrtf(vaddv_f32((float32x2_t)v27));
            *(float *)v27.i32 = fabsf(v35);
            if (*(float *)v27.i32 > *(float *)(a1 + 152) && *(float *)v27.i32 < v36)
            {
              float32x2_t v38 = vmls_lane_f32(v25, v31, (float32x2_t)v27, 0);
              float v39 = v36;
              float32x2_t v40 = vrecpe_f32((float32x2_t)LODWORD(v36));
              _D3 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v39), v40), v40);
              _D3.f32[0] = *(float *)v27.i32 * vmul_f32(_D3, vrecps_f32((float32x2_t)LODWORD(v39), _D3)).f32[0];
              float v42 = *(float *)(v15 - 8);
              float v43 = v42 + (float)((float)(*(float *)(v15 - 24) - v42) * _D3.f32[0]);
              short float v44 = *(short float *)(v15 - 4);
              __asm { FCVT            H3, S3 }
              *(short float *)_D3.i16 = v44
                                      + (short float)((short float)(*(short float *)(v15 - 20) - v44)
                                                    * *(short float *)_D3.i16);
              *(float32x2_t *)(v15 - 16) = v38;
              *(float *)(v15 - 8) = v43;
              *(_WORD *)(v15 - 4) = _D3.i16[0];
              *(_WORD *)(v15 - 2) = 2;
              if (!*(unsigned char *)(a1 + 288)) {
                *(unsigned char *)(a1 + 288) = 1;
              }
              uint64_t v47 = *(void *)(*(void *)(a1 + 120) + 56) + *(void *)(a1 + 128) + *(void *)(a1 + 144);
              *(float32x2_t *)uint64_t v47 = v25;
              *(float *)(v47 + 8) = v42;
              *(short float *)(v47 + 12) = v44;
              *(_WORD *)(v47 + 14) = -2;
              uint64_t v13 = *(void *)(a1 + 144) + 16;
              *(void *)(a1 + 144) = v13;
              ++*(void *)(a1 + 112);
            }
          }
        }
      }
      float32x2_t v48 = vadd_f32(*(float32x2_t *)(a1 + 280), *(float32x2_t *)(v15 - 16));
      float32x2_t v49 = (__int32 *)(v15 - 8);
      int32x2_t v50 = (__int16 *)(v15 - 4);
      __int16 v51 = -3;
LABEL_40:
      __int32 v56 = *v49;
      __int16 v57 = *v50;
      uint64_t v58 = (float32x2_t *)(*(void *)(*(void *)(a1 + 120) + 56) + *(void *)(a1 + 128) + v13);
      float32x2_t *v58 = v48;
      v58[1].i32[0] = v56;
      v58[1].i16[2] = v57;
      v58[1].i16[3] = v51;
      *(void *)(a1 + 144) += 16;
      ++*(void *)(a1 + 112);
    }
  }
LABEL_41:
  unint64_t v59 = (void *)(a1 + 208);
  if (*(void *)(a1 + 208))
  {
    *unint64_t v59 = 0;
    *(void *)(a1 + 216) = 0;
    *(void *)(a1 + 224) = 0;
    *(_OWORD *)(a1 + 232) = xmmword_21421A340;
  }
  double result = NAN;
  *(_OWORD *)(a1 + 184) = xmmword_21421A340;
  return result;
}

__n128 RB::anonymous namespace'::StrokeLines::push_back(uint64_t a1, __n128 *a2)
{
  if (!*(unsigned char *)(a1 + 288))
  {
    unsigned int v2 = a2->n128_i16[7] + 2;
    BOOL v3 = v2 > 4;
    int v4 = (1 << v2) & 0x15;
    if (!v3 && v4 != 0) {
      *(unsigned char *)(a1 + 288) = 1;
    }
  }
  __n128 result = *a2;
  *(__n128 *)(*(void *)(*(void *)(a1 + 120) + 56) + *(void *)(a1 + 128) + *(void *)(a1 + 144)) = *a2;
  *(void *)(a1 + 144) += 16;
  return result;
}

void RB::anonymous namespace'::StrokeLines::draw_buffer(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v8 = *(void *)(a1 + 16);
  *(_DWORD *)(v8 + 196) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v8, *(RB::Buffer **)a2);
  *(int32x2_t *)(v8 + 200) = vmovn_s64(*(int64x2_t *)(a2 + 8));
  uint32x2_t v9 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(a1 + 104), *(float32x2_t *)(a1 + 96));
  unsigned __int32 v10 = vpmin_u32(v9, v9).u32[0];
  v11.i64[0] = 0;
  double v12 = 0.0;
  if ((v10 & 0x80000000) != 0)
  {
    v11.i64[0] = *(void *)(a1 + 104);
    double v12 = RB::Rect::from_bounds(*(float32x2_t *)(a1 + 96), v11);
  }
  RB::Bounds::Bounds(&v16, *(float32x2_t *)&v12, *(float32x2_t *)v11.i8);
  unsigned int v13 = *(_DWORD *)(a1 + 24);
  uint64_t v14 = *(unsigned int *)(a1 + 28);
  if (*(unsigned char *)(a1 + 88)) {
    uint64_t v15 = v13 | 0x1000;
  }
  else {
    uint64_t v15 = v13;
  }
  if (a3 > 3) {
    RB::RenderPass::draw_indexed_primitives(*(int32x2_t **)(a1 + 16), (const char *)(v15 | (v14 << 32)), 4, ****(void ****)(a1 + 16) + 80, 0, a3 - 3, v16, v17);
  }
  if (a3 >= 3 && a4) {
    RB::RenderPass::draw_indexed_primitives(*(int32x2_t **)(a1 + 16), (const char *)(v15 & 0xFFFFFFC0 | 0xF | (v14 << 32)), 4, ****(void ****)(a1 + 16) + 80, 0, a3 - 2, v16, v17);
  }
  *(void *)(v8 + 200) = 0;
  *(_DWORD *)(v8 + 196) = 0;
}

void sub_2141B1724(_Unwind_Exception *a1)
{
  *(void *)(v1 + 200) = 0;
  *(_DWORD *)(v1 + 196) = 0;
  _Unwind_Resume(a1);
}

void RB::anonymous namespace'::StrokeLines::add_point(uint64_t a1, int a2, double a3, float a4, float _S2)
{
  if (a4 > 0.0 && a2 != -3)
  {
    if (*(void *)(a1 + 192))
    {
      uint32x2_t v9 = (uint32x2_t)vceq_f32(*(float32x2_t *)(*(void *)(*(void *)(a1 + 120) + 56)+ *(void *)(a1 + 128)+ *(void *)(a1 + 144)- 16), *(float32x2_t *)&a3);
      if ((vpmin_u32(v9, v9).u32[0] & 0x80000000) != 0) {
        return;
      }
    }
    float32x2_t v10 = vmul_n_f32(*(float32x2_t *)(a1 + 160), a4);
    if (!a2) {
      float32x2_t v10 = vmul_n_f32(v10, *(float *)(a1 + 156));
    }
    float64x2_t v11 = vcvtq_f64_f32(*(float32x2_t *)&a3);
    *(float32x2_t *)&v11.f64[0] = vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 64), *(float64x2_t *)(a1 + 32), v11.f64[0]), *(float64x2_t *)(a1 + 48), v11, 1));
    float32x2_t v12 = vminnm_f32(*(float32x2_t *)(a1 + 96), vsub_f32(*(float32x2_t *)&v11.f64[0], v10));
    float32x2_t v13 = vmaxnm_f32(*(float32x2_t *)(a1 + 104), vadd_f32(v10, *(float32x2_t *)&v11.f64[0]));
    *(float32x2_t *)(a1 + 96) = v12;
    *(float32x2_t *)(a1 + 104) = v13;
    if (_S2 != 1.0) {
      *(unsigned char *)(a1 + 88) = 1;
    }
  }
  v20.n128_f64[0] = a3;
  v20.n128_f32[2] = a4;
  __asm { FCVT            H0, S2 }
  v20.n128_u16[6] = _H0;
  v20.n128_u16[7] = a2;
  if (!*(void *)(a1 + 120) || (unint64_t)(*(void *)(a1 + 144) + 64) > *(void *)(a1 + 136)) {
  if (!*(unsigned char *)(a1 + 288) && (a2 + 2) <= 4 && ((1 << (a2 + 2)) & 0x15) != 0)
  }
    *(unsigned char *)(a1 + 288) = 1;
  unint64_t v18 = v20.n128_u64[1];
  uint64_t v19 = *(void *)(*(void *)(a1 + 120) + 56) + *(void *)(a1 + 128) + *(void *)(a1 + 144);
  *(double *)uint64_t v19 = a3;
  *(void *)(v19 + 8) = v18;
  *(void *)(a1 + 144) += 16;
  ++*(void *)(a1 + 112);
  ++*(void *)(a1 + 192);
}

void RB::anonymous namespace'::StrokeLines::new_buffer(uint64_t a1, __n128 *a2)
{
  BOOL v3 = (void *)(a1 + 120);
  if (*(void *)(a1 + 112))
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 120) + 56) + *(void *)(a1 + 128) + *(void *)(a1 + 144);
    uint64_t v5 = (__n128 *)(v4 - 16);
    uint64_t v6 = (__n128 *)(v4 - 32);
    if (*(void *)(a1 + 192))
    {
      ++*(void *)(a1 + 112);
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    if (!*v3) {
      goto LABEL_9;
    }
  }
  RB::RenderFrame::commit_buffer_region_size(***(void ***)(a1 + 16), (uint64_t)v3, *(void *)(a1 + 144));
  unint64_t v7 = *(void *)(a1 + 112);
  if (v7)
  {
    if (*(void *)(a1 + 208))
    {
    }
    else
    {
      *(void *)(a1 + 208) = *(void *)(a1 + 120);
      *(_OWORD *)(a1 + 216) = *(_OWORD *)(a1 + 128);
      *(void *)(a1 + 232) = *(void *)(a1 + 184);
      *(void *)(a1 + 240) = v7;
      *(unsigned char *)(a1 + 248) = *(unsigned char *)(a1 + 288);
    }
  }
LABEL_9:
  RB::RenderFrame::alloc_buffer_region(***(RB::RenderFrame ****)(a1 + 16), (RB::Device *)0x800, 4uLL, 1, &v8);
  *(void *)(a1 + 120) = v8;
  *(_OWORD *)(a1 + 128) = v9;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 184) = -1;
  *(unsigned char *)(a1 + 288) = 0;
  if (v6)
  {
    if (v5)
    {
      *(void *)(a1 + 112) = 2;
    }
  }
}

float *RB::anonymous namespace'::StrokeParticles::add_particle(float *this, unint64_t a2, float32x2_t a3, float32x2_t a4, float a5, float a6)
{
  uint64_t v8 = this;
  uint64_t v9 = *((void *)this + 15);
  if (!v9 || (uint64_t v10 = *((void *)this + 18), (unint64_t)(v10 + 20) > *((void *)this + 17)))
  {
    float v25 = a6;
    float v26 = a5;
    float32x2_t v24 = a4;
    a4 = v24;
    a6 = v25;
    a5 = v26;
    uint64_t v10 = *((void *)v8 + 18);
    uint64_t v9 = *((void *)v8 + 15);
  }
  *(float32x2_t *)v11.f32 = a4;
  v11.i64[1] = __PAIR64__(LODWORD(a5), LODWORD(a6));
  uint64_t v12 = *(void *)(v9 + 56) + *((void *)v8 + 16) + v10;
  *(double *)uint64_t v12 = *(double *)&a3;
  *(float16x4_t *)(v12 + 8) = vcvt_f16_f32(v11);
  *(short float *)(v12 + 16) = (short float)a2;
  *((void *)v8 + 18) += 20;
  ++*((void *)v8 + 14);
  int32x2_t v13 = (int32x2_t)vmul_f32(a4, a4);
  v13.i32[0] = vadd_f32((float32x2_t)v13, (float32x2_t)vdup_lane_s32(v13, 1)).u32[0];
  float32x2_t v14 = vrsqrte_f32((float32x2_t)v13.u32[0]);
  v13.i32[0] = vmul_f32(vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(v14, v14)), v14).u32[0];
  float32x2_t v15 = vrecpe_f32((float32x2_t)v13.u32[0]);
  LODWORD(v16) = vmul_f32(vrecps_f32((float32x2_t)v13.u32[0], v15), v15).u32[0];
  if (a6 >= 1.0) {
    float v17 = a6;
  }
  else {
    float v17 = 1.0;
  }
  float32x2_t v18 = vmul_n_f32(*(float32x2_t *)(v8 + 20), (float)(v8[38] * v17) * v16);
  float64x2_t v19 = vcvtq_f64_f32(a3);
  *(float32x2_t *)&v19.f64[0] = vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(v8 + 16), *(float64x2_t *)(v8 + 8), v19.f64[0]), *(float64x2_t *)(v8 + 12), v19, 1));
  float32x2_t v20 = vminnm_f32(*(float32x2_t *)(v8 + 24), vsub_f32(*(float32x2_t *)&v19.f64[0], v18));
  float32x2_t v21 = vmaxnm_f32(*(float32x2_t *)(v8 + 26), vadd_f32(v18, *(float32x2_t *)&v19.f64[0]));
  *((float32x2_t *)v8 + 12) = v20;
  *((float32x2_t *)v8 + 13) = v21;
  BOOL v23 = a5 != 1.0 || *((unsigned char *)v8 + 88) != 0;
  *((unsigned char *)v8 + 88) = v23;
  return this;
}

uint64_t RB::anonymous namespace'::StrokeParticles::flush(uint64_t this, int a2)
{
  uint64_t v3 = this;
  if (*(void *)(this + 120))
  {
    this = RB::RenderFrame::commit_buffer_region_size(***(void ***)(this + 16), this + 120, *(void *)(this + 144));
    if (*(void *)(v3 + 112))
    {
      unsigned int v4 = *(_DWORD *)(v3 + 24);
      uint64_t v5 = *(unsigned int *)(v3 + 28);
      if (*(unsigned char *)(v3 + 88)) {
        uint64_t v6 = v4 | 0x1000;
      }
      else {
        uint64_t v6 = v4;
      }
      uint64_t v7 = *(void *)(v3 + 16);
      *(_DWORD *)(v7 + 196) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v7, *(RB::Buffer **)(v3 + 120));
      *(int32x2_t *)(v7 + 200) = vmovn_s64(*(int64x2_t *)(v3 + 128));
      uint64_t v8 = *(int32x2_t **)(v3 + 16);
      uint32x2_t v9 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(v3 + 104), *(float32x2_t *)(v3 + 96));
      unsigned __int32 v10 = vpmin_u32(v9, v9).u32[0];
      v11.i64[0] = 0;
      double v12 = 0.0;
      if ((v10 & 0x80000000) != 0)
      {
        v11.i64[0] = *(void *)(v3 + 104);
        double v12 = RB::Rect::from_bounds(*(float32x2_t *)(v3 + 96), v11);
      }
      RB::Bounds::Bounds(v17, *(float32x2_t *)&v12, *(float32x2_t *)v11.i8);
      this = (uint64_t)RB::RenderPass::draw_indexed_primitives(v8, (const char *)(v6 | (v5 << 32)), 4, ***(void ***)v8 + 80, 0, *(void *)(v3 + 112), v17[0], v17[1]);
      *(void *)(v3 + 112) = 0;
      *(void *)(v7 + 200) = 0;
      *(_DWORD *)(v7 + 196) = 0;
    }
  }
  if (a2)
  {
    this = (uint64_t)RB::RenderFrame::alloc_buffer_region(***(RB::RenderFrame ****)(v3 + 16), (RB::Device *)0xA00, 4uLL, 1, &v15);
    uint64_t v13 = v15;
    long long v14 = v16;
  }
  else
  {
    uint64_t v13 = 0;
    long long v14 = 0uLL;
  }
  *(void *)(v3 + 120) = v13;
  *(_OWORD *)(v3 + 128) = v14;
  *(void *)(v3 + 144) = 0;
  return this;
}

void sub_2141B1C8C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 200) = 0;
  *(_DWORD *)(v1 + 196) = 0;
  _Unwind_Resume(a1);
}

uint64_t RB::render_stroke_coverage(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::StrokeGenerator const&,RB::Coverage::StrokeInfo const&,float,RB::BlendMode)::Renderer::operator()(uint64_t a1, uint64_t a2, int32x2_t a3, int32x2_t a4, int32x2_t a5)
{
  a5.i32[0] = 0;
  uint32x2_t v7 = (uint32x2_t)vceq_s32(a4, (int32x2_t)0x8000000080000000);
  int8x8_t v8 = (int8x8_t)vdup_lane_s32(vcgt_s32(a5, (int32x2_t)vpmin_u32(v7, v7)), 0);
  RB::Coverage::set_plane((float32x2_t *)&v18, (float32x2_t *)a2, (float32x2_t)vbsl_s8(v8, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a3)), COERCE_DOUBLE(vbsl_s8(v8, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a4))));
  _S0 = *(_DWORD *)(a1 + 16);
  __asm { FCVT            H0, S0 }
  WORD6(v19) = _S0;
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x20, 4uLL, 0, &v20);
  long long v14 = v20;
  if (v20)
  {
    uint64_t v15 = (_OWORD *)(*((void *)v20 + 7) + v21.i64[0]);
    long long v16 = v19;
    *uint64_t v15 = v18;
    v15[1] = v16;
  }
  else
  {
    float32x2_t v20 = 0;
    int64x2_t v21 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v14);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v21);
  return *(void *)(a1 + 8);
}

uint64_t RB::render_stroke(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::StrokeGenerator const&,RB::Coverage::StrokeInfo const&,RB::Fill::Color const&,BOOL,RB::BlendMode)::Renderer::operator()(uint64_t a1, uint64_t a2, int32x2_t a3, int32x2_t a4, int32x2_t a5)
{
  a5.i32[0] = 0;
  uint32x2_t v7 = (uint32x2_t)vceq_s32(a4, (int32x2_t)0x8000000080000000);
  int8x8_t v8 = (int8x8_t)vdup_lane_s32(vcgt_s32(a5, (int32x2_t)vpmin_u32(v7, v7)), 0);
  *(float *)&double v9 = RB::Coverage::set_plane((float32x2_t *)&v15, (float32x2_t *)a2, (float32x2_t)vbsl_s8(v8, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a3)), COERCE_DOUBLE(vbsl_s8(v8, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a4))));
  *(float16x4_t *)&v16[12] = RB::Fill::Color::prepare(*(void *)(a1 + 16), *(unsigned __int8 *)(a2 + 124), v9);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x24, 4uLL, 0, &v17);
  unsigned __int32 v10 = v17;
  if (v17)
  {
    uint64_t v11 = *((void *)v17 + 7) + v18.i64[0];
    long long v12 = v15;
    long long v13 = *(_OWORD *)v16;
    *(_DWORD *)(v11 + 32) = *(_DWORD *)&v16[16];
    *(_OWORD *)uint64_t v11 = v12;
    *(_OWORD *)(v11 + 16) = v13;
  }
  else
  {
    float v17 = 0;
    int64x2_t v18 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v10);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v18);
  return *(void *)(a1 + 8);
}

uint64_t RB::render_stroke(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::StrokeGenerator const&,RB::Coverage::StrokeInfo const&,RB::Fill::Gradient const&,BOOL,float,RB::BlendMode)::Renderer::operator()(uint64_t a1, uint64_t a2, int32x2_t a3, int32x2_t a4, int32x2_t a5)
{
  a5.i32[0] = 0;
  uint32x2_t v7 = (uint32x2_t)vceq_s32(a4, (int32x2_t)0x8000000080000000);
  int8x8_t v8 = (int8x8_t)vdup_lane_s32(vcgt_s32(a5, (int32x2_t)vpmin_u32(v7, v7)), 0);
  RB::Coverage::set_plane((float32x2_t *)&v17, (float32x2_t *)a2, (float32x2_t)vbsl_s8(v8, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a3)), COERCE_DOUBLE(vbsl_s8(v8, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a4))));
  LODWORD(v9) = *(_DWORD *)(a1 + 32);
  RB::Fill::Gradient::set_gradient(*(float32x2_t **)(a1 + 24), (uint64_t)v18 + 12, a2, *(float64x2_t **)(a1 + 16), v9);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x54, 4uLL, 0, &v20);
  unsigned __int32 v10 = v20;
  if (v20)
  {
    uint64_t v11 = *((void *)v20 + 7) + v21.i64[0];
    long long v12 = v17;
    *(_OWORD *)(v11 + 16) = v18[0];
    long long v13 = v18[3];
    long long v14 = v18[2];
    long long v15 = v18[1];
    *(_DWORD *)(v11 + 80) = v19;
    *(_OWORD *)(v11 + 48) = v14;
    *(_OWORD *)(v11 + 64) = v13;
    *(_OWORD *)(v11 + 32) = v15;
    *(_OWORD *)uint64_t v11 = v12;
  }
  else
  {
    float32x2_t v20 = 0;
    int64x2_t v21 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v10);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v21);
  return *(void *)(a1 + 8);
}

uint64_t RB::render_stroke(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::StrokeGenerator const&,RB::Coverage::StrokeInfo const&,RB::Fill::MeshGradient const&,BOOL,float,RB::BlendMode)::Renderer::operator()(uint64_t a1, RB::RenderPass *a2, int32x2_t a3, int32x2_t a4)
{
  v6[0] = a3;
  v6[1] = a4;
  RB::render_mesh_gradient(a2, *(float64x2_t **)(a1 + 8), *(RB::Fill::MeshGradient **)(a1 + 16), 0, *(unsigned __int8 *)(a1 + 24), *(_DWORD *)(a1 + 32), v6, *(float *)(a1 + 28));
  if (*((_DWORD *)a2 + 34) == 2) {
    return 131111;
  }
  else {
    return 39;
  }
}

uint64_t RB::render_stroke(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::StrokeGenerator const&,RB::Coverage::StrokeInfo const&,RB::Shader::Globals<RB::Shader::StrokeGlobals,RB::Shader::ImageGlobals> &,RB::Fill::ImageData const&,BOOL,RB::BlendMode)::Renderer::operator()(uint64_t a1, uint64_t a2, int32x2_t a3, int32x2_t a4, int32x2_t a5)
{
  a5.i32[0] = 0;
  uint32x2_t v7 = (uint32x2_t)vceq_s32(a4, (int32x2_t)0x8000000080000000);
  int8x8_t v8 = (int8x8_t)vdup_lane_s32(vcgt_s32(a5, (int32x2_t)vpmin_u32(v7, v7)), 0);
  RB::Coverage::set_plane((float32x2_t *)&v21, (float32x2_t *)a2, (float32x2_t)vbsl_s8(v8, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a3)), COERCE_DOUBLE(vbsl_s8(v8, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a4))));
  uint64_t v9 = *(void *)(a1 + 16);
  long long v10 = *(_OWORD *)(v9 + 44);
  *(_OWORD *)&v22[28] = *(_OWORD *)(v9 + 60);
  long long v11 = *(_OWORD *)(v9 + 76);
  long long v12 = *(_OWORD *)(v9 + 92);
  *(_OWORD *)&v22[76] = *(_OWORD *)(v9 + 108);
  *(_OWORD *)&v22[60] = v12;
  *(_DWORD *)&v22[92] = *(_DWORD *)(v9 + 124);
  *(_OWORD *)&v22[44] = v11;
  *(_OWORD *)&v22[12] = v10;
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x70, 4uLL, 0, &v23);
  long long v13 = v23;
  if (v23)
  {
    long long v14 = (_OWORD *)(*((void *)v23 + 7) + v24.i64[0]);
    long long v15 = *(_OWORD *)&v22[16];
    long long v16 = v21;
    v14[1] = *(_OWORD *)v22;
    double v14[2] = v15;
    long long v17 = *(_OWORD *)&v22[80];
    long long v18 = *(_OWORD *)&v22[48];
    long long v19 = *(_OWORD *)&v22[32];
    v14[5] = *(_OWORD *)&v22[64];
    v14[6] = v17;
    _OWORD v14[3] = v19;
    v14[4] = v18;
    *long long v14 = v16;
  }
  else
  {
    BOOL v23 = 0;
    int64x2_t v24 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v13);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v24);
  return *(void *)(a1 + 8);
}

unint64_t RB::render_stroke(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::StrokeGenerator const&,RB::Coverage::StrokeInfo const&,RB::Fill::Custom const&,BOOL,float,RB::BlendMode)::Renderer::operator()(uint64_t a1, uint64_t a2, int32x2_t a3, int32x2_t a4)
{
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)(*(unsigned int *)(*(void *)(a1 + 32) + 80) + 56), 4uLL, 0, &v15);
  unint64_t v9 = (unint64_t)v15;
  if (v15)
  {
    v8.i32[0] = 0;
    uint64_t v10 = *((void *)v15 + 7) + v16.i64[0];
    uint32x2_t v11 = (uint32x2_t)vceq_s32(a4, (int32x2_t)0x8000000080000000);
    int8x8_t v12 = (int8x8_t)vdup_lane_s32(vcgt_s32(v8, (int32x2_t)vpmin_u32(v11, v11)), 0);
    RB::Coverage::set_plane((float32x2_t *)v10, (float32x2_t *)a2, (float32x2_t)vbsl_s8(v12, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a3)), COERCE_DOUBLE(vbsl_s8(v12, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a4))));
    if (RB::Fill::Custom::set_custom(*(void *)(a1 + 24), (float32x2_t *)(v10 + 28), *(void *)(a1 + 32), v10 + 56, a2, *(float64x2_t **)(a1 + 16), *(float *)(a1 + 40)))
    {
      *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v15);
      *(int32x2_t *)(a2 + 188) = vmovn_s64(v16);
      unint64_t v9 = *(void *)(a1 + 8) & 0xFFFFFFFF00000000;
      uint64_t v13 = *(void *)(a1 + 8);
      return v13 | v9;
    }
    unint64_t v9 = 0;
  }
  uint64_t v13 = 39;
  if (*(_DWORD *)(a2 + 136) == 2) {
    uint64_t v13 = 131111;
  }
  return v13 | v9;
}

uint64_t RB::DisplayList::State::operator=(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  long long v4 = *(_OWORD *)(a2 + 16);
  long long v5 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v5;
  *(_OWORD *)(a1 + 16) = v4;
  long long v6 = *(_OWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = v6;
  uint32x2_t v7 = *(atomic_uint **)(a1 + 88);
  int32x2_t v8 = *(atomic_uint **)(a2 + 88);
  if (v7 != v8)
  {
    if (v7)
    {
      if (atomic_fetch_add_explicit(v7 + 2, 0xFFFFFFFF, memory_order_release) == 1)
      {
        __dmb(9u);
        (*(void (**)(atomic_uint *))(*(void *)v7 + 8))(v7);
      }
      int32x2_t v8 = *(atomic_uint **)(a2 + 88);
    }
    if (v8) {
      atomic_fetch_add_explicit(v8 + 2, 1u, memory_order_relaxed);
    }
    *(void *)(a1 + 88) = v8;
  }
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
  *(void *)(a1 + 144) = *(void *)(a2 + 144);
  *(_WORD *)(a1 + 156) = *(_WORD *)(a2 + 156);
  return a1;
}

atomic_uint *RB::DisplayList::State::set_transition(RB::DisplayList::State *this, const RB::Transition *a2)
{
  if (*((unsigned char *)a2 + 12)) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = 0;
  }
  __n128 result = (atomic_uint *)*((void *)this + 11);
  if (result != (atomic_uint *)v3)
  {
    if (result && atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      __n128 result = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 8))(result);
      if (!v3) {
        goto LABEL_9;
      }
    }
    else if (!v3)
    {
LABEL_9:
      *((void *)this + 11) = v3;
      *((void *)this + 15) = 0;
      return result;
    }
    atomic_fetch_add_explicit((atomic_uint *volatile)v3 + 2, 1u, memory_order_relaxed);
    goto LABEL_9;
  }
  return result;
}

BOOL RB::DisplayList::State::set_numeric_value(uint64_t a1, float a2)
{
  BOOL v2 = *(float *)(a1 + 152) == a2;
  if (*(float *)(a1 + 152) != a2)
  {
    *(float *)(a1 + 152) = a2;
    *(void *)(a1 + 120) = 0;
  }
  return !v2;
}

uint64_t RB::DisplayList::State::set_text_run(RB::DisplayList::State *this, CFTypeRef cf, RB::DisplayList::Builder *a3)
{
  v23[1] = *MEMORY[0x263EF8340];
  if (!cf) {
    goto LABEL_17;
  }
  CFTypeRef v5 = cf;
  {
    RB::DisplayList::State::set_text_run(objc_object *,RB::DisplayList::Builder &)::run_type = CTRunGetTypeID();
  }
  {
    RB::DisplayList::State::set_text_run(objc_object *,RB::DisplayList::Builder &)::array_type = CFArrayGetTypeID();
  }
  CFTypeID v6 = CFGetTypeID(v5);
  if (v6 == RB::DisplayList::State::set_text_run(objc_object *,RB::DisplayList::Builder &)::run_type)
  {
    unsigned int v7 = 0;
LABEL_10:
    unsigned int v11 = -1;
    goto LABEL_11;
  }
  if (v6 != RB::DisplayList::State::set_text_run(objc_object *,RB::DisplayList::Builder &)::array_type
    || CFArrayGetCount((CFArrayRef)v5) != 3)
  {
    unsigned int v7 = 0;
    CFTypeRef v5 = 0;
    goto LABEL_10;
  }
  ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v5, 0);
  unint64_t v9 = (void *)CFArrayGetValueAtIndex((CFArrayRef)v5, 1);
  uint64_t v10 = (void *)CFArrayGetValueAtIndex((CFArrayRef)v5, 2);
  unsigned int v7 = [v9 unsignedIntValue];
  unsigned int v11 = [v10 unsignedIntValue];
  CFTypeRef v5 = ValueAtIndex;
LABEL_11:
  unint64_t GlyphCount = CTRunGetGlyphCount((CTRunRef)v5);
  if (GlyphCount > v7)
  {
    if (GlyphCount < v7 + v11) {
      unsigned int v11 = GlyphCount - v7;
    }
    if (v11)
    {
      uint64_t v14 = 4 * v11;
      size_t v15 = v14 + 4;
      if (v11 > 0x3FF)
      {
        int64x2_t v16 = malloc_type_malloc(v14 + 4, 0xA05E671EuLL);
        if (!v16)
        {
          int v19 = 1;
LABEL_32:
          free(v16);
          return this & (v19 ^ 1);
        }
      }
      else
      {
        MEMORY[0x270FA5388](GlyphCount, v13);
        int64x2_t v16 = (_DWORD *)((char *)v23 - ((v15 + 15) & 0xFFFFFFFF0));
        bzero(v16, v15);
      }
      RB::TextIdentity::TextIdentity((RB::TextIdentity *)v16, (CTRunRef)v5, v7, v11);
      long long v18 = (_DWORD *)*((void *)this + 20);
      if (v18 && RB::TextIdentity::operator==(v16, v18))
      {
        int v19 = 1;
      }
      else
      {
        float32x2_t v20 = (size_t *)*((void *)a3 + 1);
        long long v21 = (int *)((v20[4] + 3) & 0xFFFFFFFFFFFFFFFCLL);
        if ((unint64_t)v21 + v15 > v20[5]) {
          long long v21 = (int *)RB::Heap::alloc_slow(v20 + 2, v15, 3);
        }
        else {
          void v20[4] = (size_t)v21 + v15;
        }
        float32x2_t v22 = RB::TextIdentity::TextIdentity(v21, v16, 0, *v16 >> 2);
        int v19 = 0;
        if (*((int **)this + 20) == v22)
        {
          LODWORD(this) = 0;
        }
        else
        {
          *((void *)this + 20) = v22;
          *((void *)this + 15) = 0;
          LODWORD(this) = 1;
        }
      }
      if (v11 < 0x400) {
        return this & (v19 ^ 1);
      }
      goto LABEL_32;
    }
  }
LABEL_17:
  if (!*((void *)this + 20)) {
    return 0;
  }
  *((void *)this + 20) = 0;
  *((void *)this + 15) = 0;
  return 1;
}

void sub_2141B26B8(_Unwind_Exception *a1)
{
}

double RB::DisplayList::State::clip_bounds(RB::DisplayList::State *this)
{
  uint64_t v1 = *((void *)this + 12);
  if (v1) {
    return *(double *)(v1 + 16);
  }
  else {
    return -5.48612406e303;
  }
}

void RB::DisplayList::State::append(RB::DisplayList::State *this, RB::DisplayList::Builder *a2, const RB::DisplayList::ClipNode *a3, char a4)
{
  v16[14] = *MEMORY[0x263EF8340];
  if (a3)
  {
    long long v4 = a3;
    if (a4)
    {
      v10[0] = xmmword_2142181C0;
      v10[1] = xmmword_2142181D0;
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      RB::DisplayList::CachedTransform::CachedTransform((uint64_t)v13, (uint64_t)a2, v10, 0, 0, 0);
      do
      {
        for (uint64_t i = (*(uint64_t (**)(unint64_t, unsigned char *, void, uint64_t))(*(void *)(*((void *)v4 + 1) & 0xFFFFFFFFFFFFFFFELL)
                                                                                        + 24))(*((void *)v4 + 1) & 0xFFFFFFFFFFFFFFFELL, v13, 0, 1); i; uint64_t i = *(void *)i)
        {
          uint64_t v8 = *((void *)a2 + 1);
          uint64_t v9 = *(void *)(i + 8);
          *(void *)(v9 + 8) = *(void *)(v8 + 312);
          *(void *)(v8 + 312) = v9;
          *((void *)this + 12) = RB::Heap::emplace<RB::DisplayList::ClipNode,RB::DisplayList::Clip const*&,RB::DisplayList::ClipNode*&>((size_t *)(v8 + 16), (const RB::DisplayList::Clip **)(i + 8), (const RB::DisplayList::ClipNode **)this + 12);
        }
        long long v4 = *(const RB::DisplayList::ClipNode **)v4;
      }
      while (v4);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v16);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v15);
      RB::Heap::~Heap((RB::Heap *)&v14);
    }
    else
    {
      *((void *)this + 12) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, *((void **)this + 12), a3);
    }
    *((_DWORD *)this + 37) = -1;
  }
}

void sub_2141B287C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

__n128 RB::DisplayList::State::add_style(__n128 *this, RB::DisplayList::Builder *a2, RB::DisplayList::Style *a3)
{
  RB::DisplayList::State::copy_ctm(this, (RB::Heap *)(*((void *)a2 + 1) + 16));
  *((void *)a3 + 2) = v6;
  *((void *)a3 + 3) = 0;
  if (!*((unsigned char *)a2 + 272))
  {
    *((void *)a3 + 5) = RB::DisplayList::State::copy_metadata((RB::DisplayList::State *)this, *((RB::DisplayList::Contents **)a2 + 1));
    *((_DWORD *)a3 + 12) = this[4].n128_u32[0];
  }
  __n128 result = this[6];
  *(__n128 *)((char *)a3 + 24) = result;
  this[6].n128_u64[0] = 0;
  this[6].n128_u64[1] = (unint64_t)a3;
  this[9].n128_u32[1] = -1;
  uint64_t v8 = *((void *)a2 + 1);
  *((void *)a3 + 1) = *(void *)(v8 + 312);
  *(void *)(v8 + 312) = a3;
  return result;
}

_DWORD *RB::DisplayList::Metadata::Traits<(RB::DisplayList::Metadata::Type)1>::retain(_DWORD *result, uint64_t a2)
{
  if (result)
  {
    unint64_t v3 = (unint64_t)result;
    atomic_fetch_add_explicit(result + 2, 1u, memory_order_relaxed);
    long long v4 = *(_DWORD **)(a2 + 48);
    if (!v4)
    {
      RB::Heap::make_object_table((size_t *)(a2 + 16));
      long long v4 = *(_DWORD **)(a2 + 48);
    }
    return RB::ObjectTable::adopt(v4, v3);
  }
  return result;
}

void sub_2141B2C04(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_2141B2C90(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_2141B2CFC(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_2141B2DB4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

id __copy_helper_block_e8_32c29_ZTSN2RB8objc_ptrIP7RBLayerEE(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_e8_32c29_ZTSN2RB8objc_ptrIP7RBLayerEE(uint64_t a1)
{
}

void sub_2141B3298(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18, id a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

id __copy_helper_block_e8_40c40_ZTSN2RB8objc_ptrIP17RBImageQueueLayerEE48c30_ZTSN2RB8objc_ptrIP8RBDeviceEE(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = *(id *)(a2 + 40);
  id result = *(id *)(a2 + 48);
  *(void *)(a1 + 48) = result;
  return result;
}

void sub_2141B335C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_40c40_ZTSN2RB8objc_ptrIP17RBImageQueueLayerEE48c30_ZTSN2RB8objc_ptrIP8RBDeviceEE(uint64_t a1)
{
  BOOL v2 = *(void **)(a1 + 40);
}

id __copy_helper_block_e16_64c40_ZTSN2RB8objc_ptrIP17RBImageQueueLayerEE72c30_ZTSN2RB8objc_ptrIP8RBDeviceEE88c29_ZTSN2RB8objc_ptrIP7RBLayerEE96c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE112c36_ZTSN2RB8objc_ptrIP13RBDisplayListEE(void *a1, uint64_t a2)
{
  a1[8] = *(id *)(a2 + 64);
  a1[9] = *(id *)(a2 + 72);
  a1[11] = *(id *)(a2 + 88);
  uint64_t v4 = *(void *)(a2 + 96);
  if (v4) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
  }
  a1[12] = v4;
  id result = *(id *)(a2 + 112);
  a1[14] = result;
  return result;
}

void sub_2141B3418(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 96);
  if (v3) {
    __copy_helper_block_e8_48c58_ZTSN2RB8objc_ptrIPU21objcproto10MTLTexture11objc_objectEE56c66_ZTSN2RB8objc_ptrIPU29objcproto18RBDrawableDelegate11objc_objectEE64c30_ZTSN2RB8objc_ptrIP8RBDeviceEE72c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE120c55_ZTSN2RB8objc_ptrIPU18objcproto8MTLEvent11objc_objectEE_cold_1(v3);
  }

  _Unwind_Resume(a1);
}

void __destroy_helper_block_e16_64c40_ZTSN2RB8objc_ptrIP17RBImageQueueLayerEE72c30_ZTSN2RB8objc_ptrIP8RBDeviceEE88c29_ZTSN2RB8objc_ptrIP7RBLayerEE96c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE112c36_ZTSN2RB8objc_ptrIP13RBDisplayListEE(uint64_t a1)
{
  BOOL v2 = *(atomic_uint **)(a1 + 96);
  if (v2 && atomic_fetch_add_explicit(v2 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }

  uint64_t v3 = *(void **)(a1 + 64);
}

void sub_2141B3728(_Unwind_Exception *exception_object)
{
  if (atomic_fetch_add_explicit(v2 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
    if (!v1) {
      goto LABEL_5;
    }
  }
  else if (!v1)
  {
    goto LABEL_5;
  }
  if (atomic_fetch_add_explicit(v1 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v1 + 8))(v1);
  }
LABEL_5:
  _Unwind_Resume(exception_object);
}

void sub_2141B387C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2141B39F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  os_unfair_lock_unlock(v10);
  RB::vector<RB::objc_ptr<RBLayer *>,0ul,unsigned long>::~vector((uint64_t)&a10);
  _Unwind_Resume(a1);
}

uint64_t RB::vector<RB::objc_ptr<RBLayer *>,0ul,unsigned long>::~vector(uint64_t a1)
{
  BOOL v2 = *(id **)a1;
  if (*(void *)(a1 + 8))
  {
    unint64_t v3 = 0;
    do

    while (v3 < *(void *)(a1 + 8));
    BOOL v2 = *(id **)a1;
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

void sub_2141B3B4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2141B3C8C(_Unwind_Exception *exception_object)
{
  if (atomic_fetch_add_explicit((atomic_uint *volatile)(v1 + 8), 0xFFFFFFFF, memory_order_release) == 1) {
    -[RBLayer resetStatistics:alpha:]();
  }
  _Unwind_Resume(exception_object);
}

void sub_2141B3D90(_Unwind_Exception *exception_object)
{
  if (atomic_fetch_add_explicit(v1, 0xFFFFFFFF, memory_order_release) == 1) {
    -[RBLayer statistics]();
  }
  _Unwind_Resume(exception_object);
}

void sub_2141B3F20(_Unwind_Exception *exception_object)
{
  if (atomic_fetch_add_explicit((atomic_uint *volatile)(v1 + 8), 0xFFFFFFFF, memory_order_release) == 1) {
    -[RBLayer resetStatistics:alpha:]();
  }
  _Unwind_Resume(exception_object);
}

void sub_2141B3FF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2141B4628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, atomic_uint *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id a19, uint64_t a20,uint64_t a21,id a22,id a23,uint64_t a24,uint64_t a25,id a26)
{
  if (a12)
  {
    if (atomic_fetch_add_explicit(a12 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)a12 + 8))(a12);
    }
  }

  _Unwind_Resume(a1);
}

void sub_2141B4CB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,id a30,id a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,id a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
  _Block_object_dispose(&a43, 8);
  _Unwind_Resume(a1);
}

id __copy_helper_block_e8_32c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7CGImageEEE(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_e8_32c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7CGImageEEE(uint64_t a1)
{
}

uint64_t __Block_byref_object_copy__4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__4(uint64_t a1)
{
}

void sub_2141B50C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id a17)
{
  CFRelease(v18);
  if (v17) {
    CFRelease(v17);
  }
  _Unwind_Resume(a1);
}

CFTypeRef __copy_helper_block_e8_32c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7CGImageEEE40c27_ZTSN2RB6cf_ptrIP7CGImageEE(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = *(id *)(a2 + 32);
  CFTypeRef result = *(CFTypeRef *)(a2 + 40);
  if (result) {
    CFTypeRef result = CFRetain(result);
  }
  *(void *)(a1 + 40) = result;
  return result;
}

void sub_2141B515C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_32c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7CGImageEEE40c27_ZTSN2RB6cf_ptrIP7CGImageEE(uint64_t a1)
{
  BOOL v2 = *(const void **)(a1 + 40);
  if (v2) {
    CFRelease(v2);
  }
  unint64_t v3 = *(void **)(a1 + 32);
}

id __copy_helper_block_e8_64c61_ZTSN2RB8objc_ptrIPU28objcproto17OS_dispatch_queue8NSObjectEE72c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7CGImageEEE(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 64) = *(id *)(a2 + 64);
  id result = *(id *)(a2 + 72);
  *(void *)(a1 + 72) = result;
  return result;
}

void sub_2141B51EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_64c61_ZTSN2RB8objc_ptrIPU28objcproto17OS_dispatch_queue8NSObjectEE72c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7CGImageEEE(uint64_t a1)
{
  BOOL v2 = *(void **)(a1 + 64);
}

id __copy_helper_block_e16_48c30_ZTSN2RB8objc_ptrIP8RBDeviceEE72c61_ZTSN2RB8objc_ptrIPU28objcproto17OS_dispatch_queue8NSObjectEE80c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7CGImageEEE88c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE104c36_ZTSN2RB8objc_ptrIP13RBDisplayListEE(void *a1, uint64_t a2)
{
  a1[6] = *(id *)(a2 + 48);
  a1[9] = *(id *)(a2 + 72);
  a1[10] = *(id *)(a2 + 80);
  uint64_t v4 = *(void *)(a2 + 88);
  if (v4) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
  }
  a1[11] = v4;
  id result = *(id *)(a2 + 104);
  a1[13] = result;
  return result;
}

void sub_2141B52BC(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 88);
  if (v3) {
    __copy_helper_block_e8_48c58_ZTSN2RB8objc_ptrIPU21objcproto10MTLTexture11objc_objectEE56c66_ZTSN2RB8objc_ptrIPU29objcproto18RBDrawableDelegate11objc_objectEE64c30_ZTSN2RB8objc_ptrIP8RBDeviceEE72c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE120c55_ZTSN2RB8objc_ptrIPU18objcproto8MTLEvent11objc_objectEE_cold_1(v3);
  }

  _Unwind_Resume(a1);
}

void __destroy_helper_block_e16_48c30_ZTSN2RB8objc_ptrIP8RBDeviceEE72c61_ZTSN2RB8objc_ptrIPU28objcproto17OS_dispatch_queue8NSObjectEE80c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7CGImageEEE88c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE104c36_ZTSN2RB8objc_ptrIP13RBDisplayListEE(uint64_t a1)
{
  BOOL v2 = *(atomic_uint **)(a1 + 88);
  if (v2 && atomic_fetch_add_explicit(v2 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }

  uint64_t v3 = *(void **)(a1 + 48);
}

void sub_2141B5434(_Unwind_Exception *a1)
{
  *(unsigned char *)(v1 + *(int *)(v2 + 916)) = 0;
  _Unwind_Resume(a1);
}

void sub_2141B5648(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

atomic_uint *RB::Refcount<RB::SharedSurfaceClient,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::Refcount<RB::SharedSurfaceClient,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void RB::SharedSurfaceClient::~SharedSurfaceClient(RB::SharedSurfaceClient *this)
{
}

uint64_t _ZZZZ59__RBLayer_copyImageInRect_options_completionQueue_handler__EUb0_EUb1_EN3__18__invokeIPvPKvmEEDaT_T0_T1_(int a1, void *a2, size_t a3)
{
  return munmap(a2, a3);
}

uint64_t RB::DisplayList::Interpolator::Contents::intern_animation(uint64_t a1, unsigned int *a2, unint64_t a3)
{
  if (!a3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = a2;
  unsigned int v6 = RB::Animation::hash(a2, a3);
  unsigned int v7 = v6;
  uint64_t v8 = *(_DWORD **)(a1 + 80);
  unint64_t v9 = *(unsigned int *)(a1 + 88);
  uint64_t v10 = &v8[2 * v9];
  if (v9)
  {
    do
    {
      unint64_t v11 = v9 >> 1;
      uint64_t v12 = &v8[2 * (v9 >> 1)];
      unsigned int v14 = *v12;
      uint64_t v13 = v12 + 2;
      v9 += ~(v9 >> 1);
      if (v14 < v6) {
        uint64_t v8 = v13;
      }
      else {
        unint64_t v9 = v11;
      }
    }
    while (v9);
    if (v8 != v10)
    {
      uint64_t v10 = v8;
      while (*v10 == v7)
      {
        unsigned int v15 = v10[1];
        uint64_t v16 = *(void *)(a1 + 96);
        uint64_t v17 = *(unsigned int *)(v16 + 40 * v15);
        if (v17)
        {
          uint64_t v18 = 0;
          int v19 = (unsigned int *)(v16 + 40 * v15 + 8);
          do
          {
            unsigned int v20 = *v19;
            v19 += 10;
            v18 += v20;
            --v17;
          }
          while (v17);
        }
        else
        {
          uint64_t v18 = 0;
        }
        if (RB::Animation::equal(v4, a3, (_DWORD *)(*(void *)(a1 + 112) + 4 * *(unsigned int *)(v16 + 40 * v15 + 4)), v18))
        {
          return (v10[1] + 1);
        }
        v10 += 2;
        if (v10 == (_DWORD *)(*(void *)(a1 + 80) + 8 * *(unsigned int *)(a1 + 88))) {
          break;
        }
      }
    }
  }
  short float v44 = v10;
  unsigned int v45 = v7;
  unint64_t v21 = 0;
  int v22 = 0;
  unsigned int v43 = *(_DWORD *)(a1 + 104);
  int32x2_t v46 = (void *)(a1 + 112);
  do
  {
    BOOL v23 = v4;
    uint64_t v24 = (uint64_t)&v4[v21];
    unint64_t v25 = RB::Animation::size(v24, a3 - v21);
    uint64_t v26 = *(unsigned int *)(a1 + 120);
    unsigned int v27 = v26 + v25;
    if (v26 < (int)v26 + (int)v25 && *(_DWORD *)(a1 + 124) < v27) {
      RB::vector<RB::Animation::TermOrArg,0ul,unsigned int>::reserve_slow((uint64_t)v46, v27);
    }
    *(_DWORD *)(a1 + 120) = v27;
    if (v25)
    {
      unsigned __int32 v28 = (_DWORD *)(*v46 + 4 * v26);
      uint64_t v29 = 4 * v25;
      int32x2_t v30 = (int *)v24;
      do
      {
        int v31 = *v30++;
        *v28++ = v31;
        v29 -= 4;
      }
      while (v29);
    }
    unsigned int v32 = *(_DWORD *)(a1 + 104);
    if (*(_DWORD *)(a1 + 108) < v32 + 1)
    {
      RB::vector<RB::DisplayList::Interpolator::Contents::AnimationTableItem,0ul,unsigned int>::reserve_slow(a1 + 96, v32 + 1);
      unsigned int v32 = *(_DWORD *)(a1 + 104);
    }
    uint64_t v33 = *(void *)(a1 + 96) + 40 * v32;
    *(void *)(v33 + 32) = 0;
    *(_OWORD *)uint64_t v33 = 0u;
    *(_OWORD *)(v33 + 16) = 0u;
    LODWORD(v33) = *(_DWORD *)(a1 + 104);
    *(_DWORD *)(a1 + 104) = v33 + 1;
    float32x2_t v34 = (_DWORD *)(*(void *)(a1 + 96) + 40 * v33);
    *float32x2_t v34 = 1;
    v34[1] = v26;
    v34[2] = v25;
    float v35 = RB::Animation::active_duration(v24, v25);
    uint64_t v36 = *(void *)(a1 + 96) + 40 * (*(_DWORD *)(a1 + 104) - 1);
    *(float *)(v36 + 12) = v35;
    RB::Animation::prepare(v24, v25, v36 + 16);
    unint64_t v21 = (v25 + v21);
    ++v22;
    uint64_t v4 = v23;
  }
  while (v21 < a3);
  *(_DWORD *)(*(void *)(a1 + 96) + 40 * v43) = v22;
  uint64_t v37 = *(void *)(a1 + 80);
  unint64_t v38 = ((uint64_t)v44 - v37) >> 3;
  unsigned int v39 = *(_DWORD *)(a1 + 88);
  if (*(_DWORD *)(a1 + 92) < v39 + 1)
  {
    RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::reserve_slow(a1 + 80, v39 + 1);
    uint64_t v37 = *(void *)(a1 + 80);
    unsigned int v39 = *(_DWORD *)(a1 + 88);
  }
  BOOL v40 = v39 > v38;
  unint64_t v41 = v39 - v38;
  if (v40) {
    memmove((void *)(v37 + 8 * v38 + 8), (const void *)(v37 + 8 * v38), 8 * v41);
  }
  *(void *)(v37 + 8 * v38) = v45 | ((unint64_t)v43 << 32);
  ++*(_DWORD *)(a1 + 88);
  return v43 + 1;
}

uint64_t RB::DisplayList::Interpolator::Contents::intern_animation(RB::DisplayList::Interpolator::Contents *this, const RB::Animation *a2)
{
  uint64_t v2 = (unsigned int *)*((void *)a2 + 3);
  if (!v2) {
    uint64_t v2 = (unsigned int *)a2;
  }
  return RB::DisplayList::Interpolator::Contents::intern_animation((uint64_t)this, v2, *((unsigned int *)a2 + 8));
}

uint64_t RB::DisplayList::Interpolator::Contents::intern_animation(RB::DisplayList::Interpolator::Contents *this, const RB::Animation *a2, const RB::Animation *a3)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (a2)
  {
    uint64_t v4 = a2;
    if (!*((_DWORD *)a2 + 8)) {
      return 0xFFFFFFFFLL;
    }
    BOOL v5 = a3 != 0;
    if (!a3)
    {
LABEL_46:
      if (v4)
      {
        if (*((void *)v4 + 3)) {
          uint64_t v33 = (unsigned int *)*((void *)v4 + 3);
        }
        else {
          uint64_t v33 = (unsigned int *)v4;
        }
        unint64_t v34 = *((unsigned int *)v4 + 8);
LABEL_63:
        return RB::DisplayList::Interpolator::Contents::intern_animation((uint64_t)this, v33, v34);
      }
      if (v5)
      {
        if (*((void *)a3 + 3)) {
          uint64_t v33 = (unsigned int *)*((void *)a3 + 3);
        }
        else {
          uint64_t v33 = (unsigned int *)a3;
        }
        unint64_t v34 = *((unsigned int *)a3 + 8);
        goto LABEL_63;
      }
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    if (!a3) {
      return *((unsigned int *)this + 4);
    }
    uint64_t v4 = (const RB::Animation *)*((void *)this + 1);
    BOOL v5 = 1;
  }
  if (!v4) {
    goto LABEL_46;
  }
  long long v42 = 0u;
  unint64_t v43 = 128;
  unint64_t v6 = *((unsigned int *)a3 + 8);
  if (!v6)
  {
    unint64_t v35 = 0;
    uint64_t v36 = 0;
    goto LABEL_53;
  }
  BOOL v40 = this;
  unint64_t v7 = 0;
  do
  {
    if (!*((_DWORD *)v4 + 8)) {
      goto LABEL_30;
    }
    unsigned int v8 = 0;
    do
    {
      unint64_t v9 = (const RB::Animation *)*((void *)v4 + 3);
      if (!v9) {
        unint64_t v9 = v4;
      }
      uint64_t v10 = (unsigned int *)((char *)v9 + 4 * v8);
      uint64_t v11 = *v10;
      if ((unint64_t)(v11 - 11) >= 2)
      {
        if (v11 != 13) {
          break;
        }
      }
      else
      {
        uint64_t v12 = RB::Animation::_term_args[v11];
        uint64_t v13 = *((void *)&v42 + 1);
        unint64_t v14 = v12 + *((void *)&v42 + 1) + 1;
        if (*((void *)&v42 + 1) < v14 && v43 < v14) {
          RB::vector<RB::Animation::TermOrArg,128ul,unsigned long>::reserve_slow(__dst, v12 + *((void *)&v42 + 1) + 1);
        }
        *((void *)&v42 + 1) = v14;
        uint64_t v16 = (unsigned char *)v42;
        if (!(void)v42) {
          uint64_t v16 = __dst;
        }
        uint64_t v17 = &v16[4 * v13];
        uint64_t v18 = 4 * v12 + 4;
        int v19 = (int *)v10;
        do
        {
          int v20 = *v19++;
          *v17++ = v20;
          v18 -= 4;
        }
        while (v18);
        uint64_t v11 = *v10;
        if (v11 == 18)
        {
          int v21 = 2 * v10[1] + 2;
          goto LABEL_28;
        }
      }
      int v21 = RB::Animation::_term_args[v11];
LABEL_28:
      v8 += v21 + 1;
    }
    while (v8 < *((_DWORD *)v4 + 8));
    unint64_t v6 = *((unsigned int *)a3 + 8);
LABEL_30:
    int v22 = (const RB::Animation *)*((void *)a3 + 3);
    if (!v22) {
      int v22 = a3;
    }
    unint64_t v23 = RB::Animation::size((uint64_t)v22 + 4 * v7, v6 - v7);
    uint64_t v24 = *((void *)&v42 + 1);
    size_t v25 = *((void *)&v42 + 1) + v23;
    if (*((void *)&v42 + 1) < *((void *)&v42 + 1) + v23 && v43 < v25) {
      RB::vector<RB::Animation::TermOrArg,128ul,unsigned long>::reserve_slow(__dst, v25);
    }
    *((void *)&v42 + 1) = v25;
    unsigned int v27 = (const RB::Animation *)*((void *)a3 + 3);
    if (!v27) {
      unsigned int v27 = a3;
    }
    if (v23)
    {
      unsigned __int32 v28 = (int *)((char *)v27 + 4 * v7);
      uint64_t v29 = (unsigned char *)v42;
      if (!(void)v42) {
        uint64_t v29 = __dst;
      }
      int32x2_t v30 = &v29[4 * v24];
      uint64_t v31 = 4 * v23;
      do
      {
        int v32 = *v28++;
        *v30++ = v32;
        v31 -= 4;
      }
      while (v31);
    }
    v7 += v23;
    unint64_t v6 = *((unsigned int *)a3 + 8);
  }
  while (v7 < v6);
  unint64_t v35 = *((void *)&v42 + 1);
  uint64_t v36 = (unsigned int *)v42;
  this = v40;
LABEL_53:
  if (v36) {
    unint64_t v38 = v36;
  }
  else {
    unint64_t v38 = (unsigned int *)__dst;
  }
  uint64_t v37 = RB::DisplayList::Interpolator::Contents::intern_animation((uint64_t)this, v38, v35);
  if ((void)v42) {
    free((void *)v42);
  }
  return v37;
}

void sub_2141B6034(_Unwind_Exception *a1)
{
  if (STACK[0x208]) {
    free((void *)STACK[0x208]);
  }
  _Unwind_Resume(a1);
}

float RB::DisplayList::Interpolator::Contents::animation_max_duration(RB::DisplayList::Interpolator::Contents *this, unsigned int a2)
{
  if (!a2) {
    return 1.0;
  }
  float result = 0.0;
  if (a2 <= 0xFFFFFFFD)
  {
    uint64_t v3 = *((void *)this + 12);
    uint64_t v4 = *(unsigned int *)(v3 + 40 * (a2 - 1));
    if (v4)
    {
      BOOL v5 = (float *)(v3 + 40 * (a2 - 1) + 12);
      do
      {
        float v6 = *v5;
        v5 += 10;
        float v7 = v6;
        if (result < v6) {
          float result = v7;
        }
        --v4;
      }
      while (v4);
    }
  }
  return result;
}

void RB::DisplayList::Interpolator::Contents::animation_time(RB::DisplayList::Interpolator::Contents *this, int a2, unsigned int a3, double a4, double a5)
{
  if (a2 != -2 && a2 && a2 != -1)
  {
    BOOL v5 = (_DWORD *)(*((void *)this + 12) + 40 * (a2 - 1));
    unsigned int v6 = *v5 - 1;
    if (v6 >= a3) {
      unsigned int v6 = a3;
    }
    RB::Animation::eval(*((void *)this + 14) + 4 * v5[10 * v6 + 1], v5[10 * v6 + 2], (int32x2_t *)&v5[10 * v6 + 4], a4, a5);
  }
}

float RB::DisplayList::Interpolator::Contents::max_animation_speed(RB::DisplayList::Interpolator::Contents *this, double a2, double a3)
{
  uint64_t v3 = *((unsigned int *)this + 26);
  if (!v3) {
    return 0.0;
  }
  int v4 = LODWORD(a2);
  uint64_t v6 = 40 * v3;
  float v7 = (int32x2_t *)(*((void *)this + 12) + 16);
  float v8 = 0.0;
  do
  {
    LODWORD(a2) = v4;
    RB::Animation::speed(*((void *)this + 14) + 4 * v7[-2].u32[1], v7[-1].u32[0], v7, a2, a3);
    if (v8 < *(float *)&a2) {
      float v8 = *(float *)&a2;
    }
    v7 += 5;
    v6 -= 40;
  }
  while (v6);
  return v8;
}

unint64_t *RB::DisplayList::Interpolator::Op::set_type(unint64_t *result, unsigned __int8 a2)
{
  if (a2 < 4u)
  {
    if (a2 == 3)
    {
      unint64_t v2 = *result & 0xFFFFFFFFFFFFFFF0 | 4;
    }
    else
    {
      unint64_t v3 = *result & 0xFFFFFFFFFFFFFFF0;
      unint64_t v2 = v3 | 2;
      uint64_t v4 = v3 | 3;
      if (a2 >= 2u) {
        unint64_t v2 = v4;
      }
    }
  }
  else
  {
    unint64_t v2 = *result & 0xFFFFFFFFFFFFFFF0 | 5;
  }
  atomic_uint *result = v2;
  return result;
}

unint64_t *RB::DisplayList::Interpolator::Op::set_type(unint64_t *result, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  unsigned int v4 = a2;
  if (a3 < a2) {
    unsigned int v4 = a3;
  }
  if (a4 >= v4) {
    unsigned int v5 = v4;
  }
  else {
    unsigned int v5 = a4;
  }
  if (v5)
  {
    if (v5 < 4)
    {
      unint64_t v7 = *result & 0xFFFFFFFFFFFFFFF0;
      BOOL v8 = v4 >= 2;
      unint64_t v6 = v7 | 2;
      uint64_t v9 = v7 | 3;
      if (v8) {
        unint64_t v6 = v9;
      }
    }
    else
    {
      unint64_t v6 = *result & 0xFFFFFFFFFFFFFFF0 | 5;
    }
  }
  else
  {
    if (!v4) {
      return result;
    }
    if (v4 == 1) {
      unint64_t v6 = *result & 0xFFFFFFFFFFFFFFF0 | 6;
    }
    else {
      unint64_t v6 = *result & 0xFFFFFFFFFFFFFFF0 | 7;
    }
  }
  atomic_uint *result = v6;
  return result;
}

uint64_t RB::DisplayList::Interpolator::Op::get_type(RB::DisplayList::Interpolator::Op *this)
{
  if ((*(void *)this & 8) != 0) {
    return 0;
  }
  else {
    return (0x201040302010000uLL >> (8 * (*(unsigned char *)this & 0xFu)));
  }
}

const RB::Transition *RB::DisplayList::Interpolator::Layer::item_transition(RB::DisplayList::Interpolator::Layer *this, const RB::Transition *a2)
{
  if (!a2 || *((unsigned char *)a2 + 13) && !*(unsigned char *)(**(void **)this + 13)) {
    return **(const RB::Transition ***)this;
  }
  return a2;
}

void RB::DisplayList::Interpolator::Layer::print(RB::DisplayList::Interpolator::Layer *this, std::string *a2)
{
  if (*((unsigned char *)this + 248))
  {
    if (*((unsigned char *)this + 250)) {
      RB::SexpString::print(a2, 0, "#:non-fade");
    }
    if (*((unsigned char *)this + 251)) {
      RB::SexpString::print(a2, 0, "#:has-animations");
    }
    RB::SexpString::printf(a2, 0, "#:active-duration %g", *((float *)this + 2));
    unsigned int v4 = (char *)this + 16;
    if (*((void *)this + 22)) {
      unsigned int v4 = (char *)*((void *)this + 22);
    }
    uint64_t v5 = *((unsigned int *)this + 46);
    if (v5)
    {
      unint64_t v6 = v4 + 20;
      uint64_t v7 = 40 * v5;
      unsigned int v8 = -1;
      do
      {
        uint64_t v9 = *(void *)(v6 - 20);
        if (v8 != v9 >> 4)
        {
          if ((v8 & 0x80000000) == 0) {
            RB::SexpString::pop(a2);
          }
          RB::SexpString::push(a2, "group");
          RB::SexpString::printf(a2, 0, "#:id %u", *((_DWORD *)v6 - 5) >> 4);
          uint64_t v9 = *(void *)(v6 - 20);
          unsigned int v8 = v9 >> 4;
        }
        RB::SexpString::push(a2, RB::DisplayList::Interpolator::Layer::print(RB::SexpString &)const::types[v9 & 0xF]);
        switch(*((_DWORD *)v6 - 5) & 0xF)
        {
          case 0:
            RB::SexpString::printf(a2, 0, "#:count %u #:from (%u . %u)");
            break;
          case 1:
          case 8:
            RB::SexpString::printf(a2, 0, "#:count %u #:to (%u . %u)");
            break;
          case 9:
            RB::SexpString::printf(a2, 0, "#:from %u #:from-count %u #:to %u #:to-count %u");
            break;
          default:
            RB::SexpString::printf(a2, 0, "#:count %u #:from (%u . %u) #:to (%u . %u)");
            break;
        }
        if (*((_DWORD *)v6 + 3)) {
          RB::SexpString::printf(a2, 0, "#:animation %d", *((_DWORD *)v6 + 3));
        }
        float v10 = *((float *)v6 + 4);
        if (v10 != 0.0) {
          RB::SexpString::printf(a2, 0, "#:begin %g", v10);
        }
        if (*(void *)(v6 + 4) != 0x100000000) {
          RB::SexpString::printf(a2, 0, "#:rects (%u . %u)", *((_DWORD *)v6 + 1), *((_DWORD *)v6 + 2));
        }
        if ((*(v6 - 16) & 8) != 0) {
          RB::SexpString::print(a2, 0, "#:value-inverted");
        }
        RB::SexpString::pop(a2);
        v6 += 40;
        v7 -= 40;
      }
      while (v7);
      if ((v8 & 0x80000000) == 0) {
        RB::SexpString::pop(a2);
      }
    }
    if (*((_DWORD *)this + 60))
    {
      RB::SexpString::push(a2, "rects");
      uint64_t v11 = *((unsigned int *)this + 60);
      if (v11)
      {
        uint64_t v12 = 0;
        int v13 = 0;
        uint64_t v14 = 16 * v11;
        do
        {
          unsigned int v15 = (char *)*((void *)this + 29);
          if (!v15) {
            unsigned int v15 = (char *)this + 200;
          }
          RB::SexpString::printf(a2, 1, "#:%u [%g %g; %g %g]",
            v13++,
            COERCE_FLOAT(*(void *)&v15[v12]),
            COERCE_FLOAT(HIDWORD(*(void *)&v15[v12])),
            COERCE_FLOAT(*(void *)&v15[v12 + 8]),
            COERCE_FLOAT(HIDWORD(*(void *)&v15[v12 + 8])));
          v12 += 16;
        }
        while (v14 != v12);
      }
      RB::SexpString::pop(a2);
    }
  }
  else
  {
    RB::SexpString::print(a2, 0, "#:invalid");
  }
}

double RB::DisplayList::Interpolator::Layer::clear(RB::DisplayList::Interpolator::Layer *this)
{
  *((_DWORD *)this + 46) = 0;
  *((_DWORD *)this + 48) = 0;
  *((_DWORD *)this + 60) = 0;
  *(void *)&double result = 0x100000001;
  *((_DWORD *)this + 62) = 1;
  *((_DWORD *)this + 2) = 0;
  return result;
}

uint64_t RB::DisplayList::Interpolator::Layer::failed(uint64_t this)
{
  *(_DWORD *)(this + 184) = 0;
  *(_DWORD *)(this + 192) = 0;
  if (*(_DWORD *)(this + 240) >= 3u) {
    *(_DWORD *)(this + 240) = 2;
  }
  *(unsigned char *)(this + 249) = 0;
  unsigned int v1 = *(_DWORD *)(*(void *)this + 16);
  if (v1)
  {
    float v2 = 0.0;
    if (v1 <= 0xFFFFFFFD) {
      float v2 = *(float *)(*(void *)(*(void *)this + 96) + 40 * (v1 - 1) + 12);
    }
  }
  else
  {
    float v2 = 1.0;
  }
  *(float *)(this + 8) = v2;
  *(unsigned char *)(this + 248) = 0;
  return this;
}

BOOL RB::DisplayList::Interpolator::Layer::is_fade(RB::DisplayList::Interpolator::Layer *this)
{
  if (*((unsigned char *)this + 250)) {
    return 0;
  }
  if (!*((unsigned char *)this + 248) || !*((_DWORD *)this + 46)) {
    return 1;
  }
  if ((*((_DWORD *)this + 48) & 0xDC) != 0) {
    return 0;
  }
  return (*((_DWORD *)this + 48) & 0x20) == 0;
}

uint64_t RB::DisplayList::Interpolator::Layer::merge_tail(uint64_t this)
{
  unsigned int v1 = *(_DWORD *)(this + 184);
  unsigned int v2 = v1 - 2;
  if (v1 >= 2)
  {
    uint64_t v3 = *(void *)(this + 176) ? *(void *)(this + 176) : this + 16;
    unsigned int v4 = (unint64_t *)(v3 + 40 * v2);
    unsigned int v5 = v1 - 1;
    unint64_t v6 = *v4;
    uint64_t v7 = *(void *)(v3 + 40 * v5);
    if (((v7 ^ *v4) & 0xFLL) == 0
      && *(_DWORD *)(v3 + 40 * v2 + 24) == *(_DWORD *)(v3 + 40 * v5 + 24)
      && *(_DWORD *)(v3 + 40 * v2 + 28) == *(_DWORD *)(v3 + 40 * v5 + 28)
      && *(_DWORD *)(v3 + 40 * v2 + 32) == *(_DWORD *)(v3 + 40 * v5 + 32)
      && *(float *)(v3 + 40 * v2 + 36) == *(float *)(v3 + 40 * v5 + 36))
    {
      BOOL v8 = (v7 & 0xF) == 1 || (v7 & 0xF) == 8;
      if ((v8
         || *(_DWORD *)(v3 + 40 * v5 + 8) == *(_DWORD *)(v3 + 40 * v2 + 8)
         && *(_DWORD *)(v3 + 40 * v5 + 12) == *(_DWORD *)(v3 + 40 * v2 + 12) + (v6 >> 36))
        && ((v7 & 0xF) == 0
         || *(_DWORD *)(v3 + 40 * v5 + 16) == *(_DWORD *)(v3 + 40 * v2 + 16)
         && *(_DWORD *)(v3 + 40 * v5 + 20) == *(_DWORD *)(v3 + 40 * v2 + 20) + (v6 >> 36)))
      {
        unint64_t *v4 = ((v6 & 0xFFFFFFF000000000) + v7) & 0xFFFFFFF000000000 | v6 & 0xFFFFFFFFFLL;
        --*(_DWORD *)(this + 184);
      }
    }
  }
  return this;
}

float RB::DisplayList::Interpolator::State::effect_time(RB::DisplayList::Interpolator::State *this, const RB::Transition *a2, const Effect *a3, char a4, double a5, double a6, double a7, float a8)
{
  float result = *((float *)this + 4);
  __int16 v13 = *(_WORD *)a3;
  if ((*(_WORD *)a3 & 0x80) != 0)
  {
    p_begin_or_insert_animation = &a3->begin_or_insert_animation;
    if ((a4 & 1) == 0) {
      p_begin_or_insert_animation = &a3->dur_or_remove_animation;
    }
    unsigned int v15 = *p_begin_or_insert_animation;
    if (*p_begin_or_insert_animation)
    {
      if (*((unsigned __int8 *)this + 29) != v15
        || (float result = *((float *)this + 6), (LODWORD(result) & 0x7FFFFFFFu) >= 0x7F800000))
      {
        *((unsigned char *)this + 29) = v15;
        uint64_t v16 = *((void *)this + 1);
        LODWORD(a6) = *(_DWORD *)(v16 + 36);
        *(float *)&a5 = *((float *)this + 5) - *(float *)&a6;
        RB::DisplayList::Interpolator::Contents::animation_time(*(RB::DisplayList::Interpolator::Contents **)this, *(_DWORD *)(v16 + 32), v15, a5, a6);
        *((float *)this + 6) = result;
        if (*((unsigned char *)this + 28))
        {
          float result = 1.0 - result;
          *((float *)this + 6) = result;
        }
      }
      __int16 v13 = *(_WORD *)a3;
    }
  }
  float v17 = 1.0 - result;
  if ((a4 & 1) == 0) {
    float result = 1.0 - result;
  }
  if ((v13 & 0x80) == 0)
  {
    LOBYTE(v17) = a3->dur_or_remove_animation;
    float v18 = (float)LODWORD(v17) * 0.0039216;
    if (v18 == 0.0)
    {
      if ((*(unsigned char *)(*((void *)this + 1) + 4) & 2) != 0)
      {
        LOBYTE(v18) = *((unsigned char *)a2 + 14);
        float v23 = (float)LODWORD(v18) * 0.0039216;
        if (v23 != 0.0)
        {
          float v24 = v23;
          float32x2_t v25 = vrecpe_f32((float32x2_t)LODWORD(v23));
          float32x2_t v26 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v24), v25), v25);
          return vmlas_n_f32(1.0, result - 1.0, vmul_f32(v26, vrecps_f32((float32x2_t)LODWORD(v24), v26)).f32[0]);
        }
      }
    }
    else
    {
      LOBYTE(a8) = a3->begin_or_insert_animation;
      float v19 = (float)LODWORD(a8) * 0.0039216;
      float32x2_t v20 = vrecpe_f32((float32x2_t)LODWORD(v18));
      float32x2_t v21 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v18), v20), v20);
      float result = (float)(result - v19) * vmul_f32(v21, vrecps_f32((float32x2_t)LODWORD(v18), v21)).f32[0];
      if (result < 0.0 && v19 > 0.0) {
        float result = 0.0;
      }
      if ((float)(v19 + v18) < 1.0 && result > 1.0) {
        return 1.0;
      }
    }
  }
  return result;
}

void *RB::vector<RB::Animation::TermOrArg,128ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 66) + (*((void *)__dst + 66) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 66) + (*((void *)__dst + 66) >> 1);
  }
  float result = RB::details::realloc_vector<unsigned long,4ul>(*((void **)__dst + 64), __dst, 0x80uLL, (size_t *)__dst + 66, v3);
  *((void *)__dst + 64) = result;
  return result;
}

double *CG::intersection@<X0>(double *result@<X0>, double *a2@<X1>, uint64_t a3@<X8>)
{
  double v3 = a2[2];
  double v4 = a2[3];
  double v6 = result[2];
  double v5 = result[3];
  double v7 = -(v6 * v4 - v5 * v3);
  if (fabs(v7) >= 0.0001)
  {
    double v9 = result[1];
    double v10 = ((*result - *a2) * v4 + (a2[1] - v9) * v3) / v7;
    *(double *)(a3 + 8) = *result + v10 * v6;
    *(double *)(a3 + 16) = v9 + v10 * v5;
    char v8 = 1;
  }
  else
  {
    char v8 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
  *(unsigned char *)a3 = v8;
  return result;
}

uint64_t *RB::DisplayList::Metadata::identity_ns(uint64_t *this)
{
  if (this)
  {
    while (1)
    {
      uint64_t v1 = *this;
      if ((*this & 7) == 0) {
        break;
      }
      this = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFF8);
      if ((v1 & 0xFFFFFFFFFFFFFFF8) == 0) {
        return this;
      }
    }
    return (uint64_t *)this[1];
  }
  return this;
}

uint64_t *RB::DisplayList::Metadata::transition(uint64_t *this)
{
  if (this)
  {
    while (1)
    {
      uint64_t v1 = *this;
      if ((*this & 7) == 1) {
        break;
      }
      this = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFF8);
      if ((v1 & 0xFFFFFFFFFFFFFFF8) == 0) {
        return this;
      }
    }
    return (uint64_t *)this[1];
  }
  return this;
}

uint64_t *RB::DisplayList::Metadata::numeric_value(uint64_t *this)
{
  if (this)
  {
    while (1)
    {
      uint64_t v1 = *this;
      if ((*this & 7) == 2) {
        break;
      }
      this = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFF8);
      if ((v1 & 0xFFFFFFFFFFFFFFF8) == 0) {
        return this;
      }
    }
    ++this;
  }
  return this;
}

uint64_t *RB::DisplayList::Metadata::text_identity(uint64_t *this)
{
  if (this)
  {
    while (1)
    {
      uint64_t v1 = *this;
      if ((*this & 7) == 3) {
        break;
      }
      this = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFF8);
      if ((v1 & 0xFFFFFFFFFFFFFFF8) == 0) {
        return this;
      }
    }
    return (uint64_t *)this[1];
  }
  return this;
}

uint64_t *RB::DisplayList::Metadata::animation_layer(uint64_t *this)
{
  if (this)
  {
    while (1)
    {
      uint64_t v1 = *this;
      if ((*this & 7) == 4) {
        break;
      }
      this = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFF8);
      if ((v1 & 0xFFFFFFFFFFFFFFF8) == 0) {
        return this;
      }
    }
    ++this;
  }
  return this;
}

int *RB::DisplayList::Metadata::Traits<(RB::DisplayList::Metadata::Type)3>::retain(int *result, size_t *a2)
{
  unsigned int v2 = *(_DWORD **)result;
  if (*(void *)result)
  {
    double v3 = result;
    uint64_t v4 = (*v2 & 0xFFFFFFFC) + 4;
    double v5 = (int *)((a2[4] + 3) & 0xFFFFFFFFFFFFFFFCLL);
    if ((unint64_t)v5 + v4 > a2[5]) {
      double v5 = (int *)RB::Heap::alloc_slow(a2 + 2, (*v2 & 0xFFFFFFFC) + 4, 3);
    }
    else {
      a2[4] = (size_t)v5 + v4;
    }
    float result = RB::TextIdentity::TextIdentity(v5, v2, 0, *v2 >> 2);
    *double v3 = result;
  }
  return result;
}

Class screen_init(void *a1)
{
  Class result = NSClassFromString(&cfstr_Uiview.isa);
  uiview_cls = (uint64_t)result;
  return result;
}

uint64_t anonymous namespace'::AnimationTimer::shared(_anonymous_namespace_::AnimationTimer *this)
{
  {
    operator new();
  }
}

void sub_2141B6E4C(_Unwind_Exception *a1)
{
}

void anonymous namespace'::AnimationTimer::set_handler(uint64_t a1, void *a2, void *a3, double a4, float a5)
{
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  uint64_t v10 = *(void *)(a1 + 272);
  if (v10)
  {
    uint64_t v11 = -v10;
    uint64_t v12 = 32 * v10;
    do
    {
      if (*(void *)(a1 + 264)) {
        uint64_t v13 = *(void *)(a1 + 264);
      }
      else {
        uint64_t v13 = a1 + 8;
      }
      if (*(void **)(v13 + v12 - 16) == a3)
      {

        uint64_t v14 = *(void *)(a1 + 272);
        *(void *)(a1 + 272) = v14 - 1;
        if (v10 != v14) {
          memmove((void *)(v13 + v12 - 32), (const void *)(v13 + v12), 32 * (v11 + v14));
        }
      }
      v12 -= 32;
      --v10;
    }
    while (!__CFADD__(v11++, 1));
  }
  if ((*(void *)&a4 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
LABEL_37:
    os_unfair_lock_unlock((os_unfair_lock_t)a1);
    unsigned int v27 = 0;
    goto LABEL_45;
  }
  uint64_t v16 = *(void *)(a1 + 272);
  if (*(void *)(a1 + 280) < (unint64_t)(v16 + 1))
  {
    uint64_t v16 = *(void *)(a1 + 272);
  }
  uint64_t v17 = *(void *)(a1 + 264);
  if (!v17) {
    uint64_t v17 = a1 + 8;
  }
  float v18 = (_OWORD *)(v17 + 32 * v16);
  *float v18 = 0u;
  v18[1] = 0u;
  uint64_t v20 = *(void *)(a1 + 264);
  uint64_t v19 = *(void *)(a1 + 272);
  *(void *)(a1 + 272) = v19 + 1;
  if (!v20) {
    uint64_t v20 = a1 + 8;
  }
  uint64_t v21 = v20 + 32 * v19;
  *(void *)uint64_t v21 = a2;
  *(double *)(v21 + 8) = a4;
  int v22 = *(void **)(v21 + 16);
  if (v22 != a3)
  {

    *(void *)(v21 + 16) = a3;
  }
  *(float *)(v21 + 24) = a5;
  uint64_t v24 = *(void *)(a1 + 320);
  uint64_t v23 = *(void *)(a1 + 328);
  if (!v24) {
    uint64_t v24 = a1 + 288;
  }
  if (v23)
  {
    uint64_t v25 = 16 * v23;
    float32x2_t v26 = (void **)(v24 + 8);
    while (!*(v26 - 1) || *v26 != a2)
    {
      v26 += 2;
      v25 -= 16;
      if (!v25) {
        goto LABEL_27;
      }
    }
    goto LABEL_37;
  }
LABEL_27:
  unsigned int v27 = -[RBAnimationThread initWithScreen:]([RBAnimationThread alloc], a2);

  if (v27)
  {
    uint64_t v28 = *(void *)(a1 + 328);
    if (*(void *)(a1 + 336) < (unint64_t)(v28 + 1))
    {
      uint64_t v28 = *(void *)(a1 + 328);
    }
    uint64_t v29 = *(void *)(a1 + 320);
    if (!v29) {
      uint64_t v29 = a1 + 288;
    }
    int32x2_t v30 = (void *)(v29 + 16 * v28);
    *int32x2_t v30 = 0;
    v30[1] = 0;
    uint64_t v32 = *(void *)(a1 + 320);
    uint64_t v31 = *(void *)(a1 + 328);
    *(void *)(a1 + 328) = v31 + 1;
    if (!v32) {
      uint64_t v32 = a1 + 288;
    }
    uint64_t v33 = v32 + 16 * v31;
    if (*(void **)v33 != v27)
    {

      *(void *)uint64_t v33 = v27;
    }
    *(void *)(v33 + 8) = a2;
  }
  else if (*(double *)(a1 + 344) - a4 >= 0.0166666667)
  {
    *(double *)(a1 + 344) = a4;
    double v34 = a4 - CACurrentMediaTime();
    double v35 = v34 * 1000000000.0;
    BOOL v36 = v34 <= 0.0166666667;
    double v37 = 16666666.7;
    if (v36) {
      double v37 = v35;
    }
    dispatch_time_t v38 = dispatch_time(0, (uint64_t)v37);
    {
      unsigned int v39 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  -[RBAnimationThread startThread]((uint64_t)v27);
LABEL_45:
}

void sub_2141B71A8(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);

  _Unwind_Resume(a1);
}

void sub_2141B76D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, os_unfair_lock_t lock, char a10)
{
  if (a10) {
    os_unfair_lock_unlock(lock);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::AnimationTimer::dispatch_handlers(uint64_t a1, uint64_t a2, double a3, double a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  double v34 = 0;
  size_t v35 = 0;
  unint64_t v36 = 8;
  unint64_t v4 = *(void *)(a1 + 272);
  if (!v4) {
    goto LABEL_36;
  }
  uint64_t v8 = 0;
  unint64_t v9 = 0;
  uint64_t v10 = a1 + 8;
  double v11 = a4 * 0.5;
  do
  {
    uint64_t v12 = *(void *)(a1 + 264);
    if (v12) {
      uint64_t v13 = *(void *)(a1 + 264);
    }
    else {
      uint64_t v13 = v10;
    }
    uint64_t v14 = (long long *)(v13 + v8);
    if (*(double *)(v13 + v8 + 8) - a3 < v11)
    {
      size_t v15 = v35;
      size_t v16 = v35 + 1;
      if (v36 < v35 + 1)
      {
        RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(__dst, v16);
        size_t v15 = v35;
        uint64_t v12 = *(void *)(a1 + 264);
        unint64_t v4 = *(void *)(a1 + 272);
        size_t v16 = v35 + 1;
      }
      uint64_t v17 = v34;
      if (!v34) {
        uint64_t v17 = __dst;
      }
      *(void *)&v17[8 * v15] = *((void *)v14 + 2);
      size_t v35 = v16;
      if (!v12) {
        uint64_t v12 = v10;
      }
      uint64_t v18 = v12 + 32 * v4;
      long long v32 = *v14;
      long long v19 = *v14;
      *((void *)v14 + 2) = 0;
      int v20 = *(_DWORD *)(v13 + v8 + 24);
      *uint64_t v14 = *(_OWORD *)(v18 - 32);
      *((void *)v14 + 2) = *(void *)(v18 - 16);
      *(void *)(v18 - 16) = 0;
      *(_DWORD *)(v13 + v8 + 24) = *(_DWORD *)(v18 - 8);
      *(_OWORD *)(v18 - 32) = v19;
      uint64_t v21 = *(void **)(v18 - 16);
      *(void *)(v18 - 16) = 0;
      *(_DWORD *)(v18 - 8) = v20;

      uint64_t v22 = *(void *)(a1 + 264);
      uint64_t v23 = *(void *)(a1 + 272) - 1;
      *(void *)(a1 + 272) = v23;
      if (!v22) {
        uint64_t v22 = v10;
      }

      unint64_t v4 = *(void *)(a1 + 272);
    }
    ++v9;
    v8 += 32;
  }
  while (v9 < v4);
  if (!v35) {
    goto LABEL_36;
  }
  std::unique_lock<RB::spin_lock>::unlock(a2);
  [MEMORY[0x263F158F8] activateBackground:1];
  if (v34) {
    uint64_t v24 = (id *)v34;
  }
  else {
    uint64_t v24 = (id *)__dst;
  }
  if (v35)
  {
    uint64_t v25 = 8 * v35;
    do
    {
      objc_msgSend(*v24++, "runAnimationAtTime:", a3, v32);
      v25 -= 8;
    }
    while (v25);
    float32x2_t v26 = (void **)(v34 ? v34 : __dst);
    if (v35)
    {
      uint64_t v27 = 8 * v35;
      do
      {
        uint64_t v28 = *v26++;

        v27 -= 8;
      }
      while (v27);
    }
  }
  size_t v35 = 0;
  objc_msgSend(MEMORY[0x263F158F8], "flush", v32);
  std::unique_lock<RB::spin_lock>::lock(a2);
  uint64_t v29 = v34;
  if (v34) {
    int32x2_t v30 = v34;
  }
  else {
    int32x2_t v30 = __dst;
  }
  if (v35)
  {
    for (size_t i = 0; i < v35; ++i)

LABEL_36:
    uint64_t v29 = v34;
  }
  if (v29) {
    free(v29);
  }
}

void sub_2141B7950(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  RB::vector<RB::objc_ptr<objc_object  {objcproto18RBAnimationHandler}*>,8ul,unsigned long>::~vector((id *)va);
  _Unwind_Resume(a1);
}

void anonymous namespace'::AnimationTimer::remove_thread_locked(_anonymous_namespace_::AnimationTimer *this, RBAnimationThread *a2)
{
  unint64_t v2 = *((void *)this + 41);
  if (v2)
  {
    unint64_t v5 = 0;
    double v6 = (char *)this + 288;
    do
    {
      if (*((void *)this + 40)) {
        double v7 = (char *)*((void *)this + 40);
      }
      else {
        double v7 = v6;
      }
      uint64_t v8 = &v7[16 * v5];
      if (*(RBAnimationThread **)v8 == a2)
      {
        unint64_t v9 = &v7[16 * v2];
        *(void *)uint64_t v8 = 0;
        uint64_t v10 = *((void *)v8 + 1);
        *(_OWORD *)uint64_t v8 = *((_OWORD *)v9 - 1);
        *((void *)v9 - 2) = a2;
        *((void *)v9 - 1) = v10;

        double v11 = (char *)*((void *)this + 40);
        uint64_t v12 = *((void *)this + 41) - 1;
        *((void *)this + 41) = v12;
        if (!v11) {
          double v11 = v6;
        }

        unint64_t v2 = *((void *)this + 41);
      }
      else
      {
        ++v5;
      }
    }
    while (v5 < v2);
  }
}

void *RB::vector<anonymous namespace'::AnimationTimer::Handler,8ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 34) + (*((void *)__dst + 34) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 34) + (*((void *)__dst + 34) >> 1);
  }
  Class result = RB::details::realloc_vector<unsigned long,32ul>(*((void **)__dst + 32), __dst, 8uLL, (size_t *)__dst + 34, v3);
  *((void *)__dst + 32) = result;
  return result;
}

void *RB::vector<anonymous namespace'::AnimationTimer::Link,2ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 6) + (*((void *)__dst + 6) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 6) + (*((void *)__dst + 6) >> 1);
  }
  Class result = RB::details::realloc_vector<unsigned long,16ul>(*((void **)__dst + 4), __dst, 2uLL, (size_t *)__dst + 6, v3);
  *((void *)__dst + 4) = result;
  return result;
}

void anonymous namespace'::AnimationTimer::schedule_fallback_locked(double)::$_0::__invoke(uint64_t a1)
{
  os_unfair_lock_t lock = (os_unfair_lock_t)a1;
  char v4 = 1;
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  *(void *)(a1 + 344) = 0x7FF0000000000000;
  double v2 = CACurrentMediaTime();
  if (v4) {
    os_unfair_lock_unlock(lock);
  }
}

void sub_2141B7B54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, os_unfair_lock_t lock, char a10)
{
  if (a10) {
    os_unfair_lock_unlock(lock);
  }
  _Unwind_Resume(exception_object);
}

id *RB::vector<RB::objc_ptr<objc_object  {objcproto18RBAnimationHandler}*>,8ul,unsigned long>::~vector(id *a1)
{
  double v2 = (id *)a1[8];
  if (v2) {
    size_t v3 = v2;
  }
  else {
    size_t v3 = a1;
  }
  if (a1[9])
  {
    unint64_t v4 = 0;
    do

    while (v4 < (unint64_t)a1[9]);
    double v2 = (id *)a1[8];
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

uint64_t RB::ContextDelegate::finalize()
{
  uint64_t result = CGContextDelegateGetInfo();
  if (result)
  {
    uint64_t v1 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v1();
  }
  return result;
}

float64x2_t RB::ContextDelegate::get_transform@<Q0>(float64x2_t *a1@<X8>)
{
  uint64_t Info = CGContextDelegateGetInfo();
  double v3 = *(double *)(Info + 448);
  float64x2_t v4 = vmulq_n_f64(*(float64x2_t *)(Info + 384), v3);
  float64x2_t v5 = vmulq_n_f64(*(float64x2_t *)(Info + 400), v3);
  float64x2_t result = vmulq_n_f64(*(float64x2_t *)(Info + 416), v3);
  *a1 = v4;
  a1[1] = v5;
  a1[2] = result;
  return result;
}

uint64_t RB::ContextDelegate::get_bounds()
{
  uint64_t Info = CGContextDelegateGetInfo();
  DisplayList = (void *)RBDrawingStateGetDisplayList(*(void *)(Info + 432));
  return [DisplayList contentRect];
}

uint64_t RB::ContextDelegate::draw_rects(uint64_t a1, uint64_t a2, const char *a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t Info = CGContextDelegateGetInfo();
  if (a4 >= 2 && CGGStateGetLineDash()) {
    return 1006;
  }
  RB::ContextDelegate::update(Info, a3, a2, 0);
  if (a6)
  {
    BOOL v14 = a4 == 1 || a4 == 4;
    size_t v15 = (double *)(a5 + 16);
    do
    {
      if (a4 == 2
        || (objc_msgSend(*(id *)(Info + 8), "setRect:", *(v15 - 2), *(v15 - 1), *v15, v15[1]),
            [*(id *)(Info + 8) setEOFill:v14],
            FillColor = (CGColor *)CGGStateGetFillColor(),
            RB::ContextDelegate::set_color_in_shape(Info, FillColor, (int)a3, a2, 1),
            a4 >= 2))
      {
        RBDrawingStateGetCTM(*(void *)(Info + 440), (uint64_t)&v19);
        CGGStateGetAdjustedLineWidth();
        objc_msgSend(*(id *)(Info + 8), "setStrokedRect:lineWidth:", *(v15 - 2), *(v15 - 1), *v15, v15[1], v17);
        StrokeColor = (CGColor *)CGGStateGetStrokeColor();
        RB::ContextDelegate::set_color_in_shape(Info, StrokeColor, (int)a3, a2, 1);
      }
      v15 += 4;
      --a6;
    }
    while (a6);
  }
  return 0;
}

uint64_t RB::ContextDelegate::draw_path(uint64_t a1, uint64_t a2, const char *a3, int a4, uint64_t a5)
{
  return 0;
}

uint64_t RB::ContextDelegate::draw_path_direct(uint64_t a1, uint64_t a2, const char *a3, int a4, uint64_t a5)
{
  return 0;
}

uint64_t RB::ContextDelegate::draw_image(uint64_t a1, uint64_t a2, const char *a3, CGImage *a4, double a5, double a6, double a7, double a8)
{
  return 0;
}

uint64_t RB::ContextDelegate::draw_image_from_rect(uint64_t a1, uint64_t a2, const char *a3, CGImage *a4, double a5, double a6, double a7, double a8, float64_t a9, float64_t a10, double a11, double a12)
{
  v13.f64[0] = a9;
  v13.f64[1] = a10;
  double v14 = a11;
  double v15 = a12;
  RB::ContextDelegate::draw_image_(a5, a6, a7, a8, a1, a2, a3, a4, &v13);
  return 0;
}

uint64_t RB::ContextDelegate::draw_images(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, CGImageRef *a5, uint64_t a6, uint64_t a7)
{
  uint64_t Info = CGContextDelegateGetInfo();
  RB::ContextDelegate::update(Info, a3, a2, 0);
  if (!a6) {
    [*(id *)(Info + 8) setInfinite];
  }
  unsigned int v14 = CGGStateGetInterpolationQuality() - 1;
  if (v14 > 3) {
    unsigned int v15 = 7;
  }
  else {
    unsigned int v15 = dword_21421A3D0[v14];
  }
  unsigned int v56 = v15;
  CGGStateGetAlpha();
  float v17 = v16;
  if (!*(void *)(Info + 360)) {
    float v17 = *(float *)(Info + 456) * v17;
  }
  unsigned int CompositeOperation = CGGStateGetCompositeOperation();
  int v54 = (int)a3;
  if (CompositeOperation <= 0x1B)
  {
    if (!a7) {
      return 0;
    }
    goto LABEL_12;
  }
  unsigned int v19 = 0;
  if (a7)
  {
LABEL_12:
    long long v53 = v59;
    int v20 = (double *)(a6 + 16);
    uint64_t v21 = (double *)(a4 + 16);
    float v55 = v17;
    while (1)
    {
      if (a6) {
        objc_msgSend(*(id *)(Info + 8), "setRect:", *(v20 - 2), *(v20 - 1), *v20, v20[1]);
      }
      float v22 = *(v21 - 2);
      float v23 = *(v21 - 1);
      float v24 = *v21;
      float v25 = v21[1];
      double v26 = v24;
      double v27 = (float)-v25;
      double v28 = v22;
      double v29 = (float)(v25 + v23);
      int v30 = 1065353216;
      int v31 = 1065353216;
      int v32 = 1065353216;
      int v33 = 1065353216;
      if (!CGImageIsMask(*a5)) {
        break;
      }
      FillColor = (CGColor *)CGGStateGetFillColor();
      if (!CGColorGetPattern(FillColor))
      {
        double v46 = RBColorFromCGColor2(FillColor, *(_DWORD *)(Info + 528));
        int v30 = LODWORD(v46);
        int v31 = v47;
        int v32 = v48;
        int v33 = v49;
        uint64_t v45 = 1;
        goto LABEL_20;
      }
      unint64_t v43 = *(void **)(Info + 16);
      CGImageRef v44 = *a5;
      *long long v53 = 0;
      v53[1] = 0;
      double v58 = v26;
      *(double *)&v59[2] = v27;
      *(double *)&v59[3] = v28;
      *(double *)&Point v59[4] = v29;
      LODWORD(v39) = 1065353216;
      LODWORD(v40) = 1065353216;
      LODWORD(v41) = 1065353216;
      LODWORD(v42) = 1065353216;
      objc_msgSend(v43, "setTiledImage:transform:sourceRect:interpolation:tintColor:flags:", v44, &v58, v56, 0, 0.0, 0.0, 1.0, 1.0, v39, v40, v41, v42);
      RB::ContextDelegate::mask_color_in_shape(Info, FillColor, v54, a2, v19, v55);
LABEL_21:
      ++a5;
      v20 += 4;
      v21 += 4;
      if (!--a7) {
        return 0;
      }
    }
    uint64_t v45 = 0;
LABEL_20:
    int32x2_t v50 = *(void **)(Info + 16);
    CGImageRef v51 = *a5;
    v57[1] = 0;
    v57[2] = 0;
    *(double *)__int16 v57 = v26;
    *(double *)&v57[3] = v27;
    *(double *)&v57[4] = v28;
    *(double *)&v57[5] = v29;
    LODWORD(v34) = v30;
    LODWORD(v35) = v31;
    LODWORD(v36) = v32;
    LODWORD(v37) = v33;
    objc_msgSend(v50, "setTiledImage:transform:sourceRect:interpolation:tintColor:flags:", v51, v57, v56, v45, 0.0, 0.0, 1.0, 1.0, v34, v35, v36, v37, v53);
    RBDrawingStateDrawShape(*(__n128 **)(Info + 440), *(void *)(Info + 8), *(RBFill **)(Info + 16), v19, v55);
    goto LABEL_21;
  }
  return 0;
}

uint64_t RB::ContextDelegate::draw_shading(uint64_t a1, uint64_t a2, const char *a3, CGShading *a4)
{
  uint64_t Info = CGContextDelegateGetInfo();
  RB::ContextDelegate::update(Info, a3, a2, 0);
  [*(id *)(Info + 8) setInfinite];
  char v8 = RB::ContextDelegate::draw_shading_in_shape(Info, (int)a3, a4, 0);
  uint64_t result = 0;
  if ((v8 & 1) == 0)
  {
    RBDrawingStateGetDeviceClipBoundingBox(*(void *)(Info + 440));
    v11.f64[1] = v10;
    v13.f64[1] = v12;
    float32x2_t v14 = vcvt_f32_f64(v13);
    float32x2_t v85 = vcvt_f32_f64(v11);
    float32x2_t v86 = v14;
    uint64_t Background = CGShadingGetBackground();
    if (Background)
    {
      uint64_t v17 = Background;
      ColorSpace = (CGColorSpace *)CGShadingGetColorSpace();
      if (*(double *)(v17 + 8 * CGColorSpaceGetNumberOfComponents(ColorSpace)) == 0.0)
      {
        CGShadingGetBounds();
        v20.f64[1] = v19;
        v22.f64[1] = v21;
        RB::Rect::intersect(&v85, COERCE_DOUBLE(vcvt_f32_f64(v20)), vcvt_f32_f64(v22), v22.f64[0], v21, v23, v24);
        float32x2_t v14 = v86;
      }
    }
    uint32x2_t v25 = (uint32x2_t)vclez_f32(v14);
    if ((vpmax_u32(v25, v25).u32[0] & 0x80000000) == 0)
    {
      *(float32x2_t *)v16.i8 = v14;
      float32x2_t v26 = RB::operator*((float64x2_t *)(Info + 384), v85, v16);
      RB::Bounds::Bounds(&v83, v26, v27);
      size_t v28 = v84.i32[0];
      size_t v29 = v84.i32[1];
      int v31 = (CGColorSpace *)RB::srgb_colorspace(v30);
      CGContextRef v32 = CGBitmapContextCreate(0, v28, v29, 8uLL, 0, v31, 0x2002u);
      if (!v32) {
        return 1000;
      }
      int v33 = v32;
      uint64_t CTM = CGGStateGetCTM();
      long long v35 = *(_OWORD *)(CTM + 16);
      long long v36 = *(_OWORD *)(CTM + 32);
      float64x2_t v80 = *(float64x2_t *)CTM;
      long long v81 = v35;
      long long v82 = v36;
      v37.f64[0] = RB::operator*(&v80, (float64x2_t *)(Info + 384));
      float64x2_t v80 = v37;
      long long v81 = v38;
      long long v82 = v39;
      CGContextTranslateCTM(v33, (double)-v83.i32[0], (double)-v83.i32[1]);
      *(float64x2_t *)&transform.a = v80;
      *(_OWORD *)&transform.c = v81;
      *(_OWORD *)&transform.tx = v82;
      CGContextConcatCTM(v33, &transform);
      if (CGShadingGetType())
      {
        CGContextSetCompositeOperation();
      }
      else
      {
        CGContextSetCompositeOperation();
        CGContextClear();
      }
      CGContextDrawShading(v33, a4);
      CGImageRef Image = CGBitmapContextCreateImage(v33);
      v41.i32[0] = 0;
      uint32x2_t v42 = (uint32x2_t)vceq_s32(v84, (int32x2_t)0x8000000080000000);
      int8x8_t v43 = (int8x8_t)vdup_lane_s32(vcgt_s32(v41, (int32x2_t)vpmin_u32(v42, v42)), 0);
      int8x8_t v44 = vbsl_s8(v43, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v84));
      int8x8_t v45 = vbsl_s8(v43, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v83));
      RBImageSimpleTransform((uint64_t)&v87, *(float *)v45.i32, *(float *)&v45.i32[1], *(float *)v44.i32, *(float *)&v44.i32[1]);
      float64x2_t v76 = v87;
      long long v77 = v88;
      long long v78 = v89;
      long long v46 = *(_OWORD *)(Info + 400);
      float64x2_t v87 = *(float64x2_t *)(Info + 384);
      long long v88 = v46;
      long long v89 = *(_OWORD *)(Info + 416);
      BOOL v47 = RB::AffineTransform::invert((RB::AffineTransform *)&v87);
      if (v47) {
        int v48 = &v87;
      }
      else {
        int v48 = (float64x2_t *)(Info + 384);
      }
      float64x2_t v49 = *v48;
      int32x2_t v50 = (float64x2_t *)&v88;
      if (!v47) {
        int32x2_t v50 = (float64x2_t *)(Info + 400);
      }
      float64x2_t v51 = *v50;
      uint64_t v52 = (float64x2_t *)&v89;
      if (!v47) {
        uint64_t v52 = (float64x2_t *)(Info + 416);
      }
      float64x2_t v53 = *v52;
      v75[0] = v49;
      v75[1] = v51;
      v75[2] = v53;
      v54.f64[0] = RB::operator*(&v76, v75);
      float64x2_t v76 = v54;
      long long v77 = v55;
      long long v78 = v56;
      __int16 v57 = *(void **)(Info + 16);
      v74[0] = v54;
      v74[1] = v55;
      v74[2] = v56;
      LODWORD(v54.f64[0]) = 1065353216;
      LODWORD(v55) = 1065353216;
      LODWORD(v56) = 1065353216;
      LODWORD(v58) = 1065353216;
      objc_msgSend(v57, "setImage:transform:interpolation:tintColor:flags:", Image, v74, 1, 0, v54.f64[0], *(double *)&v55, *(double *)&v56, v58);
      v59.i32[0] = 0;
      uint32x2_t v60 = (uint32x2_t)vceq_s32(v84, (int32x2_t)0x8000000080000000);
      int8x8_t v61 = (int8x8_t)vdup_lane_s32(vcgt_s32(v59, (int32x2_t)vpmin_u32(v60, v60)), 0);
      int8x8_t v62 = vbsl_s8(v61, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v84));
      int8x8_t v63 = vbsl_s8(v61, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v83));
      objc_msgSend(*(id *)(Info + 8), "setRect:", *(float *)v63.i32, *(float *)&v63.i32[1], *(float *)v62.i32, *(float *)&v62.i32[1]);
      [*(id *)(Info + 8) setAntialiased:0];
      int32x2_t v64 = *(RB::DisplayList::State **)(Info + 440);
      float64x2_t v65 = *(float64x2_t *)(Info + 400);
      v73[0] = *(float64x2_t *)(Info + 384);
      v73[1] = v65;
      v73[2] = *(float64x2_t *)(Info + 416);
      RBDrawingStateSetCTM(v64, v73);
      uint32x2_t v66 = *(__n128 **)(Info + 440);
      uint64_t v67 = *(void *)(Info + 8);
      int32x4_t v68 = *(RBFill **)(Info + 16);
      CGGStateGetAlpha();
      float v70 = v69;
      if (!*(void *)(Info + 360)) {
        float v70 = *(float *)(Info + 456) * v70;
      }
      unsigned int CompositeOperation = CGGStateGetCompositeOperation();
      if (CompositeOperation > 0x1B) {
        unsigned int v72 = 0;
      }
      else {
      RBDrawingStateDrawShape(v66, v67, v68, v72, v70);
      }
      if (Image) {
        CFRelease(Image);
      }
      CFRelease(v33);
    }
    return 0;
  }
  return result;
}

void sub_2141B8548(_Unwind_Exception *a1)
{
  if (v2) {
    CFRelease(v2);
  }
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::ContextDelegate::draw_linear_gradient(double a1, double a2, double a3, double a4, uint64_t a5, uint64_t a6, const char *a7, uint64_t a8, char a9)
{
  v36[1] = *MEMORY[0x263EF8340];
  uint64_t Info = CGContextDelegateGetInfo();
  RB::ContextDelegate::update(Info, a7, a6, 0);
  uint64_t LocationCount = CGGradientGetLocationCount();
  unint64_t v19 = LocationCount + 2;
  if ((unint64_t)(LocationCount + 2) >> 60)
  {
    if (v19 >> 61) {
      return 1000;
    }
    double v21 = 0;
  }
  else
  {
    if (16 * v19 > 0x1000)
    {
      uint64_t LocationCount = (uint64_t)malloc_type_malloc(16 * v19, 0xBCB38F5BuLL);
      double v21 = (char *)LocationCount;
      char v22 = 0;
      goto LABEL_9;
    }
    MEMORY[0x270FA5388](LocationCount, 16 * v19);
    double v21 = (char *)v36 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v21, v23);
  }
  char v22 = 1;
LABEL_9:
  if (v19 >= 0x201)
  {
    uint32x2_t v25 = (char *)malloc_type_malloc(8 * v19, 0xC5C1FABEuLL);
    if (!v21) {
      goto LABEL_18;
    }
  }
  else
  {
    MEMORY[0x270FA5388](LocationCount, 8 * v19);
    uint32x2_t v25 = (char *)v36 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v25, v24);
    if (!v21) {
      goto LABEL_18;
    }
  }
  if (v25)
  {
    BOOL gradient = RB::make_gradient(a8, (uint64_t)v21, (uint64_t)v25, *(unsigned int *)(Info + 528), a9);
    objc_msgSend(*(id *)(Info + 16), "setAxialGradientStartPoint:endPoint:stopCount:colors:locations:flags:", gradient, v21, v25, v27, a1, a2, a3, a4);
    [*(id *)(Info + 8) setInfinite];
    size_t v28 = *(__n128 **)(Info + 440);
    uint64_t v29 = *(void *)(Info + 8);
    int v30 = *(RBFill **)(Info + 16);
    CGGStateGetAlpha();
    float v32 = v31;
    if (!*(void *)(Info + 360)) {
      float v32 = *(float *)(Info + 456) * v32;
    }
    unsigned int CompositeOperation = CGGStateGetCompositeOperation();
    if (CompositeOperation > 0x1B) {
      unsigned int v34 = 0;
    }
    else {
    RBDrawingStateDrawShape(v28, v29, v30, v34, v32);
    }
    uint64_t v20 = 0;
    goto LABEL_21;
  }
LABEL_18:
  uint64_t v20 = 1000;
LABEL_21:
  if (v19 >= 0x201) {
    free(v25);
  }
  if ((v22 & 1) == 0) {
    free(v21);
  }
  return v20;
}

void sub_2141B87F4(_Unwind_Exception *exception_object)
{
  if (v3 >= 0x201) {
    free(v2);
  }
  if ((v4 & 1) == 0) {
    free(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::ContextDelegate::draw_radial_gradient(double a1, double a2, double a3, double a4, double a5, double a6, uint64_t a7, uint64_t a8, const char *a9, uint64_t a10, char a11)
{
  v40[1] = *MEMORY[0x263EF8340];
  uint64_t Info = CGContextDelegateGetInfo();
  RB::ContextDelegate::update(Info, a9, a8, 0);
  uint64_t LocationCount = CGGradientGetLocationCount();
  unint64_t v23 = LocationCount + 2;
  if ((unint64_t)(LocationCount + 2) >> 60)
  {
    if (v23 >> 61) {
      return 1000;
    }
    uint32x2_t v25 = 0;
  }
  else
  {
    if (16 * v23 > 0x1000)
    {
      uint64_t LocationCount = (uint64_t)malloc_type_malloc(16 * v23, 0xA2238EA7uLL);
      uint32x2_t v25 = (char *)LocationCount;
      char v26 = 0;
      goto LABEL_9;
    }
    MEMORY[0x270FA5388](LocationCount, 16 * v23);
    uint32x2_t v25 = (char *)v40 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v25, v27);
  }
  char v26 = 1;
LABEL_9:
  if (v23 >= 0x201)
  {
    uint64_t v29 = (char *)malloc_type_malloc(8 * v23, 0x57124365uLL);
    if (!v25) {
      goto LABEL_18;
    }
  }
  else
  {
    MEMORY[0x270FA5388](LocationCount, 8 * v23);
    uint64_t v29 = (char *)v40 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v29, v28);
    if (!v25) {
      goto LABEL_18;
    }
  }
  if (v29)
  {
    BOOL gradient = RB::make_gradient(a10, (uint64_t)v25, (uint64_t)v29, *(unsigned int *)(Info + 528), a11);
    objc_msgSend(*(id *)(Info + 16), "setRadialGradientStartCenter:startRadius:endCenter:endRadius:stopCount:colors:locations:flags:", gradient, v25, v29, v31, a1, a2, a3, a4, a5, a6);
    [*(id *)(Info + 8) setInfinite];
    float v32 = *(__n128 **)(Info + 440);
    uint64_t v33 = *(void *)(Info + 8);
    unsigned int v34 = *(RBFill **)(Info + 16);
    CGGStateGetAlpha();
    float v36 = v35;
    if (!*(void *)(Info + 360)) {
      float v36 = *(float *)(Info + 456) * v36;
    }
    unsigned int CompositeOperation = CGGStateGetCompositeOperation();
    if (CompositeOperation > 0x1B) {
      unsigned int v38 = 0;
    }
    else {
    RBDrawingStateDrawShape(v32, v33, v34, v38, v36);
    }
    uint64_t v24 = 0;
    goto LABEL_21;
  }
LABEL_18:
  uint64_t v24 = 1000;
LABEL_21:
  if (v23 >= 0x201) {
    free(v29);
  }
  if ((v26 & 1) == 0) {
    free(v25);
  }
  return v24;
}

void sub_2141B8AB0(_Unwind_Exception *exception_object)
{
  if (v3 >= 0x201) {
    free(v2);
  }
  if ((v4 & 1) == 0) {
    free(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::ContextDelegate::draw_conic_gradient(double a1, double a2, double a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7)
{
  v32[1] = *MEMORY[0x263EF8340];
  uint64_t Info = CGContextDelegateGetInfo();
  RB::ContextDelegate::update(Info, a6, a5, 0);
  uint64_t LocationCount = CGGradientGetLocationCount();
  unint64_t v15 = LocationCount + 2;
  if ((unint64_t)(LocationCount + 2) >> 60)
  {
    if (v15 >> 61) {
      return 1000;
    }
    uint64_t v17 = 0;
  }
  else
  {
    if (16 * v15 > 0x1000)
    {
      uint64_t LocationCount = (uint64_t)malloc_type_malloc(16 * v15, 0xD3AA41DDuLL);
      uint64_t v17 = (char *)LocationCount;
      char v18 = 0;
      goto LABEL_9;
    }
    MEMORY[0x270FA5388](LocationCount, 16 * v15);
    uint64_t v17 = (char *)v32 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v17, v19);
  }
  char v18 = 1;
LABEL_9:
  if (v15 >= 0x201)
  {
    double v21 = (char *)malloc_type_malloc(8 * v15, 0x75C905ADuLL);
    if (!v17) {
      goto LABEL_18;
    }
  }
  else
  {
    MEMORY[0x270FA5388](LocationCount, 8 * v15);
    double v21 = (char *)v32 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v21, v20);
    if (!v17) {
      goto LABEL_18;
    }
  }
  if (v21)
  {
    BOOL gradient = RB::make_gradient(a7, (uint64_t)v17, (uint64_t)v21, *(unsigned int *)(Info + 528), 3);
    objc_msgSend(*(id *)(Info + 16), "setConicGradientCenter:angle:stopCount:colors:locations:flags:", gradient, v17, v21, v23, a1, a2, a3);
    [*(id *)(Info + 8) setInfinite];
    uint64_t v24 = *(__n128 **)(Info + 440);
    uint64_t v25 = *(void *)(Info + 8);
    char v26 = *(RBFill **)(Info + 16);
    CGGStateGetAlpha();
    float v28 = v27;
    if (!*(void *)(Info + 360)) {
      float v28 = *(float *)(Info + 456) * v28;
    }
    unsigned int CompositeOperation = CGGStateGetCompositeOperation();
    if (CompositeOperation > 0x1B) {
      unsigned int v30 = 0;
    }
    else {
    RBDrawingStateDrawShape(v24, v25, v26, v30, v28);
    }
    uint64_t v16 = 0;
    goto LABEL_21;
  }
LABEL_18:
  uint64_t v16 = 1000;
LABEL_21:
  if (v15 >= 0x201) {
    free(v21);
  }
  if ((v18 & 1) == 0) {
    free(v17);
  }
  return v16;
}

void sub_2141B8D48(_Unwind_Exception *exception_object)
{
  if (v3 >= 0x201) {
    free(v2);
  }
  if ((v4 & 1) == 0) {
    free(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::ContextDelegate::operation(uint64_t a1, uint64_t a2, const char *a3, const void *a4, void *a5)
{
  uint64_t Info = CGContextDelegateGetInfo();
  if (CFEqual(a4, @"kCGContextClear"))
  {
    RB::ContextDelegate::update(Info, a3, a2, 0);
    [*(id *)(Info + 8) setInfinite];
    float32x2_t v14 = *(void **)(Info + 16);
    unint64_t v15 = &RBColorClear;
LABEL_5:
    LODWORD(v10) = *(_DWORD *)v15;
    LODWORD(v11) = *((_DWORD *)v15 + 1);
    LODWORD(v12) = *((_DWORD *)v15 + 2);
    LODWORD(v13) = *((_DWORD *)v15 + 3);
    objc_msgSend(v14, "setColor:", v10, v11, v12, v13);
    RBDrawingStateDrawShape(*(__n128 **)(Info + 440), *(void *)(Info + 8), *(RBFill **)(Info + 16), 0x11u, 1.0);
    return 0;
  }
  if (CFEqual(a4, @"kCGContextErase"))
  {
    RB::ContextDelegate::update(Info, a3, a2, 0);
    [*(id *)(Info + 8) setInfinite];
    float32x2_t v14 = *(void **)(Info + 16);
    unint64_t v15 = &RBColorWhite;
    goto LABEL_5;
  }
  if (CFEqual(a4, @"RBDisplayListAttributeTextRun"))
  {
    uint64_t v17 = *(const void **)(Info + 544);
    if (v17 == a5) {
      return 0;
    }
    if (v17) {
      CFRelease(v17);
    }
    if (a5) {
      CFTypeRef v18 = CFRetain(a5);
    }
    else {
      CFTypeRef v18 = 0;
    }
    uint64_t result = 0;
    *(void *)(Info + 544) = v18;
  }
  else if (CFEqual(a4, @"RBShapeRenderingMode"))
  {
    uint64_t result = [a5 objectForKeyedSubscript:@"value"];
    if (result)
    {
      *(_DWORD *)(Info + 552) = [(id)result unsignedIntValue];
      uint64_t result = [a5 objectForKeyedSubscript:@"argument"];
      if (result)
      {
        size_t v19 = (void *)result;
        uint64_t CTM = CGGStateGetCTM();
        float64x2_t v21 = *(float64x2_t *)(CTM + 16);
        float64x2_t v22 = *(float64x2_t *)(CTM + 32);
        v30[0] = *(float64x2_t *)CTM;
        v30[1] = v21;
        Point v30[2] = v22;
        v23.f64[0] = RB::operator*(v30, (float64x2_t *)(Info + 384));
        v31[0] = v23;
        v31[1] = v24;
        Point v31[2] = v25;
        [v19 doubleValue];
        double v27 = v26;
        float v28 = RB::AffineTransform::scale(v31);
        uint64_t result = 0;
        float v29 = v27 * v28;
        *(float *)(Info + 556) = v29;
      }
    }
    else
    {
      *(void *)(Info + 552) = 0;
    }
  }
  else
  {
    return 1006;
  }
  return result;
}

uint64_t RB::ContextDelegate::begin_transparency_layer(uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t Info = CGContextDelegateGetInfo();
  RB::ContextDelegate::update(Info, a3, a2, 0);
  double v7 = RBDrawingStateBeginLayer(*(RB::DisplayList::State **)(Info + 440), 0);
  float64x2_t v8 = *(float64x2_t *)(Info + 400);
  v17[0] = *(float64x2_t *)(Info + 384);
  v17[1] = v8;
  int32x2_t v17[2] = *(float64x2_t *)(Info + 416);
  RBDrawingStateSetCTM(v7, v17);
  uint64_t v9 = *(void *)(Info + 360);
  if (*(void *)(Info + 368) < (unint64_t)(v9 + 1))
  {
    RB::vector<RB::ContextDelegate::Layer,4ul,unsigned long>::reserve_slow((void *)(Info + 32), v9 + 1);
    uint64_t v9 = *(void *)(Info + 360);
  }
  uint64_t v10 = *(void *)(Info + 352);
  if (!v10) {
    uint64_t v10 = Info + 32;
  }
  uint64_t v11 = v10 + 80 * v9;
  int v12 = *(_DWORD *)(Info + 464);
  *(_OWORD *)uint64_t v11 = *(_OWORD *)(Info + 432);
  uint64_t v13 = *(void *)(Info + 472);
  *(_DWORD *)(v11 + 16) = v12;
  *(void *)(v11 + 20) = v13;
  long long v14 = *(_OWORD *)(Info + 480);
  long long v15 = *(_OWORD *)(Info + 512);
  *(_OWORD *)(v11 + 48) = *(_OWORD *)(Info + 496);
  *(_OWORD *)(v11 + 64) = v15;
  *(_OWORD *)(v11 + 32) = v14;
  ++*(void *)(Info + 360);
  *(void *)(Info + 432) = v7;
  *(void *)(Info + 440) = 0;
  *(_DWORD *)(Info + 464) = 0;
  *(void *)(Info + 472) = 0;
  return a1;
}

uint64_t RB::ContextDelegate::end_transparency_layer(uint64_t a1)
{
  uint64_t Info = (void *)CGContextDelegateGetInfo();
  unint64_t v3 = (float *)Info;
  char v4 = Info + 4;
  float64x2_t v5 = (void *)Info[44];
  if (!v5) {
    float64x2_t v5 = Info + 4;
  }
  double v6 = (int8x16_t *)v5[10 * Info[45] - 9];
  double v7 = (RB::DisplayList::State *)Info[54];
  CGGStateGetAlpha();
  float v9 = v8;
  if (!*((void *)v3 + 45)) {
    float v9 = v3[114] * v9;
  }
  unsigned int CompositeOperation = CGGStateGetCompositeOperation();
  if (CompositeOperation > 0x1B) {
    unsigned int v11 = 0;
  }
  else {
  RBDrawingStateDrawLayer(v6, v7, v11, v9);
  }
  long long v14 = (RB::XML::Document *)*((void *)v3 + 55);
  if (v14) {
    RBDrawingStateDestroy(v14, v12, v13);
  }
  long long v15 = (void *)*((void *)v3 + 44);
  if (!v15) {
    long long v15 = v4;
  }
  uint64_t v16 = *((void *)v3 + 45) - 1;
  uint64_t v17 = &v15[10 * v16];
  v3[116] = *((float *)v17 + 4);
  *((void *)v3 + 59) = *(void *)((char *)v17 + 20);
  long long v18 = *((_OWORD *)v17 + 2);
  long long v19 = *((_OWORD *)v17 + 4);
  *((_OWORD *)v3 + 31) = *((_OWORD *)v17 + 3);
  *((_OWORD *)v3 + 32) = v19;
  *((_OWORD *)v3 + 30) = v18;
  *((_OWORD *)v3 + 27) = *(_OWORD *)v17;
  *((void *)v3 + 45) = v16;
  return a1;
}

void RB::ContextDelegate::create_layer(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  v14.origin.x = a1;
  v14.origin.CGFloat y = a2;
  v14.size.width = a3;
  v14.size.CGFloat height = a4;
  uint64_t Info = (float64x2_t *)CGContextDelegateGetInfo();
  uint64_t CTM = CGGStateGetCTM();
  long long v6 = *(_OWORD *)(CTM + 16);
  long long v7 = *(_OWORD *)(CTM + 32);
  float64x2_t v11 = *(float64x2_t *)CTM;
  long long v12 = v6;
  long long v13 = v7;
  v8.f64[0] = RB::operator*(&v11, Info + 24);
  float64x2_t v11 = v8;
  long long v12 = v9;
  long long v13 = v10;
  RB::AffineTransform::scale(&v11);
  operator new();
}

void sub_2141B9230(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10E1C40C37EBC0CLL);
  _Unwind_Resume(a1);
}

uint64_t RB::ContextDelegate::draw_layer(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, uint64_t a5, uint64_t a6, const char *a7)
{
  uint64_t Info = CGContextDelegateGetInfo();
  if ((uint64_t (*)())CGContextDelegateGetCallback() == RB::ContextDelegate::get_bounds)
  {
    uint64_t v22 = CGContextDelegateGetInfo();
    RB::ContextDelegate::update(v22, a7, a6, 0);
    float64x2_t v23 = RBDrawingStateBeginLayer(*(RB::DisplayList::State **)(v22 + 440), 0);
    v38.origin.x = a1;
    v38.origin.CGFloat y = a2;
    v38.size.width = a3;
    v38.size.CGFloat height = a4;
    if (!CGRectEqualToRect(v38, *(CGRect *)(Info + 568)))
    {
      RBDrawingStateTranslateCTM(v23, a1, a2);
      v25.f64[0] = *(double *)(Info + 584) / a3;
      RBDrawingStateScaleCTM((uint64_t)v23, v25, *(double *)(Info + 592) / a4);
      RBDrawingStateTranslateCTM(v23, -*(double *)(Info + 568), -*(double *)(Info + 576));
    }
    RBDrawingStateDrawDisplayList((uint64_t)v23, *(void **)(Info + 560), v24);
    double v26 = *(int8x16_t **)(v22 + 440);
    CGGStateGetAlpha();
    float v28 = v27;
    if (!*(void *)(v22 + 360)) {
      float v28 = *(float *)(v22 + 456) * v28;
    }
    unsigned int CompositeOperation = CGGStateGetCompositeOperation();
    if (CompositeOperation > 0x1B) {
      unsigned int v30 = 0;
    }
    else {
    RBDrawingStateDrawLayer(v26, v23, v30, v28);
    }
  }
  else
  {
    uint64_t CTM = (_OWORD *)CGGStateGetCTM();
    long long v16 = CTM[1];
    long long v15 = CTM[2];
    *(_OWORD *)&v36.a = *CTM;
    *(_OWORD *)&v36.c = v16;
    *(_OWORD *)&v36.tx = v15;
    long long v17 = *CTM;
    long long v18 = CTM[2];
    *(_OWORD *)&v35.c = CTM[1];
    *(_OWORD *)&v35.tx = v18;
    *(_OWORD *)&v35.a = v17;
    CGAffineTransformTranslate(&v36, &v35, a1, a2);
    CGAffineTransform v33 = v36;
    CGAffineTransformScale(&v34, &v33, *(double *)(Info + 584) / a3, *(double *)(Info + 592) / a4);
    CGAffineTransform v36 = v34;
    *(_OWORD *)&v32.a = *(_OWORD *)&v34.a;
    *(_OWORD *)&v32.c = *(_OWORD *)&v34.c;
    CGFloat v19 = -*(double *)(Info + 568);
    CGFloat v20 = -*(double *)(Info + 576);
    *(_OWORD *)&v32.tx = *(_OWORD *)&v34.tx;
    CGAffineTransformTranslate(&v34, &v32, v19, v20);
    CGAffineTransform v36 = v34;
    CGGStateCreateCopy();
    CGGStateSetCTM();
    float64x2_t v21 = (CGContext *)CGContextCreateWithDelegate();
    CGGStateRelease();
    v37.origin.x = a1;
    v37.origin.CGFloat y = a2;
    v37.size.width = a3;
    v37.size.CGFloat height = a4;
    CGContextBeginTransparencyLayerWithRect(v21, v37, 0);
    [*(id *)(Info + 560) renderInContext:v21 options:0];
    CGContextEndTransparencyLayer(v21);
    if (v21) {
      CFRelease(v21);
    }
  }
  return 0;
}

void sub_2141B94F8(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void RB::ContextDelegate::~ContextDelegate(RB::ContextDelegate *this)
{
  *(void *)this = &unk_26C4ED160;
  double v2 = (const void *)*((void *)this + 68);
  if (v2) {
    CFRelease(v2);
  }

  unint64_t v3 = (void *)*((void *)this + 44);
  if (v3) {
    free(v3);
  }
}

{
  uint64_t vars8;

  RB::ContextDelegate::~ContextDelegate(this);
  JUMPOUT(0x21669AC10);
}

uint64_t RB::ContextDelegate::set_stroked_clip(uint64_t a1, uint64_t a2)
{
  long long v19 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  CGClipStrokeGetMatrix();
  CGClipStrokeGetLineWidth();
  double v5 = v4;
  uint64_t LineCap = CGClipStrokeGetLineCap();
  uint64_t LineJoin = CGClipStrokeGetLineJoin();
  CGClipStrokeGetMiterLimit();
  double v9 = v8;
  double v16 = 0.0;
  uint64_t v17 = 0;
  if (CGClipStrokeGetDash())
  {
    uint64_t Pattern = CGDashGetPattern();
    double v11 = v16;
    uint64_t v12 = v17;
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t Pattern = 0;
    double v11 = 0.0;
  }
  long long v13 = *(void **)(a1 + 8);
  v15[0] = v18;
  v15[1] = v19;
  int32x2_t v15[2] = v20;
  [v13 setStrokedPath:a2 transform:v15 lineWidth:LineCap lineCap:LineJoin lineJoin:Pattern miterLimit:v12 dashPhase:v5 dashPattern:v9 dashCount:v11];
  return [*(id *)(a1 + 8) setEOFill:0];
}

void RB::ContextDelegate::clip_soft_mask(uint64_t a1)
{
  CGSoftMaskGetMatrix();
  float64x2_t v63 = (float64x2_t)v62[0];
  long long v64 = v62[1];
  long long v65 = v62[2];
  uint64_t Background = (CGColor *)CGSoftMaskGetBackground();
  uint64_t Transfer = CGSoftMaskGetTransfer();
  if (Transfer && (double v4 = (CGContext *)Transfer, !CGFunctionIsIdentity()))
  {
    CGSoftMaskGetBounds();
    v15.f64[1] = v14;
    v17.f64[1] = v16;
    *(float32x2_t *)v18.i8 = vcvt_f32_f64(v17);
    float32x2_t v19 = RB::operator*(&v63, vcvt_f32_f64(v15), v18);
    RB::Bounds::Bounds((int32x2_t *)v62, v19, v20);
    RBDrawingStateGetDeviceClipBoundingBox(*(void *)(a1 + 440));
    v22.f64[1] = v21;
    v24.f64[1] = v23;
    RB::Bounds::Bounds(v60, vcvt_f32_f64(v22), vcvt_f32_f64(v24));
    float64x2_t v25 = (RB *)RB::Bounds::intersect((int32x2_t *)v62, v60[0], v60[1]);
    uint64_t v26 = *((void *)&v62[0] + 1);
    uint32x2_t v27 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)v62 + 8));
    if ((vpmax_u32(v27, v27).u32[0] & 0x80000000) == 0)
    {
      if (Background)
      {
        float v28 = (CGColorSpace *)RB::gray_colorspace(v25);
        uint32_t v29 = 0;
        uint64_t v26 = *((void *)&v62[0] + 1);
      }
      else
      {
        float v28 = 0;
        uint32_t v29 = 7;
      }
      unsigned int v30 = CGBitmapContextCreate(0, (int)v26, SHIDWORD(v26), 8uLL, 0, v28, v29);
      if (v30)
      {
        uint64_t v31 = v30;
        if (Background)
        {
          CGContextBeginTransparencyLayer(v30, 0);
          CGContextSetFillColorWithColor(v31, Background);
          CGContextFillRect(v31, *MEMORY[0x263F00190]);
        }
        CGContextTranslateCTM(v31, (double)-LODWORD(v62[0]), (double)-DWORD1(v62[0]));
        *(float64x2_t *)&transform.a = v63;
        *(_OWORD *)&transform.c = v64;
        *(_OWORD *)&transform.tx = v65;
        CGContextConcatCTM(v31, &transform);
        CGContextGetCTM(&v58, v31);
        CGContextSetBaseCTM();
        CGContextGetDelegate();
        CGContextGetRenderingState();
        CGContextGetGState();
        CGSoftMaskDelegateDrawSoftMask();
        if (Background) {
          CGContextEndTransparencyLayer(v31);
        }
        RB::cg_mask_apply_transfer((vImage_Error)v31, v4, v32);
        CGImageRef Image = CGBitmapContextCreateImage(v31);
        if (Image)
        {
          v34.i32[0] = 0;
          CGAffineTransform v35 = *(void **)(a1 + 16);
          uint32x2_t v36 = (uint32x2_t)vceq_s32(*(int32x2_t *)((char *)v62 + 8), (int32x2_t)0x8000000080000000);
          int8x8_t v37 = (int8x8_t)vdup_lane_s32(vcgt_s32(v34, (int32x2_t)vpmin_u32(v36, v36)), 0);
          int32x2_t v38 = (int32x2_t)vbsl_s8(v37, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v62[0]));
          int8x8_t v39 = (int8x8_t)vdup_n_s32(0x7F7FFFFFu);
          int8x8_t v40 = (int8x8_t)vcvt_f32_s32(*(int32x2_t *)((char *)v62 + 8));
          float32x2_t v41 = (float32x2_t)vbsl_s8(v37, v39, v40);
          *(float *)v40.i32 = -v41.f32[1];
          double v42 = COERCE_FLOAT(vadd_f32(*(float32x2_t *)&v38, v41).i32[1]);
          v55[0] = v41.f32[0];
          float32x2_t v43 = (float32x2_t)vdup_lane_s32(v38, 0);
          v55[1] = 0.0;
          v55[2] = 0.0;
          v43.i32[0] = v40.i32[0];
          float64x2_t v44 = vcvtq_f64_f32(v43);
          float64x2_t v56 = v44;
          double v57 = v42;
          LODWORD(v44.f64[0]) = 1065353216;
          v40.i32[0] = 1065353216;
          v38.i32[0] = 1065353216;
          LODWORD(v42) = 1065353216;
          objc_msgSend(v35, "setImage:transform:interpolation:tintColor:flags:", Image, v55, 1, 0, v44.f64[0], *(double *)&v40, *(double *)&v38, v42);
          v45.i32[0] = 0;
          uint32x2_t v46 = (uint32x2_t)vceq_s32(*(int32x2_t *)((char *)v62 + 8), (int32x2_t)0x8000000080000000);
          int8x8_t v47 = (int8x8_t)vdup_lane_s32(vcgt_s32(v45, (int32x2_t)vpmin_u32(v46, v46)), 0);
          int8x8_t v48 = vbsl_s8(v47, v39, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)((char *)v62 + 8)));
          int8x8_t v49 = vbsl_s8(v47, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v62[0]));
          objc_msgSend(*(id *)(a1 + 8), "setRect:", *(float *)v49.i32, *(float *)&v49.i32[1], *(float *)v48.i32, *(float *)&v48.i32[1]);
          [*(id *)(a1 + 8) setAntialiased:0];
          int32x2_t v50 = RBDrawingStateBeginLayer(*(RB::DisplayList::State **)(a1 + 440), 0);
          float64x2_t v51 = (__n128 *)v50;
          if (Background) {
            RBDrawingStateAddLuminanceToAlphaFilter((__n128 *)v50, 0);
          }
          uint64_t v52 = *(RB::DisplayList::State **)(a1 + 440);
          float64x2_t v53 = *(float64x2_t *)(a1 + 400);
          v54[0] = *(float64x2_t *)(a1 + 384);
          v54[1] = v53;
          v54[2] = *(float64x2_t *)(a1 + 416);
          RBDrawingStateSetCTM(v52, v54);
          RBDrawingStateDrawShape(v51, *(void *)(a1 + 8), *(RBFill **)(a1 + 16), 0, 1.0);
          RBDrawingStateClipLayer(*(__n128 **)(a1 + 440), (RB::DisplayList::State *)v51, 0, 1.0);
          CFRelease(Image);
        }
        CFRelease(v31);
      }
    }
  }
  else
  {
    double v5 = *(RB::DisplayList::State **)(a1 + 440);
    v6.f64[0] = RB::operator*(&v63, (float64x2_t *)(a1 + 384));
    v61[0] = v6;
    v61[1] = v7;
    v61[2] = v8;
    RBDrawingStateSetCTM(v5, v61);
    double v9 = RBDrawingStateBeginLayer(*(RB::DisplayList::State **)(a1 + 440), 0);
    long long v10 = v9;
    double v11 = v9;
    if (Background)
    {
      RBDrawingStateAddLuminanceToAlphaFilter((__n128 *)v9, 0);
      double v11 = RBDrawingStateBeginLayer(v10, 0);
      [*(id *)(a1 + 8) setInfinite];
      objc_msgSend(*(id *)(a1 + 16), "setColor:", RBColorFromCGColor2(Background, *(_DWORD *)(a1 + 528)));
      RBDrawingStateDrawShape((__n128 *)v11, *(void *)(a1 + 8), *(RBFill **)(a1 + 16), 0, 1.0);
    }
    if (RBDrawingStateBeginCGContext((uint64_t)v11, *(_DWORD *)(a1 + 460), 1.0))
    {
      CGContextGetDelegate();
      CGContextGetRenderingState();
      CGContextGetGState();
      CGSoftMaskDelegateDrawSoftMask();
      RBDrawingStateEndCGContext((uint64_t)v11, v12, v13);
    }
    if (Background) {
      RBDrawingStateDrawLayer((int8x16_t *)v10, v11, 0, 1.0);
    }
    RBDrawingStateClipLayer(*(__n128 **)(a1 + 440), v10, 0, 1.0);
  }
}

void sub_2141B9B70(_Unwind_Exception *a1)
{
  CFRelease(v2);
  CFRelease(v1);
  _Unwind_Resume(a1);
}

RB::XML::Document *RB::ContextDelegate::add_shadow_style(uint64_t a1)
{
  Data = (double *)CGStyleGetData();
  Color = (CGColor *)CGStyleGetColor();
  double v4 = RBColorFromCGColor2(Color, *(_DWORD *)(a1 + 528));
  float v6 = *(float *)&v4;
  float v8 = v7;
  float v10 = v9;
  float v11 = fabsf(*(float *)&v4 + 1.0);
  float v12 = fabsf(v8 + 1.0);
  if (v11 < v12) {
    float v11 = v12;
  }
  float v13 = fabsf(v10 + 1.0);
  if (v11 >= v13) {
    float v13 = v11;
  }
  if (v13 >= 0.001)
  {
    float v16 = v5;
    float v17 = Data[5];
    float v18 = 0.0;
    float v19 = fmaxf(v17 * 0.5, 0.0);
    float v20 = Data[2] * 0.0174532925;
    float v21 = Data[1] * 0.0174532925;
    if (v21 <= 1.5691)
    {
      if (v21 >= 0.0017453)
      {
        double v22 = Data[4];
        float v18 = v22 / tanf(v21);
      }
      else
      {
        float v18 = 3.4028e38;
      }
    }
    __float2 v23 = __sincosf_stret(v20);
    double v24 = (float)-(float)(v18 * v23.__cosval);
    double v25 = (float)-(float)(v18 * v23.__sinval);
    char v26 = 2 * (CGStyleGetDrawOrdering() == 0);
    uint32x2_t v27 = *(__n128 **)(a1 + 440);
    return RBDrawingStateAddShadowStyle(v27, 0, v26, v19, v24, v25, v6, v8, v10, v16);
  }
  else
  {
    uint64_t result = (RB::XML::Document *)[(id)RBDrawingStateGetDisplayList(*(void *)(a1 + 440)) CGStyleHandler];
    if (result)
    {
      float64x2_t v15 = (uint64_t (*)(void))*((void *)result + 2);
      return (RB::XML::Document *)v15();
    }
  }
  return result;
}

RB::XML::DisplayList *RB::ContextDelegate::add_gaussian_blur_style(uint64_t a1)
{
  double v2 = *(double *)(CGStyleGetData() + 8) * 0.5;
  CGFloat v3 = *MEMORY[0x263F001A0];
  CGFloat v4 = *(double *)(MEMORY[0x263F001A0] + 8);
  CGFloat v5 = *(double *)(MEMORY[0x263F001A0] + 16);
  CGFloat v6 = *(double *)(MEMORY[0x263F001A0] + 24);
  float v7 = *(__n128 **)(a1 + 440);
  return RBDrawingStateAddBlurFilter(v7, 0, v2, v3, v4, v5, v6);
}

RB::XML::DisplayList *RB::ContextDelegate::add_color_matrix_style(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t Data = CGStyleGetData();
  uint64_t v3 = 0;
  CGFloat v4 = (float64x2_t *)(Data + 8);
  do
  {
    float64x2_t v6 = *v4;
    float64x2_t v5 = v4[1];
    v4 += 2;
    *(float32x4_t *)&v8[v3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v6), v5);
    v3 += 4;
  }
  while (v3 != 20);
  return RBDrawingStateAddColorMatrixFilter(*(__n128 **)(a1 + 440), v8, 0);
}

uint64_t RB::ContextDelegate::draw_shading_in_shape(uint64_t a1, int a2, CGShading *a3, float64x2_t *a4)
{
  uint64_t v6 = RB::ContextDelegate::set_shading((RB::ContextDelegate *)a1, a3, (const RB::AffineTransform *)a4);
  if (v6)
  {
    CGShadingGetBounds();
    double x = v26.origin.x;
    double y = v26.origin.y;
    double width = v26.size.width;
    double height = v26.size.height;
    BOOL IsInfinite = CGRectIsInfinite(v26);
    float v12 = *(_RBDrawingState **)(a1 + 440);
    float v13 = (uint64_t *)(a1 + 8);
    if (!IsInfinite)
    {
      float v12 = RBDrawingStateInit(*(RB::DisplayList::State **)(a1 + 440));
      RBDrawingStateClipShape((__n128 *)v12, *v13, 0);
      if (a4)
      {
        float64x2_t v14 = a4[1];
        v25[0] = *a4;
        v25[1] = v14;
        v25[2] = a4[2];
        RBDrawingStateSetCTM((RB::DisplayList::State *)v12, v25);
      }
      float v13 = (uint64_t *)(a1 + 536);
      float64x2_t v15 = *(void **)(a1 + 536);
      if (!v15)
      {
        float64x2_t v15 = objc_opt_new();

        *float v13 = (uint64_t)v15;
      }
      objc_msgSend(v15, "setRect:", x, y, width, height);
      RBDrawingStateClipShape((__n128 *)v12, *v13, 0);
      [(id)*v13 setInfinite];
    }
    uint64_t v16 = *v13;
    float v17 = *(RBFill **)(a1 + 16);
    CGGStateGetAlpha();
    float v19 = v18;
    if (!*(void *)(a1 + 360)) {
      float v19 = *(float *)(a1 + 456) * v19;
    }
    unsigned int CompositeOperation = CGGStateGetCompositeOperation();
    if (CompositeOperation > 0x1B) {
      unsigned int v21 = 0;
    }
    else {
    RBDrawingStateDrawShape((__n128 *)v12, v16, v17, v21, v19);
    }
    if (!IsInfinite) {
      RBDrawingStateDestroy((RB::XML::Document *)v12, v22, v23);
    }
  }
  return v6;
}

uint64_t RB::ContextDelegate::set_shading(RB::ContextDelegate *this, CGShading *a2, const RB::AffineTransform *a3)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  int Type = CGShadingGetType();
  Descriptor = (double *)CGShadingGetDescriptor();
  if (Type == 3)
  {
    int v39 = 3;
    int8x8_t v37 = a3;
    int32x2_t v38 = Descriptor;
  }
  else
  {
    if (Type != 2)
    {
      if (Type == 1 && *((unsigned char *)Descriptor + 16) && *((unsigned char *)Descriptor + 40))
      {
        int v39 = 1;
        int8x8_t v37 = a3;
        int32x2_t v38 = Descriptor;
        goto LABEL_12;
      }
      return 0;
    }
    if (!*((unsigned char *)Descriptor + 24) || !*((unsigned char *)Descriptor + 56)) {
      return 0;
    }
    int v39 = 2;
    int8x8_t v37 = a3;
    int32x2_t v38 = Descriptor;
  }
LABEL_12:
  MEMORY[0x270FA5388](Descriptor, v7);
  long long v36 = 0u;
  long long v34 = 0u;
  memset(v35, 0, sizeof(v35));
  memset(v33, 0, sizeof(v33));
  long long v32 = 0u;
  long long v30 = 0u;
  memset(v31, 0, sizeof(v31));
  memset(v29, 0, sizeof(v29));
  long long v28 = 0u;
  memset(v27, 0, sizeof(v27));
  ColorSpace = (CGColorSpace *)CGShadingGetColorSpace();
  size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(ColorSpace);
  unint64_t RangeDimension = CGFunctionGetRangeDimension();
  unint64_t v12 = RangeDimension;
  if (RangeDimension <= NumberOfComponents + 1) {
    unint64_t v13 = NumberOfComponents + 1;
  }
  else {
    unint64_t v13 = RangeDimension;
  }
  MEMORY[0x270FA5388](RangeDimension, 8 * v13);
  float64x2_t v15 = (float64x2_t *)((char *)v27 - v14);
  bzero((char *)v27 - v14, v16);
  Domain = (double *)CGFunctionGetDomain();
  if (Domain)
  {
    double v18 = (Domain[1] - *Domain) * 0.0666666667;
    double v19 = trunc(*Domain);
  }
  else
  {
    double v19 = 0.0;
    double v18 = 0.0666666667;
  }
  unint64_t v20 = 0;
  int8x8_t v40 = v27;
  unsigned int v21 = (_DWORD *)v27 + 2;
  do
  {
    double v42 = v19 + v18 * (double)v20;
    CGFunctionEvaluate();
    if (v12 < NumberOfComponents + 1) {
      v15->f64[NumberOfComponents] = 1.0;
    }
    *(v21 - 2) = RBColorFromComponents2(ColorSpace, v15, *((_DWORD *)this + 132)).u32[0];
    *(v21 - 1) = v22;
    _DWORD *v21 = v23;
    v21[1] = v24;
    v21 += 4;
    ++v20;
  }
  while (v20 != 16);
  switch(v39)
  {
    case 1:
      objc_msgSend(*((id *)this + 2), "setAxialGradientStartPoint:endPoint:stopCount:colors:locations:flags:", 16, v40, 0, 0, *v38, v38[1], v38[3], v38[4], v27[0], *(void *)&v27[1], *(_OWORD *)((char *)&v27[1] + 8), *((void *)&v27[2] + 1), v28, v29[0], *(_OWORD *)&v29[1], v29[3], v30,
        v31[0],
        *(_OWORD *)&v31[1],
        v31[3],
        v32,
        v33[0],
        *(_OWORD *)&v33[1],
        v33[3],
        v34,
        v35[0],
        *(_OWORD *)&v35[1],
        v35[3],
        v36);
      break;
    case 2:
      objc_msgSend(*((id *)this + 2), "setRadialGradientStartCenter:startRadius:endCenter:endRadius:stopCount:colors:locations:flags:", 16, v40, 0, 0, *v38, v38[1], v38[2], v38[4], v38[5], v38[6], v27[0], *(void *)&v27[1], *(_OWORD *)((char *)&v27[1] + 8), *((void *)&v27[2] + 1), v28, v29[0], *(_OWORD *)&v29[1],
        v29[3],
        v30,
        v31[0],
        *(_OWORD *)&v31[1],
        v31[3],
        v32,
        v33[0],
        *(_OWORD *)&v33[1],
        v33[3],
        v34,
        v35[0],
        *(_OWORD *)&v35[1],
        v35[3],
        v36);
      break;
    case 3:
      objc_msgSend(*((id *)this + 2), "setConicGradientCenter:angle:stopCount:colors:locations:flags:", 16, v40, 0, 0, *v38, v38[1], v38[2], v27[0], *(void *)&v27[1], *(_OWORD *)((char *)&v27[1] + 8), *((void *)&v27[2] + 1), v28, v29[0], *(_OWORD *)&v29[1], v29[3], v30, v31[0],
        *(_OWORD *)&v31[1],
        v31[3],
        v32,
        v33[0],
        *(_OWORD *)&v33[1],
        v33[3],
        v34,
        v35[0],
        *(_OWORD *)&v35[1],
        v35[3],
        v36);
      break;
    default:
      abort();
  }
  if (v37)
  {
    double v25 = (void *)*((void *)this + 2);
    long long v26 = *((_OWORD *)v37 + 1);
    v41[0] = *(_OWORD *)v37;
    v41[1] = v26;
    v41[2] = *((_OWORD *)v37 + 2);
    [v25 concat:v41];
  }
  return 1;
}

atomic_uint *RB::ContextDelegate::mask_color_in_shape(uint64_t a1, CGColor *a2, int a3, uint64_t a4, unsigned int a5, float a6)
{
  unint64_t v12 = RBDrawingStateInit(*(RB::DisplayList::State **)(a1 + 440));
  unint64_t v13 = RBDrawingStateBeginLayer((RB::DisplayList::State *)v12, 0);
  RBDrawingStateDrawShape((__n128 *)v13, *(void *)(a1 + 8), *(RBFill **)(a1 + 16), 0, 1.0);
  RBDrawingStateClipLayer((__n128 *)v12, v13, 0, 1.0);
  RB::ContextDelegate::set_color_in_shape(a1, a2, a3, a4, 0);
  [*(id *)(a1 + 8) setInfinite];
  RBDrawingStateDrawShape((__n128 *)v12, *(void *)(a1 + 8), *(RBFill **)(a1 + 16), a5, a6);
  return RBDrawingStateDestroy((RB::XML::Document *)v12, v14, v15);
}

uint64_t RB::ContextDelegate::check_type(RB::ContextDelegate *this, CGContext *a2)
{
  uint64_t result = CGContextGetDelegate();
  if (result) {
    return CGContextDelegateGetCallback() == (void)RB::ContextDelegate::get_bounds;
  }
  return result;
}

uint64_t RB::ContextDelegate::draw_path_(uint64_t a1, uint64_t a2, const char *a3, int a4, uint64_t a5, char a6)
{
  uint64_t Info = CGContextDelegateGetInfo();
  RB::ContextDelegate::update(Info, a3, a2, 0);
  if (a6)
  {
    int8x16_t v33 = (int8x16_t)xmmword_2142181D0;
    int8x16_t v32 = (int8x16_t)xmmword_2142181C0;
    int8x16_t v12 = 0uLL;
  }
  else
  {
    uint64_t CTM = (int8x16_t *)CGGStateGetCTM();
    int8x16_t v34 = *CTM;
    int8x16_t v29 = CTM[1];
    int8x16_t v30 = CTM[2];
    int8x16_t v39 = *CTM;
    int8x16_t v40 = v29;
    int8x16_t v41 = v30;
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v39)) {
      unint64_t v14 = -1;
    }
    else {
      unint64_t v14 = 0;
    }
    int8x16_t v15 = (int8x16_t)vdupq_n_s64(v14);
    int8x16_t v32 = vbslq_s8(v15, v39, v34);
    int8x16_t v33 = vbslq_s8(v15, v40, v29);
    int8x16_t v12 = vbslq_s8(v15, v41, v30);
  }
  int8x16_t v31 = v12;
  if (a4 == 2) {
    goto LABEL_15;
  }
  size_t v16 = *(void **)(Info + 8);
  v38[0] = v32;
  v38[1] = v33;
  v38[2] = v12;
  [v16 setPath:a5 transform:v38];
  BOOL v17 = a4 == 1 || a4 == 4;
  BOOL v18 = v17;
  objc_msgSend(*(id *)(Info + 8), "setEOFill:", v18, *(_OWORD *)&v29);
  FillColor = (CGColor *)CGGStateGetFillColor();
  RB::ContextDelegate::set_color_in_shape(Info, FillColor, (int)a3, a2, 1);
  if (a4 >= 2)
  {
LABEL_15:
    v39.i64[0] = 0;
    double v37 = 0.0;
    if (CGGStateGetLineDash()) {
      uint64_t Pattern = CGDashGetPattern();
    }
    else {
      uint64_t Pattern = 0;
    }
    RBDrawingStateGetCTM(*(void *)(Info + 440), (uint64_t)v36);
    CGGStateGetAdjustedLineWidth();
    double v22 = v21;
    int v23 = *(void **)(Info + 8);
    v35[0] = v32;
    v35[1] = v33;
    Point v35[2] = v31;
    uint64_t LineCap = CGGStateGetLineCap();
    uint64_t LineJoin = CGGStateGetLineJoin();
    CGGStateGetMiterLimit();
    [v23 setStrokedPath:a5 transform:v35 lineWidth:LineCap lineCap:LineJoin lineJoin:Pattern miterLimit:v39.i64[0] dashPhase:v22 dashPattern:v26 dashCount:v37];
    [*(id *)(Info + 8) setEOFill:0];
    StrokeColor = (CGColor *)CGGStateGetStrokeColor();
    RB::ContextDelegate::set_color_in_shape(Info, StrokeColor, (int)a3, a2, 1);
  }
  return 0;
}

uint64_t RB::ContextDelegate::draw_image_(double a1, double a2, double a3, double a4, uint64_t a5, uint64_t a6, const char *a7, CGImage *a8, float64x2_t *a9)
{
  uint64_t Info = CGContextDelegateGetInfo();
  RB::ContextDelegate::update(Info, a7, a6, 0);
  objc_msgSend(*(id *)(Info + 8), "setRect:", a1, a2, a3, a4);
  if (a9)
  {
    float Width = (float)CGImageGetWidth(a8);
    size_t Height = CGImageGetHeight(a8);
    v20.f32[0] = Width;
    v20.f32[1] = (float)Height;
    v21.f32[0] = a1;
    float v22 = a2;
    v23.f32[0] = a3;
    float v24 = a4;
    float32x2_t v25 = vcvt_f32_f64(a9[1]);
    v21.f32[1] = v22 + v24;
    v23.f32[1] = -v24;
    *(float32x2_t *)&long long v26 = vsub_f32(v21, vdiv_f32(vmul_f32(v23, vcvt_f32_f64(*a9)), v25));
    long long v54 = v26;
    float32x2_t v28 = vdiv_f32(vmul_f32(v20, v23), v25);
    float v27 = v28.f32[1];
    float v55 = v28.f32[0];
    float v29 = *((float *)&v26 + 1);
  }
  else
  {
    *(float *)&long long v18 = a1;
    long long v54 = v18;
    float v30 = a2;
    float v31 = a3;
    float v55 = v31;
    float v32 = a4;
    float v29 = v30 + v32;
    float v27 = -v32;
  }
  unsigned int v33 = CGGStateGetInterpolationQuality() - 1;
  if (v33 > 3) {
    uint64_t v34 = 7;
  }
  else {
    uint64_t v34 = dword_21421A3D0[v33];
  }
  CGGStateGetAlpha();
  float v36 = v35;
  if (!*(void *)(Info + 360)) {
    float v36 = *(float *)(Info + 456) * v36;
  }
  float v57 = v36;
  unsigned int CompositeOperation = CGGStateGetCompositeOperation();
  if (CompositeOperation > 0x1B) {
    unsigned int v38 = 0;
  }
  else {
  double v39 = v29;
  }
  double v40 = v27;
  if (!CGImageIsMask(a8))
  {
    uint64_t v51 = 0;
    LODWORD(v41) = 1065353216;
    LODWORD(v42) = 1065353216;
    LODWORD(v43) = 1065353216;
    LODWORD(v44) = 1065353216;
LABEL_17:
    uint64_t v52 = *(void **)(Info + 16);
    v58[0] = v55;
    v58[1] = 0.0;
    v58[2] = 0.0;
    v58[3] = v40;
    v58[4] = *(float *)&v54;
    v58[5] = v39;
    objc_msgSend(v52, "setImage:transform:interpolation:tintColor:flags:", a8, v58, v34, v51, v41, v42, v43, v44, v54);
    RBDrawingStateDrawShape(*(__n128 **)(Info + 440), *(void *)(Info + 8), *(RBFill **)(Info + 16), v38, v57);
    return 0;
  }
  FillColor = (CGColor *)CGGStateGetFillColor();
  if (!CGColorGetPattern(FillColor))
  {
    double v41 = RBColorFromCGColor2(FillColor, *(_DWORD *)(Info + 528));
    uint64_t v51 = 1;
    goto LABEL_17;
  }
  int32x2_t v50 = *(void **)(Info + 16);
  v59[0] = v55;
  v59[1] = 0.0;
  v59[2] = 0.0;
  v59[3] = v40;
  Point v59[4] = *(float *)&v54;
  v59[5] = v39;
  LODWORD(v46) = 1065353216;
  LODWORD(v47) = 1065353216;
  LODWORD(v48) = 1065353216;
  LODWORD(v49) = 1065353216;
  objc_msgSend(v50, "setImage:transform:interpolation:tintColor:flags:", a8, v59, v34, 0, v46, v47, v48, v49);
  RB::ContextDelegate::mask_color_in_shape(Info, FillColor, (int)a7, a6, v38, v57);
  return 0;
}

uint64_t RB::ContextDelegate::draw_glyphs_removing_invalid(uint64_t a1, size_t size, uint64_t a3, uint64_t a4, unsigned __int16 *a5, _OWORD *a6, unint64_t a7)
{
  unint64_t v7 = a7;
  uint64_t v10 = a4;
  v25[1] = *MEMORY[0x263EF8340];
  if ((a7 & 0x8000000000000000) != 0)
  {
    BOOL v17 = 0;
    int8x16_t v15 = 0;
    int v16 = 0;
LABEL_13:
    char v19 = 1;
    goto LABEL_14;
  }
  if (2 * a7 <= 0x1000)
  {
    MEMORY[0x270FA5388](a1, 2 * a7);
    int8x16_t v15 = (char *)v25 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v15, v18);
    int v16 = 0;
  }
  else
  {
    unint64_t v14 = (char *)malloc_type_malloc(2 * a7, 0xD8A7280FuLL);
    int8x16_t v15 = v14;
    int v16 = 1;
  }
  if (v7 >> 60)
  {
    a4 = v10;
    BOOL v17 = 0;
    goto LABEL_13;
  }
  if (16 * v7 <= 0x1000)
  {
    MEMORY[0x270FA5388](v14, 16 * v7);
    BOOL v17 = (char *)v25 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v17, v20);
    if (!v7) {
      goto LABEL_22;
    }
    a4 = v10;
    goto LABEL_13;
  }
  BOOL v17 = (char *)malloc_type_malloc(16 * v7, 0xEEF7D836uLL);
  if (!v7)
  {
LABEL_21:
    free(v17);
    goto LABEL_22;
  }
  a4 = v10;
  char v19 = 0;
LABEL_14:
  uint64_t v21 = 0;
  do
  {
    int v23 = *a5++;
    __int16 v22 = v23;
    if (v23 != 0xFFFF)
    {
      *(_WORD *)&v15[2 * v21] = v22;
      *(_OWORD *)&v17[16 * v21++] = *a6;
    }
    ++a6;
    --v7;
  }
  while (v7);
  if (v21) {
    RB::ContextDelegate::draw_glyphs(a1, size, a3, a4, v15, v17);
  }
  if ((v19 & 1) == 0) {
    goto LABEL_21;
  }
LABEL_22:
  if (v16) {
    free(v15);
  }
  return 0;
}

void sub_2141BAB24(_Unwind_Exception *exception_object)
{
  if (v2) {
    free(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL RB::make_gradient(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  BOOL v6 = (a5 & 3) != 3;
  CGGradientGetColorSpace();
  CGGradientApply();
  return v6;
}

RB::LayerContextDelegate *RB::LayerContextDelegate::LayerContextDelegate(RB::LayerContextDelegate *this, const CGRect *a2, double a3)
{
  *(void *)RB::ContextDelegate::ContextDelegate(this) = &unk_26C4ED260;
  BOOL v6 = objc_opt_new();
  *((void *)this + 70) = v6;
  CGSize size = a2->size;
  *(CGPoint *)((char *)this + 568) = a2->origin;
  *(CGSize *)((char *)this + 584) = size;
  [v6 setDefaultColorSpace:1];
  objc_msgSend(*((id *)this + 70), "setContentRect:", *((double *)this + 71), *((double *)this + 72), *((double *)this + 73), *((double *)this + 74));
  State = (_RBDrawingState *)RBDisplayListGetState(*((void *)this + 70));
  RB::ContextDelegate::begin(this, State, 1.0, a3, 0);
  return this;
}

void sub_2141BACEC(_Unwind_Exception *a1)
{
  RB::ContextDelegate::~ContextDelegate(v1);
  _Unwind_Resume(a1);
}

void RB::LayerContextDelegate::~LayerContextDelegate(id *this, const char *a2, _RBDrawingState *a3)
{
  *this = &unk_26C4ED260;
  RB::ContextDelegate::end((RB::ContextDelegate *)this, a2, a3);

  RB::ContextDelegate::~ContextDelegate((RB::ContextDelegate *)this);
}

{
  uint64_t vars8;

  RB::LayerContextDelegate::~LayerContextDelegate(this, a2, a3);
  JUMPOUT(0x21669AC10);
}

void sub_2141BAD6C(_Unwind_Exception *a1)
{
  RB::ContextDelegate::~ContextDelegate((RB::ContextDelegate *)v1);
  _Unwind_Resume(a1);
}

void RB::make_gradient(CGGradient *,RBColor *,double *,unsigned long,RBColorSpace,unsigned int)::$_1::__invoke(uint64_t **a1, float64x2_t *a2, double a3)
{
  unsigned __int32 v5 = RBColorFromComponents2((CGColorSpace *)a1[3], a2, *((_DWORD *)a1 + 8)).u32[0];
  BOOL v6 = *a1;
  uint64_t v7 = **a1;
  float v8 = (unsigned __int32 *)&a1[1][2 * v7];
  unsigned __int32 *v8 = v5;
  v8[1] = v9;
  int32x2_t v8[2] = v10;
  void v8[3] = v11;
  *(double *)&a1[2][v7] = a3;
  *BOOL v6 = v7 + 1;
}

void *RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,8ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 18) + (*((void *)__dst + 18) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 18) + (*((void *)__dst + 18) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned long,16ul>(*((void **)__dst + 16), __dst, 8uLL, (size_t *)__dst + 18, v3);
  *((void *)__dst + 16) = result;
  return result;
}

void *RB::vector<RB::ContextDelegate::Layer,4ul,unsigned long>::reserve_slow(void *__dst, unint64_t a2)
{
  if (*((void *)__dst + 42) + (*((void *)__dst + 42) >> 1) <= a2) {
    unint64_t v3 = a2;
  }
  else {
    unint64_t v3 = *((void *)__dst + 42) + (*((void *)__dst + 42) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned long,80ul>(*((void **)__dst + 40), __dst, 4uLL, (unint64_t *)__dst + 42, v3);
  *((void *)__dst + 40) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,80ul>(void *__src, void *__dst, unint64_t a3, unint64_t *a4, unint64_t a5)
{
  uint64_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      unint64_t v9 = a3;
      memcpy(__dst, __src, 80 * a5);
      free(v7);
      int8x16_t v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(80 * a5);
    unint64_t v9 = v8 / 0x50;
    if (v8 / 0x50 != *a4)
    {
      unsigned __int32 v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      int8x16_t v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 80 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

void RB::ObjectTable::adopt(RB::ObjectTable *this, CFTypeRef cf)
{
  if (cf)
  {
    uint64_t v4 = *((unsigned int *)this + 2);
    int v5 = v4 - 16;
    if (v4 < 0x10) {
      int v5 = 0;
    }
    unsigned int v6 = -v5;
    if (v4 <= -v5)
    {
LABEL_8:
      unsigned int v10 = v4 + 1;
      if (*((_DWORD *)this + 3) < (v4 + 1))
      {
        RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::reserve_slow((uint64_t)this, v10);
        LODWORD(v4) = *((_DWORD *)this + 2);
        unsigned int v10 = v4 + 1;
      }
      *(void *)(*(void *)this + 8 * v4) = cf;
      *((_DWORD *)this + 2) = v10;
    }
    else
    {
      uint64_t v7 = v4 - v6;
      size_t v8 = (const void **)(*(void *)this + 8 * v6);
      while (1)
      {
        CFTypeRef v9 = *v8++;
        if (v9 == cf) {
          break;
        }
        if (!--v7) {
          goto LABEL_8;
        }
      }
      CFRelease(cf);
    }
  }
}

_DWORD *RB::ObjectTable::adopt(_DWORD *result, unint64_t a2)
{
  if (a2)
  {
    int v2 = result;
    uint64_t v3 = a2 | 1;
    uint64_t v4 = result[2];
    int v5 = v4 - 16;
    if (v4 < 0x10) {
      int v5 = 0;
    }
    unsigned int v6 = -v5;
    if (v4 <= -v5)
    {
LABEL_8:
      unsigned int v10 = v4 + 1;
      if (result[3] < (v4 + 1))
      {
        uint64_t result = RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::reserve_slow((uint64_t)result, v10);
        LODWORD(v4) = v2[2];
        unsigned int v10 = v4 + 1;
      }
      *(void *)(*(void *)v2 + 8 * v4) = v3;
      v2[2] = v10;
    }
    else
    {
      uint64_t v7 = v4 - v6;
      size_t v8 = (uint64_t *)(*(void *)result + 8 * v6);
      while (1)
      {
        uint64_t v9 = *v8++;
        if (v9 == v3) {
          break;
        }
        if (!--v7) {
          goto LABEL_8;
        }
      }
      unsigned __int32 v11 = **(uint64_t (***)(unint64_t))a2;
      return (_DWORD *)v11(a2);
    }
  }
  return result;
}

double RB::Fill::ImageData::concat(RB::Fill::ImageData *this, float64x2_t *a2)
{
  uint64_t v4 = (float *)((char *)this + 32);
  float64x2_t v5 = a2[1];
  float64x2_t v13 = *a2;
  float64x2_t v14 = v5;
  float64x2_t v15 = a2[2];
  if (RB::AffineTransform::invert((RB::AffineTransform *)&v13)) {
    unsigned int v6 = &v13;
  }
  else {
    unsigned int v6 = a2;
  }
  float64x2_t v7 = v6[1];
  float64x2_t v8 = v6[2];
  float64x2_t v13 = *v6;
  float64x2_t v14 = v7;
  float64x2_t v15 = v8;
  RB::operator*(v4, &v13, (uint64_t)v11);
  double result = *(double *)v11;
  long long v10 = v11[1];
  *((_OWORD *)this + 2) = v11[0];
  *((_OWORD *)this + 3) = v10;
  *((_DWORD *)this + 16) = v12;
  return result;
}

uint64_t RB::Fill::ImageData::can_append_color_matrix(int a1, float16x4_t *this, char a3, __int16 a4)
{
  if ((a4 & 0xFF00) != 0) {
    return 0;
  }
  if (RB::ColorMatrix::is_alpha_multiply(this, a3)) {
    return 1;
  }
  return RB::ColorMatrix::is_diagonal(this);
}

float16x4_t RB::Fill::ImageData::append_color_matrix(uint64_t a1, RB::ColorMatrix *this, int a3)
{
  if (RB::ColorMatrix::is_alpha_multiply((float16x4_t *)this, a3))
  {
    v6.n64_u64[0] = RB::ColorMatrix::alpha_multiply_color(this, a3).n64_u64[0];
    if (a3)
    {
      __asm { FCMP            H1, #0 }
      if (_ZF)
      {
        LOWORD(_H1) = 0;
      }
      else
      {
        __asm { FCVT            S1, H1 }
        unsigned int v14 = _S1;
        float32x2_t v15 = vrecpe_f32((float32x2_t)_S1);
        _D1 = vmul_f32(vrecps_f32((float32x2_t)v14, v15), v15);
        _D1.i32[0] = vmul_f32(_D1, vrecps_f32((float32x2_t)v14, _D1)).u32[0];
        __asm { FCVT            H1, S1 }
      }
      v7.n64_u32[0] = vmul_n_f16((float16x4_t)v6.n64_u64[0], _H1).u32[0];
      v7.n64_u16[2] = vmulh_lane_f16(_H1, (float16x4_t)v6.n64_u64[0], 2);
      v7.n64_u16[3] = v6.n64_u16[3];
      v6.n64_u64[0] = v7.n64_u64[0];
    }
    *(short float *)v7.n64_u16 = vmulh_lane_f16(*(short float *)(a1 + 74), (float16x4_t)v6.n64_u64[0], 3);
    float16x4_t v25 = (float16x4_t)vdup_lane_s16((int16x4_t)v7.n64_u64[0], 0);
    v25.i16[3] = *(_WORD *)(a1 + 74);
    float16x4_t result = vmul_f16(v25, (float16x4_t)v6.n64_u64[0]);
    *(float16x4_t *)(a1 + 68) = result;
    *(_WORD *)(a1 + 76) = 0;
    *(_WORD *)(a1 + 78) |= 0x1000u;
  }
  else
  {
    float16x4_t v18 = *(float16x4_t *)this;
    if (a3)
    {
      __asm { FCMP            H4, #0 }
      if (_ZF)
      {
        LOWORD(_H4) = 0;
      }
      else
      {
        __asm { FCVT            S4, H4 }
        unsigned int v21 = _S4;
        float32x2_t v22 = vrecpe_f32((float32x2_t)_S4);
        _D4 = vmul_f32(vrecps_f32((float32x2_t)v21, v22), v22);
        _D4.i32[0] = vmul_f32(_D4, vrecps_f32((float32x2_t)v21, _D4)).u32[0];
        __asm { FCVT            H4, S4 }
      }
      v18.i16[1] = WORD1(*((void *)this + 1));
      v18.i32[0] = vmul_n_f16(v18, _H4).u32[0];
      *(short float *)&v18.i16[2] = _H4 * COERCE_SHORT_FLOAT(HIDWORD(*((void *)this + 2)));
    }
    else
    {
      v18.i16[1] = WORD1(*((void *)this + 1));
      v18.i16[2] = WORD2(*((void *)this + 2));
    }
    v18.i16[3] = HIWORD(*((void *)this + 3));
    float16x4_t result = vmul_f16(*(float16x4_t *)(a1 + 68), v18);
    *(float16x4_t *)(a1 + 68) = result;
  }
  return result;
}

uint64_t RB::Fill::ImageData::can_mix(float32x2_t *this, float32x2_t *a2)
{
  uint32x2_t v2 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(this[1], a2[1]), (int8x8_t)vceq_f32(*this, *a2));
  if ((vpmin_u32(v2, v2).u32[0] & 0x80000000) == 0 || this[9].u16[3] != a2[9].u16[3]) {
    return 0;
  }
  if (this[2].f32[0] == a2[2].f32[0]
    && this[2].f32[1] == a2[2].f32[1]
    && this[3].f32[0] == a2[3].f32[0]
    && this[3].f32[1] == a2[3].f32[1]
    && RB::ProjectionMatrix::operator==((float *)&this[4], (float *)&a2[4])
    && (!this[9].i8[5] || !a2[9].i8[5] || this[9].u8[4] == a2[9].u8[4])
    && *(short float *)&this[8].i16[2] == *(short float *)&a2[8].i16[2]
    && *(short float *)&this[8].i16[3] == *(short float *)&a2[8].i16[3]
    && *(short float *)this[9].i16 == *(short float *)a2[9].i16
    && *(short float *)&this[9].i16[1] == *(short float *)&a2[9].i16[1])
  {
    return 4;
  }
  return 2;
}

BOOL RB::ProjectionMatrix::operator==(float *a1, float *a2)
{
  return *a1 == *a2
      && a1[1] == a2[1]
      && a1[2] == a2[2]
      && a1[3] == a2[3]
      && a1[4] == a2[4]
      && a1[5] == a2[5]
      && a1[6] == a2[6]
      && a1[7] == a2[7]
      && a1[8] == a2[8];
}

void RB::Fill::ImageData::mix(float32x4_t *this, const RB::DisplayList::Interpolator::Op *a2, float32x4_t *a3, float a4)
{
  this[1] = vmlaq_n_f32(this[1], vsubq_f32(a3[1], this[1]), a4);
  RB::ProjectionMatrix::mix(this + 2, a3 + 2, a4);
  RB::Fill::Color::mix((uint64_t)this[4].i64 + 4, (uint64_t)a3[4].i64 + 4, 0, a4);
}

float RB::Fill::ImageData::min_scale(RB::Fill::ImageData *this, const RB::AffineTransform *a2)
{
  uint64_t v2 = (*((unsigned char *)this + 79) & 0xF) - 1;
  float result = 1.0;
  if (v2 <= 8) {
    return flt_21421A4C0[v2];
  }
  return result;
}

uint64_t RB::Fill::set_image(uint64_t a1, uint64_t a2, char *a3, float64x2_t *a4, uint64_t a5, float a6)
{
  _S8 = a6;
  uint64_t v9 = a3;
  int v12 = *(unsigned __int8 *)(a5 + 78);
  if (v12 == 4 && *(float *)(a5 + 40) == 0.0 && *(float *)(a5 + 52) == 0.0)
  {
    if (*(float *)(a5 + 64) == 1.0) {
      int v12 = 1;
    }
    else {
      int v12 = 4;
    }
  }
  if (a3) {
    int v13 = v12;
  }
  else {
    int v13 = 0;
  }
  if (v13 == 4)
  {
    RB::operator*((float *)(a5 + 32), a4, (uint64_t)v70);
    RB::ProjectionMatrix::invert((RB::ProjectionMatrix *)v70);
    uint64_t v14 = *(void *)(a2 + 104);
    v15.i64[0] = (int)v14;
    v15.i64[1] = SHIDWORD(v14);
    __asm { FMOV            V1.2D, #0.5 }
    float64x2_t v20 = vmulq_f64(vcvtq_f64_s64(v15), _Q1);
    float64x2_t v21 = vnegq_f64(v20);
    float64x2_t v74 = v20;
    v21.f64[0] = 0.0;
    float64x2_t v72 = (float64x2_t)*(unint64_t *)&v20.f64[0];
    float64x2_t v73 = v21;
    RB::operator*(&v72, (uint64_t)v70, (uint64_t)v75);
    *(_OWORD *)float v70 = v75[0];
    *(_OWORD *)&v70[16] = v75[1];
    LODWORD(v71.f64[0]) = v76;
    int v22 = DWORD2(v75[0]);
    uint64_t v23 = *(void *)&v70[12];
    *(void *)a1 = *(void *)&v75[0];
    *(void *)(a1 + 8) = v23;
    int v24 = *(_DWORD *)&v70[20];
    *(_DWORD *)(a1 + 48) = v22;
    *(_DWORD *)(a1 + 52) = v24;
    *(void *)(a1 + 16) = *(void *)&v70[24];
    *(_DWORD *)(a1 + 56) = LODWORD(v71.f64[0]);
LABEL_12:
    char v25 = 0;
    *(void *)(a1 + 32) = *(void *)a5;
    _D0 = vadd_f32(*(float32x2_t *)(a5 + 8), *(float32x2_t *)a5);
    *(float32x2_t *)(a1 + 40) = _D0;
    goto LABEL_28;
  }
  float64x2_t v27 = vcvtq_f64_f32(*(float32x2_t *)(a5 + 44));
  float64x2_t v28 = vcvtq_f64_f32(*(float32x2_t *)(a5 + 56));
  *(float64x2_t *)float v70 = vcvtq_f64_f32(*(float32x2_t *)(a5 + 32));
  *(float64x2_t *)&v70[16] = v27;
  float64x2_t v71 = v28;
  v29.f64[0] = RB::operator*((float64x2_t *)v70, a4);
  float64x2_t v72 = v29;
  float64x2_t v73 = v30;
  float64x2_t v74 = v31;
  RB::AffineTransform::invert((RB::AffineTransform *)&v72);
  uint64_t v32 = *(void *)(a2 + 104);
  v33.i64[0] = (int)v32;
  v33.i64[1] = SHIDWORD(v32);
  __asm { FMOV            V1.2D, #0.5 }
  float64x2_t v35 = vmulq_f64(vcvtq_f64_s64(v33), _Q1);
  v36.i64[1] = *(void *)&v73.f64[1];
  float64x2_t v38 = vmulq_n_f64(v72, v35.f64[0]);
  float64x2_t v37 = vmlaq_laneq_f64(vaddq_f64(v38, v74), v73, v35, 1);
  *(float32x2_t *)&v35.f64[0] = vcvt_f32_f64(v38);
  *(float32x2_t *)&v38.f64[0] = vcvt_f32_f64(vmulq_n_f64(v73, -v35.f64[1]));
  *(float64_t *)a1 = v35.f64[0];
  *(float64_t *)(a1 + 8) = v38.f64[0];
  _D0 = vcvt_f32_f64(v37);
  *(float32x2_t *)(a1 + 16) = _D0;
  if ((v13 - 5) < 2)
  {
    *(void *)(a1 + 32) = *(void *)a5;
    uint64_t v39 = *(void *)(a5 + 16);
    HIDWORD(v39) = *(_DWORD *)(a5 + 24);
    *(void *)(a1 + 40) = v39;
    __asm { FMOV            V1.2S, #1.0 }
    *(float32x2_t *)(a1 + 48) = vsub_f32(_D1, vadd_f32(*(float32x2_t *)a5, *(float32x2_t *)(a5 + 8)));
    float32x2_t v41 = *(float32x2_t *)(a5 + 20);
    v41.i32[1] = *(_DWORD *)(a5 + 28);
    *(float32x2_t *)(a1 + 56) = vsub_f32(*(float32x2_t *)(a5 + 8), v41);
    float32x2_t v42 = *(float32x2_t *)(a5 + 16);
    v42.i32[1] = *(_DWORD *)(a5 + 24);
    float32x2_t v43 = *(float32x2_t *)(a5 + 20);
    v43.i32[1] = *(_DWORD *)(a5 + 28);
    float32x2_t v44 = vadd_f32(v43, v42);
    float32x2_t v45 = vsub_f32(_D1, v44);
    uint32x2_t v46 = (uint32x2_t)vceqz_f32(v45);
    int v47 = vpmin_u32(v46, v46).u32[0];
    BOOL v49 = v13 == 6 && v47 < 0;
    if (v13 == 5 || v49)
    {
      v38.f64[0] = *(float64_t *)(a5 + 8);
      float32x2_t v53 = vsub_f32(*(float32x2_t *)&v38.f64[0], v44);
      float32x2_t v54 = vrecpe_f32(v53);
      float32x2_t v55 = vmul_f32(vrecps_f32(v53, v54), v54);
      *(int32x2_t *)&v38.f64[0] = vcgt_f32((float32x2_t)vdup_n_s32(0x3727C5ACu), vabd_f32(*(float32x2_t *)&v38.f64[0], v44));
      float32x2_t v56 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32((int32x4_t)v38), (int8x8_t)vdup_n_s32(0x47C35000u), (int8x8_t)vmul_f32(v55, vrecps_f32(v53, v55)));
      *(float32x2_t *)(a1 + 64) = vmul_f32(v56, v45);
      float32x2_t v57 = *(float32x2_t *)(a5 + 16);
      v57.i32[1] = *(_DWORD *)(a5 + 24);
      _D0 = vmul_f32(v56, vmla_f32(vneg_f32(vmla_f32(v57, *(float32x2_t *)a5, v45)), *(float32x2_t *)(a5 + 8), v57));
      *(float32x2_t *)(a1 + 72) = _D0;
      char v25 = 1;
      LOBYTE(v13) = 5;
    }
    else
    {
      float32x2_t v50 = (float32x2_t)vdup_n_s32(0x3727C5ACu);
      *(int32x2_t *)v36.i8 = vcgt_f32(v50, vabs_f32(v45));
      float32x2_t v51 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v36), (int8x8_t)v50, (int8x8_t)v45);
      float32x2_t v52 = vneg_f32(v51);
      _D0 = vdiv_f32(_D1, v51);
      *(float32x2_t *)(a1 + 64) = v52;
      *(float32x2_t *)(a1 + 72) = _D0;
      char v25 = 1;
      LOBYTE(v13) = 6;
    }
  }
  else
  {
    if (v13 == 1) {
      goto LABEL_12;
    }
    if (v13 == 2)
    {
      *(void *)(a1 + 32) = *(void *)a5;
      _D0 = *(float32x2_t *)(a5 + 8);
      *(float32x2_t *)(a1 + 40) = _D0;
    }
    char v25 = 1;
  }
LABEL_28:
  __asm { FCVT            H0, S8 }
  LOWORD(v72.f64[0]) = *(_WORD *)(a5 + 68);
  *(_DWORD *)((char *)v72.f64 + 2) = *(_DWORD *)(a5 + 70);
  *(short float *)_D0.i16 = *(short float *)(a5 + 74) * *(short float *)_D0.i16;
  HIWORD(v72.f64[0]) = _D0.i16[0];
  LOWORD(v72.f64[1]) = *(_WORD *)(a5 + 76);
  float16x4_t v58 = RB::Fill::Color::prepare((uint64_t)&v72, *(unsigned __int8 *)(a2 + 124), *(double *)&_D0);
  *(float16x4_t *)(a1 + 24) = v58;
  uint16x4_t v59 = (uint16x4_t)vmvn_s8((int8x8_t)vceq_f16(v58, (float16x4_t)0x3C003C003C003C00));
  v59.i16[0] = vmaxv_u16(v59);
  unsigned int v60 = v13 & 7 | ((((unsigned __int32)v59.i32[0] >> 15) & 1) << 6);
  *(_DWORD *)(a1 + 80) = v60;
  int v61 = v60 | (*(unsigned __int16 *)(a5 + 78) >> 5) & 0x80;
  *(_DWORD *)(a1 + 80) = v61;
  int v62 = v61 | (*(unsigned __int16 *)(a5 + 78) >> 4) & 0x200;
  *(_DWORD *)(a1 + 80) = v62;
  if (v9)
  {
    *(_DWORD *)(a1 + 80) = v62 | (16 * (v9[80] & 3));
    unsigned int v63 = RB::Fill::ImageData::image_filter(a5, a4, *(int32x2_t *)(v9 + 64));
    if (v63 == 4)
    {
      *(_DWORD *)(a1 + 80) |= 8u;
    }
    else if (v63 == 3)
    {
      if (*(unsigned __int8 *)(***(void ***)a2 + 283) < *((unsigned __int8 *)RB::pixel_format_traits(*((void *)v9 + 7), v64)+ 10))unsigned int v63 = 1; {
      else
      }
        unsigned int v63 = 3;
    }
    int v66 = RB::image_filter_sampler(v63);
    if (v66 == 5) {
      char v67 = v25;
    }
    else {
      char v67 = 1;
    }
    if (v67)
    {
      char v65 = v66;
    }
    else
    {
      float32x2_t v68 = *(float32x2_t *)(a1 + 40);
      *(float32x2_t *)(a1 + 32) = vmul_f32(*(float32x2_t *)(a1 + 32), vcvt_f32_s32(*(int32x2_t *)(v9 + 64)));
      *(float32x2_t *)(a1 + 40) = vmul_f32(v68, vcvt_f32_s32(*(int32x2_t *)(v9 + 64)));
      char v65 = 5;
    }
  }
  else
  {
    uint64_t v9 = (char *)RB::Device::invalid_texture(***(id ****)a2);
    char v65 = 1;
  }
  uint64_t result = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)a2, (uint64_t)v9);
  *(_DWORD *)(a2 + 232) = result;
  *(unsigned char *)(a2 + 236) = v65;
  return result;
}

uint64_t RB::Fill::ImageData::image_filter(uint64_t a1, float64x2_t *a2, int32x2_t a3)
{
  uint64_t v3 = HIBYTE(*(unsigned __int16 *)(a1 + 78)) & 0xF;
  if (v3 > 9) {
    return 0;
  }
  if (!a2 || *(_WORD *)(a1 + 78) == 4)
  {
    return *v6;
  }
  uint32x2_t v5 = (uint32x2_t)vcgt_s32(a3, (int32x2_t)0x100000001);
  if ((vpmin_u32(v5, v5).u32[0] & 0x80000000) != 0)
  {
    float64x2_t v8 = vcvtq_f64_f32(*(float32x2_t *)(a1 + 44));
    float64x2_t v9 = vcvtq_f64_f32(*(float32x2_t *)(a1 + 56));
    v33[0] = vcvtq_f64_f32(*(float32x2_t *)(a1 + 32));
    v33[1] = v8;
    Point v33[2] = v9;
    v10.f64[0] = RB::operator*(v33, a2);
    if (!v3) {
      goto LABEL_13;
    }
    if (*(unsigned __int8 *)(a1 + 78) > 2u) {
      goto LABEL_13;
    }
    int64x2_t v13 = vceqq_f64(vrndmq_f64(v12), v12);
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v13, 1), (int8x16_t)v13).u64[0] & 0x8000000000000000) == 0) {
      goto LABEL_13;
    }
    if (v10.f64[1] == 0.0 && v11.f64[0] == 0.0)
    {
      int32x2_t v14 = a3;
      double v28 = fabs((double)a3.i32[1]);
      if (v10.f64[0] != fabs((double)a3.i32[0]) || v11.f64[1] != v28) {
        goto LABEL_14;
      }
    }
    else
    {
      if (v10.f64[0] != 0.0)
      {
LABEL_13:
        int32x2_t v14 = a3;
        goto LABEL_14;
      }
      int32x2_t v14 = a3;
      if (v11.f64[1] != 0.0
        || ((double v30 = fabs((double)a3.i32[0]), v10.f64[1] == fabs((double)a3.i32[1]))
          ? (BOOL v31 = v11.f64[0] == v30)
          : (BOOL v31 = 0),
            !v31))
      {
LABEL_14:
        int64x2_t v15 = (int64x2_t)vmulq_f64(v10, v10);
        int64x2_t v16 = (int64x2_t)vmulq_f64(v11, v11);
        float32x2_t v17 = vcvt_f32_f64(vaddq_f64((float64x2_t)vzip1q_s64(v15, v16), (float64x2_t)vzip2q_s64(v15, v16)));
        float32x2_t v18 = vcvt_f32_s32(v14);
        __asm { FMOV            V2.2S, #0.75 }
        float32x2_t v23 = vmul_f32(v18, _D2);
        uint64_t v3 = v3;
        uint32x2_t v24 = (uint32x2_t)vcgt_f32(vmul_f32(v23, v23), v17);
        if ((vpmax_u32(v24, v24).u32[0] & 0x80000000) != 0)
        {
          return *v6;
        }
        __asm { FMOV            V2.2S, #1.25 }
        float32x2_t v26 = vmul_f32(v18, _D2);
        uint32x2_t v27 = (uint32x2_t)vcgt_f32(vmul_f32(v26, v26), v17);
        if ((vpmax_u32(v27, v27).u32[0] & 0x80000000) != 0)
        {
          return *v6;
        }
        goto LABEL_6;
      }
    }
    LODWORD(v3) = 0;
    goto LABEL_14;
  }
LABEL_6:
  return *v6;
}

__n128 RB::Fill::set_image_stretch(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t RB::Fill::ImageData::image_filter_uses_mipmaps(uint64_t a1, float64x2_t *a2, int32x2_t a3)
{
  uint64_t result = RB::interpolation_mode_uses_mipmaps(*(unsigned char *)(a1 + 79) & 0xF);
  if (result) {
    return RB::Fill::ImageData::image_filter(a1, a2, a3) == 2;
  }
  return result;
}

void RB::Fill::ImageData::fill(void *a1, uint64_t a2, RB *a3, uint16x4_t a4)
{
  uint64_t v4 = a3;
  uint64_t v71 = *MEMORY[0x263EF8340];
  if ((*((_WORD *)a1 + 39) & 0x1000) != 0)
  {
    uint64_t v4 = RB::cg_image_alpha_mask(a3, (CGImage *)a2);
    char v19 = (const RB::Fill::Color *)((char *)a1 + 68);
    if (*(unsigned char *)(a2 + 121)) {
      _ZF = *((unsigned char *)a1 + 77) == 0;
    }
    else {
      _ZF = 1;
    }
    if (!_ZF && *(unsigned __int8 *)(a2 + 120) != *((unsigned __int8 *)a1 + 76)
      || (v18.i16[0] = *(_WORD *)(a2 + 112), *(short float *)v18.i16 != *(short float *)v19)
      || (v18.i16[0] = *(_WORD *)(a2 + 114), *(short float *)v18.i16 != *((short float *)a1 + 35))
      || (v18.i16[0] = *(_WORD *)(a2 + 116), *(short float *)v18.i16 != *((short float *)a1 + 36))
      || (v18.i16[0] = *(_WORD *)(a2 + 118), *(short float *)v18.i16 != *((short float *)a1 + 37)))
    {
      RB::CGContext::set_fill_color_slow((RB::CGContext *)a2, v19, v18);
    }
    goto LABEL_22;
  }
  *(short float *)a4.i16 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0));
  if (*((short float *)a1 + 34) == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))
    && *((short float *)a1 + 35) == *(short float *)a4.i16
    && *((short float *)a1 + 36) == *(short float *)a4.i16
    && *((short float *)a1 + 37) == *(short float *)a4.i16)
  {
    goto LABEL_22;
  }
  int v7 = *(unsigned __int8 *)(a2 + 8);
  c[0].a = *(CGFloat *)((char *)a1 + 68);
  LOWORD(c[0].b) = *((_WORD *)a1 + 38);
  RB::Fill::Color::convert((uint64_t)c, v7, a4);
  v8.i32[0] = LODWORD(c[0].a);
  v8.i32[1] = WORD1(c[0].a);
  RB::ColorMatrix::set_color(&v66, COERCE_DOUBLE(vmovn_s32(vmovn_hight_s64(v8, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(*(unint64_t *)&c[0].a), (uint64x2_t)xmmword_21421A490)))));
  if ((RB::ColorMatrix::is_identity((float16x4_t *)&v66) & 1) != 0
    || (size_t Width = CGImageGetWidth(v4),
        size_t Height = CGImageGetHeight(v4),
        *(float *)&uint64_t v11 = (float)Width,
        *((float *)&v11 + 1) = (float)Height,
        float32x2_t v68 = 0,
        uint64_t v69 = v11,
        RB::CGContext::begin_bitmap((int8x8_t *)a2, &v68, 2, 257, 0, 0, (CGContext **)&cf),
        !cf))
  {
LABEL_22:
    CGImageRef v17 = 0;
    goto LABEL_23;
  }
  __asm { FMOV            V0.2S, #1.0 }
  RB::CGContext::CGContext(c, cf, *(unsigned __int8 *)(a2 + 8), _D0);
  v72.origin.double x = v68.f32[0];
  v72.origin.double y = v68.f32[1];
  v72.size.double width = *(float *)&v69;
  v72.size.double height = *((float *)&v69 + 1);
  CGContextDrawImage(*(CGContextRef *)&c[0].a, v72, v4);
  RB::CGContext::apply_color_matrix((RB::_anonymous_namespace_ **)c, (float16x4_t *)&v66, 0);
  CGImageRef Image = CGBitmapContextCreateImage(*(CGContextRef *)&c[0].a);
  CGImageRef v17 = Image;
  if (Image) {
    uint64_t v4 = Image;
  }
  RB::CGContext::~CGContext((RB::CGContext *)c);
  if (cf) {
    CFRelease(cf);
  }
LABEL_23:
  char v21 = *((unsigned char *)a1 + 79);
  _ZF = (v21 & 0xF) == 0;
  int v22 = 4 * ((v21 & 0xF) == 1);
  if (_ZF) {
    CGInterpolationQuality v23 = kCGInterpolationNone;
  }
  else {
    CGInterpolationQuality v23 = v22;
  }
  InterpolationQualitdouble y = CGContextGetInterpolationQuality(*(CGContextRef *)a2);
  if (v23 != InterpolationQuality) {
    CGContextSetInterpolationQuality(*(CGContextRef *)a2, v23);
  }
  if (*(unsigned char *)(a2 + 140) != 1) {
    RB::CGContext::set_aliasing_mode_slow(a2, 1);
  }
  __int16 v25 = *((_WORD *)a1 + 39);
  if (v25 <= 6u)
  {
    if (((1 << v25) & 0x13) != 0)
    {
      memset(&v66, 0, sizeof(v66));
      float64x2_t v32 = vcvtq_f64_f32((float32x2_t)a1[4]);
      float64x2_t v33 = vcvtq_f64_f32(*(float32x2_t *)((char *)a1 + 44));
      float64x2_t v34 = vaddq_f64(vcvtq_f64_f32((float32x2_t)a1[7]), v33);
      int64x2_t v35 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v33, (float64x2_t)xmmword_21421A380), (int8x16_t)vceqq_f64(v32, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v34));
      unint64_t v36 = vandq_s8((int8x16_t)vdupq_laneq_s64(v35, 1), (int8x16_t)v35).u64[0];
      if ((v36 & 0x8000000000000000) == 0)
      {
        float64x2_t v59 = v34;
        float64x2_t v63 = v32;
        float64x2_t v55 = v33;
        CGContextGetCTM(c, *(CGContextRef *)a2);
        CGAffineTransform v66 = c[0];
        float64x2_t v37 = *(CGContext **)a2;
        *(float64x2_t *)&c[0].a = v63;
        *(float64x2_t *)&c[0].c = vnegq_f64(v55);
        *(float64x2_t *)&c[0].tdouble x = v59;
        CGContextConcatCTM(v37, c);
      }
      v73.origin.double x = 0.0;
      v73.origin.double y = 0.0;
      v73.size.double width = 1.0;
      v73.size.double height = 1.0;
      CGContextDrawImage(*(CGContextRef *)a2, v73, v4);
      if ((v36 & 0x8000000000000000) == 0) {
        goto LABEL_36;
      }
    }
    else if (((1 << v25) & 0x60) != 0)
    {
      float64x2_t v26 = vcvtq_f64_f32((float32x2_t)a1[4]);
      float64x2_t v27 = vcvtq_f64_f32(*(float32x2_t *)((char *)a1 + 44));
      float64x2_t v28 = vmlaq_n_f64(vmlaq_f64(vcvtq_f64_f32((float32x2_t)a1[7]), (float64x2_t)0, v26), v27, *((float *)a1 + 3) + *((float *)a1 + 1) + *((float *)a1 + 1));
      memset(&v66, 0, sizeof(v66));
      int64x2_t v29 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v27, (float64x2_t)xmmword_21421A380), (int8x16_t)vceqq_f64(v26, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v28));
      unint64_t v30 = vandq_s8((int8x16_t)vdupq_laneq_s64(v29, 1), (int8x16_t)v29).u64[0];
      if ((v30 & 0x8000000000000000) == 0)
      {
        float64x2_t v54 = v27;
        float64x2_t v58 = v28;
        float64x2_t v62 = v26;
        CGContextGetCTM(c, *(CGContextRef *)a2);
        CGAffineTransform v66 = c[0];
        BOOL v31 = *(CGContext **)a2;
        *(float64x2_t *)&c[0].a = v62;
        *(float64x2_t *)&c[0].c = vnegq_f64(v54);
        *(float64x2_t *)&c[0].tdouble x = v58;
        CGContextConcatCTM(v31, c);
        __int16 v25 = *((_WORD *)a1 + 39);
      }
      RB::cg_draw_9_slice_image(*(CGContextRef *)a2, v4, (float32x4_t *)a1 + 1, (float32x2_t *)a1, v25 == 6, 1);
      if ((v30 & 0x8000000000000000) == 0)
      {
LABEL_36:
        c[0] = v66;
        CGContextSetCTM();
      }
    }
    else if (v25 == 2)
    {
      float64x2_t v60 = vcvtq_f64_f32(*(float32x2_t *)((char *)a1 + 44));
      float64x2_t v64 = vcvtq_f64_f32((float32x2_t)a1[4]);
      float64x2_t v56 = vcvtq_f64_f32((float32x2_t)a1[7]);
      __asm { FMOV            V2.2S, #1.0 }
      uint32x2_t v39 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32((float32x2_t)a1[1], _D2), (int8x8_t)vceqz_f32(*(float32x2_t *)a1));
      if ((vpmin_u32(v39, v39).u32[0] & 0x80000000) != 0)
      {
        CGImageRef v45 = 0;
        float64x2_t v48 = v60;
        float64x2_t v47 = v64;
        float64x2_t v46 = v56;
      }
      else
      {
        size_t v40 = CGImageGetWidth(v4);
        size_t v41 = CGImageGetHeight(v4);
        v42.f32[0] = (float)v40;
        v42.f32[1] = (float)v41;
        float32x2_t v43 = vmul_f32(*(float32x2_t *)a1, v42);
        float32x2_t v44 = vmul_f32((float32x2_t)a1[1], v42);
        v74.origin.double x = v43.f32[0];
        v74.origin.double y = v43.f32[1];
        v74.size.double width = v44.f32[0];
        v74.size.double height = v44.f32[1];
        CGImageRef v45 = CGImageCreateWithImageInRect(v4, v74);
        float64x2_t v46 = vmlaq_n_f64(vmlaq_n_f64(v56, v64, COERCE_FLOAT(*a1)), v60, COERCE_FLOAT(HIDWORD(*a1)));
        float64x2_t v47 = vmulq_n_f64(v64, COERCE_FLOAT(a1[1]));
        float64x2_t v48 = vmulq_n_f64(v60, COERCE_FLOAT(HIDWORD(a1[1])));
      }
      float64x2_t v49 = vaddq_f64(v46, v48);
      float64x2_t v65 = v47;
      memset(&v66, 0, sizeof(v66));
      float64x2_t v61 = v48;
      int64x2_t v50 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v48, (float64x2_t)xmmword_21421A380), (int8x16_t)vceqq_f64(v47, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v49));
      unint64_t v51 = vandq_s8((int8x16_t)vdupq_laneq_s64(v50, 1), (int8x16_t)v50).u64[0];
      if ((v51 & 0x8000000000000000) == 0)
      {
        float64x2_t v57 = v49;
        CGContextGetCTM(c, *(CGContextRef *)a2);
        CGAffineTransform v66 = c[0];
        float32x2_t v52 = *(CGContext **)a2;
        *(float64x2_t *)&c[0].a = v65;
        *(float64x2_t *)&c[0].c = vnegq_f64(v61);
        *(float64x2_t *)&c[0].tdouble x = v57;
        CGContextConcatCTM(v52, c);
      }
      if (v45) {
        float32x2_t v53 = v45;
      }
      else {
        float32x2_t v53 = v4;
      }
      v75.origin.double x = 0.0;
      v75.origin.double y = 0.0;
      v75.size.double width = 1.0;
      v75.size.double height = 1.0;
      CGContextDrawTiledImage(*(CGContextRef *)a2, v75, v53);
      if ((v51 & 0x8000000000000000) == 0)
      {
        c[0] = v66;
        CGContextSetCTM();
      }
      if (v45) {
        CFRelease(v45);
      }
    }
  }
  if (v23 != InterpolationQuality) {
    CGContextSetInterpolationQuality(*(CGContextRef *)a2, InterpolationQuality);
  }
  if (v17) {
    CFRelease(v17);
  }
}

void sub_2141BC310(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,CFTypeRef cf,uint64_t a23,uint64_t a24,char a25)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::Fill::ImageData::matches(RB::Fill::ImageData *this, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  if ((*((_WORD *)this + 39) & 0x1000) != 0) {
    return RB::DisplayList::Predicate::matches_color(a2, (RB::Fill::ImageData *)((char *)this + 68), a3);
  }
  else {
    return RB::DisplayList::Predicate::matches_non_color(a2);
  }
}

void RB::Fill::ImageData::apply_transform(RB::Fill::ImageData *this, const RB::DisplayList::Transform *a2, RB::Heap *a3, uint32x4_t a4)
{
  if ((*((_WORD *)this + 39) & 0x1000) != 0) {
    RB::DisplayList::Transform::apply_to_color(a2, (RB::Fill::ImageData *)((char *)this + 68), a4);
  }
}

unint64_t RB::Fill::ImageData::can_get_image(uint64_t a1, float64x2_t *a2, double a3)
{
  __asm { FMOV            V2.2S, #1.0 }
  uint32x2_t v9 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(*(float32x2_t *)(a1 + 8), _D2), (int8x8_t)vceqz_f32(*(float32x2_t *)a1));
  if ((vpmin_u32(v9, v9).u32[0] & 0x80000000) == 0) {
    return 0;
  }
  if (*(float *)(a1 + 16) != 0.0) {
    return 0;
  }
  if (*(float *)(a1 + 20) != 0.0) {
    return 0;
  }
  if (*(float *)(a1 + 24) != 0.0) {
    return 0;
  }
  if (*(float *)(a1 + 28) != 0.0) {
    return 0;
  }
  short float v11 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0));
  if (*(short float *)(a1 + 68) != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
    return 0;
  }
  if (*(short float *)(a1 + 70) != v11) {
    return 0;
  }
  if (*(short float *)(a1 + 72) != v11) {
    return 0;
  }
  if (*(short float *)(a1 + 74) != v11) {
    return 0;
  }
  if ((*(_WORD *)(a1 + 78) & 0x10FF) != 0) {
    return 0;
  }
  if (*(float *)(a1 + 40) != 0.0) {
    return 0;
  }
  if (*(float *)(a1 + 52) != 0.0) {
    return 0;
  }
  double v19 = a3;
  if (*(float *)(a1 + 64) != 1.0) {
    return 0;
  }
  float64x2_t v12 = vcvtq_f64_f32(*(float32x2_t *)(a1 + 44));
  float64x2_t v13 = vcvtq_f64_f32(*(float32x2_t *)(a1 + 56));
  v20[0] = vcvtq_f64_f32(*(float32x2_t *)(a1 + 32));
  v20[1] = v12;
  _OWORD v20[2] = v13;
  v14.f64[0] = RB::operator*(v20, a2);
  v15.f64[0] = 0.0;
  v15.f64[1] = (double)SHIDWORD(v19);
  int64x2_t v18 = (int64x2_t)vandq_s8((int8x16_t)vceqq_f64(v16, v15), vandq_s8((int8x16_t)vceqq_f64(v14, (float64x2_t)COERCE_UNSIGNED_INT64((double)SLODWORD(v19))), (int8x16_t)vceqzq_f64(v17)));
  return vandq_s8((int8x16_t)vdupq_laneq_s64(v18, 1), (int8x16_t)v18).u64[0] >> 63;
}

void *RB::Fill::ImageData::encode(RB::Fill::ImageData *this, RB::Encoder *a2, int32x4_t a3, int32x4_t a4)
{
  unint64_t v6 = *((unsigned __int8 *)this + 78);
  if (*((unsigned char *)this + 78))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x10uLL);
    RB::ProtobufEncoder::encode_varint(a2, v6);
  }
  float32x2_t v7 = *(float32x2_t *)((char *)this + 32);
  if (v7.f32[0] != 1.0
    || v7.f32[1] != 0.0
    || *((float *)this + 10) != 0.0
    || *((float *)this + 11) != 0.0
    || *((float *)this + 12) != 1.0
    || *((float *)this + 13) != 0.0
    || *((float *)this + 14) != 0.0
    || *((float *)this + 15) != 0.0
    || *((float *)this + 16) != 1.0)
  {
    float64x2_t v8 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 44));
    float64x2_t v9 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 56));
    v22[0] = vcvtq_f64_f32(v7);
    v22[1] = v8;
    v22[2] = v9;
    RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::AffineTransform::encode((double *)v22, a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  short float v10 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0));
  if (*((short float *)this + 34) != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))
    || *((short float *)this + 35) != v10
    || *((short float *)this + 36) != v10
    || *((short float *)this + 37) != v10)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x22uLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Fill::Color::encode((RB::Fill::ImageData *)((char *)this + 68), a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  __asm { FMOV            V3.2S, #1.0 }
  uint32x2_t v16 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(*(float32x2_t *)((char *)this + 8), _D3), (int8x8_t)vceqz_f32(*(float32x2_t *)this));
  if ((vpmin_u32(v16, v16).u32[0] & 0x80000000) == 0) {
    RB::ProtobufEncoder::float4_field(a2, 5, *(float32x4_t *)this);
  }
  a3.i64[0] = *((void *)this + 2);
  *(int32x2_t *)a4.i8 = vceqz_f32(*(float32x2_t *)a3.i8);
  if ((a4.i32[0] & a4.i32[1] & 1) == 0 || *((float *)this + 6) != 0.0 || *((float *)this + 7) != 0.0)
  {
    a4.i32[0] = *((_DWORD *)this + 6);
    float32x4_t v17 = (float32x4_t)vzip1q_s32(a4, a3);
    v17.i32[2] = *((_DWORD *)this + 7);
    RB::ProtobufEncoder::float4_field(a2, 6, v17);
  }
  if (*((_WORD *)this + 39) == 4)
  {
    a3.i32[0] = *((_DWORD *)this + 10);
    a3.i32[1] = *((_DWORD *)this + 13);
    a3.i32[2] = *((_DWORD *)this + 16);
    RB::ProtobufEncoder::float3_field(a2, 7, (float32x4_t)a3);
    LOBYTE(v18) = *((unsigned char *)this + 79);
  }
  else
  {
    int v18 = HIBYTE(*((unsigned __int16 *)this + 39));
  }
  uint64_t result = (void *)rb_interpolation_mode(v18 & 0xF);
  if (result != 1)
  {
    int v20 = (int)result;
    RB::ProtobufEncoder::encode_varint(a2, 0x40uLL);
    uint64_t result = RB::ProtobufEncoder::encode_varint(a2, v20);
  }
  __int16 v21 = *((_WORD *)this + 39);
  if ((v21 & 0x1000) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x48uLL);
    uint64_t result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    __int16 v21 = *((_WORD *)this + 39);
    if ((v21 & 0x2000) == 0)
    {
LABEL_31:
      if ((v21 & 0x4000) == 0) {
        return result;
      }
      goto LABEL_32;
    }
  }
  else if ((*((_WORD *)this + 39) & 0x2000) == 0)
  {
    goto LABEL_31;
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x50uLL);
  uint64_t result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  if ((*((_WORD *)this + 39) & 0x4000) == 0) {
    return result;
  }
LABEL_32:
  RB::ProtobufEncoder::encode_varint(a2, 0x58uLL);
  return RB::ProtobufEncoder::encode_varint(a2, 1uLL);
}

unint64_t RB::Fill::ImageData::decode@<X0>(RB::Fill::ImageData *this@<X0>, RB::Decoder *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 16) = 0;
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v7 = result;
    do
    {
      switch((v7 >> 3))
      {
        case 1u:
          long long v27 = *(_OWORD *)a2;
          RB::ProtobufDecoder::skip_field(a2, v7);
          *(_OWORD *)a3 = v27;
          *(void *)(a3 + 16) = v7;
          break;
        case 2u:
          unint64_t v8 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, v7);
          if (v8 <= 6)
          {
            __int16 v9 = v8 | (*((unsigned __int8 *)this + 79) << 8);
            goto LABEL_28;
          }
          break;
        case 3u:
          long long v28 = xmmword_2142181C0;
          int64x2_t v29 = (int64x2_t)xmmword_2142181D0;
          int64x2_t v30 = 0uLL;
          if ((v7 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            RB::AffineTransform::decode((RB::AffineTransform *)&v28, a2);
            RB::ProtobufDecoder::end_message((uint64_t)a2);
            double v11 = *(double *)&v28;
            double v10 = *(double *)v29.i64;
            double v12 = *((double *)&v28 + 1);
            double v13 = *(double *)v30.i64;
            int64x2_t v14 = vzip2q_s64(v30, v29);
          }
          else
          {
            *((unsigned char *)a2 + 56) = 1;
            *(void *)a2 = *((void *)a2 + 1);
            double v12 = 0.0;
            double v13 = 0.0;
            int64x2_t v14 = (int64x2_t)xmmword_2142181D0;
            double v11 = 1.0;
            double v10 = 0.0;
          }
          float v15 = v11;
          float v16 = v12;
          *((float *)this + 8) = v15;
          *((float *)this + 9) = v16;
          float v17 = v10;
          float v18 = *(double *)&v14.i64[1];
          *((float *)this + 11) = v17;
          *((float *)this + 12) = v18;
          float v19 = v13;
          float v20 = *(double *)v14.i64;
          *((float *)this + 14) = v19;
          *((float *)this + 15) = v20;
          break;
        case 4u:
          if ((v7 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            RB::Fill::Color::decode((uint64_t)this + 68, a2);
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
            *((unsigned char *)a2 + 56) = 1;
            *(void *)a2 = *((void *)a2 + 1);
          }
          break;
        case 5u:
          *(__n128 *)this = RB::ProtobufDecoder::float4_field(a2, v7);
          break;
        case 6u:
          __n128 v21 = RB::ProtobufDecoder::float4_field(a2, v7);
          *((int32x4_t *)this + 1) = vuzp2q_s32((int32x4_t)v21, vrev64q_s32((int32x4_t)v21));
          break;
        case 7u:
          __n128 v22 = RB::ProtobufDecoder::float3_field(a2, v7);
          *((_DWORD *)this + 10) = v22.n128_u32[0];
          *((_DWORD *)this + 13) = v22.n128_u32[1];
          *((_DWORD *)this + 16) = v22.n128_u32[2];
          break;
        case 8u:
          unsigned int v23 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, v7);
          __int16 v9 = *((_WORD *)this + 39) & 0xF0FF | ((rb_interpolation_mode(v23) & 0xF) << 8);
          goto LABEL_28;
        case 9u:
          int v24 = RB::ProtobufDecoder::BOOL_field(a2, v7);
          __int16 v25 = *((_WORD *)this + 39);
          if (v24) {
            __int16 v26 = 4096;
          }
          else {
            __int16 v26 = 0;
          }
          goto LABEL_27;
        case 0xAu:
          if (RB::ProtobufDecoder::BOOL_field(a2, v7)) {
            __int16 v25 = 0x2000;
          }
          else {
            __int16 v25 = 0;
          }
          goto LABEL_26;
        case 0xBu:
          if (RB::ProtobufDecoder::BOOL_field(a2, v7)) {
            __int16 v25 = 0x4000;
          }
          else {
            __int16 v25 = 0;
          }
LABEL_26:
          __int16 v26 = *((_WORD *)this + 39);
LABEL_27:
          __int16 v9 = v25 | v26;
LABEL_28:
          *((_WORD *)this + 39) = v9;
          break;
        default:
          RB::ProtobufDecoder::skip_field(a2, v7);
          break;
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v7 = result;
    }
    while (result);
  }
  return result;
}

void RB::Fill::ImageData::attributes(RB::Fill::ImageData *this, RB::XML::Element *a2)
{
  long long v3 = &unk_26C4ED758;
  float64x2_t v2 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 44));
  float64x2_t v4 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 32));
  float64x2_t v5 = v2;
  float64x2_t v6 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 56));
  RB::XML::Element::set<RB::XML::Value::Transform>();
}

void RB::XML::Element::set<RB::XML::Value::InterpolationMode>()
{
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::InterpolationMode,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2141BCF3C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::InterpolationMode *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::InterpolationMode>,std::allocator<RB::XML::Value::InterpolationMode>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::InterpolationMode *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::InterpolationMode>,std::allocator<RB::XML::Value::InterpolationMode>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void RB::DisplayList::Predicate::Term::Term(RB::DisplayList::Predicate::Term *this, const RB::DisplayList::Predicate *a2)
{
  *(_DWORD *)this = 3;
  operator new();
}

void sub_2141BD02C(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x1020C4057BCEDDBLL);
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::Predicate::Term::Term(uint64_t this, const RB::DisplayList::Predicate::Term *a2)
{
  int v2 = *(_DWORD *)a2;
  *(_DWORD *)this = *(_DWORD *)a2;
  long long v3 = (void *)(this + 8);
  switch(v2)
  {
    case 3:
      operator new();
    case 2:
      uint64_t v4 = *((void *)a2 + 1);
      *(_WORD *)(this + 16) = *((_WORD *)a2 + 8);
      *long long v3 = v4;
      break;
    case 1:
      *(_DWORD *)long long v3 = *((_DWORD *)a2 + 2);
      break;
  }
  return this;
}

void sub_2141BD18C(_Unwind_Exception *a1)
{
  long long v3 = RB::vector<RB::DisplayList::Predicate::Term,1ul,unsigned int>::~vector(v1);
  MEMORY[0x21669AC10](v3, 0x1020C4057BCEDDBLL);
  _Unwind_Resume(a1);
}

_DWORD *RB::DisplayList::Predicate::add(_DWORD *this, int a2)
{
  long long v3 = this;
  int v4 = this[8];
  if (this[9] < (v4 + 1))
  {
    this = RB::vector<RB::DisplayList::Predicate::Term,1ul,unsigned int>::reserve_slow(this, v4 + 1);
    int v4 = v3[8];
  }
  float64x2_t v5 = (_DWORD *)*((void *)v3 + 3);
  if (!v5) {
    float64x2_t v5 = v3;
  }
  float64x2_t v6 = &v5[6 * v4];
  *float64x2_t v6 = 1;
  int32x2_t v6[2] = a2;
  ++v3[8];
  return this;
}

void RB::DisplayList::Predicate::add_predicate(RB::DisplayList::Predicate *this, const RB::DisplayList::Predicate *a2)
{
  unsigned int v4 = *((_DWORD *)this + 8);
  if (*((_DWORD *)this + 9) < v4 + 1)
  {
    RB::vector<RB::DisplayList::Predicate::Term,1ul,unsigned int>::reserve_slow(this, v4 + 1);
    unsigned int v4 = *((_DWORD *)this + 8);
  }
  float64x2_t v5 = (RB::DisplayList::Predicate *)*((void *)this + 3);
  if (!v5) {
    float64x2_t v5 = this;
  }
  RB::DisplayList::Predicate::Term::Term((RB::DisplayList::Predicate *)((char *)v5 + 24 * v4), a2);
}

uint64_t RB::DisplayList::Predicate::matches_non_color(RB::DisplayList::Predicate *this)
{
  if (*((void *)this + 3)) {
    uint64_t v1 = (RB::DisplayList::Predicate *)*((void *)this + 3);
  }
  else {
    uint64_t v1 = this;
  }
  uint64_t v2 = *((unsigned int *)this + 8);
  if (!v2) {
    return 1;
  }
  long long v3 = (RB::DisplayList::Predicate **)((char *)v1 + 8);
  uint64_t v4 = 24 * v2;
  while (1)
  {
    int v5 = *((_DWORD *)v3 - 2);
    if (v5 != 1) {
      break;
    }
    if (!*(_DWORD *)v3) {
      return 0;
    }
LABEL_13:
    v3 += 3;
    v4 -= 24;
    if (!v4) {
      return 1;
    }
  }
  if (v5 != 3)
  {
    if (v5 == 2) {
      return 0;
    }
    goto LABEL_13;
  }
  float64x2_t v6 = *v3;
  if ((RB::DisplayList::Predicate::matches_non_color(*v3) ^ (*((unsigned char *)v6 + 40) != 0))) {
    goto LABEL_13;
  }
  return 0;
}

uint64_t RB::DisplayList::Predicate::Term::can_mix(RB::DisplayList::InvertiblePredicate **this, const RB::DisplayList::InvertiblePredicate **a2)
{
  int v2 = *(_DWORD *)this;
  if (*(_DWORD *)this != *(_DWORD *)a2) {
    return 0;
  }
  if (v2 == 3) {
    return RB::DisplayList::InvertiblePredicate::can_mix(this[1], a2[1]);
  }
  if (v2 != 2)
  {
    if (v2 != 1 || *((_DWORD *)this + 2) == *((_DWORD *)a2 + 2)) {
      return 4;
    }
    return 0;
  }
  return RB::Fill::Color::can_mix((RB::Fill::Color *)(this + 1), (const RB::Fill::Color *)(a2 + 1));
}

uint64_t RB::DisplayList::InvertiblePredicate::can_mix(RB::DisplayList::InvertiblePredicate *this, const RB::DisplayList::InvertiblePredicate *a2)
{
  if (*((unsigned __int8 *)this + 40) == *((unsigned __int8 *)a2 + 40)) {
    return RB::DisplayList::Predicate::can_mix(this, a2);
  }
  else {
    return 0;
  }
}

void RB::DisplayList::Predicate::Term::mix(RB::DisplayList::Predicate::Term *this, const RB::DisplayList::Predicate **a2, float a3)
{
  if (*(_DWORD *)this == 3)
  {
    RB::DisplayList::Predicate::mix(*((void *)this + 1), a2[1], a3);
  }
  else if (*(_DWORD *)this == 2)
  {
    RB::Fill::Color::mix((uint64_t)this + 8, (uint64_t)(a2 + 1), 0, a3);
  }
}

uint64_t RB::DisplayList::Predicate::can_mix(RB::DisplayList::Predicate *this, const RB::DisplayList::Predicate *a2)
{
  uint64_t v2 = *((unsigned int *)this + 8);
  if (v2 != *((_DWORD *)a2 + 8)) {
    return 0;
  }
  if (!v2) {
    return 4;
  }
  uint64_t v5 = 0;
  uint64_t v6 = 24 * v2;
  LOBYTE(v7) = 4;
  do
  {
    unint64_t v8 = (RB::DisplayList::Predicate *)*((void *)this + 3);
    if (!v8) {
      unint64_t v8 = this;
    }
    __int16 v9 = (RB::DisplayList::InvertiblePredicate **)((char *)v8 + v5);
    double v10 = (const RB::DisplayList::Predicate *)*((void *)a2 + 3);
    if (!v10) {
      double v10 = a2;
    }
    unsigned int can_mix = RB::DisplayList::Predicate::Term::can_mix(v9, (const RB::DisplayList::InvertiblePredicate **)((char *)v10 + v5));
    if (can_mix >= v7) {
      uint64_t v7 = v7;
    }
    else {
      uint64_t v7 = can_mix;
    }
    if (!v7) {
      break;
    }
    v5 += 24;
  }
  while (v6 != v5);
  return v7;
}

uint64_t RB::DisplayList::Predicate::mix(uint64_t this, const RB::DisplayList::Predicate *a2, float a3)
{
  uint64_t v3 = *(unsigned int *)(this + 32);
  if (v3)
  {
    uint64_t v6 = this;
    uint64_t v7 = 0;
    uint64_t v8 = 24 * v3;
    do
    {
      uint64_t v9 = *(void *)(v6 + 24);
      if (!v9) {
        uint64_t v9 = v6;
      }
      double v10 = (RB::DisplayList::Predicate::Term *)(v9 + v7);
      double v11 = (const RB::DisplayList::Predicate *)*((void *)a2 + 3);
      if (!v11) {
        double v11 = a2;
      }
      this = RB::DisplayList::Predicate::Term::mix(v10, (const RB::DisplayList::Predicate *)((char *)v11 + v7), a3);
      v7 += 24;
    }
    while (v8 != v7);
  }
  return this;
}

uint64_t RB::DisplayList::Predicate::xml_elements(uint64_t this, RB::XML::Document *a2)
{
  uint64_t v2 = *(void *)(this + 24);
  if (!v2) {
    uint64_t v2 = this;
  }
  uint64_t v3 = *(unsigned int *)(this + 32);
  if (v3)
  {
    uint64_t v4 = (_DWORD *)(v2 + 8);
    uint64_t v5 = 24 * v3;
    do
    {
      int v6 = *(v4 - 2);
      if (v6 == 3) {
        RB::XML::Document::push(a2, "predicate");
      }
      if (v6 == 2) {
        RB::XML::Document::push(a2, "color");
      }
      if (v6 == 1 && !*v4) {
        RB::XML::Document::push(a2, "monochrome");
      }
      v4 += 6;
      v5 -= 24;
    }
    while (v5);
  }
  return this;
}

uint64_t RB::DisplayList::Layer::matches(RB::DisplayList::Layer *this, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  if (*((unsigned char *)this + 64) == 2)
  {
    uint64_t v5 = *(uint64_t (**)(void))(**((void **)this + 3) + 72);
    return v5();
  }
  else if ((*((unsigned char *)this + 60) & 8) != 0)
  {
    uint64_t v16 = 0x3C003C003C003C00;
    __int16 v17 = 0;
    return RB::DisplayList::Predicate::matches_color(a2, (const RB::Fill::Color *)&v16, a3);
  }
  else
  {
    uint64_t v7 = (void *)*((void *)this + 2);
    if (v7)
    {
      while (1)
      {
        int v8 = (*(uint64_t (**)(void *))(*v7 + 40))(v7);
        if (v8 == 2) {
          break;
        }
        if (v8 == 1)
        {
          return RB::DisplayList::Predicate::matches_non_color(a2);
        }
        uint64_t v7 = (void *)v7[1];
        if (!v7) {
          goto LABEL_10;
        }
      }
      float v15 = (const RB::Fill::Color *)(v9 + 32);
      return RB::DisplayList::Predicate::matches_color(a2, v15, v10);
    }
    else
    {
LABEL_10:
      double v11 = *(void **)this;
      if (v11)
      {
        while (1)
        {
          double v12 = (void *)v11[2];
          if (v12) {
            break;
          }
LABEL_18:
          uint64_t result = (*(uint64_t (**)(void *, const RB::DisplayList::Predicate *))(*v11 + 192))(v11, a2);
          if (!result)
          {
            double v11 = (void *)v11[1];
            if (v11) {
              continue;
            }
          }
          return result;
        }
        while (1)
        {
          unsigned __int16 v13 = (*(uint64_t (**)(void *, const RB::DisplayList::Predicate *))(*v12 + 64))(v12, a2);
          if (v13 >= 0x100u && v13 != 0) {
            return 1;
          }
          double v12 = (void *)v12[4];
          if (!v12) {
            goto LABEL_18;
          }
        }
      }
      else
      {
        return 0;
      }
    }
  }
}

uint64_t RB::DisplayList::LayerItem::matches(RB::DisplayList::Layer **this, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::DisplayList::Layer::matches(this[6], a2, a3);
}

uint64_t RB::DisplayList::BackdropColorMatrixItem::matches(RB::DisplayList::BackdropColorMatrixItem *this, const RB::DisplayList::Predicate *a2)
{
  return RB::DisplayList::Predicate::matches_non_color(a2);
}

uint64_t RB::DisplayList::CustomItem::matches(RB::DisplayList::CustomItem *this, const RB::DisplayList::Predicate *a2)
{
  return RB::DisplayList::Predicate::matches_non_color(a2);
}

void *RB::DisplayList::Predicate::encode(void *this, RB::Encoder *a2)
{
  if (this[3]) {
    uint64_t v2 = (void *)this[3];
  }
  else {
    uint64_t v2 = this;
  }
  uint64_t v3 = *((unsigned int *)this + 8);
  if (v3)
  {
    uint64_t v5 = 24 * v3;
    do
    {
      RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::DisplayList::Predicate::Term::encode(v2, a2);
      this = RB::ProtobufEncoder::end_length_delimited(a2);
      v2 += 3;
      v5 -= 24;
    }
    while (v5);
  }
  return this;
}

uint64_t RB::DisplayList::Predicate::decode(RB::DisplayList::Predicate *this, RB::Decoder *a2)
{
  uint64_t v3 = this;
  if (*((void *)this + 3)) {
    this = (RB::DisplayList::Predicate *)*((void *)this + 3);
  }
  uint64_t v4 = *((unsigned int *)v3 + 8);
  if (v4)
  {
    uint64_t v5 = 24 * v4;
    do
    {
      RB::DisplayList::Predicate::Term::~Term(this);
      this = (RB::DisplayList::Predicate *)(v6 + 24);
      v5 -= 24;
    }
    while (v5);
  }
  *((_DWORD *)v3 + 8) = 0;
  uint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    uint64_t v8 = result;
    do
    {
      if ((v8 & 0x7FFFFFFF8) == 8)
      {
        unsigned int v9 = *((_DWORD *)v3 + 8);
        unsigned int v10 = v9 + 1;
        if (*((_DWORD *)v3 + 9) < v9 + 1)
        {
          RB::vector<RB::DisplayList::Predicate::Term,1ul,unsigned int>::reserve_slow(v3, v10);
          unsigned int v9 = *((_DWORD *)v3 + 8);
          unsigned int v10 = v9 + 1;
        }
        double v11 = (RB::DisplayList::Predicate *)*((void *)v3 + 3);
        if (!v11) {
          double v11 = v3;
        }
        double v12 = (RB::DisplayList::Predicate *)((char *)v11 + 24 * v9);
        *(_DWORD *)double v12 = 0;
        *((_DWORD *)v3 + 8) = v10;
        if ((v8 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          RB::DisplayList::Predicate::Term::decode(v12, a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v8);
      }
      uint64_t result = RB::ProtobufDecoder::next_field(a2);
      uint64_t v8 = result;
    }
    while (result);
  }
  return result;
}

void *RB::DisplayList::InvertiblePredicate::encode(RB::DisplayList::InvertiblePredicate *this, RB::Encoder *a2)
{
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::DisplayList::Predicate::encode(this, a2);
  uint64_t result = RB::ProtobufEncoder::end_length_delimited(a2);
  if (*((unsigned char *)this + 40))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x10uLL);
    return RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  return result;
}

unint64_t RB::DisplayList::InvertiblePredicate::decode(RB::DisplayList::InvertiblePredicate *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      if ((v5 >> 3) == 2)
      {
        *((unsigned char *)this + 40) = RB::ProtobufDecoder::BOOL_field(a2, v5);
      }
      else if ((v5 >> 3) == 1)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          RB::DisplayList::Predicate::decode(this, a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v5);
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void *RB::DisplayList::Predicate::Term::encode(void *this, RB::Encoder *a2)
{
  int v3 = *(_DWORD *)this;
  if (*(_DWORD *)this == 3)
  {
    unint64_t v5 = (RB::DisplayList::Predicate *)this[1];
    if (!v5) {
      return this;
    }
    RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::DisplayList::Predicate::encode(v5, a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
    if (*((unsigned char *)v5 + 40))
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x10uLL);
      RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    }
  }
  else
  {
    if (v3 != 2)
    {
      if (v3 == 1)
      {
        unint64_t v4 = *((unsigned int *)this + 2);
        if ((int)v4 >= 1)
        {
          RB::ProtobufEncoder::encode_varint(a2, 8uLL);
          return RB::ProtobufEncoder::encode_varint(a2, v4);
        }
      }
      return this;
    }
    uint64_t v6 = (RB::Fill::Color *)(this + 1);
    RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Fill::Color::encode(v6, a2);
  }
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

unint64_t RB::DisplayList::Predicate::Term::decode(RB::DisplayList::Predicate::Term *this, RB::Decoder *a2)
{
  RB::DisplayList::Predicate::Term::~Term(this);
  _DWORD *v4 = 0;
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v6 = result;
    do
    {
      unint64_t v7 = v6 >> 3;
      if ((v6 >> 3) == 3)
      {
        RB::DisplayList::Predicate::Term::~Term(this);
        *(_DWORD *)this = 3;
        operator new();
      }
      if (v7 == 2)
      {
        RB::DisplayList::Predicate::Term::~Term(this);
        *(_DWORD *)this = 2;
        if ((v6 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          RB::Fill::Color::decode((uint64_t)this + 8, a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
        }
      }
      else if (v7 == 1)
      {
        RB::DisplayList::Predicate::Term::~Term(this);
        *(_DWORD *)this = 1;
        *((_DWORD *)this + 2) = RB::ProtobufDecoder::uint_field((uint64_t **)a2, v6);
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v6);
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v6 = result;
    }
    while (result);
  }
  return result;
}

RB::DisplayList::InvertiblePredicate *RB::DisplayList::InvertiblePredicate::InvertiblePredicate(RB::DisplayList::InvertiblePredicate *this, const RB::DisplayList::Predicate *a2, char a3)
{
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0x100000000;
  if (*((void *)a2 + 3)) {
    unint64_t v5 = (const RB::DisplayList::Predicate::Term *)*((void *)a2 + 3);
  }
  else {
    unint64_t v5 = a2;
  }
  unsigned int v6 = *((_DWORD *)a2 + 8);
  unsigned int v7 = v6;
  if (v6 >= 2)
  {
    RB::vector<RB::DisplayList::Predicate::Term,1ul,unsigned int>::reserve_slow(this, v6);
    uint64_t v8 = (RB::DisplayList::InvertiblePredicate *)*((void *)this + 3);
    unsigned int v9 = *((_DWORD *)this + 8);
  }
  else
  {
    if (!v6)
    {
      int v12 = 0;
      goto LABEL_13;
    }
    uint64_t v8 = 0;
    unsigned int v9 = 0;
  }
  if (!v8) {
    uint64_t v8 = this;
  }
  uint64_t v10 = (uint64_t)v8 + 24 * v9;
  do
  {
    uint64_t v11 = RB::DisplayList::Predicate::Term::Term(v10, v5);
    unint64_t v5 = (const RB::DisplayList::Predicate::Term *)((char *)v5 + 24);
    uint64_t v10 = v11 + 24;
    --v7;
  }
  while (v7);
  int v12 = *((_DWORD *)this + 8);
LABEL_13:
  *((_DWORD *)this + 8) = v12 + v6;
  *((unsigned char *)this + 40) = a3;
  return this;
}

void sub_2141BDED8(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)(v1 + 24);
  if (v3) {
    unint64_t v4 = *(RB::DisplayList::Predicate::Term **)(v1 + 24);
  }
  else {
    unint64_t v4 = (RB::DisplayList::Predicate::Term *)v1;
  }
  if (*(_DWORD *)(v1 + 32))
  {
    unint64_t v5 = 0;
    do
    {
      RB::DisplayList::Predicate::Term::~Term(v4);
      ++v5;
      unint64_t v4 = (RB::DisplayList::Predicate::Term *)(v6 + 24);
    }
    while (v5 < *(unsigned int *)(v1 + 32));
    int v3 = *(void **)(v1 + 24);
  }
  if (v3) {
    free(v3);
  }
  _Unwind_Resume(exception_object);
}

RB::DisplayList::Predicate::Term *RB::vector<RB::DisplayList::Predicate::Term,1ul,unsigned int>::~vector(RB::DisplayList::Predicate::Term *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = (void *)*((void *)a1 + 3);
  if (v2) {
    a1 = (RB::DisplayList::Predicate::Term *)*((void *)a1 + 3);
  }
  if (*((_DWORD *)v1 + 8))
  {
    unint64_t v3 = 0;
    do
    {
      RB::DisplayList::Predicate::Term::~Term(a1);
      ++v3;
      a1 = (RB::DisplayList::Predicate::Term *)(v4 + 24);
    }
    while (v3 < *((unsigned int *)v1 + 8));
    uint64_t v2 = (void *)*((void *)v1 + 3);
  }
  if (v2) {
    free(v2);
  }
  return v1;
}

void *RB::vector<RB::DisplayList::Predicate::Term,1ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 9) + (*((_DWORD *)__dst + 9) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 9) + (*((_DWORD *)__dst + 9) >> 1);
  }
  unint64_t result = RB::details::realloc_vector<unsigned int,24ul>(*((void **)__dst + 3), __dst, 1u, (_DWORD *)__dst + 9, v3);
  *((void *)__dst + 3) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,24ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  unsigned int v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 24 * a5);
      free(v7);
      int v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(24 * a5);
    unint64_t v9 = v8 / 0x18;
    if (*a4 != (v8 / 0x18))
    {
      uint64_t v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      int v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 24 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t RB::CGContext::display_list_context(RB::CGContext *this, CGContext *a2)
{
  int v3 = *((_DWORD *)this + 36);
  if (v3 < 0)
  {
    int Type = CGContextGetType();
    *((_DWORD *)this + 36) = Type;
    if (Type) {
      return 0;
    }
  }
  else if (v3)
  {
    return 0;
  }
  uint64_t v6 = *(RB::ContextDelegate **)this;
  return RB::ContextDelegate::check_type(v6, a2);
}

void RB::CGContext::set_alpha(RB::CGContext *this, float a2)
{
  if (*((float *)this + 33) != a2)
  {
    *((float *)this + 33) = a2;
    CGContextSetAlpha(*(CGContextRef *)this, a2);
  }
}

double RB::CGContext::set_stroke_color_slow(RB::CGContext *this, const RB::Fill::Color *a2, uint16x4_t a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(void *)a2;
  *((_WORD *)this + 65) = *((_WORD *)a2 + 4);
  *(void *)((char *)this + 122) = v5;
  a3.i16[0] = *(_WORD *)a2;
  _ZF = *(short float *)a2 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(-1.0))
     && *((short float *)a2 + 1) == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(-1.0));
  if (_ZF && (RB::CGContext::display_list_context(this, a2) & 1) == 0)
  {
    *(void *)((char *)this + 122) = 0x3C003C0000003C00;
    *((_WORD *)this + 65) = 0;
  }
  int v7 = *((unsigned __int8 *)this + 8);
  CGFloat components = *(CGFloat *)a2;
  v18.i16[0] = *((_WORD *)a2 + 4);
  RB::Fill::Color::convert((uint64_t)&components, v7, a3);
  _Q0 = (uint64x2_t)vdupq_n_s64(*(unint64_t *)&components);
  _H1 = LOWORD(components);
  _S2 = HIWORD(*(void *)&components);
  __asm { FCVT            D1, H1 }
  CGFloat components = _D1;
  *(int32x2_t *)_Q0.i8 = vmovn_s64((int64x2_t)vshlq_u64(_Q0, (uint64x2_t)xmmword_21421A500));
  _Q0.i32[0] = vuzp1_s16(*(int16x4_t *)_Q0.i8, *(int16x4_t *)_Q0.i8).u32[0];
  LOWORD(_D1) = _Q0.i16[1];
  __asm
  {
    FCVT            D1, H1
    FCVT            D0, H0
  }
  _Q0.i64[1] = _D1;
  uint64x2_t v18 = _Q0;
  __asm { FCVT            D0, H2 }
  uint64_t v19 = _Q0.i64[0];
  CGContextSetStrokeColor(*(CGContextRef *)this, &components);
  return result;
}

void RB::CGContext::set_aliasing_mode_slow(uint64_t a1, int a2)
{
  *(unsigned char *)(a1 + 140) = a2;
  CGContextSetShouldAntialias(*(CGContextRef *)a1, a2 == 0);
}

uint64_t RB::CGContext::reset_ctm(uint64_t this)
{
  if (*(void *)(this + 80))
  {
    uint64_t v1 = this;
    this = CGContextSetCTM();
    *(void *)(v1 + 80) = 0;
  }
  return this;
}

void RB::CGContext::begin_layer(uint64_t a1, float a2, int32x2_t a3, int32x2_t a4)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  long long v8 = *(_OWORD *)(a1 + 48);
  uint64_t v9 = a1 + 432;
  *(_OWORD *)CGFloat components = *(_OWORD *)(a1 + 32);
  long long v21 = v8;
  long long v10 = *(_OWORD *)(a1 + 80);
  long long v22 = *(_OWORD *)(a1 + 64);
  long long v23 = v10;
  long long v11 = *(_OWORD *)(a1 + 112);
  long long v24 = *(_OWORD *)(a1 + 96);
  *(_OWORD *)__int16 v25 = v11;
  *(_OWORD *)&v25[14] = *(_OWORD *)(a1 + 126);
  unsigned int v12 = *(_DWORD *)(a1 + 888);
  if (*(_DWORD *)(a1 + 892) < v12 + 1)
  {
    RB::vector<RB::CGContext::LayerState,4ul,unsigned int>::reserve_slow((void *)(a1 + 432), v12 + 1);
    unsigned int v12 = *(_DWORD *)(a1 + 888);
  }
  uint64_t v13 = *(void *)(a1 + 880);
  if (!v13) {
    uint64_t v13 = v9;
  }
  int64x2_t v14 = (_OWORD *)(v13 + 112 * v12);
  _OWORD v14[3] = v23;
  v14[4] = v24;
  v14[5] = *(_OWORD *)v25;
  v14[6] = *(_OWORD *)&v25[16];
  *int64x2_t v14 = *(_OWORD *)components;
  v14[1] = v21;
  double v14[2] = v22;
  ++*(_DWORD *)(a1 + 888);
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 132) = 0x23F800000;
  *(unsigned char *)(a1 + 141) = 0;
  if (a2 != 1.0)
  {
    float64x2_t v15 = vmulq_n_f64(*(float64x2_t *)(a1 + 48), a2);
    *(float64x2_t *)(a1 + 32) = vmulq_n_f64(*(float64x2_t *)(a1 + 32), a2);
    *(float64x2_t *)(a1 + 48) = v15;
    CGContextSetCTM();
    *(void *)(a1 + 80) = 0;
  }
  if (*(short float *)(a1 + 118) != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
  {
    *(_OWORD *)CGFloat components = xmmword_21421A558;
    long long v21 = unk_21421A568;
    CGContextSetFillColor(*(CGContextRef *)a1, components);
  }
  uint32x2_t v16 = (uint32x2_t)vceq_s32(a4, (int32x2_t)0x8000000080000000);
  __int16 v17 = *(CGContext **)a1;
  if ((vpmin_u32(v16, v16).u32[0] & 0x80000000) != 0)
  {
    CGContextBeginTransparencyLayer(v17, 0);
  }
  else
  {
    float32x2_t v18 = vcvt_f32_s32(a3);
    float32x2_t v19 = vcvt_f32_s32(a4);
    v27.origin.double x = v18.f32[0];
    v27.origin.double y = v18.f32[1];
    v27.size.double width = v19.f32[0];
    v27.size.double height = v19.f32[1];
    CGContextBeginTransparencyLayerWithRect(v17, v27, 0);
  }
}

double RB::CGContext::end_layer(CGContextRef *this)
{
  uint64_t v2 = this + 10;
  if (*((unsigned char *)this + 141)) {
    CGContextRestoreGState(*this);
  }
  CGContextEndTransparencyLayer(*this);
  int v3 = (char *)(this + 54);
  if (this[110]) {
    int v3 = (char *)this[110];
  }
  unsigned int v4 = *((_DWORD *)this + 222) - 1;
  uint64_t v5 = &v3[112 * v4];
  long long v7 = *((_OWORD *)v5 + 1);
  long long v6 = *((_OWORD *)v5 + 2);
  *((_OWORD *)this + 2) = *(_OWORD *)v5;
  *((_OWORD *)this + 3) = v7;
  *((_OWORD *)this + 4) = v6;
  long long v10 = *((_OWORD *)v5 + 3);
  long long v8 = *((_OWORD *)v5 + 4);
  long long v9 = *((_OWORD *)v5 + 5);
  *(_OWORD *)((char *)v2 + 46) = *(_OWORD *)(v5 + 94);
  v2[1] = v8;
  v2[2] = v9;
  *uint64_t v2 = v10;
  *((_DWORD *)this + 222) = v4;
  LOWORD(v10) = *((_WORD *)this + 59);
  if (*(short float *)&v10 != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
  {
    CGContextRef v12 = this[14];
    __int16 v13 = *((_WORD *)this + 60);
    *(double *)&long long v10 = RB::CGContext::set_fill_color_slow((RB::CGContext *)this, (const RB::Fill::Color *)&v12, *(uint16x4_t *)&v10);
  }
  return *(double *)&v10;
}

uint64_t RB::CGContext::add_soft_mask(RB::CGContext::SoftMaskMode,RB::Rect,void const*,void (*)(RB::CGContext&,void const*))::$_0::__invoke()
{
  CGContextGetDelegate();
  CGContextGetRenderingState();
  CGContextGetGState();
  return CGSoftMaskDelegateDrawSoftMask();
}

const void **RB::CGContext::add_soft_mask(RB::CGContext::SoftMaskMode,RB::Rect,void const*,void (*)(RB::CGContext&,void const*))::$_1::__invoke(const void **result)
{
  if (result)
  {
    uint64_t v1 = *result;
    if (v1) {
      CFRelease(v1);
    }
    JUMPOUT(0x21669AC10);
  }
  return result;
}

void RB::CGContext::add_alpha_mask(RB::CGContext *this, CGImage *a2, float32x2_t *a3, double a4, int32x4_t a5)
{
  int Type = *((_DWORD *)this + 36);
  if (Type < 0)
  {
    int Type = CGContextGetType();
    *((_DWORD *)this + 36) = Type;
  }
  if ((Type - 1) > 1)
  {
    long long v10 = *(CGContext **)this;
    double v11 = COERCE_FLOAT(*a3);
    double v12 = COERCE_FLOAT(HIDWORD(*(unint64_t *)a3));
    double v13 = COERCE_FLOAT(*(void *)&a3[1]);
    double v14 = COERCE_FLOAT(HIDWORD(*(void *)&a3[1]));
    float64x2_t v15 = RB::cg_image_alpha_mask(a2, a2);
    double v16 = v11;
    double v17 = v12;
    double v18 = v13;
    double v19 = v14;
    CGContextClipToMask(v10, *(CGRect *)&v16, v15);
  }
  else
  {
    float32x2_t v9 = *a3;
    *(float32x2_t *)a5.i8 = a3[1];
    v20[0] = a2;
    v20[1] = a3;
    RB::CGContext::add_soft_mask((uint64_t)this, 0, (uint64_t)v20, (void (*)(CGContextRef *, uint64_t))RB::CGContext::add_soft_mask<RB::CGContext::add_alpha_mask(CGImage *,RB::Rect const&)::$_0>(RB::CGContext::SoftMaskMode,RB::Rect,RB::CGContext::add_alpha_mask(CGImage *,RB::Rect const&)::$_0 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke, v9, a5);
  }
}

float32x2_t RB::CGContext::begin_bitmap@<D0>(int8x8_t *a1@<X0>, float32x2_t *a2@<X1>, char a3@<W2>, __int16 a4@<W3>, int8x8_t a5@<X4>, unsigned __int8 a6@<W5>, CGContext **a7@<X8>)
{
  *a7 = 0;
  float32x2_t v12 = (float32x2_t)vbsl_s8((int8x8_t)vceqd_s64(a6, 0), a1[2], a5);
  float32x2_t v13 = vmul_f32(*a2, v12);
  float32x2_t v35 = v12;
  float32x2_t v14 = vmul_f32(a2[1], v12);
  *a2 = v13;
  a2[1] = v14;
  RB::Bounds::Bounds(&v36, v13, v14);
  if (a3)
  {
    size_t v21 = v37.i32[0];
    size_t v20 = v37.i32[1];
    size_t v22 = 8;
    double v19 = 0;
    uint32_t v23 = 7;
  }
  else
  {
    if ((a4 & 0xFF00) == 0) {
      LOBYTE(a4) = a1[1].i8[0];
    }
    char v15 = (a3 & 2 | a4 & 1) == 0;
    int32x2_t v34 = v37;
    double v16 = (RB *)a4;
    if (a3 & 2 | a4 & 1) {
      int v17 = 8194;
    }
    else {
      int v17 = 4353;
    }
    if (v15) {
      uint64_t v18 = 16;
    }
    else {
      uint64_t v18 = 8;
    }
    double v19 = RB::cg_color_space(v16, v15);
    size_t v20 = v34.i32[1];
    size_t v21 = v34.i32[0];
    size_t v22 = v18;
    uint32_t v23 = v17;
  }
  long long v24 = CGBitmapContextCreate(0, v21, v20, v22, 0, v19, v23);
  uint64_t v26 = v24;
  *a7 = v24;
  if (v24)
  {
    CGContextTranslateCTM(v24, (double)-v36.i32[0], (double)-v36.i32[1]);
    CGContextScaleCTM(v26, v35.f32[0], v35.f32[1]);
  }
  v25.i32[0] = 0;
  uint32x2_t v27 = (uint32x2_t)vceq_s32(v37, (int32x2_t)0x8000000080000000);
  int8x8_t v28 = (int8x8_t)vdup_lane_s32(vcgt_s32(v25, (int32x2_t)vpmin_u32(v27, v27)), 0);
  float32x2_t v29 = (float32x2_t)vbsl_s8(v28, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v37));
  float32x2_t v30 = vrecpe_f32(v35);
  float32x2_t v31 = vmul_f32(vrecps_f32(v35, v30), v30);
  float32x2_t v32 = vmul_f32(v31, vrecps_f32(v35, v31));
  float32x2_t result = vmul_f32(v32, (float32x2_t)vbsl_s8(v28, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v36)));
  *a2 = result;
  a2[1] = vmul_f32(v32, v29);
  return result;
}

void sub_2141BE8B8(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

size_t RB::CGContext::apply_scale(RB::_anonymous_namespace_ **a1, RB::_anonymous_namespace_ *a2, double a3)
{
  memset(&src, 0, sizeof(src));
  memset(&dest, 0, sizeof(dest));
  size_t BitsPerComponent = CGBitmapContextGetBitsPerComponent(*a1);
  size_t result = CGBitmapContextGetBitsPerPixel(*a1);
  transform.a = *(float *)&a3;
  *(void *)&transform.b = 0;
  transform.d = *((float *)&a3 + 1);
  *(void *)&transform.tdouble x = 0;
  if (BitsPerComponent == 8 && result == 32)
  {
    *(_DWORD *)backColor = 0;
    return vImageAffineWarp_ARGB8888(&src, &dest, 0, &transform, backColor, 8u);
  }
  else if (BitsPerComponent == 8 && result == 8)
  {
    return vImageAffineWarp_Planar8(&src, &dest, 0, &transform, 0, 8u);
  }
  return result;
}

size_t RB::anonymous namespace'::vimage_buffer@<X0>(RB::_anonymous_namespace_ *this@<X0>, void **a2@<X8>)
{
  *a2 = CGBitmapContextGetData(this);
  a2[1] = (void *)CGBitmapContextGetHeight(this);
  a2[2] = (void *)CGBitmapContextGetWidth(this);
  size_t result = CGBitmapContextGetBytesPerRow(this);
  a2[3] = (void *)result;
  return result;
}

void RB::CGContext::apply_blur(uint64_t a1, char a2, CFTypeRef *a3, float a4)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  memset(&src, 0, sizeof(src));
  size_t BitsPerComponent = CGBitmapContextGetBitsPerComponent(*(CGContextRef *)a1);
  size_t BitsPerPixel = CGBitmapContextGetBitsPerPixel(*(CGContextRef *)a1);
  vImage_Buffer dest = src;
  if (a4 <= 0.0) {
    goto LABEL_10;
  }
  long long v10 = (RB::_anonymous_namespace_ *)*a3;
  if (*a3) {
    goto LABEL_9;
  }
  uint32_t BitmapInfo = CGBitmapContextGetBitmapInfo(*(CGContextRef *)a1);
  if (BitmapInfo == 7) {
    float32x2_t v12 = 0;
  }
  else {
    float32x2_t v12 = RB::cg_color_space((RB *)*(unsigned __int8 *)(a1 + 8), BitsPerComponent > 8);
  }
  long long v10 = CGBitmapContextCreate(0, src.width, src.height, BitsPerComponent, 0, v12, BitmapInfo);
  if (*a3) {
    CFRelease(*a3);
  }
  *a3 = v10;
  if (v10)
  {
LABEL_9:
LABEL_10:
    int v13 = vcvtms_s32_f32((float)(a4 * 1.88) + 0.5);
    if (v13 <= 1) {
      int v14 = 1;
    }
    else {
      int v14 = v13;
    }
    uint32_t v15 = v14 - 1;
    if (v13) {
      uint32_t v16 = v13;
    }
    else {
      uint32_t v16 = v15;
    }
    uint32_t v17 = v13 | 1;
    if (BitsPerComponent == 8 && BitsPerPixel == 32)
    {
      if (a4 > 0.0)
      {
        vImageTentConvolve_ARGB8888(&src, &dest, 0, 0, 0, v17, v13 | 1, 0, 8u);
        vImageBoxConvolve_ARGB8888(&dest, &src, 0, 0, 0, v16, v16, 0, 8u);
      }
      if (a2)
      {
        vImageUnpremultiplyData_RGBA8888(&src, &src, 0);
        vImageOverwriteChannelsWithScalar_ARGB8888(0xFFu, &src, &src, 1u, 0);
      }
    }
    else if (BitsPerComponent == 8 && BitsPerPixel == 8)
    {
      if (a4 > 0.0)
      {
        vImageTentConvolve_Planar8(&src, &dest, 0, 0, 0, v17, v13 | 1, 0, 8u);
        vImageBoxConvolve_Planar8(&dest, &src, 0, 0, 0, v16, v16, 0, 8u);
      }
      if ((a2 & 2) != 0)
      {
        uint64_t v18 = 0;
        int8x16_t v19 = (int8x16_t)xmmword_21421A510;
        v20.i64[0] = 0x1010101010101010;
        v20.i64[1] = 0x1010101010101010;
        do
        {
          *(int8x16_t *)&table[v18] = vmvnq_s8(v19);
          v18 += 16;
          int8x16_t v19 = vaddq_s8(v19, v20);
        }
        while (v18 != 256);
        vImageTableLookUp_Planar8(&src, &src, table, 0);
      }
    }
  }
}

uint64_t RB::CGContext::apply_color_matrix(RB::_anonymous_namespace_ **this, float16x4_t *a2, int a3)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  uint64_t result = RB::ColorMatrix::is_identity(a2);
  if ((result & 1) == 0)
  {
    memset(&v38, 0, sizeof(v38));
    size_t BitsPerComponent = CGBitmapContextGetBitsPerComponent(*this);
    uint64_t result = CGBitmapContextGetBitsPerPixel(*this);
    if (BitsPerComponent == 8 && result == 32)
    {
      if (RB::ColorMatrix::is_alpha_multiply(a2, a3))
      {
        *(void *)matridouble x = 0;
        int8x8_t v41 = 0;
        int8x8_t v42 = 0;
        v8.n64_u64[0] = RB::ColorMatrix::alpha_multiply_color((RB::ColorMatrix *)a2, a3).n64_u64[0];
        float32x2_t v9 = 0;
        int8x8_t v10 = (int8x8_t)vdup_lane_s16((int16x4_t)v8.n64_u64[0], 3);
        if (a3) {
          unsigned int v11 = -1;
        }
        else {
          unsigned int v11 = 0;
        }
        v10.i16[3] = COERCE_UNSIGNED_INT(1.0);
        v12.i64[0] = 0x3F0000003F000000;
        v12.i64[1] = 0x3F0000003F000000;
        int8x8_t v13 = (int8x8_t)vrev32_s16(vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v12, (float32x4_t)vdupq_n_s32(0x43800000u), vcvtq_f32_f16(vmul_f16((float16x4_t)v8.n64_u64[0], (float16x4_t)vbsl_s8((int8x8_t)vdup_n_s16(v11), (int8x8_t)0x3C003C003C003C00, v10)))))));
        int8x8_t v43 = vext_s8(v13, v13, 6uLL);
        goto LABEL_18;
      }
      if ((a3 & 1) == 0 && RB::ColorMatrix::is_alpha_identity((RB::ColorMatrix *)a2))
      {
        float32x2_t v9 = 0;
        float32x4_t v14 = (float32x4_t)vdupq_n_s32(0x43800000u);
        v15.i64[0] = 0x3F0000003F000000;
        v15.i64[1] = 0x3F0000003F000000;
        float16x4_t v16 = *a2;
        v17.i64[0] = 0x3F0000003F000000;
        v17.i64[1] = 0x3F0000003F000000;
        int8x8_t v18 = (int8x8_t)vrev32_s16(vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v15, v14, vcvtq_f32_f16(a2[2])))));
        *(int16x4_t *)v15.f32 = vrev32_s16(vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v17, v14, vcvtq_f32_f16(a2[1])))));
        *(int8x8_t *)matridouble x = vext_s8(v18, v18, 6uLL);
        int8x8_t v41 = vext_s8(*(int8x8_t *)v15.f32, *(int8x8_t *)v15.f32, 6uLL);
        v15.i64[0] = 0x3F0000003F000000;
        v15.i64[1] = 0x3F0000003F000000;
        float32x4_t v19 = vmlaq_f32(v15, v14, vcvtq_f32_f16(v16));
        float16x4_t v20 = a2[4];
        v20.i16[3] = COERCE_UNSIGNED_INT(1.0);
        v21.i64[0] = 0x3F0000003F000000;
        v21.i64[1] = 0x3F0000003F000000;
        *(int16x4_t *)v19.f32 = vrev32_s16(vmovn_s32(vcvtq_s32_f32(v19)));
        *(int16x4_t *)v14.f32 = vrev32_s16(vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v21, v14, vcvtq_f32_f16(v20)))));
        int8x8_t v42 = vext_s8(*(int8x8_t *)v19.f32, *(int8x8_t *)v19.f32, 6uLL);
        int8x8_t v43 = vext_s8(*(int8x8_t *)v14.f32, *(int8x8_t *)v14.f32, 6uLL);
LABEL_18:
        vImageMatrixMultiply_ARGB8888(&v38, &v38, matrix, 256, 0, v9->i32, 0);
        return vImageClipToAlpha_RGBA8888(&v38, &v38, 0);
      }
      float32x4_t v22 = (float32x4_t)vdupq_n_s32(0x43800000u);
      v23.i64[0] = 0x3F0000003F000000;
      v23.i64[1] = 0x3F0000003F000000;
      v24.i64[0] = 0x3F0000003F000000;
      v24.i64[1] = 0x3F0000003F000000;
      float32x4_t v25 = vmlaq_f32(v24, v22, vcvtq_f32_f16(a2[1]));
      v26.i64[0] = 0x3F0000003F000000;
      v26.i64[1] = 0x3F0000003F000000;
      float32x4_t v27 = vmlaq_f32(v26, v22, vcvtq_f32_f16(*a2));
      v28.i64[0] = 0x3F0000003F000000;
      v28.i64[1] = 0x3F0000003F000000;
      float32x4_t v29 = vmlaq_f32(v28, v22, vcvtq_f32_f16(a2[3]));
      v30.i64[0] = 0x3F0000003F000000;
      v30.i64[1] = 0x3F0000003F000000;
      *(int16x4_t *)v22.f32 = vrev32_s16(vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v23, v22, vcvtq_f32_f16(a2[2])))));
      *(int16x4_t *)v23.f32 = vrev32_s16(vmovn_s32(vcvtq_s32_f32(v25)));
      *(int8x8_t *)matridouble x = vext_s8(*(int8x8_t *)v22.f32, *(int8x8_t *)v22.f32, 6uLL);
      int8x8_t v41 = vext_s8(*(int8x8_t *)v23.f32, *(int8x8_t *)v23.f32, 6uLL);
      *(int16x4_t *)v22.f32 = vrev32_s16(vmovn_s32(vcvtq_s32_f32(v27)));
      *(int16x4_t *)v29.f32 = vrev32_s16(vmovn_s32(vcvtq_s32_f32(v29)));
      int8x8_t v42 = vext_s8(*(int8x8_t *)v22.f32, *(int8x8_t *)v22.f32, 6uLL);
      int8x8_t v43 = vext_s8(*(int8x8_t *)v29.f32, *(int8x8_t *)v29.f32, 6uLL);
      float16x4_t v31 = a2[4];
      unsigned __int16 v32 = vmaxv_u16((uint16x4_t)vmvn_s8((int8x8_t)vceqz_f16(v31)));
      unsigned __int16 v33 = v32;
      if ((v32 & 0x8000) != 0)
      {
        int32x4_t v34 = vcvtq_s32_f32(vmlaq_f32(v30, (float32x4_t)vdupq_n_s32(0x47800000u), vcvtq_f32_f16(v31)));
        v35.i64[0] = 0x8000000080;
        v35.i64[1] = 0x8000000080;
        int8x16_t v36 = (int8x16_t)vrev64q_s32(vaddq_s32(v34, v35));
        int8x16_t v39 = vextq_s8(v36, v36, 0xCuLL);
      }
      if (a3)
      {
        if ((v32 & 0x8000) != 0) {
          float32x2_t v9 = &v39;
        }
        else {
          float32x2_t v9 = 0;
        }
        goto LABEL_18;
      }
      vImageUnpremultiplyData_RGBA8888(&v38, &v38, 0);
      if ((v33 & 0x8000) != 0) {
        int32x2_t v37 = &v39;
      }
      else {
        int32x2_t v37 = 0;
      }
      vImageMatrixMultiply_ARGB8888(&v38, &v38, matrix, 256, 0, v37->i32, 0);
      return vImagePremultiplyData_RGBA8888(&v38, &v38, 0);
    }
  }
  return result;
}

void RB::CGContext::apply_luminance_curve(uint64_t a1, float16x4_t *a2, int32x4_t a3)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (CGBitmapContextGetBitmapInfo(*(CGContextRef *)a1) != 7)
  {
    size_t BitsPerComponent = CGBitmapContextGetBitsPerComponent(*(CGContextRef *)a1);
    if (CGBitmapContextGetBitsPerPixel(*(CGContextRef *)a1) == 32 && BitsPerComponent == 8)
    {
      unint64_t v9 = 0;
      int32x2_t v10 = (int32x2_t)vsubq_f32((float32x4_t)vdupq_laneq_s32(a3, 3), (float32x4_t)a3).u64[0];
      *(float *)v7.i32 = *(float *)v10.i32 + (float)((float)(*(float *)&a3.i32[1] - *(float *)&a3.i32[2]) * 3.0);
      *(float *)v6.i32 = (float)((float)(*(float *)&a3.i32[2] + *(float *)a3.i32)
                               - (float)(*(float *)&a3.i32[1] + *(float *)&a3.i32[1]))
                       * 3.0;
      *(float *)v10.i32 = (float)(*(float *)&a3.i32[1] - *(float *)a3.i32) * 3.0;
      float32x4_t v11 = (float32x4_t)vdupq_lane_s32(v7, 0);
      float32x4_t v12 = (float32x4_t)vdupq_lane_s32(v6, 0);
      float32x4_t v13 = (float32x4_t)vdupq_lane_s32(v10, 0);
      float32x4_t v14 = (float32x4_t)xmmword_21421A520;
      float32x4_t v15 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a3.i8, 0);
      float32x4_t v16 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      float32x4_t v17 = (float32x4_t)vdupq_n_s32(0x3C808081u);
      do
      {
        v18.i64[0] = 0x3F0000003F000000;
        v18.i64[1] = 0x3F0000003F000000;
        int16x8_t v19 = (int16x8_t)vcvtq_u32_f32(vmlaq_f32(v18, v16, vmlaq_f32(v15, v14, vmlaq_f32(v13, v14, vmlaq_f32(v12, v11, v14)))));
        *(int16x4_t *)v19.i8 = vmovn_s32((int32x4_t)v19);
        *(_DWORD *)&v43[v9] = vmovn_s16(v19).u32[0];
        float32x4_t v14 = vaddq_f32(v14, v17);
        _CF = v9 >= 0xFC;
        v9 += 4;
      }
      while (!_CF);
      long long v39 = 0u;
      long long v40 = 0u;
      int v21 = *(unsigned __int8 *)(a1 + 8);
      float16x4_t v41 = *a2;
      __int16 v42 = a2[1].i16[0];
      RB::Fill::Color::convert((uint64_t)&v41, v21, v22);
      uint64_t v24 = *((void *)&v39 + 1);
      if (*((void *)&v39 + 1))
      {
        uint64_t v25 = 0;
        int32x4_t v26 = (int32x4_t)vcvtq_u32_f32(vcvtq_f32_f16(vmla_n_f16((float16x4_t)0x3800380038003800, v41, *(short float *)&v41.i16[3] * COERCE_SHORT_FLOAT(23544))));
        _H1 = COERCE_SHORT_FLOAT(23544) - (short float)(*(short float *)&v41.i16[3] * COERCE_SHORT_FLOAT(23544));
        __asm { FCVT            S1, H1 }
        long long v31 = v40;
        unsigned __int16 v32 = (unsigned int *)v39;
        int32x4_t v33 = vdupq_n_s32((float)(_S1 + 0.5));
        do
        {
          int32x4_t v34 = v32;
          for (uint64_t i = v31; i; --i)
          {
            *(int8x8_t *)v23.i8 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v34), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
            int32x2_t v36 = vmul_s32(*(int32x2_t *)v23.i8, (int32x2_t)0xB72500003666);
            v23.i32[2] = *v34;
            int32x4_t v23 = (int32x4_t)vshrq_n_u32((uint32x4_t)vmlaq_s32(vnegq_s32((int32x4_t)vmvnq_s8((int8x16_t)vmulq_s32(vdupq_n_s32(v43[(unint64_t)(v36.i32[1] + 4725 * v23.i32[2] + v36.i32[0]) >> 16]), v26))), v23, v33), 8uLL);
            uint32x2_t v37 = vshl_u32(*(uint32x2_t *)v23.i8, (uint32x2_t)0x800000010);
            *int32x4_t v34 = v23.i32[2] | *v34 & 0xFF000000 | v37.i32[0] | v37.i32[1];
            ++v34;
          }
          ++v25;
          unsigned __int16 v32 = (unsigned int *)((char *)v32 + *((void *)&v31 + 1));
        }
        while (v25 != v24);
      }
    }
  }
}

size_t RB::CGContext::apply_alpha_lut(CGContextRef *this, int16x8_t *a2)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  size_t BitsPerComponent = CGBitmapContextGetBitsPerComponent(*this);
  size_t BitsPerPixel = CGBitmapContextGetBitsPerPixel(*this);
  memset(&v22, 0, sizeof(v22));
  if (BitsPerPixel == 32 && BitsPerComponent == 8)
  {
    vImagePermuteChannels_ARGB8888(&v22, &v22, RB::CGContext::apply_alpha_lut(unsigned int const*)::permute, 0);
    for (uint64_t i = 0; i != 256; i += 16)
    {
      int16x8_t v16 = *a2;
      int16x8_t v15 = a2[1];
      int16x8_t v18 = a2[2];
      int16x8_t v17 = a2[3];
      int16x8_t v19 = (int8x16_t *)&table[i];
      *(uint16x4_t *)v20.i8 = vshr_n_u16((uint16x4_t)vmovn_s32((int32x4_t)v18), 8uLL);
      v20.u64[1] = (unint64_t)vshr_n_u16((uint16x4_t)vmovn_s32((int32x4_t)v17), 8uLL);
      *(uint16x4_t *)v21.i8 = vshr_n_u16((uint16x4_t)vmovn_s32(*(int32x4_t *)a2), 8uLL);
      v21.u64[1] = (unint64_t)vshr_n_u16((uint16x4_t)vmovn_s32((int32x4_t)v15), 8uLL);
      *int16x8_t v19 = vuzp1q_s8((int8x16_t)vuzp1q_s16(*a2, v15), (int8x16_t)vuzp1q_s16(v18, v17));
      v19[16] = vuzp1q_s8(v21, v20);
      v19[32] = vuzp1q_s8((int8x16_t)vuzp2q_s16(v16, v15), (int8x16_t)vuzp2q_s16(v18, v17));
      v19[48] = vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vshrq_n_u32((uint32x4_t)v16, 0x18uLL), (int16x8_t)vshrq_n_u32((uint32x4_t)v15, 0x18uLL)), (int8x16_t)vuzp1q_s16((int16x8_t)vshrq_n_u32((uint32x4_t)v18, 0x18uLL), (int16x8_t)vshrq_n_u32((uint32x4_t)v17, 0x18uLL)));
      a2 += 4;
    }
    return vImageTableLookUp_ARGB8888(&v22, &v22, table, v24, v25, v26, 0);
  }
  else if (BitsPerPixel == 8 && BitsPerComponent == 8)
  {
    for (uint64_t j = 0; j != 256; j += 16)
    {
      uint32x4_t v10 = (uint32x4_t)a2[2];
      uint32x4_t v11 = (uint32x4_t)a2[3];
      uint32x4_t v12 = *(uint32x4_t *)a2;
      uint32x4_t v13 = (uint32x4_t)a2[1];
      a2 += 4;
      *(int8x16_t *)&table[j] = vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vshrq_n_u32(v12, 0x18uLL), (int16x8_t)vshrq_n_u32(v13, 0x18uLL)), (int8x16_t)vuzp1q_s16((int16x8_t)vshrq_n_u32(v10, 0x18uLL), (int16x8_t)vshrq_n_u32(v11, 0x18uLL)));
    }
    return vImageTableLookUp_Planar8(&v22, &v22, table, 0);
  }
  return result;
}

RB::CGContext::Raster *RB::CGContext::Raster::Raster(RB::CGContext::Raster *this, RB::_anonymous_namespace_ **a2)
{
  *(_OWORD *)this = xmmword_2142181C0;
  *((_OWORD *)this + 1) = xmmword_2142181D0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  int v4 = DWORD2(v11);
  *((void *)this + 6) = v11;
  int v5 = DWORD2(v12);
  *((_DWORD *)this + 14) = v12;
  *((_DWORD *)this + 15) = v4;
  *((_DWORD *)this + 16) = v5;
  *((unsigned char *)this + 69) = CGBitmapContextGetBitsPerComponent(*a2);
  *((unsigned char *)this + 68) = CGBitmapContextGetBitsPerPixel(*a2);
  *((unsigned char *)this + 70) = *((unsigned char *)a2 + 8);
  int32x2_t v6 = (float64x2_t *)a2[10];
  if (!v6) {
    int32x2_t v6 = (float64x2_t *)(a2 + 4);
  }
  v7.f64[0] = 0.0;
  v7.f64[1] = (double)*((int *)this + 15);
  float64x2_t v8 = vmulq_f64(v6[1], (float64x2_t)xmmword_2142181F0);
  float64x2_t v9 = vmlaq_f64(v7, (float64x2_t)xmmword_2142181F0, v6[2]);
  *(float64x2_t *)this = vmulq_f64(*v6, (float64x2_t)xmmword_2142181F0);
  *((float64x2_t *)this + 1) = v8;
  *((float64x2_t *)this + 2) = v9;
  return this;
}

void RB::CGContext::Raster::fill_triangle(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, float32x2_t a5, float32x2_t a6, float32x2_t a7)
{
  if (*(void *)(a1 + 48))
  {
    int v10 = *(unsigned __int8 *)(a1 + 68);
    if ((v10 == 8 || v10 == 32) && *(unsigned char *)(a1 + 69) == 8)
    {
      float64x2_t v11 = vcvtq_f64_f32(a5);
      float64x2_t v12 = *(float64x2_t *)(a1 + 16);
      float32x2_t v13 = vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 32), *(float64x2_t *)a1, v11.f64[0]), v12, v11, 1));
      float64x2_t v14 = vcvtq_f64_f32(a6);
      float32x2_t v15 = vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 32), *(float64x2_t *)a1, v14.f64[0]), v12, v14, 1));
      float64x2_t v16 = vcvtq_f64_f32(a7);
      float32x2_t v17 = vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 32), *(float64x2_t *)a1, v16.f64[0]), v12, v16, 1));
      int32x2_t v18 = vmax_s32(vcvt_s32_f32(vrndm_f32(vminnm_f32(vminnm_f32(v13, v15), v17))), 0);
      int32x2_t v19 = vmin_s32(vcvt_s32_f32(vrndp_f32(vmaxnm_f32(vmaxnm_f32(v13, v15), v17))), *(int32x2_t *)(a1 + 56));
      *(int32x2_t *)&v16.f64[0] = vcgt_s32(v19, v18);
      double v20 = COERCE_DOUBLE(vpmin_u32(*(uint32x2_t *)&v16.f64[0], *(uint32x2_t *)&v16.f64[0]));
      if ((LODWORD(v20) & 0x80000000) != 0)
      {
        int32x2_t v58 = v18;
        int32x2_t v59 = v19;
        float16x4_t v21 = RB::Fill::Color::prepare(a2, *(unsigned __int8 *)(a1 + 70), v20);
        float16x4_t v22 = RB::Fill::Color::prepare(a3, *(unsigned __int8 *)(a1 + 70), *(double *)&v21);
        float16x4_t v23 = RB::Fill::Color::prepare(a4, *(unsigned __int8 *)(a1 + 70), *(double *)&v22);
        long long v24 = 0uLL;
        __int32 v25 = v58.i32[1];
        if (v58.i32[1] < v59.i32[1])
        {
          __asm { FMOV            V3.4S, #1.0 }
          float32x4_t v31 = vminnmq_f32(vmaxnmq_f32(vcvtq_f32_f16(v21), (float32x4_t)0), _Q3);
          float32x4_t v32 = vminnmq_f32(vmaxnmq_f32(vcvtq_f32_f16(v22), (float32x4_t)0), _Q3);
          float32x4_t v33 = vminnmq_f32(vmaxnmq_f32(vcvtq_f32_f16(v23), (float32x4_t)0), _Q3);
          int v34 = *(_DWORD *)(a1 + 64);
          uint64_t v35 = *(void *)(a1 + 48) + v34 * v58.i32[1];
          *(float32x2_t *)_Q3.f32 = vsub_f32(v15, v13);
          *(float *)&long long v24 = -_Q3.f32[1];
          float32x2_t v36 = vsub_f32(v17, v15);
          int32x2_t v37 = (int32x2_t)vmul_f32((float32x2_t)vzip1_s32(*(int32x2_t *)&v24, *(int32x2_t *)_Q3.f32), v36);
          v37.i32[0] = vadd_f32((float32x2_t)v37, (float32x2_t)vdup_lane_s32(v37, 1)).u32[0];
          float32x2_t v38 = vrecpe_f32((float32x2_t)v37.u32[0]);
          float32x2_t v39 = vmul_f32(vrecps_f32((float32x2_t)v37.u32[0], v38), v38);
          v37.i32[0] = vmul_f32(v39, vrecps_f32((float32x2_t)v37.u32[0], v39)).u32[0];
          float32x2_t v40 = vmul_n_f32(*(float32x2_t *)_Q3.f32, *(float *)v37.i32);
          float32x2_t v41 = vsub_f32(v13, v17);
          int32x2_t v42 = (int32x2_t)vmul_n_f32(v41, *(float *)v37.i32);
          int32x2_t v43 = (int32x2_t)vmul_n_f32(v36, *(float *)v37.i32);
          int32x2_t v44 = (int32x2_t)vcvt_f32_s32(v58);
          int32x2_t v45 = (int32x2_t)vsub_f32(vadd_f32(v17, (float32x2_t)0xBF000000BF000000), (float32x2_t)v44);
          *(float *)v44.i32 = -*(float *)&v45.i32[1];
          float32x2_t v46 = (float32x2_t)vzip1_s32(v44, v45);
          int32x2_t v47 = (int32x2_t)vmul_f32(v46, v41);
          int32x2_t v48 = (int32x2_t)vmul_f32(v46, v36);
          *(float32x2_t *)&long long v24 = vmul_n_f32(vadd_f32((float32x2_t)vzip1_s32(v47, v48), (float32x2_t)vzip2_s32(v47, v48)), *(float *)v37.i32);
          float v49 = 1.0 - vaddv_f32(*(float32x2_t *)&v24);
          float32x2_t v50 = (float32x2_t)vzip1_s32(v42, v43);
          float32x2_t v51 = (float32x2_t)vzip2_s32(v42, v43);
          do
          {
            uint64_t v52 = v58.u32[0];
            float v53 = v49;
            float32x2_t v54 = (float32x2_t)v24;
            if (v58.i32[0] < v59.i32[0])
            {
              do
              {
                if (v54.f32[1] >= -0.00001 && v54.f32[0] >= -0.00001 && v53 >= -0.00001)
                {
                  v55.i64[0] = 0x3F0000003F000000;
                  v55.i64[1] = 0x3F0000003F000000;
                  uint32x4_t v56 = vcvtq_u32_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(v55, v31, v54.f32[1] * 255.0), v32, v54.f32[0] * 255.0), v33, v53 * 255.0));
                  int v57 = v56.i32[2] | (v56.i32[0] << 16) | (v56.i32[3] << 24) | (v56.i32[1] << 8);
                  if (*(unsigned char *)(a1 + 68) == 32) {
                    *(_DWORD *)(v35 + 4 * v52) = v57;
                  }
                  else {
                    *(unsigned char *)(v35 + v52) = HIBYTE(v57);
                  }
                }
                float32x2_t v54 = vsub_f32(v54, v51);
                float v53 = v53 - v40.f32[1];
                ++v52;
              }
              while (v59.i32[0] != v52);
              int v34 = *(_DWORD *)(a1 + 64);
            }
            *(float32x2_t *)&long long v24 = vadd_f32(*(float32x2_t *)&v24, v50);
            float v49 = v49 + v40.f32[0];
            v35 += v34;
            ++v25;
          }
          while (v25 != v59.i32[1]);
        }
      }
    }
  }
}

void RB::CGContext::add_soft_mask<RB::CGContext::update_state_slow(RB::AffineTransform const*,RB::DisplayList::ClipNode const*,float,RB::BlendMode,RB::Bounds const&,BOOL)::$_1>(RB::CGContext::SoftMaskMode,RB::Rect,RB::CGContext::update_state_slow(RB::AffineTransform const*,RB::DisplayList::ClipNode const*,float,RB::BlendMode,RB::Bounds const&,BOOL)::$_1 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke(uint64_t a1, void *a2)
{
  uint64_t v2 = (void *)*a2;
  if (*a2)
  {
    do
    {
      int v4 = (unsigned char *)(v2[1] & 0xFFFFFFFFFFFFFFFELL);
      if (v4[44] != 1 && (v4[45] & 1) == 0)
      {
        _S0 = (*(float (**)(unint64_t))(*(void *)v4 + 104))(v2[1] & 0xFFFFFFFFFFFFFFFELL);
        if (_S0 != 1.0)
        {
          __asm { FCVT            H0, S0 }
          int v11 = 0;
          __int16 v12 = 0;
          __int16 v13 = _H0;
          __int16 v14 = 0;
          (*(void (**)(unsigned char *, uint64_t, int *))(*(void *)v4 + 96))(v4, a1, &v11);
        }
      }
      uint64_t v2 = (void *)*v2;
    }
    while (v2);
  }
}

void *RB::vector<RB::CGContext::GState,4ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 67) + (*((_DWORD *)__dst + 67) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 67) + (*((_DWORD *)__dst + 67) >> 1);
  }
  size_t result = RB::details::realloc_vector<unsigned int,64ul>(*((void **)__dst + 32), __dst, 4u, (_DWORD *)__dst + 67, v3);
  *((void *)__dst + 32) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,64ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  float64x2_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, (unint64_t)a5 << 6);
      free(v7);
      __int16 v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size((unint64_t)a5 << 6);
    size_t v9 = v8 >> 6;
    if (*a4 != (v8 >> 6))
    {
      int v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      __int16 v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, (unint64_t)*a4 << 6);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

void *RB::vector<RB::CGContext::LayerState,4ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 115) + (*((_DWORD *)__dst + 115) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 115) + (*((_DWORD *)__dst + 115) >> 1);
  }
  size_t result = RB::details::realloc_vector<unsigned int,112ul>(*((void **)__dst + 56), __dst, 4u, (_DWORD *)__dst + 115, v3);
  *((void *)__dst + 56) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,112ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  float64x2_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 112 * a5);
      free(v7);
      __int16 v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(112 * a5);
    uint64_t v9 = ((v8 >> 4) * (unsigned __int128)0x2492492492492493uLL) >> 64;
    if (*a4 != v9)
    {
      int v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      __int16 v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 112 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

double RB::CGContext::add_soft_mask<RB::CGContext::add_alpha_mask(CGImage *,RB::Rect const&)::$_0>(RB::CGContext::SoftMaskMode,RB::Rect,RB::CGContext::add_alpha_mask(CGImage *,RB::Rect const&)::$_0 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke(CGContextRef *a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a2 + 8);
  v4.origin.double x = COERCE_FLOAT(*v2);
  v4.origin.double y = COERCE_FLOAT(HIDWORD(*v2));
  v4.size.double width = COERCE_FLOAT(v2[1]);
  v4.size.double height = COERCE_FLOAT(HIDWORD(v2[1]));
  CGContextDrawImage(*a1, v4, *(CGImageRef *)a2);
  return result;
}

float RBColorMakeLinear(int8x16_t a1, float a2, float a3)
{
  int8x16_t v9 = a1;
  if (*(float *)a1.i32 <= 0.0) {
    *(float *)a1.i32 = -*(float *)a1.i32;
  }
  if (*(float *)a1.i32 <= 0.04045)
  {
    *(float *)a1.i32 = *(float *)a1.i32 * 0.077399;
    int8x16_t v8 = a1;
  }
  else
  {
    *(float *)&uint64_t v3 = powf((float)(*(float *)a1.i32 * 0.94787) + 0.052133, 2.4);
    v8.i64[0] = v3;
  }
  float v4 = -a2;
  if (a2 > 0.0) {
    float v4 = a2;
  }
  if (v4 > 0.04045) {
    powf((float)(v4 * 0.94787) + 0.052133, 2.4);
  }
  float v5 = -a3;
  if (a3 > 0.0) {
    float v5 = a3;
  }
  if (v5 > 0.04045) {
    powf((float)(v5 * 0.94787) + 0.052133, 2.4);
  }
  v6.i64[0] = 0x8000000080000000;
  v6.i64[1] = 0x8000000080000000;
  LODWORD(result) = vbslq_s8(v6, v8, v9).u32[0];
  return result;
}

double RBColorFromComponents(CGColorSpace *a1, float64x2_t *a2, int a3)
{
  if (a3) {
    unsigned int v3 = 2;
  }
  else {
    unsigned int v3 = 1;
  }
  *(void *)&double result = RBColorFromComponents2(a1, a2, v3).u64[0];
  return result;
}

double RBColorFromCGColor(CGColor *a1, int a2)
{
  ColorSpace = CGColorGetColorSpace(a1);
  Components = (float64x2_t *)CGColorGetComponents(a1);
  if (a2) {
    unsigned int v6 = 2;
  }
  else {
    unsigned int v6 = 1;
  }
  *(void *)&double result = RBColorFromComponents2(ColorSpace, Components, v6).u64[0];
  return result;
}

CGColorRef RBColorCopyCGColor(unsigned int a1, float a2, float a3, float a4, float a5)
{
  components[4] = *(CGFloat *)MEMORY[0x263EF8340];
  components[0] = a2;
  components[1] = a3;
  CGFloat components[2] = a4;
  components[3] = a5;
  BOOL v5 = a2 < 0.0;
  if (a2 > 1.0) {
    BOOL v5 = 1;
  }
  if (a3 < 0.0) {
    BOOL v5 = 1;
  }
  if (a3 > 1.0) {
    BOOL v5 = 1;
  }
  if (a4 < 0.0) {
    BOOL v5 = 1;
  }
  char v6 = a4 > 1.0 || v5;
  __int16 v7 = rb_color_space(a1);
  if ((v7 & 0xFF00) != 0) {
    unsigned __int8 v8 = v7;
  }
  else {
    unsigned __int8 v8 = 1;
  }
  int8x16_t v9 = RB::cg_color_space((RB *)v8, v6);
  return CGColorCreate(v9, components);
}

float RBColorToLinear(int8x16_t a1, float a2, float a3)
{
  int8x16_t v9 = a1;
  if (*(float *)a1.i32 <= 0.0) {
    *(float *)a1.i32 = -*(float *)a1.i32;
  }
  if (*(float *)a1.i32 <= 0.04045)
  {
    *(float *)a1.i32 = *(float *)a1.i32 * 0.077399;
    int8x16_t v8 = a1;
  }
  else
  {
    *(float *)&uint64_t v3 = powf((float)(*(float *)a1.i32 * 0.94787) + 0.052133, 2.4);
    v8.i64[0] = v3;
  }
  float v4 = -a2;
  if (a2 > 0.0) {
    float v4 = a2;
  }
  if (v4 > 0.04045) {
    powf((float)(v4 * 0.94787) + 0.052133, 2.4);
  }
  float v5 = -a3;
  if (a3 > 0.0) {
    float v5 = a3;
  }
  if (v5 > 0.04045) {
    powf((float)(v5 * 0.94787) + 0.052133, 2.4);
  }
  v6.i64[0] = 0x8000000080000000;
  v6.i64[1] = 0x8000000080000000;
  LODWORD(result) = vbslq_s8(v6, v8, v9).u32[0];
  return result;
}

float RBColorAdd(unsigned int a1, unsigned __int8 a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, float a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint16x4_t a17)
{
  _S8 = a10;
  _S9 = a9;
  _S10 = a8;
  _S11 = a7;
  _S12 = a6;
  _S13 = a5;
  _S14 = a4;
  _S15 = a3;
  unsigned __int16 v26 = rb_color_space(a1);
  unsigned __int8 v27 = v26;
  unsigned int v28 = v26;
  __asm
  {
    FCVT            H0, S15
    FCVT            H1, S14
    FCVT            H2, S13
    FCVT            H3, S12
  }
  __int16 v51 = _H0;
  __int16 v52 = _H1;
  __int16 v53 = _H2;
  __int16 v54 = _H3;
  unsigned __int16 v55 = v26;
  __asm
  {
    FCVT            H0, S11
    FCVT            H1, S10
    FCVT            H2, S9
    FCVT            H3, S8
  }
  v50[0] = _H0;
  v50[1] = _D1.i16[0];
  v50[2] = _H2;
  float64x2_t v50[3] = _H3;
  v50[4] = v26;
  RB::Fill::Color::mix((uint64_t)&v51, (uint64_t)v50, a2, a17, _D1);
  if (v28 >= 0x100) {
    RB::Fill::Color::convert((uint64_t)&v51, v27, v41);
  }
  _H0 = v51;
  __asm { FCVT            S0, H0 }
  _H1 = v52;
  __asm { FCVT            S1, H1 }
  _H2 = v53;
  __asm { FCVT            S2, H2 }
  _H3 = v54;
  __asm { FCVT            S3, H3 }
  return result;
}

BOOL RBColorEqualToColor(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  return a1 == a5 && a2 == a6 && a3 == a7 && a4 == a8;
}

int32x2_t *RB::DisplayList::Builder::Builder(int32x2_t *this, atomic_uint *a2)
{
  float v4 = (atomic_uint *)RB::DisplayList::Builder::Builder(this)[1];
  if (v4 != a2)
  {
    if (v4 && atomic_fetch_add_explicit(v4 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v4 + 8))(v4);
    }
    atomic_fetch_add_explicit(a2 + 2, 1u, memory_order_relaxed);
    this[1] = (int32x2_t)a2;
  }
  this[34].i8[0] = *((unsigned char *)a2 + 400) ^ 1;
  this[28] = (int32x2_t)(a2 + 80);
  int v5 = this->i32[0] + 1;
  this->i32[0] = v5;
  this[32].i32[0] = v5;
  this[4] = (int32x2_t)&this[28];
  return this;
}

void sub_2141C00B8(_Unwind_Exception *a1)
{
  RB::DisplayList::Builder::~Builder(v1);
  _Unwind_Resume(a1);
}

void RB::DisplayList::Builder::save(RB::DisplayList::Builder *this)
{
  uint64_t v2 = (const RB::DisplayList::State *)*((void *)this + 33);
  uint64_t v3 = (RB::DisplayList::State *)*((void *)this + 2);
  if (v3) {
    *((void *)this + 2) = *(void *)v3;
  }
  else {
    uint64_t v3 = (RB::DisplayList::State *)malloc_type_malloc(0xB0uLL, 0x9E39E26DuLL);
  }
  RB::DisplayList::State::State(v3, v2);
  void *v4 = *((void *)this + 33);
  *((void *)this + 33) = v4;
}

atomic_uint *RB::DisplayList::Builder::save(RB::DisplayList::Builder *this, LayerState *a2)
{
  int v4 = *(_DWORD *)(*(void *)a2 + 56);
  int v5 = (const RB::DisplayList::State *)*((void *)this + 33);
  int8x16_t v6 = (RB::DisplayList::State *)*((void *)this + 2);
  if (v6) {
    *((void *)this + 2) = *(void *)v6;
  }
  else {
    int8x16_t v6 = (RB::DisplayList::State *)malloc_type_malloc(0xB0uLL, 0x9E39E26DuLL);
  }
  float result = (atomic_uint *)RB::DisplayList::State::State(v6, v4, v5);
  uint64_t v8 = *(void *)a2;
  uint64_t v9 = *((void *)this + 33);
  if ((*(unsigned char *)(v8 + 61) & 4) != 0)
  {
    float result = (atomic_uint *)*((void *)v6 + 11);
    int v10 = *(atomic_uint **)(v9 + 88);
    if (result != v10)
    {
      if (result)
      {
        if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
        {
          __dmb(9u);
          float result = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 8))(result);
        }
        int v10 = *(atomic_uint **)(v9 + 88);
      }
      if (v10) {
        atomic_fetch_add_explicit(v10 + 2, 1u, memory_order_relaxed);
      }
      *((void *)v6 + 11) = v10;
      uint64_t v9 = *((void *)this + 33);
    }
  }
  *(void *)int8x16_t v6 = v9;
  *((void *)this + 33) = v6;
  return result;
}

atomic_uint *RB::DisplayList::Builder::restore(RB::DisplayList::Builder *this, const char *a2)
{
  uint64_t v2 = (uint64_t *)*((void *)this + 33);
  uint64_t v3 = *v2;
  if (!*v2) {
    RB::precondition_failure((RB *)"too many gstate restores", a2);
  }
  if ((a2 & 1) == 0 && *((_DWORD *)v2 + 36) != *(_DWORD *)(v3 + 144)) {
    RB::precondition_failure((RB *)"restoring out of layer", a2);
  }
  *((void *)this + 33) = v3;
  float result = (atomic_uint *)v2[11];
  if (result && atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    float result = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 8))(result);
  }
  *uint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = v2;
  return result;
}

void RB::DisplayList::Builder::clip_layer(RB::DisplayList::Builder *this, RB::DisplayList::Layer *a2, __n128 *a3, uint64_t a4, __n128 a5)
{
  float v6 = a5.n128_f32[0];
  uint64_t v8 = (uint64_t)a2;
  uint64_t v22 = *MEMORY[0x263EF8340];
  int32x2_t v18 = a2;
  unsigned __int32 v17 = a5.n128_u32[0];
  unsigned int v16 = a4;
  if (*((unsigned char *)this + 272))
  {
    if (a5.n128_f32[0] == 0.0)
    {
      RB::DisplayList::Layer::~Layer(a2);
      goto LABEL_21;
    }
    uint64_t v8 = (uint64_t)RB::DisplayList::Builder::simplify_clip_layer(this, a2, a4);
    unint64_t v10 = (unint64_t)v11;
    int32x2_t v18 = (RB::DisplayList::Layer *)v8;
  }
  else
  {
    unint64_t v10 = 0;
  }
  if (!(v8 | v10))
  {
LABEL_21:
    if (a4 != 1)
    {
      memset(v19, 0, sizeof(v19));
      LODWORD(v20) = 1065353216;
      *(void *)((char *)&v20 + 4) = 0;
      *(_DWORD *)((char *)&v20 + 11) = 0;
      RB::DisplayList::State::clip<RB::Coverage::Primitive>(a3, this, v19, a4, 1.0);
    }
    return;
  }
  if (v10)
  {
    RB::DisplayList::State::append((RB::DisplayList::State *)a3, this, *(const RB::DisplayList::ClipNode **)(v10 + 24), a4 == 1);
    *(void *)(v10 + 24) = 0;
    long long v20 = 0uLL;
    uint64_t v21 = 4;
    (*(void (**)(unint64_t, RB::DisplayList::Builder *, uint64_t, _OWORD *, float))(*(void *)v10 + 88))(v10, this, a4, v19, v6);
    __int16 v12 = (void *)v20;
    if ((void)v20) {
      __int16 v13 = (RB::DisplayList::Clip **)v20;
    }
    else {
      __int16 v13 = (RB::DisplayList::Clip **)v19;
    }
    if (*((void *)&v20 + 1))
    {
      uint64_t v14 = 8 * *((void *)&v20 + 1);
      do
      {
        RB::DisplayList::State::push((RB::DisplayList::State *)a3, this, *v13++);
        v14 -= 8;
      }
      while (v14);
      __int16 v12 = (void *)v20;
    }
    if (v12) {
      free(v12);
    }
  }
  if (v8)
  {
    if (*((unsigned char *)this + 272)) {
      RB::DisplayList::Layer::discard_color(v8);
    }
    float32x2_t v15 = (RB::DisplayList::Clip *)RB::Heap::emplace<RB::DisplayList::LayerClip,RB::DisplayList::Layer *&,float &,RB::ClipMode const&>((size_t *)(*((void *)this + 1) + 16), (uint64_t *)&v18, &v17, &v16, a5);
    RB::DisplayList::State::push((RB::DisplayList::State *)a3, this, v15);
  }
}

void sub_2141C04C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  if (a15) {
    free(a15);
  }
  _Unwind_Resume(exception_object);
}

RB::DisplayList::Layer *RB::DisplayList::Builder::simplify_clip_layer(RB::DisplayList::Builder *this, RB::DisplayList::Layer *a2, int a3)
{
  uint64_t v3 = a2;
  if (a2)
  {
    if (!*(void *)a2 && (*((_WORD *)a2 + 30) & 0x2001) == 0)
    {
      char v7 = RB::DisplayList::Layer::effect_needs_zero_alpha(a2);
      if ((v7 & 1) != 0 || (uint64_t v8 = (void *)*((void *)v3 + 2)) == 0)
      {
LABEL_13:
        if ((v7 & 1) == 0)
        {
LABEL_14:
          RB::DisplayList::Layer::~Layer(v3);
          return 0;
        }
      }
      else
      {
        while (1)
        {
          uint64_t v11 = 0;
          float32x2_t v12 = 0;
          (*(void (**)(void *, uint64_t *))(*v8 + 56))(v8, &v11);
          uint32x2_t v9 = (uint32x2_t)vcgtz_f32(v12);
          if ((vpmin_u32(v9, v9).u32[0] & 0x80000000) != 0) {
            break;
          }
          uint64_t v8 = (void *)v8[1];
          if (!v8) {
            goto LABEL_13;
          }
        }
      }
    }
    RB::DisplayList::Builder::lower_color_filters(this, v3, 0);
    if (a3 == 1) {
      int v6 = 14;
    }
    else {
      int v6 = 10;
    }
    if (RB::DisplayList::Builder::merge_layer_item(this, v3, v6)) {
      goto LABEL_14;
    }
  }
  return v3;
}

uint64_t RB::DisplayList::State::clip<RB::Coverage::Primitive>(__n128 *a1, RB::DisplayList::Builder *a2, _OWORD *a3, int a4, float a5)
{
  float v15 = a5;
  int v14 = a4;
  uint64_t v8 = (RB::Heap *)(*((void *)a2 + 1) + 16);
  __n128 v9 = RB::DisplayList::State::copy_ctm(a1, v8);
  uint64_t v13 = v10;
  uint64_t v11 = (RB::DisplayList::Clip *)RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive&,float &,RB::ClipMode &,RB::AffineTransform const*&>((size_t *)v8, (int8x16_t)v9, (uint64_t)v8, a3, (unsigned __int32 *)&v15, &v14, &v13);
  return RB::DisplayList::State::push((RB::DisplayList::State *)a1, a2, v11);
}

float *RB::DisplayList::Builder::make_layer_item(RB::DisplayList::Builder *this, RB::DisplayList::Layer *a2, int a3, float64x2_t *a4, float a5, float a6)
{
  char v6 = a3;
  __n128 v9 = (float *)a2;
  v22[14] = *MEMORY[0x263EF8340];
  int32x2_t v18 = a2;
  float v17 = a5;
  int v16 = a3;
  int64x2_t v11 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*a4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(a4[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v11, 1), (int8x16_t)v11).u64[0] & 0x8000000000000000) == 0)
  {
    RB::DisplayList::CachedTransform::CachedTransform((uint64_t)v19, (uint64_t)this, (long long *)a4, 0, 0, 0);
    RB::DisplayList::Layer::apply_transform((RB::DisplayList::Layer *)v9, (const RB::DisplayList::CachedTransform *)v19);
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v22);
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v21);
    RB::Heap::~Heap((RB::Heap *)&v20);
  }
  if (a6 > 0.0 && a6 < 1.0)
  {
    RB::DisplayList::Layer::min_scale((RB::DisplayList::Layer *)v9);
    if (v12 <= a6) {
      float v12 = a6;
    }
    v9[12] = v12;
  }
  if (!*((unsigned char *)this + 272))
  {
    if (!v9) {
      return v9;
    }
    goto LABEL_14;
  }
  if (a5 == 0.0)
  {
    RB::DisplayList::Layer::~Layer((RB::DisplayList::Layer *)v9);
    return 0;
  }
  int32x2_t v18 = RB::DisplayList::Builder::simplify_clip_layer(this, (RB::DisplayList::Layer *)v9, 0);
  if (v18)
  {
LABEL_14:
    RB::Heap::emplace<RB::DisplayList::LayerItem,float &,RB::BlendMode &,RB::DisplayList::Layer *&>((size_t *)(*((void *)this + 1) + 16), &v17, &v16, (uint64_t *)&v18);
    return (float *)v14;
  }
  __n128 v9 = (float *)v13;
  if (v13)
  {
    *(_WORD *)(v13 + 46) = *(_WORD *)(v13 + 46) & 0xFFC0 | v6 & 0x3F;
    RB::DisplayList::Item::apply_alpha(v13, a5);
  }
  return v9;
}

void sub_2141C083C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

RB::DisplayList::Layer *RB::DisplayList::Builder::simplify_item(RB::DisplayList::Layer *result, RB::DisplayList::Layer **a2, char a3)
{
  if (*((unsigned char *)result + 272))
  {
    int v4 = *a2;
    if ((*((_WORD *)*a2 + 23) & 0x200) != 0)
    {
      float result = RB::DisplayList::Builder::simplify_clip_layer(result, *((RB::DisplayList::Layer **)v4 + 6), 0);
      if (result)
      {
        if (a3)
        {
          uint64_t v7 = *((void *)v4 + 6);
          return (RB::DisplayList::Layer *)RB::DisplayList::Layer::discard_color(v7);
        }
      }
      else
      {
        float result = *a2;
        *a2 = v6;
        if (result)
        {
          uint64_t v8 = **(uint64_t (***)(void))result;
          return (RB::DisplayList::Layer *)v8();
        }
      }
    }
  }
  return result;
}

const RB::DisplayList::ClipNode *RB::DisplayList::Builder::join_clip_lists(uint64_t a1, void *a2, const RB::DisplayList::ClipNode *a3)
{
  if (a2)
  {
    uint64_t v3 = a2;
    if (a3)
    {
      __n128 v9 = a3;
      do
      {
        int v5 = (size_t *)(*(void *)(a1 + 8) + 16);
        uint64_t v8 = (const RB::DisplayList::Clip *)(v3[1] & 0xFFFFFFFFFFFFFFFELL);
        char v6 = (const RB::DisplayList::ClipNode *)RB::Heap::emplace<RB::DisplayList::ClipNode,RB::DisplayList::Clip const*&,RB::DisplayList::ClipNode*&>(v5, &v8, &v9);
        __n128 v9 = v6;
        uint64_t v3 = (void *)*v3;
      }
      while (v3);
      return v6;
    }
    else
    {
      return (const RB::DisplayList::ClipNode *)a2;
    }
  }
  return a3;
}

float64x2_t RB::DisplayList::CachedTransform::CachedTransform(RB::DisplayList::CachedTransform *this, float64x2_t *a2, float a3, float a4, int a5)
{
  uint64_t v6 = *(void *)&a2->f64[0];
  double v7 = a3;
  float64x2_t v8 = vmulq_n_f64(a2[68], v7);
  float64x2_t v9 = vmulq_n_f64(a2[69], v7);
  long long v10 = (__int128)a2[70];
  v13[0] = (__int128)v8;
  v13[1] = (__int128)v9;
  void v13[2] = v10;
  int64x2_t v11 = (float64x2_t *)RB::DisplayList::CachedTransform::CachedTransform((uint64_t)this, v6, v13, 0, 0, a5);
  float64x2_t result = vmulq_n_f64(v11[70], a4);
  v11[70] = result;
  return result;
}

void RB::DisplayList::CachedTransform::transform_scale(RB::DisplayList::CachedTransform *this)
{
  if (*((float *)this + 288) == 0.0) {
    *((float *)this + 288) = RB::AffineTransform::scale((float64x2_t *)this + 68);
  }
}

uint64_t RB::DisplayList::CachedTransform::transform_projection(RB::DisplayList::CachedTransform *this, const RB::ProjectionMatrix *a2)
{
  if (*((const RB::ProjectionMatrix **)this + 154) == a2) {
    return *((void *)this + 155);
  }
  long long v4 = *((_OWORD *)this + 69);
  float64x2_t v19 = *((float64x2_t *)this + 68);
  long long v20 = v4;
  long long v21 = *((_OWORD *)this + 70);
  BOOL v5 = RB::AffineTransform::invert((RB::AffineTransform *)&v19);
  if (v5) {
    uint64_t v6 = &v19;
  }
  else {
    uint64_t v6 = (float64x2_t *)((char *)this + 1088);
  }
  float64x2_t v7 = *v6;
  if (v5) {
    float64x2_t v8 = &v20;
  }
  else {
    float64x2_t v8 = (long long *)((char *)this + 1104);
  }
  long long v9 = *v8;
  if (v5) {
    long long v10 = &v21;
  }
  else {
    long long v10 = (long long *)((char *)this + 1120);
  }
  long long v11 = *v10;
  float64x2_t v19 = v7;
  long long v20 = v9;
  long long v21 = v11;
  *((void *)this + 154) = a2;
  float v12 = *(size_t **)(*(void *)this + 8);
  RB::operator*(&v19, (uint64_t)a2, (uint64_t)v16);
  RB::operator*(v16, (float64x2_t *)this + 68, (uint64_t)v17);
  uint64_t result = (v12[4] + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if (result + 36 > v12[5]) {
    uint64_t result = RB::Heap::alloc_slow(v12 + 2, 0x24uLL, 3);
  }
  else {
    v12[4] = result + 36;
  }
  long long v14 = v17[0];
  long long v15 = v17[1];
  *(_DWORD *)(result + 32) = v18;
  *(_OWORD *)uint64_t result = v14;
  *(_OWORD *)(result + 16) = v15;
  *((void *)this + 155) = result;
  return result;
}

uint64_t RB::DisplayList::can_mix(uint64_t a1, void *a2, void *a3)
{
  BOOL v3 = a2 != 0;
  BOOL v4 = a3 != 0;
  uint64_t v5 = 4;
  if (a2 && (uint64_t v6 = a3) != 0)
  {
    float64x2_t v7 = a2;
    while (v7 != v6)
    {
      if (!RB::same_type<RB::DisplayList::Clip>(v7[1] & 0xFFFFFFFFFFFFFFFELL, v6[1] & 0xFFFFFFFFFFFFFFFELL)) {
        return 0;
      }
      unsigned int v9 = (*(unsigned __int8 (**)(unint64_t, uint64_t, unint64_t))(*(void *)(v7[1] & 0xFFFFFFFFFFFFFFFELL)
                                                                                          + 64))(v7[1] & 0xFFFFFFFFFFFFFFFELL, a1, v6[1] & 0xFFFFFFFFFFFFFFFELL);
      if (v9 >= v5) {
        uint64_t v5 = v5;
      }
      else {
        uint64_t v5 = v9;
      }
      float64x2_t v7 = (void *)*v7;
      uint64_t v6 = (void *)*v6;
      BOOL v3 = v7 != 0;
      BOOL v4 = v6 != 0;
      if (v5) {
        BOOL v10 = v7 == 0;
      }
      else {
        BOOL v10 = 1;
      }
      if (v10 || v6 == 0) {
        goto LABEL_17;
      }
    }
  }
  else
  {
LABEL_17:
    if (v3 || v4) {
      return 0;
    }
    else {
      return v5;
    }
  }
  return v5;
}

BOOL RB::same_type<RB::DisplayList::Clip>(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  BOOL result = 0;
  if (a1)
  {
    if (a2)
    {
      int v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      return v5 == (*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2);
    }
  }
  return result;
}

uint64_t RB::DisplayList::can_mix(uint64_t a1, float32x2_t *a2, float32x2_t *a3, uint64_t a4, uint64_t a5)
{
  float64x2_t v7 = (float32x2_t **)a3;
  float64x2_t v8 = (float32x2_t **)a2;
  uint64_t v9 = 4;
  if (!a2 || !a3)
  {
LABEL_11:
    if (v8)
    {
LABEL_12:
      double v12 = (*(double (**)(uint64_t, uint64_t))(*(void *)a4 + 144))(a4, 2);
      double v29 = v12;
      double v30 = v13;
      LODWORD(v12) = 1036831949;
      RB::Rect::inset((float32x2_t *)&v29, *(float32x2_t *)&v12, 0.1);
      while (1)
      {
        if (v8[1])
        {
          float32x2_t v18 = (float32x2_t)v8[3];
          unsigned __int8 v27 = v8[2];
          float32x2_t v28 = v18;
          if (RB::Rect::contains((float32x2_t *)&v27, *(float32x2_t *)&v29, *(float32x2_t *)&v30, v14, v15, v16, v17)) {
            break;
          }
        }
        if ((*(unsigned int (**)(unint64_t, double, double))(*(void *)((unint64_t)v8[1] & 0xFFFFFFFFFFFFFFFELL)
                                                                              + 32))((unint64_t)v8[1] & 0xFFFFFFFFFFFFFFFELL, v29, v30))
        {
          float64x2_t v8 = (float32x2_t **)*v8;
          if (v8) {
            continue;
          }
        }
        goto LABEL_17;
      }
      float64x2_t v8 = 0;
      if (!v7) {
        goto LABEL_27;
      }
    }
    else
    {
LABEL_17:
      if (!v7)
      {
LABEL_27:
        if ((unint64_t)v8 | (unint64_t)v7) {
          return 0;
        }
        else {
          return v9;
        }
      }
    }
    double v19 = (*(double (**)(uint64_t, uint64_t))(*(void *)a5 + 144))(a5, 2);
    double v29 = v19;
    double v30 = v20;
    LODWORD(v19) = 1036831949;
    RB::Rect::inset((float32x2_t *)&v29, *(float32x2_t *)&v19, 0.1);
    while (1)
    {
      if (v7[1])
      {
        float32x2_t v25 = (float32x2_t)v7[3];
        unsigned __int8 v27 = v7[2];
        float32x2_t v28 = v25;
        if (RB::Rect::contains((float32x2_t *)&v27, *(float32x2_t *)&v29, *(float32x2_t *)&v30, v21, v22, v23, v24)) {
          break;
        }
      }
      if ((*(unsigned int (**)(unint64_t, double, double))(*(void *)((unint64_t)v7[1] & 0xFFFFFFFFFFFFFFFELL)
                                                                            + 32))((unint64_t)v7[1] & 0xFFFFFFFFFFFFFFFELL, v29, v30))
      {
        float64x2_t v7 = (float32x2_t **)*v7;
        if (v7) {
          continue;
        }
      }
      goto LABEL_27;
    }
    float64x2_t v7 = 0;
    goto LABEL_27;
  }
  while (v8 != v7)
  {
    if (!RB::same_type<RB::DisplayList::Clip>((unint64_t)v8[1] & 0xFFFFFFFFFFFFFFFELL, (unint64_t)v7[1] & 0xFFFFFFFFFFFFFFFELL))goto LABEL_12; {
    unsigned int v11 = (*(unsigned __int8 (**)(unint64_t, uint64_t, unint64_t))(*(void *)((unint64_t)v8[1] & 0xFFFFFFFFFFFFFFFELL)
    }
                                                                                         + 64))((unint64_t)v8[1] & 0xFFFFFFFFFFFFFFFELL, a1, (unint64_t)v7[1] & 0xFFFFFFFFFFFFFFFELL);
    uint64_t v9 = v11 >= v9 ? v9 : v11;
    if (!v9) {
      break;
    }
    float64x2_t v8 = (float32x2_t **)*v8;
    float64x2_t v7 = (float32x2_t **)*v7;
    if (!v8 || !v7) {
      goto LABEL_11;
    }
  }
  return v9;
}

const RB::DisplayList::ClipNode *RB::DisplayList::CachedTransform::mix_clip(const RB::DisplayList::ClipNode **this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::ClipNode *a3, const RB::DisplayList::ClipNode *a4, int a5)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  float32x2_t v25 = 0;
  size_t v26 = 0;
  unint64_t v27 = 16;
  if (a3)
  {
    float64x2_t v7 = a4;
    if (a4)
    {
      float64x2_t v8 = a3;
      do
      {
        if (!RB::same_type<RB::DisplayList::Clip>(*((void *)v8 + 1) & 0xFFFFFFFFFFFFFFFELL, *((void *)v7 + 1) & 0xFFFFFFFFFFFFFFFELL))break; {
        uint64_t v10 = (*(uint64_t (**)(unint64_t, const RB::DisplayList::Interpolator::State *, unint64_t, const RB::DisplayList::ClipNode **))(*(void *)(*((void *)v8 + 1) & 0xFFFFFFFFFFFFFFFELL) + 72))(*((void *)v8 + 1) & 0xFFFFFFFFFFFFFFFELL, a2, *((void *)v7 + 1) & 0xFFFFFFFFFFFFFFFELL, this);
        }
        *(void *)(v10 + 32) = RB::DisplayList::CachedTransform::transform_metadata((RB::DisplayList::CachedTransform *)this, *(const RB::DisplayList::Metadata **)((*((void *)v7 + 1) & 0xFFFFFFFFFFFFFFFELL) + 32), *(_DWORD *)((*((void *)v7 + 1) & 0xFFFFFFFFFFFFFFFELL) + 40));
        *(_DWORD *)(v10 + 40) = v11;
        size_t v12 = v26;
        size_t v13 = v26 + 1;
        if (v27 < v26 + 1)
        {
          _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(__dst, v13);
          size_t v12 = v26;
          size_t v13 = v26 + 1;
        }
        double v14 = v25;
        if (!v25) {
          double v14 = __dst;
        }
        *(void *)&v14[8 * v12] = v10;
        size_t v26 = v13;
        float64x2_t v8 = *(const RB::DisplayList::ClipNode **)v8;
        if (!v8) {
          break;
        }
        float64x2_t v7 = *(const RB::DisplayList::ClipNode **)v7;
      }
      while (v7);
    }
  }
  if (a5) {
    double v15 = this[134];
  }
  else {
    double v15 = 0;
  }
  double v23 = v15;
  if (v26)
  {
    size_t v16 = v26 - 1;
    while (1)
    {
      double v22 = 0;
      int32x4_t v17 = v25;
      if (!v25) {
        int32x4_t v17 = __dst;
      }
      float32x2_t v18 = *(const RB::DisplayList::Clip **)&v17[8 * v16];
      double v22 = v18;
      double v19 = *this;
      if (!*((unsigned char *)*this + 272)) {
        goto LABEL_22;
      }
      if ((RB::DisplayList::ClipNode::elide_append((uint64_t *)&v23, (float32x2_t *)v18) & 1) == 0) {
        break;
      }
      (**(void (***)(const RB::DisplayList::Clip *))v22)(v22);
LABEL_23:
      if (--v16 == -1)
      {
        double v15 = v23;
        goto LABEL_25;
      }
    }
    double v19 = *this;
    float32x2_t v18 = v22;
LABEL_22:
    uint64_t v20 = *((void *)v19 + 1);
    *((void *)v18 + 1) = *(void *)(v20 + 312);
    *(void *)(v20 + 312) = v18;
    double v23 = (const RB::DisplayList::ClipNode *)RB::Heap::emplace<RB::DisplayList::ClipNode,RB::DisplayList::Clip const*&,RB::DisplayList::ClipNode*&>((size_t *)(v20 + 16), &v22, &v23);
    goto LABEL_23;
  }
LABEL_25:
  if (v25) {
    free(v25);
  }
  return v15;
}

void sub_2141C1158(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27)
{
  if (a27) {
    free(a27);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::DisplayList::CachedTransform::mix_clip_bounds(uint64_t a1, float32x2_t *a2, double *a3, void *a4)
{
  *a2 = (float32x2_t)0x100000001000000;
  a2[1] = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
  uint64_t result = 1;
  if (a3)
  {
    uint64_t v6 = a4;
    if (a4)
    {
      float64x2_t v7 = a3;
      while (1)
      {
        if (!RB::same_type<RB::DisplayList::Clip>((void)v7[1] & 0xFFFFFFFFFFFFFFFELL, v6[1] & 0xFFFFFFFFFFFFFFFELL)) {
          return 1;
        }
        float32x2_t v9 = (float32x2_t)v7[3];
        double v17 = v7[2];
        float32x2_t v18 = v9;
        uint64_t v10 = v6[3];
        v16[0] = v6[2];
        v16[1] = v10;
        if (((*(uint64_t (**)(unint64_t, uint64_t, double *, void *, unint64_t))(*(void *)((void)v7[1] & 0xFFFFFFFFFFFFFFFELL) + 80))((void)v7[1] & 0xFFFFFFFFFFFFFFFELL, a1, &v17, v16, v6[1] & 0xFFFFFFFFFFFFFFFELL) & 1) == 0)break; {
        RB::Rect::intersect(a2, v17, v18, v11, v12, v13, v14);
        }
        uint32x2_t v15 = (uint32x2_t)vclez_f32(a2[1]);
        if ((vpmax_u32(v15, v15).u32[0] & 0x80000000) != 0) {
          return 1;
        }
        float64x2_t v7 = *(double **)v7;
        uint64_t result = 1;
        if (v7)
        {
          uint64_t v6 = (void *)*v6;
          if (v6) {
            continue;
          }
        }
        return result;
      }
      return 0;
    }
  }
  return result;
}

uint64_t RB::DisplayList::can_mix(RB::DisplayList *this, RB::DisplayList::Interpolator::Contents *a2, uint64_t a3, const RB::DisplayList::Style *a4)
{
  for (uint64_t i = a2; i; uint64_t i = (const RB::DisplayList::Style *)*((void *)i + 4))
  {
    if ((*((unsigned char *)i + 52) & 1) == 0) {
      break;
    }
  }
  while (1)
  {
    if (!a3) {
      goto LABEL_8;
    }
    if ((*(unsigned char *)(a3 + 52) & 1) == 0) {
      break;
    }
    a3 = *(void *)(a3 + 32);
  }
  if (!i)
  {
LABEL_8:
    LODWORD(v7) = 4;
    while ((unint64_t)i | a3)
    {
      if (i)
      {
        unsigned int v19 = (*(unsigned __int8 (**)(const RB::DisplayList::Style *, RB::DisplayList *, void, const RB::DisplayList::Style *))(*(void *)i + 80))(i, this, 0, a4);
        if (v19 >= v7) {
          LODWORD(v7) = v7;
        }
        else {
          LODWORD(v7) = v19;
        }
        do
          uint64_t i = (const RB::DisplayList::Style *)*((void *)i + 4);
        while (i && (*((unsigned char *)i + 52) & 1) != 0);
      }
      if (a3)
      {
        unsigned int v18 = (*(unsigned __int8 (**)(uint64_t, RB::DisplayList *, void, const RB::DisplayList::Style *))(*(void *)a3 + 80))(a3, this, 0, a4);
        if (v18 >= v7) {
          LODWORD(v7) = v7;
        }
        else {
          LODWORD(v7) = v18;
        }
        do
          a3 = *(void *)(a3 + 32);
        while (a3 && (*(unsigned char *)(a3 + 52) & 1) != 0);
      }
LABEL_68:
      if (!(_BYTE)v7)
      {
        LODWORD(v7) = 0;
        goto LABEL_86;
      }
    }
    a3 = 0;
    uint64_t i = 0;
LABEL_86:
    if ((unint64_t)i | a3) {
      return 0;
    }
    else {
      return v7;
    }
  }
  uint64_t v7 = 4;
  while (i != (const RB::DisplayList::Style *)a3)
  {
    uint64_t v8 = (uint64_t)i;
    if (RB::same_identity<RB::DisplayList::Style>((uint64_t)i, a3)
      && (uint64_t v8 = (uint64_t)i, RB::same_type<RB::DisplayList::Style>((uint64_t)i, a3)))
    {
      unsigned int v9 = (*(unsigned __int8 (**)(const RB::DisplayList::Style *, RB::DisplayList *, uint64_t))(*(void *)i + 80))(i, this, a3);
      if (v9 >= v7) {
        uint64_t v7 = v7;
      }
      else {
        uint64_t v7 = v9;
      }
      if (v7)
      {
        unsigned int can_mix = RB::DisplayList::can_mix((uint64_t)this, *((void **)i + 3), *(void **)(a3 + 24));
        uint64_t v7 = can_mix >= v7 ? v7 : can_mix;
        if (v7)
        {
          unsigned int v12 = RB::can_mix(*((float64x2_t **)i + 2), *(float64x2_t **)(a3 + 16), v10);
          if (v12 >= v7) {
            uint64_t v7 = v7;
          }
          else {
            uint64_t v7 = v12;
          }
        }
      }
      do
        uint64_t i = (const RB::DisplayList::Style *)*((void *)i + 4);
      while (i && (*((unsigned char *)i + 52) & 1) != 0);
      do
      {
        a3 = *(void *)(a3 + 32);
        if (!a3) {
          goto LABEL_68;
        }
      }
      while ((*(unsigned char *)(a3 + 52) & 1) != 0);
    }
    else
    {
LABEL_33:
      if (RB::same_identity<RB::DisplayList::Style>(v8, a3) && RB::same_type<RB::DisplayList::Style>(v8, a3))
      {
        if (i != (const RB::DisplayList::Style *)v8)
        {
          do
          {
            unsigned int v14 = (*(unsigned __int8 (**)(const RB::DisplayList::Style *, RB::DisplayList *, void))(*(void *)i + 80))(i, this, 0);
            if (v14 >= v7) {
              uint64_t v7 = v7;
            }
            else {
              uint64_t v7 = v14;
            }
            do
              uint64_t i = (const RB::DisplayList::Style *)*((void *)i + 4);
            while (i && (*((unsigned char *)i + 52) & 1) != 0);
            if (v7) {
              BOOL v15 = i == (const RB::DisplayList::Style *)v8;
            }
            else {
              BOOL v15 = 1;
            }
          }
          while (!v15);
        }
      }
      else
      {
        while (1)
        {
          uint64_t v8 = *(void *)(v8 + 32);
          if (!v8) {
            break;
          }
          if ((*(unsigned char *)(v8 + 52) & 1) == 0) {
            goto LABEL_33;
          }
        }
        double v13 = (const RB::DisplayList::Style *)a3;
        while (!RB::same_identity<RB::DisplayList::Style>((uint64_t)v13, (uint64_t)i)
             || !RB::same_type<RB::DisplayList::Style>((uint64_t)v13, (uint64_t)i))
        {
          do
          {
            double v13 = (const RB::DisplayList::Style *)*((void *)v13 + 4);
            if (!v13) {
              goto LABEL_68;
            }
          }
          while ((*((unsigned char *)v13 + 52) & 1) != 0);
        }
        if ((const RB::DisplayList::Style *)a3 != v13)
        {
          do
          {
            unsigned int v16 = (*(unsigned __int8 (**)(uint64_t, RB::DisplayList *, void))(*(void *)a3 + 80))(a3, this, 0);
            if (v16 >= v7) {
              uint64_t v7 = v7;
            }
            else {
              uint64_t v7 = v16;
            }
            do
              a3 = *(void *)(a3 + 32);
            while (a3 && (*(unsigned char *)(a3 + 52) & 1) != 0);
            if (v7) {
              BOOL v17 = a3 == (void)v13;
            }
            else {
              BOOL v17 = 1;
            }
          }
          while (!v17);
        }
      }
    }
    if (!(_BYTE)v7 || !i || !a3) {
      goto LABEL_68;
    }
  }
  return v7;
}

uint64_t RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::CachedTransform *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Style *a3, uint64_t a4, int a5)
{
  uint64_t v7 = (uint64_t)a3;
  uint64_t v86 = *MEMORY[0x263EF8340];
  int32x2_t v83 = 0;
  size_t v84 = 0;
  unint64_t v85 = 16;
  float64x2_t v79 = this;
  BOOL v80 = a5;
  uint64_t __dst = v82;
  if (a3)
  {
    do
    {
      if ((*(unsigned char *)(v7 + 52) & 1) == 0) {
        break;
      }
      uint64_t v10 = (*(uint64_t (**)(uint64_t, void))(*(void *)v7 + 24))(v7, *(void *)this);
      RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_0::operator()((float64x2_t **)&v79, v10, v7);
      uint64_t v7 = *(void *)(v7 + 32);
    }
    while (v7);
  }
  while (1)
  {
    if (!a4) {
      goto LABEL_8;
    }
    if ((*(unsigned char *)(a4 + 52) & 1) == 0) {
      break;
    }
    uint64_t v11 = (*(uint64_t (**)(uint64_t, void))(*(void *)a4 + 24))(a4, *(void *)this);
    RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_0::operator()((float64x2_t **)&v79, v11, a4);
    a4 = *(void *)(a4 + 32);
  }
  if (!v7)
  {
    BOOL v12 = 0;
    BOOL v13 = 1;
    do
    {
LABEL_74:
      if (v12)
      {
        uint64_t v57 = (*(uint64_t (**)(uint64_t, const RB::DisplayList::Interpolator::State *, void, RB::DisplayList::CachedTransform *))(*(void *)v7 + 88))(v7, a2, 0, this);
        if (v57)
        {
          int32x2_t v58 = v79;
          *(void *)(v57 + 16) = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)v79, *(const RB::AffineTransform **)(v7 + 16));
          BOOL v59 = v80;
          *(void *)(v57 + 24) = RB::DisplayList::CachedTransform::transform_clip(v58, *(void *)(v7 + 24), v80);
          *(void *)(v57 + 40) = RB::DisplayList::CachedTransform::transform_metadata(v58, *(const RB::DisplayList::Metadata **)(v7 + 40), *(_DWORD *)(v7 + 48));
          *(_DWORD *)(v57 + 48) = v60;
          *(_DWORD *)(v57 + 52) = *(_DWORD *)(v7 + 52) & 1;
          (*(void (**)(uint64_t, RB::DisplayList::CachedTransform *, BOOL))(*(void *)v57 + 32))(v57, v58, v59);
          float64x2_t v61 = __dst;
          uint64_t v62 = *((void *)__dst + 17);
          size_t v63 = v62 + 1;
          if (*((void *)__dst + 18) < (unint64_t)(v62 + 1))
          {
            _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(__dst, v63);
            uint64_t v62 = v61[17];
            size_t v63 = v62 + 1;
          }
          float64x2_t v64 = (void *)v61[16];
          if (!v64) {
            float64x2_t v64 = v61;
          }
          v64[v62] = v57;
          v61[17] = v63;
        }
        while (1)
        {
          uint64_t v7 = *(void *)(v7 + 32);
          if (!v7 || (*(unsigned char *)(v7 + 52) & 1) == 0) {
            break;
          }
          uint64_t v65 = (*(uint64_t (**)(uint64_t, void))(*(void *)v7 + 24))(v7, *(void *)this);
          RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_0::operator()((float64x2_t **)&v79, v65, v7);
        }
      }
      else
      {
        uint64_t v7 = 0;
      }
      if (v13)
      {
        long long v66 = *((_OWORD *)a2 + 1);
        long long v76 = *(_OWORD *)a2;
        long long v77 = v66;
        *(void *)&long long v78 = *((void *)a2 + 4);
        *(float *)&long long v77 = 1.0 - *(float *)&v66;
        BYTE12(v77) = BYTE12(v66) ^ 1;
        uint64_t v67 = (*(uint64_t (**)(uint64_t, long long *, void, RB::DisplayList::CachedTransform *))(*(void *)a4 + 88))(a4, &v76, 0, this);
        if (v67)
        {
          float32x2_t v68 = v79;
          *(void *)(v67 + 16) = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)v79, *(const RB::AffineTransform **)(a4 + 16));
          BOOL v69 = v80;
          *(void *)(v67 + 24) = RB::DisplayList::CachedTransform::transform_clip(v68, *(void *)(a4 + 24), v80);
          *(void *)(v67 + 40) = RB::DisplayList::CachedTransform::transform_metadata(v68, *(const RB::DisplayList::Metadata **)(a4 + 40), *(_DWORD *)(a4 + 48));
          *(_DWORD *)(v67 + 48) = v70;
          *(_DWORD *)(v67 + 52) = *(_DWORD *)(a4 + 52) & 1;
          (*(void (**)(uint64_t, RB::DisplayList::CachedTransform *, BOOL))(*(void *)v67 + 32))(v67, v68, v69);
          uint64_t v71 = __dst;
          uint64_t v72 = *((void *)__dst + 17);
          size_t v73 = v72 + 1;
          if (*((void *)__dst + 18) < (unint64_t)(v72 + 1))
          {
            _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(__dst, v73);
            uint64_t v72 = v71[17];
            size_t v73 = v72 + 1;
          }
          CGRect v74 = (void *)v71[16];
          if (!v74) {
            CGRect v74 = v71;
          }
          v74[v72] = v67;
          v71[17] = v73;
        }
        while (1)
        {
          a4 = *(void *)(a4 + 32);
          if (!a4 || (*(unsigned char *)(a4 + 52) & 1) == 0) {
            break;
          }
          uint64_t v75 = (*(uint64_t (**)(uint64_t, void))(*(void *)a4 + 24))(a4, *(void *)this);
          RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_0::operator()((float64x2_t **)&v79, v75, a4);
        }
      }
      else
      {
        a4 = 0;
      }
      BOOL v12 = v7 != 0;
      BOOL v13 = a4 != 0;
    }
    while (v7 | a4);
    goto LABEL_9;
  }
  while (1)
  {
    if (v7 == a4
      || (uint64_t v23 = v7, RB::same_identity<RB::DisplayList::Style>(v7, a4))
      && (uint64_t v23 = v7, RB::same_type<RB::DisplayList::Style>(v7, a4)))
    {
      uint64_t v25 = (*(uint64_t (**)(uint64_t, const RB::DisplayList::Interpolator::State *, uint64_t, RB::DisplayList::CachedTransform *))(*(void *)v7 + 88))(v7, a2, a4, this);
      if (v25)
      {
        RB::mix(*(CGAffineTransform **)(v7 + 16), *(float64x2_t **)(a4 + 16), v24, *((float *)a2 + 4));
        long long v76 = v26;
        long long v77 = v27;
        long long v78 = v28;
        *(void *)(v25 + 16) = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)this, (const RB::AffineTransform *)&v76);
        *(void *)(v25 + 24) = RB::DisplayList::CachedTransform::mix_clip((const RB::DisplayList::ClipNode **)this, a2, *(const RB::DisplayList::ClipNode **)(v7 + 24), *(const RB::DisplayList::ClipNode **)(a4 + 24), a5);
        *(void *)(v25 + 40) = RB::DisplayList::CachedTransform::transform_metadata(this, *(const RB::DisplayList::Metadata **)(a4 + 40), *(_DWORD *)(a4 + 48));
        *(_DWORD *)(v25 + 48) = v29;
        *(_DWORD *)(v25 + 52) = (*(_DWORD *)(a4 + 52) | *(_DWORD *)(v7 + 52)) & 1;
        size_t v30 = v84;
        size_t v31 = v84 + 1;
        if (v85 < v84 + 1)
        {
          _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(v82, v31);
          size_t v30 = v84;
          size_t v31 = v84 + 1;
        }
        float32x4_t v32 = v83;
        if (!v83) {
          float32x4_t v32 = v82;
        }
        *(void *)&v32[8 * v30] = v25;
        size_t v84 = v31;
      }
      while (1)
      {
        uint64_t v7 = *(void *)(v7 + 32);
        if (!v7 || (*(unsigned char *)(v7 + 52) & 1) == 0) {
          break;
        }
        uint64_t v33 = (*(uint64_t (**)(uint64_t, void))(*(void *)v7 + 24))(v7, *(void *)this);
        RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_0::operator()((float64x2_t **)&v79, v33, v7);
      }
      while (1)
      {
        a4 = *(void *)(a4 + 32);
        if (!a4) {
          goto LABEL_8;
        }
        if ((*(unsigned char *)(a4 + 52) & 1) == 0) {
          goto LABEL_36;
        }
        uint64_t v34 = (*(uint64_t (**)(uint64_t, void))(*(void *)a4 + 24))(a4, *(void *)this);
        RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_0::operator()((float64x2_t **)&v79, v34, a4);
      }
    }
LABEL_38:
    if (RB::same_identity<RB::DisplayList::Style>(v23, a4) && RB::same_type<RB::DisplayList::Style>(v23, a4))
    {
      if (v7 != v23)
      {
        do
        {
          uint64_t v38 = (*(uint64_t (**)(uint64_t, const RB::DisplayList::Interpolator::State *, void, RB::DisplayList::CachedTransform *))(*(void *)v7 + 88))(v7, a2, 0, this);
          if (v38)
          {
            float32x2_t v39 = v79;
            *(void *)(v38 + 16) = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)v79, *(const RB::AffineTransform **)(v7 + 16));
            BOOL v40 = v80;
            *(void *)(v38 + 24) = RB::DisplayList::CachedTransform::transform_clip(v39, *(void *)(v7 + 24), v80);
            *(void *)(v38 + 40) = RB::DisplayList::CachedTransform::transform_metadata(v39, *(const RB::DisplayList::Metadata **)(v7 + 40), *(_DWORD *)(v7 + 48));
            *(_DWORD *)(v38 + 48) = v41;
            *(_DWORD *)(v38 + 52) = *(_DWORD *)(v7 + 52) & 1;
            (*(void (**)(uint64_t, RB::DisplayList::CachedTransform *, BOOL))(*(void *)v38 + 32))(v38, v39, v40);
            int32x2_t v42 = __dst;
            uint64_t v43 = *((void *)__dst + 17);
            size_t v44 = v43 + 1;
            if (*((void *)__dst + 18) < (unint64_t)(v43 + 1))
            {
              _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(__dst, v44);
              uint64_t v43 = v42[17];
              size_t v44 = v43 + 1;
            }
            int32x2_t v45 = (void *)v42[16];
            if (!v45) {
              int32x2_t v45 = v42;
            }
            v45[v43] = v38;
            v42[17] = v44;
          }
          while (1)
          {
            uint64_t v7 = *(void *)(v7 + 32);
            if (!v7 || (*(unsigned char *)(v7 + 52) & 1) == 0) {
              break;
            }
            uint64_t v46 = (*(uint64_t (**)(uint64_t, void))(*(void *)v7 + 24))(v7, *(void *)this);
            RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_0::operator()((float64x2_t **)&v79, v46, v7);
          }
        }
        while (v7 != v23);
        uint64_t v7 = v23;
      }
      goto LABEL_36;
    }
    while (1)
    {
      uint64_t v23 = *(void *)(v23 + 32);
      if (!v23) {
        break;
      }
      if ((*(unsigned char *)(v23 + 52) & 1) == 0) {
        goto LABEL_38;
      }
      uint64_t v35 = (*(uint64_t (**)(uint64_t, void))(*(void *)v23 + 24))(v23, *(void *)this);
      RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_0::operator()((float64x2_t **)&v79, v35, v23);
    }
    float32x2_t v36 = (const RB::DisplayList::Style *)a4;
LABEL_44:
    if (!RB::same_identity<RB::DisplayList::Style>((uint64_t)v36, v7)
      || !RB::same_type<RB::DisplayList::Style>((uint64_t)v36, v7))
    {
      break;
    }
    long long v47 = *((_OWORD *)a2 + 1);
    long long v76 = *(_OWORD *)a2;
    long long v77 = v47;
    *(void *)&long long v78 = *((void *)a2 + 4);
    *(float *)&long long v77 = 1.0 - *(float *)&v47;
    BYTE12(v77) = BYTE12(v47) ^ 1;
    if ((const RB::DisplayList::Style *)a4 != v36)
    {
      do
      {
        uint64_t v48 = (*(uint64_t (**)(uint64_t, long long *, void, RB::DisplayList::CachedTransform *))(*(void *)a4 + 88))(a4, &v76, 0, this);
        if (v48)
        {
          float v49 = v79;
          *(void *)(v48 + 16) = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)v79, *(const RB::AffineTransform **)(a4 + 16));
          BOOL v50 = v80;
          *(void *)(v48 + 24) = RB::DisplayList::CachedTransform::transform_clip(v49, *(void *)(a4 + 24), v80);
          *(void *)(v48 + 40) = RB::DisplayList::CachedTransform::transform_metadata(v49, *(const RB::DisplayList::Metadata **)(a4 + 40), *(_DWORD *)(a4 + 48));
          *(_DWORD *)(v48 + 48) = v51;
          *(_DWORD *)(v48 + 52) = *(_DWORD *)(a4 + 52) & 1;
          (*(void (**)(uint64_t, RB::DisplayList::CachedTransform *, BOOL))(*(void *)v48 + 32))(v48, v49, v50);
          __int16 v52 = __dst;
          uint64_t v53 = *((void *)__dst + 17);
          size_t v54 = v53 + 1;
          if (*((void *)__dst + 18) < (unint64_t)(v53 + 1))
          {
            _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(__dst, v54);
            uint64_t v53 = v52[17];
            size_t v54 = v53 + 1;
          }
          unsigned __int16 v55 = (void *)v52[16];
          if (!v55) {
            unsigned __int16 v55 = v52;
          }
          v55[v53] = v48;
          v52[17] = v54;
        }
        while (1)
        {
          a4 = *(void *)(a4 + 32);
          if (!a4 || (*(unsigned char *)(a4 + 52) & 1) == 0) {
            break;
          }
          uint64_t v56 = (*(uint64_t (**)(uint64_t, void))(*(void *)a4 + 24))(a4, *(void *)this);
          RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_0::operator()((float64x2_t **)&v79, v56, a4);
        }
      }
      while ((const RB::DisplayList::Style *)a4 != v36);
      a4 = (uint64_t)v36;
    }
LABEL_36:
    if (!v7) {
      goto LABEL_8;
    }
  }
  while (1)
  {
    float32x2_t v36 = (const RB::DisplayList::Style *)*((void *)v36 + 4);
    if (!v36) {
      break;
    }
    if ((*((unsigned char *)v36 + 52) & 1) == 0) {
      goto LABEL_44;
    }
    uint64_t v37 = (*(uint64_t (**)(const RB::DisplayList::Style *, void))(*(void *)v36 + 24))(v36, *(void *)this);
    RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_0::operator()((float64x2_t **)&v79, v37, (uint64_t)v36);
  }
LABEL_8:
  BOOL v12 = v7 != 0;
  BOOL v13 = a4 != 0;
  if (v7 | a4) {
    goto LABEL_74;
  }
LABEL_9:
  if (a5) {
    uint64_t v14 = *((void *)this + 135);
  }
  else {
    uint64_t v14 = 0;
  }
  BOOL v15 = v83;
  size_t v16 = v84;
  if (v84)
  {
    uint64_t v17 = *(void *)(*(void *)this + 8);
    unsigned int v18 = v82;
    if (v83) {
      unsigned int v18 = v83;
    }
    uint64_t v19 = *(void *)(v17 + 312);
    uint64_t v20 = v18 - 8;
    do
    {
      uint64_t v21 = *(void *)&v20[8 * v16];
      *(void *)(v21 + 8) = v19;
      *(void *)(v17 + 312) = v21;
      *(void *)(*(void *)&v20[8 * v16] + 32) = v14;
      uint64_t v14 = *(void *)&v20[8 * v16];
      uint64_t v19 = v21;
      --v16;
    }
    while (v16);
  }
  if (v15) {
    free(v15);
  }
  return v14;
}

void sub_2141C2058(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34)
{
  if (a34) {
    free(a34);
  }
  _Unwind_Resume(exception_object);
}

float64x2_t **RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_0::operator()(float64x2_t **result, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    int v5 = result;
    uint64_t v6 = *result;
    *(void *)(a2 + 16) = RB::DisplayList::CachedTransform::transform_ctm(*result, *(const RB::AffineTransform **)(a3 + 16));
    *(void *)(a2 + 24) = RB::DisplayList::CachedTransform::transform_clip((RB::DisplayList::CachedTransform *)v6, *(void *)(a3 + 24), *((unsigned __int8 *)v5 + 8));
    *(void *)(a2 + 40) = RB::DisplayList::CachedTransform::transform_metadata((RB::DisplayList::CachedTransform *)v6, *(const RB::DisplayList::Metadata **)(a3 + 40), *(_DWORD *)(a3 + 48));
    *(_DWORD *)(a2 + 48) = v7;
    *(_DWORD *)(a2 + 52) = *(_DWORD *)(a3 + 52) & 1;
    uint64_t result = (float64x2_t **)(*(uint64_t (**)(uint64_t, float64x2_t *, void))(*(void *)a2 + 32))(a2, v6, *((unsigned __int8 *)v5 + 8));
    uint64_t v8 = v5[2];
    float64_t v9 = v8[8].f64[1];
    size_t v10 = *(void *)&v9 + 1;
    if (*(void *)&v8[9].f64[0] < (unint64_t)(*(void *)&v9 + 1))
    {
      uint64_t result = (float64x2_t **)_ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(v8, v10);
      float64_t v9 = v8[8].f64[1];
      size_t v10 = *(void *)&v9 + 1;
    }
    float64_t v11 = v8[8].f64[0];
    if (v11 == 0.0) {
      float64_t v11 = *(double *)&v8;
    }
    *(void *)(*(void *)&v11 + 8 * *(void *)&v9) = a2;
    *(void *)&v8[8].f64[1] = v10;
  }
  return result;
}

RB::DisplayList::Item *RB::DisplayList::Builder::ensure_layer(RB::DisplayList::Builder *this, RB::DisplayList::Item *a2, float a3, int a4)
{
  float v5 = a3;
  uint64_t v6 = a2;
  v39[14] = *MEMORY[0x263EF8340];
  unsigned int v8 = (2 * a4) & 0x20 | a4;
  if (a3 == 0.0)
  {
    float v10 = a3;
  }
  else
  {
    (*(void (**)(RB::DisplayList::Item *))(*(void *)a2 + 152))(a2);
    if (a4)
    {
      unsigned int v11 = 0;
      do
      {
        float v10 = v5;
        float v5 = v5 + v5;
      }
      while (v5 <= v9 && v11++ < 3);
    }
    else if (v9 <= v5)
    {
      float v10 = v5;
    }
    else
    {
      float v10 = v9;
    }
  }
  if ((*((_WORD *)v6 + 23) & 0x200) == 0) {
    goto LABEL_14;
  }
  uint64_t v14 = *((void *)v6 + 6);
  if ((a4 & 0x84) == 0 && *((void *)v6 + 3)
    || *(unsigned char *)(v14 + 64) && (*(unsigned char *)(v14 + 64) != 1 || (a4 & 2) == 0)
    || (int v15 = *(_DWORD *)(v14 + 60), (v15 & 6) != 0)
    || ((a4 | (v8 >> 2)) & 8) == 0 && (v15 & 8) != 0)
  {
LABEL_23:
    if ((*(_WORD *)(v14 + 60) & 0x2001) != 0 || (*((_WORD *)v6 + 23) & 0x400) != 0)
    {
      int v13 = *(unsigned __int8 *)(v14 + 67) + 1;
LABEL_26:
      uint64_t v16 = 0;
      uint64_t v17 = *((void *)v6 + 2);
      *((void *)v6 + 2) = 0;
      if ((a4 & 4) != 0)
      {
        uint64_t v16 = *((void *)v6 + 3);
        *((void *)v6 + 3) = 0;
      }
      int v36 = 0;
      unsigned int v18 = (size_t *)(*((void *)this + 1) + 16);
      ++*((_DWORD *)this + 1);
      uint64_t v19 = RB::Heap::emplace<RB::DisplayList::Layer,unsigned int,int>(v18, (int *)this + 1, &v36);
      size_t v31 = (RB::DisplayList::Layer *)v19;
      if (a4)
      {
        *(_DWORD *)(v19 + 60) |= 0x200u;
        if ((a4 & 0x40) == 0)
        {
LABEL_30:
          if (v13)
          {
LABEL_31:
            *(_DWORD *)(v19 + 60) |= 0x2000u;
            *(unsigned char *)(v19 + 67) = v13 - 1;
            int v20 = 1;
            goto LABEL_37;
          }
LABEL_34:
          if (v10 == 0.0 || v10 == 1.0) {
            goto LABEL_38;
          }
          int v20 = 0;
LABEL_37:
          *(float *)(v19 + 48) = v10;
          *(void *)&long long v21 = 0;
          *((double *)&v21 + 1) = v10;
          long long v32 = COERCE_UNSIGNED_INT64(v10);
          long long v33 = v21;
          uint64_t v34 = 0;
          uint64_t v35 = 0;
          RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v36, (uint64_t)this, &v32, 0, 0, v20);
          (*(void (**)(RB::DisplayList::Item *, int *, void))(*(void *)v6 + 32))(v6, &v36, 0);
          RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v39);
          RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v38);
          RB::Heap::~Heap((RB::Heap *)&v37);
LABEL_38:
          double v22 = (size_t *)(*((void *)this + 1) + 16);
          int v36 = *((_WORD *)v6 + 23) & 0x3F;
          _ZN2RB4Heap7emplaceINS_11DisplayList9LayerItemEJRDF16_RKNS_9BlendModeERPNS2_5LayerEEEEPT_DpOT0_(v22, (__int16 *)v6 + 22, &v36, (uint64_t *)&v31);
          uint64_t v24 = v23;
          *(void *)(v23 + 32) = *((void *)v6 + 4);
          *(_DWORD *)(v23 + 40) = *((_DWORD *)v6 + 10);
          *(void *)(v23 + 16) = v17;
          if ((a4 & 4) != 0) {
            *(void *)(v23 + 24) = v16;
          }
          if ((v8 & 0x20) != 0) {
            RB::DisplayList::Layer::discard_color((uint64_t)v31);
          }
          uint64_t v25 = v31;
          if ((a4 & 0x100) != 0) {
            *((unsigned char *)v31 + 65) = 4;
          }
          *((_WORD *)v6 + 22) = COERCE_UNSIGNED_INT(1.0);
          *((_WORD *)v6 + 23) = *((_WORD *)v6 + 23) & 0xFFC0 | 2;
          *((void *)v6 + 4) = 0;
          *((_DWORD *)v6 + 10) = 0;
          RB::DisplayList::Layer::append(v25, this, v6);
          return (RB::DisplayList::Item *)v24;
        }
      }
      else if ((a4 & 0x40) == 0)
      {
        goto LABEL_30;
      }
      *(_DWORD *)(v19 + 60) |= 0x40u;
      if (v13) {
        goto LABEL_31;
      }
      goto LABEL_34;
    }
LABEL_14:
    int v13 = 0;
    goto LABEL_26;
  }
  if (v10 != 0.0)
  {
    float v27 = *(float *)(v14 + 48);
    if (v27 == 0.0) {
      float v27 = 1.0;
    }
    if (v10 != v27)
    {
      float v28 = fminf(v10 / v27, 1.0);
      *(void *)&long long v29 = 0;
      *((double *)&v29 + 1) = v28;
      long long v32 = COERCE_UNSIGNED_INT64(v28);
      long long v33 = v29;
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v36, (uint64_t)this, &v32, 0, 0, 0);
      RB::DisplayList::Layer::apply_transform_((RB::DisplayList::Layer *)v14, (const RB::DisplayList::CachedTransform *)&v36);
      RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)&v36);
      float v30 = *(float *)(v14 + 48);
      if (v30 == 0.0) {
        float v30 = 1.0;
      }
      *(float *)(v14 + 48) = v30 * v28;
    }
  }
  if (a4)
  {
    *(_DWORD *)(v14 + 60) |= 0x200u;
    if ((a4 & 0x40) == 0)
    {
LABEL_55:
      if ((v8 & 0x20) == 0) {
        goto LABEL_60;
      }
      goto LABEL_59;
    }
  }
  else if ((a4 & 0x40) == 0)
  {
    goto LABEL_55;
  }
  *(_DWORD *)(v14 + 60) |= 0x40u;
  if ((v8 & 0x20) != 0) {
LABEL_59:
  }
    RB::DisplayList::Layer::discard_color(v14);
LABEL_60:
  if ((a4 & 0x10) != 0 && (*(unsigned char *)(v14 + 60) & 8) == 0) {
    goto LABEL_23;
  }
  if ((a4 & 0x100) != 0) {
    *(unsigned char *)(v14 + 65) = 4;
  }
  return v6;
}

void sub_2141C25B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

RB::DisplayList::Item *RB::DisplayList::Builder::apply_filter_(RB::DisplayList::Builder *this, RB::DisplayList::Item *a2, RB::DisplayList::LayerFilter *a3, float64x2_t *a4, const RB::DisplayList::ClipNode *a5)
{
  v35[14] = *MEMORY[0x263EF8340];
  int v10 = (*(uint64_t (**)(RB::DisplayList::LayerFilter *))(*(void *)a3 + 40))(a3);
  uint64_t v12 = v11;
  if ((*(unsigned int (**)(RB::DisplayList::LayerFilter *))(*(void *)a3 + 64))(a3)) {
    unsigned int v13 = 128;
  }
  else {
    unsigned int v13 = 0;
  }
  if (v10 == 6)
  {
    float v14 = *(float *)(v12 + 4);
    unsigned int v13 = v13 & 0xFFFFFEFF | ((*(_DWORD *)(v12 + 8) & 1) << 8);
  }
  else if (v10 == 5)
  {
    if (!*(void *)(v12 + 32))
    {
      int v16 = *(_DWORD *)(v12 + 24);
      if ((v16 & 7) == 0)
      {
        if ((*(uint64_t (**)(RB::DisplayList::Item *, float64x2_t *, float))(*(void *)a2 + 112))(a2, a4, *(float *)v12))
        {
LABEL_28:
          *((void *)a2 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)this, *((void **)a2 + 3), a5);
          return a2;
        }
        int v16 = *(_DWORD *)(v12 + 24);
      }
      v13 |= (8 * v16) & 0x40 | 1;
    }
    v13 |= 8u;
    float v17 = RB::AffineTransform::scale(a4);
    float v14 = RB::Filter::GaussianBlur::layer_scale((RB::Filter::GaussianBlur *)v12, v17);
  }
  else
  {
    float v14 = 0.0;
    if (v10 == 1)
    {
      if (RB::ColorMatrix::is_alpha_zero((RB::ColorMatrix *)(v12 + 8))
        && RB::may_discard_alpha(*((_WORD *)a2 + 23) & 0x3F))
      {
        (**(void (***)(RB::DisplayList::Item *))a2)(a2);
        return 0;
      }
      __asm { FCMP            H0, #0 }
      if (_ZF)
      {
        uint64_t v22 = (*(_DWORD *)v12 & 1) != 0 ? 256 : ((*(_DWORD *)v12 & 2) << 7) | (*(_DWORD *)v12 >> 1) & 1u;
        if ((*(unsigned int (**)(RB::DisplayList::Item *, uint64_t, void, uint64_t, __n128))(*(void *)a2 + 96))(a2, v12 + 8, (*(_DWORD *)v12 >> 2) & 1, v22, _Q0)&& RB::may_discard_alpha(*((_WORD *)a2 + 23) & 0x3F))
        {
          if (*(_DWORD *)v12) {
            uint64_t v23 = 256;
          }
          else {
            uint64_t v23 = ((*(_DWORD *)v12 & 2) << 7) | (*(_DWORD *)v12 >> 1) & 1u;
          }
          (*(void (**)(RB::DisplayList::Item *, uint64_t, void, uint64_t, RB::DisplayList::Builder *))(*(void *)a2 + 104))(a2, v12 + 8, (*(_DWORD *)v12 >> 2) & 1, v23, this);
          goto LABEL_28;
        }
      }
    }
  }
  a2 = RB::DisplayList::Builder::ensure_layer(this, a2, v14, v13);
  *((void *)a2 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)this, *((void **)a2 + 3), a5);
  uint64_t v24 = *((void *)a2 + 6);
  float v25 = *(float *)(v24 + 48);
  if (v25 == 0.0) {
    float v25 = 1.0;
  }
  double v26 = v25;
  float64x2_t v27 = vmulq_n_f64(*a4, v26);
  float64x2_t v28 = vmulq_n_f64(a4[1], v26);
  float64x2_t v29 = vmulq_n_f64(a4[2], v26);
  v31[0] = (__int128)v27;
  v31[1] = (__int128)v28;
  Point v31[2] = (__int128)v29;
  RB::DisplayList::CachedTransform::CachedTransform((uint64_t)v32, (uint64_t)this, v31, 0, 0, 0);
  (*(void (**)(RB::DisplayList::LayerFilter *, unsigned char *))(*(void *)a3 + 24))(a3, v32);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v35);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v34);
  RB::Heap::~Heap((RB::Heap *)&v33);
  RB::DisplayList::Layer::append_filter(v24, (uint64_t)a3);
  return a2;
}

void sub_2141C2964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

RB::DisplayList::Item *RB::DisplayList::Builder::apply_color_matrix(RB::DisplayList::Builder *this, RB::DisplayList::Item *a2, const RB::ColorMatrix *a3, int a4, float64x2_t *a5, const RB::DisplayList::ClipNode *a6)
{
  if ((RB::ColorMatrix::is_identity((float16x4_t *)a3) & 1) == 0)
  {
    int v15 = a4;
    long long v12 = *((_OWORD *)a3 + 1);
    long long v16 = *(_OWORD *)a3;
    long long v17 = v12;
    uint64_t v18 = *((void *)a3 + 4);
    RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix const&,RB::DisplayList::Builder &>((RB::Heap *)(*((void *)this + 1) + 16), (uint64_t)&v15);
    return RB::DisplayList::Builder::apply_filter_(this, a2, v13, a5, a6);
  }
  return a2;
}

void RB::XML::Document::~Document(RB::XML::Document *this)
{
  RB::UntypedTable::~UntypedTable((RB::XML::Document *)((char *)this + 32));
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2) {
    free(v2);
  }
  BOOL v3 = *(_DWORD **)this;
  if (*(void *)this)
  {
    int v4 = v3[2] - 1;
    v3[2] = v4;
    if (!v4) {
      (*(void (**)(_DWORD *))(*(void *)v3 + 8))(v3);
    }
  }
}

void RB::DisplayList::Builder::draw_interpolated(RB::DisplayList::Layer ***this, RB::DisplayList::State *a2, const RB::DisplayList::Interpolator::Layer *a3, float32_t a4, float a5, const RB::DisplayList::Contents *a6, const RB::DisplayList::Contents *a7, const RB::AffineTransform *a8)
{
  v29[14] = *MEMORY[0x263EF8340];
  if (!this[1]) {
    RB::DisplayList::Builder::reset_contents((RB::DisplayList::Builder *)this);
  }
  long long v16 = this[4];
  if (!v16 || *((_DWORD *)*v16 + 14) != *((_DWORD *)a2 + 36)) {
    RB::precondition_failure((RB *)"current layer doesn't match drawing state", (const char *)a2);
  }
  RB::DisplayList::CachedTransform::CachedTransform((uint64_t)v27, (uint64_t)this, (long long *)a2 + 1, *((void *)a2 + 12), *((void *)a2 + 13), 0);
  unsigned int v19 = *(_DWORD *)(*(void *)a3 + 16);
  int v20 = *this[4];
  if (!*((unsigned char *)this + 272))
  {
    uint64_t v23 = 0;
    if (a6) {
      goto LABEL_9;
    }
LABEL_12:
    uint64_t v24 = 0;
    if (a7) {
      goto LABEL_10;
    }
LABEL_13:
    float v25 = 0;
    goto LABEL_14;
  }
  uint64_t v21 = RB::DisplayList::Builder::crop_bounds((RB::DisplayList::Builder *)this, a2);
  float32x2_t v18 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
  uint32x2_t v22 = (uint32x2_t)vcge_f32((float32x2_t)(*(void *)(v21 + 8) & 0x7FFFFFFF7FFFFFFFLL), v18);
  double v17 = COERCE_DOUBLE(vpmax_u32(v22, v22));
  if (SLODWORD(v17) >= 0) {
    uint64_t v23 = (float32x2_t *)v21;
  }
  else {
    uint64_t v23 = 0;
  }
  if (!a6) {
    goto LABEL_12;
  }
LABEL_9:
  uint64_t v24 = (const RB::Rect *)*((void *)a6 + 40);
  if (!a7) {
    goto LABEL_13;
  }
LABEL_10:
  float v25 = (const RB::DisplayList::Item *)*((void *)a7 + 40);
LABEL_14:
  *(float *)&double v17 = a5;
  v18.f32[0] = a4;
  RB::DisplayList::apply_interpolator(a3, 0, v17, v19, v20, v27, *(double *)&v18, v23, v24, v25, a8, v26);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v29);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v28);
  RB::Heap::~Heap((RB::Heap *)&v27[0].f64[1]);
}

void sub_2141C2C34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

RB::DisplayList::Builder *RB::DisplayList::Builder::draw_custom(uint64_t a1, void *a2, int a3, _OWORD *a4, __n128 *this, int a6, float a7)
{
  unsigned int v19 = a2;
  int v18 = a3;
  float v17 = a7;
  int v16 = a6;
  int v10 = (RB::Heap *)(*(void *)(a1 + 8) + 16);
  RB::DisplayList::State::copy_ctm(this, v10);
  uint64_t v15 = v11;
  long long v12 = (int8x16_t *)RB::Heap::emplace<RB::DisplayList::CustomItem,void({block_pointer}&)(RBMetalRenderState *),unsigned int &,RB::AffineTransform const*,RB::Rect const&,float &,RB::BlendMode &>(v10, &v19, &v18, &v15, a4, &v17, &v16);
  char v13 = v18;
  if (v18)
  {
    if ((v18 & 2) != 0) {
      goto LABEL_3;
    }
  }
  else
  {
    v12[2].i16[7] |= 0x40u;
    if ((v13 & 2) != 0)
    {
LABEL_3:
      if ((v13 & 4) != 0) {
        goto LABEL_4;
      }
LABEL_9:
      v12[2].i16[7] |= 0x100u;
      if ((v13 & 8) == 0) {
        return RB::DisplayList::Builder::draw((RB::DisplayList::Contents **)a1, v12, (int8x16_t *)this);
      }
      goto LABEL_5;
    }
  }
  v12[2].i16[7] |= 0x80u;
  if ((v13 & 4) == 0) {
    goto LABEL_9;
  }
LABEL_4:
  if ((v13 & 8) != 0) {
LABEL_5:
  }
    v12[2].i16[7] |= 0x100u;
  return RB::DisplayList::Builder::draw((RB::DisplayList::Contents **)a1, v12, (int8x16_t *)this);
}

uint64_t RB::Heap::emplace<RB::DisplayList::CustomItem,void({block_pointer}&)(RBMetalRenderState *),unsigned int &,RB::AffineTransform const*,RB::Rect const&,float &,RB::BlendMode &>(RB::Heap *this, void **a2, int *a3, uint64_t *a4, _OWORD *a5, float *a6, int *a7)
{
  unint64_t v14 = *((void *)this + 3);
  uint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 88 > v14) {
    uint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0x58uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 88;
  }
  int v16 = *a2;
  int v17 = *a3;
  uint64_t v18 = *a4;
  float v19 = *a6;
  int v20 = *a7;
  return RB::DisplayList::CustomItem::CustomItem(v15, v16, v17, v18, a5, v20, v19);
}

const RB::DisplayList::ClipNode *RB::DisplayList::Builder::MemoizedAddClip::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v5 = *(void **)(a3 + 24);
  if (*(void **)(a1 + 8) == v5)
  {
    uint64_t result = *(const RB::DisplayList::ClipNode **)(a1 + 16);
  }
  else
  {
    *(void *)(a1 + 8) = v5;
    uint64_t result = RB::DisplayList::Builder::join_clip_lists(a2, v5, *(const RB::DisplayList::ClipNode **)a1);
    *(void *)(a1 + 16) = result;
  }
  *(void *)(a3 + 24) = result;
  return result;
}

double _ZN2RB4Heap7emplaceINS_11DisplayList23BackdropColorMatrixItemEJRPKNS_6Filter11ColorMatrixERDF16_NS_9BlendModeEEEEPT_DpOT0_(size_t *a1, uint64_t *a2, __int16 *a3, int *a4)
{
  uint64_t v7 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v7 + 56 > a1[3]) {
    uint64_t v7 = RB::Heap::alloc_slow(a1, 0x38uLL, 7);
  }
  else {
    a1[2] = v7 + 56;
  }
  uint64_t v8 = *a2;
  _H0 = *a3;
  __asm { FCVT            S0, H0 }
  int v15 = *a4;
  *(void *)&double result = RB::DisplayList::BackdropColorMatrixItem::BackdropColorMatrixItem(v7, v8, v15, _S0);
  return result;
}

BOOL RB::DisplayList::Builder::can_lower_color_matrix(uint64_t *a1, uint64_t a2, uint64_t a3, unsigned __int16 a4, int a5)
{
  _Q0 = *(__n128 *)a2;
  long long v9 = *(_OWORD *)(a2 + 16);
  v19[0] = *(_OWORD *)a2;
  v19[1] = v9;
  float16x4_t v20 = *(float16x4_t *)(a2 + 32);
  uint64_t v10 = *a1;
  if (*a1)
  {
    BOOL v11 = *(void *)(v10 + 8) == 0;
    if (!*(void *)(v10 + 8)) {
      goto LABEL_7;
    }
  }
  else
  {
    BOOL v11 = 0;
  }
  if (a5) {
    _Q0.n128_f32[0] = RB::ColorMatrix::remove_alpha_factor((float16x4_t *)v19, a3);
  }
LABEL_7:
  __asm { FCMP            H0, #0 }
  if (!_ZF) {
    return 0;
  }
  if (v11)
  {
LABEL_14:
    uint64_t v16 = *a1;
    if (!v16) {
      return 1;
    }
    while (1)
    {
      unsigned int v17 = *(_WORD *)(v16 + 46) & 0x3F;
      _ZF = v17 < 0xB || v17 == 24;
      if (!_ZF
        || ((*(uint64_t (**)(uint64_t, _OWORD *, uint64_t, void, __n128))(*(void *)v16 + 96))(v16, v19, a3, a4, _Q0) & 1) == 0)
      {
        break;
      }
      uint64_t v16 = *(void *)(v16 + 8);
      if (!v16) {
        return 1;
      }
    }
    return 0;
  }
  BOOL result = RB::ColorMatrix::is_alpha_identity((RB::ColorMatrix *)v19);
  if (result)
  {
    if (a3)
    {
      _Q0.n128_u64[0] = (unint64_t)vmvn_s8((int8x8_t)vceqz_f16(v20));
      _Q0.n128_u16[0] = vmaxv_u16((uint16x4_t)_Q0.n128_u64[0]);
      if ((_Q0.n128_u16[0] & 0x8000) != 0) {
        return 0;
      }
    }
    goto LABEL_14;
  }
  return result;
}

float RB::DisplayList::Builder::lower_color_matrix(uint64_t a1, void **a2, uint64_t a3, uint64_t a4, unsigned __int16 a5, int a6)
{
  long long v10 = *(_OWORD *)(a3 + 16);
  v14[0] = *(_OWORD *)a3;
  v14[1] = v10;
  uint64_t v15 = *(void *)(a3 + 32);
  BOOL v11 = *a2;
  if (!*a2)
  {
    float v12 = 1.0;
    if (!a6) {
      return v12;
    }
    goto LABEL_6;
  }
  float v12 = 1.0;
  if (v11[1] && (a6 & 1) != 0)
  {
LABEL_6:
    float v12 = RB::ColorMatrix::remove_alpha_factor((float16x4_t *)v14, a4);
    BOOL v11 = *a2;
    if (!*a2) {
      return v12;
    }
    goto LABEL_7;
  }
  do
  {
LABEL_7:
    (*(void (**)(void *, _OWORD *, uint64_t, void, uint64_t))(*v11 + 104))(v11, v14, a4, a5, a1);
    BOOL v11 = (void *)v11[1];
  }
  while (v11);
  return v12;
}

BOOL RB::DisplayList::Builder::merge_layer_item(RB::DisplayList::Layer &,unsigned int)::$_0::operator()(unsigned char *a1, uint64_t a2, uint64_t a3)
{
  if ((!*(unsigned char *)(a3 + 64) || (!*(unsigned char *)(a2 + 64) ? (BOOL v3 = *(void *)(a2 + 16) == 0) : (BOOL v3 = 0), v3))
    && ((int v4 = *(_DWORD *)(a3 + 60) ^ *(_DWORD *)(a2 + 60), (*a1 & 2) != 0) || (v4 & 8) == 0))
  {
    return (v4 & 6 & ((v4 & 6) - 1)) == 0;
  }
  else
  {
    return 0;
  }
}

BOOL RB::same_identity<RB::DisplayList::Style>(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 48);
  if (v2 != *(_DWORD *)(a2 + 48)) {
    return 0;
  }
  BOOL v3 = *(uint64_t **)(a1 + 40);
  int v4 = *(uint64_t **)(a2 + 40);
  if (v2) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v3 == v4;
  }
  if (v5) {
    return 1;
  }
  if (v3)
  {
    uint64_t v6 = RB::DisplayList::Metadata::identity_ns(v3);
    if (v4)
    {
LABEL_8:
      uint64_t v7 = RB::DisplayList::Metadata::identity_ns(v4);
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v6 = 0;
    if (v4) {
      goto LABEL_8;
    }
  }
  uint64_t v7 = 0;
LABEL_12:
  if (v6 == v7) {
    return 1;
  }
  BOOL result = 0;
  if (v6 && v7)
  {
    uint64_t v10 = *v7;
    uint64_t v9 = v7[1];
    return *v6 == v10 && v6[1] == v9;
  }
  return result;
}

BOOL RB::same_type<RB::DisplayList::Style>(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  BOOL result = 0;
  if (a1)
  {
    if (a2)
    {
      int v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      return v5 == (*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2);
    }
  }
  return result;
}

void *RB::Path::BufferedTransform::lineto(void *result, __n128 a2)
{
  int v2 = result;
  BOOL v3 = result + 1;
  uint64_t v4 = result[18];
  size_t v5 = v4 + 1;
  if (result[19] < (unint64_t)(v4 + 1))
  {
    __n128 v10 = a2;
    BOOL result = RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(result + 1, v5);
    a2 = v10;
    uint64_t v4 = v2[18];
    size_t v5 = v4 + 1;
  }
  uint64_t v6 = (void *)v2[17];
  if (!v6) {
    uint64_t v6 = v3;
  }
  *((unsigned char *)v6 + v4) = 1;
  v2[18] = v5;
  unint64_t v7 = v2[533];
  unint64_t v8 = v7 + 2;
  if (v7 <= 0xFFFFFFFFFFFFFFFDLL && v2[534] < v8)
  {
    __n128 v11 = a2;
    BOOL result = RB::vector<double,512ul,unsigned long>::reserve_slow(v2 + 20, v7 + 2);
    a2 = v11;
  }
  v2[533] = v8;
  uint64_t v9 = (void *)v2[532];
  if (!v9) {
    uint64_t v9 = v2 + 20;
  }
  *(__n128 *)&v9[v7] = a2;
  return result;
}

void *RB::Path::BufferedTransform::quadto(void *result, __n128 a2, __n128 a3)
{
  BOOL v3 = result;
  uint64_t v4 = result + 1;
  uint64_t v5 = result[18];
  size_t v6 = v5 + 1;
  if (result[19] < (unint64_t)(v5 + 1))
  {
    __n128 v12 = a2;
    __n128 v14 = a3;
    BOOL result = RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(result + 1, v6);
    a2 = v12;
    a3 = v14;
    uint64_t v5 = v3[18];
    size_t v6 = v5 + 1;
  }
  unint64_t v7 = (void *)v3[17];
  if (!v7) {
    unint64_t v7 = v4;
  }
  *((unsigned char *)v7 + v5) = 2;
  v3[18] = v6;
  unint64_t v8 = v3[533];
  unint64_t v9 = v8 + 4;
  if (v8 <= 0xFFFFFFFFFFFFFFFBLL && v3[534] < v9)
  {
    __n128 v13 = a2;
    __n128 v15 = a3;
    BOOL result = RB::vector<double,512ul,unsigned long>::reserve_slow(v3 + 20, v8 + 4);
    a2 = v13;
    a3 = v15;
  }
  v3[533] = v9;
  __n128 v10 = (void *)v3[532];
  if (!v10) {
    __n128 v10 = v3 + 20;
  }
  __n128 v11 = (__n128 *)&v10[v8];
  *__n128 v11 = a2;
  v11[1] = a3;
  return result;
}

void RB::Path::CGPathTransform::closepath(RB::Path::CGPathTransform *this)
{
  uint64_t v1 = (CGPath *)*((void *)this + 1);
  if (v1) {
    CGPathCloseSubpath(v1);
  }
}

void RB::Path::CGPathTransform::moveto(RB::Path::CGPathTransform *this, __n128 a2)
{
  BOOL v3 = (CGPath *)*((void *)this + 1);
  if (!v3)
  {
    __n128 x = a2;
    RB::Path::CGPathTransform::reset(this);
    a2 = x;
    BOOL v3 = (CGPath *)*((void *)this + 1);
  }
  CGPathMoveToPoint(v3, 0, a2.n128_f64[0], a2.n128_f64[1]);
}

void RB::Path::CGPathTransform::reset(RB::Path::CGPathTransform *this)
{
  CGMutablePathRef Mutable = CGPathCreateMutable();
  BOOL v3 = (const void *)*((void *)this + 1);
  if (v3) {
    CFRelease(v3);
  }
  *((void *)this + 1) = Mutable;
}

void RB::Path::CGPathTransform::lineto(RB::Path::CGPathTransform *this, __n128 a2)
{
  BOOL v3 = (CGPath *)*((void *)this + 1);
  if (!v3)
  {
    __n128 x = a2;
    RB::Path::CGPathTransform::reset(this);
    a2 = x;
    BOOL v3 = (CGPath *)*((void *)this + 1);
  }
  CGPathAddLineToPoint(v3, 0, a2.n128_f64[0], a2.n128_f64[1]);
}

void RB::Path::CGPathTransform::quadto(RB::Path::CGPathTransform *this, __n128 a2, __n128 a3)
{
  __n128 v3 = a3;
  uint64_t v5 = (CGPath *)*((void *)this + 1);
  if (!v5)
  {
    __n128 v6 = a2;
    RB::Path::CGPathTransform::reset(this);
    a2 = v6;
    __n128 v3 = a3;
    uint64_t v5 = (CGPath *)*((void *)this + 1);
  }
  CGPathAddQuadCurveToPoint(v5, 0, a2.n128_f64[0], a2.n128_f64[1], v3.n128_f64[0], v3.n128_f64[1]);
}

void RB::Path::CGPathTransform::cubeto(RB::Path::CGPathTransform *this, __n128 a2, __n128 a3, __n128 a4)
{
  __n128 v5 = a3;
  unint64_t v7 = (CGPath *)*((void *)this + 1);
  if (!v7)
  {
    __n128 x = a4;
    __n128 v8 = a2;
    RB::Path::CGPathTransform::reset(this);
    a2 = v8;
    __n128 v5 = a3;
    a4 = x;
    unint64_t v7 = (CGPath *)*((void *)this + 1);
  }
  CGPathAddCurveToPoint(v7, 0, a2.n128_f64[0], a2.n128_f64[1], v5.n128_f64[0], v5.n128_f64[1], a4.n128_f64[0], a4.n128_f64[1]);
}

uint64_t RB::Path::AffineTransformer::quadto(uint64_t a1, float64x2_t a2, float64x2_t a3)
{
  return (*(uint64_t (**)(void, __n128, __n128))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), (__n128)vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 48), *(float64x2_t *)(a1 + 16), a2.f64[0]), *(float64x2_t *)(a1 + 32), a2, 1), (__n128)vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 48), *(float64x2_t *)(a1 + 16), a3.f64[0]), *(float64x2_t *)(a1 + 32), a3, 1));
}

BOOL RB::Path::Projection::project(uint64_t a1, uint64_t a2, float64x2_t a3)
{
  uint64_t v3 = *(void *)(a1 + 704);
  if (v3)
  {
    unint64_t v7 = (float32x2_t *)(a1 + 56);
    float64x2_t v8 = *(float64x2_t *)(a1 + 32);
    float64x2_t v9 = vsubq_f64(a3, *(float64x2_t *)(a1 + 16));
    float64x2_t v10 = vmulq_f64(v8, v9);
    double v11 = vaddvq_f64(v10) * *(float *)(a1 + 760);
    v10.f64[0] = -v9.f64[1];
    double v12 = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64((int64x2_t)v10, (int64x2_t)v9), v8)) * *(float *)(a1 + 756);
    float64x2_t v50 = a3;
    if (v11 <= 0.0000999999975 || v11 >= 0.999899983)
    {
      __n128 v13 = *(float32x2_t **)(a1 + 696);
      if (v11 < 0.5)
      {
        unsigned int v26 = 0;
        if (v13) {
          unint64_t v7 = *(float32x2_t **)(a1 + 696);
        }
        goto LABEL_22;
      }
    }
    else
    {
      __n128 v13 = *(float32x2_t **)(a1 + 696);
      if (v13) {
        __n128 v14 = *(float32x2_t **)(a1 + 696);
      }
      else {
        __n128 v14 = (float32x2_t *)(a1 + 56);
      }
      double v15 = v11 * *(float *)(a1 + 752);
      uint64_t v16 = v14;
      unint64_t v17 = *(void *)(a1 + 704);
      do
      {
        unint64_t v18 = v17 >> 1;
        float v19 = &v16[5 * (v17 >> 1)];
        double v20 = (float)(v19[4].f32[1] + v19[4].f32[0]);
        uint64_t v21 = v19 + 5;
        v17 += ~(v17 >> 1);
        if (v15 > v20) {
          uint64_t v16 = v21;
        }
        else {
          unint64_t v17 = v18;
        }
      }
      while (v17);
      double v11 = 1.0;
      if (v16 != &v14[5 * v3])
      {
        float v22 = v16[4].f32[1];
        double v23 = v15 - v16[4].f32[0];
        if (v23 < v22)
        {
          if (v23 >= (float)(v22 * 0.5))
          {
            float v42 = v22 - v23;
            float v25 = 1.0 - RB::cubic_index_f<float>(v16[3], v16[2], v16[1], *v16, v42, 0.5);
          }
          else
          {
            float v24 = v23;
            float v25 = RB::cubic_index_f<float>(*v16, v16[1], v16[2], v16[3], v24, 0.5);
          }
          *(float64x2_t *)&v57[0].v = vcvtq_f64_f32(*v16);
          float64x2_t v43 = vcvtq_f64_f32(v16[1]);
          *(float64x2_t *)&v52[0].v = vcvtq_f64_f32(v16[2]);
          *(float64x2_t *)&v53[0].v = v43;
          *(float64x2_t *)&v51[0].v = vcvtq_f64_f32(v16[3]);
          CG::Cubic::Cubic((CG::Cubic *)&v54, v57, v53, v52, v51);
          double v44 = v25;
          double v45 = CG::Cubic::evaluate(&v54, v44);
          double v48 = v46;
          double v49 = v45;
          *(double *)&long long v28 = CG::Cubic::derivative((CG::Cubic *)&v54, v44);
          if (*(double *)&v28 != 0.0 || v29 != 0.0)
          {
            double v47 = sqrt(*(double *)&v28 * *(double *)&v28 + v29 * v29);
            *(double *)&long long v28 = *(double *)&v28 / v47;
            double v29 = v29 / v47;
          }
          *(_OWORD *)a2 = xmmword_2142181C0;
          *(_OWORD *)(a2 + 16) = xmmword_2142181D0;
          *(float64x2_t *)(a2 + 32) = vmlaq_n_f64(vmulq_n_f64((float64x2_t)xmmword_2142181D0, v48), (float64x2_t)xmmword_2142181C0, v49);
LABEL_32:
          *(double *)&long long v37 = -v29;
          *((void *)&v37 + 1) = v28;
          *((double *)&v28 + 1) = v29;
          *(_OWORD *)&v57[0].v = v28;
          long long v58 = v37;
          uint64_t v59 = 0;
          uint64_t v60 = 0;
          v38.f64[0] = RB::operator*((float64x2_t *)v57, (float64x2_t *)a2);
          *(float64x2_t *)a2 = v38;
          *(float64x2_t *)(a2 + 16) = v39;
          *(float64x2_t *)(a2 + 32) = vmlsq_lane_f64(vmlsq_lane_f64(v40, v38, v50.f64[0], 0), v39, v12 + v50.f64[1], 0);
          return v3 != 0;
        }
      }
    }
    if (v13) {
      unint64_t v7 = v13;
    }
    unint64_t v7 = &v7[5 * v3 - 5];
    unsigned int v26 = 1;
LABEL_22:
    *(float64x2_t *)&v57[0].v = vcvtq_f64_f32(*v7);
    float64x2_t v27 = vcvtq_f64_f32(v7[1]);
    *(float64x2_t *)&v52[0].v = vcvtq_f64_f32(v7[2]);
    *(float64x2_t *)&v53[0].v = v27;
    *(float64x2_t *)&v51[0].v = vcvtq_f64_f32(v7[3]);
    CG::Cubic::Cubic((CG::Cubic *)&v54, v57, v53, v52, v51);
    *(double *)&long long v28 = CG::Cubic::derivative((CG::Cubic *)&v54, (double)v26);
    if (*(double *)&v28 != 0.0 || v29 != 0.0)
    {
      double v30 = sqrt(*(double *)&v28 * *(double *)&v28 + v29 * v29);
      *(double *)&long long v28 = *(double *)&v28 / v30;
      double v29 = v29 / v30;
    }
    double v31 = v11 + -1.0;
    if (!v26) {
      double v31 = v11;
    }
    double v32 = v31 * *(float *)(a1 + 752);
    uint64_t v33 = (float64x2_t *)&v55;
    if (!v26) {
      uint64_t v33 = &v54;
    }
    uint64_t v34 = &v54.f64[1];
    if (v26) {
      uint64_t v34 = (double *)&v56;
    }
    double v35 = v33->f64[0] + v32 * *(double *)&v28;
    double v36 = *v34 + v32 * v29;
    *(_OWORD *)a2 = xmmword_2142181C0;
    *(_OWORD *)(a2 + 16) = xmmword_2142181D0;
    *(float64x2_t *)(a2 + 32) = vmlaq_n_f64(vmulq_n_f64((float64x2_t)xmmword_2142181D0, v36), (float64x2_t)xmmword_2142181C0, v35);
    goto LABEL_32;
  }
  return v3 != 0;
}

float RB::cubic_index_f<float>(float32x2_t a1, float32x2_t a2, float32x2_t a3, float32x2_t a4, float a5, float a6)
{
  float v6 = 0.0;
  if (a5 <= 0.0) {
    return v6;
  }
  float32x2_t v9 = vrecpe_f32((float32x2_t)LODWORD(a6));
  float32x2_t v10 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(a6), v9), v9);
  float v11 = vmul_f32(v10, vrecps_f32((float32x2_t)LODWORD(a6), v10)).f32[0];
  float32x2_t v12 = vmaxnm_f32(vabs_f32(vadd_f32(vsub_f32(a1, vadd_f32(a2, a2)), a3)), vabs_f32(vadd_f32(vsub_f32(a2, vadd_f32(a3, a3)), a4)));
  float v13 = ceilf(sqrtf((float)(0.75 * v11) * sqrtf(vaddv_f32(vmul_f32(v12, v12)))));
  if ((v13 < 0.0 || ((LODWORD(v13) & 0x7FFFFFFFu) - 0x800000) >> 24 > 0x7E) && LODWORD(v13) != 0) {
    goto LABEL_13;
  }
  float v6 = 1.0;
  if (v13 >= 1.0)
  {
    if (v13 > 1024.0) {
      float v13 = 1024.0;
    }
    int v17 = (int)v13;
    _ZN2RB13CubicIteratorIDv2_fEC1ES1_S1_S1_S1_i(v26, (int)v13);
    if (v17 < 1) {
      return v6;
    }
  }
  else
  {
    uint32x2_t v16 = (uint32x2_t)vceq_f32(a1, a4);
    if ((vpmin_u32(v16, v16).u32[0] & 0x80000000) != 0)
    {
LABEL_13:
      _ZN2RB13CubicIteratorIDv2_fEC1ES1_S1_S1_S1_i(v26, 0);
      return 1.0;
    }
    int v17 = 1;
    _ZN2RB13CubicIteratorIDv2_fEC1ES1_S1_S1_S1_i(v26, 1);
  }
  int v18 = 0;
  float32x2_t v19 = (float32x2_t)v26[2];
  float v20 = 0.0;
  float32x2_t v21 = (float32x2_t)v26[1];
  while (1)
  {
    float v22 = sqrtf(vaddv_f32(vmul_f32(v21, v21)));
    if ((float)(v22 + v20) > a5) {
      break;
    }
    float32x2_t v21 = vadd_f32(v19, v21);
    float32x2_t v19 = vadd_f32((float32x2_t)v26[3], v19);
    ++v18;
    float v20 = v22 + v20;
    if (v17 == v18) {
      return v6;
    }
  }
  float32x2_t v23 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v17));
  float32x2_t v24 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v17), v23), v23);
  return (float)((float)((float)(a5 - v20) / v22) + (float)v18)
       * vmul_f32(v24, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v17), v24)).f32[0];
}

int32x2_t RB::Path::Projection::endpath(RB::Path::Projection *this)
{
  float v1 = *((float *)this + 188);
  *((float64x2_t *)this + 2) = vmulq_n_f64(*((float64x2_t *)this + 2), v1/ sqrt(vaddvq_f64(vmulq_f64(*((float64x2_t *)this + 2), *((float64x2_t *)this + 2)))));
  float32x2_t v2 = vrecpe_f32((float32x2_t)LODWORD(v1));
  float32x2_t v3 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v1), v2), v2);
  int32x2_t v4 = (int32x2_t)vmul_f32(v3, vrecps_f32((float32x2_t)LODWORD(v1), v3));
  *(float *)&unsigned int v5 = v1 * v1;
  float32x2_t v6 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(v1 * v1));
  float32x2_t v7 = vmul_f32(vrecps_f32((float32x2_t)v5, v6), v6);
  int32x2_t result = vzip1_s32(v4, (int32x2_t)vmul_f32(v7, vrecps_f32((float32x2_t)v5, v7)));
  *(int32x2_t *)((char *)this + 756) = result;
  return result;
}

float64x2_t RB::Path::Projection::closepath(float64x2_t *this)
{
  float64x2_t result = this[46];
  int8x16_t v2 = (int8x16_t)vceqq_f64(this[45], result);
  if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v2), 1), v2).u64[0] & 0x8000000000000000) != 0)
  {
    RB::Path::Projection::lineto(this, result);
    float64x2_t result = this[46];
    this[45] = result;
  }
  return result;
}

float64x2_t *RB::Path::Projection::lineto(float64x2_t *result, float64x2_t a2)
{
  float64x2_t v2 = result[45];
  int8x16_t v3 = (int8x16_t)vceqq_f64(v2, a2);
  if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v3), 1), v3).u64[0] & 0x8000000000000000) != 0)
  {
    int32x2_t v4 = result;
    float64x2_t v5 = vsubq_f64(a2, v2);
    double v6 = sqrt(vaddvq_f64(vmulq_f64(v5, v5)));
    float32x2_t v7 = (char *)&result[3].f64[1];
    float64_t v8 = result[44].f64[0];
    if (*(void *)&result[44].f64[1] < (unint64_t)(*(void *)&v8 + 1))
    {
      float64x2_t v16 = a2;
      float64x2_t result = (float64x2_t *)RB::vector<RB::Path::Projection::Segment,16ul,unsigned long>::reserve_slow(&result[3].f64[1], *(void *)&v8 + 1);
      a2 = v16;
      float64_t v8 = v4[44].f64[0];
      float64x2_t v2 = v4[45];
    }
    float64_t v9 = v4[43].f64[1];
    if (v9 == 0.0) {
      float64_t v9 = *(double *)&v7;
    }
    float32x2_t v10 = (float32x2_t *)(*(void *)&v9 + 40 * *(void *)&v8);
    __int32 v11 = LODWORD(v4[47].f64[0]);
    float32_t v12 = v6;
    float32x2_t v13 = vcvt_f32_f64(v2);
    *float32x2_t v10 = v13;
    v10[1] = v13;
    float32x2_t v14 = vcvt_f32_f64(a2);
    long long v10[2] = v14;
    v10[3] = v14;
    v10[4].i32[0] = v11;
    v10[4].f32[1] = v12;
    ++*(void *)&v4[44].f64[0];
    float v15 = v6 + *(float *)v4[47].f64;
    *(float *)v4[47].f64 = v15;
    v4[45] = a2;
  }
  return result;
}

__n128 *RB::Path::Projection::moveto(__n128 *result, __n128 a2)
{
  result[45] = a2;
  result[46] = a2;
  return result;
}

float RB::Path::Projection::quadto(float64x2_t *a1, float64x2_t a2, float64x2_t a3)
{
  float64x2_t v4 = vaddq_f64(a2, a2);
  float64x2_t v5 = (float64x2_t)vdupq_n_s64(0x3FD5555555555555uLL);
  return RB::Path::Projection::cubeto((uint64_t)a1, vmulq_f64(vaddq_f64(a1[45], v4), v5), vmulq_f64(vaddq_f64(v4, a3), v5), a3);
}

float RB::Path::Projection::cubeto(uint64_t a1, float64x2_t a2, float64x2_t a3, float64x2_t a4)
{
  if ((*(_DWORD *)(a1 + 48) & 0x1C) == 4)
  {
    long long v5 = *(_OWORD *)(a1 + 720);
    *(float64x2_t *)&v9[0].v = a2;
    *(_OWORD *)&v10[0].v = v5;
    float64x2_t v7 = a4;
    *(float64x2_t *)&v8[0].v = a3;
    CG::Cubic::Cubic((CG::Cubic *)v11, v10, v9, v8, (const Point *)&v7);
    RB::Path::Projection::cubeto_subdivide((RB::Path::Projection *)a1, v11);
  }
  else
  {
    return RB::Path::Projection::cubeto_emit(a1, a2, a3, a4);
  }
  return result;
}

float RB::Path::Projection::cubeto_emit(uint64_t a1, float64x2_t a2, float64x2_t a3, float64x2_t a4)
{
  double v5 = RB::cubic_length_f<double>(*(float64x2_t *)(a1 + 720), a2, a3, a4, 0.5);
  uint64_t v6 = *(void *)(a1 + 704);
  if (*(void *)(a1 + 712) < (unint64_t)(v6 + 1))
  {
    RB::vector<RB::Path::Projection::Segment,16ul,unsigned long>::reserve_slow((void *)(a1 + 56), v6 + 1);
    uint64_t v6 = *(void *)(a1 + 704);
  }
  uint64_t v7 = *(void *)(a1 + 696);
  if (!v7) {
    uint64_t v7 = a1 + 56;
  }
  float64_t v8 = (float32x2_t *)(v7 + 40 * v6);
  __int32 v9 = *(_DWORD *)(a1 + 752);
  float32_t v10 = v5;
  float32x2_t *v8 = vcvt_f32_f64(*(float64x2_t *)(a1 + 720));
  v8[1] = vcvt_f32_f64(a2);
  int32x2_t v8[2] = vcvt_f32_f64(a3);
  void v8[3] = vcvt_f32_f64(a4);
  v8[4].i32[0] = v9;
  v8[4].f32[1] = v10;
  ++*(void *)(a1 + 704);
  float result = v5 + *(float *)(a1 + 752);
  *(float *)(a1 + 752) = result;
  *(float64x2_t *)(a1 + 720) = a4;
  return result;
}

void RB::Path::Projection::cubeto_subdivide(RB::Path::Projection *this, float64x2_t *a2)
{
  if (CG::Cubic::is_flat_(a2, 4096.0))
  {
    float64x2_t v4 = a2[1];
    float64x2_t v5 = a2[2];
    float64x2_t v6 = a2[3];
    RB::Path::Projection::cubeto_emit((uint64_t)this, v4, v5, v6);
  }
  else
  {
    CG::Cubic::split(a2, 0.5, v7);
    RB::Path::Projection::cubeto_subdivide(this, (const CG::Cubic *)v7);
    RB::Path::Projection::cubeto_subdivide(this, (const CG::Cubic *)&v8);
  }
}

double RB::cubic_length_f<double>(float64x2_t a1, float64x2_t a2, float64x2_t a3, float64x2_t a4, double a5)
{
  uint64_t v5 = _ZN2RB13CubicIteratorIDv2_dE13segment_countIdEEiS1_S1_S1_S1_T_(a1, a2, a3, a4, a5);
  _ZN2RB13CubicIteratorIDv2_dEC1ES1_S1_S1_S1_i(v14, v5, (__n128)a1, (__n128)a2, (__n128)a3, (__n128)a4);
  if ((int)v5 < 1) {
    return 0.0;
  }
  float64x2_t v6 = v16;
  double result = 0.0;
  float64x2_t v8 = v15;
  do
  {
    float64x2_t v9 = vmulq_f64(v8, v8);
    float64x2_t v8 = vaddq_f64(v6, v8);
    float64x2_t v6 = vaddq_f64(v17, v6);
    double result = sqrt(vaddvq_f64(v9)) + result;
    LODWORD(v5) = v5 - 1;
  }
  while (v5);
  return result;
}

void RB::Path::BooleanTransform::endpath(RB::Path::BooleanTransform *this)
{
  float64x2_t v2 = (const CGPath *)*((void *)this + 4);
  if (v2)
  {
    switch(*((unsigned char *)this + 24))
    {
      case 1:
        int8x16_t v3 = (const CGPath *)*((void *)this + 1);
        if (!v3) {
          goto LABEL_23;
        }
        CGPathRef CopyByIntersectingPath = CGPathCreateCopyByIntersectingPath(v2, v3, *((unsigned char *)this + 25));
        goto LABEL_20;
      case 2:
        float64x2_t v8 = (const CGPath *)*((void *)this + 1);
        if (!v8) {
          return;
        }
        CGPathRef CopyByIntersectingPath = CGPathCreateCopyByUnioningPath(v2, v8, *((unsigned char *)this + 25));
        goto LABEL_20;
      case 3:
        float64x2_t v9 = (const CGPath *)*((void *)this + 1);
        if (!v9) {
          return;
        }
        CGPathRef CopyByIntersectingPath = CGPathCreateCopyBySubtractingPath(v2, v9, *((unsigned char *)this + 25));
        goto LABEL_20;
      case 4:
        float32_t v10 = (const CGPath *)*((void *)this + 1);
        if (!v10) {
          return;
        }
        CGPathRef CopyByIntersectingPath = CGPathCreateCopyBySymmetricDifferenceOfPath(v2, v10, *((unsigned char *)this + 25));
        goto LABEL_20;
      case 5:
        __int32 v11 = (const CGPath *)*((void *)this + 1);
        if (!v11) {
          goto LABEL_23;
        }
        CGPathRef CopyByIntersectingPath = CGPathCreateCopyOfLineByIntersectingPath(v2, v11, *((unsigned char *)this + 25));
        goto LABEL_20;
      case 6:
        float32_t v12 = (const CGPath *)*((void *)this + 1);
        if (v12)
        {
          CGPathRef CopyByIntersectingPath = CGPathCreateCopyOfLineBySubtractingPath(v2, v12, *((unsigned char *)this + 25));
LABEL_20:
          CGPathRef v13 = CopyByIntersectingPath;
          float32x2_t v14 = (const void *)*((void *)this + 4);
          if (v14) {
            CFRelease(v14);
          }
          *((void *)this + 4) = v13;
        }
        else
        {
LABEL_23:
          CFRelease(v2);
          *((void *)this + 4) = 0;
        }
        break;
      default:
        return;
    }
  }
  else if (*((unsigned char *)this + 24))
  {
    uint64_t v5 = (const void *)*((void *)this + 1);
    if (v5)
    {
      CFTypeRef v6 = CFRetain(v5);
      uint64_t v7 = (const void *)*((void *)this + 1);
      *((void *)this + 4) = v6;
      if (v7) {
        CFRelease(v7);
      }
    }
    *((void *)this + 1) = 0;
  }
}

void RB::Path::BooleanTransform::commit(RB::Path::BooleanTransform *this)
{
  if (*((unsigned char *)this + 24))
  {
    CopyByNormalizing = (const CGPath *)*((void *)this + 4);
    if (!CopyByNormalizing) {
      return;
    }
    goto LABEL_3;
  }
  CopyByNormalizing = CGPathCreateCopyByNormalizing(*((CGPathRef *)this + 1), *((unsigned char *)this + 25));
  float64x2_t v4 = (const void *)*((void *)this + 4);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 4) = CopyByNormalizing;
  if (CopyByNormalizing)
  {
LABEL_3:
    int8x16_t v3 = (void (***)(void))*((void *)this + 2);
    v5[0] = v3;
    v5[1] = 0;
    CGPathApply(CopyByNormalizing, v5, (CGPathApplierFunction)RB::Path::Iterator::callback_1);
    (**v3)(v3);
  }
}

void RB::Path::DilateGlyphTransform::endpath(RB::Path::DilateGlyphTransform *this, uint64_t a2)
{
  MEMORY[0x270FA5388](this, a2);
  int8x16_t v3 = v2;
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v5 = &unk_26C4E7060;
  long long v6 = 0u;
  long long v7 = 0u;
  uint64_t v8 = 0;
  RB::Path::BufferedTransform::apply(v2, (uint64_t)&v5);
  RB::Path::Dilator::Dilator((uint64_t)v4, v3[267].n128_i64[1], v3[268]);
  if (*(double *)&v6 >= 0.0)
  {
    RB::Path::BufferedTransform::apply(v3, (uint64_t)v4);
    RB::Path::Dilator::endpath((RB::Path::Dilator *)v4);
  }
  else
  {
    v9[0] = &unk_26C4E7120;
    v9[1] = v4;
    *(_OWORD *)float32_t v10 = 0u;
    uint64_t v11 = 128;
    *(_OWORD *)float32_t v12 = 0u;
    uint64_t v13 = 256;
    RB::Path::BufferedTransform::apply(v3, (uint64_t)v9);
    RB::Path::Reverser::endpath((RB::Path::Reverser *)v9);
    if (v12[0]) {
      free(v12[0]);
    }
    if (v10[0]) {
      free(v10[0]);
    }
  }
}

uint64_t RB::Path::ProjectPointsTransform::ProjectPointsTransform(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, double a5)
{
  *(void *)a1 = &unk_26C4EF0A0;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a3;
  *(double *)(a1 + 24) = a5;
  *(double *)(a1 + 32) = a5 * a5;
  long long v7 = *a4;
  long long v8 = a4[2];
  *(_OWORD *)(a1 + 64) = a4[1];
  *(_OWORD *)(a1 + 80) = v8;
  *(_OWORD *)(a1 + 48) = v7;
  long long v9 = a4[1];
  v14[0] = *a4;
  v14[1] = v9;
  _OWORD v14[2] = a4[2];
  if (RB::AffineTransform::invert((RB::AffineTransform *)v14)) {
    float32_t v10 = v14;
  }
  else {
    float32_t v10 = a4;
  }
  long long v11 = v10[1];
  long long v12 = v10[2];
  *(_OWORD *)(a1 + 96) = *v10;
  *(_OWORD *)(a1 + 112) = v11;
  *(_OWORD *)(a1 + 128) = v12;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  return a1;
}

double RB::Path::ProjectPointsTransform::project(uint64_t a1, float64x2_t a2)
{
  v16[0] = (float64x2_t)xmmword_2142181C0;
  v16[1] = (float64x2_t)xmmword_2142181D0;
  int8x16_t v3 = (float64x2_t *)(a1 + 96);
  float64x2_t v4 = *(float64x2_t *)(a1 + 96);
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  BOOL v5 = RB::Path::Projection::project(*(void *)(a1 + 16), (uint64_t)v16, vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 128), v4, a2.f64[0]), *(float64x2_t *)(a1 + 112), a2, 1));
  double v6 = a2.f64[0];
  if (v5)
  {
    v7.f64[0] = RB::operator*(v3, v16);
    v15[0] = v7;
    v15[1] = v8;
    int32x2_t v15[2] = v9;
    v10.f64[0] = RB::operator*(v15, (float64x2_t *)(a1 + 48));
    *(void *)&double v6 = *(_OWORD *)&vmlaq_f64(vmlaq_f64(v11, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a2.f64[0], 0), v10), (float64x2_t)vdupq_laneq_s64((int64x2_t)a2, 1), v12);
  }
  return v6;
}

uint64_t RB::Path::ProjectPointsTransform::moveto(uint64_t a1, float64x2_t a2)
{
  *(float64x2_t *)(a1 + 144) = a2;
  *(float64x2_t *)(a1 + 160) = a2;
  v3.n128_f64[0] = RB::Path::ProjectPointsTransform::project(a1, a2);
  float64x2_t v4 = *(uint64_t (**)(__n128))(**(void **)(a1 + 8) + 16);
  return v4(v3);
}

uint64_t RB::Path::ProjectPointsTransform::lineto(uint64_t result, float64x2_t a2)
{
  uint64_t v2 = result;
  float64x2_t v3 = *(float64x2_t *)(result + 144);
  float64x2_t v4 = vsubq_f64(a2, v3);
  double v5 = vaddvq_f64(vmulq_f64(v4, v4));
  double v6 = 1.0;
  if (v5 <= *(double *)(result + 32))
  {
    int v7 = 1;
  }
  else
  {
    int v7 = vcvtpd_s64_f64(sqrt(v5) / *(double *)(result + 24));
    if (v7 > 15)
    {
      int v7 = 16;
      double v6 = 0.0625;
    }
    else if (v7 != 1)
    {
      if (v7 < 1) {
        return result;
      }
      double v6 = 1.0 / (double)v7;
    }
  }
  __asm { FMOV            V0.2D, #0.5 }
  float64x2_t v17 = _Q0;
  float64x2_t v18 = v4;
  _Q0.f64[0] = v6;
  float64x2_t v19 = *(float64x2_t *)(result + 144);
  do
  {
    float64x2_t v22 = _Q0;
    float64x2_t v20 = vmlaq_n_f64(v3, v4, _Q0.f64[0]);
    float64x2_t v13 = vmulq_f64(vaddq_f64(*(float64x2_t *)(v2 + 144), v20), v17);
    *(float64x2_t *)(v2 + 144) = v20;
    uint64_t v14 = *(void *)(v2 + 8);
    v15.n128_f64[0] = RB::Path::ProjectPointsTransform::project(v2, v13);
    __n128 v21 = v15;
    v16.n128_f64[0] = RB::Path::ProjectPointsTransform::project(v2, v20);
    double result = (*(uint64_t (**)(uint64_t, __n128, __n128))(*(void *)v14 + 32))(v14, v21, v16);
    _Q0.f64[1] = v22.f64[1];
    float64x2_t v4 = v18;
    float64x2_t v3 = v19;
    _Q0.f64[0] = v22.f64[0] + v6;
    --v7;
  }
  while (v7);
  return result;
}

uint64_t RB::Path::ProjectPointsTransform::quadto(__n128 *a1, float64x2_t a2, float64x2_t a3)
{
  a1[9] = (__n128)a3;
  unint64_t v4 = a1->n128_u64[1];
  v5.n128_f64[0] = RB::Path::ProjectPointsTransform::project((uint64_t)a1, a2);
  __n128 v10 = v5;
  v6.n128_f64[0] = RB::Path::ProjectPointsTransform::project((uint64_t)a1, a3);
  int v7 = *(uint64_t (**)(unint64_t, __n128, __n128))(*(void *)v4 + 32);
  return v7(v4, v10, v6);
}

uint64_t RB::Path::ProjectPointsTransform::cubeto(__n128 *a1, float64x2_t a2, float64x2_t a3, float64x2_t a4)
{
  a1[9] = (__n128)a4;
  unint64_t v5 = a1->n128_u64[1];
  v6.n128_f64[0] = RB::Path::ProjectPointsTransform::project((uint64_t)a1, a2);
  __n128 v14 = v6;
  v7.n128_f64[0] = RB::Path::ProjectPointsTransform::project((uint64_t)a1, a3);
  __n128 v12 = v7;
  v8.n128_f64[0] = RB::Path::ProjectPointsTransform::project((uint64_t)a1, a4);
  float64x2_t v9 = *(uint64_t (**)(unint64_t, __n128, __n128, __n128))(*(void *)v5 + 40);
  return v9(v5, v14, v12, v8);
}

uint64_t RB::Path::ProjectPointsTransform::closepath(float64x2_t *this)
{
  float64x2_t v2 = this[10];
  int8x16_t v3 = (int8x16_t)vceqq_f64(this[9], v2);
  if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v3), 1), v3).u64[0] & 0x8000000000000000) != 0) {
    RB::Path::ProjectPointsTransform::lineto((uint64_t)this, v2);
  }
  unint64_t v4 = *(uint64_t (**)(void))(**(void **)&this->f64[1] + 8);
  return v4();
}

void RB::Path::Builder::Builder(RB::Path::Builder *this)
{
  *(void *)this = &unk_26C4EF0E0;
  *((void *)this + 1) = 0;
  operator new();
}

uint64_t RB::Path::Builder::operator RBPath(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

_DWORD *RB::Path::Builder::moveto(uint64_t a1, __n128 a2)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  __n128 v3 = a2;
  return RB::Path::Storage::append_element((RB::Path::Storage *)(*(void *)(a1 + 8) + 16), 0, v3.n128_f64, 0);
}

_DWORD *RB::Path::Builder::lineto(uint64_t a1, __n128 a2)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  __n128 v3 = a2;
  return RB::Path::Storage::append_element((RB::Path::Storage *)(*(void *)(a1 + 8) + 16), (const char *)1, v3.n128_f64, 0);
}

_DWORD *RB::Path::Builder::quadto(uint64_t a1, __n128 a2, __n128 a3)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  v4[0] = a2;
  v4[1] = a3;
  return RB::Path::Storage::append_element((RB::Path::Storage *)(*(void *)(a1 + 8) + 16), (const char *)2, (double *)v4, 0);
}

_DWORD *RB::Path::Builder::cubeto(uint64_t a1, __n128 a2, __n128 a3, __n128 a4)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  v5[0] = a2;
  v5[1] = a3;
  void v5[2] = a4;
  return RB::Path::Storage::append_element((RB::Path::Storage *)(*(void *)(a1 + 8) + 16), (const char *)3, (double *)v5, 0);
}

_DWORD *RB::Path::Builder::closepath(RB::Path::Builder *this)
{
  return RB::Path::Storage::append_element((RB::Path::Storage *)(*((void *)this + 1) + 16), (const char *)4, 0, 0);
}

__n128 *RB::Path::anonymous namespace'::Lengths::lineto(__n128 *result, float64x2_t a2)
{
  float64x2_t v2 = result;
  float64x2_t v3 = (float64x2_t)result[67];
  uint64_t v4 = &result->n128_i8[8];
  unint64_t v5 = result[65].n128_u64[0];
  size_t v6 = v5 + 1;
  if (result[65].n128_u64[1] < v5 + 1)
  {
    float64x2_t v10 = (float64x2_t)result[67];
    float64x2_t v11 = a2;
    double result = (__n128 *)RB::vector<double,128ul,unsigned long>::reserve_slow(&result->n128_i8[8], v6);
    float64x2_t v3 = v10;
    a2 = v11;
    unint64_t v5 = v2[65].n128_u64[0];
    size_t v6 = v5 + 1;
  }
  float64x2_t v7 = vsubq_f64(a2, v3);
  double v8 = sqrt(vaddvq_f64(vmulq_f64(v7, v7)));
  unint64_t v9 = v2[64].n128_u64[1];
  if (!v9) {
    unint64_t v9 = (unint64_t)v4;
  }
  *(double *)(v9 + 8 * v5) = v8;
  v2[65].n128_u64[0] = v6;
  v2[66].n128_f64[0] = v2[66].n128_f64[0] + v8;
  v2[67] = (__n128)a2;
  return result;
}

double RB::Path::anonymous namespace'::Lengths::quadto(float64x2_t *a1, float64x2_t a2, float64x2_t a3)
{
  float64x2_t v4 = vaddq_f64(a2, a2);
  float64x2_t v5 = (float64x2_t)vdupq_n_s64(0x3FD5555555555555uLL);
  return result;
}

void *RB::vector<double,128ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 130) + (*((void *)__dst + 130) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 130) + (*((void *)__dst + 130) >> 1);
  }
  double result = RB::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 128), __dst, 0x80uLL, (size_t *)__dst + 130, v3);
  *((void *)__dst + 128) = result;
  return result;
}

void *RB::vector<double,512ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 514) + (*((void *)__dst + 514) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 514) + (*((void *)__dst + 514) >> 1);
  }
  double result = RB::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 512), __dst, 0x200uLL, (size_t *)__dst + 514, v3);
  *((void *)__dst + 512) = result;
  return result;
}

void *RB::vector<RB::Path::Projection::Segment,16ul,unsigned long>::reserve_slow(void *__dst, unint64_t a2)
{
  if (*((void *)__dst + 82) + (*((void *)__dst + 82) >> 1) <= a2) {
    unint64_t v3 = a2;
  }
  else {
    unint64_t v3 = *((void *)__dst + 82) + (*((void *)__dst + 82) >> 1);
  }
  double result = RB::details::realloc_vector<unsigned long,40ul>(*((void **)__dst + 80), __dst, 0x10uLL, (unint64_t *)__dst + 82, v3);
  *((void *)__dst + 80) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,40ul>(void *__src, void *__dst, unint64_t a3, unint64_t *a4, unint64_t a5)
{
  float64x2_t v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      unint64_t v9 = a3;
      memcpy(__dst, __src, 40 * a5);
      free(v7);
      __n128 v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(40 * a5);
    unint64_t v9 = v8 / 0x28;
    if (v8 / 0x28 != *a4)
    {
      float64x2_t v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      __n128 v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 40 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t _ZN2RB13CubicIteratorIDv2_dE13segment_countIdEEiS1_S1_S1_S1_T_(float64x2_t a1, float64x2_t a2, float64x2_t a3, float64x2_t a4, double a5)
{
  float64x2_t v5 = vmaxnmq_f64(vabsq_f64(vaddq_f64(vsubq_f64(a1, vaddq_f64(a2, a2)), a3)), vabsq_f64(vaddq_f64(vsubq_f64(a2, vaddq_f64(a3, a3)), a4)));
  double v6 = ceil(sqrt(sqrt(vaddvq_f64(vmulq_f64(v5, v5))) * 0.75 / a5));
  if ((v6 < 0.0 || ((*(void *)&v6 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE)
    && *(void *)&v6 != 0)
  {
    return 0;
  }
  if (v6 < 1.0)
  {
    int64x2_t v9 = vceqq_f64(a1, a4);
    return (vandq_s8((int8x16_t)vdupq_laneq_s64(v9, 1), (int8x16_t)v9).u64[0] & 0x8000000000000000) == 0;
  }
  double v11 = 1024.0;
  if (v6 <= 1024.0) {
    double v11 = v6;
  }
  return (int)v11;
}

float64x2_t *_ZN2RB13CubicIteratorIDv2_dEC2ES1_S1_S1_S1_i(float64x2_t *result, int a2, float64x2_t a3, float64x2_t a4, float64x2_t a5, float64x2_t a6)
{
  __asm { FMOV            V5.2D, #3.0 }
  float64x2_t v11 = vmulq_f64(vsubq_f64(a4, a3), _Q5);
  float64x2_t v12 = vmlaq_f64(vnegq_f64(v11), _Q5, vsubq_f64(a5, a4));
  float64x2_t v13 = vsubq_f64(a6, vaddq_f64(vaddq_f64(v11, a3), v12));
  float v14 = 1.0 / (float)a2;
  __asm { FMOV            V7.2D, #6.0 }
  double v16 = (float)((float)(v14 * v14) * v14);
  float64x2_t v17 = vmulq_n_f64(vmulq_f64(v13, _Q7), v16);
  result[3] = v17;
  float64x2_t v18 = vmulq_n_f64(v12, (float)(v14 * v14));
  __asm { FMOV            V5.2D, #2.0 }
  void *result = a3;
  result[1] = vmlaq_n_f64(vmlaq_n_f64(v18, v11, v14), v13, v16);
  result[2] = vmlaq_f64(v17, _Q5, v18);
  return result;
}

uint64_t RB::DisplayList::Contents::empty_contents(RB::DisplayList::Contents *this)
{
  {
    RB::DisplayList::Contents::empty_contents(void)::$_0::operator()();
  }
  return RB::DisplayList::Contents::empty_contents(void)::shared_empty;
}

void sub_2141C4E54(_Unwind_Exception *a1)
{
}

void RB::DisplayList::Contents::empty_contents(void)::$_0::operator()()
{
}

void sub_2141C4EB4(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10F1C4040C62C24);
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::Contents::intern_uuid(RB::DisplayList::Contents *this, const UUID *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t result = *((void *)this + 49);
  if (!result
    || (*(void *)result == *(void *)a2 ? (BOOL v5 = *(void *)(result + 8) == *(void *)&(*a2)[8]) : (BOOL v5 = 0), !v5))
  {
    uint64_t result = *((void *)this + 4);
    if ((unint64_t)(result + 16) > *((void *)this + 5)) {
      uint64_t result = RB::Heap::alloc_slow((size_t *)this + 2, 0x10uLL, 0);
    }
    else {
      *((void *)this + 4) = result + 16;
    }
    *(_OWORD *)uint64_t result = *(_OWORD *)a2;
    *((void *)this + 49) = result;
  }
  return result;
}

uint64_t *RB::DisplayList::Contents::copy_atoms(RB::DisplayList::Contents *this, const RB::DisplayList::Metadata **a2, unsigned int a3, unsigned int a4)
{
  uint64_t result = (uint64_t *)*a2;
  if (*a2)
  {
    uint64_t result = RB::DisplayList::Metadata::text_identity(result);
    if (result)
    {
      int64x2_t v9 = (RB::DisplayList::Contents *)((char *)this + 16);
      float64x2_t v10 = RB::TextIdentity::copy_atoms((RB::TextIdentity *)result, v9, a3, a4);
      uint64_t result = RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)3>,RB::DisplayList::Metadata const*&,RB::TextIdentity const*&>(v9, a2, (uint64_t *)&v10);
      *a2 = (const RB::DisplayList::Metadata *)result;
    }
  }
  return result;
}

void *RB::DisplayList::Contents::get_cgimage(void *result, const void **a2, double a3)
{
  if (*((float *)result + 92) == 0.0)
  {
    uint64_t v4 = result[40];
    if (v4)
    {
      if (!*(void *)(v4 + 8)
        && !result[42]
        && !*((unsigned char *)result + 384)
        && (*((_WORD *)result + 190) & 0x2001) == 0
        && !*(void *)(v4 + 24)
        && !*(void *)(v4 + 16)
        && *(short float *)(v4 + 44) == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))
        && (*(_WORD *)(v4 + 46) & 0x3F) == 2)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v4 + 16))(result[40]);
        if (result == 12587009)
        {
          double v6 = *(float64x2_t **)(v4 + 48);
          if (v6)
          {
            uint64_t result = (void *)RB::Coverage::Primitive::contains(v4 + 64, *(void *)(v4 + 48), 0, vcvt_f32_s32(*(int32x2_t *)&a3));
            if (result)
            {
              return RB::Fill::Image<RB::ImageTexture>::get_cgimage((RB::ImageTexture *)(v4 + 112), v6, a2, a3);
            }
          }
        }
      }
    }
  }
  return result;
}

const void *RB::Fill::Image<RB::ImageTexture>::get_cgimage(RB::ImageTexture *a1, float64x2_t *a2, const void **a3, double a4)
{
  uint64_t result = (const void *)RB::Fill::ImageData::can_get_image((uint64_t)a1 + 16, a2, a4);
  if (result)
  {
    float64x2_t v7 = (const void *)RB::ImageTexture::cg_image(a1);
    uint64_t result = *a3;
    if (*a3 != v7)
    {
      if (result) {
        CFRelease(result);
      }
      if (v7) {
        uint64_t result = CFRetain(v7);
      }
      else {
        uint64_t result = 0;
      }
      *a3 = result;
    }
  }
  return result;
}

void RB::DisplayList::Contents::print(RB::DisplayList::Contents *this, std::string *a2)
{
  RB::SexpString::push(a2, "display-list");
  if (!*((unsigned char *)this + 400)) {
    RB::SexpString::print(a2, 0, "optimized");
  }
  RB::DisplayList::Layer::print((RB::DisplayList::Contents *)((char *)this + 320), a2);
  RB::SexpString::pop(a2);
}

atomic_uint *RB::Refcount<RB::DisplayList::Contents,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::DisplayList::Contents::finalize(void)::$_0::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

_DWORD *RB::DisplayList::AtomizedItems::advance(_DWORD *this, int a2)
{
  int v2 = this[4];
  int v3 = this[3] + a2;
  this[3] = v3;
  if (v3 == v2)
  {
    uint64_t v4 = this;
    this = *(_DWORD **)(*(void *)this + 8);
    *(void *)uint64_t v4 = this;
    *((void *)v4 + 1) = (v4[2] + 1);
    if (this) {
      this = (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(void *)this + 40))(this);
    }
    *((unsigned char *)v4 + 20) = this != -1;
    if (this == -1) {
      int v5 = 1;
    }
    else {
      int v5 = (int)this;
    }
    v4[4] = v5;
    *((unsigned char *)v4 + 88) = 0;
  }
  return this;
}

uint64_t RB::DisplayList::AtomizedItems::reset(uint64_t this, const RB::DisplayList::Item *a2, int a3, int a4)
{
  uint64_t v5 = this;
  if (*(const RB::DisplayList::Item **)this != a2)
  {
    *(void *)this = a2;
    *(_DWORD *)(this + 8) = a3;
    if (a2) {
      this = (*(uint64_t (**)(const RB::DisplayList::Item *))(*(void *)a2 + 40))(a2);
    }
    else {
      this = 0;
    }
    *(unsigned char *)(v5 + 20) = this != -1;
    if (this == -1) {
      int v6 = 1;
    }
    else {
      int v6 = this;
    }
    *(_DWORD *)(v5 + 16) = v6;
    *(unsigned char *)(v5 + 88) = 0;
  }
  *(_DWORD *)(v5 + 12) = a4;
  return this;
}

uint64_t RB::DisplayList::AtomizedItems::copy(RB::DisplayList::AtomizedItems *this, RB::DisplayList::Builder *a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, RB::DisplayList::Builder *, void, uint64_t, uint64_t))(**(void **)this
                                                                                                 + 48))(*(void *)this, a2, *((unsigned int *)this + 3), a3, a4);
}

uint64_t RB::DisplayList::AtomizedItems::mix(RB::DisplayList::AtomizedItems *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::AtomizedItems *a3, RB::DisplayList::CachedTransform *a4)
{
  return (*(uint64_t (**)(void, const RB::DisplayList::Interpolator::State *, void, RB::DisplayList::CachedTransform *))(**(void **)this + 216))(*(void *)this, a2, *(void *)a3, a4);
}

const RB::DisplayList::ClipNode *RB::DisplayList::AtomizedItems::mix_clip_style(RB::DisplayList::AtomizedItems *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::AtomizedItems *a3, RB::DisplayList::CachedTransform *a4)
{
  uint64_t v7 = *(void *)this;
  uint64_t v8 = *(void *)(*(void *)this + 24);
  uint64_t v9 = *(void *)a3;
  if (*((void *)this + 3) != v8)
  {
    uint64_t v10 = *(void *)(v9 + 24);
LABEL_3:
    float64x2_t v11 = *(const RB::DisplayList::Style **)(v7 + 16);
    uint64_t v12 = *(void *)(v9 + 16);
    *((void *)this + 6) = v11;
    *((void *)this + 7) = v12;
    *((void *)this + 3) = v8;
    *((void *)this + 4) = v10;
    *((_WORD *)this + 56) = 256;
LABEL_9:
    uint64_t v13 = RB::DisplayList::CachedTransform::mix_style(a4, a2, v11, v12, 1);
    *((void *)this + 8) = v13;
    uint64_t result = RB::DisplayList::CachedTransform::mix_clip((const RB::DisplayList::ClipNode **)a4, a2, *((const RB::DisplayList::ClipNode **)this + 3), *((const RB::DisplayList::ClipNode **)this + 4), v13 == 0);
    *((void *)this + 5) = result;
    return result;
  }
  uint64_t v10 = *((void *)this + 4);
  if (v10 == *(void *)(v9 + 24)) {
    goto LABEL_3;
  }
  float64x2_t v11 = *(const RB::DisplayList::Style **)(v7 + 16);
  if (*((const RB::DisplayList::Style **)this + 6) != v11)
  {
    uint64_t v12 = *(void *)(v9 + 16);
LABEL_8:
    *((void *)this + 6) = v11;
    *((void *)this + 7) = v12;
    goto LABEL_9;
  }
  uint64_t v12 = *(void *)(v9 + 16);
  if (*((void *)this + 7) != v12) {
    goto LABEL_8;
  }
  return (const RB::DisplayList::ClipNode *)*((void *)this + 5);
}

float32x2_t *RB::DisplayList::AtomizedItems::styled_bounds(float32x2_t *this)
{
  if (!this[11].i8[0])
  {
    this[9] = RB::DisplayList::Item::styled_bounds(*(RB::DisplayList::Item **)this, 0);
    this[10] = v2;
    this[11].i8[0] = 1;
  }
  return this + 9;
}

uint64_t RB::DisplayList::AtomizedItems::atom_bounds(RB::DisplayList::AtomizedItems *this, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, uint64_t))(**(void **)this + 64))(*(void *)this, *((unsigned int *)this + 3), a2);
}

uint64_t RB::DisplayList::AtomizedItems::mix_clip_bounds(float32x2_t *this, const RB::DisplayList::Interpolator::State *a2, RB::Rect *a3, float32x2_t **a4)
{
  uint64_t v7 = (double *)this[3];
  uint64_t v8 = *(double **)(*(void *)this + 24);
  uint64_t v9 = *a4;
  if (v7 == v8)
  {
    uint64_t v10 = (void *)this[4];
    uint64_t v13 = (void *)v9[3];
    if (v10 != v13)
    {
      if (this[14].i8[1])
      {
        if (this[14].i8[0]) {
          goto LABEL_8;
        }
      }
      else
      {
        __int16 v14 = RB::DisplayList::CachedTransform::mix_clip_bounds((uint64_t)a2, this + 12, v7, v13);
        this[14].i16[0] = v14 | 0x100;
        if (v14) {
          goto LABEL_8;
        }
      }
      return 0;
    }
  }
  else
  {
    uint64_t v10 = (void *)v9[3];
  }
  uint64_t result = RB::DisplayList::CachedTransform::mix_clip_bounds((uint64_t)a2, this + 12, v8, v10);
  this[14].i16[0] = result | 0x100;
  float32x2_t v12 = (*a4)[3];
  this[3] = *(float32x2_t *)(*(void *)this + 24);
  this[4] = v12;
  this[6] = (float32x2_t)1;
  if (result)
  {
LABEL_8:
    *(_OWORD *)a3 = *(_OWORD *)this[12].f32;
    return 1;
  }
  return result;
}

const RB::Transition *RB::DisplayList::AtomizedItems::transition(RB::DisplayList::AtomizedItems *this, const RB::DisplayList::Interpolator::Layer *a2)
{
  int v3 = *(uint64_t **)(*(void *)this + 32);
  if (v3) {
    uint64_t v4 = RB::DisplayList::Metadata::transition(v3);
  }
  else {
    uint64_t v4 = 0;
  }
  return RB::DisplayList::Interpolator::Layer::item_transition(a2, (const RB::Transition *)v4);
}

unint64_t RB::DisplayList::AtomizedItems::animation_layer(RB::DisplayList::AtomizedItems *this)
{
  uint64_t v1 = *(uint64_t **)(*(void *)this + 32);
  if (v1 && (float32x2_t v2 = RB::DisplayList::Metadata::animation_layer(v1)) != 0)
  {
    unint64_t v3 = *v2 & 0xFFFFFFFF00000000;
    uint64_t v4 = *v2;
  }
  else
  {
    uint64_t v4 = 0;
    unint64_t v3 = 0x100000000;
  }
  return v4 | v3;
}

uint64_t RB::DisplayList::AtomizedItems::apply_effects(uint64_t result, const RB::DisplayList::Interpolator::Layer *a2, uint64_t a3, unsigned int a4, RB::DisplayList::Item *a5, uint64_t a6)
{
  char v148 = (float32x2_t *)result;
  if (*(_DWORD *)(*(void *)(a3 + 8) + 32) != -1)
  {
    uint64_t v9 = a2;
    uint64_t result = (uint64_t)RB::DisplayList::AtomizedItems::transition((RB::DisplayList::AtomizedItems *)result, a2);
    if (*(_DWORD *)(result + 48))
    {
      uint64_t v14 = result;
      unsigned int v15 = 0;
      uint64_t v16 = result + 24;
      int v139 = v148 + 9;
      uint64_t v146 = (char *)v9 + 200;
      if (a4) {
        int v17 = 2;
      }
      else {
        int v17 = 1;
      }
      int v140 = v17;
      uint64_t result = 8;
      unsigned __int8 v141 = v9;
      do
      {
        uint64_t v18 = *(void *)(v14 + 40);
        if (!v18) {
          uint64_t v18 = v16;
        }
        float64x2_t v19 = (__int16 *)(v18 + 4 * v15);
        float64x2_t v20 = *(uint64_t **)(a3 + 8);
        unint64_t v21 = *v20;
        if ((*v20 & 0x100000000) != 0) {
          char v22 = 4;
        }
        else {
          char v22 = 8;
        }
        if ((v21 & 0x400000000) != 0) {
          char v23 = 16;
        }
        else {
          char v23 = 32;
        }
        __int16 v24 = *v19;
        if (((v22 | v23 | a4) & HIBYTE(*v19) & 0x3F) == a4)
        {
          int v25 = v24 & 0x7F;
          int v26 = (v21 >> 35) & (v24 < 0) ^ (a4 >> 1) & ((unsigned __int16)(v24 & 0x4000) >> 14);
          switch(v24 & 0x7F)
          {
            case 1:
              *(float *)v10.f64 = RB::DisplayList::Interpolator::State::effect_time((RB::DisplayList::Interpolator::State *)a3, (const RB::Transition *)v14, (const Effect *)v19, a4, v10.f64[0], v11.f64[0], v12.f64[0], *(float *)v13.f64);
              uint64_t result = 8;
              if (*(float *)v10.f64 < 0.0) {
                *(float *)v10.f64 = 0.0;
              }
              if (*(float *)v10.f64 > 1.0) {
                *(float *)v10.f64 = 1.0;
              }
              LODWORD(v11.f64[0]) = *(_DWORD *)(a6 + 56);
              *(float *)v10.f64 = *(float *)v10.f64 * *(float *)v11.f64;
              *(_DWORD *)(a6 + 56) = LODWORD(v10.f64[0]);
              break;
            case 2:
            case 6:
              if ((v24 & 0x7F) == 6)
              {
                if (a5)
                {
                  *(double *)&uint64_t v33 = COERCE_DOUBLE((*(uint64_t (**)(RB::DisplayList::Item *, void, uint64_t, unsigned __int8 *))(*(void *)a5 + 56))(a5, 0, 32, RB::Transition::_effect_args));
                  if (!v35)
                  {
                    v149[0] = RB::DisplayList::Item::styled_bounds(a5, 0);
                    goto LABEL_157;
                  }
LABEL_89:
                  double v75 = *(double *)&v33;
                }
                else
                {
                  *(double *)&uint64_t v33 = COERCE_DOUBLE((*(uint64_t (**)(float32x2_t, void, uint64_t, unsigned __int8 *))(**(void **)v148 + 56))(*v148, v148[1].u32[1], 32, RB::Transition::_effect_args));
                  if (v74) {
                    goto LABEL_89;
                  }
                  float32x2_t v99 = *(void **)(a3 + 8);
                  uint64_t v100 = 20;
                  if ((a4 & 1) == 0) {
                    uint64_t v100 = 12;
                  }
                  if (*(_DWORD *)((char *)v99 + v100) || v148[2].i32[0] > (*v99 >> 36))
                  {
                    v149[0] = COERCE_FLOAT32X2_T((*(double (**)(void))(**(void **)v148 + 64))());
                    v149[1] = v34;
                    uint64_t v103 = *(void *)(*(void *)v148 + 24);
                    if (v103) {
                      RB::Rect::intersect(v149, *(double *)(v103 + 16), *(float32x2_t *)(v103 + 24), v12.f64[0], v13.f64[0], v101, v102);
                    }
                  }
                  else
                  {
                    if (!v148[11].i8[0])
                    {
                      v148[9] = RB::DisplayList::Item::styled_bounds(*(RB::DisplayList::Item **)v148, 0);
                      v148[10] = v34;
                      v148[11].i8[0] = 1;
                    }
                    *(_OWORD *)v149[0].f32 = *(_OWORD *)v139->f32;
                  }
LABEL_157:
                  double v75 = *(double *)v149;
                }
                double v142 = v75;
                goto LABEL_159;
              }
              if (a5)
              {
                v149[0] = RB::DisplayList::Item::styled_bounds(a5, 0);
                v149[1] = v72;
              }
              else
              {
                uint64_t v94 = 20;
                if ((a4 & 1) == 0) {
                  uint64_t v94 = 12;
                }
                if (*(_DWORD *)((char *)v20 + v94) || v148[2].i32[0] > v21 >> 36)
                {
                  v149[0] = COERCE_FLOAT32X2_T((*(double (**)(void))(**(void **)v148 + 64))());
                  v149[1] = v95;
                  uint64_t v98 = *(void *)(*(void *)v148 + 24);
                  if (v98) {
                    RB::Rect::intersect(v149, *(double *)(v98 + 16), *(float32x2_t *)(v98 + 24), v12.f64[0], v13.f64[0], v96, v97);
                  }
                }
                else
                {
                  if (!v148[11].i8[0])
                  {
                    v148[9] = RB::DisplayList::Item::styled_bounds(*(RB::DisplayList::Item **)v148, 0);
                    v148[10] = v134;
                    v148[11].i8[0] = 1;
                  }
                  *(_OWORD *)v149[0].f32 = *(_OWORD *)v139->f32;
                }
              }
              double v75 = *(double *)&v149[1];
              float32x2_t v34 = vmla_f32(v149[0], (float32x2_t)0x3F0000003F000000, v149[1]);
              double v142 = *(double *)&v34;
LABEL_159:
              v34.i32[0] = *((_DWORD *)v19 + 1);
              if (v26)
              {
                unsigned int v135 = *((_DWORD *)v19 + 1);
                float32x2_t v136 = vrecpe_f32((float32x2_t)v34.u32[0]);
                *(float32x2_t *)&v12.f64[0] = vrecps_f32((float32x2_t)v135, v136);
                float32x2_t v34 = vmul_f32(*(float32x2_t *)&v12.f64[0], v136);
                double v75 = COERCE_DOUBLE(vmul_f32(v34, vrecps_f32((float32x2_t)v135, v34)));
                float v145 = *(float *)&v75;
              }
              else
              {
                float v145 = *((float *)v19 + 1);
              }
              *(float *)v10.f64 = fmaxf(v145+ (float)((float)(1.0 - v145)* RB::DisplayList::Interpolator::State::effect_time((RB::DisplayList::Interpolator::State *)a3, (const RB::Transition *)v14, (const Effect *)v19, a4, v75, *(double *)&v34, v12.f64[0], *(float *)v13.f64)), 0.0);
              float64x2_t v137 = *(float64x2_t *)(a6 + 16);
              float64x2_t v13 = vmulq_n_f64(*(float64x2_t *)a6, *(float *)v10.f64);
              float64x2_t v11 = vmulq_n_f64(v137, *(float *)v10.f64);
              v12.f64[0] = (float)-*((float *)&v142 + 1);
              float64x2_t v138 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a6 + 32), *(float64x2_t *)a6, *(float *)&v142), v137, *((float *)&v142 + 1)), v13, (float)-*(float *)&v142), v11, v12.f64[0]);
              *(float64x2_t *)a6 = v13;
              *(float64x2_t *)(a6 + 16) = v11;
              *(float64x2_t *)(a6 + 32) = v138;
              uint64_t result = 8;
              if (*(unsigned char *)(a6 + 52))
              {
                LODWORD(v11.f64[0]) = *(_DWORD *)(a6 + 48);
                *(float *)v10.f64 = *(float *)v11.f64 * *(float *)v10.f64;
                goto LABEL_164;
              }
              break;
            case 3:
              float32x2_t v36 = *(float32x2_t *)(v19 + 2);
              int8x8_t v37 = (int8x8_t)vneg_f32(v36);
              if (v26) {
                unsigned int v38 = -1;
              }
              else {
                unsigned int v38 = 0;
              }
              int8x8_t v39 = (int8x8_t)vdup_n_s32(v38);
              float32x2_t v40 = (float32x2_t)vbsl_s8(v39, v37, (int8x8_t)v36);
              float v41 = RB::DisplayList::Interpolator::State::effect_time((RB::DisplayList::Interpolator::State *)a3, (const RB::Transition *)v14, (const Effect *)v19, a4, *(double *)&v36, *(double *)&v37, *(double *)&v39, *(float *)v13.f64);
              uint64_t result = 8;
              float32x2_t v42 = vmul_n_f32(v40, 1.0 - v41);
              goto LABEL_87;
            case 4:
              float v43 = *((float *)v19 + 1);
              if (v43 > 0.0) {
                goto LABEL_147;
              }
              break;
            case 5:
              uint64_t v45 = *((unsigned int *)v20 + 6);
              uint64_t v44 = *((unsigned int *)v20 + 7);
              if (*((_DWORD *)v20 + 6)) {
                BOOL v46 = v44 == 1;
              }
              else {
                BOOL v46 = 1;
              }
              int v47 = v46;
              if (a5)
              {
                v149[0] = RB::DisplayList::Item::styled_bounds(a5, 0);
                v149[1] = v48;
              }
              else
              {
                uint64_t v76 = 20;
                if ((a4 & 1) == 0) {
                  uint64_t v76 = 12;
                }
                if (*(_DWORD *)((char *)v20 + v76) || v148[2].i32[0] > v21 >> 36)
                {
                  v149[0] = COERCE_FLOAT32X2_T((*(double (**)(void))(**(void **)v148 + 64))());
                  v149[1] = v77;
                  uint64_t v82 = *(void *)(*(void *)v148 + 24);
                  if (v82) {
                    RB::Rect::intersect(v149, *(double *)(v82 + 16), *(float32x2_t *)(v82 + 24), v78, v79, v80, v81);
                  }
                }
                else
                {
                  if (!v148[11].i8[0])
                  {
                    v148[9] = RB::DisplayList::Item::styled_bounds(*(RB::DisplayList::Item **)v148, 0);
                    v148[10] = v104;
                    v148[11].i8[0] = 1;
                  }
                  *(_OWORD *)v149[0].f32 = *(_OWORD *)v139->f32;
                }
              }
              float32x2_t v105 = v149[1];
              char v106 = (char *)*((void *)v141 + 29);
              if (!v106) {
                char v106 = v146;
              }
              if (v47) {
                uint64_t v107 = 0;
              }
              else {
                uint64_t v107 = v45;
              }
              uint64_t v108 = (double *)&v106[16 * v107];
              double v110 = *v108;
              double v109 = v108[1];
              if (v47) {
                uint64_t v111 = 1;
              }
              else {
                uint64_t v111 = v44;
              }
              long long v112 = &v106[16 * v111];
              float32x2_t v114 = *(float32x2_t *)v112;
              double v113 = *((double *)v112 + 1);
              if (a4)
              {
                double v115 = v110;
                float32x2_t v116 = *(float32x2_t *)&v109;
              }
              else
              {
                double v115 = *(double *)v112;
                float32x2_t v116 = *(float32x2_t *)(v112 + 8);
                float32x2_t v114 = *(float32x2_t *)&v110;
                double v113 = v109;
              }
              uint64_t v9 = v141;
              float32x2_t v117 = vadd_f32(vdiv_f32(vmul_f32(vsub_f32(v149[0], v114), v116), *(float32x2_t *)&v113), *(float32x2_t *)&v115);
              float32x2_t v118 = vmul_f32(v116, v149[1]);
              float32x2_t v119 = vdiv_f32(v118, *(float32x2_t *)&v113);
              float32x2_t v144 = v149[0];
              float v120 = RB::DisplayList::Interpolator::State::effect_time((RB::DisplayList::Interpolator::State *)a3, (const RB::Transition *)v14, (const Effect *)v19, a4, v113, *(double *)&v118, v115, v116.f32[0]);
              float32x2_t v121 = vadd_f32(v117, v119);
              *(float32x2_t *)v122.i8 = vmla_n_f32(v121, vsub_f32(vadd_f32(v105, v144), v121), v120);
              v10.f64[0] = RB::Rect::from_bounds(vmla_n_f32(v117, vsub_f32(v144, v117), v120), v122);
              *(float32x2_t *)&v12.f64[0] = vdiv_f32(v123, v105);
              float32x2_t v124 = vmla_f32(v144, (float32x2_t)0x3F0000003F000000, v105);
              *(float32x2_t *)&v10.f64[0] = vmla_f32(*(float32x2_t *)&v10.f64[0], (float32x2_t)0x3F0000003F000000, v123);
              double v125 = *(float *)v10.f64;
              v10.f64[0] = *((float *)v10.f64 + 1);
              float64x2_t v126 = *(float64x2_t *)(a6 + 16);
              float64x2_t v127 = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a6 + 32), *(float64x2_t *)a6, v125), v126, v10.f64[0]);
              LODWORD(v10.f64[0]) = HIDWORD(v12.f64[0]);
              float64x2_t v11 = vmulq_n_f64(*(float64x2_t *)a6, *(float *)v12.f64);
              float64x2_t v13 = vmulq_n_f64(v126, *((float *)v12.f64 + 1));
              *(float64x2_t *)a6 = v11;
              *(float64x2_t *)(a6 + 16) = v13;
              *(float64x2_t *)(a6 + 32) = vmlaq_n_f64(vmlaq_n_f64(v127, v11, (float)-v124.f32[0]), v13, (float)-v124.f32[1]);
              uint64_t result = 8;
              if (*(unsigned char *)(a6 + 52))
              {
                *(float *)v11.f64 = 0.5 * *(float *)(a6 + 48);
                *(float *)v10.f64 = (float)(*(float *)v12.f64 + *((float *)v12.f64 + 1)) * *(float *)v11.f64;
LABEL_164:
                *(_DWORD *)(a6 + 48) = LODWORD(v10.f64[0]);
              }
              break;
            case 7:
            case 8:
            case 9:
            case 0xA:
              float64x2_t v27 = (char *)*((void *)v9 + 29);
              if (!v27) {
                float64x2_t v27 = v146;
              }
              long long v28 = (float32x2_t *)&v27[16 * *((unsigned int *)v20 + 6)];
              double v29 = *(double *)v28;
              double v30 = (float32x2_t *)&v27[16 * *((unsigned int *)v20 + 7)];
              int32x2_t v31 = (int32x2_t)*v30;
              float32x2_t v32 = vsub_f32(*v30, *v28);
              if (v25 == 7)
              {
                v32.i32[1] = 0;
              }
              else
              {
                *(float32x2_t *)&v12.f64[0] = v28[1];
                double v29 = COERCE_DOUBLE(vsub_f32(vadd_f32(v30[1], (float32x2_t)v31), vadd_f32(*(float32x2_t *)&v12.f64[0], *(float32x2_t *)&v29)));
                v31.i32[1] = HIDWORD(v29);
                v31.i32[0] = 0;
                v32.i32[0] = 0;
                HIDWORD(v29) = 0;
                if (v25 != 8) {
                  double v29 = *(double *)&v32;
                }
                if (v25 == 10) {
                  float32x2_t v32 = (float32x2_t)v31;
                }
                else {
                  *(double *)&float32x2_t v32 = v29;
                }
              }
              if (*((float *)v20 + 9) == 0.0)
              {
                float v70 = *(float *)(a3 + 16);
                goto LABEL_84;
              }
              double v143 = *(double *)&v32;
              if (a4)
              {
                if ((v24 & 0x80) == 0)
                {
LABEL_76:
                  unsigned int v71 = 0;
                  goto LABEL_81;
                }
                BOOL v69 = (unsigned __int8 *)(v19 + 1);
              }
              else
              {
                if ((v24 & 0x80) == 0) {
                  goto LABEL_76;
                }
                BOOL v69 = (unsigned __int8 *)v19 + 3;
              }
              unsigned int v71 = *v69;
LABEL_81:
              LODWORD(v29) = *(_DWORD *)(a3 + 20);
              RB::DisplayList::Interpolator::Contents::animation_time(*(RB::DisplayList::Interpolator::Contents **)v9, *((_DWORD *)v20 + 8), v71, v29, *(double *)&v31);
              if (*(unsigned char *)(a3 + 28)) {
                float v70 = 1.0 - v70;
              }
              uint64_t result = 8;
              *(double *)&float32x2_t v32 = v143;
LABEL_84:
              v31.i32[0] = 0;
              LODWORD(v12.f64[0]) = a4 & 2;
              float32x2_t v73 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32((int32x2_t)vmvn_s8((int8x8_t)vceq_s32(*(int32x2_t *)&v12.f64[0], v31)), 0), (int8x8_t)v32, (int8x8_t)vneg_f32(v32));
              if (a4) {
                float v70 = 1.0 - v70;
              }
              float32x2_t v42 = vmul_n_f32(v73, v70);
LABEL_87:
              v11.f64[0] = v42.f32[0];
              v10.f64[0] = v42.f32[1];
              float64x2_t v12 = *(float64x2_t *)a6;
              float64x2_t v13 = *(float64x2_t *)(a6 + 16);
              *(float64x2_t *)(a6 + 32) = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a6 + 32), *(float64x2_t *)a6, v11.f64[0]), v13, v10.f64[0]);
              break;
            case 0xF:
              if (a5)
              {
                v149[0] = RB::DisplayList::Item::styled_bounds(a5, 0);
                v149[1] = v49;
              }
              else
              {
                uint64_t v83 = 20;
                if ((a4 & 1) == 0) {
                  uint64_t v83 = 12;
                }
                if (*(_DWORD *)((char *)v20 + v83) || v148[2].i32[0] > v21 >> 36)
                {
                  v149[0] = COERCE_FLOAT32X2_T((*(double (**)(void))(**(void **)v148 + 64))());
                  v149[1] = v84;
                  uint64_t v88 = *(void *)(*(void *)v148 + 24);
                  if (v88) {
                    RB::Rect::intersect(v149, *(double *)(v88 + 16), *(float32x2_t *)(v88 + 24), v85, v13.f64[0], v86, v87);
                  }
                }
                else
                {
                  if (!v148[11].i8[0])
                  {
                    v148[9] = RB::DisplayList::Item::styled_bounds(*(RB::DisplayList::Item **)v148, 0);
                    v148[10] = v128;
                    v148[11].i8[0] = 1;
                  }
                  *(_OWORD *)v149[0].f32 = *(_OWORD *)v139->f32;
                }
              }
              float32x2_t v129 = vmul_f32(*(float32x2_t *)(v19 + 2), v149[1]);
              int8x8_t v130 = (int8x8_t)vneg_f32(v129);
              if (v26) {
                unsigned int v131 = -1;
              }
              else {
                unsigned int v131 = 0;
              }
              int8x8_t v132 = (int8x8_t)vdup_n_s32(v131);
              *(float32x2_t *)&v10.f64[0] = vmul_n_f32((float32x2_t)vbsl_s8(v132, v130, (int8x8_t)v129), 1.0- RB::DisplayList::Interpolator::State::effect_time((RB::DisplayList::Interpolator::State *)a3, (const RB::Transition *)v14, (const Effect *)v19, a4, *(double *)&v129, *(double *)&v130, *(double *)&v132, *(float *)v13.f64));
              v11.f64[0] = *(float *)v10.f64;
              v10.f64[0] = *((float *)v10.f64 + 1);
              float64x2_t v12 = *(float64x2_t *)a6;
              float64x2_t v13 = *(float64x2_t *)(a6 + 16);
              *(float64x2_t *)(a6 + 32) = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a6 + 32), *(float64x2_t *)a6, v11.f64[0]), v13, v10.f64[0]);
              uint64_t result = 8;
              break;
            case 0x10:
              if (a5)
              {
                v149[0] = RB::DisplayList::Item::styled_bounds(a5, 0);
                v149[1] = v50;
              }
              else
              {
                uint64_t v89 = 20;
                if ((a4 & 1) == 0) {
                  uint64_t v89 = 12;
                }
                if (*(_DWORD *)((char *)v20 + v89) || v148[2].i32[0] > v21 >> 36)
                {
                  v149[0] = COERCE_FLOAT32X2_T((*(double (**)(void))(**(void **)v148 + 64))());
                  v149[1] = v90;
                  uint64_t v93 = *(void *)(*(void *)v148 + 24);
                  if (v93) {
                    RB::Rect::intersect(v149, *(double *)(v93 + 16), *(float32x2_t *)(v93 + 24), v12.f64[0], v13.f64[0], v91, v92);
                  }
                }
                else
                {
                  if (!v148[11].i8[0])
                  {
                    v148[9] = RB::DisplayList::Item::styled_bounds(*(RB::DisplayList::Item **)v148, 0);
                    v148[10] = v133;
                    v148[11].i8[0] = 1;
                  }
                  *(_OWORD *)v149[0].f32 = *(_OWORD *)v139->f32;
                }
              }
              v11.f64[0] = *(float64_t *)(v19 + 2);
              *(float32x2_t *)&v10.f64[0] = vmul_f32(*(float32x2_t *)&v11.f64[0], v149[1]);
              float v43 = vaddv_f32(*(float32x2_t *)&v10.f64[0]);
              uint64_t result = 8;
              if (v43 > 0.0)
              {
LABEL_147:
                *(float *)v10.f64 = fmaxf(v43- (float)(RB::DisplayList::Interpolator::State::effect_time((RB::DisplayList::Interpolator::State *)a3, (const RB::Transition *)v14, (const Effect *)v19, a4, v10.f64[0], v11.f64[0], v12.f64[0], *(float *)v13.f64)* v43), 0.0);
                if (*(unsigned char *)(a6 + 52))
                {
                  LODWORD(v11.f64[0]) = *(_DWORD *)(a6 + 48);
                  *(float *)v10.f64 = sqrtf((float)(*(float *)v10.f64 * *(float *)v10.f64)+ (float)(*(float *)v11.f64 * *(float *)v11.f64));
                }
                uint64_t result = 8;
                *(_DWORD *)(a6 + 48) = LODWORD(v10.f64[0]);
                *(unsigned char *)(a6 + 52) = 1;
              }
              break;
            case 0x11:
              int v51 = *((_DWORD *)v19 + 1);
              if ((v51 & 0xF) == 3) {
                unsigned int v52 = 0x80000000;
              }
              else {
                unsigned int v52 = 0x40000000;
              }
              if ((v51 & 0xF) == 1) {
                unsigned int v53 = 0;
              }
              else {
                unsigned int v53 = v52;
              }
              int v54 = (v53 | v51 & 0x10) ^ 0x10;
              float v55 = *((float *)v19 + 2) * *(float *)(a3 + 20);
              v149[0] = (float32x2_t)RB::DisplayList::AtomizedItems::animation_layer((RB::DisplayList::AtomizedItems *)v148);
              uint64_t v9 = v141;
              *(float *)v10.f64 = RB::Symbol::Animation::eval_appear_disappear((_DWORD *)(a4 & 1), v54, v149, v55);
              goto LABEL_63;
            case 0x12:
              int v56 = *((_DWORD *)v19 + 1);
              unsigned int v57 = (v56 & 0xF) - 1;
              if (v57 >= 4) {
                int v58 = 0x40000000;
              }
              else {
                int v58 = v57 << 30;
              }
              int v59 = (v58 | v56 & 0x10) ^ 0x10;
              float v60 = *((float *)v19 + 2) * *(float *)(a3 + 20);
              v149[0] = (float32x2_t)RB::DisplayList::AtomizedItems::animation_layer((RB::DisplayList::AtomizedItems *)v148);
              *(float *)v10.f64 = RB::Symbol::Animation::eval_replace(v140, v59, v149, v60);
LABEL_63:
              LODWORD(v12.f64[0]) = *(_DWORD *)(a6 + 56);
              *(float *)v11.f64 = *(float *)v12.f64 * *(float *)v11.f64;
              *(_DWORD *)(a6 + 56) = LODWORD(v11.f64[0]);
              uint64_t result = 8;
              if (*(float *)v10.f64 != 1.0)
              {
                uint64_t v61 = 28;
                if ((a4 & 1) == 0) {
                  uint64_t v61 = 24;
                }
                uint64_t v62 = *(unsigned int *)(*(void *)(a3 + 8) + v61);
                size_t v63 = (char *)*((void *)v9 + 29);
                if (!v63) {
                  size_t v63 = v146;
                }
                float32x2_t v64 = vmla_f32(*(float32x2_t *)&v63[16 * v62], (float32x2_t)0x3F0000003F000000, *(float32x2_t *)&v63[16 * v62 + 8]);
                float v65 = v64.f32[1];
                float64x2_t v66 = *(float64x2_t *)(a6 + 16);
                float64x2_t v67 = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a6 + 32), *(float64x2_t *)a6, v64.f32[0]), v66, v64.f32[1]);
                double v68 = *(float *)v10.f64;
                float64x2_t v12 = vmulq_n_f64(*(float64x2_t *)a6, v68);
                float64x2_t v10 = vmulq_n_f64(v66, v68);
                v11.f64[0] = (float)-v64.f32[0];
                v13.f64[0] = (float)-v65;
                *(float64x2_t *)a6 = v12;
                *(float64x2_t *)(a6 + 16) = v10;
                *(float64x2_t *)(a6 + 32) = vmlaq_n_f64(vmlaq_n_f64(v67, v12, v11.f64[0]), v10, v13.f64[0]);
              }
              break;
            default:
              break;
          }
        }
        v15 += RB::Transition::_effect_args[*v19 & 0x7F] + 1;
      }
      while (v15 < *(_DWORD *)(v14 + 48));
    }
  }
  return result;
}

void RB::DisplayList::AtomizedItems::effect_bounds(RB::DisplayList::AtomizedItems *this, const RB::DisplayList::Interpolator::Layer *a2, const RB::DisplayList::Interpolator::State *a3, unsigned int a4)
{
  if (*((unsigned char *)this + 88))
  {
    float32x2_t v8 = *(float32x2_t *)((char *)this + 72);
    float32x2_t v9 = *(float32x2_t *)((char *)this + 80);
  }
  else
  {
    float32x2_t v8 = RB::DisplayList::Item::styled_bounds(*(RB::DisplayList::Item **)this, 0);
    float32x2_t v9 = v10;
    *((float32x2_t *)this + 9) = v8;
    *((float32x2_t *)this + 10) = v10;
    *((unsigned char *)this + 88) = 1;
  }
  uint32x2_t v11 = (uint32x2_t)vclez_f32(v9);
  if ((vpmax_u32(v11, v11).u32[0] & 0x80000000) == 0)
  {
    v13[0] = (float64x2_t)xmmword_2142181C0;
    v13[1] = (float64x2_t)xmmword_2142181D0;
    char v17 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    LOBYTE(v16) = 0;
    float v18 = 1.0;
    RB::DisplayList::AtomizedItems::apply_effects((uint64_t)this, a2, (uint64_t)a3, a4, 0, (uint64_t)v13);
    if (v18 > 0.0)
    {
      *(float32x2_t *)v12.i8 = v9;
      RB::operator*(v13, v8, v12);
    }
  }
}

uint64_t RB::DisplayList::AtomizedItems::effects_change_geometry(RB::DisplayList::AtomizedItems *this, const RB::DisplayList::Interpolator::Layer *a2, const RB::DisplayList::Interpolator::State *a3, int a4)
{
  int v6 = RB::DisplayList::AtomizedItems::transition(this, a2);
  unsigned int v7 = *((_DWORD *)v6 + 12);
  if (!v7) {
    return 0;
  }
  unsigned int v8 = 0;
  float32x2_t v9 = (char *)v6 + 24;
  if (*((void *)v6 + 5)) {
    float32x2_t v9 = (char *)*((void *)v6 + 5);
  }
  uint64_t v10 = **((void **)a3 + 1);
  if ((v10 & 0x100000000) != 0) {
    char v11 = 4;
  }
  else {
    char v11 = 8;
  }
  if ((v10 & 0x400000000) != 0) {
    char v12 = 16;
  }
  else {
    char v12 = 32;
  }
  unsigned __int8 v13 = v11 | v12 | a4;
  while (1)
  {
    __int16 v14 = *(_WORD *)&v9[4 * v8];
    if ((v13 & HIBYTE(v14) & 0x3F) == a4
      && ((v14 & 0x7F) - 2) < 0x11u
      && ((0x1E1FFu >> ((v14 & 0x7F) - 2)) & 1) != 0)
    {
      break;
    }
    v8 += RB::Transition::_effect_args[v14 & 0x7F] + 1;
    if (v8 >= v7) {
      return 0;
    }
  }
  return 1;
}

void RB::Buffer::~Buffer(RB::Buffer *this)
{
  *(void *)this = &unk_26C4EDD98;
  float32x2_t v2 = (_DWORD *)*((void *)this + 3);
  if (v2)
  {
    int v3 = v2[2] - 1;
    v2[2] = v3;
    if (!v3) {
      (*(void (**)(_DWORD *))(*(void *)v2 + 8))(v2);
    }
  }
}

{
  _DWORD *v2;
  int v3;
  uint64_t vars8;

  *(void *)this = &unk_26C4EDD98;
  float32x2_t v2 = (_DWORD *)*((void *)this + 3);
  if (v2)
  {
    int v3 = v2[2] - 1;
    v2[2] = v3;
    if (!v3) {
      (*(void (**)(_DWORD *))(*(void *)v2 + 8))(v2);
    }
  }

  JUMPOUT(0x21669AC10);
}

char *RB::vector<RB::Device::FrameContinuation,2ul,unsigned long>::~vector(char *a1)
{
  float32x2_t v2 = (char *)*((void *)a1 + 6);
  if (v2) {
    int v3 = v2;
  }
  else {
    int v3 = a1;
  }
  if (*((void *)a1 + 7))
  {
    unint64_t v4 = 0;
    uint64_t v5 = (id *)(v3 + 16);
    do
    {

      ++v4;
      v5 += 3;
    }
    while (v4 < *((void *)a1 + 7));
    float32x2_t v2 = (char *)*((void *)a1 + 6);
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

void RB::Device::~Device(RB::Device *this)
{
  *(void *)this = &unk_26C4EDB10;
  dispatch_sync(*((dispatch_queue_t *)this + 5), &__block_literal_global_0);
  for (uint64_t i = (void *)*((void *)this + 48); i != (void *)((char *)this + 376); uint64_t i = (void *)i[1])
    *(void *)(i[2] + 48) = 0;
  if (*((void *)this + 121)) {
    CGGlyphLockRelease();
  }
  uint64_t v15 = this;
  RB::UntypedTable::for_each((uint64_t)this + 880, (void (*)(const void *, const void *, void *))RB::Table<RB::CustomShader::Library *,RB::FunctionLibrary *>::for_each<RB::Device::~Device()::$_0>(RB::Device::~Device()::$_0)const::{lambda(void const*,void const*,void *)#1}::__invoke, &v15);
  uint64_t v3 = *((void *)this + 122);
  *((void *)this + 122) = 0;
  if (v3) {
    std::default_delete<RB::SharedSurfaceGroup>::operator()[abi:nn180100]((uint64_t)this + 976, v3);
  }
  std::unique_ptr<RB::GlyphPathCache>::reset[abi:nn180100]((uint64_t *)this + 120, 0);
  RB::UntypedTable::~UntypedTable((RB::Device *)((char *)this + 880));
  RB::UntypedTable::~UntypedTable((RB::Device *)((char *)this + 800));
  for (uint64_t j = 792; j != 600; j -= 8)

  do
  {

    j -= 8;
  }
  while (j != 552);
  std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::~__hash_table((uint64_t)this + 512);
  RB::UntypedTable::~UntypedTable((RB::Device *)((char *)this + 432));
  std::__list_imp<RB::refcounted_ptr<RB::Texture>>::clear((uint64_t *)this + 50);
  std::__list_imp<RB::refcounted_ptr<RB::Texture>>::clear((uint64_t *)this + 47);
  std::__list_imp<RB::refcounted_ptr<RB::Texture>>::clear((uint64_t *)this + 43);
  RB::Heap::~Heap((RB::Device *)((char *)this + 304));
  uint64_t v5 = (char *)this + 200;
  int v6 = (void *)*((void *)this + 31);
  if (v6) {
    uint64_t v5 = (char *)*((void *)this + 31);
  }
  if (*((void *)this + 32))
  {
    unint64_t v7 = 0;
    unsigned int v8 = (id *)(v5 + 16);
    do
    {

      ++v7;
      v8 += 3;
    }
    while (v7 < *((void *)this + 32));
    int v6 = (void *)*((void *)this + 31);
  }
  if (v6) {
    free(v6);
  }
  float32x2_t v9 = (_DWORD *)*((void *)this + 22);
  if (v9)
  {
    int v10 = v9[2] - 1;
    v9[2] = v10;
    if (!v10) {
      (*(void (**)(_DWORD *))(*(void *)v9 + 8))(v9);
    }
  }
  char v11 = (_DWORD *)*((void *)this + 21);
  if (v11)
  {
    int v12 = v11[2] - 1;
    _OWORD v11[2] = v12;
    if (!v12) {
      (*(void (**)(_DWORD *))(*(void *)v11 + 8))(v11);
    }
  }
  unsigned __int8 v13 = (_DWORD *)*((void *)this + 20);
  if (v13)
  {
    int v14 = v13[2] - 1;
    float64x2_t v13[2] = v14;
    if (!v14) {
      (*(void (**)(_DWORD *))(*(void *)v13 + 8))(v13);
    }
  }
}

{
  uint64_t vars8;

  RB::Device::~Device(this);
  JUMPOUT(0x21669AC10);
}

void sub_2141C7278(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void *)(v1 + 976);
  *(void *)(v1 + 976) = 0;
  if (v4) {
    std::default_delete<RB::SharedSurfaceGroup>::operator()[abi:nn180100](v1 + 976, v4);
  }
  RB::Device::~Device(v1, v2);

  _Unwind_Resume(a1);
}

void *RB::Device::library_archive(void **this)
{
  if (*((unsigned char *)this + 282) && !this[7])
  {
    float32x2_t v2 = (RB::_anonymous_namespace_ *)MEMORY[0x21669B110]();

    this[7] = (void *)library_archive;
    if (!library_archive) {
      *((unsigned char *)this + 282) = 0;
    }
  }
  return this[7];
}

void sub_2141C7394(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void RB::Device::add_frame_continuation(uint64_t a1, int a2, NSObject *a3, void *a4)
{
  unsigned int v8 = (os_unfair_lock_s *)(a1 + 184);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 184));
  if (a2 - *(_DWORD *)(a1 + 192) < 1)
  {
    dispatch_async(a3, a4);
  }
  else
  {
    uint64_t v9 = a1 + 200;
    uint64_t v10 = *(void *)(a1 + 256);
    if (*(void *)(a1 + 264) < (unint64_t)(v10 + 1))
    {
      RB::vector<RB::Device::FrameContinuation,2ul,unsigned long>::reserve_slow((void *)(a1 + 200), v10 + 1);
      uint64_t v10 = *(void *)(a1 + 256);
    }
    if (*(void *)(a1 + 248)) {
      uint64_t v9 = *(void *)(a1 + 248);
    }
    uint64_t v11 = v9 + 24 * v10;
    *(_DWORD *)uint64_t v11 = a2;
    *(void *)(v11 + 8) = a3;
    *(void *)(v11 + 16) = [a4 copy];
    ++*(void *)(a1 + 256);
  }
  os_unfair_lock_unlock(v8);
}

void sub_2141C7490(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Device::alloc_shared_texture_view@<X0>(uint64_t result@<X0>, MTLPixelFormat a2@<X1>, RB *a3@<X2>, int a4@<W3>, MTLPixelFormat *a5@<X8>)
{
  MTLPixelFormat v5 = a2;
  unint64_t v7 = *(RB **)(a2 + 56);
  if (v7 == a3)
  {
LABEL_2:
    ++*(_DWORD *)(v5 + 8);
    goto LABEL_14;
  }
  uint64_t v10 = result;
  uint64_t v11 = RB::pixel_format_traits(*(void *)(a2 + 56), a2);
  if (((*v11 | ((unint64_t)*((unsigned __int16 *)v11 + 2) << 32)) & 0x40000000000) != 0)
  {
    uint64_t result = RB::Texture::has_view_usage((id *)v5);
    if (!result)
    {
LABEL_13:
      MTLPixelFormat v5 = MTLPixelFormatInvalid;
      goto LABEL_14;
    }
    unint64_t v7 = *(RB **)(v5 + 56);
  }
  uint64_t result = RB::pixel_formats_support_view_copy(v7, a3, v12);
  if (!result) {
    goto LABEL_13;
  }
  uint64_t v13 = v10 + 400;
  for (uint64_t i = *(void *)(v10 + 408); ; uint64_t i = *(void *)(i + 8))
  {
    if (i == v13)
    {
      [*(id *)(v5 + 16) newTextureViewWithPixelFormat:a3];
      operator new();
    }
    uint64_t v15 = *(void *)(i + 16);
    if (*(RB **)(v15 + 56) == a3 && *(unsigned __int8 *)(v15 + 80) == a4)
    {
      uint64_t result = [*(id *)(v15 + 16) parentTexture];
      if (result == *(void *)(v5 + 16)) {
        break;
      }
    }
  }
  MTLPixelFormat v5 = *(void *)(i + 16);
  if (v5) {
    goto LABEL_2;
  }
LABEL_14:
  *a5 = v5;
  return result;
}

void sub_2141C760C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *a9)
{
  uint64_t v10 = exception_object;
  if (*v9)
  {
    RB::TextureCache::prepare_from_cache(*v9, (uint64_t)exception_object, a2, (uint64_t)&a9);
    uint64_t v10 = a9;
  }
  _Unwind_Resume(v10);
}

void *std::list<RB::refcounted_ptr<RB::Texture>>::emplace_back<RB::refcounted_ptr<RB::Texture>&>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = operator new(0x18uLL);
  uint64_t v5 = *a2;
  if (*a2) {
    ++*(_DWORD *)(v5 + 8);
  }
  _OWORD v4[2] = v5;
  uint64_t v6 = *a1;
  void *v4 = *a1;
  v4[1] = a1;
  *(void *)(v6 + 8) = v4;
  *a1 = (uint64_t)v4;
  ++a1[2];
  return v4 + 2;
}

id RB::Device::noise_texture(RB::Device *this)
{
  id v1 = (id)*((void *)this + 19);
  if (!v1)
  {
    uint64_t v3 = (void *)[MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:80 width:32 height:32 mipmapped:0];
    [v3 setUsage:1];
    [v3 setStorageMode:0];
    uint64_t v4 = (void *)[*((id *)this + 3) newTextureWithDescriptor:v3];

    *((void *)this + 19) = v4;
    if (v4)
    {
      memset(v9, 0, sizeof(v9));
      int64x2_t v10 = vdupq_n_s64(0x20uLL);
      uint64_t v11 = 1;
      return (id)*((void *)this + 19);
    }
    else
    {
      uint64_t v6 = RB::error_log(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
        RB::Device::noise_texture(v6);
      }
      id v1 = (id)*((void *)RB::Device::invalid_texture((id *)this) + 2);
      id v7 = (id)*((void *)this + 19);
      if (v7 != v1)
      {

        id v1 = v1;
        *((void *)this + 19) = v1;
      }
    }
  }
  return v1;
}

id RB::Device::invalid_texture(id *this)
{
  if (!this[20])
  {
    uint64_t v3 = (void *)[MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:80 width:1 height:1 mipmapped:0];
    [v3 setUsage:1];
    [v3 setStorageMode:0];
    uint64_t v4 = (void *)[this[3] newTextureWithDescriptor:v3];
    int v8 = -256;
    memset(v5, 0, sizeof(v5));
    int64x2_t v6 = vdupq_n_s64(1uLL);
    uint64_t v7 = 1;
    [v4 replaceRegion:v5 mipmapLevel:0 withBytes:&v8 bytesPerRow:4];
    operator new();
  }
  return this[20];
}

void sub_2141C7908(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A1C401006C202);
  _Unwind_Resume(a1);
}

id RB::Device::clear_texture(id *this)
{
  if (!this[21])
  {
    uint64_t v3 = (void *)[MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:80 width:1 height:1 mipmapped:0];
    [v3 setUsage:1];
    [v3 setStorageMode:0];
    uint64_t v4 = (void *)[this[3] newTextureWithDescriptor:v3];
    int v8 = 0;
    memset(v5, 0, sizeof(v5));
    int64x2_t v6 = vdupq_n_s64(1uLL);
    uint64_t v7 = 1;
    [v4 replaceRegion:v5 mipmapLevel:0 withBytes:&v8 bytesPerRow:4];
    operator new();
  }
  return this[21];
}

void sub_2141C7A60(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A1C401006C202);
  _Unwind_Resume(a1);
}

uint64_t RB::Device::tables_buffer(RB::Device *this)
{
  if (!*((void *)this + 22)
    && [*((id *)this + 3) newBufferWithBytesNoCopy:RB::Shader::Tables::shared(this) length:24576 options:0 deallocator:0])
  {
    operator new();
  }
  return *((void *)this + 22);
}

void sub_2141C7B48(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A1C40C08ACA79);
  _Unwind_Resume(a1);
}

uint64_t *RB::Device::texture_cache(uint64_t a1, uint64_t a2, unsigned int a3)
{
  return RB::UntypedTable::lookup((RB::UntypedTable *)(a1 + 800), (uint64_t *)(a3 | (unint64_t)(a2 << 32)), 0);
}

uint64_t RB::Device::set_texture_cache(uint64_t a1, uint64_t a2, unsigned int a3, size_t *a4)
{
  uint64_t v4 = (size_t *)(a3 | (unint64_t)(a2 << 32));
  uint64_t v5 = (size_t **)(a1 + 800);
  if (a4) {
    return RB::UntypedTable::insert(v5, v4, a4);
  }
  else {
    return RB::UntypedTable::remove((RB::UntypedTable *)v5, v4);
  }
}

uint64_t *RB::Device::function_library(RB::Device *this, RB::CustomShader::Library *a2)
{
  uint64_t v4 = 0;
  uint64_t result = RB::UntypedTable::lookup((RB::Device *)((char *)this + 880), (uint64_t *)a2, &v4);
  if (v4 != a2) {
    operator new();
  }
  return result;
}

void sub_2141C7C84(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A0C400C0D2FE0);
  _Unwind_Resume(a1);
}

uint64_t *RB::Device::remove_function_library(RB::Device *this, RB::CustomShader::Library *a2)
{
  uint64_t v4 = (RB::Device *)((char *)this + 880);
  uint64_t result = RB::UntypedTable::lookup((RB::Device *)((char *)this + 880), (uint64_t *)a2, 0);
  if (result)
  {
    if (*((unsigned char *)result + 112))
    {
      int64x2_t v6 = *((void *)this + 5);
      block[0] = MEMORY[0x263EF8330];
      block[1] = 3221225472;
      block[2] = ___ZN2RB6Device23remove_function_libraryERNS_12CustomShader7LibraryE_block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      void block[4] = this;
      dispatch_sync(v6, block);
    }
    return (uint64_t *)RB::UntypedTable::remove(v4, a2);
  }
  return result;
}

uint64_t ___ZN2RB6Device23remove_function_libraryERNS_12CustomShader7LibraryE_block_invoke(uint64_t a1)
{
  return RB::UntypedTable::for_each(*(void *)(a1 + 32) + 432, (void (*)(const void *, const void *, void *))_ZZNK2RB5TableIPKNS_20FormattedRenderStateEPNS_6Device19RenderPipelineEntryEE8for_eachIZZNS4_23remove_function_libraryERNS_12CustomShader7LibraryEEUb_E4__10EEvT_ENUlPKvSF_PvE_8__invokeESF_SF_SG_, &v2);
}

BOOL RB::Device::should_compile_binary_functions(RB::Device *this)
{
  if (!*((unsigned char *)this + 287)) {
    return 0;
  }
  if ((int)v2 < 1) {
    return 0;
  }
    return RB::Device::library_archive((void **)this) != 0;
  return 1;
}

uint64_t RB::Device::valid_texture_size_nonnative(uint64_t a1, uint64_t a2, int32x2_t a3)
{
  if ((unint64_t)(a2 - 2147483649) <= 2)
  {
    if (3 * a3.i32[0] != 3 * a3.i32[0]) {
      return 0;
    }
    a3.i32[0] *= 3;
  }
  uint64_t v4 = (const float *)(a1 + 288);
  int32x2_t v5 = (int32x2_t)vld1_dup_f32(v4);
  uint32x2_t v6 = (uint32x2_t)vand_s8((int8x8_t)vcge_s32(v5, a3), (int8x8_t)vcgtz_s32(a3));
  return vpmin_u32(v6, v6).u32[0] >> 31;
}

void RB::Device::RenderPipelineEntry::clear_custom_functions(RB::Device::RenderPipelineEntry *this)
{
  uint64_t v4 = (void *)*((void *)this + 4);
  char v2 = (char *)this + 32;
  uint64_t v3 = v4;
  if (v4 && *v3)
  {
    uint64_t v5 = *((void *)this + 3);
    *((void *)this + 3) = *v3;
    *uint64_t v3 = v5;
    uint64_t v6 = *((void *)this + 4);
    *((void *)this + 4) = 0;
    if (v6) {
      std::default_delete<RB::Device::RenderPipelineEntry::Functions>::operator()[abi:nn180100]((uint64_t)v2, v6);
    }
  }
}

uint64_t RB::Device::glyph_path_cache(RB::Device *this)
{
  uint64_t result = *((void *)this + 120);
  if (!result) {
    operator new();
  }
  return result;
}

void sub_2141C7FC0(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A0C40197EAB39);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<RB::GlyphPathCache>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  uint64_t *result = a2;
  if (v2)
  {
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)(v2 + 8));
    JUMPOUT(0x21669AC10);
  }
  return result;
}

void RB::Device::command_buffer_error(atomic_uchar *a1, void *a2, void *a3)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  if (a2)
  {
    uint64_t v6 = RB::error_log((RB *)a1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      RB::Device::command_buffer_error(a2, v6);
      if (!a3) {
        return;
      }
    }
    else if (!a3)
    {
      return;
    }
    if ((a1[292] & 2) != 0)
    {
      uint64_t v7 = (void *)[MEMORY[0x263EFF9A0] dictionary];
      objc_msgSend(v7, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(a2, "code")), @"errorCode");
      uint64_t v8 = [a2 localizedDescription];
      if (v8) {
        [v7 setObject:v8 forKeyedSubscript:@"errorString"];
      }
      [v7 setObject:RB::Device::device_info((RB::Device *)a1) forKeyedSubscript:@"deviceInfo"];
      uint64_t v9 = (void *)[a2 userInfo];
      uint64_t v10 = [v9 objectForKeyedSubscript:*MEMORY[0x263F125E8]];
      if (v10)
      {
        uint64_t v11 = (void *)v10;
        unint64_t v21 = a3;
        MTLPixelFormat v12 = (void *)[MEMORY[0x263EFF980] array];
        long long v24 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        uint64_t v13 = [v11 countByEnumeratingWithState:&v24 objects:v29 count:16];
        if (v13)
        {
          uint64_t v14 = v13;
          uint64_t v15 = *(void *)v25;
          do
          {
            for (uint64_t i = 0; i != v14; ++i)
            {
              if (*(void *)v25 != v15) {
                objc_enumerationMutation(v11);
              }
              char v17 = *(void **)(*((void *)&v24 + 1) + 8 * i);
              float v18 = (void *)[MEMORY[0x263EFF9A0] dictionary];
              objc_msgSend(v18, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(v17, "errorState")), @"errorState");
              uint64_t v19 = [v17 label];
              if (v19) {
                [v18 setObject:v19 forKeyedSubscript:@"label"];
              }
              uint64_t v20 = [v17 debugSignposts];
              if (v20) {
                [v18 setObject:v20 forKeyedSubscript:@"signposts"];
              }
              [v12 addObject:v18];
            }
            uint64_t v14 = [v11 countByEnumeratingWithState:&v24 objects:v29 count:16];
          }
          while (v14);
        }
        [v7 setObject:v12 forKeyedSubscript:@"encoders"];
        a3 = v21;
      }
      time_t v23 = time(0);
      localtime_r(&v23, &v22);
      if (!strftime(v28, 0x100uLL, "RBDeviceError-%F-%H%M%S.rbar", &v22)) {
        snprintf_l(v28, 0x100uLL, 0, "RBDeviceError-%ld.rbar", v23);
      }
      RBArchiveToFileWithMetadata(a3, [MEMORY[0x263F08900] dataWithJSONObject:v7 options:0 error:0], v28, 1);
      atomic_fetch_and_explicit(a1 + 292, 0xFDu, memory_order_relaxed);
    }
  }
}

uint64_t RB::Device::device_info(RB::Device *this)
{
  _DWORD v7[9] = *MEMORY[0x263EF8340];
  uint64_t v2 = (void *)*((void *)this + 3);
  v6[0] = @"name";
  v7[0] = [v2 name];
  v6[1] = @"featureProfile";
  v7[1] = objc_msgSend(NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v2, "featureProfile"));
  int32x2_t v6[2] = @"bufferSize";
  float64x2_t v7[2] = [NSNumber numberWithUnsignedLong:*((void *)this + 34)];
  void v6[3] = @"useBinaryArchive";
  void v7[3] = [NSNumber numberWithBool:*((unsigned __int8 *)this + 282)];
  Point v6[4] = @"isAGX";
  Point v7[4] = [NSNumber numberWithBool:*((unsigned char *)this + 283) != 0];
  v6[5] = @"hasXR10Formats";
  v7[5] = [NSNumber numberWithBool:*((unsigned __int8 *)this + 283) > 2u];
  v6[6] = @"hasYCbCrFormats";
  v7[6] = [NSNumber numberWithBool:*((unsigned __int8 *)this + 283) > 2u];
  v6[7] = @"hasFBRead";
  float64x2_t v7[7] = [NSNumber numberWithBool:1];
  v6[8] = @"limits";
  v4[0] = @"GPUFamilyApple";
  v5[0] = [NSNumber numberWithUnsignedChar:*((unsigned __int8 *)this + 283)];
  v4[1] = @"GPUFamilyMac";
  v5[1] = [NSNumber numberWithUnsignedInt:0];
  _OWORD v4[2] = @"GPUFamilyCommon1";
  void v5[2] = objc_msgSend(NSNumber, "numberWithBool:", objc_msgSend(v2, "supportsFamily:", 3001));
  v4[3] = @"GPUFamilyCommon2";
  void v5[3] = objc_msgSend(NSNumber, "numberWithBool:", objc_msgSend(v2, "supportsFamily:", 3002));
  v4[4] = @"GPUFamilyCommon3";
  void v5[4] = objc_msgSend(NSNumber, "numberWithBool:", objc_msgSend(v2, "supportsFamily:", 3003));
  v4[5] = @"readWriteTextureSupport";
  v5[5] = objc_msgSend(NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v2, "readWriteTextureSupport"));
  v7[8] = [NSDictionary dictionaryWithObjects:v5 forKeys:v4 count:6];
  return [NSDictionary dictionaryWithObjects:v7 forKeys:v6 count:9];
}

atomic_uint *RB::Refcount<RB::Device,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::Refcount<RB::Device,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_2::__invoke<RB::Device::RenderPipelineEntry *>(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v4 = *(void *)(result + 32);
    uint64_t v2 = (void *)(result + 32);
    uint64_t v3 = v4;
    *uint64_t v2 = 0;
    if (v4) {
      std::default_delete<RB::Device::RenderPipelineEntry::Functions>::operator()[abi:nn180100]((uint64_t)v2, v3);
    }

    uint64_t v6 = *(void *)(v1 + 16);
    *(void *)(v1 + 16) = 0;
    if (v6) {
      RB::Device::RenderPipelineEntry::DeleteLoader::operator()(v5, v6);
    }
    JUMPOUT(0x21669AC10);
  }
  return result;
}

id *RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_3::__invoke<RB::TextureCache *>(id *result)
{
  if (result)
  {
    RB::TextureCache::~TextureCache(result);
    JUMPOUT(0x21669AC10);
  }
  return result;
}

void RB::TextureCache::~TextureCache(id *location)
{
  uint64_t v2 = location + 8;
  uint64_t v3 = (id *)location[9];
  if (v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = v2;
  }
  if (*((_DWORD *)location + 20))
  {
    unint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4[v5];
      if (v6)
      {
        int v7 = v6[2] - 1;
        int32x2_t v6[2] = v7;
        if (!v7) {
          (*(void (**)(_DWORD *))(*(void *)v6 + 8))(v6);
        }
      }
      ++v5;
    }
    while (v5 < *((unsigned int *)location + 20));
    uint64_t v3 = (id *)location[9];
  }
  if (v3) {
    free(v3);
  }
  uint64_t v8 = location + 4;
  id v9 = location[6];
  if (v9) {
    uint64_t v8 = (id *)location[6];
  }
  if (*((_DWORD *)location + 14))
  {
    unint64_t v10 = 0;
    uint64_t v11 = (_DWORD **)(v8 + 1);
    do
    {
      MTLPixelFormat v12 = *v11;
      if (*v11)
      {
        int v13 = v12[2] - 1;
        v12[2] = v13;
        if (!v13) {
          (*(void (**)(_DWORD *))(*(void *)v12 + 8))(v12);
        }
      }
      ++v10;
      v11 += 2;
    }
    while (v10 < *((unsigned int *)location + 14));
    id v9 = location[6];
  }
  if (v9) {
    free(v9);
  }
  id v14 = location[3];
  if (v14) {
    CFRelease(v14);
  }
  objc_destroyWeak(location);
}

uint64_t RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_4::__invoke(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)(result + 32));

    JUMPOUT(0x21669AC10);
  }
  return result;
}

void std::__list_imp<RB::refcounted_ptr<RB::Texture>>::clear(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v3 = *a1;
    uint64_t v2 = (uint64_t *)a1[1];
    uint64_t v4 = *v2;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v3 + 8) = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        unint64_t v5 = (uint64_t *)v2[1];
        std::__list_imp<RB::refcounted_ptr<RB::Texture>>::__delete_node[abi:nn180100]<>((int)a1, v2);
        uint64_t v2 = v5;
      }
      while (v5 != a1);
    }
  }
}

void RB::Device::function_library(RB::CustomShader::Library &)::$_0::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(NSObject **)(a2 + 32);
  v3[0] = MEMORY[0x263EF8330];
  v3[1] = 3221225472;
  v3[2] = ___ZZN2RB6Device16function_libraryERNS_12CustomShader7LibraryEENK3__0clES3_Pv_block_invoke;
  v3[3] = &__block_descriptor_48_e5_v8__0l;
  v3[4] = a2;
  v3[5] = a1;
  dispatch_sync(v2, v3);
}

uint64_t *___ZZN2RB6Device16function_libraryERNS_12CustomShader7LibraryEENK3__0clES3_Pv_block_invoke(uint64_t a1)
{
  return RB::Device::remove_function_library(*(RB::Device **)(a1 + 32), *(RB::CustomShader::Library **)(a1 + 40));
}

uint64_t _ZZN2RB14GlyphPathCacheC1EvENUlT_E_8__invokeIPKNS_21GlyphPathCacheDetails8GlyphKeyEEEDaS1_(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t _ZZN2RB14GlyphPathCacheC1EvENUlT_T0_E_8__invokeIPKNS_21GlyphPathCacheDetails8GlyphKeyES8_EEDaS1_S2_(float32x2_t *a1, float32x2_t *a2)
{
  if (a1->i32[0] != a2->i32[0]
    || a1[2].u16[1] != a2[2].u16[1]
    || a1->f32[1] != a2->f32[1]
    || a1[2].u8[0] != a2[2].u8[0])
  {
    return 0;
  }
  uint32x2_t v2 = (uint32x2_t)vceq_f32(a1[1], a2[1]);
  return vpmin_u32(v2, v2).u32[0] >> 31;
}

uint64_t _ZZN2RB14GlyphPathCacheC1EvENUlT_E0_8__invokeIPNS0_4PathEEEDaS1_(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void **)(result + 48);
    if (v1) {
      free(v1);
    }
    JUMPOUT(0x21669AC10);
  }
  return result;
}

void std::default_delete<RB::SharedSurfaceGroup>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    std::__list_imp<RB::refcounted_ptr<RB::SharedSurface>>::clear((uint64_t *)(a2 + 24));
    uint64_t v3 = *(atomic_uint **)(a2 + 8);
    if (v3 && atomic_fetch_add_explicit(v3 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v3 + 8))(v3);
    }
    JUMPOUT(0x21669AC10);
  }
}

void std::__list_imp<RB::refcounted_ptr<RB::SharedSurface>>::clear(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v3 = *a1;
    uint32x2_t v2 = (uint64_t *)a1[1];
    uint64_t v4 = *v2;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v3 + 8) = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        unint64_t v5 = (uint64_t *)v2[1];
        std::__list_imp<RB::refcounted_ptr<RB::SharedSurface>>::__delete_node[abi:nn180100]<>((int)a1, v2);
        uint32x2_t v2 = v5;
      }
      while (v5 != a1);
    }
  }
}

void std::__list_imp<RB::refcounted_ptr<RB::SharedSurface>>::__delete_node[abi:nn180100]<>(int a1, void *__p)
{
  uint64_t v3 = (atomic_uint *)__p[2];
  if (v3 && atomic_fetch_add_explicit(v3 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v3 + 8))(v3);
  }
  operator delete(__p);
}

void RB::Table<RB::CustomShader::Library *,RB::FunctionLibrary *>::for_each<RB::Device::~Device()::$_0>(RB::Device::~Device()::$_0)const::{lambda(void const*,void const*,void *)#1}::__invoke(os_unfair_lock_s *a1, uint64_t a2, void **a3)
{
}

void *RB::vector<RB::Device::FrameContinuation,2ul,unsigned long>::reserve_slow(void *__dst, unint64_t a2)
{
  if (*((void *)__dst + 8) + (*((void *)__dst + 8) >> 1) <= a2) {
    unint64_t v3 = a2;
  }
  else {
    unint64_t v3 = *((void *)__dst + 8) + (*((void *)__dst + 8) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned long,24ul>(*((void **)__dst + 6), __dst, 2uLL, (unint64_t *)__dst + 8, v3);
  *((void *)__dst + 6) = result;
  return result;
}

void _ZZNK2RB5TableIPKNS_20FormattedRenderStateEPNS_6Device19RenderPipelineEntryEE8for_eachIZZNS4_23remove_function_libraryERNS_12CustomShader7LibraryEEUb_E4__10EEvT_ENUlPKvSF_PvE_8__invokeESF_SF_SG_(int a1, RB::Device::RenderPipelineEntry *this)
{
}

BOOL RB::Table<unsigned long,RB::TextureCache *>::remove_if<RB::Device::prune_caches(void)::$_0>(RB::Device::prune_caches(void)::$_0)::{lambda(void const*,void const*,void *)#1}::__invoke(int a1, RB::TextureCache *this, uint64_t a3)
{
  return RB::TextureCache::prune_caches(this, *(_DWORD *)a3, *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), *(_DWORD *)(a3 + 12));
}

uint64_t RB::Table<RB::CustomShader::Library *,RB::FunctionLibrary *>::remove_if<RB::Device::prune_caches(void)::$_3>(RB::Device::prune_caches(void)::$_3)::{lambda(void const*,void const*,void *)#1}::__invoke(int a1, RB::FunctionLibrary *this, int *a3)
{
  if (!this) {
    return 0;
  }
  if (!*((unsigned char *)this + 112) && *((_DWORD *)this + 6) <= *a3) {
    return 1;
  }
  RB::FunctionLibrary::prune_caches(this, *a3);
  return 0;
}

void *RB::vector<RB::FormattedRenderState,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned long,12ul>(*(void **)a1, (unint64_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,12ul>(void *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(12 * a3);
    unint64_t v6 = v5 / 0xC;
    if (v5 / 0xC != *a2)
    {
      int v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      uint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void *std::get_temporary_buffer[abi:nn180100]<RB::FormattedRenderState>(uint64_t a1)
{
  if (a1 < 1) {
    return 0;
  }
  if (a1 >= 0xAAAAAAAAAAAAAAALL) {
    unint64_t v1 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v1 = a1;
  }
  uint32x2_t v2 = (const std::nothrow_t *)MEMORY[0x263F8C180];
  while (1)
  {
    uint64_t result = operator new(12 * v1, v2);
    if (result) {
      break;
    }
    BOOL v4 = v1 > 1;
    v1 >>= 1;
    if (!v4) {
      return 0;
    }
  }
  return result;
}

uint64_t std::__stable_sort<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(uint64_t result, char *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v73 = *MEMORY[0x263EF8340];
  if (a3 < 2) {
    return result;
  }
  uint64_t v6 = result;
  if (a3 == 2)
  {
    uint64_t v7 = 0;
    id v9 = a2 - 12;
    uint64_t v8 = *(void *)(a2 - 12);
    int v10 = *((_DWORD *)a2 - 1);
    uint64_t v11 = *(void *)result;
    int v12 = *(_DWORD *)(result + 8);
    uint64_t v71 = v8;
    int v72 = v10;
    uint64_t v69 = v11;
    int v70 = v12;
    while (1)
    {
      unsigned int v13 = *((unsigned __int8 *)&v71 + v7);
      unsigned int v14 = *((unsigned __int8 *)&v69 + v7);
      if (v13 != v14) {
        break;
      }
      if (++v7 == 12) {
        goto LABEL_40;
      }
    }
    if (v13 < v14)
    {
LABEL_49:
      int v43 = *(_DWORD *)(result + 8);
      uint64_t v44 = *(void *)result;
      int v45 = *((_DWORD *)a2 - 1);
      *(void *)uint64_t result = *(void *)v9;
      *(_DWORD *)(result + 8) = v45;
      *(void *)id v9 = v44;
      *((_DWORD *)a2 - 1) = v43;
      return result;
    }
LABEL_40:
    uint64_t v35 = 0;
    uint64_t v67 = v8;
    int v68 = v10;
    uint64_t v65 = v11;
    int v66 = v12;
    while (1)
    {
      unsigned int v36 = *((unsigned __int8 *)&v67 + v35);
      unsigned int v37 = *((unsigned __int8 *)&v65 + v35);
      if (v36 != v37) {
        break;
      }
      if (++v35 == 12) {
        return result;
      }
    }
    if (v36 >= v37) {
      goto LABEL_49;
    }
  }
  else if ((uint64_t)a3 > 128)
  {
    int8x8_t v39 = (unsigned int *)a4;
    unint64_t v40 = a3 >> 1;
    uint64_t v41 = result + 12 * (a3 >> 1);
    unint64_t v42 = a3 >> 1;
    if ((uint64_t)a3 <= a5)
    {
      std::__stable_sort_move<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(result, v41, v42, a4);
      uint64_t v46 = (uint64_t)&v39[3 * v40];
      uint64_t result = std::__stable_sort_move<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(v6 + 12 * (a3 >> 1), (uint64_t)a2, a3 - (a3 >> 1), v46);
      int v47 = &v39[3 * a3];
      uint64_t v48 = v46;
      while ((unsigned int *)v48 != v47)
      {
        uint64_t result = 0;
        uint64_t v49 = *(void *)v48;
        int v50 = *(_DWORD *)(v48 + 8);
        uint64_t v51 = *(void *)v39;
        unsigned int v52 = v39[2];
        uint64_t v71 = *(void *)v48;
        int v72 = v50;
        uint64_t v69 = v51;
        int v70 = v52;
        while (1)
        {
          unsigned int v53 = *((unsigned __int8 *)&v71 + result);
          unsigned int v54 = *((unsigned __int8 *)&v69 + result);
          if (v53 != v54) {
            break;
          }
          if (++result == 12) {
            goto LABEL_57;
          }
        }
        if (v53 < v54)
        {
LABEL_63:
          uint64_t v58 = *(void *)v48;
          *(_DWORD *)(v6 + 8) = *(_DWORD *)(v48 + 8);
          *(void *)uint64_t v6 = v58;
          v48 += 12;
          goto LABEL_64;
        }
LABEL_57:
        uint64_t result = 0;
        uint64_t v67 = v49;
        int v68 = v50;
        uint64_t v65 = v51;
        int v66 = v52;
        while (1)
        {
          unsigned int v55 = *((unsigned __int8 *)&v67 + result);
          unsigned int v56 = *((unsigned __int8 *)&v65 + result);
          if (v55 != v56) {
            break;
          }
          if (++result == 12) {
            goto LABEL_62;
          }
        }
        if (v55 >= v56) {
          goto LABEL_63;
        }
LABEL_62:
        uint64_t v57 = *(void *)v39;
        *(_DWORD *)(v6 + 8) = v39[2];
        *(void *)uint64_t v6 = v57;
        v39 += 3;
LABEL_64:
        v6 += 12;
        if (v39 == (unsigned int *)v46)
        {
          if ((unsigned int *)v48 != v47)
          {
            uint64_t v59 = 0;
            do
            {
              uint64_t v60 = v6 + v59;
              uint64_t v61 = *(void *)(v48 + v59);
              *(_DWORD *)(v60 + 8) = *(_DWORD *)(v48 + v59 + 8);
              *(void *)uint64_t v60 = v61;
              v59 += 12;
            }
            while ((unsigned int *)(v48 + v59) != v47);
          }
          return result;
        }
      }
      if (v39 != (unsigned int *)v46)
      {
        uint64_t v62 = 0;
        do
        {
          uint64_t v63 = v6 + v62 * 4;
          uint64_t v64 = *(void *)&v39[v62];
          *(_DWORD *)(v63 + 8) = v39[v62 + 2];
          *(void *)uint64_t v63 = v64;
          v62 += 3;
        }
        while (&v39[v62] != (unsigned int *)v46);
      }
    }
    else
    {
      std::__stable_sort<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(result, v41, v42, a4, a5);
      std::__stable_sort<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(v6 + 12 * (a3 >> 1), a2, a3 - (a3 >> 1), v39, a5);
      return std::__inplace_merge<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(v6, (char *)(v6 + 12 * (a3 >> 1)), a2, a3 >> 1, a3 - (a3 >> 1), v39, a5);
    }
  }
  else if ((char *)result != a2)
  {
    uint64_t v16 = result + 12;
    if ((char *)(result + 12) != a2)
    {
      uint64_t v17 = result;
      while (1)
      {
        uint64_t result = 0;
        uint64_t v18 = v17;
        uint64_t v17 = v16;
        uint64_t v19 = *(void *)(v18 + 12);
        int v20 = *(_DWORD *)(v18 + 20);
        uint64_t v21 = *(void *)v18;
        int v22 = *(_DWORD *)(v18 + 8);
        uint64_t v71 = v19;
        int v72 = v20;
        uint64_t v69 = v21;
        int v70 = v22;
        while (1)
        {
          unsigned int v23 = *((unsigned __int8 *)&v71 + result);
          unsigned int v24 = *((unsigned __int8 *)&v69 + result);
          if (v23 != v24) {
            break;
          }
          if (++result == 12) {
            goto LABEL_17;
          }
        }
        if (v23 < v24) {
          break;
        }
LABEL_17:
        uint64_t result = 0;
        uint64_t v67 = v19;
        int v68 = v20;
        uint64_t v65 = v21;
        int v66 = v22;
        while (1)
        {
          unsigned int v25 = *((unsigned __int8 *)&v67 + result);
          unsigned int v26 = *((unsigned __int8 *)&v65 + result);
          if (v25 != v26) {
            break;
          }
          if (++result == 12) {
            goto LABEL_37;
          }
        }
        if (v25 >= v26) {
          break;
        }
LABEL_37:
        uint64_t v16 = v17 + 12;
        if ((char *)(v17 + 12) == a2) {
          return result;
        }
      }
      uint64_t v27 = v17;
      while (1)
      {
        uint64_t v28 = v27;
        uint64_t v27 = v18;
        *(void *)uint64_t v28 = *(void *)v18;
        *(_DWORD *)(v28 + 8) = *(_DWORD *)(v18 + 8);
        if (v18 == v6) {
          break;
        }
        uint64_t v29 = 0;
        v18 -= 12;
        uint64_t v30 = *(void *)(v27 - 12);
        uint64_t result = *(unsigned int *)(v27 - 4);
        uint64_t v71 = v19;
        int v72 = v20;
        uint64_t v69 = v30;
        int v70 = result;
        while (1)
        {
          unsigned int v31 = *((unsigned __int8 *)&v71 + v29);
          unsigned int v32 = *((unsigned __int8 *)&v69 + v29);
          if (v31 != v32) {
            break;
          }
          if (++v29 == 12) {
            goto LABEL_29;
          }
        }
        if (v31 < v32) {
          continue;
        }
LABEL_29:
        uint64_t v33 = 0;
        uint64_t v67 = v19;
        int v68 = v20;
        uint64_t v65 = v30;
        int v66 = result;
        while (1)
        {
          unsigned int v34 = *((unsigned __int8 *)&v67 + v33);
          uint64_t result = *((unsigned __int8 *)&v65 + v33);
          if (v34 != result) {
            break;
          }
          if (++v33 == 12) {
            goto LABEL_36;
          }
        }
        if (v34 < result) {
          goto LABEL_36;
        }
      }
      uint64_t v27 = v6;
LABEL_36:
      *(void *)uint64_t v27 = v19;
      *(_DWORD *)(v27 + 8) = v20;
      goto LABEL_37;
    }
  }
  return result;
}

uint64_t std::__stable_sort_move<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v78 = *MEMORY[0x263EF8340];
  if (a3)
  {
    uint64_t v4 = a4;
    uint64_t v7 = result;
    if (a3 == 2)
    {
      uint64_t v9 = 0;
      uint64_t v11 = (uint64_t *)(a2 - 12);
      uint64_t v10 = *(void *)(a2 - 12);
      int v12 = *(_DWORD *)(a2 - 4);
      uint64_t v13 = *(void *)result;
      int v14 = *(_DWORD *)(result + 8);
      uint64_t v76 = v10;
      int v77 = v12;
      uint64_t v74 = v13;
      int v75 = v14;
      while (1)
      {
        unsigned int v15 = *((unsigned __int8 *)&v76 + v9);
        unsigned int v16 = *((unsigned __int8 *)&v74 + v9);
        if (v15 != v16) {
          break;
        }
        if (++v9 == 12) {
          goto LABEL_40;
        }
      }
      if (v15 < v16)
      {
LABEL_65:
        uint64_t v66 = *v11;
        *(_DWORD *)(a4 + 8) = *(_DWORD *)(a2 - 4);
        *(void *)a4 = v66;
        uint64_t v64 = *(void *)result;
        int v65 = *(_DWORD *)(result + 8);
        goto LABEL_66;
      }
LABEL_40:
      uint64_t v44 = 0;
      uint64_t v72 = v10;
      int v73 = v12;
      uint64_t v70 = v13;
      int v71 = v14;
      while (1)
      {
        unsigned int v45 = *((unsigned __int8 *)&v72 + v44);
        unsigned int v46 = *((unsigned __int8 *)&v70 + v44);
        if (v45 != v46) {
          break;
        }
        if (++v44 == 12) {
          goto LABEL_64;
        }
      }
      if (v45 >= v46) {
        goto LABEL_65;
      }
LABEL_64:
      uint64_t v63 = *(void *)result;
      *(_DWORD *)(a4 + 8) = *(_DWORD *)(result + 8);
      *(void *)a4 = v63;
      uint64_t v64 = *v11;
      int v65 = *(_DWORD *)(a2 - 4);
LABEL_66:
      *(_DWORD *)(a4 + 20) = v65;
      *(void *)(a4 + 12) = v64;
    }
    else if (a3 == 1)
    {
      uint64_t v8 = *(void *)result;
      *(_DWORD *)(a4 + 8) = *(_DWORD *)(result + 8);
      *(void *)a4 = v8;
    }
    else if ((uint64_t)a3 > 8)
    {
      unint64_t v47 = result + 12 * (a3 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(result, v47, a3 >> 1, a4, a3 >> 1);
      uint64_t result = std::__stable_sort<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(v7 + 12 * (a3 >> 1), a2, a3 - (a3 >> 1), v4 + 12 * (a3 >> 1), a3 - (a3 >> 1));
      unint64_t v48 = v7 + 12 * (a3 >> 1);
      while (v48 != a2)
      {
        uint64_t v49 = 0;
        uint64_t v50 = *(void *)v48;
        int v51 = *(_DWORD *)(v48 + 8);
        uint64_t v52 = *(void *)v7;
        int v53 = *(_DWORD *)(v7 + 8);
        uint64_t v76 = *(void *)v48;
        int v77 = v51;
        uint64_t v74 = v52;
        int v75 = v53;
        while (1)
        {
          uint64_t result = *((unsigned __int8 *)&v76 + v49);
          unsigned int v54 = *((unsigned __int8 *)&v74 + v49);
          if (result != v54) {
            break;
          }
          if (++v49 == 12) {
            goto LABEL_51;
          }
        }
        if (result < v54)
        {
LABEL_57:
          uint64_t v59 = *(void *)v48;
          *(_DWORD *)(v4 + 8) = *(_DWORD *)(v48 + 8);
          *(void *)uint64_t v4 = v59;
          v48 += 12;
          goto LABEL_58;
        }
LABEL_51:
        uint64_t v55 = 0;
        uint64_t v72 = v50;
        int v73 = v51;
        uint64_t v70 = v52;
        int v71 = v53;
        while (1)
        {
          unsigned int v56 = *((unsigned __int8 *)&v72 + v55);
          unsigned int v57 = *((unsigned __int8 *)&v70 + v55);
          if (v56 != v57) {
            break;
          }
          if (++v55 == 12) {
            goto LABEL_56;
          }
        }
        if (v56 >= v57) {
          goto LABEL_57;
        }
LABEL_56:
        uint64_t v58 = *(void *)v7;
        *(_DWORD *)(v4 + 8) = *(_DWORD *)(v7 + 8);
        *(void *)uint64_t v4 = v58;
        v7 += 12;
LABEL_58:
        v4 += 12;
        if (v7 == v47)
        {
          if (v48 != a2)
          {
            uint64_t v60 = 0;
            do
            {
              uint64_t v61 = v4 + v60;
              uint64_t v62 = *(void *)(v48 + v60);
              *(_DWORD *)(v61 + 8) = *(_DWORD *)(v48 + v60 + 8);
              *(void *)uint64_t v61 = v62;
              v60 += 12;
            }
            while (v48 + v60 != a2);
          }
          return result;
        }
      }
      if (v7 != v47)
      {
        uint64_t v67 = 0;
        do
        {
          uint64_t v68 = v4 + v67;
          uint64_t v69 = *(void *)(v7 + v67);
          *(_DWORD *)(v68 + 8) = *(_DWORD *)(v7 + v67 + 8);
          *(void *)uint64_t v68 = v69;
          v67 += 12;
        }
        while (v7 + v67 != v47);
      }
    }
    else if (result != a2)
    {
      uint64_t v17 = *(void *)result;
      *(_DWORD *)(a4 + 8) = *(_DWORD *)(result + 8);
      *(void *)a4 = v17;
      uint64_t v18 = result + 12;
      if (result + 12 != a2)
      {
        uint64_t v19 = a4;
        while (1)
        {
          uint64_t v20 = 0;
          uint64_t v21 = v7;
          uint64_t v22 = v19;
          uint64_t v7 = v18;
          v19 += 12;
          uint64_t v23 = *(void *)(v21 + 12);
          int v24 = *(_DWORD *)(v21 + 20);
          uint64_t result = *(void *)v22;
          int v25 = *(_DWORD *)(v22 + 8);
          uint64_t v76 = v23;
          int v77 = v24;
          uint64_t v74 = result;
          int v75 = v25;
          while (1)
          {
            unsigned int v26 = *((unsigned __int8 *)&v76 + v20);
            unsigned int v27 = *((unsigned __int8 *)&v74 + v20);
            if (v26 != v27) {
              break;
            }
            if (++v20 == 12) {
              goto LABEL_18;
            }
          }
          if (v26 < v27) {
            break;
          }
LABEL_18:
          uint64_t v28 = 0;
          uint64_t v72 = v23;
          int v73 = v24;
          uint64_t v70 = result;
          int v71 = v25;
          while (1)
          {
            unsigned int v29 = *((unsigned __int8 *)&v72 + v28);
            unsigned int v30 = *((unsigned __int8 *)&v70 + v28);
            BOOL v31 = v29 >= v30;
            if (v29 != v30) {
              break;
            }
            if (++v28 == 12)
            {
              uint64_t v32 = v19;
              goto LABEL_37;
            }
          }
          uint64_t v32 = v19;
          if (v31) {
            break;
          }
LABEL_37:
          uint64_t v43 = *(void *)v7;
          *(_DWORD *)(v32 + 8) = *(_DWORD *)(v7 + 8);
          *(void *)uint64_t v32 = v43;
          uint64_t v18 = v7 + 12;
          if (v7 + 12 == a2) {
            return result;
          }
        }
        *(void *)uint64_t v19 = *(void *)v22;
        *(_DWORD *)(v19 + 8) = *(_DWORD *)(v22 + 8);
        uint64_t v32 = v4;
        if (v22 != v4)
        {
          while (2)
          {
            uint64_t v33 = 0;
            uint64_t v32 = v22;
            uint64_t v34 = *(void *)v7;
            uint64_t v36 = *(void *)(v22 - 12);
            v22 -= 12;
            uint64_t v35 = v36;
            uint64_t result = *(unsigned int *)(v21 + 20);
            int v37 = *(_DWORD *)(v22 + 8);
            uint64_t v76 = *(void *)v7;
            int v77 = result;
            uint64_t v74 = v36;
            int v75 = v37;
            while (1)
            {
              unsigned int v38 = *((unsigned __int8 *)&v76 + v33);
              unsigned int v39 = *((unsigned __int8 *)&v74 + v33);
              if (v38 != v39) {
                break;
              }
              if (++v33 == 12) {
                goto LABEL_30;
              }
            }
            if (v38 < v39) {
              goto LABEL_35;
            }
LABEL_30:
            uint64_t v40 = 0;
            uint64_t v72 = v34;
            int v73 = result;
            uint64_t v70 = v35;
            int v71 = v37;
            while (1)
            {
              unsigned int v41 = *((unsigned __int8 *)&v72 + v40);
              unsigned int v42 = *((unsigned __int8 *)&v70 + v40);
              if (v41 != v42) {
                break;
              }
              if (++v40 == 12) {
                goto LABEL_37;
              }
            }
            if (v41 < v42) {
              goto LABEL_37;
            }
LABEL_35:
            *(void *)uint64_t v32 = *(void *)v22;
            *(_DWORD *)(v32 + 8) = *(_DWORD *)(v22 + 8);
            if (v22 != v4) {
              continue;
            }
            break;
          }
          uint64_t v32 = v4;
        }
        goto LABEL_37;
      }
    }
  }
  return result;
}

uint64_t std::__inplace_merge<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(uint64_t result, char *a2, char *a3, uint64_t a4, uint64_t a5, unsigned int *a6, uint64_t a7)
{
  uint64_t v113 = *MEMORY[0x263EF8340];
  if (a5)
  {
    uint64_t v8 = a5;
    uint64_t v11 = (char *)result;
    uint64_t result = 12;
    while (2)
    {
      if (v8 <= a7 || a4 <= a7)
      {
        if (a4 <= v8)
        {
          if (v11 != a2)
          {
            unint64_t v80 = 0;
            do
            {
              int32x4_t v81 = (char *)&a6[v80 / 4];
              uint64_t v82 = *(void *)&v11[v80];
              *((_DWORD *)v81 + 2) = *(_DWORD *)&v11[v80 + 8];
              *(void *)int32x4_t v81 = v82;
              v80 += 12;
            }
            while (&v11[v80] != a2);
            if (v80)
            {
              uint64_t v83 = a6;
              while (a2 != a3)
              {
                uint64_t v84 = 0;
                uint64_t v85 = *(void *)a2;
                int v86 = *((_DWORD *)a2 + 2);
                uint64_t v87 = *(void *)v83;
                uint64_t result = v83[2];
                uint64_t v111 = *(void *)a2;
                int v112 = v86;
                uint64_t v109 = v87;
                int v110 = result;
                while (1)
                {
                  unsigned int v88 = *((unsigned __int8 *)&v111 + v84);
                  unsigned int v89 = *((unsigned __int8 *)&v109 + v84);
                  if (v88 != v89) {
                    break;
                  }
                  if (++v84 == 12) {
                    goto LABEL_97;
                  }
                }
                if (v88 < v89)
                {
LABEL_103:
                  uint64_t v94 = *(void *)a2;
                  *((_DWORD *)v11 + 2) = *((_DWORD *)a2 + 2);
                  *(void *)uint64_t v11 = v94;
                  a2 += 12;
                  goto LABEL_104;
                }
LABEL_97:
                uint64_t v90 = 0;
                uint64_t v107 = v85;
                int v108 = v86;
                uint64_t v105 = v87;
                int v106 = result;
                while (1)
                {
                  unsigned int v91 = *((unsigned __int8 *)&v107 + v90);
                  unsigned int v92 = *((unsigned __int8 *)&v105 + v90);
                  if (v91 != v92) {
                    break;
                  }
                  if (++v90 == 12) {
                    goto LABEL_102;
                  }
                }
                if (v91 >= v92) {
                  goto LABEL_103;
                }
LABEL_102:
                uint64_t v93 = *(void *)v83;
                *((_DWORD *)v11 + 2) = v83[2];
                *(void *)uint64_t v11 = v93;
                v83 += 3;
LABEL_104:
                v11 += 12;
                if (&a6[v80 / 4] == v83) {
                  return result;
                }
              }
              return (uint64_t)memmove(v11, v83, (char *)a6 - (char *)v83 + v80);
            }
          }
        }
        else if (a2 != a3)
        {
          unint64_t v64 = 0;
          do
          {
            int v65 = (char *)&a6[v64 / 4];
            uint64_t v66 = *(void *)&a2[v64];
            *((_DWORD *)v65 + 2) = *(_DWORD *)&a2[v64 + 8];
            *(void *)int v65 = v66;
            v64 += 12;
          }
          while (&a2[v64] != a3);
          if (v64)
          {
            uint64_t v67 = &a6[v64 / 4];
            while (a2 != v11)
            {
              uint64_t v68 = 0;
              uint64_t v69 = a2 - 12;
              uint64_t v70 = *(void *)(a2 - 12);
              uint64_t v71 = *(void *)(v67 - 3);
              int v72 = *(v67 - 1);
              int v73 = *((_DWORD *)a2 - 1);
              uint64_t v111 = v71;
              int v112 = v72;
              uint64_t v109 = v70;
              int v110 = v73;
              while (1)
              {
                unsigned int v74 = *((unsigned __int8 *)&v111 + v68);
                unsigned int v75 = *((unsigned __int8 *)&v109 + v68);
                if (v74 != v75) {
                  break;
                }
                if (++v68 == 12) {
                  goto LABEL_78;
                }
              }
              if (v74 < v75)
              {
                uint64_t result = (uint64_t)(a2 - 12);
                goto LABEL_84;
              }
LABEL_78:
              uint64_t v76 = 0;
              uint64_t v107 = v71;
              int v108 = v72;
              uint64_t v105 = v70;
              int v106 = v73;
              while (1)
              {
                unsigned int v77 = *((unsigned __int8 *)&v107 + v76);
                unsigned int v78 = *((unsigned __int8 *)&v105 + v76);
                if (v77 != v78) {
                  break;
                }
                if (++v76 == 12) {
                  goto LABEL_83;
                }
              }
              uint64_t result = (uint64_t)(a2 - 12);
              if (v77 >= v78) {
                goto LABEL_84;
              }
LABEL_83:
              uint64_t v69 = (char *)(v67 - 3);
              uint64_t result = (uint64_t)a2;
              v67 -= 3;
LABEL_84:
              int v79 = *((_DWORD *)v69 + 2);
              *(void *)(a3 - 12) = *(void *)v69;
              a3 -= 12;
              *((_DWORD *)a3 + 2) = v79;
              a2 = (char *)result;
              if (v67 == a6) {
                return result;
              }
            }
            uint64_t v98 = 0;
            do
            {
              float32x2_t v99 = &a3[v98 * 4];
              uint64_t v100 = *(void *)&v67[v98 - 3];
              *((_DWORD *)v99 - 1) = v67[v98 - 1];
              *(void *)(v99 - 12) = v100;
              v98 -= 3;
            }
            while (&v67[v98] != a6);
          }
        }
      }
      else if (a4)
      {
        while (2)
        {
          uint64_t v12 = 0;
          uint64_t v13 = *(void *)a2;
          int v14 = *((_DWORD *)a2 + 2);
          uint64_t v15 = *(void *)v11;
          int v16 = *((_DWORD *)v11 + 2);
          uint64_t v111 = *(void *)a2;
          int v112 = v14;
          uint64_t v109 = v15;
          int v110 = v16;
          while (1)
          {
            unsigned int v17 = *((unsigned __int8 *)&v111 + v12);
            unsigned int v18 = *((unsigned __int8 *)&v109 + v12);
            if (v17 != v18) {
              break;
            }
            if (++v12 == 12) {
              goto LABEL_11;
            }
          }
          if (v17 >= v18)
          {
LABEL_11:
            uint64_t v19 = 0;
            uint64_t v107 = v13;
            int v108 = v14;
            uint64_t v105 = v15;
            int v106 = v16;
            while (1)
            {
              unsigned int v20 = *((unsigned __int8 *)&v107 + v19);
              unsigned int v21 = *((unsigned __int8 *)&v105 + v19);
              if (v20 != v21) {
                break;
              }
              if (++v19 == 12) {
                goto LABEL_16;
              }
            }
            if (v20 >= v21) {
              break;
            }
LABEL_16:
            v11 += 12;
            if (--a4) {
              continue;
            }
            return result;
          }
          break;
        }
        int32x4_t v102 = a3;
        uint64_t v103 = a6;
        uint64_t v104 = a7;
        if (a4 >= v8)
        {
          if (a4 == 1)
          {
            uint64_t v95 = *(void *)v11;
            int v112 = *((_DWORD *)v11 + 2);
            uint64_t v111 = v95;
            uint64_t v96 = *(void *)a2;
            *((_DWORD *)v11 + 2) = *((_DWORD *)a2 + 2);
            *(void *)uint64_t v11 = v96;
            uint64_t v97 = v111;
            *((_DWORD *)a2 + 2) = v112;
            *(void *)a2 = v97;
            return result;
          }
          if (a4 >= 0) {
            uint64_t v39 = a4;
          }
          else {
            uint64_t v39 = a4 + 1;
          }
          uint64_t v40 = v39 >> 1;
          uint64_t v28 = &v11[12 * (v39 >> 1)];
          if (a3 != a2)
          {
            unint64_t v41 = 0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 2);
            uint64_t v42 = *(void *)v28;
            int v43 = *((_DWORD *)v28 + 2);
            uint64_t v24 = (uint64_t)a2;
            while (1)
            {
              uint64_t v44 = 0;
              unint64_t v45 = v41 >> 1;
              unint64_t v46 = v24 + 12 * (v41 >> 1);
              uint64_t v47 = *(void *)v46;
              int v48 = *(_DWORD *)(v46 + 8);
              uint64_t v111 = *(void *)v46;
              int v112 = v48;
              uint64_t v109 = v42;
              int v110 = v43;
              while (1)
              {
                unsigned int v49 = *((unsigned __int8 *)&v111 + v44);
                unsigned int v50 = *((unsigned __int8 *)&v109 + v44);
                if (v49 != v50) {
                  break;
                }
                if (++v44 == 12) {
                  goto LABEL_48;
                }
              }
              if (v49 < v50) {
                break;
              }
LABEL_48:
              uint64_t v51 = 0;
              uint64_t v107 = v47;
              int v108 = v48;
              uint64_t v105 = v42;
              int v106 = v43;
              while (1)
              {
                unsigned int v52 = *((unsigned __int8 *)&v107 + v51);
                unsigned int v53 = *((unsigned __int8 *)&v105 + v51);
                if (v52 != v53) {
                  break;
                }
                if (++v51 == 12) {
                  goto LABEL_54;
                }
              }
              if (v52 >= v53) {
                break;
              }
LABEL_54:
              unint64_t v41 = v45;
              if (!v45) {
                goto LABEL_59;
              }
            }
            uint64_t v24 = v46 + 12;
            unint64_t v45 = v41 + ~v45;
            goto LABEL_54;
          }
          uint64_t v24 = (uint64_t)a3;
LABEL_59:
          uint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((v24 - (uint64_t)a2) >> 2);
        }
        else
        {
          if (v8 >= 0) {
            uint64_t v22 = v8;
          }
          else {
            uint64_t v22 = v8 + 1;
          }
          uint64_t v23 = v22 >> 1;
          uint64_t v24 = (uint64_t)&a2[12 * (v22 >> 1)];
          if (a2 == v11)
          {
            uint64_t v28 = a2;
          }
          else
          {
            unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v11) >> 2);
            uint64_t v26 = *(void *)v24;
            int v27 = *(_DWORD *)(v24 + 8);
            uint64_t v28 = v11;
            do
            {
              uint64_t v29 = 0;
              unint64_t v30 = v25 >> 1;
              BOOL v31 = &v28[12 * (v25 >> 1)];
              uint64_t v32 = *(void *)v31;
              int v33 = *((_DWORD *)v31 + 2);
              uint64_t v111 = v26;
              int v112 = v27;
              uint64_t v109 = v32;
              int v110 = v33;
              while (1)
              {
                unsigned int v34 = *((unsigned __int8 *)&v111 + v29);
                unsigned int v35 = *((unsigned __int8 *)&v109 + v29);
                if (v34 != v35) {
                  break;
                }
                if (++v29 == 12) {
                  goto LABEL_29;
                }
              }
              if (v34 < v35) {
                goto LABEL_35;
              }
LABEL_29:
              uint64_t v36 = 0;
              uint64_t v107 = v26;
              int v108 = v27;
              uint64_t v105 = v32;
              int v106 = v33;
              while (1)
              {
                unsigned int v37 = *((unsigned __int8 *)&v107 + v36);
                unsigned int v38 = *((unsigned __int8 *)&v105 + v36);
                if (v37 != v38) {
                  break;
                }
                if (++v36 == 12) {
                  goto LABEL_34;
                }
              }
              if (v37 >= v38) {
                goto LABEL_35;
              }
LABEL_34:
              uint64_t v28 = v31 + 12;
              unint64_t v30 = v25 + ~v30;
LABEL_35:
              unint64_t v25 = v30;
            }
            while (v30);
          }
          uint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((v28 - v11) >> 2);
        }
        uint64_t v101 = v24;
        a4 -= v40;
        uint64_t v54 = v8 - v23;
        uint64_t v55 = v40;
        uint64_t v56 = v23;
        unsigned int v57 = std::__rotate[abi:nn180100]<std::_ClassicAlgPolicy,RB::FormattedRenderState *,RB::FormattedRenderState *>(v28, a2, v24);
        uint64_t v58 = v56;
        uint64_t v8 = v54;
        uint64_t v59 = v55;
        a3 = v57;
        if (v58 + v59 >= v54 + a4)
        {
          uint64_t v61 = v59;
          uint64_t v62 = a4;
          uint64_t v63 = v58;
          std::__inplace_merge<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(v57, v101, v102, v62, v8, v103, v104);
          a2 = v28;
          a6 = v103;
          uint64_t v8 = v63;
          a4 = v61;
        }
        else
        {
          uint64_t v60 = v28;
          a6 = v103;
          std::__inplace_merge<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(v11, v60, v57, v59, v58, v103, v104);
          uint64_t v11 = a3;
          a2 = (char *)v101;
          a3 = v102;
        }
        a7 = v104;
        uint64_t result = 12;
        if (v8) {
          continue;
        }
      }
      break;
    }
  }
  return result;
}

char *std::__rotate[abi:nn180100]<std::_ClassicAlgPolicy,RB::FormattedRenderState *,RB::FormattedRenderState *>(char *__src, char *a2, uint64_t a3)
{
  uint64_t v4 = (char *)a3;
  if (__src != a2)
  {
    if (a2 == (char *)a3)
    {
      return __src;
    }
    else if (__src + 12 == a2)
    {
      uint64_t v9 = *(void *)__src;
      int v11 = *((_DWORD *)__src + 2);
      uint64_t v6 = a3 - (void)a2;
      memmove(__src, a2, a3 - (void)a2);
      uint64_t v4 = &__src[v6];
      *(void *)uint64_t v4 = v9;
      *((_DWORD *)v4 + 2) = v11;
    }
    else if (a2 + 12 == (char *)a3)
    {
      uint64_t v4 = __src + 12;
      uint64_t v10 = *(void *)(a3 - 12);
      int v12 = *(_DWORD *)(a3 - 4);
      size_t v7 = a3 - 12 - (void)__src;
      if ((char *)(a3 - 12) != __src) {
        memmove(__src + 12, __src, v7);
      }
      *(void *)__vImage_Buffer src = v10;
      *((_DWORD *)__src + 2) = v12;
    }
    else
    {
      return (char *)std::__rotate_gcd[abi:nn180100]<std::_ClassicAlgPolicy,RB::FormattedRenderState *>((uint64_t)__src, (uint64_t)a2, a3);
    }
  }
  return v4;
}

uint64_t std::__rotate_gcd[abi:nn180100]<std::_ClassicAlgPolicy,RB::FormattedRenderState *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 2);
  if (v3 == 0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 2))
  {
    if (a1 != a2 && a2 != a3)
    {
      uint64_t v4 = 0;
      do
      {
        uint64_t v5 = a2 + v4;
        uint64_t v6 = a1 + v4;
        int v7 = *(_DWORD *)(a1 + v4 + 8);
        uint64_t v8 = *(void *)(a1 + v4);
        int v9 = *(_DWORD *)(a2 + v4 + 8);
        *(void *)uint64_t v6 = *(void *)(a2 + v4);
        *(_DWORD *)(v6 + 8) = v9;
        *(void *)uint64_t v5 = v8;
        *(_DWORD *)(v5 + 8) = v7;
        if (a1 + v4 + 12 == a2) {
          break;
        }
        v4 += 12;
      }
      while (v5 + 12 != a3);
    }
  }
  else
  {
    uint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 2);
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 2);
    do
    {
      uint64_t v12 = v11;
      unint64_t v11 = v10;
      uint64_t v10 = v12 % v10;
    }
    while (v10);
    if (v11)
    {
      uint64_t v13 = a1 + 12 * v11;
      do
      {
        uint64_t v14 = *(void *)(v13 - 12);
        v13 -= 12;
        uint64_t v24 = v14;
        int v25 = *(_DWORD *)(v13 + 8);
        uint64_t v15 = (void *)(v13 + 4 * ((a2 - a1) >> 2));
        int v16 = (void *)v13;
        do
        {
          unsigned int v17 = v16;
          int v16 = v15;
          uint64_t v18 = *v15;
          *((_DWORD *)v17 + 2) = *((_DWORD *)v16 + 2);
          *unsigned int v17 = v18;
          unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((a3 - (uint64_t)v16) >> 2);
          BOOL v20 = __OFSUB__(v3, v19);
          uint64_t v22 = v3 - v19;
          char v21 = (v22 < 0) ^ v20;
          uint64_t v15 = (void *)(a1 + 12 * v22);
          if (v21) {
            uint64_t v15 = (void *)((char *)v16 + 4 * ((a2 - a1) >> 2));
          }
        }
        while (v15 != (void *)v13);
        *((_DWORD *)v16 + 2) = v25;
        *int v16 = v24;
      }
      while (v13 != a1);
    }
    return a1 + 4 * ((a3 - a2) >> 2);
  }
  return a2;
}

void std::default_delete<RB::Device::RenderPipelineEntry::Functions>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unint64_t v3 = *(void ***)(a2 + 24);
    if (*(_DWORD *)(a2 + 32))
    {
      unint64_t v4 = 0;
      uint64_t v5 = v3 + 1;
      do
      {
        uint64_t v6 = *v5;
        v5 += 2;

        ++v4;
      }
      while (v4 < *(unsigned int *)(a2 + 32));
      unint64_t v3 = *(void ***)(a2 + 24);
    }
    if (v3) {
      free(v3);
    }
    int v7 = *(void ***)(a2 + 8);
    if (*(_DWORD *)(a2 + 16))
    {
      unint64_t v8 = 0;
      do
      {
        int v9 = *v7;
        v7 += 10;

        ++v8;
      }
      while (v8 < *(unsigned int *)(a2 + 16));
      int v7 = *(void ***)(a2 + 8);
    }
    if (v7) {
      free(v7);
    }

    JUMPOUT(0x21669AC10);
  }
}

BOOL RB::pointer_compare(RB *this, RB *a2, const void *a3)
{
  return this == a2;
}

void RB::UntypedTable::grow_buckets(RB::UntypedTable *this)
{
  unsigned int v1 = *((_DWORD *)this + 18);
  if (v1 > 0x1E) {
    return;
  }
  unint64_t v3 = (void *)*((void *)this + 6);
  char v4 = v1 + 1;
  *((_DWORD *)this + 18) = v1 + 1;
  if (v1 > 3)
  {
    size_t v6 = 8 << v4;
    uint64_t v8 = (uint64_t)malloc_type_malloc(8 << v4, 0x2004093837F09uLL);
  }
  else
  {
    uint64_t v5 = (size_t *)*((void *)this + 4);
    if (!v5) {
      operator new();
    }
    size_t v6 = 8 << v4;
    int v7 = (void *)((v5[2] + 7) & 0xFFFFFFFFFFFFFFF8);
    if ((unint64_t)v7 + v6 <= v5[3])
    {
      void v5[2] = (size_t)v7 + v6;
      goto LABEL_9;
    }
    uint64_t v8 = RB::Heap::alloc_slow(v5, v6, 7);
  }
  int v7 = (void *)v8;
LABEL_9:
  bzero(v7, v6);
  int v9 = *((_DWORD *)this + 18);
  if (v7)
  {
    unint64_t v10 = 0;
    uint64_t v11 = ~(-1 << v9);
    *((void *)this + 8) = v11;
    do
    {
      uint64_t v12 = (void *)v3[v10];
      if (v12)
      {
        do
        {
          uint64_t v13 = (void *)*v12;
          uint64_t v14 = v12[3] & v11;
          *uint64_t v12 = *((void *)v7 + v14);
          *((void *)v7 + v14) = v12;
          uint64_t v12 = v13;
        }
        while (v13);
      }
      ++v10;
    }
    while (!(v10 >> v1));
    *((void *)this + 6) = v7;
    if (v1 > 4)
    {
      free(v3);
    }
  }
  else
  {
    *((_DWORD *)this + 18) = v9 - 1;
  }
}

uint64_t RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::~vector(uint64_t a1)
{
  uint32x2_t v2 = *(void **)(a1 + 32);
  if (v2) {
    unint64_t v3 = v2;
  }
  else {
    unint64_t v3 = (void *)a1;
  }
  unint64_t v4 = *(unsigned int *)(a1 + 40);
  if (v4)
  {
    for (unint64_t i = 0; i < v4; ++i)
    {
      uint64_t v6 = v3[i];
      v3[i] = 0;
      if (v6)
      {
        RB::RenderFrame::QueueDeleter::operator()((uint64_t)v2, v6);
        unint64_t v4 = *(unsigned int *)(a1 + 40);
      }
    }
    uint32x2_t v2 = *(void **)(a1 + 32);
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

void **RB::shared_vector<RB::Function const*>::~shared_vector(void **a1)
{
  uint32x2_t v2 = RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::buffer::~buffer(*a1);
  free(v2);
  return a1;
}

uint64_t RB::shared_vector<RB::RenderFrame::TextureRef>::~shared_vector(uint64_t a1)
{
  uint32x2_t v2 = *(void **)a1;
  uint64_t v3 = *(void *)(*(void *)a1 + 8);
  if (v3)
  {
    unint64_t v4 = v2 + 3;
    do
    {
      uint64_t v6 = *v4++;
      uint64_t v5 = v6;
      if (v6)
      {
        int v7 = (_DWORD *)(v5 & 0xFFFFFFFFFFFFFFFELL);
        int v8 = *(_DWORD *)((v5 & 0xFFFFFFFFFFFFFFFELL) + 8) - 1;
        float64x2_t v7[2] = v8;
        if (!v8) {
          (*(void (**)(_DWORD *))(*(void *)v7 + 8))(v7);
        }
      }
      --v3;
    }
    while (v3);
  }
  int v9 = RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::buffer::~buffer(v2);
  free(v9);
  return a1;
}

uint64_t RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::~shared_vector(uint64_t a1)
{
  uint32x2_t v2 = *(void **)a1;
  uint64_t v3 = *(void *)(*(void *)a1 + 8);
  if (v3)
  {
    unint64_t v4 = (_DWORD **)(v2 + 3);
    do
    {
      uint64_t v5 = *v4;
      if (*v4)
      {
        int v6 = v5[2] - 1;
        void v5[2] = v6;
        if (!v6) {
          (*(void (**)(_DWORD *))(*(void *)v5 + 8))(v5);
        }
      }
      ++v4;
      --v3;
    }
    while (v3);
  }
  int v7 = RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::buffer::~buffer(v2);
  free(v7);
  return a1;
}

void RB::RenderFrame::add_continuation(uint64_t a1, NSObject *a2, void *a3)
{
}

void RB::RenderFrame::copy_texture(uint64_t *a1@<X0>, MTLPixelFormat a2@<X1>, int a3@<W2>, char a4@<W3>, uint64_t a5@<X4>, int32x2_t *a6@<X5>, void *a7@<X8>)
{
  int v13 = *(unsigned __int8 *)(a2 + 80);
  uint64_t v14 = *(RB **)(a2 + 56);
  int v15 = a4 & 2;
  if (v13 == a3)
  {
    BOOL v16 = 0;
    unsigned int v17 = *(RB **)(a2 + 56);
    if ((a4 & 2) != 0) {
      goto LABEL_31;
    }
  }
  else
  {
    if ((v13 & 0xFE) == a3)
    {
      uint64_t v18 = (RB *)*(unsigned int *)((char *)RB::pixel_format_traits(*(void *)(a2 + 56), a2) + 18);
    }
    else if ((v13 | 1) == a3)
    {
      uint64_t v18 = (RB *)RB::pixel_format_traits(*(void *)(a2 + 56), a2)[6];
    }
    else
    {
      uint64_t v18 = 0;
    }
    BOOL v16 = v18 != 0;
    if (v18) {
      unsigned int v17 = v18;
    }
    else {
      unsigned int v17 = v14;
    }
    if (v15) {
      goto LABEL_31;
    }
  }
  if (!v17) {
    BOOL v16 = 0;
  }
  BOOL v19 = v13 != a3 && !v16;
  if (v19 || (a4 & 1) != 0 && *(unsigned __int8 *)(a2 + 76) < 2u) {
    goto LABEL_31;
  }
  if (v14 == v17)
  {
    ++*(_DWORD *)(a2 + 8);
    *a7 = a2;
    return;
  }
  BOOL v20 = RB::pixel_format_traits((unint64_t)v14, a2);
  if (((*v20 | ((unint64_t)*((unsigned __int16 *)v20 + 2) << 32)) & 0x40000000000) != 0)
  {
    if (!RB::Texture::has_view_usage((id *)a2)) {
      goto LABEL_31;
    }
    uint64_t v14 = *(RB **)(a2 + 56);
  }
  if (RB::pixel_formats_support_view_copy(v14, v17, v21))
  {
    if ((*(unsigned char *)(a2 + 77) & 1) == 0 || (uint64_t v22 = *(void *)(a2 + 24)) == 0 || *(RB **)(v22 + 56) != v17)
    {
      [*(id *)(a2 + 16) newTextureViewWithPixelFormat:v17];
      operator new();
    }
    ++*(_DWORD *)(v22 + 8);
    *a7 = v22;
    return;
  }
LABEL_31:
  int v23 = *(unsigned __int8 *)(a2 + 79);
  uint64_t v24 = RB::pixel_format_traits((unint64_t)v17, a2);
  unint64_t v26 = v24[8];
  if (!v24[8]) {
    unint64_t v26 = (unint64_t)v17;
  }
  int v27 = (RB *)HIDWORD(*((void *)v24 + 3));
  if (!v27) {
    int v27 = v17;
  }
  if (v23) {
    unint64_t v28 = v26;
  }
  else {
    unint64_t v28 = (unint64_t)v27;
  }
  if (a6
    && *(void *)&a6[7] == v28
    && (uint32x2_t v29 = (uint32x2_t)vceq_s32(a6[8], *(int32x2_t *)(a2 + 64)), (vpmin_u32(v29, v29).u32[0] & 0x80000000) != 0)
    && ((a4 & 1) == 0) != a6[9].u8[4] > 1u
    && a6[9].i8[6] == 1)
  {
    ++a6[1].i32[0];
    a6[10].i8[0] = a3;
  }
  else
  {
    if (a4) {
      unsigned int v30 = 0x7FFFFFFF;
    }
    else {
      unsigned int v30 = 1;
    }
    v25.n128_u64[0] = *(void *)(a2 + 64);
    RB::Texture::alloc(*a1, v28, v30, 1, 0, v44, v25);
    a6 = (int32x2_t *)v44[0];
    if (!*(void *)v44)
    {
      *a7 = 0;
      return;
    }
  }
  RB::RenderPass::RenderPass(v44, a5, a6, 0, 1, 0);
  RB::RenderPass::set_label((id *)v44, &cfstr_RbColorConvers.isa);
  RB::Coverage::set_plane((float32x2_t *)&v42, (uint64_t)v44, v31);
  if (v45 == 2) {
    unsigned int v32 = 131106;
  }
  else {
    unsigned int v32 = 34;
  }
  unint64_t v41 = (const char *)v32;
  RB::RenderState::set_color_conversion((int *)&v41, v13, a3, (_DWORD *)&v43 + 3);
  if (v15
    || (unsigned int v34 = RB::pixel_format_traits(*(void *)(a2 + 56), v33),
        ((*v34 | ((unint64_t)*((unsigned __int16 *)v34 + 2) << 32)) & 0x100000000) == 0))
  {
    LODWORD(v41) = v41 & 0xFCFFFFFF | ((v15 & 3) << 24) | 0x1000000;
  }
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v44, (RB::Device *)0x20, 4uLL, 0, &v53);
  unsigned int v35 = v53;
  if (v53)
  {
    int v36 = v54;
    unsigned int v37 = (_OWORD *)(*((void *)v53 + 7) + v54);
    long long v38 = v43;
    *unsigned int v37 = v42;
    v37[1] = v38;
    int v39 = v55;
  }
  else
  {
    int v39 = 0;
    int v36 = 0;
  }
  int v48 = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v44, v35);
  int v49 = v36;
  int v50 = v39;
  int v51 = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)v44, a2);
  char v52 = 0;
  RB::RenderPass::draw_indexed_primitives(v44, v41, 4, ***(void ***)v44 + 80, 0, 1uLL, v46, v47);
  int v51 = 0;
  char v52 = 0;
  RB::RenderPass::~RenderPass((RB::RenderPass *)v44);
  if (a4) {
    RB::RenderFrame::invalidate_mipmaps(a1, (RB::Texture *)a6);
  }
  *a7 = a6;
}

void sub_2141CA864(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,int a45,char a46)
{
  int v48 = *(_DWORD *)(v46 + 8) - 1;
  *(_DWORD *)(v46 + 8) = v48;
  if (!v48) {
    RB::TextureCache::prepare(v46);
  }
  _Unwind_Resume(exception_object);
}

RB::Resource *RB::Resource::set_source(RB::Resource *this, RB::Resource *a2)
{
  uint64_t result = (RB::Resource *)*((void *)this + 3);
  if (result != a2)
  {
    if (result)
    {
      int v5 = *((_DWORD *)result + 2) - 1;
      *((_DWORD *)result + 2) = v5;
      if (!v5) {
        uint64_t result = (RB::Resource *)(*(uint64_t (**)(RB::Resource *))(*(void *)result + 8))(result);
      }
    }
    if (a2) {
      ++*((_DWORD *)a2 + 2);
    }
    *((void *)this + 3) = a2;
  }
  return result;
}

void *RB::RenderFrame::invalidate_mipmaps(void *this, RB::Texture *a2)
{
  if (*((void *)a2 + 3)) {
    uint32x2_t v2 = (RB::Texture *)*((void *)a2 + 3);
  }
  else {
    uint32x2_t v2 = a2;
  }
  if (*((unsigned __int8 *)v2 + 76) >= 2u && (*((unsigned char *)v2 + 77) & 8) == 0)
  {
    uint64_t v3 = this;
    *((unsigned char *)v2 + 77) |= 8u;
    RB::RenderFrame::texture_id((RB::RenderFrame *)this, (uint64_t)v2);
    uint64_t v4 = v3[15];
    this = operator new(0x10uLL);
    *this = v4;
    this[1] = v2;
    v3[15] = this;
  }
  return this;
}

uint64_t RB::RenderFrame::texture_id(RB::RenderFrame *this, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  RB::Resource::set_frame_id(a2, *((_DWORD *)this + 21), *((_DWORD *)this + 22));
  uint64_t result = *(unsigned int *)(a2 + 40);
  if (!result)
  {
    uint64_t result = *(void *)(*((void *)this + 13) + 8);
    uint64_t v5 = *(void *)(a2 + 48);
    int v6 = (void *)*((void *)this + 13);
    unint64_t v7 = v6[1];
    if (v7 >= v6[2])
    {
      uint64_t v9 = *(void *)(a2 + 48);
      unint64_t v10 = v6[1];
      uint64_t v11 = *(void *)(*((void *)this + 13) + 8);
      unint64_t v8 = RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::realloc_buffer((unint64_t *)this + 13, v6);
      uint64_t v5 = v9;
      unint64_t v7 = v10;
      int v6 = (void *)v8;
      uint64_t result = v11;
    }
    v6[v7 + 3] = (v5 == 0) | (unint64_t)a2;
    if (!v5) {
      ++*(_DWORD *)(a2 + 8);
    }
    atomic_store(v7 + 1, v6 + 1);
    *(_DWORD *)(a2 + 40) = result;
    *((void *)this + 5) += *(unsigned int *)(a2 + 72);
  }
  return result;
}

uint64_t RB::RenderFrame::will_render(void)::Encoder::dispatch(uint64_t a1)
{
  uint64_t result = RB::RenderFrame::will_render(void)::Encoder::operator()(a1);
  if (a1)
  {
    uint64_t v3 = *(void **)(a1 + 8);
    if (v3)
    {
      do
      {
        uint64_t v4 = (void *)*v3;
        operator delete(v3);
        uint64_t v3 = v4;
      }
      while (v4);
    }
    *(void *)(a1 + 8) = 0;
    JUMPOUT(0x21669AC10);
  }
  return result;
}

uint64_t RB::RenderFrame::will_render(void)::Encoder::operator()(uint64_t a1)
{
  blit_encoder = (void *)RB::RenderFrame::make_blit_encoder(*(RB::RenderFrame **)a1);
  for (unint64_t i = *(void **)(a1 + 8); i; unint64_t i = (void *)*i)
    [blit_encoder generateMipmapsForTexture:*(void *)(i[1] + 16)];
  return [blit_encoder endEncoding];
}

uint64_t RB::RenderFrame::present(uint64_t a1, uint64_t a2, double a3)
{
  uint64_t v3 = *(void **)(a1 + 16);
  if (a3 == 0.0) {
    return [v3 presentDrawable:a2];
  }
  else {
    return objc_msgSend(v3, "presentDrawable:atTime:", a2);
  }
}

id *RB::RenderFrame::signal_event(id *result, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v5 = result;
    RB::RenderFrame::end_encoding(result);
    id v6 = v5[2];
    return (id *)[v6 encodeSignalEvent:a2 value:a3];
  }
  return result;
}

unint64_t RB::RenderFrame::add_function(unint64_t this, Function *a2)
{
  int v2 = *(_DWORD *)(this + 84);
  if (*((_DWORD *)a2 + 23) != v2)
  {
    int v4 = *(_DWORD *)(this + 88);
    *((_DWORD *)a2 + 23) = v2;
    *((_DWORD *)a2 + 24) = v4;
    uint64_t v5 = *(void **)(this + 112);
    unint64_t v6 = v5[1];
    if (v6 >= v5[2])
    {
      this = RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::realloc_buffer((unint64_t *)(this + 112), v5);
      uint64_t v5 = (void *)this;
    }
    v5[v6 + 3] = a2;
    atomic_store(v6 + 1, v5 + 1);
  }
  return this;
}

uint64_t RB::RenderFrame::commit_buffer_region_size(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(a2 + 16) = a3;
  if (*(unsigned char *)(result + 144))
  {
    *(void *)(result + 136) = *(void *)(a2 + 8) + a3;
    *(unsigned char *)(result + 144) = 0;
  }
  return result;
}

uint64_t RB::RenderFrame::make_blit_encoder(RB::RenderFrame *this)
{
  int v2 = (void *)*((void *)this + 36);
  if (v2)
  {
    [v2 endEncoding];

    *((void *)this + 36) = 0;
  }
  uint64_t v3 = (void *)*((void *)this + 2);
  return [v3 blitCommandEncoder];
}

void *RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 11) + (*((_DWORD *)__dst + 11) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 11) + (*((_DWORD *)__dst + 11) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned int,8ul>(*((void **)__dst + 4), __dst, 4u, (_DWORD *)__dst + 11, v3);
  *((void *)__dst + 4) = result;
  return result;
}

void RB::RenderFrame::end_encoding(void)::$_0::__invoke(uint64_t a1)
{
  int v2 = *(void **)(a1 + 288);
  if (v2)
  {
    [v2 endEncoding];

    *(void *)(a1 + 288) = 0;
  }
}

unint64_t RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::realloc_buffer(unint64_t *a1, void *a2)
{
  unint64_t v4 = a2[2] + (a2[2] >> 1);
  size_t v5 = malloc_good_size(8 * v4 + 24);
  unint64_t v6 = malloc_type_malloc(v5, 0x10E729FFuLL);
  if (!v6) {
    RB::precondition_failure((RB *)"memory allocation failed", v7);
  }
  unint64_t v8 = (unint64_t)v6;
  v6[1] = 0;
  int32x2_t v6[2] = (v5 - 24) >> 3;
  *unint64_t v6 = a2;
  unint64_t v9 = a2[1];
  if (v9 >= v4) {
    unint64_t v9 = v4;
  }
  v6[1] = v9;
  if (v9) {
    memcpy(v6 + 3, a2 + 3, 8 * v9);
  }
  atomic_store(v8, a1);
  return v8;
}

double RB::BinAllocator::dealloc(uint64_t a1, double a2, __n128 a3)
{
  unint64_t v4 = *(__int16 **)(a1 + 16);
  unint64_t v5 = *(unsigned int *)(a1 + 24);
  if (v5)
  {
    do
    {
      unint64_t v6 = v5 >> 1;
      unint64_t v7 = &v4[16 * (v5 >> 1)];
      int v9 = *v7;
      unint64_t v8 = v7 + 16;
      v5 += ~(v5 >> 1);
      if (SHIDWORD(a2) > v9) {
        unint64_t v4 = v8;
      }
      else {
        unint64_t v5 = v6;
      }
    }
    while (v5);
  }
  else
  {
    v4 += 16 * v5;
  }
  RB::BinAllocator::Shelf::dealloc((RB::BinAllocator::Shelf *)v4, SLOWORD(a2), a3.n128_i16[0]);
  if (v4[3] == v4[1])
  {
    unint64_t v10 = *(__int16 **)(a1 + 16);
    uint64_t v11 = (char *)v4 - (char *)v10;
    if (v4 == v10)
    {
      unint64_t v10 = v4;
    }
    else if (*(v4 - 13) == *(v4 - 15))
    {
      *(v4 - 14) += v4[2];
      unint64_t v12 = (unint64_t)v11 >> 5;
      uint64_t v13 = v11 >> 5;
      uint64_t v14 = (void *)*((void *)v4 + 2);
      if (v14) {
        free(v14);
      }
      uint64_t v15 = (*(_DWORD *)(a1 + 24) - 1);
      *(_DWORD *)(a1 + 24) = v15;
      uint64_t v16 = v15 - v13;
      if (v16) {
        memmove(&v10[16 * v13], &v10[16 * v13 + 16], 32 * v16);
      }
      unint64_t v10 = *(__int16 **)(a1 + 16);
      unint64_t v4 = &v10[16 * (v12 - 1)];
    }
    unsigned int v17 = v4 + 16;
    uint64_t v18 = *(unsigned int *)(a1 + 24);
    if (v4 + 16 != &v10[16 * v18] && v4[19] == v4[17])
    {
      v4[2] += v4[18];
      uint64_t v19 = ((char *)v17 - (char *)v10) >> 5;
      BOOL v20 = (void *)*((void *)v17 + 2);
      if (v20)
      {
        free(v20);
        LODWORD(v18) = *(_DWORD *)(a1 + 24);
      }
      uint64_t v21 = (v18 - 1);
      *(_DWORD *)(a1 + 24) = v21;
      uint64_t v22 = v21 - v19;
      if (v22) {
        memmove(&v10[16 * v19], &v10[16 * v19 + 16], 32 * v22);
      }
    }
  }
  double result = *(double *)a1;
  *(void *)(a1 + 8) = *(void *)a1;
  return result;
}

_WORD *RB::BinAllocator::Shelf::dealloc(RB::BinAllocator::Shelf *this, int a2, int a3)
{
  unsigned __int16 v3 = a3;
  unsigned __int16 v4 = a2;
  unint64_t v8 = (__int16 *)*((void *)this + 2);
  double result = (_WORD *)((char *)this + 16);
  unint64_t v7 = v8;
  __int16 v9 = *(result - 5) + a3;
  *(result - 5) = v9;
  *(result - 4) = v9;
  unint64_t v10 = *((unsigned int *)result + 2);
  if (!v10)
  {
LABEL_17:
    if (*((_DWORD *)this + 7) < (v10 + 1))
    {
      double result = RB::vector<RB::Animation::TermOrArg,0ul,unsigned int>::reserve_slow((uint64_t)result, (int)v10 + 1);
      unint64_t v7 = (__int16 *)*((void *)this + 2);
      unint64_t v10 = *((unsigned int *)this + 6);
    }
    *(_DWORD *)&v7[2 * v10] = v4 | (v3 << 16);
LABEL_29:
    ++*((_DWORD *)this + 6);
    return result;
  }
  uint64_t v11 = v7;
  unint64_t v12 = *((unsigned int *)result + 2);
  do
  {
    unint64_t v13 = v12 >> 1;
    uint64_t v14 = &v11[2 * (v12 >> 1)];
    int v16 = *v14;
    uint64_t v15 = v14 + 2;
    v12 += ~(v12 >> 1);
    if (v16 < a2) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v12 = v13;
    }
  }
  while (v12);
  if (v11 == &v7[2 * v10])
  {
    uint64_t v21 = &v7[2 * (v10 - 1)];
    int v24 = v21[1];
    uint64_t v22 = v21 + 1;
    __int16 v23 = v24;
    if (v24 + v7[2 * (v10 - 1)] == a2)
    {
      *uint64_t v22 = v23 + a3;
      return result;
    }
    goto LABEL_17;
  }
  if (a3 + a2 != *v11)
  {
    if (v11 != v7)
    {
      int v25 = *(v11 - 1);
      if (v25 + *(v11 - 2) == a2)
      {
        *(v11 - 1) = v25 + a3;
        return result;
      }
    }
    unint64_t v26 = ((char *)v11 - (char *)v7) >> 2;
    if (*((_DWORD *)this + 7) < (v10 + 1))
    {
      double result = RB::vector<RB::Animation::TermOrArg,0ul,unsigned int>::reserve_slow((uint64_t)result, (int)v10 + 1);
      unint64_t v7 = (__int16 *)*((void *)this + 2);
      unint64_t v10 = *((unsigned int *)this + 6);
    }
    BOOL v27 = v10 > v26;
    unint64_t v28 = v10 - v26;
    if (v27) {
      double result = memmove(&v7[2 * v26 + 2], &v7[2 * v26], 4 * v28);
    }
    *(_DWORD *)&v7[2 * v26] = v4 | (v3 << 16);
    goto LABEL_29;
  }
  *uint64_t v11 = a2;
  __int16 v17 = v11[1] + a3;
  v11[1] = v17;
  uint64_t v18 = (char *)v11 - (char *)v7;
  if (v11 != v7)
  {
    int v19 = *(v11 - 1);
    if (v19 + *(v11 - 2) == a2)
    {
      *(v11 - 1) = v19 + v17;
      uint64_t v20 = (v10 - 1);
      *((_DWORD *)this + 6) = v20;
      if (v20 != v18 >> 2)
      {
        return memmove(&v7[2 * (v18 >> 2)], &v7[2 * (v18 >> 2) + 2], 4 * (v20 - (v18 >> 2)));
      }
    }
  }
  return result;
}

std::string *RB::BinAllocator::print(uint64_t a1, std::string *this)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  std::string::append(this, "  <state>\n", 0xAuLL);
  int v4 = HIDWORD(*(void *)a1);
  int v5 = *(void *)a1;
  snprintf_l(__s, 0x100uLL, 0, "    <draw rect=\"%d %d %d %d\" color=\"%s\"/>\n", 0, 0, v5, v4, "red");
  size_t v6 = strlen(__s);
  std::string::append(this, __s, v6);
  snprintf_l(__s, 0x100uLL, 0, "    <draw stroked-rect=\"%g %g %d %d\" line-width=\"1\" color=\"black\"/>\n", 0.5, 0.5, v5 - 1, v4 - 1);
  size_t v7 = strlen(__s);
  std::string::append(this, __s, v7);
  uint64_t v30 = a1;
  uint64_t v8 = *(unsigned int *)(a1 + 24);
  if (v8)
  {
    __int16 v9 = *(__int16 **)(a1 + 16);
    uint32x2_t v29 = &v9[16 * v8];
    unint64_t v10 = "    <draw stroked-rect=\"%g %g %d %d\" line-width=\"1\" color=\"black\"/>\n";
    do
    {
      int v11 = *v9;
      int v12 = *(void *)v30;
      int v13 = v9[2];
      snprintf_l(__s, 0x100uLL, 0, "    <draw rect=\"%d %d %d %d\" color=\"%s\"/>\n", 0, v11, v12, v13, "#0080ff");
      size_t v14 = strlen(__s);
      std::string::append(this, __s, v14);
      snprintf_l(__s, 0x100uLL, 0, v10, 0x3FE0000000000000, (float)((float)v11 + 0.5), (v12 - 1), (v13 - 1));
      size_t v15 = strlen(__s);
      std::string::append(this, __s, v15);
      uint64_t v16 = *((unsigned int *)v9 + 6);
      if (v16)
      {
        __int16 v17 = (__int16 *)*((void *)v9 + 2);
        uint64_t v18 = &v17[2 * v16];
        do
        {
          int v19 = *v17;
          uint64_t v20 = v10;
          int v21 = *v9;
          int v22 = v17[1];
          int v23 = v9[2];
          snprintf_l(__s, 0x100uLL, 0, "    <draw rect=\"%d %d %d %d\" color=\"%s\"/>\n", v19, v21, v22, v23, "yellow");
          size_t v24 = strlen(__s);
          std::string::append(this, __s, v24);
          float v25 = (float)v21;
          unint64_t v10 = v20;
          snprintf_l(__s, 0x100uLL, 0, v20, (float)((float)v19 + 0.5), (float)(v25 + 0.5), (v22 - 1), (v23 - 1));
          size_t v26 = strlen(__s);
          std::string::append(this, __s, v26);
          v17 += 2;
        }
        while (v17 != v18);
      }
      v9 += 16;
    }
    while (v9 != v29);
  }
  std::string::append(this, "  </state>\n", 0xBuLL);
  snprintf_l(__s, 0x100uLL, 0, "  <transform translation=\"0 %d\"/>\n", *(_DWORD *)(v30 + 4) + 10);
  size_t v27 = strlen(__s);
  return std::string::append(this, __s, v27);
}

void RB::XML::DisplayList::save(RB::XML::DisplayList *this, RB::XML::Document *a2)
{
}

size_t *RB::XML::DisplayList::copy_state(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, _RBDrawingState *a4)
{
  size_t v6 = (RB::XML::DisplayList *)((char *)this + 32);
  size_t v7 = RB::UntypedTable::lookup((RB::XML::DisplayList *)((char *)this + 32), (uint64_t *)a2, 0);
  if (RB::UntypedTable::lookup(v6, (uint64_t *)a3, 0)) {
    RB::XML::Document::push(this, "copy-state");
  }
  double result = RB::XML::Document::add_state(this, a3);
  if (v7 || result) {
    RB::XML::Document::push(this, "copy-state");
  }
  return result;
}

void RB::XML::Element::set<RB::XML::Value::StateID>()
{
}

void RB::XML::DisplayList::device_scale(RB::XML::DisplayList *this, RB::XML::Document *a2, double a3)
{
}

uint64_t RB::XML::DisplayList::draw_layer(RB::XML::Document *this, int a2, float a3)
{
  if (a3 != 1.0) {
    RB::XML::Element::set<RB::XML::Value::Float>();
  }
  if (a2) {
    RB::XML::Element::set<RB::XML::Value::BlendMode>();
  }
  return RB::XML::Document::pop((uint64_t)this);
}

void RB::XML::Element::set<RB::XML::Value::BlendMode>()
{
}

void RB::XML::DisplayList::clip_layer()
{
}

void RB::XML::Element::set<RB::XML::Value::ClipMode>()
{
}

RB::XML::Document *RB::XML::DisplayList::concat_ctm(RB::XML::Document *this, RB::XML::Document *a2, float64x2_t *a3, const RB::AffineTransform *a4)
{
  int64x2_t v4 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a3[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*a3, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(a3[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v4, 1), (int8x16_t)v4).u64[0] & 0x8000000000000000) == 0) {
    RB::XML::Document::push(this, "transform");
  }
  return this;
}

void RB::XML::Element::set<RB::XML::Value::Angle>()
{
}

RB::XML::Document *RB::XML::DisplayList::scale_ctm(RB::XML::Document *this, RB::XML::Document *a2, _RBDrawingState *a3, double a4, double a5)
{
  if (a4 != 1.0 || a5 != 1.0) {
    RB::XML::Document::push(this, "transform");
  }
  return this;
}

RB::XML::Document *RB::XML::DisplayList::translate_ctm(RB::XML::Document *this, RB::XML::Document *a2, _RBDrawingState *a3, double a4, double a5)
{
  if (a4 != 0.0 || a5 != 0.0) {
    RB::XML::Document::push(this, "transform");
  }
  return this;
}

RB::XML::Document *RB::XML::DisplayList::rotate_ctm(RB::XML::Document *this, RB::XML::Document *a2, _RBDrawingState *a3, double a4)
{
  if (a4 != 0.0) {
    RB::XML::Document::push(this, "transform");
  }
  return this;
}

RB::XML::Document *RB::XML::DisplayList::set_identity(RB::XML::Document *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)a3 != *(_DWORD *)a4
    || (*(void *)(a3 + 4) == *(void *)(a4 + 4) ? (BOOL v4 = *(void *)(a3 + 12) == *(void *)(a4 + 12)) : (BOOL v4 = 0), !v4))
  {
    RB::XML::Document::push(this, "identity");
  }
  return this;
}

void RB::XML::Element::set<RB::XML::Value::UUID>()
{
}

void RB::XML::DisplayList::transition(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, const RB::Transition *a4)
{
}

RB::XML::Document *RB::XML::DisplayList::anonymous namespace'::add_transition(RB::XML::Document *this, RB::XML::Document *a2, const RB::Transition *a3)
{
  if (*((unsigned char *)a2 + 12)) {
    RB::XML::Element::set<RB::XML::Value::TransitionMethod>();
  }
  if (*((_DWORD *)a2 + 4) != -1) {
    RB::XML::Element::set<RB::XML::Value::Int>();
  }
  if (*((unsigned char *)a2 + 13)) {
    RB::XML::Element::set<RB::XML::Value::Bool>();
  }
  if (*((unsigned char *)a2 + 14) != 32) {
    RB::XML::Element::set<RB::XML::Value::Float>();
  }
  if (*((_DWORD *)a2 + 22)) {
    RB::XML::Document::push(this, "animation");
  }
  if (*((_DWORD *)a2 + 12)) {
    RB::XML::Document::push(this, "effect");
  }
  return this;
}

void RB::XML::DisplayList::attribute_value(RB::XML::Document *a1)
{
}

void RB::XML::DisplayList::clip_shape(RB::XML::Document *a1)
{
}

void RB::XML::DisplayList::draw_list(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, const RB::XML::Document *a4, float a5)
{
}

void sub_2141CCD24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, _DWORD *a12)
{
  if (a12)
  {
    int v13 = a12[2] - 1;
    a12[2] = v13;
    if (!v13) {
      (*(void (**)(_DWORD *))(*(void *)a12 + 8))(a12);
    }
  }
  _Unwind_Resume(exception_object);
}

void RB::XML::DisplayList::draw_interpolated(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, RBDisplayListInterpolator *a4, const RB::XML::Document *a5, const RB::XML::Document *a6, float a7, float a8)
{
}

void sub_2141CCFDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _DWORD *a10, uint64_t a11)
{
  if (a10)
  {
    int v12 = a10[2] - 1;
    a10[2] = v12;
    if (!v12) {
      (*(void (**)(_DWORD *))(*(void *)a10 + 8))(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

void RB::XML::DisplayList::add_predicate_style(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, const RB::DisplayList::InvertiblePredicate *a4)
{
}

void RB::XML::DisplayList::add_transform_style(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, const RB::DisplayList::Transform *a4)
{
}

void RB::XML::DisplayList::add_animation_style(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, const RB::Animation *a4, const UUID *a5)
{
}

void RB::XML::DisplayList::add_shadow_style(RB::XML::Document *a1)
{
}

void RB::XML::DisplayList::add_projection_style(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, const float *a4)
{
}

void sub_2141CD740(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  if (a10) {
    free(a10);
  }
  _Unwind_Resume(exception_object);
}

void RB::XML::DisplayList::add_rotation_style(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, double a4, CGPoint a5)
{
}

void RB::XML::DisplayList::add_scale_style(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, CGSize a4, CGPoint a5)
{
}

void RB::XML::DisplayList::add_translation_style(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, CGSize a4)
{
}

void RB::XML::DisplayList::add_rotation3d_style(RB::XML::Document *a1)
{
}

void RB::XML::Element::set<RB::XML::Value::Vec3>()
{
}

void RB::XML::DisplayList::add_affine_transform_style(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, const RB::AffineTransform *a4)
{
}

void RB::XML::DisplayList::add_path_projection_style(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, CGPoint a4, CGPoint a5, RBPath a6, const RB::AffineTransform *a7)
{
}

void sub_2141CDFF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

void RB::XML::DisplayList::add_blur_filter(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, double a4, CGRect a5)
{
}

void RB::XML::DisplayList::anonymous namespace'::set_blur_args(RB::XML::DisplayList::_anonymous_namespace_ *this, RB::XML::Element *a2, double a3, CGRect a4)
{
}

void RB::XML::DisplayList::add_variable_blur_filter(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, double a4, RBFill *a5, CGRect a6)
{
}

void RB::XML::DisplayList::add_variable_blur_layer(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, double a4, float a5, double a6, CGRect a7)
{
  CGFloat height = a7.size.height;
  CGFloat width = a7.size.width;
  CGFloat y = a7.origin.y;
  CGFloat x = a7.origin.x;
  *(void *)(*(void *)(*((void *)this + 1) + 8 * *((void *)this + 2) - 8) + 16) = "variable-blur-layer";
  RB::XML::Document::set_state(this, a2);
  if (a4 != 0.0) {
    RB::XML::Element::set<RB::XML::Value::Float>();
  }
  if (a5 != 1.0) {
    RB::XML::Element::set<RB::XML::Value::Float>();
  }
  v16.origin.CGFloat x = x;
  v16.origin.CGFloat y = y;
  v16.size.CGFloat width = width;
  v16.size.CGFloat height = height;
}

void RB::XML::DisplayList::add_alpha_threshold_filter(RB::XML::Document *a1)
{
}

void RB::XML::DisplayList::add_alpha_gradient_filter(uint64_t a1, uint64_t a2)
{
  MEMORY[0x270FA5388](a1, a2);
  uint64_t v3 = *MEMORY[0x263EF8340];
  RB::XML::Document::push(v2, "alpha-gradient");
}

void sub_2141CE920(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
}

void RB::XML::DisplayList::add_distance_filter(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, double a4, double a5)
{
}

void RB::XML::DisplayList::add_color_matrix_filter(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, const float *a4)
{
}

void RB::XML::Element::set<RB::XML::Value::ColorMatrix>()
{
}

void RB::XML::DisplayList::anonymous namespace'::add_color_filter_flags(RB::XML::DisplayList::_anonymous_namespace_ *this, RB::XML::Document *a2)
{
  if ((a2 & 1) != 0 || (a2 & 2) != 0) {
    RB::XML::Element::set<RB::XML::Value::ConstantString>();
  }
  if ((a2 & 4) != 0) {
    RB::XML::Element::set<RB::XML::Value::Bool>();
  }
}

void RB::XML::DisplayList::add_color_multiply_filter(RB::XML::Document *a1)
{
}

void RB::XML::DisplayList::add_alpha_multiply_filter(RB::XML::Document *a1)
{
}

void RB::XML::DisplayList::add_hue_rotation_filter(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, double a4)
{
}

void RB::XML::DisplayList::add_saturation_filter(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, float a4)
{
}

void RB::XML::DisplayList::add_brightness_filter(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, float a4)
{
}

void RB::XML::DisplayList::add_contrast_filter(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, float a4)
{
}

void RB::XML::DisplayList::add_luminance_to_alpha_filter(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3)
{
}

void RB::XML::DisplayList::add_color_invert_filter(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, float a4)
{
}

void RB::XML::DisplayList::add_grayscale_filter(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, float a4)
{
}

void RB::XML::DisplayList::add_color_monochrome_filter(RB::XML::Document *a1)
{
}

void RB::XML::DisplayList::add_luminance_curve_filter(RB::XML::Document *a1)
{
}

void RB::XML::DisplayList::add_rgba_curves_filter(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, const float *a4)
{
}

void RB::XML::DisplayList::add_shader_filter(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, RBShader *a4, CGSize a5, const CGSize *a6, const CGRect *a7)
{
  char v7 = (char)a7;
  if (a4)
  {
    *(void *)(*(void *)(*((void *)this + 1) + 8 * *((void *)this + 2) - 8) + 16) = "custom-filter-layer";
    RB::XML::Document::set_state(this, a2);
    if ((v7 & 0xFu) <= 2) {
      RB::XML::Element::set<RB::XML::Value::ConstantString>();
    }
    a3;
    RB::XML::Element::set<RB::XML::Value::Shader>();
  }
  RB::XML::Document::push(this, "custom-filter");
}

void sub_2141CFBA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
  _Unwind_Resume(a1);
}

void RB::XML::Element::set<RB::XML::Value::Shader>()
{
}

void sub_2141CFC78(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x81C40803F642BLL);
  _Unwind_Resume(a1);
}

void RB::XML::Element::set<RB::XML::Value::TransitionMethod>()
{
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::TransitionMethod,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2141CFDB8(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::TransitionMethod *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::TransitionMethod>,std::allocator<RB::XML::Value::TransitionMethod>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::TransitionMethod *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::TransitionMethod>,std::allocator<RB::XML::Value::TransitionMethod>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void RB::XML::Element::set<RB::XML::Value::TransitionEffectType>()
{
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::TransitionEffectType,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2141CFF5C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::TransitionEffectType *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::TransitionEffectType>,std::allocator<RB::XML::Value::TransitionEffectType>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::TransitionEffectType *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::TransitionEffectType>,std::allocator<RB::XML::Value::TransitionEffectType>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::StateID,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2141D004C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::StateID *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::StateID>,std::allocator<RB::XML::Value::StateID>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::StateID *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::StateID>,std::allocator<RB::XML::Value::StateID>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::BlendMode,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2141D013C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::BlendMode *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::BlendMode>,std::allocator<RB::XML::Value::BlendMode>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::BlendMode *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::BlendMode>,std::allocator<RB::XML::Value::BlendMode>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::ClipMode,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2141D022C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::ClipMode *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::ClipMode>,std::allocator<RB::XML::Value::ClipMode>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::ClipMode *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::ClipMode>,std::allocator<RB::XML::Value::ClipMode>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Angle,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2141D031C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Angle *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Angle>,std::allocator<RB::XML::Value::Angle>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Angle *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Angle>,std::allocator<RB::XML::Value::Angle>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::UUID,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2141D040C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::UUID *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::UUID>,std::allocator<RB::XML::Value::UUID>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::UUID *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::UUID>,std::allocator<RB::XML::Value::UUID>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Vec3,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2141D04FC(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Vec3 *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Vec3>,std::allocator<RB::XML::Value::Vec3>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Vec3 *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Vec3>,std::allocator<RB::XML::Value::Vec3>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::ColorMatrix,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2141D05EC(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::ColorMatrix *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::ColorMatrix>,std::allocator<RB::XML::Value::ColorMatrix>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::ColorMatrix *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::ColorMatrix>,std::allocator<RB::XML::Value::ColorMatrix>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Shader,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_2141D06DC(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Shader *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Shader>,std::allocator<RB::XML::Value::Shader>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21669AC10);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Shader *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Shader>,std::allocator<RB::XML::Value::Shader>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

float RB::DisplayList::ShadowStyle::copy(RB::DisplayList::ShadowStyle *this, RB::DisplayList::Builder *a2)
{
  return _ZN2RB4Heap7emplaceINS_11DisplayList11ShadowStyleEJRKfS5_RKDv2_fRKNS_4Fill5ColorERKNS_9BlendModeERKjEEEPT_DpOT0_((RB::Heap *)(*((void *)a2 + 1) + 16), (float *)this + 16, (int *)this + 17, (uint64_t *)this + 7, (uint64_t *)this + 9, (int *)this + 21, (int *)this + 22);
}

float _ZN2RB4Heap7emplaceINS_11DisplayList11ShadowStyleEJRKfS5_RKDv2_fRKNS_4Fill5ColorERKNS_9BlendModeERKjEEEPT_DpOT0_(RB::Heap *this, float *a2, int *a3, uint64_t *a4, uint64_t *a5, int *a6, int *a7)
{
  unint64_t v14 = *((void *)this + 3);
  unint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 96 > v14) {
    unint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0x60uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 96;
  }
  float result = *a2;
  int v17 = *a3;
  uint64_t v18 = *a4;
  uint64_t v19 = *a5;
  __int16 v20 = *((_WORD *)a5 + 4);
  int v21 = *a6;
  int v22 = *a7;
  *(void *)(v15 + 48) = 0;
  *(_OWORD *)(v15 + 16) = 0u;
  *(_OWORD *)(v15 + 32) = 0u;
  *(void *)unint64_t v15 = &unk_26C4EA5F8;
  *(void *)(v15 + 56) = v18;
  *(float *)(v15 + 64) = result;
  *(_DWORD *)(v15 + 68) = v17;
  *(void *)(v15 + 72) = v19;
  *(_WORD *)(v15 + 80) = v20;
  *(_DWORD *)(v15 + 84) = v21;
  *(_DWORD *)(v15 + 88) = v22;
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::ShadowStyle::draw(RB::DisplayList::ShadowStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  v58[13] = *MEMORY[0x263EF8340];
  __asm { FCMP            H0, #0 }
  if (_ZF && RB::may_discard_alpha(*((_WORD *)a4 + 23) & 0x3F))
  {
    if ((*((unsigned char *)this + 88) & 2) != 0)
    {
      __int16 v20 = **(uint64_t (***)(RB::DisplayList::Item *))a4;
      return (RB::DisplayList::Builder *)v20(a4);
    }
    else
    {
      *((void *)a4 + 2) = *((void *)this + 4);
      *((void *)a4 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, *((void **)a4 + 3), *((const RB::DisplayList::ClipNode **)this + 3));
      return RB::DisplayList::Builder::draw(a2, a4, a3, a5);
    }
  }
  __int16 v14 = *((_WORD *)a4 + 23);
  int v50 = v14 & 0x3F;
  short float v15 = *((short float *)a4 + 22);
  short float v49 = v15;
  uint64_t v16 = *((void *)a4 + 4);
  int v17 = *((_DWORD *)a4 + 10);
  if ((*((unsigned char *)this + 88) & 0xA) == 0)
  {
    if ((v14 & 0x3F) == 2)
    {
      int v19 = *((_DWORD *)this + 21);
      *((_WORD *)a4 + 23) = v14 & 0xFFC0 | 2;
      if (v19 == 2 && v15 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
      {
        int v18 = 0;
        goto LABEL_19;
      }
    }
    else
    {
      *((_WORD *)a4 + 23) = v14 & 0xFFC0 | 2;
    }
    *((_WORD *)a4 + 22) = COERCE_UNSIGNED_INT(1.0);
    *((void *)a4 + 4) = 0;
    *((_DWORD *)a4 + 10) = 0;
    int v18 = 1;
    goto LABEL_19;
  }
  int v18 = 0;
  *((_WORD *)a4 + 23) = v14 & 0xFFC0 | 2;
LABEL_19:
  uint64_t v21 = (*(uint64_t (**)(RB::DisplayList::Item *, RB::DisplayList::Builder *, RB::DisplayList::ShadowStyle *))(*(void *)a4 + 72))(a4, a2, this);
  if (v21)
  {
    int v22 = (RB::DisplayList::Item *)v21;
    LOBYTE(v23) = 0;
  }
  else
  {
    unsigned int v24 = *((_DWORD *)this + 22);
    float v25 = a4;
    if ((v24 & 2) == 0) {
      float v25 = (RB::DisplayList::Item *)(*(uint64_t (**)(RB::DisplayList::Item *, RB::DisplayList::Builder *, void))(*(void *)a4 + 24))(a4, a2, 0);
    }
    float v26 = *((float *)this + 16);
    if (fabsf(v26) > 0.01)
    {
      RB::Filter::GaussianBlur::GaussianBlur((uint64_t)&v54, v26, 0, 0, (*((_DWORD *)this + 22) >> 1) & 8);
      size_t v27 = (float64x2_t *)*((void *)this + 2);
      unint64_t v28 = (RB::DisplayList::LayerFilter *)RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur const&,RB::DisplayList::Builder &>((size_t *)(*((void *)a2 + 1) + 16), (RB::Filter::GaussianBlur *)&v54, a2);
      float v25 = RB::DisplayList::Builder::apply_filter_(a2, v25, v28, v27, 0);
      uint32x2_t v29 = v56;
      uint64_t v56 = 0;
      if (v29) {
        (**v29)(v29);
      }
    }
    *((_WORD *)v25 + 23) = *((_WORD *)v25 + 23) & 0xFFC0 | *((_WORD *)this + 42) & 0x3F;
    unint64_t v30 = *((_DWORD *)this + 22) & 4;
    float v31 = *((float *)this + 17);
    if (fabsf(v31 + -0.5) >= 0.01)
    {
      *(_OWORD *)((char *)&v54 + 4 * v30) = RBColorClear;
      *((float32x4_t *)&v54 + ((v30 >> 2) ^ RBPathRetain(*(void *)this, *((void *)this + 1)) = vcvtq_f32_f16(*(float16x4_t *)((char *)this + 72));
      *(void *)&long long v51 = 0;
      if (v30) {
        float v31 = 1.0 - v31;
      }
      *((double *)&v51 + 1) = v31;
      *(void *)&long long v52 = 0x3FF0000000000000;
      MTLPixelFormat v33 = (size_t *)(*((void *)a2 + 1) + 16);
      int v48 = 2;
      unint64_t v34 = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::Heap&,int,RBColor (&)[2],std::optional<RB::ColorSpace> const&,double (&)[3],unsigned int const&>(v33, (RB::Heap *)v33, &v48, (uint64_t)&v54, (__int16 *)this + 40, (uint64_t)&v51, &RB::Fill::Gradient::Flags::interp_midpoints);
    }
    else
    {
      float16x4_t v32 = *(float16x4_t *)((char *)this + 72);
      if ((*((_DWORD *)this + 22) & 4) != 0) {
        RB::ColorMatrix::set_inverse_alpha_multiply((uint64_t)&v54, 0, v32);
      }
      else {
        RB::ColorMatrix::set_alpha_multiply((int8x8_t *)&v54, 0, (int8x8_t)v32);
      }
      unsigned int v35 = RB::DisplayList::Builder::apply_color_matrix(a2, v25, (const RB::ColorMatrix *)&v54, 0, *((float64x2_t **)this + 2), 0);
    }
    int v22 = v35;
    int v23 = (v24 >> 1) & 1;
  }
  float32x2_t v36 = *(float32x2_t *)((char *)this + 56);
  uint32x2_t v37 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(v36));
  if ((vpmax_u32(v37, v37).u32[0] & 0x80000000) != 0)
  {
    float64x2_t v38 = vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)*((void *)this + 2), v36.f32[0]), *(float64x2_t *)(*((void *)this + 2) + 16), v36.f32[1]);
    long long v51 = xmmword_2142181C0;
    long long v52 = xmmword_2142181D0;
    float64x2_t v53 = v38;
    RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v54, (uint64_t)a2, &v51, 0, 0, 0);
    (*(void (**)(RB::DisplayList::Item *, RB::DisplayList::Layer **, void))(*(void *)v22 + 32))(v22, &v54, 0);
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v58);
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v57);
    RB::Heap::~Heap((RB::Heap *)&v55);
  }
  *((_WORD *)v22 + 23) = *((_WORD *)v22 + 23) & 0xFFC0 | *((_WORD *)this + 42) & 0x3F;
  *((void *)v22 + 4) = v16;
  *((_DWORD *)v22 + 10) = v17;
  if (v18)
  {
    layer = (RB::DisplayList::Layer *)RB::DisplayList::Builder::make_layer(a2, 0);
    char v40 = 0;
  }
  else
  {
    unint64_t v41 = (void *)*((void *)v22 + 3);
    *((void *)v22 + 2) = *((void *)this + 4);
    *((void *)v22 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, v41, *((const RB::DisplayList::ClipNode **)this + 3));
    layer = a3;
    char v40 = a5;
    if ((*((unsigned char *)this + 88) & 2) == 0)
    {
      long long v42 = (void *)*((void *)a4 + 3);
      *((void *)a4 + 2) = *((void *)this + 4);
      *((void *)a4 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, v42, *((const RB::DisplayList::ClipNode **)this + 3));
      *((_WORD *)a4 + 23) = *((_WORD *)a4 + 23) & 0xFFC0 | v50 & 0x3F;
      *((void *)a4 + 4) = v16;
      *((_DWORD *)a4 + 10) = v17;
      layer = a3;
      char v40 = a5;
    }
  }
  uint64_t v54 = layer;
  if ((*((_DWORD *)this + 22) & 3) == 1)
  {
    RB::DisplayList::Builder::draw(a2, a4, layer, v40);
    float result = RB::DisplayList::Builder::draw(a2, v22, layer, v40);
  }
  else if ((*((_DWORD *)this + 22) & 3) != 0)
  {
    float result = RB::DisplayList::Builder::draw(a2, v22, layer, v40);
    if ((v23 & 1) == 0) {
      float result = (RB::DisplayList::Builder *)(**(uint64_t (***)(RB::DisplayList::Item *))a4)(a4);
    }
  }
  else
  {
    RB::DisplayList::Builder::draw(a2, v22, layer, v40);
    float result = RB::DisplayList::Builder::draw(a2, a4, v54, v40);
  }
  if (v18)
  {
    _ZN2RB4Heap7emplaceINS_11DisplayList9LayerItemEJRDF16_RKNS_9BlendModeERPNS2_5LayerEEEEPT_DpOT0_((size_t *)(*((void *)a2 + 1) + 16), (__int16 *)&v49, &v50, (uint64_t *)&v54);
    uint64_t v44 = v43;
    int v45 = *(void **)(v43 + 24);
    *(void *)(v43 + 16) = *((void *)this + 4);
    *(void *)(v43 + 24) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, v45, *((const RB::DisplayList::ClipNode **)this + 3));
    *(void *)(v44 + 32) = v16;
    *(_DWORD *)(v44 + 40) = v17;
    return RB::DisplayList::Builder::draw(a2, (RB::DisplayList::Item *)v44, a3, a5);
  }
  return result;
}

void sub_2141D0F10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::Heap&,int,RBColor (&)[2],std::optional<RB::ColorSpace> const&,double (&)[3],unsigned int const&>(size_t *a1, RB::Heap *a2, int *a3, uint64_t a4, __int16 *a5, uint64_t a6, int *a7)
{
  unint64_t v13 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v13 + 88 > a1[3]) {
    unint64_t v13 = RB::Heap::alloc_slow(a1, 0x58uLL, 7);
  }
  else {
    a1[2] = v13 + 88;
  }
  *(void *)unint64_t v13 = &unk_26C4EBD20;
  RB::Fill::Gradient::Gradient(v13 + 16, a2, 3, *a3, a4, *a5, a6, *a7, 0.0, 0.0, 0.0, 0.0);
  *(unsigned char *)(v13 + 80) = 1;
  return v13;
}

RB::DisplayList::Item *RB::DisplayList::anonymous namespace'::apply_alpha_gradient(RB::DisplayList::Builder *a1, RB::DisplayList::Item *a2, uint64_t a3)
{
  float result = (RB::DisplayList::Item *)(*(uint64_t (**)(RB::DisplayList::Item *, RB::DisplayList::Builder *, uint64_t))(*(void *)a2 + 120))(a2, a1, a3 + 16);
  if (!result)
  {
    float result = RB::DisplayList::Builder::ensure_layer(a1, a2, 0.0, 160);
    uint64_t v7 = *((void *)result + 6);
    *(unsigned char *)(v7 + 64) = 2;
    *(void *)(v7 + 24) = a3;
  }
  return result;
}

void RB::DisplayList::ShadowStyle::make_primitive(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, int a5, float _S0, float a7)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v26 = a4;
  float v25 = a7;
  int v24 = a5;
  float v9 = *(float *)(a1 + 68);
  if (v9 == 0.5)
  {
    unint64_t v10 = (RB::Heap *)(*(void *)(a2 + 8) + 16);
    __asm { FCVT            H0, S0 }
    LOWORD(v22) = *(_WORD *)(a1 + 72);
    *(_DWORD *)((char *)&v22 + 2) = *(_DWORD *)(a1 + 74);
    *((short float *)&v22 + 3) = *(short float *)(a1 + 78) * _H0;
    __int16 v23 = *(_WORD *)(a1 + 80);
    LOWORD(v28) = *(_WORD *)(*(void *)(a2 + 264) + 156);
    RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(v10, (uint64_t)v10, a3, (uint64_t)&v22, &v26, (int *)&v25, &v24, (__int16 *)&v28);
  }
  else
  {
    long long v28 = RBColorClear;
    _H2 = *(_WORD *)(a1 + 76);
    __asm { FCVT            S2, H2 }
    _H3 = *(_WORD *)(a1 + 78);
    __asm { FCVT            S3, H3 }
    unint64_t v29 = vcvtq_f32_f16(*(float16x4_t *)(a1 + 72)).u64[0];
    int v30 = _S2;
    float v31 = _S3 * _S0;
    v27[0] = 0;
    *(double *)&v27[1] = v9;
    v27[2] = 0x3FF0000000000000;
    RB::Fill::Gradient::Gradient((uint64_t)&v22, (RB::Heap *)(*(void *)(a2 + 8) + 16), 3, 2uLL, (uint64_t)&v28, *(_WORD *)(a1 + 80), (uint64_t)v27, 256, 0.0, 0.0, 0.0, 0.0);
    __int16 v20 = (size_t *)(*(void *)(a2 + 8) + 16);
    __int16 v21 = *(_WORD *)(*(void *)(a2 + 264) + 156);
    RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(v20, (RB::Heap *)v20, a3, &v22, &v26, (int *)&v25, &v24, &v21);
  }
}

void *RB::DisplayList::ShadowStyle::encode(RB::DisplayList::ShadowStyle *this, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x22uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  int v4 = *((int *)this + 16);
  if (*(float *)&v4 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xDuLL);
    RB::ProtobufEncoder::encode_fixed32(a2, v4);
  }
  RB::ProtobufEncoder::float2_field(a2, 2, *((double *)this + 7));
  RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Fill::Color::encode((RB::DisplayList::ShadowStyle *)((char *)this + 72), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  int v5 = rb_blend_mode(*((_DWORD *)this + 21));
  if (v5)
  {
    int v6 = v5;
    RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
    RB::ProtobufEncoder::encode_varint(a2, v6);
  }
  int v7 = *((_DWORD *)this + 22);
  if (v7)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
    RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    int v7 = *((_DWORD *)this + 22);
    if ((v7 & 2) == 0)
    {
LABEL_7:
      if ((v7 & 4) == 0) {
        goto LABEL_8;
      }
      goto LABEL_18;
    }
  }
  else if ((v7 & 2) == 0)
  {
    goto LABEL_7;
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x30uLL);
  RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  int v7 = *((_DWORD *)this + 22);
  if ((v7 & 4) == 0)
  {
LABEL_8:
    if ((v7 & 8) == 0) {
      goto LABEL_9;
    }
    goto LABEL_19;
  }
LABEL_18:
  RB::ProtobufEncoder::encode_varint(a2, 0x38uLL);
  RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  int v7 = *((_DWORD *)this + 22);
  if ((v7 & 8) == 0)
  {
LABEL_9:
    if ((v7 & 0x10) == 0) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
LABEL_19:
  RB::ProtobufEncoder::encode_varint(a2, 0x40uLL);
  RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  if ((*((_DWORD *)this + 22) & 0x10) != 0)
  {
LABEL_10:
    RB::ProtobufEncoder::encode_varint(a2, 0x48uLL);
    RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
LABEL_11:
  int v8 = *((int *)this + 17);
  if (*(float *)&v8 != 0.5)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x55uLL);
    RB::ProtobufEncoder::encode_fixed32(a2, v8);
  }
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void *RB::DisplayList::Style::encode(void *this, RB::Encoder *a2)
{
  uint64_t v3 = this;
  int v4 = (float64x2_t *)this[2];
  if (v4)
  {
    int64x2_t v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::AffineTransform::encode(v4->f64, a2);
      this = RB::ProtobufEncoder::end_length_delimited(a2);
    }
  }
  int v6 = (uint64_t *)v3[3];
  if (v6) {
    this = RB::Encoder::shared_field_f(a2, 2, v6);
  }
  if (v3[5])
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::DisplayList::encode_metadata(a2, (RB::Encoder *)v3[5], (const RB::DisplayList::Metadata *)*((unsigned int *)v3 + 12), 1);
    return RB::ProtobufEncoder::end_length_delimited(a2);
  }
  return this;
}

unint64_t RB::DisplayList::ShadowStyle::decode(RB::DisplayList::ShadowStyle *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v6 = result;
    do
    {
      switch((v6 >> 3))
      {
        case 1u:
          *((float *)this + 16) = RB::ProtobufDecoder::float_field(a2, v6);
          break;
        case 2u:
          *((void *)this + 7) = RB::ProtobufDecoder::float2_field(a2, v6, v5).n128_u64[0];
          break;
        case 3u:
          if ((v6 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            RB::Fill::Color::decode((uint64_t)this + 72, a2);
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
            *((unsigned char *)a2 + 56) = 1;
            *(void *)a2 = *((void *)a2 + 1);
          }
          break;
        case 4u:
          unsigned int v7 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, v6);
          *((_DWORD *)this + 21) = rb_blend_mode(v7);
          break;
        case 5u:
          *((_DWORD *)this + 22) &= ~1u;
          int v8 = *((_DWORD *)this + 22) | RB::ProtobufDecoder::BOOL_field(a2, v6);
          goto LABEL_24;
        case 6u:
          *((_DWORD *)this + 22) &= ~2u;
          if (RB::ProtobufDecoder::BOOL_field(a2, v6)) {
            int v9 = 2;
          }
          else {
            int v9 = 0;
          }
          goto LABEL_23;
        case 7u:
          *((_DWORD *)this + 22) &= ~4u;
          if (RB::ProtobufDecoder::BOOL_field(a2, v6)) {
            int v9 = 4;
          }
          else {
            int v9 = 0;
          }
          goto LABEL_23;
        case 8u:
          *((_DWORD *)this + 22) &= ~8u;
          if (RB::ProtobufDecoder::BOOL_field(a2, v6)) {
            int v9 = 8;
          }
          else {
            int v9 = 0;
          }
          goto LABEL_23;
        case 9u:
          *((_DWORD *)this + 22) &= ~0x10u;
          if (RB::ProtobufDecoder::BOOL_field(a2, v6)) {
            int v9 = 16;
          }
          else {
            int v9 = 0;
          }
LABEL_23:
          int v8 = *((_DWORD *)this + 22) | v9;
LABEL_24:
          *((_DWORD *)this + 22) = v8;
          break;
        case 0xAu:
          *((float *)this + 17) = RB::ProtobufDecoder::float_field(a2, v6);
          break;
        default:
          RB::ProtobufDecoder::skip_field(a2, v6);
          break;
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v6 = result;
    }
    while (result);
  }
  return result;
}

void RB::DisplayList::ShadowStyle::bounds(float64x2_t **this, float32x2_t *a2, float64x2_t *a3, int a4)
{
  float32x2_t v4 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
  uint32x2_t v5 = (uint32x2_t)vcge_f32((float32x2_t)(*(void *)&a2[1] & 0x7FFFFFFF7FFFFFFFLL), v4);
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) == 0)
  {
    RB::Rect::move(a2, a3, this[2]);
    *(float *)v9.i32 = *((float *)this + 16) * 2.8;
    long long v23 = *(_OWORD *)a2->f32;
    *(int32x2_t *)v10.i8 = vcgt_f32(v4, *(float32x2_t *)((char *)&v23 + 8));
    int8x16_t v11 = (int8x16_t)vcltzq_s32(v10);
    int8x8_t v12 = (int8x8_t)vmvnq_s8(v11).u64[0];
    *(int8x8_t *)&long long v13 = vorr_s8(vand_s8((int8x8_t)vsub_f32(*(float32x2_t *)&v23, (float32x2_t)vdup_lane_s32(v9, 0)), *(int8x8_t *)v11.i8), vand_s8(*(int8x8_t *)&v23, v12));
    *((int8x8_t *)&v13 + 1) = vorr_s8(vand_s8((int8x8_t)vmla_n_f32(*(float32x2_t *)((char *)&v23 + 8), (float32x2_t)0x4000000040000000, *(float *)v9.i32), *(int8x8_t *)v11.i8), vand_s8(*(int8x8_t *)((char *)&v23 + 8), v12));
    long long v23 = v13;
    float32x2_t v14 = (float32x2_t)this[7];
    int8x8_t v15 = (int8x8_t)vneg_f32(v14);
    if (a4) {
      unsigned int v16 = -1;
    }
    else {
      unsigned int v16 = 0;
    }
    float32x2_t v17 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v16), v15, (int8x8_t)v14);
    RB::Rect::translate((float32x2_t *)&v23, v17, v17.f32[1]);
    if (((_BYTE)this[11] & 2) != 0)
    {
      *(_OWORD *)a2->f32 = v23;
    }
    else
    {
      v18.i64[0] = *((void *)&v23 + 1);
      RB::Rect::Union(a2, *(double *)&v23, v18, v19, v20, v21, v22);
    }
  }
}

void RB::DisplayList::ShadowStyle::map_roi(float64x2_t **this, float32x2_t *a2, float64x2_t *a3)
{
}

double RB::DisplayList::ShadowStyle::bounds(RB::DisplayList::ShadowStyle *this, const RB::DisplayList::Item *a2, uint64_t a3)
{
  v14[0] = RB::DisplayList::Style::next_bounds(this, a2, a3);
  v14[1] = v4;
  v11[0] = (float64x2_t)xmmword_2142181C0;
  v11[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  RB::DisplayList::ShadowStyle::bounds((float64x2_t **)this, v14, v11, 0);
  RB::Rect::move_identity(v14, v11);
  uint64_t v9 = *((void *)this + 3);
  if (v9) {
    RB::Rect::intersect(v14, *(double *)(v9 + 16), *(float32x2_t *)(v9 + 24), v5, v6, v7, v8);
  }
  return *(double *)v14;
}

float32x2_t RB::DisplayList::Style::next_bounds(RB::DisplayList::Style *this, const RB::DisplayList::Item *a2, uint64_t a3)
{
  uint64_t v4 = *((void *)this + 4);
  if (v4)
  {
    (*(void (**)(uint64_t, const RB::DisplayList::Item *))(*(void *)v4 + 48))(v4, a2);
  }
  else
  {
    *(double *)&float32x2_t result = (*(double (**)(const RB::DisplayList::Item *, uint64_t))(*(void *)a2 + 144))(a2, a3);
    v12[0] = result;
    v12[1] = v10;
    uint64_t v11 = *((void *)a2 + 3);
    if (v11)
    {
      RB::Rect::intersect(v12, *(double *)(v11 + 16), *(float32x2_t *)(v11 + 24), v6, v7, v8, v9);
      return v12[0];
    }
  }
  return result;
}

uint64_t RB::DisplayList::ShadowStyle::matches(RB::DisplayList::ShadowStyle *this, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::DisplayList::Predicate::matches_color(a2, (RB::DisplayList::ShadowStyle *)((char *)this + 72), a3) | 0x100;
}

uint64_t RB::DisplayList::ShadowStyle::apply_predicate(uint64_t this, const InvertiblePredicate *a2, int a3)
{
  if (a3) {
    *(_DWORD *)(this + 88) |= 2u;
  }
  return this;
}

uint64_t RB::DisplayList::ShadowStyle::can_mix(float32x2_t *this, RB::DisplayList::Interpolator::Contents *a2, float32x2_t *a3)
{
  if (a3)
  {
    if (this[10].i32[1] == a3[10].i32[1] && this[11].i32[0] == a3[11].i32[0])
    {
      uint64_t result = RB::Fill::Color::can_mix((RB::Fill::Color *)&this[9], (const RB::Fill::Color *)&a3[9]);
      uint32x2_t v6 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(this[7], a3[7]));
      if ((vpmax_u32(v6, v6).u32[0] & 0x80000000) != 0 || this[8].f32[0] != a3[8].f32[0]) {
        return result != 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    __asm { FCMP            H0, #0 }
    if (_ZF) {
      return 4;
    }
    else {
      return 1;
    }
  }
  return result;
}

uint64_t RB::DisplayList::ShadowStyle::mix(RB::DisplayList::ShadowStyle *this, const RB::DisplayList::Interpolator::State *a2, float32x2_t *a3, const RB::DisplayList::CachedTransform *a4)
{
  _ZN2RB4Heap7emplaceINS_11DisplayList11ShadowStyleEJRKfS5_RKDv2_fRKNS_4Fill5ColorERKNS_9BlendModeERKjEEEPT_DpOT0_((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), (float *)this + 16, (int *)this + 17, (uint64_t *)this + 7, (uint64_t *)this + 9, (int *)this + 21, (int *)this + 22);
  uint64_t v7 = v6;
  if (a3)
  {
    float32x2_t v8 = *(float32x2_t *)(v6 + 64);
    *(float32x2_t *)(v6 + 56) = vmla_n_f32(*(float32x2_t *)(v6 + 56), vsub_f32(a3[7], *(float32x2_t *)(v6 + 56)), COERCE_FLOAT(*((void *)a2 + 2)));
    float v9 = *((float *)a2 + 4);
    *(float32x2_t *)(v6 + 64) = vmla_n_f32(v8, vsub_f32(a3[8], v8), v9);
    RB::Fill::Color::mix(v6 + 72, (uint64_t)&a3[9], 0, v9);
  }
  else
  {
    _S1 = *((_DWORD *)a2 + 4);
    __asm { FCVT            H1, S1 }
    *(short float *)(v6 + 78) = *(short float *)(v6 + 78)
                              - (short float)(*(short float *)(v6 + 78) * *(short float *)&_S1);
  }
  return v7;
}

void RB::DisplayList::ShadowStyle::print(float32x2_t *this, std::string *a2)
{
  RB::SexpString::push(a2, "shadow");
  RB::SexpString::printf(a2, 1, "(radius %g)", this[8].f32[0]);
  float v4 = this[8].f32[1];
  if (v4 != 0.5) {
    RB::SexpString::printf(a2, 1, "(midpoint %g)", v4);
  }
  float32x2_t v5 = this[7];
  uint32x2_t v6 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(v5));
  if ((vpmax_u32(v6, v6).u32[0] & 0x80000000) != 0) {
    RB::SexpString::printf(a2, 1, "(offset %g %g)", v5.f32[0], v5.f32[1]);
  }
  RB::Fill::Color::print((RB::Fill::Color *)&this[9], a2);
  unsigned int v7 = this[10].u32[1];
  if (v7 != 2)
  {
    float32x2_t v8 = RB::blend_name(v7);
    RB::SexpString::printf(a2, 1, "(blend %s)", v8);
  }
  if (this[11].i32[0])
  {
    RB::SexpString::push(a2, "flags");
    __int32 v9 = this[11].i32[0];
    if (v9)
    {
      RB::SexpString::print(a2, 0, "above");
      __int32 v9 = this[11].i32[0];
      if ((v9 & 2) == 0)
      {
LABEL_10:
        if ((v9 & 4) == 0) {
          goto LABEL_11;
        }
        goto LABEL_20;
      }
    }
    else if ((v9 & 2) == 0)
    {
      goto LABEL_10;
    }
    RB::SexpString::print(a2, 0, "only");
    __int32 v9 = this[11].i32[0];
    if ((v9 & 4) == 0)
    {
LABEL_11:
      if ((v9 & 8) == 0) {
        goto LABEL_12;
      }
      goto LABEL_21;
    }
LABEL_20:
    RB::SexpString::print(a2, 0, "inverse");
    __int32 v9 = this[11].i32[0];
    if ((v9 & 8) == 0)
    {
LABEL_12:
      if ((v9 & 0x10) == 0)
      {
LABEL_14:
        RB::SexpString::pop(a2);
        goto LABEL_15;
      }
LABEL_13:
      RB::SexpString::print(a2, 0, "dither");
      goto LABEL_14;
    }
LABEL_21:
    RB::SexpString::print(a2, 0, "no-layer");
    if ((this[11].i32[0] & 0x10) == 0) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
LABEL_15:
  RB::DisplayList::Style::print((const RB::AffineTransform **)this, a2);
  RB::SexpString::pop(a2);
}

void RB::DisplayList::Style::print(const RB::AffineTransform **this, std::string *a2)
{
  RB::SexpString::print_ctm(a2, this[2]);
  for (unint64_t i = this[3]; i; unint64_t i = *(const RB::AffineTransform **)i)
    (*(void (**)(unint64_t, std::string *))(*(void *)(*((void *)i + 1) & 0xFFFFFFFFFFFFFFFELL)
                                                            + 128))(*((void *)i + 1) & 0xFFFFFFFFFFFFFFFELL, a2);
  if (*((_DWORD *)this + 12)) {
    RB::SexpString::printf(a2, 0, "(identifier %u)", *((_DWORD *)this + 12));
  }
  if (*((unsigned char *)this + 52))
  {
    RB::SexpString::print(a2, 0, "disable-mix");
  }
}

double RB::DisplayList::State::add_shadow(__n128 *a1, RB::DisplayList::Builder *a2, uint64_t *a3, int a4, int a5, float a6, float a7, double a8)
{
  float v16 = a6;
  float v15 = a7;
  double v14 = a8;
  int v12 = a5;
  int v13 = a4;
  _ZN2RB4Heap7emplaceINS_11DisplayList11ShadowStyleEJRKfS5_RKDv2_fRKNS_4Fill5ColorERKNS_9BlendModeERKjEEEPT_DpOT0_((RB::Heap *)(*((void *)a2 + 1) + 16), &v16, (int *)&v15, (uint64_t *)&v14, a3, &v13, &v12);
  *(void *)&double result = RB::DisplayList::State::add_style(a1, a2, v10).n128_u64[0];
  return result;
}

void *RB::DisplayList::ProjectionStyle::encode(RB::DisplayList::ProjectionStyle *this, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x3AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProjectionMatrix::encode((void *)this + 7, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

double RB::DisplayList::State::add_projection_matrix(__n128 *this, RB::DisplayList::Builder *a2, const RB::ProjectionMatrix *a3)
{
  RB::Heap::emplace<RB::DisplayList::ProjectionStyle,RB::ProjectionMatrix const&>((RB::Heap *)(*((void *)a2 + 1) + 16), (uint64_t)a3);
  *(void *)&double result = RB::DisplayList::State::add_style(this, a2, v5).n128_u64[0];
  return result;
}

__n128 RB::Heap::emplace<RB::DisplayList::ProjectionStyle,RB::ProjectionMatrix const&>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 96 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x60uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 96;
  }
  *(void *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4E8578;
  __n128 result = *(__n128 *)a2;
  long long v7 = *(_OWORD *)(a2 + 16);
  *(_DWORD *)(v5 + 88) = *(_DWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 72) = v7;
  *(__n128 *)(v5 + 56) = result;
  *(void *)unint64_t v5 = &unk_26C4EC338;
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::Builder::affine_style_draw(RB::DisplayList::Builder *this, RB::DisplayList::Layer *a2, RB::DisplayList::Item *a3, char a4, float64x2_t *a5, const RB::AffineTransform *a6, const RB::DisplayList::ClipNode *a7)
{
  v33[14] = *MEMORY[0x263EF8340];
  long long v14 = *((_OWORD *)a6 + 1);
  float64x2_t v29 = *(float64x2_t *)a6;
  long long v30 = v14;
  long long v31 = *((_OWORD *)a6 + 2);
  if (RB::AffineTransform::invert((RB::AffineTransform *)&v29)) {
    float v15 = &v29;
  }
  else {
    float v15 = (float64x2_t *)a6;
  }
  float64x2_t v16 = v15[1];
  float64x2_t v17 = v15[2];
  v27[0] = *v15;
  v27[1] = v16;
  v27[2] = v17;
  v18.f64[0] = RB::operator*(v27, a5);
  float64x2_t v29 = v18;
  long long v30 = v19;
  long long v31 = v20;
  v21.f64[0] = RB::operator*(&v29, (float64x2_t *)a6);
  v28[0] = (__int128)v21;
  v28[1] = (__int128)v22;
  Point v28[2] = (__int128)v23;
  int64x2_t v24 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v22, (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(v21, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(v23));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v24, 1), (int8x16_t)v24).u64[0] & 0x8000000000000000) == 0)
  {
    uint64_t v25 = *((void *)a3 + 2);
    *((void *)a3 + 2) = 0;
    RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v29, (uint64_t)this, v28, 0, 0, 0);
    (*(void (**)(RB::DisplayList::Item *, float64x2_t *, void))(*(void *)a3 + 32))(a3, &v29, 0);
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v33);
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v32);
    RB::Heap::~Heap((RB::Heap *)&v29.f64[1]);
    *((void *)a3 + 2) = v25;
  }
  *((void *)a3 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)this, *((void **)a3 + 3), a7);
  return RB::DisplayList::Builder::draw(this, a3, a2, a4);
}

void sub_2141D2130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

void RB::DisplayList::affine_style_roi(RB::DisplayList *this, float64x2_t *a2, float64x2_t *a3, int8x16_t *a4, const RB::AffineTransform *a5)
{
  uint32x2_t v5 = (uint32x2_t)vcge_f32((float32x2_t)(*((void *)this + 1) & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) == 0)
  {
    int8x16_t v9 = a4[1];
    int8x16_t v28 = *a4;
    int8x16_t v29 = v9;
    int8x16_t v30 = a4[2];
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v28)) {
      float32x2_t v10 = &v28;
    }
    else {
      float32x2_t v10 = a4;
    }
    float64x2_t v11 = (float64x2_t)v10[1];
    float64x2_t v12 = (float64x2_t)v10[2];
    v27[0] = *(float64x2_t *)v10;
    v27[1] = v11;
    v27[2] = v12;
    *(double *)v13.i64 = RB::operator*(v27, a3);
    int8x16_t v28 = v13;
    int8x16_t v29 = v14;
    int8x16_t v30 = v15;
    *(double *)v16.i64 = RB::operator*((float64x2_t *)&v28, (float64x2_t *)a4);
    int8x16_t v24 = v17;
    int8x16_t v25 = v16;
    int8x16_t v26 = v18;
    int8x16_t v28 = v16;
    int8x16_t v29 = v17;
    int8x16_t v30 = v18;
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v28)) {
      unint64_t v19 = -1;
    }
    else {
      unint64_t v19 = 0;
    }
    int8x16_t v20 = (int8x16_t)vdupq_n_s64(v19);
    int8x16_t v28 = vbslq_s8(v20, v28, v25);
    int8x16_t v29 = vbslq_s8(v20, v29, v24);
    int8x16_t v30 = vbslq_s8(v20, v30, v26);
    v21.f64[0] = RB::operator*(a2, (float64x2_t *)&v28);
    *a2 = v21;
    a2[1] = v22;
    a2[2] = v23;
  }
}

double RB::DisplayList::affine_style_bounds(float64x2_t **this, const RB::DisplayList::Style *a2, const RB::DisplayList::Item *a3, float64x2_t *a4, const RB::AffineTransform *a5)
{
  float32x2_t bounds = RB::DisplayList::Style::next_bounds((RB::DisplayList::Style *)this, a2, (uint64_t)a3);
  float32x2_t v13 = v12;
  float32x2_t v32 = bounds;
  float32x2_t v33 = v12;
  uint32x2_t v14 = (uint32x2_t)vcge_f32(vabs_f32(v12), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if ((vpmax_u32(v14, v14).u32[0] & 0x80000000) == 0)
  {
    int8x16_t v15 = this[2];
    float64x2_t v16 = *v15;
    float64x2_t v17 = v15[2];
    int32x4_t v35 = (int32x4_t)v15[1];
    float64x2_t v36 = v17;
    float64x2_t v34 = v16;
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v34)) {
      int8x16_t v18 = &v34;
    }
    else {
      int8x16_t v18 = v15;
    }
    float64x2_t v19 = v18[1];
    float64x2_t v20 = v18[2];
    v30[0] = *v18;
    v30[1] = v19;
    Point v30[2] = v20;
    v21.f64[0] = RB::operator*(v30, a4);
    v31[0] = v21;
    v31[1] = v22;
    Point v31[2] = v23;
    v24.f64[0] = RB::operator*(v31, this[2]);
    float64x2_t v34 = v24;
    int32x4_t v35 = v25;
    float64x2_t v36 = v26;
    *(float32x2_t *)v25.i8 = v13;
    float32x2_t bounds = RB::operator*(&v34, bounds, v25);
    float32x2_t v32 = bounds;
    float32x2_t v33 = v27;
  }
  int8x16_t v28 = this[3];
  if (v28)
  {
    RB::Rect::intersect(&v32, v28[1].f64[0], *(float32x2_t *)&v28[1].f64[1], v7, v8, v9, v10);
    float32x2_t bounds = v32;
  }
  return *(double *)&bounds;
}

RB::DisplayList::Builder *RB::DisplayList::Builder::projection_style_draw(size_t **this, RB::DisplayList::Layer *a2, RB::DisplayList::Item *a3, char a4, const RB::ProjectionMatrix *a5, float64x2_t *a6, const RB::DisplayList::ClipNode *a7)
{
  if (RB::may_discard_alpha(*((_WORD *)a3 + 23) & 0x3F)
    && *((float *)a5 + 2) == 0.0
    && (*((float *)a5 + 5) == 0.0 ? (BOOL v14 = *((float *)a5 + 8) == 1.0) : (BOOL v14 = 0), v14))
  {
    float64x2_t v15 = vcvtq_f64_f32(*(float32x2_t *)((char *)a5 + 12));
    float64x2_t v16 = vcvtq_f64_f32(*(float32x2_t *)((char *)a5 + 24));
    float64x2_t v35 = vcvtq_f64_f32(*(float32x2_t *)a5);
    float64x2_t v36 = v15;
    float64x2_t v37 = v16;
    return RB::DisplayList::Builder::affine_style_draw((RB::DisplayList::Builder *)this, a2, a3, a4, &v35, (const RB::AffineTransform *)a6, a7);
  }
  else
  {
    float64x2_t v18 = a6[1];
    float64x2_t v35 = *a6;
    float64x2_t v36 = v18;
    float64x2_t v37 = a6[2];
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v35)) {
      float64x2_t v19 = (float32x4_t *)&v35;
    }
    else {
      float64x2_t v19 = (float32x4_t *)a6;
    }
    float32x4_t v20 = v19[1];
    float32x4_t v21 = v19[2];
    float64x2_t v35 = *(float64x2_t *)v19;
    float64x2_t v36 = (float64x2_t)v20;
    float64x2_t v37 = (float64x2_t)v21;
    RB::operator*(&v35, (uint64_t)a5, (uint64_t)v31);
    RB::operator*(v31, a6, (uint64_t)&v32);
    float64x2_t v22 = RB::DisplayList::Builder::ensure_layer((RB::DisplayList::Builder *)this, a3, 0.0, 10);
    uint64_t v26 = *((void *)v22 + 6);
    if (*(unsigned char *)(v26 + 64) == 1)
    {
      RB::operator*(*(void *)(v26 + 24), (uint64_t)&v32, (float32x4_t *)&v35, v23, v24, v25);
      float32x4_t v32 = (float32x4_t)v35;
      float64x2_t v33 = v36;
      int v34 = LODWORD(v37.f64[0]);
    }
    *(unsigned char *)(v26 + 64) = 1;
    float32x2_t v27 = this[1];
    unint64_t v28 = (v27[4] + 3) & 0xFFFFFFFFFFFFFFFCLL;
    if (v28 + 36 > v27[5]) {
      unint64_t v28 = RB::Heap::alloc_slow(v27 + 2, 0x24uLL, 3);
    }
    else {
      v27[4] = v28 + 36;
    }
    float32x4_t v29 = v32;
    float64x2_t v30 = v33;
    *(_DWORD *)(v28 + 32) = v34;
    *(float32x4_t *)unint64_t v28 = v29;
    *(float64x2_t *)(v28 + 16) = v30;
    *(void *)(v26 + 24) = v28;
    *((void *)v22 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)this, *((void **)v22 + 3), a7);
    return RB::DisplayList::Builder::draw((RB::DisplayList::Builder *)this, v22, a2, a4);
  }
}

float32x2_t RB::DisplayList::projection_style_roi(float32x2_t *this, float64x2_t *a2, RB::AffineTransform *a3, float64x2_t *a4, const RB::AffineTransform *a5)
{
  uint32x2_t v5 = (uint32x2_t)vcge_f32((float32x2_t)(*(void *)&this[1] & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  float32x2_t result = (float32x2_t)vpmax_u32(v5, v5);
  if ((result.i32[0] & 0x80000000) == 0)
  {
    RB::Rect::move(this, a2, a4);
    if (!RB::unapply(this, a3, v9))
    {
      float32x2_t result = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
      *this = (float32x2_t)0x100000001000000;
      this[1] = result;
    }
  }
  return result;
}

double RB::DisplayList::projection_style_bounds(float64x2_t **this, const RB::DisplayList::Style *a2, const RB::DisplayList::Item *a3, uint64_t a4, const RB::ProjectionMatrix *a5)
{
  float32x2_t bounds = RB::DisplayList::Style::next_bounds((RB::DisplayList::Style *)this, a2, (uint64_t)a3);
  float32x2_t v13 = v12;
  float32x2_t v28 = bounds;
  float32x2_t v29 = v12;
  uint32x2_t v14 = (uint32x2_t)vcge_f32(vabs_f32(v12), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if ((vpmax_u32(v14, v14).u32[0] & 0x80000000) == 0)
  {
    float64x2_t v15 = this[2];
    float64x2_t v16 = *v15;
    float64x2_t v17 = v15[2];
    int32x4_t v31 = (int32x4_t)v15[1];
    float64x2_t v32 = v17;
    float64x2_t v30 = v16;
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v30)) {
      float64x2_t v18 = &v30;
    }
    else {
      float64x2_t v18 = v15;
    }
    int32x4_t v19 = (int32x4_t)v18[1];
    float64x2_t v20 = v18[2];
    float64x2_t v30 = *v18;
    int32x4_t v31 = v19;
    float64x2_t v32 = v20;
    *(float32x2_t *)v19.i8 = v13;
    *(float32x2_t *)&double v21 = RB::operator*(&v30, bounds, v19);
    float32x2_t v23 = RB::operator*(a4, v21, v22);
    float32x2_t bounds = RB::operator*(this[2], v23, v24);
    float32x2_t v28 = bounds;
    float32x2_t v29 = v25;
  }
  uint64_t v26 = this[3];
  if (v26)
  {
    RB::Rect::intersect(&v28, v26[1].f64[0], *(float32x2_t *)&v26[1].f64[1], v7, v8, v9, v10);
    float32x2_t bounds = v28;
  }
  return *(double *)&bounds;
}

double RB::DisplayList::State::add_path_projection(uint64_t a1, RB::DisplayList::Builder *a2, uint64_t a3, uint64_t a4, float64x2_t *a5, int a6, __n128 a7, __n128 a8)
{
  v20[0] = a3;
  v20[1] = a4;
  __n128 v19 = a7;
  __n128 v18 = a8;
  int v17 = a6;
  float64x2_t v11 = (RB::DisplayList::Style *)_ZN2RB4Heap7emplaceINS_11DisplayList19PathProjectionStyleEJRDv2_dS5_R6RBPathRjEEEPT_DpOT0_((size_t *)(*((void *)a2 + 1) + 16), (long long *)&v19, (long long *)&v18, v20, &v17);
  int64x2_t v12 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a5[1], (float64x2_t)xmmword_2142181D0), (int8x16_t)vceqq_f64(*a5, (float64x2_t)xmmword_2142181C0)), (int8x16_t)vceqzq_f64(a5[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v12, 1), (int8x16_t)v12).u64[0] & 0x8000000000000000) != 0)
  {
    *(void *)&double result = RB::DisplayList::State::add_style((__n128 *)a1, a2, v11).n128_u64[0];
  }
  else
  {
    long long v14 = *(_OWORD *)(a1 + 16);
    long long v15 = *(_OWORD *)(a1 + 32);
    long long v16 = *(_OWORD *)(a1 + 48);
    RB::DisplayList::State::concat((float64x2_t *)a1, a5);
    RB::DisplayList::State::add_style((__n128 *)a1, a2, v11);
    *(_OWORD *)(a1 + 16) = v14;
    *(_OWORD *)(a1 + 32) = v15;
    double result = *(double *)&v16;
    *(_OWORD *)(a1 + 48) = v16;
    *(void *)(a1 + 112) = 0;
    *(_DWORD *)(a1 + 148) = -1;
  }
  return result;
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList19PathProjectionStyleEJRDv2_dS5_R6RBPathRjEEEPT_DpOT0_(size_t *a1, long long *a2, long long *a3, uint64_t *a4, int *a5)
{
  unint64_t v9 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v9 + 128 > a1[3]) {
    unint64_t v9 = RB::Heap::alloc_slow(a1, 0x80uLL, 15);
  }
  else {
    a1[2] = v9 + 128;
  }
  long long v10 = *a2;
  long long v11 = *a3;
  uint64_t v12 = *a4;
  uint64_t v13 = a4[1];
  int v14 = *a5;
  *(void *)(v9 + 48) = 0;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + 32) = 0u;
  *(void *)unint64_t v9 = &unk_26C4ECBB8;
  *(_OWORD *)(v9 + 64) = v10;
  *(_OWORD *)(v9 + 80) = v11;
  *(void *)(v9 + 96) = RBPathRetain(v12, v13);
  *(void *)(v9 + 104) = v15;
  *(_DWORD *)(v9 + 112) = v14;
  return v9;
}

uint64_t RB::DisplayList::PathProjectionStyle::PathProjectionStyle(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)a1 = &unk_26C4ECBB8;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(void *)(a1 + 96) = RBPathRetain(*(void *)(a2 + 96), *(void *)(a2 + 104));
  *(void *)(a1 + 104) = v4;
  *(_DWORD *)(a1 + 112) = *(_DWORD *)(a2 + 112);
  return a1;
}

uint64_t RB::DisplayList::PathProjectionStyle::copy(RB::DisplayList::PathProjectionStyle *this, RB::DisplayList::Builder *a2)
{
  return RB::Heap::emplace<RB::DisplayList::PathProjectionStyle,RB::DisplayList::PathProjectionStyle const&>((size_t *)(*((void *)a2 + 1) + 16), (uint64_t)this);
}

uint64_t RB::Heap::emplace<RB::DisplayList::PathProjectionStyle,RB::DisplayList::PathProjectionStyle const&>(size_t *a1, uint64_t a2)
{
  uint64_t v3 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 128 > a1[3]) {
    uint64_t v3 = RB::Heap::alloc_slow(a1, 0x80uLL, 15);
  }
  else {
    a1[2] = v3 + 128;
  }
  return RB::DisplayList::PathProjectionStyle::PathProjectionStyle(v3, a2);
}

void RB::DisplayList::PathProjectionStyle::draw(RB::DisplayList::PathProjectionStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  int v10 = *((_DWORD *)this + 28);
  if (v10)
  {
    (*(void (**)(RB::DisplayList::Item *, void))(*(void *)a4 + 128))(a4, *((void *)this + 2));
    int v10 = *((_DWORD *)this + 28);
  }
  float64x2_t v11 = *((float64x2_t *)this + 4);
  float64x2_t v12 = *((float64x2_t *)this + 5);
  v16[0] = (void (**)(void))&unk_26C4ED7B0;
  float64x2_t v17 = v11;
  float64x2_t v18 = vsubq_f64(v12, v11);
  int v19 = v10;
  long long v20 = 0u;
  uint64_t v21 = 16;
  long long v22 = 0u;
  long long v23 = 0u;
  int v24 = 0;
  RBPathMap(*((CGPathRef *)this + 12), *((void **)this + 13), v16, 0);
  *((void *)a4 + 1) = 0;
  uint64_t v13 = (RB::DisplayList::Item *)(*(uint64_t (**)(RB::DisplayList::Item *, RB::DisplayList::Builder *, void (***)(void), void))(*(void *)a4 + 232))(a4, a2, v16, *((void *)this + 2));
  v15[0] = *((void *)this + 3);
  v15[1] = 0;
  int32x2_t v15[2] = v15[0];
  while (v13)
  {
    int v14 = (RB::DisplayList::Item *)*((void *)v13 + 1);
    *((void *)v13 + 2) = *((void *)this + 4);
    RB::DisplayList::Builder::MemoizedAddClip::operator()((uint64_t)v15, (uint64_t)a2, (uint64_t)v13);
    RB::DisplayList::Builder::draw(a2, v13, a3, a5);
    uint64_t v13 = v14;
  }
  if ((void)v20) {
    free((void *)v20);
  }
}

void sub_2141D2ADC(_Unwind_Exception *a1)
{
  if (STACK[0x2D8]) {
    free((void *)STACK[0x2D8]);
  }
  _Unwind_Resume(a1);
}

int32x2_t RB::DisplayList::PathProjectionStyle::map_roi(RB::DisplayList::PathProjectionStyle *this, int32x2_t *a2, RB::AffineTransform *a3)
{
  int32x2_t result = vdup_n_s32(0x7F7FFFFFu);
  *a2 = (int32x2_t)0x100000001000000;
  a2[1] = result;
  return result;
}

double RB::DisplayList::PathProjectionStyle::bounds(RB::DisplayList::PathProjectionStyle *this, const RB::DisplayList::Item *a2, uint64_t a3)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  if (a3)
  {
    float64x2_t v8 = *((float64x2_t *)this + 4);
    float64x2_t v9 = *((float64x2_t *)this + 5);
    int v10 = *((_DWORD *)this + 28);
    v28[0] = (void (**)(void))&unk_26C4ED7B0;
    float64x2_t v29 = v8;
    float64x2_t v30 = vsubq_f64(v9, v8);
    int v31 = v10;
    long long v32 = 0u;
    uint64_t v33 = 16;
    long long v34 = 0u;
    long long v35 = 0u;
    int v36 = 0;
    RBPathMap(*((CGPathRef *)this + 12), *((void **)this + 13), v28, 0);
    RB::DisplayList::Builder::Builder((RB::DisplayList::Builder *)v26);
    if (!v27) {
      RB::DisplayList::Builder::reset_contents((RB::DisplayList::Builder *)v26);
    }
    uint64_t v11 = (*(uint64_t (**)(const RB::DisplayList::Item *, unsigned char *, void))(*(void *)a2 + 24))(a2, v26, 0);
    float64x2_t v12 = (const RB::DisplayList::Item *)(*(uint64_t (**)(uint64_t, unsigned char *, void (***)(void), void))(*(void *)v11 + 232))(v11, v26, v28, *((void *)this + 2));
    v25[0] = 0;
    for (v25[1] = 0; v12; float64x2_t v12 = (const RB::DisplayList::Item *)*((void *)v12 + 1))
    {
      *(float32x2_t *)&double v17 = RB::DisplayList::Style::next_bounds(this, v12, a3);
      RB::Rect::Union(v25, v17, v18, v19, v20, v21, v22);
    }
    uint64_t v23 = *((void *)this + 3);
    if (v23) {
      RB::Rect::intersect(v25, *(double *)(v23 + 16), *(float32x2_t *)(v23 + 24), v13, v14, v15, v16);
    }
    RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)v26);
    if ((void)v32) {
      free((void *)v32);
    }
    uint32x2_t v5 = v25;
  }
  else
  {
    uint64_t v4 = (float32x2_t *)*((void *)this + 3);
    if (!v4) {
      return 7.29112205e-304;
    }
    uint32x2_t v5 = v4 + 2;
  }
  return *(double *)v5;
}

void sub_2141D2CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)va);
  if (STACK[0x3E8]) {
    free((void *)STACK[0x3E8]);
  }
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::PathProjectionStyle::can_mix(RB::DisplayList::PathProjectionStyle *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Style *a3)
{
  if (!a3) {
    return 0;
  }
  if (*((_DWORD *)this + 28) != *((_DWORD *)a3 + 28)) {
    return 0;
  }
  v7.info = (void *)*((void *)this + 12);
  v7.int callbacks = (RBPathCallbacks *)*((void *)this + 13);
  v8.info = (void *)*((void *)a3 + 12);
  v8.int callbacks = (RBPathCallbacks *)*((void *)a3 + 13);
  LODWORD(result) = RBPathCanMix(v7, v8);
  int64x2_t v6 = (int64x2_t)vornq_s8(vmvnq_s8((int8x16_t)vceqq_f64(*((float64x2_t *)this + 5), *((float64x2_t *)a3 + 5))), (int8x16_t)vceqq_f64(*((float64x2_t *)this + 4), *((float64x2_t *)a3 + 4)));
  if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v6, 1), (int8x16_t)v6).i64[0] >= 0) {
    return result;
  }
  else {
    return result != 0;
  }
}

float64x2_t *RB::DisplayList::PathProjectionStyle::mix(float64x2_t *this, const RB::DisplayList::Interpolator::State *a2, float64x2_t *a3, const RB::DisplayList::CachedTransform *a4)
{
  if (!a3) {
    return 0;
  }
  RB::Heap::emplace<RB::DisplayList::PathProjectionStyle>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16));
  RBPath v8 = v7;
  Point v7[4] = vmlaq_n_f64(this[4], vsubq_f64(a3[4], this[4]), *((float *)a2 + 4));
  v7[5] = vmlaq_n_f64(this[5], vsubq_f64(a3[5], this[5]), *((float *)a2 + 4));
  float64_t v9 = this[6].f64[0];
  int v10 = *(RBPathCallbacks **)&this[6].f64[1];
  float64_t v11 = a3[6].f64[0];
  float64x2_t v12 = *(RBPathCallbacks **)&a3[6].f64[1];
  float v13 = *((float *)a2 + 4);
  double v14 = *(CGAffineTransform **)&this[1].f64[0];
  double v15 = *(float64x2_t **)&a3[1].f64[0];
  RB::mix(v14, v15, v16, v13);
  v23[0] = v17;
  v23[1] = v18;
  void v23[2] = v19;
  *(float64_t *)&v25.info = v9;
  v25.int callbacks = v10;
  *(float64_t *)&v26.info = v11;
  v26.int callbacks = v12;
  RBPathMix(v25, v26, v13, (float64x2_t *)v14, v15, v23, &v24);
  uint64_t v20 = *(void *)&v8[6].f64[0];
  uint64_t v21 = *(void *)&v8[6].f64[1];
  v8[6] = v24;
  *(void *)&v24.f64[0] = v20;
  *(void *)&v24.f64[1] = v21;
  RBPathRelease(v20, v21);
  LODWORD(v8[7].f64[0]) = LODWORD(a3[7].f64[0]);
  return v8;
}

double RB::Heap::emplace<RB::DisplayList::PathProjectionStyle>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 128 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x80uLL, 15);
  }
  else {
    *((void *)this + 2) = v3 + 128;
  }
  *(void *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4ECBB8;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  double result = *(double *)&RBPathEmpty;
  *(_OWORD *)(v3 + 96) = RBPathEmpty;
  *(_DWORD *)(v3 + 112) = 0;
  return result;
}

void *RB::DisplayList::PathProjectionStyle::encode(RB::DisplayList::PathProjectionStyle *this, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x2AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::float2_field(a2, 1, COERCE_DOUBLE(vcvt_f32_f64(*((float64x2_t *)this + 4))));
  RB::ProtobufEncoder::float2_field(a2, 2, COERCE_DOUBLE(vcvt_f32_f64(*((float64x2_t *)this + 5))));
  if (*((void *)this + 13) != 0x21421C340)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RBPathEncode(*((RBPath *)this + 6), a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  int v4 = *((_DWORD *)this + 28);
  if (v4)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
    RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    int v4 = *((_DWORD *)this + 28);
  }
  unint64_t v5 = v4 & 0x1E;
  if ((v4 & 0x1E) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
    RB::ProtobufEncoder::encode_varint(a2, v5);
  }
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

unint64_t RB::DisplayList::PathProjectionStyle::decode(float64x2_t *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v6 = result;
    do
    {
      switch((v6 >> 3))
      {
        case 1u:
          this[4] = vcvtq_f64_f32((float32x2_t)RB::ProtobufDecoder::float2_field(a2, v6, v5).n128_u64[0]);
          break;
        case 2u:
          this[5] = vcvtq_f64_f32((float32x2_t)RB::ProtobufDecoder::float2_field(a2, v6, v5).n128_u64[0]);
          break;
        case 3u:
          if ((v6 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            RBPathDecode(a2);
          }
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
          break;
        case 4u:
          int v7 = LODWORD(this[7].f64[0]) | RB::ProtobufDecoder::BOOL_field(a2, v6);
          goto LABEL_11;
        case 5u:
          LODWORD(this[7].f64[0]) &= 0xFFFFFFE1;
          int v7 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, v6) & 0x1E | LODWORD(this[7].f64[0]);
LABEL_11:
          LODWORD(this[7].f64[0]) = v7;
          break;
        default:
          RB::ProtobufDecoder::skip_field(a2, v6);
          break;
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v6 = result;
    }
    while (result);
  }
  return result;
}

void RB::DisplayList::PathProjectionStyle::print(const RB::AffineTransform **this, std::string *a2)
{
  RB::SexpString::print(a2, 0, "path-projection");
  RB::DisplayList::Style::print(this, a2);
}

double RB::DisplayList::State::add_alpha_threshold(__n128 *a1, RB::DisplayList::Builder *a2, uint64_t a3, __int16 a4, double a5)
{
  uint64_t v13 = a3;
  __int16 v14 = a4;
  double v12 = a5;
  int v7 = (RB::Heap *)(*((void *)a2 + 1) + 16);
  _ZN2RB4Heap7emplaceINS_11DisplayList13GenericEffectINS_20AlphaThresholdEffectEEEJRDv2_fRNS_4Fill5ColorEEEEPT_DpOT0_(v7, &v12, &v13);
  uint64_t v11 = v8;
  RB::Heap::emplace<RB::DisplayList::AlphaThresholdStyle,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> *&>(v7, &v11);
  *(void *)&double result = RB::DisplayList::State::add_style(a1, a2, v9).n128_u64[0];
  return result;
}

double _ZN2RB4Heap7emplaceINS_11DisplayList13GenericEffectINS_20AlphaThresholdEffectEEEJRDv2_fRNS_4Fill5ColorEEEEPT_DpOT0_(RB::Heap *this, double *a2, uint64_t *a3)
{
  unint64_t v6 = *((void *)this + 3);
  unint64_t v7 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v7 + 48 > v6) {
    unint64_t v7 = RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 7);
  }
  else {
    *((void *)this + 2) = v7 + 48;
  }
  *(void *)unint64_t v7 = &unk_26C4EBDE0;
  double result = *a2;
  uint64_t v9 = *a3;
  __int16 v10 = *((_WORD *)a3 + 4);
  *(double *)(v7 + 16) = *a2;
  *(void *)(v7 + 24) = v9;
  *(_WORD *)(v7 + 32) = v10;
  *(unsigned char *)(v7 + 40) = 1;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::AlphaThresholdStyle,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> *&>(RB::Heap *this, uint64_t *a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 64;
  }
  uint64_t v6 = *a2;
  *(void *)(v5 + 48) = 0;
  *(void *)(v5 + 56) = v6;
  double result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4EC998;
  return result;
}

double RB::DisplayList::AlphaThresholdStyle::copy(RB::DisplayList::AlphaThresholdStyle *this, RB::DisplayList::Builder *a2)
{
  RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>,RB::AlphaThresholdEffect const&,RB::DisplayList::Contents &>((RB::Heap *)(*((void *)a2 + 1) + 16), (__n128 *)(*((void *)this + 7) + 16));
  uint64_t v5 = v3;
  return RB::Heap::emplace<RB::DisplayList::AlphaThresholdStyle,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> *&>((RB::Heap *)(*((void *)a2 + 1) + 16), &v5);
}

__n128 RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>,RB::AlphaThresholdEffect const&,RB::DisplayList::Contents &>(RB::Heap *this, __n128 *a2)
{
  unint64_t v4 = *((void *)this + 3);
  uint64_t v5 = (__n128 *)((*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)v5[3].n128_u64 > v4) {
    uint64_t v5 = (__n128 *)RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 3;
  }
  v5->n128_u64[0] = (unint64_t)&unk_26C4EBDE0;
  __n128 result = *a2;
  v5[2].n128_u16[0] = a2[1].n128_u16[0];
  v5[1] = result;
  v5[2].n128_u8[8] = 1;
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::AlphaThresholdStyle::draw(RB::DisplayList::AlphaThresholdStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  uint64_t v9 = RB::DisplayList::Builder::ensure_layer(a2, a4, 0.0, 160);
  __int16 v10 = (const RB::DisplayList::ClipNode *)*((void *)this + 3);
  *((void *)v9 + 2) = *((void *)this + 4);
  *((void *)v9 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, *((void **)v9 + 3), v10);
  uint64_t v11 = *((void *)v9 + 6);
  *(unsigned char *)(v11 + 64) = 2;
  *(void *)(v11 + 24) = *((void *)this + 7);
  return RB::DisplayList::Builder::draw(a2, v9, a3, a5);
}

uint64_t RB::DisplayList::AlphaThresholdStyle::can_mix(RB::DisplayList::AlphaThresholdStyle *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Style *a3)
{
  if (a3) {
    return RB::AlphaThresholdEffect::can_mix((float32x2_t *)(*((void *)this + 7) + 16), (float32x2_t *)(*((void *)a3 + 7) + 16));
  }
  else {
    return 0;
  }
}

float32x2_t RB::DisplayList::AlphaThresholdStyle::bounds(RB::DisplayList::AlphaThresholdStyle *this, const RB::DisplayList::Item *a2, uint64_t a3)
{
  int32x2_t v3 = *(int32x2_t *)(*((void *)this + 7) + 16);
  float32x2_t result = 0;
  if (vcgt_f32((float32x2_t)vdup_lane_s32(v3, 1), (float32x2_t)v3).u32[0])
  {
    if (*(float *)v3.i32 <= 0.0)
    {
      return RB::DisplayList::Style::bounds(this, a2, a3);
    }
    else
    {
      uint64_t v5 = (float32x2_t *)*((void *)this + 3);
      if (v5) {
        return v5[2];
      }
      else {
        return (float32x2_t)0x100000001000000;
      }
    }
  }
  return result;
}

float32x2_t RB::DisplayList::Style::bounds(RB::DisplayList::Style *this, const RB::DisplayList::Item *a2, uint64_t a3)
{
  float32x2_t result = RB::DisplayList::Style::next_bounds(this, a2, a3);
  v11[0] = result;
  v11[1] = v9;
  uint64_t v10 = *((void *)this + 3);
  if (v10)
  {
    RB::Rect::intersect(v11, *(double *)(v10 + 16), *(float32x2_t *)(v10 + 24), v5, v6, v7, v8);
    return v11[0];
  }
  return result;
}

void RB::DisplayList::AlphaThresholdStyle::mix(RB::DisplayList::AlphaThresholdStyle *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Style *a3, const RB::DisplayList::CachedTransform *a4)
{
  if (a3)
  {
    RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>,RB::AlphaThresholdEffect const&,RB::DisplayList::Contents &>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), (__n128 *)(*((void *)this + 7) + 16));
    int32x4_t v8 = v7;
    RB::AlphaThresholdEffect::mix(v7 + 2, (float32x2_t *)(*((void *)a3 + 7) + 16), *((float *)a2 + 4));
    RB::Heap::emplace<RB::DisplayList::AlphaThresholdStyle,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> *&>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), (uint64_t *)&v8);
  }
}

void *RB::DisplayList::AlphaThresholdStyle::encode(RB::DisplayList::AlphaThresholdStyle *this, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x3AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  unint64_t v4 = (RB::AlphaThresholdEffect *)(*((void *)this + 7) + 16);
  RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::AlphaThresholdEffect::encode(v4, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::AlphaThresholdStyle::print(RB::DisplayList::AlphaThresholdStyle *this, std::string *a2)
{
  RB::AlphaThresholdEffect::print((RB::AlphaThresholdEffect *)(*((void *)this + 7) + 16), a2);
  RB::DisplayList::Style::print((const RB::AffineTransform **)this, a2);
}

double RB::DisplayList::State::add_alpha_gradient(__n128 *a1, RB::DisplayList::Builder *a2, unint64_t a3, uint64_t a4, unsigned __int16 a5, uint64_t a6, int a7)
{
  uint64_t v16 = a4;
  unint64_t v17 = a3;
  uint64_t v15 = a6;
  int v14 = a7;
  uint64_t v9 = *((void *)a2 + 1);
  if ((a5 & 0xFF00) == 0) {
    a5 = a1[9].n128_u16[6];
  }
  uint64_t v10 = (RB::Heap *)(v9 + 16);
  LOWORD(v13) = a5;
  unint64_t v13 = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::Heap&,unsigned long &,RBColor const*&,std::optional<RB::ColorSpace>,double const*&,unsigned int &>((size_t *)(v9 + 16), (RB::Heap *)(v9 + 16), &v17, &v16, (__int16 *)&v13, &v15, &v14);
  RB::Heap::emplace<RB::DisplayList::AlphaGradientStyle,RB::DisplayList::GenericEffect<RB::AlphaGradientEffect> *&>(v10, (uint64_t *)&v13);
  *(void *)&double result = RB::DisplayList::State::add_style(a1, a2, v11).n128_u64[0];
  return result;
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::Heap&,unsigned long &,RBColor const*&,std::optional<RB::ColorSpace>,double const*&,unsigned int &>(size_t *a1, RB::Heap *a2, unint64_t *a3, uint64_t *a4, __int16 *a5, uint64_t *a6, int *a7)
{
  unint64_t v13 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v13 + 88 > a1[3]) {
    unint64_t v13 = RB::Heap::alloc_slow(a1, 0x58uLL, 7);
  }
  else {
    a1[2] = v13 + 88;
  }
  *(void *)unint64_t v13 = &unk_26C4EBD20;
  RB::Fill::Gradient::Gradient(v13 + 16, a2, 3, *a3, *a4, *a5, *a6, *a7, 0.0, 0.0, 0.0, 0.0);
  *(unsigned char *)(v13 + 80) = 1;
  return v13;
}

double RB::Heap::emplace<RB::DisplayList::AlphaGradientStyle,RB::DisplayList::GenericEffect<RB::AlphaGradientEffect> *&>(RB::Heap *this, uint64_t *a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 64;
  }
  uint64_t v6 = *a2;
  *(void *)(v5 + 48) = 0;
  *(void *)(v5 + 56) = v6;
  double result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4EC910;
  return result;
}

double RB::DisplayList::AlphaGradientStyle::copy(RB::DisplayList::AlphaGradientStyle *this, RB::DisplayList::Builder *a2)
{
  unint64_t v4 = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::AlphaGradientEffect const&,RB::DisplayList::Contents &>((size_t *)(*((void *)a2 + 1) + 16), (uint64_t *)(*((void *)this + 7) + 16), *((void *)a2 + 1));
  return RB::Heap::emplace<RB::DisplayList::AlphaGradientStyle,RB::DisplayList::GenericEffect<RB::AlphaGradientEffect> *&>((RB::Heap *)(*((void *)a2 + 1) + 16), (uint64_t *)&v4);
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::AlphaGradientEffect const&,RB::DisplayList::Contents &>(size_t *a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v5 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 88 > a1[3]) {
    unint64_t v5 = RB::Heap::alloc_slow(a1, 0x58uLL, 7);
  }
  else {
    a1[2] = v5 + 88;
  }
  *(void *)unint64_t v5 = &unk_26C4EBD20;
  RB::AlphaGradientEffect::AlphaGradientEffect((uint64_t *)(v5 + 16), a2, a3);
  *(unsigned char *)(v5 + 80) = 1;
  return v5;
}

RB::DisplayList::Builder *RB::DisplayList::AlphaGradientStyle::draw(RB::DisplayList::AlphaGradientStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  uint64_t v10 = (const RB::DisplayList::ClipNode *)*((void *)this + 3);
  *((void *)v9 + 2) = *((void *)this + 4);
  *((void *)v9 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, *((void **)v9 + 3), v10);
  return RB::DisplayList::Builder::draw(a2, v9, a3, a5);
}

uint64_t RB::DisplayList::AlphaGradientStyle::can_mix(RB::DisplayList::AlphaGradientStyle *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Style *a3)
{
  if (a3) {
    return RB::AlphaGradientEffect::can_mix((RB::AlphaGradientEffect *)(*((void *)this + 7) + 16), (const RB::AlphaGradientEffect *)(*((void *)a3 + 7) + 16));
  }
  else {
    return 0;
  }
}

float32x2_t RB::DisplayList::AlphaGradientStyle::bounds(float32x2_t **this, const RB::DisplayList::Item *a2, uint64_t a3, double a4, double a5, double a6, double a7, float a8)
{
  if (RB::Fill::Gradient::sample_alpha((RB::Fill::Gradient *)&this[7][2], 0.0, a5, a6, a7, a8) <= 0.0)
  {
    return RB::DisplayList::Style::bounds((RB::DisplayList::Style *)this, a2, a3);
  }
  else
  {
    uint64_t v11 = this[3];
    if (v11) {
      return v11[2];
    }
    else {
      return (float32x2_t)0xFEFFFFFFFEFFFFFFLL;
    }
  }
}

void RB::DisplayList::AlphaGradientStyle::mix(RB::DisplayList::AlphaGradientStyle *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Style *a3, const RB::DisplayList::CachedTransform *a4)
{
  if (a3)
  {
    unint64_t v7 = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::AlphaGradientEffect const&,RB::DisplayList::Contents &>((size_t *)(*(void *)(*(void *)a4 + 8) + 16), (uint64_t *)(*((void *)this + 7) + 16), *(void *)(*(void *)a4 + 8));
    RB::AlphaGradientEffect::mix((RB::AlphaGradientEffect *)(v7 + 16), (const RB::AlphaGradientEffect *)(*((void *)a3 + 7) + 16), *((float *)a2 + 4), (RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16));
    RB::Heap::emplace<RB::DisplayList::AlphaGradientStyle,RB::DisplayList::GenericEffect<RB::AlphaGradientEffect> *&>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), (uint64_t *)&v7);
  }
}

void *RB::DisplayList::AlphaGradientStyle::encode(RB::DisplayList::AlphaGradientStyle *this, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x3AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  unint64_t v4 = (RB::AlphaGradientEffect *)(*((void *)this + 7) + 16);
  RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::AlphaGradientEffect::encode(v4, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::AlphaGradientStyle::print(RB::DisplayList::AlphaGradientStyle *this, RB::SexpString *a2)
{
}

unint64_t RB::DisplayList::CustomEffectStyle::copy(RB::DisplayList::CustomEffectStyle *this, RB::DisplayList::Builder *a2)
{
  unint64_t v4 = (RB::DisplayList::Layer *)*((void *)this + 23);
  if (v4) {
    unint64_t v4 = (RB::DisplayList::Layer *)RB::DisplayList::Layer::copy(v4, a2, 0);
  }
  unint64_t v5 = (size_t *)(*((void *)a2 + 1) + 16);
  unint64_t v7 = v4;
  return _ZN2RB4Heap7emplaceINS_11DisplayList17CustomEffectStyleEJRKNS_12CustomShader7ClosureERPNS2_5LayerERKDv2_fSD_RKNS_4RectERKjEEEPT_DpOT0_(v5, (RB::DisplayList::CustomEffectStyle *)((char *)this + 56), (uint64_t *)&v7, (uint64_t *)this + 24, (uint64_t *)this + 25, (_OWORD *)this + 13, (int *)this + 56);
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList17CustomEffectStyleEJRKNS_12CustomShader7ClosureERPNS2_5LayerERKDv2_fSD_RKNS_4RectERKjEEEPT_DpOT0_(size_t *a1, RB::CustomShader::Closure *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, _OWORD *a6, int *a7)
{
  unint64_t v13 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v13 + 232 > a1[3]) {
    unint64_t v13 = RB::Heap::alloc_slow(a1, 0xE8uLL, 7);
  }
  else {
    a1[2] = v13 + 232;
  }
  uint64_t v14 = *a3;
  uint64_t v15 = *a4;
  uint64_t v16 = *a5;
  int v17 = *a7;
  *(void *)(v13 + 48) = 0;
  *(_OWORD *)(v13 + 16) = 0u;
  *(_OWORD *)(v13 + 32) = 0u;
  *(void *)unint64_t v13 = &unk_26C4EC888;
  RB::CustomShader::Closure::Closure((RB::CustomShader::Closure *)(v13 + 56), a2);
  *(void *)(v13 + 184) = v14;
  *(void *)(v13 + 192) = v15;
  *(void *)(v13 + 200) = v16;
  *(_OWORD *)(v13 + 208) = *a6;
  *(_DWORD *)(v13 + 224) = v17;
  return v13;
}

void RB::DisplayList::CustomEffectStyle::apply_transform(RB::DisplayList::CustomEffectStyle *this, const RB::DisplayList::CachedTransform *a2)
{
  unint64_t v2 = (RB::DisplayList::Layer *)*((void *)this + 23);
  if (v2) {
    RB::DisplayList::Layer::apply_transform(v2, a2);
  }
}

RB::DisplayList::Builder *RB::DisplayList::CustomEffectStyle::draw(RB::DisplayList::CustomEffectStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5, double a6, int32x4_t a7)
{
  double v12 = *((double *)this + 24);
  unint64_t v23 = *((void *)this + 25);
  a7.i64[0] = v23;
  double v24 = v12;
  RB::CustomEffect::transform_border((float32x2_t *)&v24, *((float64x2_t **)this + 2), v12, a7);
  if (*((void *)this + 23))
  {
    RB::CustomEffect::transform_border((float32x2_t *)&v23, *((float64x2_t **)this + 2), v13, v14);
    uint64_t v15 = (RB::DisplayList::Layer *)*((void *)this + 23);
    if (v15) {
      uint64_t v15 = (RB::DisplayList::Layer *)RB::DisplayList::Layer::copy(v15, a2, 0);
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  int32x4_t v22 = v15;
  unint64_t v16 = _ZN2RB4Heap7emplaceINS_11DisplayList13GenericEffectINS_12CustomEffectEEEJRKNS_12CustomShader7ClosureERPNS2_5LayerERDv2_fSE_RKNS_4RectERKNS_15AffineTransformERKjEEEPT_DpOT0_((size_t *)(*((void *)a2 + 1) + 16), (RB::DisplayList::CustomEffectStyle *)((char *)this + 56), (uint64_t *)&v22, (uint64_t *)&v24, (uint64_t *)&v23, (_OWORD *)this + 13, *((long long **)this + 2), (int *)this + 56);
  uint64_t v17 = *((void *)a2 + 1);
  *(void *)(v16 + 8) = *(void *)(v17 + 312);
  *(void *)(v17 + 312) = v16;
  float64x2_t v18 = RB::DisplayList::Builder::ensure_layer(a2, a4, 0.0, (2 * *((_DWORD *)this + 56)) & 0x10);
  *((void *)v18 + 2) = *((void *)this + 4);
  *((void *)v18 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, *((void **)v18 + 3), *((const RB::DisplayList::ClipNode **)this + 3));
  uint64_t v19 = *((void *)this + 23);
  if (v19 && (*(_WORD *)(v19 + 60) & 0x2001) != 0) {
    *((_WORD *)v18 + 23) |= 0x400u;
  }
  uint64_t v20 = *((void *)v18 + 6);
  *(unsigned char *)(v20 + 64) = 2;
  *(void *)(v20 + 24) = v16;
  return RB::DisplayList::Builder::draw(a2, v18, a3, a5);
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList13GenericEffectINS_12CustomEffectEEEJRKNS_12CustomShader7ClosureERPNS2_5LayerERDv2_fSE_RKNS_4RectERKNS_15AffineTransformERKjEEEPT_DpOT0_(size_t *a1, RB::CustomShader::Closure *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, _OWORD *a6, long long *a7, int *a8)
{
  unint64_t v15 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 272 > a1[3]) {
    unint64_t v15 = RB::Heap::alloc_slow(a1, 0x110uLL, 15);
  }
  else {
    a1[2] = v15 + 272;
  }
  *(void *)unint64_t v15 = &unk_26C4EBC60;
  uint64_t v16 = *a3;
  uint64_t v17 = *a4;
  uint64_t v18 = *a5;
  int v19 = *a8;
  RB::CustomShader::Closure::Closure((RB::CustomShader::Closure *)(v15 + 16), a2);
  *(void *)(v15 + 144) = v16;
  *(void *)(v15 + 152) = v17;
  *(void *)(v15 + 160) = v18;
  long long v20 = *a7;
  long long v21 = a7[2];
  *(_OWORD *)(v15 + 192) = a7[1];
  *(_OWORD *)(v15 + 208) = v21;
  *(_OWORD *)(v15 + 176) = v20;
  *(_OWORD *)(v15 + 224) = *a6;
  *(_DWORD *)(v15 + 240) = v19;
  *(unsigned char *)(v15 + 256) = 1;
  return v15;
}

void RB::DisplayList::CustomEffectStyle::map_roi(RB::DisplayList::CustomEffectStyle *this, float32x2_t *a2, float64x2_t *a3)
{
  uint32x2_t v3 = (uint32x2_t)vcge_f32((float32x2_t)(*(void *)&a2[1] & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) == 0)
  {
    if (!*((void *)this + 23) || (*((unsigned char *)this + 224) & 0x10) != 0)
    {
      uint32x2_t v7 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(*(float32x2_t *)((char *)this + 192)));
      if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) == 0) {
        return;
      }
      RB::Rect::move(a2, a3, *((float64x2_t **)this + 2));
      float32x2_t v8 = vabs_f32(*(float32x2_t *)((char *)this + 192));
      float32x2_t v9 = a2[1];
      *(int32x2_t *)v10.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v9);
      v10.i64[0] = vcltzq_s32(v10).u64[0];
      *a2 = (float32x2_t)vbsl_s8(*(int8x8_t *)v10.i8, (int8x8_t)vsub_f32(*a2, v8), (int8x8_t)*a2);
      int32x2_t v6 = (int32x2_t)vbsl_s8(*(int8x8_t *)v10.i8, (int8x8_t)vmla_f32(v9, (float32x2_t)0x4000000040000000, v8), (int8x8_t)v9);
    }
    else
    {
      *a2 = (float32x2_t)0x100000001000000;
      int32x2_t v6 = vdup_n_s32(0x7F7FFFFFu);
    }
    a2[1] = (float32x2_t)v6;
  }
}

double RB::DisplayList::CustomEffectStyle::bounds(RB::DisplayList::CustomEffectStyle *this, const RB::DisplayList::Item *a2, uint64_t a3)
{
  *(float32x2_t *)&long long v44 = RB::DisplayList::Style::next_bounds(this, a2, a3);
  *((float32x2_t *)&v44 + 1) = v4;
  uint32x2_t v9 = (uint32x2_t)vcge_f32(vabs_f32(v4), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if ((vpmax_u32(v9, v9).u32[0] & 0x80000000) == 0)
  {
    int32x4_t v10 = (int32x4_t)xmmword_2142181D0;
    v41[0] = (float64x2_t)xmmword_2142181C0;
    v41[1] = (float64x2_t)xmmword_2142181D0;
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    uint32x2_t v11 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(*(float32x2_t *)((char *)this + 192)));
    *(uint32x2_t *)&long long v12 = vpmax_u32(v11, v11);
    if ((v12 & 0x80000000) != 0)
    {
      RB::Rect::move((float32x2_t *)&v44, v41, *((float64x2_t **)this + 2));
      float32x2_t v13 = vabs_f32(*(float32x2_t *)((char *)this + 192));
      *(int32x2_t *)v14.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), *(float32x2_t *)((char *)&v44 + 8));
      int32x4_t v10 = vcltzq_s32(v14);
      int8x8_t v15 = (int8x8_t)vmvnq_s8((int8x16_t)v10).u64[0];
      int8x8_t v16 = vorr_s8(vand_s8((int8x8_t)vmla_f32(*(float32x2_t *)((char *)&v44 + 8), (float32x2_t)0x4000000040000000, v13), *(int8x8_t *)v10.i8), vand_s8(*(int8x8_t *)((char *)&v44 + 8), v15));
      int8x8_t v17 = vand_s8((int8x8_t)vsub_f32(*(float32x2_t *)&v44, v13), *(int8x8_t *)v10.i8);
      *(int8x8_t *)v10.i8 = vand_s8(*(int8x8_t *)&v44, v15);
      *(int8x8_t *)&long long v12 = vorr_s8(v17, *(int8x8_t *)v10.i8);
      *((int8x8_t *)&v12 + 1) = v16;
      long long v44 = v12;
    }
    uint64_t v18 = (RB::DisplayList::Layer *)*((void *)this + 23);
    if (v18 && (*((unsigned char *)this + 224) & 0x10) == 0)
    {
      float32x2_t v19 = RB::DisplayList::Layer::bounds(v18, *(double *)&v12, v10);
      uint64_t v21 = v20;
      int32x4_t v22 = (float64x2_t *)*((void *)this + 2);
      float64x2_t v23 = *v22;
      float64x2_t v24 = v22[2];
      int32x4_t v46 = (int32x4_t)v22[1];
      float64x2_t v47 = v24;
      float64x2_t v45 = v23;
      if (RB::AffineTransform::invert((RB::AffineTransform *)&v45)) {
        RBPath v25 = &v45;
      }
      else {
        RBPath v25 = v22;
      }
      int32x4_t v26 = (int32x4_t)v25[1];
      float64x2_t v27 = v25[2];
      float64x2_t v45 = *v25;
      int32x4_t v46 = v26;
      float64x2_t v47 = v27;
      v26.i64[0] = v21;
      float32x2_t v28 = RB::operator*(&v45, v19, v26);
      float32x2_t v29 = vabs_f32(*(float32x2_t *)((char *)this + 200));
      *(int32x2_t *)v31.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v30);
      v31.i64[0] = vcltzq_s32(v31).u64[0];
      double v32 = COERCE_DOUBLE(vbsl_s8(*(int8x8_t *)v31.i8, (int8x8_t)vsub_f32(v28, v29), (int8x8_t)v28));
      int8x8_t v33 = vbsl_s8(*(int8x8_t *)v31.i8, (int8x8_t)vmla_f32(v30, (float32x2_t)0x4000000040000000, v29), (int8x8_t)v30);
      RB::Rect::move((float32x2_t *)&v44, v41, *((float64x2_t **)this + 2));
      *(int8x8_t *)v34.i8 = v33;
      RB::Rect::Union((float32x2_t *)&v44, v32, v34, v35, v36, v37, v38);
    }
    RB::Rect::move_identity((float32x2_t *)&v44, v41);
  }
  uint64_t v39 = *((void *)this + 3);
  if (v39) {
    RB::Rect::intersect((float32x2_t *)&v44, *(double *)(v39 + 16), *(float32x2_t *)(v39 + 24), v5, v6, v7, v8);
  }
  return *(double *)&v44;
}

BOOL RB::DisplayList::CustomEffectStyle::can_mix(RB::DisplayList::CustomEffectStyle *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Style *a3)
{
  return a3
      && *((_DWORD *)this + 56) == *((_DWORD *)a3 + 56)
      && RB::CustomShader::Closure::can_mix((RB::DisplayList::CustomEffectStyle *)((char *)this + 56), (const Closure *)((char *)a3 + 56));
}

unint64_t RB::DisplayList::CustomEffectStyle::mix(float32x2_t *this, const RB::DisplayList::Interpolator::State *a2, float32x2_t *a3, RB::DisplayList::Builder **a4, double a5, int32x4_t a6)
{
  if (!a3) {
    return 0;
  }
  float64x2_t v23 = 0;
  int32x4_t v10 = (RB::DisplayList::Layer *)this[23];
  if (v10)
  {
    uint32x2_t v11 = (const RB::DisplayList::Layer *)a3[23];
    if (v11) {
      float64x2_t v23 = RB::DisplayList::Layer::mix(v10, a2, v11, a4);
    }
  }
  long long v12 = (size_t *)(*((void *)*a4 + 1) + 16);
  uint64_t v13 = *((void *)a2 + 2);
  *(float32x2_t *)a6.i8 = this[25];
  float32x2_t v14 = a3[25];
  float32x2_t v22 = vmla_n_f32(this[24], vsub_f32(a3[24], this[24]), *(float *)&v13);
  float32x2_t v21 = vmla_n_f32(*(float32x2_t *)a6.i8, vsub_f32(v14, *(float32x2_t *)a6.i8), *(float *)&v13);
  float32x2_t v15 = this[26];
  float32x2_t v16 = a3[26];
  *(float32x2_t *)a6.i8 = vadd_f32(this[27], v15);
  *(float32x2_t *)a6.i8 = vmla_n_f32(*(float32x2_t *)a6.i8, vadd_f32(vsub_f32(v16, *(float32x2_t *)a6.i8), a3[27]), *(float *)&v13);
  *(void *)&long long v20 = RB::Rect::from_bounds(vmla_n_f32(v15, vsub_f32(v16, v15), *(float *)&v13), a6);
  *((void *)&v20 + 1) = v17;
  unint64_t v18 = _ZN2RB4Heap7emplaceINS_11DisplayList17CustomEffectStyleEJRKNS_12CustomShader7ClosureERPNS2_5LayerERKDv2_fSD_RKNS_4RectERKjEEEPT_DpOT0_(v12, (RB::CustomShader::Closure *)&this[7], (uint64_t *)&v23, (uint64_t *)&v22, (uint64_t *)&v21, &v20, (int *)&this[28]);
  RB::CustomShader::Closure::mix((RB::CustomShader::Closure *)(v18 + 56), (const RB::CustomShader::Closure *)&a3[7], *((float *)a2 + 4));
  return v18;
}

uint64_t *RB::DisplayList::CustomEffectStyle::prepare_encode(RB::DisplayList::CustomEffectStyle *this, RB::Encoder *a2)
{
  RB::DisplayList::Style::prepare_encode(this, a2);
  return RB::CustomShader::Closure::prepare_encode((RB::DisplayList::CustomEffectStyle *)((char *)this + 56), a2);
}

uint64_t *RB::DisplayList::Style::prepare_encode(RB::DisplayList::Style *this, RB::Encoder *a2)
{
  double result = (uint64_t *)*((void *)this + 3);
  if (result)
  {
    RB::DisplayList::ClipNode::prepare_encode((unint64_t)result, (uint64_t)a2);
    return RB::Encoder::prepare_shared_f<void RB::Encoder::prepare_shared<RB::DisplayList::ClipNode>(RB::Encoder::SharedType,RB::DisplayList::ClipNode const&)::{lambda(RB::DisplayList::ClipNode&)#1}>((uint64_t *)a2, 4, *((uint64_t **)this + 3), &v5);
  }
  return result;
}

void *RB::DisplayList::CustomEffectStyle::encode(RB::DisplayList::CustomEffectStyle *this, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x3AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x22uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::CustomShader::Closure::encode((RB::CustomShader::Function **)this + 7, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  RB::ProtobufEncoder::float2_field(a2, 2, *((double *)this + 24));
  unint64_t v4 = *((_DWORD *)this + 56) & 3;
  RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
  RB::ProtobufEncoder::encode_varint(a2, v4);
  if ((*((unsigned char *)this + 224) & 4) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
    RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  uint32x2_t v5 = (uint32x2_t)vcgtz_f32(*(float32x2_t *)((char *)this + 216));
  if ((vpmin_u32(v5, v5).u32[0] & 0x80000000) != 0) {
    RB::ProtobufEncoder::float4_field(a2, 5, *((float32x4_t *)this + 13));
  }
  if ((*((unsigned char *)this + 224) & 8) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x30uLL);
    RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  double v6 = (void **)*((void *)this + 23);
  if (v6)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x3AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::DisplayList::Layer::encode(v6, a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
    RB::ProtobufEncoder::float2_field(a2, 8, *((double *)this + 25));
  }
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

unint64_t RB::DisplayList::CustomEffectStyle::decode(__n128 *this, size_t **a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
  if (result)
  {
    unint64_t v6 = result;
    do
    {
      switch((v6 >> 3))
      {
        case 1u:
          if ((v6 & 7) != 2) {
            goto LABEL_27;
          }
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          RB::CustomShader::Closure::decode((RB::CustomShader::Closure *)&this[3].n128_i8[8], (RB::Decoder *)a2);
          goto LABEL_23;
        case 2u:
          this[12].n128_u64[0] = RB::ProtobufDecoder::float2_field((RB::ProtobufDecoder *)a2, v6, v5).n128_u64[0];
          break;
        case 3u:
          this[14].n128_u32[0] &= 0xFFFFFFFC;
          unint64_t v7 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, v6);
          if (v7 > 2) {
            break;
          }
          int v8 = this[14].n128_u32[0] | v7;
          goto LABEL_18;
        case 4u:
          this[14].n128_u32[0] &= ~4u;
          if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v6)) {
            int v9 = 4;
          }
          else {
            int v9 = 0;
          }
          goto LABEL_17;
        case 5u:
          this[13] = RB::ProtobufDecoder::float4_field((RB::ProtobufDecoder *)a2, v6);
          break;
        case 6u:
          this[14].n128_u32[0] &= ~8u;
          if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v6)) {
            int v9 = 8;
          }
          else {
            int v9 = 0;
          }
LABEL_17:
          int v8 = this[14].n128_u32[0] | v9;
LABEL_18:
          this[14].n128_u32[0] = v8;
          break;
        case 7u:
          int v10 = *((_DWORD *)a2 + 56) + 1;
          *((_DWORD *)a2 + 56) = v10;
          int v14 = 0;
          int v15 = v10;
          uint64_t v11 = RB::Heap::emplace<RB::DisplayList::Layer,unsigned int,int>(a2[8], &v15, &v14);
          long long v12 = (RB::DisplayList::Layer *)this[11].n128_u64[1];
          this[11].n128_u64[1] = v11;
          if (v12) {
            RB::DisplayList::Layer::~Layer(v12);
          }
          if ((v6 & 7) == 2)
          {
            uint64_t v13 = (RB::DisplayList::Layer *)this[11].n128_u64[1];
            RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
            RB::DisplayList::Layer::decode(v13, (RB::Decoder *)a2);
LABEL_23:
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
LABEL_27:
            *((unsigned char *)a2 + 56) = 1;
            *a2 = a2[1];
          }
          break;
        case 8u:
          this[12].n128_u64[1] = RB::ProtobufDecoder::float2_field((RB::ProtobufDecoder *)a2, v6, v5).n128_u64[0];
          break;
        default:
          RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, v6);
          break;
      }
      unint64_t result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
      unint64_t v6 = result;
    }
    while (result);
  }
  return result;
}

void RB::DisplayList::CustomEffectStyle::print(RB::DisplayList::CustomEffectStyle *this, std::string *a2)
{
  uint64_t v4 = *((void *)this + 7);
  if (v4) {
    RB::SexpString::printf(a2, 0, "(shader %s)", (const char *)[*(id *)(v4 + 24) UTF8String]);
  }
  float32x2_t v5 = *(float32x2_t *)((char *)this + 216);
  uint32x2_t v6 = (uint32x2_t)vcgtz_f32(v5);
  if ((vpmin_u32(v6, v6).u32[0] & 0x80000000) != 0) {
    RB::SexpString::printf(a2, 0, "(bounds %g %g %g %g)", COERCE_FLOAT(*((void *)this + 26)), COERCE_FLOAT(HIDWORD(*((void *)this + 26))), v5.f32[0], v5.f32[1]);
  }
  if ((*((_DWORD *)this + 56) & 3) == 2) {
    unint64_t v7 = "warp";
  }
  else {
    unint64_t v7 = "layer";
  }
  RB::SexpString::printf(a2, 0, "(type %s)", v7);
  int v8 = (RB::DisplayList::Layer *)*((void *)this + 23);
  if (v8) {
    RB::DisplayList::Layer::print(v8, a2);
  }
  RB::DisplayList::Style::print((const RB::AffineTransform **)this, a2);
}

double RB::DisplayList::State::add_custom_effect(__n128 *a1, RB::DisplayList::Builder *a2, RB::CustomShader::Closure *a3, uint64_t a4, _OWORD *a5, int a6, double a7, double a8)
{
  uint64_t v15 = a4;
  double v13 = a8;
  double v14 = a7;
  int v12 = a6;
  int v10 = (RB::DisplayList::Style *)_ZN2RB4Heap7emplaceINS_11DisplayList17CustomEffectStyleEJRKNS_12CustomShader7ClosureERPNS2_5LayerERKDv2_fSD_RKNS_4RectERKjEEEPT_DpOT0_((size_t *)(*((void *)a2 + 1) + 16), a3, &v15, (uint64_t *)&v14, (uint64_t *)&v13, a5, &v12);
  *(void *)&double result = RB::DisplayList::State::add_style(a1, a2, v10).n128_u64[0];
  return result;
}

unint64_t RB::DisplayList::PredicateStyle::copy(RB::DisplayList::PredicateStyle *this, RB::DisplayList::Builder *a2)
{
  return RB::Heap::emplace<RB::DisplayList::PredicateStyle,RB::DisplayList::Predicate const&,BOOL const&>((size_t *)(*((void *)a2 + 1) + 16), (RB::DisplayList::PredicateStyle *)((char *)this + 56), (char *)this + 96);
}

unint64_t RB::Heap::emplace<RB::DisplayList::PredicateStyle,RB::DisplayList::Predicate const&,BOOL const&>(size_t *a1, RB::DisplayList::Predicate *a2, char *a3)
{
  unint64_t v5 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 104 > a1[3]) {
    unint64_t v5 = RB::Heap::alloc_slow(a1, 0x68uLL, 7);
  }
  else {
    a1[2] = v5 + 104;
  }
  char v6 = *a3;
  *(void *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4EC228;
  RB::DisplayList::InvertiblePredicate::InvertiblePredicate((RB::DisplayList::InvertiblePredicate *)(v5 + 56), a2, v6);
  return v5;
}

RB::DisplayList::Builder *RB::DisplayList::PredicateStyle::draw(RB::DisplayList::PredicateStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, uint64_t (***a4)(RB::DisplayList::Item *), char a5)
{
  if (((unsigned int (*)(uint64_t (***)(RB::DisplayList::Item *), char *))(*a4)[24])(a4, (char *)this + 56) == (*((unsigned char *)this + 96) != 0))
  {
    int v12 = **a4;
    return (RB::DisplayList::Builder *)v12((RB::DisplayList::Item *)a4);
  }
  else
  {
    int v10 = (const RB::DisplayList::ClipNode *)*((void *)this + 3);
    a4[2] = (uint64_t (**)(RB::DisplayList::Item *))*((void *)this + 4);
    a4[3] = (uint64_t (**)(RB::DisplayList::Item *))RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, a4[3], v10);
    return RB::DisplayList::Builder::draw(a2, (RB::DisplayList::Item *)a4, a3, a5);
  }
}

uint64_t RB::DisplayList::PredicateStyle::can_mix(RB::DisplayList::PredicateStyle *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Style *a3)
{
  if (a3) {
    return RB::DisplayList::InvertiblePredicate::can_mix((RB::DisplayList::PredicateStyle *)((char *)this + 56), (const RB::DisplayList::Style *)((char *)a3 + 56));
  }
  else {
    return 0;
  }
}

unint64_t RB::DisplayList::PredicateStyle::mix(RB::DisplayList::PredicateStyle *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Style *a3, const RB::DisplayList::CachedTransform *a4)
{
  if (!a3) {
    return 0;
  }
  unint64_t v6 = RB::Heap::emplace<RB::DisplayList::PredicateStyle,RB::DisplayList::Predicate const&,BOOL const&>((size_t *)(*(void *)(*(void *)a4 + 8) + 16), (RB::DisplayList::PredicateStyle *)((char *)this + 56), (char *)this + 96);
  RB::DisplayList::InvertiblePredicate::mix((RB::DisplayList::InvertiblePredicate *)(v6 + 56), (const RB::DisplayList::Style *)((char *)a3 + 56), *((float *)a2 + 4));
  return v6;
}

void *RB::DisplayList::PredicateStyle::encode(RB::DisplayList::PredicateStyle *this, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x42uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::DisplayList::InvertiblePredicate::encode((RB::DisplayList::PredicateStyle *)((char *)this + 56), a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

uint64_t RB::DisplayList::PredicateStyle::print(RB::DisplayList::PredicateStyle *this, std::string *a2)
{
  RB::SexpString::push(a2, "display-list-predicate");
  if (*((unsigned char *)this + 96)) {
    RB::SexpString::print(a2, 0, "inverts-result");
  }
  RB::XML::Document::Document((RB::XML::Document *)&v6);
  RB::DisplayList::Predicate::xml_elements((uint64_t)this + 56, (RB::XML::Document *)&v6);
  RB::XML::Document::print_children((RB::XML::Document *)&v6, a2, 0);
  RB::DisplayList::Style::print((const RB::AffineTransform **)this, a2);
  RB::SexpString::pop(a2);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v8);
  if (v7) {
    free(v7);
  }
  uint64_t result = v6;
  if (v6)
  {
    int v5 = *(_DWORD *)(v6 + 8) - 1;
    *(_DWORD *)(v6 + 8) = v5;
    if (!v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void sub_2141D4D18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

double RB::DisplayList::State::add_predicate(__n128 *this, RB::DisplayList::Builder *a2, const RB::DisplayList::Predicate *a3, char a4)
{
  char v8 = a4;
  uint64_t v6 = (RB::DisplayList::Style *)RB::Heap::emplace<RB::DisplayList::PredicateStyle,RB::DisplayList::Predicate const&,BOOL const&>((size_t *)(*((void *)a2 + 1) + 16), a3, &v8);
  *(void *)&double result = RB::DisplayList::State::add_style(this, a2, v6).n128_u64[0];
  return result;
}

RB::DisplayList::TransformStyle *RB::DisplayList::TransformStyle::copy(RB::DisplayList::TransformStyle *this, RB::DisplayList::Builder *a2)
{
  return RB::Heap::emplace<RB::DisplayList::TransformStyle,RB::DisplayList::Transform const&>((size_t *)(*((void *)a2 + 1) + 16), (RB::DisplayList::TransformStyle *)((char *)this + 56));
}

RB::DisplayList::TransformStyle *RB::Heap::emplace<RB::DisplayList::TransformStyle,RB::DisplayList::Transform const&>(size_t *a1, RB::DisplayList::Transform *a2)
{
  uint32x2_t v3 = (RB::DisplayList::TransformStyle *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)v3 + 104 > a1[3]) {
    uint32x2_t v3 = (RB::DisplayList::TransformStyle *)RB::Heap::alloc_slow(a1, 0x68uLL, 7);
  }
  else {
    a1[2] = (size_t)v3 + 104;
  }
  return RB::DisplayList::TransformStyle::TransformStyle(v3, a2);
}

RB::DisplayList::Builder *RB::DisplayList::TransformStyle::draw(RB::DisplayList::TransformStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  int v10 = (const RB::DisplayList::ClipNode *)*((void *)this + 3);
  *((void *)a4 + 2) = *((void *)this + 4);
  *((void *)a4 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, *((void **)a4 + 3), v10);
  (*(void (**)(RB::DisplayList::Item *, char *, void))(*(void *)a4 + 200))(a4, (char *)this + 56, *((void *)a2 + 1));
  return RB::DisplayList::Builder::draw(a2, a4, a3, a5);
}

uint64_t RB::DisplayList::TransformStyle::can_mix(RB::DisplayList::TransformStyle *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Style *a3)
{
  if (a3) {
    return RB::DisplayList::Transform::can_mix((RB::DisplayList::TransformStyle *)((char *)this + 56), (const RB::DisplayList::Style *)((char *)a3 + 56));
  }
  else {
    return 0;
  }
}

RB::DisplayList::TransformStyle *RB::DisplayList::TransformStyle::mix(RB::DisplayList::TransformStyle *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Style *a3, const RB::DisplayList::CachedTransform *a4)
{
  if (!a3) {
    return 0;
  }
  uint64_t v6 = RB::Heap::emplace<RB::DisplayList::TransformStyle,RB::DisplayList::Transform const&>((size_t *)(*(void *)(*(void *)a4 + 8) + 16), (RB::DisplayList::TransformStyle *)((char *)this + 56));
  RB::DisplayList::Transform::mix((RB::DisplayList::TransformStyle *)((char *)v6 + 56), (const RB::DisplayList::Style *)((char *)a3 + 56), *((float *)a2 + 4));
  return v6;
}

void *RB::DisplayList::TransformStyle::encode(RB::DisplayList::TransformStyle *this, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x4AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::DisplayList::Transform::encode((int *)this + 14, a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

uint64_t RB::DisplayList::TransformStyle::print(const RB::AffineTransform **this, std::string *a2)
{
  RB::SexpString::push(a2, "display-list-transform");
  RB::XML::Document::Document((RB::XML::Document *)&v6);
  RB::DisplayList::Transform::xml_elements((uint64_t)(this + 7), (RB::XML::Document *)&v6);
  RB::XML::Document::print_children((RB::XML::Document *)&v6, a2, 0);
  RB::DisplayList::Style::print(this, a2);
  RB::SexpString::pop(a2);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v8);
  if (v7) {
    free(v7);
  }
  uint64_t result = v6;
  if (v6)
  {
    int v5 = *(_DWORD *)(v6 + 8) - 1;
    *(_DWORD *)(v6 + 8) = v5;
    if (!v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void sub_2141D5050(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

double RB::DisplayList::State::add_transform(__n128 *this, RB::DisplayList::Builder *a2, const RB::DisplayList::Transform *a3)
{
  int v5 = RB::Heap::emplace<RB::DisplayList::TransformStyle,RB::DisplayList::Transform const&>((size_t *)(*((void *)a2 + 1) + 16), a3);
  *(void *)&double result = RB::DisplayList::State::add_style(this, a2, v5).n128_u64[0];
  return result;
}

RB::DisplayList::AnimationStyle *RB::DisplayList::AnimationStyle::AnimationStyle(RB::DisplayList::AnimationStyle *this, const RB::Animation *a2, const UUID *a3, int a4)
{
  *((void *)this + 6) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(void *)this = &unk_26C4EC118;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0x600000000;
  *((_OWORD *)this + 6) = *(_OWORD *)a3;
  *((_DWORD *)this + 28) = a4;
  if (a2)
  {
    *((_DWORD *)this + 22) = 0;
    if (*((void *)a2 + 3)) {
      int v5 = (const RB::Animation *)*((void *)a2 + 3);
    }
    else {
      int v5 = a2;
    }
    unsigned int v6 = *((_DWORD *)a2 + 8);
    if (v6 >= 7)
    {
      RB::vector<RB::Animation::TermOrArg,6ul,unsigned int>::reserve_slow((char *)this + 56, *((_DWORD *)a2 + 8));
      uint64_t v8 = *((unsigned int *)this + 22);
      unint64_t v7 = (char *)*((void *)this + 10);
    }
    else
    {
      if (!v6)
      {
        int v12 = 0;
LABEL_14:
        *((_DWORD *)this + 22) = v12 + v6;
        return this;
      }
      unint64_t v7 = 0;
      uint64_t v8 = 0;
    }
    if (!v7) {
      unint64_t v7 = (char *)this + 56;
    }
    int v9 = &v7[4 * v8];
    unsigned int v10 = v6;
    do
    {
      int v11 = *(_DWORD *)v5;
      int v5 = (const RB::Animation *)((char *)v5 + 4);
      *(_DWORD *)int v9 = v11;
      v9 += 4;
      --v10;
    }
    while (v10);
    int v12 = *((_DWORD *)this + 22);
    goto LABEL_14;
  }
  return this;
}

void sub_2141D51A0(_Unwind_Exception *exception_object)
{
  uint32x2_t v3 = *(void **)(v1 + 80);
  if (v3) {
    free(v3);
  }
  _Unwind_Resume(exception_object);
}

RB::DisplayList::AnimationStyle *RB::DisplayList::AnimationStyle::copy(RB::DisplayList::AnimationStyle *this, RB::DisplayList::Builder *a2)
{
  unint64_t v2 = (size_t *)(*((void *)a2 + 1) + 16);
  uint64_t v4 = (RB::DisplayList::AnimationStyle *)((char *)this + 56);
  return RB::Heap::emplace<RB::DisplayList::AnimationStyle,RB::Animation const*,RB::UUID const&,unsigned int const&>(v2, &v4, (UUID *)((uint8_t *)this + 6), (int *)this + 28);
}

RB::DisplayList::AnimationStyle *RB::Heap::emplace<RB::DisplayList::AnimationStyle,RB::Animation const*,RB::UUID const&,unsigned int const&>(size_t *a1, const RB::Animation **a2, UUID *a3, int *a4)
{
  unint64_t v7 = (RB::DisplayList::AnimationStyle *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)v7 + 120 > a1[3]) {
    unint64_t v7 = (RB::DisplayList::AnimationStyle *)RB::Heap::alloc_slow(a1, 0x78uLL, 7);
  }
  else {
    a1[2] = (size_t)v7 + 120;
  }
  uint64_t v8 = *a2;
  int v9 = *a4;
  return RB::DisplayList::AnimationStyle::AnimationStyle(v7, v8, a3, v9);
}

RB::DisplayList::Builder *RB::DisplayList::AnimationStyle::draw(RB::DisplayList::AnimationStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  int v9 = (const RB::DisplayList::ClipNode *)*((void *)this + 3);
  *((void *)a4 + 2) = *((void *)this + 4);
  *((void *)a4 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, *((void **)a4 + 3), v9);
  return RB::DisplayList::Builder::draw(a2, a4, a3, a5);
}

uint64_t RB::DisplayList::AnimationStyle::can_mix(RB::DisplayList::AnimationStyle *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Style *a3)
{
  return 4;
}

uint64_t RB::DisplayList::AnimationStyle::mix(RB::DisplayList::AnimationStyle *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Style *a3, const RB::DisplayList::CachedTransform *a4)
{
  if (a3) {
    this = a3;
  }
  return (*(uint64_t (**)(RB::DisplayList::AnimationStyle *, void))(*(void *)this + 24))(this, *(void *)a4);
}

void *RB::DisplayList::AnimationStyle::encode(RB::DisplayList::AnimationStyle *this, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x5AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  if (*((_DWORD *)this + 22))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Animation::encode((void *)this + 7, a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
  RB::ProtobufEncoder::encode_data(a2, (char *)this + 96, 0x10uLL);
  unint64_t v4 = *((unsigned int *)this + 28);
  if (v4 != 273)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
    RB::ProtobufEncoder::encode_varint(a2, v4);
  }
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

unint64_t RB::DisplayList::AnimationStyle::decode(RB::DisplayList::AnimationStyle *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      unint64_t v6 = v5 >> 3;
      if ((v5 >> 3) == 3)
      {
        *((_DWORD *)this + 28) = RB::ProtobufDecoder::uint_field((uint64_t **)a2, v5);
      }
      else if (v6 == 2)
      {
        unint64_t v7 = (_OWORD *)RB::ProtobufDecoder::data_field(a2, v5);
        if (v8 == 16) {
          *((_OWORD *)this + 6) = *v7;
        }
      }
      else if (v6 == 1)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          RB::Animation::decode((RB::DisplayList::AnimationStyle *)((char *)this + 56), a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v5);
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::DisplayList::AnimationStyle::print(RB::DisplayList::AnimationStyle *this, std::string *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  RB::SexpString::push(a2, "animation");
  if (*((_DWORD *)this + 28) != 273) {
    RB::SexpString::printf(a2, 0, "(flags 0x%x)", *((_DWORD *)this + 28));
  }
  memset(out, 0, 37);
  uuid_unparse((const unsigned __int8 *)this + 96, out);
  RB::SexpString::printf(a2, 1, "(id %s)", out);
  if (*((_DWORD *)this + 22))
  {
    RB::XML::Document::Document((RB::XML::Document *)&v6);
    RB::Animation::xml_elements((uint64_t)this + 56, (RB::XML::Document *)&v6);
    RB::XML::Document::print_children((RB::XML::Document *)&v6, a2, 0);
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v8);
    if (v7) {
      free(v7);
    }
    uint64_t v4 = v6;
    if (v6)
    {
      int v5 = *(_DWORD *)(v6 + 8) - 1;
      *(_DWORD *)(v6 + 8) = v5;
      if (!v5) {
        (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
      }
    }
  }
  RB::DisplayList::Style::print((const RB::AffineTransform **)this, a2);
  RB::SexpString::pop(a2);
}

void sub_2141D5638(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  RB::XML::Document::~Document((RB::XML::Document *)va);
  _Unwind_Resume(a1);
}

double RB::DisplayList::State::add_animation(__n128 *this, RB::DisplayList::Builder *a2, const RB::Animation *a3, UUID *a4, int a5)
{
  uint64_t v10 = a3;
  int v9 = a5;
  unint64_t v7 = RB::Heap::emplace<RB::DisplayList::AnimationStyle,RB::Animation const*,RB::UUID const&,unsigned int const&>((size_t *)(*((void *)a2 + 1) + 16), &v10, a4, &v9);
  *(void *)&double result = RB::DisplayList::State::add_style(this, a2, v7).n128_u64[0];
  return result;
}

uint64_t RB::DisplayList::find_animation(RB::DisplayList *this, const RB::DisplayList::Item *a2, const RB::DisplayList::Item *a3)
{
  if (this && a2)
  {
    for (uint64_t i = *((void *)this + 2); i; uint64_t i = *(void *)(i + 32))
    {
      if ((*(unsigned char *)(i + 52) & 1) == 0) {
        break;
      }
    }
    uint64_t v5 = *((void *)a2 + 2);
    if (!v5) {
      return 0;
    }
    while ((*(unsigned char *)(v5 + 52) & 1) != 0)
    {
      uint64_t v5 = *(void *)(v5 + 32);
      if (!v5) {
        return 0;
      }
    }
    if (!i) {
      return 0;
    }
LABEL_29:
    if ((*(unsigned int (**)(uint64_t))(*(void *)i + 16))(i) == 7)
    {
      uint64_t v10 = v5;
LABEL_31:
      if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 16))(v10) != 7
        || !RB::same_identity<RB::DisplayList::Style>(i, v10))
      {
        while (1)
        {
          uint64_t v10 = *(void *)(v10 + 32);
          if (!v10) {
            break;
          }
          if ((*(unsigned char *)(v10 + 52) & 1) == 0) {
            goto LABEL_31;
          }
        }
      }
      if (v10) {
        uint64_t v5 = v10;
      }
      uint64_t v12 = i;
      uint64_t v11 = i;
      uint64_t i = v10;
      goto LABEL_51;
    }
    if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 16))(v5) == 7)
    {
      uint64_t v11 = i;
LABEL_38:
      if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 16))(v11) != 7
        || !RB::same_identity<RB::DisplayList::Style>(i, v11))
      {
        while (1)
        {
          uint64_t v11 = *(void *)(v11 + 32);
          if (!v11) {
            break;
          }
          if ((*(unsigned char *)(v11 + 52) & 1) == 0) {
            goto LABEL_38;
          }
        }
      }
      if (v11) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = i;
      }
      if (v11)
      {
LABEL_51:
        if (i)
        {
          if ((*(_DWORD *)(i + 112) & 0xF00) == 0x100)
          {
            uint64_t v13 = v11 + 96;
            if (uuid_is_null((const unsigned __int8 *)v13) || uuid_is_null((const unsigned __int8 *)(i + 96))) {
              return i + 56;
            }
            if (*(void *)v13 != *(void *)(i + 96) || *(void *)(v13 + 8) != *(void *)(i + 104)) {
              return i + 56;
            }
          }
          else if ((*(_DWORD *)(i + 112) & 0xF00) == 0x200)
          {
            return i + 56;
          }
        }
      }
    }
    else
    {
      uint64_t v12 = i;
    }
    for (uint64_t i = *(void *)(v12 + 32); i; uint64_t i = *(void *)(i + 32))
    {
      if ((*(unsigned char *)(i + 52) & 1) == 0) {
        break;
      }
    }
    while (1)
    {
      uint64_t v5 = *(void *)(v5 + 32);
      if (!v5) {
        return 0;
      }
      if ((*(unsigned char *)(v5 + 52) & 1) == 0)
      {
        uint64_t result = 0;
        if (i) {
          goto LABEL_29;
        }
        return result;
      }
    }
  }
  if (this) {
    uint64_t v6 = this;
  }
  else {
    uint64_t v6 = a2;
  }
  if (v6)
  {
    uint64_t i = *((void *)v6 + 2);
    if (i)
    {
      while ((*(unsigned char *)(i + 52) & 1) != 0)
      {
        uint64_t i = *(void *)(i + 32);
        if (!i) {
          return 0;
        }
      }
LABEL_20:
      if ((*(unsigned int (**)(uint64_t, const RB::DisplayList::Item *, const RB::DisplayList::Item *))(*(void *)i + 16))(i, a2, a3) != 7)goto LABEL_18; {
      unsigned int v7 = *(_DWORD *)(i + 112);
      }
      if (!a2) {
        LOBYTE(v7) = v7 >> 4;
      }
      int v8 = v7 & 0xF;
      if (v8 != 1)
      {
        if (v8 != 2) {
          goto LABEL_18;
        }
        return i + 56;
      }
      if (uuid_is_null((const unsigned __int8 *)(i + 96))) {
        return i + 56;
      }
LABEL_18:
      while (1)
      {
        uint64_t i = *(void *)(i + 32);
        if (!i) {
          break;
        }
        if ((*(unsigned char *)(i + 52) & 1) == 0) {
          goto LABEL_20;
        }
      }
    }
  }
  return 0;
}

float RB::DisplayList::CrossFadeStyle::copy(RB::DisplayList::CrossFadeStyle *this, RB::DisplayList::Builder *a2)
{
  uint64_t v6 = 0;
  uint64_t v4 = *((void *)this + 7);
  if (v4) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t, RB::DisplayList::Builder *, uint64_t))(*(void *)v4 + 24))(v4, a2, 4);
  }
  return RB::Heap::emplace<RB::DisplayList::CrossFadeStyle,RB::DisplayList::Item *&,float const&,float const&>((RB::Heap *)(*((void *)a2 + 1) + 16), &v6, (float *)this + 16, (int *)this + 17);
}

float RB::Heap::emplace<RB::DisplayList::CrossFadeStyle,RB::DisplayList::Item *&,float const&,float const&>(RB::Heap *this, uint64_t *a2, float *a3, int *a4)
{
  unint64_t v8 = *((void *)this + 3);
  unint64_t v9 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v9 + 72 > v8) {
    unint64_t v9 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  }
  else {
    *((void *)this + 2) = v9 + 72;
  }
  uint64_t v10 = *a2;
  float result = *a3;
  int v12 = *a4;
  *(void *)(v9 + 48) = 0;
  *(void *)(v9 + 56) = v10;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + 32) = 0u;
  *(void *)unint64_t v9 = &unk_26C4EC1A0;
  *(float *)(v9 + 64) = result;
  *(_DWORD *)(v9 + 68) = v12;
  return result;
}

uint64_t RB::DisplayList::CrossFadeStyle::apply_transform(RB::DisplayList::CrossFadeStyle *this, const RB::DisplayList::CachedTransform *a2)
{
  uint64_t result = *((void *)this + 7);
  if (result) {
    return (*(uint64_t (**)(uint64_t, const RB::DisplayList::CachedTransform *))(*(void *)result + 32))(result, a2);
  }
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::CrossFadeStyle::draw(RB::DisplayList::CrossFadeStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  uint64_t v10 = *((void *)this + 7);
  if (v10)
  {
    uint64_t v11 = (*(uint64_t (**)(uint64_t, RB::DisplayList::Builder *, uint64_t))(*(void *)v10 + 24))(v10, a2, 4);
    RB::DisplayList::Item::apply_alpha(v11, 1.0 - *((float *)this + 16));
  }
  else
  {
    uint64_t v11 = 0;
  }
  float v12 = *((float *)this + 17);
  if (v12 == 0.0)
  {
    float v26 = 0.0;
  }
  else
  {
    _H0 = *((short float *)a4 + 22);
    if (_H0 != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
    {
      __asm { FCVT            S0, H0 }
      float v12 = _S0 / v12;
    }
    float v26 = v12;
    float32x2_t v19 = vrecpe_f32((float32x2_t)LODWORD(v12));
    float32x2_t v20 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v12), v19), v19);
    RB::DisplayList::Item::apply_alpha((uint64_t)a4, *((float *)this + 16) * vmul_f32(v20, vrecps_f32((float32x2_t)LODWORD(v12), v20)).f32[0]);
  }
  *((void *)a4 + 2) = *((void *)this + 4);
  if (v11)
  {
    int v29 = *((_WORD *)a4 + 23) & 0x3F;
    uint64_t v21 = *((void *)a4 + 4);
    int v22 = *((_DWORD *)a4 + 10);
    *(_WORD *)(v11 + 46) = *(_WORD *)(v11 + 46) & 0xFFC0 | 2;
    *(void *)(v11 + 32) = 0;
    *(_DWORD *)(v11 + 40) = 0;
    *((_WORD *)a4 + 23) = *((_WORD *)a4 + 23) & 0xFFC0 | 0xB;
    *((void *)a4 + 4) = 0;
    *((_DWORD *)a4 + 10) = 0;
    layer = (RB::DisplayList::Layer *)RB::DisplayList::Builder::make_layer(a2, 0);
    RB::DisplayList::Builder::draw(a2, (RB::DisplayList::Item *)v11, layer, 0);
    RB::DisplayList::Builder::draw(a2, a4, layer, 0);
    float64x2_t v23 = (size_t *)(*((void *)a2 + 1) + 16);
    int v27 = 1;
    RB::Heap::emplace<RB::DisplayList::LayerItem,int,RB::BlendMode,RB::DisplayList::Layer *&>(v23, &v27, &v29, (uint64_t *)&layer);
    a4 = (RB::DisplayList::Item *)v24;
    *(void *)(v24 + 32) = v21;
    *(_DWORD *)(v24 + 40) = v22;
  }
  RB::DisplayList::Item::apply_alpha((uint64_t)a4, v26);
  *((void *)a4 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, *((void **)a4 + 3), *((const RB::DisplayList::ClipNode **)this + 3));
  return RB::DisplayList::Builder::draw(a2, a4, a3, a5);
}

uint64_t RB::DisplayList::CrossFadeStyle::prepare_encode(RB::DisplayList::CrossFadeStyle *this, RB::Encoder *a2)
{
  RB::DisplayList::Style::prepare_encode(this, a2);
  uint64_t result = *((void *)this + 7);
  if (result)
  {
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 240);
    return v4();
  }
  return result;
}

void *RB::DisplayList::CrossFadeStyle::encode(RB::DisplayList::CrossFadeStyle *this, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x72uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  if (*((void *)this + 7))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    (*(void (**)(void, RB::Encoder *))(**((void **)this + 7) + 248))(*((void *)this + 7), a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  int v4 = *((int *)this + 16);
  if (*(float *)&v4 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x15uLL);
    RB::ProtobufEncoder::encode_fixed32(a2, v4);
  }
  int v5 = *((int *)this + 17);
  if (*(float *)&v5 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x15uLL);
    RB::ProtobufEncoder::encode_fixed32(a2, v5);
  }
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

unint64_t RB::DisplayList::CrossFadeStyle::decode(RB::DisplayList::CrossFadeStyle *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      unint64_t v6 = v5 >> 3;
      if ((v5 >> 3) == 3)
      {
        *((float *)this + 17) = RB::ProtobufDecoder::float_field(a2, v5);
      }
      else if (v6 == 2)
      {
        *((float *)this + 16) = RB::ProtobufDecoder::float_field(a2, v5);
      }
      else if (v6 == 1)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          uint64_t v8 = RB::DisplayList::Item::decode(a2, v7);
          if (v8)
          {
            uint64_t v9 = v8;
            uint64_t v10 = (void (***)(void))*((void *)this + 7);
            *((void *)this + 7) = v9;
            if (v10) {
              (**v10)(v10);
            }
          }
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v5);
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::DisplayList::CrossFadeStyle::print(RB::DisplayList::CrossFadeStyle *this, std::string *a2)
{
  RB::SexpString::push(a2, "cross-fade");
  RB::SexpString::printf(a2, 0, "(t %g)", *((float *)this + 16));
  float v4 = *((float *)this + 17);
  if (v4 != 1.0) {
    RB::SexpString::printf(a2, 0, "(to-alpha %g)", v4);
  }
  if (*((void *)this + 7))
  {
    RB::SexpString::push(a2, "from");
    (*(void (**)(void))(**((void **)this + 7) + 256))();
    RB::SexpString::pop(a2);
  }
  RB::DisplayList::Style::print((const RB::AffineTransform **)this, a2);
  RB::SexpString::pop(a2);
}

void RB::DisplayList::Style::roi(RB::DisplayList::Style *this, float32x2_t *a2, float64x2_t *a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  unint64_t v18 = 0;
  uint64_t v19 = 0x4000000000;
  if (this)
  {
    unint64_t v5 = this;
    int v6 = 0;
    do
    {
      unsigned int v7 = v6 + 1;
      if (HIDWORD(v19) < v6 + 1)
      {
        RB::vector<RB::DisplayList::Style const*,64ul,unsigned int>::reserve_slow(__dst, v7);
        int v6 = v19;
        unsigned int v7 = v19 + 1;
      }
      uint64_t v8 = v18;
      if (!v18) {
        uint64_t v8 = __dst;
      }
      *(void *)&v8[8 * v6] = v5;
      LODWORD(v19) = v7;
      unint64_t v5 = (RB::DisplayList::Style *)*((void *)v5 + 4);
      int v6 = v7;
    }
    while (v5);
  }
  else
  {
    unsigned int v7 = 0;
  }
  for (uint64_t i = 8 * v7 - 8; i != -8; i -= 8)
  {
    uint64_t v10 = v18;
    if (!v18) {
      uint64_t v10 = __dst;
    }
    uint64_t v11 = *(void **)&v10[i];
    uint64_t v12 = v11[3];
    if (v12)
    {
      RB::Rect::move_identity(a2, a3);
      RB::Rect::intersect(a2, *(double *)(v12 + 16), *(float32x2_t *)(v12 + 24), v13, v14, v15, v16);
    }
    (*(void (**)(void *, float32x2_t *, float64x2_t *))(*v11 + 56))(v11, a2, a3);
  }
  if (v18) {
    free(v18);
  }
}

void sub_2141D61B0(_Unwind_Exception *a1)
{
  if (STACK[0x208]) {
    free((void *)STACK[0x208]);
  }
  _Unwind_Resume(a1);
}

RB::DisplayList::AnimationStyle *RB::DisplayList::Style::decode(RB::Heap **this, RB::Decoder *a2)
{
  uint32x2_t v3 = 0;
  uint64_t v59 = 0;
  uint64_t v75 = *MEMORY[0x263EF8340];
  v61[0] = xmmword_2142181C0;
  v61[1] = xmmword_2142181D0;
  uint64_t v62 = 0;
  uint64_t v63 = 0;
  memset(v60, 0, sizeof(v60));
  while (1)
  {
    float v4 = v3;
    unint64_t field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
    uint64_t v6 = field;
    if (!field) {
      break;
    }
    switch((field >> 3))
    {
      case 1u:
        if ((field & 7) != 2) {
          goto LABEL_155;
        }
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        RB::AffineTransform::decode((RB::AffineTransform *)v61, (RB::ProtobufDecoder *)this);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        continue;
      case 2u:
        uint64_t v59 = RB::Decoder::shared_field_f<RB::DisplayList::ClipNode,RB::DisplayList::ClipNode const* RB::Decoder::shared_field<RB::DisplayList::ClipNode>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType)::{lambda(RB::DisplayList::ClipNode&)#1}>((RB::ProtobufDecoder *)this, field, 4, (uint64_t)&v64);
        goto LABEL_7;
      case 3u:
        unsigned int v7 = this[9];
        if (v7 && (uint64_t v8 = (size_t *)(*(uint64_t (**)(RB::Heap *))(*(void *)v7 + 32))(v7)) != 0)
        {
          if ((v6 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
            RB::DisplayList::decode_metadata((RB::DisplayList *)this, v8, (RB::DisplayList::Contents *)&v60[4], (const RB::DisplayList::Metadata **)v60, v9);
            RB::ProtobufDecoder::end_message((uint64_t)this);
            uint32x2_t v3 = v4;
          }
          else
          {
LABEL_155:
            *((unsigned char *)this + 56) = 1;
            *this = this[1];
LABEL_7:
            uint32x2_t v3 = v4;
          }
        }
        else
        {
          RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v6);
          uint32x2_t v3 = v4;
        }
        continue;
      case 4u:
        RB::Heap::emplace<RB::DisplayList::ShadowStyle>(this[8]);
        uint32x2_t v3 = v10;
        if ((v6 & 7) != 2) {
          goto LABEL_153;
        }
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        RB::DisplayList::ShadowStyle::decode(v3, (RB::Decoder *)this);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        goto LABEL_146;
      case 5u:
        RB::Heap::emplace<RB::DisplayList::PathProjectionStyle>(this[8]);
        uint32x2_t v3 = v11;
        if ((v6 & 7) != 2) {
          goto LABEL_153;
        }
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        RB::DisplayList::PathProjectionStyle::decode((float64x2_t *)v3, (RB::Decoder *)this);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        goto LABEL_146;
      case 6u:
        if ((field & 7) != 2) {
          goto LABEL_155;
        }
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        for (unint64_t i = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
              ;
              unint64_t i = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this))
        {
          char v13 = i;
          if (!i) {
            break;
          }
          switch((i >> 3))
          {
            case 1u:
              v64.n128_u32[0] = 0;
              RB::ColorMatrix::set_identity((RB::ColorMatrix *)&v64.n128_i8[8]);
              if ((v13 & 7) == 2)
              {
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RB::Filter::ColorMatrix::decode((RB::Filter::ColorMatrix *)&v64, (RB::Decoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
              }
              else
              {
                *((unsigned char *)this + 56) = 1;
                *this = this[1];
              }
              __n128 v15 = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix>(this[8], (uint64_t)&v64);
              goto LABEL_55;
            case 2u:
              v64.n128_u32[0] = 0;
              v65[0] = 0;
              v65[1] = 0;
              *(void *)((char *)&v65[1] + 6) = 0;
              *(_DWORD *)((char *)&v65[2] + 6) = 15360;
              if ((i & 7) == 2)
              {
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RB::Filter::LuminanceCurve::decode(&v64, (RB::Decoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
              }
              else
              {
                *((unsigned char *)this + 56) = 1;
                *this = this[1];
              }
              __n128 v15 = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve>(this[8], (uint64_t)&v64);
              goto LABEL_55;
            case 3u:
              v64.n128_u32[0] = 0;
              v65[2] = 0;
              v64.n128_u64[1] = 0;
              v65[0] = 0;
              LODWORD(v65[1]) = 0;
              if ((i & 7) == 2)
              {
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RB::Filter::GaussianBlur::decode((RB::Filter::GaussianBlur *)&v64, (RB::Decoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
              }
              else
              {
                *((unsigned char *)this + 56) = 1;
                *this = this[1];
              }
              __n128 v16 = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur>(this[8], (uint64_t)&v64);
              unint64_t v18 = v17;
              if (v4) {
                (**(void (***)(RB::DisplayList::AnimationStyle *, __n128))v4)(v4, v16);
              }
              uint64_t v19 = (void (***)(void, __n128))v65[2];
              v65[2] = 0;
              if (v19) {
                (**v19)(v19, v16);
              }
              goto LABEL_57;
            case 4u:
              v64.n128_u32[0] = 0;
              v64.n128_u64[1] = 0;
              uint64_t v68 = 0;
              unint64_t v69 = 0;
              uint64_t v70 = 4;
              long long v71 = xmmword_2142181C0;
              long long v72 = xmmword_2142181D0;
              long long v73 = 0u;
              long long v74 = 0u;
              if ((i & 7) == 2)
              {
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RB::Filter::Custom::decode(&v64, (RB::Decoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
              }
              else
              {
                *((unsigned char *)this + 56) = 1;
                *this = this[1];
              }
              unint64_t v18 = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Custom>,RB::Filter::Custom const&,RB::DisplayList::Builder &>((size_t *)this[8], (uint64_t)&v64);
              if (v4) {
                (**(void (***)(RB::DisplayList::AnimationStyle *))v4)(v4);
              }
              uint64_t v20 = v68;
              if (v68) {
                uint64_t v21 = (const void **)v68;
              }
              else {
                uint64_t v21 = (const void **)v65;
              }
              if (v69)
              {
                for (unint64_t j = 0; j < v69; ++j)
                {
                  RB::CustomShader::Value::reset_data(v21);
                  v21 += 3;
                }
                uint64_t v20 = v68;
              }
              if (v20) {
                free(v20);
              }
              unint64_t v23 = v64.n128_u64[1];
              if (v64.n128_u64[1]
                && atomic_fetch_add_explicit((atomic_uint *volatile)(v64.n128_u64[1] + 8), 0xFFFFFFFF, memory_order_release) == 1)
              {
                __dmb(9u);
                (*(void (**)(unint64_t))(*(void *)v23 + 8))(v23);
              }
              goto LABEL_57;
            case 5u:
              v64.n128_u32[0] = 0;
              memset(v65, 0, sizeof(v65));
              long long v66 = 0u;
              long long v67 = 0u;
              if ((i & 7) == 2)
              {
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RB::Filter::RGBACurves::decode(&v64, (RB::Decoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
              }
              else
              {
                *((unsigned char *)this + 56) = 1;
                *this = this[1];
              }
              __n128 v15 = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>,RB::Filter::RGBACurves>(this[8], (uint64_t)&v64);
              goto LABEL_55;
            case 6u:
              v64.n128_u64[0] = 0x3F80000000000000;
              v64.n128_u32[2] = 0;
              if ((i & 7) == 2)
              {
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RB::Filter::Distance::decode((uint64_t)&v64, (RB::ProtobufDecoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
              }
              else
              {
                *((unsigned char *)this + 56) = 1;
                *this = this[1];
              }
              v15.n128_f64[0] = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Distance>,RB::Filter::Distance>(this[8], (uint64_t *)&v64);
LABEL_55:
              unint64_t v18 = v14;
              if (v4) {
                (**(void (***)(RB::DisplayList::AnimationStyle *, __n128))v4)(v4, v15);
              }
LABEL_57:
              float v4 = (RB::DisplayList::AnimationStyle *)v18;
              break;
            default:
              RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, i);
              break;
          }
        }
        goto LABEL_148;
      case 7u:
        if ((field & 7) != 2) {
          goto LABEL_155;
        }
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        unint64_t v24 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
        while (2)
        {
          char v25 = v24;
          if (v24)
          {
            switch((v24 >> 3))
            {
              case 1u:
                RB::Heap::emplace<RB::DisplayList::ProjectionStyle>(this[8]);
                int v27 = v26;
                if ((v25 & 7) != 2) {
                  goto LABEL_87;
                }
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RB::ProjectionMatrix::decode((uint64_t)&v27[3].n128_i64[1], (RB::ProtobufDecoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
                goto LABEL_83;
              case 2u:
                v64.n128_u64[0] = 0;
                RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>>(this[8]);
                unint64_t v29 = v28;
                v64.n128_u64[0] = v28;
                if ((v25 & 7) == 2)
                {
                  RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                  RB::AlphaThresholdEffect::decode((RB::AlphaThresholdEffect *)(v29 + 16), (RB::Decoder *)this);
                  RB::ProtobufDecoder::end_message((uint64_t)this);
                }
                else
                {
                  *((unsigned char *)this + 56) = 1;
                  *this = this[1];
                }
                v31.n128_f64[0] = RB::Heap::emplace<RB::DisplayList::AlphaThresholdStyle,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> *&>(this[8], (uint64_t *)&v64);
                goto LABEL_78;
              case 3u:
                v64.n128_u64[0] = 0;
                RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>>(this[8]);
                unint64_t v33 = v32;
                v64.n128_u64[0] = v32;
                if ((v25 & 7) == 2)
                {
                  RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                  RB::AlphaGradientEffect::decode((RB::AlphaGradientEffect *)(v33 + 16), (RB::Decoder *)this);
                  RB::ProtobufDecoder::end_message((uint64_t)this);
                }
                else
                {
                  *((unsigned char *)this + 56) = 1;
                  *this = this[1];
                }
                v31.n128_f64[0] = RB::Heap::emplace<RB::DisplayList::AlphaGradientStyle,RB::DisplayList::GenericEffect<RB::AlphaGradientEffect> *&>(this[8], (uint64_t *)&v64);
LABEL_78:
                int32x4_t v34 = v30;
                if (v4) {
                  (**(void (***)(RB::DisplayList::AnimationStyle *, __n128))v4)(v4, v31);
                }
                float v4 = v34;
                goto LABEL_86;
              case 4u:
                RB::Heap::emplace<RB::DisplayList::CustomEffectStyle>(this[8]);
                int v27 = v35;
                if ((v25 & 7) == 2)
                {
                  RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                  RB::DisplayList::CustomEffectStyle::decode(v27, (size_t **)this);
                  RB::ProtobufDecoder::end_message((uint64_t)this);
LABEL_83:
                  if (v4) {
                    goto LABEL_84;
                  }
                }
                else
                {
LABEL_87:
                  *((unsigned char *)this + 56) = 1;
                  *this = this[1];
                  if (v4) {
LABEL_84:
                  }
                    (**(void (***)(RB::DisplayList::AnimationStyle *))v4)(v4);
                }
                float v4 = (RB::DisplayList::AnimationStyle *)v27;
LABEL_86:
                unint64_t v24 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
                continue;
              default:
                RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v24);
                goto LABEL_86;
            }
          }
          break;
        }
LABEL_148:
        RB::ProtobufDecoder::end_message((uint64_t)this);
        uint32x2_t v3 = v4;
        break;
      case 8u:
        RB::Heap::emplace<RB::DisplayList::PredicateStyle>(this[8]);
        uint32x2_t v3 = v36;
        if ((v6 & 7) != 2) {
          goto LABEL_153;
        }
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        RB::DisplayList::InvertiblePredicate::decode((RB::DisplayList::AnimationStyle *)((char *)v3 + 56), (RB::Decoder *)this);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        goto LABEL_146;
      case 9u:
        RB::Heap::emplace<RB::DisplayList::TransformStyle>(this[8]);
        uint32x2_t v3 = v37;
        if ((v6 & 7) != 2) {
          goto LABEL_153;
        }
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        RB::DisplayList::Transform::decode((RB::DisplayList::AnimationStyle *)((char *)v3 + 56), (RB::Decoder *)this);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        goto LABEL_146;
      case 0xAu:
        if ((field & 7) != 2) {
          goto LABEL_155;
        }
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        for (k = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this); k; float v4 = v3)
        {
          switch((k >> 3))
          {
            case 1u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>>(this[8]);
              uint64_t v40 = v39;
              if ((k & 7) != 2) {
                goto LABEL_121;
              }
              goto LABEL_99;
            case 2u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>>(this[8]);
              uint64_t v40 = v41;
              if ((k & 7) != 2) {
                goto LABEL_121;
              }
LABEL_99:
              RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
              RB::ColorStyle::ColorMultiply::decode((RB::ColorStyle::ColorMultiply *)(v40 + 56), (RB::Decoder *)this);
              RB::ProtobufDecoder::end_message((uint64_t)this);
              goto LABEL_117;
            case 3u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>>(this[8]);
              uint64_t v40 = v42;
              if ((k & 7) == 2) {
                goto LABEL_116;
              }
              goto LABEL_121;
            case 4u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>>(this[8]);
              uint64_t v40 = v43;
              if ((k & 7) == 2) {
                goto LABEL_116;
              }
              goto LABEL_121;
            case 5u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>>(this[8]);
              uint64_t v40 = v44;
              if ((k & 7) == 2) {
                goto LABEL_116;
              }
              goto LABEL_121;
            case 6u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>>(this[8]);
              uint64_t v40 = v45;
              if ((k & 7) == 2) {
                goto LABEL_116;
              }
              goto LABEL_121;
            case 7u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>>(this[8]);
              uint64_t v40 = v46;
              if ((k & 7) != 2) {
                goto LABEL_121;
              }
              RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
              RB::ColorStyle::LuminanceToAlpha::decode((_DWORD *)(v40 + 56), (RB::ProtobufDecoder *)this);
              RB::ProtobufDecoder::end_message((uint64_t)this);
              goto LABEL_117;
            case 8u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>>(this[8]);
              uint64_t v40 = v47;
              if ((k & 7) != 2) {
                goto LABEL_121;
              }
              RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
              RB::ColorStyle::ColorMonochrome::decode((RB::ColorStyle::ColorMonochrome *)(v40 + 56), (RB::Decoder *)this);
              RB::ProtobufDecoder::end_message((uint64_t)this);
              goto LABEL_117;
            case 9u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>>(this[8]);
              uint64_t v40 = v48;
              if ((k & 7) == 2)
              {
LABEL_116:
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RB::ColorStyle::HueRotation::decode(v40 + 56, (RB::ProtobufDecoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
              }
              else
              {
LABEL_121:
                *((unsigned char *)this + 56) = 1;
                *this = this[1];
              }
LABEL_117:
              uint32x2_t v3 = (RB::DisplayList::AnimationStyle *)v40;
              if (v4) {
                (**(void (***)(RB::DisplayList::AnimationStyle *))v4)(v4);
              }
              break;
            default:
              uint32x2_t v3 = v4;
              RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, k);
              break;
          }
          unint64_t k = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
        }
        goto LABEL_151;
      case 0xBu:
        uint32x2_t v3 = RB::Heap::emplace<RB::DisplayList::AnimationStyle>((size_t *)this[8]);
        if ((v6 & 7) != 2) {
          goto LABEL_153;
        }
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        RB::DisplayList::AnimationStyle::decode(v3, (RB::Decoder *)this);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        goto LABEL_146;
      case 0xDu:
        if ((field & 7) != 2) {
          goto LABEL_155;
        }
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        for (m = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this); m; float v4 = v3)
        {
          switch((m >> 3))
          {
            case 1u:
              RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>>(this[8]);
              long long v51 = v50;
              if ((m & 7) != 2) {
                goto LABEL_143;
              }
              RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
              RB::GeometryStyle::Rotation::decode((RB::GeometryStyle::Rotation *)&v51[3].n128_i8[8], (RB::Decoder *)this);
              RB::ProtobufDecoder::end_message((uint64_t)this);
              goto LABEL_139;
            case 2u:
              RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>>(this[8]);
              long long v51 = v52;
              if ((m & 7) != 2) {
                goto LABEL_143;
              }
              RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
              RB::GeometryStyle::Scale::decode((RB::GeometryStyle::Scale *)&v51[3].n128_i8[8], (RB::Decoder *)this);
              RB::ProtobufDecoder::end_message((uint64_t)this);
              goto LABEL_139;
            case 3u:
              RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>>(this[8]);
              long long v51 = v53;
              if ((m & 7) != 2) {
                goto LABEL_143;
              }
              RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
              RB::GeometryStyle::Rotation3D::decode(v51 + 4, (RB::Decoder *)this);
              RB::ProtobufDecoder::end_message((uint64_t)this);
              goto LABEL_139;
            case 4u:
              RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>>(this[8]);
              long long v51 = v54;
              if ((m & 7) != 2) {
                goto LABEL_143;
              }
              RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
              RB::GeometryStyle::Translation::decode((RB::GeometryStyle::Translation *)&v51[3].n128_i8[8], (RB::Decoder *)this);
              RB::ProtobufDecoder::end_message((uint64_t)this);
              goto LABEL_139;
            case 5u:
              RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>>(this[8]);
              long long v51 = v55;
              if ((m & 7) == 2)
              {
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RB::GeometryStyle::Affine::decode((RB::GeometryStyle::Affine *)&v51[4], (RB::Decoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
              }
              else
              {
LABEL_143:
                *((unsigned char *)this + 56) = 1;
                *this = this[1];
              }
LABEL_139:
              uint32x2_t v3 = (RB::DisplayList::AnimationStyle *)v51;
              if (v4) {
                (**(void (***)(RB::DisplayList::AnimationStyle *))v4)(v4);
              }
              break;
            default:
              uint32x2_t v3 = v4;
              RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, m);
              break;
          }
          unint64_t m = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
        }
LABEL_151:
        RB::ProtobufDecoder::end_message((uint64_t)this);
        continue;
      case 0xEu:
        RB::Heap::emplace<RB::DisplayList::CrossFadeStyle>(this[8]);
        uint32x2_t v3 = v56;
        if ((v6 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::DisplayList::CrossFadeStyle::decode(v3, (RB::Decoder *)this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
LABEL_146:
          if (v4)
          {
LABEL_147:
            (**(void (***)(RB::DisplayList::AnimationStyle *))v4)(v4);
            continue;
          }
        }
        else
        {
LABEL_153:
          *((unsigned char *)this + 56) = 1;
          *this = this[1];
          if (v4) {
            goto LABEL_147;
          }
        }
        continue;
      default:
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, field);
        continue;
    }
  }
  if (v3)
  {
    RB::Decoder::emplace<RB::AffineTransform,RB::AffineTransform&>((uint64_t)this, (uint64_t)v61);
    *((void *)v3 + 2) = v57;
    *((void *)v3 + 3) = v59;
  }
  else
  {
    *((unsigned char *)this + 56) = 1;
    *this = this[1];
  }
  return v3;
}

void sub_2141D7154(_Unwind_Exception *a1)
{
  (**v1)(v1);
  _Unwind_Resume(a1);
}

__n128 RB::Decoder::emplace<RB::AffineTransform,RB::AffineTransform&>(uint64_t a1, uint64_t a2)
{
  uint32x2_t v3 = *(size_t **)(a1 + 64);
  unint64_t v4 = (v3[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v4 + 48 > v3[3]) {
    unint64_t v4 = RB::Heap::alloc_slow(v3, 0x30uLL, 15);
  }
  else {
    v3[2] = v4 + 48;
  }
  __n128 result = *(__n128 *)a2;
  long long v6 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v4 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v4 + 32) = v6;
  *(__n128 *)unint64_t v4 = result;
  return result;
}

uint64_t RB::DisplayList::Style::can_mix(RB::DisplayList::Style *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Style *a3)
{
  return 0;
}

void RB::DisplayList::ShadowStyle::~ShadowStyle(RB::DisplayList::ShadowStyle *this)
{
}

uint64_t RB::DisplayList::ShadowStyle::type_id(RB::DisplayList::ShadowStyle *this)
{
  return 0;
}

void RB::DisplayList::CrossFadeStyle::~CrossFadeStyle(RB::DisplayList::CrossFadeStyle *this)
{
  unint64_t v2 = (void (***)(void))*((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v2) {
    (**v2)(v2);
  }
}

{
  void (***v2)(void);
  uint64_t vars8;

  unint64_t v2 = (void (***)(void))*((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v2) {
    (**v2)(v2);
  }
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::CrossFadeStyle::type_id(RB::DisplayList::CrossFadeStyle *this)
{
  return 10;
}

void RB::DisplayList::ProjectionStyle::~ProjectionStyle(RB::DisplayList::ProjectionStyle *this)
{
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::type_id()
{
  return 24582;
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::copy(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>,RB::GeometryStyle::Projection const&>((RB::Heap *)(*(void *)(a2 + 8) + 16), a1 + 56).n128_u64[0];
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::draw(uint64_t a1, size_t **this, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  *((void *)a4 + 2) = *(void *)(a1 + 32);
  long long v5 = *(_OWORD *)(a1 + 72);
  v7[0] = *(_OWORD *)(a1 + 56);
  v7[1] = v5;
  int v8 = *(_DWORD *)(a1 + 88);
  return RB::DisplayList::Builder::projection_style_draw(this, a3, a4, a5, (const RB::ProjectionMatrix *)v7, *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::bounds(uint64_t a1, const RB::DisplayList::Style *a2, const RB::DisplayList::Item *a3, uint64_t a4, const RB::ProjectionMatrix *a5)
{
  long long v5 = *(_OWORD *)(a1 + 72);
  v7[0] = *(_OWORD *)(a1 + 56);
  v7[1] = v5;
  int v8 = *(_DWORD *)(a1 + 88);
  return RB::DisplayList::projection_style_bounds((float64x2_t **)a1, a2, a3, (uint64_t)v7, a5);
}

float32x2_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::map_roi(uint64_t a1, float32x2_t *this, float64x2_t *a3)
{
  long long v3 = *(_OWORD *)(a1 + 72);
  v8[0] = *(_OWORD *)(a1 + 56);
  v8[1] = v3;
  int v9 = *(_DWORD *)(a1 + 88);
  uint32x2_t v4 = (uint32x2_t)vcge_f32((float32x2_t)(*(void *)&this[1] & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  float32x2_t result = (float32x2_t)vpmax_u32(v4, v4);
  if ((result.i32[0] & 0x80000000) == 0)
  {
    RB::Rect::move(this, a3, *(float64x2_t **)(a1 + 16));
    if (!RB::unapply(this, (RB::Rect *)v8, v7))
    {
      float32x2_t result = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
      *this = (float32x2_t)0x100000001000000;
      this[1] = result;
    }
  }
  return result;
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && RB::ProjectionMatrix::operator==((float *)(a1 + 56), (float *)(a3 + 56))) {
    return 4;
  }
  else {
    return 1;
  }
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>,RB::GeometryStyle::Projection const&>((RB::Heap *)(*(void *)(*(void *)a4 + 8) + 16), a1 + 56);
  uint64_t v7 = v6;
  int v8 = (float32x4_t *)(v6 + 56);
  if (a3) {
    int v9 = (float32x4_t *)(a3 + 56);
  }
  else {
    int v9 = 0;
  }
  RB::GeometryStyle::Projection::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "geometry");
  RB::GeometryStyle::Projection::print((RB::GeometryStyle::Projection *)(a1 + 7), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

void RB::DisplayList::PathProjectionStyle::~PathProjectionStyle(RB::DisplayList::PathProjectionStyle *this)
{
}

{
  uint64_t vars8;

  RBPathRelease(*((void *)this + 12), *((void *)this + 13));
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::PathProjectionStyle::type_id(RB::DisplayList::PathProjectionStyle *this)
{
  return 1;
}

void RB::DisplayList::AlphaThresholdStyle::~AlphaThresholdStyle(RB::DisplayList::AlphaThresholdStyle *this)
{
}

uint64_t RB::DisplayList::AlphaThresholdStyle::type_id(RB::DisplayList::AlphaThresholdStyle *this)
{
  return 11;
}

void RB::DisplayList::AlphaGradientStyle::~AlphaGradientStyle(RB::DisplayList::AlphaGradientStyle *this)
{
}

uint64_t RB::DisplayList::AlphaGradientStyle::type_id(RB::DisplayList::AlphaGradientStyle *this)
{
  return 12;
}

void RB::DisplayList::CustomEffectStyle::~CustomEffectStyle(RB::DisplayList::CustomEffectStyle *this)
{
  unint64_t v2 = (RB::DisplayList::Layer *)*((void *)this + 23);
  *((void *)this + 23) = 0;
  if (v2) {
    RB::DisplayList::Layer::~Layer(v2);
  }
  long long v3 = (void *)*((void *)this + 20);
  if (v3) {
    uint32x2_t v4 = (const void **)*((void *)this + 20);
  }
  else {
    uint32x2_t v4 = (const void **)((char *)this + 64);
  }
  if (*((void *)this + 21))
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < *((void *)this + 21));
    long long v3 = (void *)*((void *)this + 20);
  }
  if (v3) {
    free(v3);
  }
  uint64_t v6 = (atomic_uint *)*((void *)this + 7);
  if (v6)
  {
    if (atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
    {
      __dmb(9u);
      (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
    }
  }
}

{
  RB::DisplayList::Layer *v2;
  void *v3;
  const void **v4;
  unint64_t v5;
  atomic_uint *v6;
  uint64_t vars8;

  unint64_t v2 = (RB::DisplayList::Layer *)*((void *)this + 23);
  *((void *)this + 23) = 0;
  if (v2) {
    RB::DisplayList::Layer::~Layer(v2);
  }
  long long v3 = (void *)*((void *)this + 20);
  if (v3) {
    uint32x2_t v4 = (const void **)*((void *)this + 20);
  }
  else {
    uint32x2_t v4 = (const void **)((char *)this + 64);
  }
  if (*((void *)this + 21))
  {
    unint64_t v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < *((void *)this + 21));
    long long v3 = (void *)*((void *)this + 20);
  }
  if (v3) {
    free(v3);
  }
  uint64_t v6 = (atomic_uint *)*((void *)this + 7);
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::CustomEffectStyle::type_id(RB::DisplayList::CustomEffectStyle *this)
{
  return 13;
}

void RB::DisplayList::PredicateStyle::~PredicateStyle(RB::DisplayList::PredicateStyle *this)
{
  unint64_t v2 = (void *)*((void *)this + 10);
  if (v2) {
    long long v3 = (RB::DisplayList::Predicate::Term *)*((void *)this + 10);
  }
  else {
    long long v3 = (RB::DisplayList::PredicateStyle *)((char *)this + 56);
  }
  if (*((_DWORD *)this + 22))
  {
    unint64_t v4 = 0;
    do
    {
      RB::DisplayList::Predicate::Term::~Term(v3);
      ++v4;
      long long v3 = (RB::DisplayList::Predicate::Term *)(v5 + 24);
    }
    while (v4 < *((unsigned int *)this + 22));
    unint64_t v2 = (void *)*((void *)this + 10);
  }
  if (v2) {
    free(v2);
  }
}

{
  void *v2;
  RB::DisplayList::Predicate::Term *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t vars8;

  unint64_t v2 = (void *)*((void *)this + 10);
  if (v2) {
    long long v3 = (RB::DisplayList::Predicate::Term *)*((void *)this + 10);
  }
  else {
    long long v3 = (RB::DisplayList::PredicateStyle *)((char *)this + 56);
  }
  if (*((_DWORD *)this + 22))
  {
    unint64_t v4 = 0;
    do
    {
      RB::DisplayList::Predicate::Term::~Term(v3);
      ++v4;
      long long v3 = (RB::DisplayList::Predicate::Term *)(v5 + 24);
    }
    while (v4 < *((unsigned int *)this + 22));
    unint64_t v2 = (void *)*((void *)this + 10);
  }
  if (v2) {
    free(v2);
  }
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::PredicateStyle::type_id(RB::DisplayList::PredicateStyle *this)
{
  return 3;
}

void RB::DisplayList::TransformStyle::~TransformStyle(RB::DisplayList::TransformStyle *this)
{
  unint64_t v2 = (void *)*((void *)this + 11);
  if (v2) {
    long long v3 = (RB::DisplayList::Transform::Term *)*((void *)this + 11);
  }
  else {
    long long v3 = (RB::DisplayList::TransformStyle *)((char *)this + 56);
  }
  if (*((_DWORD *)this + 24))
  {
    unint64_t v4 = 0;
    do
    {
      RB::DisplayList::Transform::Term::~Term(v3);
      ++v4;
      long long v3 = (RB::DisplayList::Transform::Term *)(v5 + 32);
    }
    while (v4 < *((unsigned int *)this + 24));
    unint64_t v2 = (void *)*((void *)this + 11);
  }
  if (v2) {
    free(v2);
  }
}

{
  void *v2;
  RB::DisplayList::Transform::Term *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t vars8;

  unint64_t v2 = (void *)*((void *)this + 11);
  if (v2) {
    long long v3 = (RB::DisplayList::Transform::Term *)*((void *)this + 11);
  }
  else {
    long long v3 = (RB::DisplayList::TransformStyle *)((char *)this + 56);
  }
  if (*((_DWORD *)this + 24))
  {
    unint64_t v4 = 0;
    do
    {
      RB::DisplayList::Transform::Term::~Term(v3);
      ++v4;
      long long v3 = (RB::DisplayList::Transform::Term *)(v5 + 32);
    }
    while (v4 < *((unsigned int *)this + 24));
    unint64_t v2 = (void *)*((void *)this + 11);
  }
  if (v2) {
    free(v2);
  }
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::TransformStyle::type_id(RB::DisplayList::TransformStyle *this)
{
  return 4;
}

void RB::DisplayList::AnimationStyle::~AnimationStyle(RB::DisplayList::AnimationStyle *this)
{
  uint64_t v1 = (void *)*((void *)this + 10);
  if (v1) {
    free(v1);
  }
}

{
  void *v1;
  uint64_t vars8;

  uint64_t v1 = (void *)*((void *)this + 10);
  if (v1) {
    free(v1);
  }
  JUMPOUT(0x21669AC10);
}

uint64_t RB::DisplayList::AnimationStyle::type_id(RB::DisplayList::AnimationStyle *this)
{
  return 7;
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::~GeometryMatrixStyle()
{
}

void *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::encode(void *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x6AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::GeometryStyle::Projection::encode((RB::GeometryStyle::Projection *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

RB::DisplayList::TransformStyle *RB::DisplayList::TransformStyle::TransformStyle(RB::DisplayList::TransformStyle *this, const RB::DisplayList::Transform *a2)
{
  *((void *)this + 6) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(void *)this = &unk_26C4EC2B0;
  long long v3 = (char *)this + 56;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0x100000000;
  if (*((void *)a2 + 4)) {
    unint64_t v4 = (const RB::DisplayList::Transform::Term *)*((void *)a2 + 4);
  }
  else {
    unint64_t v4 = a2;
  }
  unsigned int v5 = *((_DWORD *)a2 + 10);
  unsigned int v6 = v5;
  if (v5 >= 2)
  {
    RB::vector<RB::DisplayList::Transform::Term,1ul,unsigned int>::reserve_slow((char *)this + 56, v5);
    uint64_t v7 = (char *)*((void *)this + 11);
    uint64_t v8 = *((unsigned int *)this + 24);
  }
  else
  {
    if (!v5)
    {
      int v11 = 0;
      goto LABEL_13;
    }
    uint64_t v7 = 0;
    uint64_t v8 = 0;
  }
  if (!v7) {
    uint64_t v7 = v3;
  }
  int v9 = (RB::DisplayList::Transform::Term *)&v7[32 * v8];
  do
  {
    uint64_t v10 = RB::DisplayList::Transform::Term::Term(v9, v4);
    unint64_t v4 = (const RB::DisplayList::Transform::Term *)((char *)v4 + 32);
    int v9 = (RB::DisplayList::Transform::Term *)(v10 + 32);
    --v6;
  }
  while (v6);
  int v11 = *((_DWORD *)this + 24);
LABEL_13:
  *((_DWORD *)this + 24) = v11 + v5;
  return this;
}

void sub_2141D7CF4(_Unwind_Exception *exception_object)
{
  unint64_t v4 = *(void **)(v1 + 88);
  if (v4) {
    unsigned int v5 = *(RB::DisplayList::Transform::Term **)(v1 + 88);
  }
  else {
    unsigned int v5 = v2;
  }
  if (*(_DWORD *)(v1 + 96))
  {
    unint64_t v6 = 0;
    do
    {
      RB::DisplayList::Transform::Term::~Term(v5);
      ++v6;
      unsigned int v5 = (RB::DisplayList::Transform::Term *)(v7 + 32);
    }
    while (v6 < *(unsigned int *)(v1 + 96));
    unint64_t v4 = *(void **)(v1 + 88);
  }
  if (v4) {
    free(v4);
  }
  _Unwind_Resume(exception_object);
}

void *RB::vector<RB::DisplayList::Style const*,64ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 131) + (*((_DWORD *)__dst + 131) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 131) + (*((_DWORD *)__dst + 131) >> 1);
  }
  float32x2_t result = RB::details::realloc_vector<unsigned int,8ul>(*((void **)__dst + 64), __dst, 0x40u, (_DWORD *)__dst + 131, v3);
  *((void *)__dst + 64) = result;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ShadowStyle>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 96 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x60uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 96;
  }
  *(void *)(v3 + 48) = 0;
  *(void *)(v3 + 56) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4EA5F8;
  *(void *)(v3 + 64) = 0x3F00000000000000;
  *(void *)(v3 + 72) = 0x3C00000000000000;
  *(_WORD *)(v3 + 80) = 0;
  *(void *)&double result = 2;
  *(void *)(v3 + 84) = 2;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ProjectionStyle>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 96 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x60uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 96;
  }
  *(void *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_DWORD *)(v3 + 88) = 1065353216;
  *(void *)&double result = 1065353216;
  *(_OWORD *)(v3 + 72) = xmmword_214218320;
  *(_OWORD *)(v3 + 56) = xmmword_214218320;
  *(void *)unint64_t v3 = &unk_26C4EC338;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::CustomEffectStyle>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 232 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0xE8uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 232;
  }
  double result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(void *)unint64_t v3 = &unk_26C4EC888;
  *(_OWORD *)(v3 + 160) = 0u;
  *(void *)(v3 + 176) = 4;
  *(_OWORD *)(v3 + 184) = 0u;
  *(_OWORD *)(v3 + 200) = 0u;
  *(_OWORD *)(v3 + 212) = 0u;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::PredicateStyle>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 104 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x68uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 104;
  }
  *(void *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4EC228;
  *(void *)(v3 + 80) = 0;
  *(void *)&double result = 0x100000000;
  *(void *)(v3 + 88) = 0x100000000;
  *(unsigned char *)(v3 + 96) = 0;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::TransformStyle>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 104 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x68uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 104;
  }
  *(void *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4EC2B0;
  *(void *)(v3 + 88) = 0;
  *(void *)&double result = 0x100000000;
  *(void *)(v3 + 96) = 0x100000000;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 72 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 72;
  }
  *(void *)(v3 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4EC668;
  *(_DWORD *)(v3 + 56) = 0;
  *(void *)(v3 + 60) = 0x3C003C003C003C00;
  *(_WORD *)(v3 + 68) = 0;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 72 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 72;
  }
  *(void *)(v3 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4EC5E0;
  *(_DWORD *)(v3 + 56) = 0;
  *(void *)(v3 + 60) = 0x3C003C003C003C00;
  *(_WORD *)(v3 + 68) = 0;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 64 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 64;
  }
  *(void *)(v3 + 48) = 0;
  *(void *)(v3 + 56) = 0;
  double result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4EC558;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 64 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 64;
  }
  double result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4EC448;
  *(void *)(v3 + 48) = 0;
  *(void *)(v3 + 56) = 0x3F80000000000000;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 64 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 64;
  }
  *(void *)(v3 + 48) = 0;
  *(void *)(v3 + 56) = 0;
  double result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4EC3C0;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 64 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 64;
  }
  double result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4EC800;
  *(void *)(v3 + 48) = 0;
  *(void *)(v3 + 56) = 0x3F80000000000000;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 64 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 64;
  }
  *(void *)(v3 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4EC778;
  *(_DWORD *)(v3 + 56) = 0;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 80 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x50uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 80;
  }
  *(void *)(v3 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4EC6F0;
  *(_DWORD *)(v3 + 56) = 0;
  *(void *)(v3 + 60) = 0x3C003C003C003C00;
  *(_WORD *)(v3 + 68) = 0;
  *(void *)(v3 + 72) = 0;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 64 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 64;
  }
  *(void *)(v3 + 48) = 0;
  *(void *)(v3 + 56) = 0;
  double result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4EC4D0;
  return result;
}

RB::DisplayList::AnimationStyle *RB::Heap::emplace<RB::DisplayList::AnimationStyle>(size_t *a1)
{
  uint64_t v1 = (RB::DisplayList::AnimationStyle *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)v1 + 120 > a1[3]) {
    uint64_t v1 = (RB::DisplayList::AnimationStyle *)RB::Heap::alloc_slow(a1, 0x78uLL, 7);
  }
  else {
    a1[2] = (size_t)v1 + 120;
  }
  return RB::DisplayList::AnimationStyle::AnimationStyle(v1);
}

RB::DisplayList::AnimationStyle *RB::DisplayList::AnimationStyle::AnimationStyle(RB::DisplayList::AnimationStyle *this)
{
  *((void *)this + 6) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(void *)this = &unk_26C4EC118;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0x600000000;
  uuid_clear((unsigned __int8 *)this + 96);
  *((_DWORD *)this + 28) = 273;
  return this;
}

void sub_2141D8528(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)(v1 + 80);
  if (v3) {
    free(v3);
  }
  _Unwind_Resume(exception_object);
}

double RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 72 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 72;
  }
  *(void *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4ECAA8;
  __asm { FMOV            V0.2S, #1.0 }
  *(double *)(v3 + 56) = result;
  *(void *)(v3 + 64) = 0;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 72 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 72;
  }
  *(void *)(v3 + 48) = 0;
  *(void *)(v3 + 56) = 0;
  double result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4ECB30;
  *(void *)(v3 + 64) = 0;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 64 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 64;
  }
  *(void *)(v3 + 48) = 0;
  *(void *)(v3 + 56) = 0;
  double result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4E8600;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 128 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x80uLL, 15);
  }
  else {
    *((void *)this + 2) = v3 + 128;
  }
  *(void *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4ECA20;
  *(void *)(v3 + 64) = 0;
  double result = 0.0;
  *(_OWORD *)(v3 + 80) = xmmword_21421C0E0;
  *(void *)(v3 + 96) = 0;
  *(void *)(v3 + 104) = 0;
  *(void *)(v3 + 112) = 0x7FC0000000000000;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 112 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x70uLL, 15);
  }
  else {
    *((void *)this + 2) = v3 + 112;
  }
  *(void *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4E8688;
  double result = 1.0;
  *(_OWORD *)(v3 + 64) = xmmword_2142181C0;
  *(_OWORD *)(v3 + 80) = xmmword_2142181D0;
  *(void *)(v3 + 96) = 0;
  *(void *)(v3 + 104) = 0;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::CrossFadeStyle>(RB::Heap *this)
{
  unint64_t v2 = *((void *)this + 3);
  unint64_t v3 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 72 > v2) {
    unint64_t v3 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  }
  else {
    *((void *)this + 2) = v3 + 72;
  }
  *(void *)(v3 + 48) = 0;
  *(void *)(v3 + 56) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(void *)unint64_t v3 = &unk_26C4EC1A0;
  double result = 0.0078125;
  *(void *)(v3 + 64) = 0x3F80000000000000;
  return result;
}

__n128 RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>,RB::GeometryStyle::Projection const&>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v5 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 96 > v4) {
    unint64_t v5 = RB::Heap::alloc_slow((size_t *)this, 0x60uLL, 7);
  }
  else {
    *((void *)this + 2) = v5 + 96;
  }
  *(void *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(void *)unint64_t v5 = &unk_26C4E8578;
  __n128 result = *(__n128 *)a2;
  long long v7 = *(_OWORD *)(a2 + 16);
  *(_DWORD *)(v5 + 88) = *(_DWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 72) = v7;
  *(__n128 *)(v5 + 56) = result;
  return result;
}

int32x2_t *RB::render_masks_coverage(int32x2_t *result, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5, char a6, float a7)
{
  if (a5)
  {
    _S8 = a7;
    char v13 = result;
    if (result[17].i32[0] == 2) {
      uint64_t v14 = 131082;
    }
    else {
      uint64_t v14 = 10;
    }
    float32x2_t v25 = (float32x2_t)result[14];
    __int32 v15 = result[15].i32[0];
    result[24].i32[1] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)result, *(RB::Buffer **)a4);
    v13[25] = vmovn_s64(*(int64x2_t *)(a4 + 8));
    __int32 v16 = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v13, a5);
    v13[26].i32[1] = 0;
    v13[27].i32[0] = 0;
    v13[26].i32[0] = v16;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v13, (RB::Device *)0x20, 4uLL, 0, &v26);
    unint64_t v17 = v26;
    if (v26)
    {
      float32x2_t v18 = vneg_f32(v25);
      v18.i32[0] = 0;
      __asm { FCVT            H2, S8 }
      uint64_t v24 = *((void *)v26 + 7) + v27.i64[0];
      *(void *)uint64_t v24 = v25.u32[0];
      *(float32x2_t *)(v24 + 8) = v18;
      *(void *)(v24 + 16) = 0x3F800000BF800000;
      *(_DWORD *)(v24 + 24) = v15;
      *(_WORD *)(v24 + 28) = _H2;
    }
    else
    {
      float v26 = 0;
      int64x2_t v27 = 0uLL;
    }
    v13[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v13, v17);
    *(int32x2_t *)((char *)v13 + 188) = vmovn_s64(v27);
    __n128 result = RB::RenderPass::draw_indexed_primitives(v13, (const char *)(v14 | ((unint64_t)(a6 & 0x3F) << 32)), 4, ***(void ***)v13 + 80, 0, a3, *a2, a2[1]);
    *(int32x2_t *)((char *)&v13[24] + 4) = 0;
    *(int32x2_t *)((char *)&v13[25] + 4) = 0;
    *(int32x2_t *)((char *)&v13[26] + 4) = 0;
  }
  return result;
}

void sub_2141D8A44(_Unwind_Exception *a1)
{
  *(void *)(v1 + 200) = 0;
  *(_DWORD *)(v1 + 196) = 0;
  _Unwind_Resume(a1);
}

int32x2_t *RB::render_masks(int32x2_t *result, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5, uint64_t a6, int a7, char a8)
{
  if (a5)
  {
    char v13 = result;
    if (result[17].i32[0] == 2) {
      uint64_t v14 = 131083;
    }
    else {
      uint64_t v14 = 11;
    }
    if (a7) {
      uint64_t v15 = 0x10000;
    }
    else {
      uint64_t v15 = 0;
    }
    double v22 = *(double *)&result[14];
    __int32 v16 = result[15].i32[0];
    float16x4_t v17 = RB::Fill::Color::prepare(a6, result[15].u8[4], v22);
    v13[24].i32[1] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v13, *(RB::Buffer **)a4);
    v13[25] = vmovn_s64(*(int64x2_t *)(a4 + 8));
    __int32 v18 = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v13, a5);
    v13[26].i32[1] = 0;
    v13[27].i32[0] = 0;
    v13[26].i32[0] = v18;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v13, (RB::Device *)0x24, 4uLL, 0, &v23);
    uint64_t v19 = v23;
    if (v23)
    {
      float32x2_t v20 = vneg_f32(*(float32x2_t *)&v22);
      v20.i32[0] = 0;
      uint64_t v21 = *((void *)v23 + 7) + v24.i64[0];
      *(void *)uint64_t v21 = LODWORD(v22);
      *(float32x2_t *)(v21 + 8) = v20;
      *(void *)(v21 + 16) = 0x3F800000BF800000;
      *(_DWORD *)(v21 + 24) = v16;
      *(float16x4_t *)(v21 + 28) = v17;
    }
    else
    {
      unint64_t v23 = 0;
      int64x2_t v24 = 0uLL;
    }
    v13[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v13, v19);
    *(int32x2_t *)((char *)v13 + 188) = vmovn_s64(v24);
    __n128 result = RB::RenderPass::draw_indexed_primitives(v13, (const char *)(v15 | v14 | ((unint64_t)(a8 & 0x3F) << 32)), 4, ***(void ***)v13 + 80, 0, a3, *a2, a2[1]);
    *(int32x2_t *)((char *)&v13[24] + 4) = 0;
    *(int32x2_t *)((char *)&v13[25] + 4) = 0;
    *(int32x2_t *)((char *)&v13[26] + 4) = 0;
  }
  return result;
}

void sub_2141D8C00(_Unwind_Exception *a1)
{
  *(void *)(v1 + 200) = 0;
  *(_DWORD *)(v1 + 196) = 0;
  _Unwind_Resume(a1);
}

int32x2_t *RB::render_masks(int32x2_t *result, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5, float64x2_t *a6, float32x2_t *a7, int a8, double a9, char a10)
{
  if (a5)
  {
    float v10 = *(float *)&a9;
    uint64_t v17 = (uint64_t)result;
    RB::Fill::Gradient::set_gradient(a7, (uint64_t)v31 + 12, (uint64_t)result, a6, a9);
    if (*(_DWORD *)(v17 + 136) == 2) {
      unsigned int v18 = 131084;
    }
    else {
      unsigned int v18 = 12;
    }
    int8x8_t v29 = (int8x8_t)v18;
    RB::Fill::Gradient::set_fill_state((uint64_t)a7, (int *)&v29, v17, v10);
    if (a8) {
      int v19 = 0x10000;
    }
    else {
      int v19 = 0;
    }
    float32x2_t v20 = *(float32x2_t *)(v17 + 112);
    float32x2_t v21 = vneg_f32(v20);
    v21.i32[0] = 0;
    int8x8_t v29 = vorr_s8(vand_s8(v29, (int8x8_t)0xFFFFFFC0FFFEFFFFLL), (int8x8_t)__PAIR64__(a10 & 0x3F, v19));
    *(void *)&long long v30 = v20.u32[0];
    *((float32x2_t *)&v30 + 1) = v21;
    *(void *)&v31[0] = 0x3F800000BF800000;
    DWORD2(v31[0]) = *(_DWORD *)(v17 + 120);
    *(_DWORD *)(v17 + 196) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v17, *(RB::Buffer **)a4);
    *(int32x2_t *)(v17 + 200) = vmovn_s64(*(int64x2_t *)(a4 + 8));
    int v22 = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v17, a5);
    *(_DWORD *)(v17 + 212) = 0;
    *(_DWORD *)(v17 + 216) = 0;
    *(_DWORD *)(v17 + 208) = v22;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v17, (RB::Device *)0x54, 4uLL, 0, &v33);
    unint64_t v23 = v33;
    if (v33)
    {
      uint64_t v24 = *((void *)v33 + 7) + v34.i64[0];
      long long v25 = v30;
      *(_OWORD *)(v24 + 16) = v31[0];
      long long v27 = v31[2];
      long long v26 = v31[3];
      long long v28 = v31[1];
      *(_DWORD *)(v24 + 80) = v32;
      *(_OWORD *)(v24 + 48) = v27;
      *(_OWORD *)(v24 + 64) = v26;
      *(_OWORD *)(v24 + 32) = v28;
      *(_OWORD *)uint64_t v24 = v25;
    }
    else
    {
      unint64_t v33 = 0;
      int64x2_t v34 = 0uLL;
    }
    *(_DWORD *)(v17 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v17, v23);
    *(int32x2_t *)(v17 + 188) = vmovn_s64(v34);
    __n128 result = RB::RenderPass::draw_indexed_primitives((int32x2_t *)v17, *(const char **)&v29, 4, ***(void ***)v17 + 80, 0, a3, *a2, a2[1]);
    *(_DWORD *)(v17 + 228) = 0;
    *(_OWORD *)(v17 + 196) = 0u;
    *(_OWORD *)(v17 + 212) = 0u;
  }
  return result;
}

void sub_2141D8E10(_Unwind_Exception *a1)
{
  *(void *)(v1 + 200) = 0;
  *(_DWORD *)(v1 + 196) = 0;
  _Unwind_Resume(a1);
}

int32x2_t *RB::render_masks(int32x2_t *result, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5, long long *a6, uint64_t a7, int a8, char a9)
{
  if (a5)
  {
    uint64_t v15 = result;
    if (result[17].i32[0] == 2) {
      unsigned int v16 = 131085;
    }
    else {
      unsigned int v16 = 13;
    }
    int8x8_t v27 = (int8x8_t)v16;
    RB::RenderState::set_image((int *)&v27, (uint64_t)a6 + 28, result[15].u8[4]);
    if (a8) {
      int v17 = 0x10000;
    }
    else {
      int v17 = 0;
    }
    int8x8_t v27 = vorr_s8(vand_s8(v27, (int8x8_t)0xFFFFFFC0FFFEFFFFLL), (int8x8_t)__PAIR64__(a9 & 0x3F, v17));
    *(void *)a6 = *(void *)&v15[14];
    LODWORD(v18) = 0;
    *((float *)&v18 + 1) = -*(float *)&v15[14].i32[1];
    *((void *)a6 + 1) = v18;
    *((void *)a6 + 2) = 0x3F800000BF800000;
    *((_DWORD *)a6 + 6) = v15[15].i32[0];
    v15[24].i32[1] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v15, *(RB::Buffer **)a4);
    v15[25] = vmovn_s64(*(int64x2_t *)(a4 + 8));
    __int32 v19 = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v15, a5);
    v15[26].i32[1] = 0;
    v15[27].i32[0] = 0;
    v15[26].i32[0] = v19;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v15, (RB::Device *)0x70, 4uLL, 0, &v28);
    float32x2_t v20 = v28;
    if (v28)
    {
      float32x2_t v21 = (_OWORD *)(*((void *)v28 + 7) + v29.i64[0]);
      long long v22 = a6[2];
      long long v23 = *a6;
      v21[1] = a6[1];
      void v21[2] = v22;
      long long v24 = a6[6];
      long long v26 = a6[3];
      long long v25 = a6[4];
      v21[5] = a6[5];
      v21[6] = v24;
      float64x2_t v21[3] = v26;
      _OWORD v21[4] = v25;
      _OWORD *v21 = v23;
    }
    else
    {
      long long v28 = 0;
      int64x2_t v29 = 0uLL;
    }
    v15[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v15, v20);
    *(int32x2_t *)((char *)v15 + 188) = vmovn_s64(v29);
    __n128 result = RB::RenderPass::draw_indexed_primitives(v15, *(const char **)&v27, 4, ***(void ***)v15 + 80, 0, a3, *a2, a2[1]);
    *(int32x2_t *)((char *)&v15[24] + 4) = 0;
    *(int32x2_t *)((char *)&v15[25] + 4) = 0;
    *(int32x2_t *)((char *)&v15[26] + 4) = 0;
  }
  return result;
}

void sub_2141D8FFC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 200) = 0;
  *(_DWORD *)(v1 + 196) = 0;
  _Unwind_Resume(a1);
}

void sub_2141D90EC(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

char *RB::vector<std::pair<RB::objc_ptr<RBSymbolAnimator *>,RB::objc_ptr<objc_object  {objcproto24RBSymbolAnimatorObserver}*>>,4ul,unsigned long>::~vector(char *a1)
{
  unint64_t v2 = (char *)*((void *)a1 + 8);
  if (v2) {
    unint64_t v3 = v2;
  }
  else {
    unint64_t v3 = a1;
  }
  if (*((void *)a1 + 9))
  {
    unint64_t v4 = 0;
    unint64_t v5 = (id *)(v3 + 8);
    do
    {

      ++v4;
      v5 += 2;
    }
    while (v4 < *((void *)a1 + 9));
    unint64_t v2 = (char *)*((void *)a1 + 8);
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

void sub_2141DA05C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  RB::Symbol::Presentation::~Presentation((RB::Symbol::Presentation *)va);
  _Unwind_Resume(a1);
}

void sub_2141DA114(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double RBSymbolUpdateBoundingRect(RB::Symbol::Presentation *a1, double a2, double a3, double a4, int32x4_t a5)
{
  double v5 = RB::Symbol::Presentation::bounding_rect(a1, a2, a3, a4, a5);
  v6.i32[0] = 0;
  uint32x2_t v8 = (uint32x2_t)vcgtz_f32(v7);
  *(uint32x2_t *)v9.i8 = vpmin_u32(v8, v8);
  *(void *)&double result = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v6, v9), 0), (int8x16_t)vcvtq_f64_f32(*(float32x2_t *)&v5), *MEMORY[0x263F001A0]).u64[0];
  return result;
}

double RBSymbolUpdateMaxVelocity(uint64_t a1)
{
  return *(float *)(a1 + 920);
}

float RBSymbolUpdateLayerColor(void *a1)
{
  unsigned int v1 = *(_DWORD *)(*a1 + 848) + ~*((_DWORD *)a1 + 2);
  uint64_t v2 = *(void *)(*a1 + 840);
  if (!v2) {
    uint64_t v2 = *a1 + 8;
  }
  uint64_t v3 = a1[2];
  unint64_t v4 = *(void **)(v2 + 416 * v1 + 400);
  if (v4) {
    LODWORD(v3) = *(_DWORD *)(*v4 + 8 * a1[2]);
  }
  uint64_t v5 = v2 + 416 * v1;
  uint64_t v6 = v5 + 16;
  uint64_t v7 = *(void *)(v5 + 376);
  if (!v7) {
    uint64_t v7 = v6;
  }
  return *(float *)(v7 + 120 * v3 + 8);
}

float RBSymbolUpdateLayerErasingOpacity(_DWORD *a1)
{
  uint64_t v1 = *(void *)a1 + 8;
  unsigned int v2 = *(_DWORD *)(*(void *)a1 + 848) + ~a1[2];
  if (*(void *)(*(void *)a1 + 840)) {
    uint64_t v1 = *(void *)(*(void *)a1 + 840);
  }
  uint64_t v3 = (_DWORD *)*((void *)a1 + 2);
  unint64_t v4 = *(void **)(v1 + 416 * v2 + 400);
  if (!v4) {
    goto LABEL_6;
  }
  uint64_t v3 = (_DWORD *)(*v4 + 8 * *((void *)a1 + 2));
  uint64_t v5 = v3[1];
  float result = 0.0;
  if (!v5) {
    return result;
  }
  LODWORD(v3) = *v3;
  if (v5 != 1)
  {
    uint64_t v12 = v1 + 416 * v2;
    uint64_t v13 = v12 + 16;
    uint64_t v14 = *(void *)(v12 + 376);
    if (!v14) {
      uint64_t v14 = v13;
    }
    while (1)
    {
      unsigned int v15 = v3;
      uint64_t v16 = *(void *)(v14 + 120 * v3);
      if ((*(unsigned char *)(v16 + 86) & 0x40) != 0)
      {
        float v17 = *(float *)(v16 + 72);
        uint64_t v18 = v14 + 120 * v15;
        float v19 = v17 <= 0.0 ? *(float *)(v18 + 32) * *(float *)(v18 + 28) : *(float *)(v18 + 32);
        if (v19 > 0.0) {
          break;
        }
      }
      LODWORD(v3) = v15 + 1;
      if (!--v5) {
        return result;
      }
    }
    return 1.0;
  }
  else
  {
LABEL_6:
    uint64_t v7 = v1 + 416 * v2;
    uint64_t v8 = v7 + 16;
    uint64_t v9 = *(void *)(v7 + 376);
    if (!v9) {
      uint64_t v9 = v8;
    }
    uint64_t v10 = *(void *)(v9 + 120 * v3);
    float result = 0.0;
    if ((*(unsigned char *)(v10 + 86) & 0x40) != 0)
    {
      uint64_t v11 = v9 + 120 * v3;
      if (*(float *)(v10 + 72) <= 0.0) {
        return *(float *)(v11 + 32) * *(float *)(v11 + 28);
      }
      else {
        return *(float *)(v11 + 32);
      }
    }
  }
  return result;
}

uint64_t RBSymbolUpdateLayerDefaultColor(void *a1)
{
  unsigned int v1 = *(_DWORD *)(*a1 + 848) + ~*((_DWORD *)a1 + 2);
  uint64_t v2 = *(void *)(*a1 + 840);
  if (!v2) {
    uint64_t v2 = *a1 + 8;
  }
  uint64_t v3 = a1[2];
  unint64_t v4 = *(void **)(v2 + 416 * v1 + 400);
  if (v4) {
    LODWORD(v3) = *(_DWORD *)(*v4 + 8 * a1[2]);
  }
  uint64_t v5 = v2 + 416 * v1;
  uint64_t v6 = v5 + 16;
  uint64_t v7 = *(void *)(v5 + 376);
  if (!v7) {
    uint64_t v7 = v6;
  }
  uint64_t v8 = *(void *)(v7 + 120 * v3);
  if ((*(_DWORD *)(v8 + 84) & 0xF00) == 0x900) {
    return *(void *)(v8 + 16);
  }
  else {
    return 0;
  }
}

float RBSymbolUpdateLayerModelColor(void *a1)
{
  unsigned int v1 = *(_DWORD *)(*a1 + 848) + ~*((_DWORD *)a1 + 2);
  uint64_t v2 = *(void *)(*a1 + 840);
  if (!v2) {
    uint64_t v2 = *a1 + 8;
  }
  uint64_t v3 = a1[2];
  unint64_t v4 = *(void **)(v2 + 416 * v1 + 400);
  if (v4) {
    LODWORD(v3) = *(_DWORD *)(*v4 + 8 * a1[2]);
  }
  uint64_t v5 = v2 + 416 * v1;
  uint64_t v6 = v5 + 16;
  uint64_t v7 = *(void *)(v5 + 376);
  if (!v7) {
    uint64_t v7 = v6;
  }
  return *(float *)(v7 + 120 * v3 + 8);
}

uint64_t RBSymbolUpdateLayerClip(uint64_t a1, __n128 *a2, int a3, char a4, float a5)
{
  uint64_t v7 = *(RB::Symbol::Presentation **)a1;
  uint64_t v8 = *(void *)a1 + 8;
  if (*(void *)(*(void *)a1 + 840)) {
    uint64_t v8 = *(void *)(*(void *)a1 + 840);
  }
  uint64_t v47 = v8;
  unsigned int v48 = *(_DWORD *)(*(void *)a1 + 848) + ~*(_DWORD *)(a1 + 8);
  uint64_t v9 = v8 + 416 * v48;
  uint64_t v10 = *(void **)(v9 + 400);
  if (v10)
  {
    uint64_t v11 = (_DWORD *)(*v10 + 8 * *(void *)(a1 + 16));
    LODWORD(v52) = *v11;
    unsigned int v49 = v11[1];
    BOOL v51 = v49 > 1;
  }
  else
  {
    uint64_t v52 = *(void *)(a1 + 16);
    BOOL v51 = 0;
    unsigned int v49 = 1;
  }
  unint64_t v57 = a2[10].n128_u64[1];
  if (a4)
  {
    unint64_t v12 = v52 + v49;
    uint64_t v13 = v8 + 416 * v48;
    unsigned int v14 = *(_DWORD *)(v13 + 384);
    if (v12 < v14)
    {
      uint64_t v46 = (unsigned int *)(v13 + 384);
      uint64_t v15 = v47 + 416 * v48;
      uint64_t v16 = v15 + 16;
      float v17 = (uint64_t *)(v15 + 376);
      uint64_t v18 = 120 * (v52 + v49);
      do
      {
        if (*v17) {
          uint64_t v19 = *v17;
        }
        else {
          uint64_t v19 = v16;
        }
        float32x2_t v20 = (float32x2_t *)(v19 + v18);
        uint64_t v21 = *(void *)(v19 + v18);
        if ((*(unsigned char *)(v21 + 86) & 0x40) != 0)
        {
          float v22 = *(float *)(v21 + 72);
          uint64_t v23 = v19 + v18;
          float v24 = v22 <= 0.0 ? *(float *)(v23 + 32) * *(float *)(v23 + 28) : *(float *)(v23 + 32);
          if (v24 > 0.0)
          {
            RB::Symbol::Presentation::Layer::set_animation_layer((RB::Symbol::Presentation::Layer *)(v19 + v18), (_RBDrawingState *)a2, (RB::Symbol::Model **)v9);
            uint64_t v25 = v19 + v18;
            uint64_t v26 = *(void *)(v19 + v18);
            v27.f64[0] = RB::Symbol::Presentation::Layer::transform(v20, (uint64_t)v7);
            float64x2_t v54 = v27;
            long long v55 = v28;
            long long v56 = v29;
            LODWORD(v28) = 0;
            DWORD1(v28) = *(_DWORD *)(v25 + 52);
            RB::Symbol::Glyph::Layer::clip(v26, a2, 1, &v54, v7, v24, *(float32x2_t *)&v28);
            unsigned int v14 = *v46;
          }
        }
        ++v12;
        v18 += 120;
      }
      while (v12 < v14);
    }
  }
  long long v30 = (_RBDrawingState *)a2;
  if (v49 >= 2) {
    long long v30 = (_RBDrawingState *)RBDrawingStateBeginLayer((RB::DisplayList::State *)a2, 0);
  }
  if (v52 < v52 + v49)
  {
    uint64_t v31 = v47 + 416 * v48;
    uint64_t v32 = v31 + 16;
    unint64_t v33 = (uint64_t *)(v31 + 376);
    uint64_t v34 = 120 * v52;
    unsigned int v35 = v49;
    do
    {
      uint64_t v36 = *v33;
      if (!*v33) {
        uint64_t v36 = v32;
      }
      double v37 = (float32x2_t *)(v36 + v34);
      float v38 = a5;
      if (v51)
      {
        float v39 = 0.0;
        if ((*(unsigned char *)(*(void *)v37 + 86) & 0x40) != 0)
        {
          uint64_t v40 = v36 + v34;
          if (*(float *)(*(void *)v37 + 72) <= 0.0) {
            float v39 = *(float *)(v40 + 32) * *(float *)(v40 + 28);
          }
          else {
            float v39 = *(float *)(v40 + 32);
          }
        }
        float v38 = v39 * a5;
      }
      v41.f64[0] = RB::Symbol::Presentation::Layer::transform(v37, (uint64_t)v7);
      float64x2_t v54 = v41;
      long long v55 = v42;
      long long v56 = v43;
      LODWORD(v41.f64[0]) = 0;
      HIDWORD(v41.f64[0]) = v37[6].i32[1];
      float32x2_t v53 = *(float32x2_t *)&v41.f64[0];
      RB::Symbol::Presentation::Layer::set_animation_layer((RB::Symbol::Presentation::Layer *)v37, v30, (RB::Symbol::Model **)v9);
      uint64_t v44 = (uint64_t)*v37;
      if (v30 == (_RBDrawingState *)a2) {
        RB::Symbol::Glyph::Layer::clip(v44, a2, a3, &v54, v7, v38, v53);
      }
      else {
        RB::Symbol::Glyph::Layer::draw(v44, (__n128 *)v30, 0, &v54, v7, 1.0, 1.0, 1.0, 1.0, v38, v53);
      }
      v34 += 120;
      --v35;
    }
    while (v35);
  }
  if (v49 > 1) {
    RBDrawingStateClipLayer(a2, (RB::DisplayList::State *)v30, a3, 1.0);
  }
  return RB::DisplayList::State::set_animation_layer((uint64_t)a2, &v57);
}

void std::default_delete<RB::Symbol::Animation::Timing>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void **)(a2 + 24);
    if (v2) {
      free(v2);
    }
    JUMPOUT(0x21669AC10);
  }
}

void *RB::vector<objc_object  {objcproto24RBSymbolAnimatorObserver}*,2ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 7) + (*((_DWORD *)__dst + 7) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 7) + (*((_DWORD *)__dst + 7) >> 1);
  }
  float result = RB::details::realloc_vector<unsigned int,8ul>(*((void **)__dst + 2), __dst, 2u, (_DWORD *)__dst + 7, v3);
  *((void *)__dst + 2) = result;
  return result;
}

void *RB::vector<std::pair<RB::objc_ptr<RBSymbolAnimator *>,RB::objc_ptr<objc_object  {objcproto24RBSymbolAnimatorObserver}*>>,4ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 10) + (*((void *)__dst + 10) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 10) + (*((void *)__dst + 10) >> 1);
  }
  float result = RB::details::realloc_vector<unsigned long,16ul>(*((void **)__dst + 8), __dst, 4uLL, (size_t *)__dst + 10, v3);
  *((void *)__dst + 8) = result;
  return result;
}

void *std::pair<RB::objc_ptr<RBSymbolAnimator *>,RB::objc_ptr<objc_object  {objcproto24RBSymbolAnimatorObserver}*>>::pair[abi:nn180100](void *a1, id *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  return a1;
}

void sub_2141DA960(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

int *RB::ColorStyle::Base::encode(int *this, RB::Encoder *a2)
{
  size_t v3 = this;
  int v4 = *this;
  if ((*this & 1) == 0)
  {
    if ((v4 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    RB::ProtobufEncoder::encode_varint(a2, 0x48uLL);
    this = (int *)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    if ((*v3 & 4) == 0) {
      return this;
    }
    goto LABEL_7;
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x40uLL);
  this = (int *)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  int v4 = *v3;
  if ((*v3 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v4 & 4) == 0) {
    return this;
  }
LABEL_7:
  RB::ProtobufEncoder::encode_varint(a2, 0x50uLL);
  return (int *)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
}

uint64_t RB::ColorStyle::Base::decode_field(_DWORD *a1, RB::ProtobufDecoder *this, unint64_t a3)
{
  unint64_t v4 = a3 >> 3;
  if ((a3 >> 3) == 10)
  {
    uint64_t result = RB::ProtobufDecoder::BOOL_field(this, a3);
    BOOL v7 = result == 0;
    int v8 = 4;
LABEL_7:
    if (v7) {
      int v8 = 0;
    }
    int v6 = *a1 | v8;
    goto LABEL_11;
  }
  if (v4 == 9)
  {
    uint64_t result = RB::ProtobufDecoder::BOOL_field(this, a3);
    BOOL v7 = result == 0;
    int v8 = 2;
    goto LABEL_7;
  }
  if (v4 == 8)
  {
    uint64_t result = RB::ProtobufDecoder::BOOL_field(this, a3);
    int v6 = *a1 | result;
LABEL_11:
    *a1 = v6;
    return result;
  }
  return (uint64_t)RB::ProtobufDecoder::skip_field(this, a3);
}

std::string *RB::ColorStyle::Base::print(std::string *this, std::string *a2)
{
  size_t v3 = this;
  if ((uint64_t)this->__r_.__value_.__l.__data_)
  {
    unint64_t v4 = "linear";
  }
  else
  {
    if (((uint64_t)this->__r_.__value_.__l.__data_ & 2) == 0) {
      goto LABEL_6;
    }
    unint64_t v4 = "non-linear";
  }
  this = RB::SexpString::print(a2, 0, v4);
LABEL_6:
  if ((v3->__r_.__value_.__s.__data_[0] & 4) != 0)
  {
    return RB::SexpString::print(a2, 0, "premultiplied");
  }
  return this;
}

double RB::ColorStyle::ColorMultiply::set_color_matrix(RB::ColorStyle::ColorMultiply *this, RB::ColorMatrix *a2, uint16x4_t a3, int8x8_t a4)
{
  unsigned int v5 = *(_DWORD *)this;
  if (*((unsigned char *)this + 13)) {
    unsigned __int8 v6 = *((unsigned char *)this + 12);
  }
  else {
    unsigned __int8 v6 = 1;
  }
  BOOL v7 = (char *)this + 4;
  unsigned int v8 = ((v5 & 2) << 7) | (v5 >> 1) & 1;
  if (v5) {
    unsigned int v8 = 256;
  }
  if (v8 >= 0x100) {
    unsigned __int8 v6 = v8;
  }
  *(float16x4_t *)&double v9 = RB::Fill::Color::prepare((uint64_t)v7, v6, (v5 >> 2) & 1, a3, a4);
  return RB::ColorMatrix::set_color(a2, v9);
}

void RB::ColorStyle::ColorMultiply::mix(RB::ColorStyle::ColorMultiply *this, const RB::ColorStyle::ColorMultiply *a2, float a3)
{
  if (a2)
  {
    uint64_t v3 = *(void *)((char *)a2 + 4);
    __int16 v4 = *((_WORD *)a2 + 6);
  }
  else
  {
    uint64_t v3 = 0x3C003C003C003C00;
    __int16 v4 = 0;
  }
  RB::Fill::Color::mix((uint64_t)this + 4, (uint64_t)&v3, 0, a3);
}

void *RB::ColorStyle::ColorMultiply::encode(RB::ColorStyle::ColorMultiply *this, RB::Encoder *a2)
{
  RB::ColorStyle::Base::encode((int *)this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Fill::Color::encode((RB::ColorStyle::ColorMultiply *)((char *)this + 4), a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

unint64_t RB::ColorStyle::ColorMultiply::decode(RB::ColorStyle::ColorMultiply *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      if ((v5 & 0x7FFFFFFF8) == 8)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          RB::Fill::Color::decode((uint64_t)this + 4, a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
        }
      }
      else
      {
        RB::ColorStyle::Base::decode_field(this, a2, v5);
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::ColorStyle::ColorMultiply::print(std::string *this, std::string *a2)
{
  RB::SexpString::push(a2, "color-multiply");
  RB::ColorStyle::Base::print(this, a2);
  RB::Fill::Color::print((RB::Fill::Color *)((char *)this->__r_.__value_.__r.__words + 4), a2);
  RB::SexpString::pop(a2);
}

int8x8_t RB::ColorStyle::AlphaMultiply::set_color_matrix(RB::ColorStyle::AlphaMultiply *this, int8x8_t *a2, uint16x4_t a3, int8x8_t a4)
{
  unsigned int v5 = *(_DWORD *)this;
  if (*((unsigned char *)this + 13)) {
    unsigned __int8 v6 = *((unsigned char *)this + 12);
  }
  else {
    unsigned __int8 v6 = 1;
  }
  BOOL v7 = (char *)this + 4;
  unsigned int v8 = ((v5 & 2) << 7) | (v5 >> 1) & 1;
  if (v5) {
    unsigned int v8 = 256;
  }
  if (v8 >= 0x100) {
    unsigned __int8 v6 = v8;
  }
  int v9 = (v5 >> 2) & 1;
  float16x4_t v10 = RB::Fill::Color::prepare((uint64_t)v7, v6, v9, a3, a4);
  return RB::ColorMatrix::set_alpha_multiply(a2, v9, (int8x8_t)v10);
}

void RB::ColorStyle::AlphaMultiply::mix(RB::ColorStyle::AlphaMultiply *this, const RB::ColorStyle::AlphaMultiply *a2, float a3)
{
  if (a2)
  {
    uint64_t v3 = *(void *)((char *)a2 + 4);
    __int16 v4 = *((_WORD *)a2 + 6);
    RB::Fill::Color::mix((uint64_t)this + 4, (uint64_t)&v3, 0, a3);
  }
}

uint64_t RB::ColorStyle::AlphaMultiply::matches(RB::ColorStyle::AlphaMultiply *this, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::DisplayList::Predicate::matches_color(a2, (RB::ColorStyle::AlphaMultiply *)((char *)this + 4), a3);
}

void RB::ColorStyle::AlphaMultiply::print(std::string *this, std::string *a2)
{
  RB::SexpString::push(a2, "alpha-multiply");
  RB::ColorStyle::Base::print(this, a2);
  RB::Fill::Color::print((RB::Fill::Color *)((char *)this->__r_.__value_.__r.__words + 4), a2);
  RB::SexpString::pop(a2);
}

float RB::ColorStyle::HueRotation::mix(uint64_t a1, uint64_t a2, float a3)
{
  if (a2) {
    float v3 = *(float *)(a2 + 4);
  }
  else {
    float v3 = 0.0;
  }
  float result = *(float *)(a1 + 4) + (float)((float)(v3 - *(float *)(a1 + 4)) * a3);
  *(float *)(a1 + 4) = result;
  return result;
}

int *RB::ColorStyle::HueRotation::encode(RB::ColorStyle::HueRotation *this, RB::Encoder *a2)
{
  float result = RB::ColorStyle::Base::encode((int *)this, a2);
  int v5 = *((int *)this + 1);
  if (*(float *)&v5 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xDuLL);
    return (int *)RB::ProtobufEncoder::encode_fixed32(a2, v5);
  }
  return result;
}

uint64_t RB::ColorStyle::HueRotation::decode(uint64_t a1, RB::ProtobufDecoder *this)
{
  uint64_t result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    uint64_t v5 = result;
    do
    {
      if ((v5 & 0x7FFFFFFF8) == 8) {
        *(float *)(a1 + 4) = RB::ProtobufDecoder::float_field(this, v5);
      }
      else {
        RB::ColorStyle::Base::decode_field((_DWORD *)a1, this, v5);
      }
      uint64_t result = RB::ProtobufDecoder::next_field(this);
      uint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::ColorStyle::HueRotation::print(std::string *this, std::string *a2)
{
  RB::SexpString::push(a2, "hue-rotation");
  RB::ColorStyle::Base::print(this, a2);
  RB::SexpString::printf(a2, 0, "(angle %g deg)", *((float *)this->__r_.__value_.__r.__words + 1) * 57.2957795);
  RB::SexpString::pop(a2);
}

float RB::ColorStyle::Saturation::mix(uint64_t a1, uint64_t a2, float a3)
{
  if (a2) {
    float v3 = *(float *)(a2 + 4);
  }
  else {
    float v3 = 1.0;
  }
  float result = *(float *)(a1 + 4) + (float)((float)(v3 - *(float *)(a1 + 4)) * a3);
  *(float *)(a1 + 4) = result;
  return result;
}

int *RB::ColorStyle::Saturation::encode(RB::ColorStyle::Saturation *this, RB::Encoder *a2)
{
  float result = RB::ColorStyle::Base::encode((int *)this, a2);
  int v5 = *((int *)this + 1);
  if (*(float *)&v5 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xDuLL);
    return (int *)RB::ProtobufEncoder::encode_fixed32(a2, v5);
  }
  return result;
}

void RB::ColorStyle::Saturation::print(std::string *this, std::string *a2)
{
  RB::SexpString::push(a2, "saturation");
  RB::ColorStyle::Base::print(this, a2);
  RB::SexpString::printf(a2, 0, "(amount %g)", *((float *)this->__r_.__value_.__r.__words + 1));
  RB::SexpString::pop(a2);
}

void RB::ColorStyle::Brightness::print(std::string *this, std::string *a2)
{
  RB::SexpString::push(a2, "brightness");
  RB::ColorStyle::Base::print(this, a2);
  RB::SexpString::printf(a2, 0, "(amount %g)", *((float *)this->__r_.__value_.__r.__words + 1));
  RB::SexpString::pop(a2);
}

void RB::ColorStyle::Contrast::print(std::string *this, std::string *a2)
{
  RB::SexpString::push(a2, "contrast");
  RB::ColorStyle::Base::print(this, a2);
  RB::SexpString::printf(a2, 0, "(amount %g)", *((float *)this->__r_.__value_.__r.__words + 1));
  RB::SexpString::pop(a2);
}

unint64_t RB::ColorStyle::LuminanceToAlpha::decode(_DWORD *a1, RB::ProtobufDecoder *this)
{
  unint64_t result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      RB::ColorStyle::Base::decode_field(a1, this, v5);
      unint64_t result = RB::ProtobufDecoder::next_field(this);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::ColorStyle::LuminanceToAlpha::print(std::string *this, std::string *a2)
{
  RB::SexpString::push(a2, "luminance-to-alpha");
  RB::ColorStyle::Base::print(this, a2);
  RB::SexpString::pop(a2);
}

double RB::ColorStyle::ColorMonochrome::set_color_matrix(RB::ColorStyle::ColorMonochrome *this, RB::ColorMatrix *a2, uint16x4_t a3, int8x8_t a4)
{
  unsigned int v6 = *(_DWORD *)this;
  if (*((unsigned char *)this + 13)) {
    unsigned __int8 v7 = *((unsigned char *)this + 12);
  }
  else {
    unsigned __int8 v7 = 1;
  }
  unsigned int v8 = (char *)this + 4;
  unsigned int v9 = ((v6 & 2) << 7) | (v6 >> 1) & 1;
  if (v6) {
    unsigned int v9 = 256;
  }
  if (v9 >= 0x100) {
    unsigned __int8 v7 = v9;
  }
  int v10 = *((_DWORD *)this + 4);
  *(float16x4_t *)&double v18 = RB::Fill::Color::prepare((uint64_t)v8, v7, (v6 >> 2) & 1, a3, a4);
  int8x8_t v16 = *(int8x8_t *)&v18;
  float v17 = *((float *)this + 5);
  LODWORD(v18) = v10;
  *(void *)&double result = RB::ColorMatrix::set_color_monochrome(a2, v18, v16, v17, v11, v12, v13, v14, v15);
  return result;
}

float32_t RB::ColorStyle::ColorMonochrome::mix(float32x2_t *this, float32x2_t *a2, float a3)
{
  if (a2)
  {
    RB::Fill::Color::mix((uint64_t)this + 4, (uint64_t)a2 + 4, 0, a3);
    float32x2_t v5 = vmla_n_f32(this[2], vsub_f32(a2[2], this[2]), a3);
    this[2] = v5;
  }
  else
  {
    v5.f32[0] = this[2].f32[0] - (float)(this[2].f32[0] * a3);
    this[2].i32[0] = v5.i32[0];
  }
  return v5.f32[0];
}

void *RB::ColorStyle::ColorMonochrome::encode(RB::ColorStyle::ColorMonochrome *this, RB::Encoder *a2)
{
  double result = RB::ColorStyle::Base::encode((int *)this, a2);
  short float v5 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0));
  if (*((short float *)this + 2) != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))
    || *((short float *)this + 3) != v5
    || *((short float *)this + 4) != v5
    || *((short float *)this + 5) != v5)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Fill::Color::encode((RB::ColorStyle::ColorMonochrome *)((char *)this + 4), a2);
    double result = RB::ProtobufEncoder::end_length_delimited(a2);
  }
  int v6 = *((int *)this + 4);
  if (*(float *)&v6 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x15uLL);
    double result = RB::ProtobufEncoder::encode_fixed32(a2, v6);
  }
  int v7 = *((int *)this + 5);
  if (*(float *)&v7 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x1DuLL);
    return RB::ProtobufEncoder::encode_fixed32(a2, v7);
  }
  return result;
}

unint64_t RB::ColorStyle::ColorMonochrome::decode(RB::ColorStyle::ColorMonochrome *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      unint64_t v6 = v5 >> 3;
      if ((v5 >> 3) == 3)
      {
        *((float *)this + 5) = RB::ProtobufDecoder::float_field(a2, v5);
      }
      else if (v6 == 2)
      {
        *((float *)this + 4) = RB::ProtobufDecoder::float_field(a2, v5);
      }
      else if (v6 == 1)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          RB::Fill::Color::decode((uint64_t)this + 4, a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((unsigned char *)a2 + 56) = 1;
          *(void *)a2 = *((void *)a2 + 1);
        }
      }
      else
      {
        RB::ColorStyle::Base::decode_field(this, a2, v5);
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::ColorStyle::ColorMonochrome::print(std::string *this, std::string *a2)
{
  RB::SexpString::push(a2, "color-monochrome");
  RB::ColorStyle::Base::print(this, a2);
  RB::SexpString::printf(a2, 0, "(amount %g)", *(float *)&this->__r_.__value_.__r.__words[2]);
  float v4 = *((float *)&this->__r_.__value_.__r.__words[2] + 1);
  if (v4 != 0.0) {
    RB::SexpString::printf(a2, 0, "(bias %g)", v4);
  }
  RB::Fill::Color::print((RB::Fill::Color *)((char *)this->__r_.__value_.__r.__words + 4), a2);
  RB::SexpString::pop(a2);
}

void RB::ColorStyle::ColorInvert::print(std::string *this, std::string *a2)
{
  RB::SexpString::push(a2, "color-invert");
  RB::ColorStyle::Base::print(this, a2);
  RB::SexpString::printf(a2, 0, "(amount %g)", *((float *)this->__r_.__value_.__r.__words + 1));
  RB::SexpString::pop(a2);
}

uint64_t RB::Filter::GaussianBlur::GaussianBlur(uint64_t this, float a2, RB::DisplayList::Item *a3, const RB::Rect *a4, int a5)
{
  *(float *)this = a2;
  unint64_t v5 = (_OWORD *)(this + 8);
  if (a4)
  {
    *unint64_t v5 = *(_OWORD *)a4;
    int v6 = 256;
  }
  else
  {
    int v6 = 0;
    *(void *)unint64_t v5 = 0;
    *(void *)(this + 16) = 0;
  }
  *(_DWORD *)(this + 24) = v6 | a5;
  *(void *)(this + 32) = a3;
  return this;
}

RB::Filter::GaussianBlur *RB::Filter::GaussianBlur::GaussianBlur(RB::Filter::GaussianBlur *this, const RB::Filter::GaussianBlur *a2, RB::DisplayList::Builder *a3)
{
  *(_DWORD *)this = *(_DWORD *)a2;
  long long v4 = *(_OWORD *)((char *)a2 + 8);
  *((void *)this + 4) = 0;
  unint64_t v5 = (RB::DisplayList::Layer **)((char *)this + 32);
  *(_OWORD *)((char *)this + 8) = v4;
  *((_DWORD *)this + 6) = *((_DWORD *)a2 + 6);
  uint64_t v6 = *((void *)a2 + 4);
  if (v6)
  {
    uint64_t v8 = (*(uint64_t (**)(uint64_t, RB::DisplayList::Builder *, void))(*(void *)v6 + 24))(v6, a3, 0);
    unsigned int v9 = *v5;
    *unint64_t v5 = (RB::DisplayList::Layer *)v8;
    if (v9)
    {
      (**(void (***)(RB::DisplayList::Layer *))v9)(v9);
      uint64_t v8 = (uint64_t)*v5;
    }
    if (v8) {
      BOOL v10 = *((unsigned char *)a3 + 272) == 0;
    }
    else {
      BOOL v10 = 1;
    }
    if (!v10) {
      RB::DisplayList::Builder::simplify_item(a3, v5, 1);
    }
  }
  return this;
}

void sub_2141DB80C(_Unwind_Exception *exception_object)
{
  float v3 = *v1;
  *unsigned int v1 = 0;
  if (v3) {
    RB::Filter::GaussianBlur::GaussianBlur(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::Filter::GaussianBlur::append(uint64_t a1, int a2, uint64_t a3)
{
  if (a2 != 5 || *(_DWORD *)(a1 + 24) != *(_DWORD *)(a3 + 24)) {
    return 0;
  }
  *(float *)a1 = sqrtf((float)(*(float *)a3 * *(float *)a3) + (float)(*(float *)a1 * *(float *)a1));
  return 1;
}

float RB::Filter::GaussianBlur::layer_scale(RB::Filter::GaussianBlur *this, float a2)
{
  float v2 = 1.0;
  if (!*((void *)this + 4))
  {
    float v3 = 7.0;
    if ((*((unsigned char *)this + 24) & 0x20) == 0) {
      float v3 = 3.5;
    }
    return fminf(v3 / (float)(*(float *)this * a2), 1.0);
  }
  return v2;
}

uint64_t RB::Filter::GaussianBlur::apply_transform(float32x2_t *this, float64x2_t *a2)
{
  float v3 = a2 + 68;
  this->f32[0] = this->f32[0] * RB::AffineTransform::scale(a2 + 68);
  if (this[3].i8[1])
  {
    *(float32x2_t *)v4.i8 = this[2];
    this[1] = RB::operator*(v3, this[1], v4);
    this[2] = v5;
  }
  uint64_t result = (uint64_t)this[4];
  if (result)
  {
    int v7 = *(uint64_t (**)(void))(*(void *)result + 32);
    return v7();
  }
  return result;
}

uint64_t RB::Filter::GaussianBlur::required_depth(uint64_t a1, unsigned int a2)
{
  if (a2 == 3) {
    unsigned int v2 = 2;
  }
  else {
    unsigned int v2 = a2;
  }
  if (a2 == 1) {
    return 0;
  }
  else {
    return v2;
  }
}

uint64_t RB::Filter::GaussianBlur::can_mix(float32x2_t *this, RB::DisplayList::Interpolator::Contents *a2, float32x2_t *a3)
{
  if (a3)
  {
    if (this[3].i32[0] == a3[3].i32[0])
    {
      if (this->f32[0] == a3->f32[0]
        && (uint32x2_t v3 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(this[2], a3[2]), (int8x8_t)vceq_f32(this[1], a3[1])),
            (vpmin_u32(v3, v3).u32[0] & 0x80000000) != 0))
      {
        uint64_t v4 = 4;
      }
      else
      {
        uint64_t v4 = 1;
      }
      float32x2_t v5 = this[4];
      float32x2_t v6 = a3[4];
      if (v5)
      {
        if (v6)
        {
          v9[1] = 0;
          v9[2] = 0;
          v9[0] = 0xFFFFFFF000000000;
          int v10 = 0;
          uint64_t v11 = 1;
          int v12 = 0;
          (*(void (**)(float32x2_t, RB::DisplayList::Interpolator::Contents *, void *))(**(void **)&v5 + 208))(v5, a2, v9);
          unsigned int type = RB::DisplayList::Interpolator::Op::get_type((RB::DisplayList::Interpolator::Op *)v9);
          if (type >= v4) {
            return v4;
          }
          else {
            return type;
          }
        }
      }
      else if (!*(void *)&v6)
      {
        return v4;
      }
    }
    return 0;
  }
  if (this->f32[0] == 0.0) {
    return 4;
  }
  else {
    return 1;
  }
}

float RB::Filter::GaussianBlur::mix(float32x2_t *this, const RB::DisplayList::Interpolator::State *a2, float32x2_t *a3, const RB::DisplayList::CachedTransform *a4, double a5, int32x4_t a6)
{
  v26[14] = *MEMORY[0x263EF8340];
  float v8 = this->f32[0];
  if (a3)
  {
    float v11 = *((float *)a2 + 4);
    *(float *)&double v12 = v8 + (float)((float)(a3->f32[0] - v8) * v11);
    this->i32[0] = LODWORD(v12);
    if (this[3].i8[1])
    {
      float32x2_t v13 = this[1];
      float32x2_t v14 = a3[1];
      *(float32x2_t *)a6.i8 = vadd_f32(this[2], v13);
      *(float32x2_t *)a6.i8 = vmla_n_f32(*(float32x2_t *)a6.i8, vadd_f32(vsub_f32(v14, *(float32x2_t *)a6.i8), a3[2]), v11);
      double v12 = RB::Rect::from_bounds(vmla_n_f32(v13, vsub_f32(v14, v13), v11), a6);
      *(double *)&this[1] = v12;
      this[2] = v15;
    }
    if (*(void *)&this[4] && *(void *)&a3[4])
    {
      uint64_t v16 = *(void *)a4;
      v20[0] = xmmword_2142181C0;
      v20[1] = xmmword_2142181D0;
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      RB::DisplayList::CachedTransform::CachedTransform((uint64_t)v23, v16, v20, 0, 0, 0);
      uint64_t v17 = (*(uint64_t (**)(void, const RB::DisplayList::Interpolator::State *, void, unsigned char *))(**(void **)&this[4] + 216))(*(void *)&this[4], a2, *(void *)&a3[4], v23);
      double v18 = (void (***)(void))this[4];
      this[4] = (float32x2_t)v17;
      if (v18) {
        (**v18)(v18);
      }
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v26);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v25);
      RB::Heap::~Heap((RB::Heap *)&v24);
    }
  }
  else
  {
    *(float *)&double v12 = v8 - (float)(*((float *)a2 + 4) * v8);
    this->i32[0] = LODWORD(v12);
  }
  return *(float *)&v12;
}

void sub_2141DBC0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

double RB::Filter::GaussianBlur::dod(RB::Filter::GaussianBlur *this, float32x2_t *a2, int32x4_t a3)
{
  float32x2_t v3 = a2[1];
  uint32x2_t v4 = (uint32x2_t)vcgtz_f32(v3);
  *(uint32x2_t *)a3.i8 = vpmin_u32(v4, v4);
  if (a3.i32[0] < 0)
  {
    *(int32x2_t *)a3.i8 = vdup_n_s32(0x7F7FFFFFu);
    uint32x2_t v5 = (uint32x2_t)vcge_f32(vabs_f32(v3), *(float32x2_t *)a3.i8);
    int32x2_t v6 = (int32x2_t)vpmax_u32(v5, v5);
    if ((v6.i32[0] & 0x80000000) == 0)
    {
      *(float *)v6.i32 = ceilf(*(float *)this * 2.8);
      *(int32x2_t *)a3.i8 = vcgt_f32(*(float32x2_t *)a3.i8, v3);
      int32x4_t v8 = vcltzq_s32(a3);
      *(int8x8_t *)a3.i8 = vbsl_s8(*(int8x8_t *)v8.i8, (int8x8_t)vsub_f32(*a2, (float32x2_t)vdup_lane_s32(v6, 0)), (int8x8_t)*a2);
      int8x8_t v9 = (int8x8_t)vmla_n_f32(v3, (float32x2_t)0x4000000040000000, *(float *)v6.i32);
      float32x2_t v10 = (float32x2_t)vbsl_s8(*(int8x8_t *)v8.i8, v9, (int8x8_t)v3);
      *a2 = *(float32x2_t *)a3.i8;
      a2[1] = v10;
      if (*((unsigned char *)this + 25))
      {
        double v11 = *((double *)this + 2);
        float32x2_t v14 = *(float32x2_t *)((char *)this + 8);
        double v15 = v11;
        RB::Rect::intersect(&v14, *(double *)a3.i64, v10, *(double *)&v14, v11, *(double *)&v9, v8);
        *(float32x2_t *)a3.i8 = v14;
        float32x2_t v12 = *(float32x2_t *)&v15;
        *a2 = v14;
        a2[1] = v12;
      }
    }
  }
  return *(double *)a3.i64;
}

uint64_t RB::Filter::GaussianBlur::commutes_with_clip(RB::Filter::GaussianBlur *this)
{
  return *((_DWORD *)this + 6) & 1;
}

uint64_t RB::Filter::GaussianBlur::prepare(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 168))();
  }
  return result;
}

void RB::Filter::GaussianBlur::render(uint64_t a1, uint64_t a2, id ***a3, int32x2_t a4)
{
  if (*(float *)a1 >= 0.25)
  {
    if (!*(void *)(a1 + 32)) {
      operator new();
    }
    RB::Filter::GaussianBlur::render_variable(a1, a2, a3, a4);
  }
}

void RB::Filter::GaussianBlur::render_variable(uint64_t a1, uint64_t a2, id ***a3, int32x2_t a4)
{
  uint64_t v7 = a1;
  uint64_t v98 = *MEMORY[0x263EF8340];
  float v8 = *(float *)a1;
  int32x2_t v9 = (int32x2_t)a3[20];
  int32x2_t v10 = (int32x2_t)a3[21];
  float32x2_t v11 = vcvt_f32_s32(v10);
  unsigned int v12 = *(_DWORD *)(a1 + 24);
  if ((v12 & 0x100) != 0)
  {
    int32x2_t v15 = vsub_s32(a4, v9);
    *(_OWORD *)uint64_t v96 = *(_OWORD *)(a1 + 8);
    v14.i32[1] = HIDWORD(v96[0]);
    v14.f32[0] = (float)v15.i32[0];
    RB::Rect::translate((float32x2_t *)v96, v14, (float)v15.i32[1]);
    int8x8_t v13 = (int8x8_t)vmaxnm_f32((float32x2_t)v96[0], 0);
    float32x2_t v11 = vminnm_f32(v11, vadd_f32((float32x2_t)v96[1], (float32x2_t)v96[0]));
    unsigned int v12 = *(_DWORD *)(v7 + 24);
  }
  else
  {
    int8x8_t v13 = 0;
  }
  if ((v12 & 2) != 0) {
    __int16 v16 = 256;
  }
  else {
    __int16 v16 = ((v12 & 4) << 6) | (v12 >> 2) & 1;
  }
  RB::RenderPass::WorkingSpace::WorkingSpace((uint64_t)v96, (MTLPixelFormat)a3, v16, v12 & 1, 0);
  _S8 = v8 * 0.61;
  v18.n128_u64[0] = (unint64_t)vsub_s32((int32x2_t)(*(void *)&vshr_n_s32(vadd_s32(vadd_s32(v9, v10), (int32x2_t)0x7F0000007FLL), 1uLL) & 0xFFFFFFC0FFFFFFC0), (int32x2_t)(*(void *)&vshr_n_s32(vadd_s32(v9, (int32x2_t)0x7E0000007ELL), 1uLL) & 0xFFFFFFC0FFFFFFC0));
  __n128 v80 = v18;
  unsigned int v19 = v18.n128_u32[1];
  if (v18.n128_i32[1] <= v18.n128_i32[0]) {
    unsigned int v19 = v18.n128_u32[0];
  }
  unsigned int v20 = 32 - __clz(v19);
  unsigned int v21 = vcvtps_u32_f32(log2f(_S8));
  if (v20 <= v21) {
    unsigned int v22 = v21;
  }
  else {
    unsigned int v22 = v20;
  }
  RB::Device::alloc_shared_texture(***a3, (RB *)a3[2], v22, v97, 1, (int32x2_t **)&v93, v80);
  RB::RenderFrame::flush_pass(**a3, (RB::RenderPass *)a3, 1);
  uint64_t v24 = v96[0];
  uint64_t v23 = v96[1];
  if (v96[1]) {
    uint64_t v25 = v96[1];
  }
  else {
    uint64_t v25 = v96[0];
  }
  float32x2_t v26 = vcvt_f32_s32(v9);
  if (v22)
  {
    float v77 = _S8;
    float32x2_t v78 = v11;
    uint64_t v79 = v7;
    uint64_t v27 = 0;
    long long v28 = (int32x2_t *)*((void *)v25 + 1);
    int32x2_t v29 = v28[8];
    float32x2_t v76 = v26;
    float32x2_t v30 = v11;
    float32x2_t v31 = (float32x2_t)v13;
    do
    {
      RB::RenderPass::RenderPass(&v83, *a3, v93, v27, 1, 0);
      int32x2_t v32 = vshl_s32(vadd_s32(*(int32x2_t *)((char *)v93 + 64), vdup_n_s32(~(-1 << v27))), vneg_s32(vdup_n_s32(v27)));
      v33.n128_u64[0] = (unint64_t)vmin_s32(vadd_s32(v32, (int32x2_t)0x100000001), v32);
      uint64_t v87 = 0;
      unint64_t v88 = v33.n128_u64[0];
      RB::RenderPass::set_extra_attachments((uint64_t)&v83, MTLPixelFormatInvalid, v33);
      RB::RenderPass::set_label((id *)&v83, &cfstr_RbVariableBlur.isa);
      RB::Coverage::set_plane((float32x2_t *)v81, (uint64_t)&v83, v34);
      float32x2_t v35 = vcvt_f32_s32(v29);
      float32x2_t v36 = vrecpe_f32(v35);
      float32x2_t v37 = vmul_f32(vrecps_f32(v35, v36), v36);
      float32x2_t v38 = vmul_f32(v37, vrecps_f32(v35, v37));
      *(float32x2_t *)&v81[28] = vadd_f32(v38, v38);
      *(float32x2_t *)&v81[36] = vmul_f32(v38, v26);
      *(float32x2_t *)&v81[44] = vmul_f32(v38, vadd_f32(vadd_f32(v31, v26), (float32x2_t)0x3F0000003F000000));
      *(float32x2_t *)&v81[52] = vmul_f32(v38, vadd_f32(vadd_f32(v30, v26), (float32x2_t)0xBF000000BF000000));
      *(_DWORD *)&v81[92] = v27 - (v27 != 0);
      *(void *)&v81[60] = COERCE_UNSIGNED_INT(-v38.f32[0]);
      float32x2_t v39 = vneg_f32(v38);
      v39.i32[0] = 0;
      *(float32x2_t *)&v81[68] = v39;
      *(void *)&v81[76] = v38.u32[0];
      v38.i32[0] = 0;
      *(float32x2_t *)&v81[84] = v38;
      uint64_t v82 = 0x3400340034003400;
      if (*((_DWORD *)a3 + 34) == 2) {
        uint64_t v40 = 2228255;
      }
      else {
        uint64_t v40 = 2097183;
      }
      RB::RenderFrame::alloc_buffer_region(*(RB::RenderFrame **)v83, (RB::Device *)0x68, 4uLL, 0, &v94);
      float64x2_t v41 = v94;
      if (v94)
      {
        uint64_t v42 = *((void *)v94 + 7) + v95.i64[0];
        long long v43 = *(_OWORD *)&v81[32];
        long long v44 = *(_OWORD *)v81;
        *(_OWORD *)(v42 + 16) = *(_OWORD *)&v81[16];
        *(_OWORD *)(v42 + 32) = v43;
        long long v46 = *(_OWORD *)&v81[64];
        long long v45 = *(_OWORD *)&v81[80];
        long long v47 = *(_OWORD *)&v81[48];
        *(void *)(v42 + 96) = v82;
        *(_OWORD *)(v42 + 64) = v46;
        *(_OWORD *)(v42 + 80) = v45;
        *(_OWORD *)(v42 + 48) = v47;
        *(_OWORD *)uint64_t v42 = v44;
      }
      else
      {
        uint64_t v94 = 0;
        int64x2_t v95 = 0uLL;
      }
      int v89 = RB::RenderFrame::buffer_id(*(RB::RenderFrame **)v83, v41);
      int32x2_t v90 = vmovn_s64(v95);
      if (v27) {
        unsigned int v48 = v93;
      }
      else {
        unsigned int v48 = (RB::Texture *)v28;
      }
      int v91 = RB::RenderFrame::texture_id(*(RB::RenderFrame **)v83, (uint64_t)v48);
      char v92 = 0;
      RB::RenderPass::draw_indexed_primitives((int32x2_t *)&v83, (const char *)v40, 4, **(void **)v83 + 80, 0, 1uLL, (int32x2_t)0xC0000001C0000001, (int32x2_t)0x7FFFFFFF7FFFFFFFLL);
      v49.i32[0] = 0;
      v50.i32[0] = v27;
      int8x8_t v51 = (int8x8_t)vdup_lane_s32(vceq_s32(v50, v49), 0);
      float32x2_t v26 = (float32x2_t)vbsl_s8(v51, v13, (int8x8_t)vrndm_f32(vmul_f32(v26, (float32x2_t)0x3F0000003F000000)));
      int32x2_t v29 = (int32x2_t)vbsl_s8(v51, (int8x8_t)v80.n128_u64[0], (int8x8_t)vshr_n_s32(vadd_s32(v29, (int32x2_t)0x100000001), 1uLL));
      float32x2_t v31 = vrndm_f32(vmul_f32(v31, (float32x2_t)0x3F0000003F000000));
      float32x2_t v30 = vrndp_f32(vmul_f32(v30, (float32x2_t)0x3F0000003F000000));
      int v91 = 0;
      char v92 = 0;
      RB::RenderPass::~RenderPass((RB::RenderPass *)&v83);
      uint64_t v27 = (v27 + 1);
    }
    while (v22 != v27);
    uint64_t v24 = v96[0];
    uint64_t v23 = v96[1];
    uint64_t v7 = v79;
    float32x2_t v11 = v78;
    _S8 = v77;
    float32x2_t v26 = v76;
  }
  if (v23) {
    uint64_t v52 = v23;
  }
  else {
    uint64_t v52 = v24;
  }
  (*(void (**)(void, uint64_t, RB::RenderPass *, void, uint64_t, double))(**(void **)(v7 + 32) + 176))(*(void *)(v7 + 32), a2, v52, 0, 19, *(double *)&a4);
  if (v96[1]) {
    float64x2_t v54 = v96[1];
  }
  else {
    float64x2_t v54 = v96[0];
  }
  RB::Coverage::set_plane((float32x2_t *)&v83, (uint64_t)v54, v53);
  *(void *)&v84[12] = 0x3F0000003F000000;
  *(float32x2_t *)&v84[20] = vmul_f32(v26, (float32x2_t)0xBF000000BF000000);
  *(int8x8_t *)&v84[28] = v13;
  *(float32x2_t *)&v84[36] = v11;
  _D0 = vcvt_f32_s32(*(int32x2_t *)((char *)v93 + 64));
  float32x2_t v56 = vrecpe_f32(_D0);
  float32x2_t v57 = vmul_f32(vrecps_f32(_D0, v56), v56);
  *(float32x2_t *)&v84[44] = vmul_f32(v57, vrecps_f32(_D0, v57));
  HIDWORD(v85) = 0;
  __asm { FCVT            H0, S8 }
  LOWORD(v86) = _D0.i16[0];
  int v62 = *(_DWORD *)(v7 + 24);
  if (*((_DWORD *)v54 + 34) == 2) {
    int v63 = 131103;
  }
  else {
    int v63 = 31;
  }
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v54, (RB::Device *)0x68, 4uLL, 0, v81);
  __n128 v64 = *(RB::Buffer **)v81;
  if (*(void *)v81)
  {
    uint64_t v65 = *(void *)(*(void *)v81 + 56) + *(void *)&v81[8];
    long long v66 = *(_OWORD *)&v84[16];
    long long v67 = v83;
    *(_OWORD *)(v65 + 16) = *(_OWORD *)v84;
    *(_OWORD *)(v65 + 32) = v66;
    long long v69 = *(_OWORD *)&v84[48];
    long long v68 = v85;
    long long v70 = *(_OWORD *)&v84[32];
    *(void *)(v65 + 96) = v86;
    *(_OWORD *)(v65 + 64) = v69;
    *(_OWORD *)(v65 + 80) = v68;
    *(_OWORD *)(v65 + 48) = v70;
    *(_OWORD *)uint64_t v65 = v67;
  }
  else
  {
    memset(v81, 0, 24);
  }
  *((_DWORD *)v54 + 46) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v54, v64);
  *(int32x2_t *)((char *)v54 + 188) = vmovn_s64(*(int64x2_t *)&v81[8]);
  *((_DWORD *)v54 + 58) = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)v54, (uint64_t)v93);
  *((unsigned char *)v54 + 236) = 0;
  RB::RenderPass::draw_indexed_primitives((int32x2_t *)v54, (const char *)((v62 << 22) & 0x2000000 | ((v62 & 1) << 24) | v63 | 0x400000u), 4, ***(void ***)v54 + 80, 0, 1uLL, v9, v10);
  *((_DWORD *)v54 + 58) = 0;
  *((unsigned char *)v54 + 236) = 0;
  float v72 = RB::RenderPass::WorkingSpace::commit((RB::RenderPass::WorkingSpace *)v96, v71);
  long long v73 = v93;
  if (v93)
  {
    int v74 = *((_DWORD *)v93 + 2) - 1;
    *((_DWORD *)v93 + 2) = v74;
    if (!v74) {
      (*(void (**)(RB::Texture *, float))(*(void *)v73 + 8))(v73, v72);
    }
  }
  uint64_t v75 = v96[1];
  v96[1] = 0;
  if (v75) {
    RB::RenderPass::~RenderPass(v75);
  }
}

void sub_2141DC5E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  *(_DWORD *)(v70 + 232) = 0;
  *(unsigned char *)(v70 + 236) = 0;
  if (a65)
  {
    int v72 = a65[2] - 1;
    a65[2] = v72;
    if (!v72) {
      (*(void (**)(_DWORD *))(*(void *)a65 + 8))(a65);
    }
  }
  if (a70) {
    RB::RenderPass::~RenderPass(a70);
  }
  _Unwind_Resume(a1);
}

uint64_t RB::Filter::GaussianBlur::prepare_encode(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 240))();
  }
  return result;
}

int *RB::Filter::GaussianBlur::encode(int *this, RB::Encoder *a2)
{
  float32x2_t v3 = this;
  int v4 = *this;
  if (*(float *)this != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xDuLL);
    this = (int *)RB::ProtobufEncoder::encode_fixed32(a2, v4);
  }
  int v5 = v3[6];
  if ((v5 & 0x100) != 0)
  {
    this = (int *)RB::ProtobufEncoder::float4_field(a2, 2, *(float32x4_t *)(v3 + 2));
    int v5 = v3[6];
    if ((v5 & 1) == 0)
    {
LABEL_5:
      if ((v5 & 2) == 0) {
        goto LABEL_6;
      }
      goto LABEL_17;
    }
  }
  else if ((v5 & 1) == 0)
  {
    goto LABEL_5;
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
  this = (int *)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  int v5 = v3[6];
  if ((v5 & 2) == 0)
  {
LABEL_6:
    if ((v5 & 4) == 0) {
      goto LABEL_7;
    }
    goto LABEL_18;
  }
LABEL_17:
  RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
  this = (int *)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  int v5 = v3[6];
  if ((v5 & 4) == 0)
  {
LABEL_7:
    if ((v5 & 8) == 0) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
LABEL_18:
  RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
  this = (int *)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  if ((v3[6] & 8) != 0)
  {
LABEL_8:
    RB::ProtobufEncoder::encode_varint(a2, 0x30uLL);
    this = (int *)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
LABEL_9:
  uint64_t v6 = *((void *)v3 + 4);
  if (v6)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x3AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    (*(void (**)(uint64_t, RB::Encoder *))(*(void *)v6 + 248))(v6, a2);
    this = (int *)RB::ProtobufEncoder::end_length_delimited(a2);
  }
  unint64_t v7 = (v3[6] >> 4) & 3;
  if (v7)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x40uLL);
    return (int *)RB::ProtobufEncoder::encode_varint(a2, v7);
  }
  return this;
}

unint64_t RB::Filter::GaussianBlur::decode(RB::Filter::GaussianBlur *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    while (2)
    {
      switch((v5 >> 3))
      {
        case 1u:
          *(float *)this = RB::ProtobufDecoder::float_field(a2, v5);
          goto LABEL_27;
        case 2u:
          __n128 v6 = RB::ProtobufDecoder::float4_field(a2, v5);
          if ((vmaxvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32((float32x4_t)v6))) & 0x80000000) != 0)
          {
            *(__n128 *)((char *)this + 8) = v6;
            int v7 = *((_DWORD *)this + 6) | 0x100;
            goto LABEL_26;
          }
          goto LABEL_27;
        case 3u:
          int v7 = *((_DWORD *)this + 6) | RB::ProtobufDecoder::BOOL_field(a2, v5);
          goto LABEL_26;
        case 4u:
          if (RB::ProtobufDecoder::BOOL_field(a2, v5)) {
            int v8 = 2;
          }
          else {
            int v8 = 0;
          }
          goto LABEL_25;
        case 5u:
          if (RB::ProtobufDecoder::BOOL_field(a2, v5)) {
            int v8 = 4;
          }
          else {
            int v8 = 0;
          }
          goto LABEL_25;
        case 6u:
          if (RB::ProtobufDecoder::BOOL_field(a2, v5)) {
            int v8 = 8;
          }
          else {
            int v8 = 0;
          }
          goto LABEL_25;
        case 7u:
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            uint64_t v10 = RB::DisplayList::Item::decode(a2, v9);
            if (v10)
            {
              uint64_t v11 = v10;
              unsigned int v12 = (void (***)(void))*((void *)this + 4);
              *((void *)this + 4) = v11;
              if (v12) {
                (**v12)(v12);
              }
            }
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
            *((unsigned char *)a2 + 56) = 1;
            *(void *)a2 = *((void *)a2 + 1);
          }
          goto LABEL_27;
        case 8u:
          *((_DWORD *)this + 6) &= 0xFFFFFFCF;
          unint64_t v13 = RB::ProtobufDecoder::uint_field((uint64_t **)a2, v5);
          if (v13 > 3) {
            goto LABEL_27;
          }
          int v8 = 16 * v13;
LABEL_25:
          int v7 = *((_DWORD *)this + 6) | v8;
LABEL_26:
          *((_DWORD *)this + 6) = v7;
LABEL_27:
          unint64_t result = RB::ProtobufDecoder::next_field(a2);
          unint64_t v5 = result;
          if (!result) {
            return result;
          }
          continue;
        default:
          RB::ProtobufDecoder::skip_field(a2, v5);
          goto LABEL_27;
      }
    }
  }
  return result;
}

void RB::Filter::GaussianBlur::print(RB::Filter::GaussianBlur *this, std::string *a2)
{
  RB::SexpString::push(a2, "blur");
  int v4 = *((_DWORD *)this + 6);
  if ((v4 & 2) != 0)
  {
    unint64_t v5 = "linear";
  }
  else
  {
    if ((v4 & 4) == 0) {
      goto LABEL_6;
    }
    unint64_t v5 = "non-linear";
  }
  RB::SexpString::print(a2, 0, v5);
LABEL_6:
  int v6 = *((_DWORD *)this + 6);
  if (v6)
  {
    RB::SexpString::print(a2, 0, "opaque");
    int v6 = *((_DWORD *)this + 6);
    if ((v6 & 8) == 0)
    {
LABEL_8:
      if ((v6 & 0x100) == 0) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 8) == 0)
  {
    goto LABEL_8;
  }
  RB::SexpString::print(a2, 0, "dither");
  if ((*((_DWORD *)this + 6) & 0x100) != 0) {
LABEL_9:
  }
    RB::SexpString::printf(a2, 1, "(bounds %g %g %g %g)", COERCE_FLOAT(*((void *)this + 1)), COERCE_FLOAT(HIDWORD(*((void *)this + 1))), COERCE_FLOAT(*((void *)this + 2)), COERCE_FLOAT(HIDWORD(*((void *)this + 2))));
LABEL_10:
  RB::SexpString::printf(a2, 1, "(radius %g)", *(float *)this);
  if (*((void *)this + 4))
  {
    RB::SexpString::push(a2, "variable-mask");
    (*(void (**)(void))(**((void **)this + 4) + 256))();
    RB::SexpString::pop(a2);
  }
  RB::SexpString::pop(a2);
}

void RB::Filter::anonymous namespace'::BlurRenderer::~BlurRenderer(RB::Filter::_anonymous_namespace_::BlurRenderer *this)
{
}

uint64_t RB::Filter::anonymous namespace'::BlurRenderer::render(uint64_t a1, uint64_t a2, char a3, uint64_t a4, int32x2_t a5, int32x2_t a6)
{
  v108[3] = *MEMORY[0x263EF8340];
  int v12 = *(_DWORD *)(a1 + 16);
  if (v12 > 2 || *(unsigned char *)(a1 + 56))
  {
    RB::Coverage::set_plane((float32x2_t *)&v106, a2, a5);
    int v13 = *(_DWORD *)(a1 + 16);
    if (v13 < 7)
    {
      if (v13 < 3)
      {
        uint64_t v22 = 0;
        __asm { FMOV            V0.2S, #1.0 }
        _D12 = _D0;
        goto LABEL_37;
      }
      if (!*(unsigned char *)(a1 + 9))
      {
        uint64_t v22 = 0;
        *(float *)(a1 + 12) = (float)(*(float *)(a1 + 12) * 0.25) + -0.76562;
        _D12 = (float32x2_t)0x3F0000003F000000;
        _D0 = (float32x2_t)0x4000000040000000;
        goto LABEL_37;
      }
    }
    else if (!*(unsigned char *)(a1 + 9))
    {
      *(void *)((char *)&v107[2] + 12) = 0x3F800000BF800000;
      __asm { FMOV            V0.2S, #1.0 }
      *(void *)((char *)&v107[3] + 4) = _D0;
      __asm { FMOV            V0.2S, #-1.0 }
      *(void *)((char *)&v107[3] + 12) = _D0;
      *(void *)((char *)&v107[4] + 4) = 0xBF8000003F800000;
      v108[0] = 0x3400340034003400;
      *(float *)(a1 + 12) = (float)(*(float *)(a1 + 12) * 0.0625) + -0.47266;
      __asm
      {
        FMOV            V12.2S, #0.25
        FMOV            V0.2S, #4.0
      }
      uint64_t v22 = 0x100000;
      goto LABEL_37;
    }
    char v23 = *(unsigned char *)(a1 + 57);
    if (v23)
    {
      _D12 = (float32x2_t)0x3F8000003F000000;
      _D0 = (float32x2_t)0x3F80000040000000;
      uint64_t v24 = 1086026033;
      uint64_t v25 = 1081725962;
      uint64_t v26 = 1073333521;
    }
    else
    {
      *(float *)(a1 + 12) = (float)(*(float *)(a1 + 12) * 0.25) + -2.56;
      _D12 = (float32x2_t)0x3F0000003F800000;
      _D0 = (float32x2_t)0x400000003F800000;
      uint64_t v24 = 0x40BB713100000000;
      uint64_t v25 = 0x4079D40A00000000;
      uint64_t v26 = 0x3FF9C51100000000;
    }
    HIDWORD(v107[2]) = 0;
    LODWORD(v107[3]) = 0;
    *(void *)((char *)&v107[3] + 4) = v26;
    *(void *)((char *)&v107[3] + 12) = v25;
    *(void *)((char *)&v107[4] + 4) = v24;
    v108[0] = 0x29D62F9132B4300ELL;
    *(unsigned char *)(a1 + 57) = v23 ^ 1;
    uint64_t v22 = 3145728;
LABEL_37:
    float32x2_t v64 = vcvt_f32_s32(a6);
    float32x2_t v65 = vadd_f32(v64, (float32x2_t)0x3F0000003F000000);
    float32x2_t v66 = vadd_f32(v64, (float32x2_t)0xBF000000BF000000);
    int32x2_t v67 = vcvt_s32_f32(vrndp_f32(vmul_f32(_D12, vcvt_f32_s32(*(int32x2_t *)(a1 + 24)))));
    *(double *)(a2 + 160) = *(double *)&a5;
    *(int32x2_t *)(a2 + 168) = v67;
    *(float32x2_t *)((char *)v107 + 12) = _D0;
    *(float32x2_t *)((char *)&v107[1] + 4) = vmls_f32(v64, vcvt_f32_s32(a5), _D0);
    float32x2_t v68 = *(float32x2_t *)(a1 + 40);
    *(float32x2_t *)((char *)&v107[1] + 12) = vadd_f32(v65, *(float32x2_t *)(a1 + 32));
    *(float32x2_t *)((char *)&v107[2] + 4) = vadd_f32(v66, v68);
    HIDWORD(v107[4]) = 0;
    if (*(_DWORD *)(a2 + 136) == 2) {
      uint64_t v69 = 131103;
    }
    else {
      uint64_t v69 = 31;
    }
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x68, 4uLL, 0, &v104);
    uint64_t v70 = v104;
    if (v104)
    {
      uint64_t v71 = *((void *)v104 + 7) + v105.i64[0];
      long long v72 = v107[1];
      long long v73 = v106;
      *(_OWORD *)(v71 + 16) = v107[0];
      *(_OWORD *)(v71 + 32) = v72;
      long long v75 = v107[3];
      long long v74 = v107[4];
      long long v76 = v107[2];
      *(void *)(v71 + 96) = v108[0];
      *(_OWORD *)(v71 + 64) = v75;
      *(_OWORD *)(v71 + 80) = v74;
      *(_OWORD *)(v71 + 48) = v76;
      *(_OWORD *)uint64_t v71 = v73;
    }
    else
    {
      uint64_t v104 = 0;
      int64x2_t v105 = 0uLL;
    }
    *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v70);
    *(int32x2_t *)(a2 + 188) = vmovn_s64(v105);
    *(_DWORD *)(a2 + 232) = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)a2, a4);
    *(unsigned char *)(a2 + 236) = 0;
    RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, (const char *)(v69 | v22), 4, ***(void ***)a2 + 80, 0, 1uLL, (int32x2_t)0xC0000001C0000001, (int32x2_t)0x7FFFFFFF7FFFFFFFLL);
    float32x2_t v77 = *(float32x2_t *)(a1 + 40);
    float32x2_t v78 = vrndm_f32(vmul_f32(*(float32x2_t *)(a1 + 32), _D12));
    *(int32x2_t *)(a1 + 24) = v67;
    *(float32x2_t *)(a1 + 32) = v78;
    float32x2_t v79 = vrndp_f32(vmul_f32(v77, _D12));
    float32x2_t v80 = vmul_f32(*(float32x2_t *)(a1 + 48), _D12);
    *(float32x2_t *)(a1 + 40) = v79;
    *(float32x2_t *)(a1 + 48) = v80;
    if (*(unsigned char *)(a1 + 57))
    {
      int v81 = vcvtps_s32_f32((float)(*(float *)(a1 + 12) * 0.081633) + -0.001);
      if (v81 <= 1) {
        int v81 = 1;
      }
      *(_DWORD *)(a1 + 16) = v81;
      *(unsigned char *)(a1 + 56) = a3 & 1;
    }
    goto LABEL_47;
  }
  uint64_t v27 = 131103;
  if (v12 >= 1)
  {
    if (!*(_DWORD *)(a1 + 92))
    {
      uint64_t v28 = 0;
      double v29 = (float)(*(float *)(a1 + 12) / (float)v12);
      double v30 = 1.0 / v29;
      double v31 = 1.0 / sqrt(v29 * 6.28318531);
      double v32 = 0.0;
      do
      {
        long double v33 = exp((double)((int)v28 - 7) * (double)((int)v28 - 7) * -0.5 * v30) * v31;
        *((long double *)&v107[-1] + v28) = v33;
        double v32 = v33 + v32;
        ++v28;
      }
      while (v28 != 15);
      for (uint64_t i = 0; i != 120; i += 8)
        *(double *)((char *)&v107[-1] + i) = *(double *)((char *)&v107[-1] + i) * (1.0 / v32);
      double v35 = *(double *)&v107[1] + *((double *)&v107[1] + 1);
      double v36 = *(double *)v107 + *((double *)v107 + 1);
      double v37 = *(double *)&v106 + *((double *)&v106 + 1);
      double v38 = *(double *)&v107[1] / (*(double *)&v107[1] + *((double *)&v107[1] + 1)) + 2.0;
      double v39 = *(double *)v107 / (*(double *)v107 + *((double *)v107 + 1)) + 4.0;
      double v40 = *(double *)&v106 / (*(double *)&v106 + *((double *)&v106 + 1)) + 6.0;
      if (*(double *)&v107[1] + *((double *)&v107[1] + 1) < 0.002)
      {
        double v35 = 0.0;
        double v38 = 0.0;
      }
      if (v36 < 0.002)
      {
        double v36 = 0.0;
        double v39 = 0.0;
      }
      if (v37 < 0.002)
      {
        double v37 = 0.0;
        double v40 = 0.0;
      }
      float v41 = *(double *)&v107[2] / (*(double *)&v107[2] + *((double *)&v107[2] + 1) * 0.5);
      float v42 = v38;
      *(float *)(a1 + 76) = v41;
      *(float *)(a1 + 80) = v42;
      float v43 = v39;
      float v44 = v40;
      *(float *)(a1 + 84) = v43;
      *(float *)(a1 + 88) = v44;
      float v45 = 0.5 - (v35 + v36 + v37);
      float v46 = v35;
      *(float *)(a1 + 60) = v45;
      *(float *)(a1 + 64) = v46;
      float v47 = v36;
      float v48 = v37;
      *(float *)(a1 + 68) = v47;
      *(float *)(a1 + 72) = v48;
      *(_DWORD *)(a1 + 92) = 7;
    }
    int32x2_t v49 = *(int32x2_t *)(a1 + 24);
    *(double *)(a2 + 160) = *(double *)&a5;
    *(int32x2_t *)(a2 + 168) = v49;
    RB::Coverage::set_plane((float32x2_t *)&v106, a2, v49);
    uint64_t v50 = 0;
    uint64_t v51 = 0;
    float32x2_t v52 = vcvt_f32_s32(a6);
    *(float32x2_t *)((char *)&v107[1] + 4) = vsub_f32(v52, vcvt_f32_s32(a5));
    float32x2_t v53 = *(float32x2_t *)(a1 + 40);
    float32x2_t v54 = vadd_f32(vadd_f32(v52, (float32x2_t)0x3F0000003F000000), *(float32x2_t *)(a1 + 32));
    __asm { FMOV            V10.2S, #1.0 }
    *(float32x2_t *)((char *)v107 + 12) = _D10;
    *(float32x2_t *)((char *)&v107[1] + 12) = v54;
    *(float32x2_t *)((char *)&v107[2] + 4) = vadd_f32(vadd_f32(v52, (float32x2_t)0xBF000000BF000000), v53);
    HIDWORD(v107[4]) = 0;
    int v56 = *(unsigned __int8 *)(a1 + 57);
    float32x2_t v57 = (_DWORD *)&v107[2] + 3;
    uint64_t v58 = (_DWORD *)(a1 + 76);
    do
    {
      if (v56)
      {
        LODWORD(v59) = *v58;
        _DWORD *v57 = *v58;
        int v60 = 0;
        uint64_t v61 = v57;
      }
      else
      {
        uint64_t v61 = (void *)((char *)&v107[2] + 8 * v51 + 12);
        LODWORD(v59) = 0;
        _DWORD *v57 = 0;
        int v60 = *v58;
      }
      HIDWORD(v59) = v60;
      *uint64_t v61 = v59;
      _S0 = *(v58 - 4);
      __asm { FCVT            H0, S0 }
      *(_WORD *)((char *)v108 + v50) = _S0;
      ++v51;
      v50 += 2;
      v57 += 2;
      ++v58;
    }
    while (v50 != 8);
    if (!v56) {
      --*(_DWORD *)(a1 + 16);
    }
    if (*(unsigned char *)(a1 + 8))
    {
      if (*(_DWORD *)(a1 + 16)) {
        uint64_t v63 = 3145728;
      }
      else {
        uint64_t v63 = 19922944;
      }
    }
    else
    {
      uint64_t v63 = 3145728;
    }
    if (*(_DWORD *)(a2 + 136) != 2) {
      uint64_t v27 = 31;
    }
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x68, 4uLL, 0, &v104);
    uint64_t v96 = v104;
    if (v104)
    {
      uint64_t v97 = *((void *)v104 + 7) + v105.i64[0];
      long long v98 = v107[1];
      long long v99 = v106;
      *(_OWORD *)(v97 + 16) = v107[0];
      *(_OWORD *)(v97 + 32) = v98;
      long long v101 = v107[3];
      long long v100 = v107[4];
      long long v102 = v107[2];
      *(void *)(v97 + 96) = v108[0];
      *(_OWORD *)(v97 + 64) = v101;
      *(_OWORD *)(v97 + 80) = v100;
      *(_OWORD *)(v97 + 48) = v102;
      *(_OWORD *)uint64_t v97 = v99;
    }
    else
    {
      uint64_t v104 = 0;
      int64x2_t v105 = 0uLL;
    }
    *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v96);
    *(int32x2_t *)(a2 + 188) = vmovn_s64(v105);
    *(_DWORD *)(a2 + 232) = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)a2, a4);
    *(unsigned char *)(a2 + 236) = 0;
    RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, (const char *)(v27 | v63), 4, ***(void ***)a2 + 80, 0, 1uLL, (int32x2_t)0xC0000001C0000001, (int32x2_t)0x7FFFFFFF7FFFFFFFLL);
    *(unsigned char *)(a1 + 57) ^= 1u;
    if (!*(_DWORD *)(a1 + 16))
    {
      uint32x2_t v103 = (uint32x2_t)vceq_f32(*(float32x2_t *)(a1 + 48), _D10);
      uint64_t result = vpmin_u32(v103, v103).u32[0] >> 31;
      goto LABEL_48;
    }
LABEL_47:
    uint64_t result = 0;
LABEL_48:
    *(_DWORD *)(a2 + 232) = 0;
    *(unsigned char *)(a2 + 236) = 0;
    return result;
  }
  RB::Coverage::set_plane((float32x2_t *)&v106, a2, a5);
  float32x2_t v83 = vcvt_f32_s32(a6);
  float32x2_t v84 = vadd_f32(v83, (float32x2_t)0x3F0000003F000000);
  float32x2_t v85 = vadd_f32(v83, (float32x2_t)0xBF000000BF000000);
  float32x2_t v86 = vmls_f32(v83, vcvt_f32_s32(a5), *(float32x2_t *)(a1 + 48));
  *(void *)((char *)v107 + 12) = *(void *)(a1 + 48);
  *(float32x2_t *)((char *)&v107[1] + 4) = v86;
  float32x2_t v87 = *(float32x2_t *)(a1 + 40);
  *(float32x2_t *)((char *)&v107[1] + 12) = vadd_f32(v84, *(float32x2_t *)(a1 + 32));
  *(float32x2_t *)((char *)&v107[2] + 4) = vadd_f32(v85, v87);
  memset((char *)&v107[2] + 12, 0, 36);
  memset_pattern16(v108, &unk_21421C1A0, 8uLL);
  if (*(_DWORD *)(a2 + 136) == 2) {
    uint64_t v88 = 131103;
  }
  else {
    uint64_t v88 = 31;
  }
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x68, 4uLL, 0, &v104);
  int v89 = v104;
  if (v104)
  {
    uint64_t v90 = *((void *)v104 + 7) + v105.i64[0];
    long long v91 = v107[1];
    long long v92 = v106;
    *(_OWORD *)(v90 + 16) = v107[0];
    *(_OWORD *)(v90 + 32) = v91;
    long long v94 = v107[3];
    long long v93 = v107[4];
    long long v95 = v107[2];
    *(void *)(v90 + 96) = v108[0];
    *(_OWORD *)(v90 + 64) = v94;
    *(_OWORD *)(v90 + 80) = v93;
    *(_OWORD *)(v90 + 48) = v95;
    *(_OWORD *)uint64_t v90 = v92;
  }
  else
  {
    uint64_t v104 = 0;
    int64x2_t v105 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v89);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v105);
  *(_DWORD *)(a2 + 232) = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)a2, a4);
  *(unsigned char *)(a2 + 236) = 0;
  RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, (const char *)v88, 4, ***(void ***)a2 + 80, 0, 1uLL, (int32x2_t)0xC0000001C0000001, (int32x2_t)0x7FFFFFFF7FFFFFFFLL);
  *(_DWORD *)(a2 + 232) = 0;
  *(unsigned char *)(a2 + 236) = 0;
  return 1;
}

void sub_2141DD474(_Unwind_Exception *a1)
{
  *(_DWORD *)(v1 + 232) = 0;
  *(unsigned char *)(v1 + 236) = 0;
  _Unwind_Resume(a1);
}

float64x2_t RB::GeometryStyle::Rotation::set_affine_transform(RB::GeometryStyle::Rotation *this, float64x2_t *a2)
{
  __double2 v5 = __sincos_stret(*(double *)this);
  v4.f64[0] = v5.__cosval;
  v6.f64[0] = -v5.__sinval;
  v6.f64[1] = v5.__cosval;
  v4.f64[1] = v5.__sinval;
  float64x2_t result = vmlaq_n_f64(vmlaq_n_f64(vcvtq_f64_f32(*(float32x2_t *)((char *)this + 8)), v6, (float)-COERCE_FLOAT(HIDWORD(*((void *)this + 1)))), v4, (float)-COERCE_FLOAT(*((void *)this + 1)));
  *a2 = v4;
  a2[1] = v6;
  a2[2] = result;
  return result;
}

double RB::GeometryStyle::Rotation::mix(float32x2_t *this, const RB::GeometryStyle::Rotation *a2, double result)
{
  double v3 = *(double *)this;
  if (a2)
  {
    *(double *)this = v3 + (*(double *)a2 - v3) * *(float *)&result;
    this[1] = vmla_n_f32(this[1], vsub_f32(*(float32x2_t *)((char *)a2 + 8), this[1]), *(float *)&result);
  }
  else
  {
    float64x2_t result = v3 - v3 * *(float *)&result;
    *(double *)this = result;
  }
  return result;
}

void *RB::GeometryStyle::Rotation::encode(RB::GeometryStyle::Rotation *this, RB::Encoder *a2)
{
  uint64_t v4 = *(void *)this;
  if (*(double *)this != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 9uLL);
    RB::ProtobufEncoder::encode_fixed64(a2, v4);
  }
  double v5 = *((double *)this + 1);
  return RB::ProtobufEncoder::float2_field(a2, 2, v5);
}

unint64_t RB::GeometryStyle::Rotation::decode(RB::GeometryStyle::Rotation *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v6 = result;
    do
    {
      if ((v6 >> 3) == 2)
      {
        *((void *)this + 1) = RB::ProtobufDecoder::float2_field(a2, v6, v5).n128_u64[0];
      }
      else if ((v6 >> 3) == 1)
      {
        *(double *)this = RB::ProtobufDecoder::double_field(a2, v6);
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v6);
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v6 = result;
    }
    while (result);
  }
  return result;
}

void RB::GeometryStyle::Rotation::print(RB::GeometryStyle::Rotation *this, std::string *a2)
{
  RB::SexpString::push(a2, "rotation");
  RB::SexpString::printf(a2, 0, "(angle %g)", *(double *)this);
  RB::SexpString::printf(a2, 0, "(anchor %g %g)", COERCE_FLOAT(*((void *)this + 1)), COERCE_FLOAT(HIDWORD(*((void *)this + 1))));
  RB::SexpString::pop(a2);
}

double RB::GeometryStyle::Scale::set_affine_transform(float32x2_t *this, float64x2_t *a2)
{
  float32x2_t v2 = this[1];
  v3.f64[0] = 0.0;
  *(double *)&unint64_t v4 = COERCE_FLOAT(*this);
  v3.f64[1] = COERCE_FLOAT(HIDWORD(*(unint64_t *)this));
  double result = (float)-v2.f32[0];
  *a2 = (float64x2_t)v4;
  a2[1] = v3;
  a2[2] = vmlaq_n_f64(vmlaq_n_f64(vcvtq_f64_f32(v2), v3, (float)-v2.f32[1]), (float64x2_t)v4, result);
  return result;
}

float32x2_t *RB::GeometryStyle::Scale::mix(float32x2_t *this, float32x2_t *a2, float a3)
{
  float32x2_t v3 = *this;
  if (a2)
  {
    *this = vmla_n_f32(v3, vsub_f32(*a2, v3), a3);
    this[1] = vmla_n_f32(this[1], vsub_f32(a2[1], this[1]), a3);
  }
  else
  {
    __asm { FMOV            V2.2S, #1.0 }
    *this = vmla_n_f32(v3, vsub_f32(_D2, v3), a3);
  }
  return this;
}

void *RB::GeometryStyle::Scale::encode(RB::GeometryStyle::Scale *this, RB::Encoder *a2)
{
  RB::ProtobufEncoder::float2_field(a2, 1, *(double *)this);
  double v4 = *((double *)this + 1);
  return RB::ProtobufEncoder::float2_field(a2, 2, v4);
}

unint64_t RB::GeometryStyle::Scale::decode(RB::GeometryStyle::Scale *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v6 = result;
    do
    {
      if ((v6 >> 3) == 2)
      {
        *((void *)this + 1) = RB::ProtobufDecoder::float2_field(a2, v6, v5).n128_u64[0];
      }
      else if ((v6 >> 3) == 1)
      {
        *(void *)this = RB::ProtobufDecoder::float2_field(a2, v6, v5).n128_u64[0];
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v6);
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v6 = result;
    }
    while (result);
  }
  return result;
}

void RB::GeometryStyle::Scale::print(RB::GeometryStyle::Scale *this, std::string *a2)
{
  RB::SexpString::push(a2, "scale");
  RB::SexpString::printf(a2, 0, "(scale %g %g)", COERCE_FLOAT(*(void *)this), COERCE_FLOAT(HIDWORD(*(void *)this)));
  RB::SexpString::printf(a2, 0, "(anchor %g %g)", COERCE_FLOAT(*((void *)this + 1)), COERCE_FLOAT(HIDWORD(*((void *)this + 1))));
  RB::SexpString::pop(a2);
}

float64x2_t RB::GeometryStyle::Translation::set_affine_transform(float32x2_t *this, RB::AffineTransform *a2)
{
  float64x2_t result = vcvtq_f64_f32(*this);
  *(_OWORD *)a2 = xmmword_2142181C0;
  *((_OWORD *)a2 + 1) = xmmword_2142181D0;
  *((float64x2_t *)a2 + 2) = result;
  return result;
}

float32x2_t *RB::GeometryStyle::Translation::mix(float32x2_t *this, float32x2_t *a2, float a3)
{
  if (a2) {
    float32x2_t v3 = *a2;
  }
  else {
    float32x2_t v3 = 0;
  }
  *this = vmla_n_f32(*this, vsub_f32(v3, *this), a3);
  return this;
}

void *RB::GeometryStyle::Translation::encode(RB::GeometryStyle::Translation *this, RB::Encoder *a2)
{
  return RB::ProtobufEncoder::float2_field(a2, 1, *(double *)this);
}

uint64_t RB::GeometryStyle::Translation::decode(RB::GeometryStyle::Translation *this, RB::Decoder *a2)
{
  uint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    uint64_t v6 = result;
    do
    {
      if ((v6 & 0x7FFFFFFF8) == 8) {
        *(void *)this = RB::ProtobufDecoder::float2_field(a2, v6, v5).n128_u64[0];
      }
      else {
        RB::ProtobufDecoder::skip_field(a2, v6);
      }
      uint64_t result = RB::ProtobufDecoder::next_field(a2);
      uint64_t v6 = result;
    }
    while (result);
  }
  return result;
}

void RB::GeometryStyle::Translation::print(RB::GeometryStyle::Translation *this, std::string *a2)
{
}

BOOL RB::GeometryStyle::Rotation3D::operator==(uint64_t a1, uint64_t a2)
{
  if (*(double *)a1 == *(double *)a2
    && *(float *)(a1 + 48) == *(float *)(a2 + 48)
    && (uint32x4_t v2 = (uint32x4_t)vandq_s8((int8x16_t)vceqq_f32(*(float32x4_t *)(a1 + 32), *(float32x4_t *)(a2 + 32)), (int8x16_t)vceqq_f32(*(float32x4_t *)(a1 + 16), *(float32x4_t *)(a2 + 16))), v2.i32[3] = v2.i32[2], (vminvq_u32(v2) & 0x80000000) != 0))
  {
    return *(float *)(a1 + 52) == *(float *)(a2 + 52);
  }
  else
  {
    return 0;
  }
}

double RB::GeometryStyle::Rotation3D::set_projection_matrix(RB::GeometryStyle::Rotation3D *this, float32x4_t *a2)
{
  long long v4 = *(_OWORD *)(MEMORY[0x263F15740] + 80);
  v30[4] = *(_OWORD *)(MEMORY[0x263F15740] + 64);
  long long v31 = v4;
  long long v5 = *(_OWORD *)(MEMORY[0x263F15740] + 112);
  long long v32 = *(_OWORD *)(MEMORY[0x263F15740] + 96);
  long long v33 = v5;
  long long v6 = *(_OWORD *)(MEMORY[0x263F15740] + 16);
  v30[0] = *MEMORY[0x263F15740];
  v30[1] = v6;
  long long v7 = *(_OWORD *)(MEMORY[0x263F15740] + 48);
  Point v30[2] = *(_OWORD *)(MEMORY[0x263F15740] + 32);
  float64x2_t v30[3] = v7;
  *((double *)&v31 + 1) = (float)(-1.0 / *((float *)this + 12));
  CATransform3DMakeTranslation_(MEMORY[0x263F15740], *((float *)this + 8), *((float *)this + 9), *((float *)this + 10));
  MEMORY[0x216699150](&v29, v30, &v29);
  CATransform3DRotate_(v8, &v29, *(CGFloat *)this, *((float *)this + 4), *((float *)this + 5), *((float *)this + 6));
  CATransform3DTranslate_(v9, &v29, (float)-*((float *)this + 8), (float)-*((float *)this + 9), (float)-*((float *)this + 10));
  float32x4_t v16 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v29.m11), *(float64x2_t *)&v29.m14);
  v12.f64[0] = v29.m22;
  double m44 = v29.m44;
  v12.f64[1] = v29.m24;
  int8x16_t v14 = *(int8x16_t *)&v29.m41;
  float32x4_t v15 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v12), *(float64x2_t *)&v29.m41);
  *a2 = v16;
  a2[1] = v15;
  v16.f32[0] = m44;
  a2[2].i32[0] = v16.i32[0];
  v16.i32[0] = *((_DWORD *)this + 13);
  if ((v16.i32[0] & 0x7FFFFFFFu) <= 0x7F7FFFFF)
  {
    uint64_t v28 = 0x3F80000000000000;
    uint64_t v26 = 1065353216;
    long long v25 = xmmword_21421C1D0;
    __int32 v27 = v16.i32[0];
    RB::operator*((uint64_t)&v25, (uint64_t)a2, v22, v14, v10, v11);
    RB::operator*((uint64_t)v22, (uint64_t)&v25, v23, v17, v18, v19);
    v16.i64[0] = v23[0].i64[0];
    float32x4_t v20 = v23[1];
    *a2 = v23[0];
    a2[1] = v20;
    a2[2].i32[0] = v24;
  }
  return *(double *)v16.i64;
}

BOOL RB::GeometryStyle::Rotation3D::can_mix(RB::GeometryStyle::Rotation3D *this, const RB::GeometryStyle::Rotation3D *a2)
{
  return !a2 || (*((_DWORD *)this + 13) & 0x7FFFFFFFu) < 0x7F800000 == (*((_DWORD *)a2 + 13) & 0x7FFFFFFFu) < 0x7F800000;
}

double RB::GeometryStyle::Rotation3D::mix(RB::GeometryStyle::Rotation3D *this, float32x4_t *a2, double result)
{
  double v3 = *(double *)this;
  if (a2)
  {
    *(double *)this = v3 + (*(double *)a2->i64 - v3) * *(float *)&result;
    float32x4_t v4 = *((float32x4_t *)this + 2);
    *((float32x4_t *)this + 1) = vmlaq_n_f32(*((float32x4_t *)this + 1), vsubq_f32(a2[1], *((float32x4_t *)this + 1)), *(float *)&result);
    *((float32x4_t *)this + 2) = vmlaq_n_f32(v4, vsubq_f32(a2[2], v4), *(float *)&result);
    float v5 = *((float *)this + 13);
    *((float *)this + 12) = *((float *)this + 12)
                          + (float)((float)(a2[3].f32[0] - *((float *)this + 12)) * *(float *)&result);
    if ((LODWORD(v5) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
    {
      *(float *)&uint64_t result = v5 + (float)((float)(a2[3].f32[1] - v5) * *(float *)&result);
      *((_DWORD *)this + 13) = LODWORD(result);
    }
  }
  else
  {
    uint64_t result = v3 - v3 * *(float *)&result;
    *(double *)this = result;
  }
  return result;
}

void *RB::GeometryStyle::Rotation3D::encode(float32x4_t *this, RB::Encoder *a2)
{
  uint64_t v4 = this->i64[0];
  if (*(double *)this->i64 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 9uLL);
    RB::ProtobufEncoder::encode_fixed64(a2, v4);
  }
  RB::ProtobufEncoder::float3_field(a2, 2, this[1]);
  uint64_t result = RB::ProtobufEncoder::float3_field(a2, 3, this[2]);
  int v6 = this[3].i32[0];
  if (*(float *)&v6 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x25uLL);
    uint64_t result = RB::ProtobufEncoder::encode_fixed32(a2, v6);
  }
  int v7 = this[3].i32[1];
  if (*(float *)&v7 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x2DuLL);
    return RB::ProtobufEncoder::encode_fixed32(a2, v7);
  }
  return result;
}

unint64_t RB::GeometryStyle::Rotation3D::decode(__n128 *this, RB::Decoder *a2)
{
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          this->n128_f64[0] = RB::ProtobufDecoder::double_field(a2, v5);
          break;
        case 2u:
          this[1] = RB::ProtobufDecoder::float3_field(a2, v5);
          break;
        case 3u:
          this[2] = RB::ProtobufDecoder::float3_field(a2, v5);
          break;
        case 4u:
          this[3].n128_f32[0] = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        case 5u:
          this[3].n128_f32[1] = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        default:
          RB::ProtobufDecoder::skip_field(a2, v5);
          break;
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::GeometryStyle::Rotation3D::print(RB::GeometryStyle::Rotation3D *this, std::string *a2)
{
  RB::SexpString::push(a2, "rotation3d");
  RB::SexpString::printf(a2, 0, "(angle %g)", *(double *)this);
  RB::SexpString::printf(a2, 0, "(axis %g %g %g)", *((float *)this + 4), *((float *)this + 5), *((float *)this + 6));
  RB::SexpString::printf(a2, 0, "(anchor %g %g %g)", *((float *)this + 8), *((float *)this + 9), *((float *)this + 10));
  RB::SexpString::printf(a2, 0, "(perspective %g)", *((float *)this + 12));
  if ((*((_DWORD *)this + 13) & 0x7FFFFFFFu) <= 0x7F7FFFFF) {
    RB::SexpString::printf(a2, 0, "(flip-width %g)", *((float *)this + 13));
  }
  RB::SexpString::pop(a2);
}

BOOL RB::GeometryStyle::Affine::can_mix(RB *a1, const RB::AffineTransform *a2, const RB::AffineTransform *a3)
{
  return !a2 || RB::can_mix(a1, a2, a3) != 0;
}

CGAffineTransform *RB::GeometryStyle::Affine::mix(CGAffineTransform *this, uint64_t a2, const RB::AffineTransform *a3, float a4)
{
  if (a2)
  {
    long long v5 = *(_OWORD *)(a2 + 16);
    float64x2_t v10 = *(float64x2_t *)a2;
    long long v11 = v5;
    long long v12 = *(_OWORD *)(a2 + 32);
  }
  else
  {
    float64x2_t v10 = (float64x2_t)xmmword_2142181C0;
    long long v11 = xmmword_2142181D0;
    long long v12 = 0uLL;
  }
  unint64_t result = RB::mix(this, &v10, a3, a4);
  *(_OWORD *)&this->a = v7;
  *(_OWORD *)&this->c = v8;
  *(_OWORD *)&this->tCGFloat x = v9;
  return result;
}

void RB::GeometryStyle::Affine::print(RB::GeometryStyle::Affine *this, std::string *a2)
{
}

float32_t RB::GeometryStyle::Projection::mix(float32x4_t *a1, float32x4_t *a2, float a3)
{
  if (a2)
  {
    return RB::ProjectionMatrix::mix(a1, a2, a3);
  }
  else
  {
    uint64_t v8 = v3;
    uint64_t v9 = v4;
    int v7 = 1065353216;
    v6[0] = (float32x4_t)xmmword_214218320;
    v6[1] = (float32x4_t)xmmword_214218320;
    return RB::ProjectionMatrix::mix(a1, v6, a3);
  }
}

void RB::GeometryStyle::Projection::print(RB::GeometryStyle::Projection *this, std::string *a2)
{
    *(float *)this,
    *((float *)this + 1),
    *((float *)this + 2),
    *((float *)this + 3),
    *((float *)this + 4),
    *((float *)this + 5),
    *((float *)this + 6),
    *((float *)this + 7),
    *((float *)this + 8));
}

void RB::DisplayList::PackedTexture::render(RB::DisplayList::PackedTexture *this, void ***a2)
{
  while (1)
  {
    RB::RenderTaskTexture::render_dependencies(this, a2);
    uint64_t v5 = *((void *)this + 4);
    if (!*((void *)this + 2)) {
      break;
    }
LABEL_8:
    RB::RenderParams::RenderParams((uint64_t)v16, (uint64_t)*a2, v5, *((unsigned char *)this + 40), *((unsigned char *)a2 + 29), *((unsigned char *)a2 + 30), *((unsigned char *)a2 + 31) & 1, *((double *)this + 6), *((float *)a2 + 6));
    uint64_t v10 = *((void *)this + 2);
    char v17 = v17 & 0xF7 | (2 * *(unsigned char *)(v10 + 77)) & 8;
    RB::RenderPass::RenderPass(v15, v16, v10, 0, 1, 0);
    RB::RenderPass::set_label((id *)v15, &cfstr_RbPackedLayer.isa);
    uint64_t v12 = *((void *)this + 3);
    if (v12)
    {
      MTLPixelFormat v13 = 5;
      uint64_t v14 = *((void *)this + 3);
      do
      {
        v13 |= ((unint64_t)*(unsigned __int8 *)(v14 + 128) >> 1) & 8 | ((unint64_t)*(unsigned __int8 *)(v14 + 128) >> 2) & 2;
        uint64_t v14 = *(void *)(v14 + 48);
      }
      while (v14 && *(_DWORD *)(v12 + 12) == *(_DWORD *)(v14 + 12));
    }
    else
    {
      MTLPixelFormat v13 = MTLPixelFormatInvalid;
    }
    if (RB::RenderPass::set_extra_attachments((uint64_t)v15, v13, v11)) {
      RB::RenderTaskTexture::render_all_tasks(this, (RB::RenderPass *)v15, a2);
    }
    RB::RenderPass::~RenderPass((RB::RenderPass *)v15);
    if (!*((void *)this + 3)) {
      return;
    }
  }
  v4.n128_u64[0] = *((void *)this + 6);
  __n128 v6 = RB::Device::alloc_shared_texture(**a2, (RB *)*((void *)this + 4), 1u, *((unsigned char *)this + 40), 1, v15, v4);
  int v7 = (int32x2_t *)*((void *)this + 2);
  uint64_t v8 = v15[0];
  *((int32x2_t **)this + 2) = v15[0];
  v15[0] = v7;
  if (v7)
  {
    int v9 = v7[1].i32[0] - 1;
    v7[1].i32[0] = v9;
    if (!v9)
    {
      (*(void (**)(int32x2_t *, __n128))(*(void *)v7 + 8))(v7, v6);
      uint64_t v8 = (int32x2_t *)*((void *)this + 2);
    }
  }
  if (v8)
  {
    uint64_t v5 = *((void *)this + 4);
    if (v5 == 25)
    {
      v8[9].i8[5] |= 4u;
      uint64_t v5 = *((void *)this + 4);
    }
    goto LABEL_8;
  }
}

void sub_2141DE2AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  RB::RenderPass::~RenderPass((RB::RenderPass *)va);
  _Unwind_Resume(a1);
}

void RB::DisplayList::Layer::blit(uint64_t a1, int32x2_t *a2, int32x2_t *a3, int a4, long long **a5, uint64_t a6, int a7, unsigned int a8, float32x2_t a9, float32x2_t a10, double a11, float32x2_t a12, __n128 a13, float a14, char a15, unsigned __int8 a16)
{
  int v74 = a7;
  __n128 v73 = a13;
  uint64_t v72 = a1;
  __int32 v27 = 0;
  uint64_t v102 = *MEMORY[0x263EF8340];
  double v97 = 0.0;
  uint64_t v98 = 0;
  if (a4 == 1)
  {
    uint32x2_t v28 = (uint32x2_t)vtst_s32((int32x2_t)v73.n128_u64[0], (int32x2_t)v73.n128_u64[0]);
    if ((vpmax_u32(v28, v28).u32[0] & 0x80000000) != 0)
    {
      MEMORY[0x270FA5388](a1, a2);
      __int32 v27 = &v68;
      int v70 = 0;
      long long v68 = 0u;
      long long v69 = 0u;
      int v30 = v29;
      long long v31 = (*a5)[1];
      int v32 = *((_DWORD *)*a5 + 8);
      long long v68 = **a5;
      long long v69 = v31;
      int v70 = v32;
      int v34 = v33;
      RB::ProjectionMatrix::translate((RB::ProjectionMatrix *)&v68, (float)-v29, (float)-v33);
      v35.n64_f32[0] = (float)v30;
      RB::ProjectionMatrix::translate_right((RB::ProjectionMatrix *)&v68, v35, (float)v34);
    }
    else
    {
      __int32 v27 = *a5;
    }
  }
  if (!RB::may_discard_alpha(a8))
  {
    v36.i32[0] = 0;
    int32x2_t v43 = a2[21];
    uint32x2_t v44 = (uint32x2_t)vceq_s32(v43, (int32x2_t)0x8000000080000000);
    int8x8_t v45 = (int8x8_t)vdup_lane_s32(vcgt_s32(*(int32x2_t *)v36.i8, (int32x2_t)vpmin_u32(v44, v44)), 0);
    *(int8x8_t *)v37.i8 = vbsl_s8(v45, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v43));
    *(int8x8_t *)v36.i8 = vbsl_s8(v45, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a2[20]));
    double v97 = *(double *)v36.i64;
    char v42 = 1;
    goto LABEL_11;
  }
  switch(a4)
  {
    case 2:
      goto LABEL_9;
    case 1:
      *(float32x2_t *)v37.i8 = a12;
      *(float32x2_t *)v36.i8 = RB::operator*((uint64_t)v27, a11, v37);
      double v97 = *(double *)v36.i64;
      char v42 = 2;
      goto LABEL_11;
    case 0:
LABEL_9:
      double v97 = a11;
      char v42 = 2;
      *(float32x2_t *)v37.i8 = a12;
      *(double *)v36.i64 = a11;
LABEL_11:
      uint64_t v98 = v37.i64[0];
      goto LABEL_12;
  }
  char v42 = 2;
  v37.i64[0] = 0;
  v36.i64[0] = 0;
LABEL_12:
  v93[0] = v36.i64[0];
  v93[1] = v37.i64[0];
  v93[2] = 0;
  v93[3] = 0;
  unsigned char v93[4] = 1065353216;
  int v94 = 0;
  char v95 = v42;
  __int16 v96 = 1;
  if (a3) {
    *(float32x2_t *)v36.i8 = vcvt_f32_s32(a3[8]);
  }
  else {
    v36.i64[0] = 0;
  }
  int32x4_t v75 = v36;
  *(float32x2_t *)v37.i8 = vdiv_f32(vmul_f32(*(float32x2_t *)v36.i8, a12), a10);
  float32x2_t v46 = vdiv_f32(vmul_f32(a12, a9), a10);
  LODWORD(v90) = v37.i32[0];
  *(void *)((char *)&v90 + 4) = 0;
  int32x4_t v71 = v37;
  *(void *)&long long v91 = v37.u32[1];
  float32x2_t v47 = vsub_f32(*(float32x2_t *)&a11, v46);
  HIDWORD(v90) = 0;
  *((float32x2_t *)&v91 + 1) = v47;
  int v92 = 1065353216;
  float32x2_t v88 = a9;
  float32x2_t v89 = a10;
  if (a15)
  {
    *(int32x2_t *)v36.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), a10);
    int8x8_t v48 = (int8x8_t)vcltzq_s32(v36).u64[0];
    float32x2_t v49 = (float32x2_t)vbsl_s8(v48, (int8x8_t)vadd_f32(a9, (float32x2_t)0xBF000000BF000000), (int8x8_t)a9);
    __asm { FMOV            V1.2S, #1.0 }
    float32x2_t v55 = (float32x2_t)vbsl_s8(v48, (int8x8_t)vadd_f32(a10, _D1), (int8x8_t)a10);
  }
  else
  {
    v46.i32[0] = 0.5;
    RB::Rect::inset(&v88, v46, 0.5);
    float32x2_t v49 = v88;
    float32x2_t v55 = v89;
  }
  float32x2_t v56 = vrecpe_f32((float32x2_t)v75.u32[0]);
  float32x2_t v57 = vmul_f32(vrecps_f32((float32x2_t)v75.u32[0], v56), v56);
  int32x2_t v58 = (int32x2_t)vmul_f32(v57, vrecps_f32((float32x2_t)v75.u32[0], v57));
  float32x2_t v59 = vrecpe_f32((float32x2_t)v75.u32[1]);
  float32x2_t v60 = vrecps_f32((float32x2_t)v75.u32[1], v59);
  float32x2_t v61 = vmul_f32(v60, v59);
  *(float32x2_t *)v39.i8 = vrecps_f32((float32x2_t)v75.u32[1], v61);
  *(float32x2_t *)v38.i8 = vmul_f32(v61, *(float32x2_t *)v39.i8);
  float32x2_t v62 = (float32x2_t)vzip1_s32(v58, *(int32x2_t *)v38.i8);
  float32x2_t v63 = vmul_f32(v62, v49);
  double v64 = COERCE_DOUBLE(vmul_f32(v55, v62));
  float32x2_t v88 = v63;
  float32x2_t v89 = *(float32x2_t *)&v64;
  if (a4 == 2)
  {
    float32x2_t v66 = *a5;
    *(void *)&long long v67 = 0;
    *((double *)&v67 + 1) = *(float *)&v71.i32[1];
    v99[0] = COERCE_UNSIGNED_INT64(*(float *)v71.i32);
    v99[1] = v67;
    v99[2] = vcvtq_f64_f32(v47);
    (*(void (**)(long long *, uint64_t, int32x2_t *, double *, int32x2_t *, uint64_t, _OWORD *, float32x2_t *, __n128, float, _BYTE))(*(void *)v66 + 128))(v66, v72, a2, &v97, a3, a6, v99, &v88, v73, a14, v74);
  }
  else
  {
    if (a4 == 1)
    {
      RB::operator*=((uint64_t)&v90, (uint64_t)v27, *(double *)&v63, v64, *(double *)&v62, v38, v39, *(double *)&v60, v40, v41);
      __int16 v65 = 4;
    }
    else
    {
      __int16 v65 = a4 == 0;
    }
    RB::Heap::Heap((RB::Heap *)v87, 0, 0, 0);
    long long v81 = v90;
    long long v82 = v91;
    int v83 = v92;
    float32x2_t v79 = a3;
    v80[0] = v88;
    v80[1] = v89;
    v80[2] = 0;
    v80[3] = 0;
    uint64_t v84 = 0x3C003C003C003C00;
    __int16 v85 = 0;
    __int16 v86 = v65 & 0xF0FF | ((a6 & 0xF) << 8) | (a16 << 12);
    v76[0] = (float64x2_t)xmmword_2142181C0;
    v76[1] = (float64x2_t)xmmword_2142181D0;
    uint64_t v77 = 0;
    uint64_t v78 = 0;
    RB::Fill::set_image((uint64_t)&v100, (uint64_t)a2, (char *)a3, v76, (uint64_t)v80, a14);
    v101 &= ~0x100u;
    RB::render_primitive((uint64_t)a2, (uint64_t)v76, (uint64_t)v93, (uint64_t)v99, (uint64_t)v80, v74, a8);
    a2[29].i32[0] = 0;
    a2[29].i8[4] = 0;
    RB::Heap::~Heap((RB::Heap *)v87);
  }
}

void sub_2141DE778(_Unwind_Exception *a1)
{
  RB::Heap::~Heap((RB::Heap *)(v1 + 224));
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::LayerTask::add_task(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t result = *a4;
  if (*a4)
  {
    RB::RenderTask::set_parent(result, a1);
    uint64_t v9 = *a4;
    unsigned int v10 = *(_DWORD *)(a1 + 184);
    unsigned int v11 = v10 + 1;
    if (*(_DWORD *)(a1 + 188) < v10 + 1)
    {
      RB::vector<std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>,0ul,unsigned int>::reserve_slow(a1 + 176, v11);
      unsigned int v10 = *(_DWORD *)(a1 + 184);
      uint64_t result = *a4;
      unsigned int v11 = v10 + 1;
    }
    else
    {
      uint64_t result = *a4;
    }
    uint64_t v12 = (void *)(*(void *)(a1 + 176) + 24 * v10);
    *uint64_t v12 = a2;
    v12[1] = a3;
    float32x2_t v12[2] = v9;
    *(_DWORD *)(a1 + 184) = v11;
  }
  return result;
}

uint64_t RB::DisplayList::LayerTask::find_task(RB::DisplayList::LayerTask *this, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = *((unsigned int *)this + 46);
  if (!v3) {
    return 0;
  }
  __n128 v4 = (void *)*((void *)this + 22);
  uint64_t v5 = &v4[3 * v3];
  do
  {
    unint64_t v6 = v3 >> 1;
    int v7 = &v4[3 * (v3 >> 1)];
    if (*v7 >= a2) {
      char v8 = 1;
    }
    else {
      char v8 = -1;
    }
    if (*v7 == a2)
    {
      unint64_t v9 = v7[1];
      BOOL v10 = v9 == a3;
      char v8 = v9 >= a3 ? 1 : -1;
      if (v10) {
        char v8 = 0;
      }
    }
    unsigned int v11 = v7 + 3;
    v3 += ~v6;
    if (v8 < 0) {
      __n128 v4 = v11;
    }
    else {
      unint64_t v3 = v6;
    }
  }
  while (v3);
  if (v4 != v5 && (*v4 == a2 ? (BOOL v12 = v4[1] == a3) : (BOOL v12 = 0), v12)) {
    return v4[2];
  }
  else {
    return 0;
  }
}

void RB::DisplayList::LayerTask::render(int32x2_t *a1, uint64_t a2, int32x2_t *a3, int a4, unsigned int a5, double a6, float a7, double a8, __n128 a9)
{
  if (*(void *)(*(void *)&a1[11] + 16))
  {
    a9.n128_f64[0] = a6;
    float v15 = *(float *)(*(void *)&a1[12] + 48);
    if (v15 == 0.0) {
      float v16 = 1.0;
    }
    else {
      float v16 = 1.0 / v15;
    }
    int32x2_t v17 = a1[15];
    uint32x2_t v18 = (uint32x2_t)vceq_s32(v17, (int32x2_t)0x8000000080000000);
    unsigned __int32 v19 = vpmin_u32(v18, v18).u32[0];
    int8x8_t v20 = (int8x8_t)vdup_n_s32(0x7F7FFFFFu);
    float32x2_t v21 = (float32x2_t)v20;
    float32x2_t v22 = (float32x2_t)0x100000001000000;
    if ((v19 & 0x80000000) == 0)
    {
      float32x2_t v22 = vcvt_f32_s32(a1[14]);
      float32x2_t v21 = vcvt_f32_s32(v17);
    }
    float32x2_t v23 = vmul_n_f32(v22, v16);
    double v37 = *(double *)&v23;
    float32x2_t v38 = vmul_n_f32(v21, v16);
    v23.f32[0] = (float)a9.n128_i32[0];
    float v35 = v16;
    __n128 v36 = a9;
    float32x2_t v24 = RB::Rect::translate((float32x2_t *)&v37, v23, (float)a9.n128_i32[1]);
    v24.i32[0] = 0;
    int32x2_t v25 = vsub_s32(vadd_s32(a1[8], a1[14]), a1[13]);
    int32x2_t v26 = a1[12];
    int v27 = *(unsigned __int8 *)(*(void *)&v26 + 64);
    BOOL v28 = v27 != 1 && v35 == 1.0;
    int32x2_t v29 = a1[15];
    uint32x2_t v30 = (uint32x2_t)vceq_s32(v29, (int32x2_t)0x8000000080000000);
    int8x8_t v31 = (int8x8_t)vdup_lane_s32(vcgt_s32((int32x2_t)v24, (int32x2_t)vpmin_u32(v30, v30)), 0);
    float32x2_t v32 = (float32x2_t)vbsl_s8(v31, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v25));
    float32x2_t v33 = (float32x2_t)vbsl_s8(v31, v20, (int8x8_t)vcvt_f32_s32(v29));
    if (v28) {
      uint64_t v34 = 0;
    }
    else {
      uint64_t v34 = 7;
    }
    RB::DisplayList::Layer::blit(a2, a3, *(int32x2_t **)(*(void *)&a1[11] + 16), v27, (long long **)(*(void *)&v26 + 24), v34, a4, a5, v32, v33, v37, v38, v36, a7, a1[16].i8[0] & 1, (*(unsigned char *)(*(void *)&v26 + 60) >> 5) & 2);
  }
}

void *RB::vector<RB::refcounted_ptr<RB::RenderTask>,8ul,unsigned long>::~vector(void *a1)
{
  uint32x4_t v2 = (void *)a1[8];
  unint64_t v3 = a1[9];
  if (v2) {
    __n128 v4 = v2;
  }
  else {
    __n128 v4 = a1;
  }
  if (v3)
  {
    for (unint64_t i = 0; i < v3; ++i)
    {
      unint64_t v6 = (_DWORD *)v4[i];
      if (v6)
      {
        int v7 = v6[2] - 1;
        float32x4_t v6[2] = v7;
        if (!v7)
        {
          (*(void (**)(_DWORD *))(*(void *)v6 + 8))(v6);
          unint64_t v3 = a1[9];
        }
      }
    }
    uint32x4_t v2 = (void *)a1[8];
  }
  if (v2) {
    free(v2);
  }
  return a1;
}

uint64_t RB::DisplayList::Layer::compute_roi(RB::DisplayList::Layer *this, int32x2_t *a2, int32x2_t *a3, BOOL *a4, __n128 *a5, __n128 a6)
{
  BOOL v10 = 0;
  uint64_t v57 = *MEMORY[0x263EF8340];
  __n128 v52 = 0uLL;
  if (a5 && (*((_DWORD *)this + 15) & 0x2001) != 0)
  {
    a6 = *a5;
    __n128 v52 = *a5;
    BOOL v10 = a5;
  }
  int v11 = *((unsigned __int8 *)this + 64);
  if (v11 == 2)
  {
    a6.n128_u32[0] = 0;
    int32x2_t v15 = a2[1];
    uint32x2_t v16 = (uint32x2_t)vceq_s32(v15, (int32x2_t)0x8000000080000000);
    int8x8_t v17 = (int8x8_t)vdup_lane_s32(vcgt_s32((int32x2_t)a6.n128_u64[0], (int32x2_t)vpmin_u32(v16, v16)), 0);
    *(int8x8_t *)&long long v53 = vbsl_s8(v17, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*a2));
    *((int8x8_t *)&v53 + 1) = vbsl_s8(v17, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v15));
    (*(void (**)(void, long long *))(**((void **)this + 3) + 32))(*((void *)this + 3), &v53);
    RB::Bounds::Bounds((int32x2_t *)&v51, *(float32x2_t *)&v53, *(float32x2_t *)((char *)&v53 + 8));
    a6.n128_u32[1] = DWORD1(v51);
    *(_OWORD *)a2->i8 = v51;
  }
  else
  {
    if (v11 != 1) {
      goto LABEL_12;
    }
    a6.n128_u32[0] = 0;
    int32x2_t v12 = a2[1];
    uint32x2_t v13 = (uint32x2_t)vceq_s32(v12, (int32x2_t)0x8000000080000000);
    int8x8_t v14 = (int8x8_t)vdup_lane_s32(vcgt_s32((int32x2_t)a6.n128_u64[0], (int32x2_t)vpmin_u32(v13, v13)), 0);
    *(int8x8_t *)&long long v53 = vbsl_s8(v14, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*a2));
    *((int8x8_t *)&v53 + 1) = vbsl_s8(v14, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v12));
    if (RB::unapply((float32x2_t *)&v53, *((RB::Rect **)this + 3), (const RB::ProjectionMatrix *)a3))
    {
      RB::Bounds::Bounds((int32x2_t *)&v51, *(float32x2_t *)&v53, *(float32x2_t *)((char *)&v53 + 8));
      a6.n128_u32[1] = DWORD1(v51);
      *(_OWORD *)a2->i8 = v51;
    }
    else
    {
      a6.n128_u64[0] = (unint64_t)vdup_n_s32(0xC0000001);
      *a2 = (int32x2_t)a6.n128_u64[0];
      a2[1] = (int32x2_t)0x8000000080000000;
    }
    BOOL v10 = 0;
  }
  *a4 = 1;
LABEL_12:
  if (*((float *)this + 12) == 0.0) {
    float v18 = 1.0;
  }
  else {
    float v18 = *((float *)this + 12);
  }
  if (v18 != 1.0)
  {
    a6.n128_u32[0] = 0;
    int32x2_t v19 = a2[1];
    uint32x2_t v20 = (uint32x2_t)vceq_s32(v19, (int32x2_t)0x8000000080000000);
    int8x8_t v21 = (int8x8_t)vdup_lane_s32(vcgt_s32((int32x2_t)a6.n128_u64[0], (int32x2_t)vpmin_u32(v20, v20)), 0);
    RB::Bounds::Bounds((int32x2_t *)&v53, vmul_n_f32((float32x2_t)vbsl_s8(v21, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*a2)), v18), vmul_n_f32((float32x2_t)vbsl_s8(v21, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v19)), v18));
    v22.i32[1] = DWORD1(v53);
    *(_OWORD *)a2->i8 = v53;
    if (v10)
    {
      v22.i32[0] = 0;
      uint32x2_t v23 = (uint32x2_t)vceq_s32(*(int32x2_t *)&v52.n128_i8[8], (int32x2_t)0x8000000080000000);
      int8x8_t v24 = (int8x8_t)vdup_lane_s32(vcgt_s32(v22, (int32x2_t)vpmin_u32(v23, v23)), 0);
      float32x2_t v25 = (float32x2_t)vbsl_s8(v24, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v52.n128_i8[8]));
      float32x2_t v26 = (float32x2_t)vbsl_s8(v24, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)v52.n128_u64[0]));
      float v27 = *((float *)this + 12);
      if (v27 == 0.0) {
        float v27 = 1.0;
      }
      RB::Bounds::Bounds((int32x2_t *)&v52, vmul_n_f32(v26, v27), vmul_n_f32(v25, v27));
    }
    *a4 = 1;
  }
  if (v10)
  {
    double v29 = RB::DisplayList::Layer::compute_bounds_(this, (int32x2_t *)&v52);
    *(double *)&long long v51 = v29;
    *((float32x2_t *)&v51 + 1) = v28;
  }
  else
  {
    RB::DisplayList::Layer::compute_bounds(this);
    long long v51 = *((_OWORD *)this + 2);
    float32x2_t v28 = *(float32x2_t *)((char *)&v51 + 8);
    double v29 = *(double *)&v51;
  }
  RB::Bounds::Bounds(v50, *(float32x2_t *)&v29, v28);
  RB::Bounds::intersect(a2, v50[0], v50[1]);
  uint32x2_t v30 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, a2[1]);
  if ((vpmax_u32(v30, v30).u32[0] & 0x80000000) != 0) {
    return 0;
  }
  *(_OWORD *)a3->i8 = *(_OWORD *)a2->i8;
  if (*((void *)this + 2))
  {
    RB::Heap::Heap((RB::Heap *)&v53, v56, 512, 0);
    uint64_t v34 = *((void *)this + 2);
    if (v34)
    {
      float v35 = 0;
      do
      {
        __n128 v36 = (void *)(((unint64_t)v54 + 7) & 0xFFFFFFFFFFFFFFF8);
        if ((unint64_t)(v36 + 4) > v55) {
          __n128 v36 = (void *)RB::Heap::alloc_slow((size_t *)&v53, 0x20uLL, 7);
        }
        else {
          float32x2_t v54 = v36 + 4;
        }
        void *v36 = v34;
        v36[3] = v35;
        uint64_t v34 = *(void *)(v34 + 8);
        float v35 = v36;
      }
      while (v34);
    }
    else
    {
      __n128 v36 = 0;
    }
    v31.i32[0] = 0;
    int32x2_t v38 = a3[1];
    uint32x2_t v39 = (uint32x2_t)vceq_s32(v38, (int32x2_t)0x8000000080000000);
    int8x8_t v40 = (int8x8_t)vdup_lane_s32(vcgt_s32(v31, (int32x2_t)vpmin_u32(v39, v39)), 0);
    int8x8_t v41 = vbsl_s8(v40, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v38));
    int8x8_t v42 = (int8x8_t)vcvt_f32_s32(*a3);
    double v43 = 7.29112205e-304;
    float32x2_t v48 = (float32x2_t)vbsl_s8(v40, (int8x8_t)0x100000001000000, v42);
    float32x2_t v49 = (float32x2_t)v41;
    uint32x2_t v44 = &v51;
    if (v36)
    {
      do
      {
        RB::Rect::intersect(&v48, *(double *)v44, *(float32x2_t *)((char *)v44 + 8), *(double *)&v42, v43, v32, v33);
        RB::Bounds::Bounds(v47, v48, v49);
        RB::Bounds::Union(a2, v47[0], v47[1]);
        (*(void (**)(void, float32x2_t *))(*(void *)*v36 + 48))(*v36, &v48);
        uint32x2_t v44 = (long long *)(*v36 + 16);
        __n128 v36 = (void *)v36[3];
      }
      while (v36);
      double v29 = *(double *)v44;
    }
    RB::Rect::intersect(&v48, v29, *(float32x2_t *)((char *)v44 + 8), *(double *)&v42, v43, v32, v33);
    RB::Bounds::Bounds(v46, v48, v49);
    RB::Bounds::Union(a2, v46[0], v46[1]);
    RB::Heap::~Heap((RB::Heap *)&v53);
  }
  uint32x2_t v45 = (uint32x2_t)vcgtz_s32(a2[1]);
  return vpmin_u32(v45, v45).u32[0] >> 31;
}

void sub_2141DEF3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  RB::Heap::~Heap((RB::Heap *)va);
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::Layer::prepare(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(unsigned char *)(result + 64) == 2) {
    uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(result + 24) + 120))(*(void *)(result + 24), a2);
  }
  for (unint64_t i = *(void **)(v3 + 16); i; unint64_t i = (void *)i[1])
    uint64_t result = (*(uint64_t (**)(void *, uint64_t))(*i + 96))(i, a2);
  return result;
}

__n128 RB::Heap::emplace<RB::DisplayList::SpillItem,RB::Shader::SpillMode,unsigned int &,int,RB::BlendMode,RB::Bounds &,decltype(nullptr)>(RB::Heap *this, int *a2, int *a3, int *a4, _WORD *a5, __n128 *a6)
{
  unint64_t v12 = *((void *)this + 3);
  unint64_t v13 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v13 + 80 > v12) {
    unint64_t v13 = RB::Heap::alloc_slow((size_t *)this, 0x50uLL, 7);
  }
  else {
    *((void *)this + 2) = v13 + 80;
  }
  int v14 = *a2;
  int v15 = *a3;
  _S0 = (float)*a4;
  char v17 = *a5;
  __asm { FCVT            H0, S0 }
  *(void *)(v13 + 16) = 0;
  *(void *)(v13 + 24) = 0;
  *(_DWORD *)(v13 + 40) = 0;
  *(void *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 44) = LOWORD(_S0);
  *(_WORD *)(v13 + 46) = v17 & 0x3F;
  *(void *)unint64_t v13 = &unk_26C4E7FF0;
  __n128 result = *a6;
  *(__n128 *)(v13 + 48) = *a6;
  *(_DWORD *)(v13 + 64) = v14;
  *(_DWORD *)(v13 + 68) = v15;
  *(void *)(v13 + 72) = 0;
  return result;
}

__n128 _ZN2RB4Heap7emplaceINS_11DisplayList9SpillItemEJNS_6Shader9SpillModeERjRKDF16_RKNS_9BlendModeERNS_6BoundsERPNS2_11LayerFilterEEEEPT_DpOT0_(RB::Heap *this, int *a2, int *a3, __int16 *a4, _WORD *a5, __n128 *a6, uint64_t *a7)
{
  unint64_t v14 = *((void *)this + 3);
  unint64_t v15 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 80 > v14) {
    unint64_t v15 = RB::Heap::alloc_slow((size_t *)this, 0x50uLL, 7);
  }
  else {
    *((void *)this + 2) = v15 + 80;
  }
  int v16 = *a2;
  int v17 = *a3;
  __int16 v18 = *a4;
  char v19 = *a5;
  uint64_t v20 = *a7;
  *(void *)(v15 + 16) = 0;
  *(void *)(v15 + 24) = 0;
  *(_DWORD *)(v15 + 40) = 0;
  *(void *)(v15 + 32) = 0;
  *(_WORD *)(v15 + 44) = v18;
  *(_WORD *)(v15 + 46) = v19 & 0x3F;
  *(void *)unint64_t v15 = &unk_26C4E7FF0;
  __n128 result = *a6;
  *(__n128 *)(v15 + 48) = *a6;
  *(_DWORD *)(v15 + 64) = v16;
  *(_DWORD *)(v15 + 68) = v17;
  *(void *)(v15 + 72) = v20;
  return result;
}

void *_ZZNK2RB11DisplayList5Layer9make_taskERNS0_11RenderStateENS_6BoundsEPKS4_jPKNS0_4ItemEPKDv4_fENK3__2clES9_(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  unint64_t v5 = *(void *)(*a1 + 104);
  __n128 result = (void *)((*(void *)(*a1 + 96) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > v5) {
    __n128 result = (void *)RB::Heap::alloc_slow((size_t *)(v4 + 80), 0x10uLL, 7);
  }
  else {
    *(void *)(v4 + 96) = result + 2;
  }
  void *result = 0;
  result[1] = a2;
  **(void **)a1[1] = result;
  *(void *)a1[1] = result;
  ++*(_DWORD *)a1[2];
  return result;
}

void *RB::DisplayList::LayerTask::append_task(void *result, uint64_t a2, void **a3, unsigned int *a4)
{
  uint64_t v5 = (uint64_t)result;
  unsigned int v6 = *a4;
  **a3 = *(void *)(a2 + 160);
  int v7 = *(void **)(a2 + 160);
  if (v7)
  {
    unsigned int v8 = v6;
    do
    {
      *a3 = v7;
      ++v8;
      int v7 = (void *)*v7;
    }
    while (v7);
    *a4 = v8;
  }
  unsigned int v9 = *(_DWORD *)(a2 + 184);
  if (v9)
  {
    uint64_t v10 = *(void *)(a2 + 32);
    *(void *)(a2 + 32) = 0;
    if (v10)
    {
      do
      {
        *(void *)(v10 + 16) = 0;
        uint64_t v11 = *(void *)(v10 + 40);
        *(void *)(v10 + 40) = 0;
        __n128 result = RB::RenderTask::set_parent(v10, v5);
        int v12 = *(_DWORD *)(v10 + 8) - 1;
        *(_DWORD *)(v10 + 8) = v12;
        if (!v12) {
          __n128 result = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v10 + 8))(v10);
        }
        uint64_t v10 = v11;
      }
      while (v11);
      unsigned int v9 = *(_DWORD *)(a2 + 184);
    }
    unsigned int v13 = v9 + *(_DWORD *)(v5 + 184);
    if (*(_DWORD *)(v5 + 188) < v13)
    {
      __n128 result = RB::vector<std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>,0ul,unsigned int>::reserve_slow(v5 + 176, v13);
      unsigned int v9 = *(_DWORD *)(a2 + 184);
      if (!v9) {
        goto LABEL_19;
      }
    }
    else if (!v9)
    {
      goto LABEL_19;
    }
    unint64_t v14 = *(long long **)(a2 + 176);
    uint64_t v15 = v9;
    unsigned int v16 = *(_DWORD *)(v5 + 184);
    uint64_t v17 = 24 * v15;
    do
    {
      if (*(_DWORD *)(v5 + 188) < v16 + 1)
      {
        __n128 result = RB::vector<std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>,0ul,unsigned int>::reserve_slow(v5 + 176, v16 + 1);
        unsigned int v16 = *(_DWORD *)(v5 + 184);
      }
      uint64_t v18 = *(void *)(v5 + 176) + 24 * v16;
      long long v19 = *v14;
      *(void *)(v18 + 16) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v18 = v19;
      unsigned int v16 = *(_DWORD *)(v5 + 184) + 1;
      *(_DWORD *)(v5 + 184) = v16;
      unint64_t v14 = (long long *)((char *)v14 + 24);
      v17 -= 24;
    }
    while (v17);
  }
LABEL_19:
  int v20 = *(_DWORD *)(v5 + 216);
  unsigned int v21 = *(_DWORD *)(a2 + 200) + *(_DWORD *)(v5 + 200);
  if (*(_DWORD *)(v5 + 204) < v21) {
    __n128 result = RB::vector<RBColor,0ul,unsigned int>::reserve_slow(v5 + 192, v21);
  }
  unsigned int v22 = *(_DWORD *)(a2 + 216) + v20;
  if (*(_DWORD *)(v5 + 220) < v22) {
    __n128 result = RB::vector<RB::DisplayList::LayerTask::ClipInfo,0ul,unsigned int>::reserve_slow(v5 + 208, v22);
  }
  uint64_t v23 = *(unsigned int *)(a2 + 200);
  if (v23)
  {
    int8x8_t v24 = *(uint64_t **)(a2 + 192);
    float32x2_t v25 = &v24[2 * v23];
    unsigned int v26 = *(_DWORD *)(v5 + 200);
    do
    {
      uint64_t v27 = *v24;
      int v28 = *((_DWORD *)v24 + 2);
      unsigned int v29 = v26 + 1;
      if (*(_DWORD *)(v5 + 204) < v26 + 1)
      {
        __n128 result = RB::vector<RBColor,0ul,unsigned int>::reserve_slow(v5 + 192, v29);
        unsigned int v26 = *(_DWORD *)(v5 + 200);
        unsigned int v29 = v26 + 1;
      }
      uint64_t v30 = *(void *)(v5 + 192) + 16 * v26;
      *(void *)uint64_t v30 = v27;
      *(_DWORD *)(v30 + 8) = v28 + v20;
      *(_DWORD *)(v5 + 200) = v29;
      v24 += 2;
      unsigned int v26 = v29;
    }
    while (v24 != v25);
  }
  uint64_t v31 = *(unsigned int *)(a2 + 216);
  if (v31)
  {
    double v32 = *(long long **)(a2 + 208);
    unsigned int v33 = *(_DWORD *)(v5 + 216);
    int32x2_t v34 = vdup_n_s32(v6);
    uint64_t v35 = 48 * v31;
    do
    {
      if (*(_DWORD *)(v5 + 220) < v33 + 1)
      {
        __n128 result = RB::vector<RB::DisplayList::LayerTask::ClipInfo,0ul,unsigned int>::reserve_slow(v5 + 208, v33 + 1);
        unsigned int v33 = *(_DWORD *)(v5 + 216);
      }
      __n128 v36 = (_OWORD *)(*(void *)(v5 + 208) + 48 * v33);
      long long v37 = *v32;
      long long v38 = v32[2];
      v36[1] = v32[1];
      void v36[2] = v38;
      _OWORD *v36 = v37;
      unsigned int v39 = *(_DWORD *)(v5 + 216);
      unsigned int v33 = v39 + 1;
      *(_DWORD *)(v5 + 216) = v39 + 1;
      uint64_t v40 = *(void *)(v5 + 208) + 48 * v39;
      *(int32x2_t *)(v40 + 36) = vadd_s32(*(int32x2_t *)(v40 + 36), v34);
      v32 += 3;
      v35 -= 48;
    }
    while (v35);
  }
  if ((*(unsigned char *)(v5 + 128) & 0x10) != 0) {
    char v41 = 16;
  }
  else {
    char v41 = *(unsigned char *)(a2 + 128) & 0x10;
  }
  *(unsigned char *)(v5 + 128) = v41 | *(unsigned char *)(v5 + 128) & 0xEF;
  return result;
}

void sub_2141DF4FC(_Unwind_Exception *a1)
{
  if (v2) {
    RB::DisplayList::LayerTask::append_task(v2);
  }
  RB::DisplayList::LayerTask::append_task(v1);
  _Unwind_Resume(a1);
}

void RB::DisplayList::LayerTask::make_texture(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>, double a4@<D0>)
{
  double v6 = a4;
  _ZN2RB4Heap7emplaceINS_11DisplayList13PackedTextureEJRK14MTLPixelFormatRKNS_10ColorSpaceERDv2_iEEEPT_DpOT0_((RB::Heap *)(a2 + 80), (uint64_t *)(a1 + 80), (char *)(a1 + 72), &v6);
  *a3 = v5;
}

double _ZN2RB4Heap7emplaceINS_11DisplayList13PackedTextureEJRK14MTLPixelFormatRKNS_10ColorSpaceERDv2_iEEEPT_DpOT0_(RB::Heap *this, uint64_t *a2, char *a3, double *a4)
{
  unint64_t v8 = *((void *)this + 3);
  unint64_t v9 = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v9 + 56 > v8) {
    unint64_t v9 = RB::Heap::alloc_slow((size_t *)this, 0x38uLL, 7);
  }
  else {
    *((void *)this + 2) = v9 + 56;
  }
  uint64_t v10 = *a2;
  char v11 = *a3;
  double result = *a4;
  *(_DWORD *)(v9 + 8) = 1;
  *(void *)(v9 + 16) = 0;
  *(void *)(v9 + 24) = 0;
  *(void *)unint64_t v9 = &unk_26C4EC0E0;
  *(void *)(v9 + 32) = v10;
  *(unsigned char *)(v9 + 40) = v11;
  *(double *)(v9 + 48) = result;
  return result;
}

void RB::DisplayList::LayerTask::postprocess(int32x2_t *this, int32x2_t *a2, RB::Filter::RenderGroup *a3, void *a4)
{
  a4[4] = this;
  int32x2_t v7 = this[13];
  int32x2_t v9 = this[7];
  int32x2_t v8 = this[8];
  a2[20] = v8;
  a2[21] = v9;
  uint64_t v10 = (void *)this[21];
  if (v10)
  {
    double v12 = COERCE_DOUBLE(vsub_s32(v8, v7));
    while (1)
    {
      *((void *)a3 + 4) = v10;
      (*(void (**)(void *, void *, int32x2_t *, RB::Filter::RenderGroup *, double))(*v10 + 104))(v10, a4, a2, a3, v12);
      *((void *)a3 + 4) = 0;
      *(float *)v7.i32 = *(float *)a2[15].i32 + 1.0;
      a2[15].i32[0] = v7.i32[0];
      uint64_t v13 = *((void *)a3 + 2);
      if (v13)
      {
        if (*(void **)(*((void *)a3 + 1) + 56 * v13 - 56) == v10) {
          break;
        }
      }
      uint64_t v10 = (void *)v10[1];
      if (!v10) {
        goto LABEL_6;
      }
    }
    this[21] = (int32x2_t)v10[1];
    this[9].i8[2] = 1;
    a4[4] = 0;
  }
  else
  {
LABEL_6:
    this[21] = 0;
    a4[4] = 0;
    if ((this[16].i8[0] & 4) != 0)
    {
      RB::RenderPass::resolve_srgb_alpha((RB::RenderPass *)a2, v7);
      this[16].i8[0] &= ~4u;
    }
  }
}

uint64_t RB::DisplayList::LayerItem::prepare(uint64_t a1, uint64_t a2)
{
  return RB::DisplayList::Layer::prepare(*(void *)(a1 + 48), a2);
}

void RB::DisplayList::LayerItem::render(unint64_t a1, uint64_t a2, int32x2_t *a3, int a4, unsigned int a5, double a6)
{
  uint64_t v10 = *(RB::DisplayList::LayerTask **)(a2 + 32);
  if (v10)
  {
    tasunint64_t k = (int32x2_t *)RB::DisplayList::LayerTask::find_task(v10, a1, 0);
    if (task)
    {
      _H0 = *(_WORD *)(a1 + 44);
      __asm { FCVT            S1, H0 }
      RB::DisplayList::LayerTask::render(task, a2, a3, a4, a5, a6, _S1, v14, v15);
      return;
    }
    uint64_t v23 = *(void *)(a1 + 48);
    if (*(unsigned char *)(v23 + 64) == 2)
    {
      _H0 = *(_WORD *)(a1 + 44);
      __asm { FCVT            S5, H0 }
      v16.n128_f64[0] = a6;
      RB::DisplayList::Layer::blit(a2, a3, 0, 2, (long long **)(v23 + 24), 0, a4, a5, 0, 0, 0.0, 0, v16, _S5, 0, (*(unsigned char *)(v23 + 60) >> 5) & 2);
      return;
    }
  }
  if ((RB::may_discard_alpha(a5) & 1) == 0)
  {
    v26.i32[0] = 0;
    int32x2_t v27 = a3[21];
    uint32x2_t v28 = (uint32x2_t)vceq_s32(v27, (int32x2_t)0x8000000080000000);
    int8x8_t v29 = (int8x8_t)vdup_lane_s32(vcgt_s32(v26, (int32x2_t)vpmin_u32(v28, v28)), 0);
    v33[0] = vbsl_s8(v29, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a3[20]));
    v33[1] = vbsl_s8(v29, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v27));
    Point v33[2] = 0;
    float64x2_t v33[3] = 0;
    void v33[4] = 1065353216;
    int v34 = 0;
    __int16 v35 = 257;
    char v36 = 0;
    v30[0] = xmmword_2142181C0;
    v30[1] = xmmword_2142181D0;
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    v29.i16[0] = *(_WORD *)(a1 + 44);
    int v37 = 0;
    __int16 v38 = 0;
    short float v39 = *(short float *)v29.i16 * COERCE_SHORT_FLOAT(0);
    __int16 v40 = 0;
    RB::render_primitive((uint64_t)a3, (uint64_t)v30, (uint64_t)v33, (uint64_t)&v37, a4, a5);
  }
}

uint64_t RB::DisplayList::LayerClip::prepare(uint64_t a1, uint64_t a2)
{
  return RB::DisplayList::Layer::prepare(*(void *)(a1 + 48), a2);
}

void RB::DisplayList::LayerClip::render()
{
}

uint64_t RB::DisplayList::BackdropColorMatrixItem::render(uint64_t a1, uint64_t a2, MTLPixelFormat a3, int a4, int a5)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(unsigned char **)(a1 + 48);
  if (!v10)
  {
    MEMORY[0x270FA5388](a1, a2);
    uint64_t v10 = v18;
    memset(v18, 0, 48);
    RB::ColorMatrix::set_identity((RB::ColorMatrix *)&v18[8]);
  }
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  return RB::Filter::ColorMatrix::render((uint64_t)v10, a3, a2, a5, a4, _S0);
}

uint64_t RB::DisplayList::ItemClip::prepare(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 168))();
}

uint64_t RB::DisplayList::ItemClip::render(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void, uint64_t))(**(void **)(a1 + 48) + 176))(*(void *)(a1 + 48), a2, a3, 0, a4);
}

unsigned __int8 *RB::DisplayList::CustomItem::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, int a5, char a6)
{
  uint64_t v8 = 39;
  if (*(_DWORD *)(a4 + 136) == 2) {
    uint64_t v8 = 131111;
  }
  uint64_t v9 = a6 & 0x3F;
  uint64_t v10 = 0x10000;
  if (!a5) {
    uint64_t v10 = 0;
  }
  uint64_t v11 = v10 | v8;
  double v12 = *(float64x2_t **)(a1 + 56);
  v13.i64[0] = SLODWORD(a2);
  v13.i64[1] = SHIDWORD(a2);
  float64x2_t v15 = v12[1];
  float64x2_t v16 = vaddq_f64(v12[2], vcvtq_f64_s64(v13));
  v27[0] = *v12;
  v14.i64[1] = *(void *)&v27[0].f64[1];
  v27[1] = v15;
  v27[2] = v16;
  v14.i64[0] = *(void *)(a1 + 72);
  float32x2_t v17 = RB::operator*(v27, *(float32x2_t *)(a1 + 64), v14);
  RB::Bounds::Bounds(v26, v17, v18);
  _H2 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S2, H2 }
  return RB::RenderPass::draw_custom(a4, (const char *)(v11 | (v9 << 32)), *(void *)(a1 + 48), v27, *(_DWORD *)(a1 + 80), v26[0], v26[1], _S2);
}

int32x2_t *RB::DisplayList::SpillItem::render(int32x2_t *a1, uint64_t a2, RB::RenderPass *this, int a4, char a5, int32x2_t a6)
{
  __int32 v12 = a1[8].i32[0];
  if (v12 == 2)
  {
    int64x2_t v13 = (void *)a1[9];
    if (v13)
    {
      v35[0] = (void *)a2;
      v35[1] = 0;
      long long v36 = 0uLL;
      do
      {
        (*(void (**)(void *, uint64_t))(*v13 + 96))(v13, a2);
        (*(void (**)(void *, uint64_t, RB::RenderPass *, void **, double))(*v13 + 104))(v13, a2, this, v35, *(double *)&a6);
        int64x2_t v13 = (void *)v13[1];
      }
      while (v13);
      int32x4_t v14 = v35[1];
      unint64_t v15 = v36;
      if ((void)v36)
      {
        unint64_t v16 = 0;
        float32x2_t v17 = (uint64_t *)((char *)v35[1] + 8);
        do
        {
          uint64_t v18 = *v17;
          *float32x2_t v17 = 0;
          if (v18)
          {
            (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
            unint64_t v15 = v36;
          }
          ++v16;
          v17 += 7;
        }
        while (v16 < v15);
        int32x4_t v14 = v35[1];
      }
      if (v14) {
        free(v14);
      }
    }
    RB::RenderPass::pop_layer((uint64_t)this);
  }
  else
  {
    RB::RenderPass::push_layer((uint64_t)this);
  }
  v19.i32[0] = 0;
  int32x2_t v20 = a1[7];
  int32x2_t v21 = vadd_s32(a1[6], a6);
  uint32x2_t v22 = (uint32x2_t)vceq_s32(v20, (int32x2_t)0x8000000080000000);
  int8x8_t v23 = (int8x8_t)vdup_lane_s32(vcgt_s32(v19, (int32x2_t)vpmin_u32(v22, v22)), 0);
  RB::Coverage::set_plane((float32x2_t *)v35, (float32x2_t *)this, (float32x2_t)vbsl_s8(v23, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v21)), COERCE_DOUBLE(vbsl_s8(v23, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v20))));
  int v24 = 0;
  WORD6(v36) = a1[5].i16[2];
  if (v12 == 2) {
    int v24 = ((unsigned __int32)a1[8].i32[1] >> 4) & 4;
  }
  int v25 = v24 | a1[8].i32[0] & 3;
  if (*((_DWORD *)this + 34) == 2) {
    int v26 = 131108;
  }
  else {
    int v26 = 36;
  }
  int v27 = v26 | (v25 << 20);
  uint64_t v28 = a5 & 0x3F;
  if (a4) {
    int v29 = 0x10000;
  }
  else {
    int v29 = 0;
  }
  uint64_t v30 = v27 | v29;
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)this, (RB::Device *)0x20, 4uLL, 0, &v37);
  uint64_t v31 = v37;
  if (v37)
  {
    uint64_t v32 = (_OWORD *)(*((void *)v37 + 7) + v38.i64[0]);
    long long v33 = v36;
    *uint64_t v32 = *(_OWORD *)v35;
    v32[1] = v33;
  }
  else
  {
    int v37 = 0;
    int64x2_t v38 = 0uLL;
  }
  *((_DWORD *)this + 46) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)this, v31);
  *(int32x2_t *)((char *)this + 188) = vmovn_s64(v38);
  double result = RB::RenderPass::draw_indexed_primitives((int32x2_t *)this, (const char *)(v30 | (v28 << 32)), 4, ***(void ***)this + 80, 0, 1uLL, v21, v20);
  if (v12 != 2) {
    return RB::Bounds::intersect((int32x2_t *)(a2 + 56), a1[6], a1[7]);
  }
  *(_OWORD *)(a2 + 56) = *(_OWORD *)(a2 + 40);
  return result;
}

void sub_2141DFD9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void RB::DisplayList::SpillItem::print(RB::DisplayList::SpillItem *this, std::string *a2)
{
  RB::SexpString::push(a2, "spill");
  int v4 = *((_DWORD *)this + 16);
  uint64_t v5 = "unspill";
  if (v4 == 1) {
    uint64_t v5 = "spill-copy";
  }
  if (v4) {
    double v6 = v5;
  }
  else {
    double v6 = "spill-clear";
  }
  RB::SexpString::printf(a2, 0, "(mode %s)", v6);
  RB::DisplayList::Item::print(this, a2);
  RB::SexpString::pop(a2);
}

void *RB::Filter::RenderGroup::add_multipass_renderer(void *result, uint64_t a2, uint64_t a3, char a4, char a5, double a6, double a7)
{
  __int32 v12 = result;
  uint64_t v13 = *(void *)(a2 + 160);
  uint64_t v14 = *(void *)(a2 + 168);
  uint64_t v15 = result[2];
  if (result[3] < (unint64_t)(v15 + 1))
  {
    double result = RB::vector<RB::Filter::RenderGroup::MultipassInfo,0ul,unsigned long>::reserve_slow((uint64_t)(result + 1), v15 + 1);
    uint64_t v15 = v12[2];
  }
  uint64_t v16 = v12[1] + 56 * v15;
  *(void *)uint64_t v16 = v12[4];
  *(void *)(v16 + 8) = a3;
  *(double *)(v16 + 16) = a6;
  *(void *)(v16 + 24) = v13;
  *(void *)(v16 + 32) = v14;
  *(double *)(v16 + 40) = a7;
  *(unsigned char *)(v16 + 48) = a4;
  *(unsigned char *)(v16 + 49) = a5;
  *(unsigned char *)(v16 + 50) = 0;
  ++v12[2];
  return result;
}

void RB::Filter::RenderGroup::resolve(RB::Filter::RenderGroup *this, RB::RenderPass *a2)
{
  uint64_t v91 = *MEMORY[0x263EF8340];
  if (*((void *)this + 2))
  {
    RB::BinPacker::BinPacker((RB::BinPacker *)v89, *((void *)a2 + 13), HIDWORD(*((void *)a2 + 13)));
    uint64_t v5 = *((void *)this + 2);
    if (v5)
    {
      uint64_t v6 = *((void *)this + 1);
      uint64_t v7 = 56 * v5;
      do
      {
        RB::BinPacker::add((uint64_t)v89, *(void *)(v6 + 40), HIDWORD(*(void *)(v6 + 40)), (void *)v6, *(unsigned __int8 *)(v6 + 48));
        v6 += 56;
        v7 -= 56;
      }
      while (v7);
    }
    RB::BinPacker::pack((RB::BinPacker *)v89, v4);
    uint64_t v10 = v90;
    if (v90)
    {
      uint64_t v11 = *((void *)a2 + 20);
      uint64_t v12 = *((void *)a2 + 21);
      float32x2_t v80 = (char *)a2 + 8;
      int v13 = *((unsigned __int8 *)a2 + 124);
      unint64_t v14 = *((void *)a2 + 2);
      uint64_t v15 = a2;
      long long v81 = (char *)a2 + 8;
      MTLPixelFormat v82 = MTLPixelFormatInvalid;
      __int16 v85 = (char *)a2 + 8;
      __int16 v86 = (RB *)v14;
      int v83 = 0;
      int v84 = v13;
      while (1)
      {
        unsigned __int8 v16 = *(unsigned char *)(v10 + 8);
        float32x2_t v17 = *(RB::RenderParams **)a2;
        if ((*(unsigned char *)(*(void *)a2 + 31) & 8) != 0 || *((unsigned __int8 *)a2 + 124) == v16)
        {
          if (v15 != a2) {
            RB::RenderPass::~RenderPass(v15);
          }
          uint32x2_t v22 = (RB *)v14;
          uint64_t v15 = a2;
        }
        else
        {
          uint64_t v18 = RB::pixel_format_traits(v14, v8);
          int32x2_t v20 = (unsigned int *)((char *)v18 + 18);
          if (v16) {
            int32x2_t v20 = v18 + 6;
          }
          int32x2_t v21 = (RB *)*v20;
          if (v21) {
            uint32x2_t v22 = v21;
          }
          else {
            uint32x2_t v22 = (RB *)v14;
          }
          int v23 = RB::RenderParams::srgb_alpha(v17, v19);
          int v25 = RB::pixel_format_traits((unint64_t)v22, v24);
          if (v22 == (RB *)v14)
          {
            for (uint64_t i = *(void *)(v10 + 16); i; uint64_t i = *(void *)(i + 40))
            {
              int v27 = *(int32x2_t **)(i + 16);
              int32x2_t v28 = v27[3];
              int32x2_t v29 = v27[4];
              *((int32x2_t *)a2 + 20) = v28;
              *((int32x2_t *)a2 + 21) = v29;
              if (v23) {
                BOOL v30 = (v27[6].i8[1] & 1) == 0;
              }
              else {
                BOOL v30 = 0;
              }
              RB::RenderPass::color_convert((uint64_t)a2, *((unsigned __int8 *)a2 + 124), v16, v30, v28);
            }
            RB::RenderPass::set_color_space((id ***)a2, v16);
            uint32x2_t v22 = v86;
          }
          else
          {
            uint64_t v31 = *((unsigned __int16 *)v25 + 2);
            uint64_t v32 = *v25;
            if (v82 == MTLPixelFormatInvalid || *(RB **)(v82 + 56) != v22)
            {
              RB::Device::alloc_shared_texture_view(***(void ***)a2, *((MTLPixelFormat *)a2 + 1), v22, v16, v87);
              MTLPixelFormat v33 = v87[0];
              MTLPixelFormat v34 = v82;
              v87[0] = v82;
              if (v82)
              {
                int v35 = *(_DWORD *)(v82 + 8) - 1;
                *(_DWORD *)(v82 + 8) = v35;
                if (!v35) {
                  (*(void (**)(MTLPixelFormat))(*(void *)v34 + 8))(v34);
                }
              }
              if (v33 == MTLPixelFormatInvalid) {
                break;
              }
              BOOL v36 = v23 == (((v32 | (unint64_t)(v31 << 32)) >> 36) & 1);
              int v37 = v80;
              int v13 = v84;
              if (!v36)
              {
                for (uint64_t j = *(void *)(v10 + 16); j; uint64_t j = *(void *)(j + 40))
                {
                  short float v39 = *(int32x2_t **)(j + 16);
                  if ((v39[6].i8[1] & 1) == 0)
                  {
                    int32x2_t v40 = v39[3];
                    int32x2_t v41 = v39[4];
                    *((int32x2_t *)a2 + 20) = v40;
                    *((int32x2_t *)a2 + 21) = v41;
                    RB::RenderPass::resolve_srgb_alpha(a2, v40);
                  }
                }
                int v83 = 1;
              }
              if (v15 == a2)
              {
                RB::RenderFrame::flush_pass(**(id ***)a2, a2, 1);
                MEMORY[0x270FA5388](v42, v43);
                uint64_t v15 = (RB::RenderPass *)(&v79 - 34);
                *(&v79 - 2) = 0;
                *((_OWORD *)&v79 - 3) = 0u;
                *((_OWORD *)&v79 - 2) = 0u;
                *((_OWORD *)&v79 - 5) = 0u;
                *((_OWORD *)&v79 - 4) = 0u;
                *((_OWORD *)&v79 - 7) = 0u;
                *((_OWORD *)&v79 - 6) = 0u;
                *((_OWORD *)&v79 - 9) = 0u;
                *((_OWORD *)&v79 - 8) = 0u;
                *((_OWORD *)&v79 - 11) = 0u;
                *((_OWORD *)&v79 - 10) = 0u;
                *((_OWORD *)&v79 - 13) = 0u;
                *((_OWORD *)&v79 - 12) = 0u;
                *((_OWORD *)&v79 - 15) = 0u;
                *((_OWORD *)&v79 - 14) = 0u;
                *((_OWORD *)&v79 - 16) = 0u;
                *((_OWORD *)&v79 - 17) = 0u;
              }
              else
              {
                RB::RenderPass::~RenderPass(v15);
              }
              RB::RenderPass::RenderPass(v15, *(void *)a2, v33, 0, 1, 0);
              uint64_t v45 = 0;
              char v46 = 1;
              do
              {
                char v47 = v46;
                MTLPixelFormat v48 = *((int *)&RB::Filter::RenderGroup::resolve(RB::RenderPass &)::aux_attachments + v45);
                float32x2_t v49 = *(RB::Resource **)&v37[24 * (int)v48];
                if (v49) {
                  RB::RenderPass::set_attachment((uint64_t **)v15, v48, v49, 0, 0);
                }
                char v46 = 0;
                uint64_t v45 = 1;
              }
              while ((v47 & 1) != 0);
              RB::RenderPass::set_extra_attachments((uint64_t)v15, (MTLPixelFormat)(v81 & 0xF0), v44);
              long long v81 = (char *)(v81 & 0xFFFFFFF0);
              MTLPixelFormat v82 = v33;
              goto LABEL_45;
            }
          }
          int v13 = v84;
        }
LABEL_45:
        v9.n128_u64[0] = *(void *)v10;
        __n128 v9 = RB::Device::alloc_shared_texture((void *)***(void ***)a2, v22, 1u, v16, 1, &v88, v9);
        if (v88)
        {
          v50.n128_f64[0] = RB::RenderPass::RenderPass(v87, *(void *)a2, v88, 0, 1, 0);
          int v51 = (int)v85;
          RB::RenderPass::set_extra_attachments((uint64_t)v87, (MTLPixelFormat)(v85 & 0xF0), v50);
          uint64_t v52 = 0;
          __int16 v85 = (char *)(v51 & 0xFFFFFFF0);
          long long v53 = v87;
          float32x2_t v54 = v15;
          do
          {
            unint64_t v55 = v53;
            RB::RenderFrame::flush_pass(**(id ***)a2, v54, 1);
            if (v52) {
              float32x2_t v56 = @"RB: Packed filters [odd]";
            }
            else {
              float32x2_t v56 = @"RB: Packed filters [even]";
            }
            RB::RenderPass::set_label((id *)v55, &v56->isa);
            float32x2_t v59 = *(uint64_t **)(v10 + 16);
            if (!v59) {
              break;
            }
            char v60 = 0;
            do
            {
              uint64_t v61 = v59[2];
              if (!*(unsigned char *)(v61 + 50))
              {
                v58.n128_u64[0] = v59[4];
                if (v55 == (MTLPixelFormat *)v15)
                {
                  unint64_t v62 = *(void *)(v61 + 24);
                  float32x2_t v63 = (uint64_t *)(v61 + 32);
                  v57.n128_u64[0] = *(void *)(v61 + 16);
                }
                else
                {
                  unint64_t v62 = v59[4];
                  float32x2_t v63 = v59;
                  v57.n128_u64[0] = v62;
                  v58.n128_u64[0] = *(void *)(v61 + 16);
                }
                uint64_t v64 = *v63;
                *((void *)v55 + 20) = v62;
                *((void *)v55 + 21) = v64;
                char v65 = (*(uint64_t (**)(void, MTLPixelFormat *, uint64_t, void, __n128, __n128))(**(void **)(v61 + 8) + 16))(*(void *)(v61 + 8), v55, v52, *((void *)v54 + 1), v57, v58);
                *(unsigned char *)(v61 + 50) = v65;
                *((float *)v55 + 30) = *((float *)v55 + 30) + 1.0;
                char v60 = v60 & 1 | ((v65 & 1) == 0);
              }
              float32x2_t v59 = (uint64_t *)v59[5];
            }
            while (v59);
            uint64_t v52 = (v52 + 1);
            long long v53 = (MTLPixelFormat *)v54;
            float32x2_t v54 = (RB::RenderPass *)v55;
          }
          while ((v60 & 1) != 0);
          RB::RenderPass::~RenderPass((RB::RenderPass *)v87);
          int v13 = v84;
        }
        if (v83)
        {
          for (uint64_t k = *(void *)(v10 + 16); k; uint64_t k = *(void *)(k + 40))
          {
            long long v67 = *(int32x2_t **)(k + 16);
            if ((v67[6].i8[1] & 1) == 0)
            {
              int32x2_t v68 = v67[3];
              int32x2_t v69 = v67[4];
              *((int32x2_t *)v15 + 20) = v68;
              *((int32x2_t *)v15 + 21) = v69;
              v9.n128_f32[0] = RB::RenderPass::resolve_srgb_alpha(v15, v68);
            }
          }
        }
        else if (*((unsigned __int8 *)a2 + 124) != v13)
        {
          for (uint64_t m = *(void *)(v10 + 16); m; uint64_t m = *(void *)(m + 40))
          {
            int32x4_t v71 = *(int32x2_t **)(m + 16);
            int32x2_t v72 = v71[3];
            int32x2_t v73 = v71[4];
            *((int32x2_t *)a2 + 20) = v72;
            *((int32x2_t *)a2 + 21) = v73;
            int v74 = (*(unsigned char *)(*(void *)a2 + 31) & 1) != 0 && (v71[6].i8[1] & 1) == 0;
            RB::RenderPass::color_convert((uint64_t)a2, *((unsigned __int8 *)a2 + 124), v13, v74, v72);
          }
          RB::RenderPass::set_color_space((id ***)a2, v13);
        }
        int32x4_t v75 = v88;
        if (v88)
        {
          __int32 v76 = v88[1].i32[0] - 1;
          v88[1].i32[0] = v76;
          if (!v76) {
            (*(void (**)(int32x2_t *, __n128))(*(void *)v75 + 8))(v75, v9);
          }
        }
        uint64_t v10 = *(void *)(v10 + 24);
        unint64_t v14 = (unint64_t)v86;
        if (!v10)
        {
          if (v15 != a2) {
            RB::RenderPass::~RenderPass(v15);
          }
          *((void *)a2 + 20) = v11;
          *((void *)a2 + 21) = v12;
          MTLPixelFormat v77 = v82;
          if (v82)
          {
            int v78 = *(_DWORD *)(v82 + 8) - 1;
            *(_DWORD *)(v82 + 8) = v78;
            if (!v78) {
              (*(void (**)(MTLPixelFormat))(*(void *)v77 + 8))(v77);
            }
          }
          break;
        }
      }
    }
    RB::Heap::~Heap((RB::Heap *)v89);
  }
}

void sub_2141E0548(_Unwind_Exception *a1)
{
  RB::Heap::~Heap((RB::Heap *)(v1 + 328));
  _Unwind_Resume(a1);
}

_DWORD *RB::Refcount<RB::RenderTask,unsigned int>::release(_DWORD *result)
{
  int v1 = result[2] - 1;
  result[2] = v1;
  if (!v1) {
    return (_DWORD *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

_DWORD *RB::Refcount<RB::RenderTaskTexture,unsigned int>::release(_DWORD *result)
{
  int v1 = result[2] - 1;
  result[2] = v1;
  if (!v1) {
    return (_DWORD *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void RB::DisplayList::RootTexture::~RootTexture(RB::DisplayList::RootTexture *this)
{
  *(void *)this = &unk_26C4ED180;
  int v1 = (_DWORD *)*((void *)this + 2);
  if (v1)
  {
    int v2 = v1[2] - 1;
    v1[2] = v2;
    if (!v2) {
      (*(void (**)(_DWORD *))(*(void *)v1 + 8))(v1);
    }
  }
}

{
  _DWORD *v1;
  int v2;
  uint64_t vars8;

  *(void *)this = &unk_26C4ED180;
  int v1 = (_DWORD *)*((void *)this + 2);
  if (v1)
  {
    int v2 = v1[2] - 1;
    v1[2] = v2;
    if (!v2) {
      (*(void (**)(_DWORD *))(*(void *)v1 + 8))(v1);
    }
  }
  JUMPOUT(0x21669AC10);
}

_DWORD *RB::DisplayList::PackedTexture::finalize(RB::DisplayList::PackedTexture *this)
{
  *(void *)this = &unk_26C4ED180;
  double result = (_DWORD *)*((void *)this + 2);
  if (result)
  {
    int v2 = result[2] - 1;
    result[2] = v2;
    if (!v2) {
      return (_DWORD *)(*(uint64_t (**)(void))(*(void *)result + 8))();
    }
  }
  return result;
}

void RB::DisplayList::PackedTexture::~PackedTexture(RB::DisplayList::PackedTexture *this)
{
  *(void *)this = &unk_26C4ED180;
  int v1 = (_DWORD *)*((void *)this + 2);
  if (v1)
  {
    int v2 = v1[2] - 1;
    v1[2] = v2;
    if (!v2) {
      (*(void (**)(_DWORD *))(*(void *)v1 + 8))(v1);
    }
  }
}

{
  _DWORD *v1;
  int v2;
  uint64_t vars8;

  *(void *)this = &unk_26C4ED180;
  int v1 = (_DWORD *)*((void *)this + 2);
  if (v1)
  {
    int v2 = v1[2] - 1;
    v1[2] = v2;
    if (!v2) {
      (*(void (**)(_DWORD *))(*(void *)v1 + 8))(v1);
    }
  }
  JUMPOUT(0x21669AC10);
}

void RB::DisplayList::SpillItem::~SpillItem(RB::DisplayList::SpillItem *this)
{
}

uint64_t RB::DisplayList::SpillItem::type_id(RB::DisplayList::SpillItem *this)
{
  return 4;
}

float32x2_t RB::DisplayList::SpillItem::bounds(int32x2_t *this)
{
  uint32x2_t v1 = (uint32x2_t)vceq_s32(this[7], (int32x2_t)0x8000000080000000);
  if ((vpmin_u32(v1, v1).u32[0] & 0x80000000) != 0) {
    return (float32x2_t)0x100000001000000;
  }
  else {
    return vcvt_f32_s32(this[6]);
  }
}

float RB::DisplayList::SpillItem::min_scale(RB::DisplayList::SpillItem *this)
{
  return 1.0;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,false>(uint64_t result, unint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  __n128 v9 = (unint64_t *)result;
LABEL_2:
  uint64_t v10 = (uint64_t *)(a2 - 3);
  uint64_t v11 = v9;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    __n128 v9 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * (a2 - v11);
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          double result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(v10, v11);
          if ((result & 0x80) != 0)
          {
            unint64_t v25 = *v11;
            *uint64_t v11 = *(a2 - 3);
            *(a2 - 3) = v25;
            unint64_t v26 = v11[1];
            unint64_t v27 = v11[2];
            unint64_t v28 = *(a2 - 1);
            v11[1] = *(a2 - 2);
            float32x2_t v11[2] = v28;
            *(a2 - 2) = v26;
            *(a2 - 1) = v27;
          }
          break;
        case 3uLL:
          double result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)v11, (uint64_t *)v11 + 3, v10);
          break;
        case 4uLL:
          double result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)v11, (uint64_t *)v11 + 3, (uint64_t *)v11 + 6, v10);
          break;
        case 5uLL:
          double result = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)v11, (uint64_t *)v11 + 3, (uint64_t *)v11 + 6, (uint64_t *)v11 + 9, v10);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 575) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    float32x2_t v17 = (uint64_t *)&v11[3 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0xC01)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)v11, (uint64_t *)&v11[3 * (v15 >> 1)], v10);
      uint64_t v18 = v10;
      MTLPixelFormat v19 = &v11[3 * v16];
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)v11 + 3, (uint64_t *)v19 - 3, (uint64_t *)a2 - 6);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)v11 + 6, (uint64_t *)&v11[3 * v16 + 3], (uint64_t *)a2 - 9);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)v19 - 3, v17, (uint64_t *)&v11[3 * v16 + 3]);
      long long v20 = *(_OWORD *)v11;
      *(_OWORD *)uint64_t v11 = *(_OWORD *)v17;
      *(_OWORD *)float32x2_t v17 = v20;
      unint64_t v21 = v11[2];
      float32x2_t v11[2] = v19[2];
      _OWORD v19[2] = v21;
      uint64_t v10 = v18;
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)&v11[3 * (v15 >> 1)], (uint64_t *)v11, v10);
    }
    if ((a5 & 1) == 0
      && (std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(v11 - 3, v11) & 0x80) == 0)
    {
      double result = (uint64_t)std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,std::__less<void,void> &>(v11, (uint64_t *)a2);
      uint64_t v11 = (unint64_t *)result;
      goto LABEL_18;
    }
    uint32x2_t v22 = (uint64_t *)std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,std::__less<void,void> &>(v11, a2);
    if ((v23 & 1) == 0) {
      goto LABEL_16;
    }
    BOOL v24 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)v11, v22);
    uint64_t v11 = (unint64_t *)(v22 + 3);
    double result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(v22 + 3, (uint64_t *)a2);
    if (result)
    {
      a4 = -v13;
      a2 = (unint64_t *)v22;
      if (v24) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v24)
    {
LABEL_16:
      double result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,false>(v9, v22, a3, -v13, a5 & 1);
      uint64_t v11 = (unint64_t *)(v22 + 3);
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t)v11, a2);
  }
  else
  {
    return std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t)v11, a2);
  }
}

uint64_t std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(uint64_t result, unint64_t *a2)
{
  if ((unint64_t *)result != a2)
  {
    uint64_t v3 = (unint64_t *)result;
    uint64_t v4 = (unint64_t *)(result + 24);
    if ((unint64_t *)(result + 24) != a2)
    {
      uint64_t v5 = 0;
      char v6 = (unint64_t *)result;
      do
      {
        uint64_t v7 = v4;
        double result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(v4, v6);
        if ((result & 0x80) != 0)
        {
          unint64_t v8 = *v7;
          unint64_t v9 = v6[4];
          unint64_t v10 = v6[5];
          uint64_t v11 = v5;
          unint64_t v12 = *v6;
          while (1)
          {
            uint64_t v13 = (unint64_t *)((char *)v3 + v11);
            uint64_t v14 = *(unint64_t *)((char *)v3 + v11 + 8);
            uint64_t v15 = *(unint64_t *)((char *)v3 + v11 + 16);
            long long v13[3] = v12;
            v13[4] = v14;
            int8x8_t v13[5] = v15;
            if (!v11)
            {
              unint64_t v16 = v3;
              goto LABEL_14;
            }
            unint64_t v16 = v6;
            unint64_t v12 = *(v13 - 3);
            BOOL v17 = v8 < v12;
            if (v8 == v12)
            {
              unint64_t v18 = *(unint64_t *)((char *)v3 + v11 - 16);
              BOOL v19 = v9 == v18;
              BOOL v17 = v9 < v18;
              if (v19)
              {
                unint64_t v20 = *(unint64_t *)((char *)v3 + v11 - 8);
                BOOL v19 = v10 == v20;
                BOOL v17 = v10 < v20;
                if (v19) {
                  break;
                }
              }
            }
            v6 -= 3;
            v11 -= 24;
            if (!v17) {
              goto LABEL_14;
            }
          }
          unint64_t v16 = (unint64_t *)((char *)v3 + v11);
LABEL_14:
          *unint64_t v16 = v8;
          v16[1] = v9;
          float64x2_t v16[2] = v10;
        }
        uint64_t v4 = v7 + 3;
        v5 += 24;
        char v6 = v7;
      }
      while (v7 + 3 != a2);
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(uint64_t result, unint64_t *a2)
{
  if ((unint64_t *)result != a2)
  {
    uint64_t v3 = (unint64_t *)result;
    uint64_t v4 = (unint64_t *)(result + 24);
    if ((unint64_t *)(result + 24) != a2)
    {
      uint64_t v5 = (unint64_t *)(result + 8);
      do
      {
        char v6 = v4;
        double result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(v4, v3);
        if ((result & 0x80) != 0)
        {
          unint64_t v7 = *v6;
          unint64_t v8 = v3[4];
          unint64_t v9 = v3[5];
          unint64_t v10 = v5;
          unint64_t v11 = *v3;
          do
          {
            unint64_t v12 = v10;
            unint64_t v13 = *v10;
            unint64_t v14 = v10[1];
            float32x2_t v12[2] = v11;
            void v12[3] = v13;
            v12[4] = v14;
            unint64_t v11 = *(v12 - 4);
            BOOL v15 = v7 < v11;
            if (v7 == v11)
            {
              unint64_t v16 = *(v12 - 3);
              BOOL v17 = v8 == v16;
              BOOL v15 = v8 < v16;
              if (v17)
              {
                unint64_t v18 = *(v12 - 2);
                BOOL v17 = v9 == v18;
                BOOL v15 = v9 < v18;
                if (v17) {
                  break;
                }
              }
            }
            unint64_t v10 = v12 - 3;
          }
          while (v15);
          *(v12 - 1) = v7;
          *unint64_t v12 = v8;
          v12[1] = v9;
        }
        uint64_t v4 = v6 + 3;
        v5 += 3;
        uint64_t v3 = v6;
      }
      while (v6 + 3 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  char v6 = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a2, a1);
  int v7 = (char)std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a3, a2);
  if ((v6 & 0x80) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return 0;
    }
    uint64_t v17 = *a2;
    *a2 = *a3;
    *a3 = v17;
    uint64_t v18 = a2[1];
    uint64_t v19 = a3[2];
    a2[1] = a3[1];
    unint64_t v16 = a2 + 2;
    uint64_t v20 = a2[2];
    a2[2] = v19;
    a3[1] = v18;
    a3[2] = v20;
    if ((std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a2, a1) & 0x80) == 0)return 1; {
    uint64_t v22 = *a1;
    }
    *a1 = *a2;
    *a2 = v22;
    uint64_t v23 = a1[1];
    a1[1] = a2[1];
    a2[1] = v23;
    unint64_t v10 = a1 + 2;
LABEL_11:
    uint64_t result = 2;
    goto LABEL_12;
  }
  unint64_t v10 = a1 + 2;
  uint64_t v9 = *a1;
  if ((v7 & 0x80000000) == 0)
  {
    *a1 = *a2;
    *a2 = v9;
    unint64_t v10 = a2 + 2;
    uint64_t v11 = a2[2];
    uint64_t v12 = a1[1];
    uint64_t v13 = a1[2];
    a1[1] = a2[1];
    a2[1] = v12;
    a1[2] = v11;
    a2[2] = v13;
    if ((std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a3, a2) & 0x80) == 0)return 1; {
    uint64_t v14 = *a2;
    }
    *a2 = *a3;
    *a3 = v14;
    uint64_t v15 = a2[1];
    a2[1] = a3[1];
    a3[1] = v15;
    unint64_t v16 = a3 + 2;
    goto LABEL_11;
  }
  *a1 = *a3;
  *a3 = v9;
  uint64_t v21 = a1[1];
  a1[1] = a3[1];
  a3[1] = v21;
  unint64_t v16 = a3 + 2;
  uint64_t result = 1;
LABEL_12:
  uint64_t v24 = *v10;
  *unint64_t v10 = *v16;
  *unint64_t v16 = v24;
  return result;
}

uint64_t *std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,std::__less<void,void> &>(unint64_t *a1, uint64_t *a2)
{
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  unint64_t v4 = a1[2];
  unint64_t v5 = *(a2 - 3);
  BOOL v12 = *a1 == v5;
  BOOL v6 = *a1 < v5;
  if (v12 && (v7 = *(a2 - 2), BOOL v12 = v3 == v7, v6 = v3 < v7, v12))
  {
    if (v4 < *(a2 - 1)) {
      goto LABEL_25;
    }
  }
  else if (v6)
  {
LABEL_25:
    uint64_t v15 = a1;
    uint64_t v9 = (uint64_t *)a1;
    do
    {
      unint64_t v16 = v9[3];
      v9 += 3;
      BOOL v17 = v2 == v16;
      if (v2 < v16) {
        char v18 = -1;
      }
      else {
        char v18 = 1;
      }
      if (v17)
      {
        unint64_t v19 = v15[4];
        BOOL v20 = v3 == v19;
        char v18 = v3 < v19 ? -1 : 1;
        if (v20)
        {
          unint64_t v21 = v15[5];
          BOOL v22 = v4 == v21;
          char v18 = v4 < v21 ? -1 : 1;
          if (v22) {
            char v18 = 0;
          }
        }
      }
      uint64_t v15 = (unint64_t *)v9;
    }
    while ((v18 & 0x80) == 0);
    goto LABEL_42;
  }
  unint64_t v8 = a1 + 3;
  do
  {
    uint64_t v9 = (uint64_t *)v8;
    if (v8 >= (unint64_t *)a2) {
      break;
    }
    if (v2 < *v8) {
      char v10 = -1;
    }
    else {
      char v10 = 1;
    }
    if (v2 == *v8)
    {
      unint64_t v11 = v8[1];
      BOOL v12 = v3 == v11;
      char v10 = v3 < v11 ? -1 : 1;
      if (v12)
      {
        unint64_t v13 = v8[2];
        BOOL v14 = v4 == v13;
        char v10 = v4 < v13 ? -1 : 1;
        if (v14) {
          char v10 = 0;
        }
      }
    }
    v8 += 3;
  }
  while ((v10 & 0x80) == 0);
LABEL_42:
  if (v9 < a2)
  {
    uint64_t v23 = (unint64_t *)(a2 - 3);
    do
    {
      a2 = (uint64_t *)v23;
      BOOL v24 = v2 < *v23;
      if (v2 == *v23)
      {
        unint64_t v25 = v23[1];
        BOOL v12 = v3 == v25;
        BOOL v24 = v3 < v25;
        if (v12)
        {
          unint64_t v26 = v23[2];
          BOOL v12 = v4 == v26;
          BOOL v24 = v4 < v26;
          if (v12) {
            break;
          }
        }
      }
      v23 -= 3;
    }
    while (v24);
  }
  if (v9 < a2)
  {
    uint64_t v27 = *v9;
    unint64_t v28 = *a2;
    do
    {
      *uint64_t v9 = v28;
      *a2 = v27;
      uint64_t v29 = v9[1];
      uint64_t v30 = v9[2];
      uint64_t v31 = a2[2];
      v9[1] = a2[1];
      v9[2] = v31;
      a2[1] = v29;
      a2[2] = v30;
      do
      {
        uint64_t v32 = v9;
        unint64_t v33 = v9[3];
        v9 += 3;
        uint64_t v27 = v33;
        BOOL v34 = v2 == v33;
        if (v2 < v33) {
          char v35 = -1;
        }
        else {
          char v35 = 1;
        }
        if (v34)
        {
          unint64_t v36 = v32[4];
          BOOL v37 = v3 == v36;
          char v35 = v3 < v36 ? -1 : 1;
          if (v37)
          {
            unint64_t v38 = v32[5];
            BOOL v39 = v4 == v38;
            char v35 = v4 < v38 ? -1 : 1;
            if (v39) {
              char v35 = 0;
            }
          }
        }
      }
      while ((v35 & 0x80) == 0);
      int32x2_t v40 = (unint64_t *)(a2 - 3);
      do
      {
        a2 = (uint64_t *)v40;
        unint64_t v28 = *v40;
        BOOL v41 = v2 < *v40;
        if (v2 == *v40)
        {
          unint64_t v42 = v40[1];
          BOOL v12 = v3 == v42;
          BOOL v41 = v3 < v42;
          if (v12)
          {
            unint64_t v43 = v40[2];
            BOOL v12 = v4 == v43;
            BOOL v41 = v4 < v43;
            if (v12) {
              break;
            }
          }
        }
        v40 -= 3;
      }
      while (v41);
    }
    while (v9 < a2);
  }
  if (v9 - 3 != (uint64_t *)a1)
  {
    *a1 = *(v9 - 3);
    unint64_t v44 = *(v9 - 1);
    a1[1] = *(v9 - 2);
    a1[2] = v44;
  }
  *(v9 - 3) = v2;
  *(v9 - 2) = v3;
  *(v9 - 1) = v4;
  return v9;
}

unint64_t *std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,std::__less<void,void> &>(unint64_t *a1, void *a2)
{
  uint64_t v2 = 0;
  unint64_t v3 = *a1;
  unint64_t v4 = a1[1];
  unint64_t v5 = a1[2];
  do
  {
    uint64_t v6 = v2;
    unint64_t v7 = (char *)a1 + v2;
    unint64_t v8 = *((void *)v7 + 3);
    BOOL v9 = v8 < v3;
    if (v8 == v3)
    {
      unint64_t v10 = *((void *)v7 + 4);
      BOOL v15 = v10 == v4;
      BOOL v9 = v10 < v4;
      if (v15)
      {
        unint64_t v11 = *(unint64_t *)((char *)a1 + v6 + 40);
        BOOL v15 = v11 == v5;
        BOOL v9 = v11 < v5;
        if (v15) {
          break;
        }
      }
    }
    uint64_t v2 = v6 + 24;
  }
  while (v9);
  unint64_t v12 = (unint64_t)a1 + v6 + 24;
  if (v6)
  {
    unint64_t v13 = a2;
    do
    {
      unint64_t v14 = *(v13 - 3);
      v13 -= 3;
      BOOL v15 = v14 == v3;
      if (v14 < v3) {
        char v16 = -1;
      }
      else {
        char v16 = 1;
      }
      if (v15)
      {
        unint64_t v17 = *(a2 - 2);
        BOOL v18 = v17 == v4;
        char v16 = v17 < v4 ? -1 : 1;
        if (v18)
        {
          unint64_t v19 = *(a2 - 1);
          BOOL v20 = v19 == v5;
          char v16 = v19 < v5 ? -1 : 1;
          if (v20) {
            char v16 = 0;
          }
        }
      }
      a2 = v13;
    }
    while ((v16 & 0x80) == 0);
  }
  else
  {
    while (v12 < (unint64_t)a2)
    {
      unint64_t v13 = a2 - 3;
      unint64_t v21 = *(a2 - 3);
      BOOL v22 = v21 == v3;
      if (v21 < v3) {
        char v23 = -1;
      }
      else {
        char v23 = 1;
      }
      if (v22)
      {
        unint64_t v24 = *(a2 - 2);
        BOOL v25 = v24 == v4;
        char v23 = v24 < v4 ? -1 : 1;
        if (v25)
        {
          unint64_t v26 = *(a2 - 1);
          BOOL v27 = v26 == v5;
          char v23 = v26 < v5 ? -1 : 1;
          if (v27) {
            char v23 = 0;
          }
        }
      }
      a2 -= 3;
      if (v23 < 0) {
        goto LABEL_44;
      }
    }
    unint64_t v13 = a2;
  }
LABEL_44:
  if (v12 >= (unint64_t)v13)
  {
    uint64_t v29 = (unint64_t *)v12;
  }
  else
  {
    unint64_t v28 = *v13;
    uint64_t v29 = (unint64_t *)v12;
    uint64_t v30 = v13;
    do
    {
      *uint64_t v29 = v28;
      *uint64_t v30 = v8;
      unint64_t v31 = v29[1];
      unint64_t v32 = v29[2];
      unint64_t v33 = v30[2];
      v29[1] = v30[1];
      Point v29[2] = v33;
      v30[1] = v31;
      _OWORD v30[2] = v32;
      BOOL v34 = v29 + 3;
      do
      {
        uint64_t v29 = v34;
        unint64_t v8 = *v34;
        BOOL v35 = *v34 < v3;
        if (*v34 == v3)
        {
          unint64_t v36 = v34[1];
          BOOL v15 = v36 == v4;
          BOOL v35 = v36 < v4;
          if (v15)
          {
            unint64_t v37 = v34[2];
            BOOL v15 = v37 == v5;
            BOOL v35 = v37 < v5;
            if (v15) {
              break;
            }
          }
        }
        v34 += 3;
      }
      while (v35);
      do
      {
        unint64_t v38 = v30;
        unint64_t v39 = *(v30 - 3);
        v30 -= 3;
        unint64_t v28 = v39;
        BOOL v40 = v39 == v3;
        if (v39 < v3) {
          char v41 = -1;
        }
        else {
          char v41 = 1;
        }
        if (v40)
        {
          unint64_t v42 = *(v38 - 2);
          BOOL v43 = v42 == v4;
          char v41 = v42 < v4 ? -1 : 1;
          if (v43)
          {
            unint64_t v44 = *(v38 - 1);
            BOOL v45 = v44 == v5;
            char v41 = v44 < v5 ? -1 : 1;
            if (v45) {
              char v41 = 0;
            }
          }
        }
      }
      while ((v41 & 0x80) == 0);
    }
    while (v29 < v30);
  }
  if (v29 - 3 != a1)
  {
    *a1 = *(v29 - 3);
    unint64_t v46 = *(v29 - 1);
    a1[1] = *(v29 - 2);
    a1[2] = v46;
  }
  *(v29 - 3) = v3;
  *(v29 - 2) = v4;
  *(v29 - 1) = v5;
  return v29 - 3;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if ((std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a2 - 3, a1) & 0x80) != 0)
      {
        uint64_t v6 = *a1;
        *a1 = *(a2 - 3);
        *(a2 - 3) = v6;
        uint64_t v7 = a1[1];
        uint64_t v8 = a1[2];
        uint64_t v9 = *(a2 - 1);
        a1[1] = *(a2 - 2);
        a1[2] = v9;
        *(a2 - 2) = v7;
        *(a2 - 1) = v8;
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(a1, a1 + 3, a2 - 3);
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(a1, a1 + 3, a1 + 6, a2 - 3);
      return 1;
    case 5uLL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(a1, a1 + 3, a1 + 6, a1 + 9, a2 - 3);
      return 1;
    default:
      unint64_t v10 = a1 + 6;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(a1, a1 + 3, a1 + 6);
      unint64_t v11 = a1 + 9;
      if (a1 + 9 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    if ((std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(v11, v10) & 0x80) != 0)
    {
      unint64_t v14 = *v11;
      unint64_t v15 = v11[1];
      unint64_t v16 = v11[2];
      uint64_t v17 = v12;
      unint64_t v18 = *v10;
      while (1)
      {
        unint64_t v19 = (uint64_t *)((char *)a1 + v17);
        uint64_t v20 = *(uint64_t *)((char *)a1 + v17 + 56);
        uint64_t v21 = *(uint64_t *)((char *)a1 + v17 + 64);
        v19[9] = v18;
        v19[10] = v20;
        v19[11] = v21;
        if (v17 == -48)
        {
          BOOL v22 = a1;
          goto LABEL_16;
        }
        BOOL v22 = v10;
        unint64_t v18 = v19[3];
        BOOL v23 = v14 < v18;
        if (v14 == v18)
        {
          unint64_t v24 = *(uint64_t *)((char *)a1 + v17 + 32);
          BOOL v25 = v15 == v24;
          BOOL v23 = v15 < v24;
          if (v25)
          {
            unint64_t v26 = *(uint64_t *)((char *)a1 + v17 + 40);
            BOOL v25 = v16 == v26;
            BOOL v23 = v16 < v26;
            if (v25) {
              break;
            }
          }
        }
        v10 -= 3;
        v17 -= 24;
        if (!v23) {
          goto LABEL_16;
        }
      }
      BOOL v22 = (uint64_t *)((char *)a1 + v17 + 48);
LABEL_16:
      *BOOL v22 = v14;
      v22[1] = v15;
      float32x4_t v22[2] = v16;
      if (++v13 == 8) {
        return v11 + 3 == a2;
      }
    }
    unint64_t v10 = v11;
    v12 += 24;
    v11 += 3;
    if (v11 == a2) {
      return 1;
    }
  }
}

uint64_t std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(void *a1, void *a2)
{
  BOOL v3 = *a1 == *a2;
  if (*a1 < *a2) {
    uint64_t result = 0xFFFFFFFFLL;
  }
  else {
    uint64_t result = 1;
  }
  if (v3)
  {
    unint64_t v5 = a1[1];
    unint64_t v6 = a2[1];
    uint64_t result = v5 < v6 ? 0xFFFFFFFFLL : 1;
    if (v5 == v6)
    {
      unint64_t v7 = a1[2];
      unint64_t v8 = a2[2];
      BOOL v9 = v7 == v8;
      if (v7 < v8) {
        unsigned int v10 = -1;
      }
      else {
        unsigned int v10 = 1;
      }
      if (v9) {
        return 0;
      }
      else {
        return v10;
      }
    }
  }
  return result;
}

uint64_t std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(a1, a2, a3);
  uint64_t result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a4, a3);
  if ((result & 0x80) != 0)
  {
    uint64_t v9 = *a3;
    *a3 = *a4;
    *a4 = v9;
    uint64_t v10 = a3[1];
    uint64_t v11 = a3[2];
    uint64_t v12 = a4[2];
    a3[1] = a4[1];
    a3[2] = v12;
    a4[1] = v10;
    a4[2] = v11;
    uint64_t result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a3, a2);
    if ((result & 0x80) != 0)
    {
      uint64_t v13 = *a2;
      *a2 = *a3;
      *a3 = v13;
      uint64_t v14 = a2[1];
      uint64_t v15 = a2[2];
      uint64_t v16 = a3[2];
      a2[1] = a3[1];
      a2[2] = v16;
      a3[1] = v14;
      a3[2] = v15;
      uint64_t result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a2, a1);
      if ((result & 0x80) != 0)
      {
        uint64_t v17 = *a1;
        *a1 = *a2;
        *a2 = v17;
        uint64_t v18 = a1[1];
        uint64_t v19 = a1[2];
        uint64_t v20 = a2[2];
        a1[1] = a2[1];
        a1[2] = v20;
        a2[1] = v18;
        a2[2] = v19;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(a1, a2, a3, a4);
  uint64_t result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a5, a4);
  if ((result & 0x80) != 0)
  {
    uint64_t v11 = *a4;
    *a4 = *a5;
    *a5 = v11;
    uint64_t v12 = a4[1];
    uint64_t v13 = a4[2];
    uint64_t v14 = a5[2];
    a4[1] = a5[1];
    a4[2] = v14;
    a5[1] = v12;
    a5[2] = v13;
    uint64_t result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a4, a3);
    if ((result & 0x80) != 0)
    {
      uint64_t v15 = *a3;
      *a3 = *a4;
      *a4 = v15;
      uint64_t v16 = a3[1];
      uint64_t v17 = a3[2];
      uint64_t v18 = a4[2];
      a3[1] = a4[1];
      a3[2] = v18;
      a4[1] = v16;
      a4[2] = v17;
      uint64_t result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a3, a2);
      if ((result & 0x80) != 0)
      {
        uint64_t v19 = *a2;
        *a2 = *a3;
        *a3 = v19;
        uint64_t v20 = a2[1];
        uint64_t v21 = a2[2];
        uint64_t v22 = a3[2];
        a2[1] = a3[1];
        a2[2] = v22;
        a3[1] = v20;
        a3[2] = v21;
        uint64_t result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a2, a1);
        if ((result & 0x80) != 0)
        {
          uint64_t v23 = *a1;
          *a1 = *a2;
          *a2 = v23;
          uint64_t v24 = a1[1];
          uint64_t v25 = a1[2];
          uint64_t v26 = a2[2];
          a1[1] = a2[1];
          a1[2] = v26;
          a2[1] = v24;
          a2[2] = v25;
        }
      }
    }
  }
  return result;
}

unint64_t *std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = ((char *)a2 - (char *)a1) / 24;
    if ((char *)a2 - (char *)a1 >= 25)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = &a1[3 * v10];
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t)a1, a4, v9, v12);
        v12 -= 3;
        --v11;
      }
      while (v11);
    }
    uint64_t v13 = a2;
    if (a2 != a3)
    {
      uint64_t v14 = a2;
      do
      {
        if ((std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(v14, a1) & 0x80) != 0)
        {
          unint64_t v15 = *v14;
          *uint64_t v14 = *a1;
          *a1 = v15;
          unint64_t v16 = v14[1];
          unint64_t v17 = v14[2];
          unint64_t v18 = a1[2];
          v14[1] = a1[1];
          float32x2_t v14[2] = v18;
          a1[1] = v16;
          a1[2] = v17;
          std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t)a1, a4, v9, a1);
        }
        v14 += 3;
      }
      while (v14 != a3);
      uint64_t v13 = a3;
    }
    if (v8 >= 25)
    {
      int64_t v19 = v8 / 0x18uLL;
      uint64_t v20 = a2 - 3;
      do
      {
        unint64_t v22 = *a1;
        unint64_t v21 = a1[1];
        unint64_t v23 = a1[2];
        uint64_t v24 = std::__floyd_sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(a1, a4, v19);
        if (v20 == v24)
        {
          *uint64_t v24 = v22;
          v24[1] = v21;
          Point v24[2] = v23;
        }
        else
        {
          *uint64_t v24 = *v20;
          unint64_t v25 = v20[2];
          v24[1] = v20[1];
          Point v24[2] = v25;
          *uint64_t v20 = v22;
          v20[1] = v21;
          long long v20[2] = v23;
          std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t)a1, (uint64_t)(v24 + 3), a4, 0xAAAAAAAAAAAAAAABLL * (v24 + 3 - a1));
        }
        v20 -= 3;
      }
      while (v19-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  unint64_t v4 = a3 - 2;
  if (a3 >= 2)
  {
    unint64_t v5 = a4;
    uint64_t v6 = result;
    uint64_t v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= (uint64_t)(0xAAAAAAAAAAAAAAABLL * (((uint64_t)a4 - result) >> 3)))
    {
      uint64_t v9 = (0x5555555555555556 * (((uint64_t)a4 - result) >> 3)) | 1;
      unint64_t v10 = (unint64_t *)(result + 24 * v9);
      uint64_t v11 = 0x5555555555555556 * (((uint64_t)a4 - result) >> 3) + 2;
      if (v11 < a3
        && (std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>((void *)(result + 24 * v9), v10 + 3) & 0x80u) != 0)
      {
        v10 += 3;
        uint64_t v9 = v11;
      }
      uint64_t result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(v10, v5);
      if ((result & 0x80) == 0)
      {
        unint64_t v12 = *v5;
        unint64_t v22 = v5[2];
        unint64_t v23 = v5[1];
        unint64_t v13 = *v10;
        do
        {
          uint64_t v14 = v5;
          unint64_t v5 = v10;
          *uint64_t v14 = v13;
          unint64_t v15 = v10[2];
          v14[1] = v10[1];
          float32x2_t v14[2] = v15;
          if (v7 < v9) {
            break;
          }
          uint64_t v16 = (2 * v9) | 1;
          unint64_t v10 = (unint64_t *)(v6 + 24 * v16);
          if (2 * v9 + 2 >= a3)
          {
            uint64_t v9 = (2 * v9) | 1;
          }
          else
          {
            uint64_t result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>((void *)(v6 + 24 * v16), v10 + 3);
            if ((result & 0x80u) == 0)
            {
              uint64_t v9 = (2 * v9) | 1;
            }
            else
            {
              v10 += 3;
              uint64_t v9 = 2 * v9 + 2;
            }
          }
          unint64_t v13 = *v10;
          if (*v10 < v12) {
            char v17 = -1;
          }
          else {
            char v17 = 1;
          }
          if (*v10 == v12)
          {
            unint64_t v18 = v10[1];
            BOOL v19 = v18 == v23;
            char v17 = v18 < v23 ? -1 : 1;
            if (v19)
            {
              unint64_t v20 = v10[2];
              BOOL v21 = v20 == v22;
              if (v20 < v22) {
                char v17 = -1;
              }
              else {
                char v17 = 1;
              }
              if (v21) {
                char v17 = 0;
              }
            }
          }
        }
        while ((v17 & 0x80) == 0);
        *unint64_t v5 = v12;
        v5[1] = v23;
        void v5[2] = v22;
      }
    }
  }
  return result;
}

void *std::__floyd_sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = 0;
  uint64_t v6 = a3 - 2;
  if (a3 < 2) {
    uint64_t v6 = a3 - 1;
  }
  uint64_t v7 = v6 >> 1;
  do
  {
    uint64_t v8 = &a1[3 * v5 + 3];
    uint64_t v9 = (2 * v5) | 1;
    uint64_t v10 = 2 * v5 + 2;
    if (v10 < a3
      && (std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(&a1[3 * v5 + 3], &a1[3 * v5 + 6]) & 0x80u) != 0)
    {
      v8 += 3;
      uint64_t v9 = v10;
    }
    *a1 = *v8;
    uint64_t v11 = v8[2];
    a1[1] = v8[1];
    a1[2] = v11;
    a1 = v8;
    uint64_t v5 = v9;
  }
  while (v9 <= v7);
  return v8;
}

uint64_t std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    uint64_t v5 = result;
    unint64_t v6 = (unint64_t)(a4 - 2) >> 1;
    uint64_t v7 = (unint64_t *)(result + 24 * v6);
    uint64_t v8 = (unint64_t *)(a2 - 24);
    uint64_t result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(v7, (void *)(a2 - 24));
    if ((result & 0x80) != 0)
    {
      unint64_t v9 = *(void *)(a2 - 24);
      unint64_t v10 = *(void *)(a2 - 16);
      unint64_t v11 = *(void *)(a2 - 8);
      unint64_t v12 = *v7;
      do
      {
        unint64_t v13 = v8;
        uint64_t v8 = v7;
        *unint64_t v13 = v12;
        unint64_t v14 = v7[2];
        v13[1] = v7[1];
        float64x2_t v13[2] = v14;
        if (!v6) {
          break;
        }
        unint64_t v6 = (v6 - 1) >> 1;
        uint64_t v7 = (unint64_t *)(v5 + 24 * v6);
        unint64_t v12 = *v7;
        BOOL v15 = *v7 < v9;
        if (*v7 == v9)
        {
          unint64_t v16 = v7[1];
          BOOL v17 = v16 == v10;
          BOOL v15 = v16 < v10;
          if (v17)
          {
            unint64_t v18 = *(void *)(v5 + 24 * v6 + 16);
            BOOL v17 = v18 == v11;
            BOOL v15 = v18 < v11;
            if (v17) {
              break;
            }
          }
        }
      }
      while (v15);
      unint64_t *v8 = v9;
      v8[1] = v10;
      _OWORD v8[2] = v11;
    }
  }
  return result;
}

BOOL _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEbT1_SL_T0_(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v6 = *(void *)(a2 - 16);
      unint64_t v7 = *(void *)a1;
      if (v6 < *(void *)a1)
      {
        *(void *)a1 = v6;
        *(void *)(a2 - 16) = v7;
        int v8 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v8;
      }
      return result;
    case 3:
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)a1, (unint64_t *)(a1 + 16), (unint64_t *)(a2 - 16));
      return 1;
    case 4:
      _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEvT1_SL_SL_SL_T0_(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEvT1_SL_SL_SL_T0_(a1, a1 + 16, a1 + 32, a1 + 48);
      unint64_t v19 = *(void *)(a2 - 16);
      unint64_t v20 = *(void *)(a1 + 48);
      if (v19 < v20)
      {
        *(void *)(a1 + 48) = v19;
        *(void *)(a2 - 16) = v20;
        int v21 = *(_DWORD *)(a1 + 56);
        *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v21;
        unint64_t v22 = *(void *)(a1 + 48);
        unint64_t v23 = *(void *)(a1 + 32);
        if (v22 < v23)
        {
          *(void *)(a1 + 32) = v22;
          *(void *)(a1 + 48) = v23;
          int v24 = *(_DWORD *)(a1 + 40);
          int v25 = *(_DWORD *)(a1 + 56);
          *(_DWORD *)(a1 + 40) = v25;
          *(_DWORD *)(a1 + 56) = v24;
          unint64_t v26 = *(void *)(a1 + 16);
          if (v22 < v26)
          {
            *(void *)(a1 + 16) = v22;
            *(void *)(a1 + 32) = v26;
            int v27 = *(_DWORD *)(a1 + 24);
            *(_DWORD *)(a1 + 24) = v25;
            *(_DWORD *)(a1 + 40) = v27;
            unint64_t v28 = *(void *)a1;
            if (v22 < *(void *)a1)
            {
              *(void *)a1 = v22;
              *(void *)(a1 + 16) = v28;
              int v29 = *(_DWORD *)(a1 + 8);
              *(_DWORD *)(a1 + 8) = v25;
              *(_DWORD *)(a1 + 24) = v29;
            }
          }
        }
      }
      return 1;
    default:
      unint64_t v9 = (unint64_t *)(a1 + 32);
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)a1, (unint64_t *)(a1 + 16), (unint64_t *)(a1 + 32));
      uint64_t v10 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    unint64_t v13 = *(void *)v10;
    unint64_t v14 = *v9;
    if (*(void *)v10 < *v9)
    {
      int v15 = *(_DWORD *)(v10 + 8);
      uint64_t v16 = v11;
      while (1)
      {
        uint64_t v17 = a1 + v16;
        *(void *)(v17 + 48) = v14;
        *(_DWORD *)(v17 + 56) = *(_DWORD *)(a1 + v16 + 40);
        if (v16 == -32) {
          break;
        }
        unint64_t v14 = *(void *)(v17 + 16);
        v16 -= 16;
        if (v13 >= v14)
        {
          uint64_t v18 = a1 + v16 + 48;
          goto LABEL_13;
        }
      }
      uint64_t v18 = a1;
LABEL_13:
      *(void *)uint64_t v18 = v13;
      *(_DWORD *)(v18 + 8) = v15;
      if (++v12 == 8) {
        return v10 + 16 == a2;
      }
    }
    unint64_t v9 = (unint64_t *)v10;
    v11 += 16;
    v10 += 16;
    if (v10 == a2) {
      return 1;
    }
  }
}

uint64_t RB::Refcount<RB::RenderTask,unsigned int>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t RB::Refcount<RB::RenderTaskTexture,unsigned int>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t _ZZNK2RB5TableIPKNS_11DisplayList5LayerEPNS_6BoundsEE8for_eachIZNKS2_9make_taskERNS1_11RenderStateES5_PKS5_jPKNS1_4ItemEPKDv4_fE3__4EEvT_ENUlPKvSM_PvE_8__invokeESM_SM_SN_(uint64_t a1, double *a2, uint64_t a3)
{
  uint64_t v4 = *(unsigned int *)(a3 + 24);
  uint64_t v5 = *(void *)a3;
  RB::DisplayList::Layer::make_task(&v9, a1, *(void *)(a3 + 16), *(void *)(a3 + 8), 2, 0, 0, *a2, a2[1]);
  RB::DisplayList::LayerTask::add_task(v5, a1, v4, &v9);
  uint64_t result = v9;
  if (v9)
  {
    int v7 = *(_DWORD *)(v9 + 8) - 1;
    *(_DWORD *)(v9 + 8) = v7;
    if (!v7)
    {
      int v8 = *(uint64_t (**)(void))(*(void *)result + 8);
      return v8();
    }
  }
  return result;
}

void sub_2141E2164(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _DWORD *a10)
{
  if (a10) {
    RB::DisplayList::LayerTask::append_task(a10);
  }
  _Unwind_Resume(exception_object);
}

void *RB::vector<RB::Filter::RenderGroup::MultipassInfo,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned long,56ul>(*(void **)a1, (unint64_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,56ul>(void *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(56 * a3);
    unint64_t v6 = v5 / 0x38;
    if (v5 / 0x38 != *a2)
    {
      int v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      uint64_t v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t RB::ProtobufEncoder::uuid_field(RB::ProtobufEncoder *this, uint64_t a2, const UUID *uu)
{
  uint64_t result = uuid_is_null((const unsigned __int8 *)uu);
  if (!result)
  {
    RB::ProtobufEncoder::encode_varint(this, (8 * a2) | 2);
    return (uint64_t)RB::ProtobufEncoder::encode_data(this, uu, 0x10uLL);
  }
  return result;
}

void RB::ProtobufDecoder::uuid_field(RB::ProtobufDecoder *a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v4 = RB::ProtobufDecoder::data_field(a1, a2);
  if (v5 == 36)
  {
    long long v7 = *(_OWORD *)v4;
    long long v8 = *(_OWORD *)(v4 + 16);
    int v12 = *(_DWORD *)(v4 + 32);
    *(_OWORD *)in = v7;
    long long v11 = v8;
    char v13 = 0;
    if (uuid_parse(in, (unsigned __int8 *)&v9)) {
      uuid_clear((unsigned __int8 *)&v9);
    }
    long long v6 = v9;
  }
  else
  {
    if (v5 != 16) {
      return;
    }
    long long v6 = *(_OWORD *)v4;
  }
  *a3 = v6;
}

unsigned int *RB::Identity::encode(unsigned int *this, RB::Encoder *a2)
{
  unint64_t v2 = *this;
  if (v2)
  {
    uint64_t v4 = this;
    RB::ProtobufEncoder::encode_varint(a2, 8uLL);
    RB::ProtobufEncoder::encode_varint(a2, v2);
    return (unsigned int *)RB::ProtobufEncoder::uuid_field(a2, 2, (const UUID *)(v4 + 1));
  }
  return this;
}

__n128 RB::Identity::decode(uint64_t a1, RB::ProtobufDecoder *this)
{
  uint64_t field = RB::ProtobufDecoder::next_field(this);
  if (!field)
  {
LABEL_12:
    __n128 result = *((__n128 *)this + 13);
    *(__n128 *)(a1 + 4) = result;
    return result;
  }
  unint64_t v5 = field;
  char v6 = 0;
  do
  {
    while ((v5 >> 3) != 1)
    {
      if ((v5 >> 3) != 2)
      {
        RB::ProtobufDecoder::skip_field(this, v5);
        goto LABEL_7;
      }
      RB::ProtobufDecoder::uuid_field(this, v5, (_OWORD *)(a1 + 4));
      unint64_t v5 = RB::ProtobufDecoder::next_field(this);
      char v6 = 1;
      if (!v5) {
        return result;
      }
    }
    *(_DWORD *)a1 = RB::ProtobufDecoder::uint_field((uint64_t **)this, v5);
LABEL_7:
    unint64_t v5 = RB::ProtobufDecoder::next_field(this);
  }
  while (v5);
  if ((v6 & 1) == 0) {
    goto LABEL_12;
  }
  return result;
}

RB::TextIdentity *RB::TextIdentity::TextIdentity(RB::TextIdentity *this, CTRunRef run, unsigned int a3, unsigned int a4)
{
  v19[1] = *MEMORY[0x263EF8340];
  *(_DWORD *)this = 4 * a4;
  char Status = CTRunGetStatus(run);
  if (Status) {
    *(_DWORD *)this |= 1u;
  }
  if ((Status & 2) != 0) {
    *(_DWORD *)this |= 2u;
  }
  StringIndicesPtr = CTRunGetStringIndicesPtr(run);
  if (!StringIndicesPtr)
  {
    if (a4 >= 0x201)
    {
      int v15 = (char *)malloc_type_malloc(8 * a4, 0xBB718847uLL);
      if (!v15)
      {
        bzero((char *)this + 4, 4 * (a4 - 1) + 4);
        goto LABEL_19;
      }
    }
    else
    {
      MEMORY[0x270FA5388](0, 8 * a4);
      int v15 = (char *)v19 - ((v14 + 15) & 0xFFFFFFFF0);
      bzero(v15, v14);
    }
    v20.location = a3;
    v20.length = a4;
    CTRunGetStringIndices(run, v20, (CFIndex *)v15);
    if (!a4) {
      return this;
    }
    uint64_t v16 = 0;
    uint64_t v17 = (_DWORD *)((char *)this + 4);
    do
    {
      *v17++ = *(void *)&v15[v16];
      v16 += 8;
    }
    while (8 * a4 != v16);
    if (a4 < 0x201) {
      return this;
    }
LABEL_19:
    free(v15);
    return this;
  }
  if (a4)
  {
    uint64_t v10 = &StringIndicesPtr[a3];
    long long v11 = (_DWORD *)((char *)this + 4);
    uint64_t v12 = 8 * a4;
    do
    {
      uint64_t v13 = *v10++;
      *v11++ = v13;
      v12 -= 8;
    }
    while (v12);
  }
  return this;
}

int *RB::TextIdentity::TextIdentity(int *a1, _DWORD *a2, int a3, unsigned int a4)
{
  *a1 = *a2 & 3 | (4 * a4);
  if (a4) {
    memmove(a1 + 1, &a2[a3 + 1], 4 * a4);
  }
  return a1;
}

BOOL RB::TextIdentity::operator==(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2 && memcmp(a1 + 1, a2 + 1, *a1 & 0xFFFFFFFC) == 0;
}

_DWORD *RB::TextIdentity::copy_atoms(RB::TextIdentity *this, RB::Heap *a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4 = *(_DWORD *)this >> 2;
  BOOL v5 = v4 >= a3;
  unsigned int v6 = v4 - a3;
  if (v6 == 0 || !v5) {
    return 0;
  }
  unsigned int v7 = v6 >= a4 ? a4 : v6;
  if (!v7) {
    return 0;
  }
  uint64_t v10 = v7;
  long long v11 = (_DWORD *)((*((void *)a2 + 2) + 3) & 0xFFFFFFFFFFFFFFFCLL);
  uint64_t v12 = &v11[v10 + 1];
  if ((unint64_t)v12 > *((void *)a2 + 3)) {
    long long v11 = (_DWORD *)RB::Heap::alloc_slow((size_t *)a2, v10 * 4 + 4, 3);
  }
  else {
    *((void *)a2 + 2) = v12;
  }
  *long long v11 = 4 * v7;
  memmove(v11 + 1, (char *)this + 4 * a3 + 4, 4 * v7);
  return v11;
}

void *RB::TextIdentity::encode(RB::TextIdentity *this, RB::Encoder *a2)
{
  __n128 result = RB::ProtobufEncoder::packed_uint32_field(a2, 1, (unsigned int *)this + 1, (unint64_t)*(unsigned int *)this >> 2);
  unsigned int v5 = *(_DWORD *)this;
  if (*(_DWORD *)this)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x10uLL);
    __n128 result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    unsigned int v5 = *(_DWORD *)this;
  }
  if ((v5 & 2) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
    return RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  return result;
}

_DWORD *RB::TextIdentity::decode(size_t **this, RB::Decoder *a2)
{
  int v3 = 0;
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v17 = 0;
  uint64_t v18 = 0x10000000000;
  while (1)
  {
    unint64_t field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
    if (!field) {
      break;
    }
    unint64_t v5 = field >> 3;
    if ((field >> 3) == 1)
    {
      int v6 = RB::ProtobufDecoder::uint_field((uint64_t **)this, field);
      int v7 = v18;
      if (HIDWORD(v18) < (v18 + 1))
      {
        RB::vector<unsigned int,256ul,unsigned int>::reserve_slow(__dst, v18 + 1);
        int v7 = v18;
      }
      long long v8 = v17;
      if (!v17) {
        long long v8 = __dst;
      }
      *(_DWORD *)&v8[4 * v7] = v6;
      LODWORD(v18) = v18 + 1;
    }
    else if (v5 == 2)
    {
      v3 |= RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)this, field);
    }
    else if (v5 == 3)
    {
      if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)this, field)) {
        int v9 = 2;
      }
      else {
        int v9 = 0;
      }
      v3 |= v9;
    }
    else
    {
      RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, field);
    }
  }
  int v10 = v18;
  if (v18 | v3)
  {
    uint64_t v12 = this[8];
    size_t v13 = 4 * v18 + 4;
    long long v11 = (_DWORD *)((v12[2] + 3) & 0xFFFFFFFFFFFFFFFCLL);
    if ((unint64_t)v11 + v13 > v12[3]) {
      long long v11 = (_DWORD *)RB::Heap::alloc_slow(v12, v13, 3);
    }
    else {
      float32x2_t v12[2] = (size_t)v11 + v13;
    }
    *long long v11 = v3 & 3 | (4 * v10);
    if (v18)
    {
      if (v17) {
        size_t v14 = v17;
      }
      else {
        size_t v14 = __dst;
      }
      memmove(v11 + 1, v14, 4 * v18);
    }
  }
  else
  {
    long long v11 = 0;
  }
  if (v17) {
    free(v17);
  }
  return v11;
}

void sub_2141E29F8(_Unwind_Exception *a1)
{
  if (STACK[0x408]) {
    free((void *)STACK[0x408]);
  }
  _Unwind_Resume(a1);
}

void RB::TextIdentity::print(RB::TextIdentity *this, std::string *a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  RB::SexpString::push(a2, "text-identity");
  unsigned int v4 = *(_DWORD *)this;
  if (*(_DWORD *)this)
  {
    RB::SexpString::print(a2, 0, "right-to-left");
    unsigned int v4 = *(_DWORD *)this;
  }
  if ((v4 & 2) != 0)
  {
    RB::SexpString::print(a2, 0, "non-contiguous");
    unsigned int v4 = *(_DWORD *)this;
  }
  if (v4 >= 4)
  {
    unsigned int v5 = 0;
    memset(&v15, 0, sizeof(v15));
    int v6 = (char *)this + 4;
    unsigned int v7 = v4 >> 2;
    do
    {
      if (v5 + 1 >= v7) {
        goto LABEL_15;
      }
      uint64_t v8 = v7;
      uint64_t v9 = v5;
      int v10 = *(_DWORD *)&v6[4 * v5] + 1;
      uint64_t v11 = v5;
      while (v10 == *((_DWORD *)this + v11 + 2))
      {
        ++v11;
        ++v10;
        if (v8 - 1 == v11) {
          goto LABEL_13;
        }
      }
      LODWORD(v8) = v11 + 1;
LABEL_13:
      if (v8 <= v5 + 1)
      {
LABEL_15:
        snprintf_l(__s, 0x40uLL, 0, "%u", *(_DWORD *)&v6[4 * v5]);
      }
      else
      {
        unsigned int v5 = v8 - 1;
        snprintf_l(__s, 0x40uLL, 0, "(%u . %u)", *(_DWORD *)&v6[4 * v9], *(_DWORD *)&v6[4 * (v8 - 1)]);
      }
      std::string::size_type size = HIBYTE(v15.__r_.__value_.__r.__words[2]);
      if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = v15.__r_.__value_.__l.__size_;
      }
      if (size) {
        std::string::push_back(&v15, 32);
      }
      size_t v13 = strlen(__s);
      std::string::append(&v15, __s, v13);
      ++v5;
      unsigned int v7 = *(_DWORD *)this >> 2;
    }
    while (v5 < v7);
    size_t v14 = (std::string *)v15.__r_.__value_.__r.__words[0];
    if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t v14 = &v15;
    }
    RB::SexpString::printf(a2, 0, "(char-indices %s)", (const char *)v14);
    if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v15.__r_.__value_.__l.__data_);
    }
  }
  RB::SexpString::pop(a2);
}

void sub_2141E2C30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *RB::AnimationLayer::encode(void *this, RB::Encoder *a2)
{
  int v3 = this;
  unint64_t v4 = *(unsigned int *)this;
  if (v4)
  {
    RB::ProtobufEncoder::encode_varint(a2, 8uLL);
    this = RB::ProtobufEncoder::encode_varint(a2, v4);
  }
  unint64_t v5 = *((unsigned int *)v3 + 1);
  if (v5 != 1)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x10uLL);
    return RB::ProtobufEncoder::encode_varint(a2, v5);
  }
  return this;
}

unint64_t RB::AnimationLayer::decode(_DWORD *a1, RB::ProtobufDecoder *this)
{
  unint64_t result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      if ((v5 >> 3) == 2)
      {
        a1[1] = RB::ProtobufDecoder::uint_field((uint64_t **)this, v5);
      }
      else if ((v5 >> 3) == 1)
      {
        *a1 = RB::ProtobufDecoder::uint_field((uint64_t **)this, v5);
      }
      else
      {
        RB::ProtobufDecoder::skip_field(this, v5);
      }
      unint64_t result = RB::ProtobufDecoder::next_field(this);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void *RB::vector<unsigned int,256ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  if (*((_DWORD *)__dst + 259) + (*((_DWORD *)__dst + 259) >> 1) <= a2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = *((_DWORD *)__dst + 259) + (*((_DWORD *)__dst + 259) >> 1);
  }
  unint64_t result = RB::details::realloc_vector<unsigned int,4ul>(*((void **)__dst + 128), __dst, 0x100u, (_DWORD *)__dst + 259, v3);
  *((void *)__dst + 128) = result;
  return result;
}

void sub_2141E3094(_Unwind_Exception *a1)
{
}

void sub_2141E3314(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10A1C401E2E3159);
  _Unwind_Resume(a1);
}

void sub_2141E37A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t RBUUIDInitFromNSUUID(void *a1)
{
  v2[2] = *MEMORY[0x263EF8340];
  [a1 getUUIDBytes:v2];
  return v2[0];
}

unint64_t RBUUIDInitFromHash(uint64_t a1, uint64_t a2, char a3)
{
  return a1 & 0xFFFFFFFFFFFF0FFFLL | ((a3 & 0xF) << 12);
}

RB::Transition *RB::Transition::Transition(RB::Transition *this, const RB::Transition *a2)
{
  *((_DWORD *)this + 2) = 1;
  *(void *)this = &unk_26C4E8430;
  *(void *)((char *)this + 12) = *(void *)((char *)a2 + 12);
  unint64_t v4 = (char *)this + 24;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0x400000000;
  if (*((void *)a2 + 5)) {
    unint64_t v5 = (int *)*((void *)a2 + 5);
  }
  else {
    unint64_t v5 = (int *)((char *)a2 + 24);
  }
  unsigned int v6 = *((_DWORD *)a2 + 12);
  unsigned int v7 = v6;
  if (v6 >= 5)
  {
    RB::vector<RB::Symbol::Tag,4ul,unsigned int>::reserve_slow((char *)this + 24, v6);
    uint64_t v8 = (char *)*((void *)this + 5);
    uint64_t v9 = *((unsigned int *)this + 12);
  }
  else
  {
    if (!v6)
    {
      int v12 = 0;
      goto LABEL_13;
    }
    uint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  if (!v8) {
    uint64_t v8 = v4;
  }
  int v10 = &v8[4 * v9];
  do
  {
    int v11 = *v5++;
    *(_DWORD *)int v10 = v11;
    v10 += 4;
    --v7;
  }
  while (v7);
  int v12 = *((_DWORD *)this + 12);
LABEL_13:
  *((_DWORD *)this + 12) = v12 + v6;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0x600000000;
  if (*((void *)a2 + 10)) {
    size_t v13 = (int *)*((void *)a2 + 10);
  }
  else {
    size_t v13 = (int *)((char *)a2 + 56);
  }
  unsigned int v14 = *((_DWORD *)a2 + 22);
  if (v14 >= 7)
  {
    RB::vector<RB::Animation::TermOrArg,6ul,unsigned int>::reserve_slow((char *)this + 56, v14);
    std::string v15 = (char *)*((void *)this + 10);
    uint64_t v16 = *((unsigned int *)this + 22);
  }
  else
  {
    if (!v14)
    {
      int v20 = 0;
      goto LABEL_25;
    }
    std::string v15 = 0;
    uint64_t v16 = 0;
  }
  if (!v15) {
    std::string v15 = (char *)this + 56;
  }
  uint64_t v17 = &v15[4 * v16];
  unsigned int v18 = v14;
  do
  {
    int v19 = *v13++;
    *(_DWORD *)uint64_t v17 = v19;
    v17 += 4;
    --v18;
  }
  while (v18);
  int v20 = *((_DWORD *)this + 22);
LABEL_25:
  *((_DWORD *)this + 22) = v20 + v14;
  return this;
}

void sub_2141E3C3C(_Unwind_Exception *exception_object)
{
  unsigned int v3 = *(void **)(v1 + 80);
  if (v3) {
    free(v3);
  }
  unint64_t v4 = *(void **)(v1 + 40);
  if (v4) {
    free(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::Symbol::Animator::flips_rtl(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  uint64_t v2 = (*(unsigned __int8 *)(*(void *)&this[2]._os_unfair_lock_opaque + 90) >> 1) & 1;
  os_unfair_lock_unlock(this);
  return v2;
}

double RB::Symbol::Animator::transform(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  double v2 = *(double *)(*(void *)&this[2]._os_unfair_lock_opaque + 64);
  os_unfair_lock_unlock(this);
  return v2;
}

BOOL RB::Symbol::Animator::set_transform(os_unfair_lock_s *this, const Transform *a2)
{
  os_unfair_lock_lock(this);
  uint32x2_t v4 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(*(float32x2_t *)(*(void *)&this[2]._os_unfair_lock_opaque + 72), *(float32x2_t *)&a2->_terms._p[8]), (int8x8_t)vceq_f32(*(float32x2_t *)(*(void *)&this[2]._os_unfair_lock_opaque + 64), *(float32x2_t *)a2->_terms._p));
  signed __int32 v5 = vpmin_u32(v4, v4).u32[0];
  if ((v5 & 0x80000000) == 0)
  {
    RB::Symbol::Model::copy_on_write((uint64_t)&this[2]);
    *(_OWORD *)(*(void *)&this[2]._os_unfair_lock_opaque + 64) = *(_OWORD *)a2->_terms._p;
    ++this[15]._os_unfair_lock_opaque;
  }
  os_unfair_lock_unlock(this);
  return v5 >= 0;
}

void sub_2141E3D6C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

float RB::Symbol::Animator::color(uint64_t a1, int a2)
{
  unsigned int v3 = RB::Symbol::Model::style_color_index(a2);
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v3 >= *(_DWORD *)(v4 + 32)) {
    signed __int32 v5 = &RBColorNull;
  }
  else {
    signed __int32 v5 = (long long *)(*(void *)(v4 + 24) + 16 * v3);
  }
  float v6 = *(float *)v5;
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  return v6;
}

uint64_t RB::Symbol::Animator::set_color(uint64_t a1, int a2, float32x4_t *a3)
{
  unsigned int v5 = RB::Symbol::Model::style_color_index(a2);
  if (v5 != -1)
  {
    unsigned int v6 = v5;
    os_unfair_lock_lock((os_unfair_lock_t)a1);
    uint64_t v8 = (void *)(a1 + 8);
    uint64_t v7 = *(void *)(a1 + 8);
    if (v6 >= *(_DWORD *)(v7 + 32))
    {
      if (a3->f32[3] == -32768.0) {
        goto LABEL_4;
      }
    }
    else if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(*(float32x4_t *)(*(void *)(v7 + 24) + 16 * v6), *a3))), 0xFuLL))) & 1) == 0)
    {
LABEL_4:
      uint64_t v9 = 0;
LABEL_9:
      os_unfair_lock_unlock((os_unfair_lock_t)a1);
      return v9;
    }
    RB::Symbol::Model::copy_on_write(a1 + 8);
    uint64_t v10 = *v8;
    int v11 = (void *)(*v8 + 24);
    size_t v13 = (unsigned int *)(*v8 + 32);
    for (unsigned int i = *v13; v6 >= *v13; unsigned int i = *v13)
    {
      if (*(_DWORD *)(v10 + 36) < i + 1)
      {
        RB::vector<RBColor,0ul,unsigned int>::reserve_slow((uint64_t)v11, i + 1);
        unsigned int i = *v13;
      }
      *(_OWORD *)(*v11 + 16 * i) = RBColorNull;
      ++*v13;
      uint64_t v10 = *v8;
      int v11 = (void *)(*v8 + 24);
      size_t v13 = (unsigned int *)(*v8 + 32);
    }
    *(float32x4_t *)(*v11 + 16 * v6) = *a3;
    ++*(_DWORD *)(*(void *)(a1 + 8) + 84);
    ++*(_DWORD *)(a1 + 60);
    uint64_t v9 = 1;
    goto LABEL_9;
  }
  return 0;
}

void sub_2141E3F7C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

BOOL RB::Symbol::Animator::set_alpha(os_unfair_lock_t lock, const float *a2, unint64_t a3)
{
  unint64_t v4 = 0;
  unint64_t v5 = 4;
  if (a3 < 4) {
    unint64_t v5 = a3;
  }
  do
  {
    if (v4 >= v5)
    {
      if (v4) {
        LOBYTE(v6) = *((unsigned char *)&v10 + v4 - 1);
      }
      else {
        LOBYTE(v6) = 1;
      }
    }
    else
    {
      int v6 = (int)(float)((float)(a2[v4] * 255.0) + 0.5);
    }
    *((unsigned char *)&v10 + v4++) = v6;
  }
  while (v4 != 4);
  os_unfair_lock_lock(lock);
  int v7 = *(_DWORD *)(*(void *)&lock[2]._os_unfair_lock_opaque + 91);
  int v8 = v10;
  if (v7 != v10)
  {
    RB::Symbol::Model::copy_on_write((uint64_t)&lock[2]);
    *(_DWORD *)(*(void *)&lock[2]._os_unfair_lock_opaque + 91) = v10;
    ++lock[15]._os_unfair_lock_opaque;
  }
  os_unfair_lock_unlock(lock);
  return v7 != v8;
}

void sub_2141E4070(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Animator::hidden(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  uint64_t v2 = *(unsigned char *)(*(void *)&this[2]._os_unfair_lock_opaque + 90) & 1;
  os_unfair_lock_unlock(this);
  return v2;
}

uint64_t RB::Symbol::Animator::set_hidden(os_unfair_lock_s *this, int a2)
{
  os_unfair_lock_lock(this);
  int v4 = (((*(unsigned __int16 *)(*(void *)&this[2]._os_unfair_lock_opaque + 88) | (*(unsigned __int8 *)(*(void *)&this[2]._os_unfair_lock_opaque + 90) << 16)) & 0x10000) == 0) ^ a2;
  if ((v4 & 1) == 0)
  {
    RB::Symbol::Model::copy_on_write((uint64_t)&this[2]);
    uint64_t v5 = *(void *)&this[2]._os_unfair_lock_opaque;
    int v7 = *(unsigned __int16 *)(v5 + 88);
    uint64_t v6 = v5 + 88;
    int v8 = v7 | (*(unsigned __int8 *)(v6 + 2) << 16);
    if (a2) {
      int v9 = 0x10000;
    }
    else {
      int v9 = 0;
    }
    unsigned int v10 = v8 & 0xFFFEFFFF;
    *(_WORD *)uint64_t v6 = v10;
    *(unsigned char *)(v6 + 2) = (v10 | v9) >> 16;
    ++*(_DWORD *)(*(void *)&this[2]._os_unfair_lock_opaque + 84);
    ++this[15]._os_unfair_lock_opaque;
  }
  os_unfair_lock_unlock(this);
  return v4 ^ 1u;
}

void sub_2141E4174(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Animator::scale_level(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  uint64_t v2 = (*(__int16 *)(*(void *)&this[2]._os_unfair_lock_opaque + 88) >> 8);
  os_unfair_lock_unlock(this);
  return v2;
}

BOOL RB::Symbol::Animator::set_scale_level(os_unfair_lock_s *this, int a2)
{
  os_unfair_lock_lock(this);
  int v4 = *(__int16 *)(*(void *)&this[2]._os_unfair_lock_opaque + 88) >> 8;
  if (v4 != a2)
  {
    RB::Symbol::Model::copy_on_write((uint64_t)&this[2]);
    *(_WORD *)(*(void *)&this[2]._os_unfair_lock_opaque + 88) = *(_WORD *)(*(void *)&this[2]._os_unfair_lock_opaque
                                                                                              + 88) | (unsigned __int16)((_WORD)a2 << 8);
    ++this[15]._os_unfair_lock_opaque;
  }
  os_unfair_lock_unlock(this);
  return v4 != a2;
}

void sub_2141E4240(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

double RB::Symbol::Animator::anchor_point(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  double v2 = *(double *)(*(void *)&this[2]._os_unfair_lock_opaque + 40);
  os_unfair_lock_unlock(this);
  return v2;
}

double RB::Symbol::Animator::position(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  double v2 = *(double *)(*(void *)&this[2]._os_unfair_lock_opaque + 48);
  os_unfair_lock_unlock(this);
  return v2;
}

double RB::Symbol::Animator::size(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  double v2 = *(double *)(*(void *)&this[2]._os_unfair_lock_opaque + 56);
  os_unfair_lock_unlock(this);
  return v2;
}

double RB::Symbol::Animator::presentation_position(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  double v2 = *(double *)&this[12]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(this);
  return v2;
}

BOOL RB::Symbol::Animator::set_current_time(os_unfair_lock_s *this, double a2)
{
  os_unfair_lock_lock(this);
  double v4 = *(double *)&this[10]._os_unfair_lock_opaque;
  if (v4 != a2)
  {
    *(double *)&this[10]._uint32_t os_unfair_lock_opaque = a2;
    ++this[15]._os_unfair_lock_opaque;
  }
  BOOL v5 = v4 != a2;
  os_unfair_lock_unlock(this);
  return v5;
}

uint64_t RB::Symbol::Animator::add_animation(uint64_t a1, float32x2_t *a2)
{
  RB::Symbol::Animation::description(a2->u32[0], a2->i32[1], a2[1].i32[0], a2[3].f32[0] > 0.0, (uint64_t)v30);
  __int32 v33 = a2[2].i32[0];
  float v31 = ceilf(a2[2].f32[1]);
  if (v31 <= 0.0) {
    return 0;
  }
  float v4 = a2[3].f32[0];
  if ((LODWORD(v4) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
  {
    if (v4 < 0.0) {
      float v4 = 0.0;
    }
    float v32 = v4;
  }
  uint32x2_t v5 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(a2[4]));
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) != 0) {
    float32x2_t v34 = a2[4];
  }
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  if (v30[1])
  {
    uint64_t v6 = *(void *)(a1 + 24);
    uint64_t v7 = 88 * v6;
    while (v6)
    {
      --v6;
      uint64_t v8 = *(void *)(a1 + 16);
      int v9 = *(_DWORD *)(v8 + v7 - 84);
      v7 -= 88;
      if (v9 == a2->i32[0])
      {
        if (*(void *)(v8 + v7 + 80) == *(void *)(a1 + 8)) {
          RB::Symbol::Animator::remove_animation_at_index((RB::Symbol::Animator *)a1, v6, 0);
        }
        break;
      }
    }
  }
  uint64_t v11 = *(void *)(a1 + 16);
  unint64_t v10 = *(void *)(a1 + 24);
  uint64_t v12 = v11 + 88 * v10;
  if (v10)
  {
    uint64_t v13 = *(void *)(a1 + 16);
    unint64_t v14 = *(void *)(a1 + 24);
    do
    {
      unint64_t v15 = v14 >> 1;
      uint64_t v16 = v13 + 88 * (v14 >> 1);
      float v17 = *(float *)(v16 + 8);
      uint64_t v18 = v16 + 88;
      v14 += ~(v14 >> 1);
      if (v17 < a2[1].f32[1]) {
        uint64_t v13 = v18;
      }
      else {
        unint64_t v14 = v15;
      }
    }
    while (v14);
    if (v13 != v12)
    {
      while (*(float *)(v13 + 8) == a2[1].f32[1])
      {
        v13 += 88;
        if (v13 == v12) {
          goto LABEL_26;
        }
      }
      uint64_t v12 = v13;
    }
  }
LABEL_26:
  uint64_t v20 = *(void *)(a1 + 8);
  uint64_t v21 = *(void *)(a1 + 16);
  if (*(void *)(a1 + 32) < v10 + 1)
  {
    RB::vector<RB::Symbol::Animation,0ul,unsigned long>::reserve_slow(a1 + 16, v10 + 1);
    uint64_t v21 = *(void *)(a1 + 16);
    unint64_t v10 = *(void *)(a1 + 24);
  }
  unint64_t v22 = 0x2E8BA2E8BA2E8BA3 * ((v12 - v11) >> 3);
  BOOL v23 = v10 > v22;
  unint64_t v24 = v10 - v22;
  if (v23) {
    memmove((void *)(v21 + 88 * v22 + 88), (const void *)(v21 + 88 * v22), 88 * v24);
  }
  RB::Symbol::Animation::Animation(v21 + 88 * v22, v20, a2->u32[0], v30, a2[1].f32[1]);
  uint64_t v25 = *(void *)(a1 + 16);
  ++*(void *)(a1 + 24);
  ++*(_DWORD *)(a1 + 60);
  unint64_t v26 = (void *)a2[6];
  if (v26)
  {
    uint64_t v27 = [v26 copy];
    uint64_t v28 = v25 + 88 * v22;

    *(void *)(v28 + 64) = v27;
  }
  if (a2[5]) {
    operator new();
  }
  uint64_t v19 = *(unsigned int *)(v25 + 88 * v22);
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  return v19;
}

void sub_2141E46A0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void RB::Symbol::Animator::remove_animation_at_index(RB::Symbol::Animator *this, uint64_t a2, char a3)
{
  uint64_t v5 = 88 * a2;
  RB::Symbol::Animation::send_completion((RB::Symbol::Animation *)(*((void *)this + 2) + 88 * a2), a3);
  uint64_t v6 = *((void *)this + 2);
  uint64_t v7 = (void *)(v6 + v5);
  uint64_t v8 = (atomic_uint *)v7[10];
  if (v8 && atomic_fetch_add_explicit(v8 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = v6 + 88 * a2;
  uint64_t v12 = *(void *)(v9 + 72);
  unint64_t v10 = (void *)(v9 + 72);
  uint64_t v11 = v12;
  *unint64_t v10 = 0;
  if (v12) {
    std::default_delete<RB::Symbol::Animation::Timing>::operator()[abi:nn180100]((uint64_t)v10, v11);
  }

  uint64_t v13 = *((void *)this + 3) - 1;
  *((void *)this + 3) = v13;
  uint64_t v14 = v13 - a2;
  if (v14) {
    memmove(v7, v7 + 11, 88 * v14);
  }
  ++*((_DWORD *)this + 15);
}

void RB::Symbol::Animator::remove_finished_animations_locked(RB::Symbol::Animator *this)
{
  unint64_t v1 = *((void *)this + 3);
  if (v1)
  {
    unint64_t v3 = 0;
    do
    {
      if ((*(unsigned char *)(*((void *)this + 2) + 88 * v3 + 13) & 0x20) != 0)
      {
        RB::Symbol::Animator::remove_animation_at_index(this, v3, 1);
        unint64_t v1 = *((void *)this + 3);
      }
      else
      {
        ++v3;
      }
    }
    while (v3 < v1);
  }
}

BOOL RB::Symbol::Animator::remove_animation_by_id(os_unfair_lock_s *this, int a2)
{
  os_unfair_lock_lock(this);
  unint64_t v4 = *(void *)&this[6]._os_unfair_lock_opaque;
  if (!v4)
  {
LABEL_9:
    BOOL v7 = 0;
    goto LABEL_10;
  }
  uint64_t v5 = *(_DWORD **)&this[4]._os_unfair_lock_opaque;
  if (*v5 != a2)
  {
    unint64_t v6 = 0;
    uint64_t v8 = v5 + 22;
    while (v4 - 1 != v6)
    {
      int v9 = *v8;
      v8 += 22;
      ++v6;
      if (v9 == a2)
      {
        BOOL v7 = v6 < v4;
        goto LABEL_8;
      }
    }
    goto LABEL_9;
  }
  unint64_t v6 = 0;
  BOOL v7 = 1;
LABEL_8:
  RB::Symbol::Animator::remove_animation_at_index((RB::Symbol::Animator *)this, v6, 0);
LABEL_10:
  os_unfair_lock_unlock(this);
  return v7;
}

void sub_2141E48D0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Animator::remove_animations_by_mask(os_unfair_lock_s *this, unsigned int a2)
{
  os_unfair_lock_lock(this);
  unint64_t v4 = 0;
  char v5 = 0;
  while (v4 < *(void *)&this[6]._os_unfair_lock_opaque)
  {
    if ((a2 >> *(_DWORD *)(*(void *)&this[4]._os_unfair_lock_opaque + 88 * v4 + 4)))
    {
      char v5 = 1;
      RB::Symbol::Animator::remove_animation_at_index((RB::Symbol::Animator *)this, v4, 0);
    }
    else
    {
      ++v4;
    }
  }
  os_unfair_lock_unlock(this);
  return v5 & 1;
}

void sub_2141E4974(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

BOOL RB::Symbol::Animator::cancel_animation_at_index(RB::Symbol::Animator *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 2);
  double v3 = *((double *)this + 5);
  BOOL v4 = *(double *)(v2 + 88 * a2 + 48) > v3 || v3 == 0.0;
  if (v4)
  {
    RB::Symbol::Animator::remove_animation_at_index(this, a2, 0);
  }
  else
  {
    char v5 = (RB::Symbol::Animation *)(v2 + 88 * a2);
    if ((unint64_t)(a2 + 1) >= *((void *)this + 3)) {
      unint64_t v6 = (const RB::Symbol::Model **)((char *)this + 8);
    }
    else {
      unint64_t v6 = (const RB::Symbol::Model **)((char *)v5 + 168);
    }
    RB::Symbol::Animation::cancel(v5, *(float32x2_t *)&v3, *v6);
  }
  return v4;
}

uint64_t RB::Symbol::Animator::cancel_animation_by_id(os_unfair_lock_s *this, int a2)
{
  os_unfair_lock_lock(this);
  unint64_t v5 = *(void *)&this[6]._os_unfair_lock_opaque;
  if (!v5)
  {
LABEL_9:
    BOOL v8 = 0;
    goto LABEL_10;
  }
  unint64_t v6 = *(_DWORD **)&this[4]._os_unfair_lock_opaque;
  if (*v6 != a2)
  {
    unint64_t v7 = 0;
    int v9 = v6 + 22;
    while (v5 - 1 != v7)
    {
      int v10 = *v9;
      v9 += 22;
      ++v7;
      if (v10 == a2)
      {
        BOOL v8 = v7 < v5;
        goto LABEL_8;
      }
    }
    goto LABEL_9;
  }
  unint64_t v7 = 0;
  BOOL v8 = 1;
LABEL_8:
  BOOL v4 = RB::Symbol::Animator::cancel_animation_at_index((RB::Symbol::Animator *)this, v7);
LABEL_10:
  uint64_t v11 = v8 & v4;
  os_unfair_lock_unlock(this);
  return v11;
}

void sub_2141E4AA4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Animator::cancel_animations_by_mask(os_unfair_lock_s *this, unsigned int a2)
{
  os_unfair_lock_lock(this);
  unint64_t v4 = 0;
  uint64_t v5 = 0;
LABEL_2:
  uint64_t v6 = v5;
  while (1)
  {
    uint64_t v5 = v6;
    if (v4 >= *(void *)&this[6]._os_unfair_lock_opaque) {
      break;
    }
    if ((a2 >> *(_DWORD *)(*(void *)&this[4]._os_unfair_lock_opaque + 88 * v4 + 4)))
    {
      BOOL v7 = RB::Symbol::Animator::cancel_animation_at_index((RB::Symbol::Animator *)this, v4);
      uint64_t v6 = 1;
      if (v7) {
        continue;
      }
    }
    ++v4;
    goto LABEL_2;
  }
  os_unfair_lock_unlock(this);
  return v5 & 1;
}

void sub_2141E4B4C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Animator::set_priority_by_id(os_unfair_lock_s *this, int a2, float a3)
{
  os_unfair_lock_lock(this);
  uint64_t v6 = *(void *)&this[6]._os_unfair_lock_opaque;
  if (!v6) {
    goto LABEL_22;
  }
  uint64_t v7 = *(void *)&this[6]._os_unfair_lock_opaque;
  unint64_t v8 = *(void *)&this[4]._os_unfair_lock_opaque;
  while (*(_DWORD *)v8 != a2)
  {
    v8 += 88;
    if (!--v7) {
      goto LABEL_22;
    }
  }
  if (*(float *)(v8 + 8) == a3) {
    goto LABEL_22;
  }
  unint64_t v9 = *(void *)&this[4]._os_unfair_lock_opaque;
  unint64_t v10 = *(void *)&this[6]._os_unfair_lock_opaque;
  do
  {
    unint64_t v11 = v10 >> 1;
    unint64_t v12 = v9 + 88 * (v10 >> 1);
    float v13 = *(float *)(v12 + 8);
    unint64_t v14 = v12 + 88;
    v10 += ~(v10 >> 1);
    if (v13 < a3) {
      unint64_t v9 = v14;
    }
    else {
      unint64_t v10 = v11;
    }
  }
  while (v10);
  uint64_t v15 = *(void *)&this[4]._os_unfair_lock_opaque + 88 * v6;
  if (v9 != v15)
  {
    while (*(float *)(v9 + 8) == a3)
    {
      v9 += 88;
      if (v9 == v15)
      {
        unint64_t v9 = v15;
        break;
      }
    }
  }
  *(float *)(v8 + 8) = a3;
  if (v9 >= v8)
  {
    if (v9 > v8)
    {
      if (v8 + 88 != v9) {
        std::__rotate_forward[abi:nn180100]<std::_ClassicAlgPolicy,RB::Symbol::Animation *>((long long *)v8, (long long *)(v8 + 88), (long long *)v9);
      }
      goto LABEL_21;
    }
LABEL_22:
    uint64_t v16 = 0;
    goto LABEL_23;
  }
  std::__rotate_forward[abi:nn180100]<std::_ClassicAlgPolicy,RB::Symbol::Animation *>((long long *)v9, (long long *)v8, (long long *)(v8 + 88));
LABEL_21:
  uint64_t v16 = 1;
LABEL_23:
  os_unfair_lock_unlock(this);
  return v16;
}

void sub_2141E4C88(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

long long *std::__rotate_forward[abi:nn180100]<std::_ClassicAlgPolicy,RB::Symbol::Animation *>(long long *a1, long long *a2, long long *a3)
{
  unint64_t v4 = a2;
  std::swap[abi:nn180100]<RB::Symbol::Animation>(a1, a2);
  uint64_t v6 = (long long *)((char *)a1 + 88);
  for (unsigned int i = (long long *)((char *)v4 + 88); i != a3; unsigned int i = (long long *)((char *)i + 88))
  {
    if (v6 == v4) {
      unint64_t v4 = i;
    }
    std::swap[abi:nn180100]<RB::Symbol::Animation>(v6, i);
    uint64_t v6 = (long long *)((char *)v6 + 88);
  }
  if (v6 != v4)
  {
    unint64_t v8 = v6;
    unint64_t v9 = v4;
    do
    {
      while (1)
      {
        std::swap[abi:nn180100]<RB::Symbol::Animation>(v8, v4);
        unint64_t v8 = (long long *)((char *)v8 + 88);
        unint64_t v4 = (long long *)((char *)v4 + 88);
        if (v4 == a3) {
          break;
        }
        if (v8 == v9) {
          unint64_t v9 = v4;
        }
      }
      unint64_t v4 = v9;
    }
    while (v8 != v9);
  }
  return v6;
}

void std::swap[abi:nn180100]<RB::Symbol::Animation>(long long *a1, long long *a2)
{
  long long v18 = *a1;
  long long v19 = a1[1];
  long long v20 = a1[2];
  long long v21 = a1[3];
  long long v4 = a1[4];
  a1[4] = 0u;
  uint64_t v5 = (atomic_uint *)*((void *)a1 + 10);
  *((void *)a1 + 10) = 0;
  long long v6 = a2[3];
  long long v8 = *a2;
  long long v7 = a2[1];
  a1[2] = a2[2];
  a1[3] = v6;
  *a1 = v8;
  a1[1] = v7;
  *((void *)a1 + 8) = *((void *)a2 + 8);
  uint64_t v10 = (uint64_t)a2 + 72;
  uint64_t v9 = *((void *)a2 + 9);
  a2[4] = 0u;
  uint64_t v13 = *((void *)a1 + 9);
  unint64_t v11 = (void *)a1 + 9;
  uint64_t v12 = v13;
  unint64_t v24 = v5;
  *unint64_t v11 = v9;
  if (v13)
  {
    long long v17 = v4;
    std::default_delete<RB::Symbol::Animation::Timing>::operator()[abi:nn180100]((uint64_t)v11, v12);
    long long v4 = v17;
  }
  unint64_t v14 = (atomic_uint *)*((void *)a1 + 10);
  *((void *)a1 + 10) = *((void *)a2 + 10);
  *((void *)a2 + 10) = v14;
  *a2 = v18;
  a2[1] = v19;
  a2[2] = v20;
  a2[3] = v21;
  uint64_t v15 = *((void *)a2 + 9);
  id v22 = (id)*((void *)a2 + 8);
  uint64_t v23 = 0;
  a2[4] = v4;
  if (v15)
  {
    std::default_delete<RB::Symbol::Animation::Timing>::operator()[abi:nn180100](v10, v15);
    unint64_t v14 = (atomic_uint *)*((void *)a2 + 10);
  }
  *((void *)a2 + 10) = v5;
  unint64_t v24 = v14;
  if (v14 && atomic_fetch_add_explicit(v14 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v14 + 8))(v14);
  }
  uint64_t v16 = v23;
  uint64_t v23 = 0;
  if (v16) {
    std::default_delete<RB::Symbol::Animation::Timing>::operator()[abi:nn180100]((uint64_t)&v23, v16);
  }
}

void *RB::vector<RB::Symbol::Animation,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1) <= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16) + (*(void *)(a1 + 16) >> 1);
  }
  unint64_t result = RB::details::realloc_vector<unsigned long,88ul>(*(void **)a1, (unint64_t *)(a1 + 16), v3);
  *(void *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,88ul>(void *a1, unint64_t *a2, uint64_t a3)
{
  long long v4 = a1;
  if (a3)
  {
    size_t v5 = malloc_good_size(88 * a3);
    unint64_t v6 = v5 / 0x58;
    if (v5 / 0x58 != *a2)
    {
      long long v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7) {
        RB::precondition_failure((RB *)"allocation failure", v8);
      }
      long long v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void RB::DisplayList::Layer::make_cgimage(RB::DisplayList::Layer *this@<X0>, RB::CGContext *a2@<X1>, float32x2_t *a3@<X2>, char *a4@<X3>, CGImage **a5@<X8>)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  BOOL v61 = 0;
  RB::Bounds::Bounds((int32x2_t *)&v60, *a3, a3[1]);
  __n128 v59 = v60;
  if ((RB::DisplayList::Layer::compute_roi(this, (int32x2_t *)&v60, (int32x2_t *)&v59, &v61, 0, v60) & 1) == 0) {
    goto LABEL_23;
  }
  v10.i32[0] = 0;
  uint32x2_t v11 = (uint32x2_t)vceq_s32(*(int32x2_t *)&v60.n128_i8[8], (int32x2_t)0x8000000080000000);
  int8x8_t v12 = (int8x8_t)vdup_lane_s32(vcgt_s32(v10, (int32x2_t)vpmin_u32(v11, v11)), 0);
  int8x8_t v13 = vbsl_s8(v12, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v60.n128_i8[8]));
  *a3 = (float32x2_t)vbsl_s8(v12, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)v60.n128_u64[0]));
  a3[1] = (float32x2_t)v13;
  unsigned int v14 = *((_DWORD *)this + 15);
  unsigned int v15 = ((v14 & 4) << 6) | (v14 >> 2) & 1;
  if ((v14 & 2) != 0) {
    unsigned int v15 = 256;
  }
  unsigned __int8 v16 = v15 >= 0x100 ? v15 : *((unsigned char *)a2 + 8);
  if ((v14 & 8) != 0) {
    char v17 = 1;
  }
  else {
    char v17 = *((void *)this + 2) || *((unsigned char *)this + 64) ? 2 : 0;
  }
  __int16 v18 = v16 | 0x100;
  RB::CGContext::begin_bitmap((int8x8_t *)a2, a3, v17, v18, 0, 0, (CGContext **)&v58);
  if (!v58)
  {
LABEL_23:
    *a5 = 0;
    return;
  }
  unsigned __int8 v54 = v16;
  __asm { FMOV            V0.2S, #1.0 }
  RB::CGContext::CGContext(c, v58, v16, _D0);
  if ((*((unsigned char *)this + 60) & 1) != 0 && *(char **)this == a4)
  {
    CGImageRef Image = CGBitmapContextCreateImage(*(CGContextRef *)a2);
    size_t Width = CGImageGetWidth(Image);
    size_t Height = CGImageGetHeight(Image);
    long long v26 = *((_OWORD *)a2 + 3);
    *(_OWORD *)&context[0].CGFloat a = *((_OWORD *)a2 + 2);
    long long v27 = *((_OWORD *)a2 + 4);
    *(_OWORD *)&context[0].c = v26;
    *(_OWORD *)&context[0].tCGFloat x = v27;
    RB::AffineTransform::invert((RB::AffineTransform *)context);
    float v29 = *((float *)this + 12);
    if (v29 == 0.0) {
      float v29 = 1.0;
    }
    double v30 = v29;
    *(float64x2_t *)&context[0].CGFloat a = vmulq_n_f64(*(float64x2_t *)&context[0].a, v30);
    *(float64x2_t *)&context[0].c = vmulq_n_f64(*(float64x2_t *)&context[0].c, v30);
    *(float *)&v28.i32[1] = (float)Height;
    *(float *)v28.i32 = (float)Width;
    float32x2_t v50 = RB::operator*((float64x2_t *)context, 0, v28);
    float32x2_t v51 = v31;
    RB::Bounds::Bounds((int32x2_t *)&v56, v50, v31);
    if (v66 || !RB::Bounds::contains(v67, *(int32x2_t *)&v56.a, *(int32x2_t *)&v56.b))
    {
      int v32 = 0;
    }
    else
    {
      int v32 = 1;
      if (!v65 && v68 == 1.0 && !v69)
      {
LABEL_26:
        v71.origin.CGFloat x = v50.f32[0];
        v71.origin.CGFloat y = v50.f32[1];
        v71.size.CGFloat width = v51.f32[0];
        v71.size.CGFloat height = v51.f32[1];
        CGContextDrawImage(c[0], v71, Image);
        if (Image) {
          CFRelease(Image);
        }
        goto LABEL_28;
      }
    }
    RB::CGContext::update_state_slow((uint64_t)c, 0, 0, 0, &v56, v32, 1.0);
    goto LABEL_26;
  }
LABEL_28:
  RB::DisplayList::Layer::render_items((void **)this, (RB::CGContext *)c, a4);
  CFTypeRef cf = 0;
  for (unsigned int i = (void *)*((void *)this + 2); i; unsigned int i = (void *)i[1])
    (*(void (**)(void *, CGContextRef *, CFTypeRef *))(*i + 112))(i, c, &cf);
  if (*((float *)this + 12) == 0.0) {
    float v35 = 1.0;
  }
  else {
    float v35 = *((float *)this + 12);
  }
  if (v35 < 0.9)
  {
    *(float *)v33.i32 = 1.0 / v35;
    int32x2_t v53 = v33;
    RB::CGContext::begin_bitmap((int8x8_t *)a2, a3, v17, v18, (int8x8_t)vmul_n_f32(*(float32x2_t *)((char *)a2 + 16), 1.0 / v35), 1u, (CGContext **)context);
    CFTypeRef v36 = cf;
    CGFloat a = context[0].a;
    CFTypeRef cf = *(CFTypeRef *)&context[0].a;
    *(void *)&context[0].CGFloat a = v36;
    if (v36)
    {
      CFRelease(v36);
      CGFloat a = *(double *)&cf;
    }
    if (a != 0.0)
    {
      RB::CGContext::apply_scale(c, *(RB::_anonymous_namespace_ **)&a, COERCE_DOUBLE(vdup_lane_s32(v53, 0)));
      unint64_t v38 = CGBitmapContextCreateImage((CGContextRef)cf);
      CGContextGetCTM(&v56, (CGContextRef)cf);
      context[0] = v56;
      int32x2_t v39 = RB::AffineTransform::scale2((float64x2_t *)context);
      if (v38) {
        goto LABEL_39;
      }
    }
  }
  unint64_t v38 = CGBitmapContextCreateImage(c[0]);
  int32x2_t v39 = RB::AffineTransform::scale2(v64);
  if (v38)
  {
LABEL_39:
    v40.f32[0] = (float)v59.n128_i32[0] - COERCE_FLOAT(*a3);
    v40.f32[1] = (float)(a3[1].f32[1] + COERCE_FLOAT(HIDWORD(*(unint64_t *)a3)))
               - (float)vadd_s32(*(int32x2_t *)(&v59 + 8), *(int32x2_t *)&v59).i32[1];
    float32x2_t v41 = vmul_f32(v40, (float32x2_t)v39);
    float32x2_t v42 = vmul_f32((float32x2_t)v39, vcvt_f32_s32(*(int32x2_t *)&v59.n128_i8[8]));
    v72.origin.CGFloat x = v41.f32[0];
    v72.origin.CGFloat y = v41.f32[1];
    v72.size.CGFloat width = v42.f32[0];
    v72.size.CGFloat height = v42.f32[1];
    BOOL v43 = CGImageCreateWithImageInRect(v38, v72);
    v44.i32[0] = 0;
    *a5 = v43;
    uint32x2_t v45 = (uint32x2_t)vceq_s32(*(int32x2_t *)&v59.n128_i8[8], (int32x2_t)0x8000000080000000);
    int8x8_t v46 = (int8x8_t)vdup_lane_s32(vcgt_s32(v44, (int32x2_t)vpmin_u32(v45, v45)), 0);
    float32x2_t v47 = (float32x2_t)vbsl_s8(v46, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v59.n128_i8[8]));
    *a3 = vmul_n_f32((float32x2_t)vbsl_s8(v46, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)v59.n128_u64[0])), 1.0 / v35);
    a3[1] = vmul_n_f32(v47, 1.0 / v35);
    if (*((unsigned char *)this + 64) == 2)
    {
      if (v17)
      {
        *(_OWORD *)&v56.CGFloat a = *(_OWORD *)a3->f32;
        RB::CGContext::begin_bitmap((int8x8_t *)a2, (float32x2_t *)&v56, 2, v18, 0, 0, &v55);
        v73.origin.CGFloat x = COERCE_FLOAT(*a3);
        v73.origin.CGFloat y = COERCE_FLOAT(HIDWORD(*(unint64_t *)a3));
        v73.size.CGFloat width = COERCE_FLOAT(*(void *)&a3[1]);
        v73.size.CGFloat height = COERCE_FLOAT(HIDWORD(*(void *)&a3[1]));
        CGContextDrawImage(v55, v73, v43);
        __asm { FMOV            V0.2S, #1.0 }
        RB::CGContext::CGContext(context, v55, v54, _D0);
        (*(void (**)(void, CGAffineTransform *))(**((void **)this + 3) + 136))(*((void *)this + 3), context);
        CGImageRef v49 = CGBitmapContextCreateImage(*(CGContextRef *)&context[0].a);
        if (v43) {
          CFRelease(v43);
        }
        *a5 = v49;
        *(_OWORD *)a3->f32 = *(_OWORD *)&v56.a;
        RB::CGContext::~CGContext((RB::CGContext *)context);
        if (v55) {
          CFRelease(v55);
        }
      }
      else
      {
        (*(void (**)(void, CGContextRef *))(**((void **)this + 3) + 136))(*((void *)this + 3), c);
      }
    }
    CFRelease(v38);
  }
  else
  {
    *a5 = 0;
  }
  if (cf) {
    CFRelease(cf);
  }
  RB::CGContext::~CGContext((RB::CGContext *)c);
  if (v58) {
    CFRelease(v58);
  }
}

void sub_2141E5578(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef cf, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,CFTypeRef a23,CFTypeRef a24)
{
  if (cf) {
    CFRelease(cf);
  }
  if (v25) {
    CFRelease(v25);
  }
  CFRelease(v24);
  if (a23) {
    CFRelease(a23);
  }
  RB::CGContext::~CGContext((RB::CGContext *)&STACK[0x430]);
  if (a24) {
    CFRelease(a24);
  }
  _Unwind_Resume(a1);
}

void RB::DisplayList::LayerItem::render(RB::DisplayList::LayerItem *this, int32x2_t *a2)
{
  long long v4 = (float32x2_t *)*((void *)this + 3);
  _H0 = *((_WORD *)this + 22);
  __asm { FCVT            S8, H0 }
  unsigned int v10 = *((_WORD *)this + 23) & 0x3F;
  float32x2_t v11 = RB::DisplayList::LayerItem::bounds(this);
  RB::Bounds::Bounds((int32x2_t *)&v28, v11, v12);
  int v13 = 0;
  if ((float32x2_t *)a2[11] != v4) {
    goto LABEL_10;
  }
  if (!RB::Bounds::contains(a2 + 12, *(int32x2_t *)&v28, *(int32x2_t *)((char *)&v28 + 8)))
  {
    int v13 = 0;
LABEL_10:
    RB::CGContext::update_state_slow((uint64_t)a2, 0, v4, v10, &v28, v13, _S8);
    goto LABEL_11;
  }
  int v13 = 1;
  if (a2[10]) {
    goto LABEL_10;
  }
  if (*(float *)&a2[16].i32[1] != _S8 || a2[17].i32[0] != v10) {
    goto LABEL_10;
  }
LABEL_11:
  uint64_t v15 = *((void *)this + 6);
  if (*(void *)(v15 + 16)
    || *(unsigned char *)(v15 + 64)
    || (int v16 = *(_DWORD *)(v15 + 60), (v16 & 1) != 0)
    || !RB::CGContext::compatible_layer_flags((RB::CGContext *)a2, v16))
  {
    RB::CGContext::reset_ctm((uint64_t)a2);
    CGRect ClipBoundingBox = CGContextGetClipBoundingBox((CGContextRef)*(void *)a2);
    CGFloat y = ClipBoundingBox.origin.y;
    CGFloat height = ClipBoundingBox.size.height;
    *(float32x2_t *)&long long v28 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.origin);
    *((float32x2_t *)&v28 + 1) = vcvt_f32_f64((float64x2_t)ClipBoundingBox.size);
    RB::DisplayList::Layer::make_cgimage(*((RB::DisplayList::Layer **)this + 6), (RB::CGContext *)a2, (float32x2_t *)&v28, 0, &image);
    CGImageRef v25 = image;
    if (image)
    {
      v30.origin.CGFloat x = *(float *)&v28;
      v30.origin.CGFloat y = *((float *)&v28 + 1);
      v30.size.CGFloat width = *((float *)&v28 + 2);
      v30.size.CGFloat height = *((float *)&v28 + 3);
      CGContextDrawImage(*(CGContextRef *)a2, v30, image);
      CFRelease(v25);
    }
  }
  else
  {
    long long v19 = (float *)*((void *)this + 6);
    *(float *)&double v17 = v19[12];
    v18.i32[0] = 1.0;
    if (*(float *)&v17 == 0.0) {
      float v20 = 1.0;
    }
    else {
      float v20 = v19[12];
    }
    float32x2_t v21 = RB::DisplayList::Layer::bounds((RB::DisplayList::Layer *)v19, v17, v18);
    RB::Bounds::Bounds(v27, v21, v22);
    RB::CGContext::begin_layer((uint64_t)a2, v20, v27[0], v27[1]);
    RB::DisplayList::Layer::render_items(*((void ***)this + 6), (RB::CGContext *)a2, 0);
    RB::CGContext::end_layer((CGContextRef *)a2);
  }
}

void sub_2141E57FC(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

double RB::DisplayList::Clip::fill(RB::DisplayList::Clip *this, RB::CGContext *a2, const RB::Fill::Color *a3)
{
  RB::CGContext::save(a2);
  if (*((unsigned char *)this + 45))
  {
    if (*((unsigned char *)a2 + 140) != 1) {
      RB::CGContext::set_aliasing_mode_slow((uint64_t)a2, 1);
    }
    v10.origin.CGFloat x = COERCE_FLOAT(*((void *)this + 2));
    v10.origin.CGFloat y = COERCE_FLOAT(HIDWORD(*((void *)this + 2)));
    v10.size.CGFloat width = COERCE_FLOAT(*((void *)this + 3));
    v10.size.CGFloat height = COERCE_FLOAT(HIDWORD(*((void *)this + 3)));
    CGContextClipToRect(*(CGContextRef *)a2, v10);
  }
  else
  {
    (*(void (**)(RB::DisplayList::Clip *, RB::CGContext *))(*(void *)this + 88))(this, a2);
  }
  if (*((unsigned char *)a2 + 121)) {
    BOOL v7 = *((unsigned char *)a3 + 9) == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7 && *((unsigned __int8 *)a2 + 120) != *((unsigned __int8 *)a3 + 8)
    || (v6.i16[0] = *((_WORD *)a2 + 56), *(short float *)v6.i16 != *(short float *)a3)
    || (v6.i16[0] = *((_WORD *)a2 + 57), *(short float *)v6.i16 != *((short float *)a3 + 1))
    || (v6.i16[0] = *((_WORD *)a2 + 58), *(short float *)v6.i16 != *((short float *)a3 + 2))
    || (v6.i16[0] = *((_WORD *)a2 + 59), *(short float *)v6.i16 != *((short float *)a3 + 3)))
  {
    RB::CGContext::set_fill_color_slow(a2, a3, v6);
  }
  v11.origin.CGFloat x = COERCE_FLOAT(*((void *)this + 2));
  v11.origin.CGFloat y = COERCE_FLOAT(HIDWORD(*((void *)this + 2)));
  v11.size.CGFloat width = COERCE_FLOAT(*((void *)this + 3));
  v11.size.CGFloat height = COERCE_FLOAT(HIDWORD(*((void *)this + 3)));
  CGContextFillRect(*(CGContextRef *)a2, v11);
  *(void *)&double result = RB::CGContext::restore(a2).n128_u64[0];
  return result;
}

void RB::DisplayList::LayerClip::clip(RB::DisplayList::LayerClip *this, CGContextRef *a2)
{
  RB::CGContext::reset_ctm((uint64_t)a2);
  CGRect ClipBoundingBox = CGContextGetClipBoundingBox(*a2);
  CGFloat y = ClipBoundingBox.origin.y;
  CGFloat height = ClipBoundingBox.size.height;
  float32x2_t v18 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.origin);
  float32x2_t v19 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.size);
  RB::Rect::intersect(&v18, *((double *)this + 2), *(float32x2_t *)((char *)this + 24), ClipBoundingBox.size.width, ClipBoundingBox.size.height, v6, v7);
  uint32x2_t v8 = (uint32x2_t)vclez_f32(v19);
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) != 0)
  {
    CGContextClipToRect(*a2, *MEMORY[0x263F001A0]);
    return;
  }
  uint64_t v9 = *((void *)this + 6);
  CGRect v10 = *(void **)(v9 + 16);
  if (!v10) {
    goto LABEL_7;
  }
  if (!v10[1]
    && (*(unsigned int (**)(void *))(*v10 + 40))(v10) == 1
    && RB::ColorMatrix::is_luminance_to_alpha(v11 + 1))
  {
    uint64_t v9 = *((void *)this + 6);
LABEL_7:
    int v12 = *(_DWORD *)(v9 + 60);
    if ((v12 & 1) == 0
      && !*(unsigned char *)(v9 + 64)
      && RB::CGContext::compatible_layer_flags((RB::CGContext *)a2, v12))
    {
      *(float32x2_t *)v13.i8 = v19;
      double v17 = this;
      RB::CGContext::add_soft_mask((uint64_t)a2, v10 != 0, (uint64_t)&v17, (void (*)(CGContextRef *, uint64_t))RB::CGContext::add_soft_mask<RB::DisplayList::LayerClip::clip(RB::CGContext&)::$_0>(RB::CGContext::SoftMaskMode,RB::Rect,RB::DisplayList::LayerClip::clip(RB::CGContext&)::$_0 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke, v18, v13);
      return;
    }
  }
  RB::DisplayList::Layer::make_cgimage(*((RB::DisplayList::Layer **)this + 6), (RB::CGContext *)a2, &v18, 0, &v17);
  int v16 = v17;
  if (v17)
  {
    RB::CGContext::add_alpha_mask((RB::CGContext *)a2, v17, &v18, v14, v15);
    CFRelease(v16);
  }
}

void sub_2141E5AD0(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void RB::DisplayList::ItemClip::clip(RB::DisplayList::ItemClip *this, CGContextRef *a2)
{
  RB::CGContext::reset_ctm((uint64_t)a2);
  CGRect ClipBoundingBox = CGContextGetClipBoundingBox(*a2);
  CGFloat y = ClipBoundingBox.origin.y;
  CGFloat height = ClipBoundingBox.size.height;
  float32x2_t v11 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.origin);
  float32x2_t v12 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.size);
  RB::Rect::intersect(&v11, *((double *)this + 2), *(float32x2_t *)((char *)this + 24), ClipBoundingBox.size.width, ClipBoundingBox.size.height, v6, v7);
  *(float32x2_t *)v8.i8 = v12;
  uint32x2_t v9 = (uint32x2_t)vclez_f32(v12);
  if ((vpmax_u32(v9, v9).u32[0] & 0x80000000) != 0)
  {
    CGContextClipToRect(*a2, *MEMORY[0x263F001A0]);
  }
  else
  {
    CGRect v10 = this;
    RB::CGContext::add_soft_mask((uint64_t)a2, 0, (uint64_t)&v10, (void (*)(CGContextRef *, uint64_t))RB::CGContext::add_soft_mask<RB::DisplayList::ItemClip::clip(RB::CGContext&)::$_0>(RB::CGContext::SoftMaskMode,RB::Rect,RB::DisplayList::ItemClip::clip(RB::CGContext&)::$_0 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke, v11, v8);
  }
}

void RB::DisplayList::BackdropColorMatrixItem::render(RB::DisplayList::BackdropColorMatrixItem *this, int32x2_t *a2)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  long long v4 = (float32x2_t *)*((void *)this + 3);
  _H8 = *((_WORD *)this + 22);
  __int16 v6 = *((_WORD *)this + 23);
  RB::Bounds::Bounds((int32x2_t *)c, (float32x2_t)0xFEFFFFFFFEFFFFFFLL, (float32x2_t)0x7F7FFFFF7F7FFFFFLL);
  __asm { FCVT            S8, H8 }
  unsigned int v11 = v6 & 0x3F;
  if ((float32x2_t *)a2[11] != v4 || !RB::Bounds::contains(a2 + 12, (int32x2_t)c[0], (int32x2_t)c[1]))
  {
    int v12 = 0;
LABEL_10:
    RB::CGContext::update_state_slow((uint64_t)a2, 0, v4, v11, c, v12, _S8);
    goto LABEL_11;
  }
  int v12 = 1;
  if (a2[10]) {
    goto LABEL_10;
  }
  if (*(float *)&a2[16].i32[1] != _S8 || a2[17].i32[0] != v11) {
    goto LABEL_10;
  }
LABEL_11:
  CGRect ClipBoundingBox = CGContextGetClipBoundingBox((CGContextRef)*(void *)a2);
  CGFloat y = ClipBoundingBox.origin.y;
  CGFloat height = ClipBoundingBox.size.height;
  float32x2_t v45 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.origin);
  float32x2_t v46 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.size);
  *(float32x2_t *)&double v16 = RB::DisplayList::Item::styled_bounds(this, 0);
  RB::Rect::intersect(&v45, v16, v17, v18, v19, v20, v21);
  uint32x2_t v22 = (uint32x2_t)vclez_f32(v46);
  if ((vpmax_u32(v22, v22).u32[0] & 0x80000000) == 0)
  {
    CGImageRef Image = CGBitmapContextCreateImage(*(CGContextRef *)a2);
    unint64_t v24 = Image;
    if (Image)
    {
      size_t Width = CGImageGetWidth(Image);
      size_t v26 = CGImageGetHeight(v24);
      long long v27 = *(_OWORD *)a2[6].i8;
      *(_OWORD *)c = *(_OWORD *)a2[4].i8;
      long long v48 = v27;
      long long v49 = *(_OWORD *)a2[8].i8;
      BOOL v28 = RB::AffineTransform::invert((RB::AffineTransform *)c);
      CGRect v30 = (CGContextRef *)&a2[4];
      if (v28) {
        CGRect v30 = c;
      }
      long long v31 = *(_OWORD *)v30;
      int v32 = (int32x2_t *)&v48;
      if (!v28) {
        int v32 = a2 + 6;
      }
      long long v33 = *(_OWORD *)v32->i8;
      float32x2_t v34 = (int32x2_t *)&v49;
      if (!v28) {
        float32x2_t v34 = a2 + 8;
      }
      long long v35 = *(_OWORD *)v34->i8;
      *(_OWORD *)CFTypeRef cf = v31;
      long long v43 = v33;
      long long v44 = v35;
      *(float *)&v29.i32[1] = (float)v26;
      *(float *)v29.i32 = (float)Width;
      float32x2_t v41 = RB::operator*((float64x2_t *)cf, 0, v29);
      float32x2_t v40 = v36;
      unint64_t v37 = (float16x4_t *)*((void *)this + 6);
      if (!v37 || (RB::ColorMatrix::is_identity(v37 + 1) & 1) != 0)
      {
        unint64_t v38 = v24;
        goto LABEL_22;
      }
      RB::CGContext::begin_bitmap((int8x8_t *)a2, &v45, 2, 0, 0, 0, (CGContext **)cf);
      if (!cf[0]) {
        goto LABEL_23;
      }
      __asm { FMOV            V0.2S, #1.0 }
      RB::CGContext::CGContext(c, cf[0], a2[1].u8[0], _D0);
      v53.origin.CGFloat x = v41.f32[0];
      v53.origin.CGFloat y = v41.f32[1];
      v53.size.CGFloat width = v40.f32[0];
      v53.size.CGFloat height = v40.f32[1];
      CGContextDrawImage(c[0], v53, v24);
      RB::CGContext::apply_color_matrix(c, (float16x4_t *)(*((void *)this + 6) + 8), (**((_DWORD **)this + 6) >> 2) & 1);
      unint64_t v38 = CGBitmapContextCreateImage(c[0]);
      CFRelease(v24);
      float32x2_t v41 = v45;
      float32x2_t v40 = v46;
      RB::CGContext::~CGContext((RB::CGContext *)c);
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      if (v38)
      {
LABEL_22:
        v52.origin.CGFloat x = v41.f32[0];
        v52.origin.CGFloat y = v41.f32[1];
        v52.size.CGFloat width = v40.f32[0];
        v52.size.CGFloat height = v40.f32[1];
        CGContextDrawImage(*(CGContextRef *)a2, v52, v38);
        unint64_t v24 = v38;
LABEL_23:
        CFRelease(v24);
      }
    }
  }
}

void sub_2141E5E80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, CFTypeRef cf, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (cf) {
    CFRelease(cf);
  }
  CFRelease(v21);
  _Unwind_Resume(a1);
}

uint64_t RB::Filter::ColorMatrix::render(float16x4_t *a1, RB::_anonymous_namespace_ **this)
{
  return RB::CGContext::apply_color_matrix(this, a1 + 1, ((unsigned __int32)a1->i32[0] >> 2) & 1);
}

void RB::Filter::LuminanceCurve::render(uint64_t a1, uint64_t a2)
{
}

uint64_t RB::Filter::RGBACurves::render(uint64_t a1, uint64_t a2)
{
  return RBStrokeRef::clip(a2);
}

void RB::Filter::GaussianBlur::render(uint64_t a1, float64x2_t *a2, CFTypeRef *a3)
{
  int v5 = *(_DWORD *)(a1 + 24) & 1;
  float v6 = *(float *)a1;
  float v7 = RB::AffineTransform::scale(a2 + 2) * v6;
  RB::CGContext::apply_blur((uint64_t)a2, v5, a3, v7);
}

void RB::CGContext::add_soft_mask<RB::DisplayList::LayerClip::clip(RB::CGContext&)::$_0>(RB::CGContext::SoftMaskMode,RB::Rect,RB::DisplayList::LayerClip::clip(RB::CGContext&)::$_0 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke(RB::CGContext *a1, uint64_t *a2, double a3, int32x4_t a4)
{
  uint64_t v5 = *a2;
  float v6 = *(float **)(*a2 + 48);
  *(float *)&a3 = v6[12];
  a4.i32[0] = 1.0;
  if (*(float *)&a3 == 0.0) {
    float v7 = 1.0;
  }
  else {
    float v7 = v6[12];
  }
  float32x2_t v8 = RB::DisplayList::Layer::bounds((RB::DisplayList::Layer *)v6, a3, a4);
  RB::Bounds::Bounds(v10, v8, v9);
  RB::CGContext::begin_layer((uint64_t)a1, v7, v10[0], v10[1]);
  RB::DisplayList::Layer::render_items(*(void ***)(v5 + 48), a1, 0);
  RB::CGContext::end_layer((CGContextRef *)a1);
}

uint64_t RB::CGContext::add_soft_mask<RB::DisplayList::ItemClip::clip(RB::CGContext&)::$_0>(RB::CGContext::SoftMaskMode,RB::Rect,RB::DisplayList::ItemClip::clip(RB::CGContext&)::$_0 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)a2 + 48) + 184))(*(void *)(*(void *)a2 + 48), a1);
}

void RB::render_mesh_gradient(RB::RenderPass *a1, float64x2_t *a2, RB::Fill::MeshGradient *this, __int16 a4, int a5, char a6, int32x2_t *a7, float a8)
{
  uint64_t v67 = *MEMORY[0x263EF8340];
  if (*((_DWORD *)a1 + 34) == 2) {
    int v15 = 131092;
  }
  else {
    int v15 = 20;
  }
  int8x8_t v61 = (int8x8_t)(v15 & 0xFFFF003F | ((a4 & 0x3FF) << 6));
  RB::Fill::MeshGradient::set_fill_state((uint64_t)this, (RB::RenderState *)&v61, a1, a8, 0);
  if (a5) {
    int v16 = 0x10000;
  }
  else {
    int v16 = 0;
  }
  int8x8_t v61 = vorr_s8(vand_s8(v61, (int8x8_t)0xFFFFFFC0FFFEFFFFLL), (int8x8_t)__PAIR64__(a6 & 0x3F, v16));
  float64x2_t v17 = a2[1];
  float64x2_t v58 = *a2;
  float64x2_t v59 = v17;
  float64x2_t v60 = a2[2];
  double v18 = (float64x2_t *)*((void *)this + 2);
  if (v18)
  {
    v19.f64[0] = RB::operator*(v18, &v58);
    float64x2_t v58 = v19;
    float64x2_t v59 = v20;
    float64x2_t v60 = v21;
  }
  long long v57 = *(_OWORD *)a7->i8;
  RB::Bounds::intersect((int32x2_t *)&v57, *(int32x2_t *)((char *)a1 + 160), *(int32x2_t *)((char *)a1 + 168));
  float32x2_t v22 = *(float32x2_t *)((char *)a1 + 112);
  v22.i32[1] = vneg_f32(v22).i32[1];
  *(float32x2_t *)&long long v54 = vmul_f32(v22, vcvt_f32_f64(v58));
  *((float32x2_t *)&v54 + 1) = vmul_f32(v22, vcvt_f32_f64(v59));
  *(float32x2_t *)&v55[0] = vmla_f32((float32x2_t)0x3F800000BF800000, vcvt_f32_f64(v60), v22);
  DWORD2(v55[0]) = *((_DWORD *)a1 + 30);
  uint64_t v65 = 0;
  uint64_t v66 = 0x400000000;
  unsigned int buffers = RB::Fill::MeshGradient::make_buffers((int32x2_t *)this, (uint64_t)v64, (uint64_t)v55 + 12, (RB::RenderFrame ***)a1, (uint64_t)&v58, a7, a8);
  if (v66)
  {
    unsigned int v25 = buffers;
    uint64_t v26 = RB::Fill::MeshGradient::primitive_type(this);
    if (v27)
    {
      if (v65) {
        BOOL v28 = v65;
      }
      else {
        BOOL v28 = v64;
      }
      if (v66)
      {
        uint64_t v29 = v26;
        CGRect v30 = &v28[32 * v66];
        unsigned int v31 = v25 - 1;
        do
        {
          HIDWORD(v55[0]) = v31;
          RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x34, 4uLL, 0, v53);
          int v32 = v53[0];
          if (v53[0])
          {
            long long v33 = (char *)v53[1] + *((void *)v53[0] + 7);
            long long v34 = v54;
            long long v35 = v55[0];
            long long v36 = v55[1];
            *((_DWORD *)v33 + 12) = v56;
            *((_OWORD *)v33 + 1) = v35;
            *((_OWORD *)v33 + 2) = v36;
            *(_OWORD *)long long v33 = v34;
          }
          else
          {
            memset(v53, 0, 24);
          }
          *((_DWORD *)a1 + 46) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v32);
          *(int32x2_t *)((char *)a1 + 188) = vmovn_s64(*(int64x2_t *)&v53[1]);
          *((_DWORD *)a1 + 49) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, *(RB::Buffer **)v28);
          *((int32x2_t *)a1 + 25) = vmovn_s64(*(int64x2_t *)(v28 + 8));
          *((_DWORD *)a1 + 55) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, *(RB::Buffer **)v28);
          *((int32x2_t *)a1 + 28) = vmovn_s64(*(int64x2_t *)(v28 + 8));
          RB::RenderPass::draw_primitives((int32x2_t *)a1, *(const char **)&v61, v29, 0, *((unsigned int *)v28 + 7), 1, *(int32x2_t *)&v57, *(int32x2_t *)((char *)&v57 + 8));
          v28 += 32;
        }
        while (v28 != v30);
      }
    }
    else
    {
      v53[0] = (RB::Buffer *)&v54;
      v53[1] = (RB::Buffer *)v64;
      void v53[2] = a1;
      v53[3] = (RB::Buffer *)&v57;
      if (*((_DWORD *)a1 + 34) == 2) {
        unsigned int v37 = 131100;
      }
      else {
        unsigned int v37 = 28;
      }
      unint64_t v62 = (RB::Buffer *)v37;
      RB::Fill::MeshGradient::set_fill_state((uint64_t)this, (RB::RenderState *)&v62, a1, a8, 1);
      *((_WORD *)a1 + 88) = 517;
      *((_DWORD *)a1 + 45) = 0;
      RB::render_mesh_gradient(RB::RenderPass &,RB::AffineTransform const&,RB::Fill::MeshGradient const&,RB::Shader::AccumulatorCoverageState,BOOL,float,RB::BlendMode,RB::Bounds const&)::$_0::operator()((int32x2_t *)v53, (const char **)&v62, 0);
      *((_WORD *)a1 + 88) = 262;
      *((_DWORD *)a1 + 45) = 0;
      RB::render_mesh_gradient(RB::RenderPass &,RB::AffineTransform const&,RB::Fill::MeshGradient const&,RB::Shader::AccumulatorCoverageState,BOOL,float,RB::BlendMode,RB::Bounds const&)::$_0::operator()((int32x2_t *)v53, (const char **)&v61, 1);
      *((unsigned char *)a1 + 177) = 0;
      *((float *)a1 + 30) = *((float *)a1 + 30) + (float)v25;
    }
    v24.i32[1] = 0;
    *(void *)((char *)a1 + 196) = 0;
    *((_DWORD *)a1 + 51) = 0;
    *(void *)((char *)a1 + 220) = 0;
    *((_DWORD *)a1 + 57) = 0;
  }
  v24.i32[0] = 0;
  uint32x2_t v38 = (uint32x2_t)vceq_s32(*(int32x2_t *)((char *)&v57 + 8), (int32x2_t)0x8000000080000000);
  int8x8_t v39 = (int8x8_t)vdup_lane_s32(vcgt_s32(v24, (int32x2_t)vpmin_u32(v38, v38)), 0);
  RB::Coverage::set_plane((float32x2_t *)v53, (float32x2_t *)a1, (float32x2_t)vbsl_s8(v39, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v57)), COERCE_DOUBLE(vbsl_s8(v39, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(*(int32x2_t *)((char *)&v57 + 8)))));
  uint64_t v51 = *(void *)((char *)this + 28);
  __int16 v52 = *((_WORD *)this + 18);
  _H0 = HIWORD(v51);
  __asm { FCVT            S0, H0 }
  *(float *)&_D0 = _S0 * a8;
  __asm { FCVT            H0, S0 }
  HIWORD(v51) = LOWORD(_D0);
  *(float16x4_t *)((char *)&v53[3] + 4) = RB::Fill::Color::prepare((uint64_t)&v51, *((unsigned __int8 *)a1 + 124), _D0);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x24, 4uLL, 0, &v62);
  float32x2_t v47 = v62;
  if (v62)
  {
    uint64_t v48 = *((void *)v62 + 7) + v63.i64[0];
    long long v49 = *(_OWORD *)v53;
    long long v50 = *(_OWORD *)&v53[2];
    *(_DWORD *)(v48 + 32) = v53[4];
    *(_OWORD *)uint64_t v48 = v49;
    *(_OWORD *)(v48 + 16) = v50;
  }
  else
  {
    unint64_t v62 = 0;
    int64x2_t v63 = 0uLL;
  }
  *((_DWORD *)a1 + 46) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v47);
  *(int32x2_t *)((char *)a1 + 188) = vmovn_s64(v63);
  v61.i32[0] = v61.i32[0] & 0xFFFC0 | 0x12;
  RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, *(const char **)&v61, 4, ***(void ***)a1 + 80, 0, 1uLL, *(int32x2_t *)&v57, *(int32x2_t *)((char *)&v57 + 8));
  if (v65) {
    free(v65);
  }
}

void sub_2141E64D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52)
{
  if (a52) {
    free(a52);
  }
  _Unwind_Resume(exception_object);
}

int32x2_t *RB::render_mesh_gradient(RB::RenderPass &,RB::AffineTransform const&,RB::Fill::MeshGradient const&,RB::Shader::AccumulatorCoverageState,BOOL,float,RB::BlendMode,RB::Bounds const&)::$_0::operator()(int32x2_t *result, const char **a2, int a3)
{
  int v3 = *(_DWORD *)(*(void *)&result[1] + 136);
  if (v3)
  {
    float v6 = result;
    int v7 = *(_DWORD *)(*(void *)result + 36) + 1;
    unsigned int v8 = v3 - 1;
    do
    {
      int32x2_t v9 = v6[1];
      if (*(void *)(*(void *)&v9 + 128)) {
        int32x2_t v10 = *(int32x2_t *)(*(void *)&v9 + 128);
      }
      else {
        int32x2_t v10 = v6[1];
      }
      uint64_t v11 = v8;
      if (!a3 || *(_DWORD *)(*(void *)&v9 + 136) != 1)
      {
        uint64_t v12 = *(void *)&v10 + 32 * v8;
        int32x2_t v13 = v6[2];
        unsigned int v14 = *(_DWORD *)(v12 + 24);
        int32x2_t v15 = *v6;
        *(float *)(*(void *)&v15 + 24) = *(float *)(*(void *)&v13 + 120) + (float)v14;
        *(_DWORD *)(*(void *)&v15 + 28) = (*(_DWORD *)(v12 + 28) + v14) * v7 - 1;
        *(_WORD *)(*(void *)&v15 + 40) = v14;
        RB::RenderFrame::alloc_buffer_region(***(RB::RenderFrame ****)&v13, (RB::Device *)0x34, 4uLL, 0, &v23);
        int v16 = v23;
        if (v23)
        {
          uint64_t v17 = *((void *)v23 + 7) + v24.i64[0];
          long long v18 = *(_OWORD *)*(void *)&v15;
          long long v19 = *(_OWORD *)(*(void *)&v15 + 16);
          long long v20 = *(_OWORD *)(*(void *)&v15 + 32);
          *(_DWORD *)(v17 + 48) = *(_DWORD *)(*(void *)&v15 + 48);
          *(_OWORD *)(v17 + 16) = v19;
          *(_OWORD *)(v17 + 32) = v20;
          *(_OWORD *)uint64_t v17 = v18;
        }
        else
        {
          uint64_t v23 = 0;
          int64x2_t v24 = 0uLL;
        }
        *(_DWORD *)(*(void *)&v13 + 184) = RB::RenderFrame::buffer_id(***(RB::RenderFrame ****)&v13, v16);
        *(int32x2_t *)(*(void *)&v13 + 188) = vmovn_s64(v24);
        int32x2_t v21 = v6[2];
        *(_DWORD *)(*(void *)&v21 + 196) = RB::RenderFrame::buffer_id(***(RB::RenderFrame ****)&v21, *(RB::Buffer **)v12);
        *(int32x2_t *)(*(void *)&v21 + 200) = vmovn_s64(*(int64x2_t *)(v12 + 8));
        int32x2_t v22 = v6[2];
        *(_DWORD *)(*(void *)&v22 + 220) = RB::RenderFrame::buffer_id(***(RB::RenderFrame ****)&v22, *(RB::Buffer **)v12);
        *(int32x2_t *)(*(void *)&v22 + 224) = vmovn_s64(*(int64x2_t *)(v12 + 8));
      }
      double result = RB::RenderPass::draw_indexed_primitives(*(int32x2_t **)&v6[2], *a2, 4, ****(void ****)&v6[2] + 80, 0, (*(_DWORD *)(*(void *)&v10 + 32 * v8-- + 28) * v7), *(int32x2_t *)v6[3], *(int32x2_t *)(*(void *)&v6[3] + 8));
    }
    while (v11);
  }
  return result;
}

uint64_t RB::disable_workaround(RB *this, const char *a2)
{
  {
    RB::disable_workaround(char const*)::names = RB::disable_workaround(char const*)::$_0::operator()();
  }
  if (!RB::disable_workaround(char const*)::names) {
    return 0;
  }
  uint64_t v3 = *(void *)(RB::disable_workaround(char const*)::names + 8);
  if (!v3) {
    return 0;
  }
  long long v4 = *(const char ***)RB::disable_workaround(char const*)::names;
  uint64_t v5 = 8 * v3;
  while (1)
  {
    float v6 = *v4;
    if (**v4 == 10 && !v6[1]) {
      break;
    }
    if (!strcasecmp(v6, (const char *)this)) {
      break;
    }
    ++v4;
    v5 -= 8;
    if (!v5) {
      return 0;
    }
  }
  return 1;
}

uint64_t RB::disable_workaround(char const*)::$_0::operator()()
{
  v8[1] = *(const __CFString **)MEMORY[0x263EF8340];
  RB::Config::debug_value((RB::Config *)"RB_DISABLE_WORKAROUNDS", v8);
  if (v8[0])
  {
    unsigned __int16 v1 = RB::Config::BOOL_value(v8[0], v0);
    if (v1 >= 0x100u)
    {
      if ((_BYTE)v1) {
        operator new();
      }
    }
    else
    {
      CFTypeID v2 = CFGetTypeID(v8[0]);
      TypeIOSurfaceID ID = CFStringGetTypeID();
      if (v2 == TypeID)
      {
        CFStringRef v5 = v8[0];
        MEMORY[0x270FA5388](TypeID, v4);
        bzero(v7, 0x1000uLL);
        if (CFStringGetCString(v5, v7, 4096, 0x8000100u)) {
          operator new();
        }
      }
    }
    if (v8[0]) {
      CFRelease(v8[0]);
    }
  }
  return 0;
}

float RB::bezier_flatness(RB *this)
{
  {
    RB::bezier_flatness(void)::flatness = RB::debug_float((RB *)"RB_FLATNESS", v2);
  }
  float result = *(float *)&RB::bezier_flatness(void)::flatness;
  if (*(float *)&RB::bezier_flatness(void)::flatness < 0.01) {
    float result = 0.01;
  }
  if (!BYTE4(RB::bezier_flatness(void)::flatness)) {
    return 0.25;
  }
  return result;
}

float RB::bezier_flatness(RB *a1)
{
  char v1 = (char)a1;
  float result = RB::bezier_flatness(a1);
  if ((v1 & 0xFE) == 2) {
    return result * 0.5;
  }
  return result;
}

const char *RB::parse_byte_size(RB *this, const char *a2, unint64_t a3, unint64_t a4)
{
  if (!this) {
    return a2;
  }
  uint64_t v12 = 0;
  double v8 = strtod((const char *)this, &v12);
  if (v12 == (char *)this) {
    return a2;
  }
  unsigned int v9 = *v12 - 71;
  if (v9 <= 0x26)
  {
    if (((1 << v9) & 0x100000001) != 0)
    {
      double v8 = v8 * 1024.0;
    }
    else
    {
      if (((1 << v9) & 0x1000000010) != 0)
      {
LABEL_10:
        double v8 = v8 * 1024.0;
        goto LABEL_11;
      }
      if (((1 << v9) & 0x4000000040) == 0) {
        goto LABEL_11;
      }
    }
    double v8 = v8 * 1024.0;
    goto LABEL_10;
  }
LABEL_11:
  unint64_t v10 = (unint64_t)v8;
  if ((unint64_t)v8 >= a4) {
    unint64_t v10 = a4;
  }
  if (v10 <= a3) {
    return (const char *)a3;
  }
  else {
    return (const char *)v10;
  }
}

const char *RB::blend_name(unsigned int a1)
{
  if (a1 > 0x2F) {
    return "unknown";
  }
  else {
    return (&off_2641F9360)[a1];
  }
}

uint64_t RB::interpolation_mode_uses_mipmaps(unsigned int a1)
{
  return (a1 < 0xA) & (0x248u >> a1);
}

uint64_t RB::interpolation_mode_without_mipmaps(int a1)
{
  if (a1 == 3) {
    int v1 = 2;
  }
  else {
    int v1 = a1;
  }
  if (a1 == 6) {
    unsigned int v2 = 5;
  }
  else {
    unsigned int v2 = v1;
  }
  if (a1 == 9) {
    return 8;
  }
  else {
    return v2;
  }
}

const char *RB::color_space_name(int a1)
{
  if ((a1 - 1) > 4) {
    return "sRGBLinear";
  }
  else {
    return (&off_2641F94E0)[(char)(a1 - 1)];
  }
}

uint64_t RB::linear_srgb_colorspace(RB *this)
{
  {
    if (v3)
    {
      RB::linear_srgb_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x263F002C8]);
    }
  }
  return v1[24];
}

uint64_t RB::extended_linear_srgb_colorspace(RB *this)
{
  int v1 = &color_symbols(void)::flag;
  {
    int v1 = &color_symbols(void)::flag;
    if (v3)
    {
      RB::extended_linear_srgb_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x263F00230]);
      int v1 = &color_symbols(void)::flag;
    }
  }
  return *((void *)v1 + 32);
}

uint64_t RB::display_p3_colorspace(RB *this)
{
  unint64_t v1 = 0x267806000uLL;
  {
    unint64_t v1 = 0x267806000;
    if (v3)
    {
      RB::display_p3_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x263F001E8]);
      unint64_t v1 = 0x267806000;
    }
  }
  return *(void *)(v1 + 3768);
}

uint64_t RB::extended_display_p3_colorspace(RB *this)
{
  {
    if (v3)
    {
      RB::extended_display_p3_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x263F00200]);
    }
  }
  return v1[26];
}

uint64_t RB::extended_linear_display_p3_colorspace(RB *this)
{
  {
    if (v3)
    {
      RB::extended_linear_display_p3_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x263F00218]);
    }
  }
  return v1[28];
}

uint64_t RB::linear_display_p3_colorspace(RB *this)
{
  {
    if (v3)
    {
      RB::linear_display_p3_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x263F002B0]);
    }
  }
  return v1[30];
}

uint64_t RB::pq_colorspace(RB *this)
{
  {
    if (v3)
    {
      RB::pq_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x263F00290]);
    }
  }
  return v1[32];
}

uint64_t RB::gray_colorspace(RB *this)
{
  {
    if (v3)
    {
      RB::gray_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x263F00250]);
    }
  }
  return v1[34];
}

uint64_t RB::color_space_from_cg_name(RB *this, const __CFString *a2)
{
  if (!this)
  {
    int v3 = 0;
    int v4 = 0;
    return v3 | (v4 << 8);
  }
  if (CFEqual(this, (CFTypeRef)*MEMORY[0x263F002D8]) || CFEqual(this, (CFTypeRef)*MEMORY[0x263F00238]))
  {
    int v3 = 1;
LABEL_5:
    int v4 = 1;
    return v3 | (v4 << 8);
  }
  if (CFEqual(this, (CFTypeRef)*MEMORY[0x263F002C8]) || CFEqual(this, (CFTypeRef)*MEMORY[0x263F00230]))
  {
    int v3 = 0;
    goto LABEL_5;
  }
  if (CFEqual(this, (CFTypeRef)*MEMORY[0x263F001E8]) || CFEqual(this, (CFTypeRef)*MEMORY[0x263F00200]))
  {
    int v4 = 1;
    int v3 = 3;
  }
  else if (CFEqual(this, (CFTypeRef)*MEMORY[0x263F002B0]))
  {
    int v4 = 1;
    int v3 = 2;
  }
  else
  {
    int v4 = CFEqual(this, (CFTypeRef)*MEMORY[0x263F00218]) != 0;
    int v3 = 2 * v4;
  }
  return v3 | (v4 << 8);
}

uint64_t RB::color_space_from_cg(RB *this, CGColorSpace *a2)
{
  if (this)
  {
    Name = (RB *)CGColorSpaceGetName(this);
    LOWORD(this) = RB::color_space_from_cg_name(Name, v3);
    int v4 = BYTE1(this);
  }
  else
  {
    int v4 = 0;
  }
  return this | (v4 << 8);
}

RB *RB::cg_image_alpha_mask(RB *this, CGImage *a2)
{
  if (CGImageIsMask(this)) {
    return this;
  }
  PropertCGFloat y = (const void *)CGImageGetProperty();
  if (!Property)
  {
    unint64_t Width = CGImageGetWidth(this);
    unint64_t Height = CGImageGetHeight(this);
    float v6 = CGBitmapContextCreate(0, Width, Height, 8uLL, 0, 0, 7u);
    if (v6)
    {
      int v7 = v6;
      v9.origin.CGFloat x = 0.0;
      v9.origin.CGFloat y = 0.0;
      v9.size.CGFloat width = (double)Width;
      v9.size.CGFloat height = (double)Height;
      CGContextClearRect(v6, v9);
      CGContextSetBlendMode(v7, kCGBlendModeCopy);
      v10.origin.CGFloat x = 0.0;
      v10.origin.CGFloat y = 0.0;
      v10.size.CGFloat width = (double)Width;
      v10.size.CGFloat height = (double)Height;
      CGContextDrawImage(v7, v10, this);
      PropertCGFloat y = CGBitmapContextCreateImage(v7);
      if (Property)
      {
        CGImageSetProperty();
        CFRelease(Property);
      }
      CFRelease(v7);
    }
    else
    {
      return 0;
    }
  }
  return (RB *)Property;
}

void RB::cg_image_create_placeholder(RB *this)
{
}

uint64_t RB::cg_image_create_placeholder(unsigned long,unsigned long,unsigned long,BOOL)::$_0::__invoke(uint64_t a1)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  if (!*(void *)(a1 + 48))
  {
    CFStringRef v3 = (char *)malloc_type_malloc(*(void *)(a1 + 40), 0x88224499uLL);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = 0;
      v19[0] = *(_WORD *)a1;
      v19[1] = 33 * v19[0];
      void v19[2] = 1089 * v19[0];
      do
        v20[v5++] = (int)(erand48(v19) * 255.0 + 0.5);
      while (v5 != 6);
      char v22 = v21;
      if (*(unsigned char *)(a1 + 24)) {
        char v6 = 127;
      }
      else {
        char v6 = -1;
      }
      unint64_t v7 = *(void *)(a1 + 8);
      unint64_t v8 = *(void *)(a1 + 16);
      if (v7 <= v8) {
        unint64_t v9 = *(void *)(a1 + 16);
      }
      else {
        unint64_t v9 = *(void *)(a1 + 8);
      }
      char v21 = -1;
      char v23 = v6;
      unint64_t v10 = 64;
      unint64_t v11 = 6;
      long long v18 = v4;
      while (v10 >= v9 >> 1)
      {
        unint64_t v10 = 1 << --v11;
        if (v11 <= 2)
        {
          LOBYTE(v11) = 2;
          break;
        }
      }
      if (v8)
      {
        for (unint64_t i = 0; i < v8; i += v10)
        {
          if (v7)
          {
            uint64_t v13 = 0;
            unint64_t v14 = 0;
            uint64_t v15 = (i >> v11) & 1;
            int v16 = &v18[*(void *)(a1 + 32) * i];
            do
            {
              CGBlt_fillBytes();
              v14 += v10;
              v15 ^= 1uLL;
              unint64_t v7 = *(void *)(a1 + 8);
              v16 += 4 * v10;
              v13 -= v10;
            }
            while (v14 < v7);
            unint64_t v8 = *(void *)(a1 + 16);
          }
        }
      }
      uint64_t v17 = 0;
      atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 48), (unint64_t *)&v17, (unint64_t)v18);
      if (v17) {
        free(v18);
      }
    }
  }
  return *(void *)(a1 + 48);
}

uint64_t RB::cg_image_create_placeholder(unsigned long,unsigned long,unsigned long,BOOL)::$_1::__invoke(uint64_t result)
{
  if (result)
  {
    free(*(void **)(result + 48));
    JUMPOUT(0x21669AC10);
  }
  return result;
}

void RB::cg_draw_9_slice_image(CGContextRef c, CGImageRef image, float32x4_t *a3, float32x2_t *a4, int a5, int a6)
{
  uint64_t v83 = *MEMORY[0x263EF8340];
  __asm { FMOV            V8.2S, #1.0 }
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(*a3)))) & 1) == 0
    && (float32x2_t v16 = a4[1], v17 = (uint32x2_t)vceq_f32(v16, _D8), (vpmin_u32(v17, v17).u32[0] & 0x80000000) != 0))
  {
    double v52 = COERCE_FLOAT(*a4);
    double v53 = COERCE_FLOAT(HIDWORD(*(unint64_t *)a4));
    double v54 = v16.f32[0];
    double v55 = v16.f32[1];
    CGContextDrawImage(c, *(CGRect *)&v52, image);
  }
  else
  {
    CGContextSaveGState(c);
    CGContextBeginTransparencyLayer(c, 0);
    CGContextSetBlendMode(c, kCGBlendModeCopy);
    CGContextSetShouldAntialias(c, 0);
    float Width = (float)CGImageGetWidth(image);
    size_t Height = CGImageGetHeight(image);
    *(float *)&long long v23 = (float)Height;
    v24.f32[0] = Width;
    long long v56 = v23;
    v81[0] = 0;
    float v82 = Width;
    LODWORD(v23) = a3->i32[0];
    LODWORD(v28) = a3->i32[1];
    *(float *)&v81[1] = a3->f32[0] * Width;
    *(float *)&float64x2_t v81[2] = v82 - (float)(*(float *)&v28 * v82);
    float32x2_t v25 = *a4;
    float32x2_t v26 = vadd_f32(a4[1], *a4);
    float v27 = COERCE_FLOAT(*a4) + *(float *)&v23;
    *(float *)&long long v28 = v26.f32[0] - *(float *)&v28;
    if (v27 < COERCE_FLOAT(*a4)) {
      LODWORD(v27) = *(float32x2_t *)a4->f32;
    }
    if (v27 > v26.f32[0]) {
      float v27 = v26.f32[0];
    }
    int v76 = (int)*a4;
    float v77 = v27;
    float32x2_t v58 = v25;
    if (*(float *)&v28 < v25.f32[0]) {
      *(float *)&long long v28 = v25.f32[0];
    }
    if (*(float *)&v28 > v26.f32[0]) {
      *(float *)&long long v28 = v26.f32[0];
    }
    float v78 = *(float *)&v28;
    __int32 v79 = v26.i32[0];
    if (v27 > *(float *)&v28)
    {
      float v77 = (float)(*(float *)&v28 + v27) * 0.5;
      float v78 = v77;
    }
    v80[0] = 0;
    long long v29 = v56;
    v80[3] = v56;
    float v30 = a3->f32[2];
    float v31 = a3->f32[3];
    *(float *)&v80[1] = v30 * *(float *)&v56;
    *(float *)&v80[2] = *(float *)&v29 - (float)(v31 * *(float *)&v29);
    __int32 v72 = v58.i32[1];
    float v32 = v58.f32[1];
    __int32 v75 = v26.i32[1];
    v26.f32[0] = v30 + v58.f32[1];
    float v33 = v26.f32[1] - v31;
    if (v26.f32[0] < v58.f32[1]) {
      v26.f32[0] = v58.f32[1];
    }
    if (v26.f32[0] > v26.f32[1]) {
      v26.f32[0] = v26.f32[1];
    }
    if (v33 < v58.f32[1]) {
      float v33 = v58.f32[1];
    }
    if (v33 > v26.f32[1]) {
      float v33 = v26.f32[1];
    }
    float v73 = v26.f32[0];
    float v74 = v33;
    if (v26.f32[0] > v33)
    {
      float v73 = (float)(v33 + v26.f32[0]) * 0.5;
      float v74 = v73;
    }
    uint64_t v34 = 0;
    v24.f32[1] = (float)Height;
    float32x2_t v59 = vdiv_f32(_D8, v24);
    float v35 = 1.0;
    float32x2_t v36 = 0;
    do
    {
      LODWORD(v29) = 0;
      DWORD1(v29) = v36.i32[0];
      uint64_t v37 = v34 + 1;
      LODWORD(v20) = 0;
      *((float *)&v20 + 1) = *(float *)&v80[v34 + 1] - v36.f32[0];
      __int32 v60 = v80[v34 + 1];
      if (*((float *)&v20 + 1) <= 0.0)
      {
        *((float *)&v20 + 1) = v35;
        *((float *)&v29 + 1) = v36.f32[0] + -0.5;
      }
      float v38 = *((float *)&v72 + v37);
      if ((float)(v38 - v32) > 0.0)
      {
        if (a6)
        {
          *((void *)&v28 + 1) = *((void *)&v56 + 1);
          *((float *)&v29 + 1) = *(float *)&v56
                               - COERCE_FLOAT(vadd_f32(*(float32x2_t *)&v29, *(float32x2_t *)&v20).i32[1]);
        }
        uint64_t v39 = 0;
        LODWORD(v40) = 0;
        *((float *)&v40 + 1) = v32;
        LODWORD(v28) = 0;
        *((float *)&v28 + 1) = v38 - v32;
        float v41 = 0.0;
        float v42 = v58.f32[0];
        do
        {
          *(void *)&long long v22 = v40;
          *(float *)&long long v21 = v42;
          *(float *)&long long v29 = v41;
          uint64_t v43 = v39 + 1;
          float v41 = *(float *)&v81[v39 + 1];
          v36.f32[0] = v41 - *(float *)&v29;
          *(float *)&long long v20 = v41 - *(float *)&v29;
          float32x2_t v36 = (float32x2_t)vdup_lane_s32(vcgt_f32(v36, 0), 0);
          v44.i32[1] = DWORD1(v29);
          *(float *)v44.i32 = *(float *)&v29 + -0.5;
          *(int8x8_t *)&long long v29 = vbsl_s8((int8x8_t)v36, *(int8x8_t *)&v29, v44);
          *(int8x8_t *)&long long v20 = vbsl_s8((int8x8_t)v36, *(int8x8_t *)&v20, (int8x8_t)__PAIR64__(DWORD1(v20), LODWORD(v35)));
          long long v40 = v22;
          *(float *)&long long v40 = v42;
          float v42 = *((float *)&v76 + v39 + 1);
          *(float *)&long long v19 = v42 - *(float *)&v40;
          if ((float)(v42 - *(float *)&v40) > 0.0)
          {
            long long v61 = v40;
            long long v62 = v19;
            long long v63 = v29;
            long long v64 = v20;
            long long v65 = v28;
            if (a5 && ((v39 | v34) & 1) != 0)
            {
              v85.origin.CGFloat x = *(float *)&v29;
              v85.origin.CGFloat y = *((float *)&v29 + 1);
              v85.size.CGFloat width = *(float *)&v20;
              v85.size.CGFloat height = *((float *)&v20 + 1);
              long long v66 = v21;
              float v71 = *((float *)&v22 + 1);
              float32x2_t v45 = CGImageCreateWithImageInRect(image, v85);
              CGContextSaveGState(c);
              v86.origin.CGFloat x = *(float *)&v66;
              v86.origin.CGFloat y = v71;
              v86.size.CGFloat width = *(float *)&v62;
              v86.size.CGFloat height = *((float *)&v65 + 1);
              CGContextClipToRect(c, v86);
              float v46 = v71 + *((float *)&v65 + 1);
              if (v71 < (float)(v71 + *((float *)&v65 + 1)))
              {
                long long v47 = v61;
                float32x2_t v48 = vmul_f32(*(float32x2_t *)&v64, v59);
                double v49 = v48.f32[0];
                double v50 = v48.f32[1];
                float32x2_t v67 = v48;
                do
                {
                  long long v51 = v66;
                  LODWORD(v47) = v66;
                  if (*(float *)&v66 < v42)
                  {
                    do
                    {
                      long long v68 = v47;
                      long long v70 = v51;
                      v87.origin.CGFloat x = *(float *)&v51;
                      v87.origin.CGFloat y = *((float *)&v47 + 1);
                      v87.size.CGFloat width = v49;
                      v87.size.CGFloat height = v50;
                      CGContextDrawImage(c, v87, v45);
                      long long v47 = v68;
                      long long v51 = v70;
                      float32x2_t v48 = v67;
                      *(float *)&long long v51 = *(float *)&v70 + v67.f32[0];
                      *(float *)&long long v47 = *(float *)&v70 + v67.f32[0];
                    }
                    while ((float)(*(float *)&v70 + v67.f32[0]) < v42);
                  }
                  DWORD1(v47) = vadd_f32(*(float32x2_t *)&v47, v48).i32[1];
                }
                while (*((float *)&v47 + 1) < v46);
              }
              CGContextRestoreGState(c);
              CGImageRelease(v45);
              float v35 = 1.0;
              long long v29 = v63;
              long long v20 = v64;
              long long v28 = v65;
              *(void *)&long long v40 = v61;
              long long v19 = v62;
            }
            else
            {
              CGContextDrawImageFromRect();
              long long v19 = v62;
              long long v29 = v63;
              long long v20 = v64;
              long long v28 = v65;
              float v35 = 1.0;
              *(void *)&long long v40 = v61;
            }
          }
          LODWORD(v28) = v19;
          uint64_t v39 = v43;
        }
        while (v43 != 3);
      }
      float v32 = v38;
      v36.i32[0] = v60;
      ++v34;
    }
    while (v37 != 3);
    CGContextEndTransparencyLayer(c);
    CGContextSaveGState(c);
  }
}

void RB::cg_font_create_with_name(const __CFString *this@<X0>, CGFontRef *a2@<X8>)
{
  CFStringRef v3 = this;
  if (CFStringHasPrefix(this, @".SFNS"))
  {
    CFIndex Length = CFStringGetLength(@".SFNS");
    v12.length = CFStringGetLength(v3) - Length;
    v12.location = Length;
    CFStringRef v6 = CFStringCreateWithSubstring(0, v3, v12);
    CFStringRef v7 = CFStringCreateWithFormat(0, 0, @"%@%@", @".SFUI", v6);
    if (v6) {
      CFRelease(v6);
    }
    CFStringRef v3 = v7;
  }
  else
  {
    CFStringRef v7 = 0;
  }
  unint64_t v8 = CTFontCreateWithNameAndOptions(v3, 0.0, 0, 0x20000uLL);
  if (v8)
  {
    unint64_t v9 = v8;
    CGFontRef v10 = CTFontCopyGraphicsFont(v8, 0);
    CFRelease(v9);
  }
  else
  {
    CGFontRef v10 = 0;
  }
  *a2 = v10;
  if (v7)
  {
    CFRelease(v7);
  }
}

void *RB::cg_font_get_normalized_path_cache(RB *this, CGFont *a2)
{
  unsigned int AssociatedObject = objc_getAssociatedObject(this, "com.apple.RenderBox.normalizedGlyphPaths");
  if (!AssociatedObject)
  {
    unsigned int AssociatedObject = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x263EFFF90]);
    objc_setAssociatedObject(this, "com.apple.RenderBox.normalizedGlyphPaths", AssociatedObject, (void *)1);
    CFRelease(AssociatedObject);
  }
  return AssociatedObject;
}

uint64_t RB::cg_font_get_path_cache_for_stroking(RB *this, CGFont *a2)
{
  return 0;
}

void RB::cg_font_get_glyph_path(RB *this@<X0>, CGFont *a2@<X1>, const __CFDictionary *a3@<X2>, void *a4@<X8>)
{
  unsigned int v5 = a2;
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (!a3)
  {
    *a4 = CGFontCreateGlyphPath();
    return;
  }
  unint64_t v9 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)&RB::cg_font_get_glyph_path(CGFont *,unsigned short,__CFDictionary *)::cache_lock);
  v16[0] = 0;
  if (CFDictionaryGetValueIfPresent(a3, (const void *)v5, v16))
  {
    CGFontRef v10 = (const CGPath *)v16[0];
    if (v16[0] == (const void *)*MEMORY[0x263EFFD08])
    {
      CGFontRef v10 = 0;
      v16[0] = 0;
    }
    *a4 = CGPathRetain(v10);
    os_unfair_lock_unlock((os_unfair_lock_t)&RB::cg_font_get_glyph_path(CGFont *,unsigned short,__CFDictionary *)::cache_lock);
    return;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&RB::cg_font_get_glyph_path(CGFont *,unsigned short,__CFDictionary *)::cache_lock);
  *a4 = 0;
  GlyphPath = (const CGPath *)CGFontCreateGlyphPath();
  if (GlyphPath)
  {
    if ((RB::disable_workaround((RB *)"jitter-glyph-paths", v11) & 1) == 0)
    {
      double v13 = 0.0625 / (double)CGFontGetUnitsPerEm(this);
      v16[0] = CGPathCreateMutable();
      v16[1] = *(const void **)&v13;
      *(double *)&float64x2_t v16[2] = v13 * -0.5;
      long long v17 = 0u;
      long long v18 = 0u;
      int v19 = 1450709556;
      __int16 v20 = -25924;
      unint64_t v14 = (const CGPath *)v16[0];
      CFRelease(GlyphPath);
      GlyphPath = v14;
    }
    CGPathRef CopyByNormalizing = CGPathCreateCopyByNormalizing(GlyphPath, 0);
    *a4 = CopyByNormalizing;
    os_unfair_lock_lock((os_unfair_lock_t)&RB::cg_font_get_glyph_path(CGFont *,unsigned short,__CFDictionary *)::cache_lock);
    if (CopyByNormalizing) {
      goto LABEL_14;
    }
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)&RB::cg_font_get_glyph_path(CGFont *,unsigned short,__CFDictionary *)::cache_lock);
  }
  CGPathRef CopyByNormalizing = (CGPathRef)*MEMORY[0x263EFFD08];
LABEL_14:
  CFDictionarySetValue(a3, (const void *)v9, CopyByNormalizing);
  os_unfair_lock_unlock((os_unfair_lock_t)&RB::cg_font_get_glyph_path(CGFont *,unsigned short,__CFDictionary *)::cache_lock);
  if (GlyphPath) {
    CFRelease(GlyphPath);
  }
}

vImage_Error RB::cg_mask_apply_transfer(vImage_Error this, CGContext *a2, CGFunction *a3)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (a2)
  {
    CFStringRef v3 = (CGContext *)this;
    this = CGFunctionIsIdentity();
    if ((this & 1) == 0)
    {
      for (uint64_t i = 0; i != 256; ++i)
      {
        *(double *)&v5.datCGFloat a = (double)(int)i * 0.00392156863;
        uint64_t v6 = 0;
        CGFunctionEvaluate();
        table[i] = 0;
      }
      v5.datCGFloat a = CGBitmapContextGetData(v3);
      v5.CGFloat height = CGBitmapContextGetHeight(v3);
      v5.CGFloat width = CGBitmapContextGetWidth(v3);
      v5.rowBytes = CGBitmapContextGetBytesPerRow(v3);
      return vImageTableLookUp_Planar8(&v5, &v5, table, 0);
    }
  }
  return this;
}

uint64_t RB::error_log(RB *this)
{
  unint64_t v1 = &color_symbols(void)::flag;
  {
    unint64_t v1 = &color_symbols(void)::flag;
    if (v3)
    {
      RB::error_log(void)::log = (uint64_t)os_log_create("com.apple.renderbox", "error");
      unint64_t v1 = &color_symbols(void)::flag;
    }
  }
  return *((void *)v1 + 4);
}

void RB::precondition_failure(RB *this, const char *a2, ...)
{
  va_start(va, a2);
  va_copy((va_list)&v5[1], va);
  v5[0] = 0;
  unsigned int v2 = (RB *)vasprintf(v5, (const char *)this, va);
  if (v5[0])
  {
    int v3 = RB::error_log(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      *(char **)&buf[4] = v5[0];
      _os_log_error_impl(&dword_2140F5000, v3, OS_LOG_TYPE_ERROR, "precondition failure: %s", buf, 0xCu);
    }
    if (!qword_267806E30)
    {
      *(void *)buf = 0;
      asprintf((char **)buf, "RenderBox precondition failure: %s.\n", v5[0]);
      qword_267806E30 = *(void *)buf;
    }
    free(v5[0]);
  }
  abort();
}

void RB::non_fatal_precondition_failure(RB *this, const char *a2, ...)
{
  va_start(va, a2);
  v4[0] = 0;
  va_copy((va_list)&v4[1], va);
  unsigned int v2 = (RB *)vasprintf((char **)v4, (const char *)this, va);
  if (v4[0])
  {
    int v3 = RB::error_log(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT)) {
      RB::non_fatal_precondition_failure((uint64_t *)v4, v3);
    }
    free(v4[0]);
  }
}

void RB::anonymous namespace'::cg_path_create_copy_by_jittering_points(CGPath const*,double)::$_0::__invoke(uint64_t a1, uint64_t a2)
{
  switch(*(_DWORD *)a2)
  {
    case 0:
      int v4 = *(double **)(a2 + 8);
      double v5 = *v4;
      double v6 = v4[1];
      double v7 = erand48((unsigned __int16 *)(a1 + 64));
      double v8 = *(double *)(a1 + 8);
      double v9 = *(double *)(a1 + 16);
      CGFloat v10 = v9 + v6 + v8 * erand48((unsigned __int16 *)(a1 + 64));
      *(double *)&long long v11 = v9 + v5 + v8 * v7;
      *((CGFloat *)&v11 + 1) = v10;
      long long v52 = v11;
      CGPathMoveToPoint(*(CGMutablePathRef *)a1, 0, *(CGFloat *)&v11, v10);
      long long v12 = v52;
      *(_OWORD *)(a1 + 48) = v52;
      goto LABEL_8;
    case 1:
      double v13 = *(double **)(a2 + 8);
      double v14 = *v13;
      double v15 = v13[1];
      double v16 = erand48((unsigned __int16 *)(a1 + 64));
      double v17 = *(double *)(a1 + 8);
      double v18 = *(double *)(a1 + 16);
      CGFloat v19 = v18 + v15 + v17 * erand48((unsigned __int16 *)(a1 + 64));
      *(double *)&long long v20 = v18 + v14 + v17 * v16;
      *((CGFloat *)&v20 + 1) = v19;
      long long v53 = v20;
      CGPathAddLineToPoint(*(CGMutablePathRef *)a1, 0, *(CGFloat *)&v20, v19);
      goto LABEL_6;
    case 2:
      uint64_t v21 = *(double **)(a2 + 8);
      double v22 = *v21;
      double v23 = v21[1];
      CGFloat v24 = *(double *)(a1 + 16) + v22 + *(double *)(a1 + 8) * erand48((unsigned __int16 *)(a1 + 64));
      CGFloat v25 = *(double *)(a1 + 16) + v23 + *(double *)(a1 + 8) * erand48((unsigned __int16 *)(a1 + 64));
      uint64_t v26 = *(void *)(a2 + 8);
      double v27 = *(double *)(v26 + 16);
      double v28 = *(double *)(v26 + 24);
      double v29 = erand48((unsigned __int16 *)(a1 + 64));
      double v30 = *(double *)(a1 + 8);
      double v31 = *(double *)(a1 + 16);
      CGFloat v32 = v31 + v28 + v30 * erand48((unsigned __int16 *)(a1 + 64));
      *(double *)&long long v33 = v31 + v27 + v30 * v29;
      *((CGFloat *)&v33 + 1) = v32;
      long long v53 = v33;
      CGPathAddQuadCurveToPoint(*(CGMutablePathRef *)a1, 0, v24, v25, *(CGFloat *)&v33, v32);
      goto LABEL_6;
    case 3:
      uint64_t v34 = *(double **)(a2 + 8);
      double v35 = *v34;
      double v36 = v34[1];
      CGFloat v37 = *(double *)(a1 + 16) + v35 + *(double *)(a1 + 8) * erand48((unsigned __int16 *)(a1 + 64));
      CGFloat v38 = *(double *)(a1 + 16) + v36 + *(double *)(a1 + 8) * erand48((unsigned __int16 *)(a1 + 64));
      uint64_t v39 = *(void *)(a2 + 8);
      double v40 = *(double *)(v39 + 16);
      double v41 = *(double *)(v39 + 24);
      CGFloat v50 = *(double *)(a1 + 16) + v40 + *(double *)(a1 + 8) * erand48((unsigned __int16 *)(a1 + 64));
      CGFloat v51 = *(double *)(a1 + 16) + v41 + *(double *)(a1 + 8) * erand48((unsigned __int16 *)(a1 + 64));
      *(double *)&long long v42 = v50;
      *((CGFloat *)&v42 + 1) = v51;
      long long v53 = v42;
      uint64_t v43 = *(void *)(a2 + 8);
      double v44 = *(double *)(v43 + 32);
      double v45 = *(double *)(v43 + 40);
      double v46 = erand48((unsigned __int16 *)(a1 + 64));
      double v47 = *(double *)(a1 + 8);
      double v48 = *(double *)(a1 + 16);
      double v49 = erand48((unsigned __int16 *)(a1 + 64));
      CGPathAddCurveToPoint(*(CGMutablePathRef *)a1, 0, v37, v38, v50, v51, v48 + v44 + v47 * v46, *(double *)(a1 + 16) + v45 + *(double *)(a1 + 8) * v49);
LABEL_6:
      long long v12 = v53;
      goto LABEL_8;
    case 4:
      CGPathCloseSubpath(*(CGMutablePathRef *)a1);
      long long v12 = *(_OWORD *)(a1 + 48);
LABEL_8:
      *(_OWORD *)(a1 + 32) = v12;
      break;
    default:
      return;
  }
}

uint64_t RB::ImageTexture::prepare(uint64_t this, uint64_t **a2, const RB::Fill::ImageData *a3, float64x2_t *a4, char a5)
{
  double v6 = *(CGImage **)this;
  if (*(void *)this)
  {
    switch(*(_DWORD *)(this + 8))
    {
      case 0:
        this = RBMakeCachedImageTexture(a2, v6, a3, a4, a5);
        break;
      case 1:
        this = RBMakeCachedIOSurfaceTexture(a2, v6, a3, a4, a5);
        break;
      case 2:
        this = RBSurfacePrepareTexture(*(void *)this, (RB::Device ***)a2);
        break;
      case 4:
        this = RBMakeCachedMTLTexture((uint64_t *)a2, v6, (uint64_t)a3, a4, a5);
        break;
      default:
        return this;
    }
  }
  return this;
}

uint64_t RB::ImageTexture::texture(CGImage **this, uint64_t **a2, const RB::Fill::ImageData *a3, float64x2_t *a4, char a5)
{
  double v6 = *this;
  if (!*this) {
    return 0;
  }
  switch(*((_DWORD *)this + 2))
  {
    case 0:
      uint64_t result = (uint64_t)RBGetCachedImageTexture(a2, v6, a3, a4, a5);
      break;
    case 1:
      uint64_t result = (uint64_t)RBGetCachedIOSurfaceTexture(a2, v6, a3, a4, a5);
      break;
    case 2:
      uint64_t result = RBSurfaceGetTexture((uint64_t)*this);
      break;
    case 4:
      uint64_t result = (uint64_t)RBGetCachedMTLTexture(a2, v6, (uint64_t)a3, a4, a5);
      break;
    default:
      return 0;
  }
  return result;
}

uint64_t RB::ImageTexture::cg_image(RB::ImageTexture *this)
{
  uint64_t result = *(void *)this;
  if (result)
  {
    int v3 = *((_DWORD *)this + 2);
    if ((v3 - 1) < 2 || v3) {
      return 0;
    }
  }
  return result;
}

uint64_t RB::ImageTexture::can_mix(RB::ImageTexture *this, const RB::ImageTexture *a2)
{
  if (*(void *)this == *(void *)a2 && *((_DWORD *)this + 2) == *((_DWORD *)a2 + 2)) {
    return 4;
  }
  else {
    return 0;
  }
}

uint64_t *RB::ImageTexture::prepare_encode(uint64_t **this, RB::Encoder *a2)
{
  return RB::Encoder::prepare_image((uint64_t *)a2, *((unsigned int *)this + 2), *this);
}

RB::Encoder *RB::ImageTexture::encode(RB::ImageTexture *this, RB::Encoder *a2)
{
  return RB::Encoder::image_field(a2, 1, *((_DWORD *)this + 2), *(uint64_t **)this);
}

uint64_t RB::ImageTexture::decode(uint64_t result, RB::ProtobufDecoder *this, uint64_t a3)
{
  unint64_t v4 = result;
  uint64_t v5 = *(void *)(a3 + 16);
  if (v5)
  {
    long long v7 = *(_OWORD *)this;
    *(_OWORD *)this = *(_OWORD *)a3;
    uint64_t result = RB::Decoder::image_field(this, v5);
    if (v6)
    {
      *(_DWORD *)(v4 + 8) = result;
      *(void *)unint64_t v4 = v6;
      uint64_t result = RB::ImageTexture::update_image(v4, v6);
    }
    *(_OWORD *)this = v7;
  }
  if (!*(void *)v4)
  {
    *((unsigned char *)this + 56) = 1;
    *(void *)this = *((void *)this + 1);
  }
  return result;
}

void RB::ImageTexture::attributes(CFTypeRef *this, RB::XML::Element *a2)
{
  if (*this) {
    CFRetain(*this);
  }
  RB::XML::Element::set<RB::XML::Value::Image>();
}

void sub_2141E8694(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::RetainedImageTexture::RetainedImageTexture(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 6) = 0;
  *(void *)a1 = 0;
  CFTypeRef v4 = *(CFTypeRef *)a2;
  if (*(void *)a2) {
    CFTypeRef v4 = CFRetain(v4);
  }
  *(void *)a1 = v4;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_WORD *)(a1 + 12) = *(_WORD *)(a2 + 12);
  return a1;
}

void RB::RetainedImageTexture::~RetainedImageTexture(const void **this)
{
  unint64_t v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

RB::ImageDescription *RB::ImageDescription::ImageDescription(RB::ImageDescription *this, const void *a2, RB *a3)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((unsigned char *)this + 24) = 0;
  *((void *)this + 2) = 0;
  switch((int)a2)
  {
    case 0:
      *(void *)this = CGImageGetIdentifier();
      *((void *)this + 1) = CGImageGetWidth(a3);
      *((void *)this + 2) = CGImageGetHeight(a3);
      *((unsigned char *)this + 24) = RB::cg_image_has_alpha(a3, v5);
      break;
    case 1:
      *(void *)this = IOSurfaceGetID(a3);
      *((void *)this + 1) = IOSurfaceGetWidth(a3);
      *((void *)this + 2) = IOSurfaceGetHeight(a3);
      OSType PixelFormat = IOSurfaceGetPixelFormat(a3);
      if (PixelFormat)
      {
        __int16 v14 = 0;
        char v13 = 0;
        RB::pixel_format_from_four_cc(PixelFormat, MTLPixelFormatInvalid, (unsigned char *)&v14 + 1, &v14, &v13);
        char v7 = HIBYTE(v14) ^ 1;
        goto LABEL_7;
      }
      break;
    case 2:
      *(void *)this = (int)a3;
      [(RB *)a3 size];
      *((void *)this + 1) = (unint64_t)v8;
      [(RB *)a3 size];
      *((void *)this + 2) = (unint64_t)v9;
      break;
    case 4:
      *(void *)this = (int)RB::pointer_hash(a3, a2);
      *((void *)this + 1) = [(RB *)a3 width];
      *((void *)this + 2) = [(RB *)a3 height];
      unint64_t v10 = [(RB *)a3 pixelFormat];
      char v7 = RB::pixel_format_traits(v10, v11)[1] & 1;
LABEL_7:
      *((unsigned char *)this + 24) = v7;
      break;
    default:
      return this;
  }
  return this;
}

CGImageRef RBImageCopyCGImage(int a1, CGImageRef image)
{
  if (a1) {
    return 0;
  }
  else {
    return CGImageRetain(image);
  }
}

uint64_t RB::Stroke::Dasher::prepare_pattern(uint64_t this, char *a2, float *a3)
{
  if (this) {
    RB::precondition_failure((RB *)"dash pattern counts must be even", a2, a3);
  }
  if (this)
  {
    float v3 = 0.0;
    do
    {
      float v4 = fabsf(*(float *)a2);
      if ((*(_DWORD *)a2 & 0x7FFFFFFFu) >= 0x7F800000) {
        float v5 = 0.0;
      }
      else {
        float v5 = v4;
      }
      *(float *)a2 = v5;
      a2 += 4;
      float v3 = v5 + v3;
      --this;
    }
    while (this);
    return v3 > 0.00000011921;
  }
  return this;
}

BOOL RB::Stroke::Dasher::validate_pattern(RB::Stroke::Dasher *this, float *a2, float *a3)
{
  if (this)
  {
    return 0;
  }
  else if (this)
  {
    float v3 = *a2;
    BOOL v4 = 0;
    if (*a2 >= 0.0)
    {
      unint64_t v5 = 1;
      do
      {
        if ((LODWORD(v3) & 0x7FFFFFFFu) >= 0x7F800000) {
          break;
        }
        BOOL v4 = v5 >= (unint64_t)this;
        if (this == (RB::Stroke::Dasher *)v5) {
          break;
        }
        float v3 = a2[v5++];
      }
      while (v3 >= 0.0);
    }
  }
  else
  {
    return 1;
  }
  return v4;
}

uint64_t RB::Stroke::Dasher::Dasher(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, float a5, float32x2_t a6, float32x2_t a7)
{
  *(void *)a1 = &unk_26C4EDBE0;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a4;
  *(_DWORD *)(a1 + 32) = 0;
  *(double *)(a1 + 40) = *(double *)&a6;
  *(float32x2_t *)(a1 + 48) = vadd_f32(a7, a6);
  *(unsigned char *)(a1 + 80) = 0;
  *(void *)(a1 + 112) = 0x3F80000000000000;
  *(void *)(a1 + 152) = 0x3F80000000000000;
  float v10 = 0.0;
  if (a3)
  {
    MTLPixelFormat v11 = a4;
    uint64_t v12 = a3;
    do
    {
      float v13 = *v11++;
      float v10 = v10 + v13;
      *(float *)(a1 + 32) = v10;
      --v12;
    }
    while (v12);
  }
  float v14 = fmodf(a5, v10);
  if ((LODWORD(v14) & 0x7FFFFFFFu) >= 0x7F800000) {
    float v14 = 0.0;
  }
  while (v14 < 0.0)
    float v14 = v14 + v10;
  *(void *)(a1 + 88) = 0;
  *(unsigned char *)(a1 + 81) = 1;
  float v15 = *a4;
  if (v14 >= *a4)
  {
    unint64_t v16 = 0;
    int v17 = 1;
    do
    {
      if (v14 == 0.0 && v15 == 0.0) {
        break;
      }
      float v14 = v14 - v15;
      v17 ^= 1u;
      *(unsigned char *)(a1 + 81) = v17;
      if (v16 < a3 - 1) {
        ++v16;
      }
      else {
        unint64_t v16 = 0;
      }
      *(void *)(a1 + 88) = v16;
      float v15 = a4[v16];
    }
    while (v14 >= v15);
  }
  *(float *)(a1 + 96) = v15 - v14;
  return a1;
}

uint64_t RB::Stroke::Dasher::add_dash_segment(uint64_t a1, uint64_t a2, __n128 a3, float32_t a4, float32_t a5, float a6, __n128 a7)
{
  v8.f32[0] = a4;
  double v9 = a3.n128_f64[0];
  float32x2_t v11 = vmla_n_f32(*(float32x2_t *)(a1 + 144), (float32x2_t)a3.n128_u64[0], a6);
  float32x2_t v12 = vmla_n_f32(*(float32x2_t *)(a1 + 144), (float32x2_t)a3.n128_u64[0], a7.n128_f32[0]);
  if (*(unsigned char *)(a1 + 160))
  {
    float v17 = a5;
    if (a6 < 0.00001 && (*(unsigned char *)(a1 + 80) & 1) != 0) {
      a3.n128_u64[0] = *(void *)(a1 + 56);
    }
    (*(void (**)(void, void, __n128))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), 0, a3);
    float32x2_t v20 = vmla_n_f32(*(float32x2_t *)(a1 + 152), (float32x2_t)__PAIR64__(LODWORD(v17), LODWORD(a4)), a6);
    (*(void (**)(void, float32x2_t *, double))(**(void **)(a1 + 8) + 8))(*(void *)(a1 + 8), &v20, *(double *)&v11);
    a5 = v17;
    v8.f32[0] = a4;
  }
  v8.f32[1] = a5;
  float32x2_t v20 = vmla_n_f32(*(float32x2_t *)(a1 + 152), v8, a7.n128_f32[0]);
  uint32x2_t v13 = (uint32x2_t)vcgt_f32(vminnm_f32(v11, v12), *(float32x2_t *)(a1 + 48));
  if ((vpmax_u32(v13, v13).u32[0] & 0x80000000) != 0
    || (uint32x2_t v14 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(a1 + 40), vmaxnm_f32(v11, v12)),
        (vpmax_u32(v14, v14).u32[0] & 0x80000000) != 0))
  {
    (*(void (**)(void, float32x2_t *, double))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), &v20, *(double *)&v12);
  }
  else
  {
    (*(void (**)(void, float32x2_t *, uint64_t, double))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), &v20, a2, *(double *)&v12);
  }
  if (a7.n128_f32[0] > 0.99999 && (*(unsigned char *)(a1 + 80) & 2) != 0) {
    double v9 = *(double *)(a1 + 64);
  }
  return (*(uint64_t (**)(void, uint64_t, double, __n128))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), 1, v9, a7);
}

double RB::Stroke::Dasher::closepath(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 160))
  {
    if ((*(unsigned char *)(a1 + 80) & 4) != 0) {
      (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), 1, *(double *)(a1 + 72));
    }
    *(unsigned char *)(a1 + 80) = 0;
  }
  *(void *)(a1 + 128) = *(void *)(a1 + 88);
  *(unsigned char *)(a1 + 120) = *(unsigned char *)(a1 + 81);
  *(unsigned char *)(a1 + 160) = 1;
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a1 + 96);
  double result = *(double *)(a1 + 104);
  *(double *)(a1 + 144) = result;
  *(void *)(a1 + 152) = *(void *)(a1 + 112);
  return result;
}

uint64_t RB::Stroke::Dasher::moveto(uint64_t result, uint64_t *a2, double a3)
{
  *(double *)(result + 104) = a3;
  uint64_t v3 = *a2;
  *(void *)(result + 112) = *a2;
  *(void *)(result + 128) = *(void *)(result + 88);
  *(unsigned char *)(result + 120) = *(unsigned char *)(result + 81);
  *(unsigned char *)(result + 160) = 1;
  *(_DWORD *)(result + 136) = *(_DWORD *)(result + 96);
  *(double *)(result + 144) = a3;
  *(void *)(result + 152) = v3;
  return result;
}

float32x2_t *RB::Stroke::Dasher::lineto(float32x2_t *result, float *a2, uint64_t a3, __n128 a4, double a5, double a6, double a7, __n128 a8)
{
  unint64_t v10 = a4.n128_u64[0];
  uint64_t v11 = (uint64_t)result;
  float32x2_t v12 = vsub_f32((float32x2_t)a4.n128_u64[0], result[18]);
  float v13 = *a2 - result[19].f32[0];
  float v14 = a2[1] - result[19].f32[1];
  float v15 = sqrtf(vaddv_f32(vmul_f32(v12, v12)));
  float v16 = result[17].f32[0];
  if (v15 <= v16)
  {
    if (result[15].i8[0])
    {
      a8.n128_u32[0] = 1.0;
      a4.n128_u64[0] = (unint64_t)v12;
      double result = (float32x2_t *)RB::Stroke::Dasher::add_dash_segment((uint64_t)result, a3, a4, *a2 - result[19].f32[0], a2[1] - result[19].f32[1], 0.0, a8);
      *(unsigned char *)(v11 + 160) = 0;
      float v16 = *(float *)(v11 + 136);
    }
    float v27 = v16 - v15;
    goto LABEL_18;
  }
  if (v15 < (float)(result[4].f32[0] * 8192.0))
  {
    float v17 = 0.0;
    float v18 = 1.0 / v15;
    if (v16 >= v15)
    {
      float v26 = result[17].f32[0];
    }
    else
    {
      int v19 = result[15].u8[0];
      float v20 = 0.0;
      do
      {
        float v17 = v16;
        if (v19)
        {
          a8.n128_f32[0] = v16 * v18;
          if (v16 == v15) {
            uint64_t v21 = a3;
          }
          else {
            uint64_t v21 = 1;
          }
          a4.n128_u64[0] = (unint64_t)v12;
          double result = (float32x2_t *)RB::Stroke::Dasher::add_dash_segment(v11, v21, a4, v13, v14, v20 * v18, a8);
          int v19 = *(unsigned __int8 *)(v11 + 120);
        }
        uint64_t v22 = *(void *)(v11 + 128);
        uint64_t v23 = *(void *)(v11 + 24);
        uint64_t v24 = *(void *)(v11 + 16) - 1;
        v19 ^= 1u;
        *(unsigned char *)(v11 + 120) = v19;
        if (v22 == v24) {
          uint64_t v25 = 0;
        }
        else {
          uint64_t v25 = v22 + 1;
        }
        float v26 = *(float *)(v23 + 4 * v25);
        *(void *)(v11 + 128) = v25;
        *(float *)(v11 + 136) = v26;
        *(unsigned char *)(v11 + 160) = 1;
        float v16 = v26 + v17;
        float v20 = v17;
      }
      while ((float)(v26 + v17) < v15);
    }
    if (v17 < v15)
    {
      if (*(unsigned char *)(v11 + 120))
      {
        a8.n128_u32[0] = 1.0;
        a4.n128_u64[0] = (unint64_t)v12;
        double result = (float32x2_t *)RB::Stroke::Dasher::add_dash_segment(v11, a3, a4, v13, v14, v17 * v18, a8);
        *(unsigned char *)(v11 + 160) = 0;
        float v26 = *(float *)(v11 + 136);
      }
      float v27 = (float)(v17 - v15) + v26;
LABEL_18:
      *(float *)(v11 + 136) = v27;
    }
  }
  *(void *)(v11 + 144) = v10;
  *(void *)(v11 + 152) = *(void *)a2;
  return result;
}

void RB::Stroke::Dasher::skipto()
{
}

uint64_t RB::Stroke::Dasher::tangent(uint64_t result, int a2, double a3)
{
  if (a2 == 1)
  {
    uint64_t v3 = (double *)(result + 64);
    char v4 = 2;
  }
  else
  {
    if (a2) {
      return result;
    }
    *(double *)(result + 56) = a3;
    uint64_t v3 = (double *)(result + 72);
    char v4 = 5;
  }
  *uint64_t v3 = a3;
  *(unsigned char *)(result + 80) |= v4;
  return result;
}

uint64_t $_3::__invoke($_3 *this, const void *a2)
{
  return 0;
}

uint64_t $_4::__invoke($_4 *this, const void *a2)
{
  unint64_t NumberOfPoints = CGPathGetNumberOfPoints();
  unint64_t NumberOfElements = CGPathGetNumberOfElements();
  if (NumberOfPoints <= NumberOfElements && NumberOfPoints == 3 && NumberOfElements == 3)
  {
    char info = 0;
    if (info) {
      return 3;
    }
    else {
      return 1;
    }
  }
  else if (NumberOfPoints <= NumberOfElements)
  {
    return 1;
  }
  else
  {
    return 3;
  }
}

uint64_t RBPathMakeWithCGPath(const void *a1)
{
  if (a1) {
    return (uint64_t)CFRetain(a1);
  }
  else {
    return 1;
  }
}

uint64_t RBPathMakeRect(_OWORD *a1, double a2, double a3, double a4, double a5)
{
}

uint64_t anonymous namespace'::make_rect(_OWORD *a1, double a2, double a3, double a4, double a5)
{
  if (!CGRectIsNull(*(CGRect *)&a2))
  {
    if (!a1
      || (long long v7 = a1[1],
          *(_OWORD *)&v8.CGFloat a = *a1,
          *(_OWORD *)&v8.c = v7,
          *(_OWORD *)&v8.tCGFloat x = a1[2],
          CGAffineTransformIsIdentity(&v8)))
    {
      operator new();
    }
    operator new();
  }
  return 0;
}

uint64_t RBPathMakeEllipse(_OWORD *a1, double a2, double a3, double a4, double a5)
{
  if (!CGRectIsNull(*(CGRect *)&a2))
  {
    if (!a1
      || (long long v7 = a1[1],
          *(_OWORD *)&v8.CGFloat a = *a1,
          *(_OWORD *)&v8.c = v7,
          *(_OWORD *)&v8.tCGFloat x = a1[2],
          CGAffineTransformIsIdentity(&v8)))
    {
      operator new();
    }
    operator new();
  }
  return 0;
}

uint64_t RBPathMakeUnevenRoundedRect(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, uint64_t a9, _OWORD *a10)
{
  if (a5 == 0.0 && a6 == 0.0 && a7 == 0.0 && a8 == 0.0) {
  if (!CGRectIsNull(*(CGRect *)&a1))
  }
  {
    if (a10)
    {
      long long v12 = a10[1];
      *(_OWORD *)&v13.CGFloat a = *a10;
      *(_OWORD *)&v13.c = v12;
      *(_OWORD *)&v13.tCGFloat x = a10[2];
      if (!CGAffineTransformIsIdentity(&v13)) {
        operator new();
      }
    }
    operator new();
  }
  return 0;
}

uint64_t RBPathApply(const CGPath *a1, void *a2, uint64_t a3, void (**a4)(void), void (**a5)(void))
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (a3)
  {
    MEMORY[0x270FA5388](a1, a2);
    unint64_t v5 = (float64x2_t *)v10;
    long long v7 = v6[1];
    long long v8 = v6[2];
    v10[0] = *v6;
    v10[1] = v7;
    int32x2_t v10[2] = v8;
  }
  else
  {
    unint64_t v5 = 0;
  }
  v11[0] = (void (**)(void))&unk_26C4EE490;
  v11[1] = a4;
  float32x2_t v11[2] = a5;
  unsigned __int8 v12 = 1;
  RBPathMap(a1, a2, v11, v5);
  return v12;
}

uint64_t RBPathApplyLines(const CGPath *a1, void *a2, void (**a3)(void), void (**a4)(void), double a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  v10[0] = (void (**)(void))&unk_26C4E7160;
  v10[1] = a3;
  int32x2_t v10[2] = a4;
  *(float *)&unsigned int v5 = a5;
  float v6 = *(float *)&v5;
  float32x2_t v7 = vrecpe_f32((float32x2_t)v5);
  float32x2_t v8 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v6), v7), v7);
  long long v11 = 0u;
  long long v12 = 0u;
  float v13 = 0.75 * vmul_f32(v8, vrecps_f32((float32x2_t)LODWORD(v6), v8)).f32[0];
  unsigned __int8 v14 = 1;
  RBPathMap(a1, a2, v10, 0);
  return v14;
}

uint64_t RBPathGetBezierOrder(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 2))
  {
    char v4 = *(uint64_t (**)(void))(a2 + 56);
    if (v4) {
      return v4();
    }
  }
  else
  {
    unsigned int v2 = *(uint64_t (**)(void))(a2 + 56);
    if (v2) {
      return v2();
    }
  }
  return 3;
}

uint64_t RBPathContainsPoint(RBPath a1, int a2, double a3, double a4)
{
  *(double *)unsigned int v5 = a3;
  *(double *)&v5[1] = a4;
  return RBPathContainsPoints(a1, 1uLL, (uint64_t)v5, a2, 0) & 1;
}

uint64_t RBPathContainsPoints(RBPath a1, unint64_t x2_0, uint64_t a3, int a4, float64x2_t *a5)
{
  uint64_t v73 = *MEMORY[0x263EF8340];
  if (!x2_0) {
    return 0;
  }
  int callbacks = a1.callbacks;
  char info = a1.info;
  unint64_t v9 = 0;
  if (x2_0 >= 0x40) {
    unint64_t v10 = 64;
  }
  else {
    unint64_t v10 = x2_0;
  }
  long long v11 = (float64x2_t *)MEMORY[0x263F000D0];
  if (a5) {
    long long v11 = a5;
  }
  float64x2_t v55 = v11[1];
  float64x2_t v56 = *v11;
  float64x2_t v54 = v11[2];
  float32x2_t v58 = (void (**)(void))&unk_26C4EE510;
  long long v64 = 0;
  uint64_t v66 = 16;
  *(_OWORD *)long long v68 = 0u;
  uint64_t v69 = 16;
  float32x2_t v70 = (float32x2_t)vdup_n_s32(0x7F800000u);
  float32x2_t v71 = (float32x2_t)0x7F0000007FLL;
  unsigned __int8 v12 = v10 + 3;
  unint64_t v13 = (v10 + 3) >> 2;
  long long v72 = 0u;
  uint64_t v62 = 16;
  __int32 v60 = 0;
  unint64_t v61 = v13;
  unint64_t v65 = v13;
  if (v13 >= 0x11)
  {
    RB::vector<RB::Fill::Gradient::Stop,16ul,unsigned long>::reserve_slow(v67, (v10 + 3) >> 2);
    unint64_t v9 = (unint64_t)v68[1];
  }
  if (v13 > v9)
  {
    unsigned __int8 v14 = v68[0];
    if (!v68[0]) {
      unsigned __int8 v14 = v67;
    }
    bzero(&v14[16 * v9], 16 * (v13 - v9));
  }
  v68[1] = (void *)((v10 + 3) >> 2);
  uint64_t v15 = (double *)(a3 + 8);
  float v16 = v59;
  float v17 = v63;
  unint64_t v18 = v10;
  do
  {
    float32x2_t v19 = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(v54, v56, *(v15 - 1)), v55, *v15));
    float32x2_t v70 = vminnm_f32(v70, v19);
    float32x2_t v71 = vmaxnm_f32(v71, v19);
    *v16++ = v19.i32[0];
    *v17++ = v19.i32[1];
    v15 += 2;
    --v18;
  }
  while (v18);
  unint64_t v20 = v10 - (v12 & 0xFC);
  if (v10 < (v12 & 0xFCu))
  {
    uint64_t v21 = &v63[v10];
    uint64_t v22 = &v59[v10];
    do
    {
      *v22++ = 0;
      *v21++ = 0;
    }
    while (!__CFADD__(v20++, 1));
  }
  v75.char info = info;
  v75.int callbacks = callbacks;
  *(void *)&v24.f64[0] = *(_OWORD *)&RBPathBoundingRect(v75, 0);
  *(void *)&v24.f64[1] = v28.i64[0];
  v27.f64[1] = v25;
  v57[0] = vcvt_f32_f64(v24);
  v57[1] = vcvt_f32_f64(v27);
  *(float32x2_t *)v28.i8 = v71;
  *(int32x2_t *)&v27.f64[0] = vceq_f32(v70, v71);
  double v29 = COERCE_DOUBLE(vpmin_u32(*(uint32x2_t *)&v27.f64[0], *(uint32x2_t *)&v27.f64[0]));
  if ((LODWORD(v29) & 0x80000000) != 0)
  {
    char v36 = RB::Rect::contains(v57, v70, *(double *)&v71, v29, v25, v26);
  }
  else
  {
    double v30 = RB::Rect::from_bounds(v70, v28);
    char v36 = RB::Rect::intersects(v57, v74, *(float32x2_t *)&v30, v31, v32, v33, v34, v35);
  }
  if ((v36 & 1) == 0)
  {
    uint64_t v37 = 0;
    uint64_t v39 = v68[0];
    if (!v68[0]) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }
  RBPathMap((CGPathRef)info, callbacks, &v58, 0);
  unint64_t v38 = 0;
  uint64_t v37 = 0;
  uint64_t v39 = v68[0];
  if (v68[0]) {
    double v40 = (int32x4_t *)v68[0];
  }
  else {
    double v40 = (int32x4_t *)v67;
  }
  unint64_t v41 = 1;
  v42.i64[0] = 0x100000001;
  v42.i64[1] = 0x100000001;
  do
  {
    int32x4_t v43 = *v40++;
    int32x4_t v44 = v43;
    int8x16_t v45 = (int8x16_t)vtstq_s32(v44, v44);
    if (a4) {
      unsigned int v46 = -1;
    }
    else {
      unsigned int v46 = 0;
    }
    int8x16_t v47 = (int8x16_t)vdupq_n_s32(v46);
    int32x4_t v48 = vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(vandq_s8((int8x16_t)v44, v42), v47), vbicq_s8(v45, v47)));
    v49.i64[0] = v48.i32[0];
    v49.i64[1] = v48.i32[1];
    int8x16_t v50 = v49;
    v49.i64[0] = v48.i32[2];
    v49.i64[1] = v48.i32[3];
    v51.i64[0] = v41;
    v51.i64[1] = 2 * v41;
    int8x16_t v52 = vorrq_s8(vbicq_s8(v51, v50), vbicq_s8((int8x16_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v41), (uint64x2_t)xmmword_214219C30), v49));
    v37 |= *(void *)&vorr_s8(*(int8x8_t *)v52.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL));
    v38 += 4;
    v41 *= 16;
  }
  while (v38 < v10);
  if (v68[0]) {
LABEL_33:
  }
    free(v39);
LABEL_34:
  if (v64) {
    free(v64);
  }
  if (v60) {
    free(v60);
  }
  return v37;
}

void sub_2141E99C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51)
{
  if (STACK[0x390]) {
    free((void *)STACK[0x390]);
  }
  if (STACK[0x270]) {
    free((void *)STACK[0x270]);
  }
  if (a51) {
    free(a51);
  }
  _Unwind_Resume(a1);
}

void RBPathContainsPoints::Winding::~Winding(RBPathContainsPoints::Winding *this)
{
  unsigned int v2 = (void *)*((void *)this + 106);
  if (v2) {
    free(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 70);
  if (v3) {
    free(v3);
  }
  char v4 = (void *)*((void *)this + 34);
  if (v4) {
    free(v4);
  }
}

double RBPathGetLength(const CGPath *a1, void *a2, _OWORD *a3, double a4)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  v9[0] = (void (**)(void))&unk_26C4EF148;
  v9[1] = *(void (***)(void))&a4;
  long long v10 = 0u;
  long long v11 = 0u;
  double v12 = 0.0;
  if (a3)
  {
    long long v4 = a3[1];
    long long v5 = a3[2];
    v8[0] = *a3;
    v8[1] = v4;
    _OWORD v8[2] = v5;
    float v6 = (float64x2_t *)v8;
  }
  else
  {
    float v6 = 0;
  }
  RBPathMap(a1, a2, v9, v6);
  return v12;
}

uint64_t RBPathCopyStrokedPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  if ((RBPathIsEmpty(a1, a2) & 1) == 0)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    unint64_t v15 = 0;
    if (a6)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      do
      {
        unint64_t v10 = v9 + 1;
        if (v15 < v9 + 1)
        {
          RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)&v13, v10);
          uint64_t v8 = v13;
          unint64_t v9 = v14;
          unint64_t v10 = v14 + 1;
        }
        uint64_t v11 = *a5++;
        *(void *)(v8 + 8 * v9) = v11;
        unint64_t v14 = v10;
        unint64_t v9 = v10;
        --a6;
      }
      while (a6);
    }
    operator new();
  }
  return 0;
}

void sub_2141E9CA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  if (*v15) {
    free(*v15);
  }
  float v17 = *(void (**)(void))(*(void *)(v14 + 24) + 16);
  if (v17) {
    v17(*(void *)(v14 + 16));
  }
  MEMORY[0x21669AC10](v14, 0x10E1C4000811C3ELL);
  if (a14) {
    free(a14);
  }
  _Unwind_Resume(a1);
}

uint64_t RBPathCopyTrimmedPath(uint64_t a1, uint64_t a2)
{
  if ((RBPathIsEmpty(a1, a2) & 1) == 0) {
    operator new();
  }
  return 0;
}

void sub_2141E9DC8(_Unwind_Exception *a1)
{
  MEMORY[0x21669AC10](v1, 0x10E1C404749101FLL);
  _Unwind_Resume(a1);
}

uint64_t RBPathCanMix(RBPath a1, RBPath a2)
{
  int callbacks = a2.callbacks;
  char info = a2.info;
  long long v4 = a1.callbacks;
  long long v5 = a1.info;
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (RBPathEqualToPath((uint64_t)a1.info, (uint64_t)a1.callbacks, (uint64_t)a2.info, a2.callbacks)) {
    return 4;
  }
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  memset(v12, 0, 24);
  uint64_t v15 = 128;
  float v17 = 0;
  size_t v18 = 0;
  unint64_t v19 = 16;
  unint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 8;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 4;
  RBPathApplyElements((uint64_t)v5, (uint64_t)v4, (uint64_t)v12, (uint64_t)RBPathCanMix(RBPath,RBPath)::$_0::__invoke<void *,RBPathElement,double const*,void const*>);
  size_t v7 = v18;
  size_t v8 = v18 + 1;
  if (v19 < v18 + 1)
  {
    RB::vector<BOOL,16ul,unsigned long>::reserve_slow(v16, v8);
    size_t v7 = v18;
    size_t v8 = v18 + 1;
  }
  unint64_t v9 = v17;
  if (!v17) {
    unint64_t v9 = v16;
  }
  v9[v7] = 0;
  size_t v18 = v8;
  unsigned int v10 = RBPathApplyElements((uint64_t)info, (uint64_t)callbacks, (uint64_t)v12, (uint64_t)RBPathCanMix(RBPath,RBPath)::$_1::__invoke<void *,RBPathElement,double const*,void const*>);
  if (v12[0] == v14) {
    uint64_t v6 = v10;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v23) {
    free(v23);
  }
  if (v20) {
    free(v20);
  }
  if (v17) {
    free(v17);
  }
  if (v13) {
    free(v13);
  }
  return v6;
}

void sub_2141E9F68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *RBPathCanMix(RBPath,RBPath)::Info::~Info(void *a1)
{
  unsigned int v2 = (void *)a1[40];
  if (v2) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[29];
  if (v3) {
    free(v3);
  }
  long long v4 = (void *)a1[24];
  if (v4) {
    free(v4);
  }
  long long v5 = (void *)a1[19];
  if (v5) {
    free(v5);
  }
  return a1;
}

void *RBPathMix@<X0>(RBPath a1@<0:X0, 8:X1>, RBPath a2@<0:X2, 8:X3>, float a3@<S0>, float64x2_t *this@<X4>, float64x2_t *a5@<X5>, float64x2_t *a6@<X6>, void *a7@<X8>)
{
  int callbacks = a1.callbacks;
  char info = a1.info;
  uint64_t v28 = *MEMORY[0x263EF8340];
  if (a3 == 0.0 || (double v12 = a2.callbacks, v13 = a2.info, a1.info == a2.info) && a1.callbacks == a2.callbacks)
  {
    uint64_t v14 = (uint64_t (*)(void *))*((void *)a1.callbacks + 1);
    if (v14)
    {
      a1.char info = (void *)v14(a1.info);
      char info = a1.info;
    }
    *a7 = info;
    a7[1] = callbacks;
  }
  else
  {
    if (a3 != 1.0)
    {
      unint64_t v20 = 0;
      uint64_t v21 = 0;
      long long v18 = 0u;
      long long v19 = 0u;
      long long v23 = 0u;
      uint64_t v22 = 128;
      uint64_t v24 = 256;
      uint64_t v25 = 0;
      uint64_t v27 = 0;
      uint64_t v26 = 0;
      *(float *)float v17 = a3;
      v17[1] = RB::AffineTransform::scale(this);
      _OWORD v17[2] = RB::AffineTransform::scale(a5);
      *(float *)&float64x2_t v17[3] = 1.0 / RB::AffineTransform::scale(a6);
      RBPathApplyElements((uint64_t)info, (uint64_t)callbacks, (uint64_t)v17, (uint64_t)RBPathMix(RBPath,RBPath,float,RB::AffineTransform const&,RB::AffineTransform const&,RB::AffineTransform const&)::$_0::__invoke<void *,RBPathElement,double const*,void const*>);
      operator new();
    }
    uint64_t v15 = (uint64_t (*)(void *))*((void *)a2.callbacks + 1);
    if (v15)
    {
      a1.char info = (void *)v15(a2.info);
      uint64_t v13 = a1.info;
    }
    *a7 = v13;
    a7[1] = v12;
  }
  return a1.info;
}

void sub_2141EA29C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  RBPathMix(RBPath,RBPath,float,RB::AffineTransform const&,RB::AffineTransform const&,RB::AffineTransform const&)::Info::~Info((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *RBPathMix(RBPath,RBPath,float,RB::AffineTransform const&,RB::AffineTransform const&,RB::AffineTransform const&)::Info::~Info(void *a1)
{
  unsigned int v2 = (void *)a1[284];
  if (v2) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[281];
  if (v3) {
    free(v3);
  }
  long long v4 = (void *)a1[22];
  if (v4) {
    free(v4);
  }
  long long v5 = (atomic_uint *)a1[5];
  if (v5 && atomic_fetch_add_explicit(v5 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v5 + 8))(v5);
  }
  return a1;
}

BOOL RBPathCanInterpolate(RBPath a1, RBPath a2)
{
  return RBPathCanMix(a1, a2) != 0;
}

uint64_t RBPathCopyInterpolatedPath(RBPath a1, RBPath a2, float a3)
{
  v5[0] = (float64x2_t)xmmword_2142181C0;
  v5[1] = (float64x2_t)xmmword_2142181D0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  RBPathMix(a1, a2, a3, v5, v5, v5, &v4);
  return v4;
}

void RBPathEncode(RBPath a1, RB::ProtobufEncoder *a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (a1.callbacks != (RBPathCallbacks *)&empty_path_callbacks)
  {
    uint64_t v7 = a2;
    *(_OWORD *)unint64_t v9 = 0u;
    uint64_t v10 = 64;
    long long v12 = 0u;
    uint64_t v13 = 384;
    unint64_t v16 = 0;
    uint64_t v15 = 0;
    uint64_t v17 = 32;
    RBPathApplyElements((uint64_t)a1.info, (uint64_t)a1.callbacks, (uint64_t)&v7, (uint64_t)RBPathEncode(RBPath,RB::ProtobufEncoder &)::$_0::__invoke<void *,RBPathElement,double const*,void const*>);
    uint64_t v3 = v9[1];
    if (v9[0]) {
      uint64_t v4 = (uint64_t *)v9[0];
    }
    else {
      uint64_t v4 = &v8;
    }
    if (v9[1])
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
      RB::ProtobufEncoder::encode_data(a2, v4, (unint64_t)v3);
    }
    if (*((void *)&v12 + 1))
    {
      if ((void)v12) {
        long long v5 = (const unsigned int *)v12;
      }
      else {
        long long v5 = (const unsigned int *)&v11;
      }
      RB::ProtobufEncoder::packed_fixed32_field(a2, 2, v5, *((uint64_t *)&v12 + 1));
    }
    if (v16)
    {
      if (v15) {
        uint64_t v6 = (const unint64_t *)v15;
      }
      else {
        uint64_t v6 = (const unint64_t *)&v14;
      }
      RB::ProtobufEncoder::packed_fixed64_field(a2, 5, v6, v16);
    }
    if (v15) {
      free(v15);
    }
    if ((void)v12) {
      free((void *)v12);
    }
    if (v9[0]) {
      free(v9[0]);
    }
  }
}

void sub_2141EA544(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  RBPathEncode(RBPath,RB::ProtobufEncoder &)::Context::~Context((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *RBPathEncode(RBPath,RB::ProtobufEncoder &)::Context::~Context(void *a1)
{
  unsigned int v2 = (void *)a1[239];
  if (v2) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[204];
  if (v3) {
    free(v3);
  }
  uint64_t v4 = (void *)a1[9];
  if (v4) {
    free(v4);
  }
  return a1;
}

void RBPathDecode(RB::Decoder *a1)
{
}

void sub_2141EA6B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  RB::Path::Storage::~Storage((RB::Path::Storage *)&a9);
  MEMORY[0x21669AC10](v9, 0x10F1C40860659AFLL);
  _Unwind_Resume(a1);
}

uint64_t RBPathXMLDescription(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5 = a3;
  int v6 = a4;
  return RBPathApplyElements(a1, a2, (uint64_t)&v5, (uint64_t)RBPathXMLDescription(RBPath,std::string &,unsigned int)::$_0::__invoke<void *,RBPathElement,double const*,void const*>);
}

void RBPathCopyData(RBPath a1)
{
  char v4 = 0;
  *(_OWORD *)unsigned int v2 = 0u;
  long long v3 = 0u;
  *(_OWORD *)uint64_t v1 = 0u;
  RBPathEncode(a1, (RB::ProtobufEncoder *)v1);
  operator new();
}

void sub_2141EA7FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (v19) {
    CFRelease(v19);
  }
  RB::ProtobufEncoder::~ProtobufEncoder((RB::ProtobufEncoder *)&a19);
  _Unwind_Resume(a1);
}

void RBPathMakeWithData(const __CFData *a1)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  RB::Heap::Heap((RB::Heap *)v4, 0, 0, 0);
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  v5[0] = BytePtr;
  v5[1] = &BytePtr[Length];
  float64x2_t v5[2] = 0;
  memset(&v5[4], 0, 24);
  char v6 = 0;
  uint64_t v7 = v4;
  uint64_t v8 = 0;
  RB::UntypedTable::UntypedTable((uint64_t)v9, 0, 0, 0, 0, 0);
  memset(&v9[80], 0, 48);
  uuid_clear(v10);
  int v11 = 0;
  char v12 = 1;
  RBPathDecode((RB::Decoder *)v5);
}

void sub_2141EA96C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37)
{
}

__CFString *RBPathCopyDebugDescription(uint64_t a1, uint64_t a2)
{
  CGMutablePathRef Mutable = CFStringCreateMutable(0, 0);
  CFStringAppendCString(Mutable, "RBPath:", 0x8000100u);
  RBPathApplyElements(a1, a2, (uint64_t)Mutable, (uint64_t)RBPathCopyDebugDescription::$_0::__invoke<void *,RBPathElement,double const*,void const*>);
  CFStringAppendCString(Mutable, "\n", 0x8000100u);
  return Mutable;
}

unsigned char *anonymous namespace'::cgpath_bezier_order(CGPath const*)::$_0::__invoke(unsigned char *result, _DWORD *a2)
{
  if ((*a2 & 0xFFFFFFFE) == 2) {
    void *result = 1;
  }
  return result;
}

uint64_t anonymous namespace'::make_single_element_path<anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::{lambda(void const*)#1}::__invoke(uint64_t result)
{
  return result;
}

atomic_uint *anonymous namespace'::make_single_element_path<anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::{lambda(void const*)#2}::__invoke(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t anonymous namespace'::make_single_element_path<anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::{lambda(void const*,void *,BOOL (*)(void const*,RBPathElement,double const*,void const))#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, void, uint64_t, uint64_t))
{
  if (*(unsigned char *)(a1 + 56)) {
    uint64_t v3 = a1 + 64;
  }
  else {
    uint64_t v3 = 0;
  }
  return a3(a2, *(unsigned __int8 *)(a1 + 48), a1 + 16, v3);
}

BOOL anonymous namespace'::make_single_element_path<anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::{lambda(void const*,void const)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 56);
  if (v2 != *(unsigned __int8 *)(a2 + 56) || memcmp((const void *)(a1 + 16), (const void *)(a2 + 16), 0x28uLL)) {
    return 0;
  }
  if (!v2) {
    return 1;
  }
  long long v6 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&t1.CGFloat a = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&t1.c = v6;
  *(_OWORD *)&t1.tCGFloat x = *(_OWORD *)(a1 + 96);
  long long v7 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)&v8.CGFloat a = *(_OWORD *)(a2 + 64);
  *(_OWORD *)&v8.c = v7;
  *(_OWORD *)&v8.tCGFloat x = *(_OWORD *)(a2 + 96);
  BOOL result = CGAffineTransformEqualToTransform(&t1, &v8);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t anonymous namespace'::make_single_element_path<anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::{lambda(void const*)#3}::__invoke()
{
  return 0;
}

uint64_t anonymous namespace'::make_single_element_path<anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::{lambda(void const*)#4}::__invoke()
{
  return 1;
}

uint64_t anonymous namespace'::make_single_element_path<anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::{lambda(void const*)#5}::__invoke()
{
  return 1;
}

atomic_uint *RB::Refcount<RBPath anonymous namespace'::make_single_element_path<anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::Info,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::Refcount<RBPath anonymous namespace'::make_single_element_path<anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::Info,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void anonymous namespace'::make_single_element_path<anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::TransformInfo::~TransformInfo()
{
}

void anonymous namespace'::make_single_element_path<anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::Info::~Info()
{
}

uint64_t RBPathEqualToPath::$_0::__invoke<void *,RBPathElement,double const*,void const*>(uint64_t a1, unsigned int a2, double *a3, unsigned __int8 *a4)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  int32x4_t v48 = 0;
  uint64_t v49 = 0x400000000;
  BOOL v7 = RB::Path::Storage::Iterator::next((uint64_t *)(a1 + 1088), a1, __dst);
  if (__dst[64] == a2 && v7)
  {
    if (a2 <= 0x18 && __RBPathElementArgumentCount[a2])
    {
      uint64_t v9 = 8 * __RBPathElementArgumentCount[a2];
      uint64_t v10 = (double *)__dst;
      while (*a3 == *v10)
      {
        ++a3;
        ++v10;
        v9 -= 8;
        if (!v9) {
          goto LABEL_10;
        }
      }
    }
    else
    {
LABEL_10:
      if (!a4 && !v43)
      {
LABEL_13:
        uint64_t v11 = 1;
        goto LABEL_78;
      }
      switch(a2)
      {
        case 0x10u:
        case 0x12u:
        case 0x16u:
        case 0x17u:
          goto LABEL_13;
        case 0x11u:
        case 0x15u:
          goto LABEL_15;
        case 0x13u:
          uint64_t v11 = 0;
          unint64_t v16 = &default_stroke_transform;
          if (a4) {
            unint64_t v16 = a4;
          }
          int v17 = v44;
          if (!v43) {
            int v17 = 0;
          }
          if (v17 != *(_DWORD *)v16) {
            goto LABEL_78;
          }
          uint64_t v11 = 0;
          int v18 = v45;
          if (!v43) {
            int v18 = 0;
          }
          if (v18 != *((_DWORD *)v16 + 1)) {
            goto LABEL_78;
          }
          unint64_t v19 = v46;
          if (!v43) {
            unint64_t v19 = 0;
          }
          if (v19 != *((void *)v16 + 1)) {
            goto LABEL_77;
          }
          if (v43) {
            unint64_t v20 = v47;
          }
          else {
            unint64_t v20 = 0;
          }
          if (!v19) {
            goto LABEL_13;
          }
          uint64_t v21 = (double *)*((void *)v16 + 2);
          uint64_t v22 = 8 * v19;
          break;
        case 0x14u:
          uint64_t v11 = 0;
          long long v23 = (unsigned __int8 *)&default_BOOL_transform;
          if (a4) {
            long long v23 = a4;
          }
          unsigned __int8 v24 = v44;
          if (!v43) {
            unsigned __int8 v24 = 0;
          }
          if (*v23 == v24)
          {
            uint64_t v11 = 0;
            unsigned __int8 v25 = v43 ? BYTE1(v44) : 0;
            if (v23[1] == v25) {
              goto LABEL_13;
            }
          }
          goto LABEL_78;
        case 0x18u:
          uint64_t v11 = 0;
          if (a4) {
            uint64_t v26 = a4;
          }
          else {
            uint64_t v26 = &default_clip_stroke_transform;
          }
          int v27 = v44;
          if (!v43) {
            int v27 = 0;
          }
          if (v27 != *v26) {
            goto LABEL_78;
          }
          int v28 = v45;
          if (!v43) {
            int v28 = 1;
          }
          if (v28 != v26[1]) {
            goto LABEL_77;
          }
          unint64_t v29 = v46;
          if (!v43) {
            unint64_t v29 = 0;
          }
          if (v29 != *((void *)v26 + 1)) {
            goto LABEL_77;
          }
          if (v29)
          {
            double v30 = v47;
            if (!v43) {
              double v30 = 0;
            }
            uint64_t v31 = *((void *)v26 + 2);
            if (*(_DWORD *)v30 != *(_DWORD *)v31
              || *((float *)v30 + 1) != *(float *)(v31 + 4)
              || *((float *)v30 + 2) != *(float *)(v31 + 8))
            {
              goto LABEL_77;
            }
            BOOL v32 = 0;
            double v33 = (float *)(v31 + 24);
            double v34 = (float *)(v30 + 3);
            unint64_t v35 = 1;
            do
            {
              if (*(v34 - 3) != *(v33 - 3)) {
                break;
              }
              BOOL v32 = v35 >= v29;
              if (v29 == v35) {
                break;
              }
              if (*((_DWORD *)v34 - 2) != *((_DWORD *)v33 - 2)) {
                break;
              }
              if (*(v34 - 1) != *(v33 - 1)) {
                break;
              }
              float v36 = *v34;
              v34 += 4;
              float v37 = v36;
              float v38 = *v33;
              v33 += 4;
              ++v35;
            }
            while (v37 == v38);
            if (!v32) {
              goto LABEL_77;
            }
          }
          goto LABEL_13;
        default:
          if (a2 == 4) {
            goto LABEL_13;
          }
LABEL_15:
          if (v43) {
            char v12 = &v44;
          }
          else {
            char v12 = (int *)MEMORY[0x263F000D0];
          }
          long long v13 = *((_OWORD *)v12 + 1);
          if (a4) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = (_OWORD *)MEMORY[0x263F000D0];
          }
          *(_OWORD *)&t1.CGFloat a = *(_OWORD *)v12;
          *(_OWORD *)&t1.c = v13;
          *(_OWORD *)&t1.tCGFloat x = *((_OWORD *)v12 + 2);
          long long v15 = v14[1];
          *(_OWORD *)&v40.CGFloat a = *v14;
          *(_OWORD *)&v40.c = v15;
          *(_OWORD *)&v40.tCGFloat x = v14[2];
          if (!CGAffineTransformEqualToTransform(&t1, &v40)) {
            goto LABEL_77;
          }
          goto LABEL_13;
      }
      while (*v20 == *v21)
      {
        ++v20;
        ++v21;
        v22 -= 8;
        if (!v22) {
          goto LABEL_13;
        }
      }
    }
  }
LABEL_77:
  uint64_t v11 = 0;
LABEL_78:
  if (v48) {
    free(v48);
  }
  return v11;
}

void sub_2141EAFB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40)
{
  if (a40) {
    free(a40);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RBPathApply::Context::closepath(uint64_t this)
{
  if (*(unsigned char *)(this + 24))
  {
    uint64_t v1 = this;
    long long v2 = xmmword_21421C310;
    this = (*(uint64_t (**)(void, long long *))(this + 16))(*(void *)(this + 8), &v2);
    *(unsigned char *)(v1 + 24) = this;
  }
  return this;
}

uint64_t RBPathApply::Context::moveto(uint64_t result, __n128 a2)
{
  if (*(unsigned char *)(result + 24))
  {
    uint64_t v2 = result;
    __n128 v4 = a2;
    v3[0] = 0;
    v3[1] = &v4;
    BOOL result = (*(uint64_t (**)(void, void *))(result + 16))(*(void *)(result + 8), v3);
    *(unsigned char *)(v2 + 24) = result;
  }
  return result;
}

uint64_t RBPathApply::Context::lineto(uint64_t result, __n128 a2)
{
  if (*(unsigned char *)(result + 24))
  {
    uint64_t v2 = result;
    __n128 v4 = a2;
    v3[1] = &v4;
    v3[0] = 1;
    BOOL result = (*(uint64_t (**)(void, void *))(result + 16))(*(void *)(result + 8), v3);
    *(unsigned char *)(v2 + 24) = result;
  }
  return result;
}

uint64_t RBPathApply::Context::quadto(uint64_t result, __n128 a2, __n128 a3)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(result + 24))
  {
    uint64_t v3 = result;
    v5[0] = a2;
    v5[1] = a3;
    v4[1] = v5;
    v4[0] = 2;
    BOOL result = (*(uint64_t (**)(void, void *))(result + 16))(*(void *)(result + 8), v4);
    *(unsigned char *)(v3 + 24) = result;
  }
  return result;
}

uint64_t RBPathApply::Context::cubeto(uint64_t result, __n128 a2, __n128 a3, __n128 a4)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(result + 24))
  {
    uint64_t v4 = result;
    v6[0] = a2;
    v6[1] = a3;
    float32x4_t v6[2] = a4;
    v5[1] = v6;
    v5[0] = 3;
    BOOL result = (*(uint64_t (**)(void, void *))(result + 16))(*(void *)(result + 8), v5);
    *(unsigned char *)(v4 + 24) = result;
  }
  return result;
}

__n128 RBPathApplyLines::Flattener::closepath(__n128 *this)
{
  if (this[4].n128_u8[4])
  {
    uint64_t v3 = 0;
    this[4].n128_u8[4] = ((uint64_t (*)(unint64_t, uint64_t, uint64_t *))this[1].n128_u64[0])(this->n128_u64[1], 2, &v3);
  }
  __n128 result = this[2];
  this[3] = result;
  return result;
}

uint64_t RBPathApplyLines::Flattener::moveto(uint64_t result, __n128 a2)
{
  uint64_t v2 = (__n128 *)result;
  uint64_t v5 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(result + 68))
  {
    __n128 v3 = a2;
    __n128 v4 = a2;
    __n128 result = (*(uint64_t (**)(void, void, __n128 *))(result + 16))(*(void *)(result + 8), 0, &v4);
    a2 = v3;
    v2[4].n128_u8[4] = result;
  }
  v2[2] = a2;
  void v2[3] = a2;
  return result;
}

uint64_t RBPathApplyLines::Flattener::lineto(uint64_t result, __n128 a2)
{
  uint64_t v2 = (__n128 *)result;
  uint64_t v5 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(result + 68))
  {
    __n128 v3 = a2;
    __n128 v4 = a2;
    __n128 result = (*(uint64_t (**)(void, uint64_t, __n128 *))(result + 16))(*(void *)(result + 8), 1, &v4);
    a2 = v3;
    v2[4].n128_u8[4] = result;
  }
  void v2[3] = a2;
  return result;
}

double RBPathApplyLines::Flattener::quadto(float64x2_t *a1, float64x2_t a2, float64x2_t a3)
{
  float64x2_t v4 = vaddq_f64(a2, a2);
  float64x2_t v5 = (float64x2_t)vdupq_n_s64(0x3FD5555555555555uLL);
  *(void *)&double result = RBPathApplyLines::Flattener::cubeto((uint64_t)a1, (__n128)vmulq_f64(vaddq_f64(a1[3], v4), v5), vmulq_f64(vaddq_f64(v4, a3), v5), a3).n128_u64[0];
  return result;
}

__n128 RBPathApplyLines::Flattener::cubeto(uint64_t a1, __n128 result, float64x2_t a3, float64x2_t a4)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(a1 + 68)) {
    goto LABEL_10;
  }
  float64x2_t v7 = (float64x2_t)result;
  result.n128_u64[0] = (unint64_t)vcvt_f32_f64(*(float64x2_t *)(a1 + 48));
  *(float32x2_t *)&v7.f64[0] = vcvt_f32_f64(v7);
  *(float32x2_t *)&a3.f64[0] = vcvt_f32_f64(a3);
  float32x2_t v8 = vcvt_f32_f64(a4);
  float32x2_t v9 = vmaxnm_f32(vabs_f32(vadd_f32(vsub_f32(*(float32x2_t *)&a3.f64[0], vadd_f32(*(float32x2_t *)&v7.f64[0], *(float32x2_t *)&v7.f64[0])), (float32x2_t)result.n128_u64[0])), vabs_f32(vadd_f32(vsub_f32(*(float32x2_t *)&v7.f64[0], vadd_f32(*(float32x2_t *)&a3.f64[0], *(float32x2_t *)&a3.f64[0])), v8)));
  float v10 = ceilf(sqrtf(sqrtf(vaddv_f32(vmul_f32(v9, v9)))) * *(float *)(a1 + 64));
  if (((LODWORD(v10) & 0x7FFFFFFFu) - 0x800000) >> 24 >= 0x7F && (LODWORD(v10) & 0x7FFFFFFF) != 0)
  {
LABEL_10:
    *(float64x2_t *)(a1 + 48) = a4;
    return result;
  }
  if (v10 < 1.0)
  {
    uint32x2_t v12 = (uint32x2_t)vceq_f32((float32x2_t)result.n128_u64[0], v8);
    result.n128_u64[0] = (unint64_t)vpmin_u32(v12, v12);
    if ((result.n128_u32[0] & 0x80000000) != 0) {
      return result;
    }
LABEL_18:
    float64x2_t v17 = a4;
    float64x2_t v19 = a4;
    *(unsigned char *)(a1 + 68) = (*(uint64_t (**)(void, uint64_t, float64x2_t *))(a1 + 16))(*(void *)(a1 + 8), 1, &v19);
    double result = (__n128)v17;
    *(float64x2_t *)(a1 + 48) = v17;
    return result;
  }
  if (v10 > 1024.0) {
    float v10 = 1024.0;
  }
  unsigned int v13 = (int)v10;
  if ((int)v10 < 2) {
    goto LABEL_18;
  }
  float64x2_t v16 = a4;
  _ZN2RB13CubicIteratorIDv2_fEC1ES1_S1_S1_S1_i(&v19, (int)v10);
  if (*(unsigned char *)(a1 + 68))
  {
    do
    {
      *(float32x2_t *)&v19.f64[0] = vadd_f32(*(float32x2_t *)&v19.f64[0], *(float32x2_t *)&v19.f64[1]);
      *(float32x2_t *)&v19.f64[1] = vadd_f32(v20, *(float32x2_t *)&v19.f64[1]);
      float32x2_t v20 = vadd_f32(v21, v20);
      float64x2_t v18 = vcvtq_f64_f32(*(float32x2_t *)&v19.f64[0]);
      float64x2_t v22 = v18;
      int v14 = (*(uint64_t (**)(void, uint64_t, float64x2_t *))(a1 + 16))(*(void *)(a1 + 8), 1, &v22);
      *(unsigned char *)(a1 + 68) = v14;
      double result = (__n128)v18;
      *(float64x2_t *)(a1 + 48) = v18;
      if (!v14) {
        break;
      }
    }
    while (v13-- > 2);
    a4 = v16;
    if (v14) {
      goto LABEL_18;
    }
  }
  return result;
}

float32x2_t *RBPathContainsPoints::Winding::endpath(float32x2_t *this)
{
  float32x2_t v1 = this[112];
  uint32x2_t v2 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v1, this[113]));
  if ((vpmax_u32(v2, v2).u32[0] & 0x80000000) != 0) {
    return RBPathContainsPoints::Winding::lineto_float(this, v1);
  }
  return this;
}

float32x2_t *RBPathContainsPoints::Winding::closepath(float32x2_t *this)
{
  float32x2_t v1 = this[112];
  uint32x2_t v2 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v1, this[113]));
  if ((vpmax_u32(v2, v2).u32[0] & 0x80000000) != 0) {
    return RBPathContainsPoints::Winding::lineto_float(this, v1);
  }
  return this;
}

float32x2_t RBPathContainsPoints::Winding::moveto(float32x2_t *a1, float64x2_t a2)
{
  float32x2_t v4 = a1[112];
  uint32x2_t v5 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v4, a1[113]));
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) != 0)
  {
    float64x2_t v7 = a2;
    RBPathContainsPoints::Winding::lineto_float(a1, v4);
    a2 = v7;
  }
  float32x2_t result = vcvt_f32_f64(a2);
  a1[113] = result;
  a1[112] = result;
  return result;
}

float32x2_t *RBPathContainsPoints::Winding::lineto(float32x2_t *a1, float64x2_t a2)
{
  return RBPathContainsPoints::Winding::lineto_float(a1, vcvt_f32_f64(a2));
}

float32x2_t *RBPathContainsPoints::Winding::quadto(float32x2_t *a1, float64x2_t a2, float64x2_t a3)
{
  float64x2_t v4 = vaddq_f64(a2, a2);
  float64x2_t v5 = (float64x2_t)vdupq_n_s64(0x3FD5555555555555uLL);
  return RBPathContainsPoints::Winding::cubeto(a1, vmulq_f64(vaddq_f64(v4, vcvtq_f64_f32(a1[113])), v5), vmulq_f64(vaddq_f64(v4, a3), v5), a3);
}

float32x2_t *RBPathContainsPoints::Winding::cubeto(float32x2_t *result, float64x2_t a2, float64x2_t a3, float64x2_t a4)
{
  float64x2_t v7 = result;
  float32x2_t v8 = result[113];
  float32x2_t v9 = vcvt_f32_f64(a2);
  float32x2_t v10 = vcvt_f32_f64(a3);
  float32x2_t v11 = vcvt_f32_f64(a4);
  int32x2_t v12 = vcgt_f32(vminnm_f32(vminnm_f32(v8, v9), vminnm_f32(v10, v11)), result[111]);
  if (v12.i8[4]) {
    goto LABEL_18;
  }
  uint32x2_t v13 = (uint32x2_t)vcgt_f32(result[110], vmaxnm_f32(vmaxnm_f32(v8, v9), vmaxnm_f32(v10, v11)));
  if ((vpmax_u32(v13, v13).u32[0] & 0x80000000) != 0) {
    goto LABEL_18;
  }
  if ((v12.i8[0] & 1) == 0)
  {
    float32x2_t v14 = vmaxnm_f32(vabs_f32(vadd_f32(vsub_f32(v10, vadd_f32(v9, v9)), v8)), vabs_f32(vadd_f32(vsub_f32(v9, vadd_f32(v10, v10)), v11)));
    float v15 = ceilf(sqrtf(sqrtf(vaddv_f32(vmul_f32(v14, v14)))));
    if (SLODWORD(v15) > -1 && ((LODWORD(v15) & 0x7FFFFFFFu) - 0x800000) >> 24 < 0x7F || LODWORD(v15) == 0)
    {
      if (v15 >= 1.0)
      {
        if (v15 > 1024.0) {
          float v15 = 1024.0;
        }
        int v19 = (int)v15;
        if ((int)v15 >= 2)
        {
          _ZN2RB13CubicIteratorIDv2_fEC1ES1_S1_S1_S1_i(&v45, (int)v15);
          __asm { FMOV            V1.4S, #1.0 }
          do
          {
            float32x2_t v23 = vadd_f32(v45, v46);
            float32x2_t v45 = v23;
            float32x2_t v46 = vadd_f32(v47, v46);
            float32x2_t v47 = vadd_f32(v48, v47);
            int32x2_t v24 = (int32x2_t)v7[113];
            v7[113] = v23;
            if (COERCE_FLOAT(vminnm_f32(*(float32x2_t *)&v24, v23).i32[1]) <= v7[111].f32[1])
            {
              uint32x2_t v25 = (uint32x2_t)vcgt_f32(v7[110], vmaxnm_f32((float32x2_t)v24, v23));
              if ((vpmax_u32(v25, v25).u32[0] & 0x80000000) == 0)
              {
                int32x2_t v26 = (int32x2_t)vsub_f32(v23, (float32x2_t)v24);
                if (fabsf(*(float *)&v26.i32[1]) >= 0.0001)
                {
                  float32x2_t v27 = v7[35];
                  if (v27)
                  {
                    uint64_t v28 = 0;
                    if (*(float *)&v26.i32[1] > 0.0) {
                      unsigned int v29 = 1;
                    }
                    else {
                      unsigned int v29 = -1;
                    }
                    float32x2_t v30 = vrecpe_f32((float32x2_t)v26.u32[1]);
                    float32x2_t v31 = vmul_f32(vrecps_f32((float32x2_t)v26.u32[1], v30), v30);
                    LODWORD(v32) = vmul_f32(v31, vrecps_f32((float32x2_t)v26.u32[1], v31)).u32[0];
                    float32x4_t v33 = (float32x4_t)vdupq_lane_s32(v24, 1);
                    float32x4_t v34 = (float32x4_t)vdupq_lane_s32(v24, 0);
                    float32x4_t v35 = (float32x4_t)vdupq_lane_s32(v26, 0);
                    int8x16_t v36 = (int8x16_t)vdupq_n_s32(v29);
                    do
                    {
                      float v37 = (float32x2_t *)v7[34];
                      if (!v37) {
                        float v37 = v7 + 2;
                      }
                      float32x4_t v38 = *(float32x4_t *)v37[2 * v28].f32;
                      uint64_t v39 = (float32x2_t *)v7[70];
                      if (!v39) {
                        uint64_t v39 = v7 + 38;
                      }
                      float32x4_t v40 = vmulq_n_f32(vsubq_f32(*(float32x4_t *)v39[2 * v28].f32, v33), v32);
                      int8x16_t v41 = (int8x16_t)vcgtq_f32(vmlaq_f32(v34, v35, v40), v38);
                      int8x16_t v42 = vandq_s8(v36, vandq_s8((int8x16_t)vcgezq_f32(v40), (int8x16_t)vcgeq_f32(_Q1, v40)));
                      char v43 = (float32x2_t *)v7[106];
                      if (!v43) {
                        char v43 = v7 + 74;
                      }
                      *(int32x4_t *)v43[2 * v28].f32 = vaddq_s32((int32x4_t)vandq_s8(v42, v41), *(int32x4_t *)v43[2 * v28].f32);
                      ++v28;
                    }
                    while (*(void *)&v27 != v28);
                  }
                }
              }
            }
          }
          while (v19-- > 2);
        }
      }
      else
      {
        uint32x2_t v18 = (uint32x2_t)vceq_f32(v8, v11);
        if ((vpmin_u32(v18, v18).u32[0] & 0x80000000) != 0) {
          return result;
        }
      }
      return RBPathContainsPoints::Winding::lineto_float(v7, v11);
    }
LABEL_18:
    result[113] = v11;
    return result;
  }
  return RBPathContainsPoints::Winding::lineto_float(result, v11);
}

float32x2_t *RBPathContainsPoints::Winding::lineto_float(float32x2_t *result, float32x2_t a2)
{
  float32x2_t v2 = result[113];
  result[113] = a2;
  if (COERCE_FLOAT(vminnm_f32(v2, a2).i32[1]) <= result[111].f32[1])
  {
    uint32x2_t v3 = (uint32x2_t)vcgt_f32(result[110], vmaxnm_f32(v2, a2));
    if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) == 0)
    {
      int32x2_t v4 = (int32x2_t)vsub_f32(a2, v2);
      if (fabsf(*(float *)&v4.i32[1]) >= 0.0001)
      {
        float32x2_t v5 = result[35];
        if (v5)
        {
          uint64_t v6 = 0;
          if (*(float *)&v4.i32[1] > 0.0) {
            unsigned int v7 = 1;
          }
          else {
            unsigned int v7 = -1;
          }
          float32x2_t v8 = vrecpe_f32((float32x2_t)v4.u32[1]);
          float32x2_t v9 = vmul_f32(vrecps_f32((float32x2_t)v4.u32[1], v8), v8);
          LODWORD(v10) = vmul_f32(v9, vrecps_f32((float32x2_t)v4.u32[1], v9)).u32[0];
          float32x4_t v11 = (float32x4_t)vdupq_lane_s32((int32x2_t)v2, 1);
          float32x4_t v12 = (float32x4_t)vdupq_lane_s32((int32x2_t)v2, 0);
          float32x4_t v13 = (float32x4_t)vdupq_lane_s32(v4, 0);
          int8x16_t v14 = (int8x16_t)vdupq_n_s32(v7);
          __asm { FMOV            V5.4S, #1.0 }
          do
          {
            float32x2_t v20 = (float32x2_t *)result[34];
            if (!v20) {
              float32x2_t v20 = result + 2;
            }
            float32x4_t v21 = *(float32x4_t *)v20[2 * v6].f32;
            float64x2_t v22 = (float32x2_t *)result[70];
            if (!v22) {
              float64x2_t v22 = result + 38;
            }
            float32x4_t v23 = vmulq_n_f32(vsubq_f32(*(float32x4_t *)v22[2 * v6].f32, v11), v10);
            int8x16_t v24 = (int8x16_t)vcgtq_f32(vmlaq_f32(v12, v13, v23), v21);
            int8x16_t v25 = vandq_s8(v14, vandq_s8((int8x16_t)vcgezq_f32(v23), (int8x16_t)vcgeq_f32(_Q5, v23)));
            int32x2_t v26 = (float32x2_t *)result[106];
            if (!v26) {
              int32x2_t v26 = result + 74;
            }
            *(int32x4_t *)v26[2 * v6].f32 = vaddq_s32((int32x4_t)vandq_s8(v25, v24), *(int32x4_t *)v26[2 * v6].f32);
            ++v6;
          }
          while (*(void *)&v5 != v6);
        }
      }
    }
  }
  return result;
}

float64x2_t RBPathGetLength::Accumulator::closepath(float64x2_t *this)
{
  float64x2_t result = this[1];
  float64x2_t v2 = vsubq_f64(result, this[2]);
  this[3].f64[0] = sqrt(vaddvq_f64(vmulq_f64(v2, v2))) + this[3].f64[0];
  this[2] = result;
  return result;
}

__n128 *RBPathGetLength::Accumulator::moveto(__n128 *result, __n128 a2)
{
  result[1] = a2;
  result[2] = a2;
  return result;
}

float64x2_t *RBPathGetLength::Accumulator::lineto(float64x2_t *result, float64x2_t a2)
{
  float64x2_t v2 = vsubq_f64(a2, result[2]);
  result[3].f64[0] = sqrt(vaddvq_f64(vmulq_f64(v2, v2))) + result[3].f64[0];
  result[2] = a2;
  return result;
}

__n128 RBPathGetLength::Accumulator::quadto(float64x2_t *a1, float64x2_t a2, float64x2_t a3)
{
  float64x2_t v4 = vaddq_f64(a2, a2);
  float64x2_t v5 = (float64x2_t)vdupq_n_s64(0x3FD5555555555555uLL);
  a1[3].f64[0] = a1[3].f64[0]
               + RB::cubic_length_f<double>(a1[2], vmulq_f64(vaddq_f64(a1[2], v4), v5), vmulq_f64(vaddq_f64(v4, a3), v5), a3, a1->f64[1]);
  __n128 result = (__n128)a3;
  a1[2] = a3;
  return result;
}

__n128 RBPathGetLength::Accumulator::cubeto(float64x2_t *a1, float64x2_t a2, float64x2_t a3, float64x2_t a4)
{
  a1[3].f64[0] = a1[3].f64[0] + RB::cubic_length_f<double>(a1[2], a2, a3, a4, a1->f64[1]);
  __n128 result = (__n128)a4;
  a1[2] = a4;
  return result;
}

void RBPathCopyCGPath::Accumulator::quadto(uint64_t a1, __n128 a2, __n128 a3)
{
}

uint64_t RBPathCanMix(RBPath,RBPath)::$_0::__invoke<void *,RBPathElement,double const*,void const*>(void *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  float32x2_t v8 = a1 + 3;
  uint64_t v9 = a1[20];
  size_t v10 = v9 + 1;
  if (a1[21] < (unint64_t)(v9 + 1))
  {
    RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(a1 + 3, v10);
    uint64_t v9 = a1[20];
    size_t v10 = v9 + 1;
  }
  float32x4_t v11 = (void *)a1[19];
  if (!v11) {
    float32x4_t v11 = v8;
  }
  *((unsigned char *)v11 + v9) = a2;
  a1[20] = v10;
  if (a2 == 24)
  {
    float v15 = (uint64_t *)&default_clip_stroke_transform;
    if (a4) {
      float v15 = a4;
    }
    uint64_t v16 = *a3;
    uint64_t v17 = *v15;
    uint64_t v18 = a1[41];
    size_t v19 = v18 + 1;
    if (a1[42] < (unint64_t)(v18 + 1))
    {
      RB::vector<std::pair<RB::objc_ptr<RBSymbolAnimator *>,RB::objc_ptr<objc_object  {objcproto24RBSymbolAnimatorObserver}*>>,4ul,unsigned long>::reserve_slow(a1 + 32, v19);
      uint64_t v18 = a1[41];
      size_t v19 = v18 + 1;
    }
    float32x2_t v20 = (void *)a1[40];
    if (!v20) {
      float32x2_t v20 = a1 + 32;
    }
    float32x4_t v21 = &v20[2 * v18];
    void *v21 = v16;
    v21[1] = v17;
    a1[41] = v19;
  }
  else if (a2 == 20)
  {
    if (a4) {
      float32x4_t v12 = a4;
    }
    else {
      float32x4_t v12 = (uint64_t *)&default_BOOL_transform;
    }
    uint64_t v13 = a1[30];
    if (a1[31] < (unint64_t)(v13 + 1))
    {
      RB::vector<RBPathBooleanTransform,8ul,unsigned long>::reserve_slow(a1 + 27, v13 + 1);
      uint64_t v13 = a1[30];
    }
    int8x16_t v14 = (void *)a1[29];
    if (!v14) {
      int8x16_t v14 = a1 + 27;
    }
    *((_WORD *)v14 + v13) = *(_WORD *)v12;
    ++a1[30];
  }
  return 1;
}

void *RB::vector<RBPathBooleanTransform,8ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 4) + (*((void *)__dst + 4) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 4) + (*((void *)__dst + 4) >> 1);
  }
  __n128 result = RB::details::realloc_vector<unsigned long,2ul>(*((void **)__dst + 2), __dst, 8uLL, (size_t *)__dst + 4, v3);
  *((void *)__dst + 2) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,2ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t a5)
{
  unsigned int v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      size_t v9 = a3;
      memcpy(__dst, __src, 2 * a5);
      free(v7);
      float32x4_t v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    size_t v8 = malloc_good_size(2 * a5);
    size_t v9 = v8 >> 1;
    if (v8 >> 1 != *a4)
    {
      size_t v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10) {
        RB::precondition_failure((RB *)"allocation failure", v11);
      }
      float32x4_t v12 = v10;
      if (!v7) {
        memcpy(v10, __dst, 2 * *a4);
      }
      goto LABEL_8;
    }
  }
  return v7;
}

BOOL RBPathCanMix(RBPath,RBPath)::$_1::__invoke<void *,RBPathElement,double const*,void const*>(uint64_t *a1, unsigned int a2, double *a3, int *a4)
{
  if (a2 <= 0x18)
  {
    if (((1 << a2) & 0x1DE0000) != 0)
    {
      size_t v8 = (void *)a1[24];
      uint64_t v9 = a1[25];
      if (v8) {
        size_t v10 = (void *)a1[24];
      }
      else {
        size_t v10 = a1 + 22;
      }
      int v11 = *((unsigned __int8 *)v10 + v9 - 1);
      BOOL v13 = a2 == 18 || v11 != 0;
      size_t v14 = v9 + 1;
      if (a1[26] < (unint64_t)(v9 + 1))
      {
        RB::vector<BOOL,16ul,unsigned long>::reserve_slow(a1 + 22, v14);
        size_t v8 = (void *)a1[24];
        uint64_t v9 = a1[25];
        size_t v14 = v9 + 1;
      }
      if (!v8) {
        size_t v8 = a1 + 22;
      }
      *((unsigned char *)v8 + v9) = v13;
      a1[25] = v14;
    }
    else if (a2 == 16)
    {
      unint64_t v29 = a1[25];
      if (v29 >= 2) {
        a1[25] = v29 - 1;
      }
    }
  }
  uint64_t v15 = *a1;
  if (*a1 >= (unint64_t)a1[20]) {
    return 0;
  }
  uint64_t v16 = a1 + 3;
  uint64_t v17 = v15 + 1;
  if (a1[19]) {
    uint64_t v16 = (void *)a1[19];
  }
  int v18 = *((unsigned __int8 *)v16 + v15);
  *a1 = v17;
  size_t v19 = a1 + 22;
  if (a1[24]) {
    size_t v19 = (void *)a1[24];
  }
  if (v18 != a2)
  {
    int v25 = *((unsigned __int8 *)v19 + a1[25] - 1);
    BOOL v27 = v18 != 5 || v25 != 0;
    if (v18 != 6 && v27)
    {
      if ((v18 & 0xFC) == 8)
      {
        if (a2 != 6) {
          return a2 == 5 && v25 == 0;
        }
        return 1;
      }
      return 0;
    }
    BOOL v31 = a2 != 5 || v25 != 0;
    if ((a2 & 0xFC) != 8 && a2 != 6 && v31) {
      return 0;
    }
  }
  if (a2 == 24)
  {
    float v32 = a1 + 32;
    uint64_t v33 = a1[2];
    a1[2] = v33 + 1;
    if (a1[40]) {
      float v32 = (void *)a1[40];
    }
    float32x4_t v34 = (int *)&default_clip_stroke_transform;
    if (a4) {
      float32x4_t v34 = a4;
    }
    int v35 = v32[2 * v33 + 1];
    int v36 = *v34;
    if ((*v34 ^ v35))
    {
      double v37 = *(double *)&v32[2 * v33];
      if ((v37 < 0.0001 || v37 > 0.9999) && fabs(v37 + *a3 + -1.0) < 0.0001)
      {
        v35 &= ~1u;
        v36 &= ~1u;
      }
    }
    if (v35 == v36)
    {
      int v23 = HIDWORD(v32[2 * v33 + 1]);
      int v24 = v34[1];
      return v23 == v24;
    }
    return 0;
  }
  if (a2 != 20) {
    return 1;
  }
  float32x2_t v20 = a1 + 27;
  uint64_t v21 = a1[1];
  a1[1] = v21 + 1;
  if (a1[29]) {
    float32x2_t v20 = (void *)a1[29];
  }
  float64x2_t v22 = (unsigned __int8 *)&default_BOOL_transform;
  if (a4) {
    float64x2_t v22 = (unsigned __int8 *)a4;
  }
  if (*((unsigned __int8 *)v20 + 2 * v21) != *v22) {
    return 0;
  }
  int v23 = *((unsigned __int8 *)v20 + 2 * v21 + 1);
  int v24 = v22[1];
  return v23 == v24;
}

uint64_t RBPathMix(RBPath,RBPath,float,RB::AffineTransform const&,RB::AffineTransform const&,RB::AffineTransform const&)::$_0::__invoke<void *,RBPathElement,double const*,void const*>(void *a1, unsigned int a2, uint64_t *a3, _OWORD *a4)
{
  char v6 = a2;
  if (a2 > 0x18)
  {
    uint64_t v8 = 0;
    if (!a4) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v8 = __RBPathElementArgumentCount[a2];
    if (!a4) {
      goto LABEL_7;
    }
  }
  if (a2 > 0x18 || ((1 << a2) & 0x1DD0010) == 0)
  {
    long long v17 = a4[1];
    *(_OWORD *)&v22.CGFloat a = *a4;
    *(_OWORD *)&v22.c = v17;
    *(_OWORD *)&v22.tCGFloat x = a4[2];
    if (!CGAffineTransformIsIdentity(&v22))
    {
      uint64_t v18 = a1[285];
      if (a1[286] < (unint64_t)(v18 + 1))
      {
        RB::vector<RB::CustomShader::Closure::marshal_args(RB::RenderPass &,RB::Function &,RB::Rect const*,unsigned char *,RB::BufferRegion &,RB::Texture *&)::PendingArg,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 284), v18 + 1);
        uint64_t v18 = a1[285];
      }
      size_t v19 = (_OWORD *)(a1[284] + 48 * v18);
      long long v20 = *a4;
      long long v21 = a4[2];
      v19[1] = a4[1];
      void v19[2] = v21;
      *size_t v19 = v20;
      ++a1[285];
      v6 |= 0x80u;
    }
  }
LABEL_7:
  uint64_t v9 = a1[23];
  if (a1[24] < (unint64_t)(v9 + 1))
  {
    RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(a1 + 6, v9 + 1);
    uint64_t v9 = a1[23];
  }
  size_t v10 = (void *)a1[22];
  if (!v10) {
    size_t v10 = a1 + 6;
  }
  *((unsigned char *)v10 + v9) = v6;
  ++a1[23];
  if (v8)
  {
    size_t v11 = a1[282];
    do
    {
      size_t v12 = v11 + 1;
      if (a1[283] < v11 + 1)
      {
        RB::vector<double,256ul,unsigned long>::reserve_slow(a1 + 25, v12);
        size_t v11 = a1[282];
        size_t v12 = v11 + 1;
      }
      BOOL v13 = (void *)a1[281];
      uint64_t v14 = *a3++;
      uint64_t v15 = v14;
      if (!v13) {
        BOOL v13 = a1 + 25;
      }
      v13[v11] = v15;
      a1[282] = v12;
      size_t v11 = v12;
      --v8;
    }
    while (v8);
  }
  return 1;
}

void *RB::vector<double,256ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 258) + (*((void *)__dst + 258) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 258) + (*((void *)__dst + 258) >> 1);
  }
  __n128 result = RB::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 256), __dst, 0x100uLL, (size_t *)__dst + 258, v3);
  *((void *)__dst + 256) = result;
  return result;
}

uint64_t RBPathMix(RBPath,RBPath,float,RB::AffineTransform const&,RB::AffineTransform const&,RB::AffineTransform const&)::$_1::operator()<void *,RBPathElement,double const*,void const*>(uint64_t result, const char *a2, const RB::AffineTransform *__src, __n128 *a4)
{
  float64x2_t v4 = a4;
  float64x2_t v5 = (float64x2_t *)__src;
  uint64_t v6 = (uint64_t)a2;
  uint64_t v7 = result;
  uint64_t v71 = *MEMORY[0x263EF8340];
  uint64_t v8 = result + 48;
  uint64_t v9 = *(void *)(result + 16);
  *(void *)(result + 16) = v9 + 1;
  if (*(void *)(result + 176)) {
    uint64_t v8 = *(void *)(result + 176);
  }
  int v10 = *(unsigned __int8 *)(v8 + v9);
  if (a2 > 0x18 || ((1 << (char)a2) & 0x1DD0010) == 0)
  {
    if (a4)
    {
      __n128 v50 = a4[1];
      *(__n128 *)&v70.CGFloat a = *a4;
      *(__n128 *)&v70.c = v50;
      *(__n128 *)&v70.tCGFloat x = a4[2];
      __n128 result = CGAffineTransformIsIdentity(&v70);
      if (result) {
        int8x16_t v51 = 0;
      }
      else {
        int8x16_t v51 = v4;
      }
      if ((v10 & 0x80) == 0) {
        goto LABEL_48;
      }
    }
    else
    {
      int8x16_t v51 = 0;
      if ((v10 & 0x80) == 0) {
        goto LABEL_48;
      }
    }
    unint64_t v53 = *(void *)(v7 + 32);
    if (v53 < *(void *)(v7 + 2280))
    {
      *(void *)(v7 + 32) = v53 + 1;
      uint64_t v54 = *(void *)(v7 + 2272) + 48 * v53;
      goto LABEL_49;
    }
LABEL_48:
    uint64_t v54 = 0;
LABEL_49:
    if ((unint64_t)v51 | v54)
    {
      float64x2_t v55 = (float64x2_t)xmmword_2142181D0;
      float64x2_t v56 = (float64x2_t)xmmword_2142181C0;
      float64x2_t v57 = 0uLL;
      long long v58 = xmmword_2142181C0;
      long long v59 = xmmword_2142181D0;
      long long v60 = 0uLL;
      if (v54)
      {
        long long v58 = *(_OWORD *)v54;
        long long v59 = *(_OWORD *)(v54 + 16);
        long long v60 = *(_OWORD *)(v54 + 32);
      }
      *(_OWORD *)&v69.CGFloat a = v58;
      *(_OWORD *)&v69.c = v59;
      *(_OWORD *)&v69.tCGFloat x = v60;
      if (v51)
      {
        float64x2_t v56 = *(float64x2_t *)v51;
        float64x2_t v55 = (float64x2_t)v51[1];
        float64x2_t v57 = (float64x2_t)v51[2];
      }
      v68[0] = v56;
      v68[1] = v55;
      v68[2] = v57;
      unint64_t v61 = RB::mix(&v69, v68, __src, *(float *)v7);
      float64x2_t v4 = &v65;
      __n128 v65 = MEMORY[0x270FA5388](v61, v62);
      long long v66 = v63;
      long long v67 = v64;
    }
  }
  uint64_t v11 = v10 & 0x7F;
  if ((v10 & 0x7Fu) > 0x18) {
    unint64_t v12 = 0;
  }
  else {
    unint64_t v12 = __RBPathElementArgumentCount[v11];
  }
  uint64_t v13 = *(void *)(v7 + 24);
  if (v13 + v12 > *(void *)(v7 + 2256))
  {
LABEL_28:
    RB::Path::Storage::append_element((RB::Path::Storage *)(*(void *)(v7 + 40) + 16), (const char *)v6, v5->f64, (int *)v4);
    return 1;
  }
  uint64_t v14 = v7 + 200;
  if (*(void *)(v7 + 2248)) {
    uint64_t v14 = *(void *)(v7 + 2248);
  }
  uint64_t v15 = (float64x2_t *)(v14 + 8 * v13);
  *(void *)(v7 + 24) = v13 + v12;
  if (v11 == v6) {
    goto LABEL_16;
  }
  if ((v10 - 133) < 2 || (v10 - 5) <= 1)
  {
    if ((v6 & 0xFC) == 8)
    {
      MEMORY[0x270FA5388](result, a2);
      __n128 v16 = (__n128)v15[1];
      v68[-4] = *v15;
      __n128 v65 = v16;
      long long v66 = 0u;
      long long v67 = 0u;
      unint64_t v12 = __RBPathElementArgumentCount[v6];
      uint64_t v15 = &v68[-4];
LABEL_16:
      uint64_t v11 = v6;
LABEL_17:
      MEMORY[0x270FA5388](result, 8 * v12);
      uint64_t v18 = (int8x16_t *)((char *)v68 - v17);
      bzero((char *)v68 - v17, v19);
      unint64_t v20 = 2 * path_element_leading_vec2s[v11];
      if (v20)
      {
        unint64_t v21 = 0;
        double v22 = *(float *)(v7 + 4);
        float64x2_t v23 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(*(float *)(v7 + 8)), 0);
        float64x2_t v24 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(*(float *)v7), 0);
        double v25 = *(float *)(v7 + 12);
        int32x2_t v26 = v15;
        BOOL v27 = v5;
        uint64_t v28 = v18;
        do
        {
          float64x2_t v29 = *v26++;
          float64x2_t v30 = v29;
          float64x2_t v31 = *v27++;
          float64x2_t v32 = vmulq_n_f64(v30, v22);
          float64x2_t v33 = vmulq_n_f64(vmlaq_f64(v32, v24, vmlaq_f64(vnegq_f64(v32), v31, v23)), v25);
          *v28++ = vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f64(v33), (int8x16_t)vcgezq_f64(v33)), (int8x16_t)v33, (int8x16_t)v30);
          v21 += 2;
        }
        while (v21 < v20);
      }
      else
      {
        unint64_t v21 = 0;
      }
      if ((v11 & 0xFE) == 0xA)
      {
        uint64_t v34 = (8 * v21) | 8;
        uint64_t v35 = 8 * v21 + 16;
        float64x2_t v36 = *(float64x2_t *)((char *)v15 + v35);
        v37.f64[0] = v15->f64[v21];
        v37.f64[1] = *(float64_t *)((char *)v15->f64 + v34);
        v38.f64[0] = v5->f64[v21];
        v38.f64[1] = *(float64_t *)((char *)v5->f64 + v34);
        double v39 = *(float *)(v7 + 4);
        float64x2_t v40 = vmulq_n_f64(v36, v39);
        float64x2_t v41 = vmulq_n_f64(v37, v39);
        float v42 = *(float *)(v7 + 12);
        double v43 = *(float *)(v7 + 8);
        float64x2_t v44 = vmlaq_n_f64(vnegq_f64(v41), v38, v43);
        double v45 = *(float *)v7;
        float64x2_t v46 = vmulq_n_f64(vmlaq_n_f64(v40, vmlaq_n_f64(vnegq_f64(v40), *(float64x2_t *)((char *)v5 + v35), v43), v45), v42);
        float64x2_t v47 = vmulq_n_f64(vmlaq_n_f64(v41, v44, v45), v42);
        int8x16_t v48 = vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f64(v47), (int8x16_t)vcgezq_f64(v47)), (int8x16_t)v47, (int8x16_t)v37);
        v18->i64[v21] = v48.i64[0];
        *(uint64_t *)((char *)v18->i64 + v34) = v48.i64[1];
        *(int8x16_t *)((char *)v18 + v35) = vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f64(v46), (int8x16_t)vcgezq_f64(v46)), (int8x16_t)v46, (int8x16_t)v36);
        v21 += 4;
      }
      if (v21 < v12)
      {
        double v49 = *(float *)v7;
        do
        {
          *(double *)&v18->i64[v21] = v15->f64[v21] + (v5->f64[v21] - v15->f64[v21]) * v49;
          ++v21;
        }
        while (v12 != v21);
      }
      float64x2_t v5 = (float64x2_t *)v18;
      uint64_t v6 = v11;
      goto LABEL_28;
    }
    if ((v10 & 0x7C) != 8)
    {
      if (((v10 - 5) < 2 || (v10 - 133) < 2) && (v6 - 5) <= 1u) {
        goto LABEL_17;
      }
      return 0;
    }
LABEL_42:
    if ((v6 - 5) <= 1u)
    {
      MEMORY[0x270FA5388](result, a2);
      __n128 v52 = (__n128)v5[1];
      v68[-4] = *v5;
      __n128 v65 = v52;
      long long v66 = 0u;
      long long v67 = 0u;
      float64x2_t v5 = &v68[-4];
      goto LABEL_17;
    }
    return 0;
  }
  if ((v10 & 0x7C) == 8) {
    goto LABEL_42;
  }
  __n128 result = 0;
  if ((v6 - 5) <= 1u && v11 == 5)
  {
    uint64_t v11 = 5;
    goto LABEL_17;
  }
  return result;
}

uint64_t RBPathEncode(RBPath,RB::ProtobufEncoder &)::$_0::__invoke<void *,RBPathElement,double const*,void const*>(RB::ProtobufEncoder **a1, unsigned int a2, double *a3, int *a4)
{
  char v6 = a2;
  uint64_t v55 = *MEMORY[0x263EF8340];
  if (a2 > 0x18)
  {
    uint64_t v8 = 0;
    if (!a4) {
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v8 = __RBPathElementArgumentCount[a2];
    if (!a4) {
      goto LABEL_6;
    }
  }
  switch(a2)
  {
    case 0x10u:
    case 0x12u:
    case 0x16u:
    case 0x17u:
      goto LABEL_6;
    case 0x11u:
    case 0x15u:
      goto LABEL_32;
    case 0x13u:
      if (*a4 || a4[1] || *((void *)a4 + 1))
      {
        double v39 = *a1;
        RB::ProtobufEncoder::encode_varint(*a1, 0x22uLL);
        RB::ProtobufEncoder::begin_length_delimited(v39);
        RB::ProtobufEncoder::encode_varint(v39, 0x12uLL);
        RB::ProtobufEncoder::begin_length_delimited(v39);
        unint64_t v40 = *a4;
        if (v40)
        {
          RB::ProtobufEncoder::encode_varint(v39, 8uLL);
          RB::ProtobufEncoder::encode_varint(v39, v40);
        }
        unint64_t v41 = a4[1];
        if (v41)
        {
          RB::ProtobufEncoder::encode_varint(v39, 0x10uLL);
          RB::ProtobufEncoder::encode_varint(v39, v41);
        }
        unint64_t v42 = *((void *)a4 + 1);
        if (v42 && *((void *)a4 + 2))
        {
          tCGFloat x = 0.0;
          tCGFloat y = 0.0;
          unint64_t v45 = 0;
          __dst.tCGFloat x = 0.0;
          __dst.tCGFloat y = 0.0;
          unint64_t v54 = 8;
          do
          {
            uint64_t v46 = *((void *)a4 + 2);
            *(void *)&CGFloat v47 = *(void *)&ty + 1;
            if (v54 < *(void *)&ty + 1)
            {
              RB::vector<RB::Function::Param,8ul,unsigned long>::reserve_slow(&__dst, *(void *)&ty + 1);
              tCGFloat x = __dst.tx;
              tCGFloat y = __dst.ty;
              *(void *)&CGFloat v47 = *(void *)&__dst.ty + 1;
              unint64_t v42 = *((void *)a4 + 1);
            }
            if (tx == 0.0) {
              p_dst = &__dst;
            }
            else {
              p_dst = *(CGAffineTransform **)&tx;
            }
            float v49 = *(double *)(v46 + 8 * v45);
            *((float *)&p_dst->a + *(void *)&ty) = v49;
            __dst.tCGFloat y = v47;
            ++v45;
            tCGFloat y = v47;
          }
          while (v45 < v42);
          RB::ProtobufEncoder::packed_fixed32_field(v39, 3, (const unsigned int *)p_dst, *(uint64_t *)&v47);
          if (*(void *)&__dst.tx) {
            free(*(void **)&__dst.tx);
          }
        }
        RB::ProtobufEncoder::end_length_delimited(v39);
        RB::ProtobufEncoder::end_length_delimited(v39);
        char v6 = -109;
      }
      else
      {
        char v6 = 19;
      }
      goto LABEL_6;
    case 0x14u:
      if (*(unsigned char *)a4 || *((unsigned char *)a4 + 1))
      {
        __n128 v50 = *a1;
        RB::ProtobufEncoder::encode_varint(*a1, 0x22uLL);
        RB::ProtobufEncoder::begin_length_delimited(v50);
        RB::ProtobufEncoder::encode_varint(v50, 0x1AuLL);
        RB::ProtobufEncoder::begin_length_delimited(v50);
        unint64_t v51 = *(unsigned __int8 *)a4;
        if (*(unsigned char *)a4)
        {
          RB::ProtobufEncoder::encode_varint(v50, 8uLL);
          RB::ProtobufEncoder::encode_varint(v50, v51);
        }
        if (*((unsigned char *)a4 + 1))
        {
          RB::ProtobufEncoder::encode_varint(v50, 0x10uLL);
          RB::ProtobufEncoder::encode_varint(v50, 1uLL);
        }
        RB::ProtobufEncoder::end_length_delimited(v50);
        RB::ProtobufEncoder::end_length_delimited(v50);
        char v6 = -108;
      }
      else
      {
        char v6 = 20;
      }
      goto LABEL_6;
    case 0x18u:
      if (a4[1] == 1 && !*((void *)a4 + 1))
      {
        char v6 = 24;
        goto LABEL_6;
      }
      float64x2_t v29 = *a1;
      RB::ProtobufEncoder::encode_varint(*a1, 0x22uLL);
      RB::ProtobufEncoder::begin_length_delimited(v29);
      RB::ProtobufEncoder::encode_varint(v29, 0x22uLL);
      RB::ProtobufEncoder::begin_length_delimited(v29);
      unint64_t v30 = a4[1];
      if (v30 != 1)
      {
        RB::ProtobufEncoder::encode_varint(v29, 8uLL);
        RB::ProtobufEncoder::encode_varint(v29, v30);
      }
      int v31 = *a4;
      if ((*a4 & 4) != 0)
      {
        RB::ProtobufEncoder::encode_varint(v29, 0x10uLL);
        RB::ProtobufEncoder::encode_varint(v29, 1uLL);
        int v31 = *a4;
        if ((*a4 & 1) == 0)
        {
LABEL_40:
          if ((v31 & 2) == 0) {
            goto LABEL_42;
          }
          goto LABEL_41;
        }
      }
      else if ((v31 & 1) == 0)
      {
        goto LABEL_40;
      }
      RB::ProtobufEncoder::encode_varint(v29, 0x18uLL);
      RB::ProtobufEncoder::encode_varint(v29, 1uLL);
      if ((*a4 & 2) != 0)
      {
LABEL_41:
        RB::ProtobufEncoder::encode_varint(v29, 0x20uLL);
        RB::ProtobufEncoder::encode_varint(v29, 1uLL);
      }
LABEL_42:
      if (*((void *)a4 + 1) && *((void *)a4 + 2))
      {
        uint64_t v32 = 0;
        unint64_t v33 = 0;
        do
        {
          uint64_t v34 = *((void *)a4 + 2);
          RB::ProtobufEncoder::encode_varint(v29, 0x2AuLL);
          RB::ProtobufEncoder::begin_length_delimited(v29);
          int v35 = *(int *)(v34 + v32 + 4);
          if (*(float *)&v35 != 0.0)
          {
            RB::ProtobufEncoder::encode_varint(v29, 0xDuLL);
            RB::ProtobufEncoder::encode_fixed32(v29, v35);
          }
          int v36 = *(int *)(v34 + v32 + 8);
          if (*(float *)&v36 != 0.0)
          {
            RB::ProtobufEncoder::encode_varint(v29, 0x15uLL);
            RB::ProtobufEncoder::encode_fixed32(v29, v36);
          }
          int v37 = *(int *)(v34 + v32 + 12);
          if (*(float *)&v37 != 0.0)
          {
            RB::ProtobufEncoder::encode_varint(v29, 0x1DuLL);
            RB::ProtobufEncoder::encode_fixed32(v29, v37);
          }
          int v38 = *(_DWORD *)(v34 + v32);
          if (v38)
          {
            RB::ProtobufEncoder::encode_varint(v29, 0x20uLL);
            RB::ProtobufEncoder::encode_varint(v29, 1uLL);
            int v38 = *(_DWORD *)(v34 + v32);
          }
          if ((v38 & 2) != 0)
          {
            RB::ProtobufEncoder::encode_varint(v29, 0x28uLL);
            RB::ProtobufEncoder::encode_varint(v29, 1uLL);
          }
          RB::ProtobufEncoder::end_length_delimited(v29);
          ++v33;
          v32 += 16;
        }
        while (v33 < *((void *)a4 + 1));
      }
      if ((*(unsigned char *)a4 & 8) != 0)
      {
        RB::ProtobufEncoder::encode_varint(v29, 0x30uLL);
        RB::ProtobufEncoder::encode_varint(v29, 1uLL);
      }
      RB::ProtobufEncoder::end_length_delimited(v29);
      RB::ProtobufEncoder::end_length_delimited(v29);
      char v6 = -104;
LABEL_6:
      if (v8)
      {
        uint64_t v9 = a3;
        uint64_t v10 = v8;
        while (fabs(*v9) <= 32767.0)
        {
          ++v9;
          if (!--v10) {
            goto LABEL_12;
          }
        }
        v6 |= 0x40u;
      }
LABEL_12:
      uint64_t v11 = a1[10];
      if (a1[11] < (RB::ProtobufEncoder *)((char *)v11 + 1))
      {
        RB::vector<unsigned char,64ul,unsigned long>::reserve_slow(a1 + 1, (size_t)v11 + 1);
        uint64_t v11 = a1[10];
      }
      unint64_t v12 = a1[9];
      if (!v12) {
        unint64_t v12 = (RB::ProtobufEncoder *)(a1 + 1);
      }
      *((unsigned char *)v11 + (void)v12) = v6;
      a1[10] = (RB::ProtobufEncoder *)((char *)a1[10] + 1);
      if ((v6 & 0x40) != 0)
      {
        uint64_t v13 = a1 + 240;
        uint64_t v14 = a1[240];
        if (a1[241] < (RB::ProtobufEncoder *)((char *)v14 + v8))
        {
          RB::vector<RB::DisplayList::Item const*,32ul,unsigned long>::reserve_slow(a1 + 207, (size_t)v14 + v8);
          uint64_t v14 = *v13;
          if (!v8) {
            goto LABEL_30;
          }
        }
        else if (!v8)
        {
          goto LABEL_30;
        }
        unint64_t v20 = a1[239];
        if (!v20) {
          unint64_t v20 = (RB::ProtobufEncoder *)(a1 + 207);
        }
        unint64_t v21 = (double *)((char *)v20 + 8 * (void)v14);
        uint64_t v22 = v8;
        do
        {
          double v23 = *a3++;
          *v21++ = v23;
          --v22;
        }
        while (v22);
      }
      else
      {
        uint64_t v13 = a1 + 205;
        uint64_t v14 = a1[205];
        if (a1[206] < (RB::ProtobufEncoder *)((char *)v14 + v8))
        {
          RB::vector<float,384ul,unsigned long>::reserve_slow(a1 + 12, (size_t)v14 + v8);
          uint64_t v14 = *v13;
          if (!v8) {
            goto LABEL_30;
          }
        }
        else if (!v8)
        {
          goto LABEL_30;
        }
        uint64_t v15 = a1[204];
        if (!v15) {
          uint64_t v15 = (RB::ProtobufEncoder *)(a1 + 12);
        }
        __n128 v16 = (float *)((char *)v15 + 4 * (void)v14);
        uint64_t v17 = v8;
        do
        {
          double v18 = *a3++;
          float v19 = v18;
          *v16++ = v19;
          --v17;
        }
        while (v17);
      }
LABEL_30:
      *uint64_t v13 = (RB::ProtobufEncoder *)((char *)v14 + v8);
      return 1;
    default:
      if (a2 != 4)
      {
LABEL_32:
        long long v25 = *((_OWORD *)a4 + 1);
        *(_OWORD *)&__dst.CGFloat a = *(_OWORD *)a4;
        *(_OWORD *)&__dst.c = v25;
        *(_OWORD *)&__dst.tCGFloat x = *((_OWORD *)a4 + 2);
        if (!CGAffineTransformIsIdentity(&__dst))
        {
          long long v26 = *((_OWORD *)a4 + 1);
          long long v27 = *((_OWORD *)a4 + 2);
          v52[0] = *(_OWORD *)a4;
          v52[1] = v26;
          v52[2] = v27;
          uint64_t v28 = *a1;
          RB::ProtobufEncoder::encode_varint(*a1, 0x22uLL);
          RB::ProtobufEncoder::begin_length_delimited(v28);
          RB::ProtobufEncoder::encode_varint(v28, 0xAuLL);
          RB::ProtobufEncoder::begin_length_delimited(v28);
          RB::AffineTransform::encode((double *)v52, v28);
          RB::ProtobufEncoder::end_length_delimited(v28);
          RB::ProtobufEncoder::end_length_delimited(v28);
          v6 |= 0x80u;
        }
      }
      goto LABEL_6;
  }
}

void sub_2141ECD7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  if (a19) {
    free(a19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RBPathXMLDescription(RBPath,std::string &,unsigned int)::$_0::__invoke<void *,RBPathElement,double const*,void const*>(std::string **a1, unsigned int a2, uint64_t a3, int *a4)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  if (a2 <= 0x18)
  {
    uint64_t v8 = a2;
    int v9 = *((_DWORD *)a1 + 2);
    if (a4)
    {
      switch(a2)
      {
        case 0x10u:
        case 0x12u:
        case 0x16u:
        case 0x17u:
          break;
        case 0x11u:
        case 0x15u:
          goto LABEL_9;
        case 0x13u:
          if (*a4 > 6 || a4[1] > 2)
          {
            uint64_t v36 = __RBPathElementArgumentCount[a2];
            goto LABEL_60;
          }
          uint64_t v10 = *a1;
          if (SHIBYTE((*a1)->__r_.__value_.__r.__words[2]) < 0) {
            std::string::size_type size = v10->__r_.__value_.__l.__size_;
          }
          else {
            std::string::size_type size = HIBYTE((*a1)->__r_.__value_.__r.__words[2]);
          }
          if (size)
          {
            std::string::push_back(v10, 32);
            uint64_t v10 = *a1;
          }
          std::string::append(v10, "{s ", 3uLL);
          std::string::push_back(*a1, 32);
          if (*((void *)a4 + 1))
          {
            unint64_t v41 = 0;
            do
            {
              snprintf_l(__s, 0x40uLL, 0, " %g", *(double *)(*((void *)a4 + 2) + 8 * v41));
              size_t v42 = strlen(__s);
              std::string::append(*a1, __s, v42);
              ++v41;
            }
            while (v41 < *((void *)a4 + 1));
          }
          std::string::push_back(*a1, 125);
          break;
        case 0x14u:
          switch(*(unsigned char *)a4)
          {
            case 0:
              int v26 = *((unsigned __int8 *)a4 + 1);
              long long v27 = "[N";
              uint64_t v28 = "[n";
              goto LABEL_47;
            case 1:
              int v26 = *((unsigned __int8 *)a4 + 1);
              long long v27 = "[I";
              uint64_t v28 = "[i";
              goto LABEL_47;
            case 2:
              int v26 = *((unsigned __int8 *)a4 + 1);
              long long v27 = "[U";
              uint64_t v28 = "[u";
              goto LABEL_47;
            case 3:
              int v26 = *((unsigned __int8 *)a4 + 1);
              long long v27 = "[R";
              uint64_t v28 = "[r";
              goto LABEL_47;
            case 4:
              int v26 = *((unsigned __int8 *)a4 + 1);
              long long v27 = "[X";
              uint64_t v28 = "[x";
              goto LABEL_47;
            case 5:
              int v26 = *((unsigned __int8 *)a4 + 1);
              long long v27 = "[lI";
              uint64_t v28 = "[li";
              goto LABEL_47;
            case 6:
              int v26 = *((unsigned __int8 *)a4 + 1);
              long long v27 = "[lR";
              uint64_t v28 = "[lr";
LABEL_47:
              if (v26) {
                int v38 = (char *)v27;
              }
              else {
                int v38 = (char *)v28;
              }
              unint64_t v53 = v38;
              break;
            default:
              break;
          }
          uint64_t v36 = __RBPathElementArgumentCount[a2];
          goto LABEL_65;
        case 0x18u:
          uint64_t v52 = a2;
          std::string::append(*a1, "{k ", 3uLL);
          if (*(unsigned char *)a4) {
            std::string::append(*a1, " inverse", 8uLL);
          }
          if (*((void *)a4 + 1))
          {
            uint64_t v30 = 0;
            unint64_t v31 = 0;
            do
            {
              uint64_t v32 = *((void *)a4 + 2) + v30;
              unint64_t v33 = "^";
              if ((*(_DWORD *)v32 & 1) == 0) {
                unint64_t v33 = "";
              }
              uint64_t v34 = "*";
              if ((*(_DWORD *)v32 & 2) == 0) {
                uint64_t v34 = "";
              }
              snprintf_l(__s, 0x40uLL, 0, " %s%s%g:%g,%g", v33, v34, *(float *)(v32 + 4), *(float *)(v32 + 8), *(float *)(v32 + 12));
              size_t v35 = strlen(__s);
              std::string::append(*a1, __s, v35);
              ++v31;
              v30 += 16;
            }
            while (v31 < *((void *)a4 + 1));
          }
          std::string::push_back(*a1, 125);
          uint64_t v8 = v52;
          break;
        default:
          if (a2 == 4) {
            break;
          }
LABEL_9:
          long long v12 = *((_OWORD *)a4 + 1);
          *(_OWORD *)&v54.CGFloat a = *(_OWORD *)a4;
          *(_OWORD *)&v54.c = v12;
          *(_OWORD *)&v54.tCGFloat x = *((_OWORD *)a4 + 2);
          if (!CGAffineTransformIsIdentity(&v54))
          {
            double v13 = *(double *)a4;
            double v14 = *((double *)a4 + 1);
            double v15 = round(*(double *)a4 * 32.0) * 0.03125;
            if ((v9 & 2) != 0) {
              double v13 = v15;
            }
            double v16 = round(v14 * 32.0) * 0.03125;
            if ((v9 & 2) != 0) {
              double v14 = v16;
            }
            double v17 = *((double *)a4 + 2);
            double v18 = *((double *)a4 + 3);
            double v19 = round(v17 * 32.0) * 0.03125;
            if ((v9 & 2) != 0) {
              double v17 = v19;
            }
            double v20 = round(v18 * 32.0) * 0.03125;
            if ((v9 & 2) != 0) {
              double v18 = v20;
            }
            double v21 = *((double *)a4 + 4);
            double v22 = round(v21 * 32.0) * 0.03125;
            if ((v9 & 2) != 0) {
              double v21 = v22;
            }
            double v23 = round(*((double *)a4 + 5) * 32.0) * 0.03125;
            if ((v9 & 2) == 0) {
              double v23 = *((double *)a4 + 5);
            }
            snprintf_l(__s, 0x100uLL, 0, "%g %g %g %g %g %g t", v13, v14, v17, v18, v21, v23);
            float64x2_t v24 = *a1;
            if (SHIBYTE((*a1)->__r_.__value_.__r.__words[2]) < 0) {
              std::string::size_type v25 = v24->__r_.__value_.__l.__size_;
            }
            else {
              std::string::size_type v25 = HIBYTE((*a1)->__r_.__value_.__r.__words[2]);
            }
            if (v25)
            {
              std::string::push_back(*a1, 32);
              float64x2_t v24 = *a1;
            }
            size_t v37 = strlen(__s);
            std::string::append(v24, __s, v37);
          }
          break;
      }
    }
    uint64_t v36 = __RBPathElementArgumentCount[v8];
    if (a2 == 19)
    {
LABEL_60:
      if (!a4 || *(double *)(a3 + 16) == 0.0)
      {
        if (*(double *)(a3 + 8) == 10.0) {
          v36 -= 2;
        }
        else {
          --v36;
        }
      }
    }
LABEL_65:
    if (v36)
    {
      uint64_t v43 = 0;
      while (1)
      {
        double v44 = *(double *)(a3 + 8 * v43);
        double v45 = round(v44 * 32.0) * 0.03125;
        if ((v9 & 2) != 0) {
          double v44 = v45;
        }
        snprintf_l(__s, 0x40uLL, 0, "%g", v44);
        uint64_t v46 = *a1;
        if (v43) {
          goto LABEL_72;
        }
        if (SHIBYTE(v46->__r_.__value_.__r.__words[2]) < 0) {
          break;
        }
        if (*((unsigned char *)&v46->__r_.__value_.__s + 23)) {
          goto LABEL_72;
        }
LABEL_73:
        size_t v47 = strlen(__s);
        std::string::append(v46, __s, v47);
        if (v36 == ++v43) {
          goto LABEL_77;
        }
      }
      if (!v46->__r_.__value_.__l.__size_) {
        goto LABEL_73;
      }
LABEL_72:
      std::string::push_back(*a1, 32);
      uint64_t v46 = *a1;
      goto LABEL_73;
    }
LABEL_77:
    int8x16_t v48 = *a1;
    if (SHIBYTE((*a1)->__r_.__value_.__r.__words[2]) < 0) {
      std::string::size_type v49 = v48->__r_.__value_.__l.__size_;
    }
    else {
      std::string::size_type v49 = HIBYTE((*a1)->__r_.__value_.__r.__words[2]);
    }
    if (a2 != 16 && v49)
    {
      std::string::push_back(*a1, 32);
      int8x16_t v48 = *a1;
    }
    size_t v50 = strlen(v53);
    std::string::append(v48, v53, v50);
  }
  return 1;
}

void RBPathCopyData::$_0::__invoke(RBPathCopyData::$_0 *this, void **a2, void *a3)
{
  if (a2)
  {
    if (*a2) {
      free(*a2);
    }
    JUMPOUT(0x21669AC10);
  }
}

uint64_t RBPathCopyDebugDescription::$_0::__invoke<void *,RBPathElement,double const*,void const*>(__CFString *a1, unsigned int a2, uint64_t *a3, unsigned int *a4)
{
  CFStringAppendCString(a1, "\n  ", 0x8000100u);
  if (a2 > 0x18) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = __RBPathElementArgumentCount[a2];
  }
  for (; v8; --v8)
  {
    uint64_t v9 = *a3++;
    CFStringAppendFormat(a1, 0, @" %g", v9);
  }
  if (a4)
  {
    switch(a2)
    {
      case 0x10u:
      case 0x12u:
      case 0x16u:
      case 0x17u:
        return 1;
      case 0x11u:
      case 0x15u:
        goto LABEL_11;
      case 0x13u:
        uint64_t v10 = *a4;
        if (v10 > 6) {
          uint64_t v11 = "unknown";
        }
        else {
        uint64_t v15 = a4[1];
        }
        if (v15 > 2) {
          double v16 = "unknown";
        }
        else {
        CFStringAppendFormat(a1, 0, @" %s %s [", v11, v16);
        }
        if (*((void *)a4 + 1))
        {
          unint64_t v24 = 0;
          do
          {
            if (v24) {
              std::string::size_type v25 = ", ";
            }
            else {
              std::string::size_type v25 = "";
            }
            CFStringAppendFormat(a1, 0, @"%s%g", v25, *(void *)(*((void *)a4 + 2) + 8 * v24++));
          }
          while (v24 < *((void *)a4 + 1));
        }
        goto LABEL_42;
      case 0x14u:
        if (*((unsigned char *)a4 + 1)) {
          double v14 = "even-odd";
        }
        else {
          double v14 = "non-zero";
        }
        return 1;
      case 0x18u:
        uint64_t v12 = a4[1];
        if (v12 > 6) {
          double v13 = "unknown";
        }
        else {
        CFStringAppendFormat(a1, 0, @" %s [", v13);
        }
        if (*((void *)a4 + 1))
        {
          uint64_t v17 = 0;
          unint64_t v18 = 0;
          do
          {
            double v19 = (float *)(*((void *)a4 + 2) + v17);
            float v20 = *v19;
            if (v18) {
              double v21 = ", ";
            }
            else {
              double v21 = "";
            }
            if (LOBYTE(v20)) {
              double v22 = "^";
            }
            else {
              double v22 = "";
            }
            if ((LOBYTE(v20) & 2) != 0) {
              double v23 = "*";
            }
            else {
              double v23 = "";
            }
            CFStringAppendFormat(a1, 0, @"%s%s%s%g:%g,%g", v21, v22, v23, v19[1], v19[2], v19[3]);
            ++v18;
            v17 += 16;
          }
          while (v18 < *((void *)a4 + 1));
        }
LABEL_42:
        CFStringAppendCString(a1, "]", 0x8000100u);
        break;
      default:
        if (a2 != 4) {
LABEL_11:
        }
          CFStringAppendFormat(a1, 0, @" affine(%g %g; %g %g; %g %g)",
            *(void *)a4,
            *((void *)a4 + 1),
            *((void *)a4 + 2),
            *((void *)a4 + 3),
            *((void *)a4 + 4),
            *((void *)a4 + 5));
        break;
    }
  }
  return 1;
}

uint64_t anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::{lambda(void const*)#1}::__invoke(uint64_t result)
{
  return result;
}

uint64_t anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::{lambda(void const*,void *,BOOL (*)(void const*,RBPathElement,double const*,void const))#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  if (*(unsigned char *)(a1 + 48)) {
    uint64_t v3 = a1 + 56;
  }
  else {
    uint64_t v3 = 0;
  }
  return a3(a2, 7, a1 + 16, v3);
}

BOOL anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::{lambda(void const*,void const)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 48) != *(unsigned __int8 *)(a2 + 48)) {
    return 0;
  }
  BOOL v2 = *(void *)(a1 + 16) == *(void *)(a2 + 16) && *(void *)(a1 + 24) == *(void *)(a2 + 24);
  BOOL v3 = v2 && *(void *)(a1 + 32) == *(void *)(a2 + 32);
  if (!v3 || *(void *)(a1 + 40) != *(void *)(a2 + 40)) {
    return 0;
  }
  if (!*(unsigned char *)(a1 + 48)) {
    return 1;
  }
  long long v6 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&t1.CGFloat a = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&t1.c = v6;
  *(_OWORD *)&t1.tCGFloat x = *(_OWORD *)(a1 + 88);
  long long v7 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)&v8.CGFloat a = *(_OWORD *)(a2 + 56);
  *(_OWORD *)&v8.c = v7;
  *(_OWORD *)&v8.tCGFloat x = *(_OWORD *)(a2 + 88);
  BOOL result = CGAffineTransformEqualToTransform(&t1, &v8);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::{lambda(void const*)#3}::__invoke()
{
  return 0;
}

uint64_t anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::{lambda(void const*)#4}::__invoke()
{
  return 1;
}

uint64_t anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::{lambda(void const*)#5}::__invoke()
{
  return 3;
}

atomic_uint *RB::Refcount<RBPath anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::Info,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::TransformInfo::~TransformInfo()
{
}

uint64_t anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#1}::__invoke(uint64_t result)
{
  return result;
}

BOOL anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*,void const)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 72);
  if (v2 != *(unsigned __int8 *)(a2 + 72) || memcmp((const void *)(a1 + 16), (const void *)(a2 + 16), 0x38uLL)) {
    return 0;
  }
  if (!v2) {
    return 1;
  }
  long long v6 = *(_OWORD *)(a1 + 96);
  *(_OWORD *)&t1.CGFloat a = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&t1.c = v6;
  *(_OWORD *)&t1.tCGFloat x = *(_OWORD *)(a1 + 112);
  long long v7 = *(_OWORD *)(a2 + 96);
  *(_OWORD *)&v8.CGFloat a = *(_OWORD *)(a2 + 80);
  *(_OWORD *)&v8.c = v7;
  *(_OWORD *)&v8.tCGFloat x = *(_OWORD *)(a2 + 112);
  BOOL result = CGAffineTransformEqualToTransform(&t1, &v8);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#3}::__invoke()
{
  return 0;
}

uint64_t anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#4}::__invoke()
{
  return 1;
}

uint64_t anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#5}::__invoke()
{
  return 3;
}

atomic_uint *RB::Refcount<RBPath anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::Info,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::TransformInfo::~TransformInfo()
{
}

uint64_t anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#1}::__invoke(uint64_t result)
{
  return result;
}

atomic_uint *anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#2}::__invoke(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*,void *,BOOL (*)(void const*,RBPathElement,double const*,void const))#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  if (*(unsigned char *)(a1 + 88)) {
    uint64_t v4 = a1 + 96;
  }
  else {
    uint64_t v4 = 0;
  }
  if (*(unsigned char *)(a1 + 80)) {
    uint64_t v5 = 11;
  }
  else {
    uint64_t v5 = 10;
  }
  return a3(a2, v5, a1 + 16, v4);
}

BOOL anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*,void const)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 88);
  if (v2 != *(unsigned __int8 *)(a2 + 88) || memcmp((const void *)(a1 + 16), (const void *)(a2 + 16), 0x48uLL)) {
    return 0;
  }
  if (!v2) {
    return 1;
  }
  long long v6 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)&t1.CGFloat a = *(_OWORD *)(a1 + 96);
  *(_OWORD *)&t1.c = v6;
  *(_OWORD *)&t1.tCGFloat x = *(_OWORD *)(a1 + 128);
  long long v7 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)&v8.CGFloat a = *(_OWORD *)(a2 + 96);
  *(_OWORD *)&v8.c = v7;
  *(_OWORD *)&v8.tCGFloat x = *(_OWORD *)(a2 + 128);
  BOOL result = CGAffineTransformEqualToTransform(&t1, &v8);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#3}::__invoke()
{
  return 0;
}

uint64_t anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#4}::__invoke()
{
  return 1;
}

uint64_t anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#5}::__invoke()
{
  return 3;
}

atomic_uint *RB::Refcount<RBPath anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::Info,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::Refcount<RBPath anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::Info,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::TransformInfo::~TransformInfo()
{
}

void anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::Info::~Info()
{
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::{lambda(void const*)#1}::__invoke(uint64_t result)
{
  return result;
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::{lambda(void const*,void const)#1}::__invoke(void *a1, void *a2)
{
  if (memcmp(a1 + 4, a2 + 4, 0x30uLL)) {
    return 0;
  }
  uint64_t v5 = a1[2];
  uint64_t v6 = a1[3];
  uint64_t v7 = a2[2];
  CGAffineTransform v8 = (void *)a2[3];
  return RBPathEqualToPath(v5, v6, v7, v8);
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::{lambda(void const*)#3}::__invoke()
{
  return 0;
}

atomic_uint *RB::Refcount<RBPath anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::Info,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void *anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::Info::~Info(void *a1)
{
  *a1 = &unk_26C4EE5B0;
  int v2 = *(void (**)(void))(a1[3] + 16);
  if (v2) {
    v2(a1[2]);
  }
  return a1;
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::{lambda(void const*)#1}::__invoke(uint64_t result)
{
  return result;
}

atomic_uint *anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::{lambda(void const*)#2}::__invoke(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::{lambda(void const*,void *,BOOL (*)(void const*,RBPathElement,double const*,void const))#1}::__invoke(uint64_t *a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t *, void *))
{
  uint64_t v6 = a1 + 4;
  v9[0] = a1[7];
  uint64_t v7 = a1[8];
  v9[1] = a1[9];
  v9[2] = v7;
  uint64_t result = a3(a2, 19, a1 + 4, v9);
  if (result)
  {
    uint64_t result = RBPathApplyElements(a1[2], a1[3], a2, (uint64_t)a3);
    if (result) {
      return a3(a2, 16, v6, 0);
    }
  }
  return result;
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::{lambda(void const*,void const)#1}::__invoke(void *a1, void *a2)
{
  if (memcmp(a1 + 4, a2 + 4, 0x38uLL)) {
    return 0;
  }
  uint64_t v5 = a1[2];
  uint64_t v6 = a1[3];
  uint64_t v7 = a2[2];
  CGAffineTransform v8 = (void *)a2[3];
  return RBPathEqualToPath(v5, v6, v7, v8);
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::{lambda(void const*)#3}::__invoke()
{
  return 0;
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::{lambda(void const*)#4}::__invoke()
{
  return 1;
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::{lambda(void const*)#5}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

atomic_uint *RB::Refcount<RBPath anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::Info,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::Refcount<RBPath anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::Info,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void *anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::Info::~Info(void *a1)
{
  *a1 = &unk_26C4EE550;
  int v2 = (void *)a1[8];
  if (v2) {
    free(v2);
  }
  BOOL v3 = *(void (**)(void))(a1[3] + 16);
  if (v3) {
    v3(a1[2]);
  }
  return a1;
}

void anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::Info::~Info(void *a1)
{
  *a1 = &unk_26C4EE550;
  int v2 = (void *)a1[8];
  if (v2) {
    free(v2);
  }
  BOOL v3 = *(void (**)(void))(a1[3] + 16);
  if (v3) {
    v3(a1[2]);
  }
  JUMPOUT(0x21669AC10);
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::{lambda(void const*)#1}::__invoke(uint64_t result)
{
  return result;
}

atomic_uint *anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::{lambda(void const*)#2}::__invoke(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::{lambda(void const*,void *,BOOL (*)(void const*,RBPathElement,double const*,void const))#1}::__invoke(uint64_t a1, uint64_t a2, unsigned int (*a3)(uint64_t, uint64_t, uint64_t, void))
{
  uint64_t v5 = a1 + 32;
  if (!a3(a2, 18, a1 + 32, 0)
    || !RBPathApplyElements(*(void *)(a1 + 16), *(void *)(a1 + 24), a2, (uint64_t)a3))
  {
    return 0;
  }
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, void))a3)(a2, 16, v5, 0);
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::{lambda(void const*,void const)#1}::__invoke(uint64_t *a1, uint64_t a2)
{
  if (a1[4] == *(void *)(a2 + 32) && a1[5] == *(void *)(a2 + 40)) {
    return RBPathEqualToPath(a1[2], a1[3], *(void *)(a2 + 16), *(void **)(a2 + 24));
  }
  else {
    return 0;
  }
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::{lambda(void const*)#3}::__invoke()
{
  return 0;
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::{lambda(void const*)#4}::__invoke()
{
  return 1;
}

uint64_t anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::{lambda(void const*)#5}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

atomic_uint *RB::Refcount<RBPath anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::Info,std::atomic<unsigned int>>::release(atomic_uint *result)
{
  if (atomic_fetch_add_explicit(result + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t RB::Refcount<RBPath anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::Info,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void *anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::Info::~Info(void *a1)
{
  *a1 = &unk_26C4EE580;
  int v2 = *(void (**)(void))(a1[3] + 16);
  if (v2) {
    v2(a1[2]);
  }
  return a1;
}

void anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::Info::~Info(void *a1)
{
  *a1 = &unk_26C4EE580;
  float32x2_t v1 = *(void (**)(void))(a1[3] + 16);
  if (v1) {
    v1(a1[2]);
  }
  JUMPOUT(0x21669AC10);
}

void *RB::vector<BOOL,16ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  if (*((void *)__dst + 4) + (*((void *)__dst + 4) >> 1) <= a2) {
    size_t v3 = a2;
  }
  else {
    size_t v3 = *((void *)__dst + 4) + (*((void *)__dst + 4) >> 1);
  }
  uint64_t result = RB::details::realloc_vector<unsigned long,1ul>(*((void **)__dst + 2), __dst, 0x10uLL, (size_t *)__dst + 4, v3);
  *((void *)__dst + 2) = result;
  return result;
}

uint64_t std::array<RB::RenderPass::AttachmentData,4ul>::~array(uint64_t a1)
{
  for (uint64_t i = 72; i != -24; i -= 24)
  {
    size_t v3 = *(_DWORD **)(a1 + i);
    if (v3)
    {
      int v4 = v3[2] - 1;
      void v3[2] = v4;
      if (!v4) {
        (*(void (**)(_DWORD *))(*(void *)v3 + 8))(v3);
      }
    }
  }
  return a1;
}

uint64_t RB::RenderPass::push_layer(uint64_t this)
{
  *(_DWORD *)(this + 136) = 2;
  return this;
}

uint64_t RB::RenderPass::pop_layer(uint64_t this)
{
  *(_DWORD *)(this + 136) = 0;
  return this;
}

void RB::RenderPass::set_color_space(id ***a1, int a2)
{
  if (*((unsigned __int8 *)a1 + 124) != a2)
  {
    char v2 = a2;
    if (a1[19]) {
      RB::RenderFrame::flush_pass(**a1, (RB::RenderPass *)a1, 0);
    }
    *((unsigned char *)a1 + 124) = v2;
  }
}

int32x2_t *RB::RenderPass::draw_primitives(int32x2_t *result, const char *a2, uint64_t a3, __int32 a4, unint64_t a5, uint64_t a6, int32x2_t a7, int32x2_t a8)
{
  int32x2_t v15 = a7;
  int32x2_t v16 = a8;
  if (a5 && a6)
  {
    if ((a6 | a5) >> 32) {
      RB::precondition_failure((RB *)"invalid vertex or instance count", a2, *(void *)&v15, *(void *)&v16);
    }
    double v13 = (id ***)result;
    uint64_t result = RB::Bounds::intersect(&v15, result[20], result[21]);
    uint32x2_t v14 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v16);
    if ((vpmax_u32(v14, v14).u32[0] & 0x80000000) == 0)
    {
      uint64_t result = (int32x2_t *)RB::RenderPass::draw(v13, a2, (int8x8_t *)&v15, 0);
      result[5].i8[2] = a3;
      result[3].i32[0] = a4;
      result[3].i32[1] = a5;
      result[4].i32[0] = a6;
      result[4].i32[1] = 0;
      if (a3 == 4) {
        (**v13)[4] = (char *)(**v13)[4] + (a5 - 2) * a6;
      }
    }
  }
  return result;
}

unsigned __int8 *RB::RenderPass::draw_custom(uint64_t a1, const char *a2, uint64_t a3, _OWORD *a4, int a5, int32x2_t a6, int32x2_t a7, float a8)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  int32x2_t v20 = a6;
  int32x2_t v21 = a7;
  uint64_t result = (unsigned __int8 *)RB::Bounds::intersect(&v20, *(int32x2_t *)(a1 + 160), *(int32x2_t *)(a1 + 168));
  uint32x2_t v15 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v21);
  if ((vpmax_u32(v15, v15).u32[0] & 0x80000000) == 0)
  {
    long long v16 = a4[1];
    *(_OWORD *)&v22[8] = *a4;
    *(_OWORD *)&v22[24] = v16;
    *(_OWORD *)&v22[40] = a4[2];
    uint64_t result = (unsigned __int8 *)RB::RenderPass::draw((id ***)a1, a2, (int8x8_t *)&v20, 80);
    unint64_t v17 = (unint64_t)(result + 49);
    if (result[48]) {
      unint64_t v17 = ((unint64_t)(result + 56) & 0xFFFFFFFFFFFFFFF8) + 16;
    }
    uint64_t v18 = v17 + 12 * result[47] + 8 * result[46];
    *(_OWORD *)(v18 + 40) = *(_OWORD *)&v22[32];
    long long v19 = *(_OWORD *)v22;
    *(_OWORD *)(v18 + 24) = *(_OWORD *)&v22[16];
    *(void *)uint64_t v18 = a3;
    *(void *)(v18 + 56) = *(void *)&v22[48];
    *(_OWORD *)(v18 + 8) = v19;
    *(float *)(v18 + 64) = a8;
    *(_DWORD *)(v18 + 68) = a5;
  }
  return result;
}

float RB::RenderPass::color_convert(uint64_t a1, int a2, int a3, int a4, int32x2_t a5)
{
  RB::Coverage::set_plane((float32x2_t *)&v17, a1, a5);
  if (*(_DWORD *)(a1 + 136) == 2) {
    unsigned int v9 = 131107;
  }
  else {
    unsigned int v9 = 35;
  }
  long long v16 = (const char *)v9;
  if (RB::RenderState::set_color_conversion((int *)&v16, a2, a3, (_DWORD *)&v18 + 3))
  {
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x20, 4uLL, 0, &v19);
    uint64_t v11 = v19;
    if (v19)
    {
      uint64_t v12 = (_OWORD *)(*((void *)v19 + 7) + v20.i64[0]);
      long long v13 = v18;
      *uint64_t v12 = v17;
      v12[1] = v13;
    }
    else
    {
      long long v19 = 0;
      int64x2_t v20 = 0uLL;
    }
    *(_DWORD *)(a1 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v11);
    *(int32x2_t *)(a1 + 188) = vmovn_s64(v20);
    if (!a4
      || (uint32x2_t v15 = RB::pixel_format_traits(*(void *)(a1 + 16), v14),
          ((*v15 | ((unint64_t)*((unsigned __int16 *)v15 + 2) << 32)) & 0x100000000) == 0))
    {
      LODWORD(v16) = v16 | 0x1000000;
    }
    RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, v16, 4, ***(void ***)a1 + 80, 0, 1uLL, 0, *(int32x2_t *)(a1 + 104));
    float result = *(float *)(a1 + 120) + 1.0;
    *(float *)(a1 + 120) = result;
  }
  return result;
}

float RB::RenderPass::resolve_srgb_alpha(RB::RenderPass *this, int32x2_t a2)
{
  RB::Coverage::set_plane((float32x2_t *)&v8, (uint64_t)this, a2);
  HIDWORD(v9) = 1065353216;
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)this, (RB::Device *)0x20, 4uLL, 0, &v10);
  size_t v3 = v10;
  if (v10)
  {
    int v4 = (_OWORD *)(*((void *)v10 + 7) + v11.i64[0]);
    long long v5 = v9;
    _OWORD *v4 = v8;
    v4[1] = v5;
  }
  else
  {
    uint64_t v10 = 0;
    int64x2_t v11 = 0uLL;
  }
  *((_DWORD *)this + 46) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)this, v3);
  *(int32x2_t *)((char *)this + 188) = vmovn_s64(v11);
  if (*((_DWORD *)this + 34) == 2) {
    uint64_t v6 = 131171;
  }
  else {
    uint64_t v6 = 99;
  }
  RB::RenderPass::draw_indexed_primitives((int32x2_t *)this, (const char *)v6, 4, ***(void ***)this + 80, 0, 1uLL, 0, *(int32x2_t *)((char *)this + 104));
  float result = *((float *)this + 30) + 1.0;
  *((float *)this + 30) = result;
  return result;
}

void RB::RenderPass::resolve_framebuffer(RB::RenderPass *this, int32x2_t *a2, int32x2_t *a3, const RB::RenderTask *a4, int32x2_t a5, double a6, __n128 a7, __n128 a8)
{
  uint64_t v62 = *MEMORY[0x263EF8340];
  uint64_t v12 = *(void *)this;
  long long v13 = *(RB **)(*(void *)this + 8);
  MTLPixelFormat v14 = (RB *)a2[7];
  unint64_t v15 = (unint64_t)a3[7];
  int v16 = a3[10].u8[0];
  int v17 = 8;
  int v18 = 3;
  __int16 v19 = 128;
  switch((unint64_t)v13)
  {
    case 0x80000001uLL:
      if (v14 != (RB *)10 || v15 != 80) {
        goto LABEL_81;
      }
      goto LABEL_27;
    case 0x80000002uLL:
      if (v14 != (RB *)10 || v15 != 81) {
        goto LABEL_81;
      }
      __int16 v19 = 2;
      int v17 = 17;
      goto LABEL_38;
    case 0x80000003uLL:
      if (v14 != (RB *)25 || v15 != 115) {
        goto LABEL_81;
      }
LABEL_27:
      __int16 v19 = 2;
      int v17 = 16;
      goto LABEL_38;
    case 0x80000004uLL:
      int v20 = 1;
LABEL_14:
      if (v14 == (RB *)40) {
        goto LABEL_17;
      }
      if (v14 != (RB *)23) {
        goto LABEL_81;
      }
      __int16 v19 = 35;
      goto LABEL_18;
    case 0x80000005uLL:
      int v20 = 1;
LABEL_10:
      if (v14 == (RB *)43)
      {
LABEL_17:
        __int16 v19 = 32;
      }
      else
      {
        if (v14 != (RB *)23)
        {
LABEL_81:
          unint64_t v41 = (RB *)a3[7];
          size_t v42 = RB::pixel_format_name(v13, (MTLPixelFormat)a2);
          double v44 = RB::pixel_format_name(v14, v43);
          uint64_t v46 = RB::pixel_format_name(v41, v45);
          RB::precondition_failure((RB *)"unexpected framebuffer resolve: %s, %s, %s", v47, v42, v44, v46);
        }
        __int16 v19 = 36;
      }
LABEL_18:
      int v17 = v20 | 0x18;
      goto LABEL_38;
    case 0x80000006uLL:
      int v17 = 9;
LABEL_29:
      if (v14 != (RB *)42) {
        goto LABEL_81;
      }
LABEL_37:
      __int16 v19 = 0;
LABEL_38:
      int v18 = a2[10].u8[0];
      break;
    case 0x80000007uLL:
    case 0x80000009uLL:
      break;
    case 0x80000008uLL:
    case 0x8000000AuLL:
      int v18 = 2;
      break;
    case 0x8000000BuLL:
    case 0x8000000CuLL:
      if (a2 != a3 || v14 != (RB *)115) {
        goto LABEL_81;
      }
      int v17 = 0;
      __int16 v19 = 0;
      int v16 = *(unsigned __int8 *)(v12 + 29);
      int v18 = 5;
      break;
    default:
      int v20 = 0;
      switch((unint64_t)v13)
      {
        case '(':
          goto LABEL_14;
        case ')':
          if (v14 != (RB *)41) {
            goto LABEL_81;
          }
          int v20 = 0;
          goto LABEL_17;
        case '*':
          goto LABEL_29;
        case '+':
          goto LABEL_10;
        default:
          if (v14 != v13 || v15 != (void)v13) {
            goto LABEL_81;
          }
          int v17 = 0;
          goto LABEL_37;
      }
  }
  float v22 = 1.0;
  if (v18 != v16)
  {
    if (v16 == 1 || v16 == 3)
    {
      uint64_t v30 = RB::pixel_format_traits(v15, (MTLPixelFormat)a2);
      if (((*v30 | ((unint64_t)*((unsigned __int16 *)v30 + 2) << 32)) & 0x1000000000) == 0) {
        v17 |= 4u;
      }
    }
    else if (v16 == 5)
    {
      int8x16_t v48 = RB::color_space_name(v18);
      int v49 = 5;
      goto LABEL_84;
    }
    int v39 = v18 | (v16 << 8) | 0x101;
    if (v39 == 261)
    {
      v19 |= 0x18u;
LABEL_74:
      if (v18 != 1)
      {
        if (v18 == 5)
        {
          {
            uint64_t v53 = RB::debug_float((RB *)"RB_PQ_WHITE", v52);
            float v54 = *(float *)&v53;
            if ((v53 & 0xFF00000000) == 0) {
              float v54 = 203.0;
            }
            RB::RenderPass::resolve_framebuffer(RB::Texture *,RB::Texture *,RB::RenderTask const*)::reference_white = LODWORD(v54);
          }
          int v17 = v17 & 0x1C | 2;
          float v22 = *(float *)&RB::RenderPass::resolve_framebuffer(RB::Texture *,RB::Texture *,RB::RenderTask const*)::reference_white
              * 0.0001;
          goto LABEL_40;
        }
        if (v18 != 3) {
          goto LABEL_40;
        }
      }
      size_t v40 = RB::pixel_format_traits((unint64_t)v13, (MTLPixelFormat)a2);
      if (((*v40 | ((unint64_t)*((unsigned __int16 *)v40 + 2) << 32)) & 0x1000000000) == 0) {
        int v17 = v17 & 0x1C | 1;
      }
      goto LABEL_40;
    }
    if (v39 == 259)
    {
      __int16 v19 = v19 & 0xFFE7 | 0x10;
      goto LABEL_74;
    }
    int8x16_t v48 = RB::color_space_name(v18);
    int v49 = v16;
LABEL_84:
    size_t v50 = RB::color_space_name(v49);
    RB::precondition_failure((RB *)"unexpected framebuffer colorspace: %s, %s", v51, v48, v50);
  }
LABEL_40:
  if (a3 == a2) {
    int v23 = 35;
  }
  else {
    int v23 = 33;
  }
  unsigned int v24 = v23 & 0xFFFF003F | ((v19 & 0x3FF) << 6) | ((*((_DWORD *)this + 34) == 2) << 17) | (v17 << 20);
  if (a3 == a2)
  {
    int v27 = 1;
    uint64_t v28 = this;
    if (!a4) {
      goto LABEL_66;
    }
    goto LABEL_61;
  }
  std::string::size_type v25 = **(RB::RenderFrame ***)this;
  if (*(unsigned char *)(*(void *)v25 + 285))
  {
    int v26 = RB::RenderFrame::texture_id(v25, (uint64_t)a2);
    int v27 = 1;
    uint64_t v28 = this;
  }
  else
  {
    RB::RenderFrame::flush_pass((id *)v25, this, 1);
    MEMORY[0x270FA5388](v31, v32);
    uint64_t v28 = (RB::RenderPass *)v55;
    memset(v55, 0, sizeof(v55));
    RB::RenderPass::RenderPass((uint64_t)v55, *(void *)this, a2, 0, 0, (uint64_t)v14);
    if ((v19 & 7) == 2) {
      int v27 = 3;
    }
    else {
      int v27 = 1;
    }
    int v26 = RB::RenderFrame::texture_id(*(RB::RenderFrame **)v55[0], (uint64_t)a3);
    unsigned int v24 = v24 & 0x1F2FFC0 | 0x22;
  }
  *((_DWORD *)v28 + 58) = v26;
  if (a4)
  {
LABEL_61:
    int8x8_t v33 = (int8x8_t)vdup_n_s32(0x7F7FFFFFu);
    do
    {
      a5.i32[0] = 0;
      a8.n128_u64[0] = *((void *)a4 + 7);
      a7.n128_u64[0] = *((void *)a4 + 8);
      a7.n128_u32[0] *= v27;
      a8.n128_u32[0] *= v27;
      uint32x2_t v34 = (uint32x2_t)vceq_s32((int32x2_t)a8.n128_u64[0], (int32x2_t)0x8000000080000000);
      int8x8_t v35 = (int8x8_t)vdup_lane_s32(vcgt_s32(a5, (int32x2_t)vpmin_u32(v34, v34)), 0);
      __n128 v56 = a8;
      __n128 v57 = a7;
      RB::Coverage::set_plane((float32x2_t *)&v58, (float32x2_t *)v28, (float32x2_t)vbsl_s8(v35, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)a7.n128_u64[0])), COERCE_DOUBLE(vbsl_s8(v35, v33, (int8x8_t)vcvt_f32_s32((int32x2_t)a8.n128_u64[0]))));
      *((float *)&v59 + 3) = v22;
      RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v28, (RB::Device *)0x20, 4uLL, 0, &v60);
      uint64_t v36 = v60;
      if (v60)
      {
        size_t v37 = (_OWORD *)(*((void *)v60 + 7) + v61.i64[0]);
        long long v38 = v59;
        *size_t v37 = v58;
        v37[1] = v38;
      }
      else
      {
        long long v60 = 0;
        int64x2_t v61 = 0uLL;
      }
      *((_DWORD *)v28 + 46) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v28, v36);
      *(int32x2_t *)((char *)v28 + 188) = vmovn_s64(v61);
      RB::RenderPass::draw_indexed_primitives((int32x2_t *)v28, (const char *)v24, 4, ***(void ***)v28 + 80, 0, 1uLL, (int32x2_t)v57.n128_u64[0], (int32x2_t)v56.n128_u64[0]);
      a4 = (const RB::RenderTask *)*((void *)a4 + 6);
    }
    while (a4);
  }
LABEL_66:
  if (v28 == this)
  {
    *((_DWORD *)this + 58) = 0;
    *((unsigned char *)this + 236) = 0;
  }
  else
  {
    RB::RenderPass::~RenderPass(v28);
  }
}

void sub_2141EED9C(_Unwind_Exception *a1)
{
}

uint64_t RB::RenderPass::WorkingSpace::WorkingSpace(uint64_t a1, MTLPixelFormat a2, __int16 a3, char a4, unsigned __int8 a5)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = 0;
  int v6 = *(unsigned __int8 *)(a2 + 124);
  *(unsigned char *)(a1 + 16) = v6;
  *(unsigned char *)(a1 + 17) = a4;
  *(unsigned char *)(a1 + 18) = 0;
  uint64_t v7 = *(RB::RenderParams **)a2;
  if ((*(unsigned char *)(*(void *)a2 + 31) & 8) == 0)
  {
    unsigned __int8 v8 = a3;
    if ((a3 & 0xFF00) != 0)
    {
      *(unsigned char *)(a1 + 16) = a3;
      if (v6 != a3)
      {
        MTLPixelFormat v12 = *(void *)(a2 + 8);
        long long v13 = RB::pixel_format_traits(*(void *)(v12 + 56), a2);
        int v16 = (unsigned int *)((char *)v13 + 18);
        if (v8) {
          int v16 = v13 + 6;
        }
        if (*v16)
        {
          RB::Device::alloc_shared_texture_view(**(void **)v7, v12, (RB *)*v16, v8, (MTLPixelFormat *)&v30);
          uint64_t v18 = v30;
          if (v30)
          {
            if ((a4 & 1) == 0)
            {
              int v19 = RB::RenderParams::srgb_alpha(*(RB::RenderParams **)a2, v17);
              if (v19 != ((*((unsigned __int16 *)RB::pixel_format_traits(*(void *)(v18 + 56), v20) + 2) >> 4) & 1))
              {
                RB::RenderPass::resolve_srgb_alpha((RB::RenderPass *)a2, v21);
                *(unsigned char *)(a1 + 18) = 1;
              }
            }
            uint64_t v22 = RB::RenderPass::RenderPass(a1 + 24, *(void *)a2, (int32x2_t *)v18, 0, 1, 0);
            unsigned int v24 = *(RB::RenderPass **)(a1 + 8);
            *(void *)(a1 + 8) = v22;
            if (v24)
            {
              RB::RenderPass::~RenderPass(v24);
              uint64_t v22 = *(void *)(a1 + 8);
            }
            RB::RenderPass::set_extra_attachments(v22, (MTLPixelFormat)a5, v23);
            uint64_t v25 = *(void *)(a1 + 8);
            uint64_t v26 = *(void *)(a2 + 168);
            *(void *)(v25 + 160) = *(void *)(a2 + 160);
            *(void *)(v25 + 168) = v26;
            RB::RenderPass::set_label(*(id **)(a1 + 8), &cfstr_RbWorkingColor.isa);
            int v27 = *(_DWORD *)(v18 + 8) - 1;
            *(_DWORD *)(v18 + 8) = v27;
            if (!v27) {
              (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
            }
          }
        }
        else
        {
          if (a4)
          {
            int v28 = 0;
          }
          else
          {
            int v28 = RB::RenderParams::srgb_alpha(v7, v14);
            unsigned __int8 v8 = *(unsigned char *)(a1 + 16);
          }
          RB::RenderPass::color_convert(a2, v6, v8, v28, v15);
        }
      }
    }
    else
    {
      *(unsigned char *)(a1 + 16) = v6;
    }
  }
  return a1;
}

{
  return RB::RenderPass::WorkingSpace::WorkingSpace(a1, a2, a3, a4, a5);
}

void sub_2141EEFC8(_Unwind_Exception *exception_object)
{
  size_t v3 = *(RB::RenderPass **)(v1 + 8);
  *(void *)(v1 + 8) = 0;
  if (v3) {
    RB::RenderPass::~RenderPass(v3);
  }
  _Unwind_Resume(exception_object);
}

float RB::RenderPass::WorkingSpace::commit(RB::RenderPass::WorkingSpace *this, double a2)
{
  size_t v3 = (RB::RenderPass *)*((void *)this + 1);
  if (v3)
  {
    if (*((unsigned char *)this + 18))
    {
      RB::RenderPass::resolve_srgb_alpha(*((RB::RenderPass **)this + 1), *(int32x2_t *)&a2);
      size_t v3 = (RB::RenderPass *)*((void *)this + 1);
    }
    int v4 = **(id ***)v3;
    RB::RenderFrame::flush_pass(v4, v3, 1);
  }
  else
  {
    uint64_t v5 = *(void *)this;
    int v6 = *(unsigned __int8 *)(*(void *)this + 124);
    int v7 = *((unsigned __int8 *)this + 16);
    if (v6 != v7)
    {
      if (*((unsigned char *)this + 17)) {
        int v8 = 0;
      }
      else {
        int v8 = *(unsigned char *)(*(void *)v5 + 31) & 1;
      }
      *(float *)&a2 = RB::RenderPass::color_convert(v5, v7, v6, v8, *(int32x2_t *)&a2);
    }
  }
  return *(float *)&a2;
}

__n128 RB::Stroke::ParticleGenerator::moveto(uint64_t a1, uint64_t a2, double a3)
{
  *(double *)(a1 + 48) = a3;
  __n128 result = *(__n128 *)a2;
  long long v4 = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 88) = *(void *)(a2 + 32);
  *(_OWORD *)(a1 + 72) = v4;
  *(__n128 *)(a1 + 56) = result;
  return result;
}

__n128 RB::Stroke::ParticleGenerator::lineto(uint64_t a1, float32x2_t *a2, unsigned int *a3, float32x2_t a4, __n128 a5)
{
  float32x2_t v13 = *(float32x2_t *)(a1 + 48);
  int32x2_t v14 = (int32x2_t)vsub_f32(a4, v13);
  float v15 = sqrtf(vaddv_f32(vmul_f32((float32x2_t)v14, (float32x2_t)v14)));
  if (v15 <= 0.0001)
  {
    *(double *)(a1 + 48) = *(double *)&a4;
    uint64_t v20 = a1 + 56;
  }
  else
  {
    float32x2_t v16 = vrecpe_f32((float32x2_t)LODWORD(v15));
    float32x2_t v17 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v15), v16), v16);
    LODWORD(v18) = vmul_f32(v17, vrecps_f32((float32x2_t)LODWORD(v15), v17)).u32[0];
    int32x2_t v19 = (int32x2_t)vmul_n_f32((float32x2_t)v14, v18);
    if (*(unsigned char *)(a1 + 40))
    {
      *(float *)v14.i32 = -*(float *)&v19.i32[1];
      a5.n128_u64[0] = (unint64_t)vzip1_s32(v14, v19);
    }
    else
    {
      a5.n128_u64[0] = 0x3F80000000000000;
    }
    float32x2_t v54 = (float32x2_t)a5.n128_u64[0];
    uint64_t v20 = a1 + 56;
    *(void *)&long long v5 = *(void *)(a1 + 56);
    LODWORD(v10) = *(_DWORD *)(a1 + 100);
    *(void *)&long long v6 = *(void *)(a1 + 64);
    *(void *)&long long v7 = *(void *)(a1 + 72);
    *(void *)&long long v8 = *(void *)(a1 + 80);
    *(void *)&long long v9 = *(void *)(a1 + 88);
    float32x2_t v21 = vmul_n_f32(vsub_f32(*a2, *(float32x2_t *)&v5), v18);
    float32x2_t v22 = vmul_n_f32(vsub_f32(a2[1], *(float32x2_t *)&v6), v18);
    float32x2_t v23 = vmul_n_f32(vsub_f32(a2[2], *(float32x2_t *)&v7), v18);
    float32x2_t v24 = vmul_n_f32(vsub_f32(a2[3], *(float32x2_t *)&v8), v18);
    float32x2_t v25 = vmul_n_f32(vsub_f32(a2[4], *(float32x2_t *)&v9), v18);
    if (*(float *)&v10 != 0.0)
    {
      float32x2_t v13 = vmla_n_f32(v13, (float32x2_t)v19, *(float *)&v10);
      *(float32x2_t *)&long long v5 = vmla_n_f32(*(float32x2_t *)&v5, v21, *(float *)&v10);
      *(float32x2_t *)&long long v6 = vmla_n_f32(*(float32x2_t *)&v6, v22, *(float *)&v10);
      *(float32x2_t *)&long long v7 = vmla_n_f32(*(float32x2_t *)&v7, v23, *(float *)&v10);
      *(float32x2_t *)&long long v8 = vmla_n_f32(*(float32x2_t *)&v8, v24, *(float *)&v10);
      *(float32x2_t *)&long long v9 = vmla_n_f32(*(float32x2_t *)&v9, v25, *(float *)&v10);
    }
    if (*(float *)&v10 < v15)
    {
      *((void *)&v26 + 1) = a5.n128_u64[1];
      *(int32x2_t *)&long long v26 = vdup_lane_s32((int32x2_t)a5.n128_u64[0], 0);
      float32x2_t v47 = (float32x2_t)v26;
      float32x2_t v48 = v23;
      float v27 = fmaxf((float)(v15 - *(float *)&v10) * 0.00097656, 1.0);
      float v28 = 0.5 * v21.f32[0];
      int32x2_t v50 = v19;
      float v51 = v15;
      float32x2_t v49 = v21;
      do
      {
        if (*(float *)&v5 >= v27) {
          *(float *)&long long v26 = *(float *)&v5;
        }
        else {
          *(float *)&long long v26 = v27;
        }
        uint32x2_t v29 = (uint32x2_t)vcgt_f32(v13, *(float32x2_t *)(a1 + 32));
        if ((vpmax_u32(v29, v29).u32[0] & 0x80000000) == 0)
        {
          uint32x2_t v30 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(a1 + 24), v13);
          if ((vpmax_u32(v30, v30).u32[0] & 0x80000000) == 0)
          {
            long long v56 = v26;
            long long v57 = v10;
            long long v60 = v5;
            unsigned int v63 = *(_DWORD *)(a1 + 96);
            long long v61 = v6;
            long long v59 = v8;
            long long v62 = v9;
            long long v58 = v7;
            if (*((float *)&v7 + 1) == 0.0)
            {
              float v31 = *(float *)&v7;
            }
            else
            {
              *(void *)&long long v6 = v61;
              *(void *)&long long v9 = v62;
              *(void *)&long long v8 = v59;
            }
            float32x2_t v32 = v54;
            if (fabsf(v31) > 0.005)
            {
              __float2 v33 = __sincosf_stret(v31);
              *(void *)&long long v6 = v61;
              *(void *)&long long v9 = v62;
              *(void *)&long long v8 = v59;
              v34.f32[0] = -v33.__sinval;
              v34.i32[1] = LODWORD(v33.__cosval);
              float32x2_t v32 = vmla_f32(vmul_lane_f32(v34, v54, 1), v47, (float32x2_t)__PAIR64__(LODWORD(v33.__sinval), LODWORD(v33.__cosval)));
            }
            if (*((float *)&v8 + 1) == 0.0)
            {
              float v55 = *(float *)&v8;
            }
            else
            {
              *(void *)&long long v6 = v61;
              *(void *)&long long v9 = v62;
              float v55 = v35;
            }
            if (*((float *)&v6 + 1) != 0.0)
            {
              *(void *)&long long v9 = v62;
              *(float *)&long long v6 = v36;
            }
            if (*((float *)&v9 + 1) == 0.0)
            {
              float v37 = *(float *)&v9;
            }
            else
            {
              int v52 = v6;
              LODWORD(v6) = v52;
              float v37 = v38;
            }
            int v39 = *(RB::Stroke::_anonymous_namespace_ **)(a1 + 16);
            if (v39 == (RB::Stroke::_anonymous_namespace_ *)1)
            {
              uint64_t v40 = 0;
            }
            else
            {
              int v53 = v6;
              LODWORD(v6) = v53;
              uint64_t v40 = v41;
            }
            (***(void (****)(void, uint64_t, double, double, float, float))(a1 + 8))(*(void *)(a1 + 8), v40, COERCE_DOUBLE(vmla_n_f32(v13, v32, v55)), COERCE_DOUBLE(vmul_n_f32(v32, *(float *)&v6)), v37, *((float *)&v60 + 1));
            long long v8 = v59;
            long long v5 = v60;
            int32x2_t v19 = v50;
            float v15 = v51;
            long long v6 = v61;
            long long v9 = v62;
            long long v10 = v57;
            long long v7 = v58;
            float32x2_t v21 = v49;
            float32x2_t v23 = v48;
            long long v26 = v56;
          }
        }
        float v42 = *(float *)&v26 + v28;
        float v43 = *(float *)&v10 + (float)(*(float *)&v26 + v28);
        if (v43 == *(float *)&v10) {
          break;
        }
        float32x2_t v13 = vmla_n_f32(v13, (float32x2_t)v19, v42);
        LODWORD(v5) = v26;
        *(float32x2_t *)&long long v5 = vmla_n_f32(*(float32x2_t *)&v5, v21, v42);
        *(float32x2_t *)&long long v6 = vmla_n_f32(*(float32x2_t *)&v6, v22, v42);
        *(float32x2_t *)&long long v7 = vmla_n_f32(*(float32x2_t *)&v7, v23, v42);
        *(float32x2_t *)&long long v8 = vmla_n_f32(*(float32x2_t *)&v8, v24, v42);
        *(float32x2_t *)&long long v9 = vmla_n_f32(*(float32x2_t *)&v9, v25, v42);
        *(_DWORD *)(a1 + 96) = 1664525 * *(_DWORD *)(a1 + 96) + 1013904223;
        *(float *)&long long v10 = *(float *)&v10 + (float)(*(float *)&v26 + v28);
      }
      while (v43 < v15);
    }
    *(float *)(a1 + 100) = *(float *)&v10 - v15;
    *(double *)(a1 + 48) = *(double *)&a4;
  }
  __n128 result = *(__n128 *)a2->f32;
  long long v45 = *(_OWORD *)a2[2].f32;
  *(float32x2_t *)(v20 + 32) = a2[4];
  *(__n128 *)uint64_t v20 = result;
  *(_OWORD *)(v20 + 16) = v45;
  return result;
}

void RB::Stroke::ParticleGenerator::skipto()
{
}

float RB::Stroke::anonymous namespace'::sample_slow(unsigned int *a1, double _D0)
{
  unsigned int v2 = 73189 * *a1 + 101513;
  *a1 = v2;
  _S1 = (float)((float)HIWORD(v2) * 0.000015259) + -0.5;
  __asm { FMLA            S0, S1, V0.S[1] }
  return result;
}

uint64_t RB::Stroke::anonymous namespace'::sample_index_slow(RB::Stroke::_anonymous_namespace_ *this, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3 = 73189 * *a2 + 101513;
  float v4 = (float)((float)(unint64_t)this * 0.000015259) * (float)HIWORD(v3);
  *a2 = v3;
  if ((unint64_t)this - 1 >= (int)v4) {
    return (int)v4;
  }
  else {
    return (uint64_t)this - 1;
  }
}

uint64_t RB::ColorMatrix::operator==(float16x4_t *a1, float16x4_t *a2)
{
  uint16x4_t v2 = (uint16x4_t)vand_s8(vand_s8(vand_s8((int8x8_t)vceq_f16(a1[1], a2[1]), (int8x8_t)vceq_f16(*a1, *a2)), vand_s8((int8x8_t)vceq_f16(a1[2], a2[2]), (int8x8_t)vceq_f16(a1[3], a2[3]))), (int8x8_t)vceq_f16(a1[4], a2[4]));
  v2.i16[0] = vminv_u16(v2);
  return ((unsigned __int32)v2.i32[0] >> 15) & 1;
}

uint64_t RB::ColorMatrix::is_identity(float16x4_t *this)
{
  if ((vminv_u16((uint16x4_t)vceq_f16(*this, (float16x4_t)15360)) & 0x8000) == 0
    || (vminv_u16((uint16x4_t)vceq_f16(this[1], (float16x4_t)1006632960)) & 0x8000) == 0
    || (vminv_u16((uint16x4_t)vceq_f16(this[2], (float16x4_t)0x3C0000000000)) & 0x8000) == 0
    || (vminv_u16((uint16x4_t)vceq_f16(this[3], (float16x4_t)0x3C00000000000000)) & 0x8000) == 0)
  {
    return 0;
  }
  uint16x4_t v2 = (uint16x4_t)vceqz_f16(this[4]);
  v2.i16[0] = vminv_u16(v2);
  return ((unsigned __int32)v2.i32[0] >> 15) & 1;
}

BOOL RB::ColorMatrix::has_alpha(float16x4_t *this)
{
  if ((vmaxv_u16((uint16x4_t)vmvn_s8((int8x8_t)vceq_f16(this[3], (float16x4_t)0x3C00000000000000))) & 0x8000) != 0) {
    return 1;
  }
  __asm { FCMP            H0, #0 }
  if (!_ZF) {
    return 1;
  }
  __asm { FCMP            H0, #0 }
  if (!_ZF) {
    return 1;
  }
  __asm { FCMP            H0, #0 }
  if (!_ZF) {
    return 1;
  }
  __asm { FCMP            H0, #0 }
  return !_ZF;
}

BOOL RB::ColorMatrix::is_alpha_identity(RB::ColorMatrix *this)
{
  __asm { FCMP            H0, #0 }
  if (!_ZF) {
    return 0;
  }
  __asm { FCMP            H0, #0 }
  if (!_ZF) {
    return 0;
  }
  __asm { FCMP            H0, #0 }
  if (!_ZF || *((short float *)this + 15) != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
    return 0;
  }
  __asm { FCMP            H0, #0 }
  return _ZF != 0;
}

BOOL RB::ColorMatrix::is_alpha_zero(RB::ColorMatrix *this)
{
  __asm { FCMP            H0, #0 }
  if (!_ZF) {
    return 0;
  }
  __asm { FCMP            H0, #0 }
  if (!_ZF) {
    return 0;
  }
  __asm { FCMP            H0, #0 }
  if (!_ZF) {
    return 0;
  }
  __asm { FCMP            H0, #0 }
  if (!_ZF) {
    return 0;
  }
  __asm { FCMP            H0, #0 }
  return _ZF != 0;
}

uint64_t RB::ColorMatrix::is_diagonal(float16x4_t *this)
{
  uint64_t result = 0;
  __asm { FCMP            H0, #0 }
  if (_ZF)
  {
    __asm { FCMP            H0, #0 }
    if (_ZF)
    {
      __asm { FCMP            H0, #0 }
      if (_ZF)
      {
        uint64_t result = 0;
        __asm { FCMP            H0, #0 }
        if (_ZF)
        {
          __asm { FCMP            H0, #0 }
          if (_ZF)
          {
            __asm { FCMP            H0, #0 }
            if (_ZF)
            {
              uint64_t result = 0;
              __asm { FCMP            H0, #0 }
              if (_ZF)
              {
                __asm { FCMP            H0, #0 }
                if (_ZF)
                {
                  __asm { FCMP            H0, #0 }
                  if (_ZF)
                  {
                    uint64_t result = 0;
                    __asm { FCMP            H0, #0 }
                    if (_ZF)
                    {
                      __asm { FCMP            H0, #0 }
                      if (_ZF)
                      {
                        __asm { FCMP            H0, #0 }
                        if (_ZF)
                        {
                          uint16x4_t v19 = (uint16x4_t)vceqz_f16(this[4]);
                          v19.i16[0] = vminv_u16(v19);
                          return ((unsigned __int32)v19.i32[0] >> 15) & 1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

BOOL RB::ColorMatrix::is_alpha_multiply(float16x4_t *this, char a2)
{
  if ((vminv_u16((uint16x4_t)vceqz_f16(*this)) & 0x8000) == 0
    || (vminv_u16((uint16x4_t)vceqz_f16(this[1])) & 0x8000) == 0
    || (vminv_u16((uint16x4_t)vceqz_f16(this[2])) & 0x8000) == 0)
  {
    return 0;
  }
  if (a2)
  {
    uint16x4_t v4 = (uint16x4_t)vceqz_f16(this[4]);
    v4.i16[0] = vminv_u16(v4);
    return ((unsigned __int32)v4.i32[0] >> 15) & 1;
  }
  else
  {
    uint64_t v2 = 0;
    __asm { FCMP            H0, #0 }
    if (_ZF)
    {
      __asm { FCMP            H0, #0 }
      if (_ZF)
      {
        __asm { FCMP            H0, #0 }
        if (_ZF)
        {
          __asm { FCMP            H0, #0 }
          return _ZF != 0;
        }
      }
    }
  }
  return v2;
}

BOOL RB::ColorMatrix::is_alpha_color_dependent(RB::ColorMatrix *this)
{
  __asm { FCMP            H0, #0 }
  if (!_ZF) {
    return 1;
  }
  __asm { FCMP            H0, #0 }
  if (!_ZF) {
    return 1;
  }
  __asm { FCMP            H0, #0 }
  return !_ZF;
}

double RB::ColorMatrix::set_identity(RB::ColorMatrix *this)
{
  *(void *)this = 15360;
  *((void *)this + 1) = 1006632960;
  *((void *)this + 2) = 0x3C0000000000;
  *((void *)this + 3) = 0x3C00000000000000;
  double result = 0.0;
  *((void *)this + 4) = 0;
  return result;
}

float16x4_t RB::ColorMatrix::set_color_matrix(float16x4_t *this, float32_t *a2)
{
  v2.f32[0] = *a2;
  v2.f32[1] = a2[5];
  v2.f32[2] = a2[10];
  v2.f32[3] = a2[15];
  *this = vcvt_f16_f32(v2);
  v2.f32[0] = a2[1];
  v2.f32[1] = a2[6];
  v2.f32[2] = a2[11];
  v2.f32[3] = a2[16];
  this[1] = vcvt_f16_f32(v2);
  v2.f32[0] = a2[2];
  v2.f32[1] = a2[7];
  v2.f32[2] = a2[12];
  v2.f32[3] = a2[17];
  this[2] = vcvt_f16_f32(v2);
  v2.f32[0] = a2[3];
  v2.f32[1] = a2[8];
  v2.f32[2] = a2[13];
  v2.f32[3] = a2[18];
  this[3] = vcvt_f16_f32(v2);
  v2.f32[0] = a2[4];
  v2.f32[1] = a2[9];
  v2.f32[2] = a2[14];
  v2.f32[3] = a2[19];
  float16x4_t result = vcvt_f16_f32(v2);
  this[4] = result;
  return result;
}

double RB::ColorMatrix::set_color(void *a1, double a2)
{
  LOWORD(v2) = 0;
  HIWORD(v2) = WORD1(a2);
  *a1 = LOWORD(a2);
  a1[1] = v2;
  uint64_t v3 = 0;
  WORD2(v3) = WORD2(a2);
  uint64_t v4 = 0;
  HIWORD(v4) = HIWORD(a2);
  double result = 0.0;
  a1[2] = v3;
  a1[3] = v4;
  a1[4] = 0;
  return result;
}

int8x8_t RB::ColorMatrix::set_alpha_multiply(int8x8_t *a1, int a2, int8x8_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2) {
    unsigned int v3 = -1;
  }
  else {
    unsigned int v3 = 0;
  }
  int8x8_t v4 = (int8x8_t)vdup_n_s16(v3);
  int8x8_t v5 = vand_s8(a3, v4);
  v5.i16[3] = a3.i16[3];
  a3.i16[3] = 0;
  int8x8_t result = vbic_s8(a3, v4);
  a1[3] = v5;
  a1[4] = result;
  return result;
}

uint64_t RB::ColorMatrix::set_inverse_alpha_multiply(uint64_t result, char a2, float16x4_t a3)
{
  *(void *)int8x8_t result = 0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  if (a2)
  {
    LODWORD(v3) = vmul_n_f16(a3, -*(short float *)&a3.i16[3]).u32[0];
    WORD2(v3) = vmulh_lane_f16(-*(short float *)&a3.i16[3], a3, 2);
    *((short float *)&v3 + 3) = -*(short float *)&a3.i16[3];
    LODWORD(v4) = vmul_lane_f16(a3, a3, 3).u32[0];
    WORD2(v4) = vmulh_lane_f16(*(short float *)&a3.i16[2], a3, 3);
    HIWORD(v4) = a3.i16[3];
    *(double *)&a3 = v4;
  }
  else
  {
    uint64_t v3 = 0;
    HIWORD(v3) = vneg_f16(a3).i16[3];
  }
  *(void *)(result + 24) = v3;
  *(double *)(result + 32) = *(double *)&a3;
  return result;
}

__n64 RB::ColorMatrix::alpha_multiply_color(RB::ColorMatrix *this, char a2)
{
  if (a2)
  {
    return *(__n64 *)((char *)this + 24);
  }
  else
  {
    result.n64_u64[0] = *(void *)((unint64_t)this + 32);
    result.n64_u16[3] = HIWORD(*((void *)this + 3));
  }
  return result;
}

__int16 RB::ColorMatrix::set_hue_rotate@<H0>(float32x2_t *this@<X0>, float a2@<S0>)
{
  this[3] = (float32x2_t)0x3C00000000000000;
  this[4] = 0;
  __float2 v3 = __sincosf_stret(a2);
  _S2 = (float)((float)(v3.__cosval * 0.7873) + 0.2126) + (float)(v3.__sinval * -0.2126);
  __asm { FCVT            H2, S2 }
  v9.f32[0] = 0.0722 - (float)(v3.__cosval * 0.0722);
  float v10 = (float)(v3.__cosval * -0.2126) + 0.2126;
  v11.i32[0] = 1060575065;
  _D6 = vmul_n_f32((float32x2_t)0x3E91D14E3F371759, v3.__cosval);
  float32x2_t v13 = vsub_f32(v11, _D6);
  float32x2_t v14 = vmul_n_f32((float32x2_t)0x3E0F5C293F371759, v3.__sinval);
  v15.i32[0] = vsub_f32(v13, v14).u32[0];
  v13.i32[1] = vadd_f32(_D6, (float32x2_t)vdup_n_s32(0x3F371759u)).i32[1];
  _D6.f32[0] = v10 + (float)(v3.__sinval * 0.143);
  _D16 = vadd_f32(v13, v14);
  v15.i32[1] = _D16.i32[1];
  v13.i32[0] = vcvt_f16_f32(v15).u32[0];
  __asm { FCVT            H16, S16 }
  v13.i32[1] = _D16.u16[0];
  float32x2_t v17 = vmul_n_f32((float32x2_t)0x3E90E5603F6D844DLL, v3.__sinval);
  *(int32x2_t *)v15.f32 = vdup_lane_s32(*(int32x2_t *)v9.f32, 0);
  v9.i32[0] = vadd_f32(*(float32x2_t *)v9.f32, v17).u32[0];
  v9.i32[1] = vsub_f32(*(float32x2_t *)&v15, v17).i32[1];
  v9.i32[0] = vcvt_f16_f32(v9).u32[0];
  _S1 = (float)((float)(v3.__cosval * 0.9278) + 0.0722) + (float)(v3.__sinval * 0.0722);
  __asm { FCVT            H1, S1 }
  v9.i32[1] = LOWORD(_S1);
  __asm { FCVT            H1, S6 }
  _S0 = v10 - (float)(v3.__sinval * 0.7873);
  v20.i16[3] = 0;
  v20.i16[0] = LOWORD(_S2);
  v20.i16[1] = LOWORD(_S1);
  __asm { FCVT            H0, S0 }
  v20.i16[2] = result;
  *this = v20;
  this[1] = v13;
  this[2] = *(float32x2_t *)v9.f32;
  return result;
}

__int16 RB::ColorMatrix::set_saturate@<H0>(float32x2_t *this@<X0>, float a2@<S0>, double a3@<D1>, double a4@<D2>, double a5@<D3>, double a6@<D4>, float32x4_t a7@<Q5>, float32x4_t a8@<Q6>)
{
  v8.i16[3] = 0;
  this[4] = 0;
  if (a2 < 0.0) {
    a2 = 0.0;
  }
  float32x2_t v9 = vmul_n_f32((float32x2_t)0x3E59B3D03F498C7ELL, a2);
  a7.i32[0] = 1046066128;
  *(int32x2_t *)a8.f32 = vdup_n_s32(0x3E59B3D0u);
  a7.i32[0] = vadd_f32(v9, *(float32x2_t *)a7.f32).u32[0];
  a7.i32[1] = vsub_f32(*(float32x2_t *)&a8, v9).i32[1];
  float32x2_t v10 = vmul_n_f32((float32x2_t)0x3E91D14E3F371759, a2);
  a8.i32[0] = 1060575065;
  a8.i32[0] = vsub_f32(*(float32x2_t *)a8.f32, v10).u32[0];
  _S7 = 0.0722 - (float)(a2 * 0.0722);
  v12.i32[0] = vcvt_f16_f32(a7).u32[0];
  __asm { FCVT            H7, S7 }
  v12.i32[1] = v12.u16[1];
  a8.i32[1] = vadd_f32(v10, (float32x2_t)vdup_n_s32(0x3F371759u)).i32[1];
  v10.i32[0] = vcvt_f16_f32(a8).u32[0];
  v10.i32[1] = v10.u16[0];
  *this = v12;
  this[1] = v10;
  _S0 = (float)(a2 * 0.9278) + 0.0722;
  __asm { FCVT            H0, S0 }
  v8.i16[0] = LOWORD(_S7);
  v8.i16[1] = LOWORD(_S7);
  v8.i16[2] = result;
  this[2] = v8;
  this[3] = (float32x2_t)0x3C00000000000000;
  return result;
}

__n64 RB::ColorMatrix::set_brightness(__n64 *this, int16x4_t _D0)
{
  this->n64_u64[0] = 15360;
  this[1].n64_u64[0] = 1006632960;
  this[2].n64_u64[0] = 0x3C0000000000;
  this[3].n64_u64[0] = 0x3C00000000000000;
  __asm { FCVT            H0, S0 }
  result.n64_u64[0] = (unint64_t)vdup_lane_s16(_D0, 0);
  result.n64_u16[3] = 0;
  this[4].n64_u64[0] = result.n64_u64[0];
  return result;
}

__n64 RB::ColorMatrix::set_contrast(__n64 *this, float _S0)
{
  _S1 = 0.5 - (float)(_S0 * 0.5);
  __asm { FCVT            H0, S0 }
  unint64_t v8 = 0;
  LOWORD(v9) = 0;
  HIWORD(v9) = _H0;
  this->n64_u64[0] = _H0;
  this[1].n64_u64[0] = v9;
  WORD2(v8) = _H0;
  _D0 = (int16x4_t)0x3C00000000000000;
  this[2].n64_u64[0] = v8;
  this[3].n64_u64[0] = 0x3C00000000000000;
  __asm { FCVT            H0, S1 }
  result.n64_u64[0] = (unint64_t)vdup_lane_s16(_D0, 0);
  result.n64_u16[3] = 0;
  this[4].n64_u64[0] = result.n64_u64[0];
  return result;
}

double RB::ColorMatrix::set_luminance_to_alpha(RB::ColorMatrix *this)
{
  double result = 0.0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *(void *)this = 0x32CE000000000000;
  *((void *)this + 1) = 0x39B9000000000000;
  *((void *)this + 2) = 0x2C9F000000000000;
  return result;
}

uint64_t RB::ColorMatrix::is_luminance_to_alpha(float16x4_t *this)
{
  uint16x4_t v1 = (uint16x4_t)vand_s8(vand_s8(vand_s8((int8x8_t)vceq_f16(this[1], (float16x4_t)0x39B9000000000000), (int8x8_t)vceq_f16(*this, (float16x4_t)0x32CE000000000000)), vand_s8((int8x8_t)vceq_f16(this[2], (float16x4_t)0x2C9F000000000000), (int8x8_t)vceqz_f16(this[3]))), (int8x8_t)vceqz_f16(this[4]));
  v1.i16[0] = vminv_u16(v1);
  return ((unsigned __int32)v1.i32[0] >> 15) & 1;
}

__int16 RB::ColorMatrix::set_color_monochrome@<H0>(void *a1@<X0>, double a2@<D0>, int8x8_t _D1@<D1>, float a4@<S2>, double a5@<D3>, float32x4_t _Q4@<Q4>, double a7@<D5>, float32x4_t a8@<Q6>, float32x4_t a9@<Q7>)
{
  __asm { FCVT            S4, H1 }
  _H3 = _D1.i16[3];
  __asm { FCVT            S3, H3 }
  _D1 = vmul_n_f32((float32x2_t)*(_OWORD *)&vcvtq_f32_f16((float16x4_t)vext_s8(_D1, *(int8x8_t *)&a2, 2uLL)), *(float *)&a2);
  *(int32x2_t *)a8.f32 = vdup_lane_s32((int32x2_t)_D1, 0);
  a8.i32[0] = _Q4.i32[0];
  v9.i32[0] = 1060575065;
  *(int32x2_t *)_Q4.f32 = vdup_lane_s32((int32x2_t)v9, 0);
  _Q4.i32[0] = LODWORD(a2);
  *(float32x2_t *)_Q4.f32 = vmul_f32(*(float32x2_t *)a8.f32, *(float32x2_t *)_Q4.f32);
  a9.i32[0] = vmul_f32(*(float32x2_t *)_Q4.f32, v9).u32[0];
  _S17 = vmuls_lane_f32(0.7152, _D1, 1);
  v9.f32[1] = 1.0 - *(float *)&a2;
  _S0 = (float)(1.0 - *(float *)&a2) + (float)(_S3 * *(float *)&a2);
  _S3 = vmlas_n_f32(v9.f32[1], 0.2126, _Q4.f32[0]);
  __asm { FCVT            H3, S3 }
  a9.i32[1] = vadd_f32(*(float32x2_t *)&_Q4, v9).i32[1];
  LODWORD(v20) = vcvt_f16_f32(a9).u32[0];
  *(int32x2_t *)_Q4.f32 = vzip1_s32(*(int32x2_t *)_Q4.f32, (int32x2_t)_D1);
  *(float32x2_t *)a8.f32 = vmul_f32(*(float32x2_t *)_Q4.f32, (float32x2_t)vdup_n_s32(0x3D93DD98u));
  LODWORD(v21) = vcvt_f16_f32(a8).u32[0];
  *(float32x2_t *)_Q4.f32 = vmul_n_f32(*(float32x2_t *)_Q4.f32, a4);
  LODWORD(v22) = vcvt_f16_f32(_Q4).u32[0];
  *(float32x2_t *)a9.f32 = vmul_f32(_D1, (float32x2_t)vdup_n_s32(0x3E59B3D0u));
  __asm { FCVT            H16, S17 }
  _S17 = 1033100696;
  __asm
  {
    FMLA            S18, S17, V1.S[1]
    FCVT            H17, S18
  }
  _D1.f32[0] = vmuls_lane_f32(a4, _D1, 1);
  __asm { FCVT            H1, S1 }
  uint64_t v26 = 0;
  HIWORD(_D18) = 0;
  LOWORD(_D18) = LOWORD(_S3);
  *(_DWORD *)((char *)&_D18 + 2) = vcvt_f16_f32(a9).u32[0];
  HIDWORD(v20) = _H16;
  *a1 = _D18;
  a1[1] = v20;
  HIDWORD(v21) = (unsigned __int16)_S17;
  __asm { FCVT            H0, S0 }
  HIWORD(v26) = result;
  a1[2] = v21;
  a1[3] = v26;
  HIDWORD(v22) = _D1.u16[0];
  a1[4] = v22;
  return result;
}

__n64 RB::ColorMatrix::set_color_invert(__n64 *this, double _D0)
{
  _S1 = (float)(*(float *)&_D0 * -2.0) + 1.0;
  __asm { FCVT            H1, S1 }
  unint64_t v7 = 0;
  LOWORD(v8) = 0;
  HIWORD(v8) = LOWORD(_S1);
  this->n64_u64[0] = LOWORD(_S1);
  this[1].n64_u64[0] = v8;
  WORD2(v7) = LOWORD(_S1);
  this[2].n64_u64[0] = v7;
  this[3].n64_u64[0] = 0x3C00000000000000;
  __asm { FCVT            H0, S0 }
  result.n64_u64[0] = (unint64_t)vdup_lane_s16(*(int16x4_t *)&_D0, 0);
  result.n64_u16[3] = 0;
  this[4].n64_u64[0] = result.n64_u64[0];
  return result;
}

float16x4_t RB::ColorMatrix::multiply_color(float16x4_t *this, float a2, float a3, float a4, float32_t a5, int a6)
{
  float v6 = 1.0;
  if (a6) {
    float v6 = a5;
  }
  v7.f32[0] = v6 * a2;
  v7.f32[1] = v6 * a3;
  v7.f32[2] = v6 * a4;
  v7.f32[3] = a5;
  *(float16x4_t *)v7.f32 = vcvt_f16_f32(v7);
  float16x4_t v8 = vmul_f16(this[1], *(float16x4_t *)v7.f32);
  *this = vmul_f16(*this, *(float16x4_t *)v7.f32);
  this[1] = v8;
  float16x4_t v9 = vmul_f16(this[3], *(float16x4_t *)v7.f32);
  this[2] = vmul_f16(this[2], *(float16x4_t *)v7.f32);
  this[3] = v9;
  float16x4_t result = vmul_f16(this[4], *(float16x4_t *)v7.f32);
  this[4] = result;
  return result;
}

float RB::ColorMatrix::remove_alpha_factor(float16x4_t *this, char a2)
{
  if ((RB::ColorMatrix::is_diagonal(this) & 1) != 0
    || (is_alpha_multiply = RB::ColorMatrix::is_alpha_multiply(this, a2), float result = 1.0, is_alpha_multiply))
  {
    _H0 = this[3].i16[3];
    this[3].i16[3] = COERCE_UNSIGNED_INT(1.0);
    __asm { FCVT            S0, H0 }
  }
  return result;
}

float16x4_t RB::operator*@<D0>(float16x4_t *a1@<X0>, float16x4_t *a2@<X1>, float16x4_t *a3@<X8>)
{
  float16x4_t result = *a1;
  float16x4_t v4 = a1[1];
  float16x4_t v5 = a1[2];
  float16x4_t v6 = a1[3];
  float16x4_t v7 = vmla_lane_f16(vmla_lane_f16(vmla_n_f16(vmul_lane_f16(v4, a2[1], 1), *a1, COERCE_SHORT_FLOAT(*(void *)&a2[1])), v5, a2[1], 2), v6, a2[1], 3);
  float16x4_t v8 = a2[3];
  float16x4_t v9 = vmla_lane_f16(vmla_lane_f16(vmla_n_f16(vmul_lane_f16(v4, a2[2], 1), *a1, COERCE_SHORT_FLOAT(*(void *)&a2[2])), v5, a2[2], 2), v6, a2[2], 3);
  *a3 = vmla_lane_f16(vmla_lane_f16(vmla_n_f16(vmul_lane_f16(v4, *a2, 1), *a1, COERCE_SHORT_FLOAT(*a2)), v5, *a2, 2), v6, *a2, 3);
  a3[1] = v7;
  a3[2] = v9;
  a3[3] = vmla_lane_f16(vmla_lane_f16(vmla_n_f16(vmul_lane_f16(v4, v8, 1), result, *(short float *)v8.i16), v5, v8, 2), v6, v8, 3);
  a3[4] = vmla_lane_f16(vmla_lane_f16(vmla_n_f16(vmla_lane_f16(a1[4], v4, a2[4], 1), result, COERCE_SHORT_FLOAT(*(void *)&a2[4])), v5, a2[4], 2), v6, a2[4], 3);
  return result;
}

float16x4_t RB::operator*=(uint64_t a1, float16x4_t *a2)
{
  float16x4_t v2 = *(float16x4_t *)(a1 + 2);
  float16x4_t result = a2[2];
  float16x4_t v4 = vmla_lane_f16(vmla_lane_f16(vmla_n_f16(vmla_n_f16(a2[4], *a2, COERCE_SHORT_FLOAT(*(void *)a1)), a2[1], *(short float *)v2.i16), result, v2, 1), a2[3], v2, 2);
  *(void *)a1 = ((unint64_t)v4.u16[2] << 32) | ((unint64_t)v4.u16[3] << 48) | ((unint64_t)v4.u16[1] << 16) | v4.u16[0];
  *(_WORD *)(a1 + 8) = v2.i16[3];
  return result;
}

void *RB::ColorMatrix::encode(void *this, RB::ProtobufEncoder *a2)
{
  __float2 v3 = this;
  uint64_t v4 = 0;
  v12[0] = 15360;
  v12[1] = 1006632960;
  float32x2_t v12[2] = 0x3C0000000000;
  void v12[3] = 0x3C00000000000000;
  v12[4] = 0;
  unint64_t v5 = 13;
  do
  {
    _H0 = *(short float *)((char *)v3 + v4);
    if (_H0 != *(short float *)((char *)v12 + v4))
    {
      __asm { FCVT            S8, H0 }
      RB::ProtobufEncoder::encode_varint(a2, v5);
      this = RB::ProtobufEncoder::encode_fixed32(a2, _S8);
    }
    v4 += 2;
    v5 += 8;
  }
  while (v4 != 40);
  return this;
}

unint64_t RB::ColorMatrix::decode(RB::ColorMatrix *this, RB::ProtobufDecoder *a2)
{
  *(void *)this = 15360;
  *((void *)this + 1) = 1006632960;
  *((void *)this + 2) = 0x3C0000000000;
  *((void *)this + 3) = 0x3C00000000000000;
  *((void *)this + 4) = 0;
  unint64_t result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    unint64_t v5 = result;
    do
    {
      unint64_t v6 = v5 >> 3;
      if ((v5 >> 3) - 1 > 0x13)
      {
        RB::ProtobufDecoder::skip_field(a2, v5);
      }
      else
      {
        _S0 = RB::ProtobufDecoder::float_field(a2, v5);
        __asm { FCVT            H0, S0 }
        *((_WORD *)this + (v6 - RBPathRetain(*(void *)this, *((void *)this + 1)) = LOWORD(_S0);
      }
      unint64_t result = RB::ProtobufDecoder::next_field(a2);
      unint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::ColorMatrix::print(float16x4_t *this, std::string *a2)
{
  if (RB::ColorMatrix::is_diagonal(this))
  {
    RB::SexpString::push(a2, "color-multiply");
    _D0 = *this;
    __asm { FCVT            D0, H0 }
    _H1 = this[1].i16[1];
    __asm { FCVT            D1, H1 }
    _H2 = this[2].i16[2];
LABEL_8:
    __asm { FCVT            D2, H2 }
    _H3 = this[3].i16[3];
    __asm { FCVT            D3, H3 }
    RB::SexpString::printf(a2, 0, "[%g %g %g %g]");
    goto LABEL_9;
  }
  if (RB::ColorMatrix::is_alpha_multiply(this, 0))
  {
    float32x2_t v13 = "alpha-multiply";
LABEL_7:
    RB::SexpString::push(a2, v13);
    _H0 = this[4].i16[0];
    __asm { FCVT            D0, H0 }
    _H1 = this[4].i16[1];
    __asm { FCVT            D1, H1 }
    _H2 = this[4].i16[2];
    goto LABEL_8;
  }
  if (RB::ColorMatrix::is_alpha_multiply(this, 1))
  {
    float32x2_t v13 = "alpha-multiply*";
    goto LABEL_7;
  }
  RB::SexpString::push(a2, "color-matrix");
  _D0 = *this;
  _D1 = this[1];
  __asm
  {
    FCVT            D0, H0
    FCVT            D1, H1
  }
  _D2 = this[2];
  _D3 = this[3];
  __asm
  {
    FCVT            D2, H2
    FCVT            D3, H3
  }
  _D4 = this[4];
  __asm { FCVT            D4, H4 }
  RB::SexpString::printf(a2, 1, "(row0 %g %g %g %g; %g)", _D0, _D1, _D2, _D3, _D4);
  _H0 = this->i16[1];
  __asm { FCVT            D0, H0 }
  _H1 = this[1].i16[1];
  __asm { FCVT            D1, H1 }
  _H2 = this[2].i16[1];
  __asm { FCVT            D2, H2 }
  _H3 = this[3].i16[1];
  __asm { FCVT            D3, H3 }
  _H4 = this[4].i16[1];
  __asm { FCVT            D4, H4 }
  RB::SexpString::printf(a2, 1, "(row1 %g %g %g %g; %g)", _D0, _D1, _D2, _D3, _D4);
  _H0 = this->i16[2];
  __asm { FCVT            D0, H0 }
  _H1 = this[1].i16[2];
  __asm { FCVT            D1, H1 }
  _H2 = this[2].i16[2];
  __asm { FCVT            D2, H2 }
  _H3 = this[3].i16[2];
  __asm { FCVT            D3, H3 }
  _H4 = this[4].i16[2];
  __asm { FCVT            D4, H4 }
  RB::SexpString::printf(a2, 1, "(row2 %g %g %g %g; %g)", _D0, _D1, _D2, _D3, _D4);
  _H0 = this->i16[3];
  __asm { FCVT            D0, H0 }
  _H1 = this[1].i16[3];
  __asm { FCVT            D1, H1 }
  _H2 = this[2].i16[3];
  __asm { FCVT            D2, H2 }
  _H3 = this[3].i16[3];
  __asm { FCVT            D3, H3 }
  _H4 = this[4].i16[3];
  __asm { FCVT            D4, H4 }
  RB::SexpString::printf(a2, 1, "(row3 %g %g %g %g; %g)");
LABEL_9:
  RB::SexpString::pop(a2);
}

uint64_t RB::Stroke::flatten_points(void *a1, uint64_t (**a2)(void), char a3, char a4, float64x2_t a5, double a6, float32x2_t a7, float a8, float a9, float a10)
{
  v17[0] = (uint64_t (**)(void))&unk_26C4EDC18;
  v17[1] = a2;
  _OWORD v17[2] = *(uint64_t (***)(void))&a6;
  float64x2_t v17[3] = (uint64_t (**)(void))vadd_f32(a7, *(float32x2_t *)&a6);
  char v18 = a3;
  char v19 = a4;
  float v10 = a8 * a8;
  uint32x2_t v11 = (uint32x2_t)vcge_f32(vabs_f32(a7), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  BOOL v23 = vpmax_u32(v11, v11).i32[0] >= 0;
  int v24 = 0;
  uint64_t v25 = 0x3F80000000000000;
  char v26 = 1;
  int v27 = 0;
  uint64_t v28 = 0x3F80000000000000;
  uint64_t v29 = 0x3F80000000000000;
  float v22 = a9;
  float32x2_t v12 = vrecpe_f32((float32x2_t)LODWORD(a9));
  float32x2_t v13 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(a9), v12), v12);
  LODWORD(v14) = vmul_f32(v13, vrecps_f32((float32x2_t)LODWORD(a9), v13)).u32[0];
  float v15 = 0.75;
  if ((float)(a10 * 0.05) > 1.0) {
    float v15 = a10 * 0.0375;
  }
  float v20 = v10;
  float v21 = v15 * v14;
  return RB::Stroke::stroke_points(a1, v17, a5);
}

uint64_t RB::Stroke::flatten_particles(void *a1, uint64_t (**a2)(void), float64x2_t a3, double a4, float32x2_t a5, float a6, float a7)
{
  void v19[2] = *(uint64_t (***)(void))&a4;
  unsigned __int16 v19[3] = (uint64_t (**)(void))vadd_f32(a5, *(float32x2_t *)&a4);
  uint32x2_t v7 = (uint32x2_t)vcge_f32(vabs_f32(a5), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  signed __int32 v8 = vpmax_u32(v7, v7).u32[0];
  __asm { FMOV            V1.2S, #1.0 }
  uint64_t v26 = _D1;
  uint64_t v27 = 1065353216;
  uint64_t v30 = 1065353216;
  uint64_t v33 = _D1;
  uint64_t v34 = 1065353216;
  uint64_t v37 = 1065353216;
  uint64_t v38 = _D1;
  uint64_t v39 = 1065353216;
  uint64_t v42 = 1065353216;
  float32x2_t v14 = vrecpe_f32((float32x2_t)LODWORD(a6));
  float32x2_t v15 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(a6), v14), v14);
  v19[0] = (uint64_t (**)(void))&unk_26C4EDC58;
  v19[1] = a2;
  __int16 v20 = 256;
  int v21 = 1120403456;
  BOOL v24 = v8 >= 0;
  int v25 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  char v31 = 1;
  int v32 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  LODWORD(v16) = vmul_f32(v15, vrecps_f32((float32x2_t)LODWORD(a6), v15)).u32[0];
  float v17 = a7 * 0.0375;
  if ((float)(a7 * 0.05) <= 1.0) {
    float v17 = 0.75;
  }
  float v22 = v17 * v16;
  float v23 = a6;
  return RB::Stroke::stroke_particles(a1, v19, a3);
}

void RB::Stroke::flatten_points(CGPathRef path, void *a2, float64x2_t *a3, void (**a4)(void), char a5, char a6, uint64_t a7, double a8, float32x2_t a9, float a10, float a11, double a12, float a13)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  if (a7)
  {
    MEMORY[0x270FA5388](path, a2);
    float v30 = v22;
    uint64_t v24 = RB::Stroke::Dasher::Dasher(v23);
    a13 = v30;
    a9 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
    a8 = 7.29112205e-304;
    a4 = (void (**)(void))v24;
  }
  v31[0] = (void (**)(void))&unk_26C4EE940;
  v31[1] = (void (**)(void))&unk_26C4EDC18;
  Point v31[2] = a4;
  float64x2_t v31[3] = *(void (***)(void))&a8;
  _OWORD v31[4] = (void (**)(void))vadd_f32(*(float32x2_t *)&a8, a9);
  char v32 = a5;
  char v33 = a6;
  uint32x2_t v25 = (uint32x2_t)vcge_f32(vabs_f32(a9), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  BOOL v37 = vpmax_u32(v25, v25).i32[0] >= 0;
  int v38 = 0;
  uint64_t v39 = 0x3F80000000000000;
  char v40 = 1;
  int v41 = 0;
  uint64_t v42 = 0x3F80000000000000;
  uint64_t v43 = 0x3F80000000000000;
  float32x2_t v26 = vrecpe_f32((float32x2_t)LODWORD(a13));
  float32x2_t v27 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(a13), v26), v26);
  LODWORD(v28) = vmul_f32(v27, vrecps_f32((float32x2_t)LODWORD(a13), v27)).u32[0];
  float v29 = a10 * 0.0375;
  if ((float)(a10 * 0.05) <= 1.0) {
    float v29 = 0.75;
  }
  float v34 = a11 * a11;
  float v35 = v29 * v28;
  float v36 = a13;
  int v45 = 1065353216;
  float v44 = a10 * 0.5;
  RBPathMap(path, a2, v31, a3);
}

void RB::Stroke::LineBounds::quadto(float32x2_t *a1, float32x2_t a2, float32x2_t a3, float a4, double a5, int32x4_t a6, int32x4_t a7, int32x4_t a8, int32x4_t a9)
{
  *(float32x2_t *)a6.i8 = vadd_f32(a2, a2);
  float32x2_t v11 = (float32x2_t)vdup_n_s32(0x3EAAAAABu);
  float32x2_t v12 = vmul_f32(vadd_f32(a1[3], *(float32x2_t *)a6.i8), v11);
  *(float32x2_t *)a6.i8 = vadd_f32(*(float32x2_t *)a6.i8, a3);
  RB::Stroke::LineBounds::cubeto((uint64_t)a1, v12, vmul_f32(*(float32x2_t *)a6.i8, v11), a3, a4, a6, a7, a8, a9);
}

uint64_t RB::Stroke::flatten_points(RBPath,RB::AffineTransform const&,RB::Stroke::LineConsumer<RB::Stroke::Point> &,RB::Rect,float,RB::LineCap,RB::LineJoin,float,unsigned long,float const*,float,float)::Adaptor::endpath(uint64_t a1)
{
  return RB::Stroke::Flattener<RB::Stroke::Point>::endpath(a1 + 8);
}

uint64_t RB::Stroke::flatten_points(RBPath,RB::AffineTransform const&,RB::Stroke::LineConsumer<RB::Stroke::Point> &,RB::Rect,float,RB::LineCap,RB::LineJoin,float,unsigned long,float const*,float,float)::Adaptor::closepath(uint64_t a1)
{
  return RB::Stroke::Flattener<RB::Stroke::Point>::closepath(a1 + 8);
}

uint64_t RB::Stroke::flatten_points(RBPath,RB::AffineTransform const&,RB::Stroke::LineConsumer<RB::Stroke::Point> &,RB::Rect,float,RB::LineCap,RB::LineJoin,float,unsigned long,float const*,float,float)::Adaptor::moveto(uint64_t a1, float64x2_t a2)
{
  return RB::Stroke::Flattener<RB::Stroke::Point>::moveto(a1 + 8, (uint64_t *)(a1 + 136), COERCE_DOUBLE(vcvt_f32_f64(a2)));
}

uint64_t RB::Stroke::flatten_points(RBPath,RB::AffineTransform const&,RB::Stroke::LineConsumer<RB::Stroke::Point> &,RB::Rect,float,RB::LineCap,RB::LineJoin,float,unsigned long,float const*,float,float)::Adaptor::lineto(uint64_t a1, float64x2_t a2)
{
  return RB::Stroke::Flattener<RB::Stroke::Point>::lineto(a1 + 8, (void *)(a1 + 136), COERCE_DOUBLE(vcvt_f32_f64(a2)));
}

double RB::Stroke::flatten_points(RBPath,RB::AffineTransform const&,RB::Stroke::LineConsumer<RB::Stroke::Point> &,RB::Rect,float,RB::LineCap,RB::LineJoin,float,unsigned long,float const*,float,float)::Adaptor::quadto(float32x2_t *a1, float64x2_t a2, float64x2_t a3)
{
  float32x2_t v3 = vcvt_f32_f64(a2);
  float32x2_t v4 = vcvt_f32_f64(a3);
  float32x2_t v5 = vadd_f32(v3, v3);
  float32x2_t v6 = (float32x2_t)vdup_n_s32(0x3EAAAAABu);
  RB::Stroke::Flattener<RB::Stroke::Point>::cubeto((uint64_t)&a1[1], a1 + 17, vmul_f32(vadd_f32(a1[15], v5), v6), vmul_f32(vadd_f32(v5, v4), v6), *(double *)&v4);
  return result;
}

void RB::Stroke::flatten_points(RBPath,RB::AffineTransform const&,RB::Stroke::LineConsumer<RB::Stroke::Point> &,RB::Rect,float,RB::LineCap,RB::LineJoin,float,unsigned long,float const*,float,float)::Adaptor::cubeto(float32x2_t *a1, float64x2_t a2, float64x2_t a3, float64x2_t a4)
{
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Point>::endpath(uint64_t a1)
{
  uint64_t result = RB::Stroke::Flattener<RB::Stroke::Point>::flush_lineto(a1, 1);
  if (*(unsigned char *)(a1 + 72))
  {
    if (*(_DWORD *)(a1 + 76) == 1)
    {
      uint64_t result = (*(uint64_t (**)(void, uint64_t, double))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), 1, *(double *)(a1 + 80));
      *(unsigned char *)(a1 + 72) = 0;
    }
  }
  return result;
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Point>::flush_lineto(uint64_t result, int a2)
{
  uint64_t v2 = result;
  if (!a2)
  {
    if (!*(unsigned char *)(result + 49)) {
      return result;
    }
    uint64_t v3 = *(unsigned __int8 *)(result + 53);
    goto LABEL_7;
  }
  uint64_t result = RB::Stroke::Flattener<RB::Stroke::Point>::flush_empty_line(result);
  if ((result & 1) == 0 && *(unsigned char *)(v2 + 49))
  {
    uint64_t v3 = 1;
LABEL_7:
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, double))(**(void **)(v2 + 8) + 16))(*(void *)(v2 + 8), v2 + 64, v3, *(double *)(v2 + 56));
    *(unsigned char *)(v2 + 49) = 0;
    *(unsigned char *)(v2 + 52) = 1;
  }
  return result;
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Point>::flush_empty_line(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 50) || !*(unsigned char *)(a1 + 51)) {
    return 0;
  }
  (*(void (**)(void, void, double))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), 0, COERCE_DOUBLE(1065353216));
  uint64_t v2 = 1;
  (*(void (**)(void, uint64_t, uint64_t, double))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), a1 + 104, 1, *(double *)(a1 + 88));
  (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), 1, COERCE_DOUBLE(1065353216));
  *(unsigned char *)(a1 + 72) = 0;
  *(_WORD *)(a1 + 51) = 256;
  return v2;
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Point>::closepath(uint64_t a1)
{
  RB::Stroke::Flattener<RB::Stroke::Point>::lineto(a1, (void *)(a1 + 104), *(double *)(a1 + 88));
  RB::Stroke::Flattener<RB::Stroke::Point>::flush_lineto(a1, 0, *(float32x2_t *)(a1 + 96));
  uint64_t v2 = ***(uint64_t (****)(void))(a1 + 8);
  return v2();
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Point>::lineto(uint64_t result, void *a2, double a3)
{
  uint64_t v4 = result;
  float32x2_t v5 = *(float32x2_t *)(result + 112);
  uint32x2_t v6 = (uint32x2_t)vceq_f32(v5, *(float32x2_t *)&a3);
  if ((vpmin_u32(v6, v6).u32[0] & 0x80000000) != 0)
  {
    if (*(unsigned char *)(result + 50) && !*(unsigned char *)(result + 32)) {
      *(unsigned char *)(result + 51) = 1;
    }
  }
  else
  {
    *(double *)(result + 112) = a3;
    *(void *)(result + 120) = *a2;
    *(unsigned char *)(result + 50) = 0;
    float32x2_t v8 = vsub_f32(*(float32x2_t *)&a3, v5);
    uint64_t result = RB::Stroke::Flattener<RB::Stroke::Point>::flush_lineto(result, 0, v8);
    if (*(unsigned char *)(v4 + 48)
      && ((uint32x2_t v10 = (uint32x2_t)vcgt_f32(vminnm_f32(v5, *(float32x2_t *)&a3), *(float32x2_t *)(v4 + 24)),
           (vpmax_u32(v10, v10).u32[0] & 0x80000000) != 0)
       || (uint32x2_t v11 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(v4 + 16), vmaxnm_f32(v5, *(float32x2_t *)&a3)),
           (vpmax_u32(v11, v11).u32[0] & 0x80000000) != 0)))
    {
      *(unsigned char *)(v4 + 72) = 0;
      float32x2_t v13 = *(uint64_t (**)(__n128))(**(void **)(v4 + 8) + 24);
      v9.n128_f64[0] = a3;
      return v13(v9);
    }
    else
    {
      if (*(unsigned char *)(v4 + 72) && !*(_DWORD *)(v4 + 76))
      {
        *(float32x2_t *)(v4 + 96) = v8;
        uint64_t result = (*(uint64_t (**)(void, void, double))(**(void **)(v4 + 8) + 32))(*(void *)(v4 + 8), 0, *(double *)&v8);
        *(unsigned char *)(v4 + 72) = 0;
      }
      char v12 = 1;
      if (*(float *)a2 > *(float *)(v4 + 44)) {
        char v12 = *(unsigned char *)(v4 + 33);
      }
      *(unsigned char *)(v4 + 51) = 0;
      *(unsigned char *)(v4 + 49) = 1;
      *(unsigned char *)(v4 + 53) = v12;
      *(double *)(v4 + 56) = a3;
      *(void *)(v4 + 64) = *a2;
      *(unsigned char *)(v4 + 72) = 1;
      *(_DWORD *)(v4 + 76) = 1;
      *(float32x2_t *)(v4 + 80) = v8;
    }
  }
  return result;
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Point>::flush_lineto(uint64_t result, int a2, float32x2_t a3)
{
  uint64_t v3 = result;
  if (!a2)
  {
    if (!*(unsigned char *)(result + 49)) {
      return result;
    }
    uint64_t v4 = *(unsigned __int8 *)(result + 53);
    if (!*(unsigned char *)(result + 53))
    {
      if (*(unsigned char *)(result + 72) && *(_DWORD *)(result + 76) == 1)
      {
        float32x2_t v5 = *(float32x2_t *)(result + 80);
        int32x2_t v6 = (int32x2_t)vmul_f32(v5, v5);
        v6.i32[0] = vadd_f32((float32x2_t)v6, (float32x2_t)vdup_lane_s32(v6, 1)).u32[0];
        float32x2_t v7 = vrsqrte_f32((float32x2_t)v6.u32[0]);
        float32x2_t v8 = vmul_f32(vrsqrts_f32((float32x2_t)v6.u32[0], vmul_f32(v7, v7)), v7);
        int32x2_t v9 = (int32x2_t)vmul_f32(a3, a3);
        v9.i32[0] = vadd_f32((float32x2_t)v9, (float32x2_t)vdup_lane_s32(v9, 1)).u32[0];
        float32x2_t v10 = vrsqrte_f32((float32x2_t)v9.u32[0]);
        float32x2_t v11 = vmul_f32(vrsqrts_f32((float32x2_t)v9.u32[0], vmul_f32(v10, v10)), v10);
        float v12 = vaddv_f32(vmul_n_f32(vmul_f32(v5, a3), vmul_f32(vmul_f32(vmul_f32(v8, vrsqrts_f32((float32x2_t)v9.u32[0], vmul_f32(v11, v11))), v11), vrsqrts_f32((float32x2_t)v6.u32[0], vmul_f32(v8, v8))).f32[0]));
        if (v12 > 0.99) {
          uint64_t v4 = 1;
        }
        else {
          uint64_t v4 = 2 * ((float)((float)(v12 + 1.0) * *(float *)(result + 36)) < 2.0);
        }
      }
      else
      {
        uint64_t v4 = 0;
      }
    }
    goto LABEL_13;
  }
  uint64_t result = RB::Stroke::Flattener<RB::Stroke::Point>::flush_empty_line(result);
  if ((result & 1) == 0 && *(unsigned char *)(v3 + 49))
  {
    uint64_t v4 = 1;
LABEL_13:
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, double))(**(void **)(v3 + 8) + 16))(*(void *)(v3 + 8), v3 + 64, v4, *(double *)(v3 + 56));
    *(unsigned char *)(v3 + 49) = 0;
    *(unsigned char *)(v3 + 52) = 1;
  }
  return result;
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Point>::moveto(uint64_t a1, uint64_t *a2, double a3)
{
  RB::Stroke::Flattener<RB::Stroke::Point>::flush_lineto(a1, 1);
  if (*(unsigned char *)(a1 + 72) && *(_DWORD *)(a1 + 76) == 1) {
    (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), 1, *(double *)(a1 + 80));
  }
  *(double *)(a1 + 88) = a3;
  uint64_t v7 = *a2;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = v7;
  *(double *)(a1 + 112) = a3;
  *(void *)(a1 + 120) = *a2;
  *(_WORD *)(a1 + 50) = 1;
  *(unsigned char *)(a1 + 52) = 0;
  *(unsigned char *)(a1 + 72) = 1;
  *(_DWORD *)(a1 + 76) = 0;
  float32x2_t v8 = *(uint64_t (**)(__n128))(**(void **)(a1 + 8) + 8);
  v6.n128_f64[0] = a3;
  return v8(v6);
}

void RB::Stroke::Flattener<RB::Stroke::Point>::quadto(float32x2_t *a1, float32x2_t *a2, float32x2_t a3, double a4)
{
  float32x2_t v5 = vadd_f32(a3, a3);
  float32x2_t v6 = (float32x2_t)vdup_n_s32(0x3EAAAAABu);
  RB::Stroke::Flattener<RB::Stroke::Point>::cubeto((uint64_t)a1, a2, vmul_f32(vadd_f32(a1[14], v5), v6), vmul_f32(vadd_f32(v5, *(float32x2_t *)&a4), v6), a4);
}

void RB::Stroke::Flattener<RB::Stroke::Point>::cubeto(uint64_t a1, float32x2_t *a2, float32x2_t a3, float32x2_t a4, double a5)
{
  float32x2_t v10 = *(float32x2_t *)(a1 + 112);
  float32x2_t v11 = *(float32x2_t *)(a1 + 120);
  uint32x2_t v12 = (uint32x2_t)vceq_f32(v10, a3);
  if ((vpmin_u32(v12, v12).u32[0] & 0x80000000) != 0
    && (uint32x2_t v13 = (uint32x2_t)vceq_f32(a3, a4), (vpmin_u32(v13, v13).u32[0] & 0x80000000) != 0)
    && (uint32x2_t v14 = (uint32x2_t)vceq_f32(a4, *(float32x2_t *)&a5), (vpmin_u32(v14, v14).u32[0] & 0x80000000) != 0))
  {
    RB::Stroke::Flattener<RB::Stroke::Point>::lineto(a1, a2, a5);
  }
  else
  {
    double v15 = COERCE_DOUBLE(vsub_f32(a3, v10));
    if (vaddv_f32(vmul_f32(*(float32x2_t *)&v15, *(float32x2_t *)&v15)) < 0.00001)
    {
      double v16 = COERCE_DOUBLE(vsub_f32(a4, v10));
      double v17 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&a5, v10));
      if (vaddv_f32(vmul_f32(*(float32x2_t *)&v16, *(float32x2_t *)&v16)) < 0.00001) {
        double v15 = v17;
      }
      else {
        double v15 = v16;
      }
    }
    double v18 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&a5, a4));
    if (vaddv_f32(vmul_f32(*(float32x2_t *)&v18, *(float32x2_t *)&v18)) < 0.00001)
    {
      double v19 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&a5, a3));
      double v20 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&a5, v10));
      if (vaddv_f32(vmul_f32(*(float32x2_t *)&v19, *(float32x2_t *)&v19)) < 0.00001) {
        double v18 = v20;
      }
      else {
        double v18 = v19;
      }
    }
    *(double *)(a1 + 112) = a5;
    *(float32x2_t *)(a1 + 120) = *a2;
    *(unsigned char *)(a1 + 50) = 0;
    RB::Stroke::Flattener<RB::Stroke::Point>::flush_lineto(a1, 0, *(float32x2_t *)&v15);
    int v26 = *(unsigned __int8 *)(a1 + 48);
    if (*(unsigned char *)(a1 + 48))
    {
      v21.n128_u64[0] = (unint64_t)vminnm_f32(v10, *(float32x2_t *)&a5);
      float32x2_t v27 = vmaxnm_f32(v10, *(float32x2_t *)&a5);
      float32x2_t v28 = vminnm_f32(a3, a4);
      float32x2_t v29 = vmaxnm_f32(a3, a4);
      float32x2_t v31 = *(float32x2_t *)(a1 + 16);
      float32x2_t v30 = *(float32x2_t *)(a1 + 24);
      *(int32x2_t *)v25.i8 = vcgt_f32(v31, vmaxnm_f32(v27, v29));
      uint32x2_t v32 = (uint32x2_t)vorr_s8(*(int8x8_t *)v25.i8, (int8x8_t)vcgt_f32(vminnm_f32((float32x2_t)v21.n128_u64[0], v28), v30));
      *(uint32x2_t *)v24.i8 = vpmax_u32(v32, v32);
      if (v24.i32[0] < 0) {
        goto LABEL_23;
      }
      *(int32x2_t *)v23.i8 = vcge_f32(v27, v29);
      uint32x2_t v33 = (uint32x2_t)vand_s8(*(int8x8_t *)v23.i8, (int8x8_t)vcge_f32(v28, (float32x2_t)v21.n128_u64[0]));
      *(uint32x2_t *)v22.i8 = vpmin_u32(v33, v33);
      if ((v22.i32[0] & 0x80000000) == 0)
      {
        v21.n128_f64[0] = RB::Path::cubic_bounds_slow(v10, a3, a4, *(float32x2_t *)&a5, v22, v23, v24, v25);
        float32x2_t v31 = *(float32x2_t *)(a1 + 16);
        float32x2_t v30 = *(float32x2_t *)(a1 + 24);
      }
      uint32x2_t v34 = (uint32x2_t)vorr_s8((int8x8_t)vcgt_f32(v31, v27), (int8x8_t)vcgt_f32((float32x2_t)v21.n128_u64[0], v30));
      if ((vpmax_u32(v34, v34).u32[0] & 0x80000000) != 0)
      {
LABEL_23:
        *(unsigned char *)(a1 + 72) = 0;
        char v40 = *(void (**)(__n128))(**(void **)(a1 + 8) + 24);
        v21.n128_f64[0] = a5;
        v40(v21);
        return;
      }
      uint32x2_t v35 = (uint32x2_t)vcge_f32((float32x2_t)v21.n128_u64[0], v31);
      int v36 = vpmin_u32(v35, v35).u32[0];
      uint32x2_t v37 = (uint32x2_t)vcge_f32(v30, v27);
      if (vpmin_u32(v37, v37).i32[0] >= 0) {
        int v38 = v26;
      }
      else {
        int v38 = 0;
      }
      if (v36 < 0) {
        int v39 = v38;
      }
      else {
        int v39 = 1;
      }
    }
    else
    {
      int v39 = 0;
    }
    float32x2_t v41 = vmaxnm_f32(vabs_f32(vadd_f32(vsub_f32(a4, vadd_f32(a3, a3)), v10)), vabs_f32(vadd_f32(vsub_f32(a3, vadd_f32(a4, a4)), *(float32x2_t *)&a5)));
    float v42 = ceilf(sqrtf(sqrtf(vaddv_f32(vmul_f32(v41, v41))) * *(float *)(a1 + 40)));
    if (v42 >= 0.0 && ((LODWORD(v42) & 0x7FFFFFFFu) - 0x800000) >> 24 <= 0x7E || LODWORD(v42) == 0)
    {
      if (v42 >= 1.0)
      {
        if (v42 > 1024.0) {
          float v42 = 1024.0;
        }
        uint64_t v46 = (int)v42;
      }
      else
      {
        uint32x2_t v45 = (uint32x2_t)vceq_f32(v10, *(float32x2_t *)&a5);
        if ((vpmin_u32(v45, v45).u32[0] & 0x80000000) != 0) {
          return;
        }
        uint64_t v46 = 1;
      }
      uint64_t v64 = 0x3F80000000000000;
      char v65 = 0;
      uint64_t v59 = a1;
      long long v60 = &v63;
      char v61 = v39;
      double v62 = v15;
      if ((int)v46 >= 2)
      {
        _ZN2RB13CubicIteratorIDv2_fEC1ES1_S1_S1_S1_i(&v55, v46);
        float32x2_t v47 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)v46));
        float32x2_t v48 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)v46), v47), v47);
        float32x2_t v49 = vmul_n_f32(vsub_f32(*a2, v11), vmul_f32(v48, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)v46), v48)).f32[0]);
        int v50 = v46 - 1;
        float v51 = &v63;
        do
        {
          float32x2_t v52 = v55;
          float32x2_t v10 = vadd_f32(v56, v55);
          float32x2_t v55 = v10;
          float32x2_t v56 = vadd_f32(v57, v56);
          float32x2_t v57 = vadd_f32(v58, v57);
          float32x2_t v11 = vadd_f32(v11, v49);
          if (v39
            && ((uint32x2_t v53 = (uint32x2_t)vcgt_f32(vminnm_f32(v52, v10), *(float32x2_t *)(a1 + 24)),
                 (vpmax_u32(v53, v53).u32[0] & 0x80000000) != 0)
             || (uint32x2_t v54 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(a1 + 16), vmaxnm_f32(v52, v10)),
                 (vpmax_u32(v54, v54).u32[0] & 0x80000000) != 0)))
          {
            *((unsigned char *)v51 + 16) = 1;
            *float v51 = *(double *)&v10;
            float v51 = v60;
            v60[1] = *(double *)&v11;
            *(unsigned char *)(a1 + 72) = 0;
          }
          else
          {
            if (*(unsigned char *)(a1 + 49)) {
              RB::Stroke::Flattener<RB::Stroke::Point>::flush_lineto(a1, 0);
            }
            if (*((unsigned char *)v51 + 16))
            {
              *(unsigned char *)(a1 + 72) = 0;
              (*(void (**)(void, double *, double))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), v51 + 1, *v51);
              float v51 = v60;
              *((unsigned char *)v60 + 16) = 0;
            }
            if (*(unsigned char *)(a1 + 72) && !*(_DWORD *)(a1 + 76))
            {
              *(double *)(a1 + 96) = v62;
              (*(void (**)(void, void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), 0);
              *(unsigned char *)(a1 + 72) = 0;
            }
            *(unsigned char *)(a1 + 51) = 0;
            *(unsigned char *)(a1 + 49) = 1;
            *(unsigned char *)(a1 + 53) = 1;
            *(float32x2_t *)(a1 + 56) = v10;
            *(float32x2_t *)(a1 + 64) = v11;
          }
          --v50;
        }
        while (v50);
      }
      _ZZN2RB6Stroke9FlattenerINS0_5PointEE6cubetoEDv2_fS4_S4_RKS2_ENKUlS4_S4_S2_bE_clES4_S4_S2_b((uint64_t)&v59, 1, v10, a5, a2->f32[0], a2->f32[1]);
      if (v65)
      {
        RB::Stroke::Flattener<RB::Stroke::Point>::flush_lineto(a1, 0);
        (*(void (**)(void, uint64_t *, double))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), &v64, v63);
      }
      else
      {
        *(unsigned char *)(a1 + 72) = 1;
        *(_DWORD *)(a1 + 76) = 1;
        *(double *)(a1 + 80) = v18;
      }
    }
  }
}

uint64_t _ZZN2RB6Stroke9FlattenerINS0_5PointEE6cubetoEDv2_fS4_S4_RKS2_ENKUlS4_S4_S2_bE_clES4_S4_S2_b(uint64_t result, int a2, float32x2_t a3, double a4, float a5, float a6)
{
  uint64_t v10 = result;
  uint64_t v11 = *(void *)result;
  if (*(unsigned char *)(result + 16)
    && ((uint32x2_t v12 = (uint32x2_t)vcgt_f32(vminnm_f32(a3, *(float32x2_t *)&a4), *(float32x2_t *)(v11 + 24)),
         (vpmax_u32(v12, v12).u32[0] & 0x80000000) != 0)
     || (uint32x2_t v13 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(v11 + 16), vmaxnm_f32(a3, *(float32x2_t *)&a4)),
         (vpmax_u32(v13, v13).u32[0] & 0x80000000) != 0)))
  {
    uint64_t v16 = *(void *)(result + 8);
    *(unsigned char *)(v16 + 16) = 1;
    *(double *)uint64_t v16 = a4;
    uint64_t v17 = *(void *)(result + 8);
    *(float *)(v17 + 8) = a5;
    *(float *)(v17 + 12) = a6;
    *(unsigned char *)(v11 + 72) = 0;
  }
  else
  {
    if (*(unsigned char *)(v11 + 49)) {
      uint64_t result = RB::Stroke::Flattener<RB::Stroke::Point>::flush_lineto(*(void *)result, 0);
    }
    uint64_t v14 = *(void *)(v10 + 8);
    if (*(unsigned char *)(v14 + 16))
    {
      *(unsigned char *)(v11 + 72) = 0;
      uint64_t result = (*(uint64_t (**)(void, uint64_t, double))(**(void **)(v11 + 8) + 24))(*(void *)(v11 + 8), v14 + 8, *(double *)v14);
      *(unsigned char *)(*(void *)(v10 + 8) + 16) = 0;
    }
    if (*(unsigned char *)(v11 + 72) && !*(_DWORD *)(v11 + 76))
    {
      *(void *)(v11 + 96) = *(void *)(v10 + 24);
      uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(v11 + 8) + 32))(*(void *)(v11 + 8), 0);
      *(unsigned char *)(v11 + 72) = 0;
    }
    char v15 = 1;
    if (a2)
    {
      if (a5 > *(float *)(v11 + 44)) {
        char v15 = *(unsigned char *)(v11 + 33);
      }
    }
    *(unsigned char *)(v11 + 51) = 0;
    *(unsigned char *)(v11 + 49) = 1;
    *(unsigned char *)(v11 + 53) = v15;
    *(double *)(v11 + 56) = a4;
    *(float *)(v11 + 64) = a5;
    *(float *)(v11 + 68) = a6;
  }
  return result;
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Particle>::endpath(uint64_t a1)
{
  uint64_t result = RB::Stroke::Flattener<RB::Stroke::Particle>::flush_lineto(a1, 1);
  if (*(unsigned char *)(a1 + 104))
  {
    if (*(_DWORD *)(a1 + 108) == 1)
    {
      uint64_t result = (*(uint64_t (**)(void, uint64_t, double))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), 1, *(double *)(a1 + 112));
      *(unsigned char *)(a1 + 104) = 0;
    }
  }
  return result;
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Particle>::closepath(uint64_t a1)
{
  RB::Stroke::Flattener<RB::Stroke::Particle>::lineto(a1, (long long *)(a1 + 136), *(double *)(a1 + 120));
  RB::Stroke::Flattener<RB::Stroke::Particle>::flush_lineto(a1, 0, *(float32x2_t *)(a1 + 128));
  uint64_t v2 = ***(uint64_t (****)(void))(a1 + 8);
  return v2();
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Particle>::moveto(uint64_t a1, uint64_t a2, double a3)
{
  RB::Stroke::Flattener<RB::Stroke::Particle>::flush_lineto(a1, 1);
  if (*(unsigned char *)(a1 + 104) && *(_DWORD *)(a1 + 108) == 1) {
    (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), 1, *(double *)(a1 + 112));
  }
  *(double *)(a1 + 120) = a3;
  __n128 v6 = *(__n128 *)a2;
  long long v7 = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 168) = *(void *)(a2 + 32);
  *(_OWORD *)(a1 + 152) = v7;
  *(__n128 *)(a1 + 136) = v6;
  *(void *)(a1 + 128) = 0;
  *(double *)(a1 + 176) = a3;
  __n128 v10 = *(__n128 *)a2;
  long long v8 = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 216) = *(void *)(a2 + 32);
  *(_OWORD *)(a1 + 200) = v8;
  *(__n128 *)(a1 + 184) = v10;
  *(_WORD *)(a1 + 50) = 1;
  *(unsigned char *)(a1 + 52) = 0;
  *(unsigned char *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 108) = 0;
  int32x2_t v9 = *(uint64_t (**)(__n128))(**(void **)(a1 + 8) + 8);
  v10.n128_f64[0] = a3;
  return v9(v10);
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Particle>::lineto(uint64_t result, long long *a2, double a3)
{
  uint64_t v4 = result;
  float32x2_t v5 = *(float32x2_t *)(result + 176);
  uint32x2_t v6 = (uint32x2_t)vceq_f32(v5, *(float32x2_t *)&a3);
  if ((vpmin_u32(v6, v6).u32[0] & 0x80000000) != 0)
  {
    if (*(unsigned char *)(result + 50) && !*(unsigned char *)(result + 32)) {
      *(unsigned char *)(result + 51) = 1;
    }
  }
  else
  {
    *(double *)(result + 176) = a3;
    long long v8 = *a2;
    long long v9 = a2[1];
    *(void *)(result + 216) = *((void *)a2 + 4);
    *(_OWORD *)(result + 200) = v9;
    *(_OWORD *)(result + 184) = v8;
    *(unsigned char *)(result + 50) = 0;
    float32x2_t v10 = vsub_f32(*(float32x2_t *)&a3, v5);
    uint64_t result = RB::Stroke::Flattener<RB::Stroke::Particle>::flush_lineto(result, 0, v10);
    if (*(unsigned char *)(v4 + 48)
      && ((uint32x2_t v12 = (uint32x2_t)vcgt_f32(vminnm_f32(v5, *(float32x2_t *)&a3), *(float32x2_t *)(v4 + 24)),
           (vpmax_u32(v12, v12).u32[0] & 0x80000000) != 0)
       || (uint32x2_t v13 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(v4 + 16), vmaxnm_f32(v5, *(float32x2_t *)&a3)),
           (vpmax_u32(v13, v13).u32[0] & 0x80000000) != 0)))
    {
      *(unsigned char *)(v4 + 104) = 0;
      uint64_t v17 = *(uint64_t (**)(__n128))(**(void **)(v4 + 8) + 24);
      v11.n128_f64[0] = a3;
      return v17(v11);
    }
    else
    {
      if (*(unsigned char *)(v4 + 104))
      {
        if (!*(_DWORD *)(v4 + 108))
        {
          *(float32x2_t *)(v4 + 128) = v10;
          uint64_t result = (*(uint64_t (**)(void, void, double))(**(void **)(v4 + 8) + 32))(*(void *)(v4 + 8), 0, *(double *)&v10);
          *(unsigned char *)(v4 + 104) = 0;
        }
      }
      char v14 = *(unsigned char *)(v4 + 33);
      *(unsigned char *)(v4 + 51) = 0;
      *(unsigned char *)(v4 + 49) = 1;
      *(unsigned char *)(v4 + 53) = v14;
      *(double *)(v4 + 56) = a3;
      long long v16 = *a2;
      long long v15 = a2[1];
      *(void *)(v4 + 96) = *((void *)a2 + 4);
      *(_OWORD *)(v4 + 64) = v16;
      *(_OWORD *)(v4 + 80) = v15;
      *(unsigned char *)(v4 + 104) = 1;
      *(_DWORD *)(v4 + 108) = 1;
      *(float32x2_t *)(v4 + 112) = v10;
    }
  }
  return result;
}

void RB::Stroke::Flattener<RB::Stroke::Particle>::quadto(float32x2_t *a1, uint64_t a2, float32x2_t a3, double a4)
{
  float32x2_t v5 = vadd_f32(a3, a3);
  float32x2_t v6 = (float32x2_t)vdup_n_s32(0x3EAAAAABu);
  RB::Stroke::Flattener<RB::Stroke::Particle>::cubeto((uint64_t)a1, a2, vmul_f32(vadd_f32(a1[22], v5), v6), vmul_f32(vadd_f32(v5, *(float32x2_t *)&a4), v6), a4);
}

void RB::Stroke::Flattener<RB::Stroke::Particle>::cubeto(uint64_t a1, uint64_t a2, float32x2_t a3, float32x2_t a4, double a5)
{
  float32x2_t v8 = *(float32x2_t *)(a1 + 184);
  float32x2_t v9 = *(float32x2_t *)(a1 + 176);
  float32x2_t v11 = *(float32x2_t *)(a1 + 192);
  float32x2_t v10 = *(float32x2_t *)(a1 + 200);
  float32x2_t v13 = *(float32x2_t *)(a1 + 208);
  float32x2_t v12 = *(float32x2_t *)(a1 + 216);
  uint32x2_t v14 = (uint32x2_t)vceq_f32(v9, a3);
  if ((vpmin_u32(v14, v14).u32[0] & 0x80000000) != 0
    && (uint32x2_t v15 = (uint32x2_t)vceq_f32(a3, a4), (vpmin_u32(v15, v15).u32[0] & 0x80000000) != 0)
    && (uint32x2_t v16 = (uint32x2_t)vceq_f32(a4, *(float32x2_t *)&a5), (vpmin_u32(v16, v16).u32[0] & 0x80000000) != 0))
  {
    RB::Stroke::Flattener<RB::Stroke::Particle>::lineto(a1, (long long *)a2, a5);
  }
  else
  {
    double v17 = COERCE_DOUBLE(vsub_f32(a3, v9));
    if (vaddv_f32(vmul_f32(*(float32x2_t *)&v17, *(float32x2_t *)&v17)) < 0.00001)
    {
      double v17 = COERCE_DOUBLE(vsub_f32(a4, v9));
      double v18 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&a5, v9));
      if (vaddv_f32(vmul_f32(*(float32x2_t *)&v17, *(float32x2_t *)&v17)) < 0.00001) {
        double v17 = v18;
      }
    }
    double v19 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&a5, a4));
    if (vaddv_f32(vmul_f32(*(float32x2_t *)&v19, *(float32x2_t *)&v19)) < 0.00001)
    {
      double v20 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&a5, a3));
      double v19 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&a5, v9));
      if (vaddv_f32(vmul_f32(*(float32x2_t *)&v20, *(float32x2_t *)&v20)) >= 0.00001) {
        double v19 = v20;
      }
    }
    double v69 = v19;
    double v70 = v17;
    *(double *)(a1 + 176) = a5;
    long long v22 = *(_OWORD *)a2;
    long long v21 = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 216) = *(void *)(a2 + 32);
    *(_OWORD *)(a1 + 184) = v22;
    *(_OWORD *)(a1 + 200) = v21;
    *(unsigned char *)(a1 + 50) = 0;
    *(double *)&float32x2_t v23 = a5;
    RB::Stroke::Flattener<RB::Stroke::Particle>::flush_lineto(a1, 0, *(float32x2_t *)&v17);
    int v29 = *(unsigned __int8 *)(a1 + 48);
    if (*(unsigned char *)(a1 + 48))
    {
      v24.n128_u64[0] = (unint64_t)vminnm_f32(v9, v23);
      float32x2_t v30 = vmaxnm_f32(v9, v23);
      float32x2_t v31 = a4;
      float32x2_t v32 = vminnm_f32(a3, a4);
      float32x2_t v33 = vmaxnm_f32(a3, a4);
      float32x2_t v34 = *(float32x2_t *)(a1 + 16);
      float32x2_t v35 = *(float32x2_t *)(a1 + 24);
      *(int32x2_t *)v28.i8 = vcgt_f32(v34, vmaxnm_f32(v30, v33));
      uint32x2_t v36 = (uint32x2_t)vorr_s8(*(int8x8_t *)v28.i8, (int8x8_t)vcgt_f32(vminnm_f32((float32x2_t)v24.n128_u64[0], v32), v35));
      *(uint32x2_t *)v27.i8 = vpmax_u32(v36, v36);
      if (v27.i32[0] < 0) {
        goto LABEL_21;
      }
      *(int32x2_t *)v26.i8 = vcge_f32(v30, v33);
      uint32x2_t v37 = (uint32x2_t)vand_s8(*(int8x8_t *)v26.i8, (int8x8_t)vcge_f32(v32, (float32x2_t)v24.n128_u64[0]));
      *(uint32x2_t *)v25.i8 = vpmin_u32(v37, v37);
      if ((v25.i32[0] & 0x80000000) == 0)
      {
        v24.n128_f64[0] = RB::Path::cubic_bounds_slow(v9, a3, a4, v23, v25, v26, v27, v28);
        float32x2_t v31 = a4;
        float32x2_t v34 = *(float32x2_t *)(a1 + 16);
        float32x2_t v35 = *(float32x2_t *)(a1 + 24);
      }
      uint32x2_t v38 = (uint32x2_t)vorr_s8((int8x8_t)vcgt_f32(v34, v30), (int8x8_t)vcgt_f32((float32x2_t)v24.n128_u64[0], v35));
      if ((vpmax_u32(v38, v38).u32[0] & 0x80000000) != 0)
      {
LABEL_21:
        *(unsigned char *)(a1 + 104) = 0;
        float v44 = *(void (**)(__n128))(**(void **)(a1 + 8) + 24);
        v24.n128_u64[0] = (unint64_t)v23;
        v44(v24);
        return;
      }
      uint32x2_t v39 = (uint32x2_t)vcge_f32((float32x2_t)v24.n128_u64[0], v34);
      int v40 = vpmin_u32(v39, v39).u32[0];
      uint32x2_t v41 = (uint32x2_t)vcge_f32(v35, v30);
      if (vpmin_u32(v41, v41).i32[0] >= 0) {
        int v42 = v29;
      }
      else {
        int v42 = 0;
      }
      if (v40 < 0) {
        int v43 = v42;
      }
      else {
        int v43 = 1;
      }
    }
    else
    {
      int v43 = 0;
      float32x2_t v31 = a4;
    }
    float32x2_t v45 = vmaxnm_f32(vabs_f32(vadd_f32(vsub_f32(v31, vadd_f32(a3, a3)), v9)), vabs_f32(vadd_f32(vsub_f32(a3, vadd_f32(v31, v31)), v23)));
    float v46 = ceilf(sqrtf(sqrtf(vaddv_f32(vmul_f32(v45, v45))) * *(float *)(a1 + 40)));
    if (v46 >= 0.0 && ((LODWORD(v46) & 0x7FFFFFFFu) - 0x800000) >> 24 <= 0x7E || LODWORD(v46) == 0)
    {
      if (v46 >= 1.0)
      {
        if (v46 > 1024.0) {
          float v46 = 1024.0;
        }
        uint64_t v50 = (int)v46;
      }
      else
      {
        uint32x2_t v49 = (uint32x2_t)vceq_f32(v9, v23);
        if ((vpmin_u32(v49, v49).u32[0] & 0x80000000) != 0) {
          return;
        }
        uint64_t v50 = 1;
      }
      __asm { FMOV            V1.2S, #1.0 }
      *(void *)&long long v83 = _D1;
      *((void *)&v83 + 1) = 1065353216;
      long long v84 = 0uLL;
      uint64_t v85 = 1065353216;
      char v86 = 0;
      if ((int)v50 >= 2)
      {
        float32x2_t v68 = v23;
        _ZN2RB13CubicIteratorIDv2_fEC1ES1_S1_S1_S1_i(&v78, v50);
        float32x2_t v55 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)v50));
        float32x2_t v56 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)v50), v55), v55);
        v56.i32[0] = vmul_f32(v56, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)v50), v56)).u32[0];
        float32x2_t v72 = vmul_n_f32(vsub_f32(*(float32x2_t *)(a2 + 8), v11), v56.f32[0]);
        float32x2_t v74 = vmul_n_f32(vsub_f32(*(float32x2_t *)a2, v8), v56.f32[0]);
        float32x2_t v71 = vmul_n_f32(vsub_f32(*(float32x2_t *)(a2 + 16), v10), v56.f32[0]);
        float32x2_t v57 = vmul_n_f32(vsub_f32(*(float32x2_t *)(a2 + 24), v13), v56.f32[0]);
        float32x2_t v58 = vmul_n_f32(vsub_f32(*(float32x2_t *)(a2 + 32), v12), v56.f32[0]);
        int v59 = v50 - 1;
        do
        {
          float32x2_t v60 = v78;
          float32x2_t v9 = vadd_f32(v79, v78);
          float32x2_t v78 = v9;
          float32x2_t v79 = vadd_f32(v80, v79);
          float32x2_t v80 = vadd_f32(v81, v80);
          float32x2_t v8 = vadd_f32(v8, v74);
          float32x2_t v11 = vadd_f32(v11, v72);
          float32x2_t v10 = vadd_f32(v10, v71);
          float32x2_t v13 = vadd_f32(v13, v57);
          float32x2_t v12 = vadd_f32(v12, v58);
          if (v43
            && ((uint32x2_t v61 = (uint32x2_t)vcgt_f32(vminnm_f32(v60, v9), *(float32x2_t *)(a1 + 24)),
                 (vpmax_u32(v61, v61).u32[0] & 0x80000000) != 0)
             || (uint32x2_t v62 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(a1 + 16), vmaxnm_f32(v60, v9)),
                 (vpmax_u32(v62, v62).u32[0] & 0x80000000) != 0)))
          {
            char v86 = 1;
            double v82 = *(double *)&v9;
            *(float32x2_t *)&long long v83 = v8;
            *((float32x2_t *)&v83 + 1) = v11;
            *(float32x2_t *)&long long v84 = v10;
            *((float32x2_t *)&v84 + 1) = v13;
            uint64_t v85 = (uint64_t)v12;
            *(unsigned char *)(a1 + 104) = 0;
          }
          else
          {
            if (*(unsigned char *)(a1 + 49)) {
              RB::Stroke::Flattener<RB::Stroke::Particle>::flush_lineto(a1, 0);
            }
            if (v86)
            {
              *(unsigned char *)(a1 + 104) = 0;
              (*(void (**)(void, long long *, double))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), &v83, v82);
              char v86 = 0;
            }
            if (*(unsigned char *)(a1 + 104) && !*(_DWORD *)(a1 + 108))
            {
              *(double *)(a1 + 128) = v70;
              (*(void (**)(void, void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), 0);
              *(unsigned char *)(a1 + 104) = 0;
            }
            *(unsigned char *)(a1 + 51) = 0;
            *(unsigned char *)(a1 + 49) = 1;
            *(unsigned char *)(a1 + 53) = 1;
            *(double *)(a1 + 56) = *(double *)&v9;
            *(float32x2_t *)(a1 + 64) = v8;
            *(float32x2_t *)(a1 + 72) = v11;
            *(float32x2_t *)(a1 + 80) = v10;
            *(float32x2_t *)(a1 + 88) = v13;
            *(float32x2_t *)(a1 + 96) = v12;
          }
          --v59;
        }
        while (v59);
        float32x2_t v23 = v68;
      }
      long long v75 = *(_OWORD *)a2;
      long long v76 = *(_OWORD *)(a2 + 16);
      uint64_t v77 = *(void *)(a2 + 32);
      if (v43
        && ((uint32x2_t v63 = (uint32x2_t)vcgt_f32(vminnm_f32(v9, v23), *(float32x2_t *)(a1 + 24)),
             (vpmax_u32(v63, v63).u32[0] & 0x80000000) != 0)
         || (uint32x2_t v64 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(a1 + 16), vmaxnm_f32(v9, v23)),
             (vpmax_u32(v64, v64).u32[0] & 0x80000000) != 0)))
      {
        char v86 = 1;
        double v82 = *(double *)&v23;
        long long v66 = *(_OWORD *)(a2 + 16);
        long long v83 = *(_OWORD *)a2;
        long long v84 = v66;
        uint64_t v85 = *(void *)(a2 + 32);
        *(unsigned char *)(a1 + 104) = 0;
      }
      else
      {
        if (*(unsigned char *)(a1 + 49)) {
          RB::Stroke::Flattener<RB::Stroke::Particle>::flush_lineto(a1, 0);
        }
        if (v86)
        {
          *(unsigned char *)(a1 + 104) = 0;
          (*(void (**)(void, long long *, double))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), &v83, v82);
          char v86 = 0;
        }
        if (*(unsigned char *)(a1 + 104) && !*(_DWORD *)(a1 + 108))
        {
          *(double *)(a1 + 128) = v70;
          (*(void (**)(void, void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), 0);
          *(unsigned char *)(a1 + 104) = 0;
          BOOL v65 = v86 == 0;
        }
        else
        {
          BOOL v65 = 1;
        }
        char v67 = *(unsigned char *)(a1 + 33);
        *(unsigned char *)(a1 + 51) = 0;
        *(unsigned char *)(a1 + 49) = 1;
        *(unsigned char *)(a1 + 53) = v67;
        *(double *)(a1 + 56) = *(double *)&v23;
        *(_OWORD *)(a1 + 64) = v75;
        *(_OWORD *)(a1 + 80) = v76;
        *(void *)(a1 + 96) = v77;
        if (v65)
        {
          *(unsigned char *)(a1 + 104) = 1;
          *(_DWORD *)(a1 + 108) = 1;
          *(double *)(a1 + 112) = v69;
          return;
        }
      }
      RB::Stroke::Flattener<RB::Stroke::Particle>::flush_lineto(a1, 0);
      (*(void (**)(void, long long *, double))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), &v83, v82);
    }
  }
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Particle>::flush_lineto(uint64_t result, int a2)
{
  uint64_t v2 = result;
  if (!a2)
  {
    if (!*(unsigned char *)(result + 49)) {
      return result;
    }
    uint64_t v3 = *(unsigned __int8 *)(result + 53);
    goto LABEL_7;
  }
  uint64_t result = RB::Stroke::Flattener<RB::Stroke::Particle>::flush_empty_line(result);
  if ((result & 1) == 0 && *(unsigned char *)(v2 + 49))
  {
    uint64_t v3 = 1;
LABEL_7:
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, double))(**(void **)(v2 + 8) + 16))(*(void *)(v2 + 8), v2 + 64, v3, *(double *)(v2 + 56));
    *(unsigned char *)(v2 + 49) = 0;
    *(unsigned char *)(v2 + 52) = 1;
  }
  return result;
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Particle>::flush_empty_line(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 50) || !*(unsigned char *)(a1 + 51)) {
    return 0;
  }
  (*(void (**)(void, void, double))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), 0, COERCE_DOUBLE(1065353216));
  uint64_t v2 = 1;
  (*(void (**)(void, uint64_t, uint64_t, double))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), a1 + 136, 1, *(double *)(a1 + 120));
  (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), 1, COERCE_DOUBLE(1065353216));
  *(unsigned char *)(a1 + 104) = 0;
  *(_WORD *)(a1 + 51) = 256;
  return v2;
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Particle>::flush_lineto(uint64_t result, int a2, float32x2_t a3)
{
  uint64_t v3 = result;
  if (!a2)
  {
    if (!*(unsigned char *)(result + 49)) {
      return result;
    }
    uint64_t v4 = *(unsigned __int8 *)(result + 53);
    if (!*(unsigned char *)(result + 53))
    {
      if (*(unsigned char *)(result + 104) && *(_DWORD *)(result + 108) == 1)
      {
        float32x2_t v5 = *(float32x2_t *)(result + 112);
        int32x2_t v6 = (int32x2_t)vmul_f32(v5, v5);
        v6.i32[0] = vadd_f32((float32x2_t)v6, (float32x2_t)vdup_lane_s32(v6, 1)).u32[0];
        float32x2_t v7 = vrsqrte_f32((float32x2_t)v6.u32[0]);
        float32x2_t v8 = vmul_f32(vrsqrts_f32((float32x2_t)v6.u32[0], vmul_f32(v7, v7)), v7);
        int32x2_t v9 = (int32x2_t)vmul_f32(a3, a3);
        v9.i32[0] = vadd_f32((float32x2_t)v9, (float32x2_t)vdup_lane_s32(v9, 1)).u32[0];
        float32x2_t v10 = vrsqrte_f32((float32x2_t)v9.u32[0]);
        float32x2_t v11 = vmul_f32(vrsqrts_f32((float32x2_t)v9.u32[0], vmul_f32(v10, v10)), v10);
        float v12 = vaddv_f32(vmul_n_f32(vmul_f32(v5, a3), vmul_f32(vmul_f32(vmul_f32(v8, vrsqrts_f32((float32x2_t)v9.u32[0], vmul_f32(v11, v11))), v11), vrsqrts_f32((float32x2_t)v6.u32[0], vmul_f32(v8, v8))).f32[0]));
        if (v12 > 0.99) {
          uint64_t v4 = 1;
        }
        else {
          uint64_t v4 = 2 * ((float)((float)(v12 + 1.0) * *(float *)(result + 36)) < 2.0);
        }
      }
      else
      {
        uint64_t v4 = 0;
      }
    }
    goto LABEL_13;
  }
  uint64_t result = RB::Stroke::Flattener<RB::Stroke::Particle>::flush_empty_line(result);
  if ((result & 1) == 0 && *(unsigned char *)(v3 + 49))
  {
    uint64_t v4 = 1;
LABEL_13:
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, double))(**(void **)(v3 + 8) + 16))(*(void *)(v3 + 8), v3 + 64, v4, *(double *)(v3 + 56));
    *(unsigned char *)(v3 + 49) = 0;
    *(unsigned char *)(v3 + 52) = 1;
  }
  return result;
}

float RB::Path::ClipStroke::ClipStroke(uint64_t a1, uint64_t a2, int a3, char a4, uint64_t a5, uint64_t a6, float result)
{
  *(void *)a1 = &unk_26C4E8188;
  *(void *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 16) = a3;
  *(float *)(a1 + 20) = result;
  *(unsigned char *)(a1 + 24) = a4;
  *(void *)(a1 + 32) = a5;
  *(void *)(a1 + 40) = a6;
  *(void *)(a1 + 344) = 0;
  *(void *)(a1 + 352) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 360) = 32;
  if ((a3 & 2) == 0)
  {
    if ((a3 & 1) == 0) {
      return result;
    }
LABEL_7:
    uint64_t result = 1.0 - result;
    *(float *)(a1 + 20) = result;
    return result;
  }
  float v7 = fmaxf(result, 0.0);
  if ((a3 & 4) == 0) {
    uint64_t result = v7;
  }
  uint64_t result = fminf(result, 1.0);
  *(float *)(a1 + 20) = result;
  if (a3) {
    goto LABEL_7;
  }
  return result;
}

void *RB::Path::ClipStroke::DistanceMap::append(void *this, double a2, double a3, double a4)
{
  float v7 = this;
  uint64_t v8 = this[13];
  if (v8
    && (this[12] ? (int32x2_t v9 = (void *)this[12]) : (int32x2_t v9 = this),
        (uint64_t v10 = 3 * (v8 - 1), v11 = *(double *)&v9[v10], v12 = *(double *)&v9[v10 + 2], fabs(v11 - a2 + v12) < 1.0)
     && fabs(v12 - a3 + *(double *)&v9[3 * v8 - 2]) < 1.0))
  {
    *(double *)&v9[v10 + 2] = a4 + a2 - v11;
  }
  else
  {
    unint64_t v13 = v8 + 1;
    if (this[14] < (unint64_t)(v8 + 1))
    {
      this = RB::vector<RB::CustomShader::Value,4ul,unsigned long>::reserve_slow(this, v13);
      uint64_t v8 = v7[13];
      unint64_t v13 = v8 + 1;
    }
    uint32x2_t v14 = (void *)v7[12];
    if (!v14) {
      uint32x2_t v14 = v7;
    }
    uint32x2_t v15 = (double *)&v14[3 * v8];
    *uint32x2_t v15 = a2;
    v15[1] = a3;
    int32x2_t v15[2] = a4;
    v7[13] = v13;
  }
  return this;
}

double RB::Path::ClipStroke::DistanceMap::operator()(uint64_t a1, double a2)
{
  uint64_t v2 = *(double **)(a1 + 96);
  unint64_t v3 = *(void *)(a1 + 104);
  if (!v2) {
    uint64_t v2 = (double *)a1;
  }
  if (!v3) {
    return INFINITY;
  }
  uint64_t v4 = &v2[3 * v3];
  do
  {
    unint64_t v5 = v3 >> 1;
    int32x2_t v6 = &v2[3 * (v3 >> 1)];
    double v7 = *v6 + 0.0001 + v6[2];
    uint64_t v8 = v6 + 3;
    v3 += ~(v3 >> 1);
    if (v7 < a2) {
      uint64_t v2 = v8;
    }
    else {
      unint64_t v3 = v5;
    }
  }
  while (v3);
  if (v2 != v4 && (double v9 = a2 - *v2, v9 >= -0.0001)) {
    return v2[1] + v9;
  }
  else {
    return INFINITY;
  }
}

uint64_t RB::Path::ClipStroke::Subpath::replay(uint64_t result, uint64_t *a2, int a3, float64x2_t *a4)
{
  if (*(void *)(result + 288))
  {
    uint64_t v7 = result;
    __n128 v8 = *(__n128 *)result;
    if (a4) {
      __n128 v8 = (__n128)vmlaq_laneq_f64(vmlaq_n_f64(a4[2], *a4, *(double *)result), a4[1], (float64x2_t)v8, 1);
    }
    uint64_t v9 = *a2;
    if (a3) {
      uint64_t result = (*(uint64_t (**)(uint64_t *, __n128))(v9 + 16))(a2, v8);
    }
    else {
      uint64_t result = (*(uint64_t (**)(uint64_t *, __n128))(v9 + 24))(a2, v8);
    }
    if (*(uint64_t *)(v7 + 288) >= 1)
    {
      if (*(void *)(v7 + 280)) {
        uint64_t v10 = *(double **)(v7 + 280);
      }
      else {
        uint64_t v10 = (double *)(v7 + 24);
      }
      do
      {
        int v11 = (int)*v10;
        switch(v11)
        {
          case 4:
            __n128 v16 = *(__n128 *)(v10 + 2);
            if (a4)
            {
              float64x2_t v17 = a4[1];
              __n128 v18 = (__n128)vmlaq_n_f64(vmlaq_n_f64(a4[2], *a4, v10[4]), v17, v10[5]);
              __n128 v19 = (__n128)vmlaq_n_f64(vmlaq_n_f64(a4[2], *a4, v10[6]), v17, v10[7]);
              __n128 v16 = (__n128)vmlaq_laneq_f64(vmlaq_n_f64(a4[2], *a4, v10[2]), v17, (float64x2_t)v16, 1);
            }
            else
            {
              __n128 v18 = *(__n128 *)(v10 + 4);
              __n128 v19 = *(__n128 *)(v10 + 6);
            }
            uint64_t result = (*(uint64_t (**)(uint64_t *, __n128, __n128, __n128))(*a2 + 40))(a2, v16, v18, v19);
            v10 += 8;
            break;
          case 3:
            __n128 v13 = *(__n128 *)(v10 + 2);
            if (a4)
            {
              float64x2_t v14 = a4[1];
              __n128 v15 = (__n128)vmlaq_n_f64(vmlaq_n_f64(a4[2], *a4, v10[4]), v14, v10[5]);
              __n128 v13 = (__n128)vmlaq_laneq_f64(vmlaq_n_f64(a4[2], *a4, v10[2]), v14, (float64x2_t)v13, 1);
            }
            else
            {
              __n128 v15 = *(__n128 *)(v10 + 4);
            }
            uint64_t result = (*(uint64_t (**)(uint64_t *, __n128, __n128))(*a2 + 32))(a2, v13, v15);
            v10 += 6;
            break;
          case 2:
            __n128 v12 = *(__n128 *)(v10 + 2);
            if (a4) {
              __n128 v12 = (__n128)vmlaq_laneq_f64(vmlaq_n_f64(a4[2], *a4, v10[2]), a4[1], (float64x2_t)v12, 1);
            }
            uint64_t result = (*(uint64_t (**)(uint64_t *, __n128))(*a2 + 24))(a2, v12);
            v10 += 4;
            break;
        }
        uint64_t v20 = *(void *)(v7 + 280);
        if (!v20) {
          uint64_t v20 = v7 + 24;
        }
      }
      while ((unint64_t)v10 < v20 + 8 * *(void *)(v7 + 288));
    }
    if (a3)
    {
      long long v21 = *(uint64_t (**)(uint64_t *))(*a2 + 8);
      return v21(a2);
    }
  }
  return result;
}

double RB::Path::ClipStroke::Subpath::close(RB::Path::ClipStroke::Subpath *this, __n128 a2)
{
  uint64_t v2 = *((void *)this + 36);
  if (v2)
  {
    unint64_t v3 = (char *)this + 24;
    if (*((void *)this + 35)) {
      unint64_t v3 = (char *)*((void *)this + 35);
    }
    uint64_t v4 = &v3[8 * v2];
    a2.n128_u64[0] = *(void *)this;
    if (*(double *)this != *((double *)v4 - 2))
    {
      double v5 = *((double *)this + 1);
LABEL_7:
      a2.n128_f64[1] = v5;
      a2.n128_f64[0] = RB::Path::ClipStroke::Subpath::add_lineto((uint64_t)this, a2, INFINITY);
      return a2.n128_f64[0];
    }
    double v5 = *((double *)this + 1);
    if (v5 != *((double *)v4 - 1)) {
      goto LABEL_7;
    }
  }
  return a2.n128_f64[0];
}

double RB::Path::ClipStroke::Subpath::add_lineto(uint64_t a1, __n128 a2, double a3)
{
  uint64_t v5 = a1 + 24;
  unint64_t v6 = *(void *)(a1 + 288);
  unint64_t v7 = v6 + 4;
  if (v6 <= 0xFFFFFFFFFFFFFFFBLL && *(void *)(a1 + 296) < v7)
  {
    __n128 v15 = a2;
    RB::vector<RB::DisplayList::Item const*,32ul,unsigned long>::reserve_slow((void *)(a1 + 24), v6 + 4);
    a2 = v15;
  }
  *(void *)(a1 + 288) = v7;
  uint64_t v8 = *(void *)(a1 + 280);
  if (!v8) {
    uint64_t v8 = v5;
  }
  uint64_t v9 = (__n128 *)(v8 + 8 * v6);
  uint64_t v10 = (double *)(a1 + 8);
  n128_f64 = v9[-1].n128_f64;
  if (v6) {
    uint64_t v10 = &v9[-1].n128_f64[1];
  }
  else {
    n128_f64 = (double *)a1;
  }
  double v12 = *v10;
  double v13 = *n128_f64;
  v9->n128_u64[0] = 0x4000000000000000;
  if ((*(void *)&a3 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
    a3 = sqrt((a2.n128_f64[1] - v12) * (a2.n128_f64[1] - v12) + (a2.n128_f64[0] - v13) * (a2.n128_f64[0] - v13));
  }
  v9->n128_f64[1] = a3;
  v9[1] = a2;
  double result = *(double *)(a1 + 16) + a3;
  *(double *)(a1 + 16) = result;
  return result;
}

void RB::Path::ClipStroke::Subpath::append_range(__n128 *this, const RB::Path::ClipStroke::Subpath *a2, double a3, double a4, RB::Path::ClipStroke::DistanceMap *a5)
{
  *(_OWORD *)&v32[0].v = *(_OWORD *)a2;
  if (*((uint64_t *)a2 + 36) >= 1)
  {
    uint64_t v10 = (char *)a2 + 24;
    if (*((void *)a2 + 35)) {
      int v11 = (char *)*((void *)a2 + 35);
    }
    else {
      int v11 = (char *)a2 + 24;
    }
    double v12 = 0.0;
    do
    {
      int v13 = (int)*(double *)v11;
      switch(v13)
      {
        case 4:
          long long v22 = *((_OWORD *)v11 + 1);
          *(_OWORD *)&v30[0].v = *((_OWORD *)v11 + 2);
          *(_OWORD *)&v31[0].v = v22;
          *(_OWORD *)&v29[0].v = *((_OWORD *)v11 + 3);
          CG::Cubic::Cubic((CG::Cubic *)&v26, v32, v31, v30, v29);
          double v23 = *((double *)v11 + 1);
          double v17 = v23 + v12;
          double v24 = a4;
          if (a4 <= a3)
          {
            RB::Path::ClipStroke::Subpath::add<CG::Cubic>(this, &v26, a5, v12, *((double *)v11 + 1), v12, a4);
            double v24 = v23 + v12;
          }
          RB::Path::ClipStroke::Subpath::add<CG::Cubic>(this, &v26, a5, v12, v23, a3, v24);
          *(_OWORD *)&v32[0].v = *(_OWORD *)&v29[0].v;
          v11 += 64;
          break;
        case 3:
          long long v19 = *((_OWORD *)v11 + 1);
          *(_OWORD *)&v30[0].v = *((_OWORD *)v11 + 2);
          *(_OWORD *)&v31[0].v = v19;
          CG::Quadratic::Quadratic((CG::Quadratic *)&v26, v32, v31, v30);
          double v20 = *((double *)v11 + 1);
          double v17 = v20 + v12;
          double v21 = a4;
          if (a4 <= a3)
          {
            RB::Path::ClipStroke::Subpath::add<CG::Quadratic>(this, (CG::Quadratic *)&v26, a5, v12, *((double *)v11 + 1), v12, a4);
            double v21 = v20 + v12;
          }
          RB::Path::ClipStroke::Subpath::add<CG::Quadratic>(this, (CG::Quadratic *)&v26, a5, v12, v20, a3, v21);
          *(_OWORD *)&v32[0].v = *(_OWORD *)&v30[0].v;
          v11 += 48;
          break;
        case 2:
          uint64_t v14 = *((void *)v11 + 2);
          uint64_t v15 = *((void *)v11 + 3);
          float64x2_t v26 = *(float64x2_t *)&v32[0].v;
          uint64_t v27 = v14;
          uint64_t v28 = v15;
          double v16 = *((double *)v11 + 1);
          double v17 = v16 + v12;
          double v18 = a4;
          if (a4 <= a3)
          {
            RB::Path::ClipStroke::Subpath::add<CG::LineSegment>((RB::Path::ClipStroke::Subpath *)this, &v26, a5, v12, *((double *)v11 + 1), v12, a4);
            double v18 = v16 + v12;
          }
          RB::Path::ClipStroke::Subpath::add<CG::LineSegment>((RB::Path::ClipStroke::Subpath *)this, &v26, a5, v12, v16, a3, v18);
          *(void *)&v32[0].v = v14;
          *(void *)&v32[2].v = v15;
          v11 += 32;
          break;
        default:
          double v17 = v12;
          break;
      }
      int32x4_t v25 = (char *)*((void *)a2 + 35);
      if (!v25) {
        int32x4_t v25 = v10;
      }
      double v12 = v17;
    }
    while (v11 < &v25[8 * *((void *)a2 + 36)]);
  }
}

void RB::Path::ClipStroke::Subpath::append_logical_range(__n128 *this, const RB::Path::ClipStroke::Subpath *a2, double a3, double a4, RB::Path::ClipStroke::DistanceMap *a5)
{
  if (a3 > a4)
  {
    RB::Path::ClipStroke::Subpath::append_range(this, a2, a3, *((double *)a2 + 2), a5);
    a3 = 0.0;
  }
  RB::Path::ClipStroke::Subpath::append_range(this, a2, a3, a4, a5);
}

double RB::Path::ClipStroke::Subpath::add_quadto(__n128 *a1, __n128 a2, __n128 a3, double a4)
{
  unint64_t v6 = &a1[1].n128_i64[1];
  unint64_t v7 = a1[18].n128_u64[0];
  unint64_t v8 = v7 + 6;
  __n128 v15 = a2;
  __n128 v16 = a3;
  if (v7 >= 0xFFFFFFFFFFFFFFFALL)
  {
    a1[18].n128_u64[0] = v8;
    double v12 = (uint64_t *)a1[17].n128_u64[1];
    if (!v12) {
      double v12 = &a1[1].n128_i64[1];
    }
    uint64_t v10 = (__n128 *)&v12[v7];
  }
  else
  {
    if (a1[18].n128_u64[1] < v8)
    {
      RB::vector<RB::DisplayList::Item const*,32ul,unsigned long>::reserve_slow(&a1[1].n128_i8[8], v7 + 6);
      a2 = v15;
      a3 = v16;
    }
    a1[18].n128_u64[0] = v8;
    uint64_t v9 = (uint64_t *)a1[17].n128_u64[1];
    if (!v9) {
      uint64_t v9 = v6;
    }
    uint64_t v10 = (__n128 *)&v9[v7];
    if (!v7)
    {
      __n128 v11 = *a1;
      goto LABEL_12;
    }
  }
  __n128 v11 = v10[-1];
LABEL_12:
  *(__n128 *)&v20[0].v = v11;
  *(__n128 *)&v17[0].v = a3;
  *(__n128 *)&v18[0].v = a2;
  CG::Quadratic::Quadratic((CG::Quadratic *)v19, v20, v18, v17);
  v10->n128_u64[0] = 0x4008000000000000;
  if ((*(void *)&a4 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    CG::Quadratic::length(v19, 0);
    a4 = v13;
  }
  v10->n128_f64[1] = a4;
  v10[1] = v15;
  int32x2_t v10[2] = v16;
  double result = a1[1].n128_f64[0] + a4;
  a1[1].n128_f64[0] = result;
  return result;
}

double RB::Path::ClipStroke::Subpath::add_cubeto(__n128 *a1, __n128 a2, __n128 a3, __n128 a4, double a5)
{
  unint64_t v7 = &a1[1].n128_i64[1];
  unint64_t v8 = a1[18].n128_u64[0];
  unint64_t v9 = v8 + 8;
  __n128 v16 = a3;
  __n128 v17 = a4;
  __n128 v15 = a2;
  if (v8 >= 0xFFFFFFFFFFFFFFF8)
  {
    a1[18].n128_u64[0] = v9;
    double v13 = (uint64_t *)a1[17].n128_u64[1];
    if (!v13) {
      double v13 = &a1[1].n128_i64[1];
    }
    __n128 v11 = (__n128 *)&v13[v8];
  }
  else
  {
    if (a1[18].n128_u64[1] < v9)
    {
      RB::vector<RB::DisplayList::Item const*,32ul,unsigned long>::reserve_slow(&a1[1].n128_i8[8], v8 + 8);
      a2 = v15;
      a3 = v16;
      a4 = v17;
    }
    a1[18].n128_u64[0] = v9;
    uint64_t v10 = (uint64_t *)a1[17].n128_u64[1];
    if (!v10) {
      uint64_t v10 = v7;
    }
    __n128 v11 = (__n128 *)&v10[v8];
    if (!v8)
    {
      __n128 v12 = *a1;
      goto LABEL_12;
    }
  }
  __n128 v12 = v11[-1];
LABEL_12:
  *(__n128 *)&v22[0].v = v12;
  *(__n128 *)&v19[0].v = a3;
  *(__n128 *)&v20[0].v = a2;
  *(__n128 *)&v18[0].v = a4;
  CG::Cubic::Cubic((CG::Cubic *)v21, v22, v20, v19, v18);
  v11->n128_u64[0] = 0x4010000000000000;
  if ((*(void *)&a5 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
    a5 = CG::Cubic::length(v21, 0.5);
  }
  v11->n128_f64[1] = a5;
  v11[1] = v15;
  float32x2_t v11[2] = v16;
  float64x2_t v11[3] = v17;
  double result = a1[1].n128_f64[0] + a5;
  a1[1].n128_f64[0] = result;
  return result;
}

double RB::Path::ClipStroke::Subpath::add(RB::Path::ClipStroke::Subpath *this, float64x2_t *a2, double a3)
{
  __n128 v5 = *(__n128 *)a2;
  float64x2_t v6 = vsubq_f64(a2[1], *a2);
  if (vaddvq_f64(vmulq_f64(v6, v6)) <= 0.00000001) {
    return *((double *)this + 2);
  }
  uint64_t v8 = *((void *)this + 36);
  if (v8)
  {
    unint64_t v9 = (char *)this + 24;
    if (*((void *)this + 35)) {
      unint64_t v9 = (char *)*((void *)this + 35);
    }
    uint64_t v10 = &v9[8 * v8];
    if (v5.n128_f64[0] != *((double *)v10 - 2) || v5.n128_f64[1] != *((double *)v10 - 1)) {
      RB::Path::ClipStroke::Subpath::add_lineto((uint64_t)this, v5, INFINITY);
    }
  }
  else
  {
    *(__n128 *)this = v5;
    *((void *)this + 2) = 0;
    *((void *)this + 36) = 0;
  }
  double v11 = *((double *)this + 2);
  RB::Path::ClipStroke::Subpath::add_lineto((uint64_t)this, (__n128)a2[1], a3);
  return v11;
}

double RB::Path::ClipStroke::Subpath::add(__n128 *this, const CG::Quadratic *a2, double a3)
{
  __n128 v6 = *(__n128 *)a2;
  float64x2_t v7 = *((float64x2_t *)a2 + 1);
  float64x2_t v8 = vsubq_f64(v7, *(float64x2_t *)a2);
  if (vaddvq_f64(vmulq_f64(v8, v8)) <= 0.00000001
    && (*((double *)a2 + 4) - v7.f64[0]) * (*((double *)a2 + 4) - v7.f64[0])
     + (*((double *)a2 + 5) - v7.f64[1]) * (*((double *)a2 + 5) - v7.f64[1]) <= 0.00000001)
  {
    return this[1].n128_f64[0];
  }
  unint64_t v9 = this[18].n128_u64[0];
  if (v9)
  {
    uint64_t v10 = &this[1].n128_i8[8];
    if (this[17].n128_u64[1]) {
      uint64_t v10 = (__int8 *)this[17].n128_u64[1];
    }
    double v11 = &v10[8 * v9];
    if (v6.n128_f64[0] != *((double *)v11 - 2) || v6.n128_f64[1] != *((double *)v11 - 1)) {
      RB::Path::ClipStroke::Subpath::add_lineto((uint64_t)this, v6, INFINITY);
    }
  }
  else
  {
    *this = v6;
    this[1].n128_u64[0] = 0;
    this[18].n128_u64[0] = 0;
  }
  double v12 = this[1].n128_f64[0];
  RB::Path::ClipStroke::Subpath::add_quadto(this, *((__n128 *)a2 + 1), *((__n128 *)a2 + 2), a3);
  return v12;
}

double RB::Path::ClipStroke::Subpath::add(__n128 *this, const CG::Cubic *a2, double a3)
{
  __n128 v6 = *(__n128 *)a2;
  float64x2_t v7 = *((float64x2_t *)a2 + 1);
  float64x2_t v8 = vsubq_f64(v7, *(float64x2_t *)a2);
  if (vaddvq_f64(vmulq_f64(v8, v8)) <= 0.00000001)
  {
    double v9 = *((double *)a2 + 4);
    double v10 = *((double *)a2 + 5);
    if ((v9 - v7.f64[0]) * (v9 - v7.f64[0]) + (v10 - v7.f64[1]) * (v10 - v7.f64[1]) <= 0.00000001
      && (*((double *)a2 + 6) - v9) * (*((double *)a2 + 6) - v9)
       + (*((double *)a2 + 7) - v10) * (*((double *)a2 + 7) - v10) <= 0.00000001)
    {
      return this[1].n128_f64[0];
    }
  }
  unint64_t v11 = this[18].n128_u64[0];
  if (v11)
  {
    double v12 = &this[1].n128_i8[8];
    if (this[17].n128_u64[1]) {
      double v12 = (__int8 *)this[17].n128_u64[1];
    }
    double v13 = &v12[8 * v11];
    if (v6.n128_f64[0] != *((double *)v13 - 2) || v6.n128_f64[1] != *((double *)v13 - 1)) {
      RB::Path::ClipStroke::Subpath::add_lineto((uint64_t)this, v6, INFINITY);
    }
  }
  else
  {
    *this = v6;
    this[1].n128_u64[0] = 0;
    this[18].n128_u64[0] = 0;
  }
  double v14 = this[1].n128_f64[0];
  RB::Path::ClipStroke::Subpath::add_cubeto(this, *((__n128 *)a2 + 1), *((__n128 *)a2 + 2), *((__n128 *)a2 + 3), a3);
  return v14;
}

BOOL RB::Path::ClipStroke::value_clipped(RB::Path::ClipStroke *this, float a2)
{
  if (*((_DWORD *)this + 4))
  {
    if (a2 < 1.0 || (*((_DWORD *)this + 4) & 4) == 0) {
      return fmaxf(*((float *)this + 5), 0.0) >= a2;
    }
  }
  else if (a2 > 0.0 || (*((_DWORD *)this + 4) & 4) == 0)
  {
    return fminf(*((float *)this + 5), 1.0) <= a2;
  }
  return 0;
}

void RB::Path::ClipStroke::moveto(RB::Path::ClipStroke *this, uint64_t a2, __n128 a3)
{
  if (*((float *)this + 5) == (float)((*((_DWORD *)this + 4) & 1) == 0))
  {
    uint64_t v4 = *(void (**)(void))(**((void **)this + 1) + 16);
    v4();
  }
  else
  {
    if (*((void *)this + 44))
    {
      __n128 v5 = a3;
      RB::Path::ClipStroke::closepath(this, a2);
      a3 = v5;
    }
    *((__n128 *)this + 4) = a3;
    *((void *)this + 10) = 0;
    *((void *)this + 44) = 0;
  }
}

void RB::Path::ClipStroke::closepath(RB::Path::ClipStroke *this, uint64_t a2)
{
  uint64_t v221 = *MEMORY[0x263EF8340];
  if (*((float *)this + 5) == (float)((*((_DWORD *)this + 4) & 1) == 0))
  {
    unint64_t v3 = *(void (**)(void))(**((void **)this + 1) + 8);
    v3();
    return;
  }
  uint64_t v4 = *((void *)this + 44);
  if (!v4)
  {
    ++*((void *)this + 7);
    return;
  }
  __n128 v5 = (long long *)((char *)this + 64);
  __n128 v6 = (char *)this + 88;
  if (*((void *)this + 43)) {
    __n128 v6 = (char *)*((void *)this + 43);
  }
  float64x2_t v7 = &v6[8 * v4];
  v8.n128_u64[0] = *((void *)this + 8);
  if (v8.n128_f64[0] == *((double *)v7 - 2))
  {
    double v9 = *((double *)this + 9);
    if (v9 == *((double *)v7 - 1)) {
      goto LABEL_12;
    }
  }
  else
  {
    double v9 = *((double *)this + 9);
  }
  v8.n128_f64[1] = v9;
  RB::Path::ClipStroke::Subpath::add_lineto((uint64_t)this + 64, v8, INFINITY);
LABEL_12:
  int v10 = 0;
  uint64_t v11 = *((void *)this + 6);
  uint64_t v12 = *((void *)this + 4);
  while (1)
  {
    unint64_t v13 = v11 + v10;
    if (v13 >= *((void *)this + 5)) {
      break;
    }
    float v14 = floorf(*(float *)(v12 + 16 * v13 + 8));
    float v15 = (float)*((unint64_t *)this + 7);
    if (v14 >= v15)
    {
      int v16 = v10;
    }
    else
    {
      ++v11;
      int v16 = 0;
    }
    int v10 = v16 + 1;
    if (v14 > v15)
    {
      uint64_t v17 = v16;
      int v10 = v16;
      unint64_t v13 = v11 + v16;
      goto LABEL_21;
    }
  }
  uint64_t v17 = v10;
LABEL_21:
  double v18 = (float *)(v12 + 16 * v11);
  *((void *)this + 6) = v13;
  if (*((unsigned char *)this + 16)) {
    int v19 = 1;
  }
  else {
    int v19 = -1;
  }
  if (v10)
  {
    char v20 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    float v23 = (float)v19;
    double v24 = v18 + 1;
    float v25 = INFINITY;
    do
    {
      int v26 = *((_DWORD *)v24 - 1);
      if ((v26 & 2) != 0 && (float)(*v24 * v23) < v25)
      {
        float v25 = *v24 * v23;
        uint64_t v21 = v22;
      }
      v24 += 4;
      v20 |= v26;
      ++v22;
    }
    while (v17 != v22);
  }
  else
  {
    uint64_t v21 = 0;
    char v20 = 0;
    float v25 = INFINITY;
  }
  if ((LODWORD(v25) & 0x7FFFFFFFu) >= 0x7F800000)
  {
    *(double *)&uint32x2_t v36 = 0.0;
  }
  else
  {
    uint64_t v27 = &v18[4 * v21];
    float v29 = v27[2];
    float v28 = v27[3];
    if (v28 >= v29) {
      float v30 = v27[2];
    }
    else {
      float v30 = v27[3];
    }
    if (v29 < v28) {
      float v29 = v27[3];
    }
    if (v10)
    {
      float32x2_t v31 = (float *)(v12 + 16 * v11 + 12);
      uint64_t v32 = v17;
      do
      {
        if (v21)
        {
          float v33 = *(v31 - 1);
          BOOL v34 = v30 > v33 || v29 <= v33;
          if (!v34) {
            break;
          }
          if (v30 <= *v31 && v29 > *v31) {
            break;
          }
        }
        --v21;
        v31 += 4;
        --v32;
      }
      while (v32);
    }
    float v37 = MEMORY[0x270FA5388](this, a2).n128_f32[0];
    *(double *)&uint32x2_t v36 = COERCE_DOUBLE(v147);
    memset(v147, 0, sizeof(v147));
    uint64_t v148 = 0;
    uint64_t v149 = 32;
    RB::Path::ClipStroke::Subpath::append_logical_range(v147, (RB::Path::ClipStroke *)((char *)this + 64), (v37 - floor(v37)) * v38, (v39 - floor(v39)) * v38, 0);
  }
  v191 = 0;
  uint64_t v192 = 0;
  uint64_t v193 = 0;
  if (v20)
  {
    uint64_t v159 = v36;
    v218 = 0;
    double v199 = 0.0;
    __n128 v198 = 0uLL;
    uint64_t v219 = 0;
    uint64_t v220 = 32;
    uint64_t v196 = 0;
    v195 = 0;
    uint64_t v197 = 4;
    unint64_t v188 = 0;
    unint64_t v189 = 0;
    unint64_t v190 = 0;
    unint64_t v185 = 0;
    uint64_t v186 = 0;
    uint64_t v187 = 0;
    if (v17)
    {
      unint64_t v40 = 0;
      v160 = 0;
      uint64_t v156 = 0;
      unint64_t v157 = 0;
      uint64_t v154 = v179;
      uint64_t v155 = v172;
      uint64_t v152 = &v173;
      unint64_t v153 = v181;
      v151 = &v175;
      int64x2_t v150 = vdupq_n_s64(0x7FF0000000000000uLL);
      unint64_t v41 = v17;
      do
      {
        int v42 = &v18[4 * v40];
        if ((*(unsigned char *)v42 & 1) != 0
          && !RB::Path::ClipStroke::value_clipped(this, *(v42 - 3))
          && RB::Path::ClipStroke::value_clipped(this, v42[5]))
        {
          uint64_t v43 = 0;
          float v44 = &v18[4 * v40];
          double v45 = INFINITY;
          float v46 = v44[3] - v44[2];
          double v47 = 0.0;
          if (v46 >= -0.5) {
            double v48 = 0.0;
          }
          else {
            double v48 = 1.0;
          }
          BOOL v34 = v46 <= 0.5;
          double v49 = v46;
          if (!v34) {
            double v48 = -1.0;
          }
          double v50 = v48 + v49;
          BOOL v51 = v50 < 0.0;
          if (v50 >= 0.0) {
            float v52 = v44[3];
          }
          else {
            float v52 = v44[2];
          }
          if (v51) {
            float v53 = v44[3];
          }
          else {
            float v53 = v44[2];
          }
          double v54 = INFINITY;
          double v55 = 0.0;
          do
          {
            if (v40 != v43)
            {
              float32x2_t v56 = &v18[4 * v43];
              float32x2_t v57 = v56 + 2;
              float32x2_t v58 = v56 + 3;
              char v59 = 1;
              do
              {
                int v60 = v59 & 1;
                char v59 = 0;
                if (v60) {
                  uint32x2_t v61 = v57;
                }
                else {
                  uint32x2_t v61 = v58;
                }
                float v62 = *v61;
                if (v60) {
                  uint32x2_t v63 = v58;
                }
                else {
                  uint32x2_t v63 = v57;
                }
                if ((float)(v53 - v62) >= -0.5) {
                  double v64 = 0.0;
                }
                else {
                  double v64 = 1.0;
                }
                if ((float)(v53 - v62) <= 0.5) {
                  double v65 = v64;
                }
                else {
                  double v65 = -1.0;
                }
                double v66 = v65 + (float)(v53 - v62);
                float v67 = v62 - v52;
                double v68 = v67;
                if (v67 >= -0.5) {
                  double v69 = 0.0;
                }
                else {
                  double v69 = 1.0;
                }
                if (v67 <= 0.5) {
                  double v70 = v69;
                }
                else {
                  double v70 = -1.0;
                }
                double v71 = v70 + v68;
                if (v66 >= 0.0 && v66 < v54)
                {
                  double v55 = *v63;
                  double v54 = v66;
                }
                if (v71 >= 0.0 && v71 < v45)
                {
                  double v47 = *v63;
                  double v45 = v71;
                }
              }
              while (v60);
            }
            ++v43;
          }
          while (v43 != v41);
          if ((*(void *)&v54 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000
            && (*(void *)&v45 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
          {
            double v72 = *((double *)this + 10);
            uint64_t v219 = 0;
            double v199 = 0.0;
            __n128 v198 = 0uLL;
            uint64_t v196 = 0;
            double v165 = v72;
            v158 = (const RB::Path::ClipStroke::Subpath *)v5;
            RB::Path::ClipStroke::Subpath::append_range(&v198, (const RB::Path::ClipStroke::Subpath *)v5, v72 * (v55 - floor(v55)), v72 * (v52 - floor(v52)), (RB::Path::ClipStroke::DistanceMap *)v194);
            RB::Path::ClipStroke::Subpath::close((RB::Path::ClipStroke::Subpath *)&v198, v73);
            uint64_t v74 = 0;
            uint64_t v75 = 0;
            unint64_t v189 = 0;
            long long v76 = (char *)(v18 + 2);
            uint64_t v77 = v18 + 2;
            double v164 = 1.0 / v199;
            do
            {
              unsigned int v78 = *((_DWORD *)v77 - 2);
              *(float *)&double v162 = *(v77 - 1);
              float v79 = *v77;
              float v163 = v77[1];
              if (v40 == v75) {
                unsigned int v80 = v78 & 0xFFFFFFFE;
              }
              else {
                unsigned int v80 = v78;
              }
              double v81 = v165;
              double v82 = RB::Path::ClipStroke::DistanceMap::operator()((uint64_t)v194, (v79 - floor(v79)) * v165);
              *(float *)&double v82 = v82 * v164;
              int v161 = LODWORD(v82);
              int v83 = LODWORD(v82);
              double v84 = RB::Path::ClipStroke::DistanceMap::operator()((uint64_t)v194, (v163 - floor(v163)) * v81);
              float v85 = v84 * v164;
              if ((v83 & 0x7FFFFFFFu) <= 0x7F7FFFFF && COERCE_UNSIGNED_INT(fabs(v84 * v164)) <= 0x7F7FFFFF)
              {
                unint64_t v87 = v74 + 1;
                if (v190 < v74 + 1)
                {
                  RB::vector<RB::Fill::Gradient::Stop,0ul,unsigned long>::reserve_slow((uint64_t)&v188, v87);
                  uint64_t v74 = v189;
                  unint64_t v87 = v189 + 1;
                }
                float32x2_t v88 = (char *)&v188[4 * v74];
                *(_DWORD *)float32x2_t v88 = v80;
                int v89 = v161;
                *((_DWORD *)v88 + 1) = LODWORD(v162);
                *((_DWORD *)v88 + 2) = v89;
                *((float *)v88 + 3) = v85;
                unint64_t v189 = v87;
                uint64_t v74 = v87;
              }
              ++v75;
              v77 += 4;
            }
            while (v41 != v75);
            double v184 = 0.0;
            if (RB::Path::ClipStroke::make_keyframes((uint64_t)this, (uint64_t)v188, v74, (uint64_t)&v198, (unint64_t *)&v185, &v184))
            {
              uint64_t v90 = v185;
              uint64_t v91 = v186;
              double v166 = *(double *)&this;
              uint64_t v167 = &v198;
              v168 = v159;
              uint64_t v169 = v185;
              uint64_t v170 = v186;
              double v171 = v184;
              int v92 = v155;
              *uint64_t v155 = 0;
              v92[1] = 0;
              int64x2_t v93 = v150;
              int64x2_t v178 = v150;
              int v94 = v154;
              void *v154 = 0;
              v94[1] = 0;
              int64x2_t v180 = v93;
              char v95 = v153;
              *unint64_t v153 = 0;
              v95[1] = 0;
              char v183 = 0;
              __int16 v96 = &v90[3 * v91];
              long long v97 = *(_OWORD *)(v96 - 3);
              uint64_t v98 = v152;
              *((void *)v152 + 2) = *(v96 - 1);
              *uint64_t v98 = v97;
              *(double *)&long long v173 = *(double *)&v173 - v199;
              *(double *)&long long v97 = *(double *)&v173;
              long long v99 = *(_OWORD *)v90;
              uint64_t v100 = v151;
              *((void *)v151 + 2) = v90[2];
              *uint64_t v100 = v99;
              v172[0] = 1;
              *(float *)&long long v97 = *(double *)&v97 / (*(double *)&v175 - *(double *)&v97);
              float v177 = *((float *)&v173 + 2)
                   + (float)((float)(*((float *)&v173 + 2) - *((float *)&v175 + 2)) * *(float *)&v97);
              BOOL v182 = RB::Path::ClipStroke::value_clipped(this, v177);
              RB::Path::ClipStroke::Clipper::run((RB::Path::ClipStroke::Clipper *)&v166, v101, v102, v103, v104, v105, v106, v107);
            }
            else
            {
              RB::Path::ClipStroke::Subpath::replay((uint64_t)&v198, *((uint64_t **)this + 1), 1, 0);
            }
            uint64_t v219 = 0;
            double v199 = 0.0;
            __n128 v198 = 0uLL;
            uint64_t v196 = 0;
            RB::Path::ClipStroke::Subpath::append_range(&v198, v158, v165 * (v53 - floor(v53)), v165 * (v47 - floor(v47)), (RB::Path::ClipStroke::DistanceMap *)v194);
            RB::Path::ClipStroke::Subpath::close((RB::Path::ClipStroke::Subpath *)&v198, v108);
            uint64_t v17 = 0;
            unint64_t v189 = 0;
            double v162 = 1.0 / v199;
            do
            {
              unsigned int v109 = *((_DWORD *)v76 - 2);
              float v110 = *(float *)v76;
              int v111 = *((_DWORD *)v76 + 1);
              float v163 = *((float *)v76 - 1);
              LODWORD(v164) = v111;
              if (v40) {
                unsigned int v112 = v109;
              }
              else {
                unsigned int v112 = v109 & 0xFFFFFFFE;
              }
              double v113 = v165;
              double v114 = RB::Path::ClipStroke::DistanceMap::operator()((uint64_t)v194, (v110 - floor(v110)) * v165);
              double v115 = v162;
              float v116 = v114 * v162;
              float v117 = RB::Path::ClipStroke::DistanceMap::operator()((uint64_t)v194, (*(float *)&v164 - floor(*(float *)&v164)) * v113)* v115;
              if ((LODWORD(v116) & 0x7FFFFFFFu) <= 0x7F7FFFFF && (LODWORD(v117) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
              {
                float v119 = v163;
                unint64_t v120 = v17 + 1;
                if (v190 < v17 + 1)
                {
                  RB::vector<RB::Fill::Gradient::Stop,0ul,unsigned long>::reserve_slow((uint64_t)&v188, v120);
                  uint64_t v17 = v189;
                  unint64_t v120 = v189 + 1;
                }
                float32x2_t v121 = &v188[4 * v17];
                *(_DWORD *)float32x2_t v121 = v112;
                v121[1] = v119;
                v121[2] = v116;
                v121[3] = v117;
                unint64_t v189 = v120;
                uint64_t v17 = v120;
              }
              --v40;
              v76 += 16;
              --v41;
            }
            while (v41);
            double v18 = v188;
            unint64_t v122 = v190;
            unint64_t v188 = v160;
            unint64_t v189 = v156;
            __n128 v5 = (long long *)v158;
            unint64_t v190 = v157;
            std::swap[abi:nn180100]<RB::Path::ClipStroke::Subpath>((long long *)v158, (long long *)&v198);
            unint64_t v40 = 0;
            unint64_t v41 = v17;
            uint64_t v156 = v17;
            unint64_t v157 = v122;
            v160 = v18;
          }
        }
        ++v40;
      }
      while (v40 < v41);
    }
    else
    {
      v160 = 0;
    }
    double v184 = 0.0;
    if (RB::Path::ClipStroke::make_keyframes((uint64_t)this, (uint64_t)v18, v17, (uint64_t)v5, (unint64_t *)&v185, &v184))
    {
      double v166 = *(double *)&this;
      uint64_t v167 = (__n128 *)v5;
      uint32x2_t v36 = v159;
      v168 = v159;
      uint64_t v169 = v185;
      uint64_t v170 = v186;
      double v171 = v184;
      v172[1] = 0;
      int64x2_t v178 = vdupq_n_s64(0x7FF0000000000000uLL);
      v179[0] = 0;
      v179[1] = 0;
      int64x2_t v180 = v178;
      v181[0] = 0;
      v181[1] = 0;
      char v183 = 0;
      float32x2_t v134 = (char *)&v185[3 * v186];
      uint64_t v135 = *((void *)v134 - 1);
      long long v173 = *(_OWORD *)(v134 - 24);
      uint64_t v174 = v135;
      *(double *)&long long v173 = *(double *)&v173 - *((double *)this + 10);
      uint64_t v136 = v185[2];
      long long v175 = *(_OWORD *)v185;
      uint64_t v176 = v136;
      v172[0] = 1;
      float v137 = *(double *)&v173 / (*(double *)&v175 - *(double *)&v173);
      float v177 = *((float *)&v173 + 2) + (float)((float)(*((float *)&v173 + 2) - *((float *)&v175 + 2)) * v137);
      BOOL v182 = RB::Path::ClipStroke::value_clipped(this, v177);
      RB::Path::ClipStroke::Clipper::run((RB::Path::ClipStroke::Clipper *)&v166, v138, v139, v140, v141, v142, v143, v144);
    }
    else
    {
      RB::Path::ClipStroke::Subpath::replay((uint64_t)v5, *((uint64_t **)this + 1), 1, 0);
      uint32x2_t v36 = v159;
    }
    float v145 = v160;
    if (v185) {
      free(v185);
    }
    if (v145) {
      free(v145);
    }
    if (v188) {
      free(v188);
    }
    if (v195) {
      free(v195);
    }
    if (v218) {
      free(v218);
    }
  }
  else
  {
    double v166 = 0.0;
    if (RB::Path::ClipStroke::make_keyframes((uint64_t)this, (uint64_t)v18, v17, (uint64_t)this + 64, (unint64_t *)&v191, &v166))
    {
      v198.n128_u64[0] = (unint64_t)this;
      v198.n128_u64[1] = (unint64_t)this + 64;
      double v199 = *(double *)&v36;
      v200 = v191;
      uint64_t v201 = v192;
      double v202 = v166;
      int64x2_t v210 = vdupq_n_s64(0x7FF0000000000000uLL);
      uint64_t v204 = 0;
      uint64_t v211 = 0;
      int64x2_t v213 = v210;
      uint64_t v215 = 0;
      uint64_t v212 = 0;
      uint64_t v214 = 0;
      char v217 = 0;
      float32x2_t v123 = (char *)&v191[3 * v192];
      uint64_t v124 = *((void *)v123 - 1);
      long long v205 = *(_OWORD *)(v123 - 24);
      uint64_t v206 = v124;
      *(double *)&long long v205 = *(double *)&v205 - *((double *)this + 10);
      uint64_t v125 = v191[2];
      long long v207 = *(_OWORD *)v191;
      uint64_t v208 = v125;
      uint64_t v203 = 1;
      float v126 = *(double *)&v205 / (*(double *)&v207 - *(double *)&v205);
      float v209 = *((float *)&v205 + 2) + (float)((float)(*((float *)&v205 + 2) - *((float *)&v207 + 2)) * v126);
      BOOL v216 = RB::Path::ClipStroke::value_clipped(this, v209);
      RB::Path::ClipStroke::Clipper::run((RB::Path::ClipStroke::Clipper *)&v198, v127, v128, v129, v130, v131, v132, v133);
    }
    else
    {
      RB::Path::ClipStroke::Subpath::replay((uint64_t)this + 64, *((uint64_t **)this + 1), 1, 0);
    }
  }
  *((void *)this + 44) = 0;
  *((void *)v5 + 1) = 0;
  *((void *)v5 + 2) = 0;
  *(void *)__n128 v5 = 0;
  ++*((void *)this + 7);
  if (v191) {
    free(v191);
  }
  if (*(double *)&v36 != 0.0)
  {
    uint64_t v146 = (void *)v36[17].n128_u64[1];
    if (v146) {
      free(v146);
    }
  }
}

double RB::Path::ClipStroke::lineto(uint64_t a1, __n128 a2)
{
  if (*(float *)(a1 + 20) != (float)((*(_DWORD *)(a1 + 16) & 1) == 0)) {
    return RB::Path::ClipStroke::Subpath::add_lineto(a1 + 64, a2, INFINITY);
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 24))();
  return result;
}

double RB::Path::ClipStroke::quadto(uint64_t a1, __n128 a2, __n128 a3)
{
  if (*(float *)(a1 + 20) != (float)((*(_DWORD *)(a1 + 16) & 1) == 0)) {
    return RB::Path::ClipStroke::Subpath::add_quadto((__n128 *)(a1 + 64), a2, a3, INFINITY);
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 32))();
  return result;
}

double RB::Path::ClipStroke::cubeto(uint64_t a1, __n128 a2, __n128 a3, __n128 a4)
{
  if (*(float *)(a1 + 20) != (float)((*(_DWORD *)(a1 + 16) & 1) == 0)) {
    return RB::Path::ClipStroke::Subpath::add_cubeto((__n128 *)(a1 + 64), a2, a3, a4, INFINITY);
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 40))();
  return result;
}

BOOL RB::Path::ClipStroke::make_keyframes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5, double *a6)
{
  unint64_t v7 = 2 * a3;
  if (!(2 * a3)) {
    return 0;
  }
  a5[1] = 0;
  if (a5[2] < v7) {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)a5, v7);
  }
  unint64_t v13 = a5[1];
  if (a3)
  {
    uint64_t v14 = 0;
    float v15 = (float *)(a2 + 8);
    float v16 = -INFINITY;
    float v17 = INFINITY;
    do
    {
      int v18 = *((_DWORD *)v15 - 1);
      float v19 = *v15;
      double v20 = *(double *)(a4 + 16);
      int v21 = *((_DWORD *)v15 - 2);
      unint64_t v22 = v13 + 1;
      unint64_t v23 = a5[2];
      if (v23 < v13 + 1)
      {
        RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)a5, v22);
        unint64_t v13 = a5[1];
        unint64_t v23 = a5[2];
        unint64_t v22 = v13 + 1;
      }
      unint64_t v24 = *a5;
      uint64_t v25 = *a5 + 24 * v13;
      *(double *)uint64_t v25 = v20 * (float)(v19 - floorf(v19));
      *(_DWORD *)(v25 + 8) = v18;
      *(_DWORD *)(v25 + 12) = v14;
      *(_DWORD *)(v25 + 16) = v21;
      a5[1] = v22;
      float v26 = v15[1];
      double v27 = *(double *)(a4 + 16);
      int v28 = *((_DWORD *)v15 - 1);
      int v29 = *((_DWORD *)v15 - 2);
      unint64_t v30 = v13 + 2;
      if (v23 < v30)
      {
        RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)a5, v30);
        unint64_t v24 = *a5;
        unint64_t v22 = a5[1];
      }
      unint64_t v31 = v24 + 24 * v22;
      *(double *)unint64_t v31 = v27 * (float)(v26 - floorf(v26));
      *(_DWORD *)(v31 + 8) = v28;
      *(_DWORD *)(v31 + 12) = v14;
      *(_DWORD *)(v31 + 16) = v29;
      unint64_t v13 = v22 + 1;
      a5[1] = v22 + 1;
      float v32 = *(v15 - 1);
      if (v32 < v17) {
        float v17 = *(v15 - 1);
      }
      if (v16 < v32) {
        float v16 = *(v15 - 1);
      }
      ++v14;
      v15 += 4;
    }
    while (a3 != v14);
  }
  else
  {
    unint64_t v24 = *a5;
    float v17 = INFINITY;
    float v16 = -INFINITY;
  }
  unint64_t v34 = 126 - 2 * __clz(v13);
  if (v13) {
    uint64_t v35 = v34;
  }
  else {
    uint64_t v35 = 0;
  }
  std::__introsort<std::_ClassicAlgPolicy,RB::Path::ClipStroke::make_keyframes(std::span<RB::Path::ClipStroke::Keyframe const,18446744073709551615ul>,RB::Path::ClipStroke::Subpath const&,RB::vector<RB::Path::ClipStroke::SingleKeyframe,0ul,unsigned long> &,double &)::$_0 &,RB::Path::ClipStroke::SingleKeyframe*,false>(v24, v24 + 24 * v13, v35, 1);
  unint64_t v36 = a5[1];
  if (v36 <= 1)
  {
    *a6 = 0.0;
  }
  else
  {
    float v37 = *(float *)(*a5 + 8);
    double v38 = (float *)(*a5 + 32);
    double v39 = 0.0;
    float v40 = 0.0;
    for (uint64_t i = 1; i != v36; ++i)
    {
      float v42 = *v38;
      if (vabds_f32(v37, *v38) >= 0.0001)
      {
        double v39 = *((double *)v38 - 1) + v39 - *((double *)v38 - 4);
        float v40 = vabds_f32(v42, v37) + v40;
      }
      v38 += 6;
      float v37 = v42;
    }
    double v43 = 0.0;
    if (v40 > 0.0)
    {
      float v44 = v40;
      float32x2_t v45 = vrecpe_f32((float32x2_t)LODWORD(v40));
      float32x2_t v46 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v44), v45), v45);
      double v43 = v39 * vmul_f32(v46, vrecps_f32((float32x2_t)LODWORD(v44), v46)).f32[0];
    }
    *a6 = v43;
    unint64_t v47 = v36 - 2;
    if (v36 != 2)
    {
      double v48 = (float *)(*a5 + 32);
      float v49 = *v48;
      float v50 = *(float *)(*a5 + 8);
      do
      {
        float v51 = v50;
        float v50 = v49;
        float v49 = v48[6];
        if (v50 > v17 && v50 < v16)
        {
          if (v50 >= v51) {
            float v53 = v51;
          }
          else {
            float v53 = v50;
          }
          if (v49 < v53) {
            float v53 = v48[6];
          }
          if (v51 < v50) {
            float v51 = v50;
          }
          float v54 = *(float *)(a1 + 20);
          if (v51 < v49) {
            float v51 = v48[6];
          }
          if (v53 > v54 || v51 < v54) {
            float *v48 = INFINITY;
          }
        }
        v48 += 6;
        --v47;
      }
      while (v47);
    }
  }
  return v36 != 0;
}

void RB::Path::ClipStroke::Clipper::run(RB::Path::ClipStroke::Clipper *this, double a2, double a3, double a4, double a5, double a6, double a7, float64x2_t a8)
{
  double v9 = *((double *)this + 11);
  double v10 = *((double *)this + 8);
  if (v9 > v10)
  {
    float v11 = *(float *)(*(void *)this + 20);
    if (*(_DWORD *)(*(void *)this + 16))
    {
      LODWORD(a3) = 1.0;
      if (v11 <= 1.0) {
        goto LABEL_8;
      }
    }
    else if (v11 >= 0.0)
    {
      goto LABEL_8;
    }
    if ((*(_DWORD *)(*(void *)this + 16) & 6) == 4
      && (RB::Path::ClipStroke::Clipper::emit_undershoot(this) & 1) != 0)
    {
      return;
    }
  }
LABEL_8:
  uint64_t v12 = *((void *)this + 1);
  float64x2_t v13 = *(float64x2_t *)v12;
  *(_OWORD *)&v31[0].v = *(_OWORD *)v12;
  if (*(uint64_t *)(v12 + 288) >= 1)
  {
    if (*(void *)(v12 + 280)) {
      unint64_t v14 = *(void *)(v12 + 280);
    }
    else {
      unint64_t v14 = v12 + 24;
    }
    do
    {
      v13.f64[0] = *(float64_t *)v14;
      int v15 = (int)*(double *)v14;
      switch(v15)
      {
        case 4:
          long long v19 = *(_OWORD *)(v14 + 16);
          *(_OWORD *)&v29[0].v = *(_OWORD *)(v14 + 32);
          *(_OWORD *)&v30[0].v = v19;
          *(_OWORD *)&v27[0].v = *(_OWORD *)(v14 + 48);
          CG::Cubic::Cubic((CG::Cubic *)v26, v31, v30, v29, v27);
          if (v9 > v10)
          {
            double v21 = *(double *)(v14 + 8);
            __n128 v36 = v26[4];
            __n128 v37 = v26[5];
            __n128 v38 = v26[6];
            float64x2_t v32 = (float64x2_t)v26[0];
            __n128 v33 = v26[1];
            __n128 v34 = v26[2];
            __n128 v35 = v26[3];
            RB::Path::ClipStroke::Clipper::split_segment<CG::Cubic>((uint64_t)this, &v32, v21);
          }
          else
          {
            RB::Path::ClipStroke::Clipper::emit_segment<CG::Cubic>((uint64_t)this, v26);
          }
          float64x2_t v13 = *(float64x2_t *)&v27[0].v;
          *(_OWORD *)&v31[0].v = *(_OWORD *)&v27[0].v;
          v14 += 64;
          break;
        case 3:
          long long v20 = *(_OWORD *)(v14 + 16);
          *(_OWORD *)&v29[0].v = *(_OWORD *)(v14 + 32);
          *(_OWORD *)&v30[0].v = v20;
          CG::Quadratic::Quadratic((CG::Quadratic *)v28, v31, v30, v29);
          if (v9 > v10)
          {
            double v22 = *(double *)(v14 + 8);
            __n128 v34 = (__n128)v28[2];
            __n128 v35 = (__n128)v28[3];
            __n128 v36 = (__n128)v28[4];
            float64x2_t v32 = v28[0];
            __n128 v33 = (__n128)v28[1];
            RB::Path::ClipStroke::Clipper::split_segment<CG::Quadratic>((uint64_t)this, &v32, v22);
          }
          else
          {
            RB::Path::ClipStroke::Clipper::emit_segment<CG::Quadratic>((__n128 *)this, v28);
          }
          float64x2_t v13 = *(float64x2_t *)&v29[0].v;
          *(_OWORD *)&v31[0].v = *(_OWORD *)&v29[0].v;
          v14 += 48;
          break;
        case 2:
          float64_t v17 = *(double *)(v14 + 16);
          float64_t v16 = *(double *)(v14 + 24);
          double v18 = *(double *)(v14 + 8);
          float64x2_t v32 = *(float64x2_t *)&v31[0].v;
          v33.n128_f64[0] = v17;
          v33.n128_f64[1] = v16;
          if (v9 > v10) {
            RB::Path::ClipStroke::Clipper::split_segment<CG::LineSegment>((uint64_t)this, *(float64_t *)&v31[0].v, *(float64_t *)&v31[2].v, v17, v16, v18);
          }
          else {
            RB::Path::ClipStroke::Clipper::emit_segment<CG::LineSegment>(this, &v32);
          }
          *(float64_t *)&v31[0].v = v17;
          *(float64_t *)&v31[2].v = v16;
          v14 += 32;
          break;
      }
      uint64_t v23 = *(void *)(v12 + 280);
      if (!v23) {
        uint64_t v23 = v12 + 24;
      }
    }
    while (v14 < v23 + 8 * *(void *)(v12 + 288));
  }
  if (*((unsigned char *)this + 205))
  {
    if (*((unsigned char *)this + 204))
    {
      *((unsigned char *)this + 204) = 1;
    }
    else
    {
      BOOL v24 = RB::Path::ClipStroke::value_clipped(*(RB::Path::ClipStroke **)this, *((float *)this + 50));
      *((unsigned char *)this + 204) = v24;
      if (!v24)
      {
LABEL_37:
        (*(void (**)(void, float64x2_t *, float64x2_t))(**(void **)(*(void *)this + 8) + 8))(*(void *)(*(void *)this + 8), v25, v13);
        return;
      }
    }
    uint64_t v25 = (float64x2_t *)((char *)this + 160);
    if ((*((void *)this + 20) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
      && (*((void *)this + 21) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      *((_DWORD *)this + 28) = *((_DWORD *)this + 50);
      float64x2_t v13 = RB::Path::ClipStroke::Clipper::emit_cap((uint64_t *)this, v25, (float64x2_t *)this + 11, *((float64_t *)this + 24), a3, a4, a5, a6, a7, a8);
    }
    goto LABEL_37;
  }
}

void std::swap[abi:nn180100]<RB::Path::ClipStroke::Subpath>(long long *a1, long long *a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  long long v10 = *a1;
  uint64_t v4 = *((void *)a1 + 2);
  uint64_t v5 = (uint64_t)a1 + 24;
  *(_OWORD *)float64x2_t v13 = *(long long *)((char *)a1 + 280);
  *((void *)a1 + 35) = 0;
  uint64_t v11 = v4;
  *(void *)&unsigned char v13[16] = *((void *)a1 + 37);
  a1[18] = xmmword_21421C540;
  RB::vector<double,32ul,unsigned long>::swap_inline(v12, (long long *)((char *)a1 + 24));
  *a1 = *a2;
  *((void *)a1 + 2) = *((void *)a2 + 2);
  *((void *)a1 + 36) = 0;
  uint64_t v6 = *(void *)(v5 + 256);
  *(void *)(v5 + 256) = *((void *)a2 + 35);
  *((void *)a2 + 35) = v6;
  *((void *)a1 + 36) = *((void *)a2 + 36);
  *((void *)a2 + 36) = 0;
  uint64_t v7 = *((void *)a1 + 37);
  *((void *)a1 + 37) = *((void *)a2 + 37);
  *((void *)a2 + 37) = v7;
  RB::vector<double,32ul,unsigned long>::swap_inline((long long *)v5, (long long *)((char *)a2 + 24));
  *a2 = v10;
  *((void *)a2 + 2) = v11;
  uint64_t v8 = *((void *)a2 + 35);
  *((void *)a2 + 35) = *(void *)v13;
  *(void *)float64x2_t v13 = v8;
  uint64_t v9 = *((void *)a2 + 37);
  a2[18] = *(_OWORD *)&v13[8];
  *(void *)&unsigned char v13[8] = 0;
  *(void *)&unsigned char v13[16] = v9;
  RB::vector<double,32ul,unsigned long>::swap_inline((long long *)((char *)a2 + 24), v12);
  if (*(void *)v13) {
    free(*(void **)v13);
  }
}

double RB::Path::ClipStroke::Clipper::advance_keyframes(RB::Path::ClipStroke::Clipper *this, __n128 a2)
{
  uint64_t v2 = (_OWORD *)((char *)this + 88);
  double v3 = *((double *)this + 11);
  if (v3 <= a2.n128_f64[0])
  {
    unint64_t v4 = *((void *)this + 4);
    unint64_t v5 = *((void *)this + 6);
    if (v4 <= v5) {
      unint64_t v4 = *((void *)this + 6);
    }
    uint64_t v6 = 24 * v5;
    do
    {
      if (v4 == v5) {
        break;
      }
      uint64_t v7 = *((void *)this + 3) + v6;
      double v8 = *(double *)v7;
      int v9 = *(_DWORD *)(v7 + 8);
      uint64_t v14 = *(void *)(v7 + 12);
      int v15 = *(_DWORD *)(v7 + 20);
      if (*(double *)v7 < v3) {
        break;
      }
      *((void *)this + 6) = ++v5;
      if ((v9 & 0x7FFFFFFFu) <= 0x7F7FFFFF)
      {
        *((_OWORD *)this + 4) = *v2;
        *((void *)this + 10) = *((void *)this + 13);
        *((double *)this + 11) = v8;
        *((_DWORD *)this + 24) = v9;
        *(void *)((char *)this + 100) = v14;
        *((_DWORD *)this + 27) = v15;
        double v3 = v8;
      }
      v6 += 24;
    }
    while (v3 <= a2.n128_f64[0]);
  }
  if (v3 <= a2.n128_f64[0])
  {
    uint64_t v10 = *((void *)this + 6);
    if (v10 == *((void *)this + 4))
    {
      a2 = *(__n128 *)v2;
      *((_OWORD *)this + 4) = *v2;
      *((void *)this + 10) = *((void *)this + 13);
      if (v10)
      {
        uint64_t v11 = *((void *)this + 3);
        uint64_t v12 = *(void *)(v11 + 16);
        *uint64_t v2 = *(_OWORD *)v11;
        *((void *)this + 13) = v12;
        a2.n128_f64[0] = *((double *)this + 11) + *(double *)(*((void *)this + 1) + 16);
        *((void *)this + 11) = a2.n128_u64[0];
        *((void *)this + 6) = v10 + 1;
      }
    }
  }
  return a2.n128_f64[0];
}

float64x2_t RB::Path::ClipStroke::Clipper::emit_cap(uint64_t *a1, float64x2_t *a2, float64x2_t *a3, float64_t a4, double a5, double a6, double a7, double a8, double a9, float64x2_t a10)
{
  a10.f64[0] = a4;
  if (!*((unsigned char *)a1 + 205))
  {
    *((float64x2_t *)a1 + 10) = *a2;
    float64x2_t result = *a3;
    *((float64x2_t *)a1 + 11) = *a3;
    a1[24] = *(void *)&a10.f64[0];
    LODWORD(result.f64[0]) = *((_DWORD *)a1 + 28);
    *((_DWORD *)a1 + 50) = LODWORD(result.f64[0]);
    return result;
  }
  uint64_t v13 = *a1;
  int v14 = *(_DWORD *)(*a1 + 16);
  __n128 v15 = *(__n128 *)a2;
  __n128 v76 = (__n128)a10;
  if ((v14 & 8) != 0)
  {
    (*(void (**)(void, __n128))(**(void **)(v13 + 8) + 24))(*(void *)(v13 + 8), v15);
    *(float64x2_t *)(a1 + 15) = *a2;
    *(float64x2_t *)(a1 + 17) = vnegq_f64(*a3);
    float64x2_t result = (float64x2_t)v76;
    a1[19] = v76.n128_u64[0];
    return result;
  }
  float64x2_t v16 = *(float64x2_t *)(a1 + 15);
  float64x2_t v17 = vmulq_n_f64(*(float64x2_t *)(a1 + 17), 1.0 / sqrt(vaddvq_f64(vmulq_f64(*(float64x2_t *)(a1 + 17), *(float64x2_t *)(a1 + 17)))));
  float64x2_t v18 = vmulq_f64(*a3, *a3);
  float64x2_t v19 = vmulq_n_f64(*a3, 1.0 / sqrt(vaddvq_f64(v18)));
  *(void *)&v18.f64[0] = a1[19];
  float64x2_t v20 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s64(vcgtq_f64(v18, a10).i64[0], 0), (int8x16_t)v17, (int8x16_t)v19);
  float64x2_t v21 = vmulq_f64(v20, vsubq_f64((float64x2_t)v15, v16));
  float64x2_t v22 = (float64x2_t)vdupq_laneq_s64((int64x2_t)v21, 1);
  float64x2_t v23 = vaddq_f64(v21, v22);
  v22.f64[0] = 0.0;
  int8x16_t v24 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(v23, v22).i64[0], 0);
  int8x16_t v25 = (int8x16_t)vmulq_n_f64(v20, v23.f64[0]);
  float64x2_t v26 = (float64x2_t)vbslq_s8(v24, v25, (int8x16_t)vdupq_n_s64(0x8000000000000000));
  __n128 v27 = (__n128)vsubq_f64((float64x2_t)v15, (float64x2_t)vbicq_s8(v25, v24));
  __n128 v28 = (__n128)vaddq_f64(v16, v26);
  if ((v14 & 2) == 0)
  {
    float v29 = *((float *)a1 + 28);
    if (v14)
    {
      if (v29 <= 0.0)
      {
        float v30 = *(float *)(v13 + 20);
LABEL_11:
        float v32 = v29 - v30;
        if (v32 > 0.0)
        {
          float64x2_t v33 = vaddq_f64(v19, v17);
          float64x2_t v34 = vmulq_n_f64(v33, *((double *)a1 + 5) * v32 / sqrt(vaddvq_f64(vmulq_f64(v33, v33))));
          __n128 v28 = (__n128)vaddq_f64(v34, (float64x2_t)v28);
          __n128 v27 = (__n128)vaddq_f64(v34, (float64x2_t)v27);
        }
      }
    }
    else if (v29 >= 1.0)
    {
      float v30 = *((float *)a1 + 28);
      float v29 = *(float *)(v13 + 20);
      goto LABEL_11;
    }
  }
  int8x16_t v35 = (int8x16_t)vceqq_f64((float64x2_t)v28, v16);
  int64x2_t v36 = vdupq_laneq_s64((int64x2_t)vmvnq_s8(v35), 1);
  float64x2_t v75 = (float64x2_t)v27;
  if ((vornq_s8((int8x16_t)v36, v35).u64[0] & 0x8000000000000000) != 0)
  {
    float64x2_t v70 = v20;
    __n128 v72 = v28;
    (*(void (**)(void, __n128))(**(void **)(v13 + 8) + 24))(*(void *)(v13 + 8), v28);
    float64x2_t v20 = v70;
    __n128 v28 = v72;
    __n128 v27 = (__n128)v75;
  }
  uint64_t v37 = a1[2];
  if (v37)
  {
    uint64_t v38 = v37 + 24;
    if (*(void *)(v37 + 280)) {
      uint64_t v38 = *(void *)(v37 + 280);
    }
    float64x2_t v39 = *(float64x2_t *)v37;
    float64x2_t v40 = vsubq_f64(*(float64x2_t *)(v38 + 8 * *(void *)(v37 + 288) - 16), *(float64x2_t *)v37);
    float64x2_t v41 = vsubq_f64((float64x2_t)v27, (float64x2_t)v28);
    int64x2_t v42 = (int64x2_t)vmulq_f64(v40, v40);
    int64x2_t v43 = (int64x2_t)vmulq_f64(v41, v41);
    float64x2_t v44 = vsqrtq_f64(vaddq_f64((float64x2_t)vzip1q_s64(v43, v42), (float64x2_t)vzip2q_s64(v43, v42)));
    float64x2_t v45 = (float64x2_t)vdupq_laneq_s64((int64x2_t)v44, 1);
    float64x2_t v46 = vdivq_f64(v40, v45);
    float64x2_t v47 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v44.f64[0], 0);
    float64x2_t v48 = vdivq_f64(v41, v47);
    v44.f64[0] = vdivq_f64(v44, v45).f64[0];
    int64x2_t v49 = (int64x2_t)vmulq_f64(v46, v48);
    v47.f64[0] = -v46.f64[1];
    int64x2_t v50 = (int64x2_t)vmulq_f64((float64x2_t)vzip1q_s64((int64x2_t)v47, (int64x2_t)v46), v48);
    float64x2_t v51 = vaddq_f64((float64x2_t)vzip1q_s64(v49, v50), (float64x2_t)vzip2q_s64(v49, v50));
    *(float64x2_t *)&v78.CGFloat a = vmulq_n_f64(v51, v44.f64[0]);
    v78.c = vmuld_lane_f64(-v44.f64[0], v51, 1);
    v78.d = v78.a;
    *(__n128 *)&v78.tCGFloat x = v28;
    *(_OWORD *)&v77.c = *(_OWORD *)&v78.c;
    *(__n128 *)&v77.tCGFloat x = v28;
    *(_OWORD *)&v77.CGFloat a = *(_OWORD *)&v78.a;
    CGAffineTransformTranslate(&v78, &v77, -v39.f64[0], -v39.f64[1]);
    RB::Path::ClipStroke::Subpath::replay(v37, *(uint64_t **)(*a1 + 8), 0, (float64x2_t *)&v78);
  }
  else
  {
    uint64_t v52 = *a1;
    float64x2_t v53 = vsubq_f64((float64x2_t)v27, (float64x2_t)v28);
    *(double *)v36.i64 = -v53.f64[1];
    float64x2_t v54 = vmulq_f64((float64x2_t)vzip1q_s64(v36, (int64x2_t)v53), v20);
    float64x2_t v55 = (float64x2_t)vdupq_laneq_s64((int64x2_t)v54, 1);
    float64x2_t v56 = vaddq_f64(v54, v55);
    v55.f64[0] = 0.0;
    int8x16_t v57 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(v55, v56).i64[0], 0);
    v55.f64[0] = -v20.f64[1];
    float64x2_t v58 = (float64x2_t)vzip1q_s64((int64x2_t)v55, (int64x2_t)v20);
    v53.f64[0] = sqrt(vaddvq_f64(vmulq_f64(v53, v53))) * 0.5;
    float64x2_t v59 = vmulq_n_f64((float64x2_t)vbslq_s8(v57, (int8x16_t)vnegq_f64(v58), (int8x16_t)v58), v53.f64[0]);
    float64x2_t v60 = vsubq_f64((float64x2_t)v28, v59);
    float64x2_t v61 = vmulq_n_f64(v20, v53.f64[0]);
    float64x2_t v71 = v59;
    __n128 v73 = (__n128)v60;
    switch(*(unsigned char *)(*a1 + 24))
    {
      case 0:
        float64x2_t v62 = (float64x2_t)vdupq_n_s64(0x3FE1AC51114F0EAFuLL);
        float64x2_t v69 = vmulq_f64(v61, v62);
        float64x2_t v66 = vaddq_f64(v60, v61);
        float64x2_t v67 = vmulq_f64(v59, v62);
        (*(void (**)(void, __n128, __n128))(**(void **)(v52 + 8) + 40))(*(void *)(v52 + 8), (__n128)vaddq_f64(v69, (float64x2_t)v28), (__n128)vaddq_f64(v66, v67));
        (*(void (**)(void, __n128, __n128))(**(void **)(*a1 + 8) + 40))(*(void *)(*a1 + 8), (__n128)vsubq_f64(v66, v67), (__n128)vaddq_f64(vsubq_f64((float64x2_t)v73, v71), v69));
        break;
      case 1:
        float64x2_t v68 = v61;
        (*(void (**)(__n128))(**(void **)(v52 + 8) + 24))((__n128)vaddq_f64(v61, (float64x2_t)v28));
        goto LABEL_24;
      case 3:
      case 5:
        (*(void (**)(void, __n128))(**(void **)(v52 + 8) + 24))(*(void *)(v52 + 8), (__n128)vaddq_f64(v60, v61));
        (*(void (**)(__n128))(**(void **)(*a1 + 8) + 24))((__n128)vsubq_f64((float64x2_t)v73, v71));
        break;
      case 4:
      case 6:
        float64x2_t v68 = v61;
        (*(void (**)(void, __n128))(**(void **)(v52 + 8) + 24))(*(void *)(v52 + 8), (__n128)vaddq_f64(v61, (float64x2_t)v28));
        (*(void (**)(__n128))(**(void **)(*a1 + 8) + 24))(v73);
LABEL_24:
        __n128 v74 = (__n128)vsubq_f64((float64x2_t)v73, v71);
        (*(void (**)(void, __n128))(**(void **)(*a1 + 8) + 24))(*(void *)(*a1 + 8), (__n128)vaddq_f64((float64x2_t)v74, v68));
        (*(void (**)(__n128))(**(void **)(*a1 + 8) + 24))(v74);
        break;
      default:
        (*(void (**)(__n128))(**(void **)(v52 + 8) + 24))(v27);
        break;
    }
  }
  int8x16_t v63 = (int8x16_t)vceqq_f64(v75, *a2);
  unint64_t v64 = vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v63), 1), v63).u64[0];
  unint64_t v65 = v76.n128_u64[0];
  if ((v64 & 0x8000000000000000) != 0)
  {
    (*(void (**)(void, __n128, __n128))(**(void **)(*a1 + 8) + 24))(*(void *)(*a1 + 8), *(__n128 *)a2, v76);
    unint64_t v65 = v76.n128_u64[0];
  }
  *(float64x2_t *)(a1 + 15) = *a2;
  float64x2_t result = vnegq_f64(*a3);
  *(float64x2_t *)(a1 + 17) = result;
  a1[19] = v65;
  return result;
}

uint64_t RB::Path::ClipStroke::Clipper::emit_undershoot(RB::Path::ClipStroke::Clipper *this)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 3);
    double v4 = 0.0;
    float v5 = INFINITY;
    uint64_t v6 = *((void *)this + 4);
    double v7 = 0.0;
    do
    {
      float v8 = *(float *)(v3 + 8);
      if (v8 >= v5)
      {
        if (v8 == v5) {
          double v7 = *(double *)v3;
        }
      }
      else
      {
        double v4 = *(double *)v3;
        double v7 = INFINITY;
        float v5 = *(float *)(v3 + 8);
      }
      v3 += 24;
      --v6;
    }
    while (v6);
    int v9 = (double *)(*((void *)this + 3) + 8);
    while (1)
    {
      if ((*(_DWORD *)v9 & 0x7FFFFFFFu) <= 0x7F7FFFFF && *(float *)v9 != v5)
      {
        double v11 = *(v9 - 1);
        if (v11 >= v4 && v11 < v7) {
          break;
        }
      }
      v9 += 3;
      if (!--v2)
      {
        double v13 = v7;
        double v7 = v4;
        goto LABEL_21;
      }
    }
    double v13 = v4;
  }
  else
  {
    double v13 = 0.0;
    float v5 = INFINITY;
    double v7 = 0.0;
  }
LABEL_21:
  float64x2_t v61 = 0;
  uint64_t v59 = 0;
  float64x2_t v58 = 0uLL;
  uint64_t v62 = 0;
  uint64_t v63 = 32;
  RB::Path::ClipStroke::Subpath::append_logical_range((__n128 *)&v58, *((const RB::Path::ClipStroke::Subpath **)this + 1), v7, v13, 0);
  float64x2_t v48 = v58;
  int v14 = v61;
  if (v61) {
    __n128 v15 = v61;
  }
  else {
    __n128 v15 = v60;
  }
  float64x2_t v16 = (double *)&v15[8 * v62];
  double v18 = *(v16 - 2);
  double v17 = *(v16 - 1);
  double v46 = 0.0;
  double v47 = 0.0;
  *(float64x2_t *)&v57[0].v = v58;
  if (v62 > 0)
  {
    double v45 = 0.0;
    double v44 = 0.0;
    do
    {
      int v19 = (int)*(double *)v15;
      switch(v19)
      {
        case 4:
          long long v25 = *((_OWORD *)v15 + 1);
          *(_OWORD *)&v55[0].v = *((_OWORD *)v15 + 2);
          *(_OWORD *)&v56[0].v = v25;
          *(_OWORD *)&v53[0].v = *((_OWORD *)v15 + 3);
          CG::Cubic::Cubic((CG::Cubic *)&v49, v57, v56, v55, v53);
          if (v45 == 0.0 && v47 == 0.0)
          {
            double v45 = CG::Cubic::derivative((CG::Cubic *)&v49, 0.0);
            __n128 v27 = &v47;
          }
          else
          {
            double v44 = CG::Cubic::derivative((CG::Cubic *)&v49, 1.0);
            __n128 v27 = &v46;
          }
          *(void *)__n128 v27 = v26;
          *(_OWORD *)&v57[0].v = *(_OWORD *)&v53[0].v;
          v15 += 64;
          break;
        case 3:
          long long v22 = *((_OWORD *)v15 + 1);
          *(_OWORD *)&v55[0].v = *((_OWORD *)v15 + 2);
          *(_OWORD *)&v56[0].v = v22;
          CG::Quadratic::Quadratic((CG::Quadratic *)v54, v57, v56, v55);
          if (v45 == 0.0 && v47 == 0.0)
          {
            double v45 = CG::Quadratic::derivative(v54, 0.0);
            int8x16_t v24 = &v47;
          }
          else
          {
            double v44 = CG::Quadratic::derivative(v54, 1.0);
            int8x16_t v24 = &v46;
          }
          *(void *)int8x16_t v24 = v23;
          *(_OWORD *)&v57[0].v = *(_OWORD *)&v55[0].v;
          v15 += 48;
          break;
        case 2:
          double v20 = *((double *)v15 + 2);
          double v21 = *((double *)v15 + 3);
          if (v45 == 0.0 && v47 == 0.0)
          {
            double v47 = v21 - *(double *)&v57[2].v;
            double v45 = v20 - *(double *)&v57[0].v;
          }
          else
          {
            double v46 = v21 - *(double *)&v57[2].v;
            double v44 = v20 - *(double *)&v57[0].v;
          }
          *(double *)&v57[0].v = v20;
          *(double *)&v57[2].v = v21;
          v15 += 32;
          break;
      }
      int v14 = v61;
      if (v61) {
        __n128 v28 = v61;
      }
      else {
        __n128 v28 = v60;
      }
    }
    while (v15 < &v28[8 * v62]);
    if ((v45 != 0.0 || v47 != 0.0) && (v44 != 0.0 || v46 != 0.0))
    {
      uint64_t v29 = *(void *)this;
      float v30 = v5 - *(float *)(*(void *)this + 20);
      if (*(unsigned char *)(*(void *)this + 16)) {
        float v30 = -v30;
      }
      if (v30 > 0.0)
      {
        v32.f64[0] = v44;
        v31.f64[0] = v45;
        v31.f64[1] = v47;
        double v42 = v46;
        double v43 = v47;
        v32.f64[1] = v46;
        float64x2_t v33 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v32, 1.0 / sqrt(vaddvq_f64(vmulq_f64(v32, v32))))), v31, 1.0 / sqrt(vaddvq_f64(vmulq_f64(v31, v31))));
        float64x2_t v41 = vmulq_n_f64(v33, *((double *)this + 5) * v30 / sqrt(vaddvq_f64(vmulq_f64(v33, v33))));
        float64x2_t v48 = vaddq_f64(v41, v48);
        (*(void (**)(void))(**(void **)(v29 + 8) + 16))(*(void *)(v29 + 8));
        uint64_t v34 = 1;
        *((unsigned char *)this + 205) = 1;
        float64x2_t v49 = (float64x2_t)0x3FF0000000000000uLL;
        uint64_t v50 = 0;
        uint64_t v51 = 0x3FF0000000000000;
        float64x2_t v52 = v41;
        RB::Path::ClipStroke::Subpath::replay((uint64_t)&v58, *(uint64_t **)(*(void *)this + 8), 0, &v49);
        *((double *)this + 15) = v41.f64[0] + v18;
        *((double *)this + 16) = v41.f64[1] + v17;
        *((double *)this + 17) = v44;
        *((double *)this + 18) = v42;
        *((void *)this + 19) = 0;
        *((float *)this + 28) = v5;
        v54[0].f64[0] = -v45;
        v54[0].f64[1] = -v43;
        float64x2_t v39 = RB::Path::ClipStroke::Clipper::emit_cap((uint64_t *)this, &v48, v54, 0.0, -v43, v44, v35, v36, v37, v38);
        (*(void (**)(void, __n128))(**(void **)(*(void *)this + 8) + 8))(*(void *)(*(void *)this + 8), (__n128)v39);
        *((unsigned char *)this + 205) = 0;
        int v14 = v61;
        if (!v61) {
          return v34;
        }
        goto LABEL_58;
      }
    }
  }
  uint64_t v34 = 0;
  if (v14) {
LABEL_58:
  }
    free(v14);
  return v34;
}

long long *RB::vector<double,32ul,unsigned long>::swap_inline(long long *result, long long *a2)
{
  uint64_t v2 = *((void *)a2 + 32);
  uint64_t v3 = *((void *)result + 32);
  if (v2) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    long long v29 = a2[12];
    long long v30 = a2[13];
    long long v31 = a2[14];
    long long v32 = a2[15];
    long long v25 = a2[8];
    long long v26 = a2[9];
    long long v27 = a2[10];
    long long v28 = a2[11];
    long long v21 = a2[4];
    long long v22 = a2[5];
    long long v23 = a2[6];
    long long v24 = a2[7];
    long long v17 = *a2;
    long long v18 = a2[1];
    long long v19 = a2[2];
    long long v20 = a2[3];
    long long v5 = *result;
    long long v6 = result[1];
    long long v7 = result[3];
    a2[2] = result[2];
    a2[3] = v7;
    *a2 = v5;
    a2[1] = v6;
    long long v8 = result[4];
    long long v9 = result[5];
    long long v10 = result[7];
    a2[6] = result[6];
    a2[7] = v10;
    a2[4] = v8;
    a2[5] = v9;
    long long v11 = result[8];
    long long v12 = result[9];
    long long v13 = result[11];
    a2[10] = result[10];
    a2[11] = v13;
    a2[8] = v11;
    a2[9] = v12;
    long long v14 = result[12];
    long long v15 = result[13];
    long long v16 = result[15];
    a2[14] = result[14];
    a2[15] = v16;
    a2[12] = v14;
    a2[13] = v15;
    result[12] = v29;
    result[13] = v30;
    result[14] = v31;
    result[15] = v32;
    result[8] = v25;
    result[9] = v26;
    result[10] = v27;
    result[11] = v28;
    result[4] = v21;
    result[5] = v22;
    result[6] = v23;
    result[7] = v24;
    unsigned __int8 *result = v17;
    result[1] = v18;
    result[2] = v19;
    result[3] = v20;
    if (v3)
    {
      if (v2) {
        return result;
      }
    }
    else
    {
      *((void *)result + 32) = 0;
      if (v2) {
        return result;
      }
    }
    *((void *)a2 + 32) = 0;
  }
  return result;
}